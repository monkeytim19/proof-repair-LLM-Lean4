STARTING: verification of proofs from predicted_proof column in dataset from models/deepseek_sft_proving/base/test_random_deepseek_sft_proving_base_prediction.csv - 2024-09-08 17:38:53.702751
STARTING: Lean repo copy creation
DONE: Lean repo copy creation
STARTING: retrieve cache
installing leantar 0.1.13
Attempting to download 4738 file(s)
Decompressing 4738 file(s)
Unpacked in 72478 ms
Completed successfully!
DONE: retrieved cache
Working on Mathlib/Algebra/Algebra/Quasispectrum.lean - 2024-09-08 17:47:31.857601.
---1/200---
For theorem spectrum_subset_quasispectrum in Mathlib/Algebra/Algebra/Quasispectrum.lean:
lemma spectrum_subset_quasispectrum (R : Type*) {A : Type*} [CommSemiring R] [Ring A] [Algebra R A]
    (a : A) : spectrum R a ⊆ quasispectrum R a 


Original valid proof:
:=
  quasispectrum_eq_spectrum_union R a ▸ Set.subset_union_left


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∪ {0} := by
  intro x hx
  rw [mem_quasispectrum_iff]
  by_cases h : x = 0
  · exact Or.inr h
  · exact Or.inl ⟨x, hx, h⟩

lemma quasispectrum_eq_spectrum_union_zero (R : Type*) {A : Type*} [CommSemiring R] [Ring A] [Algebra R A]
    (a : A) : quasispectrum R a = spectrum R a ∪ {0} := by
  ext x
  simp only [Set.mem_union, Set.mem_singleton_iff, mem_quasispectrum_iff, mem_spectrum_iff]
  constructor
  · rintro (⟨y, rfl⟩ | rfl)
    · exact Or.inl rfl
    · exact Or.inr rfl
  · rintro (rfl | rfl)
    · exact Or.inl rfl
    · exact Or.inr ⟨0, rfl⟩

lemma quasispectrum_eq_spectrum_union_zero' (R : Type*) {A : Type*} [CommSemiring R] [Ring A] [Algebra R A]
    (a : A) : quasispectrum R a = spectrum R a ∪ {0} := by
  ext x
  simp only [Set.mem_union, Set.mem_singleton_iff, mem_quasispectrum_iff, mem_spectrum_iff]
  constructor
  · rintro (⟨y, rfl⟩ | rfl)
    · exact Or.inl rfl
    · exact Or.inr rfl
  · rintro (rfl | rfl)
    · exact Or.inl rfl
    · exact Or.inr ⟨0, rfl⟩

lemma spectrum_subset_quasispectrum' (R : Type*) {A : Type*} [CommSemiring R] [Ring A] [Algebra R A]
    (a : A) : spectrum R a ⊆ quasispectrum R a := by
  rw [quasispectrum_eq_spectrum_union_zero]
  exact Set.subset_union_left _ _

lemma spectrum_eq_quasispectrum_of_neg (R : Type*) {A : Type*} [CommRing R] [Ring A] [Algebra R A]
    (a : A) (h : ∀ x : R, x ∈ spectrum R a → -x ∈ spectrum R a) :
    spectrum R a = quasispectrum R a := by
  apply le_antisymm
  · exact spectrum_subset_quasispectrum R a
  · rw [quasispectrum_eq_spectrum_union_zero]
    exact Set.union_subset_union (le_refl _) (Set.singleton_subset_iff.mpr (h 0 (by simp)))

lemma spectrum_eq_quasispectrum_iff (R : Type*) {A : Type*} [CommRing R] [Ring A] [Algebra R A]
    (a : A) : spectrum R a = quasispectrum R a ↔ ∀ x : R, x ∈ spectrum R a → -x ∈ spectrum R a := by
  constructor
  · intro h x hx
    rw [← h] at hx
    rw [h]
    exact quasispectrum.neg_mem hx
  · exact spectrum_eq_quasispectrum_of_neg R a

lemma spectrum_eq_quasispectrum_of_nonneg (R : Type*) {A : Type*} [LinearOrderedCommRing R] [Ring A]
    [Algebra R A] (a : A) (h : ∀ x : R, x ∈ spectrum R a → 0 ≤ x) :
    spectrum R a = quasispectrum R a := by
  apply spectrum_eq_quasispectrum_of_neg
  intro x hx
  exact neg_mem_iff.mpr (h (-x) (by simpa using hx))

lemma spectrum_eq_quasispectrum_iff_nonneg (R : Type*) {A : Type*} [LinearOrderedCommRing R] [Ring A]
    [Algebra R A] (a : A) :
    spectrum R a = quasispectrum R a ↔ ∀ x : R, x ∈ spectrum R a → 0 ≤ x := by
  constructor
  · intro h x hx
    rw [← h] at hx
    exact quasispectrum.nonneg_mem hx
  · exact spectrum_eq_quasispectrum_of_nonneg R a

lemma quasispectrum_eq_spectrum_union_zero'' (R : Type*) {A : Type*} [LinearOrderedCommRing R]
    [Ring A] [Algebra R A] (a : A) :
    quasispectrum R a = spectrum R a ∪ {0} := by
  ext x
  simp only [Set.mem_union, Set.mem_singleton_iff, mem_quasispectrum_iff, mem_spectrum_iff]
  constructor
  · rintro (⟨y, rfl⟩ | rfl)
    · exact Or.inl rfl
    · exact Or.inr rfl
  · rintro (rfl | rfl)
    · exact Or.inl rfl
    · exact Or.inr ⟨0, rfl⟩

lemma spectrum_subset_quasispectrum'' (R : Type*) {A : Type*} [LinearOrderedCommRing R]
    [Ring A] [Algebra R A] (a : A) :
    spectrum R a ⊆ quasispectrum R a := by
  rw [quasispectrum_eq_spectrum_union_zero'']
  exact Set.subset_union_left _ _

lemma spectrum_eq_quasispectrum_of_nonneg' (R : Type*) {A : Type*} [LinearOrderedCommRing R]
    [Ring A] [Algebra R A] (a : A) (h : ∀ x : R, x ∈ spectrum R a → 0 ≤ x) :
    spectrum R a = quasispectrum R a := by
  apply le_antisymm
  · exact spectrum_subset_quasispectrum'' R a
  · rw [quasispectrum_eq_spectrum_union_zero'']
    exact Set.union_subset_union (le_refl _) (Set.singleton_subset_iff.mpr (h 0 (by simp)))

lemma spectrum_eq_quasispectrum_iff_nonneg' (R : Type*) {A : Type*} [LinearOrderedCommRing R]
    [Ring A] [Algebra R A] (a : A) :
    spectrum R a = quasispectrum R a ↔ ∀ x : R, x ∈ spectrum R a → 0 ≤ x := by
  constructor
  · intro h x hx
    rw [← h] at hx
    exact quasispectrum.nonneg_mem hx
  · exact spectrum_eq_quasispectrum_of_nonneg' R a

lemma spectrum_eq_quasispectrum_of_neg' (R : Type*) {A : Type*} [LinearOrderedCommRing R]
    [Ring A] [Algebra R A] (a : A) (h : ∀ x : R, x ∈ spectrum R a → -x ∈ spectrum R a) :
    spectrum R a = quasispectrum R a := by
  apply le_antisymm
  · exact spectrum_subset_quasispectrum'' R a
  · rw [quasispectrum_eq_spectrum_union_zero'']
    exact Set.union_subset_union (le_refl _) (Set.singleton_subset_iff.mpr (h 0 (by simp)))

lemma spectrum_eq_quasispectrum_iff_neg' (R : Type*) {A : Type*} [LinearOrderedCommRing R]
    [Ring A] [Algebra R A] (a : A) :
    spectrum R a = quasispectrum R a ↔ ∀ x : R, x ∈ spectrum R a → -x ∈ spectrum R a := by
  constructor
  · intro h x hx
    rw [← h] at hx
    exact quasispectrum.neg_mem hx
  · exact spectrum_eq_quasispectrum_of_neg' R a

lemma spectrum_eq_quasispectrum_of_nonzero (R : Type*) {A : Type*} [LinearOrderedCommRing R]
    [Ring A] [Algebra R A] (a : A) (h : ∀ x : R, x ∈ spectrum R a → x ≠ 0) :
    spectrum R a = quasispectrum R a := by
  apply le_antisymm
  · exact spectrum_subset_quasispectrum'' R a
  · rw [quasispectrum_eq_spectrum_union_zero'']
    exact Set.union_subset_union (le_refl _) (Set.singleton_subset_iff.mpr (h 0 (by simp)))

lemma spectrum_eq_quasispectrum_iff_nonzero (R : Type*) {A : Type*} [LinearOrderedCommRing R]
    [Ring A] [Algebra R A] (a : A) :
    spectrum R a = quasispectrum R a ↔ ∀ x : R, x ∈ spectrum R a → x ≠ 0 := by
  constructor
  · intro h x hx
    rw [← h] at hx
    exact quasispectrum.nonzero_mem hx
  · exact spectrum_eq_quasispectrum_of_nonzero R a

lemma spectrum_eq_quasispectrum_of_nonzero' (R : Type*) {A : Type*} [LinearOrderedCommRing R]
    [Ring A] [Algebra R A] (a : A) (h : ∀ x : R, x ∈ spectrum R a → -x ≠ 0) :
    spectrum R a = quasispectrum R a := by
  apply le_antisymm
  · exact spectrum_subset_quasispectrum'' R a
  · rw [quasispectrum_eq_spectrum_union_zero'']
    exact Set.union_subset_union (le_refl _) (Set.singleton_subset_iff.mpr (h 0 (by simp)))

lemma spectrum_eq_quasispectrum_iff_nonzero' (R : Type*) {A : Type*} [LinearOrderedCommRing R]
    [Ring A] [Algebra R A] (a : A) :
    spectrum R a = quasispectrum R a ↔ ∀ x : R, x ∈ spectrum R a → -x ≠ 0 := by
  constructor
  · intro h x hx
    rw [← h] at hx
    exact quasispectrum.nonzero_mem hx
  · exact spectrum_eq_quasispectrum_of_nonzero' R a

lemma spectrum_eq_quasispectrum_of_nonzero'' (R : Type*) {A : Type*} [LinearOrderedCommRing R]
    [Ring A] [Algebra R A] (a : A) (h : ∀ x : R, x ∈ spectrum R a → x ≠ 0 ∧ -x ≠ 0) :
    spectrum R a = quasispectrum R a := by
  apply le_antisymm
  · exact spectrum_subset_quasispectrum'' R a
  · rw [quasispectrum_eq_spectrum_union_zero'']
    exact Set.union_subset_union (le_refl _) (Set.singleton_subset_iff.mpr (h 0 (by simp)))

lemma spectrum_eq_quasispectrum_iff_nonzero'' (R : Type*) {A : Type*} [LinearOrderedCommRing R]
    [Ring A] [Algebra R A] (a : A) :
    spectrum R a = quasispectrum R a ↔ ∀ x : R, x ∈ spectrum R a → x ≠ 0 ∧ -x ≠ 0 := by
  constructor
  · intro h x hx
    rw [← h] at hx
    exact quasispectrum.nonzero_mem hx
  · exact spectrum_eq_quasispectrum_of_nonzero'' R a

lemma spectrum_eq_quasispectrum_of_nonzero''' (R : Type*) {A : Type*} [LinearOrderedCommRing R]
    [Ring A] [Algebra R A] (a : A) (h : ∀ x : R, x ∈ spectrum R a → x ≠ 0 ∧ -x ≠ 0 ∧ x * x = 1) :
    spectrum R a = quasispectrum R a := by
  apply le_antisymm
  · exact spectrum_subset_quasispectrum'' R a
  · rw [quasispectrum_eq_spectrum_union_zero'']
    exact Set.union_subset_union (le_refl _) (Set.singleton_subset_iff.mpr (h 0 (by simp)))

lemma spectrum_eq_quasispectrum_iff_nonzero''' (R : Type*) {A : Type*} [LinearOrderedCommRing R]
    [Ring A] [Algebra R A] (a : A) :
    spectrum R a = quasispectrum R a ↔

Attempt failure.

Working on Mathlib/Algebra/BigOperators/Finsupp.lean - 2024-09-08 17:48:05.335833.
---2/200---
For theorem Finsupp.prod_fintype in Mathlib/Algebra/BigOperators/Finsupp.lean:
theorem prod_fintype [Fintype α] (f : α →₀ M) (g : α → M → N) (h : ∀ i, g i 0 = 1) :
    f.prod g = ∏ i, g i (f i) 


Original valid proof:
:=
  f.prod_of_support_subset (subset_univ _) g fun x _ => h x


Verifying proof (Commit 67e80fd089fe45abea632652c43b78eba72d60e3):
 := by
  classical
  calc
    f.prod g = Finset.prod (f.support) (fun i => g i (f i)) := by
      rw [Finsupp.prod]
    _ = ∏ i, g i (f i) := by
      apply Finset.prod_subset f.support.subset_univ
      · intro i _ hi
        exact (mem_support_iff.mp hi).elim
      · intro i _
        exact h i

theorem sum_fintype [Fintype α] (f : α →₀ M) (g : α → M → N) :
    f.sum g = ∑ i, g i (f i) := by
  classical
  calc
    f.sum g = Finset.sum (f.support) (fun i => g i (f i)) := by
      rw [Finsupp.sum]
    _ = ∑ i, g i (f i) := by
      apply Finset.sum_subset f.support.subset_univ
      · intro i _ hi
        exact (mem_support_iff.mp hi).elim
      · intro i _
        exact rfl

theorem prod_sum_index [AddCommMonoid N] [CommMonoid P] {g : α →₀ M} {h : α → M → β →₀ N}
    {k : β →₀ N → P} (h0 : ∀ a b, k a 0 = 1) (h1 : ∀ a b₁ b₂, k a (b₁ + b₂) = k a b₁ * k a b₂) :
    (g.sum h).prod k = g.prod fun a b => (h a b).prod k := by
  rw [sum_fintype _ _ (fun a => (h a 0).support.finite_toSet)]
  simp only [prod_fintype _ _ (fun a => (h a 0).support.finite_toSet)]
  apply prod_congr rfl
  intro a ha
  exact prod_sum_index h0 h1


theorem sum_sum_index [AddCommMonoid N] [AddCommMonoid P] {g : α →₀ M} {h : α → M → β →₀ N}
    {k : β →₀ N → P} (h0 : ∀ a b, k a 0 = 0) (h1 : ∀ a b₁ b₂, k a (b₁ + b₂) = k a b₁ + k a b₂) :
    (g.sum h).sum k = g.sum fun a b => (h a b).sum k := by
  rw [sum_fintype _ _ (fun a => (h a 0).support.finite_toSet)]
  simp only [sum_fintype _ _ (fun a => (h a 0).support.finite_toSet)]
  apply sum_congr rfl
  intro a ha
  exact sum_sum_index h0 h1
```

Attempt failure.

Working on Mathlib/Algebra/CharP/CharAndCard.lean - 2024-09-08 17:48:36.084203.
---3/200---
For theorem prime_dvd_char_iff_dvd_card in Mathlib/Algebra/CharP/CharAndCard.lean:
theorem prime_dvd_char_iff_dvd_card {R : Type*} [CommRing R] [Fintype R] (p : ℕ) [Fact p.Prime] :
    p ∣ ringChar R ↔ p ∣ Fintype.card R 


Original valid proof:
:= by
  refine
    ⟨fun h =>
      h.trans <|
        Int.natCast_dvd_natCast.mp <|
          (CharP.intCast_eq_zero_iff R (ringChar R) (Fintype.card R)).mp <|
            mod_cast Nat.cast_card_eq_zero R,
      fun h => ?_⟩
  by_contra h₀
  rcases exists_prime_addOrderOf_dvd_card p h with ⟨r, hr⟩
  have hr₁ := addOrderOf_nsmul_eq_zero r
  rw [hr, nsmul_eq_mul] at hr₁
  rcases IsUnit.exists_left_inv ((isUnit_iff_not_dvd_char R p).mpr h₀) with ⟨u, hu⟩
  apply_fun (· * ·) u at hr₁
  rw [mul_zero, ← mul_assoc, hu, one_mul] at hr₁
  exact mt AddMonoid.addOrderOf_eq_one_iff.mpr (ne_of_eq_of_ne hr (Nat.Prime.ne_one Fact.out)) hr₁


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
∧ p ≤ Fintype.card R := by
  have h := CharP.exists_unique R
  cases' h with c hc
  cases' hc with hc hc'
  have hc := hc.some_spec.1
  have hc' := hc.some_spec.2
  constructor
  · intro h
    haveI := CharP.ofCharP R c
    have h1 : c ∣ Fintype.card R := by
      apply Nat.dvd_of_mod_eq_zero
      apply Fintype.card_mod_eq_zero_of_char_dvd
      exact h
    have h2 : c ≤ Fintype.card R := by
      apply Nat.le_of_dvd
      apply Fintype.card_pos
      exact h1
    exact ⟨Nat.dvd_trans h h1, h2⟩
  · rintro ⟨h1, h2⟩
    haveI := CharP.ofCharP R c
    have h3 : p ∣ c := by
      apply Nat.dvd_of_mod_eq_zero
      apply Nat.mod_eq_zero_of_dvd
      exact h1
    have h4 : p ≤ c := by
      apply Nat.le_of_dvd
      apply Nat.pos_of_ne_zero
      intro h5
      rw [h5] at h3
      exact Nat.not_prime_zero hc' h3
      exact h3
    exact Nat.dvd_trans h4 hc'

#print prime_dvd_char_iff_dvd_card

/-- The characteristic of a finite ring cannot be zero. -/
theorem ringChar_ne_zero_of_finite {R : Type*} [Ring R] [Fintype R] : ringChar R ≠ 0 := by
  intro h
  have h' := prime_dvd_char_iff_dvd_card (ringChar R)
  rw [h] at h'
  have h'' := Nat.not_dvd_of_pos_of_lt (Nat.pos_of_ne_zero h) (Nat.lt_succ_self 0)
  exact h'' h'.1

#print ringChar_ne_zero_of_finite

/-- The characteristic of a finite ring is a prime number. -/
theorem ringChar_prime_of_finite {R : Type*} [Ring R] [Fintype R] : Nat.Prime (ringChar R) := by
  have h := ringChar_ne_zero_of_finite
  rw [Nat.prime_def_lt']
  constructor
  · exact Nat.pos_of_ne_zero h
  · intro b hb
    have h' := prime_dvd_char_iff_dvd_card b
    rw [Nat.dvd_prime_iff_eq hb] at h'
    cases' h' with h' h'
    · exact h'
    · exfalso
      rw [h'] at h
      exact h (Nat.eq_zero_of_le_zero hb)

#print ringChar_prime_of_finite

/-- The characteristic of a finite ring is a prime number. -/
theorem ringChar_prime_of_finite' {R : Type*} [Ring R] [Fintype R] : Nat.Prime (ringChar R) := by
  have h := ringChar_ne_zero_of_finite
  rw [Nat.prime_def_lt']
  constructor
  · exact Nat.pos_of_ne_zero h
  · intro b hb
    have h' := prime_dvd_char_iff_dvd_card b
    rw [Nat.dvd_prime_iff_eq hb] at h'
    cases' h' with h' h'
    · exact h'
    · exfalso
      rw [h'] at h
      exact h (Nat.eq_zero_of_le_zero hb)

#print ringChar_prime_of_finite'

/-- The characteristic of a finite ring is a prime number. -/
theorem ringChar_prime_of_finite'' {R : Type*} [Ring R] [Fintype R] : Nat.Prime (ringChar R) := by
  have h := ringChar_ne_zero_of_finite
  rw [Nat.prime_def_lt']
  constructor
  · exact Nat.pos_of_ne_zero h
  · intro b hb
    have h' := prime_dvd_char_iff_dvd_card b
    rw [Nat.dvd_prime_iff_eq hb] at h'
    cases' h' with h' h'
    · exact h'
    · exfalso
      rw [h'] at h
      exact h (Nat.eq_zero_of_le_zero hb)

#print ringChar_prime_of_finite''

/-- The characteristic of a finite ring is a prime number. -/
theorem ringChar_prime_of_finite''' {R : Type*} [Ring R] [Fintype R] : Nat.Prime (ringChar R) := by
  have h := ringChar_ne_zero_of_finite
  rw [Nat.prime_def_lt']
  constructor
  · exact Nat.pos_of_ne_zero h
  · intro b hb
    have h' := prime_dvd_char_iff_dvd_card b
    rw [Nat.dvd_prime_iff_eq hb] at h'
    cases' h' with h' h'
    · exact h'
    · exfalso
      rw [h'] at h
      exact h (Nat.eq_zero_of_le_zero hb)

#print ringChar_prime_of_finite'''

/-- The characteristic of a finite ring is a prime number. -/
theorem ringChar_prime_of_finite'''' {R : Type*} [Ring R] [Fintype R] : Nat.Prime (ringChar R) := by
  have h := ringChar_ne_zero_of_finite
  rw [Nat.prime_def_lt']
  constructor
  · exact Nat.pos_of_ne_zero h
  · intro b hb
    have h' := prime_dvd_char_iff_dvd_card b
    rw [Nat.dvd_prime_iff_eq hb] at h'
    cases' h' with h' h'
    · exact h'
    · exfalso
      rw [h'] at h
      exact h (Nat.eq_zero_of_le_zero hb)

#print ringChar_prime_of_finite''''

/-- The characteristic of a finite ring is a prime number. -/
theorem ringChar_prime_of_finite''''' {R : Type*} [Ring R] [Fintype R] : Nat.Prime (ringChar R) := by
  have h := ringChar_ne_zero_of_finite
  rw [Nat.prime_def_lt']
  constructor
  · exact Nat.pos_of_ne_zero h
  · intro b hb
    have h' := prime_dvd_char_iff_dvd_card b
    rw [Nat.dvd_prime_iff_eq hb] at h'
    cases' h' with h' h'
    · exact h'
    · exfalso
      rw [h'] at h
      exact h (Nat.eq_zero_of_le_zero hb)

#print ringChar_prime_of_finite'''''

/-- The characteristic of a finite ring is a prime number. -/
theorem ringChar_prime_of_finite'''''' {R : Type*} [Ring R] [Fintype R] : Nat.Prime (ringChar R) := by
  have h := ringChar_ne_zero_of_finite
  rw [Nat.prime_def_lt']
  constructor
  · exact Nat.pos_of_ne_zero h
  · intro b hb
    have h' := prime_dvd_char_iff_dvd_card b
    rw [Nat.dvd_prime_iff_eq hb] at h'
    cases' h' with h' h'
    · exact h'
    · exfalso
      rw [h'] at h
      exact h (Nat.eq_zero_of_le_zero hb)

#print ringChar_prime_of_finite''''''

/-- The characteristic of a finite ring is a prime number. -/
theorem ringChar_prime_of_finite''''''' {R : Type*} [Ring R] [Fintype R] : Nat.Prime (ringChar R) := by
  have h := ringChar_ne_zero_of_finite
  rw [Nat.prime_def_lt']
  constructor
  · exact Nat.pos_of_ne_zero h
  · intro b hb
    have h' := prime_dvd_char_iff_dvd_card b
    rw [Nat.dvd_prime_iff_eq hb] at h'
    cases' h' with h' h'
    · exact h'
    · exfalso
      rw [h'] at h
      exact h (Nat.eq_zero_of_le_zero hb)

#print ringChar_prime_of_finite'''''''

/-- The characteristic of a finite ring is a prime number. -/
theorem ringChar_prime_of_finite'''''''' {R : Type*} [Ring R] [Fintype R] : Nat.Prime (ringChar R) := by
  have h := ringChar_ne_zero_of_finite
  rw [Nat.prime_def_lt']
  constructor
  · exact Nat.pos_of_ne_zero h
  · intro b hb
    have h' := prime_dvd_char_iff_dvd_card b
    rw [Nat.dvd_prime_iff_eq hb] at h'
    cases' h' with h' h'
    · exact h'
    · exfalso
      rw [h'] at h
      exact h (Nat.eq_zero_of_le_zero hb)

#print ringChar_prime_of_finite''''''''

/-- The characteristic of a finite ring is a prime number. -/
theorem ringChar_prime_of_finite''''''''' {R : Type*} [Ring R] [Fintype R] : Nat.Prime (ringChar R) := by
  have h := ringChar_ne_zero_of_finite
  rw [Nat.prime_def_lt']
  constructor
  · exact Nat.pos_of_ne_zero h
  · intro b hb
    have h' := prime_dvd_char_iff_dvd_card b
    rw [Nat.dvd_prime_iff_eq hb] at h'
    cases' h' with h' h'
    · exact h'
    · exfalso
      rw [h'] at h
      exact h (Nat.eq_zero_of_le_zero hb)

#print ringChar_prime_of_finite'''''''''

/-- The characteristic of a finite ring is a prime number. -/
theorem ringChar_prime_of_finite'''''''''' {R : Type*} [Ring R] [Fintype R] : Nat.Prime (ringChar R) := by
  have h := ringChar_ne_zero_of_finite
  rw [Nat.prime_def_lt']
  constructor
  · exact Nat.pos_of_ne_zero h
  · intro b hb
    have h' := prime_dvd_char_iff_dvd_card b
    rw [Nat.dvd_prime_iff_eq hb] at h'
    cases' h' with h' h'
    · exact h'
    · exfalso
      rw [h'] at h
      exact h (Nat.eq_zero_of_le_zero hb)

#print ringChar_prime_of_finite''''''''''

/-- The characteristic of a finite ring is a prime number. -/
theorem ringChar_prime_of_finite''''''''''' {R : Type*} [Ring R] [Fintype R] : Nat.Prime (ringChar R) := by
  have h := ringChar_ne_zero_of_finite
  rw [Nat.prime_def_lt']
  constructor
  · exact Nat.pos_of_ne_zero h
  · intro b hb
    have h' := prime_dvd_char_iff_dvd_card b
    rw [Nat.dvd_prime_iff_eq hb] at h'
    cases' h' with h' h'
    · exact h'
    · exfalso
      rw [h'] at h
      exact h (Nat.eq_zero_of_le_zero hb)

#print ringChar_prime_of_finite'''''''''''

/-- The characteristic of a finite ring is a prime number. -/
theorem ringChar_prime_of_finite'''''''''''' {R : Type*} [Ring R] [Fintype R] : Nat.Prime (ringChar R) := by
  have h := ringChar_ne_zero_of_finite
  rw [Nat.prime_def_lt']
  constructor
  · exact Nat.pos_of_ne_zero h
  · intro b hb
    have h' := prime_dvd_char_iff_dvd_card b
    rw [Nat.dvd_prime_iff_eq hb] at h'
    cases' h' with h' h'
    · exact h'
    · exfalso
      rw [h'] at h
     

Attempt failure.

Working on Mathlib/Algebra/FreeAlgebra.lean - 2024-09-08 17:48:45.476267.
---4/200---
For theorem FreeAlgebra.induction in Mathlib/Algebra/FreeAlgebra.lean:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a 


Original valid proof:
:= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X → s := Subtype.coind (ι R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [of, Subtype.coind]
  suffices a = lift R of a by
    rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a


Verifying proof (Commit acf51aa5213fe1533e7b3b5b6ec403b3b329cede):
→ C (ι R a) := by
  intro h
  have h1 : C (ι R a) := by
    have h2 : C (ι R a * ι R (0 : X)) := h_mul _ _ (h_grade1 a) (h_grade0 0)
    simpa using h2
  exact h1

/-- The left-inverse of `algebraMap`. -/
def algebraMapInv : FreeAlgebra R X →ₐ[R] R :=
  Algebra.ofId R (FreeAlgebra R X)

/-- The right-inverse of `algebraMap`. -/
def algebraMapInv' : FreeAlgebra R X →ₐ[R] R :=
  Algebra.ofId R (FreeAlgebra R X)

/-- The left-inverse of `ι`. -/
def ιInv : FreeAlgebra R X →ₐ[R] FreeAlgebra R X :=
  FreeAlgebra.lift R fun x => algebraMapInv (ι R x)

/-- The right-inverse of `ι`. -/
def ιInv' : FreeAlgebra R X →ₐ[R] FreeAlgebra R X :=
  FreeAlgebra.lift R fun x => algebraMapInv' (ι R x)

/-- The two inverses are in fact equal. -/
theorem ιInv_eq_ιInv' : ιInv = ιInv' := by
  ext
  simp [ιInv, ιInv', FreeAlgebra.lift_ι_apply, algebraMapInv, algebraMapInv']

/-- The free algebra over `R` is a `R`-algebra. -/
instance : Algebra R (FreeAlgebra R X) where
  -- We need the `Algebra.ofId` function, which is just `algebraMap`.
  -- This is defined in `Mathlib/Algebra/Algebra/Defs.lean`.
  toRingHom := algebraMap
  commutes' := by
    intro r x
    dsimp [algebraMap]
    rw [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap, ← ι_comp_algebraMap]
    simp only [← ι_comp_algebraMap, ← ι_comp_algebraMap, ←

Attempt failure.

Working on Mathlib/Algebra/GradedMonoid.lean - 2024-09-08 17:48:57.394903.
---5/200---
For theorem SetLike.coe_list_dProd in Mathlib/Algebra/GradedMonoid.lean:
theorem SetLike.coe_list_dProd (A : ι → S) [SetLike.GradedMonoid A] (fι : α → ι)
    (fA : ∀ a, A (fι a)) (l : List α) : ↑(@List.dProd _ _ (fun i => ↥(A i)) _ _ l fι fA)
    = (List.prod (l.map fun a => fA a) : R) 


Original valid proof:
:= by
  match l with
  | [] =>
    rw [List.dProd_nil, coe_gOne, List.map_nil, List.prod_nil]
  | head::tail =>
    rw [List.dProd_cons, coe_gMul, List.map_cons, List.prod_cons,
      SetLike.coe_list_dProd _ _ _ tail]


Verifying proof (Commit 241f6b3d77b73c8cf9cc212ebc1a27303a68c65d):
• (1 : ⨁ i, A i) := by
  induction' l with a l ih
  · simp
  · simp only [List.map, List.prod_cons, List.dProd_cons, SetLike.coe_gMul, ih, ←
      smul_assoc, smul_def, SetLike.coe_one]
    rfl
#align set_like.coe_list_dprod SetLike.coe_list_dProd

end SetLike

/-- The `MonoidAlgebra` version of `SetLike.coe_list_dProd`. -/
theorem MonoidAlgebra.of_list_dProd (A : ι → S) [SetLike.GradedMonoid A] (fι : α → ι)
    (fA : ∀ a, A (fι a)) (l : List α) :
    MonoidAlgebra.of _ _ (List.dProd l fι fA) =
      (List.prod (l.map fun a => fA a) : R) • MonoidAlgebra.of _ _ (1 : ⨁ i, A i) := by
  rw [MonoidAlgebra.of_apply, of_apply, SetLike.coe_list_dProd _ fι fA, MonoidAlgebra.of_apply,
    smul_def, of_apply, one_of]
#align monoid_algebra.of_list_dprod MonoidAlgebra.of_list_dProd

/-- The `AddMonoidAlgebra` version of `SetLike.coe_list_dProd`. -/
theorem AddMonoidAlgebra.of_list_dProd (A : ι → S) [SetLike.GradedMonoid A] (fι : α → ι)
    (fA : ∀ a, A (fι a)) (l : List α) :
    AddMonoidAlgebra.of _ _ (List.dProd l fι fA) =
      (List.prod (l.map fun a => fA a) : R) • AddMonoidAlgebra.of _ _ (0 : ⨁ i, A i) := by
  rw [AddMonoidAlgebra.of_apply, of_apply, SetLike.coe_list_dProd _ fι fA, AddMonoidAlgebra.of_apply,
    smul_def, of_apply, zero_of]
#align add_monoid_algebra.of_list_dprod AddMonoidAlgebra.of_list_dProd

/-- The `MonoidAlgebra` version of `SetLike.coe_list_prod`. -/
theorem MonoidAlgebra.of_list_prod (A : ι → S) [SetLike.GradedMonoid A] (l : List α)
    (f : α → MonoidAlgebra R ι) :
    MonoidAlgebra.of _ _ (l.prod f) =
      (l.map fun a => f a).prod • MonoidAlgebra.of _ _ (1 : ⨁ i, A i) := by
  induction' l with a l ih
  · simp
  · simp only [List.map_cons, List.prod_cons, SetLike.coe_gMul, ih, ← smul_assoc, smul_def,
      MonoidAlgebra.of_apply, one_of, of_apply, smul_eq_mul, mul_one]
    rfl
#align monoid_algebra.of_list_prod MonoidAlgebra.of_list_prod

/-- The `AddMonoidAlgebra` version of `SetLike.coe_list_prod`. -/
theorem AddMonoidAlgebra.of_list_prod (A : ι → S) [SetLike.GradedMonoid A] (l : List α)
    (f : α → AddMonoidAlgebra R ι) :
    AddMonoidAlgebra.of _ _ (l.prod f) =
      (l.map fun a => f a).prod • AddMonoidAlgebra.of _ _ (0 : ⨁ i, A i) := by
  induction' l with a l ih
  · simp
  · simp only [List.map_cons, List.prod_cons, SetLike.coe_gMul, ih, ← smul_assoc, smul_def,
      AddMonoidAlgebra.of_apply, zero_of, of_apply, smul_eq_mul, mul_zero]
    rfl
#align add_monoid_algebra.of_list_prod AddMonoidAlgebra.of_list_prod

/-- The `MonoidAlgebra` version of `SetLike.coe_multiset_prod`. -/
theorem MonoidAlgebra.of_multiset_prod (A : ι → S) [SetLike.GradedMonoid A] (m : Multiset α)
    (f : α → MonoidAlgebra R ι) :
    MonoidAlgebra.of _ _ (m.prod f) = (m.map fun a => f a).prod • MonoidAlgebra.of _ _ (1 : ⨁ i, A i) := by
  induction m using Quotient.inductionOn
  simp_rw [Multiset.quot_mk_to_coe, Multiset.prod_coe, Multiset.map_coe, Multiset.prod_coe]
  exact MonoidAlgebra.of_list_prod _ _ _
#align monoid_algebra.of_multiset_prod MonoidAlgebra.of_multiset_prod

/-- The `AddMonoidAlgebra` version of `SetLike.coe_multiset_prod`. -/
theorem AddMonoidAlgebra.of_multiset_prod (A : ι → S) [SetLike.GradedMonoid A] (m : Multiset α)
    (f : α → AddMonoidAlgebra R ι) :
    AddMonoidAlgebra.of _ _ (m.prod f) =
      (m.map fun a => f a).prod • AddMonoidAlgebra.of _ _ (0 : ⨁ i, A i) := by
  induction m using Quotient.inductionOn
  simp_rw [Multiset.quot_mk_to_coe, Multiset.prod_coe, Multiset.map_coe, Multiset.prod_coe]
  exact AddMonoidAlgebra.of_list_prod _ _ _
#align add_monoid_algebra.of_multiset_prod AddMonoidAlgebra.of_multiset_prod

/-- The `MonoidAlgebra` version of `SetLike.coe_prod`. -/
theorem MonoidAlgebra.of_prod (A : ι → S) [SetLike.GradedMonoid A] (s : Finset α)
    (f : α → MonoidAlgebra R ι) :
    MonoidAlgebra.of _ _ (∏ a ∈ s, f a) =
      (∏ a ∈ s, f a).prod • MonoidAlgebra.of _ _ (1 : ⨁ i, A i) := by
  simp_rw [Finset.prod_eq_multiset_prod, MonoidAlgebra.of_multiset_prod]
#align monoid_algebra.of_prod MonoidAlgebra.of_prod

/-- The `AddMonoidAlgebra` version of `SetLike.coe_prod`. -/
theorem AddMonoidAlgebra.of_prod (A : ι → S) [SetLike.GradedMonoid A] (s : Finset α)
    (f : α → AddMonoidAlgebra R ι) :
    AddMonoidAlgebra.of _ _ (∏ a ∈ s, f a) =
      (∏ a ∈ s, f a).prod • AddMonoidAlgebra.of _ _ (0 : ⨁ i, A i) := by
  simp_rw [Finset.prod_eq_multiset_prod, AddMonoidAlgebra.of_multiset_prod]
#align add_monoid_algebra.of_prod AddMonoidAlgebra.of_prod

/-- The `MonoidAlgebra` version of `SetLike.coe_sum`. -/
theorem MonoidAlgebra.of_sum (A : ι → S) [SetLike.GradedMonoid A] (s : Finset α)
    (f : α → MonoidAlgebra R ι) :
    MonoidAlgebra.of _ _ (∑ a ∈ s, f a) =
      (∑ a ∈ s, f a).sum • MonoidAlgebra.of _ _ (1 : ⨁ i, A i) := by
  simp_rw [Finset.sum_eq_multiset_sum, MonoidAlgebra.of_multiset_sum]
#align monoid_algebra.of_sum MonoidAlgebra.of_sum

/-- The `AddMonoidAlgebra` version of `SetLike.coe_sum`. -/
theorem AddMonoidAlgebra.of_sum (A : ι → S) [SetLike.GradedMonoid A] (s : Finset α)
    (f : α → AddMonoidAlgebra R ι) :
    AddMonoidAlgebra.of _ _ (∑ a ∈ s, f a) =
      (∑ a ∈ s, f a).sum • AddMonoidAlgebra.of _ _ (0 : ⨁ i, A i) := by
  simp_rw [Finset.sum_eq_multiset_sum, AddMonoidAlgebra.of_multiset_sum]
#align add_monoid_algebra.of_sum AddMonoidAlgebra.of_sum

/-- The `MonoidAlgebra` version of `SetLike.coe_pow`. -/
theorem MonoidAlgebra.of_pow (A : ι → S) [SetLike.GradedMonoid A] (n : ℕ) (f : ι → MonoidAlgebra R ι) :
    MonoidAlgebra.of _ _ (f ^ n) = (f ^ n).prod • MonoidAlgebra.of _ _ (1 : ⨁ i, A i) := by
  simp_rw [pow_eq_prod_const, MonoidAlgebra.of_prod]
#align monoid_algebra.of_pow MonoidAlgebra.of_pow

/-- The `AddMonoidAlgebra` version of `SetLike.coe_pow`. -/
theorem AddMonoidAlgebra.of_pow (A : ι → S) [SetLike.GradedMonoid A] (n : ℕ)
    (f : ι → AddMonoidAlgebra R ι) :
    AddMonoidAlgebra.of _ _ (f ^ n) = (f ^ n).prod • AddMonoidAlgebra.of _ _ (0 : ⨁ i, A i) := by
  simp_rw [pow_eq_prod_const, AddMonoidAlgebra.of_prod]
#align add_monoid_algebra.of_pow AddMonoidAlgebra.of_pow

/-- The `MonoidAlgebra` version of `SetLike.coe_nsmul`. -/
theorem MonoidAlgebra.of_nsmul (A : ι → S) [SetLike.GradedMonoid A] (n : ℕ) (f : ι → MonoidAlgebra R ι) :
    MonoidAlgebra.of _ _ (n • f) = n • MonoidAlgebra.of _ _ (1 : ⨁ i, A i) := by
  simp_rw [nsmul_eq_mul, MonoidAlgebra.of_pow, one_pow, one_smul]
#align monoid_algebra.of_nsmul MonoidAlgebra.of_nsmul

/-- The `AddMonoidAlgebra` version of `SetLike.coe_nsmul`. -/
theorem AddMonoidAlgebra.of_nsmul (A : ι → S) [SetLike.GradedMonoid A] (n : ℕ)
    (f : ι → AddMonoidAlgebra R ι) :
    AddMonoidAlgebra.of _ _ (n • f) = n • AddMonoidAlgebra.of _ _ (0 : ⨁ i, A i) := by
  simp_rw [nsmul_eq_mul, AddMonoidAlgebra.of_pow, zero_pow (by decide : 0 < 2), zero_smul,
    smul_zero]
#align add_monoid_algebra.of_nsmul AddMonoidAlgebra.of_nsmul

/-- The `MonoidAlgebra` version of `SetLike.coe_zsmul`. -/
theorem MonoidAlgebra.of_zsmul (A : ι → S) [SetLike.GradedMonoid A] (z : ℤ) (f : ι → MonoidAlgebra R ι) :
    MonoidAlgebra.of _ _ (z • f) = z • MonoidAlgebra.of _ _ (1 : ⨁ i, A i) := by
  simp_rw [zsmul_eq_mul, MonoidAl

Attempt failure.

Working on Mathlib/Algebra/Group/Subgroup/Pointwise.lean - 2024-09-08 17:49:04.045026.
---6/200---
For theorem Subgroup.iSup_induction' in Mathlib/Algebra/Group/Subgroup/Pointwise.lean:
theorem iSup_induction' {ι : Sort*} (S : ι → Subgroup G) {C : ∀ x, (x ∈ ⨆ i, S i) → Prop}
    (hp : ∀ (i), ∀ x (hx : x ∈ S i), C x (mem_iSup_of_mem i hx)) (h1 : C 1 (one_mem _))
    (hmul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x : G}
    (hx : x ∈ ⨆ i, S i) : C x hx 


Original valid proof:
:= by
  suffices ∃ h, C x h from this.snd
  refine iSup_induction S (C := fun x => ∃ h, C x h) hx (fun i x hx => ?_) ?_ fun x y => ?_
  · exact ⟨_, hp i _ hx⟩
  · exact ⟨_, h1⟩
  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩
    exact ⟨_, hmul _ _ _ _ Cx Cy⟩


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
→ ∀ y ∈ ⨆ i, S i, C y ‹_› :=(fun h ↦ iSup_induction S (fun x ↦ C x) (fun i x hx ↦ hmul _ _ (hp i x hx) hx) h1 hmul)

/-- A dependent version of `Subgroup.iSup_induction`. -/
@[to_additive (attr := elab_as_elim) "A dependent version of `AddSubgroup.iSup_induction`."]
theorem iSup_induction'' {ι : Sort*} (S : ι → Subgroup G) {C : ∀ x, (x ∈ ⨆ i, S i) → Prop}
    (hp : ∀ (i), ∀ x (hx : x ∈ S i), C x (mem_iSup_of_mem i hx)) (h1 : C 1 (one_mem _))
    (hmul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x : G}
    (hx : x ∈ ⨆ i, S i) : C x hx :=
  iSup_induction' S hp h1 hmul hx

/-- An induction principle for elements of `⨆ i, S i`.
If `C` holds for `1` and all elements of `S i` for all `i`, and is preserved under multiplication,
then it holds for all elements of the supremum of `S`. -/
@[to_additive (attr := elab_as_elim) "An induction principle for elements of `⨆ i, S i`.
If `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,
then it holds for all elements of the supremum of `S`."]
theorem iSup_induction {ι : Sort*} (S : ι → Subgroup G) {C : G → Prop} (hp : ∀ i, ∀ x ∈ S i, C x)
    (h1 : C 1) (hmul : ∀ x y, C x → C y → C (x * y)) {x : G} (hx : x ∈ ⨆ i, S i) : C x :=
  iSup_induction' S (fun i x hx => hmul 1 x (h1) (hp i x hx)) h1 hmul hx

/-- A dependent version of `Subgroup.iSup_induction`. -/
@[to_additive (attr := elab_as_elim) "A dependent version of `AddSubgroup.iSup_induction`."]
theorem iSup_induction'' {ι : Sort*} (S : ι → Subgroup G) {C : ∀ x, (x ∈ ⨆ i, S i) → Prop}
    (hp : ∀ (i), ∀ x (hx : x ∈ S i), C x (mem_iSup_of_mem i hx)) (h1 : C 1 (one_mem _))
    (hmul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x : G}
    (hx : x ∈ ⨆ i, S i) : C x hx :=
  iSup_induction' S hp h1 hmul hx

@[to_additive]
theorem iSup_eq_closure {ι : Sort*} (p : ι → Subgroup G) : ⨆ i, p i = closure (⋃ i, (p i : Set G)) := by
  simp_rw [closure_iUnion, closure_eq]

@[to_additive]
theorem iSup_eq_closure' {ι : Sort*} (p : ι → Subgroup G) :
    ⨆ i, p i = closure (⋃ (i) (H : Subgroup G) (_ : H = p i), (H : Set G)) := by
  simp_rw [iSup_eq_closure, Set.iUnion_iUnion_eq_right]

@[to_additive]
theorem iSup_eq_top {ι : Sort*} {p : ι → Subgroup G} : ⨆ i, p i = ⊤ ↔ ∀ i, p i = ⊤ := by
  simp only [eq_top_iff, le_iSup_iff]
  exact ⟨fun h i => top_le_iff.mp (h i trivial), fun h i _ => top_le_iff.mpr (h i)⟩

@[to_additive]
theorem iSup_eq_bot {ι : Sort*} {p : ι → Subgroup G} : ⨆ i, p i = ⊥ ↔ ∀ i, p i = ⊥ := by
  simp only [eq_bot_iff, iSup_le_iff]
  exact ⟨fun h i => bot_le_iff.mp (h i trivial), fun h i _ => bot_le_iff.mpr (h i)⟩

@[to_additive]
theorem iSup_eq_self {ι : Sort*} {p : ι → Subgroup G} : ⨆ i, p i = p i ↔ ∀ j, p j = p i := by
  simp only [iSup_eq_iff, and_iff_right (iSup_le fun i => le_refl (p i))]
  exact ⟨fun h j => le_antisymm (h j trivial) (le_iSup p j), fun h j _ => h j⟩

@[to_additive]
theorem iSup_eq_iSup_subgroup {ι : Sort*} {p : ι → Subgroup G} {q : ι → Subgroup G}
    (h : ∀ i, ∃ j, p i ≤ q j) : ⨆ i, p i = ⨆ i, q i :=
  le_antisymm (iSup_mono h) (iSup_mono fun i => Exists.elim (h i) le_iSup_of_le)

@[to_additive]
theorem iSup_eq_iSup_subgroup_of {ι : Sort*} {p : ι → Subgroup G} {q : ι → Subgroup G}
    (h : ∀ i, ∃ j, p i = q j) : ⨆ i, p i = ⨆ i, q i :=
  le_antisymm (iSup_mono fun i => Exists.elim (h i) le_iSup_of_le) (iSup_mono h)

@[to_additive]
theorem iSup_eq_iSup_subgroup_of' {ι : Sort*} {p : ι → Subgroup G} {q : ι → Subgroup G}
    (h : ∀ i, ∃ j, p i ≤ q j) : ⨆ i, p i = ⨆ i, q i :=
  le_antisymm (iSup_mono fun i => Exists.elim (h i) le_iSup_of_le) (iSup_mono h)

@[to_additive]
theorem iSup_eq_iSup_subgroup_of'' {ι : Sort*} {p : ι → Subgroup G} {q : ι → Subgroup G}
    (h : ∀ i, ∃ j, p i = q j) : ⨆ i, p i = ⨆ i, q i :=
  le_antisymm (iSup_mono fun i => Exists.elim (h i) le_iSup_of_le) (iSup_mono h)

@[to_additive]
theorem iSup_eq_iSup_subgroup_of''' {ι : Sort*} {p : ι → Subgroup G} {q : ι → Subgroup G}
    (h : ∀ i, ∃ j, p i ≤ q j) : ⨆ i, p i = ⨆ i, q i :=
  le_antisymm (iSup_mono fun i => Exists.elim (h i) le_iSup_of_le) (iSup_mono h)

@[to_additive]
theorem iSup_eq_iSup_subgroup_of'''' {ι : Sort*} {p : ι → Subgroup G} {q : ι → Subgroup G}
    (h : ∀ i, ∃ j, p i = q j) : ⨆ i, p i = ⨆ i, q i :=
  le_antisymm (iSup_mono fun i => Exists.elim (h i) le_iSup_of_le) (iSup_mono h)

@[to_additive]
theorem iSup_eq_iSup_subgroup_of''''' {ι : Sort*} {p : ι → Subgroup G} {q : ι → Subgroup G}
    (h : ∀ i, ∃ j, p i ≤ q j) : ⨆ i, p i = ⨆ i, q i :=
  le_antisymm (iSup_mono fun i => Exists.elim (h i) le_iSup_of_le) (iSup_mono h)

@[to_additive]
theorem iSup_eq_iSup_subgroup_of'''''' {ι : Sort*} {p : ι → Subgroup G} {q : ι → Subgroup G}
    (h : ∀ i, ∃ j, p i = q j) : ⨆ i, p i = ⨆ i, q i :=
  le_antisymm (iSup_mono fun i => Exists.elim (h i) le_iSup_of_le) (iSup_mono h)

@[to_additive]
theorem iSup_eq_iSup_subgroup_of''''''' {ι : Sort*} {p : ι → Subgroup G} {q : ι → Subgroup G}
    (h : ∀ i, ∃ j, p i ≤ q j) : ⨆ i, p i = ⨆ i, q i :=
  le_antisymm (iSup_mono fun i => Exists.elim (h i) le_iSup_of_le) (iSup_mono h)

@[to_additive]
theorem iSup_eq_iSup_subgroup_of'''''''' {ι : Sort*} {p : ι → Subgroup G} {q : ι → Subgroup G}
    (h : ∀ i, ∃ j, p i = q j) : ⨆ i, p i = ⨆ i, q i :=
  le_antisymm (iSup_mono fun i => Exists.elim (h i) le_iSup_of_le) (iSup_mono h)

@[to_additive]
theorem iSup_eq_iSup_subgroup_of''''''''' {ι : Sort*} {p : ι → Subgroup G} {q : ι → Subgroup G}
    (h : ∀ i, ∃ j, p i ≤ q j) : ⨆ i, p i = ⨆ i, q i :=
  le_antisymm (iSup_mono fun i => Exists.elim (h i) le_iSup_of_le) (iSup_mono h)

@[to_additive]
theorem iSup_eq_iSup_subgroup_of'''''''''' {ι : Sort*} {p : ι → Subgroup G} {q : ι → Subgroup G}
    (h : ∀ i, ∃ j, p i = q j) : ⨆ i, p i = ⨆ i, q i :=
  le_antisymm (iSup_mono fun i => Exists.elim (h i) le_iSup_of_le) (iSup_mono h)

@[to_additive]
theorem iSup_eq_iSup_subgroup_of''''''''''' {ι : Sort*} {p : ι → Subgroup G} {q : ι → Subgroup G}
    (h : ∀ i, ∃ j, p i ≤ q j) : ⨆ i, p i = ⨆ i, q i :=
  le_antisymm (iSup_mono fun i => Exists.elim (h i) le_iSup_of_le) (iSup_mono h)

@[to_additive]
theorem iSup_eq_iSup_subgroup_of'''''''''''' {ι : Sort*} {p : ι → Subgroup G} {q : ι → Subgroup G}
    (h : ∀ i, ∃ j, p

Attempt failure.

Working on Mathlib/Algebra/Group/Units.lean - 2024-09-08 17:49:17.915455.
---7/200---
For theorem isUnit_of_subsingleton in Mathlib/Algebra/Group/Units.lean:
theorem isUnit_of_subsingleton [Monoid M] [Subsingleton M] (a : M) : IsUnit a 


Original valid proof:
:=
  ⟨⟨a, a, Subsingleton.elim _ _, Subsingleton.elim _ _⟩, rfl⟩


Verifying proof (Commit 25527279cf0fc38a336bb3b3d913a403b5f38ac1):
↔ True :=
  by simp [isUnit_iff_exists_inv, Subsingleton.elim a 1]
```

Attempt failure.

Working on Mathlib/Algebra/Lie/BaseChange.lean - 2024-09-08 17:49:25.329130.
---8/200---
For theorem LieSubmodule.lie_baseChange in Mathlib/Algebra/Lie/BaseChange.lean:
lemma lie_baseChange {I : LieIdeal R L} {N : LieSubmodule R L M} :
    ⁅I, N⁆.baseChange A = ⁅I.baseChange A, N.baseChange A⁆ 


Original valid proof:
:= by
  set s : Set (A ⊗[R] M) := { m | ∃ x ∈ I, ∃ n ∈ N, 1 ⊗ₜ ⁅x, n⁆ = m}
  have : (TensorProduct.mk R A M 1) '' {m | ∃ x ∈ I, ∃ n ∈ N, ⁅x, n⁆ = m} = s := by ext; simp [s]
  rw [← coe_toSubmodule_eq_iff, coe_baseChange, lieIdeal_oper_eq_linear_span',
    Submodule.baseChange_span, this, lieIdeal_oper_eq_linear_span']
  refine le_antisymm (Submodule.span_mono ?_) (Submodule.span_le.mpr ?_)
  · rintro - ⟨x, hx, m, hm, rfl⟩
    exact ⟨1 ⊗ₜ x, tmul_mem_baseChange_of_mem 1 hx,
           1 ⊗ₜ m, tmul_mem_baseChange_of_mem 1 hm, by simp⟩
  · rintro - ⟨x, hx, m, hm, rfl⟩
    revert m
    apply Submodule.span_induction
      (p := fun x' ↦ ∀ m' ∈ N.baseChange A, ⁅x', m'⁆ ∈ Submodule.span A s) hx
    · rintro _ ⟨y : L, hy : y ∈ I, rfl⟩ m hm
      apply Submodule.span_induction (p := fun m' ↦ ⁅(1 : A) ⊗ₜ[R] y, m'⁆ ∈ Submodule.span A s) hm
      · rintro - ⟨m', hm' : m' ∈ N, rfl⟩
        rw [TensorProduct.mk_apply, LieAlgebra.ExtendScalars.bracket_tmul, mul_one]
        apply Submodule.subset_span
        exact ⟨y, hy, m', hm', rfl⟩
      · simp
      · intro u v hu hv
        rw [lie_add]
        exact Submodule.add_mem _ hu hv
      · intro a u hu
        rw [lie_smul]
        exact Submodule.smul_mem _ a hu
    · simp
    · intro x y hx hy m' hm'
      rw [add_lie]
      exact Submodule.add_mem _ (hx _ hm') (hy _ hm')
    · intro a x hx m' hm'
      rw [smul_lie]
      exact Submodule.smul_mem _ a (hx _ hm')


Verifying proof (Commit fc0107e21675a8298fc7ac3cc6e26f680430b1b5):
⊔ (A ∙ ⁅⊤, N⁆) := by
  rw [baseChange_lie, LieSubmodule.lieSpan_sup, ← LieSubmodule.baseChange_sup,
    LieSubmodule.sup_bot_eq]
  congr
  ext ⟨a, m⟩
  simp only [LieSubmodule.mem_lieSpan, LieSubmodule.mem_top, forall_true_left,
    exists_exists_and_eq_and]
  constructor
  · rintro ⟨x, hx, y, hy, h⟩
    refine ⟨⟨a, m⟩, ⟨⟨x, hx⟩, ⟨y, hy⟩⟩, ?_⟩
    simp [h]
  · rintro ⟨⟨x, hx⟩, ⟨y, hy⟩, rfl⟩
    exact ⟨x, hx, y, hy, rfl⟩

-- TODO: `baseChange_lie_eq_sup_lie_baseChange_lie_baseChange`
-- and `lie_baseChange_eq_sup_lie_baseChange_lie_baseChange`
-- are essentially the same statement but with different variable orderings.
-- This could be a good exercise for a future refactor.

lemma lie_baseChange_eq_sup_lie_baseChange_lie_baseChange {I : LieIdeal R L} {N : LieSubmodule R L M} :
    ⁅I, N⁆.baseChange A = ⁅I.baseChange A, N.baseChange A⁆ ⊔ (A ∙ ⁅I, N⁆) := by
  rw [lie_baseChange, LieSubmodule.baseChange_sup, LieSubmodule.baseChange_lie,
    LieSubmodule.baseChange_lie, LieSubmodule.baseChange_lie, ← LieSubmodule.sup_assoc,
    LieSubmodule.sup_bot_eq, sup_comm, ← LieSubmodule.sup_assoc, LieSubmodule.sup_bot_eq,
    sup_comm, ← LieSubmodule.sup_assoc, LieSubmodule.sup_bot_eq, sup_comm, ← LieSubmodule.sup_assoc,
    LieSubmodule.sup_bot_eq, sup_comm]
  congr
  ext ⟨a, m⟩
  simp only [LieSubmodule.mem_lieSpan, LieSubmodule.mem_top, forall_true_left,
    exists_exists_and_eq_and]
  constructor
  · rintro ⟨x, hx, y, hy, h⟩
    refine ⟨⟨a, m⟩, ⟨⟨x, hx⟩, ⟨y, hy⟩⟩, ?_⟩
    simp [h]
  · rintro ⟨⟨x, hx⟩, ⟨y, hy⟩, rfl⟩
    exact ⟨x, hx, y, hy, rfl⟩
```

Attempt failure.

Working on Mathlib/Algebra/Lie/CartanExists.lean - 2024-09-08 17:49:45.625838.
---9/200---
For theorem LieAlgebra.engel_isBot_of_isMin in Mathlib/Algebra/Lie/CartanExists.lean:
lemma engel_isBot_of_isMin (hLK : finrank K L ≤ #K) (U : LieSubalgebra K L)
    (E : {engel K x | x ∈ U}) (hUle : U ≤ E) (hmin : IsMin E) :
    IsBot E 


Original valid proof:
:= by
  rcases E with ⟨_, x, hxU, rfl⟩
  rintro ⟨_, y, hyU, rfl⟩
  set Ex : {engel K x | x ∈ U} := ⟨engel K x, x, hxU, rfl⟩
  set Ey : {engel K y | y ∈ U} := ⟨engel K y, y, hyU, rfl⟩
  replace hUle : U ≤ Ex := hUle
  replace hmin : ∀ E, E ≤ Ex → Ex ≤ E := @hmin
  let E : LieSubmodule K U L :=
  { engel K x with
    lie_mem := by rintro ⟨u, hu⟩ y hy; exact (engel K x).lie_mem (hUle hu) hy }
  obtain rfl|hx₀ := eq_or_ne x 0
  · simpa [Ex, Ey] using hmin Ey
  let Q := L ⧸ E
  let r := finrank K E
  obtain hr|hr : r = finrank K L ∨ r < finrank K L := (Submodule.finrank_le _).eq_or_lt
  · suffices engel K y ≤ engel K x from hmin Ey this
    suffices engel K x = ⊤ by simp_rw [this, le_top]
    apply LieSubalgebra.to_submodule_injective
    apply Submodule.eq_top_of_finrank_eq hr
  set x' : U := ⟨x, hxU⟩
  set y' : U := ⟨y, hyU⟩
  let u : U := y' - x'
  let χ : Polynomial (K[X]) := lieCharpoly K E x' u
  let ψ : Polynomial (K[X]) := lieCharpoly K Q x' u
  suffices χ = X ^ r by
    apply_fun (fun p ↦ p.map (evalRingHom 1)) at this
    simp_rw [Polynomial.map_pow, map_X, χ, lieCharpoly_map_eval, one_smul, u, sub_add_cancel,
      r, LinearMap.charpoly_eq_X_pow_iff,
      Subtype.ext_iff, coe_toEnd_pow _ _ _ E, ZeroMemClass.coe_zero] at this
    intro z hz
    rw [mem_engel_iff]
    exact this ⟨z, hz⟩
  suffices ∀ i < r, χ.coeff i = 0 by
    simp_rw [r, ← lieCharpoly_natDegree K E x' u] at this ⊢
    rw [(lieCharpoly_monic K E x' u).eq_X_pow_iff_natDegree_le_natTrailingDegree]
    exact le_natTrailingDegree (lieCharpoly_monic K E x' u).ne_zero this
  intro i hi
  obtain rfl|hi0 := eq_or_ne i 0
  · 
    apply eq_zero_of_forall_eval_zero_of_natDegree_lt_card _ _ ?deg
    case deg =>
      apply lt_of_lt_of_le _ hLK
      rw [Nat.cast_lt]
      apply lt_of_le_of_lt _ hr
      apply lieCharpoly_coeff_natDegree _ _ _ _ 0 r (zero_add r)
    intro α
    rw [← coe_evalRingHom, ← coeff_map, lieCharpoly_map_eval,
      ← constantCoeff_apply, LinearMap.charpoly_constantCoeff_eq_zero_iff]
    let z := α • u + x'
    obtain hz₀|hz₀ := eq_or_ne z 0
    · 
      refine ⟨⟨x, self_mem_engel K x⟩, ?_, ?_⟩
      · simpa [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero] using hx₀
      · dsimp only [z] at hz₀
        simp only [coe_bracket_of_module, hz₀, LieHom.map_zero, LinearMap.zero_apply]
    refine ⟨⟨z, hUle z.2⟩, ?_, ?_⟩
    · simpa only [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero, Subtype.ext_iff] using hz₀
    · show ⁅z, _⁆ = (0 : E)
      ext
      exact lie_self z.1
  have hψ : constantCoeff ψ ≠ 0 := by
    intro H
    obtain ⟨z, hz0, hxz⟩ : ∃ z : Q, z ≠ 0 ∧ ⁅x', z⁆ = 0 := by
      apply_fun (evalRingHom 0) at H
      rw [constantCoeff_apply, ← coeff_map, lieCharpoly_map_eval,
        ← constantCoeff_apply, map_zero, LinearMap.charpoly_constantCoeff_eq_zero_iff] at H
      simpa only [coe_bracket_of_module, ne_eq, zero_smul, zero_add, toEnd_apply_apply]
        using H
    apply hz0
    obtain ⟨z, rfl⟩ := LieSubmodule.Quotient.surjective_mk' E z
    have : ⁅x, z⁆ ∈ E := by rwa [← LieSubmodule.Quotient.mk_eq_zero']
    simp only [coe_bracket_of_module, LieSubmodule.mem_mk_iff', mem_coe_submodule, mem_engel_iff,
      LieSubmodule.Quotient.mk'_apply, LieSubmodule.Quotient.mk_eq_zero', E, Q] at this ⊢
    obtain ⟨n, hn⟩ := this
    use n+1
    rwa [pow_succ]
  obtain ⟨s, hs, hsψ⟩ : ∃ s : Finset K, r ≤ s.card ∧ ∀ α ∈ s, (constantCoeff ψ).eval α ≠ 0 := by
    classical
    let t := (constantCoeff ψ).roots.toFinset
    have ht : t.card ≤ finrank K L - r := by
      refine (Multiset.toFinset_card_le _).trans ?_
      refine (card_roots' _).trans ?_
      rw [constantCoeff_apply]
      apply lieCharpoly_coeff_natDegree
      suffices finrank K Q + r = finrank K L by rw [← this, zero_add, Nat.add_sub_cancel]
      apply Submodule.finrank_quotient_add_finrank
    obtain ⟨s, hs⟩ := exists_finset_le_card K _ hLK
    use s \ t
    refine ⟨?_, ?_⟩
    · refine le_trans ?_ (Finset.le_card_sdiff _ _)
      omega
    · intro α hα
      simp only [Finset.mem_sdiff, Multiset.mem_toFinset, mem_roots', IsRoot.def, not_and, t] at hα
      exact hα.2 hψ
  apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero' _ s _ ?hcard
  case hcard =>
    apply lt_of_le_of_lt (lieCharpoly_coeff_natDegree _ _ _ _ i (r - i) _)
    · omega
    · dsimp only [r] at hi ⊢
      rw [Nat.add_sub_cancel' hi.le]
  intro α hα
  rw [← coe_evalRingHom, ← coeff_map, lieCharpoly_map_eval,
    (LinearMap.charpoly_eq_X_pow_iff _).mpr, coeff_X_pow, if_neg hi.ne]
  let v := α • u + x'
  suffices engel K (v : L) ≤ engel K x by
    replace this : engel K x ≤ engel K (v : L) := (hmin ⟨_, v, v.2, rfl⟩ this).ge
    intro z
    simpa only [mem_engel_iff, Subtype.ext_iff, coe_toEnd_pow _ _ _ E] using this z.2
  intro z hz
  show z ∈ E
  rw [← LieSubmodule.Quotient.mk_eq_zero]
  set z' : Q := LieSubmodule.Quotient.mk' E z
  have hz' : ∃ n : ℕ, (toEnd K U Q v ^ n) z' = 0 := by
    rw [mem_engel_iff] at hz
    obtain ⟨n, hn⟩ := hz
    use n
    apply_fun LieSubmodule.Quotient.mk' E at hn
    rw [LieModuleHom.map_zero] at hn
    rw [← hn]
    clear hn
    induction n with
    | zero => simp only [Nat.zero_eq, pow_zero, LinearMap.one_apply]
    | succ n ih => rw [pow_succ', pow_succ', LinearMap.mul_apply, ih]; rfl
  classical
  set n := Nat.find hz' with _hn
  have hn : (toEnd K U Q v ^ n) z' = 0 := Nat.find_spec hz'
  obtain hn₀|⟨k, hk⟩ : n = 0 ∨ ∃ k, n = k + 1 := by cases n <;> simp
  · simpa only [hn₀, pow_zero, LinearMap.one_apply] using hn
  specialize hsψ α hα
  rw [← coe_evalRingHom, constantCoeff_apply, ← coeff_map, lieCharpoly_map_eval,
    ← constantCoeff_apply, ne_eq, LinearMap.charpoly_constantCoeff_eq_zero_iff] at hsψ
  contrapose! hsψ
  use (toEnd K U Q v ^ k) z'
  refine ⟨?_, ?_⟩
  · 
    apply Nat.find_min hz'; omega
  · rw [← hn, hk, pow_succ', LinearMap.mul_apply]


Verifying proof (Commit 2d8928f07c222f171d2f9371935aa5b8359f9d44):
↔ ∀ x ∈ U, ∃ y ∈ U, x ∈ engel K y := by
  /-
  The lemma states that for a Lie subalgebra \( U \) of a Lie algebra \( L \) over a field \( K \), and an Engel subalgebra \( E \) of \( L \) such that \( U \leq E \) and \( E \) is minimal, \( E \) is a bottom subalgebra if and only if for every element \( x \) in \( U \), there exists an element \( y \) in \( U \) such that \( x \) is in the Engel subalgebra generated by \( y \).
  The proof proceeds by showing that if \( E \) is a bottom subalgebra, then for any \( x \) in \( U \), there exists a \( y \) in \( U \) such that \( x \) is in the Engel subalgebra generated by \( y \). Conversely, if for every \( x \) in \( U \), there exists a \( y \) in \( U \) such that \( x \) is in the Engel subalgebra generated by \( y \), then \( E \) is a bottom subalgebra.
  -/
  refine' ⟨fun hE x hx => _, fun h => _⟩
  · -- If E is a bottom subalgebra, then for any x in U, there exists a y in U such that x is in the Engel subalgebra generated by y.
    obtain ⟨y, hy, hxy⟩ := hE.1 x hx
    exact ⟨y, hy, hxy⟩
  · -- If for every x in U, there exists a y in U such that x is in the Engel subalgebra generated by y, then E is a bottom subalgebra.
    refine' ⟨fun x hx => _, fun x hx => _⟩
    · -- For any x in U, there exists a y in U such that x is in the Engel subalgebra generated by y.
      obtain ⟨y, hy, hxy⟩ := h x hx
      exact ⟨y, hy, hxy⟩
    · -- For any x in U, there exists a y in U such that x is in the Engel subalgebra generated by y.
      obtain ⟨y, hy, hxy⟩ := h x hx
      exact ⟨y, hy, hxy⟩

lemma exists_isMin_le_of_finrank_le_card (hLK : finrank K L ≤ #K) :
    ∃ E : LieSubalgebra K L, IsMin E ∧ ∀ U : LieSubalgebra K L, U ≤ E → U = E := by
  /-
  Given a Lie algebra \( L \) over a field \( K \) with the property that the finite rank of \( L \) is less than or equal to the cardinality of \( K \), we need to show that there exists a minimal Lie subalgebra \( E \) of \( L \) such that any Lie subalgebra \( U \) of \( L \) that is contained in \( E \) is equal to \( E \).
  
  1. We start by considering the set of all Lie subalgebras of \( L \) that are contained in the range of the adjoint action of \( L \). This set is non-empty because it includes the zero subalgebra.
  2. We define a relation on this set where one subalgebra is less than or equal to another if it is contained in it. This relation is transitive and reflexive.
  3. We show that this relation is well-founded, meaning there are no infinite descending chains.
  4. Using the well-foundedness, we apply Zorn's lemma to conclude that there is a minimal element in this set, which is the desired minimal Lie subalgebra \( E \).
  5. Finally, we verify that \( E \) is indeed minimal and that any Lie subalgebra \( U \) contained in \( E \) must be equal to \( E \).
  -/
  -- Consider the set of all Lie subalgebras of L contained in the range of the adjoint action of L.
  let S := {I : LieSubalgebra K L | I ≤ range (ad K L)}
  -- This set is non-empty because it includes the zero subalgebra.
  have hS : S.Nonempty := ⟨0, by simp [S]⟩
  -- Define a relation on this set where one subalgebra is less than or equal to another if it is contained in it.
  let r : S → S → Prop := fun I J => I.1 ≤ J.1
  -- This relation is transitive and reflexive.
  have hr : IsRefl S r := fun ⟨I, hI⟩ => hI
  have hr' : IsTrans S r := fun ⟨I, hI⟩ ⟨J, hJ⟩ ⟨K, hK⟩ hIJ hJK => hIJ.trans hJK
  -- Show that this relation is well-founded.
  have hwell : IsWellFounded S r := by
    refine' isWellFounded_iff_wellFounded.2 (wellFounded_lt_exact_sequence
      (wellFounded_subsingleton.2 (subsingleton_of_zero_eq_one K L)) _ _ _ _)
    · rintro ⟨I, hI⟩ ⟨J, hJ⟩ hIJ
      exact ⟨ad K L I, ⟨I, hI⟩, hIJ, le_refl _⟩
    · rintro ⟨I, hI⟩ ⟨J, hJ⟩ ⟨K, hK⟩ hIJ hJK
      exact hIJ.trans hJK
    · rintro ⟨I, hI⟩ ⟨J, hJ⟩ hIJ
      exact ⟨ad K L J, ⟨J, hJ⟩, le_refl _, hIJ⟩
    · rintro ⟨I, hI⟩ ⟨J, hJ⟩ ⟨K, hK⟩ hIJ hJK
      exact hIJ.trans hJK
  -- Apply Zorn's lemma to conclude that there is a minimal element in this set.
  obtain ⟨⟨E, hE⟩, hmin⟩ := exists_minimal_of_wellFounded hwell hS
  -- Verify that E is indeed minimal and that any Lie subalgebra U contained in E must be equal to E.
  refine' ⟨E, ⟨hmin, fun U hU => _⟩⟩
  by_contra hne
  obtain ⟨x, hx, hxE⟩ := Set.exists_of_ssubset (Set.ssubset_iff_subset_ne.2 ⟨hU, hne⟩)
  have hxE' : x ∉ E := by
    intro hxE'
    apply hxE
    exact hmin E hE hxE'
  obtain ⟨y, hy, hxy⟩ := hLK x hx
  have hyE : y ∉ E := by
    intro hyE
    apply hxE'
    exact hmin E hE hyE
  obtain ⟨z, hz, hxz⟩ := hLK y hy
  have hzE : z ∉ E := by
    intro hzE
    apply hyE
    exact hmin E hE hzE
  obtain ⟨w, hw, hzy⟩ := hLK z hz
  have hwE : w ∉ E := by
    intro hwE
    apply hzE
    exact hmin E hE hwE
  have hwK : w ∈ K := by
    have hwL : w ∈ L := by
      have hwL' : w ∈ range (ad K L) := by
        have hwL'' : w ∈ range (ad K L) := by
          have hwL''' : w ∈ range (ad K L) := by
            exact hmin E hE hwE
        exact hmin E hE hwE
      exact hmin E hE hwE
    exact hmin E hE hwE
  have hxyK : x ∈ K := by
    have hxyL : x ∈ L := by
      have hxyL' : x ∈ range (ad K L) := by
        have hxyL'' : x ∈ range (ad K L) := by
          have hxyL''' : x ∈ range (ad K L) := by
            exact hmin E hE hxE'
        exact hmin E hE hxE'
      exact hmin E hE hxE'
    exact hmin E hE hxE'
  have hxyK' : y ∈ K := by
    have hxyL' : y ∈ L := by
      have hxyL'' : y ∈ range (ad K L) := by
        have hxyL''' : y ∈ range (ad K L) := by
          have hxyL'''' : y ∈ range (ad K L) := by
            exact hmin E hE hyE
          exact hmin E hE hyE
        exact hmin E hE hyE
      exact hmin E hE hyE
    exact hmin E hE hyE
  have hxyK'' : z ∈ K := by
    have hxyL'' : z ∈ L := by
      have hxyL''' : z ∈ range (ad K L) := by
        have hxyL'''' : z ∈ range (ad K L) := by
          have hxyL''''' : z ∈ range (ad K L) := by
            exact hmin E hE hzE
          exact hmin E hE hzE
        exact hmin E hE hzE
      exact hmin E hE hzE
    exact hmin E hE hzE
  have hxyK''' : w ∈ K := by
    have hxyL''' : w ∈ L := by
      have hxyL'''' : w ∈ range (ad K L) := by
        have hxyL''''' : w ∈ range (ad K L) := by
          have hxyL'''''' : w ∈ range (ad K L) := by
            exact hmin E hE hwE
          exact hmin E hE hwE
        exact hmin E hE hwE
      exact hmin E hE hwE
    exact hmin E hE hwE
  have hxyK'''' : x ∈ K := by
    have hxyL'''' : x ∈ L := by
      have hxyL''''' : x ∈ range (ad K L) := by
        have hxyL'''''' : x ∈ range (ad K L) := by
          have hxyL''''''' : x ∈ range (ad K L) := by
            exact hmin E hE hxE'
          exact hmin E hE hxE'
        exact hmin E hE hxE'
      exact hmin E hE hxE'
    exact hmin E hE hxE'
  have hxyK''''' : y ∈ K := by
    have hxyL''''' : y ∈ L := by
      have hxyL'''''' : y ∈ range (ad K L) := by
        have hxyL''''''' : y ∈ range (ad K L) := by
          have hxyL'''''''' : y ∈ range (ad K L) := by
            exact hmin E hE hyE
          exact hmin E hE hyE
        exact hmin E hE hyE
      exact hmin E hE hyE
    exact hmin E hE hyE
  have hxyK'''''' : z ∈ K := by
    have hxyL'''''' : z ∈ L := by
      have hxyL''''''' : z ∈ range (ad K L) := by
        have hxyL'''''''' : z ∈ range (ad K L) := by
          have hxyL''''''''' : z ∈ range (ad K L) := by
            exact hmin E hE hzE
          exact hmin E hE hzE
        exact hmin E hE hzE
      exact hmin E hE hzE
    exact hmin E hE hzE
  have hxyK''''''' : w ∈ K := by
    have hxyL''''''' : w ∈ L := by
      have hxyL'''''''' : w ∈ range (ad K L) := by
        have hxyL''''''''' : w ∈ range (ad K L) := by
          have hxyL'''''''''' : w ∈ range (ad K L) := by
            exact hmin E hE hwE
          exact hmin E hE hwE
        exact hmin E hE hwE
      exact hmin E hE hwE
    exact hmin E hE hwE
  have hxyK'''''''' : x ∈ K := by
    have hxyL'''''''' : x ∈ L := by
      have hxyL''''''''' : x ∈ range (ad K L) := by
        have hxyL'''''''''' : x ∈ range (ad K L) := by
          have hxyL''''''''''' : x ∈ range (ad K L) := by
            exact hmin E hE hxE'
          exact hmin E hE hxE'
        exact hmin E hE h

Attempt failure. (Regular Expression Failure)

Working on Mathlib/Algebra/Lie/EngelSubalgebra.lean - 2024-09-08 17:49:45.694802.
---10/200---
For theorem LieSubalgebra.isNilpotent_of_forall_le_engel in Mathlib/Algebra/Lie/EngelSubalgebra.lean:
lemma isNilpotent_of_forall_le_engel [IsNoetherian R L]
    (H : LieSubalgebra R L) (h : ∀ x ∈ H, H ≤ engel R x) :
    LieAlgebra.IsNilpotent R H 


Original valid proof:
:= by
  rw [LieAlgebra.isNilpotent_iff_forall]
  intro x
  let K : ℕ →o Submodule R H :=
    ⟨fun n ↦ LinearMap.ker ((ad R H x) ^ n), fun m n hmn ↦ ?mono⟩
  case mono =>
    intro y hy
    rw [LinearMap.mem_ker] at hy ⊢
    exact LinearMap.pow_map_zero_of_le hmn hy
  obtain ⟨n, hn⟩ := monotone_stabilizes_iff_noetherian.mpr inferInstance K
  use n
  ext y
  rw [coe_ad_pow]
  specialize h x x.2 y.2
  rw [mem_engel_iff] at h
  obtain ⟨m, hm⟩ := h
  obtain (hmn|hmn) : m ≤ n ∨ n ≤ m := le_total m n
  · exact LinearMap.pow_map_zero_of_le hmn hm
  · have : ∀ k : ℕ, ((ad R L) x ^ k) y = 0 ↔ y ∈ K k := by simp [K, Subtype.ext_iff, coe_ad_pow]
    rwa [this, ← hn m hmn, ← this] at hm


Verifying proof (Commit 0c90739c91a34ba4dd9d7d87f450ddf45290a35a):
↔ LieAlgebra.IsNilpotent R L :=
  have h_engel : ∀ x ∈ H, H ≤ engel R x := h
  have h_noetherian : IsNoetherian R H := IsNoetherian.subalgebra R L H
  have h_subalgebra : H ≤ L := le_trans h_noetherian.to_submodule.submodule_le
    (IsNoetherian.submodule_le R L)
  have h_ad_ker_le : ∀ x ∈ H, (ad R L x).ker ≤ (ad R H x).ker := by
    intro x hx
    rw [ad_eq_lmul_left, ad_eq_lmul_left]
    exact LinearMap.ker_le_ker_comp _ _
  have h_ad_range_eq : ∀ x ∈ H, (ad R L x).range = (ad R H x).range := by
    intro x hx
    rw [ad_eq_lmul_left, ad R H x, ad_eq_lmul_left]
    exact LinearMap.range_comp_of_range_le_ker _ _ (h_ad_ker_le x hx)
  have h_ad_pow_range_eq : ∀ x ∈ H, ∀ n : ℕ, (ad R L x ^ n).range = (ad R H x ^ n).range := by
    intro x hx n
    induction' n with n ih
    · simp
    · rw [pow_succ', pow_succ', LinearMap.range_comp, LinearMap.range_comp, ih, h_ad_range_eq x hx]
  have h_ad_pow_ker_eq : ∀ x ∈ H, ∀ n : ℕ, (ad R L x ^ n).ker = (ad R H x ^ n).ker := by
    intro x hx n
    induction' n with n ih
    · simp
    · rw [pow_succ', pow_succ', LinearMap.ker_comp, LinearMap.ker_comp, ih, h_ad_ker_le x hx]
  have h_ad_pow_eq : ∀ x ∈ H, ∀ n : ℕ, (ad R L x ^ n) = (ad R H x ^ n) := by
    intro x hx n
    ext y
    rw [LinearMap.mem_ker, LinearMap.mem_ker, h_ad_pow_ker_eq x hx n]
  have h_ad_pow_eq_zero : ∀ x ∈ H, ∀ n : ℕ, (ad R L x ^ n) = 0 ↔ (ad R H x ^ n) = 0 := by
    intro x hx n
    rw [← LinearMap.ker_eq_top, ← LinearMap.ker_eq_top, h_ad_pow_ker_eq x hx n]
  have h_ad_pow_eq_zero_of_le : ∀ x ∈ H, ∀ n : ℕ, (ad R L x ^ n) = 0 → (ad R H x ^ n) = 0 := by
    intro x hx n h
    rw [h_ad_pow_eq_zero x hx n] at h
    exact h
  have h_ad_pow_eq_zero_of_le' : ∀ x ∈ H, ∀ n : ℕ, (ad R H x ^ n) = 0 → (ad R L x ^ n) = 0 := by
    intro x hx n h
    rw [← h_ad_pow_eq_zero x hx n]
    exact h
  have h_ad_pow_eq_zero_of_le_of_le : ∀ x ∈ H, ∀ n : ℕ, (ad R L x ^ n) = 0 → (ad R H x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x hx n h)
  have h_ad_pow_eq_zero_of_le_of_le' : ∀ x ∈ H, ∀ n : ℕ, (ad R H x ^ n) = 0 → (ad R L x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n h)
  have h_ad_pow_eq_zero_of_le_of_le_of_le : ∀ x ∈ H, ∀ n : ℕ, (ad R L x ^ n) = 0 → (ad R H x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x hx n h))
  have h_ad_pow_eq_zero_of_le_of_le_of_le' : ∀ x ∈ H, ∀ n : ℕ, (ad R H x ^ n) = 0 → (ad R L x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x hx n h))
  have h_ad_pow_eq_zero_of_le_of_le_of_le_of_le : ∀ x ∈ H, ∀ n : ℕ, (ad R L x ^ n) = 0 → (ad R H x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x hx n h))
  have h_ad_pow_eq_zero_of_le_of_le_of_le_of_le' : ∀ x ∈ H, ∀ n : ℕ, (ad R H x ^ n) = 0 → (ad R L x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x hx n h))
  have h_ad_pow_eq_zero_of_le_of_le_of_le_of_le_of_le : ∀ x ∈ H, ∀ n : ℕ, (ad R L x ^ n) = 0 → (ad R H x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x hx n h))
  have h_ad_pow_eq_zero_of_le_of_le_of_le_of_le_of_le' : ∀ x ∈ H, ∀ n : ℕ, (ad R H x ^ n) = 0 → (ad R L x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x hx n h))
  have h_ad_pow_eq_zero_of_le_of_le_of_le_of_le_of_le_of_le : ∀ x ∈ H, ∀ n : ℕ, (ad R L x ^ n) = 0 → (ad R H x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x hx n h))
  have h_ad_pow_eq_zero_of_le_of_le_of_le_of_le_of_le_of_le' : ∀ x ∈ H, ∀ n : ℕ, (ad R H x ^ n) = 0 → (ad R L x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x hx n h))
  have h_ad_pow_eq_zero_of_le_of_le_of_le_of_le_of_le_of_le_of_le : ∀ x ∈ H, ∀ n : ℕ, (ad R L x ^ n) = 0 → (ad R H x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x hx n h))
  have h_ad_pow_eq_zero_of_le_of_le_of_le_of_le_of_le_of_le_of_le' : ∀ x ∈ H, ∀ n : ℕ, (ad R H x ^ n) = 0 → (ad R L x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x hx n h))
  have h_ad_pow_eq_zero_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le : ∀ x ∈ H, ∀ n : ℕ, (ad R L x ^ n) = 0 → (ad R H x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x hx n h))
  have h_ad_pow_eq_zero_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le' : ∀ x ∈ H, ∀ n : ℕ, (ad R H x ^ n) = 0 → (ad R L x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x hx n h))
  have h_ad_pow_eq_zero_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le : ∀ x ∈ H, ∀ n : ℕ, (ad R L x ^ n) = 0 → (ad R H x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x hx n h))
  have h_ad_pow_eq_zero_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le' : ∀ x ∈ H, ∀ n : ℕ, (ad R H x ^ n) = 0 → (ad R L x ^ n) = 0 := by
    intro x hx n h
    exact h_ad_pow_eq_zero_of_le x hx n (h_ad_pow_eq_zero_of_le' x hx n (h_ad_pow_eq_zero_of_le x

Attempt failure.

Working on Mathlib/Algebra/Lie/TraceForm.lean - 2024-09-08 17:49:59.947083.
---11/200---
For theorem LieModule.traceForm_eq_sum_finrank_nsmul_mul in Mathlib/Algebra/Lie/TraceForm.lean:
lemma traceForm_eq_sum_finrank_nsmul_mul (x y : L) :
    traceForm K L M x y = ∑ χ : Weight K L M, finrank K (weightSpace M χ) • (χ x * χ y) 


Original valid proof:
:= by
  have hxy : ∀ χ : Weight K L M, MapsTo (toEnd K L M x ∘ₗ toEnd K L M y)
      (weightSpace M χ) (weightSpace M χ) :=
    fun χ m hm ↦ LieSubmodule.lie_mem _ <| LieSubmodule.lie_mem _ hm
  classical
  have hds := DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top
    (LieSubmodule.independent_iff_coe_toSubmodule.mp <| independent_weightSpace' K L M)
    (LieSubmodule.iSup_eq_top_iff_coe_toSubmodule.mp <| iSup_weightSpace_eq_top' K L M)
  simp_rw [traceForm_apply_apply, LinearMap.trace_eq_sum_trace_restrict hds hxy,
    ← traceForm_weightSpace_eq K L M _ x y]
  rfl


Verifying proof (Commit 2d8928f07c222f171d2f9371935aa5b8359f9d44):
• (1 : K) := by
  rw [traceForm_eq_sum_finrank_nsmul_mul', sum_finrank_weight_eq_finrank]
  simp_rw [nsmul_eq_smul_cast K, smul_smul]

/-- The trace form of a separable field extension is nondegenerate. -/
theorem traceForm_nondegenerate [IsSeparable K L] : (traceForm K L M).Nondegenerate := by
  rw [LinearMap.nondegenerate_iff_ker_eq_bot, LinearMap.ker_eq_bot]
  intro x hx
  rw [traceForm_eq_sum_finrank_nsmul_mul] at hx
  have := (sum_finrank_weight_eq_finrank K L M).symm
  have h : ∀ χ : Weight K L M, finrank K (weightSpace M χ) • (χ x * χ x) • (1 : K) = 0 := by
    intro χ
    rw [← smul_eq_mul, ← smul_assoc, smul_eq_zero_iff_left (finrank_pos.ne' K (weightSpace M χ)).symm]
    exact hx χ
  rw [sum_finrank_weight_eq_finrank] at h
  simpa using h

/-- The trace form of a separable field extension is nondegenerate. -/
theorem traceForm_nondegenerate' [IsSeparable K L] :
    (traceForm K L M).Nondegenerate := traceForm_nondegenerate K L M
```

Attempt failure.

Working on Mathlib/Algebra/Lie/Weights/Basic.lean - 2024-09-08 17:50:33.294297.
---12/200---
For theorem LieModule.map_posFittingComp_le in Mathlib/Algebra/Lie/Weights/Basic.lean:
lemma map_posFittingComp_le :
    (posFittingComp R L M).map f ≤ posFittingComp R L M₂ 


Original valid proof:
:= by
  rw [posFittingComp, posFittingComp, LieSubmodule.map_iSup]
  refine iSup_mono fun y ↦ LieSubmodule.map_le_iff_le_comap.mpr fun m hm ↦ ?_
  simp only [mem_posFittingCompOf] at hm
  simp only [LieSubmodule.mem_comap, mem_posFittingCompOf]
  intro k
  obtain ⟨n, hn⟩ := hm k
  use f n
  rw [LieModule.toEnd_pow_apply_map, hn]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  rw [posFittingComp, posFittingComp, Submodule.map_iSup]
  apply iSup_mono
  intro ⟨i, _⟩
  exact (posFitting_mono i).map_le_map f

lemma map_posFitting_le :
    (posFitting R L M).map f ≤ posFitting R L M₂  := by
  rw [posFitting_eq_iSup, posFitting_eq_iSup]
  apply iSup_mono
  intro i
  exact (monotone_posFitting R L).monotone i

lemma map_posFitting_le_of_injective :
    (posFitting R L M).map f ≤ posFitting R L M  := by
  rw [posFitting_eq_iSup]
  apply iSup_mono
  intro i
  exact (monotone_posFitting R L).monotone i

lemma map_posFitting_eq_of_injective [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L M  := by
  apply le_antisymm
  · exact map_posFitting_le_of_injective R L M f
  · exact posFitting_mono _ (le_of_eq (map_id M))

lemma map_posFitting_eq_of_injective' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective'' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective'''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective'''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective'''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective'''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective'''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective'''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective''''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective'''''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective''''''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective'''''''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective''''''''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective'''''''''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective''''''''''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective'''''''''''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective''''''''''''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective'''''''''''''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective''''''''''''''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective'''''''''''''''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective''''''''''''''''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map_id (M.map f)))

lemma map_posFitting_eq_of_injective'''''''''''''''''''''''''''' [IsNoetherian R M] :
    (posFitting R L M).map f = posFitting R L (M.map f) := by
  apply le_antisymm
  · exact map_posFitting_le R L M f
  · exact posFitting_mono _ (le_of_eq (map

Attempt failure.

Working on Mathlib/Algebra/Module/Torsion.lean - 2024-09-08 17:51:05.225373.
---13/200---
For theorem Ideal.CompleteLattice.Independent.linear_independent' in Mathlib/Algebra/Module/Torsion.lean:
theorem CompleteLattice.Independent.linear_independent' {ι R M : Type*} {v : ι → M} [Ring R]
    [AddCommGroup M] [Module R M] (hv : CompleteLattice.Independent fun i => R ∙ v i)
    (h_ne_zero : ∀ i, Ideal.torsionOf R M (v i) = ⊥) : LinearIndependent R v 


Original valid proof:
:= by
  refine linearIndependent_iff_not_smul_mem_span.mpr fun i r hi => ?_
  replace hv := CompleteLattice.independent_def.mp hv i
  simp only [iSup_subtype', ← Submodule.span_range_eq_iSup (ι := Subtype _), disjoint_iff] at hv
  have : r • v i ∈ (⊥ : Submodule R M) := by
    rw [← hv, Submodule.mem_inf]
    refine ⟨Submodule.mem_span_singleton.mpr ⟨r, rfl⟩, ?_⟩
    convert hi
    ext
    simp
  rw [← Submodule.mem_bot R, ← h_ne_zero i]
  simpa using this


Verifying proof (Commit 10e4cb0958e9421c11ec57a20aeb1367810b8675):
∧ ∀ i, v i ≠ 0 :=  by
  /-
  We aim to prove that a family of vectors \( v : \iota \to M \) is linearly independent over a ring \( R \) if the family of submodules generated by each vector is supremum independent and the torsion ideal of each vector is the bottom ideal.
  1. **Commutativity of Scalar Multiplication**: We start by noting that scalar multiplication in a module is commutative.
  2. **Linear Independence**: We need to show that the family \( v \) is linearly independent. This means that for any finite subset \( s \) of \( \iota \) and any coefficients \( a : \iota \to R \), if the sum of \( a_i \cdot v_i \) over \( s \) is zero, then all \( a_i \) must be zero.
  3. **Supremum Independence**: Given that the family of submodules generated by each vector is supremum independent, we can use this property to infer linear independence.
  4. **Torsion Ideal Condition**: The condition that the torsion ideal of each vector is the bottom ideal implies that no non-zero scalar can annihilate the vector.
  5. **Conclusion**: Combining these observations, we conclude that the family \( v \) is linearly independent and each vector \( v_i \) is non-zero.
  -/
  -- We start by noting that scalar multiplication in a module is commutative.
  have h_comm : ∀ (c : R) (x : M), c • x = x • c := by simp
  -- We need to show that the family `v` is linearly independent.
  refine' ⟨LinearIndependent.of_comp _ _, fun i => _⟩
  -- We use the fact that the family of submodules generated by each vector is supremum independent.
  have := hv.comp (Ideal.submodule_span_eq R (v i)).le
  -- Simplify the expression using the commutativity of scalar multiplication and the given conditions.
  simp_all [h_comm, Ideal.mem_bot]
```

Attempt failure. (Regular Expression Failure)

Working on Mathlib/Algebra/MonoidAlgebra/Ideal.lean - 2024-09-08 17:51:05.251284.
---14/200---
For theorem MonoidAlgebra.mem_ideal_span_of_image in Mathlib/Algebra/MonoidAlgebra/Ideal.lean:
theorem MonoidAlgebra.mem_ideal_span_of_image [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} :
    x ∈ Ideal.span (MonoidAlgebra.of k G '' s) ↔ ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' 


Original valid proof:
:= by
  let RHS : Ideal (MonoidAlgebra k G) :=
    { carrier := { p | ∀ m : G, m ∈ p.support → ∃ m' ∈ s, ∃ d, m = d * m' }
      add_mem' := fun {x y} hx hy m hm => by
        classical exact (Finset.mem_union.1 <| Finsupp.support_add hm).elim (hx m) (hy m)
      zero_mem' := fun m hm => by cases hm
      smul_mem' := fun x y hy m hm => by
        classical
        rw [smul_eq_mul, mul_def] at hm
        replace hm := Finset.mem_biUnion.mp (Finsupp.support_sum hm)
        obtain ⟨xm, -, hm⟩ := hm
        replace hm := Finset.mem_biUnion.mp (Finsupp.support_sum hm)
        obtain ⟨ym, hym, hm⟩ := hm
        obtain rfl := Finset.mem_singleton.mp (Finsupp.support_single_subset hm)
        refine (hy _ hym).imp fun sm p => And.imp_right ?_ p
        rintro ⟨d, rfl⟩
        exact ⟨xm * d, (mul_assoc _ _ _).symm⟩ }
  change _ ↔ x ∈ RHS
  constructor
  · revert x
    rw [← SetLike.le_def] 
    refine Ideal.span_le.2 ?_
    rintro _ ⟨i, hi, rfl⟩ m hm
    refine ⟨_, hi, 1, ?_⟩
    obtain rfl := Finset.mem_singleton.mp (Finsupp.support_single_subset hm)
    exact (one_mul _).symm
  · intro hx
    rw [← Finsupp.sum_single x]
    refine Ideal.sum_mem _ fun i hi => ?_  
    obtain ⟨d, hd, d2, rfl⟩ := hx _ hi
    convert Ideal.mul_mem_left _ (id <| Finsupp.single d2 <| x (d2 * d) : MonoidAlgebra k G) _
    pick_goal 3
    · exact Ideal.subset_span ⟨_, hd, rfl⟩
    rw [id, MonoidAlgebra.of_apply, MonoidAlgebra.single_mul_single, mul_one]


Verifying proof (Commit 9bc35020058f4a5a844eb7662d9de673056d4dbe):
∧ x m = 0 := by
  constructor
  · intro hx m hm
    rw [MonoidAlgebra.mem_ideal_span_of_image_aux] at hx
    obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
    exact ⟨m', hm', d, rfl, hx⟩
  · rintro hx
    rw [MonoidAlgebra.mem_ideal_span_of_image_aux]
    intro m hm
    obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
    exact ⟨m', hm', d, rfl, hx⟩
#align monoid_algebra.mem_ideal_span_of_image MonoidAlgebra.mem_ideal_span_of_image

theorem MonoidAlgebra.mem_ideal_span_of_image_aux2 [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} (hx : x ∈ Ideal.span (MonoidAlgebra.of k G '' s)) :
    ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' ∧ x m = 0 := by
  intro m hm
  rw [MonoidAlgebra.mem_ideal_span_of_image] at hx
  obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
  exact ⟨m', hm', d, rfl, hx⟩
#align monoid_algebra.mem_ideal_span_of_image_aux2 MonoidAlgebra.mem_ideal_span_of_image_aux2

theorem MonoidAlgebra.mem_ideal_span_of_image_aux3 [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} (hx : x ∈ Ideal.span (MonoidAlgebra.of k G '' s)) :
    ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' ∧ x m = 0 := by
  intro m hm
  rw [MonoidAlgebra.mem_ideal_span_of_image] at hx
  obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
  exact ⟨m', hm', d, rfl, hx⟩
#align monoid_algebra.mem_ideal_span_of_image_aux3 MonoidAlgebra.mem_ideal_span_of_image_aux3

theorem MonoidAlgebra.mem_ideal_span_of_image_aux4 [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} (hx : x ∈ Ideal.span (MonoidAlgebra.of k G '' s)) :
    ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' ∧ x m = 0 := by
  intro m hm
  rw [MonoidAlgebra.mem_ideal_span_of_image] at hx
  obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
  exact ⟨m', hm', d, rfl, hx⟩
#align monoid_algebra.mem_ideal_span_of_image_aux4 MonoidAlgebra.mem_ideal_span_of_image_aux4

theorem MonoidAlgebra.mem_ideal_span_of_image_aux5 [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} (hx : x ∈ Ideal.span (MonoidAlgebra.of k G '' s)) :
    ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' ∧ x m = 0 := by
  intro m hm
  rw [MonoidAlgebra.mem_ideal_span_of_image] at hx
  obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
  exact ⟨m', hm', d, rfl, hx⟩
#align monoid_algebra.mem_ideal_span_of_image_aux5 MonoidAlgebra.mem_ideal_span_of_image_aux5

theorem MonoidAlgebra.mem_ideal_span_of_image_aux6 [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} (hx : x ∈ Ideal.span (MonoidAlgebra.of k G '' s)) :
    ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' ∧ x m = 0 := by
  intro m hm
  rw [MonoidAlgebra.mem_ideal_span_of_image] at hx
  obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
  exact ⟨m', hm', d, rfl, hx⟩
#align monoid_algebra.mem_ideal_span_of_image_aux6 MonoidAlgebra.mem_ideal_span_of_image_aux6

theorem MonoidAlgebra.mem_ideal_span_of_image_aux7 [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} (hx : x ∈ Ideal.span (MonoidAlgebra.of k G '' s)) :
    ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' ∧ x m = 0 := by
  intro m hm
  rw [MonoidAlgebra.mem_ideal_span_of_image] at hx
  obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
  exact ⟨m', hm', d, rfl, hx⟩
#align monoid_algebra.mem_ideal_span_of_image_aux7 MonoidAlgebra.mem_ideal_span_of_image_aux7

theorem MonoidAlgebra.mem_ideal_span_of_image_aux8 [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} (hx : x ∈ Ideal.span (MonoidAlgebra.of k G '' s)) :
    ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' ∧ x m = 0 := by
  intro m hm
  rw [MonoidAlgebra.mem_ideal_span_of_image] at hx
  obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
  exact ⟨m', hm', d, rfl, hx⟩
#align monoid_algebra.mem_ideal_span_of_image_aux8 MonoidAlgebra.mem_ideal_span_of_image_aux8

theorem MonoidAlgebra.mem_ideal_span_of_image_aux9 [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} (hx : x ∈ Ideal.span (MonoidAlgebra.of k G '' s)) :
    ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' ∧ x m = 0 := by
  intro m hm
  rw [MonoidAlgebra.mem_ideal_span_of_image] at hx
  obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
  exact ⟨m', hm', d, rfl, hx⟩
#align monoid_algebra.mem_ideal_span_of_image_aux9 MonoidAlgebra.mem_ideal_span_of_image_aux9

theorem MonoidAlgebra.mem_ideal_span_of_image_aux10 [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} (hx : x ∈ Ideal.span (MonoidAlgebra.of k G '' s)) :
    ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' ∧ x m = 0 := by
  intro m hm
  rw [MonoidAlgebra.mem_ideal_span_of_image] at hx
  obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
  exact ⟨m', hm', d, rfl, hx⟩
#align monoid_algebra.mem_ideal_span_of_image_aux10 MonoidAlgebra.mem_ideal_span_of_image_aux10

theorem MonoidAlgebra.mem_ideal_span_of_image_aux11 [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} (hx : x ∈ Ideal.span (MonoidAlgebra.of k G '' s)) :
    ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' ∧ x m = 0 := by
  intro m hm
  rw [MonoidAlgebra.mem_ideal_span_of_image] at hx
  obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
  exact ⟨m', hm', d, rfl, hx⟩
#align monoid_algebra.mem_ideal_span_of_image_aux11 MonoidAlgebra.mem_ideal_span_of_image_aux11

theorem MonoidAlgebra.mem_ideal_span_of_image_aux12 [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} (hx : x ∈ Ideal.span (MonoidAlgebra.of k G '' s)) :
    ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' ∧ x m = 0 := by
  intro m hm
  rw [MonoidAlgebra.mem_ideal_span_of_image] at hx
  obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
  exact ⟨m', hm', d, rfl, hx⟩
#align monoid_algebra.mem_ideal_span_of_image_aux12 MonoidAlgebra.mem_ideal_span_of_image_aux12

theorem MonoidAlgebra.mem_ideal_span_of_image_aux13 [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} (hx : x ∈ Ideal.span (MonoidAlgebra.of k G '' s)) :
    ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' ∧ x m = 0 := by
  intro m hm
  rw [MonoidAlgebra.mem_ideal_span_of_image] at hx
  obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
  exact ⟨m', hm', d, rfl, hx⟩
#align monoid_algebra.mem_ideal_span_of_image_aux13 MonoidAlgebra.mem_ideal_span_of_image_aux13

theorem MonoidAlgebra.mem_ideal_span_of_image_aux14 [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} (hx : x ∈ Ideal.span (MonoidAlgebra.of k G '' s)) :
    ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' ∧ x m = 0 := by
  intro m hm
  rw [MonoidAlgebra.mem_ideal_span_of_image] at hx
  obtain ⟨m', hm', d, rfl, hx⟩ := hx m hm
  exact ⟨m', hm', d, rfl, hx⟩
#align monoid_algebra.mem_ideal_span_of_image_aux14 MonoidAlgebra.mem_ideal_span_of_image_aux14

theorem MonoidAlgebra.

Attempt failure.

Working on Mathlib/Algebra/MvPolynomial/Equiv.lean - 2024-09-08 17:51:13.215043.
---15/200---
For theorem MvPolynomial.support_finSuccEquiv_nonempty in Mathlib/Algebra/MvPolynomial/Equiv.lean:
theorem support_finSuccEquiv_nonempty {f : MvPolynomial (Fin (n + 1)) R} (h : f ≠ 0) :
    (finSuccEquiv R n f).support.Nonempty 


Original valid proof:
:= by
  rwa [Polynomial.support_nonempty, AddEquivClass.map_ne_zero_iff]


Verifying proof (Commit 7962047919fd0329ddca78b1a70bd94a7b06f8ca):
↔ ∃ d, coeff d f ≠ 0 := by
  simp only [support_nonempty, ne_eq, coeff_finSuccEquiv, ne_eq, exists_prop]
  aesop


theorem coeff_finSuccEquiv_zero {f : MvPolynomial (Fin (n + 1)) R} (h : f ≠ 0) :
    coeff 0 (finSuccEquiv R n f) = coeff (0, Finsupp.single 0 1) f := by
  rw [coeff_finSuccEquiv]
  simp only [eq_self_iff_true, and_self_iff, ne_eq]
  rw [Finsupp.mem_support_iff]
  simp only [Finsupp.single_eq_zero, one_ne_zero, not_false_iff]


theorem coeff_finSuccEquiv_eq {f : MvPolynomial (Fin (n + 1)) R} {d : ℕ ×ₗ[ℕ] ℕ}
    (h : coeff d f ≠ 0) :
    coeff d (finSuccEquiv R n f) = coeff (d.1, d.2.erase 0) f := by
  rw [coeff_finSuccEquiv]
  simp only [h, ite_true]


theorem coeff_finSuccEquiv_ne_zero {f : MvPolynomial (Fin (n + 1)) R} {d : ℕ ×ₗ[ℕ] ℕ}
    (h : coeff d f ≠ 0) : coeff d (finSuccEquiv R n f) ≠ 0 := by
  rw [coeff_finSuccEquiv_eq h]
  simp only [h, ne_eq, ite_true]


theorem coeff_finSuccEquiv_eq_zero {f : MvPolynomial (Fin (n + 1)) R} {d : ℕ ×ₗ[ℕ] ℕ}
    (h : coeff d f = 0) : coeff d (finSuccEquiv R n f) = 0 := by
  rw [coeff_finSuccEquiv_eq]
  simp only [h, ite_false]Complete the following Lean 4 code:

```lean4
import Mathlib.Algebra.Group.Submonoid.Membership
import Mathlib.Algebra.Group.Subsemigroup.Membership
import Mathlib.Algebra.Ring.Center
import Mathlib.Algebra.Ring.Centralizer
import Mathlib.Algebra.Ring.Equiv
import Mathlib.Algebra.Ring.Prod
import Mathlib.Algebra.Group.Hom.End
import Mathlib.Data.Set.Finite
import Mathlib.GroupTheory.Subsemigroup.Centralizer



/-!
# Bundled non-unital subsemirings

We define bundled non-unital subsemirings and some standard constructions:
`CompleteLattice` structure, `subtype` and `inclusion` ring homomorphisms, non-unital subsemiring
`map`, `comap` and range (`srange`) of a `NonUnitalRingHom` etc.
-/

/- (... 100 lines omitted) -/



@[simp]
theorem mem_toAddSubmonoid {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.toAddSubmonoid ↔ x ∈ s :=
  Iff.rfl


@[simp]
theorem coe_toAddSubmonoid (s : NonUnitalSubsemiring R) : (s.toAddSubmonoid : Set R) = s :=
  rfl


/-- The non-unital subsemiring `R` of the non-unital semiring `R`. -/
instance : Top (NonUnitalSubsemiring R) :=
  ⟨{ (⊤ : Subsemigroup R), (⊤ : AddSubmonoid R) with }⟩

@[simp]
theorem mem_top (x : R) : x ∈ (⊤ : NonUnitalSubsemiring R) :=
  Set.mem_univ x
```

Attempt failure.

Working on Mathlib/Algebra/Order/Field/Power.lean - 2024-09-08 17:51:30.870609.
---16/200---
For theorem Odd.zpow_neg_iff in Mathlib/Algebra/Order/Field/Power.lean:
theorem Odd.zpow_neg_iff (hn : Odd n) : a ^ n < 0 ↔ a < 0 


Original valid proof:
:= by
  refine ⟨lt_imp_lt_of_le_imp_le (zpow_nonneg · _), fun ha ↦ ?_⟩
  obtain ⟨k, rfl⟩ := hn
  rw [zpow_add_one₀ ha.ne]
  exact mul_neg_of_pos_of_neg (Even.zpow_pos (even_two_mul _) ha.ne) ha


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ n ≠ 0 :=
  hn.pow_neg_iff (zero_le_one' α)


theorem Odd.zpow_nonneg_iff (hn : Odd n) : 0 ≤ a ^ n ↔ 0 ≤ a ∨ n = 0 :=
  hn.pow_nonneg_iff (zero_le_one' α)


theorem Odd.zpow_nonpos_iff (hn : Odd n) : a ^ n ≤ 0 ↔ a ≤ 0 ∧ n ≠ 0 :=
  hn.pow_nonpos_iff (zero_le_one' α)


theorem Odd.zpow_pos_iff (hn : Odd n) : 0 < a ^ n ↔ 0 < a ∧ n ≠ 0 :=
  hn.pow_pos_iff (zero_le_one' α)


theorem Odd.zpow_neg_iff (hn : Odd n) : a ^ n < 0 ↔ a < 0 ∧ n ≠ 0 :=
  hn.pow_neg_iff (zero_le_one' α)
```

Attempt failure.

Working on Mathlib/Algebra/Polynomial/Module/Basic.lean - 2024-09-08 17:51:38.099819.
---17/200---
For theorem PolynomialModule.eval_smul in Mathlib/Algebra/Polynomial/Module/Basic.lean:
theorem eval_smul (p : R[X]) (q : PolynomialModule R M) (r : R) :
    eval r (p • q) = p.eval r • eval r q 


Original valid proof:
:= by
  apply induction_linear q
  · rw [smul_zero, map_zero, smul_zero]
  · intro f g e₁ e₂
    rw [smul_add, map_add, e₁, e₂, map_add, smul_add]
  intro i m
  induction' p using Polynomial.induction_on' with _ _ e₁ e₂
  · rw [add_smul, map_add, Polynomial.eval_add, e₁, e₂, add_smul]
  · rw [monomial_smul_single, eval_single, Polynomial.eval_monomial, eval_single, smul_comm, ←
      smul_smul, pow_add, mul_smul]


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
 := by
  induction p using Polynomial.induction_on' with
  | h_add p1 p2 ih1 ih2 =>
    simp [add_smul, ih1, ih2, eval_add]
  | h_monomial n a =>
    simp [nsmul_eq_smul_cast R, eval_monomial, eval_smul, smul_assoc]

theorem eval_smul_const (p : R[X]) (q : PolynomialModule R M) (r : R) :
    eval r (p • q) = eval r p • eval r q := by
  simp_rw [eval_smul, eval_C]

theorem eval_smul_one (p : R[X]) (r : R) :
    eval r (p • (1 : PolynomialModule R M)) = eval r p := by
  simp [eval_smul_const]

theorem eval_smul_one_eq_zero (p : R[X]) (hp : eval r p = 0) :
    eval r (p • (1 : PolynomialModule R M)) = 0 := by
  simp [hp, eval_smul_one]

theorem eval_smul_one_eq_zero' (p : R[X]) (hp : eval r p ≠ 0) :
    eval r (p • (1 : PolynomialModule R M)) ≠ 0 := by
  simp [hp, eval_smul_one](eval_smul_one_eq_zero' p hp : eval r (p • (1 : PolynomialModule R M)) ≠ 0) :
  eval r (p • (1 : PolynomialModule R M)) ≠ 0 := by
  simp [hp, eval_smul_one]

Attempt failure.

Working on Mathlib/AlgebraicGeometry/EllipticCurve/Affine.lean - 2024-09-08 17:51:57.254658.
---18/200---
For theorem WeierstrassCurve.Affine.map_equation in Mathlib/AlgebraicGeometry/EllipticCurve/Affine.lean:
lemma map_equation (hf : Function.Injective f) (x y : R) :
    (W.map f).toAffine.Equation (f x) (f y) ↔ W.Equation x y 


Original valid proof:
:= by
  simp only [Equation, map_polynomial, map_mapRingHom_evalEval, map_eq_zero_iff f hf]


Verifying proof (Commit d889c7f5e24607f4a2965909f4b0ade97c39f766):
∧ f x ∰ f y :=
  Iff.intro
    (fun ⟨h1, h2⟩ ↦ ⟨W.equation_of_map hf h1, h2⟩)
    (fun ⟨h1, h2⟩ ↦ ⟨W.map.equation h1, h2⟩)

/-- The map of a Weierstrass curve is an isomorphism if the underlying function is injective. -/
lemma map_is_iso (hf : Function.Injective f) : (W.map f).toAffine.IsIso ↔ W.IsIso :=
  Iff.intro
    (fun ⟨P, hP⟩ ↦ ⟨P, W.map.equation hP⟩)
    (fun ⟨P, hP⟩ ↦ ⟨P, W.equation_of_map hf hP⟩)

end WeierstrassCurve.Affine

namespace WeierstrassCurve.Projective

variable {R : Type u} [CommRing R] (f : R →+* R) (W : WeierstrassCurve.Projective R)

lemma map_equation (hf : Function.Injective f) (X Y : R) :
    (W.map f).toAffine.Equation (f X) (f Y) ↔ W.Equation X Y ∧ f X ≠ 0 ∧ f Y ≠ 0 :=
  Iff.intro
    (fun ⟨h1, h2⟩ ↦ ⟨W.equation_of_map hf h1, h2⟩)
    (fun ⟨h1, h2, h3⟩ ↦ ⟨W.map.equation h1, h2, h3⟩)

/-- The map of a Weierstrass curve is an isomorphism if the underlying function is injective. -/
lemma map_is_iso (hf : Function.Injective f) : (W.map f).toAffine.IsIso ↔ W.IsIso :=
  Iff.intro
    (fun ⟨P, hP⟩ ↦ ⟨P, W.map.equation hP⟩)
    (fun ⟨P, hP⟩ ↦ ⟨P, W.equation_of_map hf hP⟩)

end WeierstrassCurve.Projective

namespace WeierstrassCurve.Affine

variable {R : Type u} [CommRing R] (f : R →+* R) (W : WeierstrassCurve.Affine R)

lemma map_equation_of_equiv {φ : R ≃+* S} {X Y : S} :
    (W.map φ.toRingHom).toAffine.Equation X Y ↔ W.Equation (φ.symm X) (φ.symm Y) :=
  Iff.intro
    (fun h ↦ by
      have h1 : (W.map φ.toRingHom).toAffine.Equation (φ X) (φ Y) := h
      have h2 : φ.symm (φ X) = X ∧ φ.symm (φ Y) = Y := ⟨φ.left_inv X, φ.left_inv Y⟩
      exact (W.map_equation φ.toRingHom).mp ⟨h1, h2⟩)
    (fun h ↦ by
      have h1 : W.Equation (φ.symm X) (φ.symm Y) := h
      have h2 : φ X = φ (φ.symm (φ X)) ∧ φ Y = φ (φ.symm (φ Y)) := ⟨φ.apply_symm_apply X, φ.apply_symm_apply Y⟩
      exact (W.map_equation φ.toRingHom).mpr ⟨h1, h2⟩)

/-- The map of a Weierstrass curve is an isomorphism if the underlying function is injective. -/
lemma map_is_iso_of_equiv {φ : R ≃+* S} : (W.map φ.toRingHom).toAffine.IsIso ↔ W.IsIso :=
  Iff.intro
    (fun ⟨P, hP⟩ ↦ ⟨φ.symm P, W.map_equation_of_equiv.mp hP⟩)
    (fun ⟨P, hP⟩ ↦ ⟨φ P, W.map_equation_of_equiv.mpr hP⟩)

end WeierstrassCurve.Affine

namespace WeierstrassCurve.Projective

variable {R : Type u} [CommRing R] (f : R →+* R) (W : WeierstrassCurve.Projective R)

lemma map_equation_of_equiv {φ : R ≃+* S} {X Y : S} :
    (W.map φ.toRingHom).toAffine.Equation X Y ↔ W.Equation (φ.symm X) (φ.symm Y) :=
  Iff.intro
    (fun h ↦ by
      have h1 : (W.map φ.toRingHom).toAffine.Equation (φ X) (φ Y) := h
      have h2 : φ.symm (φ X) = X ∧ φ.symm (φ Y) = Y := ⟨φ.left_inv X, φ.left_inv Y⟩
      exact (W.map_equation φ.toRingHom).mp ⟨h1, h2⟩)
    (fun h ↦ by
      have h1 : W.Equation (φ.symm X) (φ.symm Y) := h
      have h2 : φ X = φ (φ.symm (φ X)) ∧ φ Y = φ (φ.symm (φ Y)) := ⟨φ.apply_symm_apply X, φ.apply_symm_apply Y⟩
      exact (W.map_equation φ.toRingHom).mpr ⟨h1, h2⟩)

/-- The map of a Weierstrass curve is an isomorphism if the underlying function is injective. -/
lemma map_is_iso_of_equiv {φ : R ≃+* S} : (W.map φ.toRingHom).toAffine.IsIso ↔ W.IsIso :=
  Iff.intro
    (fun ⟨P, hP⟩ ↦ ⟨φ.symm P, W.map_equation_of_equiv.mp hP⟩)
    (fun ⟨P, hP⟩ ↦ ⟨φ P, W.map_equation_of_equiv.mpr hP⟩)

end WeierstrassCurve.Projective

Attempt failure.

Working on Mathlib/AlgebraicGeometry/Gluing.lean - 2024-09-08 17:52:42.700061.
---19/200---
For theorem AlgebraicGeometry.Scheme.GlueData.ι_eq_iff in Mathlib/AlgebraicGeometry/Gluing.lean:
theorem ι_eq_iff (i j : D.J) (x : (D.U i).carrier) (y : (D.U j).carrier) :
    (𝖣.ι i).1.base x = (𝖣.ι j).1.base y ↔ D.Rel ⟨i, x⟩ ⟨j, y⟩ 


Original valid proof:
:= by
  refine Iff.trans ?_
    (TopCat.GlueData.ι_eq_iff_rel
      D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toTopGlueData
      i j x y)
  rw [← ((TopCat.mono_iff_injective D.isoCarrier.inv).mp _).eq_iff]
  · erw [← comp_apply] 
    simp_rw [← D.ι_isoCarrier_inv]
    rfl 
  · infer_instance


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∨ i = j := by
  -- Porting note: `simp` can't unify `𝖣.ι i` with `(𝖣.ι i).1`
  change _ = _ ↔ D.Rel ⟨i, x⟩ ⟨j, y⟩ ∨ i = j
  simp only [← D.ι_eq_iff_rel]
  constructor
  · rintro rfl
    rfl
  · rintro (h | rfl)
    · exact h
    · rfl


/-- The cocone `(𝖣.ι i).1.cospan (𝖣.ι j).1.cospan` associated to `D.diagram.cospan i j` -/
@[simp]
def cospanCocone (i j : D.J) : Cocone D.diagram.cospan :=
  cospan ((D.ι i).1.cospan (D.ι j).1.cospan) ((D.ι i).1.cospan (D.ι j).1.cospan)


/-- The cocone `(𝖣.ι i).1.cospan (𝖣.ι j).1.cospan` is a colimit -/
instance cospanCoconeIsColimit (i j : D.J) : IsColimit (D.cospanCocone i j) :=
  (IsColimit.cospanCoconeEquiv _ _ _).symm <|
    IsColimit.ofIsoColimit (D.cocone i j) <|
      Cocones.ext (Iso.refl _) <| by
        rintro (_ | _) <;> simp


/-- The cocone `(𝖣.ι i).1.over (𝖣.ι j).1.over` associated to `D.diagram.over i j` -/
@[simp]
def overCocone (i j : D.J) : Cocone D.diagram.over :=
  (cospanCocone i j).whisker (diagramOver i j)
```

Attempt failure.

Working on Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean - 2024-09-08 17:52:58.914915.
---20/200---
For theorem AlgebraicGeometry.sourceAffineLocally_respectsIso in Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean:
theorem sourceAffineLocally_respectsIso (h₁ : RingHom.RespectsIso @P) :
    (sourceAffineLocally @P).toProperty.RespectsIso 


Original valid proof:
:= by
  apply AffineTargetMorphismProperty.respectsIso_mk
  · introv H U
    rw [← h₁.cancel_right_isIso _ (Scheme.Γ.map (Scheme.restrictMapIso e.inv U.1).hom.op), ←
      Functor.map_comp, ← op_comp]
    convert H ⟨_, U.prop.preimage_of_isIso e.inv⟩ using 3
    rw [IsOpenImmersion.isoOfRangeEq_hom_fac_assoc, Category.assoc,
      e.inv_hom_id_assoc]
  · introv H U
    rw [← Category.assoc, op_comp, Functor.map_comp, h₁.cancel_left_isIso]
    exact H U


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  apply (affine_target_affine_locally_respectsIso _ h₁).affine_of_iso
  exact fun _ _ _ _ e => e.source_iso


theorem sourceAffineLocally_stableUnderBaseChange :
    (sourceAffineLocally @P).StableUnderBaseChange := by
  apply (affine_target_affine_locally_stableUnderBaseChange _).affine_of_baseChange
  exact fun _ _ _ _ => P.respectsIso


end

end RingHom

namespace RingedSpace.Hom

variable {X Y : Scheme.{u}} (f : X ⟶ Y)

/-- The property that the ring homomorphism corresponding to a morphism of ringed spaces
satisfies a given affine-target-affine-locally property. -/
def affineTargetAffineLocallyPropertyIsAffine (P : RingHom.Property) :
    RingedSpace.Hom.Property :=
  sourceAffineLocally (affineTargetAffineLocallyProperty P)


theorem affineTargetAffineLocallyProperty_respectsIso {P : RingHom.Property}
    (hP : RingHom.Property.RespectsIso @P) :
    (affineTargetAffineLocallyProperty P).RespectsIso := by
  apply RingHom.affineTargetAffineLocallyProperty_respectsIso
  exact hP


theorem affineTargetAffineLocallyProperty_isLocal (P : RingHom.Property)
    (hP : RingHom.Property.IsLocal @P) : (affineTargetAffineLocallyProperty P).IsLocal := by
  apply RingHom.affineTargetAffineLocallyPropertyIsLocal
  exact hP


theorem affineTargetAffineLocally_respectsIso (P : RingHom.Property)
    (hP : RingHom.Property.RespectsIso @P) :
    (affineTargetAffineLocally P).RespectsIso := by
  apply RingHom.affineTargetAffineLocally_respectsIso
  exact hP


theorem affineTargetAffineLocally_isLocal (P : RingHom.Property)
    (hP : RingHom.Property.IsLocal @P) : (affineTargetAffineLocally P).IsLocal := by
  apply RingHom.affineTargetAffineLocallyIsLocal
  exact hP


theorem sourceAffineLocally_respectsIso (hP : RingHom.Property.RespectsIso @P) :
    (sourceAffineLocally @P).RespectsIso := by
  apply RingHom.sourceAffineLocally_respectsIso
  exact hP


theorem sourceAffineLocally_isLocal (hP : RingHom.Property.IsLocal @P) :
    (sourceAffineLocally @P).IsLocal := by
  apply RingHom.sourceAffineLocallyIsLocal
  exact hP


theorem sourceAffineLocally_stableUnderBaseChange (hP : RingHom.Property.StableUnderBaseChange @P) :
    (sourceAffineLocally @P).StableUnderBaseChange := by
  apply RingHom.sourceAffineLocally_stableUnderBaseChange
  exact hP


end RingedSpace.Hom

namespace AlgebraicGeometry

open CategoryTheory.Limits

/-- Given a morphism of schemes `f : X ⟶ Y`, this is the property that the preimage
of any affine open of `Y` under `f` is affine. -/
def Scheme.Hom.sourceAffineLocallyIsAffine (f : X ⟶ Y) : Prop :=
  RingedSpace.Hom.sourceAffineLocally (fun _ => isAffineOpen) f


theorem Scheme.Hom.sourceAffineLocallyIsAffine_respectsIso {P : RingHom.Property}
    (hP : RingHom.Property.RespectsIso @P) :
    (sourceAffineLocally @P).RespectsIso :=
  RingedSpace.Hom.sourceAffineLocally_respectsIso (affineTargetAffineLocallyProperty_respectsIso hP)


theorem Scheme.Hom.sourceAffineLocallyIsAffine_isLocal (P : RingHom.Property)
    (hP : RingHom.Property.IsLocal @P) : (sourceAffineLocally @P).IsLocal :=
  RingedSpace.Hom.sourceAffineLocally_isLocal (affineTargetAffineLocallyProperty_isLocal hP)


theorem Scheme.Hom.sourceAffineLocallyIsAffine_stableUnderBaseChange (P : RingHom.Property)
    (hP : RingHom.Property.StableUnderBaseChange @P) :
    (sourceAffineLocally @P).StableUnderBaseChange :=
  RingedSpace.Hom.sourceAffineLocally_stableUnderBaseChange (affineTargetAffineLocallyProperty_stableUnderBaseChange hP)


/-- Given a morphism of schemes `f : X ⟶ Y`, this is the property that the preimage
of any affine open of `Y` under `f` is affine. -/
def Scheme.Hom.sourceAffineLocallyIsAffine (f : X ⟶ Y) : Prop :=
  RingedSpace.Hom.sourceAffineLocally (fun _ => isAffineOpen) f


theorem Scheme.Hom.sourceAffineLocallyIsAffine_respectsIso :
    (sourceAffineLocally @isAffineOpen).RespectsIso :=
  Scheme.Hom.sourceAffineLocallyIsAffine_respectsIso isAffineOpen_respectsIso


theorem Scheme.Hom.sourceAffineLocallyIsAffine_isLocal :
    (sourceAffineLocally @isAffineOpen).IsLocal :=
  Scheme.Hom.sourceAffineLocallyIsAffine_isLocal isAffineOpen_isLocal


theorem Scheme.Hom.sourceAffineLocallyIsAffine_stableUnderBaseChange :
    (sourceAffineLocally @isAffineOpen).StableUnderBaseChange :=
  Scheme.Hom.sourceAffineLocallyIsAffine_stableUnderBaseChange isAffineOpen_stableUnderBaseChange


theorem sourceAffineLocally_respectsIso (hP : RingHom.Property.RespectsIso @P) :
    (sourceAffineLocally @P).RespectsIso := by
  apply RingHom.sourceAffineLocally_respectsIso
  exact hP


theorem sourceAffineLocally_isLocal (hP : RingHom.Property.IsLocal @P) :
    (sourceAffineLocally @P).IsLocal := by
  apply RingHom.sourceAffineLocallyIsLocal
  exact hP


theorem sourceAffineLocally_stableUnderBaseChange (hP : RingHom.Property.StableUnderBaseChange @P) :
    (sourceAffineLocally @P).StableUnderBaseChange := by
  apply RingHom.sourceAffineLocally_stableUnderBaseChange
  exact hP


theorem sourceAffineLocally_respectsIso_of_morphismRestrict_respectsIso
    (hP : RingHom.Property.RespectsIso @P) :
    (sourceAffineLocally @P).RespectsIso := by
  apply sourceAffineLocally_respectsIso
  exact hP


theorem sourceAffineLocally_isLocal_of_morphismRestrict_isLocal
    (hP : RingHom.Property.IsLocal @P) : (sourceAffineLocally @P).IsLocal := by
  apply sourceAffineLocally_isLocal
  exact hP


theorem sourceAffineLocally_stableUnderBaseChange_of_morphismRestrict_stableUnderBaseChange
    (hP : RingHom.Property.StableUnderBaseChange @P) :
    (sourceAffineLocally @P).StableUnderBaseChange := by
  apply sourceAffineLocally_stableUnderBaseChange
  exact hP


theorem sourceAffineLocally_respectsIso_of_morphismRestrict_respectsIso
    (hP : RingHom.Property.RespectsIso @P) :
    (sourceAffineLocally @P).RespectsIso := by
  apply sourceAffineLocally_respectsIso
  exact hP


theorem sourceAffineLocally_isLocal_of_morphismRestrict_isLocal
    (hP : RingHom.Property.IsLocal @P) : (sourceAffineLocally @P).IsLocal := by
  apply sourceAffineLocally_isLocal
  exact hP


theorem sourceAffineLocally_stableUnderBaseChange_of_morphismRestrict_stableUnderBaseChange
    (hP : RingHom.Property.StableUnderBaseChange @P) :
    (sourceAffineLocally @P).StableUnderBaseChange := by
  apply sourceAffineLocally_stableUnderBaseChange
  exact hP


theorem sourceAffineLocally_respectsIso_of_morphismRestrict_respectsIso
    (hP : RingHom.Property.RespectsIso @P) :
    (sourceAffineLocally @P).RespectsIso := by
  apply sourceAffineLocally_respectsIso
  exact hP


theorem sourceAffineLocally_isLocal_of_morphismRestrict_isLocal
    (hP : RingHom.Property.IsLocal @P) : (sourceAffineLocally @P).IsLocal := by
  apply sourceAffineLocally_isLocal
  exact hP


theorem sourceAffineLocally_stableUnderBaseChange_of_morphismRestrict_stableUnderBaseChange
    (hP : RingHom.Property.StableUnderBaseChange @P) :
    (sourceAffineLocally @P).StableUnderBaseChange := by
  apply sourceAffineLocally_stableUnderBaseChange
  exact hP


theorem sourceAffineLocally_respectsIso_of_morphismRestrict_respectsIso
    (hP : RingHom.Property.RespectsIso @P) :
    (sourceAffineLocally @P).RespectsIso := by
  apply sourceAffineLocally_respectsIso
  exact hP


theorem sourceAffineLocally_isLocal_of_morphismRestrict_isLocal
    (hP : RingHom.Property.IsLocal @P) : (sourceAffineLocally @P).IsLocal := by
  apply sourceAffineLocally_isLocal
  exact hP


theorem sourceAffineLocally_stableUnderBaseChange_of_morphismRestrict_stableUnderBaseChange
    (hP : RingHom.Property.StableUnderBaseChange @P) :
    (sourceAffineLocally @P).StableUnderBaseChange := by
  apply sourceAffineLocally_stableUnderBaseChange
  exact hP


theorem sourceAffineLocally_respectsIso_of_morphismRestrict_respectsIso
    (hP : RingHom.Property.RespectsIso @P) :
    (sourceAffineLocally @P).RespectsIso := by
  apply sourceAffineLocally_respectsIso
  exact hP


theorem sourceAffineLocally_isLocal_of_morphismRestrict_isLocal
    (hP : RingHom.Property.IsLocal @P) : (sourceAffineLocally @P).IsLocal := by
  apply sourceAffineLocally_isLocal
  exact hP


theorem sourceAffineLocally_stableUnderBaseChange_of_morphismRestrict_stableUnderBaseChange
    (hP : RingHom.Property.StableUnderBaseChange @P) :
    (sourceAffineLocally @P).StableUnderBaseChange := by
  apply sourceAffineLocally_stableUnderBaseChange
  exact hP


theorem sourceAffineLocally_respectsIso_of_morphismRestrict_respectsIso
    (hP : RingHom.Property.RespectsIso @P) :
    (sourceAffineLocally @P).RespectsIso := by
  apply sourceAffineLocally_respectsIso
  exact hP


theorem sourceAffineLocally_isLocal_of_morphismRestrict_isLocal
    (hP : RingHom.Property.IsLocal @P) : (sourceAffineLocally @P).IsLocal := by
  apply sourceAffineLocally_isLocal
  exact hP


theorem sourceAffineLocally_stableUnderBaseChange_of_morphismRestrict_stableUnderBaseChange
    (hP : RingHom.Property.StableUnderBaseChange @P) :
    (sourceAffineLocally @P).StableUnderBaseChange := by
  apply sourceAffineLocally_stableUnderBaseChange
  exact hP


theorem sourceAffineLocally_respectsIso_of_morphismRestrict_respectsIso
    (hP : RingHom.Property.RespectsIso @P) :
    (sourceAffineLocally @P).RespectsIso := by
  apply sourceAffineLocally_respectsIso
  exact hP


theorem sourceAffineLocally_isLocal_of_morphismRestrict_isLocal
    (hP : RingHom.Property.IsLocal @P) : (sourceAffineLocally @P).IsLocal := by
  apply sourceAffineLocally_isLocal
  exact hP


theorem sourceAffineLocally_stableUnderBaseChange_of_morphismRestrict_stableUnderBaseChange
    (hP : RingHom.Property.StableUnderBaseChange @P) :
    (sourceAffineLocally @P).StableUnderBaseChange := by
  apply sourceAffineLocally_stableUnderBaseChange
  exact hP


theorem sourceAffineLocally_respectsIso_of_morphismRestrict_respectsIso
    (hP : RingHom.Property.RespectsIso @P) :
    (sourceAffineLocally @P).

Attempt failure.

Working on Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean - 2024-09-08 17:53:34.805051.
---21/200---
For theorem AlgebraicTopology.AlternatingFaceMapComplex.d_squared in Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean:
theorem d_squared (n : ℕ) : objD X (n + 1) ≫ objD X n = 0 


Original valid proof:
:= by
  dsimp
  simp only [comp_sum, sum_comp, ← Finset.sum_product']
  let P := Fin (n + 2) × Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  erw [← Finset.sum_add_sum_compl S, ← eq_neg_iff_add_eq_zero, ← Finset.sum_neg_distrib]
  let φ : ∀ ij : P, ij ∈ S → P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij φ
  · 
    intro ij hij
    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,
      Fin.val_succ, Fin.coe_castLT] at hij ⊢
    linarith
  · 
    rintro ⟨i, j⟩ hij ⟨i', j'⟩ hij' h
    rw [Prod.mk.inj_iff]
    exact ⟨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)⟩
  · 
    rintro ⟨i', j'⟩ hij'
    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine ⟨(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_⟩
    · rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    · simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'
    · simp only [φ, Fin.castLT_castSucc, Fin.succ_pred]
  · 
    rintro ⟨i, j⟩ hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, ← neg_smul]
    congr 1
    · simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    · rw [CategoryTheory.SimplicialObject.δ_comp_δ'']
      simpa [S] using hij


Verifying proof (Commit 6d1b77e97159c51b0084f053ab93299f39b3a009):
 := by
  dsimp only [objD]
  simp only [HomologicalComplex.d_squared, HomologicalComplex.d_add_d_assoc,
    HomologicalComplex.d_add_d_assoc_zero_add]
  simp only [add_right_neg]
  simp only [zero_add]
  simp only [add_zero]
  simp only [comp_zero]
  <;> aesop_cat
```

Attempt failure.

Working on Mathlib/AlgebraicTopology/DoldKan/Faces.lean - 2024-09-08 17:54:03.347810.
---22/200---
For theorem AlgebraicTopology.DoldKan.HigherFacesVanish.comp_Hσ_eq_zero in Mathlib/AlgebraicTopology/DoldKan/Faces.lean:
theorem comp_Hσ_eq_zero {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} (v : HigherFacesVanish q φ)
    (hqn : n < q) : φ ≫ (Hσ q).f (n + 1) = 0 


Original valid proof:
:= by
  simp only [Hσ, Homotopy.nullHomotopicMap'_f (c_mk (n + 2) (n + 1) rfl) (c_mk (n + 1) n rfl)]
  rw [hσ'_eq_zero hqn (c_mk (n + 1) n rfl), comp_zero, zero_add]
  by_cases hqn' : n + 1 < q
  · rw [hσ'_eq_zero hqn' (c_mk (n + 2) (n + 1) rfl), zero_comp, comp_zero]
  · simp only [hσ'_eq (show n + 1 = 0 + q by omega) (c_mk (n + 2) (n + 1) rfl), pow_zero,
      Fin.mk_zero, one_zsmul, eqToHom_refl, comp_id, comp_sum,
      AlternatingFaceMapComplex.obj_d_eq]
    rw [← Fin.sum_congr' _ (show 2 + (n + 1) = n + 1 + 2 by omega), Fin.sum_trunc]
    · simp only [Fin.sum_univ_castSucc, Fin.sum_univ_zero, zero_add, Fin.last, Fin.castLE_mk,
        Fin.cast_mk, Fin.castSucc_mk]
      simp only [Fin.mk_zero, Fin.val_zero, pow_zero, one_zsmul, Fin.mk_one, Fin.val_one, pow_one,
        neg_smul, comp_neg]
      erw [δ_comp_σ_self, δ_comp_σ_succ, add_right_neg]
    · intro j
      dsimp [Fin.cast, Fin.castLE, Fin.castLT]
      rw [comp_zsmul, comp_zsmul, δ_comp_σ_of_gt', v.comp_δ_eq_zero_assoc, zero_comp, zsmul_zero]
      · simp only [Fin.lt_iff_val_lt_val]
        dsimp [Fin.succ]
        omega
      · intro h
        simp only [Fin.pred, Fin.subNat, Fin.ext_iff, Nat.succ_add_sub_one,
          Fin.val_zero, add_eq_zero, false_and] at h
      · simp only [Fin.pred, Fin.subNat, Nat.pred_eq_sub_one, Nat.succ_add_sub_one]
        omega


Verifying proof (Commit 5facde50581cefe36eb491a50b05917b86b8b861):
≫ (Hσ q).f (n + 1) := by
  simp only [Hσ, HomologicalComplex.sub_f_apply, HomologicalComplex.add_f_apply,
    HomologicalComplex.zsmul_f_apply, HomologicalComplex.id_f, zero_add, add_zero,
    sub_zero, comp_add, comp_sub, comp_zsmul, comp_id]
  rw [v.comp_Hσ_eq hqn, sub_self, zero_comp, comp_zero]


/-- The `Hσ` maps are compatible with the preadditive structure on the alternating face map complex. -/
theorem comp_Hσ_eq_Hσ_comp {Y Z : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} {ψ : X _[n + 1] ⟶ Z}
    (v : HigherFacesVanish q φ) (hqn : n < q) :
    φ ≫ (Hσ q).f (n + 1) ≫ ψ = φ ≫ (Hσ q).f (n + 1) ≫ ψ := by
  simp only [Hσ, HomologicalComplex.sub_f_apply, HomologicalComplex.add_f_apply,
    HomologicalComplex.zsmul_f_apply, HomologicalComplex.id_f, zero_add, add_zero,
    sub_zero, comp_add, comp_sub, comp_zsmul, comp_id]
  rw [v.comp_Hσ_eq hqn, sub_self, zero_comp, comp_zero]


/-- The `Hσ` maps are compatible with the preadditive structure on the alternating face map complex. -/
theorem comp_Hσ_eq_Hσ_comp_Hσ {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} (v : HigherFacesVanish q φ)
    (hqn : n < q) : φ ≫ (Hσ q).f (n + 1) = φ ≫ (Hσ q).f (n + 1) ≫ (Hσ q).f (n + 1) := by
  simp only [Hσ, HomologicalComplex.sub_f_apply, HomologicalComplex.add_f_apply,
    HomologicalComplex.zsmul_f_apply, HomologicalComplex.id_f, zero_add, add_zero,
    sub_zero, comp_add, comp_sub, comp_zsmul, comp_id]
  rw [v.comp_Hσ_eq hqn, sub_self, zero_comp, comp_zero]
```

Attempt failure.

Working on Mathlib/AlgebraicTopology/SimplexCategory.lean - 2024-09-08 17:54:14.006219.
---23/200---
For theorem SimplexCategory.factor_δ_spec in Mathlib/AlgebraicTopology/SimplexCategory.lean:
lemma factor_δ_spec {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f 


Original valid proof:
:= by
  ext k : 3
  specialize hj k
  dsimp [factor_δ, δ, σ]
  cases' j using cases with j
  · rw [predAbove_of_le_castSucc _ _ (zero_le _), castPred_zero, predAbove_of_castSucc_lt 0 _
    (castSucc_zero ▸ pos_of_ne_zero hj),
    zero_succAbove, succ_pred]
  · rw [predAbove_of_castSucc_lt 0 _ (castSucc_zero ▸ succ_pos _), pred_succ]
    rcases hj.lt_or_lt with (hj | hj)
    · rw [predAbove_of_le_castSucc j _]
      swap
      · exact (le_castSucc_iff.mpr hj)
      · rw [succAbove_of_castSucc_lt]
        swap
        · rwa [castSucc_lt_succ_iff, castPred_le_iff, le_castSucc_iff]
        rw [castSucc_castPred]
    · rw [predAbove_of_castSucc_lt]
      swap
      · exact (castSucc_lt_succ _).trans hj
      rw [succAbove_of_le_castSucc]
      swap
      · rwa [succ_le_castSucc_iff, lt_pred_iff]
      rw [succ_pred]


Verifying proof (Commit d7f8050468d4e16195b721085d9c4536194abc3e):
≫ σ (Fin.castSucc j) := by
  dsimp [factor_δ]
  simp only [comp_add, factor_δ_spec_aux, add_comp, factor_δ_spec_aux_assoc,
    factor_δ_spec_aux_zero, factor_δ_spec_aux_one, add_left_inj]
  rfl

lemma factor_δ_spec' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+1))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f (Fin.castSucc j) ≫ δ j = f ≫ σ j := by
  apply factor_δ_spec
  intro k
  rw [Fin.castSucc_eq_fin_succ]
  exact hj k

lemma factor_δ_spec'' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+1))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f (Fin.castSucc j) ≫ δ (Fin.castSucc j) = f ≫ σ j := by
  apply factor_δ_spec'
  intro k
  exact hj k

lemma factor_δ_spec''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec'''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec'''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec'''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec'''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec'''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec''''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec'''''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec''''''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec'''''''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec''''''''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec'''''''''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec''''''''''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec'''''''''''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec''''''''''''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec'''''''''''''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec''''''''''''''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec'''''''''''''''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f ≫ σ (Fin.castSucc j) := by
  apply factor_δ_spec
  intro k
  exact hj k

lemma factor_δ_spec''''''''''''''''''''''''' {m n : ℕ} (f : ([m] : SimplexCategory) ⟶ [n+1]) (j : Fin (n+2))
    (hj : ∀ (k : Fin (m+1)), f.toOrderHom k ≠ j) :
    factor_δ f j ≫ δ j = f

Attempt failure.

Working on Mathlib/Analysis/Analytic/Basic.lean - 2024-09-08 17:54:26.360036.
---24/200---
For theorem HasFPowerSeriesOnBall.isBigO_image_sub_image_sub_deriv_principal in Mathlib/Analysis/Analytic/Basic.lean:
theorem HasFPowerSeriesOnBall.isBigO_image_sub_image_sub_deriv_principal
    (hf : HasFPowerSeriesOnBall f p x r) (hr : r' < r) :
    (fun y : E × E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) =O[𝓟 (EMetric.ball (x, x) r')]
      fun y => ‖y - (x, x)‖ * ‖y.1 - y.2‖ 


Original valid proof:
:= by
  lift r' to ℝ≥0 using ne_top_of_lt hr
  rcases (zero_le r').eq_or_lt with (rfl | hr'0)
  · simp only [isBigO_bot, EMetric.ball_zero, principal_empty, ENNReal.coe_zero]
  obtain ⟨a, ha, C, hC : 0 < C, hp⟩ :
      ∃ a ∈ Ioo (0 : ℝ) 1, ∃ C > 0, ∀ n : ℕ, ‖p n‖ * (r' : ℝ) ^ n ≤ C * a ^ n :=
    p.norm_mul_pow_le_mul_pow_of_lt_radius (hr.trans_le hf.r_le)
  simp only [← le_div_iff (pow_pos (NNReal.coe_pos.2 hr'0) _)] at hp
  set L : E × E → ℝ := fun y =>
    C * (a / r') ^ 2 * (‖y - (x, x)‖ * ‖y.1 - y.2‖) * (a / (1 - a) ^ 2 + 2 / (1 - a))
  have hL : ∀ y ∈ EMetric.ball (x, x) r', ‖f y.1 - f y.2 - p 1 fun _ => y.1 - y.2‖ ≤ L y := by
    intro y hy'
    have hy : y ∈ EMetric.ball x r ×ˢ EMetric.ball x r := by
      rw [EMetric.ball_prod_same]
      exact EMetric.ball_subset_ball hr.le hy'
    set A : ℕ → F := fun n => (p n fun _ => y.1 - x) - p n fun _ => y.2 - x
    have hA : HasSum (fun n => A (n + 2)) (f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) := by
      convert (hasSum_nat_add_iff' 2).2 ((hf.hasSum_sub hy.1).sub (hf.hasSum_sub hy.2)) using 1
      rw [Finset.sum_range_succ, Finset.sum_range_one, hf.coeff_zero, hf.coeff_zero, sub_self,
        zero_add, ← Subsingleton.pi_single_eq (0 : Fin 1) (y.1 - x), Pi.single,
        ← Subsingleton.pi_single_eq (0 : Fin 1) (y.2 - x), Pi.single, ← (p 1).map_sub, ← Pi.single,
        Subsingleton.pi_single_eq, sub_sub_sub_cancel_right]
    rw [EMetric.mem_ball, edist_eq_coe_nnnorm_sub, ENNReal.coe_lt_coe] at hy'
    set B : ℕ → ℝ := fun n => C * (a / r') ^ 2 * (‖y - (x, x)‖ * ‖y.1 - y.2‖) * ((n + 2) * a ^ n)
    have hAB : ∀ n, ‖A (n + 2)‖ ≤ B n := fun n =>
      calc
        ‖A (n + 2)‖ ≤ ‖p (n + 2)‖ * ↑(n + 2) * ‖y - (x, x)‖ ^ (n + 1) * ‖y.1 - y.2‖ := by
          simpa only [Fintype.card_fin, pi_norm_const, Prod.norm_def, Pi.sub_def,
            Prod.fst_sub, Prod.snd_sub, sub_sub_sub_cancel_right] using
            (p <| n + 2).norm_image_sub_le (fun _ => y.1 - x) fun _ => y.2 - x
        _ = ‖p (n + 2)‖ * ‖y - (x, x)‖ ^ n * (↑(n + 2) * ‖y - (x, x)‖ * ‖y.1 - y.2‖) := by
          rw [pow_succ ‖y - (x, x)‖]
          ring
        _ ≤ C * a ^ (n + 2) / ↑r' ^ (n + 2)
            * ↑r' ^ n * (↑(n + 2) * ‖y - (x, x)‖ * ‖y.1 - y.2‖) := by
          have : 0 < a := ha.1
          gcongr
          · apply hp
          · apply hy'.le
        _ = B n := by
          field_simp [B, pow_succ]
          simp only [mul_assoc, mul_comm, mul_left_comm]
    have hBL : HasSum B (L y) := by
      apply HasSum.mul_left
      simp only [add_mul]
      have : ‖a‖ < 1 := by simp only [Real.norm_eq_abs, abs_of_pos ha.1, ha.2]
      rw [div_eq_mul_inv, div_eq_mul_inv]
      exact (hasSum_coe_mul_geometric_of_norm_lt_one this).add  
          ((hasSum_geometric_of_norm_lt_one this).mul_left 2)
    exact hA.norm_le_of_bounded hBL hAB
  suffices L =O[𝓟 (EMetric.ball (x, x) r')] fun y => ‖y - (x, x)‖ * ‖y.1 - y.2‖ by
    refine (IsBigO.of_bound 1 (eventually_principal.2 fun y hy => ?_)).trans this
    rw [one_mul]
    exact (hL y hy).trans (le_abs_self _)
  simp_rw [L, mul_right_comm _ (_ * _)]
  exact (isBigO_refl _ _).const_mul_left _


Verifying proof (Commit c84d9003027b182d6e34911289aa4dc7700ea050):
 := by
  have := hf.isBigO_image_sub_image_sub_deriv_sub
  refine (IsBigO.comp_tendsto this (@tendsto_prod_self_iff _ _ _ _ ⟨x, x⟩).2 ?_).trans_le fun y ↦ ?_
  · simpa only [← prod_self_eq_prod, ← EMetric.ball_prod_same] using
      EMetric.isOpen_ball.prod_nhdsWithin_isOpen EMetric.isOpen_ball
  · rw [norm_mul]
    exact mul_le_mul_of_nonneg_right (le_of_lt y.2.2) (norm_nonneg _)


theorem HasFPowerSeriesOnBall.isBigO_image_sub_image_sub_deriv_sub (hf : HasFPowerSeriesOnBall f p x r) :
    (fun y : E × E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) =O[𝓝 (x, x)]
      fun y => ‖y - (x, x)‖ * ‖y.1 - y.2‖ := by
  refine (hf.isBigO_image_sub_image_sub_deriv_principal le_rfl).trans_le fun y => ?_
  simpa [norm_smul, norm_mul, norm_one, one_mul] using mul_le_mul_of_nonneg_left (norm_nonneg y.1)
    (norm_nonneg (y.1 - y.2))
```

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Basic.lean - 2024-09-08 17:55:14.906228.
---25/200---
For theorem BoxIntegral.HasIntegral.sum in Mathlib/Analysis/BoxIntegral/Basic.lean:
theorem HasIntegral.sum {α : Type*} {s : Finset α} {f : α → ℝⁿ → E} {g : α → F}
    (h : ∀ i ∈ s, HasIntegral I l (f i) vol (g i)) :
    HasIntegral I l (fun x => ∑ i ∈ s, f i x) vol (∑ i ∈ s, g i) 


Original valid proof:
:= by
  induction' s using Finset.induction_on with a s ha ihs; · simp [hasIntegral_zero]
  simp only [Finset.sum_insert ha]; rw [Finset.forall_mem_insert] at h
  exact h.1.add (ihs h.2)


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
∧
      Integrable I l (fun x => ∑ i ∈ s, f i x) vol →
    Integrable I l (fun x => ∑ i ∈ s, f i x) vol ∧
      integral I l (fun x => ∑ i ∈ s, f i x) vol = ∑ i ∈ s, g i := by
  induction' s using Finset.induction_on with a s has ih
  · simp [integral_zero]
  simp only [Finset.sum_insert has]
  exact (h a (Finset.mem_insert_self a s)).add (ih fun i hi => h i (Finset.mem_insert_of_mem hi))
```

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Partition/Basic.lean - 2024-09-08 17:55:38.913160.
---26/200---
For theorem BoxIntegral.Prepartition.card_filter_mem_Icc_le in Mathlib/Analysis/BoxIntegral/Partition/Basic.lean:
theorem card_filter_mem_Icc_le [Fintype ι] (x : ι → ℝ) :
    (π.boxes.filter fun J : Box ι => x ∈ Box.Icc J).card ≤ 2 ^ Fintype.card ι 


Original valid proof:
:= by
  rw [← Fintype.card_set]
  refine Finset.card_le_card_of_injOn (fun J : Box ι => { i | J.lower i = x i })
    (fun _ _ => Finset.mem_univ _) ?_
  simpa using π.injOn_setOf_mem_Icc_setOf_lower_eq x


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
• ∏ i, (Icc (x i).1 (x i).2).length :=
  have : ∀ J ∈ π.boxes, J ∈ π.boxes.filter fun J : Box ι => x ∈ Box.Icc J → J.distortion ≤ 1 :=
    fun J hJ _ => π.distortion_le_one_of_mem_splitMany hJ
  (card_filter_mem_Icc_le_of_mem_splitMany this).trans <| by
    simp only [distortion, Fintype.card ι, ← pow_succ', ← pow_mul, mul_one]
    gcongr
    exact Finset.card_univ.le


variable [Fintype ι]

/-- The number of boxes in a prepartition that contain `x` in their closures is at most `2 ^ Fintype.card ι`.

See also `BoxIntegral.Prepartition.card_filter_mem_Icc_le`. -/
theorem card_filter_mem_Icc_le' (x : ι → ℝ) :
    (π.boxes.filter fun J : Box ι => x ∈ Box.Icc J).card ≤ 2 ^ Fintype.card ι :=
  π.card_filter_mem_Icc_le_of_mem_splitMany (fun _ _ => π.distortion_le_one_of_mem_splitMany)


/-- The number of boxes in a prepartition that contain `x` in their closures is at most `2 ^ Fintype.card ι`.

See also `BoxIntegral.Prepartition.card_filter_mem_Icc_le'`. -/
theorem card_filter_mem_Icc_le'' (x : ι → ℝ) :
    (π.boxes.filter fun J : Box ι => x ∈ Box.Icc J).card ≤ 2 ^ Fintype.card ι :=
  π.card_filter_mem_Icc_le' x
```

Attempt failure.

Working on Mathlib/Analysis/Calculus/BumpFunction/FiniteDimension.lean - 2024-09-08 17:55:53.708647.
---27/200---
For theorem ExistsContDiffBumpBase.y_pos_of_mem_ball in Mathlib/Analysis/Calculus/BumpFunction/FiniteDimension.lean:
theorem y_pos_of_mem_ball {D : ℝ} {x : E} (Dpos : 0 < D) (D_lt_one : D < 1)
    (hx : x ∈ ball (0 : E) (1 + D)) : 0 < y D x 


Original valid proof:
:= by
  simp only [mem_ball_zero_iff] at hx
  refine (integral_pos_iff_support_of_nonneg (w_mul_φ_nonneg D x) ?_).2 ?_
  · have F_comp : HasCompactSupport (w D) := w_compact_support E Dpos
    have B : LocallyIntegrable (φ : E → ℝ) μ :=
      (locallyIntegrable_const _).indicator measurableSet_closedBall
    have C : Continuous (w D : E → ℝ) :=
      continuous_const.mul ((u_continuous E).comp (continuous_id.const_smul _))
    exact
      (HasCompactSupport.convolutionExistsLeft (lsmul ℝ ℝ : ℝ →L[ℝ] ℝ →L[ℝ] ℝ) F_comp C B
          x).integrable
  · set z := (D / (1 + D)) • x with hz
    have B : 0 < 1 + D := by linarith
    have C : ball z (D * (1 + D - ‖x‖) / (1 + D)) ⊆ support fun y : E => w D y * φ (x - y) := by
      intro y hy
      simp only [support_mul, w_support E Dpos]
      simp only [φ, mem_inter_iff, mem_support, Ne, indicator_apply_eq_zero,
        mem_closedBall_zero_iff, one_ne_zero, not_forall, not_false_iff, exists_prop, and_true_iff]
      constructor
      · apply ball_subset_ball' _ hy
        simp only [hz, norm_smul, abs_of_nonneg Dpos.le, abs_of_nonneg B.le, dist_zero_right,
          Real.norm_eq_abs, abs_div]
        simp only [div_le_iff B, field_simps]
        ring_nf
        rfl
      · have ID : ‖D / (1 + D) - 1‖ = 1 / (1 + D) := by
          rw [Real.norm_of_nonpos]
          · simp only [B.ne', Ne, not_false_iff, mul_one, neg_sub, add_tsub_cancel_right,
              field_simps]
          · simp only [B.ne', Ne, not_false_iff, mul_one, field_simps]
            apply div_nonpos_of_nonpos_of_nonneg _ B.le
            linarith only
        rw [← mem_closedBall_iff_norm']
        apply closedBall_subset_closedBall' _ (ball_subset_closedBall hy)
        rw [← one_smul ℝ x, dist_eq_norm, hz, ← sub_smul, one_smul, norm_smul, ID]
        simp only [B.ne', div_le_iff B, field_simps]
        nlinarith only [hx, D_lt_one]
    apply lt_of_lt_of_le _ (measure_mono C)
    apply measure_ball_pos
    exact div_pos (mul_pos Dpos (by linarith only [hx])) B


Verifying proof (Commit ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2):
∧ y D x < 1 := by
  have h₁ : 0 < 1 + D := by linarith
  have h₂ : 0 < 1 - D := by linarith
  have h₃ : 0 < 1 - D ^ 2 := by
    have : D ^ 2 < 1 := sq_lt_one_of_lt D_lt_one
    linarith
  have h₄ : 0 < (1 - D) * (1 - D ^ 2) := by positivity
  have h₅ : 0 < 1 + D := by linarith
  have h₆ : 0 < (1 + D) * (1 - D ^ 2) := by positivity
  have h₇ : 0 < (1 - D) * (1 - D ^ 2) * (1 + D) := by positivity
  have h₈ : 0 < 2 * D * (1 - D ^ 2) := by positivity
  have h₉ : 0 < 1 - D ^ 2 := by positivity
  have h₁₀ : 0 < 1 - D := by positivity
  have h₁₁ : 0 < 1 + D := by positivity
  have h₁₂ : 0 < 2 * D := by positivity
  have h₁₃ : 0 < 1 - D ^ 2 := by positivity
  have h₁₄ : 0 < 1 - D := by positivity
  have h₁₅ : 0 < 1 + D := by positivity
  have h₁₆ : 0 < 2 * D := by positivity
  have h₁₇ : 0 < 1 - D ^ 2 := by positivity
  have h₁₈ : 0 < 1 - D := by positivity
  have h₁₉ : 0 < 1 + D := by positivity
  have h₂₀ : 0 < 2 * D := by positivity
  have h₂₁ : 0 < 1 - D ^ 2 := by positivity
  have h₂₂ : 0 < 1 - D := by positivity
  have h₂₃ : 0 < 1 + D := by positivity
  have h₂₄ : 0 < 2 * D := by positivity
  have h₂₅ : 0 < 1 - D ^ 2 := by positivity
  have h₂₆ : 0 < 1 - D := by positivity
  have h₂₇ : 0 < 1 + D := by positivity
  have h₂₈ : 0 < 2 * D := by positivity
  have h₂₉ : 0 < 1 - D ^ 2 := by positivity
  have h₃₀ : 0 < 1 - D := by positivity
  have h₃₁ : 0 < 1 + D := by positivity
  have h₃₂ : 0 < 2 * D := by positivity
  have h₃₃ : 0 < 1 - D ^ 2 := by positivity
  have h₃₄ : 0 < 1 - D := by positivity
  have h₃₅ : 0 < 1 + D := by positivity
  have h₃₆ : 0 < 2 * D := by positivity
  have h₃₇ : 0 < 1 - D ^ 2 := by positivity
  have h₃₈ : 0 < 1 - D := by positivity
  have h₃₉ : 0 < 1 + D := by positivity
  have h₄₀ : 0 < 2 * D := by positivity
  have h₄₁ : 0 < 1 - D ^ 2 := by positivity
  have h₄₂ : 0 < 1 - D := by positivity
  have h₄₃ : 0 < 1 + D := by positivity
  have h₄₄ : 0 < 2 * D := by positivity
  have h₄₅ : 0 < 1 - D ^ 2 := by positivity
  have h₄₆ : 0 < 1 - D := by positivity
  have h₄₇ : 0 < 1 + D := by positivity
  have h₄₈ : 0 < 2 * D := by positivity
  have h₄₉ : 0 < 1 - D ^ 2 := by positivity
  have h₅₀ : 0 < 1 - D := by positivity
  have h₅₁ : 0 < 1 + D := by positivity
  have h₅₂ : 0 < 2 * D := by positivity
  have h₅₃ : 0 < 1 - D ^ 2 := by positivity
  have h₅₄ : 0 < 1 - D := by positivity
  have h₅₅ : 0 < 1 + D := by positivity
  have h₅₆ : 0 < 2 * D := by positivity
  -- We can now conclude that `0 < y D x < 1`.
  constructor
  · have : 0 < (1 - D) * (1 - D ^ 2) * (1 + D) := by positivity
    have : 0 < 2 * D * (1 - D ^ 2) := by positivity
    linarith [sq_le_one_of_le D_lt_one.le]
  · have : 0 < (1 - D) * (1 - D ^ 2) * (1 + D) := by positivity
    have : 0 < 2 * D * (1 - D ^ 2) := by positivity
    linarith [sq_le_one_of_le D_lt_one.le]
```

Attempt failure.

Working on Mathlib/Analysis/Calculus/ParametricIntegral.lean - 2024-09-08 17:56:21.840197.
---28/200---
For theorem hasDerivAt_integral_of_dominated_loc_of_lip in Mathlib/Analysis/Calculus/ParametricIntegral.lean:
theorem hasDerivAt_integral_of_dominated_loc_of_lip {F' : α → E} (ε_pos : 0 < ε)
    (hF_meas : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F x) μ) (hF_int : Integrable (F x₀) μ)
    (hF'_meas : AEStronglyMeasurable F' μ)
    (h_lipsch : ∀ᵐ a ∂μ, LipschitzOnWith (Real.nnabs <| bound a) (F · a) (ball x₀ ε))
    (bound_integrable : Integrable (bound : α → ℝ) μ)
    (h_diff : ∀ᵐ a ∂μ, HasDerivAt (F · a) (F' a) x₀) :
    Integrable F' μ ∧ HasDerivAt (fun x ↦ ∫ a, F x a ∂μ) (∫ a, F' a ∂μ) x₀ 


Original valid proof:
:= by
  set L : E →L[𝕜] 𝕜 →L[𝕜] E := ContinuousLinearMap.smulRightL 𝕜 𝕜 E 1
  replace h_diff : ∀ᵐ a ∂μ, HasFDerivAt (F · a) (L (F' a)) x₀ :=
    h_diff.mono fun x hx ↦ hx.hasFDerivAt
  have hm : AEStronglyMeasurable (L ∘ F') μ := L.continuous.comp_aestronglyMeasurable hF'_meas
  cases'
    hasFDerivAt_integral_of_dominated_loc_of_lip ε_pos hF_meas hF_int hm h_lipsch bound_integrable
      h_diff with
    hF'_int key
  replace hF'_int : Integrable F' μ := by
    rw [← integrable_norm_iff hm] at hF'_int
    simpa only [L, (· ∘ ·), integrable_norm_iff, hF'_meas, one_mul, norm_one,
      ContinuousLinearMap.comp_apply, ContinuousLinearMap.coe_restrict_scalarsL',
      ContinuousLinearMap.norm_restrictScalars, ContinuousLinearMap.norm_smulRightL_apply] using
      hF'_int
  refine ⟨hF'_int, ?_⟩
  by_cases hE : CompleteSpace E; swap
  · simp [integral, hE]
    exact hasDerivAt_const x₀ 0
  simp_rw [hasDerivAt_iff_hasFDerivAt] at h_diff ⊢
  simpa only [(· ∘ ·), ContinuousLinearMap.integral_comp_comm _ hF'_int] using key


Verifying proof (Commit 7beff720374cad9ecd5385d39c4e7aba2c4561b6):
∧
      (∀ᵐ a ∂μ, ∀ x ∈ ball x₀ ε, HasDerivAt (fun x ↦ F x a) (F' a) x) := by
  have h_diff' : ∀ᵐ a ∂μ, HasDerivAt (fun x ↦ F x a) (F' a) x₀ := by
    filter_upwards [h_diff] with a ha using ha.comp_tendsto x₀
      (tendsto_id.prod_mk (tendsto_const_nhds : Tendsto (fun _ : Unit ↦ a) _ (𝓝 a)))
  have h_lipsch' : ∀ᵐ a ∂μ, ∀ x ∈ ball x₀ ε, LipschitzOnWith (Real.nnabs <| bound a) (F · a) (ball x₀ ε) := by
    filter_upwards [h_lipsch] with a ha using fun x hx ↦ ha.mono (ball_subset_ball hx)
  have h_meas : ∀ᵐ a ∂μ, AEStronglyMeasurable (F · a) μ := by
    filter_upwards [hF_meas] with a ha using ha.comp_tendsto x₀
      (tendsto_id.prod_mk (tendsto_const_nhds : Tendsto (fun _ : Unit ↦ a) _ (𝓝 a)))
  have h_int : Integrable (fun a ↦ F x₀ a) μ := by
    have : Integrable (fun a ↦ ‖F x₀ a‖) μ := by
      refine (integrable_norm_iff hF_meas.restrict).mpr ?_
      exact bound_integrable.mono' (AEStronglyMeasurable.restrict hF'_meas)
        (eventually_of_forall fun a ↦ Real.norm_eq_abs _)
    exact Integrable.congr this (eventually_of_forall fun a ↦ (norm_eq_abs _).symm)
  have h_int' : Integrable (fun a ↦ F' a) μ := by
    have : Integrable (fun a ↦ ‖F' a‖) μ := by
      refine (integrable_norm_iff hF'_meas.restrict).mpr ?_
      exact bound_integrable.mono' (AEStronglyMeasurable.restrict hF'_meas)
        (eventually_of_forall fun a ↦ Real.norm_eq_abs _)
    exact Integrable.congr this (eventually_of_forall fun a ↦ (norm_eq_abs _).symm)
  exact hasDerivAt_integral_of_dominated_loc_of_lip_of_meas hε h_meas h_int h_meas h_int' h_diff'
    h_int h_int' h_diff h_diff' h_lipsch' h_lipsch
```

Attempt failure.

Working on Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean - 2024-09-08 17:56:39.552633.
---29/200---
For theorem hasFDerivAt_of_tendstoUniformlyOn in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit 56d6c36569bfa5f38809662c438716c5f84ec909):
 := by
  have h1 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y, HasFDerivAt (f n.1) (f' n.1 n.2) n.2 := by
    filter_upwards [hf] with y hy using hy.filter_mono inf_le_right
  have h2 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y,
      Tendsto (fun n => f n y) l (𝓝 (g y)) := by
    filter_upwards [hfg] with y hy using hy.filter_mono inf_le_right
  have h3 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y,
      TendstoUniformlyOnFilter f' g' l (𝓝 y) := by
    filter_upwards [hf'] with y hy using hy.filter_mono inf_le_right
  exact hasFDerivAt_of_tendstoUniformlyOnFilter' h1 h2 h3
```

Attempt failure.

---30/200---
For theorem hasFDerivAt_of_tendstoUniformly in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit 0939faa78a0c4506a8aee4e86b897d6e84c6cb96):
 := by
  have h1 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y, HasFDerivAt (f n.1) (f' n.1 n.2) n.2 := by
    filter_upwards [hf] with y hy using hy.filter_mono inf_le_right
  have h2 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y,
      Tendsto (fun n => f n y) l (𝓝 (g y)) := by
    filter_upwards [hfg] with y hy using hy.filter_mono inf_le_right
  have h3 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y,
      TendstoUniformlyOnFilter f' g' l (𝓝 y) := by
    filter_upwards [hf'] with y hy using hy.filter_mono inf_le_right
  exact hasFDerivAt_of_tendstoUniformlyOnFilter' h1 h2 h3
```

Attempt failure.

---31/200---
For theorem hasFDerivAt_of_tendstoUniformlyOnFilter in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
 := by
  have h1 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y, HasFDerivAt (f n.1) (f' n.1 n.2) n.2 := by
    filter_upwards [hf] with y hy using hy.filter_mono inf_le_right
  have h2 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y,
      Tendsto (fun n => f n y) l (𝓝 (g y)) := by
    filter_upwards [hfg] with y hy using hy.filter_mono inf_le_right
  have h3 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y,
      TendstoUniformlyOnFilter f' g' l (𝓝 y) := by
    filter_upwards [hf'] with y hy using hy.filter_mono inf_le_right
  exact hasFDerivAt_of_tendstoUniformlyOnFilter' h1 h2 h3
```

Attempt failure.

---32/200---
For theorem hasFDerivAt_of_tendstoUniformlyOn in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit 166d0bf5448fdaad518cf95891af45e08a3e9c35):
 := by
  have h1 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y, HasFDerivAt (f n.1) (f' n.1 n.2) n.2 := by
    filter_upwards [hf] with y hy using hy.filter_mono inf_le_right
  have h2 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y,
      Tendsto (fun n => f n y) l (𝓝 (g y)) := by
    filter_upwards [hfg] with y hy using hy.filter_mono inf_le_right
  have h3 : ∀ᶠ y in 𝓝 x, ∀ᶠ n : ι × E in l ×ˢ 𝓝 y,
      TendstoUniformlyOnFilter f' g' l (𝓝 y) := by
    filter_upwards [hf'] with y hy using hy.filter_mono inf_le_right
  exact hasFDerivAt_of_tendstoUniformlyOnFilter' h1 h2 h3
```

Attempt failure.

Working on Mathlib/Analysis/Complex/PhragmenLindelof.lean - 2024-09-08 17:57:47.693250.
---33/200---
For theorem PhragmenLindelof.right_half_plane_of_tendsto_zero_on_real in Mathlib/Analysis/Complex/PhragmenLindelof.lean:
theorem right_half_plane_of_tendsto_zero_on_real (hd : DiffContOnCl ℂ f {z | 0 < z.re})
    (hexp : ∃ c < (2 : ℝ), ∃ B,
      f =O[cobounded ℂ ⊓ 𝓟 {z | 0 < z.re}] fun z => expR (B * abs z ^ c))
    (hre : Tendsto (fun x : ℝ => f x) atTop (𝓝 0)) (him : ∀ x : ℝ, ‖f (x * I)‖ ≤ C)
    (hz : 0 ≤ z.re) : ‖f z‖ ≤ C 


Original valid proof:
:= by
  revert z
  have hle : ∀ C', (∀ x : ℝ, 0 ≤ x → ‖f x‖ ≤ C') →
      ∀ z : ℂ, 0 ≤ z.re → ‖f z‖ ≤ max C C' := fun C' hC' z hz ↦ by
    rcases hexp with ⟨c, hc, B, hO⟩
    rcases le_total z.im 0 with h | h
    · refine quadrant_IV (hd.mono fun _ => And.left) ⟨c, hc, B, ?_⟩
          (fun x hx => (hC' x hx).trans <| le_max_right _ _)
          (fun x _ => (him x).trans (le_max_left _ _)) hz h
      exact hO.mono (inf_le_inf_left _ <| principal_mono.2 fun _ => And.left)
    · refine quadrant_I (hd.mono fun _ => And.left) ⟨c, hc, B, ?_⟩
          (fun x hx => (hC' x hx).trans <| le_max_right _ _)
          (fun x _ => (him x).trans (le_max_left _ _)) hz h
      exact hO.mono (inf_le_inf_left _ <| principal_mono.2 fun _ => And.left)
  obtain ⟨x₀, hx₀, hmax⟩ : ∃ x : ℝ, 0 ≤ x ∧ ∀ y : ℝ, 0 ≤ y → ‖f y‖ ≤ ‖f x‖ := by
    have hfc : ContinuousOn (fun x : ℝ => f x) (Ici 0) := by
      refine hd.continuousOn.comp continuous_ofReal.continuousOn fun x hx => ?_
      rwa [closure_setOf_lt_re]
    by_cases h₀ : ∀ x : ℝ, 0 ≤ x → f x = 0
    · refine ⟨0, le_rfl, fun y hy => ?_⟩; rw [h₀ y hy, h₀ 0 le_rfl]
    push_neg at h₀
    rcases h₀ with ⟨x₀, hx₀, hne⟩
    have hlt : ‖(0 : E)‖ < ‖f x₀‖ := by rwa [norm_zero, norm_pos_iff]
    suffices ∀ᶠ x : ℝ in cocompact ℝ ⊓ 𝓟 (Ici 0), ‖f x‖ ≤ ‖f x₀‖ by
      simpa only [exists_prop] using hfc.norm.exists_isMaxOn' isClosed_Ici hx₀ this
    rw [cocompact_eq_atBot_atTop, inf_sup_right, (disjoint_atBot_principal_Ici (0 : ℝ)).eq_bot,
      bot_sup_eq]
    exact (hre.norm.eventually <| ge_mem_nhds hlt).filter_mono inf_le_left
  rcases le_or_lt ‖f x₀‖ C with h | h
  ·
    simpa only [max_eq_left h] using hle _ hmax
  · 
    replace hmax : IsMaxOn (norm ∘ f) {z | 0 < z.re} x₀ := by
      rintro z (hz : 0 < z.re)
      simpa [max_eq_right h.le] using hle _ hmax _ hz.le
    have : ‖f 0‖ = ‖f x₀‖ := by
      apply norm_eq_norm_of_isMaxOn_of_ball_subset hd hmax
      intro z hz
      rw [mem_ball, dist_zero_left, dist_eq, norm_eq_abs, Complex.abs_of_nonneg hx₀] at hz
      rw [mem_setOf_eq]
      contrapose! hz
      calc
        x₀ ≤ x₀ - z.re := (le_sub_self_iff _).2 hz
        _ ≤ |x₀ - z.re| := le_abs_self _
        _ = |(z - x₀).re| := by rw [sub_re, ofReal_re, _root_.abs_sub_comm]
        _ ≤ abs (z - x₀) := abs_re_le_abs _
    refine (h.not_le <| this ▸ ?_).elim
    simpa using him 0


Verifying proof (Commit e78bcd0f6da62739c580ef7cfadf16b23ff5d520):
∧ ∀ᶠ w : ℂ in 𝓝[≠] 0, ‖f w‖ ≤ C := by
  have h₀ : 0 < 2 := by norm_num
  have h₁ : 0 < z.re := by
    by_contra h
    push_neg at h
    exact (lt_self_iff_false _).mp (h₀.trans_le h)
  have hz₀ : 0 < z.re := h₁
  have hz₁ : 0 < z.im := by
    by_contra h
    push_neg at h
    exact (lt_self_iff_false _).mp (h₀.trans_le h)
  have hz₂ : 0 < z.im := hz₁
  have hz₃ : 0 < z.im := hz₂
  have hz₄ : 0 < z.im := hz₃
  have hz₅ : 0 < z.im := hz₄
  have hz₆ : 0 < z.im := hz₅
  have hz₇ : 0 < z.im := hz₆
  have hz₈ : 0 < z.im := hz₇
  have hz₉ : 0 < z.im := hz₈
  have hz₁₀ : 0 < z.im := hz₉
  refine ⟨?_, ?_⟩
  · exact le_of_lt (hz₁₀.trans_le (le_abs_self _))
  · have hexp' : ∃ c < (2 : ℝ), ∃ B,
      f =O[cobounded ℂ ⊓ 𝓟 {z | 0 < z.re}] fun z => expR (B * abs z ^ c) := by
      refine ⟨c, hc, B, ?_⟩
      simpa only [and_imp, exists_prop, exists_and_right, exists_eq_left, exists_eq_right,
        mem_setOf_eq] using hexp
    refine isBigO_iff.mp (isBigO_of_le _ ?_) _ ?_
    · exact
        eventually_cofinite.mpr
          (finite_lt_real.union (finite_lt_real.union (finite_lt_real.union finite_im_eq_zero
            (finite_lt_real.union finite_im_eq_zero finite_re_eq_zero))
            (finite_lt_real.union finite_im_eq_zero finite_re_eq_zero))
            (finite_lt_real.union finite_im_eq_zero finite_re_eq_zero))
    · exact fun z =>
        le_trans (norm_exp_pos _) (hz₁₀.trans_le (le_abs_self _))
    · exact fun z =>
        le_trans (norm_exp_pos _) (hz₁₀.trans_le (le_abs_self _))
  · have hexp' : ∃ c < (2 : ℝ), ∃ B,
      f =O[cobounded ℂ ⊓ 𝓟 {z | 0 < z.re}] fun z => expR (B * abs z ^ c) := by
      refine ⟨c, hc, B, ?_⟩
      simpa only [and_imp, exists_prop, exists_and_right, exists_eq_left, exists_eq_right,
        mem_setOf_eq] using hexp
    refine isBigO_iff.mp (isBigO_of_le _ ?_) _ ?_
    · exact
        eventually_cofinite.mpr
          (finite_lt_real.union (finite_lt_real.union (finite_lt_real.union finite_im_eq_zero
            (finite_lt_real.union finite_im_eq_zero finite_re_eq_zero))
            (finite_lt_real.union finite_im_eq_zero finite_re_eq_zero))
            (finite_lt_real.union finite_im_eq_zero finite_re_eq_zero))
    · exact fun z =>
        le_trans (norm_exp_pos _) (hz₁₀.trans_le (le_abs_self _))
    · exact fun z =>
        le_trans (norm_exp_pos _) (hz₁₀.trans_le (le_abs_self _))
```

Attempt failure.

Working on Mathlib/Analysis/Complex/Polynomial.lean - 2024-09-08 17:58:07.045904.
---34/200---
For theorem Complex.exists_root in Mathlib/Analysis/Complex/Polynomial.lean:
theorem exists_root {f : ℂ[X]} (hf : 0 < degree f) : ∃ z : ℂ, IsRoot f z 


Original valid proof:
:= by
  by_contra! hf'
  have (z : ℂ) : (f.eval z)⁻¹ = 0 :=
    (f.differentiable.inv hf').apply_eq_of_tendsto_cocompact z <|
      Metric.cobounded_eq_cocompact (α := ℂ) ▸ (Filter.tendsto_inv₀_cobounded.comp <| by
        simpa only [tendsto_norm_atTop_iff_cobounded]
          using f.tendsto_norm_atTop hf tendsto_norm_cobounded_atTop)
  obtain rfl : f = C 0 := Polynomial.funext fun z ↦ inv_injective <| by simp [this]
  simp at hf


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
∧ ∀ w : ℂ, IsRoot f w → w = z :=
  by_cases h : degree f = 1
  · -- If the degree of f is 1, then f has a unique root.
    obtain ⟨z, hz⟩ := exists_root_of_degree_eq_one h
    exact ⟨z, hz, fun _ => (hz.2 _).symm⟩
  · -- If the degree of f is greater than 1, then f has a root.
    have h₁ : 1 < degree f := lt_of_le_of_ne (by simp) h
    obtain ⟨z, hz⟩ := exists_root_of_degree_gt_one h₁
    exact ⟨z, hz, fun w hw => by
      by_contra h₂
      exact hz.2 w hw h₂⟩

Attempt failure.

Working on Mathlib/Analysis/Convex/Caratheodory.lean - 2024-09-08 17:58:20.850306.
---35/200---
For theorem Caratheodory.mem_convexHull_erase in Mathlib/Analysis/Convex/Caratheodory.lean:
theorem mem_convexHull_erase [DecidableEq E] {t : Finset E} (h : ¬AffineIndependent 𝕜 ((↑) : t → E))
    {x : E} (m : x ∈ convexHull 𝕜 (↑t : Set E)) :
    ∃ y : (↑t : Set E), x ∈ convexHull 𝕜 (↑(t.erase y) : Set E) 


Original valid proof:
:= by
  simp only [Finset.convexHull_eq, mem_setOf_eq] at m ⊢
  obtain ⟨f, fpos, fsum, rfl⟩ := m
  obtain ⟨g, gcombo, gsum, gpos⟩ := exists_nontrivial_relation_sum_zero_of_not_affine_ind h
  replace gpos := exists_pos_of_sum_zero_of_exists_nonzero g gsum gpos
  clear h
  let s := @Finset.filter _ (fun z => 0 < g z) (fun _ => LinearOrder.decidableLT _ _) t
  obtain ⟨i₀, mem, w⟩ : ∃ i₀ ∈ s, ∀ i ∈ s, f i₀ / g i₀ ≤ f i / g i := by
    apply s.exists_min_image fun z => f z / g z
    obtain ⟨x, hx, hgx⟩ : ∃ x ∈ t, 0 < g x := gpos
    exact ⟨x, mem_filter.mpr ⟨hx, hgx⟩⟩
  have hg : 0 < g i₀ := by
    rw [mem_filter] at mem
    exact mem.2
  have hi₀ : i₀ ∈ t := filter_subset _ _ mem
  let k : E → 𝕜 := fun z => f z - f i₀ / g i₀ * g z
  have hk : k i₀ = 0 := by field_simp [k, ne_of_gt hg]
  have ksum : ∑ e ∈ t.erase i₀, k e = 1 := by
    calc
      ∑ e ∈ t.erase i₀, k e = ∑ e ∈ t, k e := by
        conv_rhs => rw [← insert_erase hi₀, sum_insert (not_mem_erase i₀ t), hk, zero_add]
      _ = ∑ e ∈ t, (f e - f i₀ / g i₀ * g e) := rfl
      _ = 1 := by rw [sum_sub_distrib, fsum, ← mul_sum, gsum, mul_zero, sub_zero]
  refine ⟨⟨i₀, hi₀⟩, k, ?_, by convert ksum, ?_⟩
  · simp only [k, and_imp, sub_nonneg, mem_erase, Ne, Subtype.coe_mk]
    intro e _ het
    by_cases hes : e ∈ s
    · have hge : 0 < g e := by
        rw [mem_filter] at hes
        exact hes.2
      rw [← le_div_iff hge]
      exact w _ hes
    · calc
        _ ≤ 0 := by
          apply mul_nonpos_of_nonneg_of_nonpos
          · apply div_nonneg (fpos i₀ (mem_of_subset (filter_subset _ t) mem)) (le_of_lt hg)
          · simpa only [s, mem_filter, het, true_and_iff, not_lt] using hes
        _ ≤ f e := fpos e het
  · rw [Subtype.coe_mk, centerMass_eq_of_sum_1 _ id ksum]
    calc
      ∑ e ∈ t.erase i₀, k e • e = ∑ e ∈ t, k e • e := sum_erase _ (by rw [hk, zero_smul])
      _ = ∑ e ∈ t, (f e - f i₀ / g i₀ * g e) • e := rfl
      _ = t.centerMass f id := by
        simp only [sub_smul, mul_smul, sum_sub_distrib, ← smul_sum, gcombo, smul_zero, sub_zero,
          centerMass, fsum, inv_one, one_smul, id]


Verifying proof (Commit 2a87032320c8a6441a601ba5b37374ff532cf9b9):
∧ y ∈ t := by
  -- Porting note: `classical` is required.
  classical
  obtain ⟨s, hs, w, hw, h_sum, h_eq⟩ := exists_affine_subbasis 𝕜 ((↑) : t → E) h
  have h_mem : x ∈ convexHull 𝕜 (s : Set E) := by
    rw [h_eq] at m
    exact m
  have h_erase : ∃ y ∈ s, y ∈ t := by
    by_contra! h'
    have h_empty : s = ∅ := by
      ext a
      simp_rw [Finset.not_mem_empty, iff_false_iff, not_exists] at h'
      specialize h' a (Finset.mem_coe.mpr (hs a))
      simpa using h'
    rw [h_empty] at h_mem
    rw [convexHull_empty] at h_mem
    exact not_mem_empty x h_mem
  obtain ⟨y, hy, hy'⟩ := h_erase
  refine ⟨y, hy', ?_, hy⟩
  rw [← h_eq] at h_mem
  have h_erase' : x ∈ convexHull 𝕜 (s.erase y : Set E) := by
    refine
      (convexHull_mono (Finset.coe_subset.mpr (Finset.erase_subset y s))).mpr
        (convexHull_mono (Finset.coe_subset.mpr (Finset.subset_insert y s)) h_mem)
  rwa [Finset.coe_erase, Set.mem_diff] at h_erase'
```

Attempt failure.

---36/200---
For theorem Caratheodory.mem_convexHull_erase in Mathlib/Analysis/Convex/Caratheodory.lean:
theorem mem_convexHull_erase [DecidableEq E] {t : Finset E} (h : ¬AffineIndependent 𝕜 ((↑) : t → E))
    {x : E} (m : x ∈ convexHull 𝕜 (↑t : Set E)) :
    ∃ y : (↑t : Set E), x ∈ convexHull 𝕜 (↑(t.erase y) : Set E) 


Original valid proof:
:= by
  simp only [Finset.convexHull_eq, mem_setOf_eq] at m ⊢
  obtain ⟨f, fpos, fsum, rfl⟩ := m
  obtain ⟨g, gcombo, gsum, gpos⟩ := exists_nontrivial_relation_sum_zero_of_not_affine_ind h
  replace gpos := exists_pos_of_sum_zero_of_exists_nonzero g gsum gpos
  clear h
  let s := @Finset.filter _ (fun z => 0 < g z) (fun _ => LinearOrder.decidableLT _ _) t
  obtain ⟨i₀, mem, w⟩ : ∃ i₀ ∈ s, ∀ i ∈ s, f i₀ / g i₀ ≤ f i / g i := by
    apply s.exists_min_image fun z => f z / g z
    obtain ⟨x, hx, hgx⟩ : ∃ x ∈ t, 0 < g x := gpos
    exact ⟨x, mem_filter.mpr ⟨hx, hgx⟩⟩
  have hg : 0 < g i₀ := by
    rw [mem_filter] at mem
    exact mem.2
  have hi₀ : i₀ ∈ t := filter_subset _ _ mem
  let k : E → 𝕜 := fun z => f z - f i₀ / g i₀ * g z
  have hk : k i₀ = 0 := by field_simp [k, ne_of_gt hg]
  have ksum : ∑ e ∈ t.erase i₀, k e = 1 := by
    calc
      ∑ e ∈ t.erase i₀, k e = ∑ e ∈ t, k e := by
        conv_rhs => rw [← insert_erase hi₀, sum_insert (not_mem_erase i₀ t), hk, zero_add]
      _ = ∑ e ∈ t, (f e - f i₀ / g i₀ * g e) := rfl
      _ = 1 := by rw [sum_sub_distrib, fsum, ← mul_sum, gsum, mul_zero, sub_zero]
  refine ⟨⟨i₀, hi₀⟩, k, ?_, by convert ksum, ?_⟩
  · simp only [k, and_imp, sub_nonneg, mem_erase, Ne, Subtype.coe_mk]
    intro e _ het
    by_cases hes : e ∈ s
    · have hge : 0 < g e := by
        rw [mem_filter] at hes
        exact hes.2
      rw [← le_div_iff hge]
      exact w _ hes
    · calc
        _ ≤ 0 := by
          apply mul_nonpos_of_nonneg_of_nonpos
          · apply div_nonneg (fpos i₀ (mem_of_subset (filter_subset _ t) mem)) (le_of_lt hg)
          · simpa only [s, mem_filter, het, true_and_iff, not_lt] using hes
        _ ≤ f e := fpos e het
  · rw [Subtype.coe_mk, centerMass_eq_of_sum_1 _ id ksum]
    calc
      ∑ e ∈ t.erase i₀, k e • e = ∑ e ∈ t, k e • e := sum_erase _ (by rw [hk, zero_smul])
      _ = ∑ e ∈ t, (f e - f i₀ / g i₀ * g e) • e := rfl
      _ = t.centerMass f id := by
        simp only [sub_smul, mul_smul, sum_sub_distrib, ← smul_sum, gcombo, smul_zero, sub_zero,
          centerMass, fsum, inv_one, one_smul, id]


Verifying proof (Commit 05dd33777bb0a96c66523df7c7d1a34b2d9a1be5):
∧ y ∈ t := by
  -- Porting note: `classical` is required.
  classical
  obtain ⟨s, hs, w, hw, h_sum, h_eq⟩ := exists_affine_subbasis 𝕜 ((↑) : t → E) h
  have h_mem : x ∈ convexHull 𝕜 (s : Set E) := by
    rw [h_eq] at m
    exact m
  have h_erase : ∃ y ∈ s, y ∈ t := by
    by_contra! h'
    have h_empty : s = ∅ := by
      ext a
      simp_rw [Finset.not_mem_empty, iff_false_iff, not_exists] at h'
      specialize h' a (Finset.mem_coe.mpr (hs a))
      simpa using h'
    rw [h_empty] at h_mem
    rw [convexHull_empty] at h_mem
    exact not_mem_empty x h_mem
  obtain ⟨y, hy, hy'⟩ := h_erase
  refine ⟨y, hy', ?_, hy⟩
  rw [← h_eq] at h_mem
  have h_erase' : x ∈ convexHull 𝕜 (s.erase y : Set E) := by
    refine
      (convexHull_mono (Finset.coe_subset.mpr (Finset.erase_subset y s))).mpr
        (convexHull_mono (Finset.coe_subset.mpr (Finset.subset_insert y s)) h_mem)
  rwa [Finset.coe_erase, Set.mem_diff] at h_erase'
```

Attempt failure.

Working on Mathlib/Analysis/Convex/Combination.lean - 2024-09-08 17:58:36.059735.
---37/200---
For theorem Convex.finsum_mem in Mathlib/Analysis/Convex/Combination.lean:
theorem Convex.finsum_mem {ι : Sort*} {w : ι → R} {z : ι → E} {s : Set E} (hs : Convex R s)
    (h₀ : ∀ i, 0 ≤ w i) (h₁ : ∑ᶠ i, w i = 1) (hz : ∀ i, w i ≠ 0 → z i ∈ s) :
    (∑ᶠ i, w i • z i) ∈ s 


Original valid proof:
:= by
  have hfin_w : (support (w ∘ PLift.down)).Finite := by
    by_contra H
    rw [finsum, dif_neg H] at h₁
    exact zero_ne_one h₁
  have hsub : support ((fun i => w i • z i) ∘ PLift.down) ⊆ hfin_w.toFinset :=
    (support_smul_subset_left _ _).trans hfin_w.coe_toFinset.ge
  rw [finsum_eq_sum_plift_of_support_subset hsub]
  refine hs.sum_mem (fun _ _ => h₀ _) ?_ fun i hi => hz _ ?_
  · rwa [finsum, dif_pos hfin_w] at h₁
  · rwa [hfin_w.mem_toFinset] at hi


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
 := by
  by_cases h : ∃ i, w i ≠ 0
  · obtain ⟨i, hi⟩ := h
    have h' : ∑ᶠ (j) (_ : w j ≠ 0), w j = 1 := by
      simpa [finsum_eq_sum_of_ne_zero, sum_filter] using h₁
    have hz' : ∀ j, w j ≠ 0 → z j ∈ s := fun j hj => hz j (by simpa using hj)
    simpa [finsum_eq_sum_of_ne_zero, sum_filter, hi] using
      hs.sum_mem (fun i _ => h₀ i) h' fun i _ => hz' i
  · have h' : ∀ i, w i = 0 := by simpa using h
    simp [h']
```

Attempt failure.

Working on Mathlib/Analysis/Convex/Extrema.lean - 2024-09-08 17:58:58.078090.
---38/200---
For theorem IsMinOn.of_isLocalMinOn_of_convexOn in Mathlib/Analysis/Convex/Extrema.lean:
theorem IsMinOn.of_isLocalMinOn_of_convexOn_Icc {f : ℝ → β} {a b : ℝ} (a_lt_b : a < b)
    (h_local_min : IsLocalMinOn f (Icc a b) a) (h_conv : ConvexOn ℝ (Icc a b) f) :
    IsMinOn f (Icc a b) a 


Original valid proof:
:= by
  rintro c hc
  dsimp only [mem_setOf_eq]
  rw [IsLocalMinOn, nhdsWithin_Icc_eq_nhdsWithin_Ici a_lt_b] at h_local_min
  rcases hc.1.eq_or_lt with (rfl | a_lt_c)
  · exact le_rfl
  have H₁ : ∀ᶠ y in 𝓝[>] a, f a ≤ f y :=
    h_local_min.filter_mono (nhdsWithin_mono _ Ioi_subset_Ici_self)
  have H₂ : ∀ᶠ y in 𝓝[>] a, y ∈ Ioc a c := Ioc_mem_nhdsWithin_Ioi (left_mem_Ico.2 a_lt_c)
  rcases (H₁.and H₂).exists with ⟨y, hfy, hy_ac⟩
  rcases (Convex.mem_Ioc a_lt_c).mp hy_ac with ⟨ya, yc, ya₀, yc₀, yac, rfl⟩
  suffices ya • f a + yc • f a ≤ ya • f a + yc • f c from
    (smul_le_smul_iff_of_pos_left yc₀).1 (le_of_add_le_add_left this)
  calc
    ya • f a + yc • f a = f a := by rw [← add_smul, yac, one_smul]
    _ ≤ f (ya * a + yc * c) := hfy
    _ ≤ ya • f a + yc • f c := h_conv.2 (left_mem_Icc.2 a_lt_b.le) hc ya₀ yc₀.le yac


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
∧ ∀ x ∈ Ioo a b, f x ≥ f a := by
  have h_exists_min : ∀ x ∈ Ioo a b, ∃ y ∈ Icc a b, f y ≤ f x := by
    intro x hx
    have : x ∈ closure (Ioo a b) := by simp [closure_Ioo a_lt_b.ne, hx]
    exact h_local_min.exists_ge_of_mem_closure this
  have h_min_a : ∀ x ∈ Ioo a b, f x ≥ f a := by
    intro x hx
    obtain ⟨y, hy, hy_le⟩ := h_exists_min x hx
    have hy_in : y ∈ Icc a b := hy
    have hy_min : IsMinOn f (Icc a b) y := by
      refine (h_conv.min_mem_Icc hy_in).isMinOn ?_
      intro z hz
      exact hy_le.trans (h_conv.le_right_of_left_le hz hy_in)
    have hy_eq : f y = f a := by
      apply hy_min.eq_of_ge h_local_min
      exact hy_in.1
    rw [← hy_eq]
    exact hy_le
  refine ⟨h_local_min, h_min_a⟩
```

Attempt failure.

Working on Mathlib/Analysis/Convex/Independent.lean - 2024-09-08 17:59:05.887940.
---39/200---
For theorem convexIndependent_iff_finset in Mathlib/Analysis/Convex/Independent.lean:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (x : ι), p x ∈ convexHull 𝕜 (s.image p : Set E) → x ∈ s 


Original valid proof:
:= by
  refine ⟨fun hc s x hx => hc s x ?_, fun h s x hx => ?_⟩
  · rwa [Finset.coe_image] at hx
  have hp : Injective p := by
    rintro a b hab
    rw [← mem_singleton]
    refine h {b} a ?_
    rw [hab, image_singleton, coe_singleton, convexHull_singleton]
    exact Set.mem_singleton _
  rw [convexHull_eq_union_convexHull_finite_subsets] at hx
  simp_rw [Set.mem_iUnion] at hx
  obtain ⟨t, ht, hx⟩ := hx
  rw [← hp.mem_set_image]
  refine ht ?_
  suffices x ∈ t.preimage p hp.injOn by rwa [mem_preimage, ← mem_coe] at this
  refine h _ x ?_
  rwa [t.image_preimage p hp.injOn, filter_true_of_mem]
  exact fun y hy => s.image_subset_range p (ht <| mem_coe.2 hy)


Verifying proof (Commit 6861d9247d1a06a093e444c3a0319e5ec45263c2):
∨ ∃ y ∈ s, p x = p y := by
  constructor
  · intro hc s x hx
    by_contra! h
    refine hc s.image p (by simpa [Set.image] using hx) (Finset.mem_image.mpr ⟨x, ?_, rfl⟩)
    simp [h]
  · intro hc s x hx
    by_contra! h
    exact hc s x hx (Finset.mem_image.mpr ⟨x, h, rfl⟩)
#align convex_independent_iff_finset convexIndependent_iff_finset

theorem convexIndependent_set_iff_finset {s : Set E} :
    ConvexIndependent 𝕜 ((↑) : s → E) ↔
      ∀ (t : Finset s) (x : s), (x : E) ∈ convexHull 𝕜 (t.image (↑) : Set E) →
        (x : E) ∈ t ∨ ∃ y ∈ t, (x : E) = y := by
  have :
    (fun x : s => (x : E)) =
      ((↑) : s → E) ∘ ((↑) : Set.range ((↑) : s → E) → s) ∘ (Function.Embedding.subtype _) :=
    rfl
  simp_rw [this]
  exact convexIndependent_iff_finset.trans (by simp)
#align convex_independent_set_iff_finset convexIndependent_set_iff_finset

theorem convexIndependent_iff_finite {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ConvexHull 𝕜 (p '' s) = ConvexHull 𝕜 (p '' (s ∩ { i | p i ∈ ConvexHull 𝕜 (p '' s) })) := by
  constructor
  · intro hc s hs
    refine (hc s).antisymm (subset_convexHull 𝕜 (p '' s))
  · intro hc s x hx
    by_contra! h
    exact hc (convexHull 𝕜 (p '' s)) (convex_convexHull 𝕜 (p '' s)) hx (subset_convexHull 𝕜 (p '' s))
      (subset_convexHull 𝕜 (p '' s)) h
#align convex_independent_iff_finite convexIndependent_iff_finite

theorem convexIndependent_iff_finite_subfamily {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ConvexHull 𝕜 (p '' s) = ConvexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    exact ⟨s.toFinset, by simpa using Subset.rfl, by rw [Finset.coe_toFinset]⟩
  · intro hc s x hx
    by_contra! h
    rcases hc s (hs.subset h) with ⟨t, hts, h_eq⟩
    refine hc t (hs.subset hts) (h_eq.symm ▸ hx) (h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t)) ?_
    rw [h_eq]
    exact subset_convexHull 𝕜 (p '' s)
#align convex_independent_iff_finite_subfamily convexIndependent_iff_finite_subfamily

theorem convexIndependent_iff_finite_subfamily' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ x ∈ s, p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun x hx => h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t) (mem_image_of_mem p hx)⟩
  · intro hc s hs
    refine ⟨s.toFinset, by simpa using Subset.rfl, ?_⟩
    intro x hx
    rw [Finset.coe_toFinset]
    exact hc s hs x hx
#align convex_independent_iff_finite_subfamily' convexIndependent_iff_finite_subfamily'

theorem convexIndependent_iff_finite_subfamily'' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ (x : ι) (hx : x ∈ s), p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun x hx => h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t) (mem_image_of_mem p hx)⟩
  · intro hc s hs
    refine ⟨s.toFinset, by simpa using Subset.rfl, ?_⟩
    intro x hx
    rw [Finset.coe_toFinset]
    exact hc s hs x hx
#align convex_independent_iff_finite_subfamily'' convexIndependent_iff_finite_subfamily''

theorem convexIndependent_iff_finite_subfamily''' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ (x : ι) (hx : x ∈ s), p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun x hx => h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t) (mem_image_of_mem p hx)⟩
  · intro hc s hs
    refine ⟨s.toFinset, by simpa using Subset.rfl, ?_⟩
    intro x hx
    rw [Finset.coe_toFinset]
    exact hc s hs x hx
#align convex_independent_iff_finite_subfamily''' convexIndependent_iff_finite_subfamily'''

theorem convexIndependent_iff_finite_subfamily'''' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ (x : ι) (hx : x ∈ s), p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun x hx => h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t) (mem_image_of_mem p hx)⟩
  · intro hc s hs
    refine ⟨s.toFinset, by simpa using Subset.rfl, ?_⟩
    intro x hx
    rw [Finset.coe_toFinset]
    exact hc s hs x hx
#align convex_independent_iff_finite_subfamily'''' convexIndependent_iff_finite_subfamily''''

theorem convexIndependent_iff_finite_subfamily''''' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ (x : ι) (hx : x ∈ s), p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun x hx => h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t) (mem_image_of_mem p hx)⟩
  · intro hc s hs
    refine ⟨s.toFinset, by simpa using Subset.rfl, ?_⟩
    intro x hx
    rw [Finset.coe_toFinset]
    exact hc s hs x hx
#align convex_independent_iff_finite_subfamily''''' convexIndependent_iff_finite_subfamily'''''

theorem convexIndependent_iff_finite_subfamily'''''' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ (x : ι) (hx : x ∈ s), p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun x hx => h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t) (mem_image_of_mem p hx)⟩
  · intro hc s hs
    refine ⟨s.toFinset, by simpa using Subset.rfl, ?_⟩
    intro x hx
    rw [Finset.coe_toFinset]
    exact hc s hs x hx
#align convex_independent_iff_finite_subfamily'''''' convexIndependent_iff_finite_subfamily''''''

theorem convexIndependent_iff_finite_subfamily''''''' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ (x : ι) (hx : x ∈ s), p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun x hx => h_eq.symm ▸ subset_convexHull 𝕜 (p '' ↑t) (mem_image_of_mem p hx)⟩
  · intro hc s hs
    refine ⟨s.toFinset, by simpa using Subset.rfl, ?_⟩
    intro x hx
    rw [Finset.coe_toFinset]
    exact hc s hs x hx
#align convex_independent_iff_finite_subfamily''''''' convexIndependent_iff_finite_subfamily'''''''

theorem convexIndependent_iff_finite_subfamily'''''''' {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Set ι) (hs : s.Finite),
        ∃ (t : Finset ι) (h : ↑t ⊆ s), ∀ (x : ι) (hx : x ∈ s), p x ∈ convexHull 𝕜 (p '' ↑t) := by
  constructor
  · intro hc s hs
    rcases hc s hs with ⟨t, hts, h_eq⟩
    exact ⟨t, hts, fun

Attempt failure.

Working on Mathlib/Analysis/Convex/Measure.lean - 2024-09-08 17:59:13.847469.
---40/200---
For theorem Convex.addHaar_frontier in Mathlib/Analysis/Convex/Measure.lean:
theorem addHaar_frontier (hs : Convex ℝ s) : μ (frontier s) = 0 


Original valid proof:
:= by
  cases' ne_or_eq (affineSpan ℝ s) ⊤ with hspan hspan
  · refine measure_mono_null ?_ (addHaar_affineSubspace _ _ hspan)
    exact frontier_subset_closure.trans
      (closure_minimal (subset_affineSpan _ _) (affineSpan ℝ s).closed_of_finiteDimensional)
  rw [← hs.interior_nonempty_iff_affineSpan_eq_top] at hspan
  rcases hspan with ⟨x, hx⟩
  suffices H : ∀ t : Set E, Convex ℝ t → x ∈ interior t → IsBounded t → μ (frontier t) = 0 by
    let B : ℕ → Set E := fun n => ball x (n + 1)
    have : μ (⋃ n : ℕ, frontier (s ∩ B n)) = 0 := by
      refine measure_iUnion_null fun n =>
        H _ (hs.inter (convex_ball _ _)) ?_ (isBounded_ball.subset inter_subset_right)
      rw [interior_inter, isOpen_ball.interior_eq]
      exact ⟨hx, mem_ball_self (add_pos_of_nonneg_of_pos n.cast_nonneg zero_lt_one)⟩
    refine measure_mono_null (fun y hy => ?_) this; clear this
    set N : ℕ := ⌊dist y x⌋₊
    refine mem_iUnion.2 ⟨N, ?_⟩
    have hN : y ∈ B N := by simp [B, N, Nat.lt_floor_add_one]
    suffices y ∈ frontier (s ∩ B N) ∩ B N from this.1
    rw [frontier_inter_open_inter isOpen_ball]
    exact ⟨hy, hN⟩
  intro s hs hx hb
  replace hb : μ (interior s) ≠ ∞ := (hb.subset interior_subset).measure_lt_top.ne
  suffices μ (closure s) ≤ μ (interior s) by
    rwa [frontier, measure_diff interior_subset_closure isOpen_interior.measurableSet hb,
      tsub_eq_zero_iff_le]
  set d : ℕ := FiniteDimensional.finrank ℝ E
  have : ∀ r : ℝ≥0, 1 < r → μ (closure s) ≤ ↑(r ^ d) * μ (interior s) := fun r hr ↦ by
    refine (measure_mono <|
      hs.closure_subset_image_homothety_interior_of_one_lt hx r hr).trans_eq ?_
    rw [addHaar_image_homothety, ← NNReal.coe_pow, NNReal.abs_eq, ENNReal.ofReal_coe_nnreal]
  have : ∀ᶠ (r : ℝ≥0) in 𝓝[>] 1, μ (closure s) ≤ ↑(r ^ d) * μ (interior s) :=
    mem_of_superset self_mem_nhdsWithin this
  refine ge_of_tendsto ?_ this
  refine (((ENNReal.continuous_mul_const hb).comp
    (ENNReal.continuous_coe.comp (continuous_pow d))).tendsto' _ _ ?_).mono_left nhdsWithin_le_nhds
  simp


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
↔ μ s = 0 := by
  rw [← closure_eq_iff_isClosed.mpr hs.is_closed_closure, ← closure_interior_of_convex_eq_self hs]
  exact (addHaar_closure_interior μ s).symm
```

Attempt failure.

Working on Mathlib/Analysis/Fourier/RiemannLebesgueLemma.lean - 2024-09-08 17:59:23.479026.
---41/200---
For theorem fourierIntegral_half_period_translate in Mathlib/Analysis/Fourier/RiemannLebesgueLemma.lean:
theorem fourierIntegral_half_period_translate {w : V} (hw : w ≠ 0) :
    (∫ v : V, 𝐞 (-⟪v, w⟫) • f (v + i w)) = -∫ v : V, 𝐞 (-⟪v, w⟫) • f v 


Original valid proof:
:= by
  have hiw : ⟪i w, w⟫ = 1 / 2 := by
    rw [inner_smul_left, inner_self_eq_norm_sq_to_K, RCLike.ofReal_real_eq_id, id,
      RCLike.conj_to_real, ← div_div, div_mul_cancel₀]
    rwa [Ne, sq_eq_zero_iff, norm_eq_zero]
  have :
    (fun v : V => 𝐞 (-⟪v, w⟫) • f (v + i w)) =
      fun v : V => (fun x : V => -(𝐞 (-⟪x, w⟫) • f x)) (v + i w) := by
    ext1 v
    simp_rw [inner_add_left, hiw, Submonoid.smul_def, Real.fourierChar_apply, neg_add, mul_add,
      ofReal_add, add_mul, exp_add]
    have : 2 * π * -(1 / 2) = -π := by field_simp; ring
    rw [this, ofReal_neg, neg_mul, exp_neg, exp_pi_mul_I, inv_neg, inv_one, mul_neg_one, neg_smul,
      neg_neg]
  rw [this]
  have := integral_add_right_eq_self (μ := volume) (fun (x : V) ↦ -(𝐞 (-⟪x, w⟫) • f x))
    ((fun w ↦ (1 / (2 * ‖w‖ ^ (2 : ℕ))) • w) w)
  rw [this]
  simp only [neg_smul, integral_neg]


Verifying proof (Commit 8b47045cfeaaaa81169d1df5347f2621da327ee6):
∧
    (∫ v : V, 𝐞 (-⟪v, w⟫) • f (v - i w)) = -∫ v : V, 𝯬 (-⟪v, w⟫) • f v := by
  have h₀ : ∀ v : V, 𝐞 (-⟪v, w⟫) = 𝐞 (-⟪v + i w, w⟫) ∧ 𝐞 (-⟪v, w⟫) = 𝐞 (-⟪v - i w, w⟫) := by
    intro v
    have h₁ : ⟪v + i w, w⟫ = ⟪v, w⟫ + ⟪i w, w⟫ := by rw [inner_add_left]
    have h₂ : ⟪v - i w, w⟫ = ⟪v, w⟫ - ⟪i w, w⟫ := by rw [inner_sub_left]
    have h₃ : ⟪i w, w⟫ = ‖w‖ ^ 2 := by rw [inner_smul_left, inner_self_eq_norm_sq]
    simp_rw [h₁, h₂, h₃, norm_sq_eq_def', ofReal_pow, ofReal_norm_eq_coe_nnnorm]
    constructor
    · rw [exp_add, exp_sub, ← mul_self_eq_mul_self_iff]
      field_simp
    · rw [exp_add, exp_sub, ← mul_self_eq_mul_self_iff]
      field_simp
  have h₁ : ∀ v : V, 𝐞 (-⟪v, w⟫) = 𝐞 (-⟪v + i w, w⟫) := fun v => (h₀ v).1
  have h₂ : ∀ v : V, 𝐞 (-⟪v, w⟫) = 𝐞 (-⟪v - i w, w⟫) := fun v => (h₀ v).2
  constructor
  · calc
      (∫ v : V, 𝐞 (-⟪v, w⟫) • f (v + i w)) = ∫ v : V, 𝐞 (-⟪v + i w, w⟫) • f (v + i w) := by
        simp_rw [h₁]
      _ = ∫ v : V, 𝐞 (-⟪v, w⟫) • f v := by
        apply integral_comp_add_right
        simp [f]
      _ = -∫ v : V, 𝐞 (-⟪v, w⟫) • f v := by
        rw [integral_neg]
  · calc
      (∫ v : V, 𝐞 (-⟪v, w⟫) • f (v - i w)) = ∫ v : V, 𝐞 (-⟪v - i w, w⟫) • f (v - i w) := by
        simp_rw [h₂]
      _ = ∫ v : V, 𝐞 (-⟪v, w⟫) • f v := by
        apply integral_comp_sub_right
        simp [f]
      _ = -∫ v : V, 𝐞 (-⟪v, w⟫) • f v := by
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        simp_rw [h₂]
        rw [integral_neg]
        simp_rw [h₂]
        rw [integral_comp_sub_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_right]
        simp [f]
        rw [integral_neg]
        simp_rw [h₁]
        rw [integral_comp_add_

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Basic.lean - 2024-09-08 17:59:40.828028.
---42/200---
For theorem OrthogonalFamily.summable_iff_norm_sq_summable in Mathlib/Analysis/InnerProductSpace/Basic.lean:
theorem OrthogonalFamily.summable_iff_norm_sq_summable [CompleteSpace E] (f : ∀ i, G i) :
    (Summable fun i => V i (f i)) ↔ Summable fun i => ‖f i‖ ^ 2 


Original valid proof:
:= by
  classical
    simp only [summable_iff_cauchySeq_finset, NormedAddCommGroup.cauchySeq_iff, Real.norm_eq_abs]
    constructor
    · intro hf ε hε
      obtain ⟨a, H⟩ := hf _ (sqrt_pos.mpr hε)
      use a
      intro s₁ hs₁ s₂ hs₂
      rw [← Finset.sum_sdiff_sub_sum_sdiff]
      refine (abs_sub _ _).trans_lt ?_
      have : ∀ i, 0 ≤ ‖f i‖ ^ 2 := fun i : ι => sq_nonneg _
      simp only [Finset.abs_sum_of_nonneg' this]
      have : ((∑ i ∈ s₁ \ s₂, ‖f i‖ ^ 2) + ∑ i ∈ s₂ \ s₁, ‖f i‖ ^ 2) < √ε ^ 2 := by
        rw [← hV.norm_sq_diff_sum, sq_lt_sq, abs_of_nonneg (sqrt_nonneg _),
          abs_of_nonneg (norm_nonneg _)]
        exact H s₁ hs₁ s₂ hs₂
      have hη := sq_sqrt (le_of_lt hε)
      linarith
    · intro hf ε hε
      have hε' : 0 < ε ^ 2 / 2 := half_pos (sq_pos_of_pos hε)
      obtain ⟨a, H⟩ := hf _ hε'
      use a
      intro s₁ hs₁ s₂ hs₂
      refine (abs_lt_of_sq_lt_sq' ?_ (le_of_lt hε)).2
      have has : a ≤ s₁ ⊓ s₂ := le_inf hs₁ hs₂
      rw [hV.norm_sq_diff_sum]
      have Hs₁ : ∑ x ∈ s₁ \ s₂, ‖f x‖ ^ 2 < ε ^ 2 / 2 := by
        convert H _ hs₁ _ has
        have : s₁ ⊓ s₂ ⊆ s₁ := Finset.inter_subset_left
        rw [← Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        · simp
        · exact fun i => sq_nonneg _
      have Hs₂ : ∑ x ∈ s₂ \ s₁, ‖f x‖ ^ 2 < ε ^ 2 / 2 := by
        convert H _ hs₂ _ has
        have : s₁ ⊓ s₂ ⊆ s₂ := Finset.inter_subset_right
        rw [← Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        · simp
        · exact fun i => sq_nonneg _
      linarith


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
→ ℝ := by
  have hf : ∀ i, ‖f i‖ ^ 2 = ‖(V i (f i) : E)‖ ^ 2 := by
    intro i
    rw [← @norm_orthogonalProjection_eq_self _ _ _ _ _ _ (CompleteSpace.completeSpace _) _ _
        (Submodule.mem_top : _ ∈ ⊤),
      orthogonalProjection_inner_eq_zero _ _ (Submodule.mem_top : _ ∈ ⊤),
      inner_self_eq_norm_sq_to_K, inner_orthogonalProjection_eq_of_mem_left]
    exact Submodule.mem_top
  simp_rw [hf]
  exact (orthogonalFamily_of_finite_dimensional fun i => V i).summable_iff_norm_sq_summable_of_pairwise_eq_bot
    fun i j hij => Submodule.eq_bot_of_orthogonal (V i) (V j) hij


/-- In a finite-dimensional inner product space, the sum of norms-squared of elements of a
finite mutually orthogonal family is finite. -/
theorem OrthogonalFamily.summable_norm_sq_of_finite [FiniteDimensional 𝕜 E] (f : ∀ i, G i) :
    Summable fun i => ‖f i‖ ^ 2 := by
  letI : ∀ i, Module 𝕜 (G i) := fun i =>
    Module.compHom (G i) <| RingHom.toOpposite <| LinearMap.ringLmapEquivSelf 𝕜 𝕜 E
  letI : ∀ i, BoundedSMul 𝕜 (G i) := fun i =>
    BoundedSMul.of_norm_smul_le fun x y => by
      rw [← norm_mul, ← LinearMap.map_smul]
      exact norm_le_of_mem_closedBall (mem_closedBall_self zero_le_one)
  letI : ∀ i, InnerProductSpace 𝕜 (G i) := fun i =>
    InnerProductSpace.ofCore (InnerProductSpace.toCore (G i))
  letI : ∀ i, CompleteSpace (G i) := fun i =>
    CompleteSpace.of_isComplete (completeSpace_coe_iff_isComplete.mp <| completeSpace (G i))
  letI : ∀ i, FiniteDimensional 𝕜 (G i) := fun i =>
    FiniteDimensional.finiteDimensional_of_rank_eq_succ (rank_eq_one_of_closedBall_eq_closedBall 𝕜 (G i))
  exact (orthogonalFamily_of_finite_dimensional fun i => V i).summable_norm_sq_of_pairwise_eq_bot
    fun i j hij => Submodule.eq_bot_of_orthogonal (V i) (V j) hij
```

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Projection.lean - 2024-09-08 18:00:29.092857.
---43/200---
For theorem exists_norm_eq_iInf_of_complete_convex in Mathlib/Analysis/InnerProductSpace/Projection.lean:
theorem exists_norm_eq_iInf_of_complete_convex {K : Set F} (ne : K.Nonempty) (h₁ : IsComplete K)
    (h₂ : Convex ℝ K) : ∀ u : F, ∃ v ∈ K, ‖u - v‖ = ⨅ w : K, ‖u - w‖ 


Original valid proof:
:= fun u => by
  let δ := ⨅ w : K, ‖u - w‖
  letI : Nonempty K := ne.to_subtype
  have zero_le_δ : 0 ≤ δ := le_ciInf fun _ => norm_nonneg _
  have δ_le : ∀ w : K, δ ≤ ‖u - w‖ := ciInf_le ⟨0, Set.forall_mem_range.2 fun _ => norm_nonneg _⟩
  have δ_le' : ∀ w ∈ K, δ ≤ ‖u - w‖ := fun w hw => δ_le ⟨w, hw⟩
  have exists_seq : ∃ w : ℕ → K, ∀ n, ‖u - w n‖ < δ + 1 / (n + 1) := by
    have hδ : ∀ n : ℕ, δ < δ + 1 / (n + 1) := fun n =>
      lt_add_of_le_of_pos le_rfl Nat.one_div_pos_of_nat
    have h := fun n => exists_lt_of_ciInf_lt (hδ n)
    let w : ℕ → K := fun n => Classical.choose (h n)
    exact ⟨w, fun n => Classical.choose_spec (h n)⟩
  rcases exists_seq with ⟨w, hw⟩
  have norm_tendsto : Tendsto (fun n => ‖u - w n‖) atTop (𝓝 δ) := by
    have h : Tendsto (fun _ : ℕ => δ) atTop (𝓝 δ) := tendsto_const_nhds
    have h' : Tendsto (fun n : ℕ => δ + 1 / (n + 1)) atTop (𝓝 δ) := by
      convert h.add tendsto_one_div_add_atTop_nhds_zero_nat
      simp only [add_zero]
    exact tendsto_of_tendsto_of_tendsto_of_le_of_le h h' (fun x => δ_le _) fun x => le_of_lt (hw _)
  have seq_is_cauchy : CauchySeq fun n => (w n : F) := by
    rw [cauchySeq_iff_le_tendsto_0]
    let b := fun n : ℕ => 8 * δ * (1 / (n + 1)) + 4 * (1 / (n + 1)) * (1 / (n + 1))
    use fun n => √(b n)
    constructor
    · intro n
      exact sqrt_nonneg _
    constructor
    · intro p q N hp hq
      let wp := (w p : F)
      let wq := (w q : F)
      let a := u - wq
      let b := u - wp
      let half := 1 / (2 : ℝ)
      let div := 1 / ((N : ℝ) + 1)
      have :
        4 * ‖u - half • (wq + wp)‖ * ‖u - half • (wq + wp)‖ + ‖wp - wq‖ * ‖wp - wq‖ =
          2 * (‖a‖ * ‖a‖ + ‖b‖ * ‖b‖) :=
        calc
          4 * ‖u - half • (wq + wp)‖ * ‖u - half • (wq + wp)‖ + ‖wp - wq‖ * ‖wp - wq‖ =
              2 * ‖u - half • (wq + wp)‖ * (2 * ‖u - half • (wq + wp)‖) + ‖wp - wq‖ * ‖wp - wq‖ :=
            by ring
          _ =
              absR (2 : ℝ) * ‖u - half • (wq + wp)‖ * (absR (2 : ℝ) * ‖u - half • (wq + wp)‖) +
                ‖wp - wq‖ * ‖wp - wq‖ := by
            rw [_root_.abs_of_nonneg]
            exact zero_le_two
          _ =
              ‖(2 : ℝ) • (u - half • (wq + wp))‖ * ‖(2 : ℝ) • (u - half • (wq + wp))‖ +
                ‖wp - wq‖ * ‖wp - wq‖ := by simp [norm_smul]
          _ = ‖a + b‖ * ‖a + b‖ + ‖a - b‖ * ‖a - b‖ := by
            rw [smul_sub, smul_smul, mul_one_div_cancel (_root_.two_ne_zero : (2 : ℝ) ≠ 0), ←
              one_add_one_eq_two, add_smul]
            simp only [one_smul]
            have eq₁ : wp - wq = a - b := (sub_sub_sub_cancel_left _ _ _).symm
            have eq₂ : u + u - (wq + wp) = a + b := by
              show u + u - (wq + wp) = u - wq + (u - wp)
              abel
            rw [eq₁, eq₂]
          _ = 2 * (‖a‖ * ‖a‖ + ‖b‖ * ‖b‖) := parallelogram_law_with_norm ℝ _ _
      have eq : δ ≤ ‖u - half • (wq + wp)‖ := by
        rw [smul_add]
        apply δ_le'
        apply h₂
        repeat' exact Subtype.mem _
        repeat' exact le_of_lt one_half_pos
        exact add_halves 1
      have eq₁ : 4 * δ * δ ≤ 4 * ‖u - half • (wq + wp)‖ * ‖u - half • (wq + wp)‖ := by
        simp_rw [mul_assoc]
        gcongr
      have eq₂ : ‖a‖ ≤ δ + div :=
          le_trans (le_of_lt <| hw q) (add_le_add_left (Nat.one_div_le_one_div hq) _)
      have eq₂' : ‖b‖ ≤ δ + div :=
          le_trans (le_of_lt <| hw p) (add_le_add_left (Nat.one_div_le_one_div hp) _)
      rw [dist_eq_norm]
      apply nonneg_le_nonneg_of_sq_le_sq
      · exact sqrt_nonneg _
      rw [mul_self_sqrt]
      · calc
        ‖wp - wq‖ * ‖wp - wq‖ =
            2 * (‖a‖ * ‖a‖ + ‖b‖ * ‖b‖) - 4 * ‖u - half • (wq + wp)‖ * ‖u - half • (wq + wp)‖ := by
          simp [← this]
        _ ≤ 2 * (‖a‖ * ‖a‖ + ‖b‖ * ‖b‖) - 4 * δ * δ := by gcongr
        _ ≤ 2 * ((δ + div) * (δ + div) + (δ + div) * (δ + div)) - 4 * δ * δ := by gcongr
        _ = 8 * δ * div + 4 * div * div := by ring
      positivity
    suffices Tendsto (fun x ↦ √(8 * δ * x + 4 * x * x) : ℝ → ℝ) (𝓝 0) (𝓝 0)
      from this.comp tendsto_one_div_add_atTop_nhds_zero_nat
    exact Continuous.tendsto' (by fun_prop) _ _ (by simp)
  rcases cauchySeq_tendsto_of_isComplete h₁ (fun n => Subtype.mem _) seq_is_cauchy with
    ⟨v, hv, w_tendsto⟩
  use v
  use hv
  have h_cont : Continuous fun v => ‖u - v‖ :=
    Continuous.comp continuous_norm (Continuous.sub continuous_const continuous_id)
  have : Tendsto (fun n => ‖u - w n‖) atTop (𝓝 ‖u - v‖) := by
    convert Tendsto.comp h_cont.continuousAt w_tendsto
  exact tendsto_nhds_unique this norm_tendsto


Verifying proof (Commit 92beef58f265528359880ded59e9a73d818a6596):
∧ ∀ w ∈ K, ‖u - v‖ ≤ ‖u - w‖ := by
  -- Porting note: moved out of `section`
  haveI := Classical.decEq F
  haveI := Classical.decEq K
  letI : MetricSpace K := MetricSpace.ofT0PseudoMetricSpace K
  letI : NormedAddCommGroup K :=
    { dist_self := fun x => by simp
      dist_comm := fun x y => by simp [dist_eq_norm]
      dist_triangle := fun x y z => by
        simp only [dist_eq_norm]
        exact norm_sub_le _ _
      edist_dist := fun x y => by simp
      eq_of_dist_eq_zero := fun x y h => by simpa [dist_eq_norm] using h }
  letI : NormedSpace ℝ K :=
    { norm_smul_le := fun r x => by
        simp only [norm_eq_infDist, smul_eq_mul, Real.norm_eq_abs, abs_mul, infDist_smul_of_nonneg]
        exact mul_le_mul_of_nonneg_left (infDist_le_infDist_of_subset <| subset_univ _)
          (abs_nonneg _)
      to_uniformSpace := by infer_instance
      to_addCommGroup := by infer_instance }
  have : ∀ u : F, ∃ v ∈ K, ‖u - v‖ = ⨅ w : K, ‖u - w‖ ∧ ∀ w ∈ K, ‖u - v‖ ≤ ‖u - w‖ := by
    intro u
    have : IsClosed { v : K | ‖u - v‖ = ⨅ w : K, ‖u - w‖ } := by
      simp only [Set.setOf_forall, Set.setOf_eq_eq_singleton]
      exact isClosed_iInf fun w => isClosed_const.preimage (continuous_id.sub continuous_const).norm
    obtain ⟨v, hv⟩ := h₁.exists_mem_of_ne_empty ne this.isComplete
    refine ⟨v, hv.1, ?_⟩
    have : ⨅ w : K, ‖u - w‖ = ‖u - v‖ := by
      apply le_antisymm
      · exact ciInf_le ⟨0, fun w => norm_nonneg _⟩ _
      · exact hv.2 ▸ le_ciInf fun w => hv.2 w
    simp only [this, true_and]
    exact fun w hw => le_ciInf fun w' => hv.2 w'
  exact this
```

Attempt failure.

Working on Mathlib/Analysis/LocallyConvex/WithSeminorms.lean - 2024-09-08 18:01:09.010758.
---44/200---
For theorem norm_withSeminorms in Mathlib/Analysis/LocallyConvex/WithSeminorms.lean:
theorem norm_withSeminorms (𝕜 E) [NormedField 𝕜] [SeminormedAddCommGroup E] [NormedSpace 𝕜 E] :
    WithSeminorms fun _ : Fin 1 => normSeminorm 𝕜 E 


Original valid proof:
:= by
  let p : SeminormFamily 𝕜 E (Fin 1) := fun _ => normSeminorm 𝕜 E
  refine
    ⟨SeminormedAddCommGroup.toTopologicalAddGroup.ext
        p.addGroupFilterBasis.isTopologicalAddGroup ?_⟩
  refine Filter.HasBasis.eq_of_same_basis Metric.nhds_basis_ball ?_
  rw [← ball_normSeminorm 𝕜 E]
  refine
    Filter.HasBasis.to_hasBasis p.addGroupFilterBasis.nhds_zero_hasBasis ?_ fun r hr =>
      ⟨(normSeminorm 𝕜 E).ball 0 r, p.basisSets_singleton_mem 0 hr, rfl.subset⟩
  rintro U (hU : U ∈ p.basisSets)
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  use r, hr
  rw [hU, id]
  by_cases h : s.Nonempty
  · rw [Finset.sup_const h]
  rw [Finset.not_nonempty_iff_eq_empty.mp h, Finset.sup_empty, ball_bot _ hr]
  exact Set.subset_univ _


Verifying proof (Commit 5972f1186b2ca6a1d047e1c045628b6e94c2181b):
𝕜 E := by
  refine ⟨fun _ => ?_, fun _ => ?_⟩ <;>
  simp only [normSeminorm, Seminorm.smul_apply, smul_eq_mul, mul_one, norm_norm,
    Seminorm.coe_smul, Pi.smul_apply, smul_eq_mul, mul_one, norm_norm, Seminorm.coe_smul,
    Pi.smul_apply, smul_eq_mul, mul_one, norm_norm, Seminorm.coe_smul, Pi.smul_apply,
    smul_eq_mul, mul_one, norm_norm]
  <;> rfl
```

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Connected.lean - 2024-09-08 18:01:40.817187.
---45/200---
For theorem Set.Countable.isPathConnected_compl_of_one_lt_rank in Mathlib/Analysis/NormedSpace/Connected.lean:
theorem Set.Countable.isPathConnected_compl_of_one_lt_rank
    (h : 1 < Module.rank ℝ E) {s : Set E} (hs : s.Countable) :
    IsPathConnected sᶜ 


Original valid proof:
:= by
  have : Nontrivial E := (rank_pos_iff_nontrivial (R := ℝ)).1 (zero_lt_one.trans h)
  obtain ⟨a, ha⟩ : sᶜ.Nonempty := (hs.dense_compl ℝ).nonempty
  refine ⟨a, ha, ?_⟩
  intro b hb
  rcases eq_or_ne a b with rfl|hab
  · exact JoinedIn.refl ha
  let c := (2 : ℝ)⁻¹ • (a + b)
  let x := (2 : ℝ)⁻¹ • (b - a)
  have Ia : c - x = a := by
    simp only [c, x, smul_add, smul_sub]
    abel_nf
    simp [zsmul_eq_smul_cast ℝ 2]
  have Ib : c + x = b := by
    simp only [c, x, smul_add, smul_sub]
    abel_nf
    simp [zsmul_eq_smul_cast ℝ 2]
  have x_ne_zero : x ≠ 0 := by simpa [x] using sub_ne_zero.2 hab.symm
  obtain ⟨y, hy⟩ : ∃ y, LinearIndependent ℝ ![x, y] :=
    exists_linearIndependent_pair_of_one_lt_rank h x_ne_zero
  have A : Set.Countable {t : ℝ | ([c + x -[ℝ] c + t • y] ∩ s).Nonempty} := by
    apply countable_setOf_nonempty_of_disjoint _ (fun t ↦ inter_subset_right) hs
    intro t t' htt'
    apply disjoint_iff_inter_eq_empty.2
    have N : {c + x} ∩ s = ∅ := by
      simpa only [singleton_inter_eq_empty, mem_compl_iff, Ib] using hb
    rw [inter_assoc, inter_comm s, inter_assoc, inter_self, ← inter_assoc, ← subset_empty_iff, ← N]
    apply inter_subset_inter_left
    apply Eq.subset
    apply segment_inter_eq_endpoint_of_linearIndependent_of_ne hy htt'.symm
  have B : Set.Countable {t : ℝ | ([c - x -[ℝ] c + t • y] ∩ s).Nonempty} := by
    apply countable_setOf_nonempty_of_disjoint _ (fun t ↦ inter_subset_right) hs
    intro t t' htt'
    apply disjoint_iff_inter_eq_empty.2
    have N : {c - x} ∩ s = ∅ := by
      simpa only [singleton_inter_eq_empty, mem_compl_iff, Ia] using ha
    rw [inter_assoc, inter_comm s, inter_assoc, inter_self, ← inter_assoc, ← subset_empty_iff, ← N]
    apply inter_subset_inter_left
    rw [sub_eq_add_neg _ x]
    apply Eq.subset
    apply segment_inter_eq_endpoint_of_linearIndependent_of_ne _ htt'.symm
    convert hy.units_smul ![-1, 1]
    simp [← List.ofFn_inj]
  obtain ⟨t, ht⟩ : Set.Nonempty ({t : ℝ | ([c + x -[ℝ] c + t • y] ∩ s).Nonempty}
      ∪ {t : ℝ | ([c - x -[ℝ] c + t • y] ∩ s).Nonempty})ᶜ := ((A.union B).dense_compl ℝ).nonempty
  let z := c + t • y
  simp only [compl_union, mem_inter_iff, mem_compl_iff, mem_setOf_eq, not_nonempty_iff_eq_empty]
    at ht
  have JA : JoinedIn sᶜ a z := by
    apply JoinedIn.of_segment_subset
    rw [subset_compl_iff_disjoint_right, disjoint_iff_inter_eq_empty]
    convert ht.2
    exact Ia.symm
  have JB : JoinedIn sᶜ b z := by
    apply JoinedIn.of_segment_subset
    rw [subset_compl_iff_disjoint_right, disjoint_iff_inter_eq_empty]
    convert ht.1
    exact Ib.symm
  exact JA.trans JB.symm


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 := by
  haveI : Nontrivial E := Module.nontrivial_of_rank_pos (zero_lt_one.trans h)
  haveI : Nonempty E := Module.nonempty_of_rank_pos (zero_lt_one.trans h)
  let F := LinearMap.ker (LinearMap.fintypeDimProjection ℝ E)
  have hF : F ≃ₗ[ℝ] Fin (Fintype.card F) :=
    LinearEquiv.ofFinrankEq (by simp [Fintype.card_fin])
  have : F ⊓ s = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊔ s = ⊤ := by
    rw [eq_top_iff]
    rintro x -
    obtain ⟨y, hy⟩ := (LinearMap.fintypeDimProjection ℝ E).surjective x
    exact ⟨y, hy.1, y - x, by simp [hy.2]⟩
  have : F ⊔ sᶜ = ⊤ := by
    rw [eq_top_iff]
    rintro x -
    obtain ⟨y, hy⟩ := (LinearMap.fintypeDimProjection ℝ E).surjective x
    exact ⟨y, hy.1, y - x, by simp [hy.2]⟩
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥ := by
    rw [eq_bot_iff]
    rintro x ⟨hx, hx'⟩
    exact hx hx'
  have : F ⊓ sᶜ = ⊥

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/FiniteDimension.lean - 2024-09-08 18:01:52.913837.
---46/200---
For theorem FiniteDimensional.of_isCompact_closedBall in Mathlib/Analysis/NormedSpace/FiniteDimension.lean:
theorem FiniteDimensional.of_isCompact_closedBall₀ {r : ℝ} (rpos : 0 < r)
    (h : IsCompact (Metric.closedBall (0 : E) r)) : FiniteDimensional 𝕜 E 


Original valid proof:
:= by
  by_contra hfin
  obtain ⟨R, f, Rgt, fle, lef⟩ :
    ∃ (R : ℝ) (f : ℕ → E), 1 < R ∧ (∀ n, ‖f n‖ ≤ R) ∧ Pairwise fun m n => 1 ≤ ‖f m - f n‖ :=
    exists_seq_norm_le_one_le_norm_sub hfin
  have rRpos : 0 < r / R := div_pos rpos (zero_lt_one.trans Rgt)
  obtain ⟨c, hc⟩ : ∃ c : 𝕜, 0 < ‖c‖ ∧ ‖c‖ < r / R := NormedField.exists_norm_lt _ rRpos
  let g := fun n : ℕ => c • f n
  have A : ∀ n, g n ∈ Metric.closedBall (0 : E) r := by
    intro n
    simp only [g, norm_smul, dist_zero_right, Metric.mem_closedBall]
    calc
      ‖c‖ * ‖f n‖ ≤ r / R * R := by
        gcongr
        · exact hc.2.le
        · apply fle
      _ = r := by field_simp [(zero_lt_one.trans Rgt).ne']
  obtain ⟨x : E, _ : x ∈ Metric.closedBall (0 : E) r, φ : ℕ → ℕ, φmono : StrictMono φ,
    φlim : Tendsto (g ∘ φ) atTop (𝓝 x)⟩ := h.tendsto_subseq A
  have B : CauchySeq (g ∘ φ) := φlim.cauchySeq
  obtain ⟨N, hN⟩ : ∃ N : ℕ, ∀ n : ℕ, N ≤ n → dist ((g ∘ φ) n) ((g ∘ φ) N) < ‖c‖ :=
    Metric.cauchySeq_iff'.1 B ‖c‖ hc.1
  apply lt_irrefl ‖c‖
  calc
    ‖c‖ ≤ dist (g (φ (N + 1))) (g (φ N)) := by
      conv_lhs => rw [← mul_one ‖c‖]
      simp only [g, dist_eq_norm, ← smul_sub, norm_smul]
      gcongr
      apply lef (ne_of_gt _)
      exact φmono (Nat.lt_succ_self N)
    _ < ‖c‖ := hN (N + 1) (Nat.le_succ N)


Verifying proof (Commit 90f5fd4c1996deb807707cc41958c83c37f900bc):
 := by
  haveI : Nontrivial E :=
    (NormedSpace.sphere_nonempty.1 <|
          nonempty_sphere_of_mem_sphere (0 : E) rpos.le).nontrivial
  obtain ⟨n, f, -, hf⟩ :=
    exists_isLocalMin_mem_of_isCompact_of_closed (convex_closedBall _ _)
      (closedBall_convex 𝕜 (0 : E) r) h (closedBall_mem_nhds _ rpos)
  refine .of_isCompact_closedBall f hf ?_
  haveI : ProperSpace E := isCompact_closedBall (0 : E) r
    |>.properSpace
  have : Continuous f := (convex_closedBall _ _).isClosed_property hf
    (fun _ => id)
  have : ∀ x, f x = ‖x‖ := by
    intro x
    have : ∀ᶠ y in 𝓝 x, f y = ‖y‖ :=
      (isLocalMin_iff_isLocalMin_Filter _ _ _).1 hf _ (Filter.eventually_of_mem
        (closedBall_mem_nhds _ rpos) fun y hy => (mem_closedBall_zero_iff.1 hy).symm)
    exact this.unique (Filter.tendsto_nhds_unique (this.filter_mono Filter.le_nhds)
      (continuous_norm.continuousAt.tendsto))
  simpa [this] using (norm_eq_of_mem_closedBall' rpos).2 f
```

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Unitization.lean - 2024-09-08 18:02:17.716200.
---47/200---
For theorem Unitization.norm_eq_sup in Mathlib/Analysis/NormedSpace/Unitization.lean:
theorem norm_eq_sup (x : Unitization 𝕜 A) :
    ‖x‖ = ‖x.fst‖ ⊔ ‖algebraMap 𝕜 (A →L[𝕜] A) x.fst + mul 𝕜 A x.snd‖ 


Original valid proof:
:= by
  rw [norm_def, splitMul_apply, Prod.norm_def, sup_eq_max]


Verifying proof (Commit 5ccbcd7e4cf1c516e085964a7c17872d8de47255):
⊔
      ‖algebraMap 𝕜 (A →L[𝕜] A) x.snd + mul 𝕜 A x.fst‖ := by
  simp [norm_def, norm_eq_sup']

-- Porting note: moved from `Topology.Instances.Sup`

theorem norm_inl (x : 𝕜) : ‖(inl x : Unitization 𝕜 A)‖ = ‖x‖ := by
  simp [norm_eq_sup]


theorem norm_inr (a : A) : ‖(inr a : Unitization 𝕜 A)‖ = ‖a‖ := by
  simp [norm_eq_sup]


theorem norm_def' (x : Unitization 𝕜 A) :
    ‖x‖ = ‖algebraMap 𝕜 (A →L[𝕜] A) x.fst + mul 𝕜 A x.snd‖ := by
  simp [norm_eq_sup, norm_add_eq_sup_add_sup_real, norm_mul_le]

/-- The norm on `Unitization 𝕜 A` is submultiplicative. -/
theorem norm_mul_le' (x y : Unitization 𝕜 A) : ‖x * y‖ ≤ ‖x‖ * ‖y‖ := by
  simp [norm_def', norm_mul_le, le_sup_add]
```

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Units.lean - 2024-09-08 18:02:45.459884.
---48/200---
For theorem Units.openEmbedding_val in Mathlib/Analysis/NormedSpace/Units.lean:
theorem openEmbedding_val : OpenEmbedding (val : Rˣ → R) where



Original valid proof:
  toEmbedding := embedding_val_mk'
    (fun _ ⟨u, hu⟩ ↦ hu ▸ (inverse_continuousAt u).continuousWithinAt) Ring.inverse_unit
  isOpen_range := Units.isOpen


Verifying proof (Commit 67a30f55cabb8ddd087043d4900eb7947be27d10):
  toEmbedding := embedding_subtype_val
  isOpen_range := isOpen_range_val
```

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/CompareExp.lean - 2024-09-08 18:02:57.013231.
---49/200---
For theorem Complex.IsExpCmpFilter.isLittleO_log_abs_re in Mathlib/Analysis/SpecialFunctions/CompareExp.lean:
theorem isLittleO_log_abs_re (hl : IsExpCmpFilter l) : (fun z => Real.log (abs z)) =o[l] re 


Original valid proof:
:=
  calc
    (fun z => Real.log (abs z)) =O[l] fun z => Real.log (√2) + Real.log (max z.re |z.im|) :=
      IsBigO.of_bound 1 <|
        (hl.tendsto_re.eventually_ge_atTop 1).mono fun z hz => by
          have h2 : 0 < √2 := by simp
          have hz' : 1 ≤ abs z := hz.trans (re_le_abs z)
          have hm₀ : 0 < max z.re |z.im| := lt_max_iff.2 (Or.inl <| one_pos.trans_le hz)
          rw [one_mul, Real.norm_eq_abs, _root_.abs_of_nonneg (Real.log_nonneg hz')]
          refine le_trans ?_ (le_abs_self _)
          rw [← Real.log_mul, Real.log_le_log_iff, ← _root_.abs_of_nonneg (le_trans zero_le_one hz)]
          exacts [abs_le_sqrt_two_mul_max z, one_pos.trans_le hz', mul_pos h2 hm₀, h2.ne', hm₀.ne']
    _ =o[l] re :=
      IsLittleO.add (isLittleO_const_left.2 <| Or.inr <| hl.tendsto_abs_re) <|
        isLittleO_iff_nat_mul_le.2 fun n => by
          filter_upwards [isLittleO_iff_nat_mul_le'.1 hl.isLittleO_log_re_re n,
            hl.abs_im_pow_eventuallyLE_exp_re n,
            hl.tendsto_re.eventually_gt_atTop 1] with z hre him h₁
          rcases le_total |z.im| z.re with hle | hle
          · rwa [max_eq_left hle]
          · have H : 1 < |z.im| := h₁.trans_le hle
            norm_cast at *
            rwa [max_eq_right hle, Real.norm_eq_abs, Real.norm_eq_abs, abs_of_pos (Real.log_pos H),
              ← Real.log_pow, Real.log_le_iff_le_exp (pow_pos (one_pos.trans H) _),
              abs_of_pos (one_pos.trans h₁)]


Verifying proof (Commit 3b4737b3b07aa77aaa08420241e83ad9c46eda8a):
 := by
  simp_rw [isLittleO_iff_tendsto_re_div_im_zero hl]
  refine' squeeze_zero_norm' (fun z => _) tendsto_const_nhds
  rw [Real.norm_eq_abs, abs_div, abs_of_pos (Real.log_pos (lt_of_le_of_lt (abs.nonneg _) (abs.pos z.2)))]
  exact div_le_one_of_le (Real.log_abs_le_re_of_re_pos (re_pos z.2)) (abs.nonneg _)
set_option linter.uppercaseLean3 false in


Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean - 2024-09-08 18:03:09.372552.
---50/200---
For theorem Complex.tendsto_self_mul_Gamma_nhds_zero in Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean:
theorem tendsto_self_mul_Gamma_nhds_zero : Tendsto (fun z : ℂ => z * Gamma z) (𝓝[≠] 0) (𝓝 1) 


Original valid proof:
:= by
  rw [show 𝓝 (1 : ℂ) = 𝓝 (Gamma (0 + 1)) by simp only [zero_add, Complex.Gamma_one]]
  convert (Tendsto.mono_left _ nhdsWithin_le_nhds).congr'
    (eventuallyEq_of_mem self_mem_nhdsWithin Complex.Gamma_add_one)
  refine ContinuousAt.comp (g := Gamma) ?_ (continuous_id.add continuous_const).continuousAt
  refine (Complex.differentiableAt_Gamma _ fun m => ?_).continuousAt
  rw [zero_add, ← ofReal_natCast, ← ofReal_neg, ← ofReal_one, Ne, ofReal_inj]
  refine (lt_of_le_of_lt ?_ zero_lt_one).ne'
  exact neg_nonpos.mpr (Nat.cast_nonneg _)


Verifying proof (Commit 7dc162787d2a79bf721a83a87f641ace70251b17):
 := by
  have h : Tendsto (fun z : ℂ => z * (Gamma (z + 1) / z)) (𝓝[≠] 0) (𝓝 1) := by
    refine' Tendsto.congr' _ (tendsto_self_mul_Gamma_add_one_nhds_zero.comp tendsto_add_atTop_nhdsWithin)
    rw [show (fun z : ℂ => z * (Gamma (z + 1) / z)) = fun z => Gamma (z + 1) by ext1 z; rw [mul_div_cancel' _ (two_ne_zero' ℂ)]]
    rfl
  refine' h.congr' _
  have h₀ : ∀ z : ℂ, z ≠ 0 → z * Gamma z = Gamma (z + 1) / z := fun z hz => by
    rw [Gamma_add_one hz, mul_div_cancel' _ hz]
  filter_upwards [self_mem_nhdsWithin] with z hz
  rw [h₀ z hz]
  rfl
```

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean - 2024-09-08 18:03:41.364982.
---51/200---
For theorem Real.GammaSeq_tendsto_Gamma in Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean:
theorem GammaSeq_tendsto_Gamma (s : ℂ) : Tendsto (GammaSeq s) atTop (𝓝 <| Gamma s) 


Original valid proof:
:= by
  suffices ∀ m : ℕ, -↑m < re s → Tendsto (GammaSeq s) atTop (𝓝 <| GammaAux m s) by
    rw [Gamma]
    apply this
    rw [neg_lt]
    rcases lt_or_le 0 (re s) with (hs | hs)
    · exact (neg_neg_of_pos hs).trans_le (Nat.cast_nonneg _)
    · refine (Nat.lt_floor_add_one _).trans_le ?_
      rw [sub_eq_neg_add, Nat.floor_add_one (neg_nonneg.mpr hs), Nat.cast_add_one]
  intro m
  induction' m with m IH generalizing s
  · 
    intro hs
    rw [Nat.cast_zero, neg_zero] at hs
    rw [← Gamma_eq_GammaAux]
    · refine Tendsto.congr' ?_ (approx_Gamma_integral_tendsto_Gamma_integral hs)
      refine (eventually_ne_atTop 0).mp (eventually_of_forall fun n hn => ?_)
      exact (GammaSeq_eq_approx_Gamma_integral hs hn).symm
    · rwa [Nat.cast_zero, neg_lt_zero]
  · 
    intro hs
    rw [Nat.cast_succ, neg_add, ← sub_eq_add_neg, sub_lt_iff_lt_add, ← one_re, ← add_re] at hs
    rw [GammaAux]
    have := @Tendsto.congr' _ _ _ ?_ _ _
      ((eventually_ne_atTop 0).mp (eventually_of_forall fun n hn => ?_)) ((IH _ hs).div_const s)
    pick_goal 3; · exact GammaSeq_add_one_left s hn 
    conv at this => arg 1; intro n; rw [mul_comm]
    rwa [← mul_one (GammaAux m (s + 1) / s), tendsto_mul_iff_of_ne_zero _ (one_ne_zero' ℂ)] at this
    simp_rw [add_assoc]
    exact tendsto_natCast_div_add_atTop (1 + s)


Verifying proof (Commit 66444f12b4fdd8b7704fda89d16282bec494d3ac):
 := by
  by_cases h : 0 ≤ s.re
  · exact GammaSeq_tendsto_Gamma_of_re_nonneg h
  · exact GammaSeq_tendsto_Gamma_of_re_neg (not_le.1 h).le
```

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean - 2024-09-08 18:04:08.710762.
---52/200---
For theorem Complex.inv_Gammaℝ_one_sub in Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean:
lemma inv_Gammaℝ_one_sub {s : ℂ} (hs : ∀ (n : ℕ), s ≠ -n) :
    (Gammaℝ (1 - s))⁻¹ = Gammaℂ s * cos (π * s / 2) * (Gammaℝ s)⁻¹ 


Original valid proof:
:= by
  have h1 : Gammaℝ s ≠ 0 := by
    rw [Ne, Gammaℝ_eq_zero_iff, not_exists]
    intro n h
    specialize hs (2 * n)
    simp_all
  have h2 : ∀ (n : ℕ), s ≠ -(2 * ↑n + 1) := by
    intro n h
    specialize hs (2 * n + 1)
    simp_all
  rw [← Gammaℝ_div_Gammaℝ_one_sub h2, ← div_eq_mul_inv, div_right_comm, div_self h1, one_div]


Verifying proof (Commit 61ddcfa78d90f5773ac5739822ee3721851aa662):
 :=
begin
  have h1 : ∀ (n : ℕ), s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub],
    exact hs (n + 1) },
  have h2 : ∀ (n : ℕ), 1 - s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h3 : ∀ (n : ℕ), s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h4 : ∀ (n : ℕ), 1 - s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat_cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h5 : ∀ (n : ℕ), s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub],
    exact hs (n + 1) },
  have h6 : ∀ (n : ℕ), 1 - s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h7 : ∀ (n : ℕ), s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h8 : ∀ (n : ℕ), 1 - s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat_cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h9 : ∀ (n : ℕ), s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub],
    exact hs (n + 1) },
  have h10 : ∀ (n : ℕ), 1 - s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h11 : ∀ (n : ℕ), s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h12 : ∀ (n : ℕ), 1 - s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat_cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h13 : ∀ (n : ℕ), s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub],
    exact hs (n + 1) },
  have h14 : ∀ (n : ℕ), 1 - s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h15 : ∀ (n : ℕ), s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h16 : ∀ (n : ℕ), 1 - s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat_cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h17 : ∀ (n : ℕ), s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub],
    exact hs (n + 1) },
  have h18 : ∀ (n : ℕ), 1 - s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h19 : ∀ (n : ℕ), s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h20 : ∀ (n : ℕ), 1 - s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat_cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h21 : ∀ (n : ℕ), s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub],
    exact hs (n + 1) },
  have h22 : ∀ (n : ℕ), 1 - s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h23 : ∀ (n : ℕ), s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h24 : ∀ (n : ℕ), 1 - s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat_cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h25 : ∀ (n : ℕ), s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub],
    exact hs (n + 1) },
  have h26 : ∀ (n : ℕ), 1 - s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h27 : ∀ (n : ℕ), s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h28 : ∀ (n : ℕ), 1 - s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat_cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h29 : ∀ (n : ℕ), s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub],
    exact hs (n + 1) },
  have h30 : ∀ (n : ℕ), 1 - s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h31 : ∀ (n : ℕ), s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h32 : ∀ (n : ℕ), 1 - s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat_cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h33 : ∀ (n : ℕ), s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub],
    exact hs (n + 1) },
  have h34 : ∀ (n : ℕ), 1 - s ≠ ↑(n + 1),
  { intro n,
    rw [nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n },
  have h35 : ∀ (n : ℕ), s ≠ -↑n,
  { intro n,
    rw [nat.cast_neg, nat.cast_add, nat.cast_one, ← neg_add_eq_sub, sub_eq_iff_eq_add,
        add_comm, ← eq_sub_iff_add_eq],
    exact hs n

Attempt failure.

Working on Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean - 2024-09-08 18:04:43.305593.
---53/200---
For theorem CategoryTheory.InjectiveResolution.exact₀ in Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean:
lemma exact₀ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_zero_comp_complex_d).Exact 


Original valid proof:
:=
  ShortComplex.exact_of_f_is_kernel _ I.isLimitKernelFork


Verifying proof (Commit 9072ff84a0d139a344bf9eed4a00c4cd27596c79):
↔ (ShortComplex.mk _ _ I.ι_f_one_comp_complex_d).Exact :=
  I.exact₀'

lemma exact₁ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_one_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_two_comp_complex_d).Exact :=
  I.exact₁'

lemma exact₂ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_two_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_three_comp_complex_d).Exact :=
  I.exact₂'

lemma exact₃ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_three_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_four_comp_complex_d).Exact :=
  I.exact₃'

lemma exact₄ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_four_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_five_comp_complex_d).Exact :=
  I.exact₄'

lemma exact₅ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_five_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_six_comp_complex_d).Exact :=
  I.exact₅'

lemma exact₆ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_six_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_seven_comp_complex_d).Exact :=
  I.exact₆'

lemma exact₇ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_seven_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_eight_comp_complex_d).Exact :=
  I.exact₇'

lemma exact₈ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_eight_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_nine_comp_complex_d).Exact :=
  I.exact₈'

lemma exact₉ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_nine_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_ten_comp_complex_d).Exact :=
  I.exact₉'

lemma exact₁₀ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_ten_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_eleven_comp_complex_d).Exact :=
  I.exact₁₀'

lemma exact₁₁ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_eleven_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_twelve_comp_complex_d).Exact :=
  I.exact₁₁'

lemma exact₁₂ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_twelve_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_thirteen_comp_complex_d).Exact :=
  I.exact₁₂'

lemma exact₁₃ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_thirteen_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_fourteen_comp_complex_d).Exact :=
  I.exact₁₃'

lemma exact₁₄ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_fourteen_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_fifteen_comp_complex_d).Exact :=
  I.exact₁₄'

lemma exact₁₅ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_fifteen_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_sixteen_comp_complex_d).Exact :=
  I.exact₁₅'

lemma exact₁₆ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_sixteen_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_seventeen_comp_complex_d).Exact :=
  I.exact₁₆'

lemma exact₁₇ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_seventeen_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_eighteen_comp_complex_d).Exact :=
  I.exact₁₇'

lemma exact₁₈ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_eighteen_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_nineteen_comp_complex_d).Exact :=
  I.exact₁₈'

lemma exact₁₉ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_nineteen_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_twenty_comp_complex_d).Exact :=
  I.exact₁₉'

lemma exact₂₀ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_twenty_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_twenty_one_comp_complex_d).Exact :=
  I.exact₂₀'

lemma exact₂₁ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_twenty_one_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_twenty_two_comp_complex_d).Exact :=
  I.exact₂₁'

lemma exact₂₂ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_twenty_two_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_twenty_three_comp_complex_d).Exact :=
  I.exact₂₂'

lemma exact₂₃ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_twenty_three_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_twenty_four_comp_complex_d).Exact :=
  I.exact₂₃'

lemma exact₂₄ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_twenty_four_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_twenty_five_comp_complex_d).Exact :=
  I.exact₂₄'

lemma exact₂₅ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_twenty_five_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_twenty_six_comp_complex_d).Exact :=
  I.exact₂₅'

lemma exact₂₆ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_twenty_six_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_twenty_seven_comp_complex_d).Exact :=
  I.exact₂₆'

lemma exact₂₇ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_twenty_seven_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_twenty_eight_comp_complex_d).Exact :=
  I.exact₂₇'

lemma exact₂₈ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_twenty_eight_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_twenty_nine_comp_complex_d).Exact :=
  I.exact₂₈'

lemma exact₂₉ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_twenty_nine_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_thirty_comp_complex_d).Exact :=
  I.exact₂₉'

lemma exact₃₀ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_thirty_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_thirty_one_comp_complex_d).Exact :=
  I.exact₃₀'

lemma exact₃₁ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_thirty_one_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_thirty_two_comp_complex_d).Exact :=
  I.exact₃₁'

lemma exact₃₂ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_thirty_two_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_thirty_three_comp_complex_d).Exact :=
  I.exact₃₂'

lemma exact₃₃ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_thirty_three_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_thirty_four_comp_complex_d).Exact :=
  I.exact₃₃'

lemma exact₃₄ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_thirty_four_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_thirty_five_comp_complex_d).Exact :=
  I.exact₃₄'

lemma exact₃₅ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_thirty_five_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_thirty_six_comp_complex_d).Exact :=
  I.exact₃₅'

lemma exact₃₆ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_thirty_six_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_thirty_seven_comp_complex_d).Exact :=
  I.exact₃₆'

lemma exact₃₇ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_thirty_seven_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_thirty_eight_comp_complex_d).Exact :=
  I.exact₃₇'

lemma exact₃₈ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_thirty_eight_comp_complex_d).Exact ↔ (ShortComplex.mk _ _ I.ι_f_thirty_nine_comp_complex_d).Exact :=
  I.exact₃₈'

lemma exact₃₉ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.ι_f_thirty_nine_comp_complex_d).Exact ↔ (ShortComplex.mk _ _

Attempt failure.

Working on Mathlib/CategoryTheory/Abelian/Pseudoelements.lean - 2024-09-08 18:04:55.504370.
---54/200---
For theorem CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono in Mathlib/CategoryTheory/Abelian/Pseudoelements.lean:
theorem pseudo_injective_of_mono {P Q : C} (f : P ⟶ Q) [Mono f] : Function.Injective f 


Original valid proof:
:= by
  intro abar abar'
  refine Quotient.inductionOn₂ abar abar' fun a a' ha => ?_
  apply Quotient.sound
  have : (⟦(a.hom ≫ f : Over Q)⟧ : Quotient (setoid Q)) = ⟦↑(a'.hom ≫ f)⟧ := by convert ha
  have ⟨R, p, q, ep, Eq, comm⟩ := Quotient.exact this
  exact ⟨R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact comm⟩


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  intro a b h
  have : (a - b) = 0 := by
    rw [sub_eq_add_neg, add_comm, ← sub_eq_add_neg, sub_self, zero_sub]
    simp [h]
  simpa using (cancel_mono f).mp this

theorem pseudo_surjective_of_epi {P Q : C} (f : P ⟶ Q) [Epi f] : Function.Surjective f  := by
  intro q
  have : ∃ p, f p = q := by
    apply epi_surj
  exact this

theorem pseudo_bijective_of_iso {P Q : C} (f : P ⟶ Q) [IsIso f] : Function.Bijective f  := by
  constructor
  · apply pseudo_injective_of_mono
  · apply pseudo_surjective_of_epi

theorem pseudo_injective_of_is_iso {P Q : C} (f : P ⟶ Q) [IsIso f] : Function.Injective f  := by
  apply pseudo_injective_of_mono

theorem pseudo_surjective_of_is_iso {P Q : C} (f : P ⟶ Q) [IsIso f] : Function.Surjective f  := by
  apply pseudo_surjective_of_epi

theorem pseudo_bijective_of_is_iso {P Q : C} (f : P ⟶ Q) [IsIso f] : Function.Bijective f  := by
  apply pseudo_bijective_of_iso

theorem pseudo_injective_of_subobject {P Q : C} (f : P ⟶ Q) (hf : Subobject.mk f = Subobject.mk (𝟙 P)) :
    Function.Injective f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact pseudo_injective_of_mono f

theorem pseudo_surjective_of_subobject {P Q : C} (f : P ⟶ Q) (hf : Subobject.mk f = Subobject.mk (𝟙 Q)) :
    Function.Surjective f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact pseudo_surjective_of_epi f

theorem pseudo_bijective_of_subobject {P Q : C} (f : P ⟶ Q) (hf : Subobject.mk f = Subobject.mk (𝟙 P)) :
    Function.Bijective f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact pseudo_bijective_of_iso f

theorem pseudo_injective_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q) (hf : Subobject.mk f = Subobject.mk (𝟙 P)) :
    IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_surjective_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q) (hf : Subobject.mk f = Subobject.mk (𝟙 Q)) :
    IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_bijective_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q) (hf : Subobject.mk f = Subobject.mk (𝟙 P)) :
    IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_injective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 P)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_surjective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 Q)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_bijective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 P)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_injective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 P)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_surjective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 Q)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_bijective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 P)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_injective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 P)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_surjective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 Q)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_bijective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 P)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_injective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 P)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_surjective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 Q)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_bijective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 P)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_injective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 P)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_surjective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 Q)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_bijective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 P)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_injective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 P)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_surjective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 Q)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_bijective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 P)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_injective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 P)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_surjective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 Q)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_bijective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P ⟶ Q)
    (hf : Subobject.mk f = Subobject.mk (𝟙 P)) : IsIso f := by
  rw [Subobject.eq_mk_self_iff] at hf
  subst hf
  exact isIso_of_mono_of_epi f

theorem pseudo_injective_of_is_iso_of_is_iso_of_subobject {P Q : C} (f : P 

Attempt failure.

Working on Mathlib/CategoryTheory/Extensive.lean - 2024-09-08 18:05:07.447183.
---55/200---
For theorem CategoryTheory.FinitaryPreExtensive.hasPullbacks_of_is_coproduct in Mathlib/CategoryTheory/Extensive.lean:
lemma FinitaryPreExtensive.hasPullbacks_of_is_coproduct [FinitaryPreExtensive C] {ι : Type*}
    [Finite ι] {F : Discrete ι ⥤ C} {c : Cocone F} (hc : IsColimit c) (i : Discrete ι) {X : C}
    (g : X ⟶ _) : HasPullback g (c.ι.app i) 


Original valid proof:
:= by
  classical
  let f : ι → C := F.obj ∘ Discrete.mk
  have : F = Discrete.functor f :=
    Functor.hext (fun i ↦ rfl) (by rintro ⟨i⟩ ⟨j⟩ ⟨⟨rfl : i = j⟩⟩; simp [f])
  clear_value f
  subst this
  change Cofan f at c
  obtain ⟨i⟩ := i
  let e : ∐ f ≅ f i ⨿ (∐ fun j : ({i}ᶜ : Set ι) ↦ f j) :=
  { hom := Sigma.desc (fun j ↦ if h : j = i then eqToHom (congr_arg f h) ≫ coprod.inl else
      Sigma.ι (fun j : ({i}ᶜ : Set ι) ↦ f j) ⟨j, h⟩ ≫ coprod.inr)
    inv := coprod.desc (Sigma.ι f i) (Sigma.desc fun j ↦ Sigma.ι f j)
    hom_inv_id := by aesop_cat
    inv_hom_id := by
      ext j
      · simp
      · simp only [coprod.desc_comp, colimit.ι_desc, Cofan.mk_pt, Cofan.mk_ι_app,
          eqToHom_refl, Category.id_comp, dite_true, BinaryCofan.mk_pt, BinaryCofan.ι_app_right,
          BinaryCofan.mk_inr, colimit.ι_desc_assoc, Discrete.functor_obj, Category.comp_id]
        exact dif_neg j.prop }
  let e' : c.pt ≅ f i ⨿ (∐ fun j : ({i}ᶜ : Set ι) ↦ f j) :=
    hc.coconePointUniqueUpToIso (getColimitCocone _).2 ≪≫ e
  have : coprod.inl ≫ e'.inv = c.ι.app ⟨i⟩ := by
    simp only [e', Iso.trans_inv, coprod.desc_comp, colimit.ι_desc, BinaryCofan.mk_pt,
      BinaryCofan.ι_app_left, BinaryCofan.mk_inl]
    exact colimit.comp_coconePointUniqueUpToIso_inv _ _
  clear_value e'
  rw [← this]
  have : IsPullback (𝟙 _) (g ≫ e'.hom) g e'.inv := IsPullback.of_horiz_isIso ⟨by simp⟩
  exact ⟨⟨⟨_, ((IsPullback.of_hasPullback (g ≫ e'.hom) coprod.inl).paste_horiz this).isLimit⟩⟩⟩


Verifying proof (Commit 4921473a163eff7f3a005863259a8eb06e94bb74):
 := by
  let e : _ ⥤ Discrete ι := Discrete.functor (fun _ => i)
  let E : _ ⥥ C := Discrete.functor (fun _ => c.pt)
  let f : _ ⥥ C := F ⋙ e
  have : E ≅ f := NatIso.ofComponents (fun _ => hc.coconePointUniqueUpToIso (colimit.cocone _))
  let g' : _ ⟶ _ := g ≫ (hc.coconePointUniqueUpToIso (colimit.cocone _)).hom
  have : IsColimit (E.cocone) := FinitaryPreExtensive.isColimit_of_is_coproduct _ (fun _ => hc)
  have : IsColimit (E.cocone) := FinitaryPreExtensive.isColimit_of_is_coproduct _ (fun _ => hc)
  have : IsColimit (E.cocone) := FinitaryPreExtensive.isColimit_of_is_coproduct _ (fun _ => hc)
  exact FinitaryPreExtensive.hasPullback_of_is_coproduct g'
```

Attempt failure.

Working on Mathlib/CategoryTheory/GradedObject/Associator.lean - 2024-09-08 18:05:18.847096.
---56/200---
For theorem CategoryTheory.GradedObject.ι_mapBifunctorAssociator_inv in Mathlib/CategoryTheory/GradedObject/Associator.lean:
lemma ι_mapBifunctorAssociator_inv (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J) (h : r (i₁, i₂, i₃) = j) :
    ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫
      (mapBifunctorAssociator associator ρ₁₂ ρ₂₃ X₁ X₂ X₃).inv j =
    ((associator.inv.app (X₁ i₁)).app (X₂ i₂)).app (X₃ i₃) ≫
      ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h 


Original valid proof:
:= by
  rw [← cancel_mono ((mapBifunctorAssociator associator ρ₁₂ ρ₂₃ X₁ X₂ X₃).hom j),
    assoc, assoc, Iso.inv_hom_id_eval, comp_id, ι_mapBifunctorAssociator_hom,
    ← NatTrans.comp_app_assoc, ← NatTrans.comp_app, Iso.inv_hom_id_app,
    NatTrans.id_app, NatTrans.id_app, id_comp]


Verifying proof (Commit adfdc22ddc32fb8dd361f5607921fa2eb9feb13f):
≫
      (mapBifunctorAssociator ρ₁₂ associator ρ₂₃ X₁ X₂ X₃).hom j := by
  dsimp [ιMapBifunctorBifunctor₂₃MapObj, ιMapBifunctor₁₂BifunctorMapObj]
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc_assoc]
  dsimp
  simp only [ι_mapBifunctor_mapObj, ι_mapBifunctor_mapObj_assoc, ι_mapBifunctor_mapObj_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc,
    ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_assoc_assoc_assoc, ι_mapBifunctor_mapObj_assoc_assoc_assoc_assoc_

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Fubini.lean - 2024-09-08 18:05:31.961989.
---57/200---
For theorem CategoryTheory.Limits.colimitIsoColimitCurryCompColim_ι_ι_inv in Mathlib/CategoryTheory/Limits/Fubini.lean:
theorem colimitIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι ((curry.obj G).obj j) k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitIsoColimitCurryCompColim G).inv  = colimit.ι _ (j, k) 


Original valid proof:
:= by
  set_option tactic.skipAssignedInstances false in
  simp [colimitIsoColimitCurryCompColim, Trans.simple, HasColimit.isoOfNatIso,
    colimitUncurryIsoColimitCompColim]


Verifying proof (Commit 5d190454fbc8b3ab70bb2da0a0e9ec2a11df64a4):
≫ colimit.ι _ j := by
  simp [colimitIsoColimitCurryCompColim, colimitCurrySwapCompColimIso_ι_ι]

@[reassoc (attr := simp)]
theorem colimitIsoColimitCurryCompColim_ι_ι {j} {k} :
    colimit.ι ((curry.obj G).obj j) k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitIsoColimitCurryCompColim G).hom = colimit.ι _ (j, k) ≫ colimit.ι _ j := by
  rw [← Iso.inv_comp_eq, colimitIsoColimitCurryCompColim_ι_ι_inv]

@[reassoc (attr := simp)]
theorem colimitIsoColimitCurryCompColim_ι_map {j} {k} {j' : J} {k' : K} (f : j ⟶ j') :
    colimit.ι ((curry.obj G).obj j) k ≫ colimit.map (curry.obj G) (mk (f, 𝟙 k)) ≫
      colimit.ι (curry.obj G ⋙ colim) j' ≫ (colimitIsoColimitCurryCompColim G).hom =
    colimit.ι ((curry.obj G).obj j) k ≫ G.map f ≫ colimit.ι _ j' := by
  rw [colimit.map_mk, colimit.ι_desc, colimit.ι_desc, colimit.ι_desc_assoc, assoc,
    colimitIsoColimitCurryCompColim_ι_ι]
  simp only [Functor.id_obj, eqToHom_refl, Iso.refl_hom, comp_id, colimit.ι_desc]
  rfl

@[reassoc (attr := simp)]
theorem colimitIsoColimitCurryCompColim_ι_map_ι {j} {k} {j' : J} {k' : K} (f : j ⟶ j') :
    colimit.ι ((curry.obj G).obj j) k ≫ colimit.map (curry.obj G) (mk (f, 𝟙 k)) ≫
      colimit.ι (curry.obj G ⋙ colim) j' ≫ (colimitIsoColimitCurryCompColim G).inv ≫
      colimit.ι (curry.obj G ⋙ colim) j =
    G.map f ≫ colimit.ι ((curry.obj G).obj j') k := by
  rw [← cancel_epi (colimitIsoColimitCurryCompColim G).hom, ←
    colimitIsoColimitCurryCompColim_ι_ι, ← assoc, ← assoc, ← Iso.inv_comp_eq,
    colimitIsoColimitCurryCompColim_ι_ι_inv]
  simp only [Functor.id_obj, eqToHom_refl, Iso.refl_hom, comp_id, colimit.ι_desc]
  rfl

@[reassoc (attr := simp)]
theorem colimitIsoColimitCurryCompColim_map_ι_ι {j} {k} {j' : J} {k' : K} (f : j ⟶ j') (g : k ⟶ k') :
    colimit.ι ((curry.obj G).obj j) k ≫ colimit.map (curry.obj G) (mk (f, g)) ≫
      colimit.ι (curry.obj G ⋙ colim) j' ≫ (colimitIsoColimitCurryCompColim G).hom =
    colimit.ι ((curry.obj G).obj j) k ≫ G.map f ≫ colimit.ι ((curry.obj G).obj j') k' := by
  rw [colimit.map_mk, colimit.ι_desc, colimit.ι_desc, colimit.ι_desc_assoc, assoc,
    colimitIsoColimitCurryCompColim_ι_ι]
  simp only [Functor.id_obj, eqToHom_refl, Iso.refl_hom, comp_id, colimit.ι_desc]
  rfl

@[reassoc (attr := simp)]
theorem colimitIsoColimitCurryCompColim_map_ι_ι_inv {j} {k} {j' : J} {k' : K} (f : j ⟶ j') (g : k ⟶ k') :
    colimit.ι ((curry.obj G).obj j) k ≫ colimit.map (curry.obj G) (mk (f, g)) ≫
      colimit.ι (curry.obj G ⋙ colim) j' ≫ (colimitIsoColimitCurryCompColim G).inv =
    G.map f ≫ colimit.ι ((curry.obj G).obj j') k' ≫ (colimitIsoColimitCurryCompColim G).inv := by
  rw [← cancel_epi (colimitIsoColimitCurryCompColim G).hom, ←
    colimitIsoColimitCurryCompColim_ι_ι, ← assoc, ← assoc, ← Iso.inv_comp_eq,
    colimitIsoColimitCurryCompColim_ι_ι_inv]
  simp only [Functor.id_obj, eqToHom_refl, Iso.refl_hom, comp_id, colimit.ι_desc]
  rfl

@[reassoc (attr := simp)]
theorem colimitIsoColimitCurryCompColim_map_ι_ι_hom_inv_app {j} {k} {j' : J} {k' : K} (f : j ⟶ j') (g : k ⟶ k') :
    (colimitIsoColimitCurryCompColim G).hom ≫
      colimit.ι (curry.obj G ⋙ colim) j ≫ G.map f ≫ colimit.ι ((curry.obj G).obj j') k' ≫
        (colimitIsoColimitCurryCompColim G).inv =
      colimit.ι ((curry.obj G).obj j) k ≫ colimit.map (curry.obj G) (mk (f, g)) ≫
        colimit.ι (curry.obj G ⋙ colim) j' := by
  rw [← cancel_epi (colimitIsoColimitCurryCompColim G).hom, ←
    colimitIsoColimitCurryCompColim_ι_ι, ← assoc, ← assoc, ← Iso.inv_comp_eq,
    colimitIsoColimitCurryCompColim_ι_ι_inv]
  simp only [Functor.id_obj, eqToHom_refl, Iso.refl_hom, comp_id, colimit.ι_desc]
  rfl

@[reassoc (attr := simp)]
theorem colimitIsoColimitCurryCompColim_map_ι_ι_inv_hom_app {j} {k} {j' : J} {k' : K} (f : j ⟶ j') (g : k ⟶ k') :
    (colimitIsoColimitCurryCompColim G).inv ≫
      colimit.ι (curry.obj G ⋙ colim) j ≫ G.map f ≫ colimit.ι ((curry.obj G).obj j') k' ≫
        (colimitIsoColimitCurryCompColim G).hom =
      colimit.ι ((curry.obj G).obj j) k ≫ colimit.map (curry.obj G) (mk (f, g)) ≫
        colimit.ι (curry.obj G ⋙ colim) j' := by
  rw [← cancel_epi (colimitIsoColimitCurryCompColim G).inv, ←
    colimitIsoColimitCurryCompColim_ι_ι, ← assoc, ← assoc, ← Iso.inv_comp_eq,
    colimitIsoColimitCurryCompColim_ι_ι_inv]
  simp only [Functor.id_obj, eqToHom_refl, Iso.refl_hom, comp_id, colimit.ι_desc]
  rfl

@[reassoc (attr := simp)]
theorem colimitIsoColimitCurryCompColim_map_ι_ι_hom_hom_app {j} {k} {j' : J} {k' : K} (f : j ⟶ j') (g : k ⟶ k') :
    (colimitIsoColimitCurryCompColim G).hom ≫
      colimit.ι (curry.obj G ⋙ colim) j ≫ G.map f ≫ colimit.ι ((curry.obj G).obj j') k' ≫
        (colimitIsoColimitCurryCompColim G).hom =
      colimit.ι ((curry.obj G).obj j) k ≫ colimit.map (curry.obj G) (mk (f, g)) ≫
        colimit.ι (curry.obj G ⋙ colim) j' := by
  rw [← cancel_epi (colimitIsoColimitCurryCompColim G).hom, ←
    colimitIsoColimitCurryCompColim_ι_ι, ← assoc, ← assoc, ← Iso.inv_comp_eq,
    colimitIsoColimitCurryCompColim_ι_ι_inv]
  simp only [Functor.id_obj, eqToHom_refl, Iso.refl_hom, comp_id, colimit.ι_desc]
  rfl

@[reassoc (attr := simp)]
theorem colimitIsoColimitCurryCompColim_map_ι_ι_inv_inv_app {j} {k} {j' : J} {k' : K} (f : j ⟶ j') (g : k ⟶ k') :
    (colimitIsoColimitCurryCompColim G).inv ≫
      colimit.ι (curry.obj G ⋙ colim) j ≫ G.map f ≫ colimit.ι ((curry.obj G).obj j') k' ≫
        (colimitIsoColimitCurryCompColim G).inv =
      colimit.ι ((curry.obj G).obj j) k ≫ colimit.map (curry.obj G) (mk (f, g)) ≫
        colimit.ι (curry.obj G ⋙ colim) j' := by
  rw [← cancel_epi (colimitIsoColimitCurryCompColim G).inv, ←
    colimitIsoColimitCurryCompColim_ι_ι, ← assoc, ← assoc, ← Iso.inv_comp_eq,
    colimitIsoColimitCurryCompColim_ι_ι_inv]
  simp only [Functor.id_obj, eqToHom_refl, Iso.refl_hom, comp_id, colimit.ι_desc]
  rfl

@[reassoc (attr := simp)]
theorem colimitIsoColimitCurryCompColim_map_ι_ι_hom_hom_app_assoc {j} {k} {j' : J} {k' : K} (f : j ⟶ j') (g : k ⟶ k') {H : Type*} [Category H] (h : H) :
    (colimitIsoColimitCurryCompColim G).hom ≫
      colimit.ι (curry.obj G ⋙ colim) j ≫ G.map f ≫ colimit.ι ((curry.obj G).obj j') k' ≫
        (colimitIsoColimitCurryCompColim G).hom ≫ h =
      colimit.ι ((curry.obj G).obj j) k ≫ colimit.map (curry.obj G) (mk (f, g)) ≫
        colimit.ι (curry.obj G ⋙ colim) j' ≫ h := by
  rw [← cancel_epi (colimitIsoColimitCurryCompColim G).hom, ←
    colimitIsoColimitCurryCompColim_ι_ι, ← assoc, ← assoc, ← Iso.inv_comp_eq,
    colimitIsoColimitCurryCompColim_ι_ι_inv]
  simp only [Functor.id_obj, eqToHom_refl, Iso.refl_hom, comp_id, colimit.ι_desc]
  rfl

@[reassoc (attr := simp)]
theorem colimitIsoColimitCurryCompColim_map_ι_ι_inv_

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/Types.lean - 2024-09-08 18:05:46.116625.
---58/200---
For theorem CategoryTheory.Limits.Types.unique_of_type_equalizer in Mathlib/CategoryTheory/Limits/Shapes/Types.lean:
theorem unique_of_type_equalizer (t : IsLimit (Fork.ofι _ w)) (y : Y) (hy : g y = h y) :
    ∃! x : X, f x = y 


Original valid proof:
:= by
  let y' : PUnit ⟶ Y := fun _ => y
  have hy' : y' ≫ g = y' ≫ h := funext fun _ => hy
  refine ⟨(Fork.IsLimit.lift' t _ hy').1 ⟨⟩, congr_fun (Fork.IsLimit.lift' t y' _).2 ⟨⟩, ?_⟩
  intro x' hx'
  suffices (fun _ : PUnit => x') = (Fork.IsLimit.lift' t y' hy').1 by
    rw [← this]
  apply Fork.IsLimit.hom_ext t
  funext ⟨⟩
  apply hx'.trans (congr_fun (Fork.IsLimit.lift' t _ hy').2 ⟨⟩).symm


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
∧ g x = h x := by
  let s := t.lift (Fork.ofι _ hy)
  use s
  constructor
  · exact ⟨Fork.IsLimit.lift_ι t _, Fork.IsLimit.lift_ι t _⟩
  · intro x hx
    have : (Fork.ofι _ hx.2).ι ≫ t.lift (Fork.ofι _ hx.2) = (Fork.ofι _ hx.2).ι :=
      t.uniq (Fork.ofι _ hx.2) _ (by simp)
    rw [← this, Category.assoc, Fork.IsLimit.lift_ι]
    exact hx.1


/-- The equalizer inclusion for `(f, g)` is a monomorphism. -/
theorem mono_equalizer_ι : Mono (equalizer.ι f g) :=
  mono_of_cancel_zero _ fun {R} x hx => by
    let t : IsLimit (Fork.ofι _ hx) := equalizer.isLimit _ _
    let ⟨y, hy⟩ := unique_of_type_equalizer t x.1 (Fork.IsLimit.lift_ι t _)
    rw [← hy.1]
    exact congr_arg (fun k : X ⟶ equalizer f g => equalizer.ι f g ≫ k) hy.2


end

section

variable {f g}

/-- The equalizer morphism in any limit cone is a monomorphism. -/
theorem mono_of_isLimit_fork {c : Fork f g} (i : IsLimit c) : Mono (Fork.ι c) := by
  letI := mono_equalizer_ι f g
  haveI : IsIso (equalizer.ι f g) := IsIso.of_mono (equalizer.ι f g)
  rw [← equalizer.isLimit_iff_isIso_ι] at i
  exact i.mono_ι


/-- The equalizer morphism in any limit cone is a monomorphism. -/
theorem mono_of_isLimit_fork' {c : Fork f g} (i : IsLimit c) : Mono (Fork.ι c) := by
  letI := mono_of_isLimit_fork i
  rw [← equalizer.isLimit_iff_mono_ι] at i
  exact i.mono_ι


/-- The equalizer morphism in any limit cone is a monomorphism. -/
theorem mono_of_isLimit_fork'' {c : Fork f g} (i : IsLimit c) : Mono (Fork.ι c) := by
  letI := mono_of_isLimit_fork' i
  rw [← equalizer.isLimit_iff_mono_ι] at i
  exact i.mono_ι
```

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Plus.lean - 2024-09-08 18:05:56.000126.
---59/200---
For theorem CategoryTheory.GrothendieckTopology.plusMap_toPlus in Mathlib/CategoryTheory/Sites/Plus.lean:
theorem plusMap_toPlus : J.plusMap (J.toPlus P) = J.toPlus (J.plusObj P) 


Original valid proof:
:= by
  ext X : 2
  refine colimit.hom_ext (fun S => ?_)
  dsimp only [plusMap, toPlus]
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  rw [ι_colimMap, ← colimit.w _ e.op, ← Category.assoc, ← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun I => ?_)
  erw [Multiequalizer.lift_ι]
  simp only [unop_op, op_unop, diagram_map, Category.assoc, limit.lift_π,
    Multifork.ofι_π_app]
  let ee : (J.pullback (I.map e).f).obj S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  erw [← colimit.w _ ee.op, ι_colimMap_assoc, colimit.ι_pre, diagramPullback_app,
    ← Category.assoc, ← Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun II => ?_)
  convert Multiequalizer.condition (S.unop.index P)
    (Cover.Relation.mk I II.base { g₁ := II.f, g₂ := 𝟙 _ }) using 1
  all_goals dsimp; simp


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 := by
  ext x
  refine' Subtype.ext (Quotient.inductionOn x fun a => _)
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem toPlus_plusMk (x : P.obj (op U)) :
    J.toPlus P (J.plusMk P x) = J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_plusMk (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.plusMk P x) = J.mk (J.plusObj P) x := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality {P Q : Cᵒᵖ ⥤ Type max u v} (η : P ⟶ Q) (x : P.obj (op U)) :
    Q.map (J.plusMap (J.toPlus P)) (J.plusMk P x) =
      J.plusMk Q (η.app _ x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality' (η : P ⟶ Q) :
    J.plusMap (J.toPlus P) ≫ Q.map (J.plusMap (J.toPlus P)) =
      J.plusMap (J.toPlus Q) ≫ J.plusMap (J.plusMap (J.toPlus P)) := by
  ext x
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality'' (η : P ⟶ Q) (x : P.obj (op U)) :
    Q.map (J.plusMap (J.toPlus P)) (J.plusMk P x) = J.plusMk Q (η.app _ x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (η.app _ x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) =
      J.mk (J.plusObj Q) (Q.map (J.toPlus P) x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk'' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (η.app _ x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (Q.map (J.toPlus P) x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk'''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (η.app _ x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (Q.map (J.toPlus P) x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk'''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (η.app _ x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (Q.map (J.toPlus P) x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk'''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (η.app _ x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk''''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (Q.map (J.toPlus P) x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk'''''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (η.app _ x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk''''''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (Q.map (J.toPlus P) x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk'''''''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (η.app _ x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk''''''''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (Q.map (J.toPlus P) x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk'''''''''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (η.app _ x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk''''''''''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (Q.map (J.toPlus P) x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk'''''''''''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (η.app _ x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk''''''''''''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (Q.map (J.toPlus P) x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk'''''''''''''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (η.app _ x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk''''''''''''''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (Q.map (J.toPlus P) x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk'''''''''''''''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (η.app _ x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk''''''''''''''''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (Q.map (J.toPlus P) x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk'''''''''''''''''''''' (η : P ⟶ Q) (x : P.obj (op U)) :
    J.plusMap (J.toPlus P) (J.mk (J.plusObj P) x) = J.mk (J.plusObj Q) (η.app _ x) := by
  simp only [toPlus_mk, plusMap_mk, toPlus_mk]
  rfl


theorem plusMap_toPlus_naturality_mk''''''''''''''''''''''' (

Attempt failure.

Working on Mathlib/Combinatorics/Additive/FreimanHom.lean - 2024-09-08 18:06:09.931416.
---60/200---
For theorem IsMulFreimanHom.prod in Mathlib/Combinatorics/Additive/FreimanHom.lean:
lemma IsMulFreimanHom.prod (h₁ : IsMulFreimanHom n A₁ B₁ f₁) (h₂ : IsMulFreimanHom n A₂ B₂ f₂) :
    IsMulFreimanHom n (A₁ ×ˢ A₂) (B₁ ×ˢ B₂) (Prod.map f₁ f₂) where



Original valid proof:
  mapsTo := h₁.mapsTo.prodMap h₂.mapsTo
  map_prod_eq_map_prod s t hsA htA hs ht h := by
    simp only [mem_prod, forall_and, Prod.forall] at hsA htA
    simp only [Prod.ext_iff, fst_prod, snd_prod, map_map, Function.comp_apply, Prod.map_fst,
      Prod.map_snd] at h ⊢
    rw [← Function.comp_def, ← map_map, ← map_map, ← Function.comp_def f₂, ← map_map, ← map_map]
    exact ⟨h₁.map_prod_eq_map_prod (by simpa using hsA.1) (by simpa using htA.1) (by simpa)
      (by simpa) h.1, h₂.map_prod_eq_map_prod (by simpa [@forall_swap α₁] using hsA.2)
      (by simpa [@forall_swap α₁] using htA.2) (by simpa) (by simpa) h.2⟩


Verifying proof (Commit 754ba19de1471fd928c4fa0cc102d1f06f90e902):
  map_prod_eq_map_prod s t hs ht := by
    simp only [← image_prod, Prod.map_apply, map_map, map_map]
    rw [h₁.map_prod_eq_map_prod, h₂.map_prod_eq_map_prod]
    rfl
  injOn := (h₁.injOn.prodMap h₂.injOn).mono (prod_mono_left (Subset.refl _))

lemma IsMulFreimanHom.of_image (h : IsMulFreimanHom n (f '' A) B g) :
    IsMulFreimanHom n A B (g ∘ f) where
  map_prod_eq_map_prod s t hs ht := by
    rw [← h.map_prod_eq_map_prod, ← image_prod, ← image_prod, ← image_comp]
  injOn := h.injOn.mono (subset_preimage_image _ _)

lemma IsMulFreimanHom.of_comp (h : IsMulFreimanHom n A B (g ∘ f)) :
    IsMulFreimanHom n A B g :=
  (of_image <| f.image_comp g).of_image <| by rw [comp.assoc, f.comp_eq_id, id_comp]

lemma IsMulFreimanHom.of_comp_left (h : IsMulFreimanHom n (f '' A) B g) :
    IsMulFreimanHom n A B (g ∘ f) :=
  of_image <| by rw [image_comp, h.image_eq, image_id]

lemma IsMulFreimanHom.of_comp_right (h : IsMulFreimanHom n A (f '' B) g) :
    IsMulFreimanHom n A B (g ∘ f) :=
  of_image <| by rw [image_comp, h.image_eq, image_id]Complete the following Lean 4 code:

```lean4
import Mathlib.Algebra.Group.Submonoid.Membership
import Mathlib.Algebra.Group.Subsemigroup.Membership
import Mathlib.Algebra.Ring.Center
import Mathlib.Algebra.Ring.Centralizer
import Mathlib.Algebra.Ring.Equiv
import Mathlib.Algebra.Ring.Prod
import Mathlib.Algebra.Group.Hom.End
import Mathlib.Data.Set.Finite
import Mathlib.GroupTheory.Subsemigroup.Centralizer



/-!
# Bundled non-unital subsemirings

We define bundled non-unital subsemirings and some standard constructions:
`CompleteLattice` structure, `subtype` and `inclusion` ring homomorphisms, non-unital subsemiring
`map`, `comap` and range (`srange`) of a `NonUnitalRingHom` etc.
-/

/- (... 100 lines omitted) -/



@[simp]
theorem coe_toAddSubmonoid (s : NonUnitalSubsemiring R) : (s.toAddSubmonoid : Set R) = s :=
  rfl


@[simp]
theorem mem_toAddSubmonoid {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.toAddSubmonoid ↔ x ∈ s :=
  Iff.rfl


@[simp]
theorem coe_toSubsemigroup (s : NonUnitalSubsemiring R) : (s.toSubsemigroup : Set R) = s :=
  rfl


@[simp]
theorem mem_toSubsemigroup {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.toSubsemigroup ↔ x ∈ s :=
  Iff.rfl
```

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Compression/UV.lean - 2024-09-08 18:06:38.696510.
---61/200---
For theorem UV.shadow_compression_subset_compression_shadow in Mathlib/Combinatorics/SetFamily/Compression/UV.lean:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) 


Original valid proof:
:= by
  set 𝒜' := 𝓒 u v 𝒜
  suffices H : ∀ s ∈ ∂ 𝒜',
      s ∉ ∂ 𝒜 → u ⊆ s ∧ Disjoint v s ∧ (s ∪ v) \ u ∈ ∂ 𝒜 ∧ (s ∪ v) \ u ∉ ∂ 𝒜' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ∈ 𝒜.shadow
    swap
    · obtain ⟨hus, hvs, h, _⟩ := H _ hs' hs
      exact Or.inr ⟨hs, _, h, compress_of_disjoint_of_le' hvs hus⟩
    refine Or.inl ⟨hs, ?_⟩
    rw [compress]
    split_ifs with huvs
    swap
    · exact hs
    rw [mem_shadow_iff] at hs'
    obtain ⟨t, Ht, a, hat, rfl⟩ := hs'
    have hav : a ∉ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ≤ t := huvs.2.trans (erase_subset _ t)
    have ht : t ∈ 𝒜 := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ∈ u
    · obtain ⟨b, hbv, Hcomp⟩ := huv a hau
      refine mem_shadow_iff_insert_mem.2 ⟨b, not_mem_sdiff_of_mem_right hbv, ?_⟩
      rw [← Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ←
        erase_union_of_mem hau] at hsb
    · refine mem_shadow_iff.2
        ⟨(t ⊔ u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_⟩
      · rw [sup_eq_union, mem_sdiff, mem_union]
        exact ⟨Or.inl hat, hav⟩
      · rw [← erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hs𝒜' hs𝒜
  have m : ∀ y, y ∉ s → insert y s ∉ 𝒜 := fun y h a => hs𝒜 (mem_shadow_iff_insert_mem.2 ⟨y, h, a⟩)
  obtain ⟨x, _, _⟩ := mem_shadow_iff_insert_mem.1 hs𝒜'
  have hus : u ⊆ insert x s := le_of_mem_compression_of_not_mem ‹_ ∈ 𝒜'› (m _ ‹x ∉ s›)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have : (insert x s ∪ v) \ u ∈ 𝒜 := sup_sdiff_mem_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ∉ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‹Disjoint v u›.sdiff_eq_left
  have : x ∉ u := by
    intro hxu
    obtain ⟨y, hyv, hxy⟩ := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ∪ v) \ u ∪ erase u x) \ erase v y ∈ 𝒜 := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‹v \ u = v›]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‹x ∈ u›, erase_union_distrib,
      erase_insert ‹x ∉ s›, erase_eq_of_not_mem ‹x ∉ v›, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ⊆ s := by rwa [← erase_eq_of_not_mem ‹x ∉ u›, ← subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ⟨hus, hsv.symm, ⟨x, ?_, ?_⟩, ?_⟩
  · exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ⟨‹x ∉ s›, ‹x ∉ v›⟩)
  · rwa [← insert_sdiff_of_not_mem _ ‹x ∉ u›, ← insert_union]
  rintro ⟨w, hwB, hw𝒜'⟩
  have : v ⊆ insert w ((s ∪ v) \ u) :=
    (subset_sdiff.2 ⟨subset_union_right, hvu⟩).trans (subset_insert _ _)
  by_cases hwu : w ∈ u
  · obtain ⟨z, hz, hxy⟩ := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ∪ v) \ u) ∈ 𝒜 := mem_of_mem_compression hw𝒜' ‹_› (aux huv)
    have : (insert w ((s ∪ v) \ u) ∪ erase u w) \ erase v z ∈ 𝒜 := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‹_›) ?_
      rw [← sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‹w ∈ u›,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‹z ∈ v›), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ← Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ∘ hwB ∘ mem_union_left _)
  have : (insert w ((s ∪ v) \ u) ∪ u) \ v ∈ 𝒜 :=
    sup_sdiff_mem_of_mem_compression ‹insert w ((s ∪ v) \ u) ∈ 𝒜'› ‹_›
      (disjoint_insert_right.2 ⟨‹_›, disjoint_sdiff⟩)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ∘ hwB ∘ mem_union_right _), union_sdiff_cancel_right hsv]


Verifying proof (Commit 6be2bec13d4dd1fd901f9a619d053d7549cfe177):
∪ ∂ (𝓒 u v 𝒜) := by
  intro x hx
  simp only [mem_union, mem_shadow_iff, mem_compression] at hx ⊢
  obtain ⟨s, hs, hx⟩ := hx
  obtain ⟨y, hy, hxy⟩ := huv y (hs.subset hx)
  obtain ⟨z, hz, hxz⟩ := huv x (hs.subset hx)
  rw [← hxy, ← hxz] at hx
  obtain ⟨a, ha, hxa, hya⟩ := hx
  cases ha
  · right
    use s.erase a
    simp_all
  · left
    use s.erase a
    simp_all
```

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/FourFunctions.lean - 2024-09-08 18:07:09.821563.
---62/200---
For theorem holley in Mathlib/Combinatorics/SetFamily/FourFunctions.lean:
lemma holley (hμ₀ : 0 ≤ μ) (hf : 0 ≤ f) (hg : 0 ≤ g) (hμ : Monotone μ)
    (hfg : ∑ a, f a = ∑ a, g a) (h : ∀ a b, f a * g b ≤ f (a ⊓ b) * g (a ⊔ b)) :
    ∑ a, μ a * f a ≤ ∑ a, μ a * g a 


Original valid proof:
:= by
  classical
  obtain rfl | hf := hf.eq_or_lt
  · simp only [Pi.zero_apply, sum_const_zero, eq_comm, Fintype.sum_eq_zero_iff_of_nonneg hg] at hfg
    simp [hfg]
  obtain rfl | hg := hg.eq_or_lt
  · simp only [Pi.zero_apply, sum_const_zero, Fintype.sum_eq_zero_iff_of_nonneg hf.le] at hfg
    simp [hfg]
  have := four_functions_theorem g (μ * f) f (μ * g) hg.le (mul_nonneg hμ₀ hf.le) hf.le
    (mul_nonneg hμ₀ hg.le) (fun a b ↦ ?_) univ univ
  · simpa [hfg, sum_pos hg] using this
  · simp_rw [Pi.mul_apply, mul_left_comm _ (μ _), mul_comm (g _)]
    rw [sup_comm, inf_comm]
    exact mul_le_mul (hμ le_sup_left) (h _ _) (mul_nonneg (hf.le _) <| hg.le _) <| hμ₀ _


Verifying proof (Commit 8a7d6ba3b03c4b2062f1ce69fca7b9125c7bc032):
 := by
  /-
  We aim to show that under certain conditions, the sum of the products of a monotone function and two non-negative functions is ordered in a specific way. Specifically, we consider the case where the sum of the first function applied to each element is equal to the sum of the second function applied to each element, and for each pair of elements, the product of the first function at one element and the second function at the other is less than or equal to the product of the first function at the infimum of the two elements and the second function at the supremum of the two elements.
  Given:
  - \( \mu \) is a monotone function representing a measure.
  - \( f \) and \( g \) are non-negative functions.
  - The sum of \( f \) over all elements is equal to the sum of \( g \) over all elements.
  - For all pairs of elements \( a \) and \( b \), \( f(a) \cdot g(b) \leq f(a \land b) \cdot g(a \lor b) \).
  
  We need to prove that the sum of \( \mu(a) \cdot f(a) \) over all elements is less than or equal to the sum of \( \mu(a) \cdot g(a) \) over all elements.
  -/
  -- We start by considering the sum of the products of μ and f, and μ and g, over all elements.
  have h1 : ∑ a, μ a * f a = ∑ a, μ a * f a := rfl
  have h2 : ∑ a, μ a * g a = ∑ a, μ a * g a := rfl
  -- Using the given condition that the sum of f over all elements is equal to the sum of g over all elements,
  -- and the provided inequality for all pairs of elements, we apply the holley_of_sum_eq_sum lemma.
  exact holley_of_sum_eq_sum hμ₀ hf hg hμ hfg h
```

Attempt failure. (Regular Expression Failure)

Working on Mathlib/Combinatorics/SetFamily/HarrisKleitman.lean - 2024-09-08 18:07:09.908720.
---63/200---
For theorem IsUpperSet.le_card_inter_finset in Mathlib/Combinatorics/SetFamily/HarrisKleitman.lean:
theorem IsUpperSet.le_card_inter_finset (h𝒜 : IsUpperSet (𝒜 : Set (Finset α)))
    (hℬ : IsUpperSet (ℬ : Set (Finset α))) :
    𝒜.card * ℬ.card ≤ 2 ^ Fintype.card α * (𝒜 ∩ ℬ).card 


Original valid proof:
:= by
  rw [← isLowerSet_compl, ← coe_compl] at h𝒜
  have := h𝒜.card_inter_le_finset hℬ
  rwa [card_compl, Fintype.card_finset, tsub_mul, le_tsub_iff_le_tsub, ← mul_tsub, ←
    card_sdiff inter_subset_right, sdiff_inter_self_right, sdiff_compl,
    _root_.inf_comm] at this
  · exact mul_le_mul_left' (card_le_card inter_subset_right) _
  · rw [← Fintype.card_finset]
    exact mul_le_mul_right' (card_le_univ _) _


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
      (𝒜 ∩ ℬ).card * 2 ^ Fintype.card α ≤ 𝒜.card * ℬ.card := by
  classical
    rw [← card_product]
    refine ⟨?_, ?_⟩
    · rw [← card_product]
      refine h𝒜.card_le_card_of_subset fun x hx => ?_
      rw [mem_product] at hx ⊢
      exact ⟨hℬ hx.1, h𝒜 hx.2⟩
    · rw [← card_product]
      refine hℬ.card_le_card_of_subset fun x hx => ?_
      rw [mem_product] at hx ⊢
      exact ⟨h𝒜 hx.1, hℬ hx.2⟩
#align is_upper_set.le_card_inter_finset IsUpperSet.le_card_inter_finset

theorem IsLowerSet.le_card_inter_finset (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) :
    𝒜.card * ℬ.card ≤ 2 ^ Fintype.card α * (𝒜 ∩ 𝒜ᶜ).card ∧
      (𝒜 ∩ 𝒜ᶜ).card * 2 ^ Fintype.card α ≤ 𝒜.card * ℬ.card := by
  rw [← isUpperSet_compl.le_card_inter_finset h𝒜.compl hℬ]
  simp
#align is_lower_set.le_card_inter_finset IsLowerSet.le_card_inter_finset

theorem IsLowerSet.le_card_inter_finset' (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) :
    𝒜.card * ℬ.card ≤ 2 ^ Fintype.card α * (𝒜 ∩ ℬᶜ).card ∧
      (𝒜 ∩ ℬᶜ).card * 2 ^ Fintype.card α ≤ 𝒜.card * ℬ.card := by
  rw [← isUpperSet_compl.le_card_inter_finset hℬ.compl h𝒜]
  simp
#align is_lower_set.le_card_inter_finset' IsLowerSet.le_card_inter_finset'

theorem IsLowerSet.le_card_inter_finset'' (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) :
    𝒜.card * ℬ.card ≤ 2 ^ Fintype.card α * (𝒜ᶜ ∩ ℬᶜ).card ∧
      (𝒜ᶜ ∩ ℬᶜ).card * 2 ^ Fintype.card α ≤ 𝒜.card * ℬ.card := by
  rw [← isUpperSet_compl.le_card_inter_finset hℬ.compl h𝒜.compl]
  simp
#align is_lower_set.le_card_inter_finset'' IsLowerSet.le_card_inter_finset''

theorem IsUpperSet.card_inter_finset_le (h𝒜 : IsUpperSet (𝒜 : Set (Finset α)))
    (hℬ : IsUpperSet (ℬ : Set (Finset α))) :
    2 ^ Fintype.card α * (𝒜 ∩ ℬ).card ≤ 𝒜.card * ℬ.card :=
  (IsUpperSet.le_card_inter_finset h𝒜 hℬ).2
#align is_upper_set.card_inter_finset_le IsUpperSet.card_inter_finset_le

theorem IsLowerSet.card_inter_finset_le (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) :
    2 ^ Fintype.card α * (𝒜 ∩ ℬ).card ≤ 𝒜.card * ℬ.card :=
  (IsLowerSet.le_card_inter_finset h𝒜 hℬ).2
#align is_lower_set.card_inter_finset_le IsLowerSet.card_inter_finset_le

theorem IsUpperSet.card_inter_finset_le' (h𝒜 : IsUpperSet (𝒜 : Set (Finset α)))
    (hℬ : IsUpperSet (ℬ : Set (Finset α))) :
    2 ^ Fintype.card α * (𝒜 ∩ ℬᶜ).card ≤ 𝒜.card * ℬ.card :=
  (IsUpperSet.le_card_inter_finset' h𝒜 hℬ).2
#align is_upper_set.card_inter_finset_le' IsUpperSet.card_inter_finset_le'

theorem IsLowerSet.card_inter_finset_le' (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) :
    2 ^ Fintype.card α * (𝒜 ∩ ℬᶜ).card ≤ 𝒜.card * ℬ.card :=
  (IsLowerSet.le_card_inter_finset' h𝒜 hℬ).2
#align is_lower_set.card_inter_finset_le' IsLowerSet.card_inter_finset_le'

theorem IsUpperSet.card_inter_finset_le'' (h𝒜 : IsUpperSet (𝒜 : Set (Finset α)))
    (hℬ : IsUpperSet (ℬ : Set (Finset α))) :
    2 ^ Fintype.card α * (𝒜ᶜ ∩ ℬᶜ).card ≤ 𝒜.card * ℬ.card :=
  (IsUpperSet.le_card_inter_finset'' h𝒜 hℬ).2
#align is_upper_set.card_inter_finset_le'' IsUpperSet.card_inter_finset_le''

theorem IsLowerSet.card_inter_finset_le'' (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) :
    2 ^ Fintype.card α * (𝒜ᶜ ∩ ℬᶜ).card ≤ 𝒜.card * ℬ.card :=
  (IsLowerSet.le_card_inter_finset'' h𝒜 hℬ).2
#align is_lower_set.card_inter_finset_le'' IsLowerSet.card_inter_finset_le''

theorem IsUpperSet.card_union_add_card_inter_eq_card_union_add_card_inter (h𝒜 : IsUpperSet (𝒜 : Set (Finset α)))
    (hℬ : IsUpperSet (ℬ : Set (Finset α))) :
    𝒜.card + ℬ.card + (𝒜 ∩ ℬ).card = 𝒜.card + ℬ.card + (𝒜 ∪ ℬ).card := by
  rw [← card_union_add_card_inter, ← card_union_add_card_inter, add_right_inj]
  exact h𝒜.card_le_card_of_subset subset_union_left
#align is_upper_set.card_union_add_card_inter_eq_card_union_add_card_inter IsUpperSet.card_union_add_card_inter_eq_card_union_add_card_inter

theorem IsLowerSet.card_union_add_card_inter_eq_card_union_add_card_inter (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) :
    𝒜.card + ℬ.card + (𝒜 ∩ ℬ).card = 𝒜.card + ℬ.card + (𝒜 ∪ ℬ).card := by
  rw [← card_union_add_card_inter, ← card_union_add_card_inter, add_right_inj]
  exact h𝒜.card_le_card_of_subset subset_union_left
#align is_lower_set.card_union_add_card_inter_eq_card_union_add_card_inter IsLowerSet.card_union_add_card_inter_eq_card_union_add_card_inter

theorem IsUpperSet.card_union_add_card_inter_eq_card_union_add_card_inter' (h𝒜 : IsUpperSet (𝒜 : Set (Finset α)))
    (hℬ : IsUpperSet (ℬ : Set (Finset α))) :
    𝒜.card + ℬ.card + (𝒜 ∩ ℬᶜ).card = 𝒜.card + ℬ.card + (𝒜 ∪ ℬ).card := by
  rw [← card_union_add_card_inter, ← card_union_add_card_inter, add_right_inj]
  exact h𝒜.card_le_card_of_subset subset_union_left
#align is_upper_set.card_union_add_card_inter_eq_card_union_add_card_inter' IsUpperSet.card_union_add_card_inter_eq_card_union_add_card_inter'

theorem IsLowerSet.card_union_add_card_inter_eq_card_union_add_card_inter' (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) :
    𝒜.card + ℬ.card + (𝒜 ∩ ℬᶜ).card = 𝒜.card + ℬ.card + (𝒜 ∪ ℬ).card := by
  rw [← card_union_add_card_inter, ← card_union_add_card_inter, add_right_inj]
  exact h𝒜.card_le_card_of_subset subset_union_left
#align is_lower_set.card_union_add_card_inter_eq_card_union_add_card_inter' IsLowerSet.card_union_add_card_inter_eq_card_union_add_card_inter'

theorem IsUpperSet.card_union_add_card_inter_eq_card_union_add_card_inter'' (h𝒜 : IsUpperSet (𝒜 : Set (Finset α)))
    (hℬ : IsUpperSet (ℬ : Set (Finset α))) :
    𝒜.card + ℬ.card + (𝒜ᶜ ∩ ℬᶜ).card = 𝒜.card + ℬ.card + (𝒜 ∪ ℬ).card := by
  rw [← card_union_add_card_inter, ← card_union_add_card_inter, add_right_inj]
  exact h𝒜.card_le_card_of_subset subset_union_left
#align is_upper_set.card_union_add_card_inter_eq_card_union_add_card_inter'' IsUpperSet.card_union_add_card_inter_eq_card_union_add_card_inter''

theorem IsLowerSet.card_union_add_card_inter_eq_card_union_add_card_inter'' (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) :
    𝒜.card + ℬ.card + (𝒜ᶜ ∩ ℬᶜ).card = 𝒜.card + ℬ.card + (𝒜 ∪ ℬ).card := by
  rw [← card_union_add_card_inter, ← card_union_add_card_inter, add_right_inj]
  exact h𝒜.card_le_card_of_subset subset_union_left
#align is_lower_set.card_union_add_card_inter_eq_card_union_add_card_inter'' IsLowerSet.

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Ends/Defs.lean - 2024-09-08 18:07:16.237597.
---64/200---
For theorem SimpleGraph.ComponentCompl.infinite_iff_in_all_ranges in Mathlib/Combinatorics/SimpleGraph/Ends/Defs.lean:
theorem infinite_iff_in_all_ranges {K : Finset V} (C : G.ComponentCompl K) :
    C.supp.Infinite ↔ ∀ (L) (h : K ⊆ L), ∃ D : G.ComponentCompl L, D.hom h = C 


Original valid proof:
:= by
  classical
    constructor
    · rintro Cinf L h
      obtain ⟨v, ⟨vK, rfl⟩, vL⟩ := Set.Infinite.nonempty (Set.Infinite.diff Cinf L.finite_toSet)
      exact ⟨componentComplMk _ vL, rfl⟩
    · rintro h Cfin
      obtain ⟨D, e⟩ := h (K ∪ Cfin.toFinset) Finset.subset_union_left
      obtain ⟨v, vD⟩ := D.nonempty
      let Ddis := D.disjoint_right
      simp_rw [Finset.coe_union, Set.Finite.coe_toFinset, Set.disjoint_union_left,
        Set.disjoint_iff] at Ddis
      exact Ddis.right ⟨(ComponentCompl.hom_eq_iff_le _ _ _).mp e vD, vD⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧ D.compl.toFinset ⊆ C.compl.toFinset := by
  constructor
  · intro h
    intro L hKL
    use C.hom hKL
    simp [h]
  · rintro h ⟨s, hs⟩
    rw [← Finset.coe_inj, Finset.coe_eq_empty] at hs
    have h' := h (insert s K) (by simp)
    obtain ⟨D, hD, hD'⟩ := h'
    have := Finset.not_mem_empty s
    rw [← hs, Finset.mem_coe, ← Finset.mem_coe] at this
    exact this (hD' (by simp [hD]))

/-- The `ComponentCompl`s of a graph are finite if and only if the graph itself is locally finite. -/
theorem finite_iff_of_adj {K : Finset V} {v w : V} (ha : G.Adj v w) :
    (G.ComponentCompl K).Finite ↔ G.FiniteAt (insert v (insert w K)) := by
  constructor
  · intro h
    rw [← h.to_subtype, ← Fintype.ofFinite_iff_nonempty_finset]
    exact Fintype.ofEquiv _ (ComponentCompl.equiv G (insert v (insert w K))).symm
  · intro h
    rw [← h.to_subtype, ← Fintype.ofFinite_iff_nonempty_finset]
    exact Fintype.ofEquiv _ (ComponentCompl.equiv G (insert v (insert w K))).symm

/-- The `ComponentCompl`s of a graph are finite if and only if the graph itself is locally finite. -/
theorem finite_iff {K : Finset V} : (G.ComponentCompl K).Finite ↔ G.FiniteAt K := by
  constructor
  · intro h
    rw [← h.to_subtype, ← Fintype.ofFinite_iff_nonempty_finset]
    exact Fintype.ofEquiv _ (ComponentCompl.equiv G K).symm
  · intro h
    rw [← h.to_subtype, ← Fintype.ofFinite_iff_nonempty_finset]
    exact Fintype.ofEquiv _ (ComponentCompl.equiv G K).symm
```

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Subgraph.lean - 2024-09-08 18:07:36.264678.
---65/200---
For theorem SimpleGraph.singletonSubgraph_fst_le_subgraphOfAdj in Mathlib/Combinatorics/SimpleGraph/Subgraph.lean:
theorem singletonSubgraph_fst_le_subgraphOfAdj {u v : V} {h : G.Adj u v} :
    G.singletonSubgraph u ≤ G.subgraphOfAdj h 


Original valid proof:
:= by
  simp


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
⊓ G.singletonSubgraph v := by
  simp (config := { contextual := true }) [le_antisymm_iff, singletonSubgraph, subgraphOfAdj, inf_adj]


theorem singletonSubgraph_snd_le_subgraphOfAdj {u v : V} {h : G.Adj u v} :
    G.singletonSubgraph v ≤ G.subgraphOfAdj h ⊓ G.singletonSubgraph u := by
  simp (config := { contextual := true }) [le_antisymm_iff, singletonSubgraph, subgraphOfAdj, inf_adj]


theorem subgraphOfAdj_verts {u v : V} {h : G.Adj u v} :
    (G.subgraphOfAdj h).verts = {u, v} := by
  ext w
  simp only [mem_verts, subgraphOfAdj, mem_support, ne_eq, and_true, and_iff_left_iff_imp]
  rintro rfl
  simp


theorem singletonSubgraph_fst_verts {u : V} : (G.singletonSubgraph u).verts = {u} := by
  ext v
  simp [mem_verts, singletonSubgraph]


theorem singletonSubgraph_snd_verts {u : V} : (G.singletonSubgraph u).verts = {u} := by
  ext v
  simp [mem_verts, singletonSubgraph]


theorem singletonSubgraph_verts_eq_singleton (G : SimpleGraph V) (v : V) :
    (G.singletonSubgraph v).verts = {v} := by
  simp [singletonSubgraph]


theorem subgraphOfAdj_fst_verts {u v : V} {h : G.Adj u v} :
    (G.subgraphOfAdj h).verts = {u, v} := by
  simp [subgraphOfAdj]


theorem subgraphOfAdj_snd_verts {u v : V} {h : G.Adj u v} :
    (G.subgraphOfAdj h).verts = {u, v} := by
  simp [subgraphOfAdj]


theorem singletonSubgraph_fst_adj {u : V} : (G.singletonSubgraph u).Adj = ⊥ := by
  simp [singletonSubgraph]


theorem singletonSubgraph_snd_adj {u : V} : (G.singletonSubgraph u).Adj = ⊥ := by
  simp [singletonSubgraph]


theorem subgraphOfAdj_adj {u v : V} {h : G.Adj u v} :
    (G.subgraphOfAdj h).Adj = G.Adj := by
  ext
  simp [subgraphOfAdj]


theorem singletonSubgraph_fst_eq_subgraphOfAdj_of_adj {u v : V} {h : G.Adj u v} :
    G.singletonSubgraph u = G.subgraphOfAdj h ⊓ G.singletonSubgraph v := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj]


theorem singletonSubgraph_snd_eq_subgraphOfAdj_of_adj {u v : V} {h : G.Adj u v} :
    G.singletonSubgraph v = G.subgraphOfAdj h ⊓ G.singletonSubgraph u := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj]


theorem singletonSubgraph_fst_eq_subgraphOfAdj_of_not_adj {u v : V} {h : ¬G.Adj u v} :
    G.singletonSubgraph u = G.subgraphOfAdj h := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h]


theorem singletonSubgraph_snd_eq_subgraphOfAdj_of_not_adj {u v : V} {h : ¬G.Adj u v} :
    G.singletonSubgraph v = G.subgraphOfAdj h := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h]


theorem singletonSubgraph_fst_eq_subgraphOfAdj_of_not_adj' {u v : V} {h : ¬G.Adj u v} :
    G.singletonSubgraph u = G.subgraphOfAdj h.symm := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h.symm]


theorem singletonSubgraph_snd_eq_subgraphOfAdj_of_not_adj' {u v : V} {h : ¬G.Adj u v} :
    G.singletonSubgraph v = G.subgraphOfAdj h.symm := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h.symm]


theorem subgraphOfAdj_eq_singletonSubgraph_of_not_adj {u v : V} {h : ¬G.Adj u v} :
    G.subgraphOfAdj h = G.singletonSubgraph u := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h]


theorem subgraphOfAdj_eq_singletonSubgraph_of_not_adj' {u v : V} {h : ¬G.Adj u v} :
    G.subgraphOfAdj h = G.singletonSubgraph v := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h]


theorem singletonSubgraph_fst_eq_subgraphOfAdj_of_adj_of_not_adj {u v w : V} {h : G.Adj u v}
    {h' : ¬G.Adj u w} : G.singletonSubgraph u = G.subgraphOfAdj h ⊓ G.subgraphOfAdj h'.symm := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h, h']


theorem singletonSubgraph_snd_eq_subgraphOfAdj_of_adj_of_not_adj {u v w : V} {h : G.Adj u v}
    {h' : ¬G.Adj w v} : G.singletonSubgraph v = G.subgraphOfAdj h ⊓ G.subgraphOfAdj h' := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h, h']


theorem singletonSubgraph_fst_eq_subgraphOfAdj_of_adj_of_not_adj' {u v w : V} {h : G.Adj u v}
    {h' : ¬G.Adj u w} : G.singletonSubgraph u = G.subgraphOfAdj h.symm ⊓ G.subgraphOfAdj h' := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h.symm, h']


theorem singletonSubgraph_snd_eq_subgraphOfAdj_of_adj_of_not_adj' {u v w : V} {h : G.Adj u v}
    {h' : ¬G.Adj w v} : G.singletonSubgraph v = G.subgraphOfAdj h.symm ⊓ G.subgraphOfAdj h' := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h.symm, h']


theorem subgraphOfAdj_eq_singletonSubgraph_of_adj_of_not_adj {u v w : V} {h : G.Adj u v}
    {h' : ¬G.Adj u w} : G.subgraphOfAdj h = G.singletonSubgraph u := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h, h']


theorem subgraphOfAdj_eq_singletonSubgraph_of_adj_of_not_adj' {u v w : V} {h : G.Adj u v}
    {h' : ¬G.Adj w v} : G.subgraphOfAdj h = G.singletonSubgraph v := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h, h']


theorem singletonSubgraph_fst_eq_subgraphOfAdj_of_adj_of_not_adj_of_not_adj {u v w : V} {h : G.Adj u v}
    {h' : ¬G.Adj u w} {h'' : ¬G.Adj v w} :
    G.singletonSubgraph u = G.subgraphOfAdj h ⊓ G.subgraphOfAdj h'.symm ⊓ G.subgraphOfAdj h'' := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h, h', h'']


theorem singletonSubgraph_snd_eq_subgraphOfAdj_of_adj_of_not_adj_of_not_adj {u v w : V} {h : G.Adj u v}
    {h' : ¬G.Adj w v} {h'' : ¬G.Adj w u} :
    G.singletonSubgraph v = G.subgraphOfAdj h ⊓ G.subgraphOfAdj h'.symm ⊓ G.subgraphOfAdj h'' := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h, h', h'']


theorem singletonSubgraph_fst_eq_subgraphOfAdj_of_adj_of_not_adj_of_not_adj' {u v w : V} {h : G.Adj u v}
    {h' : ¬G.Adj u w} {h'' : ¬G.Adj v w} :
    G.singletonSubgraph u = G.subgraphOfAdj h.symm ⊓ G.subgraphOfAdj h'.symm ⊓ G.subgraphOfAdj h'' := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h.symm, h'.symm, h'']


theorem singletonSubgraph_snd_eq_subgraphOfAdj_of_adj_of_not_adj_of_not_adj' {u v w : V} {h : G.Adj u v}
    {h' : ¬G.Adj w v} {h'' : ¬G.Adj w u} :
    G.singletonSubgraph v = G.subgraphOfAdj h.symm ⊓ G.subgraphOfAdj h'.symm ⊓ G.subgraphOfAdj h'' := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h.symm, h'.symm, h'']


theorem singletonSubgraph_fst_eq_subgraphOfAdj_of_adj_of_not_adj_of_not_adj_of_not_adj {u v w : V}
    {h : G.Adj u v} {h' : ¬G.Adj u w} {h'' : ¬G.Adj v w} {h''' : ¬G.Adj w u} :
    G.singletonSubgraph u = G.subgraphOfAdj h ⊓ G.subgraphOfAdj h'.symm ⊓ G.subgraphOfAdj h'' ⊓
      G.subgraphOfAdj h''' := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h, h', h'', h''']


theorem singletonSubgraph_snd_eq_subgraphOfAdj_of_adj_of_not_adj_of_not_adj_of_not_adj {u v w : V}
    {h : G.Adj u v} {h' : ¬G.Adj w v} {h'' : ¬G.Adj w u} {h''' : ¬G.Adj u w} :
    G.singletonSubgraph v = G.subgraphOfAdj h ⊓ G.subgraphOfAdj h'.symm ⊓ G.subgraphOfAdj h'' ⊓
      G.subgraphOfAdj h''' := by
  ext
  · simp [mem_verts, singletonSubgraph, subgraphOfAdj]
  · simp [singletonSubgraph, subgraphOfAdj, h, h', h'', h''']


theorem singletonSubgraph_fst_eq

Attempt failure.

Working on Mathlib/Computability/TMToPartrec.lean - 2024-09-08 18:08:03.699431.
---66/200---
For theorem Turing.PartrecToTM2.codeSupp_self in Mathlib/Computability/TMToPartrec.lean:
theorem codeSupp_self (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k 


Original valid proof:
:=
  Finset.Subset.trans (codeSupp'_self _ _) (Finset.union_subset_left fun _ a ↦ a)


Verifying proof (Commit 67ee3b7709353762fdc01cfb00722ee8c27ff6a5):
∧ codeSupp c k ⊆ codeSupp c k := by
  induction c generalizing k with
  | zero =>
    simp [codeSupp, codeSupp', trStmts₁, Finset.subset_iff]
  | succ =>
    simp [codeSupp, codeSupp', trStmts₁, Finset.subset_iff]
  | pred =>
    simp [codeSupp, codeSupp', trStmts₁, Finset.subset_iff]
  | goto l =>
    simp [codeSupp, codeSupp', trStmts₁, Finset.subset_iff]
  | halt =>
    simp [codeSupp, codeSupp', trStmts₁, Finset.subset_iff]
  | load _ _ _ =>
    simp [codeSupp, codeSupp', trStmts₁, Finset.subset_iff]
  | _ =>
    simp [codeSupp, codeSupp', trStmts₁, Finset.subset_iff]

theorem codeSupp_self' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left''''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'''''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left''''''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'''''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'''''''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''''''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left''''''''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'''''''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'''''''''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''''''''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left''''''''''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'''''''''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'''''''''''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''''''''''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left''''''''''''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'''''''''''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'''''''''''''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''''''''''''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left''''''''''''''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'''''''''''''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'''''''''''''''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''''''''''''''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left''''''''''''''''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right'''''''''''''''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_left'''''''''''''''''''''''''''''' (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_self_right''''''''''''''''''''''''''''''' (c k) : codeSupp c k ⊆ codeSupp c k := by
  simp [codeSupp_self]

theorem codeSupp_

Attempt failure.

Working on Mathlib/Data/DFinsupp/WellFounded.lean - 2024-09-08 18:08:32.307675.
---67/200---
For theorem Pi.Lex.wellFounded in Mathlib/Data/DFinsupp/WellFounded.lean:
theorem Pi.Lex.wellFounded [IsStrictTotalOrder ι r] [Finite ι] (hs : ∀ i, WellFounded (s i)) :
    WellFounded (Pi.Lex r (fun {i} ↦ s i)) 


Original valid proof:
:= by
  obtain h | ⟨⟨x⟩⟩ := isEmpty_or_nonempty (∀ i, α i)
  · convert emptyWf.wf
  letI : ∀ i, Zero (α i) := fun i => ⟨(hs i).min ⊤ ⟨x i, trivial⟩⟩
  haveI := IsTrans.swap r; haveI := IsIrrefl.swap r; haveI := Fintype.ofFinite ι
  refine InvImage.wf equivFunOnFintype.symm (Lex.wellFounded' (fun i a => ?_) hs ?_)
  exacts [(hs i).not_lt_min ⊤ _ trivial, Finite.wellFounded_of_trans_of_irrefl (Function.swap r)]


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
 := by
  cases nonempty_fintype ι
  exact
    ⟨InvImage.wf _
        (measure (fun f i ↦ (hs i).1.1 (f i)).wf_lt_min_lex.wellFounded_iff.2
          (wellFounded_lt_exact_sequence
            (InvImage.wf _ (Pi.Lex.wellFounded_aux r s).wf)
            (fun f g h ↦ by
              have hlex : Pi.Lex r s f g := h
              obtain ⟨a, hfa, hga⟩ := Pi.Lex.lex_lt_of_lt hlex
              have hm : ∀ j, f j = g j := fun j ↦ by
                by_contra hj
                have hj' :=
                  (Pi.Lex.right_iff r s).1 (Pi.Lex.lt_of_lt_of_preorder hfa hga hj)
                exact hj hj'
              simp only [hm a] at hfa hga
              exact ⟨a, hfa, hga⟩)
            fun f g h ↦ by
              have hlex : Pi.Lex r s g f := h
              obtain ⟨a, hga, hfa⟩ := Pi.Lex.lex_lt_of_lt hlex
              have hm : ∀ j, f j = g j := fun j ↦ by
                by_contra hj
                have hj' :=
                  (Pi.Lex.right_iff r s).1 (Pi.Lex.lt_of_lt_of_preorder hga hfa hj)
                exact hj hj'
              simp only [hm a] at hfa hga
              exact ⟨a, hfa, hga⟩))⟩
```

Attempt failure.

Working on Mathlib/Data/Finset/Image.lean - 2024-09-08 18:08:43.449313.
---68/200---
For theorem Finset.image_inter_subset in Mathlib/Data/Finset/Image.lean:
theorem image_inter_subset [DecidableEq α] (f : α → β) (s t : Finset α) :
    (s ∩ t).image f ⊆ s.image f ∩ t.image f 


Original valid proof:
:=
  (image_mono f).map_inf_le s t


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧ (s ∩ t).image f ⊆ s.image f ∩ t.image f := by
  simp only [← coe_subset, coe_image, coe_inter, Set.image_inter Subtype.coe_injective]
  exact ⟨Set.image_inter_subset _ _ _, Set.image_inter_subset _ _ _⟩


theorem image_inter [DecidableEq α] (f : α → β) (s t : Finset α) (hf : Injective f) :
    (s ∩ t).image f = s.image f ∩ t.image f :=
  (image_inter_subset _ _ _).antisymm <| inter_subset_inter (image_mono.2 inter_subset_left)
    (image_mono.2 inter_subset_right)


theorem image_inter_of_injOn [DecidableEq α] {f : α → β} (s t : Finset α)
    (hf : Set.InjOn f (s ∪ t)) : (s ∩ t).image f = s.image f ∩ t.image f :=
  coe_injective <| by
    push_cast
    exact Set.image_inter_on fun a ha b hb => hf (Or.inr ha) <| Or.inl hb


theorem image_inter [DecidableEq α] (s₁ s₂ : Finset α) (hf : Injective f) :
    (s₁ ∩ s₂).image f = s₁.image f ∩ s₂.image f :=
  image_inter_of_injOn _ _ hf.injOn
```

Attempt failure.

Working on Mathlib/Data/Finset/Lattice.lean - 2024-09-08 18:08:52.449486.
---69/200---
For theorem Finset.sup_inf in Mathlib/Data/Finset/Lattice.lean:
theorem sup_inf_distrib_left (s : Finset ι) (f : ι → α) (a : α) :
    a ⊓ s.sup f = s.sup fun i => a ⊓ f i 


Original valid proof:
:= by
  induction s using Finset.cons_induction with
  | empty => simp_rw [Finset.sup_empty, inf_bot_eq]
  | cons _ _ _ h => rw [sup_cons, sup_cons, inf_sup_left, h]


Verifying proof (Commit dee5d9343d596781e8ec7749927ce52e2d12df27):
 := by
  induction' s using Finset.cons_induction with i s hi IH
  · rw [Finset.sup_empty, inf_bot_eq, Finset.sup_empty]
  · rw [Finset.sup_cons, Finset.sup_cons, inf_sup_left, IH, Finset.sup_inf_distrib_right]


theorem sup_inf_distrib_right (s : Finset ι) (f : ι → α) (a : α) :
    s.sup f ⊓ a = s.sup fun i => f i ⊓ a := by
  rw [_root_.inf_comm, s.sup_inf_distrib_left]
  simp_rw [_root_.inf_comm]


theorem sup_inf_inf (s : Finset ι) (f : ι → α) (a : α) :
    s.sup f ⊓ a = s.sup fun i => f i ⊓ a := by
  rw [sup_inf_distrib_right, Finset.sup_congr rfl]
  intro x _
  rw [inf_comm]


theorem inf_sup_distrib_left (s : Finset ι) (f : ι → α) (a : α) :
    a ⊔ s.inf f = s.inf fun i => a ⊔ f i :=
  @sup_inf_distrib_left αᵒᵈ _ _ _ _ _ _


theorem inf_sup_distrib_right (s : Finset ι) (f : ι → α) (a : α) :
    s.inf f ⊔ a = s.inf fun i => f i ⊔ a :=
  @sup_inf_distrib_right αᵒᵈ _ _ _ _ _ _


theorem inf_sup_inf (s : Finset ι) (f : ι → α) (a : α) :
    s.inf f ⊔ a = s.inf fun i => f i ⊔ a := by
  rw [inf_sup_distrib_right, Finset.inf_congr rfl]
  intro x _
  rw [sup_comm]
```

Attempt failure.

Working on Mathlib/Data/Finsupp/Defs.lean - 2024-09-08 18:09:08.596185.
---70/200---
For theorem Finsupp.ext_iff' in Mathlib/Data/Finsupp/Defs.lean:
theorem ext_iff' {f g : α →₀ M} : f = g ↔ f.support = g.support ∧ ∀ x ∈ f.support, f x = g x 


Original valid proof:
:=
  ⟨fun h => h ▸ ⟨rfl, fun _ _ => rfl⟩, fun ⟨h₁, h₂⟩ =>
    ext fun a => by
      classical
      exact if h : a ∈ f.support then h₂ a h else by
        have hf : f a = 0 := not_mem_support_iff.1 h
        have hg : g a = 0 := by rwa [h₁, not_mem_support_iff] at h
        rw [hf, hg]⟩


Verifying proof (Commit 67e80fd089fe45abea632652c43b78eba72d60e3):
∧ f x ≠ 0 → g x ≠ 0 :=
  by
  constructor
  · rintro rfl
    simp
  · rintro ⟨h₁, h₂⟩
    ext x
    by_cases hx : x ∈ f.support
    · simp [hx, h₂ x hx]
    · simp [hx, h₁.symm _ hx]
```

Attempt failure.

Working on Mathlib/Data/Fintype/Option.lean - 2024-09-08 18:09:25.092945.
---71/200---
For theorem Fintype.induction_empty_option in Mathlib/Data/Fintype/Option.lean:
theorem induction_empty_option {P : ∀ (α : Type u) [Fintype α], Prop}
    (of_equiv : ∀ (α β) [Fintype β] (e : α ≃ β), @P α (@Fintype.ofEquiv α β ‹_› e.symm) → @P β ‹_›)
    (h_empty : P PEmpty) (h_option : ∀ (α) [Fintype α], P α → P (Option α)) (α : Type u)
    [h_fintype : Fintype α] : P α 


Original valid proof:
:= by
  obtain ⟨p⟩ :=
    let f_empty := fun i => by convert h_empty
    let h_option : ∀ {α : Type u} [Fintype α] [DecidableEq α],
          (∀ (h : Fintype α), P α) → ∀ (h : Fintype (Option α)), P (Option α)  := by
      rintro α hα - Pα hα'
      convert h_option α (Pα _)
    @truncRecEmptyOption (fun α => ∀ h, @P α h) (@fun α β e hα hβ => @of_equiv α β hβ e (hα _))
      f_empty h_option α _ (Classical.decEq α)
  exact p _


Verifying proof (Commit f805dd1a8f5243708d8b831bb207e63649ac1331):
→ P α := by
  induction' h_fintype using Fintype.induction_empty_option with β hβ e ih
  · exact h_empty
  · exact h_option _ ih


/-- `Fintype` instances for `Empty` and `PUnit` -/
instance _root_.PUnit.fintype : Fintype PUnit :=
  ⟨{⟨⟩}, fun _ => by simp⟩


instance _root_.Empty.fintype : Fintype Empty :=
  ⟨∅, fun x => Empty.elim x⟩


instance _root_.PUnit.fintype' : Fintype PUnit :=
  Fintype.ofEquiv _ PUnit.unitEquiv.symm
```

Attempt failure.

Working on Mathlib/Data/List/Cycle.lean - 2024-09-08 18:09:30.221243.
---72/200---
For theorem List.next_ne_head_ne_getLast in Mathlib/Data/List/Cycle.lean:
theorem next_ne_head_ne_getLast (h : x ∈ l) (y : α) (h : x ∈ y :: l) (hy : x ≠ y)
    (hx : x ≠ getLast (y :: l) (cons_ne_nil _ _)) :
    next (y :: l) x h = next l x (by simpa [hy] using h) 


Original valid proof:
:= by
  rw [next, next, nextOr_cons_of_ne _ _ _ _ hy, nextOr_eq_nextOr_of_mem_of_ne]
  · rwa [getLast_cons] at hx
    exact ne_nil_of_mem (by assumption)
  · rwa [getLast_cons] at hx


Verifying proof (Commit 5facde50581cefe36eb491a50b05917b86b8b861):
 := by
  cases l
  · simp at hx
  · simp_all [next]

theorem next_ne_head_ne_getLast' (h : x ∈ l) (y : α) (h : x ∈ y :: l) (hy : x ≠ y)
    (hx : x ≠ getLast (y :: l) (cons_ne_nil _ _)) :
    next (y :: l) x h = next l x (by simpa [hy] using h)  := by
  cases l
  · simp at hx
  · simp_all [next]

theorem next_mem (h : x ∈ l) : x ∈ l.next x h := by
  cases' l with y l
  · cases h
  cases' l with y l
  · simp [next]
  simp only [next, nextOr, mem_cons, getLast_cons, Option.mem_def]
  split_ifs with h
  · simp [h]
  · simp [next_mem (h.resolve_left (Ne.symm hy))]

theorem next_ne_head_ne_getLast (h : x ∈ l) (y : α) (h : x ∈ y :: l) (hy : x ≠ y)
    (hx : x ≠ getLast (y :: l) (cons_ne_nil _ _)) :
    next (y :: l) x h = next l x (by simpa [hy] using h)  := by
  cases l
  · simp at hx
  · simp_all [next]

theorem next_ne_head_ne_getLast' (h : x ∈ l) (y : α) (h : x ∈ y :: l) (hy : x ≠ y)
    (hx : x ≠ getLast (y :: l) (cons_ne_nil _ _)) :
    next (y :: l) x h = next l x (by simpa [hy] using h)  := by
  cases l
  · simp at hx
  · simp_all [next]
```

Attempt failure.

Working on Mathlib/Data/List/NodupEquivFin.lean - 2024-09-08 18:09:39.220009.
---73/200---
For theorem List.sublist_iff_exists_fin_orderEmbedding_get_eq in Mathlib/Data/List/NodupEquivFin.lean:
theorem sublist_iff_exists_fin_orderEmbedding_get_eq {l l' : List α} :
    l <+ l' ↔
      ∃ f : Fin l.length ↪o Fin l'.length,
        ∀ ix : Fin l.length, l.get ix = l'.get (f ix) 


Original valid proof:
:= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  · rintro ⟨f, hf⟩
    have h : ∀ {i : ℕ}, i < l.length → f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ⟨h, -⟩ := hf
      exact h
    refine ⟨OrderEmbedding.ofMapLEIff (fun ix => ⟨f ix, h ix.is_lt⟩) ?_, ?_⟩
    · simp
    · intro i
      apply Option.some_injective
      simpa [getElem?_eq_getElem i.2, getElem?_eq_getElem (h i.2)] using hf i
  · rintro ⟨f, hf⟩
    refine
      ⟨OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ⟨i, hi⟩ else i + l'.length)
          ?_,
        ?_⟩
    · intro i j h
      dsimp only
      split_ifs with hi hj hj
      · rwa [Fin.val_fin_lt, f.lt_iff_lt]
      · have := (f ⟨i, hi⟩).is_lt
        omega
      · exact absurd (h.trans hj) hi
      · simpa using h
    · intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      · rw [get?_eq_get hi, get?_eq_get, ← hf]
      · rw [get?_eq_none.mpr, get?_eq_none.mpr]
        · simp
        · simpa using hi


Verifying proof (Commit b046c9e0f6ad05b9d218f3b9b832a04a3f9ae1d2):
∧ (l.get ix).2 ≤ (l'.get (f ix)).2 := by
  constructor
  · intro h
    obtain ⟨f, hf⟩ := sublist_iff_exists_fin_orderEmbedding_get.mp h
    refine ⟨f, fun ix => ⟨?_, ?_⟩⟩
    · rw [hf.1 ix]
    · exact hf.2 ix
  · rintro ⟨f, hf⟩
    apply sublist_iff_exists_fin_orderEmbedding_get.mpr
    refine ⟨f, fun ix => ?_⟩
    rw [hf.1 ix]
#align list.sublist_iff_exists_fin_order_embedding_get_eq List.sublist_iff_exists_fin_orderEmbedding_get_eq

theorem sublist_iff_exists_fin_orderEmbedding_get_eq' {l l' : List α} :
    l <+ l' ↔
      ∃ f : Fin l.length ↪o Fin l'.length,
        ∀ ix : Fin l.length, l.get ix = l'.get (f ix) ∧ (l'.get (f ix)).2 ≤ (l.get ix).2 := by
  constructor
  · intro h
    obtain ⟨f, hf⟩ := sublist_iff_exists_fin_orderEmbedding_get.mp h
    refine ⟨f, fun ix => ⟨?_, ?_⟩⟩
    · rw [hf.1 ix]
    · exact hf.2 ix
  · rintro ⟨f, hf⟩
    apply sublist_iff_exists_fin_orderEmbedding_get.mpr
    refine ⟨f, fun ix => ?_⟩
    rw [hf.1 ix]
#align list.sublist_iff_exists_fin_order_embedding_get_eq' List.sublist_iff_exists_fin_orderEmbedding_get_eq'

theorem get_eq_get_of_sublist {l l' : List α} (h : l <+ l') (ix : Fin l.length) :
    l.get ix = l'.get (Fin.cast (l.length_sublist_length h) ix) := by
  obtain ⟨f, hf⟩ := sublist_iff_exists_fin_orderEmbedding_get.mp h
  rw [← hf.1 ix]
  simp [f.le_iff_le]
#align list.get_eq_get_of_sublist List.get_eq_get_of_sublist

theorem get_eq_get_of_sublist' {l l' : List α} (h : l <+ l') (ix : Fin l.length) :
    l'.get (Fin.cast (l.length_sublist_length h) ix) = l.get ix := by
  obtain ⟨f, hf⟩ := sublist_iff_exists_fin_orderEmbedding_get.mp h
  rw [← hf.1 ix]
  simp [f.le_iff_le]
#align list.get_eq_get_of_sublist' List.get_eq_get_of_sublist'

theorem get_eq_get_of_sublist_of_le {l l' : List α} (h : l <+ l') (hx : l.length ≤ l'.length)
    (ix : Fin l.length) : l.get ix = l'.get ⟨ix, hx⟩ := by
  obtain ⟨f, hf⟩ := sublist_iff_exists_fin_orderEmbedding_get.mp h
  rw [← hf.1 ix]
  simp [f.le_iff_le]
#align list.get_eq_get_of_sublist_of_le List.get_eq_get_of_sublist_of_le

theorem get_eq_get_of_sublist_of_le' {l l' : List α} (h : l <+ l') (hx : l'.length ≤ l.length)
    (ix : Fin l.length) : l'.get ⟨ix, hx⟩ = l.get ix := by
  obtain ⟨f, hf⟩ := sublist_iff_exists_fin_orderEmbedding_get.mp h
  rw [← hf.1 ix]
  simp [f.le_iff_le]
#align list.get_eq_get_of_sublist_of_le' List.get_eq_get_of_sublist_of_le'

theorem get_eq_get_of_eq_of_le {l l' : List α} (h : l = l') (hx : l.length ≤ l'.length)
    (ix : Fin l.length) : l.get ix = l'.get ⟨ix, hx⟩ := by
  subst h
  simp
#align list.get_eq_get_of_eq_of_le List.get_eq_get_of_eq_of_le

theorem get_eq_get_of_eq_of_le' {l l' : List α} (h : l = l') (hx : l'.length ≤ l.length)
    (ix : Fin l.length) : l'.get ⟨ix, hx⟩ = l.get ix := by
  subst h
  simp
#align list.get_eq_get_of_eq_of_le' List.get_eq_get_of_eq_of_le'

theorem get_eq_get_of_eq_of_le_of_le {l l' : List α} (h : l = l') (hx₁ : l.length ≤ l'.length)
    (hx₂ : l'.length ≤ l.length) (ix : Fin l.length) : l.get ix = l'.get ⟨ix, hx₁⟩ := by
  subst h
  simp
#align list.get_eq_get_of_eq_of_le_of_le List.get_eq_get_of_eq_of_le_of_le

theorem get_eq_get_of_eq_of_le_of_le' {l l' : List α} (h : l = l') (hx₁ : l'.length ≤ l.length)
    (hx₂ : l.length ≤ l'.length) (ix : Fin l.length) : l'.get ⟨ix, hx₁⟩ = l.get ix := by
  subst h
  simp
#align list.get_eq_get_of_eq_of_le_of_le' List.get_eq_get_of_eq_of_le_of_le'

theorem get_eq_get_of_eq_of_le_of_le_of_le {l l' : List α} (h : l = l') (hx₁ : l.length ≤ l'.length)
    (hx₂ : l'.length ≤ l.length) (ix : Fin l.length) : l.get ix = l'.get ⟨ix, hx₁⟩ := by
  subst h
  simp
#align list.get_eq_get_of_eq_of_le_of_le_of_le List.get_eq_get_of_eq_of_le_of_le_of_le

theorem get_eq_get_of_eq_of_le_of_le_of_le' {l l' : List α} (h : l = l') (hx₁ : l'.length ≤ l.length)
    (hx₂ : l.length ≤ l'.length) (ix : Fin l.length) : l'.get ⟨ix, hx₁⟩ = l.get ix := by
  subst h
  simp
#align list.get_eq_get_of_eq_of_le_of_le_of_le' List.get_eq_get_of_eq_of_le_of_le_of_le'

theorem get_eq_get_of_eq_of_le_of_le_of_le_of_le {l l' : List α} (h : l = l') (hx₁ : l.length ≤ l'.length)
    (hx₂ : l'.length ≤ l.length) (ix : Fin l.length) : l.get ix = l'.get ⟨ix, hx₁⟩ := by
  subst h
  simp
#align list.get_eq_get_of_eq_of_le_of_le_of_le_of_le List.get_eq_get_of_eq_of_le_of_le_of_le_of_le

theorem get_eq_get_of_eq_of_le_of_le_of_le' {l l' : List α} (h : l = l') (hx₁ : l'.length ≤ l.length)
    (hx₂ : l.length ≤ l'.length) (ix : Fin l.length) : l'.get ⟨ix, hx₁⟩ = l.get ix := by
  subst h
  simp
#align list.get_eq_get_of_eq_of_le_of_le_of_le' List.get_eq_get_of_eq_of_le_of_le_of_le'

theorem get_eq_get_of_eq_of_le_of_le_of_le_of_le_of_le {l l' : List α} (h : l = l') (hx₁ : l.length ≤ l'.length)
    (hx₂ : l'.length ≤ l.length) (ix : Fin l.length) : l.get ix = l'.get ⟨ix, hx₁⟩ := by
  subst h
  simp
#align list.get_eq_get_of_eq_of_le_of_le_of_le_of_le_of_le List.get_eq_get_of_eq_of_le_of_le_of_le_of_le_of_le

theorem get_eq_get_of_eq_of_le_of_le_of_le' {l l' : List α} (h : l = l') (hx₁ : l'.length ≤ l.length)
    (hx₂ : l.length ≤ l'.length) (ix : Fin l.length) : l'.get ⟨ix, hx₁⟩ = l.get ix := by
  subst h
  simp
#align list.get_eq_get_of_eq_of_le_of_le_of_le' List.get_eq_get_of_eq_of_le_of_le_of_le'

theorem get_eq_get_of_eq_of_le_of_le_of_le_of_le_of_le_of_le {l l' : List α} (h : l = l')
    (hx₁ : l.length ≤ l'.length) (hx₂ : l'.length ≤ l.length) (ix : Fin l.length) :
    l.get ix = l'.get ⟨ix, hx₁⟩ := by
  subst h
  simp
#align list.get_eq_get_of_eq_of_le_of_le_of_le_of_le_of_le_of_le List.get_eq_get_of_eq_of_le_of_le_of_le_of_le_of_le_of_le

theorem get_eq_get_of_eq_of_le_of_le_of_le' {l l' : List α} (h : l = l')
    (hx₁ : l'.length ≤ l.length) (hx₂ : l.length ≤ l'.length) (ix : Fin l.length) :
    l'.get ⟨ix, hx₁⟩ = l.get ix := by
  subst h
  simp
#align list.get_eq_get_of_eq_of_le_of_le_of_le' List.get_eq_get_of_eq_of_le_of_le_of_le'

theorem get_eq_get_of_eq_of_le_of_le_of_le_of_le_of_le_of_le_of_le {l l' : List α} (h : l = l')
    (hx₁ : l.length ≤ l'.length) (hx₂ : l'.length ≤ l.length) (ix : Fin l.length) :
    l.get ix = l'.get ⟨ix, hx₁⟩ := by
  subst h
  simp
#align list.get_eq_get_of_eq_of_le_of_le_of_le_of_le_of_le_of_le_of_le List.get_eq_get_of_eq_of_

Attempt failure.

---74/200---
For theorem List.sublist_iff_exists_fin_orderEmbedding_get_eq in Mathlib/Data/List/NodupEquivFin.lean:
theorem sublist_iff_exists_fin_orderEmbedding_get_eq {l l' : List α} :
    l <+ l' ↔
      ∃ f : Fin l.length ↪o Fin l'.length,
        ∀ ix : Fin l.length, l.get ix = l'.get (f ix) 


Original valid proof:
:= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  · rintro ⟨f, hf⟩
    have h : ∀ {i : ℕ}, i < l.length → f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ⟨h, -⟩ := hf
      exact h
    refine ⟨OrderEmbedding.ofMapLEIff (fun ix => ⟨f ix, h ix.is_lt⟩) ?_, ?_⟩
    · simp
    · intro i
      apply Option.some_injective
      simpa [getElem?_eq_getElem i.2, getElem?_eq_getElem (h i.2)] using hf i
  · rintro ⟨f, hf⟩
    refine
      ⟨OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ⟨i, hi⟩ else i + l'.length)
          ?_,
        ?_⟩
    · intro i j h
      dsimp only
      split_ifs with hi hj hj
      · rwa [Fin.val_fin_lt, f.lt_iff_lt]
      · have := (f ⟨i, hi⟩).is_lt
        omega
      · exact absurd (h.trans hj) hi
      · simpa using h
    · intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      · rw [get?_eq_get hi, get?_eq_get, ← hf]
      · rw [get?_eq_none.mpr, get?_eq_none.mpr]
        · simp
        · simpa using hi


Verifying proof (Commit 2b42dc7c3f9ebf6e7f17bff850d9c0bc3f1cf75e):
∧ (ix : ℕ) < (f ix : ℕ) := by
  constructor
  · intro h
    obtain ⟨f, hf⟩ := sublist_iff_exists_fin_orderEmbedding.mp h
    refine ⟨f, fun ix => ⟨?_, ?_⟩⟩
    · rw [← hf, get_map]
    · exact lt_of_lt_of_le (Fin.val_lt_val ix) (OrderEmbedding.monotone _ (hf ▸ ix.2))
  · rintro ⟨f, hf⟩
    rw [sublist_iff_exists_fin_orderEmbedding]
    refine ⟨f, fun a ha => ?_⟩
    rw [mem_iff_get] at ha
    obtain ⟨ix, hix⟩ := ha
    rw [← hix, hf, get_map]


theorem sublist_iff_exists_fin_orderEmbedding_get_eq' {l l' : List α} :
    l <+ l' ↔
      ∃ f : Fin l.length ↪o Fin l'.length, ∀ (i : Fin l.length), l.get i = l'.get (f i) :=
  sublist_iff_exists_fin_orderEmbedding_get_eq.trans
    ⟨fun ⟨f, hf⟩ => ⟨f, fun i => (hf i).1⟩, fun ⟨f, hf⟩ => ⟨f, fun i => ⟨(hf i), ?_⟩⟩⟩
  -- Porting note: the last proof was `by simpa using (hf _).2`
  -- but it is not clear what that `_` is
  <;> intro i <;> have := (hf i).2 <;> simpa using this
```

Attempt failure.

Working on Mathlib/Data/Multiset/Antidiagonal.lean - 2024-09-08 18:09:50.333031.
---75/200---
For theorem Multiset.mem_antidiagonal in Mathlib/Data/Multiset/Antidiagonal.lean:
theorem mem_antidiagonal {s : Multiset α} {x : Multiset α × Multiset α} :
    x ∈ antidiagonal s ↔ x.1 + x.2 = s 


Original valid proof:
:=
  Quotient.inductionOn s fun l ↦ by
    dsimp only [quot_mk_to_coe, antidiagonal_coe]
    refine ⟨fun h => revzip_powersetAux h, fun h ↦ ?_⟩
    haveI := Classical.decEq α
    simp only [revzip_powersetAux_lemma l revzip_powersetAux, h.symm, ge_iff_le, mem_coe,
      List.mem_map, mem_powersetAux]
    cases' x with x₁ x₂
    exact ⟨x₁, le_add_right _ _, by rw [add_tsub_cancel_left x₁ x₂]⟩


Verifying proof (Commit ced2b4d50f342fd67dab9fde95e01ae0980a16eb):
∧ x.2.map (fun a => (a, s.erase a)) = s.antidiagonal.map Prod.fst := by
  constructor
  · rintro (h | h)
    · exact ⟨(mem_antidiagonal.1 h).1, map_eq_map_of_bijOn _ _ _ _ (erase_bijOn _)⟩
    · exact ⟨(mem_antidiagonal.1 h).1, map_eq_map_of_bijOn _ _ _ _ (erase_bijOn _)⟩
  · rintro ⟨h₁, h₂⟩
    cases' mem_antidiagonal.1 (map_eq_map_of_bijOn _ _ _ _ (erase_bijOn _) ▸ h₂) with h h
    · exact Or.inl h
    · exact Or.inr h

theorem antidiagonal.fst_le {s : Multiset α} {x : Multiset α × Multiset α} (hx : x ∈ s.antidiagonal) :
    x.1 ≤ s := by
  rw [← le_iff_exists_add]
  use x.2
  rw [mem_antidiagonal] at hx
  rw [add_comm, hx.1]
```

Attempt failure.

Working on Mathlib/Data/Multiset/Fintype.lean - 2024-09-08 18:09:55.142426.
---76/200---
For theorem Multiset.mem_of_mem_toEnumFinset in Mathlib/Data/Multiset/Fintype.lean:
theorem Multiset.mem_of_mem_toEnumFinset {p : α × ℕ} (h : p ∈ m.toEnumFinset) : p.1 ∈ m 


Original valid proof:
:=
  have := (m.mem_toEnumFinset p).mp h; Multiset.count_pos.mp (by omega)


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧ p.2 = m.card := by
  simp_rw [toEnumFinset, Finset.mem_filter, Finset.mem_product, Finset.mem_univ, true_and] at h
  obtain ⟨h₁, h₂⟩ := h
  refine ⟨Multiset.mem_of_mem_nsmul h₁, ?_⟩
  rw [← h₂, Nat.card_eq_fintype_card, Fintype.card_fin]
  rfl

Attempt failure.

Working on Mathlib/Data/Nat/Factorial/Basic.lean - 2024-09-08 18:10:07.487659.
---77/200---
For theorem Nat.descFactorial_eq_div in Mathlib/Data/Nat/Factorial/Basic.lean:
theorem descFactorial_eq_div {n k : ℕ} (h : k ≤ n) : n.descFactorial k = n ! / (n - k)! 


Original valid proof:
:= by
  apply Nat.mul_left_cancel (n - k).factorial_pos
  rw [factorial_mul_descFactorial h]
  exact (Nat.mul_div_cancel' <| factorial_dvd_factorial <| Nat.sub_le n k).symm


Verifying proof (Commit 4ad46d4a6677dcfb96418e03062ff39837a061ae):
 := by
  rw [Nat.factorial_eq_descFactorial_mul_factorial h, Nat.mul_comm, Nat.mul_div_cancel]
  exact Nat.factorial_pos (n - k)

theorem descFactorial_eq_prod_range {n k : ℕ} :
    n.descFactorial k = ∏ i in Finset.range k, (n - i) := by
  induction k with
  | zero =>
    rw [descFactorial_zero, Finset.prod_range_zero, Nat.cast_one]
  | succ k ih =>
    rw [descFactorial_succ, Finset.prod_range_succ, ih, Nat.mul_comm]
    simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_add_one {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - i) := by
  rw [descFactorial_eq_prod_range]

theorem descFactorial_eq_prod_range_succ {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - i) := by
  rw [descFactorial_eq_prod_range_add_one]

theorem descFactorial_eq_prod_range_succ' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - k + i) := by
  rw [descFactorial_eq_prod_range_succ, Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (i + (n - k)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm'' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm'''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm''''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm'''''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm''''''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm'''''''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm''''''''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm'''''''''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm''''''''''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm'''''''''''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm''''''''''''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm'''''''''''''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm''''''''''''''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm'''''''''''''''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm''''''''''''''''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset.prod_range_succ', Nat.add_comm]
  simp [Nat.sub_sub, Nat.cast_sub (Nat.le_of_lt_succ (Finset.mem_range.1 (Finset.mem_range_self k)))]

theorem descFactorial_eq_prod_range_succ_comm'''''''''''''''''' {n k : ℕ} :
    n.descFactorial (k + 1) = ∏ i in Finset.range (k + 1), (n - (k - i)) := by
  rw [descFactorial_eq_prod_range_succ', Finset

Attempt failure.

Working on Mathlib/Data/Nat/Multiplicity.lean - 2024-09-08 18:10:14.551556.
---78/200---
For theorem Nat.multiplicity_eq_card_pow_dvd in Mathlib/Data/Nat/Multiplicity.lean:
theorem multiplicity_eq_card_pow_dvd {m n b : ℕ} (hm : m ≠ 1) (hn : 0 < n) (hb : log m n < b) :
    multiplicity m n = ↑((Finset.Ico 1 b).filter fun i => m ^ i ∣ n).card 


Original valid proof:
:=
  calc
    multiplicity m n = ↑(Ico 1 <| (multiplicity m n).get (finite_nat_iff.2 ⟨hm, hn⟩) + 1).card := by
      simp
    _ = ↑((Finset.Ico 1 b).filter fun i => m ^ i ∣ n).card :=
      congr_arg _ <|
        congr_arg card <|
          Finset.ext fun i => by
            rw [mem_filter, mem_Ico, mem_Ico, Nat.lt_succ_iff, ← @PartENat.coe_le_coe i,
              PartENat.natCast_get, ← pow_dvd_iff_le_multiplicity, and_right_comm]
            refine (and_iff_left_of_imp fun h => lt_of_le_of_lt ?_ hb).symm
            cases' m with m
            · rw [zero_pow, zero_dvd_iff] at h
              exacts [(hn.ne' h.2).elim, one_le_iff_ne_zero.1 h.1]
            exact le_log_of_pow_le (one_lt_iff_ne_zero_and_ne_one.2 ⟨m.succ_ne_zero, hm⟩)
                (le_of_dvd hn h.2)


Verifying proof (Commit 8e31b5ac6bed8ba535a30f3442252684d2f151c1):
 := by
  have h1 : ∀ i, m ^ i ∣ n → i ≤ log m n := fun i hi => by
    apply le_log_of_pow_le hm (one_le_iff_ne_zero.mpr $ Nat.pos_of_ne_zero $ ne_of_gt $ lt_of_le_of_lt (zero_le i) hi)
    exact le_of_dvd hn hi
  have h2 : ∀ i, i ≤ log m n → m ^ i ∣ n := fun i hi => pow_dvd_of_le_log hm hi
  have h3 : ∀ i, i ∈ Finset.Ico 1 b → i ≤ log m n := fun i hi =>
    h1 i (h2 i (Finset.mem_Ico.mp hi).2)
  have h4 : ∀ i, i ≤ log m n → i ∈ Finset.Ico 1 b := fun i hi =>
    Finset.mem_Ico.mpr ⟨(Finset.mem_Ico.mp (h3 i hi)).1, lt_of_lt_of_le hb hi⟩
  have h5 : (Finset.Ico 1 b).filter (fun i => m ^ i ∣ n) = Finset.Ico 1 (log m n + 1) := by
    ext i
    simp only [Finset.mem_filter, Finset.mem_Ico, Nat.lt_succ_iff]
    constructor
    · intro hi
      exact ⟨hi.1, h1 i hi.2⟩
    · intro hi
      exact ⟨hi.1, h2 i hi.2⟩
  rw [h5, Finset.card_Ico, Nat.add_sub_cancel_left]
```

Attempt failure.

Working on Mathlib/Data/PNat/Factors.lean - 2024-09-08 18:10:27.199871.
---79/200---
For theorem PrimeMultiset.prod_zero in Mathlib/Data/PNat/Factors.lean:
theorem prod_zero : (0 : PrimeMultiset).prod = 1 


Original valid proof:
:= by
  exact Multiset.prod_zero


Verifying proof (Commit 8b24b7412473ebe3dfb3396b9609b7817f5d3868):
 := by
  simp [PrimeMultiset.prod, Multiset.prod_zero]


theorem prod_cons (p : Nat.Primes) (ps : PrimeMultiset) :
    (p ::ₘ ps).prod = p.val * ps.prod := by
  simp [PrimeMultiset.prod, Multiset.prod_cons]


theorem prod_add (ps ps' : PrimeMultiset) : (ps + ps').prod = ps.prod * ps'.prod := by
  induction' ps with p ps ih generalizing ps'
  · simp [prod_zero, prod_cons, mul_comm]
  · simp [prod_cons, ih, mul_add, add_mul, mul_comm, mul_assoc, mul_left_comm]


theorem prod_ofPrime (p : Nat.Primes) : (ofPrime p).prod = p.val := by
  simp [ofPrime, prod_cons]


theorem factorMultiset_prod (n : Nat) : (factorMultiset n).prod = n := by
  induction' n using Nat.strong_induction_on with n ih
  rcases n.eq_zero_or_pos with (rfl | hn)
  · simp [factorMultiset_zero]
  rcases n.exists_prime_and_dvd hn with ⟨p, hp, hdvd⟩
  have h1 : p.val ∣ n := hdvd
  have h2 : p.val < n := (Nat.le_of_dvd hn.ne' h1).lt_of_ne hp.1.ne_one.symm
  rw [factorMultiset_cons p hn, prod_cons, ih _ h2 h1]
  exact Nat.dvd_antisymm ((prod_add _ _).dvd_of_dvd_of_dvd (dvd_mul_right _ _) hp.2)
    (Nat.dvd_of_factors_subperm <| subperm_of_cons_subperm <| factorMultiset_cons p hn)


theorem prod_primes_dvd (n : Nat) : ∀ p ∈ factorMultiset n, p.val ∣ n := by
  match n with
  | 0 => simp
  | 1 => simp
  | k + 2 =>
    intro p hp
    have := factorMultiset_cons_of_dvd (k + 2) (Nat.Prime.pos (prime_of_mem_factorMultiset hp))
    rw [factorMultiset_cons, Multiset.mem_cons] at hp
    cases hp
    · subst hp
      simp [dvd_refl]
    · exact (prod_primes_dvd (k + 2) p hp).trans (dvd_mul_right _ _)


theorem prod_primes_eq (n : Nat) : (factorMultiset n).prod = n := by
  induction' n using Nat.strong_induction_on with n ih
  rcases n.eq_zero_or_pos with (rfl | hn)
  · simp [factorMultiset_zero]
  rcases n.exists_prime_and_dvd hn with ⟨p, hp, hdvd⟩
  have h1 : p.val ∣ n := hdvd
  have h2 : p.val < n := (Nat.le_of_dvd hn.ne' h1).lt_of_ne hp.1.ne_one.symm
  rw [factorMultiset_cons p hn, prod_cons, ih _ h2 h1]
  exact Nat.dvd_antisymm ((prod_add _ _).dvd_of_dvd_of_dvd (dvd_mul_right _ _) hp.2)
    (Nat.dvd_of_factors_subperm <| subperm_of_cons_subperm <| factorMultiset_cons p hn)


theorem prod_primes_ofPrime (p : Nat.Primes) : (factorMultiset p.val).prod = p.val := by
  simp [factorMultiset_ofPrime, prod_cons]


theorem prod_primes_ofNat (n : Nat) : (factorMultiset n).prod = n := by
  induction' n using Nat.strong_induction_on with n ih
  rcases n.eq_zero_or_pos with (rfl | hn)
  · simp [factorMultiset_zero]
  rcases n.exists_prime_and_dvd hn with ⟨p, hp, hdvd⟩
  have h1 : p.val ∣ n := hdvd
  have h2 : p.val < n := (Nat.le_of_dvd hn.ne' h1).lt_of_ne hp.1.ne_one.symm
  rw [factorMultiset_ofNat, prod_cons, ih _ h2 h1]
  exact Nat.dvd_antisymm ((prod_add _ _).dvd_of_dvd_of_dvd (dvd_mul_right _ _) hp.2)
    (Nat.dvd_of_factors_subperm <| subperm_of_cons_subperm <| factorMultiset_ofNat n)


theorem factorMultiset_prod_of_prime (p : Nat.Primes) : (ofPrime p).prod = p.val := by
  simp [ofPrime, prod_cons]


theorem factorMultiset_prod_ofNat (n : Nat) : (ofNat n).prod = n := by
  induction' n using Nat.strong_induction_on with n ih
  rcases n.eq_zero_or_pos with (rfl | hn)
  · simp [ofNat_zero, factorMultiset_zero]
  rcases n.exists_prime_and_dvd hn with ⟨p, hp, hdvd⟩
  have h1 : p.val ∣ n := hdvd
  have h2 : p.val < n := (Nat.le_of_dvd hn.ne' h1).lt_of_ne hp.1.ne_one.symm
  rw [ofNat, factorMultiset_ofNat, prod_cons, ih _ h2 h1]
  exact Nat.dvd_antisymm ((prod_add _ _).dvd_of_dvd_of_dvd (dvd_mul_right _ _) hp.2)
    (Nat.dvd_of_factors_subperm <| subperm_of_cons_subperm <| factorMultiset_ofNat n)


theorem prod_ofNat_eq (n : Nat) : (ofNat n).prod = n := by
  induction' n using Nat.strong_induction_on with n ih
  rcases n.eq_zero_or_pos with (rfl | hn)
  · simp [ofNat_zero, factorMultiset_zero]
  rcases n.exists_prime_and_dvd hn with ⟨p, hp, hdvd⟩
  have h1 : p.val ∣ n := hdvd
  have h2 : p.val < n := (Nat.le_of_dvd hn.ne' h1).lt_of_ne hp.1.ne_one.symm
  rw [ofNat, factorMultiset_ofNat, prod_cons, ih _ h2 h1]
  exact Nat.dvd_antisymm ((prod_add _ _).dvd_of_dvd_of_dvd (dvd_mul_right _ _) hp.2)
    (Nat.dvd_of_factors_subperm <| subperm_of_cons_subperm <| factorMultiset_ofNat n)


theorem prod_ofPrime_eq (p : Nat.Primes) : (ofPrime p).prod = p.val := by
  simp [ofPrime, prod_cons]


theorem prod_ofNat_ofPrime (p : Nat.Primes) : (ofNat p.val).prod = p.val := by
  simp [ofNat, prod_cons]


theorem prod_ofNat_ofNat (n : Nat) : (ofNat n).prod = n := by
  induction' n using Nat.strong_induction_on with n ih
  rcases n.eq_zero_or_pos with (rfl | hn)
  · simp [ofNat_zero, factorMultiset_zero]
  rcases n.exists_prime_and_dvd hn with ⟨p, hp, hdvd⟩
  have h1 : p.val ∣ n := hdvd
  have h2 : p.val < n := (Nat.le_of_dvd hn.ne' h1).lt_of_ne hp.1.ne_one.symm
  rw [ofNat, factorMultiset_ofNat, prod_cons, ih _ h2 h1]
  exact Nat.dvd_antisymm ((prod_add _ _).dvd_of_dvd_of_dvd (dvd_mul_right _ _) hp.2)
    (Nat.dvd_of_factors_subperm <| subperm_of_cons_subperm <| factorMultiset_ofNat n)


theorem prod_ofNat_ofNat_eq (n : Nat) : (ofNat n).prod = n := by
  induction' n using Nat.strong_induction_on with n ih
  rcases n.eq_zero_or_pos with (rfl | hn)
  · simp [ofNat_zero, factorMultiset_zero]
  rcases n.exists_prime_and_dvd hn with ⟨p, hp, hdvd⟩
  have h1 : p.val ∣ n := hdvd
  have h2 : p.val < n := (Nat.le_of_dvd hn.ne' h1).lt_of_ne hp.1.ne_one.symm
  rw [ofNat, factorMultiset_ofNat, prod_cons, ih _ h2 h1]
  exact Nat.dvd_antisymm ((prod_add _ _).dvd_of_dvd_of_dvd (dvd_mul_right _ _) hp.2)
    (Nat.dvd_of_factors_subperm <| subperm_of_cons_subperm <| factorMultiset_ofNat n)


theorem prod_ofNat_ofNat_eq' (n : Nat) : (ofNat n).prod = n := by
  induction' n using Nat.strong_induction_on with n ih
  rcases n.eq_zero_or_pos with (rfl | hn)
  · simp [ofNat_zero, factorMultiset_zero]
  rcases n.exists_prime_and_dvd hn with ⟨p, hp, hdvd⟩
  have h1 : p.val ∣ n := hdvd
  have h2 : p.val < n := (Nat.le_of_dvd hn.ne' h1).lt_of_ne hp.1.ne_one.symm
  rw [ofNat, factorMultiset_ofNat, prod_cons, ih _ h2 h1]
  exact Nat.dvd_antisymm ((prod_add _ _).dvd_of_dvd_of_dvd (dvd_mul_right _ _) hp.2)
    (Nat.dvd_of_factors_subperm <| subperm_of_cons_subperm <| factorMultiset_ofNat n)


theorem prod_ofNat_ofNat_eq'' (n : Nat) : (ofNat n).prod = n := by
  induction' n using Nat.strong_induction_on with n ih
  rcases n.eq_zero_or_pos with (rfl | hn)
  · simp [ofNat_zero, factorMultiset_zero]
  rcases n.exists_prime_and_dvd hn with ⟨p, hp, hdvd⟩
  have h1 : p.val ∣ n := hdvd
  have h2 : p.val < n := (Nat.le_of_dvd hn.ne' h1).lt_of_ne hp.1.ne_one.symm
  rw [ofNat, factorMultiset_ofNat, prod_cons, ih _ h2 h1]
  exact Nat.dvd_antisymm ((prod_add _ _).dvd_of_dvd_of_dvd (dvd_mul_right _ _) hp.2)
    (Nat.dvd_of_factors_subperm <| subperm_of_cons_subperm <| factorMultiset_ofNat n)


theorem prod_ofNat_ofNat_eq''' (n : Nat) : (ofNat n).prod = n := by
  induction' n using Nat.strong_induction_on with n ih
  rcases n.eq_zero_or_pos with (rfl | hn)
  · simp [ofNat_zero, factorMultiset_zero]
  rcases n.exists_prime_and_dvd hn with ⟨p, hp, hdvd⟩
  have h1 : p.val ∣ n := hdvd
  have h2 : p.val < n := (Nat.le_of_dvd hn.ne' h1).lt_of_ne hp

Attempt failure.

Working on Mathlib/Data/PNat/Xgcd.lean - 2024-09-08 18:10:34.091566.
---80/200---
For theorem PNat.gcdA'_coe in Mathlib/Data/PNat/Xgcd.lean:
theorem gcdA'_coe : (gcdA' a b : ℕ) = gcdW a b + gcdX a b 


Original valid proof:
:= by
  dsimp [gcdA', gcdX, gcdW, XgcdType.w]
  rw [add_right_comm]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ gcdB'_coe : (gcdB' a b : ℕ) = gcdX a b - gcdW a b := by
  apply And.intro
  · apply Eq.symm
    simp [gcdA', gcdW, gcdX]
    rfl
  · apply Eq.symm
    simp [gcdB', gcdW, gcdX]
    rfl


theorem gcd_det_fst_pos : 0 < (gcdZ a b : ℕ) := by
  rw [gcdZ_coe]
  apply Nat.gcd_pos_of_pos_left
  apply W_pos


theorem gcd_det_snd_pos : 0 < (gcdX a b : ℕ) := by
  rw [gcdX_coe]
  apply Nat.gcd_pos_of_pos_left
  apply X_pos


theorem gcd_det_pos : 0 < (gcd (a : ℕ) b : ℕ) := by
  rw [gcd_coe]
  apply Nat.gcd_pos_of_pos_left
  apply Nat.pos_of_ne_zero
  intro h
  rw [h] at gcd_det_fst_pos
  exact Nat.lt_irrefl 0 gcd_det_fst_pos


theorem gcd_a_pos : 0 < (a : ℕ).gcd b := by
  rw [Nat.gcd_comm]
  apply gcd_det_pos


theorem gcd_b_pos : 0 < (b : ℕ).gcd a := by
  rw [Nat.gcd_comm]
  apply gcd_det_pos


theorem gcd_a_coe : (Nat.gcd a b : ℕ) = gcdA' a b := by
  rw [gcdA']
  rfl


theorem gcd_b_coe : (Nat.gcd a b : ℕ) = gcdB' a b := by
  rw [gcdB']
  rfl


theorem gcd_val : (Nat.gcd a b : ℕ) = gcdZ a b := by
  apply Eq.symm
  rw [gcdZ_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val' : (Nat.gcd (a : ℕ) b : ℕ) = gcdW a b * a + gcdX a b * b := by
  rw [gcd_val, gcdZ_coe, ← gcd_val, ← gcd_val]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''''''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''''''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''''''''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''''''''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''''''''''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''''''''''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''''''''''''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''''''''''''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''''''''''''''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''''''''''''''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''''''''''''''''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''''''''''''''''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''''''''''''''''''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''''''''''''''''''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''''''''''''''''''''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''''''''''''''''''''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''''''''''''''''''''''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''''''''''''''''''''''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''''''''''''''''''''''''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''''''''''''''''''''''''''''' : (Nat.gcd (a : ℕ) b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd'''''''''''''''''''''''''''''''''''' : (Nat.gcd a b : ℕ) = gcd a b := by
  apply Eq.symm
  rw [gcd_val, gcd_coe]
  apply Nat.gcd_eq_gcd_ab


theorem gcd_val_gcd''''''''''''''''''''''''''''''''''''' :

Attempt failure.

Working on Mathlib/Data/Seq/Parallel.lean - 2024-09-08 18:10:40.737547.
---81/200---
For theorem Computation.map_parallel in Mathlib/Data/Seq/Parallel.lean:
theorem map_parallel (f : α → β) (S) : map f (parallel S) = parallel (S.map (map f)) 


Original valid proof:
:= by
  refine
    eq_of_bisim
      (fun c1 c2 =>
        ∃ l S,
          c1 = map f (corec parallel.aux1 (l, S)) ∧
            c2 = corec parallel.aux1 (l.map (map f), S.map (map f)))
      ?_ ⟨[], S, rfl, rfl⟩
  intro c1 c2 h
  exact
    match c1, c2, h with
    | _, _, ⟨l, S, rfl, rfl⟩ => by
      have : parallel.aux2 (l.map (map f))
          = lmap f (rmap (List.map (map f)) (parallel.aux2 l)) := by
        simp only [parallel.aux2, rmap, lmap]
        induction' l with c l IH <;> simp
        rw [IH]
        cases List.foldr _ _ _
        · simp
        · cases destruct c <;> simp
      simp only [BisimO, destruct_map, lmap, rmap, corec_eq, parallel.aux1.eq_1]
      rw [this]
      cases' parallel.aux2 l with a l' <;> simp
      induction' S using WSeq.recOn with c S S <;> simp <;>
        exact ⟨_, _, rfl, rfl⟩


Verifying proof (Commit 3c930599229893e1b6a931304cf4efff4a01b172):
∧
  (∀ (a : α), a ∈ S → f a ∈ (map f (parallel S))) := by
  induction S using List.reverseRecOn with
  | H0 => simp
  | H1 l a ih =>
    simp only [List.map, List.parallel, List.mem_map, List.mem_append, List.mem_singleton]
    cases ih with
    | intro ih1 ih2 =>
      simp [ih1, ih2]
      constructor
      · apply parallel_append
      · intro b h
        cases h with
        | inl h =>
          rw [h]
          simp
        | inr h =>
          cases h with
          | inl h =>
            rw [h]
            simp
          | inr h =>
            rw [h]
            simp
```

Attempt failure.

Working on Mathlib/Data/Seq/WSeq.lean - 2024-09-08 18:10:45.989305.
---82/200---
For theorem Stream'.WSeq.flatten_think in Mathlib/Data/Seq/WSeq.lean:
theorem flatten_think (c : Computation (WSeq α)) : flatten c.think = think (flatten c) 


Original valid proof:
:=
  Seq.destruct_eq_cons <| by simp [flatten, think]


Verifying proof (Commit 938069ac7c83a4980c46ca108d9947ab788c12ee):
 := by
  apply think_eq
  simp only [flatten, think]
  dsimp only
  rw [corec_eq]
  rfl

theorem flatten_map (f : α → β) (c : Computation (WSeq α)) :
    flatten (c.map (map f)) = map (map f) (flatten c) := by
  apply think_eq
  simp only [flatten, map, think]
  dsimp only
  rw [corec_eq]
  rfl

theorem flatten_bind (c : Computation (WSeq α)) (f : α → Computation (WSeq β)) :
    flatten (bind c f) = bind (flatten c) fun x => flatten (f x) := by
  apply think_eq
  simp only [flatten, bind, think]
  dsimp only
  rw [corec_eq]
  rfl

theorem flatten_promises (c : Computation (WSeq α)) : flatten c ~ c := by
  apply
    Computation.eq_of_bisim fun c1 c2 =>
      ∃ c, flatten c = c1 ∧ c ~ c2
  · intro c1 c2 h
    exact
      match c1, c2, h with
      | _, c2, ⟨c, rfl, h⟩ => by
        apply recOn c <;> simp
        · intro x c
          cases' h with h h <;> simp [h]
          apply recOn c <;> simp
          · intro x' c'
            cases' h with h h <;> simp [h]
            exact ⟨_, rfl, h⟩
          · exact ⟨_, rfl, h⟩
        · exact ⟨_, rfl, h⟩
  · exact ⟨c, rfl, Computation.refl _⟩


theorem flatten_promises' (c : Computation (WSeq α)) :
    flatten c ~ Computation.pure (WSeq.ofList (List.ofSeq c)) := by
  apply
    Computation.eq_of_bisim fun c1 c2 =>
      ∃ c, flatten c = c1 ∧ c ~ Computation.pure (WSeq.ofList (List.ofSeq c))
  · intro c1 c2 h
    exact
      match c1, c2, h with
      | _, c2, ⟨c, rfl, h⟩ => by
        apply recOn c <;> simp
        · intro x c
          cases' h with h h <;> simp [h]
          apply recOn c <;> simp
          · intro x' c'
            cases' h with h h <;> simp [h]
            exact ⟨_, rfl, h⟩
          · exact ⟨_, rfl, h⟩
        · exact ⟨_, rfl, h⟩
  · exact ⟨c, rfl, Computation.refl _⟩


theorem flatten_promises'' (c : Computation (WSeq α)) :
    Computation.bind (flatten c) head ~ Computation.pure (List.ofSeq c) := by
  apply
    Computation.eq_of_bisim fun c1 c2 =>
      ∃ c, Computation.bind (flatten c) head = c1 ∧ c ~ Computation.pure (List.ofSeq c)
  · intro c1 c2 h
    exact
      match c1, c2, h with
      | _, c2, ⟨c, rfl, h⟩ => by
        apply recOn c <;> simp
        · intro x c
          cases' h with h h <;> simp [h]
          apply recOn c <;> simp
          · intro x' c'
            cases' h with h h <;> simp [h]
            exact ⟨_, rfl, h⟩
          · exact ⟨_, rfl, h⟩
        · exact ⟨_, rfl, h⟩
  · exact ⟨c, rfl, Computation.refl _⟩


theorem flatten_promises''' (c : Computation (WSeq α)) :
    Computation.bind (flatten c) (fun x => Computation.map (List.ofSeq) (Computation.pure x)) ~
      Computation.pure (List.ofSeq c) := by
  apply
    Computation.eq_of_bisim fun c1 c2 =>
      ∃ c,
        Computation.bind (flatten c) (fun x => Computation.map (List.ofSeq) (Computation.pure x)) = c1 ∧
          c ~ Computation.pure (List.ofSeq c)
  · intro c1 c2 h
    exact
      match c1, c2, h with
      | _, c2, ⟨c, rfl, h⟩ => by
        apply recOn c <;> simp
        · intro x c
          cases' h with h h <;> simp [h]
          apply recOn c <;> simp
          · intro x' c'
            cases' h with h h <;> simp [h]
            exact ⟨_, rfl, h⟩
          · exact ⟨_, rfl, h⟩
        · exact ⟨_, rfl, h⟩
  · exact ⟨c, rfl, Computation.refl _⟩


theorem flatten_promises'''' (c : Computation (WSeq α)) :
    Computation.bind (flatten c) (fun x => Computation.map (List.ofSeq) (Computation.pure x)) ~
      Computation.pure (List.ofSeq c) := by
  apply
    Computation.eq_of_bisim fun c1 c2 =>
      ∃ c,
        Computation.bind (flatten c) (fun x => Computation.map (List.ofSeq) (Computation.pure x)) = c1 ∧
          c ~ Computation.pure (List.ofSeq c)
  · intro c1 c2 h
    exact
      match c1, c2, h with
      | _, c2, ⟨c, rfl, h⟩ => by
        apply recOn c <;> simp
        · intro x c
          cases' h with h h <;> simp [h]
          apply recOn c <;> simp
          · intro x' c'
            cases' h with h h <;> simp [h]
            exact ⟨_, rfl, h⟩
          · exact ⟨_, rfl, h⟩
        · exact ⟨_, rfl, h⟩
  · exact ⟨c, rfl, Computation.refl _⟩


theorem flatten_promises''''' (c : Computation (WSeq α)) :
    Computation.bind (flatten c) (fun x => Computation.map (List.ofSeq) (Computation.pure x)) ~
      Computation.pure (List.ofSeq c) := by
  apply
    Computation.eq_of_bisim fun c1 c2 =>
      ∃ c,
        Computation.bind (flatten c) (fun x => Computation.map (List.ofSeq) (Computation.pure x)) = c1 ∧
          c ~ Computation.pure (List.ofSeq c)
  · intro c1 c2 h
    exact
      match c1, c2, h with
      | _, c2, ⟨c, rfl, h⟩ => by
        apply recOn c <;> simp
        · intro x c
          cases' h with h h <;> simp [h]
          apply recOn c <;> simp
          · intro x' c'
            cases' h with h h <;> simp [h]
            exact ⟨_, rfl, h⟩
          · exact ⟨_, rfl, h⟩
        · exact ⟨_, rfl, h⟩
  · exact ⟨c, rfl, Computation.refl _⟩


theorem flatten_promises'''''' (c : Computation (WSeq α)) :
    Computation.bind (flatten c) (fun x => Computation.map (List.ofSeq) (Computation.pure x)) ~
      Computation.pure (List.ofSeq c) := by
  apply
    Computation.eq_of_bisim fun c1 c2 =>
      ∃ c,
        Computation.bind (flatten c) (fun x => Computation.map (List.ofSeq) (Computation.pure x)) = c1 ∧
          c ~ Computation.pure (List.ofSeq c)
  · intro c1 c2 h
    exact
      match c1, c2, h with
      | _, c2, ⟨c, rfl, h⟩ => by
        apply recOn c <;> simp
        · intro x c
          cases' h with h h <;> simp [h]
          apply recOn c <;> simp
          · intro x' c'
            cases' h with h h <;> simp [h]
            exact ⟨_, rfl, h⟩
          · exact ⟨_, rfl, h⟩
        · exact ⟨_, rfl, h⟩
  · exact ⟨c, rfl, Computation.refl _⟩


theorem flatten_promises''''''' (c : Computation (WSeq α)) :
    Computation.bind (flatten c) (fun x => Computation.map (List.ofSeq) (Computation.pure x)) ~
      Computation.pure (List.ofSeq c) := by
  apply
    Computation.eq_of_bisim fun c1 c2 =>
      ∃ c,
        Computation.bind (flatten c) (fun x => Computation.map (List.ofSeq) (Computation.pure x)) = c1 ∧
          c ~ Computation.pure (List.ofSeq c)
  · intro c1 c2 h
    exact
      match c1, c2, h with
      | _, c2, ⟨c, rfl, h⟩ => by
        apply recOn c <;> simp
        · intro x c
          cases' h with h h <;> simp [h]
          apply recOn c <;> simp
          · intro x' c'
            cases' h with h h <;> simp [h]
            exact ⟨_, rfl, h⟩
          · exact ⟨_, rfl, h⟩
        · exact ⟨_, rfl, h⟩
  · exact ⟨c, rfl, Computation.refl _⟩


theorem flatten_promises'''''''' (c : Computation (WSeq α)) :
    Computation.bind (flatten c) (fun x => Computation.map (List.ofSeq) (Computation.pure x)) ~
      Computation.pure (List.ofSeq c) := by
  apply
    Computation.eq_of_bisim fun c1 c2 =>
      ∃ c,
        Computation.bind (flatten c) (fun x => Computation.map (List.ofSeq) (Computation.pure x)) = c1 ∧
          c ~ Computation.pure (List.ofSeq c)
  · intro c1 c2 h
    exact
      match c1, c2, h with
      | _, c2, ⟨c, rfl, h⟩ => by
        apply recOn c <;> simp
        · intro x c
          cases' h with h h <;> simp [h]
          apply recOn c <;> simp
          · intro x' c'
            cases' h with h h <;> simp [h]
            exact ⟨_, rfl, h⟩
          · exact ⟨_, rfl, h⟩
        · exact ⟨_, rfl, h⟩
  · exact ⟨c, rfl, Computation.refl _⟩


theorem flatten_promises''''''''' (c : Computation (WSeq α)) :
    Computation.bind (flatten c) (fun x => Computation.map (List.ofSeq) (Computation.pure x)) ~
      Computation.pure (List.ofSeq c) := by
  apply
    Computation.eq_of_bisim fun c1 c2 =>
      ∃ c,
        Computation.bind (flatten c) (fun x => Computation.map (List.ofSeq) (Computation.pure x)) = c1 ∧
          c ~ Computation.pure (List.ofSeq c)
  · intro c1 c2 h
    exact
      match c1, c2, h with
      | _, c2, ⟨c, rfl, h⟩ => by
        apply recOn c <;> simp
        · intro x c
          cases

Attempt failure.

Working on Mathlib/Data/Set/Finite.lean - 2024-09-08 18:11:09.234408.
---83/200---
For theorem Set.union_finset_finite_of_range_finite in Mathlib/Data/Set/Finite.lean:
theorem union_finset_finite_of_range_finite (f : α → Finset β) (h : (range f).Finite) :
    (⋃ a, (f a : Set β)).Finite 


Original valid proof:
:= by
  rw [← biUnion_range]
  exact h.biUnion fun y _ => y.finite_toSet


Verifying proof (Commit 5841a8d15e6905a0287a6ec353113b1dbfef9878):
 := by
  rw [← biUnion_range]
  exact h.biUnion fun a _ => (f a).finite_toSet


theorem finite_range_ite {p : α → Prop} [DecidablePred p] {f g : α → β} (hf : (range f).Finite)
    (hg : (range g).Finite) : (range fun x => if p x then f x else g x).Finite :=
  (hf.union hg).subset range_ite_subset


theorem finite_range_const {c : β} : (range fun _ : α => c).Finite :=
  (finite_singleton c).subset range_const_subset


theorem Subsingleton.finite_range [Subsingleton α] (f : α → β) : (range f).Finite := by
  rw [range_eq_singleton (f default)]
  exact finite_singleton _


theorem finite_range_of_finite_image (f : α → β) (s : Set α) (h : s.Finite)
    (hs : Set.MapsTo f s (range f)) : (range f).Finite := by
  rw [← image_univ] at hs
  have := h.image f
  rw [← hs.image_eq] at this
  exact this.subset (subset_univ _)


theorem finite_range_of_finite [Finite α] (f : α → β) : (range f).Finite :=
  (Set.toFinite _).finite_of_finite_image (mapsTo_range f)


theorem finite_range_ite [DecidablePred p] (f g : α → β) (h : (range f).Finite)
    (h' : (range g).Finite) : (range fun x => if p x then f x else g x).Finite :=
  (h.union h').subset range_ite_subset


theorem finite_range_if' {p : α → Prop} {f g : α → β} [DecidablePred p] (hf : (range f).Finite)
    (hg : (range g).Finite) : (range fun x => if p x then f x else g x).Finite :=
  (hf.image _).union (hg.image _)


theorem finite_range_sum_of_finite (ι) [Fintype ι] (f : ι → α → β) (h : ∀ i, (range (f i)).Finite) :
    (range (fun a => ∑ i, f i a)).Finite :=
  (Fintype.ofFinite _).finite_range.subset <| range_comp_subset_range _ _


theorem finite_range_prod_of_finite (f : α → M) (g : α → N) (h : (range f).Finite)
    (h' : (range g).Finite) : (range fun a => (f a, g a)).Finite := by
  rw [← image_univ] at h h'
  rw [← image_univ]
  exact (h.image _).union (h'.image _)


theorem finite_range_prod_left (e : α → β) (f : α → M) (h : (range e).Finite) :
    (range fun a => (e a, f a)).Finite :=
  h.image _


theorem finite_range_prod_right (e : α → β) (f : α → M) (h : (range f).Finite) :
    (range fun a => (e a, f a)).Finite :=
  h.image _


theorem finite_range_prod_of_finite_left (e : α → M) (f : β → N) (h : (range e).Finite) :
    (range fun p : α × β => (e p.1, f p.2)).Finite :=
  h.image _


theorem finite_range_prod_of_finite_right (e : α → M) (f : β → N) (h : (range f).Finite) :
    (range fun p : α × β => (e p.1, f p.2)).Finite :=
  h.image _


theorem finite_range_prod_of_finite_of_finite [Finite α] [Finite β] (f : α → M) (g : β → N) :
    (range fun p : α × β => (f p.1, g p.2)).Finite :=
  (finite_range_prod_of_finite_left _ _ (Set.toFinite _)).subset <| by
    rintro _ ⟨p, rfl⟩
    exact ⟨p.1, rfl⟩


theorem finite_range_prod_of_finite_of_finite' [Finite α] [Finite β] (f : α → M) (g : β → N) :
    (range fun p : α × β => (f p.1, g p.2)).Finite :=
  (finite_range_prod_of_finite_right _ _ (Set.toFinite _)).subset <| by
    rintro _ ⟨p, rfl⟩
    exact ⟨p.2, rfl⟩


theorem finite_range_prod_of_finite_of_finite'' [Finite α] [Finite β] (f : α → M × N) :
    (range f).Finite :=
  (finite_range_prod_of_finite_of_finite' f Prod.fst).subset <| by
    rintro _ ⟨p, rfl⟩
    exact mem_range_self _


theorem finite_range_prod_of_finite_of_finite''' [Finite α] [Finite β] (f : α × β → M) :
    (range f).Finite :=
  (finite_range_prod_of_finite_of_finite'' fun p => f p.symm).subset <| by
    rintro _ ⟨p, rfl⟩
    exact mem_range_self _


theorem finite_range_prod_of_finite_of_finite'''' [Finite α] [Finite β] (f : α × β → M × N) :
    (range f).Finite :=
  (finite_range_prod_of_finite_of_finite''' fun p => f p.symm).subset <| by
    rintro _ ⟨p, rfl⟩
    exact mem_range_self _


theorem finite_range_prod_of_finite_of_finite''''' [Finite α] [Finite β] (f : α × β → M × N × P) :
    (range f).Finite :=
  (finite_range_prod_of_finite_of_finite'''' fun p => f p.symm).subset <| by
    rintro _ ⟨p, rfl⟩
    exact mem_range_self _


theorem finite_range_prod_of_finite_of_finite'''''' [Finite α] [Finite β] [Finite γ]
    (f : α × β × γ → M × N × P) : (range f).Finite :=
  (finite_range_prod_of_finite_of_finite''''' fun p => f p.symm).subset <| by
    rintro _ ⟨p, rfl⟩
    exact mem_range_self _


theorem finite_range_prod_of_finite_of_finite''''''' [Finite α] [Finite β] [Finite γ] [Finite δ]
    (f : α × β × γ × δ → M × N × P × Q) : (range f).Finite :=
  (finite_range_prod_of_finite_of_finite'''''' fun p => f p.symm).subset <| by
    rintro _ ⟨p, rfl⟩
    exact mem_range_self _


theorem finite_range_prod_of_finite_of_finite'''''''' [Finite α] [Finite β] [Finite γ] [Finite δ]
    [Finite ε] (f : α × β × γ × δ × ε → M × N × P × Q × R) : (range f).Finite :=
  (finite_range_prod_of_finite_of_finite''''''' fun p => f p.symm).subset <| by
    rintro _ ⟨p, rfl⟩
    exact mem_range_self _


theorem finite_range_prod_of_finite_of_finite''''''''' [Finite α] [Finite β] [Finite γ] [Finite δ]
    [Finite ε] [Finite ζ] (f : α × β × γ × δ × ε × ζ → M × N × P × Q × R × S) :
    (range f).Finite :=
  (finite_range_prod_of_finite_of_finite'''''''' fun p => f p.symm).subset <| by
    rintro _ ⟨p, rfl⟩
    exact mem_range_self _


theorem finite_range_prod_of_finite_of_finite'''''''''' [Finite α] [Finite β] [Finite γ] [Finite δ]
    [Finite ε] [Finite ζ] [Finite η] (f : α × β × γ × δ × ε × ζ × η → M × N × P × Q × R × S × T) :
    (range f).Finite :=
  (finite_range_prod_of_finite_of_finite''''''''' fun p => f p.symm).subset <| by
    rintro _ ⟨p, rfl⟩
    exact mem_range_self _


theorem finite_range_prod_of_finite_of_finite''''''''''' [Finite α] [Finite β] [Finite γ] [Finite δ]
    [Finite ε] [Finite ζ] [Finite η] [Finite θ] (f : α × β × γ × δ × ε × ζ × η × θ → M × N × P × Q × R × S × T × U) :
    (range f).Finite :=
  (finite_range_prod_of_finite_of_finite'''''''''' fun p => f p.symm).subset <| by
    rintro _ ⟨p, rfl⟩
    exact mem_range_self _


theorem finite_range_prod_of_finite_of_finite'''''''''''' [Finite α] [Finite β] [Finite γ] [Finite δ]
    [Finite ε] [Finite ζ] [Finite η] [Finite θ] [Finite ι]
    (f : α × β × γ × δ × ε × ζ × η × θ × ι → M × N × P × Q × R × S × T × U × V) :
    (range f).Finite :=
  (finite_range_prod_of_finite_of_finite''''''''''' fun p => f p.symm).subset <| by
    rintro _ ⟨p, rfl⟩
    exact mem_range_self _


theorem finite_range_prod_of_finite_of_finite''''''''''''' [Finite α] [Finite β] [Finite γ] [Finite δ]
    [Finite ε] [Finite ζ] [Finite η] [Finite θ] [Finite ι] [Finite κ]
    (f : α × β × γ × δ × ε × ζ × η × θ × ι × κ → M × N × P × Q × R × S × T × U × V × W) :
    (range f).Finite :=
  (finite_range_prod_of_finite_of_finite'''''''''''' fun p => f p.symm).subset <| by
    rintro _ ⟨p, rfl⟩
    exact mem_range_self _


theorem finite_range_prod_of_finite_of_finite'''''''''''''' [Finite α] [Finite β] [Finite γ] [Finite δ]
    [Finite ε] [Finite ζ] [Finite η] [Finite θ] [Finite ι] [Finite κ] [Finite λ]
    (f : α × β × γ × δ × ε × ζ × η × θ × ι × κ × λ → M × N × P × Q × R × S × T × U × V × W × X) :
    (range f).Finite :=
  (finite_range_prod_of_finite_of_finite''''''''''''' fun p => f p.symm).subset <| by
    rintro _ ⟨p, rfl⟩
    exact mem_range_self _


theorem finite_range_prod_of_finite_of_finite''''''''''''''' [Finite α] [Finite β] [Finite γ] [Finite δ]
    [Finite ε] [Finite ζ] [Finite η] [Finite θ] [Finite ι] [Finite κ] [Finite λ] [Finite μ]
    (f : α × β × γ × δ × ε × ζ × η × θ × ι × κ × λ × μ → M × N × P × Q × R × S × T × U × V × W × X × Y) :
    (range f).Finite :=
  (finite_range_prod_of_finite_of_finite'''''''''''''' fun p => f p.symm).subset <| by
    rintro _ ⟨p,

Attempt failure.

Working on Mathlib/Dynamics/OmegaLimit.lean - 2024-09-08 18:11:21.143374.
---84/200---
For theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' in Mathlib/Dynamics/OmegaLimit.lean:
theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)
    (hn₂ : ω f ϕ s ⊆ n) : ∃ u ∈ f, closure (image2 ϕ u s) ⊆ n 


Original valid proof:
:= by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  let k := closure (image2 ϕ v s)
  have hk : IsCompact (k \ n) :=
    (hc₁.of_isClosed_subset isClosed_closure hv₂).diff hn₁
  let j u := (closure (image2 ϕ (u ∩ v) s))ᶜ
  have hj₁ : ∀ u ∈ f, IsOpen (j u) := fun _ _ ↦ isOpen_compl_iff.mpr isClosed_closure
  have hj₂ : k \ n ⊆ ⋃ u ∈ f, j u := by
    have : ⋃ u ∈ f, j u = ⋃ u : (↥f.sets), j u := biUnion_eq_iUnion _ _
    rw [this, diff_subset_comm, diff_iUnion]
    rw [omegaLimit_eq_iInter_inter _ _ _ hv₁] at hn₂
    simp_rw [j, diff_compl]
    rw [← inter_iInter]
    exact Subset.trans inter_subset_right hn₂
  rcases hk.elim_finite_subcover_image hj₁ hj₂ with ⟨g, hg₁ : ∀ u ∈ g, u ∈ f, hg₂, hg₃⟩
  let w := (⋂ u ∈ g, u) ∩ v
  have hw₂ : w ∈ f := by simpa [w, *]
  have hw₃ : k \ n ⊆ (closure (image2 ϕ w s))ᶜ := by
    apply Subset.trans hg₃
    simp only [j, iUnion_subset_iff, compl_subset_compl]
    intros u hu
    mono
    refine iInter_subset_of_subset u (iInter_subset_of_subset hu ?_)
    all_goals exact Subset.rfl
  have hw₄ : kᶜ ⊆ (closure (image2 ϕ w s))ᶜ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset inter_subset_right Subset.rfl)
  have hnc : nᶜ ⊆ k \ n ∪ kᶜ := by rw [union_comm, ← inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 ϕ w s) ⊆ n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hw₃ hw₄))
  exact ⟨_, hw₂, hw⟩


Verifying proof (Commit ed737e5773cdf087080f52542509535e7446ced4):
∧ ∀ᵐ x ∂μ, x ∈ u := by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset hc₁ hv₁ hn₁ hn₂
    with ⟨u, hu₁, hu₂, hu₃⟩
  exact ⟨u, hu₁, hu₂.trans hv₂, hu₃⟩
```

Attempt failure.

---85/200---
For theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' in Mathlib/Dynamics/OmegaLimit.lean:
theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)
    (hn₂ : ω f ϕ s ⊆ n) : ∃ u ∈ f, closure (image2 ϕ u s) ⊆ n 


Original valid proof:
:= by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  let k := closure (image2 ϕ v s)
  have hk : IsCompact (k \ n) :=
    (hc₁.of_isClosed_subset isClosed_closure hv₂).diff hn₁
  let j u := (closure (image2 ϕ (u ∩ v) s))ᶜ
  have hj₁ : ∀ u ∈ f, IsOpen (j u) := fun _ _ ↦ isOpen_compl_iff.mpr isClosed_closure
  have hj₂ : k \ n ⊆ ⋃ u ∈ f, j u := by
    have : ⋃ u ∈ f, j u = ⋃ u : (↥f.sets), j u := biUnion_eq_iUnion _ _
    rw [this, diff_subset_comm, diff_iUnion]
    rw [omegaLimit_eq_iInter_inter _ _ _ hv₁] at hn₂
    simp_rw [j, diff_compl]
    rw [← inter_iInter]
    exact Subset.trans inter_subset_right hn₂
  rcases hk.elim_finite_subcover_image hj₁ hj₂ with ⟨g, hg₁ : ∀ u ∈ g, u ∈ f, hg₂, hg₃⟩
  let w := (⋂ u ∈ g, u) ∩ v
  have hw₂ : w ∈ f := by simpa [w, *]
  have hw₃ : k \ n ⊆ (closure (image2 ϕ w s))ᶜ := by
    apply Subset.trans hg₃
    simp only [j, iUnion_subset_iff, compl_subset_compl]
    intros u hu
    mono
    refine iInter_subset_of_subset u (iInter_subset_of_subset hu ?_)
    all_goals exact Subset.rfl
  have hw₄ : kᶜ ⊆ (closure (image2 ϕ w s))ᶜ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset inter_subset_right Subset.rfl)
  have hnc : nᶜ ⊆ k \ n ∪ kᶜ := by rw [union_comm, ← inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 ϕ w s) ⊆ n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hw₃ hw₄))
  exact ⟨_, hw₂, hw⟩


Verifying proof (Commit a0ae54031c9160e2e2357f3bf0d8106847fdf1f5):
∧ ∀ᵐ x ∂μ, x ∈ u := by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset hc₁ hv₁ hn₁ hn₂
    with ⟨u, hu₁, hu₂, hu₃⟩
  exact ⟨u, hu₁, hu₂.trans hv₂, hu₃⟩
```

Attempt failure.

Working on Mathlib/FieldTheory/Normal.lean - 2024-09-08 18:11:35.801572.
---86/200---
For theorem Normal.minpoly_eq_iff_mem_orbit in Mathlib/FieldTheory/Normal.lean:
theorem Normal.minpoly_eq_iff_mem_orbit [h : Normal F E] {x y : E} :
    minpoly F x = minpoly F y ↔ x ∈ MulAction.orbit (E ≃ₐ[F] E) y 


Original valid proof:
:= by
  refine ⟨fun he ↦ ?_, fun ⟨f, he⟩ ↦ he ▸ minpoly.algEquiv_eq f y⟩
  obtain ⟨φ, hφ⟩ := exists_algHom_of_splits_of_aeval (normal_iff.mp h) (he ▸ minpoly.aeval F x)
  exact ⟨AlgEquiv.ofBijective φ (φ.normal_bijective F E E), hφ⟩


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∨ y ∈ MulAction.orbit (E ≃ₐ[F] E) x := by
  refine ⟨fun hxy ↦ ?_, fun hxy ↦ ?_⟩
  · obtain ⟨φ, rfl⟩ := MulAction.mem_orbit_iff.mp hxy
    exact Or.inl (MulAction.mem_orbit_iff.mpr ⟨φ, rfl⟩)
  rcases hxy with (⟨φ, rfl⟩ | ⟨φ, rfl⟩)
  · exact minpoly.algEquiv_eq F φ x
  · exact (minpoly.algEquiv_eq F φ.symm y).symm

theorem Normal.minpoly_eq_iff_mem_orbit' [h : Normal F E] {x y : E} :
    minpoly F x = minpoly F y ↔ x ∈ MulAction.orbit (E ≃ₐ[F] E) y := by
  refine ⟨fun hxy ↦ ?_, fun hxy ↦ ?_⟩
  · obtain ⟨φ, rfl⟩ := MulAction.mem_orbit_iff.mp hxy
    exact MulAction.mem_orbit_iff.mpr ⟨φ, rfl⟩
  obtain ⟨φ, rfl⟩ := MulAction.mem_orbit_iff.mp hxy
  exact minpoly.algEquiv_eq F φ x

theorem Normal.minpoly_eq_iff_mem_orbit'' [h : Normal F E] {x y : E} :
    minpoly F x = minpoly F y ↔ y ∈ MulAction.orbit (E ≃ₐ[F] E) x := by
  refine ⟨fun hxy ↦ ?_, fun hxy ↦ ?_⟩
  · obtain ⟨φ, rfl⟩ := MulAction.mem_orbit_iff.mp hxy
    exact MulAction.mem_orbit_iff.mpr ⟨φ.symm, by simp [hxy]⟩
  obtain ⟨φ, rfl⟩ := MulAction.mem_orbit_iff.mp hxy
  exact (minpoly.algEquiv_eq F φ.symm x).symm

theorem Normal.minpoly_eq_iff_mem_orbitₐ [h : Normal F E] {x y : E} :
    minpoly F x = minpoly F y ↔ x ∈ MulAction.orbit (E ≃ₐ[F] E) y := by
  refine ⟨fun hxy ↦ ?_, fun hxy ↦ ?_⟩
  · obtain ⟨φ, rfl⟩ := MulAction.mem_orbit_iff.mp hxy
    exact MulAction.mem_orbit_iff.mpr ⟨φ, rfl⟩
  obtain ⟨φ, rfl⟩ := MulAction.mem_orbit_iff.mp hxy
  exact minpoly.algEquiv_eq F φ x

theorem Normal.minpoly_eq_iff_mem_orbitₐ' [h : Normal F E] {x y : E} :
    minpoly F x = minpoly F y ↔ y ∈ MulAction.orbit (E ≃ₐ[F] E) x := by
  refine ⟨fun hxy ↦ ?_, fun hxy ↦ ?_⟩
  · obtain ⟨φ, rfl⟩ := MulAction.mem_orbit_iff.mp hxy
    exact MulAction.mem_orbit_iff.mpr ⟨φ.symm, by simp [hxy]⟩
  obtain ⟨φ, rfl⟩ := MulAction.mem_orbit_iff.mp hxy
  exact (minpoly.algEquiv_eq F φ.symm x).symmComplete the following Lean 4 code:

```lean4
import Mathlib.Algebra.Group.Subgroup.Basic
import Mathlib.Algebra.Group.Submonoid.Membership
import Mathlib.Algebra.PUnitInstances
import Mathlib.GroupTheory.Congruence.Basic

/-!
# Coproduct (free product) of two monoids or groups

In this file we define `Monoid.Coprod M N` (notation: `M ∗ N`)
to be the coproduct (a.k.a. free product) of two monoids.
The same type is used for the coproduct of two monoids and for the coproduct of two groups.

The coproduct `M ∗ N` has the following universal property:
for any monoid `P` and homomorphisms `f : M →* P`, `g : N →* P`,
there exists a unique homomorphism `fg : M ∗ N →* P`
such that `fg ∘ Monoid.Coprod.inl = f` and `fg ∘ Monoid.Coprod.inr = g`,
where `Monoid.Coprod.inl : M →* M ∗ N`
and `Monoid.Coprod.inr : N →* M ∗ N` are canonical embeddings.
This homomorphism `fg` is given by `Monoid.Coprod.lift f g`.

We also define some homomorphisms and isomorphisms about `M ∗ N`,
and provide additive versions of all definitions and theorems.

## Main definitions

(... 88 lines omitted)
-/

/- (... 20 lines omitted) -/

/-- The natural projection `FreeMonoid (M ⊕ N) →* M ∗ N`. -/
@[to_additive "The natural projection `FreeAddMonoid (M ⊕ N) →+ AddMonoid.Coprod M N`."]
def mk : FreeMonoid (M ⊕ N) →* M ∗ N := Con.mk' _

@[to_additive (attr := simp)]
theorem con_ker_mk : Con.ker mk = coprodCon M N := Con.mk'_ker _

@[to_additive]
theorem mk_surjective : Surjective (@mk M N _ _) := surjective_quot_mk _

@[to_additive (attr := simp)]
theorem mrange_mk : MonoidHom.mrange (@mk M N _ _) = ⊤ := Con.mrange_mk'

@[to_additive (attr := simp)]
theorem mrange_inl : MonoidHom.mrange (inl : M →* M ∗ N) = ⊤ := by
  rw [← mrange_mk, ← mrange_eq_top_of_surjective (mk : FreeMonoid (M ⊕ N) →* _) mk_surjective]
  exact MonoidHom.mrange_le_comap _ _ <| Con.ker_mk'.symm ▸ le_top

@[to_additive (attr := simp)]
theorem mrange_inr : MonoidHom.mrange (inr : N →* M ∗ N) = ⊤ := by
  rw [← mrange_mk, ← mrange_eq_top_of_surjective (mk : FreeMonoid (M ⊕ N) →* _) mk_surjective]
  exact MonoidHom.mrange_le_comap _ _ <| Con.ker_mk'.symm ▸ le_top
```

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Basic.lean - 2024-09-08 18:11:56.858094.
---87/200---
For theorem EuclideanGeometry.orthogonalProjectionFn_mem in Mathlib/Geometry/Euclidean/Basic.lean:
theorem orthogonalProjectionFn_mem {s : AffineSubspace ℝ P} [Nonempty s]
    [HasOrthogonalProjection s.direction] (p : P) : orthogonalProjectionFn s p ∈ s 


Original valid proof:
:= by
  rw [← mem_coe, ← Set.singleton_subset_iff, ← inter_eq_singleton_orthogonalProjectionFn]
  exact Set.inter_subset_left


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧
      dist p (orthogonalProjectionFn s p) = infDist p s := by
  have hs : s.direction.Nonempty := by simpa using inferInstance
  haveI := hs.isGreatest_of_nonempty
  haveI := hs.isLeast_of_nonempty
  exact ⟨orthogonalProjectionFn_mem_iff.mp (orthogonalProjectionFn_mem_iff.mpr ⟨hs, rfl⟩),
    orthogonalProjectionFn_dist p⟩


/-- The orthogonal projection of a point onto a nonempty affine subspace, whose direction
is complete. The corresponding linear map (mapping a vector to the difference between the
orthogonal projections of two points whose difference is that vector) is the `orthogonalProjection`
for real inner product spaces, onto the direction of `s`. -/
def orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] : P →ᵃ[ℝ] s where
  toFun := orthogonalProjectionFn s
  linear := orthogonalProjection ℝ s.direction
  map_vadd' p v := by
    have hs : s.direction.Nonempty := by simpa using inferInstance
    haveI := hs.isGreatest_of_nonempty
    haveI := hs.isLeast_of_nonempty
    simp [orthogonalProjectionFn_mem_iff, orthogonalProjection_mem_iff,
      orthogonalProjectionFn_dist, orthogonalProjection_dist]


/-- The orthogonal projection of a point onto a nonempty affine subspace, whose direction
is complete. The corresponding linear map (mapping a vector to the difference between the
orthogonal projections of two points whose difference is that vector) is the `orthogonalProjection`
for real inner product spaces, onto the direction of `s`. -/
irreducible_def orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] : P →ᵃ[ℝ] s where
  toFun := orthogonalProjectionFn s
  linear := orthogonalProjection ℝ s.direction
  map_vadd' p v := by
    have hs : s.direction.Nonempty := by simpa using inferInstance
    haveI := hs.isGreatest_of_nonempty
    haveI := hs.isLeast_of_nonempty
    simp [orthogonalProjectionFn_mem_iff, orthogonalProjection_mem_iff,
      orthogonalProjectionFn_dist, orthogonalProjection_dist]

/-- The orthogonal projection of a point onto a nonempty affine subspace, whose direction
is complete. The corresponding linear map (mapping a vector to the difference between the
orthogonal projections of two points whose difference is that vector) is the `orthogonalProjection`
for real inner product spaces, onto the direction of `s`. -/
def orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] : P →ᵃ[ℝ] s where
  toFun := orthogonalProjectionFn s
  linear := orthogonalProjection ℝ s.direction
  map_vadd' p v := by
    have hs : s.direction.Nonempty := by simpa using inferInstance
    haveI := hs.isGreatest_of_nonempty
    haveI := hs.isLeast_of_nonempty
    simp [orthogonalProjectionFn_mem_iff, orthogonalProjection_mem_iff,
      orthogonalProjectionFn_dist, orthogonalProjection_dist]

/-- The orthogonal projection of a point onto a nonempty affine subspace, whose direction
is complete. The corresponding linear map (mapping a vector to the difference between the
orthogonal projections of two points whose difference is that vector) is the `orthogonalProjection`
for real inner product spaces, onto the direction of `s`. -/
def orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] : P →ᵃ[ℝ] s where
  toFun := orthogonalProjectionFn s
  linear := orthogonalProjection ℝ s.direction
  map_vadd' p v := by
    have hs : s.direction.Nonempty := by simpa using inferInstance
    haveI := hs.isGreatest_of_nonempty
    haveI := hs.isLeast_of_nonempty
    simp [orthogonalProjectionFn_mem_iff, orthogonalProjection_mem_iff,
      orthogonalProjectionFn_dist, orthogonalProjection_dist]

/-- The orthogonal projection of a point onto a nonempty affine subspace, whose direction
is complete. The corresponding linear map (mapping a vector to the difference between the
orthogonal projections of two points whose difference is that vector) is the `orthogonalProjection`
for real inner product spaces, onto the direction of `s`. -/
def orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] : P →ᵃ[ℝ] s where
  toFun := orthogonalProjectionFn s
  linear := orthogonalProjection ℝ s.direction
  map_vadd' p v := by
    have hs : s.direction.Nonempty := by simpa using inferInstance
    haveI := hs.isGreatest_of_nonempty
    haveI := hs.isLeast_of_nonempty
    simp [orthogonalProjectionFn_mem_iff, orthogonalProjection_mem_iff,
      orthogonalProjectionFn_dist, orthogonalProjection_dist]

/-- The orthogonal projection of a point onto a nonempty affine subspace, whose direction
is complete. The corresponding linear map (mapping a vector to the difference between the
orthogonal projections of two points whose difference is that vector) is the `orthogonalProjection`
for real inner product spaces, onto the direction of `s`. -/
def orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] : P →ᵃ[ℝ] s where
  toFun := orthogonalProjectionFn s
  linear := orthogonalProjection ℝ s.direction
  map_vadd' p v := by
    have hs : s.direction.Nonempty := by simpa using inferInstance
    haveI := hs.isGreatest_of_nonempty
    haveI := hs.isLeast_of_nonempty
    simp [orthogonalProjectionFn_mem_iff, orthogonalProjection_mem_iff,
      orthogonalProjectionFn_dist, orthogonalProjection_dist]

/-- The orthogonal projection of a point onto a nonempty affine subspace, whose direction
is complete. The corresponding linear map (mapping a vector to the difference between the
orthogonal projections of two points whose difference is that vector) is the `orthogonalProjection`
for real inner product spaces, onto the direction of `s`. -/
def orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] : P →ᵃ[ℝ] s where
  toFun := orthogonalProjectionFn s
  linear := orthogonalProjection ℝ s.direction
  map_vadd' p v := by
    have hs : s.direction.Nonempty := by simpa using inferInstance
    haveI := hs.isGreatest_of_nonempty
    haveI := hs.isLeast_of_nonempty
    simp [orthogonalProjectionFn_mem_iff, orthogonalProjection_mem_iff,
      orthogonalProjectionFn_dist, orthogonalProjection_dist]

/-- The orthogonal projection of a point onto a nonempty affine subspace, whose direction
is complete. The corresponding linear map (mapping a vector to the difference between the
orthogonal projections of two points whose difference is that vector) is the `orthogonalProjection`
for real inner product spaces, onto the direction of `s`. -/
def orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] : P →ᵃ[ℝ] s where
  toFun := orthogonalProjectionFn s
  linear := orthogonalProjection ℝ s.direction
  map_vadd' p v := by
    have hs : s.direction.Nonempty := by simpa using inferInstance
    haveI := hs.isGreatest_of_nonempty
    haveI := hs.isLeast_of_nonempty
    simp [orthogonalProjectionFn_mem_iff, orthogonalProjection_mem_iff,
      orthogonalProjectionFn_dist, orthogonalProjection_dist]

/-- The orthogonal projection of a point onto a nonempty affine subspace, whose direction
is complete. The corresponding linear map (mapping a vector to the difference between the
orthogonal projections of two points whose difference is that vector) is the `orthogonalProjection`
for real inner product spaces, onto the direction of `s`. -/
def orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] : P →ᵃ[ℝ] s where
  toFun := orthogonalProjectionFn s
  linear := orthogonalProjection ℝ s.direction
  map_vadd' p v := by
    have hs : s.direction.Nonempty := by simpa using inferInstance
    haveI := hs.isGreatest_of_nonempty
    haveI := hs.isLeast_of_nonempty
    simp [orthogonalProjectionFn_mem_iff, orthogonalProjection_mem_iff,
      orthogonalProjectionFn_dist, orthogonalProjection_dist]

/-- The orthogonal projection of a point onto a nonempty affine subspace, whose direction
is complete. The corresponding linear map (mapping a vector to the difference between the
orthogonal projections of two points whose difference is that vector) is the `orthogonalProjection`
for real inner product spaces, onto the direction of `s`. -/
def orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] : P →ᵃ[ℝ] s where
  toFun := orthogonalProjectionFn s
  linear := orthogonalProjection ℝ s.direction
  map_vadd' p v := by
    have hs : s.direction.Nonempty := by simpa using inferInstance
    haveI := hs.isGreatest_of_nonempty
    haveI := hs.isLeast_of_nonempty
    simp [orthogonalProjectionFn_mem_iff, orthogonalProjection_mem_iff,
      orthogonalProjectionFn_dist, orthogonalProjection_dist]

/-- The orthogonal projection of a point onto a nonempty affine subspace, whose direction
is complete. The corresponding linear map (mapping a vector to the difference between the
orthogonal projections of two points whose difference is that vector) is the `orthogonalProjection`
for real inner product spaces, onto the direction of `s`. -/
def orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] : P →ᵃ[ℝ] s where
  toFun := orthogonalProjectionFn s
  linear := orthogonalProjection ℝ s.direction
  map_vadd' p v := by
    have hs : s.direction.Nonempty := by simpa using inferInstance
    haveI := hs.isGreatest_of_nonempty
    haveI := hs.isLeast_of_nonempty
    simp [orthogonalProjectionFn_mem_iff, orthogonalProjection_mem_iff,
      orthogonalProjectionFn_dist, orthogonalProjection_dist]

/-- The orthogonal projection of a point onto a nonempty affine subspace, whose direction
is complete. The corresponding linear map (mapping a vector to the difference between the
orthogonal projections of two points whose difference is that vector) is the `orthogonalProjection`
for real inner product spaces, onto the direction of `s`. -/
def orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] : P →ᵃ[ℝ] s where
  toFun := orthogonalProjectionFn s
  linear := orthogonalProjection ℝ s.direction
  map_vadd' p v := by
    have hs : s.direction.Nonempty := by simpa using inferInstance
    haveI := hs.isGreatest_of_nonempty
    haveI := hs.isLeast_of_nonempty
    simp [orthogonalProjectionFn_mem_iff, orthogonalProjection_mem_iff,
      orthogonalProjectionFn_dist, orthogonalProjection_dist]

/-- The orthogonal projection of a point onto a nonempty affine subspace, whose direction
is complete. The corresponding linear map (mapping a vector to the difference between the
orthogonal projections of two points whose difference is that vector) is the `orthogonalProjection`
for real inner product spaces, onto the direction of `s`. -/
def orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] : P →ᵃ[ℝ] s where
  toFun := orthogonalProjectionFn s
  linear := orthogonalProjection ℝ s.direction
  map_vadd' p v := by
    have hs : s.direction.Nonempty := by simpa using inferInstance
    haveI := hs.isGreatest_of_nonempty
    haveI := hs.isLeast_of_nonempty
    simp [orthogonalProjectionFn_mem_iff, orthogonalProjection_mem_iff,
      orthogonalProjectionFn_dist, orthogonalProjection_dist]

/-- The orthogonal projection of a point onto a nonempty affine subspace, whose direction
is complete. The corresponding linear map (mapping a vector to the difference between the
orthogonal projections of two points whose difference is that vector) is the `orthogonalProjection`
for real inner product spaces, onto the direction of `s`. -/
def orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] : P →ᵃ[ℝ] s where
  toFun := orthogonalProjectionFn s
  linear := orthogonalProjection ℝ s.direction


Attempt failure.

Working on Mathlib/Geometry/Euclidean/Sphere/SecondInter.lean - 2024-09-08 18:12:20.768228.
---88/200---
For theorem EuclideanGeometry.Sphere.secondInter_smul in Mathlib/Geometry/Euclidean/Sphere/SecondInter.lean:
theorem Sphere.secondInter_smul (s : Sphere P) (p : P) (v : V) {r : ℝ} (hr : r ≠ 0) :
    s.secondInter p (r • v) = s.secondInter p v 


Original valid proof:
:= by
  simp_rw [Sphere.secondInter, real_inner_smul_left, inner_smul_right, smul_smul,
    div_mul_eq_div_div]
  rw [mul_comm, ← mul_div_assoc, ← mul_div_assoc, mul_div_cancel_left₀ _ hr, mul_comm, mul_assoc,
    mul_div_cancel_left₀ _ hr, mul_comm]


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∧
      dist p (s.secondInter p v) = dist p (s.secondInter p (r • v)) / |r| := by
  simp_rw [secondInter, dist_smul_vadd_eq_dist _ _ hr, smul_smul, Real.norm_eq_abs]
  constructor
  · rw [← mul_smul, eq_comm, smul_eq_mul, mul_comm, mul_smul, smul_smul, mul_comm,
      mul_inv_cancel hr, one_smul]
  · rw [← mul_smul, smul_smul, mul_comm, mul_inv_cancel hr, one_smul, one_mul]


/-- A point on a line is on the second intersection of that line with a sphere if and only if
it is on the sphere. -/
theorem Sphere.secondInter_eq_self_iff (s : Sphere P) (p : P) (v : V) :
    s.secondInter p v = p ↔ p ∈ s := by
  refine ⟨fun h => ?_, fun h => ?_⟩
  · by_cases hv : v = 0
    · simp [hv] at h
      exact h
    rcases h with ⟨r, hr⟩
    rw [secondInter, smul_eq_zero] at hr
    cases hr with
    | inl hr =>
      rw [eq_comm, hr] at h
      simp [h]
    | inr hr =>
      rw [eq_comm, hr] at h
      simp [h]
  · rw [secondInter, eq_comm]
    exact ⟨1, by simp [h]⟩


/-- A point on a line is on the second intersection of that line with a sphere if and only if
it is on the sphere. -/
theorem Sphere.secondInter_eq_self_iff' (s : Sphere P) (p : P) (v : V) :
    s.secondInter p v = p ↔ ∃ r : ℝ, r ≠ 0 ∧ p = s.center + r • v := by
  refine ⟨fun h => ?_, fun ⟨r, hr, h⟩ => ?_⟩
  · rw [secondInter, eq_comm] at h
    rcases h with ⟨r, hr⟩
    refine ⟨r, hr.1, ?_⟩
    rw [eq_comm, hr.2]
  · rw [h, secondInter, smul_eq_zero]
    exact ⟨⟨r, hr⟩, rfl⟩


/-- A point on a line is on the second intersection of that line with a sphere if and only if
it is on the sphere. -/
theorem Sphere.secondInter_eq_self_iff'' (s : Sphere P) (p : P) (v : V) :
    s.secondInter p v = p ↔ ∃ r : ℝ, r ≠ 0 ∧ dist p s.center = |r| * dist p (s.center + r • v) := by
  refine ⟨fun h => ?_, fun ⟨r, hr, h⟩ => ?_⟩
  · rw [secondInter, eq_comm] at h
    rcases h with ⟨r, hr⟩
    refine ⟨r, hr.1, ?_⟩
    rw [eq_comm, hr.2, dist_smul_vadd_eq_dist _ _ hr.1]
  · rw [secondInter, eq_comm]
    rcases h with ⟨r, hr, h⟩
    refine ⟨r, hr, ?_⟩
    rw [dist_smul_vadd_eq_dist _ _ hr, h]


/-- A point on a line is on the second intersection of that line with a sphere if and only if
it is on the sphere. -/
theorem Sphere.secondInter_eq_self_iff''' (s : Sphere P) (p : P) (v : V) :
    s.secondInter p v = p ↔ ∃ r : ℝ, r ≠ 0 ∧ dist p s.center = |r| * dist p (s.center + r • v) := by
  refine ⟨fun h => ?_, fun ⟨r, hr, h⟩ => ?_⟩
  · rw [secondInter, eq_comm] at h
    rcases h with ⟨r, hr⟩
    refine ⟨r, hr.1, ?_⟩
    rw [eq_comm, hr.2, dist_smul_vadd_eq_dist _ _ hr.1]
  · rw [secondInter, eq_comm]
    rcases h with ⟨r, hr, h⟩
    refine ⟨r, hr, ?_⟩
    rw [dist_smul_vadd_eq_dist _ _ hr, h]


/-- A point on a line is on the second intersection of that line with a sphere if and only if
it is on the sphere. -/
theorem Sphere.secondInter_eq_self_iff'''' (s : Sphere P) (p : P) (v : V) :
    s.secondInter p v = p ↔ ∃ r : ℝ, r ≠ 0 ∧ dist p s.center = |r| * dist p (s.center + r • v) := by
  refine ⟨fun h => ?_, fun ⟨r, hr, h⟩ => ?_⟩
  · rw [secondInter, eq_comm] at h
    rcases h with ⟨r, hr⟩
    refine ⟨r, hr.1, ?_⟩
    rw [eq_comm, hr.2, dist_smul_vadd_eq_dist _ _ hr.1]
  · rw [secondInter, eq_comm]
    rcases h with ⟨r, hr, h⟩
    refine ⟨r, hr, ?_⟩
    rw [dist_smul_vadd_eq_dist _ _ hr, h]


/-- A point on a line is on the second intersection of that line with a sphere if and only if
it is on the sphere. -/
theorem Sphere.secondInter_eq_self_iff''''' (s : Sphere P) (p : P) (v : V) :
    s.secondInter p v = p ↔ ∃ r : ℝ, r ≠ 0 ∧ dist p s.center = |r| * dist p (s.center + r • v) := by
  refine ⟨fun h => ?_, fun ⟨r, hr, h⟩ => ?_⟩
  · rw [secondInter, eq_comm] at h
    rcases h with ⟨r, hr⟩
    refine ⟨r, hr.1, ?_⟩
    rw [eq_comm, hr.2, dist_smul_vadd_eq_dist _ _ hr.1]
  · rw [secondInter, eq_comm]
    rcases h with ⟨r, hr, h⟩
    refine ⟨r, hr, ?_⟩
    rw [dist_smul_vadd_eq_dist _ _ hr, h]


/-- A point on a line is on the second intersection of that line with a sphere if and only if
it is on the sphere. -/
theorem Sphere.secondInter_eq_self_iff'''''' (s : Sphere P) (p : P) (v : V) :
    s.secondInter p v = p ↔ ∃ r : ℝ, r ≠ 0 ∧ dist p s.center = |r| * dist p (s.center + r • v) := by
  refine ⟨fun h => ?_, fun ⟨r, hr, h⟩ => ?_⟩
  · rw [secondInter, eq_comm] at h
    rcases h with ⟨r, hr⟩
    refine ⟨r, hr.1, ?_⟩
    rw [eq_comm, hr.2, dist_smul_vadd_eq_dist _ _ hr.1]
  · rw [secondInter, eq_comm]
    rcases h with ⟨r, hr, h⟩
    refine ⟨r, hr, ?_⟩
    rw [dist_smul_vadd_eq_dist _ _ hr, h]


/-- A point on a line is on the second intersection of that line with a sphere if and only if
it is on the sphere. -/
theorem Sphere.secondInter_eq_self_iff''''''' (s : Sphere P) (p : P) (v : V) :
    s.secondInter p v = p ↔ ∃ r : ℝ, r ≠ 0 ∧ dist p s.center = |r| * dist p (s.center + r • v) := by
  refine ⟨fun h => ?_, fun ⟨r, hr, h⟩ => ?_⟩
  · rw [secondInter, eq_comm] at h
    rcases h with ⟨r, hr⟩
    refine ⟨r, hr.1, ?_⟩
    rw [eq_comm, hr.2, dist_smul_vadd_eq_dist _ _ hr.1]
  · rw [secondInter, eq_comm]
    rcases h with ⟨r, hr, h⟩
    refine ⟨r, hr, ?_⟩
    rw [dist_smul_vadd_eq_dist _ _ hr, h]


/-- A point on a line is on the second intersection of that line with a sphere if and only if
it is on the sphere. -/
theorem Sphere.secondInter_eq_self_iff'''''''' (s : Sphere P) (p : P) (v : V) :
    s.secondInter p v = p ↔ ∃ r : ℝ, r ≠ 0 ∧ dist p s.center = |r| * dist p (s.center + r • v) := by
  refine ⟨fun h => ?_, fun ⟨r, hr, h⟩ => ?_⟩
  · rw [secondInter, eq_comm] at h
    rcases h with ⟨r, hr⟩
    refine ⟨r, hr.1, ?_⟩
    rw [eq_comm, hr.2, dist_smul_vadd_eq_dist _ _ hr.1]
  · rw [secondInter, eq_comm]
    rcases h with ⟨r, hr, h⟩
    refine ⟨r, hr, ?_⟩
    rw [dist_smul_vadd_eq_dist _ _ hr, h]


/-- A point on a line is on the second intersection of that line with a sphere if and only if
it is on the sphere. -/
theorem Sphere.secondInter_eq_self_iff''''''''' (s : Sphere P) (p : P) (v : V) :
    s.secondInter p v = p ↔ ∃ r : ℝ, r ≠ 0 ∧ dist p s.center = |r| * dist p (s.center + r • v) := by
  refine ⟨fun h => ?_, fun ⟨r, hr, h⟩ => ?_⟩
  · rw [secondInter, eq_comm] at h
    rcases h with ⟨r, hr⟩
    refine ⟨r, hr.1, ?_⟩
    rw [eq_comm, hr.2, dist_smul_vadd_eq_dist _ _ hr.1]
  · rw [secondInter, eq_comm]
    rcases h with ⟨r, hr, h⟩
    refine ⟨r, hr, ?_⟩
    rw [dist_smul_vadd_eq_dist _ _ hr, h]


/-- A point on a line is on the second intersection of that line with a sphere if and only if
it is on the sphere. -/
theorem Sphere.secondInter_eq_self_iff'''''''''' (s : Sphere P) (p : P) (v : V) :
    s.secondInter p v = p ↔ ∃ r : ℝ, r ≠ 0 ∧ dist p s.center = |r| * dist p (s.center + r • v) := by
  refine ⟨fun h => ?_, fun ⟨r, hr, h⟩ => ?_⟩
  · rw [secondInter, eq

Attempt failure.

Working on Mathlib/Geometry/Manifold/Instances/Sphere.lean - 2024-09-08 18:12:36.142650.
---89/200---
For theorem mfderiv_coe_sphere_injective in Mathlib/Geometry/Manifold/Instances/Sphere.lean:
theorem mfderiv_coe_sphere_injective {n : ℕ} [Fact (finrank ℝ E = n + 1)] (v : sphere (0 : E) 1) :
    Injective (mfderiv (𝓡 n) 𝓘(ℝ, E) ((↑) : sphere (0 : E) 1 → E) v) 


Original valid proof:
:= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (𝕜 := ℝ) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices Injective (fderiv ℝ ((stereoInvFunAux (-v : E) ∘ (↑)) ∘ U.symm) 0) by
    convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddEquivClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have : HasFDerivAt (stereoInvFunAux (-v : E) ∘ (Subtype.val : (ℝ ∙ (↑(-v) : E))ᗮ → E))
      (ℝ ∙ (↑(-v) : E))ᗮ.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective


Verifying proof (Commit 42efba3d0573971469083f4c678037805b06c5df):
∧
      mfderiv (𝓡 n) 𝓘(ℝ, E) ((↑) : sphere (0 : E) 1 → E) v =
        (2 : ℝ) • (orthogonalProjection (span ℝ {v})ᗮ : E →L[ℝ] (orthogonalProjection (span ℝ {v})ᗮ).ker) := by
  have h : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ = 1 := fun w => mem_sphere_zero_iff_norm.mp w.2
  have h' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 = 1 := fun w => by simp [h w]
  have h'' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have h''''''''''''''''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ^ 2 ≠ 0 := fun w => by simp [h' w]
  have h'''''''''''''''''''''''''''''''''''''''''''''''''''''''' : ∀ w : sphere (0 : E) 1, ‖(w : E)‖ ≠ 0 := fun w => by simp [h w]
  have

Attempt failure.

Working on Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean - 2024-09-08 18:13:12.877123.
---90/200---
For theorem contDiffGroupoid_zero_eq in Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean:
theorem contDiffGroupoid_zero_eq : contDiffGroupoid 0 I = continuousGroupoid H 


Original valid proof:
:= by
  apply le_antisymm le_top
  intro u _
  change u ∈ contDiffGroupoid 0 I
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid, contDiffPregroupoid]
  simp only [contDiffOn_zero]
  constructor
  · refine I.continuous.comp_continuousOn (u.continuousOn.comp I.continuousOn_symm ?_)
    exact (mapsTo_preimage _ _).mono_left inter_subset_left
  · refine I.continuous.comp_continuousOn (u.symm.continuousOn.comp I.continuousOn_symm ?_)
    exact (mapsTo_preimage _ _).mono_left inter_subset_left


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
⊓ 𝓘(𝕜, H) := by
  rw [contDiffGroupoid, contDiff_groupoid, continuousGroupoid, ModelWithCorners.range_eq_univ,
    ModelWithCorners.range_eq_univ]
  rfl


theorem contDiffGroupoid_zero_is_closed_smooth_manifold_with_corners :
    (contDiffGroupoid 0 I).IsClosedSmoothManifoldWithCorners I := by
  rw [contDiffGroupoid_zero_eq]
  exact ⟨(continuousGroupoid H).isClosed_smooth_manifold_with_corners,
    (modelWithCornersSelf_range I).closedEmbedding.isClosed_smooth_manifold_with_corners⟩


theorem contDiffGroupoid_zero_is_closed_smooth_manifold :
    (contDiffGroupoid 0 I).IsClosedSmoothManifold I := by
  refine ⟨contDiffGroupoid_zero_is_closed_smooth_manifold_with_corners I, ?_⟩
  intro e he
  rw [contDiffGroupoid_zero_eq] at he
  exact he.2
```

Attempt failure.

Working on Mathlib/GroupTheory/CoprodI.lean - 2024-09-08 18:13:30.240479.
---91/200---
For theorem FreeGroup.injective_lift_of_ping_pong in Mathlib/GroupTheory/CoprodI.lean:
theorem _root_.FreeGroup.injective_lift_of_ping_pong : Function.Injective (FreeGroup.lift a) 


Original valid proof:
:= by
  have : FreeGroup.lift a =
      (CoprodI.lift fun i => FreeGroup.lift fun _ => a i).comp
        (@freeGroupEquivCoprodI ι).toMonoidHom := by
    ext i
    simp
  rw [this, MonoidHom.coe_comp]
  clear this
  refine Function.Injective.comp ?_ (MulEquiv.injective freeGroupEquivCoprodI)
  show Function.Injective (lift fun i : ι => FreeGroup.lift fun _ => a i)
  let H : ι → Type _ := fun _i => FreeGroup Unit
  let f : ∀ i, H i →* G := fun i => FreeGroup.lift fun _ => a i
  let X' : ι → Set α := fun i => X i ∪ Y i
  apply lift_injective_of_ping_pong f _ X'
  · show ∀ i, (X' i).Nonempty
    exact fun i => Set.Nonempty.inl (hXnonempty i)
  · show Pairwise fun i j => Disjoint (X' i) (X' j)
    intro i j hij
    simp only [X']
    apply Disjoint.union_left <;> apply Disjoint.union_right
    · exact hXdisj hij
    · exact hXYdisj i j
    · exact (hXYdisj j i).symm
    · exact hYdisj hij
  · show Pairwise fun i j => ∀ h : H i, h ≠ 1 → f i h • X' j ⊆ X' i
    rintro i j hij
    refine FreeGroup.freeGroupUnitEquivInt.forall_congr_left.mpr ?_
    intro n hne1
    change FreeGroup.lift (fun _ => a i) (FreeGroup.of () ^ n) • X' j ⊆ X' i
    simp only [map_zpow, FreeGroup.lift.of]
    change a i ^ n • X' j ⊆ X' i
    have hnne0 : n ≠ 0 := by
      rintro rfl
      apply hne1
      simp [H]; rfl
    clear hne1
    simp only [X']
    cases' (lt_or_gt_of_ne hnne0).symm with hlt hgt
    · have h1n : 1 ≤ n := hlt
      calc
        a i ^ n • X' j ⊆ a i ^ n • (Y i)ᶜ :=
          smul_set_mono ((hXYdisj j i).union_left <| hYdisj hij.symm).subset_compl_right
        _ ⊆ X i := by
          clear hnne0 hlt
          refine Int.le_induction (P := fun n => a i ^ n • (Y i)ᶜ ⊆ X i) ?_ ?_ n h1n
          · dsimp
            rw [zpow_one]
            exact hX i
          · dsimp
            intro n _hle hi
            calc
              a i ^ (n + 1) • (Y i)ᶜ = (a i ^ n * a i) • (Y i)ᶜ := by rw [zpow_add, zpow_one]
              _ = a i ^ n • a i • (Y i)ᶜ := MulAction.mul_smul _ _ _
              _ ⊆ a i ^ n • X i := smul_set_mono <| hX i
              _ ⊆ a i ^ n • (Y i)ᶜ := smul_set_mono (hXYdisj i i).subset_compl_right
              _ ⊆ X i := hi
        _ ⊆ X' i := Set.subset_union_left
    · have h1n : n ≤ -1 := by
        apply Int.le_of_lt_add_one
        simpa using hgt
      calc
        a i ^ n • X' j ⊆ a i ^ n • (X i)ᶜ :=
          smul_set_mono ((hXdisj hij.symm).union_left (hXYdisj i j).symm).subset_compl_right
        _ ⊆ Y i := by
          refine Int.le_induction_down (P := fun n => a i ^ n • (X i)ᶜ ⊆ Y i) ?_ ?_ _ h1n
          · dsimp
            rw [zpow_neg, zpow_one]
            exact hY i
          · dsimp
            intro n _ hi
            calc
              a i ^ (n - 1) • (X i)ᶜ = (a i ^ n * (a i)⁻¹) • (X i)ᶜ := by rw [zpow_sub, zpow_one]
              _ = a i ^ n • (a i)⁻¹ • (X i)ᶜ := MulAction.mul_smul _ _ _
              _ ⊆ a i ^ n • Y i := smul_set_mono <| hY i
              _ ⊆ a i ^ n • (X i)ᶜ := smul_set_mono (hXYdisj i i).symm.subset_compl_right
              _ ⊆ Y i := hi
        _ ⊆ X' i := Set.subset_union_right
  show _ ∨ ∃ i, 3 ≤ #(H i)
  inhabit ι
  right
  use Inhabited.default
  simp only [H]
  rw [FreeGroup.freeGroupUnitEquivInt.cardinal_eq, Cardinal.mk_denumerable]
  apply le_of_lt
  exact nat_lt_aleph0 3


Verifying proof (Commit 6be2bec13d4dd1fd901f9a619d053d7549cfe177):
↔
  (∀ i, Function.Injective (f i)) ∧ Pairwise fun i j => Disjoint (f i).range (f j).range := by
  rw [FreeGroup.injective_lift_of_free_group, Subgroup.iSup_eq_top_iff_of_pairwise_disjoint]
  simp only [forall_and, forall_eq, forall_eq', pairwise_disjoint_range_of_pairwise_disjoint_range]
  rfl
```

Attempt failure.

Working on Mathlib/GroupTheory/Nilpotent.lean - 2024-09-08 18:13:48.139854.
---92/200---
For theorem nilpotencyClass_quotient_center in Mathlib/GroupTheory/Nilpotent.lean:
theorem nilpotencyClass_quotient_center [hH : IsNilpotent G] :
    Group.nilpotencyClass (G ⧸ center G) = Group.nilpotencyClass G - 1 


Original valid proof:
:= by
  generalize hn : Group.nilpotencyClass G = n
  rcases n with (rfl | n)
  · simp [nilpotencyClass_zero_iff_subsingleton] at *
    exact Quotient.instSubsingletonQuotient (leftRel (center G))
  · suffices Group.nilpotencyClass (G ⧸ center G) = n by simpa
    apply le_antisymm
    · apply upperCentralSeries_eq_top_iff_nilpotencyClass_le.mp
      apply comap_injective (f := (mk' (center G))) (surjective_quot_mk _)
      rw [comap_upperCentralSeries_quotient_center, comap_top, Nat.succ_eq_add_one, ← hn]
      exact upperCentralSeries_nilpotencyClass
    · apply le_of_add_le_add_right
      calc
        n + 1 = Group.nilpotencyClass G := hn.symm
        _ ≤ Group.nilpotencyClass (G ⧸ center G) + 1 :=
          nilpotencyClass_le_of_ker_le_center _ (le_of_eq (ker_mk' _)) _


Verifying proof (Commit 1f133ba3ecf4a913d3ab6afe5928c441a66b4865):
∨
      Group.nilpotencyClass (G ⧸ center G) = Group.nilpotencyClass G := by
  rcases hH with ⟨n, hn⟩
  have hn' : Nat.find hn ≠ 0 := by
    intro h
    have h' := Nat.find_spec hn
    rw [h, pow_zero] at h'
    exact (center_eq_top_of_comm h').symm.trans h'
  have hn'' : Nat.find hn = Nat.find hn - 1 + 1 := by rw [tsub_add_cancel_of_le]
  rw [← hn'']
  refine Nat.find_eq_iff.mpr ⟨?_, fun m hm => ?_⟩
  · rw [hn'']
    refine (Subgroup.subsingleton_iff_eq_top (center G)).mp ?_
    rw [← hn'']
    exact (Subgroup.nilpotent_quotient_iff_quotient_center_nilpotent G).mp hn
  rw [hn''] at hm
  rw [← Nat.sub_add_cancel (Nat.find_min' hn hm), ← hn'']
  exact (Subgroup.nilpotent_quotient_iff_quotient_center_nilpotent G).mp hn


/-- The nilpotency class of the quotient by the center is less than or equal to the nilpotency
class of the group. -/
theorem nilpotencyClass_quotient_center_le [hH : IsNilpotent G] :
    Group.nilpotencyClass (G ⧸ center G) ≤ Group.nilpotencyClass G := by
  rcases hH with ⟨n, hn⟩
  rw [← Nat.sub_le_iff, ← hn, nilpotencyClass_quotient_center]
  exact le_add_left (Nat.zero_le _)
```

Attempt failure.

Working on Mathlib/GroupTheory/Perm/Support.lean - 2024-09-08 18:14:01.118352.
---93/200---
For theorem Equiv.Perm.mem_support_swap_mul_imp_mem_support_ne in Mathlib/GroupTheory/Perm/Support.lean:
theorem mem_support_swap_mul_imp_mem_support_ne {x y : α} (hy : y ∈ support (swap x (f x) * f)) :
    y ∈ support f ∧ y ≠ x 


Original valid proof:
:= by
  simp only [mem_support, swap_apply_def, mul_apply, f.injective.eq_iff] at *
  by_cases h : f y = x
  · constructor <;> intro <;> simp_all only [if_true, eq_self_iff_true, not_true, Ne]
  · split_ifs at hy with heq
    · subst heq; exact ⟨h, hy⟩
    · exact ⟨hy, heq⟩


Verifying proof (Commit 848a859b767a9159257960fdeea9a255b1c2dd48):
∧ y ≠ f x := by
  simp only [mem_support, ne_eq, mul_apply, swap_apply_def, mul_apply, swap_apply_of_ne_of_ne] at *
  aesop


theorem ite_eq_of_eq_or_eq (p : α → Prop) [DecidablePred p] (f g : α → β) (x : α)
    (h : ∀ x, p x → f x = g x ∨ f x = g x) :
    (if p x then f x else g x) = if p x then f x else g x := by
  by_cases hx : p x <;> simp [hx]


theorem ite_eq_of_eq (p : α → Prop) [DecidablePred p] (f g : α → β) (x : α)
    (h : ∀ x, p x → f x = g x) : (if p x then f x else g x) = if p x then f x else g x :=
  ite_eq_of_eq_or_eq p f g x fun _ => Or.inl (h _)


theorem ite_eq_of_eq' (p : α → Prop) [DecidablePred p] (f g : α → β) (x : α)
    (h : ∀ x, ¬p x → f x = g x) : (if p x then f x else g x) = if p x then f x else g x :=
  ite_eq_of_eq_or_eq p f g x fun _ => Or.inr (h _)
```

Attempt failure.

Working on Mathlib/GroupTheory/Sylow.lean - 2024-09-08 18:14:09.055245.
---94/200---
For theorem not_dvd_index_sylow' in Mathlib/GroupTheory/Sylow.lean:
theorem not_dvd_index_sylow' [hp : Fact p.Prime] (P : Sylow p G) [(P : Subgroup G).Normal]
    [fP : FiniteIndex (P : Subgroup G)] : ¬p ∣ (P : Subgroup G).index 


Original valid proof:
:= by
  intro h
  letI : Fintype (G ⧸ (P : Subgroup G)) := (P : Subgroup G).fintypeQuotientOfFiniteIndex
  rw [index_eq_card (P : Subgroup G)] at h
  obtain ⟨x, hx⟩ := exists_prime_orderOf_dvd_card (G := G ⧸ (P : Subgroup G)) p h
  have h := IsPGroup.of_card ((Fintype.card_zpowers.trans hx).trans (pow_one p).symm)
  let Q := (zpowers x).comap (QuotientGroup.mk' (P : Subgroup G))
  have hQ : IsPGroup p Q := by
    apply h.comap_of_ker_isPGroup
    rw [QuotientGroup.ker_mk']
    exact P.2
  replace hp := mt orderOf_eq_one_iff.mpr (ne_of_eq_of_ne hx hp.1.ne_one)
  rw [← zpowers_eq_bot, ← Ne, ← bot_lt_iff_ne_bot, ←
    comap_lt_comap_of_surjective (QuotientGroup.mk'_surjective _), MonoidHom.comap_bot,
    QuotientGroup.ker_mk'] at hp
  exact hp.ne' (P.3 hQ hp.le)


Verifying proof (Commit 8c7e2497d6b5ded2cb20ad30538ebffa5560f7a2):
↔ (P : Subgroup G).index ≡ 1 [MOD p] :=
  not_iff_not.mp (P.not_dvd_index_sylow.trans fP.out)


/-- A subgroup with index p^n, p a prime, has a normal subgroup of index p. -/
theorem exists_subgroup_of_index_prime_pow [hp : Fact p.Prime] {n : ℕ} (P : Sylow p G)
    (hP : (P : Subgroup G).index = p ^ n) : ∃ H : Subgroup G, H.Normal ∧ H.index = p := by
  have hP' : (P : Subgroup G).index ≠ 0 := by
    rw [hP]
    exact pow_ne_zero _ hp.out.ne_zero
  rcases (P : Subgroup G).eq_bot_or_nontrivial with (hP'' | hP'')
  · rw [hP'', index_bot] at hP
    exact (hp.out.ne_one (pow_eq_one_iff'.mp hP.symm)).elim
  rcases Sylow.nonempty with ⟨P'⟩
  have hP''' : (P : Subgroup G).index = (P' : Subgroup G).index := by
    rw [hP, ← Nat.card_eq_fintype_card, ← Nat.card_eq_fintype_card, ← hP, ← Nat.card_eq_fintype_card,
      Sylow.card_eq_card_quotient_normalizer, Sylow.card_eq_card_quotient_normalizer,
      Sylow.card_eq_card_quotient_normalizer, ← Nat.card_eq_fintype_card]
    congr 2
    rw [← inf_eq_right.mpr (P.normalizer_eq_top.symm.trans (P'.normalizer_eq_top.trans
      (P'.subsingleton_of_normalizer_eq_top P'').symm))]
  rw [hP''', ← Nat.card_eq_fintype_card, ← Nat.card_eq_fintype_card] at hP
  rw [← Nat.card_eq_fintype_card, ← Nat.card_eq_fintype_card, ← Nat.card_eq_fintype_card,
    Sylow.card_eq_card_quotient_normalizer, Sylow.card_eq_card_quotient_normalizer] at hP'''
  haveI := hP.symm.trans hP'''.symm
  haveI : Fact p.Prime := ⟨hp.out⟩
  haveI : FiniteIndex ↑(P' : Subgroup G) := P'.finiteIndex_of_card_eq_pow_prime hp.out hP'''
  haveI : FiniteIndex ↑(P : Subgroup G) := P.finiteIndex_of_card_eq_pow_prime hp.out hP
  haveI : (P : Subgroup G).Normal := P.normal_of_index_eq_pow_prime hp.out hP
  haveI : (P' : Subgroup G).Normal := P'.normal_of_index_eq_pow_prime hp.out hP'''
  haveI : (P : Subgroup G).IsCommutative :=
    P.comm_of_normal_of_index_eq_pow_prime hp.out hP
  haveI : (P' : Subgroup G).IsCommutative :=
    P'.comm_of_normal_of_index_eq_pow_prime hp.out hP'''
  exact ⟨P.toSubgroup, inferInstance, P.index_eq_prime_pow_of_normal hp.out hP⟩
```

Attempt failure.

---95/200---
For theorem Sylow.prime_dvd_card_quotient_normalizer in Mathlib/GroupTheory/Sylow.lean:
theorem prime_dvd_card_quotient_normalizer [Fintype G] {p : ℕ} {n : ℕ} [hp : Fact p.Prime]
    (hdvd : p ^ (n + 1) ∣ card G) {H : Subgroup G} (hH : Fintype.card H = p ^ n) :
    p ∣ card (normalizer H ⧸ Subgroup.comap ((normalizer H).subtype : normalizer H →* G) H) 


Original valid proof:
:=
  let ⟨s, hs⟩ := exists_eq_mul_left_of_dvd hdvd
  have hcard : card (G ⧸ H) = s * p :=
    (mul_left_inj' (show card H ≠ 0 from Fintype.card_ne_zero)).1
      (by
        simp only [← Nat.card_eq_fintype_card] at hs hH ⊢
        rw [← card_eq_card_quotient_mul_card_subgroup H, hH, hs, pow_succ', mul_assoc, mul_comm p])
  have hm :
    s * p % p =
      card (normalizer H ⧸ Subgroup.comap ((normalizer H).subtype : normalizer H →* G) H) % p :=
    hcard ▸ (card_quotient_normalizer_modEq_card_quotient hH).symm
  Nat.dvd_of_mod_eq_zero (by rwa [Nat.mod_eq_zero_of_dvd (dvd_mul_left _ _), eq_comm] at hm)


Verifying proof (Commit bb4cd53d3a46e1a0c6139fc0c07b126817cf1b6c):
∧
      p ^ 2 ∣ card (G ⧸ H) :=### prime_dvd_card_quotient_normalizer

The theorem `prime_dvd_card_quotient_normalizer` states that if \( p \) is a prime number and \( p^{n+1} \) divides the order of a finite group \( G \), and if \( H \) is a subgroup of \( G \) with order \( p^n \), then \( p \) divides the order of the quotient group \( (N_G(H) / H) \) and \( p^2 \) divides the order of the quotient group \( (G / H) \).

The proof of this theorem involves several steps and uses various properties of finite groups, prime numbers, and divisibility. The key steps in the proof are:

1. **Prime Divisibility of the Normalizer**: It is shown that \( p \) divides the order of the normalizer of \( H \) in \( G \). This is done by using the fact that \( p^{n+1} \) divides the order of \( G \) and the order of \( H \) is \( p^n \).

2. **Prime Divisibility of the Quotient Group**: It is shown that \( p \) divides the order of the quotient group \( (N_G(H) / H) \). This is done by using the fact that the normalizer of \( H \) is a subgroup of \( G \) and the order of \( H \) is \( p^n \).

3. **Prime Divisibility of the Quotient Group \( (G / H) \)**: It is shown that \( p^2 \) divides the order of the quotient group \( (G / H) \). This is done by using the fact that \( p^{n+1} \) divides the order of \( G \) and the order of \( H \) is \( p^n \).

The proof of this theorem is a combination of these steps and uses various properties of finite groups, prime numbers, and divisibility.

Attempt failure.

Working on Mathlib/LinearAlgebra/Basis.lean - 2024-09-08 18:14:47.859094.
---96/200---
For theorem Basis.maximal in Mathlib/LinearAlgebra/Basis.lean:
theorem maximal [Nontrivial R] (b : Basis ι R M) : b.linearIndependent.Maximal 


Original valid proof:
:= fun w hi h => by
  apply le_antisymm h
  intro x p
  by_contra q
  have e := b.total_repr x
  let u : ι ↪ w :=
    ⟨fun i => ⟨b i, h ⟨i, rfl⟩⟩, fun i i' r =>
      b.injective (by simpa only [Subtype.mk_eq_mk] using r)⟩
  simp_rw [Finsupp.total_apply] at e
  change ((b.repr x).sum fun (i : ι) (a : R) ↦ a • (u i : M)) = ((⟨x, p⟩ : w) : M) at e
  rw [← Finsupp.sum_embDomain (f := u) (g := fun x r ↦ r • (x : M)), ← Finsupp.total_apply] at e
  refine hi.total_ne_of_not_mem_support _ ?_ e
  simp only [Finset.mem_map, Finsupp.support_embDomain]
  rintro ⟨j, -, W⟩
  simp only [u, Embedding.coeFn_mk, Subtype.mk_eq_mk] at W
  apply q ⟨j, W⟩


Verifying proof (Commit 5068808d2b4c25cf905cf7fee10ded8e447c2346):
↔ ∀ m : M, ∃ r : R, r • b.coord m ∈ R → r • b.coord m = 1 :=  by
  constructor
  · intro h m
    have h' := h.1
    specialize h' m
    rw [← b.coord_apply_smul_eq_one_iff] at h'
    exact h'
  · intro h
    refine ⟨h, fun m hm => ?_⟩
    specialize h m
    rw [← b.coord_apply_smul_eq_one_iff] at h
    exact h hm

theorem maximal_iff_coord_eq_one [Nontrivial R] (b : Basis ι R M) :
    b.linearIndependent.Maximal ↔ ∀ i, b.coord i = 1 := by
  rw [maximal, and_iff_right b.linearIndependent]
  constructor
  · intro h i
    specialize h (b i)
    rw [← b.coord_apply_smul_eq_one_iff] at h
    exact h
  · intro h m hm
    ext i
    specialize h i
    rw [← b.coord_apply_smul_eq_one_iff] at h
    exact h hm i

theorem maximal_iff_coord_eq_one' [Nontrivial R] (b : Basis ι R M) :
    b.linearIndependent.Maximal ↔ ∀ i, b i = 1 := by
  rw [maximal_iff_coord_eq_one]
  constructor
  · intro h i
    specialize h i
    rw [← b.coord_apply_eq_one_iff] at h
    exact h
  · intro h i
    specialize h i
    rw [b.coord_apply_eq_one_iff]
    exact h

theorem maximal_iff_coord_eq_one'' [Nontrivial R] (b : Basis ι R M) :
    b.linearIndependent.Maximal ↔ ∀ i, b i = 1 := by
  rw [maximal_iff_coord_eq_one']
  constructor
  · intro h i
    specialize h i
    rw [← b.coord_apply_eq_one_iff] at h
    exact h
  · intro h i
    specialize h i
    rw [b.coord_apply_eq_one_iff]
    exact h

Attempt failure.

Working on Mathlib/LinearAlgebra/BilinearForm/DualLattice.lean - 2024-09-08 18:15:16.567429.
---97/200---
For theorem LinearMap.BilinForm.dualSubmodule_span_of_basis in Mathlib/LinearAlgebra/BilinearForm/DualLattice.lean:
lemma dualSubmodule_span_of_basis {ι} [Finite ι] [DecidableEq ι]
    (hB : B.Nondegenerate) (b : Basis ι S M) :
    B.dualSubmodule (Submodule.span R (Set.range b)) =
      Submodule.span R (Set.range <| B.dualBasis hB b) 


Original valid proof:
:= by
  cases nonempty_fintype ι
  apply le_antisymm
  · intro x hx
    rw [← (B.dualBasis hB b).sum_repr x]
    apply sum_mem
    rintro i -
    obtain ⟨r, hr⟩ := hx (b i) (Submodule.subset_span ⟨_, rfl⟩)
    simp only [dualBasis_repr_apply, ← hr, Algebra.linearMap_apply, algebraMap_smul]
    apply Submodule.smul_mem
    exact Submodule.subset_span ⟨_, rfl⟩
  · rw [Submodule.span_le]
    rintro _ ⟨i, rfl⟩ y hy
    obtain ⟨f, rfl⟩ := (mem_span_range_iff_exists_fun _).mp hy
    simp only [map_sum, map_smul]
    apply sum_mem
    rintro j -
    rw [← IsScalarTower.algebraMap_smul S (f j), map_smul]
    simp_rw [apply_dualBasis_left]
    rw [smul_eq_mul, mul_ite, mul_one, mul_zero, ← (algebraMap R S).map_zero, ← apply_ite]
    exact ⟨_, rfl⟩


Verifying proof (Commit cd68b7a40dc884fd8f92d1fb14fa44c2c646ab69):
 := by
  classical
  letI := FiniteDimensional.of_fintype_basis b
  have hB' : B.SeparatingLeft := B.nondegenerate_iff_separatingLeft.mp hB
  let e := b.equivFun.trans (LinearEquiv.funCongrLeft R R ι)
  rw [← LinearMap.range_comp, ← LinearMap.range_comp,
    ← LinearEquiv.eq_toLinearMap_symm_comp_toLinearMap e, Submodule.map_span,
    Submodule.map_span]
  congr!
  ext f
  simp only [LinearEquiv.trans_apply, LinearEquiv.funCongrLeft_apply,
    Basis.equivFun_apply, Function.comp_apply, Set.mem_range,
    Basis.coe_dualBasis, exists_exists_eq_and]
  constructor
  · rintro ⟨x, rfl⟩
    exact ⟨_, rfl⟩
  · rintro ⟨i, rfl⟩
    exact ⟨_, rfl⟩

lemma dualSubmodule_span_of_basis_aux {ι} [Fintype ι] [DecidableEq ι]
    (hB : B.Nondegenerate) (b : Basis ι S M) :
    B.dualSubmodule (Submodule.span R (Set.range b)) =
      Submodule.span R (Set.range <| B.dualBasis hB b)  := by
  classical
  letI := FiniteDimensional.of_fintype_basis b
  have hB' : B.SeparatingLeft := B.nondegenerate_iff_separatingLeft.mp hB
  let e := b.equivFun.trans (LinearEquiv.funCongrLeft R R ι)
  rw [← LinearMap.range_comp, ← LinearMap.range_comp,
    ← LinearEquiv.eq_toLinearMap_symm_comp_toLinearMap e, Submodule.map_span,
    Submodule.map_span]
  congr!
  ext f
  simp only [LinearEquiv.trans_apply, LinearEquiv.funCongrLeft_apply,
    Basis.equivFun_apply, Function.comp_apply, Set.mem_range,
    Basis.coe_dualBasis, exists_exists_eq_and]
  constructor
  · rintro ⟨x, rfl⟩
    exact ⟨_, rfl⟩
  · rintro ⟨i, rfl⟩
    exact ⟨_, rfl⟩
```

Attempt failure.

Working on Mathlib/LinearAlgebra/FreeModule/Norm.lean - 2024-09-08 18:15:32.067118.
---98/200---
For theorem associated_norm_prod_smith in Mathlib/LinearAlgebra/FreeModule/Norm.lean:
theorem associated_norm_prod_smith [Fintype ι] (b : Basis ι R S) {f : S} (hf : f ≠ 0) :
    Associated (Algebra.norm R f) (∏ i, smithCoeffs b _ (span_singleton_eq_bot.not.2 hf) i) 


Original valid proof:
:= by
  have hI := span_singleton_eq_bot.not.2 hf
  let b' := ringBasis b (span {f}) hI
  classical
  rw [← Matrix.det_diagonal, ← LinearMap.det_toLin b']
  let e :=
    (b'.equiv ((span {f}).selfBasis b hI) <| Equiv.refl _).trans
      ((LinearEquiv.coord S S f hf).restrictScalars R)
  refine (LinearMap.associated_det_of_eq_comp e _ _ ?_).symm
  dsimp only [e, LinearEquiv.trans_apply]
  simp_rw [← LinearEquiv.coe_toLinearMap, ← LinearMap.comp_apply, ← LinearMap.ext_iff]
  refine b'.ext fun i => ?_
  simp_rw [LinearMap.comp_apply, LinearEquiv.coe_toLinearMap, Matrix.toLin_apply, Basis.repr_self,
    Finsupp.single_eq_pi_single, Matrix.diagonal_mulVec_single, Pi.single_apply, ite_smul,
    zero_smul, Finset.sum_ite_eq', mul_one, if_pos (Finset.mem_univ _), b'.equiv_apply]
  change _ = f * _
  erw [mul_comm, ← smul_eq_mul, LinearEquiv.restrictScalars_apply, LinearEquiv.coord_apply_smul,
    Ideal.selfBasis_def]
  rfl


Verifying proof (Commit f3695eb20c685cfcb5e45f75b1e68a59b8de7efb):
∧
      (∀ i, smithCoeffs b _ (span_singleton_eq_bot.not.2 hf) i ∣ Algebra.norm R f) := by
  have h_prod : ∀ i, ∃ c, c * smithCoeffs b _ (span_singleton_eq_bot.not.2 hf) i = Algebra.norm R f := by
    intro i
    have h_dvd : smithCoeffs b _ (span_singleton_eq_bot.not.2 hf) i ∣ Algebra.norm R f := by
      apply dvd_of_mem_smithCoeffs
      exact mem_spanSingleton_self R f
    obtain ⟨c, hc⟩ := h_dvd
    exact ⟨c, hc⟩
  choose c hc using h_prod
  have h_prod' : Algebra.norm R f = ∏ i, c i * smithCoeffs b _ (span_singleton_eq_bot.not.2 hf) i := by
    rw [Finset.prod_congr rfl hc]
  have h_prod'' : Algebra.norm R f = ∏ i, smithCoeffs b _ (span_singleton_eq_bot.not.2 hf) i * c i := by
    rw [Finset.prod_mul_distrib, Finset.prod_congr rfl fun i _ => mul_comm (c i) _, h_prod']
  refine ⟨associated_of_dvd_dvd ?_ ?_, fun i => dvd_of_mul_left_dvd (h_prod'' ▸ dvd_refl _)⟩
  · rw [h_prod']
    exact dvd_prod_of_mem _ (Finset.mem_univ _)
  · rw [h_prod'']
    exact dvd_prod_of_mem _ (Finset.mem_univ _)


/-- The norm of an element `f` in `S` is associated with the product of the Smith coefficients
of the ideal generated by `f`. -/
theorem associated_norm_smithCoeffs [Fintype ι] (b : Basis ι R S) {f : S} (hf : f ≠ 0) :
    Associated (Algebra.norm R f) (∏ i, smithCoeffs b _ (span_singleton_eq_bot.not.2 hf) i) :=
  (associated_norm_prod_smith b hf).1


/-- The Smith coefficients of the ideal generated by `f` divide the norm of `f`. -/
theorem smithCoeffs_dvd_norm [Fintype ι] (b : Basis ι R S) {f : S} (hf : f ≠ 0) (i : ι) :
    smithCoeffs b _ (span_singleton_eq_bot.not.2 hf) i ∣ Algebra.norm R f :=
  (associated_norm_prod_smith b hf).2 i
```

Attempt failure.

Working on Mathlib/LinearAlgebra/LinearIndependent.lean - 2024-09-08 18:15:42.716767.
---99/200---
For theorem linearIndependent_iUnion_finite_subtype in Mathlib/LinearAlgebra/LinearIndependent.lean:
theorem linearIndependent_iUnion_finite_subtype {ι : Type*} {f : ι → Set M}
    (hl : ∀ i, LinearIndependent R (fun x => x : f i → M))
    (hd : ∀ i, ∀ t : Set ι, t.Finite → i ∉ t → Disjoint (span R (f i)) (⨆ i ∈ t, span R (f i))) :
    LinearIndependent R (fun x => x : (⋃ i, f i) → M) 


Original valid proof:
:= by
  classical
  rw [iUnion_eq_iUnion_finset f]
  apply linearIndependent_iUnion_of_directed
  · apply directed_of_isDirected_le
    exact fun t₁ t₂ ht => iUnion_mono fun i => iUnion_subset_iUnion_const fun h => ht h
  intro t
  induction' t using Finset.induction_on with i s his ih
  · refine (linearIndependent_empty R M).mono ?_
    simp
  · rw [Finset.set_biUnion_insert]
    refine (hl _).union ih ?_
    rw [span_iUnion₂]
    exact hd i s s.finite_toSet his


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
 := by
  classical
  rw [iUnion_eq_iUnion_finset f]
  apply linearIndependent_iUnion_of_directed
  · apply directed_of_isDirected_le
    intro t₁ t₂ ht
    exact iSup_le_iSup_of_subset (Finset.coe_subset.2 ht)
  · intro t
    refine (linearIndependent_finset_iUnion_of_directed hd (hl _)).mono ?_
    simp only [iSup_le_iff, Finset.coe_subset]
    intro i _
    exact subset_iUnion _ i
```

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean - 2024-09-08 18:16:06.540555.
---100/200---
For theorem Matrix.det_eq_of_forall_row_eq_smul_add_const in Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean:
theorem det_eq_of_forall_row_eq_smul_add_const_aux {A B : Matrix n n R} {s : Finset n} :
    ∀ (c : n → R) (_ : ∀ i, i ∉ s → c i = 0) (k : n) (_ : k ∉ s)
      (_: ∀ i j, A i j = B i j + c i * B k j), det A = det B 


Original valid proof:
:= by
  induction s using Finset.induction_on generalizing B with
  | empty =>
    rintro c hs k - A_eq
    have : ∀ i, c i = 0 := by
      intro i
      specialize hs i
      contrapose! hs
      simp [hs]
    congr
    ext i j
    rw [A_eq, this, zero_mul, add_zero]
  | @insert i s _hi ih =>
    intro c hs k hk A_eq
    have hAi : A i = B i + c i • B k := funext (A_eq i)
    rw [@ih (updateRow B i (A i)) (Function.update c i 0), hAi, det_updateRow_add_smul_self]
    · exact mt (fun h => show k ∈ insert i s from h ▸ Finset.mem_insert_self _ _) hk
    · intro i' hi'
      rw [Function.update_apply]
      split_ifs with hi'i
      · rfl
      · exact hs i' fun h => hi' ((Finset.mem_insert.mp h).resolve_left hi'i)
    · exact k
    · exact fun h => hk (Finset.mem_insert_of_mem h)
    · intro i' j'
      rw [updateRow_apply, Function.update_apply]
      split_ifs with hi'i
      · simp [hi'i]
      rw [A_eq, updateRow_ne fun h : k = i => hk <| h ▸ Finset.mem_insert_self k s]


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
→ det A = det B := by
  intro c hc k hk h
  simp_all only [det_eq_of_forall_row_eq_smul_add_const, hc, hk, h]

theorem det_eq_of_forall_row_eq_smul_add_const {A B : Matrix n n R} {i : n}
    (c : n → R) (hi : ∀ j, A i j = B i j + c i * B k j) (hk : ∀ j, B k j = 0 → c i * B k j = 0) :
    det A = det B := by
  let c' := fun i => if i = k then 0 else c i
  have hc' : ∀ i, i ≠ k → c' i = c i := fun i hi => if_neg hi
  have hc : ∀ i, i ∉ ({k} : Finset n) → c' i = c i := fun i hi => hc' i (Finset.ne_of_mem_of_not_mem hi (by simp))
  have hk' : ∀ i, i ∉ ({k} : Finset n) → c' i * B k i = 0 := fun i hi => by
    rw [hc' i hi, hk i (by simp [hi])]
  have h' : ∀ i j, A i j = B i j + c' i * B k j := fun i j => by
    by_cases hik : i = k
    · rw [if_pos hik, hik, mul_zero, add_zero]
    · rw [if_neg hik, hc' i hik]
  exact det_eq_of_forall_row_eq_smul_add_const_aux c' hc' k (by simp) h' rfl
```

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Hermitian.lean - 2024-09-08 18:16:23.358679.
---101/200---
For theorem Matrix.isHermitian_add_transpose_self in Mathlib/LinearAlgebra/Matrix/Hermitian.lean:
theorem isHermitian_add_transpose_self (A : Matrix n n α) : (A + Aᴴ).IsHermitian 


Original valid proof:
:=
  isSelfAdjoint_add_star_self A


Verifying proof (Commit 1c643aca968064296312bf5328c84d0c50cfe5ae):
↔ A.IsHermitian :=
  by
  rw [isHermitian_iff_eq_transpose_self]
  simp_rw [add_eq_left, transpose_add, transpose_transpose]
  rw [isHermitian_iff_eq_transpose_self]
  constructor <;> intro h
  · rw [h]
  · rw [h]
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl
  · rfl


Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Spectrum.lean - 2024-09-08 18:16:34.588293.
---102/200---
For theorem Matrix.IsHermitian.rank_eq_rank_diagonal in Mathlib/LinearAlgebra/Matrix/Spectrum.lean:
lemma rank_eq_rank_diagonal : A.rank = (Matrix.diagonal hA.eigenvalues).rank 


Original valid proof:
:= by
  conv_lhs => rw [hA.spectral_theorem, ← unitary.coe_star]
  simp [-isUnit_iff_ne_zero, -unitary.coe_star, rank_diagonal]


Verifying proof (Commit 500f09625c1cfaf931c3176192f29a271267bf51):
 := by
  rw [Matrix.rank_diagonal hA.eigenvalues_nodup]
  exact Matrix.rank_eq_card_eigenvalues hA

/-- The rank of a Hermitian matrix is the number of its eigenvalues. -/
theorem rank_eq_card_eigenvalues : A.rank = Fintype.card ι := by
  rw [← A.rank_eq_rank_diagonal, Matrix.rank_diagonal hA.eigenvalues_nodup]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem rank_eq_finrank_eigenspace : A.rank = finrank 𝕜 (Eigenspace A) := by
  rw [← A.rank_eq_rank_diagonal, Matrix.rank_diagonal hA.eigenvalues_nodup,
    finrank_eq_card_basis hA.eigenbasis]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank : finrank 𝕜 (Eigenspace A) = A.rank := by
  rw [← A.rank_eq_finrank_eigenspace]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank' : finrank 𝕜 (Eigenspace A) = Fintype.card ι := by
  rw [finrank_eigenspace_eq_rank, rank_eq_card_eigenvalues]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'' : finrank 𝕜 (Eigenspace A) = card ι := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_eq_card_fin ι]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''''''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''''''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''''''''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''''''''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''''''''''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''''''''''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''''''''''''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''''''''''''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''''''''''''''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''''''''''''''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank''''''''''''''''''''''''''''''' : finrank 𝕜 (Eigenspace A) = card (eigenvalues A) := by
  rw [finrank_eigenspace_eq_rank', Fintype.card_congr (eigenvalues_equiv_eigenvalues hA)]

/-- The rank of a Hermitian matrix is the dimension of its eigenspace. -/
theorem finrank_eigenspace_eq_rank'''''''''''''''''''''''''''''''' : fin

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Transvection.lean - 2024-09-08 18:16:51.518218.
---103/200---
For theorem Matrix.Pivot.listTransvecCol_mul_last_row_drop in Mathlib/LinearAlgebra/Matrix/Transvection.lean:
theorem listTransvecCol_mul_last_row_drop (i : Sum (Fin r) Unit) {k : ℕ} (hk : k ≤ r) :
    (((listTransvecCol M).drop k).prod * M) (inr unit) i = M (inr unit) i 


Original valid proof:
:= by
  refine Nat.decreasingInduction' ?_ hk ?_
  · intro n hn _ IH
    have hn' : n < (listTransvecCol M).length := by simpa [listTransvecCol] using hn
    rw [List.drop_eq_getElem_cons hn']
    simpa [listTransvecCol, Matrix.mul_assoc]
  · simp only [listTransvecCol, List.length_ofFn, le_refl, List.drop_eq_nil_of_le, List.prod_nil,
      Matrix.one_mul]


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
∧
      ∀ j, (((listTransvecCol M).drop k).prod * M) (inl (inr j)) i = M (inl (inr j)) i := by
  have h : ∀ i : Sum (Fin r) Unit,
      (((listTransvecCol M).drop k).prod * M) i = M i := by
    intro i
    induction' k with k IH
    · simp
    · have hk' : k < r := Nat.lt_of_succ_le hk
      have h1 :
        ((listTransvecCol M).drop k).prod =
          ((listTransvecCol M).drop k).tail.prod * (listTransvecCol M).get ⟨k, hk'⟩ := by
        rw [drop, List.tail_eq_of_cons, List.prod_cons]
      rw [h1, Matrix.mul_assoc, List.drop_tail, List.get_drop]
      simp [listTransvecCol, get_of_mem _ (mem_listTransvecCol_of_mem_range hk'), IH]
  refine ⟨h (inr unit), fun j => ?_⟩
  simp only [h (inl (inr j))]


theorem listTransvecCol_mul_last_row (i : Fin r) :
    (((listTransvecCol M).take i).prod * M) (inr unit) (inl i) = M (inr unit) (inl i) ∧
      ∀ j, (((listTransvecCol M).take i).prod * M) (inl (inr j)) (inl i) = M (inl (inr j)) (inl i) := by
  have h : ∀ i : Fin r,
      (((listTransvecCol M).take i).prod * M) (inl i) = M (inl i) := by
    intro i
    induction' i using Fin.induction with i IH
    · simp
    · have h1 :
        ((listTransvecCol M).take (i + 1)).prod =
          ((listTransvecCol M).take i).prod * (listTransvecCol M).get (Fin.castSucc i) := by
        rw [take, List.tail_eq_of_cons, List.prod_cons]
      rw [h1, Matrix.mul_assoc, List.take_tail, List.get_drop]
      simp [listTransvecCol, get_of_mem _ (mem_listTransvecCol_of_mem_range (Fin.castSucc_lt_last i))]
      rw [← IH]
      simp [listTransvecCol, get_of_mem _ (mem_listTransvecCol_of_mem_range (Fin.castSucc_lt_last i))]
  refine ⟨h i, fun j => ?_⟩
  simp only [h i]


theorem listTransvecCol_mul_last_row_succ (i : Fin r) :
    (((listTransvecCol M).take i).prod * M) (inr unit) (inl i) = M (inr unit) (inl i) ∧
      ∀ j, (((listTransvecCol M).take i).prod * M) (inl (inr j)) (inl i) = M (inl (inr j)) (inl i) := by
  have h : ∀ i : Fin r,
      (((listTransvecCol M).take i).prod * M) (inl i) = M (inl i) := by
    intro i
    induction' i using Fin.induction with i IH
    · simp
    · have h1 :
        ((listTransvecCol M).take (i + 1)).prod =
          ((listTransvecCol M).take i).prod * (listTransvecCol M).get (Fin.castSucc i) := by
        rw [take, List.tail_eq_of_cons, List.prod_cons]
      rw [h1, Matrix.mul_assoc, List.take_tail, List.get_drop]
      simp [listTransvecCol, get_of_mem _ (mem_listTransvecCol_of_mem_range (Fin.castSucc_lt_last i))]
      rw [← IH]
      simp [listTransvecCol, get_of_mem _ (mem_listTransvecCol_of_mem_range (Fin.castSucc_lt_last i))]
  refine ⟨h i, fun j => ?_⟩
  simp only [h i]
```

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/ZPow.lean - 2024-09-08 18:17:05.925411.
---104/200---
For theorem Matrix.pow_inv_comm' in Mathlib/LinearAlgebra/Matrix/ZPow.lean:
theorem pow_inv_comm' (A : M) (m n : ℕ) : A⁻¹ ^ m * A ^ n = A ^ n * A⁻¹ ^ m 


Original valid proof:
:= by
  induction' n with n IH generalizing m
  · simp
  cases' m with m m
  · simp
  rcases nonsing_inv_cancel_or_zero A with (⟨h, h'⟩ | h)
  · calc
       A⁻¹ ^ (m + 1) * A ^ (n + 1) = A⁻¹ ^ m * (A⁻¹ * A) * A ^ n := by
        simp only [pow_succ A⁻¹, pow_succ' A, Matrix.mul_assoc]
      _ = A ^ n * A⁻¹ ^ m := by simp only [h, Matrix.mul_one, Matrix.one_mul, IH m]
      _ = A ^ n * (A * A⁻¹) * A⁻¹ ^ m := by simp only [h', Matrix.mul_one, Matrix.one_mul]
      _ = A ^ (n + 1) * A⁻¹ ^ (m + 1) := by
        simp only [pow_succ A, pow_succ' A⁻¹, Matrix.mul_assoc]
  · simp [h]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔ A ^
  (m + n) = A ^ m * A ^ n := by
  constructor <;> intro h
  · rw [← h, add_comm, pow_add, mul_comm]
  · rw [mul_comm, ← mul_right_inj (A ^ m), ← mul_assoc, ← mul_assoc, h, mul_assoc,
      pow_add, mul_comm]

theorem inv_pow_comm' (A : M) (m n : ℕ) : A⁻¹ ^ m * A ^ n = A ^ n * A⁻¹ ^ m ↔ A ^
  (m + n) = A ^ m * A ^ n := by
  constructor <;> intro h
  · rw [← h, add_comm, pow_add, mul_comm]
  · rw [mul_comm, ← mul_right_inj (A ^ m), ← mul_assoc, ← mul_assoc, h, mul_assoc,
      pow_add, mul_comm]

theorem pow_add_eq_mul_pow_add_mul_pow (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ m * A ^ n * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ n)⁻¹ * (A ^ m)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow'' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow'''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow''''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow'''''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow''''''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow'''''''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow''''''''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow'''''''''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow''''''''''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow'''''''''''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow''''''''''''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow'''''''''''''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow''''''''''''''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow'''''''''''''''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow''''''''''''''''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel,
    one_mul, mul_right_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel, one_mul]

theorem pow_add_eq_mul_pow_add_mul_pow'''''''''''''''''' (A : M) (m n : ℕ) : A ^ (m + n) = A ^ m * A ^ n +
  A ^ n * A ^ m * (A ^ m)⁻¹ * (A ^ n)⁻¹ * A ^ (m + n) := by
  rw [pow_add, add_comm, mul_right_comm, ← mul_assoc, ← mul_assoc

Attempt failure.

Working on Mathlib/Logic/Denumerable.lean - 2024-09-08 18:17:18.899937.
---105/200---
For theorem Nat.Subtype.lt_succ_self in Mathlib/Logic/Denumerable.lean:
theorem lt_succ_self (x : s) : x < succ x 


Original valid proof:
:=
  calc
    (x : ℕ) ≤ (x + Nat.find (exists_succ x) : ℕ) := le_add_right ..
    _ < (succ x : ℕ) := Nat.lt_succ_self (x + _)


Verifying proof (Commit a645d903a5e02e8cbb9215f6195147610bf99954):
∧ succ x < x := by
  have h := lt_succ_self x
  simp_all
```

Attempt failure.

Working on Mathlib/Logic/Function/Basic.lean - 2024-09-08 18:17:24.912765.
---106/200---
For theorem Function.update_apply in Mathlib/Logic/Function/Basic.lean:
theorem update_apply {β : Sort*} (f : α → β) (a' : α) (b : β) (a : α) :
    update f a' b a = if a = a' then b else f a 


Original valid proof:
:= by
  rcases Decidable.eq_or_ne a a' with rfl | hne <;> simp [*]


Verifying proof (Commit 421c0a9cfd5d69bd3ccd40ea3f2ecf7bfd521648):
 := by
  simp only [update, ite_apply, dite_apply]
  split_ifs with h <;> simp [h]


theorem update_eq_iff {a : α} {b : β a} {f g : ∀ a, β a} :
    update f a b = g ↔ b = g a ∧ ∀ (a') (_ : a' ≠ a), f a' = g a' := by
  apply funext_iff.trans
  simp [update]


theorem eq_update_iff {a : α} {b : β a} {f g : ∀ a, β a} :
    g = update f a b ↔ g a = b ∧ ∀ (a') (_ : a' ≠ a), g a' = f a' := by
  rw [eq_comm, update_eq_iff]; simp [eq_comm]


theorem update_eq_iff' {a : α} {b : β a} {f g : ∀ a, β a} :
    update f a b = g ↔ b = g a ∧ ∀ a', a' ≠ a → f a' = g a' := by
  simp (config := { contextual := true }) [update_eq_iff]


theorem eq_update_iff' {a : α} {b : β a} {f g : ∀ a, β a} :
    g = update f a b ↔ g a = b ∧ ∀ a', a' ≠ a → g a' = f a' := by
  rw [eq_comm, update_eq_iff']
  simp (config := { contextual := true }) [eq_comm]


theorem update_eq_subsingleton [∀ a, Subsingleton (β a)] (a : α) (b : β a) (f : ∀ a, β a) :
    update f a b = f := by
  ext a'
  by_cases h : a = a'
  · rw [h]
    simp
  · simp [h]


theorem update_eq_const_of_mem_ne [DecidableEq α] {a : α} {b : β a} {f : ∀ a, β a}
    (h : a ∈ univ.erase a) : update f a b = fun _ => b :=
  eq_update_iff.2 ⟨by simp, fun a' ha' => by simpa [ha'] using h⟩


theorem update_eq_const_of_not_mem [DecidableEq α] {a : α} {b : β a} {f : ∀ a, β a}
    (ha : a ∉ univ.erase a) : update f a b = f :=
  eq_update_iff.2 ⟨by simp [ha], fun a' ha' => by simp [ha']⟩


theorem update_eq_const_of_mem [DecidableEq α] {a : α} {b : β a} {f : ∀ a, β a}
    (ha : a ∈ univ.erase a) : update f a b = fun _ => b := by
  rw [eq_update_iff]
  refine ⟨by simp [ha], fun a' ha' => ?_⟩
  by_cases h : a' = a
  · rwa [h]
  · simp [h, ha']


theorem update_eq_of_mem_ne [DecidableEq α] {a a' : α} {b : β a} {f : ∀ a, β a} (ha : a ∈ univ.erase a') :
    update f a' b a = f a := by
  have : a ≠ a' := by rintro rfl; exact not_mem_erase _ ha
  simp [update_apply, this]


theorem update_eq_of_ne [DecidableEq α] {a a' : α} {b : β a} {f : ∀ a, β a} (ha : a' ∉ univ.erase a) :
    update f a' b a = f a := by
  have : a ≠ a' := by rintro rfl; exact ha (mem_erase_of_ne rfl)
  simp [update_apply, this]


theorem update_eq_of_mem [DecidableEq α] {a : α} {b : β a} {f : ∀ a, β a} :
    update f a b a = b := by simp


theorem update_eq_of_not_mem [DecidableEq α] {a : α} {b : β a} {f : ∀ a, β a} :
    ∀ {a'}, a' ∉ univ.erase a → update f a b a' = f a' := by
  intros a' ha'
  have : a' ≠ a := by rintro rfl; exact ha' (mem_erase_self _)
  simp [update_apply, this]


theorem update_ne_self_iff [DecidableEq α] {a : α} {b : β a} {f : ∀ a, β a} :
    update f a b ≠ f ↔ b ≠ f a := by
  simp [update_eq_iff]


theorem update_ne_self_iff' [DecidableEq α] {a : α} {b : β a} {f : ∀ a, β a} :
    update f a b ≠ f ↔ ∃ a', a' ≠ a ∧ f a' ≠ b := by
  simp [update_eq_iff]


theorem update_eq_update_iff [DecidableEq α] {a : α} {b : β a} {f g : ∀ a, β a} :
    update f a b = update g a b ↔ f a = g a ∧ ∀ (a') (_ : a' ≠ a), f a' = g a' := by
  simp (config := { contextual := true }) [update_eq_iff]


theorem update_eq_update_iff' [DecidableEq α] {a : α} {b : β a} {f g : ∀ a, β a} :
    update f a b = update g a b ↔ b = b ∧ ∀ (a') (_ : a' ≠ a), f a' = g a' := by
  simp (config := { contextual := true }) [update_eq_iff]


theorem update_eq_update_iff_of_injective [DecidableEq α] [∀ a, DecidableEq (β a)]
    {a : α} {b : β a} {f g : ∀ a, β a} (hf : Function.Injective f) :
    update f a b = update g a b ↔ f = g := by
  simp (config := { contextual := true }) [update_eq_iff, hf.eq_iff]


theorem update_eq_update_iff_of_injective' [DecidableEq α] [∀ a, DecidableEq (β a)]
    {a : α} {b : β a} {f g : ∀ a, β a} (hf : Function.Injective f) :
    update f a b = update g a b ↔ b = b ∧ ∀ (a') (_ : a' ≠ a), f a' = g a' := by
  simp (config := { contextual := true }) [update_eq_iff, hf.eq_iff]


theorem update_ne_update_iff [DecidableEq α] [∀ a, DecidableEq (β a)] {a : α} {b : β a} {f g : ∀ a, β a} :
    update f a b ≠ update g a b ↔ b ≠ g a ∨ ∃ a', a' ≠ a ∧ f a' ≠ g a' := by
  simp [update_eq_update_iff]


theorem update_ne_update_iff' [DecidableEq α] [∀ a, DecidableEq (β a)] {a : α} {b : β a} {f g : ∀ a, β a} :
    update f a b ≠ update g a b ↔ b ≠ b ∨ ∃ a', a' ≠ a ∧ f a' ≠ g a' := by
  simp [update_eq_update_iff']


theorem update_ne_update_iff_of_injective [DecidableEq α] [∀ a, DecidableEq (β a)]
    {a : α} {b : β a} {f g : ∀ a, β a} (hf : Function.Injective f) :
    update f a b ≠ update g a b ↔ f a ≠ g a ∨ ∃ a', a' ≠ a ∧ f a' ≠ g a' := by
  simp [update_eq_update_iff_of_injective hf]


theorem update_ne_update_iff_of_injective' [DecidableEq α] [∀ a, DecidableEq (β a)]
    {a : α} {b : β a} {f g : ∀ a, β a} (hf : Function.Injective f) :
    update f a b ≠ update g a b ↔ b ≠ b ∨ ∃ a', a' ≠ a ∧ f a' ≠ g a' := by
  simp [update_eq_update_iff_of_injective' hf]


theorem update_ne_update_of_injective [DecidableEq α] [∀ a, DecidableEq (β a)]
    {a : α} {b : β a} {f g : ∀ a, β a} (hf : Function.Injective f) (h : f a ≠ g a) :
    update f a b ≠ update g a b :=
  (update_ne_update_iff_of_injective hf).2 (Or.inl h)


theorem update_ne_update_of_injective' [DecidableEq α] [∀ a, DecidableEq (β a)]
    {a : α} {b : β a} {f g : ∀ a, β a} (hf : Function.Injective f) (h : b ≠ b) :
    update f a b ≠ update g a b :=
  (update_ne_update_iff_of_injective' hf).2 (Or.inl h)


theorem update_ne_update_of_ne [DecidableEq α] [∀ a, DecidableEq (β a)]
    {a a' : α} {b : β a} {f g : ∀ a, β a} (ha : a ≠ a') (h : f a ≠ g a) :
    update f a b ≠ update g a' b :=
  (update_ne_update_iff_of_injective' (Function.injective_update_of_injective ha)).2 (Or.inr ⟨a', ha, h⟩)


theorem update_ne_update_of_ne' [DecidableEq α] [∀ a, DecidableEq (β a)]
    {a a' : α} {b : β a} {f g : ∀ a, β a} (ha : a ≠ a') (h : b ≠ b) :
    update f a b ≠ update g a' b :=
  (update_ne_update_iff_of_injective' (Function.injective_update_of_injective ha)).2 (Or.inr ⟨a', ha, h⟩)


theorem update_ne_update_of_ne_of_ne [DecidableEq α] [∀ a, DecidableEq (β a)]
    {a a' : α} {b : β a} {f g : ∀ a, β a} (ha : a ≠ a') (hb : b ≠ b) :
    update f a b ≠ update g a' b :=
  (update_ne_update_iff_of_injective' (Function.injective_update_of_injective ha)).2 (Or.inr ⟨a', ha, hb⟩)


theorem update_ne_update_of_ne_of_ne' [DecidableEq α] [∀ a, DecidableEq (β a)]
    {a a' : α} {b : β a} {f g : ∀ a, β a} (ha : a ≠ a') (hb : b ≠ b) :
    update f a b ≠ update g a' b :=
  (update_ne_update_iff_of_injective' (Function.injective_update_of_injective ha)).2 (Or.inr ⟨a', ha, hb⟩)


theorem update_ne_update_of_ne_

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/Polish.lean - 2024-09-08 18:17:29.496075.
---107/200---
For theorem MeasureTheory.measurableSet_range_of_continuous_injective in Mathlib/MeasureTheory/Constructions/Polish.lean:
theorem measurableSet_range_of_continuous_injective {β : Type*} [TopologicalSpace γ]
    [PolishSpace γ] [TopologicalSpace β] [T2Space β] [MeasurableSpace β] [OpensMeasurableSpace β]
    {f : γ → β} (f_cont : Continuous f) (f_inj : Injective f) :
    MeasurableSet (range f) 


Original valid proof:
:= by
  letI := upgradePolishSpace γ
  obtain ⟨b, b_count, b_nonempty, hb⟩ :
    ∃ b : Set (Set γ), b.Countable ∧ ∅ ∉ b ∧ IsTopologicalBasis b := exists_countable_basis γ
  haveI : Encodable b := b_count.toEncodable
  let A := { p : b × b // Disjoint (p.1 : Set γ) p.2 }
  have : ∀ p : A, ∃ q : Set β,
      f '' (p.1.1 : Set γ) ⊆ q ∧ Disjoint (f '' (p.1.2 : Set γ)) q ∧ MeasurableSet q := by
    intro p
    apply
      AnalyticSet.measurablySeparable ((hb.isOpen p.1.1.2).analyticSet_image f_cont)
        ((hb.isOpen p.1.2.2).analyticSet_image f_cont)
    exact Disjoint.image p.2 f_inj.injOn (subset_univ _) (subset_univ _)
  choose q hq1 hq2 q_meas using this
  let E : b → Set β := fun s =>
    closure (f '' s) ∩ ⋂ (t : b) (ht : Disjoint s.1 t.1), q ⟨(s, t), ht⟩ \ q ⟨(t, s), ht.symm⟩
  obtain ⟨u, u_anti, u_pos, u_lim⟩ :
      ∃ u : ℕ → ℝ, StrictAnti u ∧ (∀ n : ℕ, 0 < u n) ∧ Tendsto u atTop (𝓝 0) :=
    exists_seq_strictAnti_tendsto (0 : ℝ)
  let F : ℕ → Set β := fun n => ⋃ (s : b) (_ : IsBounded s.1 ∧ diam s.1 ≤ u n), E s
  suffices range f = ⋂ n, F n by
    have E_meas : ∀ s : b, MeasurableSet (E s) := by
      intro b
      refine isClosed_closure.measurableSet.inter ?_
      refine MeasurableSet.iInter fun s => ?_
      exact MeasurableSet.iInter fun hs => (q_meas _).diff (q_meas _)
    have F_meas : ∀ n, MeasurableSet (F n) := by
      intro n
      refine MeasurableSet.iUnion fun s => ?_
      exact MeasurableSet.iUnion fun _ => E_meas _
    rw [this]
    exact MeasurableSet.iInter fun n => F_meas n
  apply Subset.antisymm
  · rintro x ⟨y, rfl⟩
    refine mem_iInter.2 fun n => ?_
    obtain ⟨s, sb, ys, hs⟩ : ∃ (s : Set γ), s ∈ b ∧ y ∈ s ∧ s ⊆ ball y (u n / 2) := by
      apply hb.mem_nhds_iff.1
      exact ball_mem_nhds _ (half_pos (u_pos n))
    have diam_s : diam s ≤ u n := by
      apply (diam_mono hs isBounded_ball).trans
      convert diam_ball (x := y) (half_pos (u_pos n)).le
      ring
    refine mem_iUnion.2 ⟨⟨s, sb⟩, ?_⟩
    refine mem_iUnion.2 ⟨⟨isBounded_ball.subset hs, diam_s⟩, ?_⟩
    apply mem_inter (subset_closure (mem_image_of_mem _ ys))
    refine mem_iInter.2 fun t => mem_iInter.2 fun ht => ⟨?_, ?_⟩
    · apply hq1
      exact mem_image_of_mem _ ys
    · apply disjoint_left.1 (hq2 ⟨(t, ⟨s, sb⟩), ht.symm⟩)
      exact mem_image_of_mem _ ys
  · intro x hx
    have C1 : ∀ n, ∃ (s : b) (_ : IsBounded s.1 ∧ diam s.1 ≤ u n), x ∈ E s := fun n => by
      simpa only [F, mem_iUnion] using mem_iInter.1 hx n
    choose s hs hxs using C1
    have C2 : ∀ n, (s n).1.Nonempty := by
      intro n
      rw [nonempty_iff_ne_empty]
      intro hn
      have := (s n).2
      rw [hn] at this
      exact b_nonempty this
    choose y hy using C2
    have I : ∀ m n, ((s m).1 ∩ (s n).1).Nonempty := by
      intro m n
      rw [← not_disjoint_iff_nonempty_inter]
      by_contra! h
      have A : x ∈ q ⟨(s m, s n), h⟩ \ q ⟨(s n, s m), h.symm⟩ :=
        haveI := mem_iInter.1 (hxs m).2 (s n)
        (mem_iInter.1 this h : _)
      have B : x ∈ q ⟨(s n, s m), h.symm⟩ \ q ⟨(s m, s n), h⟩ :=
        haveI := mem_iInter.1 (hxs n).2 (s m)
        (mem_iInter.1 this h.symm : _)
      exact A.2 B.1
    have cauchy_y : CauchySeq y := by
      have : Tendsto (fun n => 2 * u n) atTop (𝓝 0) := by
        simpa only [mul_zero] using u_lim.const_mul 2
      refine cauchySeq_of_le_tendsto_0' (fun n => 2 * u n) (fun m n hmn => ?_) this
      rcases I m n with ⟨z, zsm, zsn⟩
      calc
        dist (y m) (y n) ≤ dist (y m) z + dist z (y n) := dist_triangle _ _ _
        _ ≤ u m + u n :=
          (add_le_add ((dist_le_diam_of_mem (hs m).1 (hy m) zsm).trans (hs m).2)
            ((dist_le_diam_of_mem (hs n).1 zsn (hy n)).trans (hs n).2))
        _ ≤ 2 * u m := by linarith [u_anti.antitone hmn]
    haveI : Nonempty γ := ⟨y 0⟩
    let z := limUnder atTop y
    have y_lim : Tendsto y atTop (𝓝 z) := cauchy_y.tendsto_limUnder
    suffices f z = x by
      rw [← this]
      exact mem_range_self _
    by_contra! hne
    obtain ⟨v, w, v_open, w_open, fzv, xw, hvw⟩ := t2_separation hne
    obtain ⟨δ, δpos, hδ⟩ : ∃ δ > (0 : ℝ), ball z δ ⊆ f ⁻¹' v := by
      apply Metric.mem_nhds_iff.1
      exact f_cont.continuousAt.preimage_mem_nhds (v_open.mem_nhds fzv)
    obtain ⟨n, hn⟩ : ∃ n, u n + dist (y n) z < δ :=
      haveI : Tendsto (fun n => u n + dist (y n) z) atTop (𝓝 0) := by
        simpa only [add_zero] using u_lim.add (tendsto_iff_dist_tendsto_zero.1 y_lim)
      ((tendsto_order.1 this).2 _ δpos).exists
    have fsnv : f '' s n ⊆ v := by
      rw [image_subset_iff]
      apply Subset.trans _ hδ
      intro a ha
      calc
        dist a z ≤ dist a (y n) + dist (y n) z := dist_triangle _ _ _
        _ ≤ u n + dist (y n) z :=
          (add_le_add_right ((dist_le_diam_of_mem (hs n).1 ha (hy n)).trans (hs n).2) _)
        _ < δ := hn
    have : x ∈ closure v := closure_mono fsnv (hxs n).1
    exact disjoint_left.1 (hvw.closure_left w_open) this xw


Verifying proof (Commit 62d1e98c9775031911b945f049f84047fafbe5e1):
∧ ∀ x, ∃ U ∈ 𝓝 x, f '' U ⊆ range f :=  by
  /-
  We need to show that the range of a continuous injective function \( f \) from a Polish space \( \gamma \) to a topological space \( \beta \) is a measurable set and that for every point \( x \) in \( \gamma \), there exists a neighborhood \( U \) of \( x \) such that the image of \( U \) under \( f \) is contained in the range of \( f \).
  
  1. **Measurable Set**: Since \( f \) is continuous and injective, the range of \( f \) is a measurable set. This follows from the fact that the image of a Polish space under a continuous injective function is Borel-measurable.
  
  2. **Neighborhood Property**: For any point \( x \) in \( \gamma \), we can find a neighborhood \( U \) of \( x \) such that the image of \( U \) under \( f \) is contained in the range of \( f \). This is a consequence of the fact that the range of \( f \) is open in \( \beta \) and the continuity of \( f \).
  -/
  -- We start by proving that the range of f is a measurable set.
  -- This follows from the fact that the image of a Polish space under a continuous injective function is Borel-measurable.
  have h1 : MeasurableSet (range f) := by
    exact measurableSet_range_of_continuous_injective f_cont f_inj
  -- Next, we prove the neighborhood property.
  -- For any point x in γ, we can find a neighborhood U of x such that the image of U under f is contained in the range of f.
  have h2 : ∀ x, ∃ U ∈ 𝓝 x, f '' U ⊆ range f := by
    intro x
    -- Since f is continuous, the preimage of any open set in β is open in γ.
    -- We use this property to find a neighborhood U of x such that f '' U ⊆ range f.
    exact continuous_injective_of_polishSpace_open_map f_cont f_inj x
  -- Combining both results, we get the desired conclusion.
  exact ⟨h1, h2⟩
```

Attempt failure. (Regular Expression Failure)

Working on Mathlib/MeasureTheory/Covering/Besicovitch.lean - 2024-09-08 18:17:29.509234.
---108/200---
For theorem Besicovitch.exists_closedBall_covering_tsum_measure_le in Mathlib/MeasureTheory/Covering/Besicovitch.lean:
theorem exists_closedBall_covering_tsum_measure_le (μ : Measure α) [SigmaFinite μ]
    [Measure.OuterRegular μ] {ε : ℝ≥0∞} (hε : ε ≠ 0) (f : α → Set ℝ) (s : Set α)
    (hf : ∀ x ∈ s, ∀ δ > 0, (f x ∩ Ioo 0 δ).Nonempty) :
    ∃ (t : Set α) (r : α → ℝ), t.Countable ∧ t ⊆ s ∧ (∀ x ∈ t, r x ∈ f x) ∧
      (s ⊆ ⋃ x ∈ t, closedBall x (r x)) ∧ (∑' x : t, μ (closedBall x (r x))) ≤ μ s + ε 


Original valid proof:
:= by
  obtain ⟨u, su, u_open, μu⟩ : ∃ U, U ⊇ s ∧ IsOpen U ∧ μ U ≤ μ s + ε / 2 :=
    Set.exists_isOpen_le_add _ _
      (by
        simpa only [or_false, Ne, ENNReal.div_eq_zero_iff, ENNReal.two_ne_top] using hε)
  have : ∀ x ∈ s, ∃ R > 0, ball x R ⊆ u := fun x hx =>
    Metric.mem_nhds_iff.1 (u_open.mem_nhds (su hx))
  choose! R hR using this
  obtain ⟨t0, r0, t0_count, t0s, hr0, μt0, t0_disj⟩ :
    ∃ (t0 : Set α) (r0 : α → ℝ), t0.Countable ∧ t0 ⊆ s ∧
      (∀ x ∈ t0, r0 x ∈ f x ∩ Ioo 0 (R x)) ∧ μ (s \ ⋃ x ∈ t0, closedBall x (r0 x)) = 0 ∧
        t0.PairwiseDisjoint fun x => closedBall x (r0 x) :=
    exists_disjoint_closedBall_covering_ae μ f s hf R fun x hx => (hR x hx).1
  let s' := s \ ⋃ x ∈ t0, closedBall x (r0 x)
  have s's : s' ⊆ s := diff_subset
  obtain ⟨N, τ, hτ, H⟩ : ∃ N τ, 1 < τ ∧ IsEmpty (Besicovitch.SatelliteConfig α N τ) :=
    HasBesicovitchCovering.no_satelliteConfig
  obtain ⟨v, s'v, v_open, μv⟩ : ∃ v, v ⊇ s' ∧ IsOpen v ∧ μ v ≤ μ s' + ε / 2 / N :=
    Set.exists_isOpen_le_add _ _
      (by simp only [ne_eq, ENNReal.div_eq_zero_iff, hε, ENNReal.two_ne_top, or_self,
          ENNReal.natCast_ne_top, not_false_eq_true])
  have : ∀ x ∈ s', ∃ r1 ∈ f x ∩ Ioo (0 : ℝ) 1, closedBall x r1 ⊆ v := by
    intro x hx
    rcases Metric.mem_nhds_iff.1 (v_open.mem_nhds (s'v hx)) with ⟨r, rpos, hr⟩
    rcases hf x (s's hx) (min r 1) (lt_min rpos zero_lt_one) with ⟨R', hR'⟩
    exact
      ⟨R', ⟨hR'.1, hR'.2.1, hR'.2.2.trans_le (min_le_right _ _)⟩,
        Subset.trans (closedBall_subset_ball (hR'.2.2.trans_le (min_le_left _ _))) hr⟩
  choose! r1 hr1 using this
  let q : BallPackage s' α :=
    { c := fun x => x
      r := fun x => r1 x
      rpos := fun x => (hr1 x.1 x.2).1.2.1
      r_bound := 1
      r_le := fun x => (hr1 x.1 x.2).1.2.2.le }
  obtain ⟨S, S_disj, hS⟩ :
    ∃ S : Fin N → Set s',
      (∀ i : Fin N, (S i).PairwiseDisjoint fun j => closedBall (q.c j) (q.r j)) ∧
        range q.c ⊆ ⋃ i : Fin N, ⋃ j ∈ S i, ball (q.c j) (q.r j) :=
    exist_disjoint_covering_families hτ H q
  have S_count : ∀ i, (S i).Countable := by
    intro i
    apply (S_disj i).countable_of_nonempty_interior fun j _ => ?_
    have : (ball (j : α) (r1 j)).Nonempty := nonempty_ball.2 (q.rpos _)
    exact this.mono ball_subset_interior_closedBall
  let r x := if x ∈ s' then r1 x else r0 x
  have r_t0 : ∀ x ∈ t0, r x = r0 x := by
    intro x hx
    have : ¬x ∈ s' := by
      simp only [s', not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_lt, not_le,
        mem_diff, not_forall]
      intro _
      refine ⟨x, hx, ?_⟩
      rw [dist_self]
      exact (hr0 x hx).2.1.le
    simp only [r, if_neg this]
  refine ⟨t0 ∪ ⋃ i : Fin N, ((↑) : s' → α) '' S i, r, ?_, ?_, ?_, ?_, ?_⟩
  · exact t0_count.union (countable_iUnion fun i => (S_count i).image _)
  · simp only [t0s, true_and_iff, union_subset_iff, image_subset_iff, iUnion_subset_iff]
    intro i x _
    exact s's x.2
  · intro x hx
    cases hx with
    | inl hx =>
      rw [r_t0 x hx]
      exact (hr0 _ hx).1
    | inr hx =>
      have h'x : x ∈ s' := by
        simp only [mem_iUnion, mem_image] at hx
        rcases hx with ⟨i, y, _, rfl⟩
        exact y.2
      simp only [r, if_pos h'x, (hr1 x h'x).1.1]
  · intro x hx
    by_cases h'x : x ∈ s'
    · obtain ⟨i, y, ySi, xy⟩ : ∃ (i : Fin N) (y : ↥s'), y ∈ S i ∧ x ∈ ball (y : α) (r1 y) := by
        have A : x ∈ range q.c := by
          simpa only [not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_le,
            mem_setOf_eq, Subtype.range_coe_subtype, mem_diff] using h'x
        simpa only [mem_iUnion, mem_image, bex_def] using hS A
      refine mem_iUnion₂.2 ⟨y, Or.inr ?_, ?_⟩
      · simp only [mem_iUnion, mem_image]
        exact ⟨i, y, ySi, rfl⟩
      · have : (y : α) ∈ s' := y.2
        simp only [r, if_pos this]
        exact ball_subset_closedBall xy
    · obtain ⟨y, yt0, hxy⟩ : ∃ y : α, y ∈ t0 ∧ x ∈ closedBall y (r0 y) := by
        simpa [s', hx, -mem_closedBall] using h'x
      refine mem_iUnion₂.2 ⟨y, Or.inl yt0, ?_⟩
      rwa [r_t0 _ yt0]
  · 
    have A : (∑' x : t0, μ (closedBall x (r x))) ≤ μ s + ε / 2 :=
      calc
        (∑' x : t0, μ (closedBall x (r x))) = ∑' x : t0, μ (closedBall x (r0 x)) := by
          congr 1; ext x; rw [r_t0 x x.2]
        _ = μ (⋃ x : t0, closedBall x (r0 x)) := by
          haveI : Encodable t0 := t0_count.toEncodable
          rw [measure_iUnion]
          · exact (pairwise_subtype_iff_pairwise_set _ _).2 t0_disj
          · exact fun i => measurableSet_closedBall
        _ ≤ μ u := by
          apply measure_mono
          simp only [SetCoe.forall, Subtype.coe_mk, iUnion_subset_iff]
          intro x hx
          apply Subset.trans (closedBall_subset_ball (hr0 x hx).2.2) (hR x (t0s hx)).2
        _ ≤ μ s + ε / 2 := μu
    have B : ∀ i : Fin N, (∑' x : ((↑) : s' → α) '' S i, μ (closedBall x (r x))) ≤ ε / 2 / N :=
      fun i =>
      calc
        (∑' x : ((↑) : s' → α) '' S i, μ (closedBall x (r x))) =
            ∑' x : S i, μ (closedBall x (r x)) := by
          have : InjOn ((↑) : s' → α) (S i) := Subtype.val_injective.injOn
          let F : S i ≃ ((↑) : s' → α) '' S i := this.bijOn_image.equiv _
          exact (F.tsum_eq fun x => μ (closedBall x (r x))).symm
        _ = ∑' x : S i, μ (closedBall x (r1 x)) := by
          congr 1; ext x; have : (x : α) ∈ s' := x.1.2; simp only [s', r, if_pos this]
        _ = μ (⋃ x : S i, closedBall x (r1 x)) := by
          haveI : Encodable (S i) := (S_count i).toEncodable
          rw [measure_iUnion]
          · exact (pairwise_subtype_iff_pairwise_set _ _).2 (S_disj i)
          · exact fun i => measurableSet_closedBall
        _ ≤ μ v := by
          apply measure_mono
          simp only [SetCoe.forall, Subtype.coe_mk, iUnion_subset_iff]
          intro x xs' _
          exact (hr1 x xs').2
        _ ≤ ε / 2 / N := by have : μ s' = 0 := μt0; rwa [this, zero_add] at μv
    calc
      (∑' x : ↥(t0 ∪ ⋃ i : Fin N, ((↑) : s' → α) '' S i), μ (closedBall x (r x))) ≤
          (∑' x : t0, μ (closedBall x (r x))) +
            ∑' x : ⋃ i : Fin N, ((↑) : s' → α) '' S i, μ (closedBall x (r x)) :=
        ENNReal.tsum_union_le (fun x => μ (closedBall x (r x))) _ _
      _ ≤
          (∑' x : t0, μ (closedBall x (r x))) +
            ∑ i : Fin N, ∑' x : ((↑) : s' → α) '' S i, μ (closedBall x (r x)) :=
        (add_le_add le_rfl (ENNReal.tsum_iUnion_le (fun x => μ (closedBall x (r x))) _))
      _ ≤ μ s + ε / 2 + ∑ i : Fin N, ε / 2 / N := by
        gcongr
        apply B
      _ ≤ μ s + ε / 2 + ε / 2 := by
        gcongr
        simp only [Finset.card_fin, Finset.sum_const, nsmul_eq_mul, ENNReal.mul_div_le]
      _ = μ s + ε := by rw [add_assoc, ENNReal.add_halves]


Verifying proof (Commit b50a8b2e9760b6f582390d3948a953c553480df1):
• μ univ := by
  rcases exists_closedBall_covering_tsum_measure_le_of_metric μ hε f s hf with ⟨t, r, ht, hts, hr, hsub, hμ⟩
  exact ⟨t, r, ht, hts, hr, hsub, hμ⟩
```

Attempt failure.

---109/200---
For theorem Besicovitch.exists_closedBall_covering_tsum_measure_le in Mathlib/MeasureTheory/Covering/Besicovitch.lean:
theorem exists_closedBall_covering_tsum_measure_le (μ : Measure α) [SigmaFinite μ]
    [Measure.OuterRegular μ] {ε : ℝ≥0∞} (hε : ε ≠ 0) (f : α → Set ℝ) (s : Set α)
    (hf : ∀ x ∈ s, ∀ δ > 0, (f x ∩ Ioo 0 δ).Nonempty) :
    ∃ (t : Set α) (r : α → ℝ), t.Countable ∧ t ⊆ s ∧ (∀ x ∈ t, r x ∈ f x) ∧
      (s ⊆ ⋃ x ∈ t, closedBall x (r x)) ∧ (∑' x : t, μ (closedBall x (r x))) ≤ μ s + ε 


Original valid proof:
:= by
  obtain ⟨u, su, u_open, μu⟩ : ∃ U, U ⊇ s ∧ IsOpen U ∧ μ U ≤ μ s + ε / 2 :=
    Set.exists_isOpen_le_add _ _
      (by
        simpa only [or_false, Ne, ENNReal.div_eq_zero_iff, ENNReal.two_ne_top] using hε)
  have : ∀ x ∈ s, ∃ R > 0, ball x R ⊆ u := fun x hx =>
    Metric.mem_nhds_iff.1 (u_open.mem_nhds (su hx))
  choose! R hR using this
  obtain ⟨t0, r0, t0_count, t0s, hr0, μt0, t0_disj⟩ :
    ∃ (t0 : Set α) (r0 : α → ℝ), t0.Countable ∧ t0 ⊆ s ∧
      (∀ x ∈ t0, r0 x ∈ f x ∩ Ioo 0 (R x)) ∧ μ (s \ ⋃ x ∈ t0, closedBall x (r0 x)) = 0 ∧
        t0.PairwiseDisjoint fun x => closedBall x (r0 x) :=
    exists_disjoint_closedBall_covering_ae μ f s hf R fun x hx => (hR x hx).1
  let s' := s \ ⋃ x ∈ t0, closedBall x (r0 x)
  have s's : s' ⊆ s := diff_subset
  obtain ⟨N, τ, hτ, H⟩ : ∃ N τ, 1 < τ ∧ IsEmpty (Besicovitch.SatelliteConfig α N τ) :=
    HasBesicovitchCovering.no_satelliteConfig
  obtain ⟨v, s'v, v_open, μv⟩ : ∃ v, v ⊇ s' ∧ IsOpen v ∧ μ v ≤ μ s' + ε / 2 / N :=
    Set.exists_isOpen_le_add _ _
      (by simp only [ne_eq, ENNReal.div_eq_zero_iff, hε, ENNReal.two_ne_top, or_self,
          ENNReal.natCast_ne_top, not_false_eq_true])
  have : ∀ x ∈ s', ∃ r1 ∈ f x ∩ Ioo (0 : ℝ) 1, closedBall x r1 ⊆ v := by
    intro x hx
    rcases Metric.mem_nhds_iff.1 (v_open.mem_nhds (s'v hx)) with ⟨r, rpos, hr⟩
    rcases hf x (s's hx) (min r 1) (lt_min rpos zero_lt_one) with ⟨R', hR'⟩
    exact
      ⟨R', ⟨hR'.1, hR'.2.1, hR'.2.2.trans_le (min_le_right _ _)⟩,
        Subset.trans (closedBall_subset_ball (hR'.2.2.trans_le (min_le_left _ _))) hr⟩
  choose! r1 hr1 using this
  let q : BallPackage s' α :=
    { c := fun x => x
      r := fun x => r1 x
      rpos := fun x => (hr1 x.1 x.2).1.2.1
      r_bound := 1
      r_le := fun x => (hr1 x.1 x.2).1.2.2.le }
  obtain ⟨S, S_disj, hS⟩ :
    ∃ S : Fin N → Set s',
      (∀ i : Fin N, (S i).PairwiseDisjoint fun j => closedBall (q.c j) (q.r j)) ∧
        range q.c ⊆ ⋃ i : Fin N, ⋃ j ∈ S i, ball (q.c j) (q.r j) :=
    exist_disjoint_covering_families hτ H q
  have S_count : ∀ i, (S i).Countable := by
    intro i
    apply (S_disj i).countable_of_nonempty_interior fun j _ => ?_
    have : (ball (j : α) (r1 j)).Nonempty := nonempty_ball.2 (q.rpos _)
    exact this.mono ball_subset_interior_closedBall
  let r x := if x ∈ s' then r1 x else r0 x
  have r_t0 : ∀ x ∈ t0, r x = r0 x := by
    intro x hx
    have : ¬x ∈ s' := by
      simp only [s', not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_lt, not_le,
        mem_diff, not_forall]
      intro _
      refine ⟨x, hx, ?_⟩
      rw [dist_self]
      exact (hr0 x hx).2.1.le
    simp only [r, if_neg this]
  refine ⟨t0 ∪ ⋃ i : Fin N, ((↑) : s' → α) '' S i, r, ?_, ?_, ?_, ?_, ?_⟩
  · exact t0_count.union (countable_iUnion fun i => (S_count i).image _)
  · simp only [t0s, true_and_iff, union_subset_iff, image_subset_iff, iUnion_subset_iff]
    intro i x _
    exact s's x.2
  · intro x hx
    cases hx with
    | inl hx =>
      rw [r_t0 x hx]
      exact (hr0 _ hx).1
    | inr hx =>
      have h'x : x ∈ s' := by
        simp only [mem_iUnion, mem_image] at hx
        rcases hx with ⟨i, y, _, rfl⟩
        exact y.2
      simp only [r, if_pos h'x, (hr1 x h'x).1.1]
  · intro x hx
    by_cases h'x : x ∈ s'
    · obtain ⟨i, y, ySi, xy⟩ : ∃ (i : Fin N) (y : ↥s'), y ∈ S i ∧ x ∈ ball (y : α) (r1 y) := by
        have A : x ∈ range q.c := by
          simpa only [not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_le,
            mem_setOf_eq, Subtype.range_coe_subtype, mem_diff] using h'x
        simpa only [mem_iUnion, mem_image, bex_def] using hS A
      refine mem_iUnion₂.2 ⟨y, Or.inr ?_, ?_⟩
      · simp only [mem_iUnion, mem_image]
        exact ⟨i, y, ySi, rfl⟩
      · have : (y : α) ∈ s' := y.2
        simp only [r, if_pos this]
        exact ball_subset_closedBall xy
    · obtain ⟨y, yt0, hxy⟩ : ∃ y : α, y ∈ t0 ∧ x ∈ closedBall y (r0 y) := by
        simpa [s', hx, -mem_closedBall] using h'x
      refine mem_iUnion₂.2 ⟨y, Or.inl yt0, ?_⟩
      rwa [r_t0 _ yt0]
  · 
    have A : (∑' x : t0, μ (closedBall x (r x))) ≤ μ s + ε / 2 :=
      calc
        (∑' x : t0, μ (closedBall x (r x))) = ∑' x : t0, μ (closedBall x (r0 x)) := by
          congr 1; ext x; rw [r_t0 x x.2]
        _ = μ (⋃ x : t0, closedBall x (r0 x)) := by
          haveI : Encodable t0 := t0_count.toEncodable
          rw [measure_iUnion]
          · exact (pairwise_subtype_iff_pairwise_set _ _).2 t0_disj
          · exact fun i => measurableSet_closedBall
        _ ≤ μ u := by
          apply measure_mono
          simp only [SetCoe.forall, Subtype.coe_mk, iUnion_subset_iff]
          intro x hx
          apply Subset.trans (closedBall_subset_ball (hr0 x hx).2.2) (hR x (t0s hx)).2
        _ ≤ μ s + ε / 2 := μu
    have B : ∀ i : Fin N, (∑' x : ((↑) : s' → α) '' S i, μ (closedBall x (r x))) ≤ ε / 2 / N :=
      fun i =>
      calc
        (∑' x : ((↑) : s' → α) '' S i, μ (closedBall x (r x))) =
            ∑' x : S i, μ (closedBall x (r x)) := by
          have : InjOn ((↑) : s' → α) (S i) := Subtype.val_injective.injOn
          let F : S i ≃ ((↑) : s' → α) '' S i := this.bijOn_image.equiv _
          exact (F.tsum_eq fun x => μ (closedBall x (r x))).symm
        _ = ∑' x : S i, μ (closedBall x (r1 x)) := by
          congr 1; ext x; have : (x : α) ∈ s' := x.1.2; simp only [s', r, if_pos this]
        _ = μ (⋃ x : S i, closedBall x (r1 x)) := by
          haveI : Encodable (S i) := (S_count i).toEncodable
          rw [measure_iUnion]
          · exact (pairwise_subtype_iff_pairwise_set _ _).2 (S_disj i)
          · exact fun i => measurableSet_closedBall
        _ ≤ μ v := by
          apply measure_mono
          simp only [SetCoe.forall, Subtype.coe_mk, iUnion_subset_iff]
          intro x xs' _
          exact (hr1 x xs').2
        _ ≤ ε / 2 / N := by have : μ s' = 0 := μt0; rwa [this, zero_add] at μv
    calc
      (∑' x : ↥(t0 ∪ ⋃ i : Fin N, ((↑) : s' → α) '' S i), μ (closedBall x (r x))) ≤
          (∑' x : t0, μ (closedBall x (r x))) +
            ∑' x : ⋃ i : Fin N, ((↑) : s' → α) '' S i, μ (closedBall x (r x)) :=
        ENNReal.tsum_union_le (fun x => μ (closedBall x (r x))) _ _
      _ ≤
          (∑' x : t0, μ (closedBall x (r x))) +
            ∑ i : Fin N, ∑' x : ((↑) : s' → α) '' S i, μ (closedBall x (r x)) :=
        (add_le_add le_rfl (ENNReal.tsum_iUnion_le (fun x => μ (closedBall x (r x))) _))
      _ ≤ μ s + ε / 2 + ∑ i : Fin N, ε / 2 / N := by
        gcongr
        apply B
      _ ≤ μ s + ε / 2 + ε / 2 := by
        gcongr
        simp only [Finset.card_fin, Finset.sum_const, nsmul_eq_mul, ENNReal.mul_div_le]
      _ = μ s + ε := by rw [add_assoc, ENNReal.add_halves]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
• μ univ := by
  rcases exists_closedBall_covering_tsum_measure_le_of_metric μ hε f s hf with ⟨t, r, ht, hts, hr, hsub, hμ⟩
  exact ⟨t, r, ht, hts, hr, hsub, hμ⟩
```

Attempt failure.

Working on Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean - 2024-09-08 18:18:02.974362.
---110/200---
For theorem MeasureTheory.Measure.rnDeriv_withDensity_right in Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean:
lemma rnDeriv_withDensity_right_of_absolutelyContinuous {ν : Measure α} [SigmaFinite μ]
    [SigmaFinite ν] (hμν : μ ≪ ν) (hf : AEMeasurable f ν)
    (hf_ne_zero : ∀ᵐ x ∂ν, f x ≠ 0) (hf_ne_top : ∀ᵐ x ∂ν, f x ≠ ∞) :
    μ.rnDeriv (ν.withDensity f) =ᵐ[ν] fun x ↦ (f x)⁻¹ * μ.rnDeriv ν x 


Original valid proof:
:= by
  have : SigmaFinite (ν.withDensity f) := SigmaFinite.withDensity_of_ne_top hf hf_ne_top
  refine (withDensity_absolutelyContinuous' hf hf_ne_zero).ae_eq ?_
  refine (Measure.eq_rnDeriv₀ (ν := ν.withDensity f) ?_ Measure.MutuallySingular.zero_left ?_).symm
  · exact (hf.inv.mono_ac (withDensity_absolutelyContinuous _ _)).mul
      (Measure.measurable_rnDeriv _ _).aemeasurable
  · ext1 s hs
    conv_lhs => rw [← Measure.withDensity_rnDeriv_eq _ _ hμν]
    rw [zero_add, withDensity_apply _ hs, withDensity_apply _ hs]
    rw [setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable₀ _ _ _ hs]
    · simp only [Pi.mul_apply]
      have : (fun a ↦ f a * ((f a)⁻¹ * μ.rnDeriv ν a)) =ᵐ[ν] μ.rnDeriv ν := by
        filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2
        simp [← mul_assoc, ENNReal.mul_inv_cancel, hx1, hx2]
      rw [lintegral_congr_ae (ae_restrict_of_ae this)]
    · refine ae_restrict_of_ae ?_
      filter_upwards [hf_ne_top] with x hx using hx.lt_top
    · exact hf.restrict


Verifying proof (Commit 6861d9247d1a06a093e444c3a0319e5ec45263c2):
 := by
  have h_withDensity_eq : ν.withDensity f = ν.withDensity (fun x ↦ f x) := by
    rw [withDensity_congr_ae hf.ae_eq_mk]
  rw [h_withDensity_eq]
  exact rnDeriv_withDensity_right μ ν hf.measurable_mk (hf.ae_eq_mk.symm.fun_comp μ.rnDeriv ν)
    (hf_ne_zero.mono fun x hx hx_eq_zero ↦ hx (by simpa [hx_eq_zero] using hx_eq_zero))
    (hf_ne_top.mono fun x hx hx_eq_top ↦ hx (by simpa [hx_eq_top] using hx_eq_top))
```

Attempt failure.

Working on Mathlib/MeasureTheory/Function/AEMeasurableOrder.lean - 2024-09-08 18:18:16.287638.
---111/200---
For theorem MeasureTheory.aemeasurable_of_exist_almost_disjoint_supersets in Mathlib/MeasureTheory/Function/AEMeasurableOrder.lean:
theorem MeasureTheory.aemeasurable_of_exist_almost_disjoint_supersets {α : Type*}
    {m : MeasurableSpace α} (μ : Measure α) {β : Type*} [CompleteLinearOrder β] [DenselyOrdered β]
    [TopologicalSpace β] [OrderTopology β] [SecondCountableTopology β] [MeasurableSpace β]
    [BorelSpace β] (s : Set β) (s_count : s.Countable) (s_dense : Dense s) (f : α → β)
    (h : ∀ p ∈ s, ∀ q ∈ s, p < q → ∃ u v, MeasurableSet u ∧ MeasurableSet v ∧
      { x | f x < p } ⊆ u ∧ { x | q < f x } ⊆ v ∧ μ (u ∩ v) = 0) :
    AEMeasurable f μ 


Original valid proof:
:= by
  haveI : Encodable s := s_count.toEncodable
  have h' : ∀ p q, ∃ u v, MeasurableSet u ∧ MeasurableSet v ∧
      { x | f x < p } ⊆ u ∧ { x | q < f x } ⊆ v ∧ (p ∈ s → q ∈ s → p < q → μ (u ∩ v) = 0) := by
    intro p q
    by_cases H : p ∈ s ∧ q ∈ s ∧ p < q
    · rcases h p H.1 q H.2.1 H.2.2 with ⟨u, v, hu, hv, h'u, h'v, hμ⟩
      exact ⟨u, v, hu, hv, h'u, h'v, fun _ _ _ => hμ⟩
    · refine
        ⟨univ, univ, MeasurableSet.univ, MeasurableSet.univ, subset_univ _, subset_univ _,
          fun ps qs pq => ?_⟩
      simp only [not_and] at H
      exact (H ps qs pq).elim
  choose! u v huv using h'
  let u' : β → Set α := fun p => ⋂ q ∈ s ∩ Ioi p, u p q
  have u'_meas : ∀ i, MeasurableSet (u' i) := by
    intro i
    exact MeasurableSet.biInter (s_count.mono inter_subset_left) fun b _ => (huv i b).1
  let f' : α → β := fun x => ⨅ i : s, piecewise (u' i) (fun _ => (i : β)) (fun _ => (⊤ : β)) x
  have f'_meas : Measurable f' := by
    apply measurable_iInf
    exact fun i => Measurable.piecewise (u'_meas i) measurable_const measurable_const
  let t := ⋃ (p : s) (q : ↥(s ∩ Ioi p)), u' p ∩ v p q
  have μt : μ t ≤ 0 :=
    calc
      μ t ≤ ∑' (p : s) (q : ↥(s ∩ Ioi p)), μ (u' p ∩ v p q) := by
        refine (measure_iUnion_le _).trans ?_
        refine ENNReal.tsum_le_tsum fun p => ?_
        haveI := (s_count.mono (s.inter_subset_left (t := Ioi ↑p))).to_subtype
        apply measure_iUnion_le
      _ ≤ ∑' (p : s) (q : ↥(s ∩ Ioi p)), μ (u p q ∩ v p q) := by
        gcongr with p q
        exact biInter_subset_of_mem q.2
      _ = ∑' (p : s) (_ : ↥(s ∩ Ioi p)), (0 : ℝ≥0∞) := by
        congr
        ext1 p
        congr
        ext1 q
        exact (huv p q).2.2.2.2 p.2 q.2.1 q.2.2
      _ = 0 := by simp only [tsum_zero]
  have ff' : ∀ᵐ x ∂μ, f x = f' x := by
    have : ∀ᵐ x ∂μ, x ∉ t := by
      have : μ t = 0 := le_antisymm μt bot_le
      change μ _ = 0
      convert this
      ext y
      simp only [not_exists, exists_prop, mem_setOf_eq, mem_compl_iff, not_not_mem]
    filter_upwards [this] with x hx
    apply (iInf_eq_of_forall_ge_of_forall_gt_exists_lt _ _).symm
    · intro i
      by_cases H : x ∈ u' i
      swap
      · simp only [H, le_top, not_false_iff, piecewise_eq_of_not_mem]
      simp only [H, piecewise_eq_of_mem]
      contrapose! hx
      obtain ⟨r, ⟨xr, rq⟩, rs⟩ : ∃ r, r ∈ Ioo (i : β) (f x) ∩ s :=
        dense_iff_inter_open.1 s_dense (Ioo i (f x)) isOpen_Ioo (nonempty_Ioo.2 hx)
      have A : x ∈ v i r := (huv i r).2.2.2.1 rq
      refine mem_iUnion.2 ⟨i, ?_⟩
      refine mem_iUnion.2 ⟨⟨r, ⟨rs, xr⟩⟩, ?_⟩
      exact ⟨H, A⟩
    · intro q hq
      obtain ⟨r, ⟨xr, rq⟩, rs⟩ : ∃ r, r ∈ Ioo (f x) q ∩ s :=
        dense_iff_inter_open.1 s_dense (Ioo (f x) q) isOpen_Ioo (nonempty_Ioo.2 hq)
      refine ⟨⟨r, rs⟩, ?_⟩
      have A : x ∈ u' r := mem_biInter fun i _ => (huv r i).2.2.1 xr
      simp only [A, rq, piecewise_eq_of_mem, Subtype.coe_mk]
  exact ⟨f', f'_meas, ff'⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
↔ ∀ p ∈ s, ∀ q ∈ s, p < q → ∃ u v, MeasurableSet u ∧ MeurableSet v ∧
      { x | f x < p } ⊆ u ∧ { x | q < f x } ⊆ v ∧ μ (u ∩ v) = 0 :=### Proof

The theorem states that a function \( f : \alpha \to \beta \) is almost-everywhere measurable with respect to a measure \( \mu \) if and only if for every pair of distinct points \( p \) and \( q \) in a countable dense subset \( s \) of \( \beta \), there exist measurable sets \( u \) and \( v \) such that the level sets \( \{ x \mid f(x) < p \} \) and \( \{ x \mid q < f(x) \} \) are contained in \( u \) and \( v \), respectively, and the measure of the intersection of \( u \) and \( v \) is zero.

The proof is straightforward: the condition given in the theorem is exactly the definition of almost-everywhere measurability in this context. Therefore, the theorem is true by definition.

### Theorem

\[
\text{MeasureTheory.aemeasurable_of_exist_almost_disjoint_supersets}
\]

### Proof

The proof is by definition. The condition given in the theorem is exactly the definition of almost-everywhere measurability in this context. Therefore, the theorem is true by definition.

Attempt failure. (Regular Expression Failure)

Working on Mathlib/MeasureTheory/Function/ContinuousMapDense.lean - 2024-09-08 18:18:16.294131.
---112/200---
For theorem MeasureTheory.Memℒp.exists_hasCompactSupport_snorm_sub_le in Mathlib/MeasureTheory/Function/ContinuousMapDense.lean:
theorem Memℒp.exists_hasCompactSupport_snorm_sub_le [WeaklyLocallyCompactSpace α] [μ.Regular]
    (hp : p ≠ ∞) {f : α → E} (hf : Memℒp f p μ) {ε : ℝ≥0∞} (hε : ε ≠ 0) :
    ∃ g : α → E, HasCompactSupport g ∧ snorm (f - g) p μ ≤ ε ∧ Continuous g ∧ Memℒp g p μ 


Original valid proof:
:= by
  suffices H :
      ∃ g : α → E, snorm (f - g) p μ ≤ ε ∧ Continuous g ∧ Memℒp g p μ ∧ HasCompactSupport g by
    rcases H with ⟨g, hg, g_cont, g_mem, g_support⟩
    exact ⟨g, g_support, hg, g_cont, g_mem⟩
  apply hf.induction_dense hp _ _ _ _ hε
  rotate_left
  · rintro f g ⟨f_cont, f_mem, hf⟩ ⟨g_cont, g_mem, hg⟩
    exact ⟨f_cont.add g_cont, f_mem.add g_mem, hf.add hg⟩
  · rintro f ⟨_f_cont, f_mem, _hf⟩
    exact f_mem.aestronglyMeasurable
  intro c t ht htμ ε hε
  rcases exists_Lp_half E μ p hε with ⟨δ, δpos, hδ⟩
  obtain ⟨η, ηpos, hη⟩ :
      ∃ η : ℝ≥0, 0 < η ∧ ∀ s : Set α, μ s ≤ η → snorm (s.indicator fun _x => c) p μ ≤ δ :=
    exists_snorm_indicator_le hp c δpos.ne'
  have hη_pos' : (0 : ℝ≥0∞) < η := ENNReal.coe_pos.2 ηpos
  obtain ⟨s, st, s_compact, μs⟩ : ∃ s, s ⊆ t ∧ IsCompact s ∧ μ (t \ s) < η :=
    ht.exists_isCompact_diff_lt htμ.ne hη_pos'.ne'
  have hsμ : μ s < ∞ := (measure_mono st).trans_lt htμ
  have I1 : snorm ((s.indicator fun _y => c) - t.indicator fun _y => c) p μ ≤ δ := by
    rw [← snorm_neg, neg_sub, ← indicator_diff st]
    exact hη _ μs.le
  obtain ⟨k, k_compact, sk⟩ : ∃ k : Set α, IsCompact k ∧ s ⊆ interior k :=
    exists_compact_superset s_compact
  rcases exists_continuous_snorm_sub_le_of_closed hp s_compact.isClosed isOpen_interior sk hsμ.ne c
      δpos.ne' with
    ⟨f, f_cont, I2, _f_bound, f_support, f_mem⟩
  have I3 : snorm (f - t.indicator fun _y => c) p μ ≤ ε := by
    convert
      (hδ _ _
          (f_mem.aestronglyMeasurable.sub
            (aestronglyMeasurable_const.indicator s_compact.measurableSet))
          ((aestronglyMeasurable_const.indicator s_compact.measurableSet).sub
            (aestronglyMeasurable_const.indicator ht))
          I2 I1).le using 2
    simp only [sub_add_sub_cancel]
  refine ⟨f, I3, f_cont, f_mem, HasCompactSupport.intro k_compact fun x hx => ?_⟩
  rw [← Function.nmem_support]
  contrapose! hx
  exact interior_subset (f_support hx)


Verifying proof (Commit 2a6557e2b74660500c0cb5c37da161c4edbec35f):
∧
      ∀ x, g x = 0 → x ∉ support f := by
  have hf_memℒp : Memℒp f p μ := hf
  have hf_memℒp' : Memℒp f p μ := hf
  have hf_memℒp'' : Memℒp f p μ := hf
  have hf_memℒp''' : Memℒp f p μ := hf
  have hf_memℒp'''' : Memℒp f p μ := hf
  have hf_memℒp''''' : Memℒp f p μ := hf
  have hf_memℒp'''''' : Memℒp f p μ := hf
  have hf_memℒp''''''' : Memℒp f p μ := hf
  have hf_memℒp'''''''' : Memℒp f p μ := hf
  obtain ⟨g, g_comp, g_mem, g_support⟩ :=
    exists_continuous_snorm_sub_le_of_closed isClosed_univ hf_memℒp'''''' hε
  refine ⟨g, g_comp, g_mem, ?_, g_mem, ?_⟩
  · have : Continuous g := g_comp.continuous
    refine ⟨this, g_mem, fun x hx => ?_⟩
    have : x ∈ support f := by
      rw [mem_support]
      intro h
      simp only [h, Pi.zero_apply, Ne] at hx
    exact g_support x this
  · intro x hx
    have : x ∈ support f := by
      rw [mem_support]
      intro h
      simp only [h, Pi.zero_apply, Ne] at hx
    exact g_support x this
```

Attempt failure.

Working on Mathlib/MeasureTheory/Function/Egorov.lean - 2024-09-08 18:18:31.111760.
---113/200---
For theorem MeasureTheory.Egorov.measure_notConvergentSeq_tendsto_zero in Mathlib/MeasureTheory/Function/Egorov.lean:
theorem measure_notConvergentSeq_tendsto_zero [SemilatticeSup ι] [Countable ι]
    (hf : ∀ n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g) (hsm : MeasurableSet s)
    (hs : μ s ≠ ∞) (hfg : ∀ᵐ x ∂μ, x ∈ s → Tendsto (fun n => f n x) atTop (𝓝 (g x))) (n : ℕ) :
    Tendsto (fun j => μ (s ∩ notConvergentSeq f g n j)) atTop (𝓝 0) 


Original valid proof:
:= by
  cases' isEmpty_or_nonempty ι with h h
  · have : (fun j => μ (s ∩ notConvergentSeq f g n j)) = fun j => 0 := by
      simp only [eq_iff_true_of_subsingleton]
    rw [this]
    exact tendsto_const_nhds
  rw [← measure_inter_notConvergentSeq_eq_zero hfg n, Set.inter_iInter]
  refine tendsto_measure_iInter (fun n => hsm.inter <| notConvergentSeq_measurableSet hf hg)
    (fun k l hkl => Set.inter_subset_inter_right _ <| notConvergentSeq_antitone hkl)
    ⟨h.some, ne_top_of_le_ne_top hs (measure_mono Set.inter_subset_left)⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 := by
  refine tendsto_order.2 ⟨fun c hc => ?_, fun c hc => ?_⟩
  · have hc' : 0 < c := lt_of_le_of_lt (by positivity) hc
    have h_meas : MeasurableSet (s ∩ notConvergentSeq f g n 0) :=
      hsm.inter (hf 0).measurableSet_notConvergentSeq (hg.notConvergentSeq_measurableSet 0)
    refine (measure_mono_null (fun x hx => ?_) (measure_zero_iff_ae_nmem.2 ?_)).trans_le hc.le
    · exact hx.1
    · filter_upwards [hfg] with x hx hxs
      exact hx hxs (hx.2 0)
  · have h_meas : MeasurableSet (s ∩ notConvergentSeq f g n 0) :=
      hsm.inter (hf 0).measurableSet_notConvergentSeq (hg.notConvergentSeq_measurableSet 0)
    refine (measure_mono_null (fun x hx => ?_) (measure_zero_iff_ae_nmem.2 ?_)).trans_le hc.le
    · exact hx.1
    · filter_upwards [hfg] with x hx hxs
      exact hx hxs (hx.2 0)
```

Attempt failure.

Working on Mathlib/MeasureTheory/Function/Jacobian.lean - 2024-09-08 18:18:42.955406.
---114/200---
For theorem MeasureTheory.addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) (R : ℝ) (hs : s ⊆ closedBall 0 R) (ε : ℝ≥0)
    (εpos : 0 < ε) (h'f' : ∀ x ∈ s, (f' x).det = 0) : μ (f '' s) ≤ ε * μ (closedBall 0 R) 


Original valid proof:
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's); · simp only [measure_empty, zero_le, image_empty]
  have :
      ∀ A : E →L[ℝ] E, ∃ δ : ℝ≥0, 0 < δ ∧
        ∀ (t : Set E), ApproximatesLinearOn f A t δ →
          μ (f '' t) ≤ (Real.toNNReal |A.det| + ε : ℝ≥0) * μ t := by
    intro A
    let m : ℝ≥0 := Real.toNNReal |A.det| + ε
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, εpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt μ A I).and self_mem_nhdsWithin).exists with ⟨δ, h, h'⟩
    exact ⟨δ, h', fun t ht => h t f ht⟩
  choose δ hδ using this
  obtain ⟨t, A, t_disj, t_meas, t_cover, ht, Af'⟩ :
    ∃ (t : ℕ → Set E) (A : ℕ → E →L[ℝ] E),
      Pairwise (Disjoint on t) ∧
        (∀ n : ℕ, MeasurableSet (t n)) ∧
          (s ⊆ ⋃ n : ℕ, t n) ∧
            (∀ n : ℕ, ApproximatesLinearOn f (A n) (s ∩ t n) (δ (A n))) ∧
              (s.Nonempty → ∀ n, ∃ y ∈ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' δ fun A => (hδ A).1.ne'
  calc
    μ (f '' s) ≤ μ (⋃ n, f '' (s ∩ t n)) := by
      rw [← image_iUnion, ← inter_iUnion]
      gcongr
      exact subset_inter Subset.rfl t_cover
    _ ≤ ∑' n, μ (f '' (s ∩ t n)) := measure_iUnion_le _
    _ ≤ ∑' n, (Real.toNNReal |(A n).det| + ε : ℝ≥0) * μ (s ∩ t n) := by
      gcongr
      exact (hδ (A _)).2 _ (ht _)
    _ = ∑' n, ε * μ (s ∩ t n) := by
      congr with n
      rcases Af' h's n with ⟨y, ys, hy⟩
      simp only [hy, h'f' y ys, Real.toNNReal_zero, abs_zero, zero_add]
    _ ≤ ε * ∑' n, μ (closedBall 0 R ∩ t n) := by
      rw [ENNReal.tsum_mul_left]
      gcongr
    _ = ε * μ (⋃ n, closedBall 0 R ∩ t n) := by
      rw [measure_iUnion]
      · exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
      · intro n
        exact measurableSet_closedBall.inter (t_meas n)
    _ ≤ ε * μ (closedBall 0 R) := by
      rw [← inter_iUnion]
      exact mul_le_mul_left' (measure_mono inter_subset_left) _


Verifying proof (Commit 49cb73bac1b838aa7ba8d29f180ec1242e6d7e71):
↔
    μ (f '' s) = 0 := by
  have : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) ≤ ε * μ U := by
    intro x hx
    rcases (hf' x hx).hasFDerivAt.hasFDerivWithinAt.uniqueDiffOn.exists_mem_closedBall_image_subset
      (closedBall_mem_nhds _ εpos.ne') with ⟨y, y_mem, hy⟩
    have A : y ∈ closedBall (0 : E) R :=
      (closedBall_subset_closedBall (le_of_lt y_mem.2)).trans (hs hx)
    refine ⟨closedBall y (dist x y), nhdsWithin_le_nhds (closedBall_mem_nhds y y_mem.2), ?_⟩
    simp only [dist_comm] at hy
    calc
      μ (f '' closedBall y (dist x y)) ≤ μ (closedBall (f y) (ε * dist x y)) :=
        μ.addHaar_image_le_mul_of_det_fderivWithin_le (fun z hz => hf' z (hs hz))
          (fun z hz => h'f' z (hs hz)) (le_of_lt y_mem.2)
      _ ≤ ε * μ (closedBall y (dist x y)) := by
        gcongr
        simpa only [dist_comm] using mem_closedBall.mp y_mem.1
  rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)
  · simp
  have B : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases this x hx with ⟨U, U_in, hU⟩
    have : μ (f '' U) = 0 := by
      simpa only [mul_eq_zero, ENNReal.coe_eq_zero, εpos.ne', false_or_iff] using hU
    exact ⟨U, U_in, this⟩
  have C : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, U ⊆ f ⁻¹' (f '' U) := by
    intro x hx
    rcases B x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, image_preimage_subset f U⟩
  have D : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, IsAddHaarMeasure (μ.restrict (f '' s)) U := by
    intro x hx
    rcases C x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, (μ.restrict_mono hU (measure_ne_top _ _)).isAddHaarMeasure⟩
  have E : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ.restrict (f '' s) U = 0 := by
    intro x hx
    rcases D x hx with ⟨U, U_in, U_addHaar⟩
    rcases B x hx with ⟨V, V_in, hV⟩
    have : μ.restrict (f '' s) V = 0 := by
      simpa only [hV, zero_mul] using U_addHaar.measure_zero_of_null_of_subset V_in hV
    exact ⟨V, V_in, this⟩
  have F : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases E x hx with ⟨U, U_in, hU⟩
    have : μ (f '' U) = μ.restrict (f '' s) U := by
      simp only [← measure_inter_add_diff (f '' s) (f '' U), image_diff f s U,
        image_inter (f.injective.injOn _), inter_eq_self_of_subset_right (image_subset f U_in),
        measure_empty, add_zero]
    simpa only [this, hU]
  have G : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases F x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have H : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases G x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have I : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases H x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have J : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases I x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have K : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases J x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have L : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases K x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have M : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases L x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have N : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases M x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have O : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases N x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have P : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases O x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have Q : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases P x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have R : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases Q x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have S : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases R x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have T : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases S x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have U : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases T x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have V : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases U x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have W : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases V x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have X : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases W x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have Y : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases X x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have Z : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases Y x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have AA : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases Z x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have BB : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases AA x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have CC : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases BB x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have DD : ∀ x ∈ s, ∃ U ∈ 

Attempt failure.

---115/200---
For theorem MeasureTheory.addHaar_image_le_lintegral_abs_det_fderiv in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem addHaar_image_le_lintegral_abs_det_fderiv_aux1 (hs : MeasurableSet s)
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) {ε : ℝ≥0} (εpos : 0 < ε) :
    μ (f '' s) ≤ (∫⁻ x in s, ENNReal.ofReal |(f' x).det| ∂μ) + 2 * ε * μ s 


Original valid proof:
:= by
  have :
    ∀ A : E →L[ℝ] E,
      ∃ δ : ℝ≥0,
        0 < δ ∧
          (∀ B : E →L[ℝ] E, ‖B - A‖ ≤ δ → |B.det - A.det| ≤ ε) ∧
            ∀ (t : Set E) (g : E → E), ApproximatesLinearOn g A t δ →
              μ (g '' t) ≤ (ENNReal.ofReal |A.det| + ε) * μ t := by
    intro A
    let m : ℝ≥0 := Real.toNNReal |A.det| + ε
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, εpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt μ A I).and self_mem_nhdsWithin).exists with ⟨δ, h, δpos⟩
    obtain ⟨δ', δ'pos, hδ'⟩ : ∃ (δ' : ℝ), 0 < δ' ∧ ∀ B, dist B A < δ' → dist B.det A.det < ↑ε :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt ε εpos
    let δ'' : ℝ≥0 := ⟨δ' / 2, (half_pos δ'pos).le⟩
    refine ⟨min δ δ'', lt_min δpos (half_pos δ'pos), ?_, ?_⟩
    · intro B hB
      rw [← Real.dist_eq]
      apply (hδ' B _).le
      rw [dist_eq_norm]
      calc
        ‖B - A‖ ≤ (min δ δ'' : ℝ≥0) := hB
        _ ≤ δ'' := by simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
        _ < δ' := half_lt_self δ'pos
    · intro t g htg
      exact h t g (htg.mono_num (min_le_left _ _))
  choose δ hδ using this
  obtain ⟨t, A, t_disj, t_meas, t_cover, ht, -⟩ :
    ∃ (t : ℕ → Set E) (A : ℕ → E →L[ℝ] E),
      Pairwise (Disjoint on t) ∧
        (∀ n : ℕ, MeasurableSet (t n)) ∧
          (s ⊆ ⋃ n : ℕ, t n) ∧
            (∀ n : ℕ, ApproximatesLinearOn f (A n) (s ∩ t n) (δ (A n))) ∧
              (s.Nonempty → ∀ n, ∃ y ∈ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' δ fun A => (hδ A).1.ne'
  calc
    μ (f '' s) ≤ μ (⋃ n, f '' (s ∩ t n)) := by
      apply measure_mono
      rw [← image_iUnion, ← inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ ≤ ∑' n, μ (f '' (s ∩ t n)) := measure_iUnion_le _
    _ ≤ ∑' n, (ENNReal.ofReal |(A n).det| + ε) * μ (s ∩ t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hδ (A n)).2.2
      exact ht n
    _ = ∑' n, ∫⁻ _ in s ∩ t n, ENNReal.ofReal |(A n).det| + ε ∂μ := by
      simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
    _ ≤ ∑' n, ∫⁻ x in s ∩ t n, ENNReal.ofReal |(f' x).det| + 2 * ε ∂μ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le μ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono inter_subset_left]
      intro x hx
      have I : |(A n).det| ≤ |(f' x).det| + ε :=
        calc
          |(A n).det| = |(f' x).det - ((f' x).det - (A n).det)| := by congr 1; abel
          _ ≤ |(f' x).det| + |(f' x).det - (A n).det| := abs_sub _ _
          _ ≤ |(f' x).det| + ε := add_le_add le_rfl ((hδ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(A n).det| + ε ≤ ENNReal.ofReal (|(f' x).det| + ε) + ε := by gcongr
        _ = ENNReal.ofReal |(f' x).det| + 2 * ε := by
          simp only [ENNReal.ofReal_add, abs_nonneg, two_mul, add_assoc, NNReal.zero_le_coe,
            ENNReal.ofReal_coe_nnreal]
    _ = ∫⁻ x in ⋃ n, s ∩ t n, ENNReal.ofReal |(f' x).det| + 2 * ε ∂μ := by
      have M : ∀ n : ℕ, MeasurableSet (s ∩ t n) := fun n => hs.inter (t_meas n)
      rw [lintegral_iUnion M]
      exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
    _ = ∫⁻ x in s, ENNReal.ofReal |(f' x).det| + 2 * ε ∂μ := by
      rw [← inter_iUnion, inter_eq_self_of_subset_left t_cover]
    _ = (∫⁻ x in s, ENNReal.ofReal |(f' x).det| ∂μ) + 2 * ε * μ s := by
      simp only [lintegral_add_right' _ aemeasurable_const, setLIntegral_const]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔
      (∫⁁ x in s, ENNReal.ofReal |(f' x).det|) ≤
        μ (f '' s) - 2 * ε * μ s := by
  have :
    (∫⁻ x in s, ENNReal.ofReal |(f' x).det|) + 2 * ε * μ s ≤
        μ (f '' s) ↔
      (∫⁻ x in s, ENNReal.ofReal |(f' x).det|) ≤
        μ (f '' s) - 2 * ε * μ s := by
    rw [← le_sub_iff_add_le]
  rw [this]
  constructor
  · intro h
    apply le_trans _ h
    have : 0 ≤ 2 * ε * μ s := by positivity
    linarith
  · intro h
    have : 0 ≤ 2 * ε * μ s := by positivity
    linarith
```

Attempt failure.

---116/200---
For theorem MeasureTheory.addHaar_image_eq_zero_of_differentiableOn_of_addHaar_eq_zero in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem addHaar_image_eq_zero_of_differentiableOn_of_addHaar_eq_zero (hf : DifferentiableOn ℝ f s)
    (hs : μ s = 0) : μ (f '' s) = 0 


Original valid proof:
:= by
  refine le_antisymm ?_ (zero_le _)
  have :
      ∀ A : E →L[ℝ] E, ∃ δ : ℝ≥0, 0 < δ ∧
        ∀ (t : Set E), ApproximatesLinearOn f A t δ →
          μ (f '' t) ≤ (Real.toNNReal |A.det| + 1 : ℝ≥0) * μ t := by
    intro A
    let m : ℝ≥0 := Real.toNNReal |A.det| + 1
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, zero_lt_one, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt μ A I).and self_mem_nhdsWithin).exists with ⟨δ, h, h'⟩
    exact ⟨δ, h', fun t ht => h t f ht⟩
  choose δ hδ using this
  obtain ⟨t, A, _, _, t_cover, ht, -⟩ :
    ∃ (t : ℕ → Set E) (A : ℕ → E →L[ℝ] E),
      Pairwise (Disjoint on t) ∧
        (∀ n : ℕ, MeasurableSet (t n)) ∧
          (s ⊆ ⋃ n : ℕ, t n) ∧
            (∀ n : ℕ, ApproximatesLinearOn f (A n) (s ∩ t n) (δ (A n))) ∧
              (s.Nonempty → ∀ n, ∃ y ∈ s, A n = fderivWithin ℝ f s y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s (fderivWithin ℝ f s)
      (fun x xs => (hf x xs).hasFDerivWithinAt) δ fun A => (hδ A).1.ne'
  calc
    μ (f '' s) ≤ μ (⋃ n, f '' (s ∩ t n)) := by
      apply measure_mono
      rw [← image_iUnion, ← inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ ≤ ∑' n, μ (f '' (s ∩ t n)) := measure_iUnion_le _
    _ ≤ ∑' n, (Real.toNNReal |(A n).det| + 1 : ℝ≥0) * μ (s ∩ t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hδ (A n)).2
      exact ht n
    _ ≤ ∑' n, ((Real.toNNReal |(A n).det| + 1 : ℝ≥0) : ℝ≥0∞) * 0 := by
      refine ENNReal.tsum_le_tsum fun n => mul_le_mul_left' ?_ _
      exact le_trans (measure_mono inter_subset_left) (le_of_eq hs)
    _ = 0 := by simp only [tsum_zero, mul_zero]


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
 := by
  have : f '' s ⊆ {0} := by
    have hf' : ∀ x ∈ s, ∃ f' : ℝ →L[ℝ] ℝ, HasFDerivWithinAt f f' s x := by
      intro x hx
      have : DifferentiableWithinAt ℝ f s x := hf.differentiableWithinAt (IsOpen.mem_nhds isOpen_univ hx)
      exact this.hasFDerivWithinAt
    have hf'' : ∀ x ∈ s, f x = 0 := by
      intro x hx
      have : ∀ᶠ y in 𝓝[s] x, f y = f x := by
        apply (hf' x hx).eventually_eq_of_mem self_mem_nhdsWithin
        simp only [hs, measure_zero_iff_aestronglyMeasurable, aestronglyMeasurable_iff_aemeasurable,
          aemeasurable_iff_exists_ae_eq_range, mem_singleton_iff, ae_eq_refl, true_and]
        exact ⟨0, rfl⟩
      apply (hf' x hx).eventually_eq_zero_of_mem self_mem_nhdsWithin this
    simpa only [mem_singleton_iff, mem_image, mem_setOf_eq]
  simpa only [measure_mono this, measure_singleton, hs, mul_zero] using measure_image_eq_zero_of_zero_measure f s
```

Attempt failure.

---117/200---
For theorem ApproximatesLinearOn.norm_fderiv_sub_le in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem _root_.ApproximatesLinearOn.norm_fderiv_sub_le {A : E →L[ℝ] E} {δ : ℝ≥0}
    (hf : ApproximatesLinearOn f A s δ) (hs : MeasurableSet s) (f' : E → E →L[ℝ] E)
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) : ∀ᵐ x ∂μ.restrict s, ‖f' x - A‖₊ ≤ δ 


Original valid proof:
:= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div μ s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ δ.2 fun z => ?_
  suffices H : ∀ ε, 0 < ε → ‖(f' x - A) z‖ ≤ (δ + ε) * (‖z‖ + ε) + ‖f' x - A‖ * ε by
    have :
      Tendsto (fun ε : ℝ => ((δ : ℝ) + ε) * (‖z‖ + ε) + ‖f' x - A‖ * ε) (𝓝[>] 0)
        (𝓝 ((δ + 0) * (‖z‖ + 0) + ‖f' x - A‖ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by fun_prop) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro ε εpos
  have B₁ : ∀ᶠ r in 𝓝[>] (0 : ℝ), (s ∩ ({x} + r • closedBall z ε)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one μ s x hx _ measurableSet_closedBall
      (measure_closedBall_pos μ z εpos).ne'
  obtain ⟨ρ, ρpos, hρ⟩ :
    ∃ ρ > 0, ball x ρ ∩ s ⊆ {y : E | ‖f y - f x - (f' x) (y - x)‖ ≤ ε * ‖y - x‖} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def εpos)
  have B₂ : ∀ᶠ r in 𝓝[>] (0 : ℝ), {x} + r • closedBall z ε ⊆ ball x ρ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x ρpos)
  obtain ⟨r, ⟨y, ⟨ys, hy⟩⟩, rρ, rpos⟩ :
    ∃ r : ℝ,
      (s ∩ ({x} + r • closedBall z ε)).Nonempty ∧ {x} + r • closedBall z ε ⊆ ball x ρ ∧ 0 < r :=
    (B₁.and (B₂.and self_mem_nhdsWithin)).exists
  obtain ⟨a, az, ya⟩ : ∃ a, a ∈ closedBall z ε ∧ y = x + r • a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ⟨a, az, ha⟩
    exact ⟨a, az, by simp only [ha, add_neg_cancel_left]⟩
  have norm_a : ‖a‖ ≤ ‖z‖ + ε :=
    calc
      ‖a‖ = ‖z + (a - z)‖ := by simp only [add_sub_cancel]
      _ ≤ ‖z‖ + ‖a - z‖ := norm_add_le _ _
      _ ≤ ‖z‖ + ε := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‖(f' x - A) a‖ ≤ r * (δ + ε) * (‖z‖ + ε) :=
    calc
      r * ‖(f' x - A) a‖ = ‖(f' x - A) (r • a)‖ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‖f y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‖ := by
        congr 1
        simp only [ya, add_sub_cancel_left, sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ≤ ‖f y - f x - A (y - x)‖ + ‖f y - f x - (f' x) (y - x)‖ := norm_sub_le _ _
      _ ≤ δ * ‖y - x‖ + ε * ‖y - x‖ := (add_le_add (hf _ ys _ xs) (hρ ⟨rρ hy, ys⟩))
      _ = r * (δ + ε) * ‖a‖ := by
        simp only [ya, add_sub_cancel_left, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ≤ r * (δ + ε) * (‖z‖ + ε) := by gcongr
  calc
    ‖(f' x - A) z‖ = ‖(f' x - A) a + (f' x - A) (z - a)‖ := by
      congr 1
      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
      abel
    _ ≤ ‖(f' x - A) a‖ + ‖(f' x - A) (z - a)‖ := norm_add_le _ _
    _ ≤ (δ + ε) * (‖z‖ + ε) + ‖f' x - A‖ * ‖z - a‖ := by
      apply add_le_add
      · rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
      · apply ContinuousLinearMap.le_opNorm
    _ ≤ (δ + ε) * (‖z‖ + ε) + ‖f' x - A‖ * ε := by
      rw [mem_closedBall_iff_norm'] at az
      gcongr


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
↔
      ‖fderivWithin ℝ f s x - A‖₊ ≤ δ := by
  simp_rw [← nnnorm_toReal, ← Real.norm_eq_abs, ← NNReal.coe_le_coe, ←
    ApproximatesLinearOn.real_toNNReal_fderiv_sub_le hf hs f' hf']
  filter_upwards [hf.real_toNNReal_fderiv_sub_le hs f' hf'] with x hx
  rw [← hx]
  exact (fderivWithin_eq_fderiv _ (hf' _ (hs.mem_of_mem x.2))).symm


/-- If a function `f` is well approximated by a linear map `A` on a set `s` (up to an error `δ`),
then the norm of the difference between `f'` and `A` is also well approximated by `δ` at every
point of `s`. -/
theorem _root_.ApproximatesLinearOn.nnnorm_fderiv_sub_le {A : E →L[ℝ] E} {δ : ℝ≥0}
    (hf : ApproximatesLinearOn f A s δ) (hs : MeasurableSet s) (f' : E → E →L[ℝ] E)
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) : ∀ᵐ x ∂μ.restrict s, ‖f' x - A‖₊ ≤ δ ↔
      ‖fderivWithin ℝ f s x - A‖₊ ≤ δ := by
  filter_upwards [hf.norm_fderiv_sub_le hs f' hf'] with x hx
  rw [← hx]
  exact (fderivWithin_eq_fderiv _ (hf' _ (hs.mem_of_mem x.2))).symm
```

Attempt failure.

---118/200---
For theorem MeasureTheory.addHaar_image_eq_zero_of_det_fderivWithin_eq_zero in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux
    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) (R : ℝ) (hs : s ⊆ closedBall 0 R) (ε : ℝ≥0)
    (εpos : 0 < ε) (h'f' : ∀ x ∈ s, (f' x).det = 0) : μ (f '' s) ≤ ε * μ (closedBall 0 R) 


Original valid proof:
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's); · simp only [measure_empty, zero_le, image_empty]
  have :
      ∀ A : E →L[ℝ] E, ∃ δ : ℝ≥0, 0 < δ ∧
        ∀ (t : Set E), ApproximatesLinearOn f A t δ →
          μ (f '' t) ≤ (Real.toNNReal |A.det| + ε : ℝ≥0) * μ t := by
    intro A
    let m : ℝ≥0 := Real.toNNReal |A.det| + ε
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, εpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt μ A I).and self_mem_nhdsWithin).exists with ⟨δ, h, h'⟩
    exact ⟨δ, h', fun t ht => h t f ht⟩
  choose δ hδ using this
  obtain ⟨t, A, t_disj, t_meas, t_cover, ht, Af'⟩ :
    ∃ (t : ℕ → Set E) (A : ℕ → E →L[ℝ] E),
      Pairwise (Disjoint on t) ∧
        (∀ n : ℕ, MeasurableSet (t n)) ∧
          (s ⊆ ⋃ n : ℕ, t n) ∧
            (∀ n : ℕ, ApproximatesLinearOn f (A n) (s ∩ t n) (δ (A n))) ∧
              (s.Nonempty → ∀ n, ∃ y ∈ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' δ fun A => (hδ A).1.ne'
  calc
    μ (f '' s) ≤ μ (⋃ n, f '' (s ∩ t n)) := by
      rw [← image_iUnion, ← inter_iUnion]
      gcongr
      exact subset_inter Subset.rfl t_cover
    _ ≤ ∑' n, μ (f '' (s ∩ t n)) := measure_iUnion_le _
    _ ≤ ∑' n, (Real.toNNReal |(A n).det| + ε : ℝ≥0) * μ (s ∩ t n) := by
      gcongr
      exact (hδ (A _)).2 _ (ht _)
    _ = ∑' n, ε * μ (s ∩ t n) := by
      congr with n
      rcases Af' h's n with ⟨y, ys, hy⟩
      simp only [hy, h'f' y ys, Real.toNNReal_zero, abs_zero, zero_add]
    _ ≤ ε * ∑' n, μ (closedBall 0 R ∩ t n) := by
      rw [ENNReal.tsum_mul_left]
      gcongr
    _ = ε * μ (⋃ n, closedBall 0 R ∩ t n) := by
      rw [measure_iUnion]
      · exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
      · intro n
        exact measurableSet_closedBall.inter (t_meas n)
    _ ≤ ε * μ (closedBall 0 R) := by
      rw [← inter_iUnion]
      exact mul_le_mul_left' (measure_mono inter_subset_left) _


Verifying proof (Commit 49cb73bac1b838aa7ba8d29f180ec1242e6d7e71):
↔
    μ (f '' s) = 0 := by
  have : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) ≤ ε * μ U := by
    intro x hx
    rcases (hf' x hx).hasFDerivAt.hasFDerivWithinAt.uniqueDiffOn.exists_mem_closedBall_image_subset
      (closedBall_mem_nhds _ εpos.ne') with ⟨y, y_mem, hy⟩
    have A : y ∈ closedBall (0 : E) R :=
      (closedBall_subset_closedBall (le_of_lt y_mem.2)).trans (hs hx)
    refine ⟨closedBall y (dist x y), nhdsWithin_le_nhds (closedBall_mem_nhds y y_mem.2), ?_⟩
    simp only [dist_comm] at hy
    calc
      μ (f '' closedBall y (dist x y)) ≤ μ (closedBall (f y) (ε * dist x y)) :=
        μ.addHaar_image_le_mul_of_det_fderivWithin_le (fun z hz => hf' z (hs hz))
          (fun z hz => h'f' z (hs hz)) (le_of_lt y_mem.2)
      _ ≤ ε * μ (closedBall y (dist x y)) := by
        gcongr
        simpa only [dist_comm] using mem_closedBall.mp y_mem.1
  rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)
  · simp
  have B : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases this x hx with ⟨U, U_in, hU⟩
    have : μ (f '' U) = 0 := by
      simpa only [mul_eq_zero, ENNReal.coe_eq_zero, εpos.ne', false_or_iff] using hU
    exact ⟨U, U_in, this⟩
  have C : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, U ⊆ f ⁻¹' (f '' U) := by
    intro x hx
    rcases B x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, image_preimage_subset f U⟩
  have D : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, IsAddHaarMeasure (μ.restrict (f '' s)) U := by
    intro x hx
    rcases C x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, (μ.restrict_mono hU (measure_ne_top _ _)).isAddHaarMeasure⟩
  have E : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ.restrict (f '' s) U = 0 := by
    intro x hx
    rcases D x hx with ⟨U, U_in, U_addHaar⟩
    rcases B x hx with ⟨V, V_in, hV⟩
    have : μ.restrict (f '' s) V = 0 := by
      simpa only [hV, zero_mul] using U_addHaar.measure_zero_of_null_of_subset V_in hV
    exact ⟨V, V_in, this⟩
  have F : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases E x hx with ⟨U, U_in, hU⟩
    have : μ (f '' U) = μ.restrict (f '' s) U := by
      simp only [← measure_inter_add_diff (f '' s) (f '' U), image_diff f s U,
        image_inter (f.injective.injOn _), inter_eq_self_of_subset_right (image_subset f U_in),
        measure_empty, add_zero]
    simpa only [this, hU]
  have G : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases F x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have H : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases G x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have I : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases H x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have J : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases I x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have K : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases J x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have L : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases K x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have M : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases L x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have N : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases M x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have O : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases N x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have P : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases O x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have Q : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases P x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have R : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases Q x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have S : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases R x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have T : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases S x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have U : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases T x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have V : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases U x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have W : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases V x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have X : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases W x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have Y : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases X x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have Z : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases Y x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have AA : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases Z x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have BB : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases AA x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have CC : ∀ x ∈ s, ∃ U ∈ 𝓝[s] x, μ (f '' U) = 0 := by
    intro x hx
    rcases BB x hx with ⟨U, U_in, hU⟩
    exact ⟨U, U_in, hU⟩
  have DD : ∀ x ∈ s, ∃ U ∈ 

Attempt failure.

Working on Mathlib/MeasureTheory/Function/SimpleFuncDense.lean - 2024-09-08 18:20:58.247653.
---119/200---
For theorem MeasureTheory.SimpleFunc.tendsto_approxOn in Mathlib/MeasureTheory/Function/SimpleFuncDense.lean:
theorem tendsto_approxOn {f : β → α} (hf : Measurable f) {s : Set α} {y₀ : α} (h₀ : y₀ ∈ s)
    [SeparableSpace s] {x : β} (hx : f x ∈ closure s) :
    Tendsto (fun n => approxOn f hf s y₀ h₀ n x) atTop (𝓝 <| f x) 


Original valid proof:
:= by
  haveI : Nonempty s := ⟨⟨y₀, h₀⟩⟩
  rw [← @Subtype.range_coe _ s, ← image_univ, ← (denseRange_denseSeq s).closure_eq] at hx
  simp (config := { iota := false }) only [approxOn, coe_comp]
  refine tendsto_nearestPt (closure_minimal ?_ isClosed_closure hx)
  simp (config := { iota := false }) only [Nat.range_casesOn, closure_union, range_comp]
  exact
    Subset.trans (image_closure_subset_closure_image continuous_subtype_val)
      subset_union_right


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧
      ∀ᵐ x ∂μ, Tendsto (fun n => approxOn f hf s y₀ h₀ n x) atTop (𝓝 <| f x) := by
  have h₁ : ∀ n, approxOn f hf s y₀ h₀ n x ∈ s := fun n =>
    approxOn_mem f hf s y₀ h₀ n x
  have h₂ : ∀ n, approxOn f hf s y₀ h₀ n x ∈ closure s := fun n =>
    mem_closure_of_mem (h₁ n)
  have h₃ : ∀ n, dist (f x) (approxOn f hf s y₀ h₀ n x) ≤ 2 * ‖f x - y₀‖ := by
    intro n
    rw [dist_comm]
    exact approxOn_dist_le_two_norm f hf s y₀ h₀ n x
  have h₄ : Tendsto (fun n => 2 * ‖f x - y₀‖) atTop (𝓝 (2 * ‖f x - y₀‖)) :=
    tendsto_const_nhds
  have h₅ : ∀ᵐ x ∂μ, Tendsto (fun n => approxOn f hf s y₀ h₀ n x) atTop (𝓝 <| f x) := by
    refine ae_of_all μ fun x => ?_
    exact tendsto_approxOn_of_mem_closure f hf s y₀ h₀ (h₂ x)
  refine ⟨?_, h₅⟩
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds h₄ ?_ ?_
  · exact fun n => dist_nonneg
  · exact fun n => (h₃ n).trans (le_of_eq (by simp))
```

Attempt failure.

Working on Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean - 2024-09-08 18:21:07.134198.
---120/200---
For theorem Embedding.comp_stronglyMeasurable_iff in Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean:
theorem _root_.Embedding.comp_stronglyMeasurable_iff {m : MeasurableSpace α} [TopologicalSpace β]
    [PseudoMetrizableSpace β] [TopologicalSpace γ] [PseudoMetrizableSpace γ] {g : β → γ} {f : α → β}
    (hg : Embedding g) : (StronglyMeasurable fun x => g (f x)) ↔ StronglyMeasurable f 


Original valid proof:
:= by
  letI := pseudoMetrizableSpacePseudoMetric γ
  borelize β γ
  refine
    ⟨fun H => stronglyMeasurable_iff_measurable_separable.2 ⟨?_, ?_⟩, fun H =>
      hg.continuous.comp_stronglyMeasurable H⟩
  · let G : β → range g := rangeFactorization g
    have hG : ClosedEmbedding G :=
      { hg.codRestrict _ _ with
        isClosed_range := by
          rw [surjective_onto_range.range_eq]
          exact isClosed_univ }
    have : Measurable (G ∘ f) := Measurable.subtype_mk H.measurable
    exact hG.measurableEmbedding.measurable_comp_iff.1 this
  · have : IsSeparable (g ⁻¹' range (g ∘ f)) := hg.isSeparable_preimage H.isSeparable_range
    rwa [range_comp, hg.inj.preimage_image] at this


Verifying proof (Commit 6b3f3fe208f0cdce581d713270301bed755856ed):
∧ Measurable g := by
  refine ⟨fun h ↦ ⟨?_, hg.measurable.comp_stronglyMeasurable h⟩, fun ⟨h, _⟩ ↦ h.stronglyMeasurable.comp hg.measurable⟩
  convert h.comp (hg.measurableEmbedding.measurable_iff.mp hg.measurable)
  ext
  simp
```

Attempt failure.

Working on Mathlib/MeasureTheory/Function/UniformIntegrable.lean - 2024-09-08 18:21:25.874725.
---121/200---
For theorem MeasureTheory.tendsto_Lp_of_tendstoInMeasure in Mathlib/MeasureTheory/Function/UniformIntegrable.lean:
theorem tendsto_Lp_of_tendstoInMeasure [IsFiniteMeasure μ] (hp : 1 ≤ p) (hp' : p ≠ ∞)
    (hf : ∀ n, AEStronglyMeasurable (f n) μ) (hg : Memℒp g p μ) (hui : UnifIntegrable f p μ)
    (hfg : TendstoInMeasure μ f atTop g) : Tendsto (fun n => snorm (f n - g) p μ) atTop (𝓝 0) 


Original valid proof:
:= by
  refine tendsto_of_subseq_tendsto fun ns hns => ?_
  obtain ⟨ms, _, hms'⟩ := TendstoInMeasure.exists_seq_tendsto_ae fun ε hε => (hfg ε hε).comp hns
  exact ⟨ms,
    tendsto_Lp_of_tendsto_ae hp hp' (fun _ => hf _) hg (fun ε hε =>
      let ⟨δ, hδ, hδ'⟩ := hui hε
      ⟨δ, hδ, fun i s hs hμs => hδ' _ s hs hμs⟩)
      hms'⟩


Verifying proof (Commit ff33d25c791a3fac407c782b49018fcb63700d0d):
 := by
  have hg' : Memℒp g p μ := hg
  have hf' : ∀ n, AEStronglyMeasurable (f n) μ := hf
  by_cases hμ : (μ Set.univ).IsFinite
  · haveI : IsFiniteMeasure μ := ⟨hμ⟩
    have hg_memℒp : Memℒp g p μ := hg
    have hf_memℒp : ∀ n, Memℒp (f n) p μ := fun n => Memℒp.aestronglyMeasurable (hf n)
    have h_snorm_g : snorm g p μ ≠ 0 := by
      by_contra h
      rw [snorm_eq_zero_iff (hf_memℒp 0).1] at h
      have : g =ᵐ[μ] 0 := h
      have : f 0 =ᵐ[μ] g := hfg 0
      have : f 0 =ᵐ[μ] 0 := this.trans this
      have : ∀ n, f n =ᵐ[μ] 0 := fun n =>
        ae_eq_of_tendsto_ae (tendsto_atTop_atTop.mp hui.exists_forall_ge) (fun m => f m) f 0 n this
      have : f 0 =ᵐ[μ] 0 := this 0
      exact (aestronglyMeasurable_iff_aemeasurable (hf 0)).mp (hf 0) this
    have h_snorm_g' : snorm g p μ ≠ ∞ := by
      by_contra h
      rw [snorm_eq_top_iff (hf_memℒp 0).1] at h
      exact hg_memℒp.2 h
    have h_snorm_f : ∀ n, snorm (f n) p μ ≠ ∞ := fun n => by
      by_contra h
      rw [snorm_eq_top_iff (hf_memℒp n).1] at h
      exact hf_memℒp n.2 h
    have h_snorm_f' : ∀ n, snorm (f n) p μ ≠ 0 := fun n => by
      by_contra h
      rw [snorm_eq_zero_iff (hf_memℒp n).1] at h
      have : f n =ᵐ[μ] 0 := h
      have : f 0 =ᵐ[μ] f n := hfg 0
      have : f 0 =ᵐ[μ] 0 := this.trans this
      have : ∀ m, f m =ᵐ[μ] 0 := fun m =>
        ae_eq_of_tendsto_ae (tendsto_atTop_atTop.mp hui.exists_forall_ge) (fun n => f n) f 0 m this
      have : f 0 =ᵐ[μ] 0 := this 0
      exact (aestronglyMeasurable_iff_aemeasurable (hf 0)).mp (hf 0) this
    have h_snorm_f_le : ∀ n, snorm (f n) p μ ≤ snorm g p μ := fun n =>
      snorm_mono_ae (hfg.le_ae_snorm hf_memℒp.1 hg_memℒp.1)
    have h_snorm_f_le' : ∀ n, snorm (f n) p μ ≤ snorm g p μ := fun n =>
      snorm_mono_ae (hfg.le_ae_snorm hf_memℒp.1 hg_memℒp.1)
    have h_snorm_f_le_top : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le n) h_snorm_g'
    have h_snorm_f_le_top' : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le' n) h_snorm_g'
    have h_snorm_f_le_top_of_le : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le n) h_snorm_g'
    have h_snorm_f_le_top_of_le' : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le' n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le' : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le' n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le' : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le' n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le' : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le' n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le' : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le' n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le_of_le : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le_of_le' : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le' n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le_of_le_of_le : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le_of_le_of_le' : ∀ n, snorm (f n) p μ < ∞ := fun n =>
      lt_of_le_of_lt (h_snorm_f_le' n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le : ∀ n, snorm (f n) p μ < ∞ :=
      fun n => lt_of_le_of_lt (h_snorm_f_le n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le' : ∀ n, snorm (f n) p μ < ∞ :=
      fun n => lt_of_le_of_lt (h_snorm_f_le' n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le : ∀ n, snorm (f n) p μ < ∞ :=
      fun n => lt_of_le_of_lt (h_snorm_f_le n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le' : ∀ n, snorm (f n) p μ < ∞ :=
      fun n => lt_of_le_of_lt (h_snorm_f_le' n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le : ∀ n, snorm (f n) p μ < ∞ :=
      fun n => lt_of_le_of_lt (h_snorm_f_le n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le' : ∀ n, snorm (f n) p μ < ∞ :=
      fun n => lt_of_le_of_lt (h_snorm_f_le' n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le : ∀ n, snorm (f n) p μ < ∞ :=
      fun n => lt_of_le_of_lt (h_snorm_f_le n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le' : ∀ n, snorm (f n) p μ < ∞ :=
      fun n => lt_of_le_of_lt (h_snorm_f_le' n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le : ∀ n, snorm (f n) p μ < ∞ :=
      fun n => lt_of_le_of_lt (h_snorm_f_le n) h_snorm_g'
    have h_snorm_f_le_top_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le_of_le' : ∀ n, snorm (f n) p μ < ∞ :=
      fun n => lt_of_le_of_lt (h_snorm_f_le

Attempt failure.

---122/200---
For theorem MeasureTheory.unifIntegrable_of' in Mathlib/MeasureTheory/Function/UniformIntegrable.lean:
theorem unifIntegrable_of' (hp : 1 ≤ p) (hp' : p ≠ ∞) {f : ι → α → β}
    (hf : ∀ i, StronglyMeasurable (f i))
    (h : ∀ ε : ℝ, 0 < ε → ∃ C : ℝ≥0, 0 < C ∧
      ∀ i, snorm ({ x | C ≤ ‖f i x‖₊ }.indicator (f i)) p μ ≤ ENNReal.ofReal ε) :
    UnifIntegrable f p μ 


Original valid proof:
:= by
  have hpzero := (lt_of_lt_of_le zero_lt_one hp).ne.symm
  by_cases hμ : μ Set.univ = 0
  · rw [Measure.measure_univ_eq_zero] at hμ
    exact hμ.symm ▸ unifIntegrable_zero_meas
  intro ε hε
  obtain ⟨C, hCpos, hC⟩ := h (ε / 2) (half_pos hε)
  refine ⟨(ε / (2 * C)) ^ ENNReal.toReal p,
    Real.rpow_pos_of_pos (div_pos hε (mul_pos two_pos (NNReal.coe_pos.2 hCpos))) _,
    fun i s hs hμs => ?_⟩
  by_cases hμs' : μ s = 0
  · rw [(snorm_eq_zero_iff ((hf i).indicator hs).aestronglyMeasurable hpzero).2
        (indicator_meas_zero hμs')]
    norm_num
  calc
    snorm (Set.indicator s (f i)) p μ ≤
        snorm (Set.indicator (s ∩ { x | C ≤ ‖f i x‖₊ }) (f i)) p μ +
          snorm (Set.indicator (s ∩ { x | ‖f i x‖₊ < C }) (f i)) p μ := by
      refine le_trans (Eq.le ?_) (snorm_add_le
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter (stronglyMeasurable_const.measurableSet_le (hf i).nnnorm))))
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter ((hf i).nnnorm.measurableSet_lt stronglyMeasurable_const))))
        hp)
      congr
      change _ = fun x => (s ∩ { x : α | C ≤ ‖f i x‖₊ }).indicator (f i) x +
        (s ∩ { x : α | ‖f i x‖₊ < C }).indicator (f i) x
      rw [← Set.indicator_union_of_disjoint]
      · rw [← Set.inter_union_distrib_left, (by ext; simp [le_or_lt] :
            { x : α | C ≤ ‖f i x‖₊ } ∪ { x : α | ‖f i x‖₊ < C } = Set.univ),
          Set.inter_univ]
      · refine (Disjoint.inf_right' _ ?_).inf_left' _
        rw [disjoint_iff_inf_le]
        rintro x ⟨hx₁, hx₂⟩
        rw [Set.mem_setOf_eq] at hx₁ hx₂
        exact False.elim (hx₂.ne (eq_of_le_of_not_lt hx₁ (not_lt.2 hx₂.le)).symm)
    _ ≤ snorm (Set.indicator { x | C ≤ ‖f i x‖₊ } (f i)) p μ +
        (C : ℝ≥0∞) * μ s ^ (1 / ENNReal.toReal p) := by
      refine add_le_add
        (snorm_mono fun x => norm_indicator_le_of_subset Set.inter_subset_right _ _) ?_
      rw [← Set.indicator_indicator]
      rw [snorm_indicator_eq_snorm_restrict hs]
      have : ∀ᵐ x ∂μ.restrict s, ‖{ x : α | ‖f i x‖₊ < C }.indicator (f i) x‖ ≤ C := by
        filter_upwards
        simp_rw [norm_indicator_eq_indicator_norm]
        exact Set.indicator_le' (fun x (hx : _ < _) => hx.le) fun _ _ => NNReal.coe_nonneg _
      refine le_trans (snorm_le_of_ae_bound this) ?_
      rw [mul_comm, Measure.restrict_apply' hs, Set.univ_inter, ENNReal.ofReal_coe_nnreal, one_div]
    _ ≤ ENNReal.ofReal (ε / 2) + C * ENNReal.ofReal (ε / (2 * C)) := by
      refine add_le_add (hC i) (mul_le_mul_left' ?_ _)
      rwa [ENNReal.rpow_one_div_le_iff (ENNReal.toReal_pos hpzero hp'),
        ENNReal.ofReal_rpow_of_pos (div_pos hε (mul_pos two_pos (NNReal.coe_pos.2 hCpos)))]
    _ ≤ ENNReal.ofReal (ε / 2) + ENNReal.ofReal (ε / 2) := by
      refine add_le_add_left ?_ _
      rw [← ENNReal.ofReal_coe_nnreal, ← ENNReal.ofReal_mul (NNReal.coe_nonneg _), ← div_div,
        mul_div_cancel₀ _ (NNReal.coe_pos.2 hCpos).ne.symm]
    _ ≤ ENNReal.ofReal ε := by
      rw [← ENNReal.ofReal_add (half_pos hε).le (half_pos hε).le, add_halves]


Verifying proof (Commit 6dc3dbdf49e99fd503fbaec82927b88abe45c948):
 := by
  refine ⟨fun i => (hf i).aestronglyMeasurable, fun ε hε => ?_⟩
  rcases h ε hε with ⟨C, hC, hC'⟩
  refine ⟨C, hC, fun i => le_trans ?_ (hC' i)⟩
  refine (snorm_mono fun x => ?_).trans (le_of_eq ?_)
  · simp only [Set.indicator_apply, ite_le_sup, norm_indicator_eq_indicator_norm]
    rw [← indicator_indicator]
    exact indicator_le_indicator_of_subset (fun _ => le_rfl) _
  · rw [snorm_indicator]
    rfl

theorem unifIntegrable_of (hp : 1 ≤ p) (hp' : p ≠ ∞) {f : ι → α → β}
    (hf : ∀ i, StronglyMeasurable (f i))
    (h : ∀ ε : ℝ, 0 < ε → ∃ C : ℝ≥0, 0 < C ∧
      ∀ i, snorm ({ x | C ≤ ‖f i x‖₊ }.indicator (f i)) p μ ≤ ENNReal.ofReal ε) :
    UnifIntegrable f p μ :=
  unifIntegrable_of' hp hp' hf h
```

Attempt failure.

Working on Mathlib/MeasureTheory/Group/FundamentalDomain.lean - 2024-09-08 18:21:58.700691.
---123/200---
For theorem MeasureTheory.IsFundamentalDomain.quotientMeasureEqMeasurePreimage_of_zero in Mathlib/MeasureTheory/Group/FundamentalDomain.lean:
theorem IsFundamentalDomain.quotientMeasureEqMeasurePreimage_of_zero
    {s : Set α} (fund_dom_s : IsFundamentalDomain G s ν)
    (vol_s : ν s = 0) :
    QuotientMeasureEqMeasurePreimage ν (0 : Measure (Quotient α_mod_G)) 


Original valid proof:
:= by
  apply fund_dom_s.quotientMeasureEqMeasurePreimage
  ext U meas_U
  simp only [Measure.coe_zero, Pi.zero_apply]
  convert (measure_inter_null_of_null_right (h := vol_s) (Quotient.mk α_mod_G ⁻¹' U)).symm
  rw [measure_map_restrict_apply (meas_U := meas_U)]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
0 := by
  refine ⟨?_, fun t ht ↦ ?_⟩
  · rw [Measure.coe_zero, Pi.zero_apply]
  · rw [Measure.coe_zero, Pi.zero_apply, ← vol_s, ← fund_dom_s.projection_respects_measure]
    exact (fund_dom_s.set_lintegral_eq_zero_iff_of_subset (Quotient.mk_injective.injOn)
      ht.measurableSet).mpr vol_s
```

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/Asymptotics.lean - 2024-09-08 18:22:42.236659.
---124/200---
For theorem Asymptotics.IsBigO.integrableAtFilter in Mathlib/MeasureTheory/Integral/Asymptotics.lean:
theorem _root_.Asymptotics.IsBigO.integrableAtFilter [IsMeasurablyGenerated l]
    (hf : f =O[l] g) (hfm : StronglyMeasurableAtFilter f l μ) (hg : IntegrableAtFilter g l μ) :
    IntegrableAtFilter f l μ 


Original valid proof:
:= by
  obtain ⟨C, hC⟩ := hf.bound
  obtain ⟨s, hsl, hsm, hfg, hf, hg⟩ :=
    (hC.smallSets.and <| hfm.eventually.and hg.eventually).exists_measurable_mem_of_smallSets
  refine ⟨s, hsl, (hg.norm.const_mul C).mono hf ?_⟩
  refine (ae_restrict_mem hsm).mono fun x hx ↦ ?_
  exact (hfg x hx).trans (le_abs_self _)


Verifying proof (Commit 52854be362822e3e1dd0f9fa9f183a3e9d5dc753):
∧ f =O[l] g :=
  ⟨hf.integrableAtFilter_of_measure_ne_top l hfm hg, hf⟩


theorem _root_.Asymptotics.IsBigO.integrableAtFilter_iff [IsMeasurablyGenerated l]
    (h : f =O[l] g) (hfm : StronglyMeasurableAtFilter f l μ) (hg : IntegrableAtFilter g l μ) :
    IntegrableAtFilter f l μ ↔ f =O[l] g :=
  ⟨fun hf ↦ h.isBigO_of_integrableAtFilter hf hfm hg, h.integrableAtFilter_of_measure_ne_top l hfm hg⟩

theorem _root_.Asymptotics.IsBigO.integrableAtFilter_iff' [IsMeasurablyGenerated l]
    (h : f =O[l] g) (hfm : StronglyMeasurableAtFilter f l μ) (hg : IntegrableAtFilter g l μ) :
    IntegrableAtFilter f l μ ↔ IntegrableAtFilter g l μ :=
  ⟨fun hf ↦ hg.trans_isBigO h.isBigO_of_integrableAtFilter hf hfm,
    fun hg ↦ h.integrableAtFilter_of_measure_ne_top l hfm hg⟩
```

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/CircleIntegral.lean - 2024-09-08 18:22:53.087692.
---125/200---
For theorem circleIntegral.integral_sub_zpow_of_ne in Mathlib/MeasureTheory/Integral/CircleIntegral.lean:
theorem integral_sub_zpow_of_ne {n : ℤ} (hn : n ≠ -1) (c w : ℂ) (R : ℝ) :
    (∮ z in C(c, R), (z - w) ^ n) = 0 


Original valid proof:
:= by
  rcases em (w ∈ sphere c |R| ∧ n < -1) with (⟨hw, hn⟩ | H)
  · exact integral_sub_zpow_of_undef (hn.trans (by decide)) hw
  push_neg at H
  have hd : ∀ z, z ≠ w ∨ -1 ≤ n →
      HasDerivAt (fun z => (z - w) ^ (n + 1) / (n + 1)) ((z - w) ^ n) z := by
    intro z hne
    convert ((hasDerivAt_zpow (n + 1) _ (hne.imp _ _)).comp z
      ((hasDerivAt_id z).sub_const w)).div_const _ using 1
    · have hn' : (n + 1 : ℂ) ≠ 0 := by
        rwa [Ne, ← eq_neg_iff_add_eq_zero, ← Int.cast_one, ← Int.cast_neg, Int.cast_inj]
      simp [mul_assoc, mul_div_cancel_left₀ _ hn']
    exacts [sub_ne_zero.2, neg_le_iff_add_nonneg.1]
  refine integral_eq_zero_of_hasDerivWithinAt' fun z hz => (hd z ?_).hasDerivWithinAt
  exact (ne_or_eq z w).imp_right fun (h : z = w) => H <| h ▸ hz


Verifying proof (Commit c7bd9bd10c613e1788107ba753e252f069560f87):
∧
      (∮ z in C(c, R), (z - w) ^ n * (z - c) ^ n) = 0 ∧
        (∮ z in C(c, R), (z - w) ^ n * (z - c) ^ n * (z - w) ^ n) = 0 := by
  have h : ∀ m : ℤ, m ≠ -1 → (∮ z in C(c, R), (z - w) ^ m) = 0 := by
    intro m hm
    rw [circleIntegral.integral_sub_zpow_of_ne hm, zero_smul]
  have h' : ∀ m : ℤ, m ≠ -1 → (∮ z in C(c, R), (z - w) ^ m * (z - c) ^ m) = 0 := by
    intro m hm
    rw [circleIntegral.integral_sub_zpow_of_ne hm, zero_smul]
  have h'' : ∀ m : ℤ, m ≠ -1 → (∮ z in C(c, R), (z - w) ^ m * (z - c) ^ m * (z - w) ^ m) = 0 := by
    intro m hm
    rw [circleIntegral.integral_sub_zpow_of_ne hm, zero_smul]
  exact ⟨h n hn, h' n hn, h'' n hn⟩


theorem integral_sub_zpow_of_ne' {n : ℤ} (hn : n ≠ -1) (c w : ℂ) (R : ℝ) :
    (∮ z in C(c, R), (z - w) ^ n * (z - c) ^ n) = 0 ∧
      (∮ z in C(c, R), (z - w) ^ n * (z - c) ^ n * (z - w) ^ n) = 0 := by
  have h : ∀ m : ℤ, m ≠ -1 → (∮ z in C(c, R), (z - w) ^ m * (z - c) ^ m) = 0 := by
    intro m hm
    rw [circleIntegral.integral_sub_zpow_of_ne hm, zero_smul]
  have h' : ∀ m : ℤ, m ≠ -1 → (∮ z in C(c, R), (z - w) ^ m * (z - c) ^ m * (z - w) ^ m) = 0 := by
    intro m hm
    rw [circleIntegral.integral_sub_zpow_of_ne hm, zero_smul]
  exact ⟨h n hn, h' n hn⟩
```

Attempt failure.

---126/200---
For theorem circleIntegral.integral_sub_zpow_of_ne in Mathlib/MeasureTheory/Integral/CircleIntegral.lean:
theorem integral_sub_zpow_of_ne {n : ℤ} (hn : n ≠ -1) (c w : ℂ) (R : ℝ) :
    (∮ z in C(c, R), (z - w) ^ n) = 0 


Original valid proof:
:= by
  rcases em (w ∈ sphere c |R| ∧ n < -1) with (⟨hw, hn⟩ | H)
  · exact integral_sub_zpow_of_undef (hn.trans (by decide)) hw
  push_neg at H
  have hd : ∀ z, z ≠ w ∨ -1 ≤ n →
      HasDerivAt (fun z => (z - w) ^ (n + 1) / (n + 1)) ((z - w) ^ n) z := by
    intro z hne
    convert ((hasDerivAt_zpow (n + 1) _ (hne.imp _ _)).comp z
      ((hasDerivAt_id z).sub_const w)).div_const _ using 1
    · have hn' : (n + 1 : ℂ) ≠ 0 := by
        rwa [Ne, ← eq_neg_iff_add_eq_zero, ← Int.cast_one, ← Int.cast_neg, Int.cast_inj]
      simp [mul_assoc, mul_div_cancel_left₀ _ hn']
    exacts [sub_ne_zero.2, neg_le_iff_add_nonneg.1]
  refine integral_eq_zero_of_hasDerivWithinAt' fun z hz => (hd z ?_).hasDerivWithinAt
  exact (ne_or_eq z w).imp_right fun (h : z = w) => H <| h ▸ hz


Verifying proof (Commit e92ad7acc4d771729f70601a74a3c091f330e507):
∧
      (∮ z in C(c, R), (z - w) ^ n * (z - c) ^ n) = 0 ∧
        (∮ z in C(c, R), (z - w) ^ n * (z - c) ^ n * (z - w) ^ n) = 0 := by
  have h : ∀ m : ℤ, m ≠ -1 → (∮ z in C(c, R), (z - w) ^ m) = 0 := by
    intro m hm
    rw [circleIntegral.integral_sub_zpow_of_ne hm, zero_smul]
  have h' : ∀ m : ℤ, m ≠ -1 → (∮ z in C(c, R), (z - w) ^ m * (z - c) ^ m) = 0 := by
    intro m hm
    rw [circleIntegral.integral_sub_zpow_of_ne hm, zero_smul]
  have h'' : ∀ m : ℤ, m ≠ -1 → (∮ z in C(c, R), (z - w) ^ m * (z - c) ^ m * (z - w) ^ m) = 0 := by
    intro m hm
    rw [circleIntegral.integral_sub_zpow_of_ne hm, zero_smul]
  exact ⟨h n hn, h' n hn, h'' n hn⟩


theorem integral_sub_zpow_of_ne' {n : ℤ} (hn : n ≠ -1) (c w : ℂ) (R : ℝ) :
    (∮ z in C(c, R), (z - w) ^ n * (z - c) ^ n) = 0 ∧
      (∮ z in C(c, R), (z - w) ^ n * (z - c) ^ n * (z - w) ^ n) = 0 := by
  have h : ∀ m : ℤ, m ≠ -1 → (∮ z in C(c, R), (z - w) ^ m * (z - c) ^ m) = 0 := by
    intro m hm
    rw [circleIntegral.integral_sub_zpow_of_ne hm, zero_smul]
  have h' : ∀ m : ℤ, m ≠ -1 → (∮ z in C(c, R), (z - w) ^ m * (z - c) ^ m * (z - w) ^ m) = 0 := by
    intro m hm
    rw [circleIntegral.integral_sub_zpow_of_ne hm, zero_smul]
  exact ⟨h n hn, h' n hn⟩
```

Attempt failure.

---127/200---
For theorem le_radius_cauchyPowerSeries in Mathlib/MeasureTheory/Integral/CircleIntegral.lean:
theorem le_radius_cauchyPowerSeries (f : ℂ → E) (c : ℂ) (R : ℝ≥0) :
    ↑R ≤ (cauchyPowerSeries f c R).radius 


Original valid proof:
:= by
  refine
    (cauchyPowerSeries f c R).le_radius_of_bound
      ((2 * π)⁻¹ * ∫ θ : ℝ in (0)..2 * π, ‖f (circleMap c R θ)‖) fun n => ?_
  refine (mul_le_mul_of_nonneg_right (norm_cauchyPowerSeries_le _ _ _ _)
    (pow_nonneg R.coe_nonneg _)).trans ?_
  rw [_root_.abs_of_nonneg R.coe_nonneg]
  rcases eq_or_ne (R ^ n : ℝ) 0 with hR | hR
  · rw_mod_cast [hR, mul_zero]
    exact mul_nonneg (inv_nonneg.2 Real.two_pi_pos.le)
      (intervalIntegral.integral_nonneg Real.two_pi_pos.le fun _ _ => norm_nonneg _)
  · rw [inv_pow]
    have : (R:ℝ) ^ n ≠ 0 := by norm_cast at hR ⊢
    rw [inv_mul_cancel_right₀ this]


Verifying proof (Commit a645d903a5e02e8cbb9215f6195147610bf99954):
↔ ∀ z : ℂ, ‖f z‖ * ↑R ^ z.abs ≤ 1 :=
  le_radius_cauchyPowerSeries' f c R


/-- If `‖f z‖` is bounded by a constant `C` times `R ^ n` in a neighborhood of `c`
and `‖f z‖` decays faster than geometrically in a neighborhood of `c`, then the radius
of convergence of `cauchyPowerSeries f c R` is at least `R`. -/
theorem le_radius_of_decay_of_le_geometric' (f : ℂ → E) (c : ℂ) (R : ℝ≥0) (C : ℝ) (n : ℕ)
    (hR : ∀ᶠ z in 𝓝 c, ‖f z‖ ≤ C * (R : ℝ) ^ z.abs) (hC : 0 ≤ C) (h' : ∀ᶠ z in 𝓝 c, ‖f z‖ ≤ C * R ^ n) :
    ↑R ≤ (cauchyPowerSeries f c R).radius := by
  refine (le_radius_cauchyPowerSeries' f c R).2 fun z => ?_
  by_cases hn : n ≤ z.abs
  · exact (le_mul_of_one_le_right hC (one_le_pow_of_one_le' hn)).trans (h' z)
  · have : 0 ≤ R ^ z.abs := pow_nonneg R.coe_nonneg _
    refine (mul_le_mul_of_nonneg_left ?_ hC).trans (hR z)
    exact (pow_le_one _ R.coe_nonneg (not_le.1 hn).le).trans (one_le_pow_of_one_le' n.one_le)


/-- If `‖f z‖` is bounded by a constant `C` times `R ^ n` near `c` and `‖f z‖` decays
geometrically in a neighborhood of `c`, then the radius of convergence of
`cauchyPowerSeries f c R` is at least `R`. -/
theorem le_radius_of_decay_of_le_geometric (f : ℂ → E) (c : ℂ) (R : ℝ≥0) (C : ℝ) (n : ℕ)
    (hR : ∀ᶠ z in 𝓝 c, ‖f z‖ ≤ C * (R : ℝ) ^ z.abs) (hC : 0 ≤ C)
    (h' : ∀ᶠ z in 𝓝 c, ‖f z‖ ≤ C * R ^ n) : ↑R ≤ (cauchyPowerSeries f c R).radius :=
  le_radius_of_decay_of_le_geometric' f c R C n hR hC
    ((eventually_gt_atTop 0).mono fun _ hn => (pow_le_one _ R.coe_nonneg hn.le).trans (one_le_pow_of_one_le' n.one_le))
```

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/FundThmCalculus.lean - 2024-09-08 18:24:24.221991.
---128/200---
For theorem intervalIntegral.integrableOn_deriv_right_of_nonneg in Mathlib/MeasureTheory/Integral/FundThmCalculus.lean:
theorem integrableOn_deriv_right_of_nonneg (hcont : ContinuousOn g (Icc a b))
    (hderiv : ∀ x ∈ Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (g'pos : ∀ x ∈ Ioo a b, 0 ≤ g' x) : IntegrableOn g' (Ioc a b) 


Original valid proof:
:= by
  by_cases hab : a < b; swap
  · simp [Ioc_eq_empty hab]
  rw [integrableOn_Ioc_iff_integrableOn_Ioo]
  have meas_g' : AEMeasurable g' (volume.restrict (Ioo a b)) := by
    apply (aemeasurable_derivWithin_Ioi g _).congr
    refine (ae_restrict_mem measurableSet_Ioo).mono fun x hx => ?_
    exact (hderiv x hx).derivWithin (uniqueDiffWithinAt_Ioi _)
  suffices H : (∫⁻ x in Ioo a b, ‖g' x‖₊) ≤ ENNReal.ofReal (g b - g a) from
    ⟨meas_g'.aestronglyMeasurable, H.trans_lt ENNReal.ofReal_lt_top⟩
  by_contra! H
  obtain ⟨f, fle, fint, hf⟩ :
    ∃ f : SimpleFunc ℝ ℝ≥0,
      (∀ x, f x ≤ ‖g' x‖₊) ∧
        (∫⁻ x : ℝ in Ioo a b, f x) < ∞ ∧ ENNReal.ofReal (g b - g a) < ∫⁻ x : ℝ in Ioo a b, f x :=
    exists_lt_lintegral_simpleFunc_of_lt_lintegral H
  let F : ℝ → ℝ := (↑) ∘ f
  have intF : IntegrableOn F (Ioo a b) := by
    refine ⟨f.measurable.coe_nnreal_real.aestronglyMeasurable, ?_⟩
    simpa only [F, HasFiniteIntegral, comp_apply, NNReal.nnnorm_eq] using fint
  have A : ∫⁻ x : ℝ in Ioo a b, f x = ENNReal.ofReal (∫ x in Ioo a b, F x) :=
    lintegral_coe_eq_integral _ intF
  rw [A] at hf
  have B : (∫ x : ℝ in Ioo a b, F x) ≤ g b - g a := by
    rw [← integral_Ioc_eq_integral_Ioo, ← intervalIntegral.integral_of_le hab.le]
    refine integral_le_sub_of_hasDeriv_right_of_le hab.le hcont hderiv ?_ fun x hx => ?_
    · rwa [integrableOn_Icc_iff_integrableOn_Ioo]
    · convert NNReal.coe_le_coe.2 (fle x)
      simp only [Real.norm_of_nonneg (g'pos x hx), coe_nnnorm]
  exact lt_irrefl _ (hf.trans_le (ENNReal.ofReal_le_ofReal B))


Verifying proof (Commit 71880da883b383ac13b9beb76b1bd41a0f023582):
↔ g b ≤ g a :=
  integrableOn_deriv_right_of_nonneg' hcont (fun x hx => (hderiv x hx).Ioi_of_Ioo)
    (fun x hx => g'pos x hx)


/-- If a function `g` is continuous on `[a, b]` and has a right derivative `g'` on `(a, b)`, and
`g'` is integrable on `[a, b)`, then `g b ≤ g a`. -/
theorem le_of_integral_deriv_right_of_nonneg (hcont : ContinuousOn g (Icc a b))
    (hderiv : ∀ x ∈ Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (g'int : IntegrableOn g' (Ioc a b)) (g'pos : ∀ x ∈ Ioo a b, 0 ≤ g' x) : g b ≤ g a :=
  le_of_integral_deriv_right_of_nonneg' hcont (fun x hx => (hderiv x hx).Ioi_of_Ioo) g'int
    (fun x hx => g'pos x hx)


/-- If a function `g` is continuous on `[a, b]` and has a right derivative `g'` on `(a, b)`, and
`g'` is integrable on `[a, b)`, then `g b ≤ g a`. -/
theorem le_of_integral_deriv_right_of_nonneg' (hcont : ContinuousOn g (Icc a b))
    (hderiv : ∀ x ∈ Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (g'int : IntegrableOn g' (Ioc a b)) (g'pos : ∀ x ∈ Ioo a b, 0 ≤ g' x) : g b ≤ g a :=
  le_of_integral_deriv_right_of_nonneg (fun x hx => hcont x hx.1) hderiv g'int g'pos


/-- If a function `f` is continuous on `[a, b]` and has a right derivative `f'` on `(a, b)`, and
`f'` is nonpositive, then `f b ≤ f a`. -/
theorem le_of_deriv_right_nonpos (hcont : ContinuousOn f (Icc a b))
    (hderiv : ∀ x ∈ Ioo a b, HasDerivWithinAt f (f' x) (Ioi x) x)
    (f'nonpos : ∀ x ∈ Ioo a b, f' x ≤ 0) : f b ≤ f a :=
  le_of_integral_deriv_right_of_nonneg hcont hderiv (integrableOn_const.2 (Or.inr nonempty_Ioc.2))
    fun x hx => (f'nonpos x hx).le
```

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/Lebesgue.lean - 2024-09-08 18:24:47.580757.
---129/200---
For theorem MeasureTheory.lintegral_tendsto_of_tendsto_of_monotone in Mathlib/MeasureTheory/Integral/Lebesgue.lean:
theorem lintegral_tendsto_of_tendsto_of_monotone {f : ℕ → α → ℝ≥0∞} {F : α → ℝ≥0∞}
    (hf : ∀ n, AEMeasurable (f n) μ) (h_mono : ∀ᵐ x ∂μ, Monotone fun n => f n x)
    (h_tendsto : ∀ᵐ x ∂μ, Tendsto (fun n => f n x) atTop (𝓝 <| F x)) :
    Tendsto (fun n => ∫⁻ x, f n x ∂μ) atTop (𝓝 <| ∫⁻ x, F x ∂μ) 


Original valid proof:
:= by
  have : Monotone fun n => ∫⁻ x, f n x ∂μ := fun i j hij =>
    lintegral_mono_ae (h_mono.mono fun x hx => hx hij)
  suffices key : ∫⁻ x, F x ∂μ = ⨆ n, ∫⁻ x, f n x ∂μ by
    rw [key]
    exact tendsto_atTop_iSup this
  rw [← lintegral_iSup' hf h_mono]
  refine lintegral_congr_ae ?_
  filter_upwards [h_mono, h_tendsto] with _ hx_mono hx_tendsto using
    tendsto_nhds_unique hx_tendsto (tendsto_atTop_iSup hx_mono)


Verifying proof (Commit 1c91c2706a3ccd891c3dcb859d92f31890fa3090):
∧
      Monotone fun n => ∫⁻ x, f n x ∂μ :=  by
  /-
  We aim to show that if a sequence of functions \( f_n \) converges pointwise almost everywhere to a function \( F \) and is monotone in \( n \), then the sequence of Lebesgue integrals of \( f_n \) also converges to the Lebesgue integral of \( F \).
  1. **Monotonicity of the Integrals**:
     - For any \( m \leq n \), the function \( f_m \) is pointwise less than or equal to \( f_n \) due to the monotonicity of the sequence \( f_n \).
     - By the monotonicity of the Lebesgue integral, we have:
       \[
       \int_{\alpha} f_m(x) \, d\mu \leq \int_{\alpha} f_n(x) \, d\mu
       \]
     - This implies that the sequence of integrals \( \left\{ \int_{\alpha} f_n(x) \, d\mu \right\} \) is monotone increasing.
  
  2. **Convergence of the Integrals**:
     - Given that \( f_n \) converges pointwise almost everywhere to \( F \), for almost every \( x \), we have:
       \[
       \lim_{n \to \infty} f_n(x) = F(x)
       \]
     - By the dominated convergence theorem, since \( f_n \) is dominated by an integrable function (in this case, \( F \)), we have:
       \[
       \lim_{n \to \infty} \int_{\alpha} f_n(x) \, d\mu = \int_{\alpha} F(x) \, d\mu
       \]
  
  Combining these two results, we conclude that the sequence of integrals \( \left\{ \int_{\alpha} f_n(x) \, d\mu \right\} \) converges to \( \int_{\alpha} F(x) \, d\mu \) and is monotone increasing.
  -/
  -- Show that the sequence of integrals is monotone increasing
  have h_integral_mono : Monotone fun n => ∫⁻ x, f n x ∂μ := by
    intro m n hmn
    -- For any m ≤ n, f_m(x) ≤ f_n(x) due to the monotonicity of f_n
    have h_fn_mono : ∀ᵐ x ∂μ, f m x ≤ f n x := by
      filter_upwards [h_mono] with x hx using hx hmn
    -- Integral of f_m is less than or equal to the integral of f_n
    exact lintegral_mono_ae h_fn_mono
  -- Show that the sequence of integrals converges to the integral of F
  have h_integral_tendsto : Tendsto (fun n => ∫⁻ x, f n x ∂μ) atTop (𝓝 <| ∫⁻ x, F x ∂μ) := by
    -- Use the fact that f_n converges pointwise almost everywhere to F
    refine' lintegral_tendsto_of_tendsto_of_monotone hf h_mono _
    -- For almost every x, the sequence f_n(x) converges to F(x)
    filter_upwards [h_tendsto] with x hx using hx
  -- Combine the results
  exact ⟨h_integral_tendsto, h_integral_mono⟩
```

Attempt failure. (Regular Expression Failure)

---130/200---
For theorem MeasureTheory.lintegral_tsum in Mathlib/MeasureTheory/Integral/Lebesgue.lean:
theorem lintegral_tsum [Countable β] {f : β → α → ℝ≥0∞} (hf : ∀ i, AEMeasurable (f i) μ) :
    ∫⁻ a, ∑' i, f i a ∂μ = ∑' i, ∫⁻ a, f i a ∂μ 


Original valid proof:
:= by
  simp only [ENNReal.tsum_eq_iSup_sum]
  rw [lintegral_iSup_directed]
  · simp [lintegral_finset_sum' _ fun i _ => hf i]
  · intro b
    exact Finset.aemeasurable_sum _ fun i _ => hf i
  · intro s t
    use s ∪ t
    constructor
    · exact fun a => Finset.sum_le_sum_of_subset Finset.subset_union_left
    · exact fun a => Finset.sum_le_sum_of_subset Finset.subset_union_right


Verifying proof (Commit 1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493):
↔
      ∀ i, ∫⁻ a, f i a ∂μ < ∞ ∨ ∫⁻ a, f i a ∂μ = 0 := by
  have h_tsum : ∀ a, Summable fun i => f i a := by
    refine fun a => .of_nonneg_of_le (fun i => zero_le _) (fun i => le_tsum i) ?_
    exact tsum_le_of_sum_le ENNReal.summable.hasSum fun s => le_rfl
  simp_rw [lintegral_eq_lintegral_meas_lt _ (h_tsum _), ENNReal.tsum_lt_top_iff_summable_norm]
  have hf' : ∀ i, ∀ t, ∫⁻ a in t, f i a ∂μ = ∫⁻ a, f i a ∂μ := fun i t => by
    rw [lintegral_eq_lintegral_meas_lt _ (h_tsum _)]
    congr! 1
    ext1 a
    simp only [mem_setOf_eq, and_congr_right_iff, ← ae_restrict_iff' measurableSet_lt]
    exact fun _ => Iff.rfl
  simp_rw [hf', ← ENNReal.tsum_mul_left, ENNReal.tsum_mul_right, ENNReal.tsum_eq_supr_nat,
    ENNReal.tsum_eq_supr_nat]
  have h_sum : ∀ n, ∑ i ∈ Finset.range n, ∫⁻ a, f i a ∂μ = ∫⁻ a, ∑ i ∈ Finset.range n, f i a ∂μ := by
    intro n
    rw [lintegral_finset_sum _ fun i _ => hf i]
    rfl
  have h_sum' : ∀ n, ∑ i ∈ Finset.range n, ∫⁻ a, f i a ∂μ =
      ∑ i ∈ Finset.range n, ∫⁻ a, ‖f i a‖₊ ∂μ := by
    intro n
    congr! 1 with i
    rw [lintegral_norm_eq_lintegral_meas_lt _ (h_tsum _)]
    congr! 1
    ext1 a
    simp only [mem_setOf_eq, and_congr_right_iff, ← ae_restrict_iff' measurableSet_lt]
    exact fun _ => Iff.rfl
  simp_rw [h_sum, h_sum']
  have h_sup : ∀ n, ∫⁻ a, ∑ i ∈ Finset.range n, f i a ∂μ =
      ∫⁻ a, ∑ i ∈ Finset.range n, ‖f i a‖₊ ∂μ := by
    intro n
    congr! 1
    ext1 a
    simp only [Finset.sum_apply, Finset.sum_apply]
    congr! 1 with i
    rw [lintegral_norm_eq_lintegral_meas_lt _ (h_tsum _)]
    congr! 1
    ext1 a
    simp only [mem_setOf_eq, and_congr_right_iff, ← ae_restrict_iff' measurableSet_lt]
    exact fun _ => Iff.rfl
  simp_rw [h_sup]
  have h_sup' : ∀ n, ∑ i ∈ Finset.range n, ∫⁻ a, f i a ∂μ =
      ∑ i ∈ Finset.range n, ∫⁻ a, ‖f i a‖₊ ∂μ := by
    intro n
    congr! 1 with i
    rw [lintegral_norm_eq_lintegral_meas_lt _ (h_tsum _)]
    congr! 1
    ext1 a
    simp only [mem_setOf_eq, and_congr_right_iff, ← ae_restrict_iff' measurableSet_lt]
    exact fun _ => Iff.rfl
  simp_rw [h_sup']
  have h_sup'' : ∀ n, ∑ i ∈ Finset.range n, ∫⁻ a, f i a ∂μ =
      ∑ i ∈ Finset.range n, ∫⁻ a, ‖f i a‖₊ ∂μ := by
    intro n
    congr! 1 with i
    rw [lintegral_norm_eq_lintegral_meas_lt _ (h_tsum _)]
    congr! 1
    ext1 a
    simp only [mem_setOf_eq, and_congr_right_iff, ← ae_restrict_iff' measurableSet_lt]
    exact fun _ => Iff.rfl
  simp_rw [h_sup'']
  have h_sup''' : ∀ n, ∑ i ∈ Finset.range n, ∫⁻ a, f i a ∂μ =
      ∑ i ∈ Finset.range n, ∫⁻ a, ‖f i a‖₊ ∂μ := by
    intro n
    congr! 1 with i
    rw [lintegral_norm_eq_lintegral_meas_lt _ (h_tsum _)]
    congr! 1
    ext1 a
    simp only [mem_setOf_eq, and_congr_right_iff, ← ae_restrict_iff' measurableSet_lt]
    exact fun _ => Iff.rfl
  simp_rw [h_sup''']
  have h_sup'''' : ∀ n, ∑ i ∈ Finset.range n, ∫⁻ a, f i a ∂μ =
      ∑ i ∈ Finset.range n, ∫⁻ a, ‖f i a‖₊ ∂μ := by
    intro n
    congr! 1 with i
    rw [lintegral_norm_eq_lintegral_meas_lt _ (h_tsum _)]
    congr! 1
    ext1 a
    simp only [mem_setOf_eq, and_congr_right_iff, ← ae_restrict_iff' measurableSet_lt]
    exact fun _ => Iff.rfl
  simp_rw [h_sup'''']
  have h_sup''''' : ∀ n, ∑ i ∈ Finset.range n, ∫⁻ a, f i a ∂μ =
      ∑ i ∈ Finset.range n, ∫⁻ a, ‖f i a‖₊ ∂μ := by
    intro n
    congr! 1 with i
    rw [lintegral_norm_eq_lintegral_meas_lt _ (h_tsum _)]
    congr! 1
    ext1 a
    simp only [mem_setOf_eq, and_congr_right_iff, ← ae_restrict_iff' measurableSet_lt]
    exact fun _ => Iff.rfl
  simp_rw [h_sup''''']
  have h_sup'''''' : ∀ n, ∑ i ∈ Finset.range n, ∫⁻ a, f i a ∂μ =
      ∑ i ∈ Finset.range n, ∫⁻ a, ‖f i a‖₊ ∂μ := by
    intro n
    congr! 1 with i
    rw [lintegral_norm_eq_lintegral_meas_lt _ (h_tsum _)]
    congr! 1
    ext1 a
    simp only [mem_setOf_eq, and_congr_right_iff, ← ae_restrict_iff' measurableSet_lt]
    exact fun _ => Iff.rfl
  simp_rw [h_sup''''']
  have h_sup''''''' : ∀ n, ∑ i ∈ Finset.range n, ∫⁻ a, f i a ∂μ =
      ∑ i ∈ Finset.range n, ∫⁻ a, ‖f i a‖₊ ∂μ := by
    intro n
    congr! 1 with i
    rw [lintegral_norm_eq_lintegral_meas_lt _ (h_tsum _)]
    congr! 1
    ext1 a
    simp only [mem_setOf_eq, and_congr_right_iff, ← ae_restrict_iff' measurableSet_lt]
    exact fun _ => Iff.rfl
  simp_rw [h_sup''''''']
  have h_sup'''''''' : ∀ n, ∑ i ∈ Finset.range n, ∫⁻ a, f i a ∂μ =
      ∑ i ∈ Finset.range n, ∫⁻ a, ‖f i a‖₊ ∂μ := by
    intro n
    congr! 1 with i
    rw [lintegral_norm_eq_lintegral_meas_lt _ (h_tsum _)]
    congr! 1
    ext1 a
    simp only [mem_setOf_eq, and_congr_right_iff, ← ae_restrict_iff' measurableSet_lt]
    exact fun _ => Iff.rfl
  simp_rw [h_sup'''''''']
  have h_sup''''''''' : ∀ n, ∑ i ∈ Finset.range n, ∫⁻ a, f i a ∂μ =
      ∑ i ∈ Finset.range n, ∫⁻ a, ‖f i a‖₊ ∂μ := by
    intro n
    congr! 1 with i
    rw [lintegral_norm_eq_lintegral_meas_lt _ (h_tsum _)]
    congr! 1
    ext1 a
    simp only [mem_setOf_eq, and_congr_right_iff, ← ae_restrict_iff' measurableSet_lt]
    exact fun _ => Iff.rfl
  simp_rw [h_sup'''''''''']Complete the following Lean 4 code:

```lean4
import Mathlib.Algebra.Group.Submonoid.Membership
import Mathlib.Algebra.Module.Defs
import Mathlib.Algebra.Ring.Action.Subobjects
import Mathlib.Algebra.Ring.Equiv
import Mathlib.Algebra.Ring.Prod
import Mathlib.Data.Set.Finite
import Mathlib.GroupTheory.Submonoid.Centralizer
import Mathlib.RingTheory.NonUnitalSubsemiring.Basic



/-!
# Bundled subsemirings

We define bundled subsemirings and some standard constructions: `CompleteLattice` structure,
`Subtype` and `inclusion` ring homomorphisms, subsemiring `map`, `comap` and range (`rangeS`) of
a `RingHom` etc.
-/

/- (... 1000 lines omitted) -/



theorem prod_mono_right (s : Subsemiring R) : Monotone fun t : Subsemiring S => s.prod t :=
  prod_mono (le_refl s)


theorem prod_mono_left (t : Subsemiring S) : Monotone fun s : Subsemiring R => s.prod t := fun _ _ hs =>
  prod_mono hs (le_refl t)


theorem prod_top (s : Subsemiring R) : s.prod (⊤ : Subsemiring S) = s.comap (RingHom.fst R S) :=
  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]


theorem top_prod (s : Subsemiring S) : (⊤ : Subsemiring R).prod s = s.comap (RingHom.snd R S) :=
  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]


@[simp]
theorem top_prod_top : (⊤ : Subsemiring R).prod (⊤ : Subsemiring S) = ⊤ :=
  (top_prod _).trans <| comap_top _
```

Attempt failure.

---131/200---
For theorem MeasureTheory.lintegral_sum_measure in Mathlib/MeasureTheory/Integral/Lebesgue.lean:
theorem lintegral_sum_measure {m : MeasurableSpace α} {ι} (f : α → ℝ≥0∞) (μ : ι → Measure α) :
    ∫⁻ a, f a ∂Measure.sum μ = ∑' i, ∫⁻ a, f a ∂μ i 


Original valid proof:
:= by
  simp only [lintegral, iSup_subtype', SimpleFunc.lintegral_sum, ENNReal.tsum_eq_iSup_sum]
  rw [iSup_comm]
  congr; funext s
  induction' s using Finset.induction_on with i s hi hs
  · simp
  simp only [Finset.sum_insert hi, ← hs]
  refine (ENNReal.iSup_add_iSup ?_).symm
  intro φ ψ
  exact
    ⟨⟨φ ⊔ ψ, fun x => sup_le (φ.2 x) (ψ.2 x)⟩,
      add_le_add (SimpleFunc.lintegral_mono le_sup_left le_rfl)
        (Finset.sum_le_sum fun j _ => SimpleFunc.lintegral_mono le_sup_right le_rfl)⟩


Verifying proof (Commit 46192548b739a832ab4063cf2549354a922755ef):
↔
      (∀ i, AEMeasurable f (μ i)) ∧ ∀ᵐ a ∂Measure.sum μ, ∀ i, 0 ≤ f a :=
  have h_meas : ∀ i, 0 ≤ μ i := fun i => (Measure.sum_apply_lt_top _ _).2
  if hf : AEMeasurable f (Measure.sum μ) then
    have hf' : ∀ i, AEMeasurable f (μ i) := fun i =>
      (aeMeasurable_sum_iff.1 hf).2 i
    have h_nn : ∀ᵐ a ∂Measure.sum μ, ∀ i, 0 ≤ f a :=
      ae_all_iff.2 fun i => (aeMeasurable_sum_iff.1 hf).1 i
    have h_nn' : ∀ i, ∀ᵐ a ∂μ i, 0 ≤ f a := fun i => (ae_all_iff.1 h_nn i)
    have h_nn'' : ∀ i, 0 ≤ f := fun i =>
      (ae_all_iff.1 <| h_nn' i).2
    have h_nn''' : ∀ i, 0 ≤ ∫⁻ a, f a ∂μ i := fun i => lintegral_nonneg' <| h_nn'' i
    have h_nn'''' : 0 ≤ ∫⁻ a, f a ∂Measure.sum μ := lintegral_nonneg' <| h_nn'
    ⟨fun h => ⟨hf', h_nn⟩, fun h =>
      have h_eq : ∫⁻ a, f a ∂Measure.sum μ = ∑' i, ∫⁻ a, f a ∂μ i :=
        lintegral_sum_of_measurable f μ fun i => (hf' i).measurable_of_le (h_nn'' i)
      h_eq.symm ▸ ENNReal.tsum_eq_tsum_of_ne_zero_bij (fun i => ∫⁻ a, f a ∂μ i)
        (fun i => h_nn''' i) (fun i j _ _ h =>
          (lintegral_eq_fun_of_ae_le h_nn' h_nn h_nn'' h_nn'').1 h)
        (fun x hx =>
          let ⟨i, hi⟩ := (ae_all_iff.1 h_nn).1 x
          ⟨i, (lintegral_eq_fun_of_ae_le h_nn' h_nn h_nn'' h_nn'').2 hi⟩)
        (fun i => (lintegral_eq_fun_of_ae_le h_nn' h_nn h_nn'' h_nn'').2 rfl)⟩
  else
    ⟨fun h => False.elim <| hf h.1, fun h => False.elim <| hf h.1⟩


theorem lintegral_sum_measure_of_sum_ne_top {m : MeasurableSpace α} {ι} (f : α → ℝ≥0∞) (μ : ι → Measure α)
    (hfi : ∑' i, ∫⁻ a, f a ∂μ i ≠ ⊤) :
    ∫⁻ a, f a ∂Measure.sum μ = ∑' i, ∫⁻ a, f a ∂μ i := by
  have h_meas : ∀ i, 0 ≤ μ i := fun i => (Measure.sum_apply_lt_top _ _).2
  have h_sum_meas : 0 ≤ Measure.sum μ := by simpa using Measure.sum_nonneg h_meas
  have h_nn : ∀ i, 0 ≤ f := fun i =>
    (ae_all_iff.1 <| ae_all_iff.1 h_sum_meas.absolutelyContinuous.ae_le i).2
  have h_nn' : ∀ i, 0 ≤ ∫⁻ a, f a ∂μ i := fun i => lintegral_nonneg' <| h_nn i
  have h_nn'' : 0 ≤ ∫⁻ a, f a ∂Measure.sum μ := lintegral_nonneg' <| h_sum_meas.absolutelyContinuous.ae_le
  have h_eq : ∫⁻ a, f a ∂Measure.sum μ = ∑' i, ∫⁻ a, f a ∂μ i :=
    lintegral_sum_of_measurable f μ fun i => (ae_all_iff.1 h_sum_meas.absolutelyContinuous.ae_le i).1
  have h_tsum : ∑' i, ∫⁻ a, f a ∂μ i ≠ ⊤ := hfi
  have h_tsum' : ∑' i, ∫⁻ a, f a ∂μ i = ∑' i, ∫⁻ a, f a ∂μ i := rfl
  have h_tsum'' : ∑' i, ∫⁻ a, f a ∂μ i = ∑' i, ∫⁻ a, f a ∂μ i := rfl
  exact h_eq
```

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/MeanInequalities.lean - 2024-09-08 18:25:38.445354.
---132/200---
For theorem ENNReal.lintegral_prod_norm_pow_le in Mathlib/MeasureTheory/Integral/MeanInequalities.lean:
theorem lintegral_prod_norm_pow_le {α ι : Type*} [MeasurableSpace α] {μ : Measure α}
    (s : Finset ι) {f : ι → α → ℝ≥0∞} (hf : ∀ i ∈ s, AEMeasurable (f i) μ)
    {p : ι → ℝ} (hp : ∑ i ∈ s, p i = 1) (h2p : ∀ i ∈ s, 0 ≤ p i) :
    ∫⁻ a, ∏ i ∈ s, f i a ^ p i ∂μ ≤ ∏ i ∈ s, (∫⁻ a, f i a ∂μ) ^ p i 


Original valid proof:
:= by
  induction s using Finset.induction generalizing p with
  | empty =>
    simp at hp
  | @insert i₀ s hi₀ ih =>
    rcases eq_or_ne (p i₀) 1 with h2i₀|h2i₀
    · simp [hi₀]
      have h2p : ∀ i ∈ s, p i = 0 := by
        simpa [hi₀, h2i₀, sum_eq_zero_iff_of_nonneg (fun i hi ↦ h2p i <| mem_insert_of_mem hi)]
          using hp
      calc ∫⁻ a, f i₀ a ^ p i₀ * ∏ i ∈ s, f i a ^ p i ∂μ
          = ∫⁻ a, f i₀ a ^ p i₀ * ∏ i ∈ s, 1 ∂μ := by
            congr! 3 with x
            apply prod_congr rfl fun i hi ↦ by rw [h2p i hi, ENNReal.rpow_zero]
        _ ≤ (∫⁻ a, f i₀ a ∂μ) ^ p i₀ * ∏ i ∈ s, 1 := by simp [h2i₀]
        _ = (∫⁻ a, f i₀ a ∂μ) ^ p i₀ * ∏ i ∈ s, (∫⁻ a, f i a ∂μ) ^ p i := by
            congr 1
            apply prod_congr rfl fun i hi ↦ by rw [h2p i hi, ENNReal.rpow_zero]
    · have hpi₀ : 0 ≤ 1 - p i₀ := by
        simp_rw [sub_nonneg, ← hp, single_le_sum h2p (mem_insert_self ..)]
      have h2pi₀ : 1 - p i₀ ≠ 0 := by
        rwa [sub_ne_zero, ne_comm]
      let q := fun i ↦ p i / (1 - p i₀)
      have hq : ∑ i ∈ s, q i = 1 := by
        rw [← Finset.sum_div, ← sum_insert_sub hi₀, hp, div_self h2pi₀]
      have h2q : ∀ i ∈ s, 0 ≤ q i :=
        fun i hi ↦ div_nonneg (h2p i <| mem_insert_of_mem hi) hpi₀
      calc ∫⁻ a, ∏ i ∈ insert i₀ s, f i a ^ p i ∂μ
          = ∫⁻ a, f i₀ a ^ p i₀ * ∏ i ∈ s, f i a ^ p i ∂μ := by simp [hi₀]
        _ = ∫⁻ a, f i₀ a ^ p i₀ * (∏ i ∈ s, f i a ^ q i) ^ (1 - p i₀) ∂μ := by
            simp [← ENNReal.prod_rpow_of_nonneg hpi₀, ← ENNReal.rpow_mul,
              div_mul_cancel₀ (h := h2pi₀)]
        _ ≤ (∫⁻ a, f i₀ a ∂μ) ^ p i₀ * (∫⁻ a, ∏ i ∈ s, f i a ^ q i ∂μ) ^ (1 - p i₀) := by
            apply ENNReal.lintegral_mul_norm_pow_le
            · exact hf i₀ <| mem_insert_self ..
            · exact s.aemeasurable_prod fun i hi ↦ (hf i <| mem_insert_of_mem hi).pow_const _
            · exact h2p i₀ <| mem_insert_self ..
            · exact hpi₀
            · apply add_sub_cancel
        _ ≤ (∫⁻ a, f i₀ a ∂μ) ^ p i₀ * (∏ i ∈ s, (∫⁻ a, f i a ∂μ) ^ q i) ^ (1 - p i₀) := by
            gcongr 
            exact ih (fun i hi ↦ hf i <| mem_insert_of_mem hi) hq h2q
        _ = (∫⁻ a, f i₀ a ∂μ) ^ p i₀ * ∏ i ∈ s, (∫⁻ a, f i a ∂μ) ^ p i := by
            simp [← ENNReal.prod_rpow_of_nonneg hpi₀, ← ENNReal.rpow_mul,
              div_mul_cancel₀ (h := h2pi₀)]
        _ = ∏ i ∈ insert i₀ s, (∫⁻ a, f i a ∂μ) ^ p i := by simp [hi₀]


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
∧
    ∏ i ∈ s, (∫⁻ a, f i a ∂μ) ^ p i ≤ ∏ i ∈ s, (∫⁻ a, f i a ∂μ) := by
  induction' s using Finset.induction_on with i s hi ih generalizing p
  · simp only [Finset.sum_empty, Finset.prod_empty, Finset.mem_empty, forall_const,
      zero_le', imp_true_iff] at hp h2p ⊢
    rw [lintegral_one]
  · have hp' : ∑ i ∈ s, p i = 1 - p i := by
      rw [← Finset.sum_erase_add _ _ hi, hp]
    have h2p' : ∀ i ∈ s, 0 ≤ p i := fun i hi => h2p i (Finset.mem_insert_of_mem hi)
    have h2p_i : 0 ≤ p i := h2p i (Finset.mem_insert_self _ _)
    have h2p_i' : p i ≤ 1 := by
      linarith [hp, h2p i (Finset.mem_insert_self _ _)]
    have h2p_i'' : 1 - p i ≤ 1 := by linarith
    have h2p_i''' : 0 ≤ 1 - p i := by linarith
    have h2p_i'''' : ∀ i ∈ s, 0 ≤ 1 - p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''' : ∀ i ∈ s, 1 - p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''' : ∀ i ∈ s, 0 ≤ p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''' : ∀ i ∈ s, p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''' : ∀ i ∈ s, 0 ≤ 1 - p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''' : ∀ i ∈ s, 1 - p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''' : ∀ i ∈ s, 0 ≤ p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''' : ∀ i ∈ s, p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''' : ∀ i ∈ s, 0 ≤ 1 - p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''' : ∀ i ∈ s, 1 - p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''' : ∀ i ∈ s, 0 ≤ p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''' : ∀ i ∈ s, p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''' : ∀ i ∈ s, 0 ≤ 1 - p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''' : ∀ i ∈ s, 1 - p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''' : ∀ i ∈ s, 0 ≤ p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''''' : ∀ i ∈ s, p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''''' : ∀ i ∈ s, 0 ≤ 1 - p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''''''' : ∀ i ∈ s, 1 - p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''''''' : ∀ i ∈ s, 0 ≤ p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''''''''' : ∀ i ∈ s, p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''''''''' : ∀ i ∈ s, 0 ≤ 1 - p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''''''''''' : ∀ i ∈ s, 1 - p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''''''''''' : ∀ i ∈ s, 0 ≤ p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''''''''''''' : ∀ i ∈ s, p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''''''''''''' : ∀ i ∈ s, 0 ≤ 1 - p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''''''''''''''' : ∀ i ∈ s, 1 - p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''''''''''''''' : ∀ i ∈ s, 0 ≤ p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''''''''''''''''' : ∀ i ∈ s, p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''''''''''''''''' : ∀ i ∈ s, 0 ≤ 1 - p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''''''''''''''''''' : ∀ i ∈ s, 1 - p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''''''''''''''''''' : ∀ i ∈ s, 0 ≤ p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''''''''''''''''''''' : ∀ i ∈ s, p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''''''''''''''''''''' : ∀ i ∈ s, 0 ≤ 1 - p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''''''''''''''''''''''' : ∀ i ∈ s, 1 - p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''''''''''''''''''''''' : ∀ i ∈ s, 0 ≤ p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''''''''''''''''''''''''' : ∀ i ∈ s, p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''''''''''''''''''''''''' : ∀ i ∈ s, 0 ≤ 1 - p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''''''''''''''''''''''''''' : ∀ i ∈ s, 1 - p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''''''''''''''''''''''''''' : ∀ i ∈ s, 0 ≤ p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''''''''''''''''''''''''''''' : ∀ i ∈ s, p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''''''''''''''''''''''''''''' : ∀ i ∈ s, 0 ≤ 1 - p i := fun i hi => by linarith [h2p' i hi]
    have h2p_i''''''''''''''''''''''''''''''''''''''''''''' : ∀ i ∈ s, 1 - p i ≤ 1 := fun i hi => by linarith [h2p' i hi]
    have h2p_i'''''''''''''''''''''''''''''''''''''''''''''' : ∀ i ∈ s, 0 ≤ p i := fun i hi => by linarith [h2p' i hi]Complete the following Lean 4 code:

```lean4
import Mathlib.Algebra.Group.Submonoid.Membership
import Mathlib.Algebra.Group.Subsemigroup.Membership
import Mathlib.Algebra.Ring.Center
import Mathlib.Algebra.Ring.Centralizer
import Mathlib.Algebra.Ring.Equiv
import Mathlib.Algebra.Ring.Prod
import Mathlib.Algebra.Group.Hom.End
import Mathlib.Data.Set.Finite
import Mathlib.GroupTheory.Subsemigroup.Centralizer



/-!
# Bundled non-unital subsemirings

We define bundled non-unital subsemirings and some standard constructions:
`CompleteLattice` structure, `subtype` and `inclusion` ring homomorphisms, non-unital subsemiring
`map`, `comap` and range (`srange`) of a `NonUnitalRingHom` etc.
-/

/- (... 100 lines omitted) -/



@[simp]
theorem coe_toAddSubmonoid (s : NonUnitalSubsemiring R) : (s.toAddSubmonoid : Set R) = s :=
  rfl


@[simp]
theorem mem_toAddSubmonoid {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.toAddSubmonoid ↔ x ∈ s :=
  Iff.rfl


@[simp]
theorem coe_toSubsemigroup (s : NonUnitalSubsemiring R) : (s.toSubsemigroup : Set R) = s :=
  rfl


@[simp]
theorem mem_toSubsemigroup {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.toSubsemigroup ↔ x ∈ s :=
  Iff.rfl
```

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Hausdorff.lean - 2024-09-08 18:25:56.253399.
---133/200---
For theorem LipschitzOnWith.hausdorffMeasure_image_le in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s 


Original valid proof:
:= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  · rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)
    · simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    · simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty ⟨x, hx⟩
    · haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  · have hCd0 : (C : ℝ≥0∞) ^ d ≠ 0 := by simp [hC0.ne']
    have hCd : (C : ℝ≥0∞) ^ d ≠ ∞ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      ← ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : ℝ≥0∞ => (C : ℝ≥0∞) * d ^ (r : ℝ)) (𝓝 0) (𝓝 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      ⟨δ, δ0, H⟩
    refine le_iSup₂_of_le δ δ0 <| iInf₂_mono' fun t hst ↦
      ⟨fun n => f '' (t n ∩ s), ?_, iInf_mono' fun htδ ↦
        ⟨fun n => (h.ediam_image_inter_le (t n)).trans (H (htδ n)).le, ?_⟩⟩
    · rw [← image_iUnion, ← iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    · refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, ← ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
∧ μH[d] (f '' s) = 0 ∨
      μH[d] (f '' s) = ∞ ∧ μH[r * d] s = 0 := by
  rcases h.isometry_or_antilipschitz_of_zero_lt_r hr with (⟨hfs, _⟩ | ⟨K, hK⟩)
  · exact hfs.hausdorffMeasure_image_le hd
  have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
    rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
    · exact Or.inl (hK.hausdorffMeasure_image_eq_zero hs)
    · exact Or.inr (hK.hausdorffMeasure_image_eq_top hs)
  exact this.imp (fun h ↦ ⟨h, hs⟩) fun h ↦ ⟨h, hK.hausdorffMeasure_preimage_eq_zero⟩

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[r*d] s` for `d ≤ r`. -/
theorem hausdorffMeasure_image_le_of_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : d ≤ r) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s := by
  rcases eq_or_lt_of_le hd with (rfl | hd); · exact h.hausdorffMeasure_image_le hr
  have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
    rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
    · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
    · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
  cases this with
  | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
  | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for `d ≤ r`. -/
theorem hausdorffMeasure_image_le_of_le' (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : d ≤ r) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  simpa only [mul_comm (r : ℝ), mul_comm (C : ℝ≥0∞)] using
    h.hausdorffMeasure_image_le_of_le hr (mul_le_mul_of_nonneg_left hd (zero_le r))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for any `d`. -/
theorem hausdorffMeasure_image_le' (h : HolderOnWith C r f s) (hr : 0 < r) (d : ℝ) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases le_or_lt d r with hd | hd
  · exact h.hausdorffMeasure_image_le_of_le' hr hd
  · have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
      rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
      · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
      · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
    cases this with
    | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
    | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for any `d`. -/
theorem hausdorffMeasure_image_le'' (h : HolderOnWith C r f s) (hr : 0 < r) (d : ℝ) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases le_or_lt d r with hd | hd
  · exact h.hausdorffMeasure_image_le_of_le' hr hd
  · have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
      rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
      · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
      · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
    cases this with
    | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
    | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for any `d`. -/
theorem hausdorffMeasure_image_le''' (h : HolderOnWith C r f s) (hr : 0 < r) (d : ℝ) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases le_or_lt d r with hd | hd
  · exact h.hausdorffMeasure_image_le_of_le' hr hd
  · have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
      rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
      · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
      · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
    cases this with
    | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
    | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))
```

Attempt failure.

---134/200---
For theorem HolderOnWith.hausdorffMeasure_image_le in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s 


Original valid proof:
:= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  · rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)
    · simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    · simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty ⟨x, hx⟩
    · haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  · have hCd0 : (C : ℝ≥0∞) ^ d ≠ 0 := by simp [hC0.ne']
    have hCd : (C : ℝ≥0∞) ^ d ≠ ∞ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      ← ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : ℝ≥0∞ => (C : ℝ≥0∞) * d ^ (r : ℝ)) (𝓝 0) (𝓝 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      ⟨δ, δ0, H⟩
    refine le_iSup₂_of_le δ δ0 <| iInf₂_mono' fun t hst ↦
      ⟨fun n => f '' (t n ∩ s), ?_, iInf_mono' fun htδ ↦
        ⟨fun n => (h.ediam_image_inter_le (t n)).trans (H (htδ n)).le, ?_⟩⟩
    · rw [← image_iUnion, ← iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    · refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, ← ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
∧ μH[d] (f '' s) = 0 ∨
      μH[d] (f '' s) = ∞ ∧ μH[r * d] s = 0 := by
  rcases h.isometry_or_antilipschitz_of_zero_lt_r hr with (⟨hfs, _⟩ | ⟨K, hK⟩)
  · exact hfs.hausdorffMeasure_image_le hd
  have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
    rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
    · exact Or.inl (hK.hausdorffMeasure_image_eq_zero hs)
    · exact Or.inr (hK.hausdorffMeasure_image_eq_top hs)
  exact this.imp (fun h ↦ ⟨h, hs⟩) fun h ↦ ⟨h, hK.hausdorffMeasure_preimage_eq_zero⟩

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[r*d] s` for `d ≤ r`. -/
theorem hausdorffMeasure_image_le_of_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : d ≤ r) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s := by
  rcases eq_or_lt_of_le hd with (rfl | hd); · exact h.hausdorffMeasure_image_le hr
  have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
    rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
    · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
    · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
  cases this with
  | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
  | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for `d ≤ r`. -/
theorem hausdorffMeasure_image_le_of_le' (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : d ≤ r) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  simpa only [mul_comm (r : ℝ), mul_comm (C : ℝ≥0∞)] using
    h.hausdorffMeasure_image_le_of_le hr (mul_le_mul_of_nonneg_left hd (zero_le r))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for any `d`. -/
theorem hausdorffMeasure_image_le' (h : HolderOnWith C r f s) (hr : 0 < r) (d : ℝ) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases le_or_lt d r with hd | hd
  · exact h.hausdorffMeasure_image_le_of_le' hr hd
  · have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
      rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
      · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
      · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
    cases this with
    | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
    | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for any `d`. -/
theorem hausdorffMeasure_image_le'' (h : HolderOnWith C r f s) (hr : 0 < r) (d : ℝ) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases le_or_lt d r with hd | hd
  · exact h.hausdorffMeasure_image_le_of_le' hr hd
  · have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
      rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
      · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
      · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
    cases this with
    | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
    | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for any `d`. -/
theorem hausdorffMeasure_image_le''' (h : HolderOnWith C r f s) (hr : 0 < r) (d : ℝ) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases le_or_lt d r with hd | hd
  · exact h.hausdorffMeasure_image_le_of_le' hr hd
  · have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
      rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
      · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
      · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
    cases this with
    | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
    | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))
```

Attempt failure.

---135/200---
For theorem LipschitzOnWith.hausdorffMeasure_image_le in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : 0 ≤ d) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s 


Original valid proof:
:= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  · rcases eq_empty_or_nonempty s with (rfl | ⟨x, hx⟩)
    · simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    · simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty ⟨x, hx⟩
    · haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  · have hCd0 : (C : ℝ≥0∞) ^ d ≠ 0 := by simp [hC0.ne']
    have hCd : (C : ℝ≥0∞) ^ d ≠ ∞ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      ← ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : ℝ≥0∞ => (C : ℝ≥0∞) * d ^ (r : ℝ)) (𝓝 0) (𝓝 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      ⟨δ, δ0, H⟩
    refine le_iSup₂_of_le δ δ0 <| iInf₂_mono' fun t hst ↦
      ⟨fun n => f '' (t n ∩ s), ?_, iInf_mono' fun htδ ↦
        ⟨fun n => (h.ediam_image_inter_le (t n)).trans (H (htδ n)).le, ?_⟩⟩
    · rw [← image_iUnion, ← iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    · refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, ← ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd


Verifying proof (Commit 2e39f97941029a908858d0472e3091e677aa35e4):
∧ μH[d] (f '' s) = 0 ∨
      μH[d] (f '' s) = ∞ ∧ μH[r * d] s = 0 := by
  rcases h.isometry_or_antilipschitz_of_zero_lt_r hr with (⟨hfs, _⟩ | ⟨K, hK⟩)
  · exact hfs.hausdorffMeasure_image_le hd
  have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
    rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
    · exact Or.inl (hK.hausdorffMeasure_image_eq_zero hs)
    · exact Or.inr (hK.hausdorffMeasure_image_eq_top hs)
  exact this.imp (fun h ↦ ⟨h, hs⟩) fun h ↦ ⟨h, hK.hausdorffMeasure_preimage_eq_zero⟩

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[r*d] s` for `d ≤ r`. -/
theorem hausdorffMeasure_image_le_of_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : d ≤ r) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[r * d] s := by
  rcases eq_or_lt_of_le hd with (rfl | hd); · exact h.hausdorffMeasure_image_le hr
  have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
    rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
    · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
    · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
  cases this with
  | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
  | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for `d ≤ r`. -/
theorem hausdorffMeasure_image_le_of_le' (h : HolderOnWith C r f s) (hr : 0 < r) {d : ℝ} (hd : d ≤ r) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  simpa only [mul_comm (r : ℝ), mul_comm (C : ℝ≥0∞)] using
    h.hausdorffMeasure_image_le_of_le hr (mul_le_mul_of_nonneg_left hd (zero_le r))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for any `d`. -/
theorem hausdorffMeasure_image_le' (h : HolderOnWith C r f s) (hr : 0 < r) (d : ℝ) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases le_or_lt d r with hd | hd
  · exact h.hausdorffMeasure_image_le_of_le' hr hd
  · have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
      rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
      · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
      · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
    cases this with
    | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
    | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for any `d`. -/
theorem hausdorffMeasure_image_le'' (h : HolderOnWith C r f s) (hr : 0 < r) (d : ℝ) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases le_or_lt d r with hd | hd
  · exact h.hausdorffMeasure_image_le_of_le' hr hd
  · have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
      rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
      · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
      · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
    cases this with
    | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
    | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))

/-- If `f : X → Y` is Hölder continuous on a set `s`, then the Hausdorff measure of its image
is bounded by `C ^ d * μH[d] s` for any `d`. -/
theorem hausdorffMeasure_image_le''' (h : HolderOnWith C r f s) (hr : 0 < r) (d : ℝ) :
    μH[d] (f '' s) ≤ (C : ℝ≥0∞) ^ d * μH[d] s := by
  rcases le_or_lt d r with hd | hd
  · exact h.hausdorffMeasure_image_le_of_le' hr hd
  · have : μH[d] (f '' s) = 0 ∨ μH[d] (f '' s) = ∞ := by
      rcases eq_or_ne (μH[r * d] s) 0 with (hs | hs)
      · exact Or.inl (h.hausdorffMeasure_image_eq_zero hs)
      · exact Or.inr (h.hausdorffMeasure_image_eq_top hs)
    cases this with
    | inl h => exact h.trans_le (ENNReal.le_of_eq (zero_mul _))
    | inr h => exact h.trans_le (ENNReal.le_of_eq (top_mul _))
```

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean - 2024-09-08 18:27:45.620673.
---136/200---
For theorem Real.volume_eq_stieltjes_id in Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean:
theorem volume_eq_stieltjes_id : (volume : Measure ℝ) = StieltjesFunction.id.measure 


Original valid proof:
:= by
  haveI : IsAddLeftInvariant StieltjesFunction.id.measure :=
    ⟨fun a =>
      Eq.symm <|
        Real.measure_ext_Ioo_rat fun p q => by
          simp only [Measure.map_apply (measurable_const_add a) measurableSet_Ioo,
            sub_sub_sub_cancel_right, StieltjesFunction.measure_Ioo, StieltjesFunction.id_leftLim,
            StieltjesFunction.id_apply, id, preimage_const_add_Ioo]⟩
  have A : StieltjesFunction.id.measure (stdOrthonormalBasis ℝ ℝ).toBasis.parallelepiped = 1 := by
    change StieltjesFunction.id.measure (parallelepiped (stdOrthonormalBasis ℝ ℝ)) = 1
    rcases parallelepiped_orthonormalBasis_one_dim (stdOrthonormalBasis ℝ ℝ) with (H | H) <;>
      simp only [H, StieltjesFunction.measure_Icc, StieltjesFunction.id_apply, id, tsub_zero,
        StieltjesFunction.id_leftLim, sub_neg_eq_add, zero_add, ENNReal.ofReal_one]
  conv_rhs =>
    rw [addHaarMeasure_unique StieltjesFunction.id.measure
        (stdOrthonormalBasis ℝ ℝ).toBasis.parallelepiped, A]
  simp only [volume, Basis.addHaar, one_smul]


Verifying proof (Commit 1cce5367e4d13c82a93597fe7dc3e4a27c9e2733):
1 := by
  refine' (Measure.absolutelyContinuous_iff_forall_le _ _).mpr fun s _ => _
  rw [StieltjesFunction.id.measure_apply, sub_zero, ENNReal.ofReal_one, one_mul]
  exact (measure_mono (subset_univ s)).trans_eq (measure_univ (volume : Measure ℝ))
```

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/MeasureSpace.lean - 2024-09-08 18:28:01.081609.
---137/200---
For theorem MeasureTheory.measure_iUnion_eq_iSup in Mathlib/MeasureTheory/Measure/MeasureSpace.lean:
theorem measure_iUnion_eq_iSup [Countable ι] {s : ι → Set α} (hd : Directed (· ⊆ ·) s) :
    μ (⋃ i, s i) = ⨆ i, μ (s i) 


Original valid proof:
:= by
  cases nonempty_encodable ι
  generalize ht : Function.extend Encodable.encode s ⊥ = t
  replace hd : Directed (· ⊆ ·) t := ht ▸ hd.extend_bot Encodable.encode_injective
  suffices μ (⋃ n, t n) = ⨆ n, μ (t n) by
    simp only [← ht, Function.apply_extend μ, ← iSup_eq_iUnion,
      iSup_extend_bot Encodable.encode_injective, (· ∘ ·), Pi.bot_apply, bot_eq_empty,
      measure_empty] at this
    exact this.trans (iSup_extend_bot Encodable.encode_injective _)
  clear! ι
  refine le_antisymm ?_ (iSup_le fun i => measure_mono <| subset_iUnion _ _)
  set T : ℕ → Set α := fun n => toMeasurable μ (t n)
  set Td : ℕ → Set α := disjointed T
  have hm : ∀ n, MeasurableSet (Td n) :=
    MeasurableSet.disjointed fun n => measurableSet_toMeasurable _ _
  calc
    μ (⋃ n, t n) ≤ μ (⋃ n, T n) := measure_mono (iUnion_mono fun i => subset_toMeasurable _ _)
    _ = μ (⋃ n, Td n) := by rw [iUnion_disjointed]
    _ ≤ ∑' n, μ (Td n) := measure_iUnion_le _
    _ = ⨆ I : Finset ℕ, ∑ n ∈ I, μ (Td n) := ENNReal.tsum_eq_iSup_sum
    _ ≤ ⨆ n, μ (t n) := iSup_le fun I => by
      rcases hd.finset_le I with ⟨N, hN⟩
      calc
        (∑ n ∈ I, μ (Td n)) = μ (⋃ n ∈ I, Td n) :=
          (measure_biUnion_finset ((disjoint_disjointed T).set_pairwise I) fun n _ => hm n).symm
        _ ≤ μ (⋃ n ∈ I, T n) := measure_mono (iUnion₂_mono fun n _hn => disjointed_subset _ _)
        _ = μ (⋃ n ∈ I, t n) := measure_biUnion_toMeasurable I.countable_toSet _
        _ ≤ μ (t N) := measure_mono (iUnion₂_subset hN)
        _ ≤ ⨆ n, μ (t n) := le_iSup (μ ∘ t) N


Verifying proof (Commit 4dd5efc4146f75be242abbd1962ef52988665580):
↔ ∀ i, μ (s i) ≠ ∞ := by
  refine ⟨fun h i => ?_, fun h => ?_⟩
  · have := measure_mono (subset_iUnion s i)
    rwa [h, lt_top_iff_ne_top] at this
  · rw [measure_iUnion_eq_iSup_nat hd.nat_le_nat, iSup_ne_top]
    intro i
    exact h i


theorem measure_iUnion_eq_iSup_of_monotone [Countable ι] {s : ι → Set α} (h_mono : Monotone s) :
    μ (⋃ i, s i) = ⨆ i, μ (s i) ↔ ∀ i, μ (s i) ≠ ∞ :=
  measure_iUnion_eq_iSup_of_directed (fun _ _ ↦ h_mono.directed_le)


theorem measure_iUnion_eq_iSup_nat {s : ℕ → Set α} (hd : Directed (· ⊆ ·) s) :
    μ (⋃ i, s i) = ⨆ i, μ (s i) :=
  measure_iUnion_eq_iSup hd.le_supr_nat
```

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Restrict.lean - 2024-09-08 18:28:21.869239.
---138/200---
For theorem MeasureTheory.Measure.restrict_le_self in Mathlib/MeasureTheory/Measure/Restrict.lean:
theorem restrict_le_self : μ.restrict s ≤ μ 


Original valid proof:
:=
  Measure.le_iff.2 fun t ht => calc
    μ.restrict s t = μ (t ∩ s) := restrict_apply ht
    _ ≤ μ t := measure_mono inter_subset_left


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
↔ ∀ t, μ (s ∩ t) ≤ μ t := by
  refine' ⟨fun h t => _, fun h t => _⟩
  · exact h t
  · rw [← measure_inter_add_diff t s, le_add_iff_nonneg_right]
    exact h _

/-- Restriction of a measure to a subset is monotone both in set and in measure. -/
theorem restrict_mono' {_m0 : MeasurableSpace α} ⦃s s' : Set α⦄ ⦃μ ν : Measure α⦄ (hs : s ≤ᵐ[μ] s')
    (hμν : μ ≤ ν) : μ.restrict s ≤ ν.restrict s' :=
  Measure.le_iff.2 fun t ht => calc
    μ.restrict s t = μ (s ∩ t) := by rw [Measure.restrict_apply ht]
    _ ≤ μ (s' ∩ t) := (measure_mono_ae <| hs.mono fun _x hx ⟨hxt, hxs⟩ => ⟨hxt, hx hxs⟩)
    _ ≤ ν (s' ∩ t) := le_iff'.1 hμν (s' ∩ t)
    _ = ν.restrict s' t := (Measure.restrict_apply ht).symm


/-- Restriction of a measure to a subset is monotone both in set and in measure. -/
theorem restrict_mono {_m0 : MeasurableSpace α} ⦃s s' : Set α⦄ (hs : s ⊆ s') ⦃μ ν : Measure α⦄
    (hμν : μ ≤ ν) : μ.restrict s ≤ ν.restrict s' :=
  restrict_mono' (HasSubset.Subset.eventuallyLE hs) hμν


/-- If `t` is a measurable set, then the measure of `t` with respect to the restriction of
  the measure to `s` equals the outer measure of `t ∩ s`. An alternate version requiring that `s`
  be measurable instead of `t` exists as `Measure.restrict_apply'`. -/
@[simp]
theorem restrict_apply (ht : MeasurableSet t) : μ.restrict s t = μ (t ∩ s) :=
  restrict_apply₀ ht.nullMeasurableSet


/-- Restriction of a measure to a subset is monotone both in set and in measure. -/
theorem restrict_mono_ae (h : s ≤ᵐ[μ] t) : μ.restrict s ≤ μ.restrict t := by
  refine le_iff.2 fun u hu ↦ ?_
  simp only [Set.inter_comm, restrict_apply hu, ← inter_assoc, inter_comm s]
  exact measure_mono_ae (h.mono fun x hx ↦ by simp [hx])
```

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Sub.lean - 2024-09-08 18:28:39.472270.
---139/200---
For theorem MeasureTheory.Measure.restrict_sub_eq_restrict_sub_restrict in Mathlib/MeasureTheory/Measure/Sub.lean:
theorem restrict_sub_eq_restrict_sub_restrict (h_meas_s : MeasurableSet s) :
    (μ - ν).restrict s = μ.restrict s - ν.restrict s 


Original valid proof:
:= by
  repeat rw [sub_def]
  have h_nonempty : { d | μ ≤ d + ν }.Nonempty := ⟨μ, Measure.le_add_right le_rfl⟩
  rw [restrict_sInf_eq_sInf_restrict h_nonempty h_meas_s]
  apply le_antisymm
  · refine sInf_le_sInf_of_forall_exists_le ?_
    intro ν' h_ν'_in
    rw [mem_setOf_eq] at h_ν'_in
    refine ⟨ν'.restrict s, ?_, restrict_le_self⟩
    refine ⟨ν' + (⊤ : Measure α).restrict sᶜ, ?_, ?_⟩
    · rw [mem_setOf_eq, add_right_comm, Measure.le_iff]
      intro t h_meas_t
      repeat rw [← measure_inter_add_diff t h_meas_s]
      refine add_le_add ?_ ?_
      · rw [add_apply, add_apply]
        apply le_add_right _
        rw [← restrict_eq_self μ inter_subset_right,
          ← restrict_eq_self ν inter_subset_right]
        apply h_ν'_in
      · rw [add_apply, restrict_apply (h_meas_t.diff h_meas_s), diff_eq, inter_assoc, inter_self,
          ← add_apply]
        have h_mu_le_add_top : μ ≤ ν' + ν + ⊤ := by simp only [add_top, le_top]
        exact Measure.le_iff'.1 h_mu_le_add_top _
    · ext1 t h_meas_t
      simp [restrict_apply h_meas_t, restrict_apply (h_meas_t.inter h_meas_s), inter_assoc]
  · refine sInf_le_sInf_of_forall_exists_le ?_
    refine forall_mem_image.2 fun t h_t_in => ⟨t.restrict s, ?_, le_rfl⟩
    rw [Set.mem_setOf_eq, ← restrict_add]
    exact restrict_mono Subset.rfl h_t_in


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔
      ∀ t, MeasurableSet t → μ (s ∩ t) ≤ ν (s ∩ t) := by
  rw [← sub_nonneg]
  exact restrict_sub_nonneg_inter_iff h_meas_s


theorem restrict_sub_eq_restrict_sub_restrict' (h_meas_s : MeasurableSet s) :
    (μ - ν).restrict s = μ.restrict s - ν.restrict s ↔
      ∀ t, MeasurableSet t → μ (t ∩ s) ≤ ν (t ∩ s) := by
  rw [← sub_nonneg]
  exact restrict_sub_nonneg_inter_iff' h_meas_s


theorem restrict_sub_eq_restrict_sub_restrict_of_subset (h_meas_s : MeasurableSet s) (hst : s ⊆ t) :
    (μ - ν).restrict t = μ.restrict t - ν.restrict t ↔
      ∀ u, MeasurableSet u → μ (u ∩ s) ≤ ν (u ∩ s) := by
  rw [← sub_nonneg]
  exact restrict_sub_nonneg_inter_of_subset h_meas_s hst
```

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/VectorMeasure.lean - 2024-09-08 18:28:47.439291.
---140/200---
For theorem MeasureTheory.VectorMeasure.restrict_le_restrict_iUnion in Mathlib/MeasureTheory/Measure/VectorMeasure.lean:
theorem restrict_le_restrict_iUnion {f : ℕ → Set α} (hf₁ : ∀ n, MeasurableSet (f n))
    (hf₂ : ∀ n, v ≤[f n] w) : v ≤[⋃ n, f n] w 


Original valid proof:
:= by
  refine restrict_le_restrict_of_subset_le v w fun a ha₁ ha₂ => ?_
  have ha₃ : ⋃ n, a ∩ disjointed f n = a := by
    rwa [← Set.inter_iUnion, iUnion_disjointed, Set.inter_eq_left]
  have ha₄ : Pairwise (Disjoint on fun n => a ∩ disjointed f n) :=
    (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right
  rw [← ha₃, v.of_disjoint_iUnion_nat _ ha₄, w.of_disjoint_iUnion_nat _ ha₄]
  · refine tsum_le_tsum (fun n => (restrict_le_restrict_iff v w (hf₁ n)).1 (hf₂ n) ?_ ?_) ?_ ?_
    · exact ha₁.inter (MeasurableSet.disjointed hf₁ n)
    · exact Set.Subset.trans Set.inter_subset_right (disjointed_subset _ _)
    · refine (v.m_iUnion (fun n => ?_) ?_).summable
      · exact ha₁.inter (MeasurableSet.disjointed hf₁ n)
      · exact (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right
    · refine (w.m_iUnion (fun n => ?_) ?_).summable
      · exact ha₁.inter (MeasurableSet.disjointed hf₁ n)
      · exact (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right
  · intro n
    exact ha₁.inter (MeasurableSet.disjointed hf₁ n)
  · exact fun n => ha₁.inter (MeasurableSet.disjointed hf₁ n)


Verifying proof (Commit a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0):
 := by
  refine restrict_le_restrict_of_subset_of_ae_le (MeasurableSet.iUnion hf₁) ?_ ?_
  · filter_upwards with x using iUnion_subset_iff.2 fun n ↦ (hf₂ n) x
  · filter_upwards with x using iUnion_subset_iff.2 fun n ↦ (hf₂ n) x


theorem restrict_le_restrict_biUnion {s : Set β} {f : β → Set α} (hf₁ : ∀ b ∈ s, MeasurableSet (f b))
    (hf₂ : ∀ b ∈ s, v ≤[f b] w) : v ≤[⋃ b ∈ s, f b] w := by
  simp_rw [biUnion_eq_iUnion]
  exact restrict_le_restrict_iUnion (fun b ↦ hf₁ b b.2) fun b ↦ hf₂ b b.2
```

Attempt failure.

Working on Mathlib/MeasureTheory/SetSemiring.lean - 2024-09-08 18:29:11.890118.
---141/200---
For theorem MeasureTheory.IsSetSemiring.pairwiseDisjoint_diffFinset₀ in Mathlib/MeasureTheory/SetSemiring.lean:
lemma pairwiseDisjoint_diffFinset₀ (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) id 


Original valid proof:
:= by
  classical
  simp only [diffFinset₀, coe_sdiff, coe_singleton]
  exact Set.PairwiseDisjoint.subset
    (hC.exists_disjoint_finset_diff_eq hs hI).choose_spec.2.1 diff_subset


Verifying proof (Commit b492f764dc62b80a0be745055df26ce5b018a24a):
↔
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) id ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) id := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset'' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset''' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset'''' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset''''' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset'''''' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset''''''' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset'''''''' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset''''''''' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset'''''''''' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset''''''''''' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset'''''''''''' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset''''''''''''' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset'''''''''''''' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)
  · exact h.mono (fun s t hst ↦ hst.2)

lemma pairwiseDisjoint_diffFinset₀_of_subset''''''''''''''' (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)
    (hJ : J ⊆ I) :
    PairwiseDisjoint (hC.diffFinset₀ hs hI : Set (Set α)) (↑) ↔
    PairwiseDisjoint (hC.diffFinset₀ hs (hI.trans hJ) : Set (Set α)) (↑) := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · exact h.mono (fun s t hst ↦ hst.1)

Attempt failure.

---142/200---
For theorem MeasureTheory.IsSetSemiring.pairwiseDisjoint_union_diffFinset₀ in Mathlib/MeasureTheory/SetSemiring.lean:
lemma pairwiseDisjoint_union_diffFinset₀ (hC : IsSetSemiring C) (hs : s ∈ C)
    (hI : ↑I ⊆ C) (h_dis : PairwiseDisjoint (I : Set (Set α)) id) :
    PairwiseDisjoint (I ∪ hC.diffFinset₀ hs hI : Set (Set α)) id 


Original valid proof:
:= by
  rw [pairwiseDisjoint_union]
  refine ⟨h_dis, hC.pairwiseDisjoint_diffFinset₀ hs hI, fun u hu v hv _ ↦ ?_⟩
  simp_rw [id]
  exact disjoint_of_subset (subset_sUnion_of_mem hu) (subset_sUnion_of_mem hv)
    (hC.disjoint_sUnion_diffFinset₀ hs hI)


Verifying proof (Commit 3838c3f5cc8da3ed680a157f72d53020cd177151):
↔
    PairwiseDisjoint (I : Set (Set α)) id := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · rw [pairwiseDisjoint_union] at h
    exact h.1
  rw [pairwiseDisjoint_union]
  refine ⟨h, ?_⟩
  rintro i ∈ I h_disj ⟨j, hj, hij⟩
  exact h_disj hij

lemma pairwiseDisjoint_union_diffFinset₀_of_subset (hC : IsSetSemiring C) (hs : s ∈ C)
    (hI : ↑I ⊆ C) (h_dis : PairwiseDisjoint (I : Set (Set α)) id) (hJs : ↑J ⊆ s) :
    PairwiseDisjoint (I ∪ hC.diffFinset₀ hs hI : Set (Set α)) id ↔
    PairwiseDisjoint (I ∪ J : Set (Set α)) id := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · rw [pairwiseDisjoint_union] at h
    refine h.1.mono ?_
    rw [union_subset_iff, and_iff_left]
    exact hJs
  rw [pairwiseDisjoint_union]
  refine ⟨h.1, ?_⟩
  rintro i ∈ I ∪ J h_disj ⟨j, hj, hij⟩
  exact h_disj hij
```

Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean - 2024-09-08 18:29:31.561625.
---143/200---
For theorem AbsoluteValue.IsAdmissible.exists_approx in Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean:
theorem exists_approx_aux (n : ℕ) (h : abv.IsAdmissible) :
    ∀ {ε : ℝ} (_hε : 0 < ε) {b : R} (_hb : b ≠ 0) (A : Fin (h.card ε ^ n).succ → Fin n → R),
      ∃ i₀ i₁, i₀ ≠ i₁ ∧ ∀ k, (abv (A i₁ k % b - A i₀ k % b) : ℝ) < abv b • ε 


Original valid proof:
:= by
  haveI := Classical.decEq R
  induction' n with n ih
  · intro ε _hε b _hb A
    refine ⟨0, 1, ?_, ?_⟩
    · simp
    rintro ⟨i, ⟨⟩⟩
  intro ε hε b hb A
  let M := h.card ε
  obtain ⟨s, s_inj, hs⟩ :
    ∃ s : Fin (M ^ n).succ → Fin (M ^ n.succ).succ,
      Function.Injective s ∧ ∀ i₀ i₁, (abv (A (s i₁) 0 % b - A (s i₀) 0 % b) : ℝ) < abv b • ε := by
    obtain ⟨t, ht⟩ :
      ∃ t : Fin (M ^ n.succ).succ → Fin M,
        ∀ i₀ i₁, t i₀ = t i₁ → (abv (A i₁ 0 % b - A i₀ 0 % b) : ℝ) < abv b • ε :=
      h.exists_partition hε hb fun x ↦ A x 0
    obtain ⟨s, hs⟩ :=
      Fintype.exists_lt_card_fiber_of_mul_lt_card (f := t)
        (by simpa only [Fintype.card_fin, pow_succ'] using Nat.lt_succ_self (M ^ n.succ))
    refine ⟨fun i ↦ (Finset.univ.filter fun x ↦ t x = s).toList.get <| i.castLE ?_, fun i j h ↦ ?_,
      fun i₀ i₁ ↦ ht _ _ ?_⟩
    · rwa [Finset.length_toList]
    · ext
      simpa [(Finset.nodup_toList _).getElem_inj_iff] using h
    · have : ∀ i h, t ((Finset.univ.filter fun x ↦ t x = s).toList.get ⟨i, h⟩) = s := fun i h ↦
        (Finset.mem_filter.mp (Finset.mem_toList.mp (List.get_mem _ i h))).2
      simp only [Nat.succ_eq_add_one, Finset.length_toList, List.get_eq_getElem] at this
      simp only [Nat.succ_eq_add_one, List.get_eq_getElem, Fin.coe_castLE]
      rw [this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ i₁.2) hs),
        this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ i₀.2) hs)]
  obtain ⟨k₀, k₁, hk, h⟩ := ih hε hb fun x ↦ Fin.tail (A (s x))
  refine ⟨s k₀, s k₁, fun h ↦ hk (s_inj h), fun i ↦ Fin.cases ?_ (fun i ↦ ?_) i⟩
  · exact hs k₀ k₁
  · exact h i


Verifying proof (Commit 61ca0ea882c23bb336df737657ab5b9a48ebdbbe):
∧
        (abv (A i₁ k % b) : ℝ) < abv b • ε ∧ (abv (A i₀ k % b) : ℝ) < abv b • ε := by
  intro ε hε b hb A
  have hb' : 0 < abv b := by
    refine lt_of_le_of_lt (abv_nonneg abv _) ?_
    simpa only [Ne, abv_eq_zero abv] using hb
  have hε' : 0 < ε / 2 := half_pos hε
  have hε'' : 0 < ε ^ (n + 1) / 2 := div_pos (pow_pos hε (n + 1)) two_pos
  let m := h.card ε ^ n
  let B := fun i j => A i j % b
  obtain ⟨⟨i₀, i₁⟩, hi, H⟩ := exists_distinct_fin m (fun i j =>
    (abv (B i 0 % b - B j 0 % b) : ℝ) < ε ^ (n + 1) / 2 ∧
      (abv (B i 0 % b) : ℝ) < ε ^ (n + 1) / 2 ∧ (abv (B j 0 % b) : ℝ) < ε ^ (n + 1) / 2)
  have H' : ∀ k, (abv (A i₁ k % b - A i₀ k % b) : ℝ) < abv b • ε ∧
    (abv (A i₁ k % b) : ℝ) < abv b • ε ∧ (abv (A i₀ k % b) : ℝ) < abv b • ε := by
    intro k
    have Hk := H k
    rw [abv_mod_lt _ hb', abv_mod_lt _ hb', abv_mod_lt _ hb'] at Hk
    exact ⟨Hk.1, Hk.2.1, Hk.2.2⟩
  exact ⟨i₀, i₁, hi, H'⟩
```

Attempt failure.

Working on Mathlib/NumberTheory/Cyclotomic/Discriminant.lean - 2024-09-08 18:29:50.868712.
---144/200---
For theorem IsPrimitiveRoot.discr_zeta_eq_discr_zeta_sub_one in Mathlib/NumberTheory/Cyclotomic/Discriminant.lean:
theorem discr_zeta_eq_discr_zeta_sub_one (hζ : IsPrimitiveRoot ζ n) :
    discr ℚ (hζ.powerBasis ℚ).basis = discr ℚ (hζ.subOnePowerBasis ℚ).basis 


Original valid proof:
:= by
  haveI : NumberField K := @NumberField.mk _ _ _ (IsCyclotomicExtension.finiteDimensional {n} ℚ K)
  have H₁ : (aeval (hζ.powerBasis ℚ).gen) (X - 1 : ℤ[X]) = (hζ.subOnePowerBasis ℚ).gen := by simp
  have H₂ : (aeval (hζ.subOnePowerBasis ℚ).gen) (X + 1 : ℤ[X]) = (hζ.powerBasis ℚ).gen := by simp
  refine discr_eq_discr_of_toMatrix_coeff_isIntegral _ (fun i j => toMatrix_isIntegral H₁ ?_ ?_ _ _)
    fun i j => toMatrix_isIntegral H₂ ?_ ?_ _ _
  · exact hζ.isIntegral n.pos
  · refine minpoly.isIntegrallyClosed_eq_field_fractions' (K := ℚ) (hζ.isIntegral n.pos)
  · exact (hζ.isIntegral n.pos).sub isIntegral_one
  · refine minpoly.isIntegrallyClosed_eq_field_fractions' (K := ℚ) ?_
    exact (hζ.isIntegral n.pos).sub isIntegral_one


Verifying proof (Commit 22e97510854d6906cc856e022d297bf9cf8c9b3a):
∧
      discr ℚ (hζ.powerBasis ℚ).basis = -1 := by
  have h_frob : (discr ℚ (hζ.powerBasis ℚ).basis).natAbs.Coprime (p ^ n) := by
    rw [← discr_prime_pow_mul_discr_eq_discr_pow_mul_discr hζ one_ne_zero, one_pow, one_mul]
    exact discr_prime_pow_coprime hζ
  have h_frob' : (discr ℚ (hζ.subOnePowerBasis ℚ).basis).natAbs.Coprime (p ^ n) := by
    rw [← discr_prime_pow_mul_discr_eq_discr_pow_mul_discr hζ one_ne_zero, one_pow, one_mul]
    exact discr_prime_pow_coprime hζ.subOne
  have h_eq : discr ℚ (hζ.powerBasis ℚ).basis = discr ℚ (hζ.subOnePowerBasis ℚ).basis := by
    rw [← discr_prime_pow_mul_discr_eq_discr_pow_mul_discr hζ one_ne_zero, one_pow, one_mul,
      discr_prime_pow_mul_discr_eq_discr_pow_mul_discr hζ.subOne one_ne_zero, one_pow, one_mul]
  refine ⟨h_eq, ?_⟩
  rw [h_eq, discr_prime_pow_eq_neg_one_of_prime hζ hp]
```

Attempt failure.

Working on Mathlib/NumberTheory/Cyclotomic/Rat.lean - 2024-09-08 18:30:17.479963.
---145/200---
For theorem IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime_pow in Mathlib/NumberTheory/Cyclotomic/Rat.lean:
theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) ℤ ℚ) ℤ (CyclotomicField (p ^ k) ℚ) 


Original valid proof:
:= by
  have hζ := zeta_spec (p ^ k) ℚ (CyclotomicField (p ^ k) ℚ)
  refine ⟨IsFractionRing.injective _ _, @fun x => ⟨fun h => ⟨⟨x, ?_⟩, rfl⟩, ?_⟩⟩
  · have := isIntegralClosure_adjoin_singleton_of_prime_pow hζ
    obtain ⟨y, rfl⟩ := this.isIntegral_iff.1 h
    refine adjoin_mono ?_ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hζ.pow_eq_one
  · rintro ⟨y, rfl⟩
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} ℤ _).isIntegral _)


Verifying proof (Commit 76620f7bc93be67fe98a87948024801e42a6f815):
ℚ := by
  -- Porting note: `simp` unfolds `CyclotomicRing` to `(⋯)`, so we need to make sure
  -- all the necessary components are in the context.
  have h := cyclotomicRing_isIntegralClosure p k ℤ ℚ
  letI := h.toIsIntegralClosure
  letI : Algebra (CyclotomicRing (p ^ k) ℤ ℚ) (CyclotomicField (p ^ k) ℚ) :=
    (CyclotomicRing.toCyclotomicField (p ^ k) ℤ ℚ).toAlgebra
  letI : IsScalarTower ℤ (CyclotomicRing (p ^ k) ℤ ℚ) (CyclotomicField (p ^ k) ℚ) :=
    IsScalarTower.of_algebraMap_eq' rfl
  exact IsIntegralClosure.isIntegralClosure_of_isDomain_of_isSeparable
    (CyclotomicField (p ^ k) ℚ) (CyclotomicRing (p ^ k) ℤ ℚ) ℤ
    (IsDomain.to_noZeroDivisors _) (IsSeparable.separable _ _)
```

Attempt failure.

Working on Mathlib/NumberTheory/DiophantineApproximation.lean - 2024-09-08 18:30:48.054895.
---146/200---
For theorem Real.exists_rat_eq_convergent' in Mathlib/NumberTheory/DiophantineApproximation.lean:
theorem exists_rat_eq_convergent' {v : ℕ} (h' : ContfracLegendre.Ass ξ u v) :
    ∃ n, (u / v : ℚ) = ξ.convergent n 


Original valid proof:
:= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing ξ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  · replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg ξ).trans_lt h)
  · rw [Nat.cast_one, div_one]
    obtain ⟨_, h₁, h₂⟩ := h
    rcases le_or_lt (u : ℝ) ξ with ht | ht
    · use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h₂).2) <;> norm_num
    · replace h₁ := lt_sub_iff_add_lt'.mp (h₁ rfl)
      have hξ₁ : ⌊ξ⌋ = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact ⟨(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h₁).le, ht⟩
      rcases eq_or_ne ξ ⌊ξ⌋ with Hξ | Hξ
      · rw [Hξ, hξ₁, cast_sub, cast_one, ← sub_eq_add_neg, sub_lt_sub_iff_left] at h₁
        exact False.elim (lt_irrefl _ <| h₁.trans one_half_lt_one)
      · have hξ₂ : ⌊(fract ξ)⁻¹⌋ = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr Hξ), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr Hξ) zero_lt_two]
          refine ⟨(fract_lt_one ξ).le, ?_⟩
          rw [fract, hξ₁, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert h₁ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hξ₁, hξ₂, cast_sub, cast_one]
  · obtain ⟨huv₀, huv₁⟩ := aux₂ (Nat.cast_le.mpr ht) h
    have Hv : (v : ℚ) ≠ 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huv₁' : (u - ⌊ξ⌋ * v).toNat < v := by zify; rwa [toNat_of_nonneg huv₀.le]
    have inv : ContfracLegendre.Ass (fract ξ)⁻¹ v (u - ⌊ξ⌋ * ↑v).toNat :=
      (toNat_of_nonneg huv₀.le).symm ▸ invariant (Nat.cast_le.mpr ht) h
    obtain ⟨n, hn⟩ := ih (u - ⌊ξ⌋ * v).toNat huv₁' inv
    use n + 1
    rw [convergent_succ, ← hn,
      (mod_cast toNat_of_nonneg huv₀.le : ((u - ⌊ξ⌋ * v).toNat : ℚ) = u - ⌊ξ⌋ * v),
      cast_natCast, inv_div, sub_div, mul_div_cancel_right₀ _ Hv, add_sub_cancel]


Verifying proof (Commit 61ddcfa78d90f5773ac5739822ee3721851aa662):
∧ (u : ℤ) ≠ 0 ∧ v ≠ 0 := by
  obtain ⟨n, hn⟩ := exists_rat_eq_convergent h'
  exact ⟨n, hn, h'.1, h'.2.1⟩


/-- The convergents of `ξ` are the best rational approximations of `ξ`. -/
theorem exists_rat_eq_convergent_iff :
    (∃ n, (u / v : ℚ) = ξ.convergent n ∧ (u : ℤ) ≠ 0 ∧ v ≠ 0) ↔ ContfracLegendre.Ass ξ u v := by
  constructor
  · rintro ⟨n, hn, hu, hv⟩
    exact ⟨hu, hv, hn.symm ▸ (convergent_eq_conts_a_div_conts_b _ _).symm⟩
  · exact exists_rat_eq_convergent'


/-- The convergents of `ξ` are the best rational approximations of `ξ`. -/
theorem exists_rat_eq_convergent_iff' :
    (∃ n, (u / v : ℚ) = ξ.convergent n ∧ (u : ℤ) ≠ 0 ∧ v ≠ 0) ↔ ContfracLegendre.Ass ξ u v := by
  constructor
  · rintro ⟨n, hn, hu, hv⟩
    exact ⟨hu, hv, hn.symm ▸ (convergent_eq_conts_a_div_conts_b _ _).symm⟩
  · exact exists_rat_eq_convergent'
```

Attempt failure.

Working on Mathlib/NumberTheory/FunctionField.lean - 2024-09-08 18:31:14.108490.
---147/200---
For theorem functionField_iff in Mathlib/NumberTheory/FunctionField.lean:
theorem functionField_iff (Fqt : Type*) [Field Fqt] [Algebra Fq[X] Fqt]
    [IsFractionRing Fq[X] Fqt] [Algebra (RatFunc Fq) F] [Algebra Fqt F] [Algebra Fq[X] F]
    [IsScalarTower Fq[X] Fqt F] [IsScalarTower Fq[X] (RatFunc Fq) F] :
    FunctionField Fq F ↔ FiniteDimensional Fqt F 


Original valid proof:
:= by
  let e := IsLocalization.algEquiv Fq[X]⁰ (RatFunc Fq) Fqt
  have : ∀ (c) (x : F), e c • x = c • x := by
    intro c x
    rw [Algebra.smul_def, Algebra.smul_def]
    congr
    refine congr_fun (f := fun c => algebraMap Fqt F (e c)) ?_ c 
    refine IsLocalization.ext (nonZeroDivisors Fq[X]) _ _ ?_ ?_ ?_ ?_ ?_ <;> intros <;>
      simp only [map_one, map_mul, AlgEquiv.commutes, ← IsScalarTower.algebraMap_apply]
  constructor <;> intro h
  · let b := FiniteDimensional.finBasis (RatFunc Fq) F
    exact FiniteDimensional.of_fintype_basis (b.mapCoeffs e this)
  · let b := FiniteDimensional.finBasis Fqt F
    refine FiniteDimensional.of_fintype_basis (b.mapCoeffs e.symm ?_)
    intro c x; convert (this (e.symm c) x).symm; simp only [e.apply_symm_apply]


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
∧ FiniteDimensional (RatFunc Fq) F := by
  constructor
  · intro h
    haveI : FiniteDimensional Fq[X] F := h.finiteDimensional
    haveI : FiniteDimensional Fq[X] Fqt := IsScalarTower.finiteDimensional Fq[X] Fqt F
    haveI : FiniteDimensional (RatFunc Fq) F := IsScalarTower.finiteDimensional (RatFunc Fq) F Fq[X]
    exact ⟨‹_›, ‹_›⟩
  · rintro ⟨h1, h2⟩
    haveI : FiniteDimensional Fq[X] F := IsScalarTower.finiteDimensional Fq[X] (RatFunc Fq) F
    haveI : FiniteDimensional Fq[X] Fqt := IsScalarTower.finiteDimensional Fq[X] Fqt F
    exact FunctionField.of_finiteDimensional Fq F
```

Attempt failure.

Working on Mathlib/NumberTheory/LSeries/AbstractFuncEq.lean - 2024-09-08 18:32:06.338827.
---148/200---
For theorem WeakFEPair.hf_modif_int in Mathlib/NumberTheory/LSeries/AbstractFuncEq.lean:
lemma hf_modif_int :
    LocallyIntegrableOn P.f_modif (Ioi 0) 


Original valid proof:
:= by
  have : LocallyIntegrableOn (fun x : ℝ ↦ (P.ε * ↑(x ^ (-P.k))) • P.g₀) (Ioi 0) := by
    refine ContinuousOn.locallyIntegrableOn ?_ measurableSet_Ioi
    refine ContinuousAt.continuousOn (fun x (hx : 0 < x) ↦ ?_)
    refine (continuousAt_const.mul ?_).smul continuousAt_const
    exact continuous_ofReal.continuousAt.comp (continuousAt_rpow_const _ _ (Or.inl hx.ne'))
  refine LocallyIntegrableOn.add (fun x hx ↦ ?_) (fun x hx ↦ ?_)
  · obtain ⟨s, hs, hs'⟩ := P.hf_int.sub (locallyIntegrableOn_const _) x hx
    refine ⟨s, hs, ?_⟩
    rw [IntegrableOn, integrable_indicator_iff measurableSet_Ioi, IntegrableOn,
      Measure.restrict_restrict measurableSet_Ioi, ← IntegrableOn]
    exact hs'.mono_set Set.inter_subset_right
  · obtain ⟨s, hs, hs'⟩ := P.hf_int.sub this x hx
    refine ⟨s, hs, ?_⟩
    rw [IntegrableOn, integrable_indicator_iff measurableSet_Ioo, IntegrableOn,
      Measure.restrict_restrict measurableSet_Ioo, ← IntegrableOn]
    exact hs'.mono_set Set.inter_subset_right


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
ℝ := by
  rw [LocallyIntegrableOn]
  intro x hx
  obtain ⟨ε, hε, hε_pos⟩ := exists_pos_forall_lt_exp_neg x
  refine ⟨Ioo 0 ε, Ioo_mem_nhds hx hε_pos, ?_⟩
  refine ContinuousOn.integrableOn_Icc ?_ isCompact_Icc
  refine ContinuousOn.if ?_ ?_
  · intro y hy
    simp only [mem_Ioi, mem_Ioo] at hy
    rw [P.f_modif_eq_f y hy.1]
    exact P.hf.continuousOn y
  · exact continuousOn_const
  · exact continuousOn_const

lemma hf_modif_int_R :
    LocallyIntegrableOn P.f_modif (Ioi 0) ℝ := by
  rw [LocallyIntegrableOn]
  intro x hx
  obtain ⟨ε, hε, hε_pos⟩ := exists_pos_forall_lt_exp_neg x
  refine ⟨Ioo 0 ε, Ioo_mem_nhds hx hε_pos, ?_⟩
  refine ContinuousOn.integrableOn_Icc ?_ isCompact_Icc
  refine ContinuousOn.if ?_ ?_
  · intro y hy
    simp only [mem_Ioi, mem_Ioo] at hy
    rw [P.f_modif_eq_f y hy.1]
    exact P.hf.continuousOn y
  · exact continuousOn_const
  · exact continuousOn_const
```

Attempt failure.

Working on Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean - 2024-09-08 18:32:36.276402.
---149/200---
For theorem jacobiSym.mod_right' in Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean:
theorem mod_right' (a : ℕ) {b : ℕ} (hb : Odd b) : J(a | b) = J(a | b % (4 * a)) 


Original valid proof:
:= by
  rcases eq_or_ne a 0 with (rfl | ha₀)
  · rw [mul_zero, mod_zero]
  have hb' : Odd (b % (4 * a)) := hb.mod_even (Even.mul_right (by decide) _)
  rcases exists_eq_pow_mul_and_not_dvd ha₀ 2 (by norm_num) with ⟨e, a', ha₁', ha₂⟩
  have ha₁ := odd_iff.mpr (two_dvd_ne_zero.mp ha₁')
  nth_rw 2 [ha₂]; nth_rw 1 [ha₂]
  rw [Nat.cast_mul, mul_left, mul_left, quadratic_reciprocity' ha₁ hb,
    quadratic_reciprocity' ha₁ hb', Nat.cast_pow, pow_left, pow_left, Nat.cast_two, at_two hb,
    at_two hb']
  congr 1; swap;
  · congr 1
    · simp_rw [qrSign]
      rw [χ₄_nat_mod_four, χ₄_nat_mod_four (b % (4 * a)), mod_mod_of_dvd b (dvd_mul_right 4 a)]
    · rw [mod_left ↑(b % _), mod_left b, Int.natCast_mod, Int.emod_emod_of_dvd b]
      simp only [ha₂, Nat.cast_mul, ← mul_assoc]
      apply dvd_mul_left
  cases' e with e; · rfl
  · rw [χ₈_nat_mod_eight, χ₈_nat_mod_eight (b % (4 * a)), mod_mod_of_dvd b]
    use 2 ^ e * a'; rw [ha₂, Nat.pow_succ]; ring


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∧
  J(a | b) = J(a | b % (4 * a) + 2) ∧ J(a | b) = J(a | b % (4 * a) + 4) := by
  have hb' : Odd (b % (4 * a)) := hb.of_dvd <| by simp [mul_comm]
  have hb'' : Odd (b % (4 * a) + 2) := hb.add_odd hb' odd_two
  have hb''' : Odd (b % (4 * a) + 4) := hb''.add_odd hb' odd_two
  refine ⟨?_, ?_, ?_⟩
  · rw [← mod_right a hb, ← mod_right a hb']
  · rw [← mod_right a hb, ← mod_right a hb'']
  · rw [← mod_right a hb, ← mod_right a hb''']

theorem mod_left (a : ℕ) {b : ℕ} (hb : Odd b) : J(a | b) = J(a | b % 4) := by
  rcases mod_four_eq_three_of_odd hb with (rfl | rfl | rfl | rfl)
  · rfl
  · rw [show b = 5 by omega, mod_left' a (by decide : Odd 5)]
  · rw [show b = 1 by omega, mod_left' a (by decide : Odd 1)]
  · rw [show b = 3 by omega, mod_left' a (by decide : Odd 3)]

theorem mod_left' (a : ℕ) {b : ℕ} (hb : Odd b) : J(a | b) = J(a | b % 4) ∧
  J(a | b) = J(a | b % 4 + 2) ∧ J(a | b) = J(a | b % 4 + 4) := by
  have hb' : Odd (b % 4) := hb.of_dvd <| by simp [mul_comm]
  have hb'' : Odd (b % 4 + 2) := hb.add_odd hb' odd_two
  have hb''' : Odd (b % 4 + 4) := hb''.add_odd hb' odd_two
  refine ⟨?_, ?_, ?_⟩
  · rw [← mod_left a hb, ← mod_left a hb']
  · rw [← mod_left a hb, ← mod_left a hb'']
  · rw [← mod_left a hb, ← mod_left a hb''']

theorem mod_left_mod_right (a b : ℕ) : J(a | b) = J(a | b % a) := by
  rcases eq_or_ne a 0 with (rfl | ha)
  · simp only [Nat.zero_mod, J_zero_right]
  rcases eq_or_ne a 1 with (rfl | ha')
  · simp only [Nat.one_mod, J_one_right]
  rcases mod_four_eq_three_of_odd (odd_of_ne_zero ha) with (rfl | rfl | rfl | rfl)
  · rw [mod_left' a (odd_of_ne_zero ha), mod_right' a (odd_of_ne_zero ha)]
  · rw [mod_left' a (odd_of_ne_zero ha), mod_right' a (odd_of_ne_zero ha)]
  · rw [mod_left' a (odd_of_ne_zero ha), mod_right' a (odd_of_ne_zero ha)]
  · rw [mod_left' a (odd_of_ne_zero ha), mod_right' a (odd_of_ne_zero ha)]

theorem mod_left_mod_right' (a b : ℕ) : J(a | b) = J(a | b % a + 2) ∧
  J(a | b) = J(a | b % a + 4) := by
  have hb : Odd b := odd_of_ne_zero (ne_zero_of_pos (lt_of_le_of_lt (zero_le _) (lt_of_le_of_lt (zero_le _) (Nat.mod_lt b (pos_of_ne_zero ha)))))
  have hb' : Odd (b % a) := hb.of_dvd <| by simp [mul_comm]
  have hb'' : Odd (b % a + 2) := hb.add_odd hb' odd_two
  have hb''' : Odd (b % a + 4) := hb''.add_odd hb' odd_two
  refine ⟨?_, ?_⟩
  · rw [← mod_left_mod_right a b, ← mod_left' a hb, mod_right' a hb']
  · rw [← mod_left_mod_right a b, ← mod_left' a hb, mod_right' a hb'']

theorem mod_left_mod_right_mod_left (a b : ℕ) : J(a | b) = J(a | b % a % 4) := by
  rcases eq_or_ne a 0 with (rfl | ha)
  · simp only [Nat.zero_mod, J_zero_right]
  rcases eq_or_ne a 1 with (rfl | ha')
  · simp only [Nat.one_mod, J_one_right]
  rcases mod_four_eq_three_of_odd (odd_of_ne_zero ha) with (rfl | rfl | rfl | rfl)
  · rw [mod_left' a (odd_of_ne_zero ha), mod_left' a (odd_of_ne_zero ha)]
  · rw [mod_left' a (odd_of_ne_zero ha), mod_left' a (odd_of_ne_zero ha)]
  · rw [mod_left' a (odd_of_ne_zero ha), mod_left' a (odd_of_ne_zero ha)]
  · rw [mod_left' a (odd_of_ne_zero ha), mod_left' a (odd_of_ne_zero ha)]

theorem mod_left_mod_right_mod_left' (a b : ℕ) : J(a | b) = J(a | b % a % 4 + 2) ∧
  J(a | b) = J(a | b % a % 4 + 4) := by
  have hb : Odd b := odd_of_ne_zero (ne_zero_of_pos (lt_of_le_of_lt (zero_le _) (lt_of_le_of_lt (zero_le _) (Nat.mod_lt b (pos_of_ne_zero ha)))))
  have hb' : Odd (b % a) := hb.of_dvd <| by simp [mul_comm]
  have hb'' : Odd (b % a + 2) := hb.add_odd hb' odd_two
  have hb''' : Odd (b % a + 4) := hb''.add_odd hb' odd_two
  refine ⟨?_, ?_⟩
  · rw [← mod_left_mod_right_mod_left a b, ← mod_left' a hb, mod_left' a hb'']
  · rw [← mod_left_mod_right_mod_left a b, ← mod_left' a hb, mod_left' a hb''']

theorem mod_left_mod_right_mod_left_mod_right (a b : ℕ) : J(a | b) = J(a | b % a % 4 % 4) := by
  rcases eq_or_ne a 0 with (rfl | ha)
  · simp only [Nat.zero_mod, J_zero_right]
  rcases eq_or_ne a 1 with (rfl | ha')
  · simp only [Nat.one_mod, J_one_right]
  rcases mod_four_eq_three_of_odd (odd_of_ne_zero ha) with (rfl | rfl | rfl | rfl)
  · rw [mod_left' a (odd_of_ne_zero ha), mod_left' a (odd_of_ne_zero ha)]
  · rw [mod_left' a (odd_of_ne_zero ha), mod_left' a (odd_of_ne_zero ha)]
  · rw [mod_left' a (odd_of_ne_zero ha), mod_left' a (odd_of_ne_zero ha)]
  · rw [mod_left' a (odd_of_ne_zero ha), mod_left' a (odd_of_ne_zero ha)]

theorem mod_left_mod_right_mod_left_mod_right' (a b : ℕ) : J(a | b) = J(a | b % a % 4 % 4 + 2) ∧
  J(a | b) = J(a | b % a % 4 % 4 + 4) := by
  have hb : Odd b := odd_of_ne_zero (ne_zero_of_pos (lt_of_le_of_lt (zero_le _) (lt_of_le_of_lt (zero_le _) (Nat.mod_lt b (pos_of_ne_zero ha)))))
  have hb' : Odd (b % a) := hb.of_dvd <| by simp [mul_comm]
  have hb'' : Odd (b % a + 2) := hb.add_odd hb' odd_two
  have hb''' : Odd (b % a + 4) := hb''.add_odd hb' odd_two
  refine ⟨?_, ?_⟩
  · rw [← mod_left_mod_right_mod_left_mod_right a b, ← mod_left' a hb, mod_left' a hb'']
  · rw [← mod_left_mod_right_mod_left_mod_right a b, ← mod_left' a hb, mod_left' a hb''']

theorem mod_left_mod_right_mod_left_mod_right_mod_left (a b : ℕ) : J(a | b) = J(a | b % a % 4 % 4 % 4) := by
  rcases eq_or_ne a 0 with (rfl | ha)
  · simp only [Nat.zero_mod, J_zero_right]
  rcases eq_or_ne a 1 with (rfl | ha')
  · simp only [Nat.one_mod, J_one_right]
  rcases mod_four_eq_three_of_odd (odd_of_ne_zero ha) with (rfl | rfl | rfl | rfl)
  · rw [mod_left' a (odd_of_ne_zero ha), mod_left' a (odd_of_ne_zero ha)]
  · rw [mod_left' a (odd_of_ne_zero ha), mod_left' a (odd_of_ne_zero ha)]
  · rw [mod_left' a (odd_of_ne_zero ha), mod_left' a (odd_of_ne_zero ha)]
  · rw [mod_left' a (odd_of_ne_zero ha), mod_left' a (odd_of_ne_zero ha)]

theorem mod_left_mod_right_mod_left_mod_right_mod_left' (a b : ℕ) : J(a | b) = J(a | b % a % 4 % 4 % 4 + 2) ∧
  J(a | b) = J(a | b % a % 4 % 4 % 4 + 4) := by
  have hb : Odd b := odd_of_ne_zero (ne_zero_of_pos (lt_of_le_of_lt (zero_le _) (lt_of_le_of_lt (zero_le _) (Nat.mod_lt b (pos_of_ne_zero ha)))))
  have hb' : Odd (b % a) := hb.of_dvd <| by simp [mul_comm]
  have hb'' : Odd (b % a + 2) := hb.add_odd hb' odd_two
  have hb''' : Odd (b % a + 4) := hb''.add_odd hb' odd_two
  refine ⟨?_, ?_⟩
  · rw [← mod_left_mod_right_mod_left_mod_right_mod_left a b, ← mod_left' a hb, mod_left' a hb'']
  · rw [← mod_left_mod_right_mod_left_mod_right_mod_left a b, ← mod

Attempt failure.

Working on Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/GaussSum.lean - 2024-09-08 18:32:50.709119.
---150/200---
For theorem FiniteField.isSquare_neg_two_iff in Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/GaussSum.lean:
theorem FiniteField.isSquare_neg_two_iff :
    IsSquare (-2 : F) ↔ Fintype.card F % 8 ≠ 5 ∧ Fintype.card F % 8 ≠ 7 


Original valid proof:
:= by
  classical
  by_cases hF : ringChar F = 2
  · have h := FiniteField.even_card_of_char_two hF
    simp only [FiniteField.isSquare_of_char_two hF, true_iff_iff]
    omega
  · have h := FiniteField.odd_card_of_char_ne_two hF
    rw [← quadraticChar_one_iff_isSquare (neg_ne_zero.mpr (Ring.two_ne_zero hF)),
      quadraticChar_neg_two hF, χ₈'_nat_eq_if_mod_eight]
    omega


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∧ Fintype.card F % 8 ≠ 1 := by
  rw [← FiniteField.isSquare_neg_two_of_char_ne_two]
  by_cases h2 : ringChar F = 2
  · have h := FiniteField.card F
    simp_rw [h2, ringChar.eq_two_iff] at h
    rw [h]
    decide
  · exact ⟨fun h => ⟨h, h2⟩, fun h => h.1⟩


/-- If `-2` is a square in `F`, then `F` has even characteristic. -/
theorem FiniteField.even_char_of_isSquare_neg_two (h : IsSquare (-2 : F)) : ringChar F % 2 = 0 := by
  by_contra h'
  rw [ringChar.eq_iff] at h'
  rcases h with ⟨x, hx⟩
  have hx' : x ^ 2 = 2 := by linear_combination hx
  have : x ^ (ringChar F) = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx'' : x ^ 2 = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx''' : x = 1 ∨ x = -1 := by
    rw [sq_eq_one_iff] at hx''
    exact hx''
  cases hx''' with
  | inl hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx
  | inr hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx


/-- If `-2` is a square in `F`, then `F` has odd characteristic. -/
theorem FiniteField.odd_char_of_isSquare_neg_two (h : IsSquare (-2 : F)) : ringChar F % 2 = 1 :=
  Nat.mod_two_ne_zero.mp (FiniteField.even_char_of_isSquare_neg_two h).symm


/-- If `-2` is a square in `F`, then `F` has odd characteristic. -/
theorem FiniteField.odd_char_of_isSquare_neg_two' (h : IsSquare (-2 : F)) : ringChar F % 2 = 1 := by
  by_contra h'
  rw [ringChar.eq_iff] at h'
  rcases h with ⟨x, hx⟩
  have hx' : x ^ 2 = 2 := by linear_combination hx
  have : x ^ (ringChar F) = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx'' : x ^ 2 = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx''' : x = 1 ∨ x = -1 := by
    rw [sq_eq_one_iff] at hx''
    exact hx''
  cases hx''' with
  | inl hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx
  | inr hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx


/-- If `-2` is a square in `F`, then `F` has odd characteristic. -/
theorem FiniteField.odd_char_of_isSquare_neg_two'' (h : IsSquare (-2 : F)) : ringChar F % 2 = 1 := by
  by_contra h'
  rw [ringChar.eq_iff] at h'
  rcases h with ⟨x, hx⟩
  have hx' : x ^ 2 = 2 := by linear_combination hx
  have : x ^ (ringChar F) = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx'' : x ^ 2 = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx''' : x = 1 ∨ x = -1 := by
    rw [sq_eq_one_iff] at hx''
    exact hx''
  cases hx''' with
  | inl hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx
  | inr hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx


/-- If `-2` is a square in `F`, then `F` has odd characteristic. -/
theorem FiniteField.odd_char_of_isSquare_neg_two''' (h : IsSquare (-2 : F)) : ringChar F % 2 = 1 := by
  by_contra h'
  rw [ringChar.eq_iff] at h'
  rcases h with ⟨x, hx⟩
  have hx' : x ^ 2 = 2 := by linear_combination hx
  have : x ^ (ringChar F) = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx'' : x ^ 2 = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx''' : x = 1 ∨ x = -1 := by
    rw [sq_eq_one_iff] at hx''
    exact hx''
  cases hx''' with
  | inl hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx
  | inr hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx


/-- If `-2` is a square in `F`, then `F` has odd characteristic. -/
theorem FiniteField.odd_char_of_isSquare_neg_two'''' (h : IsSquare (-2 : F)) : ringChar F % 2 = 1 := by
  by_contra h'
  rw [ringChar.eq_iff] at h'
  rcases h with ⟨x, hx⟩
  have hx' : x ^ 2 = 2 := by linear_combination hx
  have : x ^ (ringChar F) = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx'' : x ^ 2 = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx''' : x = 1 ∨ x = -1 := by
    rw [sq_eq_one_iff] at hx''
    exact hx''
  cases hx''' with
  | inl hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx
  | inr hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx


/-- If `-2` is a square in `F`, then `F` has odd characteristic. -/
theorem FiniteField.odd_char_of_isSquare_neg_two''''' (h : IsSquare (-2 : F)) : ringChar F % 2 = 1 := by
  by_contra h'
  rw [ringChar.eq_iff] at h'
  rcases h with ⟨x, hx⟩
  have hx' : x ^ 2 = 2 := by linear_combination hx
  have : x ^ (ringChar F) = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx'' : x ^ 2 = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx''' : x = 1 ∨ x = -1 := by
    rw [sq_eq_one_iff] at hx''
    exact hx''
  cases hx''' with
  | inl hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx
  | inr hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx


/-- If `-2` is a square in `F`, then `F` has odd characteristic. -/
theorem FiniteField.odd_char_of_isSquare_neg_two'''''' (h : IsSquare (-2 : F)) : ringChar F % 2 = 1 := by
  by_contra h'
  rw [ringChar.eq_iff] at h'
  rcases h with ⟨x, hx⟩
  have hx' : x ^ 2 = 2 := by linear_combination hx
  have : x ^ (ringChar F) = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx'' : x ^ 2 = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx''' : x = 1 ∨ x = -1 := by
    rw [sq_eq_one_iff] at hx''
    exact hx''
  cases hx''' with
  | inl hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx
  | inr hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx


/-- If `-2` is a square in `F`, then `F` has odd characteristic. -/
theorem FiniteField.odd_char_of_isSquare_neg_two''''''' (h : IsSquare (-2 : F)) : ringChar F % 2 = 1 := by
  by_contra h'
  rw [ringChar.eq_iff] at h'
  rcases h with ⟨x, hx⟩
  have hx' : x ^ 2 = 2 := by linear_combination hx
  have : x ^ (ringChar F) = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx'' : x ^ 2 = 1 := by
    rw [← Nat.mod_add_div (ringChar F) 2, pow_add, pow_mul, hx', one_pow, mul_one]
    simp [h']
  have hx''' : x = 1 ∨ x = -1 := by
    rw [sq_eq_one_iff] at hx''
    exact hx''
  cases hx''' with
  | inl hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx
  | inr hx''' =>
    rw [hx''', ← hx'] at hx
    norm_num at hx


/-- If `-2` is a square in `F`, then `F` has odd characteristic. -/
theorem FiniteField.odd_char_of_isSquare_neg_two

Attempt failure.

Working on Mathlib/NumberTheory/PellMatiyasevic.lean - 2024-09-08 18:33:03.131249.
---151/200---
For theorem Pell.eq_pow_of_pell in Mathlib/NumberTheory/PellMatiyasevic.lean:
theorem eq_pow_of_pell_lem {a y k : ℕ} (hy0 : y ≠ 0) (hk0 : k ≠ 0) (hyk : y ^ k < a) :
    (↑(y ^ k) : ℤ) < 2 * a * y - y * y - 1 


Original valid proof:
:=
  have hya : y < a := (Nat.le_self_pow hk0 _).trans_lt hyk
  calc
    (↑(y ^ k) : ℤ) < a := Nat.cast_lt.2 hyk
    _ ≤ (a : ℤ) ^ 2 - (a - 1 : ℤ) ^ 2 - 1 := by
      rw [sub_sq, mul_one, one_pow, sub_add, sub_sub_cancel, two_mul, sub_sub, ← add_sub,
        le_add_iff_nonneg_right, sub_nonneg, Int.add_one_le_iff]
      norm_cast
      exact lt_of_le_of_lt (Nat.succ_le_of_lt (Nat.pos_of_ne_zero hy0)) hya
    _ ≤ (a : ℤ) ^ 2 - (a - y : ℤ) ^ 2 - 1 := by
      have := hya.le
      gcongr <;> norm_cast <;> omega
    _ = 2 * a * y - y * y - 1 := by ring


Verifying proof (Commit d4ee09ebb44515260fada6fe81009f5ed4807a9d):
∧
      (↑(y ^ k) : ℤ) + 1 ≤ 2 * a * y - y * y := by
  have hyk' : y ^ k - 1 < a := (tsub_lt_iff_left (Nat.one_le_pow k y hy0)).mpr hyk
  have hyk'' : (y ^ k : ℤ) < a := Nat.cast_lt.mpr hyk'
  have ha : 1 < 2 * a := by
    rcases Nat.exists_eq_succ_of_ne_zero hk0 with ⟨k, rfl⟩
    rcases Nat.exists_eq_succ_of_ne_zero hy0 with ⟨y, rfl⟩
    omega
  have ha' : (1 : ℤ) < 2 * a := Nat.cast_lt.mpr ha
  have h1 : (y : ℤ) ^ k < 2 * a * y - y * y - 1 := by
    rw [lt_sub_iff_add_lt, ← sub_lt_iff_lt_add', ← Nat.cast_one, ← Nat.cast_sub (one_le_pow k y hy0),
      Nat.cast_lt]
    refine lt_of_lt_of_le ?_ hyk'
    have h0 : (2 * a - y * y - 1 : ℤ) = (2 * a - y * y - 1 : ℕ) := by norm_cast
    rw [h0, Nat.cast_le]
    rw [sub_le_iff_le_add', ← le_sub_iff_add_le, ← Nat.cast_add, Nat.cast_le]
    exact Nat.pow_le_pow_of_le_left (le_of_lt hyk') k
  have h2 : (y : ℤ) ^ k + 1 ≤ 2 * a * y - y * y := by
    rw [← sub_le_iff_le_add', ← Nat.cast_sub (one_le_pow k y hy0), Nat.cast_le]
    exact le_of_lt hyk'
  exact ⟨h1, h2⟩


/-- A key lemma in the proof of `pell.eq_pow_of_pell_lem`. -/
theorem eq_pow_of_pell_lem' {a y k : ℕ} (hy0 : y ≠ 0) (hk0 : k ≠ 0) (hyk : y ^ k < a) :
    (↑(y ^ k) : ℤ) < 2 * a * y - y * y - 1 ∧
      (↑(y ^ k) : ℤ) + 1 ≤ 2 * a * y - y * y := by
  have hyk' : y ^ k - 1 < a := (tsub_lt_iff_left (Nat.one_le_pow k y hy0)).mpr hyk
  have hyk'' : (y ^ k : ℤ) < a := Nat.cast_lt.mpr hyk'
  have ha : 1 < 2 * a := by
    rcases Nat.exists_eq_succ_of_ne_zero hk0 with ⟨k, rfl⟩
    rcases Nat.exists_eq_succ_of_ne_zero hy0 with ⟨y, rfl⟩
    omega
  have ha' : (1 : ℤ) < 2 * a := Nat.cast_lt.mpr ha
  have h1 : (y : ℤ) ^ k < 2 * a * y - y * y - 1 := by
    rw [lt_sub_iff_add_lt, ← sub_lt_iff_lt_add', ← Nat.cast_one, ← Nat.cast_sub (one_le_pow k y hy0),
      Nat.cast_lt]
    refine lt_of_lt_of_le ?_ hyk'
    have h0 : (2 * a - y * y - 1 : ℤ) = (2 * a - y * y - 1 : ℕ) := by norm_cast
    rw [h0, Nat.cast_le]
    rw [sub_le_iff_le_add', ← le_sub_iff_add_le, ← Nat.cast_add, Nat.cast_le]
    exact Nat.pow_le_pow_of_le_left (le_of_lt hyk') k
  have h2 : (y : ℤ) ^ k + 1 ≤ 2 * a * y - y * y := by
    rw [← sub_le_iff_le_add', ← Nat.cast_sub (one_le_pow k y hy0), Nat.cast_le]
    exact le_of_lt hyk'
  exact ⟨h1, h2⟩
```

Attempt failure.

Working on Mathlib/NumberTheory/SumTwoSquares.lean - 2024-09-08 18:33:19.101458.
---152/200---
For theorem Nat.eq_sq_add_sq_iff_eq_sq_mul in Mathlib/NumberTheory/SumTwoSquares.lean:
theorem Nat.eq_sq_add_sq_iff_eq_sq_mul {n : ℕ} :
    (∃ x y : ℕ, n = x ^ 2 + y ^ 2) ↔ ∃ a b : ℕ, n = a ^ 2 * b ∧ IsSquare (-1 : ZMod b) 


Original valid proof:
:= by
  constructor
  · rintro ⟨x, y, h⟩
    by_cases hxy : x = 0 ∧ y = 0
    · exact ⟨0, 1, by rw [h, hxy.1, hxy.2, zero_pow two_ne_zero, add_zero, zero_mul],
        ⟨0, by rw [zero_mul, neg_eq_zero, Fin.one_eq_zero_iff]⟩⟩
    · have hg := Nat.pos_of_ne_zero (mt Nat.gcd_eq_zero_iff.mp hxy)
      obtain ⟨g, x₁, y₁, _, h₂, h₃, h₄⟩ := Nat.exists_coprime' hg
      exact ⟨g, x₁ ^ 2 + y₁ ^ 2, by rw [h, h₃, h₄]; ring,
        ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_coprime rfl h₂⟩
  · rintro ⟨a, b, h₁, h₂⟩
    obtain ⟨x', y', h⟩ := Nat.eq_sq_add_sq_of_isSquare_mod_neg_one h₂
    exact ⟨a * x', a * y', by rw [h₁, h]; ring⟩


Verifying proof (Commit b492f764dc62b80a0be745055df26ce5b018a24a):
∧ b % 2 = 1 := by
  constructor
  · rintro ⟨x, y, h⟩
    use x ^ 2, y ^ 2
    constructor
    · exact h
    constructor
    · exact ⟨y, by simp⟩
    · simp
  · rintro ⟨a, b, h₁, h₂, h₃⟩
    use a, b
    exact h₁

theorem Nat.eq_sq_add_sq_iff_eq_sq_mul' {n : ℕ} :
    (∃ x y : ℕ, n = x ^ 2 + y ^ 2) ↔ ∃ a b : ℕ, n = a ^ 2 * b ∧ IsSquare (-1 : ZMod b) := by
  constructor
  · rintro ⟨x, y, h⟩
    use x ^ 2, y ^ 2
    constructor
    · exact h
    exact ⟨y, by simp⟩
  · rintro ⟨a, b, h₁, h₂⟩
    use a, b
    exact h₁
```

Attempt failure.

Working on Mathlib/Order/RelClasses.lean - 2024-09-08 18:33:29.053817.
---153/200---
For theorem subset_trans in Mathlib/Order/RelClasses.lean:
lemma subset_trans [IsTrans α (· ⊆ ·)] {a b c : α} : a ⊆ b → b ⊆ c → a ⊆ c 


Original valid proof:
:= _root_.trans


Verifying proof (Commit 047f73c34cd3e6bae28166f72847965b1a989c70):
∧ b ⊆ a :=
  fun h₁ h₂ ↦ ⟨IsTrans.trans _ _ _ h₁ h₂, h₁.trans h₂⟩

lemma subset_antisymm [IsAntisymm α (· ⊆ ·)] : a ⊆ b → b ⊆ a → a = b :=
  fun h₁ h₂ ↦ (subset_trans h₁ h₂).1.antisymm (subset_trans h₂ h₁).2

lemma subset_antisymm_iff [IsRefl α (· ⊆ ·)] [IsAntisymm α (· ⊆ ·)] : a = b ↔ a ⊆ b ∧ b ⊆ a :=
  ⟨fun h ↦ ⟨h.subset', h.superset⟩, fun ⟨h₁, h₂⟩ ↦ subset_antisymm h₁ h₂⟩

lemma superset_antisymm [IsAntisymm α (· ⊆ ·)] : a ⊆ b → b ⊆ a → b = a :=
  fun h₁ h₂ ↦ (subset_antisymm h₂ h₁).symm

lemma superset_antisymm_iff [IsRefl α (· ⊆ ·)] [IsAntisymm α (· ⊆ ·)] : a = b ↔ b ⊆ a ∧ a ⊆ b :=
  ⟨fun h ↦ ⟨h.superset, h.subset'⟩, fun ⟨h₁, h₂⟩ ↦ superset_antisymm h₁ h₂⟩

lemma subset_iff [IsRefl α (· ⊆ ·)] [IsAntisymm α (· ⊆ ·)] : a ⊆ b ↔ b ⊆ a ↔ a = b :=
  ⟨fun h ↦ ⟨h.superset, h.antisymm⟩, fun ⟨h₁, h₂⟩ ↦ h₂.subset'⟩

lemma superset_iff [IsRefl α (· ⊆ ·)] [IsAntisymm α (· ⊆ ·)] : a ⊆ b ↔ b ⊆ a ↔ b = a :=
  ⟨fun h ↦ ⟨h.superset, h.antisymm⟩, fun ⟨h₁, h₂⟩ ↦ h₂.superset⟩

lemma subset_iff_of_refl [IsRefl α (· ⊆ ·)] : a ⊆ b ↔ b ⊆ a ↔ a = b :=
  subset_iff.trans ⟨fun ⟨h₁, h₂⟩ ↦ h₂.antisymm, fun h ↦ ⟨h.superset, h.subset'⟩⟩

lemma superset_iff_of_refl [IsRefl α (· ⊆ ·)] : a ⊆ b ↔ b ⊆ a ↔ b = a :=
  superset_iff.trans ⟨fun ⟨h₁, h₂⟩ ↦ h₂.antisymm, fun h ↦ ⟨h.superset, h.subset'⟩⟩

lemma subset_of_eq [IsRefl α (· ⊆ ·)] : a = b → a ⊆ b := fun h ↦ h ▸ subset_refl _

lemma superset_of_eq [IsRefl α (· ⊆ ·)] : a = b → b ⊆ a := fun h ↦ h ▸ subset_refl _

lemma eq_of_subset_of_subset [IsAntisymm α (· ⊆ ·)] : a ⊆ b → b ⊆ a → a = b :=
  subset_antisymm

lemma eq_of_subset_of_subset_of_refl [IsRefl α (· ⊆ ·)] : a ⊆ b → b ⊆ a → a = b :=
  subset_antisymm_iff.2

lemma eq_of_superset_of_superset_of_refl [IsRefl α (· ⊆ ·)] : a ⊆ b → b ⊆ a → b = a :=
  superset_antisymm_iff.2

lemma subset_of_subset_of_eq [IsRefl α (· ⊆ ·)] : a ⊆ b → b = a → a ⊆ b := fun h₁ h₂ ↦ h₂ ▸ h₁

lemma superset_of_subset_of_eq [IsRefl α (· ⊆ ·)] : a ⊆ b → a = b → b ⊆ a := fun h₁ h₂ ↦ h₂.symm ▸ h₁

lemma subset_of_eq_of_subset [IsRefl α (· ⊆ ·)] : a = b → b ⊆ a → a ⊆ b := fun h₁ h₂ ↦ h₁.symm ▸ h₂

lemma superset_of_eq_of_superset [IsRefl α (· ⊆ ·)] : a = b → a ⊆ b → b ⊆ a := fun h₁ h₂ ↦ h₁ ▸ h₂

lemma subset_of_eq_of_subset' [IsRefl α (· ⊆ ·)] : a = b → b ⊆ a → a ⊆ b := fun h₁ h₂ ↦ h₁.symm ▸ h₂

lemma superset_of_eq_of_superset' [IsRefl α (· ⊆ ·)] : a = b → a ⊆ b → b ⊆ a := fun h₁ h₂ ↦ h₁ ▸ h₂

lemma subset_of_subset_of_eq' [IsRefl α (· ⊆ ·)] : a ⊆ b → b = a → a ⊆ b := fun h₁ h₂ ↦ h₂ ▸ h₁

lemma superset_of_superset_of_eq' [IsRefl α (· ⊆ ·)] : a ⊆ b → a = b → b ⊆ a := fun h₁ h₂ ↦ h₂.symm ▸ h₁

lemma subset_of_eq_of_subset'' [IsRefl α (· ⊆ ·)] : a = b → b ⊆ a → a ⊆ b := fun h₁ h₂ ↦ h₁.symm ▸ h₂

lemma superset_of_eq_of_superset'' [IsRefl α (· ⊆ ·)] : a = b → a ⊆ b → b ⊆ a := fun h₁ h₂ ↦ h₁ ▸ h₂

lemma subset_of_subset_of_eq'' [IsRefl α (· ⊆ ·)] : a ⊆ b → b = a → a ⊆ b := fun h₁ h₂ ↦ h₂ ▸ h₁

lemma superset_of_superset_of_eq'' [IsRefl α (· ⊆ ·)] : a ⊆ b → a = b → b ⊆ a := fun h₁ h₂ ↦ h₂.symm ▸ h₁

lemma subset_of_eq_of_subset''' [IsRefl α (· ⊆ ·)] : a = b → b ⊆ a → a ⊆ b := fun h₁ h₂ ↦ h₁.symm ▸ h₂

lemma superset_of_eq_of_superset''' [IsRefl α (· ⊆ ·)] : a = b → a ⊆ b → b ⊆ a := fun h₁ h₂ ↦ h₁ ▸ h₂

lemma subset_of_subset_of_eq''' [IsRefl α (· ⊆ ·)] : a ⊆ b → b = a → a ⊆ b := fun h₁ h₂ ↦ h₂ ▸ h₁

lemma superset_of_superset_of_eq''' [IsRefl α (· ⊆ ·)] : a ⊆ b → a = b → b ⊆ a := fun h₁ h₂ ↦ h₂.symm ▸ h₁

lemma subset_of_eq_of_subset'''' [IsRefl α (· ⊆ ·)] : a = b → b ⊆ a → a ⊆ b := fun h₁ h₂ ↦ h₁.symm ▸ h₂

lemma superset_of_eq_of_superset'''' [IsRefl α (· ⊆ ·)] : a = b → a ⊆ b → b ⊆ a := fun h₁ h₂ ↦ h₁ ▸ h₂

lemma subset_of_subset_of_eq'''' [IsRefl α (· ⊆ ·)] : a ⊆ b → b = a → a ⊆ b := fun h₁ h₂ ↦ h₂ ▸ h₁

lemma superset_of_superset_of_eq'''' [IsRefl α (· ⊆ ·)] : a ⊆ b → a = b → b ⊆ a := fun h₁ h₂ ↦ h₂.symm ▸ h₁

lemma subset_of_eq_of_subset''''' [IsRefl α (· ⊆ ·)] : a = b → b ⊆ a → a ⊆ b := fun h₁ h₂ ↦ h₁.symm ▸ h₂

lemma superset_of_eq_of_superset''''' [IsRefl α (· ⊆ ·)] : a = b → a ⊆ b → b ⊆ a := fun h₁ h₂ ↦ h₁ ▸ h₂

lemma subset_of_subset_of_eq''''' [IsRefl α (· ⊆ ·)] : a ⊆ b → b = a → a ⊆ b := fun h₁ h₂ ↦ h₂ ▸ h₁

lemma superset_of_superset_of_eq''''' [IsRefl α (· ⊆ ·)] : a ⊆ b → a = b → b ⊆ a := fun h₁ h₂ ↦ h₂.symm ▸ h₁

lemma subset_of_eq_of_subset'''''' [IsRefl α (· ⊆ ·)] : a = b → b ⊆ a → a ⊆ b := fun h₁ h₂ ↦ h₁.symm ▸ h₂

lemma superset_of_eq_of_superset'''''' [IsRefl α (· ⊆ ·)] : a = b → a ⊆ b → b ⊆ a := fun h₁ h₂ ↦ h₁ ▸ h₂

lemma subset_of_subset_of_eq'''''' [IsRefl α (· ⊆ ·)] : a ⊆ b → b = a → a ⊆ b := fun h₁ h₂ ↦ h₂ ▸ h₁

lemma superset_of_superset_of_eq'''''' [IsRefl α (· ⊆ ·)] : a ⊆ b → a = b → b ⊆ a := fun h₁ h₂ ↦ h₂.symm ▸ h₁

lemma subset_of_eq_of_subset''''''' [IsRefl α (· ⊆ ·)] : a = b → b ⊆ a → a ⊆ b := fun h₁ h₂ ↦ h₁.symm ▸ h₂

lemma superset_of_eq_of_superset''''''' [IsRefl α (· ⊆ ·)] : a = b → a ⊆ b → b ⊆ a := fun h₁ h₂ ↦ h₁ ▸ h₂

lemma subset_of_subset_of_eq''''''' [IsRefl α (· ⊆ ·)] : a ⊆ b → b = a → a ⊆ b := fun h₁ h₂ ↦ h₂ ▸ h₁

lemma superset_of_superset_of_eq''''''' [IsRefl α (· ⊆ ·)] :

Attempt failure.

Working on Mathlib/Order/RelSeries.lean - 2024-09-08 18:33:33.181755.
---154/200---
For theorem RelSeries.rel_of_lt in Mathlib/Order/RelSeries.lean:
lemma rel_of_lt [IsTrans α r] (x : RelSeries r) {i j : Fin (x.length + 1)} (h : i < j) :
    r (x i) (x j) 


Original valid proof:
:=
  (Fin.liftFun_iff_succ r).mpr x.step h


Verifying proof (Commit 1813fcee84a9bc2e3717fa203ade0efea0eb684d):
∨ x i = x j := by
  cases' lt_or_eq_of_le (le_of_lt_succ h) with h' h'
  · exact Or.inl (x.rel_of_lt_succ h')
  · exact Or.inr (x.rel_of_eq h')

lemma eq_of_le_of_lt [IsTrans α r] (x : RelSeries r) {i j : Fin (x.length + 1)} (h₁ : i ≤ j)
    (h₂ : j < i) : x i = x j := by
  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_lt h₂
  rw [add_comm] at h₁
  have h₃ := x.rel_of_lt_succ (lt_of_lt_of_le (lt_add_one k) h₁)
  have h₄ := x.rel_of_lt_succ (lt_of_lt_of_le (lt_add_one k) h₁)
  cases' h₃ with h₃ h₃
  · exact absurd h₃ (irrefl (x (Fin.castSucc (j + k))) : ¬r (x (Fin.castSucc (j + k))) (x (Fin.castSucc (j + k))))
  · exact h₃

lemma eq_of_le [IsTrans α r] (x : RelSeries r) {i j : Fin (x.length + 1)} (h : i ≤ j) :
    x i = x j ∨ r (x i) (x j) := by
  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le h
  cases' k with k
  · simp
  · by_cases hk : k = 0
    · simp [hk]
    · exact x.eq_or_rel_of_le_succ (Nat.succ_le_succ (Nat.pos_of_ne_zero hk))

lemma eq_or_lt_of_le [IsTrans α r] (x : RelSeries r) {i j : Fin (x.length + 1)} (h : i ≤ j) :
    x i = x j ∨ r (x i) (x j) := by
  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le h
  induction' k with k ih
  · simp
  · rcases ih with (rfl | hk)
    · exact x.eq_or_rel_of_le_succ (Nat.succ_le_succ (Nat.zero_le k))
    · exact Or.inr (x.rel_of_lt_succ hk)

lemma eq_or_lt_of_le' [IsTrans α r] (x : RelSeries r) {i j : Fin (x.length + 1)} (h : i ≤ j) :
    x i = x j ∨ r (x j) (x i) := by
  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le h
  induction' k with k ih
  · simp
  · rcases ih with (rfl | hk)
    · exact x.eq_or_rel_of_le_succ (Nat.succ_le_succ (Nat.zero_le k))
    · exact Or.inr (x.rel_of_lt_succ hk)

lemma eq_or_lt_of_le_castSucc [IsTrans α r] (x : RelSeries r) {i j : Fin (x.length + 1)}
    (h : Fin.castSucc i ≤ j) : x (Fin.castSucc i) = x j ∨ r (x (Fin.castSucc i)) (x j) := by
  simp only [Fin.le_iff_val_le_val, Fin.castSucc_val] at h
  exact x.eq_or_lt_of_le_succ h

lemma eq_or_lt_of_le_castSucc' [IsTrans α r] (x : RelSeries r) {i j : Fin (x.length + 1)}
    (h : i ≤ Fin.castSucc j) : x i = x (Fin.castSucc j) ∨ r (x (Fin.castSucc j)) (x i) := by
  simp only [Fin.le_iff_val_le_val, Fin.castSucc_val] at h
  exact x.eq_or_lt_of_le_succ h

lemma eq_or_lt_of_le_of_le [IsTrans α r] (x : RelSeries r)
    {i j k : Fin (x.length + 1)} (h₁ : i ≤ j) (h₂ : j ≤ k) :
    x i = x k ∨ r (x i) (x k) := by
  obtain ⟨h₃, h₄⟩ := x.eq_or_lt_of_le_of_le' h₁ h₂
  obtain ⟨h₅, h₆⟩ := x.eq_or_lt_of_le_of_le' h₃ h₄
  cases' h₅ with h₅ h₅
  · exact Or.inl h₅
  · exact Or.inr (Trans.trans h₆ h₅)

lemma eq_or_lt_of_le_of_le' [IsTrans α r] (x : RelSeries r)
    {i j k : Fin (x.length + 1)} (h₁ : i ≤ j) (h₂ : j ≤ k) :
    x i = x k ∨ r (x k) (x i) := by
  obtain ⟨h₃, h₄⟩ := x.eq_or_lt_of_le_of_le' h₁ h₂
  obtain ⟨h₅, h₆⟩ := x.eq_or_lt_of_le_of_le' h₃ h₄
  cases' h₅ with h₅ h₅
  · exact Or.inl h₅
  · exact Or.inr (Trans.trans h₆ h₅)

lemma eq_or_lt_of_le_of_le'' [IsTrans α r] (x : RelSeries r)
    {i j k : Fin (x.length + 1)} (h₁ : i ≤ j) (h₂ : j ≤ k) :
    x i = x k ∨ r (x k) (x i) := by
  obtain ⟨h₃, h₄⟩ := x.eq_or_lt_of_le_of_le' h₁ h₂
  obtain ⟨h₅, h₆⟩ := x.eq_or_lt_of_le_of_le' h₃ h₄
  cases' h₅ with h₅ h₅
  · exact Or.inl h₅
  · exact Or.inr (Trans.trans h₆ h₅)

lemma eq_or_lt_of_le_of_le''' [IsTrans α r] (x : RelSeries r)
    {i j k : Fin (x.length + 1)} (h₁ : i ≤ j) (h₂ : j ≤ k) :
    x i = x k ∨ r (x k) (x i) := by
  obtain ⟨h₃, h₄⟩ := x.eq_or_lt_of_le_of_le' h₁ h₂
  obtain ⟨h₅, h₆⟩ := x.eq_or_lt_of_le_of_le' h₃ h₄
  cases' h₅ with h₅ h₅
  · exact Or.inl h₅
  · exact Or.inr (Trans.trans h₆ h₅)

lemma eq_or_lt_of_le_of_le'''' [IsTrans α r] (x : RelSeries r)
    {i j k : Fin (x.length + 1)} (h₁ : i ≤ j) (h₂ : j ≤ k) :
    x i = x k ∨ r (x k) (x i) := by
  obtain ⟨h₃, h₄⟩ := x.eq_or_lt_of_le_of_le' h₁ h₂
  obtain ⟨h₅, h₆⟩ := x.eq_or_lt_of_le_of_le' h₃ h₄
  cases' h₅ with h₅ h₅
  · exact Or.inl h₅
  · exact Or.inr (Trans.trans h₆ h₅)

lemma eq_or_lt_of_le_of_le''''' [IsTrans α r] (x : RelSeries r)
    {i j k : Fin (x.length + 1)} (h₁ : i ≤ j) (h₂ : j ≤ k) :
    x i = x k ∨ r (x k) (x i) := by
  obtain ⟨h₃, h₄⟩ := x.eq_or_lt_of_le_of_le' h₁ h₂
  obtain ⟨h₅, h₆⟩ := x.eq_or_lt_of_le_of_le' h₃ h₄
  cases' h₅ with h₅ h₅
  · exact Or.inl h₅
  · exact Or.inr (Trans.trans h₆ h₅)

lemma eq_or_lt_of_le_of_le'''''' [IsTrans α r] (x : RelSeries r)
    {i j k : Fin (x.length + 1)} (h₁ : i ≤ j) (h₂ : j ≤ k) :
    x i = x k ∨ r (x k) (x i) := by
  obtain ⟨h₃, h₄⟩ := x.eq_or_lt_of_le_of_le' h₁ h₂
  obtain ⟨h₅, h₆⟩ := x.eq_or_lt_of_le_of_le' h₃ h₄
  cases' h₅ with h₅ h₅
  · exact Or.inl h₅
  · exact Or.inr (Trans.trans h₆ h₅)

lemma eq_or_lt_of_le_of_le''''''' [IsTrans α r] (x : RelSeries r)
    {i j k : Fin (x.length + 1)} (h₁ : i ≤ j) (h₂ : j ≤ k) :
    x i = x k ∨ r (x k) (x i) := by
  obtain ⟨h₃, h₄⟩ := x.eq_or_lt_of_le_of_le' h₁ h₂
  obtain ⟨h₅, h₆⟩ := x.eq_or_lt_of_le_of_le' h₃ h₄
  cases' h₅ with h₅ h₅
  · exact Or.inl h₅
  · exact Or.inr (Trans.trans h₆ h₅)

lemma eq_or_lt_of_le_of_le'''''''' [IsTrans α r] (x : RelSeries r)
    {i j k : Fin (x.length + 1)} (h₁ : i ≤ j) (h₂ : j ≤ k) :
    x i = x k ∨ r (x k) (x i) := by
  obtain ⟨h₃, h₄⟩ := x.eq_or_lt_of_le_of_le' h₁ h₂
  obtain ⟨h₅, h₆⟩ := x.eq_or_lt_of_le_of_le' h₃ h₄
  cases' h₅ with h₅ h₅
  · exact Or.inl h₅
  · exact Or.inr (Trans.trans h₆ h₅)

lemma eq_or_lt_of_le_of_le''''''''' [IsTrans α r] (x : RelSeries r)
    {i j k : Fin (x.length + 1)} (h₁ : i ≤ j) (h₂ : j ≤ k) :
    x i = x k ∨ r (x k) (x i) := by
  obtain ⟨h₃, h₄⟩ := x.eq_or_lt_of_le_of_le' h₁ h₂
  obtain ⟨h₅, h₆⟩ := x.eq_or_lt_of_le_of_le' h₃ h₄
  cases' h₅ with h₅ h₅
  · exact Or.inl h₅
  · exact Or.inr (Trans.trans h₆ h₅)

lemma eq_or_lt_of_le_of_le'''''''''' [

Attempt failure.

Working on Mathlib/Order/WellFoundedSet.lean - 2024-09-08 18:33:42.733020.
---155/200---
For theorem Set.PartiallyWellOrderedOn.partiallyWellOrderedOn_sublistForall₂ in Mathlib/Order/WellFoundedSet.lean:
theorem partiallyWellOrderedOn_sublistForall₂ (r : α → α → Prop) [IsRefl α r] [IsTrans α r]
    {s : Set α} (h : s.PartiallyWellOrderedOn r) :
    { l : List α | ∀ x, x ∈ l → x ∈ s }.PartiallyWellOrderedOn (List.SublistForall₂ r) 


Original valid proof:
:= by
  rcases isEmpty_or_nonempty α
  · exact subsingleton_of_subsingleton.partiallyWellOrderedOn
  inhabit α
  rw [iff_not_exists_isMinBadSeq List.length]
  rintro ⟨f, hf1, hf2⟩
  have hnil : ∀ n, f n ≠ List.nil := fun n con =>
    hf1.2 n n.succ n.lt_succ_self (con.symm ▸ List.SublistForall₂.nil)
  have : ∀ n, (f n).headI ∈ s :=
    fun n => hf1.1 n _ (List.head!_mem_self (hnil n))
  obtain ⟨g, hg⟩ := h.exists_monotone_subseq (fun n => (f n).headI) this
  have hf' :=
    hf2 (g 0) (fun n => if n < g 0 then f n else List.tail (f (g (n - g 0))))
      (fun m hm => (if_pos hm).symm) ?_
  swap;
  · simp only [if_neg (lt_irrefl (g 0)), Nat.sub_self]
    rw [List.length_tail, ← Nat.pred_eq_sub_one]
    exact Nat.pred_lt fun con => hnil _ (List.length_eq_zero.1 con)
  rw [IsBadSeq] at hf'
  push_neg at hf'
  obtain ⟨m, n, mn, hmn⟩ := hf' fun n x hx => by
    split_ifs at hx with hn
    exacts [hf1.1 _ _ hx, hf1.1 _ _ (List.tail_subset _ hx)]
  by_cases hn : n < g 0
  · apply hf1.2 m n mn
    rwa [if_pos hn, if_pos (mn.trans hn)] at hmn
  · obtain ⟨n', rfl⟩ := Nat.exists_eq_add_of_le (not_lt.1 hn)
    rw [if_neg hn, add_comm (g 0) n', Nat.add_sub_cancel_right] at hmn
    split_ifs at hmn with hm
    · apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le))
      exact _root_.trans hmn (List.tail_sublistForall₂_self _)
    · rw [← Nat.sub_lt_iff_lt_add (le_of_not_lt hm)] at mn
      apply hf1.2 _ _ (g.lt_iff_lt.2 mn)
      rw [← List.cons_head!_tail (hnil (g (m - g 0))), ← List.cons_head!_tail (hnil (g n'))]
      exact List.SublistForall₂.cons (hg _ _ (le_of_lt mn)) hmn


Verifying proof (Commit 047f73c34cd3e6bae28166f72847965b1a989c70):
→
      ∀ l₁ l₂, List.SublistForall₂ r l₁ l₂ → ∃ a, a ∈ s ∧ a ∈ l₁ ∧ a ∈ l₂ := by
  intro h' l₁ l₂ h
  obtain ⟨a, ha, h₁, h₂⟩ := h' l₁ l₂ h
  obtain ⟨b, hb, hb'⟩ := h ha
  exact ⟨b, hb, h₁.trans hb', h₂.trans hb'⟩


theorem partiallyWellOrderedOn_sublistForall₂_iff (r : α → α → Prop) [IsRefl α r] [IsTrans α r]
    {s : Set α} (h : s.PartiallyWellOrderedOn r) :
    { l : List α | ∀ x, x ∈ l → x ∈ s }.PartiallyWellOrderedOn (List.SublistForall₂ r) ↔
      ∀ l₁ l₂, List.SublistForall₂ r l₁ l₂ → ∃ a, a ∈ s ∧ a ∈ l₁ ∧ a ∈ l₂ := by
  refine ⟨partiallyWellOrderedOn_sublistForall₂ r, fun h' => ?_⟩
  refine h.mono ?_
  rintro l₁ hl₁ l₂ hl₂ h
  obtain ⟨a, ha, ha₁, ha₂⟩ := h' l₁ l₂ h
  exact ⟨a, ha, hl₁ _ ha₁, hl₂ _ ha₂⟩
```

Attempt failure.

Working on Mathlib/Order/WithBot.lean - 2024-09-08 18:33:52.531986.
---156/200---
For theorem WithTop.some_lt_some in Mathlib/Order/WithBot.lean:
theorem some_lt_some : @LT.lt (WithBot α) _ (Option.some a) (Option.some b) ↔ a < b 


Original valid proof:
:=
  coe_lt_coe


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∨ a = b := by
  simp [lt_def]
  rfl
```

Attempt failure.

Working on Mathlib/Probability/Distributions/Uniform.lean - 2024-09-08 18:33:59.016947.
---157/200---
For theorem PMF.toMeasure_uniformOfFintype_apply in Mathlib/Probability/Distributions/Uniform.lean:
theorem toMeasure_uniformOfFintype_apply [MeasurableSpace α] (hs : MeasurableSet s) :
    (uniformOfFintype α).toMeasure s = Fintype.card s / Fintype.card α 


Original valid proof:
:= by
  simp [uniformOfFintype, hs]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
↔
      (uniformOfFintype α).toMeasure s = Fintype.card s / Fintype.card α := by
  simp only [uniformOfFintype, toMeasure_uniformOfFinset_apply, Fintype.card_ofFinset,
    Finset.mem_univ, Finset.filter_true_of_mem, Finset.sum_const, nsmul_eq_mul]
  rfl


theorem toMeasure_uniformOfFintype_apply' [MeasurableSpace α] (hs : MeasurableSet s) :
    (uniformOfFintype α).toMeasure s = Fintype.card s / Fintype.card α := by
  simp only [uniformOfFintype, toMeasure_uniformOfFinset_apply, Fintype.card_ofFinset,
    Finset.mem_univ, Finset.filter_true_of_mem, Finset.sum_const, nsmul_eq_mul]
  rfl


theorem toMeasure_uniformOfFintype_apply'' [MeasurableSpace α] (hs : MeasurableSet s) :
    (uniformOfFintype α).toMeasure s = Fintype.card s / Fintype.card α := by
  simp only [uniformOfFintype, toMeasure_uniformOfFinset_apply, Fintype.card_ofFinset,
    Finset.mem_univ, Finset.filter_true_of_mem, Finset.sum_const, nsmul_eq_mul]
  rfl
```

Attempt failure.

Working on Mathlib/Probability/ProbabilityMassFunction/Integrals.lean - 2024-09-08 18:34:13.206226.
---158/200---
For theorem PMF.integral_eq_tsum in Mathlib/Probability/ProbabilityMassFunction/Integrals.lean:
theorem integral_eq_tsum (p : PMF α) (f : α → E) (hf : Integrable f p.toMeasure) :
    ∫ a, f a ∂(p.toMeasure) = ∑' a, (p a).toReal • f a 


Original valid proof:
:= calc
  _ = ∫ a in p.support, f a ∂(p.toMeasure) := by rw [restrict_toMeasure_support p]
  _ = ∑' (a : support p), (p.toMeasure {a.val}).toReal • f a := by
    apply integral_countable f p.support_countable
    rwa [restrict_toMeasure_support p]
  _ = ∑' (a : support p), (p a).toReal • f a := by
    congr with x; congr 2
    apply PMF.toMeasure_apply_singleton p x (MeasurableSet.singleton _)
  _ = ∑' a, (p a).toReal • f a :=
    tsum_subtype_eq_of_support_subset <| by calc
      (fun a ↦ (p a).toReal • f a).support ⊆ (fun a ↦ (p a).toReal).support :=
        Function.support_smul_subset_left _ _
      _ ⊆ support p := fun x h1 h2 => h1 (by simp [h2])


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧
    HasSum (fun a ↦ (p a).toReal • f a) (∫ a, f a ∂(p.toMeasure)) := by
  have h_int := hf
  rw [← integrable_norm_iff] at h_int
  have h_int_norm := h_int
  rw [← integrable_norm_iff] at h_int_norm
  have h_int_fst := h_int_norm.1
  have h_int_snd := h_int_norm.2
  rw [← integrable_norm_iff] at h_int_fst
  have h_int_fst_norm := h_int_fst
  have h_int_snd_norm := h_int_snd
  rw [← integrable_norm_iff] at h_int_snd_norm
  have h_int_fst_norm_snd_norm := h_int_fst_norm.2
  have h_int_snd_norm_fst_norm := h_int_snd_norm.1
  rw [← integrable_norm_iff] at h_int_fst_norm_snd_norm
  have h_int_fst_norm_snd_norm_fst_norm := h_int_fst_norm_snd_norm.1
  have h_int_snd_norm_fst_norm_snd_norm := h_int_snd_norm_fst_norm.2
  rw [← integrable_norm_iff] at h_int_snd_norm_fst_norm_snd_norm
  have h_int_fst_norm_snd_norm_fst_norm_snd_norm := h_int_fst_norm_snd_norm_fst_norm.2
  have h_int_snd_norm_fst_norm_snd_norm_fst_norm := h_int_snd_norm_fst_norm_snd_norm.1
  rw [← integrable_norm_iff] at h_int_snd_norm_fst_norm_snd_norm_fst_norm
  have h_int_fst_norm_snd_norm_fst_norm_snd_norm_fst_norm := h_int_fst_norm_snd_norm_fst_norm.2
  have h_int_snd_norm_fst_norm_snd_norm_fst_norm_snd_norm := h_int_snd_norm_fst_norm_snd_norm_fst_norm.1
  rw [← integrable_norm_iff] at h_int_snd_norm_fst_norm_snd_norm_fst_norm_snd_norm
  have h_int_fst_norm_snd_norm_fst_norm_snd_norm_fst_norm_snd_norm := h_int_fst_norm_snd_norm_fst_norm.2
  have h_int_snd_norm_fst_norm_snd_norm_fst_norm_snd_norm_fst_norm := h_int_snd_norm_fst_norm_snd_norm_fst_norm.1
  rw [← integrable_norm_iff] at h_int_snd_norm_fst_norm_snd_norm_fst_norm_snd_norm_fst_norm
  have h_int_fst_norm_snd_norm_fst_norm_snd_norm_fst_norm_snd_norm_fst_norm := h_int_fst_norm_snd_norm_fst_norm.2
  have h_int_snd_norm_fst_norm_snd_norm_fst_norm_snd_norm_fst_norm_snd_norm_fst_norm := h_int
    _
  rw [← integrable_norm_iff] at h_int_snd_norm_fst_norm_snd_norm_fst_norm_snd_norm_fst_norm_snd_norm_fst_norm
  exact h_int_snd_norm_fst_norm_snd_norm_fst_norm_snd_norm_fst_norm_snd_norm_fst_norm
```

Attempt failure.

Working on Mathlib/Probability/Variance.lean - 2024-09-08 18:34:23.656305.
---159/200---
For theorem ProbabilityTheory.IndepFun.variance_sum in Mathlib/Probability/Variance.lean:
theorem IndepFun.variance_sum [@IsProbabilityMeasure Ω _ ℙ] {ι : Type*} {X : ι → Ω → ℝ}
    {s : Finset ι} (hs : ∀ i ∈ s, @Memℒp _ _ _ (_) (X i) 2 ℙ)
    (h : Set.Pairwise ↑s fun i j => @IndepFun _ _ _ (_) _ _ (X i) (X j) ℙ) :
    Var[∑ i ∈ s, X i] = ∑ i ∈ s, Var[X i] 


Original valid proof:
:= by
  classical
  induction' s using Finset.induction_on with k s ks IH
  · simp only [Finset.sum_empty, variance_zero]
  rw [variance_def' (memℒp_finset_sum' _ hs), sum_insert ks, sum_insert ks]
  simp only [add_sq']
  calc
    𝔼[X k ^ 2 + (∑ i ∈ s, X i) ^ 2 + 2 * X k * ∑ i ∈ s, X i] - 𝔼[X k + ∑ i ∈ s, X i] ^ 2 =
        𝔼[X k ^ 2] + 𝔼[(∑ i ∈ s, X i) ^ 2] + 𝔼[2 * X k * ∑ i ∈ s, X i] -
          (𝔼[X k] + 𝔼[∑ i ∈ s, X i]) ^ 2 := by
      rw [integral_add', integral_add', integral_add']
      · exact Memℒp.integrable one_le_two (hs _ (mem_insert_self _ _))
      · apply integrable_finset_sum' _ fun i hi => ?_
        exact Memℒp.integrable one_le_two (hs _ (mem_insert_of_mem hi))
      · exact Memℒp.integrable_sq (hs _ (mem_insert_self _ _))
      · apply Memℒp.integrable_sq
        exact memℒp_finset_sum' _ fun i hi => hs _ (mem_insert_of_mem hi)
      · apply Integrable.add
        · exact Memℒp.integrable_sq (hs _ (mem_insert_self _ _))
        · apply Memℒp.integrable_sq
          exact memℒp_finset_sum' _ fun i hi => hs _ (mem_insert_of_mem hi)
      · rw [mul_assoc]
        apply Integrable.const_mul _ (2 : ℝ)
        rw [mul_sum, sum_fn]
        apply integrable_finset_sum _ fun i hi => ?_
        apply IndepFun.integrable_mul _ (Memℒp.integrable one_le_two (hs _ (mem_insert_self _ _)))
          (Memℒp.integrable one_le_two (hs _ (mem_insert_of_mem hi)))
        apply h (mem_insert_self _ _) (mem_insert_of_mem hi)
        exact fun hki => ks (hki.symm ▸ hi)
    _ = Var[X k] + Var[∑ i ∈ s, X i] +
        (𝔼[2 * X k * ∑ i ∈ s, X i] - 2 * 𝔼[X k] * 𝔼[∑ i ∈ s, X i]) := by
      rw [variance_def' (hs _ (mem_insert_self _ _)),
        variance_def' (memℒp_finset_sum' _ fun i hi => hs _ (mem_insert_of_mem hi))]
      ring
    _ = Var[X k] + Var[∑ i ∈ s, X i] := by
      simp_rw [Pi.mul_apply, Pi.ofNat_apply, Nat.cast_ofNat, sum_apply, mul_sum, mul_assoc,
        add_right_eq_self]
      rw [integral_finset_sum s fun i hi => ?_]; swap
      · apply Integrable.const_mul _ (2 : ℝ)
        apply IndepFun.integrable_mul _ (Memℒp.integrable one_le_two (hs _ (mem_insert_self _ _)))
          (Memℒp.integrable one_le_two (hs _ (mem_insert_of_mem hi)))
        apply h (mem_insert_self _ _) (mem_insert_of_mem hi)
        exact fun hki => ks (hki.symm ▸ hi)
      rw [integral_finset_sum s fun i hi =>
          Memℒp.integrable one_le_two (hs _ (mem_insert_of_mem hi)),
        mul_sum, mul_sum, ← sum_sub_distrib]
      apply Finset.sum_eq_zero fun i hi => ?_
      rw [integral_mul_left, IndepFun.integral_mul', sub_self]
      · apply h (mem_insert_self _ _) (mem_insert_of_mem hi)
        exact fun hki => ks (hki.symm ▸ hi)
      · exact Memℒp.aestronglyMeasurable (hs _ (mem_insert_self _ _))
      · exact Memℒp.aestronglyMeasurable (hs _ (mem_insert_of_mem hi))
    _ = Var[X k] + ∑ i ∈ s, Var[X i] := by
      rw [IH (fun i hi => hs i (mem_insert_of_mem hi))
          (h.mono (by simp only [coe_insert, Set.subset_insert]))]


Verifying proof (Commit 525ae9d15817f1ed908335d2ed89b534c3cbd387):
↔
      ∀ i ∈ s, ∀ j ∈ s, i ≠ j → IndepFun (X i) (X j) := by
  classical
  induction' s using Finset.induction_on with a s has IH
  · simp only [Finset.sum_empty, Finset.mem_empty, IsEmpty.forall_iff, imp_true_iff,
      variance_zero, Finset.sum_const_zero, eq_self_iff_true, zero_eq_mul, mul_eq_zero,
      Nat.cast_eq_zero, false_or_iff]
  · rw [Finset.sum_insert has, variance_add' (hs a (Finset.mem_insert_self a s))
      (hs _ (Finset.mem_insert_of_mem (Finset.mem_coe.2 (Finset.mem_insert_self a s))))]
    have :
      Set.Pairwise ↑(insert a s) fun i j => @IndepFun _ _ _ (_) _ _ (X i) (X j) ℙ := by
      refine' Set.Pairwise.insert_of_symmetric (fun i j => @IndepFun _ _ _ (_) _ _ (X i) (X j) ℙ)
        (fun i j => @IndepFun.symm _ _ _ (_) _ _ (X i) (X j) ℙ) _
      exact h
    rw [IH (fun i hi => hs i (Finset.mem_insert_of_mem hi)) this.mono_ac (add_comm a s)]
    constructor
    · intro h
      intro i hi j hj hij
      simp only [Finset.mem_insert] at hi hj
      cases' hi with hi hi <;> cases' hj with hj hj <;> simp only [hi, hj, hij,
        @IndepFun.symm _ _ _ (_) _ _ (X i) (X j) ℙ, imp_true_iff]
    · intro h
      simp only [Finset.mem_insert]
      exact fun i hi j hj => h i (Or.inl hi) j (Or.inr hj)
```

Attempt failure.

Working on Mathlib/RingTheory/Adjoin/Basic.lean - 2024-09-08 18:34:36.594339.
---160/200---
For theorem Algebra.mem_adjoin_of_map_mul in Mathlib/RingTheory/Adjoin/Basic.lean:
theorem mem_adjoin_of_map_mul {s} {x : A} {f : A →ₗ[R] B} (hf : ∀ a₁ a₂, f (a₁ * a₂) = f a₁ * f a₂)
    (h : x ∈ adjoin R s) : f x ∈ adjoin R (f '' (s ∪ {1})) 


Original valid proof:
:= by
  refine
    @adjoin_induction R A _ _ _ _ (fun a => f a ∈ adjoin R (f '' (s ∪ {1}))) x h
      (fun a ha => subset_adjoin ⟨a, ⟨Set.subset_union_left ha, rfl⟩⟩) (fun r => ?_)
      (fun y z hy hz => by simpa [hy, hz] using Subalgebra.add_mem _ hy hz) fun y z hy hz => by
      simpa [hy, hz, hf y z] using Subalgebra.mul_mem _ hy hz
  have : f 1 ∈ adjoin R (f '' (s ∪ {1})) :=
    subset_adjoin ⟨1, ⟨Set.subset_union_right <| Set.mem_singleton 1, rfl⟩⟩
  convert Subalgebra.smul_mem (adjoin R (f '' (s ∪ {1}))) this r
  rw [algebraMap_eq_smul_one]
  exact f.map_smul _ _


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
∧ ∀ y ∈ adjoin R (f '' (s ∪ {1})), f x * y = y * f x := by
  refine ⟨?_, fun y hy ↦ ?_➍
  · refine
      adjoin_induction h (fun a ↦ ?_) (fun r ↦ ?_) (fun _ _ ↦ ?_) (fun _ _ ↦ ?_) fun y z hy hz ↦ ?_
    · exact subset_adjoin R (f '' (s ∪ {1})) (Set.mem_image_of_mem _ (Set.subset_union_left _ _))
    · exact Subalgebra.algebraMap_mem _ _
    · rw [map_add]
      exact add_mem hy hz
    · rw [map_mul]
      exact mul_mem hy hz
    · exact Subalgebra.mul_mem hy hz
  · refine adjoin_induction hy (fun a ↦ ?_) (fun r ↦ ?_) (fun y z hy hz ↦ ?_) (fun y z hy hz ↦ ?_) fun y z hy hz ↦ ?_
    · exact Subalgebra.mul_mem (subset_adjoin R (f '' (s ∪ {1})) (Set.mem_image_of_mem _ (Set.subset_union_left _ _)))
        (subset_adjoin R (f '' (s ∪ {1})) (Set.mem_image_of_mem _ (Set.subset_union_right _ _)))
    · exact Subalgebra.algebraMap_mem _ _
    · rw [map_add]
      exact add_mem hy hz
    · rw [map_mul]
      exact mul_mem hy hz
    · rw [← mul_assoc, ← hf, mul_assoc, hf, mul_assoc]
      exact mul_mem hy hz

theorem mem_adjoin_of_map_mul' {s} {x : A} {f : A →ₗ[R] B} (hf : ∀ a₁ a₂, f (a₁ * a₂) = f a₁ * f a₂)
    (h : x ∈ adjoin R s) : f x ∈ adjoin R (f '' s) ∧ ∀ y ∈ adjoin R (f '' s), f x * y = y * f x := by
  refine ⟨?_, fun y hy ↦ ?_⟩
  · refine adjoin_induction h (fun a ↦ ?_) (fun r ↦ ?_) (fun _ _ ↦ ?_) (fun _ _ ↦ ?_) fun y z hy hz ↦ ?_
    · exact subset_adjoin R (f '' s) (Set.mem_image_of_mem _ (Set.subset_union_left _ _))
    · exact Subalgebra.algebraMap_mem _ _
    · rw [map_add]
      exact add_mem hy hz
    · rw [map_mul]
      exact mul_mem hy hz
    · exact Subalgebra.mul_mem hy hz
  · refine adjoin_induction hy (fun a ↦ ?_) (fun r ↦ ?_) (fun y z hy hz ↦ ?_) (fun y z hy hz ↦ ?_) fun y z hy hz ↦ ?_
    · exact Subalgebra.mul_mem (subset_adjoin R (f '' s) (Set.mem_image_of_mem _ (Set.subset_union_left _ _)))
        (subset_adjoin R (f '' s) (Set.mem_image_of_mem _ (Set.subset_union_right _ _)))
    · exact Subalgebra.algebraMap_mem _ _
    · rw [map_add]
      exact add_mem hy hz
    · rw [map_mul]
      exact mul_mem hy hz
    · rw [← mul_assoc, ← hf, mul_assoc, hf, mul_assoc]
      exact mul_mem hy hz
```

Attempt failure.

Working on Mathlib/RingTheory/Adjoin/Tower.lean - 2024-09-08 18:34:54.379446.
---161/200---
For theorem fg_of_fg_of_fg in Mathlib/RingTheory/Adjoin/Tower.lean:
theorem fg_of_fg_of_fg [IsNoetherianRing A] (hAC : (⊤ : Subalgebra A C).FG)
    (hBC : (⊤ : Submodule B C).FG) (hBCi : Function.Injective (algebraMap B C)) :
    (⊤ : Subalgebra A B).FG 


Original valid proof:
:=
  let ⟨B₀, hAB₀, hB₀C⟩ := exists_subalgebra_of_fg A B C hAC hBC
  Algebra.fg_trans' (B₀.fg_top.2 hAB₀) <|
    Subalgebra.fg_of_submodule_fg <|
      have : IsNoetherianRing B₀ := isNoetherianRing_of_fg hAB₀
      have : Module.Finite B₀ C := ⟨hB₀C⟩
      fg_of_injective (IsScalarTower.toAlgHom B₀ B C).toLinearMap hBCi


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
∧ (⊤ : Submodule A C).FG := by
  haveI : IsNoetherianRing B :=
    IsNoetherianRing.isNoetherianRing_of_fg (⊤ : Subalgebra A B) hAC.1
  haveI : IsNoetherianRing C :=
    IsNoetherianRing.isNoetherianRing_of_fg (⊤ : Subalgebra A C) hAC.2
  refine ⟨?_, ?_⟩
  · exact
      Subalgebra.fg_of_fg_map_injective (algebraMap B C).injective hBC
  · exact
      Submodule.fg_of_fg_map_injective (algebraMap A C).injective hBCi hBC


theorem fg_of_fg_of_fg' [IsNoetherianRing A] (hAC : (⊤ : Subalgebra A C).FG)
    (hBC : (⊤ : Submodule B C).FG) (hBCi : Function.Injective (algebraMap B C)) :
    (⊤ : Subalgebra A B).FG ∧ (⊤ : Submodule A C).FG :=
  fg_of_fg_of_fg hAC hBC hBCi
```

Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/Factorization.lean - 2024-09-08 18:35:03.139091.
---162/200---
For theorem Ideal.finite_mulSupport_coe in Mathlib/RingTheory/DedekindDomain/Factorization.lean:
theorem finite_mulSupport_coe {I : Ideal R} (hI : I ≠ 0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R⁰ K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : ℤ)).Finite 


Original valid proof:
:= by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, ← FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_one]
  exact finite_mulSupport hI


Verifying proof (Commit 04cf8c4630518d88c67bf9ba4d4db872ea86f7e2):
 := by
  apply Set.finite_of_finite_image (f := fun v : HeightOneSpectrum R => v.asIdeal)
  swap
  · intro v1 v2 hv
    simpa only [Subtype.mk.injEq] using FractionalIdeal.ext_iff.mp hv
  exact finite_mulSupport_coe' hI
```

Attempt failure.

Working on Mathlib/RingTheory/FiniteType.lean - 2024-09-08 18:35:17.943674.
---163/200---
For theorem AddMonoidAlgebra.freeAlgebra_lift_of_surjective_of_closure in Mathlib/RingTheory/FiniteType.lean:
theorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}
    (hS : closure S = ⊤) :
    Function.Surjective
      (FreeAlgebra.lift R fun s : S => of' R M ↑s : FreeAlgebra R S → R[M]) 


Original valid proof:
:= by
  intro f
  induction' f using induction_on with m f g ihf ihg r f ih
  · have : m ∈ closure S := hS.symm ▸ mem_top _
    refine AddSubmonoid.closure_induction this (fun m hm => ?_) ?_ ?_
    · exact ⟨FreeAlgebra.ι R ⟨m, hm⟩, FreeAlgebra.lift_ι_apply _ _⟩
    · exact ⟨1, AlgHom.map_one _⟩
    · rintro m₁ m₂ ⟨P₁, hP₁⟩ ⟨P₂, hP₂⟩
      exact
        ⟨P₁ * P₂, by
          rw [AlgHom.map_mul, hP₁, hP₂, of_apply, of_apply, of_apply, single_mul_single,
            one_mul]; rfl⟩
  · rcases ihf with ⟨P, rfl⟩
    rcases ihg with ⟨Q, rfl⟩
    exact ⟨P + Q, AlgHom.map_add _ _ _⟩
  · rcases ih with ⟨P, rfl⟩
    exact ⟨r • P, AlgHom.map_smul _ _ _⟩


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
∧
        (FreeAlgebra.lift R fun s : S => of' R M ↑s : FreeAlgebra R S → R[M])
          (FreeAlgebra.ι R (⊤ : Submonoid M)) = 0 := by
  -- Porting note: `simp_rw` is required to infer metavariables in the `rw` in the next line.
  simp_rw [← @Submonoid.mem_carrier _ (⊤ : Submonoid M), hS]
  rw [← FreeAlgebra.ι_eq_lift, ← FreeAlgebra.ι_eq_lift]
  exact
    ⟨fun f =>
      FreeAlgebra.induction_on f
        (fun r => by
          rw [FreeAlgebra.lift_ι_apply, FreeAlgebra.ι_ofScalar])
        (fun x => by
          rw [FreeAlgebra.lift_ι_apply, FreeAlgebra.ι_of]
          exact ⟨x, rfl⟩)
        (fun x y ⟨x', hx'⟩ ⟨y', hy'⟩ => by
          rw [map_add, hx', hy', Submonoid.coe_add]
          exact ⟨x' + y', rfl⟩)
        fun x y ⟨x', hx'⟩ ⟨y', hy'⟩ => by
        rw [map_mul, hx', hy', Submonoid.coe_mul]
        exact ⟨x' * y', rfl⟩,
      (FreeAlgebra.lift_ι_apply _ _).trans <| by simp⟩
```

Attempt failure.

Working on Mathlib/RingTheory/IntegralClosure.lean - 2024-09-08 18:35:35.378566.
---164/200---
For theorem RingHom.isIntegralElem_leadingCoeff_mul in Mathlib/RingTheory/IntegralClosure.lean:
theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval₂ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) 


Original valid proof:
:= by
  by_cases h' : 1 ≤ p.natDegree
  · use normalizeScaleRoots p
    have : p ≠ 0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_eval₂_leadingCoeff_mul p h' f x, h, mul_zero]
  · by_cases hp : p.map f = 0
    · apply_fun fun q => coeff q p.natDegree at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, zero_mul]
      exact f.isIntegralElem_zero
    · rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', eval₂_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]


Verifying proof (Commit 3b4737b3b07aa77aaa08420241e83ad9c46eda8a):
 := by
  refine ⟨p, monic_mul_leadingCoeff_inv p.ne_zero, ?_⟩
  rw [← f.map_mul, ← eval₂_mul, mul_comm, ← f.map_mul, ← eval₂_mul, ← mul_assoc,
    mul_comm _ x, ← mul_assoc, mul_inv_cancel, one_mul]
  · exact h
  · exact leadingCoeff_ne_zero.mpr p.ne_zero

theorem isIntegral_leadingCoeff_mul (h : p.eval₂ f x = 0) :
    IsIntegral (f p.leadingCoeff * x) :=
  (f.isIntegralElem_leadingCoeff_mul h).isIntegral

/-- If `x` is a root of a polynomial with coefficients in a ring `S`,
then `f x` is a root of a polynomial with coefficients in `R`,
where `f : R →+* S` is a ring homomorphism. -/
theorem RingHom.isIntegralElem_of_mem_range (hx : x ∈ (Polynomial.map f p).aroots S) :
    f.IsIntegralElem x := by
  obtain ⟨q, hq⟩ := mem_roots'.mp hx
  refine ⟨q, monic_map_of_monic hf p.monic, ?_⟩
  rw [← eval_map_algebraMap, ← hq, map_zero]

/-- If `x` is a root of a polynomial with coefficients in a ring `S`,
then `f x` is a root of a polynomial with coefficients in `R`,
where `f : R →+* S` is a ring homomorphism. -/
theorem isIntegral_of_mem_range (hx : x ∈ (Polynomial.map f p).aroots S) :
    IsIntegral R x :=
  (f.isIntegralElem_of_mem_range hf hx).isIntegral
```

Attempt failure.

Working on Mathlib/RingTheory/MvPowerSeries/Basic.lean - 2024-09-08 18:35:59.629856.
---165/200---
For theorem MvPowerSeries.X_pow_eq in Mathlib/RingTheory/MvPowerSeries/Basic.lean:
theorem X_pow_eq (s : σ) (n : ℕ) : (X s : MvPowerSeries σ R) ^ n = monomial R (single s n) 1 


Original valid proof:
:= by
  induction' n with n ih
  · simp
  · rw [pow_succ, ih, Finsupp.single_add, X, monomial_mul_monomial, one_mul]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
1 := by
  induction' n with n ih
  · simp
  · rw [pow_succ, ih, monomial_mul_monomial, add_comm]
    congr
    ext a
    simp [single_add]
```

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Chebyshev.lean - 2024-09-08 18:36:14.833964.
---166/200---
For theorem Polynomial.Chebyshev.mul_T in Mathlib/RingTheory/Polynomial/Chebyshev.lean:
theorem mul_T (m k : ℤ) : 2 * T R m * T R k = T R (m + k) + T R (m - k) 


Original valid proof:
:= by
  induction k using Polynomial.Chebyshev.induct with
  | zero => simp [two_mul]
  | one => rw [T_add_one, T_one]; ring
  | add_two k ih1 ih2 =>
    have h₁ := T_add_two R (m + k)
    have h₂ := T_sub_two R (m - k)
    have h₃ := T_add_two R k
    linear_combination (norm := ring_nf) 2 * T R m * h₃ - h₂ - h₁ - ih2 + 2 * (X:R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have h₁ := T_add_two R (m + (-k - 1))
    have h₂ := T_sub_two R (m - (-k - 1))
    have h₃ := T_add_two R (-k - 1)
    linear_combination (norm := ring_nf) 2 * T R m * h₃ - h₂ - h₁ - ih2 + 2 * (X:R[X]) * ih1


Verifying proof (Commit a645d903a5e02e8cbb9215f6195147610bf99954):
 := by
  induction k with
  | ofNat =>
    simp only [ofNat_eq_coe, Int.cast_ofNat, Int.cast_add, Int.cast_sub, Int.cast_one,
      Int.cast_zero, Int.cast_mul, Int.cast_two, Int.cast_neg, Int.cast_natCast,
      Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Nat.cast_natCast, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add,
      Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.cast_zero,
      Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul, Nat.cast_two, Nat.cast_neg,
      Int.cast_natCast, Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_sub, Nat.cast_mul,
      Nat.cast_two, Nat.cast_neg, Int.cast_natCast, Nat.

Attempt failure.

---167/200---
For theorem Polynomial.Chebyshev.U_neg_sub_one in Mathlib/RingTheory/Polynomial/Chebyshev.lean:
theorem U_neg_sub_one (n : ℤ) : U R (-n - 1) = -U R (n - 1) 


Original valid proof:
:= by
  induction n using Polynomial.Chebyshev.induct with
  | zero => simp
  | one => simp
  | add_two n ih1 ih2 =>
    have h₁ := U_add_one R n
    have h₂ := U_sub_two R (-n - 1)
    linear_combination (norm := ring_nf) 2 * (X:R[X]) * ih1 - ih2 + h₁ + h₂
  | neg_add_one n ih1 ih2 =>
    have h₁ := U_eq R n
    have h₂ := U_sub_two R (-n)
    linear_combination (norm := ring_nf) 2 * (X:R[X]) * ih1 - ih2 + h₁ + h₂


Verifying proof (Commit a645d903a5e02e8cbb9215f6195147610bf99954):
 := by
  induction n using Int.induction_on with
  | hz =>
    simp only [Int.ofNat_zero, Int.neg_zero, Int.zero_sub, U_zero, U_neg_one, neg_neg,
      eq_self_iff_true, Int.neg_add, Int.neg_neg, Int.zero_add, Int.one_add, Int.neg_one_add]
  | hp n ih =>
    simp only [Int.neg_add, Int.neg_sub, Int.neg_neg, Int.add_sub_cancel, Int.sub_add_cancel,
      Int.neg_add_cancel_right, Int.neg_add_cancel_left, Int.neg_sub_neg, Int.neg_sub_self,
      Int.neg_zero, Int.sub_zero, Int.sub_neg_eq_add, Int.add_comm, Int.add_left_comm,
      Int.add_assoc, Int.sub_eq_add_neg, Int.sub_neg_eq_add, Int.sub_self, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq_add,
      Int.sub_neg_eq_add, Int.sub_neg_eq_add, Int.sub_neg_eq

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Cyclotomic/Expand.lean - 2024-09-08 18:36:47.720548.
---168/200---
For theorem Polynomial.cyclotomic_mul_prime_pow_eq in Mathlib/RingTheory/Polynomial/Cyclotomic/Expand.lean:
theorem cyclotomic_mul_prime_pow_eq (R : Type*) {p m : ℕ} [Fact (Nat.Prime p)] [Ring R] [CharP R p]
    (hm : ¬p ∣ m) : ∀ {k}, 0 < k → cyclotomic (p ^ k * m) R = cyclotomic m R ^ (p ^ k - p ^ (k - 1))



Original valid proof:
  | 1, _ => by
    rw [pow_one, Nat.sub_self, pow_zero, mul_comm, cyclotomic_mul_prime_eq_pow_of_not_dvd R hm]
  | a + 2, _ => by
    have hdiv : p ∣ p ^ a.succ * m := ⟨p ^ a * m, by rw [← mul_assoc, pow_succ']⟩
    rw [pow_succ', mul_assoc, mul_comm, cyclotomic_mul_prime_dvd_eq_pow R hdiv,
      cyclotomic_mul_prime_pow_eq _ _ a.succ_pos, ← pow_mul]
    · simp only [tsub_zero, Nat.succ_sub_succ_eq_sub]
      rw [Nat.mul_sub_right_distrib, mul_comm, pow_succ]
    · assumption


Verifying proof (Commit c7bd9bd10c613e1788107ba753e252f069560f87):
  | 1, _ => by
    rw [pow_one, pow_one, pow_zero, Nat.sub_self, pow_one]
  | k + 2, hk => by
    have hdiv : p ∣ p ^ k.succ * m := by
      rw [Nat.pow_succ]
      exact Nat.dvd_mul_right _ _
    rw [cyclotomic_mul_prime_pow_eq R hdiv, cyclotomic_mul_prime_pow_eq R hdiv, pow_sub_pow_mul_pow,
      pow_sub_pow_mul_pow, ← pow_mul, ← pow_mul, ← pow_succ, ← pow_succ,
      Nat.sub_sub_self (Nat.one_le_pow _ _ hk.ne'), Nat.sub_sub_self (Nat.one_le_pow _ _ hk.ne'),
      Nat.mul_div_cancel' (Nat.dvd_of_mod_eq_zero <| Nat.mod_eq_zero_of_dvd hdiv),
      Nat.mul_div_cancel' (Nat.dvd_of_mod_eq_zero <| Nat.mod_eq_zero_of_dvd hdiv)]
  | 0, hk => (Nat.not_lt_zero _ hk).elim
```

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Hermite/Basic.lean - 2024-09-08 18:36:58.177164.
---169/200---
For theorem Polynomial.coeff_hermite_explicit in Mathlib/RingTheory/Polynomial/Hermite/Basic.lean:
theorem coeff_hermite_explicit :
    ∀ n k : ℕ, coeff (hermite (2 * n + k)) k = (-1) ^ n * (2 * n - 1)‼ * Nat.choose (2 * n + k) k



Original valid proof:
  | 0, _ => by simp
  | n + 1, 0 => by
    convert coeff_hermite_succ_zero (2 * n + 1) using 1
    rw [coeff_hermite_explicit n 1, (by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] :
      2 * (n + 1) - 1 = 2 * n + 1), Nat.doubleFactorial_add_one, Nat.choose_zero_right,
      Nat.choose_one_right, pow_succ]
    push_cast
    ring
  | n + 1, k + 1 => by
    let hermite_explicit : ℕ → ℕ → ℤ := fun n k =>
      (-1) ^ n * (2 * n - 1)‼ * Nat.choose (2 * n + k) k
    have hermite_explicit_recur :
      ∀ n k : ℕ,
        hermite_explicit (n + 1) (k + 1) =
          hermite_explicit (n + 1) k - (k + 2) * hermite_explicit n (k + 2) := by
      intro n k
      simp only [hermite_explicit]
      rw [mul_comm (↑k + _ : ℤ), sub_eq_add_neg]
      nth_rw 3 [neg_eq_neg_one_mul]
      simp only [mul_assoc, ← mul_add, pow_succ']
      congr 2
      norm_cast
      rw [(by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] : 2 * (n + 1) - 1 = 2 * n + 1),
        Nat.doubleFactorial_add_one, mul_comm (2 * n + 1)]
      simp only [mul_assoc, ← mul_add]
      congr 1
      rw [(by ring : 2 * (n + 1) + (k + 1) = 2 * n + 1 + (k + 1) + 1),
        (by ring : 2 * (n + 1) + k = 2 * n + 1 + (k + 1)),
        (by ring : 2 * n + (k + 2) = 2 * n + 1 + (k + 1))]
      rw [Nat.choose, Nat.choose_succ_right_eq (2 * n + 1 + (k + 1)) (k + 1), Nat.add_sub_cancel]
      ring
    change _ = hermite_explicit _ _
    rw [← add_assoc, coeff_hermite_succ_succ, hermite_explicit_recur]
    congr
    · rw [coeff_hermite_explicit (n + 1) k]
    · rw [(by ring : 2 * (n + 1) + k = 2 * n + (k + 2)), coeff_hermite_explicit n (k + 2)]


Verifying proof (Commit 8a77514daeaf3b706a2b617d963d1f46e4504afb):
  | 0, k => by simp
  | n + 1, k => by
    simp only [coeff_hermite_succ_zero, coeff_hermite_succ_succ, coeff_hermite_explicit n]
    simp only [Nat.choose_succ_succ, add_right_comm, add_tsub_cancel_right,
      Nat.choose_symm_add, add_tsub_cancel_left, add_tsub_assoc_of_le, add_assoc,
      add_left_comm, add_comm, tsub_tsub, mul_assoc, mul_left_comm, mul_comm,
      Nat.cast_id, pow_succ, Nat.cast_add, Nat.cast_one, Nat.cast_mul]
    ring

theorem coeff_hermite_succ_of_lt {n k : ℕ} (h : n < 2 * k) :
    coeff (hermite (2 * k + 1)) n = 0 := by
  rwa [coeff_hermite_succ_zero, Nat.choose_eq_zero_of_lt]

theorem coeff_hermite_succ_succ_of_eq {n k : ℕ} (h : n = 2 * k) :
    coeff (hermite (2 * k + 1)) (2 * k + 1) = (-1) ^ k * (2 * k - 1)‼ * Nat.choose (2 * k + 1) (2 * k + 1) := by
  simp only [coeff_hermite_succ_succ, coeff_hermite_succ_zero, h, Nat.choose_succ_succ,
    add_right_comm, add_tsub_cancel_right, Nat.choose_symm_add, add_tsub_cancel_left,
    add_tsub_assoc_of_le, add_assoc, add_left_comm, add_comm, tsub_tsub, mul_assoc, mul_left_comm,
    mul_comm, Nat.cast_id, pow_succ, Nat.cast_add, Nat.cast_one, Nat.cast_mul]
  ring

theorem coeff_hermite_succ_succ_of_lt {n k : ℕ} (h : n < 2 * k) :
    coeff (hermite (2 * k + 1)) (2 * k + 1) = 0 := by
  rwa [coeff_hermite_succ_succ, Nat.choose_eq_zero_of_lt]

theorem coeff_hermite_of_odd_add {n k : ℕ} (h : Odd (2 * k + 1 + n)) :
    coeff (hermite (2 * k + 1 + n)) k = 0 := by
  rcases le_or_lt n (2 * k + 1) with hn | hn
  · rw [← Nat.odd_iff, Nat.odd_add, Nat.odd_mul, Nat.odd_add] at h
    rw [coeff_hermite_of_lt hn, coeff_hermite_of_lt (lt_of_le_of_lt hn h)]
  · rw [← Nat.odd_iff, Nat.odd_add, Nat.odd_mul, Nat.odd_add] at h
    rw [coeff_hermite_of_lt (lt_of_le_of_lt h hn), coeff_hermite_of_lt hn]

theorem coeff_hermite_of_odd_add' {n k : ℕ} (h : Odd (2 * k + 1 + n)) :
    coeff (hermite (2 * k + 1 + n)) (2 * k + 1) = 0 := by
  rcases le_or_lt n (2 * k + 1) with hn | hn
  · rw [← Nat.odd_iff, Nat.odd_add, Nat.odd_mul, Nat.odd_add] at h
    rw [coeff_hermite_of_lt hn, coeff_hermite_of_lt (lt_of_le_of_lt hn h)]
  · rw [← Nat.odd_iff, Nat.odd_add, Nat.odd_mul, Nat.odd_add] at h
    rw [coeff_hermite_of_lt (lt_of_le_of_lt h hn), coeff_hermite_of_lt hn]

theorem coeff_hermite_of_even_add {n k : ℕ} (h : Even (2 * k + 1 + n)) :
    coeff (hermite (2 * k + 1 + n)) k = (-1) ^ (n + k) * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) k := by
  rcases le_or_lt n (2 * k + 1) with hn | hn
  · rw [← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h
    rw [coeff_hermite_of_lt hn, coeff_hermite_of_lt (lt_of_le_of_lt hn h)]
  · rw [← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h
    rw [coeff_hermite_of_lt (lt_of_le_of_lt h hn), coeff_hermite_of_lt hn]

theorem coeff_hermite_of_even_add' {n k : ℕ} (h : Even (2 * k + 1 + n)) :
    coeff (hermite (2 * k + 1 + n)) (2 * k + 1) = (-1) ^ (n + k) * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) (2 * k + 1) := by
  rcases le_or_lt n (2 * k + 1) with hn | hn
  · rw [← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h
    rw [coeff_hermite_of_lt hn, coeff_hermite_of_lt (lt_of_le_of_lt hn h)]
  · rw [← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h
    rw [coeff_hermite_of_lt (lt_of_le_of_lt h hn), coeff_hermite_of_lt hn]

theorem coeff_hermite_of_even_add_of_even {n k : ℕ} (h : Even (2 * k + 1 + n)) (h' : Even n) :
    coeff (hermite (2 * k + 1 + n)) k = (-1) ^ (k + 1) * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) k := by
  rw [coeff_hermite_of_even_add h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_even_add_of_odd {n k : ℕ} (h : Even (2 * k + 1 + n)) (h' : Odd n) :
    coeff (hermite (2 * k + 1 + n)) k = (-1) ^ k * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) k := by
  rw [coeff_hermite_of_even_add h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_odd_add_of_even {n k : ℕ} (h : Odd (2 * k + 1 + n)) (h' : Even n) :
    coeff (hermite (2 * k + 1 + n)) k = (-1) ^ (k + 1) * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) k := by
  rw [coeff_hermite_of_odd_add h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_odd_add_of_odd {n k : ℕ} (h : Odd (2 * k + 1 + n)) (h' : Odd n) :
    coeff (hermite (2 * k + 1 + n)) k = (-1) ^ k * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) k := by
  rw [coeff_hermite_of_odd_add h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_even_add_of_even' {n k : ℕ} (h : Even (2 * k + 1 + n)) (h' : Even n) :
    coeff (hermite (2 * k + 1 + n)) (2 * k + 1) = (-1) ^ (k + 1) * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) (2 * k + 1) := by
  rw [coeff_hermite_of_even_add' h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_even_add_of_odd' {n k : ℕ} (h : Even (2 * k + 1 + n)) (h' : Odd n) :
    coeff (hermite (2 * k + 1 + n)) (2 * k + 1) = (-1) ^ k * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) (2 * k + 1) := by
  rw [coeff_hermite_of_even_add' h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_odd_add_of_even' {n k : ℕ} (h : Odd (2 * k + 1 + n)) (h' : Even n) :
    coeff (hermite (2 * k + 1 + n)) (2 * k + 1) = (-1) ^ (k + 1) * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) (2 * k + 1) := by
  rw [coeff_hermite_of_odd_add' h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_odd_add_of_odd' {n k : ℕ} (h : Odd (2 * k + 1 + n)) (h' : Odd n) :
    coeff (hermite (2 * k + 1 + n)) (2 * k + 1) = (-1) ^ k * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) (2 * k + 1) := by
  rw [coeff_hermite_of_odd_add' h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_even_add_of_even'' {n k : ℕ} (h : Even (2 * k + 1 + n)) (h' : Even n) :
    coeff (hermite (2 * k + 1 + n)) (2 * k + 1) = (-1) ^ (k + 1) * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) (2 * k + 1) := by
  rw [coeff_hermite_of_even_add' h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_

Attempt failure.

---170/200---
For theorem Polynomial.coeff_hermite_explicit in Mathlib/RingTheory/Polynomial/Hermite/Basic.lean:
theorem coeff_hermite_explicit :
    ∀ n k : ℕ, coeff (hermite (2 * n + k)) k = (-1) ^ n * (2 * n - 1)‼ * Nat.choose (2 * n + k) k



Original valid proof:
  | 0, _ => by simp
  | n + 1, 0 => by
    convert coeff_hermite_succ_zero (2 * n + 1) using 1
    rw [coeff_hermite_explicit n 1, (by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] :
      2 * (n + 1) - 1 = 2 * n + 1), Nat.doubleFactorial_add_one, Nat.choose_zero_right,
      Nat.choose_one_right, pow_succ]
    push_cast
    ring
  | n + 1, k + 1 => by
    let hermite_explicit : ℕ → ℕ → ℤ := fun n k =>
      (-1) ^ n * (2 * n - 1)‼ * Nat.choose (2 * n + k) k
    have hermite_explicit_recur :
      ∀ n k : ℕ,
        hermite_explicit (n + 1) (k + 1) =
          hermite_explicit (n + 1) k - (k + 2) * hermite_explicit n (k + 2) := by
      intro n k
      simp only [hermite_explicit]
      rw [mul_comm (↑k + _ : ℤ), sub_eq_add_neg]
      nth_rw 3 [neg_eq_neg_one_mul]
      simp only [mul_assoc, ← mul_add, pow_succ']
      congr 2
      norm_cast
      rw [(by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] : 2 * (n + 1) - 1 = 2 * n + 1),
        Nat.doubleFactorial_add_one, mul_comm (2 * n + 1)]
      simp only [mul_assoc, ← mul_add]
      congr 1
      rw [(by ring : 2 * (n + 1) + (k + 1) = 2 * n + 1 + (k + 1) + 1),
        (by ring : 2 * (n + 1) + k = 2 * n + 1 + (k + 1)),
        (by ring : 2 * n + (k + 2) = 2 * n + 1 + (k + 1))]
      rw [Nat.choose, Nat.choose_succ_right_eq (2 * n + 1 + (k + 1)) (k + 1), Nat.add_sub_cancel]
      ring
    change _ = hermite_explicit _ _
    rw [← add_assoc, coeff_hermite_succ_succ, hermite_explicit_recur]
    congr
    · rw [coeff_hermite_explicit (n + 1) k]
    · rw [(by ring : 2 * (n + 1) + k = 2 * n + (k + 2)), coeff_hermite_explicit n (k + 2)]


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
  | 0, k => by simp
  | n + 1, k => by
    simp only [coeff_hermite_succ_zero, coeff_hermite_succ_succ, coeff_hermite_explicit n]
    simp only [Nat.choose_succ_succ, add_right_comm, add_tsub_cancel_right,
      Nat.choose_symm_add, add_tsub_cancel_left, add_tsub_assoc_of_le, add_assoc,
      add_left_comm, add_comm, tsub_tsub, mul_assoc, mul_left_comm, mul_comm,
      Nat.cast_id, pow_succ, Nat.cast_add, Nat.cast_one, Nat.cast_mul]
    ring

theorem coeff_hermite_succ_of_lt {n k : ℕ} (h : n < 2 * k) :
    coeff (hermite (2 * k + 1)) n = 0 := by
  rwa [coeff_hermite_succ_zero, Nat.choose_eq_zero_of_lt]

theorem coeff_hermite_succ_succ_of_eq {n k : ℕ} (h : n = 2 * k) :
    coeff (hermite (2 * k + 1)) (2 * k + 1) = (-1) ^ k * (2 * k - 1)‼ * Nat.choose (2 * k + 1) (2 * k + 1) := by
  simp only [coeff_hermite_succ_succ, coeff_hermite_succ_zero, h, Nat.choose_succ_succ,
    add_right_comm, add_tsub_cancel_right, Nat.choose_symm_add, add_tsub_cancel_left,
    add_tsub_assoc_of_le, add_assoc, add_left_comm, add_comm, tsub_tsub, mul_assoc, mul_left_comm,
    mul_comm, Nat.cast_id, pow_succ, Nat.cast_add, Nat.cast_one, Nat.cast_mul]
  ring

theorem coeff_hermite_succ_succ_of_lt {n k : ℕ} (h : n < 2 * k) :
    coeff (hermite (2 * k + 1)) (2 * k + 1) = 0 := by
  rwa [coeff_hermite_succ_succ, Nat.choose_eq_zero_of_lt]

theorem coeff_hermite_of_odd_add {n k : ℕ} (h : Odd (2 * k + 1 + n)) :
    coeff (hermite (2 * k + 1 + n)) k = 0 := by
  rcases le_or_lt n (2 * k + 1) with hn | hn
  · rw [← Nat.odd_iff, Nat.odd_add, Nat.odd_mul, Nat.odd_add] at h
    rw [coeff_hermite_of_lt hn, coeff_hermite_of_lt (lt_of_le_of_lt hn h)]
  · rw [← Nat.odd_iff, Nat.odd_add, Nat.odd_mul, Nat.odd_add] at h
    rw [coeff_hermite_of_lt (lt_of_le_of_lt h hn), coeff_hermite_of_lt hn]

theorem coeff_hermite_of_odd_add' {n k : ℕ} (h : Odd (2 * k + 1 + n)) :
    coeff (hermite (2 * k + 1 + n)) (2 * k + 1) = 0 := by
  rcases le_or_lt n (2 * k + 1) with hn | hn
  · rw [← Nat.odd_iff, Nat.odd_add, Nat.odd_mul, Nat.odd_add] at h
    rw [coeff_hermite_of_lt hn, coeff_hermite_of_lt (lt_of_le_of_lt hn h)]
  · rw [← Nat.odd_iff, Nat.odd_add, Nat.odd_mul, Nat.odd_add] at h
    rw [coeff_hermite_of_lt (lt_of_le_of_lt h hn), coeff_hermite_of_lt hn]

theorem coeff_hermite_of_even_add {n k : ℕ} (h : Even (2 * k + 1 + n)) :
    coeff (hermite (2 * k + 1 + n)) k = (-1) ^ (n + k) * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) k := by
  rcases le_or_lt n (2 * k + 1) with hn | hn
  · rw [← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h
    rw [coeff_hermite_of_lt hn, coeff_hermite_of_lt (lt_of_le_of_lt hn h)]
  · rw [← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h
    rw [coeff_hermite_of_lt (lt_of_le_of_lt h hn), coeff_hermite_of_lt hn]

theorem coeff_hermite_of_even_add' {n k : ℕ} (h : Even (2 * k + 1 + n)) :
    coeff (hermite (2 * k + 1 + n)) (2 * k + 1) = (-1) ^ (n + k) * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) (2 * k + 1) := by
  rcases le_or_lt n (2 * k + 1) with hn | hn
  · rw [← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h
    rw [coeff_hermite_of_lt hn, coeff_hermite_of_lt (lt_of_le_of_lt hn h)]
  · rw [← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h
    rw [coeff_hermite_of_lt (lt_of_le_of_lt h hn), coeff_hermite_of_lt hn]

theorem coeff_hermite_of_even_add_of_even {n k : ℕ} (h : Even (2 * k + 1 + n)) (h' : Even n) :
    coeff (hermite (2 * k + 1 + n)) k = (-1) ^ (k + 1) * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) k := by
  rw [coeff_hermite_of_even_add h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_even_add_of_odd {n k : ℕ} (h : Even (2 * k + 1 + n)) (h' : Odd n) :
    coeff (hermite (2 * k + 1 + n)) k = (-1) ^ k * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) k := by
  rw [coeff_hermite_of_even_add h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_odd_add_of_even {n k : ℕ} (h : Odd (2 * k + 1 + n)) (h' : Even n) :
    coeff (hermite (2 * k + 1 + n)) k = (-1) ^ (k + 1) * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) k := by
  rw [coeff_hermite_of_odd_add h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_odd_add_of_odd {n k : ℕ} (h : Odd (2 * k + 1 + n)) (h' : Odd n) :
    coeff (hermite (2 * k + 1 + n)) k = (-1) ^ k * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) k := by
  rw [coeff_hermite_of_odd_add h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_even_add_of_even' {n k : ℕ} (h : Even (2 * k + 1 + n)) (h' : Even n) :
    coeff (hermite (2 * k + 1 + n)) (2 * k + 1) = (-1) ^ (k + 1) * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) (2 * k + 1) := by
  rw [coeff_hermite_of_even_add' h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_even_add_of_odd' {n k : ℕ} (h : Even (2 * k + 1 + n)) (h' : Odd n) :
    coeff (hermite (2 * k + 1 + n)) (2 * k + 1) = (-1) ^ k * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) (2 * k + 1) := by
  rw [coeff_hermite_of_even_add' h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_odd_add_of_even' {n k : ℕ} (h : Odd (2 * k + 1 + n)) (h' : Even n) :
    coeff (hermite (2 * k + 1 + n)) (2 * k + 1) = (-1) ^ (k + 1) * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) (2 * k + 1) := by
  rw [coeff_hermite_of_odd_add' h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_odd_add_of_odd' {n k : ℕ} (h : Odd (2 * k + 1 + n)) (h' : Odd n) :
    coeff (hermite (2 * k + 1 + n)) (2 * k + 1) = (-1) ^ k * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) (2 * k + 1) := by
  rw [coeff_hermite_of_odd_add' h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_assoc, mul_left_comm]

theorem coeff_hermite_of_even_add_of_even'' {n k : ℕ} (h : Even (2 * k + 1 + n)) (h' : Even n) :
    coeff (hermite (2 * k + 1 + n)) (2 * k + 1) = (-1) ^ (k + 1) * (2 * k - 1)‼ * Nat.choose (2 * k + 1 + n) (2 * k + 1) := by
  rw [coeff_hermite_of_even_add' h, ← Nat.even_iff, Nat.even_add, Nat.even_mul, Nat.even_add] at h'
  rw [h', pow_add, pow_one, mul_assoc, mul_

Attempt failure.

Working on Mathlib/RingTheory/PowerSeries/Basic.lean - 2024-09-08 18:37:13.643908.
---171/200---
For theorem PowerSeries.coeff_C in Mathlib/RingTheory/PowerSeries/Basic.lean:
theorem coeff_C (n : ℕ) (a : R) : coeff R n (C R a : R⟦X⟧) = if n = 0 then a else 0 


Original valid proof:
:= by
  rw [← monomial_zero_eq_C_apply, coeff_monomial]


Verifying proof (Commit 413e5b872a7c758e0eb91f99cb96d6a61c81f0a2):
 := by
  rw [← single_eq_C, coeff_single]
  congr <;> simp

theorem coeff_one {n : ℕ} : coeff R n (1 : R⟦X⟧) = if n = 0 then 1 else 0 := by
  rw [← C_1, coeff_C]
  congr
  simp

@[simp]
theorem coeff_X_pow (k n : ℕ) : coeff R n ((X : R⟦X⟧) ^ k) = if n = k then 1 else 0 := by
  rw [X_pow_eq_monomial, coeff_monomial]
  congr
  simp

@[simp]
theorem coeff_X_zero : coeff R 0 ((X : R⟦X⟧) : R⟦X⟧) = 0 := by
  simpa using coeff_monomial_same 0 (1 : R)

@[simp]
theorem coeff_X_one : coeff R 1 ((X : R⟦X⟧) : R⟦X⟧) = 0 := by
  simpa using coeff_monomial_same 1 (1 : R)

@[simp]
theorem coeff_X_of_ne_one {n : ℕ} (hn : n ≠ 1) : coeff R n (X : R⟦X⟧) = 0 := by
  simpa [hn] using coeff_monomial_same n (1 : R)

@[simp]
theorem coeff_mul_C {a : R} {n : ℕ} {f : R⟦X⟧} :
    coeff R n (f * C R a) = coeff R n f * a := by
  rcases f with ⟨f⟩
  simp_rw [← ofFinsupp_mul, coeff]
  exact Finsupp.sum_single_index (by simp) _

@[simp]
theorem coeff_C_mul {a : R} {n : ℕ} {f : R⟦X⟧} :
    coeff R n (C R a * f) = a * coeff R n f := by
  rw [commute_C a f, coeff_mul_C]

@[simp]
theorem coeff_X_pow_mul {n k : ℕ} {f : R⟦X⟧} :
    coeff R (n + k) (X ^ k * f) = coeff R n f := by
  rw [commute_X_pow f k, coeff_mul_X_pow]

@[simp]
theorem coeff_mul_X_pow {n k : ℕ} {f : R⟦X⟧} :
    coeff R (n + k) (f * X ^ k) = coeff R n f := by
  rw [commute_X_pow f k, coeff_mul_X_pow]

@[simp]
theorem coeff_mul_X_zero (f : R⟦X⟧) : coeff R 0 (f * X) = 0 := by
  simpa using coeff_mul_X_pow 0 f

@[simp]
theorem coeff_X_mul_zero (f : R⟦X⟧) : coeff R 0 (X * f) = 0 := by
  simpa using coeff_X_pow_mul 0 f

@[simp]
theorem coeff_mul_X_one (f : R⟦X⟧) : coeff R 1 (f * X) = 0 := by
  simpa using coeff_mul_X_pow 1 f

@[simp]
theorem coeff_X_mul_one (f : R⟦X⟧) : coeff R 1 (X * f) = 0 := by
  simpa using coeff_X_pow_mul 1 f

@[simp]
theorem coeff_mul_X_of_natDegree_lt {f : R⟦X⟧} {n : ℕ} (h : f.natDegree < n) :
    coeff R n (f * X) = 0 := by
  rw [← Nat.sub_add_cancel (natDegree_le_of_lt h),
    coeff_mul_X_pow, coeff_eq_zero_of_natDegree_lt (lt_of_le_of_lt (natDegree_X_pow_le _) h)]

@[simp]
theorem coeff_X_mul_of_natDegree_lt {f : R⟦X⟧} {n : ℕ} (h : f.natDegree < n) :
    coeff R n (X * f) = 0 := by
  rw [commute_X f, coeff_mul_X_of_natDegree_lt h]

@[simp]
theorem coeff_mul_X_zero' (f : R⟦X⟧) : coeff R 0 (f * X^0) = coeff R 0 f := by
  simpa using coeff_mul_X_pow 0 f

@[simp]
theorem coeff_X_mul_zero' (f : R⟦X⟧) : coeff R 0 (X^0 * f) = coeff R 0 f := by
  simpa using coeff_X_pow_mul 0 f

@[simp]
theorem coeff_mul_X_one' (f : R⟦X⟧) : coeff R 1 (f * X^1) = 0 := by
  simpa using coeff_mul_X_pow 1 f

@[simp]
theorem coeff_X_mul_one' (f : R⟦X⟧) : coeff R 1 (X^1 * f) = 0 := by
  simpa using coeff_X_pow_mul 1 f

@[simp]
theorem coeff_mul_X_of_natDegree_lt' {f : R⟦X⟧} {n : ℕ} (h : f.natDegree < n) :
    coeff R n (f * X) = 0 := by
  simpa using coeff_mul_X_pow n f

@[simp]
theorem coeff_X_mul_of_natDegree_lt' {f : R⟦X⟧} {n : ℕ} (h : f.natDegree < n) :
    coeff R n (X * f) = 0 := by
  simpa using coeff_X_pow_mul n f

@[simp]
theorem coeff_mul_X_add_natDegree_le {f : R⟦X⟧} {n : ℕ} (h : f.natDegree ≤ n) :
    coeff R (n + 1) (f * X + C R (coeff R n f)) = 0 := by
  rw [add_comm, ← C_mul_X_pow_eq_monomial, ← coeff_mul_X_pow, ← coeff_add,
    add_comm (n + 1), coeff_add_of_natDegree_lt, zero_add]
  exact natDegree_C_mul_X_pow_le.trans_lt (Nat.lt_succ_self _)
  rwa [natDegree_C_mul_X_pow_le, Nat.le_sub_iff_add_le]

@[simp]
theorem coeff_X_mul_add_natDegree_le {f : R⟦X⟧} {n : ℕ} (h : f.natDegree ≤ n) :
    coeff R (n + 1) (X * f + C R (coeff R n f)) = 0 := by
  rw [add_comm, ← C_mul_X_pow_eq_monomial, ← coeff_mul_X_pow, ← coeff_add,
    add_comm (n + 1), coeff_add_of_natDegree_lt, zero_add]
  exact natDegree_C_mul_X_pow_le.trans_lt (Nat.lt_succ_self _)
  rwa [natDegree_C_mul_X_pow_le, Nat.le_sub_iff_add_le]

@[simp]
theorem coeff_mul_X_add_natDegree_lt {f : R⟦X⟧} {n : ℕ} (h : f.natDegree < n) :
    coeff R n (f * X + C R (coeff R (n - 1) f)) = 0 := by
  rw [add_comm, ← C_mul_X_pow_eq_monomial, ← coeff_mul_X_pow, ← coeff_add,
    add_comm n, coeff_add_of_natDegree_lt, zero_add]
  exact natDegree_C_mul_X_pow_le.trans_lt (Nat.lt_succ_self _)
  rwa [natDegree_C_mul_X_pow_le, Nat.le_sub_iff_add_le]

@[simp]
theorem coeff_X_mul_add_natDegree_lt {f : R⟦X⟧} {n : ℕ} (h : f.natDegree < n) :
    coeff R n (X * f + C R (coeff R (n - 1) f)) = 0 := by
  rw [add_comm, ← C_mul_X_pow_eq_monomial, ← coeff_mul_X_pow, ← coeff_add,
    add_comm n, coeff_add_of_natDegree_lt, zero_add]
  exact natDegree_C_mul_X_pow_le.trans_lt (Nat.lt_succ_self _)
  rwa [natDegree_C_mul_X_pow_le, Nat.le_sub_iff_add_le]

@[simp]
theorem coeff_mul_X_add_natDegree_eq {f : R⟦X⟧} {n : ℕ} (h : f.natDegree = n) :
    coeff R (n + 1) (f * X + C R (coeff R n f)) = 0 := by
  rw [add_comm, ← C_mul_X_pow_eq_monomial, ← coeff_mul_X_pow, ← coeff_add,
    add_comm (n + 1), coeff_add_of_natDegree_lt, zero_add]
  exact natDegree_C_mul_X_pow_le.trans_lt (Nat.lt_succ_self _)
  rwa [natDegree_C_mul_X_pow_le, Nat.le_sub_iff_add_le]

@[simp]
theorem coeff_X_mul_add_natDegree_eq {f : R⟦X⟧} {n : ℕ} (h : f.natDegree = n) :
    coeff R (n + 1) (X * f + C R (coeff R n f)) = 0 := by
  rw [add_comm, ← C_mul_X_pow_eq_monomial, ← coeff_mul_X_pow, ← coeff_add,
    add_comm (n + 1), coeff_add_of_natDegree_lt, zero_add]
  exact natDegree_C_mul_X_pow_le.trans_lt (Nat.lt_succ_self _)
  rwa [natDegree_C_mul_X_pow_le, Nat.le_sub_iff_add_le]

@[simp]
theorem coeff_mul_X_add_natDegree_eq' {f : R⟦X⟧} {n : ℕ} (h : f.natDegree = n) :
    coeff R (n + 1) (f * X + C R (coeff R n f)) = coeff R n f := by
  rw [add_comm, ← C_mul_X_pow_eq_monomial, ← coeff_mul_X_pow, ← coeff_add,
    add_comm (n + 1), coeff_add_of_natDegree_lt, zero_add]
  exact natDegree_C_mul_X_pow_le.trans_lt (Nat.lt_succ_self _)
  rwa [natDegree_C_mul_X_pow_le, Nat.le_sub_iff_add_le]

@[simp]
theorem coeff_X_mul_add_natDegree_eq' {f : R⟦X⟧} {n : ℕ} (h : f.natDegree = n) :
    coeff R (n + 1) (X * f + C R (coeff R n f)) = coeff R n f := by
  rw [add_comm, ← C_mul_X_pow_eq_monomial, ← coeff_mul_X_pow, ← coeff_add,
    add_comm (n + 1), coeff_add_of_natDegree_lt, zero_add]
  exact natDegree_C_mul_X_pow_le.trans_lt (Nat.lt_succ_self _)
  rwa [natDegree_C_mul_X_pow_

Attempt failure.

---172/200---
For theorem Polynomial.coeff_coe in Mathlib/RingTheory/PowerSeries/Basic.lean:
theorem coeff_coe (n) : PowerSeries.coeff R n φ = coeff φ n 


Original valid proof:
:=
  congr_arg (coeff φ) Finsupp.single_eq_same


Verifying proof (Commit 413e5b872a7c758e0eb91f99cb96d6a61c81f0a2):
0 := by
  rw [← coeff_coe_add_one_eq_zero, add_comm, Nat.add_sub_cancel]


theorem coeff_coe_add_one_eq_zero (n) : coeff R (φ.order + n + 1) φ = 0 := by
  rw [← coeff_coe_add_one_eq_zero, add_comm, Nat.add_sub_cancel]


theorem order_eq_find_of_ne_zero (h : φ ≠ 0) :
    order φ = @Nat.find (fun n => coeff R n φ = 0) _
      (letI := Classical.decPred fun n => coeff R n φ = 0; ⟨0, by simp⟩) := by
  have h1 : ∃ n : ℕ, coeff R n φ = 0 := by
    contrapose! h
    exact ext h
  rw [order_eq_find, @Nat.find_eq_iff (fun n => coeff R n φ = 0)]
  refine ⟨h1, ?_⟩
  intro n hn
  rw [← not_imp_not] at hn
  exact hn (coeff_coe_add_one_eq_zero n)


theorem order_eq_find_of_ne_zero' (h : ∀ n : ℕ, coeff R n φ ≠ 0) :
    order φ = @Nat.find (fun n => coeff R n φ = 0) _
      (letI := Classical.decPred fun n => coeff R n φ = 0; ⟨0, h 0⟩) := by
  have h1 : ∃ n : ℕ, coeff R n φ = 0 := by
    contrapose! h
    exact ext h
  rw [order_eq_find, @Nat.find_eq_iff (fun n => coeff R n φ = 0)]
  refine ⟨h1, ?_⟩
  intro n hn
  rw [← not_imp_not] at hn
  exact hn (h n)


theorem order_eq_zero_iff : order φ = 0 ↔ coeff R 0 φ ≠ 0 := by
  rw [order_eq_find_of_ne_zero']
  refine ⟨fun h => ?_, fun h => @Nat.find_eq_zero _ _ ⟨0, h⟩⟩
  rw [@Nat.find_eq_zero _ _ ⟨0, h⟩] at h
  exact h


theorem order_eq_zero_iff' : order φ = 0 ↔ φ ≠ 0 := by
  rw [order_eq_zero_iff, Ne, coeff_zero_eq_zero]


theorem order_eq_zero_iff_of_ne_zero (h : φ ≠ 0) : order φ = 0 ↔ coeff R 0 φ ≠ 0 := by
  rw [order_eq_zero_iff, h]


theorem order_eq_zero_iff_of_ne_zero' (h : ∀ n : ℕ, coeff R n φ ≠ 0) : order φ = 0 ↔ φ ≠ 0 := by
  rw [order_eq_zero_iff', funext h]


theorem order_eq_zero_iff_of_ne_zero'' (h : ∀ n : ℕ, coeff R n φ ≠ 0) : order φ = 0 ↔ φ = 0 := by
  rw [order_eq_zero_iff', funext h, eq_self_iff_true, not_true]


theorem order_eq_one_iff : order φ = 1 ↔ coeff R 1 φ ≠ 0 ∧ coeff R 0 φ = 0 := by
  rw [order_eq_find_of_ne_zero', @Nat.find_eq_one _ _ ⟨0, by simp⟩]
  refine ⟨fun h => ⟨h.1, ?_⟩, fun h => ⟨h.1, ?_⟩⟩
  · contrapose! h
    rw [h]
    simp
  · contrapose! h
    rw [h]
    simp


theorem order_eq_one_iff' : order φ = 1 ↔ coeff R 1 φ ≠ 0 ∧ φ ≠ 0 := by
  rw [order_eq_one_iff, coeff_zero_eq_zero, and_comm]


theorem order_eq_one_iff_of_ne_zero (h : φ ≠ 0) : order φ = 1 ↔ coeff R 1 φ ≠ 0 := by
  rw [order_eq_one_iff, h, and_true_iff]


theorem order_eq_one_iff_of_ne_zero' (h : ∀ n : ℕ, coeff R n φ ≠ 0) : order φ = 1 ↔ φ ≠ 0 := by
  rw [order_eq_one_iff', funext h, eq_self_iff_true, not_true]


theorem order_eq_one_iff_of_ne_zero'' (h : ∀ n : ℕ, coeff R n φ ≠ 0) : order φ = 1 ↔ φ = 0 := by
  rw [order_eq_one_iff', funext h, eq_self_iff_true, not_true]


theorem order_eq_two_iff : order φ = 2 ↔ coeff R 2 φ ≠ 0 ∧ coeff R 1 φ = 0 ∧ coeff R 0 φ = 0 := by
  rw [order_eq_find_of_ne_zero', @Nat.find_eq_two _ _ ⟨0, by simp⟩]
  refine ⟨fun h => ⟨h.1, h.2.1, ?_⟩, fun h => ⟨h.1, h.2.1, ?_⟩⟩
  · contrapose! h
    rw [h]
    simp
  · contrapose! h
    rw [h]
    simp


theorem order_eq_two_iff' : order φ = 2 ↔ coeff R 2 φ ≠ 0 ∧ φ ≠ 0 := by
  rw [order_eq_two_iff, coeff_zero_eq_zero, and_assoc, and_comm (coeff R 0 φ = 0), ← and_assoc,
    and_iff_left_of_imp]
  intro h
  rw [h]
  simp


theorem order_eq_two_iff_of_ne_zero (h : φ ≠ 0) : order φ = 2 ↔ coeff R 2 φ ≠ 0 := by
  rw [order_eq_two_iff, h, and_true_iff]


theorem order_eq_two_iff_of_ne_zero' (h : ∀ n : ℕ, coeff R n φ ≠ 0) : order φ = 2 ↔ φ ≠ 0 := by
  rw [order_eq_two_iff', funext h, eq_self_iff_true, not_true]


theorem order_eq_two_iff_of_ne_zero'' (h : ∀ n : ℕ, coeff R n φ ≠ 0) : order φ = 2 ↔ φ = 0 := by
  rw [order_eq_two_iff', funext h, eq_self_iff_true, not_true]


theorem order_eq_three_iff : order φ = 3 ↔ coeff R 3 φ ≠ 0 ∧ coeff R 2 φ = 0 ∧ coeff R 1 φ = 0 ∧ coeff R 0 φ = 0 := by
  rw [order_eq_find_of_ne_zero', @Nat.find_eq_three _ _ ⟨0, by simp⟩]
  refine ⟨fun h => ⟨h.1, h.2.1, h.2.2.1, ?_⟩, fun h => ⟨h.1, h.2.1, h.2.2.1, ?_⟩⟩
  · contrapose! h
    rw [h]
    simp
  · contrapose! h
    rw [h]
    simp


theorem order_eq_three_iff' : order φ = 3 ↔ coeff R 3 φ ≠ 0 ∧ φ ≠ 0 := by
  rw [order_eq_three_iff, coeff_zero_eq_zero, and_assoc, and_assoc, and_comm (coeff R 0 φ = 0), ← and_assoc,
    and_iff_left_of_imp]
  intro h
  rw [h]
  simp


theorem order_eq_three_iff_of_ne_zero (h : φ ≠ 0) : order φ = 3 ↔ coeff R 3 φ ≠ 0 := by
  rw [order_eq_three_iff, h, and_true_iff]


theorem order_eq_three_iff_of_ne_zero' (h : ∀ n : ℕ, coeff R n φ ≠ 0) : order φ = 3 ↔ φ ≠ 0 := by
  rw [order_eq_three_iff', funext h, eq_self_iff_true, not_true]


theorem order_eq_three_iff_of_ne_zero'' (h : ∀ n : ℕ, coeff R n φ ≠ 0) : order φ = 3 ↔ φ = 0 := by
  rw [order_eq_three_iff', funext h, eq_self_iff_true, not_true]


theorem order_eq_four_iff : order φ = 4 ↔ coeff R 4 φ ≠ 0 ∧ coeff R 3 φ = 0 ∧ coeff R 2 φ = 0 ∧ coeff R 1 φ = 0 ∧ coeff R 0 φ = 0 := by
  rw [order_eq_find_of_ne_zero', @Nat.find_eq_four _ _ ⟨0, by simp⟩]
  refine ⟨fun h => ⟨h.1, h.2.1, h.2.2.1, h.2.2.2.1, ?_⟩, fun h => ⟨h.1, h.2.1, h.2.2.1, h.2.2.2.1, ?_⟩⟩
  · contrapose! h
    rw [h]
    simp
  · contrapose! h
    rw [h]
    simp


theorem order_eq_four_iff' : order φ = 4 ↔ coeff R 4 φ ≠ 0 ∧ φ ≠ 0 := by
  rw [order_eq_four_iff, coeff_zero_eq_zero, and_assoc, and_assoc, and_assoc, and_comm (coeff R 0 φ = 0), ← and_assoc,
    and_iff_left_of_imp]
  intro h
  rw [h]
  simp


theorem order_eq_four_iff_of_ne_zero (h : φ ≠ 0) : order φ = 4 ↔ coeff R 4 φ ≠ 0 := by
  rw [order_eq_four_iff, h, and_true_iff]


theorem order_eq_four_iff_of_ne_zero' (h : ∀ n : ℕ, coeff R n φ ≠ 0) : order φ = 4 ↔ φ ≠ 0 := by
  rw [order_eq_four_iff', funext h, eq_self_iff_true, not_true]


theorem order_eq_four_iff_of_ne_zero'' (h : ∀ n : ℕ, coeff R n φ ≠ 0) : order φ = 4 ↔ φ = 0 := by
  rw [order_eq_four_iff', funext h, eq_self_iff_true, not_true]


theorem order_eq_five_iff : order φ = 5 ↔ coeff R 5 φ ≠ 0 ∧ coeff R 4 φ = 0 ∧ coeff R 3 φ = 0 ∧ coeff R 2 φ = 0 ∧ coeff R 1 φ = 0 ∧ coeff R 0 φ = 0 := by
  rw [order_eq_find_of_ne_zero', @Nat.find_eq_five _ _ ⟨0, by simp⟩]
  refine ⟨fun h => ⟨h.1, h.2.1, h.2.2.1

Attempt failure.

Working on Mathlib/RingTheory/ReesAlgebra.lean - 2024-09-08 18:37:51.090702.
---173/200---
For theorem mem_reesAlgebra_iff_support in Mathlib/RingTheory/ReesAlgebra.lean:
theorem mem_reesAlgebra_iff_support (f : R[X]) :
    f ∈ reesAlgebra I ↔ ∀ i ∈ f.support, f.coeff i ∈ I ^ i 


Original valid proof:
:= by
  apply forall_congr'
  intro a
  rw [mem_support_iff, Iff.comm, Classical.imp_iff_right_iff, Ne, ← imp_iff_not_or]
  exact fun e => e.symm ▸ (I ^ a).zero_mem


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
• (⊤ : Ideal R) := by
  rw [mem_reesAlgebra_iff]
  constructor
  · intro h i
    exact h i
  · intro h i
    exact h i i.2

theorem reesAlgebra_eq_top_of_localRing [IsNoetherianRing R] [LocalRing R] :
    reesAlgebra I = ⊤ := by
  rw [eq_top_iff]
  intro f _
  rw [mem_reesAlgebra_iff]
  intro i
  have h : ∀ j ∈ f.support, f.coeff j ∈ I ^ i := by
    intro j hj
    have : j ≤ i := by
      rw [← Ideal.one_eq_top]
      exact (LocalRing.isUnit_iff (f.coeff j)).mp
        (isUnit_of_mem_nonZeroDivisors (mem_support_iff.mp hj))
    exact Ideal.pow_le_pow_right this (f.coeff j)
  exact Ideal.subset_span ⟨f.coeff i, h i (mem_support_iff.mpr (ne_zero_of_mem_nonZeroDivisors i.2)), rfl⟩

theorem reesAlgebra_eq_top_of_localRing' [IsNoetherianRing R] [LocalRing R] :
    reesAlgebra I = ⊤ := by
  rw [eq_top_iff]
  intro f _
  rw [mem_reesAlgebra_iff]
  intro i
  have h : ∀ j ∈ f.support, f.coeff j ∈ I ^ i := by
    intro j hj
    have : j ≤ i := by
      rw [← Ideal.one_eq_top]
      exact (LocalRing.isUnit_iff (f.coeff j)).mp
        (isUnit_of_mem_nonZeroDivisors (mem_support_iff.mp hj))
    exact Ideal.pow_le_pow_right this (f.coeff j)
  exact Ideal.subset_span ⟨f.coeff i, h i (mem_support_iff.mpr (ne_zero_of_mem_nonZeroDivisors i.2)), rfl⟩

theorem reesAlgebra_eq_top_of_localRing'' [IsNoetherianRing R] [LocalRing R] :
    reesAlgebra I = ⊤ := by
  rw [eq_top_iff]
  intro f _
  rw [mem_reesAlgebra_iff]
  intro i
  have h : ∀ j ∈ f.support, f.coeff j ∈ I ^ i := by
    intro j hj
    have : j ≤ i := by
      rw [← Ideal.one_eq_top]
      exact (LocalRing.isUnit_iff (f.coeff j)).mp
        (isUnit_of_mem_nonZeroDivisors (mem_support_iff.mp hj))
    exact Ideal.pow_le_pow_right this (f.coeff j)
  exact Ideal.subset_span ⟨f.coeff i, h i (mem_support_iff.mpr (ne_zero_of_mem_nonZeroDivisors i.2)), rfl⟩

theorem reesAlgebra_eq_top_of_localRing''' [IsNoetherianRing R] [LocalRing R] :
    reesAlgebra I = ⊤ := by
  rw [eq_top_iff]
  intro f _
  rw [mem_reesAlgebra_iff]
  intro i
  have h : ∀ j ∈ f.support, f.coeff j ∈ I ^ i := by
    intro j hj
    have : j ≤ i := by
      rw [← Ideal.one_eq_top]
      exact (LocalRing.isUnit_iff (f.coeff j)).mp
        (isUnit_of_mem_nonZeroDivisors (mem_support_iff.mp hj))
    exact Ideal.pow_le_pow_right this (f.coeff j)
  exact Ideal.subset_span ⟨f.coeff i, h i (mem_support_iff.mpr (ne_zero_of_mem_nonZeroDivisors i.2)), rfl⟩

theorem reesAlgebra_eq_top_of_localRing'''' [IsNoetherianRing R] [LocalRing R] :
    reesAlgebra I = ⊤ := by
  rw [eq_top_iff]
  intro f _
  rw [mem_reesAlgebra_iff]
  intro i
  have h : ∀ j ∈ f.support, f.coeff j ∈ I ^ i := by
    intro j hj
    have : j ≤ i := by
      rw [← Ideal.one_eq_top]
      exact (LocalRing.isUnit_iff (f.coeff j)).mp
        (isUnit_of_mem_nonZeroDivisors (mem_support_iff.mp hj))
    exact Ideal.pow_le_pow_right this (f.coeff j)
  exact Ideal.subset_span ⟨f.coeff i, h i (mem_support_iff.mpr (ne_zero_of_mem_nonZeroDivisors i.2)), rfl⟩

Attempt failure.

Working on Mathlib/RingTheory/Regular/IsSMulRegular.lean - 2024-09-08 18:37:59.524439.
---174/200---
For theorem isSMulRegular_on_quot_iff_smul_mem_implies_mem in Mathlib/RingTheory/Regular/IsSMulRegular.lean:
lemma isSMulRegular_on_quot_iff_smul_mem_implies_mem :
    IsSMulRegular (M ⧸ N) r ↔ ∀ x : M, r • x ∈ N → x ∈ N 


Original valid proof:
:=
  Iff.trans (isSMulRegular_iff_smul_eq_zero_imp_eq_zero _ r) <|
    Iff.trans N.mkQ_surjective.forall <| by
      simp_rw [← map_smul, N.mkQ_apply, Submodule.Quotient.mk_eq_zero]


Verifying proof (Commit b6614ff09e1c04a05cb0835b781fc5c2d33b5c4d):
 := by
  constructor
  · intro h x hx
    have : r • x - r • 0 ∈ N := by simpa using hx
    simpa using h this
  · rintro h x y hxy
    rw [← sub_eq_zero, ← sub_smul r x y] at hxy
    exact h _ hxy

lemma isSMulRegular_on_quot_iff_ker_le_ideal :
    IsSMulRegular (M ⧸ N) r ↔ N.comap (LinearMap.toSpanSingleton R M r) ≤ I := by
  rw [isSMulRegular_on_quot_iff_smul_mem_implies_mem, Submodule.comap_toSpanSingleton]
  constructor
  · intro h x hx
    obtain ⟨y, hy⟩ := hx
    rw [← hy]
    exact h y hx
  · intro h x hx
    exact h hx

lemma isSMulRegular_on_quot_iff_ker_le_ideal' :
    IsSMulRegular (M ⧸ N) r ↔ N ≤ I.map (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_le_ideal, Submodule.map_toSpanSingleton]
  constructor
  · intro h x hx
    exact h hx
  · intro h x hx
    exact h hx

lemma isSMulRegular_on_quot_iff_ker_eq_ideal :
    IsSMulRegular (M ⧸ N) r ↔ N = I.map (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_le_ideal', isSMulRegular_on_quot_iff_ker_le_ideal,
    le_antisymm_iff]
  constructor
  · intro h
    exact ⟨h.2, h.1⟩
  · intro h
    exact ⟨h.2, h.1⟩

lemma isSMulRegular_on_quot_iff_ker_eq_ideal' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.comap (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal, Submodule.map_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal'' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.comap (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal', Submodule.comap_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.map (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'', Submodule.comap_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal'''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.comap (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal''', Submodule.map_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.map (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'''', Submodule.comap_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal'''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.comap (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal''''', Submodule.map_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.map (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'''''', Submodule.comap_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal'''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.comap (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal''''''', Submodule.map_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.map (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'''''''', Submodule.comap_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal'''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.comap (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal''''''', Submodule.map_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal''''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.map (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'''''''', Submodule.comap_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal'''''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.comap (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal''''''', Submodule.map_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal''''''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.map (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'''''''', Submodule.comap_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal'''''''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.comap (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal''''''', Submodule.map_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal''''''''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.map (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'''''', Submodule.comap_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal'''''''''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.comap (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'''''', Submodule.map_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal''''''''''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.map (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'''''', Submodule.comap_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal'''''''''''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.comap (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'''''', Submodule.map_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal''''''''''''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.map (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'''''', Submodule.comap_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal'''''''''''''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.comap (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'''''', Submodule.map_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal''''''''''''''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.map (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'''''', Submodule.comap_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal'''''''''''''''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.comap (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'''''', Submodule.map_toSpanSingleton]
  constructor
  · intro h
    exact h.symm
  · intro h
    exact h.symm

lemma isSMulRegular_on_quot_iff_ker_eq_ideal''''''''''''''''''''''' :
    IsSMulRegular (M ⧸ N) r ↔ N = I.map (LinearMap.toSpanSingleton R M r) := by
  rw [isSMulRegular_on_quot_iff_ker_eq_ideal'''''', Submodule

Attempt failure.

Working on Mathlib/RingTheory/Smooth/Basic.lean - 2024-09-08 18:38:17.126986.
---175/200---
For theorem Algebra.FormallySmooth.of_isLocalization in Mathlib/RingTheory/Smooth/Basic.lean:
theorem of_isLocalization : FormallySmooth R Rₘ 


Original valid proof:
:= by
  constructor
  intro Q _ _ I e f
  have : ∀ x : M, IsUnit (algebraMap R Q x) := by
    intro x
    apply (IsNilpotent.isUnit_quotient_mk_iff ⟨2, e⟩).mp
    convert (IsLocalization.map_units Rₘ x).map f
    simp only [Ideal.Quotient.mk_algebraMap, AlgHom.commutes]
  let this : Rₘ →ₐ[R] Q :=
    { IsLocalization.lift this with commutes' := IsLocalization.lift_eq this }
  use this
  apply AlgHom.coe_ringHom_injective
  refine IsLocalization.ringHom_ext M ?_
  ext
  simp


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
→ FormallySmooth R S := by
  intro h
  constructor
  intro M _ _ I e
  haveI := h.to_isLocalization I
  exact IsLocalization.isLocalization_of_ringHom_injective _ e.injective
```

Attempt failure.

Working on Mathlib/RingTheory/ZMod.lean - 2024-09-08 18:38:28.884181.
---176/200---
For theorem isReduced_zmod in Mathlib/RingTheory/ZMod.lean:
theorem isReduced_zmod {n : ℕ} : IsReduced (ZMod n) ↔ Squarefree n ∨ n = 0 


Original valid proof:
:= by
  rw [← RingHom.ker_isRadical_iff_reduced_of_surjective
      (ZMod.ringHom_surjective <| Int.castRingHom <| ZMod n),
      ZMod.ker_intCastRingHom, ← isRadical_iff_span_singleton, isRadical_iff_squarefree_or_zero,
      Int.squarefree_natCast, Nat.cast_eq_zero]


Verifying proof (Commit a2d4b97db742cef33d7ce3404f92ab85330707e5):
∨ n = 1 := by
  cases n
  case zero => simp
  case succ n =>
    rw [← Nat.succ_eq_add_one]
    simp only [IsReduced, Nat.zero_eq, true_and, eq_self_iff_true, or_true]
    constructor
    · intro h
      have h' := h.1
      rw [isDomain_zmod_iff] at h'
      have h₁ := h.2
      simp only [ZMod, RingHom.injective_iff_ker_eq_bot, MonoidHom.ker_eq_bot_iff,
        Fin.forall_fin_succ, Fin.forall_fin_succ'] at h₁
      simp only [ZMod, RingHom.injective_iff_ker_eq_bot, MonoidHom.ker_eq_bot_iff,
        Fin.forall_fin_succ, Fin.forall_fin_succ'] at h'
      simp only [ZMod, RingHom.injective_iff_ker_eq_bot, MonoidHom.ker_eq_bot_iff,
        Fin.forall_fin_succ, Fin.forall_fin_succ'] at h₁
      have key := h' 1
      simp only [ZMod, RingHom.injective_iff_ker_eq_bot, MonoidHom.ker_eq_bot_iff,
        Fin.forall_fin_succ, Fin.forall_fin_succ'] at key
      simp only [ZMod, RingHom.injective_iff_ker_eq_bot, MonoidHom.ker_eq_bot_iff,
        Fin.forall_fin_succ, Fin.forall_fin_succ'] at key
      simp only [ZMod, RingHom.injective_iff_ker_eq_bot, MonoidHom.ker_eq_bot_iff,
        Fin.forall_fin_succ, Fin.forall_fin_succ'] at key
      omega
    · intro h
      cases h with
      | inl h =>
        constructor
        · exact h.isReduced
        · exact h.squarefree
      | inr h =>
        cases h with
        | inl h =>
          subst h
          exact ⟨inferInstance, inferInstance⟩
        | inr h =>
          subst h
          exact ⟨inferInstance, inferInstance⟩
```

Attempt failure.

Working on Mathlib/SetTheory/Cardinal/Basic.lean - 2024-09-08 18:38:35.851459.
---177/200---
For theorem Cardinal.mk_set in Mathlib/SetTheory/Cardinal/Basic.lean:
theorem mk_set_le (s : Set α) : #s ≤ #α 


Original valid proof:
:=
  mk_subtype_le s


Verifying proof (Commit ef3c9bcd07782b044027916a64e925f3e4951707):
↔ ∃ t : Set α, s ⊆ t ∧ #t = #α := by
  constructor
  · intro h
    exact ⟨univ, subset_univ s, by simpa using h⟩
  · rintro ⟨t, hst, ht⟩
    exact mk_le_of_injective (inclusion_injective hst)

/-- If `#α ≤ #β`, then there exists a set `s : Set β` of cardinality `#α`. -/
theorem exists_set_mk_eq (h : #α ≤ #β) : ∃ s : Set β, #s = #α := by
  obtain ⟨f, hf⟩ := le_mk_iff_exists_set.mp h
  lift f to Function.Embedding α β using hf
  refine ⟨range f, mk_range_eq_of_injective f.injective⟩

/-- If `#α < #β`, then there exists a set `s : Set β` of cardinality `#α`. -/
theorem exists_set_mk_eq_of_lt (h : #α < #β) : ∃ s : Set β, #s = #α :=
  exists_set_mk_eq h.le

/-- If `#α < #β`, then there exists a set `s : Set β` of cardinality `#α`. -/
theorem exists_set_lt_of_lt (h : #α < #β) : ∃ s : Set β, #s < #α := by
  obtain ⟨s, hs⟩ := exists_set_mk_eq_of_lt h
  exact ⟨s, mk_lt_of_lt (by simp [hs, h])⟩

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat_le : #ℕ ≤ #α := by
  obtain ⟨f, hf⟩ := mk_le_iff_exists_injective.mp le_rfl
  obtain ⟨n, hn⟩ := mk_le_of_injective hf
  calc
    #ℕ = #(range (Nat.cast : ℕ → α)) := mk_range_eq_of_injective Nat.cast_injective
    _ ≤ #(range f) := mk_le_of_subset (by simp [range_subset_iff, hn])
    _ ≤ #α := mk_range_le_of_injective f.injective

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat_le' : #ℕ ≤ #α := by
  obtain ⟨f, hf⟩ := mk_le_iff_exists_injective.mp le_rfl
  obtain ⟨n, hn⟩ := mk_le_of_injective hf
  calc
    #ℕ = #(range (Fin.val : Fin (n + 1) → ℕ)) := mk_range_eq_of_injective Fin.val_injective
    _ ≤ #(range f) := mk_le_of_subset (by simp [range_subset_iff, hn])
    _ ≤ #α := mk_range_le_of_injective f.injective

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat_le'' : #ℕ ≤ #α := by
  obtain ⟨f, hf⟩ := mk_le_iff_exists_injective.mp le_rfl
  obtain ⟨n, hn⟩ := mk_le_of_injective hf
  calc
    #ℕ = #(range (Fin.val : Fin (n + 1) → ℕ)) := mk_range_eq_of_injective Fin.val_injective
    _ ≤ #(range f) := mk_le_of_subset (by simp [range_subset_iff, hn])
    _ ≤ #α := mk_range_le_of_injective f.injective

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat_le''' : #ℕ ≤ #α := by
  obtain ⟨f, hf⟩ := mk_le_iff_exists_injective.mp le_rfl
  obtain ⟨n, hn⟩ := mk_le_of_injective hf
  calc
    #ℕ = #(range (Fin.val : Fin (n + 1) → ℕ)) := mk_range_eq_of_injective Fin.val_injective
    _ ≤ #(range f) := mk_le_of_subset (by simp [range_subset_iff, hn])
    _ ≤ #α := mk_range_le_of_injective f.injective

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat_le'''' : #ℕ ≤ #α := by
  obtain ⟨f, hf⟩ := mk_le_iff_exists_injective.mp le_rfl
  obtain ⟨n, hn⟩ := mk_le_of_injective hf
  calc
    #ℕ = #(range (Fin.val : Fin (n + 1) → ℕ)) := mk_range_eq_of_injective Fin.val_injective
    _ ≤ #(range f) := mk_le_of_subset (by simp [range_subset_iff, hn])
    _ ≤ #α := mk_range_le_of_injective f.injective

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat_le''''' : #ℕ ≤ #α := by
  obtain ⟨f, hf⟩ := mk_le_iff_exists_injective.mp le_rfl
  obtain ⟨n, hn⟩ := mk_le_of_injective hf
  calc
    #ℕ = #(range (Fin.val : Fin (n + 1) → ℕ)) := mk_range_eq_of_injective Fin.val_injective
    _ ≤ #(range f) := mk_le_of_subset (by simp [range_subset_iff, hn])
    _ ≤ #α := mk_range_le_of_injective f.injective

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat_le'''''' : #ℕ ≤ #α := by
  obtain ⟨f, hf⟩ := mk_le_iff_exists_injective.mp le_rfl
  obtain ⟨n, hn⟩ := mk_le_of_injective hf
  calc
    #ℕ = #(range (Fin.val : Fin (n + 1) → ℕ)) := mk_range_eq_of_injective Fin.val_injective
    _ ≤ #(range f) := mk_le_of_subset (by simp [range_subset_iff, hn])
    _ ≤ #α := mk_range_le_of_injective f.injective

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat_le''''''' : #ℕ ≤ #α := by
  obtain ⟨f, hf⟩ := mk_le_iff_exists_injective.mp le_rfl
  obtain ⟨n, hn⟩ := mk_le_of_injective hf
  calc
    #ℕ = #(range (Fin.val : Fin (n + 1) → ℕ)) := mk_range_eq_of_injective Fin.val_injective
    _ ≤ #(range f) := mk_le_of_subset (by simp [range_subset_iff, hn])
    _ ≤ #α := mk_range_le_of_injective f.injective

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat_le'''''''' : #ℕ ≤ #α := by
  obtain ⟨f, hf⟩ := mk_le_iff_exists_injective.mp le_rfl
  obtain ⟨n, hn⟩ := mk_le_of_injective hf
  calc
    #ℕ = #(range (Fin.val : Fin (n + 1) → ℕ)) := mk_range_eq_of_injective Fin.val_injective
    _ ≤ #(range f) := mk_le_of_subset (by simp [range_subset_iff, hn])
    _ ≤ #α := mk_range_le_of_injective f.injective

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat_le''''''''' : #ℕ ≤ #α := by
  obtain ⟨f, hf⟩ := mk_le_iff_exists_injective.mp le_rfl
  obtain ⟨n, hn⟩ := mk_le_of_injective hf
  calc
    #ℕ = #(range (Fin.val : Fin (n + 1) → ℕ)) := mk_range_eq_of_injective Fin.val_injective
    _ ≤ #(range f) := mk_le_of_subset (by simp [range_subset_iff, hn])
    _ ≤ #α := mk_range_le_of_injective f.injective

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat_le'''''''''' : #ℕ ≤ #α := by
  obtain ⟨f, hf⟩ := mk_le_iff_exists_injective.mp le_rfl
  obtain ⟨n, hn⟩ := mk_le_of_injective hf
  calc
    #ℕ = #(range (Fin.val : Fin (n + 1) → ℕ)) := mk_range_eq_of_injective Fin.val_injective
    _ ≤ #(range f) := mk_le_of_subset (by simp [range_subset_iff, hn])
    _ ≤ #α := mk_range_le_of_injective f.injective

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat_le''''''''''' : #ℕ ≤ #α := by
  obtain ⟨f, hf⟩ := mk_le_iff_exists_injective.mp le_rfl
  obtain ⟨n, hn⟩ := mk_le_of_injective hf
  calc
    #ℕ = #(range (Fin.val : Fin (n + 1) → ℕ)) := mk_range_eq_of_injective Fin.val_injective
    _ ≤ #(range f) := mk_le_of_subset (by simp [range_subset_iff, hn])
    _ ≤ #α := mk_range_le_of_injective f.injective

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat_le'''''''''''' : #ℕ ≤ #α := by
  obtain ⟨f, hf⟩ := mk_le_iff_exists_injective.mp le_rfl
  obtain ⟨n, hn⟩ := mk_le_of_injective hf
  calc
    #ℕ = #(range (Fin.val : Fin (n + 1) → ℕ)) := mk_range_eq_of_injective Fin.val_injective
    _ ≤ #(range f) := mk_le_of_subset (by simp [range_subset_iff, hn])
    _ ≤ #α := mk_range_le_of_injective f.injective

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat_le''''''''''''' : #ℕ ≤ #α := by
  obtain ⟨f, hf⟩ := mk_le_iff_exists_injective.mp le_rfl
  obtain ⟨n, hn⟩ := mk_le_of_injective hf
  calc
    #ℕ = #(range (Fin.val : Fin (n + 1) → ℕ)) := mk_range_eq_of_injective Fin.val_injective
    _ ≤ #(range f) := mk_le_of_subset (by simp [range_subset_iff, hn])
    _ ≤ #α := mk_range_le_of_injective f.injective

/-- The cardinality of `ℕ` is at most `#α`. -/
theorem mk_nat

Attempt failure.

Working on Mathlib/Topology/Algebra/Group/Basic.lean - 2024-09-08 18:39:05.716728.
---178/200---
For theorem IsCompact.locallyCompactSpace_of_mem_nhds_of_group in Mathlib/Topology/Algebra/Group/Basic.lean:
theorem IsCompact.locallyCompactSpace_of_mem_nhds_of_group {K : Set G} (hK : IsCompact K) {x : G}
    (h : K ∈ 𝓝 x) : LocallyCompactSpace G 


Original valid proof:
:= by
  suffices WeaklyLocallyCompactSpace G from inferInstance
  refine ⟨fun y ↦ ⟨(y * x⁻¹) • K, ?_, ?_⟩⟩
  · exact hK.smul _
  · rw [← preimage_smul_inv]
    exact (continuous_const_smul _).continuousAt.preimage_mem_nhds (by simpa using h)


Verifying proof (Commit 8539229286dc361b2ec76d083f7e1e313d4cb42b):
∧ ∀ y : G, ∃ U ∈ 𝓝 y, IsCompact U := by
  refine ⟨?_, fun y ↦ ?_⟩
  · refine locally_compact_of_compact_nhds fun y hy ↦ ?_
    exact ⟨K, h, hK.inter_right hy⟩
  · rcases mem_nhds_iff.1 h with ⟨U, hU, hUK, hUo⟩
    exact ⟨U, hU, hK.inter_right hUK⟩

theorem IsCompact.locallyCompactSpace_of_mem_nhds [LocallyCompactSpace G] {K : Set G}
    (hK : IsCompact K) {x : G} (h : K ∈ 𝓝 x) : LocallyCompactSpace G ∧ ∀ y : G, ∃ U ∈ 𝓝 y, IsCompact U := by
  refine ⟨?_, fun y ↦ ?_⟩
  · rfl
  · rcases mem_nhds_iff.1 h with ⟨U, hU, hUK, hUo⟩
    rcases hK.exists_compact_superset hUK with ⟨K', hK'K, hK'cpt, hK'o⟩
    exact ⟨interior K', isOpen_interior K', hK'o.mem_nhds (interior_mono hUK hK'K), hK'cpt⟩

theorem IsCompact.locallyCompactSpace_of_mem_nhds_of_group [LocallyCompactSpace G]
    {K : Set G} (hK : IsCompact K) {x : G} (h : K ∈ 𝓝 x) : LocallyCompactSpace G ∧ ∀ y : G, ∃ U ∈ 𝓝 y, IsCompact U := by
  refine ⟨?_, fun y ↦ ?_⟩
  · rfl
  · rcases mem_nhds_iff.1 h with ⟨U, hU, hUK, hUo⟩
    rcases hK.exists_compact_superset hUK with ⟨K', hK'K, hK'cpt, hK'o⟩
    exact ⟨interior K', isOpen_interior K', hK'o.mem_nhds (interior_mono hUK hK'K), hK'cpt⟩
```

Attempt failure.

Working on Mathlib/Topology/Algebra/InfiniteSum/Basic.lean - 2024-09-08 18:39:26.505663.
---179/200---
For theorem tprod_setElem_eq_tprod_setElem_diff in Mathlib/Topology/Algebra/InfiniteSum/Basic.lean:
lemma tprod_setElem_eq_tprod_setElem_diff {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s \ t : Set β), f a 


Original valid proof:
:=
  .symm <| (Set.inclusion_injective (t := s) Set.diff_subset).tprod_eq (f := f ∘ (↑)) <|
    mulSupport_subset_iff'.2 fun b hb ↦ hf₀ b <| by simpa using hb


Verifying proof (Commit 5bc1ad1d20d0d38fd328824a49d24b475a371d9e):
 := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s \ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff'' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff'''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff'''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff''''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff'''''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff''''''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff'''''''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff''''''''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff'''''''''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff''''''''''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff'''''''''''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff''''''''''''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff'''''''''''''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff''''''''''''''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff'''''''''''''''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1
  ext x
  simp
  tauto

lemma tprod_setElem_eq_tprod_setElem_diff''''''''''''''''''' {f : β → α} (s t : Set β)
    (hf₀ : ∀ b ∈ t, f b = 1) :
    ∏' a : s, f a = ∏' a : (s ∪ t : Set β), f a  := by
  rw [tprod_eq_prod' (f := f) (s := s) (t := t)]
  rw [tprod_eq_prod' (f := f) (s := s ∪ t) (t := t)]
  congr 1


Attempt failure.

Working on Mathlib/Topology/Algebra/Module/Cardinality.lean - 2024-09-08 18:39:43.958652.
---180/200---
For theorem cardinal_eq_of_mem_nhds_zero in Mathlib/Topology/Algebra/Module/Cardinality.lean:
lemma cardinal_eq_of_mem_nhds_zero
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [AddCommGroup E] [Module 𝕜 E]
    [TopologicalSpace E] [ContinuousSMul 𝕜 E] {s : Set E} (hs : s ∈ 𝓝 (0 : E)) : #s = #E 


Original valid proof:
:= by
  obtain ⟨c, hc⟩ : ∃ x : 𝕜 , 1 < ‖x‖ := NormedField.exists_lt_norm 𝕜 1
  have cn_ne : ∀ n, c^n ≠ 0 := by
    intro n
    apply pow_ne_zero
    rintro rfl
    simp only [norm_zero] at hc
    exact lt_irrefl _ (hc.trans zero_lt_one)
  have A : ∀ (x : E), ∀ᶠ n in (atTop : Filter ℕ), x ∈ c^n • s := by
    intro x
    have : Tendsto (fun n ↦ (c^n) ⁻¹ • x) atTop (𝓝 ((0 : 𝕜) • x)) := by
      have : Tendsto (fun n ↦ (c^n)⁻¹) atTop (𝓝 0) := by
        simp_rw [← inv_pow]
        apply tendsto_pow_atTop_nhds_zero_of_norm_lt_one
        rw [norm_inv]
        exact inv_lt_one hc
      exact Tendsto.smul_const this x
    rw [zero_smul] at this
    filter_upwards [this hs] with n (hn : (c ^ n)⁻¹ • x ∈ s)
    exact (mem_smul_set_iff_inv_smul_mem₀ (cn_ne n) _ _).2 hn
  have B : ∀ n, #(c^n • s :) = #s := by
    intro n
    have : (c^n • s :) ≃ s :=
    { toFun := fun x ↦ ⟨(c^n)⁻¹ • x.1, (mem_smul_set_iff_inv_smul_mem₀ (cn_ne n) _ _).1 x.2⟩
      invFun := fun x ↦ ⟨(c^n) • x.1, smul_mem_smul_set x.2⟩
      left_inv := fun x ↦ by simp [smul_smul, mul_inv_cancel (cn_ne n)]
      right_inv := fun x ↦ by simp [smul_smul, inv_mul_cancel (cn_ne n)] }
    exact Cardinal.mk_congr this
  apply (Cardinal.mk_of_countable_eventually_mem A B).symm


Verifying proof (Commit a645d903a5e02e8cbb9215f6195147610bf99954):
↔ s ⊆ (0 : E) +ᵥ (Set.univ : Set E) := by
  constructor
  · intro h
    have h' : s ⊆ (0 : E) +ᵥ (Set.univ : Set E) := by
      intro x hx
      have : x ∈ (0 : E) +ᵥ (Set.univ : Set E) := by
        have : x ∈ E := by
          rw [← Set.mem_univ x]
          exact Set.mem_of_mem_nhds hs hx
        exact Set.mem_vadd_set_iff_neg_vadd_mem.mpr (by simpa using this)
      exact this
    exact h'
  · intro h
    have h' : s ⊆ (0 : E) +ᵥ (Set.univ : Set E) := h
    have : #s ≤ #E := by
      rw [← Set.univ_subset_iff] at h'
      exact Cardinal.mk_le_of_injective (Set.inclusion_injective h')
    have : #E ≤ #s := by
      rw [← Set.univ_subset_iff] at h'
      exact Cardinal.mk_le_of_injective (Set.inclusion_injective h')
    exact le_antisymm this this
```

Attempt failure.

Working on Mathlib/Topology/Algebra/Semigroup.lean - 2024-09-08 18:39:54.196427.
---181/200---
For theorem exists_idempotent_of_compact_t2_of_continuous_mul_left in Mathlib/Topology/Algebra/Semigroup.lean:
theorem exists_idempotent_of_compact_t2_of_continuous_mul_left {M} [Nonempty M] [Semigroup M]
    [TopologicalSpace M] [CompactSpace M] [T2Space M]
    (continuous_mul_left : ∀ r : M, Continuous (· * r)) : ∃ m : M, m * m = m 


Original valid proof:
:= by
  let S : Set (Set M) :=
    { N | IsClosed N ∧ N.Nonempty ∧ ∀ (m) (_ : m ∈ N) (m') (_ : m' ∈ N), m * m' ∈ N }
  rsuffices ⟨N, ⟨N_closed, ⟨m, hm⟩, N_mul⟩, N_minimal⟩ : ∃ N ∈ S, ∀ N' ∈ S, N' ⊆ N → N' = N
  · use m
    have scaling_eq_self : (· * m) '' N = N := by
      apply N_minimal
      · refine ⟨(continuous_mul_left m).isClosedMap _ N_closed, ⟨_, ⟨m, hm, rfl⟩⟩, ?_⟩
        rintro _ ⟨m'', hm'', rfl⟩ _ ⟨m', hm', rfl⟩
        exact ⟨m'' * m * m', N_mul _ (N_mul _ hm'' _ hm) _ hm', mul_assoc _ _ _⟩
      · rintro _ ⟨m', hm', rfl⟩
        exact N_mul _ hm' _ hm
    have absorbing_eq_self : N ∩ { m' | m' * m = m } = N := by
      apply N_minimal
      · refine ⟨N_closed.inter ((T1Space.t1 m).preimage (continuous_mul_left m)), ?_, ?_⟩
        · rwa [← scaling_eq_self] at hm
        · rintro m'' ⟨mem'', eq'' : _ = m⟩ m' ⟨mem', eq' : _ = m⟩
          refine ⟨N_mul _ mem'' _ mem', ?_⟩
          rw [Set.mem_setOf_eq, mul_assoc, eq', eq'']
      apply Set.inter_subset_left
    rw [← absorbing_eq_self] at hm
    exact hm.2
  refine zorn_superset _ fun c hcs hc => ?_
  refine
    ⟨⋂₀ c, ⟨isClosed_sInter fun t ht => (hcs ht).1, ?_, fun m hm m' hm' => ?_⟩, fun s hs =>
      Set.sInter_subset_of_mem hs⟩
  · obtain rfl | hcnemp := c.eq_empty_or_nonempty
    · rw [Set.sInter_empty]
      apply Set.univ_nonempty
    convert
      @IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed _ _ _ hcnemp.coe_sort
        ((↑) : c → Set M) ?_ ?_ ?_ ?_
    · exact Set.sInter_eq_iInter
    · refine DirectedOn.directed_val (IsChain.directedOn hc.symm)
    exacts [fun i => (hcs i.prop).2.1, fun i => (hcs i.prop).1.isCompact, fun i => (hcs i.prop).1]
  · rw [Set.mem_sInter]
    exact fun t ht => (hcs ht).2.2 m (Set.mem_sInter.mp hm t ht) m' (Set.mem_sInter.mp hm' t ht)


Verifying proof (Commit 0ccf299781295df79fd6dbd49a4f98dc17cb7560):
∧ ∀ n : M, n * m = m → n = m := by
  -- We will use the compactness of M to show that the set of idempotent elements
  -- is nonempty, and then use the T2 property to pick a unique one.
  let idempotents : Set M := {m : M | m * m = m}
  have idempotents_nonempty : Set.Nonempty idempotents := by
    -- Since M is compact and T2, it is totally disconnected, and thus has a
    -- unique minimal nonempty closed subset.
    obtain ⟨m, hm⟩ :=
      IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed _ _ _
        (fun s : Set M => s.Nonempty ∧ IsClosed s ∧ s * s = s)
        (fun s t =>
          let ⟨hs, ht⟩ := s.eq_empty_or_nonempty
          ⟨s ∩ t, ⟨⟨hs.mono inter_subset_left, ht.mono inter_subset_right⟩,
            inter_mul_inter.2 ⟨hs, ht⟩⟩, inter_subset_left, inter_subset_right⟩)
        (fun s => s.Nonempty.image continuous_mul_left)
        (fun s => s.IsClosed.preimage continuous_mul_left)
        (fun s => s.IsClosed.inter s.IsClosed)
        (fun s => s.Nonempty.mono inter_subset_left)
        (fun s => s.Nonempty.mono inter_subset_right)
        (fun s => s.IsClosed)
        (fun s => s.mul_eq)
    -- The minimal nonempty closed subset is idempotent.
    exact ⟨m, hm.2.2⟩
  -- Pick an idempotent.
  obtain ⟨m, hm⟩ := idempotents_nonempty
  -- For any other idempotent n, we will show that n = m.
  refine' ⟨m, hm, fun n hn => _⟩
  -- Since M is T2, we can separate n and m if they are distinct.
  by_contra h
  obtain ⟨U, V, hU, hV, hmU, hnV, hUV⟩ := T2Space.t2 h
  -- The sets U and V witness the fact that n and m can be separated.
  -- We will use the compactness of M to derive a contradiction.
  -- Consider the intersection of the translates of U and V by the idempotents.
  let W := ⋂ r : M, (r * U) ∩ (r * V)
  -- This set is nonempty because M is compact and the family of translates is
  -- an open cover.
  have W_nonempty : Set.Nonempty W := by
    obtain ⟨s, hs⟩ :=
      IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed _ _ _
        (fun t : Set M => t.Nonempty ∧ IsOpen t ∧ t * U ∩ t * V = t)
        (fun t s =>
          let ⟨ht, hs⟩ := t.eq_empty_or_nonempty
          ⟨t ∩ s, ⟨⟨ht.mono inter_subset_left, hs.mono inter_subset_right⟩,
            inter_mul_inter.2 ⟨ht, hs⟩⟩, inter_subset_left, inter_subset_right⟩)
        (fun t => t.Nonempty.image continuous_mul_left)
        (fun t => t.IsOpen.preimage continuous_mul_left)
        (fun t => t.IsOpen.inter t.IsOpen)
        (fun t => t.Nonempty.mono inter_subset_left)
        (fun t => t.Nonempty.mono inter_subset_right)
        (fun t => t.IsOpen)
        (fun t => t.mul_eq)
    exact ⟨s, hs.2.2⟩
  -- Since W is a nonempty intersection of closed sets, it is closed.
  have W_closed : IsClosed W := isClosed_iInter fun r => isClosed_inter (isClosed_mul_left r) (isClosed_mul_left r)
  -- Since W is a nonempty closed subset of a compact space, it is also compact.
  have W_compact : IsCompact W := W_nonempty.isCompact_of_isClosed W_closed
  -- The intersection of W with U and V is nonempty.
  have hmWU : (m * U) ∩ (m * V) ⊆ W := iInter_subset _ m
  have hnWV : (n * U) ∩ (n * V) ⊆ W := iInter_subset _ n
  -- This leads to a contradiction because m and n are distinct idempotents and
  -- U and V are disjoint.
  exact hUV (hmU.inter_of_left (hmWU hmU) (hnWV hnV))
```

Attempt failure.

Working on Mathlib/Topology/Algebra/StarSubalgebra.lean - 2024-09-08 18:39:59.825272.
---182/200---
For theorem StarSubalgebra.closedEmbedding_inclusion in Mathlib/Topology/Algebra/StarSubalgebra.lean:
theorem closedEmbedding_inclusion {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂)
    (hS₁ : IsClosed (S₁ : Set A)) : ClosedEmbedding (inclusion h) 


Original valid proof:
:=
  { embedding_inclusion h with
    isClosed_range := isClosed_induced_iff.2
      ⟨S₁, hS₁, by
          convert (Set.range_subtype_map id _).symm
          · rw [Set.image_id]; rfl
          · intro _ h'
            apply h h' ⟩ }


Verifying proof (Commit 6b3f3fe208f0cdce581d713270301bed755856ed):
 where
  toEmbedding := embedding_inclusion h
  isClosed_map' := by
    intro s hs
    have : (inclusion h '' s).toSet = s.toSet := by
      ext
      simp only [mem_toSet, Set.mem_image, toSet_inclusion]
      constructor
      · rintro ⟨a, ha, rfl⟩
        exact ha
      · intro ha
        exact ⟨⟨_, ha, h _ ha⟩, rfl⟩
    rw [this]
    exact hs

/-- The embedding of a smaller star subalgebra into a larger one, as a closed embedding. -/
theorem closedEmbedding_inclusion' {S₁ S₂ : StarSubalgebra R A} (h : S₁ ≤ S₂) :
    ClosedEmbedding (inclusion h) := by
  refine closedEmbedding_inclusion h ?_
  -- Porting note: was `continuity`
  exact map_continuous _
```

Attempt failure.

Working on Mathlib/Topology/Algebra/Valuation.lean - 2024-09-08 18:40:11.116217.
---183/200---
For theorem Valuation.subgroups_basis in Mathlib/Topology/Algebra/Valuation.lean:
theorem subgroups_basis : RingSubgroupsBasis fun γ : Γ₀ˣ => (v.ltAddSubgroup γ : AddSubgroup R) 


Original valid proof:
:=
  { inter := by
      rintro γ₀ γ₁
      use min γ₀ γ₁
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro γ
      cases' exists_square_le γ with γ₀ h
      use γ₀
      rintro - ⟨r, r_in, s, s_in, rfl⟩
      calc
        (v (r * s) : Γ₀) = v r * v s := Valuation.map_mul _ _ _
        _ < γ₀ * γ₀ := mul_lt_mul₀ r_in s_in
        _ ≤ γ := mod_cast h
    leftMul := by
      rintro x γ
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ⟨γx, Hx⟩)
      · use (1 : Γ₀ˣ)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt γ
      · use γx⁻¹ * γ
        rintro y (vy_lt : v y < ↑(γx⁻¹ * γ))
        change (v (x * y) : Γ₀) < γ
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul₀ vy_lt
    rightMul := by
      rintro x γ
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ⟨γx, Hx⟩)
      · use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt γ
      · use γx⁻¹ * γ
        rintro y (vy_lt : v y < ↑(γx⁻¹ * γ))
        change (v (y * x) : Γ₀) < γ
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul₀ vy_lt }


Verifying proof (Commit 916c75c1d9f2fcdcd11d5d5b32f69afcc94bb9c4):
 where
  inter := by
    rintro γ₁ γ₂ ⟨rfl⟩
    exact v.ltAddSubgroup_inter γ₁ γ₂
  mul_inter := by
    rintro γ₁ γ₂ ⟨rfl⟩
    exact v.ltAddSubgroup_mul_inter γ₁ γ₂
  inter_mul := by
    rintro γ₁ γ₂ ⟨rfl⟩
    exact v.ltAddSubgroup_inter_mul γ₁ γ₂
  mem_add_iff := by
    rintro γ ⟨rfl⟩ r x
    exact v.mem_ltAddSubgroup_iff γ x r
  mem_mul_iff := by
    rintro γ ⟨rfl�t⟩ r x
    exact v.mem_ltAddSubgroup_mul_iff γ x r
  coe_mul_self := by
    rintro γ ⟨rfl⟩
    exact v.coe_ltAddSubgroup_mul_self γ
  coe_toAddSubgroup := by
    rintro γ ⟨rfl⟩
    rfl
  to_submodules_injective := by
    rintro ⟨γ₁⟩ ⟨γ₂⟩ h
    dsimp at h
    rw [← Submodule.toAddSubgroup_eq_iff, h]
  to_addSubgroup_injective := by
    rintro ⟨γ₁⟩ ⟨γ₂⟩ h
    dsimp at h
    rw [h]
  to_submodule_injective := by
    rintro ⟨γ₁⟩ ⟨γ₂⟩ h
    dsimp at h
    rw [h]
  pow_subset_of_mem := by
    rintro γ ⟨rfl⟩ n x hx
    exact v.pow_mem_of_mem hx n
  zero_mem := by
    rintro γ ⟨rfl⟩
    exact v.zero_mem γ
  one_mem := by
    rintro γ ⟨rfl⟩
    exact v.one_mem γ
  mul_mem := by
    rintro γ ⟨rfl⟩ x y hx hy
    exact v.mul_mem hx hy
  add_mem := by
    rintro γ ⟨rfl⟩ x y hx hy
    exact v.add_mem hx hy
  neg_mem := by
    rintro γ ⟨rfl⟩ x hx
    exact v.neg_mem hx
  conj_mem := by
    rintro γ ⟨rfl⟩ x hx
    exact v.conj_mem hx
  coe_toAddSubgroup_pow := by
    rintro γ ⟨rfl⟩ n
    exact v.coe_ltAddSubgroup_pow n γ
  coe_toAddSubgroup_nsmul := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_nsmul n x γ
  coe_toAddSubgroup_zsmul := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zsmul n x γ
  coe_toAddSubgroup_natCast := by
    rintro γ ⟨rfl⟩ n
    exact v.coe_ltAddSubgroup_natCast n γ
  coe_toAddSubgroup_intCast := by
    rintro γ ⟨rfl⟩ n
    exact v.coe_ltAddSubgroup_intCast n γ
  coe_toAddSubgroup_inv := by
    rintro γ ⟨rfl⟩ x
    exact v.coe_ltAddSubgroup_inv x γ
  coe_toAddSubgroup_div := by
    rintro γ ⟨rfl⟩ x y
    exact v.coe_ltAddSubgroup_div x y γ
  coe_toAddSubgroup_zpow := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zpow n x γ
  coe_toAddSubgroup_qpow := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_qpow n x γ
  coe_toAddSubgroup_zsmul_int := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zsmul_int n x γ
  coe_toAddSubgroup_zsmul_nat := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zsmul_nat n x γ
  coe_toAddSubgroup_zsmul_neg_int := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zsmul_neg_int n x γ
  coe_toAddSubgroup_zsmul_neg_nat := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zsmul_neg_nat n x γ
  coe_toAddSubgroup_nsmul_int := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_nsmul_int n x γ
  coe_toAddSubgroup_nsmul_nat := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_nsmul_nat n x γ
  coe_toAddSubgroup_nsmul_neg_int := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_nsmul_neg_int n x γ
  coe_toAddSubgroup_nsmul_neg_nat := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_nsmul_neg_nat n x γ
  coe_toAddSubgroup_zpow_int := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zpow_int n x γ
  coe_toAddSubgroup_zpow_nat := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zpow_nat n x γ
  coe_toAddSubgroup_zpow_neg_int := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zpow_neg_int n x γ
  coe_toAddSubgroup_zpow_neg_nat := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zpow_neg_nat n x γ
  coe_toAddSubgroup_qpow_int := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_qpow_int n x γ
  coe_toAddSubgroup_qpow_nat := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_qpow_nat n x γ
  coe_toAddSubgroup_qpow_neg_int := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_qpow_neg_int n x γ
  coe_toAddSubgroup_qpow_neg_nat := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_qpow_neg_nat n x γ
  coe_toAddSubgroup_zsmul_int_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zsmul_int_neg n x γ
  coe_toAddSubgroup_zsmul_nat_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zsmul_nat_neg n x γ
  coe_toAddSubgroup_zsmul_neg_int_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zsmul_neg_int_neg n x γ
  coe_toAddSubgroup_zsmul_neg_nat_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zsmul_neg_nat_neg n x γ
  coe_toAddSubgroup_nsmul_int_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_nsmul_int_neg n x γ
  coe_toAddSubgroup_nsmul_nat_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_nsmul_nat_neg n x γ
  coe_toAddSubgroup_nsmul_neg_int_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_nsmul_neg_int_neg n x γ
  coe_toAddSubgroup_nsmul_neg_nat_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_nsmul_neg_nat_neg n x γ
  coe_toAddSubgroup_zpow_int_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zpow_int_neg n x γ
  coe_toAddSubgroup_zpow_nat_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zpow_nat_neg n x γ
  coe_toAddSubgroup_zpow_neg_int_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zpow_neg_int_neg n x γ
  coe_toAddSubgroup_zpow_neg_nat_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zpow_neg_nat_neg n x γ
  coe_toAddSubgroup_qpow_int_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_qpow_int_neg n x γ
  coe_toAddSubgroup_qpow_nat_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_qpow_nat_neg n x γ
  coe_toAddSubgroup_qpow_neg_int_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_qpow_neg_int_neg n x γ
  coe_toAddSubgroup_qpow_neg_nat_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_qpow_neg_nat_neg n x γ
  coe_toAddSubgroup_zsmul_int_neg_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zsmul_int_neg_neg n x γ
  coe_toAddSubgroup_zsmul_nat_neg_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zsmul_nat_neg_neg n x γ
  coe_toAddSubgroup_zsmul_neg_int_neg_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zsmul_neg_int_neg_neg n x γ
  coe_toAddSubgroup_zsmul_neg_nat_neg_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_zsmul_neg_nat_neg_neg n x γ
  coe_toAddSubgroup_nsmul_int_neg_neg := by
    rintro γ ⟨rfl⟩ n x
    exact v.coe_ltAddSubgroup_nsmul

Attempt failure.

Working on Mathlib/Topology/Bases.lean - 2024-09-08 18:40:19.723917.
---184/200---
For theorem TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds in Mathlib/Topology/Bases.lean:
theorem isTopologicalBasis_of_isOpen_of_nhds {s : Set (Set α)} (h_open : ∀ u ∈ s, IsOpen u)
    (h_nhds : ∀ (a : α) (u : Set α), a ∈ u → IsOpen u → ∃ v ∈ s, a ∈ v ∧ v ⊆ u) :
    IsTopologicalBasis s 


Original valid proof:
:=
  .of_hasBasis_nhds <| fun a ↦
    (nhds_basis_opens a).to_hasBasis' (by simpa [and_assoc] using h_nhds a)
      fun t ⟨hts, hat⟩ ↦ (h_open _ hts).mem_nhds hat


Verifying proof (Commit 14580a34773ef6b2f1e5f307031f50c0a6d85dbb):
 := by
  refine' ⟨fun u v h => _, fun a u h => _⟩
  · rcases h_nhds a (u ∩ v) ⟨h.1, h.2⟩ (IsOpen.inter (h_open _ h.1) (h_open _ h.2)) with ⟨w, hws, haw, hw⟩
    exact ⟨w, hws, haw, hw.trans (inter_subset_inter_left _)⟩
  · rcases h_nhds a u h with ⟨w, hws, haw, hw⟩
    exact ⟨w, hws, haw, hw⟩
```

Attempt failure.

Working on Mathlib/Topology/CompactOpen.lean - 2024-09-08 18:40:29.478372.
---185/200---
For theorem ContinuousMap.continuous_comp in Mathlib/Topology/CompactOpen.lean:
lemma continuous_compactOpen {f : X → C(Y, Z)} :
    Continuous f ↔ ∀ K, IsCompact K → ∀ U, IsOpen U → IsOpen {x | MapsTo (f x) K U} 


Original valid proof:
:=
  continuous_generateFrom_iff.trans forall_image2_iff


Verifying proof (Commit 07d28ef76de6fda605a7eb6f6c9ef70c5c90b329):
 := by
  simp_rw [continuous_iff_continuousAt, ContinuousAt, tendsto_nhds_compactOpen]
  exact forall_swap

lemma continuous_of_continuous_uncurry {f : X → Y → Z} (h : Continuous (uncurry f)) :
    Continuous f := by
  rw [continuous_iff_continuousAt] at h ⊢
  intro x
  specialize h (x, Classical.choose (Continuous.exists_tendsto h (isOpen_univ)
    (isOpen_univ) (mem_univ (Classical.choose (Continuous.exists_tendsto h (isOpen_univ)
    (isOpen_univ) (mem_univ x))))))
  convert h
  ext y
  exact congr_fun (Classical.choose_spec (Continuous.exists_tendsto h (isOpen_univ)
    (isOpen_univ) (mem_univ x))) y
```

Attempt failure.

Working on Mathlib/Topology/Compactness/Paracompact.lean - 2024-09-08 18:40:37.360627.
---186/200---
For theorem refinement_of_locallyCompact_sigmaCompact_of_nhds_basis in Mathlib/Topology/Compactness/Paracompact.lean:
theorem refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set [WeaklyLocallyCompactSpace X]
    [SigmaCompactSpace X] [T2Space X] {ι : X → Type u} {p : ∀ x, ι x → Prop} {B : ∀ x, ι x → Set X}
    {s : Set X} (hs : IsClosed s) (hB : ∀ x ∈ s, (𝓝 x).HasBasis (p x) (B x)) :
    ∃ (α : Type v) (c : α → X) (r : ∀ a, ι (c a)),
      (∀ a, c a ∈ s ∧ p (c a) (r a)) ∧
        (s ⊆ ⋃ a, B (c a) (r a)) ∧ LocallyFinite fun a ↦ B (c a) (r a) 


Original valid proof:
:= by
  classical
    set K' : CompactExhaustion X := CompactExhaustion.choice X
    set K : CompactExhaustion X := K'.shiftr.shiftr
    set Kdiff := fun n ↦ K (n + 1) \ interior (K n)
    have hKcov : ∀ x, x ∈ Kdiff (K'.find x + 1) := fun x ↦ by
      simpa only [K'.find_shiftr] using
        diff_subset_diff_right interior_subset (K'.shiftr.mem_diff_shiftr_find x)
    have Kdiffc : ∀ n, IsCompact (Kdiff n ∩ s) :=
      fun n ↦ ((K.isCompact _).diff isOpen_interior).inter_right hs
    have : ∀ (n) (x : ↑(Kdiff (n + 1) ∩ s)), (K n)ᶜ ∈ 𝓝 (x : X) :=
      fun n x ↦ (K.isClosed n).compl_mem_nhds fun hx' ↦ x.2.1.2 <| K.subset_interior_succ _ hx'
    choose! r hrp hr using fun n (x : ↑(Kdiff (n + 1) ∩ s)) ↦ (hB x x.2.2).mem_iff.1 (this n x)
    have hxr : ∀ (n x) (hx : x ∈ Kdiff (n + 1) ∩ s), B x (r n ⟨x, hx⟩) ∈ 𝓝 x := fun n x hx ↦
      (hB x hx.2).mem_of_mem (hrp _ ⟨x, hx⟩)
    choose T hT using fun n ↦ (Kdiffc (n + 1)).elim_nhds_subcover' _ (hxr n)
    set T' : ∀ n, Set ↑(Kdiff (n + 1) ∩ s) := fun n ↦ T n
    refine ⟨Σn, T' n, fun a ↦ a.2, fun a ↦ r a.1 a.2, ?_, ?_, ?_⟩
    · rintro ⟨n, x, hx⟩
      exact ⟨x.2.2, hrp _ _⟩
    · refine fun x hx ↦ mem_iUnion.2 ?_
      rcases mem_iUnion₂.1 (hT _ ⟨hKcov x, hx⟩) with ⟨⟨c, hc⟩, hcT, hcx⟩
      exact ⟨⟨_, ⟨c, hc⟩, hcT⟩, hcx⟩
    · intro x
      refine
        ⟨interior (K (K'.find x + 3)),
          IsOpen.mem_nhds isOpen_interior (K.subset_interior_succ _ (hKcov x).1), ?_⟩
      have : (⋃ k ≤ K'.find x + 2, range (Sigma.mk k) : Set (Σn, T' n)).Finite :=
        (finite_le_nat _).biUnion fun k _ ↦ finite_range _
      apply this.subset
      rintro ⟨k, c, hc⟩
      simp only [mem_iUnion, mem_setOf_eq, mem_image, Subtype.coe_mk]
      rintro ⟨x, hxB : x ∈ B c (r k c), hxK⟩
      refine ⟨k, ?_, ⟨c, hc⟩, rfl⟩
      have := (mem_compl_iff _ _).1 (hr k c hxB)
      contrapose! this with hnk
      exact K.subset hnk (interior_subset hxK)


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
∧
          (∀ a, IsCompact (B (c a) (r a))) ∧ ∀ a, ∃ U, IsOpen U ∧ c a ∈ U ∧ B (c a) (r a) ⊆ U :=
  let ⟨α, c, r, hc, hU, hfin, hcomp, hsupp⟩ :=
    refinement_of_locallyCompact_sigmaCompact_of_nhds_basis s hs hB
  -- We need to show that the sets `B (c a) (r a)` are compact.
  ⟨α, c, r, hc, hU, hfin, fun a ↦ (hcomp a).1, fun a ↦
    let ⟨U, hU, hcU, hUB⟩ := hsupp a
    ⟨U, hU, hcU, hUB.trans <| inter_subset_right _ _⟩⟩
```

Attempt failure.

Working on Mathlib/Topology/ContinuousOn.lean - 2024-09-08 18:40:43.162527.
---187/200---
For theorem IsOpenMap.continuousOn_image_of_leftInvOn in Mathlib/Topology/ContinuousOn.lean:
theorem IsOpenMap.continuousOn_image_of_leftInvOn {f : α → β} {s : Set α}
    (h : IsOpenMap (s.restrict f)) {finv : β → α} (hleft : LeftInvOn finv f s) :
    ContinuousOn finv (f '' s) 


Original valid proof:
:= by
  refine continuousOn_iff'.2 fun t ht => ⟨f '' (t ∩ s), ?_, ?_⟩
  · rw [← image_restrict]
    exact h _ (ht.preimage continuous_subtype_val)
  · rw [inter_eq_self_of_subset_left (image_subset f inter_subset_right), hleft.image_inter']


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
∧ EqOn (finv ∘ f) id s := by
  constructor
  · rw [continuousOn_iff_continuous_restrict]
    have : (s.restrict f).toFun = f := rfl
    rw [this] at h
    exact h.of_comp_left (s.restrict finv)
  · exact hleft


theorem IsOpenMap.continuousOn_range_of_leftInverse {f : α → β} (hf : IsOpenMap f) {finv : β → α}
    (hleft : Function.LeftInverse finv f) : ContinuousOn finv (range f) := by
  rw [← image_univ]
  exact (hf.continuousOn_image_of_leftInvOn hleft).1
```

Attempt failure.

Working on Mathlib/Topology/Instances/EReal.lean - 2024-09-08 18:40:52.745359.
---188/200---
For theorem EReal.nhds_bot_basis in Mathlib/Topology/Instances/EReal.lean:
theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) 


Original valid proof:
:= by
  refine _root_.nhds_bot_basis.to_hasBasis (fun x hx => ?_) fun _ _ ↦ ⟨_, bot_lt_coe _, Subset.rfl⟩
  rcases exists_rat_btwn_of_lt hx with ⟨y, -, hxy⟩
  exact ⟨_, trivial, Iio_subset_Iio hxy.le⟩


Verifying proof (Commit f3df819bd51d0f3495e887909f4ab5efc2965f66):
 where
  refine' ⟨fun s ↦ ⟨fun hs ↦ _, fun ⟨_, _⟩ ↦ mem_nhds_bot_iff.2 ⟨_, hs, Iio_subset_Iio.2 (le_refl _)⟩⟩⟩
  rw [mem_nhds_bot_iff] at hs
  rcases hs with ⟨a, ha, h⟩
  exact ⟨a, trivial, h⟩

theorem nhds_bot_basis' : (𝓝 (⊥ : EReal)).HasBasis (fun a : ℝ ↦ True) (fun a ↦ Iio ↑a) :=
  nhds_bot_basis.to_hasBasis (fun _ _ ↦ ⟨_, trivial, Subset.rfl⟩) fun _ _ ↦ ⟨_, Subset.rfl⟩

theorem nhds_bot_basis_Iic : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iic ·) := by
  refine' nhds_bot_basis.to_hasBasis (fun x _ ↦ ⟨x, trivial, Iio_subset_Iic_self⟩) fun x _ ↦ _
  rcases exists_rat_btwn_of_lt (bot_lt_coe x) with ⟨y, h, -⟩
  exact ⟨_, trivial, Iic_subset_Iio.2 h.2⟩

theorem nhds_bot_basis_Iic' : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (fun a ↦ Iic a) :=
  nhds_bot_basis_Iic.to_hasBasis (fun _ _ ↦ ⟨_, trivial, Subset.rfl⟩) fun _ _ ↦ ⟨_, Subset.rfl⟩

theorem nhds_bot_basis_Iic_mem (x : ℝ) : (𝓝 (⊥ : EReal)).HasBasis (fun _ : True ↦ True)
    fun _ ↦ Iic x := nhds_bot_basis_Iic.to_hasBasis (fun _ _ ↦ ⟨trivial, Subset.rfl⟩)
      fun _ _ ↦ ⟨x, Subset.rfl⟩

theorem nhds_bot_basis_Iic_mem' (x : ℝ) : (𝓝 (⊥ : EReal)).HasBasis (fun _ : True ↦ True)
    fun a ↦ Iic a ≤ Iic x := nhds_bot_basis_Iic.to_hasBasis (fun _ _ ↦ ⟨trivial, Subset.rfl⟩)
      fun _ _ ↦ ⟨x, Subset.rfl⟩

theorem nhds_bot_basis_Iic_mem_iff {s : Set EReal} :
    (𝓝 ⊥).HasBasis (fun _ : True ↦ True) (fun _ ↦ Iic ·) ↔ ∃ x : ℝ, Iic x ⊆ s := by
  refine' ⟨fun h ↦ _, fun ⟨x, hx⟩ ↦ nhds_bot_basis_Iic.mem_iff.2 ⟨x, hx⟩⟩
  rcases h.mem_iff.1 (mem_nhds_bot_iff.2 ⟨0, bot_le⟩) with ⟨_, ⟨_, rfl⟩, h⟩
  exact ⟨_, h⟩
```

Attempt failure.

Working on Mathlib/Topology/MetricSpace/CantorScheme.lean - 2024-09-08 18:41:00.771943.
---189/200---
For theorem CantorScheme.map_mem in Mathlib/Topology/MetricSpace/CantorScheme.lean:
theorem map_mem (x : (inducedMap A).1) (n : ℕ) : (inducedMap A).2 x ∈ A (res x n) 


Original valid proof:
:= by
  have := x.property.some_mem
  rw [mem_iInter] at this
  exact this n


Verifying proof (Commit 38dbcd8285bc4b1391619c12f158a7409f3dfc12):
→ x ∈ A n :=  by
Complete the following Lean 4 code:

```lean4
import Mathlib.Algebra.Polynomial.AlgebraMap
import Mathlib.Algebra.Polynomial.Derivative
import Mathlib.Data.Nat.Choose.Cast
import Mathlib.NumberTheory.Bernoulli



/-!
# Bernoulli polynomials

The [Bernoulli polynomials](https://en.wikipedia.org/wiki/Bernoulli_polynomials)
are an important tool obtained from Bernoulli numbers.

## Mathematical overview

The $n$-th Bernoulli polynomial is defined as
$$ B_n(X) = ∑_{k = 0}^n {n \choose k} (-1)^k B_k X^{n - k} $$
where $B_k$ is the $k$-th Bernoulli number. The Bernoulli polynomials are generating functions,
$$ \frac{t e^{tX} }{ e^t - 1} = ∑_{n = 0}^{\infty} B_n(X) \frac{t^n}{n!} $$

## Implementation detail

Bernoulli polynomials are defined using `bernoulli`, the Bernoulli numbers.

## Main theorems

- `sum_bernoulli`: The sum of the $k^\mathrm{th}$ Bernoulli polynomial with binomial
(... 9 lines omitted)
-/

/- (... 10 lines omitted) -/

/-- The Bernoulli polynomials are defined in terms of the negative Bernoulli numbers. -/
def bernoulli (n : ℕ) : ℚ[X] :=
  ∑ i ∈ range (n + 1), Polynomial.monomial (n - i) (_root_.bernoulli i * choose n i)


theorem bernoulli_def (n : ℕ) : bernoulli n =
    ∑ i ∈ range (n + 1), Polynomial.monomial i (_root_.bernoulli (n - i) * choose n i) := by
  rw [← sum_range_reflect, add_succ_sub_one, add_zero, bernoulli]
  apply sum_congr rfl
  rintro x hx
  rw [mem_range_succ_iff] at hx
  rw [choose_symm hx, tsub_tsub_cancel_of_le hx]


/-
### examples
-/
section Examples

@[simp]
theorem bernoulli_zero : bernoulli 0 = 1 := by simp [bernoulli]
```

Attempt failure. (Regular Expression Failure)

Working on Mathlib/Topology/MetricSpace/GromovHausdorff.lean - 2024-09-08 18:41:00.778374.
---190/200---
For theorem GromovHausdorff.totallyBounded in Mathlib/Topology/MetricSpace/GromovHausdorff.lean:
theorem totallyBounded {t : Set GHSpace} {C : ℝ} {u : ℕ → ℝ} {K : ℕ → ℕ}
    (ulim : Tendsto u atTop (𝓝 0)) (hdiam : ∀ p ∈ t, diam (univ : Set (GHSpace.Rep p)) ≤ C)
    (hcov : ∀ p ∈ t, ∀ n : ℕ, ∃ s : Set (GHSpace.Rep p),
      (#s) ≤ K n ∧ univ ⊆ ⋃ x ∈ s, ball x (u n)) :
    TotallyBounded t 


Original valid proof:
:= by
  refine Metric.totallyBounded_of_finite_discretization fun δ δpos => ?_
  let ε := 1 / 5 * δ
  have εpos : 0 < ε := mul_pos (by norm_num) δpos
  rcases Metric.tendsto_atTop.1 ulim ε εpos with ⟨n, hn⟩
  have u_le_ε : u n ≤ ε := by
    have := hn n le_rfl
    simp only [Real.dist_eq, add_zero, sub_eq_add_neg, neg_zero] at this
    exact le_of_lt (lt_of_le_of_lt (le_abs_self _) this)
  have :
    ∀ p : GHSpace,
      ∃ s : Set p.Rep, ∃ N ≤ K n, ∃ _ : Equiv s (Fin N), p ∈ t → univ ⊆ ⋃ x ∈ s, ball x (u n) := by
    intro p
    by_cases hp : p ∉ t
    · have : Nonempty (Equiv (∅ : Set p.Rep) (Fin 0)) := by
        rw [← Fintype.card_eq];
        simp only [empty_card', Fintype.card_fin]
      use ∅, 0, bot_le, this.some
      exact fun hp' => (hp hp').elim
    · rcases hcov _ (Set.not_not_mem.1 hp) n with ⟨s, ⟨scard, scover⟩⟩
      rcases Cardinal.lt_aleph0.1 (lt_of_le_of_lt scard (Cardinal.nat_lt_aleph0 _)) with ⟨N, hN⟩
      rw [hN, Cardinal.natCast_le] at scard
      have : #s = #(Fin N) := by rw [hN, Cardinal.mk_fin]
      cases' Quotient.exact this with E
      use s, N, scard, E
      simp only [scover, imp_true_iff]
  choose s N hN E hs using this
  let M := ⌊ε⁻¹ * max C 0⌋₊
  let F : GHSpace → Σ k : Fin (K n).succ, Fin k → Fin k → Fin M.succ := fun p =>
    ⟨⟨N p, lt_of_le_of_lt (hN p) (Nat.lt_succ_self _)⟩, fun a b =>
      ⟨min M ⌊ε⁻¹ * dist ((E p).symm a) ((E p).symm b)⌋₊,
        (min_le_left _ _).trans_lt (Nat.lt_succ_self _)⟩⟩
  refine ⟨_, ?_, fun p => F p, ?_⟩;
  · infer_instance
  rintro ⟨p, pt⟩ ⟨q, qt⟩ hpq
  have Npq : N p = N q := Fin.ext_iff.1 (Sigma.mk.inj_iff.1 hpq).1
  let Ψ : s p → s q := fun x => (E q).symm (Fin.cast Npq ((E p) x))
  let Φ : s p → q.Rep := fun x => Ψ x
  have main : ghDist p.Rep q.Rep ≤ ε + ε / 2 + ε := by
    refine ghDist_le_of_approx_subsets Φ ?_ ?_ ?_
    · show ∀ x : p.Rep, ∃ y ∈ s p, dist x y ≤ ε
      intro x
      have : x ∈ ⋃ y ∈ s p, ball y (u n) := (hs p pt) (mem_univ _)
      rcases mem_iUnion₂.1 this with ⟨y, ys, hy⟩
      exact ⟨y, ys, le_trans (le_of_lt hy) u_le_ε⟩
    · show ∀ x : q.Rep, ∃ z : s p, dist x (Φ z) ≤ ε
      intro x
      have : x ∈ ⋃ y ∈ s q, ball y (u n) := (hs q qt) (mem_univ _)
      rcases mem_iUnion₂.1 this with ⟨y, ys, hy⟩
      let i : ℕ := E q ⟨y, ys⟩
      let hi := ((E q) ⟨y, ys⟩).2
      have ihi_eq : (⟨i, hi⟩ : Fin (N q)) = (E q) ⟨y, ys⟩ := by rw [Fin.ext_iff, Fin.val_mk]
      have hiq : i < N q := hi
      have hip : i < N p := by rwa [Npq.symm] at hiq
      let z := (E p).symm ⟨i, hip⟩
      use z
      have C1 : (E p) z = ⟨i, hip⟩ := (E p).apply_symm_apply ⟨i, hip⟩
      have C2 : Fin.cast Npq ⟨i, hip⟩ = ⟨i, hi⟩ := rfl
      have C3 : (E q).symm ⟨i, hi⟩ = ⟨y, ys⟩ := by
        rw [ihi_eq]; exact (E q).symm_apply_apply ⟨y, ys⟩
      have : Φ z = y := by simp only [Ψ, Φ]; rw [C1, C2, C3]
      rw [this]
      exact le_trans (le_of_lt hy) u_le_ε
    · show ∀ x y : s p, |dist x y - dist (Φ x) (Φ y)| ≤ ε
      intro x y
      have : dist (Φ x) (Φ y) = dist (Ψ x) (Ψ y) := rfl
      rw [this]
      let i : ℕ := E p x
      have hip : i < N p := ((E p) x).2
      have hiq : i < N q := by rwa [Npq] at hip
      have i' : i = (E q) (Ψ x) := by simp only [Ψ, Equiv.apply_symm_apply, Fin.coe_cast]
      let j : ℕ := E p y
      have hjp : j < N p := ((E p) y).2
      have hjq : j < N q := by rwa [Npq] at hjp
      have j' : j = (E q) (Ψ y) := by simp only [Ψ, Equiv.apply_symm_apply, Fin.coe_cast]
      have Ap : ((F p).2 ⟨i, hip⟩ ⟨j, hjp⟩).1 = ⌊ε⁻¹ * dist x y⌋₊ :=
        calc
          ((F p).2 ⟨i, hip⟩ ⟨j, hjp⟩).1 = ((F p).2 ((E p) x) ((E p) y)).1 := by
            congr
          _ = min M ⌊ε⁻¹ * dist x y⌋₊ := by simp only [(E p).symm_apply_apply]
          _ = ⌊ε⁻¹ * dist x y⌋₊ := by
            refine min_eq_right (Nat.floor_mono ?_)
            refine mul_le_mul_of_nonneg_left (le_trans ?_ (le_max_left _ _)) (inv_pos.2 εpos).le
            change dist (x : p.Rep) y ≤ C
            refine (dist_le_diam_of_mem isCompact_univ.isBounded (mem_univ _) (mem_univ _)).trans ?_
            exact hdiam p pt
      have Aq : ((F q).2 ⟨i, hiq⟩ ⟨j, hjq⟩).1 = ⌊ε⁻¹ * dist (Ψ x) (Ψ y)⌋₊ :=
        calc
          ((F q).2 ⟨i, hiq⟩ ⟨j, hjq⟩).1 = ((F q).2 ((E q) (Ψ x)) ((E q) (Ψ y))).1 := by
            exact congr_arg₂ (Fin.val <| (F q).2 · ·) (Fin.ext i') (Fin.ext j')
          _ = min M ⌊ε⁻¹ * dist (Ψ x) (Ψ y)⌋₊ := by simp only [(E q).symm_apply_apply]
          _ = ⌊ε⁻¹ * dist (Ψ x) (Ψ y)⌋₊ := by
            refine min_eq_right (Nat.floor_mono ?_)
            refine mul_le_mul_of_nonneg_left (le_trans ?_ (le_max_left _ _)) (inv_pos.2 εpos).le
            change dist (Ψ x : q.Rep) (Ψ y) ≤ C
            refine (dist_le_diam_of_mem isCompact_univ.isBounded (mem_univ _) (mem_univ _)).trans ?_
            exact hdiam q qt
      have : ((F p).2 ⟨i, hip⟩ ⟨j, hjp⟩).1 = ((F q).2 ⟨i, hiq⟩ ⟨j, hjq⟩).1 := by
        have hpq' : HEq (F p).snd (F q).snd := (Sigma.mk.inj_iff.1 hpq).2
        rw [Fin.heq_fun₂_iff Npq Npq] at hpq'
        rw [← hpq']
      have : ⌊ε⁻¹ * dist x y⌋ = ⌊ε⁻¹ * dist (Ψ x) (Ψ y)⌋ := by
        rw [Ap, Aq] at this
        have D : 0 ≤ ⌊ε⁻¹ * dist x y⌋ :=
          floor_nonneg.2 (mul_nonneg (le_of_lt (inv_pos.2 εpos)) dist_nonneg)
        have D' : 0 ≤ ⌊ε⁻¹ * dist (Ψ x) (Ψ y)⌋ :=
          floor_nonneg.2 (mul_nonneg (le_of_lt (inv_pos.2 εpos)) dist_nonneg)
        rw [← Int.toNat_of_nonneg D, ← Int.toNat_of_nonneg D', Int.floor_toNat, Int.floor_toNat,
          this]
      have I :=
        calc
          |ε⁻¹| * |dist x y - dist (Ψ x) (Ψ y)| = |ε⁻¹ * (dist x y - dist (Ψ x) (Ψ y))| :=
            (abs_mul _ _).symm
          _ = |ε⁻¹ * dist x y - ε⁻¹ * dist (Ψ x) (Ψ y)| := by congr; ring
          _ ≤ 1 := le_of_lt (abs_sub_lt_one_of_floor_eq_floor this)
      calc
        |dist x y - dist (Ψ x) (Ψ y)| = ε * ε⁻¹ * |dist x y - dist (Ψ x) (Ψ y)| := by
          rw [mul_inv_cancel (ne_of_gt εpos), one_mul]
        _ = ε * (|ε⁻¹| * |dist x y - dist (Ψ x) (Ψ y)|) := by
          rw [abs_of_nonneg (le_of_lt (inv_pos.2 εpos)), mul_assoc]
        _ ≤ ε * 1 := mul_le_mul_of_nonneg_left I (le_of_lt εpos)
        _ = ε := mul_one _
  calc
    dist p q = ghDist p.Rep q.Rep := dist_ghDist p q
    _ ≤ ε + ε / 2 + ε := main
    _ = δ / 2 := by simp only [ε, one_div]; ring
    _ < δ := half_lt_self δpos


Verifying proof (Commit 9bc35020058f4a5a844eb7662d9de673056d4dbe):
∧ ∀ p ∈ t, ∀ ε > 0, ∃ s : Set (GHSpace.Rep p),
      (#s) ≤ K 0 ∧ univ ⊆ ⋃ x ∈ s, ball x ε :=### Proof

To prove that the set \( t \) of compact metric spaces is totally bounded and that for each space \( p \) in \( t \), given any positive real number \( \epsilon \), there exists a finite set \( s \) of points in \( p \) such that the union of balls of radius \( \epsilon \) centered at the points in \( s \) covers \( p \), we proceed as follows:

1. **Totally Bounded Set**: We need to show that \( t \) is totally bounded. This means that for any \( \epsilon > 0 \), there exists a finite number of balls of radius \( \epsilon \) that cover \( t \).

2. **Finite Covering**: Given \( \epsilon > 0 \), we use the fact that the sequence \( u \) tends to 0 and the condition on the diameters of the spaces in \( t \). We can find a sufficiently large \( N \) such that \( u_N < \epsilon \).

3. **Constructing the Cover**: For each space \( p \) in \( t \), we use the condition that for each \( n \), there exists a set \( s \) of points in \( p \) such that the union of balls of radius \( u_n \) centered at the points in \( s \) covers \( p \). Since \( u_N < \epsilon \), we can use the set \( s \) corresponding to \( n = N \).

4. **Conclusion**: By the construction, the set \( s \) has cardinality at most \( K_0 \) and covers \( p \) with balls of radius \( \epsilon \). This shows that \( t \) is totally bounded and satisfies the required property for each \( p \) in \( t \).

### Detailed Proof

1. **Totally Bounded**: We need to show that for any \( \epsilon > 0 \), there exists a finite number of balls of radius \( \epsilon \) that cover \( t \).

2. **Finite Covering**: Given \( \epsilon > 0 \), since \( u \) tends to 0, there exists \( N \) such that \( u_N < \epsilon \).

3. **Constructing the Cover**: For each \( p \) in \( t \), use the condition that for each \( n \), there exists a set \( s \) of points in \( p \) such that the union of balls of radius \( u_n \) centered at the points in \( s \) covers \( p \). Since \( u_N < \epsilon \), we can use the set \( s \) corresponding to \( n = N \).

4. **Conclusion**: The set \( s \) has cardinality at most \( K_0 \) and covers \( p \) with balls of radius \( \epsilon \). This shows that \( t \) is totally bounded and satisfies the required property for each \( p \) in \( t \).

Thus, we have shown that \( t \) is totally bounded and that for each \( p \) in \( t \), given any positive real number \( \epsilon \), there exists a finite set \( s \) of points in \( p \) such that the union of balls of radius \( \epsilon \) centered at the points in \( s \) covers \( p \).

Attempt failure. (Regular Expression Failure)

Working on Mathlib/Topology/MetricSpace/HausdorffDistance.lean - 2024-09-08 18:41:00.790430.
---191/200---
For theorem Metric.infDist_inter_closedBall_of_mem in Mathlib/Topology/MetricSpace/HausdorffDistance.lean:
theorem infDist_inter_closedBall_of_mem (h : y ∈ s) :
    infDist x (s ∩ closedBall x (dist y x)) = infDist x s 


Original valid proof:
:= by
  replace h : y ∈ s ∩ closedBall x (dist y x) := ⟨h, mem_closedBall.2 le_rfl⟩
  refine le_antisymm ?_ (infDist_le_infDist_of_subset inter_subset_left ⟨y, h⟩)
  refine not_lt.1 fun hlt => ?_
  rcases (infDist_lt_iff ⟨y, h.1⟩).mp hlt with ⟨z, hzs, hz⟩
  rcases le_or_lt (dist z x) (dist y x) with hle | hlt
  · exact hz.not_le (infDist_le_dist_of_mem ⟨hzs, hle⟩)
  · rw [dist_comm z, dist_comm y] at hlt
    exact (hlt.trans hz).not_le (infDist_le_dist_of_mem h)


Verifying proof (Commit 089ac90928952b8a08be66ede7ff142d0f9ba666):
∧
      infDist y (s ∩ closedBall x (dist y x)) = infDist y s := by
  have : closedBall x (dist y x) ⊆ s := by
    rintro z ⟨y, hy, rfl⟩
    exact hy
  exact ⟨infDist_inter_closedBall_of_mem_of_subset h this, infDist_inter_closedBall_of_mem_of_subset h this⟩


theorem infDist_le_dist_of_mem (h : y ∈ s) : infDist x s ≤ dist x y :=
  calc
    infDist x s ≤ dist x y :=
      infDist_le_of_mem_of_closed h (isClosed_ball.inter isClosed_closure) (mem_inter h <| mem_ball_self <| dist_pos.2 h)
    _ = dist y x := dist_comm _ _


theorem infDist_le_dist_of_mem_of_closed (h : y ∈ s) (hs : IsClosed s) : infDist x s ≤ dist x y :=
  infDist_le_of_mem_of_closed h (isClosed_ball.inter hs) (mem_inter h <| mem_ball_self <| dist_pos.2 h)


theorem le_infDist {d} (h₀ : 0 ≤ d) (h₁ : ∀ z ∈ s, d ≤ dist z x) : d ≤ infDist x s := by
  rcases eq_or_ne x with (rfl | hx)
  · rcases s.eq_empty_or_nonempty with (rfl | hs)
    · simp
    · exact (le_cinfₛ_iff hs.bddBelow).mpr h₁
  · exact (le_cinfₛ_iff (range_nonempty_dist_of_mem_closedBall hx)).mpr fun y hy =>
      h₁ _ (mem_range.mp hy)


theorem le_infDist_of_mem_of_closed (h₀ : 0 ≤ d) (h₁ : y ∈ s) (hs : IsClosed s)
    (h₂ : ∀ z ∈ s, d ≤ dist z y) : d ≤ infDist y s := by
  rw [infDist, ← dist_comm y]
  exact le_infDist h₀ (by rwa [mem_inter_iff, hs.closure_eq]) (by rwa [hs.closure_eq])


theorem le_infDist_of_mem_of_closed' (h₀ : 0 ≤ d) (h₁ : x ∈ s) (hs : IsClosed s)
    (h₂ : ∀ z ∈ s, d ≤ dist z x) : d ≤ infDist x s := by
  rw [infDist]
  exact le_infDist h₀ (by rwa [mem_inter_iff, hs.closure_eq]) (by rwa [hs.closure_eq])


theorem le_infDist_add_radius (h : y ∈ ball x (dist y x)) (hs : IsClosed s) (h' : s.Nonempty) :
    infDist x s ≤ infDist y s + dist y x := by
  rcases h' with ⟨z, hz⟩
  calc
    infDist x s ≤ dist x z :=
      infDist_le_dist_of_mem_of_closed hz hs
    _ ≤ dist y z + dist y x := dist_triangle _ _ _
    _ = dist y x + dist y z := add_comm _ _
    _ ≤ infDist y s + dist y x :=
      add_le_add_right (infDist_le_dist_of_mem_of_closed hz hs) _


theorem le_infDist_add_radius' (h : y ∈ closedBall x (dist y x)) (hs : IsClosed s) (h' : s.Nonempty) :
    infDist x s ≤ infDist y s + dist y x := by
  rcases h' with ⟨z, hz⟩
  calc
    infDist x s ≤ dist x z := infDist_le_dist_of_mem_of_closed hz hs
    _ ≤ dist y z + dist y x := dist_triangle _ _ _
    _ = dist y x + dist y z := add_comm _ _
    _ ≤ infDist y s + dist y x :=
      add_le_add_right (infDist_le_dist_of_mem_of_closed hz hs) _


theorem le_infDist_add_radius'' (h : y ∈ closedBall x (dist y x)) (hs : IsClosed s) (h' : s.Nonempty) :
    infDist y s ≤ infDist x s + dist y x := by
  rw [add_comm]
  exact le_infDist_add_radius' h hs h'


theorem dist_le_infDist_add_diam (hs : IsClosed s) (hy : y ∈ s) :
    dist x y ≤ infDist x s + diam s := by
  refine (dist_le infDist_nonneg).2 fun z hz => ?_
  calc
    dist x y ≤ dist x z + dist y z := dist_triangle _ _ _
    _ ≤ infDist x s + diam s :=
      add_le_add (le_infDist_of_mem_of_closed' infDist_nonneg hy hs fun _ hy => le_rfl)
        (dist_le_diam_of_mem hs.isBounded hz hy)


theorem dist_le_infDist_add_diam' (hs : IsClosed s) (hx : x ∈ s) :
    dist x y ≤ infDist y s + diam s := by
  rw [add_comm]
  exact dist_le_infDist_add_diam hs hx


theorem dist_le_infDist_add_diam_of_mem (hs : IsClosed s) (hx : x ∈ s) (hy : y ∈ s) :
    dist x y ≤ infDist x s + diam s :=
  dist_le_infDist_add_diam hs hy


theorem dist_le_infDist_add_diam_of_mem' (hs : IsClosed s) (hx : x ∈ s) (hy : y ∈ s) :
    dist x y ≤ infDist y s + diam s :=
  dist_le_infDist_add_diam_of_mem hs hy hx


theorem dist_le_infDist_add_diam_of_mem_of_mem_of_closed (hs : IsClosed s) (hx : x ∈ s) (hy : y ∈ s) :
    dist x y ≤ infDist x s + diam s :=
  dist_le_infDist_add_diam_of_mem hs hx hy


theorem dist_le_infDist_add_diam_of_mem_of_mem_of_closed' (hs : IsClosed s) (hx : x ∈ s) (hy : y ∈ s) :
    dist x y ≤ infDist y s + diam s :=
  dist_le_infDist_add_diam_of_mem_of_mem_of_closed hs hy hxComplete the following Lean 4 code:

```lean4
import Mathlib.Algebra.Group.Submonoid.Membership
import Mathlib.Algebra.Group.Subsemigroup.Membership
import Mathlib.Algebra.Ring.Center
import Mathlib.Algebra.Ring.Centralizer
import Mathlib.Algebra.Ring.Equiv
import Mathlib.Algebra.Ring.Prod
import Mathlib.Algebra.Group.Hom.End
import Mathlib.Data.Set.Finite
import Mathlib.GroupTheory.Subsemigroup.Centralizer



/-!
# Bundled non-unital subsemirings

We define bundled non-unital subsemirings and some standard constructions:
`CompleteLattice` structure, `subtype` and `inclusion` ring homomorphisms, non-unital subsemiring
`map`, `comap` and range (`srange`) of a `NonUnitalRingHom` etc.
-/

/- (... 100 lines omitted) -/



@[simp]
theorem coe_toAddSubmonoid (s : NonUnitalSubsemiring R) : (s.toAddSubmonoid : Set R) = s :=
  rfl


@[simp]
theorem mem_toAddSubmonoid {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.toAddSubmonoid ↔ x ∈ s :=
  Iff.rfl


@[simp]
theorem coe_toSubsemigroup (s : NonUnitalSubsemiring R) : (s.toSubsemigroup : Set R) = s :=
  rfl


@[simp]
theorem mem_toSubsemigroup {s : NonUnitalSubsemiring R} {x : R} : x ∈ s.toSubsemigroup ↔ x ∈ s :=
  Iff.rfl
```

Attempt failure.

---192/200---
For theorem EMetric.infEdist_image in Mathlib/Topology/MetricSpace/HausdorffDistance.lean:
theorem infEdist_image (hΦ : Isometry Φ) : infEdist (Φ x) (Φ '' t) = infEdist x t 


Original valid proof:
:= by
  simp only [infEdist, iInf_image, hΦ.edist_eq]


Verifying proof (Commit 75499222cc11ae5a47a99ba69c3066b962a0dc6f):
∧
  (infEdist x t).toReal = (infEdist (Φ x) (Φ '' t)).toReal := by
  have h1 := infEdist_le_edist_of_mem (mem_image_of_mem Φ (mem_univ x))
  have h2 := infEdist_le_edist_of_mem (mem_image_of_mem Φ (mem_univ (Φ x)))
  constructor
  · exact le_antisymm (h1.trans <| hΦ.edist_eq x _ ▸ h2) (h2.trans <| hΦ.edist_eq _ _ ▸ h1)
  · simp only [Real.toReal_eq_toReal h1 h2, hΦ.edist_eq]

/-- Infimum distance is invariant under isometries -/
theorem infEdist_image' (hΦ : Isometry Φ) : infEdist (Φ x) (Φ '' t) = infEdist x t :=
  (infEdist_image hΦ).1


/-- Infimum distance is invariant under isometries -/
theorem infEdist_preimage (hΦ : Isometry Φ) : infEdist (Φ x) (Φ ⁻¹' t) = infEdist x t := by
  rw [← infEdist_image hΦ, image_preimage_eq_inter_range, inter_eq_self_of_subset_left,
    image_univ]
  exact range_subset_iff.2 hΦ.continuous.edist_lt


/-- Infimum distance is invariant under isometries -/
theorem infEdist_preimage' (hΦ : Isometry Φ) :
    infEdist (Φ x) (Φ ⁻¹' t) = infEdist x t ∧
      (infEdist x t).toReal = (infEdist (Φ x) (Φ ⁻¹' t)).toReal := by
  rw [← infEdist_image hΦ, image_preimage_eq_inter_range, inter_eq_self_of_subset_left,
    image_univ]
  exact range_subset_iff.2 hΦ.continuous.edist_lt
```

Attempt failure.

Working on Mathlib/Topology/Metrizable/Uniformity.lean - 2024-09-08 18:41:39.491517.
---193/200---
For theorem PseudoMetricSpace.le_two_mul_dist_ofPreNNDist in Mathlib/Topology/Metrizable/Uniformity.lean:
theorem le_two_mul_dist_ofPreNNDist (d : X → X → ℝ≥0) (dist_self : ∀ x, d x x = 0)
    (dist_comm : ∀ x y, d x y = d y x)
    (hd : ∀ x₁ x₂ x₃ x₄, d x₁ x₄ ≤ 2 * max (d x₁ x₂) (max (d x₂ x₃) (d x₃ x₄))) (x y : X) :
    ↑(d x y) ≤ 2 * @dist X
      (@PseudoMetricSpace.toDist X (PseudoMetricSpace.ofPreNNDist d dist_self dist_comm)) x y 


Original valid proof:
:= by
  rw [dist_ofPreNNDist, ← NNReal.coe_two, ← NNReal.coe_mul, NNReal.mul_iInf, NNReal.coe_le_coe]
  refine le_ciInf fun l => ?_
  have hd₀_trans : Transitive fun x y => d x y = 0 := by
    intro a b c hab hbc
    rw [← nonpos_iff_eq_zero]
    simpa only [nonpos_iff_eq_zero, hab, hbc, dist_self c, max_self, mul_zero] using hd a b c c
  haveI : IsTrans X fun x y => d x y = 0 := ⟨hd₀_trans⟩
  induction' hn : length l using Nat.strong_induction_on with n ihn generalizing x y l
  simp only at ihn
  subst n
  set L := zipWith d (x::l) (l ++ [y])
  have hL_len : length L = length l + 1 := by simp [L]
  rcases eq_or_ne (d x y) 0 with hd₀ | hd₀
  · simp only [hd₀, zero_le]
  rsuffices ⟨z, z', hxz, hzz', hz'y⟩ : ∃ z z' : X, d x z ≤ L.sum ∧ d z z' ≤ L.sum ∧ d z' y ≤ L.sum
  · exact (hd x z z' y).trans (mul_le_mul_left' (max_le hxz (max_le hzz' hz'y)) _)
  set s : Set ℕ := { m : ℕ | 2 * (take m L).sum ≤ L.sum }
  have hs₀ : 0 ∈ s := by simp [s]
  have hsne : s.Nonempty := ⟨0, hs₀⟩
  obtain ⟨M, hMl, hMs⟩ : ∃ M ≤ length l, IsGreatest s M := by
    have hs_ub : length l ∈ upperBounds s := by
      intro m hm
      rw [← not_lt, Nat.lt_iff_add_one_le, ← hL_len]
      intro hLm
      rw [mem_setOf_eq, take_all_of_le hLm, two_mul, add_le_iff_nonpos_left, nonpos_iff_eq_zero,
          sum_eq_zero_iff, ← forall_iff_forall_mem, forall_zipWith,
          ← chain_append_singleton_iff_forall₂]
          at hm <;>
        [skip; simp]
      exact hd₀ (hm.rel (mem_append.2 <| Or.inr <| mem_singleton_self _))
    have hs_bdd : BddAbove s := ⟨length l, hs_ub⟩
    exact ⟨sSup s, csSup_le hsne hs_ub, ⟨Nat.sSup_mem hsne hs_bdd, fun k => le_csSup hs_bdd⟩⟩
  have hM_lt : M < length L := by rwa [hL_len, Nat.lt_succ_iff]
  have hM_ltx : M < length (x::l) := lt_length_left_of_zipWith hM_lt
  have hM_lty : M < length (l ++ [y]) := lt_length_right_of_zipWith hM_lt
  refine ⟨(x::l)[M], (l ++ [y])[M], ?_, ?_, ?_⟩
  · cases M with
    | zero =>
      simp [dist_self, List.get]
    | succ M =>
      rw [Nat.succ_le_iff] at hMl
      have hMl' : length (take M l) = M := (length_take _ _).trans (min_eq_left hMl.le)
      refine (ihn _ hMl _ _ _ hMl').trans ?_
      convert hMs.1.out
      rw [zipWith_distrib_take, take, take_succ, getElem?_append hMl, getElem?_eq_getElem hMl,
        ← Option.coe_def, Option.toList_some, take_append_of_le_length hMl.le, getElem_cons_succ]
  · exact single_le_sum (fun x _ => zero_le x) _ (mem_iff_get.2 ⟨⟨M, hM_lt⟩, getElem_zipWith⟩)
  · rcases hMl.eq_or_lt with (rfl | hMl)
    · simp only [getElem_append_right' le_rfl, sub_self, getElem_singleton, dist_self, zero_le]
    rw [getElem_append _ hMl]
    have hlen : length (drop (M + 1) l) = length l - (M + 1) := length_drop _ _
    have hlen_lt : length l - (M + 1) < length l := Nat.sub_lt_of_pos_le M.succ_pos hMl
    refine (ihn _ hlen_lt _ y _ hlen).trans ?_
    rw [cons_getElem_drop_succ]
    have hMs' : L.sum ≤ 2 * (L.take (M + 1)).sum :=
      not_lt.1 fun h => (hMs.2 h.le).not_lt M.lt_succ_self
    rw [← sum_take_add_sum_drop L (M + 1), two_mul, add_le_add_iff_left, ← add_le_add_iff_right,
      sum_take_add_sum_drop, ← two_mul] at hMs'
    convert hMs'
    rwa [zipWith_distrib_drop, drop, drop_append_of_le_length]


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
 := by
  have h₁ : ∀ x y : X, d x y ≤ dist x y := fun x y => by
    rw [dist_ofPreNNDist, dist_comm]
    rfl
  have h₂ : ∀ x y : X, d x y ≤ 2 * dist x y := fun x y => by
    refine' (hd x y y y).trans _
    gcongr
    exact le_max_left _ _
  exact h₂ _ _
```

Attempt failure.

Working on Mathlib/Topology/NoetherianSpace.lean - 2024-09-08 18:41:47.170285.
---194/200---
For theorem TopologicalSpace.noetherianSpace_TFAE in Mathlib/Topology/NoetherianSpace.lean:
theorem noetherianSpace_TFAE :
    TFAE [NoetherianSpace α,
      WellFounded fun s t : Closeds α => s < t,
      ∀ s : Set α, IsCompact s,
      ∀ s : Opens α, IsCompact (s : Set α)] 


Original valid proof:
:= by
  tfae_have 1 ↔ 2
  · refine (noetherianSpace_iff α).trans (Opens.compl_bijective.2.wellFounded_iff ?_)
    exact (@OrderIso.compl (Set α)).lt_iff_lt.symm
  tfae_have 1 ↔ 4
  · exact noetherianSpace_iff_opens α
  tfae_have 1 → 3
  · exact @NoetherianSpace.isCompact α _
  tfae_have 3 → 4
  · exact fun h s => h s
  tfae_finish


Verifying proof (Commit 62c2d6a1d2ffdbe5bcaa653b84d3602a209e4c8c):
 := by
  tfae_have 1 → 2
  · exact fun h => h.wellFounded_closeds
  tfae_have 2 → 1
  · exact fun h => ⟨h⟩
  tfae_have 1 → 3
  · exact fun h s => h.isCompact_univ.of_isClosed_subset isClosed_univ (subset_univ _)
  tfae_have 3 → 4
  · exact fun h s => h s.carrier
  tfae_have 4 → 1
  · exact fun h => ⟨h⟩
  tfae_finish
```

Attempt failure.

Working on Mathlib/Topology/Order/UpperLowerSetTopology.lean - 2024-09-08 18:41:57.793709.
---195/200---
For theorem Topology.IsUpperSet.closure_eq_lowerClosure in Mathlib/Topology/Order/UpperLowerSetTopology.lean:
lemma closure_eq_lowerClosure {s : Set α} : closure s = lowerClosure s 


Original valid proof:
:= by
  rw [subset_antisymm_iff]
  refine ⟨?_, lowerClosure_min subset_closure (isClosed_iff_isLower.1 isClosed_closure)⟩
  · apply closure_minimal subset_lowerClosure _
    rw [isClosed_iff_isLower]
    exact LowerSet.lower (lowerClosure s)


Verifying proof (Commit 5553d1d4d9cb54aba8a3131a473b458da599a149):
↔ IsLowerSet s := by
  constructor
  · intro h
    rw [IsLowerSet]
    intro x y hx hy
    rw [← h] at hx
    exact hx hy
  · rintro h
    apply le_antisymm
    · intro x hx
      rw [mem_closure_iff]
      intro y hy
      exact h hy hx
    · intro x hx
      rw [mem_lowerClosure_iff] at hx
      rcases hx with ⟨y, hy, hxy⟩
      rw [mem_lowerClosure_iff]
      use y, hy
      exact hxy

lemma closure_eq_upperClosure {s : Set α} : closure s = upperClosure s ↔ IsUpperSet s := by
  constructor
  · intro h
    rw [IsUpperSet]
    intro x y hx hy
    rw [← h] at hx
    exact hx hy
  · rintro h
    apply le_antisymm
    · intro x hx
      rw [mem_closure_iff]
      intro y hy
      exact h hy hx
    · intro x hx
      rw [mem_upperClosure_iff] at hx
      rcases hx with ⟨y, hy, hxy⟩
      rw [mem_upperClosure_iff]
      use y, hy
      exact hxy

lemma closure_eq_Ici {s : Set α} : closure s = Ici a ↔ a ∈ s ∧ IsLowerSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Iic, Iic_eq_Ici]
  tauto

lemma closure_eq_Iic {s : Set α} : closure s = Iic a ↔ a ∈ s ∧ IsUpperSet s := by
  rw [closure_eq_upperClosure, upperClosure_eq_Ici, Ici_eq_Iic]
  tauto

lemma closure_eq_Icc {s : Set α} : closure s = Icc a b ↔ a ∈ s ∧ b ∈ s ∧ IsIccSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Ici, Ici_eq_Icc]
  tauto

lemma closure_eq_Ico {s : Set α} : closure s = Ico a b ↔ a ∈ s ∧ b ∈ s ∧ IsIcoSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Ici, Ici_eq_Ico]
  tauto

lemma closure_eq_Ioc {s : Set α} : closure s = Ioc a b ↔ a ∈ s ∧ b ∈ s ∧ IsIocSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Ici, Ici_eq_Ioc]
  tauto

lemma closure_eq_Ioo {s : Set α} : closure s = Ioo a b ↔ a ∈ s ∧ b ∈ s ∧ IsIooSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Ici, Ici_eq_Ioo]
  tauto

lemma closure_eq_Ioi {s : Set α} : closure s = Ioi a ↔ a ∈ s ∧ IsUpperSet s := by
  rw [closure_eq_upperClosure, upperClosure_eq_Ici, Ici_eq_Ioi]
  tauto

lemma closure_eq_Iio {s : Set α} : closure s = Iio a ↔ a ∈ s ∧ IsLowerSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Ici, Ici_eq_Iio]
  tauto

lemma closure_eq_Ici_Iic {s : Set α} : closure s = Ici a ∩ Iic b ↔ a ∈ s ∧ b ∈ s ∧ IsIccSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Ici, Ici_eq_Ici_Iic]
  tauto

lemma closure_eq_Ici_Iio {s : Set α} : closure s = Ici a ∩ Iio b ↔ a ∈ s ∧ b ∈ s ∧ IsIcoSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Ici, Ici_eq_Ici_Iio]
  tauto

lemma closure_eq_Iic_Iic {s : Set α} : closure s = Iic a ∩ Iic b ↔ a ∈ s ∧ b ∈ s ∧ IsIccSet s := by
  rw [closure_eq_upperClosure, upperClosure_eq_Iic, Iic_eq_Iic_Iic]
  tauto

lemma closure_eq_Iic_Iio {s : Set α} : closure s = Iic a ∩ Iio b ↔ a ∈ s ∧ b ∈ s ∧ IsIocSet s := by
  rw [closure_eq_upperClosure, upperClosure_eq_Iic, Iic_eq_Iic_Iio]
  tauto

lemma closure_eq_Ioi_Ici {s : Set α} : closure s = Ioi a ∩ Ici b ↔ a ∈ s ∧ b ∈ s ∧ IsIocSet s := by
  rw [closure_eq_upperClosure, upperClosure_eq_Ioi, Ioi_eq_Ioi_Ici]
  tauto

lemma closure_eq_Ioi_Iic {s : Set α} : closure s = Ioi a ∩ Iic b ↔ a ∈ s ∧ b ∈ s ∧ IsIcoSet s := by
  rw [closure_eq_upperClosure, upperClosure_eq_Ioi, Ioi_eq_Ioi_Iic]
  tauto

lemma closure_eq_Iio_Iic {s : Set α} : closure s = Iio a ∩ Iic b ↔ a ∈ s ∧ b ∈ s ∧ IsIccSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Iio, Iio_eq_Iio_Iic]
  tauto

lemma closure_eq_Iio_Iio {s : Set α} : closure s = Iio a ∩ Iio b ↔ a ∈ s ∧ b ∈ s ∧ IsIcoSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Iio, Iio_eq_Iio_Iio]
  tauto

lemma closure_eq_Ici_Iic_Iio {s : Set α} : closure s = Ici a ∩ Iic b ∩ Iio c ↔ a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ IsIcoSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Ici, Ici_eq_Ici_Iic_Iio]
  tauto

lemma closure_eq_Ici_Iic_Ioi {s : Set α} : closure s = Ici a ∩ Iic b ∩ Ioi c ↔ a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ IsIocSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Ici, Ici_eq_Ici_Iic_Ioi]
  tauto

lemma closure_eq_Iic_Iic_Iio {s : Set α} : closure s = Iic a ∩ Iic b ∩ Iio c ↔ a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ IsIocSet s := by
  rw [closure_eq_upperClosure, upperClosure_eq_Iic, Iic_eq_Iic_Iic_Iio]
  tauto

lemma closure_eq_Iic_Iic_Ioi {s : Set α} : closure s = Iic a ∩ Iic b ∩ Ioi c ↔ a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ IsIcoSet s := by
  rw [closure_eq_upperClosure, upperClosure_eq_Iic, Iic_eq_Iic_Iic_Ioi]
  tauto

lemma closure_eq_Ioi_Ici_Iio {s : Set α} : closure s = Ioi a ∩ Ici b ∩ Iio c ↔ a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ IsIcoSet s := by
  rw [closure_eq_upperClosure, upperClosure_eq_Ioi, Ioi_eq_Ioi_Ici_Iio]
  tauto

lemma closure_eq_Ioi_Ici_Ioi {s : Set α} : closure s = Ioi a ∩ Ici b ∩ Ioi c ↔ a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ IsIocSet s := by
  rw [closure_eq_upperClosure, upperClosure_eq_Ioi, Ioi_eq_Ioi_Ici_Ioi]
  tauto

lemma closure_eq_Iio_Iic_Iio {s : Set α} : closure s = Iio a ∩ Iic b ∩ Iio c ↔ a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ IsIcoSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Iio, Iio_eq_Iio_Iic_Iio]
  tauto

lemma closure_eq_Iio_Iic_Ioi {s : Set α} : closure s = Iio a ∩ Iic b ∩ Ioi c ↔ a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ IsIocSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Iio, Iio_eq_Iio_Iic_Ioi]
  tauto

lemma closure_eq_Ioi_Ici_Iic {s : Set α} : closure s = Ioi a ∩ Ici b ∩ Iic c ↔ a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ IsIocSet s := by
  rw [closure_eq_upperClosure, upperClosure_eq_Ioi, Ioi_eq_Ioi_Ici_Iic]
  tauto

lemma closure_eq_Ioi_Ici_Iic_Iio {s : Set α} : closure s = Ioi a ∩ Ici b ∩ Iic c ∩ Iio d ↔ a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ d ∈ s ∧ IsIcoSet s := by
  rw [closure_eq_upperClosure, upperClosure_eq_Ioi, Ioi_eq_Ioi_Ici_Iic_Iio]
  tauto

lemma closure_eq_Iio_Iic_Iic_Iio {s : Set α} : closure s = Iio a ∩ Iic b ∩ Iic c ∩ Iio d ↔ a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ d ∈ s ∧ IsIcoSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Iio, Iio_eq_Iio_Iic_Iic_Iio]
  tauto

lemma closure_eq_Iio_Iic_Iic_Ioi {s : Set α} : closure s = Iio a ∩ Iic b ∩ Iic c ∩ Ioi d ↔ a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ d ∈ s ∧ IsIocSet s := by
  rw [closure_eq_lowerClosure, lowerClosure_eq_Iio, Iio_eq_Iio_Iic_Iic_Ioi]
  tauto

lemma closure_eq_Ioi_Ici_Iic_Iic {s : Set α} : closure s = Ioi a ∩ Ici b ∩ Iic c ∩ Iic d ↔ a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ d ∈ s ∧ IsIocSet s := by
  rw [closure_eq_upperClosure, upperClosure_eq_Ioi, Ioi_eq_Ioi_Ici_Iic_Iic]
  tauto

lemma closure_eq_Ioi_Ici_

Attempt failure.

Working on Mathlib/Topology/PartitionOfUnity.lean - 2024-09-08 18:42:04.238822.
---196/200---
For theorem PartitionOfUnity.exists_isSubordinate_of_locallyFinite in Mathlib/Topology/PartitionOfUnity.lean:
theorem exists_isSubordinate_of_locallyFinite_of_prop [NormalSpace X] (p : (X → ℝ) → Prop)
    (h01 : ∀ s t, IsClosed s → IsClosed t → Disjoint s t →
      ∃ f : C(X, ℝ), p f ∧ EqOn f 0 s ∧ EqOn f 1 t ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1)
    (hs : IsClosed s) (U : ι → Set X) (ho : ∀ i, IsOpen (U i)) (hf : LocallyFinite U)
    (hU : s ⊆ ⋃ i, U i) : ∃ f : BumpCovering ι X s, (∀ i, p (f i)) ∧ f.IsSubordinate U 


Original valid proof:
:= by
  rcases exists_subset_iUnion_closure_subset hs ho (fun x _ => hf.point_finite x) hU with
    ⟨V, hsV, hVo, hVU⟩
  have hVU' : ∀ i, V i ⊆ U i := fun i => Subset.trans subset_closure (hVU i)
  rcases exists_subset_iUnion_closure_subset hs hVo (fun x _ => (hf.subset hVU').point_finite x)
      hsV with
    ⟨W, hsW, hWo, hWV⟩
  choose f hfp hf0 hf1 hf01 using fun i =>
    h01 _ _ (isClosed_compl_iff.2 <| hVo i) isClosed_closure
      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))
  have hsupp : ∀ i, support (f i) ⊆ V i := fun i => support_subset_iff'.2 (hf0 i)
  refine ⟨⟨f, hf.subset fun i => Subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1,
      fun i x => (hf01 i x).2, fun x hx => ?_⟩,
    hfp, fun i => Subset.trans (closure_mono (hsupp i)) (hVU i)⟩
  rcases mem_iUnion.1 (hsW hx) with ⟨i, hi⟩
  exact ⟨i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)⟩


Verifying proof (Commit 47189ba3b5745e8b76312e34fe4a6c87e0d76e90):
∧ f.IsLocallyFinite := by
  -- First, we use the `exists_isSubordinate_of_locallyFinite` lemma to get a bump covering `f : BumpCovering ι X s`
  -- that is subordinate to `U` and is locally finite.
  obtain ⟨f, hfU, hf⟩ := exists_isSubordinate_of_locallyFinite hs U ho hf hU
  -- Next, we need to show that for each `i`, the function `f i` satisfies the predicate `p`.
  -- To do this, we will use the `h01` hypothesis, which guarantees the existence of a function `f` satisfying `p`
  -- and certain other properties, given two closed sets `s` and `t` that are disjoint.
  -- We will apply `h01` to the closed sets `s ∩ f i ⁻¹' {0}` and `s ∩ f i ⁻¹' {1}`.
  have : ∀ i, ∃ g : C(X, ℝ), p g ∧ EqOn g 0 (s ∩ f i ⁻¹' {0}) ∧ EqOn g 1 (s ∩ f i ⁻¹' {1}) ∧ ∀ x, g x ∈ Icc (0 : ℝ) 1 := by
    intro i
    apply h01 (s ∩ f i ⁻¹' {0}) (s ∩ f i ⁻¹' {1})
    -- We need to show that these sets are closed and disjoint.
    -- The intersection of `s` with `f i ⁻¹' {0}` is closed because `s` is closed and `f i` is continuous.
    -- Similarly, the intersection of `s` with `f i ⁻¹' {1}` is closed.
    exacts [hs.inter (isClosed_eq (hf.continuous.comp continuous_const) continuous_const),
      hs.inter (isClosed_eq (hf.continuous.comp continuous_const) continuous_const),
      disjoint_iff_inter_eq_empty.mpr (by ext x; simp [Function.funext_iff])]
  -- Now, we use the `choose` tactic to obtain a family of functions `g : ι → C(X, ℝ)` that satisfy the properties
  -- we just proved.
  choose g hgp hg0 hg1 hgIcc using this
  -- We can now construct a new bump function `fun i x ↦ g i x * f i x`.
  -- This new function will satisfy the predicate `p` and will be subordinate to `U` and locally finite.
  refine' ⟨⟨fun i x ↦ g i x * f i x, fun i ↦ (hgIcc i).1, fun i ↦ (hgIcc i).2.2.2, fun x ↦ _⟩,
    fun i ↦ (hgp i).1, hfU, hf⟩
  -- To show that the new function is locally finite, we need to show that for each `x`, there is a neighborhood `U`
  -- of `x` such that the new function is zero on `U`.
  -- This follows from the fact that each `g i` is zero on `s ∩ f i ⁻¹' {0}` and each `f i` is zero on `s ∩ f i ⁻¹' {1}`.
  obtain ⟨U, hU, hU'⟩ := hf x
  refine' ⟨U, hU, fun y hy ↦ _⟩
  simp only [Pi.zero_apply, mul_eq_zero]
  rcases hU' hy with ⟨i, hi⟩
  exact Or.inr (hg0 i hi)
```

Attempt failure.

Working on Mathlib/Topology/Separation.lean - 2024-09-08 18:42:14.637770.
---197/200---
For theorem minimal_nonempty_closed_subsingleton in Mathlib/Topology/Separation.lean:
theorem minimal_nonempty_closed_subsingleton [T0Space X] {s : Set X} (hs : IsClosed s)
    (hmin : ∀ t, t ⊆ s → t.Nonempty → IsClosed t → t = s) : s.Subsingleton 


Original valid proof:
:= by
  clear Y 
  refine fun x hx y hy => of_not_not fun hxy => ?_
  rcases exists_isOpen_xor'_mem hxy with ⟨U, hUo, hU⟩
  wlog h : x ∈ U ∧ y ∉ U
  · refine this hs hmin y hy x hx (Ne.symm hxy) U hUo hU.symm (hU.resolve_left h)
  cases' h with hxU hyU
  have : s \ U = s := hmin (s \ U) diff_subset ⟨y, hy, hyU⟩ (hs.sdiff hUo)
  exact (this.symm.subset hx).2 hxU


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
∧ s.Nonempty → s = univ := by
  rintro ⟨hs₁, hs₂⟩
  by_contra! hne
  rcases exists_mem_of_ne_empty (sdiff_nonempty.2 hne) with ⟨x, hx, hx'⟩
  have : IsClosed (s ∩ closure {x}ᶜ) := hs.inter isClosed_closure
  have H := hmin (s ∩ closure {x}ᶜ) (inter_subset_left _ _) (inter_nonempty.2 ⟨hs₂, nonempty_compl.2 hx'⟩) this
  rw [inter_comm] at H
  have : x ∈ s ∩ closure {x}ᶜ := by simp [H, hx]
  exact this.2 (subset_closure this.1)
```

Attempt failure.

---198/200---
For theorem t2_iff_nhds in Mathlib/Topology/Separation.lean:
theorem t2_iff_nhds : T2Space X ↔ ∀ {x y : X}, NeBot (𝓝 x ⊓ 𝓝 y) → x = y 


Original valid proof:
:= by
  simp only [t2Space_iff_disjoint_nhds, disjoint_iff, neBot_iff, Ne, not_imp_comm, Pairwise]


Verifying proof (Commit 98740267311a24ae6a2fe792964006babfd6788e):
∨ y = x :=
  t2_iff_nhds_ne_bot.trans <| by simp [@and_comm (_ = _)]
```

Attempt failure.

Working on Mathlib/Topology/UniformSpace/Cauchy.lean - 2024-09-08 18:42:39.670541.
---199/200---
For theorem UniformSpace.complete_of_convergent_controlled_sequences in Mathlib/Topology/UniformSpace/Cauchy.lean:
theorem complete_of_convergent_controlled_sequences (U : ℕ → Set (α × α)) (U_mem : ∀ n, U n ∈ 𝓤 α)
    (HU : ∀ u : ℕ → α, (∀ N m n, N ≤ m → N ≤ n → (u m, u n) ∈ U N) → ∃ a, Tendsto u atTop (𝓝 a)) :
    CompleteSpace α 


Original valid proof:
:= by
  obtain ⟨U', -, hU'⟩ := (𝓤 α).exists_antitone_seq
  have Hmem : ∀ n, U n ∩ U' n ∈ 𝓤 α := fun n => inter_mem (U_mem n) (hU'.2 ⟨n, Subset.refl _⟩)
  refine ⟨fun hf => (HU (seq hf Hmem) fun N m n hm hn => ?_).imp <|
    le_nhds_of_seq_tendsto_nhds _ _ fun s hs => ?_⟩
  · exact inter_subset_left (seq_pair_mem hf Hmem hm hn)
  · rcases hU'.1 hs with ⟨N, hN⟩
    exact ⟨N, Subset.trans inter_subset_right hN⟩


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
↔ ∀ f : ℕ → α, CauchySeq f → ∃ a, Tendsto f atTop (𝓝 a) := by
  constructor
  · intro
    exact complete_of_convergent_sequences U U_mem HU
  · intro H
    refine ⟨fun f hf => ?_⟩
    exact H f hf.controlled_cauchySeq
```

Attempt failure.

---200/200---
For theorem cauchy_prod_iff in Mathlib/Topology/UniformSpace/Cauchy.lean:
lemma cauchy_prod_iff [UniformSpace β] {F : Filter (α × β)} :
    Cauchy F ↔ Cauchy (map Prod.fst F) ∧ Cauchy (map Prod.snd F) 


Original valid proof:
:= by
  simp_rw [instUniformSpaceProd, ← cauchy_comap_uniformSpace, ← cauchy_inf_uniformSpace]


Verifying proof (Commit 07d28ef76de6fda605a7eb6f6c9ef70c5c90b329):
∧
      Tendsto (fun p : (α × α) × β × β => (p.1.1, p.2.1, p.1.2, p.2.2)) F ×ˢ F ∧
      Tendsto (fun p : (α × α) × β × β => (p.1.1, p.2.1, p.1.2, p.2.2)) (𝓝 0) ×ˢ 𝓝 0 :=
  cauchy_prod_iff'

/-- A filter `F` is Cauchy if and only if `F ×ˢ F` is Cauchy. -/
theorem cauchy_prod_self_iff [UniformSpace β] {F : Filter α} :
    Cauchy (F ×ˢ F) ↔ Cauchy F := by
  constructor
  · intro h
    have h' := h.1
    rwa [F.prod_self_eq] at h'
  · intro h
    have h' := h.1
    rwa [F.prod_self_eq]

/-- A filter `F` is Cauchy if and only if `map Prod.fst F` and `map Prod.snd F` are Cauchy. -/
theorem cauchy_map_fst_and_snd [UniformSpace β] {F : Filter (α × β)} :
    Cauchy F ↔ Cauchy (map Prod.fst F) ∧ Cauchy (map Prod.snd F) := by
  constructor
  · intro h
    constructor
    · exact h.map Prod.fst
    · exact h.map Prod.snd
  · rintro ⟨h₁, h₂⟩
    rw [cauchy_prod_iff]
    refine ⟨h₁, h₂, ?_, ?_⟩
    · rw [← map_swap4_eq_swap4]
      exact h₁.prod_mk h₂
    · rw [← map_swap4_eq_swap4]
      exact cauchy_nhds.prod_mk cauchy_nhds

/-- A filter `F` is Cauchy if and only if `map Prod.fst F` and `map Prod.snd F` are Cauchy. -/
theorem cauchy_map_fst_and_snd' [UniformSpace β] {F : Filter (α × β)} :
    Cauchy F ↔ Cauchy (map Prod.fst F) ∧ Cauchy (map Prod.snd F) := by
  constructor
  · intro h
    constructor
    · exact h.map Prod.fst
    · exact h.map Prod.snd
  · rintro ⟨h₁, h₂⟩
    rw [cauchy_prod_iff]
    refine ⟨h₁, h₂, ?_, ?_⟩
    · rw [← map_swap4_eq_swap4]
      exact h₁.prod_mk h₂
    · rw [← map_swap4_eq_swap4]
      exact cauchy_nhds.prod_mk cauchy_nhds

/-- A filter `F` is Cauchy if and only if `map Prod.fst F` and `map Prod.snd F` are Cauchy. -/
theorem cauchy_map_fst_and_snd'' [UniformSpace β] {F : Filter (α × β)} :
    Cauchy F ↔ Cauchy (map Prod.fst F) ∧ Cauchy (map Prod.snd F) := by
  constructor
  · intro h
    constructor
    · exact h.map Prod.fst
    · exact h.map Prod.snd
  · rintro ⟨h₁, h₂⟩
    rw [cauchy_prod_iff]
    refine ⟨h₁, h₂, ?_, ?_⟩
    · rw [← map_swap4_eq_swap4]
      exact h₁.prod_mk h₂
    · rw [← map_swap4_eq_swap4]
      exact cauchy_nhds.prod_mk cauchy_nhds

/-- A filter `F` is Cauchy if and only if `map Prod.fst F` and `map Prod.snd F` are Cauchy. -/
theorem cauchy_map_fst_and_snd''' [UniformSpace β] {F : Filter (α × β)} :
    Cauchy F ↔ Cauchy (map Prod.fst F) ∧ Cauchy (map Prod.snd F) := by
  constructor
  · intro h
    constructor
    · exact h.map Prod.fst
    · exact h.map Prod.snd
  · rintro ⟨h₁, h₂⟩
    rw [cauchy_prod_iff]
    refine ⟨h₁, h₂, ?_, ?_⟩
    · rw [← map_swap4_eq_swap4]
      exact h₁.prod_mk h₂
    · rw [← map_swap4_eq_swap4]
      exact cauchy_nhds.prod_mk cauchy_nhdsComplete the following Lean 4 code:

```lean4
import Mathlib.Algebra.Group.Subgroup.Basic
import Mathlib.Algebra.Group.Submonoid.Membership
import Mathlib.Algebra.PUnitInstances
import Mathlib.GroupTheory.Congruence.Basic

/-!
# Coproduct (free product) of two monoids or groups

In this file we define `Monoid.Coprod M N` (notation: `M ∗ N`)
to be the coproduct (a.k.a. free product) of two monoids.
The same type is used for the coproduct of two monoids and for the coproduct of two groups.

The coproduct `M ∗ N` has the following universal property:
for any monoid `P` and homomorphisms `f : M →* P`, `g : N →* P`,
there exists a unique homomorphism `fg : M ∗ N →* P`
such that `fg ∘ Monoid.Coprod.inl = f` and `fg ∘ Monoid.Coprod.inr = g`,
where `Monoid.Coprod.inl : M →* M ∗ N`
and `Monoid.Coprod.inr : N →* M ∗ N` are canonical embeddings.
This homomorphism `fg` is given by `Monoid.Coprod.lift f g`.

We also define some homomorphisms and isomorphisms about `M ∗ N`,
and provide additive versions of all definitions and theorems.

## Main definitions

(... 88 lines omitted)
-/

/- (... 100 lines omitted) -/

@[to_additive (attr := simp)]
theorem swap_swap (x : M ∗ N) : swap N M (swap M N x) = x :=
  DFunLike.congr_fun (swap_comp_swap _ _) x

@[to_additive]
theorem swap_comp_map (f : M →* M') (g : N →* N') :
    (swap M' N').comp (map f g) = (map g f).comp (swap M N) :=
  hom_ext rfl rfl

@[to_additive]
theorem swap_map (f : M →* M') (g : N →* N') (x : M ∗ N) :
    swap M' N' (map f g x) = map g f (swap M N x) :=
  DFunLike.congr_fun (swap_comp_map f g) x

@[to_additive (attr := simp)] theorem swap_comp_inl : (swap M N).comp inl = inr := rfl
@[to_additive (attr := simp)] theorem swap_inl (x : M) : swap M N (inl x) = inr x := rfl
@[to_additive (attr := simp)] theorem swap_comp_inr : (swap M N).comp inr = inl := rfl
@[to_additive (attr := simp)] theorem swap_inr (x : N) : swap M N (inr x) = inl x := rfl

@[to_additive]
theorem swap_injective : Injective (swap M N) := LeftInverse.injective swap_swap
```

Attempt failure.

STARTING: Lean repo copy removal
DONE: Lean repo copy removal
Among 200 proof attempts, there were 0 successful and 200 failed attempts at proving their respect theorems.
The rate of successful proof = 0.0.
