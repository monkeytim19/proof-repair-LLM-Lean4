STARTING: verification of proofs from predicted_proof column in dataset from models/reprover_proving/base/test_random_reprover_proving_base_prediction.csv - 2024-09-08 23:27:59.565709
Working on Mathlib/Algebra/AddTorsor.lean - 2024-09-08 23:27:59.571582.
---1/200---
For theorem Equiv.pointReflection_fixed_iff_of_injective_bit0 in Mathlib/Algebra/AddTorsor.lean:
theorem pointReflection_fixed_iff_of_injective_bit0 {x y : P} (h : Injective (bit0 : G â†’ G)) :
    pointReflection x y = y â†” y = x 


Original valid proof:
:= by
  rw [pointReflection_apply, eq_comm, eq_vadd_iff_vsub_eq, â† neg_vsub_eq_vsub_rev,
    neg_eq_iff_add_eq_zero, â† bit0, â† bit0_zero, h.eq_iff, vsub_eq_zero_iff_eq, eq_comm]


Verifying proof (Commit b0c1460c9fd4a5058bcae6b919686bc5e8a0ee37):
rw [pointReflection_eq_pointReflection pointReflection_fixed_iff_of_injective_bit0,
  pointReflection_fixed_iff_of_injective_bit0]

Attempt failure.

Working on Mathlib/Algebra/BigOperators/Fin.lean - 2024-09-08 23:30:50.368141.
---2/200---
For theorem Fin.prod_ofFn in Mathlib/Algebra/BigOperators/Fin.lean:
theorem prod_ofFn [CommMonoid Î²] {n : â„•} (f : Fin n â†’ Î²) : (List.ofFn f).prod = âˆ i, f i 


Original valid proof:
:= by
  simp [prod_eq_multiset_prod]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
simp only [List.ofFn, List.ofFn, List.ofFn, List.ofFn, List.ofFn, List.ofFn, List.ofFn,
  List.ofFn, List.ofFn, List.ofFn]

Attempt failure.

Working on Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean - 2024-09-08 23:31:35.480911.
---3/200---
For theorem GeneralizedContinuedFraction.get?_of_eq_some_of_succ_get?_intFractPair_stream in Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean:
theorem get?_of_eq_some_of_succ_get?_intFractPair_stream {ifp_succ_n : IntFractPair K}
    (stream_succ_nth_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n) :
    (of v).s.get? n = some âŸ¨1, ifp_succ_n.bâŸ© 


Original valid proof:
:= by
  unfold of IntFractPair.seq1
  simp [Stream'.Seq.map_tail, Stream'.Seq.get?_tail, Stream'.Seq.map_get?, stream_succ_nth_eq]


Verifying proof (Commit 67bb925387960887a3b36a6aab219b9c613883f7):
simp [stream_succ_nth_eq, stream_succ_nth_eq]

Attempt failure.

---4/200---
For theorem GeneralizedContinuedFraction.of_s_tail in Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean:
theorem of_s_tail : (of v).s.tail = (of (fract v)â»Â¹).s 


Original valid proof:
:=
  Stream'.Seq.ext fun n => Stream'.Seq.get?_tail (of v).s n â–¸ of_s_succ v n


Verifying proof (Commit 67bb925387960887a3b36a6aab219b9c613883f7):
simp of_s_tail

Attempt failure.

Working on Mathlib/Algebra/DirectLimit.lean - 2024-09-08 23:32:24.666395.
---5/200---
For theorem AddCommGroup.DirectLimit.map_comp in Mathlib/Algebra/DirectLimit.lean:
lemma map_comp [IsDirected Î¹ (Â· â‰¤ Â·)]
    (gâ‚ : (i : Î¹) â†’ G i â†’â‚—[R] G' i) (gâ‚‚ : (i : Î¹) â†’ G' i â†’â‚—[R] G'' i)
    (hgâ‚ : âˆ€ i j h, gâ‚ j âˆ˜â‚— f i j h = f' i j h âˆ˜â‚— gâ‚ i)
    (hgâ‚‚ : âˆ€ i j h, gâ‚‚ j âˆ˜â‚— f' i j h = f'' i j h âˆ˜â‚— gâ‚‚ i) :
    (map gâ‚‚ hgâ‚‚ âˆ˜â‚— map gâ‚ hgâ‚ :
      DirectLimit G f â†’â‚—[R] DirectLimit G'' f'') =
    (map (fun i â†¦ gâ‚‚ i âˆ˜â‚— gâ‚ i) fun i j h â†¦ by
        rw [LinearMap.comp_assoc, hgâ‚ i, â† LinearMap.comp_assoc, hgâ‚‚ i, LinearMap.comp_assoc] :
      DirectLimit G f â†’â‚—[R] DirectLimit G'' f'') 


Original valid proof:
:=
  DFunLike.ext _ _ fun x â†¦ (isEmpty_or_nonempty Î¹).elim (fun _ â†¦ Subsingleton.elim _ _) fun _ â†¦
    x.induction_on fun i g â†¦ by simp


Verifying proof (Commit af1e1921fa808d9f4d24fd674214116943e9fbb8):
dsimp [LinearMap.comp_assoc, LinearMap.comp_assoc]

Attempt failure.

Working on Mathlib/Algebra/DirectSum/Decomposition.lean - 2024-09-08 23:33:20.770688.
---6/200---
For theorem DirectSum.decompose_lhom_ext in Mathlib/Algebra/DirectSum/Decomposition.lean:
theorem decompose_lhom_ext {N} [AddCommMonoid N] [Module R N] â¦ƒf g : M â†’â‚—[R] Nâ¦„
    (h : âˆ€ i, f âˆ˜â‚— (â„³ i).subtype = g âˆ˜â‚— (â„³ i).subtype) : f = g 


Original valid proof:
:=
  LinearMap.ext <| (decomposeLinearEquiv â„³).symm.surjective.forall.mpr <|
    suffices f âˆ˜â‚— (decomposeLinearEquiv â„³).symm
           = (g âˆ˜â‚— (decomposeLinearEquiv â„³).symm : (â¨ i, â„³ i) â†’â‚—[R] N) from
      DFunLike.congr_fun this
    linearMap_ext _ fun i => by
      simp_rw [LinearMap.comp_assoc, decomposeLinearEquiv_symm_comp_lof â„³ i, h]


Verifying proof (Commit b071b57a84e9970e988d47cb1622531297757a79):
apply Submodule.ext_of_linear_subtype

Attempt failure.

Working on Mathlib/Algebra/Homology/ExactSequence.lean - 2024-09-08 23:33:41.652531.
---7/200---
For theorem CategoryTheory.ComposableArrows.exact_iff_Î´last in Mathlib/Algebra/Homology/ExactSequence.lean:
lemma exact_iff_Î´last {n : â„•} (S : ComposableArrows C (n + 2)) :
    S.Exact â†” S.Î´last.Exact âˆ§ (mkâ‚‚ (S.map' n (n + 1)) (S.map' (n + 1) (n + 2))).Exact 


Original valid proof:
:= by
  constructor
  Â· intro h
    constructor
    Â· exact Exact.mk (IsComplex.mk (fun i hi => h.toIsComplex.zero i))
        (fun i hi => h.exact i)
    Â· rw [exactâ‚‚_iff]; swap
      Â· rw [isComplexâ‚‚_iff]
        exact h.toIsComplex.zero n
      exact h.exact n (by omega)
  Â· rintro âŸ¨h, h'âŸ©
    refine Exact.mk (IsComplex.mk (fun i hi => ?_)) (fun i hi => ?_)
    Â· simp only [add_le_add_iff_right, ge_iff_le] at hi
      obtain hi | rfl := hi.lt_or_eq
      Â· exact h.toIsComplex.zero i
      Â· exact h'.toIsComplex.zero 0
    Â· simp only [add_le_add_iff_right, ge_iff_le] at hi
      obtain hi | rfl := hi.lt_or_eq
      Â· exact h.exact i
      Â· exact h'.exact 0


Verifying proof (Commit 4ce1bee1aec1b13e15aa7ab6b7f2b65c272ebb54):
constructor

Attempt failure.

Working on Mathlib/Algebra/Homology/ShortComplex/ConcreteCategory.lean - 2024-09-08 23:34:38.582311.
---8/200---
For theorem CategoryTheory.ShortComplex.ShortExact.surjective_g in Mathlib/Algebra/Homology/ShortComplex/ConcreteCategory.lean:
lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forgetâ‚‚ C Ab).map S.g) 


Original valid proof:
:= by
  rw [â† Preadditive.epi_iff_surjective]
  exact hS.epi_g


Verifying proof (Commit 71880da883b383ac13b9beb76b1bd41a0f023582):
simp only [Function.Surjective, Function.Surjective]

Attempt failure.

Working on Mathlib/Algebra/Homology/ShortComplex/Preadditive.lean - 2024-09-08 23:34:59.763026.
---9/200---
For theorem CategoryTheory.ShortComplex.homologyMap_sub in Mathlib/Algebra/Homology/ShortComplex/Preadditive.lean:
lemma homologyMap_sub : homologyMap (Ï† - Ï†') = homologyMap Ï† - homologyMap Ï†' 


Original valid proof:
:=
  homologyMap'_sub _ _


Verifying proof (Commit 9072ff84a0d139a344bf9eed4a00c4cd27596c79):
rw [homologyMap_sub, homologyMap_sub]

Attempt failure.

Working on Mathlib/Algebra/Lie/InvariantForm.lean - 2024-09-08 23:35:15.476688.
---10/200---
For theorem LieAlgebra.InvariantForm.atomistic in Mathlib/Algebra/Lie/InvariantForm.lean:
lemma atomistic : âˆ€ I : LieIdeal K L, sSup {J : LieIdeal K L | IsAtom J âˆ§ J â‰¤ I} = I 


Original valid proof:
:= by
  intro I
  apply le_antisymm
  Â· apply sSup_le
    rintro J âŸ¨-, hJ'âŸ©
    exact hJ'
  by_cases hI : I = âŠ¥
  Â· exact hI.le.trans bot_le
  obtain âŸ¨J, hJ, hJIâŸ© := (eq_bot_or_exists_atom_le I).resolve_left hI
  let J' := orthogonal Î¦ hÎ¦_inv J
  suffices I â‰¤ J âŠ” (J' âŠ“ I) by
    refine this.trans ?_
    apply sup_le
    Â· exact le_sSup âŸ¨hJ, hJIâŸ©
    rw [â† atomistic (J' âŠ“ I)]
    apply sSup_le_sSup
    simp only [le_inf_iff, Set.setOf_subset_setOf, and_imp]
    tauto
  suffices J âŠ” J' = âŠ¤ by rw [â† sup_inf_assoc_of_le _ hJI, this, top_inf_eq]
  exact (orthogonal_isCompl Î¦ hÎ¦_nondeg hÎ¦_inv hÎ¦_refl hL J hJ).codisjoint.eq_top


Verifying proof (Commit 08bbfa2463d2acd9d80762f3f528516e41b2de13):
apply le_antisymm

Attempt failure.

Working on Mathlib/Algebra/Lie/Weights/Basic.lean - 2024-09-08 23:35:35.651314.
---11/200---
For theorem LieModule.disjoint_weightSpace in Mathlib/Algebra/Lie/Weights/Basic.lean:
lemma disjoint_weightSpaceOf [NoZeroSMulDivisors R M] {x : L} {Ï†â‚ Ï†â‚‚ : R} (h : Ï†â‚ â‰  Ï†â‚‚) :
    Disjoint (weightSpaceOf M Ï†â‚ x) (weightSpaceOf M Ï†â‚‚ x) 


Original valid proof:
:= by
  rw [LieSubmodule.disjoint_iff_coe_toSubmodule]
  exact Module.End.disjoint_iSup_genEigenspace _ h


Verifying proof (Commit 61e05975727e0b1a19d0075b994c53596adb3405):
rw [weightSpaceOf_disjoint_weightSpaceOf, disjoint_weightSpaceOf_disjoint_weightSpaceOf,
  disjoint_weightSpaceOf_disjoint_weightSpaceOf, disjoint_weightSpaceOf]

Attempt failure.

---12/200---
For theorem LieModule.isCompl_weightSpace_zero_posFittingComp in Mathlib/Algebra/Lie/Weights/Basic.lean:
lemma isCompl_weightSpace_zero_posFittingComp_aux
    (h : âˆ€ N < (âŠ¤ : LieSubmodule R L M), IsCompl (weightSpace N 0) (posFittingComp R L N)) :
    IsCompl (weightSpace M 0) (posFittingComp R L M) 


Original valid proof:
:= by
  set Mâ‚€ := weightSpace M (0 : L â†’ R)
  set Mâ‚ := posFittingComp R L M
  rcases forall_or_exists_not (fun (x : L) â†¦ weightSpaceOf M (0 : R) x = âŠ¤)
    with h | âŸ¨x, hx : weightSpaceOf M (0 : R) x â‰  âŠ¤âŸ©
  Â· suffices IsNilpotent R L M by simp [Mâ‚€, Mâ‚, isCompl_top_bot]
    replace h : Mâ‚€ = âŠ¤ := by simpa [Mâ‚€, weightSpace]
    rw [â† LieModule.isNilpotent_of_top_iff', â† h]
    infer_instance
  Â· set Mâ‚€â‚“ := weightSpaceOf M (0 : R) x
    set Mâ‚â‚“ := posFittingCompOf R M x
    set Mâ‚€â‚“â‚€ := weightSpace Mâ‚€â‚“ (0 : L â†’ R)
    set Mâ‚€â‚“â‚ := posFittingComp R L Mâ‚€â‚“
    have hâ‚ : IsCompl Mâ‚€â‚“ Mâ‚â‚“ := isCompl_weightSpaceOf_zero_posFittingCompOf R L M x
    have hâ‚‚ : IsCompl Mâ‚€â‚“â‚€ Mâ‚€â‚“â‚ := h Mâ‚€â‚“ hx.lt_top
    have hâ‚ƒ : Mâ‚€â‚“â‚€.map Mâ‚€â‚“.incl = Mâ‚€ := by
      rw [map_weightSpace_eq_of_injective Mâ‚€â‚“.injective_incl, inf_eq_left, LieSubmodule.range_incl]
      exact iInf_le _ x
    have hâ‚„ : Mâ‚€â‚“â‚.map Mâ‚€â‚“.incl âŠ” Mâ‚â‚“ = Mâ‚ := by
      apply le_antisymm <| sup_le_iff.mpr
        âŸ¨map_posFittingComp_le _, posFittingCompOf_le_posFittingComp R L M xâŸ©
      rw [â† posFittingComp_map_incl_sup_of_codisjoint hâ‚.codisjoint]
      exact sup_le_sup_left LieSubmodule.map_incl_le _
    rw [â† hâ‚ƒ, â† hâ‚„]
    apply Disjoint.isCompl_sup_right_of_isCompl_sup_left
    Â· rw [disjoint_iff, â† LieSubmodule.map_inf Mâ‚€â‚“.injective_incl, hâ‚‚.inf_eq_bot,
        LieSubmodule.map_bot]
    Â· rwa [â† LieSubmodule.map_sup, hâ‚‚.sup_eq_top, LieModuleHom.map_top, LieSubmodule.range_incl]


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
exact isCompl_weightSpace_zero_posFittingComp_aux isCompl_weightSpace_zero_posFittingComp_aux

Attempt failure.

---13/200---
For theorem LieModule.independent_weightSpace in Mathlib/Algebra/Lie/Weights/Basic.lean:
lemma independent_weightSpace [NoZeroSMulDivisors R M] :
    CompleteLattice.Independent fun (Ï‡ : L â†’ R) â†¦ weightSpace M Ï‡ 


Original valid proof:
:= by
  classical
  suffices âˆ€ Ï‡ (s : Finset (L â†’ R)) (_ : Ï‡ âˆ‰ s),
      Disjoint (weightSpace M Ï‡) (s.sup fun (Ï‡ : L â†’ R) â†¦ weightSpace M Ï‡) by
    simpa only [CompleteLattice.independent_iff_supIndep_of_injOn (injOn_weightSpace R L M),
      Finset.supIndep_iff_disjoint_erase] using fun s Ï‡ _ â†¦ this _ _ (s.not_mem_erase Ï‡)
  intro Ï‡â‚ s
  induction' s using Finset.induction_on with Ï‡â‚‚ s _ ih
  Â· simp
  intro hÏ‡â‚â‚‚
  obtain âŸ¨hÏ‡â‚â‚‚ : Ï‡â‚ â‰  Ï‡â‚‚, hÏ‡â‚ : Ï‡â‚ âˆ‰ sâŸ© := by rwa [Finset.mem_insert, not_or] at hÏ‡â‚â‚‚
  specialize ih hÏ‡â‚
  rw [Finset.sup_insert, disjoint_iff, LieSubmodule.eq_bot_iff]
  rintro x âŸ¨hx, hx'âŸ©
  simp only [SetLike.mem_coe, LieSubmodule.mem_coeSubmodule] at hx hx'
  suffices x âˆˆ weightSpace M Ï‡â‚‚ by
    rw [â† LieSubmodule.mem_bot (R := R) (L := L), â† (disjoint_weightSpace R L M hÏ‡â‚â‚‚).eq_bot]
    exact âŸ¨hx, thisâŸ©
  obtain âŸ¨y, hy, z, hz, rflâŸ© := (LieSubmodule.mem_sup _ _ _).mp hx'; clear hx'
  suffices âˆ€ l, âˆƒ (k : â„•),
      ((toEnd R L M l - algebraMap R (Module.End R M) (Ï‡â‚‚ l)) ^ k) (y + z) âˆˆ
      weightSpace M Ï‡â‚ âŠ“ Finset.sup s fun Ï‡ â†¦ weightSpace M Ï‡ by
    simpa only [ih.eq_bot, LieSubmodule.mem_bot, mem_weightSpace] using this
  intro l
  let g : Module.End R M := toEnd R L M l - algebraMap R (Module.End R M) (Ï‡â‚‚ l)
  obtain âŸ¨k, hk : (g ^ k) y = 0âŸ© := (mem_weightSpace _ _ _).mp hy l
  refine âŸ¨k, (LieSubmodule.mem_inf _ _ _).mp âŸ¨?_, ?_âŸ©âŸ©
  Â· exact LieSubmodule.mapsTo_pow_toEnd_sub_algebraMap _ hx
  Â· rw [map_add, hk, zero_add]
    suffices (s.sup fun Ï‡ â†¦ weightSpace M Ï‡ : Submodule R M).map (g ^ k) â‰¤
        s.sup fun Ï‡ â†¦ weightSpace M Ï‡ by
      refine this (Submodule.mem_map_of_mem ?_)
      simp_rw [â† LieSubmodule.mem_coeSubmodule, Finset.sup_eq_iSup,
        LieSubmodule.iSup_coe_toSubmodule, â† Finset.sup_eq_iSup] at hz
      exact hz
    simp_rw [Finset.sup_eq_iSup, Submodule.map_iSup (Î¹ := L â†’ R), Submodule.map_iSup (Î¹ := _ âˆˆ s),
      LieSubmodule.iSup_coe_toSubmodule]
    refine iSupâ‚‚_mono fun Ï‡ _ â†¦ ?_
    rintro - âŸ¨u, hu, rflâŸ©
    exact LieSubmodule.mapsTo_pow_toEnd_sub_algebraMap _ hu


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
rw [NoZeroSMulDivisors.weightSpace, NoZeroSMulDivisors.weightSpace]

Attempt failure.

Working on Mathlib/Algebra/Module/PID.lean - 2024-09-08 23:36:36.585045.
---14/200---
For theorem Module.torsion_by_prime_power_decomposition in Mathlib/Algebra/Module/PID.lean:
theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    âˆƒ (d : â„•) (k : Fin d â†’ â„•), Nonempty <| N â‰ƒâ‚—[R] â¨ i : Fin d, R â§¸ R âˆ™ p ^ (k i : â„•) 


Original valid proof:
:= by
  obtain âŸ¨d, s, hsâŸ© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  Â· 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      âŸ¨âŸ¨0âŸ©, fun x => by dsimp; rw [â† Submodule.mem_bot R, hs]; exact Submodule.mem_topâŸ©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact âŸ¨0âŸ©
  Â· have : âˆ€ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain âŸ¨j, hjâŸ© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d â†’ N â§¸ R âˆ™ s j := Submodule.Quotient.mk âˆ˜ s âˆ˜ j.succAbove
    have := IH ?_ s' ?_
    Â· obtain âŸ¨k, âŸ¨fâŸ©âŸ© := this
      clear IH
      have : âˆ€ i : Fin d,
          âˆƒ x : N, p ^ k i â€¢ x = 0 âˆ§ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain âŸ¨x, h0, h1âŸ© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine âŸ¨x, h0, ?_âŸ©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine âŸ¨?_, âŸ¨?_âŸ©âŸ©
      Â· exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : â„•)) (finSuccEquiv d a)
      Â· refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R â§¸ _ â†’â‚—[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R âˆ™ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R â§¸ R âˆ™ p ^ @Option.rec _ (fun _ => â„•) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        Â· rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        Â· rw [â† f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, â† LinearMap.comp_assoc,
            â† LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R âˆ™ s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    Â· exact (mk_surjective _).forall.mpr fun x =>
        âŸ¨(@hN x).choose, by rw [â† Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]âŸ©
    Â· have hs' := congr_arg (Submodule.map <| mkQ <| R âˆ™ s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [â† Function.comp.assoc, Set.range_comp (_ âˆ˜ s), Fin.range_succAbove]
      rw [â† Set.range_comp, â† Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'


Verifying proof (Commit 149993021318d2b426f3d41570396b90e12fcb46):
refine âŸ¨torsion_by_prime_power_decomposition hN h', ?_âŸ©

Attempt failure.

Working on Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean - 2024-09-08 23:36:56.557777.
---15/200---
For theorem WeierstrassCurve.Jacobian.equiv_some_of_Z_ne_zero in Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean:
lemma equiv_some_of_Z_ne_zero {P : Fin 3 â†’ F} (hPz : P z â‰  0) :
    P â‰ˆ ![P x / P z ^ 2, P y / P z ^ 3, 1] 


Original valid proof:
:=
  equiv_of_X_eq_of_Y_eq hPz one_ne_zero
    (by linear_combination (norm := (matrix_simp; ring1)) -P x * div_self (pow_ne_zero 2 hPz))
    (by linear_combination (norm := (matrix_simp; ring1)) -P y * div_self (pow_ne_zero 3 hPz))


Verifying proof (Commit b999f5fc5a622c176ec2ff740c2226c15d01d750):
simp only [equiv_some_of_Z_ne_zero]

Attempt failure.

Working on Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean - 2024-09-08 23:37:17.049578.
---16/200---
For theorem AlgebraicGeometry.Î“Spec.adjunction_homEquiv_apply in Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean:
theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatáµ’áµ–}
    (f : (op <| Scheme.Î“.obj <| op X) âŸ¶ R) :
    Î“Spec.adjunction.homEquiv X R f = locallyRingedSpaceAdjunction.homEquiv X.1 R f 


Original valid proof:
:= rfl


Verifying proof (Commit 43339007ce3d59409eaf23093d4981175984328f):
dsimp [locallyRingedSpaceAdjunction]

Attempt failure.

Working on Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean - 2024-09-08 23:37:37.685543.
---17/200---
For theorem AlgebraicTopology.AlternatingCofaceMapComplex.d_squared in Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean:
theorem d_squared (n : â„•) : objD X (n + 1) â‰« objD X n = 0 


Original valid proof:
:= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,
      Fin.val_succ, Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij âŸ¨i', j'âŸ© hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine âŸ¨(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'
    Â· simp only [Ï†, Fin.castLT_castSucc, Fin.succ_pred]
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa [S] using hij


Verifying proof (Commit 084cfb354233793728fd0ef1054e9b156224e7f6):
simp only [objD, objDD, objDDD, d_squared, d_squared, d_squared, d_squared]

Attempt failure.

Working on Mathlib/Analysis/Analytic/Composition.lean - 2024-09-08 23:37:56.689019.
---18/200---
For theorem HasFPowerSeriesAt.comp in Mathlib/Analysis/Analytic/Composition.lean:
theorem HasFPowerSeriesAt.comp {g : F â†’ G} {f : E â†’ F} {q : FormalMultilinearSeries ğ•œ F G}
    {p : FormalMultilinearSeries ğ•œ E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) : HasFPowerSeriesAt (g âˆ˜ f) (q.comp p) x 


Original valid proof:
:= by
  rcases hg with âŸ¨rg, HgâŸ©
  rcases hf with âŸ¨rf, HfâŸ©
  rcases q.comp_summable_nnreal p Hg.radius_pos Hf.radius_pos with âŸ¨r, r_pos : 0 < r, hrâŸ©
  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© :
    âˆƒ Î´ : â„â‰¥0âˆ, 0 < Î´ âˆ§ âˆ€ {z : E}, z âˆˆ EMetric.ball x Î´ â†’ f z âˆˆ EMetric.ball (f x) rg := by
    have : EMetric.ball (f x) rg âˆˆ ğ“ (f x) := EMetric.ball_mem_nhds _ Hg.r_pos
    rcases EMetric.mem_nhds_iff.1 (Hf.analyticAt.continuousAt this) with âŸ¨Î´, Î´pos, HÎ´âŸ©
    exact âŸ¨Î´, Î´pos, fun hz => HÎ´ hzâŸ©
  let rf' := min rf Î´
  have min_pos : 0 < min rf' r := by
    simp only [rf', r_pos, Hf.r_pos, Î´pos, lt_min_iff, ENNReal.coe_pos, and_self_iff]
  refine âŸ¨min rf' r, ?_âŸ©
  refine
    âŸ¨le_trans (min_le_right rf' r) (FormalMultilinearSeries.le_comp_radius_of_summable q p r hr),
      min_pos, @fun y hy => ?_âŸ©
  have y_mem : y âˆˆ EMetric.ball (0 : E) rf :=
    (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_left _ _))) hy
  have fy_mem : f (x + y) âˆˆ EMetric.ball (f x) rg := by
    apply hÎ´
    have : y âˆˆ EMetric.ball (0 : E) Î´ :=
      (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_right _ _))) hy
    simpa [edist_eq_coe_nnnorm_sub, edist_eq_coe_nnnorm]
  have A : Tendsto (fun n => âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y)
      atTop (ğ“ (f (x + y) - f x)) := by
    have L :
      âˆ€á¶  n in atTop, (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x
        = âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y := by
      rw [eventually_atTop]
      refine âŸ¨1, fun n hn => ?_âŸ©
      symm
      rw [eq_sub_iff_add_eq', Finset.range_eq_Ico, â† Hf.coeff_zero fun _i => y,
        Finset.sum_eq_sum_Ico_succ_bot hn]
    have :
      Tendsto (fun n => (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x) atTop
        (ğ“ (f (x + y) - f x)) :=
      (Hf.hasSum y_mem).tendsto_sum_nat.sub tendsto_const_nhds
    exact Tendsto.congr' L this
  have B :
    Tendsto (fun n => q.partialSum n (âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y)) atTop
      (ğ“ (g (f (x + y)))) := by
    have Bâ‚ : ContinuousAt (fun z : F => g (f x + z)) (f (x + y) - f x) := by
      refine ContinuousAt.comp ?_ (continuous_const.add continuous_id).continuousAt
      simp only [add_sub_cancel, _root_.id]
      exact Hg.continuousOn.continuousAt (IsOpen.mem_nhds EMetric.isOpen_ball fy_mem)
    have Bâ‚‚ : f (x + y) - f x âˆˆ EMetric.ball (0 : F) rg := by
      simpa [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub] using fy_mem
    rw [â† EMetric.isOpen_ball.nhdsWithin_eq Bâ‚‚] at A
    convert Hg.tendstoLocallyUniformlyOn.tendsto_comp Bâ‚.continuousWithinAt Bâ‚‚ A
    simp only [add_sub_cancel]
  have C :
    Tendsto
      (fun n => âˆ‘ i âˆˆ compPartialSumTarget 0 n n, q.compAlongComposition p i.2 fun _j => y)
      atTop (ğ“ (g (f (x + y)))) := by
    simpa [comp_partialSum] using B
  have D :
    HasSum (fun i : Î£ n, Composition n => q.compAlongComposition p i.2 fun _j => y)
      (g (f (x + y))) :=
    haveI cau :
      CauchySeq fun s : Finset (Î£ n, Composition n) =>
        âˆ‘ i âˆˆ s, q.compAlongComposition p i.2 fun _j => y := by
      apply cauchySeq_finset_of_norm_bounded _ (NNReal.summable_coe.2 hr) _
      simp only [coe_nnnorm, NNReal.coe_mul, NNReal.coe_pow]
      rintro âŸ¨n, câŸ©
      calc
        â€–(compAlongComposition q p c) fun _j : Fin n => yâ€– â‰¤
            â€–compAlongComposition q p câ€– * âˆ _j : Fin n, â€–yâ€– := by
          apply ContinuousMultilinearMap.le_opNorm
        _ â‰¤ â€–compAlongComposition q p câ€– * (r : â„) ^ n := by
          apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
          rw [Finset.prod_const, Finset.card_fin]
          apply pow_le_pow_left (norm_nonneg _)
          rw [EMetric.mem_ball, edist_eq_coe_nnnorm] at hy
          have := le_trans (le_of_lt hy) (min_le_right _ _)
          rwa [ENNReal.coe_le_coe, â† NNReal.coe_le_coe, coe_nnnorm] at this
    tendsto_nhds_of_cauchySeq_of_subseq cau compPartialSumTarget_tendsto_atTop C
  have E : HasSum (fun n => (q.comp p) n fun _j => y) (g (f (x + y))) := by
    apply D.sigma
    intro n
    dsimp [FormalMultilinearSeries.comp]
    convert hasSum_fintype (Î± := G) (Î² := Composition n) _
    simp only [ContinuousMultilinearMap.sum_apply]
    rfl
  rw [Function.comp_apply]
  exact E


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
rw [â† hasFPowerSeriesAt_iff_hasFPowerSeriesAt, â† hasFPowerSeriesAt_iff_hasFPowerSeries]

Attempt failure.

---19/200---
For theorem FormalMultilinearSeries.comp_summable_nnreal in Mathlib/Analysis/Analytic/Composition.lean:
theorem comp_summable_nnreal (q : FormalMultilinearSeries ğ•œ F G) (p : FormalMultilinearSeries ğ•œ E F)
    (hq : 0 < q.radius) (hp : 0 < p.radius) :
    âˆƒ r > (0 : â„â‰¥0),
      Summable fun i : Î£ n, Composition n => â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 


Original valid proof:
:= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hp) with âŸ¨rp, rp_pos, hrpâŸ©
  simp only [lt_min_iff, ENNReal.coe_lt_one_iff, ENNReal.coe_pos] at hrp hrq rp_pos rq_pos
  obtain âŸ¨Cq, _hCq0, hCqâŸ© : âˆƒ Cq > 0, âˆ€ n, â€–q nâ€–â‚Š * rq ^ n â‰¤ Cq :=
    q.nnnorm_mul_pow_le_of_lt_radius hrq.2
  obtain âŸ¨Cp, hCp1, hCpâŸ© : âˆƒ Cp â‰¥ 1, âˆ€ n, â€–p nâ€–â‚Š * rp ^ n â‰¤ Cp := by
    rcases p.nnnorm_mul_pow_le_of_lt_radius hrp.2 with âŸ¨Cp, -, hCpâŸ©
    exact âŸ¨max Cp 1, le_max_right _ _, fun n => (hCp n).trans (le_max_left _ _)âŸ©
  let r0 : â„â‰¥0 := (4 * Cp)â»Â¹
  have r0_pos : 0 < r0 := inv_pos.2 (mul_pos zero_lt_four (zero_lt_one.trans_le hCp1))
  set r : â„â‰¥0 := rp * rq * r0
  have r_pos : 0 < r := mul_pos (mul_pos rp_pos rq_pos) r0_pos
  have I :
    âˆ€ i : Î£ n : â„•, Composition n, â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 â‰¤ Cq / 4 ^ i.1 := by
    rintro âŸ¨n, câŸ©
    have A := calc
      â€–q c.lengthâ€–â‚Š * rq ^ n â‰¤ â€–q c.lengthâ€–â‚Š * rq ^ c.length :=
        mul_le_mul' le_rfl (pow_le_pow_of_le_one rq.2 hrq.1.le c.length_le)
      _ â‰¤ Cq := hCq _
    have B := calc
      (âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n = âˆ i, â€–p (c.blocksFun i)â€–â‚Š * rp ^ c.blocksFun i := by
        simp only [Finset.prod_mul_distrib, Finset.prod_pow_eq_pow_sum, c.sum_blocksFun]
      _ â‰¤ âˆ _i : Fin c.length, Cp := Finset.prod_le_prod' fun i _ => hCp _
      _ = Cp ^ c.length := by simp
      _ â‰¤ Cp ^ n := pow_le_pow_right hCp1 c.length_le
    calc
      â€–q.compAlongComposition p câ€–â‚Š * r ^ n â‰¤
          (â€–q c.lengthâ€–â‚Š * âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * r ^ n :=
        mul_le_mul' (q.compAlongComposition_nnnorm p c) le_rfl
      _ = â€–q c.lengthâ€–â‚Š * rq ^ n * ((âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n) * r0 ^ n := by
        ring
      _ â‰¤ Cq * Cp ^ n * r0 ^ n := mul_le_mul' (mul_le_mul' A B) le_rfl
      _ = Cq / 4 ^ n := by
        simp only [r0]
        field_simp [mul_pow, (zero_lt_one.trans_le hCp1).ne']
        ring
  refine âŸ¨r, r_pos, NNReal.summable_of_le I ?_âŸ©
  simp_rw [div_eq_mul_inv]
  refine Summable.mul_left _ ?_
  have : âˆ€ n : â„•, HasSum (fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹) (2 ^ (n - 1) / 4 ^ n) := by
    intro n
    convert hasSum_fintype fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹
    simp [Finset.card_univ, composition_card, div_eq_mul_inv]
  refine NNReal.summable_sigma.2 âŸ¨fun n => (this n).summable, (NNReal.summable_nat_add_iff 1).1 ?_âŸ©
  convert (NNReal.summable_geometric (NNReal.div_lt_one_of_lt one_lt_two)).mul_left (1 / 4) using 1
  ext1 n
  rw [(this _).tsum_eq, add_tsub_cancel_right]
  field_simp [â† mul_assoc, pow_succ, mul_pow, show (4 : â„â‰¥0) = 2 * 2 by norm_num,
    mul_right_comm]


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
rcases ENNReal.exists_pos_summable_nnreal_of_summable_nnreal hq p.radius with âŸ¨rq, rq_pos, hrqâŸ©

Attempt failure.

---20/200---
For theorem HasFPowerSeriesAt.comp in Mathlib/Analysis/Analytic/Composition.lean:
theorem HasFPowerSeriesAt.comp {g : F â†’ G} {f : E â†’ F} {q : FormalMultilinearSeries ğ•œ F G}
    {p : FormalMultilinearSeries ğ•œ E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) : HasFPowerSeriesAt (g âˆ˜ f) (q.comp p) x 


Original valid proof:
:= by
  rcases hg with âŸ¨rg, HgâŸ©
  rcases hf with âŸ¨rf, HfâŸ©
  rcases q.comp_summable_nnreal p Hg.radius_pos Hf.radius_pos with âŸ¨r, r_pos : 0 < r, hrâŸ©
  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© :
    âˆƒ Î´ : â„â‰¥0âˆ, 0 < Î´ âˆ§ âˆ€ {z : E}, z âˆˆ EMetric.ball x Î´ â†’ f z âˆˆ EMetric.ball (f x) rg := by
    have : EMetric.ball (f x) rg âˆˆ ğ“ (f x) := EMetric.ball_mem_nhds _ Hg.r_pos
    rcases EMetric.mem_nhds_iff.1 (Hf.analyticAt.continuousAt this) with âŸ¨Î´, Î´pos, HÎ´âŸ©
    exact âŸ¨Î´, Î´pos, fun hz => HÎ´ hzâŸ©
  let rf' := min rf Î´
  have min_pos : 0 < min rf' r := by
    simp only [rf', r_pos, Hf.r_pos, Î´pos, lt_min_iff, ENNReal.coe_pos, and_self_iff]
  refine âŸ¨min rf' r, ?_âŸ©
  refine
    âŸ¨le_trans (min_le_right rf' r) (FormalMultilinearSeries.le_comp_radius_of_summable q p r hr),
      min_pos, @fun y hy => ?_âŸ©
  have y_mem : y âˆˆ EMetric.ball (0 : E) rf :=
    (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_left _ _))) hy
  have fy_mem : f (x + y) âˆˆ EMetric.ball (f x) rg := by
    apply hÎ´
    have : y âˆˆ EMetric.ball (0 : E) Î´ :=
      (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_right _ _))) hy
    simpa [edist_eq_coe_nnnorm_sub, edist_eq_coe_nnnorm]
  have A : Tendsto (fun n => âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y)
      atTop (ğ“ (f (x + y) - f x)) := by
    have L :
      âˆ€á¶  n in atTop, (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x
        = âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y := by
      rw [eventually_atTop]
      refine âŸ¨1, fun n hn => ?_âŸ©
      symm
      rw [eq_sub_iff_add_eq', Finset.range_eq_Ico, â† Hf.coeff_zero fun _i => y,
        Finset.sum_eq_sum_Ico_succ_bot hn]
    have :
      Tendsto (fun n => (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x) atTop
        (ğ“ (f (x + y) - f x)) :=
      (Hf.hasSum y_mem).tendsto_sum_nat.sub tendsto_const_nhds
    exact Tendsto.congr' L this
  have B :
    Tendsto (fun n => q.partialSum n (âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y)) atTop
      (ğ“ (g (f (x + y)))) := by
    have Bâ‚ : ContinuousAt (fun z : F => g (f x + z)) (f (x + y) - f x) := by
      refine ContinuousAt.comp ?_ (continuous_const.add continuous_id).continuousAt
      simp only [add_sub_cancel, _root_.id]
      exact Hg.continuousOn.continuousAt (IsOpen.mem_nhds EMetric.isOpen_ball fy_mem)
    have Bâ‚‚ : f (x + y) - f x âˆˆ EMetric.ball (0 : F) rg := by
      simpa [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub] using fy_mem
    rw [â† EMetric.isOpen_ball.nhdsWithin_eq Bâ‚‚] at A
    convert Hg.tendstoLocallyUniformlyOn.tendsto_comp Bâ‚.continuousWithinAt Bâ‚‚ A
    simp only [add_sub_cancel]
  have C :
    Tendsto
      (fun n => âˆ‘ i âˆˆ compPartialSumTarget 0 n n, q.compAlongComposition p i.2 fun _j => y)
      atTop (ğ“ (g (f (x + y)))) := by
    simpa [comp_partialSum] using B
  have D :
    HasSum (fun i : Î£ n, Composition n => q.compAlongComposition p i.2 fun _j => y)
      (g (f (x + y))) :=
    haveI cau :
      CauchySeq fun s : Finset (Î£ n, Composition n) =>
        âˆ‘ i âˆˆ s, q.compAlongComposition p i.2 fun _j => y := by
      apply cauchySeq_finset_of_norm_bounded _ (NNReal.summable_coe.2 hr) _
      simp only [coe_nnnorm, NNReal.coe_mul, NNReal.coe_pow]
      rintro âŸ¨n, câŸ©
      calc
        â€–(compAlongComposition q p c) fun _j : Fin n => yâ€– â‰¤
            â€–compAlongComposition q p câ€– * âˆ _j : Fin n, â€–yâ€– := by
          apply ContinuousMultilinearMap.le_opNorm
        _ â‰¤ â€–compAlongComposition q p câ€– * (r : â„) ^ n := by
          apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
          rw [Finset.prod_const, Finset.card_fin]
          apply pow_le_pow_left (norm_nonneg _)
          rw [EMetric.mem_ball, edist_eq_coe_nnnorm] at hy
          have := le_trans (le_of_lt hy) (min_le_right _ _)
          rwa [ENNReal.coe_le_coe, â† NNReal.coe_le_coe, coe_nnnorm] at this
    tendsto_nhds_of_cauchySeq_of_subseq cau compPartialSumTarget_tendsto_atTop C
  have E : HasSum (fun n => (q.comp p) n fun _j => y) (g (f (x + y))) := by
    apply D.sigma
    intro n
    dsimp [FormalMultilinearSeries.comp]
    convert hasSum_fintype (Î± := G) (Î² := Composition n) _
    simp only [ContinuousMultilinearMap.sum_apply]
    rfl
  rw [Function.comp_apply]
  exact E


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
rw [â† hasFPowerSeriesAt_iff_hasFPowerSeriesAt, â† hasFPowerSeriesAt_iff_hasFPowerSeries]

Attempt failure.

Working on Mathlib/Analysis/Analytic/Meromorphic.lean - 2024-09-08 23:38:58.703343.
---21/200---
For theorem MeromorphicAt.order_eq_int_iff in Mathlib/Analysis/Analytic/Meromorphic.lean:
lemma order_eq_int_iff {f : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) (n : â„¤) : hf.order = n â†”
    âˆƒ g : ğ•œ â†’ E, AnalyticAt ğ•œ g x âˆ§ g x â‰  0 âˆ§ âˆ€á¶  z in ğ“[â‰ ] x, f z = (z - x) ^ n â€¢ g z 


Original valid proof:
:= by
  unfold order
  by_cases h : hf.choose_spec.order = âŠ¤
  Â· rw [h, WithTop.map_top, â† WithTop.coe_natCast, top_sub,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun âŸ¨g, hg_an, hg_ne, hg_eqâŸ© â†¦ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, â† AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq âŠ¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, â† mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  Â· obtain âŸ¨m, hâŸ© := WithTop.ne_top_iff_exists.mp h
    rw [â† h, WithTop.map_coe, â† WithTop.coe_natCast, â† coe_sub, WithTop.coe_inj]
    obtain âŸ¨g, hg_an, hg_ne, hg_eqâŸ© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : âˆ€á¶  (z : ğ•œ) in ğ“[â‰ ] x, f z = (z - x) ^ (â†‘m - â†‘hf.choose : â„¤) â€¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [â† smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), â† mul_smul,
        â† zpow_addâ‚€ (sub_ne_zero.mpr hz), â† add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact âŸ¨fun h â†¦ âŸ¨g, hg_an, hg_ne, h â–¸ hg_eqâŸ©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero âŸ¨g, hg_an, hg_ne, hg_eqâŸ©âŸ©


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
constructor

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Box/SubboxInduction.lean - 2024-09-08 23:39:19.487994.
---22/200---
For theorem BoxIntegral.Box.subbox_induction_on' in Mathlib/Analysis/BoxIntegral/Box/SubboxInduction.lean:
theorem subbox_induction_on' {p : Box Î¹ â†’ Prop} (I : Box Î¹)
    (H_ind : âˆ€ J â‰¤ I, (âˆ€ s, p (splitCenterBox J s)) â†’ p J)
    (H_nhds : âˆ€ z âˆˆ Box.Icc I, âˆƒ U âˆˆ ğ“[Box.Icc I] z, âˆ€ J â‰¤ I, âˆ€ (m : â„•), z âˆˆ Box.Icc J â†’
      Box.Icc J âŠ† U â†’ (âˆ€ i, J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J) :
    p I 


Original valid proof:
:= by
  by_contra hpI
  replace H_ind := fun J hJ â†¦ not_imp_not.2 (H_ind J hJ)
  simp only [exists_imp, not_forall] at H_ind
  choose! s hs using H_ind
  set J : â„• â†’ Box Î¹ := fun m â†¦ (fun J â†¦ splitCenterBox J (s J))^[m] I
  have J_succ : âˆ€ m, J (m + 1) = splitCenterBox (J m) (s <| J m) :=
    fun m â†¦ iterate_succ_apply' _ _ _
  have hJmono : Antitone J :=
    antitone_nat_of_succ_le fun n â†¦ by simpa [J_succ] using splitCenterBox_le _ _
  have hJle : âˆ€ m, J m â‰¤ I := fun m â†¦ hJmono (zero_le m)
  have hJp : âˆ€ m, Â¬p (J m) :=
    fun m â†¦ Nat.recOn m hpI fun m â†¦ by simpa only [J_succ] using hs (J m) (hJle m)
  have hJsub : âˆ€ m i, (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m := by
    intro m i
    induction' m with m ihm
    Â· simp [J, Nat.zero_eq]
    simp only [pow_succ, J_succ, upper_sub_lower_splitCenterBox, ihm, div_div]
  have h0 : J 0 = I := rfl
  clear_value J
  clear hpI hs J_succ s
  set z : Î¹ â†’ â„ := â¨† m, (J m).lower
  have hzJ : âˆ€ m, z âˆˆ Box.Icc (J m) :=
    mem_iInter.1 (ciSup_mem_iInter_Icc_of_antitone_Icc
      ((@Box.Icc Î¹).monotone.comp_antitone hJmono) fun m â†¦ (J m).lower_le_upper)
  have hJl_mem : âˆ€ m, (J m).lower âˆˆ Box.Icc I := fun m â†¦ le_iff_Icc.1 (hJle m) (J m).lower_mem_Icc
  have hJu_mem : âˆ€ m, (J m).upper âˆˆ Box.Icc I := fun m â†¦ le_iff_Icc.1 (hJle m) (J m).upper_mem_Icc
  have hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“ z) :=
    tendsto_atTop_ciSup (antitone_lower.comp hJmono) âŸ¨I.upper, fun x âŸ¨m, hmâŸ© â†¦ hm â–¸ (hJl_mem m).2âŸ©
  have hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“ z) := by
    suffices Tendsto (fun m â†¦ (J m).upper - (J m).lower) atTop (ğ“ 0) by simpa using hJlz.add this
    refine tendsto_pi_nhds.2 fun i â†¦ ?_
    simpa [hJsub] using
      tendsto_const_nhds.div_atTop (tendsto_pow_atTop_atTop_of_one_lt _root_.one_lt_two)
  replace hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“[Icc I.lower I.upper] z) :=
    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJlz (eventually_of_forall hJl_mem)
  replace hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“[Icc I.lower I.upper] z) :=
    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJuz (eventually_of_forall hJu_mem)
  rcases H_nhds z (h0 â–¸ hzJ 0) with âŸ¨U, hUz, hUâŸ©
  rcases (tendsto_lift'.1 (hJlz.Icc hJuz) U hUz).exists with âŸ¨m, hUmâŸ©
  exact hJp m (hU (J m) (hJle m) m (hzJ m) hUm (hJsub m))


Verifying proof (Commit 24004588aea73bdc55b8a915a39abc4e4281277b):
refine theorem_theorem_Icc p I H_nhds H_ind H_nhds H_nhds H_ind H_nhds H_nhds H_ind H_nhds H_nhds

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean - 2024-09-08 23:39:39.654097.
---23/200---
For theorem BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le in Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean:
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) â†’ â„) â†’ E}
    {f' : (Fin (n + 1) â†’ â„) â†’L[â„] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) â†’ â„}
    (hxI : x âˆˆ (Box.Icc I)) {a : E} {Îµ : â„} (h0 : 0 < Îµ)
    (hÎµ : âˆ€ y âˆˆ (Box.Icc I), â€–f y - a - f' (y - x)â€– â‰¤ Îµ * â€–y - xâ€–) {c : â„â‰¥0}
    (hc : I.distortion â‰¤ c) :
    â€–(âˆ j, (I.upper j - I.lower j)) â€¢ f' (Pi.single i 1) -
      (integral (I.face i) âŠ¥ (f âˆ˜ i.insertNth (Î± := fun _ â†¦ â„) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) âŠ¥ (f âˆ˜ i.insertNth (Î± := fun _ â†¦ â„) (I.lower i))
          BoxAdditiveMap.volume)â€– â‰¤
      2 * Îµ * c * âˆ j, (I.upper j - I.lower j) 


Original valid proof:
:= by
  set e : â„ â†’ (Fin n â†’ â„) â†’ (Fin (n + 1) â†’ â„) := i.insertNth (Î± := fun _ â†¦ â„)
  have Hl : I.lower i âˆˆ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i âˆˆ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : âˆ€ x âˆˆ Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) âŠ¥ (f âˆ˜ e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : âˆ€ y âˆˆ Box.Icc (I.face i),
      â€–f' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))â€– â‰¤
        2 * Îµ * diam (Box.Icc I) := fun y hy â†¦ by
    set g := fun y => f y - a - f' (y - x) with hg
    change âˆ€ y âˆˆ (Box.Icc I), â€–g yâ€– â‰¤ Îµ * â€–y - xâ€– at hÎµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to â€–g (e (I.lower i) y) - g (e (I.upper i) y)â€– â‰¤ _
    Â· congr 1
      have := Fin.insertNth_sub_same (Î± := fun _ â†¦ â„) i (I.upper i) (I.lower i) y
      simp only [â† this, f'.map_sub]; abel
    Â· have : âˆ€ z âˆˆ Icc (I.lower i) (I.upper i), e z y âˆˆ (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hÎµ : âˆ€ y âˆˆ (Box.Icc I), â€–g yâ€– â‰¤ Îµ * diam (Box.Icc I) := by
        intro y hy
        refine (hÎµ y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [â† dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hÎµ _ (this _ Hl)) (hÎµ _ (this _ Hu))
  calc
    â€–(âˆ j, (I.upper j - I.lower j)) â€¢ f' (Pi.single i 1) -
            (integral (I.face i) âŠ¥ (f âˆ˜ e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) âŠ¥ (f âˆ˜ e (I.lower i)) BoxAdditiveMap.volume)â€– =
        â€–integral.{0, u, u} (I.face i) âŠ¥
            (fun x : Fin n â†’ â„ =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volumeâ€– := by
      rw [â† integral_sub (Hi _ Hu) (Hi _ Hl), â† Box.volume_face_mul i, mul_smul, â† Box.volume_apply,
        â† BoxAdditiveMap.toSMul_apply, â† integral_const, â† BoxAdditiveMap.volume,
        â† integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(Â· âˆ˜ Â·), Pi.sub_def, â† f'.map_smul, â† Pi.single_smul', smul_eq_mul, mul_one]
    _ â‰¤ (volume (I.face i : Set (Fin n â†’ â„))).toReal * (2 * Îµ * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * Îµ)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * Îµ * c * âˆ j, (I.upper j - I.lower j) := by
      rw [â† Measure.toBoxAdditive_apply, Box.volume_apply, â† I.volume_face_mul i]
      ac_rfl


Verifying proof (Commit 5314a658f207fdcef03c22ffaf7bc64414488ae1):
refine theorem_theorem_Icc _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  (fun y hy => ?_) (fun y hy => ?_) _ _

Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Partition/Split.lean - 2024-09-08 23:39:59.848562.
---24/200---
For theorem BoxIntegral.Prepartition.inf_splitMany in Mathlib/Analysis/BoxIntegral/Partition/Split.lean:
theorem inf_splitMany {I : Box Î¹} (Ï€ : Prepartition I) (s : Finset (Î¹ Ã— â„)) :
    Ï€ âŠ“ splitMany I s = Ï€.biUnion fun J => splitMany J s 


Original valid proof:
:= by
  induction' s using Finset.induction_on with p s _ ihp
  Â· simp
  Â· simp_rw [splitMany_insert, â† inf_assoc, ihp, inf_split, biUnion_assoc]


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
simp only [inf_splitMany, splitMany]

Attempt failure.

Working on Mathlib/Analysis/Calculus/ContDiff/Bounds.lean - 2024-09-08 23:40:33.849782.
---25/200---
For theorem norm_iteratedFDerivWithin_comp_le_aux in Mathlib/Analysis/Calculus/ContDiff/Bounds.lean:
theorem norm_iteratedFDerivWithin_comp_le_aux {Fu Gu : Type u} [NormedAddCommGroup Fu]
    [NormedSpace ğ•œ Fu] [NormedAddCommGroup Gu] [NormedSpace ğ•œ Gu] {g : Fu â†’ Gu} {f : E â†’ Fu} {n : â„•}
    {s : Set E} {t : Set Fu} {x : E} (hg : ContDiffOn ğ•œ n g t) (hf : ContDiffOn ğ•œ n f s)
    (ht : UniqueDiffOn ğ•œ t) (hs : UniqueDiffOn ğ•œ s) (hst : MapsTo f s t) (hx : x âˆˆ s) {C : â„}
    {D : â„} (hC : âˆ€ i, i â‰¤ n â†’ â€–iteratedFDerivWithin ğ•œ i g t (f x)â€– â‰¤ C)
    (hD : âˆ€ i, 1 â‰¤ i â†’ i â‰¤ n â†’ â€–iteratedFDerivWithin ğ•œ i f s xâ€– â‰¤ D ^ i) :
    â€–iteratedFDerivWithin ğ•œ n (g âˆ˜ f) s xâ€– â‰¤ n ! * C * D ^ n 


Original valid proof:
:= by
  induction' n using Nat.case_strong_induction_on with n IH generalizing Gu
  Â· simpa [norm_iteratedFDerivWithin_zero, Nat.factorial_zero, algebraMap.coe_one, one_mul,
      pow_zero, mul_one, comp_apply] using hC 0 le_rfl
  have M : (n : â„•âˆ) < n.succ := Nat.cast_lt.2 n.lt_succ_self
  have Cnonneg : 0 â‰¤ C := (norm_nonneg _).trans (hC 0 bot_le)
  have Dnonneg : 0 â‰¤ D := by
    have : 1 â‰¤ n + 1 := by simp only [le_add_iff_nonneg_left, zero_le']
    simpa only [pow_one] using (norm_nonneg _).trans (hD 1 le_rfl this)
  have I : âˆ€ i âˆˆ Finset.range (n + 1),
      â€–iteratedFDerivWithin ğ•œ i (fderivWithin ğ•œ g t âˆ˜ f) s xâ€– â‰¤ i ! * C * D ^ i := by
    intro i hi
    simp only [Finset.mem_range_succ_iff] at hi
    apply IH i hi
    Â· apply hg.fderivWithin ht
      simp only [Nat.cast_succ]
      exact add_le_add_right (Nat.cast_le.2 hi) _
    Â· apply hf.of_le (Nat.cast_le.2 (hi.trans n.le_succ))
    Â· intro j hj
      have : â€–iteratedFDerivWithin ğ•œ j (fderivWithin ğ•œ g t) t (f x)â€– =
          â€–iteratedFDerivWithin ğ•œ (j + 1) g t (f x)â€– := by
        rw [iteratedFDerivWithin_succ_eq_comp_right ht (hst hx), comp_apply,
          LinearIsometryEquiv.norm_map]
      rw [this]
      exact hC (j + 1) (add_le_add (hj.trans hi) le_rfl)
    Â· intro j hj h'j
      exact hD j hj (h'j.trans (hi.trans n.le_succ))
  have J : âˆ€ i, â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– â‰¤ D ^ (n - i + 1) := by
    intro i
    have : â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– =
        â€–iteratedFDerivWithin ğ•œ (n - i + 1) f s xâ€– := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply, LinearIsometryEquiv.norm_map]
    rw [this]
    apply hD
    Â· simp only [le_add_iff_nonneg_left, zero_le']
    Â· apply Nat.succ_le_succ tsub_le_self
  calc
    â€–iteratedFDerivWithin ğ•œ (n + 1) (g âˆ˜ f) s xâ€– =
        â€–iteratedFDerivWithin ğ•œ n (fun y : E => fderivWithin ğ•œ (g âˆ˜ f) s y) s xâ€– := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply,
        LinearIsometryEquiv.norm_map]
    _ = â€–iteratedFDerivWithin ğ•œ n (fun y : E => ContinuousLinearMap.compL ğ•œ E Fu Gu
        (fderivWithin ğ•œ g t (f y)) (fderivWithin ğ•œ f s y)) s xâ€– := by
      have L : (1 : â„•âˆ) â‰¤ n.succ := by simpa only [ENat.coe_one, Nat.one_le_cast] using n.succ_pos
      congr 1
      refine iteratedFDerivWithin_congr (fun y hy => ?_) hx _
      apply fderivWithin.comp _ _ _ hst (hs y hy)
      Â· exact hg.differentiableOn L _ (hst hy)
      Â· exact hf.differentiableOn L _ hy
    _ â‰¤ âˆ‘ i âˆˆ Finset.range (n + 1),
        (n.choose i : â„) * â€–iteratedFDerivWithin ğ•œ i (fderivWithin ğ•œ g t âˆ˜ f) s xâ€– *
          â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– := by
      have A : ContDiffOn ğ•œ n (fderivWithin ğ•œ g t âˆ˜ f) s := by
        apply ContDiffOn.comp _ (hf.of_le M.le) hst
        apply hg.fderivWithin ht
        simp only [Nat.cast_succ, le_refl]
      have B : ContDiffOn ğ•œ n (fderivWithin ğ•œ f s) s := by
        apply hf.fderivWithin hs
        simp only [Nat.cast_succ, le_refl]
      exact (ContinuousLinearMap.compL ğ•œ E Fu Gu).norm_iteratedFDerivWithin_le_of_bilinear_of_le_one
        A B hs hx le_rfl (ContinuousLinearMap.norm_compL_le ğ•œ E Fu Gu)
    _ â‰¤ âˆ‘ i âˆˆ Finset.range (n + 1), (n.choose i : â„) * (i ! * C * D ^ i) * D ^ (n - i + 1) := by
      gcongr with i hi
      Â· exact I i hi
      Â· exact J i
    _ = âˆ‘ i âˆˆ Finset.range (n + 1),
        (n ! : â„) * ((i ! : â„)â»Â¹ * i !) * C * (D ^ i * D ^ (n - i + 1)) * ((n - i)! : â„)â»Â¹ := by
      congr! 1 with i hi
      simp only [Nat.cast_choose â„ (Finset.mem_range_succ_iff.1 hi), div_eq_inv_mul, mul_inv]
      ring
    _ = âˆ‘ i âˆˆ Finset.range (n + 1), (n ! : â„) * 1 * C * D ^ (n + 1) * ((n - i)! : â„)â»Â¹ := by
      congr! with i hi
      Â· apply inv_mul_cancel
        simpa only [Ne, Nat.cast_eq_zero] using i.factorial_ne_zero
      Â· rw [â† pow_add]
        congr 1
        rw [Nat.add_succ, Nat.succ_inj']
        exact Nat.add_sub_of_le (Finset.mem_range_succ_iff.1 hi)
    _ â‰¤ âˆ‘ i âˆˆ Finset.range (n + 1), (n ! : â„) * 1 * C * D ^ (n + 1) * 1 := by
      gcongr with i
      apply inv_le_one
      simpa only [Nat.one_le_cast] using (n - i).factorial_pos
    _ = (n + 1)! * C * D ^ (n + 1) := by
      simp only [mul_assoc, mul_one, Finset.sum_const, Finset.card_range, nsmul_eq_mul,
        Nat.factorial_succ, Nat.cast_mul]


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
simp only [norm_iteratedFDerivWithin_comp_le_aux, norm_iteratedFDerivWithin_comp_le_aux]

Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Measurable.lean - 2024-09-08 23:40:54.293080.
---26/200---
For theorem RightDerivMeasurableAux.D_subset_differentiable_set in Mathlib/Analysis/Calculus/FDeriv/Measurable.lean:
theorem D_subset_differentiable_set {K : Set (E â†’L[ğ•œ] F)} (hK : IsComplete K) :
    D f K âŠ† { x | DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K } 


Original valid proof:
:= by
  have P : âˆ€ {n : â„•}, (0 : â„) < (1 / 2) ^ n := fun {n} => pow_pos (by norm_num) n
  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©
  intro x hx
  have :
    âˆ€ e : â„•, âˆƒ n : â„•, âˆ€ p q, n â‰¤ p â†’ n â‰¤ q â†’
      âˆƒ L âˆˆ K, x âˆˆ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) âˆ© A f L ((1 / 2) ^ q) ((1 / 2) ^ e) := by
    intro e
    have := mem_iInter.1 hx e
    rcases mem_iUnion.1 this with âŸ¨n, hnâŸ©
    refine âŸ¨n, fun p q hp hq => ?_âŸ©
    simp only [mem_iInter, ge_iff_le] at hn
    rcases mem_iUnion.1 (hn p hp q hq) with âŸ¨L, hLâŸ©
    exact âŸ¨L, exists_prop.mp <| mem_iUnion.1 hLâŸ©
  choose! n L hn using this
  have M :
    âˆ€ e p q e' p' q',
      n e â‰¤ p â†’
        n e â‰¤ q â†’
          n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’ â€–L e p q - L e' p' q'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p q e' p' q' hp hq hp' hq' he'
    let r := max (n e) (n e')
    have I : ((1 : â„) / 2) ^ e' â‰¤ (1 / 2) ^ e :=
      pow_le_pow_of_le_one (by norm_num) (by norm_num) he'
    have J1 : â€–L e p q - L e p râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1
      have I2 : x âˆˆ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1
      exact norm_sub_le_of_mem_A hc P P I1 I2
    have J2 : â€–L e p r - L e' p' râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2
      have I2 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.2
      exact norm_sub_le_of_mem_A hc P P I1 (A_mono _ _ I I2)
    have J3 : â€–L e' p' r - L e' p' q'â€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.1
      have I2 : x âˆˆ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1
      exact norm_sub_le_of_mem_A hc P P (A_mono _ _ I I1) (A_mono _ _ I I2)
    calc
      â€–L e p q - L e' p' q'â€– =
          â€–L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')â€– := by
        congr 1; abel
      _ â‰¤ â€–L e p q - L e p râ€– + â€–L e p r - L e' p' râ€– + â€–L e' p' r - L e' p' q'â€– :=
        norm_addâ‚ƒ_le _ _ _
      _ â‰¤ 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e := by gcongr
      _ = 12 * â€–câ€– * (1 / 2) ^ e := by ring
  let L0 : â„• â†’ E â†’L[ğ•œ] F := fun e => L e (n e) (n e)
  have : CauchySeq L0 := by
    rw [Metric.cauchySeq_iff']
    intro Îµ Îµpos
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (by positivity) (by norm_num)
    refine âŸ¨e, fun e' he' => ?_âŸ©
    rw [dist_comm, dist_eq_norm]
    calc
      â€–L0 e - L0 e'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'
      _ < 12 * â€–câ€– * (Îµ / (12 * â€–câ€–)) := by gcongr
      _ = Îµ := by field_simp
  obtain âŸ¨f', f'K, hf'âŸ© : âˆƒ f' âˆˆ K, Tendsto L0 atTop (ğ“ f') :=
    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this
  have Lf' : âˆ€ e p, n e â‰¤ p â†’ â€–L e (n e) p - f'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p hp
    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm
    rw [eventually_atTop]
    exact âŸ¨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'âŸ©
  have : HasFDerivAt f f' x := by
    simp only [hasFDerivAt_iff_isLittleO_nhds_zero, isLittleO_iff]
    intro Îµ Îµpos
    have pos : 0 < 4 + 12 * â€–câ€– := by positivity
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (4 + 12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (div_pos Îµpos pos) (by norm_num)
    rw [eventually_nhds_iff_ball]
    refine âŸ¨(1 / 2) ^ (n e + 1), P, fun y hy => ?_âŸ©
    by_cases y_pos : y = 0;
    Â· simp [y_pos]
    have yzero : 0 < â€–yâ€– := norm_pos_iff.mpr y_pos
    have y_lt : â€–yâ€– < (1 / 2) ^ (n e + 1) := by simpa using mem_ball_iff_norm.1 hy
    have yone : â€–yâ€– â‰¤ 1 := le_trans y_lt.le (pow_le_one _ (by norm_num) (by norm_num))
    obtain âŸ¨k, hk, h'kâŸ© : âˆƒ k : â„•, (1 / 2) ^ (k + 1) < â€–yâ€– âˆ§ â€–yâ€– â‰¤ (1 / 2) ^ k :=
      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : â„) < 1 / 2)
        (by norm_num : (1 : â„) / 2 < 1)
    have k_gt : n e < k := by
      have : ((1 : â„) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_trans hk y_lt
      rw [pow_lt_pow_iff_right_of_lt_one (by norm_num : (0 : â„) < 1 / 2) (by norm_num)] at this
      omega
    set m := k - 1
    have m_ge : n e â‰¤ m := Nat.le_sub_one_of_lt k_gt
    have km : k = m + 1 := (Nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm
    rw [km] at hk h'k
    have J1 : â€–f (x + y) - f x - L e (n e) m (x + y - x)â€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
      apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2
      Â· simp only [mem_closedBall, dist_self]
        positivity
      Â· simpa only [dist_eq_norm, add_sub_cancel_left, mem_closedBall, pow_succ, mul_one_div] using
          h'k
    have J2 : â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– :=
      calc
        â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
          simpa only [add_sub_cancel_left] using J1
        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by field_simp; ring
        _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– := by gcongr
    calc
      â€–f (x + y) - f x - f' yâ€– = â€–f (x + y) - f x - L e (n e) m y + (L e (n e) m - f') yâ€– :=
        congr_arg _ (by simp)
      _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– + 12 * â€–câ€– * (1 / 2) ^ e * â€–yâ€– :=
        norm_add_le_of_le J2 <| (le_opNorm _ _).trans <| by gcongr; exact Lf' _ _ m_ge
      _ = (4 + 12 * â€–câ€–) * â€–yâ€– * (1 / 2) ^ e := by ring
      _ â‰¤ (4 + 12 * â€–câ€–) * â€–yâ€– * (Îµ / (4 + 12 * â€–câ€–)) := by gcongr
      _ = Îµ * â€–yâ€– := by field_simp [ne_of_gt pos]; ring
  rw [â† this.fderiv] at f'K
  exact âŸ¨this.differentiableAt, f'KâŸ©


Verifying proof (Commit 6b3f3fe208f0cdce581d713270301bed755856ed):
simp only [D_subset_differentiable_set] at D_subset_differentiable_set

Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean - 2024-09-08 23:41:14.326916.
---27/200---
For theorem Convex.taylor_approx_two_segment in Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean:
theorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v âˆˆ interior s)
    (hw : x + v + w âˆˆ interior s) :
    (fun h : â„ => f (x + h â€¢ v + h â€¢ w)
        - f (x + h â€¢ v) - h â€¢ f' x w - h ^ 2 â€¢ f'' v w - (h ^ 2 / 2) â€¢ f'' w w) =o[ğ“[>] 0]
      fun h => h ^ 2 


Original valid proof:
:= by
  refine IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun Îµ Îµpos => ?_) (isBigO_const_mul_self ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) _ _)
  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
  rcases Metric.mem_nhdsWithin_iff.1 (hx Îµpos) with âŸ¨Î´, Î´pos, sÎ´âŸ©
  have E1 : âˆ€á¶  h in ğ“[>] (0 : â„), h * (â€–vâ€– + â€–wâ€–) < Î´ := by
    have : Filter.Tendsto (fun h => h * (â€–vâ€– + â€–wâ€–)) (ğ“[>] (0 : â„)) (ğ“ (0 * (â€–vâ€– + â€–wâ€–))) :=
      (continuous_id.mul continuous_const).continuousWithinAt
    apply (tendsto_order.1 this).2 Î´
    simpa only [zero_mul] using Î´pos
  have E2 : âˆ€á¶  h in ğ“[>] (0 : â„), (h : â„) < 1 :=
    mem_nhdsWithin_Ioi_iff_exists_Ioo_subset.2
      âŸ¨(1 : â„), by simp only [mem_Ioi, zero_lt_one], fun x hx => hx.2âŸ©
  filter_upwards [E1, E2, self_mem_nhdsWithin] with h hÎ´ h_lt_1 hpos
  replace hpos : 0 < h := hpos
  have xt_mem : âˆ€ t âˆˆ Icc (0 : â„) 1, x + h â€¢ v + (t * h) â€¢ w âˆˆ interior s := by
    intro t ht
    have : x + h â€¢ v âˆˆ interior s := s_conv.add_smul_mem_interior xs hv âŸ¨hpos, h_lt_1.leâŸ©
    rw [â† smul_smul]
    apply s_conv.interior.add_smul_mem this _ ht
    rw [add_assoc] at hw
    rw [add_assoc, â† smul_add]
    exact s_conv.add_smul_mem_interior xs hw âŸ¨hpos, h_lt_1.leâŸ©
  let g t :=
    f (x + h â€¢ v + (t * h) â€¢ w) - (t * h) â€¢ f' x w - (t * h ^ 2) â€¢ f'' v w -
      ((t * h) ^ 2 / 2) â€¢ f'' w w
  set g' := fun t =>
    f' (x + h â€¢ v + (t * h) â€¢ w) (h â€¢ w) - h â€¢ f' x w - h ^ 2 â€¢ f'' v w - (t * h ^ 2) â€¢ f'' w w
    with hg'
  have g_deriv : âˆ€ t âˆˆ Icc (0 : â„) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by
    intro t ht
    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]
    Â· refine (hf _ ?_).comp_hasDerivWithinAt _ ?_
      Â· exact xt_mem t ht
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.const_add, HasDerivAt.smul_const,
        hasDerivAt_mul_const]
    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· suffices H : HasDerivWithinAt (fun u => ((u * h) ^ 2 / 2) â€¢ f'' w w)
          ((((2 : â„•) : â„) * (t * h) ^ (2 - 1) * (1 * h) / 2) â€¢ f'' w w) (Icc 0 1) t by
        convert H using 2
        ring
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_id',
        HasDerivAt.pow, HasDerivAt.mul_const]
  have g'_bound : âˆ€ t âˆˆ Ico (0 : â„) 1, â€–g' tâ€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
    intro t ht
    have I : â€–h â€¢ v + (t * h) â€¢ wâ€– â‰¤ h * (â€–vâ€– + â€–wâ€–) :=
      calc
        â€–h â€¢ v + (t * h) â€¢ wâ€– â‰¤ â€–h â€¢ vâ€– + â€–(t * h) â€¢ wâ€– := norm_add_le _ _
        _ = h * â€–vâ€– + t * (h * â€–wâ€–) := by
          simp only [norm_smul, Real.norm_eq_abs, hpos.le, abs_of_nonneg, abs_mul, ht.left,
            mul_assoc]
        _ â‰¤ h * â€–vâ€– + 1 * (h * â€–wâ€–) := by gcongr; exact ht.2.le
        _ = h * (â€–vâ€– + â€–wâ€–) := by ring
    calc
      â€–g' tâ€– = â€–(f' (x + h â€¢ v + (t * h) â€¢ w) - f' x - f'' (h â€¢ v + (t * h) â€¢ w)) (h â€¢ w)â€– := by
        rw [hg']
        have : h * (t * h) = t * (h * h) := by ring
        simp only [ContinuousLinearMap.coe_sub', ContinuousLinearMap.map_add, pow_two,
          ContinuousLinearMap.add_apply, Pi.smul_apply, smul_sub, smul_add, smul_smul, â† sub_sub,
          ContinuousLinearMap.coe_smul', Pi.sub_apply, ContinuousLinearMap.map_smul, this]
      _ â‰¤ â€–f' (x + h â€¢ v + (t * h) â€¢ w) - f' x - f'' (h â€¢ v + (t * h) â€¢ w)â€– * â€–h â€¢ wâ€– :=
        (ContinuousLinearMap.le_opNorm _ _)
      _ â‰¤ Îµ * â€–h â€¢ v + (t * h) â€¢ wâ€– * â€–h â€¢ wâ€– := by
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        have H : x + h â€¢ v + (t * h) â€¢ w âˆˆ Metric.ball x Î´ âˆ© interior s := by
          refine âŸ¨?_, xt_mem t âŸ¨ht.1, ht.2.leâŸ©âŸ©
          rw [add_assoc, add_mem_ball_iff_norm]
          exact I.trans_lt hÎ´
        simpa only [mem_setOf_eq, add_assoc x, add_sub_cancel_left] using sÎ´ H
      _ â‰¤ Îµ * (â€–h â€¢ vâ€– + â€–h â€¢ wâ€–) * â€–h â€¢ wâ€– := by
        gcongr
        apply (norm_add_le _ _).trans
        gcongr
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, ht.1, hpos.le, mul_assoc]
        exact mul_le_of_le_one_left (mul_nonneg hpos.le (norm_nonneg _)) ht.2.le
      _ = Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, hpos.le]; ring
  have I : â€–g 1 - g 0â€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
    simpa only [mul_one, sub_zero] using
      norm_image_sub_le_of_norm_deriv_le_segment' g_deriv g'_bound 1 (right_mem_Icc.2 zero_le_one)
  convert I using 1
  Â· congr 1
    simp only [g, Nat.one_ne_zero, add_zero, one_mul, zero_div, zero_mul, sub_zero,
      zero_smul, Ne, not_false_iff, bit0_eq_zero, zero_pow]
    abel
  Â· simp only [Real.norm_eq_abs, abs_mul, add_nonneg (norm_nonneg v) (norm_nonneg w), abs_of_nonneg,
      hpos.le, mul_assoc, norm_nonneg, abs_pow]


Verifying proof (Commit 05dd33777bb0a96c66523df7c7d1a34b2d9a1be5):
simp only [Convex.taylor_approx_two_segment, Convex.taylor_approx_two_segment]

Attempt failure.

Working on Mathlib/Analysis/Calculus/LagrangeMultipliers.lean - 2024-09-08 23:41:34.780695.
---28/200---
For theorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d in Mathlib/Analysis/Calculus/LagrangeMultipliers.lean:
theorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d {f : E â†’ â„} {f' : E â†’L[â„] â„}
    (hextr : IsLocalExtrOn Ï† {x | f x = f xâ‚€} xâ‚€) (hf' : HasStrictFDerivAt f f' xâ‚€)
    (hÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€) : âˆƒ a b : â„, (a, b) â‰  0 âˆ§ a â€¢ f' + b â€¢ Ï†' = 0 


Original valid proof:
:= by
  obtain âŸ¨Î›, Î›â‚€, hÎ›, hfÎ›âŸ© := hextr.exists_linear_map_of_hasStrictFDerivAt hf' hÏ†'
  refine âŸ¨Î› 1, Î›â‚€, ?_, ?_âŸ©
  Â· contrapose! hÎ›
    simp only [Prod.mk_eq_zero] at hÎ› âŠ¢
    refine âŸ¨LinearMap.ext fun x => ?_, hÎ›.2âŸ©
    simpa [hÎ›.1] using Î›.map_smul x 1
  Â· ext x
    have Hâ‚ : Î› (f' x) = f' x * Î› 1 := by
      simpa only [mul_one, Algebra.id.smul_eq_mul] using Î›.map_smul (f' x) 1
    have Hâ‚‚ : f' x * Î› 1 + Î›â‚€ * Ï†' x = 0 := by simpa only [Algebra.id.smul_eq_mul, Hâ‚] using hfÎ› x
    simpa [mul_comm] using Hâ‚‚


Verifying proof (Commit b15c6ea0b0ad3ac6e15420c45ece165eca6725cc):
rcases hf'.theorem_isLocalExtrOn_exists_multipliers_of_hasStrictFDerivAt_extr hf' hÏ†' hf' hÏ†' with
  âŸ¨a, b, ha, hb'âŸ©

Attempt failure.

Working on Mathlib/Analysis/Calculus/MeanValue.lean - 2024-09-08 23:41:54.918106.
---29/200---
For theorem strictMono_of_deriv_pos in Mathlib/Analysis/Calculus/MeanValue.lean:
theorem strictMono_of_deriv_pos {f : â„ â†’ â„} (hf' : âˆ€ x, 0 < deriv f x) : StrictMono f 


Original valid proof:
:=
  strictMonoOn_univ.1 <| strictMonoOn_of_deriv_pos convex_univ (fun z _ =>
    (differentiableAt_of_deriv_ne_zero (hf' z).ne').differentiableWithinAt.continuousWithinAt)
    fun x _ => hf' x


Verifying proof (Commit 0939faa78a0c4506a8aee4e86b897d6e84c6cb96):
refine StrictMono.strictMono_of_deriv_pos (strictMono_of_deriv_pos hf') ?_

Attempt failure.

Working on Mathlib/Analysis/Calculus/Taylor.lean - 2024-09-08 23:42:15.085607.
---30/200---
For theorem taylor_mean_remainder_lagrange in Mathlib/Analysis/Calculus/Taylor.lean:
theorem taylor_mean_remainder_lagrange {f : â„ â†’ â„} {x xâ‚€ : â„} {n : â„•} (hx : xâ‚€ < x)
    (hf : ContDiffOn â„ n f (Icc xâ‚€ x))
    (hf' : DifferentiableOn â„ (iteratedDerivWithin n f (Icc xâ‚€ x)) (Ioo xâ‚€ x)) :
    âˆƒ x' âˆˆ Ioo xâ‚€ x, f x - taylorWithinEval f n (Icc xâ‚€ x) xâ‚€ x =
      iteratedDerivWithin (n + 1) f (Icc xâ‚€ x) x' * (x - xâ‚€) ^ (n + 1) / (n + 1)! 


Original valid proof:
:= by
  have gcont : ContinuousOn (fun t : â„ => (x - t) ^ (n + 1)) (Icc xâ‚€ x) := by fun_prop
  have xy_ne : âˆ€ y : â„, y âˆˆ Ioo xâ‚€ x â†’ (x - y) ^ n â‰  0 := by
    intro y hy
    refine pow_ne_zero _ ?_
    rw [mem_Ioo] at hy
    rw [sub_ne_zero]
    exact hy.2.ne'
  have hg' : âˆ€ y : â„, y âˆˆ Ioo xâ‚€ x â†’ -(â†‘n + 1) * (x - y) ^ n â‰  0 := fun y hy =>
    mul_ne_zero (neg_ne_zero.mpr (Nat.cast_add_one_ne_zero n)) (xy_ne y hy)
  rcases taylor_mean_remainder hx hf hf' gcont (fun y _ => monomial_has_deriv_aux y x _) hg' with
    âŸ¨y, hy, hâŸ©
  use y, hy
  simp only [sub_self, zero_pow, Ne, Nat.succ_ne_zero, not_false_iff, zero_sub, mul_neg] at h
  rw [h, neg_div, â† div_neg, neg_mul, neg_neg]
  field_simp [xy_ne y hy, Nat.factorial]; ring


Verifying proof (Commit e5e7a3c38578dfab479b07cd58791d26d9ea89a8):
rcases exists_mem_Ioo_of_differentiableWithinAt_Icc_of_le hx hf.differentiableWithinAt
  hf' hf' hf'

Attempt failure.

Working on Mathlib/Analysis/Complex/CauchyIntegral.lean - 2024-09-08 23:42:38.129766.
---31/200---
For theorem Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable in Mathlib/Analysis/Complex/CauchyIntegral.lean:
theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : â„‚}
    {r R : â„} (h0 : 0 < r) (hle : r â‰¤ R) {f : â„‚ â†’ E} {s : Set â„‚} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : âˆ€ z âˆˆ (ball c R \ closedBall c r) \ s, DifferentiableAt â„‚ f z) :
    (âˆ® z in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® z in C(c, r), (z - c)â»Â¹ â€¢ f z 


Original valid proof:
:= by
  set A := closedBall c R \ ball c r
  obtain âŸ¨a, rflâŸ© : âˆƒ a, Real.exp a = r := âŸ¨Real.log r, Real.exp_log h0âŸ©
  obtain âŸ¨b, rflâŸ© : âˆƒ b, Real.exp b = R := âŸ¨Real.log R, Real.exp_log (h0.trans_le hle)âŸ©
  rw [Real.exp_le_exp] at hle
  suffices
    (âˆ« Î¸ in (0)..2 * Ï€, I â€¢ f (circleMap c (Real.exp b) Î¸)) =
      âˆ« Î¸ in (0)..2 * Ï€, I â€¢ f (circleMap c (Real.exp a) Î¸) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, â† exp_add, smul_smul, â†
      div_eq_mul_inv, mul_div_cancel_leftâ‚€ _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] Ã—â„‚ [[0, 2 * Ï€]]
  set g : â„‚ â†’ â„‚ := (c + exp Â·)
  have hdg : Differentiable â„‚ g := differentiable_exp.const_add _
  replace hs : (g â»Â¹' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z âŸ¨h, -âŸ©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f âˆ˜ g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : âˆ€ z âˆˆ Ioo (min a b) (max a b) Ã—â„‚ Ioo (min 0 (2 * Ï€)) (max 0 (2 * Ï€)) \ g â»Â¹' s,
      DifferentiableAt â„‚ (f âˆ˜ g) z := by
    refine fun z hz => (hd (g z) âŸ¨?_, hz.2âŸ©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, â† exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ âŸ¨a, 0âŸ© âŸ¨b, 2 * Ï€âŸ© _ hs hc hd


Verifying proof (Commit 05dd33777bb0a96c66523df7c7d1a34b2d9a1be5):
refine theorem_circleIntegral_sub_center_inv_smul_eq_of_differentiable_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_

Attempt failure.

Working on Mathlib/Analysis/Complex/Hadamard.lean - 2024-09-08 23:43:01.559016.
---32/200---
For theorem Complex.HadamardThreeLines.norm_le_interp_of_mem_verticalClosedStrip' in Mathlib/Analysis/Complex/Hadamard.lean:
lemma norm_le_interp_of_mem_verticalClosedStrip' (f : â„‚ â†’ E) {z : â„‚} {a b : â„}
    (hz : z âˆˆ verticalClosedStrip 0 1) (hd : DiffContOnCl â„‚ f (verticalStrip 0 1))
    (hB : BddAbove ((norm âˆ˜ f) '' (verticalClosedStrip 0 1)))
    (ha : âˆ€ z âˆˆ re â»Â¹' {0}, â€–f zâ€– â‰¤ a) (hb : âˆ€ z âˆˆ re â»Â¹' {1}, â€–f zâ€– â‰¤ b) :
    â€–f zâ€– â‰¤ a ^ (1 - z.re) * b ^ z.re 


Original valid proof:
:= by
  have : â€–interpStrip f zâ€– â‰¤ (sSupNormIm f 0) ^ (1 - z.re) * (sSupNormIm f 1) ^ z.re := by
    by_cases h : sSupNormIm f 0 = 0 âˆ¨ sSupNormIm f 1 = 0
    Â· rw [interpStrip_eq_of_zero f z h, norm_zero, mul_nonneg_iff]
      left
      exact âŸ¨Real.rpow_nonneg (sSupNormIm_nonneg f _) _,
        Real.rpow_nonneg (sSupNormIm_nonneg f _) _ âŸ©
    Â· push_neg at h
      rcases h with âŸ¨h0, h1âŸ©
      rw [ne_comm] at h0 h1
      simp_rw [interpStrip_eq_of_pos f _ (lt_of_le_of_ne (sSupNormIm_nonneg f 0) h0)
        (lt_of_le_of_ne (sSupNormIm_nonneg f 1) h1)]
      simp only [norm_eq_abs, map_mul]
      rw [abs_cpow_eq_rpow_re_of_pos ((Ne.le_iff_lt h0).mp (sSupNormIm_nonneg f _)) _]
      rw [abs_cpow_eq_rpow_re_of_pos ((Ne.le_iff_lt h1).mp (sSupNormIm_nonneg f _)) _]
      simp only [sub_re, one_re, le_refl]
  apply (norm_le_interpStrip_of_mem_verticalClosedStrip f hz hd hB).trans (this.trans _)
  apply mul_le_mul_of_le_of_le _ _ (Real.rpow_nonneg (sSupNormIm_nonneg f _) _)
  Â· apply (Real.rpow_nonneg _ _)
    specialize hb 1
    simp only [mem_preimage, one_re, mem_singleton_iff, forall_true_left] at hb
    exact (norm_nonneg _).trans hb
  Â· apply Real.rpow_le_rpow (sSupNormIm_nonneg f _) _ (sub_nonneg.mpr hz.2)
    Â· rw [sSupNormIm]
      apply csSup_le _
      Â· simpa [comp_apply, mem_image, forall_exists_index,
          and_imp, forall_apply_eq_imp_iffâ‚‚] using ha
      Â· use â€–(f 0)â€–, 0
        simp only [mem_preimage, zero_re, mem_singleton_iff, comp_apply,
          and_self]
  Â· apply Real.rpow_le_rpow (sSupNormIm_nonneg f _) _ hz.1
    Â· rw [sSupNormIm]
      apply csSup_le _
      Â· simpa [comp_apply, mem_image, forall_exists_index,
          and_imp, forall_apply_eq_imp_iffâ‚‚] using hb
      Â· use â€–(f 1)â€–, 1
        simp only [mem_preimage, one_re, mem_singleton_iff, comp_apply,
          and_self]


Verifying proof (Commit 83acd4ef0d51cf6d0371c1664c9efdd31712f671):
simp only [mem_preimage, mem_singleton_iff, norm_le_interp_of_mem_verticalClosedStrip,
  norm_le_interp_of_mem_verticalClosedStrip']

Attempt failure.

Working on Mathlib/Analysis/Convex/Basic.lean - 2024-09-08 23:43:21.952588.
---33/200---
For theorem convex_Ioi in Mathlib/Analysis/Convex/Basic.lean:
theorem convex_Ioi (r : Î²) : Convex ğ•œ (Ioi r) 


Original valid proof:
:=
  @convex_Iio ğ•œ Î²áµ’áµˆ _ _ _ _ r


Verifying proof (Commit 03690a4c3252f422184189d0b6a6dd8d1c55d551):
rw [convex_Ioi, convex_Ioi, convex_Ioi]

Attempt failure.

Working on Mathlib/Analysis/Convex/Caratheodory.lean - 2024-09-08 23:43:43.673470.
---34/200---
For theorem convexHull_eq_union in Mathlib/Analysis/Convex/Caratheodory.lean:
theorem convexHull_eq_union : convexHull ğ•œ s =
    â‹ƒ (t : Finset E) (hss : â†‘t âŠ† s) (hai : AffineIndependent ğ•œ ((â†‘) : t â†’ E)), convexHull ğ•œ â†‘t 


Original valid proof:
:= by
  apply Set.Subset.antisymm
  Â· intro x hx
    simp only [exists_prop, Set.mem_iUnion]
    exact âŸ¨Caratheodory.minCardFinsetOfMemConvexHull hx,
      Caratheodory.minCardFinsetOfMemConvexHull_subseteq hx,
      Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull hx,
      Caratheodory.mem_minCardFinsetOfMemConvexHull hxâŸ©
  Â· iterate 3 convert Set.iUnion_subset _; intro
    exact convexHull_mono â€¹_â€º


Verifying proof (Commit 6b5a6157526632a0d26108670d5a71f9223c87fd):
rw [convexHull_eq_union]

Attempt failure.

Working on Mathlib/Analysis/Convex/Integral.lean - 2024-09-08 23:44:03.864229.
---35/200---
For theorem ae_eq_const_or_norm_average_lt_of_norm_le_const in Mathlib/Analysis/Convex/Integral.lean:
theorem ae_eq_const_or_norm_average_lt_of_norm_le_const [StrictConvexSpace â„ E]
    (h_le : âˆ€áµ x âˆ‚Î¼, â€–f xâ€– â‰¤ C) : f =áµ[Î¼] const Î± (â¨ x, f x âˆ‚Î¼) âˆ¨ â€–â¨ x, f x âˆ‚Î¼â€– < C 


Original valid proof:
:= by
  rcases le_or_lt C 0 with hC0 | hC0
  Â· have : f =áµ[Î¼] 0 := h_le.mono fun x hx => norm_le_zero_iff.1 (hx.trans hC0)
    simp only [average_congr this, Pi.zero_apply, average_zero]
    exact Or.inl this
  by_cases hfi : Integrable f Î¼; swap
  Â· simp [average_eq, integral_undef hfi, hC0, ENNReal.toReal_pos_iff]
  rcases (le_top : Î¼ univ â‰¤ âˆ).eq_or_lt with hÎ¼t | hÎ¼t; Â· simp [average_eq, hÎ¼t, hC0]
  haveI : IsFiniteMeasure Î¼ := âŸ¨hÎ¼tâŸ©
  replace h_le : âˆ€áµ x âˆ‚Î¼, f x âˆˆ closedBall (0 : E) C := by simpa only [mem_closedBall_zero_iff]
  simpa only [interior_closedBall _ hC0.ne', mem_ball_zero_iff] using
    (strictConvex_closedBall â„ (0 : E) C).ae_eq_const_or_average_mem_interior isClosed_ball h_le
      hfi


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
simp only [norm_average_lt_of_norm_average_lt_of_norm_average_lt_of_norm_average_lt_of_norm_average_lt_of_norm_average_lt_of]

Attempt failure.

Working on Mathlib/Analysis/Convex/Intrinsic.lean - 2024-09-08 23:44:24.147647.
---36/200---
For theorem intrinsicClosure_eq_closure in Mathlib/Analysis/Convex/Intrinsic.lean:
theorem intrinsicClosure_eq_closure : intrinsicClosure ğ•œ s = closure s 


Original valid proof:
:= by
  ext x
  simp only [mem_closure_iff, mem_intrinsicClosure]
  refine âŸ¨?_, fun h => âŸ¨âŸ¨x, _âŸ©, ?_, Subtype.coe_mk _ ?_âŸ©âŸ©
  Â· rintro âŸ¨x, h, rflâŸ© t ht hx
    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h _ (continuous_induced_dom.isOpen_preimage t ht) hx
    exact âŸ¨z, hzâ‚, hzâ‚‚âŸ©
  Â· rintro _ âŸ¨t, ht, rflâŸ© hx
    obtain âŸ¨y, hyt, hysâŸ© := h _ ht hx
    exact âŸ¨âŸ¨_, subset_affineSpan ğ•œ s hysâŸ©, hyt, hysâŸ©
  Â· by_contra hc
    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h _ (affineSpan ğ•œ s).closed_of_finiteDimensional.isOpen_compl hc
    exact hzâ‚ (subset_affineSpan ğ•œ s hzâ‚‚)


Verifying proof (Commit ded82be28af61da8cf3266077ac67ad9bf41c841):
rw [closure_eq_closure, intrinsicClosure_eq_closure]

Attempt failure.

Working on Mathlib/Analysis/Convex/Mul.lean - 2024-09-08 23:44:45.024606.
---37/200---
For theorem ConcaveOn.smul' in Mathlib/Analysis/Convex/Mul.lean:
lemma ConcaveOn.smul' (hf : ConcaveOn ğ•œ s f) (hg : ConcaveOn ğ•œ s g) (hfâ‚€ : âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ 0 â‰¤ f x)
    (hgâ‚€ : âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ 0 â‰¤ g x) (hfg : AntivaryOn f g s) : ConcaveOn ğ•œ s (f â€¢ g) 


Original valid proof:
:= by
  refine âŸ¨hf.1, fun x hx y hy a b ha hb hab â†¦ ?_âŸ©
  dsimp
  refine (smul_le_smul (hf.2 hx hy ha hb hab) (hg.2 hx hy ha hb hab)
    (add_nonneg (smul_nonneg ha <| hfâ‚€ hx) <| smul_nonneg hb <| hfâ‚€ hy)
    (hgâ‚€ <| hf.1 hx hy ha hb hab)).trans' ?_
  calc a â€¢ f x â€¢ g x + b â€¢ f y â€¢ g y
        = (a * (a + b)) â€¢ (f x â€¢ g x) + (b * (a + b)) â€¢ (f y â€¢ g y) := by simp_rw [hab, mul_one]
    _ = (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g x + f y â€¢ g y) := by
        simp only [mul_add, add_smul, smul_add, mul_comm _ a]; abel
    _ â‰¤ (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g y + f y â€¢ g x) := by
        gcongr _ + (a * b) â€¢ ?_; exact hfg.smul_add_smul_le_smul_add_smul hx hy
    _ = _ := ?_
  simp only [mul_add, add_smul, smul_add]
  rw [â† smul_smul_smul_comm a, â† smul_smul_smul_comm b, â† smul_smul_smul_comm a b,
    â† smul_smul_smul_comm b b, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_comm b a,
    add_comm ((a * b) â€¢ f x â€¢ g y), add_comm ((a * b) â€¢ f x â€¢ g y), add_add_add_comm]


Verifying proof (Commit 5fb9beab28702fb284701d494bc9b7c5f52fef53):
simpa onlemma ConcaveOn.smul' hf hfg hfâ‚€ hfâ‚€ hfâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hg

Attempt failure.

Working on Mathlib/Analysis/Convex/Segment.lean - 2024-09-08 23:45:01.485358.
---38/200---
For theorem mem_segment_add_sub in Mathlib/Analysis/Convex/Segment.lean:
theorem mem_segment_add_sub [Invertible (2 : ğ•œ)] (x y : E) : x âˆˆ [x + y -[ğ•œ] x - y] 


Original valid proof:
:= by
  convert @midpoint_mem_segment ğ•œ _ _ _ _ _ (x + y) (x - y)
  rw [midpoint_add_sub]


Verifying proof (Commit 03690a4c3252f422184189d0b6a6dd8d1c55d551):
rw [mem_segment_add_sub]

Attempt failure.

Working on Mathlib/Analysis/Convolution.lean - 2024-09-08 23:45:15.091623.
---39/200---
For theorem MeasureTheory.continuousOn_convolution_right_with_param in Mathlib/Analysis/Convolution.lean:
theorem continuousOn_convolution_right_with_param {g : P â†’ G â†’ E'} {s : Set P} {k : Set G}
    (hk : IsCompact k) (hgs : âˆ€ p, âˆ€ x, p âˆˆ s â†’ x âˆ‰ k â†’ g p x = 0)
    (hf : LocallyIntegrable f Î¼) (hg : ContinuousOn (â†¿g) (s Ã—Ë¢ univ)) :
    ContinuousOn (fun q : P Ã— G => (f â‹†[L, Î¼] g q.1) q.2) (s Ã—Ë¢ univ) 


Original valid proof:
:= by
  by_cases H : âˆ€ p âˆˆ s, âˆ€ x, g p x = 0
  Â· apply (continuousOn_const (c := 0)).congr
    rintro âŸ¨p, xâŸ© âŸ¨hp, -âŸ©
    apply integral_eq_zero_of_ae (eventually_of_forall (fun y â†¦ ?_))
    simp [H p hp _]
  have : LocallyCompactSpace G := by
    push_neg at H
    rcases H with âŸ¨p, hp, x, hxâŸ©
    have A : support (g p) âŠ† k := support_subset_iff'.2 (fun y hy â†¦ hgs p y hp hy)
    have B : Continuous (g p) := by
      refine hg.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
      simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true] using hp
    rcases eq_zero_or_locallyCompactSpace_of_support_subset_isCompact_of_addGroup hk A B with H|H
    Â· simp [H] at hx
    Â· exact H
  rintro âŸ¨qâ‚€, xâ‚€âŸ© âŸ¨hqâ‚€, -âŸ©
  obtain âŸ¨t, t_comp, htâŸ© : âˆƒ t, IsCompact t âˆ§ t âˆˆ ğ“ xâ‚€ := exists_compact_mem_nhds xâ‚€
  let k' : Set G := (-k) +áµ¥ t
  have k'_comp : IsCompact k' := IsCompact.vadd_set hk.neg t_comp
  let g' : (P Ã— G) â†’ G â†’ E' := fun p x â†¦ g p.1 (p.2 - x)
  let s' : Set (P Ã— G) := s Ã—Ë¢ t
  have A : ContinuousOn g'.uncurry (s' Ã—Ë¢ univ) := by
    have : g'.uncurry = g.uncurry âˆ˜ (fun w â†¦ (w.1.1, w.1.2 - w.2)) := by ext y; rfl
    rw [this]
    refine hg.comp (continuous_fst.fst.prod_mk (continuous_fst.snd.sub
      continuous_snd)).continuousOn ?_
    simp (config := {contextual := true}) [s', MapsTo]
  have B : ContinuousOn (fun a â†¦ âˆ« x, L (f x) (g' a x) âˆ‚Î¼) s' := by
    apply continuousOn_integral_bilinear_of_locally_integrable_of_compact_support L k'_comp A _
      (hf.integrableOn_isCompact k'_comp)
    rintro âŸ¨p, xâŸ© y âŸ¨hp, hxâŸ© hy
    apply hgs p _ hp
    contrapose! hy
    exact âŸ¨y - x, by simpa using hy, x, hx, by simpâŸ©
  apply ContinuousWithinAt.mono_of_mem (B (qâ‚€, xâ‚€) âŸ¨hqâ‚€, mem_of_mem_nhds htâŸ©)
  exact mem_nhdsWithin_prod_iff.2 âŸ¨s, self_mem_nhdsWithin, t, nhdsWithin_le_nhds ht, Subset.rflâŸ©


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
rw [continuousOn_convolution_right_with_param] at hf

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Basic.lean - 2024-09-08 23:45:35.481460.
---40/200---
For theorem OrthogonalFamily.summable_iff_norm_sq_summable in Mathlib/Analysis/InnerProductSpace/Basic.lean:
theorem OrthogonalFamily.summable_iff_norm_sq_summable [CompleteSpace E] (f : âˆ€ i, G i) :
    (Summable fun i => V i (f i)) â†” Summable fun i => â€–f iâ€– ^ 2 


Original valid proof:
:= by
  classical
    simp only [summable_iff_cauchySeq_finset, NormedAddCommGroup.cauchySeq_iff, Real.norm_eq_abs]
    constructor
    Â· intro hf Îµ hÎµ
      obtain âŸ¨a, HâŸ© := hf _ (sqrt_pos.mpr hÎµ)
      use a
      intro sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      rw [â† Finset.sum_sdiff_sub_sum_sdiff]
      refine (abs_sub _ _).trans_lt ?_
      have : âˆ€ i, 0 â‰¤ â€–f iâ€– ^ 2 := fun i : Î¹ => sq_nonneg _
      simp only [Finset.abs_sum_of_nonneg' this]
      have : ((âˆ‘ i âˆˆ sâ‚ \ sâ‚‚, â€–f iâ€– ^ 2) + âˆ‘ i âˆˆ sâ‚‚ \ sâ‚, â€–f iâ€– ^ 2) < âˆšÎµ ^ 2 := by
        rw [â† hV.norm_sq_diff_sum, sq_lt_sq, abs_of_nonneg (sqrt_nonneg _),
          abs_of_nonneg (norm_nonneg _)]
        exact H sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      have hÎ· := sq_sqrt (le_of_lt hÎµ)
      linarith
    Â· intro hf Îµ hÎµ
      have hÎµ' : 0 < Îµ ^ 2 / 2 := half_pos (sq_pos_of_pos hÎµ)
      obtain âŸ¨a, HâŸ© := hf _ hÎµ'
      use a
      intro sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      refine (abs_lt_of_sq_lt_sq' ?_ (le_of_lt hÎµ)).2
      have has : a â‰¤ sâ‚ âŠ“ sâ‚‚ := le_inf hsâ‚ hsâ‚‚
      rw [hV.norm_sq_diff_sum]
      have Hsâ‚ : âˆ‘ x âˆˆ sâ‚ \ sâ‚‚, â€–f xâ€– ^ 2 < Îµ ^ 2 / 2 := by
        convert H _ hsâ‚ _ has
        have : sâ‚ âŠ“ sâ‚‚ âŠ† sâ‚ := Finset.inter_subset_left
        rw [â† Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        Â· simp
        Â· exact fun i => sq_nonneg _
      have Hsâ‚‚ : âˆ‘ x âˆˆ sâ‚‚ \ sâ‚, â€–f xâ€– ^ 2 < Îµ ^ 2 / 2 := by
        convert H _ hsâ‚‚ _ has
        have : sâ‚ âŠ“ sâ‚‚ âŠ† sâ‚‚ := Finset.inter_subset_right
        rw [â† Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        Â· simp
        Â· exact fun i => sq_nonneg _
      linarith


Verifying proof (Commit 1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493):
refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Positive.lean - 2024-09-08 23:45:55.963136.
---41/200---
For theorem ContinuousLinearMap.isPositive_one in Mathlib/Analysis/InnerProductSpace/Positive.lean:
theorem isPositive_one : IsPositive (1 : E â†’L[ğ•œ] E) 


Original valid proof:
:=
  âŸ¨isSelfAdjoint_one _, fun _ => inner_self_nonnegâŸ©


Verifying proof (Commit 1c643aca968064296312bf5328c84d0c50cfe5ae):
heorem isPositive_one isPositive_one

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Projection.lean - 2024-09-08 23:46:16.086988.
---42/200---
For theorem OrthogonalFamily.projection_directSum_coeAddHom in Mathlib/Analysis/InnerProductSpace/Projection.lean:
theorem OrthogonalFamily.projection_directSum_coeAddHom [DecidableEq Î¹] {V : Î¹ â†’ Submodule ğ•œ E}
    (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) (x : â¨ i, V i) (i : Î¹)
    [CompleteSpace (V i)] :
    orthogonalProjection (V i) (DirectSum.coeAddMonoidHom V x) = x i 


Original valid proof:
:= by
  induction' x using DirectSum.induction_on with j x x y hx hy
  Â· simp
  Â· simp_rw [DirectSum.coeAddMonoidHom_of, DirectSum.of]
    erw [DFinsupp.singleAddHom_apply]
    obtain rfl | hij := Decidable.eq_or_ne i j
    Â· rw [orthogonalProjection_mem_subspace_eq_self, DFinsupp.single_eq_same]
    Â· rw [orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero,
        DFinsupp.single_eq_of_ne hij.symm]
      exact hV.isOrtho hij.symm x.prop
  Â· simp_rw [map_add]
    exact congr_argâ‚‚ (Â· + Â·) hx hy


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
simp only [orthogonalProjection]

Attempt failure.

---43/200---
For theorem LinearIsometryEquiv.reflections_generate_dim_aux in Mathlib/Analysis/InnerProductSpace/Projection.lean:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional â„ F] {n : â„•}
    (Ï† : F â‰ƒâ‚—áµ¢[â„] F) (hn : finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—® â‰¤ n) :
    âˆƒ l : List F, l.length â‰¤ n âˆ§ Ï† = (l.map fun v => reflection (â„ âˆ™ v)á—®).prod 


Original valid proof:
:= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine âŸ¨[], rfl.le, show Ï† = 1 from ?_âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      omega
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine âŸ¨x::l, Nat.succ_le_succ hl, ?_âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
refine âŸ¨finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—®, ?_, ?_âŸ©

Attempt failure.

Working on Mathlib/Analysis/MeanInequalities.lean - 2024-09-08 23:46:56.664244.
---44/200---
For theorem Real.Lp_add_le_hasSum_of_nonneg in Mathlib/Analysis/MeanInequalities.lean:
theorem Lp_add_le_hasSum_of_nonneg (hp : 1 â‰¤ p) (hf : âˆ€ i, 0 â‰¤ f i) (hg : âˆ€ i, 0 â‰¤ g i) {A B : â„}
    (hA : 0 â‰¤ A) (hB : 0 â‰¤ B) (hfA : HasSum (fun i => f i ^ p) (A ^ p))
    (hgB : HasSum (fun i => g i ^ p) (B ^ p)) :
    âˆƒ C, 0 â‰¤ C âˆ§ C â‰¤ A + B âˆ§ HasSum (fun i => (f i + g i) ^ p) (C ^ p) 


Original valid proof:
:= by
  lift f to Î¹ â†’ â„â‰¥0 using hf
  lift g to Î¹ â†’ â„â‰¥0 using hg
  lift A to â„â‰¥0 using hA
  lift B to â„â‰¥0 using hB
  beta_reduce at hfA hgB
  norm_cast at hfA hgB
  obtain âŸ¨C, hCâ‚, hCâ‚‚âŸ© := NNReal.Lp_add_le_hasSum hp hfA hgB
  use C
  beta_reduce
  norm_cast
  exact âŸ¨zero_le _, hCâ‚, hCâ‚‚âŸ©


Verifying proof (Commit aaa40f08731a6680bdee636aa290c8d59c9968c4):
refine theorem_lp_add_le_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSu

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/AddTorsorBases.lean - 2024-09-08 23:47:17.256375.
---45/200---
For theorem IsOpen.exists_between_affineIndependent_span_eq_top in Mathlib/Analysis/NormedSpace/AddTorsorBases.lean:
theorem IsOpen.exists_between_affineIndependent_span_eq_top {s u : Set P} (hu : IsOpen u)
    (hsu : s âŠ† u) (hne : s.Nonempty) (h : AffineIndependent â„ ((â†‘) : s â†’ P)) :
    âˆƒ t : Set P, s âŠ† t âˆ§ t âŠ† u âˆ§ AffineIndependent â„ ((â†‘) : t â†’ P) âˆ§ affineSpan â„ t = âŠ¤ 


Original valid proof:
:= by
  obtain âŸ¨q, hqâŸ© := hne
  obtain âŸ¨Îµ, Îµ0, hÎµuâŸ© := Metric.nhds_basis_closedBall.mem_iff.1 (hu.mem_nhds <| hsu hq)
  obtain âŸ¨t, htâ‚, htâ‚‚, htâ‚ƒâŸ© := exists_subset_affineIndependent_affineSpan_eq_top h
  let f : P â†’ P := fun y => lineMap q y (Îµ / dist y q)
  have hf : âˆ€ y, f y âˆˆ u := by
    refine fun y => hÎµu ?_
    simp only [f]
    rw [Metric.mem_closedBall, lineMap_apply, dist_vadd_left, norm_smul, Real.norm_eq_abs,
      dist_eq_norm_vsub V y q, abs_div, abs_of_pos Îµ0, abs_of_nonneg (norm_nonneg _), div_mul_comm]
    exact mul_le_of_le_one_left Îµ0.le (div_self_le_one _)
  have hÎµyq : âˆ€ y âˆ‰ s, Îµ / dist y q â‰  0 := fun y hy =>
    div_ne_zero Îµ0.ne' (dist_ne_zero.2 (ne_of_mem_of_not_mem hq hy).symm)
  classical
  let w : t â†’ â„Ë£ := fun p => if hp : (p : P) âˆˆ s then 1 else Units.mk0 _ (hÎµyq (â†‘p) hp)
  refine âŸ¨Set.range fun p : t => lineMap q p (w p : â„), ?_, ?_, ?_, ?_âŸ©
  Â· intro p hp; use âŸ¨p, htâ‚ hpâŸ©; simp [w, hp]
  Â· rintro y âŸ¨âŸ¨p, hpâŸ©, rflâŸ©
    by_cases hps : p âˆˆ s <;>
    simp only [w, hps, lineMap_apply_one, Units.val_mk0, dif_neg, dif_pos, not_false_iff,
      Units.val_one, Subtype.coe_mk] <;>
    [exact hsu hps; exact hf p]
  Â· exact (htâ‚‚.units_lineMap âŸ¨q, htâ‚ hqâŸ© w).range
  Â· rw [affineSpan_eq_affineSpan_lineMap_units (htâ‚ hq) w, htâ‚ƒ]


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
rw [affineIndependent_span_exists_between_affineIndependent_span_eq_top]

Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Spectrum.lean - 2024-09-08 23:47:37.522154.
---46/200---
For theorem QuasispectrumRestricts.real_iff in Mathlib/Analysis/NormedSpace/Spectrum.lean:
lemma real_iff [Algebra â„‚ A] {a : A} :
    SpectrumRestricts a Complex.reCLM â†” âˆ€ x âˆˆ spectrum â„‚ a, x = x.re 


Original valid proof:
:= by
  refine âŸ¨fun h x hx â†¦ ?_, fun h â†¦ ?_âŸ©
  Â· obtain âŸ¨x, -, rflâŸ© := h.algebraMap_image.symm â–¸ hx
    simp
  Â· exact .of_subset_range_algebraMap Complex.ofReal_re fun x hx â†¦ âŸ¨x.re, (h x hx).symmâŸ©


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
constructor

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean - 2024-09-08 23:47:58.142692.
---47/200---
For theorem Real.Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma in Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean:
theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : â„} (hs : 0 < s) (ht : 0 < t)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    Gamma (a * s + b * t) â‰¤ Gamma s ^ a * Gamma t ^ b 


Original valid proof:
:= by
  let f : â„ â†’ â„ â†’ â„ â†’ â„ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : âˆ€ c u x : â„, x âˆˆ Ioi (0 : â„) â†’ 0 â‰¤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : âˆ€ c u : â„, âˆ€áµ x : â„ âˆ‚volume.restrict (Ioi 0), 0 â‰¤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    âˆ€ {c x : â„} (_ : 0 < c) (u : â„) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only [f]
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), â† exp_mul, â† rpow_mul hx.le]
    congr 2 <;> field_simp [hc.ne']; ring
  have f_mem_Lp :
    âˆ€ {c u : â„} (hc : 0 < c) (hu : 0 < u),
      Memâ„’p (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) â‰  0 := by
      rwa [Ne, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) â‰  âˆ := ENNReal.ofReal_ne_top
    rw [â† memâ„’p_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memâ„’p_one_iff_integrable]
    Â· apply Integrable.congr (GammaIntegral_convergent hu)
      refine eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => ?_
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    Â· refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
      refine (Continuous.continuousOn ?_).mul (ContinuousAt.continuousOn fun x hx => ?_)
      Â· exact continuous_exp.comp (continuous_const.mul continuous_id')
      Â· exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  Â· refine setIntegral_congr measurableSet_Ioi fun x hx => ?_
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [â† exp_add, â† add_mul, â† neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [â† rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  Â· rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact setIntegral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx


Verifying proof (Commit 3cb2bdef8481160ee4f3f3a94fca1f5824c2798a):
rw [Gamma_mul_add_mul_le_rpow_Gamma_mul_add_mul_le_rpow_Gamma_mul_add_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma
  s t a b hs ht hs ht ht hab, Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma
  s t a b ht ha hb hab, Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow]

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean - 2024-09-08 23:48:18.612706.
---48/200---
For theorem Real.Angle.cos_eq_real_cos_iff_eq_or_eq_neg in Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean:
theorem cos_eq_real_cos_iff_eq_or_eq_neg {Î¸ : Angle} {Ïˆ : â„} :
    cos Î¸ = Real.cos Ïˆ â†” Î¸ = Ïˆ âˆ¨ Î¸ = -Ïˆ 


Original valid proof:
:= by
  induction Î¸ using Real.Angle.induction_on
  exact cos_eq_iff_coe_eq_or_eq_neg


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
simp only [cos_eq_real_cos_iff_eq_or_eq_neg, cos_eq_real_cos_iff_eq_or_eq_neg]

Attempt failure.

Working on Mathlib/Analysis/SpecificLimits/Normed.lean - 2024-09-08 23:48:38.684000.
---49/200---
For theorem tendsto_pow_const_mul_const_pow_of_abs_lt_one in Mathlib/Analysis/SpecificLimits/Normed.lean:
theorem tendsto_pow_const_mul_const_pow_of_abs_lt_one (k : â„•) {r : â„} (hr : |r| < 1) :
    Tendsto (fun n â†¦ (n : â„) ^ k * r ^ n : â„• â†’ â„) atTop (ğ“ 0) 


Original valid proof:
:= by
  by_cases h0 : r = 0
  Â· exact tendsto_const_nhds.congr'
      (mem_atTop_sets.2 âŸ¨1, fun n hn â†¦ by simp [zero_lt_one.trans_le hn |>.ne', h0]âŸ©)
  have hr' : 1 < |r|â»Â¹ := one_lt_inv (abs_pos.2 h0) hr
  rw [tendsto_zero_iff_norm_tendsto_zero]
  simpa [div_eq_mul_inv] using tendsto_pow_const_div_const_pow_of_one_lt k hr'


Verifying proof (Commit e234e64075504db13790aa471a4239039c94703b):
simp only [tendsto_pow_const_mul_const_pow_const_pow_const_pow_const_pow_of_abs_lt_one]

Attempt failure.

Working on Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean - 2024-09-08 23:48:59.357023.
---50/200---
For theorem CategoryTheory.InjectiveResolution.ofCocomplex_exactAt_succ in Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean:
lemma ofCocomplex_exactAt_succ (n : â„•) :
    (ofCocomplex Z).ExactAt (n + 1) 


Original valid proof:
:= by
  rw [HomologicalComplex.exactAt_iff' _ n (n + 1) (n + 1 + 1) (by simp) (by simp)]
  dsimp [ofCocomplex, CochainComplex.mk', CochainComplex.mk, HomologicalComplex.sc',
      HomologicalComplex.shortComplexFunctor']
  simp only [CochainComplex.of_d]
  match n with
  | 0 => apply exact_f_d ((CochainComplex.mkAux _ _ _
      (d (Injective.Î¹ Z)) (d (d (Injective.Î¹ Z))) _ _ 0).f)
  | n+1 => apply exact_f_d ((CochainComplex.mkAux _ _ _
      (d (Injective.Î¹ Z)) (d (d (Injective.Î¹ Z))) _ _ (n+1)).f)


Verifying proof (Commit b80a452d9c16e7a603a862a57bc182178c081175):
rw [exactAt_succ_iff]

Attempt failure.

Working on Mathlib/CategoryTheory/Closed/Functor.lean - 2024-09-08 23:49:13.970079.
---51/200---
For theorem CategoryTheory.expComparison_whiskerLeft in Mathlib/CategoryTheory/Closed/Functor.lean:
theorem expComparison_whiskerLeft {A A' : C} (f : A' âŸ¶ A) :
    expComparison F A â‰« whiskerLeft _ (pre (F.map f)) =
      whiskerRight (pre f) _ â‰« expComparison F A' 


Original valid proof:
:= by
  ext B
  dsimp
  apply uncurry_injective
  rw [uncurry_natural_left, uncurry_natural_left, uncurry_expComparison, uncurry_pre,
    prod.map_swap_assoc, â† F.map_id, expComparison_ev, â† F.map_id, â†
    prodComparison_inv_natural_assoc, â† prodComparison_inv_natural_assoc, â† F.map_comp, â†
    F.map_comp, prod_map_pre_app_comp_ev]


Verifying proof (Commit 565b3377dc3477a9806f4e6db16008ee47fd08ed):
exact expComparison_whiskerLeft_whiskerRight F A' f

Attempt failure.

Working on Mathlib/CategoryTheory/EqToHom.lean - 2024-09-08 23:49:25.267085.
---52/200---
For theorem CategoryTheory.congrArg_cast_hom_left in Mathlib/CategoryTheory/EqToHom.lean:
theorem congrArg_cast_hom_left {X Y Z : C} (p : X = Y) (q : Y âŸ¶ Z) :
    cast (congrArg (fun W : C => W âŸ¶ Z) p.symm) q = eqToHom p â‰« q 


Original valid proof:
:= by
  cases p
  simp


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
simp only [eqToHom_left, eqToHom_refl, eqToHom_refl, eqToHom_refl]

Attempt failure.

Working on Mathlib/CategoryTheory/EssentialImage.lean - 2024-09-08 23:49:29.229539.
---53/200---
For theorem CategoryTheory.Functor.essImage_eq_of_natIso in Mathlib/CategoryTheory/EssentialImage.lean:
theorem essImage_eq_of_natIso {F' : C â¥¤ D} (h : F â‰… F') : essImage F = essImage F' 


Original valid proof:
:=
  funext fun _ => propext âŸ¨essImage.ofNatIso h, essImage.ofNatIso h.symmâŸ©


Verifying proof (Commit ef3c9bcd07782b044027916a64e925f3e4951707):
apply essImage_eq_of_essImage_eq_of_essImage

Attempt failure.

Working on Mathlib/CategoryTheory/GradedObject/Associator.lean - 2024-09-08 23:49:32.744791.
---54/200---
For theorem CategoryTheory.GradedObject.Î¹_mapBifunctorAssociator_inv in Mathlib/CategoryTheory/GradedObject/Associator.lean:
lemma Î¹_mapBifunctorAssociator_inv (iâ‚ : Iâ‚) (iâ‚‚ : Iâ‚‚) (iâ‚ƒ : Iâ‚ƒ) (j : J) (h : r (iâ‚, iâ‚‚, iâ‚ƒ) = j) :
    Î¹MapBifunctorBifunctorâ‚‚â‚ƒMapObj F Gâ‚‚â‚ƒ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ iâ‚ iâ‚‚ iâ‚ƒ j h â‰«
      (mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).inv j =
    ((associator.inv.app (Xâ‚ iâ‚)).app (Xâ‚‚ iâ‚‚)).app (Xâ‚ƒ iâ‚ƒ) â‰«
      Î¹MapBifunctorâ‚â‚‚BifunctorMapObj Fâ‚â‚‚ G Ïâ‚â‚‚ Xâ‚ Xâ‚‚ Xâ‚ƒ iâ‚ iâ‚‚ iâ‚ƒ j h 


Original valid proof:
:= by
  rw [â† cancel_mono ((mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).hom j),
    assoc, assoc, Iso.inv_hom_id_eval, comp_id, Î¹_mapBifunctorAssociator_hom,
    â† NatTrans.comp_app_assoc, â† NatTrans.comp_app, Iso.inv_hom_id_app,
    NatTrans.id_app, NatTrans.id_app, id_comp]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
dsimp [mapBifunctorAssociator]

Attempt failure.

Working on Mathlib/CategoryTheory/Limits/HasLimits.lean - 2024-09-08 23:49:38.378349.
---55/200---
For theorem CategoryTheory.Limits.hasColimitOfIso in Mathlib/CategoryTheory/Limits/HasLimits.lean:
theorem hasColimitOfIso {F G : J â¥¤ C} [HasColimit F] (Î± : G â‰… F) : HasColimit G 


Original valid proof:
:=
  HasColimit.mk
    { cocone := (Cocones.precompose Î±.hom).obj (colimit.cocone F)
      isColimit := (IsColimit.precomposeHomEquiv _ _).symm (colimit.isColimit F) }


Verifying proof (Commit 4e9ad32a390d245132183394a03b349e4f617c33):
haveI : HasColimit F := hasColimitOfIso F G

Attempt failure.

Working on Mathlib/CategoryTheory/MorphismProperty/Basic.lean - 2024-09-08 23:49:49.553446.
---56/200---
For theorem CategoryTheory.MorphismProperty.map_id_eq_isoClosure in Mathlib/CategoryTheory/MorphismProperty/Basic.lean:
lemma map_id_eq_isoClosure (P : MorphismProperty C) :
    P.map (ğŸ­ _) = P.isoClosure 


Original valid proof:
:= by
  apply le_antisymm
  Â· rw [map_le_iff P.isoClosure_respectsIso]
    intro X Y f hf
    exact P.le_isoClosure _ hf
  Â· intro X Y f hf
    exact hf


Verifying proof (Commit 6830b5e612c6f4431fee7e89ec01560ae5118e5e):
simp only [isoClosure, map_id_eq_isoClosure]

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Coverage.lean - 2024-09-08 23:49:54.437316.
---57/200---
For theorem CategoryTheory.Coverage.eq_top_pullback in Mathlib/CategoryTheory/Sites/Coverage.lean:
lemma eq_top_pullback {X Y : C} {S T : Sieve X} (h : S â‰¤ T) (f : Y âŸ¶ X) (hf : S f) :
    T.pullback f = âŠ¤ 


Original valid proof:
:= by
  ext Z g
  simp only [Sieve.pullback_apply, Sieve.top_apply, iff_true]
  apply h
  apply S.downward_closed
  exact hf


Verifying proof (Commit 92beef58f265528359880ded59e9a73d818a6596):
rw [eq_top_pullback]

Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Preserves.lean - 2024-09-08 23:50:02.940924.
---58/200---
For theorem CategoryTheory.Presieve.isSheafFor_of_preservesProduct in Mathlib/CategoryTheory/Sites/Preserves.lean:
theorem isSheafFor_of_preservesProduct [PreservesLimit (Discrete.functor (fun x â†¦ op (X x))) F] :
    (ofArrows X c.inj).IsSheafFor F 


Original valid proof:
:= by
  rw [Equalizer.Presieve.Arrows.sheaf_condition, Limits.Types.type_equalizer_iff_unique]
  have : HasCoproduct X := âŸ¨âŸ¨c, hcâŸ©âŸ©
  have hi : IsIso (piComparison F (fun x â†¦ op (X x))) := inferInstance
  rw [piComparison_fac (hc := hc), isIso_iff_bijective, Function.bijective_iff_existsUnique] at hi
  intro b _
  obtain âŸ¨t, htâ‚, htâ‚‚âŸ© := hi b
  refine âŸ¨F.map ((opCoproductIsoProduct' hc (productIsProduct _)).inv) t, htâ‚, fun y hy â†¦ ?_âŸ©
  apply_fun F.map ((opCoproductIsoProduct' hc (productIsProduct _)).hom) using injective_of_mono _
  simp only [â† FunctorToTypes.map_comp_apply, Iso.op, Category.assoc]
  rw [htâ‚‚ (F.map ((opCoproductIsoProduct' hc (productIsProduct _)).hom) y) (by simp [â† hy])]
  change (ğŸ™ (F.obj (âˆá¶œ fun x â†¦ op (X x)))) t = _
  rw [â† Functor.map_id]
  refine congrFun ?_ t
  congr
  simp [Iso.eq_inv_comp, â† Category.assoc, â† op_comp, eq_comm, â† Iso.eq_comp_inv]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
apply isSheafFor_of_preservesProduct

Attempt failure.

Working on Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean - 2024-09-08 23:50:08.791421.
---59/200---
For theorem CategoryTheory.Pretriangulated.exists_iso_of_arrow_iso in Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean:
lemma exists_iso_of_arrow_iso (Tâ‚ Tâ‚‚ : Triangle C) (hTâ‚ : Tâ‚ âˆˆ distTriang C)
    (hTâ‚‚ : Tâ‚‚ âˆˆ distTriang C) (e : Arrow.mk Tâ‚.morâ‚ â‰… Arrow.mk Tâ‚‚.morâ‚) :
    âˆƒ (e' : Tâ‚ â‰… Tâ‚‚), e'.hom.homâ‚ = e.hom.left âˆ§ e'.hom.homâ‚‚ = e.hom.right 


Original valid proof:
:= by
  let Ï† := completeDistinguishedTriangleMorphism Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ e.hom.left e.hom.right e.hom.w.symm
  have : IsIso Ï†.homâ‚ := by dsimp [Ï†]; infer_instance
  have : IsIso Ï†.homâ‚‚ := by dsimp [Ï†]; infer_instance
  have : IsIso Ï†.homâ‚ƒ := isIsoâ‚ƒ_of_isIsoâ‚â‚‚ Ï† hTâ‚ hTâ‚‚ inferInstance inferInstance
  have : IsIso Ï† := by
    apply Triangle.isIso_of_isIsos
    all_goals infer_instance
  exact âŸ¨asIso Ï†, by simp [Ï†], by simp [Ï†]âŸ©


Verifying proof (Commit afe025caf56711b57f2f34e9ae25ec16a609156d):
have âŸ¨eâ‚, hTâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ©)âŸ©

Attempt failure.

Working on Mathlib/Combinatorics/Additive/FreimanHom.lean - 2024-09-08 23:50:21.194420.
---60/200---
For theorem IsMulFreimanIso.prod in Mathlib/Combinatorics/Additive/FreimanHom.lean:
lemma IsMulFreimanIso.prod (hâ‚ : IsMulFreimanIso n Aâ‚ Bâ‚ fâ‚) (hâ‚‚ : IsMulFreimanIso n Aâ‚‚ Bâ‚‚ fâ‚‚) :
    IsMulFreimanIso n (Aâ‚ Ã—Ë¢ Aâ‚‚) (Bâ‚ Ã—Ë¢ Bâ‚‚) (Prod.map fâ‚ fâ‚‚) where



Original valid proof:
  bijOn := hâ‚.bijOn.prodMap hâ‚‚.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [mem_prod, forall_and, Prod.forall] at hsA htA
    simp only [Prod.ext_iff, fst_prod, map_map, Function.comp_apply, Prod.map_fst, snd_prod,
      Prod.map_snd]
    rw [â† Function.comp_def, â† map_map, â† map_map, â† Function.comp_def fâ‚‚, â† map_map, â† map_map,
      hâ‚.map_prod_eq_map_prod (by simpa using hsA.1) (by simpa using htA.1) (by simpa) (by simpa),
      hâ‚‚.map_prod_eq_map_prod (by simpa [@forall_swap Î±â‚] using hsA.2)
      (by simpa [@forall_swap Î±â‚] using htA.2) (by simpa) (by simpa)]


Verifying proof (Commit 754ba19de1471fd928c4fa0cc102d1f06f90e902):
simp only [IsMulFreimanIso.prod, IsMulFreimanIso.prod, IsMulFreimanIso.hprod,
  IsMulFreimanIso.hprod]

Attempt failure.

Working on Mathlib/Combinatorics/HalesJewett.lean - 2024-09-08 23:50:29.880344.
---61/200---
For theorem Combinatorics.Line.exists_mono_in_high_dimension in Mathlib/Combinatorics/HalesJewett.lean:
theorem exists_mono_in_high_dimension' :
    âˆ€ (Î± : Type u) [Finite Î±] (Îº : Type max v u) [Finite Îº],
      âˆƒ (Î¹ : Type) (_ : Fintype Î¹), âˆ€ C : (Î¹ â†’ Î±) â†’ Îº, âˆƒ l : Line Î± Î¹, l.IsMono C 


Original valid proof:
:=
  Finite.induction_empty_option
  (
  fun {Î± Î±'} e =>
    forall_imp fun Îº =>
      forall_imp fun _ =>
        Exists.imp fun Î¹ =>
          Exists.imp fun _ h C =>
            let âŸ¨l, c, lcâŸ© := h fun v => C (e âˆ˜ v)
            âŸ¨l.map e, c, e.forall_congr_right.mp fun x => by rw [â† lc x, Line.map_apply]âŸ©)
  (by
    intro Îº _
    by_cases h : Nonempty Îº
    Â· refine âŸ¨Unit, inferInstance, fun C => âŸ¨default, Classical.arbitrary _, PEmpty.recâŸ©âŸ©
    Â· exact âŸ¨Empty, inferInstance, fun C => (h âŸ¨C (Empty.rec)âŸ©).elimâŸ©)
  (by
    intro Î± _ ihÎ± Îº _
    cases nonempty_fintype Îº
    by_cases h : Nonempty Î±
    case neg =>
      refine âŸ¨Unit, inferInstance, fun C => âŸ¨diagonal _ Unit, C fun _ => none, ?_âŸ©âŸ©
      rintro (_ | âŸ¨aâŸ©)
      Â· rfl
      Â· exact (h âŸ¨aâŸ©).elim
    suffices key :
      âˆ€ r : â„•,
        âˆƒ (Î¹ : Type) (_ : Fintype Î¹),
          âˆ€ C : (Î¹ â†’ Option Î±) â†’ Îº,
            (âˆƒ s : ColorFocused C, Multiset.card s.lines = r) âˆ¨ âˆƒ l, IsMono C l by
      obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := key (Fintype.card Îº + 1)
      refine âŸ¨Î¹, _inst, fun C => (hÎ¹ C).resolve_left ?_âŸ©
      rintro âŸ¨s, srâŸ©
      apply Nat.not_succ_le_self (Fintype.card Îº)
      rw [â† Nat.add_one, â† sr, â† Multiset.card_map, â† Finset.card_mk]
      exact Finset.card_le_univ âŸ¨_, s.distinct_colorsâŸ©
    intro r
    induction' r with r ihr
    Â· exact âŸ¨Empty, inferInstance, fun C => Or.inl âŸ¨default, Multiset.card_zeroâŸ©âŸ©
    obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := ihr
    specialize ihÎ± ((Î¹ â†’ Option Î±) â†’ Îº)
    obtain âŸ¨Î¹', _inst, hÎ¹'âŸ© := ihÎ±
    refine âŸ¨Sum Î¹ Î¹', inferInstance, ?_âŸ©
    intro C
    specialize hÎ¹' fun v' v => C (Sum.elim v (some âˆ˜ v'))
    obtain âŸ¨l', C', hl'âŸ© := hÎ¹'
    have mono_of_mono : (âˆƒ l, IsMono C' l) â†’ âˆƒ l, IsMono C l := by
      rintro âŸ¨l, c, hlâŸ©
      refine âŸ¨l.horizontal (some âˆ˜ l' (Classical.arbitrary Î±)), c, fun x => ?_âŸ©
      rw [Line.horizontal_apply, â† hl, â† hl']
    specialize hÎ¹ C'
    rcases hÎ¹ with (âŸ¨s, srâŸ© | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : âˆƒ p âˆˆ s.lines, (p : AlmostMono _).color = C' s.focus
    Â· obtain âŸ¨p, p_mem, hpâŸ© := h
      refine Or.inr (mono_of_mono âŸ¨p.line, p.color, ?_âŸ©)
      rintro (_ | _)
      Â· rw [hp, s.is_focused p p_mem]
      Â· apply p.has_color
    refine Or.inl âŸ¨âŸ¨(s.lines.map ?_).cons âŸ¨(l'.map some).vertical s.focus, C' s.focus, fun x => ?_âŸ©,
            Sum.elim s.focus (l'.map some none), ?_, ?_âŸ©, ?_âŸ©
    Â· refine fun p => âŸ¨p.line.prod (l'.map some), p.color, fun x => ?_âŸ©
      rw [Line.prod_apply, Line.map_apply, â† p.has_color, â† congr_fun (hl' x)]
    Â· rw [vertical_apply, â† congr_fun (hl' x), Line.map_apply]
    Â· simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | âŸ¨q, hq, rflâŸ©)
      Â· simp only [vertical_apply]
      Â· simp only [prod_apply, s.is_focused q hq]
    Â· rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact âŸ¨fun âŸ¨q, hq, heâŸ© => h âŸ¨q, hq, heâŸ©, s.distinct_colorsâŸ©
    Â· rw [Multiset.card_cons, Multiset.card_map, sr])


Verifying proof (Commit 65f7857d510e130142dbb111786341d695ac399b):
cases' exists_mono_in_high_dimension' with Î± hÎ±

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/LYM.lean - 2024-09-08 23:50:34.291070.
---62/200---
For theorem Finset.card_div_choose_le_card_shadow_div_choose in Mathlib/Combinatorics/SetFamily/LYM.lean:
theorem card_div_choose_le_card_shadow_div_choose (hr : r â‰  0)
    (hğ’œ : (ğ’œ : Set (Finset Î±)).Sized r) : (ğ’œ.card : ğ•œ) / (Fintype.card Î±).choose r
    â‰¤ (âˆ‚ ğ’œ).card / (Fintype.card Î±).choose (r - 1) 


Original valid proof:
:= by
  obtain hr' | hr' := lt_or_le (Fintype.card Î±) r
  Â· rw [choose_eq_zero_of_lt hr', cast_zero, div_zero]
    exact div_nonneg (cast_nonneg _) (cast_nonneg _)
  replace hğ’œ := card_mul_le_card_shadow_mul hğ’œ
  rw [div_le_div_iff] <;> norm_cast
  Â· cases' r with r
    Â· exact (hr rfl).elim
    rw [tsub_add_eq_add_tsub hr', add_tsub_add_eq_tsub_right] at hğ’œ
    apply le_of_mul_le_mul_right _ (pos_iff_ne_zero.2 hr)
    convert Nat.mul_le_mul_right ((Fintype.card Î±).choose r) hğ’œ using 1
    Â· simp [mul_assoc, Nat.choose_succ_right_eq]
      exact Or.inl (mul_comm _ _)
    Â· simp only [mul_assoc, choose_succ_right_eq, mul_eq_mul_left_iff]
      exact Or.inl (mul_comm _ _)
  Â· exact Nat.choose_pos hr'
  Â· exact Nat.choose_pos (r.pred_le.trans hr')


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
refine le_trans ?_ (choose_le_choose_le_choose_le_choose hr hğ’œ hğ’œ hr)

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean - 2024-09-08 23:50:46.051202.
---63/200---
For theorem SimpleGraph.adjMatrix_mul_self_apply_self in Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean:
theorem adjMatrix_mul_self_apply_self [NonAssocSemiring Î±] (i : V) :
    (G.adjMatrix Î± * G.adjMatrix Î±) i i = degree G i 


Original valid proof:
:= by simp [filter_true_of_mem]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
rw [degree_eq_degree adjMatrix_mul_self_apply_self]

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Coloring.lean - 2024-09-08 23:50:56.869774.
---64/200---
For theorem SimpleGraph.chromaticNumber_pos in Mathlib/Combinatorics/SimpleGraph/Coloring.lean:
theorem chromaticNumber_pos [Nonempty V] {n : â„•} (hc : G.Colorable n) : 0 < G.chromaticNumber 


Original valid proof:
:= by
  rw [hc.chromaticNumber_eq_sInf, Nat.cast_pos]
  apply le_csInf (colorable_set_nonempty_of_colorable hc)
  intro m hm
  by_contra h'
  simp only [not_le] at h'
  obtain âŸ¨i, hiâŸ© := hm.some (Classical.arbitrary V)
  have hâ‚: i < 0 := lt_of_lt_of_le hi (Nat.le_of_lt_succ h')
  exact Nat.not_lt_zero _ hâ‚


Verifying proof (Commit a645d903a5e02e8cbb9215f6195147610bf99954):
apply G.chromaticNumber_le_chromaticNumber

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Operations.lean - 2024-09-08 23:51:04.689037.
---65/200---
For theorem SimpleGraph.adj_replaceVertex_iff_of_ne in Mathlib/Combinatorics/SimpleGraph/Operations.lean:
lemma adj_replaceVertex_iff_of_ne_left {w : V} (hw : w â‰  t) :
    (G.replaceVertex s t).Adj s w â†” G.Adj s w 


Original valid proof:
:= by simp [replaceVertex, hw]


Verifying proof (Commit f61a485edf966de0b09bd70c1edc7f254cd1b0ae):
simp only [replaceVertex_adj, replaceVertex_adj, adj_replaceVertex_iff_of_ne_left]

Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean - 2024-09-08 23:51:11.121125.
---66/200---
For theorem Finpartition.equitabilise_aux in Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean:
theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    âˆƒ Q : Finpartition s,
      (âˆ€ x : Finset Î±, x âˆˆ Q.parts â†’ x.card = m âˆ¨ x.card = m + 1) âˆ§
        (âˆ€ x, x âˆˆ P.parts â†’ (x \ (Q.parts.filter fun y => y âŠ† x).biUnion id).card â‰¤ m) âˆ§
          (Q.parts.filter fun i => card i = m + 1).card = b 


Original valid proof:
:= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  Â· refine âŸ¨âŠ¥, by simp, ?_, by simpa [Finset.filter_true_of_mem] using hs.symmâŸ©
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      âŸ¨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _âŸ©
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 âˆ§ b = 0
  Â· simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (Î± := Finpartition âŠ¥) P
    exact âŸ¨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]âŸ©
  simp_rw [not_and_or, â† Ne.eq_def, â† pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain âŸ¨hnâ‚€, hnâ‚, hnâ‚‚, hnâ‚ƒâŸ© : 0 < n âˆ§ n â‰¤ m + 1 âˆ§ n â‰¤ a * m + b * (m + 1) âˆ§
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, â† hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    Â· refine âŸ¨m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ â€¹0 < aâ€º), ?_âŸ©
      rw [tsub_add_eq_add_tsub (Nat.le_mul_of_pos_left _ h)]
    Â· refine âŸ¨succ_pos', le_rfl,
        le_add_left (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º), ?_âŸ©
      rw [â† add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º)]
  by_cases h : âˆ€ u âˆˆ P.parts, card u < m + 1
  Â· obtain âŸ¨t, hts, htnâŸ© := exists_subset_card_eq (hnâ‚‚.trans_eq hs)
    have ht : t.Nonempty := by rwa [â† card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff â€¹t âŠ† sâ€º, htn, hnâ‚ƒ]
    obtain âŸ¨R, hRâ‚, _, hRâ‚ƒâŸ© :=
      @ih (s \ t) (sdiff_ssubset hts â€¹t.Nonemptyâ€º) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), ?_, ?_, ?_âŸ©
    Â· simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => (card_le_card sdiff_subset).trans (Nat.lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    Â· rw [hRâ‚ƒ, if_pos ha]
    rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg ha, tsub_add_cancel_of_le]
    Â· exact hab.resolve_left ha
    Â· intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg at h
  obtain âŸ¨u, huâ‚, huâ‚‚âŸ© := h
  obtain âŸ¨t, htu, htnâŸ© := exists_subset_card_eq (hnâ‚.trans huâ‚‚)
  have ht : t.Nonempty := by rwa [â† card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le huâ‚), htn, hnâ‚ƒ]
  obtain âŸ¨R, hRâ‚, hRâ‚‚, hRâ‚ƒâŸ© :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le huâ‚) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine
    âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le huâ‚), ?_, ?_, ?_âŸ©
  Â· simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hRâ‚, htn, hn]
    exact ite_eq_or_eq _ _ _
  Â· conv in _ âˆˆ _ => rw [â† insert_erase huâ‚]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne, extend_parts]
    refine âŸ¨?_, fun x hx => (card_le_card ?_).trans <| hRâ‚‚ x ?_âŸ©
    Â· simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id]
      obtain rfl | hut := eq_or_ne u t
      Â· rw [sdiff_eq_empty_iff_subset.2 subset_union_left]
        exact bot_le
      refine
        (card_le_card fun i => ?_).trans
          (hRâ‚‚ (u \ t) <| P.mem_avoid.2 âŸ¨u, huâ‚, fun i => hut <| i.antisymm htu, rflâŸ©)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id, not_or]
      exact fun hiâ‚ hiâ‚‚ hiâ‚ƒ =>
        âŸ¨âŸ¨hiâ‚, hiâ‚‚âŸ©, fun x hx hx' => hiâ‚ƒ _ hx <| hx'.trans sdiff_subsetâŸ©
    Â· apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      âŸ¨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) huâ‚ <| ne_of_mem_erase hx).sdiff_eq_leftâŸ©
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  Â· rw [hRâ‚ƒ, if_pos h]
  Â· rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)


Verifying proof (Commit 05c4c02a126a220762b13df794c36c771e2fbb7d):
refine âŸ¨Q, equitabilise_aux, equitabilise_aux, equitabilise_aux, hs, ?_âŸ©

Attempt failure.

Working on Mathlib/Computability/PartrecCode.lean - 2024-09-08 23:51:15.824891.
---67/200---
For theorem Nat.Partrec.Code.pair_prim in Mathlib/Computability/PartrecCode.lean:
theorem pair_prim : Primrecâ‚‚ pair 


Original valid proof:
:=
  Primrecâ‚‚.ofNat_iff.2 <|
    Primrecâ‚‚.encode_iff.1 <|
      nat_add.comp
        (nat_double.comp <|
          nat_double.comp <|
            Primrecâ‚‚.natPair.comp (encode_iff.2 <| (Primrec.ofNat Code).comp fst)
              (encode_iff.2 <| (Primrec.ofNat Code).comp snd))
        (Primrecâ‚‚.const 4)


Verifying proof (Commit 6085d5e27552de2d43997b4a52a8d9fcd4686071):
heorem pair_prim := pair_prim

Attempt failure.

---68/200---
For theorem Nat.Partrec.Code.evaln_prim in Mathlib/Computability/PartrecCode.lean:
theorem evaln_prim : Primrec fun a : (â„• Ã— Code) Ã— â„• => evaln a.1.1 a.1.2 a.2 


Original valid proof:
:=
  have :
    Primrecâ‚‚ fun (_ : Unit) (n : â„•) =>
      let a := ofNat (â„• Ã— Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).toâ‚‚ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr_left fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      Â· simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, Nat.lt_succ_iff] at nk
      have hg :
        âˆ€ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) â†’
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro kâ‚ câ‚ nâ‚ hl
        simp [lup, List.getElem?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      Â· cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        Â· rfl
        cases evaln k cg n <;> rfl
      Â· cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        Â· rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      Â· cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        Â· rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        Â· rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      Â· have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        Â· rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.toâ‚‚).of_eq
    fun âŸ¨âŸ¨k, câŸ©, nâŸ© => by simp [evaln_map]


Verifying proof (Commit ad88a031b67d9f51d39379f0e5f82a31c1929202):
simp [evaln, evaln_prim]

Attempt failure.

Working on Mathlib/Data/Complex/Basic.lean - 2024-09-08 23:51:42.729494.
---69/200---
For theorem Complex.re_eq_add_conj in Mathlib/Data/Complex/Basic.lean:
theorem re_eq_add_conj (z : â„‚) : (z.re : â„‚) = (z + conj z) / 2 


Original valid proof:
:= by
  simp only [add_conj, ofReal_mul, ofReal_ofNat, mul_div_cancel_leftâ‚€ (z.re : â„‚) two_ne_zero]


Verifying proof (Commit 151eb46ac9da80421706d0822fba0ae70d6ae557):
simp [theorem_re_eq_add_conj]

Attempt failure.

Working on Mathlib/Data/Fin/Basic.lean - 2024-09-08 23:51:50.804652.
---70/200---
For theorem Fin.castSucc_ne_zero_of_lt in Mathlib/Data/Fin/Basic.lean:
theorem castSucc_ne_zero_of_lt {p i : Fin n} (h : p < i) : castSucc i â‰  0 


Original valid proof:
:= by
  cases n
  Â· exact i.elim0
  Â· rw [castSucc_ne_zero_iff', Ne, ext_iff]
    exact ((zero_le _).trans_lt h).ne'


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
rw [castSucc_ne_zero_of_lt]

Attempt failure.

---71/200---
For theorem Fin.one_lt_last in Mathlib/Data/Fin/Basic.lean:
theorem one_lt_last [NeZero n] : 1 < last (n + 1) 


Original valid proof:
:= by
  rw [lt_iff_val_lt_val, val_one, val_last, Nat.lt_add_left_iff_pos, Nat.pos_iff_ne_zero]
  exact NeZero.ne n


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
apply lt_of_le_of_lt (NeZero.ne n)

Attempt failure.

Working on Mathlib/Data/Fin/VecNotation.lean - 2024-09-08 23:52:03.889333.
---72/200---
For theorem Matrix.vecAlt0_vecAppend in Mathlib/Data/Fin/VecNotation.lean:
theorem vecAlt0_vecAppend (v : Fin n â†’ Î±) : vecAlt0 rfl (vecAppend rfl v v) = v âˆ˜ bit0 


Original valid proof:
:= by
  ext i
  simp_rw [Function.comp, bit0, vecAlt0, vecAppend_eq_ite]
  split_ifs with h <;> congr
  Â· rw [Fin.val_mk] at h
    exact (Nat.mod_eq_of_lt h).symm
  Â· rw [Fin.val_mk, not_lt] at h
    simp only [Fin.ext_iff, Fin.val_add, Fin.val_mk, Nat.mod_eq_sub_mod h]
    refine (Nat.mod_eq_of_lt ?_).symm
    omega


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
rw [vecAlt0_vecAppend, vecAlt0_vecAppend]

Attempt failure.

Working on Mathlib/Data/Finsupp/Defs.lean - 2024-09-08 23:52:09.153561.
---73/200---
For theorem Finsupp.single_eq_zero in Mathlib/Data/Finsupp/Defs.lean:
theorem single_eq_zero : single a b = 0 â†” b = 0 


Original valid proof:
:= by
  simp [DFunLike.ext_iff, single_eq_set_indicator]


Verifying proof (Commit 67e80fd089fe45abea632652c43b78eba72d60e3):
rw [single_eq_zero_iff] at single_eq_zero

Attempt failure.

Working on Mathlib/Data/Int/Cast/Lemmas.lean - 2024-09-08 23:52:16.340130.
---74/200---
For theorem RingHom.ext_int in Mathlib/Data/Int/Cast/Lemmas.lean:
theorem ext_int [AddMonoid A] {f g : â„¤ â†’+ A} (h1 : f 1 = g 1) : f = g 


Original valid proof:
:=
  have : f.comp (Int.ofNatHom : â„• â†’+ â„¤) = g.comp (Int.ofNatHom : â„• â†’+ â„¤) := ext_nat' _ _ h1
  have this' : âˆ€ n : â„•, f n = g n := DFunLike.ext_iff.1 this
  ext fun n => match n with
  | (n : â„•) => this' n
  | .negSucc n => eq_on_neg _ _ (this' <| n + 1)


Verifying proof (Commit 93812b0faaaed21290db2b79c325e1dbaecd4dce):
simp [f, g, h1]

Attempt failure.

Working on Mathlib/Data/Int/GCD.lean - 2024-09-08 23:52:20.958505.
---75/200---
For theorem Nat.gcdA_zero_right in Mathlib/Data/Int/GCD.lean:
theorem gcdA_zero_right {s : â„•} (h : s â‰  0) : gcdA s 0 = 1 


Original valid proof:
:= by
  unfold gcdA xgcd
  obtain âŸ¨s, rflâŸ© := Nat.exists_eq_succ_of_ne_zero h
  rw [xgcdAux]
  simp


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
simp [gcdA_zero_right]

Attempt failure.

Working on Mathlib/Data/List/OfFn.lean - 2024-09-08 23:52:25.920868.
---76/200---
For theorem List.ofFn_succ in Mathlib/Data/List/OfFn.lean:
theorem ofFn_succ {n} (f : Fin (succ n) â†’ Î±) : ofFn f = f 0 :: ofFn fun i => f i.succ 


Original valid proof:
:=
  ext_get (by simp) (fun i hiâ‚ hiâ‚‚ => by
    cases i
    Â· simp
    Â· simp)


Verifying proof (Commit 66caaeed4dccada03ce195a3f9db1c0009ee8118):
rw [ofFn_succ, ofFn_succ]

Attempt failure.

Working on Mathlib/Data/List/ReduceOption.lean - 2024-09-08 23:52:30.213876.
---77/200---
For theorem List.reduceOption_length_eq_iff in Mathlib/Data/List/ReduceOption.lean:
theorem reduceOption_length_eq_iff {l : List (Option Î±)} :
    l.reduceOption.length = l.length â†” âˆ€ x âˆˆ l, Option.isSome x 


Original valid proof:
:= by
  rw [reduceOption_length_eq, List.filter_length_eq_length]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
simp only [reduceOption_length_eq_iff]

Attempt failure.

Working on Mathlib/Data/Multiset/Basic.lean - 2024-09-08 23:52:33.636185.
---78/200---
For theorem Multiset.count_map_eq_count in Mathlib/Data/Multiset/Basic.lean:
theorem count_map_eq_count [DecidableEq Î²] (f : Î± â†’ Î²) (s : Multiset Î±)
    (hf : Set.InjOn f { x : Î± | x âˆˆ s }) (x) (H : x âˆˆ s) : (s.map f).count (f x) = s.count x 


Original valid proof:
:= by
  suffices (filter (fun a : Î± => f x = f a) s).count x = card (filter (fun a : Î± => f x = f a) s) by
    rw [count, countP_map, â† this]
    exact count_filter_of_pos <| rfl
  Â· rw [eq_replicate_card.2 fun b hb => (hf H (mem_filter.1 hb).left _).symm]
    Â· simp only [count_replicate, eq_self_iff_true, if_true, card_replicate]
    Â· simp only [mem_filter, beq_iff_eq, and_imp, @eq_comm _ (f x), imp_self, implies_true]


Verifying proof (Commit e609eeb4638d90bf8185c6ea72c5d41e94387a3b):
rw [count_map_eq_count, count_map_eq_count]

Attempt failure.

Working on Mathlib/Data/Nat/Pairing.lean - 2024-09-08 23:52:44.865050.
---79/200---
For theorem Nat.pair_lt_max_add_one_sq in Mathlib/Data/Nat/Pairing.lean:
theorem pair_lt_max_add_one_sq (m n : â„•) : pair m n < (max m n + 1) ^ 2 


Original valid proof:
:= by
  simp only [pair, Nat.pow_two, Nat.mul_add, Nat.add_mul, Nat.mul_one, Nat.one_mul, Nat.add_assoc]
  split_ifs <;> simp [Nat.max_eq_left, Nat.max_eq_right, Nat.le_of_lt,  not_lt.1, *] <;> omega


Verifying proof (Commit e340032faef5a8ec252e988e6968b4f6b30277da):
rw [pair_lt_max_add_one_sq, pair_lt_max_add_one_sq]

Attempt failure.

Working on Mathlib/Data/Seq/Parallel.lean - 2024-09-08 23:52:48.984333.
---80/200---
For theorem Computation.exists_of_mem_parallel in Mathlib/Data/Seq/Parallel.lean:
theorem exists_of_mem_parallel {S : WSeq (Computation Î±)} {a} (h : a âˆˆ parallel S) :
    âˆƒ c âˆˆ S, a âˆˆ c 


Original valid proof:
:= by
  suffices
    âˆ€ C, a âˆˆ C â†’ âˆ€ (l : List (Computation Î±)) (S),
      corec parallel.aux1 (l, S) = C â†’ âˆƒ c, (c âˆˆ l âˆ¨ c âˆˆ S) âˆ§ a âˆˆ c from
    let âŸ¨c, h1, h2âŸ© := this _ h [] S rfl
    âŸ¨c, h1.resolve_left <| List.not_mem_nil _, h2âŸ©
  let F : List (Computation Î±) â†’ Sum Î± (List (Computation Î±)) â†’ Prop := by
    intro l a
    cases' a with a l'
    Â· exact âˆƒ c âˆˆ l, a âˆˆ c
    Â· exact âˆ€ a', (âˆƒ c âˆˆ l', a' âˆˆ c) â†’ âˆƒ c âˆˆ l, a' âˆˆ c
  have lem1 : âˆ€ l : List (Computation Î±), F l (parallel.aux2 l) := by
    intro l
    induction' l with c l IH <;> simp only [parallel.aux2, List.foldr]
    Â· intro a h
      rcases h with âŸ¨c, hn, _âŸ©
      exact False.elim <| List.not_mem_nil _ hn
    Â· simp only [parallel.aux2] at IH
      revert IH
      cases' List.foldr (fun c o =>
        match o with
        | Sum.inl a => Sum.inl a
        | Sum.inr ls => rmap (fun c' => c' :: ls) (destruct c)) (Sum.inr List.nil) l with a ls <;>
        intro IH <;>
        simp only [parallel.aux2]
      Â· rcases IH with âŸ¨c', cl, acâŸ©
        exact âŸ¨c', List.Mem.tail _ cl, acâŸ©
      Â· induction' h : destruct c with a c' <;> simp only [rmap]
        Â· refine âŸ¨c, List.mem_cons_self _ _, ?_âŸ©
          rw [destruct_eq_pure h]
          apply ret_mem
        Â· intro a' h
          rcases h with âŸ¨d, dm, adâŸ©
          simp? at dm says simp only [List.mem_cons] at dm
          cases' dm with e dl
          Â· rw [e] at ad
            refine âŸ¨c, List.mem_cons_self _ _, ?_âŸ©
            rw [destruct_eq_think h]
            exact think_mem ad
          Â· cases' IH a' âŸ¨d, dl, adâŸ© with d dm
            cases' dm with dm ad
            exact âŸ¨d, List.Mem.tail _ dm, adâŸ©
  intro C aC
  apply memRecOn aC <;> [skip; intro C' IH] <;> intro l S e <;> have e' := congr_arg destruct e <;>
    have := lem1 l <;> simp only [parallel.aux1, corec_eq, destruct_pure, destruct_think] at e' <;>
    revert this e' <;> cases' parallel.aux2 l with a' l' <;> intro this e' <;>
    [injection e' with h'; injection e'; injection e'; injection e' with h']
  Â· rw [h'] at this
    rcases this with âŸ¨c, cl, acâŸ©
    exact âŸ¨c, Or.inl cl, acâŸ©
  Â· induction' e : Seq.destruct S with a <;> rw [e] at h'
    Â· exact
        let âŸ¨d, o, adâŸ© := IH _ _ h'
        let âŸ¨c, cl, acâŸ© := this a âŸ¨d, o.resolve_right (WSeq.not_mem_nil _), adâŸ©
        âŸ¨c, Or.inl cl, acâŸ©
    Â· cases' a with o S'
      cases' o with c <;> simp [parallel.aux1] at h' <;> rcases IH _ _ h' with âŸ¨d, dl | dS', adâŸ©
      Â· exact
          let âŸ¨c, cl, acâŸ© := this a âŸ¨d, dl, adâŸ©
          âŸ¨c, Or.inl cl, acâŸ©
      Â· refine âŸ¨d, Or.inr ?_, adâŸ©
        rw [Seq.destruct_eq_cons e]
        exact Seq.mem_cons_of_mem _ dS'
      Â· simp at dl
        cases' dl with dc dl
        Â· rw [dc] at ad
          refine âŸ¨c, Or.inr ?_, adâŸ©
          rw [Seq.destruct_eq_cons e]
          apply Seq.mem_cons
        Â· exact
            let âŸ¨c, cl, acâŸ© := this a âŸ¨d, dl, adâŸ©
            âŸ¨c, Or.inl cl, acâŸ©
      Â· refine âŸ¨d, Or.inr ?_, adâŸ©
        rw [Seq.destruct_eq_cons e]
        exact Seq.mem_cons_of_mem _ dS'


Verifying proof (Commit 3c930599229893e1b6a931304cf4efff4a01b172):
induction' h : parallel S using parallel S

Attempt failure.

Working on Mathlib/Data/Set/Basic.lean - 2024-09-08 23:52:57.601280.
---81/200---
For theorem Set.inter_subset_ite in Mathlib/Data/Set/Basic.lean:
theorem inter_subset_ite (t s s' : Set Î±) : s âˆ© s' âŠ† t.ite s s' 


Original valid proof:
:=
  ite_same t (s âˆ© s') â–¸ ite_mono _ inter_subset_left inter_subset_right


Verifying proof (Commit 70dcc1355b9ce0a6754f8d809c95a171072d3aac):
refine Set.Subset.theorem_ite_of_subset_ite_subset t s' ?_

Attempt failure.

Working on Mathlib/Data/Set/Subset.lean - 2024-09-08 23:53:06.662487.
---82/200---
For theorem Set.image_val_iInter in Mathlib/Data/Set/Subset.lean:
lemma image_val_iInter [Nonempty Î¹] : (â†‘(â‹‚ i, t i) : Set Î±) = â‹‚ i, (â†‘(t i) : Set Î±) 


Original valid proof:
:=
  Subtype.val_injective.injOn.image_iInter_eq


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
simp [Set.iInter_eq_iInter, Set.iInter_eq_iInter]

Attempt failure.

Working on Mathlib/Dynamics/Ergodic/Conservative.lean - 2024-09-08 23:53:10.897236.
---83/200---
For theorem MeasureTheory.Conservative.frequently_measure_inter_ne_zero in Mathlib/Dynamics/Ergodic/Conservative.lean:
theorem frequently_measure_inter_ne_zero (hf : Conservative f Î¼) (hs : MeasurableSet s)
    (h0 : Î¼ s â‰  0) : âˆƒá¶  m in atTop, Î¼ (s âˆ© f^[m] â»Â¹' s) â‰  0 


Original valid proof:
:= by
  by_contra H
  simp only [not_frequently, eventually_atTop, Ne, Classical.not_not] at H
  rcases H with âŸ¨N, hNâŸ©
  induction' N with N ihN
  Â· apply h0
    simpa using hN 0 le_rfl
  rw [imp_false] at ihN
  push_neg at ihN
  rcases ihN with âŸ¨n, hn, hÎ¼nâŸ©
  set T := s âˆ© â‹ƒ n â‰¥ N + 1, f^[n] â»Â¹' s
  have hT : MeasurableSet T :=
    hs.inter (MeasurableSet.biUnion (to_countable _) fun _ _ => hf.measurable.iterate _ hs)
  have hÎ¼T : Î¼ T = 0 := by
    convert (measure_biUnion_null_iff <| to_countable _).2 hN
    rw [â† inter_iUnionâ‚‚]
    rfl
  have : Î¼ ((s âˆ© f^[n] â»Â¹' s) \ T) â‰  0 := by rwa [measure_diff_null hÎ¼T]
  rcases hf.exists_mem_iterate_mem ((hs.inter (hf.measurable.iterate n hs)).diff hT) this with
    âŸ¨x, âŸ¨âŸ¨hxs, _âŸ©, hxTâŸ©, m, hm0, âŸ¨_, hxmâŸ©, _âŸ©
  refine hxT âŸ¨hxs, mem_iUnionâ‚‚.2 âŸ¨n + m, ?_, ?_âŸ©âŸ©
  Â· exact add_le_add hn (Nat.one_le_of_lt <| pos_iff_ne_zero.2 hm0)
  Â· rwa [Set.mem_preimage, â† iterate_add_apply] at hxm


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
rw [frequently_measure_inter_ne_zero]

Attempt failure.

Working on Mathlib/Dynamics/OmegaLimit.lean - 2024-09-08 23:53:31.417740.
---84/200---
For theorem nonempty_omegaLimit_of_isCompact_absorbing in Mathlib/Dynamics/OmegaLimit.lean:
theorem nonempty_omegaLimit_of_isCompact_absorbing [NeBot f] {c : Set Î²} (hcâ‚ : IsCompact c)
    (hcâ‚‚ : âˆƒ v âˆˆ f, closure (image2 Ï• v s) âŠ† c) (hs : s.Nonempty) : (Ï‰ f Ï• s).Nonempty 


Original valid proof:
:= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚]
  apply IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed
  Â· rintro âŸ¨uâ‚, huâ‚âŸ© âŸ¨uâ‚‚, huâ‚‚âŸ©
    use âŸ¨uâ‚ âˆ© uâ‚‚, inter_mem huâ‚ huâ‚‚âŸ©
    constructor
    all_goals exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) Subset.rfl)
  Â· intro u
    have hn : (image2 Ï• (u âˆ© v) s).Nonempty :=
      Nonempty.image2 (Filter.nonempty_of_mem (inter_mem u.prop hvâ‚)) hs
    exact hn.mono subset_closure
  Â· intro
    apply hcâ‚.of_isClosed_subset isClosed_closure
    calc
      _ âŠ† closure (image2 Ï• v s) := closure_mono (image2_subset inter_subset_right Subset.rfl)
      _ âŠ† c := hvâ‚‚
  Â· exact fun _ â†¦ isClosed_closure


Verifying proof (Commit ffb5dddeb20329610a2c898c4125ae8bea987862):
rcases exists_nonempty_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaCt_absorbing
  nonempty_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaCt_absorbing
  nonempty_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaCt_absorbing
  nonempty_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaCt_absorbing hcâ‚ hcâ‚‚ hcâ‚ hcâ‚‚ hcâ‚ hcâ‚‚ hcâ‚ hcâ‚‚ with
  âŸ¨v, hv, hvfâŸ©

Attempt failure.

Working on Mathlib/Dynamics/PeriodicPts.lean - 2024-09-08 23:53:38.765806.
---85/200---
For theorem Function.periodicOrbit_apply_iterate_eq in Mathlib/Dynamics/PeriodicPts.lean:
theorem periodicOrbit_apply_iterate_eq (hx : x âˆˆ periodicPts f) (n : â„•) :
    periodicOrbit f (f^[n] x) = periodicOrbit f x 


Original valid proof:
:=
  Eq.symm <| Cycle.coe_eq_coe.2 <| .intro n <|
    List.ext_get (by simp [minimalPeriod_apply_iterate hx]) fun m _ _ â†¦ by
      simp [List.getElem_rotate, iterate_add_apply]


Verifying proof (Commit 0185583b06b06956b00d879ca9810cf6e8439166):
induction' n with n hn generalizing x n

Attempt failure.

Working on Mathlib/FieldTheory/IsAlgClosed/Basic.lean - 2024-09-08 23:53:44.581909.
---86/200---
For theorem IsAlgClosed.algebraMap_surjective_of_isIntegral' in Mathlib/FieldTheory/IsAlgClosed/Basic.lean:
theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k â†’+* K) (hf : f.IsIntegral) : Function.Surjective f 


Original valid proof:
:=
  let _ : Algebra k K := f.toAlgebra
  have : Algebra.IsIntegral k K := âŸ¨hfâŸ©
  algebraMap_surjective_of_isIntegral


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
apply Function.Surjective.of_surjective

Attempt failure.

Working on Mathlib/FieldTheory/PrimitiveElement.lean - 2024-09-08 23:54:04.620934.
---87/200---
For theorem Field.exists_primitive_element_of_finite_top in Mathlib/FieldTheory/PrimitiveElement.lean:
theorem exists_primitive_element_of_finite_top [Finite E] : âˆƒ Î± : E, FâŸ®Î±âŸ¯ = âŠ¤ 


Original valid proof:
:= by
  obtain âŸ¨Î±, hÎ±âŸ© := @IsCyclic.exists_generator EË£ _ _
  use Î±
  rw [eq_top_iff]
  rintro x -
  by_cases hx : x = 0
  Â· rw [hx]
    exact FâŸ®Î±.valâŸ¯.zero_mem
  Â· obtain âŸ¨n, hnâŸ© := Set.mem_range.mp (hÎ± (Units.mk0 x hx))
    rw [show x = Î± ^ n by norm_cast; rw [hn, Units.val_mk0]]
    exact zpow_mem (mem_adjoin_simple_self F (E := E) â†‘Î±) n


Verifying proof (Commit a76dc22f3a90e5ab96e9284d30276a87a4324a5d):
cases' exists_primitive_element_of_exists_primitive_element_of_exists_primitive_element_of_exists_primitive_element_of_exists_primitive_element_of_finite

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean - 2024-09-08 23:54:25.149433.
---88/200---
For theorem Orientation.oangle_eq_of_angle_eq_of_sign_eq in Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean:
theorem oangle_eq_of_angle_eq_of_sign_eq {w x y z : V}
    (h : InnerProductGeometry.angle w x = InnerProductGeometry.angle y z)
    (hs : (o.oangle w x).sign = (o.oangle y z).sign) : o.oangle w x = o.oangle y z 


Original valid proof:
:= by
  by_cases h0 : (w = 0 âˆ¨ x = 0) âˆ¨ y = 0 âˆ¨ z = 0
  Â· have hs' : (o.oangle w x).sign = 0 âˆ§ (o.oangle y z).sign = 0 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      Â· simpa using hs.symm
      Â· simpa using hs.symm
      Â· simpa using hs
      Â· simpa using hs
    rcases hs' with âŸ¨hswx, hsyzâŸ©
    have h' : InnerProductGeometry.angle w x = Ï€ / 2 âˆ§ InnerProductGeometry.angle y z = Ï€ / 2 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      Â· simpa using h.symm
      Â· simpa using h.symm
      Â· simpa using h
      Â· simpa using h
    rcases h' with âŸ¨hwx, hyzâŸ©
    have hpi : Ï€ / 2 â‰  Ï€ := by
      intro hpi
      rw [div_eq_iff, eq_comm, â† sub_eq_zero, mul_two, add_sub_cancel_right] at hpi
      Â· exact Real.pi_pos.ne.symm hpi
      Â· exact two_ne_zero
    have h0wx : w = 0 âˆ¨ x = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hswx
      simpa [hwx, Real.pi_pos.ne.symm, hpi] using h0'
    have h0yz : y = 0 âˆ¨ z = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hsyz
      simpa [hyz, Real.pi_pos.ne.symm, hpi] using h0'
    rcases h0wx with (h0wx | h0wx) <;> rcases h0yz with (h0yz | h0yz) <;> simp [h0wx, h0yz]
  Â· push_neg at h0
    rw [Real.Angle.eq_iff_abs_toReal_eq_of_sign_eq hs]
    rwa [o.angle_eq_abs_oangle_toReal h0.1.1 h0.1.2,
      o.angle_eq_abs_oangle_toReal h0.2.1 h0.2.2] at h


Verifying proof (Commit 6b3f3fe208f0cdce581d713270301bed755856ed):
refine (o.oangle_eq_of_angle_eq_of_sign_eq w x y z).symm.trans ?_

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Circumcenter.lean - 2024-09-08 23:54:45.402078.
---89/200---
For theorem Affine.Simplex.circumradius_pos in Mathlib/Geometry/Euclidean/Circumcenter.lean:
theorem circumradius_pos {n : â„•} (s : Simplex â„ P (n + 1)) : 0 < s.circumradius 


Original valid proof:
:= by
  refine lt_of_le_of_ne s.circumradius_nonneg ?_
  intro h
  have hr := s.dist_circumcenter_eq_circumradius
  simp_rw [â† h, dist_eq_zero] at hr
  have h01 := s.independent.injective.ne (by simp : (0 : Fin (n + 2)) â‰  1)
  simp [hr] at h01


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
rw [circumradius_pos]

Attempt failure.

---90/200---
For theorem Affine.Simplex.circumsphere_unique_dist_eq in Mathlib/Geometry/Euclidean/Circumcenter.lean:
theorem circumsphere_unique_dist_eq {n : â„•} (s : Simplex â„ P n) :
    (s.circumsphere.center âˆˆ affineSpan â„ (Set.range s.points) âˆ§
        Set.range s.points âŠ† s.circumsphere) âˆ§
      âˆ€ cs : Sphere P,
        cs.center âˆˆ affineSpan â„ (Set.range s.points) âˆ§ Set.range s.points âŠ† cs â†’
          cs = s.circumsphere 


Original valid proof:
:=
  s.independent.existsUnique_dist_eq.choose_spec


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
simp only [circumsphere_eq_circumsphere_eq_circumsphere, circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circums

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Triangle.lean - 2024-09-08 23:55:25.947062.
---91/200---
For theorem EuclideanGeometry.dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq in Mathlib/Geometry/Euclidean/Triangle.lean:
theorem dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq (a b c : P) :
    dist a b ^ 2 + dist a c ^ 2 = 2 * (dist a (midpoint â„ b c) ^ 2 + (dist b c / 2) ^ 2) 


Original valid proof:
:= by
  by_cases hbc : b = c
  Â· simp [hbc, midpoint_self, dist_self, two_mul]
  Â· let m := midpoint â„ b c
    have : dist b c â‰  0 := (dist_pos.mpr hbc).ne'
    have hm := dist_sq_mul_dist_add_dist_sq_mul_dist a b c m (angle_midpoint_eq_pi b c hbc)
    simp only [m, dist_left_midpoint, dist_right_midpoint, Real.norm_two] at hm
    calc
      dist a b ^ 2 + dist a c ^ 2 = 2 / dist b c * (dist a b ^ 2 *
        ((2:â„)â»Â¹ * dist b c) + dist a c ^ 2 * (2â»Â¹ * dist b c)) := by field_simp; ring
      _ = 2 * (dist a (midpoint â„ b c) ^ 2 + (dist b c / 2) ^ 2) := by rw [hm]; field_simp; ring


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
rw [dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_eq_two_mul_dist_midpoint_sq_eq_two_mul_dist_midpoint_sq_add_half_dist]

Attempt failure.

Working on Mathlib/Geometry/Manifold/IntegralCurve.lean - 2024-09-08 23:55:46.108836.
---92/200---
For theorem IsIntegralCurve.isIntegralCurveAt in Mathlib/Geometry/Manifold/IntegralCurve.lean:
lemma IsIntegralCurve.isIntegralCurveAt (h : IsIntegralCurve Î³ v) (t : â„) :
    IsIntegralCurveAt Î³ v t 


Original valid proof:
:= isIntegralCurveAt_iff.mpr âŸ¨univ, Filter.univ_mem, fun t _ â†¦ h tâŸ©


Verifying proof (Commit 2c4d77d7fd709133772709da9ffb1d698ecbcd0a):
apply IsIntegralCurve.isIntegralCurveAt_isIntegralCurveAt

Attempt failure.

Working on Mathlib/Geometry/Manifold/LocalInvariantProperties.lean - 2024-09-08 23:56:06.415221.
---93/200---
For theorem StructureGroupoid.LocalInvariantProp.liftPropWithinAt_iff in Mathlib/Geometry/Manifold/LocalInvariantProperties.lean:
theorem liftPropWithinAt_iff {f : M â†’ M'} :
    LiftPropWithinAt P f s x â†”
      ContinuousWithinAt f s x âˆ§
        P (chartAt H' (f x) âˆ˜ f âˆ˜ (chartAt H x).symm)
          ((chartAt H x).target âˆ© (chartAt H x).symm â»Â¹' (s âˆ© f â»Â¹' (chartAt H' (f x)).source))
          (chartAt H x x) 


Original valid proof:
:= by
  rw [liftPropWithinAt_iff']
  refine and_congr_right fun hf â†¦ hG.congr_set ?_
  exact PartialHomeomorph.preimage_eventuallyEq_target_inter_preimage_inter hf
    (mem_chart_source H x) (chart_source_mem_nhds H' (f x))


Verifying proof (Commit b06c98e69f01ef8ab665c237468aa64e98a5bcd4):
simp only [mfld_source, chartAt_source]

Attempt failure.

Working on Mathlib/Geometry/RingedSpace/OpenImmersion.lean - 2024-09-08 23:56:14.127468.
---94/200---
For theorem AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.pullbackConeOfLeftLift_fst in Mathlib/Geometry/RingedSpace/OpenImmersion.lean:
theorem pullbackConeOfLeftLift_fst :
    pullbackConeOfLeftLift f g s â‰« (pullbackConeOfLeft f g).fst = s.fst 


Original valid proof:
:= by
  refine PresheafedSpace.Hom.ext _ _ ?_ <| NatTrans.ext _ _ <| funext fun x => ?_
  Â· change pullback.lift _ _ _ â‰« pullback.fst = _
    simp
  Â· induction x using Opposite.rec' with | h x => ?_
    change ((_ â‰« _) â‰« _ â‰« _) â‰« _ = _
    simp_rw [Category.assoc]
    erw [â† s.pt.presheaf.map_comp]
    erw [s.snd.c.naturality_assoc]
    have := congr_app s.condition (op (opensFunctor f |>.obj x))
    dsimp only [comp_c_app, unop_op] at this
    rw [â† IsIso.comp_inv_eq] at this
    replace this := reassoc_of% this
    erw [â† this, hf.invApp_app_assoc, s.fst.c.naturality_assoc]
    simp [eqToHom_map]


Verifying proof (Commit 040e24340352a4333b5b2688f637a85dc78123c1):
simp [pullbackConeOfLeftLift, pullbackConeOfLeftLift]

Attempt failure.

Working on Mathlib/GroupTheory/Coxeter/Inversion.lean - 2024-09-08 23:56:34.482276.
---95/200---
For theorem CoxeterSystem.wordProd_mul_getD_rightInvSeq in Mathlib/GroupTheory/Coxeter/Inversion.lean:
theorem wordProd_mul_getD_rightInvSeq (Ï‰ : List B) (j : â„•) :
    Ï€ Ï‰ * ((ris Ï‰).getD j 1) = Ï€ (Ï‰.eraseIdx j) 


Original valid proof:
:= by
  rw [getD_rightInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 1 [â† take_append_drop (j + 1) Ï‰]
  rw [take_succ]
  obtain lt | le := lt_or_le j Ï‰.length
  Â· simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]
    simp
  Â· simp only [get?_eq_getElem?, getElem?_eq_none le]
    simp


Verifying proof (Commit eb780daf7ddc0b2aff6bd37f400ad1275df42fc8):
simp only [getD_eraseIdx_left, getD_eraseIdx_eq_getD_getD_rightInvSeq,
  getD_eraseIdx_left, getD_eraseIdx_left, getD_eraseIdx_left,
  getD_eraseIdx_left]

Attempt failure.

Working on Mathlib/GroupTheory/GroupAction/Blocks.lean - 2024-09-08 23:56:44.352069.
---96/200---
For theorem MulAction.IsPartition.of_orbits in Mathlib/GroupTheory/GroupAction/Blocks.lean:
theorem IsPartition.of_orbits :
    Setoid.IsPartition (Set.range fun a : X => orbit G a) 


Original valid proof:
:= by
  apply orbit.pairwiseDisjoint.isPartition_of_exists_of_ne_empty
  Â· intro x
    exact âŸ¨_, âŸ¨x, rflâŸ©, mem_orbit_self xâŸ©
  Â· rintro âŸ¨a, ha : orbit G a = âˆ…âŸ©
    exact (MulAction.orbit_nonempty a).ne_empty ha


Verifying proof (Commit 90ee4adef4081d5ea59d0008022888ad5b93d012):
refine IsPartition.of_orbits (fun a â†¦ ?_)

Attempt failure.

Working on Mathlib/GroupTheory/Schreier.lean - 2024-09-08 23:56:50.943274.
---97/200---
For theorem Subgroup.card_commutator_le_of_finite_commutatorSet in Mathlib/GroupTheory/Schreier.lean:
theorem card_commutator_le_of_finite_commutatorSet [Finite (commutatorSet G)] :
    Nat.card (_root_.commutator G) â‰¤ cardCommutatorBound (Nat.card (commutatorSet G)) 


Original valid proof:
:= by
  have h1 := index_center_le_pow (closureCommutatorRepresentatives G)
  have h2 := card_commutator_dvd_index_center_pow (closureCommutatorRepresentatives G)
  rw [card_commutatorSet_closureCommutatorRepresentatives] at h1 h2
  rw [card_commutator_closureCommutatorRepresentatives] at h2
  replace h1 :=
    h1.trans
      (Nat.pow_le_pow_of_le_right Finite.card_pos (rank_closureCommutatorRepresentatives_le G))
  replace h2 := h2.trans (pow_dvd_pow _ (add_le_add_right (mul_le_mul_right' h1 _) 1))
  rw [â† pow_succ] at h2
  refine (Nat.le_of_dvd ?_ h2).trans (Nat.pow_le_pow_left h1 _)
  exact pow_pos (Nat.pos_of_ne_zero FiniteIndex.finiteIndex) _


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
rw [card_commutator_le_of_finite_commutatorSet]

Attempt failure.

Working on Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean - 2024-09-08 23:57:11.072474.
---98/200---
For theorem AffineMap.ext in Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean:
theorem ext {f g : P1 â†’áµƒ[k] P2} (h : âˆ€ p, f p = g p) : f = g 


Original valid proof:
:=
  DFunLike.ext _ _ h


Verifying proof (Commit 161a7501773058c7d39559d99d747edbacc56fbd):
refine ext_of_theorem ext_theorem ext_theorem ext_theorem ext_theorem ext_theorem ext_theorem ?_

Attempt failure.

Working on Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean - 2024-09-08 23:57:31.268245.
---99/200---
For theorem affineSpan_pair_le_of_mem_of_mem in Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean:
theorem affineSpan_pair_le_of_mem_of_mem {pâ‚ pâ‚‚ : P} {s : AffineSubspace k P} (hpâ‚ : pâ‚ âˆˆ s)
    (hpâ‚‚ : pâ‚‚ âˆˆ s) : line[k, pâ‚, pâ‚‚] â‰¤ s 


Original valid proof:
:= by
  rw [affineSpan_le, Set.insert_subset_iff, Set.singleton_subset_iff]
  exact âŸ¨hpâ‚, hpâ‚‚âŸ©


Verifying proof (Commit 5068808d2b4c25cf905cf7fee10ded8e447c2346):
rw [line[k, pâ‚, pâ‚‚]]

Attempt failure.

Working on Mathlib/LinearAlgebra/Basis.lean - 2024-09-08 23:57:48.260463.
---100/200---
For theorem union_support_maximal_linearIndependent_eq_range_basis in Mathlib/LinearAlgebra/Basis.lean:
theorem union_support_maximal_linearIndependent_eq_range_basis {Î¹ : Type w} (b : Basis Î¹ R M)
    {Îº : Type w'} (v : Îº â†’ M) (i : LinearIndependent R v) (m : i.Maximal) :
    â‹ƒ k, ((b.repr (v k)).support : Set Î¹) = Set.univ 


Original valid proof:
:= by
  by_contra h
  simp only [â† Ne.eq_def, ne_univ_iff_exists_not_mem, mem_iUnion, not_exists_not,
    Finsupp.mem_support_iff, Finset.mem_coe] at h
  obtain âŸ¨b', wâŸ© := h
  let v' : Option Îº â†’ M := fun o => o.elim (b b') v
  have r : range v âŠ† range v' := by
    rintro - âŸ¨k, rflâŸ©
    use some k
    simp only [v', Option.elim_some]
  have r' : b b' âˆ‰ range v := by
    rintro âŸ¨k, pâŸ©
    simpa [w] using congr_arg (fun m => (b.repr m) b') p
  have r'' : range v â‰  range v' := by
    intro e
    have p : b b' âˆˆ range v' := by
      use none
      simp only [v', Option.elim_none]
    rw [â† e] at p
    exact r' p
  have i' : LinearIndependent R ((â†‘) : range v' â†’ M) := by
    apply LinearIndependent.to_subtype_range
    rw [linearIndependent_iff]
    intro l z
    rw [Finsupp.total_option] at z
    simp only [v', Option.elim'] at z
    change _ + Finsupp.total Îº M R v l.some = 0 at z
    have lâ‚€ : l none = 0 := by
      rw [â† eq_neg_iff_add_eq_zero] at z
      replace z := neg_eq_iff_eq_neg.mpr z
      apply_fun fun x => b.repr x b' at z
      simp only [repr_self, map_smul, mul_one, Finsupp.single_eq_same, Pi.neg_apply,
        Finsupp.smul_single', map_neg, Finsupp.coe_neg] at z
      erw [DFunLike.congr_fun (Finsupp.apply_total R (b.repr : M â†’â‚—[R] Î¹ â†’â‚€ R) v l.some) b'] at z
      simpa [Finsupp.total_apply, w] using z
    have lâ‚ : l.some = 0 := by
      rw [lâ‚€, zero_smul, zero_add] at z
      exact linearIndependent_iff.mp i _ z
    ext (_ | a)
    Â· simp only [lâ‚€, Finsupp.coe_zero, Pi.zero_apply]
    Â· erw [DFunLike.congr_fun lâ‚ a]
      simp only [Finsupp.coe_zero, Pi.zero_apply]
  rw [LinearIndependent.Maximal] at m
  specialize m (range v') i' r
  exact r'' m


Verifying proof (Commit 971a0d73179f0907eda2324b5a10ab2a071e3aae):
simp [Set.eq_univ_iff_forall]

Attempt failure.

Working on Mathlib/LinearAlgebra/Finsupp.lean - 2024-09-08 23:58:08.388452.
---101/200---
For theorem LinearMap.splittingOfFunOnFintypeSurjective_splits in Mathlib/LinearAlgebra/Finsupp.lean:
theorem splittingOfFunOnFintypeSurjective_splits [Finite Î±] (f : M â†’â‚—[R] Î± â†’ R)
    (s : Surjective f) : f.comp (splittingOfFunOnFintypeSurjective f s) = LinearMap.id 


Original valid proof:
:= by
  classical
  refine pi_ext' fun x => ext_ring <| funext fun y => ?_
  dsimp [splittingOfFunOnFintypeSurjective]
  rw [linearEquivFunOnFinite_symm_single, Finsupp.sum_single_index, one_smul,
    (s (Finsupp.single x 1)).choose_spec, Finsupp.single_eq_pi_single]
  rw [zero_smul]


Verifying proof (Commit 67e80fd089fe45abea632652c43b78eba72d60e3):
rw [â† splittingOfFunOnFintypeSurjective_id]

Attempt failure.

Working on Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean - 2024-09-08 23:58:28.493037.
---102/200---
For theorem Matrix.rank_vecMulVec in Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean:
theorem Matrix.rank_vecMulVec {K m n : Type u} [CommRing K] [Fintype n]
    [DecidableEq n] (w : m â†’ K) (v : n â†’ K) : (Matrix.vecMulVec w v).toLin'.rank â‰¤ 1 


Original valid proof:
:= by
  nontriviality K
  rw [Matrix.vecMulVec_eq (Fin 1), Matrix.toLin'_mul]
  refine le_trans (LinearMap.rank_comp_le_left _ _) ?_
  refine (LinearMap.rank_le_domain _).trans_eq ?_
  rw [rank_fun', Fintype.card_ofSubsingleton, Nat.cast_one]


Verifying proof (Commit bad931b7fc9f31f5ff5b8f408dd19bbe20a9f0e1):
rw [â† Matrix.rank_vecMulVec_eq_rank, Matrix.rank_vecMulVec_eq]

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean - 2024-09-08 23:58:48.846744.
---103/200---
For theorem Matrix.reverse_charpoly in Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean:
lemma reverse_charpoly (M : Matrix n n R) :
    M.charpoly.reverse = M.charpolyRev 


Original valid proof:
:= by
  nontriviality R
  let t : R[T;Tâ»Â¹] := T 1
  let t_inv : R[T;Tâ»Â¹] := T (-1)
  let p : R[T;Tâ»Â¹] := det (scalar n t - M.map LaurentPolynomial.C)
  let q : R[T;Tâ»Â¹] := det (1 - scalar n t * M.map LaurentPolynomial.C)
  have ht : t_inv * t = 1 := by rw [â† T_add, add_left_neg, T_zero]
  have hp : toLaurentAlg M.charpoly = p := by
    simp [p, charpoly, charmatrix, AlgHom.map_det, map_sub, map_smul']
  have hq : toLaurentAlg M.charpolyRev = q := by
    simp [q, charpolyRev, AlgHom.map_det, map_sub, map_smul', smul_eq_diagonal_mul]
  suffices t_inv ^ Fintype.card n * p = invert q by
    apply toLaurent_injective
    rwa [toLaurent_reverse, â† coe_toLaurentAlg, hp, hq, â† involutive_invert.injective.eq_iff,
      _root_.map_mul, involutive_invert p, charpoly_natDegree_eq_dim,
      â† mul_one (Fintype.card n : â„¤), â† T_pow, map_pow, invert_T, mul_comm]
  rw [â† det_smul, smul_sub, scalar_apply, â† diagonal_smul, Pi.smul_def, smul_eq_mul, ht,
    diagonal_one, invert.map_det]
  simp [t, map_smul', smul_eq_diagonal_mul]


Verifying proof (Commit 8a368c9ce548afdf4c8725618c97ec9e96c48601):
simp only [charpolyRev, reverse_charpoly, charmatrix_apply, charmatrix_apply,
  charmatrix_apply, charmatrix_apply]

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/PosDef.lean - 2024-09-08 23:59:09.030344.
---104/200---
For theorem Matrix.PosDef.eigenvalues_pos in Mathlib/LinearAlgebra/Matrix/PosDef.lean:
lemma eigenvalues_pos [DecidableEq n] {A : Matrix n n ğ•œ}
    (hA : Matrix.PosDef A) (i : n) : 0 < hA.1.eigenvalues i 


Original valid proof:
:= by
  simp only [hA.1.eigenvalues_eq]
  exact hA.re_dotProduct_pos <| hA.1.eigenvectorBasis.orthonormal.ne_zero i


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
simp [eigenvalues_pos, eigenvalues_pos]

Attempt failure.

---105/200---
For theorem Matrix.IsHermitian.posSemidef_of_eigenvalues_nonneg in Mathlib/LinearAlgebra/Matrix/PosDef.lean:
lemma IsHermitian.posSemidef_of_eigenvalues_nonneg [DecidableEq n] {A : Matrix n n ğ•œ}
    (hA : IsHermitian A) (h : âˆ€ i : n, 0 â‰¤ hA.eigenvalues i) : PosSemidef A 


Original valid proof:
:= by
  rw [hA.spectral_theorem]
  refine (posSemidef_diagonal_iff.mpr ?_).mul_mul_conjTranspose_same _
  simpa using h


Verifying proof (Commit 7800fb94347a7ae960c80963e8c98275d05eecba):
refine âŸ¨fun i â†¦ hA.eigenvalues i, fun i â†¦ hA.eigenvalues i, fun i â†¦ ?_âŸ©

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Spectrum.lean - 2024-09-08 23:59:49.557982.
---106/200---
For theorem Matrix.IsHermitian.det_eq_prod_eigenvalues in Mathlib/LinearAlgebra/Matrix/Spectrum.lean:
theorem det_eq_prod_eigenvalues : det A = âˆ i, (hA.eigenvalues i : ğ•œ) 


Original valid proof:
:= by
  convert congr_arg det hA.spectral_theorem
  rw [det_mul_right_comm]
  simp


Verifying proof (Commit aaf4ca2007ab15f02495731d0805034c9199aeea):
have det_eq_prod_eigenvalues : det A = âˆ i, hA.eigenvalues i := by rw [det_eq_prod_eigenvalues]

Attempt failure.

---107/200---
For theorem Matrix.IsHermitian.rank_eq_rank_diagonal in Mathlib/LinearAlgebra/Matrix/Spectrum.lean:
lemma rank_eq_rank_diagonal : A.rank = (Matrix.diagonal hA.eigenvalues).rank 


Original valid proof:
:= by
  conv_lhs => rw [hA.spectral_theorem, â† unitary.coe_star]
  simp [-isUnit_iff_ne_zero, -unitary.coe_star, rank_diagonal]


Verifying proof (Commit aaa7a79ed9b6aeb68b9146319b3798dfc6cbf05e):
rw [rank_eq_rank_diagonal]

Attempt failure.

Working on Mathlib/LinearAlgebra/Matrix/Transvection.lean - 2024-09-09 00:00:29.919580.
---108/200---
For theorem Matrix.Pivot.mul_listTransvecRow_last_col in Mathlib/LinearAlgebra/Matrix/Transvection.lean:
theorem mul_listTransvecRow_last_col_take (i : Sum (Fin r) Unit) {k : â„•} (hk : k â‰¤ r) :
    (M * ((listTransvecRow M).take k).prod) i (inr unit) = M i (inr unit) 


Original valid proof:
:= by
  induction' k with k IH
  Â· simp only [Matrix.mul_one, List.take_zero, List.prod_nil, List.take, Matrix.mul_one]
  Â· have hkr : k < r := hk
    let k' : Fin r := âŸ¨k, hkrâŸ©
    have :
      (listTransvecRow M)[k]? =
        â†‘(transvection (inr Unit.unit) (inl k')
            (-M (inr Unit.unit) (inl k') / M (inr Unit.unit) (inr Unit.unit))) := by
      simp only [listTransvecRow, List.ofFnNthVal, hkr, dif_pos, List.getElem?_ofFn]
    simp only [List.take_succ, â† Matrix.mul_assoc, this, List.prod_append, Matrix.mul_one,
      List.prod_cons, List.prod_nil, Option.toList_some]
    rw [mul_transvection_apply_of_ne, IH hkr.le]
    simp only [Ne, not_false_iff]


Verifying proof (Commit 9bc35020058f4a5a844eb7662d9de673056d4dbe):
simp [listTransvecRow_last_col_take, listTransvecRow_last_col_take]

Attempt failure.

Working on Mathlib/LinearAlgebra/Orientation.lean - 2024-09-09 00:00:50.424340.
---109/200---
For theorem Orientation.eq_or_eq_neg in Mathlib/LinearAlgebra/Orientation.lean:
theorem eq_or_eq_neg_of_isEmpty [IsEmpty Î¹] (o : Orientation R M Î¹) :
    o = positiveOrientation âˆ¨ o = -positiveOrientation 


Original valid proof:
:= by
  induction' o using Module.Ray.ind with x hx
  dsimp [positiveOrientation]
  simp only [ray_eq_iff, sameRay_neg_swap]
  rw [sameRay_or_sameRay_neg_iff_not_linearIndependent]
  intro h
  set f : (M [â‹€^Î¹]â†’â‚—[R] R) â‰ƒâ‚—[R] R := AlternatingMap.constLinearEquivOfIsEmpty.symm
  have H : LinearIndependent R ![f x, 1] := by
    convert h.map' f.toLinearMap f.ker
    ext i
    fin_cases i <;> simp [f]
  rw [linearIndependent_iff'] at H
  simpa using H Finset.univ ![1, -f x] (by simp [Fin.sum_univ_succ]) 0 (by simp)


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
cases' eq_or_eq_neg_of_isEmpty Î¹ with eq_or_eq_neg_of_isEmpty

Attempt failure.

Working on Mathlib/LinearAlgebra/TensorProduct/Submodule.lean - 2024-09-09 00:01:10.533114.
---110/200---
For theorem Submodule.comm_trans_lTensorOne in Mathlib/LinearAlgebra/TensorProduct/Submodule.lean:
theorem comm_trans_lTensorOne :
    (TensorProduct.comm R _ _).trans M.lTensorOne = M.rTensorOne 


Original valid proof:
:= by
  refine LinearEquiv.toLinearMap_injective <| TensorProduct.ext' fun m r â†¦ ?_
  obtain âŸ¨x, hâŸ© := Algebra.mem_bot.1 r.2
  replace h : algebraMap R _ x = r := Subtype.val_injective h
  rw [â† h]; simp


Verifying proof (Commit 6476f50fd255f9405ed097d5642d2a495a30b7ec):
simp [rTensorOne, comm_trans_lTensorOne]

Attempt failure.

Working on Mathlib/LinearAlgebra/Trace.lean - 2024-09-09 00:01:30.540104.
---111/200---
For theorem LinearMap.trace_one in Mathlib/LinearAlgebra/Trace.lean:
theorem trace_one : trace R M 1 = (finrank R M : R) 


Original valid proof:
:= by
  cases subsingleton_or_nontrivial R
  Â· simp [eq_iff_true_of_subsingleton]
  have b := Module.Free.chooseBasis R M
  rw [trace_eq_matrix_trace R b, toMatrix_one, finrank_eq_card_chooseBasisIndex]
  simp


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
have trace_one : trace R M 1 = finrank R M := by simp [trace_one]

Attempt failure.

Working on Mathlib/Logic/Function/Iterate.lean - 2024-09-09 00:01:50.885465.
---112/200---
For theorem Function.Commute.iterate_left in Mathlib/Logic/Function/Iterate.lean:
theorem iterate_left {g : â„• â†’ Î± â†’ Î±} (H : âˆ€ n, Semiconj f (g n) (g <| n + 1)) (n k : â„•) :
    Semiconj f^[n] (g k) (g <| n + k) 


Original valid proof:
:= by
  induction n generalizing k with
  | zero =>
    rw [Nat.zero_add]
    exact id_left
  | succ n ihn =>
    rw [Nat.add_right_comm, Nat.add_assoc]
    exact (H k).trans (ihn (k + 1))


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
induction' k with k hk

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean - 2024-09-09 00:01:53.562403.
---113/200---
For theorem measurable_of_tendsto_metrizable' in Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean:
theorem measurable_of_tendsto_metrizable' {Î¹} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : Filter Î¹) [NeBot u]
    [IsCountablyGenerated u] (hf : âˆ€ i, Measurable (f i)) (lim : Tendsto f u (ğ“ g)) :
    Measurable g 


Original valid proof:
:= by
  letI : PseudoMetricSpace Î² := pseudoMetrizableSpacePseudoMetric Î²
  apply measurable_of_isClosed'
  intro s h1s h2s h3s
  have : Measurable fun x => infNndist (g x) s := by
    suffices Tendsto (fun i x => infNndist (f i x) s) u (ğ“ fun x => infNndist (g x) s) from
      NNReal.measurable_of_tendsto' u (fun i => (hf i).infNndist) this
    rw [tendsto_pi_nhds] at lim âŠ¢
    intro x
    exact ((continuous_infNndist_pt s).tendsto (g x)).comp (lim x)
  have h4s : g â»Â¹' s = (fun x => infNndist (g x) s) â»Â¹' {0} := by
    ext x
    simp [h1s, â† h1s.mem_iff_infDist_zero h2s, â† NNReal.coe_eq_zero]
  rw [h4s]
  exact this (measurableSet_singleton 0)


Verifying proof (Commit 5068808d2b4c25cf905cf7fee10ded8e447c2346):
refine measurable_of_tendsto_metrizable'.measurable_of_tendsto_metrizable'.measurable_lim ?_

Attempt failure.

Working on Mathlib/MeasureTheory/Constructions/Polish.lean - 2024-09-09 00:02:14.078422.
---114/200---
For theorem MeasurableSet.analyticSet in Mathlib/MeasureTheory/Constructions/Polish.lean:
theorem _root_.MeasurableSet.analyticSet {Î± : Type*} [t : TopologicalSpace Î±] [PolishSpace Î±]
    [MeasurableSpace Î±] [BorelSpace Î±] {s : Set Î±} (hs : MeasurableSet s) : AnalyticSet s 


Original valid proof:
:= by
  obtain âŸ¨t', t't, t'_polish, s_closed, _âŸ© :
      âˆƒ t' : TopologicalSpace Î±, t' â‰¤ t âˆ§ @PolishSpace Î± t' âˆ§ IsClosed[t'] s âˆ§ IsOpen[t'] s :=
    hs.isClopenable
  have A := @IsClosed.analyticSet Î± t' t'_polish s s_closed
  convert @AnalyticSet.image_of_continuous Î± t' Î± t s A id (continuous_id_of_le t't)
  simp only [id, image_id']


Verifying proof (Commit 4968eba95a704a4a58e8b3735dc3733ee6d46c0d):
exact analyticSet_analyticSet_of_analyticSet hs

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Besicovitch.lean - 2024-09-09 00:02:34.344461.
---115/200---
For theorem Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux in Mathlib/MeasureTheory/Covering/Besicovitch.lean:
theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Î¼ : Measure Î±)
    [IsFiniteMeasure Î¼] (f : Î± â†’ Set â„) (s : Set Î±)
    (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty) :
    âˆƒ t : Set (Î± Ã— â„), t.Countable âˆ§ (âˆ€ p âˆˆ t, p.1 âˆˆ s) âˆ§ (âˆ€ p âˆˆ t, p.2 âˆˆ f p.1) âˆ§
      Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) = 0 âˆ§
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 


Original valid proof:
:= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, ?_âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, âŸ¨?_, ?_, ?_âŸ©, ?_âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Î¼ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
rw [exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux]

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Differentiation.lean - 2024-09-09 00:02:55.053597.
---116/200---
For theorem VitaliFamily.mul_measure_le_of_subset_lt_limRatioMeas in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem mul_measure_le_of_subset_lt_limRatioMeas {q : â„â‰¥0} {s : Set Î±}
    (h : s âŠ† {x | (q : â„â‰¥0âˆ) < v.limRatioMeas hÏ x}) : (q : â„â‰¥0âˆ) * Î¼ s â‰¤ Ï s 


Original valid proof:
:= by
  let t := {x : Î± | Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ (v.limRatioMeas hÏ x))}
  have A : Î¼ tá¶œ = 0 := v.ae_tendsto_limRatioMeas hÏ
  suffices H : (q â€¢ Î¼) (s âˆ© t) â‰¤ Ï (s âˆ© t) by calc
    (q â€¢ Î¼) s = (q â€¢ Î¼) (s âˆ© t âˆª s âˆ© tá¶œ) := by rw [inter_union_compl]
    _ â‰¤ (q â€¢ Î¼) (s âˆ© t) + (q â€¢ Î¼) (s âˆ© tá¶œ) := measure_union_le _ _
    _ â‰¤ Ï (s âˆ© t) + (q â€¢ Î¼) tá¶œ := by gcongr; apply inter_subset_right
    _ = Ï (s âˆ© t) := by simp [A]
    _ â‰¤ Ï s := by gcongr; apply inter_subset_left
  refine v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ ?_
  intro x hx
  have I : âˆ€á¶  a in v.filterAt x, (q : â„â‰¥0âˆ) < Ï a / Î¼ a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le


Verifying proof (Commit 40b64f797572a7615ba4553a28d3d6ee5049aa3b):
refine le_trans (mul_measure_le_of_subset_lt_limRatioMeas_le s) ?_

Attempt failure.

---117/200---
For theorem VitaliFamily.withDensity_le_mul in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem withDensity_le_mul {s : Set Î±} (hs : MeasurableSet s) {t : â„â‰¥0} (ht : 1 < t) :
    Î¼.withDensity (v.limRatioMeas hÏ) s â‰¤ (t : â„â‰¥0âˆ) ^ 2 * Ï s 


Original valid proof:
:= by
  have t_ne_zero' : t â‰  0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : â„â‰¥0âˆ) â‰  0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let Î½ := Î¼.withDensity (v.limRatioMeas hÏ)
  let f := v.limRatioMeas hÏ
  have f_meas : Measurable f := v.limRatioMeas_measurable hÏ
  have A : Î½ (s âˆ© f â»Â¹' {0}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) := by
    apply le_trans _ (zero_le _)
    have M : MeasurableSet (s âˆ© f â»Â¹' {0}) := hs.inter (f_meas (measurableSet_singleton _))
    simp only [Î½, nonpos_iff_eq_zero, M, withDensity_apply, lintegral_eq_zero_iff f_meas]
    apply (ae_restrict_iff' M).2
    exact eventually_of_forall fun x hx => hx.2
  have B : Î½ (s âˆ© f â»Â¹' {âˆ}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply withDensity_absolutelyContinuous Î¼ _
    rw [â† nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hÏ).le
  have C :
    âˆ€ n : â„¤,
      Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) â‰¤
        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))
    have M : MeasurableSet (s âˆ© f â»Â¹' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [Î½, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      (âˆ«â» x in s âˆ© f â»Â¹' I, f x âˆ‚Î¼) â‰¤ âˆ«â» _ in s âˆ© f â»Â¹' I, (t : â„â‰¥0âˆ) ^ (n + 1) âˆ‚Î¼ :=
        lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => hx.2.2.le))
      _ = (t : â„â‰¥0âˆ) ^ (n + 1) * Î¼ (s âˆ© f â»Â¹' I) := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ = (t : â„â‰¥0âˆ) ^ (2 : â„¤) * ((t : â„â‰¥0âˆ) ^ (n - 1) * Î¼ (s âˆ© f â»Â¹' I)) := by
        rw [â† mul_assoc, â† ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top]
        congr 2
        abel
      _ â‰¤ (t : â„â‰¥0âˆ) ^ (2 : â„¤) * Ï (s âˆ© f â»Â¹' I) := by
        gcongr
        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne']
        apply v.mul_measure_le_of_subset_lt_limRatioMeas hÏ
        intro x hx
        apply lt_of_lt_of_le _ hx.2.1
        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne', ENNReal.coe_lt_coe, sub_eq_add_neg,
          zpow_addâ‚€ t_ne_zero']
        conv_rhs => rw [â† mul_one (t ^ n)]
        gcongr
        rw [zpow_neg_one]
        exact inv_lt_one ht
  calc
    Î½ s =
      Î½ (s âˆ© f â»Â¹' {0}) + Î½ (s âˆ© f â»Â¹' {âˆ}) +
        âˆ‘' n : â„¤, Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow Î½ f_meas hs ht
    _ â‰¤
        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) + ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) +
          âˆ‘' n : â„¤, ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico (t ^ n) (t ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï) f_meas hs ht).symm


Verifying proof (Commit 611a64b31f2f9df551954217d12578133430d2b6):
refine (withDensity_le_mul hs t ht).trans ?_

Attempt failure.

Working on Mathlib/MeasureTheory/Decomposition/Jordan.lean - 2024-09-09 00:03:36.063004.
---118/200---
For theorem MeasureTheory.JordanDecomposition.toSignedMeasure_injective in Mathlib/MeasureTheory/Decomposition/Jordan.lean:
theorem toSignedMeasure_injective : Injective <| @JordanDecomposition.toSignedMeasure Î± _ 


Original valid proof:
:= by
  intro jâ‚ jâ‚‚ hj
  obtain âŸ¨S, hSâ‚, hSâ‚‚, hSâ‚ƒ, hSâ‚„, hSâ‚…âŸ© := jâ‚.exists_compl_positive_negative
  obtain âŸ¨T, hTâ‚, hTâ‚‚, hTâ‚ƒ, hTâ‚„, hTâ‚…âŸ© := jâ‚‚.exists_compl_positive_negative
  rw [â† hj] at hTâ‚‚ hTâ‚ƒ
  obtain âŸ¨hSTâ‚, -âŸ© :=
    of_symmDiff_compl_positive_negative hSâ‚.compl hTâ‚.compl âŸ¨hSâ‚ƒ, (compl_compl S).symm â–¸ hSâ‚‚âŸ©
      âŸ¨hTâ‚ƒ, (compl_compl T).symm â–¸ hTâ‚‚âŸ©
  refine eq_of_posPart_eq_posPart ?_ hj
  ext1 i hi
  have hÎ¼â‚ : (jâ‚.posPart i).toReal = jâ‚.toSignedMeasure (i âˆ© Sá¶œ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hSâ‚.compl),
      show jâ‚.negPart (i âˆ© Sá¶œ) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚… â–¸ measure_mono Set.inter_subset_right),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i S]
    rw [measure_union,
      show jâ‚.posPart (i âˆ© S) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚„ â–¸ measure_mono Set.inter_subset_right),
      zero_add]
    Â· refine
        Set.disjoint_of_subset_left Set.inter_subset_right
          (Set.disjoint_of_subset_right Set.inter_subset_right disjoint_compl_right)
    Â· exact hi.inter hSâ‚.compl
  have hÎ¼â‚‚ : (jâ‚‚.posPart i).toReal = jâ‚‚.toSignedMeasure (i âˆ© Tá¶œ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hTâ‚.compl),
      show jâ‚‚.negPart (i âˆ© Tá¶œ) = 0 from
        nonpos_iff_eq_zero.1 (hTâ‚… â–¸ measure_mono Set.inter_subset_right),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i T]
    rw [measure_union,
      show jâ‚‚.posPart (i âˆ© T) = 0 from
        nonpos_iff_eq_zero.1 (hTâ‚„ â–¸ measure_mono Set.inter_subset_right),
      zero_add]
    Â· exact
        Set.disjoint_of_subset_left Set.inter_subset_right
          (Set.disjoint_of_subset_right Set.inter_subset_right disjoint_compl_right)
    Â· exact hi.inter hTâ‚.compl
  rw [â† ENNReal.toReal_eq_toReal (measure_ne_top _ _) (measure_ne_top _ _), hÎ¼â‚, hÎ¼â‚‚, â† hj]
  exact of_inter_eq_of_symmDiff_eq_zero_positive hSâ‚.compl hTâ‚.compl hi hSâ‚ƒ hTâ‚ƒ hSTâ‚


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
rw [JordanDecomposition.toSignedMeasure_injective]

Attempt failure.

Working on Mathlib/MeasureTheory/Function/ConditionalExpectation/Basic.lean - 2024-09-09 00:03:56.779067.
---119/200---
For theorem MeasureTheory.condexp_finset_sum in Mathlib/MeasureTheory/Function/ConditionalExpectation/Basic.lean:
theorem condexp_finset_sum {Î¹ : Type*} {s : Finset Î¹} {f : Î¹ â†’ Î± â†’ F'}
    (hf : âˆ€ i âˆˆ s, Integrable (f i) Î¼) : Î¼[âˆ‘ i âˆˆ s, f i|m] =áµ[Î¼] âˆ‘ i âˆˆ s, Î¼[f i|m] 


Original valid proof:
:= by
  induction' s using Finset.induction_on with i s his heq hf
  Â· rw [Finset.sum_empty, Finset.sum_empty, condexp_zero]
  Â· rw [Finset.sum_insert his, Finset.sum_insert his]
    exact (condexp_add (hf i <| Finset.mem_insert_self i s) <|
      integrable_finset_sum' _ fun j hmem => hf j <| Finset.mem_insert_of_mem hmem).trans
        ((EventuallyEq.refl _ _).add (heq fun j hmem => hf j <| Finset.mem_insert_of_mem hmem))


Verifying proof (Commit c342c339a777827331257acd880fea6d441a6aa6):
simp only [condexp_finset_sum, condexp_finset_sum]

Attempt failure.

Working on Mathlib/MeasureTheory/Function/ConditionalExpectation/Real.lean - 2024-09-09 00:04:17.033260.
---120/200---
For theorem MeasureTheory.ae_bdd_condexp_of_ae_bdd in Mathlib/MeasureTheory/Function/ConditionalExpectation/Real.lean:
theorem ae_bdd_condexp_of_ae_bdd {R : â„â‰¥0} {f : Î± â†’ â„} (hbdd : âˆ€áµ x âˆ‚Î¼, |f x| â‰¤ R) :
    âˆ€áµ x âˆ‚Î¼, |(Î¼[f|m]) x| â‰¤ R 


Original valid proof:
:= by
  by_cases hnm : m â‰¤ m0
  swap
  Â· simp_rw [condexp_of_not_le hnm, Pi.zero_apply, abs_zero]
    exact eventually_of_forall fun _ => R.coe_nonneg
  by_cases hfint : Integrable f Î¼
  swap
  Â· simp_rw [condexp_undef hfint]
    filter_upwards [hbdd] with x hx
    rw [Pi.zero_apply, abs_zero]
    exact (abs_nonneg _).trans hx
  by_contra h
  change Î¼ _ â‰  0 at h
  simp only [â† zero_lt_iff, Set.compl_def, Set.mem_setOf_eq, not_le] at h
  suffices (Î¼ {x | â†‘R < |(Î¼[f|m]) x|}).toReal * â†‘R < (Î¼ {x | â†‘R < |(Î¼[f|m]) x|}).toReal * â†‘R by
    exact this.ne rfl
  refine lt_of_lt_of_le (setIntegral_gt_gt R.coe_nonneg ?_ ?_ h.ne.symm) ?_
  Â· simp_rw [â† Real.norm_eq_abs]
    exact (stronglyMeasurable_condexp.mono hnm).measurable.norm
  Â· exact integrable_condexp.abs.integrableOn
  refine (setIntegral_abs_condexp_le ?_ _).trans ?_
  Â· simp_rw [â† Real.norm_eq_abs]
    exact @measurableSet_lt _ _ _ _ _ m _ _ _ _ _ measurable_const
      stronglyMeasurable_condexp.norm.measurable
  simp only [â† smul_eq_mul, â† setIntegral_const, NNReal.val_eq_coe, RCLike.ofReal_real_eq_id,
    _root_.id]
  refine setIntegral_mono_ae hfint.abs.integrableOn ?_ hbdd
  refine âŸ¨aestronglyMeasurable_const, lt_of_le_of_lt ?_
    (integrable_condexp.integrableOn : IntegrableOn (Î¼[f|m]) {x | â†‘R < |(Î¼[f|m]) x|} Î¼).2âŸ©
  refine setLIntegral_mono measurable_const.nnnorm.coe_nnreal_ennreal
    (stronglyMeasurable_condexp.mono hnm).measurable.nnnorm.coe_nnreal_ennreal fun x hx => ?_
  rw [ENNReal.coe_le_coe, Real.nnnorm_of_nonneg R.coe_nonneg]
  exact Subtype.mk_le_mk.2 (le_of_lt hx)


Verifying proof (Commit f604017518b0630e4b4304f4db58858db24b64e6):
refine ae_bdd_condexp_of_ae_bdd.theorem_eventuallyLE ?_

Attempt failure.

Working on Mathlib/MeasureTheory/Function/Jacobian.lean - 2024-09-09 00:04:37.099860.
---121/200---
For theorem MeasureTheory.map_withDensity_abs_det_fderiv_eq_addHaar in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem map_withDensity_abs_det_fderiv_eq_addHaar (hs : MeasurableSet s)
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) (h'f : Measurable f) :
    Measure.map f ((Î¼.restrict s).withDensity fun x => ENNReal.ofReal |(f' x).det|) =
      Î¼.restrict (f '' s) 


Original valid proof:
:= by
  apply Measure.ext fun t ht => ?_
  rw [map_apply h'f ht, withDensity_apply _ (h'f ht), Measure.restrict_apply ht,
    restrict_restrict (h'f ht),
    lintegral_abs_det_fderiv_eq_addHaar_image Î¼ ((h'f ht).inter hs)
      (fun x hx => (hf' x hx.2).mono inter_subset_right) (hf.mono inter_subset_right),
    image_preimage_inter]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
rw [Measure.restrict_withDensity_abs_det_fderiv_eq_restrict]

Attempt failure.

---122/200---
For theorem MeasureTheory.addHaar_image_eq_zero_of_det_fderivWithin_eq_zero in Mathlib/MeasureTheory/Function/Jacobian.lean:
theorem addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (R : â„) (hs : s âŠ† closedBall 0 R) (Îµ : â„â‰¥0)
    (Îµpos : 0 < Îµ) (h'f' : âˆ€ x âˆˆ s, (f' x).det = 0) : Î¼ (f '' s) â‰¤ Îµ * Î¼ (closedBall 0 R) 


Original valid proof:
:= by
  rcases eq_empty_or_nonempty s with (rfl | h's); Â· simp only [measure_empty, zero_le, image_empty]
  have :
      âˆ€ A : E â†’L[â„] E, âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§
        âˆ€ (t : Set E), ApproximatesLinearOn f A t Î´ â†’
          Î¼ (f '' t) â‰¤ (Real.toNNReal |A.det| + Îµ : â„â‰¥0) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, h'âŸ©
    exact âŸ¨Î´, h', fun t ht => h t f htâŸ©
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, Af'âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      rw [â† image_iUnion, â† inter_iUnion]
      gcongr
      exact subset_inter Subset.rfl t_cover
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Real.toNNReal |(A n).det| + Îµ : â„â‰¥0) * Î¼ (s âˆ© t n) := by
      gcongr
      exact (hÎ´ (A _)).2 _ (ht _)
    _ = âˆ‘' n, Îµ * Î¼ (s âˆ© t n) := by
      congr with n
      rcases Af' h's n with âŸ¨y, ys, hyâŸ©
      simp only [hy, h'f' y ys, Real.toNNReal_zero, abs_zero, zero_add]
    _ â‰¤ Îµ * âˆ‘' n, Î¼ (closedBall 0 R âˆ© t n) := by
      rw [ENNReal.tsum_mul_left]
      gcongr
    _ = Îµ * Î¼ (â‹ƒ n, closedBall 0 R âˆ© t n) := by
      rw [measure_iUnion]
      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
      Â· intro n
        exact measurableSet_closedBall.inter (t_meas n)
    _ â‰¤ Îµ * Î¼ (closedBall 0 R) := by
      rw [â† inter_iUnion]
      exact mul_le_mul_left' (measure_mono inter_subset_left) _


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
have : Î¼ (closedBall 0 R) âŠ† closedBall 0 R := closedBall_subset_closedBall_subset

Attempt failure.

Working on Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean - 2024-09-09 00:05:17.878239.
---123/200---
For theorem MeasureTheory.FinStronglyMeasurable.exists_set_sigmaFinite in Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean:
theorem exists_set_sigmaFinite [Zero Î²] [TopologicalSpace Î²] [T2Space Î²]
    (hf : FinStronglyMeasurable f Î¼) :
    âˆƒ t, MeasurableSet t âˆ§ (âˆ€ x âˆˆ tá¶œ, f x = 0) âˆ§ SigmaFinite (Î¼.restrict t) 


Original valid proof:
:= by
  rcases hf with âŸ¨fs, hT_lt_top, h_approxâŸ©
  let T n := support (fs n)
  have hT_meas : âˆ€ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)
  let t := â‹ƒ n, T n
  refine âŸ¨t, MeasurableSet.iUnion hT_meas, ?_, ?_âŸ©
  Â· have h_fs_zero : âˆ€ n, âˆ€ x âˆˆ tá¶œ, fs n x = 0 := by
      intro n x hxt
      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt
      simpa [T] using hxt n
    refine fun x hxt => tendsto_nhds_unique (h_approx x) ?_
    rw [funext fun n => h_fs_zero n x hxt]
    exact tendsto_const_nhds
  Â· refine âŸ¨âŸ¨âŸ¨fun n => tá¶œ âˆª T n, fun _ => trivial, fun n => ?_, ?_âŸ©âŸ©âŸ©
    Â· rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,
        Set.compl_inter_self t, Set.empty_union]
      exact (measure_mono Set.inter_subset_left).trans_lt (hT_lt_top n)
    Â· rw [â† Set.union_iUnion tá¶œ T]
      exact Set.compl_union_self _


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
refine âŸ¨exists_set_sigmaFinite, exists_set_sigmaFinite, ?_, ?_âŸ©

Attempt failure.

Working on Mathlib/MeasureTheory/Function/UniformIntegrable.lean - 2024-09-09 00:05:38.179041.
---124/200---
For theorem MeasureTheory.unifIntegrable_of' in Mathlib/MeasureTheory/Function/UniformIntegrable.lean:
theorem unifIntegrable_of' (hp : 1 â‰¤ p) (hp' : p â‰  âˆ) {f : Î¹ â†’ Î± â†’ Î²}
    (hf : âˆ€ i, StronglyMeasurable (f i))
    (h : âˆ€ Îµ : â„, 0 < Îµ â†’ âˆƒ C : â„â‰¥0, 0 < C âˆ§
      âˆ€ i, snorm ({ x | C â‰¤ â€–f i xâ€–â‚Š }.indicator (f i)) p Î¼ â‰¤ ENNReal.ofReal Îµ) :
    UnifIntegrable f p Î¼ 


Original valid proof:
:= by
  have hpzero := (lt_of_lt_of_le zero_lt_one hp).ne.symm
  by_cases hÎ¼ : Î¼ Set.univ = 0
  Â· rw [Measure.measure_univ_eq_zero] at hÎ¼
    exact hÎ¼.symm â–¸ unifIntegrable_zero_meas
  intro Îµ hÎµ
  obtain âŸ¨C, hCpos, hCâŸ© := h (Îµ / 2) (half_pos hÎµ)
  refine âŸ¨(Îµ / (2 * C)) ^ ENNReal.toReal p,
    Real.rpow_pos_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos))) _,
    fun i s hs hÎ¼s => ?_âŸ©
  by_cases hÎ¼s' : Î¼ s = 0
  Â· rw [(snorm_eq_zero_iff ((hf i).indicator hs).aestronglyMeasurable hpzero).2
        (indicator_meas_zero hÎ¼s')]
    norm_num
  calc
    snorm (Set.indicator s (f i)) p Î¼ â‰¤
        snorm (Set.indicator (s âˆ© { x | C â‰¤ â€–f i xâ€–â‚Š }) (f i)) p Î¼ +
          snorm (Set.indicator (s âˆ© { x | â€–f i xâ€–â‚Š < C }) (f i)) p Î¼ := by
      refine le_trans (Eq.le ?_) (snorm_add_le
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter (stronglyMeasurable_const.measurableSet_le (hf i).nnnorm))))
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter ((hf i).nnnorm.measurableSet_lt stronglyMeasurable_const))))
        hp)
      congr
      change _ = fun x => (s âˆ© { x : Î± | C â‰¤ â€–f i xâ€–â‚Š }).indicator (f i) x +
        (s âˆ© { x : Î± | â€–f i xâ€–â‚Š < C }).indicator (f i) x
      rw [â† Set.indicator_union_of_disjoint]
      Â· rw [â† Set.inter_union_distrib_left, (by ext; simp [le_or_lt] :
            { x : Î± | C â‰¤ â€–f i xâ€–â‚Š } âˆª { x : Î± | â€–f i xâ€–â‚Š < C } = Set.univ),
          Set.inter_univ]
      Â· refine (Disjoint.inf_right' _ ?_).inf_left' _
        rw [disjoint_iff_inf_le]
        rintro x âŸ¨hxâ‚, hxâ‚‚âŸ©
        rw [Set.mem_setOf_eq] at hxâ‚ hxâ‚‚
        exact False.elim (hxâ‚‚.ne (eq_of_le_of_not_lt hxâ‚ (not_lt.2 hxâ‚‚.le)).symm)
    _ â‰¤ snorm (Set.indicator { x | C â‰¤ â€–f i xâ€–â‚Š } (f i)) p Î¼ +
        (C : â„â‰¥0âˆ) * Î¼ s ^ (1 / ENNReal.toReal p) := by
      refine add_le_add
        (snorm_mono fun x => norm_indicator_le_of_subset Set.inter_subset_right _ _) ?_
      rw [â† Set.indicator_indicator]
      rw [snorm_indicator_eq_snorm_restrict hs]
      have : âˆ€áµ x âˆ‚Î¼.restrict s, â€–{ x : Î± | â€–f i xâ€–â‚Š < C }.indicator (f i) xâ€– â‰¤ C := by
        filter_upwards
        simp_rw [norm_indicator_eq_indicator_norm]
        exact Set.indicator_le' (fun x (hx : _ < _) => hx.le) fun _ _ => NNReal.coe_nonneg _
      refine le_trans (snorm_le_of_ae_bound this) ?_
      rw [mul_comm, Measure.restrict_apply' hs, Set.univ_inter, ENNReal.ofReal_coe_nnreal, one_div]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + C * ENNReal.ofReal (Îµ / (2 * C)) := by
      refine add_le_add (hC i) (mul_le_mul_left' ?_ _)
      rwa [ENNReal.rpow_one_div_le_iff (ENNReal.toReal_pos hpzero hp'),
        ENNReal.ofReal_rpow_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos)))]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + ENNReal.ofReal (Îµ / 2) := by
      refine add_le_add_left ?_ _
      rw [â† ENNReal.ofReal_coe_nnreal, â† ENNReal.ofReal_mul (NNReal.coe_nonneg _), â† div_div,
        mul_div_cancelâ‚€ _ (NNReal.coe_pos.2 hCpos).ne.symm]
    _ â‰¤ ENNReal.ofReal Îµ := by
      rw [â† ENNReal.ofReal_add (half_pos hÎµ).le (half_pos hÎµ).le, add_halves]


Verifying proof (Commit 66c0098b0b62ad14d9c618b402e7673658137a7e):
refine UnifIntegrable.unifIntegrable_theorem_unifIntegrable_of' hp hp' hf hf hf hf hf

Attempt failure.

Working on Mathlib/MeasureTheory/Group/Action.lean - 2024-09-09 00:05:58.586471.
---125/200---
For theorem MeasureTheory.smulInvariantMeasure_tfae in Mathlib/MeasureTheory/Group/Action.lean:
theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G Î± Î¼,
        âˆ€ (c : G) (s), MeasurableSet s â†’ Î¼ ((c â€¢ Â·) â»Â¹' s) = Î¼ s,
        âˆ€ (c : G) (s), MeasurableSet s â†’ Î¼ (c â€¢ s) = Î¼ s,
        âˆ€ (c : G) (s), Î¼ ((c â€¢ Â·) â»Â¹' s) = Î¼ s,
        âˆ€ (c : G) (s), Î¼ (c â€¢ s) = Î¼ s,
        âˆ€ c : G, Measure.map (c â€¢ Â·) Î¼ = Î¼,
        âˆ€ c : G, MeasurePreserving (c â€¢ Â·) Î¼ Î¼] 


Original valid proof:
:= by
  tfae_have 1 â†” 2
  Â· exact âŸ¨fun h => h.1, fun h => âŸ¨hâŸ©âŸ©
  tfae_have 1 â†’ 6
  Â· intro h c
    exact (measurePreserving_smul c Î¼).map_eq
  tfae_have 6 â†’ 7
  Â· exact fun H c => âŸ¨measurable_const_smul c, H câŸ©
  tfae_have 7 â†’ 4
  Â· exact fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)
  tfae_have 4 â†’ 5
  Â· exact fun H c s => by
      rw [â† preimage_smul_inv]
      apply H
  tfae_have 5 â†’ 3
  Â· exact fun H c s _ => H c s
  tfae_have 3 â†’ 2
  Â· intro H c s hs
    rw [preimage_smul]
    exact H câ»Â¹ s hs
  tfae_finish


Verifying proof (Commit fba28f571f3d12084f060ccc0fd73ca4e275ccce):
have smulInvariantMeasure_tfae smulInvariantMeasure_tfae smulInvariantMeasure_tfae

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/Bochner.lean - 2024-09-09 00:06:19.131472.
---126/200---
For theorem MeasureTheory.ae_le_trim_of_stronglyMeasurable in Mathlib/MeasureTheory/Integral/Bochner.lean:
theorem ae_le_trim_of_stronglyMeasurable [LinearOrder Î³] [TopologicalSpace Î³]
    [OrderClosedTopology Î³] [PseudoMetrizableSpace Î³] (hm : m â‰¤ m0) {f g : Î² â†’ Î³}
    (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) (hfg : f â‰¤áµ[Î¼] g) :
    f â‰¤áµ[Î¼.trim hm] g 


Original valid proof:
:= by
  rwa [EventuallyLE, ae_iff, trim_measurableSet_eq hm]
  exact (hf.measurableSet_le hg).compl


Verifying proof (Commit 5c3b19457914190f5f82a4845a908a6fa667ed79):
rw [trim_eq_trim_iff] at hfg

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/CircleIntegral.lean - 2024-09-09 00:06:39.296455.
---127/200---
For theorem circleIntegral.norm_integral_lt_of_norm_le_const_of_lt in Mathlib/MeasureTheory/Integral/CircleIntegral.lean:
theorem norm_integral_lt_of_norm_le_const_of_lt {f : â„‚ â†’ E} {c : â„‚} {R C : â„} (hR : 0 < R)
    (hc : ContinuousOn f (sphere c R)) (hf : âˆ€ z âˆˆ sphere c R, â€–f zâ€– â‰¤ C)
    (hlt : âˆƒ z âˆˆ sphere c R, â€–f zâ€– < C) : â€–âˆ® z in C(c, R), f zâ€– < 2 * Ï€ * R * C 


Original valid proof:
:= by
  rw [â† _root_.abs_of_pos hR, â† image_circleMap_Ioc] at hlt
  rcases hlt with âŸ¨_, âŸ¨Î¸â‚€, hmem, rflâŸ©, hltâŸ©
  calc
    â€–âˆ® z in C(c, R), f zâ€– â‰¤ âˆ« Î¸ in (0)..2 * Ï€, â€–deriv (circleMap c R) Î¸ â€¢ f (circleMap c R Î¸)â€– :=
      intervalIntegral.norm_integral_le_integral_norm Real.two_pi_pos.le
    _ < âˆ« _ in (0)..2 * Ï€, R * C := by
      simp only [norm_smul, deriv_circleMap, norm_eq_abs, map_mul, abs_I, mul_one,
        abs_circleMap_zero, abs_of_pos hR]
      refine intervalIntegral.integral_lt_integral_of_continuousOn_of_le_of_exists_lt
          Real.two_pi_pos ?_ continuousOn_const (fun Î¸ _ => ?_) âŸ¨Î¸â‚€, Ioc_subset_Icc_self hmem, ?_âŸ©
      Â· exact continuousOn_const.mul (hc.comp (continuous_circleMap _ _).continuousOn fun Î¸ _ =>
          circleMap_mem_sphere _ hR.le _).norm
      Â· exact mul_le_mul_of_nonneg_left (hf _ <| circleMap_mem_sphere _ hR.le _) hR.le
      Â· exact (mul_lt_mul_left hR).2 hlt
    _ = 2 * Ï€ * R * C := by simp [mul_assoc]; ring


Verifying proof (Commit e92ad7acc4d771729f70601a74a3c091f330e507):
rcases hlt with âŸ¨z, hz, hzRâŸ©

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/Lebesgue.lean - 2024-09-09 00:07:00.005410.
---128/200---
For theorem MeasureTheory.lintegral_liminf_le in Mathlib/MeasureTheory/Integral/Lebesgue.lean:
theorem lintegral_liminf_le' {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} (h_meas : âˆ€ n, AEMeasurable (f n) Î¼) :
    âˆ«â» a, liminf (fun n => f n a) atTop âˆ‚Î¼ â‰¤ liminf (fun n => âˆ«â» a, f n a âˆ‚Î¼) atTop 


Original valid proof:
:=
  calc
    âˆ«â» a, liminf (fun n => f n a) atTop âˆ‚Î¼ = âˆ«â» a, â¨† n : â„•, â¨… i â‰¥ n, f i a âˆ‚Î¼ := by
      simp only [liminf_eq_iSup_iInf_of_nat]
    _ = â¨† n : â„•, âˆ«â» a, â¨… i â‰¥ n, f i a âˆ‚Î¼ :=
      (lintegral_iSup' (fun n => aemeasurable_biInf _ (to_countable _) (fun i _ â†¦ h_meas i))
        (ae_of_all Î¼ fun a n m hnm => iInf_le_iInf_of_subset fun i hi => le_trans hnm hi))
    _ â‰¤ â¨† n : â„•, â¨… i â‰¥ n, âˆ«â» a, f i a âˆ‚Î¼ := iSup_mono fun n => le_iInfâ‚‚_lintegral _
    _ = atTop.liminf fun n => âˆ«â» a, f n a âˆ‚Î¼ := Filter.liminf_eq_iSup_iInf_of_nat.symm


Verifying proof (Commit 3f9dee6adf287742f66dfda5079840cb2497af69):
refine liminf_le_liminf_of_le (fun n => liminf (fun n => f n a âˆ‚Î¼) atTop) ?_

Attempt failure.

Working on Mathlib/MeasureTheory/Integral/SetIntegral.lean - 2024-09-09 00:07:20.433209.
---129/200---
For theorem MeasureTheory.integral_finset_biUnion in Mathlib/MeasureTheory/Integral/SetIntegral.lean:
theorem integral_finset_biUnion {Î¹ : Type*} (t : Finset Î¹) {s : Î¹ â†’ Set X}
    (hs : âˆ€ i âˆˆ t, MeasurableSet (s i)) (h's : Set.Pairwise (â†‘t) (Disjoint on s))
    (hf : âˆ€ i âˆˆ t, IntegrableOn f (s i) Î¼) :
    âˆ« x in â‹ƒ i âˆˆ t, s i, f x âˆ‚Î¼ = âˆ‘ i âˆˆ t, âˆ« x in s i, f x âˆ‚Î¼ 


Original valid proof:
:= by
  induction' t using Finset.induction_on with a t hat IH hs h's
  Â· simp
  Â· simp only [Finset.coe_insert, Finset.forall_mem_insert, Set.pairwise_insert,
      Finset.set_biUnion_insert] at hs hf h's âŠ¢
    rw [integral_union _ _ hf.1 (integrableOn_finset_iUnion.2 hf.2)]
    Â· rw [Finset.sum_insert hat, IH hs.2 h's.1 hf.2]
    Â· simp only [disjoint_iUnion_right]
      exact fun i hi => (h's.2 i hi (ne_of_mem_of_not_mem hi hat).symm).1
    Â· exact Finset.measurableSet_biUnion _ hs.2


Verifying proof (Commit 25e538f3a737a71314ac143929711e67d0b14d73):
simp only [iUnion_iUnion_eq_iUnion_integral_finset_biUnion]

Attempt failure.

Working on Mathlib/MeasureTheory/MeasurableSpace/Basic.lean - 2024-09-09 00:07:40.753687.
---130/200---
For theorem exists_measurable_piecewise in Mathlib/MeasureTheory/MeasurableSpace/Basic.lean:
theorem exists_measurable_piecewise {Î¹} [Countable Î¹] [Nonempty Î¹] (t : Î¹ â†’ Set Î±)
    (t_meas : âˆ€ n, MeasurableSet (t n)) (g : Î¹ â†’ Î± â†’ Î²) (hg : âˆ€ n, Measurable (g n))
    (ht : Pairwise fun i j => EqOn (g i) (g j) (t i âˆ© t j)) :
    âˆƒ f : Î± â†’ Î², Measurable f âˆ§ âˆ€ n, EqOn f (g n) (t n) 


Original valid proof:
:= by
  inhabit Î¹
  set g' : (i : Î¹) â†’ t i â†’ Î² := fun i => g i âˆ˜ (â†‘)
  have ht' : âˆ€ (i j) (x : Î±) (hxi : x âˆˆ t i) (hxj : x âˆˆ t j), g' i âŸ¨x, hxiâŸ© = g' j âŸ¨x, hxjâŸ© := by
    intro i j x hxi hxj
    rcases eq_or_ne i j with rfl | hij
    Â· rfl
    Â· exact ht hij âŸ¨hxi, hxjâŸ©
  set f : (â‹ƒ i, t i) â†’ Î² := iUnionLift t g' ht' _ Subset.rfl
  have hfm : Measurable f := measurable_iUnionLift _ _ t_meas
    (fun i => (hg i).comp measurable_subtype_coe)
  classical
    refine âŸ¨fun x => if hx : x âˆˆ â‹ƒ i, t i then f âŸ¨x, hxâŸ© else g default x,
      hfm.dite ((hg default).comp measurable_subtype_coe) (.iUnion t_meas), fun i x hx => ?_âŸ©
    simp only [dif_pos (mem_iUnion.2 âŸ¨i, hxâŸ©)]
    exact iUnionLift_of_mem âŸ¨x, mem_iUnion.2 âŸ¨i, hxâŸ©âŸ© hx


Verifying proof (Commit 4449fea6cb71b0c9863e5f2aaa338fd940fe3afa):
refine âŸ¨exists_measurable_piecewise fun i j hi => ?_, fun i j hi => ?_âŸ©

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/AddContent.lean - 2024-09-09 00:07:49.568702.
---131/200---
For theorem MeasureTheory.addContent_union' in Mathlib/MeasureTheory/Measure/AddContent.lean:
lemma addContent_union' (hs : s âˆˆ C) (ht : t âˆˆ C) (hst : s âˆª t âˆˆ C) (h_dis : Disjoint s t) :
    m (s âˆª t) = m s + m t 


Original valid proof:
:= by
  by_cases hs_empty : s = âˆ…
  Â· simp only [hs_empty, Set.empty_union, addContent_empty, zero_add]
  classical
  have h := addContent_sUnion (m := m) (I := {s, t}) ?_ ?_ ?_
  rotate_left
  Â· simp only [coe_pair, Set.insert_subset_iff, hs, ht, Set.singleton_subset_iff, and_self_iff]
  Â· simp only [coe_pair, Set.pairwiseDisjoint_insert, pairwiseDisjoint_singleton,
      mem_singleton_iff, Ne, id, forall_eq, true_and_iff]
    exact fun _ => h_dis
  Â· simp only [coe_pair, sUnion_insert, sUnion_singleton]
    exact hst
  convert h
  Â· simp only [coe_pair, sUnion_insert, sUnion_singleton]
  Â· rw [sum_insert, sum_singleton]
    simp only [Finset.mem_singleton]
    refine fun hs_eq_t => hs_empty ?_
    rw [â† hs_eq_t] at h_dis
    exact Disjoint.eq_bot_of_self h_dis


Verifying proof (Commit 26c29dc27c999d53a30ed03b6e655c799e1675d8):
rw [â† mem_union, â† mem_union, â† mem_union, â† mem_union, â† mem_union]

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Haar/Quotient.lean - 2024-09-09 00:07:55.357523.
---132/200---
For theorem QuotientGroup.integral_mul_eq_integral_automorphize_mul in Mathlib/MeasureTheory/Measure/Haar/Quotient.lean:
lemma QuotientGroup.integral_mul_eq_integral_automorphize_mul {K : Type*} [NormedField K]
    [NormedSpace â„ K] [Î¼.IsMulRightInvariant] {f : G â†’ K}
    (f_â„’_1 : Integrable f Î¼) {g : G â§¸ Î“ â†’ K} (hg : AEStronglyMeasurable g Î¼_ğ“•)
    (g_â„’_infinity : essSup (fun x â†¦ â†‘â€–g xâ€–â‚Š) Î¼_ğ“• â‰  âˆ)
    (F_ae_measurable : AEStronglyMeasurable (QuotientGroup.automorphize f) Î¼_ğ“•) :
    âˆ« x : G, g (x : G â§¸ Î“) * (f x) âˆ‚Î¼
      = âˆ« x : G â§¸ Î“, g x * (QuotientGroup.automorphize f x) âˆ‚Î¼_ğ“• 


Original valid proof:
:= by
  let Ï€ : G â†’ G â§¸ Î“ := QuotientGroup.mk
  have meas_Ï€ : Measurable Ï€ := continuous_quotient_mk'.measurable
  have Hâ‚€ : QuotientGroup.automorphize ((g âˆ˜ Ï€) * f) = g * (QuotientGroup.automorphize f) := by
    exact QuotientGroup.automorphize_smul_left f g
  calc âˆ« (x : G), g (Ï€ x) * (f x) âˆ‚Î¼ =
        âˆ« (x : G â§¸ Î“), QuotientGroup.automorphize ((g âˆ˜ Ï€) * f) x âˆ‚Î¼_ğ“• := ?_
    _ = âˆ« (x : G â§¸ Î“), g x * (QuotientGroup.automorphize f x) âˆ‚Î¼_ğ“• := by simp [Hâ‚€]
  have Hâ‚ : Integrable ((g âˆ˜ Ï€) * f) Î¼ := by
    have : AEStronglyMeasurable (fun (x : G) â†¦ g (x : (G â§¸ Î“))) Î¼ :=
      (hg.mono_ac hğ“•.absolutelyContinuous_map).comp_measurable meas_Ï€
    refine Integrable.essSup_smul f_â„’_1 this ?_
    have hg' : AEStronglyMeasurable (fun x â†¦ (â€–g xâ€–â‚Š : â„â‰¥0âˆ)) Î¼_ğ“• :=
      (ENNReal.continuous_coe.comp continuous_nnnorm).comp_aestronglyMeasurable hg
    rw [â† essSup_comp_quotientGroup_mk hğ“• hg'.aemeasurable]
    exact g_â„’_infinity
  have Hâ‚‚ : AEStronglyMeasurable (QuotientGroup.automorphize ((g âˆ˜ Ï€) * f)) Î¼_ğ“• := by
    simp_rw [Hâ‚€]
    exact hg.mul F_ae_measurable
  apply QuotientGroup.integral_eq_integral_automorphize hğ“• Hâ‚ Hâ‚‚


Verifying proof (Commit 01d739c14a27d96463129c57bbb1982309f33ea6):
simp only [QuotientGroup.automorphize_automorphize, QuotientGroup.automorphize_automorphize,
  QuotientGroup.automorphize_automorphize]

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/HasOuterApproxClosed.lean - 2024-09-09 00:08:15.843785.
---133/200---
For theorem MeasureTheory.ext_of_forall_lintegral_eq_of_IsFiniteMeasure in Mathlib/MeasureTheory/Measure/HasOuterApproxClosed.lean:
theorem ext_of_forall_lintegral_eq_of_IsFiniteMeasure {Î© : Type*}
    [MeasurableSpace Î©] [TopologicalSpace Î©] [HasOuterApproxClosed Î©]
    [BorelSpace Î©] {Î¼ Î½ : Measure Î©} [IsFiniteMeasure Î¼]
    (h : âˆ€ (f : Î© â†’áµ‡ â„â‰¥0), âˆ«â» x, f x âˆ‚Î¼ = âˆ«â» x, f x âˆ‚Î½) :
    Î¼ = Î½ 


Original valid proof:
:= by
  have key := @measure_isClosed_eq_of_forall_lintegral_eq_of_isFiniteMeasure Î© _ _ _ _ Î¼ Î½ _ h
  apply ext_of_generate_finite _ ?_ isPiSystem_isClosed
  Â· exact fun F F_closed â†¦ key F_closed
  Â· exact key isClosed_univ
  Â· rw [BorelSpace.measurable_eq (Î± := Î©), borel_eq_generateFrom_isClosed]


Verifying proof (Commit b06172d4564b9175743e7c2bc9a24868a9516c7f):
simp_rw [ext_of_forall_lintegral_eq_of_isFiniteMeasure_eq_theorem]

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Hausdorff.lean - 2024-09-09 00:08:36.419693.
---134/200---
For theorem Isometry.hausdorffMeasure_image in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s 


Original valid proof:
:= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
rw [â† hausdorffMeasure_image_le, hausdorffMeasure_image_le, hausdorffMeasure_image_le]

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/MeasureSpace.lean - 2024-09-09 00:08:56.575353.
---135/200---
For theorem MeasureTheory.measure_limsup_eq_zero in Mathlib/MeasureTheory/Measure/MeasureSpace.lean:
theorem measure_limsup_eq_zero {s : â„• â†’ Set Î±} (hs : (âˆ‘' i, Î¼ (s i)) â‰  âˆ) :
    Î¼ (limsup s atTop) = 0 


Original valid proof:
:= by
  set t : â„• â†’ Set Î± := fun n => toMeasurable Î¼ (s n)
  have ht : (âˆ‘' i, Î¼ (t i)) â‰  âˆ := by simpa only [t, measure_toMeasurable] using hs
  suffices Î¼ (limsup t atTop) = 0 by
    have A : s â‰¤ t := fun n => subset_toMeasurable Î¼ (s n)
    exact measure_mono_null (limsup_le_limsup (eventually_of_forall (Pi.le_def.mp A))) this
  simp only [limsup_eq_iInf_iSup_of_nat', Set.iInf_eq_iInter, Set.iSup_eq_iUnion, â†
    nonpos_iff_eq_zero]
  refine
    le_of_tendsto_of_tendsto'
      (tendsto_measure_iInter
        (fun i => MeasurableSet.iUnion fun b => measurableSet_toMeasurable _ _) ?_
        âŸ¨0, ne_top_of_le_ne_top ht (measure_iUnion_le t)âŸ©)
      (ENNReal.tendsto_sum_nat_add (Î¼ âˆ˜ t) ht) fun n => measure_iUnion_le _
  intro n m hnm x
  simp only [Set.mem_iUnion]
  exact fun âŸ¨i, hiâŸ© => âŸ¨i + (m - n), by simpa only [add_assoc, tsub_add_cancel_of_le hnm] using hiâŸ©


Verifying proof (Commit 464f10c2e8d95b797cf97f9520e276bb51b872af):
rw [limsup_eq_limsup_eq_zero]

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/VectorMeasure.lean - 2024-09-09 00:09:17.328618.
---136/200---
For theorem MeasureTheory.VectorMeasure.MutuallySingular.add_left in Mathlib/MeasureTheory/Measure/VectorMeasure.lean:
theorem add_left [T2Space N] [ContinuousAdd M] (hâ‚ : vâ‚ âŸ‚áµ¥ w) (hâ‚‚ : vâ‚‚ âŸ‚áµ¥ w) : vâ‚ + vâ‚‚ âŸ‚áµ¥ w 


Original valid proof:
:= by
  obtain âŸ¨u, hmu, huâ‚, huâ‚‚âŸ© := hâ‚
  obtain âŸ¨v, hmv, hvâ‚, hvâ‚‚âŸ© := hâ‚‚
  refine mk (u âˆ© v) (hmu.inter hmv) (fun t ht _ => ?_) fun t ht hmt => ?_
  Â· rw [add_apply, huâ‚ _ (Set.subset_inter_iff.1 ht).1, hvâ‚ _ (Set.subset_inter_iff.1 ht).2,
      zero_add]
  Â· rw [Set.compl_inter] at ht
    rw [(_ : t = uá¶œ âˆ© t âˆª vá¶œ \ uá¶œ âˆ© t),
      of_union _ (hmu.compl.inter hmt) ((hmv.compl.diff hmu.compl).inter hmt), huâ‚‚, hvâ‚‚, add_zero]
    Â· exact Set.Subset.trans Set.inter_subset_left diff_subset
    Â· exact Set.inter_subset_left
    Â· exact disjoint_sdiff_self_right.mono Set.inter_subset_left Set.inter_subset_left
    Â· apply Set.Subset.antisymm <;> intro x hx
      Â· by_cases hxu' : x âˆˆ uá¶œ
        Â· exact Or.inl âŸ¨hxu', hxâŸ©
        rcases ht hx with (hxu | hxv)
        exacts [False.elim (hxu' hxu), Or.inr âŸ¨âŸ¨hxv, hxu'âŸ©, hxâŸ©]
      Â· cases' hx with hx hx <;> exact hx.2


Verifying proof (Commit a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0):
rw [ContinuousAdd, ContinuousAdd, ContinuousAdd, ContinuousAdd, ContinuousAdd,
  ContinuousAdd]

Attempt failure.

Working on Mathlib/ModelTheory/Satisfiability.lean - 2024-09-09 00:09:37.840039.
---137/200---
For theorem FirstOrder.Language.Theory.models_iff_not_satisfiable in Mathlib/ModelTheory/Satisfiability.lean:
theorem models_iff_not_satisfiable (Ï† : L.Sentence) : T âŠ¨áµ‡ Ï† â†” Â¬IsSatisfiable (T âˆª {Ï†.not}) 


Original valid proof:
:= by
  rw [models_sentence_iff, IsSatisfiable]
  refine
    âŸ¨fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T âˆª {Formula.not Ï†})
          (Set.subset_union_right (Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel Set.subset_union_left)),
      fun h M => ?_âŸ©
  contrapose! h
  rw [â† Sentence.realize_not] at h
  refine
    âŸ¨{  Carrier := M
        is_model := âŸ¨fun Ïˆ hÏˆ => hÏˆ.elim (realize_sentence_of_mem _) fun h' => ?_âŸ© }âŸ©
  rw [Set.mem_singleton_iff.1 h']
  exact h


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
refine âŸ¨fun h => ?_, fun h => ?_âŸ©

Attempt failure.

Working on Mathlib/NumberTheory/Bernoulli.lean - 2024-09-09 00:09:50.763512.
---138/200---
For theorem bernoulli'_odd_eq_zero in Mathlib/NumberTheory/Bernoulli.lean:
theorem bernoulli'_odd_eq_zero {n : â„•} (h_odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0 


Original valid proof:
:= by
  let B := mk fun n => bernoulli' n / (n ! : â„š)
  suffices (B - evalNegHom B) * (exp â„š - 1) = X * (exp â„š - 1) by
    cases' mul_eq_mul_right_iff.mp this with h h <;>
      simp only [PowerSeries.ext_iff, evalNegHom, coeff_X] at h
    Â· apply eq_zero_of_neg_eq
      specialize h n
      split_ifs at h <;> simp_all [B, h_odd.neg_one_pow, factorial_ne_zero]
    Â· simpa (config := {decide := true}) [Nat.factorial] using h 1
  have h : B * (exp â„š - 1) = X * exp â„š := by
    simpa [bernoulli'PowerSeries] using bernoulli'PowerSeries_mul_exp_sub_one â„š
  rw [sub_mul, h, mul_sub X, sub_right_inj, â† neg_sub, mul_neg, neg_eq_iff_eq_neg]
  suffices evalNegHom (B * (exp â„š - 1)) * exp â„š = evalNegHom (X * exp â„š) * exp â„š by
    rw [map_mul, map_mul] at this 
    simpa [mul_assoc, sub_mul, mul_comm (evalNegHom (exp â„š)), exp_mul_exp_neg_eq_one]
  congr


Verifying proof (Commit 1737baecc8d3128fff663633128256ff0699ff55):
rw [bernoulli'_odd_eq_zero]

Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean - 2024-09-09 00:10:10.855176.
---139/200---
For theorem Polynomial.exists_partition_polynomial in Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean:
theorem exists_partition_polynomial_aux (n : â„•) {Îµ : â„} (hÎµ : 0 < Îµ) {b : Fq[X]} (hb : b â‰  0)
    (A : Fin n â†’ Fq[X]) : âˆƒ t : Fin n â†’ Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log (Fintype.card Fq)âŒ‰â‚Š),
      âˆ€ iâ‚€ iâ‚ : Fin n, t iâ‚€ = t iâ‚ â†”
        (cardPowDegree (A iâ‚ % b - A iâ‚€ % b) : â„) < cardPowDegree b â€¢ Îµ 


Original valid proof:
:= by
  have hbÎµ : 0 < cardPowDegree b â€¢ Îµ := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hÎµ
  induction' n with n ih
  Â· refine âŸ¨finZeroElim, finZeroElimâŸ©
  have anti_archim' : âˆ€ {i j k} {Îµ : â„},
    (cardPowDegree (A i % b - A j % b) : â„) < Îµ â†’
      (cardPowDegree (A j % b - A k % b) : â„) < Îµ â†’
        (cardPowDegree (A i % b - A k % b) : â„) < Îµ := by
    intro i j k Îµ
    simp_rw [â† Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain âŸ¨t', ht'âŸ© := ih (Fin.tail A)
  rsuffices âŸ¨j, hjâŸ© :
    âˆƒ j, âˆ€ i, t' i = j â†” (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· refine âŸ¨Fin.cons j t', fun iâ‚€ iâ‚ => ?_âŸ©
    refine Fin.cases ?_ (fun iâ‚€ => ?_) iâ‚€ <;> refine Fin.cases ?_ (fun iâ‚ => ?_) iâ‚
    Â· simpa using hbÎµ
    Â· rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj iâ‚
    Â· rw [Fin.cons_succ, Fin.cons_zero]
      exact hj iâ‚€
    Â· rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' iâ‚€ iâ‚
  obtain âŸ¨j, hjâŸ© : âˆƒ j, âˆ€ i : Fin n,
      t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ := by
    by_contra! hg
    obtain âŸ¨jâ‚€, jâ‚, j_ne, approxâŸ© := exists_approx_polynomial hb hÎµ
      (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (hg j))))
    revert j_ne approx
    refine Fin.cases ?_ (fun jâ‚€ => ?_) jâ‚€ <;>
      refine Fin.cases (fun j_ne approx => ?_) (fun jâ‚ j_ne approx => ?_) jâ‚
    Â· exact absurd rfl j_ne
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg jâ‚)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le] at approx
      have := (Classical.choose_spec (hg jâ‚€)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne, Fin.succ_inj] at j_ne
      have : jâ‚€ = jâ‚ := (Classical.choose_spec (hg jâ‚€)).1.symm.trans
        (((ht' (Classical.choose (hg jâ‚€)) (Classical.choose (hg jâ‚))).mpr approx).trans
          (Classical.choose_spec (hg jâ‚)).1)
      contradiction
  by_cases exists_nonempty_j : âˆƒ j, (âˆƒ i, t' i = j) âˆ§
      âˆ€ i, t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· obtain âŸ¨j, âŸ¨i, hiâŸ©, hjâŸ© := exists_nonempty_j
    refine âŸ¨j, fun i' => âŸ¨hj i', fun hi' => _root_.trans ((ht' _ _).mpr ?_) hiâŸ©âŸ©
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  refine âŸ¨j, fun i => âŸ¨hj i, fun hi => ?_âŸ©âŸ©
  have := exists_nonempty_j âŸ¨t' i, âŸ¨i, rflâŸ©, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')âŸ©
  contradiction


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
refine âŸ¨exists_partition_polynomial_polynomial_polynomial_polynomial_polynomial_polynomial_aux,
  exists_partition_polynomial_polynomial_polynomial_polynomial_polynomial_polynomial_polynomial_aux,
  exists_partition_polynomial_polynomial_polynomial_polynomial_auxâŸ©

Attempt failure.

Working on Mathlib/NumberTheory/ClassNumber/Finite.lean - 2024-09-09 00:10:31.242451.
---140/200---
For theorem ClassGroup.exists_mem_finsetApprox in Mathlib/NumberTheory/ClassNumber/Finite.lean:
theorem exists_mem_finsetApprox (a : S) {b} (hb : b â‰  (0 : R)) :
    âˆƒ q : S,
      âˆƒ r âˆˆ finsetApprox bS adm, abv (Algebra.norm R (r â€¢ a - b â€¢ q)) <
      abv (Algebra.norm R (algebraMap R S b)) 


Original valid proof:
:= by
  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty
  set Îµ : â„ := normBound abv bS ^ (-1 / Fintype.card Î¹ : â„) with Îµ_eq
  have hÎµ : 0 < Îµ := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _
  have Îµ_le : (normBound abv bS : â„) * (abv b â€¢ Îµ) ^ (Fintype.card Î¹ : â„)
                â‰¤ abv b ^ (Fintype.card Î¹ : â„) := by
    have := normBound_pos abv bS
    have := abv.nonneg b
    rw [Îµ_eq, Algebra.smul_def, eq_intCast, mul_rpow, â† rpow_mul, div_mul_cancelâ‚€, rpow_neg_one,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_natCast] <;>
      try norm_cast; omega
    Â· exact Iff.mpr Int.cast_nonneg this
    Â· linarith
  set Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm with hÎ¼
  let s : Î¹ â†’â‚€ R := bS.repr a
  have s_eq : âˆ€ i, s i = bS.repr a i := fun i => rfl
  let qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i / b
  let rs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i % b
  have r_eq : âˆ€ j i, rs j i = Î¼ j * s i % b := fun i j => rfl
  have Î¼_eq : âˆ€ i j, Î¼ j * s i = b * qs j i + rs j i := by
    intro i j
    rw [r_eq, EuclideanDomain.div_add_mod]
  have Î¼_mul_a_eq : âˆ€ j, Î¼ j â€¢ a = b â€¢ âˆ‘ i, qs j i â€¢ bS i + âˆ‘ i, rs j i â€¢ bS i := by
    intro j
    rw [â† bS.sum_repr a]
    simp only [Î¼, qs, rs, Finset.smul_sum, â† Finset.sum_add_distrib]
    refine Finset.sum_congr rfl fun i _ => ?_
    rw [â† hÎ¼, â† r_eq, â† s_eq, â† mul_smul, Î¼_eq, add_smul, mul_smul, â† Î¼_eq]
  obtain âŸ¨j, k, j_ne_k, hjkâŸ© := adm.exists_approx hÎµ hb fun j i => Î¼ j * s i
  have hjk' : âˆ€ i, (abv (rs k i - rs j i) : â„) < abv b â€¢ Îµ := by simpa only [r_eq] using hjk
  let q := âˆ‘ i, (qs k i - qs j i) â€¢ bS i
  set r := Î¼ k - Î¼ j with r_eq
  refine âŸ¨q, r, (mem_finsetApprox bS adm).mpr ?_, ?_âŸ©
  Â· exact âŸ¨k, j, j_ne_k.symm, rflâŸ©
  have : r â€¢ a - b â€¢ q = âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) := by
    simp only [q, r_eq, sub_smul, Î¼_mul_a_eq, Finset.smul_sum, â† Finset.sum_add_distrib,
      â† Finset.sum_sub_distrib, smul_sub]
    refine Finset.sum_congr rfl fun x _ => ?_
    ring
  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]
  refine Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt ?_ (hjk' i)).trans_le ?_)
  Â· apply le_of_eq
    congr
    simp_rw [map_sum, map_sub, map_smul, Finset.sum_apply',
      Finsupp.sub_apply, Finsupp.smul_apply, Finset.sum_sub_distrib, Basis.repr_self_apply,
      smul_eq_mul, mul_boole, Finset.sum_ite_eq', Finset.mem_univ, if_true]
  Â· exact mod_cast Îµ_le


Verifying proof (Commit 6eab74639023015a7887e2f82e153907286e3801):
rw [theorem_exists_mem_finsetApprox]

Attempt failure.

---141/200---
For theorem ClassGroup.exists_mem_finsetApprox in Mathlib/NumberTheory/ClassNumber/Finite.lean:
theorem exists_mem_finsetApprox (a : S) {b} (hb : b â‰  (0 : R)) :
    âˆƒ q : S,
      âˆƒ r âˆˆ finsetApprox bS adm, abv (Algebra.norm R (r â€¢ a - b â€¢ q)) <
      abv (Algebra.norm R (algebraMap R S b)) 


Original valid proof:
:= by
  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty
  set Îµ : â„ := normBound abv bS ^ (-1 / Fintype.card Î¹ : â„) with Îµ_eq
  have hÎµ : 0 < Îµ := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _
  have Îµ_le : (normBound abv bS : â„) * (abv b â€¢ Îµ) ^ (Fintype.card Î¹ : â„)
                â‰¤ abv b ^ (Fintype.card Î¹ : â„) := by
    have := normBound_pos abv bS
    have := abv.nonneg b
    rw [Îµ_eq, Algebra.smul_def, eq_intCast, mul_rpow, â† rpow_mul, div_mul_cancelâ‚€, rpow_neg_one,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_natCast] <;>
      try norm_cast; omega
    Â· exact Iff.mpr Int.cast_nonneg this
    Â· linarith
  set Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm with hÎ¼
  let s : Î¹ â†’â‚€ R := bS.repr a
  have s_eq : âˆ€ i, s i = bS.repr a i := fun i => rfl
  let qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i / b
  let rs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i % b
  have r_eq : âˆ€ j i, rs j i = Î¼ j * s i % b := fun i j => rfl
  have Î¼_eq : âˆ€ i j, Î¼ j * s i = b * qs j i + rs j i := by
    intro i j
    rw [r_eq, EuclideanDomain.div_add_mod]
  have Î¼_mul_a_eq : âˆ€ j, Î¼ j â€¢ a = b â€¢ âˆ‘ i, qs j i â€¢ bS i + âˆ‘ i, rs j i â€¢ bS i := by
    intro j
    rw [â† bS.sum_repr a]
    simp only [Î¼, qs, rs, Finset.smul_sum, â† Finset.sum_add_distrib]
    refine Finset.sum_congr rfl fun i _ => ?_
    rw [â† hÎ¼, â† r_eq, â† s_eq, â† mul_smul, Î¼_eq, add_smul, mul_smul, â† Î¼_eq]
  obtain âŸ¨j, k, j_ne_k, hjkâŸ© := adm.exists_approx hÎµ hb fun j i => Î¼ j * s i
  have hjk' : âˆ€ i, (abv (rs k i - rs j i) : â„) < abv b â€¢ Îµ := by simpa only [r_eq] using hjk
  let q := âˆ‘ i, (qs k i - qs j i) â€¢ bS i
  set r := Î¼ k - Î¼ j with r_eq
  refine âŸ¨q, r, (mem_finsetApprox bS adm).mpr ?_, ?_âŸ©
  Â· exact âŸ¨k, j, j_ne_k.symm, rflâŸ©
  have : r â€¢ a - b â€¢ q = âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) := by
    simp only [q, r_eq, sub_smul, Î¼_mul_a_eq, Finset.smul_sum, â† Finset.sum_add_distrib,
      â† Finset.sum_sub_distrib, smul_sub]
    refine Finset.sum_congr rfl fun x _ => ?_
    ring
  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]
  refine Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt ?_ (hjk' i)).trans_le ?_)
  Â· apply le_of_eq
    congr
    simp_rw [map_sum, map_sub, map_smul, Finset.sum_apply',
      Finsupp.sub_apply, Finsupp.smul_apply, Finset.sum_sub_distrib, Basis.repr_self_apply,
      smul_eq_mul, mul_boole, Finset.sum_ite_eq', Finset.mem_univ, if_true]
  Â· exact mod_cast Îµ_le


Verifying proof (Commit 6d1b77e97159c51b0084f053ab93299f39b3a009):
rw [theorem_exists_mem_finsetApprox]

Attempt failure.

Working on Mathlib/NumberTheory/Cyclotomic/Basic.lean - 2024-09-09 00:11:11.593334.
---142/200---
For theorem IsCyclotomicExtension.iff_union_of_dvd in Mathlib/NumberTheory/Cyclotomic/Basic.lean:
theorem iff_union_of_dvd (h : âˆ€ s âˆˆ S, n âˆ£ s) (hS : S.Nonempty) :
    IsCyclotomicExtension S A B â†” IsCyclotomicExtension (S âˆª {n}) A B 


Original valid proof:
:= by
  refine
    âŸ¨fun H => of_union_of_dvd A B h hS, fun H => (iff_adjoin_eq_top _ A _).2 âŸ¨fun s hs => ?_, ?_âŸ©âŸ©
  Â· exact H.exists_prim_root (subset_union_left hs)
  Â· rw [_root_.eq_top_iff, â† ((iff_adjoin_eq_top _ A B).1 H).2]
    refine adjoin_mono fun x hx => ?_
    simp only [union_singleton, mem_insert_iff, mem_setOf_eq] at hx âŠ¢
    obtain âŸ¨m, rfl | hm, hxpowâŸ© := hx
    Â· obtain âŸ¨y, hyâŸ© := hS
      refine âŸ¨y, âŸ¨hy, ?_âŸ©âŸ©
      obtain âŸ¨z, rflâŸ© := h y hy
      simp only [PNat.mul_coe, pow_mul, hxpow, one_pow]
    Â· exact âŸ¨m, âŸ¨hm, hxpowâŸ©âŸ©


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
rw [IsCyclotomicExtension, IsCyclotomicExtension, IsCyclotomicExtension]

Attempt failure.

Working on Mathlib/NumberTheory/Cyclotomic/PrimitiveRoots.lean - 2024-09-09 00:11:32.141051.
---143/200---
For theorem IsPrimitiveRoot.norm_eq_one in Mathlib/NumberTheory/Cyclotomic/PrimitiveRoots.lean:
theorem norm_eq_one [IsDomain L] [IsCyclotomicExtension {n} K L] (hn : n â‰  2)
    (hirr : Irreducible (cyclotomic n K)) : norm K Î¶ = 1 


Original valid proof:
:= by
  haveI := IsCyclotomicExtension.neZero' n K L
  by_cases h1 : n = 1
  Â· rw [h1, one_coe, one_right_iff] at hÎ¶
    rw [hÎ¶, show 1 = algebraMap K L 1 by simp, Algebra.norm_algebraMap, one_pow]
  Â· replace h1 : 2 â‰¤ n := by
      by_contra! h
      exact h1 (PNat.eq_one_of_lt_two h)
    rw [â† hÎ¶.powerBasis_gen K, PowerBasis.norm_gen_eq_coeff_zero_minpoly, hÎ¶.powerBasis_gen K, â†
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr,
      (cyclotomic_coeff_zero K h1 : coeff (cyclotomic n K) 0 = 1), mul_one,
      hÎ¶.powerBasis_dim K, â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, natDegree_cyclotomic]
    exact (totient_even <| h1.lt_of_ne hn.symm).neg_one_pow


Verifying proof (Commit b89833e5d8bafbb16f4932576f6eef05071d317b):
rw [norm_eq_one, norm_eq_one, norm_eq_one]

Attempt failure.

Working on Mathlib/NumberTheory/Divisors.lean - 2024-09-09 00:11:52.406469.
---144/200---
For theorem Nat.pos_of_mem_divisors in Mathlib/NumberTheory/Divisors.lean:
theorem pos_of_mem_divisors {m : â„•} (h : m âˆˆ n.divisors) : 0 < m 


Original valid proof:
:= by
  cases m
  Â· rw [mem_divisors, zero_dvd_iff (a := n)] at h
    cases h.2 h.1
  apply Nat.succ_pos


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
rw [mem_divisors] at h

Attempt failure.

Working on Mathlib/NumberTheory/EllipticDivisibilitySequence.lean - 2024-09-09 00:11:58.851596.
---145/200---
For theorem normEDS_four in Mathlib/NumberTheory/EllipticDivisibilitySequence.lean:
lemma normEDS_four : normEDS b c d 4 = d * b 


Original valid proof:
:= by
  erw [normEDS_ofNat, preNormEDS'_four, if_pos <| by decide]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
rw [normEDS_four]

Attempt failure.

Working on Mathlib/NumberTheory/Modular.lean - 2024-09-09 00:12:07.481635.
---146/200---
For theorem ModularGroup.c_eq_zero in Mathlib/NumberTheory/Modular.lean:
theorem c_eq_zero (hz : z âˆˆ ğ’Ÿáµ’) (hg : g â€¢ z âˆˆ ğ’Ÿáµ’) : (â†‘â‚˜g) 1 0 = 0 


Original valid proof:
:= by
  have hp : âˆ€ {g' : SL(2, â„¤)}, g' â€¢ z âˆˆ ğ’Ÿáµ’ â†’ (â†‘â‚˜g') 1 0 â‰  1 := by
    intro g' hg'
    by_contra hc
    let a := (â†‘â‚˜g') 0 0
    let d := (â†‘â‚˜g') 1 1
    have had : T ^ (-a) * g' = S * T ^ d := by rw [g_eq_of_c_eq_one hc]; group
    let w := T ^ (-a) â€¢ g' â€¢ z
    have hâ‚ : w = S â€¢ T ^ d â€¢ z := by simp only [w, â† mul_smul, had]
    replace hâ‚ : normSq w < 1 := hâ‚.symm â–¸ normSq_S_smul_lt_one (one_lt_normSq_T_zpow_smul hz d)
    have hâ‚‚ : 1 < normSq w := one_lt_normSq_T_zpow_smul hg' (-a)
    linarith
  have hn : (â†‘â‚˜g) 1 0 â‰  -1 := by
    intro hc
    replace hc : (â†‘â‚˜(-g)) 1 0 = 1 := by simp [â† neg_eq_iff_eq_neg.mpr hc]
    replace hg : -g â€¢ z âˆˆ ğ’Ÿáµ’ := (SL_neg_smul g z).symm â–¸ hg
    exact hp hg hc
  specialize hp hg
  rcases Int.abs_le_one_iff.mp <| abs_c_le_one hz hg with âŸ¨âŸ© <;> tauto


Verifying proof (Commit f3db3040b24eea7e8cf5c566bd4354149c7dbdc9):
simp only [mul_zero, zero_smul, zero_mul, mul_zero]

Attempt failure.

Working on Mathlib/NumberTheory/ModularForms/JacobiTheta/Bounds.lean - 2024-09-09 00:12:27.899592.
---147/200---
For theorem HurwitzKernelBounds.isBigO_atTop_F_nat_zero_sub in Mathlib/NumberTheory/ModularForms/JacobiTheta/Bounds.lean:
lemma isBigO_atTop_F_nat_zero_sub {a : â„} (ha : 0 â‰¤ a) : âˆƒ p, 0 < p âˆ§
    (fun t â†¦ F_nat 0 a t - (if a = 0 then 1 else 0)) =O[atTop] fun t â†¦ exp (-p * t) 


Original valid proof:
:= by
  split_ifs with h
  Â· rw [h]
    have : (fun t â†¦ F_nat 0 0 t - 1) =O[atTop] fun t â†¦ rexp (-Ï€ * t) / (1 - rexp (-Ï€ * t)) := by
      apply Eventually.isBigO
      filter_upwards [eventually_gt_atTop 0] with t ht
      exact F_nat_zero_zero_sub_le ht
    refine âŸ¨_, pi_pos, this.trans ?_âŸ©
    simpa using (isBigO_refl (fun t â†¦ rexp (-Ï€ * t)) _).mul isBigO_one_aux
  Â· simp_rw [sub_zero]
    have : (fun t â†¦ F_nat 0 a t) =O[atTop] fun t â†¦ rexp (-Ï€ * a ^ 2 * t) / (1 - rexp (-Ï€ * t)) := by
      apply Eventually.isBigO
      filter_upwards [eventually_gt_atTop 0] with t ht
      exact F_nat_zero_le ha ht
    refine âŸ¨Ï€ * a ^ 2, mul_pos pi_pos (sq_pos_of_ne_zero h), this.trans ?_âŸ©
    simpa only [neg_mul Ï€ (a ^ 2), mul_one] using (isBigO_refl _ _).mul isBigO_one_aux


Verifying proof (Commit 20f51e38436d507b407de72766be0df108b734cf):
split_ifs with h

Attempt failure.

Working on Mathlib/NumberTheory/Padics/PadicVal.lean - 2024-09-09 00:12:49.054061.
---148/200---
For theorem padicValRat.le_padicValRat_add_of_le in Mathlib/NumberTheory/Padics/PadicVal.lean:
theorem le_padicValRat_add_of_le {q r : â„š} (hqr : q + r â‰  0)
    (h : padicValRat p q â‰¤ padicValRat p r) : padicValRat p q â‰¤ padicValRat p (q + r) 


Original valid proof:
:=
  if hq : q = 0 then by simpa [hq] using h
  else
    if hr : r = 0 then by simp [hr]
    else by
      have hqn : q.num â‰  0 := Rat.num_ne_zero.2 hq
      have hqd : (q.den : â„¤) â‰  0 := mod_cast Rat.den_nz _
      have hrn : r.num â‰  0 := Rat.num_ne_zero.2 hr
      have hrd : (r.den : â„¤) â‰  0 := mod_cast Rat.den_nz _
      have hqreq : q + r = (q.num * r.den + q.den * r.num) /. (q.den * r.den) := Rat.add_num_den _ _
      have hqrd : q.num * r.den + q.den * r.num â‰  0 := Rat.mk_num_ne_zero_of_ne_zero hqr hqreq
      conv_lhs => rw [â† q.num_divInt_den]
      rw [hqreq, padicValRat_le_padicValRat_iff hqn hqrd hqd (mul_ne_zero hqd hrd), â†
        multiplicity_le_multiplicity_iff, mul_left_comm,
        multiplicity.mul (Nat.prime_iff_prime_int.1 hp.1), add_mul]
      rw [â† q.num_divInt_den, â† r.num_divInt_den, padicValRat_le_padicValRat_iff hqn hrn hqd hrd, â†
        multiplicity_le_multiplicity_iff] at h
      calc
        _ â‰¤
            min (multiplicity (â†‘p) (q.num * r.den * q.den))
              (multiplicity (â†‘p) (â†‘q.den * r.num * â†‘q.den)) :=
          le_min
            (by rw [@multiplicity.mul _ _ _ _ (_ * _) _ (Nat.prime_iff_prime_int.1 hp.1), add_comm])
            (by
              rw [mul_assoc,
                  @multiplicity.mul _ _ _ _ (q.den : â„¤) (_ * _)
                    (Nat.prime_iff_prime_int.1 hp.1)]
              exact add_le_add_left h _)
        _ â‰¤ _ := min_le_multiplicity_add


Verifying proof (Commit 40b64f797572a7615ba4553a28d3d6ee5049aa3b):
rw [add_comm]

Attempt failure.

Working on Mathlib/NumberTheory/Pell.lean - 2024-09-09 00:12:57.258710.
---149/200---
For theorem Pell.exists_of_not_isSquare in Mathlib/NumberTheory/Pell.lean:
theorem exists_of_not_isSquare (hâ‚€ : 0 < d) (hd : Â¬IsSquare d) :
    âˆƒ x y : â„¤, x ^ 2 - d * y ^ 2 = 1 âˆ§ y â‰  0 


Original valid proof:
:= by
  let Î¾ : â„ := âˆšd
  have hÎ¾ : Irrational Î¾ := by
    refine irrational_nrt_of_notint_nrt 2 d (sq_sqrt <| Int.cast_nonneg.mpr hâ‚€.le) ?_ two_pos
    rintro âŸ¨x, hxâŸ©
    refine hd âŸ¨x, @Int.cast_injective â„ _ _ d (x * x) ?_âŸ©
    rw [â† sq_sqrt <| Int.cast_nonneg.mpr hâ‚€.le, Int.cast_mul, â† hx, sq]
  obtain âŸ¨M, hMâ‚âŸ© := exists_int_gt (2 * |Î¾| + 1)
  have hM : {q : â„š | |q.1 ^ 2 - d * (q.2 : â„¤) ^ 2| < M}.Infinite := by
    refine Infinite.mono (fun q h => ?_) (infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational hÎ¾)
    have h0 : 0 < (q.2 : â„) ^ 2 := pow_pos (Nat.cast_pos.mpr q.pos) 2
    have h1 : (q.num : â„) / (q.den : â„) = q := mod_cast q.num_div_den
    rw [mem_setOf, abs_sub_comm, â† @Int.cast_lt â„, â† div_lt_div_right (abs_pos_of_pos h0)]
    push_cast
    rw [â† abs_div, abs_sq, sub_div, mul_div_cancel_rightâ‚€ _ h0.ne', â† div_pow, h1, â†
      sq_sqrt (Int.cast_pos.mpr hâ‚€).le, sq_sub_sq, abs_mul, â† mul_one_div]
    refine mul_lt_mul'' (((abs_add Î¾ q).trans ?_).trans_lt hMâ‚) h (abs_nonneg _) (abs_nonneg _)
    rw [two_mul, add_assoc, add_le_add_iff_left, â† sub_le_iff_le_add']
    rw [mem_setOf, abs_sub_comm] at h
    refine (abs_sub_abs_le_abs_sub (q : â„) Î¾).trans (h.le.trans ?_)
    rw [div_le_one h0, one_le_sq_iff_one_le_abs, Nat.abs_cast, Nat.one_le_cast]
    exact q.pos
  obtain âŸ¨m, hmâŸ© : âˆƒ m : â„¤, {q : â„š | q.1 ^ 2 - d * (q.den : â„¤) ^ 2 = m}.Infinite := by
    contrapose! hM
    simp only [not_infinite] at hM âŠ¢
    refine (congr_arg _ (ext fun x => ?_)).mp (Finite.biUnion (finite_Ioo (-M) M) fun m _ => hM m)
    simp only [abs_lt, mem_setOf, mem_Ioo, mem_iUnion, exists_prop, exists_eq_right']
  have hmâ‚€ : m â‰  0 := by
    rintro rfl
    obtain âŸ¨q, hqâŸ© := hm.nonempty
    rw [mem_setOf, sub_eq_zero, mul_comm] at hq
    obtain âŸ¨a, haâŸ© := (Int.pow_dvd_pow_iff two_ne_zero).mp âŸ¨d, hqâŸ©
    rw [ha, mul_pow, mul_right_inj' (pow_pos (Int.natCast_pos.mpr q.pos) 2).ne'] at hq
    exact hd âŸ¨a, sq a â–¸ hq.symmâŸ©
  haveI := neZero_iff.mpr (Int.natAbs_ne_zero.mpr hmâ‚€)
  let f : â„š â†’ ZMod m.natAbs Ã— ZMod m.natAbs := fun q => (q.num, q.den)
  obtain âŸ¨qâ‚, hâ‚ : qâ‚.num ^ 2 - d * (qâ‚.den : â„¤) ^ 2 = m,
      qâ‚‚, hâ‚‚ : qâ‚‚.num ^ 2 - d * (qâ‚‚.den : â„¤) ^ 2 = m, hne, hqfâŸ© :=
    hm.exists_ne_map_eq_of_mapsTo (mapsTo_univ f _) finite_univ
  obtain âŸ¨hq1 : (qâ‚.num : ZMod m.natAbs) = qâ‚‚.num, hq2 : (qâ‚.den : ZMod m.natAbs) = qâ‚‚.denâŸ© :=
    Prod.ext_iff.mp hqf
  have hdâ‚ : m âˆ£ qâ‚.num * qâ‚‚.num - d * (qâ‚.den * qâ‚‚.den) := by
    rw [â† Int.natAbs_dvd, â† ZMod.intCast_zmod_eq_zero_iff_dvd]
    push_cast
    rw [hq1, hq2, â† sq, â† sq]
    norm_cast
    rw [ZMod.intCast_zmod_eq_zero_iff_dvd, Int.natAbs_dvd, Nat.cast_pow, â† hâ‚‚]
  have hdâ‚‚ : m âˆ£ qâ‚.num * qâ‚‚.den - qâ‚‚.num * qâ‚.den := by
    rw [â† Int.natAbs_dvd, â† ZMod.intCast_eq_intCast_iff_dvd_sub]
    push_cast
    rw [hq1, hq2]
  replace hmâ‚€ : (m : â„š) â‰  0 := Int.cast_ne_zero.mpr hmâ‚€
  refine âŸ¨(qâ‚.num * qâ‚‚.num - d * (qâ‚.den * qâ‚‚.den)) / m, (qâ‚.num * qâ‚‚.den - qâ‚‚.num * qâ‚.den) / m,
      ?_, ?_âŸ©
  Â· qify [hdâ‚, hdâ‚‚]
    field_simp [hmâ‚€]
    norm_cast
    conv_rhs =>
      rw [sq]
      congr
      Â· rw [â† hâ‚]
      Â· rw [â† hâ‚‚]
    push_cast
    ring
  Â· qify [hdâ‚‚]
    refine div_ne_zero_iff.mpr âŸ¨?_, hmâ‚€âŸ©
    exact mod_cast mt sub_eq_zero.mp (mt Rat.eq_iff_mul_eq_mul.mpr hne)


Verifying proof (Commit 5f92bfec6d6c4ec4639d991dbedc7d9dbbbd4162):
obtain âŸ¨x, y, hxy, hyâŸ© := exists_of_not_isSquare hâ‚€ hd

Attempt failure.

Working on Mathlib/NumberTheory/PrimesCongruentOne.lean - 2024-09-09 00:13:17.665884.
---150/200---
For theorem Nat.exists_prime_gt_modEq_one in Mathlib/NumberTheory/PrimesCongruentOne.lean:
theorem exists_prime_gt_modEq_one {k : â„•} (n : â„•) (hk0 : k â‰  0) :
    âˆƒ p : â„•, Nat.Prime p âˆ§ n < p âˆ§ p â‰¡ 1 [MOD k] 


Original valid proof:
:= by
  rcases (one_le_iff_ne_zero.2 hk0).eq_or_lt with (rfl | hk1)
  Â· rcases exists_infinite_primes (n + 1) with âŸ¨p, hnp, hpâŸ©
    exact âŸ¨p, hp, hnp, modEq_oneâŸ©
  let b := k * (n !)
  have hgt : 1 < (eval (â†‘b) (cyclotomic k â„¤)).natAbs := by
    rcases le_iff_exists_add'.1 hk1.le with âŸ¨k, rflâŸ©
    have hb : 2 â‰¤ b := le_mul_of_le_of_one_le hk1 n.factorial_pos
    calc
      1 â‰¤ b - 1 := le_tsub_of_add_le_left hb
      _ < (eval (b : â„¤) (cyclotomic (k + 1) â„¤)).natAbs :=
        sub_one_lt_natAbs_cyclotomic_eval hk1 (succ_le_iff.1 hb).ne'
  let p := minFac (eval (â†‘b) (cyclotomic k â„¤)).natAbs
  haveI hprime : Fact p.Prime := âŸ¨minFac_prime (ne_of_lt hgt).symmâŸ©
  have hroot : IsRoot (cyclotomic k (ZMod p)) (castRingHom (ZMod p) b) := by
    have : ((b : â„¤) : ZMod p) = â†‘(Int.castRingHom (ZMod p) b) := by simp
    rw [IsRoot.def, â† map_cyclotomic_int k (ZMod p), eval_map, coe_castRingHom,
      â† Int.cast_natCast, this, evalâ‚‚_hom, Int.coe_castRingHom, ZMod.intCast_zmod_eq_zero_iff_dvd]
    apply Int.dvd_natAbs.1
    exact mod_cast minFac_dvd (eval (â†‘b) (cyclotomic k â„¤)).natAbs
  have hpb : Â¬p âˆ£ b :=
    hprime.1.coprime_iff_not_dvd.1 (coprime_of_root_cyclotomic hk0.bot_lt hroot).symm
  refine âŸ¨p, hprime.1, not_le.1 fun habs => ?_, ?_âŸ©
  Â· exact hpb (dvd_mul_of_dvd_right (dvd_factorial (minFac_pos _) habs) _)
  Â· have hdiv : orderOf (b : ZMod p) âˆ£ p - 1 :=
      ZMod.orderOf_dvd_card_sub_one (mt (CharP.cast_eq_zero_iff _ _ _).1 hpb)
    haveI : NeZero (k : ZMod p) :=
      NeZero.of_not_dvd (ZMod p) fun hpk => hpb (dvd_mul_of_dvd_left hpk _)
    have : k = orderOf (b : ZMod p) := (isRoot_cyclotomic_iff.mp hroot).eq_orderOf
    rw [â† this] at hdiv
    exact ((modEq_iff_dvd' hprime.1.pos).2 hdiv).symm


Verifying proof (Commit 693fd79515903b10b1d31f10dccfc49e633cf7ee):
rcases exists_prime_gt_modEq_one k hk0 with âŸ¨p, hpâ‚, hpâ‚‚âŸ©

Attempt failure.

Working on Mathlib/Order/Height.lean - 2024-09-09 00:13:37.789802.
---151/200---
For theorem Set.chainHeight_eq_iSup_Ici in Mathlib/Order/Height.lean:
theorem chainHeight_eq_iSup_Ici : s.chainHeight = â¨† i âˆˆ s, (s âˆ© Set.Ici i).chainHeight 


Original valid proof:
:= by
  apply le_antisymm
  Â· refine iSupâ‚‚_le ?_
    rintro (_ | âŸ¨x, xsâŸ©) h
    Â· exact zero_le _
    Â· apply le_trans _ (le_iSupâ‚‚ x (cons_mem_subchain_iff.mp h).1)
      apply length_le_chainHeight_of_mem_subchain
      refine âŸ¨h.1, fun i hi â†¦ âŸ¨h.2 i hi, ?_âŸ©âŸ©
      cases hi
      Â· exact left_mem_Ici
      rename_i hi
      cases' chain'_iff_pairwise.mp h.1 with _ _ h'
      exact (h' _ hi).le
  Â· exact iSupâ‚‚_le fun i _ â†¦ chainHeight_mono Set.inter_subset_left


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
rw [chainHeight_eq_iSup_Ici]

Attempt failure.

Working on Mathlib/Order/Interval/Finset/Nat.lean - 2024-09-09 00:13:43.579265.
---152/200---
For theorem Nat.image_sub_const_Ico in Mathlib/Order/Interval/Finset/Nat.lean:
theorem image_sub_const_Ico (h : c â‰¤ a) :
    ((Ico a b).image fun x => x - c) = Ico (a - c) (b - c) 


Original valid proof:
:= by
  ext x
  simp_rw [mem_image, mem_Ico]
  refine âŸ¨?_, fun h â†¦ âŸ¨x + c, by omegaâŸ©âŸ©
  rintro âŸ¨x, hx, rflâŸ©
  omega


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
rw [Ico.image_eq_of_injective image_sub_const_Ico]

Attempt failure.

Working on Mathlib/Order/OmegaCompletePartialOrder.lean - 2024-09-09 00:13:49.348495.
---153/200---
For theorem OmegaCompletePartialOrder.isLUB_range_Ï‰Sup in Mathlib/Order/OmegaCompletePartialOrder.lean:
lemma isLUB_range_Ï‰Sup (c : Chain Î±) : IsLUB (Set.range c) (Ï‰Sup c) 


Original valid proof:
:= by
  constructor
  Â· simp only [upperBounds, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff,
      Set.mem_setOf_eq]
    exact fun a â†¦ le_Ï‰Sup c a
  Â· simp only [lowerBounds, upperBounds, Set.mem_range, forall_exists_index,
      forall_apply_eq_imp_iff, Set.mem_setOf_eq]
    exact fun â¦ƒaâ¦„ a_1 â†¦ Ï‰Sup_le c a a_1


Verifying proof (Commit df7b04231c9920b36d13328cb3f0f402d88e7da5):
apply isLUB_range_Ï‰Sup

Attempt failure.

Working on Mathlib/Order/WellFoundedSet.lean - 2024-09-09 00:13:55.176928.
---154/200---
For theorem Set.partiallyWellOrderedOn_union in Mathlib/Order/WellFoundedSet.lean:
theorem partiallyWellOrderedOn_union :
    (s âˆª t).PartiallyWellOrderedOn r â†” s.PartiallyWellOrderedOn r âˆ§ t.PartiallyWellOrderedOn r 


Original valid proof:
:=
  âŸ¨fun h => âŸ¨h.mono subset_union_left, h.mono subset_union_rightâŸ©, fun h =>
    h.1.union h.2âŸ©


Verifying proof (Commit a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0):
rw [partiallyWellOrderedOn_iff] at partiallyWellOrderedOn

Attempt failure.

---155/200---
For theorem Set.WellFoundedOn.acc_iff_wellFoundedOn in Mathlib/Order/WellFoundedSet.lean:
theorem acc_iff_wellFoundedOn {Î±} {r : Î± â†’ Î± â†’ Prop} {a : Î±} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r] 


Original valid proof:
:= by
  tfae_have 1 â†’ 2
  Â· refine fun h => âŸ¨fun b => InvImage.accessible _ ?_âŸ©
    rw [â† acc_transGen_iff] at h âŠ¢
    obtain h' | h' := reflTransGen_iff_eq_or_transGen.1 b.2
    Â· rwa [h'] at h
    Â· exact h.inv h'
  tfae_have 2 â†’ 3
  Â· exact fun h => h.subset fun _ => TransGen.to_reflTransGen
  tfae_have 3 â†’ 1
  Â· refine fun h => Acc.intro _ (fun b hb => (h.apply âŸ¨b, .single hbâŸ©).of_fibration Subtype.val ?_)
    exact fun âŸ¨c, hcâŸ© d h => âŸ¨âŸ¨d, .head h hcâŸ©, h, rflâŸ©
  tfae_finish


Verifying proof (Commit 415d6b952a0c6bc1221dd68bc6ae84a0390ea21f):
simp only [reflTransGen_eq_transGen]

Attempt failure.

Working on Mathlib/Probability/Distributions/Gaussian.lean - 2024-09-09 00:14:08.601087.
---156/200---
For theorem ProbabilityTheory.gaussianReal_map_const_mul in Mathlib/Probability/Distributions/Gaussian.lean:
lemma gaussianReal_map_const_mul (c : â„) :
    (gaussianReal Î¼ v).map (c * Â·) = gaussianReal (c * Î¼) (âŸ¨c^2, sq_nonneg _âŸ© * v) 


Original valid proof:
:= by
  by_cases hv : v = 0
  Â· simp only [hv, mul_zero, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.const_mul c) Î¼
  by_cases hc : c = 0
  Â· simp only [hc, zero_mul, ne_eq, abs_zero, mul_eq_zero]
    rw [Measure.map_const]
    simp only [ne_eq, measure_univ, one_smul, mul_eq_zero]
    convert (gaussianReal_zero_var 0).symm
    simp only [ne_eq, zero_pow, mul_eq_zero, hv, or_false, not_false_eq_true]
    rfl
  let e : â„ â‰ƒáµ â„ := (Homeomorph.mulLeftâ‚€ c hc).symm.toMeasurableEquiv
  have he' : âˆ€ x, HasDerivAt e ((fun _ â†¦ câ»Â¹) x) x := by
    suffices âˆ€ x, HasDerivAt (fun x => câ»Â¹ * x) (câ»Â¹ * 1) x by rwa [mul_one] at this
    exact fun _ â†¦ HasDerivAt.const_mul _ (hasDerivAt_id _)
  change (gaussianReal Î¼ v).map e.symm = gaussianReal (c * Î¼) (âŸ¨c^2, sq_nonneg _âŸ© * v)
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs',
    gaussianReal_apply_eq_integral _ _ s']
  swap
  Â· simp only [ne_eq, mul_eq_zero, hv, or_false]
    rw [â† NNReal.coe_inj]
    simp [hc]
  simp only [e, Homeomorph.mulLeftâ‚€, Equiv.toFun_as_coe, Equiv.mulLeftâ‚€_apply, Equiv.invFun_as_coe,
    Equiv.mulLeftâ‚€_symm_apply, Homeomorph.toMeasurableEquiv_coe, Homeomorph.homeomorph_mk_coe_symm,
    Equiv.coe_fn_symm_mk, gaussianPDFReal_inv_mul hc]
  congr with x
  suffices |câ»Â¹| * |c| = 1 by rw [â† mul_assoc, this, one_mul]
  rw [abs_inv, inv_mul_cancel]
  rwa [ne_eq, abs_eq_zero]


Verifying proof (Commit 62a9ca63fe8a39ea0004bbc5dbf652532269c0b1):
simp [gaussianReal_map_const_mul, gaussianReal_map_const_mul]

Attempt failure.

Working on Mathlib/Probability/Kernel/RadonNikodym.lean - 2024-09-09 00:14:29.066029.
---157/200---
For theorem ProbabilityTheory.kernel.measure_mutuallySingularSetSlice in Mathlib/Probability/Kernel/RadonNikodym.lean:
lemma measure_mutuallySingularSetSlice (Îº Î· : kernel Î± Î³) [IsFiniteKernel Îº] [IsFiniteKernel Î·]
    (a : Î±) :
    Î· a (mutuallySingularSetSlice Îº Î· a) = 0 


Original valid proof:
:= by
  have h_coe : âˆ€ b, (Real.toNNReal b : â„â‰¥0âˆ) = ENNReal.ofReal b := fun _ â†¦ rfl
  suffices withDensity (Îº + Î·) (fun a x â†¦ Real.toNNReal
      (1 - rnDerivAux Îº (Îº + Î·) a x)) a {x | 1 â‰¤ rnDerivAux Îº (Îº + Î·) a x} = 0 by
    rwa [withDensity_one_sub_rnDerivAux Îº Î·] at this
  simp_rw [h_coe]
  rw [kernel.withDensity_apply', lintegral_eq_zero_iff, EventuallyEq, ae_restrict_iff]
  rotate_left
  Â· exact (measurable_const.sub
      ((measurable_rnDerivAux _ _).comp measurable_prod_mk_left)).ennreal_ofReal
      (measurableSet_singleton _)
  Â· exact (measurable_const.sub
      ((measurable_rnDerivAux _ _).comp measurable_prod_mk_left)).ennreal_ofReal
  Â· exact (measurable_const.sub (measurable_rnDerivAux _ _)).ennreal_ofReal
  refine ae_of_all _ (fun x hx â†¦ ?_)
  simp only [mem_setOf_eq] at hx
  simp [hx]


Verifying proof (Commit 1953582979d6fb22253b407bc35a0372934263c5):
rw [kernel.measure_mutuallySingularSetSlice]

Attempt failure.

Working on Mathlib/Probability/Kernel/WithDensity.lean - 2024-09-09 00:14:49.381151.
---158/200---
For theorem ProbabilityTheory.kernel.isSFiniteKernel_withDensity_of_isFiniteKernel in Mathlib/Probability/Kernel/WithDensity.lean:
theorem isSFiniteKernel_withDensity_of_isFiniteKernel (Îº : kernel Î± Î²) [IsFiniteKernel Îº]
    (hf_ne_top : âˆ€ a b, f a b â‰  âˆ) : IsSFiniteKernel (withDensity Îº f) 


Original valid proof:
:= by
  by_cases hf : Measurable (Function.uncurry f)
  swap; Â· rw [withDensity_of_not_measurable _ hf]; infer_instance
  let fs : â„• â†’ Î± â†’ Î² â†’ â„â‰¥0âˆ := fun n a b => min (f a b) (n + 1) - min (f a b) n
  have h_le : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ f a b â‰¤ n := by
    intro a b n hn
    have : (f a b).toReal â‰¤ n := Nat.le_of_ceil_le hn
    rw [â† ENNReal.le_ofReal_iff_toReal_le (hf_ne_top a b) _] at this
    Â· refine this.trans (le_of_eq ?_)
      rw [ENNReal.ofReal_natCast]
    Â· norm_cast
      exact zero_le _
  have h_zero : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ fs n a b = 0 := by
    intro a b n hn
    suffices min (f a b) (n + 1) = f a b âˆ§ min (f a b) n = f a b by
      simp_rw [fs, this.1, this.2, tsub_self (f a b)]
    exact âŸ¨min_eq_left ((h_le a b n hn).trans (le_add_of_nonneg_right zero_le_one)),
      min_eq_left (h_le a b n hn)âŸ©
  have hf_eq_tsum : f = âˆ‘' n, fs n := by
    have h_sum_a : âˆ€ a, Summable fun n => fs n a := by
      refine fun a => Pi.summable.mpr fun b => ?_
      suffices âˆ€ n, n âˆ‰ Finset.range âŒˆ(f a b).toRealâŒ‰â‚Š â†’ fs n a b = 0 from
        summable_of_ne_finset_zero this
      intro n hn_not_mem
      rw [Finset.mem_range, not_lt] at hn_not_mem
      exact h_zero a b n hn_not_mem
    ext a b : 2
    rw [tsum_apply (Pi.summable.mpr h_sum_a), tsum_apply (h_sum_a a),
      ENNReal.tsum_eq_liminf_sum_nat]
    have h_finset_sum : âˆ€ n, âˆ‘ i âˆˆ Finset.range n, fs i a b = min (f a b) n := by
      intro n
      induction' n with n hn
      Â· simp
      rw [Finset.sum_range_succ, hn]
      simp [fs]
    simp_rw [h_finset_sum]
    refine (Filter.Tendsto.liminf_eq ?_).symm
    refine Filter.Tendsto.congr' ?_ tendsto_const_nhds
    rw [Filter.EventuallyEq, Filter.eventually_atTop]
    exact âŸ¨âŒˆ(f a b).toRealâŒ‰â‚Š, fun n hn => (min_eq_left (h_le a b n hn)).symmâŸ©
  rw [hf_eq_tsum, withDensity_tsum _ fun n : â„• => _]
  swap; Â· exact fun _ => (hf.min measurable_const).sub (hf.min measurable_const)
  refine isSFiniteKernel_sum fun n => ?_
  suffices IsFiniteKernel (withDensity Îº (fs n)) by haveI := this; infer_instance
  refine isFiniteKernel_withDensity_of_bounded _ (ENNReal.coe_ne_top : â†‘n + 1 â‰  âˆ) fun a b => ?_
  beta_reduce
  norm_cast
  calc
    fs n a b â‰¤ min (f a b) (n + 1) := tsub_le_self
    _ â‰¤ n + 1 := min_le_right _ _
    _ = â†‘(n + 1) := by norm_cast


Verifying proof (Commit 5ac9cb38fcf9079f6519764442b871fbd4091ab1):
refine isSFiniteKernel_withDensity_of_isFiniteKernel_withDensity_of_isFiniteKernel_withDensity_of_isFiniteKernel f

Attempt failure.

Working on Mathlib/Probability/Variance.lean - 2024-09-09 00:15:10.219230.
---159/200---
For theorem ProbabilityTheory.meas_ge_le_variance_div_sq in Mathlib/Probability/Variance.lean:
theorem meas_ge_le_variance_div_sq [@IsFiniteMeasure Î© _ â„™] {X : Î© â†’ â„} (hX : Memâ„’p X 2) {c : â„}
    (hc : 0 < c) : â„™ {Ï‰ | c â‰¤ |X Ï‰ - ğ”¼[X]|} â‰¤ ENNReal.ofReal (Var[X] / c ^ 2) 


Original valid proof:
:= by
  rw [ENNReal.ofReal_div_of_pos (sq_pos_of_ne_zero hc.ne.symm), hX.ofReal_variance_eq]
  convert @meas_ge_le_evariance_div_sq _ _ _ hX.1 c.toNNReal (by simp [hc]) using 1
  Â· simp only [Real.coe_toNNReal', max_le_iff, abs_nonneg, and_true_iff]
  Â· rw [ENNReal.ofReal_pow hc.le]
    rfl


Verifying proof (Commit 22e97510854d6906cc856e022d297bf9cf8c9b3a):
rw [ENNReal.ofReal_div, ENNReal.ofReal_ofReal (Var[X] / c ^ 2),
  ENNReal.ofReal_ofReal (Var[X] / c ^ 2)]

Attempt failure.

Working on Mathlib/RingTheory/Adjoin/PowerBasis.lean - 2024-09-09 00:15:30.509151.
---160/200---
For theorem PowerBasis.repr_mul_isIntegral in Mathlib/RingTheory/Adjoin/PowerBasis.lean:
theorem repr_mul_isIntegral [IsDomain S] {x y : A} (hx : âˆ€ i, IsIntegral R (B.basis.repr x i))
    (hy : âˆ€ i, IsIntegral R (B.basis.repr y i))
    (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) :
    âˆ€ i, IsIntegral R (B.basis.repr (x * y) i) 


Original valid proof:
:= by
  intro i
  rw [â† B.basis.sum_repr x, â† B.basis.sum_repr y, Finset.sum_mul_sum, â† Finset.sum_product',
    map_sum, Finset.sum_apply']
  refine IsIntegral.sum _ fun I _ => ?_
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smulâ‚›â‚—,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine (hy _).mul ((hx _).mul ?_)
  simp only [coe_basis, â† pow_add]
  exact repr_gen_pow_isIntegral hB hmin _ _


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
apply IsIntegral.theorem repr_mul_isIntegral

Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/Different.lean - 2024-09-09 00:15:51.143226.
---161/200---
For theorem FractionalIdeal.dual_eq_mul_inv in Mathlib/RingTheory/DedekindDomain/Different.lean:
lemma dual_eq_mul_inv :
    dual A K I = dual A K 1 * Iâ»Â¹ 


Original valid proof:
:= by
  by_cases hI : I = 0; Â· simp [hI]
  apply le_antisymm
  Â· suffices dual A K I * I â‰¤ dual A K 1 by
      convert mul_right_mono Iâ»Â¹ this using 1; simp only [mul_inv_cancel hI, mul_one, mul_assoc]
    rw [â† le_dual_iff A K hI]
  rw [le_dual_iff A K hI, mul_assoc, inv_mul_cancel hI, mul_one]


Verifying proof (Commit 3465d1aaae242475fad59e688648a2285031d19e):
rw [dual_eq_mul_inv, dual_eq_mul_inv]

Attempt failure.

Working on Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean - 2024-09-09 00:16:14.799751.
---162/200---
For theorem IsIntegralClosure.isDedekindDomain in Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean:
theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C 


Original valid proof:
:=
  have : IsFractionRing C L := IsIntegralClosure.isFractionRing_of_finite_extension A K L C
  have : Algebra.IsIntegral A C := IsIntegralClosure.isIntegral_algebra A L
  { IsIntegralClosure.isNoetherianRing A K L C,
    Ring.DimensionLEOne.isIntegralClosure A L C,
    (isIntegrallyClosed_iff L).mpr fun {x} hx =>
      âŸ¨IsIntegralClosure.mk' C x (isIntegral_trans (R := A) _ hx),
        IsIntegralClosure.algebraMap_mk' _ _ _âŸ© with : IsDedekindDomain C }


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
apply IsDedekindDomain.IsDedekindDomain.IsDedekindDomain

Attempt failure.

Working on Mathlib/RingTheory/EisensteinCriterion.lean - 2024-09-09 00:16:36.759053.
---163/200---
For theorem Polynomial.irreducible_of_eisenstein_criterion in Mathlib/RingTheory/EisensteinCriterion.lean:
theorem irreducible_of_eisenstein_criterion {f : R[X]} {P : Ideal R} (hP : P.IsPrime)
    (hfl : f.leadingCoeff âˆ‰ P) (hfP : âˆ€ n : â„•, â†‘n < degree f â†’ f.coeff n âˆˆ P) (hfd0 : 0 < degree f)
    (h0 : f.coeff 0 âˆ‰ P ^ 2) (hu : f.IsPrimitive) : Irreducible f 


Original valid proof:
:=
  have hf0 : f â‰  0 := fun _ => by simp_all only [not_true, Submodule.zero_mem, coeff_zero]
  have hf : f.map (mk P) = C (mk P (leadingCoeff f)) * X ^ natDegree f :=
    map_eq_C_mul_X_pow_of_forall_coeff_mem hfP
  have hfd0 : 0 < f.natDegree := WithBot.coe_lt_coe.1 (lt_of_lt_of_le hfd0 degree_le_natDegree)
  âŸ¨mt degree_eq_zero_of_isUnit fun h => by simp_all only [lt_irrefl], by
    rintro p q rfl
    rw [Polynomial.map_mul] at hf
    rcases mul_eq_mul_prime_pow
        (show Prime (X : Polynomial (R â§¸ P)) from monic_X.prime_of_degree_eq_one degree_X) hf with
      âŸ¨m, n, b, c, hmnd, hbc, hp, hqâŸ©
    have hmn : 0 < m â†’ 0 < n â†’ False := by
      intro hm0 hn0
      refine h0 ?_
      rw [coeff_zero_eq_eval_zero, eval_mul, sq]
      exact
        Ideal.mul_mem_mul (eval_zero_mem_ideal_of_eq_mul_X_pow hp hm0.ne')
          (eval_zero_mem_ideal_of_eq_mul_X_pow hq hn0.ne')
    have hpql0 : (mk P) (p * q).leadingCoeff â‰  0 := by rwa [Ne, eq_zero_iff_mem]
    have hp0 : p â‰  0 := fun h => by
      simp_all only [zero_mul, eq_self_iff_true, not_true, Ne]
    have hq0 : q â‰  0 := fun h => by
      simp_all only [eq_self_iff_true, not_true, Ne, mul_zero]
    have hbc0 : degree b = 0 âˆ§ degree c = 0 := by
      apply_fun degree at hbc
      rwa [degree_C hpql0, degree_mul, eq_comm, Nat.WithBot.add_eq_zero_iff] at hbc
    have hmp : m â‰¤ natDegree p := le_natDegree_of_map_eq_mul_X_pow hP hp hbc0.1
    have hnq : n â‰¤ natDegree q := le_natDegree_of_map_eq_mul_X_pow hP hq hbc0.2
    have hpmqn : p.natDegree = m âˆ§ q.natDegree = n := by
      rw [natDegree_mul hp0 hq0] at hmnd
      contrapose hmnd
      apply ne_of_lt
      rw [not_and_or] at hmnd
      cases' hmnd with hmnd hmnd
      Â· exact add_lt_add_of_lt_of_le (lt_of_le_of_ne hmp (Ne.symm hmnd)) hnq
      Â· exact add_lt_add_of_le_of_lt hmp (lt_of_le_of_ne hnq (Ne.symm hmnd))
    obtain rfl | rfl : m = 0 âˆ¨ n = 0 := by
      rwa [pos_iff_ne_zero, pos_iff_ne_zero, imp_false, Classical.not_not, â† or_iff_not_imp_left]
        at hmn
    Â· exact Or.inl (isUnit_of_natDegree_eq_zero_of_isPrimitive hu hpmqn.1)
    Â· exact Or.inr
          (isUnit_of_natDegree_eq_zero_of_isPrimitive
            (show IsPrimitive (q * p) by simpa [mul_comm] using hu)
            hpmqn.2)âŸ©


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
refine irreducible_iff_irreducible_factorization.mpr âŸ¨?_, ?_âŸ©

Attempt failure.

Working on Mathlib/RingTheory/FiniteType.lean - 2024-09-09 00:16:57.498882.
---164/200---
For theorem Module.Finite.injective_of_surjective_endomorphism in Mathlib/RingTheory/FiniteType.lean:
theorem Module.Finite.injective_of_surjective_endomorphism {R : Type*} [CommRing R] {M : Type*}
    [AddCommGroup M] [Module R M] [Finite R M] (f : M â†’â‚—[R] M)
    (f_surj : Function.Surjective f) : Function.Injective f 


Original valid proof:
:=
  OrzechProperty.injective_of_surjective_endomorphism f f_surj


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
exact Function.Injective.of_surjective f_surj

Attempt failure.

---165/200---
For theorem MonoidAlgebra.freeAlgebra_lift_of_surjective_of_closure in Mathlib/RingTheory/FiniteType.lean:
theorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}
    (hS : closure S = âŠ¤) :
    Function.Surjective
      (FreeAlgebra.lift R fun s : S => of' R M â†‘s : FreeAlgebra R S â†’ R[M]) 


Original valid proof:
:= by
  intro f
  induction' f using induction_on with m f g ihf ihg r f ih
  Â· have : m âˆˆ closure S := hS.symm â–¸ mem_top _
    refine AddSubmonoid.closure_induction this (fun m hm => ?_) ?_ ?_
    Â· exact âŸ¨FreeAlgebra.Î¹ R âŸ¨m, hmâŸ©, FreeAlgebra.lift_Î¹_apply _ _âŸ©
    Â· exact âŸ¨1, AlgHom.map_one _âŸ©
    Â· rintro mâ‚ mâ‚‚ âŸ¨Pâ‚, hPâ‚âŸ© âŸ¨Pâ‚‚, hPâ‚‚âŸ©
      exact
        âŸ¨Pâ‚ * Pâ‚‚, by
          rw [AlgHom.map_mul, hPâ‚, hPâ‚‚, of_apply, of_apply, of_apply, single_mul_single,
            one_mul]; rflâŸ©
  Â· rcases ihf with âŸ¨P, rflâŸ©
    rcases ihg with âŸ¨Q, rflâŸ©
    exact âŸ¨P + Q, AlgHom.map_add _ _ _âŸ©
  Â· rcases ih with âŸ¨P, rflâŸ©
    exact âŸ¨r â€¢ P, AlgHom.map_smul _ _ _âŸ©


Verifying proof (Commit 5fb9beab28702fb284701d494bc9b7c5f52fef53):
apply FreeAlgebra.lift_surjective_of_surjective

Attempt failure.

Working on Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean - 2024-09-09 00:17:39.042527.
---166/200---
For theorem HomogeneousIdeal.toIdeal_homogeneousCore_eq_self in Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean:
theorem HomogeneousIdeal.toIdeal_homogeneousCore_eq_self (I : HomogeneousIdeal ğ’œ) :
    I.toIdeal.homogeneousCore ğ’œ = I 


Original valid proof:
:= by
  ext1
  convert Ideal.IsHomogeneous.toIdeal_homogeneousCore_eq_self I.isHomogeneous


Verifying proof (Commit 413e5b872a7c758e0eb91f99cb96d6a61c81f0a2):
apply Ideal.homogeneousCore_eq_self

Attempt failure.

Working on Mathlib/RingTheory/IntegralDomain.lean - 2024-09-09 00:17:59.473218.
---167/200---
For theorem sum_hom_units_eq_zero in Mathlib/RingTheory/IntegralDomain.lean:
theorem sum_hom_units_eq_zero (f : G â†’* R) (hf : f â‰  1) : âˆ‘ g : G, f g = 0 


Original valid proof:
:= by
  classical
    obtain âŸ¨x, hxâŸ© : âˆƒ x : MonoidHom.range f.toHomUnits,
        âˆ€ y : MonoidHom.range f.toHomUnits, y âˆˆ Submonoid.powers x :=
      IsCyclic.exists_monoid_generator
    have hx1 : x â‰  1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx âŸ¨f.toHomUnits g, g, rflâŸ© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 â‰  0 := 
      fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      âˆ‘ g : G, f g = âˆ‘ g : G, (f.toHomUnits g : R) := rfl
      _ = âˆ‘ u âˆˆ univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card â€¢ (u : R) :=
        (sum_comp ((â†‘) : RË£ â†’ R) f.toHomUnits)
      _ = âˆ‘ u âˆˆ univ.image f.toHomUnits, c â€¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_argâ‚‚ _ ?_ rfl)
      _ = âˆ‘ b : MonoidHom.range f.toHomUnits, c â€¢ ((b : RË£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c â€¢ âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R) := smul_sum.symm
      _ = c â€¢ (0 : R) := congr_argâ‚‚ _ rfl ?_
      _ = (0 : R) := smul_zero _
    Â· 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply MonoidHom.card_fiber_eq_of_mem_range f.toHomUnits
      Â· simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      Â· exact âŸ¨1, f.toHomUnits.map_oneâŸ©
    show (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R)) = 0
    calc
      (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R))
        = âˆ‘ n âˆˆ range (orderOf x), ((x : RË£) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ Â·) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let âŸ¨n, hnâŸ© := hx b
              âŸ¨n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn âŠ¢; rw [pow_mod_orderOf, hn]âŸ©)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [â† mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]


Verifying proof (Commit 9e34a191034458a56331f976ff7400a26407c888):
simp only [sum_hom_units_eq_zero, sum_hom_units_eq_zero]

Attempt failure.

Working on Mathlib/RingTheory/IntegralRestrict.lean - 2024-09-09 00:18:20.359942.
---168/200---
For theorem Algebra.intTrace_eq_of_isLocalization in Mathlib/RingTheory/IntegralRestrict.lean:
lemma Algebra.intTrace_eq_of_isLocalization
    (x : B) :
    algebraMap A Aâ‚˜ (Algebra.intTrace A B x) = Algebra.intTrace Aâ‚˜ Bâ‚˜ (algebraMap B Bâ‚˜ x) 


Original valid proof:
:= by
  by_cases hM : 0 âˆˆ M
  Â· have := IsLocalization.uniqueOfZeroMem (S := Aâ‚˜) hM
    exact Subsingleton.elim _ _
  replace hM : M â‰¤ Aâ° := fun x hx â†¦ mem_nonZeroDivisors_iff_ne_zero.mpr (fun e â†¦ hM (e â–¸ hx))
  let K := FractionRing A
  let L := FractionRing B
  have : IsIntegralClosure B A L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsLocalization (algebraMapSubmonoid B Aâ°) L :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  let f : Aâ‚˜ â†’+* K := IsLocalization.map _ (T := Aâ°) (RingHom.id A) hM
  letI := f.toAlgebra
  have : IsScalarTower A Aâ‚˜ K := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aâ‚˜ K
  let g : Bâ‚˜ â†’+* L := IsLocalization.map _
      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B Aâ°)
      (RingHom.id B) (Submonoid.monotone_map hM)
  letI := g.toAlgebra
  have : IsScalarTower B Bâ‚˜ L := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := ((algebraMap K L).comp f).toAlgebra
  have : IsScalarTower Aâ‚˜ K L := IsScalarTower.of_algebraMap_eq' rfl
  have : IsScalarTower Aâ‚˜ Bâ‚˜ L := by
    apply IsScalarTower.of_algebraMap_eq'
    apply IsLocalization.ringHom_ext M
    rw [RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra (R := Bâ‚˜), RingHom.comp_assoc,
      RingHom.comp_assoc, â† IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq A B Bâ‚˜,
      IsLocalization.map_comp, RingHom.comp_id, â† RingHom.comp_assoc, IsLocalization.map_comp,
      RingHom.comp_id, â† IsScalarTower.algebraMap_eq, â† IsScalarTower.algebraMap_eq]
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization
    (algebraMapSubmonoid B M) Bâ‚˜ L
  have : FiniteDimensional K L := Module.Finite_of_isLocalization A B _ _ Aâ°
  have : IsIntegralClosure Bâ‚˜ Aâ‚˜ L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  apply IsFractionRing.injective Aâ‚˜ K
  rw [â† IsScalarTower.algebraMap_apply, Algebra.algebraMap_intTrace_fractionRing,
    Algebra.algebraMap_intTrace (L := L), â† IsScalarTower.algebraMap_apply]


Verifying proof (Commit 562711c9f3ae24a07facf3809c1631a4ccf2e8f2):
rw [Algebra.intTrace_eq_of_isLocalization, â† Algebra.intTrace_eq_of_isLocalization,
  Algebra.intTrace_eq_of_isLocalization]

Attempt failure.

Working on Mathlib/RingTheory/Jacobson.lean - 2024-09-09 00:18:40.696493.
---169/200---
For theorem Ideal.Polynomial.isMaximal_comap_C_of_isJacobson in Mathlib/RingTheory/Jacobson.lean:
theorem isMaximal_comap_C_of_isJacobson : (P.comap (C : R â†’+* R[X])).IsMaximal 


Original valid proof:
:= by
  rw [â† @mk_ker _ _ P, RingHom.ker_eq_comap_bot, comap_comap]
  have := (bot_quotient_isMaximal_iff _).mpr hP
  exact isMaximal_comap_of_isIntegral_of_isMaximal' _ (quotient_mk_comp_C_isIntegral_of_jacobson P)
    âŠ¥


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
heorem isMaximal_comap_C_of_isJacobson isJacobson

Attempt failure.

---170/200---
For theorem Ideal.isJacobson_of_isIntegral' in Mathlib/RingTheory/Jacobson.lean:
theorem isJacobson_of_isIntegral' (f : R â†’+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S 


Original valid proof:
:=
  let _ : Algebra R S := f.toAlgebra
  have : Algebra.IsIntegral R S := âŸ¨hfâŸ©
  isJacobson_of_isIntegral hR


Verifying proof (Commit 3a31aabe59645ce291dedbcbdd3f949a56d5178f):
exact isJacobson_of_isJacobson_of_isIntegral' f hf hR

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean - 2024-09-09 00:19:21.696023.
---171/200---
For theorem Polynomial.orderOf_root_cyclotomic_dvd in Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean:
theorem orderOf_root_cyclotomic_dvd {n : â„•} (hpos : 0 < n) {p : â„•} [Fact p.Prime] {a : â„•}
    (hroot : IsRoot (cyclotomic n (ZMod p)) (Nat.castRingHom (ZMod p) a)) :
    orderOf (ZMod.unitOfCoprime a (coprime_of_root_cyclotomic hpos hroot)) âˆ£ n 


Original valid proof:
:= by
  apply orderOf_dvd_of_pow_eq_one
  suffices hpow : eval (Nat.castRingHom (ZMod p) a) (X ^ n - 1 : (ZMod p)[X]) = 0 by
    simp only [eval_X, eval_one, eval_pow, eval_sub, eq_natCast] at hpow
    apply Units.val_eq_one.1
    simp only [sub_eq_zero.mp hpow, ZMod.coe_unitOfCoprime, Units.val_pow_eq_pow_val]
  rw [IsRoot.def] at hroot
  rw [â† prod_cyclotomic_eq_X_pow_sub_one hpos (ZMod p), â† Nat.cons_self_properDivisors hpos.ne',
    Finset.prod_cons, eval_mul, hroot, zero_mul]


Verifying proof (Commit b271affacf1fa368c4e879d75cd5aaf54b75b7ed):
apply orderOf_root_cyclotomic_dvd

Attempt failure.

---172/200---
For theorem Polynomial.orderOf_root_cyclotomic_dvd in Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean:
theorem orderOf_root_cyclotomic_dvd {n : â„•} (hpos : 0 < n) {p : â„•} [Fact p.Prime] {a : â„•}
    (hroot : IsRoot (cyclotomic n (ZMod p)) (Nat.castRingHom (ZMod p) a)) :
    orderOf (ZMod.unitOfCoprime a (coprime_of_root_cyclotomic hpos hroot)) âˆ£ n 


Original valid proof:
:= by
  apply orderOf_dvd_of_pow_eq_one
  suffices hpow : eval (Nat.castRingHom (ZMod p) a) (X ^ n - 1 : (ZMod p)[X]) = 0 by
    simp only [eval_X, eval_one, eval_pow, eval_sub, eq_natCast] at hpow
    apply Units.val_eq_one.1
    simp only [sub_eq_zero.mp hpow, ZMod.coe_unitOfCoprime, Units.val_pow_eq_pow_val]
  rw [IsRoot.def] at hroot
  rw [â† prod_cyclotomic_eq_X_pow_sub_one hpos (ZMod p), â† Nat.cons_self_properDivisors hpos.ne',
    Finset.prod_cons, eval_mul, hroot, zero_mul]


Verifying proof (Commit e0989671112bd22d51437b85db4afabad67d0756):
apply orderOf_root_cyclotomic_dvd

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Nilpotent.lean - 2024-09-09 00:20:02.312035.
---173/200---
For theorem Polynomial.isUnit_of_coeff_isUnit_isNilpotent in Mathlib/RingTheory/Polynomial/Nilpotent.lean:
theorem isUnit_of_coeff_isUnit_isNilpotent (hunit : IsUnit (P.coeff 0))
    (hnil : âˆ€ i, i â‰  0 â†’ IsNilpotent (P.coeff i)) : IsUnit P 


Original valid proof:
:= by
  induction' h : P.natDegree using Nat.strong_induction_on with k hind generalizing P
  by_cases hdeg : P.natDegree = 0
  { rw [eq_C_of_natDegree_eq_zero hdeg]
    exact hunit.map C }
  set Pâ‚ := P.eraseLead with hPâ‚
  suffices IsUnit Pâ‚ by
    rw [â† eraseLead_add_monomial_natDegree_leadingCoeff P, â† C_mul_X_pow_eq_monomial, â† hPâ‚]
    refine IsNilpotent.isUnit_add_left_of_commute ?_ this (Commute.all _ _)
    exact isNilpotent_C_mul_pow_X_of_isNilpotent _ (hnil _ hdeg)
  have hdegâ‚‚ := lt_of_le_of_lt P.eraseLead_natDegree_le (Nat.sub_lt
    (Nat.pos_of_ne_zero hdeg) zero_lt_one)
  refine hind Pâ‚.natDegree ?_ ?_ (fun i hi => ?_) rfl
  Â· simp_rw [â† h, hdegâ‚‚]
  Â· simp_rw [eraseLead_coeff_of_ne _ (Ne.symm hdeg), hunit]
  Â· by_cases H : i â‰¤ Pâ‚.natDegree
    Â· simp_rw [eraseLead_coeff_of_ne _ (ne_of_lt (lt_of_le_of_lt H hdegâ‚‚)), hnil i hi]
    Â· simp_rw [coeff_eq_zero_of_natDegree_lt (lt_of_not_ge H), IsNilpotent.zero]


Verifying proof (Commit b492f764dc62b80a0be745055df26ce5b018a24a):
rw [isUnit_of_coeff_isUnit_isNilpotent_isNilpotent_isUnit_isNilpotent]

Attempt failure.

Working on Mathlib/RingTheory/PowerSeries/Derivative.lean - 2024-09-09 00:20:23.329665.
---174/200---
For theorem PowerSeries.derivativeFun_mul in Mathlib/RingTheory/PowerSeries/Derivative.lean:
theorem derivativeFun_mul (f g : RâŸ¦XâŸ§) :
    derivativeFun (f * g) = f â€¢ g.derivativeFun + g â€¢ f.derivativeFun 


Original valid proof:
:= by
  ext n
  have hâ‚ : n < n + 1 := lt_succ_self n
  have hâ‚‚ : n < n + 1 + 1 := Nat.lt_add_right _ hâ‚
  rw [coeff_derivativeFun, map_add, coeff_mul_eq_coeff_trunc_mul_trunc _ _ (lt_succ_self _),
    smul_eq_mul, smul_eq_mul, coeff_mul_eq_coeff_trunc_mul_truncâ‚‚ g f.derivativeFun hâ‚‚ hâ‚,
    coeff_mul_eq_coeff_trunc_mul_truncâ‚‚ f g.derivativeFun hâ‚‚ hâ‚, trunc_derivativeFun,
    trunc_derivativeFun, â† map_add, â† derivativeFun_coe_mul_coe, coeff_derivativeFun]


Verifying proof (Commit a3708498bec5c2641fd86b158487e675e90d687a):
simp_rw [derivativeFun_mul, derivativeFun_mul, derivativeFun_mul]

Attempt failure.

Working on Mathlib/RingTheory/Valuation/Basic.lean - 2024-09-09 00:20:44.171970.
---175/200---
For theorem AddValuation.ext_iff in Mathlib/RingTheory/Valuation/Basic.lean:
theorem ext_iff {vâ‚ vâ‚‚ : Valuation R Î“â‚€} : vâ‚ = vâ‚‚ â†” âˆ€ r, vâ‚ r = vâ‚‚ r 


Original valid proof:
:=
  DFunLike.ext_iff


Verifying proof (Commit ae8b24f33174f0b9fcd8f2d87ba6c65a18ae9ceb):
constructor

Attempt failure.

Working on Mathlib/Topology/Algebra/Group/Basic.lean - 2024-09-09 00:21:05.300152.
---176/200---
For theorem TopologicalGroup.exists_antitone_basis_nhds_one in Mathlib/Topology/Algebra/Group/Basic.lean:
theorem TopologicalGroup.exists_antitone_basis_nhds_one :
    âˆƒ u : â„• â†’ Set G, (ğ“ 1).HasAntitoneBasis u âˆ§ âˆ€ n, u (n + 1) * u (n + 1) âŠ† u n 


Original valid proof:
:= by
  rcases (ğ“ (1 : G)).exists_antitone_basis with âŸ¨u, hu, u_antiâŸ©
  have :=
    ((hu.prod_nhds hu).tendsto_iff hu).mp
      (by simpa only [mul_one] using continuous_mul.tendsto ((1, 1) : G Ã— G))
  simp only [and_self_iff, mem_prod, and_imp, Prod.forall, exists_true_left, Prod.exists,
    forall_true_left] at this
  have event_mul : âˆ€ n : â„•, âˆ€á¶  m in atTop, u m * u m âŠ† u n := by
    intro n
    rcases this n with âŸ¨j, k, -, hâŸ©
    refine atTop_basis.eventually_iff.mpr âŸ¨max j k, True.intro, fun m hm => ?_âŸ©
    rintro - âŸ¨a, ha, b, hb, rflâŸ©
    exact h a b (u_anti ((le_max_left _ _).trans hm) ha) (u_anti ((le_max_right _ _).trans hm) hb)
  obtain âŸ¨Ï†, -, hÏ†, Ï†_anti_basisâŸ© := HasAntitoneBasis.subbasis_with_rel âŸ¨hu, u_antiâŸ© event_mul
  exact âŸ¨u âˆ˜ Ï†, Ï†_anti_basis, fun n => hÏ† n.lt_succ_selfâŸ©


Verifying proof (Commit 9f9d83a281e21565e06f284c1cf7e46e6c0ad35c):
rcases TopologicalGroup.exists_antitone_basis_nhds_one with
  âŸ¨u, huâŸ©

Attempt failure.

Working on Mathlib/Topology/Algebra/Module/Cardinality.lean - 2024-09-09 00:21:22.564531.
---177/200---
For theorem cardinal_eq_of_mem_nhds in Mathlib/Topology/Algebra/Module/Cardinality.lean:
lemma cardinal_eq_of_mem_nhds_zero
    {E : Type*} (ğ•œ : Type*) [NontriviallyNormedField ğ•œ] [AddCommGroup E] [Module ğ•œ E]
    [TopologicalSpace E] [ContinuousSMul ğ•œ E] {s : Set E} (hs : s âˆˆ ğ“ (0 : E)) : #s = #E 


Original valid proof:
:= by
  obtain âŸ¨c, hcâŸ© : âˆƒ x : ğ•œ , 1 < â€–xâ€– := NormedField.exists_lt_norm ğ•œ 1
  have cn_ne : âˆ€ n, c^n â‰  0 := by
    intro n
    apply pow_ne_zero
    rintro rfl
    simp only [norm_zero] at hc
    exact lt_irrefl _ (hc.trans zero_lt_one)
  have A : âˆ€ (x : E), âˆ€á¶  n in (atTop : Filter â„•), x âˆˆ c^n â€¢ s := by
    intro x
    have : Tendsto (fun n â†¦ (c^n) â»Â¹ â€¢ x) atTop (ğ“ ((0 : ğ•œ) â€¢ x)) := by
      have : Tendsto (fun n â†¦ (c^n)â»Â¹) atTop (ğ“ 0) := by
        simp_rw [â† inv_pow]
        apply tendsto_pow_atTop_nhds_zero_of_norm_lt_one
        rw [norm_inv]
        exact inv_lt_one hc
      exact Tendsto.smul_const this x
    rw [zero_smul] at this
    filter_upwards [this hs] with n (hn : (c ^ n)â»Â¹ â€¢ x âˆˆ s)
    exact (mem_smul_set_iff_inv_smul_memâ‚€ (cn_ne n) _ _).2 hn
  have B : âˆ€ n, #(c^n â€¢ s :) = #s := by
    intro n
    have : (c^n â€¢ s :) â‰ƒ s :=
    { toFun := fun x â†¦ âŸ¨(c^n)â»Â¹ â€¢ x.1, (mem_smul_set_iff_inv_smul_memâ‚€ (cn_ne n) _ _).1 x.2âŸ©
      invFun := fun x â†¦ âŸ¨(c^n) â€¢ x.1, smul_mem_smul_set x.2âŸ©
      left_inv := fun x â†¦ by simp [smul_smul, mul_inv_cancel (cn_ne n)]
      right_inv := fun x â†¦ by simp [smul_smul, inv_mul_cancel (cn_ne n)] }
    exact Cardinal.mk_congr this
  apply (Cardinal.mk_of_countable_eventually_mem A B).symm


Verifying proof (Commit 453c456b049db19d87dc21aed1a69aaf23bd5e15):
rw [mem_nhds_zero_iff] at hs

Attempt failure.

Working on Mathlib/Topology/Algebra/Order/LiminfLimsup.lean - 2024-09-09 00:21:43.247521.
---178/200---
For theorem tendsto_of_liminf_eq_limsup in Mathlib/Topology/Algebra/Order/LiminfLimsup.lean:
theorem tendsto_of_liminf_eq_limsup {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} (hinf : liminf u f = a)
    (hsup : limsup u f = a) (h : f.IsBoundedUnder (Â· â‰¤ Â·) u := by isBoundedDefault)
    (h' : f.IsBoundedUnder (Â· â‰¥ Â·) u := by isBoundedDefault) : Tendsto u f (ğ“ a) 


Original valid proof:
:=
  le_nhds_of_limsSup_eq_limsInf h h' hsup hinf


Verifying proof (Commit 8f4f347b47261491fcaffde5530e0b5f8490768e):
rw [tendsto_of_liminf_eq_limsup]

Attempt failure.

Working on Mathlib/Topology/Algebra/Valuation.lean - 2024-09-09 00:21:51.945237.
---179/200---
For theorem Valued.loc_const in Mathlib/Topology/Algebra/Valuation.lean:
theorem loc_const {x : R} (h : (v x : Î“â‚€) â‰  0) : { y : R | v y = v x } âˆˆ ğ“ x 


Original valid proof:
:= by
  rw [mem_nhds]
  use Units.mk0 _ h
  rw [Units.val_mk0]
  intro y y_in
  exact Valuation.map_eq_of_sub_lt _ y_in


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
rw [mem_nhds_iff]

Attempt failure.

---180/200---
For theorem Valuation.subgroups_basis in Mathlib/Topology/Algebra/Valuation.lean:
theorem subgroups_basis : RingSubgroupsBasis fun Î³ : Î“â‚€Ë£ => (v.ltAddSubgroup Î³ : AddSubgroup R) 


Original valid proof:
:=
  { inter := by
      rintro Î³â‚€ Î³â‚
      use min Î³â‚€ Î³â‚
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro Î³
      cases' exists_square_le Î³ with Î³â‚€ h
      use Î³â‚€
      rintro - âŸ¨r, r_in, s, s_in, rflâŸ©
      calc
        (v (r * s) : Î“â‚€) = v r * v s := Valuation.map_mul _ _ _
        _ < Î³â‚€ * Î³â‚€ := mul_lt_mulâ‚€ r_in s_in
        _ â‰¤ Î³ := mod_cast h
    leftMul := by
      rintro x Î³
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | âŸ¨Î³x, HxâŸ©)
      Â· use (1 : Î“â‚€Ë£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt Î³
      Â· use Î³xâ»Â¹ * Î³
        rintro y (vy_lt : v y < â†‘(Î³xâ»Â¹ * Î³))
        change (v (x * y) : Î“â‚€) < Î³
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mulâ‚€ vy_lt
    rightMul := by
      rintro x Î³
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | âŸ¨Î³x, HxâŸ©)
      Â· use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt Î³
      Â· use Î³xâ»Â¹ * Î³
        rintro y (vy_lt : v y < â†‘(Î³xâ»Â¹ * Î³))
        change (v (y * x) : Î“â‚€) < Î³
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mulâ‚€ vy_lt }


Verifying proof (Commit 14c729603a56a1a02f31a1b28b852fe56d29c058):
refine RingSubgroupsBasis.ext fun Î³ => ?_

Attempt failure.

Working on Mathlib/Topology/Algebra/WithZeroTopology.lean - 2024-09-09 00:22:34.099561.
---181/200---
For theorem WithZeroTopology.hasBasis_nhds_zero in Mathlib/Topology/Algebra/WithZeroTopology.lean:
theorem hasBasis_nhds_zero : (ğ“ (0 : Î“â‚€)).HasBasis (fun Î³ : Î“â‚€ => Î³ â‰  0) Iio 


Original valid proof:
:= by
  rw [nhds_zero]
  refine hasBasis_biInf_principal ?_ âŸ¨1, one_ne_zeroâŸ©
  exact directedOn_iff_directed.2 (Monotone.directed_ge fun a b hab => Iio_subset_Iio hab)


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
refine hasBasis_nhds_zero.mem_iff.2 âŸ¨Î³, hasBasis_nhds_zeroâŸ©

Attempt failure.

Working on Mathlib/Topology/Bases.lean - 2024-09-09 00:22:39.703072.
---182/200---
For theorem TopologicalSpace.separableSpace_iff_countable in Mathlib/Topology/Bases.lean:
theorem separableSpace_iff_countable [DiscreteTopology Î±] : SeparableSpace Î± â†” Countable Î± 


Original valid proof:
:= by
  simp [separableSpace_iff, countable_univ_iff]


Verifying proof (Commit 0bb63b2bff135338722ab98f6da549f3e6350f0a):
rw [countable_iff_countable]

Attempt failure.

Working on Mathlib/Topology/Category/CompHaus/EffectiveEpi.lean - 2024-09-09 00:22:47.972640.
---183/200---
For theorem CompHaus.effectiveEpiFamily_tfae in Mathlib/Topology/Category/CompHaus/EffectiveEpi.lean:
theorem effectiveEpiFamily_tfae
    {Î± : Type} [Finite Î±] {B : CompHaus.{u}}
    (X : Î± â†’ CompHaus.{u}) (Ï€ : (a : Î±) â†’ (X a âŸ¶ B)) :
    TFAE
    [ EffectiveEpiFamily X Ï€
    , Epi (Sigma.desc Ï€)
    , âˆ€ b : B, âˆƒ (a : Î±) (x : X a), Ï€ a x = b
    ] 


Original valid proof:
:= by
  tfae_have 2 â†’ 1
  Â· intro
    simpa [â† effectiveEpi_desc_iff_effectiveEpiFamily, (effectiveEpi_tfae (Sigma.desc Ï€)).out 0 1]
  tfae_have 1 â†’ 2
  Â· intro; infer_instance
  tfae_have 3 â†’ 2
  Â· intro e
    rw [epi_iff_surjective]
    intro b
    obtain âŸ¨t, x, hâŸ© := e b
    refine âŸ¨Sigma.Î¹ X t x, ?_âŸ©
    change (Sigma.Î¹ X t â‰« Sigma.desc Ï€) x = _
    simpa using h
  tfae_have 2 â†’ 3
  Â· intro e; rw [epi_iff_surjective] at e
    let i : âˆ X â‰… finiteCoproduct X :=
      (colimit.isColimit _).coconePointUniqueUpToIso (finiteCoproduct.isColimit _)
    intro b
    obtain âŸ¨t, rflâŸ© := e b
    let q := i.hom t
    refine âŸ¨q.1,q.2,?_âŸ©
    have : t = i.inv (i.hom t) := show t = (i.hom â‰« i.inv) t by simp only [i.hom_inv_id]; rfl
    rw [this]
    show _ = (i.inv â‰« Sigma.desc Ï€) (i.hom t)
    suffices i.inv â‰« Sigma.desc Ï€ = finiteCoproduct.desc X Ï€ by
      rw [this]; rfl
    rw [Iso.inv_comp_eq]
    apply colimit.hom_ext
    rintro âŸ¨aâŸ©
    simp only [i, Discrete.functor_obj, colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app,
      colimit.comp_coconePointUniqueUpToIso_hom_assoc]
    ext; rfl
  tfae_finish


Verifying proof (Commit 120334db6bd1644200a0101ca523070340f20491):
rw [effectiveEpiFamily_theorem_effectiveEpiFamily_theorem]

Attempt failure.

Working on Mathlib/Topology/Category/Profinite/Nobeling.lean - 2024-09-09 00:23:08.799071.
---184/200---
For theorem Profinite.NobelingProof.Nobeling_aux in Mathlib/Topology/Category/Profinite/Nobeling.lean:
theorem Nobeling_aux : Module.Free â„¤ (LocallyConstant S â„¤) 


Original valid proof:
:= Module.Free.of_equiv'
  (Module.Free.of_basis <| GoodProducts.Basis _ hÎ¹.isClosed_range) (LocallyConstant.congrLeftâ‚— â„¤
  (Homeomorph.ofEmbedding Î¹ hÎ¹.toEmbedding)).symm


Verifying proof (Commit 050597bd179a992452551cc51fe5aea3b4bdaf61):
heorem Nobeling_aux Nobeling_aux Nobeling_aux

Attempt failure.

Working on Mathlib/Topology/Category/TopCat/EffectiveEpi.lean - 2024-09-09 00:23:29.030725.
---185/200---
For theorem TopCat.effectiveEpi_iff_quotientMap in Mathlib/Topology/Category/TopCat/EffectiveEpi.lean:
theorem effectiveEpi_iff_quotientMap {B X : TopCat.{u}} (Ï€ : X âŸ¶ B) :
    EffectiveEpi Ï€ â†” QuotientMap Ï€ 


Original valid proof:
:= by
  refine âŸ¨fun _ â†¦ ?_, fun hÏ€ â†¦ âŸ¨âŸ¨effectiveEpiStructOfQuotientMap Ï€ hÏ€âŸ©âŸ©âŸ©
  have hÏ€ : RegularEpi Ï€ := inferInstance
  let F := parallelPair hÏ€.left hÏ€.right
  let i : B â‰… colimit F := hÏ€.isColimit.coconePointUniqueUpToIso (colimit.isColimit _)
  suffices QuotientMap (homeoOfIso i âˆ˜ Ï€) by
    simpa [â† Function.comp.assoc] using (homeoOfIso i).symm.quotientMap.comp this
  constructor
  Â· change Function.Surjective (Ï€ â‰« i.hom)
    rw [â† epi_iff_surjective]
    infer_instance
  Â· ext U
    have : Ï€ â‰« i.hom = colimit.Î¹ F WalkingParallelPair.one := by simp [i, â† Iso.eq_comp_inv]
    rw [isOpen_coinduced (f := (homeoOfIso i âˆ˜ Ï€)), coequalizer_isOpen_iff _ U, â† this]
    rfl


Verifying proof (Commit 76f1a2bc2fd4cfd9e874de1d4ee20645b403a690):
simp only [quotientMap_iff_quotientMap_iff, quotientMap_iff_effectiveEpi_iff_quotientMap]

Attempt failure.

Working on Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean - 2024-09-09 00:23:37.268969.
---186/200---
For theorem TopCat.pullback_fst_image_snd_preimage in Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean:
theorem pullback_fst_image_snd_preimage (f : X âŸ¶ Z) (g : Y âŸ¶ Z) (U : Set Y) :
    (pullback.fst : pullback f g âŸ¶ _) '' ((pullback.snd : pullback f g âŸ¶ _) â»Â¹' U) =
      f â»Â¹' (g '' U) 


Original valid proof:
:= by
  ext x
  constructor
  Â· rintro âŸ¨(y : (forget TopCat).obj _), hy, rflâŸ©
    exact
      âŸ¨(pullback.snd : pullback f g âŸ¶ _) y, hy,
        (ConcreteCategory.congr_hom pullback.condition y).symmâŸ©
  Â· rintro âŸ¨y, hy, eqâŸ©
    refine âŸ¨(TopCat.pullbackIsoProdSubtype f g).inv âŸ¨âŸ¨_, _âŸ©, eq.symmâŸ©, ?_, ?_âŸ©
    Â· simp only [coe_of, Set.mem_preimage]
      convert hy
      erw [pullbackIsoProdSubtype_inv_snd_apply]
    Â· rw [pullbackIsoProdSubtype_inv_fst_apply]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
rw [â† pullback.condition, â† pullback.condition, â† pullback.condition, â† pullback.conditing,
  â† pullback.conditing, â† pullback.conditing, pullback.conditing]

Attempt failure.

Working on Mathlib/Topology/Compactness/Compact.lean - 2024-09-09 00:23:47.094502.
---187/200---
For theorem Filter.hasBasis_coclosedCompact in Mathlib/Topology/Compactness/Compact.lean:
theorem hasBasis_coclosedCompact :
    (Filter.coclosedCompact X).HasBasis (fun s => IsClosed s âˆ§ IsCompact s) compl 


Original valid proof:
:= by
  simp only [Filter.coclosedCompact, iInf_and']
  refine hasBasis_biInf_principal' ?_ âŸ¨âˆ…, isClosed_empty, isCompact_emptyâŸ©
  rintro s âŸ¨hsâ‚, hsâ‚‚âŸ© t âŸ¨htâ‚, htâ‚‚âŸ©
  exact âŸ¨s âˆª t, âŸ¨âŸ¨hsâ‚.union htâ‚, hsâ‚‚.union htâ‚‚âŸ©, compl_subset_compl.2 subset_union_left,
    compl_subset_compl.2 subset_union_rightâŸ©âŸ©


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
refine hasBasis_coclosedCompact.theorem_compl_isClosedCompact hasBasis_coclosedCompact.isCompact

Attempt failure.

Working on Mathlib/Topology/Compactness/Lindelof.lean - 2024-09-09 00:23:55.059162.
---188/200---
For theorem IsLindelof.elim_countable_subcover in Mathlib/Topology/Compactness/Lindelof.lean:
theorem IsLindelof.elim_countable_subcover {Î¹ : Type v} (hs : IsLindelof s) (U : Î¹ â†’ Set X)
    (hUo : âˆ€ i, IsOpen (U i)) (hsU : s âŠ† â‹ƒ i, U i) :
    âˆƒ r : Set Î¹, r.Countable âˆ§ (s âŠ† â‹ƒ i âˆˆ r, U i) 


Original valid proof:
:= by
  have hmono : âˆ€ â¦ƒs t : Set Xâ¦„, s âŠ† t â†’ (âˆƒ r : Set Î¹, r.Countable âˆ§ t âŠ† â‹ƒ i âˆˆ r, U i)
      â†’ (âˆƒ r : Set Î¹, r.Countable âˆ§ s âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro _ _ hst âŸ¨r, âŸ¨hrcountable, hsubâŸ©âŸ©
    exact âŸ¨r, hrcountable, Subset.trans hst hsubâŸ©
  have hcountable_union : âˆ€ (S : Set (Set X)), S.Countable
      â†’ (âˆ€ s âˆˆ S, âˆƒ r : Set Î¹, r.Countable âˆ§ (s âŠ† â‹ƒ i âˆˆ r, U i))
      â†’ âˆƒ r : Set Î¹, r.Countable âˆ§ (â‹ƒâ‚€ S âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro S hS hsr
    choose! r hr using hsr
    refine âŸ¨â‹ƒ s âˆˆ S, r s, hS.biUnion_iff.mpr (fun s hs â†¦ (hr s hs).1), ?_âŸ©
    refine sUnion_subset ?h.right.h
    simp only [mem_iUnion, exists_prop, iUnion_exists, biUnion_and']
    exact fun i is x hx â†¦ mem_biUnion is ((hr i is).2 hx)
  have h_nhds : âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, âˆƒ r : Set Î¹, r.Countable âˆ§ (t âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro x hx
    let âŸ¨i, hiâŸ© := mem_iUnion.1 (hsU hx)
    refine âŸ¨U i, mem_nhdsWithin_of_mem_nhds ((hUo i).mem_nhds hi), {i}, by simp, ?_âŸ©
    simp only [mem_singleton_iff, iUnion_iUnion_eq_left]
    exact Subset.refl _
  exact hs.induction_on hmono hcountable_union h_nhds


Verifying proof (Commit ad1607ddeaaaa81b831dcb37615796d3fa93c9fe):
rcases exists_countable_subcover_elim_countable_subcover hUo hUo hsU with âŸ¨r', r'U, hr'UâŸ©

Attempt failure.

Working on Mathlib/Topology/Connected/Basic.lean - 2024-09-09 00:24:01.142581.
---189/200---
For theorem isPreconnected_of_forall_constant in Mathlib/Topology/Connected/Basic.lean:
theorem isPreconnected_of_forall_constant {s : Set Î±}
    (hs : âˆ€ f : Î± â†’ Bool, ContinuousOn f s â†’ âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, f x = f y) : IsPreconnected s 


Original valid proof:
:= by
  unfold IsPreconnected
  by_contra!
  rcases this with âŸ¨u, v, u_op, v_op, hsuv, âŸ¨x, x_in_s, x_in_uâŸ©, âŸ¨y, y_in_s, y_in_vâŸ©, HâŸ©
  have hy : y âˆ‰ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y âŸ¨y_in_s, âŸ¨y_in_u, y_in_vâŸ©âŸ©
  have : ContinuousOn u.boolIndicator s := by
    apply (continuousOn_boolIndicator_iff_isClopen _ _).mpr âŸ¨_, _âŸ©
    Â· rw [preimage_subtype_coe_eq_compl hsuv H]
      exact (v_op.preimage continuous_subtype_val).isClosed_compl
    Â· exact u_op.preimage continuous_subtype_val
  simpa [(u.mem_iff_boolIndicator _).mp x_in_u, (u.not_mem_iff_boolIndicator _).mp hy] using
    hs _ this x x_in_s y y_in_s


Verifying proof (Commit 64b674911520c89d4467fb9e8410ab9d79e82064):
rw [isPreconnected_iff]

Attempt failure.

---190/200---
For theorem isPreconnected_of_forall_constant in Mathlib/Topology/Connected/Basic.lean:
theorem isPreconnected_of_forall_constant {s : Set Î±}
    (hs : âˆ€ f : Î± â†’ Bool, ContinuousOn f s â†’ âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, f x = f y) : IsPreconnected s 


Original valid proof:
:= by
  unfold IsPreconnected
  by_contra!
  rcases this with âŸ¨u, v, u_op, v_op, hsuv, âŸ¨x, x_in_s, x_in_uâŸ©, âŸ¨y, y_in_s, y_in_vâŸ©, HâŸ©
  have hy : y âˆ‰ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y âŸ¨y_in_s, âŸ¨y_in_u, y_in_vâŸ©âŸ©
  have : ContinuousOn u.boolIndicator s := by
    apply (continuousOn_boolIndicator_iff_isClopen _ _).mpr âŸ¨_, _âŸ©
    Â· rw [preimage_subtype_coe_eq_compl hsuv H]
      exact (v_op.preimage continuous_subtype_val).isClosed_compl
    Â· exact u_op.preimage continuous_subtype_val
  simpa [(u.mem_iff_boolIndicator _).mp x_in_u, (u.not_mem_iff_boolIndicator _).mp hy] using
    hs _ this x x_in_s y y_in_s


Verifying proof (Commit 592e720e2651f6e8a7faf0968b75697c3bcd3b55):
rw [isPreconnected_iff]

Attempt failure.

Working on Mathlib/Topology/FiberBundle/Basic.lean - 2024-09-09 00:24:15.817118.
---191/200---
For theorem FiberBundle.exists_trivialization_Icc_subset in Mathlib/Topology/FiberBundle/Basic.lean:
theorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]
    [OrderTopology B] [FiberBundle F E] (a b : B) :
    âˆƒ e : Trivialization F (Ï€ F E), Icc a b âŠ† e.baseSet 


Original valid proof:
:= by
  obtain âŸ¨ea, heaâŸ© : âˆƒ ea : Trivialization F (Ï€ F E), a âˆˆ ea.baseSet :=
    âŸ¨trivializationAt F E a, mem_baseSet_trivializationAt F E aâŸ©
  cases' lt_or_le b a with hab hab
  Â· exact âŸ¨ea, by simp [*]âŸ©
  set s : Set B := { x âˆˆ Icc a b | âˆƒ e : Trivialization F (Ï€ F E), Icc a x âŠ† e.baseSet }
  have ha : a âˆˆ s := âŸ¨left_mem_Icc.2 hab, ea, by simp [hea]âŸ©
  have sne : s.Nonempty := âŸ¨a, haâŸ©
  have hsb : b âˆˆ upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := âŸ¨b, hsbâŸ©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c âˆˆ Icc a b := âŸ¨hsc.1 ha, hsc.2 hsbâŸ©
  obtain âŸ¨-, ec : Trivialization F (Ï€ F E), hec : Icc a c âŠ† ec.baseSetâŸ© : c âˆˆ s := by
    rcases hc.1.eq_or_lt with heq | hlt
    Â· rwa [â† heq]
    refine âŸ¨hc, ?_âŸ©
    obtain âŸ¨ec, hcâŸ© : âˆƒ ec : Trivialization F (Ï€ F E), c âˆˆ ec.baseSet :=
      âŸ¨trivializationAt F E c, mem_baseSet_trivializationAt F E câŸ©
    obtain âŸ¨c', hc', hc'eâŸ© : âˆƒ c' âˆˆ Ico a c, Ioc c' c âŠ† ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain âŸ¨d, âŸ¨hdab, ead, hadâŸ©, hdâŸ© : âˆƒ d âˆˆ s, d âˆˆ Ioc c' c := hsc.exists_between hc'.2
    refine âŸ¨ead.piecewiseLe ec d (had âŸ¨hdab.1, le_rflâŸ©) (hc'e hd), subset_ite.2 ?_âŸ©
    exact âŸ¨fun x hx => had âŸ¨hx.1.1, hx.2âŸ©, fun x hx => hc'e âŸ¨hd.1.trans (not_le.1 hx.2), hx.1.2âŸ©âŸ©
  rcases hc.2.eq_or_lt with heq | hlt
  Â· exact âŸ¨ec, heq â–¸ hecâŸ©
  rsuffices âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, âˆƒ e : Trivialization F (Ï€ F E), Icc a d âŠ† e.baseSet
  Â· exact ((hsc.1 âŸ¨âŸ¨hc.1.trans hdcb.1.le, hdcb.2âŸ©, hdâŸ©).not_lt hdcb.1).elim
  obtain âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, Ico c d âŠ† ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec âŸ¨hc.1, le_rflâŸ©))
  have had : Ico a d âŠ† ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  Â· obtain âŸ¨ed, hedâŸ© : âˆƒ ed : Trivialization F (Ï€ F E), d âˆˆ ed.baseSet :=
      âŸ¨trivializationAt F E d, mem_baseSet_trivializationAt F E dâŸ©
    refine âŸ¨d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono inter_subset_right inter_subset_right), fun x hx => ?_âŸ©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr âŸ¨hed, hdcb.1âŸ©, Or.inl âŸ¨had âŸ¨hx.1, hxdâŸ©, hxdâŸ©]
  Â· rw [disjoint_left] at he
    push_neg at he
    rcases he with âŸ¨d', hdd' : d' < d, hd'câŸ©
    exact âŸ¨d', âŸ¨hd'c, hdd'.le.trans hdcb.2âŸ©, ec, (Icc_subset_Ico_right hdd').trans hadâŸ©


Verifying proof (Commit f7006a73d443b58eaf61494edacfeaae71d812f2):
rcases FiberBundle.exists_trivialization_Icc_subset with âŸ¨e, heâŸ©

Attempt failure.

Working on Mathlib/Topology/Homotopy/HomotopyGroup.lean - 2024-09-09 00:24:22.951261.
---192/200---
For theorem GenLoop.homotopicFrom in Mathlib/Topology/Homotopy/HomotopyGroup.lean:
theorem homotopicFrom (i : N) {p q : Î©^ N X x} :
    (toLoop i p).Homotopic (toLoop i q) â†’ Homotopic p q 


Original valid proof:
:= by
  refine Nonempty.map fun H => âŸ¨âŸ¨homotopyFrom i H, ?_, ?_âŸ©, ?_âŸ©
  pick_goal 3
  Â· rintro t y âŸ¨j, jHâŸ©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    Â· simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
        Function.uncurry_apply_pair]
      rw [H.eq_fst]
      exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    Â· rw [p.2 _ âŸ¨j, jHâŸ©]; apply boundary; exact âŸ¨âŸ¨j, hâŸ©, jHâŸ©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
      Function.uncurry_apply_pair, ContinuousMap.HomotopyWith.apply_zero,
      ContinuousMap.HomotopyWith.apply_one, ne_eq, Path.coe_toContinuousMap, toLoop_apply_coe,
      ContinuousMap.curry_apply, ContinuousMap.comp_apply]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv


Verifying proof (Commit 0ea5bd2e88bc0475765f0292fb709ff692758ac2):
simp only [Homotopic]

Attempt failure.

Working on Mathlib/Topology/MetricSpace/PiNat.lean - 2024-09-09 00:24:56.597289.
---193/200---
For theorem PiNat.exists_lipschitz_retraction_of_isClosed in Mathlib/Topology/MetricSpace/PiNat.lean:
theorem exists_lipschitz_retraction_of_isClosed {s : Set (âˆ€ n, E n)} (hs : IsClosed s)
    (hne : s.Nonempty) :
    âˆƒ f : (âˆ€ n, E n) â†’ âˆ€ n, E n, (âˆ€ x âˆˆ s, f x = x) âˆ§ range f = s âˆ§ LipschitzWith 1 f 


Original valid proof:
:= by
  set f := fun x => if x âˆˆ s then x else (inter_cylinder_longestPrefix_nonempty hs hne x).some
  have fs : âˆ€ x âˆˆ s, f x = x := fun x xs => by simp [f, xs]
  refine âŸ¨f, fs, ?_, ?_âŸ©
  Â· apply Subset.antisymm
    Â· rintro x âŸ¨y, rflâŸ©
      by_cases hy : y âˆˆ s
      Â· rwa [fs y hy]
      simpa [f, if_neg hy] using (inter_cylinder_longestPrefix_nonempty hs hne y).choose_spec.1
    Â· intro x hx
      rw [â† fs x hx]
      exact mem_range_self _
  Â· refine LipschitzWith.mk_one fun x y => ?_
    rcases eq_or_ne x y with (rfl | hxy)
    Â· simp
    rcases eq_or_ne (f x) (f y) with (h' | hfxfy)
    Â· simp [h', dist_nonneg]
    have I2 : cylinder x (firstDiff x y) = cylinder y (firstDiff x y) := by
      rw [â† mem_cylinder_iff_eq]
      apply mem_cylinder_firstDiff
    suffices firstDiff x y â‰¤ firstDiff (f x) (f y) by
      simpa [dist_eq_of_ne hxy, dist_eq_of_ne hfxfy]
    by_cases xs : x âˆˆ s
    Â· rw [fs x xs] at hfxfy âŠ¢
      by_cases ys : y âˆˆ s
      Â· rw [fs y ys]
      have A : (s âˆ© cylinder y (longestPrefix y s)).Nonempty :=
        inter_cylinder_longestPrefix_nonempty hs hne y
      have fy : f y = A.some := by simp_rw [f, if_neg ys]
      have I : cylinder A.some (firstDiff x y) = cylinder y (firstDiff x y) := by
        rw [â† mem_cylinder_iff_eq, firstDiff_comm]
        apply cylinder_anti y _ A.some_mem.2
        exact firstDiff_le_longestPrefix hs ys xs
      rwa [â† fy, â† I2, â† mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy.symm,
        firstDiff_comm _ x] at I
    Â· by_cases ys : y âˆˆ s
      Â· have A : (s âˆ© cylinder x (longestPrefix x s)).Nonempty :=
          inter_cylinder_longestPrefix_nonempty hs hne x
        have fx : f x = A.some := by simp_rw [f, if_neg xs]
        have I : cylinder A.some (firstDiff x y) = cylinder x (firstDiff x y) := by
          rw [â† mem_cylinder_iff_eq]
          apply cylinder_anti x _ A.some_mem.2
          apply firstDiff_le_longestPrefix hs xs ys
        rw [fs y ys] at hfxfy âŠ¢
        rwa [â† fx, I2, â† mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy] at I
      Â· have Ax : (s âˆ© cylinder x (longestPrefix x s)).Nonempty :=
          inter_cylinder_longestPrefix_nonempty hs hne x
        have fx : f x = Ax.some := by simp_rw [f, if_neg xs]
        have Ay : (s âˆ© cylinder y (longestPrefix y s)).Nonempty :=
          inter_cylinder_longestPrefix_nonempty hs hne y
        have fy : f y = Ay.some := by simp_rw [f, if_neg ys]
        by_cases H : longestPrefix x s < firstDiff x y âˆ¨ longestPrefix y s < firstDiff x y
        Â· have : cylinder x (longestPrefix x s) = cylinder y (longestPrefix y s) := by
            cases' H with H H
            Â· exact cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff hs hne H xs ys
            Â· symm
              rw [firstDiff_comm] at H
              exact cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff hs hne H ys xs
          rw [fx, fy] at hfxfy
          apply (hfxfy _).elim
          congr
        Â· push_neg at H
          have I1 : cylinder Ax.some (firstDiff x y) = cylinder x (firstDiff x y) := by
            rw [â† mem_cylinder_iff_eq]
            exact cylinder_anti x H.1 Ax.some_mem.2
          have I3 : cylinder y (firstDiff x y) = cylinder Ay.some (firstDiff x y) := by
            rw [eq_comm, â† mem_cylinder_iff_eq]
            exact cylinder_anti y H.2 Ay.some_mem.2
          have : cylinder Ax.some (firstDiff x y) = cylinder Ay.some (firstDiff x y) := by
            rw [I1, I2, I3]
          rw [â† fx, â† fy, â† mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy] at this
          exact this


Verifying proof (Commit 868e361b310c1d818e48f5bcba9026910b1f6cdf):
rcases exists_lipschitz_retraction_of_isClosed hs hne hne with
  âŸ¨f, fs, fs_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz,

Attempt failure.

Working on Mathlib/Topology/PartialHomeomorph.lean - 2024-09-09 00:25:17.591178.
---194/200---
For theorem PartialHomeomorph.subtypeRestr_symm_eqOn_of_le in Mathlib/Topology/PartialHomeomorph.lean:
theorem subtypeRestr_symm_eqOn_of_le {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U â‰¤ V) : EqOn (e.subtypeRestr hV).symm (Set.inclusion hUV âˆ˜ (e.subtypeRestr hU).symm)
      (e.subtypeRestr hU).target 


Original valid proof:
:= by
  set i := Set.inclusion hUV
  intro y hy
  dsimp [PartialHomeomorph.subtypeRestr_def] at hy âŠ¢
  have hyV : e.symm y âˆˆ (V.partialHomeomorphSubtypeCoe hV).target := by
    rw [Opens.partialHomeomorphSubtypeCoe_target] at hy âŠ¢
    exact hUV hy.2
  refine (V.partialHomeomorphSubtypeCoe hV).injOn ?_ trivial ?_
  Â· rw [â† PartialHomeomorph.symm_target]
    apply PartialHomeomorph.map_source
    rw [PartialHomeomorph.symm_source]
    exact hyV
  Â· rw [(V.partialHomeomorphSubtypeCoe hV).right_inv hyV]
    show _ = U.partialHomeomorphSubtypeCoe hU _
    rw [(U.partialHomeomorphSubtypeCoe hU).right_inv hy.2]


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
simp only [subtypeRestr_symm_eqOn_of_le]

Attempt failure.

Working on Mathlib/Topology/Perfect.lean - 2024-09-09 00:25:25.607647.
---195/200---
For theorem exists_perfect_nonempty_of_isClosed_of_not_countable in Mathlib/Topology/Perfect.lean:
theorem exists_perfect_nonempty_of_isClosed_of_not_countable [SecondCountableTopology Î±]
    (hclosed : IsClosed C) (hunc : Â¬C.Countable) : âˆƒ D : Set Î±, Perfect D âˆ§ D.Nonempty âˆ§ D âŠ† C 


Original valid proof:
:= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with âŸ¨V, D, Vct, Dperf, VDâŸ©
  refine âŸ¨D, âŸ¨Dperf, ?_âŸ©âŸ©
  constructor
  Â· rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
rw [exists_perfect_nonempty_of_isClosed_of_not_countable] at hunc

Attempt failure.

---196/200---
For theorem exists_perfect_nonempty_of_isClosed_of_not_countable in Mathlib/Topology/Perfect.lean:
theorem exists_perfect_nonempty_of_isClosed_of_not_countable [SecondCountableTopology Î±]
    (hclosed : IsClosed C) (hunc : Â¬C.Countable) : âˆƒ D : Set Î±, Perfect D âˆ§ D.Nonempty âˆ§ D âŠ† C 


Original valid proof:
:= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with âŸ¨V, D, Vct, Dperf, VDâŸ©
  refine âŸ¨D, âŸ¨Dperf, ?_âŸ©âŸ©
  constructor
  Â· rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
rw [exists_perfect_nonempty_of_isClosed_of_not_countable] at hunc

Attempt failure.

Working on Mathlib/Topology/Separation.lean - 2024-09-09 00:25:35.270424.
---197/200---
For theorem compact_t2_tot_disc_iff_tot_sep in Mathlib/Topology/Separation.lean:
theorem compact_t2_tot_disc_iff_tot_sep : TotallyDisconnectedSpace X â†” TotallySeparatedSpace X 


Original valid proof:
:= by
  refine âŸ¨fun h => âŸ¨fun x _ y _ => ?_âŸ©, @TotallySeparatedSpace.totallyDisconnectedSpace _ _âŸ©
  contrapose!
  intro hyp
  suffices x âˆˆ connectedComponent y by
    simpa [totallyDisconnectedSpace_iff_connectedComponent_singleton.1 h y, mem_singleton_iff]
  rw [connectedComponent_eq_iInter_isClopen, mem_iInter]
  rintro âŸ¨w : Set X, hw : IsClopen w, hy : y âˆˆ wâŸ©
  by_contra hx
  exact hyp âŸ¨wá¶œ, w, hw.1.isOpen_compl, hw.2, hx, hy, (@isCompl_compl _ w _).symm.codisjoint.top_le,
    disjoint_compl_leftâŸ©


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
rw [totallySeparatedSpace_iff_totallySeparatedSpace_iff]

Attempt failure.

Working on Mathlib/Topology/ShrinkingLemma.lean - 2024-09-09 00:25:45.687989.
---198/200---
For theorem ShrinkingLemma.PartialRefinement.exists_gt in Mathlib/Topology/ShrinkingLemma.lean:
theorem exists_gt (v : PartialRefinement u s) (hs : IsClosed s) (i : Î¹) (hi : i âˆ‰ v.carrier) :
    âˆƒ v' : PartialRefinement u s, v < v' 


Original valid proof:
:= by
  have I : (s âˆ© â‹‚ (j) (_ : j â‰  i), (v j)á¶œ) âŠ† v i := by
    simp only [subset_def, mem_inter_iff, mem_iInter, and_imp]
    intro x hxs H
    rcases mem_iUnion.1 (v.subset_iUnion hxs) with âŸ¨j, hjâŸ©
    exact (em (j = i)).elim (fun h => h â–¸ hj) fun h => (H j h hj).elim
  have C : IsClosed (s âˆ© â‹‚ (j) (_ : j â‰  i), (v j)á¶œ) :=
    IsClosed.inter hs (isClosed_biInter fun _ _ => isClosed_compl_iff.2 <| v.isOpen _)
  rcases normal_exists_closure_subset C (v.isOpen i) I with âŸ¨vi, ovi, hvi, cviâŸ©
  refine âŸ¨âŸ¨update v i vi, insert i v.carrier, ?_, ?_, ?_, ?_âŸ©, ?_, ?_âŸ©
  Â· intro j
    rcases eq_or_ne j i with (rfl| hne) <;> simp [*, v.isOpen]
  Â· refine fun x hx => mem_iUnion.2 ?_
    rcases em (âˆƒ j â‰  i, x âˆˆ v j) with (âŸ¨j, hji, hjâŸ© | h)
    Â· use j
      rwa [update_noteq hji]
    Â· push_neg at h
      use i
      rw [update_same]
      exact hvi âŸ¨hx, mem_biInter hâŸ©
  Â· rintro j (rfl | hj)
    Â· rwa [update_same, â† v.apply_eq hi]
    Â· rw [update_noteq (ne_of_mem_of_not_mem hj hi)]
      exact v.closure_subset hj
  Â· intro j hj
    rw [mem_insert_iff, not_or] at hj
    rw [update_noteq hj.1, v.apply_eq hj.2]
  Â· refine âŸ¨subset_insert _ _, fun j hj => ?_âŸ©
    exact (update_noteq (ne_of_mem_of_not_mem hj hi) _ _).symm
  Â· exact fun hle => hi (hle.1 <| mem_insert _ _)


Verifying proof (Commit e2b5ca370bbc63149cba7caf35005bf2193dc387):
refine âŸ¨exists_gt _ _ _ hi, fun âŸ¨i, hiâŸ© => ?_âŸ©

Attempt failure.

Working on Mathlib/Topology/TietzeExtension.lean - 2024-09-09 00:25:50.678208.
---199/200---
For theorem BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding' in Mathlib/Topology/TietzeExtension.lean:
theorem exists_extension_norm_eq_of_closedEmbedding' (f : X â†’áµ‡ â„) (e : C(X, Y))
    (he : ClosedEmbedding e) : âˆƒ g : Y â†’áµ‡ â„, â€–gâ€– = â€–fâ€– âˆ§ g.compContinuous e = f 


Original valid proof:
:= by
  choose F hF_norm hF_dist using fun f : X â†’áµ‡ â„ => tietze_extension_step f e he
  set g : â„• â†’ Y â†’áµ‡ â„ := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : âˆ€ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : âˆ€ n, dist ((g n).compContinuous e) f â‰¤ (2 / 3) ^ n * â€–fâ€– := by
    intro n
    induction' n with n ihn
    Â· simp [g0]
    Â· rw [g_succ n, add_compContinuous, â† dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))
      rwa [â† dist_eq_norm']
  have hg_dist : âˆ€ n, dist (g n) (g (n + 1)) â‰¤ 1 / 3 * â€–fâ€– * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = â€–F (f - (g n).compContinuous e)â€– := by
        rw [g_succ, dist_eq_norm', add_sub_cancel_left]
      _ â‰¤ â€–f - (g n).compContinuous eâ€– / 3 := hF_norm _
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ â‰¤ 1 / 3 * ((2 / 3) ^ n * â€–fâ€–) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1)
      _ = 1 / 3 * â€–fâ€– * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ğ“ <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul â€–fâ€–]
    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine âŸ¨limUnder atTop g, le_antisymm ?_ ?_, hgeâŸ©
  Â· rw [â† dist_zero_left, â† g0]
    refine
      (dist_le_of_le_geometric_of_tendstoâ‚€ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : â„) = 1 by norm_num1]
  Â· rw [â† hge]
    exact norm_compContinuous_le _ _


Verifying proof (Commit 161c69c1dbf66cf3c7ec4f648a61551d044a43e4):
refine âŸ¨exists_extension_norm_eq_of_closedEmbedding', ?_, ?_âŸ©

Attempt failure.

Working on Mathlib/Topology/UniformSpace/Ascoli.lean - 2024-09-09 00:26:10.820495.
---200/200---
For theorem EquicontinuousOn.tendsto_uniformOnFun_iff_pi' in Mathlib/Topology/UniformSpace/Ascoli.lean:
theorem EquicontinuousOn.tendsto_uniformOnFun_iff_pi'
    {ğ”– : Set (Set X)} (ğ”–_compact : âˆ€ K âˆˆ ğ”–, IsCompact K)
    (F_eqcont : âˆ€ K âˆˆ ğ”–, EquicontinuousOn F K) (â„± : Filter Î¹) (f : X â†’ Î±) :
    Tendsto (UniformOnFun.ofFun ğ”– âˆ˜ F) â„± (ğ“ <| UniformOnFun.ofFun ğ”– f) â†”
    Tendsto ((â‹ƒâ‚€ ğ”–).restrict âˆ˜ F) â„± (ğ“ <| (â‹ƒâ‚€ ğ”–).restrict f) 


Original valid proof:
:= by
  rw [â† Filter.tendsto_comap_iff (g := (â‹ƒâ‚€ ğ”–).restrict), â† nhds_induced]
  simp_rw [UniformOnFun.topologicalSpace_eq, Pi.induced_restrict_sUnion ğ”– (Ï€ := fun _ â†¦ Î±),
    _root_.nhds_iInf, nhds_induced, tendsto_iInf, tendsto_comap_iff]
  congrm âˆ€ K (hK : K âˆˆ ğ”–), ?_
  have : CompactSpace K := isCompact_iff_compactSpace.mp (ğ”–_compact K hK)
  rw [â† (equicontinuous_restrict_iff _ |>.mpr <| F_eqcont K hK).tendsto_uniformFun_iff_pi]
  rfl


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
simp only [UniformOnFun.tendsto_restrict_restrict_restrict, UniformOnFun.tendsto_restrict,
  UniformOnFun.tendsto_restrict_restrict_restrict]

Attempt failure.

STARTING: Lean repo copy removal
DONE: Lean repo copy removal
Among 200 proof attempts, there were 0 successful and 200 failed attempts at proving their respect theorems.
The rate of successful proof = 0.0.
