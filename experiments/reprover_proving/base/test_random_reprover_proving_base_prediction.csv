filepath,thm_name,decl_name,commit,failed_proof,error_msg,statement,proof,predicted_proof
Mathlib/LinearAlgebra/Basis.lean,union_support_maximal_linearIndependent_eq_range_basis,union_support_maximal_linearIndependent_eq_range_basis,971a0d73179f0907eda2324b5a10ab2a071e3aae,":= by
  by_contra h
  simp only [â† Ne.eq_def, ne_univ_iff_exists_not_mem, mem_iUnion, not_exists_not,
    Finsupp.mem_support_iff, Finset.mem_coe] at h
  obtain âŸ¨b', wâŸ© := h
  let v' : Option Îº â†’ M := fun o => o.elim (b b') v
  have r : range v âŠ† range v' := by
    rintro - âŸ¨k, rflâŸ©
    use some k
    simp only [v', Option.elim_some]
  have r' : b b' âˆ‰ range v := by
    rintro âŸ¨k, pâŸ©
    simpa [w] using congr_arg (fun m => (b.repr m) b') p
  have r'' : range v â‰  range v' := by
    intro e
    have p : b b' âˆˆ range v' := by
      use none
      simp only [v', Option.elim_none]
    rw [â† e] at p
    exact r' p
  have i' : LinearIndependent R ((â†‘) : range v' â†’ M) := by
    apply LinearIndependent.to_subtype_range
    rw [linearIndependent_iff]
    intro l z
    rw [Finsupp.total_option] at z
    simp only [v', Option.elim'] at z
    change _ + Finsupp.total Îº M R v l.some = 0 at z
    have lâ‚€ : l none = 0 := by
      rw [â† eq_neg_iff_add_eq_zero] at z
      replace z := neg_eq_iff_eq_neg.mpr z
      apply_fun fun x => b.repr x b' at z
      simp only [repr_self, LinearEquiv.map_smul, mul_one, Finsupp.single_eq_same, Pi.neg_apply,
        Finsupp.smul_single', LinearEquiv.map_neg, Finsupp.coe_neg] at z
      erw [DFunLike.congr_fun (Finsupp.apply_total R (b.repr : M â†’â‚—[R] Î¹ â†’â‚€ R) v l.some) b'] at z
      simpa [Finsupp.total_apply, w] using z
    have lâ‚ : l.some = 0 := by
      rw [lâ‚€, zero_smul, zero_add] at z
      exact linearIndependent_iff.mp i _ z
    ext (_ | a)
    Â· simp only [lâ‚€, Finsupp.coe_zero, Pi.zero_apply]
    Â· erw [DFunLike.congr_fun lâ‚ a]
      simp only [Finsupp.coe_zero, Pi.zero_apply]
  rw [LinearIndependent.Maximal] at m
  specialize m (range v') i' r
  exact r'' m","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearEquiv
has type
  (Ïƒ : ?m.799504 â†’+* ?m.799505) â†’
    {Ïƒ' : ?m.799505 â†’+* ?m.799504} â†’
      [inst : RingHomInvPair Ïƒ Ïƒ'] â†’
        [inst : RingHomInvPair Ïƒ' Ïƒ] â†’
          (M : Type ?u.799501) â†’
            (Mâ‚‚ : Type ?u.799500) â†’
              [inst : AddCommMonoid M] â†’
                [inst_1 : AddCommMonoid Mâ‚‚] â†’
                  [inst : Module ?m.799504 M] â†’ [inst : Module ?m.799505 Mâ‚‚] â†’ Type (max ?u.799501 ?u.799500)
error:  simp made no progress","theorem union_support_maximal_linearIndependent_eq_range_basis {Î¹ : Type w} (b : Basis Î¹ R M)
    {Îº : Type w'} (v : Îº â†’ M) (i : LinearIndependent R v) (m : i.Maximal) :
    â‹ƒ k, ((b.repr (v k)).support : Set Î¹) = Set.univ ",":= by
  by_contra h
  simp only [â† Ne.eq_def, ne_univ_iff_exists_not_mem, mem_iUnion, not_exists_not,
    Finsupp.mem_support_iff, Finset.mem_coe] at h
  obtain âŸ¨b', wâŸ© := h
  let v' : Option Îº â†’ M := fun o => o.elim (b b') v
  have r : range v âŠ† range v' := by
    rintro - âŸ¨k, rflâŸ©
    use some k
    simp only [v', Option.elim_some]
  have r' : b b' âˆ‰ range v := by
    rintro âŸ¨k, pâŸ©
    simpa [w] using congr_arg (fun m => (b.repr m) b') p
  have r'' : range v â‰  range v' := by
    intro e
    have p : b b' âˆˆ range v' := by
      use none
      simp only [v', Option.elim_none]
    rw [â† e] at p
    exact r' p
  have i' : LinearIndependent R ((â†‘) : range v' â†’ M) := by
    apply LinearIndependent.to_subtype_range
    rw [linearIndependent_iff]
    intro l z
    rw [Finsupp.total_option] at z
    simp only [v', Option.elim'] at z
    change _ + Finsupp.total Îº M R v l.some = 0 at z
    have lâ‚€ : l none = 0 := by
      rw [â† eq_neg_iff_add_eq_zero] at z
      replace z := neg_eq_iff_eq_neg.mpr z
      apply_fun fun x => b.repr x b' at z
      simp only [repr_self, map_smul, mul_one, Finsupp.single_eq_same, Pi.neg_apply,
        Finsupp.smul_single', map_neg, Finsupp.coe_neg] at z
      erw [DFunLike.congr_fun (Finsupp.apply_total R (b.repr : M â†’â‚—[R] Î¹ â†’â‚€ R) v l.some) b'] at z
      simpa [Finsupp.total_apply, w] using z
    have lâ‚ : l.some = 0 := by
      rw [lâ‚€, zero_smul, zero_add] at z
      exact linearIndependent_iff.mp i _ z
    ext (_ | a)
    Â· simp only [lâ‚€, Finsupp.coe_zero, Pi.zero_apply]
    Â· erw [DFunLike.congr_fun lâ‚ a]
      simp only [Finsupp.coe_zero, Pi.zero_apply]
  rw [LinearIndependent.Maximal] at m
  specialize m (range v') i' r
  exact r'' m",simp [Set.eq_univ_iff_forall]
Mathlib/Topology/PartialHomeomorph.lean,PartialHomeomorph.subtypeRestr_symm_eqOn_of_le,subtypeRestr_symm_eqOn_of_le,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  set i := Set.inclusion hUV
  intro y hy
  dsimp [PartialHomeomorph.subtypeRestr_def] at hy âŠ¢
  have hyV : e.symm y âˆˆ (V.partialHomeomorphSubtypeCoe hV).target := by
    rw [Opens.partialHomeomorphSubtypeCoe_target] at hy âŠ¢
    exact hUV hy.2
  refine (V.partialHomeomorphSubtypeCoe hV).injOn ?_ trivial? _
  Â· rw [â† PartialHomeomorph.symm_target]
    apply PartialHomeomorph.map_source
    rw [PartialHomeomorph.symm_source]
    exact hyV
  Â· rw [(V.partialHomeomorphSubtypeCoe hV).right_inv hyV]
    show _ = U.partialHomeomorphSubtypeCoe hU _
    rw [(U.partialHomeomorphSubtypeCoe hU).right_inv hy.2]","error:  unknown identifier 'trivial?'
error:  unsolved goals
X : Type u_1
X' : Type u_2
Y : Type u_3
Y' : Type u_4
Z : Type u_5
Z' : Type u_6
instâœâµ : TopologicalSpace X
instâœâ´ : TopologicalSpace X'
instâœÂ³ : TopologicalSpace Y
instâœÂ² : TopologicalSpace Y'
instâœÂ¹ : TopologicalSpace Z
instâœ : TopologicalSpace Z'
e : PartialHomeomorph X Y
s : Opens X
hs : Nonempty â†¥s
U V : Opens X
hU : Nonempty â†¥U
hV : Nonempty â†¥V
hUV : U â‰¤ V
i : â†‘â†‘U â†’ â†‘â†‘V := inclusion hUV
y : Y
hy : y âˆˆ e.target âˆ© â†‘e.symm â»Â¹' (U.partialHomeomorphSubtypeCoe hU).target
hyV : â†‘e.symm y âˆˆ (V.partialHomeomorphSubtypeCoe hV).target
âŠ¢ â†‘(V.partialHomeomorphSubtypeCoe hV).symm (â†‘e.symm y) = i (â†‘(U.partialHomeomorphSubtypeCoe hU).symm (â†‘e.symm y))","theorem subtypeRestr_symm_eqOn_of_le {U V : Opens X} (hU : Nonempty U) (hV : Nonempty V)
    (hUV : U â‰¤ V) : EqOn (e.subtypeRestr hV).symm (Set.inclusion hUV âˆ˜ (e.subtypeRestr hU).symm)
      (e.subtypeRestr hU).target ",":= by
  set i := Set.inclusion hUV
  intro y hy
  dsimp [PartialHomeomorph.subtypeRestr_def] at hy âŠ¢
  have hyV : e.symm y âˆˆ (V.partialHomeomorphSubtypeCoe hV).target := by
    rw [Opens.partialHomeomorphSubtypeCoe_target] at hy âŠ¢
    exact hUV hy.2
  refine (V.partialHomeomorphSubtypeCoe hV).injOn ?_ trivial ?_
  Â· rw [â† PartialHomeomorph.symm_target]
    apply PartialHomeomorph.map_source
    rw [PartialHomeomorph.symm_source]
    exact hyV
  Â· rw [(V.partialHomeomorphSubtypeCoe hV).right_inv hyV]
    show _ = U.partialHomeomorphSubtypeCoe hU _
    rw [(U.partialHomeomorphSubtypeCoe hU).right_inv hy.2]",simp only [subtypeRestr_symm_eqOn_of_le]
Mathlib/Geometry/Manifold/LocalInvariantProperties.lean,StructureGroupoid.LocalInvariantProp.liftPropWithinAt_iff,liftPropWithinAt_iff,b06c98e69f01ef8ab665c237468aa64e98a5bcd4,":= by
  refine' and_congr_right fun hf â†¦ hG.congr_set _
  exact LocalHomeomorph.preimage_eventuallyEq_target_inter_preimage_inter hf (mem_chart_source H x)
    (chart_source_mem_nhds H' (f x))","error:  type mismatch
  and_congr_right fun hf â†¦ congr_set hG (?m.17477 hf)
has type
  ?m.17420 âˆ§ P ?m.17473 ?m.17474 ?m.17475 â†” ?m.17420 âˆ§ P ?m.17473 ?m.17476 ?m.17475 : Prop
but is expected to have type
  LiftPropWithinAt P f s x â†”
    ContinuousWithinAt f s x âˆ§
      P (â†‘(chartAt H' (f x)) âˆ˜ f âˆ˜ â†‘(chartAt H x).symm)
        ((chartAt H x).target âˆ© â†‘(chartAt H x).symm â»Â¹' (s âˆ© f â»Â¹' (chartAt H' (f x)).source)) (â†‘(chartAt H x) x) : Prop","theorem liftPropWithinAt_iff {f : M â†’ M'} :
    LiftPropWithinAt P f s x â†”
      ContinuousWithinAt f s x âˆ§
        P (chartAt H' (f x) âˆ˜ f âˆ˜ (chartAt H x).symm)
          ((chartAt H x).target âˆ© (chartAt H x).symm â»Â¹' (s âˆ© f â»Â¹' (chartAt H' (f x)).source))
          (chartAt H x x) ",":= by
  rw [liftPropWithinAt_iff']
  refine and_congr_right fun hf â†¦ hG.congr_set ?_
  exact PartialHomeomorph.preimage_eventuallyEq_target_inter_preimage_inter hf
    (mem_chart_source H x) (chart_source_mem_nhds H' (f x))","simp only [mfld_source, chartAt_source]"
Mathlib/NumberTheory/Modular.lean,ModularGroup.c_eq_zero,c_eq_zero,f3db3040b24eea7e8cf5c566bd4354149c7dbdc9,":= by
  have hp : âˆ€ {g' : SL(2, â„¤)}, g' â€¢ z âˆˆ ğ’Ÿáµ’ â†’ (â†‘â‚˜g') 1 0 â‰  1 := by
    intro g' hg'
    by_contra hc
    let a := (â†‘â‚˜g') 0 0
    let d := (â†‘â‚˜g') 1 1
    have had : T ^ (-a) * g' = S * T ^ d := by rw [g_eq_of_c_eq_one hc]; group
    let w := T ^ (-a) â€¢ g' â€¢ z
    have hâ‚ : w = S â€¢ T ^ d â€¢ z := by simp only [â† mul_smul, had]
    replace hâ‚ : normSq w < 1 := hâ‚.symm â–¸ normSq_S_smul_lt_one (one_lt_normSq_T_zpow_smul hz d)
    have hâ‚‚ : 1 < normSq w := one_lt_normSq_T_zpow_smul hg' (-a)
    linarith
  have hn : (â†‘â‚˜g) 1 0 â‰  -1 := by
    intro hc
    replace hc : (â†‘â‚˜(-g)) 1 0 = 1; Â· simp [â† neg_eq_iff_eq_neg.mpr hc]
    replace hg : -g â€¢ z âˆˆ ğ’Ÿáµ’ := (SL_neg_smul g z).symm â–¸ hg
    exact hp hg hc
  specialize hp hg
  rcases Int.abs_le_one_iff.mp <| abs_c_le_one hz hg with âŸ¨âŸ© <;> tauto","warning:  fd does not have a doc string
warning:  fdo does not have a doc string
error:  unexpected token ';'; expected '|'
error:  unsolved goals
g : SL(2, â„¤)
z : â„
hz : z âˆˆ ğ’Ÿáµ’
hg : g â€¢ z âˆˆ ğ’Ÿáµ’
g' : SL(2, â„¤)
hg' : g' â€¢ z âˆˆ ğ’Ÿáµ’
hc : â†‘g' 1 0 = 1
a : â„¤ := â†‘g' 0 0
d : â„¤ := â†‘g' 1 1
had : T ^ (-a) * g' = S * T ^ d
w : â„ := T ^ (-a) â€¢ g' â€¢ z
âŠ¢ w = (S * T ^ d) â€¢ z
error:  unsolved goals
g : SL(2, â„¤)
z : â„
hz : z âˆˆ ğ’Ÿáµ’
hg : g â€¢ z âˆˆ ğ’Ÿáµ’
hp : âˆ€ {g' : SL(2, â„¤)}, g' â€¢ z âˆˆ ğ’Ÿáµ’ â†’ â†‘g' 1 0 â‰  1
hc : (-â†‘g) 1 0 = 1
âŠ¢ False
error:  unsolved goals
g : SL(2, â„¤)
z : â„
hz : z âˆˆ ğ’Ÿáµ’
hg : g â€¢ z âˆˆ ğ’Ÿáµ’
hp : âˆ€ {g' : SL(2, â„¤)}, g' â€¢ z âˆˆ ğ’Ÿáµ’ â†’ â†‘g' 1 0 â‰  1
hn : â†‘g 1 0 â‰  -1
âŠ¢ â†‘g 1 0 = 0",theorem c_eq_zero (hz : z âˆˆ ğ’Ÿáµ’) (hg : g â€¢ z âˆˆ ğ’Ÿáµ’) : (â†‘â‚˜g) 1 0 = 0 ,":= by
  have hp : âˆ€ {g' : SL(2, â„¤)}, g' â€¢ z âˆˆ ğ’Ÿáµ’ â†’ (â†‘â‚˜g') 1 0 â‰  1 := by
    intro g' hg'
    by_contra hc
    let a := (â†‘â‚˜g') 0 0
    let d := (â†‘â‚˜g') 1 1
    have had : T ^ (-a) * g' = S * T ^ d := by rw [g_eq_of_c_eq_one hc]; group
    let w := T ^ (-a) â€¢ g' â€¢ z
    have hâ‚ : w = S â€¢ T ^ d â€¢ z := by simp only [w, â† mul_smul, had]
    replace hâ‚ : normSq w < 1 := hâ‚.symm â–¸ normSq_S_smul_lt_one (one_lt_normSq_T_zpow_smul hz d)
    have hâ‚‚ : 1 < normSq w := one_lt_normSq_T_zpow_smul hg' (-a)
    linarith
  have hn : (â†‘â‚˜g) 1 0 â‰  -1 := by
    intro hc
    replace hc : (â†‘â‚˜(-g)) 1 0 = 1 := by simp [â† neg_eq_iff_eq_neg.mpr hc]
    replace hg : -g â€¢ z âˆˆ ğ’Ÿáµ’ := (SL_neg_smul g z).symm â–¸ hg
    exact hp hg hc
  specialize hp hg
  rcases Int.abs_le_one_iff.mp <| abs_c_le_one hz hg with âŸ¨âŸ© <;> tauto","simp only [mul_zero, zero_smul, zero_mul, mul_zero]"
Mathlib/Analysis/BoxIntegral/Partition/Split.lean,BoxIntegral.Prepartition.inf_splitMany,inf_splitMany,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' s with p s _ ihp
  Â· simp
  Â· simp_rw [splitMany_insert, â† inf_assoc, ihp, inf_split, biUnion_assoc]","error:  simp made no progress
error:  no goals to be solved","theorem inf_splitMany {I : Box Î¹} (Ï€ : Prepartition I) (s : Finset (Î¹ Ã— â„)) :
    Ï€ âŠ“ splitMany I s = Ï€.biUnion fun J => splitMany J s ",":= by
  induction' s using Finset.induction_on with p s _ ihp
  Â· simp
  Â· simp_rw [splitMany_insert, â† inf_assoc, ihp, inf_split, biUnion_assoc]","simp only [inf_splitMany, splitMany]"
Mathlib/RingTheory/Jacobson.lean,Ideal.Polynomial.isMaximal_comap_C_of_isJacobson,isMaximal_comap_C_of_isJacobson,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [â† @mk_ker _ _ P, RingHom.ker_eq_comap_bot, comap_comap]
  exact isMaximal_comap_of_isIntegral_of_isMaximal' _ (quotient_mk_comp_C_isIntegral_of_jacobson P)
    âŠ¥ ((bot_quotient_isMaximal_iff _).mpr hP)","error:  function expected at
  isMaximal_comap_of_isIntegral_of_isMaximal' ((Quotient.mk P).comp C) (quotient_mk_comp_C_isIntegral_of_jacobson P) âŠ¥
term has type
  (comap ((Quotient.mk P).comp C) âŠ¥).IsMaximal",theorem isMaximal_comap_C_of_isJacobson : (P.comap (C : R â†’+* R[X])).IsMaximal ,":= by
  rw [â† @mk_ker _ _ P, RingHom.ker_eq_comap_bot, comap_comap]
  have := (bot_quotient_isMaximal_iff _).mpr hP
  exact isMaximal_comap_of_isIntegral_of_isMaximal' _ (quotient_mk_comp_C_isIntegral_of_jacobson P)
    âŠ¥",heorem isMaximal_comap_C_of_isJacobson isJacobson
Mathlib/Data/Finsupp/Defs.lean,Finsupp.single_eq_zero,single_eq_zero,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.single_eq_zero","warning:  Finsupp does not have a doc string
error:  unknown identifier 'DFinsupp.single_eq_zero'",theorem single_eq_zero : single a b = 0 â†” b = 0 ,":= by
  simp [DFunLike.ext_iff, single_eq_set_indicator]",rw [single_eq_zero_iff] at single_eq_zero
Mathlib/MeasureTheory/Constructions/Polish.lean,MeasurableSet.analyticSet,_root_.MeasurableSet.analyticSet,4968eba95a704a4a58e8b3735dc3733ee6d46c0d,":= by
  obtain âŸ¨t', t't, t'_polish, s_closed, _âŸ© :
      âˆƒ t' : TopologicalSpace Î±, t' â‰¤ t âˆ§ @PolishSpace Î± t' âˆ§ IsClosed[t'] s âˆ§ IsOpen[t'] s :=
    hs.isClopenable
  have A := @IsClosed.analyticSet Î± t' t'_polish s s_closed
  convert @AnalyticSet.image_of_continuous Î± t' Î± t s A id (continuous_id_of_le t't)
  simp only [id.def, image_id']","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.11795 â†’ ?m.11795
error:  simp made no progress","theorem _root_.MeasurableSet.analyticSet {Î± : Type*} [t : TopologicalSpace Î±] [PolishSpace Î±]
    [MeasurableSpace Î±] [BorelSpace Î±] {s : Set Î±} (hs : MeasurableSet s) : AnalyticSet s ",":= by
  obtain âŸ¨t', t't, t'_polish, s_closed, _âŸ© :
      âˆƒ t' : TopologicalSpace Î±, t' â‰¤ t âˆ§ @PolishSpace Î± t' âˆ§ IsClosed[t'] s âˆ§ IsOpen[t'] s :=
    hs.isClopenable
  have A := @IsClosed.analyticSet Î± t' t'_polish s s_closed
  convert @AnalyticSet.image_of_continuous Î± t' Î± t s A id (continuous_id_of_le t't)
  simp only [id, image_id']",exact analyticSet_analyticSet_of_analyticSet hs
Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean,AlgebraicGeometry.Î“Spec.adjunction_homEquiv_apply,adjunction_homEquiv_apply,43339007ce3d59409eaf23093d4981175984328f,":= by
  dsimp only [adjunction]
  rw [Adjunction.restrictFullyFaithful_homEquiv_apply, Adjunction.homEquiv_unit]
  simp","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ((Adjunction.restrictFullyFaithful ?hiC ?hiD ?adj ?comm1 ?comm2).homEquiv ?X ?Y) ?f
X : Scheme
R : CommRingCatáµ’áµ–
f : { unop := Scheme.Î“.obj { unop := X } } âŸ¶ R
âŠ¢ (locallyRingedSpaceAdjunction.homEquiv X.toLocallyRingedSpace R) f =
    (locallyRingedSpaceAdjunction.homEquiv X.toLocallyRingedSpace R) f","theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatáµ’áµ–}
    (f : (op <| Scheme.Î“.obj <| op X) âŸ¶ R) :
    Î“Spec.adjunction.homEquiv X R f = locallyRingedSpaceAdjunction.homEquiv X.1 R f ",:= rfl,dsimp [locallyRingedSpaceAdjunction]
Mathlib/Data/Complex/Basic.lean,Complex.re_eq_add_conj,re_eq_add_conj,151eb46ac9da80421706d0822fba0ae70d6ae557,":= by
  simp only [add_conj, ofReal_mul, ofReal_ofNat, mul_div_cancel_left (z.re : â„‚) two_ne_zero]","warning:  Complex does not have a doc string
warning:  Set.reProdIm does not have a doc string
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
error:  application type mismatch
  mul_div_cancel_left (â†‘z.re) two_ne_zero
argument
  two_ne_zero
has type
  2 â‰  0 : Prop
but is expected to have type
  â„‚ : Type
error:  unsolved goals
z : â„‚
âŠ¢ â†‘z.re = 2 * â†‘z.re / 2",theorem re_eq_add_conj (z : â„‚) : (z.re : â„‚) = (z + conj z) / 2 ,":= by
  simp only [add_conj, ofReal_mul, ofReal_ofNat, mul_div_cancel_leftâ‚€ (z.re : â„‚) two_ne_zero]",simp [theorem_re_eq_add_conj]
Mathlib/MeasureTheory/Measure/VectorMeasure.lean,MeasureTheory.VectorMeasure.MutuallySingular.add_left,add_left,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  obtain âŸ¨u, hmu, huâ‚, huâ‚‚âŸ© := hâ‚
  obtain âŸ¨v, hmv, hvâ‚, hvâ‚‚âŸ© := hâ‚‚
  refine mk (u âˆ© v) (hmu.inter hmv) (fun t ht _ => ?_) fun t ht hmt => ?_
  Â· rw [add_apply, huâ‚ _ (Set.subset_inter_iff.1 ht).1, hvâ‚ _ (Set.subset_inter_iff.1 ht).2,
      zero_add]
  Â· rw [Set.compl_inter] at ht
    rw [(_ : t = uá¶œ âˆ© t âˆª vá¶œ \ uá¶œ âˆ© t),
      of_union _ (hmu.compl.inter hmt) ((hmv.compl.diff hmu.compl).inter hmt), huâ‚‚, hvâ‚‚, add_zero]
    Â· exact Set.Subset.trans (Set.inter_subset_left _ _) (Set.diff_subset _ _)
    Â· exact Set.inter_subset_left _ _
    Â· exact disjoint_sdiff_self_right.mono (Set.inter_subset_left _ _) (Set.inter_subset_left _ _)
    Â· apply Set.Subset.antisymm <;> intro x hx
      Â· by_cases hxu' : x âˆˆ uá¶œ
        Â· exact Or.inl âŸ¨hxu', hxâŸ©
        rcases ht hx with (hxu | hxv)
        exacts [False.elim (hxu' hxu), Or.inr âŸ¨âŸ¨hxv, hxu'âŸ©, hxâŸ©]
      Â· cases' hx with hx hx <;> exact hx.2","warning:  @VectorMeasure.AbsolutelyContinuous does not have a doc string
warning:  @VectorMeasure.MutuallySingular does not have a doc string
error:  function expected at
  inter_subset_left ?m.336041
term has type
  ?m.336040 âˆˆ ?m.336038
error:  function expected at
  diff_subset ?m.336083
term has type
  ?m.336082 âˆˆ ?m.336080
error:  function expected at
  inter_subset_left ?m.336125
term has type
  ?m.336124 âˆˆ ?m.336122
error:  function expected at
  inter_subset_left ?m.336366
term has type
  ?m.336365 âˆˆ ?m.336363
error:  function expected at
  inter_subset_left ?m.336418
term has type
  ?m.336417 âˆˆ ?m.336415",theorem add_left [T2Space N] [ContinuousAdd M] (hâ‚ : vâ‚ âŸ‚áµ¥ w) (hâ‚‚ : vâ‚‚ âŸ‚áµ¥ w) : vâ‚ + vâ‚‚ âŸ‚áµ¥ w ,":= by
  obtain âŸ¨u, hmu, huâ‚, huâ‚‚âŸ© := hâ‚
  obtain âŸ¨v, hmv, hvâ‚, hvâ‚‚âŸ© := hâ‚‚
  refine mk (u âˆ© v) (hmu.inter hmv) (fun t ht _ => ?_) fun t ht hmt => ?_
  Â· rw [add_apply, huâ‚ _ (Set.subset_inter_iff.1 ht).1, hvâ‚ _ (Set.subset_inter_iff.1 ht).2,
      zero_add]
  Â· rw [Set.compl_inter] at ht
    rw [(_ : t = uá¶œ âˆ© t âˆª vá¶œ \ uá¶œ âˆ© t),
      of_union _ (hmu.compl.inter hmt) ((hmv.compl.diff hmu.compl).inter hmt), huâ‚‚, hvâ‚‚, add_zero]
    Â· exact Set.Subset.trans Set.inter_subset_left diff_subset
    Â· exact Set.inter_subset_left
    Â· exact disjoint_sdiff_self_right.mono Set.inter_subset_left Set.inter_subset_left
    Â· apply Set.Subset.antisymm <;> intro x hx
      Â· by_cases hxu' : x âˆˆ uá¶œ
        Â· exact Or.inl âŸ¨hxu', hxâŸ©
        rcases ht hx with (hxu | hxv)
        exacts [False.elim (hxu' hxu), Or.inr âŸ¨âŸ¨hxv, hxu'âŸ©, hxâŸ©]
      Â· cases' hx with hx hx <;> exact hx.2","rw [ContinuousAdd, ContinuousAdd, ContinuousAdd, ContinuousAdd, ContinuousAdd,
  ContinuousAdd]"
Mathlib/Data/Fin/Basic.lean,Fin.castSucc_ne_zero_of_lt,castSucc_ne_zero_of_lt,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  cases n
  Â· exact i.elim0
  Â· rw [castSucc_ne_zero_iff']
    exact ((zero_le _).trans_lt h).ne'","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Fin.val_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  failed to synthesize
  Preorder (Fin (nâœ + 1))
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  Preorder (Fin (nâœ + 1))
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  LE.le.trans_lt ?m.33915 h
argument
  h
has type
  @LT.lt (Fin (nâœ + 1)) instLTFin p i : Prop
but is expected to have type
  @LT.lt (Fin (nâœ + 1)) Preorder.toLT p i : Prop",theorem castSucc_ne_zero_of_lt {p i : Fin n} (h : p < i) : castSucc i â‰  0 ,":= by
  cases n
  Â· exact i.elim0
  Â· rw [castSucc_ne_zero_iff', Ne, ext_iff]
    exact ((zero_le _).trans_lt h).ne'",rw [castSucc_ne_zero_of_lt]
Mathlib/MeasureTheory/Measure/MeasureSpace.lean,MeasureTheory.measure_limsup_eq_zero,measure_limsup_eq_zero,464f10c2e8d95b797cf97f9520e276bb51b872af,":= by
  set t : â„• â†’ Set Î± := fun n => toMeasurable Î¼ (s n)
  have ht : (âˆ‘' i, Î¼ (t i)) â‰  âˆ := by simpa only [measure_toMeasurable] using hs
  suffices Î¼ (limsup t atTop) = 0 by
    have A : s â‰¤ t := fun n => subset_toMeasurable Î¼ (s n)
    exact
      measure_mono_null
        (limsup_le_limsup (eventually_of_forall (Pi.le_def.mp A)) isCobounded_le_of_bot
          isBounded_le_of_top)
        this
  simp only [limsup_eq_iInf_iSup_of_nat', Set.iInf_eq_iInter, Set.iSup_eq_iUnion, â†
    nonpos_iff_eq_zero]
  refine'
    le_of_tendsto_of_tendsto'
      (tendsto_measure_iInter
        (fun i => MeasurableSet.iUnion fun b => measurableSet_toMeasurable _ _) _
        âŸ¨0, ne_top_of_le_ne_top ht (measure_iUnion_le t)âŸ©)
      (ENNReal.tendsto_sum_nat_add (Î¼ âˆ˜ t) ht) fun n => measure_iUnion_le _
  intro n m hnm x
  simp only [Set.mem_iUnion]
  exact fun âŸ¨i, hiâŸ© => âŸ¨i + (m - n), by simpa only [add_assoc, tsub_add_cancel_of_le hnm] using hiâŸ©","error:  type mismatch
  hâœ
has type
  âˆ‘' (i : â„•), Î¼ (s i) â‰  âŠ¤ : Prop
but is expected to have type
  âˆ‘' (i : â„•), Î¼ (t i) â‰  âŠ¤ : Prop
warning:  @Measure.AbsolutelyContinuous does not have a doc string","theorem measure_limsup_eq_zero {s : â„• â†’ Set Î±} (hs : (âˆ‘' i, Î¼ (s i)) â‰  âˆ) :
    Î¼ (limsup s atTop) = 0 ",":= by
  set t : â„• â†’ Set Î± := fun n => toMeasurable Î¼ (s n)
  have ht : (âˆ‘' i, Î¼ (t i)) â‰  âˆ := by simpa only [t, measure_toMeasurable] using hs
  suffices Î¼ (limsup t atTop) = 0 by
    have A : s â‰¤ t := fun n => subset_toMeasurable Î¼ (s n)
    exact measure_mono_null (limsup_le_limsup (eventually_of_forall (Pi.le_def.mp A))) this
  simp only [limsup_eq_iInf_iSup_of_nat', Set.iInf_eq_iInter, Set.iSup_eq_iUnion, â†
    nonpos_iff_eq_zero]
  refine
    le_of_tendsto_of_tendsto'
      (tendsto_measure_iInter
        (fun i => MeasurableSet.iUnion fun b => measurableSet_toMeasurable _ _) ?_
        âŸ¨0, ne_top_of_le_ne_top ht (measure_iUnion_le t)âŸ©)
      (ENNReal.tendsto_sum_nat_add (Î¼ âˆ˜ t) ht) fun n => measure_iUnion_le _
  intro n m hnm x
  simp only [Set.mem_iUnion]
  exact fun âŸ¨i, hiâŸ© => âŸ¨i + (m - n), by simpa only [add_assoc, tsub_add_cancel_of_le hnm] using hiâŸ©",rw [limsup_eq_limsup_eq_zero]
Mathlib/RingTheory/IntegralRestrict.lean,Algebra.intTrace_eq_of_isLocalization,Algebra.intTrace_eq_of_isLocalization,562711c9f3ae24a07facf3809c1631a4ccf2e8f2,":= by
  by_cases hM : 0 âˆˆ M
  Â· have := IsLocalization.uniqueOfZeroMem (S := Aâ‚˜) hM
    exact Subsingleton.elim _ _
  replace hM : M â‰¤ Aâ° := fun x hx â†¦ mem_nonZeroDivisors_iff_ne_zero.mpr (fun e â†¦ hM (e â–¸ hx))
  let K := FractionRing A
  let L := FractionRing B
  have : IsIntegralClosure B A L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (Algebra.IsIntegral.of_finite A B)
  have : IsLocalization (algebraMapSubmonoid B Aâ°) L :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
      (isAlgebraic_of_isFractionRing _ _ (Algebra.IsIntegral.of_finite A B))
  let f : Aâ‚˜ â†’+* K := IsLocalization.map _ (T := Aâ°) (RingHom.id A) hM
  letI := f.toAlgebra
  have : IsScalarTower A Aâ‚˜ K := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, â† RingHomCompTriple.comp_eq])
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aâ‚˜ K
  let g : Bâ‚˜ â†’+* L := IsLocalization.map _
      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B Aâ°)
      (RingHom.id B) (Submonoid.monotone_map hM)
  letI := g.toAlgebra
  have : IsScalarTower B Bâ‚˜ L := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, â† RingHomCompTriple.comp_eq])
  letI := ((algebraMap K L).comp f).toAlgebra
  have : IsScalarTower Aâ‚˜ K L := IsScalarTower.of_algebraMap_eq' rfl
  have : IsScalarTower Aâ‚˜ Bâ‚˜ L := by
    apply IsScalarTower.of_algebraMap_eq'
    apply IsLocalization.ringHom_ext M
    rw [RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra (R := Bâ‚˜), RingHom.comp_assoc,
      RingHom.comp_assoc, â† IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq A B Bâ‚˜,
      IsLocalization.map_comp, RingHom.comp_id, â† RingHom.comp_assoc, IsLocalization.map_comp,
      RingHom.comp_id, â† IsScalarTower.algebraMap_eq, â† IsScalarTower.algebraMap_eq]
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization
    (algebraMapSubmonoid B M) Bâ‚˜ L
  have : FiniteDimensional K L := Module.Finite_of_isLocalization A B _ _ Aâ°
  have : IsIntegralClosure Bâ‚˜ Aâ‚˜ L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (Algebra.IsIntegral.of_finite Aâ‚˜ Bâ‚˜)
  apply IsFractionRing.injective Aâ‚˜ K
  rw [â† IsScalarTower.algebraMap_apply, Algebra.algebraMap_intTrace_fractionRing,
    Algebra.algebraMap_intTrace (L := L), â† IsScalarTower.algebraMap_apply]","error:  function expected at
  IsIntegralClosure.of_isIntegrallyClosed ?m.366306 ?m.366307 ?m.366311
term has type
  IsIntegralClosure ?m.366306 ?m.366307 ?m.366311
error:  function expected at
  IsIntegralClosure.isLocalization ?m.368130 (FractionRing A) ?m.368143 ?m.368145
term has type
  IsLocalization (algebraMapSubmonoid ?m.368145 ?m.368130â°) ?m.368143
error:  tactic 'rewrite' failed, pattern is a metavariable
  ?m.375556
from equation
  ?m.375556 = ?m.375555.comp ?m.375554
A : Type u_1
Kâœ : Type u_2
Lâœ : Type u_3
B : Type u_4
instâœÂ³âµ : CommRing A
instâœÂ³â´ : CommRing B
instâœÂ³Â³ : Algebra A B
instâœÂ³Â² : Field Kâœ
instâœÂ³Â¹ : Field Lâœ
instâœÂ³â° : Algebra A Kâœ
instâœÂ²â¹ : IsFractionRing A Kâœ
instâœÂ²â¸ : Algebra B Lâœ
instâœÂ²â· : Algebra Kâœ Lâœ
instâœÂ²â¶ : Algebra A Lâœ
instâœÂ²âµ : IsScalarTower A B Lâœ
instâœÂ²â´ : IsScalarTower A Kâœ Lâœ
instâœÂ²Â³ : IsIntegralClosure B A Lâœ
instâœÂ²Â² : FiniteDimensional Kâœ Lâœ
Aâ‚˜ : Type u_5
Bâ‚˜ : Type u_6
instâœÂ²Â¹ : CommRing Aâ‚˜
instâœÂ²â° : CommRing Bâ‚˜
instâœÂ¹â¹ : Algebra Aâ‚˜ Bâ‚˜
instâœÂ¹â¸ : Algebra A Aâ‚˜
instâœÂ¹â· : Algebra B Bâ‚˜
instâœÂ¹â¶ : Algebra A Bâ‚˜
instâœÂ¹âµ : IsScalarTower A Aâ‚˜ Bâ‚˜
instâœÂ¹â´ : IsScalarTower A B Bâ‚˜
M : Submonoid A
instâœÂ¹Â³ : IsLocalization M Aâ‚˜
instâœÂ¹Â² : IsLocalization (algebraMapSubmonoid B M) Bâ‚˜
instâœÂ¹Â¹ : IsDomain A
instâœÂ¹â° : IsIntegrallyClosed A
instâœâ¹ : IsDomain B
instâœâ¸ : IsIntegrallyClosed B
instâœâ· : Module.Finite A B
instâœâ¶ : NoZeroSMulDivisors A B
instâœâµ : IsDomain Aâ‚˜
instâœâ´ : IsIntegrallyClosed Aâ‚˜
instâœÂ³ : IsDomain Bâ‚˜
instâœÂ² : IsIntegrallyClosed Bâ‚˜
instâœÂ¹ : NoZeroSMulDivisors Aâ‚˜ Bâ‚˜
instâœ : Module.Finite Aâ‚˜ Bâ‚˜
x : B
hM : M â‰¤ Aâ°
K : Type u_1 := FractionRing A
L : Type u_4 := FractionRing B
thisâœÂ¹ : IsIntegralClosure B A L
thisâœ : IsLocalization (algebraMapSubmonoid B Aâ°) L
f : Aâ‚˜ â†’+* K := IsLocalization.map K (RingHom.id A) hM
this : Algebra Aâ‚˜ K := f.toAlgebra
âŠ¢ algebraMap A K = (algebraMap A K).comp (RingHom.id A)
error:  tactic 'rewrite' failed, pattern is a metavariable
  ?m.383674
from equation
  ?m.383674 = ?m.383673.comp ?m.383672
A : Type u_1
Kâœ : Type u_2
Lâœ : Type u_3
B : Type u_4
instâœÂ³âµ : CommRing A
instâœÂ³â´ : CommRing B
instâœÂ³Â³ : Algebra A B
instâœÂ³Â² : Field Kâœ
instâœÂ³Â¹ : Field Lâœ
instâœÂ³â° : Algebra A Kâœ
instâœÂ²â¹ : IsFractionRing A Kâœ
instâœÂ²â¸ : Algebra B Lâœ
instâœÂ²â· : Algebra Kâœ Lâœ
instâœÂ²â¶ : Algebra A Lâœ
instâœÂ²âµ : IsScalarTower A B Lâœ
instâœÂ²â´ : IsScalarTower A Kâœ Lâœ
instâœÂ²Â³ : IsIntegralClosure B A Lâœ
instâœÂ²Â² : FiniteDimensional Kâœ Lâœ
Aâ‚˜ : Type u_5
Bâ‚˜ : Type u_6
instâœÂ²Â¹ : CommRing Aâ‚˜
instâœÂ²â° : CommRing Bâ‚˜
instâœÂ¹â¹ : Algebra Aâ‚˜ Bâ‚˜
instâœÂ¹â¸ : Algebra A Aâ‚˜
instâœÂ¹â· : Algebra B Bâ‚˜
instâœÂ¹â¶ : Algebra A Bâ‚˜
instâœÂ¹âµ : IsScalarTower A Aâ‚˜ Bâ‚˜
instâœÂ¹â´ : IsScalarTower A B Bâ‚˜
M : Submonoid A
instâœÂ¹Â³ : IsLocalization M Aâ‚˜
instâœÂ¹Â² : IsLocalization (algebraMapSubmonoid B M) Bâ‚˜
instâœÂ¹Â¹ : IsDomain A
instâœÂ¹â° : IsIntegrallyClosed A
instâœâ¹ : IsDomain B
instâœâ¸ : IsIntegrallyClosed B
instâœâ· : Module.Finite A B
instâœâ¶ : NoZeroSMulDivisors A B
instâœâµ : IsDomain Aâ‚˜
instâœâ´ : IsIntegrallyClosed Aâ‚˜
instâœÂ³ : IsDomain Bâ‚˜
instâœÂ² : IsIntegrallyClosed Bâ‚˜
instâœÂ¹ : NoZeroSMulDivisors Aâ‚˜ Bâ‚˜
instâœ : Module.Finite Aâ‚˜ Bâ‚˜
x : B
hM : M â‰¤ Aâ°
K : Type u_1 := FractionRing A
L : Type u_4 := FractionRing B
thisâœâ´ : IsIntegralClosure B A L
thisâœÂ³ : IsLocalization (algebraMapSubmonoid B Aâ°) L
f : Aâ‚˜ â†’+* K := IsLocalization.map K (RingHom.id A) hM
thisâœÂ² : Algebra Aâ‚˜ K := f.toAlgebra
thisâœÂ¹ : IsScalarTower A Aâ‚˜ K
thisâœ : IsFractionRing Aâ‚˜ K := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aâ‚˜ K
g : Bâ‚˜ â†’+* L := IsLocalization.map L (RingHom.id B) â‹¯
this : Algebra Bâ‚˜ L := g.toAlgebra
âŠ¢ algebraMap B L = (algebraMap B L).comp (RingHom.id B)
error:  function expected at
  IsIntegralClosure.of_isIntegrallyClosed ?m.399481 ?m.399482 ?m.399486
term has type
  IsIntegralClosure ?m.399481 ?m.399482 ?m.399486","lemma Algebra.intTrace_eq_of_isLocalization
    (x : B) :
    algebraMap A Aâ‚˜ (Algebra.intTrace A B x) = Algebra.intTrace Aâ‚˜ Bâ‚˜ (algebraMap B Bâ‚˜ x) ",":= by
  by_cases hM : 0 âˆˆ M
  Â· have := IsLocalization.uniqueOfZeroMem (S := Aâ‚˜) hM
    exact Subsingleton.elim _ _
  replace hM : M â‰¤ Aâ° := fun x hx â†¦ mem_nonZeroDivisors_iff_ne_zero.mpr (fun e â†¦ hM (e â–¸ hx))
  let K := FractionRing A
  let L := FractionRing B
  have : IsIntegralClosure B A L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsLocalization (algebraMapSubmonoid B Aâ°) L :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  let f : Aâ‚˜ â†’+* K := IsLocalization.map _ (T := Aâ°) (RingHom.id A) hM
  letI := f.toAlgebra
  have : IsScalarTower A Aâ‚˜ K := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aâ‚˜ K
  let g : Bâ‚˜ â†’+* L := IsLocalization.map _
      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B Aâ°)
      (RingHom.id B) (Submonoid.monotone_map hM)
  letI := g.toAlgebra
  have : IsScalarTower B Bâ‚˜ L := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := ((algebraMap K L).comp f).toAlgebra
  have : IsScalarTower Aâ‚˜ K L := IsScalarTower.of_algebraMap_eq' rfl
  have : IsScalarTower Aâ‚˜ Bâ‚˜ L := by
    apply IsScalarTower.of_algebraMap_eq'
    apply IsLocalization.ringHom_ext M
    rw [RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra (R := Bâ‚˜), RingHom.comp_assoc,
      RingHom.comp_assoc, â† IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq A B Bâ‚˜,
      IsLocalization.map_comp, RingHom.comp_id, â† RingHom.comp_assoc, IsLocalization.map_comp,
      RingHom.comp_id, â† IsScalarTower.algebraMap_eq, â† IsScalarTower.algebraMap_eq]
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization
    (algebraMapSubmonoid B M) Bâ‚˜ L
  have : FiniteDimensional K L := Module.Finite_of_isLocalization A B _ _ Aâ°
  have : IsIntegralClosure Bâ‚˜ Aâ‚˜ L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  apply IsFractionRing.injective Aâ‚˜ K
  rw [â† IsScalarTower.algebraMap_apply, Algebra.algebraMap_intTrace_fractionRing,
    Algebra.algebraMap_intTrace (L := L), â† IsScalarTower.algebraMap_apply]","rw [Algebra.intTrace_eq_of_isLocalization, â† Algebra.intTrace_eq_of_isLocalization,
  Algebra.intTrace_eq_of_isLocalization]"
Mathlib/RingTheory/DedekindDomain/Different.lean,FractionalIdeal.dual_eq_mul_inv,dual_eq_mul_inv,3465d1aaae242475fad59e688648a2285031d19e,":= by
  by_cases hI : I = 0; Â· simp [hI]
  apply le_antisymm
  Â· suffices : dual A K I * I â‰¤ dual A K 1
    Â· convert mul_right_mono Iâ»Â¹ this using 1; simp only [mul_inv_cancel hI, mul_one, mul_assoc]
    rw [â† le_dual_iff hI]
  rw [le_dual_iff hI, mul_assoc, inv_mul_cancel hI, mul_one]","error:  unexpected token ':'; expected term
error:  unsolved goals
case neg.a
A : Type u_1
K : Type u_2
L : Type u
B : Type u_3
instâœÂ¹â¹ : CommRing A
instâœÂ¹â¸ : Field K
instâœÂ¹â· : CommRing B
instâœÂ¹â¶ : Field L
instâœÂ¹âµ : Algebra A K
instâœÂ¹â´ : Algebra B L
instâœÂ¹Â³ : Algebra A B
instâœÂ¹Â² : Algebra K L
instâœÂ¹Â¹ : Algebra A L
instâœÂ¹â° : IsScalarTower A K L
instâœâ¹ : IsScalarTower A B L
instâœâ¸ : IsDomain A
instâœâ· : IsDomain B
instâœâ¶ : IsFractionRing A K
instâœâµ : IsIntegralClosure B A L
instâœâ´ : IsFractionRing B L
instâœÂ³ : FiniteDimensional K L
instâœÂ² : IsSeparable K L
instâœÂ¹ : IsIntegrallyClosed A
instâœ : IsDedekindDomain B
I J : FractionalIdeal Bâ° L
hIâœ : I â‰  0
hJ : J â‰  0
hI : Â¬I = 0
âŠ¢ dual A K 1 * Iâ»Â¹ â‰¤ dual A K I","lemma dual_eq_mul_inv :
    dual A K I = dual A K 1 * Iâ»Â¹ ",":= by
  by_cases hI : I = 0; Â· simp [hI]
  apply le_antisymm
  Â· suffices dual A K I * I â‰¤ dual A K 1 by
      convert mul_right_mono Iâ»Â¹ this using 1; simp only [mul_inv_cancel hI, mul_one, mul_assoc]
    rw [â† le_dual_iff A K hI]
  rw [le_dual_iff A K hI, mul_assoc, inv_mul_cancel hI, mul_one]","rw [dual_eq_mul_inv, dual_eq_mul_inv]"
Mathlib/NumberTheory/ClassNumber/Finite.lean,ClassGroup.exists_mem_finsetApprox,exists_mem_finsetApprox,6eab74639023015a7887e2f82e153907286e3801,":= by
  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty
  set Îµ : â„ := normBound abv bS ^ (-1 / Fintype.card Î¹ : â„) with Îµ_eq
  have hÎµ : 0 < Îµ := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _
  have Îµ_le : (normBound abv bS : â„) * (abv b â€¢ Îµ) ^ Fintype.card Î¹ â‰¤ abv b ^ Fintype.card Î¹ := by
    have := normBound_pos abv bS
    have := abv.nonneg b
    rw [Îµ_eq, Algebra.smul_def, eq_intCast, mul_rpow, â† rpow_mul, div_mul_cancel, rpow_neg_one,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_nat_cast] <;>
      try norm_cast; linarith
    Â· exact Iff.mpr Int.cast_nonneg this
    Â· linarith
  set Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm with hÎ¼
  let s : Î¹ â†’â‚€ R := bS.repr a
  have s_eq : âˆ€ i, s i = bS.repr a i := fun i => rfl
  let qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i / b
  let rs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i % b
  have r_eq : âˆ€ j i, rs j i = Î¼ j * s i % b := fun i j => rfl
  have Î¼_eq : âˆ€ i j, Î¼ j * s i = b * qs j i + rs j i := by
    intro i j
    rw [r_eq, EuclideanDomain.div_add_mod]
  have Î¼_mul_a_eq : âˆ€ j, Î¼ j â€¢ a = b â€¢ âˆ‘ i, qs j i â€¢ bS i + âˆ‘ i, rs j i â€¢ bS i := by
    intro j
    rw [â† bS.sum_repr a]
    simp only [Finset.smul_sum, â† Finset.sum_add_distrib]
    refine'
      Finset.sum_congr rfl fun i _ => _
    rw [â† hÎ¼, â† r_eq, â† s_eq, â† mul_smul, Î¼_eq, add_smul, mul_smul, â† Î¼_eq]
  obtain âŸ¨j, k, j_ne_k, hjkâŸ© := adm.exists_approx hÎµ hb fun j i => Î¼ j * s i
  have hjk' : âˆ€ i, (abv (rs k i - rs j i) : â„) < abv b â€¢ Îµ := by simpa only [r_eq] using hjk
  let q := âˆ‘ i, (qs k i - qs j i) â€¢ bS i
  set r := Î¼ k - Î¼ j with r_eq
  refine' âŸ¨q, r, (mem_finsetApprox bS adm).mpr _, _âŸ©
  Â· exact âŸ¨k, j, j_ne_k.symm, rflâŸ©
  have : r â€¢ a - b â€¢ q = âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) := by
    simp only [r_eq, sub_smul, Î¼_mul_a_eq, Finset.smul_sum, â† Finset.sum_add_distrib,
      â† Finset.sum_sub_distrib, smul_sub]
    refine' Finset.sum_congr rfl fun x _ => _
    ring
  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]
  refine' Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt _ (hjk' i)).trans_le _)
  Â· apply le_of_eq
    congr
    simp_rw [LinearEquiv.map_sum, LinearEquiv.map_sub, LinearEquiv.map_smul, Finset.sum_apply',
      Finsupp.sub_apply, Finsupp.smul_apply, Finset.sum_sub_distrib, Basis.repr_self_apply,
      smul_eq_mul, mul_boole, Finset.sum_ite_eq', Finset.mem_univ, if_true]
  Â· exact_mod_cast Îµ_le","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?m.172686 * ?m.172687) ^ ?m.172688
R : Type u_1
S : Type u_2
K : Type u_3
L : Type u_4
instâœÂ¹â¶ : EuclideanDomain R
instâœÂ¹âµ : CommRing S
instâœÂ¹â´ : IsDomain S
instâœÂ¹Â³ : Field K
instâœÂ¹Â² : Field L
instâœÂ¹Â¹ : Algebra R K
instâœÂ¹â° : IsFractionRing R K
instâœâ¹ : Algebra K L
instâœâ¸ : FiniteDimensional K L
instâœâ· : IsSeparable K L
algRL : Algebra R L
instâœâ¶ : IsScalarTower R K L
instâœâµ : Algebra R S
instâœâ´ : Algebra S L
ist : IsScalarTower R S L
iic : IsIntegralClosure S R L
abv : AbsoluteValue R â„¤
Î¹ : Type u_5
instâœÂ³ : DecidableEq Î¹
instâœÂ² : Fintype Î¹
bS : Basis Î¹ R S
adm : abv.IsAdmissible
instâœÂ¹ : Infinite R
instâœ : DecidableEq R
a : S
b : R
hb : b â‰  0
dim_pos : 0 < Fintype.card Î¹
Îµ : â„ := â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))
Îµ_eq : Îµ = â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))
hÎµ : 0 < Îµ
thisâœ : 0 < normBound abv bS
this : 0 â‰¤ abv b
âŠ¢ â†‘(normBound abv bS) * (â†‘(abv b) * â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))) ^ Fintype.card Î¹ â‰¤
    â†‘(abv b) ^ Fintype.card Î¹
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  distinctElems bS adm
R : Type u_1
S : Type u_2
K : Type u_3
L : Type u_4
instâœÂ¹â¶ : EuclideanDomain R
instâœÂ¹âµ : CommRing S
instâœÂ¹â´ : IsDomain S
instâœÂ¹Â³ : Field K
instâœÂ¹Â² : Field L
instâœÂ¹Â¹ : Algebra R K
instâœÂ¹â° : IsFractionRing R K
instâœâ¹ : Algebra K L
instâœâ¸ : FiniteDimensional K L
instâœâ· : IsSeparable K L
algRL : Algebra R L
instâœâ¶ : IsScalarTower R K L
instâœâµ : Algebra R S
instâœâ´ : Algebra S L
ist : IsScalarTower R S L
iic : IsIntegralClosure S R L
abv : AbsoluteValue R â„¤
Î¹ : Type u_5
instâœÂ³ : DecidableEq Î¹
instâœÂ² : Fintype Î¹
bS : Basis Î¹ R S
adm : abv.IsAdmissible
instâœÂ¹ : Infinite R
instâœ : DecidableEq R
a : S
b : R
hb : b â‰  0
dim_pos : 0 < Fintype.card Î¹
Îµ : â„ := â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))
Îµ_eq : Îµ = â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))
hÎµ : 0 < Îµ
Îµ_le : â†‘(normBound abv bS) * (abv b â€¢ Îµ) ^ Fintype.card Î¹ â‰¤ â†‘(abv b) ^ Fintype.card Î¹
Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm
hÎ¼ : Î¼ = distinctElems bS adm
s : Î¹ â†’â‚€ R := bS.repr a
s_eq : âˆ€ (i : Î¹), s i = (bS.repr a) i
qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i â†¦ Î¼ j * s i / b
rs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i â†¦ Î¼ j * s i % b
r_eq : âˆ€ (j : Fin (cardM bS adm).succ) (i : Î¹), rs j i = Î¼ j * s i % b
Î¼_eq : âˆ€ (i : Î¹) (j : Fin (cardM bS adm).succ), Î¼ j * s i = b * qs j i + rs j i
j : Fin (cardM bS adm).succ
i : Î¹
xâœ : i âˆˆ Finset.univ
âŠ¢ Î¼ j â€¢ (bS.repr a) i â€¢ bS i = b â€¢ qs j i â€¢ bS i + rs j i â€¢ bS i
error:  type mismatch
  Finset.sum_congr rfl fun x x_1 â†¦ ?m.187579 x x_1
has type
  ?m.187475.sum ?m.187376 = ?m.187475.sum ?m.187377 : Prop
but is expected to have type
  âˆ‘ x : Î¹, (b â€¢ qs k x â€¢ bS x + rs k x â€¢ bS x - (b â€¢ qs j x â€¢ bS x + rs j x â€¢ bS x)) - b â€¢ q =
    âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearEquiv
has type
  (Ïƒ : ?m.191789 â†’+* ?m.191790) â†’
    {Ïƒ' : ?m.191790 â†’+* ?m.191789} â†’
      [inst : RingHomInvPair Ïƒ Ïƒ'] â†’
        [inst : RingHomInvPair Ïƒ' Ïƒ] â†’
          (M : Type ?u.191786) â†’
            (Mâ‚‚ : Type ?u.191785) â†’
              [inst : AddCommMonoid M] â†’
                [inst_1 : AddCommMonoid Mâ‚‚] â†’
                  [inst : Module ?m.191789 M] â†’ [inst : Module ?m.191790 Mâ‚‚] â†’ Type (max ?u.191786 ?u.191785)
error:  simp made no progress","theorem exists_mem_finsetApprox (a : S) {b} (hb : b â‰  (0 : R)) :
    âˆƒ q : S,
      âˆƒ r âˆˆ finsetApprox bS adm, abv (Algebra.norm R (r â€¢ a - b â€¢ q)) <
      abv (Algebra.norm R (algebraMap R S b)) ",":= by
  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty
  set Îµ : â„ := normBound abv bS ^ (-1 / Fintype.card Î¹ : â„) with Îµ_eq
  have hÎµ : 0 < Îµ := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _
  have Îµ_le : (normBound abv bS : â„) * (abv b â€¢ Îµ) ^ (Fintype.card Î¹ : â„)
                â‰¤ abv b ^ (Fintype.card Î¹ : â„) := by
    have := normBound_pos abv bS
    have := abv.nonneg b
    rw [Îµ_eq, Algebra.smul_def, eq_intCast, mul_rpow, â† rpow_mul, div_mul_cancelâ‚€, rpow_neg_one,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_natCast] <;>
      try norm_cast; omega
    Â· exact Iff.mpr Int.cast_nonneg this
    Â· linarith
  set Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm with hÎ¼
  let s : Î¹ â†’â‚€ R := bS.repr a
  have s_eq : âˆ€ i, s i = bS.repr a i := fun i => rfl
  let qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i / b
  let rs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i % b
  have r_eq : âˆ€ j i, rs j i = Î¼ j * s i % b := fun i j => rfl
  have Î¼_eq : âˆ€ i j, Î¼ j * s i = b * qs j i + rs j i := by
    intro i j
    rw [r_eq, EuclideanDomain.div_add_mod]
  have Î¼_mul_a_eq : âˆ€ j, Î¼ j â€¢ a = b â€¢ âˆ‘ i, qs j i â€¢ bS i + âˆ‘ i, rs j i â€¢ bS i := by
    intro j
    rw [â† bS.sum_repr a]
    simp only [Î¼, qs, rs, Finset.smul_sum, â† Finset.sum_add_distrib]
    refine Finset.sum_congr rfl fun i _ => ?_
    rw [â† hÎ¼, â† r_eq, â† s_eq, â† mul_smul, Î¼_eq, add_smul, mul_smul, â† Î¼_eq]
  obtain âŸ¨j, k, j_ne_k, hjkâŸ© := adm.exists_approx hÎµ hb fun j i => Î¼ j * s i
  have hjk' : âˆ€ i, (abv (rs k i - rs j i) : â„) < abv b â€¢ Îµ := by simpa only [r_eq] using hjk
  let q := âˆ‘ i, (qs k i - qs j i) â€¢ bS i
  set r := Î¼ k - Î¼ j with r_eq
  refine âŸ¨q, r, (mem_finsetApprox bS adm).mpr ?_, ?_âŸ©
  Â· exact âŸ¨k, j, j_ne_k.symm, rflâŸ©
  have : r â€¢ a - b â€¢ q = âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) := by
    simp only [q, r_eq, sub_smul, Î¼_mul_a_eq, Finset.smul_sum, â† Finset.sum_add_distrib,
      â† Finset.sum_sub_distrib, smul_sub]
    refine Finset.sum_congr rfl fun x _ => ?_
    ring
  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]
  refine Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt ?_ (hjk' i)).trans_le ?_)
  Â· apply le_of_eq
    congr
    simp_rw [map_sum, map_sub, map_smul, Finset.sum_apply',
      Finsupp.sub_apply, Finsupp.smul_apply, Finset.sum_sub_distrib, Basis.repr_self_apply,
      smul_eq_mul, mul_boole, Finset.sum_ite_eq', Finset.mem_univ, if_true]
  Â· exact mod_cast Îµ_le",rw [theorem_exists_mem_finsetApprox]
Mathlib/FieldTheory/IsAlgClosed/Basic.lean,IsAlgClosed.algebraMap_surjective_of_isIntegral',algebraMap_surjective_of_isIntegral',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  @algebraMap_surjective_of_isIntegral k K _ _ _ _ f.toAlgebra hf","error:  application type mismatch
  @algebraMap_surjective_of_isIntegral k K instâœÂ³ CommRing.toRing instâœÂ¹ instâœ f.toAlgebra hf
argument
  hf
has type
  f.IsIntegral : Prop
but is expected to have type
  Algebra.IsIntegral k K : Prop","theorem algebraMap_surjective_of_isIntegral' {k K : Type*} [Field k] [CommRing K] [IsDomain K]
    [IsAlgClosed k] (f : k â†’+* K) (hf : f.IsIntegral) : Function.Surjective f ",":=
  let _ : Algebra k K := f.toAlgebra
  have : Algebra.IsIntegral k K := âŸ¨hfâŸ©
  algebraMap_surjective_of_isIntegral",apply Function.Surjective.of_surjective
Mathlib/Combinatorics/HalesJewett.lean,Combinatorics.Line.exists_mono_in_high_dimension,exists_mono_in_high_dimension,65f7857d510e130142dbb111786341d695ac399b,":=
  Finite.induction_empty_option
  (
  fun {Î± Î±'} e =>
    forall_imp fun Îº =>
      forall_imp fun _ =>
        Exists.imp fun Î¹ =>
          Exists.imp fun _ h C =>
            let âŸ¨l, c, lcâŸ© := h fun v => C (e âˆ˜ v)
            âŸ¨l.map e, c, e.forall_congr_left.mp fun x => by rw [â† lc x, Line.map_apply]âŸ©)
  (by
    intro Îº _
    by_cases h : Nonempty Îº
    Â· refine' âŸ¨Unit, inferInstance, fun C => âŸ¨default, Classical.arbitrary _, PEmpty.recâŸ©âŸ©
    Â· exact âŸ¨Empty, inferInstance, fun C => (h âŸ¨C (Empty.rec)âŸ©).elimâŸ©)
  (by
    intro Î± _ ihÎ± Îº _
    cases nonempty_fintype Îº
    by_cases h : Nonempty Î±
    case neg =>
      refine' âŸ¨Unit, inferInstance, fun C => âŸ¨diagonal _ Unit, C fun _ => none, ?_âŸ©âŸ©
      rintro (_ | âŸ¨aâŸ©)
      Â· rfl
      Â· exact (h âŸ¨aâŸ©).elim
    suffices key :
      âˆ€ r : â„•,
        âˆƒ (Î¹ : Type) (_ : Fintype Î¹),
          âˆ€ C : (Î¹ â†’ Option Î±) â†’ Îº,
            (âˆƒ s : ColorFocused C, Multiset.card s.lines = r) âˆ¨ âˆƒ l, IsMono C l by
      obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := key (Fintype.card Îº + 1)
      refine' âŸ¨Î¹, _inst, fun C => (hÎ¹ C).resolve_left _âŸ©
      rintro âŸ¨s, srâŸ©
      apply Nat.not_succ_le_self (Fintype.card Îº)
      rw [â† Nat.add_one, â† sr, â† Multiset.card_map, â† Finset.card_mk]
      exact Finset.card_le_univ âŸ¨_, s.distinct_colorsâŸ©
    intro r
    induction' r with r ihr
    Â· exact âŸ¨Empty, inferInstance, fun C => Or.inl âŸ¨default, Multiset.card_zeroâŸ©âŸ©
    obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := ihr
    specialize ihÎ± ((Î¹ â†’ Option Î±) â†’ Îº)
    obtain âŸ¨Î¹', _inst, hÎ¹'âŸ© := ihÎ±
    refine âŸ¨Sum Î¹ Î¹', inferInstance, ?_âŸ©
    intro C
    specialize hÎ¹' fun v' v => C (Sum.elim v (some âˆ˜ v'))
    obtain âŸ¨l', C', hl'âŸ© := hÎ¹'
    have mono_of_mono : (âˆƒ l, IsMono C' l) â†’ âˆƒ l, IsMono C l := by
      rintro âŸ¨l, c, hlâŸ©
      refine âŸ¨l.horizontal (some âˆ˜ l' (Classical.arbitrary Î±)), c, fun x => ?_âŸ©
      rw [Line.horizontal_apply, â† hl, â† hl']
    specialize hÎ¹ C'
    rcases hÎ¹ with (âŸ¨s, srâŸ© | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : âˆƒ p âˆˆ s.lines, (p : AlmostMono _).color = C' s.focus
    Â· obtain âŸ¨p, p_mem, hpâŸ© := h
      refine' Or.inr (mono_of_mono âŸ¨p.line, p.color, _âŸ©)
      rintro (_ | _)
      rw [hp, s.is_focused p p_mem]
      apply p.has_color
    refine' Or.inl âŸ¨âŸ¨(s.lines.map _).cons âŸ¨(l'.map some).vertical s.focus, C' s.focus, fun x => _âŸ©,
            Sum.elim s.focus (l'.map some none), _, _âŸ©, _âŸ©
    Â· refine' fun p => âŸ¨p.line.prod (l'.map some), p.color, fun x => _âŸ©
      rw [Line.prod_apply, Line.map_apply, â† p.has_color, â† congr_fun (hl' x)]
    Â· rw [vertical_apply, â† congr_fun (hl' x), Line.map_apply]
    Â· simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | âŸ¨q, hq, rflâŸ©)
      Â· simp only [vertical_apply]
      Â· simp only [prod_apply, s.is_focused q hq]
    Â· rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact âŸ¨fun âŸ¨q, hq, heâŸ© => h âŸ¨q, hq, heâŸ©, s.distinct_colorsâŸ©
    Â· rw [Multiset.card_cons, Multiset.card_map, sr])","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  c
Î± Î±' : Type u
e : Î± â‰ƒ Î±'
Îº : Type (max v u)
xâœÂ¹ : Finite Îº
Î¹ : Type
xâœ : Fintype Î¹
h : âˆ€ (C : (Î¹ â†’ Î±) â†’ Îº), âˆƒ l, IsMono C l
C : (Î¹ â†’ Î±') â†’ Îº
l : Line Î± Î¹
c : Îº
lc : âˆ€ (x : Î±), (fun v â†¦ C (â‡‘e âˆ˜ v)) ((fun x i â†¦ (l.idxFun i).getD x) x) = c
x : Î±
âŠ¢ ?m.6437 x
error:  application type mismatch
  Exists.intro c ((Equiv.forall_congr_left e).mp fun x â†¦ ?m.6452 x)
argument
  (Equiv.forall_congr_left e).mp fun x â†¦ ?m.6452 x
has type
  âˆ€ (b : Î±'), ?m.6437 (e.symm b) : Prop
but is expected to have type
  âˆ€ (x : Î±'), C ((fun x i â†¦ ((map (â‡‘e) l).idxFun i).getD x) x) = c : Prop","theorem exists_mono_in_high_dimension' :
    âˆ€ (Î± : Type u) [Finite Î±] (Îº : Type max v u) [Finite Îº],
      âˆƒ (Î¹ : Type) (_ : Fintype Î¹), âˆ€ C : (Î¹ â†’ Î±) â†’ Îº, âˆƒ l : Line Î± Î¹, l.IsMono C ",":=
  Finite.induction_empty_option
  (
  fun {Î± Î±'} e =>
    forall_imp fun Îº =>
      forall_imp fun _ =>
        Exists.imp fun Î¹ =>
          Exists.imp fun _ h C =>
            let âŸ¨l, c, lcâŸ© := h fun v => C (e âˆ˜ v)
            âŸ¨l.map e, c, e.forall_congr_right.mp fun x => by rw [â† lc x, Line.map_apply]âŸ©)
  (by
    intro Îº _
    by_cases h : Nonempty Îº
    Â· refine âŸ¨Unit, inferInstance, fun C => âŸ¨default, Classical.arbitrary _, PEmpty.recâŸ©âŸ©
    Â· exact âŸ¨Empty, inferInstance, fun C => (h âŸ¨C (Empty.rec)âŸ©).elimâŸ©)
  (by
    intro Î± _ ihÎ± Îº _
    cases nonempty_fintype Îº
    by_cases h : Nonempty Î±
    case neg =>
      refine âŸ¨Unit, inferInstance, fun C => âŸ¨diagonal _ Unit, C fun _ => none, ?_âŸ©âŸ©
      rintro (_ | âŸ¨aâŸ©)
      Â· rfl
      Â· exact (h âŸ¨aâŸ©).elim
    suffices key :
      âˆ€ r : â„•,
        âˆƒ (Î¹ : Type) (_ : Fintype Î¹),
          âˆ€ C : (Î¹ â†’ Option Î±) â†’ Îº,
            (âˆƒ s : ColorFocused C, Multiset.card s.lines = r) âˆ¨ âˆƒ l, IsMono C l by
      obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := key (Fintype.card Îº + 1)
      refine âŸ¨Î¹, _inst, fun C => (hÎ¹ C).resolve_left ?_âŸ©
      rintro âŸ¨s, srâŸ©
      apply Nat.not_succ_le_self (Fintype.card Îº)
      rw [â† Nat.add_one, â† sr, â† Multiset.card_map, â† Finset.card_mk]
      exact Finset.card_le_univ âŸ¨_, s.distinct_colorsâŸ©
    intro r
    induction' r with r ihr
    Â· exact âŸ¨Empty, inferInstance, fun C => Or.inl âŸ¨default, Multiset.card_zeroâŸ©âŸ©
    obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := ihr
    specialize ihÎ± ((Î¹ â†’ Option Î±) â†’ Îº)
    obtain âŸ¨Î¹', _inst, hÎ¹'âŸ© := ihÎ±
    refine âŸ¨Sum Î¹ Î¹', inferInstance, ?_âŸ©
    intro C
    specialize hÎ¹' fun v' v => C (Sum.elim v (some âˆ˜ v'))
    obtain âŸ¨l', C', hl'âŸ© := hÎ¹'
    have mono_of_mono : (âˆƒ l, IsMono C' l) â†’ âˆƒ l, IsMono C l := by
      rintro âŸ¨l, c, hlâŸ©
      refine âŸ¨l.horizontal (some âˆ˜ l' (Classical.arbitrary Î±)), c, fun x => ?_âŸ©
      rw [Line.horizontal_apply, â† hl, â† hl']
    specialize hÎ¹ C'
    rcases hÎ¹ with (âŸ¨s, srâŸ© | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : âˆƒ p âˆˆ s.lines, (p : AlmostMono _).color = C' s.focus
    Â· obtain âŸ¨p, p_mem, hpâŸ© := h
      refine Or.inr (mono_of_mono âŸ¨p.line, p.color, ?_âŸ©)
      rintro (_ | _)
      Â· rw [hp, s.is_focused p p_mem]
      Â· apply p.has_color
    refine Or.inl âŸ¨âŸ¨(s.lines.map ?_).cons âŸ¨(l'.map some).vertical s.focus, C' s.focus, fun x => ?_âŸ©,
            Sum.elim s.focus (l'.map some none), ?_, ?_âŸ©, ?_âŸ©
    Â· refine fun p => âŸ¨p.line.prod (l'.map some), p.color, fun x => ?_âŸ©
      rw [Line.prod_apply, Line.map_apply, â† p.has_color, â† congr_fun (hl' x)]
    Â· rw [vertical_apply, â† congr_fun (hl' x), Line.map_apply]
    Â· simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | âŸ¨q, hq, rflâŸ©)
      Â· simp only [vertical_apply]
      Â· simp only [prod_apply, s.is_focused q hq]
    Â· rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact âŸ¨fun âŸ¨q, hq, heâŸ© => h âŸ¨q, hq, heâŸ©, s.distinct_colorsâŸ©
    Â· rw [Multiset.card_cons, Multiset.card_map, sr])",cases' exists_mono_in_high_dimension' with Î± hÎ±
Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean,SimpleGraph.adjMatrix_mul_self_apply_self,adjMatrix_mul_self_apply_self,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,:= by simp,"error:  unsolved goals
V : Type u_1
Î± : Type u_2
Î² : Type u_3
G : SimpleGraph V
instâœÂ² : DecidableRel G.Adj
instâœÂ¹ : Fintype V
instâœ : NonAssocSemiring Î±
i : V
âŠ¢ â†‘(filter (G.Adj i) (G.neighborFinset i)).card = â†‘(G.degree i)","theorem adjMatrix_mul_self_apply_self [NonAssocSemiring Î±] (i : V) :
    (G.adjMatrix Î± * G.adjMatrix Î±) i i = degree G i ",:= by simp [filter_true_of_mem],rw [degree_eq_degree adjMatrix_mul_self_apply_self]
Mathlib/Analysis/Convolution.lean,MeasureTheory.continuousOn_convolution_right_with_param,continuousOn_convolution_right_with_param,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  by_cases H : âˆ€ p âˆˆ s, âˆ€ x, g p x = 0
  Â· apply (continuousOn_const (c := 0)).congr
    rintro âŸ¨p, xâŸ© âŸ¨hp, -âŸ©
    apply integral_eq_zero_of_ae (eventually_of_forall (fun y â†¦ ?_))
    simp [H p hp _]
  have : LocallyCompactSpace G := by
    push_neg at H
    rcases H with âŸ¨p, hp, x, hxâŸ©
    have A : support (g p) âŠ† k := support_subset_iff'.2 (fun y hy â†¦ hgs p y hp hy)
    have B : Continuous (g p) := by
      refine hg.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
      simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true] using hp
    rcases eq_zero_or_locallyCompactSpace_of_support_subset_isCompact_of_addGroup hk A B with H|H
    Â· simp [H] at hx
    Â· exact H
  rintro âŸ¨qâ‚€, xâ‚€âŸ© âŸ¨hqâ‚€, -âŸ©
  obtain âŸ¨t, t_comp, htâŸ© : âˆƒ t, IsCompact t âˆ§ t âˆˆ ğ“ xâ‚€ := exists_compact_mem_nhds xâ‚€
  let k' : Set G := (-k) +áµ¥ t
  have k'_comp : IsCompact k' := IsCompact.vadd_set hk.neg t_comp
  let g' : (P Ã— G) â†’ G â†’ E' := fun p x â†¦ g p.1 (p.2 - x)
  let s' : Set (P Ã— G) := s Ã—Ë¢ t
  have A : ContinuousOn g'.uncurry (s' Ã—Ë¢ univ) := by
    have : g'.uncurry = g.uncurry âˆ˜ (fun w â†¦ (w.1.1, w.1.2 - w.2)) := by ext y; rfl
    rw [this]
    refine hg.comp (continuous_fst.fst.prod_mk (continuous_fst.snd.sub
      continuous_snd)).continuousOn ?_
    simp (config := {contextual := true}) [MapsTo]
  have B : ContinuousOn (fun a â†¦ âˆ« x, L (f x) (g' a x) âˆ‚Î¼) s' := by
    apply continuousOn_integral_bilinear_of_locally_integrable_of_compact_support L k'_comp A _
      (hf.integrableOn_isCompact k'_comp)
    rintro âŸ¨p, xâŸ© y âŸ¨hp, hxâŸ© hy
    apply hgs p _ hp
    contrapose! hy
    exact âŸ¨y - x, by simpa using hy, x, hx, by simpâŸ©
  apply ContinuousWithinAt.mono_of_mem (B (qâ‚€, xâ‚€) âŸ¨hqâ‚€, mem_of_mem_nhds htâŸ©)
  exact mem_nhdsWithin_prod_iff.2 âŸ¨s, self_mem_nhdsWithin, t, nhdsWithin_le_nhds ht, Subset.rflâŸ©","error:  unsolved goals
ğ•œ : Type uğ•œ
G : Type uG
E : Type uE
E' : Type uE'
E'' : Type uE''
F : Type uF
F' : Type uF'
F'' : Type uF''
P : Type uP
instâœÂ¹âµ : NormedAddCommGroup E
instâœÂ¹â´ : NormedAddCommGroup E'
instâœÂ¹Â³ : NormedAddCommGroup E''
instâœÂ¹Â² : NormedAddCommGroup F
f f' : G â†’ E
gâœ g'âœ : G â†’ E'
x x' : G
y y' : E
instâœÂ¹Â¹ : NontriviallyNormedField ğ•œ
instâœÂ¹â° : NormedSpace ğ•œ E
instâœâ¹ : NormedSpace ğ•œ E'
instâœâ¸ : NormedSpace ğ•œ E''
instâœâ· : NormedSpace ğ•œ F
L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F
instâœâ¶ : MeasurableSpace G
Î¼ Î½ : Measure G
instâœâµ : NormedSpace â„ F
instâœâ´ : AddGroup G
instâœÂ³ : TopologicalSpace G
instâœÂ² : TopologicalAddGroup G
instâœÂ¹ : BorelSpace G
instâœ : TopologicalSpace P
g : P â†’ G â†’ E'
s : Set P
k : Set G
hk : IsCompact k
hgs : âˆ€ (p : P) (x : G), p âˆˆ s â†’ x âˆ‰ k â†’ g p x = 0
hf : LocallyIntegrable f Î¼
hg : ContinuousOn (â†¿g) (s Ã—Ë¢ univ)
H : Â¬âˆ€ p âˆˆ s, âˆ€ (x : G), g p x = 0
thisâœ : LocallyCompactSpace G
qâ‚€ : P
xâ‚€ : G
hqâ‚€ : (qâ‚€, xâ‚€).1 âˆˆ s
t : Set G
t_comp : IsCompact t
ht : t âˆˆ ğ“ xâ‚€
k' : Set G := -k +áµ¥ t
k'_comp : IsCompact k'
g' : P Ã— G â†’ G â†’ E' := fun p x â†¦ g p.1 (p.2 - x)
s' : Set (P Ã— G) := s Ã—Ë¢ t
this : uncurry g' = uncurry g âˆ˜ fun w â†¦ (w.1.1, w.1.2 - w.2)
âŠ¢ âˆ€ (a : P) (b : G), (a, b) âˆˆ s' â†’ a âˆˆ s","theorem continuousOn_convolution_right_with_param {g : P â†’ G â†’ E'} {s : Set P} {k : Set G}
    (hk : IsCompact k) (hgs : âˆ€ p, âˆ€ x, p âˆˆ s â†’ x âˆ‰ k â†’ g p x = 0)
    (hf : LocallyIntegrable f Î¼) (hg : ContinuousOn (â†¿g) (s Ã—Ë¢ univ)) :
    ContinuousOn (fun q : P Ã— G => (f â‹†[L, Î¼] g q.1) q.2) (s Ã—Ë¢ univ) ",":= by
  by_cases H : âˆ€ p âˆˆ s, âˆ€ x, g p x = 0
  Â· apply (continuousOn_const (c := 0)).congr
    rintro âŸ¨p, xâŸ© âŸ¨hp, -âŸ©
    apply integral_eq_zero_of_ae (eventually_of_forall (fun y â†¦ ?_))
    simp [H p hp _]
  have : LocallyCompactSpace G := by
    push_neg at H
    rcases H with âŸ¨p, hp, x, hxâŸ©
    have A : support (g p) âŠ† k := support_subset_iff'.2 (fun y hy â†¦ hgs p y hp hy)
    have B : Continuous (g p) := by
      refine hg.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
      simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true] using hp
    rcases eq_zero_or_locallyCompactSpace_of_support_subset_isCompact_of_addGroup hk A B with H|H
    Â· simp [H] at hx
    Â· exact H
  rintro âŸ¨qâ‚€, xâ‚€âŸ© âŸ¨hqâ‚€, -âŸ©
  obtain âŸ¨t, t_comp, htâŸ© : âˆƒ t, IsCompact t âˆ§ t âˆˆ ğ“ xâ‚€ := exists_compact_mem_nhds xâ‚€
  let k' : Set G := (-k) +áµ¥ t
  have k'_comp : IsCompact k' := IsCompact.vadd_set hk.neg t_comp
  let g' : (P Ã— G) â†’ G â†’ E' := fun p x â†¦ g p.1 (p.2 - x)
  let s' : Set (P Ã— G) := s Ã—Ë¢ t
  have A : ContinuousOn g'.uncurry (s' Ã—Ë¢ univ) := by
    have : g'.uncurry = g.uncurry âˆ˜ (fun w â†¦ (w.1.1, w.1.2 - w.2)) := by ext y; rfl
    rw [this]
    refine hg.comp (continuous_fst.fst.prod_mk (continuous_fst.snd.sub
      continuous_snd)).continuousOn ?_
    simp (config := {contextual := true}) [s', MapsTo]
  have B : ContinuousOn (fun a â†¦ âˆ« x, L (f x) (g' a x) âˆ‚Î¼) s' := by
    apply continuousOn_integral_bilinear_of_locally_integrable_of_compact_support L k'_comp A _
      (hf.integrableOn_isCompact k'_comp)
    rintro âŸ¨p, xâŸ© y âŸ¨hp, hxâŸ© hy
    apply hgs p _ hp
    contrapose! hy
    exact âŸ¨y - x, by simpa using hy, x, hx, by simpâŸ©
  apply ContinuousWithinAt.mono_of_mem (B (qâ‚€, xâ‚€) âŸ¨hqâ‚€, mem_of_mem_nhds htâŸ©)
  exact mem_nhdsWithin_prod_iff.2 âŸ¨s, self_mem_nhdsWithin, t, nhdsWithin_le_nhds ht, Subset.rflâŸ©",rw [continuousOn_convolution_right_with_param] at hf
Mathlib/Topology/Algebra/Valuation.lean,Valued.loc_const,loc_const,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [mem_nhds]
  rcases Units.exists_iff_ne_zero.mpr h with âŸ¨Î³, hxâŸ©
  use Î³
  rw [hx]
  intro y y_in
  exact Valuation.map_eq_of_sub_lt _ y_in","error:  application type mismatch
  Units.exists_iff_ne_zero.mpr h
argument
  h
has type
  v x â‰  0 : Prop
but is expected to have type
  âˆƒ x, x â‰  0 âˆ§ ?m.29991 x : Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.29991 â†‘Î³
case h
R : Type u
instâœÂ¹ : Ring R
Î“â‚€ : Type v
instâœ : LinearOrderedCommGroupWithZero Î“â‚€
_i : Valued R Î“â‚€
x : R
h : v x â‰  0
Î³ : Î“â‚€Ë£
hx : ?m.29991 â†‘Î³
âŠ¢ {y | v (y - x) < â†‘Î³} âŠ† {y | v y = v x}",theorem loc_const {x : R} (h : (v x : Î“â‚€) â‰  0) : { y : R | v y = v x } âˆˆ ğ“ x ,":= by
  rw [mem_nhds]
  use Units.mk0 _ h
  rw [Units.val_mk0]
  intro y y_in
  exact Valuation.map_eq_of_sub_lt _ y_in",rw [mem_nhds_iff]
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.mul_measure_le_of_subset_lt_limRatioMeas,mul_measure_le_of_subset_lt_limRatioMeas,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  let t := {x : Î± | Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ (v.limRatioMeas hÏ x))}
  have A : Î¼ tá¶œ = 0 := v.ae_tendsto_limRatioMeas hÏ
  suffices H : (q â€¢ Î¼) (s âˆ© t) â‰¤ Ï (s âˆ© t);
  exact
    calc
      (q â€¢ Î¼) s = (q â€¢ Î¼) (s âˆ© t âˆª s âˆ© tá¶œ) := by rw [inter_union_compl]
      _ â‰¤ (q â€¢ Î¼) (s âˆ© t) + (q â€¢ Î¼) (s âˆ© tá¶œ) := (measure_union_le _ _)
      _ â‰¤ Ï (s âˆ© t) + q * Î¼ tá¶œ := by
        apply add_le_add H
        rw [coe_nnreal_smul_apply]
        exact mul_le_mul_left' (measure_mono (inter_subset_right _ _)) _
      _ â‰¤ Ï s := by
        rw [A, mul_zero, add_zero]; exact measure_mono (inter_subset_left _ _)
  refine' v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ _
  intro x hx
  have I : âˆ€á¶  a in v.filterAt x, (q : â„â‰¥0âˆ) < Ï a / Î¼ a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le",error:  unexpected token ';'; expected 'by' or 'from',"theorem mul_measure_le_of_subset_lt_limRatioMeas {q : â„â‰¥0} {s : Set Î±}
    (h : s âŠ† {x | (q : â„â‰¥0âˆ) < v.limRatioMeas hÏ x}) : (q : â„â‰¥0âˆ) * Î¼ s â‰¤ Ï s ",":= by
  let t := {x : Î± | Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ (v.limRatioMeas hÏ x))}
  have A : Î¼ tá¶œ = 0 := v.ae_tendsto_limRatioMeas hÏ
  suffices H : (q â€¢ Î¼) (s âˆ© t) â‰¤ Ï (s âˆ© t) by calc
    (q â€¢ Î¼) s = (q â€¢ Î¼) (s âˆ© t âˆª s âˆ© tá¶œ) := by rw [inter_union_compl]
    _ â‰¤ (q â€¢ Î¼) (s âˆ© t) + (q â€¢ Î¼) (s âˆ© tá¶œ) := measure_union_le _ _
    _ â‰¤ Ï (s âˆ© t) + (q â€¢ Î¼) tá¶œ := by gcongr; apply inter_subset_right
    _ = Ï (s âˆ© t) := by simp [A]
    _ â‰¤ Ï s := by gcongr; apply inter_subset_left
  refine v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ ?_
  intro x hx
  have I : âˆ€á¶  a in v.filterAt x, (q : â„â‰¥0âˆ) < Ï a / Î¼ a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le",refine le_trans (mul_measure_le_of_subset_lt_limRatioMeas_le s) ?_
Mathlib/Algebra/AddTorsor.lean,Equiv.pointReflection_fixed_iff_of_injective_bit0,pointReflection_fixed_iff_of_injective_bit0,b0c1460c9fd4a5058bcae6b919686bc5e8a0ee37,":= by
  rw [pointReflection_apply, eq_comm, eq_vadd_iff_vsub_eq, â† neg_vsub_eq_vsub_rev,
    neg_eq_iff_add_eq_zero, â† bit0, â† bit0_zero, h.eq_iff, vsub_eq_zero_iff_eq, eq_comm]
  equiv.point_reflection_fixed_iff_of_injective_bit0
  Equiv.pointReflection_fixed_iff_of_injective_bit0","error:  unknown tactic
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated","theorem pointReflection_fixed_iff_of_injective_bit0 {x y : P} (h : Injective (bit0 : G â†’ G)) :
    pointReflection x y = y â†” y = x ",":= by
  rw [pointReflection_apply, eq_comm, eq_vadd_iff_vsub_eq, â† neg_vsub_eq_vsub_rev,
    neg_eq_iff_add_eq_zero, â† bit0, â† bit0_zero, h.eq_iff, vsub_eq_zero_iff_eq, eq_comm]","rw [pointReflection_eq_pointReflection pointReflection_fixed_iff_of_injective_bit0,
  pointReflection_fixed_iff_of_injective_bit0]"
Mathlib/RingTheory/IntegralDomain.lean,sum_hom_units_eq_zero,sum_hom_units_eq_zero,9e34a191034458a56331f976ff7400a26407c888,":= by
  classical
    obtain âŸ¨x, hxâŸ© :
      âˆƒ x : MonoidHom.range f.toHomUnits,
        âˆ€ y : MonoidHom.range f.toHomUnits, y âˆˆ Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x â‰  1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx âŸ¨f.toHomUnits g, g, rflâŸ© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 â‰  0  
    exact fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      âˆ‘ g : G, f g = âˆ‘ g : G, (f.toHomUnits g : R) := rfl
      _ = âˆ‘ u : RË£ in univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card â€¢ (u : R) :=
        (sum_comp ((â†‘) : RË£ â†’ R) f.toHomUnits)
      _ = âˆ‘ u : RË£ in univ.image f.toHomUnits, c â€¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_argâ‚‚ _ ?_ rfl)
      _ = âˆ‘ b : MonoidHom.range f.toHomUnits, c â€¢ ((b : RË£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c â€¢ âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R) := smul_sum.symm
      _ = c â€¢ (0 : R) := (congr_argâ‚‚ _ rfl ?_)
      _ = (0 : R) := smul_zero _
    Â· 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply card_fiber_eq_of_mem_range f.toHomUnits
      Â· simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      Â· exact âŸ¨1, f.toHomUnits.map_oneâŸ©
    show (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R)) = 0
    calc
      (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R))
        = âˆ‘ n in range (orderOf x), ((x : RË£) : R) ^ n :=
        Eq.symm <|
          sum_bij (fun n _ => x ^ n) (by simp only [mem_univ, forall_true_iff])
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
            (fun m n hm hn =>
              pow_injective_of_lt_orderOf _ (by simpa only [mem_range] using hm)
                (by simpa only [mem_range] using hn))
            (fun b _ => let âŸ¨n, hnâŸ© := hx b
              âŸ¨n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn âŠ¢; rw [â† pow_eq_mod_orderOf, hn]âŸ©)
      _ = 0 := ?_

    rw [â† mul_left_inj' hx1, MulZeroClass.zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]","error:  unexpected identifier; expected '|'
error:  unsolved goals
case intro
R : Type u_1
G : Type u_2
instâœÂ³ : CommRing R
instâœÂ² : IsDomain R
instâœÂ¹ : Group G
instâœ : Fintype G
f : G â†’* R
hf : f â‰  1
x : â†¥f.toHomUnits.range
hx : âˆ€ (y : â†¥f.toHomUnits.range), y âˆˆ Submonoid.powers x
hx1 : â†‘â†‘x - 1 â‰  0
âŠ¢ âˆ‘ g : G, f g = 0","theorem sum_hom_units_eq_zero (f : G â†’* R) (hf : f â‰  1) : âˆ‘ g : G, f g = 0 ",":= by
  classical
    obtain âŸ¨x, hxâŸ© : âˆƒ x : MonoidHom.range f.toHomUnits,
        âˆ€ y : MonoidHom.range f.toHomUnits, y âˆˆ Submonoid.powers x :=
      IsCyclic.exists_monoid_generator
    have hx1 : x â‰  1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx âŸ¨f.toHomUnits g, g, rflâŸ© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 â‰  0 := 
      fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      âˆ‘ g : G, f g = âˆ‘ g : G, (f.toHomUnits g : R) := rfl
      _ = âˆ‘ u âˆˆ univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card â€¢ (u : R) :=
        (sum_comp ((â†‘) : RË£ â†’ R) f.toHomUnits)
      _ = âˆ‘ u âˆˆ univ.image f.toHomUnits, c â€¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_argâ‚‚ _ ?_ rfl)
      _ = âˆ‘ b : MonoidHom.range f.toHomUnits, c â€¢ ((b : RË£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c â€¢ âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R) := smul_sum.symm
      _ = c â€¢ (0 : R) := congr_argâ‚‚ _ rfl ?_
      _ = (0 : R) := smul_zero _
    Â· 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply MonoidHom.card_fiber_eq_of_mem_range f.toHomUnits
      Â· simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      Â· exact âŸ¨1, f.toHomUnits.map_oneâŸ©
    show (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R)) = 0
    calc
      (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R))
        = âˆ‘ n âˆˆ range (orderOf x), ((x : RË£) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ Â·) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let âŸ¨n, hnâŸ© := hx b
              âŸ¨n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn âŠ¢; rw [pow_mod_orderOf, hn]âŸ©)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [â† mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]","simp only [sum_hom_units_eq_zero, sum_hom_units_eq_zero]"
Mathlib/CategoryTheory/EssentialImage.lean,CategoryTheory.Functor.essImage_eq_of_natIso,essImage_eq_of_natIso,ef3c9bcd07782b044027916a64e925f3e4951707,":=
  congrArg Set.ofPred <| funext fun _ => propext âŸ¨essImage.ofNatIso h, essImage.ofNatIso h.symmâŸ©",error:  unknown constant 'Set.ofPred',theorem essImage_eq_of_natIso {F' : C â¥¤ D} (h : F â‰… F') : essImage F = essImage F' ,":=
  funext fun _ => propext âŸ¨essImage.ofNatIso h, essImage.ofNatIso h.symmâŸ©",apply essImage_eq_of_essImage_eq_of_essImage
Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean,Polynomial.orderOf_root_cyclotomic_dvd,orderOf_root_cyclotomic_dvd,b271affacf1fa368c4e879d75cd5aaf54b75b7ed,":= by
  apply orderOf_dvd_of_pow_eq_one
  suffices hpow : eval (Nat.castRingHom (ZMod p) a) (X ^ n - 1 : (ZMod p)[X]) = 0 by
    simp only [eval_X, eval_one, eval_pow, eval_sub, eq_natCast] at hpow
    apply Units.val_eq_one.1
    simp only [sub_eq_zero.mp hpow, ZMod.coe_unitOfCoprime, Units.val_pow_eq_pow_val]
  rw [IsRoot.definition] at hroot
  rw [â† prod_cyclotomic_eq_X_pow_sub_one hpos (ZMod p), â† Nat.cons_self_properDivisors hpos.ne',
    Finset.prod_cons, eval_mul, hroot, zero_mul]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsRoot
has type
  ?m.177035[X] â†’ ?m.177035 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.177089
case h
n : â„•
hpos : 0 < n
p : â„•
instâœ : Fact (Nat.Prime p)
a : â„•
hroot : (cyclotomic n (ZMod p)).IsRoot ((Nat.castRingHom (ZMod p)) a)
âŠ¢ eval ((Nat.castRingHom (ZMod p)) a) (X ^ n - 1) = 0","theorem orderOf_root_cyclotomic_dvd {n : â„•} (hpos : 0 < n) {p : â„•} [Fact p.Prime] {a : â„•}
    (hroot : IsRoot (cyclotomic n (ZMod p)) (Nat.castRingHom (ZMod p) a)) :
    orderOf (ZMod.unitOfCoprime a (coprime_of_root_cyclotomic hpos hroot)) âˆ£ n ",":= by
  apply orderOf_dvd_of_pow_eq_one
  suffices hpow : eval (Nat.castRingHom (ZMod p) a) (X ^ n - 1 : (ZMod p)[X]) = 0 by
    simp only [eval_X, eval_one, eval_pow, eval_sub, eq_natCast] at hpow
    apply Units.val_eq_one.1
    simp only [sub_eq_zero.mp hpow, ZMod.coe_unitOfCoprime, Units.val_pow_eq_pow_val]
  rw [IsRoot.def] at hroot
  rw [â† prod_cyclotomic_eq_X_pow_sub_one hpos (ZMod p), â† Nat.cons_self_properDivisors hpos.ne',
    Finset.prod_cons, eval_mul, hroot, zero_mul]",apply orderOf_root_cyclotomic_dvd
Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean,GeneralizedContinuedFraction.get?_of_eq_some_of_succ_get?_intFractPair_stream,get?_of_eq_some_of_succ_get?_intFractPair_stream,67bb925387960887a3b36a6aab219b9c613883f7,":= by
  unfold of IntFractPair.seq1
  simp [Seq'.map_tail, Seq'.get?_tail, Seq'.map_get?, stream_succ_nth_eq]","error:  unknown identifier 'Seq'.map_tail'
error:  unknown identifier 'Seq'.get?_tail'
error:  unknown identifier 'Seq'.map_get?'","theorem get?_of_eq_some_of_succ_get?_intFractPair_stream {ifp_succ_n : IntFractPair K}
    (stream_succ_nth_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n) :
    (of v).s.get? n = some âŸ¨1, ifp_succ_n.bâŸ© ",":= by
  unfold of IntFractPair.seq1
  simp [Stream'.Seq.map_tail, Stream'.Seq.get?_tail, Stream'.Seq.map_get?, stream_succ_nth_eq]","simp [stream_succ_nth_eq, stream_succ_nth_eq]"
Mathlib/Algebra/Module/PID.lean,Module.torsion_by_prime_power_decomposition,torsion_by_prime_power_decomposition,149993021318d2b426f3d41570396b90e12fcb46,":= by
  obtain âŸ¨d, s, hsâŸ© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  Â· 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      âŸ¨âŸ¨0âŸ©, fun x => by dsimp; rw [â† Submodule.mem_bot R, hs]; exact Submodule.mem_topâŸ©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact âŸ¨0âŸ©
  Â· have : âˆ€ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain âŸ¨j, hjâŸ© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d â†’ N â§¸ R âˆ™ s j := Submodule.Quotient.mk âˆ˜ s âˆ˜ j.succAbove
    have := IH ?_ s' ?_
    Â· obtain âŸ¨k, âŸ¨fâŸ©âŸ© := this
      clear IH
      have : âˆ€ i : Fin d,
          âˆƒ x : N, p ^ k i â€¢ x = 0 âˆ§ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain âŸ¨x, h0, h1âŸ© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine âŸ¨x, h0, ?_âŸ©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine âŸ¨?_, âŸ¨?_âŸ©âŸ©
      Â· exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : â„•)) (finSuccEquiv d a)
      Â· refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R â§¸ _ â†’â‚—[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R âˆ™ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _
          (fun i => R â§¸ R âˆ™ p ^ @Option.rec _ (fun _ => â„•) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        Â· rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        Â· rw [â† f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, â† LinearMap.comp_assoc,
            â† LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R âˆ™ s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    Â· exact (mk_surjective _).forall.mpr fun x =>
        âŸ¨(@hN x).choose, by rw [â† Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]âŸ©
    Â· have hs' := congr_arg (Submodule.map <| mkQ <| R âˆ™ s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [â† Function.comp.assoc, Set.range_comp (_ âˆ˜ s), Fin.range_succAbove]
      rw [â† Set.range_comp, â† Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'","error:  type mismatch
  R â§¸ Submodule.span R {p ^ Option.rec (pOrder hN (s j)) k i}
has type
  Type u : Type (u + 1)
but is expected to have type
  (b : Option (Fin d)) â†’ Decidable (i = b) : Type
error:  application type mismatch
  (((lequivProdOfRightSplitExact â‹¯ ?m.198963 ?m.198964).symm â‰ªâ‰«â‚—
            ((quotTorsionOfEquivSpanSingleton R N (s j)).symm â‰ªâ‰«â‚—
                  Submodule.quotEquivOfEq (torsionOf R N (s j)) (Ideal.span {p ^ pOrder hN (s j)}) â‹¯).prod
              ULift.moduleEquiv).trans
        ?m.204421).trans
    (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
argument
  DirectSum.lequivCongrLeft R (finSuccEquiv d).symm
has type
  (â¨ (i : Option (Fin d)), ?m.205281 i) â‰ƒâ‚—[R] â¨ (k : Fin (d + 1)), ?m.205281 ((finSuccEquiv d).symm.symm k) : Type u
but is expected to have type
  (â¨ (i : Option (Fin d)), ?m.205281 i) â‰ƒâ‚—[R]
    â¨ (i : Fin (d + 1)),
      R â§¸ Submodule.span R {p ^ (fun i â†¦ Option.rec (pOrder hN (s j)) k i) ((finSuccEquiv d) i)} : Type u","theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    âˆƒ (d : â„•) (k : Fin d â†’ â„•), Nonempty <| N â‰ƒâ‚—[R] â¨ i : Fin d, R â§¸ R âˆ™ p ^ (k i : â„•) ",":= by
  obtain âŸ¨d, s, hsâŸ© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  Â· 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      âŸ¨âŸ¨0âŸ©, fun x => by dsimp; rw [â† Submodule.mem_bot R, hs]; exact Submodule.mem_topâŸ©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact âŸ¨0âŸ©
  Â· have : âˆ€ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain âŸ¨j, hjâŸ© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d â†’ N â§¸ R âˆ™ s j := Submodule.Quotient.mk âˆ˜ s âˆ˜ j.succAbove
    have := IH ?_ s' ?_
    Â· obtain âŸ¨k, âŸ¨fâŸ©âŸ© := this
      clear IH
      have : âˆ€ i : Fin d,
          âˆƒ x : N, p ^ k i â€¢ x = 0 âˆ§ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain âŸ¨x, h0, h1âŸ© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine âŸ¨x, h0, ?_âŸ©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine âŸ¨?_, âŸ¨?_âŸ©âŸ©
      Â· exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : â„•)) (finSuccEquiv d a)
      Â· refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R â§¸ _ â†’â‚—[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R âˆ™ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R â§¸ R âˆ™ p ^ @Option.rec _ (fun _ => â„•) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        Â· rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        Â· rw [â† f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, â† LinearMap.comp_assoc,
            â† LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R âˆ™ s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    Â· exact (mk_surjective _).forall.mpr fun x =>
        âŸ¨(@hN x).choose, by rw [â† Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]âŸ©
    Â· have hs' := congr_arg (Submodule.map <| mkQ <| R âˆ™ s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [â† Function.comp.assoc, Set.range_comp (_ âˆ˜ s), Fin.range_succAbove]
      rw [â† Set.range_comp, â† Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'","refine âŸ¨torsion_by_prime_power_decomposition hN h', ?_âŸ©"
Mathlib/RingTheory/FiniteType.lean,Module.Finite.injective_of_surjective_endomorphism,Module.Finite.injective_of_surjective_endomorphism,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  have : (âŠ¤ : Submodule R[X] (AEval' f)) â‰¤ Ideal.span {(X : R[X])} â€¢ âŠ¤
  Â· intro a _
    obtain âŸ¨y, rflâŸ© := f_surj.comp (AEval'.of f).symm.surjective a
    rw [Function.comp_apply, â†AEval'.of_symm_X_smul]
    exact Submodule.smul_mem_smul (Ideal.mem_span_singleton.mpr (dvd_refl _)) trivial
  obtain âŸ¨F, hFa, hFbâŸ© :=
    Submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul _ (âŠ¤ : Submodule R[X] (AEval' f))
      (finite_def.mp inferInstance) this
  rw [â† LinearMap.ker_eq_bot, LinearMap.ker_eq_bot']
  intro m hm
  rw [â† map_eq_zero_iff (AEval'.of f) (AEval'.of f).injective]
  set m' := Module.AEval'.of f m
  rw [Ideal.mem_span_singleton'] at hFa
  obtain âŸ¨G, hGâŸ© := hFa
  suffices (F - 1) â€¢ m' = 0 by
    have Fmzero := hFb m' (by simp)
    rwa [â† sub_add_cancel F 1, add_smul, one_smul, this, zero_add] at Fmzero
  rw [â† hG, mul_smul, AEval'.X_smul_of, hm, map_zero, smul_zero]","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
R : Type u_1
instâœÂ³ : CommRing R
M : Type u_2
instâœÂ² : AddCommGroup M
instâœÂ¹ : Module R M
instâœ : Finite R M
f : M â†’â‚—[R] M
f_surj : Surjective â‡‘f
this : sorryAx (Sort ?u.263433) true
âŠ¢ Function.Injective â‡‘f","theorem Module.Finite.injective_of_surjective_endomorphism {R : Type*} [CommRing R] {M : Type*}
    [AddCommGroup M] [Module R M] [Finite R M] (f : M â†’â‚—[R] M)
    (f_surj : Function.Surjective f) : Function.Injective f ",":=
  OrzechProperty.injective_of_surjective_endomorphism f f_surj",exact Function.Injective.of_surjective f_surj
Mathlib/Analysis/InnerProductSpace/Positive.lean,ContinuousLinearMap.isPositive_one,isPositive_one,1c643aca968064296312bf5328c84d0c50cfe5ae,":=
  âŸ¨.one _, fun _ => inner_self_nonnegâŸ©","error:  invalid dotted identifier notation, unknown identifier `IsSelfAdjoint.one` from expected type
  IsSelfAdjoint 1
error:  invalid dotted identifier notation, unknown identifier `Eq.one` from expected type
  IsSelfAdjoint 1",theorem isPositive_one : IsPositive (1 : E â†’L[ğ•œ] E) ,":=
  âŸ¨isSelfAdjoint_one _, fun _ => inner_self_nonnegâŸ©",heorem isPositive_one isPositive_one
Mathlib/Topology/Separation.lean,compact_t2_tot_disc_iff_tot_sep,compact_t2_tot_disc_iff_tot_sep,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine âŸ¨fun h => âŸ¨fun x _ y _ => ?_âŸ©, @TotallySeparatedSpace.totallyDisconnectedSpace _ _âŸ©
  contrapose!
  intro hyp
  suffices x âˆˆ connectedComponent y by
    simpa [totallyDisconnectedSpace_iff_connectedComponent_singleton.1 h y, mem_singleton_iff]
  rw [connectedComponent_eq_iInter_isClopen, mem_iInter]
  rintro âŸ¨w : Set X, hw : IsClopen w, hy : y âˆˆ wâŸ©
  by_contra hx
  exact hyp wá¶œ w hw.1.isOpen_compl hw.2 hx hy (@isCompl_compl _ w _).symm.codisjoint.top_le
    disjoint_compl_left","error:  application type mismatch
  hyp wá¶œ
argument
  wá¶œ
has type
  Set X : Type u_1
but is expected to have type
  âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ univ âŠ† u âˆª v âˆ§ Disjoint u v : Prop",theorem compact_t2_tot_disc_iff_tot_sep : TotallyDisconnectedSpace X â†” TotallySeparatedSpace X ,":= by
  refine âŸ¨fun h => âŸ¨fun x _ y _ => ?_âŸ©, @TotallySeparatedSpace.totallyDisconnectedSpace _ _âŸ©
  contrapose!
  intro hyp
  suffices x âˆˆ connectedComponent y by
    simpa [totallyDisconnectedSpace_iff_connectedComponent_singleton.1 h y, mem_singleton_iff]
  rw [connectedComponent_eq_iInter_isClopen, mem_iInter]
  rintro âŸ¨w : Set X, hw : IsClopen w, hy : y âˆˆ wâŸ©
  by_contra hx
  exact hyp âŸ¨wá¶œ, w, hw.1.isOpen_compl, hw.2, hx, hy, (@isCompl_compl _ w _).symm.codisjoint.top_le,
    disjoint_compl_leftâŸ©",rw [totallySeparatedSpace_iff_totallySeparatedSpace_iff]
Mathlib/Analysis/Convex/Mul.lean,ConcaveOn.smul',ConcaveOn.smul',5fb9beab28702fb284701d494bc9b7c5f52fef53,":= by
  refine âŸ¨hf.1, fun x hx y hy a b ha hb hab â†¦ ?_âŸ©
  dsimp
  refine (smul_le_smul (hf.2 hx hy ha hb hab) (hg.2 hx hy ha hb hab) (add_nonneg
    (smul_nonneg ha $ hgâ‚€ hx) $ smul_nonneg hb $ hgâ‚€ hy) $ hfâ‚€ $ hf.1 hx hy ha hb hab).trans' ?_
  calc a â€¢ f x â€¢ g x + b â€¢ f y â€¢ g y
        = (a * (a + b)) â€¢ (f x â€¢ g x) + (b * (a + b)) â€¢ (f y â€¢ g y) := by simp_rw [hab, mul_one]
    _ = (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g x + f y â€¢ g y) := by
        simp only [mul_add, add_smul, smul_add, mul_comm _ a]; abel
    _ â‰¤ (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g y + f y â€¢ g x) := by
        gcongr _ + (a * b) â€¢ ?_; exact hfg.smul_add_smul_le_smul_add_smul hx hy
    _ = _ := ?_
  simp only [mul_add, add_smul, smul_add]
  rw [â† smul_smul_smul_comm a, â† smul_smul_smul_comm b, â† smul_smul_smul_comm a b,
    â† smul_smul_smul_comm b b, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_comm b a,
    add_comm ((a * b) â€¢ f x â€¢ g y), add_comm ((a * b) â€¢ f x â€¢ g y), add_add_add_comm]","error:  application type mismatch
  smul_nonneg ha (hgâ‚€ hx)
argument
  hgâ‚€ hx
has type
  0 â‰¤ g x : Prop
but is expected to have type
  0 â‰¤ f x : Prop
error:  application type mismatch
  smul_nonneg hb (hgâ‚€ hy)
argument
  hgâ‚€ hy
has type
  0 â‰¤ g y : Prop
but is expected to have type
  0 â‰¤ f y : Prop","lemma ConcaveOn.smul' (hf : ConcaveOn ğ•œ s f) (hg : ConcaveOn ğ•œ s g) (hfâ‚€ : âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ 0 â‰¤ f x)
    (hgâ‚€ : âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ 0 â‰¤ g x) (hfg : AntivaryOn f g s) : ConcaveOn ğ•œ s (f â€¢ g) ",":= by
  refine âŸ¨hf.1, fun x hx y hy a b ha hb hab â†¦ ?_âŸ©
  dsimp
  refine (smul_le_smul (hf.2 hx hy ha hb hab) (hg.2 hx hy ha hb hab)
    (add_nonneg (smul_nonneg ha <| hfâ‚€ hx) <| smul_nonneg hb <| hfâ‚€ hy)
    (hgâ‚€ <| hf.1 hx hy ha hb hab)).trans' ?_
  calc a â€¢ f x â€¢ g x + b â€¢ f y â€¢ g y
        = (a * (a + b)) â€¢ (f x â€¢ g x) + (b * (a + b)) â€¢ (f y â€¢ g y) := by simp_rw [hab, mul_one]
    _ = (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g x + f y â€¢ g y) := by
        simp only [mul_add, add_smul, smul_add, mul_comm _ a]; abel
    _ â‰¤ (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g y + f y â€¢ g x) := by
        gcongr _ + (a * b) â€¢ ?_; exact hfg.smul_add_smul_le_smul_add_smul hx hy
    _ = _ := ?_
  simp only [mul_add, add_smul, smul_add]
  rw [â† smul_smul_smul_comm a, â† smul_smul_smul_comm b, â† smul_smul_smul_comm a b,
    â† smul_smul_smul_comm b b, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_comm b a,
    add_comm ((a * b) â€¢ f x â€¢ g y), add_comm ((a * b) â€¢ f x â€¢ g y), add_add_add_comm]",simpa onlemma ConcaveOn.smul' hf hfg hfâ‚€ hfâ‚€ hfâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hgâ‚€ hfâ‚€ hg
Mathlib/Topology/ShrinkingLemma.lean,ShrinkingLemma.PartialRefinement.exists_gt,exists_gt,e2b5ca370bbc63149cba7caf35005bf2193dc387,":= by
  have I : (s âˆ© â‹‚ (j) (_ : j â‰  i), v já¶œ) âŠ† v i := by
    simp only [subset_def, mem_inter_iff, mem_iInter, and_imp]
    intro x hxs H
    rcases mem_iUnion.1 (v.subset_iUnion hxs) with âŸ¨j, hjâŸ©
    exact (em (j = i)).elim (fun h => h â–¸ hj) fun h => (H j h hj).elim
  have C : IsClosed (s âˆ© â‹‚ (j) (_ : j â‰  i), v já¶œ) :=
    IsClosed.inter hs (isClosed_biInter fun _ _ => isClosed_compl_iff.2 <| v.isOpen _)
  rcases normal_exists_closure_subset C (v.isOpen i) I with âŸ¨vi, ovi, hvi, cviâŸ©
  refine' âŸ¨âŸ¨update v i vi, insert i v.carrier, _, _, _, _âŸ©, _, _âŸ©
  Â· intro j
    rcases eq_or_ne j i with (rfl| hne) <;> simp [*, v.isOpen]
  Â· refine' fun x hx => mem_iUnion.2 _
    rcases em (âˆƒ (j : _)(_ : j â‰  i), x âˆˆ v j) with (âŸ¨j, hji, hjâŸ© | h)
    Â· use j
      rwa [update_noteq hji]
    Â· push_neg  at h
      use i
      rw [update_same]
      exact hvi âŸ¨hx, mem_biInter hâŸ©
  Â· rintro j (rfl | hj)
    Â· rwa [update_same, â† v.apply_eq hi]
    Â· rw [update_noteq (ne_of_mem_of_not_mem hj hi)]
      exact v.closure_subset hj
  Â· intro j hj
    rw [mem_insert_iff, not_or] at hj
    rw [update_noteq hj.1, v.apply_eq hj.2]
  Â· refine' âŸ¨subset_insert _ _, fun j hj => _âŸ©
    exact (update_noteq (ne_of_mem_of_not_mem hj hi) _ _).symm
  Â· exact fun hle => hi (hle.1 <| mem_insert _ _)","error:  failed to synthesize
  HasCompl Î¹
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  HasCompl Î¹
use `set_option diagnostics true` to get diagnostic information","theorem exists_gt (v : PartialRefinement u s) (hs : IsClosed s) (i : Î¹) (hi : i âˆ‰ v.carrier) :
    âˆƒ v' : PartialRefinement u s, v < v' ",":= by
  have I : (s âˆ© â‹‚ (j) (_ : j â‰  i), (v j)á¶œ) âŠ† v i := by
    simp only [subset_def, mem_inter_iff, mem_iInter, and_imp]
    intro x hxs H
    rcases mem_iUnion.1 (v.subset_iUnion hxs) with âŸ¨j, hjâŸ©
    exact (em (j = i)).elim (fun h => h â–¸ hj) fun h => (H j h hj).elim
  have C : IsClosed (s âˆ© â‹‚ (j) (_ : j â‰  i), (v j)á¶œ) :=
    IsClosed.inter hs (isClosed_biInter fun _ _ => isClosed_compl_iff.2 <| v.isOpen _)
  rcases normal_exists_closure_subset C (v.isOpen i) I with âŸ¨vi, ovi, hvi, cviâŸ©
  refine âŸ¨âŸ¨update v i vi, insert i v.carrier, ?_, ?_, ?_, ?_âŸ©, ?_, ?_âŸ©
  Â· intro j
    rcases eq_or_ne j i with (rfl| hne) <;> simp [*, v.isOpen]
  Â· refine fun x hx => mem_iUnion.2 ?_
    rcases em (âˆƒ j â‰  i, x âˆˆ v j) with (âŸ¨j, hji, hjâŸ© | h)
    Â· use j
      rwa [update_noteq hji]
    Â· push_neg at h
      use i
      rw [update_same]
      exact hvi âŸ¨hx, mem_biInter hâŸ©
  Â· rintro j (rfl | hj)
    Â· rwa [update_same, â† v.apply_eq hi]
    Â· rw [update_noteq (ne_of_mem_of_not_mem hj hi)]
      exact v.closure_subset hj
  Â· intro j hj
    rw [mem_insert_iff, not_or] at hj
    rw [update_noteq hj.1, v.apply_eq hj.2]
  Â· refine âŸ¨subset_insert _ _, fun j hj => ?_âŸ©
    exact (update_noteq (ne_of_mem_of_not_mem hj hi) _ _).symm
  Â· exact fun hle => hi (hle.1 <| mem_insert _ _)","refine âŸ¨exists_gt _ _ _ hi, fun âŸ¨i, hiâŸ© => ?_âŸ©"
Mathlib/Analysis/Analytic/Composition.lean,HasFPowerSeriesAt.comp,HasFPowerSeriesAt.comp,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  rcases hg with âŸ¨rg, HgâŸ©
  rcases hf with âŸ¨rf, HfâŸ©
  rcases q.comp_summable_nnreal p Hg.radius_pos Hf.radius_pos with âŸ¨r, r_pos : 0 < r, hrâŸ©
  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© :
    âˆƒ Î´ : â„â‰¥0âˆ, 0 < Î´ âˆ§ âˆ€ {z : E}, z âˆˆ EMetric.ball x Î´ â†’ f z âˆˆ EMetric.ball (f x) rg := by
    have : EMetric.ball (f x) rg âˆˆ ğ“ (f x) := EMetric.ball_mem_nhds _ Hg.r_pos
    rcases EMetric.mem_nhds_iff.1 (Hf.analyticAt.continuousAt this) with âŸ¨Î´, Î´pos, HÎ´âŸ©
    exact âŸ¨Î´, Î´pos, fun hz => HÎ´ hzâŸ©
  let rf' := min rf Î´
  have min_pos : 0 < min rf' r := by
    simp only [r_pos, Hf.r_pos, Î´pos, lt_min_iff, ENNReal.coe_pos, and_self_iff]
  refine' âŸ¨min rf' r, _âŸ©
  refine'
    âŸ¨le_trans (min_le_right rf' r) (FormalMultilinearSeries.le_comp_radius_of_summable q p r hr),
      min_pos, @fun y hy => _âŸ©
  have y_mem : y âˆˆ EMetric.ball (0 : E) rf :=
    (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_left _ _))) hy
  have fy_mem : f (x + y) âˆˆ EMetric.ball (f x) rg := by
    apply hÎ´
    have : y âˆˆ EMetric.ball (0 : E) Î´ :=
      (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_right _ _))) hy
    simpa [edist_eq_coe_nnnorm_sub, edist_eq_coe_nnnorm]
  have A : Tendsto (fun n => âˆ‘ a in Finset.Ico 1 n, p a fun _b => y)
      atTop (ğ“ (f (x + y) - f x)) := by
    have L :
      âˆ€á¶  n in atTop, (âˆ‘ a in Finset.range n, p a fun _b => y) - f x
        = âˆ‘ a in Finset.Ico 1 n, p a fun _b => y := by
      rw [eventually_atTop]
      refine' âŸ¨1, fun n hn => _âŸ©
      symm
      rw [eq_sub_iff_add_eq', Finset.range_eq_Ico, â† Hf.coeff_zero fun _i => y,
        Finset.sum_eq_sum_Ico_succ_bot hn]
    have :
      Tendsto (fun n => (âˆ‘ a in Finset.range n, p a fun _b => y) - f x) atTop
        (ğ“ (f (x + y) - f x)) :=
      (Hf.hasSum y_mem).tendsto_sum_nat.sub tendsto_const_nhds
    exact Tendsto.congr' L this
  have B :
    Tendsto (fun n => q.partialSum n (âˆ‘ a in Finset.Ico 1 n, p a fun _b => y)) atTop
      (ğ“ (g (f (x + y)))) := by
    have Bâ‚ : ContinuousAt (fun z : F => g (f x + z)) (f (x + y) - f x) := by
      refine' ContinuousAt.comp _ (continuous_const.add continuous_id).continuousAt
      simp only [add_sub_cancel'_right, id.def]
      exact Hg.continuousOn.continuousAt (IsOpen.mem_nhds EMetric.isOpen_ball fy_mem)
    have Bâ‚‚ : f (x + y) - f x âˆˆ EMetric.ball (0 : F) rg := by
      simpa [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub] using fy_mem
    rw [â† EMetric.isOpen_ball.nhdsWithin_eq Bâ‚‚] at A
    convert Hg.tendstoLocallyUniformlyOn.tendsto_comp Bâ‚.continuousWithinAt Bâ‚‚ A
    simp only [add_sub_cancel'_right]
  have C :
    Tendsto
      (fun n => âˆ‘ i in compPartialSumTarget 0 n n, q.compAlongComposition p i.2 fun _j => y)
      atTop (ğ“ (g (f (x + y)))) :=
    by simpa [comp_partialSum] using B
  have D :
    HasSum (fun i : Î£ n, Composition n => q.compAlongComposition p i.2 fun _j => y)
      (g (f (x + y))) :=
    haveI cau :
      CauchySeq fun s : Finset (Î£ n, Composition n) =>
        âˆ‘ i in s, q.compAlongComposition p i.2 fun _j => y := by
      apply cauchySeq_finset_of_norm_bounded _ (NNReal.summable_coe.2 hr) _
      simp only [coe_nnnorm, NNReal.coe_mul, NNReal.coe_pow]
      rintro âŸ¨n, câŸ©
      calc
        â€–(compAlongComposition q p c) fun _j : Fin n => yâ€– â‰¤
            â€–compAlongComposition q p câ€– * âˆ _j : Fin n, â€–yâ€– :=
          by apply ContinuousMultilinearMap.le_opNorm
        _ â‰¤ â€–compAlongComposition q p câ€– * (r : â„) ^ n := by
          apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
          rw [Finset.prod_const, Finset.card_fin]
          apply pow_le_pow_left (norm_nonneg _)
          rw [EMetric.mem_ball, edist_eq_coe_nnnorm] at hy
          have := le_trans (le_of_lt hy) (min_le_right _ _)
          rwa [ENNReal.coe_le_coe, â† NNReal.coe_le_coe, coe_nnnorm] at this
    tendsto_nhds_of_cauchySeq_of_subseq cau compPartialSumTarget_tendsto_atTop C
  have E : HasSum (fun n => (q.comp p) n fun _j => y) (g (f (x + y))) := by
    apply D.sigma
    intro n
    dsimp [FormalMultilinearSeries.comp]
    convert hasSum_fintype (Î± := G) (Î² := Composition n) _
    simp only [ContinuousMultilinearMap.sum_apply]
    rfl
  rw [Function.comp_apply]
  exact E","error:  unsolved goals
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
G : Type u_4
H : Type u_5
instâœâ¸ : NontriviallyNormedField ğ•œ
instâœâ· : NormedAddCommGroup E
instâœâ¶ : NormedSpace ğ•œ E
instâœâµ : NormedAddCommGroup F
instâœâ´ : NormedSpace ğ•œ F
instâœÂ³ : NormedAddCommGroup G
instâœÂ² : NormedSpace ğ•œ G
instâœÂ¹ : NormedAddCommGroup H
instâœ : NormedSpace ğ•œ H
g : F â†’ G
f : E â†’ F
q : FormalMultilinearSeries ğ•œ F G
p : FormalMultilinearSeries ğ•œ E F
x : E
rg : â„â‰¥0âˆ
Hg : HasFPowerSeriesOnBall g q (f x) rg
rf : â„â‰¥0âˆ
Hf : HasFPowerSeriesOnBall f p x rf
r : â„â‰¥0
r_pos : 0 < r
hr : Summable fun i â†¦ â€–q.compAlongComposition p i.sndâ€–â‚Š * r ^ i.fst
Î´ : â„â‰¥0âˆ
Î´pos : 0 < Î´
hÎ´ : âˆ€ {z : E}, z âˆˆ EMetric.ball x Î´ â†’ f z âˆˆ EMetric.ball (f x) rg
rf' : â„â‰¥0âˆ := min rf Î´
âŠ¢ 0 < rf' âˆ§ True
warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.647827 â†’ ?m.647827
  
  unknown constant 'FormalMultilinearSeries.id.def'
warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
warning:  `List.get_splitWrtComposition` has been deprecated, use `List.getElem_splitWrtComposition` instead
warning:  `List.get_drop'` has been deprecated, use `List.getElem_drop'` instead
warning:  `List.get_take'` has been deprecated, use `List.getElem_take` instead","theorem HasFPowerSeriesAt.comp {g : F â†’ G} {f : E â†’ F} {q : FormalMultilinearSeries ğ•œ F G}
    {p : FormalMultilinearSeries ğ•œ E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) : HasFPowerSeriesAt (g âˆ˜ f) (q.comp p) x ",":= by
  rcases hg with âŸ¨rg, HgâŸ©
  rcases hf with âŸ¨rf, HfâŸ©
  rcases q.comp_summable_nnreal p Hg.radius_pos Hf.radius_pos with âŸ¨r, r_pos : 0 < r, hrâŸ©
  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© :
    âˆƒ Î´ : â„â‰¥0âˆ, 0 < Î´ âˆ§ âˆ€ {z : E}, z âˆˆ EMetric.ball x Î´ â†’ f z âˆˆ EMetric.ball (f x) rg := by
    have : EMetric.ball (f x) rg âˆˆ ğ“ (f x) := EMetric.ball_mem_nhds _ Hg.r_pos
    rcases EMetric.mem_nhds_iff.1 (Hf.analyticAt.continuousAt this) with âŸ¨Î´, Î´pos, HÎ´âŸ©
    exact âŸ¨Î´, Î´pos, fun hz => HÎ´ hzâŸ©
  let rf' := min rf Î´
  have min_pos : 0 < min rf' r := by
    simp only [rf', r_pos, Hf.r_pos, Î´pos, lt_min_iff, ENNReal.coe_pos, and_self_iff]
  refine âŸ¨min rf' r, ?_âŸ©
  refine
    âŸ¨le_trans (min_le_right rf' r) (FormalMultilinearSeries.le_comp_radius_of_summable q p r hr),
      min_pos, @fun y hy => ?_âŸ©
  have y_mem : y âˆˆ EMetric.ball (0 : E) rf :=
    (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_left _ _))) hy
  have fy_mem : f (x + y) âˆˆ EMetric.ball (f x) rg := by
    apply hÎ´
    have : y âˆˆ EMetric.ball (0 : E) Î´ :=
      (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_right _ _))) hy
    simpa [edist_eq_coe_nnnorm_sub, edist_eq_coe_nnnorm]
  have A : Tendsto (fun n => âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y)
      atTop (ğ“ (f (x + y) - f x)) := by
    have L :
      âˆ€á¶  n in atTop, (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x
        = âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y := by
      rw [eventually_atTop]
      refine âŸ¨1, fun n hn => ?_âŸ©
      symm
      rw [eq_sub_iff_add_eq', Finset.range_eq_Ico, â† Hf.coeff_zero fun _i => y,
        Finset.sum_eq_sum_Ico_succ_bot hn]
    have :
      Tendsto (fun n => (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x) atTop
        (ğ“ (f (x + y) - f x)) :=
      (Hf.hasSum y_mem).tendsto_sum_nat.sub tendsto_const_nhds
    exact Tendsto.congr' L this
  have B :
    Tendsto (fun n => q.partialSum n (âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y)) atTop
      (ğ“ (g (f (x + y)))) := by
    have Bâ‚ : ContinuousAt (fun z : F => g (f x + z)) (f (x + y) - f x) := by
      refine ContinuousAt.comp ?_ (continuous_const.add continuous_id).continuousAt
      simp only [add_sub_cancel, _root_.id]
      exact Hg.continuousOn.continuousAt (IsOpen.mem_nhds EMetric.isOpen_ball fy_mem)
    have Bâ‚‚ : f (x + y) - f x âˆˆ EMetric.ball (0 : F) rg := by
      simpa [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub] using fy_mem
    rw [â† EMetric.isOpen_ball.nhdsWithin_eq Bâ‚‚] at A
    convert Hg.tendstoLocallyUniformlyOn.tendsto_comp Bâ‚.continuousWithinAt Bâ‚‚ A
    simp only [add_sub_cancel]
  have C :
    Tendsto
      (fun n => âˆ‘ i âˆˆ compPartialSumTarget 0 n n, q.compAlongComposition p i.2 fun _j => y)
      atTop (ğ“ (g (f (x + y)))) := by
    simpa [comp_partialSum] using B
  have D :
    HasSum (fun i : Î£ n, Composition n => q.compAlongComposition p i.2 fun _j => y)
      (g (f (x + y))) :=
    haveI cau :
      CauchySeq fun s : Finset (Î£ n, Composition n) =>
        âˆ‘ i âˆˆ s, q.compAlongComposition p i.2 fun _j => y := by
      apply cauchySeq_finset_of_norm_bounded _ (NNReal.summable_coe.2 hr) _
      simp only [coe_nnnorm, NNReal.coe_mul, NNReal.coe_pow]
      rintro âŸ¨n, câŸ©
      calc
        â€–(compAlongComposition q p c) fun _j : Fin n => yâ€– â‰¤
            â€–compAlongComposition q p câ€– * âˆ _j : Fin n, â€–yâ€– := by
          apply ContinuousMultilinearMap.le_opNorm
        _ â‰¤ â€–compAlongComposition q p câ€– * (r : â„) ^ n := by
          apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
          rw [Finset.prod_const, Finset.card_fin]
          apply pow_le_pow_left (norm_nonneg _)
          rw [EMetric.mem_ball, edist_eq_coe_nnnorm] at hy
          have := le_trans (le_of_lt hy) (min_le_right _ _)
          rwa [ENNReal.coe_le_coe, â† NNReal.coe_le_coe, coe_nnnorm] at this
    tendsto_nhds_of_cauchySeq_of_subseq cau compPartialSumTarget_tendsto_atTop C
  have E : HasSum (fun n => (q.comp p) n fun _j => y) (g (f (x + y))) := by
    apply D.sigma
    intro n
    dsimp [FormalMultilinearSeries.comp]
    convert hasSum_fintype (Î± := G) (Î² := Composition n) _
    simp only [ContinuousMultilinearMap.sum_apply]
    rfl
  rw [Function.comp_apply]
  exact E","rw [â† hasFPowerSeriesAt_iff_hasFPowerSeriesAt, â† hasFPowerSeriesAt_iff_hasFPowerSeries]"
Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean,Convex.taylor_approx_two_segment,Convex.taylor_approx_two_segment,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  refine' IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun Îµ Îµpos => _) (isBigO_const_mul_self ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) _ _)
  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
  rcases Metric.mem_nhdsWithin_iff.1 (hx Îµpos) with âŸ¨Î´, Î´pos, sÎ´âŸ©
  have E1 : âˆ€á¶  h in ğ“[>] (0 : â„), h * (â€–vâ€– + â€–wâ€–) < Î´ := by
    have : Filter.Tendsto (fun h => h * (â€–vâ€– + â€–wâ€–)) (ğ“[>] (0 : â„)) (ğ“ (0 * (â€–vâ€– + â€–wâ€–))) :=
      (continuous_id.mul continuous_const).continuousWithinAt
    apply (tendsto_order.1 this).2 Î´
    simpa only [zero_mul] using Î´pos
  have E2 : âˆ€á¶  h in ğ“[>] (0 : â„), (h : â„) < 1 :=
    mem_nhdsWithin_Ioi_iff_exists_Ioo_subset.2
      âŸ¨(1 : â„), by simp only [mem_Ioi, zero_lt_one], fun x hx => hx.2âŸ©
  filter_upwards [E1, E2, self_mem_nhdsWithin] with h hÎ´ h_lt_1 hpos
  replace hpos : 0 < h := hpos
  have xt_mem : âˆ€ t âˆˆ Icc (0 : â„) 1, x + h â€¢ v + (t * h) â€¢ w âˆˆ interior s := by
    intro t ht
    have : x + h â€¢ v âˆˆ interior s := s_conv.add_smul_mem_interior xs hv âŸ¨hpos, h_lt_1.leâŸ©
    rw [â† smul_smul]
    apply s_conv.interior.add_smul_mem this _ ht
    rw [add_assoc] at hw
    rw [add_assoc, â† smul_add]
    exact s_conv.add_smul_mem_interior xs hw âŸ¨hpos, h_lt_1.leâŸ©
  let g t :=
    f (x + h â€¢ v + (t * h) â€¢ w) - (t * h) â€¢ f' x w - (t * h ^ 2) â€¢ f'' v w -
      ((t * h) ^ 2 / 2) â€¢ f'' w w
  set g' := fun t =>
    f' (x + h â€¢ v + (t * h) â€¢ w) (h â€¢ w) - h â€¢ f' x w - h ^ 2 â€¢ f'' v w - (t * h ^ 2) â€¢ f'' w w
    with hg'
  have g_deriv : âˆ€ t âˆˆ Icc (0 : â„) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by
    intro t ht
    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]
    Â· refine' (hf _ _).comp_hasDerivWithinAt _ _
      Â· exact xt_mem t ht
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.const_add, HasDerivAt.smul_const,
        hasDerivAt_mul_const]
    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· suffices H : HasDerivWithinAt (fun u => ((u * h) ^ 2 / 2) â€¢ f'' w w)
          ((((2 : â„•) : â„) * (t * h) ^ (2 - 1) * (1 * h) / 2) â€¢ f'' w w) (Icc 0 1) t by
        convert H using 2
        ring
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_id',
        HasDerivAt.pow, HasDerivAt.mul_const]
  have g'_bound : âˆ€ t âˆˆ Ico (0 : â„) 1, â€–g' tâ€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
    intro t ht
    have I : â€–h â€¢ v + (t * h) â€¢ wâ€– â‰¤ h * (â€–vâ€– + â€–wâ€–) :=
      calc
        â€–h â€¢ v + (t * h) â€¢ wâ€– â‰¤ â€–h â€¢ vâ€– + â€–(t * h) â€¢ wâ€– := norm_add_le _ _
        _ = h * â€–vâ€– + t * (h * â€–wâ€–) := by
          simp only [norm_smul, Real.norm_eq_abs, hpos.le, abs_of_nonneg, abs_mul, ht.left,
            mul_assoc]
        _ â‰¤ h * â€–vâ€– + 1 * (h * â€–wâ€–) := by gcongr; exact ht.2.le
        _ = h * (â€–vâ€– + â€–wâ€–) := by ring
    calc
      â€–g' tâ€– = â€–(f' (x + h â€¢ v + (t * h) â€¢ w) - f' x - f'' (h â€¢ v + (t * h) â€¢ w)) (h â€¢ w)â€– := by
        rw [hg']
        have : h * (t * h) = t * (h * h) := by ring
        simp only [ContinuousLinearMap.coe_sub', ContinuousLinearMap.map_add, pow_two,
          ContinuousLinearMap.add_apply, Pi.smul_apply, smul_sub, smul_add, smul_smul, â† sub_sub,
          ContinuousLinearMap.coe_smul', Pi.sub_apply, ContinuousLinearMap.map_smul, this]
      _ â‰¤ â€–f' (x + h â€¢ v + (t * h) â€¢ w) - f' x - f'' (h â€¢ v + (t * h) â€¢ w)â€– * â€–h â€¢ wâ€– :=
        (ContinuousLinearMap.le_opNorm _ _)
      _ â‰¤ Îµ * â€–h â€¢ v + (t * h) â€¢ wâ€– * â€–h â€¢ wâ€– := by
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        have H : x + h â€¢ v + (t * h) â€¢ w âˆˆ Metric.ball x Î´ âˆ© interior s := by
          refine' âŸ¨_, xt_mem t âŸ¨ht.1, ht.2.leâŸ©âŸ©
          rw [add_assoc, add_mem_ball_iff_norm]
          exact I.trans_lt hÎ´
        simpa only [mem_setOf_eq, add_assoc x, add_sub_cancel'] using sÎ´ H
      _ â‰¤ Îµ * (â€–h â€¢ vâ€– + â€–h â€¢ wâ€–) * â€–h â€¢ wâ€– := by
        gcongr
        apply (norm_add_le _ _).trans
        gcongr
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, ht.1, hpos.le, mul_assoc]
        exact mul_le_of_le_one_left (mul_nonneg hpos.le (norm_nonneg _)) ht.2.le
      _ = Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, hpos.le]; ring
  have I : â€–g 1 - g 0â€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
    simpa only [mul_one, sub_zero] using
      norm_image_sub_le_of_norm_deriv_le_segment' g_deriv g'_bound 1 (right_mem_Icc.2 zero_le_one)
  convert I using 1
  Â· congr 1
    simp only [g, Nat.one_ne_zero, add_zero, one_mul, zero_div, zero_mul, sub_zero,
      zero_smul, Ne.def, not_false_iff, bit0_eq_zero, zero_pow]
    abel
  Â· simp only [Real.norm_eq_abs, abs_mul, add_nonneg (norm_nonneg v) (norm_nonneg w), abs_of_nonneg,
      hpos.le, mul_assoc, pow_bit0_abs, norm_nonneg, abs_pow]","warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.159468 â†’ ?m.159468 â†’ Prop
info:  Try this: abel_nf
error:  unsolved goals
case h.e'_3.e_a
E : Type u_1
F : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace â„ E
instâœÂ¹ : NormedAddCommGroup F
instâœ : NormedSpace â„ F
s : Set E
s_conv : Convex â„ s
f : E â†’ F
f' : E â†’ E â†’L[â„] F
f'' : E â†’L[â„] E â†’L[â„] F
hf : âˆ€ x âˆˆ interior s, HasFDerivAt f (f' x) x
x : E
xs : x âˆˆ s
hx : âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ âˆ€á¶  (x_1 : E) in ğ“[interior s] x, â€–f' x_1 - f' x - f'' (x_1 - x)â€– â‰¤ c * â€–x_1 - xâ€–
v w : E
hv : x + v âˆˆ interior s
hw : x + v + w âˆˆ interior s
Îµ : â„
Îµpos : 0 < Îµ
Î´ : â„
Î´pos : Î´ > 0
sÎ´ : Metric.ball x Î´ âˆ© interior s âŠ† {x_1 | (fun x_2 â†¦ â€–f' x_2 - f' x - f'' (x_2 - x)â€– â‰¤ Îµ * â€–x_2 - xâ€–) x_1}
E1 : âˆ€á¶  (h : â„) in ğ“[>] 0, h * (â€–vâ€– + â€–wâ€–) < Î´
E2 : âˆ€á¶  (h : â„) in ğ“[>] 0, h < 1
h : â„
hÎ´ : h * (â€–vâ€– + â€–wâ€–) < Î´
h_lt_1 : h < 1
hpos : 0 < h
xt_mem : âˆ€ t âˆˆ Icc 0 1, x + h â€¢ v + (t * h) â€¢ w âˆˆ interior s
g : â„ â†’ F :=
  fun t â†¦ f (x + h â€¢ v + (t * h) â€¢ w) - (t * h) â€¢ (f' x) w - (t * h ^ 2) â€¢ (f'' v) w - ((t * h) ^ 2 / 2) â€¢ (f'' w) w
g' : â„ â†’ F :=
  fun t â†¦ (f' (x + h â€¢ v + (t * h) â€¢ w)) (h â€¢ w) - h â€¢ (f' x) w - h ^ 2 â€¢ (f'' v) w - (t * h ^ 2) â€¢ (f'' w) w
hg' : g' = fun t â†¦ (f' (x + h â€¢ v + (t * h) â€¢ w)) (h â€¢ w) - h â€¢ (f' x) w - h ^ 2 â€¢ (f'' v) w - (t * h ^ 2) â€¢ (f'' w) w
g_deriv : âˆ€ t âˆˆ Icc 0 1, HasDerivWithinAt g (g' t) (Icc 0 1) t
g'_bound : âˆ€ t âˆˆ Ico 0 1, â€–g' tâ€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2
I : â€–g 1 - g 0â€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2
âŠ¢ f (x + (h â€¢ v + h â€¢ w)) +
      (-1 â€¢ f (x + h â€¢ v) + (-1 â€¢ h â€¢ (f' x) w + (-1 â€¢ h ^ 2 â€¢ (f'' v) w + -1 â€¢ (h ^ 2 / 2) â€¢ (f'' w) w))) =
    f (x + (h â€¢ v + h â€¢ w)) +
      (-1 â€¢ f (x + h â€¢ v) +
        (-1 â€¢ h â€¢ (f' x) w + (-1 â€¢ h ^ 2 â€¢ (f'' v) w + (-1 â€¢ (h ^ 2 / 2) â€¢ (f'' w) w + (0 ^ 2 / 2) â€¢ (f'' w) w))))
error:  unknown identifier 'pow_bit0_abs'","theorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v âˆˆ interior s)
    (hw : x + v + w âˆˆ interior s) :
    (fun h : â„ => f (x + h â€¢ v + h â€¢ w)
        - f (x + h â€¢ v) - h â€¢ f' x w - h ^ 2 â€¢ f'' v w - (h ^ 2 / 2) â€¢ f'' w w) =o[ğ“[>] 0]
      fun h => h ^ 2 ",":= by
  refine IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun Îµ Îµpos => ?_) (isBigO_const_mul_self ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) _ _)
  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
  rcases Metric.mem_nhdsWithin_iff.1 (hx Îµpos) with âŸ¨Î´, Î´pos, sÎ´âŸ©
  have E1 : âˆ€á¶  h in ğ“[>] (0 : â„), h * (â€–vâ€– + â€–wâ€–) < Î´ := by
    have : Filter.Tendsto (fun h => h * (â€–vâ€– + â€–wâ€–)) (ğ“[>] (0 : â„)) (ğ“ (0 * (â€–vâ€– + â€–wâ€–))) :=
      (continuous_id.mul continuous_const).continuousWithinAt
    apply (tendsto_order.1 this).2 Î´
    simpa only [zero_mul] using Î´pos
  have E2 : âˆ€á¶  h in ğ“[>] (0 : â„), (h : â„) < 1 :=
    mem_nhdsWithin_Ioi_iff_exists_Ioo_subset.2
      âŸ¨(1 : â„), by simp only [mem_Ioi, zero_lt_one], fun x hx => hx.2âŸ©
  filter_upwards [E1, E2, self_mem_nhdsWithin] with h hÎ´ h_lt_1 hpos
  replace hpos : 0 < h := hpos
  have xt_mem : âˆ€ t âˆˆ Icc (0 : â„) 1, x + h â€¢ v + (t * h) â€¢ w âˆˆ interior s := by
    intro t ht
    have : x + h â€¢ v âˆˆ interior s := s_conv.add_smul_mem_interior xs hv âŸ¨hpos, h_lt_1.leâŸ©
    rw [â† smul_smul]
    apply s_conv.interior.add_smul_mem this _ ht
    rw [add_assoc] at hw
    rw [add_assoc, â† smul_add]
    exact s_conv.add_smul_mem_interior xs hw âŸ¨hpos, h_lt_1.leâŸ©
  let g t :=
    f (x + h â€¢ v + (t * h) â€¢ w) - (t * h) â€¢ f' x w - (t * h ^ 2) â€¢ f'' v w -
      ((t * h) ^ 2 / 2) â€¢ f'' w w
  set g' := fun t =>
    f' (x + h â€¢ v + (t * h) â€¢ w) (h â€¢ w) - h â€¢ f' x w - h ^ 2 â€¢ f'' v w - (t * h ^ 2) â€¢ f'' w w
    with hg'
  have g_deriv : âˆ€ t âˆˆ Icc (0 : â„) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by
    intro t ht
    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]
    Â· refine (hf _ ?_).comp_hasDerivWithinAt _ ?_
      Â· exact xt_mem t ht
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.const_add, HasDerivAt.smul_const,
        hasDerivAt_mul_const]
    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· suffices H : HasDerivWithinAt (fun u => ((u * h) ^ 2 / 2) â€¢ f'' w w)
          ((((2 : â„•) : â„) * (t * h) ^ (2 - 1) * (1 * h) / 2) â€¢ f'' w w) (Icc 0 1) t by
        convert H using 2
        ring
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_id',
        HasDerivAt.pow, HasDerivAt.mul_const]
  have g'_bound : âˆ€ t âˆˆ Ico (0 : â„) 1, â€–g' tâ€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
    intro t ht
    have I : â€–h â€¢ v + (t * h) â€¢ wâ€– â‰¤ h * (â€–vâ€– + â€–wâ€–) :=
      calc
        â€–h â€¢ v + (t * h) â€¢ wâ€– â‰¤ â€–h â€¢ vâ€– + â€–(t * h) â€¢ wâ€– := norm_add_le _ _
        _ = h * â€–vâ€– + t * (h * â€–wâ€–) := by
          simp only [norm_smul, Real.norm_eq_abs, hpos.le, abs_of_nonneg, abs_mul, ht.left,
            mul_assoc]
        _ â‰¤ h * â€–vâ€– + 1 * (h * â€–wâ€–) := by gcongr; exact ht.2.le
        _ = h * (â€–vâ€– + â€–wâ€–) := by ring
    calc
      â€–g' tâ€– = â€–(f' (x + h â€¢ v + (t * h) â€¢ w) - f' x - f'' (h â€¢ v + (t * h) â€¢ w)) (h â€¢ w)â€– := by
        rw [hg']
        have : h * (t * h) = t * (h * h) := by ring
        simp only [ContinuousLinearMap.coe_sub', ContinuousLinearMap.map_add, pow_two,
          ContinuousLinearMap.add_apply, Pi.smul_apply, smul_sub, smul_add, smul_smul, â† sub_sub,
          ContinuousLinearMap.coe_smul', Pi.sub_apply, ContinuousLinearMap.map_smul, this]
      _ â‰¤ â€–f' (x + h â€¢ v + (t * h) â€¢ w) - f' x - f'' (h â€¢ v + (t * h) â€¢ w)â€– * â€–h â€¢ wâ€– :=
        (ContinuousLinearMap.le_opNorm _ _)
      _ â‰¤ Îµ * â€–h â€¢ v + (t * h) â€¢ wâ€– * â€–h â€¢ wâ€– := by
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        have H : x + h â€¢ v + (t * h) â€¢ w âˆˆ Metric.ball x Î´ âˆ© interior s := by
          refine âŸ¨?_, xt_mem t âŸ¨ht.1, ht.2.leâŸ©âŸ©
          rw [add_assoc, add_mem_ball_iff_norm]
          exact I.trans_lt hÎ´
        simpa only [mem_setOf_eq, add_assoc x, add_sub_cancel_left] using sÎ´ H
      _ â‰¤ Îµ * (â€–h â€¢ vâ€– + â€–h â€¢ wâ€–) * â€–h â€¢ wâ€– := by
        gcongr
        apply (norm_add_le _ _).trans
        gcongr
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, ht.1, hpos.le, mul_assoc]
        exact mul_le_of_le_one_left (mul_nonneg hpos.le (norm_nonneg _)) ht.2.le
      _ = Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, hpos.le]; ring
  have I : â€–g 1 - g 0â€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
    simpa only [mul_one, sub_zero] using
      norm_image_sub_le_of_norm_deriv_le_segment' g_deriv g'_bound 1 (right_mem_Icc.2 zero_le_one)
  convert I using 1
  Â· congr 1
    simp only [g, Nat.one_ne_zero, add_zero, one_mul, zero_div, zero_mul, sub_zero,
      zero_smul, Ne, not_false_iff, bit0_eq_zero, zero_pow]
    abel
  Â· simp only [Real.norm_eq_abs, abs_mul, add_nonneg (norm_nonneg v) (norm_nonneg w), abs_of_nonneg,
      hpos.le, mul_assoc, norm_nonneg, abs_pow]","simp only [Convex.taylor_approx_two_segment, Convex.taylor_approx_two_segment]"
Mathlib/Topology/Perfect.lean,exists_perfect_nonempty_of_isClosed_of_not_countable,exists_perfect_nonempty_of_isClosed_of_not_countable,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with âŸ¨V, D, Vct, Dperf, VDâŸ©
  refine âŸ¨D, âŸ¨Dperf, ?_âŸ©âŸ©
  constructor
  Â· rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right _ _","error:  function expected at
  subset_union_right ?m.8728
term has type
  ?m.8727 âˆˆ ?m.8725 âˆª ?m.8726","theorem exists_perfect_nonempty_of_isClosed_of_not_countable [SecondCountableTopology Î±]
    (hclosed : IsClosed C) (hunc : Â¬C.Countable) : âˆƒ D : Set Î±, Perfect D âˆ§ D.Nonempty âˆ§ D âŠ† C ",":= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with âŸ¨V, D, Vct, Dperf, VDâŸ©
  refine âŸ¨D, âŸ¨Dperf, ?_âŸ©âŸ©
  constructor
  Â· rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right",rw [exists_perfect_nonempty_of_isClosed_of_not_countable] at hunc
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine' âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, _âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, âŸ¨_, _, _âŸ©, _âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Î¼ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 âˆˆ ?m.116759 âˆª ?m.116760","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Î¼ : Measure Î±)
    [IsFiniteMeasure Î¼] (f : Î± â†’ Set â„) (s : Set Î±)
    (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty) :
    âˆƒ t : Set (Î± Ã— â„), t.Countable âˆ§ (âˆ€ p âˆˆ t, p.1 âˆˆ s) âˆ§ (âˆ€ p âˆˆ t, p.2 âˆˆ f p.1) âˆ§
      Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) = 0 âˆ§
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, ?_âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, âŸ¨?_, ?_, ?_âŸ©, ?_âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Î¼ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",rw [exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux]
Mathlib/Algebra/DirectLimit.lean,AddCommGroup.DirectLimit.map_comp,map_comp,af1e1921fa808d9f4d24fd674214116943e9fbb8,":=
  FunLike.ext _ _ fun x â†¦ (isEmpty_or_nonempty Î¹).elim (fun _ â†¦ Subsingleton.elim _ _) fun _ â†¦
    x.induction_on fun i g â†¦ by simp",error:  unknown constant 'FunLike.ext',"lemma map_comp [IsDirected Î¹ (Â· â‰¤ Â·)]
    (gâ‚ : (i : Î¹) â†’ G i â†’â‚—[R] G' i) (gâ‚‚ : (i : Î¹) â†’ G' i â†’â‚—[R] G'' i)
    (hgâ‚ : âˆ€ i j h, gâ‚ j âˆ˜â‚— f i j h = f' i j h âˆ˜â‚— gâ‚ i)
    (hgâ‚‚ : âˆ€ i j h, gâ‚‚ j âˆ˜â‚— f' i j h = f'' i j h âˆ˜â‚— gâ‚‚ i) :
    (map gâ‚‚ hgâ‚‚ âˆ˜â‚— map gâ‚ hgâ‚ :
      DirectLimit G f â†’â‚—[R] DirectLimit G'' f'') =
    (map (fun i â†¦ gâ‚‚ i âˆ˜â‚— gâ‚ i) fun i j h â†¦ by
        rw [LinearMap.comp_assoc, hgâ‚ i, â† LinearMap.comp_assoc, hgâ‚‚ i, LinearMap.comp_assoc] :
      DirectLimit G f â†’â‚—[R] DirectLimit G'' f'') ",":=
  DFunLike.ext _ _ fun x â†¦ (isEmpty_or_nonempty Î¹).elim (fun _ â†¦ Subsingleton.elim _ _) fun _ â†¦
    x.induction_on fun i g â†¦ by simp","dsimp [LinearMap.comp_assoc, LinearMap.comp_assoc]"
Mathlib/Data/List/OfFn.lean,List.ofFn_succ,ofFn_succ,66caaeed4dccada03ce195a3f9db1c0009ee8118,":=
  ext_get (by simp) (fun i hiâ‚ hiâ‚‚ => by
    cases i
    Â· simp; rfl
    Â· simp)","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_ofFn` has been deprecated, use `List.get_ofFn` instead
error:  no goals to be solved
warning:  `List.nthLe` has been deprecated, use `List.get` instead",theorem ofFn_succ {n} (f : Fin (succ n) â†’ Î±) : ofFn f = f 0 :: ofFn fun i => f i.succ ,":=
  ext_get (by simp) (fun i hiâ‚ hiâ‚‚ => by
    cases i
    Â· simp
    Â· simp)","rw [ofFn_succ, ofFn_succ]"
Mathlib/GroupTheory/GroupAction/Blocks.lean,MulAction.IsPartition.of_orbits,IsPartition.of_orbits,90ee4adef4081d5ea59d0008022888ad5b93d012,":= by
  constructor
  Â· rintro âŸ¨a, ha : orbit G a = âˆ…âŸ©
    exact Set.Nonempty.ne_empty (MulAction.orbit_nonempty a) ha
  intro a; use orbit G a
  constructor
  Â· simp only [Set.mem_range_self, mem_orbit_self, exists_unique_iff_exists, exists_true_left]
  Â· simp only [Set.mem_range, exists_unique_iff_exists, exists_prop, and_imp, forall_exists_index,
      forall_apply_eq_imp_iff']
    rintro B b âŸ¨rflâŸ© ha
    apply symm
    rw [orbit_eq_iff]
    exact ha","error:  unsolved goals
case h.left
G : Type u_1
instâœÂ¹ : Group G
X : Type u_2
instâœ : MulAction G X
a : X
âŠ¢ True âˆ§ True","theorem IsPartition.of_orbits :
    Setoid.IsPartition (Set.range fun a : X => orbit G a) ",":= by
  apply orbit.pairwiseDisjoint.isPartition_of_exists_of_ne_empty
  Â· intro x
    exact âŸ¨_, âŸ¨x, rflâŸ©, mem_orbit_self xâŸ©
  Â· rintro âŸ¨a, ha : orbit G a = âˆ…âŸ©
    exact (MulAction.orbit_nonempty a).ne_empty ha",refine IsPartition.of_orbits (fun a â†¦ ?_)
Mathlib/Analysis/Calculus/ContDiff/Bounds.lean,norm_iteratedFDerivWithin_comp_le_aux,norm_iteratedFDerivWithin_comp_le_aux,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  induction' n using Nat.case_strong_induction_on with n IH generalizing Gu
  Â· simpa [norm_iteratedFDerivWithin_zero, Nat.factorial_zero, algebraMap.coe_one, one_mul,
      pow_zero, mul_one, comp_apply] using hC 0 le_rfl
  have M : (n : â„•âˆ) < n.succ := Nat.cast_lt.2 n.lt_succ_self
  have Cnonneg : 0 â‰¤ C := (norm_nonneg _).trans (hC 0 bot_le)
  have Dnonneg : 0 â‰¤ D := by
    have : 1 â‰¤ n + 1 := by simp only [le_add_iff_nonneg_left, zero_le']
    simpa only [pow_one] using (norm_nonneg _).trans (hD 1 le_rfl this)
  have I : âˆ€ i âˆˆ Finset.range (n + 1),
      â€–iteratedFDerivWithin ğ•œ i (fderivWithin ğ•œ g t âˆ˜ f) s xâ€– â‰¤ i ! * C * D ^ i := by
    intro i hi
    simp only [Finset.mem_range_succ_iff] at hi
    apply IH i hi
    Â· apply hg.fderivWithin ht
      simp only [Nat.cast_succ]
      exact add_le_add_right (Nat.cast_le.2 hi) _
    Â· apply hf.of_le (Nat.cast_le.2 (hi.trans n.le_succ))
    Â· intro j hj
      have : â€–iteratedFDerivWithin ğ•œ j (fderivWithin ğ•œ g t) t (f x)â€– =
          â€–iteratedFDerivWithin ğ•œ (j + 1) g t (f x)â€– :=
        by rw [iteratedFDerivWithin_succ_eq_comp_right ht (hst hx), comp_apply,
          LinearIsometryEquiv.norm_map]
      rw [this]
      exact hC (j + 1) (add_le_add (hj.trans hi) le_rfl)
    Â· intro j hj h'j
      exact hD j hj (h'j.trans (hi.trans n.le_succ))
  have J : âˆ€ i, â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– â‰¤ D ^ (n - i + 1) := by
    intro i
    have : â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– =
        â€–iteratedFDerivWithin ğ•œ (n - i + 1) f s xâ€– := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply, LinearIsometryEquiv.norm_map]
    rw [this]
    apply hD
    Â· simp only [le_add_iff_nonneg_left, zero_le']
    Â· apply Nat.succ_le_succ tsub_le_self
  calc
    â€–iteratedFDerivWithin ğ•œ (n + 1) (g âˆ˜ f) s xâ€– =
        â€–iteratedFDerivWithin ğ•œ n (fun y : E => fderivWithin ğ•œ (g âˆ˜ f) s y) s xâ€– := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply,
        LinearIsometryEquiv.norm_map]
    _ = â€–iteratedFDerivWithin ğ•œ n (fun y : E => ContinuousLinearMap.compL ğ•œ E Fu Gu
        (fderivWithin ğ•œ g t (f y)) (fderivWithin ğ•œ f s y)) s xâ€– := by
      have L : (1 : â„•âˆ) â‰¤ n.succ := by simpa only [ENat.coe_one, Nat.one_le_cast] using n.succ_pos
      congr 1
      refine' iteratedFDerivWithin_congr (fun y hy => _) hx _
      apply fderivWithin.comp _ _ _ hst (hs y hy)
      Â· exact hg.differentiableOn L _ (hst hy)
      Â· exact hf.differentiableOn L _ hy
    _ â‰¤ âˆ‘ i in Finset.range (n + 1),
        (n.choose i : â„) * â€–iteratedFDerivWithin ğ•œ i (fderivWithin ğ•œ g t âˆ˜ f) s xâ€– *
          â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– := by
      have A : ContDiffOn ğ•œ n (fderivWithin ğ•œ g t âˆ˜ f) s := by
        apply ContDiffOn.comp _ (hf.of_le M.le) hst
        apply hg.fderivWithin ht
        simp only [Nat.cast_succ, le_refl]
      have B : ContDiffOn ğ•œ n (fderivWithin ğ•œ f s) s := by
        apply hf.fderivWithin hs
        simp only [Nat.cast_succ, le_refl]
      exact (ContinuousLinearMap.compL ğ•œ E Fu Gu).norm_iteratedFDerivWithin_le_of_bilinear_of_le_one
        A B hs hx le_rfl (ContinuousLinearMap.norm_compL_le ğ•œ E Fu Gu)
    _ â‰¤ âˆ‘ i in Finset.range (n + 1), (n.choose i : â„) * (i ! * C * D ^ i) * D ^ (n - i + 1) := by
      gcongr with i hi
      Â· simp only [mul_assoc (n.choose i : â„)]
        exact I i hi
      Â· exact J i
    _ = âˆ‘ i in Finset.range (n + 1),
        (n ! : â„) * ((i ! : â„)â»Â¹ * i !) * C * (D ^ i * D ^ (n - i + 1)) * ((n - i)! : â„)â»Â¹ := by
      congr! 1 with i hi
      simp only [Nat.cast_choose â„ (Finset.mem_range_succ_iff.1 hi), div_eq_inv_mul, mul_inv]
      ring
    _ = âˆ‘ i in Finset.range (n + 1), (n ! : â„) * 1 * C * D ^ (n + 1) * ((n - i)! : â„)â»Â¹ := by
      congr! with i hi
      Â· apply inv_mul_cancel
        simpa only [Ne, Nat.cast_eq_zero] using i.factorial_ne_zero
      Â· rw [â† pow_add]
        congr 1
        rw [Nat.add_succ, Nat.succ_inj']
        exact Nat.add_sub_of_le (Finset.mem_range_succ_iff.1 hi)
    _ â‰¤ âˆ‘ i in Finset.range (n + 1), (n ! : â„) * 1 * C * D ^ (n + 1) * 1 := by
      gcongr with i
      apply inv_le_one
      simpa only [Nat.one_le_cast] using (n - i).factorial_pos
    _ = (n + 1)! * C * D ^ (n + 1) := by
      simp only [mul_assoc, mul_one, Finset.sum_const, Finset.card_range, nsmul_eq_mul,
        Nat.factorial_succ, Nat.cast_mul]",error:  simp made no progress,"theorem norm_iteratedFDerivWithin_comp_le_aux {Fu Gu : Type u} [NormedAddCommGroup Fu]
    [NormedSpace ğ•œ Fu] [NormedAddCommGroup Gu] [NormedSpace ğ•œ Gu] {g : Fu â†’ Gu} {f : E â†’ Fu} {n : â„•}
    {s : Set E} {t : Set Fu} {x : E} (hg : ContDiffOn ğ•œ n g t) (hf : ContDiffOn ğ•œ n f s)
    (ht : UniqueDiffOn ğ•œ t) (hs : UniqueDiffOn ğ•œ s) (hst : MapsTo f s t) (hx : x âˆˆ s) {C : â„}
    {D : â„} (hC : âˆ€ i, i â‰¤ n â†’ â€–iteratedFDerivWithin ğ•œ i g t (f x)â€– â‰¤ C)
    (hD : âˆ€ i, 1 â‰¤ i â†’ i â‰¤ n â†’ â€–iteratedFDerivWithin ğ•œ i f s xâ€– â‰¤ D ^ i) :
    â€–iteratedFDerivWithin ğ•œ n (g âˆ˜ f) s xâ€– â‰¤ n ! * C * D ^ n ",":= by
  induction' n using Nat.case_strong_induction_on with n IH generalizing Gu
  Â· simpa [norm_iteratedFDerivWithin_zero, Nat.factorial_zero, algebraMap.coe_one, one_mul,
      pow_zero, mul_one, comp_apply] using hC 0 le_rfl
  have M : (n : â„•âˆ) < n.succ := Nat.cast_lt.2 n.lt_succ_self
  have Cnonneg : 0 â‰¤ C := (norm_nonneg _).trans (hC 0 bot_le)
  have Dnonneg : 0 â‰¤ D := by
    have : 1 â‰¤ n + 1 := by simp only [le_add_iff_nonneg_left, zero_le']
    simpa only [pow_one] using (norm_nonneg _).trans (hD 1 le_rfl this)
  have I : âˆ€ i âˆˆ Finset.range (n + 1),
      â€–iteratedFDerivWithin ğ•œ i (fderivWithin ğ•œ g t âˆ˜ f) s xâ€– â‰¤ i ! * C * D ^ i := by
    intro i hi
    simp only [Finset.mem_range_succ_iff] at hi
    apply IH i hi
    Â· apply hg.fderivWithin ht
      simp only [Nat.cast_succ]
      exact add_le_add_right (Nat.cast_le.2 hi) _
    Â· apply hf.of_le (Nat.cast_le.2 (hi.trans n.le_succ))
    Â· intro j hj
      have : â€–iteratedFDerivWithin ğ•œ j (fderivWithin ğ•œ g t) t (f x)â€– =
          â€–iteratedFDerivWithin ğ•œ (j + 1) g t (f x)â€– := by
        rw [iteratedFDerivWithin_succ_eq_comp_right ht (hst hx), comp_apply,
          LinearIsometryEquiv.norm_map]
      rw [this]
      exact hC (j + 1) (add_le_add (hj.trans hi) le_rfl)
    Â· intro j hj h'j
      exact hD j hj (h'j.trans (hi.trans n.le_succ))
  have J : âˆ€ i, â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– â‰¤ D ^ (n - i + 1) := by
    intro i
    have : â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– =
        â€–iteratedFDerivWithin ğ•œ (n - i + 1) f s xâ€– := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply, LinearIsometryEquiv.norm_map]
    rw [this]
    apply hD
    Â· simp only [le_add_iff_nonneg_left, zero_le']
    Â· apply Nat.succ_le_succ tsub_le_self
  calc
    â€–iteratedFDerivWithin ğ•œ (n + 1) (g âˆ˜ f) s xâ€– =
        â€–iteratedFDerivWithin ğ•œ n (fun y : E => fderivWithin ğ•œ (g âˆ˜ f) s y) s xâ€– := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply,
        LinearIsometryEquiv.norm_map]
    _ = â€–iteratedFDerivWithin ğ•œ n (fun y : E => ContinuousLinearMap.compL ğ•œ E Fu Gu
        (fderivWithin ğ•œ g t (f y)) (fderivWithin ğ•œ f s y)) s xâ€– := by
      have L : (1 : â„•âˆ) â‰¤ n.succ := by simpa only [ENat.coe_one, Nat.one_le_cast] using n.succ_pos
      congr 1
      refine iteratedFDerivWithin_congr (fun y hy => ?_) hx _
      apply fderivWithin.comp _ _ _ hst (hs y hy)
      Â· exact hg.differentiableOn L _ (hst hy)
      Â· exact hf.differentiableOn L _ hy
    _ â‰¤ âˆ‘ i âˆˆ Finset.range (n + 1),
        (n.choose i : â„) * â€–iteratedFDerivWithin ğ•œ i (fderivWithin ğ•œ g t âˆ˜ f) s xâ€– *
          â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– := by
      have A : ContDiffOn ğ•œ n (fderivWithin ğ•œ g t âˆ˜ f) s := by
        apply ContDiffOn.comp _ (hf.of_le M.le) hst
        apply hg.fderivWithin ht
        simp only [Nat.cast_succ, le_refl]
      have B : ContDiffOn ğ•œ n (fderivWithin ğ•œ f s) s := by
        apply hf.fderivWithin hs
        simp only [Nat.cast_succ, le_refl]
      exact (ContinuousLinearMap.compL ğ•œ E Fu Gu).norm_iteratedFDerivWithin_le_of_bilinear_of_le_one
        A B hs hx le_rfl (ContinuousLinearMap.norm_compL_le ğ•œ E Fu Gu)
    _ â‰¤ âˆ‘ i âˆˆ Finset.range (n + 1), (n.choose i : â„) * (i ! * C * D ^ i) * D ^ (n - i + 1) := by
      gcongr with i hi
      Â· exact I i hi
      Â· exact J i
    _ = âˆ‘ i âˆˆ Finset.range (n + 1),
        (n ! : â„) * ((i ! : â„)â»Â¹ * i !) * C * (D ^ i * D ^ (n - i + 1)) * ((n - i)! : â„)â»Â¹ := by
      congr! 1 with i hi
      simp only [Nat.cast_choose â„ (Finset.mem_range_succ_iff.1 hi), div_eq_inv_mul, mul_inv]
      ring
    _ = âˆ‘ i âˆˆ Finset.range (n + 1), (n ! : â„) * 1 * C * D ^ (n + 1) * ((n - i)! : â„)â»Â¹ := by
      congr! with i hi
      Â· apply inv_mul_cancel
        simpa only [Ne, Nat.cast_eq_zero] using i.factorial_ne_zero
      Â· rw [â† pow_add]
        congr 1
        rw [Nat.add_succ, Nat.succ_inj']
        exact Nat.add_sub_of_le (Finset.mem_range_succ_iff.1 hi)
    _ â‰¤ âˆ‘ i âˆˆ Finset.range (n + 1), (n ! : â„) * 1 * C * D ^ (n + 1) * 1 := by
      gcongr with i
      apply inv_le_one
      simpa only [Nat.one_le_cast] using (n - i).factorial_pos
    _ = (n + 1)! * C * D ^ (n + 1) := by
      simp only [mul_assoc, mul_one, Finset.sum_const, Finset.card_range, nsmul_eq_mul,
        Nat.factorial_succ, Nat.cast_mul]","simp only [norm_iteratedFDerivWithin_comp_le_aux, norm_iteratedFDerivWithin_comp_le_aux]"
Mathlib/Data/Fin/Basic.lean,Fin.one_lt_last,one_lt_last,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,:= (lt_add_iff_pos_left 1).mpr (NeZero.pos n),"error:  unknown identifier 'lt_add_iff_pos_left'
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Fin.val_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated",theorem one_lt_last [NeZero n] : 1 < last (n + 1) ,":= by
  rw [lt_iff_val_lt_val, val_one, val_last, Nat.lt_add_left_iff_pos, Nat.pos_iff_ne_zero]
  exact NeZero.ne n",apply lt_of_le_of_lt (NeZero.ne n)
Mathlib/MeasureTheory/Measure/Haar/Quotient.lean,QuotientGroup.integral_mul_eq_integral_automorphize_mul,QuotientGroup.integral_mul_eq_integral_automorphize_mul,01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  let Ï€ : G â†’ G â§¸ Î“ := QuotientGroup.mk
  have meas_Ï€ : Measurable Ï€ := continuous_quotient_mk'.measurable
  have Hâ‚€ : QuotientGroup.automorphize ((g âˆ˜ Ï€) * f) = g * (QuotientGroup.automorphize f) := by
    exact QuotientGroup.automorphize_smul_left f g
  calc âˆ« (x : G), g (Ï€ x) * (f x) âˆ‚Î¼ =
        âˆ« (x : G â§¸ Î“), QuotientGroup.automorphize ((g âˆ˜ Ï€) * f) x âˆ‚Î¼_ğ“• := ?_
    _ = âˆ« (x : G â§¸ Î“), g x * (QuotientGroup.automorphize f x) âˆ‚Î¼_ğ“• := by simp [Hâ‚€]
  have Hâ‚ : Integrable ((g âˆ˜ Ï€) * f) Î¼
  Â· have : AEStronglyMeasurable (fun (x : G) â†¦ g (x : (G â§¸ Î“))) Î¼
    Â· refine (AEStronglyMeasurable.mono' hg ?_).comp_measurable meas_Ï€
      exact hğ“•.absolutelyContinuous_map
    refine Integrable.essSup_smul f_â„’_1 this ?_
    have hg' : AEStronglyMeasurable (fun x â†¦ (â€–g xâ€–â‚Š : â„â‰¥0âˆ)) Î¼_ğ“• :=
      (ENNReal.continuous_coe.comp continuous_nnnorm).comp_aestronglyMeasurable hg
    rw [â† essSup_comp_quotientGroup_mk hğ“• hg'.aemeasurable]
    exact g_â„’_infinity
  have Hâ‚‚ : AEStronglyMeasurable (QuotientGroup.automorphize ((g âˆ˜ Ï€) * f)) Î¼_ğ“•
  Â· simp_rw [Hâ‚€]
    exact hg.mul F_ae_measurable
  apply QuotientGroup.integral_eq_integral_automorphize hğ“• Hâ‚ Hâ‚‚","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
G : Type u_1
instâœÂ¹â° : Group G
instâœâ¹ : MeasurableSpace G
instâœâ¸ : TopologicalSpace G
instâœâ· : TopologicalGroup G
instâœâ¶ : BorelSpace G
Î¼ : Measure G
Î“ : Subgroup G
ğ“• : Set G
hğ“• : IsFundamentalDomain (â†¥Î“.op) ğ“• Î¼
instâœâµ : Countable â†¥Î“
instâœâ´ : MeasurableSpace (G â§¸ Î“)
instâœÂ³ : BorelSpace (G â§¸ Î“)
K : Type u_2
instâœÂ² : NormedField K
instâœÂ¹ : NormedSpace â„ K
instâœ : Î¼.IsMulRightInvariant
f : G â†’ K
f_â„’_1 : Integrable f Î¼
g : G â§¸ Î“ â†’ K
hg : AEStronglyMeasurable g (Measure.map mk (Î¼.restrict ğ“•))
g_â„’_infinity : essSup (fun x â†¦ â†‘â€–g xâ€–â‚Š) (Measure.map mk (Î¼.restrict ğ“•)) â‰  âŠ¤
F_ae_measurable : AEStronglyMeasurable (automorphize f) (Measure.map mk (Î¼.restrict ğ“•))
Ï€ : G â†’ G â§¸ Î“ := mk
meas_Ï€ : Measurable Ï€
Hâ‚€ : automorphize (g âˆ˜ Ï€ * f) = g * automorphize f
Hâ‚ : Integrable (g âˆ˜ Ï€ * f) Î¼
âŠ¢ âˆ« (x : G), g (Ï€ x) * f x âˆ‚Î¼ = âˆ« (x : G â§¸ Î“), automorphize (g âˆ˜ Ï€ * f) x âˆ‚Measure.map mk (Î¼.restrict ğ“•)","lemma QuotientGroup.integral_mul_eq_integral_automorphize_mul {K : Type*} [NormedField K]
    [NormedSpace â„ K] [Î¼.IsMulRightInvariant] {f : G â†’ K}
    (f_â„’_1 : Integrable f Î¼) {g : G â§¸ Î“ â†’ K} (hg : AEStronglyMeasurable g Î¼_ğ“•)
    (g_â„’_infinity : essSup (fun x â†¦ â†‘â€–g xâ€–â‚Š) Î¼_ğ“• â‰  âˆ)
    (F_ae_measurable : AEStronglyMeasurable (QuotientGroup.automorphize f) Î¼_ğ“•) :
    âˆ« x : G, g (x : G â§¸ Î“) * (f x) âˆ‚Î¼
      = âˆ« x : G â§¸ Î“, g x * (QuotientGroup.automorphize f x) âˆ‚Î¼_ğ“• ",":= by
  let Ï€ : G â†’ G â§¸ Î“ := QuotientGroup.mk
  have meas_Ï€ : Measurable Ï€ := continuous_quotient_mk'.measurable
  have Hâ‚€ : QuotientGroup.automorphize ((g âˆ˜ Ï€) * f) = g * (QuotientGroup.automorphize f) := by
    exact QuotientGroup.automorphize_smul_left f g
  calc âˆ« (x : G), g (Ï€ x) * (f x) âˆ‚Î¼ =
        âˆ« (x : G â§¸ Î“), QuotientGroup.automorphize ((g âˆ˜ Ï€) * f) x âˆ‚Î¼_ğ“• := ?_
    _ = âˆ« (x : G â§¸ Î“), g x * (QuotientGroup.automorphize f x) âˆ‚Î¼_ğ“• := by simp [Hâ‚€]
  have Hâ‚ : Integrable ((g âˆ˜ Ï€) * f) Î¼ := by
    have : AEStronglyMeasurable (fun (x : G) â†¦ g (x : (G â§¸ Î“))) Î¼ :=
      (hg.mono_ac hğ“•.absolutelyContinuous_map).comp_measurable meas_Ï€
    refine Integrable.essSup_smul f_â„’_1 this ?_
    have hg' : AEStronglyMeasurable (fun x â†¦ (â€–g xâ€–â‚Š : â„â‰¥0âˆ)) Î¼_ğ“• :=
      (ENNReal.continuous_coe.comp continuous_nnnorm).comp_aestronglyMeasurable hg
    rw [â† essSup_comp_quotientGroup_mk hğ“• hg'.aemeasurable]
    exact g_â„’_infinity
  have Hâ‚‚ : AEStronglyMeasurable (QuotientGroup.automorphize ((g âˆ˜ Ï€) * f)) Î¼_ğ“• := by
    simp_rw [Hâ‚€]
    exact hg.mul F_ae_measurable
  apply QuotientGroup.integral_eq_integral_automorphize hğ“• Hâ‚ Hâ‚‚","simp only [QuotientGroup.automorphize_automorphize, QuotientGroup.automorphize_automorphize,
  QuotientGroup.automorphize_automorphize]"
Mathlib/Analysis/Convex/Caratheodory.lean,convexHull_eq_union,convexHull_eq_union,6b5a6157526632a0d26108670d5a71f9223c87fd,":= by
  apply Set.Subset.antisymm
  Â· intro x hx
    simp only [exists_prop, Set.mem_unionáµ¢]
    exact âŸ¨Caratheodory.minCardFinsetOfMemConvexHull hx,
      Caratheodory.minCardFinsetOfMemConvexHull_subseteq hx,
      Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull hx,
      Caratheodory.mem_minCardFinsetOfMemConvexHull hxâŸ©
  Â· iterate 3 convert Set.unionáµ¢_subset _; intro
    exact convexHull_mono â€¹_â€º","error:  unknown constant 'Set.mem_unionáµ¢'
error:  simp made no progress
error:  unknown constant 'Set.unionáµ¢_subset'
error:  no goals to be solved","theorem convexHull_eq_union : convexHull ğ•œ s =
    â‹ƒ (t : Finset E) (hss : â†‘t âŠ† s) (hai : AffineIndependent ğ•œ ((â†‘) : t â†’ E)), convexHull ğ•œ â†‘t ",":= by
  apply Set.Subset.antisymm
  Â· intro x hx
    simp only [exists_prop, Set.mem_iUnion]
    exact âŸ¨Caratheodory.minCardFinsetOfMemConvexHull hx,
      Caratheodory.minCardFinsetOfMemConvexHull_subseteq hx,
      Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull hx,
      Caratheodory.mem_minCardFinsetOfMemConvexHull hxâŸ©
  Â· iterate 3 convert Set.iUnion_subset _; intro
    exact convexHull_mono â€¹_â€º",rw [convexHull_eq_union]
Mathlib/Topology/Algebra/Group/Basic.lean,TopologicalGroup.exists_antitone_basis_nhds_one,TopologicalGroup.exists_antitone_basis_nhds_one,9f9d83a281e21565e06f284c1cf7e46e6c0ad35c,":= by
  rcases(ğ“ (1 : G)).exists_antitone_basis with âŸ¨u, hu, u_antiâŸ©
  have :=
    ((hu.prod_nhds hu).tendsto_iff hu).mp
      (by simpa only [mul_one] using continuous_mul.tendsto ((1, 1) : G Ã— G))
  simp only [and_self_iff, mem_prod, and_imp, Prod.forall, exists_true_left, Prod.exists,
    forall_true_left] at this
  have event_mul : âˆ€ n : â„•, âˆ€á¶  m in atTop, u m * u m âŠ† u n := by
    intro n
    rcases this n with âŸ¨j, k, -, hâŸ©
    refine' atTop_basis.eventually_iff.mpr âŸ¨max j k, True.intro, fun m hm => _âŸ©
    rintro - âŸ¨a, b, ha, hb, rflâŸ©
    exact h a b (u_anti ((le_max_left _ _).trans hm) ha) (u_anti ((le_max_right _ _).trans hm) hb)
  obtain âŸ¨Ï†, -, hÏ†, Ï†_anti_basisâŸ© := HasAntitoneBasis.subbasis_with_rel âŸ¨hu, u_antiâŸ© event_mul
  exact âŸ¨u âˆ˜ Ï†, Ï†_anti_basis, fun n => hÏ† n.lt_succ_selfâŸ©","error:  application type mismatch
  h a b
argument
  b
has type
  a âˆˆ u m : Prop
but is expected to have type
  G : Type w
error:  application type mismatch
  u_anti (LE.le.trans (le_max_left j k) hm) ha
argument
  ha
has type
  G : Type w
but is expected to have type
  a âˆˆ u m : Prop","theorem TopologicalGroup.exists_antitone_basis_nhds_one :
    âˆƒ u : â„• â†’ Set G, (ğ“ 1).HasAntitoneBasis u âˆ§ âˆ€ n, u (n + 1) * u (n + 1) âŠ† u n ",":= by
  rcases (ğ“ (1 : G)).exists_antitone_basis with âŸ¨u, hu, u_antiâŸ©
  have :=
    ((hu.prod_nhds hu).tendsto_iff hu).mp
      (by simpa only [mul_one] using continuous_mul.tendsto ((1, 1) : G Ã— G))
  simp only [and_self_iff, mem_prod, and_imp, Prod.forall, exists_true_left, Prod.exists,
    forall_true_left] at this
  have event_mul : âˆ€ n : â„•, âˆ€á¶  m in atTop, u m * u m âŠ† u n := by
    intro n
    rcases this n with âŸ¨j, k, -, hâŸ©
    refine atTop_basis.eventually_iff.mpr âŸ¨max j k, True.intro, fun m hm => ?_âŸ©
    rintro - âŸ¨a, ha, b, hb, rflâŸ©
    exact h a b (u_anti ((le_max_left _ _).trans hm) ha) (u_anti ((le_max_right _ _).trans hm) hb)
  obtain âŸ¨Ï†, -, hÏ†, Ï†_anti_basisâŸ© := HasAntitoneBasis.subbasis_with_rel âŸ¨hu, u_antiâŸ© event_mul
  exact âŸ¨u âˆ˜ Ï†, Ï†_anti_basis, fun n => hÏ† n.lt_succ_selfâŸ©","rcases TopologicalGroup.exists_antitone_basis_nhds_one with
  âŸ¨u, huâŸ©"
Mathlib/Topology/UniformSpace/Ascoli.lean,EquicontinuousOn.tendsto_uniformOnFun_iff_pi',EquicontinuousOn.tendsto_uniformOnFun_iff_pi',596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [â† Filter.tendsto_comap_iff (g := (â‹ƒâ‚€ ğ”–).restrict), â† nhds_induced]
  simp_rw [UniformOnFun.topologicalSpace_eq, Pi.induced_restrict_sUnion ğ”– (Ï€ := fun _ â†¦ Î±),
    nhds_iInf, nhds_induced, tendsto_iInf, tendsto_comap_iff]
  congrm âˆ€ K (hK : K âˆˆ ğ”–), ?_
  have : CompactSpace K := isCompact_iff_compactSpace.mp (ğ”–_compact K hK)
  rw [â† (equicontinuous_restrict_iff _ |>.mpr <| F_eqcont K hK).tendsto_uniformFun_iff_pi]
  rfl","error:  ambiguous, possible interpretations 
  _root_.nhds_iInf : ğ“ ?m.23800 = â¨… i, ğ“ ?m.23800
  
  Filter.nhds_iInf : âˆ€ (f : ?m.23801 â†’ Filter ?m.23802), ğ“ (â¨… i, f i) = â¨… i, ğ“ (f i)
error:  simp made no progress","theorem EquicontinuousOn.tendsto_uniformOnFun_iff_pi'
    {ğ”– : Set (Set X)} (ğ”–_compact : âˆ€ K âˆˆ ğ”–, IsCompact K)
    (F_eqcont : âˆ€ K âˆˆ ğ”–, EquicontinuousOn F K) (â„± : Filter Î¹) (f : X â†’ Î±) :
    Tendsto (UniformOnFun.ofFun ğ”– âˆ˜ F) â„± (ğ“ <| UniformOnFun.ofFun ğ”– f) â†”
    Tendsto ((â‹ƒâ‚€ ğ”–).restrict âˆ˜ F) â„± (ğ“ <| (â‹ƒâ‚€ ğ”–).restrict f) ",":= by
  rw [â† Filter.tendsto_comap_iff (g := (â‹ƒâ‚€ ğ”–).restrict), â† nhds_induced]
  simp_rw [UniformOnFun.topologicalSpace_eq, Pi.induced_restrict_sUnion ğ”– (Ï€ := fun _ â†¦ Î±),
    _root_.nhds_iInf, nhds_induced, tendsto_iInf, tendsto_comap_iff]
  congrm âˆ€ K (hK : K âˆˆ ğ”–), ?_
  have : CompactSpace K := isCompact_iff_compactSpace.mp (ğ”–_compact K hK)
  rw [â† (equicontinuous_restrict_iff _ |>.mpr <| F_eqcont K hK).tendsto_uniformFun_iff_pi]
  rfl","simp only [UniformOnFun.tendsto_restrict_restrict_restrict, UniformOnFun.tendsto_restrict,
  UniformOnFun.tendsto_restrict_restrict_restrict]"
Mathlib/Analysis/SpecificLimits/Normed.lean,tendsto_pow_const_mul_const_pow_of_abs_lt_one,tendsto_pow_const_mul_const_pow_of_abs_lt_one,e234e64075504db13790aa471a4239039c94703b,":= by
  by_cases h0 : r = 0
  Â· exact tendsto_const_nhds.congr'
      (mem_atTop_sets.2 âŸ¨1, fun n hn â†¦ by simp [zero_lt_one.trans_le hn, h0]âŸ©)
  have hr' : 1 < (|r|)â»Â¹ := one_lt_inv (abs_pos.2 h0) hr
  rw [tendsto_zero_iff_norm_tendsto_zero]
  simpa [div_eq_mul_inv] using tendsto_pow_const_div_const_pow_of_one_lt k hr'","error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î¹ : Type u_3
k : â„•
r : â„
hr : |r| < 1
h0 : r = 0
n : â„•
hn : n â‰¥ 1
âŠ¢ n = 0 âˆ§ Â¬k = 0 âˆ¨ Â¬n = 0","theorem tendsto_pow_const_mul_const_pow_of_abs_lt_one (k : â„•) {r : â„} (hr : |r| < 1) :
    Tendsto (fun n â†¦ (n : â„) ^ k * r ^ n : â„• â†’ â„) atTop (ğ“ 0) ",":= by
  by_cases h0 : r = 0
  Â· exact tendsto_const_nhds.congr'
      (mem_atTop_sets.2 âŸ¨1, fun n hn â†¦ by simp [zero_lt_one.trans_le hn |>.ne', h0]âŸ©)
  have hr' : 1 < |r|â»Â¹ := one_lt_inv (abs_pos.2 h0) hr
  rw [tendsto_zero_iff_norm_tendsto_zero]
  simpa [div_eq_mul_inv] using tendsto_pow_const_div_const_pow_of_one_lt k hr'",simp only [tendsto_pow_const_mul_const_pow_const_pow_const_pow_const_pow_of_abs_lt_one]
Mathlib/Topology/Algebra/WithZeroTopology.lean,WithZeroTopology.hasBasis_nhds_zero,hasBasis_nhds_zero,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  rw [nhds_zero]
  refine' hasBasis_biInf_principal _ âŸ¨1, one_ne_zeroâŸ©
  exact directedOn_iff_directed.2 (directed_of_inf fun a b hab => Iio_subset_Iio hab)",error:  unknown identifier 'directed_of_inf',theorem hasBasis_nhds_zero : (ğ“ (0 : Î“â‚€)).HasBasis (fun Î³ : Î“â‚€ => Î³ â‰  0) Iio ,":= by
  rw [nhds_zero]
  refine hasBasis_biInf_principal ?_ âŸ¨1, one_ne_zeroâŸ©
  exact directedOn_iff_directed.2 (Monotone.directed_ge fun a b hab => Iio_subset_Iio hab)","refine hasBasis_nhds_zero.mem_iff.2 âŸ¨Î³, hasBasis_nhds_zeroâŸ©"
Mathlib/Computability/PartrecCode.lean,Nat.Partrec.Code.pair_prim,pair_prim,6085d5e27552de2d43997b4a52a8d9fcd4686071,":=
  Primrec.ofNat_iffâ‚‚.2 <| Primrec.encode_iff.1 <| nat_add.compâ‚‚
    (nat_double.comp <| nat_double.comp <| Primrec.natPair.compâ‚‚
      (encode_iff.2 <| (Primrec.ofNat Code).comp fst)
      (encode_iff.2 <| (Primrec.ofNat Code).comp snd))
    (.const 4)","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Primrec
has type
  (?m.124537 â†’ ?m.124538) â†’ Prop",theorem pair_prim : Primrecâ‚‚ pair ,":=
  Primrecâ‚‚.ofNat_iff.2 <|
    Primrecâ‚‚.encode_iff.1 <|
      nat_add.comp
        (nat_double.comp <|
          nat_double.comp <|
            Primrecâ‚‚.natPair.comp (encode_iff.2 <| (Primrec.ofNat Code).comp fst)
              (encode_iff.2 <| (Primrec.ofNat Code).comp snd))
        (Primrecâ‚‚.const 4)",heorem pair_prim := pair_prim
Mathlib/MeasureTheory/Group/Action.lean,MeasureTheory.smulInvariantMeasure_tfae,smulInvariantMeasure_tfae,fba28f571f3d12084f060ccc0fd73ca4e275ccce,":= by
  tfae_have : 1 â†” 2
  Â· exact âŸ¨fun h => h.1, fun h => âŸ¨hâŸ©âŸ©
  tfae_have : 1 â†’ 6
  Â· intro h c
    exact (measurePreserving_smul c Î¼).map_eq
  tfae_have : 6 â†’ 7
  Â· exact fun H c => âŸ¨measurable_const_smul c, H câŸ©
  tfae_have : 7 â†’ 4
  Â· exact fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)
  tfae_have : 4 â†’ 5
  Â· exact fun H c s => by
      rw [â† preimage_smul_inv]
      apply H
  tfae_have : 5 â†’ 3
  Â· exact fun H c s _ => H c s
  tfae_have : 3 â†’ 2
  Â· intro H c s hs
    rw [preimage_smul]
    exact H câ»Â¹ s hs
  tfae_finish",error:  unexpected token ':'; expected numeral,"theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G Î± Î¼,
        âˆ€ (c : G) (s), MeasurableSet s â†’ Î¼ ((c â€¢ Â·) â»Â¹' s) = Î¼ s,
        âˆ€ (c : G) (s), MeasurableSet s â†’ Î¼ (c â€¢ s) = Î¼ s,
        âˆ€ (c : G) (s), Î¼ ((c â€¢ Â·) â»Â¹' s) = Î¼ s,
        âˆ€ (c : G) (s), Î¼ (c â€¢ s) = Î¼ s,
        âˆ€ c : G, Measure.map (c â€¢ Â·) Î¼ = Î¼,
        âˆ€ c : G, MeasurePreserving (c â€¢ Â·) Î¼ Î¼] ",":= by
  tfae_have 1 â†” 2
  Â· exact âŸ¨fun h => h.1, fun h => âŸ¨hâŸ©âŸ©
  tfae_have 1 â†’ 6
  Â· intro h c
    exact (measurePreserving_smul c Î¼).map_eq
  tfae_have 6 â†’ 7
  Â· exact fun H c => âŸ¨measurable_const_smul c, H câŸ©
  tfae_have 7 â†’ 4
  Â· exact fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)
  tfae_have 4 â†’ 5
  Â· exact fun H c s => by
      rw [â† preimage_smul_inv]
      apply H
  tfae_have 5 â†’ 3
  Â· exact fun H c s _ => H c s
  tfae_have 3 â†’ 2
  Â· intro H c s hs
    rw [preimage_smul]
    exact H câ»Â¹ s hs
  tfae_finish",have smulInvariantMeasure_tfae smulInvariantMeasure_tfae smulInvariantMeasure_tfae
Mathlib/Topology/Connected/Basic.lean,isPreconnected_of_forall_constant,isPreconnected_of_forall_constant,64b674911520c89d4467fb9e8410ab9d79e82064,":= by
  unfold IsPreconnected
  by_contra'
  rcases this with âŸ¨u, v, u_op, v_op, hsuv, âŸ¨x, x_in_s, x_in_uâŸ©, âŸ¨y, y_in_s, y_in_vâŸ©, HâŸ©
  rw [not_nonempty_iff_eq_empty] at H
  have hy : y âˆ‰ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y âŸ¨y_in_s, âŸ¨y_in_u, y_in_vâŸ©âŸ©
  have : ContinuousOn u.boolIndicator s := by
    apply (continuousOn_boolIndicator_iff_clopen _ _).mpr âŸ¨_, _âŸ©
    Â· exact u_op.preimage continuous_subtype_val
    Â· rw [preimage_subtype_coe_eq_compl hsuv H]
      exact (v_op.preimage continuous_subtype_val).isClosed_compl
  simpa [(u.mem_iff_boolIndicator _).mp x_in_u, (u.not_mem_iff_boolIndicator _).mp hy] using
    hs _ this x x_in_s y y_in_s","error:  unknown tactic
error:  unsolved goals
Î± : Type u
Î² : Type v
Î¹ : Type u_1
Ï€ : Î¹ â†’ Type u_2
instâœ : TopologicalSpace Î±
sâœ t u v s : Set Î±
hs : âˆ€ (f : Î± â†’ Bool), ContinuousOn f s â†’ âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, f x = f y
âŠ¢ âˆ€ (u v : Set Î±), IsOpen u â†’ IsOpen v â†’ s âŠ† u âˆª v â†’ (s âˆ© u).Nonempty â†’ (s âˆ© v).Nonempty â†’ (s âˆ© (u âˆ© v)).Nonempty","theorem isPreconnected_of_forall_constant {s : Set Î±}
    (hs : âˆ€ f : Î± â†’ Bool, ContinuousOn f s â†’ âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, f x = f y) : IsPreconnected s ",":= by
  unfold IsPreconnected
  by_contra!
  rcases this with âŸ¨u, v, u_op, v_op, hsuv, âŸ¨x, x_in_s, x_in_uâŸ©, âŸ¨y, y_in_s, y_in_vâŸ©, HâŸ©
  have hy : y âˆ‰ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y âŸ¨y_in_s, âŸ¨y_in_u, y_in_vâŸ©âŸ©
  have : ContinuousOn u.boolIndicator s := by
    apply (continuousOn_boolIndicator_iff_isClopen _ _).mpr âŸ¨_, _âŸ©
    Â· rw [preimage_subtype_coe_eq_compl hsuv H]
      exact (v_op.preimage continuous_subtype_val).isClosed_compl
    Â· exact u_op.preimage continuous_subtype_val
  simpa [(u.mem_iff_boolIndicator _).mp x_in_u, (u.not_mem_iff_boolIndicator _).mp hy] using
    hs _ this x x_in_s y y_in_s",rw [isPreconnected_iff]
Mathlib/Order/WellFoundedSet.lean,Set.partiallyWellOrderedOn_union,partiallyWellOrderedOn_union,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":=
  âŸ¨fun h => âŸ¨h.mono <| subset_union_left _ _, h.mono <| subset_union_right _ _âŸ©, fun h =>
    h.1.union h.2âŸ©","error:  function expected at
  subset_union_left ?m.12246
term has type
  ?m.12245 âˆˆ ?m.12243 âˆª ?m.12244
error:  function expected at
  subset_union_right ?m.12310
term has type
  ?m.12309 âˆˆ ?m.12307 âˆª ?m.12308","theorem partiallyWellOrderedOn_union :
    (s âˆª t).PartiallyWellOrderedOn r â†” s.PartiallyWellOrderedOn r âˆ§ t.PartiallyWellOrderedOn r ",":=
  âŸ¨fun h => âŸ¨h.mono subset_union_left, h.mono subset_union_rightâŸ©, fun h =>
    h.1.union h.2âŸ©",rw [partiallyWellOrderedOn_iff] at partiallyWellOrderedOn
Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean,Finpartition.equitabilise_aux,equitabilise_aux,05c4c02a126a220762b13df794c36c771e2fbb7d,":= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  Â· refine' âŸ¨âŠ¥, by simp, _, by simpa using hs.symmâŸ©
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      âŸ¨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _âŸ©
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 âˆ§ b = 0
  Â· simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (Î± := Finpartition âŠ¥) P
    exact âŸ¨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]âŸ©
  simp_rw [not_and_or, â† Ne.eq_def, â† pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain âŸ¨hnâ‚€, hnâ‚, hnâ‚‚, hnâ‚ƒâŸ© : 0 < n âˆ§ n â‰¤ m + 1 âˆ§ n â‰¤ a * m + b * (m + 1) âˆ§
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, â† hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    Â· refine' âŸ¨m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ â€¹0 < aâ€º), _âŸ©
      rw [tsub_add_eq_add_tsub (Nat.le_mul_of_pos_left _ h)]
    Â· refine' âŸ¨succ_pos', le_rfl,
        le_add_left (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º), _âŸ©
      rw [â† add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º)]
  by_cases h : âˆ€ u âˆˆ P.parts, card u < m + 1
  Â· obtain âŸ¨t, hts, htnâŸ© := exists_smaller_set s n (hnâ‚‚.trans_eq hs)
    have ht : t.Nonempty := by rwa [â† card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff â€¹t âŠ† sâ€º, htn, hnâ‚ƒ]
    obtain âŸ¨R, hRâ‚, _, hRâ‚ƒâŸ© :=
      @ih (s \ t) (sdiff_ssubset hts â€¹t.Nonemptyâ€º) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine' âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), _, _, _âŸ©
    Â· simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => (card_le_card <| sdiff_subset _ _).trans (Nat.lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    Â· rw [hRâ‚ƒ, if_pos ha]
    rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg ha, tsub_add_cancel_of_le]
    Â· exact hab.resolve_left ha
    Â· intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg at h
  obtain âŸ¨u, huâ‚, huâ‚‚âŸ© := h
  obtain âŸ¨t, htu, htnâŸ© := exists_smaller_set _ _ (hnâ‚.trans huâ‚‚)
  have ht : t.Nonempty := by rwa [â† card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le huâ‚), htn, hnâ‚ƒ]
  obtain âŸ¨R, hRâ‚, hRâ‚‚, hRâ‚ƒâŸ© :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le huâ‚) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine' âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le huâ‚), _, _, _âŸ©
  Â· simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hRâ‚, htn, hn]
    exact ite_eq_or_eq _ _ _
  Â· conv in _ âˆˆ _ => rw [â† insert_erase huâ‚]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne, extend_parts]
    refine' âŸ¨_, fun x hx => (card_le_card _).trans <| hRâ‚‚ x _âŸ©
    Â· simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id]
      obtain rfl | hut := eq_or_ne u t
      Â· rw [sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)]
        exact bot_le
      refine'
        (card_le_card fun i => _).trans
          (hRâ‚‚ (u \ t) <| P.mem_avoid.2 âŸ¨u, huâ‚, fun i => hut <| i.antisymm htu, rflâŸ©)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id, not_or]
      exact fun hiâ‚ hiâ‚‚ hiâ‚ƒ =>
        âŸ¨âŸ¨hiâ‚, hiâ‚‚âŸ©, fun x hx hx' => hiâ‚ƒ _ hx <| hx'.trans <| sdiff_subset _ _âŸ©
    Â· apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      âŸ¨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) huâ‚ <| ne_of_mem_erase hx).sdiff_eq_leftâŸ©
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  Â· rw [hRâ‚ƒ, if_pos h]
  Â· rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)","error:  type mismatch
  hâœ
has type
  s.card = b : Prop
but is expected to have type
  (filter (fun i â†¦ i.card = 1) (Finset.map { toFun := singleton, inj' := â‹¯ } s)).card = b : Prop
warning:  `Finset.exists_smaller_set` has been deprecated, use `Finset.exists_subset_card_eq` instead
error:  function expected at
  sdiff_subset ?m.19421
term has type
  ?m.19420 âˆˆ ?m.19418
warning:  `Finset.exists_smaller_set` has been deprecated, use `Finset.exists_subset_card_eq` instead
error:  function expected at
  subset_union_left ?m.28210
term has type
  ?m.28209 âˆˆ ?m.28207 âˆª ?m.28208
error:  function expected at
  sdiff_subset ?m.29984
term has type
  ?m.29983 âˆˆ ?m.29981","theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    âˆƒ Q : Finpartition s,
      (âˆ€ x : Finset Î±, x âˆˆ Q.parts â†’ x.card = m âˆ¨ x.card = m + 1) âˆ§
        (âˆ€ x, x âˆˆ P.parts â†’ (x \ (Q.parts.filter fun y => y âŠ† x).biUnion id).card â‰¤ m) âˆ§
          (Q.parts.filter fun i => card i = m + 1).card = b ",":= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  Â· refine âŸ¨âŠ¥, by simp, ?_, by simpa [Finset.filter_true_of_mem] using hs.symmâŸ©
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      âŸ¨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _âŸ©
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 âˆ§ b = 0
  Â· simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (Î± := Finpartition âŠ¥) P
    exact âŸ¨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]âŸ©
  simp_rw [not_and_or, â† Ne.eq_def, â† pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain âŸ¨hnâ‚€, hnâ‚, hnâ‚‚, hnâ‚ƒâŸ© : 0 < n âˆ§ n â‰¤ m + 1 âˆ§ n â‰¤ a * m + b * (m + 1) âˆ§
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, â† hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    Â· refine âŸ¨m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ â€¹0 < aâ€º), ?_âŸ©
      rw [tsub_add_eq_add_tsub (Nat.le_mul_of_pos_left _ h)]
    Â· refine âŸ¨succ_pos', le_rfl,
        le_add_left (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º), ?_âŸ©
      rw [â† add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º)]
  by_cases h : âˆ€ u âˆˆ P.parts, card u < m + 1
  Â· obtain âŸ¨t, hts, htnâŸ© := exists_subset_card_eq (hnâ‚‚.trans_eq hs)
    have ht : t.Nonempty := by rwa [â† card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff â€¹t âŠ† sâ€º, htn, hnâ‚ƒ]
    obtain âŸ¨R, hRâ‚, _, hRâ‚ƒâŸ© :=
      @ih (s \ t) (sdiff_ssubset hts â€¹t.Nonemptyâ€º) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), ?_, ?_, ?_âŸ©
    Â· simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => (card_le_card sdiff_subset).trans (Nat.lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    Â· rw [hRâ‚ƒ, if_pos ha]
    rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg ha, tsub_add_cancel_of_le]
    Â· exact hab.resolve_left ha
    Â· intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg at h
  obtain âŸ¨u, huâ‚, huâ‚‚âŸ© := h
  obtain âŸ¨t, htu, htnâŸ© := exists_subset_card_eq (hnâ‚.trans huâ‚‚)
  have ht : t.Nonempty := by rwa [â† card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le huâ‚), htn, hnâ‚ƒ]
  obtain âŸ¨R, hRâ‚, hRâ‚‚, hRâ‚ƒâŸ© :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le huâ‚) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine
    âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le huâ‚), ?_, ?_, ?_âŸ©
  Â· simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hRâ‚, htn, hn]
    exact ite_eq_or_eq _ _ _
  Â· conv in _ âˆˆ _ => rw [â† insert_erase huâ‚]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne, extend_parts]
    refine âŸ¨?_, fun x hx => (card_le_card ?_).trans <| hRâ‚‚ x ?_âŸ©
    Â· simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id]
      obtain rfl | hut := eq_or_ne u t
      Â· rw [sdiff_eq_empty_iff_subset.2 subset_union_left]
        exact bot_le
      refine
        (card_le_card fun i => ?_).trans
          (hRâ‚‚ (u \ t) <| P.mem_avoid.2 âŸ¨u, huâ‚, fun i => hut <| i.antisymm htu, rflâŸ©)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id, not_or]
      exact fun hiâ‚ hiâ‚‚ hiâ‚ƒ =>
        âŸ¨âŸ¨hiâ‚, hiâ‚‚âŸ©, fun x hx hx' => hiâ‚ƒ _ hx <| hx'.trans sdiff_subsetâŸ©
    Â· apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      âŸ¨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) huâ‚ <| ne_of_mem_erase hx).sdiff_eq_leftâŸ©
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  Â· rw [hRâ‚ƒ, if_pos h]
  Â· rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)","refine âŸ¨Q, equitabilise_aux, equitabilise_aux, equitabilise_aux, hs, ?_âŸ©"
Mathlib/NumberTheory/ClassNumber/Finite.lean,ClassGroup.exists_mem_finsetApprox,exists_mem_finsetApprox,6d1b77e97159c51b0084f053ab93299f39b3a009,":= by
  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty
  set Îµ : â„ := normBound abv bS ^ (-1 / Fintype.card Î¹ : â„) with Îµ_eq
  have hÎµ : 0 < Îµ := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _
  have Îµ_le : (normBound abv bS : â„) * (abv b â€¢ Îµ) ^ Fintype.card Î¹ â‰¤ abv b ^ Fintype.card Î¹ := by
    have := normBound_pos abv bS
    have := abv.nonneg b
    rw [Îµ_eq, Algebra.smul_def, eq_intCast, mul_rpow, â† rpow_mul, div_mul_cancel, rpow_neg_one,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_nat_cast] <;>
      try norm_cast; linarith
    Â· exact Iff.mpr Int.cast_nonneg this
    Â· linarith
  set Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm with hÎ¼
  let s : Î¹ â†’â‚€ R := bS.repr a
  have s_eq : âˆ€ i, s i = bS.repr a i := fun i => rfl
  let qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i / b
  let rs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i % b
  have r_eq : âˆ€ j i, rs j i = Î¼ j * s i % b := fun i j => rfl
  have Î¼_eq : âˆ€ i j, Î¼ j * s i = b * qs j i + rs j i := by
    intro i j
    rw [r_eq, EuclideanDomain.div_add_mod]
  have Î¼_mul_a_eq : âˆ€ j, Î¼ j â€¢ a = b â€¢ âˆ‘ i, qs j i â€¢ bS i + âˆ‘ i, rs j i â€¢ bS i := by
    intro j
    rw [â† bS.sum_repr a]
    simp only [Finset.smul_sum, â† Finset.sum_add_distrib]
    refine'
      Finset.sum_congr rfl fun i _ =>  _
    rw [â† hÎ¼, â† r_eq, â† s_eq, â† mul_smul, Î¼_eq, add_smul, mul_smul, â† Î¼_eq]
  obtain âŸ¨j, k, j_ne_k, hjkâŸ© := adm.exists_approx hÎµ hb fun j i => Î¼ j * s i
  have hjk' : âˆ€ i, (abv (rs k i - rs j i) : â„) < abv b â€¢ Îµ := by simpa only [r_eq] using hjk
  let q := âˆ‘ i, (qs k i - qs j i) â€¢ bS i
  set r := Î¼ k - Î¼ j with r_eq
  refine' âŸ¨q, r, (mem_finsetApprox bS adm).mpr _, _âŸ©
  Â· exact âŸ¨k, j, j_ne_k.symm, rflâŸ©
  have : r â€¢ a - b â€¢ q = âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) := by
    simp only [r_eq, sub_smul, Î¼_mul_a_eq, Finset.smul_sum, â† Finset.sum_add_distrib,
      â† Finset.sum_sub_distrib, smul_sub]
    refine' Finset.sum_congr rfl fun x _ => _
    ring
  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]
  refine' Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt _ (hjk' i)).trans_le _)
  Â· apply le_of_eq
    congr
    simp_rw [LinearEquiv.map_sum, LinearEquiv.map_sub, LinearEquiv.map_smul, Finset.sum_apply',
      Finsupp.sub_apply, Finsupp.smul_apply, Finset.sum_sub_distrib, Basis.repr_self_apply,
      smul_eq_mul, mul_boole, Finset.sum_ite_eq', Finset.mem_univ, if_true]
  Â· exact_mod_cast Îµ_le","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?m.172686 * ?m.172687) ^ ?m.172688
R : Type u_1
S : Type u_2
K : Type u_3
L : Type u_4
instâœÂ¹â¶ : EuclideanDomain R
instâœÂ¹âµ : CommRing S
instâœÂ¹â´ : IsDomain S
instâœÂ¹Â³ : Field K
instâœÂ¹Â² : Field L
instâœÂ¹Â¹ : Algebra R K
instâœÂ¹â° : IsFractionRing R K
instâœâ¹ : Algebra K L
instâœâ¸ : FiniteDimensional K L
instâœâ· : IsSeparable K L
algRL : Algebra R L
instâœâ¶ : IsScalarTower R K L
instâœâµ : Algebra R S
instâœâ´ : Algebra S L
ist : IsScalarTower R S L
iic : IsIntegralClosure S R L
abv : AbsoluteValue R â„¤
Î¹ : Type u_5
instâœÂ³ : DecidableEq Î¹
instâœÂ² : Fintype Î¹
bS : Basis Î¹ R S
adm : abv.IsAdmissible
instâœÂ¹ : Infinite R
instâœ : DecidableEq R
a : S
b : R
hb : b â‰  0
dim_pos : 0 < Fintype.card Î¹
Îµ : â„ := â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))
Îµ_eq : Îµ = â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))
hÎµ : 0 < Îµ
thisâœ : 0 < normBound abv bS
this : 0 â‰¤ abv b
âŠ¢ â†‘(normBound abv bS) * (â†‘(abv b) * â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))) ^ Fintype.card Î¹ â‰¤
    â†‘(abv b) ^ Fintype.card Î¹
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  distinctElems bS adm
R : Type u_1
S : Type u_2
K : Type u_3
L : Type u_4
instâœÂ¹â¶ : EuclideanDomain R
instâœÂ¹âµ : CommRing S
instâœÂ¹â´ : IsDomain S
instâœÂ¹Â³ : Field K
instâœÂ¹Â² : Field L
instâœÂ¹Â¹ : Algebra R K
instâœÂ¹â° : IsFractionRing R K
instâœâ¹ : Algebra K L
instâœâ¸ : FiniteDimensional K L
instâœâ· : IsSeparable K L
algRL : Algebra R L
instâœâ¶ : IsScalarTower R K L
instâœâµ : Algebra R S
instâœâ´ : Algebra S L
ist : IsScalarTower R S L
iic : IsIntegralClosure S R L
abv : AbsoluteValue R â„¤
Î¹ : Type u_5
instâœÂ³ : DecidableEq Î¹
instâœÂ² : Fintype Î¹
bS : Basis Î¹ R S
adm : abv.IsAdmissible
instâœÂ¹ : Infinite R
instâœ : DecidableEq R
a : S
b : R
hb : b â‰  0
dim_pos : 0 < Fintype.card Î¹
Îµ : â„ := â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))
Îµ_eq : Îµ = â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))
hÎµ : 0 < Îµ
Îµ_le : â†‘(normBound abv bS) * (abv b â€¢ Îµ) ^ Fintype.card Î¹ â‰¤ â†‘(abv b) ^ Fintype.card Î¹
Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm
hÎ¼ : Î¼ = distinctElems bS adm
s : Î¹ â†’â‚€ R := bS.repr a
s_eq : âˆ€ (i : Î¹), s i = (bS.repr a) i
qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i â†¦ Î¼ j * s i / b
rs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i â†¦ Î¼ j * s i % b
r_eq : âˆ€ (j : Fin (cardM bS adm).succ) (i : Î¹), rs j i = Î¼ j * s i % b
Î¼_eq : âˆ€ (i : Î¹) (j : Fin (cardM bS adm).succ), Î¼ j * s i = b * qs j i + rs j i
j : Fin (cardM bS adm).succ
i : Î¹
xâœ : i âˆˆ Finset.univ
âŠ¢ Î¼ j â€¢ (bS.repr a) i â€¢ bS i = b â€¢ qs j i â€¢ bS i + rs j i â€¢ bS i
error:  type mismatch
  Finset.sum_congr rfl fun x x_1 â†¦ ?m.187579 x x_1
has type
  ?m.187475.sum ?m.187376 = ?m.187475.sum ?m.187377 : Prop
but is expected to have type
  âˆ‘ x : Î¹, (b â€¢ qs k x â€¢ bS x + rs k x â€¢ bS x - (b â€¢ qs j x â€¢ bS x + rs j x â€¢ bS x)) - b â€¢ q =
    âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearEquiv
has type
  (Ïƒ : ?m.191789 â†’+* ?m.191790) â†’
    {Ïƒ' : ?m.191790 â†’+* ?m.191789} â†’
      [inst : RingHomInvPair Ïƒ Ïƒ'] â†’
        [inst : RingHomInvPair Ïƒ' Ïƒ] â†’
          (M : Type ?u.191786) â†’
            (Mâ‚‚ : Type ?u.191785) â†’
              [inst : AddCommMonoid M] â†’
                [inst_1 : AddCommMonoid Mâ‚‚] â†’
                  [inst : Module ?m.191789 M] â†’ [inst : Module ?m.191790 Mâ‚‚] â†’ Type (max ?u.191786 ?u.191785)
error:  simp made no progress","theorem exists_mem_finsetApprox (a : S) {b} (hb : b â‰  (0 : R)) :
    âˆƒ q : S,
      âˆƒ r âˆˆ finsetApprox bS adm, abv (Algebra.norm R (r â€¢ a - b â€¢ q)) <
      abv (Algebra.norm R (algebraMap R S b)) ",":= by
  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty
  set Îµ : â„ := normBound abv bS ^ (-1 / Fintype.card Î¹ : â„) with Îµ_eq
  have hÎµ : 0 < Îµ := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _
  have Îµ_le : (normBound abv bS : â„) * (abv b â€¢ Îµ) ^ (Fintype.card Î¹ : â„)
                â‰¤ abv b ^ (Fintype.card Î¹ : â„) := by
    have := normBound_pos abv bS
    have := abv.nonneg b
    rw [Îµ_eq, Algebra.smul_def, eq_intCast, mul_rpow, â† rpow_mul, div_mul_cancelâ‚€, rpow_neg_one,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_natCast] <;>
      try norm_cast; omega
    Â· exact Iff.mpr Int.cast_nonneg this
    Â· linarith
  set Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm with hÎ¼
  let s : Î¹ â†’â‚€ R := bS.repr a
  have s_eq : âˆ€ i, s i = bS.repr a i := fun i => rfl
  let qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i / b
  let rs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i % b
  have r_eq : âˆ€ j i, rs j i = Î¼ j * s i % b := fun i j => rfl
  have Î¼_eq : âˆ€ i j, Î¼ j * s i = b * qs j i + rs j i := by
    intro i j
    rw [r_eq, EuclideanDomain.div_add_mod]
  have Î¼_mul_a_eq : âˆ€ j, Î¼ j â€¢ a = b â€¢ âˆ‘ i, qs j i â€¢ bS i + âˆ‘ i, rs j i â€¢ bS i := by
    intro j
    rw [â† bS.sum_repr a]
    simp only [Î¼, qs, rs, Finset.smul_sum, â† Finset.sum_add_distrib]
    refine Finset.sum_congr rfl fun i _ => ?_
    rw [â† hÎ¼, â† r_eq, â† s_eq, â† mul_smul, Î¼_eq, add_smul, mul_smul, â† Î¼_eq]
  obtain âŸ¨j, k, j_ne_k, hjkâŸ© := adm.exists_approx hÎµ hb fun j i => Î¼ j * s i
  have hjk' : âˆ€ i, (abv (rs k i - rs j i) : â„) < abv b â€¢ Îµ := by simpa only [r_eq] using hjk
  let q := âˆ‘ i, (qs k i - qs j i) â€¢ bS i
  set r := Î¼ k - Î¼ j with r_eq
  refine âŸ¨q, r, (mem_finsetApprox bS adm).mpr ?_, ?_âŸ©
  Â· exact âŸ¨k, j, j_ne_k.symm, rflâŸ©
  have : r â€¢ a - b â€¢ q = âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) := by
    simp only [q, r_eq, sub_smul, Î¼_mul_a_eq, Finset.smul_sum, â† Finset.sum_add_distrib,
      â† Finset.sum_sub_distrib, smul_sub]
    refine Finset.sum_congr rfl fun x _ => ?_
    ring
  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]
  refine Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt ?_ (hjk' i)).trans_le ?_)
  Â· apply le_of_eq
    congr
    simp_rw [map_sum, map_sub, map_smul, Finset.sum_apply',
      Finsupp.sub_apply, Finsupp.smul_apply, Finset.sum_sub_distrib, Basis.repr_self_apply,
      smul_eq_mul, mul_boole, Finset.sum_ite_eq', Finset.mem_univ, if_true]
  Â· exact mod_cast Îµ_le",rw [theorem_exists_mem_finsetApprox]
Mathlib/Topology/Bases.lean,TopologicalSpace.separableSpace_iff_countable,separableSpace_iff_countable,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  simp [SeparableSpace_iff, countable_univ_iff]","error:  unknown identifier 'SeparableSpace_iff'
error:  simp made no progress",theorem separableSpace_iff_countable [DiscreteTopology Î±] : SeparableSpace Î± â†” Countable Î± ,":= by
  simp [separableSpace_iff, countable_univ_iff]",rw [countable_iff_countable]
Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean,measurable_of_tendsto_metrizable',measurable_of_tendsto_metrizable',5068808d2b4c25cf905cf7fee10ded8e447c2346,":= by
  letI : PseudoMetricSpace Î² := pseudoMetrizableSpacePseudoMetric Î²
  apply measurable_of_is_closed'
  intro s h1s h2s h3s
  have : Measurable fun x => infNndist (g x) s := by
    suffices : Tendsto (fun i x => infNndist (f i x) s) u (ğ“ fun x => infNndist (g x) s)
    exact measurable_of_tendsto_nnreal' u (fun i => (hf i).infNndist) this
    rw [tendsto_pi_nhds] at limâŠ¢
    intro x
    exact ((continuous_infNndist_pt s).tendsto (g x)).comp (lim x)
  have h4s : g â»Â¹' s = (fun x => infNndist (g x) s) â»Â¹' {0} := by
    ext x
    simp [h1s, â† h1s.mem_iff_infDist_zero h2s, â† NNReal.coe_eq_zero]
  rw [h4s]
  exact this (measurableSet_singleton 0)",error:  unexpected token ':'; expected term,"theorem measurable_of_tendsto_metrizable' {Î¹} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : Filter Î¹) [NeBot u]
    [IsCountablyGenerated u] (hf : âˆ€ i, Measurable (f i)) (lim : Tendsto f u (ğ“ g)) :
    Measurable g ",":= by
  letI : PseudoMetricSpace Î² := pseudoMetrizableSpacePseudoMetric Î²
  apply measurable_of_isClosed'
  intro s h1s h2s h3s
  have : Measurable fun x => infNndist (g x) s := by
    suffices Tendsto (fun i x => infNndist (f i x) s) u (ğ“ fun x => infNndist (g x) s) from
      NNReal.measurable_of_tendsto' u (fun i => (hf i).infNndist) this
    rw [tendsto_pi_nhds] at lim âŠ¢
    intro x
    exact ((continuous_infNndist_pt s).tendsto (g x)).comp (lim x)
  have h4s : g â»Â¹' s = (fun x => infNndist (g x) s) â»Â¹' {0} := by
    ext x
    simp [h1s, â† h1s.mem_iff_infDist_zero h2s, â† NNReal.coe_eq_zero]
  rw [h4s]
  exact this (measurableSet_singleton 0)",refine measurable_of_tendsto_metrizable'.measurable_of_tendsto_metrizable'.measurable_lim ?_
Mathlib/RingTheory/Adjoin/PowerBasis.lean,PowerBasis.repr_mul_isIntegral,repr_mul_isIntegral,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  intro i
  rw [â† B.basis.sum_repr x, â† B.basis.sum_repr y, Finset.sum_mul_sum, map_sum, Finset.sum_apply']
  refine' IsIntegral.sum _ fun I _ => _
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smulâ‚›â‚—,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine' isIntegral_mul (hy _) (isIntegral_mul (hx _) _)
  simp only [coe_basis, â† pow_add]
  refine' repr_gen_pow_isIntegral hB hmin _ _","error:  unknown identifier 'isIntegral_mul'
error:  no goals to be solved
error:  application type mismatch
  repr_mul_isIntegral hB
argument
  hB
has type
  IsIntegral R B.gen : Prop
but is expected to have type
  âˆ€ (i : Fin ?m.77364.dim), IsIntegral ?m.77357 ((?m.77364.basis.repr ?m.77366) i) : Prop
error:  application type mismatch
  repr_pow_isIntegral hB
argument
  hB
has type
  IsIntegral R B.gen : Prop
but is expected to have type
  âˆ€ (i : Fin ?m.83636.dim), IsIntegral ?m.83629 ((?m.83636.basis.repr ?m.83638) i) : Prop
error:  no goals to be solved","theorem repr_mul_isIntegral [IsDomain S] {x y : A} (hx : âˆ€ i, IsIntegral R (B.basis.repr x i))
    (hy : âˆ€ i, IsIntegral R (B.basis.repr y i))
    (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) :
    âˆ€ i, IsIntegral R (B.basis.repr (x * y) i) ",":= by
  intro i
  rw [â† B.basis.sum_repr x, â† B.basis.sum_repr y, Finset.sum_mul_sum, â† Finset.sum_product',
    map_sum, Finset.sum_apply']
  refine IsIntegral.sum _ fun I _ => ?_
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smulâ‚›â‚—,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine (hy _).mul ((hx _).mul ?_)
  simp only [coe_basis, â† pow_add]
  exact repr_gen_pow_isIntegral hB hmin _ _",apply IsIntegral.theorem repr_mul_isIntegral
Mathlib/Analysis/Analytic/Composition.lean,FormalMultilinearSeries.comp_summable_nnreal,comp_summable_nnreal,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hp) with âŸ¨rp, rp_pos, hrpâŸ©
  simp only [lt_min_iff, ENNReal.coe_lt_one_iff, ENNReal.coe_pos] at hrp hrq rp_pos rq_pos
  obtain âŸ¨Cq, _hCq0, hCqâŸ© : âˆƒ Cq > 0, âˆ€ n, â€–q nâ€–â‚Š * rq ^ n â‰¤ Cq :=
    q.nnnorm_mul_pow_le_of_lt_radius hrq.2
  obtain âŸ¨Cp, hCp1, hCpâŸ© : âˆƒ Cp â‰¥ 1, âˆ€ n, â€–p nâ€–â‚Š * rp ^ n â‰¤ Cp := by
    rcases p.nnnorm_mul_pow_le_of_lt_radius hrp.2 with âŸ¨Cp, -, hCpâŸ©
    exact âŸ¨max Cp 1, le_max_right _ _, fun n => (hCp n).trans (le_max_left _ _)âŸ©
  let r0 : â„â‰¥0 := (4 * Cp)â»Â¹
  have r0_pos : 0 < r0 := inv_pos.2 (mul_pos zero_lt_four (zero_lt_one.trans_le hCp1))
  set r : â„â‰¥0 := rp * rq * r0
  have r_pos : 0 < r := mul_pos (mul_pos rp_pos rq_pos) r0_pos
  have I :
    âˆ€ i : Î£ n : â„•, Composition n, â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 â‰¤ Cq / 4 ^ i.1 := by
    rintro âŸ¨n, câŸ©
    have A := calc
      â€–q c.lengthâ€–â‚Š * rq ^ n â‰¤ â€–q c.lengthâ€–â‚Š * rq ^ c.length :=
        mul_le_mul' le_rfl (pow_le_pow_of_le_one rq.2 hrq.1.le c.length_le)
      _ â‰¤ Cq := hCq _
    have B := calc
      (âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n = âˆ i, â€–p (c.blocksFun i)â€–â‚Š * rp ^ c.blocksFun i := by
        simp only [Finset.prod_mul_distrib, Finset.prod_pow_eq_pow_sum, c.sum_blocksFun]
      _ â‰¤ âˆ _i : Fin c.length, Cp := (Finset.prod_le_prod' fun i _ => hCp _)
      _ = Cp ^ c.length := by simp
      _ â‰¤ Cp ^ n := pow_le_pow_right hCp1 c.length_le
    calc
      â€–q.compAlongComposition p câ€–â‚Š * r ^ n â‰¤
          (â€–q c.lengthâ€–â‚Š * âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * r ^ n :=
        mul_le_mul' (q.compAlongComposition_nnnorm p c) le_rfl
      _ = â€–q c.lengthâ€–â‚Š * rq ^ n * ((âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n) * r0 ^ n := by
        simp only [mul_pow]; ring
      _ â‰¤ Cq * Cp ^ n * r0 ^ n := (mul_le_mul' (mul_le_mul' A B) le_rfl)
      _ = Cq / 4 ^ n := by
        simp only
        field_simp [mul_pow, (zero_lt_one.trans_le hCp1).ne']
        ring
  refine' âŸ¨r, r_pos, NNReal.summable_of_le I _âŸ©
  simp_rw [div_eq_mul_inv]
  refine' Summable.mul_left _ _
  have : âˆ€ n : â„•, HasSum (fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹) (2 ^ (n - 1) / 4 ^ n) := by
    intro n
    convert hasSum_fintype fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹
    simp [Finset.card_univ, composition_card, div_eq_mul_inv]
  refine' NNReal.summable_sigma.2 âŸ¨fun n => (this n).summable, (NNReal.summable_nat_add_iff 1).1 _âŸ©
  convert (NNReal.summable_geometric (NNReal.div_lt_one_of_lt one_lt_two)).mul_left (1 / 4) using 1
  ext1 n
  rw [(this _).tsum_eq, add_tsub_cancel_right]
  field_simp [â† mul_assoc, pow_succ', mul_pow, show (4 : â„â‰¥0) = 2 * 2 by norm_num,
    mul_right_comm]","error:  simp made no progress
error:  simp made no progress
error:  unsolved goals
case h.e'_5.h
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
G : Type u_4
H : Type u_5
instâœâ¸ : NontriviallyNormedField ğ•œ
instâœâ· : NormedAddCommGroup E
instâœâ¶ : NormedSpace ğ•œ E
instâœâµ : NormedAddCommGroup F
instâœâ´ : NormedSpace ğ•œ F
instâœÂ³ : NormedAddCommGroup G
instâœÂ² : NormedSpace ğ•œ G
instâœÂ¹ : NormedAddCommGroup H
instâœ : NormedSpace ğ•œ H
q : FormalMultilinearSeries ğ•œ F G
p : FormalMultilinearSeries ğ•œ E F
hq : 0 < q.radius
hp : 0 < p.radius
rq rp : â„â‰¥0
hrp : rp < 1 âˆ§ â†‘rp < p.radius
hrq : rq < 1 âˆ§ â†‘rq < q.radius
rp_pos : 0 < rp
rq_pos : 0 < rq
Cq : â„â‰¥0
_hCq0 : Cq > 0
hCq : âˆ€ (n : â„•), â€–q nâ€–â‚Š * rq ^ n â‰¤ Cq
Cp : â„â‰¥0
hCp1 : Cp â‰¥ 1
hCp : âˆ€ (n : â„•), â€–p nâ€–â‚Š * rp ^ n â‰¤ Cp
r0 : â„â‰¥0 := (4 * Cp)â»Â¹
r0_pos : 0 < r0
r : â„â‰¥0 := rp * rq * r0
r_pos : 0 < r
I : âˆ€ (i : (n : â„•) Ã— Composition n), â€–q.compAlongComposition p i.sndâ€–â‚Š * r ^ i.fst â‰¤ Cq / 4 ^ i.fst
this : âˆ€ (n : â„•), HasSum (fun c â†¦ (4 ^ n)â»Â¹) (2 ^ (n - 1) / 4 ^ n)
n : â„•
âŠ¢ 2 ^ n * 2 * 2 = 2 * 2 * 2 ^ n
warning:  `List.get_splitWrtComposition` has been deprecated, use `List.getElem_splitWrtComposition` instead
warning:  `List.get_drop'` has been deprecated, use `List.getElem_drop'` instead
warning:  `List.get_take'` has been deprecated, use `List.getElem_take` instead","theorem comp_summable_nnreal (q : FormalMultilinearSeries ğ•œ F G) (p : FormalMultilinearSeries ğ•œ E F)
    (hq : 0 < q.radius) (hp : 0 < p.radius) :
    âˆƒ r > (0 : â„â‰¥0),
      Summable fun i : Î£ n, Composition n => â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 ",":= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hp) with âŸ¨rp, rp_pos, hrpâŸ©
  simp only [lt_min_iff, ENNReal.coe_lt_one_iff, ENNReal.coe_pos] at hrp hrq rp_pos rq_pos
  obtain âŸ¨Cq, _hCq0, hCqâŸ© : âˆƒ Cq > 0, âˆ€ n, â€–q nâ€–â‚Š * rq ^ n â‰¤ Cq :=
    q.nnnorm_mul_pow_le_of_lt_radius hrq.2
  obtain âŸ¨Cp, hCp1, hCpâŸ© : âˆƒ Cp â‰¥ 1, âˆ€ n, â€–p nâ€–â‚Š * rp ^ n â‰¤ Cp := by
    rcases p.nnnorm_mul_pow_le_of_lt_radius hrp.2 with âŸ¨Cp, -, hCpâŸ©
    exact âŸ¨max Cp 1, le_max_right _ _, fun n => (hCp n).trans (le_max_left _ _)âŸ©
  let r0 : â„â‰¥0 := (4 * Cp)â»Â¹
  have r0_pos : 0 < r0 := inv_pos.2 (mul_pos zero_lt_four (zero_lt_one.trans_le hCp1))
  set r : â„â‰¥0 := rp * rq * r0
  have r_pos : 0 < r := mul_pos (mul_pos rp_pos rq_pos) r0_pos
  have I :
    âˆ€ i : Î£ n : â„•, Composition n, â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 â‰¤ Cq / 4 ^ i.1 := by
    rintro âŸ¨n, câŸ©
    have A := calc
      â€–q c.lengthâ€–â‚Š * rq ^ n â‰¤ â€–q c.lengthâ€–â‚Š * rq ^ c.length :=
        mul_le_mul' le_rfl (pow_le_pow_of_le_one rq.2 hrq.1.le c.length_le)
      _ â‰¤ Cq := hCq _
    have B := calc
      (âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n = âˆ i, â€–p (c.blocksFun i)â€–â‚Š * rp ^ c.blocksFun i := by
        simp only [Finset.prod_mul_distrib, Finset.prod_pow_eq_pow_sum, c.sum_blocksFun]
      _ â‰¤ âˆ _i : Fin c.length, Cp := Finset.prod_le_prod' fun i _ => hCp _
      _ = Cp ^ c.length := by simp
      _ â‰¤ Cp ^ n := pow_le_pow_right hCp1 c.length_le
    calc
      â€–q.compAlongComposition p câ€–â‚Š * r ^ n â‰¤
          (â€–q c.lengthâ€–â‚Š * âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * r ^ n :=
        mul_le_mul' (q.compAlongComposition_nnnorm p c) le_rfl
      _ = â€–q c.lengthâ€–â‚Š * rq ^ n * ((âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n) * r0 ^ n := by
        ring
      _ â‰¤ Cq * Cp ^ n * r0 ^ n := mul_le_mul' (mul_le_mul' A B) le_rfl
      _ = Cq / 4 ^ n := by
        simp only [r0]
        field_simp [mul_pow, (zero_lt_one.trans_le hCp1).ne']
        ring
  refine âŸ¨r, r_pos, NNReal.summable_of_le I ?_âŸ©
  simp_rw [div_eq_mul_inv]
  refine Summable.mul_left _ ?_
  have : âˆ€ n : â„•, HasSum (fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹) (2 ^ (n - 1) / 4 ^ n) := by
    intro n
    convert hasSum_fintype fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹
    simp [Finset.card_univ, composition_card, div_eq_mul_inv]
  refine NNReal.summable_sigma.2 âŸ¨fun n => (this n).summable, (NNReal.summable_nat_add_iff 1).1 ?_âŸ©
  convert (NNReal.summable_geometric (NNReal.div_lt_one_of_lt one_lt_two)).mul_left (1 / 4) using 1
  ext1 n
  rw [(this _).tsum_eq, add_tsub_cancel_right]
  field_simp [â† mul_assoc, pow_succ, mul_pow, show (4 : â„â‰¥0) = 2 * 2 by norm_num,
    mul_right_comm]","rcases ENNReal.exists_pos_summable_nnreal_of_summable_nnreal hq p.radius with âŸ¨rq, rq_pos, hrqâŸ©"
Mathlib/Algebra/Lie/Weights/Basic.lean,LieModule.disjoint_weightSpace,disjoint_weightSpace,61e05975727e0b1a19d0075b994c53596adb3405,":= by
  rw [LieSubmodule.disjoint_iff_coe_toSubmodule]
  exact Module.End.disjoint_iSup_generalizedEigenspace _ h",error:  unknown constant 'Module.End.disjoint_iSup_generalizedEigenspace',"lemma disjoint_weightSpaceOf [NoZeroSMulDivisors R M] {x : L} {Ï†â‚ Ï†â‚‚ : R} (h : Ï†â‚ â‰  Ï†â‚‚) :
    Disjoint (weightSpaceOf M Ï†â‚ x) (weightSpaceOf M Ï†â‚‚ x) ",":= by
  rw [LieSubmodule.disjoint_iff_coe_toSubmodule]
  exact Module.End.disjoint_iSup_genEigenspace _ h","rw [weightSpaceOf_disjoint_weightSpaceOf, disjoint_weightSpaceOf_disjoint_weightSpaceOf,
  disjoint_weightSpaceOf_disjoint_weightSpaceOf, disjoint_weightSpaceOf]"
Mathlib/Data/Fin/VecNotation.lean,Matrix.vecAlt0_vecAppend,vecAlt0_vecAppend,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  ext i
  simp_rw [Function.comp, bit0, vecAlt0, vecAppend_eq_ite]
  split_ifs with h <;> congr
  Â· rw [Fin.val_mk] at h
    exact (Nat.mod_eq_of_lt h).symm
  Â· rw [Fin.val_mk, not_lt] at h
    simp only [Fin.ext_iff, Fin.val_add, Fin.val_mk, Nat.mod_eq_sub_mod h]
    refine' (Nat.mod_eq_of_lt _).symm
    rw [tsub_lt_iff_left h]
    exact add_lt_add i.2 i.2","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
error:  unknown identifier 'tsub_lt_iff_left'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.32254
case neg.e_a.e_val
Î± : Type u
m n o : â„•
m' : Type u_1
n' : Type u_2
o' : Type u_3
v : Fin n â†’ Î±
i : Fin n
h : n â‰¤ â†‘i + â†‘i
âŠ¢ â†‘i + â†‘i - n < n
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated",theorem vecAlt0_vecAppend (v : Fin n â†’ Î±) : vecAlt0 rfl (vecAppend rfl v v) = v âˆ˜ bit0 ,":= by
  ext i
  simp_rw [Function.comp, bit0, vecAlt0, vecAppend_eq_ite]
  split_ifs with h <;> congr
  Â· rw [Fin.val_mk] at h
    exact (Nat.mod_eq_of_lt h).symm
  Â· rw [Fin.val_mk, not_lt] at h
    simp only [Fin.ext_iff, Fin.val_add, Fin.val_mk, Nat.mod_eq_sub_mod h]
    refine (Nat.mod_eq_of_lt ?_).symm
    omega","rw [vecAlt0_vecAppend, vecAlt0_vecAppend]"
Mathlib/RingTheory/Valuation/Basic.lean,AddValuation.ext_iff,ext_iff,ae8b24f33174f0b9fcd8f2d87ba6c65a18ae9ceb,":=
  FunLike.ext_iff",error:  unknown constant 'FunLike.ext_iff',"theorem ext_iff {vâ‚ vâ‚‚ : Valuation R Î“â‚€} : vâ‚ = vâ‚‚ â†” âˆ€ r, vâ‚ r = vâ‚‚ r ",":=
  DFunLike.ext_iff",constructor
Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean,AlgebraicTopology.AlternatingCofaceMapComplex.d_squared,d_squared,084cfb354233793728fd0ef1054e9b156224e7f6,":= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff, Fin.val_succ,
      Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa using hij
  Â· 
    rintro âŸ¨i, jâŸ© âŸ¨i', j'âŸ© hij hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine' âŸ¨(j'.pred <| _, Fin.castSucc i'), _, _âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_pred_of_lt hij'
    Â· simp only [Fin.castLT_castSucc, Fin.succ_pred]","error:  simp made no progress
error:  simp made no progress
error:  rcases tactic failed: aâœ : Quot.lift (fun l â†¦ (i, j) âˆˆ l) â‹¯ Sá¶œ.val is not an inductive datatype
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #3 provided
error:  no goals to be solved",theorem d_squared (n : â„•) : objD X (n + 1) â‰« objD X n = 0 ,":= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,
      Fin.val_succ, Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij âŸ¨i', j'âŸ© hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine âŸ¨(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'
    Â· simp only [Ï†, Fin.castLT_castSucc, Fin.succ_pred]
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa [S] using hij","simp only [objD, objDD, objDDD, d_squared, d_squared, d_squared, d_squared]"
Mathlib/Combinatorics/SimpleGraph/Operations.lean,SimpleGraph.adj_replaceVertex_iff_of_ne,adj_replaceVertex_iff_of_ne,f61a485edf966de0b09bd70c1edc7f254cd1b0ae,:= by simp [hw],error:  simp made no progress,"lemma adj_replaceVertex_iff_of_ne_left {w : V} (hw : w â‰  t) :
    (G.replaceVertex s t).Adj s w â†” G.Adj s w ",":= by simp [replaceVertex, hw]","simp only [replaceVertex_adj, replaceVertex_adj, adj_replaceVertex_iff_of_ne_left]"
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean,MeasureTheory.FinStronglyMeasurable.exists_set_sigmaFinite,exists_set_sigmaFinite,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases hf with âŸ¨fs, hT_lt_top, h_approxâŸ©
  let T n := support (fs n)
  have hT_meas : âˆ€ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)
  let t := â‹ƒ n, T n
  refine âŸ¨t, MeasurableSet.iUnion hT_meas, ?_, ?_âŸ©
  Â· have h_fs_zero : âˆ€ n, âˆ€ x âˆˆ tá¶œ, fs n x = 0 := by
      intro n x hxt
      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt
      simpa [T] using hxt n
    refine fun x hxt => tendsto_nhds_unique (h_approx x) ?_
    rw [funext fun n => h_fs_zero n x hxt]
    exact tendsto_const_nhds
  Â· refine âŸ¨âŸ¨âŸ¨fun n => tá¶œ âˆª T n, fun _ => trivial, fun n => ?_, ?_âŸ©âŸ©âŸ©
    Â· rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,
        Set.compl_inter_self t, Set.empty_union]
      exact (measure_mono (Set.inter_subset_left _ _)).trans_lt (hT_lt_top n)
    Â· rw [â† Set.union_iUnion tá¶œ T]
      exact Set.compl_union_self _","error:  function expected at
  inter_subset_left ?m.176273
term has type
  ?m.176272 âˆˆ ?m.176270","theorem exists_set_sigmaFinite [Zero Î²] [TopologicalSpace Î²] [T2Space Î²]
    (hf : FinStronglyMeasurable f Î¼) :
    âˆƒ t, MeasurableSet t âˆ§ (âˆ€ x âˆˆ tá¶œ, f x = 0) âˆ§ SigmaFinite (Î¼.restrict t) ",":= by
  rcases hf with âŸ¨fs, hT_lt_top, h_approxâŸ©
  let T n := support (fs n)
  have hT_meas : âˆ€ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)
  let t := â‹ƒ n, T n
  refine âŸ¨t, MeasurableSet.iUnion hT_meas, ?_, ?_âŸ©
  Â· have h_fs_zero : âˆ€ n, âˆ€ x âˆˆ tá¶œ, fs n x = 0 := by
      intro n x hxt
      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt
      simpa [T] using hxt n
    refine fun x hxt => tendsto_nhds_unique (h_approx x) ?_
    rw [funext fun n => h_fs_zero n x hxt]
    exact tendsto_const_nhds
  Â· refine âŸ¨âŸ¨âŸ¨fun n => tá¶œ âˆª T n, fun _ => trivial, fun n => ?_, ?_âŸ©âŸ©âŸ©
    Â· rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,
        Set.compl_inter_self t, Set.empty_union]
      exact (measure_mono Set.inter_subset_left).trans_lt (hT_lt_top n)
    Â· rw [â† Set.union_iUnion tá¶œ T]
      exact Set.compl_union_self _","refine âŸ¨exists_set_sigmaFinite, exists_set_sigmaFinite, ?_, ?_âŸ©"
Mathlib/Data/Set/Subset.lean,Set.image_val_iInter,image_val_iInter,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  (Subtype.val_injective.injOn _).image_iInter_eq","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Function.Injective.injOn Subtype.val_injective ?m.22532
has type
  âˆ€ â¦ƒxâ‚‚ : Subtype ?m.22509â¦„, xâ‚‚ âˆˆ ?m.22530 â†’ â†‘?m.22531 = â†‘xâ‚‚ â†’ ?m.22531 = xâ‚‚","lemma image_val_iInter [Nonempty Î¹] : (â†‘(â‹‚ i, t i) : Set Î±) = â‹‚ i, (â†‘(t i) : Set Î±) ",":=
  Subtype.val_injective.injOn.image_iInter_eq","simp [Set.iInter_eq_iInter, Set.iInter_eq_iInter]"
Mathlib/Topology/Compactness/Lindelof.lean,IsLindelof.elim_countable_subcover,IsLindelof.elim_countable_subcover,ad1607ddeaaaa81b831dcb37615796d3fa93c9fe,":= by
  have he : âˆƒ r : Set Î¹, r.Countable âˆ§ âˆ… âŠ† â‹ƒ i âˆˆ r, U i := by use âˆ…; simp
  have hmono : âˆ€ â¦ƒs t : Set Xâ¦„, s âŠ† t â†’ (âˆƒ r : Set Î¹, r.Countable âˆ§ t âŠ† â‹ƒ i âˆˆ r, U i)
      â†’ (âˆƒ r : Set Î¹, r.Countable âˆ§ s âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro _ _ hst âŸ¨r, âŸ¨hrcountable,hsubâŸ©âŸ©
    exact âŸ¨r,hrcountable,Subset.trans hst hsubâŸ©
  have hcountable_union : âˆ€ (S : Set (Set X)), S.Countable
      â†’ (âˆ€ s âˆˆ S, âˆƒ r : Set Î¹, r.Countable âˆ§ (s âŠ† â‹ƒ i âˆˆ r, U i))
      â†’ âˆƒ r : Set Î¹, r.Countable âˆ§ (â‹ƒ s âˆˆ S, s âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro S hS hsr
    choose! r hr using hsr
    use â‹ƒ s âˆˆ S, r s
    constructor
    Â· refine (Countable.biUnion_iff hS).mpr ?h.left.a
      intro s hs
      apply (hr s hs).1
    Â· refine iUnionâ‚‚_subset ?h.right.h
      intro i
      simp
      intro is
      have h := (hr i is).2
      intro x hx
      exact mem_biUnion is (h hx)
  have h_nhds : âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, âˆƒ r : Set Î¹, r.Countable âˆ§ (t âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro x hx
    let âŸ¨i, hiâŸ© := mem_iUnion.1 (hsU hx)
    refine' âŸ¨U i, mem_nhdsWithin_of_mem_nhds (IsOpen.mem_nhds (hUo i) hi),{i}, ?_âŸ©
    constructor <;> simp
    exact Subset.refl _
  exact hs.induction_on he hmono hcountable_union h_nhds","error:  type mismatch
  he
has type
  âˆƒ r, r.Countable âˆ§ âˆ… âŠ† â‹ƒ i âˆˆ r, U i : Prop
but is expected to have type
  âˆ€ â¦ƒs t : Set Xâ¦„,
    s âŠ† t â†’
      ((âˆ€ x âˆˆ t, âˆƒ t_1 âˆˆ ğ“[t] x, âˆƒ r, r.Countable âˆ§ t_1 âŠ† â‹ƒ i âˆˆ r, U i) â†’ âˆƒ r, r.Countable âˆ§ t âŠ† â‹ƒ i âˆˆ r, U i) â†’
        (âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, âˆƒ r, r.Countable âˆ§ t âŠ† â‹ƒ i âˆˆ r, U i) â†’ âˆƒ r, r.Countable âˆ§ s âŠ† â‹ƒ i âˆˆ r, U i : Prop
error:  type mismatch
  hmono
has type
  âˆ€ â¦ƒs t : Set Xâ¦„, s âŠ† t â†’ (âˆƒ r, r.Countable âˆ§ t âŠ† â‹ƒ i âˆˆ r, U i) â†’ âˆƒ r, r.Countable âˆ§ s âŠ† â‹ƒ i âˆˆ r, U i : Prop
but is expected to have type
  âˆ€ (S : Set (Set X)),
    S.Countable â†’
      (âˆ€ s âˆˆ S, (âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, âˆƒ r, r.Countable âˆ§ t âŠ† â‹ƒ i âˆˆ r, U i) â†’ âˆƒ r, r.Countable âˆ§ s âŠ† â‹ƒ i âˆˆ r, U i) â†’
        (âˆ€ x âˆˆ â‹ƒâ‚€ S, âˆƒ t âˆˆ ğ“[â‹ƒâ‚€ S] x, âˆƒ r, r.Countable âˆ§ t âŠ† â‹ƒ i âˆˆ r, U i) â†’
          âˆƒ r, r.Countable âˆ§ â‹ƒâ‚€ S âŠ† â‹ƒ i âˆˆ r, U i : Prop
error:  type mismatch
  hcountable_union
has type
  âˆ€ (S : Set (Set X)),
    S.Countable â†’ (âˆ€ s âˆˆ S, âˆƒ r, r.Countable âˆ§ s âŠ† â‹ƒ i âˆˆ r, U i) â†’ âˆƒ r, r.Countable âˆ§ â‹ƒ s âˆˆ S, s âŠ† â‹ƒ i âˆˆ r, U i : Prop
but is expected to have type
  âˆ€ x âˆˆ s,
    âˆƒ t âˆˆ ğ“[s] x,
      (âˆ€ x âˆˆ t, âˆƒ t_1 âˆˆ ğ“[t] x, âˆƒ r, r.Countable âˆ§ t_1 âŠ† â‹ƒ i âˆˆ r, U i) â†’ âˆƒ r, r.Countable âˆ§ t âŠ† â‹ƒ i âˆˆ r, U i : Prop","theorem IsLindelof.elim_countable_subcover {Î¹ : Type v} (hs : IsLindelof s) (U : Î¹ â†’ Set X)
    (hUo : âˆ€ i, IsOpen (U i)) (hsU : s âŠ† â‹ƒ i, U i) :
    âˆƒ r : Set Î¹, r.Countable âˆ§ (s âŠ† â‹ƒ i âˆˆ r, U i) ",":= by
  have hmono : âˆ€ â¦ƒs t : Set Xâ¦„, s âŠ† t â†’ (âˆƒ r : Set Î¹, r.Countable âˆ§ t âŠ† â‹ƒ i âˆˆ r, U i)
      â†’ (âˆƒ r : Set Î¹, r.Countable âˆ§ s âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro _ _ hst âŸ¨r, âŸ¨hrcountable, hsubâŸ©âŸ©
    exact âŸ¨r, hrcountable, Subset.trans hst hsubâŸ©
  have hcountable_union : âˆ€ (S : Set (Set X)), S.Countable
      â†’ (âˆ€ s âˆˆ S, âˆƒ r : Set Î¹, r.Countable âˆ§ (s âŠ† â‹ƒ i âˆˆ r, U i))
      â†’ âˆƒ r : Set Î¹, r.Countable âˆ§ (â‹ƒâ‚€ S âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro S hS hsr
    choose! r hr using hsr
    refine âŸ¨â‹ƒ s âˆˆ S, r s, hS.biUnion_iff.mpr (fun s hs â†¦ (hr s hs).1), ?_âŸ©
    refine sUnion_subset ?h.right.h
    simp only [mem_iUnion, exists_prop, iUnion_exists, biUnion_and']
    exact fun i is x hx â†¦ mem_biUnion is ((hr i is).2 hx)
  have h_nhds : âˆ€ x âˆˆ s, âˆƒ t âˆˆ ğ“[s] x, âˆƒ r : Set Î¹, r.Countable âˆ§ (t âŠ† â‹ƒ i âˆˆ r, U i) := by
    intro x hx
    let âŸ¨i, hiâŸ© := mem_iUnion.1 (hsU hx)
    refine âŸ¨U i, mem_nhdsWithin_of_mem_nhds ((hUo i).mem_nhds hi), {i}, by simp, ?_âŸ©
    simp only [mem_singleton_iff, iUnion_iUnion_eq_left]
    exact Subset.refl _
  exact hs.induction_on hmono hcountable_union h_nhds","rcases exists_countable_subcover_elim_countable_subcover hUo hUo hsU with âŸ¨r', r'U, hr'UâŸ©"
Mathlib/Data/Multiset/Basic.lean,Multiset.count_map_eq_count,count_map_eq_count,e609eeb4638d90bf8185c6ea72c5d41e94387a3b,":=
  by
  suffices (filter (fun a : Î± => f a == f x) s).count x = card (filter (fun a : Î± => f a == f x) s)
    by
    rw [count, countp_map, â† this]
    exact count_filter_of_pos $ beq_self_eq_true _
  Â· rw [eq_repeat.2
        âŸ¨rfl, fun b hb => eq_comm.1 ((hf H (mem_filter.1 hb).left) _)âŸ©]
    Â· simp only [count_repeat, eq_self_iff_true, if_true, card_repeat]
    Â· simp only [mem_filter, beq_iff_eq, and_imp, @eq_comm _ (f x), imp_self, implies_true]","warning:  @cons does not have a doc string
warning:  `List.filter_congr'` has been deprecated, use `List.filter_congr` instead
error:  unknown identifier 'countp_map'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.278792
Î± : Type u_1
Î² : Type v
Î³ : Type u_2
instâœÂ¹ : DecidableEq Î±
sâœ : Multiset Î±
instâœ : DecidableEq Î²
f : Î± â†’ Î²
s : Multiset Î±
hf : Set.InjOn f {x | x âˆˆ s}
x : Î±
H : x âˆˆ s
this : count x (filter (fun a â†¦ (f a == f x) = true) s) = card (filter (fun a â†¦ (f a == f x) = true) s)
âŠ¢ countP (fun x_1 â†¦ f x = x_1) (map f s) = count x s
error:  unknown identifier 'eq_repeat'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.278794
Î± : Type u_1
Î² : Type v
Î³ : Type u_2
instâœÂ¹ : DecidableEq Î±
sâœ : Multiset Î±
instâœ : DecidableEq Î²
f : Î± â†’ Î²
s : Multiset Î±
hf : Set.InjOn f {x | x âˆˆ s}
x : Î±
H : x âˆˆ s
âŠ¢ count x (filter (fun a â†¦ (f a == f x) = true) s) = card (filter (fun a â†¦ (f a == f x) = true) s)
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead","theorem count_map_eq_count [DecidableEq Î²] (f : Î± â†’ Î²) (s : Multiset Î±)
    (hf : Set.InjOn f { x : Î± | x âˆˆ s }) (x) (H : x âˆˆ s) : (s.map f).count (f x) = s.count x ",":= by
  suffices (filter (fun a : Î± => f x = f a) s).count x = card (filter (fun a : Î± => f x = f a) s) by
    rw [count, countP_map, â† this]
    exact count_filter_of_pos <| rfl
  Â· rw [eq_replicate_card.2 fun b hb => (hf H (mem_filter.1 hb).left _).symm]
    Â· simp only [count_replicate, eq_self_iff_true, if_true, card_replicate]
    Â· simp only [mem_filter, beq_iff_eq, and_imp, @eq_comm _ (f x), imp_self, implies_true]","rw [count_map_eq_count, count_map_eq_count]"
Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean,Matrix.rank_vecMulVec,Matrix.rank_vecMulVec,bad931b7fc9f31f5ff5b8f408dd19bbe20a9f0e1,":= by
  nontriviality K
  rw [Matrix.vecMulVec_eq, Matrix.toLin'_mul]
  refine le_trans (LinearMap.rank_comp_le_left _ _) ?_
  refine (LinearMap.rank_le_domain _).trans_eq ?_
  rw [rank_fun', Fintype.card_unit, Nat.cast_one]","error:  failed to synthesize
  Unique ?Î¹
use `set_option diagnostics true` to get diagnostic information","theorem Matrix.rank_vecMulVec {K m n : Type u} [CommRing K] [Fintype n]
    [DecidableEq n] (w : m â†’ K) (v : n â†’ K) : (Matrix.vecMulVec w v).toLin'.rank â‰¤ 1 ",":= by
  nontriviality K
  rw [Matrix.vecMulVec_eq (Fin 1), Matrix.toLin'_mul]
  refine le_trans (LinearMap.rank_comp_le_left _ _) ?_
  refine (LinearMap.rank_le_domain _).trans_eq ?_
  rw [rank_fun', Fintype.card_ofSubsingleton, Nat.cast_one]","rw [â† Matrix.rank_vecMulVec_eq_rank, Matrix.rank_vecMulVec_eq]"
Mathlib/Topology/Algebra/Order/LiminfLimsup.lean,tendsto_of_liminf_eq_limsup,tendsto_of_liminf_eq_limsup,8f4f347b47261491fcaffde5530e0b5f8490768e,":=
  le_nhds_of_limsupâ‚›_eq_liminfâ‚› h h' hsup hinf",error:  unknown identifier 'le_nhds_of_limsupâ‚›_eq_liminfâ‚›',"theorem tendsto_of_liminf_eq_limsup {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} (hinf : liminf u f = a)
    (hsup : limsup u f = a) (h : f.IsBoundedUnder (Â· â‰¤ Â·) u := by isBoundedDefault)
    (h' : f.IsBoundedUnder (Â· â‰¥ Â·) u := by isBoundedDefault) : Tendsto u f (ğ“ a) ",":=
  le_nhds_of_limsSup_eq_limsInf h h' hsup hinf",rw [tendsto_of_liminf_eq_limsup]
Mathlib/LinearAlgebra/Matrix/PosDef.lean,Matrix.PosDef.eigenvalues_pos,eigenvalues_pos,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [hA.1.eigenvalues_eq, hA.1.transpose_eigenvectorMatrix_apply]
  exact hA.re_dotProduct_pos <| hA.1.eigenvectorBasis.orthonormal.ne_zero i","error:  invalid field 'transpose_eigenvectorMatrix_apply', the environment does not contain 'Matrix.IsHermitian.transpose_eigenvectorMatrix_apply'
  hA.left
has type
  A.IsHermitian
error:  invalid field 'transpose_eigenvectorMatrix_apply', the environment does not contain 'Eq.transpose_eigenvectorMatrix_apply'
  hA.left
has type
  Aá´´ = A
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.173596
m : Type u_1
n : Type u_2
R : Type u_3
ğ•œ : Type u_4
instâœâ· : Fintype m
instâœâ¶ : Fintype n
instâœâµ : CommRing R
instâœâ´ : PartialOrder R
instâœÂ³ : StarRing R
instâœÂ² : StarOrderedRing R
instâœÂ¹ : RCLike ğ•œ
instâœ : DecidableEq n
A : Matrix n n ğ•œ
hA : A.PosDef
i : n
âŠ¢ 0 <
    RCLike.re
      (star ((WithLp.equiv 2 ((i : n) â†’ (fun x â†¦ ğ•œ) i)) (â‹¯.eigenvectorBasis i)) â¬áµ¥
        A *áµ¥ (WithLp.equiv 2 ((i : n) â†’ (fun x â†¦ ğ•œ) i)) (â‹¯.eigenvectorBasis i))","lemma eigenvalues_pos [DecidableEq n] {A : Matrix n n ğ•œ}
    (hA : Matrix.PosDef A) (i : n) : 0 < hA.1.eigenvalues i ",":= by
  simp only [hA.1.eigenvalues_eq]
  exact hA.re_dotProduct_pos <| hA.1.eigenvectorBasis.orthonormal.ne_zero i","simp [eigenvalues_pos, eigenvalues_pos]"
Mathlib/Topology/Connected/Basic.lean,isPreconnected_of_forall_constant,isPreconnected_of_forall_constant,592e720e2651f6e8a7faf0968b75697c3bcd3b55,":= by
  unfold IsPreconnected
  by_contra'
  rcases this with âŸ¨u, v, u_op, v_op, hsuv, âŸ¨x, x_in_s, x_in_uâŸ©, âŸ¨y, y_in_s, y_in_vâŸ©, HâŸ©
  have hy : y âˆ‰ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y âŸ¨y_in_s, âŸ¨y_in_u, y_in_vâŸ©âŸ©
  have : ContinuousOn u.boolIndicator s := by
    apply (continuousOn_boolIndicator_iff_isClopen _ _).mpr âŸ¨_, _âŸ©
    Â· exact u_op.preimage continuous_subtype_val
    Â· rw [preimage_subtype_coe_eq_compl hsuv H]
      exact (v_op.preimage continuous_subtype_val).isClosed_compl
  simpa [(u.mem_iff_boolIndicator _).mp x_in_u, (u.not_mem_iff_boolIndicator _).mp hy] using
    hs _ this x x_in_s y y_in_s","error:  unknown tactic
error:  unsolved goals
Î± : Type u
Î² : Type v
Î¹ : Type u_1
Ï€ : Î¹ â†’ Type u_2
instâœ : TopologicalSpace Î±
sâœ t u v s : Set Î±
hs : âˆ€ (f : Î± â†’ Bool), ContinuousOn f s â†’ âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, f x = f y
âŠ¢ âˆ€ (u v : Set Î±), IsOpen u â†’ IsOpen v â†’ s âŠ† u âˆª v â†’ (s âˆ© u).Nonempty â†’ (s âˆ© v).Nonempty â†’ (s âˆ© (u âˆ© v)).Nonempty","theorem isPreconnected_of_forall_constant {s : Set Î±}
    (hs : âˆ€ f : Î± â†’ Bool, ContinuousOn f s â†’ âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, f x = f y) : IsPreconnected s ",":= by
  unfold IsPreconnected
  by_contra!
  rcases this with âŸ¨u, v, u_op, v_op, hsuv, âŸ¨x, x_in_s, x_in_uâŸ©, âŸ¨y, y_in_s, y_in_vâŸ©, HâŸ©
  have hy : y âˆ‰ u := fun y_in_u => eq_empty_iff_forall_not_mem.mp H y âŸ¨y_in_s, âŸ¨y_in_u, y_in_vâŸ©âŸ©
  have : ContinuousOn u.boolIndicator s := by
    apply (continuousOn_boolIndicator_iff_isClopen _ _).mpr âŸ¨_, _âŸ©
    Â· rw [preimage_subtype_coe_eq_compl hsuv H]
      exact (v_op.preimage continuous_subtype_val).isClosed_compl
    Â· exact u_op.preimage continuous_subtype_val
  simpa [(u.mem_iff_boolIndicator _).mp x_in_u, (u.not_mem_iff_boolIndicator _).mp hy] using
    hs _ this x x_in_s y y_in_s",rw [isPreconnected_iff]
Mathlib/Dynamics/OmegaLimit.lean,nonempty_omegaLimit_of_isCompact_absorbing,nonempty_omegaLimit_of_isCompact_absorbing,ffb5dddeb20329610a2c898c4125ae8bea987862,":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  rw [omegaLimit_eq_interáµ¢_inter _ _ _ hvâ‚]
  apply IsCompact.nonempty_interáµ¢_of_directed_nonempty_compact_closed
  Â· rintro âŸ¨uâ‚, huâ‚âŸ© âŸ¨uâ‚‚, huâ‚‚âŸ©
    use âŸ¨uâ‚ âˆ© uâ‚‚, inter_mem huâ‚ huâ‚‚âŸ©
    constructor
    all_goals exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) Subset.rfl)
  Â· intro u
    have hn : (image2 Ï• (u âˆ© v) s).Nonempty :=
      Nonempty.image2 (Filter.nonempty_of_mem (inter_mem u.prop hvâ‚)) hs
    exact hn.mono subset_closure
  Â· intro
    apply isCompact_of_isClosed_subset hcâ‚ isClosed_closure
    calc
      _ âŠ† closure (image2 Ï• v s) := closure_mono (image2_subset (inter_subset_right _ _) Subset.rfl)
      _ âŠ† c := hvâ‚‚
      
  Â· exact fun _ â†¦ isClosed_closure","warning:  @omegaLimit does not have a doc string
error:  unknown identifier 'omegaLimit_eq_interáµ¢_inter'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.54074
case intro.intro
Ï„ : Type u_1
Î± : Type u_2
Î² : Type u_3
Î¹ : Type u_4
instâœÂ¹ : TopologicalSpace Î²
f : Filter Ï„
Ï• : Ï„ â†’ Î± â†’ Î²
s sâ‚ sâ‚‚ : Set Î±
instâœ : f.NeBot
c : Set Î²
hcâ‚ : IsCompact c
hs : s.Nonempty
v : Set Ï„
hvâ‚ : v âˆˆ f
hvâ‚‚ : closure (image2 Ï• v s) âŠ† c
âŠ¢ (Ï‰ f Ï• s).Nonempty","theorem nonempty_omegaLimit_of_isCompact_absorbing [NeBot f] {c : Set Î²} (hcâ‚ : IsCompact c)
    (hcâ‚‚ : âˆƒ v âˆˆ f, closure (image2 Ï• v s) âŠ† c) (hs : s.Nonempty) : (Ï‰ f Ï• s).Nonempty ",":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚]
  apply IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed
  Â· rintro âŸ¨uâ‚, huâ‚âŸ© âŸ¨uâ‚‚, huâ‚‚âŸ©
    use âŸ¨uâ‚ âˆ© uâ‚‚, inter_mem huâ‚ huâ‚‚âŸ©
    constructor
    all_goals exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) Subset.rfl)
  Â· intro u
    have hn : (image2 Ï• (u âˆ© v) s).Nonempty :=
      Nonempty.image2 (Filter.nonempty_of_mem (inter_mem u.prop hvâ‚)) hs
    exact hn.mono subset_closure
  Â· intro
    apply hcâ‚.of_isClosed_subset isClosed_closure
    calc
      _ âŠ† closure (image2 Ï• v s) := closure_mono (image2_subset inter_subset_right Subset.rfl)
      _ âŠ† c := hvâ‚‚
  Â· exact fun _ â†¦ isClosed_closure","rcases exists_nonempty_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaCt_absorbing
  nonempty_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaCt_absorbing
  nonempty_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaCt_absorbing
  nonempty_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaCt_absorbing hcâ‚ hcâ‚‚ hcâ‚ hcâ‚‚ hcâ‚ hcâ‚‚ hcâ‚ hcâ‚‚ with
  âŸ¨v, hv, hvfâŸ©"
Mathlib/MeasureTheory/Decomposition/Jordan.lean,MeasureTheory.JordanDecomposition.toSignedMeasure_injective,toSignedMeasure_injective,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  intro jâ‚ jâ‚‚ hj
  obtain âŸ¨S, hSâ‚, hSâ‚‚, hSâ‚ƒ, hSâ‚„, hSâ‚…âŸ© := jâ‚.exists_compl_positive_negative
  obtain âŸ¨T, hTâ‚, hTâ‚‚, hTâ‚ƒ, hTâ‚„, hTâ‚…âŸ© := jâ‚‚.exists_compl_positive_negative
  rw [â† hj] at hTâ‚‚ hTâ‚ƒ
  obtain âŸ¨hSTâ‚, -âŸ© :=
    of_symmDiff_compl_positive_negative hSâ‚.compl hTâ‚.compl âŸ¨hSâ‚ƒ, (compl_compl S).symm â–¸ hSâ‚‚âŸ©
      âŸ¨hTâ‚ƒ, (compl_compl T).symm â–¸ hTâ‚‚âŸ©
  refine' eq_of_posPart_eq_posPart _ hj
  ext1 i hi
  have hÎ¼â‚ : (jâ‚.posPart i).toReal = jâ‚.toSignedMeasure (i âˆ© Sá¶œ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hSâ‚.compl),
      show jâ‚.negPart (i âˆ© Sá¶œ) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚… â–¸ measure_mono (Set.inter_subset_right _ _)),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i S]
    rw [measure_union,
      show jâ‚.posPart (i âˆ© S) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚„ â–¸ measure_mono (Set.inter_subset_right _ _)),
      zero_add]
    Â· refine'
        Set.disjoint_of_subset_left (Set.inter_subset_right _ _)
          (Set.disjoint_of_subset_right (Set.inter_subset_right _ _) disjoint_compl_right)
    Â· exact hi.inter hSâ‚.compl
  have hÎ¼â‚‚ : (jâ‚‚.posPart i).toReal = jâ‚‚.toSignedMeasure (i âˆ© Tá¶œ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hTâ‚.compl),
      show jâ‚‚.negPart (i âˆ© Tá¶œ) = 0 from
        nonpos_iff_eq_zero.1 (hTâ‚… â–¸ measure_mono (Set.inter_subset_right _ _)),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i T]
    rw [measure_union,
      show jâ‚‚.posPart (i âˆ© T) = 0 from
        nonpos_iff_eq_zero.1 (hTâ‚„ â–¸ measure_mono (Set.inter_subset_right _ _)),
      zero_add]
    Â· exact
        Set.disjoint_of_subset_left (Set.inter_subset_right _ _)
          (Set.disjoint_of_subset_right (Set.inter_subset_right _ _) disjoint_compl_right)
    Â· exact hi.inter hTâ‚.compl
  rw [â† ENNReal.toReal_eq_toReal (measure_ne_top _ _) (measure_ne_top _ _), hÎ¼â‚, hÎ¼â‚‚, â† hj]
  exact of_inter_eq_of_symmDiff_eq_zero_positive hSâ‚.compl hTâ‚.compl hi hSâ‚ƒ hTâ‚ƒ hSTâ‚","error:  function expected at
  Set.inter_subset_right ?m.66442
term has type
  ?m.66441 âˆˆ ?m.66440
error:  function expected at
  Set.inter_subset_right ?m.67049
term has type
  ?m.67048 âˆˆ ?m.67047
error:  function expected at
  Set.inter_subset_right ?m.67565
term has type
  ?m.67564 âˆˆ ?m.67563
error:  function expected at
  Set.inter_subset_right ?m.67623
term has type
  ?m.67622 âˆˆ ?m.67621
error:  unsolved goals
case hd
Î± : Type u_1
Î² : Type u_2
instâœ : MeasurableSpace Î±
jâ‚ jâ‚‚ : JordanDecomposition Î±
hj : jâ‚.toSignedMeasure = jâ‚‚.toSignedMeasure
S : Set Î±
hSâ‚ : MeasurableSet S
hSâ‚‚ : VectorMeasure.restrict jâ‚.toSignedMeasure S â‰¤ VectorMeasure.restrict 0 S
hSâ‚ƒ : VectorMeasure.restrict 0 Sá¶œ â‰¤ VectorMeasure.restrict jâ‚.toSignedMeasure Sá¶œ
hSâ‚„ : jâ‚.posPart S = 0
hSâ‚… : jâ‚.negPart Sá¶œ = 0
T : Set Î±
hTâ‚ : MeasurableSet T
hTâ‚‚ : VectorMeasure.restrict jâ‚.toSignedMeasure T â‰¤ VectorMeasure.restrict 0 T
hTâ‚ƒ : VectorMeasure.restrict 0 Tá¶œ â‰¤ VectorMeasure.restrict jâ‚.toSignedMeasure Tá¶œ
hTâ‚„ : jâ‚‚.posPart T = 0
hTâ‚… : jâ‚‚.negPart Tá¶œ = 0
hSTâ‚ : â†‘jâ‚.toSignedMeasure (symmDiff Sá¶œ Tá¶œ) = 0
i : Set Î±
hi : MeasurableSet i
âŠ¢ Set Î±
error:  function expected at
  Set.inter_subset_right ?m.68398
term has type
  ?m.68397 âˆˆ ?m.68396
error:  function expected at
  Set.inter_subset_right ?m.68871
term has type
  ?m.68870 âˆˆ ?m.68869
error:  function expected at
  Set.inter_subset_right ?m.69042
term has type
  ?m.69041 âˆˆ ?m.69040
error:  function expected at
  Set.inter_subset_right ?m.69100
term has type
  ?m.69099 âˆˆ ?m.69098",theorem toSignedMeasure_injective : Injective <| @JordanDecomposition.toSignedMeasure Î± _ ,":= by
  intro jâ‚ jâ‚‚ hj
  obtain âŸ¨S, hSâ‚, hSâ‚‚, hSâ‚ƒ, hSâ‚„, hSâ‚…âŸ© := jâ‚.exists_compl_positive_negative
  obtain âŸ¨T, hTâ‚, hTâ‚‚, hTâ‚ƒ, hTâ‚„, hTâ‚…âŸ© := jâ‚‚.exists_compl_positive_negative
  rw [â† hj] at hTâ‚‚ hTâ‚ƒ
  obtain âŸ¨hSTâ‚, -âŸ© :=
    of_symmDiff_compl_positive_negative hSâ‚.compl hTâ‚.compl âŸ¨hSâ‚ƒ, (compl_compl S).symm â–¸ hSâ‚‚âŸ©
      âŸ¨hTâ‚ƒ, (compl_compl T).symm â–¸ hTâ‚‚âŸ©
  refine eq_of_posPart_eq_posPart ?_ hj
  ext1 i hi
  have hÎ¼â‚ : (jâ‚.posPart i).toReal = jâ‚.toSignedMeasure (i âˆ© Sá¶œ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hSâ‚.compl),
      show jâ‚.negPart (i âˆ© Sá¶œ) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚… â–¸ measure_mono Set.inter_subset_right),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i S]
    rw [measure_union,
      show jâ‚.posPart (i âˆ© S) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚„ â–¸ measure_mono Set.inter_subset_right),
      zero_add]
    Â· refine
        Set.disjoint_of_subset_left Set.inter_subset_right
          (Set.disjoint_of_subset_right Set.inter_subset_right disjoint_compl_right)
    Â· exact hi.inter hSâ‚.compl
  have hÎ¼â‚‚ : (jâ‚‚.posPart i).toReal = jâ‚‚.toSignedMeasure (i âˆ© Tá¶œ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hTâ‚.compl),
      show jâ‚‚.negPart (i âˆ© Tá¶œ) = 0 from
        nonpos_iff_eq_zero.1 (hTâ‚… â–¸ measure_mono Set.inter_subset_right),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i T]
    rw [measure_union,
      show jâ‚‚.posPart (i âˆ© T) = 0 from
        nonpos_iff_eq_zero.1 (hTâ‚„ â–¸ measure_mono Set.inter_subset_right),
      zero_add]
    Â· exact
        Set.disjoint_of_subset_left Set.inter_subset_right
          (Set.disjoint_of_subset_right Set.inter_subset_right disjoint_compl_right)
    Â· exact hi.inter hTâ‚.compl
  rw [â† ENNReal.toReal_eq_toReal (measure_ne_top _ _) (measure_ne_top _ _), hÎ¼â‚, hÎ¼â‚‚, â† hj]
  exact of_inter_eq_of_symmDiff_eq_zero_positive hSâ‚.compl hTâ‚.compl hi hSâ‚ƒ hTâ‚ƒ hSTâ‚",rw [JordanDecomposition.toSignedMeasure_injective]
Mathlib/RingTheory/FiniteType.lean,MonoidAlgebra.freeAlgebra_lift_of_surjective_of_closure,freeAlgebra_lift_of_surjective_of_closure,5fb9beab28702fb284701d494bc9b7c5f52fef53,":= by
  intro f
  induction' f using induction_on with m f g ihf ihg r f ih
  Â· have : m âˆˆ closure S := hS.symm â–¸ mem_top _
    refine' closure_induction this (fun m hm => _) _ _
    Â· exact âŸ¨FreeAlgebra.Î¹ R âŸ¨m, hmâŸ©, FreeAlgebra.lift_Î¹_apply _ _âŸ©
    Â· exact âŸ¨1, AlgHom.map_one _âŸ©
    Â· rintro mâ‚ mâ‚‚ âŸ¨Pâ‚, hPâ‚âŸ© âŸ¨Pâ‚‚, hPâ‚‚âŸ©
      exact
        âŸ¨Pâ‚ * Pâ‚‚, by
          rw [AlgHom.map_mul, hPâ‚, hPâ‚‚, of_apply, of_apply, of_apply, single_mul_single,
            one_mul]; rflâŸ©
  Â· rcases ihf with âŸ¨P, rflâŸ©
    rcases ihg with âŸ¨Q, rflâŸ©
    exact âŸ¨P + Q, AlgHom.map_add _ _ _âŸ©
  Â· rcases ih with âŸ¨P, rflâŸ©
    exact âŸ¨r â€¢ P, AlgHom.map_smul _ _ _âŸ©","error:  ambiguous, possible interpretations 
  Submodule.closure_induction ?m.110689 ?m.110690 ?m.110691
    ?m.110692 : âˆƒ a, ((FreeAlgebra.lift R) fun s â†¦ of' R M â†‘s) a = (of R M) (Multiplicative.ofAdd m)
  
  AddSubmonoid.closure_induction this ?m.111012 ?m.111013
    ?m.111014 : âˆƒ a, ((FreeAlgebra.lift R) fun s â†¦ of' R M â†‘s) a = (of R M) (Multiplicative.ofAdd m)
error:  no goals to be solved","theorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}
    (hS : closure S = âŠ¤) :
    Function.Surjective
      (FreeAlgebra.lift R fun s : S => of' R M â†‘s : FreeAlgebra R S â†’ R[M]) ",":= by
  intro f
  induction' f using induction_on with m f g ihf ihg r f ih
  Â· have : m âˆˆ closure S := hS.symm â–¸ mem_top _
    refine AddSubmonoid.closure_induction this (fun m hm => ?_) ?_ ?_
    Â· exact âŸ¨FreeAlgebra.Î¹ R âŸ¨m, hmâŸ©, FreeAlgebra.lift_Î¹_apply _ _âŸ©
    Â· exact âŸ¨1, AlgHom.map_one _âŸ©
    Â· rintro mâ‚ mâ‚‚ âŸ¨Pâ‚, hPâ‚âŸ© âŸ¨Pâ‚‚, hPâ‚‚âŸ©
      exact
        âŸ¨Pâ‚ * Pâ‚‚, by
          rw [AlgHom.map_mul, hPâ‚, hPâ‚‚, of_apply, of_apply, of_apply, single_mul_single,
            one_mul]; rflâŸ©
  Â· rcases ihf with âŸ¨P, rflâŸ©
    rcases ihg with âŸ¨Q, rflâŸ©
    exact âŸ¨P + Q, AlgHom.map_add _ _ _âŸ©
  Â· rcases ih with âŸ¨P, rflâŸ©
    exact âŸ¨r â€¢ P, AlgHom.map_smul _ _ _âŸ©",apply FreeAlgebra.lift_surjective_of_surjective
Mathlib/Probability/Distributions/Gaussian.lean,ProbabilityTheory.gaussianReal_map_const_mul,gaussianReal_map_const_mul,62a9ca63fe8a39ea0004bbc5dbf652532269c0b1,":= by
  by_cases hv : v = 0
  Â· simp only [hv, mul_zero, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.const_mul c) Î¼
  by_cases hc : c = 0
  Â· simp only [hc, zero_mul, ne_eq, abs_zero, mul_eq_zero]
    rw [Measure.map_const]
    simp only [ne_eq, measure_univ, one_smul, mul_eq_zero]
    convert (gaussianReal_zero_var 0).symm
    simp only [ne_eq, zero_pow', mul_eq_zero, hv, or_false, not_false_eq_true]
    rfl
  let e : â„ â‰ƒáµ â„ := (Homeomorph.mulLeftâ‚€ c hc).symm.toMeasurableEquiv
  have he' : âˆ€ x, HasDerivAt e ((fun _ â†¦ câ»Â¹) x) x := by
    suffices âˆ€ x, HasDerivAt (fun x => câ»Â¹ * x) (câ»Â¹ * 1) x by rwa [mul_one] at this
    exact fun _ â†¦ HasDerivAt.const_mul _ (hasDerivAt_id _)
  change (gaussianReal Î¼ v).map e.symm = gaussianReal (c * Î¼) (âŸ¨c^2, sq_nonneg _âŸ© * v)
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs']
  simp only [MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, ne_eq, mul_eq_zero]
  rw [gaussianReal_apply_eq_integral _ _ s']
  swap
  Â· simp only [ne_eq, mul_eq_zero, hv, or_false]
    rw [â† NNReal.coe_eq]
    simp [hc]
  simp only [Homeomorph.mulLeftâ‚€, Equiv.toFun_as_coe, Equiv.mulLeftâ‚€_apply, Equiv.invFun_as_coe,
    Equiv.mulLeftâ‚€_symm_apply, Homeomorph.toMeasurableEquiv_coe, Homeomorph.homeomorph_mk_coe_symm,
    Equiv.coe_fn_symm_mk, gaussianPDFReal_inv_mul hc]
  congr with x
  suffices |câ»Â¹| * |c| = 1 by rw [â† mul_assoc, this, one_mul]
  rw [abs_inv, inv_mul_cancel]
  rwa [ne_eq, abs_eq_zero]","error:  unknown identifier 'zero_pow''
error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case h.e'_3.h.e'_2
Î¼ : â„
v : â„â‰¥0
c : â„
hv : Â¬v = 0
hc : c = 0
âŠ¢ âŸ¨0 ^ 2, â‹¯âŸ© = 0
error:  simp made no progress","lemma gaussianReal_map_const_mul (c : â„) :
    (gaussianReal Î¼ v).map (c * Â·) = gaussianReal (c * Î¼) (âŸ¨c^2, sq_nonneg _âŸ© * v) ",":= by
  by_cases hv : v = 0
  Â· simp only [hv, mul_zero, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.const_mul c) Î¼
  by_cases hc : c = 0
  Â· simp only [hc, zero_mul, ne_eq, abs_zero, mul_eq_zero]
    rw [Measure.map_const]
    simp only [ne_eq, measure_univ, one_smul, mul_eq_zero]
    convert (gaussianReal_zero_var 0).symm
    simp only [ne_eq, zero_pow, mul_eq_zero, hv, or_false, not_false_eq_true]
    rfl
  let e : â„ â‰ƒáµ â„ := (Homeomorph.mulLeftâ‚€ c hc).symm.toMeasurableEquiv
  have he' : âˆ€ x, HasDerivAt e ((fun _ â†¦ câ»Â¹) x) x := by
    suffices âˆ€ x, HasDerivAt (fun x => câ»Â¹ * x) (câ»Â¹ * 1) x by rwa [mul_one] at this
    exact fun _ â†¦ HasDerivAt.const_mul _ (hasDerivAt_id _)
  change (gaussianReal Î¼ v).map e.symm = gaussianReal (c * Î¼) (âŸ¨c^2, sq_nonneg _âŸ© * v)
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs',
    gaussianReal_apply_eq_integral _ _ s']
  swap
  Â· simp only [ne_eq, mul_eq_zero, hv, or_false]
    rw [â† NNReal.coe_inj]
    simp [hc]
  simp only [e, Homeomorph.mulLeftâ‚€, Equiv.toFun_as_coe, Equiv.mulLeftâ‚€_apply, Equiv.invFun_as_coe,
    Equiv.mulLeftâ‚€_symm_apply, Homeomorph.toMeasurableEquiv_coe, Homeomorph.homeomorph_mk_coe_symm,
    Equiv.coe_fn_symm_mk, gaussianPDFReal_inv_mul hc]
  congr with x
  suffices |câ»Â¹| * |c| = 1 by rw [â† mul_assoc, this, one_mul]
  rw [abs_inv, inv_mul_cancel]
  rwa [ne_eq, abs_eq_zero]","simp [gaussianReal_map_const_mul, gaussianReal_map_const_mul]"
Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean,CategoryTheory.Pretriangulated.exists_iso_of_arrow_iso,exists_iso_of_arrow_iso,afe025caf56711b57f2f34e9ae25ec16a609156d,":= by
  obtain âŸ¨Ï†, âŸ¨hÏ†â‚, hÏ†â‚‚âŸ©âŸ© :=
    complete_distinguished_triangle_morphism' Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ e.hom.left e.hom.right e.hom.w.symm
  have : IsIso Ï†.homâ‚ := by rw [hÏ†â‚] ; infer_instance
  have : IsIso Ï†.homâ‚‚ := by rw [hÏ†â‚‚] ; infer_instance
  have : IsIso Ï†.homâ‚ƒ := isIsoâ‚ƒ_of_isIsoâ‚â‚‚ Ï† hTâ‚ hTâ‚‚ inferInstance inferInstance
  exact âŸ¨asIso Ï†, hÏ†â‚, hÏ†â‚‚âŸ©","error:  unknown identifier 'complete_distinguished_triangle_morphism''
error:  rcases tactic failed: xâœ : ?m.221813 is not an inductive datatype","lemma exists_iso_of_arrow_iso (Tâ‚ Tâ‚‚ : Triangle C) (hTâ‚ : Tâ‚ âˆˆ distTriang C)
    (hTâ‚‚ : Tâ‚‚ âˆˆ distTriang C) (e : Arrow.mk Tâ‚.morâ‚ â‰… Arrow.mk Tâ‚‚.morâ‚) :
    âˆƒ (e' : Tâ‚ â‰… Tâ‚‚), e'.hom.homâ‚ = e.hom.left âˆ§ e'.hom.homâ‚‚ = e.hom.right ",":= by
  let Ï† := completeDistinguishedTriangleMorphism Tâ‚ Tâ‚‚ hTâ‚ hTâ‚‚ e.hom.left e.hom.right e.hom.w.symm
  have : IsIso Ï†.homâ‚ := by dsimp [Ï†]; infer_instance
  have : IsIso Ï†.homâ‚‚ := by dsimp [Ï†]; infer_instance
  have : IsIso Ï†.homâ‚ƒ := isIsoâ‚ƒ_of_isIsoâ‚â‚‚ Ï† hTâ‚ hTâ‚‚ inferInstance inferInstance
  have : IsIso Ï† := by
    apply Triangle.isIso_of_isIsos
    all_goals infer_instance
  exact âŸ¨asIso Ï†, by simp [Ï†], by simp [Ï†]âŸ©","have âŸ¨eâ‚, hTâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ© âŸ¨eâ‚âŸ© âŸ¨eâ‚‚âŸ©)âŸ©"
Mathlib/Combinatorics/SimpleGraph/Coloring.lean,SimpleGraph.chromaticNumber_pos,chromaticNumber_pos,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  rw [hc.chromaticNumber_eq_sInf, Nat.cast_pos]
  apply le_csInf (colorable_set_nonempty_of_colorable hc)
  intro m hm
  by_contra h'
  simp only [not_le] at h'
  obtain âŸ¨i, hiâŸ© := hm.some (Classical.arbitrary V)
  have hâ‚ : i < 0 : = lt_of_lt_of_le hi (Nat.le_of_lt_succ h')
  exact Nat.not_lt_zero _ hâ‚","error:  unexpected token ':'; expected '|'
error:  unsolved goals
case mk
V : Type u
G : SimpleGraph V
nâœ : â„•
Î± : Type u_1
Î² : Type u_2
C : G.Coloring Î±
instâœ : Nonempty V
n : â„•
hc : G.Colorable n
m : â„•
hm : m âˆˆ {n | G.Colorable n}
h' : m < Nat.succ 0
i : â„•
hi : i < m
hâ‚ : i < 0
âŠ¢ False",theorem chromaticNumber_pos [Nonempty V] {n : â„•} (hc : G.Colorable n) : 0 < G.chromaticNumber ,":= by
  rw [hc.chromaticNumber_eq_sInf, Nat.cast_pos]
  apply le_csInf (colorable_set_nonempty_of_colorable hc)
  intro m hm
  by_contra h'
  simp only [not_le] at h'
  obtain âŸ¨i, hiâŸ© := hm.some (Classical.arbitrary V)
  have hâ‚: i < 0 := lt_of_lt_of_le hi (Nat.le_of_lt_succ h')
  exact Nat.not_lt_zero _ hâ‚",apply G.chromaticNumber_le_chromaticNumber
Mathlib/Topology/Algebra/Valuation.lean,Valuation.subgroups_basis,subgroups_basis,14c729603a56a1a02f31a1b28b852fe56d29c058,":=
  { inter := by
      rintro Î³â‚€ Î³â‚
      use min Î³â‚€ Î³â‚
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro Î³
      cases' exists_square_le Î³ with Î³â‚€ h
      use Î³â‚€
      rintro - âŸ¨r, s, r_in, s_in, rflâŸ©
      calc
        (v (r * s) : Î“â‚€) = v r * v s := Valuation.map_mul _ _ _
        _ < Î³â‚€ * Î³â‚€ := (mul_lt_mulâ‚€ r_in s_in)
        _ â‰¤ Î³ := mod_cast h
    leftMul := by
      rintro x Î³
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | âŸ¨Î³x, HxâŸ©)
      Â· use (1 : Î“â‚€Ë£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt Î³
      Â· use Î³xâ»Â¹ * Î³
        rintro y (vy_lt : v y < â†‘(Î³xâ»Â¹ * Î³))
        change (v (x * y) : Î“â‚€) < Î³
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mulâ‚€ vy_lt
    rightMul := by
      rintro x Î³
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | âŸ¨Î³x, HxâŸ©)
      Â· use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt Î³
      Â· use Î³xâ»Â¹ * Î³
        rintro y (vy_lt : v y < â†‘(Î³xâ»Â¹ * Î³))
        change (v (y * x) : Î“â‚€) < Î³
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mulâ‚€ vy_lt }","error:  application type mismatch
  v s
argument
  s
has type
  r âˆˆ â†‘(v.ltAddSubgroup Î³â‚€) : Prop
but is expected to have type
  R : Type u
error:  invalid 'calc' step, failed to synthesize `Trans` instance
  Trans LT.lt Membership.mem ?m.11018
use `set_option diagnostics true` to get diagnostic information",theorem subgroups_basis : RingSubgroupsBasis fun Î³ : Î“â‚€Ë£ => (v.ltAddSubgroup Î³ : AddSubgroup R) ,":=
  { inter := by
      rintro Î³â‚€ Î³â‚
      use min Î³â‚€ Î³â‚
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro Î³
      cases' exists_square_le Î³ with Î³â‚€ h
      use Î³â‚€
      rintro - âŸ¨r, r_in, s, s_in, rflâŸ©
      calc
        (v (r * s) : Î“â‚€) = v r * v s := Valuation.map_mul _ _ _
        _ < Î³â‚€ * Î³â‚€ := mul_lt_mulâ‚€ r_in s_in
        _ â‰¤ Î³ := mod_cast h
    leftMul := by
      rintro x Î³
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | âŸ¨Î³x, HxâŸ©)
      Â· use (1 : Î“â‚€Ë£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt Î³
      Â· use Î³xâ»Â¹ * Î³
        rintro y (vy_lt : v y < â†‘(Î³xâ»Â¹ * Î³))
        change (v (x * y) : Î“â‚€) < Î³
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mulâ‚€ vy_lt
    rightMul := by
      rintro x Î³
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | âŸ¨Î³x, HxâŸ©)
      Â· use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt Î³
      Â· use Î³xâ»Â¹ * Î³
        rintro y (vy_lt : v y < â†‘(Î³xâ»Â¹ * Î³))
        change (v (y * x) : Î“â‚€) < Î³
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mulâ‚€ vy_lt }",refine RingSubgroupsBasis.ext fun Î³ => ?_
Mathlib/Data/Seq/Parallel.lean,Computation.exists_of_mem_parallel,exists_of_mem_parallel,3c930599229893e1b6a931304cf4efff4a01b172,":= by
  suffices
      âˆ€ C, a âˆˆ C â†’ âˆ€ (l : List (Computation Î±)) (S),
        corec parallel.aux1 (l, S) = C â†’ âˆƒ c, (c âˆˆ l âˆ¨ c âˆˆ WSeq.mk S) âˆ§ a âˆˆ c from
    let âŸ¨c, h1, h2âŸ© := this _ h [] (WSeq.data S) rfl
    âŸ¨c, h1.resolve_left <| List.not_mem_nil _, h2âŸ©
  let F : List (Computation Î±) â†’ Î± âŠ• List (Computation Î±) â†’ Prop := by
    intro l a
    cases' a with a l'
    Â· exact âˆƒ c âˆˆ l, a âˆˆ c
    Â· exact âˆ€ a', (âˆƒ c âˆˆ l', a' âˆˆ c) â†’ âˆƒ c âˆˆ l, a' âˆˆ c
  have lem1 : âˆ€ l : List (Computation Î±), F l (parallel.aux2 l) := by
    intro l
    induction' l with c l IH <;> simp only [parallel.aux2, List.foldr]
    Â· intro a h
      rcases h with âŸ¨c, hn, _âŸ©
      exact False.elim <| List.not_mem_nil _ hn
    Â· simp only [parallel.aux2] at IH
      revert IH
      cases' List.foldr (fun c o =>
        match o with
        | Sum.inl a => Sum.inl a
        | Sum.inr ls => Sum.map id (Â· :: ls) (dest c)) (Sum.inr []) l with a ls <;>
        intro IH <;>
        simp only [parallel.aux2]
      Â· rcases IH with âŸ¨c', cl, acâŸ©
        exact âŸ¨c', List.Mem.tail _ cl, acâŸ©
      Â· induction' h : dest c with a c' <;> simp only [Sum.map_inl, Sum.map_inr]
        Â· refine âŸ¨c, List.mem_cons_self _ _, ?_âŸ©
          rw [dest_eq_pure h]
          apply mem_pure
        Â· intro a' h
          rcases h with âŸ¨d, dm, adâŸ©
          simp? at dm says simp only [List.mem_cons] at dm
          cases' dm with e dl
          Â· rw [e] at ad
            refine âŸ¨c, List.mem_cons_self _ _, ?_âŸ©
            rw [dest_eq_think h]
            exact mem_think ad
          Â· cases' IH a' âŸ¨d, dl, adâŸ© with d dm
            cases' dm with dm ad
            exact âŸ¨d, List.Mem.tail _ dm, adâŸ©
  intro C aC
  induction' aC using memRecOn with C' _ IH <;> intro l S e <;> have e' := congr_arg dest e <;>
    have := lem1 l <;> simp [parallel.aux1] at e' <;>
      revert this e' <;> cases' parallel.aux2 l with a' l' <;> intro this e' <;>
      [injection e' with h'; injection e'; injection e'; injection e' with h']
  Â· rw [â† h']
    rcases this with âŸ¨c, cl, acâŸ©
    exact âŸ¨c, Or.inl cl, acâŸ©
  Â· induction' e : Seq'.dest S with a <;> rw [e] at h'
    Â· exact
        let âŸ¨d, o, adâŸ© := IH _ _ h'
        let âŸ¨c, cl, acâŸ© := this a âŸ¨d, o.resolve_right (WSeq.not_mem_nil _), adâŸ©
        âŸ¨c, Or.inl cl, acâŸ©
    Â· cases' a with o S'
      cases' o with c <;> simp [parallel.aux1] at h' <;> rcases IH _ _ h' with âŸ¨d, dl | dS', adâŸ©
      Â· exact
          let âŸ¨c, cl, acâŸ© := this a âŸ¨d, dl, adâŸ©
          âŸ¨c, Or.inl cl, acâŸ©
      Â· refine âŸ¨d, Or.inr ?_, adâŸ©
        rw [Seq'.dest_eq_cons e]
        exact Seq'.mem_cons_of_mem _ dS'
      Â· simp at dl
        cases' dl with dc dl
        Â· rw [dc] at ad
          refine âŸ¨c, Or.inr ?_, adâŸ©
          rw [Seq'.dest_eq_cons e]
          apply Seq'.mem_cons
        Â· exact
            let âŸ¨c, cl, acâŸ© := this a âŸ¨d, dl, adâŸ©
            âŸ¨c, Or.inl cl, acâŸ©
      Â· refine âŸ¨d, Or.inr ?_, adâŸ©
        rw [Seq'.dest_eq_cons e]
        exact Seq'.mem_cons_of_mem _ dS'","error:  unknown constant 'Stream'.WSeq.mk'
error:  unknown constant 'Stream'.WSeq.data'
error:  application type mismatch
  Sum.map id fun x x â†¦ x :: ls
argument
  fun x x â†¦ x :: ls
has type
  ?m.15828 â†’ ?m.14877 â†’ List ?m.14877 : Type (max ?u.14876 ?u.15823)
but is expected to have type
  ?m.15828 â†’ List ?m.14877 : Type (max ?u.14876 ?u.15823)
error:  unknown identifier 'dest'
error:  simp made no progress
error:  simp made no progress
error:  rcases tactic failed: IH : Sum.rec (motive := fun t â†¦
  List.foldr
        (fun c o â†¦
          match o with
          | Sum.inl a => Sum.inl a
          | Sum.inr ls => rmap (fun c' â†¦ c' :: ls) c.destruct)
        (Sum.inr []) l =
      t â†’
    Prop)
  (fun val â†¦ (fun a h â†¦ âˆƒ c, c âˆˆ l âˆ§ a âˆˆ c) val)
  (fun val â†¦ (fun l' h â†¦ âˆ€ (a' : Î±), (âˆƒ c, c âˆˆ l' âˆ§ a' âˆˆ c) â†’ âˆƒ c, c âˆˆ l âˆ§ a' âˆˆ c) val)
  (List.foldr
    (fun c o â†¦
      match o with
      | Sum.inl a => Sum.inl a
      | Sum.inr ls => rmap (fun c' â†¦ c' :: ls) c.destruct)
    (Sum.inr []) l)
  â‹¯ is not an inductive datatype
error:  unknown identifier 'dest'
error:  tactic 'induction' failed, major premise type is not an inductive type 
  ?m.16604
case cons.inr
Î± : Type u
Î² : Type v
S : WSeq (Computation Î±)
a : Î±
hâœ : a âˆˆ parallel S
F : List (Computation Î±) â†’ Î± âŠ• List (Computation Î±) â†’ Prop :=
  fun l a â†¦
    Sum.casesOn (motive := fun t â†¦ a = t â†’ Prop) a (fun a_1 h â†¦ âˆƒ c, c âˆˆ l âˆ§ a_1 âˆˆ c)
      (fun l' h â†¦ âˆ€ (a' : Î±), (âˆƒ c, c âˆˆ l' âˆ§ a' âˆˆ c) â†’ âˆƒ c, c âˆˆ l âˆ§ a' âˆˆ c) â‹¯
c : Computation Î±
l : List (Computation Î±)
ls : List ?m.14877
IH :
  F l
    (List.foldr
      (fun c o â†¦
        match o with
        | Sum.inl a => Sum.inl a
        | Sum.inr ls => rmap (fun c' â†¦ c' :: ls) c.destruct)
      (Sum.inr []) l)
xâœ : ?m.16604
h : sorryAx ?m.16604 true = xâœ
âŠ¢ F (c :: l)
    (match
      List.foldr
        (fun c o â†¦
          match o with
          | Sum.inl a => Sum.inl a
          | Sum.inr ls => rmap (fun c' â†¦ c' :: ls) c.destruct)
        (Sum.inr []) l with
    | Sum.inl a => Sum.inl a
    | Sum.inr ls => rmap (fun c' â†¦ c' :: ls) c.destruct)
error:  failed to infer implicit target s
error:  invalid occurrence of universe level 'u_1' at 'Computation.parallel_empty', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  exists_of_mem_parallel.{u, u_1, u_2} m
at declaration body
  fun {Î± : Type u} (S : WSeq (Computation Î±)) (h : S.head ~> none) â†¦
    eq_empty_of_not_terminates fun (x : (parallel S).Terminates) â†¦
      match x with
      | { term := Exists.intro a m } =>
        match exists_of_mem_parallel m with
        | Exists.intro c âŸ¨cs, rightâŸ© =>
          match WSeq.exists_get?_of_mem cs with
          | Exists.intro n nm =>
            match WSeq.head_some_of_get?_some nm with
            | Exists.intro c' h' => Option.noConfusion (h h')
error:  invalid occurrence of universe level 'u_1' at 'Computation.parallelRec', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  exists_of_mem_parallel.{u, u_1, u_2} dT
at declaration body
  fun {Î± : Type u} {S : WSeq (Computation Î±)} (C : Î± â†’ Sort v) (H : (s : Computation Î±) â†’ s âˆˆ S â†’ (a : Î±) â†’ a âˆˆ s â†’ C a)
      {a : Î±} (h : a âˆˆ parallel S) â†¦
    let T : WSeq (Computation (Î± Ã— Computation Î±)) :=
      WSeq.map (fun (c : Computation Î±) â†¦ map (fun (a : Î±) â†¦ (a, c)) c) S;
    let_fun this : S = WSeq.map (map fun (c : Î± Ã— Computation Î±) â†¦ c.1) T := â‹¯;
    let_fun pe : parallel S = parallel (WSeq.map (map fun (c : Î± Ã— Computation Î±) â†¦ c.1) T) := â‹¯;
    let_fun h' : a âˆˆ parallel S := h;
    Prod.rec (motive := fun (x : Î± Ã— Computation Î±) â†¦ (parallel T).get = x â†’ C a)
      (fun (a' : Î±) (c : Computation Î±) (e : (parallel T).get = (a', c)) â†¦
        let_fun this : a âˆˆ c âˆ§ c âˆˆ S := â‹¯;
        And.casesOn (motive := fun (t : a âˆˆ c âˆ§ c âˆˆ S) â†¦ this = t â†’ C a) this
          (fun (ac : a âˆˆ c) (cs : c âˆˆ S) (h : this = â‹¯) â†¦ H c cs a ac) â‹¯)
      (parallel T).get â‹¯
error:  invalid occurrence of universe level 'u_1' at 'Computation.parallel_promises', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  exists_of_mem_parallel.{u, u_1, u_2} ma'
at declaration body
  fun {Î± : Type u} {S : WSeq (Computation Î±)} {a : Î±} (H : âˆ€ (s : Computation Î±), s âˆˆ S â†’ s ~> a) (x : Î±)
      (ma' : x âˆˆ parallel S) â†¦
    match exists_of_mem_parallel ma' with
    | Exists.intro w âŸ¨cs, acâŸ© => H w cs ac
error:  unknown identifier 'parallel_promises'
error:  unknown identifier 'parallel_promises'
error:  unsolved goals
Î± : Type u
Î² : Type v
S T : WSeq (Computation Î±)
a : Î±
h1 : âˆ€ (s : Computation Î±), s âˆˆ S â†’ s ~> a
H : WSeq.LiftRel Equiv S T
h2 : âˆ€ (t : Computation Î±), t âˆˆ T â†’ t ~> a := (parallel_congr_lem H).mp h1
a' : Î±
h : a' âˆˆ parallel S
âŠ¢ a' âˆˆ parallel T
error:  unknown identifier 'parallel_promises'
error:  unsolved goals
Î± : Type u
Î² : Type v
S T : WSeq (Computation Î±)
a : Î±
h1 : âˆ€ (s : Computation Î±), s âˆˆ S â†’ s ~> a
H : WSeq.LiftRel Equiv S T
h2 : âˆ€ (t : Computation Î±), t âˆˆ T â†’ t ~> a := (parallel_congr_lem H).mp h1
a' : Î±
h : a' âˆˆ parallel T
âŠ¢ a' âˆˆ parallel S","theorem exists_of_mem_parallel {S : WSeq (Computation Î±)} {a} (h : a âˆˆ parallel S) :
    âˆƒ c âˆˆ S, a âˆˆ c ",":= by
  suffices
    âˆ€ C, a âˆˆ C â†’ âˆ€ (l : List (Computation Î±)) (S),
      corec parallel.aux1 (l, S) = C â†’ âˆƒ c, (c âˆˆ l âˆ¨ c âˆˆ S) âˆ§ a âˆˆ c from
    let âŸ¨c, h1, h2âŸ© := this _ h [] S rfl
    âŸ¨c, h1.resolve_left <| List.not_mem_nil _, h2âŸ©
  let F : List (Computation Î±) â†’ Sum Î± (List (Computation Î±)) â†’ Prop := by
    intro l a
    cases' a with a l'
    Â· exact âˆƒ c âˆˆ l, a âˆˆ c
    Â· exact âˆ€ a', (âˆƒ c âˆˆ l', a' âˆˆ c) â†’ âˆƒ c âˆˆ l, a' âˆˆ c
  have lem1 : âˆ€ l : List (Computation Î±), F l (parallel.aux2 l) := by
    intro l
    induction' l with c l IH <;> simp only [parallel.aux2, List.foldr]
    Â· intro a h
      rcases h with âŸ¨c, hn, _âŸ©
      exact False.elim <| List.not_mem_nil _ hn
    Â· simp only [parallel.aux2] at IH
      revert IH
      cases' List.foldr (fun c o =>
        match o with
        | Sum.inl a => Sum.inl a
        | Sum.inr ls => rmap (fun c' => c' :: ls) (destruct c)) (Sum.inr List.nil) l with a ls <;>
        intro IH <;>
        simp only [parallel.aux2]
      Â· rcases IH with âŸ¨c', cl, acâŸ©
        exact âŸ¨c', List.Mem.tail _ cl, acâŸ©
      Â· induction' h : destruct c with a c' <;> simp only [rmap]
        Â· refine âŸ¨c, List.mem_cons_self _ _, ?_âŸ©
          rw [destruct_eq_pure h]
          apply ret_mem
        Â· intro a' h
          rcases h with âŸ¨d, dm, adâŸ©
          simp? at dm says simp only [List.mem_cons] at dm
          cases' dm with e dl
          Â· rw [e] at ad
            refine âŸ¨c, List.mem_cons_self _ _, ?_âŸ©
            rw [destruct_eq_think h]
            exact think_mem ad
          Â· cases' IH a' âŸ¨d, dl, adâŸ© with d dm
            cases' dm with dm ad
            exact âŸ¨d, List.Mem.tail _ dm, adâŸ©
  intro C aC
  apply memRecOn aC <;> [skip; intro C' IH] <;> intro l S e <;> have e' := congr_arg destruct e <;>
    have := lem1 l <;> simp only [parallel.aux1, corec_eq, destruct_pure, destruct_think] at e' <;>
    revert this e' <;> cases' parallel.aux2 l with a' l' <;> intro this e' <;>
    [injection e' with h'; injection e'; injection e'; injection e' with h']
  Â· rw [h'] at this
    rcases this with âŸ¨c, cl, acâŸ©
    exact âŸ¨c, Or.inl cl, acâŸ©
  Â· induction' e : Seq.destruct S with a <;> rw [e] at h'
    Â· exact
        let âŸ¨d, o, adâŸ© := IH _ _ h'
        let âŸ¨c, cl, acâŸ© := this a âŸ¨d, o.resolve_right (WSeq.not_mem_nil _), adâŸ©
        âŸ¨c, Or.inl cl, acâŸ©
    Â· cases' a with o S'
      cases' o with c <;> simp [parallel.aux1] at h' <;> rcases IH _ _ h' with âŸ¨d, dl | dS', adâŸ©
      Â· exact
          let âŸ¨c, cl, acâŸ© := this a âŸ¨d, dl, adâŸ©
          âŸ¨c, Or.inl cl, acâŸ©
      Â· refine âŸ¨d, Or.inr ?_, adâŸ©
        rw [Seq.destruct_eq_cons e]
        exact Seq.mem_cons_of_mem _ dS'
      Â· simp at dl
        cases' dl with dc dl
        Â· rw [dc] at ad
          refine âŸ¨c, Or.inr ?_, adâŸ©
          rw [Seq.destruct_eq_cons e]
          apply Seq.mem_cons
        Â· exact
            let âŸ¨c, cl, acâŸ© := this a âŸ¨d, dl, adâŸ©
            âŸ¨c, Or.inl cl, acâŸ©
      Â· refine âŸ¨d, Or.inr ?_, adâŸ©
        rw [Seq.destruct_eq_cons e]
        exact Seq.mem_cons_of_mem _ dS'",induction' h : parallel S using parallel S
Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean,GeneralizedContinuedFraction.of_s_tail,of_s_tail,67bb925387960887a3b36a6aab219b9c613883f7,":=
  Seq'.ext fun n => Seq'.get?_tail (of v).s n â–¸ of_s_succ v n",error:  unknown identifier 'Seq'.ext',theorem of_s_tail : (of v).s.tail = (of (fract v)â»Â¹).s ,":=
  Stream'.Seq.ext fun n => Stream'.Seq.get?_tail (of v).s n â–¸ of_s_succ v n",simp of_s_tail
Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean,Matrix.reverse_charpoly,reverse_charpoly,8a368c9ce548afdf4c8725618c97ec9e96c48601,":= by
  nontriviality R
  let t : R[T;Tâ»Â¹] := T 1
  let t_inv : R[T;Tâ»Â¹] := T (-1)
  let p : R[T;Tâ»Â¹] := det (scalar n t - M.map LaurentPolynomial.C)
  let q : R[T;Tâ»Â¹] := det (1 - scalar n t * M.map LaurentPolynomial.C)
  have ht : t_inv * t = 1 := by rw [â† T_add, add_left_neg, T_zero]
  have hp : toLaurentAlg M.charpoly = p := by
    simp [charpoly, charmatrix, AlgHom.map_det, map_sub, map_smul']
  have hq : toLaurentAlg M.charpolyRev = q := by
    simp [charpolyRev, AlgHom.map_det, map_sub, map_smul', smul_eq_diagonal_mul]
  suffices : t_inv ^ Fintype.card n * p = invert q
  Â· apply toLaurent_injective
    rwa [toLaurent_reverse, â† coe_toLaurentAlg, hp, hq, â† involutive_invert.injective.eq_iff,
      invert.map_mul, involutive_invert p, charpoly_natDegree_eq_dim,
      â† mul_one (Fintype.card n : â„¤), â† T_pow, invert.map_pow, invert_T, mul_comm]
  rw [â† det_smul, smul_sub, scalar_apply, â† diagonal_smul, Pi.smul_def, smul_eq_mul, ht,
    diagonal_one, invert.map_det (R := R)]
  simp [map_smul', smul_eq_diagonal_mul]","error:  unexpected token ':'; expected term
error:  unsolved goals
R : Type u
instâœâ´ : CommRing R
n G : Type v
instâœÂ³ : DecidableEq n
instâœÂ² : Fintype n
Î± Î² : Type v
instâœÂ¹ : DecidableEq Î±
Mâœ : Matrix n n R
pâœ : â„•
instâœ : Fact (Nat.Prime pâœ)
M : Matrix n n R
aâœ : Nontrivial R
t : R[T;Tâ»Â¹] := T 1
t_inv : R[T;Tâ»Â¹] := T (-1)
p : R[T;Tâ»Â¹] := ((scalar n) t - M.map â‡‘LaurentPolynomial.C).det
q : R[T;Tâ»Â¹] := (1 - (scalar n) t * M.map â‡‘LaurentPolynomial.C).det
ht : t_inv * t = 1
âŠ¢ ((diagonal fun m â†¦ T 1) - M.map â‡‘LaurentPolynomial.C).det = p
error:  unsolved goals
R : Type u
instâœâ´ : CommRing R
n G : Type v
instâœÂ³ : DecidableEq n
instâœÂ² : Fintype n
Î± Î² : Type v
instâœÂ¹ : DecidableEq Î±
Mâœ : Matrix n n R
pâœ : â„•
instâœ : Fact (Nat.Prime pâœ)
M : Matrix n n R
aâœ : Nontrivial R
t : R[T;Tâ»Â¹] := T 1
t_inv : R[T;Tâ»Â¹] := T (-1)
p : R[T;Tâ»Â¹] := ((scalar n) t - M.map â‡‘LaurentPolynomial.C).det
q : R[T;Tâ»Â¹] := (1 - (scalar n) t * M.map â‡‘LaurentPolynomial.C).det
ht : t_inv * t = 1
hp : toLaurentAlg M.charpoly = p
âŠ¢ (1 - (diagonal fun m â†¦ T 1) * M.map â‡‘LaurentPolynomial.C).det = q","lemma reverse_charpoly (M : Matrix n n R) :
    M.charpoly.reverse = M.charpolyRev ",":= by
  nontriviality R
  let t : R[T;Tâ»Â¹] := T 1
  let t_inv : R[T;Tâ»Â¹] := T (-1)
  let p : R[T;Tâ»Â¹] := det (scalar n t - M.map LaurentPolynomial.C)
  let q : R[T;Tâ»Â¹] := det (1 - scalar n t * M.map LaurentPolynomial.C)
  have ht : t_inv * t = 1 := by rw [â† T_add, add_left_neg, T_zero]
  have hp : toLaurentAlg M.charpoly = p := by
    simp [p, charpoly, charmatrix, AlgHom.map_det, map_sub, map_smul']
  have hq : toLaurentAlg M.charpolyRev = q := by
    simp [q, charpolyRev, AlgHom.map_det, map_sub, map_smul', smul_eq_diagonal_mul]
  suffices t_inv ^ Fintype.card n * p = invert q by
    apply toLaurent_injective
    rwa [toLaurent_reverse, â† coe_toLaurentAlg, hp, hq, â† involutive_invert.injective.eq_iff,
      _root_.map_mul, involutive_invert p, charpoly_natDegree_eq_dim,
      â† mul_one (Fintype.card n : â„¤), â† T_pow, map_pow, invert_T, mul_comm]
  rw [â† det_smul, smul_sub, scalar_apply, â† diagonal_smul, Pi.smul_def, smul_eq_mul, ht,
    diagonal_one, invert.map_det]
  simp [t, map_smul', smul_eq_diagonal_mul]","simp only [charpolyRev, reverse_charpoly, charmatrix_apply, charmatrix_apply,
  charmatrix_apply, charmatrix_apply]"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding',exists_extension_norm_eq_of_closedEmbedding',161c69c1dbf66cf3c7ec4f648a61551d044a43e4,":= by
  choose F hF_norm hF_dist using fun f : X â†’áµ‡ â„ => tietze_extension_step f e he
  set g : â„• â†’ Y â†’áµ‡ â„ := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : âˆ€ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : âˆ€ n, dist ((g n).compContinuous e) f â‰¤ (2 / 3) ^ n * â€–fâ€– := by
    intro n
    induction' n with n ihn
    Â· simp [g0]
    Â· rw [g_succ n, add_compContinuous, â† dist_sub_right, add_sub_cancel', pow_succ, mul_assoc]
      refine' (hF_dist _).trans (mul_le_mul_of_nonneg_left _ (by norm_num1))
      rwa [â† dist_eq_norm']
  have hg_dist : âˆ€ n, dist (g n) (g (n + 1)) â‰¤ 1 / 3 * â€–fâ€– * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = â€–F (f - (g n).compContinuous e)â€– := by
        rw [g_succ, dist_eq_norm', add_sub_cancel']
      _ â‰¤ â€–f - (g n).compContinuous eâ€– / 3 := (hF_norm _)
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ â‰¤ 1 / 3 * ((2 / 3) ^ n * â€–fâ€–) := (mul_le_mul_of_nonneg_left (hgf n) (by norm_num1))
      _ = 1 / 3 * â€–fâ€– * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ğ“ <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine' tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 _)
    refine' squeeze_zero (fun _ => dist_nonneg) hgf _
    rw [â† zero_mul â€–fâ€–]
    refine' (tendsto_pow_atTop_nhds_0_of_lt_1 _ _).mul tendsto_const_nhds <;> norm_num1
  refine' âŸ¨limUnder atTop g, le_antisymm _ _, hgeâŸ©
  Â· rw [â† dist_zero_left, â† g0]
    refine'
      (dist_le_of_le_geometric_of_tendstoâ‚€ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq _
    field_simp [show (3 - 2 : â„) = 1 by norm_num1]
  Â· rw [â† hge]
    exact norm_compContinuous_le _ _","warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  application type mismatch
  LE.le.trans (hF_dist (f - (g n).compContinuous e)) (mul_le_mul_of_nonneg_left ?m.115481 ?m.115895)
argument
  mul_le_mul_of_nonneg_left ?m.115481 ?m.115895
has type
  2 / 3 * â€–f - (g n).compContinuous eâ€– â‰¤ 2 / 3 * ?m.115476 : Prop
but is expected to have type
  2 / 3 * â€–f - (g n).compContinuous eâ€– â‰¤ (2 / 3) ^ n * (2 / 3 * â€–fâ€–) : Prop
error:  no goals to be solved
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
warning:  `tendsto_pow_atTop_nhds_0_of_lt_1` has been deprecated, use `tendsto_pow_atTop_nhds_zero_of_lt_one` instead","theorem exists_extension_norm_eq_of_closedEmbedding' (f : X â†’áµ‡ â„) (e : C(X, Y))
    (he : ClosedEmbedding e) : âˆƒ g : Y â†’áµ‡ â„, â€–gâ€– = â€–fâ€– âˆ§ g.compContinuous e = f ",":= by
  choose F hF_norm hF_dist using fun f : X â†’áµ‡ â„ => tietze_extension_step f e he
  set g : â„• â†’ Y â†’áµ‡ â„ := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : âˆ€ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : âˆ€ n, dist ((g n).compContinuous e) f â‰¤ (2 / 3) ^ n * â€–fâ€– := by
    intro n
    induction' n with n ihn
    Â· simp [g0]
    Â· rw [g_succ n, add_compContinuous, â† dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))
      rwa [â† dist_eq_norm']
  have hg_dist : âˆ€ n, dist (g n) (g (n + 1)) â‰¤ 1 / 3 * â€–fâ€– * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = â€–F (f - (g n).compContinuous e)â€– := by
        rw [g_succ, dist_eq_norm', add_sub_cancel_left]
      _ â‰¤ â€–f - (g n).compContinuous eâ€– / 3 := hF_norm _
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ â‰¤ 1 / 3 * ((2 / 3) ^ n * â€–fâ€–) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1)
      _ = 1 / 3 * â€–fâ€– * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ğ“ <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul â€–fâ€–]
    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine âŸ¨limUnder atTop g, le_antisymm ?_ ?_, hgeâŸ©
  Â· rw [â† dist_zero_left, â† g0]
    refine
      (dist_le_of_le_geometric_of_tendstoâ‚€ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : â„) = 1 by norm_num1]
  Â· rw [â† hge]
    exact norm_compContinuous_le _ _","refine âŸ¨exists_extension_norm_eq_of_closedEmbedding', ?_, ?_âŸ©"
Mathlib/MeasureTheory/Integral/CircleIntegral.lean,circleIntegral.norm_integral_lt_of_norm_le_const_of_lt,norm_integral_lt_of_norm_le_const_of_lt,e92ad7acc4d771729f70601a74a3c091f330e507,":= by
  rw [â† _root_.abs_of_pos hR, â† image_circleMap_Ioc] at hlt
  rcases hlt with âŸ¨_, âŸ¨Î¸â‚€, hmem, rflâŸ©, hltâŸ©
  calc
    â€–âˆ® z in C(c, R), f zâ€– â‰¤ âˆ« Î¸ in [0:2 * Ï€], â€–deriv (circleMap c R) Î¸ â€¢ f (circleMap c R Î¸)â€– :=
      intervalIntegral.norm_integral_le_integral_norm Real.two_pi_pos.le
    _ < âˆ« _ in [0:2 * Ï€], R * C := by
      simp only [norm_smul, deriv_circleMap, norm_eq_abs, map_mul, abs_I, mul_one,
        abs_circleMap_zero, abs_of_pos hR]
      refine' intervalIntegral.integral_lt_integral_of_continuousOn_of_le_of_exists_lt
          Real.two_pi_pos _ continuousOn_const (fun Î¸ _ => _) âŸ¨Î¸â‚€, Ioc_subset_Icc_self hmem, _âŸ©
      Â· exact continuousOn_const.mul (hc.comp (continuous_circleMap _ _).continuousOn fun Î¸ _ =>
          circleMap_mem_sphere _ hR.le _).norm
      Â· exact mul_le_mul_of_nonneg_left (hf _ <| circleMap_mem_sphere _ hR.le _) hR.le
      Â· exact (mul_lt_mul_left hR).2 hlt
    _ = 2 * Ï€ * R * C := by simp [mul_assoc]; ring","error:  type mismatch
  2 * Ï€
has type
  â„ : outParam Type
but is expected to have type
  â„• : Type
error:  type mismatch
  2 * Ï€
has type
  â„ : outParam Type
but is expected to have type
  â„• : Type
info:  Try this: ring_nf
error:  unsolved goals
E : Type u_1
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„‚ E
instâœ : CompleteSpace E
f : â„‚ â†’ E
c : â„‚
R C : â„
hR : 0 < R
hc : ContinuousOn f (sphere c R)
hf : âˆ€ z âˆˆ sphere c R, â€–f zâ€– â‰¤ C
Î¸â‚€ : â„
hmem : Î¸â‚€ âˆˆ Ioc 0 (2 * Ï€)
hlt : â€–f (circleMap c R Î¸â‚€)â€– < C
âŠ¢ (volume (sorryAx (Set (sorryAx (Type ?u.153827) true)) true)).toReal * R * C = R * C * Ï€ * 2","theorem norm_integral_lt_of_norm_le_const_of_lt {f : â„‚ â†’ E} {c : â„‚} {R C : â„} (hR : 0 < R)
    (hc : ContinuousOn f (sphere c R)) (hf : âˆ€ z âˆˆ sphere c R, â€–f zâ€– â‰¤ C)
    (hlt : âˆƒ z âˆˆ sphere c R, â€–f zâ€– < C) : â€–âˆ® z in C(c, R), f zâ€– < 2 * Ï€ * R * C ",":= by
  rw [â† _root_.abs_of_pos hR, â† image_circleMap_Ioc] at hlt
  rcases hlt with âŸ¨_, âŸ¨Î¸â‚€, hmem, rflâŸ©, hltâŸ©
  calc
    â€–âˆ® z in C(c, R), f zâ€– â‰¤ âˆ« Î¸ in (0)..2 * Ï€, â€–deriv (circleMap c R) Î¸ â€¢ f (circleMap c R Î¸)â€– :=
      intervalIntegral.norm_integral_le_integral_norm Real.two_pi_pos.le
    _ < âˆ« _ in (0)..2 * Ï€, R * C := by
      simp only [norm_smul, deriv_circleMap, norm_eq_abs, map_mul, abs_I, mul_one,
        abs_circleMap_zero, abs_of_pos hR]
      refine intervalIntegral.integral_lt_integral_of_continuousOn_of_le_of_exists_lt
          Real.two_pi_pos ?_ continuousOn_const (fun Î¸ _ => ?_) âŸ¨Î¸â‚€, Ioc_subset_Icc_self hmem, ?_âŸ©
      Â· exact continuousOn_const.mul (hc.comp (continuous_circleMap _ _).continuousOn fun Î¸ _ =>
          circleMap_mem_sphere _ hR.le _).norm
      Â· exact mul_le_mul_of_nonneg_left (hf _ <| circleMap_mem_sphere _ hR.le _) hR.le
      Â· exact (mul_lt_mul_left hR).2 hlt
    _ = 2 * Ï€ * R * C := by simp [mul_assoc]; ring","rcases hlt with âŸ¨z, hz, hzRâŸ©"
Mathlib/Order/WellFoundedSet.lean,Set.WellFoundedOn.acc_iff_wellFoundedOn,acc_iff_wellFoundedOn,415d6b952a0c6bc1221dd68bc6ae84a0390ea21f,":= by
  tfae
    1 â†’ 2 := by
      refine fun h => âŸ¨fun b => InvImage.accessible _ ?_âŸ©
      rw [â† acc_transGen_iff] at h âŠ¢
      obtain h' | h' := reflTransGen_iff_eq_or_transGen.1 b.2
      Â· rwa [h'] at h
      Â· exact h.inv h'
    2 â†’ 3 := fun h => h.subset fun _ => TransGen.to_reflTransGen
    3 â†’ 1 := by
      refine
        fun h => Acc.intro _ (fun b hb => (h.apply âŸ¨b, .single hbâŸ©).of_fibration Subtype.val ?_)
      exact fun âŸ¨c, hcâŸ© d h => âŸ¨âŸ¨d, .head h hcâŸ©, h, rflâŸ©","error:  unknown tactic
error:  unsolved goals
Î¹ : Type u_1
Î±âœ : Type u_2
Î² : Type u_3
Î³ : Type u_4
Ï€ : Î¹ â†’ Type u_5
râœ r' : Î±âœ â†’ Î±âœ â†’ Prop
f : Î² â†’ Î±âœ
s t : Set Î±âœ
x y : Î±âœ
Î± : Type u_6
r : Î± â†’ Î± â†’ Prop
a : Î±
âŠ¢ [Acc r a, {b | ReflTransGen r b a}.WellFoundedOn r, {b | TransGen r b a}.WellFoundedOn r].TFAE","theorem acc_iff_wellFoundedOn {Î±} {r : Î± â†’ Î± â†’ Prop} {a : Î±} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r] ",":= by
  tfae_have 1 â†’ 2
  Â· refine fun h => âŸ¨fun b => InvImage.accessible _ ?_âŸ©
    rw [â† acc_transGen_iff] at h âŠ¢
    obtain h' | h' := reflTransGen_iff_eq_or_transGen.1 b.2
    Â· rwa [h'] at h
    Â· exact h.inv h'
  tfae_have 2 â†’ 3
  Â· exact fun h => h.subset fun _ => TransGen.to_reflTransGen
  tfae_have 3 â†’ 1
  Â· refine fun h => Acc.intro _ (fun b hb => (h.apply âŸ¨b, .single hbâŸ©).of_fibration Subtype.val ?_)
    exact fun âŸ¨c, hcâŸ© d h => âŸ¨âŸ¨d, .head h hcâŸ©, h, rflâŸ©
  tfae_finish",simp only [reflTransGen_eq_transGen]
Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean,HomogeneousIdeal.toIdeal_homogeneousCore_eq_self,HomogeneousIdeal.toIdeal_homogeneousCore_eq_self,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":=
  HomogeneousSubmodule.toSubmodule_homogeneousCore_eq_self I",error:  unknown identifier 'HomogeneousSubmodule.toSubmodule_homogeneousCore_eq_self',"theorem HomogeneousIdeal.toIdeal_homogeneousCore_eq_self (I : HomogeneousIdeal ğ’œ) :
    I.toIdeal.homogeneousCore ğ’œ = I ",":= by
  ext1
  convert Ideal.IsHomogeneous.toIdeal_homogeneousCore_eq_self I.isHomogeneous",apply Ideal.homogeneousCore_eq_self
Mathlib/MeasureTheory/Measure/Hausdorff.lean,Isometry.hausdorffMeasure_image,hausdorffMeasure_image,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine' iSup_le fun R => iSup_le fun hR => _
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine' ENNReal.tsum_le_tsum fun n => _
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left s) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set X : Type u_2
but is expected to have type
  ?m.169595 âˆˆ t n âˆ© ?m.169594 : Prop
error:  simp made no progress","theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s ",":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","rw [â† hausdorffMeasure_image_le, hausdorffMeasure_image_le, hausdorffMeasure_image_le]"
Mathlib/Probability/Kernel/WithDensity.lean,ProbabilityTheory.kernel.isSFiniteKernel_withDensity_of_isFiniteKernel,isSFiniteKernel_withDensity_of_isFiniteKernel,5ac9cb38fcf9079f6519764442b871fbd4091ab1,":= by
  by_cases hf : Measurable (Function.uncurry f)
  swap; Â· rw [withDensity_of_not_measurable _ hf]; infer_instance
  let fs : â„• â†’ Î± â†’ Î² â†’ â„â‰¥0âˆ := fun n a b => min (f a b) (n + 1) - min (f a b) n
  have h_le : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ f a b â‰¤ n := by
    intro a b n hn
    have : (f a b).toReal â‰¤ n := Nat.le_of_ceil_le hn
    rw [â† ENNReal.le_ofReal_iff_toReal_le (hf_ne_top a b) _] at this
    Â· refine' this.trans (le_of_eq _)
      rw [ENNReal.ofReal_coe_nat]
    Â· norm_cast
      exact zero_le _
  have h_zero : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ fs n a b = 0 := by
    intro a b n hn
    suffices min (f a b) (n + 1) = f a b âˆ§ min (f a b) n = f a b by
      simp_rw [this.1, this.2, tsub_self (f a b)]
    exact âŸ¨min_eq_left ((h_le a b n hn).trans (le_add_of_nonneg_right zero_le_one)),
      min_eq_left (h_le a b n hn)âŸ©
  have hf_eq_tsum : f = âˆ‘' n, fs n := by
    have h_sum_a : âˆ€ a, Summable fun n => fs n a := by
      refine' fun a => Pi.summable.mpr fun b => _
      suffices : âˆ€ n, n âˆ‰ Finset.range âŒˆ(f a b).toRealâŒ‰â‚Š â†’ fs n a b = 0
      exact summable_of_ne_finset_zero this
      intro n hn_not_mem
      rw [Finset.mem_range, not_lt] at hn_not_mem
      exact h_zero a b n hn_not_mem
    ext a b : 2
    rw [tsum_apply (Pi.summable.mpr h_sum_a), tsum_apply (h_sum_a a),
      ENNReal.tsum_eq_liminf_sum_nat]
    have h_finset_sum : âˆ€ n, âˆ‘ i in Finset.range n, fs i a b = min (f a b) n := by
      intro n
      induction' n with n hn
      Â· simp
      rw [Finset.sum_range_succ, hn]
      simp
    simp_rw [h_finset_sum]
    refine' (Filter.Tendsto.liminf_eq _).symm
    refine' Filter.Tendsto.congr' _ tendsto_const_nhds
    rw [Filter.EventuallyEq, Filter.eventually_atTop]
    exact âŸ¨âŒˆ(f a b).toRealâŒ‰â‚Š, fun n hn => (min_eq_left (h_le a b n hn)).symmâŸ©
  rw [hf_eq_tsum, withDensity_tsum _ fun n : â„• => _]
  swap; Â· exact fun _ => (hf.min measurable_const).sub (hf.min measurable_const)
  refine' isSFiniteKernel_sum fun n => _
  suffices IsFiniteKernel (withDensity Îº (fs n)) by haveI := this; infer_instance
  refine' isFiniteKernel_withDensity_of_bounded _ (ENNReal.coe_ne_top : â†‘n + 1 â‰  âˆ) fun a b => _
  norm_cast
  calc
    fs n a b â‰¤ min (f a b) (n + 1) := tsub_le_self
    _ â‰¤ n + 1 := (min_le_right _ _)
    _ = â†‘(n + 1) := by norm_cast","error:  unexpected token ':'; expected term
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î¹ : Type u_3
mÎ± : MeasurableSpace Î±
mÎ² : MeasurableSpace Î²
Îºâœ : â†¥(kernel Î± Î²)
f : Î± â†’ Î² â†’ â„â‰¥0âˆ
Îº : â†¥(kernel Î± Î²)
instâœ : IsFiniteKernel Îº
hf_ne_top : âˆ€ (a : Î±) (b : Î²), f a b â‰  âŠ¤
hf : Measurable (Function.uncurry f)
fs : â„• â†’ Î± â†’ Î² â†’ â„â‰¥0âˆ := fun n a b â†¦ min (f a b) (â†‘n + 1) - min (f a b) â†‘n
h_le : âˆ€ (a : Î±) (b : Î²) (n : â„•), âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ f a b â‰¤ â†‘n
h_zero : âˆ€ (a : Î±) (b : Î²) (n : â„•), âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ fs n a b = 0
h_sum_a : âˆ€ (a : Î±), Summable fun n â†¦ fs n a
âŠ¢ f = âˆ‘' (n : â„•), fs n
error:  unsolved goals
case pos
Î± : Type u_1
Î² : Type u_2
Î¹ : Type u_3
mÎ± : MeasurableSpace Î±
mÎ² : MeasurableSpace Î²
Îºâœ : â†¥(kernel Î± Î²)
f : Î± â†’ Î² â†’ â„â‰¥0âˆ
Îº : â†¥(kernel Î± Î²)
instâœ : IsFiniteKernel Îº
hf_ne_top : âˆ€ (a : Î±) (b : Î²), f a b â‰  âŠ¤
hf : Measurable (Function.uncurry f)
fs : â„• â†’ Î± â†’ Î² â†’ â„â‰¥0âˆ := fun n a b â†¦ min (f a b) (â†‘n + 1) - min (f a b) â†‘n
h_le : âˆ€ (a : Î±) (b : Î²) (n : â„•), âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ f a b â‰¤ â†‘n
h_zero : âˆ€ (a : Î±) (b : Î²) (n : â„•), âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ fs n a b = 0
hf_eq_tsum : f = âˆ‘' (n : â„•), fs n
âŠ¢ IsSFiniteKernel (withDensity Îº f)","theorem isSFiniteKernel_withDensity_of_isFiniteKernel (Îº : kernel Î± Î²) [IsFiniteKernel Îº]
    (hf_ne_top : âˆ€ a b, f a b â‰  âˆ) : IsSFiniteKernel (withDensity Îº f) ",":= by
  by_cases hf : Measurable (Function.uncurry f)
  swap; Â· rw [withDensity_of_not_measurable _ hf]; infer_instance
  let fs : â„• â†’ Î± â†’ Î² â†’ â„â‰¥0âˆ := fun n a b => min (f a b) (n + 1) - min (f a b) n
  have h_le : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ f a b â‰¤ n := by
    intro a b n hn
    have : (f a b).toReal â‰¤ n := Nat.le_of_ceil_le hn
    rw [â† ENNReal.le_ofReal_iff_toReal_le (hf_ne_top a b) _] at this
    Â· refine this.trans (le_of_eq ?_)
      rw [ENNReal.ofReal_natCast]
    Â· norm_cast
      exact zero_le _
  have h_zero : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ fs n a b = 0 := by
    intro a b n hn
    suffices min (f a b) (n + 1) = f a b âˆ§ min (f a b) n = f a b by
      simp_rw [fs, this.1, this.2, tsub_self (f a b)]
    exact âŸ¨min_eq_left ((h_le a b n hn).trans (le_add_of_nonneg_right zero_le_one)),
      min_eq_left (h_le a b n hn)âŸ©
  have hf_eq_tsum : f = âˆ‘' n, fs n := by
    have h_sum_a : âˆ€ a, Summable fun n => fs n a := by
      refine fun a => Pi.summable.mpr fun b => ?_
      suffices âˆ€ n, n âˆ‰ Finset.range âŒˆ(f a b).toRealâŒ‰â‚Š â†’ fs n a b = 0 from
        summable_of_ne_finset_zero this
      intro n hn_not_mem
      rw [Finset.mem_range, not_lt] at hn_not_mem
      exact h_zero a b n hn_not_mem
    ext a b : 2
    rw [tsum_apply (Pi.summable.mpr h_sum_a), tsum_apply (h_sum_a a),
      ENNReal.tsum_eq_liminf_sum_nat]
    have h_finset_sum : âˆ€ n, âˆ‘ i âˆˆ Finset.range n, fs i a b = min (f a b) n := by
      intro n
      induction' n with n hn
      Â· simp
      rw [Finset.sum_range_succ, hn]
      simp [fs]
    simp_rw [h_finset_sum]
    refine (Filter.Tendsto.liminf_eq ?_).symm
    refine Filter.Tendsto.congr' ?_ tendsto_const_nhds
    rw [Filter.EventuallyEq, Filter.eventually_atTop]
    exact âŸ¨âŒˆ(f a b).toRealâŒ‰â‚Š, fun n hn => (min_eq_left (h_le a b n hn)).symmâŸ©
  rw [hf_eq_tsum, withDensity_tsum _ fun n : â„• => _]
  swap; Â· exact fun _ => (hf.min measurable_const).sub (hf.min measurable_const)
  refine isSFiniteKernel_sum fun n => ?_
  suffices IsFiniteKernel (withDensity Îº (fs n)) by haveI := this; infer_instance
  refine isFiniteKernel_withDensity_of_bounded _ (ENNReal.coe_ne_top : â†‘n + 1 â‰  âˆ) fun a b => ?_
  beta_reduce
  norm_cast
  calc
    fs n a b â‰¤ min (f a b) (n + 1) := tsub_le_self
    _ â‰¤ n + 1 := min_le_right _ _
    _ = â†‘(n + 1) := by norm_cast",refine isSFiniteKernel_withDensity_of_isFiniteKernel_withDensity_of_isFiniteKernel_withDensity_of_isFiniteKernel f
Mathlib/Analysis/Convex/Intrinsic.lean,intrinsicClosure_eq_closure,intrinsicClosure_eq_closure,ded82be28af61da8cf3266077ac67ad9bf41c841,":= by
  ext x
  simp only [mem_closure_iff, mem_intrinsicClosure]
  refine âŸ¨?_, fun h => âŸ¨âŸ¨x, ?_âŸ©?, _, Subtype.coe_mk _ ?_âŸ©âŸ©
  Â· rintro âŸ¨x, h, rflâŸ© t ht hx
    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h _ (continuous_induced_dom.isOpen_preimage t ht) hx
    exact âŸ¨z, hzâ‚, hzâ‚‚âŸ©
  Â· rintro _ âŸ¨t, ht, rflâŸ© hx
    obtain âŸ¨y, hyt, hysâŸ© := h _ ht hx
    exact âŸ¨âŸ¨_, subset_affineSpan ğ•œ s hysâŸ©, hyt, hysâŸ©
  Â· by_contra hc
    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h _ (affineSpan ğ•œ s).closed_of_finiteDimensional.isOpen_compl hc
    exact hzâ‚ (subset_affineSpan ğ•œ s hzâ‚‚)","error:  unexpected token '?'; expected 'âŸ©'
error:  unsolved goals
case h
ğ•œ : Type u_1
V : Type u_2
W : Type u_3
Q : Type u_4
P : Type u_5
instâœâ¶ : NontriviallyNormedField ğ•œ
instâœâµ : CompleteSpace ğ•œ
instâœâ´ : NormedAddCommGroup V
instâœÂ³ : NormedSpace ğ•œ V
instâœÂ² : FiniteDimensional ğ•œ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
s : Set P
x : P
âŠ¢ (âˆƒ y, (âˆ€ (o : Set â†¥(affineSpan ğ•œ s)), IsOpen o â†’ y âˆˆ o â†’ (o âˆ© Subtype.val â»Â¹' s).Nonempty) âˆ§ â†‘y = x) â†’
    âˆ€ (o : Set P), IsOpen o â†’ x âˆˆ o â†’ (o âˆ© s).Nonempty",theorem intrinsicClosure_eq_closure : intrinsicClosure ğ•œ s = closure s ,":= by
  ext x
  simp only [mem_closure_iff, mem_intrinsicClosure]
  refine âŸ¨?_, fun h => âŸ¨âŸ¨x, _âŸ©, ?_, Subtype.coe_mk _ ?_âŸ©âŸ©
  Â· rintro âŸ¨x, h, rflâŸ© t ht hx
    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h _ (continuous_induced_dom.isOpen_preimage t ht) hx
    exact âŸ¨z, hzâ‚, hzâ‚‚âŸ©
  Â· rintro _ âŸ¨t, ht, rflâŸ© hx
    obtain âŸ¨y, hyt, hysâŸ© := h _ ht hx
    exact âŸ¨âŸ¨_, subset_affineSpan ğ•œ s hysâŸ©, hyt, hysâŸ©
  Â· by_contra hc
    obtain âŸ¨z, hzâ‚, hzâ‚‚âŸ© := h _ (affineSpan ğ•œ s).closed_of_finiteDimensional.isOpen_compl hc
    exact hzâ‚ (subset_affineSpan ğ•œ s hzâ‚‚)","rw [closure_eq_closure, intrinsicClosure_eq_closure]"
Mathlib/CategoryTheory/GradedObject/Associator.lean,CategoryTheory.GradedObject.Î¹_mapBifunctorAssociator_inv,Î¹_mapBifunctorAssociator_inv,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [â† cancel_mono ((mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).hom j),
    assoc, assoc, iso_inv_hom_id_apply, comp_id, Î¹_mapBifunctorAssociator_hom,
    â† NatTrans.comp_app_assoc, â† NatTrans.comp_app, Iso.inv_hom_id_app,
    NatTrans.id_app, NatTrans.id_app, id_comp]","error:  unknown identifier 'iso_inv_hom_id_apply'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.39474
Câ‚ : Type u_1
Câ‚‚ : Type u_2
Câ‚â‚‚ : Type u_3
Câ‚‚â‚ƒ : Type u_4
Câ‚ƒ : Type u_5
Câ‚„ : Type u_6
instâœâ¹ : Category.{u_13, u_1} Câ‚
instâœâ¸ : Category.{u_15, u_2} Câ‚‚
instâœâ· : Category.{u_14, u_5} Câ‚ƒ
instâœâ¶ : Category.{u_11, u_6} Câ‚„
instâœâµ : Category.{u_17, u_3} Câ‚â‚‚
instâœâ´ : Category.{u_12, u_4} Câ‚‚â‚ƒ
Fâ‚â‚‚ : Câ‚ â¥¤ Câ‚‚ â¥¤ Câ‚â‚‚
G : Câ‚â‚‚ â¥¤ Câ‚ƒ â¥¤ Câ‚„
F : Câ‚ â¥¤ Câ‚‚â‚ƒ â¥¤ Câ‚„
Gâ‚‚â‚ƒ : Câ‚‚ â¥¤ Câ‚ƒ â¥¤ Câ‚‚â‚ƒ
associator : bifunctorCompâ‚â‚‚ Fâ‚â‚‚ G â‰… bifunctorCompâ‚‚â‚ƒ F Gâ‚‚â‚ƒ
Iâ‚ : Type u_7
Iâ‚‚ : Type u_8
Iâ‚ƒ : Type u_9
J : Type u_10
r : Iâ‚ Ã— Iâ‚‚ Ã— Iâ‚ƒ â†’ J
Ïâ‚â‚‚ : BifunctorCompâ‚â‚‚IndexData r
Ïâ‚‚â‚ƒ : BifunctorCompâ‚‚â‚ƒIndexData r
Xâ‚ : GradedObject Iâ‚ Câ‚
Xâ‚‚ : GradedObject Iâ‚‚ Câ‚‚
Xâ‚ƒ : GradedObject Iâ‚ƒ Câ‚ƒ
instâœÂ³ : (((mapBifunctor Fâ‚â‚‚ Iâ‚ Iâ‚‚).obj Xâ‚).obj Xâ‚‚).HasMap Ïâ‚â‚‚.p
instâœÂ² : (((mapBifunctor G Ïâ‚â‚‚.Iâ‚â‚‚ Iâ‚ƒ).obj (mapBifunctorMapObj Fâ‚â‚‚ Ïâ‚â‚‚.p Xâ‚ Xâ‚‚)).obj Xâ‚ƒ).HasMap Ïâ‚â‚‚.q
instâœÂ¹ : (((mapBifunctor Gâ‚‚â‚ƒ Iâ‚‚ Iâ‚ƒ).obj Xâ‚‚).obj Xâ‚ƒ).HasMap Ïâ‚‚â‚ƒ.p
instâœ : (((mapBifunctor F Iâ‚ Ïâ‚‚â‚ƒ.Iâ‚‚â‚ƒ).obj Xâ‚).obj (mapBifunctorMapObj Gâ‚‚â‚ƒ Ïâ‚‚â‚ƒ.p Xâ‚‚ Xâ‚ƒ)).HasMap Ïâ‚‚â‚ƒ.q
Hâ‚â‚‚ : HasGoodTrifunctorâ‚â‚‚Obj Fâ‚â‚‚ G Ïâ‚â‚‚ Xâ‚ Xâ‚‚ Xâ‚ƒ
Hâ‚‚â‚ƒ : HasGoodTrifunctorâ‚‚â‚ƒObj F Gâ‚‚â‚ƒ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ
iâ‚ : Iâ‚
iâ‚‚ : Iâ‚‚
iâ‚ƒ : Iâ‚ƒ
j : J
h : r (iâ‚, iâ‚‚, iâ‚ƒ) = j
âŠ¢ Î¹MapBifunctorBifunctorâ‚‚â‚ƒMapObj F Gâ‚‚â‚ƒ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ iâ‚ iâ‚‚ iâ‚ƒ j h â‰«
      (mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).inv j â‰«
        (mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).hom j =
    ((associator.inv.app (Xâ‚ iâ‚)).app (Xâ‚‚ iâ‚‚)).app (Xâ‚ƒ iâ‚ƒ) â‰«
      Î¹MapBifunctorâ‚â‚‚BifunctorMapObj Fâ‚â‚‚ G Ïâ‚â‚‚ Xâ‚ Xâ‚‚ Xâ‚ƒ iâ‚ iâ‚‚ iâ‚ƒ j h â‰«
        (mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).hom j","lemma Î¹_mapBifunctorAssociator_inv (iâ‚ : Iâ‚) (iâ‚‚ : Iâ‚‚) (iâ‚ƒ : Iâ‚ƒ) (j : J) (h : r (iâ‚, iâ‚‚, iâ‚ƒ) = j) :
    Î¹MapBifunctorBifunctorâ‚‚â‚ƒMapObj F Gâ‚‚â‚ƒ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ iâ‚ iâ‚‚ iâ‚ƒ j h â‰«
      (mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).inv j =
    ((associator.inv.app (Xâ‚ iâ‚)).app (Xâ‚‚ iâ‚‚)).app (Xâ‚ƒ iâ‚ƒ) â‰«
      Î¹MapBifunctorâ‚â‚‚BifunctorMapObj Fâ‚â‚‚ G Ïâ‚â‚‚ Xâ‚ Xâ‚‚ Xâ‚ƒ iâ‚ iâ‚‚ iâ‚ƒ j h ",":= by
  rw [â† cancel_mono ((mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).hom j),
    assoc, assoc, Iso.inv_hom_id_eval, comp_id, Î¹_mapBifunctorAssociator_hom,
    â† NatTrans.comp_app_assoc, â† NatTrans.comp_app, Iso.inv_hom_id_app,
    NatTrans.id_app, NatTrans.id_app, id_comp]",dsimp [mapBifunctorAssociator]
Mathlib/RingTheory/EisensteinCriterion.lean,Polynomial.irreducible_of_eisenstein_criterion,irreducible_of_eisenstein_criterion,9e34a191034458a56331f976ff7400a26407c888,":=
  have hf0 : f â‰  0 := fun _ => by simp_all only [not_true, Submodule.zero_mem, coeff_zero]
  have hf : f.map (mk P) = C (mk P (leadingCoeff f)) * X ^ natDegree f :=
    map_eq_C_mul_X_pow_of_forall_coeff_mem hfP
  have hfd0 : 0 < f.natDegree := WithBot.coe_lt_coe.1 (lt_of_lt_of_le hfd0 degree_le_natDegree)
  âŸ¨mt degree_eq_zero_of_isUnit fun h => by simp_all only [lt_irrefl], by
    rintro p q rfl
    rw [Polynomial.map_mul] at hf
    rcases mul_eq_mul_prime_pow
        (show Prime (X : Polynomial (R â§¸ P)) from monic_X.prime_of_degree_eq_one degree_X) hf with
      âŸ¨m, n, b, c, hmnd, hbc, hp, hqâŸ©
    have hmn : 0 < m â†’ 0 < n â†’ False := by
      intro hm0 hn0
      refine' h0 _
      rw [coeff_zero_eq_eval_zero, eval_mul, sq]
      exact
        Ideal.mul_mem_mul (eval_zero_mem_ideal_of_eq_mul_X_pow hp hm0)
          (eval_zero_mem_ideal_of_eq_mul_X_pow hq hn0)
    have hpql0 : (mk P) (p * q).leadingCoeff â‰  0 := by rwa [Ne.def, eq_zero_iff_mem]
    have hp0 : p â‰  0 := fun h => by
      simp_all only [MulZeroClass.zero_mul, eq_self_iff_true, not_true, Ne.def]
    have hq0 : q â‰  0 := fun h => by
      simp_all only [eq_self_iff_true, not_true, Ne.def, MulZeroClass.mul_zero]
    have hbc0 : degree b = 0 âˆ§ degree c = 0 := by
      apply_fun degree at hbc
      rwa [degree_C hpql0, degree_mul, eq_comm, Nat.WithBot.add_eq_zero_iff] at hbc
    have hmp : m â‰¤ natDegree p := le_natDegree_of_map_eq_mul_X_pow hP hp hbc0.1
    have hnq : n â‰¤ natDegree q := le_natDegree_of_map_eq_mul_X_pow hP hq hbc0.2
    have hpmqn : p.natDegree = m âˆ§ q.natDegree = n := by
      rw [natDegree_mul hp0 hq0] at hmnd
      contrapose hmnd
      apply ne_of_lt
      rw [not_and_or] at hmnd
      cases' hmnd with hmnd hmnd
      Â· exact add_lt_add_of_lt_of_le (lt_of_le_of_ne hmp (Ne.symm hmnd)) hnq
      Â· exact add_lt_add_of_le_of_lt hmp (lt_of_le_of_ne hnq (Ne.symm hmnd))
    obtain rfl | rfl : m = 0 âˆ¨ n = 0 := by
      rwa [pos_iff_ne_zero, pos_iff_ne_zero, imp_false, Classical.not_not, â† or_iff_not_imp_left]
        at hmn
    Â· exact Or.inl (isUnit_of_natDegree_eq_zero_of_isPrimitive hu hpmqn.1)
    Â· exact Or.inr
          (isUnit_of_natDegree_eq_zero_of_isPrimitive
            (show IsPrimitive (q * p) by simpa [mul_comm] using hu)
            hpmqn.2)âŸ©","error:  application type mismatch
  eval_zero_mem_ideal_of_eq_mul_X_pow hp hm0
argument
  hm0
has type
  0 < m : Prop
but is expected to have type
  m â‰  0 : Prop
error:  application type mismatch
  eval_zero_mem_ideal_of_eq_mul_X_pow hq hn0
argument
  hn0
has type
  0 < n : Prop
but is expected to have type
  n â‰  0 : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.27568 â†’ ?m.27568 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.27570
R : Type u_1
instâœÂ¹ : CommRing R
instâœ : IsDomain R
P : Ideal R
hP : P.IsPrime
p q : R[X]
hfl : (p * q).leadingCoeff âˆ‰ P
hfP : âˆ€ (n : â„•), â†‘n < (p * q).degree â†’ (p * q).coeff n âˆˆ P
hfd0âœ : 0 < (p * q).degree
h0 : (p * q).coeff 0 âˆ‰ P ^ 2
hu : (p * q).IsPrimitive
hf0 : p * q â‰  0
hf : map (mk P) p * map (mk P) q = C ((mk P) (p * q).leadingCoeff) * X ^ (p * q).natDegree
hfd0 : 0 < (p * q).natDegree
m n : â„•
b c : (R â§¸ P)[X]
hmnd : m + n = (p * q).natDegree
hbc : C ((mk P) (p * q).leadingCoeff) = b * c
hp : map (mk P) p = b * X ^ m
hq : map (mk P) q = c * X ^ n
hmn : 0 < m â†’ 0 < n â†’ False
âŠ¢ (mk P) (p * q).leadingCoeff â‰  0
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.27653 â†’ ?m.27653 â†’ Prop
error:  unsolved goals
R : Type u_1
instâœÂ¹ : CommRing R
instâœ : IsDomain R
P : Ideal R
hP : P.IsPrime
p q : R[X]
m n : â„•
b c : (R â§¸ P)[X]
hfl : leadingCoeff 0 âˆ‰ P
hfP : âˆ€ (n : â„•), â†‘n < degree 0 â†’ coeff 0 n âˆˆ P
hfd0âœ : 0 < degree 0
h0 : coeff 0 0 âˆ‰ P ^ 2
hu : IsPrimitive 0
hf0 : 0 â‰  0
hf : b * X ^ m * (c * X ^ n) = b * c * X ^ natDegree 0
hfd0 : 0 < natDegree 0
hmnd : m + n = natDegree 0
hbc : C ((mk P) (leadingCoeff 0)) = b * c
hp : map (mk P) 0 = b * X ^ m
hq : map (mk P) q = c * X ^ n
hmn : 0 < m â†’ 0 < n â†’ False
hpql0 : (mk P) (leadingCoeff 0) â‰  0
h : p = 0
âŠ¢ False
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.28984 â†’ ?m.28984 â†’ Prop
error:  unsolved goals
R : Type u_1
instâœÂ¹ : CommRing R
instâœ : IsDomain R
P : Ideal R
hP : P.IsPrime
p q : R[X]
m n : â„•
b c : (R â§¸ P)[X]
hfl : leadingCoeff 0 âˆ‰ P
hfP : âˆ€ (n : â„•), â†‘n < degree 0 â†’ coeff 0 n âˆˆ P
hfd0âœ : 0 < degree 0
h0 : coeff 0 0 âˆ‰ P ^ 2
hu : IsPrimitive 0
hf0 : 0 â‰  0
hf : b * X ^ m * (c * X ^ n) = b * c * X ^ natDegree 0
hfd0 : 0 < natDegree 0
hmnd : m + n = natDegree 0
hbc : C ((mk P) (leadingCoeff 0)) = b * c
hp : map (mk P) p = b * X ^ m
hq : map (mk P) 0 = c * X ^ n
hmn : 0 < m â†’ 0 < n â†’ False
hpql0 : (mk P) (leadingCoeff 0) â‰  0
hp0 : p â‰  0
h : q = 0
âŠ¢ False","theorem irreducible_of_eisenstein_criterion {f : R[X]} {P : Ideal R} (hP : P.IsPrime)
    (hfl : f.leadingCoeff âˆ‰ P) (hfP : âˆ€ n : â„•, â†‘n < degree f â†’ f.coeff n âˆˆ P) (hfd0 : 0 < degree f)
    (h0 : f.coeff 0 âˆ‰ P ^ 2) (hu : f.IsPrimitive) : Irreducible f ",":=
  have hf0 : f â‰  0 := fun _ => by simp_all only [not_true, Submodule.zero_mem, coeff_zero]
  have hf : f.map (mk P) = C (mk P (leadingCoeff f)) * X ^ natDegree f :=
    map_eq_C_mul_X_pow_of_forall_coeff_mem hfP
  have hfd0 : 0 < f.natDegree := WithBot.coe_lt_coe.1 (lt_of_lt_of_le hfd0 degree_le_natDegree)
  âŸ¨mt degree_eq_zero_of_isUnit fun h => by simp_all only [lt_irrefl], by
    rintro p q rfl
    rw [Polynomial.map_mul] at hf
    rcases mul_eq_mul_prime_pow
        (show Prime (X : Polynomial (R â§¸ P)) from monic_X.prime_of_degree_eq_one degree_X) hf with
      âŸ¨m, n, b, c, hmnd, hbc, hp, hqâŸ©
    have hmn : 0 < m â†’ 0 < n â†’ False := by
      intro hm0 hn0
      refine h0 ?_
      rw [coeff_zero_eq_eval_zero, eval_mul, sq]
      exact
        Ideal.mul_mem_mul (eval_zero_mem_ideal_of_eq_mul_X_pow hp hm0.ne')
          (eval_zero_mem_ideal_of_eq_mul_X_pow hq hn0.ne')
    have hpql0 : (mk P) (p * q).leadingCoeff â‰  0 := by rwa [Ne, eq_zero_iff_mem]
    have hp0 : p â‰  0 := fun h => by
      simp_all only [zero_mul, eq_self_iff_true, not_true, Ne]
    have hq0 : q â‰  0 := fun h => by
      simp_all only [eq_self_iff_true, not_true, Ne, mul_zero]
    have hbc0 : degree b = 0 âˆ§ degree c = 0 := by
      apply_fun degree at hbc
      rwa [degree_C hpql0, degree_mul, eq_comm, Nat.WithBot.add_eq_zero_iff] at hbc
    have hmp : m â‰¤ natDegree p := le_natDegree_of_map_eq_mul_X_pow hP hp hbc0.1
    have hnq : n â‰¤ natDegree q := le_natDegree_of_map_eq_mul_X_pow hP hq hbc0.2
    have hpmqn : p.natDegree = m âˆ§ q.natDegree = n := by
      rw [natDegree_mul hp0 hq0] at hmnd
      contrapose hmnd
      apply ne_of_lt
      rw [not_and_or] at hmnd
      cases' hmnd with hmnd hmnd
      Â· exact add_lt_add_of_lt_of_le (lt_of_le_of_ne hmp (Ne.symm hmnd)) hnq
      Â· exact add_lt_add_of_le_of_lt hmp (lt_of_le_of_ne hnq (Ne.symm hmnd))
    obtain rfl | rfl : m = 0 âˆ¨ n = 0 := by
      rwa [pos_iff_ne_zero, pos_iff_ne_zero, imp_false, Classical.not_not, â† or_iff_not_imp_left]
        at hmn
    Â· exact Or.inl (isUnit_of_natDegree_eq_zero_of_isPrimitive hu hpmqn.1)
    Â· exact Or.inr
          (isUnit_of_natDegree_eq_zero_of_isPrimitive
            (show IsPrimitive (q * p) by simpa [mul_comm] using hu)
            hpmqn.2)âŸ©","refine irreducible_iff_irreducible_factorization.mpr âŸ¨?_, ?_âŸ©"
Mathlib/CategoryTheory/EqToHom.lean,CategoryTheory.congrArg_cast_hom_left,congrArg_cast_hom_left,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  cases p
  simp

 theorem congrArg_mpr_hom_left {X Y Z : C} (p : X = Y) (q : Y âŸ¶ Z) :
    (congrArg (fun W : C => W âŸ¶ Z) p).mpr q = eqToHom p â‰« q := by
  cases p
  simp",error:  'CategoryTheory.congrArg_mpr_hom_left' has already been declared,"theorem congrArg_cast_hom_left {X Y Z : C} (p : X = Y) (q : Y âŸ¶ Z) :
    cast (congrArg (fun W : C => W âŸ¶ Z) p.symm) q = eqToHom p â‰« q ",":= by
  cases p
  simp","simp only [eqToHom_left, eqToHom_refl, eqToHom_refl, eqToHom_refl]"
Mathlib/Geometry/Euclidean/Circumcenter.lean,Affine.Simplex.circumradius_pos,circumradius_pos,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  refine' lt_of_le_of_ne s.circumradius_nonneg _
  intro h
  have hr := s.dist_circumcenter_eq_circumradius
  simp_rw [â† h, dist_eq_zero] at hr
  have h01 := s.Independent.injective.ne (by simp : (0 : Fin (n + 2)) â‰  1)
  simp [hr] at h01","error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  s
has type
  Simplex â„ P (n + 1)
error:  unsolved goals
V : Type u_1
P : Type u_2
instâœÂ³ : NormedAddCommGroup V
instâœÂ² : InnerProductSpace â„ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
n : â„•
s : Simplex â„ P (n + 1)
h : 0 = s.circumradius
hr : âˆ€ (i : Fin (n + 1 + 1)), s.points i = s.circumcenter
âŠ¢ False",theorem circumradius_pos {n : â„•} (s : Simplex â„ P (n + 1)) : 0 < s.circumradius ,":= by
  refine lt_of_le_of_ne s.circumradius_nonneg ?_
  intro h
  have hr := s.dist_circumcenter_eq_circumradius
  simp_rw [â† h, dist_eq_zero] at hr
  have h01 := s.independent.injective.ne (by simp : (0 : Fin (n + 2)) â‰  1)
  simp [hr] at h01",rw [circumradius_pos]
Mathlib/Data/Set/Basic.lean,Set.inter_subset_ite,inter_subset_ite,70dcc1355b9ce0a6754f8d809c95a171072d3aac,":=
  ite_same t (s âˆ© s') â–¸ ite_mono _ (inter_subset_left _ _) (inter_subset_right _ _)","error:  function expected at
  inter_subset_left ?m.135866
term has type
  ?m.135865 âˆˆ ?m.135863
error:  function expected at
  inter_subset_right ?m.135908
term has type
  ?m.135907 âˆˆ ?m.135906",theorem inter_subset_ite (t s s' : Set Î±) : s âˆ© s' âŠ† t.ite s s' ,":=
  ite_same t (s âˆ© s') â–¸ ite_mono _ inter_subset_left inter_subset_right",refine Set.Subset.theorem_ite_of_subset_ite_subset t s' ?_
Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean,TopCat.pullback_fst_image_snd_preimage,pullback_fst_image_snd_preimage,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  ext x
  constructor
  Â· rintro âŸ¨y, hy, rflâŸ©
    exact
      âŸ¨(pullback.snd : pullback f g âŸ¶ _) y, hy,
        (ConcreteCategory.congr_hom pullback.condition y).symmâŸ©
  Â· rintro âŸ¨y, hy, eqâŸ©
    exact âŸ¨(TopCat.pullbackIsoProdSubtype f g).inv âŸ¨âŸ¨_, _âŸ©, eq.symmâŸ©, by simpa, by simpâŸ©","error:  application type mismatch
  ConcreteCategory.congr_hom pullback.condition y
argument
  y
has type
  â†‘(pullback f g) : Type u
but is expected to have type
  (forget ?m.266580).obj (pullback ?m.266585 ?m.266586) : Type ?u.266570
error:  tactic 'assumption' failed
J : Type v
instâœ : SmallCategory J
X Y Z : TopCat
f : X âŸ¶ Z
g : Y âŸ¶ Z
U : Set â†‘Y
x : â†‘X
y : â†‘Y
hy : y âˆˆ U
eq : g y = f x
âŠ¢ pullback.snd ((pullbackIsoProdSubtype f g).inv âŸ¨(x, y), â‹¯âŸ©) âˆˆ U
error:  unsolved goals
J : Type v
instâœ : SmallCategory J
X Y Z : TopCat
f : X âŸ¶ Z
g : Y âŸ¶ Z
U : Set â†‘Y
x : â†‘X
y : â†‘Y
hy : y âˆˆ U
eq : g y = f x
âŠ¢ pullback.fst ((pullbackIsoProdSubtype f g).inv âŸ¨(x, y), â‹¯âŸ©) = x","theorem pullback_fst_image_snd_preimage (f : X âŸ¶ Z) (g : Y âŸ¶ Z) (U : Set Y) :
    (pullback.fst : pullback f g âŸ¶ _) '' ((pullback.snd : pullback f g âŸ¶ _) â»Â¹' U) =
      f â»Â¹' (g '' U) ",":= by
  ext x
  constructor
  Â· rintro âŸ¨(y : (forget TopCat).obj _), hy, rflâŸ©
    exact
      âŸ¨(pullback.snd : pullback f g âŸ¶ _) y, hy,
        (ConcreteCategory.congr_hom pullback.condition y).symmâŸ©
  Â· rintro âŸ¨y, hy, eqâŸ©
    refine âŸ¨(TopCat.pullbackIsoProdSubtype f g).inv âŸ¨âŸ¨_, _âŸ©, eq.symmâŸ©, ?_, ?_âŸ©
    Â· simp only [coe_of, Set.mem_preimage]
      convert hy
      erw [pullbackIsoProdSubtype_inv_snd_apply]
    Â· rw [pullbackIsoProdSubtype_inv_fst_apply]","rw [â† pullback.condition, â† pullback.condition, â† pullback.condition, â† pullback.conditing,
  â† pullback.conditing, â† pullback.conditing, pullback.conditing]"
Mathlib/Order/Height.lean,Set.chainHeight_eq_iSup_Ici,chainHeight_eq_iSup_Ici,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  apply le_antisymm
  Â· refine' iSupâ‚‚_le _
    rintro (_ | âŸ¨x, xsâŸ©) h
    Â· exact zero_le _
    Â· apply le_trans _ (le_iSupâ‚‚ x (cons_mem_subchain_iff.mp h).1)
      apply length_le_chainHeight_of_mem_subchain
      refine âŸ¨h.1, fun i hi â†¦ âŸ¨h.2 i hi, ?_âŸ©âŸ©
      cases hi
      Â· exact left_mem_Ici
      rename_i hi
      cases' chain'_iff_pairwise.mp h.1 with _ _ h'
      exact (h' _ hi).le
  Â· exact iSupâ‚‚_le fun i _ â†¦ chainHeight_mono <| Set.inter_subset_left _ _","error:  function expected at
  inter_subset_left ?m.28753
term has type
  ?m.28752 âˆˆ ?m.28750","theorem chainHeight_eq_iSup_Ici : s.chainHeight = â¨† i âˆˆ s, (s âˆ© Set.Ici i).chainHeight ",":= by
  apply le_antisymm
  Â· refine iSupâ‚‚_le ?_
    rintro (_ | âŸ¨x, xsâŸ©) h
    Â· exact zero_le _
    Â· apply le_trans _ (le_iSupâ‚‚ x (cons_mem_subchain_iff.mp h).1)
      apply length_le_chainHeight_of_mem_subchain
      refine âŸ¨h.1, fun i hi â†¦ âŸ¨h.2 i hi, ?_âŸ©âŸ©
      cases hi
      Â· exact left_mem_Ici
      rename_i hi
      cases' chain'_iff_pairwise.mp h.1 with _ _ h'
      exact (h' _ hi).le
  Â· exact iSupâ‚‚_le fun i _ â†¦ chainHeight_mono Set.inter_subset_left",rw [chainHeight_eq_iSup_Ici]
Mathlib/Analysis/Calculus/LagrangeMultipliers.lean,IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d,IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d,b15c6ea0b0ad3ac6e15420c45ece165eca6725cc,":= by
  obtain âŸ¨Î›, Î›â‚€, hÎ›, hfÎ›âŸ© := hextr.exists_linear_map_of_hasStrictFDerivAt hf' hÏ†'
  refine' âŸ¨Î› 1, Î›â‚€, _, _âŸ©
  Â· contrapose! hÎ›
    simp only [Prod.mk_eq_zero] at hÎ› âŠ¢
    refine' âŸ¨LinearMap.ext fun x => _, hÎ›.2âŸ©
    simpa [hÎ›.1] using Î›.map_smul x 1
  Â· ext x
    have Hâ‚ : Î› (f' x) = f' x * Î› 1 := by
      simpa only [mul_one, Algebra.id.smul_eq_mul] using Î›.map_smul (f' x) 1
    have Hâ‚‚ : f' x * Î› 1 + Î›â‚€ * Ï†' x = 0 := by simpa only [Algebra.id.smul_eq_mul, Hâ‚] using hfÎ› x
    dsimp
    rw [Pi.smul_apply]
    simpa [mul_comm] using Hâ‚‚","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?b â€¢ ?x) ?i
case intro.intro.intro.refine'_2.h
E : Type u_1
F : Type u_2
instâœâµ : NormedAddCommGroup E
instâœâ´ : NormedSpace â„ E
instâœÂ³ : CompleteSpace E
instâœÂ² : NormedAddCommGroup F
instâœÂ¹ : NormedSpace â„ F
instâœ : CompleteSpace F
fâœ : E â†’ F
Ï† : E â†’ â„
xâ‚€ : E
f'âœ : E â†’L[â„] F
Ï†' : E â†’L[â„] â„
f : E â†’ â„
f' : E â†’L[â„] â„
hextr : IsLocalExtrOn Ï† {x | f x = f xâ‚€} xâ‚€
hf' : HasStrictFDerivAt f f' xâ‚€
hÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€
Î› : Module.Dual â„ â„
Î›â‚€ : â„
hÎ› : (Î›, Î›â‚€) â‰  0
hfÎ› : âˆ€ (x : E), Î› (f' x) + Î›â‚€ â€¢ Ï†' x = 0
x : E
Hâ‚ : Î› (f' x) = f' x * Î› 1
Hâ‚‚ : f' x * Î› 1 + Î›â‚€ * Ï†' x = 0
âŠ¢ Î› 1 * f' x + Î›â‚€ * Ï†' x = 0","theorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d {f : E â†’ â„} {f' : E â†’L[â„] â„}
    (hextr : IsLocalExtrOn Ï† {x | f x = f xâ‚€} xâ‚€) (hf' : HasStrictFDerivAt f f' xâ‚€)
    (hÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€) : âˆƒ a b : â„, (a, b) â‰  0 âˆ§ a â€¢ f' + b â€¢ Ï†' = 0 ",":= by
  obtain âŸ¨Î›, Î›â‚€, hÎ›, hfÎ›âŸ© := hextr.exists_linear_map_of_hasStrictFDerivAt hf' hÏ†'
  refine âŸ¨Î› 1, Î›â‚€, ?_, ?_âŸ©
  Â· contrapose! hÎ›
    simp only [Prod.mk_eq_zero] at hÎ› âŠ¢
    refine âŸ¨LinearMap.ext fun x => ?_, hÎ›.2âŸ©
    simpa [hÎ›.1] using Î›.map_smul x 1
  Â· ext x
    have Hâ‚ : Î› (f' x) = f' x * Î› 1 := by
      simpa only [mul_one, Algebra.id.smul_eq_mul] using Î›.map_smul (f' x) 1
    have Hâ‚‚ : f' x * Î› 1 + Î›â‚€ * Ï†' x = 0 := by simpa only [Algebra.id.smul_eq_mul, Hâ‚] using hfÎ› x
    simpa [mul_comm] using Hâ‚‚","rcases hf'.theorem_isLocalExtrOn_exists_multipliers_of_hasStrictFDerivAt_extr hf' hÏ†' hf' hÏ†' with
  âŸ¨a, b, ha, hb'âŸ©"
Mathlib/LinearAlgebra/Matrix/Spectrum.lean,Matrix.IsHermitian.det_eq_prod_eigenvalues,det_eq_prod_eigenvalues,aaf4ca2007ab15f02495731d0805034c9199aeea,":= by
  apply mul_left_cancelâ‚€ <| det_ne_zero_of_left_inverse <|
    unitary.coe_mul_star_self hA.eigenvectorUnitary
  rw [unitary.coe_star, â† det_mul, spectral_theorem, det_mul, mul_comm, det_diagonal]
  simp_rw [Function.comp_apply]","error:  tactic 'rewrite' failed, pattern is a metavariable
  ?m.92295
from equation
  ?m.92295 = â†‘?hA.eigenvectorUnitary * diagonal (RCLike.ofReal âˆ˜ ?hA.eigenvalues) * star â†‘?hA.eigenvectorUnitary
ğ•œ : Type u_1
instâœÂ² : RCLike ğ•œ
n : Type u_2
instâœÂ¹ : Fintype n
A : Matrix n n ğ•œ
instâœ : DecidableEq n
hA : A.IsHermitian
âŠ¢ (star â†‘hA.eigenvectorUnitary * A).det = (star â†‘hA.eigenvectorUnitary).det * âˆ i : n, â†‘(hA.eigenvalues i)","theorem det_eq_prod_eigenvalues : det A = âˆ i, (hA.eigenvalues i : ğ•œ) ",":= by
  convert congr_arg det hA.spectral_theorem
  rw [det_mul_right_comm]
  simp","have det_eq_prod_eigenvalues : det A = âˆ i, hA.eigenvalues i := by rw [det_eq_prod_eigenvalues]"
Mathlib/RingTheory/Jacobson.lean,Ideal.isJacobson_of_isIntegral',isJacobson_of_isIntegral',3a31aabe59645ce291dedbcbdd3f949a56d5178f,":=
  let _ : SMul R S := f.toSMul
  let _ : Algebra R S := f.toAlgebra
  have : Algebra.IsIntegral R S := âŸ¨hfâŸ©
  isJacobson_of_isIntegral hR","error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  f
has type
  R â†’+* S","theorem isJacobson_of_isIntegral' (f : R â†’+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :
    IsJacobson S ",":=
  let _ : Algebra R S := f.toAlgebra
  have : Algebra.IsIntegral R S := âŸ¨hfâŸ©
  isJacobson_of_isIntegral hR",exact isJacobson_of_isJacobson_of_isIntegral' f hf hR
Mathlib/LinearAlgebra/Finsupp.lean,LinearMap.splittingOfFunOnFintypeSurjective_splits,splittingOfFunOnFintypeSurjective_splits,67e80fd089fe45abea632652c43b78eba72d60e3,":= by
  classical
  refine pi_ext' fun x => ext_ring <| funext fun y => ?_
  dsimp [splittingOfFunOnFintypeSurjective]
  rw [linearEquivFunOnFintype_symm_single, Finsupp.sum_single_index, one_smul,
    (s (Finsupp.single x 1)).choose_spec, Finsupp.single_eq_pi_single]
  rw [zero_smul]","error:  unknown identifier 'linearEquivFunOnFintype_symm_single'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.783296
R : Type u_1
M : Type u_2
N : Type u_3
instâœâµ : Semiring R
instâœâ´ : AddCommMonoid M
instâœÂ³ : Module R M
instâœÂ² : AddCommMonoid N
instâœÂ¹ : Module R N
Î± : Type u_4
instâœ : Finite Î±
f : M â†’â‚—[R] Î± â†’ R
s : Surjective â‡‘f
x y : Î±
âŠ¢ f (((linearEquivFunOnFinite R R Î±).symm (Pi.single x 1)).sum fun x r â†¦ r â€¢ â‹¯.choose) y = Pi.single x 1 y","theorem splittingOfFunOnFintypeSurjective_splits [Finite Î±] (f : M â†’â‚—[R] Î± â†’ R)
    (s : Surjective f) : f.comp (splittingOfFunOnFintypeSurjective f s) = LinearMap.id ",":= by
  classical
  refine pi_ext' fun x => ext_ring <| funext fun y => ?_
  dsimp [splittingOfFunOnFintypeSurjective]
  rw [linearEquivFunOnFinite_symm_single, Finsupp.sum_single_index, one_smul,
    (s (Finsupp.single x 1)).choose_spec, Finsupp.single_eq_pi_single]
  rw [zero_smul]",rw [â† splittingOfFunOnFintypeSurjective_id]
Mathlib/LinearAlgebra/Matrix/PosDef.lean,Matrix.IsHermitian.posSemidef_of_eigenvalues_nonneg,IsHermitian.posSemidef_of_eigenvalues_nonneg,7800fb94347a7ae960c80963e8c98275d05eecba,":= by
  simp_rw [hA.conjTranspose_eigenvectorMatrix.symm â–¸ hA.spectral_theorem']
  refine (posSemidef_diagonal_iff.mpr fun i â†¦ ?_).mul_mul_conjTranspose_same _
  rw [IsROrC.le_iff_re_im]
  simpa using h i","error:  invalid 'simp', proposition expected
  (x_0 : Sort _abstMVar.0) â†’ x_0 â†’ x_0
error:  simp made no progress","lemma IsHermitian.posSemidef_of_eigenvalues_nonneg [DecidableEq n] {A : Matrix n n ğ•œ}
    (hA : IsHermitian A) (h : âˆ€ i : n, 0 â‰¤ hA.eigenvalues i) : PosSemidef A ",":= by
  rw [hA.spectral_theorem]
  refine (posSemidef_diagonal_iff.mpr ?_).mul_mul_conjTranspose_same _
  simpa using h","refine âŸ¨fun i â†¦ hA.eigenvalues i, fun i â†¦ hA.eigenvalues i, fun i â†¦ ?_âŸ©"
Mathlib/NumberTheory/Padics/PadicVal.lean,padicValRat.le_padicValRat_add_of_le,le_padicValRat_add_of_le,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":=
  if hq : q = 0 then by simpa [hq] using h
  else
    if hr : r = 0 then by simp [hr]
    else by
      have hqn : q.num â‰  0 := Rat.num_ne_zero_of_ne_zero hq
      have hqd : (q.den : â„¤) â‰  0 := by exact_mod_cast Rat.den_nz _
      have hrn : r.num â‰  0 := Rat.num_ne_zero_of_ne_zero hr
      have hrd : (r.den : â„¤) â‰  0 := by exact_mod_cast Rat.den_nz _
      have hqreq : q + r = (q.num * r.den + q.den * r.num) /. (q.den * r.den) := Rat.add_num_den _ _
      have hqrd : q.num * r.den + q.den * r.num â‰  0 := Rat.mk_num_ne_zero_of_ne_zero hqr hqreq
      conv_lhs => rw [â† @Rat.num_den q]
      rw [hqreq, padicValRat_le_padicValRat_iff hqn hqrd hqd (mul_ne_zero hqd hrd), â†
        multiplicity_le_multiplicity_iff, mul_left_comm,
        multiplicity.mul (Nat.prime_iff_prime_int.1 hp.1), add_mul]
      rw [â† @Rat.num_den q, â† @Rat.num_den r, padicValRat_le_padicValRat_iff hqn hrn hqd hrd, â†
        multiplicity_le_multiplicity_iff] at h
      calc
        _ â‰¤
            min (multiplicity (â†‘p) (q.num * r.den * q.den))
              (multiplicity (â†‘p) (â†‘q.den * r.num * â†‘q.den)) :=
          le_min
            (by rw [@multiplicity.mul _ _ _ _ (_ * _) _ (Nat.prime_iff_prime_int.1 hp.1), add_comm])
            (by
              rw [mul_assoc,
                  @multiplicity.mul _ _ _ _ (q.den : â„¤) (_ * _)
                    (Nat.prime_iff_prime_int.1 hp.1)]
              exact add_le_add_left h _)
        _ â‰¤ _ := min_le_multiplicity_add","error:  unknown constant 'Rat.num_ne_zero_of_ne_zero'
error:  unknown constant 'Rat.num_ne_zero_of_ne_zero'
error:  invalid use of field notation with `@` modifier
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.41902
p : â„•
hp : Fact (Nat.Prime p)
q r : â„š
hqr : q + r â‰  0
h : padicValRat p q â‰¤ padicValRat p r
hq : Â¬q = 0
hr : Â¬r = 0
hqn : q.num â‰  0
hqd : â†‘q.den â‰  0
hrn : r.num â‰  0
hrd : â†‘r.den â‰  0
hqreq : q + r = (q.num * â†‘r.den + â†‘q.den * r.num) /. (â†‘q.den * â†‘r.den)
hqrd : q.num * â†‘r.den + â†‘q.den * r.num â‰  0
| padicValRat p q
warning:  unused variable `hp`
note: this linter can be disabled with `set_option linter.unusedVariables false`","theorem le_padicValRat_add_of_le {q r : â„š} (hqr : q + r â‰  0)
    (h : padicValRat p q â‰¤ padicValRat p r) : padicValRat p q â‰¤ padicValRat p (q + r) ",":=
  if hq : q = 0 then by simpa [hq] using h
  else
    if hr : r = 0 then by simp [hr]
    else by
      have hqn : q.num â‰  0 := Rat.num_ne_zero.2 hq
      have hqd : (q.den : â„¤) â‰  0 := mod_cast Rat.den_nz _
      have hrn : r.num â‰  0 := Rat.num_ne_zero.2 hr
      have hrd : (r.den : â„¤) â‰  0 := mod_cast Rat.den_nz _
      have hqreq : q + r = (q.num * r.den + q.den * r.num) /. (q.den * r.den) := Rat.add_num_den _ _
      have hqrd : q.num * r.den + q.den * r.num â‰  0 := Rat.mk_num_ne_zero_of_ne_zero hqr hqreq
      conv_lhs => rw [â† q.num_divInt_den]
      rw [hqreq, padicValRat_le_padicValRat_iff hqn hqrd hqd (mul_ne_zero hqd hrd), â†
        multiplicity_le_multiplicity_iff, mul_left_comm,
        multiplicity.mul (Nat.prime_iff_prime_int.1 hp.1), add_mul]
      rw [â† q.num_divInt_den, â† r.num_divInt_den, padicValRat_le_padicValRat_iff hqn hrn hqd hrd, â†
        multiplicity_le_multiplicity_iff] at h
      calc
        _ â‰¤
            min (multiplicity (â†‘p) (q.num * r.den * q.den))
              (multiplicity (â†‘p) (â†‘q.den * r.num * â†‘q.den)) :=
          le_min
            (by rw [@multiplicity.mul _ _ _ _ (_ * _) _ (Nat.prime_iff_prime_int.1 hp.1), add_comm])
            (by
              rw [mul_assoc,
                  @multiplicity.mul _ _ _ _ (q.den : â„¤) (_ * _)
                    (Nat.prime_iff_prime_int.1 hp.1)]
              exact add_le_add_left h _)
        _ â‰¤ _ := min_le_multiplicity_add",rw [add_comm]
Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean,Orientation.oangle_eq_of_angle_eq_of_sign_eq,oangle_eq_of_angle_eq_of_sign_eq,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  by_cases h0 : (w = 0 âˆ¨ x = 0) âˆ¨ y = 0 âˆ¨ z = 0
  Â· have hs' : (o.oangle w x).sign = 0 âˆ§ (o.oangle y z).sign = 0 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      Â· simpa using hs.symm
      Â· simpa using hs.symm
      Â· simpa using hs
      Â· simpa using hs
    rcases hs' with âŸ¨hswx, hsyzâŸ©
    have h' : InnerProductGeometry.angle w x = Ï€ / 2 âˆ§ InnerProductGeometry.angle y z = Ï€ / 2 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      Â· simpa using h.symm
      Â· simpa using h.symm
      Â· simpa using h
      Â· simpa using h
    rcases h' with âŸ¨hwx, hyzâŸ©
    have hpi : Ï€ / 2 â‰  Ï€ := by
      intro hpi
      rw [div_eq_iff, eq_comm, â† sub_eq_zero, mul_two, add_sub_cancel] at hpi
      Â· exact Real.pi_pos.ne.symm hpi
      Â· exact two_ne_zero
    have h0wx : w = 0 âˆ¨ x = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hswx
      simpa [hwx, Real.pi_pos.ne.symm, hpi] using h0'
    have h0yz : y = 0 âˆ¨ z = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hsyz
      simpa [hyz, Real.pi_pos.ne.symm, hpi] using h0'
    rcases h0wx with (h0wx | h0wx) <;> rcases h0yz with (h0yz | h0yz) <;> simp [h0wx, h0yz]
  Â· push_neg at h0
    rw [Real.Angle.eq_iff_abs_toReal_eq_of_sign_eq hs]
    rwa [o.angle_eq_abs_oangle_toReal h0.1.1 h0.1.2,
      o.angle_eq_abs_oangle_toReal h0.2.1 h0.2.2] at h","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + (?b - ?a)
V : Type u_1
V' : Type u_2
instâœâµ : NormedAddCommGroup V
instâœâ´ : NormedAddCommGroup V'
instâœÂ³ : InnerProductSpace â„ V
instâœÂ² : InnerProductSpace â„ V'
instâœÂ¹ : Fact (finrank â„ V = 2)
instâœ : Fact (finrank â„ V' = 2)
o : Orientation â„ V (Fin 2)
w x y z : V
h : InnerProductGeometry.angle w x = InnerProductGeometry.angle y z
hs : (o.oangle w x).sign = (o.oangle y z).sign
h0 : (w = 0 âˆ¨ x = 0) âˆ¨ y = 0 âˆ¨ z = 0
hswx : (o.oangle w x).sign = 0
hsyz : (o.oangle y z).sign = 0
hwx : InnerProductGeometry.angle w x = Ï€ / 2
hyz : InnerProductGeometry.angle y z = Ï€ / 2
hpi : Ï€ + Ï€ - Ï€ = 0
âŠ¢ False","theorem oangle_eq_of_angle_eq_of_sign_eq {w x y z : V}
    (h : InnerProductGeometry.angle w x = InnerProductGeometry.angle y z)
    (hs : (o.oangle w x).sign = (o.oangle y z).sign) : o.oangle w x = o.oangle y z ",":= by
  by_cases h0 : (w = 0 âˆ¨ x = 0) âˆ¨ y = 0 âˆ¨ z = 0
  Â· have hs' : (o.oangle w x).sign = 0 âˆ§ (o.oangle y z).sign = 0 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      Â· simpa using hs.symm
      Â· simpa using hs.symm
      Â· simpa using hs
      Â· simpa using hs
    rcases hs' with âŸ¨hswx, hsyzâŸ©
    have h' : InnerProductGeometry.angle w x = Ï€ / 2 âˆ§ InnerProductGeometry.angle y z = Ï€ / 2 := by
      rcases h0 with ((rfl | rfl) | rfl | rfl)
      Â· simpa using h.symm
      Â· simpa using h.symm
      Â· simpa using h
      Â· simpa using h
    rcases h' with âŸ¨hwx, hyzâŸ©
    have hpi : Ï€ / 2 â‰  Ï€ := by
      intro hpi
      rw [div_eq_iff, eq_comm, â† sub_eq_zero, mul_two, add_sub_cancel_right] at hpi
      Â· exact Real.pi_pos.ne.symm hpi
      Â· exact two_ne_zero
    have h0wx : w = 0 âˆ¨ x = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hswx
      simpa [hwx, Real.pi_pos.ne.symm, hpi] using h0'
    have h0yz : y = 0 âˆ¨ z = 0 := by
      have h0' := o.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero hsyz
      simpa [hyz, Real.pi_pos.ne.symm, hpi] using h0'
    rcases h0wx with (h0wx | h0wx) <;> rcases h0yz with (h0yz | h0yz) <;> simp [h0wx, h0yz]
  Â· push_neg at h0
    rw [Real.Angle.eq_iff_abs_toReal_eq_of_sign_eq hs]
    rwa [o.angle_eq_abs_oangle_toReal h0.1.1 h0.1.2,
      o.angle_eq_abs_oangle_toReal h0.2.1 h0.2.2] at h",refine (o.oangle_eq_of_angle_eq_of_sign_eq w x y z).symm.trans ?_
Mathlib/Algebra/Homology/ExactSequence.lean,CategoryTheory.ComposableArrows.exact_iff_Î´last,exact_iff_Î´last,4ce1bee1aec1b13e15aa7ab6b7f2b65c272ebb54,":= by
  constructor
  Â· intro h
    constructor
    Â· exact Exact.mk (IsComplex.mk (fun i hi => h.toIsComplex.zero i))
        (fun i hi => h.exact i)
    Â· rw [exactâ‚‚_iff]; swap
      Â· rw [isComplexâ‚‚_iff]
        exact h.toIsComplex.zero n
      exact h.exact n (by linarith)
  Â· rintro âŸ¨h, h'âŸ©
    refine' Exact.mk (IsComplex.mk (fun i hi => _)) (fun i hi => _)
    Â· obtain hi | rfl := LE.le.lt_or_eq (show i â‰¤ n by linarith)
      Â· exact h.toIsComplex.zero i
      Â· exact h'.toIsComplex.zero 0
    Â· obtain hi | rfl := LE.le.lt_or_eq (show i â‰¤ n by linarith)
      Â· exact h.exact i
      Â· exact h'.exact 0","error:  unknown tactic
error:  unsolved goals
C : Type u_1
instâœÂ¹ : Category.{u_2, u_1} C
instâœ : HasZeroMorphisms C
nâœ : â„•
Sâœ : ComposableArrows C nâœ
n : â„•
S : ComposableArrows C (n + 2)
h : S.Exact
âŠ¢ n + 2 â‰¤ n + 2
error:  unsolved goals
case mpr
C : Type u_1
instâœÂ¹ : Category.{u_2, u_1} C
instâœ : HasZeroMorphisms C
nâœ : â„•
Sâœ : ComposableArrows C nâœ
n : â„•
S : ComposableArrows C (n + 2)
âŠ¢ S.Î´last.Exact âˆ§ (mkâ‚‚ (S.map' n (n + 1) â‹¯ â‹¯) (S.map' (n + 1) (n + 2) â‹¯ â‹¯)).Exact â†’ S.Exact","lemma exact_iff_Î´last {n : â„•} (S : ComposableArrows C (n + 2)) :
    S.Exact â†” S.Î´last.Exact âˆ§ (mkâ‚‚ (S.map' n (n + 1)) (S.map' (n + 1) (n + 2))).Exact ",":= by
  constructor
  Â· intro h
    constructor
    Â· exact Exact.mk (IsComplex.mk (fun i hi => h.toIsComplex.zero i))
        (fun i hi => h.exact i)
    Â· rw [exactâ‚‚_iff]; swap
      Â· rw [isComplexâ‚‚_iff]
        exact h.toIsComplex.zero n
      exact h.exact n (by omega)
  Â· rintro âŸ¨h, h'âŸ©
    refine Exact.mk (IsComplex.mk (fun i hi => ?_)) (fun i hi => ?_)
    Â· simp only [add_le_add_iff_right, ge_iff_le] at hi
      obtain hi | rfl := hi.lt_or_eq
      Â· exact h.toIsComplex.zero i
      Â· exact h'.toIsComplex.zero 0
    Â· simp only [add_le_add_iff_right, ge_iff_le] at hi
      obtain hi | rfl := hi.lt_or_eq
      Â· exact h.exact i
      Â· exact h'.exact 0",constructor
Mathlib/LinearAlgebra/TensorProduct/Submodule.lean,Submodule.comm_trans_lTensorOne,comm_trans_lTensorOne,6476f50fd255f9405ed097d5642d2a495a30b7ec,":= by
  refine LinearEquiv.toLinearMap_injective <| TensorProduct.ext' fun x âŸ¨m, hmâŸ© â†¦ ?_
  obtain âŸ¨y, rflâŸ© := mem_one.1 hm
  simp","error:  unsolved goals
case intro
R : Type u
S : Type v
instâœÂ² : CommSemiring R
instâœÂ¹ : Semiring S
instâœ : Algebra R S
M N : Submodule R S
x : â†¥M
xâœ : â†¥âŠ¥
y : R
hm : (algebraMap R S) y âˆˆ âŠ¥
âŠ¢ M.lTensorOne (âŸ¨(algebraMap R S) y, hmâŸ© âŠ—â‚œ[R] x) = M.rTensorOne (x âŠ—â‚œ[R] âŸ¨(algebraMap R S) y, hmâŸ©)","theorem comm_trans_lTensorOne :
    (TensorProduct.comm R _ _).trans M.lTensorOne = M.rTensorOne ",":= by
  refine LinearEquiv.toLinearMap_injective <| TensorProduct.ext' fun m r â†¦ ?_
  obtain âŸ¨x, hâŸ© := Algebra.mem_bot.1 r.2
  replace h : algebraMap R _ x = r := Subtype.val_injective h
  rw [â† h]; simp","simp [rTensorOne, comm_trans_lTensorOne]"
Mathlib/Topology/Compactness/Compact.lean,Filter.hasBasis_coclosedCompact,hasBasis_coclosedCompact,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp only [Filter.coclosedCompact, iInf_and']
  refine' hasBasis_biInf_principal' _ âŸ¨âˆ…, isClosed_empty, isCompact_emptyâŸ©
  rintro s âŸ¨hsâ‚, hsâ‚‚âŸ© t âŸ¨htâ‚, htâ‚‚âŸ©
  exact âŸ¨s âˆª t, âŸ¨âŸ¨hsâ‚.union htâ‚, hsâ‚‚.union htâ‚‚âŸ©, compl_subset_compl.2 (subset_union_left _ _),
    compl_subset_compl.2 (subset_union_right _ _)âŸ©âŸ©","error:  function expected at
  subset_union_left ?m.102099
term has type
  ?m.102098 âˆˆ ?m.102096 âˆª ?m.102097
error:  function expected at
  subset_union_right ?m.102151
term has type
  ?m.102150 âˆˆ ?m.102148 âˆª ?m.102149","theorem hasBasis_coclosedCompact :
    (Filter.coclosedCompact X).HasBasis (fun s => IsClosed s âˆ§ IsCompact s) compl ",":= by
  simp only [Filter.coclosedCompact, iInf_and']
  refine hasBasis_biInf_principal' ?_ âŸ¨âˆ…, isClosed_empty, isCompact_emptyâŸ©
  rintro s âŸ¨hsâ‚, hsâ‚‚âŸ© t âŸ¨htâ‚, htâ‚‚âŸ©
  exact âŸ¨s âˆª t, âŸ¨âŸ¨hsâ‚.union htâ‚, hsâ‚‚.union htâ‚‚âŸ©, compl_subset_compl.2 subset_union_left,
    compl_subset_compl.2 subset_union_rightâŸ©âŸ©",refine hasBasis_coclosedCompact.theorem_compl_isClosedCompact hasBasis_coclosedCompact.isCompact
Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean,Polynomial.orderOf_root_cyclotomic_dvd,orderOf_root_cyclotomic_dvd,e0989671112bd22d51437b85db4afabad67d0756,":= by
  apply orderOf_dvd_of_pow_eq_one
  suffices hpow : eval (Nat.castRingHom (ZMod p) a) (X ^ n - 1 : (ZMod p)[X]) = 0
  Â· simp only [eval_X, eval_one, eval_pow, eval_sub, eq_natCast] at hpow
    apply Units.val_eq_one.1
    simp only [sub_eq_zero.mp hpow, ZMod.coe_unitOfCoprime, Units.val_pow_eq_pow_val]
  rw [IsRoot.def] at hroot
  rw [â† prod_cyclotomic_eq_X_pow_sub_one hpos (ZMod p), â† Nat.cons_self_properDivisors hpos.ne',
    Finset.prod_cons, eval_mul, hroot, zero_mul]",error:  unexpected token 'Â·'; expected 'by' or 'from',"theorem orderOf_root_cyclotomic_dvd {n : â„•} (hpos : 0 < n) {p : â„•} [Fact p.Prime] {a : â„•}
    (hroot : IsRoot (cyclotomic n (ZMod p)) (Nat.castRingHom (ZMod p) a)) :
    orderOf (ZMod.unitOfCoprime a (coprime_of_root_cyclotomic hpos hroot)) âˆ£ n ",":= by
  apply orderOf_dvd_of_pow_eq_one
  suffices hpow : eval (Nat.castRingHom (ZMod p) a) (X ^ n - 1 : (ZMod p)[X]) = 0 by
    simp only [eval_X, eval_one, eval_pow, eval_sub, eq_natCast] at hpow
    apply Units.val_eq_one.1
    simp only [sub_eq_zero.mp hpow, ZMod.coe_unitOfCoprime, Units.val_pow_eq_pow_val]
  rw [IsRoot.def] at hroot
  rw [â† prod_cyclotomic_eq_X_pow_sub_one hpos (ZMod p), â† Nat.cons_self_properDivisors hpos.ne',
    Finset.prod_cons, eval_mul, hroot, zero_mul]",apply orderOf_root_cyclotomic_dvd
Mathlib/Geometry/Euclidean/Circumcenter.lean,Affine.Simplex.circumsphere_unique_dist_eq,circumsphere_unique_dist_eq,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  s.Independent.existsUnique_dist_eq.choose_spec","error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  s
has type
  Simplex â„ P n","theorem circumsphere_unique_dist_eq {n : â„•} (s : Simplex â„ P n) :
    (s.circumsphere.center âˆˆ affineSpan â„ (Set.range s.points) âˆ§
        Set.range s.points âŠ† s.circumsphere) âˆ§
      âˆ€ cs : Sphere P,
        cs.center âˆˆ affineSpan â„ (Set.range s.points) âˆ§ Set.range s.points âŠ† cs â†’
          cs = s.circumsphere ",":=
  s.independent.existsUnique_dist_eq.choose_spec","simp only [circumsphere_eq_circumsphere_eq_circumsphere, circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circumsphere_eq_circumsphere_eq_circumsphere,
  circumsphere_eq_circums"
Mathlib/Analysis/Analytic/Composition.lean,HasFPowerSeriesAt.comp,HasFPowerSeriesAt.comp,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  rcases hg with âŸ¨rg, HgâŸ©
  rcases hf with âŸ¨rf, HfâŸ©
  rcases q.comp_summable_nnreal p Hg.radius_pos Hf.radius_pos with âŸ¨r, r_pos : 0 < r, hrâŸ©
  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© :
    âˆƒ (Î´ : â„â‰¥0âˆ) (_H : 0 < Î´), âˆ€ {z : E}, z âˆˆ EMetric.ball x Î´ â†’ f z âˆˆ EMetric.ball (f x) rg := by
    have : EMetric.ball (f x) rg âˆˆ ğ“ (f x) := EMetric.ball_mem_nhds _ Hg.r_pos
    rcases EMetric.mem_nhds_iff.1 (Hf.analyticAt.continuousAt this) with âŸ¨Î´, Î´pos, HÎ´âŸ©
    exact âŸ¨Î´, Î´pos, fun hz => HÎ´ hzâŸ©
  let rf' := min rf Î´
  have min_pos : 0 < min rf' r := by
    simp only [r_pos, Hf.r_pos, Î´pos, lt_min_iff, ENNReal.coe_pos, and_self_iff]
  refine' âŸ¨min rf' r, _âŸ©
  refine'
    âŸ¨le_trans (min_le_right rf' r) (FormalMultilinearSeries.le_comp_radius_of_summable q p r hr),
      min_pos, @fun y hy => _âŸ©
  have y_mem : y âˆˆ EMetric.ball (0 : E) rf :=
    (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_left _ _))) hy
  have fy_mem : f (x + y) âˆˆ EMetric.ball (f x) rg := by
    apply hÎ´
    have : y âˆˆ EMetric.ball (0 : E) Î´ :=
      (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_right _ _))) hy
    simpa [edist_eq_coe_nnnorm_sub, edist_eq_coe_nnnorm]
  have A : Tendsto (fun n => âˆ‘ a in Finset.Ico 1 n, p a fun _b => y)
      atTop (ğ“ (f (x + y) - f x)) := by
    have L :
      âˆ€á¶  n in atTop, (âˆ‘ a in Finset.range n, p a fun _b => y) - f x
        = âˆ‘ a in Finset.Ico 1 n, p a fun _b => y := by
      rw [eventually_atTop]
      refine' âŸ¨1, fun n hn => _âŸ©
      symm
      rw [eq_sub_iff_add_eq', Finset.range_eq_Ico, â† Hf.coeff_zero fun _i => y,
        Finset.sum_eq_sum_Ico_succ_bot hn]
    have :
      Tendsto (fun n => (âˆ‘ a in Finset.range n, p a fun _b => y) - f x) atTop
        (ğ“ (f (x + y) - f x)) :=
      (Hf.hasSum y_mem).tendsto_sum_nat.sub tendsto_const_nhds
    exact Tendsto.congr' L this
  have B :
    Tendsto (fun n => q.partialSum n (âˆ‘ a in Finset.Ico 1 n, p a fun _b => y)) atTop
      (ğ“ (g (f (x + y)))) := by
    have Bâ‚ : ContinuousAt (fun z : F => g (f x + z)) (f (x + y) - f x) := by
      refine' ContinuousAt.comp _ (continuous_const.add continuous_id).continuousAt
      simp only [add_sub_cancel'_right, id.def]
      exact Hg.continuousOn.continuousAt (IsOpen.mem_nhds EMetric.isOpen_ball fy_mem)
    have Bâ‚‚ : f (x + y) - f x âˆˆ EMetric.ball (0 : F) rg := by
      simpa [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub] using fy_mem
    rw [â† EMetric.isOpen_ball.nhdsWithin_eq Bâ‚‚] at A
    convert Hg.tendstoLocallyUniformlyOn.tendsto_comp Bâ‚.continuousWithinAt Bâ‚‚ A
    simp only [add_sub_cancel'_right]
  have C :
    Tendsto
      (fun n => âˆ‘ i in compPartialSumTarget 0 n n, q.compAlongComposition p i.2 fun _j => y)
      atTop (ğ“ (g (f (x + y)))) :=
    by simpa [comp_partialSum] using B
  have D :
    HasSum (fun i : Î£ n, Composition n => q.compAlongComposition p i.2 fun _j => y)
      (g (f (x + y))) :=
    haveI cau :
      CauchySeq fun s : Finset (Î£ n, Composition n) =>
        âˆ‘ i in s, q.compAlongComposition p i.2 fun _j => y := by
      apply cauchySeq_finset_of_norm_bounded _ (NNReal.summable_coe.2 hr) _
      simp only [coe_nnnorm, NNReal.coe_mul, NNReal.coe_pow]
      rintro âŸ¨n, câŸ©
      calc
        â€–(compAlongComposition q p c) fun _j : Fin n => yâ€– â‰¤
            â€–compAlongComposition q p câ€– * âˆ _j : Fin n, â€–yâ€– :=
          by apply ContinuousMultilinearMap.le_op_norm
        _ â‰¤ â€–compAlongComposition q p câ€– * (r : â„) ^ n := by
          apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
          rw [Finset.prod_const, Finset.card_fin]
          apply pow_le_pow_left (norm_nonneg _)
          rw [EMetric.mem_ball, edist_eq_coe_nnnorm] at hy
          have := le_trans (le_of_lt hy) (min_le_right _ _)
          rwa [ENNReal.coe_le_coe, â† NNReal.coe_le_coe, coe_nnnorm] at this
    tendsto_nhds_of_cauchySeq_of_subseq cau compPartialSumTarget_tendsto_atTop C
  have E : HasSum (fun n => (q.comp p) n fun _j => y) (g (f (x + y))) := by
    apply D.sigma
    intro n
    dsimp [FormalMultilinearSeries.comp]
    convert hasSum_fintype (Î± := G) (Î² := Composition n) _
    simp only [ContinuousMultilinearMap.sum_apply]
    rfl
  rw [Function.comp_apply]
  exact E","error:  unsolved goals
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
G : Type u_4
H : Type u_5
instâœâ¸ : NontriviallyNormedField ğ•œ
instâœâ· : NormedAddCommGroup E
instâœâ¶ : NormedSpace ğ•œ E
instâœâµ : NormedAddCommGroup F
instâœâ´ : NormedSpace ğ•œ F
instâœÂ³ : NormedAddCommGroup G
instâœÂ² : NormedSpace ğ•œ G
instâœÂ¹ : NormedAddCommGroup H
instâœ : NormedSpace ğ•œ H
g : F â†’ G
f : E â†’ F
q : FormalMultilinearSeries ğ•œ F G
p : FormalMultilinearSeries ğ•œ E F
x : E
rg : â„â‰¥0âˆ
Hg : HasFPowerSeriesOnBall g q (f x) rg
rf : â„â‰¥0âˆ
Hf : HasFPowerSeriesOnBall f p x rf
r : â„â‰¥0
r_pos : 0 < r
hr : Summable fun i â†¦ â€–q.compAlongComposition p i.sndâ€–â‚Š * r ^ i.fst
Î´ : â„â‰¥0âˆ
Î´pos : 0 < Î´
hÎ´ : âˆ€ {z : E}, z âˆˆ EMetric.ball x Î´ â†’ f z âˆˆ EMetric.ball (f x) rg
rf' : â„â‰¥0âˆ := min rf Î´
âŠ¢ 0 < rf' âˆ§ True
warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.647845 â†’ ?m.647845
  
  unknown constant 'FormalMultilinearSeries.id.def'
warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
warning:  `ContinuousMultilinearMap.le_op_norm` has been deprecated, use `ContinuousMultilinearMap.le_opNorm` instead
warning:  `List.get_splitWrtComposition` has been deprecated, use `List.getElem_splitWrtComposition` instead
warning:  `List.get_drop'` has been deprecated, use `List.getElem_drop'` instead
warning:  `List.get_take'` has been deprecated, use `List.getElem_take` instead","theorem HasFPowerSeriesAt.comp {g : F â†’ G} {f : E â†’ F} {q : FormalMultilinearSeries ğ•œ F G}
    {p : FormalMultilinearSeries ğ•œ E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) : HasFPowerSeriesAt (g âˆ˜ f) (q.comp p) x ",":= by
  rcases hg with âŸ¨rg, HgâŸ©
  rcases hf with âŸ¨rf, HfâŸ©
  rcases q.comp_summable_nnreal p Hg.radius_pos Hf.radius_pos with âŸ¨r, r_pos : 0 < r, hrâŸ©
  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© :
    âˆƒ Î´ : â„â‰¥0âˆ, 0 < Î´ âˆ§ âˆ€ {z : E}, z âˆˆ EMetric.ball x Î´ â†’ f z âˆˆ EMetric.ball (f x) rg := by
    have : EMetric.ball (f x) rg âˆˆ ğ“ (f x) := EMetric.ball_mem_nhds _ Hg.r_pos
    rcases EMetric.mem_nhds_iff.1 (Hf.analyticAt.continuousAt this) with âŸ¨Î´, Î´pos, HÎ´âŸ©
    exact âŸ¨Î´, Î´pos, fun hz => HÎ´ hzâŸ©
  let rf' := min rf Î´
  have min_pos : 0 < min rf' r := by
    simp only [rf', r_pos, Hf.r_pos, Î´pos, lt_min_iff, ENNReal.coe_pos, and_self_iff]
  refine âŸ¨min rf' r, ?_âŸ©
  refine
    âŸ¨le_trans (min_le_right rf' r) (FormalMultilinearSeries.le_comp_radius_of_summable q p r hr),
      min_pos, @fun y hy => ?_âŸ©
  have y_mem : y âˆˆ EMetric.ball (0 : E) rf :=
    (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_left _ _))) hy
  have fy_mem : f (x + y) âˆˆ EMetric.ball (f x) rg := by
    apply hÎ´
    have : y âˆˆ EMetric.ball (0 : E) Î´ :=
      (EMetric.ball_subset_ball (le_trans (min_le_left _ _) (min_le_right _ _))) hy
    simpa [edist_eq_coe_nnnorm_sub, edist_eq_coe_nnnorm]
  have A : Tendsto (fun n => âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y)
      atTop (ğ“ (f (x + y) - f x)) := by
    have L :
      âˆ€á¶  n in atTop, (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x
        = âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y := by
      rw [eventually_atTop]
      refine âŸ¨1, fun n hn => ?_âŸ©
      symm
      rw [eq_sub_iff_add_eq', Finset.range_eq_Ico, â† Hf.coeff_zero fun _i => y,
        Finset.sum_eq_sum_Ico_succ_bot hn]
    have :
      Tendsto (fun n => (âˆ‘ a âˆˆ Finset.range n, p a fun _b => y) - f x) atTop
        (ğ“ (f (x + y) - f x)) :=
      (Hf.hasSum y_mem).tendsto_sum_nat.sub tendsto_const_nhds
    exact Tendsto.congr' L this
  have B :
    Tendsto (fun n => q.partialSum n (âˆ‘ a âˆˆ Finset.Ico 1 n, p a fun _b => y)) atTop
      (ğ“ (g (f (x + y)))) := by
    have Bâ‚ : ContinuousAt (fun z : F => g (f x + z)) (f (x + y) - f x) := by
      refine ContinuousAt.comp ?_ (continuous_const.add continuous_id).continuousAt
      simp only [add_sub_cancel, _root_.id]
      exact Hg.continuousOn.continuousAt (IsOpen.mem_nhds EMetric.isOpen_ball fy_mem)
    have Bâ‚‚ : f (x + y) - f x âˆˆ EMetric.ball (0 : F) rg := by
      simpa [edist_eq_coe_nnnorm, edist_eq_coe_nnnorm_sub] using fy_mem
    rw [â† EMetric.isOpen_ball.nhdsWithin_eq Bâ‚‚] at A
    convert Hg.tendstoLocallyUniformlyOn.tendsto_comp Bâ‚.continuousWithinAt Bâ‚‚ A
    simp only [add_sub_cancel]
  have C :
    Tendsto
      (fun n => âˆ‘ i âˆˆ compPartialSumTarget 0 n n, q.compAlongComposition p i.2 fun _j => y)
      atTop (ğ“ (g (f (x + y)))) := by
    simpa [comp_partialSum] using B
  have D :
    HasSum (fun i : Î£ n, Composition n => q.compAlongComposition p i.2 fun _j => y)
      (g (f (x + y))) :=
    haveI cau :
      CauchySeq fun s : Finset (Î£ n, Composition n) =>
        âˆ‘ i âˆˆ s, q.compAlongComposition p i.2 fun _j => y := by
      apply cauchySeq_finset_of_norm_bounded _ (NNReal.summable_coe.2 hr) _
      simp only [coe_nnnorm, NNReal.coe_mul, NNReal.coe_pow]
      rintro âŸ¨n, câŸ©
      calc
        â€–(compAlongComposition q p c) fun _j : Fin n => yâ€– â‰¤
            â€–compAlongComposition q p câ€– * âˆ _j : Fin n, â€–yâ€– := by
          apply ContinuousMultilinearMap.le_opNorm
        _ â‰¤ â€–compAlongComposition q p câ€– * (r : â„) ^ n := by
          apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
          rw [Finset.prod_const, Finset.card_fin]
          apply pow_le_pow_left (norm_nonneg _)
          rw [EMetric.mem_ball, edist_eq_coe_nnnorm] at hy
          have := le_trans (le_of_lt hy) (min_le_right _ _)
          rwa [ENNReal.coe_le_coe, â† NNReal.coe_le_coe, coe_nnnorm] at this
    tendsto_nhds_of_cauchySeq_of_subseq cau compPartialSumTarget_tendsto_atTop C
  have E : HasSum (fun n => (q.comp p) n fun _j => y) (g (f (x + y))) := by
    apply D.sigma
    intro n
    dsimp [FormalMultilinearSeries.comp]
    convert hasSum_fintype (Î± := G) (Î² := Composition n) _
    simp only [ContinuousMultilinearMap.sum_apply]
    rfl
  rw [Function.comp_apply]
  exact E","rw [â† hasFPowerSeriesAt_iff_hasFPowerSeriesAt, â† hasFPowerSeriesAt_iff_hasFPowerSeries]"
Mathlib/NumberTheory/ModularForms/JacobiTheta/Bounds.lean,HurwitzKernelBounds.isBigO_atTop_F_nat_zero_sub,isBigO_atTop_F_nat_zero_sub,20f51e38436d507b407de72766be0df108b734cf,":= by
  split_ifs with h
  Â· rw [h]
    have : (fun t â†¦ F_nat 0 0 t - 1) =O[atTop] fun t â†¦ rexp (-Ï€ * t) / (1 - rexp (-Ï€ * t)) := by
      apply Eventually.isBigO
      filter_upwards [eventually_gt_atTop 0] with t ht
      exact F_nat_zero_zero_sub_le ht
    refine âŸ¨_, pi_pos, this.trans ?_âŸ©
    simpa using (isBigO_refl (fun t â†¦ rexp (-Ï€ * t)) _).mul isBigO_one_aux
  Â· simp_rw [sub_zero]
    have : (fun t â†¦ F_nat 0 a t) =O[atTop] fun t â†¦ rexp (-Ï€ * a ^ 2 * t) / (1 - rexp (-Ï€ * t)) := by
      apply Eventually.isBigO
      filter_upwards [eventually_gt_atTop 0] with t ht
      exact F_nat_zero_le ha ht
    refine âŸ¨Ï€ * a ^ 2, mul_pos pi_pos (sq_pos_of_ne_zero _ h), this.trans ?_âŸ©
    simpa only [neg_mul Ï€ (a ^ 2), mul_one] using (isBigO_refl _ _).mul isBigO_one_aux","error:  function expected at
  sq_pos_of_ne_zero ?m.138857
term has type
  0 < ?m.138856 ^ 2","lemma isBigO_atTop_F_nat_zero_sub {a : â„} (ha : 0 â‰¤ a) : âˆƒ p, 0 < p âˆ§
    (fun t â†¦ F_nat 0 a t - (if a = 0 then 1 else 0)) =O[atTop] fun t â†¦ exp (-p * t) ",":= by
  split_ifs with h
  Â· rw [h]
    have : (fun t â†¦ F_nat 0 0 t - 1) =O[atTop] fun t â†¦ rexp (-Ï€ * t) / (1 - rexp (-Ï€ * t)) := by
      apply Eventually.isBigO
      filter_upwards [eventually_gt_atTop 0] with t ht
      exact F_nat_zero_zero_sub_le ht
    refine âŸ¨_, pi_pos, this.trans ?_âŸ©
    simpa using (isBigO_refl (fun t â†¦ rexp (-Ï€ * t)) _).mul isBigO_one_aux
  Â· simp_rw [sub_zero]
    have : (fun t â†¦ F_nat 0 a t) =O[atTop] fun t â†¦ rexp (-Ï€ * a ^ 2 * t) / (1 - rexp (-Ï€ * t)) := by
      apply Eventually.isBigO
      filter_upwards [eventually_gt_atTop 0] with t ht
      exact F_nat_zero_le ha ht
    refine âŸ¨Ï€ * a ^ 2, mul_pos pi_pos (sq_pos_of_ne_zero h), this.trans ?_âŸ©
    simpa only [neg_mul Ï€ (a ^ 2), mul_one] using (isBigO_refl _ _).mul isBigO_one_aux",split_ifs with h
Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean,Real.Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma,Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma,3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  let f : â„ â†’ â„ â†’ â„ â†’ â„ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : âˆ€ c u x : â„, x âˆˆ Ioi (0 : â„) â†’ 0 â‰¤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : âˆ€ c u : â„, âˆ€áµ x : â„ âˆ‚volume.restrict (Ioi 0), 0 â‰¤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    âˆ€ {c x : â„} (_ : 0 < c) (u : â„) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only [f]
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), â† exp_mul, â† rpow_mul hx.le]
    congr 2 <;> Â· field_simp [hc.ne']; ring
  have f_mem_Lp :
    âˆ€ {c u : â„} (hc : 0 < c) (hu : 0 < u),
      Memâ„’p (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) â‰  0 := by
      rwa [Ne, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) â‰  âˆ := ENNReal.ofReal_ne_top
    rw [â† memâ„’p_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memâ„’p_one_iff_integrable]
    Â· apply Integrable.congr (GammaIntegral_convergent hu)
      refine' eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => _
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    Â· refine' ContinuousOn.aestronglyMeasurable _ measurableSet_Ioi
      refine (Continuous.continuousOn ?_).mul (ContinuousAt.continuousOn fun x hx => ?_)
      Â· exact continuous_exp.comp (continuous_const.mul continuous_id')
      Â· exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  Â· refine' setIntegral_congr measurableSet_Ioi fun x hx => _
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [â† exp_add, â† add_mul, â† neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [â† rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  Â· rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact setIntegral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx",error:  no goals to be solved,"theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : â„} (hs : 0 < s) (ht : 0 < t)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    Gamma (a * s + b * t) â‰¤ Gamma s ^ a * Gamma t ^ b ",":= by
  let f : â„ â†’ â„ â†’ â„ â†’ â„ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : âˆ€ c u x : â„, x âˆˆ Ioi (0 : â„) â†’ 0 â‰¤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : âˆ€ c u : â„, âˆ€áµ x : â„ âˆ‚volume.restrict (Ioi 0), 0 â‰¤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    âˆ€ {c x : â„} (_ : 0 < c) (u : â„) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only [f]
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), â† exp_mul, â† rpow_mul hx.le]
    congr 2 <;> field_simp [hc.ne']; ring
  have f_mem_Lp :
    âˆ€ {c u : â„} (hc : 0 < c) (hu : 0 < u),
      Memâ„’p (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) â‰  0 := by
      rwa [Ne, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) â‰  âˆ := ENNReal.ofReal_ne_top
    rw [â† memâ„’p_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memâ„’p_one_iff_integrable]
    Â· apply Integrable.congr (GammaIntegral_convergent hu)
      refine eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => ?_
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    Â· refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
      refine (Continuous.continuousOn ?_).mul (ContinuousAt.continuousOn fun x hx => ?_)
      Â· exact continuous_exp.comp (continuous_const.mul continuous_id')
      Â· exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  Â· refine setIntegral_congr measurableSet_Ioi fun x hx => ?_
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [â† exp_add, â† add_mul, â† neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [â† rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  Â· rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact setIntegral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx","rw [Gamma_mul_add_mul_le_rpow_Gamma_mul_add_mul_le_rpow_Gamma_mul_add_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma
  s t a b hs ht hs ht ht hab, Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma
  s t a b ht ha hb hab, Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow]"
Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean,CategoryTheory.InjectiveResolution.ofCocomplex_exactAt_succ,ofCocomplex_exactAt_succ,b80a452d9c16e7a603a862a57bc182178c081175,":= by
  rw [HomologicalComplex.exactAt_iff' _ n (n + 1) (n + 1 + 1) (by simp) (by simp)]
  cases n
  all_goals
    dsimp [ofCocomplex, HomologicalComplex.sc', HomologicalComplex.shortComplexFunctor',
      CochainComplex.mk', CochainComplex.mk]
    simp
    apply exact_f_d","error:  simp made no progress
error:  unsolved goals
case zero
C : Type u
instâœÂ² : Category.{v, u} C
instâœÂ¹ : Abelian C
instâœ : EnoughInjectives C
Z : C
âŠ¢ (HomologicalComplex.sc' (ofCocomplex Z) 0 (0 + 1) (0 + 1 + 1)).Exact","lemma ofCocomplex_exactAt_succ (n : â„•) :
    (ofCocomplex Z).ExactAt (n + 1) ",":= by
  rw [HomologicalComplex.exactAt_iff' _ n (n + 1) (n + 1 + 1) (by simp) (by simp)]
  dsimp [ofCocomplex, CochainComplex.mk', CochainComplex.mk, HomologicalComplex.sc',
      HomologicalComplex.shortComplexFunctor']
  simp only [CochainComplex.of_d]
  match n with
  | 0 => apply exact_f_d ((CochainComplex.mkAux _ _ _
      (d (Injective.Î¹ Z)) (d (d (Injective.Î¹ Z))) _ _ 0).f)
  | n+1 => apply exact_f_d ((CochainComplex.mkAux _ _ _
      (d (Injective.Î¹ Z)) (d (d (Injective.Î¹ Z))) _ _ (n+1)).f)",rw [exactAt_succ_iff]
Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean,IsIntegralClosure.isDedekindDomain,IsIntegralClosure.isDedekindDomain,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  have : IsFractionRing C L := IsIntegralClosure.isFractionRing_of_finite_extension A K L C
  { IsIntegralClosure.isNoetherianRing A K L C,
    Ring.DimensionLEOne.isIntegralClosure A L C,
    (isIntegrallyClosed_iff L).mpr fun {x} hx =>
      âŸ¨IsIntegralClosure.mk' C x (isIntegral_trans (IsIntegralClosure.isIntegral_algebra A L) _ hx),
        IsIntegralClosure.algebraMap_mk' _ _ _âŸ© with : IsDedekindDomain C }","error:  function expected at
  isIntegral_trans ?m.154266 ?m.154267
term has type
  IsIntegral ?m.153783 ?m.154266
error:  application type mismatch
  isIntegral_trans (isIntegral_algebra A L)
argument
  isIntegral_algebra A L
has type
  Algebra.IsIntegral A ?m.153797 : Prop
but is expected to have type
  ?m.153785 : Type ?u.153780
error:  function expected at
  IsIntegralClosure.isDedekindDomain A K
term has type
  IsDedekindDomain K
error:  function expected at
  isDedekindDomain A (FractionRing A)
term has type
  IsDedekindDomain â†¥(integralClosure A (FractionRing A))",theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C ,":=
  have : IsFractionRing C L := IsIntegralClosure.isFractionRing_of_finite_extension A K L C
  have : Algebra.IsIntegral A C := IsIntegralClosure.isIntegral_algebra A L
  { IsIntegralClosure.isNoetherianRing A K L C,
    Ring.DimensionLEOne.isIntegralClosure A L C,
    (isIntegrallyClosed_iff L).mpr fun {x} hx =>
      âŸ¨IsIntegralClosure.mk' C x (isIntegral_trans (R := A) _ hx),
        IsIntegralClosure.algebraMap_mk' _ _ _âŸ© with : IsDedekindDomain C }",apply IsDedekindDomain.IsDedekindDomain.IsDedekindDomain
Mathlib/Analysis/InnerProductSpace/Projection.lean,OrthogonalFamily.projection_directSum_coeAddHom,OrthogonalFamily.projection_directSum_coeAddHom,9e34a191034458a56331f976ff7400a26407c888,":= by
  induction' x using DirectSum.induction_on with j x x y hx hy
  Â· simp
  Â· simp_rw [DirectSum.coeAddMonoidHom_of, DirectSum.of]
    rw [DFinsupp.singleAddHom_apply]
    obtain rfl | hij := Decidable.eq_or_ne i j
    Â· rw [orthogonalProjection_mem_subspace_eq_self, DFinsupp.single_eq_same]
    Â· rw [orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero,
        DFinsupp.single_eq_of_ne hij.symm]
      exact hV.isOrtho hij.symm x.prop
  Â· simp_rw [map_add, DFinsupp.add_apply]
    exact congr_argâ‚‚ (Â· + Â·) hx hy","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (DFinsupp.singleAddHom ?Î² ?i) ?b
case H_basic
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâ¶ : _root_.RCLike ğ•œ
instâœâµ : NormedAddCommGroup E
instâœâ´ : NormedAddCommGroup F
instâœÂ³ : InnerProductSpace ğ•œ E
instâœÂ² : InnerProductSpace â„ F
K : Submodule ğ•œ E
Î¹ : Type u_4
instâœÂ¹ : DecidableEq Î¹
V : Î¹ â†’ Submodule ğ•œ E
hV : OrthogonalFamily ğ•œ (fun i â†¦ â†¥(V i)) fun i â†¦ (V i).subtypeâ‚—áµ¢
i : Î¹
instâœ : CompleteSpace â†¥(V i)
j : Î¹
x : â†¥(V j)
âŠ¢ (orthogonalProjection (V i)) â†‘x = ((DFinsupp.singleAddHom (fun i â†¦ â†¥(V i)) j) x) i
error:  simp made no progress","theorem OrthogonalFamily.projection_directSum_coeAddHom [DecidableEq Î¹] {V : Î¹ â†’ Submodule ğ•œ E}
    (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) (x : â¨ i, V i) (i : Î¹)
    [CompleteSpace (V i)] :
    orthogonalProjection (V i) (DirectSum.coeAddMonoidHom V x) = x i ",":= by
  induction' x using DirectSum.induction_on with j x x y hx hy
  Â· simp
  Â· simp_rw [DirectSum.coeAddMonoidHom_of, DirectSum.of]
    erw [DFinsupp.singleAddHom_apply]
    obtain rfl | hij := Decidable.eq_or_ne i j
    Â· rw [orthogonalProjection_mem_subspace_eq_self, DFinsupp.single_eq_same]
    Â· rw [orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero,
        DFinsupp.single_eq_of_ne hij.symm]
      exact hV.isOrtho hij.symm x.prop
  Â· simp_rw [map_add]
    exact congr_argâ‚‚ (Â· + Â·) hx hy",simp only [orthogonalProjection]
Mathlib/Dynamics/Ergodic/Conservative.lean,MeasureTheory.Conservative.frequently_measure_inter_ne_zero,frequently_measure_inter_ne_zero,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  by_contra H
  simp only [not_frequently, eventually_atTop, Ne.def, Classical.not_not] at H
  rcases H with âŸ¨N, hNâŸ©
  induction' N with N ihN
  Â· apply h0
    simpa using hN 0 le_rfl
  rw [imp_false] at ihN
  push_neg at ihN
  rcases ihN with âŸ¨n, hn, hÎ¼nâŸ©
  set T := s âˆ© â‹ƒ n â‰¥ N + 1, f^[n] â»Â¹' s
  have hT : MeasurableSet T :=
    hs.inter (MeasurableSet.biUnion (to_countable _) fun _ _ => hf.measurable.iterate _ hs)
  have hÎ¼T : Î¼ T = 0 := by
    convert(measure_biUnion_null_iff <| to_countable _).2 hN
    rw [â† inter_iUnionâ‚‚]
    rfl
  have : Î¼ ((s âˆ© f^[n] â»Â¹' s) \ T) â‰  0 := by rwa [measure_diff_null hÎ¼T]
  rcases hf.exists_mem_image_mem ((hs.inter (hf.measurable.iterate n hs)).diff hT) this with
    âŸ¨x, âŸ¨âŸ¨hxs, _âŸ©, hxTâŸ©, m, hm0, âŸ¨_, hxmâŸ©, _âŸ©
  refine' hxT âŸ¨hxs, mem_iUnionâ‚‚.2 âŸ¨n + m, _, _âŸ©âŸ©
  Â· exact add_le_add hn (Nat.one_le_of_lt <| pos_iff_ne_zero.2 hm0)
  Â· rwa [Set.mem_preimage, â† iterate_add_apply] at hxm","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.2158 â†’ ?m.2158 â†’ Prop
error:  invalid field 'exists_mem_image_mem', the environment does not contain 'MeasureTheory.Conservative.exists_mem_image_mem'
  hf
has type
  Conservative f Î¼
error:  rcases tactic failed: xâœ : ?m.7676 is not an inductive datatype","theorem frequently_measure_inter_ne_zero (hf : Conservative f Î¼) (hs : MeasurableSet s)
    (h0 : Î¼ s â‰  0) : âˆƒá¶  m in atTop, Î¼ (s âˆ© f^[m] â»Â¹' s) â‰  0 ",":= by
  by_contra H
  simp only [not_frequently, eventually_atTop, Ne, Classical.not_not] at H
  rcases H with âŸ¨N, hNâŸ©
  induction' N with N ihN
  Â· apply h0
    simpa using hN 0 le_rfl
  rw [imp_false] at ihN
  push_neg at ihN
  rcases ihN with âŸ¨n, hn, hÎ¼nâŸ©
  set T := s âˆ© â‹ƒ n â‰¥ N + 1, f^[n] â»Â¹' s
  have hT : MeasurableSet T :=
    hs.inter (MeasurableSet.biUnion (to_countable _) fun _ _ => hf.measurable.iterate _ hs)
  have hÎ¼T : Î¼ T = 0 := by
    convert (measure_biUnion_null_iff <| to_countable _).2 hN
    rw [â† inter_iUnionâ‚‚]
    rfl
  have : Î¼ ((s âˆ© f^[n] â»Â¹' s) \ T) â‰  0 := by rwa [measure_diff_null hÎ¼T]
  rcases hf.exists_mem_iterate_mem ((hs.inter (hf.measurable.iterate n hs)).diff hT) this with
    âŸ¨x, âŸ¨âŸ¨hxs, _âŸ©, hxTâŸ©, m, hm0, âŸ¨_, hxmâŸ©, _âŸ©
  refine hxT âŸ¨hxs, mem_iUnionâ‚‚.2 âŸ¨n + m, ?_, ?_âŸ©âŸ©
  Â· exact add_le_add hn (Nat.one_le_of_lt <| pos_iff_ne_zero.2 hm0)
  Â· rwa [Set.mem_preimage, â† iterate_add_apply] at hxm",rw [frequently_measure_inter_ne_zero]
Mathlib/Analysis/Convex/Segment.lean,mem_segment_add_sub,mem_segment_add_sub,03690a4c3252f422184189d0b6a6dd8d1c55d551,":= by
  convert @midpoint_mem_segment ğ•œ _ _ _ _ _ _ (x + y) (x - y)
  rw [midpoint_add_sub]","warning:  segment does not have a doc string
error:  function expected at
  midpoint_mem_segment ?m.222421 (x + y)
term has type
  midpoint ğ•œ ?m.222421 (x + y) âˆˆ [?m.222421-[ğ•œ]x + y]
error:  no goals to be solved",theorem mem_segment_add_sub [Invertible (2 : ğ•œ)] (x y : E) : x âˆˆ [x + y -[ğ•œ] x - y] ,":= by
  convert @midpoint_mem_segment ğ•œ _ _ _ _ _ (x + y) (x - y)
  rw [midpoint_add_sub]",rw [mem_segment_add_sub]
Mathlib/RingTheory/PowerSeries/Derivative.lean,PowerSeries.derivativeFun_mul,derivativeFun_mul,a3708498bec5c2641fd86b158487e675e90d687a,":= by
  ext n
  have hâ‚ : n < n + 1 := lt_succ_self n
  have hâ‚‚ : n < n + 1 + 1 := Nat.lt_add_right _ _ _ hâ‚
  rw [coeff_derivativeFun, map_add, coeff_mul_eq_coeff_trunc_mul_trunc _ _ (lt_succ_self _),
    smul_eq_mul, smul_eq_mul, coeff_mul_eq_coeff_trunc_mul_truncâ‚‚ g f.derivativeFun hâ‚‚ hâ‚,
    coeff_mul_eq_coeff_trunc_mul_truncâ‚‚ f g.derivativeFun hâ‚‚ hâ‚, trunc_derivativeFun,
    trunc_derivativeFun, â† map_add, â† derivativeFun_coe_mul_coe, coeff_derivativeFun]","error:  function expected at
  Nat.lt_add_right ?m.22097 ?m.22098
term has type
  ?m.22095 < ?m.22096 + ?m.22097","theorem derivativeFun_mul (f g : RâŸ¦XâŸ§) :
    derivativeFun (f * g) = f â€¢ g.derivativeFun + g â€¢ f.derivativeFun ",":= by
  ext n
  have hâ‚ : n < n + 1 := lt_succ_self n
  have hâ‚‚ : n < n + 1 + 1 := Nat.lt_add_right _ hâ‚
  rw [coeff_derivativeFun, map_add, coeff_mul_eq_coeff_trunc_mul_trunc _ _ (lt_succ_self _),
    smul_eq_mul, smul_eq_mul, coeff_mul_eq_coeff_trunc_mul_truncâ‚‚ g f.derivativeFun hâ‚‚ hâ‚,
    coeff_mul_eq_coeff_trunc_mul_truncâ‚‚ f g.derivativeFun hâ‚‚ hâ‚, trunc_derivativeFun,
    trunc_derivativeFun, â† map_add, â† derivativeFun_coe_mul_coe, coeff_derivativeFun]","simp_rw [derivativeFun_mul, derivativeFun_mul, derivativeFun_mul]"
Mathlib/CategoryTheory/MorphismProperty/Basic.lean,CategoryTheory.MorphismProperty.map_id_eq_isoClosure,map_id_eq_isoClosure,6830b5e612c6f4431fee7e89ec01560ae5118e5e,":= by
  apply subset_antisymm
  Â· rw [map_subset_iff _ _ _ P.isoClosure_respectsIso]
    intro X Y f hf
    exact P.subset_isoClosure _ hf
  Â· intro X Y f hf
    exact hf","error:  failed to synthesize
  HasSubset (MorphismProperty C)
use `set_option diagnostics true` to get diagnostic information","lemma map_id_eq_isoClosure (P : MorphismProperty C) :
    P.map (ğŸ­ _) = P.isoClosure ",":= by
  apply le_antisymm
  Â· rw [map_le_iff P.isoClosure_respectsIso]
    intro X Y f hf
    exact P.le_isoClosure _ hf
  Â· intro X Y f hf
    exact hf","simp only [isoClosure, map_id_eq_isoClosure]"
Mathlib/Analysis/MeanInequalities.lean,Real.Lp_add_le_hasSum_of_nonneg,Lp_add_le_hasSum_of_nonneg,aaa40f08731a6680bdee636aa290c8d59c9968c4,":= by
  lift f to Î¹ â†’ â„â‰¥0 using hf
  lift g to Î¹ â†’ â„â‰¥0 using hg
  lift A to â„â‰¥0 using hA
  lift B to â„â‰¥0 using hB
  beta_reduce at hfA hgB
  norm_cast at hfA hgB
  obtain âŸ¨C, hCâ‚, hCâ‚‚âŸ© := NNReal.Lp_add_le_hasSum hp hfA hgB
  use C","error:  unsolved goals
case h
Î¹ : Type u
s : Finset Î¹
p q : â„
hp : 1 â‰¤ p
f g : Î¹ â†’ â„â‰¥0
A B : â„â‰¥0
hfA : HasSum (fun a â†¦ f a ^ p) (A ^ p)
hgB : HasSum (fun a â†¦ g a ^ p) (B ^ p)
C : â„â‰¥0
hCâ‚ : C â‰¤ A + B
hCâ‚‚ : HasSum (fun i â†¦ (f i + g i) ^ p) (C ^ p)
âŠ¢ 0 â‰¤ â†‘C âˆ§ â†‘C â‰¤ â†‘A + â†‘B âˆ§ HasSum (fun i â†¦ ((fun i â†¦ â†‘(f i)) i + (fun i â†¦ â†‘(g i)) i) ^ p) (â†‘C ^ p)","theorem Lp_add_le_hasSum_of_nonneg (hp : 1 â‰¤ p) (hf : âˆ€ i, 0 â‰¤ f i) (hg : âˆ€ i, 0 â‰¤ g i) {A B : â„}
    (hA : 0 â‰¤ A) (hB : 0 â‰¤ B) (hfA : HasSum (fun i => f i ^ p) (A ^ p))
    (hgB : HasSum (fun i => g i ^ p) (B ^ p)) :
    âˆƒ C, 0 â‰¤ C âˆ§ C â‰¤ A + B âˆ§ HasSum (fun i => (f i + g i) ^ p) (C ^ p) ",":= by
  lift f to Î¹ â†’ â„â‰¥0 using hf
  lift g to Î¹ â†’ â„â‰¥0 using hg
  lift A to â„â‰¥0 using hA
  lift B to â„â‰¥0 using hB
  beta_reduce at hfA hgB
  norm_cast at hfA hgB
  obtain âŸ¨C, hCâ‚, hCâ‚‚âŸ© := NNReal.Lp_add_le_hasSum hp hfA hgB
  use C
  beta_reduce
  norm_cast
  exact âŸ¨zero_le _, hCâ‚, hCâ‚‚âŸ©",refine theorem_lp_add_le_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSum_of_hasSu
Mathlib/Order/Interval/Finset/Nat.lean,Nat.image_sub_const_Ico,image_sub_const_Ico,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  ext x
  rw [mem_image]
  constructor
  Â· rintro âŸ¨x, hx, rflâŸ©
    rw [mem_Ico] at hx âŠ¢
    exact âŸ¨tsub_le_tsub_right hx.1 _, tsub_lt_tsub_right_of_le (h.trans hx.1) hx.2âŸ©
  Â· rintro h
    refine âŸ¨x + c, ?_, add_tsub_cancel_right _ _âŸ©
    rw [mem_Ico] at h âŠ¢
    exact âŸ¨tsub_le_iff_right.1 h.1, lt_tsub_iff_right.1 h.2âŸ©","error:  failed to synthesize
  OrderedSub â„•
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  ExistsAddOfLE â„•
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  OrderedSub â„•
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  OrderedSub â„•
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  OrderedSub â„•
use `set_option diagnostics true` to get diagnostic information","theorem image_sub_const_Ico (h : c â‰¤ a) :
    ((Ico a b).image fun x => x - c) = Ico (a - c) (b - c) ",":= by
  ext x
  simp_rw [mem_image, mem_Ico]
  refine âŸ¨?_, fun h â†¦ âŸ¨x + c, by omegaâŸ©âŸ©
  rintro âŸ¨x, hx, rflâŸ©
  omega",rw [Ico.image_eq_of_injective image_sub_const_Ico]
Mathlib/Combinatorics/SetFamily/LYM.lean,Finset.card_div_choose_le_card_shadow_div_choose,card_div_choose_le_card_shadow_div_choose,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain hr' | hr' := lt_or_le (Fintype.card Î±) r
  Â· rw [choose_eq_zero_of_lt hr', cast_zero, div_zero]
    exact div_nonneg (cast_nonneg _) (cast_nonneg _)
  replace hğ’œ := card_mul_le_card_shadow_mul hğ’œ
  rw [div_le_div_iff] <;> norm_cast
  Â· cases' r with r
    Â· exact (hr rfl).elim
    rw [Nat.succ_eq_add_one] at *
    rw [tsub_add_eq_add_tsub hr', add_tsub_add_eq_tsub_right] at hğ’œ
    apply le_of_mul_le_mul_right _ (pos_iff_ne_zero.2 hr)
    convert Nat.mul_le_mul_right ((Fintype.card Î±).choose r) hğ’œ using 1
    Â· simp [mul_assoc, Nat.choose_succ_right_eq]
      exact Or.inl (mul_comm _ _)
    Â· simp only [mul_assoc, choose_succ_right_eq, mul_eq_mul_left_iff]
      exact Or.inl (mul_comm _ _)
  Â· exact Nat.choose_pos hr'
  Â· exact Nat.choose_pos (r.pred_le.trans hr')","error:  tactic 'rewrite' failed, did not find instance of the pattern in the current goal
case inr.succ
ğ•œ : Type u_1
Î± : Type u_2
instâœÂ² : LinearOrderedField ğ•œ
instâœÂ¹ : DecidableEq Î±
instâœ : Fintype Î±
ğ’œ : Finset (Finset Î±)
r : â„•
hr : r + 1 â‰  0
hr' : r + 1 â‰¤ Fintype.card Î±
hğ’œ : ğ’œ.card * (r + 1) â‰¤ (âˆ‚ ğ’œ).card * (Fintype.card Î± - (r + 1) + 1)
âŠ¢ ğ’œ.card * (Fintype.card Î±).choose (r + 1 - 1) â‰¤ (âˆ‚ ğ’œ).card * (Fintype.card Î±).choose (r + 1)","theorem card_div_choose_le_card_shadow_div_choose (hr : r â‰  0)
    (hğ’œ : (ğ’œ : Set (Finset Î±)).Sized r) : (ğ’œ.card : ğ•œ) / (Fintype.card Î±).choose r
    â‰¤ (âˆ‚ ğ’œ).card / (Fintype.card Î±).choose (r - 1) ",":= by
  obtain hr' | hr' := lt_or_le (Fintype.card Î±) r
  Â· rw [choose_eq_zero_of_lt hr', cast_zero, div_zero]
    exact div_nonneg (cast_nonneg _) (cast_nonneg _)
  replace hğ’œ := card_mul_le_card_shadow_mul hğ’œ
  rw [div_le_div_iff] <;> norm_cast
  Â· cases' r with r
    Â· exact (hr rfl).elim
    rw [tsub_add_eq_add_tsub hr', add_tsub_add_eq_tsub_right] at hğ’œ
    apply le_of_mul_le_mul_right _ (pos_iff_ne_zero.2 hr)
    convert Nat.mul_le_mul_right ((Fintype.card Î±).choose r) hğ’œ using 1
    Â· simp [mul_assoc, Nat.choose_succ_right_eq]
      exact Or.inl (mul_comm _ _)
    Â· simp only [mul_assoc, choose_succ_right_eq, mul_eq_mul_left_iff]
      exact Or.inl (mul_comm _ _)
  Â· exact Nat.choose_pos hr'
  Â· exact Nat.choose_pos (r.pred_le.trans hr')",refine le_trans ?_ (choose_le_choose_le_choose_le_choose hr hğ’œ hğ’œ hr)
Mathlib/RingTheory/Polynomial/Nilpotent.lean,Polynomial.isUnit_of_coeff_isUnit_isNilpotent,isUnit_of_coeff_isUnit_isNilpotent,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  induction' h : P.natDegree using Nat.strong_induction_on with k hind generalizing P
  by_cases hdeg : P.natDegree = 0
  { rw [eq_C_of_natDegree_eq_zero hdeg]
    exact hunit.map C }
  set Pâ‚ := P.eraseLead with hPâ‚
  suffices IsUnit Pâ‚ by
    rw [â† eraseLead_add_monomial_natDegree_leadingCoeff P, â† C_mul_X_pow_eq_monomial]
    obtain âŸ¨Q, hQâŸ© := this
    rw [â† hPâ‚, â† hQ]
    refine' Commute.IsNilpotent.add_isUnit (isNilpotent_C_mul_pow_X_of_isNilpotent _ (hnil _ hdeg))
      ((Commute.all _ _).mul_left (Commute.all _ _))
  have hdegâ‚‚ := lt_of_le_of_lt P.eraseLead_natDegree_le (Nat.sub_lt
    (Nat.pos_of_ne_zero hdeg) zero_lt_one)
  refine' hind Pâ‚.natDegree _ _ (fun i hi => _) rfl
  Â· simp_rw [â† h, hdegâ‚‚]
  Â· simp_rw [eraseLead_coeff_of_ne _ (Ne.symm hdeg), hunit]
  Â· by_cases H : i â‰¤ Pâ‚.natDegree
    simp_rw [eraseLead_coeff_of_ne _ (ne_of_lt (lt_of_le_of_lt H hdegâ‚‚)), hnil i hi]
    simp_rw [coeff_eq_zero_of_natDegree_lt (lt_of_not_ge H), IsNilpotent.zero]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Commute
has type
  ?m.43997 â†’ ?m.43997 â†’ Prop","theorem isUnit_of_coeff_isUnit_isNilpotent (hunit : IsUnit (P.coeff 0))
    (hnil : âˆ€ i, i â‰  0 â†’ IsNilpotent (P.coeff i)) : IsUnit P ",":= by
  induction' h : P.natDegree using Nat.strong_induction_on with k hind generalizing P
  by_cases hdeg : P.natDegree = 0
  { rw [eq_C_of_natDegree_eq_zero hdeg]
    exact hunit.map C }
  set Pâ‚ := P.eraseLead with hPâ‚
  suffices IsUnit Pâ‚ by
    rw [â† eraseLead_add_monomial_natDegree_leadingCoeff P, â† C_mul_X_pow_eq_monomial, â† hPâ‚]
    refine IsNilpotent.isUnit_add_left_of_commute ?_ this (Commute.all _ _)
    exact isNilpotent_C_mul_pow_X_of_isNilpotent _ (hnil _ hdeg)
  have hdegâ‚‚ := lt_of_le_of_lt P.eraseLead_natDegree_le (Nat.sub_lt
    (Nat.pos_of_ne_zero hdeg) zero_lt_one)
  refine hind Pâ‚.natDegree ?_ ?_ (fun i hi => ?_) rfl
  Â· simp_rw [â† h, hdegâ‚‚]
  Â· simp_rw [eraseLead_coeff_of_ne _ (Ne.symm hdeg), hunit]
  Â· by_cases H : i â‰¤ Pâ‚.natDegree
    Â· simp_rw [eraseLead_coeff_of_ne _ (ne_of_lt (lt_of_le_of_lt H hdegâ‚‚)), hnil i hi]
    Â· simp_rw [coeff_eq_zero_of_natDegree_lt (lt_of_not_ge H), IsNilpotent.zero]",rw [isUnit_of_coeff_isUnit_isNilpotent_isNilpotent_isUnit_isNilpotent]
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicAt.order_eq_int_iff,order_eq_int_iff,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  unfold order
  by_cases h : hf.choose_spec.order = âŠ¤
  Â· rw [h, WithTop.map_top, â† WithTop.coe_nat, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun âŸ¨g, hg_an, hg_ne, hg_eqâŸ© â†¦ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, â† AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq âŠ¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, â† mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  Â· obtain âŸ¨m, hâŸ© := WithTop.ne_top_iff_exists.mp h
    rw [â† h, WithTop.map_coe, â† WithTop.coe_nat, â† WithTop.coe_sub, WithTop.coe_inj]
    obtain âŸ¨g, hg_an, hg_ne, hg_eqâŸ© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : âˆ€á¶  (z : ğ•œ) in ğ“[â‰ ] x, f z = (z - x) ^ (â†‘m - â†‘hf.choose : â„¤) â€¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [â† smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), â† mul_smul,
      â† zpow_addâ‚€ (sub_ne_zero.mpr hz), â† add_sub_assoc, add_sub_cancel', zpow_ofNat, zpow_ofNat]
    exact âŸ¨fun h â†¦ âŸ¨g, hg_an, hg_ne, h â–¸ hg_eqâŸ©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero âŸ¨g, hg_an, hg_ne, hg_eqâŸ©âŸ©","warning:  `WithTop.coe_nat` has been deprecated, use `WithTop.coe_natCast` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  âŠ¤ - â†‘?m.79514
case pos
ğ•œ : Type u_1
instâœÂ² : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace ğ•œ E
f : ğ•œ â†’ E
x : ğ•œ
hf : MeromorphicAt f x
n : â„¤
h : â‹¯.order = âŠ¤
âŠ¢ âŠ¤ - â†‘â†‘(Exists.choose hf) = â†‘n â†” âˆƒ g, AnalyticAt ğ•œ g x âˆ§ g x â‰  0 âˆ§ âˆ€á¶  (z : ğ•œ) in ğ“[â‰ ] x, f z = (z - x) ^ n â€¢ g z
warning:  `WithTop.coe_nat` has been deprecated, use `WithTop.coe_natCast` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â†‘?m.80098 - â†‘?m.80099
case neg.intro
ğ•œ : Type u_1
instâœÂ² : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace ğ•œ E
f : ğ•œ â†’ E
x : ğ•œ
hf : MeromorphicAt f x
n : â„¤
hâœ : Â¬â‹¯.order = âŠ¤
m : â„•
h : â†‘m = â‹¯.order
âŠ¢ â†‘â†‘m - â†‘â†‘(Exists.choose hf) = â†‘n â†” âˆƒ g, AnalyticAt ğ•œ g x âˆ§ g x â‰  0 âˆ§ âˆ€á¶  (z : ğ•œ) in ğ“[â‰ ] x, f z = (z - x) ^ n â€¢ g z","lemma order_eq_int_iff {f : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) (n : â„¤) : hf.order = n â†”
    âˆƒ g : ğ•œ â†’ E, AnalyticAt ğ•œ g x âˆ§ g x â‰  0 âˆ§ âˆ€á¶  z in ğ“[â‰ ] x, f z = (z - x) ^ n â€¢ g z ",":= by
  unfold order
  by_cases h : hf.choose_spec.order = âŠ¤
  Â· rw [h, WithTop.map_top, â† WithTop.coe_natCast, top_sub,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun âŸ¨g, hg_an, hg_ne, hg_eqâŸ© â†¦ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, â† AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq âŠ¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, â† mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  Â· obtain âŸ¨m, hâŸ© := WithTop.ne_top_iff_exists.mp h
    rw [â† h, WithTop.map_coe, â† WithTop.coe_natCast, â† coe_sub, WithTop.coe_inj]
    obtain âŸ¨g, hg_an, hg_ne, hg_eqâŸ© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : âˆ€á¶  (z : ğ•œ) in ğ“[â‰ ] x, f z = (z - x) ^ (â†‘m - â†‘hf.choose : â„¤) â€¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [â† smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), â† mul_smul,
        â† zpow_addâ‚€ (sub_ne_zero.mpr hz), â† add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact âŸ¨fun h â†¦ âŸ¨g, hg_an, hg_ne, h â–¸ hg_eqâŸ©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero âŸ¨g, hg_an, hg_ne, hg_eqâŸ©âŸ©",constructor
Mathlib/NumberTheory/Bernoulli.lean,bernoulli'_odd_eq_zero,bernoulli'_odd_eq_zero,1737baecc8d3128fff663633128256ff0699ff55,":= by
  let B := mk fun n => bernoulli' n / (n ! : â„š)
  suffices (B - evalNegHom B) * (exp â„š - 1) = X * (exp â„š - 1) by
    cases' mul_eq_mul_right_iff.mp this with h h <;>
      simp only [PowerSeries.ext_iff, evalNegHom, coeff_X] at h
    Â· apply eq_zero_of_neg_eq
      specialize h n
      split_ifs at h <;> simp_all [h_odd.neg_one_pow, factorial_ne_zero]
    Â· simpa [Nat.factorial] using h 1
  have h : B * (exp â„š - 1) = X * exp â„š := by
    simpa [bernoulli'PowerSeries] using bernoulli'PowerSeries_mul_exp_sub_one â„š
  rw [sub_mul, h, mul_sub X, sub_right_inj, â† neg_sub, mul_neg, neg_eq_iff_eq_neg]
  suffices evalNegHom (B * (exp â„š - 1)) * exp â„š = evalNegHom (X * exp â„š) * exp â„š by
    rw [map_mul, map_mul] at this 
    simpa [(map_one), mul_assoc, sub_mul, mul_comm (evalNegHom (exp â„š)), exp_mul_exp_neg_eq_one]
  congr","error:  unsolved goals
case neg
A : Type u_1
instâœÂ¹ : CommRing A
instâœ : Algebra â„š A
n : â„•
B : â„šâŸ¦XâŸ§ := PowerSeries.mk fun n â†¦ bernoulli' n / â†‘n !
h_odd : Â¬Even n
hlt : 1 < n
this : B - evalNegHom B = X âˆ¨ exp â„š - 1 = 0
hâœ : Â¬n = 1
h : (coeff â„š n) B = 0
âŠ¢ bernoulli' n = 0",theorem bernoulli'_odd_eq_zero {n : â„•} (h_odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0 ,":= by
  let B := mk fun n => bernoulli' n / (n ! : â„š)
  suffices (B - evalNegHom B) * (exp â„š - 1) = X * (exp â„š - 1) by
    cases' mul_eq_mul_right_iff.mp this with h h <;>
      simp only [PowerSeries.ext_iff, evalNegHom, coeff_X] at h
    Â· apply eq_zero_of_neg_eq
      specialize h n
      split_ifs at h <;> simp_all [B, h_odd.neg_one_pow, factorial_ne_zero]
    Â· simpa (config := {decide := true}) [Nat.factorial] using h 1
  have h : B * (exp â„š - 1) = X * exp â„š := by
    simpa [bernoulli'PowerSeries] using bernoulli'PowerSeries_mul_exp_sub_one â„š
  rw [sub_mul, h, mul_sub X, sub_right_inj, â† neg_sub, mul_neg, neg_eq_iff_eq_neg]
  suffices evalNegHom (B * (exp â„š - 1)) * exp â„š = evalNegHom (X * exp â„š) * exp â„š by
    rw [map_mul, map_mul] at this 
    simpa [mul_assoc, sub_mul, mul_comm (evalNegHom (exp â„š)), exp_mul_exp_neg_eq_one]
  congr",rw [bernoulli'_odd_eq_zero]
Mathlib/NumberTheory/Cyclotomic/Basic.lean,IsCyclotomicExtension.iff_union_of_dvd,iff_union_of_dvd,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine'
    âŸ¨fun H => of_union_of_dvd A B h hS, fun H => (iff_adjoin_eq_top _ A _).2 âŸ¨fun s hs => _, _âŸ©âŸ©
  Â· exact H.exists_prim_root (subset_union_left _ _ hs)
  Â· rw [_root_.eq_top_iff, â† ((iff_adjoin_eq_top _ A B).1 H).2]
    refine' adjoin_mono fun x hx => _
    simp only [union_singleton, mem_insert_iff, mem_setOf_eq] at hx âŠ¢
    obtain âŸ¨m, rfl | hm, hxpowâŸ© := hx
    Â· obtain âŸ¨y, hyâŸ© := hS
      refine' âŸ¨y, âŸ¨hy, _âŸ©âŸ©
      obtain âŸ¨z, rflâŸ© := h y hy
      simp only [PNat.mul_coe, pow_mul, hxpow, one_pow]
    Â· exact âŸ¨m, âŸ¨hm, hxpowâŸ©âŸ©","error:  function expected at
  subset_union_left ?m.74271
term has type
  ?m.74270 âˆˆ ?m.74268 âˆª ?m.74269","theorem iff_union_of_dvd (h : âˆ€ s âˆˆ S, n âˆ£ s) (hS : S.Nonempty) :
    IsCyclotomicExtension S A B â†” IsCyclotomicExtension (S âˆª {n}) A B ",":= by
  refine
    âŸ¨fun H => of_union_of_dvd A B h hS, fun H => (iff_adjoin_eq_top _ A _).2 âŸ¨fun s hs => ?_, ?_âŸ©âŸ©
  Â· exact H.exists_prim_root (subset_union_left hs)
  Â· rw [_root_.eq_top_iff, â† ((iff_adjoin_eq_top _ A B).1 H).2]
    refine adjoin_mono fun x hx => ?_
    simp only [union_singleton, mem_insert_iff, mem_setOf_eq] at hx âŠ¢
    obtain âŸ¨m, rfl | hm, hxpowâŸ© := hx
    Â· obtain âŸ¨y, hyâŸ© := hS
      refine âŸ¨y, âŸ¨hy, ?_âŸ©âŸ©
      obtain âŸ¨z, rflâŸ© := h y hy
      simp only [PNat.mul_coe, pow_mul, hxpow, one_pow]
    Â· exact âŸ¨m, âŸ¨hm, hxpowâŸ©âŸ©","rw [IsCyclotomicExtension, IsCyclotomicExtension, IsCyclotomicExtension]"
Mathlib/Geometry/Manifold/IntegralCurve.lean,IsIntegralCurve.isIntegralCurveAt,IsIntegralCurve.isIntegralCurveAt,2c4d77d7fd709133772709da9ffb1d698ecbcd0a,":= âŸ¨1, zero_lt_one, fun t _ => h tâŸ©","error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  (ğ“ t).1 {x | (fun t â†¦ HasMFDerivAt ğ“˜(â„, â„) I Î³ t (ContinuousLinearMap.smulRight 1 (v (Î³ t)))) x}","lemma IsIntegralCurve.isIntegralCurveAt (h : IsIntegralCurve Î³ v) (t : â„) :
    IsIntegralCurveAt Î³ v t ",":= isIntegralCurveAt_iff.mpr âŸ¨univ, Filter.univ_mem, fun t _ â†¦ h tâŸ©",apply IsIntegralCurve.isIntegralCurveAt_isIntegralCurveAt
Mathlib/MeasureTheory/Integral/SetIntegral.lean,MeasureTheory.integral_finset_biUnion,integral_finset_biUnion,25e538f3a737a71314ac143929711e67d0b14d73,":= by
  induction' t with a t hat IH hs h's
  Â· simp
  Â· simp only [Finset.coe_insert, Finset.forall_mem_insert, Set.pairwise_insert,
      Finset.set_biUnion_insert] at hs hf h's âŠ¢
    rw [integral_union _ _ hf.1 (integrableOn_finset_iUnion.2 hf.2)]
    Â· rw [Finset.sum_insert hat, IH hs.2 h's.1 hf.2]
    Â· simp only [disjoint_iUnion_right]
      exact fun i hi => (h's.2 i hi (ne_of_mem_of_not_mem hi hat).symm).1
    Â· exact Finset.measurableSet_biUnion _ hs.2","error:  unsolved goals
case mk
X : Type u_1
Y : Type u_2
E : Type u_3
F : Type u_4
instâœÂ² : MeasurableSpace X
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace â„ E
f g : X â†’ E
sâœ tâœ : Set X
Î¼ Î½ : Measure X
l l' : Filter X
Î¹ : Type u_5
s : Î¹ â†’ Set X
a : Multiset Î¹
t : a.Nodup
hs : âˆ€ i âˆˆ { val := a, nodup := t }, MeasurableSet (s i)
h's : (â†‘{ val := a, nodup := t }).Pairwise (Disjoint on s)
hf : âˆ€ i âˆˆ { val := a, nodup := t }, IntegrableOn f (s i) Î¼
âŠ¢ âˆ« (x : X) in â‹ƒ i âˆˆ a, s i, f x âˆ‚Î¼ = (Multiset.map (fun i â†¦ âˆ« (x : X) in s i, f x âˆ‚Î¼) a).sum
error:  no goals to be solved","theorem integral_finset_biUnion {Î¹ : Type*} (t : Finset Î¹) {s : Î¹ â†’ Set X}
    (hs : âˆ€ i âˆˆ t, MeasurableSet (s i)) (h's : Set.Pairwise (â†‘t) (Disjoint on s))
    (hf : âˆ€ i âˆˆ t, IntegrableOn f (s i) Î¼) :
    âˆ« x in â‹ƒ i âˆˆ t, s i, f x âˆ‚Î¼ = âˆ‘ i âˆˆ t, âˆ« x in s i, f x âˆ‚Î¼ ",":= by
  induction' t using Finset.induction_on with a t hat IH hs h's
  Â· simp
  Â· simp only [Finset.coe_insert, Finset.forall_mem_insert, Set.pairwise_insert,
      Finset.set_biUnion_insert] at hs hf h's âŠ¢
    rw [integral_union _ _ hf.1 (integrableOn_finset_iUnion.2 hf.2)]
    Â· rw [Finset.sum_insert hat, IH hs.2 h's.1 hf.2]
    Â· simp only [disjoint_iUnion_right]
      exact fun i hi => (h's.2 i hi (ne_of_mem_of_not_mem hi hat).symm).1
    Â· exact Finset.measurableSet_biUnion _ hs.2",simp only [iUnion_iUnion_eq_iUnion_integral_finset_biUnion]
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.wordProd_mul_getD_rightInvSeq,wordProd_mul_getD_rightInvSeq,eb780daf7ddc0b2aff6bd37f400ad1275df42fc8,":= by
  rw [getD_rightInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 1 [â† take_append_drop (j + 1) Ï‰]
  rw [take_succ]
  obtain lt | le := lt_or_le j Ï‰.length
  Â· rw [get?_eq_get lt]
    simp only [wordProd_append, wordProd_cons, mul_assoc]
    simp
  Â· rw [get?_eq_none.mpr le]
    simp","error:  unsolved goals
case inl
B : Type u_1
W : Type u_2
instâœ : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
Ï‰ : List B
j : â„•
lt : j < Ï‰.length
âŠ¢ cs.wordProd Ï‰[j]?.toList * (cs.simple Ï‰[j] * cs.wordProd (drop (j + 1) Ï‰)) = cs.wordProd (drop (j + 1) Ï‰)
error:  unsolved goals
case inr
B : Type u_1
W : Type u_2
instâœ : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
Ï‰ : List B
j : â„•
le : Ï‰.length â‰¤ j
âŠ¢ cs.wordProd (take j Ï‰ ++ (Ï‰[j]?.toList ++ drop (j + 1) Ï‰)) = cs.wordProd (take j Ï‰ ++ drop (j + 1) Ï‰)","theorem wordProd_mul_getD_rightInvSeq (Ï‰ : List B) (j : â„•) :
    Ï€ Ï‰ * ((ris Ï‰).getD j 1) = Ï€ (Ï‰.eraseIdx j) ",":= by
  rw [getD_rightInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 1 [â† take_append_drop (j + 1) Ï‰]
  rw [take_succ]
  obtain lt | le := lt_or_le j Ï‰.length
  Â· simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]
    simp
  Â· simp only [get?_eq_getElem?, getElem?_eq_none le]
    simp","simp only [getD_eraseIdx_left, getD_eraseIdx_eq_getD_getD_rightInvSeq,
  getD_eraseIdx_left, getD_eraseIdx_left, getD_eraseIdx_left,
  getD_eraseIdx_left]"
Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean,Polynomial.exists_partition_polynomial,exists_partition_polynomial,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  have hbÎµ : 0 < cardPowDegree b â€¢ Îµ := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hÎµ
  induction' n with n ih
  Â· refine' âŸ¨finZeroElim, finZeroElimâŸ©
  have anti_archim' : âˆ€ {i j k} {Îµ : â„},
    (cardPowDegree (A i % b - A j % b) : â„) < Îµ â†’
      (cardPowDegree (A j % b - A k % b) : â„) < Îµ â†’
        (cardPowDegree (A i % b - A k % b) : â„) < Îµ := by
    intro i j k Îµ
    simp_rw [â† Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain âŸ¨t', ht'âŸ© := ih (Fin.tail A)
  rsuffices âŸ¨j, hjâŸ© :
    âˆƒ j, âˆ€ i, t' i = j â†” (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· refine' âŸ¨Fin.cons j t', fun iâ‚€ iâ‚ => _âŸ©
    refine' Fin.cases _ (fun iâ‚€ => _) iâ‚€ <;> refine' Fin.cases _ (fun iâ‚ => _) iâ‚
    Â· simpa using hbÎµ
    Â· rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj iâ‚
    Â· rw [Fin.cons_succ, Fin.cons_zero]
      exact hj iâ‚€
    Â· rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' iâ‚€ iâ‚
  obtain âŸ¨j, hjâŸ© : âˆƒ j, âˆ€ i : Fin n,
      t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ := by
    by_contra! hg
    obtain âŸ¨jâ‚€, jâ‚, j_ne, approxâŸ© := exists_approx_polynomial hb hÎµ
      (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (hg j))))
    revert j_ne approx
    refine' Fin.cases _ (fun jâ‚€ => _) jâ‚€ <;>
      refine' Fin.cases (fun j_ne approx => _) (fun jâ‚ j_ne approx => _) jâ‚
    Â· exact absurd rfl j_ne
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg jâ‚)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le] at approx
      have := (Classical.choose_spec (hg jâ‚€)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne.def, Fin.succ_inj] at j_ne
      have : jâ‚€ = jâ‚ := (Classical.choose_spec (hg jâ‚€)).1.symm.trans
        (((ht' (Classical.choose (hg jâ‚€)) (Classical.choose (hg jâ‚))).mpr approx).trans
          (Classical.choose_spec (hg jâ‚)).1)
      contradiction
  by_cases exists_nonempty_j : âˆƒ j, (âˆƒ i, t' i = j) âˆ§
      âˆ€ i, t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· obtain âŸ¨j, âŸ¨i, hiâŸ©, hjâŸ© := exists_nonempty_j
    refine' âŸ¨j, fun i' => âŸ¨hj i', fun hi' => _root_.trans ((ht' _ _).mpr _) hiâŸ©âŸ©
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  refine' âŸ¨j, fun i => âŸ¨hj i, fun hi => _âŸ©âŸ©
  have := exists_nonempty_j âŸ¨t' i, âŸ¨i, rflâŸ©, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')âŸ©
  contradiction","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.81178 â†’ ?m.81178 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.81180
case intro.intro.intro.refine'_2.refine'_2
Fq : Type u_1
instâœÂ¹ : Fintype Fq
instâœ : Field Fq
Îµ : â„
hÎµ : 0 < Îµ
b : Fq[X]
hb : b â‰  0
hbÎµ : 0 < cardPowDegree b â€¢ Îµ
n : â„•
ih :
  âˆ€ (A : Fin n â†’ Fq[X]),
    âˆƒ t, âˆ€ (iâ‚€ iâ‚ : Fin n), t iâ‚€ = t iâ‚ â†” â†‘(cardPowDegree (A iâ‚ % b - A iâ‚€ % b)) < cardPowDegree b â€¢ Îµ
A : Fin (n + 1) â†’ Fq[X]
anti_archim' :
  âˆ€ {i j k : Fin (n + 1)} {Îµ : â„},
    â†‘(cardPowDegree (A i % b - A j % b)) < Îµ â†’
      â†‘(cardPowDegree (A j % b - A k % b)) < Îµ â†’ â†‘(cardPowDegree (A i % b - A k % b)) < Îµ
t' : Fin n â†’ Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š)
ht' : âˆ€ (iâ‚€ iâ‚ : Fin n), t' iâ‚€ = t' iâ‚ â†” â†‘(cardPowDegree (Fin.tail A iâ‚ % b - Fin.tail A iâ‚€ % b)) < cardPowDegree b â€¢ Îµ
hg :
  âˆ€ (j : Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š)),
    âˆƒ i, t' i = j âˆ§ cardPowDegree b â€¢ Îµ â‰¤ â†‘(cardPowDegree (A 0 % b - A i.succ % b))
jâ‚€âœ jâ‚âœ : Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š).succ
jâ‚€ jâ‚ : Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š)
j_ne : jâ‚€.succ â‰  jâ‚.succ
approx : â†‘(cardPowDegree (A (Classical.choose â‹¯).succ % b - A (Classical.choose â‹¯).succ % b)) < cardPowDegree b â€¢ Îµ
âŠ¢ False","theorem exists_partition_polynomial_aux (n : â„•) {Îµ : â„} (hÎµ : 0 < Îµ) {b : Fq[X]} (hb : b â‰  0)
    (A : Fin n â†’ Fq[X]) : âˆƒ t : Fin n â†’ Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log (Fintype.card Fq)âŒ‰â‚Š),
      âˆ€ iâ‚€ iâ‚ : Fin n, t iâ‚€ = t iâ‚ â†”
        (cardPowDegree (A iâ‚ % b - A iâ‚€ % b) : â„) < cardPowDegree b â€¢ Îµ ",":= by
  have hbÎµ : 0 < cardPowDegree b â€¢ Îµ := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hÎµ
  induction' n with n ih
  Â· refine âŸ¨finZeroElim, finZeroElimâŸ©
  have anti_archim' : âˆ€ {i j k} {Îµ : â„},
    (cardPowDegree (A i % b - A j % b) : â„) < Îµ â†’
      (cardPowDegree (A j % b - A k % b) : â„) < Îµ â†’
        (cardPowDegree (A i % b - A k % b) : â„) < Îµ := by
    intro i j k Îµ
    simp_rw [â† Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain âŸ¨t', ht'âŸ© := ih (Fin.tail A)
  rsuffices âŸ¨j, hjâŸ© :
    âˆƒ j, âˆ€ i, t' i = j â†” (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· refine âŸ¨Fin.cons j t', fun iâ‚€ iâ‚ => ?_âŸ©
    refine Fin.cases ?_ (fun iâ‚€ => ?_) iâ‚€ <;> refine Fin.cases ?_ (fun iâ‚ => ?_) iâ‚
    Â· simpa using hbÎµ
    Â· rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj iâ‚
    Â· rw [Fin.cons_succ, Fin.cons_zero]
      exact hj iâ‚€
    Â· rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' iâ‚€ iâ‚
  obtain âŸ¨j, hjâŸ© : âˆƒ j, âˆ€ i : Fin n,
      t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ := by
    by_contra! hg
    obtain âŸ¨jâ‚€, jâ‚, j_ne, approxâŸ© := exists_approx_polynomial hb hÎµ
      (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (hg j))))
    revert j_ne approx
    refine Fin.cases ?_ (fun jâ‚€ => ?_) jâ‚€ <;>
      refine Fin.cases (fun j_ne approx => ?_) (fun jâ‚ j_ne approx => ?_) jâ‚
    Â· exact absurd rfl j_ne
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg jâ‚)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le] at approx
      have := (Classical.choose_spec (hg jâ‚€)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne, Fin.succ_inj] at j_ne
      have : jâ‚€ = jâ‚ := (Classical.choose_spec (hg jâ‚€)).1.symm.trans
        (((ht' (Classical.choose (hg jâ‚€)) (Classical.choose (hg jâ‚))).mpr approx).trans
          (Classical.choose_spec (hg jâ‚)).1)
      contradiction
  by_cases exists_nonempty_j : âˆƒ j, (âˆƒ i, t' i = j) âˆ§
      âˆ€ i, t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· obtain âŸ¨j, âŸ¨i, hiâŸ©, hjâŸ© := exists_nonempty_j
    refine âŸ¨j, fun i' => âŸ¨hj i', fun hi' => _root_.trans ((ht' _ _).mpr ?_) hiâŸ©âŸ©
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  refine âŸ¨j, fun i => âŸ¨hj i, fun hi => ?_âŸ©âŸ©
  have := exists_nonempty_j âŸ¨t' i, âŸ¨i, rflâŸ©, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')âŸ©
  contradiction","refine âŸ¨exists_partition_polynomial_polynomial_polynomial_polynomial_polynomial_polynomial_aux,
  exists_partition_polynomial_polynomial_polynomial_polynomial_polynomial_polynomial_polynomial_aux,
  exists_partition_polynomial_polynomial_polynomial_polynomial_auxâŸ©"
Mathlib/Data/Int/GCD.lean,Nat.gcdA_zero_right,gcdA_zero_right,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  unfold gcdA xgcd
  obtain âŸ¨s, rflâŸ© := Nat.exists_eq_succ_of_ne_zero h
  rw [xgcdAux_succ]
  rfl","error:  unknown identifier 'xgcdAux_succ'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.7334
case intro
s : â„•
h : s.succ â‰  0
âŠ¢ (s.succ.xgcdAux 1 0 0 0 1).2.1 = 1",theorem gcdA_zero_right {s : â„•} (h : s â‰  0) : gcdA s 0 = 1 ,":= by
  unfold gcdA xgcd
  obtain âŸ¨s, rflâŸ© := Nat.exists_eq_succ_of_ne_zero h
  rw [xgcdAux]
  simp",simp [gcdA_zero_right]
Mathlib/Topology/FiberBundle/Basic.lean,FiberBundle.exists_trivialization_Icc_subset,FiberBundle.exists_trivialization_Icc_subset,f7006a73d443b58eaf61494edacfeaae71d812f2,":= by
  obtain âŸ¨ea, heaâŸ© : âˆƒ ea : Trivialization F (Ï€ F E), a âˆˆ ea.baseSet :=
    âŸ¨trivializationAt F E a, mem_baseSet_trivializationAt F E aâŸ©
  cases' lt_or_le b a with hab hab
  Â· exact âŸ¨ea, by simp [*]âŸ©
  set s : Set B := { x âˆˆ Icc a b | âˆƒ e : Trivialization F (Ï€ F E), Icc a x âŠ† e.baseSet }
  have ha : a âˆˆ s := âŸ¨left_mem_Icc.2 hab, ea, by simp [hea]âŸ©
  have sne : s.Nonempty := âŸ¨a, haâŸ©
  have hsb : b âˆˆ upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := âŸ¨b, hsbâŸ©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c âˆˆ Icc a b := âŸ¨hsc.1 ha, hsc.2 hsbâŸ©
  obtain âŸ¨-, ec : Trivialization F (Ï€ F E), hec : Icc a c âŠ† ec.baseSetâŸ© : c âˆˆ s := by
    cases' hc.1.eq_or_lt with heq hlt
    Â· rwa [â† heq]
    refine âŸ¨hc, ?_âŸ©
    obtain âŸ¨ec, hcâŸ© : âˆƒ ec : Trivialization F (Ï€ F E), c âˆˆ ec.baseSet :=
      âŸ¨trivializationAt F E c, mem_baseSet_trivializationAt F E câŸ©
    obtain âŸ¨c', hc', hc'eâŸ© : âˆƒ c' âˆˆ Ico a c, Ioc c' c âŠ† ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain âŸ¨d, âŸ¨hdab, ead, hadâŸ©, hdâŸ© : âˆƒ d âˆˆ s, d âˆˆ Ioc c' c := hsc.exists_between hc'.2
    refine' âŸ¨ead.piecewiseLe ec d (had âŸ¨hdab.1, le_rflâŸ©) (hc'e hd), subset_ite.2 _âŸ©
    refine' âŸ¨fun x hx => had âŸ¨hx.1.1, hx.2âŸ©, fun x hx => hc'e âŸ¨hd.1.trans (not_le.1 hx.2), hx.1.2âŸ©âŸ©
  cases' hc.2.eq_or_lt with heq hlt
  Â· exact âŸ¨ec, heq â–¸ hecâŸ©
  suffices : âˆƒ d âˆˆ Ioc c b, âˆƒ e : Trivialization F (Ï€ F E), Icc a d âŠ† e.baseSet
  Â· rcases this with âŸ¨d, hdcb, hdâŸ© 
    exact ((hsc.1 âŸ¨âŸ¨hc.1.trans hdcb.1.le, hdcb.2âŸ©, hdâŸ©).not_lt hdcb.1).elim
  obtain âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, Ico c d âŠ† ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec âŸ¨hc.1, le_rflâŸ©))
  have had : Ico a d âŠ† ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  Â· obtain âŸ¨ed, hedâŸ© : âˆƒ ed : Trivialization F (Ï€ F E), d âˆˆ ed.baseSet :=
      âŸ¨trivializationAt F E d, mem_baseSet_trivializationAt F E dâŸ©
    refine' âŸ¨d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono (inter_subset_right _ _) (inter_subset_right _ _)), fun x hx => _âŸ©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr âŸ¨hed, hdcb.1âŸ©, Or.inl âŸ¨had âŸ¨hx.1, hxdâŸ©, hxdâŸ©]
  Â· rw [disjoint_left] at he
    push_neg at he
    rcases he with âŸ¨d', hdd' : d' < d, hd'câŸ©
    exact âŸ¨d', âŸ¨hd'c, hdd'.le.trans hdcb.2âŸ©, ec, (Icc_subset_Ico_right hdd').trans hadâŸ©",error:  unexpected token ':'; expected term,"theorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]
    [OrderTopology B] [FiberBundle F E] (a b : B) :
    âˆƒ e : Trivialization F (Ï€ F E), Icc a b âŠ† e.baseSet ",":= by
  obtain âŸ¨ea, heaâŸ© : âˆƒ ea : Trivialization F (Ï€ F E), a âˆˆ ea.baseSet :=
    âŸ¨trivializationAt F E a, mem_baseSet_trivializationAt F E aâŸ©
  cases' lt_or_le b a with hab hab
  Â· exact âŸ¨ea, by simp [*]âŸ©
  set s : Set B := { x âˆˆ Icc a b | âˆƒ e : Trivialization F (Ï€ F E), Icc a x âŠ† e.baseSet }
  have ha : a âˆˆ s := âŸ¨left_mem_Icc.2 hab, ea, by simp [hea]âŸ©
  have sne : s.Nonempty := âŸ¨a, haâŸ©
  have hsb : b âˆˆ upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := âŸ¨b, hsbâŸ©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c âˆˆ Icc a b := âŸ¨hsc.1 ha, hsc.2 hsbâŸ©
  obtain âŸ¨-, ec : Trivialization F (Ï€ F E), hec : Icc a c âŠ† ec.baseSetâŸ© : c âˆˆ s := by
    rcases hc.1.eq_or_lt with heq | hlt
    Â· rwa [â† heq]
    refine âŸ¨hc, ?_âŸ©
    obtain âŸ¨ec, hcâŸ© : âˆƒ ec : Trivialization F (Ï€ F E), c âˆˆ ec.baseSet :=
      âŸ¨trivializationAt F E c, mem_baseSet_trivializationAt F E câŸ©
    obtain âŸ¨c', hc', hc'eâŸ© : âˆƒ c' âˆˆ Ico a c, Ioc c' c âŠ† ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain âŸ¨d, âŸ¨hdab, ead, hadâŸ©, hdâŸ© : âˆƒ d âˆˆ s, d âˆˆ Ioc c' c := hsc.exists_between hc'.2
    refine âŸ¨ead.piecewiseLe ec d (had âŸ¨hdab.1, le_rflâŸ©) (hc'e hd), subset_ite.2 ?_âŸ©
    exact âŸ¨fun x hx => had âŸ¨hx.1.1, hx.2âŸ©, fun x hx => hc'e âŸ¨hd.1.trans (not_le.1 hx.2), hx.1.2âŸ©âŸ©
  rcases hc.2.eq_or_lt with heq | hlt
  Â· exact âŸ¨ec, heq â–¸ hecâŸ©
  rsuffices âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, âˆƒ e : Trivialization F (Ï€ F E), Icc a d âŠ† e.baseSet
  Â· exact ((hsc.1 âŸ¨âŸ¨hc.1.trans hdcb.1.le, hdcb.2âŸ©, hdâŸ©).not_lt hdcb.1).elim
  obtain âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, Ico c d âŠ† ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec âŸ¨hc.1, le_rflâŸ©))
  have had : Ico a d âŠ† ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  Â· obtain âŸ¨ed, hedâŸ© : âˆƒ ed : Trivialization F (Ï€ F E), d âˆˆ ed.baseSet :=
      âŸ¨trivializationAt F E d, mem_baseSet_trivializationAt F E dâŸ©
    refine âŸ¨d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono inter_subset_right inter_subset_right), fun x hx => ?_âŸ©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr âŸ¨hed, hdcb.1âŸ©, Or.inl âŸ¨had âŸ¨hx.1, hxdâŸ©, hxdâŸ©]
  Â· rw [disjoint_left] at he
    push_neg at he
    rcases he with âŸ¨d', hdd' : d' < d, hd'câŸ©
    exact âŸ¨d', âŸ¨hd'c, hdd'.le.trans hdcb.2âŸ©, ec, (Icc_subset_Ico_right hdd').trans hadâŸ©","rcases FiberBundle.exists_trivialization_Icc_subset with âŸ¨e, heâŸ©"
Mathlib/Analysis/Complex/CauchyIntegral.lean,Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  set A := closedBall c R \ ball c r
  obtain âŸ¨a, rflâŸ© : âˆƒ a, Real.exp a = r; exact âŸ¨Real.log r, Real.exp_log h0âŸ©
  obtain âŸ¨b, rflâŸ© : âˆƒ b, Real.exp b = R; exact âŸ¨Real.log R, Real.exp_log (h0.trans_le hle)âŸ©
  rw [Real.exp_le_exp] at hle
  suffices
    (âˆ« Î¸ in (0)..2 * Ï€, I â€¢ f (circleMap c (Real.exp b) Î¸)) =
      âˆ« Î¸ in (0)..2 * Ï€, I â€¢ f (circleMap c (Real.exp a) Î¸) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, â† exp_add, smul_smul, â†
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] Ã—â„‚ [[0, 2 * Ï€]]
  set g : â„‚ â†’ â„‚ := (c + exp Â·)
  have hdg : Differentiable â„‚ g := differentiable_exp.const_add _
  replace hs : (g â»Â¹' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z âŸ¨h, -âŸ©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f âˆ˜ g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : âˆ€ z âˆˆ Ioo (min a b) (max a b) Ã—â„‚ Ioo (min 0 (2 * Ï€)) (max 0 (2 * Ï€)) \ g â»Â¹' s,
      DifferentiableAt â„‚ (f âˆ˜ g) z := by
    refine' fun z hz => (hd (g z) âŸ¨_, hz.2âŸ©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, â† exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ âŸ¨a, 0âŸ© âŸ¨b, 2 * Ï€âŸ© _ hs hc hd","warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  application type mismatch
  mul_div_cancel_left ?m.98557 (circleMap_ne_center (LT.lt.ne' (Real.exp_pos ?m.98560)))
argument
  circleMap_ne_center (LT.lt.ne' (Real.exp_pos ?m.98560))
has type
  circleMap ?m.98558 (rexp ?m.98560) ?m.98590 â‰  ?m.98558 : Prop
but is expected to have type
  ?m.98555 : Type ?u.98554
error:  tactic 'assumption' failed
E : Type u
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„‚ E
instâœ : CompleteSpace E
c : â„‚
f : â„‚ â†’ E
s : Set â„‚
hs : s.Countable
a : â„
h0 : 0 < rexp a
b : â„
hle : a â‰¤ b
hd : âˆ€ z âˆˆ (ball c (rexp b) \ closedBall c (rexp a)) \ s, DifferentiableAt â„‚ f z
A : Set â„‚ := closedBall c (rexp b) \ ball c (rexp a)
hc : ContinuousOn f A
this : âˆ« (Î¸ : â„) in 0 ..2 * Ï€, I â€¢ f (circleMap c (rexp b) Î¸) = âˆ« (Î¸ : â„) in 0 ..2 * Ï€, I â€¢ f (circleMap c (rexp a) Î¸)
âŠ¢ âˆ« (Î¸ : â„) in 0 ..2 * Ï€, (circleMap 0 (rexp b) Î¸ * I / circleMap 0 (rexp b) Î¸) â€¢ f (circleMap c (rexp b) Î¸) =
    âˆ« (Î¸ : â„) in 0 ..2 * Ï€, (circleMap 0 (rexp a) Î¸ * I / circleMap 0 (rexp a) Î¸) â€¢ f (circleMap c (rexp a) Î¸)","theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : â„‚}
    {r R : â„} (h0 : 0 < r) (hle : r â‰¤ R) {f : â„‚ â†’ E} {s : Set â„‚} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : âˆ€ z âˆˆ (ball c R \ closedBall c r) \ s, DifferentiableAt â„‚ f z) :
    (âˆ® z in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® z in C(c, r), (z - c)â»Â¹ â€¢ f z ",":= by
  set A := closedBall c R \ ball c r
  obtain âŸ¨a, rflâŸ© : âˆƒ a, Real.exp a = r := âŸ¨Real.log r, Real.exp_log h0âŸ©
  obtain âŸ¨b, rflâŸ© : âˆƒ b, Real.exp b = R := âŸ¨Real.log R, Real.exp_log (h0.trans_le hle)âŸ©
  rw [Real.exp_le_exp] at hle
  suffices
    (âˆ« Î¸ in (0)..2 * Ï€, I â€¢ f (circleMap c (Real.exp b) Î¸)) =
      âˆ« Î¸ in (0)..2 * Ï€, I â€¢ f (circleMap c (Real.exp a) Î¸) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, â† exp_add, smul_smul, â†
      div_eq_mul_inv, mul_div_cancel_leftâ‚€ _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] Ã—â„‚ [[0, 2 * Ï€]]
  set g : â„‚ â†’ â„‚ := (c + exp Â·)
  have hdg : Differentiable â„‚ g := differentiable_exp.const_add _
  replace hs : (g â»Â¹' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z âŸ¨h, -âŸ©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f âˆ˜ g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : âˆ€ z âˆˆ Ioo (min a b) (max a b) Ã—â„‚ Ioo (min 0 (2 * Ï€)) (max 0 (2 * Ï€)) \ g â»Â¹' s,
      DifferentiableAt â„‚ (f âˆ˜ g) z := by
    refine fun z hz => (hd (g z) âŸ¨?_, hz.2âŸ©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, â† exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ âŸ¨a, 0âŸ© âŸ¨b, 2 * Ï€âŸ© _ hs hc hd","refine theorem_circleIntegral_sub_center_inv_smul_eq_of_differentiable_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_"
Mathlib/Logic/Function/Iterate.lean,Function.Commute.iterate_left,iterate_left,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction n generalizing k with
  | zero =>
    rw [Nat.zero_add]
    exact id_left
  | succ n ihn =>
    rw [Nat.succ_eq_add_one, Nat.add_right_comm, Nat.add_assoc]
    exact (H k).trans (ihn (k + 1))","warning:  @Nat.iterate does not have a doc string
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ
Î± : Type u
Î² : Type v
f : Î± â†’ Î±
g : â„• â†’ Î± â†’ Î±
H : âˆ€ (n : â„•), Semiconj f (g n) (g (n + 1))
n : â„•
ihn : âˆ€ (k : â„•), Semiconj f^[n] (g k) (g (n + k))
k : â„•
âŠ¢ Semiconj f^[n + 1] (g k) (g (n + 1 + k))","theorem iterate_left {g : â„• â†’ Î± â†’ Î±} (H : âˆ€ n, Semiconj f (g n) (g <| n + 1)) (n k : â„•) :
    Semiconj f^[n] (g k) (g <| n + k) ",":= by
  induction n generalizing k with
  | zero =>
    rw [Nat.zero_add]
    exact id_left
  | succ n ihn =>
    rw [Nat.add_right_comm, Nat.add_assoc]
    exact (H k).trans (ihn (k + 1))",induction' k with k hk
Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean,AffineMap.ext,ext,161a7501773058c7d39559d99d747edbacc56fbd,":= by
  rcases f with âŸ¨f, f_linear, f_addâŸ©
  rcases g with âŸ¨g, g_linear, g_addâŸ©
  obtain rfl : f = g := funext h
  congr with v
  cases' (AddTorsor.Nonempty : Nonempty P1) with p
  apply vadd_right_cancel (f p)
  erw [â† f_add, â† g_add]",error:  unknown constant 'AddTorsor.Nonempty',"theorem ext {f g : P1 â†’áµƒ[k] P2} (h : âˆ€ p, f p = g p) : f = g ",":=
  DFunLike.ext _ _ h",refine ext_of_theorem ext_theorem ext_theorem ext_theorem ext_theorem ext_theorem ext_theorem ?_
Mathlib/Topology/Category/Profinite/Nobeling.lean,Profinite.NobelingProof.Nobeling_aux,Nobeling_aux,050597bd179a992452551cc51fe5aea3b4bdaf61,":= Module.Free.of_equiv'
  (Module.Free.of_basis <| GoodProducts.Basis _ hÎ¹.isClosed_range) (LocallyConstant.congrLeftâ‚— â„¤
  hÎ¹.toEmbedding.toHomeomorph).symm","error:  invalid field 'toHomeomorph', the environment does not contain 'Embedding.toHomeomorph'
  hÎ¹.toEmbedding
has type
  Embedding Î¹",theorem Nobeling_aux : Module.Free â„¤ (LocallyConstant S â„¤) ,":= Module.Free.of_equiv'
  (Module.Free.of_basis <| GoodProducts.Basis _ hÎ¹.isClosed_range) (LocallyConstant.congrLeftâ‚— â„¤
  (Homeomorph.ofEmbedding Î¹ hÎ¹.toEmbedding)).symm",heorem Nobeling_aux Nobeling_aux Nobeling_aux
Mathlib/Geometry/Euclidean/Triangle.lean,EuclideanGeometry.dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq,dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  by_cases hbc : b = c
  Â· simp [hbc, midpoint_self, dist_self, two_mul]
  Â· let m := midpoint â„ b c
    have : dist b c â‰  0 := (dist_pos.mpr hbc).ne'
    have hm := dist_sq_mul_dist_add_dist_sq_mul_dist a b c m (angle_midpoint_eq_pi b c hbc)
    simp only [dist_left_midpoint, dist_right_midpoint, Real.norm_two] at hm
    calc
      dist a b ^ 2 + dist a c ^ 2 = 2 / dist b c * (dist a b ^ 2 *
        ((2:â„)â»Â¹ * dist b c) + dist a c ^ 2 * (2â»Â¹ * dist b c)) := by field_simp; ring
      _ = 2 * (dist a (midpoint â„ b c) ^ 2 + (dist b c / 2) ^ 2) := by rw [hm]; field_simp; ring","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  dist a b ^ 2 * dist c m + dist a c ^ 2 * dist b m
V : Type u_1
P : Type u_2
instâœÂ³ : NormedAddCommGroup V
instâœÂ² : InnerProductSpace â„ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
a b c : P
hbc : Â¬b = c
m : P := midpoint â„ b c
this : dist b c â‰  0
hm : dist a b ^ 2 * dist c m + dist a c ^ 2 * dist b m = dist b c * (dist a m ^ 2 + dist b m * dist c m)
âŠ¢ 2 / dist b c * (dist a b ^ 2 * (2â»Â¹ * dist b c) + dist a c ^ 2 * (2â»Â¹ * dist b c)) =
    2 * (dist a (midpoint â„ b c) ^ 2 + (dist b c / 2) ^ 2)","theorem dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq (a b c : P) :
    dist a b ^ 2 + dist a c ^ 2 = 2 * (dist a (midpoint â„ b c) ^ 2 + (dist b c / 2) ^ 2) ",":= by
  by_cases hbc : b = c
  Â· simp [hbc, midpoint_self, dist_self, two_mul]
  Â· let m := midpoint â„ b c
    have : dist b c â‰  0 := (dist_pos.mpr hbc).ne'
    have hm := dist_sq_mul_dist_add_dist_sq_mul_dist a b c m (angle_midpoint_eq_pi b c hbc)
    simp only [m, dist_left_midpoint, dist_right_midpoint, Real.norm_two] at hm
    calc
      dist a b ^ 2 + dist a c ^ 2 = 2 / dist b c * (dist a b ^ 2 *
        ((2:â„)â»Â¹ * dist b c) + dist a c ^ 2 * (2â»Â¹ * dist b c)) := by field_simp; ring
      _ = 2 * (dist a (midpoint â„ b c) ^ 2 + (dist b c / 2) ^ 2) := by rw [hm]; field_simp; ring",rw [dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_eq_two_mul_dist_midpoint_sq_eq_two_mul_dist_midpoint_sq_add_half_dist]
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le,norm_volume_sub_integral_face_upper_sub_lower_smul_le,5314a658f207fdcef03c22ffaf7bc64414488ae1,":= by
  set e : â„ â†’ (Fin n â†’ â„) â†’ (Fin (n + 1) â†’ â„) := i.insertNth (Î± := fun _ â†¦ â„)
  have Hl : I.lower i âˆˆ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i âˆˆ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : âˆ€ x âˆˆ Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) âŠ¥ (f âˆ˜ e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : âˆ€ y âˆˆ Box.Icc (I.face i),
      â€–f' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))â€– â‰¤
        2 * Îµ * diam (Box.Icc I) := fun y hy â†¦ by
    set g := fun y => f y - a - f' (y - x) with hg
    change âˆ€ y âˆˆ (Box.Icc I), â€–g yâ€– â‰¤ Îµ * â€–y - xâ€– at hÎµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to â€–g (e (I.lower i) y) - g (e (I.upper i) y)â€– â‰¤ _
    Â· congr 1
      have := Fin.insertNth_sub_same (Î± := fun _ â†¦ â„) i (I.upper i) (I.lower i) y
      simp only [â† this, f'.map_sub]; abel
    Â· have : âˆ€ z âˆˆ Icc (I.lower i) (I.upper i), e z y âˆˆ (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hÎµ : âˆ€ y âˆˆ (Box.Icc I), â€–g yâ€– â‰¤ Îµ * diam (Box.Icc I)
      Â· intro y hy
        refine' (hÎµ y hy).trans (mul_le_mul_of_nonneg_left _ h0.le)
        rw [â† dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hÎµ _ (this _ Hl)) (hÎµ _ (this _ Hu))
  calc
    â€–(âˆ j, (I.upper j - I.lower j)) â€¢ f' (Pi.single i 1) -
            (integral (I.face i) âŠ¥ (f âˆ˜ e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) âŠ¥ (f âˆ˜ e (I.lower i)) BoxAdditiveMap.volume)â€– =
        â€–integral.{0, u, u} (I.face i) âŠ¥
            (fun x : Fin n â†’ â„ =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volumeâ€– := by
      rw [â† integral_sub (Hi _ Hu) (Hi _ Hl), â† Box.volume_face_mul i, mul_smul, â† Box.volume_apply,
        â† BoxAdditiveMap.toSMul_apply, â† integral_const, â† BoxAdditiveMap.volume,
        â† integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [Function.comp_def, Pi.sub_def, â† f'.map_smul, â† Pi.single_smul', smul_eq_mul,
        mul_one]
    _ â‰¤ (volume (I.face i : Set (Fin n â†’ â„))).toReal * (2 * Îµ * c * (I.upper i - I.lower i)) := by
      refine' norm_integral_le_of_le_const (fun y hy => (this y hy).trans _) volume
      rw [mul_assoc (2 * Îµ)]
      exact mul_le_mul_of_nonneg_left (I.diam_Icc_le_of_distortion_le i hc)
        (mul_nonneg zero_le_two h0.le)
    _ = 2 * Îµ * c * âˆ j, (I.upper j - I.lower j) := by
      rw [â† Measure.toBoxAdditive_apply, Box.volume_apply, â† I.volume_face_mul i]
      ac_rfl","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case convert_2
E : Type u
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
n : â„•
instâœ : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f' : (Fin (n + 1) â†’ â„) â†’L[â„] E
x : Fin (n + 1) â†’ â„
hxI : x âˆˆ Box.Icc I
a : E
Îµ : â„
h0 : 0 < Îµ
c : â„â‰¥0
hc : I.distortion â‰¤ c
e : â„ â†’ (Fin n â†’ â„) â†’ Fin (n + 1) â†’ â„ := i.insertNth
Hl : I.lower i âˆˆ Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i âˆˆ Set.Icc (I.lower i) (I.upper i)
y : Fin n â†’ â„
hy : y âˆˆ Box.Icc (I.face i)
g : (Fin (n + 1) â†’ â„) â†’ E
hfc : ContinuousOn (fun y â†¦ a + f' (y - x) + g y) (Box.Icc I)
Hi :
  âˆ€ x_1 âˆˆ Set.Icc (I.lower i) (I.upper i),
    Integrable (I.face i) âŠ¥ ((fun y â†¦ a + f' (y - x) + g y) âˆ˜ e x_1) BoxAdditiveMap.volume
hg : g = fun y â†¦ (fun y â†¦ a + f' (y - x) + g y) y - a - f' (y - x)
this : âˆ€ z âˆˆ Set.Icc (I.lower i) (I.upper i), e z y âˆˆ Box.Icc I
hÎµ : âˆ€ y âˆˆ Box.Icc I, â€–g yâ€– â‰¤ Îµ * diam (Box.Icc I)
âŠ¢ â€–g (e (I.lower i) y) - g (e (I.upper i) y)â€– â‰¤ 2 * Îµ * diam (Box.Icc I)
error:  unsolved goals
E : Type u
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
n : â„•
instâœ : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f : (Fin (n + 1) â†’ â„) â†’ E
f' : (Fin (n + 1) â†’ â„) â†’L[â„] E
hfc : ContinuousOn f (Box.Icc I)
x : Fin (n + 1) â†’ â„
hxI : x âˆˆ Box.Icc I
a : E
Îµ : â„
h0 : 0 < Îµ
hÎµ : âˆ€ y âˆˆ Box.Icc I, â€–f y - a - f' (y - x)â€– â‰¤ Îµ * â€–y - xâ€–
c : â„â‰¥0
hc : I.distortion â‰¤ c
e : â„ â†’ (Fin n â†’ â„) â†’ Fin (n + 1) â†’ â„ := i.insertNth
Hl : I.lower i âˆˆ Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i âˆˆ Set.Icc (I.lower i) (I.upper i)
Hi : âˆ€ x âˆˆ Set.Icc (I.lower i) (I.upper i), Integrable (I.face i) âŠ¥ (f âˆ˜ e x) BoxAdditiveMap.volume
this :
  âˆ€ y âˆˆ Box.Icc (I.face i),
    â€–f' (Pi.single i (I.upper i - I.lower i)) - (f (e (I.upper i) y) - f (e (I.lower i) y))â€– â‰¤ 2 * Îµ * diam (Box.Icc I)
âŠ¢ â€–(âˆ j : Fin (n + 1), (I.upper j - I.lower j)) â€¢ f' (Pi.single i 1) -
        (integral (I.face i) âŠ¥ (f âˆ˜ e (I.upper i)) BoxAdditiveMap.volume -
          integral (I.face i) âŠ¥ (f âˆ˜ e (I.lower i)) BoxAdditiveMap.volume)â€– â‰¤
    2 * Îµ * â†‘c * âˆ j : Fin (n + 1), (I.upper j - I.lower j)","theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) â†’ â„) â†’ E}
    {f' : (Fin (n + 1) â†’ â„) â†’L[â„] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) â†’ â„}
    (hxI : x âˆˆ (Box.Icc I)) {a : E} {Îµ : â„} (h0 : 0 < Îµ)
    (hÎµ : âˆ€ y âˆˆ (Box.Icc I), â€–f y - a - f' (y - x)â€– â‰¤ Îµ * â€–y - xâ€–) {c : â„â‰¥0}
    (hc : I.distortion â‰¤ c) :
    â€–(âˆ j, (I.upper j - I.lower j)) â€¢ f' (Pi.single i 1) -
      (integral (I.face i) âŠ¥ (f âˆ˜ i.insertNth (Î± := fun _ â†¦ â„) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) âŠ¥ (f âˆ˜ i.insertNth (Î± := fun _ â†¦ â„) (I.lower i))
          BoxAdditiveMap.volume)â€– â‰¤
      2 * Îµ * c * âˆ j, (I.upper j - I.lower j) ",":= by
  set e : â„ â†’ (Fin n â†’ â„) â†’ (Fin (n + 1) â†’ â„) := i.insertNth (Î± := fun _ â†¦ â„)
  have Hl : I.lower i âˆˆ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i âˆˆ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : âˆ€ x âˆˆ Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) âŠ¥ (f âˆ˜ e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : âˆ€ y âˆˆ Box.Icc (I.face i),
      â€–f' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))â€– â‰¤
        2 * Îµ * diam (Box.Icc I) := fun y hy â†¦ by
    set g := fun y => f y - a - f' (y - x) with hg
    change âˆ€ y âˆˆ (Box.Icc I), â€–g yâ€– â‰¤ Îµ * â€–y - xâ€– at hÎµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to â€–g (e (I.lower i) y) - g (e (I.upper i) y)â€– â‰¤ _
    Â· congr 1
      have := Fin.insertNth_sub_same (Î± := fun _ â†¦ â„) i (I.upper i) (I.lower i) y
      simp only [â† this, f'.map_sub]; abel
    Â· have : âˆ€ z âˆˆ Icc (I.lower i) (I.upper i), e z y âˆˆ (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hÎµ : âˆ€ y âˆˆ (Box.Icc I), â€–g yâ€– â‰¤ Îµ * diam (Box.Icc I) := by
        intro y hy
        refine (hÎµ y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [â† dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hÎµ _ (this _ Hl)) (hÎµ _ (this _ Hu))
  calc
    â€–(âˆ j, (I.upper j - I.lower j)) â€¢ f' (Pi.single i 1) -
            (integral (I.face i) âŠ¥ (f âˆ˜ e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) âŠ¥ (f âˆ˜ e (I.lower i)) BoxAdditiveMap.volume)â€– =
        â€–integral.{0, u, u} (I.face i) âŠ¥
            (fun x : Fin n â†’ â„ =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volumeâ€– := by
      rw [â† integral_sub (Hi _ Hu) (Hi _ Hl), â† Box.volume_face_mul i, mul_smul, â† Box.volume_apply,
        â† BoxAdditiveMap.toSMul_apply, â† integral_const, â† BoxAdditiveMap.volume,
        â† integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(Â· âˆ˜ Â·), Pi.sub_def, â† f'.map_smul, â† Pi.single_smul', smul_eq_mul, mul_one]
    _ â‰¤ (volume (I.face i : Set (Fin n â†’ â„))).toReal * (2 * Îµ * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * Îµ)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * Îµ * c * âˆ j, (I.upper j - I.lower j) := by
      rw [â† Measure.toBoxAdditive_apply, Box.volume_apply, â† I.volume_face_mul i]
      ac_rfl","refine theorem_theorem_Icc _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  (fun y hy => ?_) (fun y hy => ?_) _ _"
Mathlib/Topology/Category/CompHaus/EffectiveEpi.lean,CompHaus.effectiveEpiFamily_tfae,effectiveEpiFamily_tfae,120334db6bd1644200a0101ca523070340f20491,":= by
  tfae_have 2 â†’ 1
  Â· intro
    simpa [â† effectiveEpi_desc_iff_effectiveEpiFamily, (effectiveEpi_tfae (Sigma.desc Ï€)).out 0 1]
  tfae_have 1 â†’ 2
  Â· intro; infer_instance
  tfae_have 3 â†’ 2
  Â· intro e
    rw [epi_iff_surjective]
    intro b
    obtain âŸ¨t, x, hâŸ© := e b
    refine âŸ¨Sigma.Î¹ X t x, ?_âŸ©
    change (Sigma.Î¹ X t â‰« Sigma.desc Ï€) x = _
    simpa using h
  tfae_have 2 â†’ 3
  Â· intro e; rw [epi_iff_surjective] at e
    let i : âˆ X â‰… finiteCoproduct X :=
      (colimit.isColimit _).coconePointUniqueUpToIso (finiteCoproduct.isColimit _)
    intro b
    obtain âŸ¨t, rflâŸ© := e b
    let q := i.hom t
    refine âŸ¨q.1,q.2,?_âŸ©
    have : t = i.inv (i.hom t) := show t = (i.hom â‰« i.inv) t by simp only [i.hom_inv_id]; rfl
    rw [this]
    show _ = (i.inv â‰« Sigma.desc Ï€) (i.hom t)
    suffices i.inv â‰« Sigma.desc Ï€ = finiteCoproduct.desc X Ï€ by
      rw [this]; rfl
    rw [Iso.inv_comp_eq]
    apply colimit.hom_ext
    rintro âŸ¨aâŸ©
    simp only [Discrete.functor_obj, colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app,
      colimit.comp_coconePointUniqueUpToIso_hom_assoc]
    ext; rfl
  tfae_finish","error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case tfae_2_to_3.intro.w.mk.w
Î± : Type
instâœ : Finite Î±
B : CompHaus
X : Î± â†’ CompHaus
Ï€ : (a : Î±) â†’ X a âŸ¶ B
tfae_2_to_1 : Epi (Sigma.desc Ï€) â†’ EffectiveEpiFamily X Ï€
tfae_1_to_2 : EffectiveEpiFamily X Ï€ â†’ Epi (Sigma.desc Ï€)
tfae_3_to_2 : (âˆ€ (b : â†‘B.toTop), âˆƒ a x, (Ï€ a) x = b) â†’ Epi (Sigma.desc Ï€)
e : Function.Surjective â‡‘(Sigma.desc Ï€)
i : âˆ X â‰… finiteCoproduct X :=
  (colimit.isColimit (Discrete.functor X)).coconePointUniqueUpToIso (finiteCoproduct.isColimit X)
t : (forget CompHaus).obj (âˆ X)
q : (forget CompHaus).obj (finiteCoproduct X) := i.hom t
this : t = i.inv (i.hom t)
a : Î±
xâœ : (forget CompHaus).obj (X a)
âŠ¢ (Ï€ a) xâœ = (colimit.Î¹ (Discrete.functor X) { as := a } â‰« i.hom â‰« finiteCoproduct.desc X Ï€) xâœ","theorem effectiveEpiFamily_tfae
    {Î± : Type} [Finite Î±] {B : CompHaus.{u}}
    (X : Î± â†’ CompHaus.{u}) (Ï€ : (a : Î±) â†’ (X a âŸ¶ B)) :
    TFAE
    [ EffectiveEpiFamily X Ï€
    , Epi (Sigma.desc Ï€)
    , âˆ€ b : B, âˆƒ (a : Î±) (x : X a), Ï€ a x = b
    ] ",":= by
  tfae_have 2 â†’ 1
  Â· intro
    simpa [â† effectiveEpi_desc_iff_effectiveEpiFamily, (effectiveEpi_tfae (Sigma.desc Ï€)).out 0 1]
  tfae_have 1 â†’ 2
  Â· intro; infer_instance
  tfae_have 3 â†’ 2
  Â· intro e
    rw [epi_iff_surjective]
    intro b
    obtain âŸ¨t, x, hâŸ© := e b
    refine âŸ¨Sigma.Î¹ X t x, ?_âŸ©
    change (Sigma.Î¹ X t â‰« Sigma.desc Ï€) x = _
    simpa using h
  tfae_have 2 â†’ 3
  Â· intro e; rw [epi_iff_surjective] at e
    let i : âˆ X â‰… finiteCoproduct X :=
      (colimit.isColimit _).coconePointUniqueUpToIso (finiteCoproduct.isColimit _)
    intro b
    obtain âŸ¨t, rflâŸ© := e b
    let q := i.hom t
    refine âŸ¨q.1,q.2,?_âŸ©
    have : t = i.inv (i.hom t) := show t = (i.hom â‰« i.inv) t by simp only [i.hom_inv_id]; rfl
    rw [this]
    show _ = (i.inv â‰« Sigma.desc Ï€) (i.hom t)
    suffices i.inv â‰« Sigma.desc Ï€ = finiteCoproduct.desc X Ï€ by
      rw [this]; rfl
    rw [Iso.inv_comp_eq]
    apply colimit.hom_ext
    rintro âŸ¨aâŸ©
    simp only [i, Discrete.functor_obj, colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app,
      colimit.comp_coconePointUniqueUpToIso_hom_assoc]
    ext; rfl
  tfae_finish",rw [effectiveEpiFamily_theorem_effectiveEpiFamily_theorem]
Mathlib/NumberTheory/Divisors.lean,Nat.pos_of_mem_divisors,pos_of_mem_divisors,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  cases m
  Â· rw [mem_divisors, zero_eq, zero_dvd_iff (a := n)] at h
    cases h.2 h.1
  apply Nat.succ_pos","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  zero
case zero
n : â„•
h : 0 âˆ£ n âˆ§ n â‰  0
âŠ¢ 0 < 0",theorem pos_of_mem_divisors {m : â„•} (h : m âˆˆ n.divisors) : 0 < m ,":= by
  cases m
  Â· rw [mem_divisors, zero_dvd_iff (a := n)] at h
    cases h.2 h.1
  apply Nat.succ_pos",rw [mem_divisors] at h
Mathlib/Topology/MetricSpace/PiNat.lean,PiNat.exists_lipschitz_retraction_of_isClosed,exists_lipschitz_retraction_of_isClosed,868e361b310c1d818e48f5bcba9026910b1f6cdf,":= by
  set f := fun x => if x âˆˆ s then x else (inter_cylinder_longestPrefix_nonempty hs hne x).some
  have fs : âˆ€ x âˆˆ s, f x = x := fun x xs => by simp [xs]
  refine' âŸ¨f, fs, _, _âŸ©
  Â· apply Subset.antisymm
    Â· rintro x âŸ¨y, rflâŸ©
      by_cases hy : y âˆˆ s
      Â· rwa [fs y hy]
      simpa [if_neg hy] using (inter_cylinder_longestPrefix_nonempty hs hne y).choose_spec.1
    Â· intro x hx
      rw [â† fs x hx]
      exact mem_range_self _
  Â· refine LipschitzWith.mk_one fun x y => ?_
    rcases eq_or_ne x y with (rfl | hxy)
    Â· simp
    rcases eq_or_ne (f x) (f y) with (h' | hfxfy)
    Â· simp [h', dist_nonneg]
    have I2 : cylinder x (firstDiff x y) = cylinder y (firstDiff x y) := by
      rw [â† mem_cylinder_iff_eq]
      apply mem_cylinder_firstDiff
    suffices firstDiff x y â‰¤ firstDiff (f x) (f y) by
      simpa [dist_eq_of_ne hxy, dist_eq_of_ne hfxfy]
    by_cases xs : x âˆˆ s
    Â· rw [fs x xs] at hfxfy âŠ¢
      by_cases ys : y âˆˆ s
      Â· rw [fs y ys]
      have A : (s âˆ© cylinder y (longestPrefix y s)).Nonempty :=
        inter_cylinder_longestPrefix_nonempty hs hne y
      have fy : f y = A.some := by simp_rw [if_neg ys]
      have I : cylinder A.some (firstDiff x y) = cylinder y (firstDiff x y) := by
        rw [â† mem_cylinder_iff_eq, firstDiff_comm]
        apply cylinder_anti y _ A.some_mem.2
        exact firstDiff_le_longestPrefix hs ys xs
      rwa [â† fy, â† I2, â† mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy.symm,
        firstDiff_comm _ x] at I
    Â· by_cases ys : y âˆˆ s
      Â· have A : (s âˆ© cylinder x (longestPrefix x s)).Nonempty :=
          inter_cylinder_longestPrefix_nonempty hs hne x
        have fx : f x = A.some := by simp_rw [if_neg xs]
        have I : cylinder A.some (firstDiff x y) = cylinder x (firstDiff x y) := by
          rw [â† mem_cylinder_iff_eq]
          apply cylinder_anti x _ A.some_mem.2
          apply firstDiff_le_longestPrefix hs xs ys
        rw [fs y ys] at hfxfyâŠ¢
        rwa [â† fx, I2, â† mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy] at I
      Â· have Ax : (s âˆ© cylinder x (longestPrefix x s)).Nonempty :=
          inter_cylinder_longestPrefix_nonempty hs hne x
        have fx : f x = Ax.some := by simp_rw [if_neg xs]
        have Ay : (s âˆ© cylinder y (longestPrefix y s)).Nonempty :=
          inter_cylinder_longestPrefix_nonempty hs hne y
        have fy : f y = Ay.some := by simp_rw [if_neg ys]
        by_cases H : longestPrefix x s < firstDiff x y âˆ¨ longestPrefix y s < firstDiff x y
        Â· have : cylinder x (longestPrefix x s) = cylinder y (longestPrefix y s) := by
            cases' H with H H
            Â· exact cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff hs hne H xs ys
            Â· symm
              rw [firstDiff_comm] at H
              exact cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff hs hne H ys xs
          rw [fx, fy] at hfxfy
          apply (hfxfy _).elim
          congr
        Â· push_neg  at H
          have I1 : cylinder Ax.some (firstDiff x y) = cylinder x (firstDiff x y) := by
            rw [â† mem_cylinder_iff_eq]
            exact cylinder_anti x H.1 Ax.some_mem.2
          have I3 : cylinder y (firstDiff x y) = cylinder Ay.some (firstDiff x y) := by
            rw [eq_comm, â† mem_cylinder_iff_eq]
            exact cylinder_anti y H.2 Ay.some_mem.2
          have : cylinder Ax.some (firstDiff x y) = cylinder Ay.some (firstDiff x y) := by
            rw [I1, I2, I3]
          rw [â† fx, â† fy, â† mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy] at this
          exact this","error:  simp made no progress
error:  type mismatch
  hâœ
has type
  â‹¯.choose âˆˆ s : Prop
but is expected to have type
  f y âˆˆ s : Prop
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress","theorem exists_lipschitz_retraction_of_isClosed {s : Set (âˆ€ n, E n)} (hs : IsClosed s)
    (hne : s.Nonempty) :
    âˆƒ f : (âˆ€ n, E n) â†’ âˆ€ n, E n, (âˆ€ x âˆˆ s, f x = x) âˆ§ range f = s âˆ§ LipschitzWith 1 f ",":= by
  set f := fun x => if x âˆˆ s then x else (inter_cylinder_longestPrefix_nonempty hs hne x).some
  have fs : âˆ€ x âˆˆ s, f x = x := fun x xs => by simp [f, xs]
  refine âŸ¨f, fs, ?_, ?_âŸ©
  Â· apply Subset.antisymm
    Â· rintro x âŸ¨y, rflâŸ©
      by_cases hy : y âˆˆ s
      Â· rwa [fs y hy]
      simpa [f, if_neg hy] using (inter_cylinder_longestPrefix_nonempty hs hne y).choose_spec.1
    Â· intro x hx
      rw [â† fs x hx]
      exact mem_range_self _
  Â· refine LipschitzWith.mk_one fun x y => ?_
    rcases eq_or_ne x y with (rfl | hxy)
    Â· simp
    rcases eq_or_ne (f x) (f y) with (h' | hfxfy)
    Â· simp [h', dist_nonneg]
    have I2 : cylinder x (firstDiff x y) = cylinder y (firstDiff x y) := by
      rw [â† mem_cylinder_iff_eq]
      apply mem_cylinder_firstDiff
    suffices firstDiff x y â‰¤ firstDiff (f x) (f y) by
      simpa [dist_eq_of_ne hxy, dist_eq_of_ne hfxfy]
    by_cases xs : x âˆˆ s
    Â· rw [fs x xs] at hfxfy âŠ¢
      by_cases ys : y âˆˆ s
      Â· rw [fs y ys]
      have A : (s âˆ© cylinder y (longestPrefix y s)).Nonempty :=
        inter_cylinder_longestPrefix_nonempty hs hne y
      have fy : f y = A.some := by simp_rw [f, if_neg ys]
      have I : cylinder A.some (firstDiff x y) = cylinder y (firstDiff x y) := by
        rw [â† mem_cylinder_iff_eq, firstDiff_comm]
        apply cylinder_anti y _ A.some_mem.2
        exact firstDiff_le_longestPrefix hs ys xs
      rwa [â† fy, â† I2, â† mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy.symm,
        firstDiff_comm _ x] at I
    Â· by_cases ys : y âˆˆ s
      Â· have A : (s âˆ© cylinder x (longestPrefix x s)).Nonempty :=
          inter_cylinder_longestPrefix_nonempty hs hne x
        have fx : f x = A.some := by simp_rw [f, if_neg xs]
        have I : cylinder A.some (firstDiff x y) = cylinder x (firstDiff x y) := by
          rw [â† mem_cylinder_iff_eq]
          apply cylinder_anti x _ A.some_mem.2
          apply firstDiff_le_longestPrefix hs xs ys
        rw [fs y ys] at hfxfy âŠ¢
        rwa [â† fx, I2, â† mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy] at I
      Â· have Ax : (s âˆ© cylinder x (longestPrefix x s)).Nonempty :=
          inter_cylinder_longestPrefix_nonempty hs hne x
        have fx : f x = Ax.some := by simp_rw [f, if_neg xs]
        have Ay : (s âˆ© cylinder y (longestPrefix y s)).Nonempty :=
          inter_cylinder_longestPrefix_nonempty hs hne y
        have fy : f y = Ay.some := by simp_rw [f, if_neg ys]
        by_cases H : longestPrefix x s < firstDiff x y âˆ¨ longestPrefix y s < firstDiff x y
        Â· have : cylinder x (longestPrefix x s) = cylinder y (longestPrefix y s) := by
            cases' H with H H
            Â· exact cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff hs hne H xs ys
            Â· symm
              rw [firstDiff_comm] at H
              exact cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff hs hne H ys xs
          rw [fx, fy] at hfxfy
          apply (hfxfy _).elim
          congr
        Â· push_neg at H
          have I1 : cylinder Ax.some (firstDiff x y) = cylinder x (firstDiff x y) := by
            rw [â† mem_cylinder_iff_eq]
            exact cylinder_anti x H.1 Ax.some_mem.2
          have I3 : cylinder y (firstDiff x y) = cylinder Ay.some (firstDiff x y) := by
            rw [eq_comm, â† mem_cylinder_iff_eq]
            exact cylinder_anti y H.2 Ay.some_mem.2
          have : cylinder Ax.some (firstDiff x y) = cylinder Ay.some (firstDiff x y) := by
            rw [I1, I2, I3]
          rw [â† fx, â† fy, â† mem_cylinder_iff_eq, mem_cylinder_iff_le_firstDiff hfxfy] at this
          exact this","rcases exists_lipschitz_retraction_of_isClosed hs hne hne with
  âŸ¨f, fs, fs_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz_retraction_of_lipschitz,"
Mathlib/Dynamics/PeriodicPts.lean,Function.periodicOrbit_apply_iterate_eq,periodicOrbit_apply_iterate_eq,0185583b06b06956b00d879ca9810cf6e8439166,":=
  Eq.symm <| Cycle.coe_eq_coe.2 <| .intro n <|
    List.ext_get (by simp [minimalPeriod_apply_iterate hx]) fun m _ _ â†¦ by
      simp [List.get_rotate, iterate_add_apply]","error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
f fa : Î± â†’ Î±
fb : Î² â†’ Î²
x y : Î±
mâœ nâœ : â„•
hx : x âˆˆ periodicPts f
n m : â„•
xâœÂ¹ : m < ((List.map (fun n â†¦ f^[n] x) (List.range (minimalPeriod f x))).rotate n).length
xâœ : m < (List.map (fun n_1 â†¦ f^[n_1] (f^[n] x)) (List.range (minimalPeriod f (f^[n] x)))).length
âŠ¢ ((List.map (fun n â†¦ f^[n] x) (List.range (minimalPeriod f x))).rotate n)[m] = f^[m] (f^[n] x)","theorem periodicOrbit_apply_iterate_eq (hx : x âˆˆ periodicPts f) (n : â„•) :
    periodicOrbit f (f^[n] x) = periodicOrbit f x ",":=
  Eq.symm <| Cycle.coe_eq_coe.2 <| .intro n <|
    List.ext_get (by simp [minimalPeriod_apply_iterate hx]) fun m _ _ â†¦ by
      simp [List.getElem_rotate, iterate_add_apply]",induction' n with n hn generalizing x n
Mathlib/NumberTheory/EllipticDivisibilitySequence.lean,normEDS_four,normEDS_four,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  erw [normEDS, Int.cast_one, one_mul, normEDS'_four]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â†‘1
R : Type u
S : Type v
instâœÂ¹ : CommRing R
instâœ : CommRing S
W : â„¤ â†’ R
f : R â†’+* S
b c d : R
âŠ¢ (preNormEDS (b ^ 4) c d 4 * if Even 4 then b else 1) = d * b",lemma normEDS_four : normEDS b c d 4 = d * b ,":= by
  erw [normEDS_ofNat, preNormEDS'_four, if_pos <| by decide]",rw [normEDS_four]
Mathlib/Analysis/Calculus/Taylor.lean,taylor_mean_remainder_lagrange,taylor_mean_remainder_lagrange,e5e7a3c38578dfab479b07cd58791d26d9ea89a8,":= by
  have gcont : ContinuousOn (fun t : â„ => (x - t) ^ (n + 1)) (Icc xâ‚€ x) := by
    refine' Continuous.continuousOn _
    exact (continuous_const.sub continuous_id').pow _ 
  have xy_ne : âˆ€ y : â„, y âˆˆ Ioo xâ‚€ x â†’ (x - y) ^ n â‰  0 := by
    intro y hy
    refine' pow_ne_zero _ _
    rw [mem_Ioo] at hy
    rw [sub_ne_zero]
    exact hy.2.ne'
  have hg' : âˆ€ y : â„, y âˆˆ Ioo xâ‚€ x â†’ -(â†‘n + 1) * (x - y) ^ n â‰  0 := fun y hy =>
    mul_ne_zero (neg_ne_zero.mpr (Nat.cast_add_one_ne_zero n)) (xy_ne y hy)
  rcases taylor_mean_remainder hx hf hf' gcont (fun y _ => monomial_has_deriv_aux y x _) hg' with
    âŸ¨y, hy, hâŸ©
  use y, hy
  simp only [sub_self, zero_pow, Ne.def, Nat.succ_ne_zero, not_false_iff, zero_sub, mul_neg] at h
  rw [h, neg_div, â† div_neg, neg_mul, neg_neg]
  field_simp [xy_ne y hy, Nat.factorial];  ring","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.136822 â†’ ?m.136822 â†’ Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  -?b / ?a
case right
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace â„ E
f : â„ â†’ â„
x xâ‚€ : â„
n : â„•
hx : xâ‚€ < x
hf : ContDiffOn â„ (â†‘n) f (Icc xâ‚€ x)
hf' : DifferentiableOn â„ (iteratedDerivWithin n f (Icc xâ‚€ x)) (Ioo xâ‚€ x)
gcont : ContinuousOn (fun t â†¦ (x - t) ^ (n + 1)) (Icc xâ‚€ x)
xy_ne : âˆ€ y âˆˆ Ioo xâ‚€ x, (x - y) ^ n â‰  0
hg' : âˆ€ y âˆˆ Ioo xâ‚€ x, -(â†‘n + 1) * (x - y) ^ n â‰  0
y : â„
hy : y âˆˆ Ioo xâ‚€ x
h :
  f x - taylorWithinEval f n (Icc xâ‚€ x) xâ‚€ x =
    ((x - y) ^ n / â†‘n ! * (0 ^ (n + 1) - (x - xâ‚€) ^ (n + 1)) / (-(â†‘n + 1) * (x - y) ^ n)) â€¢
      iteratedDerivWithin (n + 1) f (Icc xâ‚€ x) y
âŠ¢ ((x - y) ^ n / â†‘n ! * (0 ^ (n + 1) - (x - xâ‚€) ^ (n + 1)) / (-(â†‘n + 1) * (x - y) ^ n)) â€¢
      iteratedDerivWithin (n + 1) f (Icc xâ‚€ x) y =
    iteratedDerivWithin (n + 1) f (Icc xâ‚€ x) y * (x - xâ‚€) ^ (n + 1) / â†‘(n + 1)!","theorem taylor_mean_remainder_lagrange {f : â„ â†’ â„} {x xâ‚€ : â„} {n : â„•} (hx : xâ‚€ < x)
    (hf : ContDiffOn â„ n f (Icc xâ‚€ x))
    (hf' : DifferentiableOn â„ (iteratedDerivWithin n f (Icc xâ‚€ x)) (Ioo xâ‚€ x)) :
    âˆƒ x' âˆˆ Ioo xâ‚€ x, f x - taylorWithinEval f n (Icc xâ‚€ x) xâ‚€ x =
      iteratedDerivWithin (n + 1) f (Icc xâ‚€ x) x' * (x - xâ‚€) ^ (n + 1) / (n + 1)! ",":= by
  have gcont : ContinuousOn (fun t : â„ => (x - t) ^ (n + 1)) (Icc xâ‚€ x) := by fun_prop
  have xy_ne : âˆ€ y : â„, y âˆˆ Ioo xâ‚€ x â†’ (x - y) ^ n â‰  0 := by
    intro y hy
    refine pow_ne_zero _ ?_
    rw [mem_Ioo] at hy
    rw [sub_ne_zero]
    exact hy.2.ne'
  have hg' : âˆ€ y : â„, y âˆˆ Ioo xâ‚€ x â†’ -(â†‘n + 1) * (x - y) ^ n â‰  0 := fun y hy =>
    mul_ne_zero (neg_ne_zero.mpr (Nat.cast_add_one_ne_zero n)) (xy_ne y hy)
  rcases taylor_mean_remainder hx hf hf' gcont (fun y _ => monomial_has_deriv_aux y x _) hg' with
    âŸ¨y, hy, hâŸ©
  use y, hy
  simp only [sub_self, zero_pow, Ne, Nat.succ_ne_zero, not_false_iff, zero_sub, mul_neg] at h
  rw [h, neg_div, â† div_neg, neg_mul, neg_neg]
  field_simp [xy_ne y hy, Nat.factorial]; ring","rcases exists_mem_Ioo_of_differentiableWithinAt_Icc_of_le hx hf.differentiableWithinAt
  hf' hf' hf'"
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,affineSpan_pair_le_of_mem_of_mem,affineSpan_pair_le_of_mem_of_mem,5068808d2b4c25cf905cf7fee10ded8e447c2346,":= by
  rw [affineSpan_le, Set.insert_subset, Set.singleton_subset_iff]
  exact âŸ¨hpâ‚, hpâ‚‚âŸ©","error:  tactic 'rewrite' failed, equality or iff proof expected
  ?a âˆˆ ?m.379528
k : Type u_1
V : Type u_2
P : Type u_3
instâœÂ³ : Ring k
instâœÂ² : AddCommGroup V
instâœÂ¹ : Module k V
instâœ : AffineSpace V P
Î¹ : Type u_4
pâ‚ pâ‚‚ : P
s : AffineSubspace k P
hpâ‚ : pâ‚ âˆˆ s
hpâ‚‚ : pâ‚‚ âˆˆ s
âŠ¢ {pâ‚, pâ‚‚} âŠ† â†‘s
warning:  @AffineSubspace.Parallel does not have a doc string","theorem affineSpan_pair_le_of_mem_of_mem {pâ‚ pâ‚‚ : P} {s : AffineSubspace k P} (hpâ‚ : pâ‚ âˆˆ s)
    (hpâ‚‚ : pâ‚‚ âˆˆ s) : line[k, pâ‚, pâ‚‚] â‰¤ s ",":= by
  rw [affineSpan_le, Set.insert_subset_iff, Set.singleton_subset_iff]
  exact âŸ¨hpâ‚, hpâ‚‚âŸ©","rw [line[k, pâ‚, pâ‚‚]]"
Mathlib/Analysis/Complex/Hadamard.lean,Complex.HadamardThreeLines.norm_le_interp_of_mem_verticalClosedStrip',norm_le_interp_of_mem_verticalClosedStrip',83acd4ef0d51cf6d0371c1664c9efdd31712f671,":= by
  have : â€–interpStrip f zâ€– â‰¤ (sSupNormIm f 0) ^ (1 - z.re) * (sSupNormIm f 1) ^ z.re := by
    by_cases h : sSupNormIm f 0 = 0 âˆ¨ sSupNormIm f 1 = 0
    Â· rw [interpStrip_eq_of_zero f z h, norm_zero, mul_nonneg_iff]
      left
      exact âŸ¨Real.rpow_nonneg (sSupNormIm_nonneg f _) _,
        Real.rpow_nonneg (sSupNormIm_nonneg f _) _ âŸ©
    Â· push_neg at h
      rcases h with âŸ¨h0, h1âŸ©
      rw [ne_comm] at h0 h1
      simp_rw [interpStrip_eq_of_pos f _ (lt_of_le_of_ne (sSupNormIm_nonneg f 0) h0)
        (lt_of_le_of_ne (sSupNormIm_nonneg f 1) h1)]
      simp only [norm_eq_abs, map_mul]
      rw [abs_cpow_eq_rpow_re_of_pos ((Ne.le_iff_lt h0).mp (sSupNormIm_nonneg f _)) _]
      rw [abs_cpow_eq_rpow_re_of_pos ((Ne.le_iff_lt h1).mp (sSupNormIm_nonneg f _)) _]
      simp only [sub_re, one_re, le_refl]
  apply (norm_le_interpStrip_of_mem_verticalClosedStrip f hz hd hB).trans (this.trans _)
  apply mul_le_mul_of_le_of_le_of_nonneg_of_nonneg _ _ (Real.rpow_nonneg (sSupNormIm_nonneg f _) _)
  Â· apply (Real.rpow_nonneg _ _)
    specialize hb 1
    simp only [mem_preimage, one_re, mem_singleton_iff, forall_true_left] at hb
    exact (norm_nonneg _).trans hb
  Â· apply Real.rpow_le_rpow (sSupNormIm_nonneg f _) _ (sub_nonneg.mpr hz.2)
    Â· rw [sSupNormIm]
      apply csSup_le _
      Â· simpa [comp_apply, mem_image, forall_exists_index,
          and_imp, forall_apply_eq_imp_iffâ‚‚] using ha
      Â· use â€–(f 0)â€–, 0
        simp only [mem_preimage, zero_re, mem_singleton_iff, comp_apply,
          and_self]
  Â· apply Real.rpow_le_rpow (sSupNormIm_nonneg f _) _ hz.1
    Â· rw [sSupNormIm]
      apply csSup_le _
      Â· simpa [comp_apply, mem_image, forall_exists_index,
          and_imp, forall_apply_eq_imp_iffâ‚‚] using hb
      Â· use â€–(f 1)â€–, 1
        simp only [mem_preimage, one_re, mem_singleton_iff, comp_apply,
          and_self]",error:  unknown identifier 'mul_le_mul_of_le_of_le_of_nonneg_of_nonneg',"lemma norm_le_interp_of_mem_verticalClosedStrip' (f : â„‚ â†’ E) {z : â„‚} {a b : â„}
    (hz : z âˆˆ verticalClosedStrip 0 1) (hd : DiffContOnCl â„‚ f (verticalStrip 0 1))
    (hB : BddAbove ((norm âˆ˜ f) '' (verticalClosedStrip 0 1)))
    (ha : âˆ€ z âˆˆ re â»Â¹' {0}, â€–f zâ€– â‰¤ a) (hb : âˆ€ z âˆˆ re â»Â¹' {1}, â€–f zâ€– â‰¤ b) :
    â€–f zâ€– â‰¤ a ^ (1 - z.re) * b ^ z.re ",":= by
  have : â€–interpStrip f zâ€– â‰¤ (sSupNormIm f 0) ^ (1 - z.re) * (sSupNormIm f 1) ^ z.re := by
    by_cases h : sSupNormIm f 0 = 0 âˆ¨ sSupNormIm f 1 = 0
    Â· rw [interpStrip_eq_of_zero f z h, norm_zero, mul_nonneg_iff]
      left
      exact âŸ¨Real.rpow_nonneg (sSupNormIm_nonneg f _) _,
        Real.rpow_nonneg (sSupNormIm_nonneg f _) _ âŸ©
    Â· push_neg at h
      rcases h with âŸ¨h0, h1âŸ©
      rw [ne_comm] at h0 h1
      simp_rw [interpStrip_eq_of_pos f _ (lt_of_le_of_ne (sSupNormIm_nonneg f 0) h0)
        (lt_of_le_of_ne (sSupNormIm_nonneg f 1) h1)]
      simp only [norm_eq_abs, map_mul]
      rw [abs_cpow_eq_rpow_re_of_pos ((Ne.le_iff_lt h0).mp (sSupNormIm_nonneg f _)) _]
      rw [abs_cpow_eq_rpow_re_of_pos ((Ne.le_iff_lt h1).mp (sSupNormIm_nonneg f _)) _]
      simp only [sub_re, one_re, le_refl]
  apply (norm_le_interpStrip_of_mem_verticalClosedStrip f hz hd hB).trans (this.trans _)
  apply mul_le_mul_of_le_of_le _ _ (Real.rpow_nonneg (sSupNormIm_nonneg f _) _)
  Â· apply (Real.rpow_nonneg _ _)
    specialize hb 1
    simp only [mem_preimage, one_re, mem_singleton_iff, forall_true_left] at hb
    exact (norm_nonneg _).trans hb
  Â· apply Real.rpow_le_rpow (sSupNormIm_nonneg f _) _ (sub_nonneg.mpr hz.2)
    Â· rw [sSupNormIm]
      apply csSup_le _
      Â· simpa [comp_apply, mem_image, forall_exists_index,
          and_imp, forall_apply_eq_imp_iffâ‚‚] using ha
      Â· use â€–(f 0)â€–, 0
        simp only [mem_preimage, zero_re, mem_singleton_iff, comp_apply,
          and_self]
  Â· apply Real.rpow_le_rpow (sSupNormIm_nonneg f _) _ hz.1
    Â· rw [sSupNormIm]
      apply csSup_le _
      Â· simpa [comp_apply, mem_image, forall_exists_index,
          and_imp, forall_apply_eq_imp_iffâ‚‚] using hb
      Â· use â€–(f 1)â€–, 1
        simp only [mem_preimage, one_re, mem_singleton_iff, comp_apply,
          and_self]","simp only [mem_preimage, mem_singleton_iff, norm_le_interp_of_mem_verticalClosedStrip,
  norm_le_interp_of_mem_verticalClosedStrip']"
Mathlib/LinearAlgebra/Orientation.lean,Orientation.eq_or_eq_neg,eq_or_eq_neg,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' o with x hx
  dsimp [positiveOrientation]
  simp only [ray_eq_iff, sameRay_neg_swap]
  rw [sameRay_or_sameRay_neg_iff_not_linearIndependent]
  intro h
  set f : (M [â‹€^Î¹]â†’â‚—[R] R) â‰ƒâ‚—[R] R := AlternatingMap.constLinearEquivOfIsEmpty.symm
  have H : LinearIndependent R ![f x, 1] := by
    convert h.map' f.toLinearMap f.ker
    ext i
    fin_cases i <;> simp [f]
  rw [linearIndependent_iff'] at H
  simpa using H Finset.univ ![1, -f x] (by simp [Fin.sum_univ_succ]) 0 (by simp)","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
R : Type u_1
instâœÂ³ : LinearOrderedCommRing R
M : Type u_2
instâœÂ² : AddCommGroup M
instâœÂ¹ : Module R M
Î¹ : Type u_3
instâœ : IsEmpty Î¹
o : Orientation R M Î¹
âŠ¢ o = positiveOrientation âˆ¨ o = -positiveOrientation","theorem eq_or_eq_neg_of_isEmpty [IsEmpty Î¹] (o : Orientation R M Î¹) :
    o = positiveOrientation âˆ¨ o = -positiveOrientation ",":= by
  induction' o using Module.Ray.ind with x hx
  dsimp [positiveOrientation]
  simp only [ray_eq_iff, sameRay_neg_swap]
  rw [sameRay_or_sameRay_neg_iff_not_linearIndependent]
  intro h
  set f : (M [â‹€^Î¹]â†’â‚—[R] R) â‰ƒâ‚—[R] R := AlternatingMap.constLinearEquivOfIsEmpty.symm
  have H : LinearIndependent R ![f x, 1] := by
    convert h.map' f.toLinearMap f.ker
    ext i
    fin_cases i <;> simp [f]
  rw [linearIndependent_iff'] at H
  simpa using H Finset.univ ![1, -f x] (by simp [Fin.sum_univ_succ]) 0 (by simp)",cases' eq_or_eq_neg_of_isEmpty Î¹ with eq_or_eq_neg_of_isEmpty
Mathlib/MeasureTheory/Measure/AddContent.lean,MeasureTheory.addContent_union',addContent_union',26c29dc27c999d53a30ed03b6e655c799e1675d8,":= by
  by_cases hs_empty : s = âˆ…
  Â· simp only [hs_empty, Set.empty_union, addContent_empty, zero_add]
  classical
  have h := addContent_sUnion (m := m) (I := {s, t}) ?_ ?_ ?_
  rotate_left
  Â· simp only [coe_pair, Set.insert_subset_iff, hs, ht, Set.singleton_subset_iff, and_self_iff]
  Â· simp only [coe_pair, Set.pairwiseDisjoint_insert, pairwiseDisjoint_singleton,
      mem_singleton_iff, Ne.def, id.def, forall_eq, true_and_iff]
    exact fun _ â†¦ h_dis
  Â· simp only [coe_pair, sUnion_insert, sUnion_singleton]
    exact hst
  convert h
  Â· simp only [coe_pair, sUnion_insert, sUnion_singleton]
  Â· rw [sum_insert, sum_singleton]
    simp only [Finset.mem_singleton]
    refine fun hs_eq_t â†¦ hs_empty ?_
    rw [â† hs_eq_t] at h_dis
    exact Disjoint.eq_bot_of_self h_dis","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.6002 â†’ ?m.6002 â†’ Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.6006 â†’ ?m.6006","lemma addContent_union' (hs : s âˆˆ C) (ht : t âˆˆ C) (hst : s âˆª t âˆˆ C) (h_dis : Disjoint s t) :
    m (s âˆª t) = m s + m t ",":= by
  by_cases hs_empty : s = âˆ…
  Â· simp only [hs_empty, Set.empty_union, addContent_empty, zero_add]
  classical
  have h := addContent_sUnion (m := m) (I := {s, t}) ?_ ?_ ?_
  rotate_left
  Â· simp only [coe_pair, Set.insert_subset_iff, hs, ht, Set.singleton_subset_iff, and_self_iff]
  Â· simp only [coe_pair, Set.pairwiseDisjoint_insert, pairwiseDisjoint_singleton,
      mem_singleton_iff, Ne, id, forall_eq, true_and_iff]
    exact fun _ => h_dis
  Â· simp only [coe_pair, sUnion_insert, sUnion_singleton]
    exact hst
  convert h
  Â· simp only [coe_pair, sUnion_insert, sUnion_singleton]
  Â· rw [sum_insert, sum_singleton]
    simp only [Finset.mem_singleton]
    refine fun hs_eq_t => hs_empty ?_
    rw [â† hs_eq_t] at h_dis
    exact Disjoint.eq_bot_of_self h_dis","rw [â† mem_union, â† mem_union, â† mem_union, â† mem_union, â† mem_union]"
Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean,WeierstrassCurve.Jacobian.equiv_some_of_Z_ne_zero,equiv_some_of_Z_ne_zero,b999f5fc5a622c176ec2ff740c2226c15d01d750,":=
  âŸ¨Units.mk0 _ hPz, by simp [smul_fin3, â† fin3_def P, mul_div_cancel' _ <| pow_ne_zero _ hPz]âŸ©","warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancelâ‚€` instead
error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information","lemma equiv_some_of_Z_ne_zero {P : Fin 3 â†’ F} (hPz : P z â‰  0) :
    P â‰ˆ ![P x / P z ^ 2, P y / P z ^ 3, 1] ",":=
  equiv_of_X_eq_of_Y_eq hPz one_ne_zero
    (by linear_combination (norm := (matrix_simp; ring1)) -P x * div_self (pow_ne_zero 2 hPz))
    (by linear_combination (norm := (matrix_simp; ring1)) -P y * div_self (pow_ne_zero 3 hPz))",simp only [equiv_some_of_Z_ne_zero]
Mathlib/Algebra/DirectSum/Decomposition.lean,DirectSum.decompose_lhom_ext,decompose_lhom_ext,b071b57a84e9970e988d47cb1622531297757a79,":=
  LinearMap.ext <| (decomposeLinearEquiv â„³).symm.surjective.forall.mpr <|
    suffices f âˆ˜â‚— (decomposeLinearEquiv â„³).symm
           = (g âˆ˜â‚— (decomposeLinearEquiv â„³).symm : (â¨ i, â„³ i) â†’â‚—[R] N) from
      FunLike.congr_fun this
    linearMap_ext _ fun i => by
      simp_rw [LinearMap.comp_assoc, decomposeLinearEquiv_symm_comp_lof â„³ i, h]",error:  unknown constant 'FunLike.congr_fun',"theorem decompose_lhom_ext {N} [AddCommMonoid N] [Module R N] â¦ƒf g : M â†’â‚—[R] Nâ¦„
    (h : âˆ€ i, f âˆ˜â‚— (â„³ i).subtype = g âˆ˜â‚— (â„³ i).subtype) : f = g ",":=
  LinearMap.ext <| (decomposeLinearEquiv â„³).symm.surjective.forall.mpr <|
    suffices f âˆ˜â‚— (decomposeLinearEquiv â„³).symm
           = (g âˆ˜â‚— (decomposeLinearEquiv â„³).symm : (â¨ i, â„³ i) â†’â‚—[R] N) from
      DFunLike.congr_fun this
    linearMap_ext _ fun i => by
      simp_rw [LinearMap.comp_assoc, decomposeLinearEquiv_symm_comp_lof â„³ i, h]",apply Submodule.ext_of_linear_subtype
Mathlib/Algebra/Lie/Weights/Basic.lean,LieModule.isCompl_weightSpace_zero_posFittingComp,isCompl_weightSpace_zero_posFittingComp,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  set Mâ‚€ := weightSpace M (0 : L â†’ R)
  set Mâ‚ := posFittingComp R L M
  rcases forall_or_exists_not (fun (x : L) â†¦ weightSpaceOf M (0 : R) x = âŠ¤)
    with h | âŸ¨x, hx : weightSpaceOf M (0 : R) x â‰  âŠ¤âŸ©
  Â· suffices IsNilpotent R L M by simp [isCompl_top_bot]
    replace h : Mâ‚€ = âŠ¤ := by simpa [weightSpace]
    rw [â† LieModule.isNilpotent_of_top_iff', â† h]
    infer_instance
  Â· set Mâ‚€â‚“ := weightSpaceOf M (0 : R) x
    set Mâ‚â‚“ := posFittingCompOf R M x
    set Mâ‚€â‚“â‚€ := weightSpace Mâ‚€â‚“ (0 : L â†’ R)
    set Mâ‚€â‚“â‚ := posFittingComp R L Mâ‚€â‚“
    have hâ‚€ : Function.Injective (LieSubmodule.incl Mâ‚€â‚“) := Subtype.coe_injective
    have hâ‚ : IsCompl Mâ‚€â‚“ Mâ‚â‚“ := isCompl_weightSpaceOf_zero_posFittingCompOf R L M x
    have hâ‚‚ : IsCompl Mâ‚€â‚“â‚€ Mâ‚€â‚“â‚ := h Mâ‚€â‚“ hx.lt_top
    have hâ‚ƒ : Mâ‚€â‚“â‚€.map Mâ‚€â‚“.incl = Mâ‚€ := by
      rw [map_weightSpace_eq_of_injective hâ‚€, inf_eq_left, LieSubmodule.range_incl]
      exact iInf_le _ x
    have hâ‚„ : Mâ‚€â‚“â‚.map Mâ‚€â‚“.incl âŠ” Mâ‚â‚“ = Mâ‚ := by
      apply le_antisymm <| sup_le_iff.mpr
        âŸ¨map_posFittingComp_le _, posFittingCompOf_le_posFittingComp R L M xâŸ©
      rw [â† posFittingComp_map_incl_sup_of_codisjoint hâ‚.codisjoint]
      exact sup_le_sup_left LieSubmodule.map_incl_le _
    rw [â† hâ‚ƒ, â† hâ‚„]
    apply Disjoint.isCompl_sup_right_of_isCompl_sup_left
    Â· rw [disjoint_iff, â† LieSubmodule.map_inf hâ‚€, hâ‚‚.inf_eq_bot, LieSubmodule.map_bot]
    Â· rwa [â† LieSubmodule.map_sup, hâ‚‚.sup_eq_top, LieModuleHom.map_top, LieSubmodule.range_incl]","error:  simp made no progress
error:  tactic 'assumption' failed
K : Type u_1
R : Type u_2
L : Type u_3
M : Type u_4
instâœâ¹ : CommRing R
instâœâ¸ : LieRing L
instâœâ· : LieAlgebra R L
instâœâ¶ : LieAlgebra.IsNilpotent R L
instâœâµ : AddCommGroup M
instâœâ´ : Module R M
instâœÂ³ : LieRingModule L M
instâœÂ² : LieModule R L M
instâœÂ¹ : IsNoetherian R M
instâœ : IsArtinian R M
hâœ : âˆ€ N < âŠ¤, IsCompl (weightSpace (â†¥â†‘N) 0) (posFittingComp R L â†¥â†‘N)
Mâ‚€ : LieSubmodule R L M := weightSpace M 0
Mâ‚ : LieSubmodule R L M := posFittingComp R L M
h : âˆ€ (a : L), weightSpaceOf M 0 a = âŠ¤
âŠ¢ Mâ‚€ = âŠ¤","lemma isCompl_weightSpace_zero_posFittingComp_aux
    (h : âˆ€ N < (âŠ¤ : LieSubmodule R L M), IsCompl (weightSpace N 0) (posFittingComp R L N)) :
    IsCompl (weightSpace M 0) (posFittingComp R L M) ",":= by
  set Mâ‚€ := weightSpace M (0 : L â†’ R)
  set Mâ‚ := posFittingComp R L M
  rcases forall_or_exists_not (fun (x : L) â†¦ weightSpaceOf M (0 : R) x = âŠ¤)
    with h | âŸ¨x, hx : weightSpaceOf M (0 : R) x â‰  âŠ¤âŸ©
  Â· suffices IsNilpotent R L M by simp [Mâ‚€, Mâ‚, isCompl_top_bot]
    replace h : Mâ‚€ = âŠ¤ := by simpa [Mâ‚€, weightSpace]
    rw [â† LieModule.isNilpotent_of_top_iff', â† h]
    infer_instance
  Â· set Mâ‚€â‚“ := weightSpaceOf M (0 : R) x
    set Mâ‚â‚“ := posFittingCompOf R M x
    set Mâ‚€â‚“â‚€ := weightSpace Mâ‚€â‚“ (0 : L â†’ R)
    set Mâ‚€â‚“â‚ := posFittingComp R L Mâ‚€â‚“
    have hâ‚ : IsCompl Mâ‚€â‚“ Mâ‚â‚“ := isCompl_weightSpaceOf_zero_posFittingCompOf R L M x
    have hâ‚‚ : IsCompl Mâ‚€â‚“â‚€ Mâ‚€â‚“â‚ := h Mâ‚€â‚“ hx.lt_top
    have hâ‚ƒ : Mâ‚€â‚“â‚€.map Mâ‚€â‚“.incl = Mâ‚€ := by
      rw [map_weightSpace_eq_of_injective Mâ‚€â‚“.injective_incl, inf_eq_left, LieSubmodule.range_incl]
      exact iInf_le _ x
    have hâ‚„ : Mâ‚€â‚“â‚.map Mâ‚€â‚“.incl âŠ” Mâ‚â‚“ = Mâ‚ := by
      apply le_antisymm <| sup_le_iff.mpr
        âŸ¨map_posFittingComp_le _, posFittingCompOf_le_posFittingComp R L M xâŸ©
      rw [â† posFittingComp_map_incl_sup_of_codisjoint hâ‚.codisjoint]
      exact sup_le_sup_left LieSubmodule.map_incl_le _
    rw [â† hâ‚ƒ, â† hâ‚„]
    apply Disjoint.isCompl_sup_right_of_isCompl_sup_left
    Â· rw [disjoint_iff, â† LieSubmodule.map_inf Mâ‚€â‚“.injective_incl, hâ‚‚.inf_eq_bot,
        LieSubmodule.map_bot]
    Â· rwa [â† LieSubmodule.map_sup, hâ‚‚.sup_eq_top, LieModuleHom.map_top, LieSubmodule.range_incl]",exact isCompl_weightSpace_zero_posFittingComp_aux isCompl_weightSpace_zero_posFittingComp_aux
Mathlib/ModelTheory/Satisfiability.lean,FirstOrder.Language.Theory.models_iff_not_satisfiable,models_iff_not_satisfiable,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rw [models_sentence_iff, IsSatisfiable]
  refine
    âŸ¨fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T âˆª {Formula.not Ï†})
          (Set.subset_union_right _ _ (Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel (Set.subset_union_left _ _))),
      fun h M => ?_âŸ©
  contrapose! h
  rw [â† Sentence.realize_not] at h
  refine'
    âŸ¨{  Carrier := M
        is_model := âŸ¨fun Ïˆ hÏˆ => hÏˆ.elim (realize_sentence_of_mem _) fun h' => _âŸ© }âŸ©
  rw [Set.mem_singleton_iff.1 h']
  exact h","warning:  @ModelsBoundedFormula does not have a doc string
error:  function expected at
  Set.subset_union_right ?m.33716
term has type
  ?m.33715 âˆˆ ?m.33713 âˆª ?m.33714
error:  function expected at
  Set.subset_union_left ?m.33942
term has type
  ?m.33941 âˆˆ ?m.33939 âˆª ?m.33940",theorem models_iff_not_satisfiable (Ï† : L.Sentence) : T âŠ¨áµ‡ Ï† â†” Â¬IsSatisfiable (T âˆª {Ï†.not}) ,":= by
  rw [models_sentence_iff, IsSatisfiable]
  refine
    âŸ¨fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T âˆª {Formula.not Ï†})
          (Set.subset_union_right (Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel Set.subset_union_left)),
      fun h M => ?_âŸ©
  contrapose! h
  rw [â† Sentence.realize_not] at h
  refine
    âŸ¨{  Carrier := M
        is_model := âŸ¨fun Ïˆ hÏˆ => hÏˆ.elim (realize_sentence_of_mem _) fun h' => ?_âŸ© }âŸ©
  rw [Set.mem_singleton_iff.1 h']
  exact h","refine âŸ¨fun h => ?_, fun h => ?_âŸ©"
Mathlib/LinearAlgebra/Matrix/Spectrum.lean,Matrix.IsHermitian.rank_eq_rank_diagonal,rank_eq_rank_diagonal,aaa7a79ed9b6aeb68b9146319b3798dfc6cbf05e,":= by
  conv_lhs => rw [hA.spectral_theorem2]
  have hG : (hA.eigenvectorUnitary.1) * (star (hA.eigenvectorUnitary.1)) = 1 := by
          simp only [hA.eigenvectorUnitary.2, unitary.mul_star_self_of_mem]
  have hE := isUnit_det_of_right_inverse hG
  have hE1 := isUnit_det_of_left_inverse hG
  simp only [rank_mul_eq_right_of_isUnit_det (A := hA.eigenvectorUnitary.1)
      (B := star (hA.eigenvectorUnitary.1)) hE, rank_mul_eq_left_of_isUnit_det
      (B := hA.eigenvectorUnitary.1) (A := star (hA.eigenvectorUnitary.1)) hE1,
      rank_diagonal, Function.comp_apply, ne_eq, algebraMap.lift_map_eq_zero_iff]
  sorry ","error:  invalid field 'spectral_theorem2', the environment does not contain 'Matrix.IsHermitian.spectral_theorem2'
  hA
has type
  A.IsHermitian
error:  invalid field 'spectral_theorem2', the environment does not contain 'Eq.spectral_theorem2'
  hA
has type
  Aá´´ = A
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.98289
ğ•œ : Type u_1
instâœÂ² : RCLike ğ•œ
n : Type u_2
instâœÂ¹ : Fintype n
A : Matrix n n ğ•œ
instâœ : DecidableEq n
hA : A.IsHermitian
| A.rank",lemma rank_eq_rank_diagonal : A.rank = (Matrix.diagonal hA.eigenvalues).rank ,":= by
  conv_lhs => rw [hA.spectral_theorem, â† unitary.coe_star]
  simp [-isUnit_iff_ne_zero, -unitary.coe_star, rank_diagonal]",rw [rank_eq_rank_diagonal]
Mathlib/Algebra/Homology/ShortComplex/Preadditive.lean,CategoryTheory.ShortComplex.homologyMap_sub,homologyMap_sub,9072ff84a0d139a344bf9eed4a00c4cd27596c79,:=,error:  unexpected token 'end'; expected term,lemma homologyMap_sub : homologyMap (Ï† - Ï†') = homologyMap Ï† - homologyMap Ï†' ,":=
  homologyMap'_sub _ _","rw [homologyMap_sub, homologyMap_sub]"
Mathlib/Analysis/Convex/Integral.lean,ae_eq_const_or_norm_average_lt_of_norm_le_const,ae_eq_const_or_norm_average_lt_of_norm_le_const,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  rcases le_or_lt C 0 with hC0 | hC0
  Â· have : f =áµ[Î¼] 0 := h_le.mono fun x hx => norm_le_zero_iff.1 (hx.trans hC0)
    simp only [average_congr this, Pi.zero_apply, average_zero]
    exact Or.inl this
  by_cases hfi : Integrable f Î¼; swap
  Â· simp [average_eq, integral_undef hfi, hC0, ENNReal.toReal_pos_iff]
  rcases (le_top : Î¼ univ â‰¤ âˆ).eq_or_lt with hÎ¼t | hÎ¼t; Â· simp [average_eq, hÎ¼t, hC0]
  haveI : IsFiniteMeasure Î¼ := âŸ¨hÎ¼tâŸ©
  replace h_le : âˆ€áµ x âˆ‚Î¼, f x âˆˆ closedBall (0 : E) C; Â· simpa only [mem_closedBall_zero_iff]
  simpa only [interior_closedBall _ hC0.ne', mem_ball_zero_iff] using
    (strictConvex_closedBall â„ (0 : E) C).ae_eq_const_or_average_mem_interior isClosed_ball h_le
      hfi","error:  unexpected token ';'; expected '|'
error:  unsolved goals
case pos.inr
Î± : Type u_1
E : Type u_2
F : Type u_3
m0 : MeasurableSpace Î±
instâœâ¶ : NormedAddCommGroup E
instâœâµ : NormedSpace â„ E
instâœâ´ : CompleteSpace E
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : NormedSpace â„ F
instâœÂ¹ : CompleteSpace F
Î¼ : Measure Î±
s : Set E
t : Set Î±
f : Î± â†’ E
g : E â†’ â„
C : â„
instâœ : StrictConvexSpace â„ E
hC0 : 0 < C
hfi : Integrable f Î¼
hÎ¼t : Î¼ univ < âŠ¤
this : IsFiniteMeasure Î¼
h_le : âˆ€áµ (x : Î±) âˆ‚Î¼, f x âˆˆ closedBall 0 C
âŠ¢ f =á¶ [ae Î¼] const Î± (â¨ (x : Î±), f x âˆ‚Î¼) âˆ¨ â€–â¨ (x : Î±), f x âˆ‚Î¼â€– < C","theorem ae_eq_const_or_norm_average_lt_of_norm_le_const [StrictConvexSpace â„ E]
    (h_le : âˆ€áµ x âˆ‚Î¼, â€–f xâ€– â‰¤ C) : f =áµ[Î¼] const Î± (â¨ x, f x âˆ‚Î¼) âˆ¨ â€–â¨ x, f x âˆ‚Î¼â€– < C ",":= by
  rcases le_or_lt C 0 with hC0 | hC0
  Â· have : f =áµ[Î¼] 0 := h_le.mono fun x hx => norm_le_zero_iff.1 (hx.trans hC0)
    simp only [average_congr this, Pi.zero_apply, average_zero]
    exact Or.inl this
  by_cases hfi : Integrable f Î¼; swap
  Â· simp [average_eq, integral_undef hfi, hC0, ENNReal.toReal_pos_iff]
  rcases (le_top : Î¼ univ â‰¤ âˆ).eq_or_lt with hÎ¼t | hÎ¼t; Â· simp [average_eq, hÎ¼t, hC0]
  haveI : IsFiniteMeasure Î¼ := âŸ¨hÎ¼tâŸ©
  replace h_le : âˆ€áµ x âˆ‚Î¼, f x âˆˆ closedBall (0 : E) C := by simpa only [mem_closedBall_zero_iff]
  simpa only [interior_closedBall _ hC0.ne', mem_ball_zero_iff] using
    (strictConvex_closedBall â„ (0 : E) C).ae_eq_const_or_average_mem_interior isClosed_ball h_le
      hfi",simp only [norm_average_lt_of_norm_average_lt_of_norm_average_lt_of_norm_average_lt_of_norm_average_lt_of_norm_average_lt_of]
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.unifIntegrable_of',unifIntegrable_of',66c0098b0b62ad14d9c618b402e7673658137a7e,":= by
  have hpzero := (lt_of_lt_of_le zero_lt_one hp).ne.symm
  by_cases hÎ¼ : Î¼ Set.univ = 0
  Â· rw [Measure.measure_univ_eq_zero] at hÎ¼
    exact hÎ¼.symm â–¸ unifIntegrable_zero_meas
  intro Îµ hÎµ
  obtain âŸ¨C, hCpos, hCâŸ© := h (Îµ / 2) (half_pos hÎµ)
  refine' âŸ¨(Îµ / (2 * C)) ^ ENNReal.toReal p,
    Real.rpow_pos_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos))) _,
    fun i s hs hÎ¼s => _âŸ©
  by_cases hÎ¼s' : Î¼ s = 0
  Â· rw [(snorm_eq_zero_iff ((hf i).indicator hs).aestronglyMeasurable hpzero).2
        (indicator_meas_zero hÎ¼s')]
    norm_num
  calc
    snorm (Set.indicator s (f i)) p Î¼ â‰¤
        snorm (Set.indicator (s âˆ© { x | C â‰¤ â€–f i xâ€–â‚Š }) (f i)) p Î¼ +
          snorm (Set.indicator (s âˆ© { x | â€–f i xâ€–â‚Š < C }) (f i)) p Î¼ := by
      refine' le_trans (Eq.le _) (snorm_add_le
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter (stronglyMeasurable_const.measurableSet_le (hf i).nnnorm))))
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter ((hf i).nnnorm.measurableSet_lt stronglyMeasurable_const))))
        hp)
      congr
      change _ = fun x => (s âˆ© { x : Î± | C â‰¤ â€–f i xâ€–â‚Š }).indicator (f i) x +
        (s âˆ© { x : Î± | â€–f i xâ€–â‚Š < C }).indicator (f i) x
      rw [â† Set.indicator_union_of_disjoint]
      Â· congr
        rw [â† Set.inter_union_distrib_left, (by ext; simp [le_or_lt] :
            { x : Î± | C â‰¤ â€–f i xâ€–â‚Š } âˆª { x : Î± | â€–f i xâ€–â‚Š < C } = Set.univ),
          Set.inter_univ]
      Â· refine' (Disjoint.inf_right' _ _).inf_left' _
        rw [disjoint_iff_inf_le]
        rintro x âŸ¨hxâ‚, hxâ‚‚âŸ©
        rw [Set.mem_setOf_eq] at hxâ‚ hxâ‚‚
        exact False.elim (hxâ‚‚.ne (eq_of_le_of_not_lt hxâ‚ (not_lt.2 hxâ‚‚.le)).symm)
    _ â‰¤ snorm (Set.indicator { x | C â‰¤ â€–f i xâ€–â‚Š } (f i)) p Î¼ +
        (C : â„â‰¥0âˆ) * Î¼ s ^ (1 / ENNReal.toReal p) := by
      refine' add_le_add
        (snorm_mono fun x => norm_indicator_le_of_subset (Set.inter_subset_right _ _) _ _) _
      rw [â† Set.indicator_indicator]
      rw [snorm_indicator_eq_snorm_restrict hs]
      have : âˆ€áµ x âˆ‚Î¼.restrict s, â€–{ x : Î± | â€–f i xâ€–â‚Š < C }.indicator (f i) xâ€– â‰¤ C := by
        refine' ae_of_all _ _
        simp_rw [norm_indicator_eq_indicator_norm]
        exact Set.indicator_le' (fun x (hx : _ < _) => hx.le) fun _ _ => NNReal.coe_nonneg _
      refine' le_trans (snorm_le_of_ae_bound this) _
      rw [mul_comm, Measure.restrict_apply' hs, Set.univ_inter, ENNReal.ofReal_coe_nnreal, one_div]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + C * ENNReal.ofReal (Îµ / (2 * C)) := by
      refine' add_le_add (hC i) (mul_le_mul_left' _ _)
      rwa [ENNReal.rpow_one_div_le_iff (ENNReal.toReal_pos hpzero hp'),
        ENNReal.ofReal_rpow_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos)))]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + ENNReal.ofReal (Îµ / 2) := by
      refine' add_le_add_left _ _
      rw [â† ENNReal.ofReal_coe_nnreal, â† ENNReal.ofReal_mul (NNReal.coe_nonneg _), â† div_div,
        mul_div_cancel' _ (NNReal.coe_pos.2 hCpos).ne.symm]
    _ â‰¤ ENNReal.ofReal Îµ := by
      rw [â† ENNReal.ofReal_add (half_pos hÎµ).le (half_pos hÎµ).le, add_halves]","error:  function expected at
  inter_subset_right ?m.230688
term has type
  ?m.230687 âˆˆ ?m.230686
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancelâ‚€` instead","theorem unifIntegrable_of' (hp : 1 â‰¤ p) (hp' : p â‰  âˆ) {f : Î¹ â†’ Î± â†’ Î²}
    (hf : âˆ€ i, StronglyMeasurable (f i))
    (h : âˆ€ Îµ : â„, 0 < Îµ â†’ âˆƒ C : â„â‰¥0, 0 < C âˆ§
      âˆ€ i, snorm ({ x | C â‰¤ â€–f i xâ€–â‚Š }.indicator (f i)) p Î¼ â‰¤ ENNReal.ofReal Îµ) :
    UnifIntegrable f p Î¼ ",":= by
  have hpzero := (lt_of_lt_of_le zero_lt_one hp).ne.symm
  by_cases hÎ¼ : Î¼ Set.univ = 0
  Â· rw [Measure.measure_univ_eq_zero] at hÎ¼
    exact hÎ¼.symm â–¸ unifIntegrable_zero_meas
  intro Îµ hÎµ
  obtain âŸ¨C, hCpos, hCâŸ© := h (Îµ / 2) (half_pos hÎµ)
  refine âŸ¨(Îµ / (2 * C)) ^ ENNReal.toReal p,
    Real.rpow_pos_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos))) _,
    fun i s hs hÎ¼s => ?_âŸ©
  by_cases hÎ¼s' : Î¼ s = 0
  Â· rw [(snorm_eq_zero_iff ((hf i).indicator hs).aestronglyMeasurable hpzero).2
        (indicator_meas_zero hÎ¼s')]
    norm_num
  calc
    snorm (Set.indicator s (f i)) p Î¼ â‰¤
        snorm (Set.indicator (s âˆ© { x | C â‰¤ â€–f i xâ€–â‚Š }) (f i)) p Î¼ +
          snorm (Set.indicator (s âˆ© { x | â€–f i xâ€–â‚Š < C }) (f i)) p Î¼ := by
      refine le_trans (Eq.le ?_) (snorm_add_le
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter (stronglyMeasurable_const.measurableSet_le (hf i).nnnorm))))
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter ((hf i).nnnorm.measurableSet_lt stronglyMeasurable_const))))
        hp)
      congr
      change _ = fun x => (s âˆ© { x : Î± | C â‰¤ â€–f i xâ€–â‚Š }).indicator (f i) x +
        (s âˆ© { x : Î± | â€–f i xâ€–â‚Š < C }).indicator (f i) x
      rw [â† Set.indicator_union_of_disjoint]
      Â· rw [â† Set.inter_union_distrib_left, (by ext; simp [le_or_lt] :
            { x : Î± | C â‰¤ â€–f i xâ€–â‚Š } âˆª { x : Î± | â€–f i xâ€–â‚Š < C } = Set.univ),
          Set.inter_univ]
      Â· refine (Disjoint.inf_right' _ ?_).inf_left' _
        rw [disjoint_iff_inf_le]
        rintro x âŸ¨hxâ‚, hxâ‚‚âŸ©
        rw [Set.mem_setOf_eq] at hxâ‚ hxâ‚‚
        exact False.elim (hxâ‚‚.ne (eq_of_le_of_not_lt hxâ‚ (not_lt.2 hxâ‚‚.le)).symm)
    _ â‰¤ snorm (Set.indicator { x | C â‰¤ â€–f i xâ€–â‚Š } (f i)) p Î¼ +
        (C : â„â‰¥0âˆ) * Î¼ s ^ (1 / ENNReal.toReal p) := by
      refine add_le_add
        (snorm_mono fun x => norm_indicator_le_of_subset Set.inter_subset_right _ _) ?_
      rw [â† Set.indicator_indicator]
      rw [snorm_indicator_eq_snorm_restrict hs]
      have : âˆ€áµ x âˆ‚Î¼.restrict s, â€–{ x : Î± | â€–f i xâ€–â‚Š < C }.indicator (f i) xâ€– â‰¤ C := by
        filter_upwards
        simp_rw [norm_indicator_eq_indicator_norm]
        exact Set.indicator_le' (fun x (hx : _ < _) => hx.le) fun _ _ => NNReal.coe_nonneg _
      refine le_trans (snorm_le_of_ae_bound this) ?_
      rw [mul_comm, Measure.restrict_apply' hs, Set.univ_inter, ENNReal.ofReal_coe_nnreal, one_div]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + C * ENNReal.ofReal (Îµ / (2 * C)) := by
      refine add_le_add (hC i) (mul_le_mul_left' ?_ _)
      rwa [ENNReal.rpow_one_div_le_iff (ENNReal.toReal_pos hpzero hp'),
        ENNReal.ofReal_rpow_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos)))]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + ENNReal.ofReal (Îµ / 2) := by
      refine add_le_add_left ?_ _
      rw [â† ENNReal.ofReal_coe_nnreal, â† ENNReal.ofReal_mul (NNReal.coe_nonneg _), â† div_div,
        mul_div_cancelâ‚€ _ (NNReal.coe_pos.2 hCpos).ne.symm]
    _ â‰¤ ENNReal.ofReal Îµ := by
      rw [â† ENNReal.ofReal_add (half_pos hÎµ).le (half_pos hÎµ).le, add_halves]",refine UnifIntegrable.unifIntegrable_theorem_unifIntegrable_of' hp hp' hf hf hf hf hf
Mathlib/MeasureTheory/Integral/Bochner.lean,MeasureTheory.ae_le_trim_of_stronglyMeasurable,ae_le_trim_of_stronglyMeasurable,5c3b19457914190f5f82a4845a908a6fa667ed79,":= by
  rwa [EventuallyLE, @ae_iff _ m, trim_measurableSet_eq hm _]
  exact (hf.measurableSet_le hg).compl","warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
error:  application type mismatch
  @ae_iff ?m.1331579 m
argument
  m
has type
  MeasurableSpace Î² : Type u_7
but is expected to have type
  Type ?u.1331577 : Type (?u.1331577 + 1)","theorem ae_le_trim_of_stronglyMeasurable [LinearOrder Î³] [TopologicalSpace Î³]
    [OrderClosedTopology Î³] [PseudoMetrizableSpace Î³] (hm : m â‰¤ m0) {f g : Î² â†’ Î³}
    (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) (hfg : f â‰¤áµ[Î¼] g) :
    f â‰¤áµ[Î¼.trim hm] g ",":= by
  rwa [EventuallyLE, ae_iff, trim_measurableSet_eq hm]
  exact (hf.measurableSet_le hg).compl",rw [trim_eq_trim_iff] at hfg
Mathlib/Geometry/RingedSpace/OpenImmersion.lean,AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.pullbackConeOfLeftLift_fst,pullbackConeOfLeftLift_fst,040e24340352a4333b5b2688f637a85dc78123c1,":= by
  refine PresheafedSpace.Hom.ext _ _ ?_ <| NatTrans.ext _ _ <| funext fun x => ?_
  Â· change pullback.lift _ _ _ â‰« pullback.fst = _
    simp
  Â· induction x with | h x => ?_
    change ((_ â‰« _) â‰« _ â‰« _) â‰« _ = _
    simp_rw [Category.assoc]
    erw [â† s.pt.presheaf.map_comp]
    erw [s.snd.c.naturality_assoc]
    have := congr_app s.condition (op (hf.openFunctor.obj x))
    dsimp only [comp_c_app, unop_op] at this
    rw [â† IsIso.comp_inv_eq] at this
    replace this := reassoc_of% this
    erw [â† this, hf.invApp_app_assoc, s.fst.c.naturality_assoc]
    simp [eqToHom_map]","error:  invalid field 'openFunctor', the environment does not contain 'AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.openFunctor'
  hf
has type
  IsOpenImmersion f","theorem pullbackConeOfLeftLift_fst :
    pullbackConeOfLeftLift f g s â‰« (pullbackConeOfLeft f g).fst = s.fst ",":= by
  refine PresheafedSpace.Hom.ext _ _ ?_ <| NatTrans.ext _ _ <| funext fun x => ?_
  Â· change pullback.lift _ _ _ â‰« pullback.fst = _
    simp
  Â· induction x using Opposite.rec' with | h x => ?_
    change ((_ â‰« _) â‰« _ â‰« _) â‰« _ = _
    simp_rw [Category.assoc]
    erw [â† s.pt.presheaf.map_comp]
    erw [s.snd.c.naturality_assoc]
    have := congr_app s.condition (op (opensFunctor f |>.obj x))
    dsimp only [comp_c_app, unop_op] at this
    rw [â† IsIso.comp_inv_eq] at this
    replace this := reassoc_of% this
    erw [â† this, hf.invApp_app_assoc, s.fst.c.naturality_assoc]
    simp [eqToHom_map]","simp [pullbackConeOfLeftLift, pullbackConeOfLeftLift]"
Mathlib/Analysis/Calculus/MeanValue.lean,strictMono_of_deriv_pos,strictMono_of_deriv_pos,0939faa78a0c4506a8aee4e86b897d6e84c6cb96,":=
  strictMonoOn_univ.1 <| convex_univ.strictMonoOn_of_deriv_pos (fun z _ =>
    (differentiableAt_of_deriv_ne_zero (hf' z).ne').differentiableWithinAt.continuousWithinAt)
    fun x _ => hf' x","error:  invalid field 'strictMonoOn_of_deriv_pos', the environment does not contain 'Convex.strictMonoOn_of_deriv_pos'
  convex_univ
has type
  Convex ?m.279725 univ
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  convex_univ
has type
  ?m.280049 âˆˆ univ â†’ StarConvex ?m.279725 ?m.280049 univ","theorem strictMono_of_deriv_pos {f : â„ â†’ â„} (hf' : âˆ€ x, 0 < deriv f x) : StrictMono f ",":=
  strictMonoOn_univ.1 <| strictMonoOn_of_deriv_pos convex_univ (fun z _ =>
    (differentiableAt_of_deriv_ne_zero (hf' z).ne').differentiableWithinAt.continuousWithinAt)
    fun x _ => hf' x",refine StrictMono.strictMono_of_deriv_pos (strictMono_of_deriv_pos hf') ?_
Mathlib/NumberTheory/Pell.lean,Pell.exists_of_not_isSquare,exists_of_not_isSquare,5f92bfec6d6c4ec4639d991dbedc7d9dbbbd4162,":= by
  let Î¾ : â„ := sqrt d
  have hÎ¾ : Irrational Î¾ := by
    refine' irrational_nrt_of_notint_nrt 2 d (sq_sqrt <| Int.cast_nonneg.mpr hâ‚€.le) _ two_pos
    rintro âŸ¨x, hxâŸ©
    refine' hd âŸ¨x, @Int.cast_injective â„ _ _ d (x * x) _âŸ©
    rw [â† sq_sqrt <| Int.cast_nonneg.mpr hâ‚€.le, Int.cast_mul, â† hx, sq]
  obtain âŸ¨M, hMâ‚âŸ© := exists_int_gt (2 * |Î¾| + 1)
  have hM : {q : â„š | |q.1 ^ 2 - d * (q.2 : â„¤) ^ 2| < M}.Infinite := by
    refine' Infinite.mono (fun q h => _) (infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational hÎ¾)
    have h0 : 0 < (q.2 : â„) ^ 2 := pow_pos (Nat.cast_pos.mpr q.pos) 2
    have h1 : (q.num : â„) / (q.den : â„) = q := mod_cast q.num_div_den
    rw [mem_setOf, abs_sub_comm, â† @Int.cast_lt â„, â† div_lt_div_right (abs_pos_of_pos h0)]
    push_cast
    rw [â† abs_div, abs_sq, sub_div, mul_div_cancel_rightâ‚€ _ h0.ne', â† div_pow, h1, â†
      sq_sqrt (Int.cast_pos.mpr hâ‚€).le, sq_sub_sq, abs_mul, â† mul_one_div]
    refine' mul_lt_mul'' (((abs_add Î¾ q).trans _).trans_lt hMâ‚) h (abs_nonneg _) (abs_nonneg _)
    rw [two_mul, add_assoc, add_le_add_iff_left, â† sub_le_iff_le_add']
    rw [mem_setOf, abs_sub_comm] at h
    refine' (abs_sub_abs_le_abs_sub (q : â„) Î¾).trans (h.le.trans _)
    rw [div_le_one h0, one_le_sq_iff_one_le_abs, Nat.abs_cast, Nat.one_le_cast]
    exact q.pos
  obtain âŸ¨m, hmâŸ© : âˆƒ m : â„¤, {q : â„š | q.1 ^ 2 - d * (q.den : â„¤) ^ 2 = m}.Infinite := by
    contrapose! hM
    simp only [not_infinite] at hM âŠ¢
    refine' (congr_arg _ (ext fun x => _)).mp (Finite.biUnion (finite_Ioo (-M) M) fun m _ => hM m)
    simp only [abs_lt, mem_setOf, mem_Ioo, mem_iUnion, exists_prop, exists_eq_right']
  have hmâ‚€ : m â‰  0 := by
    rintro rfl
    obtain âŸ¨q, hqâŸ© := hm.nonempty
    rw [mem_setOf, sub_eq_zero, mul_comm] at hq
    obtain âŸ¨a, haâŸ© := (Int.pow_dvd_pow_iff two_pos).mp âŸ¨d, hqâŸ©
    rw [ha, mul_pow, mul_right_inj' (pow_pos (Int.natCast_pos.mpr q.pos) 2).ne'] at hq
    exact hd âŸ¨a, sq a â–¸ hq.symmâŸ©
  haveI := neZero_iff.mpr (Int.natAbs_ne_zero.mpr hmâ‚€)
  let f : â„š â†’ ZMod m.natAbs Ã— ZMod m.natAbs := fun q => (q.num, q.den)
  obtain âŸ¨qâ‚, hâ‚ : qâ‚.num ^ 2 - d * (qâ‚.den : â„¤) ^ 2 = m,
      qâ‚‚, hâ‚‚ : qâ‚‚.num ^ 2 - d * (qâ‚‚.den : â„¤) ^ 2 = m, hne, hqfâŸ© :=
    hm.exists_ne_map_eq_of_mapsTo (mapsTo_univ f _) finite_univ
  obtain âŸ¨hq1 : (qâ‚.num : ZMod m.natAbs) = qâ‚‚.num, hq2 : (qâ‚.den : ZMod m.natAbs) = qâ‚‚.denâŸ© :=
    Prod.ext_iff.mp hqf
  have hdâ‚ : m âˆ£ qâ‚.num * qâ‚‚.num - d * (qâ‚.den * qâ‚‚.den) := by
    rw [â† Int.natAbs_dvd, â† ZMod.int_cast_zmod_eq_zero_iff_dvd]
    push_cast
    rw [hq1, hq2, â† sq, â† sq]
    norm_cast
    rw [ZMod.int_cast_zmod_eq_zero_iff_dvd, Int.natAbs_dvd, Nat.cast_pow, â† hâ‚‚]
  have hdâ‚‚ : m âˆ£ qâ‚.num * qâ‚‚.den - qâ‚‚.num * qâ‚.den := by
    rw [â† Int.natAbs_dvd, â† ZMod.int_cast_eq_int_cast_iff_dvd_sub]
    push_cast
    rw [hq1, hq2]
  replace hmâ‚€ : (m : â„š) â‰  0 := Int.cast_ne_zero.mpr hmâ‚€
  refine' âŸ¨(qâ‚.num * qâ‚‚.num - d * (qâ‚.den * qâ‚‚.den)) / m, (qâ‚.num * qâ‚‚.den - qâ‚‚.num * qâ‚.den) / m,
      _, _âŸ©
  Â· qify [hdâ‚, hdâ‚‚]
    field_simp [hmâ‚€]
    norm_cast
    conv_rhs =>
      rw [sq]
      congr
      Â· rw [â† hâ‚]
      Â· rw [â† hâ‚‚]
    push_cast
    ring
  Â· qify [hdâ‚‚]
    refine' div_ne_zero_iff.mpr âŸ¨_, hmâ‚€âŸ©
    exact mod_cast mt sub_eq_zero.mp (mt Rat.eq_iff_mul_eq_mul.mpr hne)","error:  application type mismatch
  Int.pow_dvd_pow_iff two_pos
argument
  two_pos
has type
  0 < 2 : Prop
but is expected to have type
  ?m.82608 â‰  0 : Prop
warning:  `ZMod.int_cast_zmod_eq_zero_iff_dvd` has been deprecated, use `ZMod.intCast_zmod_eq_zero_iff_dvd` instead
warning:  `ZMod.int_cast_zmod_eq_zero_iff_dvd` has been deprecated, use `ZMod.intCast_zmod_eq_zero_iff_dvd` instead
warning:  `ZMod.int_cast_eq_int_cast_iff_dvd_sub` has been deprecated, use `ZMod.intCast_eq_intCast_iff_dvd_sub` instead","theorem exists_of_not_isSquare (hâ‚€ : 0 < d) (hd : Â¬IsSquare d) :
    âˆƒ x y : â„¤, x ^ 2 - d * y ^ 2 = 1 âˆ§ y â‰  0 ",":= by
  let Î¾ : â„ := âˆšd
  have hÎ¾ : Irrational Î¾ := by
    refine irrational_nrt_of_notint_nrt 2 d (sq_sqrt <| Int.cast_nonneg.mpr hâ‚€.le) ?_ two_pos
    rintro âŸ¨x, hxâŸ©
    refine hd âŸ¨x, @Int.cast_injective â„ _ _ d (x * x) ?_âŸ©
    rw [â† sq_sqrt <| Int.cast_nonneg.mpr hâ‚€.le, Int.cast_mul, â† hx, sq]
  obtain âŸ¨M, hMâ‚âŸ© := exists_int_gt (2 * |Î¾| + 1)
  have hM : {q : â„š | |q.1 ^ 2 - d * (q.2 : â„¤) ^ 2| < M}.Infinite := by
    refine Infinite.mono (fun q h => ?_) (infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational hÎ¾)
    have h0 : 0 < (q.2 : â„) ^ 2 := pow_pos (Nat.cast_pos.mpr q.pos) 2
    have h1 : (q.num : â„) / (q.den : â„) = q := mod_cast q.num_div_den
    rw [mem_setOf, abs_sub_comm, â† @Int.cast_lt â„, â† div_lt_div_right (abs_pos_of_pos h0)]
    push_cast
    rw [â† abs_div, abs_sq, sub_div, mul_div_cancel_rightâ‚€ _ h0.ne', â† div_pow, h1, â†
      sq_sqrt (Int.cast_pos.mpr hâ‚€).le, sq_sub_sq, abs_mul, â† mul_one_div]
    refine mul_lt_mul'' (((abs_add Î¾ q).trans ?_).trans_lt hMâ‚) h (abs_nonneg _) (abs_nonneg _)
    rw [two_mul, add_assoc, add_le_add_iff_left, â† sub_le_iff_le_add']
    rw [mem_setOf, abs_sub_comm] at h
    refine (abs_sub_abs_le_abs_sub (q : â„) Î¾).trans (h.le.trans ?_)
    rw [div_le_one h0, one_le_sq_iff_one_le_abs, Nat.abs_cast, Nat.one_le_cast]
    exact q.pos
  obtain âŸ¨m, hmâŸ© : âˆƒ m : â„¤, {q : â„š | q.1 ^ 2 - d * (q.den : â„¤) ^ 2 = m}.Infinite := by
    contrapose! hM
    simp only [not_infinite] at hM âŠ¢
    refine (congr_arg _ (ext fun x => ?_)).mp (Finite.biUnion (finite_Ioo (-M) M) fun m _ => hM m)
    simp only [abs_lt, mem_setOf, mem_Ioo, mem_iUnion, exists_prop, exists_eq_right']
  have hmâ‚€ : m â‰  0 := by
    rintro rfl
    obtain âŸ¨q, hqâŸ© := hm.nonempty
    rw [mem_setOf, sub_eq_zero, mul_comm] at hq
    obtain âŸ¨a, haâŸ© := (Int.pow_dvd_pow_iff two_ne_zero).mp âŸ¨d, hqâŸ©
    rw [ha, mul_pow, mul_right_inj' (pow_pos (Int.natCast_pos.mpr q.pos) 2).ne'] at hq
    exact hd âŸ¨a, sq a â–¸ hq.symmâŸ©
  haveI := neZero_iff.mpr (Int.natAbs_ne_zero.mpr hmâ‚€)
  let f : â„š â†’ ZMod m.natAbs Ã— ZMod m.natAbs := fun q => (q.num, q.den)
  obtain âŸ¨qâ‚, hâ‚ : qâ‚.num ^ 2 - d * (qâ‚.den : â„¤) ^ 2 = m,
      qâ‚‚, hâ‚‚ : qâ‚‚.num ^ 2 - d * (qâ‚‚.den : â„¤) ^ 2 = m, hne, hqfâŸ© :=
    hm.exists_ne_map_eq_of_mapsTo (mapsTo_univ f _) finite_univ
  obtain âŸ¨hq1 : (qâ‚.num : ZMod m.natAbs) = qâ‚‚.num, hq2 : (qâ‚.den : ZMod m.natAbs) = qâ‚‚.denâŸ© :=
    Prod.ext_iff.mp hqf
  have hdâ‚ : m âˆ£ qâ‚.num * qâ‚‚.num - d * (qâ‚.den * qâ‚‚.den) := by
    rw [â† Int.natAbs_dvd, â† ZMod.intCast_zmod_eq_zero_iff_dvd]
    push_cast
    rw [hq1, hq2, â† sq, â† sq]
    norm_cast
    rw [ZMod.intCast_zmod_eq_zero_iff_dvd, Int.natAbs_dvd, Nat.cast_pow, â† hâ‚‚]
  have hdâ‚‚ : m âˆ£ qâ‚.num * qâ‚‚.den - qâ‚‚.num * qâ‚.den := by
    rw [â† Int.natAbs_dvd, â† ZMod.intCast_eq_intCast_iff_dvd_sub]
    push_cast
    rw [hq1, hq2]
  replace hmâ‚€ : (m : â„š) â‰  0 := Int.cast_ne_zero.mpr hmâ‚€
  refine âŸ¨(qâ‚.num * qâ‚‚.num - d * (qâ‚.den * qâ‚‚.den)) / m, (qâ‚.num * qâ‚‚.den - qâ‚‚.num * qâ‚.den) / m,
      ?_, ?_âŸ©
  Â· qify [hdâ‚, hdâ‚‚]
    field_simp [hmâ‚€]
    norm_cast
    conv_rhs =>
      rw [sq]
      congr
      Â· rw [â† hâ‚]
      Â· rw [â† hâ‚‚]
    push_cast
    ring
  Â· qify [hdâ‚‚]
    refine div_ne_zero_iff.mpr âŸ¨?_, hmâ‚€âŸ©
    exact mod_cast mt sub_eq_zero.mp (mt Rat.eq_iff_mul_eq_mul.mpr hne)","obtain âŸ¨x, y, hxy, hyâŸ© := exists_of_not_isSquare hâ‚€ hd"
Mathlib/Order/OmegaCompletePartialOrder.lean,OmegaCompletePartialOrder.isLUB_range_Ï‰Sup,isLUB_range_Ï‰Sup,df7b04231c9920b36d13328cb3f0f402d88e7da5,":= by
  constructor
  Â· simp only [upperBounds, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff',
      Set.mem_setOf_eq]
    exact fun a â†¦ le_Ï‰Sup c a
  Â· simp only [lowerBounds, upperBounds, Set.mem_range, forall_exists_index,
      forall_apply_eq_imp_iff', Set.mem_setOf_eq]
    exact fun â¦ƒaâ¦„ a_1 â†¦ Ï‰Sup_le c a a_1","error:  application type mismatch
  le_Ï‰Sup c a
argument
  a
has type
  Î± : Type u
but is expected to have type
  â„• : Type
error:  application type mismatch
  Ï‰Sup_le c a a_1
argument
  a_1
has type
  âˆ€ â¦ƒa_2 : Î±â¦„ (x : â„•), c x = a_2 â†’ a_2 â‰¤ a : Prop
but is expected to have type
  âˆ€ (i : â„•), c i â‰¤ a : Prop
warning:  ContinuousHom does not have a doc string",lemma isLUB_range_Ï‰Sup (c : Chain Î±) : IsLUB (Set.range c) (Ï‰Sup c) ,":= by
  constructor
  Â· simp only [upperBounds, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff,
      Set.mem_setOf_eq]
    exact fun a â†¦ le_Ï‰Sup c a
  Â· simp only [lowerBounds, upperBounds, Set.mem_range, forall_exists_index,
      forall_apply_eq_imp_iff, Set.mem_setOf_eq]
    exact fun â¦ƒaâ¦„ a_1 â†¦ Ï‰Sup_le c a a_1",apply isLUB_range_Ï‰Sup
Mathlib/GroupTheory/Schreier.lean,Subgroup.card_commutator_le_of_finite_commutatorSet,card_commutator_le_of_finite_commutatorSet,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  have h1 := index_center_le_pow (closureCommutatorRepresentatives G)
  have h2 := card_commutator_dvd_index_center_pow (closureCommutatorRepresentatives G)
  rw [card_commutatorSet_closureCommutatorRepresentatives] at h1 h2
  rw [card_commutator_closureCommutatorRepresentatives] at h2
  replace h1 :=
    h1.trans
      (Nat.pow_le_pow_of_le_right Finite.card_pos (rank_closureCommutatorRepresentatives_le G))
  replace h2 := h2.trans (pow_dvd_pow _ (add_le_add_right (mul_le_mul_right' h1 _) 1))
  rw [â† pow_succ'] at h2
  refine' (Nat.le_of_dvd _ h2).trans (Nat.pow_le_pow_of_le_left h1 _)
  exact pow_pos (Nat.pos_of_ne_zero FiniteIndex.finiteIndex) _
  Subgroup.card_commutator_le_of_finite_commutatorSet",error:  unknown tactic,"theorem card_commutator_le_of_finite_commutatorSet [Finite (commutatorSet G)] :
    Nat.card (_root_.commutator G) â‰¤ cardCommutatorBound (Nat.card (commutatorSet G)) ",":= by
  have h1 := index_center_le_pow (closureCommutatorRepresentatives G)
  have h2 := card_commutator_dvd_index_center_pow (closureCommutatorRepresentatives G)
  rw [card_commutatorSet_closureCommutatorRepresentatives] at h1 h2
  rw [card_commutator_closureCommutatorRepresentatives] at h2
  replace h1 :=
    h1.trans
      (Nat.pow_le_pow_of_le_right Finite.card_pos (rank_closureCommutatorRepresentatives_le G))
  replace h2 := h2.trans (pow_dvd_pow _ (add_le_add_right (mul_le_mul_right' h1 _) 1))
  rw [â† pow_succ] at h2
  refine (Nat.le_of_dvd ?_ h2).trans (Nat.pow_le_pow_left h1 _)
  exact pow_pos (Nat.pos_of_ne_zero FiniteIndex.finiteIndex) _",rw [card_commutator_le_of_finite_commutatorSet]
Mathlib/Analysis/Convex/Basic.lean,convex_Ioi,convex_Ioi,03690a4c3252f422184189d0b6a6dd8d1c55d551,":=
  @convex_Iio ğ•œ Î²áµ’áµˆ _ _ _ _ _ _ r","error:  application type mismatch
  convex_Iio ?m.106999 r
argument
  r
has type
  Î² : Type u_4
but is expected to have type
  ?m.107000 âˆˆ Iio ?m.106999 : Prop",theorem convex_Ioi (r : Î²) : Convex ğ•œ (Ioi r) ,":=
  @convex_Iio ğ•œ Î²áµ’áµˆ _ _ _ _ r","rw [convex_Ioi, convex_Ioi, convex_Ioi]"
Mathlib/CategoryTheory/Sites/Preserves.lean,CategoryTheory.Presieve.isSheafFor_of_preservesProduct,isSheafFor_of_preservesProduct,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [Equalizer.Presieve.Arrows.sheaf_condition, Limits.Types.type_equalizer_iff_unique]
  have : HasCoproduct X := âŸ¨âŸ¨c, hcâŸ©âŸ©
  have hi : IsIso (piComparison F (fun x â†¦ op (X x))) := inferInstance
  rw [piComparison_fac (hc := hc), isIso_iff_bijective, Function.bijective_iff_existsUnique] at hi
  intro b _
  obtain âŸ¨t, htâ‚, htâ‚‚âŸ© := hi b
  refine âŸ¨F.map ((opCoproductIsoProduct' hc (productIsProduct _)).inv) t, htâ‚, fun y hy â†¦ ?_âŸ©
  apply_fun F.map ((opCoproductIsoProduct' hc (productIsProduct _)).hom) using injective_of_mono _
  simp only [â† FunctorToTypes.map_comp_apply, Iso.op, Category.assoc]
  rw [htâ‚‚ (F.map ((opCoproductIsoProduct' hc (productIsProduct _)).hom) y) (by simp [â† hy])]
  change (ğŸ™ (F.obj (âˆ fun x â†¦ op (X x)))) t = _
  rw [â† Functor.map_id]
  refine congrFun ?_ t
  congr
  simp [Iso.eq_inv_comp, â† Category.assoc, â† op_comp, eq_comm, â† Iso.eq_comp_inv]",error:  expected token,"theorem isSheafFor_of_preservesProduct [PreservesLimit (Discrete.functor (fun x â†¦ op (X x))) F] :
    (ofArrows X c.inj).IsSheafFor F ",":= by
  rw [Equalizer.Presieve.Arrows.sheaf_condition, Limits.Types.type_equalizer_iff_unique]
  have : HasCoproduct X := âŸ¨âŸ¨c, hcâŸ©âŸ©
  have hi : IsIso (piComparison F (fun x â†¦ op (X x))) := inferInstance
  rw [piComparison_fac (hc := hc), isIso_iff_bijective, Function.bijective_iff_existsUnique] at hi
  intro b _
  obtain âŸ¨t, htâ‚, htâ‚‚âŸ© := hi b
  refine âŸ¨F.map ((opCoproductIsoProduct' hc (productIsProduct _)).inv) t, htâ‚, fun y hy â†¦ ?_âŸ©
  apply_fun F.map ((opCoproductIsoProduct' hc (productIsProduct _)).hom) using injective_of_mono _
  simp only [â† FunctorToTypes.map_comp_apply, Iso.op, Category.assoc]
  rw [htâ‚‚ (F.map ((opCoproductIsoProduct' hc (productIsProduct _)).hom) y) (by simp [â† hy])]
  change (ğŸ™ (F.obj (âˆá¶œ fun x â†¦ op (X x)))) t = _
  rw [â† Functor.map_id]
  refine congrFun ?_ t
  congr
  simp [Iso.eq_inv_comp, â† Category.assoc, â† op_comp, eq_comm, â† Iso.eq_comp_inv]",apply isSheafFor_of_preservesProduct
Mathlib/Algebra/Lie/Weights/Basic.lean,LieModule.independent_weightSpace,independent_weightSpace,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  classical
  suffices âˆ€ Ï‡ (s : Finset (L â†’ R)) (_ : Ï‡ âˆ‰ s),
      Disjoint (weightSpace M Ï‡) (s.sup fun (Ï‡ : L â†’ R) â†¦ weightSpace M Ï‡) by
    simpa only [CompleteLattice.independent_iff_supIndep_of_injOn (injOn_weightSpace R L M),
      Finset.supIndep_iff_disjoint_erase] using fun s Ï‡ _ â†¦ this _ _ (s.not_mem_erase Ï‡)
  intro Ï‡â‚ s
  induction' s using Finset.induction_on with Ï‡â‚‚ s _ ih
  Â· simp
  intro hÏ‡â‚â‚‚
  obtain âŸ¨hÏ‡â‚â‚‚ : Ï‡â‚ â‰  Ï‡â‚‚, hÏ‡â‚ : Ï‡â‚ âˆ‰ sâŸ© := by rwa [Finset.mem_insert, not_or] at hÏ‡â‚â‚‚
  specialize ih hÏ‡â‚
  rw [Finset.sup_insert, disjoint_iff, LieSubmodule.eq_bot_iff]
  rintro x âŸ¨hx, hx'âŸ©
  simp only [SetLike.mem_coe, LieSubmodule.mem_coeSubmodule] at hx hx'
  suffices x âˆˆ weightSpace M Ï‡â‚‚ by
    rw [â† LieSubmodule.mem_bot (R := R) (L := L), â† (disjoint_weightSpace R L M hÏ‡â‚â‚‚).eq_bot]
    exact âŸ¨hx, thisâŸ©
  obtain âŸ¨y, hy, z, hz, rflâŸ© := (LieSubmodule.mem_sup _ _ _).mp hx'; clear hx'
  suffices âˆ€ l, âˆƒ (k : â„•),
      ((toEndomorphism R L M l - algebraMap R (Module.End R M) (Ï‡â‚‚ l)) ^ k) (y + z) âˆˆ
      weightSpace M Ï‡â‚ âŠ“ Finset.sup s fun Ï‡ â†¦ weightSpace M Ï‡ by
    simpa only [ih.eq_bot, LieSubmodule.mem_bot, mem_weightSpace] using this
  intro l
  let g : Module.End R M := toEndomorphism R L M l - algebraMap R (Module.End R M) (Ï‡â‚‚ l)
  obtain âŸ¨k, hk : (g ^ k) y = 0âŸ© := (mem_weightSpace _ _ _).mp hy l
  refine âŸ¨k, (LieSubmodule.mem_inf _ _ _).mp âŸ¨?_, ?_âŸ©âŸ©
  Â· exact LieSubmodule.mapsTo_pow_toEndomorphism_sub_algebraMap _ hx
  Â· rw [map_add, hk, zero_add]
    suffices (s.sup fun Ï‡ â†¦ weightSpace M Ï‡ : Submodule R M).map (g ^ k) â‰¤
        s.sup fun Ï‡ â†¦ weightSpace M Ï‡ by
      refine this (Submodule.mem_map_of_mem ?_)
      simp_rw [â† LieSubmodule.mem_coeSubmodule, Finset.sup_eq_iSup,
        LieSubmodule.iSup_coe_toSubmodule, â† Finset.sup_eq_iSup] at hz
      exact hz
    simp_rw [Finset.sup_eq_iSup, Submodule.map_iSup (Î¹ := L â†’ R), Submodule.map_iSup (Î¹ := _ âˆˆ s),
      LieSubmodule.iSup_coe_toSubmodule]
    refine iSupâ‚‚_mono fun Ï‡ _ â†¦ ?_
    rintro - âŸ¨u, hu, rflâŸ©
    exact LieSubmodule.mapsTo_pow_toEndomorphism_sub_algebraMap _ hu","error:  unknown identifier 'toEndomorphism'
error:  unknown identifier 'toEndomorphism'
error:  rcases: scrutinee has type
  (((toEnd R L M) l - Ï‡â‚‚ l â€¢ 1) ^ k) y = 0 : Prop
but is expected to have type
  (g ^ k) y = 0 : Prop","lemma independent_weightSpace [NoZeroSMulDivisors R M] :
    CompleteLattice.Independent fun (Ï‡ : L â†’ R) â†¦ weightSpace M Ï‡ ",":= by
  classical
  suffices âˆ€ Ï‡ (s : Finset (L â†’ R)) (_ : Ï‡ âˆ‰ s),
      Disjoint (weightSpace M Ï‡) (s.sup fun (Ï‡ : L â†’ R) â†¦ weightSpace M Ï‡) by
    simpa only [CompleteLattice.independent_iff_supIndep_of_injOn (injOn_weightSpace R L M),
      Finset.supIndep_iff_disjoint_erase] using fun s Ï‡ _ â†¦ this _ _ (s.not_mem_erase Ï‡)
  intro Ï‡â‚ s
  induction' s using Finset.induction_on with Ï‡â‚‚ s _ ih
  Â· simp
  intro hÏ‡â‚â‚‚
  obtain âŸ¨hÏ‡â‚â‚‚ : Ï‡â‚ â‰  Ï‡â‚‚, hÏ‡â‚ : Ï‡â‚ âˆ‰ sâŸ© := by rwa [Finset.mem_insert, not_or] at hÏ‡â‚â‚‚
  specialize ih hÏ‡â‚
  rw [Finset.sup_insert, disjoint_iff, LieSubmodule.eq_bot_iff]
  rintro x âŸ¨hx, hx'âŸ©
  simp only [SetLike.mem_coe, LieSubmodule.mem_coeSubmodule] at hx hx'
  suffices x âˆˆ weightSpace M Ï‡â‚‚ by
    rw [â† LieSubmodule.mem_bot (R := R) (L := L), â† (disjoint_weightSpace R L M hÏ‡â‚â‚‚).eq_bot]
    exact âŸ¨hx, thisâŸ©
  obtain âŸ¨y, hy, z, hz, rflâŸ© := (LieSubmodule.mem_sup _ _ _).mp hx'; clear hx'
  suffices âˆ€ l, âˆƒ (k : â„•),
      ((toEnd R L M l - algebraMap R (Module.End R M) (Ï‡â‚‚ l)) ^ k) (y + z) âˆˆ
      weightSpace M Ï‡â‚ âŠ“ Finset.sup s fun Ï‡ â†¦ weightSpace M Ï‡ by
    simpa only [ih.eq_bot, LieSubmodule.mem_bot, mem_weightSpace] using this
  intro l
  let g : Module.End R M := toEnd R L M l - algebraMap R (Module.End R M) (Ï‡â‚‚ l)
  obtain âŸ¨k, hk : (g ^ k) y = 0âŸ© := (mem_weightSpace _ _ _).mp hy l
  refine âŸ¨k, (LieSubmodule.mem_inf _ _ _).mp âŸ¨?_, ?_âŸ©âŸ©
  Â· exact LieSubmodule.mapsTo_pow_toEnd_sub_algebraMap _ hx
  Â· rw [map_add, hk, zero_add]
    suffices (s.sup fun Ï‡ â†¦ weightSpace M Ï‡ : Submodule R M).map (g ^ k) â‰¤
        s.sup fun Ï‡ â†¦ weightSpace M Ï‡ by
      refine this (Submodule.mem_map_of_mem ?_)
      simp_rw [â† LieSubmodule.mem_coeSubmodule, Finset.sup_eq_iSup,
        LieSubmodule.iSup_coe_toSubmodule, â† Finset.sup_eq_iSup] at hz
      exact hz
    simp_rw [Finset.sup_eq_iSup, Submodule.map_iSup (Î¹ := L â†’ R), Submodule.map_iSup (Î¹ := _ âˆˆ s),
      LieSubmodule.iSup_coe_toSubmodule]
    refine iSupâ‚‚_mono fun Ï‡ _ â†¦ ?_
    rintro - âŸ¨u, hu, rflâŸ©
    exact LieSubmodule.mapsTo_pow_toEnd_sub_algebraMap _ hu","rw [NoZeroSMulDivisors.weightSpace, NoZeroSMulDivisors.weightSpace]"
Mathlib/NumberTheory/Cyclotomic/PrimitiveRoots.lean,IsPrimitiveRoot.norm_eq_one,norm_eq_one,b89833e5d8bafbb16f4932576f6eef05071d317b,":= by
  haveI := IsCyclotomicExtension.ne_zero' n K L
  by_cases h1 : n = 1
  Â· rw [h1, one_coe, one_right_iff] at hÎ¶
    rw [hÎ¶, show 1 = algebraMap K L 1 by simp, Algebra.norm_algebraMap, one_pow]
  Â· replace h1 : 2 â‰¤ n
    Â· by_contra' h
      exact h1 (PNat.eq_one_of_lt_two h)
    rw [â† hÎ¶.powerBasis_gen K, PowerBasis.norm_gen_eq_coeff_zero_minpoly, hÎ¶.powerBasis_gen K, â†
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr,
      (cyclotomic_coeff_zero K h1 : coeff (cyclotomic n K) 0 = 1), mul_one,
      hÎ¶.powerBasis_dim K, â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, natDegree_cyclotomic]
    exact (totient_even <| h1.lt_of_ne hn.symm).neg_one_pow","error:  unexpected token 'Â·'; expected '|'
error:  don't know how to synthesize placeholder
context:
p n : â„•+
A : Type w
B : Type z
K : Type u
L : Type v
C : Type w
instâœâ¸ : CommRing A
instâœâ· : CommRing B
instâœâ¶ : Algebra A B
instâœâµ : IsCyclotomicExtension {n} A B
instâœâ´ : CommRing L
Î¶ : L
hÎ¶ : IsPrimitiveRoot Î¶ â†‘n
instâœÂ³ : Field K
instâœÂ² : Algebra K L
instâœÂ¹ : IsDomain L
instâœ : IsCyclotomicExtension {n} K L
hn : n â‰  2
hirr : Irreducible (cyclotomic (â†‘n) K)
âŠ¢ Sort ?u.192508
error:  unsolved goals
p n : â„•+
A : Type w
B : Type z
K : Type u
L : Type v
C : Type w
instâœâ¸ : CommRing A
instâœâ· : CommRing B
instâœâ¶ : Algebra A B
instâœâµ : IsCyclotomicExtension {n} A B
instâœâ´ : CommRing L
Î¶ : L
hÎ¶ : IsPrimitiveRoot Î¶ â†‘n
instâœÂ³ : Field K
instâœÂ² : Algebra K L
instâœÂ¹ : IsDomain L
instâœ : IsCyclotomicExtension {n} K L
hn : n â‰  2
hirr : Irreducible (cyclotomic (â†‘n) K)
âŠ¢ (Algebra.norm K) Î¶ = 1
error:  invalid field notation, function 'IsPrimitiveRoot.norm_eq_one' does not have argument with type (IsPrimitiveRoot ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'IsPrimitiveRoot.norm_eq_one' does not have argument with type (IsPrimitiveRoot ...) that can be used, it must be explicit or implicit with a unique name","theorem norm_eq_one [IsDomain L] [IsCyclotomicExtension {n} K L] (hn : n â‰  2)
    (hirr : Irreducible (cyclotomic n K)) : norm K Î¶ = 1 ",":= by
  haveI := IsCyclotomicExtension.neZero' n K L
  by_cases h1 : n = 1
  Â· rw [h1, one_coe, one_right_iff] at hÎ¶
    rw [hÎ¶, show 1 = algebraMap K L 1 by simp, Algebra.norm_algebraMap, one_pow]
  Â· replace h1 : 2 â‰¤ n := by
      by_contra! h
      exact h1 (PNat.eq_one_of_lt_two h)
    rw [â† hÎ¶.powerBasis_gen K, PowerBasis.norm_gen_eq_coeff_zero_minpoly, hÎ¶.powerBasis_gen K, â†
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr,
      (cyclotomic_coeff_zero K h1 : coeff (cyclotomic n K) 0 = 1), mul_one,
      hÎ¶.powerBasis_dim K, â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, natDegree_cyclotomic]
    exact (totient_even <| h1.lt_of_ne hn.symm).neg_one_pow","rw [norm_eq_one, norm_eq_one, norm_eq_one]"
Mathlib/Probability/Variance.lean,ProbabilityTheory.meas_ge_le_variance_div_sq,meas_ge_le_variance_div_sq,22e97510854d6906cc856e022d297bf9cf8c9b3a,":= by
  rw [ENNReal.ofReal_div_of_pos (sq_pos_of_ne_zero _ hc.ne.symm), hX.ofReal_variance_eq]
  convert @meas_ge_le_evariance_div_sq _ _ _ hX.1 c.toNNReal (by simp [hc]) using 1
  Â· simp only [Real.coe_toNNReal', max_le_iff, abs_nonneg, and_true_iff]
  Â· rw [ENNReal.ofReal_pow hc.le, ENNReal.coe_pow]
    rfl","error:  function expected at
  sq_pos_of_ne_zero ?m.84973
term has type
  0 < ?m.84972 ^ 2
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â†‘(?x ^ ?n)
case h.e'_4
Î© : Type u_1
m : MeasurableSpace Î©
Xâœ : Î© â†’ â„
Î¼ : Measure Î©
instâœÂ¹ : MeasureSpace Î©
instâœ : IsFiniteMeasure â„™
X : Î© â†’ â„
hX : Memâ„’p X 2 â„™
c : â„
hc : 0 < c
âŠ¢ evariance X â„™ / ENNReal.ofReal c ^ 2 = evariance X â„™ / â†‘c.toNNReal ^ 2","theorem meas_ge_le_variance_div_sq [@IsFiniteMeasure Î© _ â„™] {X : Î© â†’ â„} (hX : Memâ„’p X 2) {c : â„}
    (hc : 0 < c) : â„™ {Ï‰ | c â‰¤ |X Ï‰ - ğ”¼[X]|} â‰¤ ENNReal.ofReal (Var[X] / c ^ 2) ",":= by
  rw [ENNReal.ofReal_div_of_pos (sq_pos_of_ne_zero hc.ne.symm), hX.ofReal_variance_eq]
  convert @meas_ge_le_evariance_div_sq _ _ _ hX.1 c.toNNReal (by simp [hc]) using 1
  Â· simp only [Real.coe_toNNReal', max_le_iff, abs_nonneg, and_true_iff]
  Â· rw [ENNReal.ofReal_pow hc.le]
    rfl","rw [ENNReal.ofReal_div, ENNReal.ofReal_ofReal (Var[X] / c ^ 2),
  ENNReal.ofReal_ofReal (Var[X] / c ^ 2)]"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.map_withDensity_abs_det_fderiv_eq_addHaar,map_withDensity_abs_det_fderiv_eq_addHaar,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  apply Measure.ext fun t ht => ?_
  rw [map_apply h'f ht, withDensity_apply _ (h'f ht), Measure.restrict_apply ht,
    restrict_restrict (h'f ht),
    lintegral_abs_det_fderiv_eq_addHaar_image Î¼ ((h'f ht).inter hs)
      (fun x hx => (hf' x hx.2).mono (inter_subset_right _ _)) (hf.mono (inter_subset_right _ _)),
    image_preimage_inter]","error:  function expected at
  inter_subset_right ?m.530744
term has type
  ?m.530743 âˆˆ ?m.530742
error:  function expected at
  inter_subset_right ?m.530821
term has type
  ?m.530820 âˆˆ ?m.530819","theorem map_withDensity_abs_det_fderiv_eq_addHaar (hs : MeasurableSet s)
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) (h'f : Measurable f) :
    Measure.map f ((Î¼.restrict s).withDensity fun x => ENNReal.ofReal |(f' x).det|) =
      Î¼.restrict (f '' s) ",":= by
  apply Measure.ext fun t ht => ?_
  rw [map_apply h'f ht, withDensity_apply _ (h'f ht), Measure.restrict_apply ht,
    restrict_restrict (h'f ht),
    lintegral_abs_det_fderiv_eq_addHaar_image Î¼ ((h'f ht).inter hs)
      (fun x hx => (hf' x hx.2).mono inter_subset_right) (hf.mono inter_subset_right),
    image_preimage_inter]",rw [Measure.restrict_withDensity_abs_det_fderiv_eq_restrict]
Mathlib/Topology/Category/TopCat/EffectiveEpi.lean,TopCat.effectiveEpi_iff_quotientMap,effectiveEpi_iff_quotientMap,76f1a2bc2fd4cfd9e874de1d4ee20645b403a690,":= by
  refine âŸ¨fun _ â†¦ ?_, fun hÏ€ â†¦ âŸ¨âŸ¨effectiveEpiStructOfQuotientMap Ï€ hÏ€âŸ©âŸ©âŸ©
  have hÏ€ : RegularEpi Ï€ := inferInstance
  let F := parallelPair hÏ€.left hÏ€.right
  let i : B â‰… colimit F := hÏ€.isColimit.coconePointUniqueUpToIso (colimit.isColimit _)
  suffices QuotientMap (homeoOfIso i âˆ˜ Ï€) by
    simpa [â† Function.comp.assoc] using (homeoOfIso i).symm.quotientMap.comp this
  constructor
  Â· change Function.Surjective (Ï€ â‰« i.hom)
    rw [â† epi_iff_surjective]
    infer_instance
  Â· ext U
    have : Ï€ â‰« i.hom = colimit.Î¹ F WalkingParallelPair.one := by simp [â† Iso.eq_comp_inv]
    rw [isOpen_coinduced (f := (homeoOfIso i âˆ˜ Ï€)), coequalizer_isOpen_iff _ U, â† this]
    rfl","error:  unsolved goals
B X : TopCat
Ï€ : X âŸ¶ B
xâœ : EffectiveEpi Ï€
hÏ€ : RegularEpi Ï€
F : WalkingParallelPair â¥¤ TopCat := parallelPair RegularEpi.left RegularEpi.right
i : B â‰… colimit F :=
  RegularEpi.isColimit.coconePointUniqueUpToIso (colimit.isColimit (parallelPair RegularEpi.left RegularEpi.right))
U : Set â†‘(colimit F)
âŠ¢ Ï€ = colimit.Î¹ F WalkingParallelPair.one â‰« i.inv","theorem effectiveEpi_iff_quotientMap {B X : TopCat.{u}} (Ï€ : X âŸ¶ B) :
    EffectiveEpi Ï€ â†” QuotientMap Ï€ ",":= by
  refine âŸ¨fun _ â†¦ ?_, fun hÏ€ â†¦ âŸ¨âŸ¨effectiveEpiStructOfQuotientMap Ï€ hÏ€âŸ©âŸ©âŸ©
  have hÏ€ : RegularEpi Ï€ := inferInstance
  let F := parallelPair hÏ€.left hÏ€.right
  let i : B â‰… colimit F := hÏ€.isColimit.coconePointUniqueUpToIso (colimit.isColimit _)
  suffices QuotientMap (homeoOfIso i âˆ˜ Ï€) by
    simpa [â† Function.comp.assoc] using (homeoOfIso i).symm.quotientMap.comp this
  constructor
  Â· change Function.Surjective (Ï€ â‰« i.hom)
    rw [â† epi_iff_surjective]
    infer_instance
  Â· ext U
    have : Ï€ â‰« i.hom = colimit.Î¹ F WalkingParallelPair.one := by simp [i, â† Iso.eq_comp_inv]
    rw [isOpen_coinduced (f := (homeoOfIso i âˆ˜ Ï€)), coequalizer_isOpen_iff _ U, â† this]
    rfl","simp only [quotientMap_iff_quotientMap_iff, quotientMap_iff_effectiveEpi_iff_quotientMap]"
Mathlib/CategoryTheory/Limits/HasLimits.lean,CategoryTheory.Limits.hasColimitOfIso,hasColimitOfIso,4e9ad32a390d245132183394a03b349e4f617c33,":=
  HasColimit.mk
    { cocone := (Cocones.precompose Î±.hom).obj (colimit.cocone F)
      isColimit :=
        { desc := fun s => colimit.desc F ((Cocones.precompose Î±.inv).obj s)
          fac := fun s j =>
            by
            rw [Cocones.precompose_obj_Î¹, NatTrans.comp_app, colimit.cocone_Î¹]
            rw [Category.assoc, colimit.Î¹_desc, â† NatIso.app_hom, â† Iso.eq_inv_comp]; rfl
          uniq := fun s m w => by
            apply colimit.hom_ext; intro j
            rw [colimit.Î¹_desc, Cocones.precompose_obj_Î¹, NatTrans.comp_app, â† NatIso.app_inv,
              Iso.eq_inv_comp]
            simpa using w j } }","error:  tactic 'apply' failed, failed to unify
  ?f = ?f'
with
  m = (fun s â†¦ colimit.desc F ((Cocones.precompose Î±.inv).obj s)) s
J : Type uâ‚
instâœÂ³ : Category.{vâ‚, uâ‚} J
K : Type uâ‚‚
instâœÂ² : Category.{vâ‚‚, uâ‚‚} K
C : Type u
instâœÂ¹ : Category.{v, u} C
Fâœ F G : J â¥¤ C
instâœ : HasColimit F
Î± : G â‰… F
s : Cocone G
m : ((Cocones.precompose Î±.hom).obj (colimit.cocone F)).pt âŸ¶ s.pt
w : âˆ€ (j : J), ((Cocones.precompose Î±.hom).obj (colimit.cocone F)).Î¹.app j â‰« m = s.Î¹.app j
âŠ¢ m = (fun s â†¦ colimit.desc F ((Cocones.precompose Î±.inv).obj s)) s",theorem hasColimitOfIso {F G : J â¥¤ C} [HasColimit F] (Î± : G â‰… F) : HasColimit G ,":=
  HasColimit.mk
    { cocone := (Cocones.precompose Î±.hom).obj (colimit.cocone F)
      isColimit := (IsColimit.precomposeHomEquiv _ _).symm (colimit.isColimit F) }",haveI : HasColimit F := hasColimitOfIso F G
Mathlib/Probability/Kernel/RadonNikodym.lean,ProbabilityTheory.kernel.measure_mutuallySingularSetSlice,measure_mutuallySingularSetSlice,1953582979d6fb22253b407bc35a0372934263c5,":= by
  suffices withDensity (Îº + Î·) (fun a x â†¦ Real.toNNReal
      (1 - rnDerivAux Îº (Îº + Î·) a x)) a {x | 1 â‰¤ rnDerivAux Îº (Îº + Î·) a x} = 0 by
    rwa [withDensity_one_sub_rnDerivAux Îº Î·] at this
  simp_rw [ofNNReal_toNNReal]
  rw [kernel.withDensity_apply', lintegral_eq_zero_iff, EventuallyEq, ae_restrict_iff]
  rotate_left
  Â· exact (measurable_const.sub
      ((measurable_rnDerivAux _ _).comp measurable_prod_mk_left)).ennreal_ofReal
      (measurableSet_singleton _)
  Â· exact (measurable_const.sub
      ((measurable_rnDerivAux _ _).comp measurable_prod_mk_left)).ennreal_ofReal
  Â· exact (measurable_const.sub (measurable_rnDerivAux _ _)).ennreal_ofReal
  refine ae_of_all _ (fun x hx â†¦ ?_)
  simp only [mem_setOf_eq] at hx
  simp [hx]","error:  unknown identifier 'ofNNReal_toNNReal'
error:  simp made no progress","lemma measure_mutuallySingularSetSlice (Îº Î· : kernel Î± Î³) [IsFiniteKernel Îº] [IsFiniteKernel Î·]
    (a : Î±) :
    Î· a (mutuallySingularSetSlice Îº Î· a) = 0 ",":= by
  have h_coe : âˆ€ b, (Real.toNNReal b : â„â‰¥0âˆ) = ENNReal.ofReal b := fun _ â†¦ rfl
  suffices withDensity (Îº + Î·) (fun a x â†¦ Real.toNNReal
      (1 - rnDerivAux Îº (Îº + Î·) a x)) a {x | 1 â‰¤ rnDerivAux Îº (Îº + Î·) a x} = 0 by
    rwa [withDensity_one_sub_rnDerivAux Îº Î·] at this
  simp_rw [h_coe]
  rw [kernel.withDensity_apply', lintegral_eq_zero_iff, EventuallyEq, ae_restrict_iff]
  rotate_left
  Â· exact (measurable_const.sub
      ((measurable_rnDerivAux _ _).comp measurable_prod_mk_left)).ennreal_ofReal
      (measurableSet_singleton _)
  Â· exact (measurable_const.sub
      ((measurable_rnDerivAux _ _).comp measurable_prod_mk_left)).ennreal_ofReal
  Â· exact (measurable_const.sub (measurable_rnDerivAux _ _)).ennreal_ofReal
  refine ae_of_all _ (fun x hx â†¦ ?_)
  simp only [mem_setOf_eq] at hx
  simp [hx]",rw [kernel.measure_mutuallySingularSetSlice]
Mathlib/Analysis/InnerProductSpace/Basic.lean,OrthogonalFamily.summable_iff_norm_sq_summable,OrthogonalFamily.summable_iff_norm_sq_summable,1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493,":= by
  classical
    simp only [summable_iff_cauchySeq_finset, NormedAddCommGroup.cauchySeq_iff, Real.norm_eq_abs]
    constructor
    Â· intro hf Îµ hÎµ
      obtain âŸ¨a, HâŸ© := hf _ (sqrt_pos.mpr hÎµ)
      use a
      intro sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      rw [â† Finset.sum_sdiff_sub_sum_sdiff]
      refine (abs_sub _ _).trans_lt ?_
      have : âˆ€ i, 0 â‰¤ â€–f iâ€– ^ 2 := fun i : Î¹ => sq_nonneg _
      simp only [Finset.abs_sum_of_nonneg' this]
      have : ((âˆ‘ i âˆˆ sâ‚ \ sâ‚‚, â€–f iâ€– ^ 2) + âˆ‘ i âˆˆ sâ‚‚ \ sâ‚, â€–f iâ€– ^ 2) < âˆšÎµ ^ 2 := by
        rw [â† hV.norm_sq_diff_sum, sq_lt_sq, abs_of_nonneg (sqrt_nonneg _),
          abs_of_nonneg (norm_nonneg _)]
        exact H sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      have hÎ· := sq_sqrt (le_of_lt hÎµ)
      linarith
    Â· intro hf Îµ hÎµ
      have hÎµ' : 0 < Îµ ^ 2 / 2 := half_pos (sq_pos_of_pos hÎµ)
      obtain âŸ¨a, HâŸ© := hf _ hÎµ'
      use a
      intro sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      refine (abs_lt_of_sq_lt_sq' ?_ (le_of_lt hÎµ)).2
      have has : a â‰¤ sâ‚ âŠ“ sâ‚‚ := le_inf hsâ‚ hsâ‚‚
      rw [hV.norm_sq_diff_sum]
      have Hsâ‚ : âˆ‘ x âˆˆ sâ‚ \ sâ‚‚, â€–f xâ€– ^ 2 < Îµ ^ 2 / 2 := by
        convert H _ hsâ‚ _ has
        have : sâ‚ âŠ“ sâ‚‚ âŠ† sâ‚ := Finset.inter_subset_left _ _
        rw [â† Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        Â· simp
        Â· exact fun i => sq_nonneg _
      have Hsâ‚‚ : âˆ‘ x âˆˆ sâ‚‚ \ sâ‚, â€–f xâ€– ^ 2 < Îµ ^ 2 / 2 := by
        convert H _ hsâ‚‚ _ has
        have : sâ‚ âŠ“ sâ‚‚ âŠ† sâ‚‚ := Finset.inter_subset_right _ _
        rw [â† Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        Â· simp
        Â· exact fun i => sq_nonneg _
      linarith","error:  function expected at
  Finset.inter_subset_left ?m.1083968
term has type
  ?m.1083967 âˆˆ ?m.1083965
error:  function expected at
  Finset.inter_subset_right ?m.1089317
term has type
  ?m.1089316 âˆˆ ?m.1089315","theorem OrthogonalFamily.summable_iff_norm_sq_summable [CompleteSpace E] (f : âˆ€ i, G i) :
    (Summable fun i => V i (f i)) â†” Summable fun i => â€–f iâ€– ^ 2 ",":= by
  classical
    simp only [summable_iff_cauchySeq_finset, NormedAddCommGroup.cauchySeq_iff, Real.norm_eq_abs]
    constructor
    Â· intro hf Îµ hÎµ
      obtain âŸ¨a, HâŸ© := hf _ (sqrt_pos.mpr hÎµ)
      use a
      intro sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      rw [â† Finset.sum_sdiff_sub_sum_sdiff]
      refine (abs_sub _ _).trans_lt ?_
      have : âˆ€ i, 0 â‰¤ â€–f iâ€– ^ 2 := fun i : Î¹ => sq_nonneg _
      simp only [Finset.abs_sum_of_nonneg' this]
      have : ((âˆ‘ i âˆˆ sâ‚ \ sâ‚‚, â€–f iâ€– ^ 2) + âˆ‘ i âˆˆ sâ‚‚ \ sâ‚, â€–f iâ€– ^ 2) < âˆšÎµ ^ 2 := by
        rw [â† hV.norm_sq_diff_sum, sq_lt_sq, abs_of_nonneg (sqrt_nonneg _),
          abs_of_nonneg (norm_nonneg _)]
        exact H sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      have hÎ· := sq_sqrt (le_of_lt hÎµ)
      linarith
    Â· intro hf Îµ hÎµ
      have hÎµ' : 0 < Îµ ^ 2 / 2 := half_pos (sq_pos_of_pos hÎµ)
      obtain âŸ¨a, HâŸ© := hf _ hÎµ'
      use a
      intro sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      refine (abs_lt_of_sq_lt_sq' ?_ (le_of_lt hÎµ)).2
      have has : a â‰¤ sâ‚ âŠ“ sâ‚‚ := le_inf hsâ‚ hsâ‚‚
      rw [hV.norm_sq_diff_sum]
      have Hsâ‚ : âˆ‘ x âˆˆ sâ‚ \ sâ‚‚, â€–f xâ€– ^ 2 < Îµ ^ 2 / 2 := by
        convert H _ hsâ‚ _ has
        have : sâ‚ âŠ“ sâ‚‚ âŠ† sâ‚ := Finset.inter_subset_left
        rw [â† Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        Â· simp
        Â· exact fun i => sq_nonneg _
      have Hsâ‚‚ : âˆ‘ x âˆˆ sâ‚‚ \ sâ‚, â€–f xâ€– ^ 2 < Îµ ^ 2 / 2 := by
        convert H _ hsâ‚‚ _ has
        have : sâ‚ âŠ“ sâ‚‚ âŠ† sâ‚‚ := Finset.inter_subset_right
        rw [â† Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        Â· simp
        Â· exact fun i => sq_nonneg _
      linarith","refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©"
Mathlib/Combinatorics/Additive/FreimanHom.lean,IsMulFreimanIso.prod,IsMulFreimanIso.prod,754ba19de1471fd928c4fa0cc102d1f06f90e902,"  bijOn := hâ‚.bijOn.prodMap hâ‚‚.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [mem_prod, forall_and, Prod.forall] at hsA htA
    simp only [Prod.map_apply, Prod.ext_iff, fst_prod, map_map, Function.comp_apply, snd_prod]
    rw [â† Function.comp_def, â† map_map, â† map_map, â† Function.comp_def fâ‚‚, â† map_map, â† map_map,
      hâ‚.map_prod_eq_map_prod (by simpa using hsA.1) (by simpa using htA.1) (by simpa) (by simpa),
      hâ‚‚.map_prod_eq_map_prod (by simpa [@forall_swap Î±â‚] using hsA.2)
      (by simpa [@forall_swap Î±â‚] using htA.2) (by simpa) (by simpa)]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  fun x â†¦ fâ‚‚ (?g x)
F : Type u_1
Î± : Type u_2
Î² : Type u_3
Î³ : Type u_4
Î±â‚ : Type u_5
Î±â‚‚ : Type u_6
Î²â‚ : Type u_7
Î²â‚‚ : Type u_8
instâœÂ³ : CommMonoid Î±â‚
instâœÂ² : CommMonoid Î±â‚‚
instâœÂ¹ : CommMonoid Î²â‚
instâœ : CommMonoid Î²â‚‚
Aâ‚ : Set Î±â‚
Aâ‚‚ : Set Î±â‚‚
Bâ‚ : Set Î²â‚
Bâ‚‚ : Set Î²â‚‚
fâ‚ : Î±â‚ â†’ Î²â‚
fâ‚‚ : Î±â‚‚ â†’ Î²â‚‚
n : â„•
hâ‚ : IsMulFreimanIso n Aâ‚ Bâ‚ fâ‚
hâ‚‚ : IsMulFreimanIso n Aâ‚‚ Bâ‚‚ fâ‚‚
s t : Multiset (Î±â‚ Ã— Î±â‚‚)
hs : card s = n
ht : card t = n
hsA : (âˆ€ (a : Î±â‚) (b : Î±â‚‚), (a, b) âˆˆ s â†’ a âˆˆ Aâ‚) âˆ§ âˆ€ (a : Î±â‚) (b : Î±â‚‚), (a, b) âˆˆ s â†’ b âˆˆ Aâ‚‚
htA : (âˆ€ (a : Î±â‚) (b : Î±â‚‚), (a, b) âˆˆ t â†’ a âˆˆ Aâ‚) âˆ§ âˆ€ (a : Î±â‚) (b : Î±â‚‚), (a, b) âˆˆ t â†’ b âˆˆ Aâ‚‚
âŠ¢ (map Prod.fst (map (Prod.map fâ‚ fâ‚‚) s)).prod = (map Prod.fst (map (Prod.map fâ‚ fâ‚‚) t)).prod âˆ§
      (map (fun x â†¦ (Prod.map fâ‚ fâ‚‚ x).2) s).prod = (map (fun x â†¦ (Prod.map fâ‚ fâ‚‚ x).2) t).prod â†”
    (map Prod.fst s).prod = (map Prod.fst t).prod âˆ§ (map Prod.snd s).prod = (map Prod.snd t).prod","lemma IsMulFreimanIso.prod (hâ‚ : IsMulFreimanIso n Aâ‚ Bâ‚ fâ‚) (hâ‚‚ : IsMulFreimanIso n Aâ‚‚ Bâ‚‚ fâ‚‚) :
    IsMulFreimanIso n (Aâ‚ Ã—Ë¢ Aâ‚‚) (Bâ‚ Ã—Ë¢ Bâ‚‚) (Prod.map fâ‚ fâ‚‚) where
","  bijOn := hâ‚.bijOn.prodMap hâ‚‚.bijOn
  map_prod_eq_map_prod s t hsA htA hs ht := by
    simp only [mem_prod, forall_and, Prod.forall] at hsA htA
    simp only [Prod.ext_iff, fst_prod, map_map, Function.comp_apply, Prod.map_fst, snd_prod,
      Prod.map_snd]
    rw [â† Function.comp_def, â† map_map, â† map_map, â† Function.comp_def fâ‚‚, â† map_map, â† map_map,
      hâ‚.map_prod_eq_map_prod (by simpa using hsA.1) (by simpa using htA.1) (by simpa) (by simpa),
      hâ‚‚.map_prod_eq_map_prod (by simpa [@forall_swap Î±â‚] using hsA.2)
      (by simpa [@forall_swap Î±â‚] using htA.2) (by simpa) (by simpa)]","simp only [IsMulFreimanIso.prod, IsMulFreimanIso.prod, IsMulFreimanIso.hprod,
  IsMulFreimanIso.hprod]"
Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean,Real.Angle.cos_eq_real_cos_iff_eq_or_eq_neg,cos_eq_real_cos_iff_eq_or_eq_neg,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction Î¸
  exact cos_eq_iff_coe_eq_or_eq_neg","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Î¸ : Angle
Ïˆ : â„
âŠ¢ Î¸.cos = Real.cos Ïˆ â†” Î¸ = â†‘Ïˆ âˆ¨ Î¸ = -â†‘Ïˆ","theorem cos_eq_real_cos_iff_eq_or_eq_neg {Î¸ : Angle} {Ïˆ : â„} :
    cos Î¸ = Real.cos Ïˆ â†” Î¸ = Ïˆ âˆ¨ Î¸ = -Ïˆ ",":= by
  induction Î¸ using Real.Angle.induction_on
  exact cos_eq_iff_coe_eq_or_eq_neg","simp only [cos_eq_real_cos_iff_eq_or_eq_neg, cos_eq_real_cos_iff_eq_or_eq_neg]"
Mathlib/Data/Nat/Pairing.lean,Nat.pair_lt_max_add_one_sq,pair_lt_max_add_one_sq,e340032faef5a8ec252e988e6968b4f6b30277da,":= by
  simp only [pair, Nat.pow_two, Nat.mul_add, Nat.add_mul, Nat.mul_one, Nat.one_mul,
    â† Nat.add_assoc']
  split_ifs <;> simp [Nat.max_eq_left, Nat.max_eq_right, Nat.le_of_lt,  not_lt.1, *] <;> omega",error:  unknown constant 'Nat.add_assoc'',theorem pair_lt_max_add_one_sq (m n : â„•) : pair m n < (max m n + 1) ^ 2 ,":= by
  simp only [pair, Nat.pow_two, Nat.mul_add, Nat.add_mul, Nat.mul_one, Nat.one_mul, Nat.add_assoc]
  split_ifs <;> simp [Nat.max_eq_left, Nat.max_eq_right, Nat.le_of_lt,  not_lt.1, *] <;> omega","rw [pair_lt_max_add_one_sq, pair_lt_max_add_one_sq]"
Mathlib/CategoryTheory/Sites/Coverage.lean,CategoryTheory.Coverage.eq_top_pullback,eq_top_pullback,92beef58f265528359880ded59e9a73d818a6596,":= by
  ext Z ; intro g
  simp only [Sieve.pullback_apply, Sieve.top_apply, iff_true]
  apply h
  apply S.downward_closed
  exact hf","error:  tactic 'introN' failed, insufficient number of binders
case h
C : Type u_2
D : Type ?u.34038
instâœÂ¹ : Category.{u_1, u_2} C
instâœ : Category.{?u.34046, ?u.34038} D
X Y : C
S T : Sieve X
h : S â‰¤ T
f : Y âŸ¶ X
hf : S.arrows f
Z : C
fâœ : Z âŸ¶ Y
âŠ¢ (Sieve.pullback f T).arrows fâœ â†” âŠ¤.arrows fâœ","lemma eq_top_pullback {X Y : C} {S T : Sieve X} (h : S â‰¤ T) (f : Y âŸ¶ X) (hf : S f) :
    T.pullback f = âŠ¤ ",":= by
  ext Z g
  simp only [Sieve.pullback_apply, Sieve.top_apply, iff_true]
  apply h
  apply S.downward_closed
  exact hf",rw [eq_top_pullback]
Mathlib/Analysis/NormedSpace/Spectrum.lean,QuasispectrumRestricts.real_iff,real_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine âŸ¨fun h x hx â†¦ ?_, fun h â†¦ ?_âŸ©
  Â· obtain âŸ¨x, -, rflâŸ© := h.algebraMap_image.symm â–¸ hx
    simp
  Â· exact .of_subset_range_algebraMap _ _ Complex.ofReal_re fun x hx â†¦ âŸ¨x.re, (h x hx).symmâŸ©","error:  function expected at
  of_subset_range_algebraMap ?m.390389 ?m.390390
term has type
  SpectrumRestricts ?m.390387 ?m.390388","lemma real_iff [Algebra â„‚ A] {a : A} :
    SpectrumRestricts a Complex.reCLM â†” âˆ€ x âˆˆ spectrum â„‚ a, x = x.re ",":= by
  refine âŸ¨fun h x hx â†¦ ?_, fun h â†¦ ?_âŸ©
  Â· obtain âŸ¨x, -, rflâŸ© := h.algebraMap_image.symm â–¸ hx
    simp
  Â· exact .of_subset_range_algebraMap Complex.ofReal_re fun x hx â†¦ âŸ¨x.re, (h x hx).symmâŸ©",constructor
Mathlib/CategoryTheory/Closed/Functor.lean,CategoryTheory.expComparison_whiskerLeft,expComparison_whiskerLeft,565b3377dc3477a9806f4e6db16008ee47fd08ed,":= by
  unfold expComparison pre
  have vcomp1 := MatesConjugates_vcomp
    (exp.adjunction A) (exp.adjunction (F.obj A)) (exp.adjunction (F.obj A'))
    ((prodComparisonNatIso F A).inv) ((prod.functor.map (F.map f)))
  have vcomp2 := ConjugatesMates_vcomp
    (exp.adjunction A) (exp.adjunction A') (exp.adjunction (F.obj A'))
    ((prod.functor.map f)) ((prodComparisonNatIso F A').inv)
  unfold LeftAdjointSquareConjugate.vcomp RightAdjointSquareConjugate.vcomp at vcomp1
  unfold LeftAdjointConjugateSquare.vcomp RightAdjointConjugateSquare.vcomp at vcomp2
  rw [â† vcomp1, â† vcomp2]
  apply congr_arg
  ext B
  simp only [Functor.comp_obj, prod.functor_obj_obj, prodComparisonNatIso_inv, asIso_inv,
    NatTrans.comp_app, whiskerLeft_app, prod.functor_map_app, NatIso.isIso_inv_app,
    whiskerRight_app]
  have piso := (prodComparison_inv_natural F f (ğŸ™ B)).symm
  rw [â† F.map_id]
  exact piso","error:  unknown identifier 'MatesConjugates_vcomp'
error:  unsolved goals
C : Type u
instâœâ¶ : Category.{v, u} C
D : Type u'
instâœâµ : Category.{v, u'} D
instâœâ´ : HasFiniteProducts C
instâœÂ³ : HasFiniteProducts D
F : C â¥¤ D
L : D â¥¤ C
instâœÂ² : CartesianClosed C
instâœÂ¹ : CartesianClosed D
instâœ : PreservesLimitsOfShape (Discrete WalkingPair) F
A A' : C
f : A' âŸ¶ A
âŠ¢ (transferNatTrans (exp.adjunction A) (exp.adjunction (F.obj A))) (prodComparisonNatIso F A).inv â‰«
      whiskerLeft F
        ((transferNatTransSelf (exp.adjunction (F.obj A)) (exp.adjunction (F.obj A'))) (prod.functor.map (F.map f))) =
    whiskerRight ((transferNatTransSelf (exp.adjunction A) (exp.adjunction A')) (prod.functor.map f)) F â‰«
      (transferNatTrans (exp.adjunction A') (exp.adjunction (F.obj A'))) (prodComparisonNatIso F A').inv","theorem expComparison_whiskerLeft {A A' : C} (f : A' âŸ¶ A) :
    expComparison F A â‰« whiskerLeft _ (pre (F.map f)) =
      whiskerRight (pre f) _ â‰« expComparison F A' ",":= by
  ext B
  dsimp
  apply uncurry_injective
  rw [uncurry_natural_left, uncurry_natural_left, uncurry_expComparison, uncurry_pre,
    prod.map_swap_assoc, â† F.map_id, expComparison_ev, â† F.map_id, â†
    prodComparison_inv_natural_assoc, â† prodComparison_inv_natural_assoc, â† F.map_comp, â†
    F.map_comp, prod_map_pre_app_comp_ev]",exact expComparison_whiskerLeft_whiskerRight F A' f
Mathlib/MeasureTheory/Function/ConditionalExpectation/Basic.lean,MeasureTheory.condexp_finset_sum,condexp_finset_sum,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' s with i s his heq hf
  Â· rw [Finset.sum_empty, Finset.sum_empty, condexp_zero]
  Â· rw [Finset.sum_insert his, Finset.sum_insert his]
    exact (condexp_add (hf i <| Finset.mem_insert_self i s) <|
      integrable_finset_sum' _ fun j hmem => hf j <| Finset.mem_insert_of_mem hmem).trans
        ((EventuallyEq.refl _ _).add (heq fun j hmem => hf j <| Finset.mem_insert_of_mem hmem))","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  âˆ‘ x âˆˆ âˆ…, ?m.86520 x
case mk
Î± : Type u_1
F : Type u_2
F' : Type u_3
ğ•œ : Type u_4
p : â„â‰¥0âˆ
instâœâ¶ : RCLike ğ•œ
instâœâµ : NormedAddCommGroup F
instâœâ´ : NormedSpace ğ•œ F
instâœÂ³ : NormedAddCommGroup F'
instâœÂ² : NormedSpace ğ•œ F'
instâœÂ¹ : NormedSpace â„ F'
instâœ : CompleteSpace F'
m m0 : MeasurableSpace Î±
Î¼ : Measure Î±
fâœ g : Î± â†’ F'
sâœ : Set Î±
Î¹ : Type u_5
f : Î¹ â†’ Î± â†’ F'
i : Multiset Î¹
s : i.Nodup
hf : âˆ€ i_1 âˆˆ { val := i, nodup := s }, Integrable (f i_1) Î¼
âŠ¢ Î¼[âˆ‘ i âˆˆ { val := i, nodup := s }, f i|m] =á¶ [ae Î¼] âˆ‘ i âˆˆ { val := i, nodup := s }, Î¼[f i|m]
error:  no goals to be solved","theorem condexp_finset_sum {Î¹ : Type*} {s : Finset Î¹} {f : Î¹ â†’ Î± â†’ F'}
    (hf : âˆ€ i âˆˆ s, Integrable (f i) Î¼) : Î¼[âˆ‘ i âˆˆ s, f i|m] =áµ[Î¼] âˆ‘ i âˆˆ s, Î¼[f i|m] ",":= by
  induction' s using Finset.induction_on with i s his heq hf
  Â· rw [Finset.sum_empty, Finset.sum_empty, condexp_zero]
  Â· rw [Finset.sum_insert his, Finset.sum_insert his]
    exact (condexp_add (hf i <| Finset.mem_insert_self i s) <|
      integrable_finset_sum' _ fun j hmem => hf j <| Finset.mem_insert_of_mem hmem).trans
        ((EventuallyEq.refl _ _).add (heq fun j hmem => hf j <| Finset.mem_insert_of_mem hmem))","simp only [condexp_finset_sum, condexp_finset_sum]"
Mathlib/MeasureTheory/Measure/HasOuterApproxClosed.lean,MeasureTheory.ext_of_forall_lintegral_eq_of_IsFiniteMeasure,ext_of_forall_lintegral_eq_of_IsFiniteMeasure,b06172d4564b9175743e7c2bc9a24868a9516c7f,":= by
  have key := @measure_isClosed_eq_of_forall_lintegral_eq_of_isFiniteMeasure Î© _ _ _ _ Î¼ Î½ _ h
  apply ext_of_generate_finite _ ?_ isPiSystem_isClosed
  Â· exact fun F F_closed â†¦ key F_closed
  Â· exact key isClosed_univ
  Â· rw [BorelSpace.measurable_eq (Î± := Î©), borel_eq_generateFrom_isClosed]
    rfl",error:  no goals to be solved,"theorem ext_of_forall_lintegral_eq_of_IsFiniteMeasure {Î© : Type*}
    [MeasurableSpace Î©] [TopologicalSpace Î©] [HasOuterApproxClosed Î©]
    [BorelSpace Î©] {Î¼ Î½ : Measure Î©} [IsFiniteMeasure Î¼]
    (h : âˆ€ (f : Î© â†’áµ‡ â„â‰¥0), âˆ«â» x, f x âˆ‚Î¼ = âˆ«â» x, f x âˆ‚Î½) :
    Î¼ = Î½ ",":= by
  have key := @measure_isClosed_eq_of_forall_lintegral_eq_of_isFiniteMeasure Î© _ _ _ _ Î¼ Î½ _ h
  apply ext_of_generate_finite _ ?_ isPiSystem_isClosed
  Â· exact fun F F_closed â†¦ key F_closed
  Â· exact key isClosed_univ
  Â· rw [BorelSpace.measurable_eq (Î± := Î©), borel_eq_generateFrom_isClosed]",simp_rw [ext_of_forall_lintegral_eq_of_isFiniteMeasure_eq_theorem]
Mathlib/Topology/Perfect.lean,exists_perfect_nonempty_of_isClosed_of_not_countable,exists_perfect_nonempty_of_isClosed_of_not_countable,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with âŸ¨V, D, Vct, Dperf, VDâŸ©
  refine' âŸ¨D, âŸ¨Dperf, _âŸ©âŸ©
  constructor
  Â· rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right _ _","error:  function expected at
  subset_union_right ?m.8728
term has type
  ?m.8727 âˆˆ ?m.8725 âˆª ?m.8726","theorem exists_perfect_nonempty_of_isClosed_of_not_countable [SecondCountableTopology Î±]
    (hclosed : IsClosed C) (hunc : Â¬C.Countable) : âˆƒ D : Set Î±, Perfect D âˆ§ D.Nonempty âˆ§ D âŠ† C ",":= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with âŸ¨V, D, Vct, Dperf, VDâŸ©
  refine âŸ¨D, âŸ¨Dperf, ?_âŸ©âŸ©
  constructor
  Â· rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right",rw [exists_perfect_nonempty_of_isClosed_of_not_countable] at hunc
Mathlib/MeasureTheory/Function/ConditionalExpectation/Real.lean,MeasureTheory.ae_bdd_condexp_of_ae_bdd,ae_bdd_condexp_of_ae_bdd,f604017518b0630e4b4304f4db58858db24b64e6,":= by
  by_cases hnm : m â‰¤ m0
  swap
  Â· simp_rw [condexp_of_not_le hnm, Pi.zero_apply, abs_zero]
    refine' eventually_of_forall fun _ => R.coe_nonneg
  by_cases hfint : Integrable f Î¼
  swap
  Â· simp_rw [condexp_undef hfint]
    filter_upwards [hbdd] with x hx
    rw [Pi.zero_apply, abs_zero]
    exact (abs_nonneg _).trans hx
  by_contra h
  change Î¼ _ â‰  0 at h
  simp only [â† zero_lt_iff, Set.compl_def, Set.mem_setOf_eq, not_le] at h
  suffices (Î¼ {x | â†‘R < |(Î¼[f|m]) x|}).toReal * â†‘R < (Î¼ {x | â†‘R < |(Î¼[f|m]) x|}).toReal * â†‘R by
    exact this.ne rfl
  refine' lt_of_lt_of_le (set_integral_gt_gt R.coe_nonneg _ _ h.ne.symm) _
  Â· simp_rw [â† Real.norm_eq_abs]
    exact (stronglyMeasurable_condexp.mono hnm).measurable.norm
  Â· exact integrable_condexp.abs.integrableOn
  refine' (set_integral_abs_condexp_le _ _).trans _
  Â· simp_rw [â† Real.norm_eq_abs]
    exact @measurableSet_lt _ _ _ _ _ m _ _ _ _ _ measurable_const
      stronglyMeasurable_condexp.norm.measurable
  simp only [â† smul_eq_mul, â† set_integral_const, NNReal.val_eq_coe, IsROrC.ofReal_real_eq_id,
    id.def]
  refine' set_integral_mono_ae hfint.abs.integrableOn _ hbdd
  refine' âŸ¨aestronglyMeasurable_const, lt_of_le_of_lt _
    (integrable_condexp.integrableOn : IntegrableOn (Î¼[f|m]) {x | â†‘R < |(Î¼[f|m]) x|} Î¼).2âŸ©
  refine' set_lintegral_mono measurable_const.nnnorm.coe_nnreal_ennreal
    (stronglyMeasurable_condexp.mono hnm).measurable.nnnorm.coe_nnreal_ennreal fun x hx => _
  rw [ENNReal.coe_le_coe, Real.nnnorm_of_nonneg R.coe_nonneg]
  exact Subtype.mk_le_mk.2 (le_of_lt hx)","warning:  `MeasureTheory.set_integral_gt_gt` has been deprecated, use `MeasureTheory.setIntegral_gt_gt` instead
warning:  `MeasureTheory.set_integral_abs_condexp_le` has been deprecated, use `MeasureTheory.setIntegral_abs_condexp_le` instead
warning:  `MeasureTheory.set_integral_const` has been deprecated, use `MeasureTheory.setIntegral_const` instead
error:  unknown identifier 'IsROrC.ofReal_real_eq_id'
error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.55844 â†’ ?m.55844
  
  unknown constant 'ContinuousLinearMap.id.def'
warning:  `MeasureTheory.set_integral_mono_ae` has been deprecated, use `MeasureTheory.setIntegral_mono_ae` instead
warning:  `MeasureTheory.set_lintegral_mono` has been deprecated, use `MeasureTheory.setLIntegral_mono` instead","theorem ae_bdd_condexp_of_ae_bdd {R : â„â‰¥0} {f : Î± â†’ â„} (hbdd : âˆ€áµ x âˆ‚Î¼, |f x| â‰¤ R) :
    âˆ€áµ x âˆ‚Î¼, |(Î¼[f|m]) x| â‰¤ R ",":= by
  by_cases hnm : m â‰¤ m0
  swap
  Â· simp_rw [condexp_of_not_le hnm, Pi.zero_apply, abs_zero]
    exact eventually_of_forall fun _ => R.coe_nonneg
  by_cases hfint : Integrable f Î¼
  swap
  Â· simp_rw [condexp_undef hfint]
    filter_upwards [hbdd] with x hx
    rw [Pi.zero_apply, abs_zero]
    exact (abs_nonneg _).trans hx
  by_contra h
  change Î¼ _ â‰  0 at h
  simp only [â† zero_lt_iff, Set.compl_def, Set.mem_setOf_eq, not_le] at h
  suffices (Î¼ {x | â†‘R < |(Î¼[f|m]) x|}).toReal * â†‘R < (Î¼ {x | â†‘R < |(Î¼[f|m]) x|}).toReal * â†‘R by
    exact this.ne rfl
  refine lt_of_lt_of_le (setIntegral_gt_gt R.coe_nonneg ?_ ?_ h.ne.symm) ?_
  Â· simp_rw [â† Real.norm_eq_abs]
    exact (stronglyMeasurable_condexp.mono hnm).measurable.norm
  Â· exact integrable_condexp.abs.integrableOn
  refine (setIntegral_abs_condexp_le ?_ _).trans ?_
  Â· simp_rw [â† Real.norm_eq_abs]
    exact @measurableSet_lt _ _ _ _ _ m _ _ _ _ _ measurable_const
      stronglyMeasurable_condexp.norm.measurable
  simp only [â† smul_eq_mul, â† setIntegral_const, NNReal.val_eq_coe, RCLike.ofReal_real_eq_id,
    _root_.id]
  refine setIntegral_mono_ae hfint.abs.integrableOn ?_ hbdd
  refine âŸ¨aestronglyMeasurable_const, lt_of_le_of_lt ?_
    (integrable_condexp.integrableOn : IntegrableOn (Î¼[f|m]) {x | â†‘R < |(Î¼[f|m]) x|} Î¼).2âŸ©
  refine setLIntegral_mono measurable_const.nnnorm.coe_nnreal_ennreal
    (stronglyMeasurable_condexp.mono hnm).measurable.nnnorm.coe_nnreal_ennreal fun x hx => ?_
  rw [ENNReal.coe_le_coe, Real.nnnorm_of_nonneg R.coe_nonneg]
  exact Subtype.mk_le_mk.2 (le_of_lt hx)",refine ae_bdd_condexp_of_ae_bdd.theorem_eventuallyLE ?_
Mathlib/MeasureTheory/MeasurableSpace/Basic.lean,exists_measurable_piecewise,exists_measurable_piecewise,4449fea6cb71b0c9863e5f2aaa338fd940fe3afa,":= by
  inhabit Î¹
  set g' : (i : Î¹) â†’ t i â†’ Î² := fun i => g i âˆ˜ (â†‘)
  have ht' : âˆ€ (i j) (x : Î±) (hxi : x âˆˆ t i) (hxj : x âˆˆ t j), g' i âŸ¨x, hxiâŸ© = g' j âŸ¨x, hxjâŸ©
  Â· intro i j x hxi hxj
    rcases eq_or_ne i j with rfl | hij
    Â· rfl
    Â· exact ht hij âŸ¨hxi, hxjâŸ©
  set f : (â‹ƒ i, t i) â†’ Î² := iUnionLift t g' ht' _ Subset.rfl
  have hfm : Measurable f := measurable_iUnionLift _ _ t_meas
    (fun i => (hg i).comp measurable_subtype_coe)
  classical
    refine âŸ¨fun x => if hx : x âˆˆ â‹ƒ i, t i then f âŸ¨x, hxâŸ© else g default x,
      hfm.dite ((hg default).comp measurable_subtype_coe) (.iUnion t_meas), fun i x hx => ?_âŸ©
    simp only [dif_pos (mem_iUnion.2 âŸ¨i, hxâŸ©)]
    exact iUnionLift_of_mem âŸ¨x, mem_iUnion.2 âŸ¨i, hxâŸ©âŸ© hx","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Î´ : Type u_4
Î´' : Type u_5
Î¹âœ : Sort uÎ¹
s tâœ u : Set Î±
m : MeasurableSpace Î±
mÎ² : MeasurableSpace Î²
mÎ³ : MeasurableSpace Î³
Î¹ : Type u_6
instâœÂ¹ : Countable Î¹
instâœ : Nonempty Î¹
t : Î¹ â†’ Set Î±
t_meas : âˆ€ (n : Î¹), MeasurableSet (t n)
g : Î¹ â†’ Î± â†’ Î²
hg : âˆ€ (n : Î¹), Measurable (g n)
ht : Pairwise fun i j â†¦ EqOn (g i) (g j) (t i âˆ© t j)
inhabited_h : Inhabited Î¹
g' : (i : Î¹) â†’ â†‘(t i) â†’ Î² := fun i â†¦ g i âˆ˜ Subtype.val
ht' : âˆ€ (i j : Î¹) (x : Î±) (hxi : x âˆˆ t i) (hxj : x âˆˆ t j), g' i âŸ¨x, hxiâŸ© = g' j âŸ¨x, hxjâŸ©
âŠ¢ âˆƒ f, Measurable f âˆ§ âˆ€ (n : Î¹), EqOn f (g n) (t n)","theorem exists_measurable_piecewise {Î¹} [Countable Î¹] [Nonempty Î¹] (t : Î¹ â†’ Set Î±)
    (t_meas : âˆ€ n, MeasurableSet (t n)) (g : Î¹ â†’ Î± â†’ Î²) (hg : âˆ€ n, Measurable (g n))
    (ht : Pairwise fun i j => EqOn (g i) (g j) (t i âˆ© t j)) :
    âˆƒ f : Î± â†’ Î², Measurable f âˆ§ âˆ€ n, EqOn f (g n) (t n) ",":= by
  inhabit Î¹
  set g' : (i : Î¹) â†’ t i â†’ Î² := fun i => g i âˆ˜ (â†‘)
  have ht' : âˆ€ (i j) (x : Î±) (hxi : x âˆˆ t i) (hxj : x âˆˆ t j), g' i âŸ¨x, hxiâŸ© = g' j âŸ¨x, hxjâŸ© := by
    intro i j x hxi hxj
    rcases eq_or_ne i j with rfl | hij
    Â· rfl
    Â· exact ht hij âŸ¨hxi, hxjâŸ©
  set f : (â‹ƒ i, t i) â†’ Î² := iUnionLift t g' ht' _ Subset.rfl
  have hfm : Measurable f := measurable_iUnionLift _ _ t_meas
    (fun i => (hg i).comp measurable_subtype_coe)
  classical
    refine âŸ¨fun x => if hx : x âˆˆ â‹ƒ i, t i then f âŸ¨x, hxâŸ© else g default x,
      hfm.dite ((hg default).comp measurable_subtype_coe) (.iUnion t_meas), fun i x hx => ?_âŸ©
    simp only [dif_pos (mem_iUnion.2 âŸ¨i, hxâŸ©)]
    exact iUnionLift_of_mem âŸ¨x, mem_iUnion.2 âŸ¨i, hxâŸ©âŸ© hx","refine âŸ¨exists_measurable_piecewise fun i j hi => ?_, fun i j hi => ?_âŸ©"
Mathlib/Algebra/Homology/ShortComplex/ConcreteCategory.lean,CategoryTheory.ShortComplex.ShortExact.surjective_g,ShortExact.surjective_g,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  rw [â† Preadditive.epi_iff_injective]
  exact hS.epi_g","error:  unknown constant 'CategoryTheory.Preadditive.epi_iff_injective'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.18582
C : Type u
instâœâ¶ : Category.{v, u} C
instâœâµ : ConcreteCategory C
instâœâ´ : HasForgetâ‚‚ C Ab
instâœÂ³ : Preadditive C
instâœÂ² : (forgetâ‚‚ C Ab).Additive
instâœÂ¹ : (forgetâ‚‚ C Ab).PreservesHomology
instâœ : HasZeroObject C
S : ShortComplex C
hS : S.ShortExact
âŠ¢ Function.Surjective â‡‘((forgetâ‚‚ C Ab).map S.g)","lemma ShortExact.surjective_g (hS : S.ShortExact) :
    Function.Surjective ((forgetâ‚‚ C Ab).map S.g) ",":= by
  rw [â† Preadditive.epi_iff_surjective]
  exact hS.epi_g","simp only [Function.Surjective, Function.Surjective]"
Mathlib/Data/Int/Cast/Lemmas.lean,RingHom.ext_int,ext_int,93812b0faaaed21290db2b79c325e1dbaecd4dce,":=
  have : f.comp (Int.ofNatHom : â„• â†’+ â„¤) = g.comp (Int.ofNatHom : â„• â†’+ â„¤) := ext_nat' _ _ h1
  have this' : âˆ€ n : â„•, f n = g n := ext_iff.1 this
  ext fun n => match n with
  | (n : â„•) => this' n
  | .negSucc n => eq_on_neg _ _ (this' <| n + 1)",error:  unknown identifier 'ext_iff',theorem ext_int [AddMonoid A] {f g : â„¤ â†’+ A} (h1 : f 1 = g 1) : f = g ,":=
  have : f.comp (Int.ofNatHom : â„• â†’+ â„¤) = g.comp (Int.ofNatHom : â„• â†’+ â„¤) := ext_nat' _ _ h1
  have this' : âˆ€ n : â„•, f n = g n := DFunLike.ext_iff.1 this
  ext fun n => match n with
  | (n : â„•) => this' n
  | .negSucc n => eq_on_neg _ _ (this' <| n + 1)","simp [f, g, h1]"
Mathlib/Data/List/ReduceOption.lean,List.reduceOption_length_eq_iff,reduceOption_length_eq_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  induction' l with hd tl hl
  Â· simp only [forall_const, reduceOption_nil, not_mem_nil, forall_prop_of_false, eq_self_iff_true,
      length, not_false_iff]
  Â· cases hd
    Â· simp only [mem_cons, forall_eq_or_imp, Bool.coe_sort_false, false_and_iff,
        reduceOption_cons_of_none, length, Option.isSome_none, iff_false_iff]
      intro H
      have := reduceOption_length_le tl
      rw [H] at this
      exact absurd (Nat.lt_succ_self _) (not_lt_of_le this)
    Â· simp only [length, mem_cons, forall_eq_or_imp, Option.isSome_some, â† hl, reduceOption,
        true_and]
      omega",error:  unknown constant 'Bool.coe_sort_false',"theorem reduceOption_length_eq_iff {l : List (Option Î±)} :
    l.reduceOption.length = l.length â†” âˆ€ x âˆˆ l, Option.isSome x ",":= by
  rw [reduceOption_length_eq, List.filter_length_eq_length]",simp only [reduceOption_length_eq_iff]
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.withDensity_le_mul,withDensity_le_mul,611a64b31f2f9df551954217d12578133430d2b6,":= by
  have t_ne_zero' : t â‰  0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : â„â‰¥0âˆ) â‰  0 := by simpa only [ENNReal.coe_eq_zero, Ne.def] using t_ne_zero'
  let Î½ := Î¼.withDensity (v.limRatioMeas hÏ)
  let f := v.limRatioMeas hÏ
  have f_meas : Measurable f := v.limRatioMeas_measurable hÏ
  have A : Î½ (s âˆ© f â»Â¹' {0}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) := by
    apply le_trans _ (zero_le _)
    have M : MeasurableSet (s âˆ© f â»Â¹' {0}) := hs.inter (f_meas (measurableSet_singleton _))
    simp only [Î½, nonpos_iff_eq_zero, M, withDensity_apply, lintegral_eq_zero_iff f_meas]
    apply (ae_restrict_iff' M).2
    exact eventually_of_forall fun x hx => hx.2
  have B : Î½ (s âˆ© f â»Â¹' {âˆ}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply withDensity_absolutelyContinuous Î¼ _
    rw [â† nonpos_iff_eq_zero]
    exact (measure_mono (inter_subset_right _ _)).trans (v.measure_limRatioMeas_top hÏ).le
  have C :
    âˆ€ n : â„¤,
      Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) â‰¤
        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))
    have M : MeasurableSet (s âˆ© f â»Â¹' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [Î½, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      (âˆ«â» x in s âˆ© f â»Â¹' I, f x âˆ‚Î¼) â‰¤ âˆ«â» _ in s âˆ© f â»Â¹' I, (t : â„â‰¥0âˆ) ^ (n + 1) âˆ‚Î¼ :=
        lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => hx.2.2.le))
      _ = (t : â„â‰¥0âˆ) ^ (n + 1) * Î¼ (s âˆ© f â»Â¹' I) := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ = (t : â„â‰¥0âˆ) ^ (2 : â„¤) * ((t : â„â‰¥0âˆ) ^ (n - 1) * Î¼ (s âˆ© f â»Â¹' I)) := by
        rw [â† mul_assoc, â† ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top]
        congr 2
        abel
      _ â‰¤ (t : â„â‰¥0âˆ) ^ (2 : â„¤) * Ï (s âˆ© f â»Â¹' I) := by
        gcongr
        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne']
        apply v.mul_measure_le_of_subset_lt_limRatioMeas hÏ
        intro x hx
        apply lt_of_lt_of_le _ hx.2.1
        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne', ENNReal.coe_lt_coe, sub_eq_add_neg,
          zpow_addâ‚€ t_ne_zero']
        conv_rhs => rw [â† mul_one (t ^ n)]
        gcongr
        rw [zpow_neg_one]
        exact inv_lt_one ht
  calc
    Î½ s =
      Î½ (s âˆ© f â»Â¹' {0}) + Î½ (s âˆ© f â»Â¹' {âˆ}) +
        âˆ‘' n : â„¤, Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow Î½ f_meas hs ht
    _ â‰¤
        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) + ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) +
          âˆ‘' n : â„¤, ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico (t ^ n) (t ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï) f_meas hs ht).symm","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.192105 â†’ ?m.192105 â†’ Prop
error:  type mismatch
  hâœ
has type
  t â‰  0 : Prop
but is expected to have type
  â†‘t â‰  0 : Prop
error:  function expected at
  inter_subset_right ?m.195907
term has type
  ?m.195906 âˆˆ ?m.195905","theorem withDensity_le_mul {s : Set Î±} (hs : MeasurableSet s) {t : â„â‰¥0} (ht : 1 < t) :
    Î¼.withDensity (v.limRatioMeas hÏ) s â‰¤ (t : â„â‰¥0âˆ) ^ 2 * Ï s ",":= by
  have t_ne_zero' : t â‰  0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : â„â‰¥0âˆ) â‰  0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let Î½ := Î¼.withDensity (v.limRatioMeas hÏ)
  let f := v.limRatioMeas hÏ
  have f_meas : Measurable f := v.limRatioMeas_measurable hÏ
  have A : Î½ (s âˆ© f â»Â¹' {0}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) := by
    apply le_trans _ (zero_le _)
    have M : MeasurableSet (s âˆ© f â»Â¹' {0}) := hs.inter (f_meas (measurableSet_singleton _))
    simp only [Î½, nonpos_iff_eq_zero, M, withDensity_apply, lintegral_eq_zero_iff f_meas]
    apply (ae_restrict_iff' M).2
    exact eventually_of_forall fun x hx => hx.2
  have B : Î½ (s âˆ© f â»Â¹' {âˆ}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply withDensity_absolutelyContinuous Î¼ _
    rw [â† nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hÏ).le
  have C :
    âˆ€ n : â„¤,
      Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) â‰¤
        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))
    have M : MeasurableSet (s âˆ© f â»Â¹' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [Î½, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      (âˆ«â» x in s âˆ© f â»Â¹' I, f x âˆ‚Î¼) â‰¤ âˆ«â» _ in s âˆ© f â»Â¹' I, (t : â„â‰¥0âˆ) ^ (n + 1) âˆ‚Î¼ :=
        lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => hx.2.2.le))
      _ = (t : â„â‰¥0âˆ) ^ (n + 1) * Î¼ (s âˆ© f â»Â¹' I) := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ = (t : â„â‰¥0âˆ) ^ (2 : â„¤) * ((t : â„â‰¥0âˆ) ^ (n - 1) * Î¼ (s âˆ© f â»Â¹' I)) := by
        rw [â† mul_assoc, â† ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top]
        congr 2
        abel
      _ â‰¤ (t : â„â‰¥0âˆ) ^ (2 : â„¤) * Ï (s âˆ© f â»Â¹' I) := by
        gcongr
        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne']
        apply v.mul_measure_le_of_subset_lt_limRatioMeas hÏ
        intro x hx
        apply lt_of_lt_of_le _ hx.2.1
        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne', ENNReal.coe_lt_coe, sub_eq_add_neg,
          zpow_addâ‚€ t_ne_zero']
        conv_rhs => rw [â† mul_one (t ^ n)]
        gcongr
        rw [zpow_neg_one]
        exact inv_lt_one ht
  calc
    Î½ s =
      Î½ (s âˆ© f â»Â¹' {0}) + Î½ (s âˆ© f â»Â¹' {âˆ}) +
        âˆ‘' n : â„¤, Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow Î½ f_meas hs ht
    _ â‰¤
        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) + ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) +
          âˆ‘' n : â„¤, ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico (t ^ n) (t ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï) f_meas hs ht).symm",refine (withDensity_le_mul hs t ht).trans ?_
Mathlib/FieldTheory/PrimitiveElement.lean,Field.exists_primitive_element_of_finite_top,exists_primitive_element_of_finite_top,a76dc22f3a90e5ab96e9284d30276a87a4324a5d,":= by
  obtain âŸ¨Î±, hÎ±âŸ© := @IsCyclic.exists_generator EË£ _ _
  use Î±
  apply eq_top_iff.mpr
  rintro x -
  by_cases hx : x = 0
  Â· rw [hx]
    exact FâŸ®Î±.valâŸ¯.zero_mem
  Â· obtain âŸ¨n, hnâŸ© := Set.mem_range.mp (hÎ± (Units.mk0 x hx))
    simp only at hn
    rw [show x = Î± ^ n by norm_cast; rw [hn, Units.val_mk0], Units.val_zpow_eq_zpow_val]
    exact zpow_mem (mem_adjoin_simple_self F (E := E) â†‘Î±) n",error:  simp made no progress,"theorem exists_primitive_element_of_finite_top [Finite E] : âˆƒ Î± : E, FâŸ®Î±âŸ¯ = âŠ¤ ",":= by
  obtain âŸ¨Î±, hÎ±âŸ© := @IsCyclic.exists_generator EË£ _ _
  use Î±
  rw [eq_top_iff]
  rintro x -
  by_cases hx : x = 0
  Â· rw [hx]
    exact FâŸ®Î±.valâŸ¯.zero_mem
  Â· obtain âŸ¨n, hnâŸ© := Set.mem_range.mp (hÎ± (Units.mk0 x hx))
    rw [show x = Î± ^ n by norm_cast; rw [hn, Units.val_mk0]]
    exact zpow_mem (mem_adjoin_simple_self F (E := E) â†‘Î±) n",cases' exists_primitive_element_of_exists_primitive_element_of_exists_primitive_element_of_exists_primitive_element_of_exists_primitive_element_of_finite
Mathlib/Topology/Homotopy/HomotopyGroup.lean,GenLoop.homotopicFrom,homotopicFrom,0ea5bd2e88bc0475765f0292fb709ff692758ac2,":= by
  refine Nonempty.map fun H => âŸ¨âŸ¨homotopyFrom i H, ?_, ?_âŸ©, ?_âŸ©
  pick_goal 3
  Â· rintro t y âŸ¨j, jHâŸ©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    Â· rw [H.eq_fst]; exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    Â· rw [p.2 _ âŸ¨j, jHâŸ©]; apply boundary; exact âŸ¨âŸ¨j, hâŸ©, jHâŸ©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    first
    | rw [H.apply_zero]
    | rw [H.apply_one]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv","warning:  GenLoop does not have a doc string
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  H (?t, ?x)
case refine_3.intro.inl
N : Type u_1
X : Type u_2
instâœÂ¹ : TopologicalSpace X
x : X
instâœ : DecidableEq N
p q : â†‘(Î©^ N X x)
t : â†‘I
y : N â†’ â†‘I
j : N
jH : y j = 0 âˆ¨ y j = 1
H : Path.Homotopy (toLoop j p) (toLoop j q)
âŠ¢ Function.uncurry (fun x_1 y â†¦ Function.uncurry (fun x_2 y â†¦ â†‘(H (x_1, x_2)) y) y)
      (Prod.map id â‡‘(Cube.splitAt j).toContinuousMap (t, y)) =
    â†‘p y
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  H (1, ?x)
case refine_1
N : Type u_1
X : Type u_2
instâœÂ¹ : TopologicalSpace X
x : X
instâœ : DecidableEq N
i : N
p q : â†‘(Î©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
xâœ : N â†’ â†‘I
âŠ¢ Function.uncurry (fun x_1 y â†¦ Function.uncurry (fun x_2 y â†¦ â†‘(H (x_1, x_2)) y) y)
      (Prod.map id â‡‘(Cube.splitAt i).toContinuousMap (0, xâœ)) =
    â†‘p xâœ
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  H (1, ?x)
case refine_2
N : Type u_1
X : Type u_2
instâœÂ¹ : TopologicalSpace X
x : X
instâœ : DecidableEq N
i : N
p q : â†‘(Î©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
xâœ : N â†’ â†‘I
âŠ¢ Function.uncurry (fun x_1 y â†¦ Function.uncurry (fun x_2 y â†¦ â†‘(H (x_1, x_2)) y) y)
      (Prod.map id â‡‘(Cube.splitAt i).toContinuousMap (1, xâœ)) =
    â†‘q xâœ
error:  unsolved goals
case refine_1
N : Type u_1
X : Type u_2
instâœÂ¹ : TopologicalSpace X
x : X
instâœ : DecidableEq N
i : N
p q : â†‘(Î©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
âŠ¢ âˆ€ (x_1 : N â†’ â†‘I), (homotopyFrom i H).toFun (0, x_1) = â†‘p x_1

case refine_2
N : Type u_1
X : Type u_2
instâœÂ¹ : TopologicalSpace X
x : X
instâœ : DecidableEq N
i : N
p q : â†‘(Î©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
âŠ¢ âˆ€ (x_1 : N â†’ â†‘I), (homotopyFrom i H).toFun (1, x_1) = â†‘q x_1","theorem homotopicFrom (i : N) {p q : Î©^ N X x} :
    (toLoop i p).Homotopic (toLoop i q) â†’ Homotopic p q ",":= by
  refine Nonempty.map fun H => âŸ¨âŸ¨homotopyFrom i H, ?_, ?_âŸ©, ?_âŸ©
  pick_goal 3
  Â· rintro t y âŸ¨j, jHâŸ©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    Â· simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
        Function.uncurry_apply_pair]
      rw [H.eq_fst]
      exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    Â· rw [p.2 _ âŸ¨j, jHâŸ©]; apply boundary; exact âŸ¨âŸ¨j, hâŸ©, jHâŸ©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
      Function.uncurry_apply_pair, ContinuousMap.HomotopyWith.apply_zero,
      ContinuousMap.HomotopyWith.apply_one, ne_eq, Path.coe_toContinuousMap, toLoop_apply_coe,
      ContinuousMap.curry_apply, ContinuousMap.comp_apply]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv",simp only [Homotopic]
Mathlib/Algebra/Lie/InvariantForm.lean,LieAlgebra.InvariantForm.atomistic,atomistic,08bbfa2463d2acd9d80762f3f528516e41b2de13,":= by
  intro I
  apply le_antisymm
  Â· apply sSup_le
    rintro J âŸ¨-, hJ'âŸ©
    exact hJ'
  by_cases hI : I = âŠ¥
  Â· exact hI.le.trans bot_le
  obtain âŸ¨J, hJ, hJIâŸ© := exists_atom_le_of_finite I hI
  let J' := orthogonalLieIdeal Î¦ hÎ¦_inv J
  suffices I â‰¤ J âŠ” (J' âŠ“ I) by
    refine this.trans ?_
    apply sup_le
    Â· exact le_sSup âŸ¨hJ, hJIâŸ©
    rw [â† atomistic (J' âŠ“ I)]
    apply sSup_le_sSup
    simp only [le_inf_iff, Set.setOf_subset_setOf, and_imp]
    tauto
  suffices J âŠ” J' = âŠ¤ by rw [â† sup_inf_assoc_of_le _ hJI, this, top_inf_eq]
  exact (orthogonalLieIdeal_isCompl hL Î¦ hÎ¦_inv hÎ¦_nondeg hÎ¦_refl J hJ).codisjoint.eq_top","error:  unknown identifier 'exists_atom_le_of_finite'
error:  rcases tactic failed: xâœ : ?m.84517 is not an inductive datatype
error:  unused termination hints, function is not recursive
error:  application type mismatch
  atomistic Î¦
argument
  Î¦
has type
  LinearMap.BilinForm K L : Type (max u_1 u_2)
but is expected to have type
  LieIdeal ?m.87608 ?m.87609 : Type ?u.87606","lemma atomistic : âˆ€ I : LieIdeal K L, sSup {J : LieIdeal K L | IsAtom J âˆ§ J â‰¤ I} = I ",":= by
  intro I
  apply le_antisymm
  Â· apply sSup_le
    rintro J âŸ¨-, hJ'âŸ©
    exact hJ'
  by_cases hI : I = âŠ¥
  Â· exact hI.le.trans bot_le
  obtain âŸ¨J, hJ, hJIâŸ© := (eq_bot_or_exists_atom_le I).resolve_left hI
  let J' := orthogonal Î¦ hÎ¦_inv J
  suffices I â‰¤ J âŠ” (J' âŠ“ I) by
    refine this.trans ?_
    apply sup_le
    Â· exact le_sSup âŸ¨hJ, hJIâŸ©
    rw [â† atomistic (J' âŠ“ I)]
    apply sSup_le_sSup
    simp only [le_inf_iff, Set.setOf_subset_setOf, and_imp]
    tauto
  suffices J âŠ” J' = âŠ¤ by rw [â† sup_inf_assoc_of_le _ hJI, this, top_inf_eq]
  exact (orthogonal_isCompl Î¦ hÎ¦_nondeg hÎ¦_inv hÎ¦_refl hL J hJ).codisjoint.eq_top",apply le_antisymm
Mathlib/Analysis/Calculus/FDeriv/Measurable.lean,RightDerivMeasurableAux.D_subset_differentiable_set,D_subset_differentiable_set,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  have P : âˆ€ {n : â„•}, (0 : â„) < (1 / 2) ^ n := fun {n} => pow_pos (by norm_num) n
  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©
  intro x hx
  have :
    âˆ€ e : â„•, âˆƒ n : â„•, âˆ€ p q, n â‰¤ p â†’ n â‰¤ q â†’
      âˆƒ L âˆˆ K, x âˆˆ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) âˆ© A f L ((1 / 2) ^ q) ((1 / 2) ^ e) := by
    intro e
    have := mem_iInter.1 hx e
    rcases mem_iUnion.1 this with âŸ¨n, hnâŸ©
    refine' âŸ¨n, fun p q hp hq => _âŸ©
    simp only [mem_iInter, ge_iff_le] at hn
    rcases mem_iUnion.1 (hn p hp q hq) with âŸ¨L, hLâŸ©
    exact âŸ¨L, exists_prop.mp <| mem_iUnion.1 hLâŸ©
  choose! n L hn using this
  have M :
    âˆ€ e p q e' p' q',
      n e â‰¤ p â†’
        n e â‰¤ q â†’
          n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’ â€–L e p q - L e' p' q'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p q e' p' q' hp hq hp' hq' he'
    let r := max (n e) (n e')
    have I : ((1 : â„) / 2) ^ e' â‰¤ (1 / 2) ^ e :=
      pow_le_pow_of_le_one (by norm_num) (by norm_num) he'
    have J1 : â€–L e p q - L e p râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1
      have I2 : x âˆˆ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1
      exact norm_sub_le_of_mem_A hc P P I1 I2
    have J2 : â€–L e p r - L e' p' râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2
      have I2 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.2
      exact norm_sub_le_of_mem_A hc P P I1 (A_mono _ _ I I2)
    have J3 : â€–L e' p' r - L e' p' q'â€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.1
      have I2 : x âˆˆ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1
      exact norm_sub_le_of_mem_A hc P P (A_mono _ _ I I1) (A_mono _ _ I I2)
    calc
      â€–L e p q - L e' p' q'â€– =
          â€–L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')â€– :=
        by congr 1; abel
      _ â‰¤ â€–L e p q - L e p râ€– + â€–L e p r - L e' p' râ€– + â€–L e' p' r - L e' p' q'â€– :=
        norm_addâ‚ƒ_le _ _ _
      _ â‰¤ 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e := by gcongr
      _ = 12 * â€–câ€– * (1 / 2) ^ e := by ring
  let L0 : â„• â†’ E â†’L[ğ•œ] F := fun e => L e (n e) (n e)
  have : CauchySeq L0 := by
    rw [Metric.cauchySeq_iff']
    intro Îµ Îµpos
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (by positivity) (by norm_num)
    refine' âŸ¨e, fun e' he' => _âŸ©
    rw [dist_comm, dist_eq_norm]
    calc
      â€–L0 e - L0 e'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'
      _ < 12 * â€–câ€– * (Îµ / (12 * â€–câ€–)) := by gcongr
      _ = Îµ := by field_simp; ring
  obtain âŸ¨f', f'K, hf'âŸ© : âˆƒ f' âˆˆ K, Tendsto L0 atTop (ğ“ f') :=
    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this
  have Lf' : âˆ€ e p, n e â‰¤ p â†’ â€–L e (n e) p - f'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p hp
    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm
    rw [eventually_atTop]
    exact âŸ¨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'âŸ©
  have : HasFDerivAt f f' x := by
    simp only [hasFDerivAt_iff_isLittleO_nhds_zero, isLittleO_iff]
    intro Îµ Îµpos
    have pos : 0 < 4 + 12 * â€–câ€– := by positivity
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (4 + 12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (div_pos Îµpos pos) (by norm_num)
    rw [eventually_nhds_iff_ball]
    refine' âŸ¨(1 / 2) ^ (n e + 1), P, fun y hy => _âŸ©
    by_cases y_pos : y = 0;
    Â· simp [y_pos]
    have yzero : 0 < â€–yâ€– := norm_pos_iff.mpr y_pos
    have y_lt : â€–yâ€– < (1 / 2) ^ (n e + 1) := by simpa using mem_ball_iff_norm.1 hy
    have yone : â€–yâ€– â‰¤ 1 := le_trans y_lt.le (pow_le_one _ (by norm_num) (by norm_num))
    obtain âŸ¨k, hk, h'kâŸ© : âˆƒ k : â„•, (1 / 2) ^ (k + 1) < â€–yâ€– âˆ§ â€–yâ€– â‰¤ (1 / 2) ^ k :=
      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : â„) < 1 / 2)
        (by norm_num : (1 : â„) / 2 < 1)
    have k_gt : n e < k := by
      have : ((1 : â„) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_trans hk y_lt
      rw [pow_lt_pow_iff_right_of_lt_one (by norm_num : (0 : â„) < 1 / 2) (by norm_num)] at this
      omega
    set m := k - 1
    have m_ge : n e â‰¤ m := Nat.le_sub_one_of_lt k_gt
    have km : k = m + 1 := (Nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm
    rw [km] at hk h'k
    have J1 : â€–f (x + y) - f x - L e (n e) m (x + y - x)â€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
      apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2
      Â· simp only [mem_closedBall, dist_self]
        positivity
      Â· simpa only [dist_eq_norm, add_sub_cancel', mem_closedBall, pow_succ', mul_one_div] using
          h'k
    have J2 : â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– :=
      calc
        â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
          simpa only [add_sub_cancel'] using J1
        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by field_simp; ring
        _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– := by gcongr
    calc
      â€–f (x + y) - f x - f' yâ€– = â€–f (x + y) - f x - L e (n e) m y + (L e (n e) m - f') yâ€– :=
        congr_arg _ (by simp)
      _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– + 12 * â€–câ€– * (1 / 2) ^ e * â€–yâ€– :=
        norm_add_le_of_le J2 <| (le_opNorm _ _).trans <| by gcongr; exact Lf' _ _ m_ge
      _ = (4 + 12 * â€–câ€–) * â€–yâ€– * (1 / 2) ^ e := by ring
      _ â‰¤ (4 + 12 * â€–câ€–) * â€–yâ€– * (Îµ / (4 + 12 * â€–câ€–)) := by gcongr
      _ = Îµ * â€–yâ€– := by field_simp [ne_of_gt pos]; ring
  rw [â† this.fderiv] at f'K
  exact âŸ¨this.differentiableAt, f'KâŸ©","error:  no goals to be solved
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  type mismatch
  hâœ
has type
  â€–yâ€– â‰¤ 1 / 2 * (1 / 2) ^ m : Prop
but is expected to have type
  â€–yâ€– â‰¤ (1 / 2) ^ m / 2 : Prop
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead","theorem D_subset_differentiable_set {K : Set (E â†’L[ğ•œ] F)} (hK : IsComplete K) :
    D f K âŠ† { x | DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K } ",":= by
  have P : âˆ€ {n : â„•}, (0 : â„) < (1 / 2) ^ n := fun {n} => pow_pos (by norm_num) n
  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©
  intro x hx
  have :
    âˆ€ e : â„•, âˆƒ n : â„•, âˆ€ p q, n â‰¤ p â†’ n â‰¤ q â†’
      âˆƒ L âˆˆ K, x âˆˆ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) âˆ© A f L ((1 / 2) ^ q) ((1 / 2) ^ e) := by
    intro e
    have := mem_iInter.1 hx e
    rcases mem_iUnion.1 this with âŸ¨n, hnâŸ©
    refine âŸ¨n, fun p q hp hq => ?_âŸ©
    simp only [mem_iInter, ge_iff_le] at hn
    rcases mem_iUnion.1 (hn p hp q hq) with âŸ¨L, hLâŸ©
    exact âŸ¨L, exists_prop.mp <| mem_iUnion.1 hLâŸ©
  choose! n L hn using this
  have M :
    âˆ€ e p q e' p' q',
      n e â‰¤ p â†’
        n e â‰¤ q â†’
          n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’ â€–L e p q - L e' p' q'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p q e' p' q' hp hq hp' hq' he'
    let r := max (n e) (n e')
    have I : ((1 : â„) / 2) ^ e' â‰¤ (1 / 2) ^ e :=
      pow_le_pow_of_le_one (by norm_num) (by norm_num) he'
    have J1 : â€–L e p q - L e p râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1
      have I2 : x âˆˆ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1
      exact norm_sub_le_of_mem_A hc P P I1 I2
    have J2 : â€–L e p r - L e' p' râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2
      have I2 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.2
      exact norm_sub_le_of_mem_A hc P P I1 (A_mono _ _ I I2)
    have J3 : â€–L e' p' r - L e' p' q'â€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.1
      have I2 : x âˆˆ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1
      exact norm_sub_le_of_mem_A hc P P (A_mono _ _ I I1) (A_mono _ _ I I2)
    calc
      â€–L e p q - L e' p' q'â€– =
          â€–L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')â€– := by
        congr 1; abel
      _ â‰¤ â€–L e p q - L e p râ€– + â€–L e p r - L e' p' râ€– + â€–L e' p' r - L e' p' q'â€– :=
        norm_addâ‚ƒ_le _ _ _
      _ â‰¤ 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e := by gcongr
      _ = 12 * â€–câ€– * (1 / 2) ^ e := by ring
  let L0 : â„• â†’ E â†’L[ğ•œ] F := fun e => L e (n e) (n e)
  have : CauchySeq L0 := by
    rw [Metric.cauchySeq_iff']
    intro Îµ Îµpos
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (by positivity) (by norm_num)
    refine âŸ¨e, fun e' he' => ?_âŸ©
    rw [dist_comm, dist_eq_norm]
    calc
      â€–L0 e - L0 e'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'
      _ < 12 * â€–câ€– * (Îµ / (12 * â€–câ€–)) := by gcongr
      _ = Îµ := by field_simp
  obtain âŸ¨f', f'K, hf'âŸ© : âˆƒ f' âˆˆ K, Tendsto L0 atTop (ğ“ f') :=
    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this
  have Lf' : âˆ€ e p, n e â‰¤ p â†’ â€–L e (n e) p - f'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p hp
    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm
    rw [eventually_atTop]
    exact âŸ¨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'âŸ©
  have : HasFDerivAt f f' x := by
    simp only [hasFDerivAt_iff_isLittleO_nhds_zero, isLittleO_iff]
    intro Îµ Îµpos
    have pos : 0 < 4 + 12 * â€–câ€– := by positivity
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (4 + 12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (div_pos Îµpos pos) (by norm_num)
    rw [eventually_nhds_iff_ball]
    refine âŸ¨(1 / 2) ^ (n e + 1), P, fun y hy => ?_âŸ©
    by_cases y_pos : y = 0;
    Â· simp [y_pos]
    have yzero : 0 < â€–yâ€– := norm_pos_iff.mpr y_pos
    have y_lt : â€–yâ€– < (1 / 2) ^ (n e + 1) := by simpa using mem_ball_iff_norm.1 hy
    have yone : â€–yâ€– â‰¤ 1 := le_trans y_lt.le (pow_le_one _ (by norm_num) (by norm_num))
    obtain âŸ¨k, hk, h'kâŸ© : âˆƒ k : â„•, (1 / 2) ^ (k + 1) < â€–yâ€– âˆ§ â€–yâ€– â‰¤ (1 / 2) ^ k :=
      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : â„) < 1 / 2)
        (by norm_num : (1 : â„) / 2 < 1)
    have k_gt : n e < k := by
      have : ((1 : â„) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_trans hk y_lt
      rw [pow_lt_pow_iff_right_of_lt_one (by norm_num : (0 : â„) < 1 / 2) (by norm_num)] at this
      omega
    set m := k - 1
    have m_ge : n e â‰¤ m := Nat.le_sub_one_of_lt k_gt
    have km : k = m + 1 := (Nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm
    rw [km] at hk h'k
    have J1 : â€–f (x + y) - f x - L e (n e) m (x + y - x)â€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
      apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2
      Â· simp only [mem_closedBall, dist_self]
        positivity
      Â· simpa only [dist_eq_norm, add_sub_cancel_left, mem_closedBall, pow_succ, mul_one_div] using
          h'k
    have J2 : â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– :=
      calc
        â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
          simpa only [add_sub_cancel_left] using J1
        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by field_simp; ring
        _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– := by gcongr
    calc
      â€–f (x + y) - f x - f' yâ€– = â€–f (x + y) - f x - L e (n e) m y + (L e (n e) m - f') yâ€– :=
        congr_arg _ (by simp)
      _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– + 12 * â€–câ€– * (1 / 2) ^ e * â€–yâ€– :=
        norm_add_le_of_le J2 <| (le_opNorm _ _).trans <| by gcongr; exact Lf' _ _ m_ge
      _ = (4 + 12 * â€–câ€–) * â€–yâ€– * (1 / 2) ^ e := by ring
      _ â‰¤ (4 + 12 * â€–câ€–) * â€–yâ€– * (Îµ / (4 + 12 * â€–câ€–)) := by gcongr
      _ = Îµ * â€–yâ€– := by field_simp [ne_of_gt pos]; ring
  rw [â† this.fderiv] at f'K
  exact âŸ¨this.differentiableAt, f'KâŸ©",simp only [D_subset_differentiable_set] at D_subset_differentiable_set
Mathlib/MeasureTheory/Integral/Lebesgue.lean,MeasureTheory.lintegral_liminf_le,lintegral_liminf_le,3f9dee6adf287742f66dfda5079840cb2497af69,":=
  calc
    âˆ«â» a, liminf (fun n => f n a) atTop âˆ‚Î¼ = âˆ«â» a, â¨† n : â„•, â¨… i â‰¥ n, f i a âˆ‚Î¼ := by
      simp only [liminf_eq_iSup_iInf_of_nat]
    _ = â¨† n : â„•, âˆ«â» a, â¨… i â‰¥ n, f i a âˆ‚Î¼ :=
      (lintegral_iSup' (fun n => aemeasurable_biInf _ (to_countable _) h_meas)
        (ae_of_all Î¼ fun a n m hnm => iInf_le_iInf_of_subset fun i hi => le_trans hnm hi))
    _ â‰¤ â¨† n : â„•, â¨… i â‰¥ n, âˆ«â» a, f i a âˆ‚Î¼ := (iSup_mono fun n => le_iInfâ‚‚_lintegral _)
    _ = atTop.liminf fun n => âˆ«â» a, f n a âˆ‚Î¼ := Filter.liminf_eq_iSup_iInf_of_nat.symm","warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
error:  application type mismatch
  aemeasurable_biInf n.le (to_countable n.le) h_meas
argument
  h_meas
has type
  âˆ€ (n : â„•), AEMeasurable (f n) Î¼ : Prop
but is expected to have type
  âˆ€ i âˆˆ n.le, AEMeasurable (f i) Î¼ : Prop","theorem lintegral_liminf_le' {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} (h_meas : âˆ€ n, AEMeasurable (f n) Î¼) :
    âˆ«â» a, liminf (fun n => f n a) atTop âˆ‚Î¼ â‰¤ liminf (fun n => âˆ«â» a, f n a âˆ‚Î¼) atTop ",":=
  calc
    âˆ«â» a, liminf (fun n => f n a) atTop âˆ‚Î¼ = âˆ«â» a, â¨† n : â„•, â¨… i â‰¥ n, f i a âˆ‚Î¼ := by
      simp only [liminf_eq_iSup_iInf_of_nat]
    _ = â¨† n : â„•, âˆ«â» a, â¨… i â‰¥ n, f i a âˆ‚Î¼ :=
      (lintegral_iSup' (fun n => aemeasurable_biInf _ (to_countable _) (fun i _ â†¦ h_meas i))
        (ae_of_all Î¼ fun a n m hnm => iInf_le_iInf_of_subset fun i hi => le_trans hnm hi))
    _ â‰¤ â¨† n : â„•, â¨… i â‰¥ n, âˆ«â» a, f i a âˆ‚Î¼ := iSup_mono fun n => le_iInfâ‚‚_lintegral _
    _ = atTop.liminf fun n => âˆ«â» a, f n a âˆ‚Î¼ := Filter.liminf_eq_iSup_iInf_of_nat.symm",refine liminf_le_liminf_of_le (fun n => liminf (fun n => f n a âˆ‚Î¼) atTop) ?_
Mathlib/Computability/PartrecCode.lean,Nat.Partrec.Code.evaln_prim,evaln_prim,ad88a031b67d9f51d39379f0e5f82a31c1929202,":=
  have :
    Primrecâ‚‚ fun (_ : Unit) (n : â„•) =>
      let a := ofNat (â„• Ã— Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).toâ‚‚ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      Â· simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, lt_succ_iff] at nk
      have hg :
        âˆ€ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) â†’
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro kâ‚ câ‚ nâ‚ hl
        simp [lup, List.get?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      Â· cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        Â· rfl
        cases evaln k cg n <;> rfl
      Â· cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        Â· rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      Â· cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        Â· rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        Â· rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      Â· have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        Â· rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.toâ‚‚).of_eq
    fun âŸ¨âŸ¨k, câŸ©, nâŸ© => by simp [evaln_map]","warning:  `List.map_congr` has been deprecated, use `List.map_congr_left` instead
error:  unknown identifier 'lt_succ_iff'
warning:  `List.get?_range` has been deprecated, use `List.getElem?_range` instead
error:  unsolved goals
xâœ : Unit
p n : â„•
this : List.range p = List.range (Nat.pair (unpair p).1 (encode (ofNat Code (unpair p).2)))
c : Code
k' : â„•
k : â„• := k' + 1
nk : n < k' + 1
kâ‚ : â„•
câ‚ : Code
nâ‚ : â„•
hl : Nat.pair kâ‚ (encode câ‚) < Nat.pair k (encode c)
âŠ¢ ((Option.map (fun n â†¦ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
          (List.range (Nat.pair k (encode c)))[Nat.pair kâ‚ (encode câ‚)]?).bind
      fun a â†¦ a[nâ‚]?.bind fun a â†¦ a) =
    evaln kâ‚ câ‚ nâ‚
error:  unknown identifier 'cf'
error:  unknown identifier 'cg'
error:  unknown identifier 'cf'
error:  unknown identifier 'cg'
error:  unknown identifier 'cf'
error:  unknown identifier 'cg'
error:  unknown identifier 'cf'
error:  unsolved goals
case succ.pair
xâœ : Unit
p n : â„•
this : List.range p = List.range (Nat.pair (unpair p).1 (encode (ofNat Code (unpair p).2)))
k' : â„•
k : â„• := k' + 1
nk : n < k' + 1
cf cg : Code
hg :
  âˆ€ {k' : â„•} {c' : Code} {n : â„•},
    Nat.pair k' (encode c') < Nat.pair k (encode (cf.pair cg)) â†’
      Nat.Partrec.Code.lup
          (List.map (fun n â†¦ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
            (List.range (Nat.pair k (encode (cf.pair cg)))))
          (k', c') n =
        evaln k' c' n
âŠ¢ ((Nat.Partrec.Code.lup
          (List.map (fun n â†¦ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
            (List.range (Nat.pair (k' + 1) (encode (cf.pair cg)))))
          (k' + 1, cf) n).bind
      fun a â†¦
      (Nat.Partrec.Code.lup
            (List.map (fun n â†¦ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
              (List.range (Nat.pair (k' + 1) (encode (cf.pair cg)))))
            (k' + 1, cg) n).bind
        fun y â†¦ some (Nat.pair a y)) =
    (guard (n â‰¤ k')).bind fun a â†¦
      (Option.map Nat.pair (evaln (k' + 1) cf n)).bind fun a â†¦ Option.map a (evaln (k' + 1) cg n)

case succ.comp
xâœ : Unit
p n : â„•
this : List.range p = List.range (Nat.pair (unpair p).1 (encode (ofNat Code (unpair p).2)))
k' : â„•
k : â„• := k' + 1
nk : n < k' + 1
cf cg : Code
hg :
  âˆ€ {k' : â„•} {c' : Code} {n : â„•},
    Nat.pair k' (encode c') < Nat.pair k (encode (cf.comp cg)) â†’
      Nat.Partrec.Code.lup
          (List.map (fun n â†¦ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
            (List.range (Nat.pair k (encode (cf.comp cg)))))
          (k', c') n =
        evaln k' c' n
âŠ¢ ((Nat.Partrec.Code.lup
          (List.map (fun n â†¦ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
            (List.range (Nat.pair (k' + 1) (encode (cf.comp cg)))))
          (k' + 1, cg) n).bind
      fun x â†¦
      Nat.Partrec.Code.lup
        (List.map (fun n â†¦ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
          (List.range (Nat.pair (k' + 1) (encode (cf.comp cg)))))
        (k' + 1, cf) x) =
    (guard (n â‰¤ k')).bind fun a â†¦ (evaln (k' + 1) cg n).bind fun x â†¦ evaln (k' + 1) cf x

case succ.prec
xâœ : Unit
p n : â„•
this : List.range p = List.range (Nat.pair (unpair p).1 (encode (ofNat Code (unpair p).2)))
k' : â„•
k : â„• := k' + 1
nk : n < k' + 1
cf cg : Code
hg :
  âˆ€ {k' : â„•} {c' : Code} {n : â„•},
    Nat.pair k' (encode c') < Nat.pair k (encode (cf.prec cg)) â†’
      Nat.Partrec.Code.lup
          (List.map (fun n â†¦ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
            (List.range (Nat.pair k (encode (cf.prec cg)))))
          (k', c') n =
        evaln k' c' n
âŠ¢ Nat.rec
      (Nat.Partrec.Code.lup
        (List.map (fun n â†¦ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
          (List.range (Nat.pair (k' + 1) (encode (cf.prec cg)))))
        (k' + 1, cf) (unpair n).1)
      (fun n_1 n_ih â†¦
        (Nat.Partrec.Code.lup
              (List.map (fun n â†¦ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
                (List.range (Nat.pair (k' + 1) (encode (cf.prec cg)))))
              (k', cf.prec cg) (Nat.pair (unpair n).1 n_1)).bind
          fun i â†¦
          Nat.Partrec.Code.lup
            (List.map (fun n â†¦ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
              (List.range (Nat.pair (k' + 1) (encode (cf.prec cg)))))
            (k' + 1, cg) (Nat.pair (unpair n).1 (Nat.pair n_1 i)))
      (unpair n).2 =
    (guard (n â‰¤ k')).bind fun a â†¦
      Nat.rec (evaln (k' + 1) cf (unpair n).1)
        (fun n_1 n_ih â†¦
          (evaln k' (cf.prec cg) (Nat.pair (unpair n).1 n_1)).bind fun i â†¦
            evaln (k' + 1) cg (Nat.pair (unpair n).1 (Nat.pair n_1 i)))
        (unpair n).2

case succ.rfind'
xâœ : Unit
p n : â„•
this : List.range p = List.range (Nat.pair (unpair p).1 (encode (ofNat Code (unpair p).2)))
k' : â„•
k : â„• := k' + 1
nk : n < k' + 1
cf : Code
hg :
  âˆ€ {k' : â„•} {c' : Code} {n : â„•},
    Nat.pair k' (encode c') < Nat.pair k (encode cf.rfind') â†’
      Nat.Partrec.Code.lup
          (List.map (fun n â†¦ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
            (List.range (Nat.pair k (encode cf.rfind'))))
          (k', c') n =
        evaln k' c' n
âŠ¢ ((Nat.Partrec.Code.lup
          (List.map (fun n â†¦ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
            (List.range (Nat.pair (k' + 1) (encode cf.rfind'))))
          (k' + 1, cf) n).bind
      fun x â†¦
      Nat.rec (some (unpair n).2)
        (fun n_1 n_ih â†¦
          Nat.Partrec.Code.lup
            (List.map (fun n â†¦ List.map (evaln (unpair n).1 (ofNat Code (unpair n).2)) (List.range (unpair n).1))
              (List.range (Nat.pair (k' + 1) (encode cf.rfind'))))
            (k', cf.rfind') (Nat.pair (unpair n).1 ((unpair n).2 + 1)))
        x) =
    (guard (n â‰¤ k')).bind fun a â†¦
      (evaln (k' + 1) cf n).bind fun a â†¦
        if a = 0 then some (unpair n).2 else evaln k' cf.rfind' (Nat.pair (unpair n).1 ((unpair n).2 + 1))",theorem evaln_prim : Primrec fun a : (â„• Ã— Code) Ã— â„• => evaln a.1.1 a.1.2 a.2 ,":=
  have :
    Primrecâ‚‚ fun (_ : Unit) (n : â„•) =>
      let a := ofNat (â„• Ã— Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).toâ‚‚ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr_left fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      Â· simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, Nat.lt_succ_iff] at nk
      have hg :
        âˆ€ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) â†’
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro kâ‚ câ‚ nâ‚ hl
        simp [lup, List.getElem?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      Â· cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        Â· rfl
        cases evaln k cg n <;> rfl
      Â· cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        Â· rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      Â· cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        Â· rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        Â· rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      Â· have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        Â· rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.toâ‚‚).of_eq
    fun âŸ¨âŸ¨k, câŸ©, nâŸ© => by simp [evaln_map]","simp [evaln, evaln_prim]"
Mathlib/Algebra/BigOperators/Fin.lean,Fin.prod_ofFn,prod_ofFn,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [List.ofFn_eq_map, prod_univ_def]","error:  unknown identifier 'prod_univ_def'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.1167
Î± : Type u_1
Î² : Type u_2
instâœ : CommMonoid Î²
n : â„•
f : Fin n â†’ Î²
âŠ¢ (List.map f (List.finRange n)).prod = âˆ i : Fin n, f i","theorem prod_ofFn [CommMonoid Î²] {n : â„•} (f : Fin n â†’ Î²) : (List.ofFn f).prod = âˆ i, f i ",":= by
  simp [prod_eq_multiset_prod]","simp only [List.ofFn, List.ofFn, List.ofFn, List.ofFn, List.ofFn, List.ofFn, List.ofFn,
  List.ofFn, List.ofFn, List.ofFn]"
Mathlib/NumberTheory/PrimesCongruentOne.lean,Nat.exists_prime_gt_modEq_one,exists_prime_gt_modEq_one,693fd79515903b10b1d31f10dccfc49e633cf7ee,":= by
  rcases (one_le_iff_ne_zero.2 hk0).eq_or_lt with (rfl | hk1)
  Â· rcases exists_infinite_primes (n + 1) with âŸ¨p, hnp, hpâŸ©
    exact âŸ¨p, hp, hnp, modEq_oneâŸ©
  let b := k * (n !)
  have hgt : 1 < (eval (â†‘b) (cyclotomic k â„¤)).natAbs := by
    rcases le_iff_exists_add'.1 hk1.le with âŸ¨k, rflâŸ©
    have hb : 2 â‰¤ b := le_mul_of_le_of_one_le hk1 n.factorial_pos
    calc
      1 â‰¤ b - 1 := le_tsub_of_add_le_left hb
      _ < (eval (b : â„¤) (cyclotomic (k + 1) â„¤)).natAbs :=
        sub_one_lt_natAbs_cyclotomic_eval hk1 (succ_le_iff.1 hb).ne'
  let p := minFac (eval (â†‘b) (cyclotomic k â„¤)).natAbs
  haveI hprime : Fact p.Prime := âŸ¨minFac_prime (ne_of_lt hgt).symmâŸ©
  have hroot : IsRoot (cyclotomic k (ZMod p)) (castRingHom (ZMod p) b) := by
    have : ((b : â„¤) : ZMod p) = â†‘(Int.castRingHom (ZMod p) b) := by simp
    rw [IsRoot.def, â† map_cyclotomic_int k (ZMod p), eval_map, coe_castRingHom, â† Int.cast_ofNat,
      this, evalâ‚‚_hom, Int.coe_castRingHom, ZMod.int_cast_zmod_eq_zero_iff_dvd _ _]
    apply Int.dvd_natAbs.1
    exact mod_cast minFac_dvd (eval (â†‘b) (cyclotomic k â„¤)).natAbs
  have hpb : Â¬p âˆ£ b :=
    hprime.1.coprime_iff_not_dvd.1 (coprime_of_root_cyclotomic hk0.bot_lt hroot).symm
  refine' âŸ¨p, hprime.1, not_le.1 fun habs => _, _âŸ©
  Â· exact hpb (dvd_mul_of_dvd_right (dvd_factorial (minFac_pos _) habs) _)
  Â· have hdiv : orderOf (b : ZMod p) âˆ£ p - 1 :=
      ZMod.orderOf_dvd_card_sub_one (mt (CharP.cast_eq_zero_iff _ _ _).1 hpb)
    haveI : NeZero (k : ZMod p) :=
      NeZero.of_not_dvd (ZMod p) fun hpk => hpb (dvd_mul_of_dvd_left hpk _)
    have : k = orderOf (b : ZMod p) := (isRoot_cyclotomic_iff.mp hroot).eq_orderOf
    rw [â† this] at hdiv
    exact ((modEq_iff_dvd' hprime.1.pos).2 hdiv).symm","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  OfNat.ofNat ?n
k n : â„•
hk0 : k â‰  0
hk1 : 1 < k
b : â„• := k * n !
hgt : 1 < (eval (â†‘b) (cyclotomic k â„¤)).natAbs
p : â„• := (eval (â†‘b) (cyclotomic k â„¤)).natAbs.minFac
hprime : Fact (Prime p)
this : â†‘â†‘b = (Int.castRingHom (ZMod p)) â†‘b
âŠ¢ evalâ‚‚ (Int.castRingHom (ZMod p)) (â†‘b) (cyclotomic k â„¤) = 0","theorem exists_prime_gt_modEq_one {k : â„•} (n : â„•) (hk0 : k â‰  0) :
    âˆƒ p : â„•, Nat.Prime p âˆ§ n < p âˆ§ p â‰¡ 1 [MOD k] ",":= by
  rcases (one_le_iff_ne_zero.2 hk0).eq_or_lt with (rfl | hk1)
  Â· rcases exists_infinite_primes (n + 1) with âŸ¨p, hnp, hpâŸ©
    exact âŸ¨p, hp, hnp, modEq_oneâŸ©
  let b := k * (n !)
  have hgt : 1 < (eval (â†‘b) (cyclotomic k â„¤)).natAbs := by
    rcases le_iff_exists_add'.1 hk1.le with âŸ¨k, rflâŸ©
    have hb : 2 â‰¤ b := le_mul_of_le_of_one_le hk1 n.factorial_pos
    calc
      1 â‰¤ b - 1 := le_tsub_of_add_le_left hb
      _ < (eval (b : â„¤) (cyclotomic (k + 1) â„¤)).natAbs :=
        sub_one_lt_natAbs_cyclotomic_eval hk1 (succ_le_iff.1 hb).ne'
  let p := minFac (eval (â†‘b) (cyclotomic k â„¤)).natAbs
  haveI hprime : Fact p.Prime := âŸ¨minFac_prime (ne_of_lt hgt).symmâŸ©
  have hroot : IsRoot (cyclotomic k (ZMod p)) (castRingHom (ZMod p) b) := by
    have : ((b : â„¤) : ZMod p) = â†‘(Int.castRingHom (ZMod p) b) := by simp
    rw [IsRoot.def, â† map_cyclotomic_int k (ZMod p), eval_map, coe_castRingHom,
      â† Int.cast_natCast, this, evalâ‚‚_hom, Int.coe_castRingHom, ZMod.intCast_zmod_eq_zero_iff_dvd]
    apply Int.dvd_natAbs.1
    exact mod_cast minFac_dvd (eval (â†‘b) (cyclotomic k â„¤)).natAbs
  have hpb : Â¬p âˆ£ b :=
    hprime.1.coprime_iff_not_dvd.1 (coprime_of_root_cyclotomic hk0.bot_lt hroot).symm
  refine âŸ¨p, hprime.1, not_le.1 fun habs => ?_, ?_âŸ©
  Â· exact hpb (dvd_mul_of_dvd_right (dvd_factorial (minFac_pos _) habs) _)
  Â· have hdiv : orderOf (b : ZMod p) âˆ£ p - 1 :=
      ZMod.orderOf_dvd_card_sub_one (mt (CharP.cast_eq_zero_iff _ _ _).1 hpb)
    haveI : NeZero (k : ZMod p) :=
      NeZero.of_not_dvd (ZMod p) fun hpk => hpb (dvd_mul_of_dvd_left hpk _)
    have : k = orderOf (b : ZMod p) := (isRoot_cyclotomic_iff.mp hroot).eq_orderOf
    rw [â† this] at hdiv
    exact ((modEq_iff_dvd' hprime.1.pos).2 hdiv).symm","rcases exists_prime_gt_modEq_one k hk0 with âŸ¨p, hpâ‚, hpâ‚‚âŸ©"
Mathlib/Analysis/BoxIntegral/Box/SubboxInduction.lean,BoxIntegral.Box.subbox_induction_on',subbox_induction_on',24004588aea73bdc55b8a915a39abc4e4281277b,":= by
  by_contra hpI
  replace H_ind := fun J hJ â†¦ not_imp_not.2 (H_ind J hJ)
  simp only [exists_imp, not_forall] at H_ind
  choose! s hs using H_ind
  set J : â„• â†’ Box Î¹ := fun m â†¦ ((fun J â†¦ splitCenterBox J (s J))^[m]) I
  have J_succ : âˆ€ m, J (m + 1) = splitCenterBox (J m) (s <| J m) :=
    fun m â†¦ iterate_succ_apply' _ _ _
  have hJmono : Antitone J :=
    antitone_nat_of_succ_le fun n â†¦ by simpa [J_succ] using splitCenterBox_le _ _
  have hJle : âˆ€ m, J m â‰¤ I := fun m â†¦ hJmono (zero_le m)
  have hJp : âˆ€ m, Â¬p (J m) :=
    fun m â†¦ Nat.recOn m hpI fun m â†¦ by simpa only [J_succ] using hs (J m) (hJle m)
  have hJsub : âˆ€ m i, (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m := by
    intro m i
    induction' m with m ihm
    Â· simp [Nat.zero_eq]
    simp only [pow_succ', J_succ, upper_sub_lower_splitCenterBox, ihm, div_div]
  have h0 : J 0 = I := rfl
  clear_value J
  clear hpI hs J_succ s
  set z : Î¹ â†’ â„ := â¨† m, (J m).lower
  have hzJ : âˆ€ m, z âˆˆ Box.Icc (J m) :=
    mem_interáµ¢.1 (csupáµ¢_mem_Inter_Icc_of_antitone_Icc
      ((@Box.Icc Î¹).monotone.comp_antitone hJmono) fun m â†¦ (J m).lower_le_upper)
  have hJl_mem : âˆ€ m, (J m).lower âˆˆ Box.Icc I := fun m â†¦ le_iff_icc.1 (hJle m) (J m).lower_mem_icc
  have hJu_mem : âˆ€ m, (J m).upper âˆˆ Box.Icc I := fun m â†¦ le_iff_icc.1 (hJle m) (J m).upper_mem_icc
  have hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“ z) :=
    tendsto_atTop_csupáµ¢ (antitone_lower.comp hJmono) âŸ¨I.upper, fun x âŸ¨m, hmâŸ© â†¦ hm â–¸ (hJl_mem m).2âŸ©
  have hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“ z) := by
    suffices Tendsto (fun m â†¦ (J m).upper - (J m).lower) atTop (ğ“ 0) by simpa using hJlz.add this
    refine' tendsto_pi_nhds.2 fun i â†¦ _
    simpa [hJsub] using
      tendsto_const_nhds.div_atTop (tendsto_pow_atTop_atTop_of_one_lt _root_.one_lt_two)
  replace hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“[Icc I.lower I.upper] z)
  exact
    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJlz (eventually_of_forall hJl_mem)
  replace hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“[Icc I.lower I.upper] z)
  exact
    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJuz (eventually_of_forall hJu_mem)
  rcases H_nhds z (h0 â–¸ hzJ 0) with âŸ¨U, hUz, hUâŸ©
  rcases(tendsto_lift'.1 (hJlz.Icc hJuz) U hUz).exists with âŸ¨m, hUmâŸ©
  exact hJp m (hU (J m) (hJle m) m (hzJ m) hUm (hJsub m))","error:  unexpected identifier; expected '|'
error:  unsolved goals
case zero
Î¹ : Type u_1
Iâœ Jâœ : Box Î¹
p : Box Î¹ â†’ Prop
I : Box Î¹
H_nhds :
  âˆ€ z âˆˆ Box.Icc I,
    âˆƒ U âˆˆ ğ“[Box.Icc I] z,
      âˆ€ J â‰¤ I,
        âˆ€ (m : â„•),
          z âˆˆ Box.Icc J â†’ Box.Icc J âŠ† U â†’ (âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J
hpI : Â¬p I
s : Box Î¹ â†’ Set Î¹
hs : âˆ€ J â‰¤ I, Â¬p J â†’ Â¬p (J.splitCenterBox (s J))
J : â„• â†’ Box Î¹ := fun m â†¦ (fun J â†¦ J.splitCenterBox (s J))^[m] I
J_succ : âˆ€ (m : â„•), J (m + 1) = (J m).splitCenterBox (s (J m))
hJmono : Antitone J
hJle : âˆ€ (m : â„•), J m â‰¤ I
hJp : âˆ€ (m : â„•), Â¬p (J m)
i : Î¹
âŠ¢ (J 0).upper i - (J 0).lower i = I.upper i - I.lower i
error:  unsolved goals
case succ
Î¹ : Type u_1
Iâœ Jâœ : Box Î¹
p : Box Î¹ â†’ Prop
I : Box Î¹
H_nhds :
  âˆ€ z âˆˆ Box.Icc I,
    âˆƒ U âˆˆ ğ“[Box.Icc I] z,
      âˆ€ J â‰¤ I,
        âˆ€ (m : â„•),
          z âˆˆ Box.Icc J â†’ Box.Icc J âŠ† U â†’ (âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J
hpI : Â¬p I
s : Box Î¹ â†’ Set Î¹
hs : âˆ€ J â‰¤ I, Â¬p J â†’ Â¬p (J.splitCenterBox (s J))
J : â„• â†’ Box Î¹ := fun m â†¦ (fun J â†¦ J.splitCenterBox (s J))^[m] I
J_succ : âˆ€ (m : â„•), J (m + 1) = (J m).splitCenterBox (s (J m))
hJmono : Antitone J
hJle : âˆ€ (m : â„•), J m â‰¤ I
hJp : âˆ€ (m : â„•), Â¬p (J m)
i : Î¹
m : â„•
ihm : (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m
âŠ¢ (I.upper i - I.lower i) / (2 ^ m * 2) = (I.upper i - I.lower i) / (2 * 2 ^ m)
error:  unsolved goals
Î¹ : Type u_1
Iâœ Jâœ : Box Î¹
p : Box Î¹ â†’ Prop
I : Box Î¹
H_nhds :
  âˆ€ z âˆˆ Box.Icc I,
    âˆƒ U âˆˆ ğ“[Box.Icc I] z,
      âˆ€ J â‰¤ I,
        âˆ€ (m : â„•),
          z âˆˆ Box.Icc J â†’ Box.Icc J âŠ† U â†’ (âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J
J : â„• â†’ Box Î¹
hJmono : Antitone J
hJle : âˆ€ (m : â„•), J m â‰¤ I
hJp : âˆ€ (m : â„•), Â¬p (J m)
hJsub : âˆ€ (m : â„•) (i : Î¹), (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m
h0 : J 0 = I
z : Î¹ â†’ â„ := â¨† m, (J m).lower
hzJ : âˆ€ (m : â„•), z âˆˆ Box.Icc (J m)
hJl_mem : âˆ€ (m : â„•), (J m).lower âˆˆ Box.Icc I
hJu_mem : âˆ€ (m : â„•), (J m).upper âˆˆ Box.Icc I
hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“ z)
hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“[Set.Icc I.lower I.upper] z)
âŠ¢ False","theorem subbox_induction_on' {p : Box Î¹ â†’ Prop} (I : Box Î¹)
    (H_ind : âˆ€ J â‰¤ I, (âˆ€ s, p (splitCenterBox J s)) â†’ p J)
    (H_nhds : âˆ€ z âˆˆ Box.Icc I, âˆƒ U âˆˆ ğ“[Box.Icc I] z, âˆ€ J â‰¤ I, âˆ€ (m : â„•), z âˆˆ Box.Icc J â†’
      Box.Icc J âŠ† U â†’ (âˆ€ i, J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J) :
    p I ",":= by
  by_contra hpI
  replace H_ind := fun J hJ â†¦ not_imp_not.2 (H_ind J hJ)
  simp only [exists_imp, not_forall] at H_ind
  choose! s hs using H_ind
  set J : â„• â†’ Box Î¹ := fun m â†¦ (fun J â†¦ splitCenterBox J (s J))^[m] I
  have J_succ : âˆ€ m, J (m + 1) = splitCenterBox (J m) (s <| J m) :=
    fun m â†¦ iterate_succ_apply' _ _ _
  have hJmono : Antitone J :=
    antitone_nat_of_succ_le fun n â†¦ by simpa [J_succ] using splitCenterBox_le _ _
  have hJle : âˆ€ m, J m â‰¤ I := fun m â†¦ hJmono (zero_le m)
  have hJp : âˆ€ m, Â¬p (J m) :=
    fun m â†¦ Nat.recOn m hpI fun m â†¦ by simpa only [J_succ] using hs (J m) (hJle m)
  have hJsub : âˆ€ m i, (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m := by
    intro m i
    induction' m with m ihm
    Â· simp [J, Nat.zero_eq]
    simp only [pow_succ, J_succ, upper_sub_lower_splitCenterBox, ihm, div_div]
  have h0 : J 0 = I := rfl
  clear_value J
  clear hpI hs J_succ s
  set z : Î¹ â†’ â„ := â¨† m, (J m).lower
  have hzJ : âˆ€ m, z âˆˆ Box.Icc (J m) :=
    mem_iInter.1 (ciSup_mem_iInter_Icc_of_antitone_Icc
      ((@Box.Icc Î¹).monotone.comp_antitone hJmono) fun m â†¦ (J m).lower_le_upper)
  have hJl_mem : âˆ€ m, (J m).lower âˆˆ Box.Icc I := fun m â†¦ le_iff_Icc.1 (hJle m) (J m).lower_mem_Icc
  have hJu_mem : âˆ€ m, (J m).upper âˆˆ Box.Icc I := fun m â†¦ le_iff_Icc.1 (hJle m) (J m).upper_mem_Icc
  have hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“ z) :=
    tendsto_atTop_ciSup (antitone_lower.comp hJmono) âŸ¨I.upper, fun x âŸ¨m, hmâŸ© â†¦ hm â–¸ (hJl_mem m).2âŸ©
  have hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“ z) := by
    suffices Tendsto (fun m â†¦ (J m).upper - (J m).lower) atTop (ğ“ 0) by simpa using hJlz.add this
    refine tendsto_pi_nhds.2 fun i â†¦ ?_
    simpa [hJsub] using
      tendsto_const_nhds.div_atTop (tendsto_pow_atTop_atTop_of_one_lt _root_.one_lt_two)
  replace hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“[Icc I.lower I.upper] z) :=
    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJlz (eventually_of_forall hJl_mem)
  replace hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“[Icc I.lower I.upper] z) :=
    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJuz (eventually_of_forall hJu_mem)
  rcases H_nhds z (h0 â–¸ hzJ 0) with âŸ¨U, hUz, hUâŸ©
  rcases (tendsto_lift'.1 (hJlz.Icc hJuz) U hUz).exists with âŸ¨m, hUmâŸ©
  exact hJp m (hU (J m) (hJle m) m (hzJ m) hUm (hJsub m))",refine theorem_theorem_Icc p I H_nhds H_ind H_nhds H_nhds H_ind H_nhds H_nhds H_ind H_nhds H_nhds
Mathlib/LinearAlgebra/Matrix/Transvection.lean,Matrix.Pivot.mul_listTransvecRow_last_col,mul_listTransvecRow_last_col,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  induction' k with k IH
  Â· simp only [Matrix.mul_one, List.take_zero, List.prod_nil, List.take, Matrix.mul_one]
  Â· have hkr : k < r := hk
    let k' : Fin r := âŸ¨k, hkrâŸ©
    have :
      (listTransvecRow M).get? k =
        â†‘(transvection (inr Unit.unit) (inl k')
            (-M (inr Unit.unit) (inl k') / M (inr Unit.unit) (inr Unit.unit))) := by
      simp only [listTransvecRow, List.ofFnNthVal, hkr, dif_pos, List.get?_ofFn]
    simp only [List.take_succ, â† Matrix.mul_assoc, this, List.prod_append, Matrix.mul_one,
      List.prod_cons, List.prod_nil, Option.to_list_some]
    rw [mul_transvection_apply_of_ne, IH hkr.le]
    simp only [Ne.def, not_false_iff]","warning:  `Option.to_list_some` has been deprecated, use `Option.toList_some` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?M * transvection ?i ?j ?c) ?a ?b
case succ
n : Type u_1
p : Type u_2
R : Type uâ‚‚
ğ•œ : Type u_3
instâœÂ³ : Field ğ•œ
instâœÂ² : DecidableEq n
instâœÂ¹ : DecidableEq p
instâœ : CommRing R
r : â„•
M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ğ•œ
i : Fin r âŠ• Unit
k : â„•
IH : k â‰¤ r â†’ (M * (List.take k (listTransvecRow M)).prod) i (inr ()) = M i (inr ())
hk : k + 1 â‰¤ r
hkr : k < r
k' : Fin r := âŸ¨k, hkrâŸ©
this : (listTransvecRow M).get? k = some (transvection (inr ()) (inl k') (-M (inr ()) (inl k') / M (inr ()) (inr ())))
âŠ¢ (M * (List.take k (listTransvecRow M)).prod * (listTransvecRow M)[k]?.toList.prod) i (inr ()) = M i (inr ())","theorem mul_listTransvecRow_last_col_take (i : Sum (Fin r) Unit) {k : â„•} (hk : k â‰¤ r) :
    (M * ((listTransvecRow M).take k).prod) i (inr unit) = M i (inr unit) ",":= by
  induction' k with k IH
  Â· simp only [Matrix.mul_one, List.take_zero, List.prod_nil, List.take, Matrix.mul_one]
  Â· have hkr : k < r := hk
    let k' : Fin r := âŸ¨k, hkrâŸ©
    have :
      (listTransvecRow M)[k]? =
        â†‘(transvection (inr Unit.unit) (inl k')
            (-M (inr Unit.unit) (inl k') / M (inr Unit.unit) (inr Unit.unit))) := by
      simp only [listTransvecRow, List.ofFnNthVal, hkr, dif_pos, List.getElem?_ofFn]
    simp only [List.take_succ, â† Matrix.mul_assoc, this, List.prod_append, Matrix.mul_one,
      List.prod_cons, List.prod_nil, Option.toList_some]
    rw [mul_transvection_apply_of_ne, IH hkr.le]
    simp only [Ne, not_false_iff]","simp [listTransvecRow_last_col_take, listTransvecRow_last_col_take]"
Mathlib/LinearAlgebra/Trace.lean,LinearMap.trace_one,trace_one,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  cases subsingleton_or_nontrivial R; simp
  have b := Module.Free.chooseBasis R M
  rw [trace_eq_matrix_trace R b, toMatrix_one, finrank_eq_card_chooseBasisIndex]
  simp",error:  simp made no progress,theorem trace_one : trace R M 1 = (finrank R M : R) ,":= by
  cases subsingleton_or_nontrivial R
  Â· simp [eq_iff_true_of_subsingleton]
  have b := Module.Free.chooseBasis R M
  rw [trace_eq_matrix_trace R b, toMatrix_one, finrank_eq_card_chooseBasisIndex]
  simp",have trace_one : trace R M 1 = finrank R M := by simp [trace_one]
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.addHaar_image_eq_zero_of_det_fderivWithin_eq_zero,addHaar_image_eq_zero_of_det_fderivWithin_eq_zero,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rcases eq_empty_or_nonempty s with (rfl | h's); Â· simp only [measure_empty, zero_le, image_empty]
  have :
      âˆ€ A : E â†’L[â„] E, âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§
        âˆ€ (t : Set E), ApproximatesLinearOn f A t Î´ â†’
          Î¼ (f '' t) â‰¤ (Real.toNNReal |A.det| + Îµ : â„â‰¥0) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, h'âŸ©
    exact âŸ¨Î´, h', fun t ht => h t f htâŸ©
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, Af'âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Real.toNNReal |(A n).det| + Îµ : â„â‰¥0) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2
      exact ht n
    _ = âˆ‘' n, Îµ * Î¼ (s âˆ© t n) := by
      congr with n
      rcases Af' h's n with âŸ¨y, ys, hyâŸ©
      simp only [hy, h'f' y ys, Real.toNNReal_zero, abs_zero, zero_add]
    _ â‰¤ Îµ * âˆ‘' n, Î¼ (closedBall 0 R âˆ© t n) := by
      rw [ENNReal.tsum_mul_left]
      refine' mul_le_mul_left' (ENNReal.tsum_le_tsum fun n => measure_mono _) _
      exact inter_subset_inter_left _ hs
    _ = Îµ * Î¼ (â‹ƒ n, closedBall 0 R âˆ© t n) := by
      rw [measure_iUnion]
      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right _ _
      Â· intro n
        exact measurableSet_closedBall.inter (t_meas n)
    _ â‰¤ Îµ * Î¼ (closedBall 0 R) := by
      rw [â† inter_iUnion]
      exact mul_le_mul_left' (measure_mono (inter_subset_left _ _)) _","error:  function expected at
  inter_subset_right ?m.329486
term has type
  ?m.329485 âˆˆ ?m.329484
error:  function expected at
  inter_subset_left ?m.330114
term has type
  ?m.330113 âˆˆ ?m.330111","theorem addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (R : â„) (hs : s âŠ† closedBall 0 R) (Îµ : â„â‰¥0)
    (Îµpos : 0 < Îµ) (h'f' : âˆ€ x âˆˆ s, (f' x).det = 0) : Î¼ (f '' s) â‰¤ Îµ * Î¼ (closedBall 0 R) ",":= by
  rcases eq_empty_or_nonempty s with (rfl | h's); Â· simp only [measure_empty, zero_le, image_empty]
  have :
      âˆ€ A : E â†’L[â„] E, âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§
        âˆ€ (t : Set E), ApproximatesLinearOn f A t Î´ â†’
          Î¼ (f '' t) â‰¤ (Real.toNNReal |A.det| + Îµ : â„â‰¥0) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, h'âŸ©
    exact âŸ¨Î´, h', fun t ht => h t f htâŸ©
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, Af'âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      rw [â† image_iUnion, â† inter_iUnion]
      gcongr
      exact subset_inter Subset.rfl t_cover
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Real.toNNReal |(A n).det| + Îµ : â„â‰¥0) * Î¼ (s âˆ© t n) := by
      gcongr
      exact (hÎ´ (A _)).2 _ (ht _)
    _ = âˆ‘' n, Îµ * Î¼ (s âˆ© t n) := by
      congr with n
      rcases Af' h's n with âŸ¨y, ys, hyâŸ©
      simp only [hy, h'f' y ys, Real.toNNReal_zero, abs_zero, zero_add]
    _ â‰¤ Îµ * âˆ‘' n, Î¼ (closedBall 0 R âˆ© t n) := by
      rw [ENNReal.tsum_mul_left]
      gcongr
    _ = Îµ * Î¼ (â‹ƒ n, closedBall 0 R âˆ© t n) := by
      rw [measure_iUnion]
      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
      Â· intro n
        exact measurableSet_closedBall.inter (t_meas n)
    _ â‰¤ Îµ * Î¼ (closedBall 0 R) := by
      rw [â† inter_iUnion]
      exact mul_le_mul_left' (measure_mono inter_subset_left) _",have : Î¼ (closedBall 0 R) âŠ† closedBall 0 R := closedBall_subset_closedBall_subset
Mathlib/Analysis/NormedSpace/AddTorsorBases.lean,IsOpen.exists_between_affineIndependent_span_eq_top,IsOpen.exists_between_affineIndependent_span_eq_top,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  obtain âŸ¨q, hqâŸ© := hne
  obtain âŸ¨Îµ, Îµ0, hÎµuâŸ© := Metric.nhds_basis_closedBall.mem_iff.1 (hu.mem_nhds <| hsu hq)
  obtain âŸ¨t, htâ‚, htâ‚‚, htâ‚ƒâŸ© := exists_subset_affineIndependent_affineSpan_eq_top h
  let f : P â†’ P := fun y => lineMap q y (Îµ / dist y q)
  have hf : âˆ€ y, f y âˆˆ u := by
    refine fun y => hÎµu ?_
    simp only [f]
    rw [Metric.mem_closedBall, lineMap_apply, dist_vadd_left, norm_smul, Real.norm_eq_abs,
      dist_eq_norm_vsub V y q, abs_div, abs_of_pos Îµ0, abs_of_nonneg (norm_nonneg _), div_mul_comm]
    exact mul_le_of_le_one_left Îµ0.le (div_self_le_one _)
  have hÎµyq : âˆ€ y âˆ‰ s, Îµ / dist y q â‰  0 := fun y hy =>
    div_ne_zero Îµ0.ne' (dist_ne_zero.2 (ne_of_mem_of_not_mem hq hy).symm)
  classical
  let w : t â†’ â„Ë£ := fun p => if hp : (p : P) âˆˆ s then 1 else Units.mk0 _ (hÎµyq (â†‘p) hp)
  refine âŸ¨Set.range fun p : t => lineMap q p (w p : â„), ?_, ?_,? ?_, _âŸ©
  Â· intro p hp; use âŸ¨p, htâ‚ hpâŸ©; simp [w, hp]
  Â· rintro y âŸ¨âŸ¨p, hpâŸ©, rflâŸ©
    by_cases hps : p âˆˆ s <;>
    simp only [w, hps, lineMap_apply_one, Units.val_mk0, dif_neg, dif_pos, not_false_iff,
      Units.val_one, Subtype.coe_mk] <;>
    [exact hsu hps; exact hf p]
  Â· exact (htâ‚‚.units_lineMap âŸ¨q, htâ‚ hqâŸ© w).range
  Â· rw [affineSpan_eq_affineSpan_lineMap_units (htâ‚ hq) w, htâ‚ƒ]","error:  unexpected token '?'; expected '_' or identifier
error:  unsolved goals
case intro.intro.intro.intro.intro.intro.refine_1
V : Type u_1
P : Type u_2
instâœÂ³ : NormedAddCommGroup V
instâœÂ² : NormedSpace â„ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
s u : Set P
hu : IsOpen u
hsu : s âŠ† u
h : AffineIndependent â„ Subtype.val
q : P
hq : q âˆˆ s
Îµ : â„
Îµ0 : 0 < Îµ
hÎµu : Metric.closedBall q Îµ âŠ† u
t : Set P
htâ‚ : s âŠ† t
htâ‚‚ : AffineIndependent â„ fun p â†¦ â†‘p
htâ‚ƒ : affineSpan â„ t = âŠ¤
f : P â†’ P := fun y â†¦ (lineMap q y) (Îµ / dist y q)
hf : âˆ€ (y : P), f y âˆˆ u
hÎµyq : âˆ€ y âˆ‰ s, Îµ / dist y q â‰  0
w : â†‘t â†’ â„Ë£ := fun p â†¦ if hp : â†‘p âˆˆ s then 1 else Units.mk0 (Îµ / dist (â†‘p) q) â‹¯
âŠ¢ s âŠ† range fun p â†¦ (lineMap q â†‘p) â†‘(w p)

case intro.intro.intro.intro.intro.intro.refine_2
V : Type u_1
P : Type u_2
instâœÂ³ : NormedAddCommGroup V
instâœÂ² : NormedSpace â„ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
s u : Set P
hu : IsOpen u
hsu : s âŠ† u
h : AffineIndependent â„ Subtype.val
q : P
hq : q âˆˆ s
Îµ : â„
Îµ0 : 0 < Îµ
hÎµu : Metric.closedBall q Îµ âŠ† u
t : Set P
htâ‚ : s âŠ† t
htâ‚‚ : AffineIndependent â„ fun p â†¦ â†‘p
htâ‚ƒ : affineSpan â„ t = âŠ¤
f : P â†’ P := fun y â†¦ (lineMap q y) (Îµ / dist y q)
hf : âˆ€ (y : P), f y âˆˆ u
hÎµyq : âˆ€ y âˆ‰ s, Îµ / dist y q â‰  0
w : â†‘t â†’ â„Ë£ := fun p â†¦ if hp : â†‘p âˆˆ s then 1 else Units.mk0 (Îµ / dist (â†‘p) q) â‹¯
âŠ¢ (range fun p â†¦ (lineMap q â†‘p) â†‘(w p)) âŠ† u

case intro.intro.intro.intro.intro.intro.refine_3
V : Type u_1
P : Type u_2
instâœÂ³ : NormedAddCommGroup V
instâœÂ² : NormedSpace â„ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
s u : Set P
hu : IsOpen u
hsu : s âŠ† u
h : AffineIndependent â„ Subtype.val
q : P
hq : q âˆˆ s
Îµ : â„
Îµ0 : 0 < Îµ
hÎµu : Metric.closedBall q Îµ âŠ† u
t : Set P
htâ‚ : s âŠ† t
htâ‚‚ : AffineIndependent â„ fun p â†¦ â†‘p
htâ‚ƒ : affineSpan â„ t = âŠ¤
f : P â†’ P := fun y â†¦ (lineMap q y) (Îµ / dist y q)
hf : âˆ€ (y : P), f y âˆˆ u
hÎµyq : âˆ€ y âˆ‰ s, Îµ / dist y q â‰  0
w : â†‘t â†’ â„Ë£ := fun p â†¦ if hp : â†‘p âˆˆ s then 1 else Units.mk0 (Îµ / dist (â†‘p) q) â‹¯
âŠ¢ AffineIndependent â„ Subtype.val âˆ§ affineSpan â„ (range fun p â†¦ (lineMap q â†‘p) â†‘(w p)) = âŠ¤","theorem IsOpen.exists_between_affineIndependent_span_eq_top {s u : Set P} (hu : IsOpen u)
    (hsu : s âŠ† u) (hne : s.Nonempty) (h : AffineIndependent â„ ((â†‘) : s â†’ P)) :
    âˆƒ t : Set P, s âŠ† t âˆ§ t âŠ† u âˆ§ AffineIndependent â„ ((â†‘) : t â†’ P) âˆ§ affineSpan â„ t = âŠ¤ ",":= by
  obtain âŸ¨q, hqâŸ© := hne
  obtain âŸ¨Îµ, Îµ0, hÎµuâŸ© := Metric.nhds_basis_closedBall.mem_iff.1 (hu.mem_nhds <| hsu hq)
  obtain âŸ¨t, htâ‚, htâ‚‚, htâ‚ƒâŸ© := exists_subset_affineIndependent_affineSpan_eq_top h
  let f : P â†’ P := fun y => lineMap q y (Îµ / dist y q)
  have hf : âˆ€ y, f y âˆˆ u := by
    refine fun y => hÎµu ?_
    simp only [f]
    rw [Metric.mem_closedBall, lineMap_apply, dist_vadd_left, norm_smul, Real.norm_eq_abs,
      dist_eq_norm_vsub V y q, abs_div, abs_of_pos Îµ0, abs_of_nonneg (norm_nonneg _), div_mul_comm]
    exact mul_le_of_le_one_left Îµ0.le (div_self_le_one _)
  have hÎµyq : âˆ€ y âˆ‰ s, Îµ / dist y q â‰  0 := fun y hy =>
    div_ne_zero Îµ0.ne' (dist_ne_zero.2 (ne_of_mem_of_not_mem hq hy).symm)
  classical
  let w : t â†’ â„Ë£ := fun p => if hp : (p : P) âˆˆ s then 1 else Units.mk0 _ (hÎµyq (â†‘p) hp)
  refine âŸ¨Set.range fun p : t => lineMap q p (w p : â„), ?_, ?_, ?_, ?_âŸ©
  Â· intro p hp; use âŸ¨p, htâ‚ hpâŸ©; simp [w, hp]
  Â· rintro y âŸ¨âŸ¨p, hpâŸ©, rflâŸ©
    by_cases hps : p âˆˆ s <;>
    simp only [w, hps, lineMap_apply_one, Units.val_mk0, dif_neg, dif_pos, not_false_iff,
      Units.val_one, Subtype.coe_mk] <;>
    [exact hsu hps; exact hf p]
  Â· exact (htâ‚‚.units_lineMap âŸ¨q, htâ‚ hqâŸ© w).range
  Â· rw [affineSpan_eq_affineSpan_lineMap_units (htâ‚ hq) w, htâ‚ƒ]",rw [affineIndependent_span_exists_between_affineIndependent_span_eq_top]
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim_aux,LinearIsometryEquiv.reflections_generate_dim_aux,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine' âŸ¨[], rfl.le, show Ï† = 1 from _âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [Nat.zero_eq, le_zero_iff, finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      linarith
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine' âŸ¨x::l, Nat.succ_le_succ hl, _âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg ((Â· * Â·) Ï) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâµ : _root_.RCLike ğ•œ
instâœâ´ : NormedAddCommGroup E
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : InnerProductSpace ğ•œ E
instâœÂ¹ : InnerProductSpace â„ F
K : Submodule ğ•œ E
instâœ : FiniteDimensional â„ F
Ï† : F â‰ƒâ‚—áµ¢[â„] F
hn :
  finrank â„
      â†¥(LinearMap.ker
            (ContinuousLinearMap.id â„ F -
              â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }))á—® â‰¤
    0
âŠ¢ LinearMap.ker
      (ContinuousLinearMap.id â„ F -
        â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }) =
    âŠ¤","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional â„ F] {n : â„•}
    (Ï† : F â‰ƒâ‚—áµ¢[â„] F) (hn : finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—® â‰¤ n) :
    âˆƒ l : List F, l.length â‰¤ n âˆ§ Ï† = (l.map fun v => reflection (â„ âˆ™ v)á—®).prod ",":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine âŸ¨[], rfl.le, show Ï† = 1 from ?_âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      omega
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine âŸ¨x::l, Nat.succ_le_succ hl, ?_âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this","refine âŸ¨finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—®, ?_, ?_âŸ©"
Mathlib/Topology/Algebra/Module/Cardinality.lean,cardinal_eq_of_mem_nhds,cardinal_eq_of_mem_nhds,453c456b049db19d87dc21aed1a69aaf23bd5e15,":= by
  obtain âŸ¨c, hcâŸ© : âˆƒ x : ğ•œ , 1 < â€–xâ€– := NormedField.exists_lt_norm ğ•œ 1
  have cn_ne : âˆ€ n, c^n â‰  0 := by
    intro n
    apply pow_ne_zero
    rintro rfl
    simp only [norm_zero] at hc
    exact lt_irrefl _ (hc.trans zero_lt_one)
  have A : âˆ€ (x : E), âˆ€á¶  n in (atTop : Filter â„•), x âˆˆ c^n â€¢ s := by
    intro x
    have : Tendsto (fun n â†¦ (c^n) â»Â¹ â€¢ x) atTop (ğ“ ((0 : ğ•œ) â€¢ x)) := by
      have : Tendsto (fun n â†¦ (c^n)â»Â¹) atTop (ğ“ 0) := by
        simp_rw [â† inv_pow]
        apply tendsto_pow_atTop_nhds_zero_of_norm_lt_one
        rw [norm_inv]
        exact inv_lt_one hc
      exact Tendsto.smul_const this x
    rw [zero_smul] at this
    filter_upwards [this hs] with n (hn : (c ^ n)â»Â¹ â€¢ x âˆˆ s)
    exact (mem_smul_set_iff_inv_smul_memâ‚€ (cn_ne n) _ _).2 hn
  have B : âˆ€ n, #(c^n â€¢ s :) = #s : = by
    intro n
    have : (c^n â€¢ s :) â‰ƒ s : =
    { toFun := fun x â†¦ âŸ¨(c^n)â»Â¹ â€¢ x.1, (mem_smul_set_iff_inv_smul_memâ‚€ (cn_ne n) _ _).1 x.2âŸ©
      invFun := fun x â†¦ âŸ¨(c^n) â€¢ x.1, smul_mem_smul_set x.2âŸ©
      left_inv := fun x â†¦ by simp [smul_smul, mul_inv_cancel (cn_ne n)]
      right_inv := fun x â†¦ by simp [smul_smul, inv_mul_cancel (cn_ne n)] }
    exact Cardinal.mk_congr this
  apply (Cardinal.mk_of_countable_eventually_mem A B).symm","error:  unexpected token ':'; expected '|'
error:  unsolved goals
case intro
E : Type u_1
ğ•œ : Type u_2
instâœâ´ : NontriviallyNormedField ğ•œ
instâœÂ³ : AddCommGroup E
instâœÂ² : Module ğ•œ E
instâœÂ¹ : TopologicalSpace E
instâœ : ContinuousSMul ğ•œ E
s : Set E
hs : s âˆˆ ğ“ 0
c : ğ•œ
hc : 1 < â€–câ€–
cn_ne : âˆ€ (n : â„•), c ^ n â‰  0
A : âˆ€ (x : E), âˆ€á¶  (n : â„•) in atTop, x âˆˆ c ^ n â€¢ s
B : âˆ€ (n : â„•), #â†‘(c ^ n â€¢ s) = #â†‘s
âŠ¢ #â†‘s = #E","lemma cardinal_eq_of_mem_nhds_zero
    {E : Type*} (ğ•œ : Type*) [NontriviallyNormedField ğ•œ] [AddCommGroup E] [Module ğ•œ E]
    [TopologicalSpace E] [ContinuousSMul ğ•œ E] {s : Set E} (hs : s âˆˆ ğ“ (0 : E)) : #s = #E ",":= by
  obtain âŸ¨c, hcâŸ© : âˆƒ x : ğ•œ , 1 < â€–xâ€– := NormedField.exists_lt_norm ğ•œ 1
  have cn_ne : âˆ€ n, c^n â‰  0 := by
    intro n
    apply pow_ne_zero
    rintro rfl
    simp only [norm_zero] at hc
    exact lt_irrefl _ (hc.trans zero_lt_one)
  have A : âˆ€ (x : E), âˆ€á¶  n in (atTop : Filter â„•), x âˆˆ c^n â€¢ s := by
    intro x
    have : Tendsto (fun n â†¦ (c^n) â»Â¹ â€¢ x) atTop (ğ“ ((0 : ğ•œ) â€¢ x)) := by
      have : Tendsto (fun n â†¦ (c^n)â»Â¹) atTop (ğ“ 0) := by
        simp_rw [â† inv_pow]
        apply tendsto_pow_atTop_nhds_zero_of_norm_lt_one
        rw [norm_inv]
        exact inv_lt_one hc
      exact Tendsto.smul_const this x
    rw [zero_smul] at this
    filter_upwards [this hs] with n (hn : (c ^ n)â»Â¹ â€¢ x âˆˆ s)
    exact (mem_smul_set_iff_inv_smul_memâ‚€ (cn_ne n) _ _).2 hn
  have B : âˆ€ n, #(c^n â€¢ s :) = #s := by
    intro n
    have : (c^n â€¢ s :) â‰ƒ s :=
    { toFun := fun x â†¦ âŸ¨(c^n)â»Â¹ â€¢ x.1, (mem_smul_set_iff_inv_smul_memâ‚€ (cn_ne n) _ _).1 x.2âŸ©
      invFun := fun x â†¦ âŸ¨(c^n) â€¢ x.1, smul_mem_smul_set x.2âŸ©
      left_inv := fun x â†¦ by simp [smul_smul, mul_inv_cancel (cn_ne n)]
      right_inv := fun x â†¦ by simp [smul_smul, inv_mul_cancel (cn_ne n)] }
    exact Cardinal.mk_congr this
  apply (Cardinal.mk_of_countable_eventually_mem A B).symm",rw [mem_nhds_zero_iff] at hs
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOnFilter,hasFDerivAt_of_tendstoUniformlyOnFilter,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  Â· simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Îµ hÎµ).mono fun y hy => _
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","error:  simp made no progress
warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  â€–(f' n.1 x - g' x) (n.2 - x)â€– â‰¤ â€–f' n.1 x - g' xâ€– * â€–n.2 - xâ€– : Prop
but is expected to have type
  â€–(f' n.1 x - g' x) (n.2 - x)â€– â‰¤ â€–(Prod.map (fun n â†¦ g' x - f' n x) id n).1â€– * â€–x - n.2â€– : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ğ“ x))
    (hf : âˆ€á¶  n : Î¹ Ã— E in l Ã—Ë¢ ğ“ x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : âˆ€á¶  y in ğ“ x, Tendsto (fun n => f n y) l (ğ“ (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","refine theorem_hasFDerivAt_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_of_tendstoUniformlyOnFilter_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOn hasFDerivAt_contin"
Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean,AbsoluteValue.IsAdmissible.exists_approx,exists_approx,a1bf5aea46b9638361ce40d14cbda31c78bdb63a,":= by
  haveI := Classical.decEq R
  induction' n with n ih
  Â· intro Îµ _hÎµ b _hb A
    refine' âŸ¨0, 1, _, _âŸ©
    Â· simp
    rintro âŸ¨i, âŸ¨âŸ©âŸ©
  intro Îµ hÎµ b hb A
  let M := h.card Îµ
  obtain âŸ¨s, s_inj, hsâŸ© :
    âˆƒ s : Fin (M ^ n).succ â†’ Fin (M ^ n.succ).succ,
      Function.Injective s âˆ§ âˆ€ iâ‚€ iâ‚, (abv (A (s iâ‚) 0 % b - A (s iâ‚€) 0 % b) : â„) < abv b â€¢ Îµ := by
    obtain âŸ¨t, htâŸ© :
      âˆƒ t : Fin (M ^ n.succ).succ â†’ Fin M,
        âˆ€ iâ‚€ iâ‚, t iâ‚€ = t iâ‚ â†’ (abv (A iâ‚ 0 % b - A iâ‚€ 0 % b) : â„) < abv b â€¢ Îµ :=
      h.exists_partition hÎµ hb fun x â†¦ A x 0
    obtain âŸ¨s, hsâŸ© :=
      @Fintype.exists_lt_card_fiber_of_mul_lt_card _ _ _ _ _ t (M ^ n)
        (by simpa only [Fintype.card_fin, pow_succ] using Nat.lt_succ_self (M ^ n.succ))
    refine'
      âŸ¨fun i â†¦ (Finset.univ.filter fun x â†¦ t x = s).toList.nthLe i _, _, fun iâ‚€ iâ‚ â†¦ ht _ _ _âŸ©
    Â· refine' i.2.trans_le _
      rwa [Finset.length_toList]
    Â· intro i j h
      ext
      exact Fin.mk.inj_iff.mp (List.nodup_iff_injective_get.mp (Finset.nodup_toList _) h)
    have : âˆ€ i h, (Finset.univ.filter fun x â†¦ t x = s).toList.nthLe i h âˆˆ
        Finset.univ.filter fun x â†¦ t x = s := by
      intro i h
      exact Finset.mem_toList.mp (List.get_mem _ i h)
    obtain âŸ¨_, hâ‚€âŸ© := Finset.mem_filter.mp (this iâ‚€ _)
    obtain âŸ¨_, hâ‚âŸ© := Finset.mem_filter.mp (this iâ‚ _)
    exact hâ‚€.trans hâ‚.symm
  obtain âŸ¨kâ‚€, kâ‚, hk, hâŸ© := ih hÎµ hb fun x â†¦ Fin.tail (A (s x))
  refine' âŸ¨s kâ‚€, s kâ‚, fun h â†¦ hk (s_inj h), fun i â†¦ Fin.cases _ (fun i â†¦ _) iâŸ©
  Â· exact hs kâ‚€ kâ‚
  Â· exact h i","error:  type mismatch
  hâœ
has type
  M ^ n * M < (M ^ n * M).succ : Prop
but is expected to have type
  M * M ^ n < (M ^ n * M).succ : Prop
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem exists_approx_aux (n : â„•) (h : abv.IsAdmissible) :
    âˆ€ {Îµ : â„} (_hÎµ : 0 < Îµ) {b : R} (_hb : b â‰  0) (A : Fin (h.card Îµ ^ n).succ â†’ Fin n â†’ R),
      âˆƒ iâ‚€ iâ‚, iâ‚€ â‰  iâ‚ âˆ§ âˆ€ k, (abv (A iâ‚ k % b - A iâ‚€ k % b) : â„) < abv b â€¢ Îµ ",":= by
  haveI := Classical.decEq R
  induction' n with n ih
  Â· intro Îµ _hÎµ b _hb A
    refine âŸ¨0, 1, ?_, ?_âŸ©
    Â· simp
    rintro âŸ¨i, âŸ¨âŸ©âŸ©
  intro Îµ hÎµ b hb A
  let M := h.card Îµ
  obtain âŸ¨s, s_inj, hsâŸ© :
    âˆƒ s : Fin (M ^ n).succ â†’ Fin (M ^ n.succ).succ,
      Function.Injective s âˆ§ âˆ€ iâ‚€ iâ‚, (abv (A (s iâ‚) 0 % b - A (s iâ‚€) 0 % b) : â„) < abv b â€¢ Îµ := by
    obtain âŸ¨t, htâŸ© :
      âˆƒ t : Fin (M ^ n.succ).succ â†’ Fin M,
        âˆ€ iâ‚€ iâ‚, t iâ‚€ = t iâ‚ â†’ (abv (A iâ‚ 0 % b - A iâ‚€ 0 % b) : â„) < abv b â€¢ Îµ :=
      h.exists_partition hÎµ hb fun x â†¦ A x 0
    obtain âŸ¨s, hsâŸ© :=
      Fintype.exists_lt_card_fiber_of_mul_lt_card (f := t)
        (by simpa only [Fintype.card_fin, pow_succ'] using Nat.lt_succ_self (M ^ n.succ))
    refine âŸ¨fun i â†¦ (Finset.univ.filter fun x â†¦ t x = s).toList.get <| i.castLE ?_, fun i j h â†¦ ?_,
      fun iâ‚€ iâ‚ â†¦ ht _ _ ?_âŸ©
    Â· rwa [Finset.length_toList]
    Â· ext
      simpa [(Finset.nodup_toList _).getElem_inj_iff] using h
    Â· have : âˆ€ i h, t ((Finset.univ.filter fun x â†¦ t x = s).toList.get âŸ¨i, hâŸ©) = s := fun i h â†¦
        (Finset.mem_filter.mp (Finset.mem_toList.mp (List.get_mem _ i h))).2
      simp only [Nat.succ_eq_add_one, Finset.length_toList, List.get_eq_getElem] at this
      simp only [Nat.succ_eq_add_one, List.get_eq_getElem, Fin.coe_castLE]
      rw [this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ iâ‚.2) hs),
        this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ iâ‚€.2) hs)]
  obtain âŸ¨kâ‚€, kâ‚, hk, hâŸ© := ih hÎµ hb fun x â†¦ Fin.tail (A (s x))
  refine âŸ¨s kâ‚€, s kâ‚, fun h â†¦ hk (s_inj h), fun i â†¦ Fin.cases ?_ (fun i â†¦ ?_) iâŸ©
  Â· exact hs kâ‚€ kâ‚
  Â· exact h i",rw [theorem_exists_approx_aux]
Mathlib/Algebra/FreeAlgebra.lean,FreeAlgebra.induction,induction,0bcbc985a529d2af125537fab684cb3a98de2f6f,":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X â†’ s := Subtype.coind (Î¹ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) :=
    by
    ext
    simp [Subtype.coind]
  suffices : a = lift R of a
  Â· rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a","error:  unexpected token ':'; expected term
error:  unsolved goals
case w.h
R : Type u_1
instâœ : CommSemiring R
X : Type u_2
C : FreeAlgebra R X â†’ Prop
h_grade0 : âˆ€ (r : R), C ((algebraMap R (FreeAlgebra R X)) r)
h_grade1 : âˆ€ (x : X), C (Î¹ R x)
h_mul : âˆ€ (a b : FreeAlgebra R X), C a â†’ C b â†’ C (a * b)
h_add : âˆ€ (a b : FreeAlgebra R X), C a â†’ C b â†’ C (a + b)
a : FreeAlgebra R X
s : Subalgebra R (FreeAlgebra R X) :=
  { carrier := C, mul_mem' := â‹¯, one_mem' := â‹¯, add_mem' := â‹¯, zero_mem' := â‹¯, algebraMap_mem' := h_grade0 }
of : X â†’ â†¥s := Subtype.coind (Î¹ R) h_grade1
xâœ : X
âŠ¢ Î¹ R xâœ = â†‘(of xâœ)","theorem induction {C : FreeAlgebra R X â†’ Prop}
    (h_grade0 : âˆ€ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : âˆ€ x, C (Î¹ R x))
    (h_mul : âˆ€ a b, C a â†’ C b â†’ C (a * b)) (h_add : âˆ€ a b, C a â†’ C b â†’ C (a + b))
    (a : FreeAlgebra R X) : C a ",":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X â†’ s := Subtype.coind (Î¹ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [of, Subtype.coind]
  suffices a = lift R of a by
    rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a",exact theorem_induction induction induction induction induction
Mathlib/Geometry/Euclidean/Inversion/Calculus.lean,EuclideanGeometry.hasFDerivAt_inversion,hasFDerivAt_inversion,8c4338d2f64ef8da7809ea24b10b780568e6b917,":= by
  rcases add_left_surjective c x with âŸ¨x, rflâŸ©
  have : HasFDerivAt (inversion c R) (_ : F â†’L[â„] F) (c + x) := by
    simp (config := { unfoldPartialApp := true }) only [inversion]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ğ•œ := â„) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := â„ âˆ™ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy â†¦ ?_)
  Â· have : ((â€–xâ€– ^ 2) ^ 2)â»Â¹ * (â€–xâ€– ^ 2) = (â€–xâ€– ^ 2)â»Â¹ := by
      rw [â† div_eq_inv_mul, sq (â€–xâ€– ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  Â· simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]","error:  don't know how to synthesize placeholder for argument 'f''
context:
E : Type u_1
F : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace â„ E
instâœÂ¹ : NormedAddCommGroup F
instâœ : InnerProductSpace â„ F
a b c d y z : F
r R : â„
x : F
hx : (fun x â†¦ c + x) x â‰  c
âŠ¢ F â†’L[â„] F
error:  unsolved goals
case intro
E : Type u_1
F : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace â„ E
instâœÂ¹ : NormedAddCommGroup F
instâœ : InnerProductSpace â„ F
a b c d y z : F
r R : â„
x : F
hx : (fun x â†¦ c + x) x â‰  c
âŠ¢ HasFDerivAt (inversion c R)
    ((R / dist ((fun x â†¦ c + x) x) c) ^ 2 â€¢
      â†‘{ toLinearEquiv := (reflection (Submodule.span â„ {(fun x â†¦ c + x) x - c})á—®).toLinearEquiv, continuous_toFun := â‹¯,
          continuous_invFun := â‹¯ })
    ((fun x â†¦ c + x) x)","theorem hasFDerivAt_inversion (hx : x â‰  c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 â€¢ (reflection (â„ âˆ™ (x - c))á—® : F â†’L[â„] F)) x ",":= by
  rcases add_left_surjective c x with âŸ¨x, rflâŸ©
  have : HasFDerivAt (inversion c R) (?_ : F â†’L[â„] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ğ•œ := â„) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := â„ âˆ™ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy â†¦ ?_)
  Â· have : ((â€–xâ€– ^ 2) ^ 2)â»Â¹ * (â€–xâ€– ^ 2) = (â€–xâ€– ^ 2)â»Â¹ := by
      rw [â† div_eq_inv_mul, sq (â€–xâ€– ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  Â· simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]",have hasFDerivAt_inversion hx hasFDerivAt_inversion hx hasFDerivAt_inversion hx
Mathlib/LinearAlgebra/Reflection.lean,Module.Dual.eq_of_preReflection_mapsTo,Dual.eq_of_preReflection_mapsTo,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  let u := reflection hgâ‚ * reflection hfâ‚
  have hu : u = LinearMap.id (R := R) (M := M) + (f - g).smulRight x := by
    ext y
    simp only [u, reflection_apply, hgâ‚, two_smul, LinearEquiv.coe_toLinearMap_mul,
      LinearMap.id_coe, LinearEquiv.coe_coe, LinearMap.mul_apply, LinearMap.add_apply, id_eq,
      LinearMap.coe_smulRight, LinearMap.sub_apply, map_sub, map_smul, sub_add_cancel', smul_neg,
      sub_neg_eq_add, sub_smul]
    abel
  replace hu : âˆ€ (n : â„•),
      â†‘(u ^ n) = LinearMap.id (R := R) (M := M) + (n : R) â€¢ (f - g).smulRight x := by
    intros n
    induction' n with n ih; simp
    have : ((f - g).smulRight x).comp ((n : R) â€¢ (f - g).smulRight x) = 0 := by ext; simp [hfâ‚, hgâ‚]
    rw [pow_succ, LinearEquiv.coe_toLinearMap_mul, ih, hu, add_mul, mul_add, mul_add]
    simp_rw [LinearMap.mul_eq_comp, LinearMap.comp_id, LinearMap.id_comp, this, add_zero, add_assoc,
      Nat.cast_succ, add_smul, one_smul]
  suffices IsOfFinOrder u by
    obtain âŸ¨n, hnâ‚€, hnâ‚âŸ© := isOfFinOrder_iff_pow_eq_one.mp this
    replace hnâ‚ : (â†‘(u ^ n) : M â†’â‚—[R] M) = LinearMap.id := LinearEquiv.toLinearMap_inj.mpr hnâ‚
    simpa [hnâ‚, hnâ‚€.ne', hx, sub_eq_zero] using hu n
  exact u.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo hÎ¦â‚ hÎ¦â‚‚ (hgâ‚‚.comp hfâ‚‚)","warning:  `sub_add_cancel'` has been deprecated, use `sub_add_cancel_left` instead
error:  simp made no progress","lemma Dual.eq_of_preReflection_mapsTo [CharZero R] [NoZeroSMulDivisors R M]
    {x : M} (hx : x â‰  0) {Î¦ : Set M} (hÎ¦â‚ : Î¦.Finite) (hÎ¦â‚‚ : span R Î¦ = âŠ¤) {f g : Dual R M}
    (hfâ‚ : f x = 2) (hfâ‚‚ : MapsTo (preReflection x f) Î¦ Î¦)
    (hgâ‚ : g x = 2) (hgâ‚‚ : MapsTo (preReflection x g) Î¦ Î¦) :
    f = g ",":= by
  let u := reflection hgâ‚ * reflection hfâ‚
  have hu : u = LinearMap.id (R := R) (M := M) + (f - g).smulRight x := by
    ext y
    simp only [u, reflection_apply, hgâ‚, two_smul, LinearEquiv.coe_toLinearMap_mul,
      LinearMap.id_coe, LinearEquiv.coe_coe, LinearMap.mul_apply, LinearMap.add_apply, id_eq,
      LinearMap.coe_smulRight, LinearMap.sub_apply, map_sub, map_smul, sub_add_cancel_left,
      smul_neg, sub_neg_eq_add, sub_smul]
    abel
  replace hu : âˆ€ (n : â„•),
      â†‘(u ^ n) = LinearMap.id (R := R) (M := M) + (n : R) â€¢ (f - g).smulRight x := by
    intros n
    induction n with
    | zero => simp
    | succ n ih =>
      have : ((f - g).smulRight x).comp ((n : R) â€¢ (f - g).smulRight x) = 0 := by
        ext; simp [hfâ‚, hgâ‚]
      rw [pow_succ', LinearEquiv.coe_toLinearMap_mul, ih, hu, add_mul, mul_add, mul_add]
      simp_rw [LinearMap.mul_eq_comp, LinearMap.comp_id, LinearMap.id_comp, this, add_zero,
        add_assoc, Nat.cast_succ, add_smul, one_smul]
  suffices IsOfFinOrder u by
    obtain âŸ¨n, hnâ‚€, hnâ‚âŸ© := isOfFinOrder_iff_pow_eq_one.mp this
    replace hnâ‚ : (â†‘(u ^ n) : M â†’â‚—[R] M) = LinearMap.id := LinearEquiv.toLinearMap_inj.mpr hnâ‚
    simpa [hnâ‚, hnâ‚€.ne', hx, sub_eq_zero] using hu n
  exact u.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo hÎ¦â‚ hÎ¦â‚‚ (hgâ‚‚.comp hfâ‚‚)",apply Dual.eq_of_preReflection_mapsTo f g
Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean,MeasureTheory.Measure.rnDeriv_withDensity_right_of_absolutelyContinuous,rnDeriv_withDensity_right_of_absolutelyContinuous,0a88f90fd4cfa7135d7bd7e34ca7799b79b40573,":= by
  have : SigmaFinite (Î½.withDensity f) := SigmaFinite.withDensity_of_ne_top hf hf_ne_top
  refine (withDensity_absolutelyContinuous' hf hf_ne_zero hf_ne_top).ae_eq ?_
  refine (Measure.eq_rnDerivâ‚€ (Î½ := Î½.withDensity f) ?_ Measure.MutuallySingular.zero_left ?_).symm
  Â· exact (hf.inv.mono_ac (withDensity_absolutelyContinuous _ _)).mul
      (Measure.measurable_rnDeriv _ _).aemeasurable
  Â· ext1 s hs
    conv_lhs => rw [â† Measure.withDensity_rnDeriv_eq _ _ hÎ¼Î½]
    rw [zero_add, withDensity_apply _ hs, withDensity_apply _ hs]
    rw [set_lintegral_withDensity_eq_set_lintegral_mul_non_measurableâ‚€ _ _ _ hs]
    Â· simp only [Pi.mul_apply]
      have : (fun a â†¦ f a * ((f a)â»Â¹ * Î¼.rnDeriv Î½ a)) =áµ[Î½] Î¼.rnDeriv Î½ := by
        filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2
        simp [â† mul_assoc, ENNReal.mul_inv_cancel, hx1, hx2]
      rw [lintegral_congr_ae (ae_restrict_of_ae this)]
    Â· refine ae_restrict_of_ae ?_
      filter_upwards [hf_ne_top] with x hx using hx.lt_top
    Â· exact hf.restrict","error:  application type mismatch
  withDensity_absolutelyContinuous' hf hf_ne_zero hf_ne_top
argument
  hf_ne_top
has type
  âˆ€áµ (x : Î±) âˆ‚Î½, f x â‰  âŠ¤ : Prop
but is expected to have type
  (Î½.withDensity f) ?m.16000 = 0 : Prop
error:  no goals to be solved","lemma rnDeriv_withDensity_right_of_absolutelyContinuous {Î½ : Measure Î±} [SigmaFinite Î¼]
    [SigmaFinite Î½] (hÎ¼Î½ : Î¼ â‰ª Î½) (hf : AEMeasurable f Î½)
    (hf_ne_zero : âˆ€áµ x âˆ‚Î½, f x â‰  0) (hf_ne_top : âˆ€áµ x âˆ‚Î½, f x â‰  âˆ) :
    Î¼.rnDeriv (Î½.withDensity f) =áµ[Î½] fun x â†¦ (f x)â»Â¹ * Î¼.rnDeriv Î½ x ",":= by
  have : SigmaFinite (Î½.withDensity f) := SigmaFinite.withDensity_of_ne_top hf hf_ne_top
  refine (withDensity_absolutelyContinuous' hf hf_ne_zero).ae_eq ?_
  refine (Measure.eq_rnDerivâ‚€ (Î½ := Î½.withDensity f) ?_ Measure.MutuallySingular.zero_left ?_).symm
  Â· exact (hf.inv.mono_ac (withDensity_absolutelyContinuous _ _)).mul
      (Measure.measurable_rnDeriv _ _).aemeasurable
  Â· ext1 s hs
    conv_lhs => rw [â† Measure.withDensity_rnDeriv_eq _ _ hÎ¼Î½]
    rw [zero_add, withDensity_apply _ hs, withDensity_apply _ hs]
    rw [setLIntegral_withDensity_eq_setLIntegral_mul_non_measurableâ‚€ _ _ _ hs]
    Â· simp only [Pi.mul_apply]
      have : (fun a â†¦ f a * ((f a)â»Â¹ * Î¼.rnDeriv Î½ a)) =áµ[Î½] Î¼.rnDeriv Î½ := by
        filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2
        simp [â† mul_assoc, ENNReal.mul_inv_cancel, hx1, hx2]
      rw [lintegral_congr_ae (ae_restrict_of_ae this)]
    Â· refine ae_restrict_of_ae ?_
      filter_upwards [hf_ne_top] with x hx using hx.lt_top
    Â· exact hf.restrict","have hf_ne_zero : âˆ€áµ x âˆ‚Î½, f x â‰  âˆ := by simp [hf_ne_zero, hf_ne_zero, hf_ne_top]"
Mathlib/Computability/Primrec.lean,Primrec.list_reverse,list_reverse,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  letI := prim H
  (list_foldl' H .id (const []) <| toâ‚‚ <| ((list_cons' H).compâ‚‚ snd fst).comp snd).of_eq
    (suffices âˆ€ l r, List.foldl (fun (s : List Î²) (b : Î²) => b :: s) r l = List.reverseAux l r from
      fun l => this l []
    fun l => by induction l <;> simp [*, List.reverseAux])","error:  application type mismatch
  Primrecâ‚‚.compâ‚‚ (list_cons' H) snd
argument
  snd
has type
  Primrec Prod.snd : Prop
but is expected to have type
  Primrecâ‚‚ ?m.129446 : Prop
error:  type mismatch
  this l []
has type
  List.foldl (fun s b â†¦ b :: s) [] l = l.reverseAux [] : Prop
but is expected to have type
  List.foldl (fun s b â†¦ ?m.137552 (l, s, b)) [] (id l) = l.reverse : Prop","theorem list_reverse' :
    haveI := prim H
    Primrec (@List.reverse Î²) ",":=
  letI := prim H
  (list_foldl' H .id (const []) <| toâ‚‚ <| ((list_cons' H).comp snd fst).comp snd).of_eq
    (suffices âˆ€ l r, List.foldl (fun (s : List Î²) (b : Î²) => b :: s) r l = List.reverseAux l r from
      fun l => this l []
    fun l => by induction l <;> simp [*, List.reverseAux])",rw [List.reverse_reverse]
Mathlib/Algebra/Module/PID.lean,Module.torsion_by_prime_power_decomposition,torsion_by_prime_power_decomposition,d54553bd16569ed7d2a0974b7a9c2eb160081ba9,":= by
  obtain âŸ¨d, s, hsâŸ© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  Â· simp only [Nat.zero_eq] at *
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      âŸ¨âŸ¨0âŸ©, fun x => by dsimp; rw [â† Submodule.mem_bot R, hs]; exact Submodule.mem_topâŸ©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact âŸ¨0âŸ©
  Â· have : âˆ€ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain âŸ¨j, hjâŸ© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d â†’ N â§¸ R âˆ™ s j := Submodule.Quotient.mk âˆ˜ s âˆ˜ j.succAbove
    have := IH ?_ s' ?_
    obtain âŸ¨k, âŸ¨fâŸ©âŸ© := this
    clear IH
    Â· have : âˆ€ i : Fin d,
          âˆƒ x : N, p ^ k i â€¢ x = 0 âˆ§ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain âŸ¨x, h0, h1âŸ© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine' âŸ¨x, h0, _âŸ©; rw [h1]
        simp only [LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine âŸ¨?_, âŸ¨?_âŸ©âŸ©
      Â· exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : â„•)) (finSuccEquiv d a)
      Â· refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R â§¸ _ â†’â‚—[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R âˆ™ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R â§¸ R âˆ™ p ^ @Option.rec _ (fun _ => â„•) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        Â· rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        Â· rw [â† f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, â† LinearMap.comp_assoc,
            â† LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R âˆ™ s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one, (this i).choose_spec.right]
    Â· exact (mk_surjective _).forall.mpr fun x =>
        âŸ¨(@hN x).choose, by rw [â† Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]âŸ©
    Â· have hs' := congr_arg (Submodule.map <| mkQ <| R âˆ™ s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only; rw [â† Function.comp.assoc, Set.range_comp (_ âˆ˜ s), Fin.range_succAbove]
      rw [â† Set.range_comp, â† Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'","error:  simp made no progress
error:  simp made no progress
error:  tactic 'rewrite' failed, motive is not type correct
case h.succ.intro.refine_3.intro.intro.refine_2.refine_2.H.h.h
R : Type u
instâœâ¶ : CommRing R
instâœâµ : IsDomain R
instâœâ´ : IsPrincipalIdealRing R
M : Type v
instâœÂ³ : AddCommGroup M
instâœÂ² : Module R M
p : R
hp : Irreducible p
hM : IsTorsion' M â†¥(Submonoid.powers p)
dec : (x : M) â†’ Decidable (x = 0)
d : â„•
N : Type (max u v)
instâœÂ¹ : AddCommGroup N
instâœ : Module R N
hN : IsTorsion' N â†¥(Submonoid.powers p)
s : Fin (d + 1) â†’ N
hs : Submodule.span R (Set.range s) = âŠ¤
thisâœ : (x : N) â†’ Decidable (x = 0)
j : Fin d.succ
hj : IsTorsionBy R N (p ^ pOrder hN (s j))
s' : Fin d â†’ N â§¸ Submodule.span R {s j} := Submodule.Quotient.mk âˆ˜ s âˆ˜ j.succAbove
k : Fin d â†’ â„•
f : (N â§¸ Submodule.span R {s j}) â‰ƒâ‚—[R] â¨ (i : Fin d), R â§¸ Submodule.span R {p ^ k i}
this :
  âˆ€ (i : Fin d),
    âˆƒ x,
      p ^ k i â€¢ x = 0 âˆ§
        f (Submodule.Quotient.mk x) = (DirectSum.lof R (Fin d) (fun i â†¦ R â§¸ Submodule.span R {p ^ k i}) i) 1
i : Fin d
âŠ¢ f (Submodule.Quotient.mk â‹¯.choose) =
    (DirectSum.lof R (Fin d) (fun i â†¦ R â§¸ Submodule.span R {p ^ k i}) i)
      ((Ideal.Quotient.mk (Submodule.span R {p ^ k i})) 1)
error:  failed to synthesize
  One (â¨ (i : Fin d), R â§¸ Submodule.span R {p ^ k i})
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  OneHomClass (R â§¸ Submodule.span R {p ^ k i} â†’â‚—[R] â¨ (i : Fin d), R â§¸ Submodule.span R {p ^ k i})
    (R â§¸ Submodule.span R {p ^ k i}) (â¨ (i : Fin d), R â§¸ Submodule.span R {p ^ k i})
use `set_option diagnostics true` to get diagnostic information
error:  simp made no progress","theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    âˆƒ (d : â„•) (k : Fin d â†’ â„•), Nonempty <| N â‰ƒâ‚—[R] â¨ i : Fin d, R â§¸ R âˆ™ p ^ (k i : â„•) ",":= by
  obtain âŸ¨d, s, hsâŸ© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  Â· 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      âŸ¨âŸ¨0âŸ©, fun x => by dsimp; rw [â† Submodule.mem_bot R, hs]; exact Submodule.mem_topâŸ©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact âŸ¨0âŸ©
  Â· have : âˆ€ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain âŸ¨j, hjâŸ© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d â†’ N â§¸ R âˆ™ s j := Submodule.Quotient.mk âˆ˜ s âˆ˜ j.succAbove
    have := IH ?_ s' ?_
    Â· obtain âŸ¨k, âŸ¨fâŸ©âŸ© := this
      clear IH
      have : âˆ€ i : Fin d,
          âˆƒ x : N, p ^ k i â€¢ x = 0 âˆ§ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain âŸ¨x, h0, h1âŸ© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine âŸ¨x, h0, ?_âŸ©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine âŸ¨?_, âŸ¨?_âŸ©âŸ©
      Â· exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : â„•)) (finSuccEquiv d a)
      Â· refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R â§¸ _ â†’â‚—[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R âˆ™ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R â§¸ R âˆ™ p ^ @Option.rec _ (fun _ => â„•) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        Â· rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        Â· rw [â† f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, â† LinearMap.comp_assoc,
            â† LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R âˆ™ s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    Â· exact (mk_surjective _).forall.mpr fun x =>
        âŸ¨(@hN x).choose, by rw [â† Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]âŸ©
    Â· have hs' := congr_arg (Submodule.map <| mkQ <| R âˆ™ s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [â† Function.comp.assoc, Set.range_comp (_ âˆ˜ s), Fin.range_succAbove]
      rw [â† Set.range_comp, â† Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'","refine âŸ¨torsion_by_prime_power_decomposition hN h', ?_âŸ©"
Mathlib/GroupTheory/GroupAction/Blocks.lean,MulAction.IsBlock.isBlockSystem,IsBlock.isBlockSystem,90ee4adef4081d5ea59d0008022888ad5b93d012,":= by
  constructor
  constructor
  Â· simp only [Set.mem_range, not_exists]
    intro x hx; apply Set.Nonempty.ne_empty hBe
    rw [â† Set.image_eq_empty]
    exact hx
  Â· intro a
    obtain âŸ¨b : X, hb : b âˆˆ BâŸ© := hBe
    obtain âŸ¨g, habâŸ© := exists_smul_eq G b a
    have hg : a âˆˆ g â€¢ B := by
      change a âˆˆ (fun b => g â€¢ b) '' B
      rw [Set.mem_image]
      use b
    use g â€¢ B
    constructor
    Â· simp only [Set.mem_range, exists_apply_eq_apply, exists_unique_iff_exists, exists_true_left]
      exact hg
    Â· simp only [Set.mem_range, exists_unique_iff_exists, exists_prop, and_imp, forall_exists_index,
        forall_apply_eq_imp_iff']
      intro B' g' hg' ha
      rw [â† hg']
      apply symm
      apply Or.resolve_right (IsBlock.def.mp hB g g')
      rw [Set.not_disjoint_iff]
      use a
      rw [hg']
      exact âŸ¨hg, haâŸ©
  rintro B' âŸ¨g, rflâŸ©; exact hB.smul g","error:  type mismatch
  hg
has type
  a âˆˆ g â€¢ B : Prop
but is expected to have type
  True âˆ§ a âˆˆ g â€¢ B : Prop
error:  invalid field 'smul', the environment does not contain 'MulAction.IsBlock.smul'
  hB
has type
  IsBlock G B
error:  invalid field 'smul', the environment does not contain 'Set.PairwiseDisjoint.smul'
  hB
has type
  (Set.range fun g â†¦ g â€¢ B).PairwiseDisjoint id
error:  invalid field 'smul', the environment does not contain 'Set.Pairwise.smul'
  hB
has type
  (Set.range fun g â†¦ g â€¢ B).Pairwise (Disjoint on id)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hB
has type
  (?m.104856 âˆˆ Set.range fun g â†¦ g â€¢ B) â†’
    âˆ€ â¦ƒy : Set Xâ¦„, (y âˆˆ Set.range fun g â†¦ g â€¢ B) â†’ ?m.104856 â‰  y â†’ (Disjoint on id) ?m.104856 y","theorem IsBlock.isBlockSystem [hGX : MulAction.IsPretransitive G X]
    {B : Set X} (hB : IsBlock G B) (hBe : B.Nonempty) :
    IsBlockSystem G (Set.range fun g : G => g â€¢ B) ",":= by
  refine âŸ¨âŸ¨?nonempty, ?coverâŸ©, ?mem_blocksâŸ©
  case mem_blocks => rintro B' âŸ¨g, rflâŸ©; exact hB.translate g
  Â· simp only [Set.mem_range, not_exists]
    intro g hg
    apply hBe.ne_empty
    simpa only [Set.smul_set_eq_empty] using hg
  Â· intro a
    obtain âŸ¨b : X, hb : b âˆˆ BâŸ© := hBe
    obtain âŸ¨g, rflâŸ© := exists_smul_eq G b a
    use g â€¢ B
    simp only [Set.smul_mem_smul_set_iff, hb, exists_unique_iff_exists, Set.mem_range,
      exists_apply_eq_apply, exists_const, exists_prop, and_imp, forall_exists_index,
      forall_apply_eq_imp_iff, true_and]
    intro g' ha
    apply (IsBlock.def.mp hB g' g).resolve_right
    rw [Set.not_disjoint_iff]
    refine âŸ¨g â€¢ b, ha, âŸ¨b, hb, rflâŸ©âŸ©","refine IsBlock.isBlockSystem_iff.mpr âŸ¨B, hBe, ?_âŸ©"
Mathlib/Topology/Instances/Real.lean,AddSubgroup.tendsto_zmultiples_subtype_cofinite,tendsto_zmultiples_subtype_cofinite,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  rcases eq_or_ne a 0 with rfl | ha
  Â· rw [zmultiples_zero_eq_bot, cofinite_eq_bot]; exact tendsto_bot
  Â· calc cofinite.map (zmultiples a).subtype
      â‰¤ .map (zmultiples a).subtype (.map (rangeFactorization (Â· â€¢ a)) (@cofinite â„¤)) :=
        Filter.map_mono surjective_onto_range.le_map_cofinite
    _ = (@cofinite â„¤).map (zmultiplesHom â„ a) := Filter.map_map
    _ â‰¤ cocompact â„ := Int.tendsto_zmultiplesHom_cofinite ha","error:  type mismatch
  tendsto_zmultiplesHom_cofinite ha
has type
  Tendsto (â‡‘((zmultiplesHom â„) a)) Filter.cofinite (cocompact â„) : Prop
but is expected to have type
  ?m.66265 â‰¤ cocompact â„ : Prop
error:  ambiguous, possible interpretations 
  Bornology.cofinite : Bornology â„¤
  
  Filter.cofinite : Filter â„¤","theorem tendsto_zmultiples_subtype_cofinite (a : â„) :
    Tendsto (zmultiples a).subtype cofinite (cocompact â„) ",":=
  (zmultiples a).tendsto_coe_cofinite_of_discrete",rw [tendsto_zmultiples_subtype_cofinite]
Mathlib/MeasureTheory/OuterMeasure/Caratheodory.lean,MeasureTheory.OuterMeasure.f_iUnion,f_iUnion,727c4bcd221ef8565e3e1ca42cccebc21e65c52f,":= by
  refine' le_antisymm (m.iUnion_nat s) _
  rw [ENNReal.tsum_eq_iSup_nat]
  refine' iSup_le fun n => _
  have := @isCaratheodory_sum _ m _ h hd univ n
  simp only [inter_comm, inter_univ, univ_inter] at this; simp only [this, ge_iff_le]
  exact m.mono (iUnionâ‚‚_subset fun i _ => subset_iUnion _ i)","warning:  `MeasureTheory.OuterMeasure.iUnion` has been deprecated, use `MeasureTheory.measure_iUnion_le` instead
error:  application type mismatch
  le_antisymm (m.iUnion_nat s)
argument
  m.iUnion_nat s
has type
  Pairwise (Disjoint on s) â†’ m.measureOf (â‹ƒ i, s i) â‰¤ âˆ‘' (i : â„•), m.measureOf (s i) : Prop
but is expected to have type
  m (â‹ƒ i, s i) â‰¤ âˆ‘' (i : â„•), m (s i) : Prop","theorem f_iUnion {s : â„• â†’ Set Î±} (h : âˆ€ i, IsCaratheodory m (s i)) (hd : Pairwise (Disjoint on s)) :
    m (â‹ƒ i, s i) = âˆ‘' i, m (s i) ",":= by
  refine le_antisymm (measure_iUnion_le s) ?_
  rw [ENNReal.tsum_eq_iSup_nat]
  refine iSup_le fun n => ?_
  have := @isCaratheodory_sum _ m _ h hd univ n
  simp only [inter_comm, inter_univ, univ_inter] at this; simp only [this, ge_iff_le]
  exact m.mono (iUnionâ‚‚_subset fun i _ => subset_iUnion _ i)",refine theorem_iUnion_of_disjoint_iUnion_eq_theorem f_iUnion h hd ?_
Mathlib/Geometry/Manifold/IntegralCurve.lean,isIntegralCurveOn_Ioo_eqOn_of_contMDiff,isIntegralCurveOn_Ioo_eqOn_of_contMDiff,5b2e142323b7a721e3ae2adce3b172f93a82f823,":= by
  set s := {t | Î³ t = Î³' t} âˆ© Ioo a b with hs
  suffices hsub : Ioo a b âŠ† s from fun t ht â†¦ mem_setOf.mp ((subset_def â–¸ hsub) t ht).1
  apply isPreconnected_Ioo.subset_of_closure_inter_subset (s := Ioo a b) (u := s) _
    âŸ¨tâ‚€, âŸ¨htâ‚€, âŸ¨h, htâ‚€âŸ©âŸ©âŸ©
  Â· 
    rw [hs, â† Subtype.image_preimage_val, â† Subtype.image_preimage_val,
      image_subset_image_iff Subtype.val_injective, preimage_setOf_eq]
    intros t ht
    rw [mem_preimage, â† closure_subtype] at ht
    revert ht t
    apply IsClosed.closure_subset (isClosed_eq _ _)
    Â· rw [continuous_iff_continuousAt]
      rintro âŸ¨_, htâŸ©
      apply ContinuousAt.comp _ continuousAt_subtype_val
      rw [Subtype.coe_mk]
      exact hÎ³.continuousAt ht
    Â· rw [continuous_iff_continuousAt]
      rintro âŸ¨_, htâŸ©
      apply ContinuousAt.comp _ continuousAt_subtype_val
      rw [Subtype.coe_mk]
      exact hÎ³'.continuousAt ht
  Â· rw [isOpen_iff_mem_nhds]
    intro tâ‚ htâ‚
    have hmem := Ioo_mem_nhds htâ‚.2.1 htâ‚.2.2
    have heq : Î³ =á¶ [ğ“ tâ‚] Î³' := isIntegralCurveAt_eventuallyEq_of_contMDiffAt
      (hÎ³t _ htâ‚.2) hv.contMDiffAt (hÎ³.isIntegralCurveAt hmem) (hÎ³'.isIntegralCurveAt hmem) htâ‚.1
    apply (heq.and hmem).mono
    exact fun _ ht â†¦ ht","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Subtype.val '' ?m.344964 âŠ† Subtype.val '' ?m.344965
E : Type u_1
instâœâ· : NormedAddCommGroup E
instâœâ¶ : NormedSpace â„ E
instâœâµ : CompleteSpace E
H : Type u_2
instâœâ´ : TopologicalSpace H
I : ModelWithCorners â„ E H
M : Type u_3
instâœÂ³ : TopologicalSpace M
instâœÂ² : ChartedSpace H M
instâœÂ¹ : SmoothManifoldWithCorners I M
Î³ Î³' : â„ â†’ M
v : (x : M) â†’ TangentSpace I x
sâœ s' : Set â„
tâ‚€ : â„
xâ‚€ : M
instâœ : T2Space M
a b : â„
htâ‚€ : tâ‚€ âˆˆ Ioo a b
hÎ³t : âˆ€ t âˆˆ Ioo a b, I.IsInteriorPoint (Î³ t)
hv : ContMDiff I I.tangent 1 fun x â†¦ { proj := x, snd := v x }
hÎ³ : IsIntegralCurveOn Î³ v (Ioo a b)
hÎ³' : IsIntegralCurveOn Î³' v (Ioo a b)
h : Î³ tâ‚€ = Î³' tâ‚€
s : Set â„ := {t | Î³ t = Î³' t} âˆ© Ioo a b
hs : s = {t | Î³ t = Î³' t} âˆ© Ioo a b
âŠ¢ Subtype.val '' (Subtype.val â»Â¹' Ioo a b) âŠ† Subtype.val '' (Subtype.val â»Â¹' Ioo a b)","theorem isIntegralCurveOn_Ioo_eqOn_of_contMDiff (htâ‚€ : tâ‚€ âˆˆ Ioo a b)
    (hÎ³t : âˆ€ t âˆˆ Ioo a b, I.IsInteriorPoint (Î³ t))
    (hv : ContMDiff I I.tangent 1 (fun x â†¦ (âŸ¨x, v xâŸ© : TangentBundle I M)))
    (hÎ³ : IsIntegralCurveOn Î³ v (Ioo a b)) (hÎ³' : IsIntegralCurveOn Î³' v (Ioo a b))
    (h : Î³ tâ‚€ = Î³' tâ‚€) : EqOn Î³ Î³' (Ioo a b) ",":= by
  set s := {t | Î³ t = Î³' t} âˆ© Ioo a b with hs
  suffices hsub : Ioo a b âŠ† s from fun t ht â†¦ mem_setOf.mp ((subset_def â–¸ hsub) t ht).1
  apply isPreconnected_Ioo.subset_of_closure_inter_subset (s := Ioo a b) (u := s) _
    âŸ¨tâ‚€, âŸ¨htâ‚€, âŸ¨h, htâ‚€âŸ©âŸ©âŸ©
  Â· 
    rw [hs, inter_comm, â† Subtype.image_preimage_val, inter_comm, â† Subtype.image_preimage_val,
      image_subset_image_iff Subtype.val_injective, preimage_setOf_eq]
    intros t ht
    rw [mem_preimage, â† closure_subtype] at ht
    revert ht t
    apply IsClosed.closure_subset (isClosed_eq _ _)
    Â· rw [continuous_iff_continuousAt]
      rintro âŸ¨_, htâŸ©
      apply ContinuousAt.comp _ continuousAt_subtype_val
      rw [Subtype.coe_mk]
      exact hÎ³.continuousAt ht
    Â· rw [continuous_iff_continuousAt]
      rintro âŸ¨_, htâŸ©
      apply ContinuousAt.comp _ continuousAt_subtype_val
      rw [Subtype.coe_mk]
      exact hÎ³'.continuousAt ht
  Â· rw [isOpen_iff_mem_nhds]
    intro tâ‚ htâ‚
    have hmem := Ioo_mem_nhds htâ‚.2.1 htâ‚.2.2
    have heq : Î³ =á¶ [ğ“ tâ‚] Î³' := isIntegralCurveAt_eventuallyEq_of_contMDiffAt
      (hÎ³t _ htâ‚.2) hv.contMDiffAt (hÎ³.isIntegralCurveAt hmem) (hÎ³'.isIntegralCurveAt hmem) htâ‚.1
    apply (heq.and hmem).mono
    exact fun _ ht â†¦ ht","rw [IsIntegralCurveOn, IsIntegralCurveOn, h]"
Mathlib/LinearAlgebra/Basis/VectorSpace.lean,nonzero_span_atom,nonzero_span_atom,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  constructor
  Â· rw [Submodule.ne_bot_iff]
    exact âŸ¨v, âŸ¨mem_span_singleton_self v, hvâŸ©âŸ©
  Â· intro T hT
    by_contra h
    apply hT.2
    change span K {v} â‰¤ T
    simp_rw [span_singleton_le_iff_mem, â† Ne.def, Submodule.ne_bot_iff] at *
    rcases h with âŸ¨s, âŸ¨hs, hzâŸ©âŸ©
    rcases mem_span_singleton.1 (hT.1 hs) with âŸ¨a, rflâŸ©
    rcases eq_or_ne a 0 with rfl | h
    Â· simp only [zero_smul, ne_eq, not_true] at hz
    Â· rwa [T.smul_mem_iff h] at hs","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.44941 â†’ ?m.44941 â†’ Prop
error:  simp made no progress",theorem nonzero_span_atom (v : V) (hv : v â‰  0) : IsAtom (span K {v} : Submodule K V) ,":= by
  constructor
  Â· rw [Submodule.ne_bot_iff]
    exact âŸ¨v, âŸ¨mem_span_singleton_self v, hvâŸ©âŸ©
  Â· intro T hT
    by_contra h
    apply hT.2
    change span K {v} â‰¤ T
    simp_rw [span_singleton_le_iff_mem, â† Ne.eq_def, Submodule.ne_bot_iff] at *
    rcases h with âŸ¨s, âŸ¨hs, hzâŸ©âŸ©
    rcases mem_span_singleton.1 (hT.1 hs) with âŸ¨a, rflâŸ©
    rcases eq_or_ne a 0 with rfl | h
    Â· simp only [zero_smul, ne_eq, not_true] at hz
    Â· rwa [T.smul_mem_iff h] at hs","refine Submodule.isAtom_iff.mpr âŸ¨nonzero_span_atom nonzero_span_atom v hv, ?_âŸ©"
Mathlib/RingTheory/IntegralRestrict.lean,Algebra.algebraMap_intTrace_fractionRing,Algebra.algebraMap_intTrace_fractionRing,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  haveI : IsIntegralClosure B A (FractionRing B) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (Algebra.IsIntegral.of_finite A B)
  haveI : IsLocalization (algebraMapSubmonoid B Aâ°) (FractionRing B) :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
      (isAlgebraic_of_isFractionRing _ _ (Algebra.IsIntegral.of_finite A B))
  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=
    Module.Finite_of_isLocalization A B _ _ Aâ°
  exact Algebra.map_intTraceAux x","error:  function expected at
  IsIntegralClosure.of_isIntegrallyClosed ?m.299082 ?m.299083 ?m.299087
term has type
  IsIntegralClosure ?m.299082 ?m.299083 ?m.299087
error:  function expected at
  IsIntegralClosure.isLocalization ?m.300878 (FractionRing A) ?m.300891 ?m.300893
term has type
  IsLocalization (algebraMapSubmonoid ?m.300893 ?m.300878â°) ?m.300891","lemma Algebra.algebraMap_intTrace_fractionRing (x : B) :
    algebraMap A (FractionRing A) (Algebra.intTrace A B x) =
      Algebra.trace (FractionRing A) (FractionRing B) (algebraMap B _ x) ",":= by
  haveI : IsIntegralClosure B A (FractionRing B) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  haveI : IsLocalization (algebraMapSubmonoid B Aâ°) (FractionRing B) :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=
    Module.Finite_of_isLocalization A B _ _ Aâ°
  exact Algebra.map_intTraceAux x","rw [Algebra.intTrace_eq_algebraMap_intTrace_fractionRing, Algebra.algebraMap_intTrace_fractionRing]"
Mathlib/Probability/Kernel/WithDensity.lean,ProbabilityTheory.kernel.isSFiniteKernel_withDensity_of_isFiniteKernel,isSFiniteKernel_withDensity_of_isFiniteKernel,21b59396b0bc5f6e4bc4ba0438eb57a292105701,":= by
  by_cases hf : Measurable (Function.uncurry f)
  swap; Â· rw [withDensity_of_not_measurable _ hf]; infer_instance
  let fs : â„• â†’ Î± â†’ Î² â†’ â„â‰¥0âˆ := fun n a b => min (f a b) (n + 1) - min (f a b) n
  have h_le : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ f a b â‰¤ n := by
    intro a b n hn
    have : (f a b).toReal â‰¤ n := Nat.le_of_ceil_le hn
    rw [â† ENNReal.le_ofReal_iff_toReal_le (hf_ne_top a b) _] at this
    Â· refine' this.trans (le_of_eq _)
      rw [ENNReal.ofReal_coe_nat]
    Â· norm_cast
      exact zero_le _
  have h_zero : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ fs n a b = 0 := by
    intro a b n hn
    suffices min (f a b) (n + 1) = f a b âˆ§ min (f a b) n = f a b by
      simp_rw [this.1, this.2, tsub_self (f a b)]
    exact âŸ¨min_eq_left ((h_le a b n hn).trans (le_add_of_nonneg_right zero_le_one)),
      min_eq_left (h_le a b n hn)âŸ©
  have hf_eq_tsum : f = âˆ‘' n, fs n := by
    have h_sum_a : âˆ€ a, Summable fun n => fs n a := by
      refine' fun a => Pi.summable.mpr fun b => _
      suffices : âˆ€ n, n âˆ‰ Finset.range âŒˆ(f a b).toRealâŒ‰â‚Š â†’ fs n a b = 0
      exact summable_of_ne_finset_zero this
      intro n hn_not_mem
      rw [Finset.mem_range, not_lt] at hn_not_mem
      exact h_zero a b n hn_not_mem
    ext a b : 2
    rw [tsum_apply (Pi.summable.mpr h_sum_a), tsum_apply (h_sum_a a),
      ENNReal.tsum_eq_liminf_sum_nat]
    have h_finset_sum : âˆ€ n, âˆ‘ i in Finset.range n, fs i a b = min (f a b) n := by
      intro n
      induction' n with n hn
      Â· simp
      rw [Finset.sum_range_succ, hn]
      simp
    simp_rw [h_finset_sum]
    refine' (Filter.Tendsto.liminf_eq _).symm
    refine' Filter.Tendsto.congr' _ tendsto_const_nhds
    rw [Filter.EventuallyEq, Filter.eventually_atTop]
    exact âŸ¨âŒˆ(f a b).toRealâŒ‰â‚Š, fun n hn => (min_eq_left (h_le a b n hn)).symmâŸ©
  rw [hf_eq_tsum, withDensity_tsum _ fun n : â„• => _]
  swap; Â· exact fun _ => (hf.min measurable_const).sub (hf.min measurable_const)
  refine' isSFiniteKernel_sum fun n => _
  suffices IsFiniteKernel (withDensity Îº (fs n)) by haveI := this; infer_instance
  refine' isFiniteKernel_withDensity_of_bounded _ (ENNReal.coe_ne_top : â†‘n + 1 â‰  âˆ) fun a b => _
  beta_reduce
  norm_cast
  calc
    fs n a b â‰¤ min (f a b) (n + 1) := tsub_le_self
    _ â‰¤ n + 1 := (min_le_right _ _)
    _ = â†‘(n + 1) := by norm_cast","error:  unexpected token ':'; expected term
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î¹ : Type u_3
mÎ± : MeasurableSpace Î±
mÎ² : MeasurableSpace Î²
Îºâœ : â†¥(kernel Î± Î²)
f : Î± â†’ Î² â†’ â„â‰¥0âˆ
Îº : â†¥(kernel Î± Î²)
instâœ : IsFiniteKernel Îº
hf_ne_top : âˆ€ (a : Î±) (b : Î²), f a b â‰  âŠ¤
hf : Measurable (Function.uncurry f)
fs : â„• â†’ Î± â†’ Î² â†’ â„â‰¥0âˆ := fun n a b â†¦ min (f a b) (â†‘n + 1) - min (f a b) â†‘n
h_le : âˆ€ (a : Î±) (b : Î²) (n : â„•), âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ f a b â‰¤ â†‘n
h_zero : âˆ€ (a : Î±) (b : Î²) (n : â„•), âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ fs n a b = 0
h_sum_a : âˆ€ (a : Î±), Summable fun n â†¦ fs n a
âŠ¢ f = âˆ‘' (n : â„•), fs n
error:  unsolved goals
case pos
Î± : Type u_1
Î² : Type u_2
Î¹ : Type u_3
mÎ± : MeasurableSpace Î±
mÎ² : MeasurableSpace Î²
Îºâœ : â†¥(kernel Î± Î²)
f : Î± â†’ Î² â†’ â„â‰¥0âˆ
Îº : â†¥(kernel Î± Î²)
instâœ : IsFiniteKernel Îº
hf_ne_top : âˆ€ (a : Î±) (b : Î²), f a b â‰  âŠ¤
hf : Measurable (Function.uncurry f)
fs : â„• â†’ Î± â†’ Î² â†’ â„â‰¥0âˆ := fun n a b â†¦ min (f a b) (â†‘n + 1) - min (f a b) â†‘n
h_le : âˆ€ (a : Î±) (b : Î²) (n : â„•), âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ f a b â‰¤ â†‘n
h_zero : âˆ€ (a : Î±) (b : Î²) (n : â„•), âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ fs n a b = 0
hf_eq_tsum : f = âˆ‘' (n : â„•), fs n
âŠ¢ IsSFiniteKernel (withDensity Îº f)","theorem isSFiniteKernel_withDensity_of_isFiniteKernel (Îº : kernel Î± Î²) [IsFiniteKernel Îº]
    (hf_ne_top : âˆ€ a b, f a b â‰  âˆ) : IsSFiniteKernel (withDensity Îº f) ",":= by
  by_cases hf : Measurable (Function.uncurry f)
  swap; Â· rw [withDensity_of_not_measurable _ hf]; infer_instance
  let fs : â„• â†’ Î± â†’ Î² â†’ â„â‰¥0âˆ := fun n a b => min (f a b) (n + 1) - min (f a b) n
  have h_le : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ f a b â‰¤ n := by
    intro a b n hn
    have : (f a b).toReal â‰¤ n := Nat.le_of_ceil_le hn
    rw [â† ENNReal.le_ofReal_iff_toReal_le (hf_ne_top a b) _] at this
    Â· refine this.trans (le_of_eq ?_)
      rw [ENNReal.ofReal_natCast]
    Â· norm_cast
      exact zero_le _
  have h_zero : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ fs n a b = 0 := by
    intro a b n hn
    suffices min (f a b) (n + 1) = f a b âˆ§ min (f a b) n = f a b by
      simp_rw [fs, this.1, this.2, tsub_self (f a b)]
    exact âŸ¨min_eq_left ((h_le a b n hn).trans (le_add_of_nonneg_right zero_le_one)),
      min_eq_left (h_le a b n hn)âŸ©
  have hf_eq_tsum : f = âˆ‘' n, fs n := by
    have h_sum_a : âˆ€ a, Summable fun n => fs n a := by
      refine fun a => Pi.summable.mpr fun b => ?_
      suffices âˆ€ n, n âˆ‰ Finset.range âŒˆ(f a b).toRealâŒ‰â‚Š â†’ fs n a b = 0 from
        summable_of_ne_finset_zero this
      intro n hn_not_mem
      rw [Finset.mem_range, not_lt] at hn_not_mem
      exact h_zero a b n hn_not_mem
    ext a b : 2
    rw [tsum_apply (Pi.summable.mpr h_sum_a), tsum_apply (h_sum_a a),
      ENNReal.tsum_eq_liminf_sum_nat]
    have h_finset_sum : âˆ€ n, âˆ‘ i âˆˆ Finset.range n, fs i a b = min (f a b) n := by
      intro n
      induction' n with n hn
      Â· simp
      rw [Finset.sum_range_succ, hn]
      simp [fs]
    simp_rw [h_finset_sum]
    refine (Filter.Tendsto.liminf_eq ?_).symm
    refine Filter.Tendsto.congr' ?_ tendsto_const_nhds
    rw [Filter.EventuallyEq, Filter.eventually_atTop]
    exact âŸ¨âŒˆ(f a b).toRealâŒ‰â‚Š, fun n hn => (min_eq_left (h_le a b n hn)).symmâŸ©
  rw [hf_eq_tsum, withDensity_tsum _ fun n : â„• => _]
  swap; Â· exact fun _ => (hf.min measurable_const).sub (hf.min measurable_const)
  refine isSFiniteKernel_sum fun n => ?_
  suffices IsFiniteKernel (withDensity Îº (fs n)) by haveI := this; infer_instance
  refine isFiniteKernel_withDensity_of_bounded _ (ENNReal.coe_ne_top : â†‘n + 1 â‰  âˆ) fun a b => ?_
  beta_reduce
  norm_cast
  calc
    fs n a b â‰¤ min (f a b) (n + 1) := tsub_le_self
    _ â‰¤ n + 1 := min_le_right _ _
    _ = â†‘(n + 1) := by norm_cast",refine isSFiniteKernel_withDensity_of_isFiniteKernel_withDensity_of_isFiniteKernel_withDensity_of_isFiniteKernel f
Mathlib/Topology/Algebra/InfiniteSum/Basic.lean,tprod_range,tprod_range,5bc1ad1d20d0d38fd328824a49d24b475a371d9e,":= by
  rw [â† Set.image_univ, tprod_image f (hg.injOn _)]
  simp_rw [â† comp_apply (g := g), tprod_univ (f âˆ˜ g)]","error:  application type mismatch
  tprod_image f (Injective.injOn hg ?m.123428)
argument
  Injective.injOn hg ?m.123428
has type
  âˆ€ â¦ƒxâ‚‚ : Î³â¦„, xâ‚‚ âˆˆ ?m.123426 â†’ g ?m.123427 = g xâ‚‚ â†’ ?m.123427 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn ?m.123401 ?m.123405 : Prop","theorem tprod_range {g : Î³ â†’ Î²} (f : Î² â†’ Î±) (hg : Injective g) :
    âˆ' x : Set.range g, f x = âˆ' x, f (g x) ",":= by
  rw [â† Set.image_univ, tprod_image f hg.injOn]
  simp_rw [â† comp_apply (g := g), tprod_univ (f âˆ˜ g)]",refine theorem_eq_theorem_of_eq_theorem tprod_range tprod_range tprod_range tprod_range theorem ?_
Mathlib/RingTheory/DedekindDomain/Factorization.lean,Ideal.finite_mulSupport_coe,finite_mulSupport_coe,c2d2bf7e3c17a8505a5d9206327d2cd9b9b50229,":= by
  rw [mulSupport]
  simp_rw [Ne.def, zpow_coe_nat, â† FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_one]
  exact finite_mulSupport hI","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.10383 â†’ ?m.10383 â†’ Prop
error:  simp made no progress","theorem finite_mulSupport_coe {I : Ideal R} (hI : I â‰  0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal Râ° K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : â„¤)).Finite ",":= by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, â† FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_one]
  exact finite_mulSupport hI",apply Finite.subset (finite_mulSupport_coe {I : Ideal Râ° K)
Mathlib/Topology/Category/Profinite/Nobeling.lean,Profinite.NobelingProof.GoodProducts.span_iff_products,GoodProducts.span_iff_products,a716898404cb865abf963d7081ebe54c3af39a18,":= by
  refine âŸ¨fun h â†¦ le_trans h (span_mono (fun a âŸ¨b, hbâŸ© â†¦ âŸ¨b.val, hbâŸ©)), fun h â†¦ le_trans h ?_âŸ©
  rw [span_le]
  rintro f âŸ¨l, rflâŸ©
  let L : Products I â†’ Prop := fun m â†¦ m.eval C âˆˆ span â„¤ (Set.range (GoodProducts.eval C))
  suffices L l by assumption
  apply IsWellFounded.induction (Â·<Â· : Products I â†’ Products I â†’ Prop)
  intro l h
  dsimp
  by_cases hl : l.isGood C
  Â· apply subset_span
    exact âŸ¨âŸ¨l, hlâŸ©, rflâŸ©
  Â· simp only [Products.isGood, not_not] at hl
    suffices : Products.eval C '' {m | m < l} âŠ† span â„¤ (Set.range (GoodProducts.eval C))
    Â· rw [â† span_le] at this
      exact this hl
    rintro a âŸ¨m, hm, rflâŸ©
    exact h m hm",error:  unexpected token ':'; expected term,"theorem GoodProducts.span_iff_products : âŠ¤ â‰¤ span â„¤ (Set.range (eval C)) â†”
    âŠ¤ â‰¤ span â„¤ (Set.range (Products.eval C)) ",":= by
  refine âŸ¨fun h â†¦ le_trans h (span_mono (fun a âŸ¨b, hbâŸ© â†¦ âŸ¨b.val, hbâŸ©)), fun h â†¦ le_trans h ?_âŸ©
  rw [span_le]
  rintro f âŸ¨l, rflâŸ©
  let L : Products I â†’ Prop := fun m â†¦ m.eval C âˆˆ span â„¤ (Set.range (GoodProducts.eval C))
  suffices L l by assumption
  apply IsWellFounded.induction (Â·<Â· : Products I â†’ Products I â†’ Prop)
  intro l h
  dsimp
  by_cases hl : l.isGood C
  Â· apply subset_span
    exact âŸ¨âŸ¨l, hlâŸ©, rflâŸ©
  Â· simp only [Products.isGood, not_not] at hl
    suffices Products.eval C '' {m | m < l} âŠ† span â„¤ (Set.range (GoodProducts.eval C)) by
      rw [â† span_le] at this
      exact this hl
    rintro a âŸ¨m, hm, rflâŸ©
    exact h m hm","refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©"
Mathlib/Data/List/Cycle.lean,List.prev_next,prev_next,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  obtain âŸ¨n, hn, rflâŸ© := nthLe_of_mem hx
  simp only [next_nthLe, prev_nthLe, h, Nat.mod_add_mod]
  cases' l with hd tl
  Â· simp at hx
  Â· have : (n + 1 + length tl) % (length tl + 1) = n := by
      rw [length_cons, Nat.succ_eq_add_one] at hn
      rw [add_assoc, add_comm 1, Nat.add_mod_right, Nat.mod_eq_of_lt hn]
    simp only [length_cons, Nat.succ_sub_succ_eq_sub, tsub_zero, Nat.succ_eq_add_one, this]","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
Î± : Type u_1
instâœ : DecidableEq Î±
l : List Î±
x : Î±
n : â„•
hd : Î±
tl : List Î±
h : (hd :: tl).Nodup
hnâœ : n < (hd :: tl).length
hn : n < tl.length + 1
hx : (hd :: tl).nthLe n hnâœ âˆˆ hd :: tl
âŠ¢ (n + 1 + tl.length) % (tl.length + 1) = n
error:  unsolved goals
case intro.intro.cons
Î± : Type u_1
instâœ : DecidableEq Î±
l : List Î±
x : Î±
n : â„•
hd : Î±
tl : List Î±
h : (hd :: tl).Nodup
hn : n < (hd :: tl).length
hx : (hd :: tl).nthLe n hn âˆˆ hd :: tl
this : (n + 1 + tl.length) % (tl.length + 1) = n
âŠ¢ (hd :: tl).nthLe ((n + 1 + (tl.length - 0)) % (tl.length + 1)) â‹¯ = (hd :: tl).nthLe n hn
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead","theorem prev_next (l : List Î±) (h : Nodup l) (x : Î±) (hx : x âˆˆ l) :
    prev l (next l x hx) (next_mem _ _ _) = x ",":= by
  obtain âŸ¨n, hn, rflâŸ© := nthLe_of_mem hx
  simp only [next_nthLe, prev_nthLe, h, Nat.mod_add_mod]
  cases' l with hd tl
  Â· simp at hx
  Â· have : (n + 1 + length tl) % (length tl + 1) = n := by
      rw [length_cons] at hn
      rw [add_assoc, add_comm 1, Nat.add_mod_right, Nat.mod_eq_of_lt hn]
    simp only [length_cons, Nat.succ_sub_succ_eq_sub, Nat.sub_zero, Nat.succ_eq_add_one, this]","simp only [next_mem, next_mem]"
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean,MeasureTheory.AEStronglyMeasurable.sum_measure,sum_measure,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  borelize Î²
  refine'
    aestronglyMeasurable_iff_aemeasurable_separable.2
      âŸ¨AEMeasurable.sum_measure fun i => (h i).aemeasurable, _âŸ©
  have A : âˆ€ i : Î¹, âˆƒ t : Set Î², IsSeparable t âˆ§ f â»Â¹' t âˆˆ (Î¼ i).ae := fun i =>
    (aestronglyMeasurable_iff_aemeasurable_separable.1 (h i)).2
  choose t t_sep ht using A
  refine âŸ¨â‹ƒ i, t i, .iUnion t_sep, ?_âŸ©
  simp only [Measure.ae_sum_eq, mem_iUnion, eventually_iSup]
  intro i
  filter_upwards [ht i] with x hx
  exact âŸ¨i, hxâŸ©","error:  invalid field 'ae', the environment does not contain 'MeasureTheory.Measure.ae'
  Î¼ i
has type
  Measure Î±
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Î¹ : Type u_4
instâœÂ³ : Countable Î¹
mâœ : MeasurableSpace Î±
Î¼âœ Î½ : Measure Î±
instâœÂ² : TopologicalSpace Î²
instâœÂ¹ : TopologicalSpace Î³
f g : Î± â†’ Î²
instâœ : PseudoMetrizableSpace Î²
m : MeasurableSpace Î±
Î¼ : Î¹ â†’ Measure Î±
h : âˆ€ (i : Î¹), AEStronglyMeasurable f (Î¼ i)
thisâœÂ¹ : MeasurableSpace Î² := borel Î²
thisâœ : BorelSpace Î²
âŠ¢ âˆƒ t, IsSeparable t âˆ§ âˆ€áµ (x : Î±) âˆ‚sum Î¼, f x âˆˆ t","theorem sum_measure [PseudoMetrizableSpace Î²] {m : MeasurableSpace Î±} {Î¼ : Î¹ â†’ Measure Î±}
    (h : âˆ€ i, AEStronglyMeasurable f (Î¼ i)) : AEStronglyMeasurable f (Measure.sum Î¼) ",":= by
  borelize Î²
  refine
    aestronglyMeasurable_iff_aemeasurable_separable.2
      âŸ¨AEMeasurable.sum_measure fun i => (h i).aemeasurable, ?_âŸ©
  have A : âˆ€ i : Î¹, âˆƒ t : Set Î², IsSeparable t âˆ§ f â»Â¹' t âˆˆ ae (Î¼ i) := fun i =>
    (aestronglyMeasurable_iff_aemeasurable_separable.1 (h i)).2
  choose t t_sep ht using A
  refine âŸ¨â‹ƒ i, t i, .iUnion t_sep, ?_âŸ©
  simp only [Measure.ae_sum_eq, mem_iUnion, eventually_iSup]
  intro i
  filter_upwards [ht i] with x hx
  exact âŸ¨i, hxâŸ©",refine AEStronglyMeasurable.sum ?_ ?_
Mathlib/Geometry/Manifold/BumpFunction.lean,SmoothBumpFunction.smooth_smul,smooth_smul,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  refine contMDiff_of_support fun x hx => ?_
  have : x âˆˆ (chartAt H c).source
  Â· exact f.tsupport_subset_chartAt_source <| tsupport_smul_subset_left _ _ hx
  exact f.smoothAt.smul ((hg _ this).contMDiffAt <| IsOpen.mem_nhds (chartAt _ _).open_source this)","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
E : Type uE
instâœÂ¹â° : NormedAddCommGroup E
instâœâ¹ : NormedSpace â„ E
instâœâ¸ : FiniteDimensional â„ E
H : Type uH
instâœâ· : TopologicalSpace H
I : ModelWithCorners â„ E H
M : Type uM
instâœâ¶ : TopologicalSpace M
instâœâµ : ChartedSpace H M
instâœâ´ : SmoothManifoldWithCorners I M
c : M
f : SmoothBumpFunction I c
xâœ : M
instâœÂ³ : T2Space M
instâœÂ² : SmoothManifoldWithCorners I M
G : Type u_1
instâœÂ¹ : NormedAddCommGroup G
instâœ : NormedSpace â„ G
g : M â†’ G
hg : SmoothOn I ğ“˜(â„, G) g (chartAt H c).source
x : M
hx : x âˆˆ tsupport fun x â†¦ â†‘f x â€¢ g x
this : x âˆˆ (chartAt H c).source
âŠ¢ ContMDiffAt I ğ“˜(â„, G) âŠ¤ (fun x â†¦ â†‘f x â€¢ g x) x","theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace â„ G] {g : M â†’ G}
    (hg : SmoothOn I ğ“˜(â„, G) g (chartAt H c).source) : Smooth I ğ“˜(â„, G) fun x => f x â€¢ g x ",":= by
  refine contMDiff_of_tsupport fun x hx => ?_
  have : x âˆˆ (chartAt H c).source :=
    f.tsupport_subset_chartAt_source <| tsupport_smul_subset_left _ _ hx
  exact f.smoothAt.smul ((hg _ this).contMDiffAt <| (chartAt _ _).open_source.mem_nhds this)",simp only [chartAt_source] at hg
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.prod_leftInvSeq,prod_leftInvSeq,50b72355f9be3d47d8653e9a50ac171292df7895,":= by
  simp [leftInvSeq_eq_reverse_rightInvSeq_reverse, prod_reverse_noncomm]
  have : List.map (fun x â†¦ xâ»Â¹) (ris Ï‰.reverse) = ris Ï‰.reverse := calc
    List.map (fun x â†¦ xâ»Â¹) (ris Ï‰.reverse)
    _ = List.map id (ris Ï‰.reverse)             := by
        apply List.map_congr
        intro t ht
        exact cs.inv_reflection_eq (cs.isReflection_of_mem_rightInvSeq _ ht)
    _ = ris Ï‰.reverse                           := map_id _
  rw [this]
  nth_rw 2 [â† reverse_reverse Ï‰]
  rw [wordProd_reverse]
  exact cs.prod_rightInvSeq _","warning:  `List.map_congr` has been deprecated, use `List.map_congr_left` instead
error:  invalid field 'inv_reflection_eq', the environment does not contain 'CoxeterSystem.inv_reflection_eq'
  cs
has type
  CoxeterSystem M W",theorem prod_leftInvSeq (Ï‰ : List B) : prod (lis Ï‰) = (Ï€ Ï‰)â»Â¹ ,":= by
  simp [leftInvSeq_eq_reverse_rightInvSeq_reverse, prod_reverse_noncomm]
  have : List.map (fun x â†¦ xâ»Â¹) (ris Ï‰.reverse) = ris Ï‰.reverse := calc
    List.map (fun x â†¦ xâ»Â¹) (ris Ï‰.reverse)
    _ = List.map id (ris Ï‰.reverse)             := by
        apply List.map_congr_left
        intro t ht
        exact (cs.isReflection_of_mem_rightInvSeq _ ht).inv
    _ = ris Ï‰.reverse                           := map_id _
  rw [this]
  nth_rw 2 [â† reverse_reverse Ï‰]
  rw [wordProd_reverse]
  exact cs.prod_rightInvSeq _","rw [â† prod_leftInvSeq_prod_leftInvSeq, prod_leftInvSeq, prod_leftInvSeq_prod_leftInvSeq]"
Mathlib/Topology/MetricSpace/HausdorffDistance.lean,EMetric.infEdist_singleton,infEdist_singleton,75499222cc11ae5a47a99ba69c3066b962a0dc6f,":=
  infáµ¢_singleton",error:  unknown identifier 'infáµ¢_singleton',theorem infEdist_singleton : infEdist x {y} = edist x y ,":=
  iInf_singleton",rw [infEdist_singleton]
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Real.Gamma_ne_zero,Gamma_ne_zero,3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  suffices âˆ€ {n : â„•}, -(n : â„) < s â†’ Gamma s â‰  0 by
    apply this
    swap; exact âŒŠ-sâŒ‹â‚Š + 1
    rw [neg_lt, Nat.cast_add, Nat.cast_one]
    exact Nat.lt_floor_add_one _
  intro n
  induction' n with _ n_ih generalizing s
  Â· intro hs
    refine (Gamma_pos_of_pos ?_).ne'
    rwa [Nat.cast_zero, neg_zero] at hs
  Â· intro hs'
    have : Gamma (s + 1) â‰  0 := by
      apply n_ih
      Â· intro m
        specialize hs (1 + m)
        contrapose! hs
        rw [â† eq_sub_iff_add_eq] at hs
        rw [hs]
        push_cast
        ring
      Â· rw [Nat.succ_eq_add_one, Nat.cast_add, Nat.cast_one, neg_add] at hs'
        linarith
    rw [Gamma_add_one, mul_ne_zero_iff] at this
    Â· exact this.2
    Â· simpa using hs 0","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case a
nâœ : â„•
n_ih : âˆ€ {s : â„}, (âˆ€ (m : â„•), s â‰  -â†‘m) â†’ -â†‘nâœ < s â†’ Gamma s â‰  0
s : â„
hs : âˆ€ (m : â„•), s â‰  -â†‘m
hs' : -â†‘(nâœ + 1) < s
âŠ¢ -â†‘nâœ < s + 1","theorem Gamma_ne_zero {s : â„} (hs : âˆ€ m : â„•, s â‰  -m) : Gamma s â‰  0 ",":= by
  suffices âˆ€ {n : â„•}, -(n : â„) < s â†’ Gamma s â‰  0 by
    apply this
    swap
    Â· exact âŒŠ-sâŒ‹â‚Š + 1
    rw [neg_lt, Nat.cast_add, Nat.cast_one]
    exact Nat.lt_floor_add_one _
  intro n
  induction' n with _ n_ih generalizing s
  Â· intro hs
    refine (Gamma_pos_of_pos ?_).ne'
    rwa [Nat.cast_zero, neg_zero] at hs
  Â· intro hs'
    have : Gamma (s + 1) â‰  0 := by
      apply n_ih
      Â· intro m
        specialize hs (1 + m)
        contrapose! hs
        rw [â† eq_sub_iff_add_eq] at hs
        rw [hs]
        push_cast
        ring
      Â· rw [Nat.cast_add, Nat.cast_one, neg_add] at hs'
        linarith
    rw [Gamma_add_one, mul_ne_zero_iff] at this
    Â· exact this.2
    Â· simpa using hs 0","rw [Gamma_eq_Gamma_ne_zero hs, Gamma_ne_zero hs, Gamma_ne_zero hs, Gamma_ne_zero hs,
  Gamma_ne_zero hs, Gamma_ne_zero hs, Gamma_ne_zero hs, Gamma_ne_zero hs, Gamma_ne_zero hs,
  Gamma_ne_zero hs, Gamma_ne_zero hs]"
Mathlib/Order/Filter/EventuallyConst.lean,Filter.EventuallyConst.compâ‚‚,compâ‚‚,421acd0506b28a0c309081c10818feebfc9f4e0b,":=
  let âŸ¨cf, hfâŸ© := hf; let âŸ¨cg, hgâŸ© := hg; âŸ¨op cf cg, hg.mp <| hf.mono fun _ â†¦ congr_argâ‚‚ opâŸ©","error:  application type mismatch
  op cf
argument
  cf
has type
  Set Î² : Type u_2
but is expected to have type
  Î² : Type u_2
error:  invalid field 'mp', the environment does not contain 'And.mp'
  hg
has type
  cg âˆˆ map g l âˆ§ cg.Subsingleton","lemma compâ‚‚ {g : Î± â†’ Î³} (hf : EventuallyConst f l) (op : Î² â†’ Î³ â†’ Î´) (hg : EventuallyConst g l) :
    EventuallyConst (fun x â†¦ op (f x) (g x)) l ",":=
  ((hf.prod hg).map op.uncurry).anti <|
    (tendsto_map (f := op.uncurry)).comp (tendsto_map.prod_mk tendsto_map)",apply EventuallyConst.eventuallyConst
Mathlib/RingTheory/Ideal/Basic.lean,Ideal.isPrime_of_maximally_disjoint,isPrime_of_maximally_disjoint,80c5f8cbb537199da2fe76f203fa16a7b1be7a41,"  ne_top' := by
    rintro rfl
    have : 1 âˆˆ (S : Set Î±) := S.one_mem
    aesop
  mem_or_mem' {x y} hxy := by
    by_contra' rid
    have hx := maximally_disjoint (I âŠ” span {x}) (Submodule.lt_sup_iff_not_mem.mpr rid.1)
    have hy := maximally_disjoint (I âŠ” span {y}) (Submodule.lt_sup_iff_not_mem.mpr rid.2)
    simp only [Set.not_disjoint_iff, mem_inter_iff, SetLike.mem_coe, Submodule.mem_sup,
      mem_span_singleton] at hx hy
    obtain âŸ¨sâ‚, âŸ¨iâ‚, hiâ‚, âŸ¨_, âŸ¨râ‚, rflâŸ©, hrâ‚âŸ©âŸ©, hsâ‚âŸ© := hx
    obtain âŸ¨sâ‚‚, âŸ¨iâ‚‚, hiâ‚‚, âŸ¨_, âŸ¨râ‚‚, rflâŸ©, hrâ‚‚âŸ©âŸ©, hsâ‚‚âŸ© := hy
    refine disjoint.ne_of_mem
      (I.add_mem (I.mul_mem_left (iâ‚ + x * râ‚) hiâ‚‚) <| I.add_mem (I.mul_mem_right (y * râ‚‚) hiâ‚) <|
        I.mul_mem_right (râ‚ * râ‚‚) hxy)
      (S.mul_mem hsâ‚ hsâ‚‚) ?_
    rw [â† hrâ‚, â† hrâ‚‚]
    ring","error:  unknown tactic
error:  unsolved goals
Î± : Type u
Î² : Type v
a b : Î±
instâœ : CommSemiring Î±
Iâœ I : Ideal Î±
S : Submonoid Î±
disjoint : Disjoint â†‘I â†‘S
maximally_disjoint : âˆ€ (J : Ideal Î±), I < J â†’ Â¬Disjoint â†‘J â†‘S
x y : Î±
hxy : x * y âˆˆ I
âŠ¢ x âˆˆ I âˆ¨ y âˆˆ I","lemma isPrime_of_maximally_disjoint (I : Ideal Î±)
    (S : Submonoid Î±)
    (disjoint : Disjoint (I : Set Î±) S)
    (maximally_disjoint : âˆ€ (J : Ideal Î±), I < J â†’ Â¬ Disjoint (J : Set Î±) S) :
    I.IsPrime where
","  ne_top' := by
    rintro rfl
    have : 1 âˆˆ (S : Set Î±) := S.one_mem
    aesop
  mem_or_mem' {x y} hxy := by
    by_contra! rid
    have hx := maximally_disjoint (I âŠ” span {x}) (Submodule.lt_sup_iff_not_mem.mpr rid.1)
    have hy := maximally_disjoint (I âŠ” span {y}) (Submodule.lt_sup_iff_not_mem.mpr rid.2)
    simp only [Set.not_disjoint_iff, mem_inter_iff, SetLike.mem_coe, Submodule.mem_sup,
      mem_span_singleton] at hx hy
    obtain âŸ¨sâ‚, âŸ¨iâ‚, hiâ‚, âŸ¨_, âŸ¨râ‚, rflâŸ©, hrâ‚âŸ©âŸ©, hsâ‚âŸ© := hx
    obtain âŸ¨sâ‚‚, âŸ¨iâ‚‚, hiâ‚‚, âŸ¨_, âŸ¨râ‚‚, rflâŸ©, hrâ‚‚âŸ©âŸ©, hsâ‚‚âŸ© := hy
    refine disjoint.ne_of_mem
      (I.add_mem (I.mul_mem_left (iâ‚ + x * râ‚) hiâ‚‚) <| I.add_mem (I.mul_mem_right (y * râ‚‚) hiâ‚) <|
        I.mul_mem_right (râ‚ * râ‚‚) hxy)
      (S.mul_mem hsâ‚ hsâ‚‚) ?_
    rw [â† hrâ‚, â† hrâ‚‚]
    ring",rw [disjoint_where_iff_disjoint]
Mathlib/RingTheory/Noetherian.lean,IsNoetherian.disjoint_partialSups_eventually_bot,IsNoetherian.disjoint_partialSups_eventually_bot,36094f2e079ab7eca97a3a7d838765b192471a71,":= by
  suffices t : âˆƒ n : â„•, âˆ€ m, n â‰¤ m â†’ f (m + 1) = âŠ¥
  Â· obtain âŸ¨n, wâŸ© := t
    use n + 1
    rintro (_ | m) p
    Â· cases p
    Â· apply w
      exact Nat.succ_le_succ_iff.mp p
  obtain âŸ¨n, wâŸ© := monotone_stabilizes_iff_noetherian.mpr inferInstance (partialSups f)
  exact
    âŸ¨n, fun m p =>
      (h m).eq_bot_of_ge <| sup_eq_left.1 <| (w (m + 1) <| le_add_right p).symm.trans <| w m pâŸ©","warning:  IsNoetherian does not have a doc string
error:  unexpected token 'Â·'; expected 'by' or 'from'","theorem IsNoetherian.disjoint_partialSups_eventually_bot
    (f : â„• â†’ Submodule R M) (h : âˆ€ n, Disjoint (partialSups f n) (f (n + 1))) :
    âˆƒ n : â„•, âˆ€ m, n â‰¤ m â†’ f m = âŠ¥ ",":= by
  suffices t : âˆƒ n : â„•, âˆ€ m, n â‰¤ m â†’ f (m + 1) = âŠ¥ by
    obtain âŸ¨n, wâŸ© := t
    use n + 1
    rintro (_ | m) p
    Â· cases p
    Â· apply w
      exact Nat.succ_le_succ_iff.mp p
  obtain âŸ¨n, wâŸ© := monotone_stabilizes_iff_noetherian.mpr inferInstance (partialSups f)
  exact
    âŸ¨n, fun m p =>
      (h m).eq_bot_of_ge <| sup_eq_left.1 <| (w (m + 1) <| le_add_right p).symm.trans <| w m pâŸ©",rw [IsNoetherian.disjoint_partialSups_eventually_bot]
Mathlib/Order/BooleanGenerators.lean,IsCompactlyGenerated.BooleanGenerators.complementedLattice_of_sSup_eq_top,complementedLattice_of_sSup_eq_top,91cefd36159ba7887974ebf32978e5a613629ba1,":= by
  constructor
  intro a
  obtain âŸ¨T, hT, rflâŸ© := hS.atomistic a (le_top.trans h.ge)
  use sSup (S \ T)
  constructor
  swap
  Â· rw [codisjoint_iff, â† sSup_union, Set.union_diff_self, Set.union_eq_right.mpr hT, h]
  intro b hbâ‚ hbâ‚‚
  obtain âŸ¨X, hX, rflâŸ© := hS.atomistic b (le_top.trans h.ge)
  rw [hS.sSup_le_sSup_iff_of_atoms _ _ hX] at hbâ‚ hbâ‚‚
  Â· obtain rfl : X = âˆ… := by
      have := Set.disjoint_sdiff_right hbâ‚ hbâ‚‚
      rwa [â† eq_bot_iff] at this
    simp only [sSup_empty, le_refl]
  Â· exact Set.diff_subset _ _
  Â· exact hT","error:  invalid field 'sSup_le_sSup_iff_of_atoms', the environment does not contain 'IsCompactlyGenerated.BooleanGenerators.sSup_le_sSup_iff_of_atoms'
  hS
has type
  BooleanGenerators S
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.21506
case h.disjoint.intro.intro
Î± : Type u_1
instâœÂ¹ : CompleteLattice Î±
instâœ : IsCompactlyGenerated Î±
S : Set Î±
hS : BooleanGenerators S
h : sSup S = âŠ¤
T : Set Î±
hT : T âŠ† S
X : Set Î±
hX : X âŠ† S
hbâ‚ : sSup X â‰¤ sSup T
hbâ‚‚ : sSup X â‰¤ sSup (S \ T)
âŠ¢ sSup X â‰¤ âŠ¥",lemma complementedLattice_of_sSup_eq_top (h : sSup S = âŠ¤) : ComplementedLattice Î± ,":= by
  let _i := hS.distribLattice_of_sSup_eq_top h
  have _iâ‚ := isAtomistic_of_sSup_eq_top hS h
  apply complementedLattice_of_isAtomistic",apply complementedLattice_of_sSup_eq_top
Mathlib/MeasureTheory/Measure/Regular.lean,MeasureTheory.Measure.OuterRegular.of_restrict,of_restrict,4a554788a29923d4384640e3dd9b0126a26f18bb,":= by
  refine' âŸ¨fun A hA r hr => _âŸ©
  have HA : Î¼ A < âˆ := lt_of_lt_of_le hr le_top
  have hm : âˆ€ n, MeasurableSet (s n) := fun n => (h' n).measurableSet
  obtain âŸ¨A, hAm, hAs, hAd, rflâŸ© :
    âˆƒ A' : â„• â†’ Set Î±,
      (âˆ€ n, MeasurableSet (A' n)) âˆ§
        (âˆ€ n, A' n âŠ† s n) âˆ§ Pairwise (Disjoint on A') âˆ§ A = â‹ƒ n, A' n := by
    refine'
      âŸ¨fun n => A âˆ© disjointed s n, fun n => hA.inter (MeasurableSet.disjointed hm _), fun n =>
        (inter_subset_right _ _).trans (disjointed_subset _ _),
        (disjoint_disjointed s).mono fun k l hkl => hkl.mono inf_le_right inf_le_right, _âŸ©
    rw [â† inter_iUnion, iUnion_disjointed, univ_subset_iff.mp h'', inter_univ]
  rcases ENNReal.exists_pos_sum_of_countable' (tsub_pos_iff_lt.2 hr).ne' â„• with âŸ¨Î´, Î´0, hÎ´ÎµâŸ©
  rw [lt_tsub_iff_right, add_comm] at hÎ´Îµ
  have : âˆ€ n, âˆƒ (U : _) (_ : U âŠ‡ A n), IsOpen U âˆ§ Î¼ U < Î¼ (A n) + Î´ n := by
    intro n
    have Hâ‚ : âˆ€ t, Î¼.restrict (s n) t = Î¼ (t âˆ© s n) := fun t => restrict_apply' (hm n)
    have Ht : Î¼.restrict (s n) (A n) â‰  âˆ := by
      rw [Hâ‚]
      exact ((measure_mono ((inter_subset_left _ _).trans (subset_iUnion A n))).trans_lt HA).ne
    rcases (A n).exists_isOpen_lt_add Ht (Î´0 n).ne' with âŸ¨U, hAU, hUo, hUâŸ©
    rw [Hâ‚, Hâ‚, inter_eq_self_of_subset_left (hAs _)] at hU
    exact âŸ¨U âˆ© s n, subset_inter hAU (hAs _), hUo.inter (h' n), hUâŸ©
  choose U hAU hUo hU using this
  refine' âŸ¨â‹ƒ n, U n, iUnion_mono hAU, isOpen_iUnion hUo, _âŸ©
  calc
    Î¼ (â‹ƒ n, U n) â‰¤ âˆ‘' n, Î¼ (U n) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Î¼ (A n) + Î´ n) := (ENNReal.tsum_le_tsum fun n => (hU n).le)
    _ = âˆ‘' n, Î¼ (A n) + âˆ‘' n, Î´ n := ENNReal.tsum_add
    _ = Î¼ (â‹ƒ n, A n) + âˆ‘' n, Î´ n := (congr_argâ‚‚ (Â· + Â·) (measure_iUnion hAd hAm).symm rfl)
    _ < r := hÎ´Îµ","error:  function expected at
  inter_subset_right ?m.25404
term has type
  ?m.25403 âˆˆ ?m.25402
error:  function expected at
  inter_subset_left ?m.28254
term has type
  ?m.28253 âˆˆ ?m.28251","lemma of_restrict [OpensMeasurableSpace Î±] {Î¼ : Measure Î±} {s : â„• â†’ Set Î±}
    (h : âˆ€ n, OuterRegular (Î¼.restrict (s n))) (h' : âˆ€ n, IsOpen (s n)) (h'' : univ âŠ† â‹ƒ n, s n) :
    OuterRegular Î¼ ",":= by
  refine âŸ¨fun A hA r hr => ?_âŸ©
  have HA : Î¼ A < âˆ := lt_of_lt_of_le hr le_top
  have hm : âˆ€ n, MeasurableSet (s n) := fun n => (h' n).measurableSet
  obtain âŸ¨A, hAm, hAs, hAd, rflâŸ© :
    âˆƒ A' : â„• â†’ Set Î±,
      (âˆ€ n, MeasurableSet (A' n)) âˆ§
        (âˆ€ n, A' n âŠ† s n) âˆ§ Pairwise (Disjoint on A') âˆ§ A = â‹ƒ n, A' n := by
    refine
      âŸ¨fun n => A âˆ© disjointed s n, fun n => hA.inter (MeasurableSet.disjointed hm _), fun n =>
        inter_subset_right.trans (disjointed_subset _ _),
        (disjoint_disjointed s).mono fun k l hkl => hkl.mono inf_le_right inf_le_right, ?_âŸ©
    rw [â† inter_iUnion, iUnion_disjointed, univ_subset_iff.mp h'', inter_univ]
  rcases ENNReal.exists_pos_sum_of_countable' (tsub_pos_iff_lt.2 hr).ne' â„• with âŸ¨Î´, Î´0, hÎ´ÎµâŸ©
  rw [lt_tsub_iff_right, add_comm] at hÎ´Îµ
  have : âˆ€ n, âˆƒ U âŠ‡ A n, IsOpen U âˆ§ Î¼ U < Î¼ (A n) + Î´ n := by
    intro n
    have Hâ‚ : âˆ€ t, Î¼.restrict (s n) t = Î¼ (t âˆ© s n) := fun t => restrict_apply' (hm n)
    have Ht : Î¼.restrict (s n) (A n) â‰  âˆ := by
      rw [Hâ‚]
      exact ((measure_mono (inter_subset_left.trans (subset_iUnion A n))).trans_lt HA).ne
    rcases (A n).exists_isOpen_lt_add Ht (Î´0 n).ne' with âŸ¨U, hAU, hUo, hUâŸ©
    rw [Hâ‚, Hâ‚, inter_eq_self_of_subset_left (hAs _)] at hU
    exact âŸ¨U âˆ© s n, subset_inter hAU (hAs _), hUo.inter (h' n), hUâŸ©
  choose U hAU hUo hU using this
  refine âŸ¨â‹ƒ n, U n, iUnion_mono hAU, isOpen_iUnion hUo, ?_âŸ©
  calc
    Î¼ (â‹ƒ n, U n) â‰¤ âˆ‘' n, Î¼ (U n) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Î¼ (A n) + Î´ n) := ENNReal.tsum_le_tsum fun n => (hU n).le
    _ = âˆ‘' n, Î¼ (A n) + âˆ‘' n, Î´ n := ENNReal.tsum_add
    _ = Î¼ (â‹ƒ n, A n) + âˆ‘' n, Î´ n := (congr_argâ‚‚ (Â· + Â·) (measure_iUnion hAd hAm).symm rfl)
    _ < r := hÎ´Îµ","refine OuterRegular.outerRegular_iff.mpr âŸ¨fun n => OuterRegular.outerRegular Î¼, OuterRegular.restrict,
  OuterRegular.restrict, OuterRegular.restrict, ?_âŸ©"
Mathlib/CategoryTheory/Limits/Final.lean,CategoryTheory.Functor.final_of_comp_full_faithful,final_of_comp_full_faithful,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,"  out d :=
    have := StructuredArrow.isEquivalencePost d F G
    isConnected_of_equivalent (StructuredArrow.post d F G).asEquivalence.symm","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  StructuredArrow
has type
  ?m.253840 â†’ ?m.253731 â¥¤ ?m.253840 â†’ Type (max ?u.253728 ?u.253729)
error:  invalid occurrence of universe level 'u_1' at 'CategoryTheory.Functor.final_comp_equivalence', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  final_of_comp_full_faithful.{vâ‚, vâ‚ƒ, vâ‚‚, uâ‚, uâ‚ƒ, uâ‚‚, u_1} (comp.{vâ‚, vâ‚‚, vâ‚ƒ, uâ‚, uâ‚‚, uâ‚ƒ} F G) (inv.{vâ‚‚, vâ‚ƒ, uâ‚‚, uâ‚ƒ} G)
at declaration body
  fun {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [Category.{vâ‚‚, uâ‚‚} D] {E : Type uâ‚ƒ} [Category.{vâ‚ƒ, uâ‚ƒ} E]
      (F : C â¥¤ D) (G : D â¥¤ E) [F.Final] [G.IsEquivalence] â†¦
    let i : F â‰… (F â‹™ G) â‹™ G.inv := isoWhiskerLeft F G.asEquivalence.unitIso;
    let_fun this : ((F â‹™ G) â‹™ G.inv).Final := final_of_natIso i;
    final_of_comp_full_faithful (F â‹™ G) G.inv
error:  unknown identifier 'final_comp_equivalence'
error:  invalid occurrence of universe level 'u_1' at 'CategoryTheory.Functor.final_comp', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  final_iff_comp_equivalence.{vâ‚, vâ‚ƒ, max (max (max (max (max uâ‚ uâ‚‚) uâ‚ƒ) vâ‚) vâ‚‚) vâ‚ƒ, uâ‚, uâ‚ƒ,
      max (max (max (max (max uâ‚ uâ‚‚) uâ‚ƒ) vâ‚) vâ‚‚) vâ‚ƒ, u_1}
    (comp.{vâ‚, vâ‚‚, vâ‚ƒ, uâ‚, uâ‚‚, uâ‚ƒ} F G)
    (Equivalence.functor.{vâ‚ƒ, max (max (max (max (max uâ‚ uâ‚‚) uâ‚ƒ) vâ‚) vâ‚‚) vâ‚ƒ, uâ‚ƒ,
        max (max (max (max (max uâ‚ uâ‚‚) uâ‚ƒ) vâ‚) vâ‚‚) vâ‚ƒ}
      sâ‚ƒ)
at declaration body
  fun {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [Category.{vâ‚‚, uâ‚‚} D] {E : Type uâ‚ƒ} [Category.{vâ‚ƒ, uâ‚ƒ} E]
      (F : C â¥¤ D) (G : D â¥¤ E) [F.Final] [G.Final] â†¦
    let sâ‚ : C â‰Œ AsSmall C := AsSmall.equiv;
    let sâ‚‚ : D â‰Œ AsSmall D := AsSmall.equiv;
    let sâ‚ƒ : E â‰Œ AsSmall E := AsSmall.equiv;
    let i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
      isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
    Eq.mpr (id (congrArg (fun (_a : Prop) â†¦ _a) (propext (final_iff_comp_equivalence (F â‹™ G) sâ‚ƒ.functor))))
      (Eq.mpr
        (id (congrArg (fun (_a : Prop) â†¦ _a) (propext (final_iff_equivalence_comp sâ‚.inverse ((F â‹™ G) â‹™ sâ‚ƒ.functor)))))
        (Eq.mpr (id (congrArg (fun (_a : Prop) â†¦ _a) (propext (final_natIso_iff i))))
          (Eq.mpr
            (id
              (congrArg (fun (_a : Prop) â†¦ _a)
                (propext (final_iff_isIso_colimit_pre ((sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor)))))
            (let sâ‚ƒ : E â‰Œ AsSmall E := AsSmall.equiv;
            let i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
              isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
            let sâ‚ƒ : E â‰Œ AsSmall E := AsSmall.equiv;
            let i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
              isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
            let sâ‚ƒ : E â‰Œ AsSmall E := AsSmall.equiv;
            let i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
              isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
            let i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
              isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
            let i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
              isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
            let i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
              isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
            fun (H : AsSmall E â¥¤ Type (max (max (max (max (max uâ‚ uâ‚‚) uâ‚ƒ) vâ‚) vâ‚‚) vâ‚ƒ)) â†¦
            Eq.mpr
              (id
                (congrArg
                  (fun (_a : colimit ((sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ (sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor) â‹™ H) âŸ¶ colimit H) â†¦
                    IsIso _a)
                  (Eq.symm (colimit.pre_pre H (sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor) (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor)))))
              inferInstance))))
error:  unknown identifier 'final_comp'
error:  invalid occurrence of universe level 'u_1' at 'CategoryTheory.Functor.final_of_final_comp', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  final_iff_comp_equivalence.{vâ‚‚, vâ‚ƒ, max (max (max (max (max uâ‚ uâ‚‚) uâ‚ƒ) vâ‚) vâ‚‚) vâ‚ƒ, uâ‚‚, uâ‚ƒ,
      max (max (max (max (max uâ‚ uâ‚‚) uâ‚ƒ) vâ‚) vâ‚‚) vâ‚ƒ, u_1}
    G
    (Equivalence.functor.{vâ‚ƒ, max (max (max (max (max uâ‚ uâ‚‚) uâ‚ƒ) vâ‚) vâ‚‚) vâ‚ƒ, uâ‚ƒ,
        max (max (max (max (max uâ‚ uâ‚‚) uâ‚ƒ) vâ‚) vâ‚‚) vâ‚ƒ}
      sâ‚ƒ)
at declaration body
  fun {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [Category.{vâ‚‚, uâ‚‚} D] {E : Type uâ‚ƒ} [Category.{vâ‚ƒ, uâ‚ƒ} E]
      (F : C â¥¤ D) (G : D â¥¤ E) [F.Final] [hFG : (F â‹™ G).Final] â†¦
    let sâ‚ : C â‰Œ AsSmall C := AsSmall.equiv;
    let sâ‚‚ : D â‰Œ AsSmall D := AsSmall.equiv;
    let sâ‚ƒ : E â‰Œ AsSmall E := AsSmall.equiv;
    let _i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
      isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
    Eq.mpr (id (congrArg (fun (_a : Prop) â†¦ _a) (propext (final_iff_comp_equivalence G sâ‚ƒ.functor))))
      (Eq.mpr (id (congrArg (fun (_a : Prop) â†¦ _a) (propext (final_iff_equivalence_comp sâ‚‚.inverse (G â‹™ sâ‚ƒ.functor)))))
        (Eq.mpr
          (id (congrArg (fun (_a : Prop) â†¦ _a) (propext (final_iff_isIso_colimit_pre (sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor)))))
          (let sâ‚ƒ : E â‰Œ AsSmall E := AsSmall.equiv;
          let _i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
            isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
          let sâ‚ƒ : E â‰Œ AsSmall E := AsSmall.equiv;
          let _i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
            isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
          let sâ‚ƒ : E â‰Œ AsSmall E := AsSmall.equiv;
          let _i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
            isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
          let _i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
            isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
          let _i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
            isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
          let _i_1 : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
            isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
          let _i_2 : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
            isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor));
          fun (H : AsSmall E â¥¤ Type (max (max (max (max (max uâ‚ uâ‚‚) uâ‚ƒ) vâ‚) vâ‚‚) vâ‚ƒ)) â†¦
          let_fun hFG : IsIso (colimit.pre H ((sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor)) :=
            Eq.mp
              (congrArg (fun (_a : Prop) â†¦ _a)
                (propext (final_iff_isIso_colimit_pre ((sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor))))
              (Eq.mp (congrArg (fun (_a : Prop) â†¦ _a) (propext (final_natIso_iff _i)))
                (Eq.mp
                  (congrArg (fun (_a : Prop) â†¦ _a)
                    (propext (final_iff_equivalence_comp sâ‚.inverse ((F â‹™ G) â‹™ sâ‚ƒ.functor))))
                  (Eq.mp (congrArg (fun (_a : Prop) â†¦ _a) (propext (final_iff_comp_equivalence (F â‹™ G) sâ‚ƒ.functor)))
                    hFG)))
              H;
          IsIso.of_isIso_comp_left (colimit.pre ((sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor) â‹™ H) (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor))
            (colimit.pre H (sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor)))))
error:  unknown identifier 'final_of_final_comp'
error:  unknown identifier 'final_of_final_comp'
error:  unknown identifier 'final_comp'
error:  unknown identifier 'final_comp'
error:  unknown identifier 'final_of_final_comp'","theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F â‹™ G)] : Final F where
",  out d := isConnected_of_equivalent (StructuredArrow.post d F G).asEquivalence.symm,apply Final.final_of_comp_full_faithful
Mathlib/Combinatorics/SetFamily/CauchyDavenport.lean,Finset.min_le_card_mul,Finset.min_le_card_mul,9f6d33884de569540c527b667d1573e1b97e1347,":= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain âŸ¨rfl, rflâŸ© := hx
  refine' wellFoundedOn_devosMulRel.induction (P := fun x : Finset Î± Ã— Finset Î± â†¦
    min (minOrder Î±) â†‘(card x.1 + card x.2 - 1) â‰¤ card (x.1 * x.2)) âŸ¨hs, htâŸ© _
  clear! x
  rintro âŸ¨s, tâŸ© âŸ¨hs, htâŸ© ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  Â· simpa only [â† mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [â† mul_inv_rev, add_comm, card_inv, true_and])
  obtain âŸ¨a, rflâŸ© | âŸ¨a, ha, b, hb, habâŸ© := hs.exists_eq_singleton_or_nontrivial
  Â· simp [add_comm]
  obtain âŸ¨g, hg, hgsâŸ© : âˆƒ g : Î±, g â‰  1 âˆ§ (s âˆ© op g â€¢ s).Nonempty :=
    âŸ¨bâ»Â¹ * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 âŸ¨ha, mem_smul_finset.2 âŸ¨_, hb, by simpâŸ©âŸ©âŸ©
  obtain hsg | hsg := eq_or_ne (op g â€¢ s) s
  Â· have hS : (zpowers g : Set Î±) âŠ† aâ»Â¹ â€¢ (s : Set Î±) := by
      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (Â· âˆˆ aâ»Â¹ â€¢ (s : Set Î±))
        âŸ¨_, ha, inv_mul_self _âŸ© (fun c hc â†¦ ?_) fun c hc â†¦ ?_
      Â· rw [â† hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      Â· simp only
        rwa [â† op_smul_eq_mul, op_inv, â† Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          â† coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [â† coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s âˆ© op g â€¢ s).card < s.card := card_lt_card âŸ¨inter_subset_left _ _, fun h â†¦
    hsg <| eq_of_superset_of_card_ge (h.trans <| inter_subset_right _ _) (card_smul_finset _ _).leâŸ©
  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (gâ»Â¹ â€¢ t)
  Â· rw [â† card_smul_finset gâ»Â¹ t]
    refine' Or.inr ((add_le_add_right hst _).trans _)
    rw [â† card_union_eq hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  Â· exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h â†¦ hstg.trans <| h.trans <| add_le_add_right aux1 _
  Â· exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h â†¦
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _","error:  function expected at
  inter_subset_left ?m.46803
term has type
  ?m.46802 âˆˆ ?m.46800
error:  function expected at
  inter_subset_right ?m.46987
term has type
  ?m.46986 âˆˆ ?m.46985
warning:  `Finset.card_union_eq` has been deprecated, use `Finset.card_union_of_disjoint` instead","lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder Î±) â†‘(s.card + t.card - 1) â‰¤ (s * t).card ",":= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain âŸ¨rfl, rflâŸ© := hx
  refine wellFoundedOn_devosMulRel.induction (P := fun x : Finset Î± Ã— Finset Î± â†¦
    min (minOrder Î±) â†‘(card x.1 + card x.2 - 1) â‰¤ card (x.1 * x.2)) âŸ¨hs, htâŸ© ?_
  clear! x
  rintro âŸ¨s, tâŸ© âŸ¨hs, htâŸ© ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  Â· simpa only [â† mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [â† mul_inv_rev, add_comm, card_inv, true_and])
  obtain âŸ¨a, rflâŸ© | âŸ¨a, ha, b, hb, habâŸ© := hs.exists_eq_singleton_or_nontrivial
  Â· simp [add_comm]
  obtain âŸ¨g, hg, hgsâŸ© : âˆƒ g : Î±, g â‰  1 âˆ§ (s âˆ© op g â€¢ s).Nonempty :=
    âŸ¨bâ»Â¹ * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 âŸ¨ha, mem_smul_finset.2 âŸ¨_, hb, by simpâŸ©âŸ©âŸ©
  obtain hsg | hsg := eq_or_ne (op g â€¢ s) s
  Â· have hS : (zpowers g : Set Î±) âŠ† aâ»Â¹ â€¢ (s : Set Î±) := by
      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (Â· âˆˆ aâ»Â¹ â€¢ (s : Set Î±))
        âŸ¨_, ha, inv_mul_self _âŸ© (fun c hc â†¦ ?_) fun c hc â†¦ ?_
      Â· rw [â† hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      Â· simp only
        rwa [â† op_smul_eq_mul, op_inv, â† Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          â† coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [â† coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s âˆ© op g â€¢ s).card < s.card := card_lt_card âŸ¨inter_subset_left, fun h â†¦
    hsg <| eq_of_superset_of_card_ge (h.trans inter_subset_right) (card_smul_finset _ _).leâŸ©
  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (gâ»Â¹ â€¢ t)
  Â· rw [â† card_smul_finset gâ»Â¹ t]
    refine Or.inr ((add_le_add_right hst _).trans ?_)
    rw [â† card_union_of_disjoint hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  Â· exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h â†¦ hstg.trans <| h.trans <| add_le_add_right aux1 _
  Â· exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h â†¦
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _","rw [card_mul, Finset.min_le_card_mul]"
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.getD_leftInvSeq_mul_wordProd,getD_leftInvSeq_mul_wordProd,5549e23620db2b17d4924bff0c4de45d992f0b8d,":= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [â† take_append_drop (j + 1) Ï‰]
  rw [take_succ]
  rcases em (j < Ï‰.length) with hj | nhj
  Â· rw [get?_eq_get hj]
    simp only [wordProd_append, wordProd_cons, mul_assoc]
    simp
  Â· rw [get?_eq_none.mpr (by linarith)]
    simp","error:  unsolved goals
case inl
B : Type u_1
W : Type u_2
instâœ : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
Ï‰ : List B
j : â„•
hj : j < Ï‰.length
âŠ¢ cs.simple Ï‰[j] * (cs.wordProd Ï‰[j]?.toList * cs.wordProd (drop (j + 1) Ï‰)) = cs.wordProd (drop (j + 1) Ï‰)
error:  unsolved goals
case inr
B : Type u_1
W : Type u_2
instâœ : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
Ï‰ : List B
j : â„•
nhj : Â¬j < Ï‰.length
âŠ¢ cs.wordProd (take j Ï‰ ++ (Ï‰[j]?.toList ++ drop (j + 1) Ï‰)) = cs.wordProd (take j Ï‰ ++ drop (j + 1) Ï‰)","theorem getD_leftInvSeq_mul_wordProd (Ï‰ : List B) (j : â„•) :
    ((lis Ï‰).getD j 1) * Ï€ Ï‰ = Ï€ (Ï‰.eraseIdx j) ",":= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [â† take_append_drop (j + 1) Ï‰]
  rw [take_succ]
  obtain lt | le := lt_or_le j Ï‰.length
  Â· simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]
    simp
  Â· simp only [get?_eq_getElem?, getElem?_eq_none le]
    simp",simp only [getD_leftInvSeq_mul_wordProd]
Mathlib/SetTheory/Ordinal/Exponential.lean,Ordinal.opow_add,opow_add,c342c339a777827331257acd880fea6d441a6aa6,":= by
  rcases eq_or_ne a 0 with (rfl | a0)
  Â· rcases eq_or_ne c 0 with (rfl | c0)
    Â· simp
    have : b + c â‰  0 := ((Ordinal.pos_iff_ne_zero.2 c0).trans_le (le_add_left _ _)).ne'
    simp only [zero_opow c0, zero_opow this, mul_zero]
  rcases eq_or_lt_of_le (one_le_iff_ne_zero.2 a0) with (rfl | a1)
  Â· simp only [one_opow, mul_one]
  induction c with
  | Hâ‚ => simp
  | Hâ‚‚ c IH =>
    rw [add_succ, opow_succ, IH, opow_succ, mul_assoc]
  | Hâ‚ƒ c l IH =>
    refine
      eq_of_forall_ge_iff fun d =>
        (((opow_isNormal a1).trans (add_isNormal b)).limit_le l).trans ?_
    dsimp only [Function.comp_def]
    simp (config := { contextual := true }) only [IH]
    exact
      (((mul_isNormal <| opow_pos b (Ordinal.pos_iff_ne_zero.2 a0)).trans
              (opow_isNormal a1)).limit_le
          l).symm","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
case inr.inr
a b c : Ordinal.{u_1}
a0 : a â‰  0
a1 : 1 < a
âŠ¢ a ^ (b + c) = a ^ b * a ^ c",theorem opow_add (a b c : Ordinal) : a ^ (b + c) = a ^ b * a ^ c ,":= by
  rcases eq_or_ne a 0 with (rfl | a0)
  Â· rcases eq_or_ne c 0 with (rfl | c0)
    Â· simp
    have : b + c â‰  0 := ((Ordinal.pos_iff_ne_zero.2 c0).trans_le (le_add_left _ _)).ne'
    simp only [zero_opow c0, zero_opow this, mul_zero]
  rcases eq_or_lt_of_le (one_le_iff_ne_zero.2 a0) with (rfl | a1)
  Â· simp only [one_opow, mul_one]
  induction c using limitRecOn with
  | Hâ‚ => simp
  | Hâ‚‚ c IH =>
    rw [add_succ, opow_succ, IH, opow_succ, mul_assoc]
  | Hâ‚ƒ c l IH =>
    refine
      eq_of_forall_ge_iff fun d =>
        (((opow_isNormal a1).trans (add_isNormal b)).limit_le l).trans ?_
    dsimp only [Function.comp_def]
    simp (config := { contextual := true }) only [IH]
    exact
      (((mul_isNormal <| opow_pos b (Ordinal.pos_iff_ne_zero.2 a0)).trans
              (opow_isNormal a1)).limit_le
          l).symm","simp only [opow_add, opow_add]"
Mathlib/Data/Nat/Log.lean,Nat.pow_le_iff_le_log,pow_le_iff_le_log,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' y using Nat.strong_induction_on with y ih generalizing x
  cases x with
  | zero => dsimp; omega
  | succ x =>
    rw [log]; split_ifs with h
    Â· have b_pos : 0 < b := lt_of_succ_lt hb
      rw [succ_eq_add_one, Nat.add_le_add_iff_right, â† ih (y / b) (div_lt_self
        (Nat.pos_iff_ne_zero.2 hy) hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,
        pow_succ', Nat.mul_comm]
    Â· exact iff_of_false (fun hby => h âŸ¨(le_self_pow x.succ_ne_zero _).trans hby, hbâŸ©)
        (not_succ_le_zero _)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case pos
b : â„•
hb : 1 < b
y : â„•
ih : âˆ€ m < y, âˆ€ {x : â„•}, m â‰  0 â†’ (b ^ x â‰¤ m â†” x â‰¤ log b m)
hy : y â‰  0
x : â„•
h : b â‰¤ y âˆ§ 1 < b
b_pos : 0 < b
âŠ¢ b ^ (x + 1) â‰¤ y â†” x + 1 â‰¤ log b (y / b) + 1","theorem pow_le_iff_le_log {b : â„•} (hb : 1 < b) {x y : â„•} (hy : y â‰  0) :
    b ^ x â‰¤ y â†” x â‰¤ log b y ",":= by
  induction' y using Nat.strong_induction_on with y ih generalizing x
  cases x with
  | zero => dsimp; omega
  | succ x =>
    rw [log]; split_ifs with h
    Â· have b_pos : 0 < b := lt_of_succ_lt hb
      rw [Nat.add_le_add_iff_right, â† ih (y / b) (div_lt_self
        (Nat.pos_iff_ne_zero.2 hy) hb) (Nat.div_pos h.1 b_pos).ne', le_div_iff_mul_le b_pos,
        pow_succ', Nat.mul_comm]
    Â· exact iff_of_false (fun hby => h âŸ¨(le_self_pow x.succ_ne_zero _).trans hby, hbâŸ©)
        (not_succ_le_zero _)","refine âŸ¨fun h => ?_, fun h => ?_âŸ©"
Mathlib/Data/Set/Basic.lean,Set.diff_union_of_subset,diff_union_of_subset,70dcc1355b9ce0a6754f8d809c95a171072d3aac,":=
  Subset.antisymm (union_subset (diff_subset _ _) h) (subset_diff_union _ _)","error:  function expected at
  diff_subset ?m.92021
term has type
  ?m.92020 âˆˆ ?m.92018",theorem diff_union_of_subset {s t : Set Î±} (h : t âŠ† s) : s \ t âˆª t = s ,":=
  Subset.antisymm (union_subset diff_subset h) (subset_diff_union _ _)","rw [union_diff_subset, diff_union_of_subset]"
Mathlib/Probability/Martingale/BorelCantelli.lean,MeasureTheory.Submartingale.exists_tendsto_of_abs_bddAbove_aux,Submartingale.exists_tendsto_of_abs_bddAbove_aux,9e34a191034458a56331f976ff7400a26407c888,":= by
  have ht :
    âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i : â„•, âˆƒ c, Tendsto (fun n => stoppedValue f (leastGE f i n) Ï‰) atTop (ğ“ c) := by
    rw [ae_all_iff]
    exact fun i => Submartingale.exists_ae_tendsto_of_bdd (hf.stoppedValue_leastGE i)
      (hf.stoppedValue_leastGE_snorm_le' i.cast_nonneg hf0 hbdd)
  filter_upwards [ht] with Ï‰ hÏ‰ hÏ‰b
  rw [BddAbove] at hÏ‰b
  obtain âŸ¨i, hiâŸ© := exists_nat_gt hÏ‰b.some
  have hib : âˆ€ n, f n Ï‰ < i := by
    intro n
    exact lt_of_le_of_lt ((mem_upperBounds.1 hÏ‰b.some_mem) _ âŸ¨n, rflâŸ©) hi
  have heq : âˆ€ n, stoppedValue f (leastGE f i n) Ï‰ = f n Ï‰ := by
    intro n
    rw [leastGE]; unfold hitting; rw [stoppedValue]
    simp only
    rw [if_neg]
    simp only [Set.mem_Icc, Set.mem_union, Set.mem_Ici]
    push_neg
    exact fun j _ => hib j
  simp only [â† heq, hÏ‰ i]",error:  simp made no progress,"theorem Submartingale.exists_tendsto_of_abs_bddAbove_aux [IsFiniteMeasure Î¼]
    (hf : Submartingale f â„± Î¼) (hf0 : f 0 = 0) (hbdd : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i, |f (i + 1) Ï‰ - f i Ï‰| â‰¤ R) :
    âˆ€áµ Ï‰ âˆ‚Î¼, BddAbove (Set.range fun n => f n Ï‰) â†’ âˆƒ c, Tendsto (fun n => f n Ï‰) atTop (ğ“ c) ",":= by
  have ht :
    âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i : â„•, âˆƒ c, Tendsto (fun n => stoppedValue f (leastGE f i n) Ï‰) atTop (ğ“ c) := by
    rw [ae_all_iff]
    exact fun i => Submartingale.exists_ae_tendsto_of_bdd (hf.stoppedValue_leastGE i)
      (hf.stoppedValue_leastGE_snorm_le' i.cast_nonneg hf0 hbdd)
  filter_upwards [ht] with Ï‰ hÏ‰ hÏ‰b
  rw [BddAbove] at hÏ‰b
  obtain âŸ¨i, hiâŸ© := exists_nat_gt hÏ‰b.some
  have hib : âˆ€ n, f n Ï‰ < i := by
    intro n
    exact lt_of_le_of_lt ((mem_upperBounds.1 hÏ‰b.some_mem) _ âŸ¨n, rflâŸ©) hi
  have heq : âˆ€ n, stoppedValue f (leastGE f i n) Ï‰ = f n Ï‰ := by
    intro n
    rw [leastGE]; unfold hitting; rw [stoppedValue]
    rw [if_neg]
    simp only [Set.mem_Icc, Set.mem_union, Set.mem_Ici]
    push_neg
    exact fun j _ => hib j
  simp only [â† heq, hÏ‰ i]",simp only [Submartingale.exists_tendsto_exists_tendsto_exists_tendsto_exists_tendsto_exists_tendsto_exists_tendsto_of_abs_bdd]
Mathlib/Analysis/BoundedVariation.lean,eVariationOn.comp_inter_Icc_eq_of_monotoneOn,comp_inter_Icc_eq_of_monotoneOn,1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493,":= by
  rcases le_total x y with (h | h)
  Â· convert comp_eq_of_monotoneOn f Ï† (hÏ†.mono (Set.inter_subset_left t (Icc x y)))
    apply le_antisymm
    Â· rintro _ âŸ¨âŸ¨u, us, rflâŸ©, vÏ†x, vÏ†yâŸ©
      rcases le_total x u with (xu | ux)
      Â· rcases le_total u y with (uy | yu)
        Â· exact âŸ¨u, âŸ¨us, âŸ¨xu, uyâŸ©âŸ©, rflâŸ©
        Â· rw [le_antisymm vÏ†y (hÏ† hy us yu)]
          exact âŸ¨y, âŸ¨hy, âŸ¨h, le_rflâŸ©âŸ©, rflâŸ©
      Â· rw [â† le_antisymm vÏ†x (hÏ† us hx ux)]
        exact âŸ¨x, âŸ¨hx, âŸ¨le_rfl, hâŸ©âŸ©, rflâŸ©
    Â· rintro _ âŸ¨u, âŸ¨âŸ¨hu, xu, uyâŸ©, rflâŸ©âŸ©
      exact âŸ¨âŸ¨u, hu, rflâŸ©, âŸ¨hÏ† hx hu xu, hÏ† hu hy uyâŸ©âŸ©
  Â· rw [eVariationOn.subsingleton, eVariationOn.subsingleton]
    exacts [(Set.subsingleton_Icc_of_ge (hÏ† hy hx h)).anti (Set.inter_subset_right _ _),
      (Set.subsingleton_Icc_of_ge h).anti (Set.inter_subset_right _ _)]","error:  application type mismatch
  inter_subset_left t
argument
  t
has type
  Set Î² : Type u_3
but is expected to have type
  ?m.218515 âˆˆ ?m.218513 âˆ© ?m.218514 : Prop
error:  function expected at
  inter_subset_right ?m.223068
term has type
  ?m.223067 âˆˆ ?m.223066
error:  function expected at
  inter_subset_right ?m.224329
term has type
  ?m.224328 âˆˆ ?m.224327","theorem comp_inter_Icc_eq_of_monotoneOn (f : Î± â†’ E) {t : Set Î²} (Ï† : Î² â†’ Î±) (hÏ† : MonotoneOn Ï† t)
    {x y : Î²} (hx : x âˆˆ t) (hy : y âˆˆ t) :
    eVariationOn (f âˆ˜ Ï†) (t âˆ© Icc x y) = eVariationOn f (Ï† '' t âˆ© Icc (Ï† x) (Ï† y)) ",":= by
  rcases le_total x y with (h | h)
  Â· convert comp_eq_of_monotoneOn f Ï† (hÏ†.mono Set.inter_subset_left)
    apply le_antisymm
    Â· rintro _ âŸ¨âŸ¨u, us, rflâŸ©, vÏ†x, vÏ†yâŸ©
      rcases le_total x u with (xu | ux)
      Â· rcases le_total u y with (uy | yu)
        Â· exact âŸ¨u, âŸ¨us, âŸ¨xu, uyâŸ©âŸ©, rflâŸ©
        Â· rw [le_antisymm vÏ†y (hÏ† hy us yu)]
          exact âŸ¨y, âŸ¨hy, âŸ¨h, le_rflâŸ©âŸ©, rflâŸ©
      Â· rw [â† le_antisymm vÏ†x (hÏ† us hx ux)]
        exact âŸ¨x, âŸ¨hx, âŸ¨le_rfl, hâŸ©âŸ©, rflâŸ©
    Â· rintro _ âŸ¨u, âŸ¨âŸ¨hu, xu, uyâŸ©, rflâŸ©âŸ©
      exact âŸ¨âŸ¨u, hu, rflâŸ©, âŸ¨hÏ† hx hu xu, hÏ† hu hy uyâŸ©âŸ©
  Â· rw [eVariationOn.subsingleton, eVariationOn.subsingleton]
    exacts [(Set.subsingleton_Icc_of_ge (hÏ† hy hx h)).anti Set.inter_subset_right,
      (Set.subsingleton_Icc_of_ge h).anti Set.inter_subset_right]",refine eVariationOn.eqVariationOn f (Ï† '' t âˆ© Icc (Ï† x) (Ï† y)) ?_
Mathlib/Analysis/LocallyConvex/Bounded.lean,Bornology.isVonNBounded_covers,isVonNBounded_covers,fce7faeae2bd16f268cd47d7cd0fceb445a4d5ac,":=
  Set.eq_univ_iff_forall.mpr fun x =>
    Set.mem_unionâ‚›.mpr âŸ¨{x}, isVonNBounded_singleton _, Set.mem_singleton _âŸ©",error:  unknown constant 'Set.mem_unionâ‚›.mpr',theorem isVonNBounded_covers : â‹ƒâ‚€ setOf (IsVonNBounded ğ•œ) = (Set.univ : Set E) ,":=
  Set.eq_univ_iff_forall.mpr fun x =>
    Set.mem_sUnion.mpr âŸ¨{x}, isVonNBounded_singleton _, Set.mem_singleton _âŸ©",simp [isVonNBounded_covers]
Mathlib/RingTheory/DedekindDomain/Dvr.lean,IsDedekindDomain.isDedekindDomainDvr,IsDedekindDomain.isDedekindDomainDvr,9e34a191034458a56331f976ff7400a26407c888,":=
  { isNoetherianRing := IsDedekindDomain.isNoetherianRing
    is_dvr_at_nonzero_prime := fun _ hP _ =>
      IsLocalization.AtPrime.discreteValuationRing_of_dedekind_domain A hP _ }",error:  unknown constant 'IsDedekindDomain.isNoetherianRing',theorem IsDedekindDomain.isDedekindDomainDvr [IsDedekindDomain A] : IsDedekindDomainDvr A ,":=
  { isNoetherianRing := IsDedekindRing.toIsNoetherian
    is_dvr_at_nonzero_prime := fun _ hP _ =>
      IsLocalization.AtPrime.discreteValuationRing_of_dedekind_domain A hP _ }",rw [IsDedekindDomain.isDedekindDomainDvr]
Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean,MeasureTheory.Measure.lintegral_rnDeriv,lintegral_rnDeriv,069e96204afb60639e37cc18449fd7f58ab913c1,":= by
  rw [â† set_lintegral_univ, set_lintegral_rnDeriv hÎ¼Î½ MeasurableSet.univ]","warning:  `MeasureTheory.set_lintegral_univ` has been deprecated, use `MeasureTheory.setLIntegral_univ` instead
warning:  `MeasureTheory.Measure.set_lintegral_rnDeriv` has been deprecated, use `MeasureTheory.Measure.setLIntegral_rnDeriv` instead
error:  application type mismatch
  set_lintegral_rnDeriv hÎ¼Î½ MeasurableSet.univ
argument
  MeasurableSet.univ
has type
  MeasurableSet Set.univ : Prop
but is expected to have type
  Set Î± : Type u_1
error:  failed to synthesize
  SFinite Î½
use `set_option diagnostics true` to get diagnostic information
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.41109
Î± : Type u_1
Î² : Type u_2
m : MeasurableSpace Î±
Î¼ Î½ : Measure Î±
instâœ : Î¼.HaveLebesgueDecomposition Î½
hÎ¼Î½ : Î¼ â‰ª Î½
âŠ¢ âˆ«â» (x : Î±) in Set.univ, Î¼.rnDeriv Î½ x âˆ‚Î½ = Î¼ Set.univ","lemma lintegral_rnDeriv [HaveLebesgueDecomposition Î¼ Î½] (hÎ¼Î½ : Î¼ â‰ª Î½) :
    âˆ«â» x, Î¼.rnDeriv Î½ x âˆ‚Î½ = Î¼ Set.univ ",":= by
  rw [â† setLIntegral_univ, setLIntegral_rnDeriv' hÎ¼Î½ MeasurableSet.univ]","rw [â† haveLebesgueDecomposition_add Î¼ Î½, haveLebesgueDecomposition_add Î¼ Î½]"
Mathlib/Combinatorics/Additive/RuzsaCovering.lean,Finset.exists_subset_mul_div,exists_subset_mul_div,93fe16b79b4d74f8ddaec22ca9d80d09915ac92b,":= by
  haveI : âˆ€ u, Decidable ((u : Set Î±).PairwiseDisjoint (Â· â€¢ t)) := fun u â†¦ Classical.dec _
  set C := s.powerset.filter fun u â†¦ u.toSet.PairwiseDisjoint (Â· â€¢ t)
  obtain âŸ¨u, hu, hCmaxâŸ© := C.exists_maximal (filter_nonempty_iff.2
    âŸ¨âˆ…, empty_mem_powerset _, by rw [coe_empty]; exact Set.pairwiseDisjoint_emptyâŸ©)
  rw [mem_filter, mem_powerset] at hu
  refine' âŸ¨u,
    (card_mul_iff.2 <| pairwiseDisjoint_smul_iff.1 hu.2).ge.trans
      (card_le_of_subset <| mul_subset_mul_right hu.1),
    fun a ha â†¦ _âŸ©
  rw [mul_div_assoc]
  by_cases hau : a âˆˆ u
  Â· exact subset_mul_left _ ht.one_mem_div hau
  by_cases H : âˆ€ b âˆˆ u, Disjoint (a â€¢ t) (b â€¢ t)
  Â· refine' (hCmax _ _ <| ssubset_insert hau).elim
    rw [mem_filter, mem_powerset, insert_subset_iff, coe_insert]
    exact âŸ¨âŸ¨ha, hu.1âŸ©, hu.2.insert fun _ hb _ â†¦ H _ hbâŸ©
  push_neg at H
  simp_rw [not_disjoint_iff, â† inv_smul_mem_iff] at H
  obtain âŸ¨b, hb, c, hcâ‚, hcâ‚‚âŸ© := H
  refine' mem_mul.2 âŸ¨b, a / b, hb, _, by simpâŸ©
  exact mem_div.2 âŸ¨_, _, hcâ‚‚, hcâ‚, by simp [div_eq_mul_inv a b, mul_comm]âŸ©","warning:  `Finset.card_le_of_subset` has been deprecated, use `Finset.card_le_card` instead
error:  type mismatch
  a / b
has type
  Î± : outParam (Type u_1)
but is expected to have type
  b âˆˆ u : Prop
error:  application type mismatch
  Exists.intro hb
argument
  hb
has type
  b âˆˆ u : Prop
but is expected to have type
  Î± : Type u_1
error:  simp made no progress
error:  simp made no progress
error:  unsolved goals
case neg.intro.intro.intro.intro
Î± : Type u_1
instâœÂ¹ : DecidableEq Î±
instâœ : CommGroup Î±
s t : Finset Î±
ht : t.Nonempty
this : (u : Set Î±) â†’ Decidable (u.PairwiseDisjoint fun x â†¦ x â€¢ t)
C : Finset (Finset Î±) := filter (fun u â†¦ (â†‘u).PairwiseDisjoint fun x â†¦ x â€¢ t) s.powerset
u : Finset Î±
hu : u âŠ† s âˆ§ (â†‘u).PairwiseDisjoint fun x â†¦ x â€¢ t
hCmax : âˆ€ x âˆˆ C, Â¬u < x
a : Î±
ha : a âˆˆ s
hau : a âˆ‰ u
b : Î±
hb : b âˆˆ u
c : Î±
hcâ‚ : aâ»Â¹ â€¢ c âˆˆ t
hcâ‚‚ : bâ»Â¹ â€¢ c âˆˆ t
âŠ¢ sorryAx Î± true âˆˆ t / t","theorem exists_subset_mul_div (ht : t.Nonempty) :
    âˆƒ u : Finset Î±, u.card * t.card â‰¤ (s * t).card âˆ§ s âŠ† u * t / t ",":= by
  haveI : âˆ€ u, Decidable ((u : Set Î±).PairwiseDisjoint (Â· â€¢ t)) := fun u â†¦ Classical.dec _
  set C := s.powerset.filter fun u â†¦ u.toSet.PairwiseDisjoint (Â· â€¢ t)
  obtain âŸ¨u, hu, hCmaxâŸ© := C.exists_maximal (filter_nonempty_iff.2
    âŸ¨âˆ…, empty_mem_powerset _, by rw [coe_empty]; exact Set.pairwiseDisjoint_emptyâŸ©)
  rw [mem_filter, mem_powerset] at hu
  refine âŸ¨u,
    (card_mul_iff.2 <| pairwiseDisjoint_smul_iff.1 hu.2).ge.trans
      (card_le_card <| mul_subset_mul_right hu.1),
    fun a ha â†¦ ?_âŸ©
  rw [mul_div_assoc]
  by_cases hau : a âˆˆ u
  Â· exact subset_mul_left _ ht.one_mem_div hau
  by_cases H : âˆ€ b âˆˆ u, Disjoint (a â€¢ t) (b â€¢ t)
  Â· refine (hCmax _ ?_ <| ssubset_insert hau).elim
    rw [mem_filter, mem_powerset, insert_subset_iff, coe_insert]
    exact âŸ¨âŸ¨ha, hu.1âŸ©, hu.2.insert fun _ hb _ â†¦ H _ hbâŸ©
  push_neg at H
  simp_rw [not_disjoint_iff, â† inv_smul_mem_iff] at H
  obtain âŸ¨b, hb, c, hcâ‚, hcâ‚‚âŸ© := H
  refine mem_mul.2 âŸ¨b, hb, a / b, ?_, by simpâŸ©
  exact mem_div.2 âŸ¨_, hcâ‚‚, _, hcâ‚, by simp [inv_mul_eq_div]âŸ©","refine âŸ¨exists_subset_mul_div ht, ?_âŸ©"
Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean,Polynomial.exists_partition_polynomial,exists_partition_polynomial,693fd79515903b10b1d31f10dccfc49e633cf7ee,":= by
  have hbÎµ : 0 < cardPowDegree b â€¢ Îµ := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hÎµ
  induction' n with n ih
  Â· refine' âŸ¨finZeroElim, finZeroElimâŸ©
  have anti_archim' : âˆ€ {i j k} {Îµ : â„},
    (cardPowDegree (A i % b - A j % b) : â„) < Îµ â†’
      (cardPowDegree (A j % b - A k % b) : â„) < Îµ â†’
        (cardPowDegree (A i % b - A k % b) : â„) < Îµ := by
    intro i j k Îµ
    simp_rw [â† Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain âŸ¨t', ht'âŸ© := ih (Fin.tail A)
  rsuffices âŸ¨j, hjâŸ© :
    âˆƒ j, âˆ€ i, t' i = j â†” (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· refine' âŸ¨Fin.cons j t', fun iâ‚€ iâ‚ => _âŸ©
    refine' Fin.cases _ (fun iâ‚€ => _) iâ‚€ <;> refine' Fin.cases _ (fun iâ‚ => _) iâ‚
    Â· simpa using hbÎµ
    Â· rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj iâ‚
    Â· rw [Fin.cons_succ, Fin.cons_zero]
      exact hj iâ‚€
    Â· rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' iâ‚€ iâ‚
  obtain âŸ¨j, hjâŸ© : âˆƒ j, âˆ€ i : Fin n,
      t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ := by
    by_contra hg
    push_neg at hg
    obtain âŸ¨jâ‚€, jâ‚, j_ne, approxâŸ© := exists_approx_polynomial hb hÎµ
      (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (hg j))))
    revert j_ne approx
    refine' Fin.cases _ (fun jâ‚€ => _) jâ‚€ <;>
      refine' Fin.cases (fun j_ne approx => _) (fun jâ‚ j_ne approx => _) jâ‚
    Â· exact absurd rfl j_ne
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg jâ‚)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le] at approx
      have := (Classical.choose_spec (hg jâ‚€)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne.def, Fin.succ_inj] at j_ne
      have : jâ‚€ = jâ‚ := (Classical.choose_spec (hg jâ‚€)).1.symm.trans
        (((ht' (Classical.choose (hg jâ‚€)) (Classical.choose (hg jâ‚))).mpr approx).trans
          (Classical.choose_spec (hg jâ‚)).1)
      contradiction
  by_cases exists_nonempty_j : âˆƒ j, (âˆƒ i, t' i = j) âˆ§
      âˆ€ i, t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· obtain âŸ¨j, âŸ¨i, hiâŸ©, hjâŸ© := exists_nonempty_j
    refine' âŸ¨j, fun i' => âŸ¨hj i', fun hi' => _root_.trans ((ht' _ _).mpr _) hiâŸ©âŸ©
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  refine' âŸ¨j, fun i => âŸ¨hj i, fun hi => _âŸ©âŸ©
  have := exists_nonempty_j âŸ¨t' i, âŸ¨i, rflâŸ©, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')âŸ©
  contradiction","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.81178 â†’ ?m.81178 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.81180
case intro.intro.intro.refine'_2.refine'_2
Fq : Type u_1
instâœÂ¹ : Fintype Fq
instâœ : Field Fq
Îµ : â„
hÎµ : 0 < Îµ
b : Fq[X]
hb : b â‰  0
hbÎµ : 0 < cardPowDegree b â€¢ Îµ
n : â„•
ih :
  âˆ€ (A : Fin n â†’ Fq[X]),
    âˆƒ t, âˆ€ (iâ‚€ iâ‚ : Fin n), t iâ‚€ = t iâ‚ â†” â†‘(cardPowDegree (A iâ‚ % b - A iâ‚€ % b)) < cardPowDegree b â€¢ Îµ
A : Fin (n + 1) â†’ Fq[X]
anti_archim' :
  âˆ€ {i j k : Fin (n + 1)} {Îµ : â„},
    â†‘(cardPowDegree (A i % b - A j % b)) < Îµ â†’
      â†‘(cardPowDegree (A j % b - A k % b)) < Îµ â†’ â†‘(cardPowDegree (A i % b - A k % b)) < Îµ
t' : Fin n â†’ Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š)
ht' : âˆ€ (iâ‚€ iâ‚ : Fin n), t' iâ‚€ = t' iâ‚ â†” â†‘(cardPowDegree (Fin.tail A iâ‚ % b - Fin.tail A iâ‚€ % b)) < cardPowDegree b â€¢ Îµ
hg :
  âˆ€ (j : Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š)),
    âˆƒ i, t' i = j âˆ§ cardPowDegree b â€¢ Îµ â‰¤ â†‘(cardPowDegree (A 0 % b - A i.succ % b))
jâ‚€âœ jâ‚âœ : Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š).succ
jâ‚€ jâ‚ : Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š)
j_ne : jâ‚€.succ â‰  jâ‚.succ
approx : â†‘(cardPowDegree (A (Classical.choose â‹¯).succ % b - A (Classical.choose â‹¯).succ % b)) < cardPowDegree b â€¢ Îµ
âŠ¢ False","theorem exists_partition_polynomial_aux (n : â„•) {Îµ : â„} (hÎµ : 0 < Îµ) {b : Fq[X]} (hb : b â‰  0)
    (A : Fin n â†’ Fq[X]) : âˆƒ t : Fin n â†’ Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log (Fintype.card Fq)âŒ‰â‚Š),
      âˆ€ iâ‚€ iâ‚ : Fin n, t iâ‚€ = t iâ‚ â†”
        (cardPowDegree (A iâ‚ % b - A iâ‚€ % b) : â„) < cardPowDegree b â€¢ Îµ ",":= by
  have hbÎµ : 0 < cardPowDegree b â€¢ Îµ := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hÎµ
  induction' n with n ih
  Â· refine âŸ¨finZeroElim, finZeroElimâŸ©
  have anti_archim' : âˆ€ {i j k} {Îµ : â„},
    (cardPowDegree (A i % b - A j % b) : â„) < Îµ â†’
      (cardPowDegree (A j % b - A k % b) : â„) < Îµ â†’
        (cardPowDegree (A i % b - A k % b) : â„) < Îµ := by
    intro i j k Îµ
    simp_rw [â† Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain âŸ¨t', ht'âŸ© := ih (Fin.tail A)
  rsuffices âŸ¨j, hjâŸ© :
    âˆƒ j, âˆ€ i, t' i = j â†” (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· refine âŸ¨Fin.cons j t', fun iâ‚€ iâ‚ => ?_âŸ©
    refine Fin.cases ?_ (fun iâ‚€ => ?_) iâ‚€ <;> refine Fin.cases ?_ (fun iâ‚ => ?_) iâ‚
    Â· simpa using hbÎµ
    Â· rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj iâ‚
    Â· rw [Fin.cons_succ, Fin.cons_zero]
      exact hj iâ‚€
    Â· rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' iâ‚€ iâ‚
  obtain âŸ¨j, hjâŸ© : âˆƒ j, âˆ€ i : Fin n,
      t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ := by
    by_contra! hg
    obtain âŸ¨jâ‚€, jâ‚, j_ne, approxâŸ© := exists_approx_polynomial hb hÎµ
      (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (hg j))))
    revert j_ne approx
    refine Fin.cases ?_ (fun jâ‚€ => ?_) jâ‚€ <;>
      refine Fin.cases (fun j_ne approx => ?_) (fun jâ‚ j_ne approx => ?_) jâ‚
    Â· exact absurd rfl j_ne
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg jâ‚)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le] at approx
      have := (Classical.choose_spec (hg jâ‚€)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne, Fin.succ_inj] at j_ne
      have : jâ‚€ = jâ‚ := (Classical.choose_spec (hg jâ‚€)).1.symm.trans
        (((ht' (Classical.choose (hg jâ‚€)) (Classical.choose (hg jâ‚))).mpr approx).trans
          (Classical.choose_spec (hg jâ‚)).1)
      contradiction
  by_cases exists_nonempty_j : âˆƒ j, (âˆƒ i, t' i = j) âˆ§
      âˆ€ i, t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· obtain âŸ¨j, âŸ¨i, hiâŸ©, hjâŸ© := exists_nonempty_j
    refine âŸ¨j, fun i' => âŸ¨hj i', fun hi' => _root_.trans ((ht' _ _).mpr ?_) hiâŸ©âŸ©
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  refine âŸ¨j, fun i => âŸ¨hj i, fun hi => ?_âŸ©âŸ©
  have := exists_nonempty_j âŸ¨t' i, âŸ¨i, rflâŸ©, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')âŸ©
  contradiction","refine âŸ¨exists_partition_polynomial_polynomial_polynomial_polynomial_polynomial_polynomial_aux,
  exists_partition_polynomial_polynomial_polynomial_polynomial_polynomial_polynomial_polynomial_aux,
  exists_partition_polynomial_polynomial_polynomial_polynomial_auxâŸ©"
Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean,CochainComplex.HomComplex.Î´_shape,Î´_shape,fc5d3dffc7c439022141babb13bcb52a72d9f631,":= by
  ext p q hpq
  dsimp [Î´, Cochain.v, Cochain.mk]
  rw [F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  . rfl
  all_goals
    change Â¬ _=_
    rintro h
    apply hnm
    linarith","error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case h.a
C : Type u
instâœÂ³ : Category.{v, u} C
instâœÂ² : Preadditive C
R : Type u_1
instâœÂ¹ : Ring R
instâœ : Linear R C
F G K L : CochainComplex C â„¤
n m : â„¤
hnm : Â¬n + 1 = m
z : Cochain F G n
p q : â„¤
hpq : p + m = q
âŠ¢ Â¬(ComplexShape.up â„¤).Rel (p + n) q",lemma Î´_shape (hnm : Â¬ n + 1 = m) (z : Cochain F G n) : Î´ n m z = 0 ,":= by
  ext p q hpq
  dsimp only [Î´]
  rw [Cochain.mk_v, Cochain.zero_v, F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  all_goals
    simp only [ComplexShape.up_Rel]
    exact fun _ => hnm (by omega)","simp only [Î´_shape, Î´_shape, Î´_shape, Cochain.map_zero]"
Mathlib/NumberTheory/ClassNumber/Finite.lean,ClassGroup.norm_le,norm_le,6eab74639023015a7887e2f82e153907286e3801,":= by
  conv_lhs => rw [â† bS.sum_repr a]
  rw [Algebra.norm_apply, â† LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, LinearEquiv.map_sum,
    LinearEquiv.map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, â† mul_pow]
  rw [â† LinearMap.det_toMatrix bS]
  convert Matrix.det_sum_smul_le (n := Î¹) Finset.univ _ hy using 3
  Â· simp; rfl
  Â· rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  Â· intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr âŸ¨âŸ¨i, j, kâŸ©, Finset.mem_univ _, rflâŸ©","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearEquiv
has type
  (Ïƒ : ?m.53606 â†’+* ?m.53607) â†’
    {Ïƒ' : ?m.53607 â†’+* ?m.53606} â†’
      [inst : RingHomInvPair Ïƒ Ïƒ'] â†’
        [inst : RingHomInvPair Ïƒ' Ïƒ] â†’
          (M : Type ?u.53603) â†’
            (Mâ‚‚ : Type ?u.53602) â†’
              [inst : AddCommMonoid M] â†’
                [inst_1 : AddCommMonoid Mâ‚‚] â†’
                  [inst : Module ?m.53606 M] â†’ [inst : Module ?m.53607 Mâ‚‚] â†’ Type (max ?u.53603 ?u.53602)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  LinearMap.det ?f
R : Type u_1
S : Type u_2
K : Type u_3
L : Type u_4
instâœÂ¹â´ : EuclideanDomain R
instâœÂ¹Â³ : CommRing S
instâœÂ¹Â² : IsDomain S
instâœÂ¹Â¹ : Field K
instâœÂ¹â° : Field L
instâœâ¹ : Algebra R K
instâœâ¸ : IsFractionRing R K
instâœâ· : Algebra K L
instâœâ¶ : FiniteDimensional K L
instâœâµ : IsSeparable K L
algRL : Algebra R L
instâœâ´ : IsScalarTower R K L
instâœÂ³ : Algebra R S
instâœÂ² : Algebra S L
ist : IsScalarTower R S L
iic : IsIntegralClosure S R L
abv : AbsoluteValue R â„¤
Î¹ : Type u_5
instâœÂ¹ : DecidableEq Î¹
instâœ : Fintype Î¹
bS : Basis Î¹ R S
a : S
y : â„¤
hy : âˆ€ (k : Î¹), abv ((bS.repr a) k) â‰¤ y
âŠ¢ abv ((LinearMap.toMatrix bS bS) (âˆ‘ x : Î¹, (bS.repr a) x â€¢ (Algebra.lmul R S) (bS x))).det â‰¤
    (Fintype.card Î¹).factorial â€¢
      (Fintype.card Î¹ â€¢
          ((Finset.image (fun ijk â†¦ abv ((Algebra.leftMulMatrix bS) (bS ijk.1) ijk.2.1 ijk.2.2)) Finset.univ).max' â‹¯ *
            y)) ^
        Fintype.card Î¹","theorem norm_le (a : S) {y : â„¤} (hy : âˆ€ k, abv (bS.repr a k) â‰¤ y) :
    abv (Algebra.norm R a) â‰¤ normBound abv bS * y ^ Fintype.card Î¹ ",":= by
  conv_lhs => rw [â† bS.sum_repr a]
  rw [Algebra.norm_apply, â† LinearMap.det_toMatrix bS]
  simp only [Algebra.norm_apply, AlgHom.map_sum, AlgHom.map_smul, map_sum,
    map_smul, Algebra.toMatrix_lmul_eq, normBound, smul_mul_assoc, â† mul_pow]
  convert Matrix.det_sum_smul_le Finset.univ _ hy using 3
  Â· rw [Finset.card_univ, smul_mul_assoc, mul_comm]
  Â· intro i j k
    apply Finset.le_max'
    exact Finset.mem_image.mpr âŸ¨âŸ¨i, j, kâŸ©, Finset.mem_univ _, rflâŸ©","rw [normBound, normBound, Algebra.norm]"
Mathlib/LinearAlgebra/TensorProduct/Vanishing.lean,TensorProduct.vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective,vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective,53ef4ce0bcf22cccd58030d7502519c16120d7e5,":= by
  have mem_M' i : m i âˆˆ span R (Set.range m) := subset_span âŸ¨i, rflâŸ©
  set m' : Î¹ â†’ span R (Set.range m) := Subtype.coind m mem_M' with m'_eq
  have hm' : span R (Set.range m') = âŠ¤ := by
    apply map_injective_of_injective (injective_subtype (span R (Set.range m)))
    rw [Submodule.map_span, Submodule.map_top, range_subtype, coeSubtype, â† Set.range_comp]
    rfl
  have hm'n : âˆ‘ i, m' i âŠ—â‚œ n i = (0 : span R (Set.range m) âŠ—[R] N) := by
    apply hm
    simp only [m'_eq, map_sum, rTensor_tmul, coeSubtype, Subtype.coind_coe, _root_.map_zero, hmn]
  have : VanishesTrivially R m' n := vanishesTrivially_of_sum_tmul_eq_zero R m' n hm' hm'n
  unfold VanishesTrivially at this âŠ¢
  convert this with Îº _ a y j
  convert (injective_iff_map_eq_zero' _).mp (injective_subtype (span R (Set.range m))) _
  simp [m'_eq]","error:  application type mismatch
  vanishesTrivially_of_sum_tmul_eq_zero R m'
argument
  m'
has type
  Î¹ â†’ â†¥(span R (Set.range m)) : Type u
but is expected to have type
  span R (Set.range ?m.112160) = âŠ¤ : Prop","theorem vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective
    (hm : Injective (rTensor N (span R (Set.range m)).subtype))
    (hmn : âˆ‘ i, m i âŠ—â‚œ n i = (0 : M âŠ—[R] N)) : VanishesTrivially R m n ",":= by
  have mem_M' i : m i âˆˆ span R (Set.range m) := subset_span âŸ¨i, rflâŸ©
  set m' : Î¹ â†’ span R (Set.range m) := Subtype.coind m mem_M' with m'_eq
  have hm' : span R (Set.range m') = âŠ¤ := by
    apply map_injective_of_injective (injective_subtype (span R (Set.range m)))
    rw [Submodule.map_span, Submodule.map_top, range_subtype, coeSubtype, â† Set.range_comp]
    rfl
  have hm'n : âˆ‘ i, m' i âŠ—â‚œ n i = (0 : span R (Set.range m) âŠ—[R] N) := by
    apply hm
    simp only [m'_eq, map_sum, rTensor_tmul, coeSubtype, Subtype.coind_coe, _root_.map_zero, hmn]
  have : VanishesTrivially R m' n := vanishesTrivially_of_sum_tmul_eq_zero R hm' hm'n
  unfold VanishesTrivially at this âŠ¢
  convert this with Îº _ a y j
  convert (injective_iff_map_eq_zero' _).mp (injective_subtype (span R (Set.range m))) _
  simp [m'_eq]",refine vanishesTrivially_of_vanishesTrivially_of_vanishesTrivially_of_vanishesTrivially_of_vanishesTrivially
Mathlib/Topology/Compactness/Compact.lean,IsCompact.inter_right,IsCompact.inter_right,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  intro f hnf hstf
  obtain âŸ¨x, hsx, hxâŸ© : âˆƒ x âˆˆ s, ClusterPt x f :=
    hs (le_trans hstf (le_principal_iff.2 (inter_subset_left _ _)))
  have : x âˆˆ t := ht.mem_of_nhdsWithin_neBot <|
    hx.mono <| le_trans hstf (le_principal_iff.2 (inter_subset_right _ _))
  exact âŸ¨x, âŸ¨hsx, thisâŸ©, hxâŸ©","error:  function expected at
  inter_subset_left ?m.7086
term has type
  ?m.7085 âˆˆ ?m.7083
error:  function expected at
  inter_subset_right ?m.7325
term has type
  ?m.7324 âˆˆ ?m.7323",theorem IsCompact.inter_right (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s âˆ© t) ,":= by
  intro f hnf hstf
  obtain âŸ¨x, hsx, hxâŸ© : âˆƒ x âˆˆ s, ClusterPt x f :=
    hs (le_trans hstf (le_principal_iff.2 inter_subset_left))
  have : x âˆˆ t := ht.mem_of_nhdsWithin_neBot <|
    hx.mono <| le_trans hstf (le_principal_iff.2 inter_subset_right)
  exact âŸ¨x, âŸ¨hsx, thisâŸ©, hxâŸ©",have : IsCompact (s âˆ© t) := IsCompact.isCompact_inter_right hs ht
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.measure_le_mul_of_subset_limRatioMeas_lt,measure_le_mul_of_subset_limRatioMeas_lt,2c23e43ba179a9dd2928e06c32f043d20e9798c8,":= by
  let t := {x : Î± | Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ (v.limRatioMeas hÏ x))}
  have A : Î¼ (tá¶œ) = 0 := v.ae_tendsto_limRatioMeas hÏ
  suffices H : Ï (s âˆ© t) â‰¤ (p â€¢ Î¼) (s âˆ© t);
  exact
    calc
      Ï s = Ï (s âˆ© t âˆª s âˆ© tá¶œ) := by rw [inter_union_compl]
      _ â‰¤ Ï (s âˆ© t) + Ï (s âˆ© tá¶œ) := (measure_union_le _ _)
      _ â‰¤ p * Î¼ (s âˆ© t) + 0 :=
        (add_le_add H ((measure_mono (inter_subset_right _ _)).trans (hÏ A).le))
      _ â‰¤ p * Î¼ s := by
        rw [add_zero]; exact mul_le_mul_left' (measure_mono (inter_subset_left _ _)) _
  refine' v.measure_le_of_frequently_le (p â€¢ Î¼) hÏ _ fun x hx => _
  have I : âˆ€á¶  b : Set Î± in v.filterAt x, Ï b / Î¼ b < p := (tendsto_order.1 hx.2).2 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  refine' (ENNReal.div_le_iff_le_mul _ (Or.inr (bot_le.trans_lt ha).ne')).1 ha.le
  simp only [ENNReal.coe_ne_top, Ne.def, or_true_iff, not_false_iff]",error:  unexpected token ';'; expected 'by' or 'from',"theorem measure_le_mul_of_subset_limRatioMeas_lt {p : â„â‰¥0} {s : Set Î±}
    (h : s âŠ† {x | v.limRatioMeas hÏ x < p}) : Ï s â‰¤ p * Î¼ s ",":= by
  let t := {x : Î± | Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ (v.limRatioMeas hÏ x))}
  have A : Î¼ tá¶œ = 0 := v.ae_tendsto_limRatioMeas hÏ
  suffices H : Ï (s âˆ© t) â‰¤ (p â€¢ Î¼) (s âˆ© t) by calc
    Ï s = Ï (s âˆ© t âˆª s âˆ© tá¶œ) := by rw [inter_union_compl]
    _ â‰¤ Ï (s âˆ© t) + Ï (s âˆ© tá¶œ) := measure_union_le _ _
    _ â‰¤ (p â€¢ Î¼) (s âˆ© t) + Ï tá¶œ := by gcongr; apply inter_subset_right
    _ â‰¤ p * Î¼ (s âˆ© t) := by simp [(hÏ A)]
    _ â‰¤ p * Î¼ s := by gcongr; apply inter_subset_left
  refine v.measure_le_of_frequently_le (p â€¢ Î¼) hÏ _ fun x hx => ?_
  have I : âˆ€á¶  b : Set Î± in v.filterAt x, Ï b / Î¼ b < p := (tendsto_order.1 hx.2).2 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  refine (ENNReal.div_le_iff_le_mul ?_ (Or.inr (bot_le.trans_lt ha).ne')).1 ha.le
  simp only [ENNReal.coe_ne_top, Ne, or_true_iff, not_false_iff]",refine le_trans (measure_le_mul_of_subset_limRatioMeas_lt s) ?_
Mathlib/NumberTheory/Liouville/Measure.lean,volume_iUnion_setOf_liouvilleWith,volume_iUnion_setOf_liouvilleWith,ff33d25c791a3fac407c782b49018fcb63700d0d,":= by
  simp only [â† setOf_exists, exists_prop]
  refine' measure_mono_null setOf_liouvilleWith_subset_aux _
  rw [measure_iUnion_null_iff]; intro m; rw [measure_preimage_add_right]; clear m
  refine' (measure_biUnion_null_iff <| to_countable _).2 fun n (hn : 1 â‰¤ n) => _
  generalize hr : (2 + 1 / n : â„) = r
  replace hr : 2 < r; Â· simp [â† hr, zero_lt_one.trans_le hn]
  clear hn n
  refine' measure_setOf_frequently_eq_zero _
  simp only [setOf_exists, â† exists_prop, â† Real.dist_eq, â† mem_ball, setOf_mem_eq]
  set B : â„¤ â†’ â„• â†’ Set â„ := fun a b => ball (a / b) (1 / (b : â„) ^ r)
  have hB : âˆ€ a b, volume (B a b) = â†‘((2 : â„â‰¥0) / (b : â„â‰¥0) ^ r) := fun a b â†¦ by
    rw [Real.volume_ball, mul_one_div, â† NNReal.coe_two, â† NNReal.coe_nat_cast, â† NNReal.coe_rpow,
      â† NNReal.coe_div, ENNReal.ofReal_coe_nnreal]
  have : âˆ€ b : â„•, volume (â‹ƒ a âˆˆ Finset.Icc (0 : â„¤) b, B a b) â‰¤
      â†‘(2 * ((b : â„â‰¥0) ^ (1 - r) + (b : â„â‰¥0) ^ (-r))) := fun b â†¦
    calc
      volume (â‹ƒ a âˆˆ Finset.Icc (0 : â„¤) b, B a b) â‰¤ âˆ‘ a in Finset.Icc (0 : â„¤) b, volume (B a b) :=
        measure_biUnion_finset_le _ _
      _ = â†‘((b + 1) * (2 / (b : â„â‰¥0) ^ r)) := by
        simp only [hB, Int.card_Icc, Finset.sum_const, nsmul_eq_mul, sub_zero, â† Int.ofNat_succ,
          Int.toNat_coe_nat, â† Nat.cast_succ, ENNReal.coe_mul, ENNReal.coe_nat]
      _ = _ := by
        have : 1 - r â‰  0 := by linarith
        rw [ENNReal.coe_inj]
        simp [add_mul, div_eq_mul_inv, NNReal.rpow_neg, NNReal.rpow_sub' _ this, mul_add,
          mul_left_comm]
  refine' ne_top_of_le_ne_top (ENNReal.tsum_coe_ne_top_iff_summable.2 _) (ENNReal.tsum_le_tsum this)
  refine' (Summable.add _ _).mul_left _ <;> simp only [NNReal.summable_rpow] <;> linarith","error:  unexpected token ';'; expected '|'
error:  unsolved goals
n : â„•
hn : 1 â‰¤ n
r : â„
hr : 2 < r
âŠ¢ volume {x | âˆƒá¶  (b : â„•) in atTop, âˆƒ a âˆˆ Finset.Icc 0 â†‘b, |x - â†‘a / â†‘b| < 1 / â†‘b ^ r} = 0","theorem volume_iUnion_setOf_liouvilleWith :
    volume (â‹ƒ (p : â„) (_hp : 2 < p), { x : â„ | LiouvilleWith p x }) = 0 ",":= by
  simp only [â† setOf_exists, exists_prop]
  refine measure_mono_null setOf_liouvilleWith_subset_aux ?_
  rw [measure_iUnion_null_iff]; intro m; rw [measure_preimage_add_right]; clear m
  refine (measure_biUnion_null_iff <| to_countable _).2 fun n (hn : 1 â‰¤ n) => ?_
  generalize hr : (2 + 1 / n : â„) = r
  replace hr : 2 < r := by simp [â† hr, zero_lt_one.trans_le hn]
  clear hn n
  refine measure_setOf_frequently_eq_zero ?_
  simp only [setOf_exists, â† exists_prop, â† Real.dist_eq, â† mem_ball, setOf_mem_eq]
  set B : â„¤ â†’ â„• â†’ Set â„ := fun a b => ball (a / b) (1 / (b : â„) ^ r)
  have hB : âˆ€ a b, volume (B a b) = â†‘((2 : â„â‰¥0) / (b : â„â‰¥0) ^ r) := fun a b â†¦ by
    rw [Real.volume_ball, mul_one_div, â† NNReal.coe_two, â† NNReal.coe_natCast, â† NNReal.coe_rpow,
      â† NNReal.coe_div, ENNReal.ofReal_coe_nnreal]
  have : âˆ€ b : â„•, volume (â‹ƒ a âˆˆ Finset.Icc (0 : â„¤) b, B a b) â‰¤
      â†‘(2 * ((b : â„â‰¥0) ^ (1 - r) + (b : â„â‰¥0) ^ (-r))) := fun b â†¦
    calc
      volume (â‹ƒ a âˆˆ Finset.Icc (0 : â„¤) b, B a b) â‰¤ âˆ‘ a âˆˆ Finset.Icc (0 : â„¤) b, volume (B a b) :=
        measure_biUnion_finset_le _ _
      _ = â†‘((b + 1) * (2 / (b : â„â‰¥0) ^ r)) := by
        simp only [hB, Int.card_Icc, Finset.sum_const, nsmul_eq_mul, sub_zero, â† Int.ofNat_succ,
          Int.toNat_natCast, â† Nat.cast_succ, ENNReal.coe_mul, ENNReal.coe_natCast]
      _ = _ := by
        have : 1 - r â‰  0 := by linarith
        rw [ENNReal.coe_inj]
        simp [add_mul, div_eq_mul_inv, NNReal.rpow_neg, NNReal.rpow_sub' _ this, mul_add,
          mul_left_comm]
  refine ne_top_of_le_ne_top (ENNReal.tsum_coe_ne_top_iff_summable.2 ?_) (ENNReal.tsum_le_tsum this)
  refine (Summable.add ?_ ?_).mul_left _ <;> simp only [NNReal.summable_rpow] <;> linarith",rw [volume_iUnion_setOf_liouvilleWith]
Mathlib/FieldTheory/PurelyInseparable.lean,Polynomial.Separable.map_irreducible_of_isPurelyInseparable,Polynomial.Separable.map_irreducible_of_isPurelyInseparable,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  let K := AlgebraicClosure E
  obtain âŸ¨x, hxâŸ© := IsAlgClosed.exists_aeval_eq_zero K f
    (natDegree_pos_iff_degree_pos.1 hirr.natDegree_pos).ne'
  have ha : Associated f (minpoly F x) := by
    have := isUnit_C.2 (leadingCoeff_ne_zero.2 hirr.ne_zero).isUnit.inv
    exact âŸ¨this.unit, by rw [IsUnit.unit_spec, minpoly.eq_of_irreducible hirr hx]âŸ©
  have ha' : Associated (f.map (algebraMap F E)) ((minpoly F x).map (algebraMap F E)) :=
    ha.map (mapRingHom (algebraMap F E)).toMonoidHom
  have heq := minpoly.map_eq_of_separable_of_isPurelyInseparable E x (ha.separable hsep)
  rw [ha'.irreducible_iff, heq]
  exact minpoly.irreducible (AlgebraicClosure.isAlgebraic E x).isIntegral","warning:  unused variable `hn`
note: this linter can be disabled with `set_option linter.unusedVariables false`
warning:  unused variable `h`
note: this linter can be disabled with `set_option linter.unusedVariables false`
error:  function expected at
  AlgebraicClosure.isAlgebraic E
term has type
  Algebra.IsAlgebraic E (AlgebraicClosure E)","theorem Polynomial.Separable.map_irreducible_of_isPurelyInseparable {f : F[X]} (hsep : f.Separable)
    (hirr : Irreducible f) [IsPurelyInseparable F E] : Irreducible (f.map (algebraMap F E)) ",":= by
  let K := AlgebraicClosure E
  obtain âŸ¨x, hxâŸ© := IsAlgClosed.exists_aeval_eq_zero K f
    (natDegree_pos_iff_degree_pos.1 hirr.natDegree_pos).ne'
  have ha : Associated f (minpoly F x) := by
    have := isUnit_C.2 (leadingCoeff_ne_zero.2 hirr.ne_zero).isUnit.inv
    exact âŸ¨this.unit, by rw [IsUnit.unit_spec, minpoly.eq_of_irreducible hirr hx]âŸ©
  have ha' : Associated (f.map (algebraMap F E)) ((minpoly F x).map (algebraMap F E)) :=
    ha.map (mapRingHom (algebraMap F E)).toMonoidHom
  have heq := minpoly.map_eq_of_separable_of_isPurelyInseparable E x (ha.separable hsep)
  rw [ha'.irreducible_iff, heq]
  exact minpoly.irreducible (Algebra.IsIntegral.isIntegral x)","have hirr' : Irreducible (f.map (algebraMap F E)) :=
  Irreducible.map_irreducible_map_irreducible_map_irreducible_map_irreducible_map"
Mathlib/Data/Nat/Choose/Central.lean,Nat.four_pow_le_two_mul_self_mul_centralBinom,four_pow_le_two_mul_self_mul_centralBinom,9f6d33884de569540c527b667d1573e1b97e1347,"  | 0, pr => (Nat.not_lt_zero _ pr).elim
  | 1, _ => by norm_num [centralBinom, choose]
  | 2, _ => by norm_num [centralBinom, choose]
  | 3, _ => by norm_num [centralBinom, choose]
  | n + 4, _ =>
    calc
      4 ^ (n+4) â‰¤ (n+4) * centralBinom (n+4) := (four_pow_lt_mul_centralBinom _ le_add_self).le
      _ â‰¤ 2 * (n+4) * centralBinom (n+4) := by
        rw [mul_assoc]; refine' le_mul_of_pos_left zero_lt_two",error:  unknown identifier 'le_mul_of_pos_left',"theorem four_pow_le_two_mul_self_mul_centralBinom :
    âˆ€ (n : â„•) (_ : 0 < n), 4 ^ n â‰¤ 2 * n * centralBinom n
","  | 0, pr => (Nat.not_lt_zero _ pr).elim
  | 1, _ => by norm_num [centralBinom, choose]
  | 2, _ => by norm_num [centralBinom, choose]
  | 3, _ => by norm_num [centralBinom, choose]
  | n + 4, _ =>
    calc
      4 ^ (n+4) â‰¤ (n+4) * centralBinom (n+4) := (four_pow_lt_mul_centralBinom _ le_add_self).le
      _ â‰¤ 2 * (n+4) * centralBinom (n+4) := by
        rw [mul_assoc]; refine Nat.le_mul_of_pos_left _ zero_lt_two",apply theorem_four_pow_le_two_mul_self_mul_centralBinom
Mathlib/SetTheory/Cardinal/Basic.lean,Cardinal.aleph0_le,aleph0_le,f8dea2620ed854ca48ed31434fd52cc5ab2b6542,":= by
  rw [â† lift_aleph0.{u,v}, lift_le]","warning:  mk does not have a doc string
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Cardinal.power_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  aleph0 does not have a doc string
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  lift.{?u.91762, ?u.91761} ?m.91763 â‰¤ lift.{?u.91762, ?u.91761} ?m.91764
Î± Î² : Type u
c : Cardinal.{u}
âŠ¢ lift.{u, v} â„µâ‚€ â‰¤ lift.{v, u} c â†” â„µâ‚€ â‰¤ c
warning:  powerlt does not have a doc string",theorem aleph0_le_lift {c : Cardinal.{u}} : â„µâ‚€ â‰¤ lift.{v} c â†” â„µâ‚€ â‰¤ c ,":= by
  rw [â† lift_aleph0.{v, u}, lift_le]","rw [â† lift_aleph0_le_lift, lift_lift]"
Mathlib/SetTheory/Cardinal/Basic.lean,Cardinal.lift_le_aleph0,lift_le_aleph0,f8dea2620ed854ca48ed31434fd52cc5ab2b6542,":= by
  rw [â† lift_aleph0.{u,v}, lift_le]","warning:  mk does not have a doc string
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Cardinal.power_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  aleph0 does not have a doc string
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  lift.{?u.91864, ?u.91863} ?m.91865 â‰¤ lift.{?u.91864, ?u.91863} ?m.91866
Î± Î² : Type u
c : Cardinal.{u}
âŠ¢ lift.{v, u} c â‰¤ lift.{u, v} â„µâ‚€ â†” c â‰¤ â„µâ‚€
warning:  powerlt does not have a doc string",theorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c â‰¤ â„µâ‚€ â†” c â‰¤ â„µâ‚€ ,":= by
  rw [â† lift_aleph0.{v, u}, lift_le]","rw [â† lift_le_aleph0, lift_le_aleph0]"
Mathlib/Analysis/Analytic/Uniqueness.lean,AnalyticOn.eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux,eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux,4a37a8e778eb3014aeb05af1b09f6de104536d53,":= by
  let u := {x | f =á¶ [ğ“ x] 0}
  suffices main : closure u âˆ© U âŠ† u
  Â· have Uu : U âŠ† u :=
      hU.subset_of_closure_inter_subset isOpen_setOf_eventually_nhds âŸ¨zâ‚€, hâ‚€, hfzâ‚€âŸ© main
    intro z hz
    simpa using mem_of_mem_nhds (Uu hz)
  rintro x âŸ¨xu, xUâŸ©
  rcases hf x xU with âŸ¨p, r, hpâŸ©
  obtain âŸ¨y, yu, hxyâŸ© : âˆƒ y âˆˆ u, edist x y < r / 2
  exact EMetric.mem_closure_iff.1 xu (r / 2) (ENNReal.half_pos hp.r_pos.ne')
  let q := p.changeOrigin (y - x)
  have has_series : HasFPowerSeriesOnBall f q y (r / 2) := by
    have A : (â€–y - xâ€–â‚Š : â„â‰¥0âˆ) < r / 2 := by rwa [edist_comm, edist_eq_coe_nnnorm_sub] at hxy
    have := hp.changeOrigin (A.trans_le ENNReal.half_le_self)
    simp only [add_sub_cancel'_right] at this
    apply this.mono (ENNReal.half_pos hp.r_pos.ne')
    apply ENNReal.le_sub_of_add_le_left ENNReal.coe_ne_top
    apply (add_le_add A.le (le_refl (r / 2))).trans (le_of_eq _)
    exact ENNReal.add_halves _
  have M : EMetric.ball y (r / 2) âˆˆ ğ“ x := EMetric.isOpen_ball.mem_nhds hxy
  filter_upwards [M] with z hz
  have A : HasSum (fun n : â„• => q n fun _ : Fin n => z - y) (f z) := has_series.hasSum_sub hz
  have B : HasSum (fun n : â„• => q n fun _ : Fin n => z - y) 0 := by
    have : HasFPowerSeriesAt 0 q y := has_series.hasFPowerSeriesAt.congr yu
    convert hasSum_zero (Î± := F) using 2
    ext n
    exact this.apply_eq_zero n _
  exact HasSum.unique A B",error:  unexpected token 'Â·'; expected 'by' or 'from',"theorem eqOn_zero_of_preconnected_of_eventuallyEq_zero_aux [CompleteSpace F] {f : E â†’ F} {U : Set E}
    (hf : AnalyticOn ğ•œ f U) (hU : IsPreconnected U) {zâ‚€ : E} (hâ‚€ : zâ‚€ âˆˆ U) (hfzâ‚€ : f =á¶ [ğ“ zâ‚€] 0) :
    EqOn f 0 U ",":= by
  let u := {x | f =á¶ [ğ“ x] 0}
  suffices main : closure u âˆ© U âŠ† u by
    have Uu : U âŠ† u :=
      hU.subset_of_closure_inter_subset isOpen_setOf_eventually_nhds âŸ¨zâ‚€, hâ‚€, hfzâ‚€âŸ© main
    intro z hz
    simpa using mem_of_mem_nhds (Uu hz)
  rintro x âŸ¨xu, xUâŸ©
  rcases hf x xU with âŸ¨p, r, hpâŸ©
  obtain âŸ¨y, yu, hxyâŸ© : âˆƒ y âˆˆ u, edist x y < r / 2 :=
    EMetric.mem_closure_iff.1 xu (r / 2) (ENNReal.half_pos hp.r_pos.ne')
  let q := p.changeOrigin (y - x)
  have has_series : HasFPowerSeriesOnBall f q y (r / 2) := by
    have A : (â€–y - xâ€–â‚Š : â„â‰¥0âˆ) < r / 2 := by rwa [edist_comm, edist_eq_coe_nnnorm_sub] at hxy
    have := hp.changeOrigin (A.trans_le ENNReal.half_le_self)
    simp only [add_sub_cancel] at this
    apply this.mono (ENNReal.half_pos hp.r_pos.ne')
    apply ENNReal.le_sub_of_add_le_left ENNReal.coe_ne_top
    apply (add_le_add A.le (le_refl (r / 2))).trans (le_of_eq _)
    exact ENNReal.add_halves _
  have M : EMetric.ball y (r / 2) âˆˆ ğ“ x := EMetric.isOpen_ball.mem_nhds hxy
  filter_upwards [M] with z hz
  have A : HasSum (fun n : â„• => q n fun _ : Fin n => z - y) (f z) := has_series.hasSum_sub hz
  have B : HasSum (fun n : â„• => q n fun _ : Fin n => z - y) 0 := by
    have : HasFPowerSeriesAt 0 q y := has_series.hasFPowerSeriesAt.congr yu
    convert hasSum_zero (Î± := F) using 2
    ext n
    exact this.apply_eq_zero n _
  exact HasSum.unique A B","simp only [EventuallyEq, eventuallyEq_zero_iff] at hfz"
Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean,MvPolynomial.weightedHomogeneousComponent_zero,weightedHomogeneousComponent_zero,c04b29dd6b022753894b2fc21d2d4951e76e339e,":= by
  ext1 d
  rcases Classical.em (d = 0) with (rfl | hd)
  Â· simp only [coeff_weightedHomogeneousComponent, if_pos, map_zero, coeff_zero_C]
  Â· rw [coeff_weightedHomogeneousComponent, if_neg, coeff_C, if_neg (Ne.symm hd)]
    simp only [weightedDegree', LinearMap.toAddMonoidHom_coe, Finsupp.total_apply, Finsupp.sum,
      sum_eq_zero_iff, Finsupp.mem_support_iff, Ne.def, smul_eq_zero, not_forall, not_or,
      and_self_left, exists_prop]
    simp only [FunLike.ext_iff, Finsupp.coe_zero, Pi.zero_apply, not_forall] at hd
    obtain âŸ¨i, hiâŸ© := hd
    exact âŸ¨i, hi, hw iâŸ©","error:  unsolved goals
case a.inl
R : Type u_1
M : Type u_2
instâœÂ² : CommSemiring R
Ïƒ : Type u_3
instâœÂ¹ : CanonicallyOrderedAddCommMonoid M
w : Ïƒ â†’ M
Ï† : MvPolynomial Ïƒ R
instâœ : NoZeroSMulDivisors â„• M
hw : âˆ€ (i : Ïƒ), w i â‰  0
âŠ¢ coeff 0 ((weightedHomogeneousComponent w 0) Ï†) = coeff 0 Ï†
error:  failed to synthesize
  DecidableEq M
use `set_option diagnostics true` to get diagnostic information","theorem weightedHomogeneousComponent_zero [NoZeroSMulDivisors â„• M] (hw : âˆ€ i : Ïƒ, w i â‰  0) :
    weightedHomogeneousComponent w 0 Ï† = C (coeff 0 Ï†) ",":= by
  classical
  ext1 d
  rcases Classical.em (d = 0) with (rfl | hd)
  Â· simp only [coeff_weightedHomogeneousComponent, if_pos, map_zero, coeff_zero_C]
  Â· rw [coeff_weightedHomogeneousComponent, if_neg, coeff_C, if_neg (Ne.symm hd)]
    simp only [weightedDegree, LinearMap.toAddMonoidHom_coe, Finsupp.total_apply, Finsupp.sum,
      sum_eq_zero_iff, Finsupp.mem_support_iff, Ne, smul_eq_zero, not_forall, not_or,
      and_self_left, exists_prop]
    simp only [DFunLike.ext_iff, Finsupp.coe_zero, Pi.zero_apply, not_forall] at hd
    obtain âŸ¨i, hiâŸ© := hd
    exact âŸ¨i, hi, hw iâŸ©",simp [weightedHomogeneousComponent_zero]
Mathlib/Geometry/Manifold/ContMDiff/Basic.lean,ContMDiffWithinAt.comp,ContMDiffWithinAt.comp,7ed7ed5693428ce8707e770581caaf86da193e99,":= by
  rw [contMDiffWithinAt_iff] at hg hf âŠ¢
  refine' âŸ¨hg.1.comp hf.1 st, _âŸ©
  set e := extChartAt I x
  set e' := extChartAt I' (f x)
  have : e' (f x) = (writtenInExtChartAt I I' x f) (e x) := by simp only [mfld_simps]
  rw [this] at hg
  have A : âˆ€á¶  y in ğ“[e.symm â»Â¹' s âˆ© range I] e x, f (e.symm y) âˆˆ t âˆ§ f (e.symm y) âˆˆ e'.source := by
    simp only [â† map_extChartAt_nhdsWithin, eventually_map]
    filter_upwards [hf.1.tendsto (extChartAt_source_mem_nhds I' (f x)),
      inter_mem_nhdsWithin s (extChartAt_source_mem_nhds I x)]
    rintro x' (hfx' : f x' âˆˆ e'.source) âŸ¨hx's, hx'âŸ©
    simp only [e.map_source hx', true_and_iff, e.left_inv hx', st hx's, *]
  refine' ((hg.2.comp _ (hf.2.mono (inter_subset_right _ _)) (inter_subset_left _ _)).mono_of_mem
    (inter_mem _ self_mem_nhdsWithin)).congr_of_eventuallyEq _ _
  Â· filter_upwards [A]
    rintro x' âŸ¨ht, hfx'âŸ©
    simp only [*, mem_preimage, writtenInExtChartAt, (Â· âˆ˜ Â·), mem_inter_iff, e'.left_inv,
      true_and_iff]
    exact mem_range_self _
  Â· filter_upwards [A]
    rintro x' âŸ¨-, hfx'âŸ©
    simp only [*, (Â· âˆ˜ Â·), writtenInExtChartAt, e'.left_inv]
  Â· simp only [writtenInExtChartAt, (Â· âˆ˜ Â·), mem_extChartAt_source, e.left_inv, e'.left_inv]","error:  unsolved goals
ğ•œ : Type u_1
instâœÂ¹â· : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ¹â¶ : NormedAddCommGroup E
instâœÂ¹âµ : NormedSpace ğ•œ E
H : Type u_3
instâœÂ¹â´ : TopologicalSpace H
I : ModelWithCorners ğ•œ E H
M : Type u_4
instâœÂ¹Â³ : TopologicalSpace M
instâœÂ¹Â² : ChartedSpace H M
instâœÂ¹Â¹ : SmoothManifoldWithCorners I M
E' : Type u_5
instâœÂ¹â° : NormedAddCommGroup E'
instâœâ¹ : NormedSpace ğ•œ E'
H' : Type u_6
instâœâ¸ : TopologicalSpace H'
I' : ModelWithCorners ğ•œ E' H'
M' : Type u_7
instâœâ· : TopologicalSpace M'
instâœâ¶ : ChartedSpace H' M'
instâœâµ : SmoothManifoldWithCorners I' M'
E'' : Type u_8
instâœâ´ : NormedAddCommGroup E''
instâœÂ³ : NormedSpace ğ•œ E''
H'' : Type u_9
instâœÂ² : TopologicalSpace H''
I'' : ModelWithCorners ğ•œ E'' H''
M'' : Type u_10
instâœÂ¹ : TopologicalSpace M''
instâœ : ChartedSpace H'' M''
eâœ : PartialHomeomorph M H
e'âœ : PartialHomeomorph M' H'
f fâ‚ : M â†’ M'
s sâ‚ tâœ : Set M
xâœ : M
m n : â„•âˆ
t : Set M'
g : M' â†’ M''
x : M
st : MapsTo f s t
e : PartialEquiv M E := extChartAt I x
e' : PartialEquiv M' E' := extChartAt I' (f x)
hg :
  ContinuousWithinAt g t (f x) âˆ§
    ContDiffWithinAt ğ•œ n (â†‘(extChartAt I'' (g (f x))) âˆ˜ g âˆ˜ â†‘e'.symm) (â†‘e'.symm â»Â¹' t âˆ© range â†‘I') (â†‘e' (f x))
hf : ContinuousWithinAt f s x âˆ§ ContDiffWithinAt ğ•œ n (â†‘e' âˆ˜ f âˆ˜ â†‘e.symm) (â†‘e.symm â»Â¹' s âˆ© range â†‘I) (â†‘e x)
âŠ¢ â†‘e' (f x) = â†‘I' (â†‘(chartAt H' (f x)) (f (â†‘(chartAt H x).symm (â†‘I.symm (â†‘e x)))))
error:  simp made no progress
error:  function expected at
  inter_subset_right ?m.9100
term has type
  ?m.9099 âˆˆ ?m.9098
error:  function expected at
  inter_subset_left ?m.9146
term has type
  ?m.9145 âˆˆ ?m.9143
error:  type mismatch
  mp_mem A ?m.9502
has type
  ?m.9508 âˆˆ ğ“[â†‘e.symm â»Â¹' s âˆ© range â†‘I] â†‘e x : Prop
but is expected to have type
  Set E : Type u_2
error:  simp made no progress
error:  simp made no progress
error:  unsolved goals
case refine'_3
ğ•œ : Type u_1
instâœÂ¹â· : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ¹â¶ : NormedAddCommGroup E
instâœÂ¹âµ : NormedSpace ğ•œ E
H : Type u_3
instâœÂ¹â´ : TopologicalSpace H
I : ModelWithCorners ğ•œ E H
M : Type u_4
instâœÂ¹Â³ : TopologicalSpace M
instâœÂ¹Â² : ChartedSpace H M
instâœÂ¹Â¹ : SmoothManifoldWithCorners I M
E' : Type u_5
instâœÂ¹â° : NormedAddCommGroup E'
instâœâ¹ : NormedSpace ğ•œ E'
H' : Type u_6
instâœâ¸ : TopologicalSpace H'
I' : ModelWithCorners ğ•œ E' H'
M' : Type u_7
instâœâ· : TopologicalSpace M'
instâœâ¶ : ChartedSpace H' M'
instâœâµ : SmoothManifoldWithCorners I' M'
E'' : Type u_8
instâœâ´ : NormedAddCommGroup E''
instâœÂ³ : NormedSpace ğ•œ E''
H'' : Type u_9
instâœÂ² : TopologicalSpace H''
I'' : ModelWithCorners ğ•œ E'' H''
M'' : Type u_10
instâœÂ¹ : TopologicalSpace M''
instâœ : ChartedSpace H'' M''
eâœ : PartialHomeomorph M H
e'âœ : PartialHomeomorph M' H'
f fâ‚ : M â†’ M'
s sâ‚ tâœ : Set M
xâœ : M
m n : â„•âˆ
t : Set M'
g : M' â†’ M''
x : M
st : MapsTo f s t
e : PartialEquiv M E := extChartAt I x
e' : PartialEquiv M' E' := extChartAt I' (f x)
hg :
  ContinuousWithinAt g t (f x) âˆ§
    ContDiffWithinAt ğ•œ n (â†‘(extChartAt I'' (g (f x))) âˆ˜ g âˆ˜ â†‘e'.symm) (â†‘e'.symm â»Â¹' t âˆ© range â†‘I')
      (writtenInExtChartAt I I' x f (â†‘e x))
hf : ContinuousWithinAt f s x âˆ§ ContDiffWithinAt ğ•œ n (â†‘e' âˆ˜ f âˆ˜ â†‘e.symm) (â†‘e.symm â»Â¹' s âˆ© range â†‘I) (â†‘e x)
this : â†‘e' (f x) = writtenInExtChartAt I I' x f (â†‘e x)
A : âˆ€á¶  (y : E) in ğ“[â†‘e.symm â»Â¹' s âˆ© range â†‘I] â†‘e x, f (â†‘e.symm y) âˆˆ t âˆ§ f (â†‘e.symm y) âˆˆ e'.source
âŠ¢ (fun x_1 â†¦ â†‘(extChartAt I'' (g (f x))) (g (f (â†‘e.symm x_1)))) =á¶ [ğ“[â†‘e.symm â»Â¹' s âˆ© range â†‘I] â†‘e x] fun x_1 â†¦
    â†‘(extChartAt I'' (g (f x))) (g (â†‘e'.symm (â†‘(extChartAt I' (f x)) (f (â†‘(extChartAt I x).symm x_1)))))
error:  unsolved goals
case refine'_4
ğ•œ : Type u_1
instâœÂ¹â· : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ¹â¶ : NormedAddCommGroup E
instâœÂ¹âµ : NormedSpace ğ•œ E
H : Type u_3
instâœÂ¹â´ : TopologicalSpace H
I : ModelWithCorners ğ•œ E H
M : Type u_4
instâœÂ¹Â³ : TopologicalSpace M
instâœÂ¹Â² : ChartedSpace H M
instâœÂ¹Â¹ : SmoothManifoldWithCorners I M
E' : Type u_5
instâœÂ¹â° : NormedAddCommGroup E'
instâœâ¹ : NormedSpace ğ•œ E'
H' : Type u_6
instâœâ¸ : TopologicalSpace H'
I' : ModelWithCorners ğ•œ E' H'
M' : Type u_7
instâœâ· : TopologicalSpace M'
instâœâ¶ : ChartedSpace H' M'
instâœâµ : SmoothManifoldWithCorners I' M'
E'' : Type u_8
instâœâ´ : NormedAddCommGroup E''
instâœÂ³ : NormedSpace ğ•œ E''
H'' : Type u_9
instâœÂ² : TopologicalSpace H''
I'' : ModelWithCorners ğ•œ E'' H''
M'' : Type u_10
instâœÂ¹ : TopologicalSpace M''
instâœ : ChartedSpace H'' M''
eâœ : PartialHomeomorph M H
e'âœ : PartialHomeomorph M' H'
f fâ‚ : M â†’ M'
s sâ‚ tâœ : Set M
xâœ : M
m n : â„•âˆ
t : Set M'
g : M' â†’ M''
x : M
st : MapsTo f s t
e : PartialEquiv M E := extChartAt I x
e' : PartialEquiv M' E' := extChartAt I' (f x)
hg :
  ContinuousWithinAt g t (f x) âˆ§
    ContDiffWithinAt ğ•œ n (â†‘(extChartAt I'' (g (f x))) âˆ˜ g âˆ˜ â†‘e'.symm) (â†‘e'.symm â»Â¹' t âˆ© range â†‘I')
      (writtenInExtChartAt I I' x f (â†‘e x))
hf : ContinuousWithinAt f s x âˆ§ ContDiffWithinAt ğ•œ n (â†‘e' âˆ˜ f âˆ˜ â†‘e.symm) (â†‘e.symm â»Â¹' s âˆ© range â†‘I) (â†‘e x)
this : â†‘e' (f x) = writtenInExtChartAt I I' x f (â†‘e x)
A : âˆ€á¶  (y : E) in ğ“[â†‘e.symm â»Â¹' s âˆ© range â†‘I] â†‘e x, f (â†‘e.symm y) âˆˆ t âˆ§ f (â†‘e.symm y) âˆˆ e'.source
âŠ¢ (â†‘(extChartAt I'' ((g âˆ˜ f) x)) âˆ˜ (g âˆ˜ f) âˆ˜ â†‘e.symm) (â†‘e x) =
    ((â†‘(extChartAt I'' (g (f x))) âˆ˜ g âˆ˜ â†‘e'.symm) âˆ˜ writtenInExtChartAt I I' x f) (â†‘e x)","theorem ContMDiffWithinAt.comp {t : Set M'} {g : M' â†’ M''} (x : M)
    (hg : ContMDiffWithinAt I' I'' n g t (f x)) (hf : ContMDiffWithinAt I I' n f s x)
    (st : MapsTo f s t) : ContMDiffWithinAt I I'' n (g âˆ˜ f) s x ",":= by
  rw [contMDiffWithinAt_iff] at hg hf âŠ¢
  refine âŸ¨hg.1.comp hf.1 st, ?_âŸ©
  set e := extChartAt I x
  set e' := extChartAt I' (f x)
  have : e' (f x) = (writtenInExtChartAt I I' x f) (e x) := by simp only [e, e', mfld_simps]
  rw [this] at hg
  have A : âˆ€á¶  y in ğ“[e.symm â»Â¹' s âˆ© range I] e x, f (e.symm y) âˆˆ t âˆ§ f (e.symm y) âˆˆ e'.source := by
    simp only [e, â† map_extChartAt_nhdsWithin, eventually_map]
    filter_upwards [hf.1.tendsto (extChartAt_source_mem_nhds I' (f x)),
      inter_mem_nhdsWithin s (extChartAt_source_mem_nhds I x)]
    rintro x' (hfx' : f x' âˆˆ e'.source) âŸ¨hx's, hx'âŸ©
    simp only [e.map_source hx', true_and_iff, e.left_inv hx', st hx's, *]
  refine ((hg.2.comp _ (hf.2.mono inter_subset_right) inter_subset_left).mono_of_mem
    (inter_mem ?_ self_mem_nhdsWithin)).congr_of_eventuallyEq ?_ ?_
  Â· filter_upwards [A]
    rintro x' âŸ¨ht, hfx'âŸ©
    simp only [*, mem_preimage, writtenInExtChartAt, (Â· âˆ˜ Â·), mem_inter_iff, e'.left_inv,
      true_and_iff]
    exact mem_range_self _
  Â· filter_upwards [A]
    rintro x' âŸ¨-, hfx'âŸ©
    simp only [*, (Â· âˆ˜ Â·), writtenInExtChartAt, e'.left_inv]
  Â· simp only [e, e', writtenInExtChartAt, (Â· âˆ˜ Â·), mem_extChartAt_source, e.left_inv, e'.left_inv]",refine ContMDiffWithinAt.comp_contMDiffWithinAt hf.contMDiffWithinAt hf.contMDiffWithinAt x ?_
Mathlib/NumberTheory/Cyclotomic/PID.lean,IsCyclotomicExtension.Rat.three_pid,three_pid,6d320164089fb7ddf42fef94dfd88b832a20bde8,":= by
  apply RingOfIntegers.isPrincipalIdealRing_of_abs_discr_lt
  rw [absdiscr_prime 3 K, IsCyclotomicExtension.finrank (n := 3) K
    (irreducible_rat (by norm_num)), nrComplexPlaces_eq_totient_div_two 3, totient_prime
      PNat.prime_three]
  simp only [Int.reduceNeg, PNat.val_ofNat, succ_sub_succ_eq_sub, tsub_zero, zero_lt_two,
    Nat.div_self, pow_one, cast_ofNat, neg_mul, one_mul, abs_neg, Int.cast_abs, Int.int_cast_ofNat,
    factorial_two, gt_iff_lt, abs_of_pos (show (0 : â„) < 3 by norm_num)]
  suffices (2 * (3 / 4) * (2 ^ 2 / 2)) ^ 2 < (2 * (Ï€ / 4) * (2 ^ 2 / 2)) ^ 2 from
    lt_trans (by norm_num) this
  gcongr
  exact pi_gt_three",error:  unknown constant 'Int.int_cast_ofNat',theorem three_pid [IsCyclotomicExtension {3} â„š K] : IsPrincipalIdealRing (ğ“ K) ,":= by
  apply RingOfIntegers.isPrincipalIdealRing_of_abs_discr_lt
  rw [absdiscr_prime 3 K, IsCyclotomicExtension.finrank (n := 3) K
    (irreducible_rat (by norm_num)), nrComplexPlaces_eq_totient_div_two 3, totient_prime
      PNat.prime_three]
  simp only [Int.reduceNeg, PNat.val_ofNat, succ_sub_succ_eq_sub, tsub_zero, zero_lt_two,
    Nat.div_self, pow_one, cast_ofNat, neg_mul, one_mul, abs_neg, Int.cast_abs, Int.cast_ofNat,
    factorial_two, gt_iff_lt, abs_of_pos (show (0 : â„) < 3 by norm_num)]
  suffices (2 * (3 / 4) * (2 ^ 2 / 2)) ^ 2 < (2 * (Ï€ / 4) * (2 ^ 2 / 2)) ^ 2 from
    lt_trans (by norm_num) this
  gcongr
  exact pi_gt_three",refine IsPrincipalIdealRing.isPrincipalIdealRing (ğ“ K) ?_
Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean,MvPolynomial.weightedHomogeneousSubmodule_mul,weightedHomogeneousSubmodule_mul,5bfb9ec189190fec527edb96b64e3187a3de6521,":= by
  classical
  rw [Submodule.mul_le]
  intro Ï† hÏ† Ïˆ hÏˆ c hc
  rw [coeff_mul] at hc
  obtain âŸ¨âŸ¨d, eâŸ©, hde, HâŸ© := Finset.exists_ne_zero_of_sum_ne_zero hc
  have aux : coeff d Ï† â‰  0 âˆ§ coeff e Ïˆ â‰  0 := by
    contrapose! H
    by_cases h : coeff d Ï† = 0 <;>
      simp_all only [Ne.def, not_false_iff, zero_mul, mul_zero]
  rw [â† Finsupp.mem_antidiagonal.mp hde, â† hÏ† aux.1, â† hÏˆ aux.2, map_add]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.29296 â†’ ?m.29296 â†’ Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.29928 â†’ ?m.29928 â†’ Prop
error:  unsolved goals
case neg
R : Type u_1
M : Type u_2
instâœÂ¹ : CommSemiring R
Ïƒ : Type u_3
instâœ : AddCommMonoid M
w : Ïƒ â†’ M
m n : M
Ï† : MvPolynomial Ïƒ R
hÏ† : Ï† âˆˆ weightedHomogeneousSubmodule R w m
Ïˆ : MvPolynomial Ïƒ R
hÏˆ : Ïˆ âˆˆ weightedHomogeneousSubmodule R w n
c : Ïƒ â†’â‚€ â„•
hc : âˆ‘ x âˆˆ antidiagonal c, coeff x.1 Ï† * coeff x.2 Ïˆ â‰  0
d e : Ïƒ â†’â‚€ â„•
hde : (d, e) âˆˆ antidiagonal c
H : coeff d Ï† â‰  0 â†’ coeff e Ïˆ = 0
h : Â¬coeff d Ï† = 0
âŠ¢ coeff d Ï† * coeff e Ïˆ = 0
error:  unknown constant 'Finsupp.mem_antidiagonal.mp'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.30084
case intro.mk.intro
R : Type u_1
M : Type u_2
instâœÂ¹ : CommSemiring R
Ïƒ : Type u_3
instâœ : AddCommMonoid M
w : Ïƒ â†’ M
m n : M
Ï† : MvPolynomial Ïƒ R
hÏ† : Ï† âˆˆ weightedHomogeneousSubmodule R w m
Ïˆ : MvPolynomial Ïƒ R
hÏˆ : Ïˆ âˆˆ weightedHomogeneousSubmodule R w n
c : Ïƒ â†’â‚€ â„•
hc : âˆ‘ x âˆˆ antidiagonal c, coeff x.1 Ï† * coeff x.2 Ïˆ â‰  0
d e : Ïƒ â†’â‚€ â„•
hde : (d, e) âˆˆ antidiagonal c
H : coeff (d, e).1 Ï† * coeff (d, e).2 Ïˆ â‰  0
aux : coeff d Ï† â‰  0 âˆ§ coeff e Ïˆ â‰  0
âŠ¢ (weightedDegree w) c = m + n","theorem weightedHomogeneousSubmodule_mul (w : Ïƒ â†’ M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n â‰¤
      weightedHomogeneousSubmodule R w (m + n) ",":= by
  classical
  rw [Submodule.mul_le]
  intro Ï† hÏ† Ïˆ hÏˆ c hc
  rw [coeff_mul] at hc
  obtain âŸ¨âŸ¨d, eâŸ©, hde, HâŸ© := Finset.exists_ne_zero_of_sum_ne_zero hc
  have aux : coeff d Ï† â‰  0 âˆ§ coeff e Ïˆ â‰  0 := by
    contrapose! H
    by_cases h : coeff d Ï† = 0 <;>
      simp_all only [Ne, not_false_iff, zero_mul, mul_zero]
  rw [â† mem_antidiagonal.mp hde, â† hÏ† aux.1, â† hÏˆ aux.2, map_add]",rw [weightedHomogeneousSubmodule_mul]
Mathlib/MeasureTheory/Measure/Stieltjes.lean,StieltjesFunction.measure_Ioc,measure_Ioc,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [StieltjesFunction.measure]
  exact f.outer_Ioc a b","error:  unsolved goals
case inl
f : StieltjesFunction
a b : â„
hab : a â‰¤ b
A : Disjoint {a} (Ioc a b)
âŠ¢ f.measure {a} + ofReal (â†‘f b - â†‘f a) = ofReal (â†‘f b - leftLim (â†‘f) a)
error:  unsolved goals
case inr
f : StieltjesFunction
a b : â„
hab : a < b
A : Disjoint {a} (Ioo a b)
âŠ¢ f.measure {a} + ofReal (leftLim (â†‘f) b - â†‘f a) = ofReal (leftLim (â†‘f) b - leftLim (â†‘f) a)",theorem measure_Ioc (a b : â„) : f.measure (Ioc a b) = ofReal (f b - f a) ,":= by
  rw [StieltjesFunction.measure]
  exact f.outer_Ioc a b","rw [measure_Ioc, f.measure_Ioc]"
Mathlib/Algebra/Polynomial/Eval.lean,Polynomial.eval_C_mul,eval_C_mul,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction p with
  | h_add p q ph qh =>
    simp only [mul_add, eval_add, ph, qh]
  | h_monomial n b =>
    simp only [mul_assoc, C_mul_monomial, eval_monomial]","error:  invalid alternative name 'h_add'
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated",theorem eval_C_mul : (C a * p).eval x = a * p.eval x ,":= by
  induction p using Polynomial.induction_on' with
  | h_add p q ph qh =>
    simp only [mul_add, eval_add, ph, qh]
  | h_monomial n b =>
    simp only [mul_assoc, C_mul_monomial, eval_monomial]",simp [eval_C_mul]
Mathlib/MeasureTheory/Integral/TorusIntegral.lean,torusIntegral_succ,torusIntegral_succ,878024beabe74d3476b6e31acfd90d64e274a958,":= by
  set e : â„ Ã— â„â¿ â‰ƒáµ â„â¿âºÂ¹ := (MeasurableEquiv.piFinSuccAboveEquiv (fun _ => â„) i).symm
  have hem : MeasurePreserving e :=
    (volume_preserving_piFinSuccAboveEquiv (fun _ : Fin (n + 1) => â„) i).symm _
  have heÏ€ : (e â»Â¹' Icc 0 fun _ => 2 * Ï€) = Icc 0 (2 * Ï€) Ã—Ë¢ Icc (0 : â„â¿) fun _ => 2 * Ï€ :=
    ((OrderIso.piFinSuccAboveIso (fun _ => â„) i).symm.preimage_Icc _ _).trans (Icc_prod_eq _ _)
  rw [torusIntegral, â† hem.map_eq, set_integral_map_equiv, heÏ€, Measure.volume_eq_prod,
    set_integral_prod, circleIntegral_def_Icc]
  Â· refine' set_integral_congr measurableSet_Icc fun Î¸ _ => _
    simp (config := { unfoldPartialApp := true }) only [torusIntegral, â† integral_smul,
      deriv_circleMap, i.prod_univ_succAbove _, smul_smul, torusMap, circleMap_zero]
    refine' set_integral_congr measurableSet_Icc fun Î˜ _ => _
    simp only [MeasurableEquiv.piFinSuccAboveEquiv_symm_apply, i.insertNth_apply_same,
      i.insertNth_apply_succAbove, Function.comp_def]
    congr 2
    simp only [funext_iff, i.forall_iff_succAbove, circleMap, Fin.insertNth_apply_same,
      eq_self_iff_true, Fin.insertNth_apply_succAbove, imp_true_iff, and_self_iff]
  Â· have := hf.function_integrable
    rwa [â† hem.integrableOn_comp_preimage e.measurableEmbedding, heÏ€] at this","warning:  @torusIntegral does not have a doc string
error:  unknown constant 'MeasurableEquiv.piFinSuccAboveEquiv'
error:  unknown identifier 'volume_preserving_piFinSuccAboveEquiv'
error:  type mismatch
  Eq.trans (OrderIso.preimage_Icc (OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm ?m.124422 ?m.124423)
    (Icc_prod_eq ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124422)
      ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124423))
has type
  â‡‘(OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm â»Â¹' Icc ?m.124422 ?m.124423 =
    Icc ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124422).1
        ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124423).1 Ã—Ë¢
      Icc ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124422).2
        ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124423).2 : Prop
but is expected to have type
  (â‡‘e â»Â¹' Icc 0 fun x â†¦ 2 * Ï€) = Icc 0 (2 * Ï€) Ã—Ë¢ Icc 0 fun x â†¦ 2 * Ï€ : Prop
warning:  `MeasureTheory.set_integral_map_equiv` has been deprecated, use `MeasureTheory.setIntegral_map_equiv` instead
warning:  `MeasureTheory.set_integral_prod` has been deprecated, use `MeasureTheory.setIntegral_prod` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
error:  unknown constant 'MeasurableEquiv.piFinSuccAboveEquiv_symm_apply'
error:  simp made no progress","theorem torusIntegral_succAbove {f : â„‚â¿âºÂ¹ â†’ E} {c : â„‚â¿âºÂ¹} {R : â„â¿âºÂ¹} (hf : TorusIntegrable f c R)
    (i : Fin (n + 1)) :
    (âˆ¯ x in T(c, R), f x) =
      âˆ® x in C(c i, R i), âˆ¯ y in T(c âˆ˜ i.succAbove, R âˆ˜ i.succAbove), f (i.insertNth x y) ",":= by
  set e : â„ Ã— â„â¿ â‰ƒáµ â„â¿âºÂ¹ := (MeasurableEquiv.piFinSuccAbove (fun _ => â„) i).symm
  have hem : MeasurePreserving e :=
    (volume_preserving_piFinSuccAbove (fun _ : Fin (n + 1) => â„) i).symm _
  have heÏ€ : (e â»Â¹' Icc 0 fun _ => 2 * Ï€) = Icc 0 (2 * Ï€) Ã—Ë¢ Icc (0 : â„â¿) fun _ => 2 * Ï€ :=
    ((OrderIso.piFinSuccAboveIso (fun _ => â„) i).symm.preimage_Icc _ _).trans (Icc_prod_eq _ _)
  rw [torusIntegral, â† hem.map_eq, setIntegral_map_equiv, heÏ€, Measure.volume_eq_prod,
    setIntegral_prod, circleIntegral_def_Icc]
  Â· refine setIntegral_congr measurableSet_Icc fun Î¸ _ => ?_
    simp (config := { unfoldPartialApp := true }) only [e, torusIntegral, â† integral_smul,
      deriv_circleMap, i.prod_univ_succAbove _, smul_smul, torusMap, circleMap_zero]
    refine setIntegral_congr measurableSet_Icc fun Î˜ _ => ?_
    simp only [MeasurableEquiv.piFinSuccAbove_symm_apply, i.insertNth_apply_same,
      i.insertNth_apply_succAbove, (Â· âˆ˜ Â·)]
    congr 2
    simp only [funext_iff, i.forall_iff_succAbove, circleMap, Fin.insertNth_apply_same,
      eq_self_iff_true, Fin.insertNth_apply_succAbove, imp_true_iff, and_self_iff]
  Â· have := hf.function_integrable
    rwa [â† hem.integrableOn_comp_preimage e.measurableEmbedding, heÏ€] at this","simp only [theorem, insertNth, Fin.succAbove_succAbove_succAbove]"
Mathlib/Analysis/Complex/RealDeriv.lean,conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj,conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj,01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  rw [conformalAt_iff_isConformalMap_fderiv]
  rw [isConformalMap_iff_is_complex_or_conj_linear]
  apply and_congr_left
  intro h
  have h_diff := h.imp_symm fderiv_zero_of_not_differentiableAt
  apply or_congr
  Â· rw [differentiableAt_iff_restrictScalars â„ h_diff]
  rw [â† conj_conj z] at h_diff
  rw [differentiableAt_iff_restrictScalars â„ (h_diff.comp _ conjCle.differentiableAt)]
  refine' exists_congr fun g => rfl.congr _
  have : fderiv â„ conj (conj z) = _ := conjCle.fderiv
  simp [fderiv.comp _ h_diff conjCle.differentiableAt, this, conj_conj]","error:  unknown identifier 'conjCle.differentiableAt'
error:  unknown identifier 'conjCle.fderiv'
error:  unsolved goals
case h.hâ‚‚
E : Type u_1
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace â„‚ E
zâœ : â„‚
fâœ : â„‚ â†’ E
f : â„‚ â†’ â„‚
z : â„‚
h : fderiv â„ f z â‰  0
h_diff : DifferentiableAt â„ f ((starRingEnd â„‚) ((starRingEnd â„‚) z))
g : â„‚ â†’L[â„‚] â„‚
âŠ¢ (fderiv â„ f z).comp â†‘conjCLE = fderiv â„ (f âˆ˜ â‡‘(starRingEnd â„‚)) ((starRingEnd â„‚) z)","theorem conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj {f : â„‚ â†’ â„‚} {z : â„‚} :
    ConformalAt f z â†”
      (DifferentiableAt â„‚ f z âˆ¨ DifferentiableAt â„‚ (f âˆ˜ conj) (conj z)) âˆ§ fderiv â„ f z â‰  0 ",":= by
  rw [conformalAt_iff_isConformalMap_fderiv]
  rw [isConformalMap_iff_is_complex_or_conj_linear]
  apply and_congr_left
  intro h
  have h_diff := h.imp_symm fderiv_zero_of_not_differentiableAt
  apply or_congr
  Â· rw [differentiableAt_iff_restrictScalars â„ h_diff]
  rw [â† conj_conj z] at h_diff
  rw [differentiableAt_iff_restrictScalars â„ (h_diff.comp _ conjCLE.differentiableAt)]
  refine exists_congr fun g => rfl.congr ?_
  have : fderiv â„ conj (conj z) = _ := conjCLE.fderiv
  simp [fderiv.comp _ h_diff conjCLE.differentiableAt, this, conj_conj]","simp only [conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj,
  conformalAt_iff_differentiableAt_comp_conj]"
Mathlib/RingTheory/Artinian.lean,LinearMap.eventually_codisjoint_ker_pow_range_pow,eventually_codisjoint_ker_pow_range_pow,43b4712c74901b669d8c212f8523d4863290c5b0,":= by
  obtain âŸ¨n, hn : âˆ€ m, n â‰¤ m â†’ LinearMap.range (f ^ n) = LinearMap.range (f ^ m)âŸ© :=
    monotone_stabilizes f.iterateRange
  refine eventually_atTop.mpr âŸ¨n, fun m hm â†¦ codisjoint_iff.mpr ?_âŸ©
  simp_rw [â† hn _ hm, Submodule.eq_top_iff', Submodule.mem_sup]
  intro x
  suffices : âˆƒ y, (f ^ m) ((f ^ n) y) = (f ^ m) x
  Â· obtain âŸ¨y, hyâŸ© := this; exact âŸ¨x - (f ^ n) y, by simp [hy], (f ^ n) y, by simpâŸ©
  simp_rw [f.pow_apply n, f.pow_apply m, â† iterate_add_apply, â† f.pow_apply (m + n),
    â† f.pow_apply m, â† mem_range, â† hn _ (n.le_add_left m), hn _ hm]
  exact LinearMap.mem_range_self (f ^ m) x",error:  unexpected token ':'; expected term,"theorem eventually_codisjoint_ker_pow_range_pow (f : M â†’â‚—[R] M) :
    âˆ€á¶  n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) ",":= by
  obtain âŸ¨n, hn : âˆ€ m, n â‰¤ m â†’ LinearMap.range (f ^ n) = LinearMap.range (f ^ m)âŸ© :=
    monotone_stabilizes f.iterateRange
  refine eventually_atTop.mpr âŸ¨n, fun m hm â†¦ codisjoint_iff.mpr ?_âŸ©
  simp_rw [â† hn _ hm, Submodule.eq_top_iff', Submodule.mem_sup]
  intro x
  rsuffices âŸ¨y, hyâŸ© : âˆƒ y, (f ^ m) ((f ^ n) y) = (f ^ m) x
  Â· exact âŸ¨x - (f ^ n) y, by simp [hy], (f ^ n) y, by simpâŸ©
  simp_rw [f.pow_apply n, f.pow_apply m, â† iterate_add_apply, â† f.pow_apply (m + n),
    â† f.pow_apply m, â† mem_range (f := _), â† hn _ (n.le_add_left m), hn _ hm]
  exact LinearMap.mem_range_self (f ^ m) x",rw [eventually_codisjoint_ker_pow_range_pow_range_pow]
Mathlib/Data/Num/Lemmas.lean,PosNum.cast_to_nat,cast_to_nat,fc94d7cf19de72da26bfb583fdb140d8737abb30,"  | 1 => Nat.cast_one
  | bit0 p => by simp [cast_to_nat p]
  | bit1 p => by simp [cast_to_nat p]","warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
error:  unsolved goals
Î± : Type u_1
instâœ : AddMonoidWithOne Î±
p : PosNum
âŠ¢ â†‘(_root_.bit0 â†‘p) = _root_.bit0 â†‘p
error:  unsolved goals
Î± : Type u_1
instâœ : AddMonoidWithOne Î±
p : PosNum
âŠ¢ â†‘(_root_.bit1 â†‘p) = _root_.bit1 â†‘p
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `castNum` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated","theorem cast_to_nat [AddMonoidWithOne Î±] : âˆ€ n : PosNum, ((n : â„•) : Î±) = n
","  | 1 => Nat.cast_one
  | bit0 p => (Nat.cast_bit0 _).trans <| congr_arg _root_.bit0 p.cast_to_nat
  | bit1 p => (Nat.cast_bit1 _).trans <| congr_arg _root_.bit1 p.cast_to_nat",induction' cast_to_nat with cast_to_nat
Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean,CategoryTheory.Limits.colimitLimitToLimitColimit_surjective,colimitLimitToLimitColimit_surjective,31d572995d4db174b6fbfa3e3dee4f9027839468,":= by
  classical
    intro x
    have z := fun j => jointly_surjective'.{v, v} (limit.Ï€ (curry.obj F â‹™ Limits.colim) j x)
    let k : J â†’ K := fun j => (z j).choose
    let y : âˆ€ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : âˆ€ j,
        colimit.Î¹ ((curry.obj F).obj j) (k j) (y j) = limit.Ï€ (curry.obj F â‹™ Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) âˆ…
    have g : âˆ€ j, k j âŸ¶ k' := fun j => IsFiltered.toSup (Finset.univ.image k) âˆ… (by simp)
    clear_value k'
    have w :
      âˆ€ {j j' : J} (f : j âŸ¶ j'),
        colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((ğŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =
          colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ğŸ™ (k j)) : (j, k j) âŸ¶ (j', k j)) â‰« (ğŸ™ j', g j) : (j, k j) âŸ¶ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply'.{v, v}, t, FunctorToTypes.map_comp_apply, Colimit.w_apply'.{v, v}, e,
        â† Limit.w_apply' f, â† e]
      simp
    simp_rw [colimit_eq_iff.{v, v}] at w
    let kf : âˆ€ {j j'} (_ : j âŸ¶ j'), K := fun f => (w f).choose
    let gf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun f => (w f).choose_spec.choose
    let hf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      âˆ€ {j j'} (f : j âŸ¶ j'),
        F.map ((ğŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j') =
          F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ğŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [â† FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) âˆª {k'}
    have kfO : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âˆˆ O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (by
            rw [Finset.mem_biUnion]
            refine' âŸ¨j, Finset.mem_univ j, _âŸ©
            rw [Finset.mem_biUnion]
            refine' âŸ¨j', Finset.mem_univ j', _âŸ©
            rw [Finset.mem_image]
            refine' âŸ¨f, Finset.mem_univ _, _âŸ©
            rfl))
    have k'O : k' âˆˆ O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Î£' (X Y : K) (_ : X âˆˆ O) (_ : Y âˆˆ O), X âŸ¶ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j âŸ¶ j' =>
            {âŸ¨k', kf f, k'O, kfO f, gf fâŸ©, âŸ¨k', kf f, k'O, kfO f, hf fâŸ©}
    obtain âŸ¨k'', i', s'âŸ© := IsFiltered.sup_exists O H
    let i : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âŸ¶ k'' := fun {j} {j'} f => i' (kfO f)
    have s : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ jâ‚„} (f : jâ‚ âŸ¶ jâ‚‚) (f' : jâ‚ƒ âŸ¶ jâ‚„), gf f â‰« i f = hf f' â‰« i f' := by
      intros jâ‚ jâ‚‚ jâ‚ƒ jâ‚„ f f'
      rw [s', s']
      exact k'O
      swap
      Â· rw [Finset.mem_biUnion]
        refine' âŸ¨jâ‚, Finset.mem_univ _, _âŸ©
        rw [Finset.mem_biUnion]
        refine' âŸ¨jâ‚‚, Finset.mem_univ _, _âŸ©
        rw [Finset.mem_biUnion]
        refine' âŸ¨f, Finset.mem_univ _, _âŸ©
        simp only [true_or_iff, eq_self_iff_true, and_self_iff, Finset.mem_insert, heq_iff_eq]
      Â· rw [Finset.mem_biUnion]
        refine' âŸ¨jâ‚ƒ, Finset.mem_univ _, _âŸ©
        rw [Finset.mem_biUnion]
        refine' âŸ¨jâ‚„, Finset.mem_univ _, _âŸ©
        rw [Finset.mem_biUnion]
        refine' âŸ¨f', Finset.mem_univ _, _âŸ©
        simp only [eq_self_iff_true, or_true_iff, and_self_iff, Finset.mem_insert,
          Finset.mem_singleton, heq_iff_eq]
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    Â· 
      apply colimit.Î¹ (curry.obj (swap K J â‹™ F) â‹™ Limits.lim) k'' _
      dsimp
      apply Limit.mk.{v, v}
      swap
      Â·
        exact fun j => F.map (âŸ¨ğŸ™ j, g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j)âŸ© : (j, k j) âŸ¶ (j, k'')) (y j)
      Â· 
        dsimp
        intro j j' f
        simp only [â† FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j)) : (j, k j) âŸ¶ (j', k'')) (y j) =
              F.map ((f, g j â‰« hf f â‰« i f) : (j, k j) âŸ¶ (j', k'')) (y j) :=
            by rw [s (ğŸ™ j) f]
          _ =
              F.map ((ğŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))
                (F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j)) :=
            by rw [â† FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ğŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))
                (F.map ((ğŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j')) :=
            by rw [â† wf f]
          _ = F.map ((ğŸ™ j', g j' â‰« gf f â‰« i f) : (j', k j') âŸ¶ (j', k'')) (y j') := by
            rw [â† FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ğŸ™ j', g j' â‰« gf (ğŸ™ j') â‰« i (ğŸ™ j')) : (j', k j') âŸ¶ (j', k'')) (y j') := by
            rw [s f (ğŸ™ j'), â† s (ğŸ™ j') (ğŸ™ j')]
    Â· 
      apply limit_ext'
      intro j
      simp only [id.def, â† e, Limits.Î¹_colimitLimitToLimitColimit_Ï€_apply,
          colimit_eq_iff.{v, v}, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.Ï€_mk]
      refine' âŸ¨k'', ğŸ™ k'', g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j), _âŸ©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","error:  application type mismatch
  jointly_surjective' (limit.Ï€ (curry.obj F â‹™ colim) j x)
argument
  limit.Ï€ (curry.obj F â‹™ colim) j x
has type
  (curry.obj F â‹™ colim).obj j : Type v
but is expected to have type
  colimit ?m.27488 : Type v
error:  unsolved goals
J : Type uâ‚
K : Type uâ‚‚
instâœâ´ : SmallCategory J
instâœÂ³ : Category.{vâ‚‚, uâ‚‚} K
instâœÂ² : Small.{v, uâ‚‚} K
instâœÂ¹ : FinCategory J
F : J Ã— K â¥¤ Type v
instâœ : IsFiltered K
x : limit (curry.obj F â‹™ colim)
âŠ¢ âˆƒ a, colimitLimitToLimitColimit F a = x","theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) ",":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.Ï€ (curry.obj F â‹™ Limits.colim) j x)
    let k : J â†’ K := fun j => (z j).choose
    let y : âˆ€ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : âˆ€ j,
        colimit.Î¹ ((curry.obj F).obj j) (k j) (y j) = limit.Ï€ (curry.obj F â‹™ Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) âˆ…
    have g : âˆ€ j, k j âŸ¶ k' := fun j => IsFiltered.toSup (Finset.univ.image k) âˆ… (by simp)
    clear_value k'
    have w :
      âˆ€ {j j' : J} (f : j âŸ¶ j'),
        colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((ğŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =
          colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ğŸ™ (k j)) : (j, k j) âŸ¶ (j', k j)) â‰« (ğŸ™ j', g j) : (j, k j) âŸ¶ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        â† Limit.w_apply.{uâ‚, v, uâ‚} f, â† e]
      simp only [Functor.comp_map, Types.Colimit.Î¹_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : âˆ€ {j j'} (_ : j âŸ¶ j'), K := fun f => (w f).choose
    let gf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun f => (w f).choose_spec.choose
    let hf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      âˆ€ {j j'} (f : j âŸ¶ j'),
        F.map ((ğŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j') =
          F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ğŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [â† FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) âˆª {k'}
    have kfO : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âˆˆ O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr âŸ¨j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr âŸ¨j', Finset.mem_univ j',
              Finset.mem_image.mpr âŸ¨f, Finset.mem_univ _, rflâŸ©âŸ©âŸ©))
    have k'O : k' âˆˆ O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Î£' (X Y : K) (_ : X âˆˆ O) (_ : Y âˆˆ O), X âŸ¶ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j âŸ¶ j' =>
            {âŸ¨k', kf f, k'O, kfO f, gf fâŸ©, âŸ¨k', kf f, k'O, kfO f, hf fâŸ©}
    obtain âŸ¨k'', i', s'âŸ© := IsFiltered.sup_exists O H
    let i : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âŸ¶ k'' := fun {j} {j'} f => i' (kfO f)
    have s : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ jâ‚„} (f : jâ‚ âŸ¶ jâ‚‚) (f' : jâ‚ƒ âŸ¶ jâ‚„), gf f â‰« i f = hf f' â‰« i f' := by
      intros jâ‚ jâ‚‚ jâ‚ƒ jâ‚„ f f'
      rw [s', s']
      Â· exact k'O
      Â· exact Finset.mem_biUnion.mpr âŸ¨jâ‚ƒ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr âŸ¨jâ‚„, Finset.mem_univ _,
            Finset.mem_biUnion.mpr âŸ¨f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivialâŸ©âŸ©âŸ©
      Â· exact Finset.mem_biUnion.mpr âŸ¨jâ‚, Finset.mem_univ _,
          Finset.mem_biUnion.mpr âŸ¨jâ‚‚, Finset.mem_univ _,
            Finset.mem_biUnion.mpr âŸ¨f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivialâŸ©âŸ©âŸ©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    Â· 
      apply colimit.Î¹ (curry.obj (swap K J â‹™ F) â‹™ Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      Â·
        exact fun j => F.map (âŸ¨ğŸ™ j, g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j)âŸ© : (j, k j) âŸ¶ (j, k'')) (y j)
      Â· 
        dsimp
        intro j j' f
        simp only [â† FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j)) : (j, k j) âŸ¶ (j', k'')) (y j) =
              F.map ((f, g j â‰« hf f â‰« i f) : (j, k j) âŸ¶ (j', k'')) (y j) := by
            rw [s (ğŸ™ j) f]
          _ =
              F.map ((ğŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))
                (F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j)) := by
            rw [â† FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ğŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))
                (F.map ((ğŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j')) := by
            rw [â† wf f]
          _ = F.map ((ğŸ™ j', g j' â‰« gf f â‰« i f) : (j', k j') âŸ¶ (j', k'')) (y j') := by
            rw [â† FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ğŸ™ j', g j' â‰« gf (ğŸ™ j') â‰« i (ğŸ™ j')) : (j', k j') âŸ¶ (j', k'')) (y j') := by
            rw [s f (ğŸ™ j'), â† s (ğŸ™ j') (ğŸ™ j')]
    Â· 
      apply limit_ext
      intro j
      simp only [id, â† e, Limits.Î¹_colimitLimitToLimitColimit_Ï€_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.Ï€_mk]
      refine âŸ¨k'', ğŸ™ k'', g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j), ?_âŸ©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","have : Function.Surjective (colimitLimitToLimitColimitColimit F) :=
  colimitLimitColimitColimitColimitColimitColimitColimitColimit F"
Mathlib/Topology/Homotopy/HSpaces.lean,unitInterval.continuous_qRight,continuous_qRight,f655aad92f39fa1eff3436b3b0c4a1004e666b53,":=
  by unfold qRight; fun_prop","error:  `fun_prop` was unable to prove `Continuous fun p â†¦ Set.projIcc 0 1 qRight.proof_1 (2 * â†‘p.1 / (1 + â†‘p.2))`

Try running with discharger `fun_prop (disch:=aesop)` or with a different discharger tactic like `assumption`, `linarith`, `omega`.
Sometimes it is useful to run `fun_prop (disch:=trace_state; sorry)` which will print all the necessary subgoals for `fun_prop` to succeed.

Potential issues to fix:
  No theorems found for `Set.projIcc` in order to prove Continuous fun p â†¦ Set.projIcc 0 1 qRight.proof_1 (2 * â†‘p.1 / (1 + â†‘p.2))
  No theorems found for `Set.projIcc` in order to prove Continuous fun a â†¦ Set.projIcc 0 1 qRight.proof_1 a
  Failed to synthesize instance DiscreteTopology â„ when applying theorem continuous_of_discreteTopology.

For more detailed information use `set_option trace.Meta.Tactic.fun_prop true`",theorem continuous_qRight : Continuous qRight ,":=
  continuous_projIcc.comp <|
    Continuous.div (by fun_prop) (by fun_prop) fun x â†¦ (add_pos zero_lt_one).ne'",exact continuous_qRight.continuous
Mathlib/MeasureTheory/Measure/MeasureSpace.lean,MeasureTheory.Measure.AbsolutelyContinuous.add_right,add_right,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  intro s hs
  simp only [add_toOuterMeasure, OuterMeasure.coe_add, Pi.add_apply, add_eq_zero] at hs âŠ¢
  exact h1 hs.1","warning:  @Measure.AbsolutelyContinuous does not have a doc string
error:  simp made no progress",lemma add_right (h1 : Î¼ â‰ª Î½) (Î½' : Measure Î±) : Î¼ â‰ª Î½ + Î½' ,":= by
  intro s hs
  simp only [coe_add, Pi.add_apply, add_eq_zero] at hs âŠ¢
  exact h1 hs.1",refine Measure.AbsolutelyContinuous.mk fun Î½' hÎ½' => ?_
Mathlib/Topology/Order/IsLUB.lean,IsLUB.mem_upperBounds_of_tendsto,IsLUB.mem_upperBounds_of_tendsto,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rintro _ âŸ¨x, hx, rflâŸ©
  replace ha := ha.inter_Ici_of_mem hx
  haveI := ha.nhdsWithin_neBot âŸ¨x, hx, le_rflâŸ©
  refine' ge_of_tendsto (hb.mono_left (nhdsWithin_mono _ (inter_subset_left s (Ici x)))) _
  exact mem_of_superset self_mem_nhdsWithin fun y hy => hf hx hy.1 hy.2","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set Î± : Type u_1
but is expected to have type
  ?m.28538 âˆˆ ?m.28536 âˆ© ?m.28537 : Prop
error:  invalid projection, structure expected
  hy
has type
  y âˆˆ ?m.28917
error:  invalid projection, structure expected
  hy
has type
  Set.Mem y ?m.28917
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hy
has type
  ?m.28917 y
error:  invalid projection, structure expected
  hy
has type
  y âˆˆ ?m.28917
error:  invalid projection, structure expected
  hy
has type
  Set.Mem y ?m.28917
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hy
has type
  ?m.28917 y
error:  type mismatch
  mem_of_superset self_mem_nhdsWithin fun y hy â†¦ hf hx (?m.28995 y hy) (?m.28996 y hy)
has type
  (fun y â†¦ Preorder.toLE.1 (f x) (f (?m.28990 y))) âˆˆ ğ“[?m.28917] ?m.28916 : Prop
but is expected to have type
  (ğ“[?intro.intro.refine'_2] a).NeBot : Prop","theorem IsLUB.mem_upperBounds_of_tendsto [Preorder Î³] [TopologicalSpace Î³] [OrderClosedTopology Î³]
    {f : Î± â†’ Î³} {s : Set Î±} {a : Î±} {b : Î³} (hf : MonotoneOn f s) (ha : IsLUB s a)
    (hb : Tendsto f (ğ“[s] a) (ğ“ b)) : b âˆˆ upperBounds (f '' s) ",":= by
  rintro _ âŸ¨x, hx, rflâŸ©
  replace ha := ha.inter_Ici_of_mem hx
  haveI := ha.nhdsWithin_neBot âŸ¨x, hx, le_rflâŸ©
  refine ge_of_tendsto (hb.mono_left (nhdsWithin_mono a (inter_subset_left (t := Ici x)))) ?_
  exact mem_of_superset self_mem_nhdsWithin fun y hy => hf hx hy.1 hy.2",simp only [upperBounds_of_mem_upperBounds_of_mem_upperBounds_of_mem_upperBounds_of_upperBounds_image]
Mathlib/LinearAlgebra/AffineSpace/Independent.lean,exists_subset_affineIndependent_affineSpan_eq_top,exists_subset_affineIndependent_affineSpan_eq_top,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases s.eq_empty_or_nonempty with (rfl | âŸ¨pâ‚, hpâ‚âŸ©)
  Â· have pâ‚ : P := AddTorsor.nonempty.some
    let hsv := Basis.ofVectorSpace k V
    have hsvi := hsv.linearIndependent
    have hsvt := hsv.span_eq
    rw [Basis.coe_ofVectorSpace] at hsvi hsvt
    have h0 : âˆ€ v : V, v âˆˆ Basis.ofVectorSpaceIndex _ _ â†’ v â‰  0 := by
      intro v hv
      simpa [hsv] using hsv.ne_zero âŸ¨v, hvâŸ©
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 pâ‚] at hsvi
    exact
      âŸ¨{pâ‚} âˆª (fun v => v +áµ¥ pâ‚) '' _, Set.empty_subset _, hsvi,
        affineSpan_singleton_union_vadd_eq_top_of_span_eq_top pâ‚ hsvtâŸ©
  Â· rw [affineIndependent_set_iff_linearIndependent_vsub k hpâ‚] at h
    let bsv := Basis.extend h
    have hsvi := bsv.linearIndependent
    have hsvt := bsv.span_eq
    rw [Basis.coe_extend] at hsvi hsvt
    have hsv := h.subset_extend (Set.subset_univ _)
    have h0 : âˆ€ v : V, v âˆˆ h.extend _ â†’ v â‰  0 := by
      intro v hv
      simpa [bsv] using bsv.ne_zero âŸ¨v, hvâŸ©
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 pâ‚] at hsvi
    refine âŸ¨{pâ‚} âˆª (fun v => v +áµ¥ pâ‚) '' h.extend (Set.subset_univ _), ?_, ?_âŸ©
    Â· refine Set.Subset.trans ?_ (Set.union_subset_union_right _ (Set.image_subset _ hsv))
      simp [Set.image_image]
    Â· use hsvi
      exact affineSpan_singleton_union_vadd_eq_top_of_span_eq_top pâ‚ hsvt","error:  typeclass instance problem is stuck, it is often due to metavariables
  Module (?m.225306 v) V","theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s â†’ P)) :
    âˆƒ t : Set P, s âŠ† t âˆ§ AffineIndependent k (fun p => p : t â†’ P) âˆ§ affineSpan k t = âŠ¤ ",":= by
  rcases s.eq_empty_or_nonempty with (rfl | âŸ¨pâ‚, hpâ‚âŸ©)
  Â· have pâ‚ : P := AddTorsor.nonempty.some
    let hsv := Basis.ofVectorSpace k V
    have hsvi := hsv.linearIndependent
    have hsvt := hsv.span_eq
    rw [Basis.coe_ofVectorSpace] at hsvi hsvt
    have h0 : âˆ€ v : V, v âˆˆ Basis.ofVectorSpaceIndex k V â†’ v â‰  0 := by
      intro v hv
      simpa [hsv] using hsv.ne_zero âŸ¨v, hvâŸ©
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 pâ‚] at hsvi
    exact
      âŸ¨{pâ‚} âˆª (fun v => v +áµ¥ pâ‚) '' _, Set.empty_subset _, hsvi,
        affineSpan_singleton_union_vadd_eq_top_of_span_eq_top pâ‚ hsvtâŸ©
  Â· rw [affineIndependent_set_iff_linearIndependent_vsub k hpâ‚] at h
    let bsv := Basis.extend h
    have hsvi := bsv.linearIndependent
    have hsvt := bsv.span_eq
    rw [Basis.coe_extend] at hsvi hsvt
    have hsv := h.subset_extend (Set.subset_univ _)
    have h0 : âˆ€ v : V, v âˆˆ h.extend (Set.subset_univ _) â†’ v â‰  0 := by
      intro v hv
      simpa [bsv] using bsv.ne_zero âŸ¨v, hvâŸ©
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 pâ‚] at hsvi
    refine âŸ¨{pâ‚} âˆª (fun v => v +áµ¥ pâ‚) '' h.extend (Set.subset_univ _), ?_, ?_âŸ©
    Â· refine Set.Subset.trans ?_ (Set.union_subset_union_right _ (Set.image_subset _ hsv))
      simp [Set.image_image]
    Â· use hsvi
      exact affineSpan_singleton_union_vadd_eq_top_of_span_eq_top pâ‚ hsvt",rw [exists_subset_affineIndependent_affineSpan_eq_top]
Mathlib/Topology/ProperMap.lean,isProperMap_iff_isClosedMap_and_tendsto_cofinite,isProperMap_iff_isClosedMap_and_tendsto_cofinite,8c47c4038ef15eef85511d722c657967f031d078,":= by
  simp_rw [isProperMap_iff_isClosedMap_and_compact_fibers, Tendsto,
    le_cofinite_iff_compl_singleton_mem, mem_map, preimage_compl]
  refine and_congr_right fun f_cont â†¦ and_congr_right fun _ â†¦
    âŸ¨fun H y â†¦ (H y).compl_mem_cocompact, fun H y â†¦ ?_âŸ©
  rcases mem_cocompact.mp (H y) with âŸ¨K, hK, hKyâŸ©
  exact isCompact_of_isClosed_subset hK (isClosed_singleton.preimage f_cont)
    (compl_le_compl_iff_le.mp hKy)",error:  unknown identifier 'isCompact_of_isClosed_subset',"lemma isProperMap_iff_isClosedMap_and_tendsto_cofinite [T1Space Y] :
    IsProperMap f â†” Continuous f âˆ§ IsClosedMap f âˆ§ Tendsto f (cocompact X) cofinite ",":= by
  simp_rw [isProperMap_iff_isClosedMap_and_compact_fibers, Tendsto,
    le_cofinite_iff_compl_singleton_mem, mem_map, preimage_compl]
  refine and_congr_right fun f_cont â†¦ and_congr_right fun _ â†¦
    âŸ¨fun H y â†¦ (H y).compl_mem_cocompact, fun H y â†¦ ?_âŸ©
  rcases mem_cocompact.mp (H y) with âŸ¨K, hK, hKyâŸ©
  exact hK.of_isClosed_subset (isClosed_singleton.preimage f_cont)
    (compl_le_compl_iff_le.mp hKy)",constructor
Mathlib/Analysis/NormedSpace/FiniteDimension.lean,FiniteDimensional.proper,FiniteDimensional.proper,b68cba430a2bd7b48000c9b0293cda90c5c2713f,":= by
  set e := ContinuousLinearEquiv.ofFinrankEq (@finrank_fin_fun ğ•œ _ _ (finrank ğ•œ E)).symm
  exact e.symm.antilipschitz.properSpace e.symm.continuous e.symm.surjective","error:  failed to synthesize
  CompleteSpace ğ•œ
use `set_option diagnostics true` to get diagnostic information
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  e
has type
  ?m.530735
error:  invalid occurrence of universe level 'u_1' at 'FiniteDimensional.proper_real', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  proper.{0, u, u_1} Real E
at declaration body
  fun (E : Type u) [NormedAddCommGroup E] [NormedSpace â„ E] [FiniteDimensional â„ E] â†¦ proper â„ E
error:  invalid occurrence of universe level 'u_3' at 'instProperSpaceSubtypeMemSubmoduleOfCompleteSpaceOfLocallyCompactSpace', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  proper.{u_1, u_2, u_3} ğ•œ â†¥S
at declaration body
  fun {ğ•œ : Type u_1} {E : Type u_2} [NontriviallyNormedField ğ•œ] [CompleteSpace ğ•œ] [NormedAddCommGroup E]
      [NormedSpace ğ•œ E] [LocallyCompactSpace E] (S : Submodule ğ•œ E) â†¦
    Mathlib.Tactic.Nontriviality.subsingleton_or_nontrivial_elim (fun (a : Subsingleton E) â†¦ proper_of_compact)
      fun (a : Nontrivial E) â†¦
      let_fun this : ProperSpace ğ•œ := ProperSpace.of_locallyCompact_module ğ•œ E;
      let_fun this : FiniteDimensional ğ•œ E := of_locallyCompactSpace ğ•œ;
      proper ğ•œ â†¥S
error:  failed to synthesize
  ProperSpace E
use `set_option diagnostics true` to get diagnostic information
error:  rcases tactic failed: xâœ : ?m.539612 is not an inductive datatype
error:  failed to synthesize
  CompleteSpace E
use `set_option diagnostics true` to get diagnostic information
warning:  declaration uses 'sorry'
error:  failed to synthesize
  CompleteSpace E
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  CompleteSpace E
use `set_option diagnostics true` to get diagnostic information",theorem FiniteDimensional.proper [FiniteDimensional ğ•œ E] : ProperSpace E ,":= by
  have : ProperSpace ğ•œ := .of_locallyCompactSpace ğ•œ
  set e := ContinuousLinearEquiv.ofFinrankEq (@finrank_fin_fun ğ•œ _ _ (finrank ğ•œ E)).symm
  exact e.symm.antilipschitz.properSpace e.symm.continuous e.symm.surjective",refine ProperSpace.isProperSpace_of_finiteDimensional_proper ?_
Mathlib/Analysis/SpecialFunctions/Integrals.lean,intervalIntegral.intervalIntegrable_rpow',intervalIntegrable_rpow',b15c6ea0b0ad3ac6e15420c45ece165eca6725cc,":= by
  suffices âˆ€ c : â„, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : âˆ€ c : â„, 0 â‰¤ c â†’ IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : âˆ€ x âˆˆ Ioo 0 c, HasDerivAt (fun x : â„ => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 â‰  0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    Â· intro x hx; apply rpow_nonneg_of_nonneg hx.1.le
    Â· refine' (continuousOn_id.rpow_const _).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  Â· exact this c hc
  Â· rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * Ï€))
    rw [intervalIntegrable_iff] at m âŠ¢
    refine' m.congr_fun _ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 â‰¤ -c)] at hx
    rw [Pi.smul_apply]
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]","error:  no goals to be solved
warning:  `rpow_nonneg_of_nonneg` has been deprecated, use `Real.rpow_nonneg` instead","theorem intervalIntegrable_rpow' {r : â„} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ",":= by
  suffices âˆ€ c : â„, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : âˆ€ c : â„, 0 â‰¤ c â†’ IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : âˆ€ x âˆˆ Ioo 0 c, HasDerivAt (fun x : â„ => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 â‰  0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    Â· intro x hx; apply rpow_nonneg hx.1.le
    Â· refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  Â· exact this c hc
  Â· rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * Ï€))
    rw [intervalIntegrable_iff] at m âŠ¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 â‰¤ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]","have : IntervalIntegrable (fun x : â„ â†¦ x ^ r) volume (intervalIntegrable_rpow' _ _) :=
  IntervalIntegrable.intervalIntegrable_rpow' _ _"
Mathlib/Data/Set/Finite.lean,Set.eq_finite_iUnion_of_finite_subset_iUnion,eq_finite_iUnion_of_finite_subset_iUnion,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  let âŸ¨I, Ifin, hIâŸ© := finite_subset_iUnion tfin h
  âŸ¨I, Ifin, fun x => s x âˆ© t, fun i => tfin.subset (inter_subset_right _ _), fun i =>
    inter_subset_left _ _, by
    ext x
    rw [mem_iUnion]
    constructor
    Â· intro x_in
      rcases mem_iUnion.mp (hI x_in) with âŸ¨i, _, âŸ¨hi, rflâŸ©, HâŸ©
      exact âŸ¨âŸ¨i, hiâŸ©, âŸ¨H, x_inâŸ©âŸ©
    Â· rintro âŸ¨i, -, HâŸ©
      exact HâŸ©","error:  function expected at
  inter_subset_right ?m.126435
term has type
  ?m.126434 âˆˆ ?m.126433
error:  function expected at
  inter_subset_left ?m.126489
term has type
  ?m.126488 âˆˆ ?m.126486","theorem eq_finite_iUnion_of_finite_subset_iUnion {Î¹} {s : Î¹ â†’ Set Î±} {t : Set Î±} (tfin : t.Finite)
    (h : t âŠ† â‹ƒ i, s i) :
    âˆƒ I : Set Î¹,
      I.Finite âˆ§
        âˆƒ Ïƒ : { i | i âˆˆ I } â†’ Set Î±, (âˆ€ i, (Ïƒ i).Finite) âˆ§ (âˆ€ i, Ïƒ i âŠ† s i) âˆ§ t = â‹ƒ i, Ïƒ i ",":=
  let âŸ¨I, Ifin, hIâŸ© := finite_subset_iUnion tfin h
  âŸ¨I, Ifin, fun x => s x âˆ© t, fun i => tfin.subset inter_subset_right, fun i =>
    inter_subset_left, by
    ext x
    rw [mem_iUnion]
    constructor
    Â· intro x_in
      rcases mem_iUnion.mp (hI x_in) with âŸ¨i, _, âŸ¨hi, rflâŸ©, HâŸ©
      exact âŸ¨âŸ¨i, hiâŸ©, âŸ¨H, x_inâŸ©âŸ©
    Â· rintro âŸ¨i, -, HâŸ©
      exact HâŸ©","rcases exists_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion_finite_subset_iUnion
  Î¹ tfin tfin.theorem eq_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion
  tfin.theorem eq_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion
  tfin.theorem eq_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion
  tfin.theorem eq_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion
  tfin.theorem eq_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion
  tfin.theorem eq_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion
  tfin.theorem eq_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion
  tfin.theorem eq_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion
  tfin.theorem eq_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion
  tfin.theorem eq_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion
  tfin.theorem eq_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion
  tfin.theorem eq_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion
  tfin.theorem eq_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion
  tfin.theorem eq_finite_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUnion_subset_iUn"
Mathlib/MeasureTheory/Group/Action.lean,MeasureTheory.smulInvariantMeasure_tfae,smulInvariantMeasure_tfae,58de6a1c33e964db25c184d0d1809e6b5b414b50,":= by
  tfae_have : 1 â†” 2 := âŸ¨fun h => h.1, fun h => âŸ¨hâŸ©âŸ©
  tfae_have : 1 â†’ 6
  | h, c => (measurePreserving_smul c Î¼).map_eq
  tfae_have : 6 â†’ 7 := fun H c => âŸ¨measurable_const_smul c, H câŸ©
  tfae_have : 7 â†’ 4 := fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)
  tfae_have : 4 â†’ 5 := fun H c s => by
      rw [â† preimage_smul_inv]
      apply H
  tfae_have : 5 â†’ 3 := fun H c s _ => H c s
  tfae_have : 3 â†’ 2
  | H, c, s, hs => by
    rw [preimage_smul]
    exact H câ»Â¹ s hs
  tfae_finish",error:  unexpected token ':'; expected numeral,"theorem smulInvariantMeasure_tfae :
    List.TFAE
      [SMulInvariantMeasure G Î± Î¼,
        âˆ€ (c : G) (s), MeasurableSet s â†’ Î¼ ((c â€¢ Â·) â»Â¹' s) = Î¼ s,
        âˆ€ (c : G) (s), MeasurableSet s â†’ Î¼ (c â€¢ s) = Î¼ s,
        âˆ€ (c : G) (s), Î¼ ((c â€¢ Â·) â»Â¹' s) = Î¼ s,
        âˆ€ (c : G) (s), Î¼ (c â€¢ s) = Î¼ s,
        âˆ€ c : G, Measure.map (c â€¢ Â·) Î¼ = Î¼,
        âˆ€ c : G, MeasurePreserving (c â€¢ Â·) Î¼ Î¼] ",":= by
  tfae_have 1 â†” 2
  Â· exact âŸ¨fun h => h.1, fun h => âŸ¨hâŸ©âŸ©
  tfae_have 1 â†’ 6
  Â· intro h c
    exact (measurePreserving_smul c Î¼).map_eq
  tfae_have 6 â†’ 7
  Â· exact fun H c => âŸ¨measurable_const_smul c, H câŸ©
  tfae_have 7 â†’ 4
  Â· exact fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)
  tfae_have 4 â†’ 5
  Â· exact fun H c s => by
      rw [â† preimage_smul_inv]
      apply H
  tfae_have 5 â†’ 3
  Â· exact fun H c s _ => H c s
  tfae_have 3 â†’ 2
  Â· intro H c s hs
    rw [preimage_smul]
    exact H câ»Â¹ s hs
  tfae_finish",have smulInvariantMeasure_tfae smulInvariantMeasure_tfae smulInvariantMeasure_tfae
Mathlib/Topology/OmegaCompletePartialOrder.lean,notBelow_isOpen,notBelow_isOpen,4fafac3c913ccc407e26d1bc00d7f75cec309030,":= by
  have h : Monotone (notBelow y) := fun x z hle â†¦ mt hle.trans
  change Ï‰ScottContinuous fun x â†¦ x âˆˆ (notBelow y)
  rw [â† continuous'_iff_Ï‰ScottContinuous]
  refine âŸ¨h, fun c â†¦ eq_of_forall_ge_iff fun z â†¦ ?_âŸ©
  simp only [Ï‰Sup_le_iff, notBelow, mem_setOf_eq, le_Prop_eq, OrderHom.coe_mk, Chain.map_coe,
    Function.comp_apply, exists_imp, not_forall]","error:  unknown identifier 'Ï‰ScottContinuous'
error:  unknown identifier 'continuous'_iff_Ï‰ScottContinuous'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.30292
Î± : Type u_1
instâœ : OmegaCompletePartialOrder Î±
y : Scott Î±
h : Monotone (notBelow y)
âŠ¢ sorryAx (Sort ?u.30117) true
error:  invalid occurrence of universe level 'u_3' at 'scottContinuous_of_continuous', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  notBelow_isOpen.{u_2, u_3} (f y)
at declaration body
  fun {Î± : Type u_1} {Î² : Type u_2} [OmegaCompletePartialOrder Î±] [OmegaCompletePartialOrder Î²] (f : Scott Î± â†’ Scott Î²)
      (hf : _root_.Continuous f) â†¦
    let_fun h : Monotone f := fun (x y : Scott Î±) (h : x â‰¤ y) â†¦
      let_fun hf : IsUpperSet {x : Scott Î± | Â¬f x â‰¤ f y} :=
        IsOpen.isUpperSet Î± (IsOpen.preimage hf (notBelow_isOpen (f y)));
      Eq.mp
        (Eq.trans
          (Eq.trans
            (implies_congr (Eq.refl Â¬f x â‰¤ f y)
              (Eq.trans (congrArg Not (Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.5 (f y)))
                Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.6))
            Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.7)
          Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.8)
        (hf h);
    Exists.intro h fun (c : Chain (Scott Î±)) â†¦
      eq_of_forall_ge_iff fun (z : Scott Î²) â†¦
        Exists.casesOn (IsOpen.preimage hf (notBelow_isOpen z))
          fun (hf : Monotone fun (x : Î±) â†¦ x âˆˆ f â»Â¹' notBelow z)
            (hf' :
              OmegaCompletePartialOrder.Continuous { toFun := fun (x : Î±) â†¦ x âˆˆ f â»Â¹' notBelow z, monotone' := hf }) â†¦
          Eq.mpr (id (congrArg (fun (_a : Prop) â†¦ _a) (Eq.symm (propext not_iff_not))))
            (Eq.mpr
              (id
                (congr
                  (congrArg Iff
                    (Eq.trans
                      (Eq.mp
                        (congr
                          (congrArg (fun (x : Î± â†’o Prop) â†¦ Eq (x (Ï‰Sup c)))
                            ((fun {Î± : Type u_1} {Î² : Type} [Preorder Î±] [Preorder Î²] (toFun toFun_1 : Î± â†’ Î²)
                                  (e_toFun : toFun = toFun_1) â†¦
                                Eq.rec (motive := fun (toFun_2 : Î± â†’ Î²) (e_toFun : toFun = toFun_2) â†¦
                                  âˆ€ (monotone' : Monotone toFun),
                                    { toFun := toFun, monotone' := monotone' } =
                                      { toFun := toFun_2, monotone' := e_toFun â–¸ monotone' })
                                  (fun (monotone' : Monotone toFun) â†¦
                                    Eq.refl { toFun := toFun, monotone' := monotone' })
                                  e_toFun)
                              (fun (x : Î±) â†¦ x âˆˆ f â»Â¹' notBelow z) (fun (x : Î±) â†¦ Â¬f x â‰¤ z)
                              (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf))
                          (congrArg (fun (x : Î± â†’o Prop) â†¦ Ï‰Sup (c.map x))
                            ((fun {Î± : Type u_1} {Î² : Type} [Preorder Î±] [Preorder Î²] (toFun toFun_1 : Î± â†’ Î²)
                                  (e_toFun : toFun = toFun_1) â†¦
                                Eq.rec (motive := fun (toFun_2 : Î± â†’ Î²) (e_toFun : toFun = toFun_2) â†¦
                                  âˆ€ (monotone' : Monotone toFun),
                                    { toFun := toFun, monotone' := monotone' } =
                                      { toFun := toFun_2, monotone' := e_toFun â–¸ monotone' })
                                  (fun (monotone' : Monotone toFun) â†¦
                                    Eq.refl { toFun := toFun, monotone' := monotone' })
                                  e_toFun)
                              (fun (x : Î±) â†¦ x âˆˆ f â»Â¹' notBelow z) (fun (x : Î±) â†¦ Â¬f x â‰¤ z)
                              (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf)))
                        (hf' c))
                      (congrArg Exists
                        (funext fun (a : Prop) â†¦
                          congrArg (fun (x : Prop) â†¦ x âˆ§ a)
                            (Eq.trans Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.10
                              (congrArg Exists
                                (funext fun (y : â„•) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.11)))))))
                  (Eq.trans
                    (congrArg Not
                      (Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.9 (c.map { toFun := f, monotone' := h }) z))
                    Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.12)))
              (Or.casesOn
                (Decidable.iff_iff_and_or_not_and_not.mp
                  (Eq.to_iff
                    (Eq.mp
                      (congr
                        (congrArg (fun (x : Î± â†’o Prop) â†¦ Eq (x (Ï‰Sup c)))
                          ((fun {Î± : Type u_1} {Î² : Type} [Preorder Î±] [Preorder Î²] (toFun toFun_1 : Î± â†’ Î²)
                                (e_toFun : toFun = toFun_1) â†¦
                              Eq.rec (motive := fun (toFun_2 : Î± â†’ Î²) (e_toFun : toFun = toFun_2) â†¦
                                âˆ€ (monotone' : Monotone toFun),
                                  { toFun := toFun, monotone' := monotone' } =
                                    { toFun := toFun_2, monotone' := e_toFun â–¸ monotone' })
                                (fun (monotone' : Monotone toFun) â†¦ Eq.refl { toFun := toFun, monotone' := monotone' })
                                e_toFun)
                            (fun (x : Î±) â†¦ x âˆˆ f â»Â¹' notBelow z) (fun (x : Î±) â†¦ Â¬f x â‰¤ z)
                            (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf))
                        (congrArg (fun (x : Î± â†’o Prop) â†¦ Ï‰Sup (c.map x))
                          ((fun {Î± : Type u_1} {Î² : Type} [Preorder Î±] [Preorder Î²] (toFun toFun_1 : Î± â†’ Î²)
                                (e_toFun : toFun = toFun_1) â†¦
                              Eq.rec (motive := fun (toFun_2 : Î± â†’ Î²) (e_toFun : toFun = toFun_2) â†¦
                                âˆ€ (monotone' : Monotone toFun),
                                  { toFun := toFun, monotone' := monotone' } =
                                    { toFun := toFun_2, monotone' := e_toFun â–¸ monotone' })
                                (fun (monotone' : Monotone toFun) â†¦ Eq.refl { toFun := toFun, monotone' := monotone' })
                                e_toFun)
                            (fun (x : Î±) â†¦ x âˆˆ f â»Â¹' notBelow z) (fun (x : Î±) â†¦ Â¬f x â‰¤ z)
                            (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf)))
                      (hf' c))))
                (fun
                    (h :
                      Â¬f (Ï‰Sup c) â‰¤ z âˆ§
                        Ï‰Sup
                          (c.map
                            { toFun := fun (x : Î±) â†¦ Â¬f x â‰¤ z,
                              monotone' :=
                                (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) â–¸ hf })) â†¦
                  And.casesOn h
                    fun (left : Â¬f (Ï‰Sup c) â‰¤ z)
                      (right :
                        Ï‰Sup
                          (c.map
                            { toFun := fun (x : Î±) â†¦ Â¬f x â‰¤ z,
                              monotone' :=
                                (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) â–¸ hf })) â†¦
                    {
                      mp := fun (a : âˆƒ (a : Prop), (âˆƒ (y : â„•), Â¬f (c y) â‰¤ z â†” a) âˆ§ a) â†¦
                        Exists.casesOn a fun (w : Prop) (h : (âˆƒ (y : â„•), Â¬f (c y) â‰¤ z â†” w) âˆ§ w) â†¦
                          And.casesOn h fun (left : âˆƒ (y : â„•), Â¬f (c y) â‰¤ z â†” w) (right : w) â†¦
                            Exists.casesOn left fun (w_1 : â„•) (h : Â¬f (c w_1) â‰¤ z â†” w) â†¦
                              Or.casesOn (Decidable.iff_iff_and_or_not_and_not.mp h)
                                (fun (h : Â¬f (c w_1) â‰¤ z âˆ§ w) â†¦
                                  And.casesOn h fun (left : Â¬f (c w_1) â‰¤ z) (right : w) â†¦ Exists.intro w_1 left)
                                fun (h : Â¬Â¬f (c w_1) â‰¤ z âˆ§ Â¬w) â†¦
                                And.casesOn h fun (left : Â¬Â¬f (c w_1) â‰¤ z) (right_1 : Â¬w) â†¦ absurd right right_1,
                      mpr := fun (a : âˆƒ (x : â„•), Â¬f (c x) â‰¤ z) â†¦
                        Exists.casesOn a fun (w : â„•) (h : Â¬f (c w) â‰¤ z) â†¦
                          Exists.intro (Â¬f (c w) â‰¤ z) âŸ¨Exists.intro w Iff.rfl, hâŸ© })
                fun
                  (h :
                    Â¬Â¬f (Ï‰Sup c) â‰¤ z âˆ§
                      Â¬Ï‰Sup
                          (c.map
                            { toFun := fun (x : Î±) â†¦ Â¬f x â‰¤ z,
                              monotone' :=
                                (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) â–¸ hf })) â†¦
                And.casesOn h
                  fun (left : Â¬Â¬f (Ï‰Sup c) â‰¤ z)
                    (right :
                      Â¬Ï‰Sup
                          (c.map
                            { toFun := fun (x : Î±) â†¦ Â¬f x â‰¤ z,
                              monotone' :=
                                (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) â–¸ hf })) â†¦
                  {
                    mp := fun (a : âˆƒ (a : Prop), (âˆƒ (y : â„•), Â¬f (c y) â‰¤ z â†” a) âˆ§ a) â†¦
                      Exists.casesOn a fun (w : Prop) (h : (âˆƒ (y : â„•), Â¬f (c y) â‰¤ z â†” w) âˆ§ w) â†¦
                        And.casesOn h fun (left : âˆƒ (y : â„•), Â¬f (c y) â‰¤ z â†” w) (right : w) â†¦
                          Exists.casesOn left fun (w_1 : â„•) (h : Â¬f (c w_1) â‰¤ z â†” w) â†¦
                            Or.casesOn (Decidable.iff_iff_and_or_not_and_not.mp h)
                              (fun (h : Â¬f (c w_1) â‰¤ z âˆ§ w) â†¦
                                And.casesOn h fun (left : Â¬f (c w_1) â‰¤ z) (right : w) â†¦ Exists.intro w_1 left)
                              fun (h : Â¬Â¬f (c w_1) â‰¤ z âˆ§ Â¬w) â†¦
                              And.casesOn h fun (left : Â¬Â¬f (c w_1) â‰¤ z) (right_1 : Â¬w) â†¦ absurd right right_1,
                    mpr := fun (a : âˆƒ (x : â„•), Â¬f (c x) â‰¤ z) â†¦
                      Exists.casesOn a fun (w : â„•) (h : Â¬f (c w) â‰¤ z) â†¦
                        Exists.intro (Â¬f (c w) â‰¤ z) âŸ¨Exists.intro w Iff.rfl, hâŸ© }))",theorem notBelow_isOpen : IsOpen (notBelow y) ,":= by
  have h : Monotone (notBelow y) := fun x z hle â†¦ mt hle.trans
  refine âŸ¨h, fun c â†¦ eq_of_forall_ge_iff fun z â†¦ ?_âŸ©
  simp only [Ï‰Sup_le_iff, notBelow, mem_setOf_eq, le_Prop_eq, OrderHom.coe_mk, Chain.map_coe,
    Function.comp_apply, exists_imp, not_forall]",have notBelow_isOpen : IsOpen (notBelow y) := isOpen_notBelow_of_isOpen notBelow_isOpen
Mathlib/Data/QPF/Univariate/Basic.lean,QPF.Cofix.bisim_rel,Cofix.bisim_rel,ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  let r' (x y) := x = y âˆ¨ r x y
  intro x y rxy
  apply Cofix.bisim_aux r'
  Â· intro x
    left
    rfl
  Â· intro x y r'xy
    cases' r'xy with r'xy r'xy
    Â· rw [r'xy]
    have : âˆ€ x y, r x y â†’ r' x y := fun x y h => Or.inr h
    rw [â† Quot.factor_mk_eq _ _ this]
    dsimp [r']
    rw [@comp_map _ _ q _ _ _ (Quot.mk r), @comp_map _ _ q _ _ _ (Quot.mk r)]
    rw [h _ _ r'xy]
  right; exact rxy","error:  application type mismatch
  @comp_map ?m.16732 ?m.16733 q
argument
  q
has type
  QPF F : Type (u + 1)
but is expected to have type
  Type ?u.16731 : Type (?u.16731 + 1)","theorem Cofix.bisim_rel (r : Cofix F â†’ Cofix F â†’ Prop)
    (h : âˆ€ x y, r x y â†’ Quot.mk r <$> Cofix.dest x = Quot.mk r <$> Cofix.dest y) :
    âˆ€ x y, r x y â†’ x = y ",":= by
  let r' (x y) := x = y âˆ¨ r x y
  intro x y rxy
  apply Cofix.bisim_aux r'
  Â· intro x
    left
    rfl
  Â· intro x y r'xy
    cases' r'xy with r'xy r'xy
    Â· rw [r'xy]
    have : âˆ€ x y, r x y â†’ r' x y := fun x y h => Or.inr h
    rw [â† Quot.factor_mk_eq _ _ this]
    dsimp [r']
    rw [@comp_map _ q _ _ _ (Quot.mk r), @comp_map _ q _ _ _ (Quot.mk r)]
    rw [h _ _ r'xy]
  right; exact rxy","induction' h : âˆ€ x y, r x y â†’ Quot.mk r <$> Cofix.dest x y â†’ Quot.mk r <$> Cofix.dest y â†’
  Quot.mk r <$> Cofix.dest x y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest x y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest x y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest x y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’ Quot.mk r <$> Cofix.dest y â†’
    Quot.mk r <$> Cofix.dest y "
Mathlib/NumberTheory/LegendreSymbol/Basic.lean,legendreSym.eq_one_of_sq_sub_mul_sq_eq_zero',eq_one_of_sq_sub_mul_sq_eq_zero',8e31b5ac6bed8ba535a30f3442252684d2f151c1,":= by
  haveI hy : y â‰  0 := by
    rintro rfl
    rw [zero_pow' 2 (by norm_num), mul_zero, sub_zero, pow_eq_zero_iff
        (by norm_num : 0 < 2)] at hxy
    exact hx hxy
  exact eq_one_of_sq_sub_mul_sq_eq_zero ha hy hxy","error:  unknown identifier 'zero_pow''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.39709
p : â„•
instâœ : Fact (Nat.Prime p)
a : â„¤
ha : â†‘a â‰  0
x : ZMod p
hx : x â‰  0
hxy : x ^ 2 - â†‘a * 0 ^ 2 = 0
âŠ¢ False","theorem eq_one_of_sq_sub_mul_sq_eq_zero' {p : â„•} [Fact p.Prime] {a : â„¤} (ha : (a : ZMod p) â‰  0)
    {x y : ZMod p} (hx : x â‰  0) (hxy : x ^ 2 - a * y ^ 2 = 0) : legendreSym p a = 1 ",":= by
  haveI hy : y â‰  0 := by
    rintro rfl
    rw [zero_pow two_ne_zero, mul_zero, sub_zero, sq_eq_zero_iff] at hxy
    exact hx hxy
  exact eq_one_of_sq_sub_mul_sq_eq_zero ha hy hxy",rw [legendreSym.eq_zero_iff]
Mathlib/Analysis/Convex/Slope.lean,StrictConvexOn.slope_strict_mono_adjacent,StrictConvexOn.slope_strict_mono_adjacent,9e34a191034458a56331f976ff7400a26407c888,":= by
  have hxz := hxy.trans hyz
  have hxz' := hxz.ne
  rw [â† sub_pos] at hxy hxz hyz
  suffices f y / (y - x) + f y / (z - y) < f x / (y - x) + f z / (z - y) by
    ring_nf at this âŠ¢
    linarith
  set a := (z - y) / (z - x)
  set b := (y - x) / (z - x)
  have hy : a â€¢ x + b â€¢ z = y := by
    field_simp
    rw [div_eq_iff] <;> [ring; linarith]
  have key :=
    hf.2 hx hz hxz' (div_pos hyz hxz) (div_pos hxy hxz)
      (show a + b = 1 by
        field_simp
        rw [div_eq_iff] <;> [ring; linarith])
  rw [hy] at key
  replace key := mul_lt_mul_of_pos_left key hxz
  field_simp [hxy.ne', hyz.ne', hxz.ne', mul_comm (z - x) _] at key âŠ¢
  rw [div_lt_div_right]
  Â· linarith
  Â· nlinarith","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.48812 / ?m.48813 = ?m.48814
ğ•œ : Type u_1
instâœ : LinearOrderedField ğ•œ
s : Set ğ•œ
f : ğ•œ â†’ ğ•œ
hf : StrictConvexOn ğ•œ s f
x y z : ğ•œ
hx : x âˆˆ s
hz : z âˆˆ s
hxy : 0 < y - x
hyz : 0 < z - y
hxz : 0 < z - x
hxz' : x â‰  z
a : ğ•œ := (z - y) / (z - x)
b : ğ•œ := (y - x) / (z - x)
âŠ¢ a * x + b * z = y
error:  simp made no progress","theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn ğ•œ s f) {x y z : ğ•œ}
    (hx : x âˆˆ s) (hz : z âˆˆ s) (hxy : x < y) (hyz : y < z) :
    (f y - f x) / (y - x) < (f z - f y) / (z - y) ",":= by
  have hxz := hxy.trans hyz
  have hxz' := hxz.ne
  rw [â† sub_pos] at hxy hxz hyz
  suffices f y / (y - x) + f y / (z - y) < f x / (y - x) + f z / (z - y) by
    ring_nf at this âŠ¢
    linarith
  set a := (z - y) / (z - x)
  set b := (y - x) / (z - x)
  have hy : a â€¢ x + b â€¢ z = y := by field_simp [a, b]; ring
  have key :=
    hf.2 hx hz hxz' (div_pos hyz hxz) (div_pos hxy hxz)
      (show a + b = 1 by field_simp [a, b])
  rw [hy] at key
  replace key := mul_lt_mul_of_pos_left key hxz
  field_simp [mul_comm (z - x) _] at key âŠ¢
  rw [div_lt_div_right]
  Â· linarith
  Â· nlinarith",simp only [StrictConvexOn.slope_strict_mono_adjacent]
Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean,CategoryTheory.Equalizer.Presieve.Arrows.SecondObj.ext,SecondObj.ext,f76dc92a63457a8b36463cee1fe33a048c0ba0ce,":= by
  apply Limits.Types.limit_ext
  rintro âŸ¨iâŸ©
  exact h i","error:  application type mismatch
  h i
argument
  i
has type
  (Y : C) Ã— (Z : C) Ã— (_ : Z âŸ¶ Y) Ã— { f' // S.arrows f' } : Type (max u v u)
but is expected to have type
  C : Type u","lemma SecondObj.ext (zâ‚ zâ‚‚ : SecondObj P S) (h : âˆ€ (Y Z : C) (g : Z âŸ¶ Y) (f : Y âŸ¶ X)
    (hf : S.arrows f), (Pi.Ï€ _ âŸ¨Y, Z, g, f, hfâŸ© : SecondObj P S âŸ¶ _) zâ‚ =
      (Pi.Ï€ _ âŸ¨Y, Z, g, f, hfâŸ© : SecondObj P S âŸ¶ _) zâ‚‚) : zâ‚ = zâ‚‚ ",":= by
  apply Limits.Types.limit_ext
  rintro âŸ¨âŸ¨Y, Z, g, f, hfâŸ©âŸ©
  apply h",apply SecondObj.ext
Mathlib/Computability/PartrecCode.lean,Nat.Partrec.Code.evaln_complete,evaln_complete,2d8928f07c222f171d2f9371935aa5b8359f9d44,":= by
  refine âŸ¨fun h => ?_, fun âŸ¨k, hâŸ© => evaln_sound hâŸ©
  rsuffices âŸ¨k, hâŸ© : âˆƒ k, x âˆˆ evaln (k + 1) c n
  Â· exact âŸ¨k + 1, hâŸ©
  induction c generalizing n x with simp [eval, evaln, pure, PFun.pure, Seq.seq, Bind.bind] at h âŠ¢
  | pair cf cg hf hg =>
    rcases h with âŸ¨x, hx, y, hy, rflâŸ©
    rcases hf hx with âŸ¨kâ‚, hkâ‚âŸ©; rcases hg hy with âŸ¨kâ‚‚, hkâ‚‚âŸ©
    refine' âŸ¨max kâ‚ kâ‚‚, _âŸ©
    refine'
      âŸ¨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚, rflâŸ©
  | comp cf cg hf hg =>
    rcases h with âŸ¨y, hy, hxâŸ©
    rcases hg hy with âŸ¨kâ‚, hkâ‚âŸ©; rcases hf hx with âŸ¨kâ‚‚, hkâ‚‚âŸ©
    refine' âŸ¨max kâ‚ kâ‚‚, _âŸ©
    exact
      âŸ¨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hkâ‚,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚âŸ©
  | prec cf cg hf hg =>
    revert h
    generalize n.unpair.1 = nâ‚; generalize n.unpair.2 = nâ‚‚
    induction' nâ‚‚ with m IH generalizing x n <;> simp
    Â· intro h
      rcases hf h with âŸ¨k, hkâŸ©
      exact âŸ¨_, le_max_left _ _, evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâŸ©
    Â· intro y hy hx
      rcases IH hy with âŸ¨kâ‚, nkâ‚, hkâ‚âŸ©
      rcases hg hx with âŸ¨kâ‚‚, hkâ‚‚âŸ©
      refine'
        âŸ¨(max kâ‚ kâ‚‚).succ,
          Nat.le_succ_of_le <| le_max_of_le_left <|
            le_trans (le_max_left _ (Nat.pair nâ‚ m)) nkâ‚, y,
          evaln_mono (Nat.succ_le_succ <| le_max_left _ _) _,
          evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_right _ _) hkâ‚‚âŸ©
      simp only [evaln.eq_8, bind, unpaired, unpair_pair, Option.mem_def, Option.bind_eq_some,
        Option.guard_eq_some', exists_and_left, exists_const]
      exact âŸ¨le_trans (le_max_right _ _) nkâ‚, hkâ‚âŸ©
  | rfind' cf hf =>
    rcases h with âŸ¨y, âŸ¨hyâ‚, hyâ‚‚âŸ©, rflâŸ©
    suffices âˆƒ k, y + n.unpair.2 âˆˆ evaln (k + 1) (rfind' cf) (Nat.pair n.unpair.1 n.unpair.2) by
      simpa [evaln, Bind.bind]
    revert hyâ‚ hyâ‚‚
    generalize n.unpair.2 = m
    intro hyâ‚ hyâ‚‚
    induction' y with y IH generalizing m <;> simp [evaln, Bind.bind]
    Â· simp at hyâ‚
      rcases hf hyâ‚ with âŸ¨k, hkâŸ©
      exact âŸ¨_, Nat.le_of_lt_succ <| evaln_bound hk, _, hk, by simpâŸ©
    Â· rcases hyâ‚‚ (Nat.succ_pos _) with âŸ¨a, ha, a0âŸ©
      rcases hf ha with âŸ¨kâ‚, hkâ‚âŸ©
      rcases IH m.succ (by simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using hyâ‚)
          fun {i} hi => by
          simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using
            hyâ‚‚ (Nat.succ_lt_succ hi) with
        âŸ¨kâ‚‚, hkâ‚‚âŸ©
      use (max kâ‚ kâ‚‚).succ
      rw [zero_add] at hkâ‚
      use Nat.le_succ_of_le <| le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚
      use a
      use evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_left _ _) hkâ‚
      simpa [Nat.succ_eq_add_one, a0, -max_eq_left, -max_eq_right, add_comm, add_left_comm] using
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚
  | _ => exact âŸ¨âŸ¨_, le_rflâŸ©, h.symmâŸ©","error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #6 provided
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #4 provided
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #2 provided
error:  tactic 'cases' failed, nested error:
dependent elimination failed, failed to solve equation
  some y =
    match guard (?m.364435 â‰¤ kâ‚), fun a â†¦
      Nat.rec (evaln (kâ‚ + 1) cf nâ‚)
        (fun n n_ih â†¦
          (evaln kâ‚ (cf.prec cg) (Nat.pair nâ‚ n)).bind fun i â†¦ evaln (kâ‚ + 1) cg (Nat.pair nâ‚ (Nat.pair n i)))
        m with
    | Option.none, x => Option.none
    | some a, f => f a
at case Eq.refl
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #4 provided
error:  type mismatch
  le_succ_of_le (le_max_of_le_left (le_of_lt_succ (evaln_bound hkâ‚)))
has type
  Nat.pair (unpair n).1 m â‰¤ (max kâ‚ ?m.381477).succ : Prop
but is expected to have type
  ((guard (Nat.pair (unpair n).1 m â‰¤ (max kâ‚ kâ‚‚).succ)).bind fun a â†¦
      (evaln ((max kâ‚ kâ‚‚).succ + 1) cf (Nat.pair (unpair n).1 m)).bind fun a â†¦
        if a = 0 then some m else evaln (max kâ‚ kâ‚‚).succ cf.rfind' (Nat.pair (unpair n).1 (m + 1))) =
    some (y + 1 + m) : Prop
error:  no goals to be solved
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type with only one constructor 
  â„•
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type with only one constructor 
  â„•
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type with only one constructor 
  â„•
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type with only one constructor 
  â„•","theorem evaln_complete {c n x} : x âˆˆ eval c n â†” âˆƒ k, x âˆˆ evaln k c n ",":= by
  refine âŸ¨fun h => ?_, fun âŸ¨k, hâŸ© => evaln_sound hâŸ©
  rsuffices âŸ¨k, hâŸ© : âˆƒ k, x âˆˆ evaln (k + 1) c n
  Â· exact âŸ¨k + 1, hâŸ©
  induction c generalizing n x with
      simp [eval, evaln, pure, PFun.pure, Seq.seq, Option.bind_eq_some] at h âŠ¢
  | pair cf cg hf hg =>
    rcases h with âŸ¨x, hx, y, hy, rflâŸ©
    rcases hf hx with âŸ¨kâ‚, hkâ‚âŸ©; rcases hg hy with âŸ¨kâ‚‚, hkâ‚‚âŸ©
    refine âŸ¨max kâ‚ kâ‚‚, ?_âŸ©
    refine
      âŸ¨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚, rflâŸ©
  | comp cf cg hf hg =>
    rcases h with âŸ¨y, hy, hxâŸ©
    rcases hg hy with âŸ¨kâ‚, hkâ‚âŸ©; rcases hf hx with âŸ¨kâ‚‚, hkâ‚‚âŸ©
    refine âŸ¨max kâ‚ kâ‚‚, ?_âŸ©
    exact
      âŸ¨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hkâ‚,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚âŸ©
  | prec cf cg hf hg =>
    revert h
    generalize n.unpair.1 = nâ‚; generalize n.unpair.2 = nâ‚‚
    induction' nâ‚‚ with m IH generalizing x n <;> simp [Option.bind_eq_some]
    Â· intro h
      rcases hf h with âŸ¨k, hkâŸ©
      exact âŸ¨_, le_max_left _ _, evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâŸ©
    Â· intro y hy hx
      rcases IH hy with âŸ¨kâ‚, nkâ‚, hkâ‚âŸ©
      rcases hg hx with âŸ¨kâ‚‚, hkâ‚‚âŸ©
      refine
        âŸ¨(max kâ‚ kâ‚‚).succ,
          Nat.le_succ_of_le <| le_max_of_le_left <|
            le_trans (le_max_left _ (Nat.pair nâ‚ m)) nkâ‚, y,
          evaln_mono (Nat.succ_le_succ <| le_max_left _ _) ?_,
          evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_right _ _) hkâ‚‚âŸ©
      simp only [evaln.eq_8, bind, unpaired, unpair_pair, Option.mem_def, Option.bind_eq_some,
        Option.guard_eq_some', exists_and_left, exists_const]
      exact âŸ¨le_trans (le_max_right _ _) nkâ‚, hkâ‚âŸ©
  | rfind' cf hf =>
    rcases h with âŸ¨y, âŸ¨hyâ‚, hyâ‚‚âŸ©, rflâŸ©
    suffices âˆƒ k, y + n.unpair.2 âˆˆ evaln (k + 1) (rfind' cf) (Nat.pair n.unpair.1 n.unpair.2) by
      simpa [evaln, Option.bind_eq_some]
    revert hyâ‚ hyâ‚‚
    generalize n.unpair.2 = m
    intro hyâ‚ hyâ‚‚
    induction' y with y IH generalizing m <;> simp [evaln, Option.bind_eq_some]
    Â· simp at hyâ‚
      rcases hf hyâ‚ with âŸ¨k, hkâŸ©
      exact âŸ¨_, Nat.le_of_lt_succ <| evaln_bound hk, _, hk, by simpâŸ©
    Â· rcases hyâ‚‚ (Nat.succ_pos _) with âŸ¨a, ha, a0âŸ©
      rcases hf ha with âŸ¨kâ‚, hkâ‚âŸ©
      rcases IH m.succ (by simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using hyâ‚)
          fun {i} hi => by
          simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using
            hyâ‚‚ (Nat.succ_lt_succ hi) with
        âŸ¨kâ‚‚, hkâ‚‚âŸ©
      use (max kâ‚ kâ‚‚).succ
      rw [zero_add] at hkâ‚
      use Nat.le_succ_of_le <| le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚
      use a
      use evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_left _ _) hkâ‚
      simpa [Nat.succ_eq_add_one, a0, -max_eq_left, -max_eq_right, add_comm, add_left_comm] using
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚
  | _ => exact âŸ¨âŸ¨_, le_rflâŸ©, h.symmâŸ©","simp only [mem_evaln, evaln_complete, evaln_complete, evaln_complete]"
Mathlib/LinearAlgebra/ExteriorAlgebra/Grading.lean,ExteriorAlgebra.GradedAlgebra.Î¹_sq_zero,GradedAlgebra.Î¹_sq_zero,5e927760039770855bbf0fe0d5195e10790c094b,":= by
  rw [GradedAlgebra.Î¹_apply, DirectSum.of_mul_of]
  refine Dfinsupp.single_eq_zero.mpr (Subtype.ext <| ExteriorAlgebra.Î¹_sq_zero _)",error:  unknown identifier 'Dfinsupp.single_eq_zero.mpr',theorem GradedAlgebra.Î¹_sq_zero (m : M) : GradedAlgebra.Î¹ R M m * GradedAlgebra.Î¹ R M m = 0 ,":= by
  rw [GradedAlgebra.Î¹_apply, DirectSum.of_mul_of]
  exact DFinsupp.single_eq_zero.mpr (Subtype.ext <| ExteriorAlgebra.Î¹_sq_zero _)",exact GradedAlgebra.Î¹_sq_zero m
Mathlib/Topology/Algebra/Order/Compact.lean,ContinuousOn.exists_isMinOn',ContinuousOn.exists_isMinOn',596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases (hasBasis_cocompact.inf_principal _).eventually_iff.1 hc with âŸ¨K, hK, hKfâŸ©
  have hsub : insert xâ‚€ (K âˆ© s) âŠ† s := insert_subset_iff.2 âŸ¨hâ‚€, inter_subset_right _ _âŸ©
  obtain âŸ¨x, hx, hxfâŸ© : âˆƒ x âˆˆ insert xâ‚€ (K âˆ© s), âˆ€ y âˆˆ insert xâ‚€ (K âˆ© s), f x â‰¤ f y :=
    ((hK.inter_right hsc).insert xâ‚€).exists_isMinOn (insert_nonempty _ _) (hf.mono hsub)
  refine âŸ¨x, hsub hx, fun y hy => ?_âŸ©
  by_cases hyK : y âˆˆ K
  exacts [hxf _ (Or.inr âŸ¨hyK, hyâŸ©), (hxf _ (Or.inl rfl)).trans (hKf âŸ¨hyK, hyâŸ©)]","error:  function expected at
  inter_subset_right ?m.55165
term has type
  ?m.55164 âˆˆ ?m.55163","theorem ContinuousOn.exists_isMinOn' [ClosedIicTopology Î±] {s : Set Î²} {f : Î² â†’ Î±}
    (hf : ContinuousOn f s) (hsc : IsClosed s) {xâ‚€ : Î²} (hâ‚€ : xâ‚€ âˆˆ s)
    (hc : âˆ€á¶  x in cocompact Î² âŠ“ ğ“Ÿ s, f xâ‚€ â‰¤ f x) : âˆƒ x âˆˆ s, IsMinOn f s x ",":= by
  rcases (hasBasis_cocompact.inf_principal _).eventually_iff.1 hc with âŸ¨K, hK, hKfâŸ©
  have hsub : insert xâ‚€ (K âˆ© s) âŠ† s := insert_subset_iff.2 âŸ¨hâ‚€, inter_subset_rightâŸ©
  obtain âŸ¨x, hx, hxfâŸ© : âˆƒ x âˆˆ insert xâ‚€ (K âˆ© s), âˆ€ y âˆˆ insert xâ‚€ (K âˆ© s), f x â‰¤ f y :=
    ((hK.inter_right hsc).insert xâ‚€).exists_isMinOn (insert_nonempty _ _) (hf.mono hsub)
  refine âŸ¨x, hsub hx, fun y hy => ?_âŸ©
  by_cases hyK : y âˆˆ K
  exacts [hxf _ (Or.inr âŸ¨hyK, hyâŸ©), (hxf _ (Or.inl rfl)).trans (hKf âŸ¨hyK, hyâŸ©)]","have : âˆ€á¶  x in cocompact Î² âŠ“ ğ“Ÿ s, f xâ‚€ â‰¤ f xâ‚€ := hc.mono inf_le_left"
Mathlib/Analysis/BoxIntegral/Integrability.lean,BoxIntegral.HasIntegral.of_aeEq_zero,HasIntegral.of_aeEq_zero,1b93076c86e6da5d0a25d3465e84d13bd9ccfcc8,":= by
  refine' hasIntegral_iff.2 fun Îµ Îµ0 => _
  lift Îµ to â„â‰¥0 using Îµ0.lt.le; rw [gt_iff_lt, NNReal.coe_pos] at Îµ0
  rcases NNReal.exists_pos_sum_of_countable Îµ0.ne' â„• with âŸ¨Î´, Î´0, c, hÎ´c, hcÎµâŸ©
  haveI := Fact.mk (I.measure_coe_lt_top Î¼)
  change Î¼.restrict I {x | f x â‰  0} = 0 at hf
  set N : (Î¹ â†’ â„) â†’ â„• := fun x => âŒˆâ€–f xâ€–âŒ‰â‚Š
  have N0 : âˆ€ {x}, N x = 0 â†” f x = 0 := by simp
  have : âˆ€ n, âˆƒ U, N â»Â¹' {n} âŠ† U âˆ§ IsOpen U âˆ§ Î¼.restrict I U < Î´ n / n := fun n â†¦ by
    refine (N â»Â¹' {n}).exists_isOpen_lt_of_lt _ ?_
    cases' n with n
    Â· simpa [ENNReal.div_zero (ENNReal.coe_pos.2 (Î´0 _)).ne'] using measure_lt_top (Î¼.restrict I) _
    Â· refine' (measure_mono_null _ hf).le.trans_lt _
      Â· exact fun x hxN hxf => n.succ_ne_zero ((Eq.symm hxN).trans <| N0.2 hxf)
      Â· simp [(Î´0 _).ne']
  choose U hNU hUo hÎ¼U using this
  have : âˆ€ x, âˆƒ r : Ioi (0 : â„), closedBall x r âŠ† U (N x) := fun x => by
    obtain âŸ¨r, hrâ‚€, hrâŸ© := nhds_basis_closedBall.mem_iff.1 ((hUo _).mem_nhds (hNU _ rfl))
    exact âŸ¨âŸ¨r, hrâ‚€âŸ©, hrâŸ©
  choose r hrU using this
  refine' âŸ¨fun _ => r, fun c => l.rCond_of_bRiemann_eq_false hl, fun c Ï€ hÏ€ _ => _âŸ©
  rw [dist_eq_norm, sub_zero, â† integralSum_fiberwise fun J => N (Ï€.tag J)]
  refine' le_trans _ (NNReal.coe_lt_coe.2 hcÎµ).le
  refine' (norm_sum_le_of_le _ _).trans
    (sum_le_hasSum _ (fun n _ => (Î´ n).2) (NNReal.hasSum_coe.2 hÎ´c))
  rintro n -
  dsimp [integralSum]
  have : âˆ€ J âˆˆ Ï€.filter fun J => N (Ï€.tag J) = n,
      â€–(Î¼ â†‘J).toReal â€¢ f (Ï€.tag J)â€– â‰¤ (Î¼ J).toReal * n := fun J hJ â†¦ by
    rw [TaggedPrepartition.mem_filter] at hJ
    rw [norm_smul, Real.norm_eq_abs, abs_of_nonneg ENNReal.toReal_nonneg]
    gcongr
    exact hJ.2 â–¸ Nat.le_ceil _
  refine' (norm_sum_le_of_le _ this).trans _; clear this
  rw [â† sum_mul, â† Prepartition.measure_iUnion_toReal]
  generalize hm : Î¼ (Ï€.filter fun J => N (Ï€.tag J) = n).iUnion = m
  have : m < Î´ n / n := by
    simp only [Measure.restrict_apply (hUo _).measurableSet] at hÎ¼U
    refine' hm â–¸ (measure_mono _).trans_lt (hÎ¼U _)
    simp only [Set.subset_def, TaggedPrepartition.mem_iUnion, TaggedPrepartition.mem_filter]
    rintro x âŸ¨J, âŸ¨hJ, rflâŸ©, hxâŸ©
    exact âŸ¨hrU _ (hÏ€.1 _ hJ (Box.coe_subset_Icc hx)), Ï€.le_of_mem' J hJ hxâŸ©
  lift m to â„â‰¥0 using ne_top_of_lt this
  rw [ENNReal.coe_toReal, â† NNReal.coe_nat_cast, â† NNReal.coe_mul, NNReal.coe_le_coe, â†
    ENNReal.coe_le_coe, ENNReal.coe_mul, ENNReal.coe_nat, mul_comm]
  exact (mul_le_mul_left' this.le _).trans ENNReal.mul_div_le","error:  simp made no progress
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (â†‘?r).toReal
case intro.intro.intro.intro.intro.intro
Î¹ : Type u
E : Type v
instâœÂ³ : Fintype Î¹
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
l : IntegrationParams
I : Box Î¹
f : (Î¹ â†’ â„) â†’ E
Î¼ : Measure (Î¹ â†’ â„)
instâœ : IsLocallyFiniteMeasure Î¼
hl : l.bRiemann = false
Îµ : â„â‰¥0
Îµ0 : 0 < Îµ
Î´ : â„• â†’ â„â‰¥0
Î´0 : âˆ€ (i : â„•), 0 < Î´ i
câœ : â„â‰¥0
hÎ´c : HasSum Î´ câœ
hcÎµ : câœ < Îµ
thisâœ : Fact (Î¼ â†‘I < âŠ¤)
hf : (Î¼.restrict â†‘I) {x | f x â‰  0} = 0
N : (Î¹ â†’ â„) â†’ â„• := fun x â†¦ âŒˆâ€–f xâ€–âŒ‰â‚Š
N0 : âˆ€ {x : Î¹ â†’ â„}, N x = 0 â†” f x = 0
U : â„• â†’ Set (Î¹ â†’ â„)
hNU : âˆ€ (n : â„•), N â»Â¹' {n} âŠ† U n
hUo : âˆ€ (n : â„•), IsOpen (U n)
hÎ¼U : âˆ€ (n : â„•), (Î¼.restrict â†‘I) (U n) < â†‘(Î´ n) / â†‘n
r : (Î¹ â†’ â„) â†’ â†‘(Set.Ioi 0)
hrU : âˆ€ (x : Î¹ â†’ â„), closedBall x â†‘(r x) âŠ† U (N x)
c : â„â‰¥0
Ï€ : TaggedPrepartition I
hÏ€ : l.MemBaseSet I c ((fun x â†¦ r) c) Ï€
xâœ : Ï€.IsPartition
n : â„•
m : â„â‰¥0
hm : Î¼ (Ï€.filter fun J â†¦ N (Ï€.tag J) = n).iUnion = â†‘m
this : â†‘m < â†‘(Î´ n) / â†‘n
âŠ¢ (Î¼ (Ï€.filter fun J â†¦ N (Ï€.tag J) = n).iUnion).toReal * â†‘n â‰¤ â†‘(Î´ n)","theorem HasIntegral.of_aeEq_zero {l : IntegrationParams} {I : Box Î¹} {f : (Î¹ â†’ â„) â†’ E}
    {Î¼ : Measure (Î¹ â†’ â„)} [IsLocallyFiniteMeasure Î¼] (hf : f =áµ[Î¼.restrict I] 0)
    (hl : l.bRiemann = false) : HasIntegral.{u, v, v} I l f Î¼.toBoxAdditive.toSMul 0 ",":= by
  refine hasIntegral_iff.2 fun Îµ Îµ0 => ?_
  lift Îµ to â„â‰¥0 using Îµ0.lt.le; rw [gt_iff_lt, NNReal.coe_pos] at Îµ0
  rcases NNReal.exists_pos_sum_of_countable Îµ0.ne' â„• with âŸ¨Î´, Î´0, c, hÎ´c, hcÎµâŸ©
  haveI := Fact.mk (I.measure_coe_lt_top Î¼)
  change Î¼.restrict I {x | f x â‰  0} = 0 at hf
  set N : (Î¹ â†’ â„) â†’ â„• := fun x => âŒˆâ€–f xâ€–âŒ‰â‚Š
  have N0 : âˆ€ {x}, N x = 0 â†” f x = 0 := by simp [N]
  have : âˆ€ n, âˆƒ U, N â»Â¹' {n} âŠ† U âˆ§ IsOpen U âˆ§ Î¼.restrict I U < Î´ n / n := fun n â†¦ by
    refine (N â»Â¹' {n}).exists_isOpen_lt_of_lt _ ?_
    cases' n with n
    Â· simpa [ENNReal.div_zero (ENNReal.coe_pos.2 (Î´0 _)).ne'] using measure_lt_top (Î¼.restrict I) _
    Â· refine (measure_mono_null ?_ hf).le.trans_lt ?_
      Â· exact fun x hxN hxf => n.succ_ne_zero ((Eq.symm hxN).trans <| N0.2 hxf)
      Â· simp [(Î´0 _).ne']
  choose U hNU hUo hÎ¼U using this
  have : âˆ€ x, âˆƒ r : Ioi (0 : â„), closedBall x r âŠ† U (N x) := fun x => by
    obtain âŸ¨r, hrâ‚€, hrâŸ© := nhds_basis_closedBall.mem_iff.1 ((hUo _).mem_nhds (hNU _ rfl))
    exact âŸ¨âŸ¨r, hrâ‚€âŸ©, hrâŸ©
  choose r hrU using this
  refine âŸ¨fun _ => r, fun c => l.rCond_of_bRiemann_eq_false hl, fun c Ï€ hÏ€ _ => ?_âŸ©
  rw [dist_eq_norm, sub_zero, â† integralSum_fiberwise fun J => N (Ï€.tag J)]
  refine le_trans ?_ (NNReal.coe_lt_coe.2 hcÎµ).le
  refine (norm_sum_le_of_le _ ?_).trans
    (sum_le_hasSum _ (fun n _ => (Î´ n).2) (NNReal.hasSum_coe.2 hÎ´c))
  rintro n -
  dsimp [integralSum]
  have : âˆ€ J âˆˆ Ï€.filter fun J => N (Ï€.tag J) = n,
      â€–(Î¼ â†‘J).toReal â€¢ f (Ï€.tag J)â€– â‰¤ (Î¼ J).toReal * n := fun J hJ â†¦ by
    rw [TaggedPrepartition.mem_filter] at hJ
    rw [norm_smul, Real.norm_eq_abs, abs_of_nonneg ENNReal.toReal_nonneg]
    gcongr
    exact hJ.2 â–¸ Nat.le_ceil _
  refine (norm_sum_le_of_le _ this).trans ?_; clear this
  rw [â† sum_mul, â† Prepartition.measure_iUnion_toReal]
  let m := Î¼ (Ï€.filter fun J => N (Ï€.tag J) = n).iUnion
  show m.toReal * â†‘n â‰¤ â†‘(Î´ n)
  have : m < Î´ n / n := by
    simp only [Measure.restrict_apply (hUo _).measurableSet] at hÎ¼U
    refine (measure_mono ?_).trans_lt (hÎ¼U _)
    simp only [Set.subset_def, TaggedPrepartition.mem_iUnion, TaggedPrepartition.mem_filter]
    rintro x âŸ¨J, âŸ¨hJ, rflâŸ©, hxâŸ©
    exact âŸ¨hrU _ (hÏ€.1 _ hJ (Box.coe_subset_Icc hx)), Ï€.le_of_mem' J hJ hxâŸ©
  clear_value m
  lift m to â„â‰¥0 using ne_top_of_lt this
  rw [ENNReal.coe_toReal, â† NNReal.coe_natCast, â† NNReal.coe_mul, NNReal.coe_le_coe, â†
    ENNReal.coe_le_coe, ENNReal.coe_mul, ENNReal.coe_natCast, mul_comm]
  exact (mul_le_mul_left' this.le _).trans ENNReal.mul_div_le","simp only [HasIntegral.of_aeEq_zero, HasIntegral.of_aeEq_zero]"
Mathlib/Algebra/Group/Hom/Defs.lean,Subsingleton.of_oneHomClass,Subsingleton.of_oneHomClass,650b48365a265f18ee37b34dfd26cc8d9de5d6d7,  allEq f g := FunLike.ext _ _ fun x â†¦ by simp [Subsingleton.elim x 1],error:  unknown constant 'FunLike.ext',"theorem Subsingleton.of_oneHomClass [Subsingleton M] [OneHomClass F M N] :
    Subsingleton F where
",  allEq f g := DFunLike.ext _ _ fun x â†¦ by simp [Subsingleton.elim x 1],refine Subsingleton.where_of_oneHomClass Subsingleton.of_oneHomClass ?_
Mathlib/SetTheory/Ordinal/FixedPoint.lean,Ordinal.derivFamily_fp,derivFamily_fp,c959b2f950b9c44268e36bcedef976356855e6fb,":= by
  induction' o with o _ o l IH
  Â· rw [derivFamily_zero]
    exact nfpFamily_fp H 0
  Â· rw [derivFamily_succ]
    exact nfpFamily_fp H _
  Â· rw [derivFamily_limit _ l,
      IsNormal.bsup.{max u v, u, max u v} H (fun a _ => derivFamily f a) l.1]
    refine eq_of_forall_ge_iff fun c => ?_
    simp (config := { contextual := true }) only [bsup_le_iff, IH]","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Î¹ : Type u
f : Î¹ â†’ Ordinal.{max u v} â†’ Ordinal.{max u v}
i : Î¹
H : IsNormal (f i)
o : Ordinal.{max u v}
âŠ¢ f i (derivFamily f o) = derivFamily f o","theorem derivFamily_fp {i} (H : IsNormal (f i)) (o : Ordinal.{max u v}) :
    f i (derivFamily.{u, v} f o) = derivFamily.{u, v} f o ",":= by
  induction' o using limitRecOn with o _ o l IH
  Â· rw [derivFamily_zero]
    exact nfpFamily_fp H 0
  Â· rw [derivFamily_succ]
    exact nfpFamily_fp H _
  Â· rw [derivFamily_limit _ l,
      IsNormal.bsup.{max u v, u, max u v} H (fun a _ => derivFamily f a) l.1]
    refine eq_of_forall_ge_iff fun c => ?_
    simp (config := { contextual := true }) only [bsup_le_iff, IH]","simp only [derivFamily_fp, derivFamily_fp]"
Mathlib/Algebra/Tropical/BigOperators.lean,Multiset.untrop_sum,Multiset.untrop_sum,040e24340352a4333b5b2688f637a85dc78123c1,":= by
  induction' s with s x IH
  Â· simp
  Â· simp only [sum_cons, ge_iff_le, untrop_add, untrop_le_iff, map_cons, inf_cons, â† IH]
    rfl","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
R : Type u_1
S : Type u_2
instâœÂ¹ : LinearOrder R
instâœ : OrderTop R
s : Multiset (Tropical R)
âŠ¢ untrop s.sum = (map untrop s).inf","theorem Multiset.untrop_sum [LinearOrder R] [OrderTop R] (s : Multiset (Tropical R)) :
    untrop s.sum = Multiset.inf (s.map untrop) ",":= by
  induction' s using Multiset.induction with s x IH
  Â· simp
  Â· simp only [sum_cons, ge_iff_le, untrop_add, untrop_le_iff, map_cons, inf_cons, â† IH]
    rfl",refine Multiset.induction_on s ?_ ?_
Mathlib/Data/Set/Prod.lean,Set.insert_prod,insert_prod,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  ext âŸ¨x, yâŸ©
  simp (config := { contextual := true }) [image, iff_def, or_imp, Imp.swap]","error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information",theorem insert_prod : insert a s Ã—Ë¢ t = Prod.mk a '' t âˆª s Ã—Ë¢ t ,":= by
  ext âŸ¨x, yâŸ©
  simp (config := { contextual := true }) [image, iff_def, or_imp]",simp [insert_prod]
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le,norm_volume_sub_integral_face_upper_sub_lower_smul_le,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  set e : â„ â†’ (Fin n â†’ â„) â†’ (Fin (n + 1) â†’ â„) := i.insertNth (Î± := fun _ â†¦ â„)
  have Hl : I.lower i âˆˆ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i âˆˆ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : âˆ€ x âˆˆ Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) âŠ¥ (f âˆ˜ e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : âˆ€ y âˆˆ Box.Icc (I.face i),
      â€–f' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))â€– â‰¤
        2 * Îµ * diam (Box.Icc I) := fun y hy â†¦ by
    set g := fun y => f y - a - f' (y - x) with hg
    change âˆ€ y âˆˆ (Box.Icc I), â€–g yâ€– â‰¤ Îµ * â€–y - xâ€– at hÎµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to â€–g (e (I.lower i) y) - g (e (I.upper i) y)â€– â‰¤ _
    Â· congr 1
      have := Fin.insertNth_sub_same (Î± := fun _ â†¦ â„) i (I.upper i) (I.lower i) y
      simp only [â† this, f'.map_sub]; abel
    Â· have : âˆ€ z âˆˆ Icc (I.lower i) (I.upper i), e z y âˆˆ (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hÎµ : âˆ€ y âˆˆ (Box.Icc I), â€–g yâ€– â‰¤ Îµ * diam (Box.Icc I)
      Â· intro y hy
        refine' (hÎµ y hy).trans (mul_le_mul_of_nonneg_left _ h0.le)
        rw [â† dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hÎµ _ (this _ Hl)) (hÎµ _ (this _ Hu))
  calc
    â€–(âˆ j, (I.upper j - I.lower j)) â€¢ f' (Pi.single i 1) -
            (integral (I.face i) âŠ¥ (f âˆ˜ e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) âŠ¥ (f âˆ˜ e (I.lower i)) BoxAdditiveMap.volume)â€– =
        â€–integral.{0, u, u} (I.face i) âŠ¥
            (fun x : Fin n â†’ â„ =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volumeâ€– := by
      rw [â† integral_sub (Hi _ Hu) (Hi _ Hl), â† Box.volume_face_mul i, mul_smul, â† Box.volume_apply,
        â† BoxAdditiveMap.toSMul_apply, â† integral_const, â† BoxAdditiveMap.volume,
        â† integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(Â· âˆ˜ Â·), Pi.sub_def, â† f'.map_smul, â† Pi.single_smul', smul_eq_mul, mul_one]
    _ â‰¤ (volume (I.face i : Set (Fin n â†’ â„))).toReal * (2 * Îµ * c * (I.upper i - I.lower i)) := by
      refine' norm_integral_le_of_le_const (fun y hy => (this y hy).trans _) volume
      rw [mul_assoc (2 * Îµ)]
      exact mul_le_mul_of_nonneg_left (I.diam_Icc_le_of_distortion_le i hc)
        (mul_nonneg zero_le_two h0.le)
    _ = 2 * Îµ * c * âˆ j, (I.upper j - I.lower j) := by
      rw [â† Measure.toBoxAdditive_apply, Box.volume_apply, â† I.volume_face_mul i]
      ac_rfl","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case convert_2
E : Type u
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
n : â„•
instâœ : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f' : (Fin (n + 1) â†’ â„) â†’L[â„] E
x : Fin (n + 1) â†’ â„
hxI : x âˆˆ Box.Icc I
a : E
Îµ : â„
h0 : 0 < Îµ
c : â„â‰¥0
hc : I.distortion â‰¤ c
e : â„ â†’ (Fin n â†’ â„) â†’ Fin (n + 1) â†’ â„ := i.insertNth
Hl : I.lower i âˆˆ Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i âˆˆ Set.Icc (I.lower i) (I.upper i)
y : Fin n â†’ â„
hy : y âˆˆ Box.Icc (I.face i)
g : (Fin (n + 1) â†’ â„) â†’ E
hfc : ContinuousOn (fun y â†¦ a + f' (y - x) + g y) (Box.Icc I)
Hi :
  âˆ€ x_1 âˆˆ Set.Icc (I.lower i) (I.upper i),
    Integrable (I.face i) âŠ¥ ((fun y â†¦ a + f' (y - x) + g y) âˆ˜ e x_1) BoxAdditiveMap.volume
hg : g = fun y â†¦ (fun y â†¦ a + f' (y - x) + g y) y - a - f' (y - x)
this : âˆ€ z âˆˆ Set.Icc (I.lower i) (I.upper i), e z y âˆˆ Box.Icc I
hÎµ : âˆ€ y âˆˆ Box.Icc I, â€–g yâ€– â‰¤ Îµ * diam (Box.Icc I)
âŠ¢ â€–g (e (I.lower i) y) - g (e (I.upper i) y)â€– â‰¤ 2 * Îµ * diam (Box.Icc I)
error:  unsolved goals
E : Type u
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
n : â„•
instâœ : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f : (Fin (n + 1) â†’ â„) â†’ E
f' : (Fin (n + 1) â†’ â„) â†’L[â„] E
hfc : ContinuousOn f (Box.Icc I)
x : Fin (n + 1) â†’ â„
hxI : x âˆˆ Box.Icc I
a : E
Îµ : â„
h0 : 0 < Îµ
hÎµ : âˆ€ y âˆˆ Box.Icc I, â€–f y - a - f' (y - x)â€– â‰¤ Îµ * â€–y - xâ€–
c : â„â‰¥0
hc : I.distortion â‰¤ c
e : â„ â†’ (Fin n â†’ â„) â†’ Fin (n + 1) â†’ â„ := i.insertNth
Hl : I.lower i âˆˆ Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i âˆˆ Set.Icc (I.lower i) (I.upper i)
Hi : âˆ€ x âˆˆ Set.Icc (I.lower i) (I.upper i), Integrable (I.face i) âŠ¥ (f âˆ˜ e x) BoxAdditiveMap.volume
this :
  âˆ€ y âˆˆ Box.Icc (I.face i),
    â€–f' (Pi.single i (I.upper i - I.lower i)) - (f (e (I.upper i) y) - f (e (I.lower i) y))â€– â‰¤ 2 * Îµ * diam (Box.Icc I)
âŠ¢ â€–(âˆ j : Fin (n + 1), (I.upper j - I.lower j)) â€¢ f' (Pi.single i 1) -
        (integral (I.face i) âŠ¥ (f âˆ˜ e (I.upper i)) BoxAdditiveMap.volume -
          integral (I.face i) âŠ¥ (f âˆ˜ e (I.lower i)) BoxAdditiveMap.volume)â€– â‰¤
    2 * Îµ * â†‘c * âˆ j : Fin (n + 1), (I.upper j - I.lower j)","theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) â†’ â„) â†’ E}
    {f' : (Fin (n + 1) â†’ â„) â†’L[â„] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) â†’ â„}
    (hxI : x âˆˆ (Box.Icc I)) {a : E} {Îµ : â„} (h0 : 0 < Îµ)
    (hÎµ : âˆ€ y âˆˆ (Box.Icc I), â€–f y - a - f' (y - x)â€– â‰¤ Îµ * â€–y - xâ€–) {c : â„â‰¥0}
    (hc : I.distortion â‰¤ c) :
    â€–(âˆ j, (I.upper j - I.lower j)) â€¢ f' (Pi.single i 1) -
      (integral (I.face i) âŠ¥ (f âˆ˜ i.insertNth (Î± := fun _ â†¦ â„) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) âŠ¥ (f âˆ˜ i.insertNth (Î± := fun _ â†¦ â„) (I.lower i))
          BoxAdditiveMap.volume)â€– â‰¤
      2 * Îµ * c * âˆ j, (I.upper j - I.lower j) ",":= by
  set e : â„ â†’ (Fin n â†’ â„) â†’ (Fin (n + 1) â†’ â„) := i.insertNth (Î± := fun _ â†¦ â„)
  have Hl : I.lower i âˆˆ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i âˆˆ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : âˆ€ x âˆˆ Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) âŠ¥ (f âˆ˜ e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : âˆ€ y âˆˆ Box.Icc (I.face i),
      â€–f' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))â€– â‰¤
        2 * Îµ * diam (Box.Icc I) := fun y hy â†¦ by
    set g := fun y => f y - a - f' (y - x) with hg
    change âˆ€ y âˆˆ (Box.Icc I), â€–g yâ€– â‰¤ Îµ * â€–y - xâ€– at hÎµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to â€–g (e (I.lower i) y) - g (e (I.upper i) y)â€– â‰¤ _
    Â· congr 1
      have := Fin.insertNth_sub_same (Î± := fun _ â†¦ â„) i (I.upper i) (I.lower i) y
      simp only [â† this, f'.map_sub]; abel
    Â· have : âˆ€ z âˆˆ Icc (I.lower i) (I.upper i), e z y âˆˆ (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hÎµ : âˆ€ y âˆˆ (Box.Icc I), â€–g yâ€– â‰¤ Îµ * diam (Box.Icc I) := by
        intro y hy
        refine (hÎµ y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [â† dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hÎµ _ (this _ Hl)) (hÎµ _ (this _ Hu))
  calc
    â€–(âˆ j, (I.upper j - I.lower j)) â€¢ f' (Pi.single i 1) -
            (integral (I.face i) âŠ¥ (f âˆ˜ e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) âŠ¥ (f âˆ˜ e (I.lower i)) BoxAdditiveMap.volume)â€– =
        â€–integral.{0, u, u} (I.face i) âŠ¥
            (fun x : Fin n â†’ â„ =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volumeâ€– := by
      rw [â† integral_sub (Hi _ Hu) (Hi _ Hl), â† Box.volume_face_mul i, mul_smul, â† Box.volume_apply,
        â† BoxAdditiveMap.toSMul_apply, â† integral_const, â† BoxAdditiveMap.volume,
        â† integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(Â· âˆ˜ Â·), Pi.sub_def, â† f'.map_smul, â† Pi.single_smul', smul_eq_mul, mul_one]
    _ â‰¤ (volume (I.face i : Set (Fin n â†’ â„))).toReal * (2 * Îµ * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * Îµ)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * Îµ * c * âˆ j, (I.upper j - I.lower j) := by
      rw [â† Measure.toBoxAdditive_apply, Box.volume_apply, â† I.volume_face_mul i]
      ac_rfl","refine theorem_theorem_Icc _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  (fun y hy => ?_) (fun y hy => ?_) _ _"
Mathlib/RingTheory/MvPolynomial/Homogeneous.lean,MvPolynomial.IsHomogeneous.evalâ‚‚,evalâ‚‚,b271affacf1fa368c4e879d75cd5aaf54b75b7ed,":= by
  apply IsHomogeneous.sum
  intro i hi
  rw [â† zero_add (n * m)]
  apply IsHomogeneous.mul (hf _) _
  convert IsHomogeneous.prod _ _ (fun k â†¦ n * i k) _
  Â· rw [Finsupp.mem_support_iff] at hi
    rw [â† Finset.mul_sum, hÏ† hi]
  Â· rintro k -
    apply (hg k).pow","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (weightedDegree 1) i
case h.e'_1
Ïƒ : Type u_1
Ï„ : Type u_2
R : Type u_3
S : Type u_4
instâœÂ² instâœÂ¹ : CommSemiring R
instâœ : CommSemiring S
Ï† Ïˆ : MvPolynomial Ïƒ R
m n : â„•
hÏ† : Ï†.IsHomogeneous m
f : R â†’+* MvPolynomial Ï„ S
g : Ïƒ â†’ MvPolynomial Ï„ S
hf : âˆ€ (r : R), (f r).IsHomogeneous 0
hg : âˆ€ (i : Ïƒ), (g i).IsHomogeneous n
i : Ïƒ â†’â‚€ â„•
hi : Ï† i â‰  0
âŠ¢ n * m = n * âˆ‘ i_1 âˆˆ i.support, i i_1","lemma evalâ‚‚ (hÏ† : Ï†.IsHomogeneous m) (f : R â†’+* MvPolynomial Ï„ S) (g : Ïƒ â†’ MvPolynomial Ï„ S)
    (hf : âˆ€ r, (f r).IsHomogeneous 0) (hg : âˆ€ i, (g i).IsHomogeneous n) :
    (evalâ‚‚ f g Ï†).IsHomogeneous (n * m) ",":= by
  apply IsHomogeneous.sum
  intro i hi
  rw [â† zero_add (n * m)]
  apply IsHomogeneous.mul (hf _) _
  convert IsHomogeneous.prod _ _ (fun k â†¦ n * i k) _
  Â· rw [Finsupp.mem_support_iff] at hi
    rw [â† Finset.mul_sum, â† hÏ† hi, weightedDegree_apply]
    simp_rw [smul_eq_mul, Finsupp.sum, Pi.one_apply, mul_one]
  Â· rintro k -
    apply (hg k).pow",apply isHomogeneous_mul
Mathlib/Topology/Category/Stonean/EffectiveEpi.lean,Stonean.effectiveEpi_tfae,effectiveEpi_tfae,55619a095ad7cce23fe9818f4cf5fefa1fabf54e,":= by
  tfae
    1 â†’ 2
    | _ => inferInstance
    2 â†” 3 := epi_iff_surjective Ï€
    3 â†’ 1 := fun hÏ€ â†¦ âŸ¨âŸ¨struct Ï€ hÏ€âŸ©âŸ©","error:  unknown tactic
error:  unsolved goals
B X : Stonean
Ï€ : X âŸ¶ B
âŠ¢ [EffectiveEpi Ï€, Epi Ï€, Function.Surjective â‡‘Ï€].TFAE","theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (Ï€ : X âŸ¶ B) :
    TFAE
    [ EffectiveEpi Ï€
    , Epi Ï€
    , Function.Surjective Ï€
    ] ",":= by
  tfae_have 1 â†’ 2
  Â· intro; infer_instance
  tfae_have 2 â†” 3
  Â· exact epi_iff_surjective Ï€
  tfae_have 3 â†’ 1
  Â· exact fun hÏ€ â†¦ âŸ¨âŸ¨struct Ï€ hÏ€âŸ©âŸ©
  tfae_finish",have : EffectiveEpi Ï€ â‰« effectiveEpi_tfae := effectiveEpi_tfae
Mathlib/Algebra/Polynomial/Eval.lean,Polynomial.eval_natCast_map,eval_natCast_map,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction p with
  | h_add p q hp hq =>
    simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]
  | h_monomial n r =>
    simp only [map_natCast f, eval_monomial, map_monomial, f.map_pow, f.map_mul]","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
error:  invalid alternative name 'h_add'","theorem eval_natCast_map (f : R â†’+* S) (p : R[X]) (n : â„•) :
    (p.map f).eval (n : S) = f (p.eval n) ",":= by
  induction p using Polynomial.induction_on' with
  | h_add p q hp hq =>
    simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]
  | h_monomial n r =>
    simp only [map_natCast f, eval_monomial, map_monomial, f.map_pow, f.map_mul]","simp only [eval_map, eval_natCast_map, eval_map, eval_natCast_map, eval_natCast_map]"
Mathlib/Data/Nat/Totient.lean,Nat.totient_eq_prod_factorization,totient_eq_prod_factorization,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  rw [multiplicative_factorization Ï† (@totient_mul) totient_one hn]
  apply Finsupp.prod_congr _
  intro p hp
  have h := zero_lt_iff.mpr (Finsupp.mem_support_iff.mp hp)
  rw [totient_prime_pow (prime_of_mem_factorization hp) h]","warning:  totient does not have a doc string
error:  unknown identifier 'prime_of_mem_factorization'","theorem totient_eq_prod_factorization {n : â„•} (hn : n â‰  0) :
    Ï† n = n.factorization.prod fun p k => p ^ (k - 1) * (p - 1) ",":= by
  rw [multiplicative_factorization Ï† (@totient_mul) totient_one hn]
  apply Finsupp.prod_congr _
  intro p hp
  have h := zero_lt_iff.mpr (Finsupp.mem_support_iff.mp hp)
  rw [totient_prime_pow (prime_of_mem_primeFactors hp) h]",rw [totient_eq_prod_factorization]
Mathlib/Algebra/CharP/CharAndCard.lean,isUnit_iff_not_dvd_char,isUnit_iff_not_dvd_char,9e34a191034458a56331f976ff7400a26407c888,":= by
  have hch := CharP.cast_eq_zero R (ringChar R)
  have hp : p.Prime := Fact.out
  constructor
  Â· rintro hâ‚ âŸ¨q, hqâŸ©
    rcases IsUnit.exists_left_inv hâ‚ with âŸ¨a, haâŸ©
    have hâ‚ƒ : Â¬ringChar R âˆ£ q := by
      rintro âŸ¨r, hrâŸ©
      rw [hr, â† mul_assoc, mul_comm p, mul_assoc] at hq
      nth_rw 1 [â† mul_one (ringChar R)] at hq
      exact Nat.Prime.not_dvd_one hp âŸ¨r, mul_left_cancelâ‚€ hR hqâŸ©
    have hâ‚„ := mt (CharP.int_cast_eq_zero_iff R (ringChar R) q).mp
    apply_fun ((â†‘) : â„• â†’ R) at hq
    apply_fun (Â· * Â·) a at hq
    rw [Nat.cast_mul, hch, MulZeroClass.mul_zero, â† mul_assoc, ha, one_mul] at hq
    norm_cast at hâ‚„
    exact hâ‚„ hâ‚ƒ hq.symm
  Â· intro h
    rcases(hp.coprime_iff_not_dvd.mpr h).isCoprime with âŸ¨a, b, habâŸ©
    apply_fun ((â†‘) : â„¤ â†’ R) at hab
    push_cast at hab
    rw [hch, MulZeroClass.mul_zero, add_zero, mul_comm] at hab
    exact isUnit_of_mul_eq_one (p : R) a hab",error:  unknown constant 'CharP.int_cast_eq_zero_iff',"theorem isUnit_iff_not_dvd_char_of_ringChar_ne_zero (R : Type*) [CommRing R] (p : â„•) [Fact p.Prime]
    (hR : ringChar R â‰  0) : IsUnit (p : R) â†” Â¬p âˆ£ ringChar R ",":= by
  have hch := CharP.cast_eq_zero R (ringChar R)
  have hp : p.Prime := Fact.out
  constructor
  Â· rintro hâ‚ âŸ¨q, hqâŸ©
    rcases IsUnit.exists_left_inv hâ‚ with âŸ¨a, haâŸ©
    have hâ‚ƒ : Â¬ringChar R âˆ£ q := by
      rintro âŸ¨r, hrâŸ©
      rw [hr, â† mul_assoc, mul_comm p, mul_assoc] at hq
      nth_rw 1 [â† mul_one (ringChar R)] at hq
      exact Nat.Prime.not_dvd_one hp âŸ¨r, mul_left_cancelâ‚€ hR hqâŸ©
    have hâ‚„ := mt (CharP.intCast_eq_zero_iff R (ringChar R) q).mp
    apply_fun ((â†‘) : â„• â†’ R) at hq
    apply_fun (Â· * Â·) a at hq
    rw [Nat.cast_mul, hch, mul_zero, â† mul_assoc, ha, one_mul] at hq
    norm_cast at hâ‚„
    exact hâ‚„ hâ‚ƒ hq.symm
  Â· intro h
    rcases (hp.coprime_iff_not_dvd.mpr h).isCoprime with âŸ¨a, b, habâŸ©
    apply_fun ((â†‘) : â„¤ â†’ R) at hab
    push_cast at hab
    rw [hch, mul_zero, add_zero, mul_comm] at hab
    exact isUnit_of_mul_eq_one (p : R) a hab","rw [â† isUnit_iff_dvd_ringChar_ne_zero, â† isUnit_iff_dvd_ringChar_ne_zero_iff_dvd_ringChar_ne_zero]"
Mathlib/MeasureTheory/Measure/Typeclasses.lean,MeasureTheory.abs_toReal_measure_sub_le_measure_symmDiff',abs_toReal_measure_sub_le_measure_symmDiff',089ac90928952b8a08be66ede7ff142d0f9ba666,":= by
  have hst : Î¼ (s \ t) â‰  âˆ := (measure_lt_top_of_subset (diff_subset s t) hs').ne
  have hts : Î¼ (t \ s) â‰  âˆ := (measure_lt_top_of_subset (diff_subset t s) ht').ne
  suffices (Î¼ s).toReal - (Î¼ t).toReal = (Î¼ (s \ t)).toReal - (Î¼ (t \ s)).toReal by
    rw [this, measure_symmDiff_eq hs ht, ENNReal.toReal_add hst hts]
    convert abs_sub (Î¼ (s \ t)).toReal (Î¼ (t \ s)).toReal <;> simp
  rw [measure_diff' s ht ht', measure_diff' t hs hs',
    ENNReal.toReal_sub_of_le measure_le_measure_union_right (measure_union_ne_top hs' ht'),
    ENNReal.toReal_sub_of_le measure_le_measure_union_right (measure_union_ne_top ht' hs'),
    union_comm t s]
  abel","error:  application type mismatch
  diff_subset s
argument
  s
has type
  Set Î± : Type u_1
but is expected to have type
  ?m.64151 âˆˆ ?m.64149 \ ?m.64150 : Prop
error:  application type mismatch
  diff_subset t
argument
  t
has type
  Set Î± : Type u_1
but is expected to have type
  ?m.64804 âˆˆ ?m.64802 \ ?m.64803 : Prop","theorem abs_toReal_measure_sub_le_measure_symmDiff'
    (hs : MeasurableSet s) (ht : MeasurableSet t) (hs' : Î¼ s â‰  âˆ) (ht' : Î¼ t â‰  âˆ) :
    |(Î¼ s).toReal - (Î¼ t).toReal| â‰¤ (Î¼ (s âˆ† t)).toReal ",":= by
  have hst : Î¼ (s \ t) â‰  âˆ := (measure_lt_top_of_subset diff_subset hs').ne
  have hts : Î¼ (t \ s) â‰  âˆ := (measure_lt_top_of_subset diff_subset ht').ne
  suffices (Î¼ s).toReal - (Î¼ t).toReal = (Î¼ (s \ t)).toReal - (Î¼ (t \ s)).toReal by
    rw [this, measure_symmDiff_eq hs ht, ENNReal.toReal_add hst hts]
    convert abs_sub (Î¼ (s \ t)).toReal (Î¼ (t \ s)).toReal <;> simp
  rw [measure_diff' s ht ht', measure_diff' t hs hs',
    ENNReal.toReal_sub_of_le measure_le_measure_union_right (measure_union_ne_top hs' ht'),
    ENNReal.toReal_sub_of_le measure_le_measure_union_right (measure_union_ne_top ht' hs'),
    union_comm t s]
  abel",rw [â† abs_toReal_measure_sub_le_measure_symmDiff']
Mathlib/CategoryTheory/MorphismProperty/Basic.lean,CategoryTheory.MorphismProperty.RespectsIso.isoClosure_eq,RespectsIso.isoClosure_eq,6830b5e612c6f4431fee7e89ec01560ae5118e5e,":= by
  refine' le_antisymm _ (P.subset_isoClosure)
  intro X Y f âŸ¨X', Y', f', hf', âŸ¨eâŸ©âŸ©
  exact (hP.arrow_mk_iso_iff e).1 hf'","error:  invalid field 'subset_isoClosure', the environment does not contain 'CategoryTheory.MorphismProperty.subset_isoClosure'
  P
has type
  MorphismProperty C
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  P
has type
  â¦ƒX Y : Câ¦„ â†’ (X âŸ¶ Y) â†’ Prop","lemma RespectsIso.isoClosure_eq {P : MorphismProperty C} (hP : P.RespectsIso) :
    P.isoClosure = P ",:= by rwa [isoClosure_eq_iff],apply P.isoClosure_eq_isoClosure_eq
Mathlib/MeasureTheory/Measure/Restrict.lean,MeasureTheory.Measure.restrict_union_congr,restrict_union_congr,6402a4dd7bfe402e3a2139adfa6bac90aa088050,":= by
  refine'
    âŸ¨fun h =>
      âŸ¨restrict_congr_mono (subset_union_left _ _) h,
        restrict_congr_mono (subset_union_right _ _) hâŸ©,
      _âŸ©
  rintro âŸ¨hs, htâŸ©
  ext1 u hu
  simp only [restrict_apply hu, inter_union_distrib_left]
  rcases exists_measurable_supersetâ‚‚ Î¼ Î½ (u âˆ© s) with âŸ¨US, hsub, hm, hÎ¼, hÎ½âŸ©
  calc
    Î¼ (u âˆ© s âˆª u âˆ© t) = Î¼ (US âˆª u âˆ© t) :=
      measure_union_congr_of_subset hsub hÎ¼.le Subset.rfl le_rfl
    _ = Î¼ US + Î¼ ((u âˆ© t) \ US) := (measure_add_diff hm _).symm
    _ = restrict Î¼ s u + restrict Î¼ t (u \ US) := by
      simp only [restrict_apply, hu, hu.diff hm, hÎ¼, â† inter_comm t, inter_diff_assoc]
    _ = restrict Î½ s u + restrict Î½ t (u \ US) := by rw [hs, ht]
    _ = Î½ US + Î½ ((u âˆ© t) \ US) := by
      simp only [restrict_apply, hu, hu.diff hm, hÎ½, â† inter_comm t, inter_diff_assoc]
    _ = Î½ (US âˆª u âˆ© t) := (measure_add_diff hm _)
    _ = Î½ (u âˆ© s âˆª u âˆ© t) := Eq.symm <| measure_union_congr_of_subset hsub hÎ½.le Subset.rfl le_rfl","error:  function expected at
  subset_union_left ?m.54948
term has type
  ?m.54947 âˆˆ ?m.54945 âˆª ?m.54946
error:  function expected at
  subset_union_right ?m.54997
term has type
  ?m.54996 âˆˆ ?m.54994 âˆª ?m.54995","theorem restrict_union_congr :
    Î¼.restrict (s âˆª t) = Î½.restrict (s âˆª t) â†”
      Î¼.restrict s = Î½.restrict s âˆ§ Î¼.restrict t = Î½.restrict t ",":= by
  refine
    âŸ¨fun h =>
      âŸ¨restrict_congr_mono subset_union_left h,
        restrict_congr_mono subset_union_right hâŸ©,
      ?_âŸ©
  rintro âŸ¨hs, htâŸ©
  ext1 u hu
  simp only [restrict_apply hu, inter_union_distrib_left]
  rcases exists_measurable_supersetâ‚‚ Î¼ Î½ (u âˆ© s) with âŸ¨US, hsub, hm, hÎ¼, hÎ½âŸ©
  calc
    Î¼ (u âˆ© s âˆª u âˆ© t) = Î¼ (US âˆª u âˆ© t) :=
      measure_union_congr_of_subset hsub hÎ¼.le Subset.rfl le_rfl
    _ = Î¼ US + Î¼ ((u âˆ© t) \ US) := (measure_add_diff hm _).symm
    _ = restrict Î¼ s u + restrict Î¼ t (u \ US) := by
      simp only [restrict_apply, hu, hu.diff hm, hÎ¼, â† inter_comm t, inter_diff_assoc]
    _ = restrict Î½ s u + restrict Î½ t (u \ US) := by rw [hs, ht]
    _ = Î½ US + Î½ ((u âˆ© t) \ US) := by
      simp only [restrict_apply, hu, hu.diff hm, hÎ½, â† inter_comm t, inter_diff_assoc]
    _ = Î½ (US âˆª u âˆ© t) := measure_add_diff hm _
    _ = Î½ (u âˆ© s âˆª u âˆ© t) := Eq.symm <| measure_union_congr_of_subset hsub hÎ½.le Subset.rfl le_rfl","rw [restrict_union_congr, restrict_union_congr]"
Mathlib/LinearAlgebra/TensorProduct/Matrix.lean,TensorProduct.toMatrix_comm,TensorProduct.toMatrix_comm,a37325ba17db4b8735587123d2388c63923a3605,":= by
  ext âŸ¨i, jâŸ© âŸ¨i', j'âŸ©
  simp_rw [toMatrix_apply, Basis.tensorProduct_apply, LinearEquiv.coe_coe, TensorProduct.comm_tmul,
    Basis.tensorProduct_repr_tmul_apply, Matrix.submatrix_apply, Prod.swap_prod_mk, id.eq_def,
    Basis.repr_self_apply, Matrix.one_apply, Prod.ext_iff, ite_and, @eq_comm _ i', @eq_comm _ j']
  split_ifs <;> simp",error:  simp made no progress,"theorem TensorProduct.toMatrix_comm :
    toMatrix (bM.tensorProduct bN) (bN.tensorProduct bM) (TensorProduct.comm R M N) =
      (1 : Matrix (Î¹ Ã— Îº) (Î¹ Ã— Îº) R).submatrix Prod.swap _root_.id ",":= by
  ext âŸ¨i, jâŸ© âŸ¨i', j'âŸ©
  simp_rw [toMatrix_apply, Basis.tensorProduct_apply, LinearEquiv.coe_coe, TensorProduct.comm_tmul,
    Basis.tensorProduct_repr_tmul_apply, Matrix.submatrix_apply, Basis.repr_self,
    Finsupp.single_apply, @eq_comm _ j', @eq_comm _ i', mul_ite, mul_one, mul_zero,
    Matrix.one_apply, Prod.swap_prod_mk, _root_.id, Prod.ext_iff, ite_and]",simp only [TensorProduct.toMatrix_comm]
Mathlib/GroupTheory/Nilpotent.lean,IsPGroup.isNilpotent,IsPGroup.isNilpotent,5618e4318bfd1fcd653dba5baf6373bb64237264,":= by
  cases' nonempty_fintype G
  classical
    revert hG
    apply @Fintype.induction_subsingleton_or_nontrivial _ G _
    Â· intro _ _ _ _
      infer_instance
    Â· intro G _ _ ih _ h
      have hcq : Fintype.card (G â§¸ center G) < Fintype.card G := by
        rw [card_eq_card_quotient_mul_card_subgroup (center G)]
        apply lt_mul_of_one_lt_right
        exact Fintype.card_pos_iff.mpr One.nonempty
        exact (Subgroup.one_lt_card_iff_ne_bot _).mpr (ne_of_gt h.bot_lt_center)
      have hnq : IsNilpotent (G â§¸ center G) := ih _ hcq (h.to_quotient (center G))
      exact of_quotient_center_nilpotent hnq","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.card G
Gâœ : Type u_1
instâœÂ² : Finite Gâœ
p : â„•
hp : Fact (Nat.Prime p)
valâœ : Fintype Gâœ
G : Type u_1
instâœÂ¹ : Fintype G
instâœ : Nontrivial G
ih : âˆ€ (Î² : Type u_1) [inst : Fintype Î²], card Î² < card G â†’ âˆ€ [hG : Group Î²], IsPGroup p Î² â†’ Group.IsNilpotent Î²
hGâœ : Group G
h : IsPGroup p G
âŠ¢ card (G â§¸ center G) < card G","theorem IsPGroup.isNilpotent [Finite G] {p : â„•} [hp : Fact (Nat.Prime p)] (h : IsPGroup p G) :
    IsNilpotent G ",":= by
  cases' nonempty_fintype G
  classical
    revert hG
    apply @Fintype.induction_subsingleton_or_nontrivial _ G _
    Â· intro _ _ _ _
      infer_instance
    Â· intro G _ _ ih _ h
      have hcq : Fintype.card (G â§¸ center G) < Fintype.card G := by
        simp only [â† Nat.card_eq_fintype_card]
        rw [card_eq_card_quotient_mul_card_subgroup (center G)]
        simp only [Nat.card_eq_fintype_card]
        apply lt_mul_of_one_lt_right
        Â· exact Fintype.card_pos_iff.mpr One.instNonempty
        Â· simp only [â† Nat.card_eq_fintype_card]
          exact (Subgroup.one_lt_card_iff_ne_bot _).mpr (ne_of_gt h.bot_lt_center)
      have hnq : IsNilpotent (G â§¸ center G) := ih _ hcq (h.to_quotient (center G))
      exact of_quotient_center_nilpotent hnq","refine IsNilpotent.isNilpotent_iff.mpr âŸ¨IsNilpotent, IsNilpotent, ?_âŸ©"
Mathlib/Data/Set/Pointwise/Interval.lean,Set.Iic_add_bij,Iic_add_bij,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  image_add_const_Iic a b â–¸ ((add_left_injective _).injOn _).bijOn_image","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Function.Injective.injOn (add_left_injective ?m.290783) ?m.290844
has type
  âˆ€ â¦ƒxâ‚‚ : ?m.290834â¦„, xâ‚‚ âˆˆ ?m.290842 â†’ ?m.290843 + ?m.290783 = xâ‚‚ + ?m.290783 â†’ ?m.290843 = xâ‚‚",theorem Iic_add_bij : BijOn (Â· + a) (Iic b) (Iic (b + a)) ,":=
  image_add_const_Iic a b â–¸ (add_left_injective _).injOn.bijOn_image",refine Iic_add_bij.ext fun x hx => ?_
Mathlib/Analysis/InnerProductSpace/LinearPMap.lean,IsSelfAdjoint.dense_domain,_root_.IsSelfAdjoint.dense_domain,11d63dbc85fa074b875a66f1c9dd6d3f7cae8101,":= by
  by_contra h
  rw [isSelfAdjoint_def] at hA
  have h' : A.domain = âŠ¤ := by
    rw [â† hA, Submodule.eq_top_iff']
    intro x
    rw [mem_adjoint_domain_iff, â† hA]
    refine (innerSL ğ•œ x).cont.comp ?_
    simp [adjoint, h, continuous_const]
  simp [h'] at h","error:  unsolved goals
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
G : Type u_4
instâœâµ : RCLike ğ•œ
instâœâ´ : NormedAddCommGroup E
instâœÂ³ : InnerProductSpace ğ•œ E
instâœÂ² : NormedAddCommGroup F
instâœÂ¹ : InnerProductSpace ğ•œ F
instâœ : CompleteSpace E
A : E â†’â‚—.[ğ•œ] E
hA : Aâ€  = A
h : Â¬Dense â†‘A.domain
x : E
âŠ¢ Continuous â‡‘0",theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) ,":= by
  by_contra h
  rw [isSelfAdjoint_def] at hA
  have h' : A.domain = âŠ¤ := by
    rw [â† hA, Submodule.eq_top_iff']
    intro x
    rw [mem_adjoint_domain_iff, â† hA]
    refine (innerSL ğ•œ x).cont.comp ?_
    simp only [adjoint, h]
    exact continuous_const
  simp [h'] at h",rw [dense_domain_dense_domain]
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.Î´_comp_Ïƒ_of_le,Î´_comp_Ïƒ_of_le,1b5c1d10be0ae07fd997c78515f4ed4561b92535,":= by
  ext k : 3
  dsimp [Ïƒ, Î´]
  rcases le_or_lt i k with (hik | hik)
  Â· rw [Fin.succAbove_above _ _ (Fin.castSucc_le_castSucc_iff.mpr hik),
    Fin.succ_predAbove_succ, Fin.succAbove_above]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    Â· rwa [Fin.predAbove_below _ _ hjk, Fin.castSucc_castPred]
    Â· rw [Fin.le_castSucc_iff, Fin.predAbove_above _ _ hjk, Fin.succ_pred]
      exact H.trans_lt hjk
  Â· rw [Fin.succAbove_below _ _ (Fin.castSucc_lt_castSucc_iff.mpr hik)]
    have hjk := H.trans_lt' hik
    rw [Fin.predAbove_below _ _ (Fin.castSucc_le_castSucc_iff.mpr
      (hjk.trans (Fin.castSucc_lt_succ _)).le),
      Fin.predAbove_below _ _ hjk.le, Fin.castPred_castSucc, Fin.succAbove_below,
      Fin.castSucc_castPred]
    rwa [Fin.castSucc_castPred]","error:  unknown constant 'Fin.succAbove_above'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.54199
case a.h.h.inl
n : â„•
i : Fin (n + 2)
j : Fin (n + 1)
H : i â‰¤ j.castSucc
k : Fin ([n + 1].len + 1)
hik : i â‰¤ k
âŠ¢ j.succ.predAbove (i.castSucc.succAbove k) = i.succAbove (j.predAbove k)
error:  unknown constant 'Fin.succAbove_below'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.54201
case a.h.h.inr
n : â„•
i : Fin (n + 2)
j : Fin (n + 1)
H : i â‰¤ j.castSucc
k : Fin ([n + 1].len + 1)
hik : k < i
âŠ¢ j.succ.predAbove (i.castSucc.succAbove k) = i.succAbove (j.predAbove k)","theorem Î´_comp_Ïƒ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i â‰¤ Fin.castSucc j) :
    Î´ (Fin.castSucc i) â‰« Ïƒ j.succ = Ïƒ j â‰« Î´ i ",":= by
  ext k : 3
  dsimp [Ïƒ, Î´]
  rcases le_or_lt i k with (hik | hik)
  Â· rw [Fin.succAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hik),
    Fin.succ_predAbove_succ, Fin.succAbove_of_le_castSucc]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    Â· rwa [Fin.predAbove_of_le_castSucc _ _ hjk, Fin.castSucc_castPred]
    Â· rw [Fin.le_castSucc_iff, Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succ_pred]
      exact H.trans_lt hjk
  Â· rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hik)]
    have hjk := H.trans_lt' hik
    rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr
      (hjk.trans (Fin.castSucc_lt_succ _)).le),
      Fin.predAbove_of_le_castSucc _ _ hjk.le, Fin.castPred_castSucc, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_castPred]
    rwa [Fin.castSucc_castPred]","rw [Fin.castSucc_castSucc, Î´_comp_Ïƒ_of_le]"
Mathlib/Data/Finset/Image.lean,Finset.image_symmDiff,image_symmDiff,b0304b2532b035fd00ff51805ac89317b4114265,":=
  coe_injective <| by
    push_cast
    exact Set.image_symm_diff hf _ _",error:  unknown constant 'Set.image_symm_diff',"theorem image_symmDiff [DecidableEq Î±] {f : Î± â†’ Î²} (s t : Finset Î±) (hf : Injective f) :
    (s âˆ† t).image f = s.image f âˆ† t.image f ",":=
  mod_cast Set.image_symmDiff hf s t","rw [symmDiff_symmDiff, symmDiff_symmDiff]"
Mathlib/Analysis/Convex/Integral.lean,ae_eq_const_or_exists_average_ne_compl,ae_eq_const_or_exists_average_ne_compl,070b09db52c6f063dd905c04b291f74460734aab,":= by
  refine' or_iff_not_imp_right.mpr fun H => _; push_neg at H
  refine' hfi.ae_eq_of_forall_set_integral_eq _ _ (integrable_const _) fun t ht ht' => _; clear ht'
  simp only [const_apply, set_integral_const]
  by_cases hâ‚€ : Î¼ t = 0
  Â· rw [restrict_eq_zero.2 hâ‚€, integral_zero_measure, hâ‚€, ENNReal.zero_toReal, zero_smul]
  by_cases hâ‚€' : Î¼ tá¶œ = 0
  Â· rw [â† ae_eq_univ] at hâ‚€'
    rw [restrict_congr_set hâ‚€', restrict_univ, measure_congr hâ‚€', measure_smul_average]
  have := average_mem_openSegment_compl_self ht.nullMeasurableSet hâ‚€ hâ‚€' hfi
  rw [â† H t ht hâ‚€ hâ‚€', openSegment_same, mem_singleton_iff] at this
  rw [this, measure_smul_set_average _ (measure_ne_top Î¼ _)]","warning:  `MeasureTheory.Integrable.ae_eq_of_forall_set_integral_eq` has been deprecated, use `MeasureTheory.Integrable.ae_eq_of_forall_setIntegral_eq` instead
warning:  `MeasureTheory.set_integral_const` has been deprecated, use `MeasureTheory.setIntegral_const` instead
error:  unknown identifier 'measure_smul_set_average'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.79953
case neg
Î± : Type u_1
E : Type u_2
F : Type u_3
m0 : MeasurableSpace Î±
instâœâ¶ : NormedAddCommGroup E
instâœâµ : NormedSpace â„ E
instâœâ´ : CompleteSpace E
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : NormedSpace â„ F
instâœÂ¹ : CompleteSpace F
Î¼ : Measure Î±
s : Set E
tâœ : Set Î±
f : Î± â†’ E
g : E â†’ â„
C : â„
instâœ : IsFiniteMeasure Î¼
hfi : Integrable f Î¼
H : âˆ€ (t : Set Î±), MeasurableSet t â†’ Î¼ t â‰  0 â†’ Î¼ tá¶œ â‰  0 â†’ â¨ (x : Î±) in t, f x âˆ‚Î¼ = â¨ (x : Î±) in tá¶œ, f x âˆ‚Î¼
t : Set Î±
ht : MeasurableSet t
hâ‚€ : Â¬Î¼ t = 0
hâ‚€' : Â¬Î¼ tá¶œ = 0
this : â¨ (x : Î±), f x âˆ‚Î¼ = â¨ (x : Î±) in t, f x âˆ‚Î¼
âŠ¢ âˆ« (x : Î±) in t, f x âˆ‚Î¼ = (Î¼ t).toReal â€¢ â¨ (x : Î±) in t, f x âˆ‚Î¼","theorem ae_eq_const_or_exists_average_ne_compl [IsFiniteMeasure Î¼] (hfi : Integrable f Î¼) :
    f =áµ[Î¼] const Î± (â¨ x, f x âˆ‚Î¼) âˆ¨
      âˆƒ t, MeasurableSet t âˆ§ Î¼ t â‰  0 âˆ§ Î¼ tá¶œ â‰  0 âˆ§ (â¨ x in t, f x âˆ‚Î¼) â‰  â¨ x in tá¶œ, f x âˆ‚Î¼ ",":= by
  refine or_iff_not_imp_right.mpr fun H => ?_; push_neg at H
  refine hfi.ae_eq_of_forall_setIntegral_eq _ _ (integrable_const _) fun t ht ht' => ?_; clear ht'
  simp only [const_apply, setIntegral_const]
  by_cases hâ‚€ : Î¼ t = 0
  Â· rw [restrict_eq_zero.2 hâ‚€, integral_zero_measure, hâ‚€, ENNReal.zero_toReal, zero_smul]
  by_cases hâ‚€' : Î¼ tá¶œ = 0
  Â· rw [â† ae_eq_univ] at hâ‚€'
    rw [restrict_congr_set hâ‚€', restrict_univ, measure_congr hâ‚€', measure_smul_average]
  have := average_mem_openSegment_compl_self ht.nullMeasurableSet hâ‚€ hâ‚€' hfi
  rw [â† H t ht hâ‚€ hâ‚€', openSegment_same, mem_singleton_iff] at this
  rw [this, measure_smul_setAverage _ (measure_ne_top Î¼ _)]",rcases ae_eq_const_or_exists_average_ne_compl ae_eq_const_or_exists_average_ne_compl ae_eq_const_or_exists_average
Mathlib/ModelTheory/Fraisse.lean,FirstOrder.Language.exists_cg_is_age_of,exists_cg_is_age_of,686b34895027252be7ce9c83a4a3bf4d09a0fd81,":= by
  obtain âŸ¨F, hFâŸ© := hc.exists_eq_range (hn.image _)
  simp only [Set.ext_iff, forall_quotient_iff, mem_image, mem_range, Quotient.eq'] at hF
  simp_rw [Quotient.eq_mk_iff_out] at hF
  have hF' : âˆ€ n : â„•, (F n).out âˆˆ K := by
    intro n
    obtain âŸ¨P, hP1, hP2âŸ© := (hF (F n).out).2 âŸ¨n, Setoid.refl _âŸ©
    replace hP2 := Setoid.trans (Setoid.symm (Quotient.mk_out P)) hP2
    exact (h _ _ hP2).1 hP1
  choose P hPK hP hFP using fun (N : K) (n : â„•) => jep N N.2 (F (n + 1)).out (hF' _)
  let G : â„• â†’ K := @Nat.rec (fun _ => K) âŸ¨(F 0).out, hF' 0âŸ© fun n N => âŸ¨P N n, hPK N nâŸ©
  let f : âˆ€ (i j : â„•), i â‰¤ j â†’ (G i).val â†ª[L] (G j).val := by
    refine DirectedSystem.natLeRec (G' := fun i => (G i).val) (L := L) ?_
    dsimp only
    exact (fun n => (hP _ n).some)
  have : DirectedSystem (fun n â†¦ (G n).val) fun i j h â†¦ â†‘(f i j h) := by
    dsimp; infer_instance
  refine âŸ¨Bundled.of (@DirectLimit L _ _ (fun n â†¦ (G n).val) _ f _ _), ?_, ?_âŸ©
  Â· exact DirectLimit.cg _ (fun n => (fg _ (G n).2).cg)
  Â· refine (age_directLimit (fun n â†¦ (G n).val) f).trans
      (subset_antisymm (iUnion_subset fun n N hN => hp (G n).val (G n).2 hN) fun N KN => ?_)
    have : Quotient.out (Quotient.mk' N) â‰ˆ N := Quotient.eq_mk_iff_out.mp rfl
    obtain âŸ¨n, âŸ¨eâŸ©âŸ© := (hF N).1 âŸ¨N, KN, thisâŸ©
    refine mem_iUnion_of_mem n âŸ¨fg _ KN, âŸ¨Embedding.comp ?_ e.symm.toEmbeddingâŸ©âŸ©
    cases' n with n
    Â· dsimp; exact Embedding.refl _ _
    Â· dsimp; exact (hFP _ n).some","error:  unknown identifier 'forall_quotient_iff'
error:  simp made no progress","theorem exists_cg_is_age_of (hn : K.Nonempty)
    (h : âˆ€ M N : Bundled.{w} L.Structure, Nonempty (M â‰ƒ[L] N) â†’ (M âˆˆ K â†” N âˆˆ K))
    (hc : (Quotient.mk' '' K).Countable)
    (fg : âˆ€ M : Bundled.{w} L.Structure, M âˆˆ K â†’ Structure.FG L M) (hp : Hereditary K)
    (jep : JointEmbedding K) : âˆƒ M : Bundled.{w} L.Structure, Structure.CG L M âˆ§ L.age M = K ",":= by
  obtain âŸ¨F, hFâŸ© := hc.exists_eq_range (hn.image _)
  simp only [Set.ext_iff, Quotient.forall, mem_image, mem_range, Quotient.eq'] at hF
  simp_rw [Quotient.eq_mk_iff_out] at hF
  have hF' : âˆ€ n : â„•, (F n).out âˆˆ K := by
    intro n
    obtain âŸ¨P, hP1, hP2âŸ© := (hF (F n).out).2 âŸ¨n, Setoid.refl _âŸ©
    replace hP2 := Setoid.trans (Setoid.symm (Quotient.mk_out P)) hP2
    exact (h _ _ hP2).1 hP1
  choose P hPK hP hFP using fun (N : K) (n : â„•) => jep N N.2 (F (n + 1)).out (hF' _)
  let G : â„• â†’ K := @Nat.rec (fun _ => K) âŸ¨(F 0).out, hF' 0âŸ© fun n N => âŸ¨P N n, hPK N nâŸ©
  let f : âˆ€ (i j : â„•), i â‰¤ j â†’ (G i).val â†ª[L] (G j).val := by
    refine DirectedSystem.natLERec (G' := fun i => (G i).val) (L := L) ?_
    dsimp only [G]
    exact fun n => (hP _ n).some
  have : DirectedSystem (fun n â†¦ (G n).val) fun i j h â†¦ â†‘(f i j h) := by
    dsimp [f, G]; infer_instance
  refine âŸ¨Bundled.of (@DirectLimit L _ _ (fun n â†¦ (G n).val) _ f _ _), ?_, ?_âŸ©
  Â· exact DirectLimit.cg _ (fun n => (fg _ (G n).2).cg)
  Â· refine (age_directLimit (fun n â†¦ (G n).val) f).trans
      (subset_antisymm (iUnion_subset fun n N hN => hp (G n).val (G n).2 hN) fun N KN => ?_)
    have : Quotient.out (Quotient.mk' N) â‰ˆ N := Quotient.eq_mk_iff_out.mp rfl
    obtain âŸ¨n, âŸ¨eâŸ©âŸ© := (hF N).1 âŸ¨N, KN, thisâŸ©
    refine mem_iUnion_of_mem n âŸ¨fg _ KN, âŸ¨Embedding.comp ?_ e.symm.toEmbeddingâŸ©âŸ©
    cases' n with n
    Â· dsimp [G]; exact Embedding.refl _ _
    Â· dsimp [G]; exact (hFP _ n).some","obtain âŸ¨M, hMâŸ© := exists_cg_is_age_of_exists_cg K"
Mathlib/Data/Seq/Parallel.lean,Computation.terminates_parallel,terminates_parallel,b9a9dce369ad3d62c09e3c1e7cd12d102dde4e51,":= by
  have lem1 :
    âˆ€ l S, (âˆƒ a : Î±, parallel.aux2 l = Sum.inl a) â†’ Terminates (corec parallel.aux1 (l, S)) := by
    intro l S e
    cases' e with a e
    have : corec parallel.aux1 (l, S) = return a := by
      apply destruct_eq_pure
      simp only [parallel.aux1, rmap, corec_eq]
      rw [e]
    rw [this]
    exact ret_terminates a
  intro l S c m T
  revert l S
  apply @terminatesRecOn _ _ c T _ _
  Â· intro a l S m
    apply lem1
    induction' l with c l IH <;> simp at m
    cases' m with e m
    Â· rw [â† e]
      simp only [parallel.aux2, rmap, List.foldr_cons, destruct_pure]
      split <;> simp
    Â· cases' IH m with a' e
      simp only [parallel.aux2, rmap, List.foldr_cons]
      simp? [parallel.aux2] at e says simp only [parallel.aux2, rmap] at e
      rw [e]
      exact âŸ¨a', rflâŸ©
  Â· intro s IH l S m
    have H1 : âˆ€ l', parallel.aux2 l = Sum.inr l' â†’ s âˆˆ l' := by
      induction' l with c l IH' <;> intro l' e' <;> simp at m
      cases' m with e m <;> simp [parallel.aux2] at e'
      Â· rw [â† e] at e'
        revert e'
        split
        Â· simp
        Â· simp only [destruct_think, Sum.inr.injEq]
          rintro rfl
          simp
      Â· induction' e : List.foldr (fun c o =>
            match o with
            | Sum.inl a => Sum.inl a
            | Sum.inr ls => rmap (fun c' => c' :: ls) (destruct c))
          (Sum.inr List.nil) l with a' ls <;> erw [e] at e'
        Â· contradiction
        have := IH' m _ e
        revert e'
        cases destruct c <;> intro e' <;> [injection e'; injection e' with h']
        rw [â† h']
        simp [this]
    induction' h : parallel.aux2 l with a l'
    Â· exact lem1 _ _ âŸ¨a, hâŸ©
    Â· have H2 : corec parallel.aux1 (l, S) = think _ := by
        apply destruct_eq_think
        simp only [parallel.aux1, rmap, corec_eq]
        rw [h]
      rw [H2]
      refine @Computation.think_terminates _ _ ?_
      have := H1 _ h
      rcases Seq'.destruct S with (_ | âŸ¨_ | c, S'âŸ©) <;> simp [parallel.aux1] <;> apply IH <;>
        simp [this]","error:  don't know how to synthesize placeholder for argument 'c'
context:
Î± : Type u
Î² : Type v
lem1 :
  âˆ€ (l : List (Computation Î±)) (S : WSeq (Computation Î±)),
    (âˆƒ a, parallel.aux2 l = Sum.inl a) â†’ (corec parallel.aux1 (l, S)).Terminates
c : Computation Î±
T : c.Terminates
s : Computation Î±
IH : âˆ€ {l : List (Computation Î±)} {S : WSeq (Computation Î±)}, s âˆˆ l â†’ (corec parallel.aux1 (l, S)).Terminates
l : List (Computation Î±)
S : WSeq (Computation Î±)
m : s.think âˆˆ l
H1 : âˆ€ (l' : List (Computation Î±)), parallel.aux2 l = Sum.inr l' â†’ s âˆˆ l'
l' : List (Computation Î±)
h : parallel.aux2 l = Sum.inr l'
âŠ¢ Computation Î±","theorem terminates_parallel.aux :
    âˆ€ {l : List (Computation Î±)} {S c},
      c âˆˆ l â†’ Terminates c â†’ Terminates (corec parallel.aux1 (l, S)) ",":= by
  have lem1 :
    âˆ€ l S, (âˆƒ a : Î±, parallel.aux2 l = Sum.inl a) â†’ Terminates (corec parallel.aux1 (l, S)) := by
    intro l S e
    cases' e with a e
    have : corec parallel.aux1 (l, S) = return a := by
      apply destruct_eq_pure
      simp only [parallel.aux1, rmap, corec_eq]
      rw [e]
    rw [this]
    exact ret_terminates a
  intro l S c m T
  revert l S
  apply @terminatesRecOn _ _ c T _ _
  Â· intro a l S m
    apply lem1
    induction' l with c l IH <;> simp at m
    cases' m with e m
    Â· rw [â† e]
      simp only [parallel.aux2, rmap, List.foldr_cons, destruct_pure]
      split <;> simp
    Â· cases' IH m with a' e
      simp only [parallel.aux2, rmap, List.foldr_cons]
      simp? [parallel.aux2] at e says simp only [parallel.aux2, rmap] at e
      rw [e]
      exact âŸ¨a', rflâŸ©
  Â· intro s IH l S m
    have H1 : âˆ€ l', parallel.aux2 l = Sum.inr l' â†’ s âˆˆ l' := by
      induction' l with c l IH' <;> intro l' e' <;> simp at m
      cases' m with e m <;> simp [parallel.aux2] at e'
      Â· rw [â† e] at e'
        revert e'
        split
        Â· simp
        Â· simp only [destruct_think, Sum.inr.injEq]
          rintro rfl
          simp
      Â· induction' e : List.foldr (fun c o =>
            match o with
            | Sum.inl a => Sum.inl a
            | Sum.inr ls => rmap (fun c' => c' :: ls) (destruct c))
          (Sum.inr List.nil) l with a' ls <;> erw [e] at e'
        Â· contradiction
        have := IH' m _ e
        revert e'
        cases destruct c <;> intro e' <;> [injection e'; injection e' with h']
        rw [â† h']
        simp [this]
    induction' h : parallel.aux2 l with a l'
    Â· exact lem1 _ _ âŸ¨a, hâŸ©
    Â· have H2 : corec parallel.aux1 (l, S) = think _ := destruct_eq_think (by
        simp only [parallel.aux1, rmap, corec_eq]
        rw [h])
      rw [H2]
      refine @Computation.think_terminates _ _ ?_
      have := H1 _ h
      rcases Seq.destruct S with (_ | âŸ¨_ | c, S'âŸ©) <;> simp [parallel.aux1] <;> apply IH <;>
        simp [this]",refine theorem_theorem terminates_parallel.aux terminates_parallel.aux ?_
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.integral_cpow_mul_exp_neg_mul_Ioi,integral_cpow_mul_exp_neg_mul_Ioi,c47ebbbece0d449dca95c589513159cdc2bab40d,":= by
  have aux : (1 / r : â„‚) ^ a = 1 / r * (1 / r) ^ (a - 1) := by
    nth_rewrite 2 [â† cpow_one (1 / r : â„‚)]
    rw [â† cpow_add _ _ (one_div_ne_zero <| ofReal_ne_zero.mpr hr.ne'), add_sub_cancel'_right]
  calc
    _ = âˆ« (t : â„) in Ioi 0, (1 / r) ^ (a - 1) * (r * t) ^ (a - 1) * exp (-(r * t)) := by
      refine MeasureTheory.set_integral_congr measurableSet_Ioi (fun x (hx : 0 < x) â†¦ ?_)
      rw [mul_cpow_ofReal_nonneg hr.le hx.le, â† mul_assoc, one_div, â† ofReal_inv,
        â† mul_cpow_ofReal_nonneg (inv_pos.mpr hr).le hr.le, â† ofReal_mul râ»Â¹, inv_mul_cancel hr.ne',
        ofReal_one, one_cpow, one_mul]
    _ = |1 / r| * âˆ« (t : â„) in Ioi (r * 0), (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      simp_rw [â† ofReal_mul]
      rw [integral_comp_mul_left_Ioi (fun x â†¦ _ * x ^ (a - 1) * exp (-x)) _ hr, mul_zero,
        real_smul, â† one_div]
    _ = 1 / r * âˆ« (t : â„) in Ioi 0, (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      rw [congr_arg Ioi (mul_zero r), _root_.abs_of_nonneg (one_div_pos.mpr hr).le, ofReal_div,
        ofReal_one]
    _ = 1 / r * (1 / r : â„‚) ^ (a - 1) * (âˆ« (t : â„) in Ioi 0, t ^ (a - 1) * exp (-t)) := by
      simp_rw [â† integral_mul_left, mul_assoc]
    _ = (1 / r) ^ a * Gamma a := by
      rw [aux, Gamma_eq_integral ha]
      congr 2 with x
      rw [ofReal_exp, ofReal_neg, mul_comm]","warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
error:  unsolved goals
a : â„‚
r : â„
ha : 0 < a.re
hr : 0 < r
aux : (1 / â†‘r) ^ a = 1 / â†‘r * (1 / â†‘r) ^ (a - 1)
âŠ¢ â†‘(1 / r) * âˆ« (x : â„) in Ioi 0, (1 / â†‘r) ^ (a - 1) * â†‘x ^ (a - 1) * cexp (-â†‘x) =
    â†‘|1 / r| * âˆ« (t : â„) in Ioi 0, (1 / â†‘r) ^ (a - 1) * â†‘t ^ (a - 1) * cexp (-â†‘t)","lemma integral_cpow_mul_exp_neg_mul_Ioi {a : â„‚} {r : â„} (ha : 0 < a.re) (hr : 0 < r) :
    âˆ« (t : â„) in Ioi 0, t ^ (a - 1) * exp (-(r * t)) = (1 / r) ^ a * Gamma a ",":= by
  have aux : (1 / r : â„‚) ^ a = 1 / r * (1 / r) ^ (a - 1) := by
    nth_rewrite 2 [â† cpow_one (1 / r : â„‚)]
    rw [â† cpow_add _ _ (one_div_ne_zero <| ofReal_ne_zero.mpr hr.ne'), add_sub_cancel]
  calc
    _ = âˆ« (t : â„) in Ioi 0, (1 / r) ^ (a - 1) * (r * t) ^ (a - 1) * exp (-(r * t)) := by
      refine MeasureTheory.setIntegral_congr measurableSet_Ioi (fun x hx â†¦ ?_)
      rw [mem_Ioi] at hx
      rw [mul_cpow_ofReal_nonneg hr.le hx.le, â† mul_assoc, one_div, â† ofReal_inv,
        â† mul_cpow_ofReal_nonneg (inv_pos.mpr hr).le hr.le, â† ofReal_mul râ»Â¹, inv_mul_cancel hr.ne',
        ofReal_one, one_cpow, one_mul]
    _ = 1 / r * âˆ« (t : â„) in Ioi 0, (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      simp_rw [â† ofReal_mul]
      rw [integral_comp_mul_left_Ioi (fun x â†¦ _ * x ^ (a - 1) * exp (-x)) _ hr, mul_zero,
        real_smul, â† one_div, ofReal_div, ofReal_one]
    _ = 1 / r * (1 / r : â„‚) ^ (a - 1) * (âˆ« (t : â„) in Ioi 0, t ^ (a - 1) * exp (-t)) := by
      simp_rw [â† integral_mul_left, mul_assoc]
    _ = (1 / r) ^ a * Gamma a := by
      rw [aux, Gamma_eq_integral ha]
      congr 2 with x
      rw [ofReal_exp, ofReal_neg, mul_comm]",simp_rw [integral_cpow_mul_exp_neg_mul_Ioi]
Mathlib/Data/Rat/Cast/CharZero.lean,Rat.cast_inj,cast_inj,8d36235876dea0b8843e7cdecc85da3004503a83,"  | âŸ¨nâ‚, dâ‚, dâ‚0, câ‚âŸ©, âŸ¨nâ‚‚, dâ‚‚, dâ‚‚0, câ‚‚âŸ© => by
    refine âŸ¨fun h => ?_, congr_arg _âŸ©
    have dâ‚a : (dâ‚ : Î±) â‰  0 := Nat.cast_ne_zero.2 dâ‚0
    have dâ‚‚a : (dâ‚‚ : Î±) â‰  0 := Nat.cast_ne_zero.2 dâ‚‚0
    rw [num_den', num_den'] at h âŠ¢
    rw [cast_mk_of_ne_zero, cast_mk_of_ne_zero] at h <;>
      simp only [divInt_ofNat, Int.cast_ofNat, ne_eq, Nat.cast_eq_zero, dâ‚0, dâ‚‚0,
        not_false_eq_true] at h âŠ¢
    rwa [eq_div_iff_mul_eq dâ‚‚a, division_def, mul_assoc, (dâ‚.cast_commute (dâ‚‚ : Î±)).inv_leftâ‚€.eq, â†
      mul_assoc, â† division_def, eq_comm, eq_div_iff_mul_eq dâ‚a, eq_comm, â† Int.cast_natCast dâ‚, â†
      Int.cast_mul, â† Int.cast_natCast dâ‚‚, â† Int.cast_mul, Int.cast_inj, â† mkRat_eq_iff dâ‚0 dâ‚‚0]
      at h","error:  unknown identifier 'num_den''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.1171
F : Type u_1
Î¹ : Type u_2
Î± : Type u_3
Î² : Type u_4
instâœÂ¹ : DivisionRing Î±
instâœ : CharZero Î±
nâ‚ : â„¤
dâ‚ : â„•
dâ‚0 : dâ‚ â‰  0
câ‚ : nâ‚.natAbs.Coprime dâ‚
nâ‚‚ : â„¤
dâ‚‚ : â„•
dâ‚‚0 : dâ‚‚ â‰  0
câ‚‚ : nâ‚‚.natAbs.Coprime dâ‚‚
h : â†‘{ num := nâ‚, den := dâ‚, den_nz := dâ‚0, reduced := câ‚ } = â†‘{ num := nâ‚‚, den := dâ‚‚, den_nz := dâ‚‚0, reduced := câ‚‚ }
dâ‚a : â†‘dâ‚ â‰  0
dâ‚‚a : â†‘dâ‚‚ â‰  0
âŠ¢ { num := nâ‚, den := dâ‚, den_nz := dâ‚0, reduced := câ‚ } = { num := nâ‚‚, den := dâ‚‚, den_nz := dâ‚‚0, reduced := câ‚‚ }
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated","theorem cast_inj [CharZero Î±] : âˆ€ {m n : â„š}, (m : Î±) = n â†” m = n
","  | âŸ¨nâ‚, dâ‚, dâ‚0, câ‚âŸ©, âŸ¨nâ‚‚, dâ‚‚, dâ‚‚0, câ‚‚âŸ© => by
    refine âŸ¨fun h => ?_, congr_arg _âŸ©
    have dâ‚a : (dâ‚ : Î±) â‰  0 := Nat.cast_ne_zero.2 dâ‚0
    have dâ‚‚a : (dâ‚‚ : Î±) â‰  0 := Nat.cast_ne_zero.2 dâ‚‚0
    rw [mk'_eq_divInt, mk'_eq_divInt] at h âŠ¢
    rw [cast_divInt_of_ne_zero, cast_divInt_of_ne_zero] at h <;> simp [dâ‚0, dâ‚‚0] at h âŠ¢
    rwa [eq_div_iff_mul_eq dâ‚‚a, division_def, mul_assoc, (dâ‚.cast_commute (dâ‚‚ : Î±)).inv_leftâ‚€.eq, â†
      mul_assoc, â† division_def, eq_comm, eq_div_iff_mul_eq dâ‚a, eq_comm, â† Int.cast_natCast dâ‚, â†
      Int.cast_mul, â† Int.cast_natCast dâ‚‚, â† Int.cast_mul, Int.cast_inj, â† mkRat_eq_iff dâ‚0 dâ‚‚0]
      at h","refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©"
Mathlib/RingTheory/Ideal/Operations.lean,Ideal.subset_union_prime,subset_union_prime,982b8f87111061a0907be0b067e8c6cdaa0d0ff7,":= by
  suffices
    ((I : Set R) âŠ† f a âˆª f b âˆª â‹ƒ i âˆˆ (â†‘s : Set Î¹), f i) â†’ I â‰¤ f a âˆ¨ I â‰¤ f b âˆ¨ âˆƒ i âˆˆ s, I â‰¤ f i from
    âŸ¨this, fun h =>
      Or.casesOn h
        (fun h =>
          Set.Subset.trans h <|
            Set.Subset.trans (Set.subset_union_left _ _) (Set.subset_union_left _ _))
        fun h =>
        Or.casesOn h
          (fun h =>
            Set.Subset.trans h <|
              Set.Subset.trans (Set.subset_union_right _ _) (Set.subset_union_left _ _))
          fun âŸ¨i, his, hiâŸ© => by
          refine' Set.Subset.trans hi <| Set.Subset.trans _ <| Set.subset_union_right _ _;
            exact Set.subset_biUnion_of_mem (u := fun x â†¦ (f x : Set R)) (Finset.mem_coe.2 his)âŸ©
  generalize hn : s.card = n; intro h
  induction' n with n ih generalizing a b s
  Â· clear hp
    rw [Finset.card_eq_zero] at hn
    subst hn
    rw [Finset.coe_empty, Set.biUnion_empty, Set.union_empty, subset_union] at h
    simpa only [exists_prop, Finset.not_mem_empty, false_and_iff, exists_false, or_false_iff]
  classical
    replace hn : âˆƒ (i : Î¹) (t : Finset Î¹), i âˆ‰ t âˆ§ insert i t = s âˆ§ t.card = n :=
      Finset.card_eq_succ.1 hn
    rcases hn with âŸ¨i, t, hit, rfl, hnâŸ©
    replace hp : IsPrime (f i) âˆ§ âˆ€ x âˆˆ t, IsPrime (f x) := (t.forall_mem_insert _ _).1 hp
    by_cases Ht : âˆƒ j âˆˆ t, f j â‰¤ f i
    Â· obtain âŸ¨j, hjt, hfjiâŸ© : âˆƒ j âˆˆ t, f j â‰¤ f i := Ht
      obtain âŸ¨u, hju, rflâŸ© : âˆƒ u, j âˆ‰ u âˆ§ insert j u = t :=
        âŸ¨t.erase j, t.not_mem_erase j, Finset.insert_erase hjtâŸ©
      have hp' : âˆ€ k âˆˆ insert i u, IsPrime (f k) := by
        rw [Finset.forall_mem_insert] at hp âŠ¢
        exact âŸ¨hp.1, hp.2.2âŸ©
      have hiu : i âˆ‰ u := mt Finset.mem_insert_of_mem hit
      have hn' : (insert i u).card = n := by
        rwa [Finset.card_insert_of_not_mem] at hn âŠ¢
        exacts [hiu, hju]
      have h' : (I : Set R) âŠ† f a âˆª f b âˆª â‹ƒ k âˆˆ (â†‘(insert i u) : Set Î¹), f k := by
        rw [Finset.coe_insert] at h âŠ¢
        rw [Finset.coe_insert] at h
        simp only [Set.biUnion_insert] at h âŠ¢
        rw [â† Set.union_assoc (f i : Set R)] at h
        erw [Set.union_eq_self_of_subset_right hfji] at h
        exact h
      specialize ih hp' hn' h'
      refine' ih.imp id (Or.imp id (Exists.imp fun k => _))
      exact And.imp (fun hk => Finset.insert_subset_insert i (Finset.subset_insert j u) hk) id
    by_cases Ha : f a â‰¤ f i
    Â· have h' : (I : Set R) âŠ† f i âˆª f b âˆª â‹ƒ j âˆˆ (â†‘t : Set Î¹), f j := by
        rw [Finset.coe_insert, Set.biUnion_insert, â† Set.union_assoc,
          Set.union_right_comm (f a : Set R)] at h
        erw [Set.union_eq_self_of_subset_left Ha] at h
        exact h
      specialize ih hp.2 hn h'
      right
      rcases ih with (ih | ih | âŸ¨k, hkt, ihâŸ©)
      Â· exact Or.inr âŸ¨i, Finset.mem_insert_self i t, ihâŸ©
      Â· exact Or.inl ih
      Â· exact Or.inr âŸ¨k, Finset.mem_insert_of_mem hkt, ihâŸ©
    by_cases Hb : f b â‰¤ f i
    Â· have h' : (I : Set R) âŠ† f a âˆª f i âˆª â‹ƒ j âˆˆ (â†‘t : Set Î¹), f j := by
        rw [Finset.coe_insert, Set.biUnion_insert, â† Set.union_assoc,
          Set.union_assoc (f a : Set R)] at h
        erw [Set.union_eq_self_of_subset_left Hb] at h
        exact h
      specialize ih hp.2 hn h'
      rcases ih with (ih | ih | âŸ¨k, hkt, ihâŸ©)
      Â· exact Or.inl ih
      Â· exact Or.inr (Or.inr âŸ¨i, Finset.mem_insert_self i t, ihâŸ©)
      Â· exact Or.inr (Or.inr âŸ¨k, Finset.mem_insert_of_mem hkt, ihâŸ©)
    by_cases Hi : I â‰¤ f i
    Â· exact Or.inr (Or.inr âŸ¨i, Finset.mem_insert_self i t, HiâŸ©)
    have : Â¬I âŠ“ f a âŠ“ f b âŠ“ t.inf f â‰¤ f i := by
      simp only [hp.1.inf_le, hp.1.inf_le', not_or]
      exact âŸ¨âŸ¨âŸ¨Hi, HaâŸ©, HbâŸ©, HtâŸ©
    rcases Set.not_subset.1 this with âŸ¨r, âŸ¨âŸ¨âŸ¨hrI, hraâŸ©, hrbâŸ©, hrâŸ©, hriâŸ©
    by_cases HI : (I : Set R) âŠ† f a âˆª f b âˆª â‹ƒ j âˆˆ (â†‘t : Set Î¹), f j
    Â· specialize ih hp.2 hn HI
      rcases ih with (ih | ih | âŸ¨k, hkt, ihâŸ©)
      Â· left
        exact ih
      Â· right
        left
        exact ih
      Â· right
        right
        exact âŸ¨k, Finset.mem_insert_of_mem hkt, ihâŸ©
    exfalso
    rcases Set.not_subset.1 HI with âŸ¨s, hsI, hsâŸ©
    rw [Finset.coe_insert, Set.biUnion_insert] at h
    have hsi : s âˆˆ f i := ((h hsI).resolve_left (mt Or.inl hs)).resolve_right (mt Or.inr hs)
    rcases h (I.add_mem hrI hsI) with (âŸ¨ha | hbâŸ© | hi | ht)
    Â· exact hs (Or.inl <| Or.inl <| add_sub_cancel_left r s â–¸ (f a).sub_mem ha hra)
    Â· exact hs (Or.inl <| Or.inr <| add_sub_cancel_left r s â–¸ (f b).sub_mem hb hrb)
    Â· exact hri (add_sub_cancel_right r s â–¸ (f i).sub_mem hi hsi)
    Â· rw [Set.mem_iUnionâ‚‚] at ht
      rcases ht with âŸ¨j, hjt, hjâŸ©
      simp only [Finset.inf_eq_iInf, SetLike.mem_coe, Submodule.mem_iInf] at hr
      exact hs $ Or.inr $ Set.mem_biUnion hjt <|
        add_sub_cancel_left r s â–¸ (f j).sub_mem hj <| hr j hjt","error:  function expected at
  Set.subset_union_left ?m.379403
term has type
  ?m.379402 âˆˆ ?m.379400 âˆª ?m.379401
error:  function expected at
  Set.subset_union_left ?m.379445
term has type
  ?m.379444 âˆˆ ?m.379442 âˆª ?m.379443
error:  function expected at
  Set.subset_union_right ?m.379546
term has type
  ?m.379545 âˆˆ ?m.379543 âˆª ?m.379544
error:  function expected at
  Set.subset_union_left ?m.379588
term has type
  ?m.379587 âˆˆ ?m.379585 âˆª ?m.379586
error:  function expected at
  Set.subset_union_right ?m.379812
term has type
  ?m.379811 âˆˆ ?m.379809 âˆª ?m.379810
error:  type mismatch
  Set.subset_biUnion_of_mem (Finset.mem_coe.mpr his)
has type
  â†‘(f i) âŠ† â‹ƒ x âˆˆ â†‘s, â†‘(f x) : Prop
but is expected to have type
  Set R : Type u
error:  unsolved goals
Râœ : Type u
Î¹ : Type u_1
instâœÂ¹ : CommSemiring Râœ
Iâœ J K L : Ideal Râœ
R : Type u
instâœ : CommRing R
s : Finset Î¹
f : Î¹ â†’ Ideal R
a b : Î¹
hp : âˆ€ i âˆˆ s, (f i).IsPrime
I : Ideal R
âŠ¢ â†‘I âŠ† â†‘(f a) âˆª â†‘(f b) âˆª â‹ƒ i âˆˆ â†‘s, â†‘(f i) â†” I â‰¤ f a âˆ¨ I â‰¤ f b âˆ¨ âˆƒ i âˆˆ s, I â‰¤ f i","theorem subset_union_prime' {R : Type u} [CommRing R] {s : Finset Î¹} {f : Î¹ â†’ Ideal R} {a b : Î¹}
    (hp : âˆ€ i âˆˆ s, IsPrime (f i)) {I : Ideal R} :
    ((I : Set R) âŠ† f a âˆª f b âˆª â‹ƒ i âˆˆ (â†‘s : Set Î¹), f i) â†” I â‰¤ f a âˆ¨ I â‰¤ f b âˆ¨ âˆƒ i âˆˆ s, I â‰¤ f i ",":= by
  suffices
    ((I : Set R) âŠ† f a âˆª f b âˆª â‹ƒ i âˆˆ (â†‘s : Set Î¹), f i) â†’ I â‰¤ f a âˆ¨ I â‰¤ f b âˆ¨ âˆƒ i âˆˆ s, I â‰¤ f i from
    âŸ¨this, fun h =>
      Or.casesOn h
        (fun h =>
          Set.Subset.trans h <|
            Set.Subset.trans Set.subset_union_left Set.subset_union_left)
        fun h =>
        Or.casesOn h
          (fun h =>
            Set.Subset.trans h <|
              Set.Subset.trans Set.subset_union_right Set.subset_union_left)
          fun âŸ¨i, his, hiâŸ© => by
          refine Set.Subset.trans hi <| Set.Subset.trans ?_ Set.subset_union_right;
            exact Set.subset_biUnion_of_mem (u := fun x â†¦ (f x : Set R)) (Finset.mem_coe.2 his)âŸ©
  generalize hn : s.card = n; intro h
  induction' n with n ih generalizing a b s
  Â· clear hp
    rw [Finset.card_eq_zero] at hn
    subst hn
    rw [Finset.coe_empty, Set.biUnion_empty, Set.union_empty, subset_union] at h
    simpa only [exists_prop, Finset.not_mem_empty, false_and_iff, exists_false, or_false_iff]
  classical
    replace hn : âˆƒ (i : Î¹) (t : Finset Î¹), i âˆ‰ t âˆ§ insert i t = s âˆ§ t.card = n :=
      Finset.card_eq_succ.1 hn
    rcases hn with âŸ¨i, t, hit, rfl, hnâŸ©
    replace hp : IsPrime (f i) âˆ§ âˆ€ x âˆˆ t, IsPrime (f x) := (t.forall_mem_insert _ _).1 hp
    by_cases Ht : âˆƒ j âˆˆ t, f j â‰¤ f i
    Â· obtain âŸ¨j, hjt, hfjiâŸ© : âˆƒ j âˆˆ t, f j â‰¤ f i := Ht
      obtain âŸ¨u, hju, rflâŸ© : âˆƒ u, j âˆ‰ u âˆ§ insert j u = t :=
        âŸ¨t.erase j, t.not_mem_erase j, Finset.insert_erase hjtâŸ©
      have hp' : âˆ€ k âˆˆ insert i u, IsPrime (f k) := by
        rw [Finset.forall_mem_insert] at hp âŠ¢
        exact âŸ¨hp.1, hp.2.2âŸ©
      have hiu : i âˆ‰ u := mt Finset.mem_insert_of_mem hit
      have hn' : (insert i u).card = n := by
        rwa [Finset.card_insert_of_not_mem] at hn âŠ¢
        exacts [hiu, hju]
      have h' : (I : Set R) âŠ† f a âˆª f b âˆª â‹ƒ k âˆˆ (â†‘(insert i u) : Set Î¹), f k := by
        rw [Finset.coe_insert] at h âŠ¢
        rw [Finset.coe_insert] at h
        simp only [Set.biUnion_insert] at h âŠ¢
        rw [â† Set.union_assoc (f i : Set R)] at h
        erw [Set.union_eq_self_of_subset_right hfji] at h
        exact h
      specialize ih hp' hn' h'
      refine ih.imp id (Or.imp id (Exists.imp fun k => ?_))
      exact And.imp (fun hk => Finset.insert_subset_insert i (Finset.subset_insert j u) hk) id
    by_cases Ha : f a â‰¤ f i
    Â· have h' : (I : Set R) âŠ† f i âˆª f b âˆª â‹ƒ j âˆˆ (â†‘t : Set Î¹), f j := by
        rw [Finset.coe_insert, Set.biUnion_insert, â† Set.union_assoc,
          Set.union_right_comm (f a : Set R)] at h
        erw [Set.union_eq_self_of_subset_left Ha] at h
        exact h
      specialize ih hp.2 hn h'
      right
      rcases ih with (ih | ih | âŸ¨k, hkt, ihâŸ©)
      Â· exact Or.inr âŸ¨i, Finset.mem_insert_self i t, ihâŸ©
      Â· exact Or.inl ih
      Â· exact Or.inr âŸ¨k, Finset.mem_insert_of_mem hkt, ihâŸ©
    by_cases Hb : f b â‰¤ f i
    Â· have h' : (I : Set R) âŠ† f a âˆª f i âˆª â‹ƒ j âˆˆ (â†‘t : Set Î¹), f j := by
        rw [Finset.coe_insert, Set.biUnion_insert, â† Set.union_assoc,
          Set.union_assoc (f a : Set R)] at h
        erw [Set.union_eq_self_of_subset_left Hb] at h
        exact h
      specialize ih hp.2 hn h'
      rcases ih with (ih | ih | âŸ¨k, hkt, ihâŸ©)
      Â· exact Or.inl ih
      Â· exact Or.inr (Or.inr âŸ¨i, Finset.mem_insert_self i t, ihâŸ©)
      Â· exact Or.inr (Or.inr âŸ¨k, Finset.mem_insert_of_mem hkt, ihâŸ©)
    by_cases Hi : I â‰¤ f i
    Â· exact Or.inr (Or.inr âŸ¨i, Finset.mem_insert_self i t, HiâŸ©)
    have : Â¬I âŠ“ f a âŠ“ f b âŠ“ t.inf f â‰¤ f i := by
      simp only [hp.1.inf_le, hp.1.inf_le', not_or]
      exact âŸ¨âŸ¨âŸ¨Hi, HaâŸ©, HbâŸ©, HtâŸ©
    rcases Set.not_subset.1 this with âŸ¨r, âŸ¨âŸ¨âŸ¨hrI, hraâŸ©, hrbâŸ©, hrâŸ©, hriâŸ©
    by_cases HI : (I : Set R) âŠ† f a âˆª f b âˆª â‹ƒ j âˆˆ (â†‘t : Set Î¹), f j
    Â· specialize ih hp.2 hn HI
      rcases ih with (ih | ih | âŸ¨k, hkt, ihâŸ©)
      Â· left
        exact ih
      Â· right
        left
        exact ih
      Â· right
        right
        exact âŸ¨k, Finset.mem_insert_of_mem hkt, ihâŸ©
    exfalso
    rcases Set.not_subset.1 HI with âŸ¨s, hsI, hsâŸ©
    rw [Finset.coe_insert, Set.biUnion_insert] at h
    have hsi : s âˆˆ f i := ((h hsI).resolve_left (mt Or.inl hs)).resolve_right (mt Or.inr hs)
    rcases h (I.add_mem hrI hsI) with (âŸ¨ha | hbâŸ© | hi | ht)
    Â· exact hs (Or.inl <| Or.inl <| add_sub_cancel_left r s â–¸ (f a).sub_mem ha hra)
    Â· exact hs (Or.inl <| Or.inr <| add_sub_cancel_left r s â–¸ (f b).sub_mem hb hrb)
    Â· exact hri (add_sub_cancel_right r s â–¸ (f i).sub_mem hi hsi)
    Â· rw [Set.mem_iUnionâ‚‚] at ht
      rcases ht with âŸ¨j, hjt, hjâŸ©
      simp only [Finset.inf_eq_iInf, SetLike.mem_coe, Submodule.mem_iInf] at hr
      exact hs $ Or.inr $ Set.mem_biUnion hjt <|
        add_sub_cancel_left r s â–¸ (f j).sub_mem hj <| hr j hjt","simp only [subset_union_prime', subset_union_prime']"
Mathlib/LinearAlgebra/FiniteSpan.lean,LinearEquiv.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo,LinearEquiv.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  replace he : BijOn e Î¦ Î¦ := (hÎ¦â‚.injOn_iff_bijOn_of_mapsTo he).mp (e.injective.injOn Î¦)
  let e' := he.equiv
  have : Finite Î¦ := finite_coe_iff.mpr hÎ¦â‚
  obtain âŸ¨k, hkâ‚€, hkâŸ© := isOfFinOrder_of_finite e'
  refine âŸ¨k, hkâ‚€, ?_âŸ©
  ext m
  have hm : m âˆˆ span R Î¦ := hÎ¦â‚‚ â–¸ Submodule.mem_top
  simp only [mul_left_iterate, mul_one, LinearEquiv.coe_one, id_eq]
  refine Submodule.span_induction hm (fun x hx â†¦ ?_) (by simp)
    (fun x y hx hy â†¦ by simp [map_add, hx, hy]) (fun t x hx â†¦ by simp [map_smul, hx])
  rw [LinearEquiv.pow_apply, â† he.1.coe_iterate_restrict âŸ¨x, hxâŸ© k]
  replace hk : (e') ^ k = 1 := by simpa [IsPeriodicPt, IsFixedPt] using hk
  replace hk := Equiv.congr_fun hk âŸ¨x, hxâŸ©
  rwa [Equiv.Perm.coe_one, id_eq, Subtype.ext_iff, Equiv.Perm.coe_pow] at hk","error:  application type mismatch
  Injective.injOn (LinearEquiv.injective e) Î¦
argument
  Î¦
has type
  Set M : Type u_2
but is expected to have type
  ?m.1393 âˆˆ ?m.1392 : Prop","lemma LinearEquiv.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo
    {R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]
    {Î¦ : Set M} (hÎ¦â‚ : Î¦.Finite) (hÎ¦â‚‚ : span R Î¦ = âŠ¤) {e : M â‰ƒâ‚—[R] M} (he : MapsTo e Î¦ Î¦) :
    IsOfFinOrder e ",":= by
  replace he : BijOn e Î¦ Î¦ := (hÎ¦â‚.injOn_iff_bijOn_of_mapsTo he).mp e.injective.injOn
  let e' := he.equiv
  have : Finite Î¦ := finite_coe_iff.mpr hÎ¦â‚
  obtain âŸ¨k, hkâ‚€, hkâŸ© := isOfFinOrder_of_finite e'
  refine âŸ¨k, hkâ‚€, ?_âŸ©
  ext m
  have hm : m âˆˆ span R Î¦ := hÎ¦â‚‚ â–¸ Submodule.mem_top
  simp only [mul_left_iterate, mul_one, LinearEquiv.coe_one, id_eq]
  refine Submodule.span_induction hm (fun x hx â†¦ ?_) (by simp)
    (fun x y hx hy â†¦ by simp [map_add, hx, hy]) (fun t x hx â†¦ by simp [map_smul, hx])
  rw [LinearEquiv.pow_apply, â† he.1.coe_iterate_restrict âŸ¨x, hxâŸ© k]
  replace hk : (e') ^ k = 1 := by simpa [IsPeriodicPt, IsFixedPt] using hk
  replace hk := Equiv.congr_fun hk âŸ¨x, hxâŸ©
  rwa [Equiv.Perm.coe_one, id_eq, Subtype.ext_iff, Equiv.Perm.coe_pow] at hk",rw [isOfFinOrder_iff_isOfFinOrder]
Mathlib/Combinatorics/SimpleGraph/Finite.lean,SimpleGraph.card_commonNeighbors_le_degree_left,card_commonNeighbors_le_degree_left,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [â† card_neighborSet_eq_degree]
  exact Set.card_le_card (Set.inter_subset_left _ _)","error:  function expected at
  Set.inter_subset_left ?m.75842
term has type
  ?m.75841 âˆˆ ?m.75839","theorem card_commonNeighbors_le_degree_left [DecidableRel G.Adj] (v w : V) :
    Fintype.card (G.commonNeighbors v w) â‰¤ G.degree v ",":= by
  rw [â† card_neighborSet_eq_degree]
  exact Set.card_le_card Set.inter_subset_left",rw [commonNeighbors_le_degree_left]
Mathlib/Data/Seq/Computation.lean,Computation.length_pure,length_pure,3c930599229893e1b6a931304cf4efff4a01b172,":=
  let h := Computation.pure_terminates a
  Nat.eq_zero_of_le_zero <| Nat.find_min' ((terminates_def (pure a)).1 h) rfl",error:  unknown constant 'Computation.pure_terminates',theorem length_pure (a : Î±) : length (pure a) = 0 ,":=
  let h := Computation.ret_terminates a
  Nat.eq_zero_of_le_zero <| Nat.find_min' ((terminates_def (pure a)).1 h) rfl","simp [length_pure, length_pure]"
Mathlib/Analysis/InnerProductSpace/Basic.lean,Orthonormal.inner_right_finsupp,Orthonormal.inner_right_finsupp,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  classical!
  simpa [Finsupp.total_apply, Finsupp.inner_sum, orthonormal_iff_ite.mp hv] using Eq.symm",error:  `classical!` has been removed; use `classical` instead,"theorem Orthonormal.inner_right_finsupp {v : Î¹ â†’ E} (hv : Orthonormal ğ•œ v) (l : Î¹ â†’â‚€ ğ•œ) (i : Î¹) :
    âŸªv i, Finsupp.total Î¹ E ğ•œ v lâŸ« = l i ",":= by
  classical
  simpa [Finsupp.total_apply, Finsupp.inner_sum, orthonormal_iff_ite.mp hv] using Eq.symm","simp only [Orthonormal.inner_right_finsupp, Orthonormal.inner_right_finsupp, Orthonormal.inner_right_finsupp]"
Mathlib/RingTheory/Localization/Away/Basic.lean,exists_reduced_fraction',exists_reduced_fraction',3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  obtain âŸ¨âŸ¨aâ‚€, yâŸ©, HâŸ© := surj (Submonoid.powers x) b
  obtain âŸ¨d, hyâŸ© := (Submonoid.mem_powers_iff y.1 x).mp y.2
  have haâ‚€ : aâ‚€ â‰  0 := by
    haveI :=
      @isDomain_of_le_nonZeroDivisors B _ R _ _ _ _ (Submonoid.powers x) _
        (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
    simp only [map_zero, â† hy, map_pow] at H
    apply ((injective_iff_map_eq_zero' (algebraMap R B)).mp _ aâ‚€).mpr.mt
    Â· rw [â† H]
      apply mul_ne_zero hb (pow_ne_zero _ _)
      exact
        IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors B
          (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
          (mem_nonZeroDivisors_iff_ne_zero.mpr hx.ne_zero)
    Â· exact IsLocalization.injective B (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
  simp only [â† hy] at H
  obtain âŸ¨m, a, hyp1, hyp2âŸ© := WfDvdMonoid.max_power_factor haâ‚€ hx
  refine âŸ¨a, m - d, ?_âŸ©
  rw [â† mk'_one (M := Submonoid.powers x) B, selfZPow_pow_sub, selfZPow_natCast, selfZPow_natCast,
    â† map_pow _ _ d, mul_comm _ b, H, hyp2, map_mul, map_pow _ _ m]
  exact âŸ¨hyp1, congr_arg _ (IsLocalization.mk'_one _ _)âŸ©","error:  application type mismatch
  @isDomain_of_le_nonZeroDivisors B ?m.101151 R ?m.101152 ?m.101153 ?m.101154 ?m.101155 (Submonoid.powers x)
argument
  Submonoid.powers x
has type
  Submonoid R : Type u_1
but is expected to have type
  IsLocalization ?m.101155 B : Prop","theorem exists_reduced_fraction' {b : B} (hb : b â‰  0) (hx : Irreducible x) :
    âˆƒ (a : R) (n : â„¤), Â¬x âˆ£ a âˆ§ selfZPow x B n * algebraMap R B a = b ",":= by
  obtain âŸ¨âŸ¨aâ‚€, yâŸ©, HâŸ© := surj (Submonoid.powers x) b
  obtain âŸ¨d, hyâŸ© := (Submonoid.mem_powers_iff y.1 x).mp y.2
  have haâ‚€ : aâ‚€ â‰  0 := by
    haveI :=
      @isDomain_of_le_nonZeroDivisors B _ R _ _ _ (Submonoid.powers x) _
        (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
    simp only [map_zero, â† hy, map_pow] at H
    apply ((injective_iff_map_eq_zero' (algebraMap R B)).mp _ aâ‚€).mpr.mt
    Â· rw [â† H]
      apply mul_ne_zero hb (pow_ne_zero _ _)
      exact
        IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors B
          (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
          (mem_nonZeroDivisors_iff_ne_zero.mpr hx.ne_zero)
    Â· exact IsLocalization.injective B (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
  simp only [â† hy] at H
  obtain âŸ¨m, a, hyp1, hyp2âŸ© := WfDvdMonoid.max_power_factor haâ‚€ hx
  refine âŸ¨a, m - d, ?_âŸ©
  rw [â† mk'_one (M := Submonoid.powers x) B, selfZPow_pow_sub, selfZPow_natCast, selfZPow_natCast,
    â† map_pow _ _ d, mul_comm _ b, H, hyp2, map_mul, map_pow _ _ m]
  exact âŸ¨hyp1, congr_arg _ (IsLocalization.mk'_one _ _)âŸ©",rw [exists_reduced_fraction']
Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean,strictConvexOn_pow,strictConvexOn_pow,d1288d481cf0b7487a274181f0282b46161236a7,":= by
  apply StrictMonoOn.strictConvexOn_of_deriv (convex_Ici _) (continuousOn_pow _)
  rw [deriv_pow', interior_Ici]
  exact fun x (hx : 0 < x) y hy hxy =>
    mul_lt_mul_of_pos_left (pow_lt_pow_of_lt_left hxy hx.le <| Nat.sub_pos_of_lt hn)
      (Nat.cast_pos.2 <| zero_lt_two.trans_le hn)","warning:  `pow_lt_pow_of_lt_left` has been deprecated, use `pow_lt_pow_left` instead
error:  application type mismatch
  pow_lt_pow_of_lt_left hxy (LT.lt.le hx) (Nat.sub_pos_of_lt hn)
argument
  Nat.sub_pos_of_lt hn
has type
  0 < n - 1 : Prop
but is expected to have type
  n - 1 â‰  0 : Prop",theorem strictConvexOn_pow {n : â„•} (hn : 2 â‰¤ n) : StrictConvexOn â„ (Ici 0) fun x : â„ => x ^ n ,":= by
  apply StrictMonoOn.strictConvexOn_of_deriv (convex_Ici _) (continuousOn_pow _)
  rw [deriv_pow', interior_Ici]
  exact fun x (hx : 0 < x) y _ hxy => mul_lt_mul_of_pos_left
    (pow_lt_pow_left hxy hx.le <| Nat.sub_ne_zero_of_lt hn) (by positivity)","simp only [strictConvexOn_pow, strictConvexOn_pow]"
Mathlib/Geometry/Euclidean/MongePoint.lean,EuclideanGeometry.OrthocentricSystem.eq_insert_orthocenter,OrthocentricSystem.eq_insert_orthocenter,0f24aee7da46f85fee5cacc716172444ce31e582,":= by
  rcases ho with âŸ¨tâ‚€, htâ‚€o, htâ‚€sâŸ©
  rw [htâ‚€s] at ht
  rcases exists_of_range_subset_orthocentricSystem htâ‚€o ht t.Independent.injective with
    (âŸ¨iâ‚, iâ‚‚, iâ‚ƒ, jâ‚‚, jâ‚ƒ, hâ‚â‚‚, hâ‚â‚ƒ, hâ‚‚â‚ƒ, hâ‚â‚‚â‚ƒ, hâ‚, hjâ‚‚â‚ƒ, hâ‚‚, hâ‚ƒâŸ© | hs)
  Â· obtain âŸ¨jâ‚, hjâ‚â‚‚, hjâ‚â‚ƒ, hjâ‚â‚‚â‚ƒâŸ© :
        âˆƒ jâ‚ : Fin 3, jâ‚ â‰  jâ‚‚ âˆ§ jâ‚ â‰  jâ‚ƒ âˆ§ âˆ€ j : Fin 3, j = jâ‚ âˆ¨ j = jâ‚‚ âˆ¨ j = jâ‚ƒ := by
      clear hâ‚‚ hâ‚ƒ
      fin_cases jâ‚‚ <;> fin_cases jâ‚ƒ <;> simp at hjâ‚‚â‚ƒ âŠ¢
    suffices h : tâ‚€.points jâ‚ = t.orthocenter
    Â· have hui : (Set.univ : Set (Fin 3)) = {iâ‚, iâ‚‚, iâ‚ƒ} := by ext x; simpa using hâ‚â‚‚â‚ƒ x
      have huj : (Set.univ : Set (Fin 3)) = {jâ‚, jâ‚‚, jâ‚ƒ} := by ext x; simpa using hjâ‚â‚‚â‚ƒ x
      rw [â† h, htâ‚€s, â† Set.image_univ, huj, â† Set.image_univ, hui]
      simp_rw [Set.image_insert_eq, Set.image_singleton, hâ‚, â† hâ‚‚, â† hâ‚ƒ]
      rw [Set.insert_comm]
    exact
      (Triangle.orthocenter_replace_orthocenter_eq_point hjâ‚â‚‚ hjâ‚â‚ƒ hjâ‚‚â‚ƒ hâ‚â‚‚ hâ‚â‚ƒ hâ‚‚â‚ƒ hâ‚ hâ‚‚.symm
          hâ‚ƒ.symm).symm
  Â· rw [hs]
    convert htâ‚€s using 2
    exact Triangle.orthocenter_eq_of_range_eq hs","error:  unexpected token 'Â·'; expected 'by' or 'from'
error:  unsolved goals
case head.tail.head
V : Type u_1
P : Type u_2
instâœÂ³ : NormedAddCommGroup V
instâœÂ² : InnerProductSpace â„ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
s : Set P
t tâ‚€ : Triangle â„ P
ht : Set.range t.points âŠ† insert tâ‚€.orthocenter (Set.range tâ‚€.points)
htâ‚€o : tâ‚€.orthocenter âˆ‰ Set.range tâ‚€.points
htâ‚€s : s = insert tâ‚€.orthocenter (Set.range tâ‚€.points)
iâ‚ iâ‚‚ iâ‚ƒ : Fin 3
hâ‚â‚‚ : iâ‚ â‰  iâ‚‚
hâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ
hâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ
hâ‚â‚‚â‚ƒ : âˆ€ (i : Fin 3), i = iâ‚ âˆ¨ i = iâ‚‚ âˆ¨ i = iâ‚ƒ
hâ‚ : t.points iâ‚ = tâ‚€.orthocenter
hjâ‚‚â‚ƒ : True
âŠ¢ âˆƒ jâ‚, Â¬jâ‚ = 0 âˆ§ Â¬jâ‚ = 1 âˆ§ âˆ€ (j : Fin 3), j = jâ‚ âˆ¨ j = 0 âˆ¨ j = 1

case head.tail.tail.head
V : Type u_1
P : Type u_2
instâœÂ³ : NormedAddCommGroup V
instâœÂ² : InnerProductSpace â„ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
s : Set P
t tâ‚€ : Triangle â„ P
ht : Set.range t.points âŠ† insert tâ‚€.orthocenter (Set.range tâ‚€.points)
htâ‚€o : tâ‚€.orthocenter âˆ‰ Set.range tâ‚€.points
htâ‚€s : s = insert tâ‚€.orthocenter (Set.range tâ‚€.points)
iâ‚ iâ‚‚ iâ‚ƒ : Fin 3
hâ‚â‚‚ : iâ‚ â‰  iâ‚‚
hâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ
hâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ
hâ‚â‚‚â‚ƒ : âˆ€ (i : Fin 3), i = iâ‚ âˆ¨ i = iâ‚‚ âˆ¨ i = iâ‚ƒ
hâ‚ : t.points iâ‚ = tâ‚€.orthocenter
hjâ‚‚â‚ƒ : True
âŠ¢ âˆƒ jâ‚, Â¬jâ‚ = 0 âˆ§ Â¬jâ‚ = 2 âˆ§ âˆ€ (j : Fin 3), j = jâ‚ âˆ¨ j = 0 âˆ¨ j = 2

case tail.head.head
V : Type u_1
P : Type u_2
instâœÂ³ : NormedAddCommGroup V
instâœÂ² : InnerProductSpace â„ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
s : Set P
t tâ‚€ : Triangle â„ P
ht : Set.range t.points âŠ† insert tâ‚€.orthocenter (Set.range tâ‚€.points)
htâ‚€o : tâ‚€.orthocenter âˆ‰ Set.range tâ‚€.points
htâ‚€s : s = insert tâ‚€.orthocenter (Set.range tâ‚€.points)
iâ‚ iâ‚‚ iâ‚ƒ : Fin 3
hâ‚â‚‚ : iâ‚ â‰  iâ‚‚
hâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ
hâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ
hâ‚â‚‚â‚ƒ : âˆ€ (i : Fin 3), i = iâ‚ âˆ¨ i = iâ‚‚ âˆ¨ i = iâ‚ƒ
hâ‚ : t.points iâ‚ = tâ‚€.orthocenter
hjâ‚‚â‚ƒ : True
âŠ¢ âˆƒ jâ‚, Â¬jâ‚ = 1 âˆ§ Â¬jâ‚ = 0 âˆ§ âˆ€ (j : Fin 3), j = jâ‚ âˆ¨ j = 1 âˆ¨ j = 0

case tail.head.tail.tail.head
V : Type u_1
P : Type u_2
instâœÂ³ : NormedAddCommGroup V
instâœÂ² : InnerProductSpace â„ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
s : Set P
t tâ‚€ : Triangle â„ P
ht : Set.range t.points âŠ† insert tâ‚€.orthocenter (Set.range tâ‚€.points)
htâ‚€o : tâ‚€.orthocenter âˆ‰ Set.range tâ‚€.points
htâ‚€s : s = insert tâ‚€.orthocenter (Set.range tâ‚€.points)
iâ‚ iâ‚‚ iâ‚ƒ : Fin 3
hâ‚â‚‚ : iâ‚ â‰  iâ‚‚
hâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ
hâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ
hâ‚â‚‚â‚ƒ : âˆ€ (i : Fin 3), i = iâ‚ âˆ¨ i = iâ‚‚ âˆ¨ i = iâ‚ƒ
hâ‚ : t.points iâ‚ = tâ‚€.orthocenter
hjâ‚‚â‚ƒ : True
âŠ¢ âˆƒ jâ‚, Â¬jâ‚ = 1 âˆ§ Â¬jâ‚ = 2 âˆ§ âˆ€ (j : Fin 3), j = jâ‚ âˆ¨ j = 1 âˆ¨ j = 2

case tail.tail.head.head
V : Type u_1
P : Type u_2
instâœÂ³ : NormedAddCommGroup V
instâœÂ² : InnerProductSpace â„ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
s : Set P
t tâ‚€ : Triangle â„ P
ht : Set.range t.points âŠ† insert tâ‚€.orthocenter (Set.range tâ‚€.points)
htâ‚€o : tâ‚€.orthocenter âˆ‰ Set.range tâ‚€.points
htâ‚€s : s = insert tâ‚€.orthocenter (Set.range tâ‚€.points)
iâ‚ iâ‚‚ iâ‚ƒ : Fin 3
hâ‚â‚‚ : iâ‚ â‰  iâ‚‚
hâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ
hâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ
hâ‚â‚‚â‚ƒ : âˆ€ (i : Fin 3), i = iâ‚ âˆ¨ i = iâ‚‚ âˆ¨ i = iâ‚ƒ
hâ‚ : t.points iâ‚ = tâ‚€.orthocenter
hjâ‚‚â‚ƒ : True
âŠ¢ âˆƒ jâ‚, Â¬jâ‚ = 2 âˆ§ Â¬jâ‚ = 0 âˆ§ âˆ€ (j : Fin 3), j = jâ‚ âˆ¨ j = 2 âˆ¨ j = 0

case tail.tail.head.tail.head
V : Type u_1
P : Type u_2
instâœÂ³ : NormedAddCommGroup V
instâœÂ² : InnerProductSpace â„ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
s : Set P
t tâ‚€ : Triangle â„ P
ht : Set.range t.points âŠ† insert tâ‚€.orthocenter (Set.range tâ‚€.points)
htâ‚€o : tâ‚€.orthocenter âˆ‰ Set.range tâ‚€.points
htâ‚€s : s = insert tâ‚€.orthocenter (Set.range tâ‚€.points)
iâ‚ iâ‚‚ iâ‚ƒ : Fin 3
hâ‚â‚‚ : iâ‚ â‰  iâ‚‚
hâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ
hâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ
hâ‚â‚‚â‚ƒ : âˆ€ (i : Fin 3), i = iâ‚ âˆ¨ i = iâ‚‚ âˆ¨ i = iâ‚ƒ
hâ‚ : t.points iâ‚ = tâ‚€.orthocenter
hjâ‚‚â‚ƒ : True
âŠ¢ âˆƒ jâ‚, Â¬jâ‚ = 2 âˆ§ Â¬jâ‚ = 1 âˆ§ âˆ€ (j : Fin 3), j = jâ‚ âˆ¨ j = 2 âˆ¨ j = 1
error:  unsolved goals
case intro.intro.inr
V : Type u_1
P : Type u_2
instâœÂ³ : NormedAddCommGroup V
instâœÂ² : InnerProductSpace â„ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
s : Set P
t tâ‚€ : Triangle â„ P
ht : Set.range t.points âŠ† insert tâ‚€.orthocenter (Set.range tâ‚€.points)
htâ‚€o : tâ‚€.orthocenter âˆ‰ Set.range tâ‚€.points
htâ‚€s : s = insert tâ‚€.orthocenter (Set.range tâ‚€.points)
hs : Set.range t.points = Set.range tâ‚€.points
âŠ¢ s = insert t.orthocenter (Set.range t.points)","theorem OrthocentricSystem.eq_insert_orthocenter {s : Set P} (ho : OrthocentricSystem s)
    {t : Triangle â„ P} (ht : Set.range t.points âŠ† s) :
    s = insert t.orthocenter (Set.range t.points) ",":= by
  rcases ho with âŸ¨tâ‚€, htâ‚€o, htâ‚€sâŸ©
  rw [htâ‚€s] at ht
  rcases exists_of_range_subset_orthocentricSystem htâ‚€o ht t.independent.injective with
    (âŸ¨iâ‚, iâ‚‚, iâ‚ƒ, jâ‚‚, jâ‚ƒ, hâ‚â‚‚, hâ‚â‚ƒ, hâ‚‚â‚ƒ, hâ‚â‚‚â‚ƒ, hâ‚, hjâ‚‚â‚ƒ, hâ‚‚, hâ‚ƒâŸ© | hs)
  Â· obtain âŸ¨jâ‚, hjâ‚â‚‚, hjâ‚â‚ƒ, hjâ‚â‚‚â‚ƒâŸ© :
        âˆƒ jâ‚ : Fin 3, jâ‚ â‰  jâ‚‚ âˆ§ jâ‚ â‰  jâ‚ƒ âˆ§ âˆ€ j : Fin 3, j = jâ‚ âˆ¨ j = jâ‚‚ âˆ¨ j = jâ‚ƒ := by
      clear hâ‚‚ hâ‚ƒ
      fin_cases jâ‚‚ <;> fin_cases jâ‚ƒ <;> simp (config := {decide := true}) at hjâ‚‚â‚ƒ âŠ¢
    suffices h : tâ‚€.points jâ‚ = t.orthocenter by
      have hui : (Set.univ : Set (Fin 3)) = {iâ‚, iâ‚‚, iâ‚ƒ} := by ext x; simpa using hâ‚â‚‚â‚ƒ x
      have huj : (Set.univ : Set (Fin 3)) = {jâ‚, jâ‚‚, jâ‚ƒ} := by ext x; simpa using hjâ‚â‚‚â‚ƒ x
      rw [â† h, htâ‚€s, â† Set.image_univ, huj, â† Set.image_univ, hui]
      simp_rw [Set.image_insert_eq, Set.image_singleton, hâ‚, â† hâ‚‚, â† hâ‚ƒ]
      rw [Set.insert_comm]
    exact
      (Triangle.orthocenter_replace_orthocenter_eq_point hjâ‚â‚‚ hjâ‚â‚ƒ hjâ‚‚â‚ƒ hâ‚â‚‚ hâ‚â‚ƒ hâ‚‚â‚ƒ hâ‚ hâ‚‚.symm
          hâ‚ƒ.symm).symm
  Â· rw [hs]
    convert htâ‚€s using 2
    exact Triangle.orthocenter_eq_of_range_eq hs",simp [OrthocentricSystem.eq_insert_orthocenter]
Mathlib/NumberTheory/ArithmeticFunction.lean,ArithmeticFunction.cardFactors_eq_one_iff_prime,cardFactors_eq_one_iff_prime,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine' âŸ¨fun h => _, fun h => List.length_eq_one.2 âŸ¨n, factors_prime hâŸ©âŸ©
  cases' n with n
  Â· simp at h
  rcases List.length_eq_one.1 h with âŸ¨x, hxâŸ©
  rw [â† prod_factors n.succ_ne_zero, hx, List.prod_singleton]
  apply prime_of_mem_factors
  rw [hx, List.mem_singleton]","warning:  zeta does not have a doc string
warning:  Î¶ does not have a doc string
warning:  sigma does not have a doc string
warning:  Ïƒ does not have a doc string
warning:  cardFactors does not have a doc string
warning:  Î© does not have a doc string
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  n.succ
case succ.intro
R : Type u_1
n : â„•
h : Î© (n + 1) = 1
x : â„•
hx : (n + 1).factors = [x]
âŠ¢ Nat.Prime (n + 1)
warning:  cardDistinctFactors does not have a doc string
warning:  Ï‰ does not have a doc string
warning:  moebius does not have a doc string
warning:  Î¼ does not have a doc string",theorem cardFactors_eq_one_iff_prime {n : â„•} : Î© n = 1 â†” n.Prime ,":= by
  refine âŸ¨fun h => ?_, fun h => List.length_eq_one.2 âŸ¨n, factors_prime hâŸ©âŸ©
  cases' n with n
  Â· simp at h
  rcases List.length_eq_one.1 h with âŸ¨x, hxâŸ©
  rw [â† prod_factors n.add_one_ne_zero, hx, List.prod_singleton]
  apply prime_of_mem_factors
  rw [hx, List.mem_singleton]","refine âŸ¨fun h => ?_, fun h => ?_âŸ©"
Mathlib/Data/Finset/Lattice.lean,Finset.mem_of_max,mem_of_max,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' s with b s _ ih
  Â· intro _ H; cases H
  Â· intro a h
    by_cases p : b = a
    Â· induction p
      exact mem_insert_self b s
    Â· cases' max_choice (â†‘b) s.max with q q <;> rw [max_insert, q] at h
      Â· cases h
        cases p rfl
      Â· exact mem_insert_of_mem (ih h)","error:  dependent elimination failed, failed to solve equation
  some aâœ =
    Quot.lift (fun l â†¦ List.foldr (fun x x_1 â†¦ x âŠ” x_1) âŠ¥ l) â‹¯ (Multiset.map WithBot.some { val := b, nodup := s }.val)
error:  no goals to be solved","theorem mem_of_max {s : Finset Î±} : âˆ€ {a : Î±}, s.max = a â†’ a âˆˆ s ",":= by
  induction' s using Finset.induction_on with b s _ ih
  Â· intro _ H; cases H
  Â· intro a h
    by_cases p : b = a
    Â· induction p
      exact mem_insert_self b s
    Â· cases' max_choice (â†‘b) s.max with q q <;> rw [max_insert, q] at h
      Â· cases h
        cases p rfl
      Â· exact mem_insert_of_mem (ih h)",induction' s using Finset.induction_on with s
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.Measure.mkMetric_le_liminf_tsum,mkMetric_le_liminf_tsum,ced4d3c0af763b9fd00166e49cf999cf46c891cc,":= by
  haveI : âˆ€ n, Encodable (Î¹ n) := fun n => Encodable.ofCountable _
  simp only [mkMetric_apply]
  refine iSupâ‚‚_le fun Îµ hÎµ => _
  refine le_of_forall_le_of_dense fun c hc => _
  rcases ((frequently_lt_of_liminf_lt (by isBoundedDefault) hc).and_eventually
        ((hr.eventually (gt_mem_nhds hÎµ)).and (ht.and hst))).exists with
    âŸ¨n, hn, hrn, htn, hstnâŸ©
  set u : â„• â†’ Set X := fun j => â‹ƒ b âˆˆ decodeâ‚‚ (Î¹ n) j, t n b
  refine iInfâ‚‚_le_of_le u (by rwa [iUnion_decodeâ‚‚]) _
  refine iInf_le_of_le (fun j => _) _
  Â· rw [EMetric.diam_iUnion_mem_option]
    exact iSupâ‚‚_le fun _ _ => (htn _).trans hrn.le
  Â· calc
      (âˆ‘' j : â„•, â¨† _ : (u j).Nonempty, m (diam (u j))) = _ :=
        tsum_iUnion_decodeâ‚‚ (fun t : Set X => â¨† _ : t.Nonempty, m (diam t)) (by simp) _
      _ â‰¤ âˆ‘' i : Î¹ n, m (diam (t n i)) := ENNReal.tsum_le_tsum fun b => iSup_le fun _ => le_rfl
      _ â‰¤ c := hn.le","error:  don't know how to synthesize placeholder
context:
Î¹âœ : Type u_1
X : Type u_2
Y : Type u_3
instâœâ´ : EMetricSpace X
instâœÂ³ : EMetricSpace Y
instâœÂ² : MeasurableSpace X
instâœÂ¹ : BorelSpace X
Î² : Type u_4
Î¹ : Î² â†’ Type u_5
instâœ : âˆ€ (n : Î²), Countable (Î¹ n)
s : Set X
l : Filter Î²
r : Î² â†’ â„â‰¥0âˆ
hr : Tendsto r l (ğ“ 0)
t : (n : Î²) â†’ Î¹ n â†’ Set X
ht : âˆ€á¶  (n : Î²) in l, âˆ€ (i : Î¹ n), diam (t n i) â‰¤ r n
hst : âˆ€á¶  (n : Î²) in l, s âŠ† â‹ƒ i, t n i
m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ
this : (n : Î²) â†’ Encodable (Î¹ n)
Îµ : â„â‰¥0âˆ
hÎµ : 0 < Îµ
âŠ¢ â¨… t, â¨… (_ : s âŠ† iUnion t), â¨… (_ : âˆ€ (n : â„•), diam (t n) â‰¤ Îµ), âˆ‘' (n : â„•), â¨† (_ : (t n).Nonempty), m (diam (t n)) â‰¤
    liminf (fun n â†¦ âˆ‘' (i : Î¹ n), m (diam (t n i))) l
error:  unsolved goals
Î¹âœ : Type u_1
X : Type u_2
Y : Type u_3
instâœâ´ : EMetricSpace X
instâœÂ³ : EMetricSpace Y
instâœÂ² : MeasurableSpace X
instâœÂ¹ : BorelSpace X
Î² : Type u_4
Î¹ : Î² â†’ Type u_5
instâœ : âˆ€ (n : Î²), Countable (Î¹ n)
s : Set X
l : Filter Î²
r : Î² â†’ â„â‰¥0âˆ
hr : Tendsto r l (ğ“ 0)
t : (n : Î²) â†’ Î¹ n â†’ Set X
ht : âˆ€á¶  (n : Î²) in l, âˆ€ (i : Î¹ n), diam (t n i) â‰¤ r n
hst : âˆ€á¶  (n : Î²) in l, s âŠ† â‹ƒ i, t n i
m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ
this : (n : Î²) â†’ Encodable (Î¹ n)
âŠ¢ â¨† r,
      â¨† (_ : 0 < r),
        â¨… t,
          â¨… (_ : s âŠ† iUnion t), â¨… (_ : âˆ€ (n : â„•), diam (t n) â‰¤ r), âˆ‘' (n : â„•), â¨† (_ : (t n).Nonempty), m (diam (t n)) â‰¤
    liminf (fun n â†¦ âˆ‘' (i : Î¹ n), m (diam (t n i))) l","theorem mkMetric_le_liminf_tsum {Î² : Type*} {Î¹ : Î² â†’ Type*} [âˆ€ n, Countable (Î¹ n)] (s : Set X)
    {l : Filter Î²} (r : Î² â†’ â„â‰¥0âˆ) (hr : Tendsto r l (ğ“ 0)) (t : âˆ€ n : Î², Î¹ n â†’ Set X)
    (ht : âˆ€á¶  n in l, âˆ€ i, diam (t n i) â‰¤ r n) (hst : âˆ€á¶  n in l, s âŠ† â‹ƒ i, t n i) (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) :
    mkMetric m s â‰¤ liminf (fun n => âˆ‘' i, m (diam (t n i))) l ",":= by
  haveI : âˆ€ n, Encodable (Î¹ n) := fun n => Encodable.ofCountable _
  simp only [mkMetric_apply]
  refine iSupâ‚‚_le fun Îµ hÎµ => ?_
  refine le_of_forall_le_of_dense fun c hc => ?_
  rcases ((frequently_lt_of_liminf_lt (by isBoundedDefault) hc).and_eventually
        ((hr.eventually (gt_mem_nhds hÎµ)).and (ht.and hst))).exists with
    âŸ¨n, hn, hrn, htn, hstnâŸ©
  set u : â„• â†’ Set X := fun j => â‹ƒ b âˆˆ decodeâ‚‚ (Î¹ n) j, t n b
  refine iInfâ‚‚_le_of_le u (by rwa [iUnion_decodeâ‚‚]) ?_
  refine iInf_le_of_le (fun j => ?_) ?_
  Â· rw [EMetric.diam_iUnion_mem_option]
    exact iSupâ‚‚_le fun _ _ => (htn _).trans hrn.le
  Â· calc
      (âˆ‘' j : â„•, â¨† _ : (u j).Nonempty, m (diam (u j))) = _ :=
        tsum_iUnion_decodeâ‚‚ (fun t : Set X => â¨† _ : t.Nonempty, m (diam t)) (by simp) _
      _ â‰¤ âˆ‘' i : Î¹ n, m (diam (t n i)) := ENNReal.tsum_le_tsum fun b => iSup_le fun _ => le_rfl
      _ â‰¤ c := hn.le","simp only [mkMetric_le_liminf_tsum_iUnion, eventually_iSup]"
Mathlib/Computability/Primrec.lean,Primrec.bind_decode_iff,bind_decode_iff,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  âŸ¨fun h => by simpa [encodek] using h.compâ‚‚ fst ((@Primrec.encode Î² _).comp snd), fun h =>
    option_bind (Primrec.decode.comp snd) <| h.compâ‚‚ (fst.comp fst) sndâŸ©","error:  application type mismatch
  Primrecâ‚‚.compâ‚‚ h fst
argument
  fst
has type
  Primrec Prod.fst : Prop
but is expected to have type
  Primrecâ‚‚ ?m.86701 : Prop
error:  type mismatch
  hâœ
has type
  Primrecâ‚‚ fun a b â†¦ (decode (?m.86702 a b)).bind (f (?m.86701 a b)) : Prop
but is expected to have type
  Primrecâ‚‚ f : Prop","theorem bind_decode_iff {f : Î± â†’ Î² â†’ Option Ïƒ} :
    (Primrecâ‚‚ fun a n => (@decode Î² _ n).bind (f a)) â†” Primrecâ‚‚ f ",":=
  âŸ¨fun h => by simpa [encodek] using h.comp fst ((@Primrec.encode Î² _).comp snd), fun h =>
    option_bind (Primrec.decode.comp snd) <| h.comp (fst.comp fst) sndâŸ©","refine âŸ¨fun h => ?_, fun h => ?_âŸ©"
Mathlib/Analysis/NormedSpace/Exponential.lean,NormedSpace.expSeries_eq_expSeries,expSeries_eq_expSeries,41597a602a472e810aba18a1f457a0473cf36736,":= by
  ext c
  simp [expSeries, inv_nat_cast_smul_eq ğ•‚ â„š]","error:  no applicable extensionality theorem found for
  ğ”¸","theorem expSeries_eq_expSeries (n : â„•) (x : ğ”¸) :
    (expSeries ğ•‚ ğ”¸ n fun _ => x) = expSeries ğ•‚' ğ”¸ n fun _ => x ",":= by
  rw [expSeries_apply_eq, expSeries_apply_eq, inv_natCast_smul_eq ğ•‚ ğ•‚']","simp [expSeries_eq_expSeries, expSeries_eq_expSeries]"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le,norm_volume_sub_integral_face_upper_sub_lower_smul_le,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  set e : â„ â†’ (Fin n â†’ â„) â†’ (Fin (n + 1) â†’ â„) := i.insertNth (Î± := fun _ â†¦ â„)
  have Hl : I.lower i âˆˆ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i âˆˆ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : âˆ€ x âˆˆ Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) âŠ¥ (f âˆ˜ e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : âˆ€ y âˆˆ Box.Icc (I.face i),
      â€–f' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))â€– â‰¤
        2 * Îµ * diam (Box.Icc I) := fun y hy â†¦ by
    set g := fun y => f y - a - f' (y - x) with hg
    change âˆ€ y âˆˆ (Box.Icc I), â€–g yâ€– â‰¤ Îµ * â€–y - xâ€– at hÎµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to â€–g (e (I.lower i) y) - g (e (I.upper i) y)â€– â‰¤ _
    Â· congr 1
      have := Fin.insertNth_sub_same (Î± := fun _ â†¦ â„) i (I.upper i) (I.lower i) y
      simp only [â† this, f'.map_sub]; abel
    Â· have : âˆ€ z âˆˆ Icc (I.lower i) (I.upper i), e z y âˆˆ (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hÎµ : âˆ€ y âˆˆ (Box.Icc I), â€–g yâ€– â‰¤ Îµ * diam (Box.Icc I)
      Â· intro y hy
        refine' (hÎµ y hy).trans (mul_le_mul_of_nonneg_left _ h0.le)
        rw [â† dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.bounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hÎµ _ (this _ Hl)) (hÎµ _ (this _ Hu))
  calc
    â€–(âˆ j, (I.upper j - I.lower j)) â€¢ f' (Pi.single i 1) -
            (integral (I.face i) âŠ¥ (f âˆ˜ e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) âŠ¥ (f âˆ˜ e (I.lower i)) BoxAdditiveMap.volume)â€– =
        â€–integral.{0, u, u} (I.face i) âŠ¥
            (fun x : Fin n â†’ â„ =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volumeâ€– := by
      rw [â† integral_sub (Hi _ Hu) (Hi _ Hl), â† Box.volume_face_mul i, mul_smul, â† Box.volume_apply,
        â† BoxAdditiveMap.toSMul_apply, â† integral_const, â† BoxAdditiveMap.volume,
        â† integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(Â· âˆ˜ Â·), Pi.sub_def, â† f'.map_smul, â† Pi.single_smul', smul_eq_mul, mul_one]
    _ â‰¤ (volume (I.face i : Set (Fin n â†’ â„))).toReal * (2 * Îµ * c * (I.upper i - I.lower i)) := by
      refine' norm_integral_le_of_le_const (fun y hy => (this y hy).trans _) volume
      rw [mul_assoc (2 * Îµ)]
      exact mul_le_mul_of_nonneg_left (I.diam_Icc_le_of_distortion_le i hc)
        (mul_nonneg zero_le_two h0.le)
    _ = 2 * Îµ * c * âˆ j, (I.upper j - I.lower j) := by
      rw [â† Measure.toBoxAdditive_apply, Box.volume_apply, â† I.volume_face_mul i]
      ac_rfl","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case convert_2
E : Type u
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
n : â„•
instâœ : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f' : (Fin (n + 1) â†’ â„) â†’L[â„] E
x : Fin (n + 1) â†’ â„
hxI : x âˆˆ Box.Icc I
a : E
Îµ : â„
h0 : 0 < Îµ
c : â„â‰¥0
hc : I.distortion â‰¤ c
e : â„ â†’ (Fin n â†’ â„) â†’ Fin (n + 1) â†’ â„ := i.insertNth
Hl : I.lower i âˆˆ Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i âˆˆ Set.Icc (I.lower i) (I.upper i)
y : Fin n â†’ â„
hy : y âˆˆ Box.Icc (I.face i)
g : (Fin (n + 1) â†’ â„) â†’ E
hfc : ContinuousOn (fun y â†¦ a + f' (y - x) + g y) (Box.Icc I)
Hi :
  âˆ€ x_1 âˆˆ Set.Icc (I.lower i) (I.upper i),
    Integrable (I.face i) âŠ¥ ((fun y â†¦ a + f' (y - x) + g y) âˆ˜ e x_1) BoxAdditiveMap.volume
hg : g = fun y â†¦ (fun y â†¦ a + f' (y - x) + g y) y - a - f' (y - x)
this : âˆ€ z âˆˆ Set.Icc (I.lower i) (I.upper i), e z y âˆˆ Box.Icc I
hÎµ : âˆ€ y âˆˆ Box.Icc I, â€–g yâ€– â‰¤ Îµ * diam (Box.Icc I)
âŠ¢ â€–g (e (I.lower i) y) - g (e (I.upper i) y)â€– â‰¤ 2 * Îµ * diam (Box.Icc I)
error:  unsolved goals
E : Type u
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
n : â„•
instâœ : CompleteSpace E
I : Box (Fin (n + 1))
i : Fin (n + 1)
f : (Fin (n + 1) â†’ â„) â†’ E
f' : (Fin (n + 1) â†’ â„) â†’L[â„] E
hfc : ContinuousOn f (Box.Icc I)
x : Fin (n + 1) â†’ â„
hxI : x âˆˆ Box.Icc I
a : E
Îµ : â„
h0 : 0 < Îµ
hÎµ : âˆ€ y âˆˆ Box.Icc I, â€–f y - a - f' (y - x)â€– â‰¤ Îµ * â€–y - xâ€–
c : â„â‰¥0
hc : I.distortion â‰¤ c
e : â„ â†’ (Fin n â†’ â„) â†’ Fin (n + 1) â†’ â„ := i.insertNth
Hl : I.lower i âˆˆ Set.Icc (I.lower i) (I.upper i)
Hu : I.upper i âˆˆ Set.Icc (I.lower i) (I.upper i)
Hi : âˆ€ x âˆˆ Set.Icc (I.lower i) (I.upper i), Integrable (I.face i) âŠ¥ (f âˆ˜ e x) BoxAdditiveMap.volume
this :
  âˆ€ y âˆˆ Box.Icc (I.face i),
    â€–f' (Pi.single i (I.upper i - I.lower i)) - (f (e (I.upper i) y) - f (e (I.lower i) y))â€– â‰¤ 2 * Îµ * diam (Box.Icc I)
âŠ¢ â€–(âˆ j : Fin (n + 1), (I.upper j - I.lower j)) â€¢ f' (Pi.single i 1) -
        (integral (I.face i) âŠ¥ (f âˆ˜ e (I.upper i)) BoxAdditiveMap.volume -
          integral (I.face i) âŠ¥ (f âˆ˜ e (I.lower i)) BoxAdditiveMap.volume)â€– â‰¤
    2 * Îµ * â†‘c * âˆ j : Fin (n + 1), (I.upper j - I.lower j)","theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) â†’ â„) â†’ E}
    {f' : (Fin (n + 1) â†’ â„) â†’L[â„] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) â†’ â„}
    (hxI : x âˆˆ (Box.Icc I)) {a : E} {Îµ : â„} (h0 : 0 < Îµ)
    (hÎµ : âˆ€ y âˆˆ (Box.Icc I), â€–f y - a - f' (y - x)â€– â‰¤ Îµ * â€–y - xâ€–) {c : â„â‰¥0}
    (hc : I.distortion â‰¤ c) :
    â€–(âˆ j, (I.upper j - I.lower j)) â€¢ f' (Pi.single i 1) -
      (integral (I.face i) âŠ¥ (f âˆ˜ i.insertNth (Î± := fun _ â†¦ â„) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) âŠ¥ (f âˆ˜ i.insertNth (Î± := fun _ â†¦ â„) (I.lower i))
          BoxAdditiveMap.volume)â€– â‰¤
      2 * Îµ * c * âˆ j, (I.upper j - I.lower j) ",":= by
  set e : â„ â†’ (Fin n â†’ â„) â†’ (Fin (n + 1) â†’ â„) := i.insertNth (Î± := fun _ â†¦ â„)
  have Hl : I.lower i âˆˆ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)
  have Hu : I.upper i âˆˆ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)
  have Hi : âˆ€ x âˆˆ Icc (I.lower i) (I.upper i),
      Integrable.{0, u, u} (I.face i) âŠ¥ (f âˆ˜ e x) BoxAdditiveMap.volume := fun x hx =>
    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume
  have : âˆ€ y âˆˆ Box.Icc (I.face i),
      â€–f' (Pi.single i (I.upper i - I.lower i)) -
          (f (e (I.upper i) y) - f (e (I.lower i) y))â€– â‰¤
        2 * Îµ * diam (Box.Icc I) := fun y hy â†¦ by
    set g := fun y => f y - a - f' (y - x) with hg
    change âˆ€ y âˆˆ (Box.Icc I), â€–g yâ€– â‰¤ Îµ * â€–y - xâ€– at hÎµ
    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]
    convert_to â€–g (e (I.lower i) y) - g (e (I.upper i) y)â€– â‰¤ _
    Â· congr 1
      have := Fin.insertNth_sub_same (Î± := fun _ â†¦ â„) i (I.upper i) (I.lower i) y
      simp only [â† this, f'.map_sub]; abel
    Â· have : âˆ€ z âˆˆ Icc (I.lower i) (I.upper i), e z y âˆˆ (Box.Icc I) := fun z hz =>
        I.mapsTo_insertNth_face_Icc hz hy
      replace hÎµ : âˆ€ y âˆˆ (Box.Icc I), â€–g yâ€– â‰¤ Îµ * diam (Box.Icc I) := by
        intro y hy
        refine (hÎµ y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)
        rw [â† dist_eq_norm]
        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI
      rw [two_mul, add_mul]
      exact norm_sub_le_of_le (hÎµ _ (this _ Hl)) (hÎµ _ (this _ Hu))
  calc
    â€–(âˆ j, (I.upper j - I.lower j)) â€¢ f' (Pi.single i 1) -
            (integral (I.face i) âŠ¥ (f âˆ˜ e (I.upper i)) BoxAdditiveMap.volume -
              integral (I.face i) âŠ¥ (f âˆ˜ e (I.lower i)) BoxAdditiveMap.volume)â€– =
        â€–integral.{0, u, u} (I.face i) âŠ¥
            (fun x : Fin n â†’ â„ =>
              f' (Pi.single i (I.upper i - I.lower i)) -
                (f (e (I.upper i) x) - f (e (I.lower i) x)))
            BoxAdditiveMap.volumeâ€– := by
      rw [â† integral_sub (Hi _ Hu) (Hi _ Hl), â† Box.volume_face_mul i, mul_smul, â† Box.volume_apply,
        â† BoxAdditiveMap.toSMul_apply, â† integral_const, â† BoxAdditiveMap.volume,
        â† integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]
      simp only [(Â· âˆ˜ Â·), Pi.sub_def, â† f'.map_smul, â† Pi.single_smul', smul_eq_mul, mul_one]
    _ â‰¤ (volume (I.face i : Set (Fin n â†’ â„))).toReal * (2 * Îµ * c * (I.upper i - I.lower i)) := by
      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume
      rw [mul_assoc (2 * Îµ)]
      gcongr
      exact I.diam_Icc_le_of_distortion_le i hc
    _ = 2 * Îµ * c * âˆ j, (I.upper j - I.lower j) := by
      rw [â† Measure.toBoxAdditive_apply, Box.volume_apply, â† I.volume_face_mul i]
      ac_rfl","refine theorem_theorem_Icc _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  (fun y hy => ?_) (fun y hy => ?_) _ _"
Mathlib/LinearAlgebra/Charpoly/ToMatrix.lean,LinearMap.charpoly_toMatrix,charpoly_toMatrix,020f593358def5e1f64b452de28d39bc85502a09,":= by
  let A := toMatrix b b f
  let b' := chooseBasis R M
  let Î¹' := ChooseBasisIndex R M
  let A' := toMatrix b' b' f
  let e := Basis.indexEquiv b b'
  let Ï† := reindexLinearEquiv R R e e
  let Ï†â‚ := reindexLinearEquiv R R e (Equiv.refl Î¹')
  let Ï†â‚‚ := reindexLinearEquiv R R (Equiv.refl Î¹') (Equiv.refl Î¹')
  let Ï†â‚ƒ := reindexLinearEquiv R R (Equiv.refl Î¹') e
  let P := b.toMatrix b'
  let Q := b'.toMatrix b
  have hPQ : C.mapMatrix (Ï†â‚ P) * C.mapMatrix (Ï†â‚ƒ Q) = 1 := by
    rw [RingHom.mapMatrix_apply, RingHom.mapMatrix_apply, â† Matrix.map_mul,
      reindexLinearEquiv_mul R R, Basis.toMatrix_mul_toMatrix_flip,
      reindexLinearEquiv_one, â† RingHom.mapMatrix_apply, RingHom.map_one]
  calc
    A.charpoly = (reindex e e A).charpoly := (charpoly_reindex _ _).symm
    _ = det (scalar Î¹' X - C.mapMatrix (Ï† A)) := rfl
    _ = det (scalar Î¹' X - C.mapMatrix (Ï† (P * A' * Q))) := by
      rw [basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix]
    _ = det (scalar Î¹' X - C.mapMatrix (Ï†â‚ P * Ï†â‚‚ A' * Ï†â‚ƒ Q)) := by
      rw [reindexLinearEquiv_mul, reindexLinearEquiv_mul]
    _ = det (scalar Î¹' X - C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by simp
    _ = det (scalar Î¹' X * C.mapMatrix (Ï†â‚ P) * C.mapMatrix (Ï†â‚ƒ Q) -
          C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [Matrix.mul_assoc ((scalar Î¹') X), hPQ, Matrix.mul_one]
    _ = det (C.mapMatrix (Ï†â‚ P) * scalar Î¹' X * C.mapMatrix (Ï†â‚ƒ Q) -
          C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [scalar_commute _ commute_X]
    _ = det (C.mapMatrix (Ï†â‚ P) * (scalar Î¹' X - C.mapMatrix A') * C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [â† Matrix.sub_mul, â† Matrix.mul_sub]
    _ = det (C.mapMatrix (Ï†â‚ P)) * det (scalar Î¹' X - C.mapMatrix A') * det (C.mapMatrix (Ï†â‚ƒ Q)) :=
      by rw [det_mul, det_mul]
    _ = det (C.mapMatrix (Ï†â‚ P)) * det (C.mapMatrix (Ï†â‚ƒ Q)) * det (scalar Î¹' X - C.mapMatrix A') :=
      by ring
    _ = det (scalar Î¹' X - C.mapMatrix A') := by
      rw [â† det_mul, hPQ, det_one, one_mul]
    _ = f.charpoly := rfl","error:  unsolved goals
R : Type u_1
M : Type u_2
Mâ‚ : Type u_3
Mâ‚‚ : Type u_4
instâœÂ¹âµ : CommRing R
instâœÂ¹â´ : Nontrivial R
instâœÂ¹Â³ : AddCommGroup M
instâœÂ¹Â² : Module R M
instâœÂ¹Â¹ : Module.Free R M
instâœÂ¹â° : Module.Finite R M
instâœâ¹ : AddCommGroup Mâ‚
instâœâ¸ : Module R Mâ‚
instâœâ· : Module.Finite R Mâ‚
instâœâ¶ : Module.Free R Mâ‚
instâœâµ : AddCommGroup Mâ‚‚
instâœâ´ : Module R Mâ‚‚
instâœÂ³ : Module.Finite R Mâ‚‚
instâœÂ² : Module.Free R Mâ‚‚
f : M â†’â‚—[R] M
Î¹ : Type w
instâœÂ¹ : DecidableEq Î¹
instâœ : Fintype Î¹
b : Basis Î¹ R M
A : Matrix Î¹ Î¹ R := (toMatrix b b) f
b' : Basis (ChooseBasisIndex R M) R M := chooseBasis R M
Î¹' : Type u_2 := ChooseBasisIndex R M
A' : Matrix (ChooseBasisIndex R M) (ChooseBasisIndex R M) R := (toMatrix b' b') f
e : Î¹ â‰ƒ ChooseBasisIndex R M := b.indexEquiv b'
Ï† : Matrix Î¹ Î¹ R â‰ƒâ‚—[R] Matrix (ChooseBasisIndex R M) (ChooseBasisIndex R M) R := reindexLinearEquiv R R e e
Ï†â‚ : Matrix Î¹ Î¹' R â‰ƒâ‚—[R] Matrix (ChooseBasisIndex R M) Î¹' R := reindexLinearEquiv R R e (Equiv.refl Î¹')
Ï†â‚‚ : Matrix Î¹' Î¹' R â‰ƒâ‚—[R] Matrix Î¹' Î¹' R := reindexLinearEquiv R R (Equiv.refl Î¹') (Equiv.refl Î¹')
Ï†â‚ƒ : Matrix Î¹' Î¹ R â‰ƒâ‚—[R] Matrix Î¹' (ChooseBasisIndex R M) R := reindexLinearEquiv R R (Equiv.refl Î¹') e
P : Matrix Î¹ (ChooseBasisIndex R M) R := b.toMatrix â‡‘b'
Q : Matrix (ChooseBasisIndex R M) Î¹ R := b'.toMatrix â‡‘b
hPQ : C.mapMatrix (Ï†â‚ P) * C.mapMatrix (Ï†â‚ƒ Q) = 1
âŠ¢ ((diagonal fun x â†¦ X) - (Ï†â‚ P).map â‡‘C * (Ï†â‚‚ A').map â‡‘C * (Ï†â‚ƒ Q).map â‡‘C).det =
    ((diagonal fun x â†¦ X) - (Ï†â‚ P).map â‡‘C * A'.map â‡‘C * (Ï†â‚ƒ Q).map â‡‘C).det","theorem charpoly_toMatrix {Î¹ : Type w} [DecidableEq Î¹] [Fintype Î¹] (b : Basis Î¹ R M) :
    (toMatrix b b f).charpoly = f.charpoly ",":= by
  let A := toMatrix b b f
  let b' := chooseBasis R M
  let Î¹' := ChooseBasisIndex R M
  let A' := toMatrix b' b' f
  let e := Basis.indexEquiv b b'
  let Ï† := reindexLinearEquiv R R e e
  let Ï†â‚ := reindexLinearEquiv R R e (Equiv.refl Î¹')
  let Ï†â‚‚ := reindexLinearEquiv R R (Equiv.refl Î¹') (Equiv.refl Î¹')
  let Ï†â‚ƒ := reindexLinearEquiv R R (Equiv.refl Î¹') e
  let P := b.toMatrix b'
  let Q := b'.toMatrix b
  have hPQ : C.mapMatrix (Ï†â‚ P) * C.mapMatrix (Ï†â‚ƒ Q) = 1 := by
    rw [RingHom.mapMatrix_apply, RingHom.mapMatrix_apply, â† Matrix.map_mul,
      reindexLinearEquiv_mul R R, Basis.toMatrix_mul_toMatrix_flip,
      reindexLinearEquiv_one, â† RingHom.mapMatrix_apply, RingHom.map_one]
  calc
    A.charpoly = (reindex e e A).charpoly := (charpoly_reindex _ _).symm
    _ = det (scalar Î¹' X - C.mapMatrix (Ï† A)) := rfl
    _ = det (scalar Î¹' X - C.mapMatrix (Ï† (P * A' * Q))) := by
      rw [basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix]
    _ = det (scalar Î¹' X - C.mapMatrix (Ï†â‚ P * Ï†â‚‚ A' * Ï†â‚ƒ Q)) := by
      rw [reindexLinearEquiv_mul, reindexLinearEquiv_mul]
    _ = det (scalar Î¹' X - C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by simp [Ï†â‚‚]
    _ = det (scalar Î¹' X * C.mapMatrix (Ï†â‚ P) * C.mapMatrix (Ï†â‚ƒ Q) -
          C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [Matrix.mul_assoc ((scalar Î¹') X), hPQ, Matrix.mul_one]
    _ = det (C.mapMatrix (Ï†â‚ P) * scalar Î¹' X * C.mapMatrix (Ï†â‚ƒ Q) -
          C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [scalar_commute _ commute_X]
    _ = det (C.mapMatrix (Ï†â‚ P) * (scalar Î¹' X - C.mapMatrix A') * C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [â† Matrix.sub_mul, â† Matrix.mul_sub]
    _ = det (C.mapMatrix (Ï†â‚ P)) * det (scalar Î¹' X - C.mapMatrix A') * det (C.mapMatrix (Ï†â‚ƒ Q)) :=
      by rw [det_mul, det_mul]
    _ = det (C.mapMatrix (Ï†â‚ P)) * det (C.mapMatrix (Ï†â‚ƒ Q)) * det (scalar Î¹' X - C.mapMatrix A') :=
      by ring
    _ = det (scalar Î¹' X - C.mapMatrix A') := by
      rw [â† det_mul, hPQ, det_one, one_mul]
    _ = f.charpoly := rfl","rw [charpoly_toMatrix_eq_charpoly, charmatrix_eq_charpoly]"
Mathlib/Analysis/Complex/CauchyIntegral.lean,Complex.integral_boundary_rect_of_hasFDerivAt_real_off_countable,integral_boundary_rect_of_hasFDerivAt_real_off_countable,15fc142c24a81bf41226645e01783f71b75b9d92,":= by
  set e : (â„ Ã— â„) â‰ƒL[â„] â„‚ := equivRealProdCLM.symm
  have he : âˆ€ x y : â„, â†‘x + â†‘y * I = e (x, y) := fun x y => (mk_eq_add_mul_I x y).symm
  have heâ‚ : e (1, 0) = 1 := rfl; have heâ‚‚ : e (0, 1) = I := rfl
  simp only [he] at *
  set F : â„ Ã— â„ â†’ E := f âˆ˜ e
  set F' : â„ Ã— â„ â†’ â„ Ã— â„ â†’L[â„] E := fun p => (f' (e p)).comp (e : â„ Ã— â„ â†’L[â„] â„‚)
  have hF' : âˆ€ p : â„ Ã— â„, (-(I â€¢ F' p)) (1, 0) + F' p (0, 1) = -(I â€¢ f' (e p) 1 - f' (e p) I) := by
    rintro âŸ¨x, yâŸ©
    simp only [ContinuousLinearMap.neg_apply, ContinuousLinearMap.smul_apply,
      ContinuousLinearMap.comp_apply, ContinuousLinearEquiv.coe_coe, heâ‚, heâ‚‚, neg_add_eq_sub,
      neg_sub]
  set R : Set (â„ Ã— â„) := [[z.re, w.re]] Ã—Ë¢ [[w.im, z.im]]
  set t : Set (â„ Ã— â„) := e â»Â¹' s
  rw [uIcc_comm z.im] at Hc Hi; rw [min_comm z.im, max_comm z.im] at Hd
  have hR : e â»Â¹' ([[z.re, w.re]] Ã—â„‚ [[w.im, z.im]]) = R := rfl
  have htc : ContinuousOn F R := Hc.comp e.continuousOn hR.ge
  have htd :
    âˆ€ p âˆˆ Ioo (min z.re w.re) (max z.re w.re) Ã—Ë¢ Ioo (min w.im z.im) (max w.im z.im) \ t,
      HasFDerivAt F (F' p) p :=
    fun p hp => (Hd (e p) hp).comp p e.hasFDerivAt
  simp_rw [â† intervalIntegral.integral_smul, intervalIntegral.integral_symm w.im z.im, â†
    intervalIntegral.integral_neg, â† hF']
  refine' (integral2_divergence_prod_of_hasFDerivWithinAt_off_countable (fun p => -(I â€¢ F p)) F
    (fun p => -(I â€¢ F' p)) F' z.re w.im w.re z.im t (hs.preimage e.injective)
    (htc.const_smul _).neg htc (fun p hp => ((htd p hp).const_smul I).neg) htd _).symm
  rw [â† (volume_preserving_equiv_real_prod.symm _).integrableOn_comp_preimage
    (MeasurableEquiv.measurableEmbedding _)] at Hi
  simpa only [hF'] using Hi.neg","error:  unsolved goals
case mk
E : Type u
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„‚ E
instâœ : CompleteSpace E
f : â„‚ â†’ E
f' : â„‚ â†’ â„‚ â†’L[â„] E
z w : â„‚
s : Set â„‚
hs : s.Countable
Hc : ContinuousOn f ([[z.re, w.re]] Ã—â„‚ [[z.im, w.im]])
Hd : âˆ€ x âˆˆ Ioo (min z.re w.re) (max z.re w.re) Ã—â„‚ Ioo (min z.im w.im) (max z.im w.im) \ s, HasFDerivAt f (f' x) x
Hi : IntegrableOn (fun z â†¦ I â€¢ (f' z) 1 - (f' z) I) ([[z.re, w.re]] Ã—â„‚ [[z.im, w.im]]) volume
e : (â„ Ã— â„) â‰ƒL[â„] â„‚ := equivRealProdCLM.symm
heâ‚ : e (1, 0) = 1
heâ‚‚ : e (0, 1) = I
he : â„ â†’ â„ â†’ True
F : â„ Ã— â„ â†’ E := f âˆ˜ â‡‘e
F' : â„ Ã— â„ â†’ â„ Ã— â„ â†’L[â„] E := fun p â†¦ (f' (e p)).comp â†‘e
x y : â„
âŠ¢ (F' (x, y)) (0, 1) - I â€¢ (F' (x, y)) (1, 0) = (f' (e (x, y))) I - I â€¢ (f' (e (x, y))) 1","theorem integral_boundary_rect_of_hasFDerivAt_real_off_countable (f : â„‚ â†’ E) (f' : â„‚ â†’ â„‚ â†’L[â„] E)
    (z w : â„‚) (s : Set â„‚) (hs : s.Countable)
    (Hc : ContinuousOn f ([[z.re, w.re]] Ã—â„‚ [[z.im, w.im]]))
    (Hd : âˆ€ x âˆˆ Ioo (min z.re w.re) (max z.re w.re) Ã—â„‚ Ioo (min z.im w.im) (max z.im w.im) \ s,
      HasFDerivAt f (f' x) x)
    (Hi : IntegrableOn (fun z => I â€¢ f' z 1 - f' z I) ([[z.re, w.re]] Ã—â„‚ [[z.im, w.im]])) :
    (âˆ« x : â„ in z.re..w.re, f (x + z.im * I)) - (âˆ« x : â„ in z.re..w.re, f (x + w.im * I)) +
      I â€¢ (âˆ« y : â„ in z.im..w.im, f (re w + y * I)) -
      I â€¢ âˆ« y : â„ in z.im..w.im, f (re z + y * I) =
      âˆ« x : â„ in z.re..w.re, âˆ« y : â„ in z.im..w.im, I â€¢ f' (x + y * I) 1 - f' (x + y * I) I ",":= by
  set e : (â„ Ã— â„) â‰ƒL[â„] â„‚ := equivRealProdCLM.symm
  have he : âˆ€ x y : â„, â†‘x + â†‘y * I = e (x, y) := fun x y => (mk_eq_add_mul_I x y).symm
  have heâ‚ : e (1, 0) = 1 := rfl; have heâ‚‚ : e (0, 1) = I := rfl
  simp only [he] at *
  set F : â„ Ã— â„ â†’ E := f âˆ˜ e
  set F' : â„ Ã— â„ â†’ â„ Ã— â„ â†’L[â„] E := fun p => (f' (e p)).comp (e : â„ Ã— â„ â†’L[â„] â„‚)
  have hF' : âˆ€ p : â„ Ã— â„, (-(I â€¢ F' p)) (1, 0) + F' p (0, 1) = -(I â€¢ f' (e p) 1 - f' (e p) I) := by
    rintro âŸ¨x, yâŸ©
    simp only [F', ContinuousLinearMap.neg_apply, ContinuousLinearMap.smul_apply,
      ContinuousLinearMap.comp_apply, ContinuousLinearEquiv.coe_coe, heâ‚, heâ‚‚, neg_add_eq_sub,
      neg_sub]
  set R : Set (â„ Ã— â„) := [[z.re, w.re]] Ã—Ë¢ [[w.im, z.im]]
  set t : Set (â„ Ã— â„) := e â»Â¹' s
  rw [uIcc_comm z.im] at Hc Hi; rw [min_comm z.im, max_comm z.im] at Hd
  have hR : e â»Â¹' ([[z.re, w.re]] Ã—â„‚ [[w.im, z.im]]) = R := rfl
  have htc : ContinuousOn F R := Hc.comp e.continuousOn hR.ge
  have htd :
    âˆ€ p âˆˆ Ioo (min z.re w.re) (max z.re w.re) Ã—Ë¢ Ioo (min w.im z.im) (max w.im z.im) \ t,
      HasFDerivAt F (F' p) p :=
    fun p hp => (Hd (e p) hp).comp p e.hasFDerivAt
  simp_rw [â† intervalIntegral.integral_smul, intervalIntegral.integral_symm w.im z.im, â†
    intervalIntegral.integral_neg, â† hF']
  refine (integral2_divergence_prod_of_hasFDerivWithinAt_off_countable (fun p => -(I â€¢ F p)) F
    (fun p => -(I â€¢ F' p)) F' z.re w.im w.re z.im t (hs.preimage e.injective)
    (htc.const_smul _).neg htc (fun p hp => ((htd p hp).const_smul I).neg) htd ?_).symm
  rw [â† (volume_preserving_equiv_real_prod.symm _).integrableOn_comp_preimage
    (MeasurableEquiv.measurableEmbedding _)] at Hi
  simpa only [hF'] using Hi.neg","refine theorem_integral_boundary_rect_of_hasFDerivAt_real_off_hasFDerivAt_real_off_countable f z.re hs Hc
  Hc Hd Hi Hd"
Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean,Real.Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma,Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  let f : â„ â†’ â„ â†’ â„ â†’ â„ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : âˆ€ c u x : â„, x âˆˆ Ioi (0 : â„) â†’ 0 â‰¤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : âˆ€ c u : â„, âˆ€áµ x : â„ âˆ‚volume.restrict (Ioi 0), 0 â‰¤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    âˆ€ {c x : â„} (_ : 0 < c) (u : â„) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), â† exp_mul, â† rpow_mul hx.le]
    congr 2 <;> Â· field_simp [hc.ne']; ring
  have f_mem_Lp :
    âˆ€ {c u : â„} (hc : 0 < c) (hu : 0 < u),
      Memâ„’p (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) â‰  0 := by
      rwa [Ne.def, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) â‰  âˆ := ENNReal.ofReal_ne_top
    rw [â† memâ„’p_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memâ„’p_one_iff_integrable]
    Â· apply Integrable.congr (GammaIntegral_convergent hu)
      refine' eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => _
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    Â· refine' ContinuousOn.aestronglyMeasurable _ measurableSet_Ioi
      refine' (Continuous.continuousOn _).mul (ContinuousAt.continuousOn fun x hx => _)
      Â· exact continuous_exp.comp (continuous_const.mul continuous_id')
      Â· exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  Â· refine' set_integral_congr measurableSet_Ioi fun x hx => _
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [â† exp_add, â† add_mul, â† neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [â† rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  Â· rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact set_integral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx","error:  dsimp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.29992 â†’ ?m.29992 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.29994
s t a b : â„
hs : 0 < s
ht : 0 < t
ha : 0 < a
hb : 0 < b
hab : a + b = 1
f : â„ â†’ â„ â†’ â„ â†’ â„ := fun c u x â†¦ rexp (-c * x) * x ^ (c * (u - 1))
e : (1 / a).IsConjExponent (1 / b)
hab' : b = 1 - a
hst : 0 < a * s + b * t
posf : âˆ€ (c u x : â„), x âˆˆ Ioi 0 â†’ 0 â‰¤ f c u x
posf' : âˆ€ (c u : â„), âˆ€áµ (x : â„) âˆ‚volume.restrict (Ioi 0), 0 â‰¤ f c u x
fpow : âˆ€ {c x : â„}, 0 < c â†’ âˆ€ (u : â„), 0 < x â†’ rexp (-x) * x ^ (u - 1) = f c u x ^ (1 / c)
c u : â„
hc : 0 < c
hu : 0 < u
âŠ¢ ENNReal.ofReal (1 / c) â‰  0
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead","theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : â„} (hs : 0 < s) (ht : 0 < t)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    Gamma (a * s + b * t) â‰¤ Gamma s ^ a * Gamma t ^ b ",":= by
  let f : â„ â†’ â„ â†’ â„ â†’ â„ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : âˆ€ c u x : â„, x âˆˆ Ioi (0 : â„) â†’ 0 â‰¤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : âˆ€ c u : â„, âˆ€áµ x : â„ âˆ‚volume.restrict (Ioi 0), 0 â‰¤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    âˆ€ {c x : â„} (_ : 0 < c) (u : â„) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only [f]
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), â† exp_mul, â† rpow_mul hx.le]
    congr 2 <;> field_simp [hc.ne']; ring
  have f_mem_Lp :
    âˆ€ {c u : â„} (hc : 0 < c) (hu : 0 < u),
      Memâ„’p (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) â‰  0 := by
      rwa [Ne, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) â‰  âˆ := ENNReal.ofReal_ne_top
    rw [â† memâ„’p_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memâ„’p_one_iff_integrable]
    Â· apply Integrable.congr (GammaIntegral_convergent hu)
      refine eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => ?_
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    Â· refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
      refine (Continuous.continuousOn ?_).mul (ContinuousAt.continuousOn fun x hx => ?_)
      Â· exact continuous_exp.comp (continuous_const.mul continuous_id')
      Â· exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  Â· refine setIntegral_congr measurableSet_Ioi fun x hx => ?_
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [â† exp_add, â† add_mul, â† neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [â† rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  Â· rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact setIntegral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx","rw [Gamma_mul_add_mul_le_rpow_Gamma_mul_add_mul_le_rpow_Gamma_mul_add_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma
  s t a b hs ht hs ht ht hab, Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma
  s t a b ht ha hb hab, Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow]"
Mathlib/Topology/MetricSpace/Holder.lean,HolderOnWith.ediam_image_inter_le,ediam_image_inter_le,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  hf.ediam_image_le_of_subset_of_le (inter_subset_right _ _) <|
    (EMetric.diam_mono <| inter_subset_left _ _).trans hd","error:  function expected at
  inter_subset_right ?m.22067
term has type
  ?m.22066 âˆˆ ?m.22065
error:  function expected at
  inter_subset_left ?m.22143
term has type
  ?m.22142 âˆˆ ?m.22140","theorem ediam_image_inter_le_of_le (hf : HolderOnWith C r f s) {d : â„â‰¥0âˆ}
    (hd : EMetric.diam t â‰¤ d) : EMetric.diam (f '' (t âˆ© s)) â‰¤ (C : â„â‰¥0âˆ) * d ^ (r : â„) ",":=
  hf.ediam_image_le_of_subset_of_le inter_subset_right <|
    (EMetric.diam_mono inter_subset_left).trans hd","refine theorem_ediam_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image
  ediam_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image
  ediam_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image
  ediam_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image
  ediam_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image_image"
Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean,Finpartition.equitabilise_aux,equitabilise_aux,92beef58f265528359880ded59e9a73d818a6596,":= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  Â· refine' âŸ¨âŠ¥, by simp, _, by simpa using hs.symmâŸ©
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id.def, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      âŸ¨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _âŸ©
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 âˆ§ b = 0
  Â· simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (Î± := Finpartition âŠ¥) P
    exact âŸ¨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]âŸ©
  simp_rw [not_and_or, â† Ne.def, â† pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain âŸ¨hnâ‚€, hnâ‚, hnâ‚‚, hnâ‚ƒâŸ© : 0 < n âˆ§ n â‰¤ m + 1 âˆ§ n â‰¤ a * m + b * (m + 1) âˆ§
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, â† hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    Â· refine' âŸ¨m_pos, le_succ _, le_add_right (le_mul_of_pos_left â€¹0 < aâ€º), _âŸ©
      rw [tsub_add_eq_add_tsub (le_mul_of_pos_left h)]
    Â· refine' âŸ¨succ_pos', le_rfl, le_add_left (le_mul_of_pos_left <| hab.resolve_left â€¹Â¬0 < aâ€º), _âŸ©
      rw [â† add_tsub_assoc_of_le (le_mul_of_pos_left <| hab.resolve_left â€¹Â¬0 < aâ€º)]
  by_cases h : âˆ€ u âˆˆ P.parts, card u < m + 1
  Â· obtain âŸ¨t, hts, htnâŸ© := exists_smaller_set s n (hnâ‚‚.trans_eq hs)
    have ht : t.Nonempty := by rwa [â† card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff â€¹t âŠ† sâ€º, htn, hnâ‚ƒ]
    obtain âŸ¨R, hRâ‚, _, hRâ‚ƒâŸ© :=
      @ih (s \ t) (sdiff_ssubset hts â€¹t.Nonemptyâ€º) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine' âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), _, _, _âŸ©
    Â· simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => (card_le_of_subset <| sdiff_subset _ _).trans (lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    Â· rw [hRâ‚ƒ, if_pos ha]
    rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg ha, tsub_add_cancel_of_le]
    Â· exact hab.resolve_left ha
    Â· intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg  at h
  obtain âŸ¨u, huâ‚, huâ‚‚âŸ© := h
  obtain âŸ¨t, htu, htnâŸ© := exists_smaller_set _ _ (hnâ‚.trans huâ‚‚)
  have ht : t.Nonempty := by rwa [â† card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le huâ‚), htn, hnâ‚ƒ]
  obtain âŸ¨R, hRâ‚, hRâ‚‚, hRâ‚ƒâŸ© :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le huâ‚) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine' âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le huâ‚), _, _, _âŸ©
  Â· simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hRâ‚, htn, hn]
    exact ite_eq_or_eq _ _ _
  Â· conv in _ âˆˆ _ => rw [â† insert_erase huâ‚]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne.def, extend_parts]
    refine' âŸ¨_, fun x hx => (card_le_of_subset _).trans <| hRâ‚‚ x _âŸ©
    Â· simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id.def]
      obtain rfl | hut := eq_or_ne u t
      Â· rw [sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)]
        exact bot_le
      refine'
        (card_le_of_subset fun i => _).trans
          (hRâ‚‚ (u \ t) <| P.mem_avoid.2 âŸ¨u, huâ‚, fun i => hut <| i.antisymm htu, rflâŸ©)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id.def, not_or]
      exact fun hiâ‚ hiâ‚‚ hiâ‚ƒ =>
        âŸ¨âŸ¨hiâ‚, hiâ‚‚âŸ©, fun x hx hx' => hiâ‚ƒ _ hx <| hx'.trans <| sdiff_subset _ _âŸ©
    Â· apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      âŸ¨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) huâ‚ <| ne_of_mem_erase hx).sdiff_eq_leftâŸ©
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  Â· rw [hRâ‚ƒ, if_pos h]
  Â· rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)","error:  type mismatch
  hâœ
has type
  s.card = b : Prop
but is expected to have type
  (filter (fun i â†¦ i.card = 1) (Finset.map { toFun := singleton, inj' := â‹¯ } s)).card = b : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.6768 â†’ ?m.6768
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.12503 â†’ ?m.12503 â†’ Prop
error:  simp made no progress","theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    âˆƒ Q : Finpartition s,
      (âˆ€ x : Finset Î±, x âˆˆ Q.parts â†’ x.card = m âˆ¨ x.card = m + 1) âˆ§
        (âˆ€ x, x âˆˆ P.parts â†’ (x \ (Q.parts.filter fun y => y âŠ† x).biUnion id).card â‰¤ m) âˆ§
          (Q.parts.filter fun i => card i = m + 1).card = b ",":= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  Â· refine âŸ¨âŠ¥, by simp, ?_, by simpa [Finset.filter_true_of_mem] using hs.symmâŸ©
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      âŸ¨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _âŸ©
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 âˆ§ b = 0
  Â· simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (Î± := Finpartition âŠ¥) P
    exact âŸ¨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]âŸ©
  simp_rw [not_and_or, â† Ne.eq_def, â† pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain âŸ¨hnâ‚€, hnâ‚, hnâ‚‚, hnâ‚ƒâŸ© : 0 < n âˆ§ n â‰¤ m + 1 âˆ§ n â‰¤ a * m + b * (m + 1) âˆ§
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, â† hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    Â· refine âŸ¨m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ â€¹0 < aâ€º), ?_âŸ©
      rw [tsub_add_eq_add_tsub (Nat.le_mul_of_pos_left _ h)]
    Â· refine âŸ¨succ_pos', le_rfl,
        le_add_left (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º), ?_âŸ©
      rw [â† add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º)]
  by_cases h : âˆ€ u âˆˆ P.parts, card u < m + 1
  Â· obtain âŸ¨t, hts, htnâŸ© := exists_subset_card_eq (hnâ‚‚.trans_eq hs)
    have ht : t.Nonempty := by rwa [â† card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff â€¹t âŠ† sâ€º, htn, hnâ‚ƒ]
    obtain âŸ¨R, hRâ‚, _, hRâ‚ƒâŸ© :=
      @ih (s \ t) (sdiff_ssubset hts â€¹t.Nonemptyâ€º) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), ?_, ?_, ?_âŸ©
    Â· simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => (card_le_card sdiff_subset).trans (Nat.lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    Â· rw [hRâ‚ƒ, if_pos ha]
    rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg ha, tsub_add_cancel_of_le]
    Â· exact hab.resolve_left ha
    Â· intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg at h
  obtain âŸ¨u, huâ‚, huâ‚‚âŸ© := h
  obtain âŸ¨t, htu, htnâŸ© := exists_subset_card_eq (hnâ‚.trans huâ‚‚)
  have ht : t.Nonempty := by rwa [â† card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le huâ‚), htn, hnâ‚ƒ]
  obtain âŸ¨R, hRâ‚, hRâ‚‚, hRâ‚ƒâŸ© :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le huâ‚) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine
    âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le huâ‚), ?_, ?_, ?_âŸ©
  Â· simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hRâ‚, htn, hn]
    exact ite_eq_or_eq _ _ _
  Â· conv in _ âˆˆ _ => rw [â† insert_erase huâ‚]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne, extend_parts]
    refine âŸ¨?_, fun x hx => (card_le_card ?_).trans <| hRâ‚‚ x ?_âŸ©
    Â· simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id]
      obtain rfl | hut := eq_or_ne u t
      Â· rw [sdiff_eq_empty_iff_subset.2 subset_union_left]
        exact bot_le
      refine
        (card_le_card fun i => ?_).trans
          (hRâ‚‚ (u \ t) <| P.mem_avoid.2 âŸ¨u, huâ‚, fun i => hut <| i.antisymm htu, rflâŸ©)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id, not_or]
      exact fun hiâ‚ hiâ‚‚ hiâ‚ƒ =>
        âŸ¨âŸ¨hiâ‚, hiâ‚‚âŸ©, fun x hx hx' => hiâ‚ƒ _ hx <| hx'.trans sdiff_subsetâŸ©
    Â· apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      âŸ¨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) huâ‚ <| ne_of_mem_erase hx).sdiff_eq_leftâŸ©
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  Â· rw [hRâ‚ƒ, if_pos h]
  Â· rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)","refine âŸ¨Q, equitabilise_aux, equitabilise_aux, equitabilise_aux, hs, ?_âŸ©"
Mathlib/Computability/Primrec.lean,Nat.Primrec'.vec_iff,vec_iff,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  âŸ¨fun h => by simpa using Primrec.vector_ofFn fun i => to_prim (h i), fun h i =>
    of_prim <| Primrec.vector_get.compâ‚‚ h (.const i)âŸ©","error:  application type mismatch
  Primrecâ‚‚.compâ‚‚ Primrec.vector_get h
argument
  h
has type
  Primrec f : Prop
but is expected to have type
  Primrecâ‚‚ ?m.304121 : Prop",theorem vec_iff {m n f} : @Vec m n f â†” Primrec f ,":=
  âŸ¨fun h => by simpa using Primrec.vector_ofFn fun i => to_prim (h i), fun h i =>
    of_prim <| Primrec.vector_get.comp h (.const i)âŸ©","refine âŸ¨fun h => ?_, fun h => ?_âŸ©"
Mathlib/Analysis/Convex/Segment.lean,openSegment_subset_union,openSegment_subset_union,ed737e5773cdf087080f52542509535e7446ced4,":= by
  rcases hz with âŸ¨c, rflâŸ©
  simp only [openSegment_eq_image_lineMap, â† mapsTo']
  rintro a âŸ¨hâ‚€, hâ‚âŸ©
  rcases lt_trichotomy a c with (hac | rfl | hca)
  Â· right
    left
    have hc : 0 < c := hâ‚€.trans hac
    refine' âŸ¨a / c, âŸ¨div_pos hâ‚€ hc, (div_lt_one hc).2 hacâŸ©, _âŸ©
    simp only [â† homothety_eq_lineMap, â† homothety_mul_apply, div_mul_cancel _ hc.ne']
  Â· left
    rfl
  Â· right
    right
    have hc : 0 < 1 - c := sub_pos.2 (hca.trans hâ‚)
    simp only [â† lineMap_apply_one_sub y]
    refine'
      âŸ¨(a - c) / (1 - c), âŸ¨div_pos (sub_pos.2 hca) hc, (div_lt_one hc).2 <| sub_lt_sub_right hâ‚ _âŸ©,
        _âŸ©
    simp only [â† homothety_eq_lineMap, â† homothety_mul_apply, sub_mul, one_mul,
      div_mul_cancel _ hc.ne', sub_sub_sub_cancel_right]","warning:  segment does not have a doc string
error:  application type mismatch
  div_mul_cancel ?m.283314 (LT.lt.ne' hc)
argument
  LT.lt.ne' hc
has type
  c â‰  0 : Prop
but is expected to have type
  ?m.283312 : Type ?u.283311
error:  unsolved goals
case intro.intro.inl.h.h
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
G : Type u_4
Î¹ : Type u_5
Ï€ : Î¹ â†’ Type u_6
instâœÂ² : LinearOrderedField ğ•œ
instâœÂ¹ : AddCommGroup E
instâœ : Module ğ•œ E
xâœ yâœ z x y : E
c a : ğ•œ
hâ‚€ : 0 < a
hâ‚ : a < 1
hac : a < c
hc : 0 < c
âŠ¢ (homothety x (a / c * c)) y = (homothety x a) y
error:  application type mismatch
  div_mul_cancel ?m.286960 (LT.lt.ne' hc)
argument
  LT.lt.ne' hc
has type
  1 - c â‰  0 : Prop
but is expected to have type
  ?m.286958 : Type ?u.286957
error:  unsolved goals
case intro.intro.inr.inr.h.h
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
G : Type u_4
Î¹ : Type u_5
Ï€ : Î¹ â†’ Type u_6
instâœÂ² : LinearOrderedField ğ•œ
instâœÂ¹ : AddCommGroup E
instâœ : Module ğ•œ E
xâœ yâœ z x y : E
c a : ğ•œ
hâ‚€ : 0 < a
hâ‚ : a < 1
hca : c < a
hc : 0 < 1 - c
âŠ¢ (homothety y (1 - c - (a - c) / (1 - c) * (1 - c))) x = (homothety y (1 - a)) x","theorem openSegment_subset_union (x y : E) {z : E} (hz : z âˆˆ range (lineMap x y : ğ•œ â†’ E)) :
    openSegment ğ•œ x y âŠ† insert z (openSegment ğ•œ x z âˆª openSegment ğ•œ z y) ",":= by
  rcases hz with âŸ¨c, rflâŸ©
  simp only [openSegment_eq_image_lineMap, â† mapsTo']
  rintro a âŸ¨hâ‚€, hâ‚âŸ©
  rcases lt_trichotomy a c with (hac | rfl | hca)
  Â· right
    left
    have hc : 0 < c := hâ‚€.trans hac
    refine âŸ¨a / c, âŸ¨div_pos hâ‚€ hc, (div_lt_one hc).2 hacâŸ©, ?_âŸ©
    simp only [â† homothety_eq_lineMap, â† homothety_mul_apply, div_mul_cancelâ‚€ _ hc.ne']
  Â· left
    rfl
  Â· right
    right
    have hc : 0 < 1 - c := sub_pos.2 (hca.trans hâ‚)
    simp only [â† lineMap_apply_one_sub y]
    refine
      âŸ¨(a - c) / (1 - c), âŸ¨div_pos (sub_pos.2 hca) hc, (div_lt_one hc).2 <| sub_lt_sub_right hâ‚ _âŸ©,
        ?_âŸ©
    simp only [â† homothety_eq_lineMap, â† homothety_mul_apply, sub_mul, one_mul,
      div_mul_cancelâ‚€ _ hc.ne', sub_sub_sub_cancel_right]","simp only [mem_range, lineMap_apply, openSegment_subset_union] at hz"
Mathlib/Analysis/Convex/Independent.lean,convexIndependent_iff_finset,convexIndependent_iff_finset,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine âŸ¨fun hc s x hx => hc s x ?_, fun h s x hx => ?_âŸ©
  Â· rwa [Finset.coe_image] at hx
  have hp : Injective p := by
    rintro a b hab
    rw [â† mem_singleton]
    refine h {b} a ?_
    rw [hab, image_singleton, coe_singleton, convexHull_singleton]
    exact Set.mem_singleton _
  rw [convexHull_eq_union_convexHull_finite_subsets] at hx
  simp_rw [Set.mem_iUnion] at hx
  obtain âŸ¨t, ht, hxâŸ© := hx
  rw [â† hp.mem_set_image]
  refine ht ?_
  suffices x âˆˆ t.preimage p (hp.injOn _) by rwa [mem_preimage, â† mem_coe] at this
  refine h _ x ?_
  rwa [t.image_preimage p (hp.injOn _), filter_true_of_mem]
  exact fun y hy => s.image_subset_range p (ht <| mem_coe.2 hy)","error:  application type mismatch
  t.preimage p â‹¯
argument
  Injective.injOn hp ?m.23738
has type
  âˆ€ â¦ƒxâ‚‚ : Î¹â¦„, xâ‚‚ âˆˆ ?m.23736 â†’ p ?m.23737 = p xâ‚‚ â†’ ?m.23737 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn p (p â»Â¹' â†‘t) : Prop
error:  application type mismatch
  image_preimage p t (Injective.injOn hp ?m.24165)
argument
  Injective.injOn hp ?m.24165
has type
  âˆ€ â¦ƒxâ‚‚ : Î¹â¦„, xâ‚‚ âˆˆ ?m.24163 â†’ p ?m.24164 = p xâ‚‚ â†’ ?m.24164 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn p (p â»Â¹' â†‘t) : Prop","theorem convexIndependent_iff_finset {p : Î¹ â†’ E} :
    ConvexIndependent ğ•œ p â†”
      âˆ€ (s : Finset Î¹) (x : Î¹), p x âˆˆ convexHull ğ•œ (s.image p : Set E) â†’ x âˆˆ s ",":= by
  refine âŸ¨fun hc s x hx => hc s x ?_, fun h s x hx => ?_âŸ©
  Â· rwa [Finset.coe_image] at hx
  have hp : Injective p := by
    rintro a b hab
    rw [â† mem_singleton]
    refine h {b} a ?_
    rw [hab, image_singleton, coe_singleton, convexHull_singleton]
    exact Set.mem_singleton _
  rw [convexHull_eq_union_convexHull_finite_subsets] at hx
  simp_rw [Set.mem_iUnion] at hx
  obtain âŸ¨t, ht, hxâŸ© := hx
  rw [â† hp.mem_set_image]
  refine ht ?_
  suffices x âˆˆ t.preimage p hp.injOn by rwa [mem_preimage, â† mem_coe] at this
  refine h _ x ?_
  rwa [t.image_preimage p hp.injOn, filter_true_of_mem]
  exact fun y hy => s.image_subset_range p (ht <| mem_coe.2 hy)","simp only [convexIndependent_iff_finset, convexHull_image]"
Mathlib/Logic/Equiv/Set.lean,Equiv.swap_bijOn_self,Equiv.swap_bijOn_self,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  refine âŸ¨fun x hx â†¦ ?_, (Equiv.injective _).injOn _, fun x hx â†¦ ?_âŸ©
  Â· obtain (rfl | hxa) := eq_or_ne x a; rwa [swap_apply_left, â† hs]
    obtain (rfl | hxb) := eq_or_ne x b; rwa [swap_apply_right, hs]
    rwa [swap_apply_of_ne_of_ne hxa hxb]
  obtain (rfl | hxa) := eq_or_ne x a; simp [hs.1 hx]
  obtain (rfl | hxb) := eq_or_ne x b; simp [hs.2 hx]
  exact âŸ¨x, hx, swap_apply_of_ne_of_ne hxa hxbâŸ©","error:  application type mismatch
  And.intro (Injective.injOn (Equiv.injective ?m.64892) ?m.64914)
argument
  Injective.injOn (Equiv.injective ?m.64892) ?m.64914
has type
  âˆ€ â¦ƒxâ‚‚ : ?m.64905â¦„, xâ‚‚ âˆˆ ?m.64912 â†’ ?m.64892 ?m.64913 = ?m.64892 xâ‚‚ â†’ ?m.64913 = xâ‚‚ : Prop
but is expected to have type
  InjOn (â‡‘(swap a b)) s : Prop",theorem Equiv.swap_bijOn_self (hs : a âˆˆ s â†” b âˆˆ s) : BijOn (Equiv.swap a b) s s ,":= by
  refine âŸ¨fun x hx â†¦ ?_, (Equiv.injective _).injOn, fun x hx â†¦ ?_âŸ©
  Â· obtain (rfl | hxa) := eq_or_ne x a
    Â· rwa [swap_apply_left, â† hs]
    obtain (rfl | hxb) := eq_or_ne x b
    Â· rwa [swap_apply_right, hs]
    rwa [swap_apply_of_ne_of_ne hxa hxb]
  obtain (rfl | hxa) := eq_or_ne x a
  Â· simp [hs.1 hx]
  obtain (rfl | hxb) := eq_or_ne x b
  Â· simp [hs.2 hx]
  exact âŸ¨x, hx, swap_apply_of_ne_of_ne hxa hxbâŸ©","simp only [BijOn, swap_bijOn_self, BijOn.swap_swap_bijOn_self, Equiv.swap_swap_bijOn_self]"
Mathlib/CategoryTheory/Galois/Decomposition.lean,CategoryTheory.PreGaloisCategory.exists_galois_representative,exists_galois_representative,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain âŸ¨A, u, a, h1, h2, h3âŸ© := fiber_in_connected_component F (selfProd F X)
    (mkSelfProdFib F X)
  use A
  use a
  constructor
  Â· refine (isGalois_iff_pretransitive F A).mpr âŸ¨fun x y â†¦ ?_âŸ©
    obtain âŸ¨fi1, hfi1âŸ© := subobj_selfProd_trans h1 x
    obtain âŸ¨fi2, hfi2âŸ© := subobj_selfProd_trans h1 y
    use fi1 â‰ªâ‰« fi2.symm
    show F.map (fi1.hom â‰« fi2.inv) x = y
    simp only [map_comp, FintypeCat.comp_apply]
    rw [hfi1, â† hfi2]
    exact congr_fun (F.mapIso fi2).hom_inv_id y
  Â· refine âŸ¨evaluationInjective_of_isConnected F A X a, ?_âŸ©
    intro x
    use u â‰« Pi.Ï€ _ x
    exact (selfProdProj_fiber h1) x",error:  unknown identifier 'evaluationInjective_of_isConnected',"lemma exists_galois_representative (X : C) : âˆƒ (A : C) (a : F.obj A),
    IsGalois A âˆ§ Function.Bijective (fun (f : A âŸ¶ X) â†¦ F.map f a) ",":= by
  obtain âŸ¨A, u, a, h1, h2, h3âŸ© := fiber_in_connected_component F (selfProd F X)
    (mkSelfProdFib F X)
  use A
  use a
  constructor
  Â· refine (isGalois_iff_pretransitive F A).mpr âŸ¨fun x y â†¦ ?_âŸ©
    obtain âŸ¨fi1, hfi1âŸ© := subobj_selfProd_trans h1 x
    obtain âŸ¨fi2, hfi2âŸ© := subobj_selfProd_trans h1 y
    use fi1 â‰ªâ‰« fi2.symm
    show F.map (fi1.hom â‰« fi2.inv) x = y
    simp only [map_comp, FintypeCat.comp_apply]
    rw [hfi1, â† hfi2]
    exact congr_fun (F.mapIso fi2).hom_inv_id y
  Â· refine âŸ¨evaluation_injective_of_isConnected F A X a, ?_âŸ©
    intro x
    use u â‰« Pi.Ï€ _ x
    exact (selfProdProj_fiber h1) x","rcases X with âŸ¨A, A_galois, exists_galois_representative, exists_galois_representative,
  exists_galois_representative, exists_galois_representative, exists_galois_representative,
  exists_galois_representative, exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_galois_representative_exists_galois_representative, exists_galois_representative,
  exists_ga"
Mathlib/CategoryTheory/Sites/SheafHom.lean,CategoryTheory.PresheafHom.IsSheafFor.exists_app,exists_app,caa00a446713ac188017c89bf0a19da029f0c735,":= by
  let c : Cone ((Presieve.diagram (Sieve.pullback g S).arrows).op â‹™ G) :=
    { pt := F.obj (op Y)
      Ï€ :=
        { app := fun âŸ¨Z, hZâŸ© => F.map Z.hom.op â‰« (x _ hZ).app (op (Over.mk (ğŸ™ _)))
          naturality := by
            rintro âŸ¨Zâ‚, hZâ‚âŸ© âŸ¨Zâ‚‚, hZâ‚‚âŸ© âŸ¨f : Zâ‚‚ âŸ¶ Zâ‚âŸ©
            dsimp
            rw [id_comp, assoc]
            have H := hx f.left (ğŸ™ _) hZâ‚ hZâ‚‚ (by simp)
            simp only [internalHom_obj, unop_op, Functor.id_obj, op_id,
              FunctorToTypes.map_id_apply] at H
            let Ï† : Over.mk f.left âŸ¶ Over.mk (ğŸ™ Zâ‚.left) := Over.homMk f.left
            have H' := (x (Zâ‚.hom â‰« g) hZâ‚).naturality Ï†.op
            dsimp at H H' âŠ¢
            erw [â† H, â† H', internalHom_map_app_op_mk_id, â† F.map_comp_assoc,
              â† op_comp, Over.w f] } }
  use (hG g).lift c
  intro Z p hp
  exact ((hG g).fac c âŸ¨Over.mk p, hpâŸ©)","error:  unknown identifier 'internalHom_obj'
error:  unknown identifier 'internalHom_map_app_op_mk_id'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.35450
case op.mk.op.mk.op
C : Type u
instâœÂ¹ : Category.{v, u} C
J : GrothendieckTopology C
A : Type u'
instâœ : Category.{v', u'} A
F G : Cáµ’áµ– â¥¤ A
X : C
S : Sieve X
hG : â¦ƒY : Câ¦„ â†’ (f : Y âŸ¶ X) â†’ IsLimit (G.mapCone (Sieve.pullback f S).arrows.cocone.op)
x : Presieve.FamilyOfElements (presheafHom F G) S.arrows
hx : x.Compatible
Y : C
g : Y âŸ¶ X
Zâ‚ : Over Y
hZâ‚ : (Sieve.pullback g S).arrows Zâ‚.hom
Zâ‚‚ : Over Y
hZâ‚‚ : (Sieve.pullback g S).arrows Zâ‚‚.hom
f : Zâ‚‚ âŸ¶ Zâ‚
H : (presheafHom F G).map f.left.op (x (Zâ‚.hom â‰« g) hZâ‚) = x (Zâ‚‚.hom â‰« g) hZâ‚‚
Ï† : Over.mk f.left âŸ¶ Over.mk (ğŸ™ Zâ‚.left) := Over.homMk f.left â‹¯
H' :
  F.map Ï†.left.op â‰« (x (Zâ‚.hom â‰« g) hZâ‚).app { unop := Over.mk f.left } =
    (x (Zâ‚.hom â‰« g) hZâ‚).app { unop := Over.mk (ğŸ™ Zâ‚.left) } â‰« G.map Ï†.left.op
âŠ¢ F.map Zâ‚‚.hom.op â‰« ((presheafHom F G).map f.left.op (x (Zâ‚.hom â‰« g) hZâ‚)).app { unop := Over.mk (ğŸ™ Zâ‚‚.left) } =
    F.map Zâ‚.hom.op â‰« F.map Ï†.left.op â‰« (x (Zâ‚.hom â‰« g) hZâ‚).app { unop := Over.mk f.left }","lemma exists_app :
    âˆƒ (Ï† : F.obj (op Y) âŸ¶ G.obj (op Y)),
      âˆ€ {Z : C} (p : Z âŸ¶ Y) (hp : S (p â‰« g)), Ï† â‰« G.map p.op =
        F.map p.op â‰« (x (p â‰« g) hp).app âŸ¨Over.mk (ğŸ™ Z)âŸ© ",":= by
  let c : Cone ((Presieve.diagram (Sieve.pullback g S).arrows).op â‹™ G) :=
    { pt := F.obj (op Y)
      Ï€ :=
        { app := fun âŸ¨Z, hZâŸ© => F.map Z.hom.op â‰« (x _ hZ).app (op (Over.mk (ğŸ™ _)))
          naturality := by
            rintro âŸ¨Zâ‚, hZâ‚âŸ© âŸ¨Zâ‚‚, hZâ‚‚âŸ© âŸ¨f : Zâ‚‚ âŸ¶ Zâ‚âŸ©
            dsimp
            rw [id_comp, assoc]
            have H := hx f.left (ğŸ™ _) hZâ‚ hZâ‚‚ (by simp)
            simp only [presheafHom_obj, unop_op, Functor.id_obj, op_id,
              FunctorToTypes.map_id_apply] at H
            let Ï† : Over.mk f.left âŸ¶ Over.mk (ğŸ™ Zâ‚.left) := Over.homMk f.left
            have H' := (x (Zâ‚.hom â‰« g) hZâ‚).naturality Ï†.op
            dsimp at H H' âŠ¢
            erw [â† H, â† H', presheafHom_map_app_op_mk_id, â† F.map_comp_assoc,
              â† op_comp, Over.w f] } }
  use (hG g).lift c
  intro Z p hp
  exact ((hG g).fac c âŸ¨Over.mk p, hpâŸ©)","rcases exists_app with âŸ¨Ï†, hÏ†âŸ©"
Mathlib/Dynamics/OmegaLimit.lean,nonempty_omegaLimit_of_isCompact_absorbing,nonempty_omegaLimit_of_isCompact_absorbing,08ffc014ce7472c743cc849e2820181b3a1c4cae,":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  rw [omegaLimit_eq_interáµ¢_inter _ _ _ hvâ‚]
  apply IsCompact.nonempty_interáµ¢_of_directed_nonempty_compact_closed
  Â· rintro âŸ¨uâ‚, huâ‚âŸ© âŸ¨uâ‚‚, huâ‚‚âŸ©
    use âŸ¨uâ‚ âˆ© uâ‚‚, inter_mem huâ‚ huâ‚‚âŸ©
    constructor
    all_goals exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) Subset.rfl)
  Â· intro u
    have hn : (image2 Ï• (u âˆ© v) s).Nonempty :=
      Nonempty.image2 (Filter.nonempty_of_mem (inter_mem u.prop hvâ‚)) hs
    exact hn.mono subset_closure
  Â· intro
    apply isCompact_of_isClosed_subset hcâ‚ isClosed_closure
    calc
      _ âŠ† closure (image2 Ï• v s) := closure_mono (image2_subset (inter_subset_right _ _) Subset.rfl)
      _ âŠ† c := hvâ‚‚
  Â· exact fun _ â†¦ isClosed_closure","warning:  @omegaLimit does not have a doc string
error:  unknown identifier 'omegaLimit_eq_interáµ¢_inter'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.54074
case intro.intro
Ï„ : Type u_1
Î± : Type u_2
Î² : Type u_3
Î¹ : Type u_4
instâœÂ¹ : TopologicalSpace Î²
f : Filter Ï„
Ï• : Ï„ â†’ Î± â†’ Î²
s sâ‚ sâ‚‚ : Set Î±
instâœ : f.NeBot
c : Set Î²
hcâ‚ : IsCompact c
hs : s.Nonempty
v : Set Ï„
hvâ‚ : v âˆˆ f
hvâ‚‚ : closure (image2 Ï• v s) âŠ† c
âŠ¢ (Ï‰ f Ï• s).Nonempty","theorem nonempty_omegaLimit_of_isCompact_absorbing [NeBot f] {c : Set Î²} (hcâ‚ : IsCompact c)
    (hcâ‚‚ : âˆƒ v âˆˆ f, closure (image2 Ï• v s) âŠ† c) (hs : s.Nonempty) : (Ï‰ f Ï• s).Nonempty ",":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚]
  apply IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed
  Â· rintro âŸ¨uâ‚, huâ‚âŸ© âŸ¨uâ‚‚, huâ‚‚âŸ©
    use âŸ¨uâ‚ âˆ© uâ‚‚, inter_mem huâ‚ huâ‚‚âŸ©
    constructor
    all_goals exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) Subset.rfl)
  Â· intro u
    have hn : (image2 Ï• (u âˆ© v) s).Nonempty :=
      Nonempty.image2 (Filter.nonempty_of_mem (inter_mem u.prop hvâ‚)) hs
    exact hn.mono subset_closure
  Â· intro
    apply hcâ‚.of_isClosed_subset isClosed_closure
    calc
      _ âŠ† closure (image2 Ï• v s) := closure_mono (image2_subset inter_subset_right Subset.rfl)
      _ âŠ† c := hvâ‚‚
  Â· exact fun _ â†¦ isClosed_closure","rcases exists_nonempty_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaCt_absorbing
  nonempty_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaCt_absorbing
  nonempty_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaCt_absorbing
  nonempty_omegaLimit_omegaLimit_omegaLimit_omegaLimit_omegaCt_absorbing hcâ‚ hcâ‚‚ hcâ‚ hcâ‚‚ hcâ‚ hcâ‚‚ hcâ‚ hcâ‚‚ with
  âŸ¨v, hv, hvfâŸ©"
Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean,Real.volume_preserving_transvectionStruct,volume_preserving_transvectionStruct,fbfb504749d41358cab0fa037180ccfee9e3ccd4,":= by
  let p : Î¹ â†’ Prop := fun i => i â‰  t.i
  let Î± : Type _ := { x // p x }
  let Î² : Type _ := { x // Â¬p x }
  let g : (Î± â†’ â„) â†’ (Î² â†’ â„) â†’ Î² â†’ â„ := fun a b => (fun _ => t.c * a âŸ¨t.j, t.hij.symmâŸ©) + b
  let F : (Î± â†’ â„) Ã— (Î² â†’ â„) â†’ (Î± â†’ â„) Ã— (Î² â†’ â„) := fun p => (id p.1, g p.1 p.2)
  let e : (Î¹ â†’ â„) â‰ƒáµ (Î± â†’ â„) Ã— (Î² â†’ â„) := MeasurableEquiv.piEquivPiSubtypeProd (fun _ : Î¹ => â„) p
  have : (toLin' t.toMatrix : (Î¹ â†’ â„) â†’ Î¹ â†’ â„) = e.symm âˆ˜ F âˆ˜ e := by
    cases t with | mk t_i t_j t_hij t_c =>
    ext f k
    simp only [e, g, p, LinearEquiv.map_smul, dite_eq_ite, LinearMap.id_coe, ite_not,
      Algebra.id.smul_eq_mul, one_mul, dotProduct, stdBasisMatrix,
      MeasurableEquiv.piEquivPiSubtypeProd_symm_apply, id.def, transvection, Pi.add_apply,
      zero_mul, LinearMap.smul_apply, Function.comp_apply,
      MeasurableEquiv.piEquivPiSubtypeProd_apply, Matrix.TransvectionStruct.toMatrix_mk,
      Matrix.mulVec, LinearEquiv.map_add, ite_mul, Matrix.toLin'_apply, Pi.smul_apply,
      Subtype.coe_mk, LinearMap.add_apply, Finset.sum_congr, Matrix.toLin'_one]
    by_cases h : t_i = k
    Â· simp only [h, true_and_iff, Finset.mem_univ, if_true, eq_self_iff_true, Finset.sum_ite_eq,
        one_apply, boole_mul, add_comm]
    Â· simp only [h, Ne.symm h, add_zero, if_false, Finset.sum_const_zero, false_and_iff,
        mul_zero]
  rw [this]
  have A : MeasurePreserving e := by
    convert volume_preserving_piEquivPiSubtypeProd (fun _ : Î¹ => â„) p
  have B : MeasurePreserving F :=
    haveI g_meas : Measurable (Function.uncurry g) := by
      have : Measurable fun c : Î± â†’ â„ => c âŸ¨t.j, t.hij.symmâŸ© :=
        measurable_pi_apply âŸ¨t.j, t.hij.symmâŸ©
      refine Measurable.add ?_ measurable_snd
      refine measurable_pi_lambda _ fun _ => Measurable.const_mul ?_ _
      exact this.comp measurable_fst
    (MeasurePreserving.id _).skew_product g_meas
      (eventually_of_forall fun a => map_add_left_eq_self
        (Measure.pi fun _ => (stdOrthonormalBasis â„ â„).toBasis.addHaar) _)
  exact ((A.symm e).comp B).comp A","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.142831 â†’ ?m.142831
error:  unsolved goals
case pos
Î¹ : Type u_1
instâœÂ¹ : Fintype Î¹
instâœ : DecidableEq Î¹
t_i t_j : Î¹
t_hij : t_i â‰  t_j
t_c : â„
p : Î¹ â†’ Prop := fun i â†¦ i â‰  { i := t_i, j := t_j, hij := t_hij, c := t_c }.i
Î± : Type u_1 := { x // p x }
Î² : Type u_1 := { x // Â¬p x }
g : (Î± â†’ â„) â†’ (Î² â†’ â„) â†’ Î² â†’ â„ :=
  fun a b â†¦
    (fun x â†¦
        { i := t_i, j := t_j, hij := t_hij, c := t_c }.c * a âŸ¨{ i := t_i, j := t_j, hij := t_hij, c := t_c }.j, â‹¯âŸ©) +
      b
F : (Î± â†’ â„) Ã— (Î² â†’ â„) â†’ (Î± â†’ â„) Ã— (Î² â†’ â„) := fun p â†¦ (id p.1, g p.1 p.2)
e : (Î¹ â†’ â„) â‰ƒáµ (Î± â†’ â„) Ã— (Î² â†’ â„) := MeasurableEquiv.piEquivPiSubtypeProd (fun x â†¦ â„) p
f : Î¹ â†’ â„
k : Î¹
h : t_i = k
âŠ¢ t_c * f t_j + id f k = if h_1 : k â‰  k then id (fun x â†¦ f â†‘x) âŸ¨k, â‹¯âŸ© else f k + t_c * f t_j
error:  unsolved goals
case neg
Î¹ : Type u_1
instâœÂ¹ : Fintype Î¹
instâœ : DecidableEq Î¹
t_i t_j : Î¹
t_hij : t_i â‰  t_j
t_c : â„
p : Î¹ â†’ Prop := fun i â†¦ i â‰  { i := t_i, j := t_j, hij := t_hij, c := t_c }.i
Î± : Type u_1 := { x // p x }
Î² : Type u_1 := { x // Â¬p x }
g : (Î± â†’ â„) â†’ (Î² â†’ â„) â†’ Î² â†’ â„ :=
  fun a b â†¦
    (fun x â†¦
        { i := t_i, j := t_j, hij := t_hij, c := t_c }.c * a âŸ¨{ i := t_i, j := t_j, hij := t_hij, c := t_c }.j, â‹¯âŸ©) +
      b
F : (Î± â†’ â„) Ã— (Î² â†’ â„) â†’ (Î± â†’ â„) Ã— (Î² â†’ â„) := fun p â†¦ (id p.1, g p.1 p.2)
e : (Î¹ â†’ â„) â‰ƒáµ (Î± â†’ â„) Ã— (Î² â†’ â„) := MeasurableEquiv.piEquivPiSubtypeProd (fun x â†¦ â„) p
f : Î¹ â†’ â„
k : Î¹
h : Â¬t_i = k
âŠ¢ id f k = if h : k â‰  t_i then id (fun x â†¦ f â†‘x) âŸ¨k, â‹¯âŸ© else t_c * f t_j + f k","theorem volume_preserving_transvectionStruct [DecidableEq Î¹] (t : TransvectionStruct Î¹ â„) :
    MeasurePreserving (toLin' t.toMatrix) ",":= by
  have ht : Measurable (toLin' t.toMatrix) :=
    (toLin' t.toMatrix).continuous_of_finiteDimensional.measurable
  refine âŸ¨ht, ?_âŸ©
  refine (pi_eq fun s hs â†¦ ?_).symm
  have h2s : MeasurableSet (univ.pi s) := .pi countable_univ fun i _ â†¦ hs i
  simp_rw [â† pi_pi, â† lintegral_indicator_one h2s]
  rw [lintegral_map (measurable_one.indicator h2s) ht, volume_pi]
  refine lintegral_eq_of_lmarginal_eq {t.i} ((measurable_one.indicator h2s).comp ht)
    (measurable_one.indicator h2s) ?_
  simp_rw [lmarginal_singleton]
  ext x
  cases t with | mk t_i t_j t_hij t_c =>
  simp [transvection, mulVec_stdBasisMatrix, t_hij.symm, â† Function.update_add,
    lintegral_add_right_eq_self fun xáµ¢ â†¦ indicator (univ.pi s) 1 (Function.update x t_i xáµ¢)]","refine MeasurePreserving.transvectionStruct volume_preserving_transvection_transvection_transvection
  volume_preserving_transvection_transvection_transvection volume_preserving_transvection
  volume_preserving_transvection_transvection_transvection volume_preserving_transvection
  volume_preserving_transvection_transvection_transvection volume_preserving_transvection
  volume_preserving_transvection_transvection_transvection volume_preserving_transvection
  volume_preserving_transvection_transvection_transvection volume_preserving_transvection
  volume_preserving_transvection_transvection_transvection volume_preserving_transvection
  volume_preserving_transvection_transvection_transvection volume_preserving_transvection t"
Mathlib/Geometry/Euclidean/Inversion/Calculus.lean,EuclideanGeometry.hasFDerivAt_inversion,hasFDerivAt_inversion,7088139429bcf36357f4c44f3beff1a1374a13e1,":= by
  rcases add_left_surjective c x with âŸ¨x, rflâŸ©
  have : HasFDerivAt (inversion c R) (_ : F â†’L[â„] F) (c + x) := by
    simp (config := { unfoldPartialApp := true }) only [inversion]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ğ•œ := â„) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := â„ âˆ™ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy â†¦ ?_)
  Â· have : ((â€–xâ€– ^ 2) ^ 2)â»Â¹ * (â€–xâ€– ^ 2) = (â€–xâ€– ^ 2)â»Â¹ := by
      rw [â† div_eq_inv_mul, sq (â€–xâ€– ^ 2), div_self_mul_self']
    simp [Pi.smul_apply _, reflection_orthogonalComplement_singleton_eq_neg,
      real_inner_self_eq_norm_sq, two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  Â· simp [Pi.smul_apply _, Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]","error:  don't know how to synthesize placeholder for argument 'f''
context:
E : Type u_1
F : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace â„ E
instâœÂ¹ : NormedAddCommGroup F
instâœ : InnerProductSpace â„ F
a b c d y z : F
r R : â„
x : F
hx : (fun x â†¦ c + x) x â‰  c
âŠ¢ F â†’L[â„] F
error:  unsolved goals
case intro
E : Type u_1
F : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace â„ E
instâœÂ¹ : NormedAddCommGroup F
instâœ : InnerProductSpace â„ F
a b c d y z : F
r R : â„
x : F
hx : (fun x â†¦ c + x) x â‰  c
âŠ¢ HasFDerivAt (inversion c R)
    ((R / dist ((fun x â†¦ c + x) x) c) ^ 2 â€¢
      â†‘{ toLinearEquiv := (reflection (Submodule.span â„ {(fun x â†¦ c + x) x - c})á—®).toLinearEquiv, continuous_toFun := â‹¯,
          continuous_invFun := â‹¯ })
    ((fun x â†¦ c + x) x)","theorem hasFDerivAt_inversion (hx : x â‰  c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 â€¢ (reflection (â„ âˆ™ (x - c))á—® : F â†’L[â„] F)) x ",":= by
  rcases add_left_surjective c x with âŸ¨x, rflâŸ©
  have : HasFDerivAt (inversion c R) (?_ : F â†’L[â„] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ğ•œ := â„) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := â„ âˆ™ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy â†¦ ?_)
  Â· have : ((â€–xâ€– ^ 2) ^ 2)â»Â¹ * (â€–xâ€– ^ 2) = (â€–xâ€– ^ 2)â»Â¹ := by
      rw [â† div_eq_inv_mul, sq (â€–xâ€– ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  Â· simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]",have hasFDerivAt_inversion hx hasFDerivAt_inversion hx hasFDerivAt_inversion hx
Mathlib/RingTheory/RingHom/Finite.lean,RingHom.finite_stableUnderBaseChange,finite_stableUnderBaseChange,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  refine StableUnderBaseChange.mk _ finite_respectsIso ?_
  classical
  introv h
  replace h : Module.Finite R T := by
    rw [RingHom.Finite] at h; convert h; ext; sorry; sorry
  suffices Module.Finite S (S âŠ—[R] T) by
    rw [RingHom.Finite]; convert this; congr; sorry; sorry; sorry 
  exact inferInstance","error:  no goals to be solved
error:  no goals to be solved",theorem finite_stableUnderBaseChange : StableUnderBaseChange @Finite ,":= by
  refine StableUnderBaseChange.mk _ finite_respectsIso ?_
  classical
  introv h
  replace h : Module.Finite R T := by
    rw [RingHom.Finite] at h; convert h; ext; simp_rw [Algebra.smul_def]; rfl
  suffices Module.Finite S (S âŠ—[R] T) by
    rw [RingHom.Finite]; convert this; congr; ext; simp_rw [Algebra.smul_def]; rfl
  exact inferInstance",refinite_stableUnderBaseChange finite_stableUnderBaseChange
Mathlib/Computability/Primrec.lean,Primcodable.mem_range_encode,mem_range_encode,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  have : PrimrecPred fun n => Encodable.decodeâ‚‚ Î± n â‰  none :=
    .not
      (Primrec.eq.comp
        (.option_bind .decode
          (.ite (Primrec.eq.comp (Primrec.encode.comp .snd) .fst)
            (Primrec.option_some.comp .snd) (.const _)))
        (.const _))
  this.of_eq_pred fun _ => decodeâ‚‚_ne_none_iff","error:  invalid field 'of_eq_pred', the environment does not contain 'PrimrecPred.of_eq_pred'
  this
has type
  PrimrecPred fun n â†¦ decodeâ‚‚ Î± n â‰  none
error:  invalid field 'of_eq_pred', the environment does not contain 'Primrec.of_eq_pred'
  this
has type
  Primrec fun a â†¦ decide ((fun n â†¦ decodeâ‚‚ Î± n â‰  none) a)
error:  invalid field 'of_eq_pred', the environment does not contain 'Nat.Primrec.of_eq_pred'
  this
has type
  Nat.Primrec fun n â†¦ encode (Option.map (fun a â†¦ decide ((fun n â†¦ decodeâ‚‚ Î± n â‰  none) a)) (decode n))",theorem mem_range_encode : PrimrecPred (fun n => n âˆˆ Set.range (encode : Î± â†’ â„•)) ,":=
  have : PrimrecPred fun n => Encodable.decodeâ‚‚ Î± n â‰  none :=
    .not
      (Primrec.eq.comp
        (.option_bind .decode
          (.ite (Primrec.eq.comp (Primrec.encode.comp .snd) .fst)
            (Primrec.option_some.comp .snd) (.const _)))
        (.const _))
  this.of_eq fun _ => decodeâ‚‚_ne_none_iff","simp only [Set.mem_range, Set.mem_range_encode]"
Mathlib/Geometry/Manifold/ContMDiff/Defs.lean,contMDiffWithinAt_iff_contMDiffOn_nhds,contMDiffWithinAt_iff_contMDiffOn_nhds,2ea14b79e1f7e6978b1265a8d41f7a305925875c,":= by
  wlog hxs : x âˆˆ s generalizing s
  Â· rw [â† contMDiffWithinAt_insert_self, this (mem_insert _ _), insert_idem]
  rw [insert_eq_of_mem hxs]
  refine âŸ¨fun h â†¦ ?_, fun âŸ¨u, hmem, huâŸ© â†¦ (hu _ (mem_of_mem_nhdsWithin hxs hmem)).mono_of_mem hmemâŸ©
  rcases (contMDiffWithinAt_iff'.1 h).2.contDiffOn le_rfl with âŸ¨v, hmem, hsub, hvâŸ©
  have hxs' : extChartAt I x x âˆˆ (extChartAt I x).target âˆ©
      (extChartAt I x).symm â»Â¹' (s âˆ© f â»Â¹' (extChartAt I' (f x)).source) :=
    âŸ¨(extChartAt I x).map_source (mem_extChartAt_source _ _), by rwa [extChartAt_to_inv], by
      rw [extChartAt_to_inv]; apply mem_extChartAt_sourceâŸ©
  rw [insert_eq_of_mem hxs'] at hmem hsub
  refine âŸ¨(extChartAt I x).symm '' v, ?_, ?_âŸ©
  Â· rw [â† map_extChartAt_symm_nhdsWithin I,
      h.1.nhdsWithin_extChartAt_symm_preimage_inter_range I I']
    exact image_mem_map hmem
  Â· have hvâ‚ : (extChartAt I x).symm '' v âŠ† (extChartAt I x).source :=
      image_subset_iff.2 fun y hy â†¦ (extChartAt I x).map_target (hsub hy).1
    have hvâ‚‚ : MapsTo f ((extChartAt I x).symm '' v) (extChartAt I' (f x)).source := by
      rintro _ âŸ¨y, hy, rflâŸ©
      exact (hsub hy).2.2
    rwa [contMDiffOn_iff_of_subset_source' hvâ‚ hvâ‚‚, PartialEquiv.image_symm_image_of_subset_target]
    exact hsub.trans (inter_subset_left _ _)","error:  function expected at
  inter_subset_left ?m.361330
term has type
  ?m.361329 âˆˆ ?m.361327","theorem contMDiffWithinAt_iff_contMDiffOn_nhds {n : â„•} :
    ContMDiffWithinAt I I' n f s x â†” âˆƒ u âˆˆ ğ“[insert x s] x, ContMDiffOn I I' n f u ",":= by
  wlog hxs : x âˆˆ s generalizing s
  Â· rw [â† contMDiffWithinAt_insert_self, this (mem_insert _ _), insert_idem]
  rw [insert_eq_of_mem hxs]
  refine âŸ¨fun h â†¦ ?_, fun âŸ¨u, hmem, huâŸ© â†¦ (hu _ (mem_of_mem_nhdsWithin hxs hmem)).mono_of_mem hmemâŸ©
  rcases (contMDiffWithinAt_iff'.1 h).2.contDiffOn le_rfl with âŸ¨v, hmem, hsub, hvâŸ©
  have hxs' : extChartAt I x x âˆˆ (extChartAt I x).target âˆ©
      (extChartAt I x).symm â»Â¹' (s âˆ© f â»Â¹' (extChartAt I' (f x)).source) :=
    âŸ¨(extChartAt I x).map_source (mem_extChartAt_source _ _), by rwa [extChartAt_to_inv], by
      rw [extChartAt_to_inv]; apply mem_extChartAt_sourceâŸ©
  rw [insert_eq_of_mem hxs'] at hmem hsub
  refine âŸ¨(extChartAt I x).symm '' v, ?_, ?_âŸ©
  Â· rw [â† map_extChartAt_symm_nhdsWithin I,
      h.1.nhdsWithin_extChartAt_symm_preimage_inter_range I I']
    exact image_mem_map hmem
  Â· have hvâ‚ : (extChartAt I x).symm '' v âŠ† (extChartAt I x).source :=
      image_subset_iff.2 fun y hy â†¦ (extChartAt I x).map_target (hsub hy).1
    have hvâ‚‚ : MapsTo f ((extChartAt I x).symm '' v) (extChartAt I' (f x)).source := by
      rintro _ âŸ¨y, hy, rflâŸ©
      exact (hsub hy).2.2
    rwa [contMDiffOn_iff_of_subset_source' hvâ‚ hvâ‚‚, PartialEquiv.image_symm_image_of_subset_target]
    exact hsub.trans inter_subset_left",simp [contMDiffWithinAt_iff_contMDiffOn_nhds]
Mathlib/CategoryTheory/Sites/Coverage.lean,CategoryTheory.Presieve.factorsThru_of_le,factorsThru_of_le,ef3c9bcd07782b044027916a64e925f3e4951707,":=
  fun Y g hg => âŸ¨Y, ğŸ™ _, g, h _ _ hg, by simpâŸ©","error:  function expected at
  h ?m.23035 ?m.23037
term has type
  ?m.23036 âˆˆ T","lemma factorsThru_of_le {X : C} (S T : Presieve X) (h : S â‰¤ T) :
    S.FactorsThru T ",":=
  fun Y g hg => âŸ¨Y, ğŸ™ _, g, h _ hg, by simpâŸ©",rw [FactorsThru]
Mathlib/Probability/Kernel/Disintegration/CdfToKernel.lean,ProbabilityTheory.IsRatCondKernelCDFAux.isRatCondKernelCDF,IsRatCondKernelCDFAux.isRatCondKernelCDF,a71231735e55fa1fc4000a42658641f766fde88b,"  measurable := hf.measurable
  isRatStieltjesPoint_ae := hf.isRatStieltjesPoint_ae
  integrable := hf.integrable
  set_integral := hf.set_integral",error:  'set_integral' is not a field of structure 'ProbabilityTheory.IsRatCondKernelCDF',"lemma IsRatCondKernelCDFAux.isRatCondKernelCDF (hf : IsRatCondKernelCDFAux f Îº Î½) [IsFiniteKernel Îº]
    [IsFiniteKernel Î½] :
    IsRatCondKernelCDF f Îº Î½ where
","  measurable := hf.measurable
  isRatStieltjesPoint_ae := hf.isRatStieltjesPoint_ae
  integrable := hf.integrable
  setIntegral := hf.setIntegral",rw [IsRatCondKernelCDFAux.isRatCondKernelCDF]
Mathlib/Geometry/Manifold/BumpFunction.lean,SmoothBumpFunction.image_eq_inter_preimage_of_subset_support,image_eq_inter_preimage_of_subset_support,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [support_eq_inter_preimage, subset_inter_iff, â† extChartAt_source I, â† image_subset_iff] at hs
  cases' hs with hse hsf
  apply Subset.antisymm
  Â· refine' subset_inter (subset_inter (hsf.trans ball_subset_closedBall) _) _
    Â· rintro _ âŸ¨x, -, rflâŸ©; exact mem_range_self _
    Â· rw [(extChartAt I c).image_eq_target_inter_inv_preimage hse]
      exact inter_subset_right _ _
  Â· refine' Subset.trans (inter_subset_inter_left _ f.closedBall_subset) _
    rw [(extChartAt I c).image_eq_target_inter_inv_preimage hse]","error:  function expected at
  inter_subset_right ?m.33338
term has type
  ?m.33337 âˆˆ ?m.33336","theorem image_eq_inter_preimage_of_subset_support {s : Set M} (hs : s âŠ† support f) :
    extChartAt I c '' s =
      closedBall (extChartAt I c c) f.rOut âˆ© range I âˆ© (extChartAt I c).symm â»Â¹' s ",":= by
  rw [support_eq_inter_preimage, subset_inter_iff, â† extChartAt_source I, â† image_subset_iff] at hs
  cases' hs with hse hsf
  apply Subset.antisymm
  Â· refine subset_inter (subset_inter (hsf.trans ball_subset_closedBall) ?_) ?_
    Â· rintro _ âŸ¨x, -, rflâŸ©; exact mem_range_self _
    Â· rw [(extChartAt I c).image_eq_target_inter_inv_preimage hse]
      exact inter_subset_right
  Â· refine Subset.trans (inter_subset_inter_left _ f.closedBall_subset) ?_
    rw [(extChartAt I c).image_eq_target_inter_inv_preimage hse]",rw [â† image_eq_inter_preimage_of_subset_support]
Mathlib/FieldTheory/Finiteness.lean,IsNoetherian.iff_rank_lt_aleph0,iff_rank_lt_aleph0,d2d4547dc5d4da050bede9036f96ca058630a465,":= by
  let b := Basis.ofVectorSpace K V
  rw [â† b.mk_eq_rank'', lt_aleph0_iff_set_finite]
  constructor
  Â· intro
    exact finite_of_linearIndependent (Basis.ofVectorSpaceIndex.linearIndependent K V)
  Â· intro hbfinite
    refine'
      @isNoetherian_of_linearEquiv K (âŠ¤ : Submodule K V) V _ _ _ _ _ (LinearEquiv.ofTop _ rfl)
        (id _)
    refine' isNoetherian_of_fg_of_noetherian _ âŸ¨Set.Finite.toFinset hbfinite, _âŸ©
    rw [Set.Finite.coe_toFinset, â† b.span_eq, Basis.coe_ofVectorSpace,
      Set.range_restrict, Set.image_id]","warning:  `finite_of_linearIndependent` has been deprecated, use `LinearIndependent.set_finite_of_isNoetherian` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Set.range (?s.restrict ?f)
case mpr
K : Type u
V : Type v
instâœÂ² : DivisionRing K
instâœÂ¹ : AddCommGroup V
instâœ : Module K V
b : Basis (â†‘(Basis.ofVectorSpaceIndex K V)) K V := Basis.ofVectorSpace K V
hbfinite : (Basis.ofVectorSpaceIndex K V).Finite
âŠ¢ span K (Basis.ofVectorSpaceIndex K V) = span K (Set.range Subtype.val)",theorem iff_rank_lt_aleph0 : IsNoetherian K V â†” Module.rank K V < â„µâ‚€ ,":= by
  let b := Basis.ofVectorSpace K V
  rw [â† b.mk_eq_rank'', lt_aleph0_iff_set_finite]
  constructor
  Â· intro
    exact (Basis.ofVectorSpaceIndex.linearIndependent K V).set_finite_of_isNoetherian
  Â· intro hbfinite
    refine
      @isNoetherian_of_linearEquiv K (âŠ¤ : Submodule K V) V _ _ _ _ _ (LinearEquiv.ofTop _ rfl)
        (id ?_)
    refine isNoetherian_of_fg_of_noetherian _ âŸ¨Set.Finite.toFinset hbfinite, ?_âŸ©
    rw [Set.Finite.coe_toFinset, â† b.span_eq, Basis.coe_ofVectorSpace, Subtype.range_coe]",rw [â† rank_lt_aleph0_iff_rank_lt_aleph0]
Mathlib/Algebra/Order/Interval/Set/Monoid.lean,Set.Ici_add_bij,Ici_add_bij,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine'
    âŸ¨fun x h => add_le_add_right (mem_Ici.mp h) _, (add_left_injective d).injOn _, fun _ h => _âŸ©
  obtain âŸ¨c, rflâŸ© := exists_add_of_le (mem_Ici.mp h)
  rw [mem_Ici, add_right_comm, add_le_add_iff_right] at h
  exact âŸ¨a + c, h, by rw [add_right_comm]âŸ©","error:  application type mismatch
  And.intro (Function.Injective.injOn (add_left_injective d) ?m.994)
argument
  Function.Injective.injOn (add_left_injective d) ?m.994
has type
  âˆ€ â¦ƒxâ‚‚ : Mâ¦„, xâ‚‚ âˆˆ ?m.992 â†’ ?m.993 + d = xâ‚‚ + d â†’ ?m.993 = xâ‚‚ : Prop
but is expected to have type
  InjOn (fun x â†¦ x + d) (Ici a) : Prop",theorem Ici_add_bij : BijOn (Â· + d) (Ici a) (Ici (a + d)) ,":= by
  refine
    âŸ¨fun x h => add_le_add_right (mem_Ici.mp h) _, (add_left_injective d).injOn, fun _ h => ?_âŸ©
  obtain âŸ¨c, rflâŸ© := exists_add_of_le (mem_Ici.mp h)
  rw [mem_Ici, add_right_comm, add_le_add_iff_right] at h
  exact âŸ¨a + c, h, by rw [add_right_comm]âŸ©",refine theorem_Ici_add_bij Ici_add_bij
Mathlib/LinearAlgebra/Matrix/PosDef.lean,Matrix.PosDef.posSemidef,posSemidef,80e6f5c2c6129e22f25d259eb3a6b63416337071,":= by
  refine âŸ¨fun âŸ¨_, hPâŸ© i â†¦ by simpa using hP (Pi.single i 1), .diagonalâŸ©","error:  invalid dotted identifier notation, unknown identifier `Matrix.PosSemidef.diagonal` from expected type
  (âˆ€ (i : n), 0 â‰¤ d i) â†’ (diagonal d).PosSemidef
error:  invalid dotted identifier notation, unknown identifier `And.diagonal` from expected type
  (âˆ€ (i : n), 0 â‰¤ d i) â†’ (diagonal d).PosSemidef","lemma posSemidef_diagonal_iff [DecidableEq n] {d : n â†’ R} :
    PosSemidef (diagonal d) â†” (âˆ€ i : n, 0 â‰¤ d i) ",":= by
  refine âŸ¨fun âŸ¨_, hPâŸ© i â†¦ by simpa using hP (Pi.single i 1), ?_âŸ©
  refine fun hd â†¦ âŸ¨isHermitian_diagonal_iff.2 fun i â†¦ IsSelfAdjoint.of_nonneg (hd i), ?_âŸ©
  refine fun x â†¦ Finset.sum_nonneg fun i _ â†¦ ?_
  simpa only [mulVec_diagonal, mul_assoc] using conjugate_nonneg (hd i) _",constructor
Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean,Real.Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma,Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  let f : â„ â†’ â„ â†’ â„ â†’ â„ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : âˆ€ c u x : â„, x âˆˆ Ioi (0 : â„) â†’ 0 â‰¤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : âˆ€ c u : â„, âˆ€áµ x : â„ âˆ‚volume.restrict (Ioi 0), 0 â‰¤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    âˆ€ {c x : â„} (_ : 0 < c) (u : â„) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only [f]
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), â† exp_mul, â† rpow_mul hx.le]
    congr 2 <;> Â· field_simp [hc.ne']; ring
  have f_mem_Lp :
    âˆ€ {c u : â„} (hc : 0 < c) (hu : 0 < u),
      Memâ„’p (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) â‰  0 := by
      rwa [Ne.def, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) â‰  âˆ := ENNReal.ofReal_ne_top
    rw [â† memâ„’p_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memâ„’p_one_iff_integrable]
    Â· apply Integrable.congr (GammaIntegral_convergent hu)
      refine' eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => _
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    Â· refine' ContinuousOn.aestronglyMeasurable _ measurableSet_Ioi
      refine' (Continuous.continuousOn _).mul (ContinuousAt.continuousOn fun x hx => _)
      Â· exact continuous_exp.comp (continuous_const.mul continuous_id')
      Â· exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  Â· refine' set_integral_congr measurableSet_Ioi fun x hx => _
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [â† exp_add, â† add_mul, â† neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [â† rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  Â· rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact set_integral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx","error:  no goals to be solved
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.38886 â†’ ?m.38886 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.38888
s t a b : â„
hs : 0 < s
ht : 0 < t
ha : 0 < a
hb : 0 < b
hab : a + b = 1
f : â„ â†’ â„ â†’ â„ â†’ â„ := fun c u x â†¦ rexp (-c * x) * x ^ (c * (u - 1))
e : (1 / a).IsConjExponent (1 / b)
hab' : b = 1 - a
hst : 0 < a * s + b * t
posf : âˆ€ (c u x : â„), x âˆˆ Ioi 0 â†’ 0 â‰¤ f c u x
posf' : âˆ€ (c u : â„), âˆ€áµ (x : â„) âˆ‚volume.restrict (Ioi 0), 0 â‰¤ f c u x
fpow : âˆ€ {c x : â„}, 0 < c â†’ âˆ€ (u : â„), 0 < x â†’ rexp (-x) * x ^ (u - 1) = f c u x ^ (1 / c)
c u : â„
hc : 0 < c
hu : 0 < u
âŠ¢ ENNReal.ofReal (1 / c) â‰  0
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead","theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : â„} (hs : 0 < s) (ht : 0 < t)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    Gamma (a * s + b * t) â‰¤ Gamma s ^ a * Gamma t ^ b ",":= by
  let f : â„ â†’ â„ â†’ â„ â†’ â„ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : âˆ€ c u x : â„, x âˆˆ Ioi (0 : â„) â†’ 0 â‰¤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : âˆ€ c u : â„, âˆ€áµ x : â„ âˆ‚volume.restrict (Ioi 0), 0 â‰¤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    âˆ€ {c x : â„} (_ : 0 < c) (u : â„) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only [f]
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), â† exp_mul, â† rpow_mul hx.le]
    congr 2 <;> field_simp [hc.ne']; ring
  have f_mem_Lp :
    âˆ€ {c u : â„} (hc : 0 < c) (hu : 0 < u),
      Memâ„’p (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) â‰  0 := by
      rwa [Ne, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) â‰  âˆ := ENNReal.ofReal_ne_top
    rw [â† memâ„’p_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memâ„’p_one_iff_integrable]
    Â· apply Integrable.congr (GammaIntegral_convergent hu)
      refine eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => ?_
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    Â· refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
      refine (Continuous.continuousOn ?_).mul (ContinuousAt.continuousOn fun x hx => ?_)
      Â· exact continuous_exp.comp (continuous_const.mul continuous_id')
      Â· exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  Â· refine setIntegral_congr measurableSet_Ioi fun x hx => ?_
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [â† exp_add, â† add_mul, â† neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [â† rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  Â· rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact setIntegral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx","rw [Gamma_mul_add_mul_le_rpow_Gamma_mul_add_mul_le_rpow_Gamma_mul_add_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma
  s t a b hs ht hs ht ht hab, Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma
  s t a b ht ha hb hab, Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow]"
Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean,WeierstrassCurve.Projective.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,0a4b391b68ce1c32b1ab9ccb77a41ee1c7f8371b,":= by
  rw [fin3_def P, hPz] at hP âŠ¢
  rw [fin3_def Q, hQz] at hQ âŠ¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
      at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact âŸ¨Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel _ hQ]âŸ©","error:  application type mismatch
  div_mul_cancel ?m.248578 hQ
argument
  hQ
has type
  Â¬Q 1 = 0 : Prop
but is expected to have type
  ?m.248576 : Type ?u.248575
error:  unsolved goals
R : Type u
instâœÂ¹ : CommRing R
Wâœ : Projective R
F : Type u
instâœ : Field F
W : Projective F
P Q : Fin 3 â†’ F
hPz : P 2 = 0
hQz : Q 2 = 0
hP : Â¬P 1 = 0
hQ : Â¬Q 1 = 0
âŠ¢ ![0, P 1 / Q 1 * Q 1, 0] = ![0, P 1, 0]","lemma equiv_of_Z_eq_zero {P Q : Fin 3 â†’ F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P â‰ˆ Q ",":= by
  rw [fin3_def P, hPz] at hP âŠ¢
  rw [fin3_def Q, hQz] at hQ âŠ¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact âŸ¨Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancelâ‚€ _ hQ]âŸ©","simp only [equiv_of_Z_eq_zero_lemma, equiv_of_Z_eq_zero_lemma, equiv_of_Z_eq_zero_lemma]"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,HolderOnWith.hausdorffMeasure_image_le,hausdorffMeasure_image_le,9e34a191034458a56331f976ff7400a26407c888,":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, MulZeroClass.mul_zero, image_empty]
    have : f '' s = {f x} :=
      haveI : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, MulZeroClass.mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine' iSup_le fun R => iSup_le fun hR => _
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine'
      le_iSupâ‚‚_of_le Î´ Î´0
        (iInfâ‚‚_mono' fun t hst =>
          âŸ¨fun n => f '' (t n âˆ© s), _,
            iInf_mono' fun htÎ´ =>
              âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, _âŸ©âŸ©)
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine' ENNReal.tsum_le_tsum fun n => _
      simp only [iSup_le_iff, nonempty_image_iff]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left s) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","warning:  `Set.nonempty_image_iff` has been deprecated, use `Set.image_nonempty` instead
error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set X : Type u_2
but is expected to have type
  ?m.169595 âˆˆ t n âˆ© ?m.169594 : Prop
error:  simp made no progress","theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s ",":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","rw [â† hausdorffMeasure_image_le, hausdorffMeasure_image_le, hausdorffMeasure_image_le]"
Mathlib/MeasureTheory/Measure/Tilted.lean,MeasureTheory.rnDeriv_tilted_right,rnDeriv_tilted_right,5522fc375dfd18ea7496d18f560309e857582ca8,":= by
  cases eq_zero_or_neZero Î½ with
  | inl h => simp_rw [h, ae_zero, Filter.EventuallyEq]; exact Filter.eventually_bot
  | inr h0 =>
    refine (Measure.rnDeriv_withDensity_right Î¼ Î½ ?_ ?_ ?_).trans ?_
    Â· exact (hf.1.aemeasurable.div_const _).ennreal_ofReal
    Â· refine ae_of_all _ ?_
      simp only [ne_eq, ENNReal.ofReal_eq_zero, not_le]
      exact fun _ â†¦ div_pos (exp_pos _) (integral_exp_pos hf)
    Â· refine ae_of_all _ (by simp)
    Â· refine ae_of_all _ (fun x â†¦ ?_)
      simp only
      congr
      rw [ENNReal.ofReal_inv_of_pos, inv_div', â† exp_neg, div_eq_mul_inv, inv_inv]
      exact div_pos (exp_pos _) (integral_exp_pos hf)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ENNReal.ofReal ?m.124660â»Â¹
case inr.refine_4.e_a
Î± : Type u_1
mÎ± : MeasurableSpace Î±
Î¼âœ : Measure Î±
f : Î± â†’ â„
Î¼ Î½ : Measure Î±
instâœÂ¹ : SigmaFinite Î¼
instâœ : SigmaFinite Î½
hf : Integrable (fun x â†¦ rexp (f x)) Î½
h0 : NeZero Î½
x : Î±
âŠ¢ (ENNReal.ofReal (rexp (f x) / âˆ« (x : Î±), rexp (f x) âˆ‚Î½))â»Â¹ = ENNReal.ofReal (rexp (-f x) * âˆ« (x : Î±), rexp (f x) âˆ‚Î½)","lemma rnDeriv_tilted_right (Î¼ Î½ : Measure Î±) [SigmaFinite Î¼] [SigmaFinite Î½]
    (hf : Integrable (fun x â†¦ exp (f x)) Î½) :
    Î¼.rnDeriv (Î½.tilted f)
      =áµ[Î½] fun x â†¦ ENNReal.ofReal (exp (- f x) * âˆ« x, exp (f x) âˆ‚Î½) * Î¼.rnDeriv Î½ x ",":= by
  cases eq_zero_or_neZero Î½ with
  | inl h => simp_rw [h, ae_zero, Filter.EventuallyEq]; exact Filter.eventually_bot
  | inr h0 =>
    refine (Measure.rnDeriv_withDensity_right Î¼ Î½ ?_ ?_ ?_).trans ?_
    Â· exact (hf.1.aemeasurable.div_const _).ennreal_ofReal
    Â· filter_upwards
      simp only [ne_eq, ENNReal.ofReal_eq_zero, not_le]
      exact fun _ â†¦ div_pos (exp_pos _) (integral_exp_pos hf)
    Â· refine ae_of_all _ (by simp)
    Â· filter_upwards with x
      congr
      rw [â† ENNReal.ofReal_inv_of_pos, inv_div', â† exp_neg, div_eq_mul_inv, inv_inv]
      exact div_pos (exp_pos _) (integral_exp_pos hf)","have : Integrable (fun x â†¦ exp (f x) * âˆ« x, exp (f x) âˆ‚Î½) := hf.integrable_comp hf"
Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean,AlgebraicTopology.AlternatingCofaceMapComplex.d_squared,d_squared,ecdd87a32faafd1762b706324fbef9260022a7b2,":= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff, Fin.val_succ,
      Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa using hij
  Â· 
    rintro âŸ¨i, jâŸ© âŸ¨i', j'âŸ© hij hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine' âŸ¨(j'.pred <| _, Fin.castSucc i'), _, _âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'
    Â· simp only [Fin.castLT_castSucc, Fin.succ_pred]","error:  simp made no progress
error:  simp made no progress
error:  rcases tactic failed: aâœ : Quot.lift (fun l â†¦ (i, j) âˆˆ l) â‹¯ Sá¶œ.val is not an inductive datatype
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #3 provided
error:  no goals to be solved",theorem d_squared (n : â„•) : objD X (n + 1) â‰« objD X n = 0 ,":= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,
      Fin.val_succ, Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij âŸ¨i', j'âŸ© hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine âŸ¨(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'
    Â· simp only [Ï†, Fin.castLT_castSucc, Fin.succ_pred]
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa [S] using hij","simp only [objD, objDD, objDDD, d_squared, d_squared, d_squared, d_squared]"
Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean,measurable_of_tendsto_metrizable',measurable_of_tendsto_metrizable',2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  letI : PseudoMetricSpace Î² := pseudoMetrizableSpacePseudoMetric Î²
  apply measurable_of_is_closed'
  intro s h1s h2s h3s
  have : Measurable fun x => infNndist (g x) s := by
    suffices : Tendsto (fun i x => infNndist (f i x) s) u (ğ“ fun x => infNndist (g x) s)
    exact measurable_of_tendsto_nnreal' u (fun i => (hf i).infNndist) this
    rw [tendsto_pi_nhds] at lim âŠ¢
    intro x
    exact ((continuous_infNndist_pt s).tendsto (g x)).comp (lim x)
  have h4s : g â»Â¹' s = (fun x => infNndist (g x) s) â»Â¹' {0} := by
    ext x
    simp [h1s, â† h1s.mem_iff_infDist_zero h2s, â† NNReal.coe_eq_zero]
  rw [h4s]
  exact this (measurableSet_singleton 0)",error:  unexpected token ':'; expected term,"theorem measurable_of_tendsto_metrizable' {Î¹} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : Filter Î¹) [NeBot u]
    [IsCountablyGenerated u] (hf : âˆ€ i, Measurable (f i)) (lim : Tendsto f u (ğ“ g)) :
    Measurable g ",":= by
  letI : PseudoMetricSpace Î² := pseudoMetrizableSpacePseudoMetric Î²
  apply measurable_of_isClosed'
  intro s h1s h2s h3s
  have : Measurable fun x => infNndist (g x) s := by
    suffices Tendsto (fun i x => infNndist (f i x) s) u (ğ“ fun x => infNndist (g x) s) from
      NNReal.measurable_of_tendsto' u (fun i => (hf i).infNndist) this
    rw [tendsto_pi_nhds] at lim âŠ¢
    intro x
    exact ((continuous_infNndist_pt s).tendsto (g x)).comp (lim x)
  have h4s : g â»Â¹' s = (fun x => infNndist (g x) s) â»Â¹' {0} := by
    ext x
    simp [h1s, â† h1s.mem_iff_infDist_zero h2s, â† NNReal.coe_eq_zero]
  rw [h4s]
  exact this (measurableSet_singleton 0)",refine measurable_of_tendsto_metrizable'.measurable_of_tendsto_metrizable'.measurable_lim ?_
Mathlib/Probability/Variance.lean,ProbabilityTheory.evariance_eq_zero_iff,evariance_eq_zero_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [evariance, lintegral_eq_zero_iff']
  constructor <;> intro hX <;> filter_upwards [hX] with Ï‰ hÏ‰
  Â· simpa only [Pi.zero_apply, sq_eq_zero_iff, ENNReal.coe_eq_zero, nnnorm_eq_zero, sub_eq_zero]
      using hÏ‰
  Â· rw [hÏ‰]
    simp
  Â· measurability","error:  (deterministic) timeout at `aesop`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information","theorem evariance_eq_zero_iff (hX : AEMeasurable X Î¼) :
    evariance X Î¼ = 0 â†” X =áµ[Î¼] fun _ => Î¼[X] ",":= by
  rw [evariance, lintegral_eq_zero_iff']
  constructor <;> intro hX <;> filter_upwards [hX] with Ï‰ hÏ‰
  Â· simpa only [Pi.zero_apply, sq_eq_zero_iff, ENNReal.coe_eq_zero, nnnorm_eq_zero, sub_eq_zero]
      using hÏ‰
  Â· rw [hÏ‰]
    simp
  Â· exact (hX.sub_const _).ennnorm.pow_const _ ","rw [evariance_eq_zero_iff, evariance_eq_zero_iff]"
Mathlib/NumberTheory/LSeries/HurwitzZetaEven.lean,HurwitzZeta.hasSum_int_completedHurwitzZetaEven,hasSum_int_completedHurwitzZetaEven,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have hF (t : â„) (ht : 0 < t) : HasSum (fun n : â„¤ â†¦ if n + a = 0 then 0
      else (1 / 2 : â„‚) * rexp (-Ï€ * (n + a) ^ 2 * t)) ((evenKernel a t - _) / 2) := by
    refine (ofReal_sub .. â–¸ (hasSum_ofReal.mpr (hasSum_int_evenKernelâ‚€ a ht)).div_const
      2).congr_fun fun n â†¦ ?_
    split_ifs
    Â· rw [ofReal_zero, zero_div]
    Â· rw [mul_comm, mul_one_div]
  rw [show completedHurwitzZetaEven a s = mellin (fun t â†¦ ((evenKernel (â†‘a) t : â„‚) -
        â†‘(if (a : UnitAddCircle) = 0 then 1 else 0 : â„)) / 2) (s / 2) by
    simp_rw [mellin_div_const, apply_ite ofReal', ofReal_one, ofReal_zero]
    refine congr_arg (Â· / 2) ((hurwitzEvenFEPair a).hasMellin (?_ : 1 / 2 < (s / 2).re)).2.symm
    rwa [div_ofNat_re, div_lt_div_right two_pos]]
  refine (hasSum_mellin_pi_mul_sq (zero_lt_one.trans hs) hF ?_).congr_fun fun n â†¦ ?_
  Â· simp_rw [â† mul_one_div â€–_â€–]
    apply Summable.mul_left
    rwa [summable_one_div_int_add_rpow]
  Â· rw [mul_one_div, div_right_comm]","error:  don't know how to synthesize placeholder
context:
a : â„
s : â„‚
hs : 1 < s.re
t : â„
ht : 0 < t
âŠ¢ â„‚
error:  unsolved goals
a : â„
s : â„‚
hs : 1 < s.re
âŠ¢ HasSum (fun n â†¦ s.Gammaâ„ / â†‘|â†‘n + a| ^ s / 2) (completedHurwitzZetaEven (â†‘a) s)","lemma hasSum_int_completedHurwitzZetaEven (a : â„) {s : â„‚} (hs : 1 < re s) :
    HasSum (fun n : â„¤ â†¦ Gammaâ„ s / (â†‘|n + a| : â„‚) ^ s / 2) (completedHurwitzZetaEven a s) ",":= by
  have hF (t : â„) (ht : 0 < t) : HasSum (fun n : â„¤ â†¦ if n + a = 0 then 0
      else (1 / 2 : â„‚) * rexp (-Ï€ * (n + a) ^ 2 * t))
      ((evenKernel a t - (if (a : UnitAddCircle) = 0 then 1 else 0 : â„)) / 2) := by
    refine (ofReal_sub .. â–¸ (hasSum_ofReal.mpr (hasSum_int_evenKernelâ‚€ a ht)).div_const
      2).congr_fun fun n â†¦ ?_
    split_ifs
    Â· rw [ofReal_zero, zero_div]
    Â· rw [mul_comm, mul_one_div]
  rw [show completedHurwitzZetaEven a s = mellin (fun t â†¦ ((evenKernel (â†‘a) t : â„‚) -
        â†‘(if (a : UnitAddCircle) = 0 then 1 else 0 : â„)) / 2) (s / 2) by
    simp_rw [mellin_div_const, apply_ite ofReal', ofReal_one, ofReal_zero]
    refine congr_arg (Â· / 2) ((hurwitzEvenFEPair a).hasMellin (?_ : 1 / 2 < (s / 2).re)).2.symm
    rwa [div_ofNat_re, div_lt_div_right two_pos]]
  refine (hasSum_mellin_pi_mul_sq (zero_lt_one.trans hs) hF ?_).congr_fun fun n â†¦ ?_
  Â· simp_rw [â† mul_one_div â€–_â€–]
    apply Summable.mul_left
    rwa [summable_one_div_int_add_rpow]
  Â· rw [mul_one_div, div_right_comm]",rw [completedHurwitzZetaEven_eq_completedHurwitzZetaEven_eq]
Mathlib/Data/DFinsupp/Basic.lean,DFinsupp.filter_single,filter_single,166d0bf5448fdaad518cf95891af45e08a3e9c35,":= by
  ext j
  have := apply_ite (fun x : Î â‚€ i, Î² i => x j) (p i) (single i x) 0
  dsimp at this
  rw [filter_apply, this]
  obtain rfl | hij := Decidable.eq_or_ne i j
  Â· rfl
  Â· rw [single_eq_of_ne hij, ite_self, Pi.zero_apply, ite_self]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  0 ?i
case h.inr
Î¹ : Type u
Î³ : Type w
Î² : Î¹ â†’ Type v
Î²â‚ : Î¹ â†’ Type vâ‚
Î²â‚‚ : Î¹ â†’ Type vâ‚‚
instâœÂ² : DecidableEq Î¹
instâœÂ¹ : (i : Î¹) â†’ Zero (Î² i)
s : Finset Î¹
xâœ : (i : â†‘â†‘s) â†’ Î² â†‘i
iâœ : Î¹
p : Î¹ â†’ Prop
instâœ : DecidablePred p
i : Î¹
x : Î² i
j : Î¹
this : (if p i then single i x else 0) j = if p i then (single i x) j else 0
hij : i â‰  j
âŠ¢ 0 = if p i then 0 else 0","theorem filter_single (p : Î¹ â†’ Prop) [DecidablePred p] (i : Î¹) (x : Î² i) :
    (single i x).filter p = if p i then single i x else 0 ",":= by
  ext j
  have := apply_ite (fun x : Î â‚€ i, Î² i => x j) (p i) (single i x) 0
  dsimp at this
  rw [filter_apply, this]
  obtain rfl | hij := Decidable.eq_or_ne i j
  Â· rfl
  Â· rw [single_eq_of_ne hij, ite_self, ite_self]",split_ifs with h
Mathlib/Algebra/Module/PID.lean,Module.torsion_by_prime_power_decomposition,torsion_by_prime_power_decomposition,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  obtain âŸ¨d, s, hsâŸ© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  Â· simp only [Nat.zero_eq] at *
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      âŸ¨âŸ¨0âŸ©, fun x => by dsimp; rw [â† Submodule.mem_bot R, hs]; exact Submodule.mem_topâŸ©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact âŸ¨0âŸ©
  Â· have : âˆ€ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain âŸ¨j, hjâŸ© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d â†’ N â§¸ R âˆ™ s j := Submodule.Quotient.mk âˆ˜ s âˆ˜ j.succAbove
    have := IH ?_ s' ?_
    obtain âŸ¨k, âŸ¨fâŸ©âŸ© := this
    clear IH
    Â· have : âˆ€ i : Fin d,
          âˆƒ x : N, p ^ k i â€¢ x = 0 âˆ§ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain âŸ¨x, h0, h1âŸ© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine' âŸ¨x, h0, _âŸ©; rw [h1]
        simp only [LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine âŸ¨?_, âŸ¨?_âŸ©âŸ©
      Â· exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : â„•)) (finSuccEquiv d a)
      Â· refine (((@lequivProdOfRightSplitExact _ _ _ _ _ _ _ _ _ _ _ _
          ((f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          ((DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R â§¸ _ â†’â‚—[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R âˆ™ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R â§¸ R âˆ™ p ^ @Option.rec _ (fun _ => â„•) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        Â· rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        Â· rw [â† f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, â† LinearMap.comp_assoc,
            â† LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R âˆ™ s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one, (this i).choose_spec.right]
    Â· exact (mk_surjective _).forall.mpr fun x =>
        âŸ¨(@hN x).choose, by rw [â† Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]âŸ©
    Â· have hs' := congr_arg (Submodule.map <| mkQ <| R âˆ™ s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only; rw [â† Function.comp.assoc, Set.range_comp (_ âˆ˜ s), Fin.range_succAbove]
      rw [â† Set.range_comp, â† Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'","error:  simp made no progress
error:  simp made no progress
error:  tactic 'rewrite' failed, motive is not type correct
case h.succ.intro.refine_3.intro.intro.refine_2.refine_2.H.h.h
R : Type u
instâœâ¶ : CommRing R
instâœâµ : IsDomain R
instâœâ´ : IsPrincipalIdealRing R
M : Type v
instâœÂ³ : AddCommGroup M
instâœÂ² : Module R M
p : R
hp : Irreducible p
hM : IsTorsion' M â†¥(Submonoid.powers p)
dec : (x : M) â†’ Decidable (x = 0)
d : â„•
N : Type (max u v)
instâœÂ¹ : AddCommGroup N
instâœ : Module R N
hN : IsTorsion' N â†¥(Submonoid.powers p)
s : Fin (d + 1) â†’ N
hs : Submodule.span R (Set.range s) = âŠ¤
thisâœ : (x : N) â†’ Decidable (x = 0)
j : Fin d.succ
hj : IsTorsionBy R N (p ^ pOrder hN (s j))
s' : Fin d â†’ N â§¸ Submodule.span R {s j} := Submodule.Quotient.mk âˆ˜ s âˆ˜ j.succAbove
k : Fin d â†’ â„•
f : (N â§¸ Submodule.span R {s j}) â‰ƒâ‚—[R] â¨ (i : Fin d), R â§¸ Submodule.span R {p ^ k i}
this :
  âˆ€ (i : Fin d),
    âˆƒ x,
      p ^ k i â€¢ x = 0 âˆ§
        f (Submodule.Quotient.mk x) = (DirectSum.lof R (Fin d) (fun i â†¦ R â§¸ Submodule.span R {p ^ k i}) i) 1
i : Fin d
âŠ¢ f (Submodule.Quotient.mk â‹¯.choose) =
    (DirectSum.lof R (Fin d) (fun i â†¦ R â§¸ Submodule.span R {p ^ k i}) i)
      ((Ideal.Quotient.mk (Submodule.span R {p ^ k i})) 1)
error:  failed to synthesize
  One (â¨ (i : Fin d), R â§¸ Submodule.span R {p ^ k i})
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  OneHomClass (R â§¸ Submodule.span R {p ^ k i} â†’â‚—[R] â¨ (i : Fin d), R â§¸ Submodule.span R {p ^ k i})
    (R â§¸ Submodule.span R {p ^ k i}) (â¨ (i : Fin d), R â§¸ Submodule.span R {p ^ k i})
use `set_option diagnostics true` to get diagnostic information
error:  simp made no progress","theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    âˆƒ (d : â„•) (k : Fin d â†’ â„•), Nonempty <| N â‰ƒâ‚—[R] â¨ i : Fin d, R â§¸ R âˆ™ p ^ (k i : â„•) ",":= by
  obtain âŸ¨d, s, hsâŸ© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  Â· 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      âŸ¨âŸ¨0âŸ©, fun x => by dsimp; rw [â† Submodule.mem_bot R, hs]; exact Submodule.mem_topâŸ©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact âŸ¨0âŸ©
  Â· have : âˆ€ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain âŸ¨j, hjâŸ© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d â†’ N â§¸ R âˆ™ s j := Submodule.Quotient.mk âˆ˜ s âˆ˜ j.succAbove
    have := IH ?_ s' ?_
    Â· obtain âŸ¨k, âŸ¨fâŸ©âŸ© := this
      clear IH
      have : âˆ€ i : Fin d,
          âˆƒ x : N, p ^ k i â€¢ x = 0 âˆ§ f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain âŸ¨x, h0, h1âŸ© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine âŸ¨x, h0, ?_âŸ©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine âŸ¨?_, âŸ¨?_âŸ©âŸ©
      Â· exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : â„•)) (finSuccEquiv d a)
      Â· refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R â§¸ _ â†’â‚—[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R âˆ™ s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R â§¸ R âˆ™ p ^ @Option.rec _ (fun _ => â„•) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        Â· rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        Â· rw [â† f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, â† LinearMap.comp_assoc,
            â† LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R âˆ™ s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    Â· exact (mk_surjective _).forall.mpr fun x =>
        âŸ¨(@hN x).choose, by rw [â† Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]âŸ©
    Â· have hs' := congr_arg (Submodule.map <| mkQ <| R âˆ™ s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [â† Function.comp.assoc, Set.range_comp (_ âˆ˜ s), Fin.range_succAbove]
      rw [â† Set.range_comp, â† Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'","refine âŸ¨torsion_by_prime_power_decomposition hN h', ?_âŸ©"
Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean,CochainComplex.HomComplex.Cocycle.coe_sub,coe_sub,9072ff84a0d139a344bf9eed4a00c4cd27596c79,  (zâ‚ : Cochain F G n) - (zâ‚‚ : Cochain F G n) := rfl,"error:  application type mismatch
  â†‘zâ‚‚ â†‘zâ‚
argument
  â†‘zâ‚
has type
  Cochain F G n : Type v
but is expected to have type
  Triplet n : Type","lemma coe_sub (zâ‚ zâ‚‚ : Cocycle F G n) :
    (â†‘(zâ‚ - zâ‚‚) : Cochain F G n) = (zâ‚ : Cochain F G n) - (zâ‚‚ : Cochain F G n) ",:= rfl,"simp only [Cocycle.coe_sub, Cocycle.sub, Cocycle.coe_sub, Cocycle.coe_sub]"
Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean,RingHom.PropertyIsLocal.sourceAffineLocally_of_source_openCover,sourceAffineLocally_of_source_openCover,8521d5a6ab9a0abc6319fae2d116feb58acc6f93,":= by
  let S i := (âŸ¨âŸ¨Set.range (ğ’°.map i).1.base, (ğ’°.IsOpen i).base_open.isOpen_rangeâŸ©,
    rangeIsAffineOpenOfOpenImmersion (ğ’°.map i)âŸ© : X.affineOpens)
  intro U
  apply of_affine_open_cover
    (P := fun V => P (Scheme.Î“.map (X.ofRestrict (Opens.openEmbedding V.val) â‰« f).op)) U
  pick_goal 5
  Â· exact Set.range S
  Â· intro U r H
    convert hP.StableUnderComposition
      (S := Scheme.Î“.obj (Opposite.op (X.restrict <| Opens.openEmbedding U.val)))
      (T := Scheme.Î“.obj (Opposite.op (X.restrict <| Opens.openEmbedding (X.basicOpen r))))
      ?_ ?_ H ?_ using 1
    swap
    Â· refine' X.presheaf.map
          (@homOfLE _ _ ((IsOpenMap.functor _).obj _) ((IsOpenMap.functor _).obj _) _).op
      dsimp
      rw [Opens.openEmbedding_obj_top, Opens.openEmbedding_obj_top]
      exact X.basicOpen_le _
    Â· rw [op_comp, op_comp, Functor.map_comp, Functor.map_comp]
      refine' (Eq.trans _ (Category.assoc (obj := CommRingCat) _ _ _).symm : _)
      congr 1
      dsimp
      refine' Eq.trans _ (X.presheaf.map_comp _ _)
      change X.presheaf.map _ = _
      congr!
    convert @HoldsForLocalizationAway _ hP _
      (Scheme.Î“.obj (Opposite.op (X.restrict (X.basicOpen r).openEmbedding))) _ _ ?_
      (X.presheaf.map (eqToHom U.1.openEmbedding_obj_top).op r) ?_
    Â· exact RingHom.algebraMap_toAlgebra
        (R := Scheme.Î“.obj <| Opposite.op <| X.restrict (U.1.openEmbedding))
        (S :=
          Scheme.Î“.obj (Opposite.op <| X.restrict (X.affineBasicOpen r).1.openEmbedding)) _|>.symm
    Â· dsimp [Scheme.Î“]
      have := U.2
      rw [â† U.1.openEmbedding_obj_top] at this
      convert (config := {typeEqs := true, transparency := .default})
          this.isLocalization_basicOpen _ using 5
      all_goals rw [Opens.openEmbedding_obj_top]; exact (Scheme.basicOpen_res_eq _ _ _).symm
  Â· introv hs hs'
    exact sourceAffineLocally_of_source_open_cover_aux hP.respectsIso hP.2 _ _ _ hs hs'
  Â· rw [Set.eq_univ_iff_forall]
    intro x
    rw [Set.mem_iUnion]
    exact âŸ¨âŸ¨_, ğ’°.f x, rflâŸ©, ğ’°.Covers xâŸ©
  Â· rintro âŸ¨_, i, rflâŸ©
    specialize H i
    rw [â† hP.respectsIso.cancel_right_isIso _
        (Scheme.Î“.map
          (IsOpenImmersion.isoOfRangeEq (ğ’°.map i) (X.ofRestrict (S i).1.openEmbedding)
                Subtype.range_coe.symm).inv.op)] at H
    rwa [â† Scheme.Î“.map_comp, â† op_comp, IsOpenImmersion.isoOfRangeEq_inv_fac_assoc] at H","warning:  `AlgebraicGeometry.rangeIsAffineOpenOfOpenImmersion` has been deprecated, use `AlgebraicGeometry.isAffineOpen_opensRange` instead
error:  application type mismatch
  of_affine_open_cover U
argument
  U
has type
  â†‘X.affineOpens : Type u
but is expected to have type
  ?m.93813 â†’ â†‘X.affineOpens : Sort (max ?u.93479 (u + 1))
error:  application type mismatch
  @sourceAffineLocally_of_source_openCover ?m.99928 ?m.99929 ?m.99930 hP
argument
  hP
has type
  PropertyIsLocal P : Prop
but is expected to have type
  ?m.99929 âŸ¶ ?m.99930 : Type ?u.99927","theorem sourceAffineLocally_of_source_openCover {X Y : Scheme.{u}} (f : X âŸ¶ Y) [IsAffine Y]
    (ğ’° : X.OpenCover) [âˆ€ i, IsAffine (ğ’°.obj i)] (H : âˆ€ i, P (Scheme.Î“.map (ğ’°.map i â‰« f).op)) :
    sourceAffineLocally (@P) f ",":= by
  let S i := (âŸ¨âŸ¨Set.range (ğ’°.map i).1.base, (ğ’°.IsOpen i).base_open.isOpen_rangeâŸ©,
    isAffineOpen_opensRange (ğ’°.map i)âŸ© : X.affineOpens)
  intro U
  apply of_affine_open_cover
    (P := fun V => P (Scheme.Î“.map (X.ofRestrict (Opens.openEmbedding V.val) â‰« f).op)) S
    ğ’°.iSup_opensRange
  Â· intro U r H
    convert hP.StableUnderComposition
      (S := Scheme.Î“.obj (Opposite.op (X.restrict <| Opens.openEmbedding U.val)))
      (T := Scheme.Î“.obj (Opposite.op (X.restrict <| Opens.openEmbedding (X.basicOpen r))))
      ?_ ?_ H ?_ using 1
    swap
    Â· refine X.presheaf.map
          (@homOfLE _ _ ((IsOpenMap.functor _).obj _) ((IsOpenMap.functor _).obj _) ?_).op
      dsimp
      rw [Opens.openEmbedding_obj_top, Opens.openEmbedding_obj_top]
      exact X.basicOpen_le _
    Â· rw [op_comp, op_comp, Functor.map_comp, Functor.map_comp]
      refine (Eq.trans ?_ (Category.assoc (obj := CommRingCat) _ _ _).symm : _)
      congr 1
      dsimp
      refine Eq.trans ?_ (X.presheaf.map_comp _ _)
      change X.presheaf.map _ = _
      congr!
    convert @HoldsForLocalizationAway _ hP _
      (Scheme.Î“.obj (Opposite.op (X.restrict (X.basicOpen r).openEmbedding))) _ _ ?_
      (X.presheaf.map (eqToHom U.1.openEmbedding_obj_top).op r) ?_
    Â· exact RingHom.algebraMap_toAlgebra
        (R := Scheme.Î“.obj <| Opposite.op <| X.restrict (U.1.openEmbedding))
        (S :=
          Scheme.Î“.obj (Opposite.op <| X.restrict (X.affineBasicOpen r).1.openEmbedding)) _|>.symm
    Â· dsimp [Scheme.Î“]
      have := U.2
      rw [â† U.1.openEmbedding_obj_top] at this
      convert (config := {typeEqs := true, transparency := .default})
          this.isLocalization_basicOpen _ using 5
      all_goals rw [Opens.openEmbedding_obj_top]; exact (Scheme.basicOpen_res_eq _ _ _).symm
  Â· introv hs hs'
    exact sourceAffineLocally_of_source_open_cover_aux hP.respectsIso hP.2 _ _ _ hs hs'
  Â· rintro i
    specialize H i
    rw [â† hP.respectsIso.cancel_right_isIso _
        (Scheme.Î“.map
          (IsOpenImmersion.isoOfRangeEq (ğ’°.map i) (X.ofRestrict (S i).1.openEmbedding)
                Subtype.range_coe.symm).inv.op)] at H
    rwa [â† Scheme.Î“.map_comp, â† op_comp, IsOpenImmersion.isoOfRangeEq_inv_fac_assoc] at H",apply sourceAffineLocally_of_source_openCover
Mathlib/Order/ConditionallyCompleteLattice/Basic.lean,WithTop.iInf_coe_lt_top,iInf_coe_lt_top,ab7200bce341f8e2a4e6620f32a3d6335eccb5c4,":= by
  rw [lt_top_iff_ne_top, Ne.def, iInf_coe_eq_top, not_isEmpty_iff]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.169231 â†’ ?m.169231 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.169233
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Î¹ : Sort u_4
instâœ : ConditionallyCompleteLinearOrderBot Î±
f : Î¹ â†’ Î±
âŠ¢ â¨… i, â†‘(f i) â‰  âŠ¤ â†” Nonempty Î¹","lemma iInf_coe_lt_top : â¨… i, (f i : WithTop Î±) < âŠ¤ â†” Nonempty Î¹ ",":= by
  rw [lt_top_iff_ne_top, Ne, iInf_coe_eq_top, not_isEmpty_iff]",constructor
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOn,hasFDerivAt_of_tendstoUniformlyOn,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @IsROrC.norm_ofReal ğ•œ _ _, IsROrC.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0); simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Îµ hÎµ).mono fun y hy => _
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  Â· 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_op_norm (n.2 - x)",error:  unexpected token ';'; expected '|',"theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ğ“ x))
    (hf : âˆ€á¶  n : Î¹ Ã— E in l Ã—Ë¢ ğ“ x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : âˆ€á¶  y in ğ“ x, Tendsto (fun n => f n y) l (ğ“ (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","refine theorem_hasFDerivAt_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_of_tendstoUniformlyOnFilter_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOn hasFDerivAt_contin"
Mathlib/Data/List/Indexes.lean,List.mapIdx_append,mapIdx_append,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  intros f l e
  unfold mapIdx
  rw [mapIdxGo_append f l [e]]
  simp only [mapIdx.go, Array.size_toArray, mapIdxGo_length, length_nil, add_zero, Array.toList_eq,
    Array.push_data, Array.data_toArray]","error:  unsolved goals
Î± : Type u
Î² : Type v
f : â„• â†’ Î± â†’ Î²
l : List Î±
e : Î±
âŠ¢ mapIdx.go f l #[] ++ [f (l.length + 0) e] = mapIdx.go f l #[] ++ [f l.length e]
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem mapIdx_append_one : âˆ€ (f : â„• â†’ Î± â†’ Î²) (l : List Î±) (e : Î±),
    mapIdx f (l ++ [e]) = mapIdx f l ++ [f l.length e] ",":= by
  intros f l e
  unfold mapIdx
  rw [mapIdxGo_append f l [e]]
  simp only [mapIdx.go, Array.size_toArray, mapIdxGo_length, length_nil, Nat.add_zero,
    Array.toList_eq, Array.push_data, Array.data_toArray]","rw [mapIdx_append_one, mapIdx_append_one]"
Mathlib/RingTheory/WittVector/Isocrystal.lean,WittVector.isocrystal_classification,isocrystal_classification,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  haveI : Nontrivial V := FiniteDimensional.nontrivial_of_finrank_eq_succ h_dim
  obtain âŸ¨x, hxâŸ© : âˆƒ x : V, x â‰  0 := exists_ne 0
  have : Î¦(p, k) x â‰  0 := by simpa only [map_zero] using Î¦(p, k).injective.ne hx
  obtain âŸ¨a, ha, haxâŸ© : âˆƒ a : K(p, k), a â‰  0 âˆ§ Î¦(p, k) x = a â€¢ x := by
    rw [finrank_eq_one_iff_of_nonzero' x hx] at h_dim
    obtain âŸ¨a, haâŸ© := h_dim (Î¦(p, k) x)
    refine' âŸ¨a, _, ha.symmâŸ©
    intro ha'
    apply this
    simp only [â† ha, ha', zero_smul]
  obtain âŸ¨b, hb, m, hmbâŸ© := WittVector.exists_frobenius_solution_fractionRing p ha
  replace hmb : Ï†(p, k) b * a = (p : K(p, k)) ^ m * b := by convert hmb
  use m
  let Fâ‚€ : StandardOneDimIsocrystal p k m â†’â‚—[K(p, k)] V := LinearMap.toSpanSingleton K(p, k) V x
  let F : StandardOneDimIsocrystal p k m â‰ƒâ‚—[K(p, k)] V := by
    refine' LinearEquiv.ofBijective Fâ‚€ âŸ¨_, _âŸ©
    Â· rw [â† LinearMap.ker_eq_bot]
      exact LinearMap.ker_toSpanSingleton K(p, k) V hx
    Â· rw [â† LinearMap.range_eq_top]
      rw [â† (finrank_eq_one_iff_of_nonzero x hx).mp h_dim]
      rw [LinearMap.span_singleton_eq_range]
  let E := (LinearEquiv.smulOfNeZero K(p, k) _ _ hb).trans F
  refine' âŸ¨âŸ¨E, _âŸ©âŸ©
  simp only
  intro c
  rw [LinearEquiv.trans_apply, LinearEquiv.trans_apply, LinearEquiv.smulOfNeZero_apply,
    LinearEquiv.smulOfNeZero_apply, LinearEquiv.map_smul, LinearEquiv.map_smul]
  rw [LinearEquiv.ofBijective_apply, LinearEquiv.ofBijective_apply]
  erw [LinearMap.toSpanSingleton_apply K(p, k) V x c, LinearMap.toSpanSingleton_apply K(p, k) V x]
  simp only [hax, LinearEquiv.ofBijective_apply, LinearMap.toSpanSingleton_apply,
    LinearEquiv.map_smulâ‚›â‚—, StandardOneDimIsocrystal.frobenius_apply, Algebra.id.smul_eq_mul]
  simp only [â† mul_smul]
  congr 1
  linear_combination Ï†(p, k) c * hmb",error:  simp made no progress,"theorem isocrystal_classification (k : Type*) [Field k] [IsAlgClosed k] [CharP k p] (V : Type*)
    [AddCommGroup V] [Isocrystal p k V] (h_dim : finrank K(p, k) V = 1) :
    âˆƒ m : â„¤, Nonempty (StandardOneDimIsocrystal p k m â‰ƒá¶ â±[p, k] V) ",":= by
  haveI : Nontrivial V := FiniteDimensional.nontrivial_of_finrank_eq_succ h_dim
  obtain âŸ¨x, hxâŸ© : âˆƒ x : V, x â‰  0 := exists_ne 0
  have : Î¦(p, k) x â‰  0 := by simpa only [map_zero] using Î¦(p, k).injective.ne hx
  obtain âŸ¨a, ha, haxâŸ© : âˆƒ a : K(p, k), a â‰  0 âˆ§ Î¦(p, k) x = a â€¢ x := by
    rw [finrank_eq_one_iff_of_nonzero' x hx] at h_dim
    obtain âŸ¨a, haâŸ© := h_dim (Î¦(p, k) x)
    refine âŸ¨a, ?_, ha.symmâŸ©
    intro ha'
    apply this
    simp only [â† ha, ha', zero_smul]
  obtain âŸ¨b, hb, m, hmbâŸ© := WittVector.exists_frobenius_solution_fractionRing p ha
  replace hmb : Ï†(p, k) b * a = (p : K(p, k)) ^ m * b := by convert hmb
  use m
  let Fâ‚€ : StandardOneDimIsocrystal p k m â†’â‚—[K(p, k)] V := LinearMap.toSpanSingleton K(p, k) V x
  let F : StandardOneDimIsocrystal p k m â‰ƒâ‚—[K(p, k)] V := by
    refine LinearEquiv.ofBijective Fâ‚€ âŸ¨?_, ?_âŸ©
    Â· rw [â† LinearMap.ker_eq_bot]
      exact LinearMap.ker_toSpanSingleton K(p, k) V hx
    Â· rw [â† LinearMap.range_eq_top]
      rw [â† (finrank_eq_one_iff_of_nonzero x hx).mp h_dim]
      rw [LinearMap.span_singleton_eq_range]
  refine âŸ¨âŸ¨(LinearEquiv.smulOfNeZero K(p, k) _ _ hb).trans F, fun c â†¦ ?_âŸ©âŸ©
  rw [LinearEquiv.trans_apply, LinearEquiv.trans_apply, LinearEquiv.smulOfNeZero_apply,
    LinearEquiv.smulOfNeZero_apply, LinearEquiv.map_smul, LinearEquiv.map_smul]
  rw [LinearEquiv.ofBijective_apply, LinearEquiv.ofBijective_apply]
  erw [LinearMap.toSpanSingleton_apply K(p, k) V x c, LinearMap.toSpanSingleton_apply K(p, k) V x]
  simp only [hax, LinearEquiv.ofBijective_apply, LinearMap.toSpanSingleton_apply,
    LinearEquiv.map_smulâ‚›â‚—, StandardOneDimIsocrystal.frobenius_apply, Algebra.id.smul_eq_mul]
  simp only [â† mul_smul]
  congr 1
  linear_combination Ï†(p, k) c * hmb","obtain âŸ¨m, hmâŸ© := finrank_eq_one_iff.mp h_dim"
Mathlib/MeasureTheory/Function/ConditionalExpectation/Unique.lean,MeasureTheory.integral_norm_le_of_forall_fin_meas_integral_eq,integral_norm_le_of_forall_fin_meas_integral_eq,7dc162787d2a79bf721a83a87f641ace70251b17,":= by
  rw [integral_norm_eq_pos_sub_neg hgi, integral_norm_eq_pos_sub_neg hfi]
  have h_meas_nonneg_g : MeasurableSet[m] {x | 0 â‰¤ g x} :=
    (@stronglyMeasurable_const _ _ m _ _).measurableSet_le hg
  have h_meas_nonneg_f : MeasurableSet {x | 0 â‰¤ f x} :=
    stronglyMeasurable_const.measurableSet_le hf
  have h_meas_nonpos_g : MeasurableSet[m] {x | g x â‰¤ 0} :=
    hg.measurableSet_le (@stronglyMeasurable_const _ _ m _ _)
  have h_meas_nonpos_f : MeasurableSet {x | f x â‰¤ 0} :=
    hf.measurableSet_le stronglyMeasurable_const
  refine' sub_le_sub _ _
  Â· rw [Measure.restrict_restrict (hm _ h_meas_nonneg_g), Measure.restrict_restrict h_meas_nonneg_f,
      hgf _ (@MeasurableSet.inter Î± m _ _ h_meas_nonneg_g hs)
        ((measure_mono (Set.inter_subset_right _ _)).trans_lt (lt_top_iff_ne_top.mpr hÎ¼s)),
      â† Measure.restrict_restrict (hm _ h_meas_nonneg_g), â†
      Measure.restrict_restrict h_meas_nonneg_f]
    exact set_integral_le_nonneg (hm _ h_meas_nonneg_g) hf hfi
  Â· rw [Measure.restrict_restrict (hm _ h_meas_nonpos_g), Measure.restrict_restrict h_meas_nonpos_f,
      hgf _ (@MeasurableSet.inter Î± m _ _ h_meas_nonpos_g hs)
        ((measure_mono (Set.inter_subset_right _ _)).trans_lt (lt_top_iff_ne_top.mpr hÎ¼s)),
      â† Measure.restrict_restrict (hm _ h_meas_nonpos_g), â†
      Measure.restrict_restrict h_meas_nonpos_f]
    exact set_integral_nonpos_le (hm _ h_meas_nonpos_g) hf hfi","error:  function expected at
  Set.inter_subset_right ?m.26528
term has type
  ?m.26527 âˆˆ ?m.26526
warning:  `MeasureTheory.set_integral_le_nonneg` has been deprecated, use `MeasureTheory.setIntegral_le_nonneg` instead
error:  function expected at
  Set.inter_subset_right ?m.27494
term has type
  ?m.27493 âˆˆ ?m.27492
warning:  `MeasureTheory.set_integral_nonpos_le` has been deprecated, use `MeasureTheory.setIntegral_nonpos_le` instead","theorem integral_norm_le_of_forall_fin_meas_integral_eq (hm : m â‰¤ m0) {f g : Î± â†’ â„}
    (hf : StronglyMeasurable f) (hfi : IntegrableOn f s Î¼) (hg : StronglyMeasurable[m] g)
    (hgi : IntegrableOn g s Î¼)
    (hgf : âˆ€ t, MeasurableSet[m] t â†’ Î¼ t < âˆ â†’ âˆ« x in t, g x âˆ‚Î¼ = âˆ« x in t, f x âˆ‚Î¼)
    (hs : MeasurableSet[m] s) (hÎ¼s : Î¼ s â‰  âˆ) : (âˆ« x in s, â€–g xâ€– âˆ‚Î¼) â‰¤ âˆ« x in s, â€–f xâ€– âˆ‚Î¼ ",":= by
  rw [integral_norm_eq_pos_sub_neg hgi, integral_norm_eq_pos_sub_neg hfi]
  have h_meas_nonneg_g : MeasurableSet[m] {x | 0 â‰¤ g x} :=
    (@stronglyMeasurable_const _ _ m _ _).measurableSet_le hg
  have h_meas_nonneg_f : MeasurableSet {x | 0 â‰¤ f x} :=
    stronglyMeasurable_const.measurableSet_le hf
  have h_meas_nonpos_g : MeasurableSet[m] {x | g x â‰¤ 0} :=
    hg.measurableSet_le (@stronglyMeasurable_const _ _ m _ _)
  have h_meas_nonpos_f : MeasurableSet {x | f x â‰¤ 0} :=
    hf.measurableSet_le stronglyMeasurable_const
  refine sub_le_sub ?_ ?_
  Â· rw [Measure.restrict_restrict (hm _ h_meas_nonneg_g), Measure.restrict_restrict h_meas_nonneg_f,
      hgf _ (@MeasurableSet.inter Î± m _ _ h_meas_nonneg_g hs)
        ((measure_mono Set.inter_subset_right).trans_lt (lt_top_iff_ne_top.mpr hÎ¼s)),
      â† Measure.restrict_restrict (hm _ h_meas_nonneg_g), â†
      Measure.restrict_restrict h_meas_nonneg_f]
    exact setIntegral_le_nonneg (hm _ h_meas_nonneg_g) hf hfi
  Â· rw [Measure.restrict_restrict (hm _ h_meas_nonpos_g), Measure.restrict_restrict h_meas_nonpos_f,
      hgf _ (@MeasurableSet.inter Î± m _ _ h_meas_nonpos_g hs)
        ((measure_mono Set.inter_subset_right).trans_lt (lt_top_iff_ne_top.mpr hÎ¼s)),
      â† Measure.restrict_restrict (hm _ h_meas_nonpos_g), â†
      Measure.restrict_restrict h_meas_nonpos_f]
    exact setIntegral_nonpos_le (hm _ h_meas_nonpos_g) hf hfi",rw [theorem_eq_integral_norm_le_of_forall_fin_meas_integral_eq]
Mathlib/RingTheory/UniqueFactorizationDomain.lean,UniqueFactorizationMonoid.induction_on_prime_power,induction_on_prime_power,c342c339a777827331257acd880fea6d441a6aa6,":= by
  letI := Classical.decEq Î±
  induction' s with p f' hpf' ih
  Â· simpa using h1 isUnit_one
  rw [Finset.prod_insert hpf']
  exact
    hcp (prime_pow_coprime_prod_of_coprime_insert i p hpf' is_prime is_coprime)
      (hpr (i p) (is_prime _ (Finset.mem_insert_self _ _)))
      (ih (fun q hq => is_prime _ (Finset.mem_insert_of_mem hq)) fun q hq q' hq' =>
        is_coprime _ (Finset.mem_insert_of_mem hq) _ (Finset.mem_insert_of_mem hq'))","error:  type mismatch
  hâœ
has type
  P 1 : Prop
but is expected to have type
  P (Multiset.map (fun p â†¦ p ^ i p) p).prod : Prop
error:  no goals to be solved","theorem induction_on_prime_power {P : Î± â†’ Prop} (s : Finset Î±) (i : Î± â†’ â„•)
    (is_prime : âˆ€ p âˆˆ s, Prime p) (is_coprime : âˆ€áµ‰ (p âˆˆ s) (q âˆˆ s), p âˆ£ q â†’ p = q)
    (h1 : âˆ€ {x}, IsUnit x â†’ P x) (hpr : âˆ€ {p} (i : â„•), Prime p â†’ P (p ^ i))
    (hcp : âˆ€ {x y}, IsRelPrime x y â†’ P x â†’ P y â†’ P (x * y)) :
    P (âˆ p âˆˆ s, p ^ i p) ",":= by
  letI := Classical.decEq Î±
  induction' s using Finset.induction_on with p f' hpf' ih
  Â· simpa using h1 isUnit_one
  rw [Finset.prod_insert hpf']
  exact
    hcp (prime_pow_coprime_prod_of_coprime_insert i p hpf' is_prime is_coprime)
      (hpr (i p) (is_prime _ (Finset.mem_insert_self _ _)))
      (ih (fun q hq => is_prime _ (Finset.mem_insert_of_mem hq)) fun q hq q' hq' =>
        is_coprime _ (Finset.mem_insert_of_mem hq) _ (Finset.mem_insert_of_mem hq'))",apply theorem_induction_on_prime_prime
Mathlib/Order/CompactlyGenerated/Basic.lean,CompleteLattice.independent_iff_supIndep_of_injOn,CompleteLattice.independent_iff_supIndep_of_injOn,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  refine âŸ¨fun h â†¦ h.supIndep', fun h â†¦ CompleteLattice.independent_def'.mpr fun i â†¦ ?_âŸ©
  simp_rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot, â† disjoint_iff]
  intro s hs
  classical
  rw [â† Finset.sup_erase_bot]
  set t := s.erase âŠ¥
  replace hf : InjOn f (f â»Â¹' t) := fun i hi j _ hij â†¦ by refine hf ?_ ?_ hij <;> aesop
  have : (Finset.erase (insert i (t.preimage _ hf)) i).image f = t := by
    ext a
    simp only [Finset.mem_preimage, Finset.mem_erase, ne_eq, Finset.mem_insert, true_or, not_true,
      Finset.erase_insert_eq_erase, not_and, Finset.mem_image]
    refine âŸ¨by aesop, fun âŸ¨ha, hasâŸ© â†¦ ?_âŸ©
    obtain âŸ¨j, hj, rflâŸ© := hs has
    exact âŸ¨j, âŸ¨hj, ha, hasâŸ©, rflâŸ©
  rw [â† this, Finset.sup_image]
  specialize h (insert i (t.preimage _ hf))
  rw [Finset.supIndep_iff_disjoint_erase] at h
  exact h i (Finset.mem_insert_self i _)","error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  Quot.lift (fun l â†¦ a âˆˆ l) â‹¯ t.val
error:  no goals to be solved","lemma CompleteLattice.independent_iff_supIndep_of_injOn {Î¹ : Type*} {f : Î¹ â†’ Î±}
    (hf : InjOn f {i | f i â‰  âŠ¥}) :
    CompleteLattice.Independent f â†” âˆ€ (s : Finset Î¹), s.SupIndep f ",":= by
  refine âŸ¨fun h â†¦ h.supIndep', fun h â†¦ CompleteLattice.independent_def'.mpr fun i â†¦ ?_âŸ©
  simp_rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot, â† disjoint_iff]
  intro s hs
  classical
  rw [â† Finset.sup_erase_bot]
  set t := s.erase âŠ¥
  replace hf : InjOn f (f â»Â¹' t) := fun i hi j _ hij â†¦ by
    refine hf ?_ ?_ hij <;> aesop (add norm simp [t])
  have : (Finset.erase (insert i (t.preimage _ hf)) i).image f = t := by
    ext a
    simp only [Finset.mem_preimage, Finset.mem_erase, ne_eq, Finset.mem_insert, true_or, not_true,
      Finset.erase_insert_eq_erase, not_and, Finset.mem_image, t]
    refine âŸ¨by aesop, fun âŸ¨ha, hasâŸ© â†¦ ?_âŸ©
    obtain âŸ¨j, hj, rflâŸ© := hs has
    exact âŸ¨j, âŸ¨hj, ha, hasâŸ©, rflâŸ©
  rw [â† this, Finset.sup_image]
  specialize h (insert i (t.preimage _ hf))
  rw [Finset.supIndep_iff_disjoint_erase] at h
  exact h i (Finset.mem_insert_self i _)",constructor
Mathlib/RingTheory/HahnSeries/Multiplication.lean,HahnSeries.support_mul_subset_add_support,support_mul_subset_add_support,1dd0eeb9de3fcbf68872a2439d830ab784a70c13,":= by
  rw [â† of_symm_smul_of_eq_mul, â† vadd_eq_add]
  exact HahnModule.support_smul_subset_vAdd_support",error:  unknown constant 'HahnModule.support_smul_subset_vAdd_support',"theorem support_mul_subset_add_support [NonUnitalNonAssocSemiring R] {x y : HahnSeries Î“ R} :
    support (x * y) âŠ† support x + support y ",":= by
  apply Set.Subset.trans (fun x hx => _) support_addAntidiagonal_subset_add
  Â· exact x.isPWO_support
  Â· exact y.isPWO_support
  intro x hx
  contrapose! hx
  simp only [not_nonempty_iff_eq_empty, Ne, Set.mem_setOf_eq] at hx
  simp [hx, mul_coeff]","rw [support_mul_subset_add_support, support_mul_subset_add_support]"
Mathlib/NumberTheory/Divisors.lean,Nat.eq_properDivisors_of_subset_of_sum_eq_sum,eq_properDivisors_of_subset_of_sum_eq_sum,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  cases n
  Â· rw [properDivisors_zero, subset_empty] at hsub
    simp [hsub]
  classical
    rw [â† sum_sdiff hsub]
    intro h
    apply Subset.antisymm hsub
    rw [â† sdiff_eq_empty_iff_subset]
    contrapose h
    rw [â† Ne, â† nonempty_iff_ne_empty] at h
    apply ne_of_lt
    rw [â† zero_add (âˆ‘ x âˆˆ s, x), â† add_assoc, add_zero]
    apply add_lt_add_right
    have hlt :=
      sum_lt_sum_of_nonempty h fun x hx => pos_of_mem_properDivisors (sdiff_subset _ _ hx)
    simp only [sum_const_zero] at hlt
    apply hlt","error:  function expected at
  sdiff_subset ?m.40956
term has type
  ?m.40955 âˆˆ ?m.40953
error:  unsolved goals
case succ.h.bc
s : Finset â„•
nâœ : â„•
hsub : s âŠ† (nâœ + 1).properDivisors
h : ((nâœ + 1).properDivisors \ s).Nonempty
âŠ¢ 0 < âˆ‘ x âˆˆ (nâœ + 1).properDivisors \ s, x","theorem eq_properDivisors_of_subset_of_sum_eq_sum {s : Finset â„•} (hsub : s âŠ† n.properDivisors) :
    ((âˆ‘ x âˆˆ s, x) = âˆ‘ x âˆˆ n.properDivisors, x) â†’ s = n.properDivisors ",":= by
  cases n
  Â· rw [properDivisors_zero, subset_empty] at hsub
    simp [hsub]
  classical
    rw [â† sum_sdiff hsub]
    intro h
    apply Subset.antisymm hsub
    rw [â† sdiff_eq_empty_iff_subset]
    contrapose h
    rw [â† Ne, â† nonempty_iff_ne_empty] at h
    apply ne_of_lt
    rw [â† zero_add (âˆ‘ x âˆˆ s, x), â† add_assoc, add_zero]
    apply add_lt_add_right
    have hlt :=
      sum_lt_sum_of_nonempty h fun x hx => pos_of_mem_properDivisors (sdiff_subset hx)
    simp only [sum_const_zero] at hlt
    apply hlt",refine eq_properDivisors_of_subset_of_subset_of_subset_of_subset_of_subset_of_subset_of_subset_of_subset_of_subset_of_subset_of_subset hsub
Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean,Sbtw.angleâ‚â‚‚â‚ƒ_eq_pi,_root_.Sbtw.angleâ‚â‚‚â‚ƒ_eq_pi,20f7b16a2188446119159f1899fa98e635e7c11d,":= by
  rw [angle, angle_eq_pi_iff]
  rcases h with âŸ¨âŸ¨r, âŸ¨hr0, hr1âŸ©, hpâ‚‚âŸ©, hpâ‚‚pâ‚, hpâ‚‚pâ‚ƒâŸ©
  refine' âŸ¨vsub_ne_zero.2 hpâ‚‚pâ‚.symm, -(1 - r) / r, _âŸ©
  have hr0' : r â‰  0 := by
    rintro rfl
    rw [â† hpâ‚‚] at hpâ‚‚pâ‚
    simp at hpâ‚‚pâ‚
  have hr1' : r â‰  1 := by
    rintro rfl
    rw [â† hpâ‚‚] at hpâ‚‚pâ‚ƒ
    simp at hpâ‚‚pâ‚ƒ
  replace hr0 := hr0.lt_of_ne hr0'.symm
  replace hr1 := hr1.lt_of_ne hr1'
  refine' âŸ¨div_neg_of_neg_of_pos (Left.neg_neg_iff.2 (sub_pos.2 hr1)) hr0, _âŸ©
  rw [â† hpâ‚‚, AffineMap.lineMap_apply, vsub_vadd_eq_vsub_sub, vsub_vadd_eq_vsub_sub, vsub_self,
    zero_sub, smul_neg, smul_smul, div_mul_cancel _ hr0', neg_smul, neg_neg, sub_eq_iff_eq_add, â†
    add_smul, sub_add_cancel, one_smul]","warning:  @angle does not have a doc string
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.115537 / ?m.115551 * ?m.115551
case intro.intro.intro.intro.intro
V : Type u_1
P : Type u_2
instâœÂ³ : NormedAddCommGroup V
instâœÂ² : InnerProductSpace â„ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
p pâ‚€ pâ‚âœ pâ‚‚âœ pâ‚ pâ‚‚ pâ‚ƒ : P
r : â„
hpâ‚‚ : (AffineMap.lineMap pâ‚ pâ‚ƒ) r = pâ‚‚
hpâ‚‚pâ‚ : pâ‚‚ â‰  pâ‚
hpâ‚‚pâ‚ƒ : pâ‚‚ â‰  pâ‚ƒ
hr0' : r â‰  0
hr1' : r â‰  1
hr0 : 0 < r
hr1 : r < 1
âŠ¢ pâ‚ƒ -áµ¥ pâ‚ - r â€¢ (pâ‚ƒ -áµ¥ pâ‚) = -((-(1 - r) / r * r) â€¢ (pâ‚ƒ -áµ¥ pâ‚))",theorem _root_.Sbtw.angleâ‚â‚‚â‚ƒ_eq_pi {pâ‚ pâ‚‚ pâ‚ƒ : P} (h : Sbtw â„ pâ‚ pâ‚‚ pâ‚ƒ) : âˆ  pâ‚ pâ‚‚ pâ‚ƒ = Ï€ ,":= by
  rw [angle, angle_eq_pi_iff]
  rcases h with âŸ¨âŸ¨r, âŸ¨hr0, hr1âŸ©, hpâ‚‚âŸ©, hpâ‚‚pâ‚, hpâ‚‚pâ‚ƒâŸ©
  refine âŸ¨vsub_ne_zero.2 hpâ‚‚pâ‚.symm, -(1 - r) / r, ?_âŸ©
  have hr0' : r â‰  0 := by
    rintro rfl
    rw [â† hpâ‚‚] at hpâ‚‚pâ‚
    simp at hpâ‚‚pâ‚
  have hr1' : r â‰  1 := by
    rintro rfl
    rw [â† hpâ‚‚] at hpâ‚‚pâ‚ƒ
    simp at hpâ‚‚pâ‚ƒ
  replace hr0 := hr0.lt_of_ne hr0'.symm
  replace hr1 := hr1.lt_of_ne hr1'
  refine âŸ¨div_neg_of_neg_of_pos (Left.neg_neg_iff.2 (sub_pos.2 hr1)) hr0, ?_âŸ©
  rw [â† hpâ‚‚, AffineMap.lineMap_apply, vsub_vadd_eq_vsub_sub, vsub_vadd_eq_vsub_sub, vsub_self,
    zero_sub, smul_neg, smul_smul, div_mul_cancelâ‚€ _ hr0', neg_smul, neg_neg, sub_eq_iff_eq_add, â†
    add_smul, sub_add_cancel, one_smul]",rw [angleâ‚â‚‚â‚‚â‚ƒ_eq_pi]
Mathlib/LinearAlgebra/AffineSpace/Independent.lean,exists_subset_affineIndependent_affineSpan_eq_top,exists_subset_affineIndependent_affineSpan_eq_top,1cb1056b5a19f416d3fae3469d51eedb4f5b48cb,":= by
  rcases s.eq_empty_or_nonempty with (rfl | âŸ¨pâ‚, hpâ‚âŸ©)
  Â· let pâ‚ : P := AddTorsor.nonempty.some
    let hsv := Basis.ofVectorSpace k V
    have hsvi := hsv.linearIndependent
    have hsvt := hsv.span_eq
    rw [Basis.coe_ofVectorSpace] at hsvi hsvt
    have h0 : âˆ€ v : V, v âˆˆ Basis.ofVectorSpaceIndex _ _ â†’ v â‰  0 := by
      intro v hv
      simpa [hsv] using hsv.ne_zero âŸ¨v, hvâŸ©
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 pâ‚] at hsvi
    exact
      âŸ¨{pâ‚} âˆª (fun v => v +áµ¥ pâ‚) '' _, Set.empty_subset _, hsvi,
        affineSpan_singleton_union_vadd_eq_top_of_span_eq_top pâ‚ hsvtâŸ©
  Â· rw [affineIndependent_set_iff_linearIndependent_vsub k hpâ‚] at h
    let bsv := Basis.extend h
    have hsvi := bsv.linearIndependent
    have hsvt := bsv.span_eq
    rw [Basis.coe_extend] at hsvi hsvt
    have hsv := h.subset_extend (Set.subset_univ _)
    have h0 : âˆ€ v : V, v âˆˆ h.extend _ â†’ v â‰  0 := by
      intro v hv
      simpa [bsv] using bsv.ne_zero âŸ¨v, hvâŸ©
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 pâ‚] at hsvi
    refine' âŸ¨{pâ‚} âˆª (fun v => v +áµ¥ pâ‚) '' h.extend (Set.subset_univ _), _, _âŸ©
    Â· refine' Set.Subset.trans _ (Set.union_subset_union_right _ (Set.image_subset _ hsv))
      simp [Set.image_image]
    Â· use hsvi
      exact affineSpan_singleton_union_vadd_eq_top_of_span_eq_top pâ‚ hsvt","error:  typeclass instance problem is stuck, it is often due to metavariables
  Module (?m.225307 v) V","theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s â†’ P)) :
    âˆƒ t : Set P, s âŠ† t âˆ§ AffineIndependent k (fun p => p : t â†’ P) âˆ§ affineSpan k t = âŠ¤ ",":= by
  rcases s.eq_empty_or_nonempty with (rfl | âŸ¨pâ‚, hpâ‚âŸ©)
  Â· have pâ‚ : P := AddTorsor.nonempty.some
    let hsv := Basis.ofVectorSpace k V
    have hsvi := hsv.linearIndependent
    have hsvt := hsv.span_eq
    rw [Basis.coe_ofVectorSpace] at hsvi hsvt
    have h0 : âˆ€ v : V, v âˆˆ Basis.ofVectorSpaceIndex k V â†’ v â‰  0 := by
      intro v hv
      simpa [hsv] using hsv.ne_zero âŸ¨v, hvâŸ©
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 pâ‚] at hsvi
    exact
      âŸ¨{pâ‚} âˆª (fun v => v +áµ¥ pâ‚) '' _, Set.empty_subset _, hsvi,
        affineSpan_singleton_union_vadd_eq_top_of_span_eq_top pâ‚ hsvtâŸ©
  Â· rw [affineIndependent_set_iff_linearIndependent_vsub k hpâ‚] at h
    let bsv := Basis.extend h
    have hsvi := bsv.linearIndependent
    have hsvt := bsv.span_eq
    rw [Basis.coe_extend] at hsvi hsvt
    have hsv := h.subset_extend (Set.subset_univ _)
    have h0 : âˆ€ v : V, v âˆˆ h.extend (Set.subset_univ _) â†’ v â‰  0 := by
      intro v hv
      simpa [bsv] using bsv.ne_zero âŸ¨v, hvâŸ©
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 pâ‚] at hsvi
    refine âŸ¨{pâ‚} âˆª (fun v => v +áµ¥ pâ‚) '' h.extend (Set.subset_univ _), ?_, ?_âŸ©
    Â· refine Set.Subset.trans ?_ (Set.union_subset_union_right _ (Set.image_subset _ hsv))
      simp [Set.image_image]
    Â· use hsvi
      exact affineSpan_singleton_union_vadd_eq_top_of_span_eq_top pâ‚ hsvt",rw [exists_subset_affineIndependent_affineSpan_eq_top]
Mathlib/Algebra/Order/Module/Defs.lean,inv_smul_le_iff_of_neg,inv_smul_le_iff_of_neg,299792d941f0a59647d1864dd577af60b4b0228f,":= by
  rw [â† smul_le_smul_iff_of_neg h, smul_inv_smulâ‚€ h.ne]","error:  unknown identifier 'smul_le_smul_iff_of_neg'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.432650
Î± : Type u_1
Î² : Type u_2
aâœ aâ‚ aâ‚‚ : Î±
b bâ‚âœ bâ‚‚âœ : Î²
instâœÂ³ : LinearOrderedField Î±
instâœÂ² : OrderedAddCommGroup Î²
instâœÂ¹ : Module Î± Î²
a : Î±
bâ‚ bâ‚‚ : Î²
instâœ : PosSMulMono Î± Î²
h : a < 0
âŠ¢ aâ»Â¹ â€¢ bâ‚ â‰¤ bâ‚‚ â†” a â€¢ bâ‚‚ â‰¤ bâ‚",lemma inv_smul_le_iff_of_neg (h : a < 0) : aâ»Â¹ â€¢ bâ‚ â‰¤ bâ‚‚ â†” a â€¢ bâ‚‚ â‰¤ bâ‚ ,":= by
  rw [â† smul_le_smul_iff_of_neg_left h, smul_inv_smulâ‚€ h.ne]","rw [â† smul_inv_smul_le_iff_of_neg h, smul_inv_smul_le_iff_of_neg h]"
Mathlib/Data/List/Zip.lean,List.get?_zip_with_eq_some,get?_zip_with_eq_some,561da585a69fbbdde80bd939bbe9557293b5250e,":= by
  induction lâ‚ generalizing lâ‚‚ i
  Â· simp [zipWith]
  Â· cases lâ‚‚ <;> simp only [zipWith, get?, exists_false, and_false_iff, false_and_iff]
    cases i <;> simp [*]","error:  unsolved goals
case cons.cons.succ
Î± : Type u
Î² : Type u_1
Î³ : Type u_2
Î´ : Type u_3
Îµ : Type u_4
f : Î± â†’ Î² â†’ Î³
z : Î³
headâœÂ¹ : Î±
tailâœÂ¹ : List Î±
tail_ihâœ :
  âˆ€ (lâ‚‚ : List Î²) (i : â„•),
    (zipWith f tailâœÂ¹ lâ‚‚).get? i = some z â†” âˆƒ x y, tailâœÂ¹.get? i = some x âˆ§ lâ‚‚.get? i = some y âˆ§ f x y = z
headâœ : Î²
tailâœ : List Î²
nâœ : â„•
âŠ¢ (zipWith f tailâœÂ¹ tailâœ)[nâœ]? = some z â†” âˆƒ x, tailâœÂ¹[nâœ]? = some x âˆ§ âˆƒ x_1, tailâœ[nâœ]? = some x_1 âˆ§ f x x_1 = z
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_zipWith` has been deprecated, use `List.getElem_zipWith` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_zipWith` has been deprecated, use `List.get_zipWith` instead","theorem get?_zip_with_eq_some (f : Î± â†’ Î² â†’ Î³) (lâ‚ : List Î±) (lâ‚‚ : List Î²) (z : Î³) (i : â„•) :
    (zipWith f lâ‚ lâ‚‚).get? i = some z â†”
      âˆƒ x y, lâ‚.get? i = some x âˆ§ lâ‚‚.get? i = some y âˆ§ f x y = z ",":= by
  simp [getElem?_zip_with_eq_some]","simp only [get?_eq_getElem?, theorem_zipWith_eq_some] at z"
Mathlib/Probability/Kernel/RadonNikodym.lean,ProbabilityTheory.kernel.measurableSet_mutuallySingularSet,measurableSet_mutuallySingularSet,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  measurable_rnDerivAux Îº (Îº + Î·) (measurableSet_singleton 1)","error:  application type mismatch
  measurable_rnDerivAux Îº (Îº + Î·) (measurableSet_singleton 1)
argument
  measurableSet_singleton 1
has type
  MeasurableSet {1} : Prop
but is expected to have type
  MeasurableSet (Real.le 1) : Prop","lemma measurableSet_mutuallySingularSet (Îº Î· : kernel Î± Î³) :
    MeasurableSet (mutuallySingularSet Îº Î·) ",":=
  measurable_rnDerivAux Îº (Îº + Î·) measurableSet_Ici",rw [mutuallySingularSet_mutuallySingularSet]
Mathlib/RingTheory/Nakayama.lean,Submodule.sup_eq_sup_smul_of_le_smul_of_le_jacobson,sup_eq_sup_smul_of_le_smul_of_le_jacobson,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have hNN' : N âŠ” N' = N âŠ” I â€¢ N' :=
    le_antisymm (sup_le le_sup_left hNN)
    (sup_le_sup_left (Submodule.smul_le.2 fun _ _ _ => Submodule.smul_mem _ _) _)
  have h_comap := Submodule.comap_injective_of_surjective (LinearMap.range_eq_top.1 N.range_mkQ)
  have : (I â€¢ N').map N.mkQ = N'.map N.mkQ := by
    rw [â† h_comap.eq_iff]
    simpa [comap_map_eq, sup_comm, eq_comm] using hNN'
  have :=
    @Submodule.eq_smul_of_le_smul_of_le_jacobson _ _ _ _ _ I J (N'.map N.mkQ) (hN'.map _)
      (by rw [â† map_smul'', this]) hIJ
  rwa [â† map_smul'', â† h_comap.eq_iff, comap_map_eq, comap_map_eq, Submodule.ker_mkQ, sup_comm,
    sup_comm (b := N)] at this","error:  type mismatch
  hâœ
has type
  N âŠ” N' = N âŠ” I â€¢ N' : Prop
but is expected to have type
  comap N.mkQ (I â€¢ map N.mkQ N') = N âŠ” N' : Prop","theorem sup_eq_sup_smul_of_le_smul_of_le_jacobson {I J : Ideal R} {N N' : Submodule R M}
    (hN' : N'.FG) (hIJ : I â‰¤ jacobson J) (hNN : N' â‰¤ N âŠ” I â€¢ N') : N âŠ” N' = N âŠ” J â€¢ N' ",":= by
  have hNN' : N âŠ” N' = N âŠ” I â€¢ N' :=
    le_antisymm (sup_le le_sup_left hNN)
    (sup_le_sup_left (Submodule.smul_le.2 fun _ _ _ => Submodule.smul_mem _ _) _)
  have h_comap := Submodule.comap_injective_of_surjective (LinearMap.range_eq_top.1 N.range_mkQ)
  have : (I â€¢ N').map N.mkQ = N'.map N.mkQ := by
    simpa only [â† h_comap.eq_iff, comap_map_mkQ, sup_comm, eq_comm] using hNN'
  have :=
    @Submodule.eq_smul_of_le_smul_of_le_jacobson _ _ _ _ _ I J (N'.map N.mkQ) (hN'.map _)
      (by rw [â† map_smul'', this]) hIJ
  rwa [â† map_smul'', â† h_comap.eq_iff, comap_map_eq, comap_map_eq, Submodule.ker_mkQ, sup_comm,
    sup_comm (b := N)] at this",apply le_antisymm
Mathlib/Probability/Distributions/Gaussian.lean,ProbabilityTheory.integrable_gaussianPDFReal,integrable_gaussianPDFReal,1c91c2706a3ccd891c3dcb859d92f31890fa3090,":= by
  rw [gaussianPDFReal_def]
  by_cases hv : v = 0
  Â· simp [hv]
  let g : â„ â†’ â„ := fun x â†¦ (Real.sqrt (2 * Ï€ * v))â»Â¹ * rexp (- x ^ 2 / (2 * v))
  have hg : Integrable g := by
    suffices g = fun x â†¦ (Real.sqrt (2 * Ï€ * v))â»Â¹ * rexp (- (2 * v)â»Â¹ * x ^ 2) by
      rw [this]
      refine (integrable_exp_neg_mul_sq ?_).const_mul (Real.sqrt (2 * Ï€ * v))â»Â¹
      simp [lt_of_le_of_ne (zero_le _) (Ne.symm hv)]
    ext x
    simp only [zero_lt_two, mul_nonneg_iff_of_pos_left, NNReal.zero_le_coe, Real.sqrt_mul',
      mul_inv_rev, NNReal.coe_mul, NNReal.coe_inv, NNReal.coe_ofNat, neg_mul, mul_eq_mul_left_iff,
      Real.exp_eq_exp, mul_eq_zero, inv_eq_zero, Real.sqrt_eq_zero, NNReal.coe_eq_zero, hv,
      false_or]
    rw [mul_comm]
    left
    field_simp
  exact Integrable.comp_sub_right hg Î¼","error:  tactic 'left' failed, left tactic works for inductive types with exactly 2 constructors
case h
Î¼ : â„
v : â„â‰¥0
hv : Â¬v = 0
g : â„ â†’ â„ := fun x â†¦ (âˆš(2 * Ï€ * â†‘v))â»Â¹ * rexp (-x ^ 2 / (2 * â†‘v))
x : â„
âŠ¢ g x = rexp (-((â†‘v)â»Â¹ * 2â»Â¹ * x ^ 2)) * ((âˆšâ†‘v)â»Â¹ * (âˆš(2 * Ï€))â»Â¹)","lemma integrable_gaussianPDFReal (Î¼ : â„) (v : â„â‰¥0) :
    Integrable (gaussianPDFReal Î¼ v) ",":= by
  rw [gaussianPDFReal_def]
  by_cases hv : v = 0
  Â· simp [hv]
  let g : â„ â†’ â„ := fun x â†¦ (âˆš(2 * Ï€ * v))â»Â¹ * rexp (- x ^ 2 / (2 * v))
  have hg : Integrable g := by
    suffices g = fun x â†¦ (âˆš(2 * Ï€ * v))â»Â¹ * rexp (- (2 * v)â»Â¹ * x ^ 2) by
      rw [this]
      refine (integrable_exp_neg_mul_sq ?_).const_mul (âˆš(2 * Ï€ * v))â»Â¹
      simp [lt_of_le_of_ne (zero_le _) (Ne.symm hv)]
    ext x
    simp only [g, zero_lt_two, mul_nonneg_iff_of_pos_left, NNReal.zero_le_coe, Real.sqrt_mul',
      mul_inv_rev, NNReal.coe_mul, NNReal.coe_inv, NNReal.coe_ofNat, neg_mul, mul_eq_mul_left_iff,
      Real.exp_eq_exp, mul_eq_zero, inv_eq_zero, Real.sqrt_eq_zero, NNReal.coe_eq_zero, hv,
      false_or]
    rw [mul_comm]
    left
    field_simp
  exact Integrable.comp_sub_right hg Î¼",rw [integrable_gaussianPDFReal_iff_integrable_gaussianPDFReal Î¼ v]
Mathlib/Topology/Bases.lean,Dense.exists_countable_dense_subset_bot_top,Dense.exists_countable_dense_subset_bot_top,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  rcases hs.exists_countable_dense_subset with âŸ¨t, hts, htc, htdâŸ©
  refine âŸ¨(t âˆª ({ x | IsBot x } âˆª { x | IsTop x })) âˆ© s, ?_, ?_?, ?_, _, ?_âŸ©
  exacts [inter_subset_right _ _,
    (htc.union ((countable_isBot Î±).union (countable_isTop Î±))).mono (inter_subset_left _ _),
    htd.mono (subset_inter (subset_union_left _ _) hts), fun x hx hxs => âŸ¨Or.inr <| Or.inl hx, hxsâŸ©,
    fun x hx hxs => âŸ¨Or.inr <| Or.inr hx, hxsâŸ©]","error:  don't know how to synthesize placeholder for argument 'left'
context:
Î± : Type u_1
instâœÂ² : TopologicalSpace Î±
instâœÂ¹ : PartialOrder Î±
s : Set Î±
instâœ : SeparableSpace â†‘s
hs : Dense s
t : Set Î±
hts : t âŠ† s
htc : t.Countable
htd : Dense t
âŠ¢ âˆ€ (x : Î±), IsBot x â†’ x âˆˆ s â†’ x âˆˆ (t âˆª ({x | IsBot x} âˆª {x | IsTop x})) âˆ© s
error:  unsolved goals
case intro.intro.intro
Î± : Type u_1
instâœÂ² : TopologicalSpace Î±
instâœÂ¹ : PartialOrder Î±
s : Set Î±
instâœ : SeparableSpace â†‘s
hs : Dense s
t : Set Î±
hts : t âŠ† s
htc : t.Countable
htd : Dense t
âŠ¢ âˆƒ t âŠ† s, t.Countable âˆ§ Dense t âˆ§ (âˆ€ (x : Î±), IsBot x â†’ x âˆˆ s â†’ x âˆˆ t) âˆ§ âˆ€ (x : Î±), IsTop x â†’ x âˆˆ s â†’ x âˆˆ t","theorem Dense.exists_countable_dense_subset_bot_top {Î± : Type*} [TopologicalSpace Î±]
    [PartialOrder Î±] {s : Set Î±} [SeparableSpace s] (hs : Dense s) :
    âˆƒ t âŠ† s, t.Countable âˆ§ Dense t âˆ§ (âˆ€ x, IsBot x â†’ x âˆˆ s â†’ x âˆˆ t) âˆ§
      âˆ€ x, IsTop x â†’ x âˆˆ s â†’ x âˆˆ t ",":= by
  rcases hs.exists_countable_dense_subset with âŸ¨t, hts, htc, htdâŸ©
  refine âŸ¨(t âˆª ({ x | IsBot x } âˆª { x | IsTop x })) âˆ© s, ?_, ?_, ?_, ?_, ?_âŸ©
  exacts [inter_subset_right,
    (htc.union ((countable_isBot Î±).union (countable_isTop Î±))).mono inter_subset_left,
    htd.mono (subset_inter subset_union_left hts), fun x hx hxs => âŸ¨Or.inr <| Or.inl hx, hxsâŸ©,
    fun x hx hxs => âŸ¨Or.inr <| Or.inr hx, hxsâŸ©]","rcases Dense.exists_countable_dense_subset_bot_top s with âŸ¨t, hts, htc, htdâŸ©"
Mathlib/Data/Set/Function.lean,Equiv.bijOn',bijOn',ac36b28ef3759cb65a7f386f3b7e15ee0ac1b4c9,:=,error:  unexpected token 'protected'; expected term,lemma bijOn' (hâ‚ : MapsTo e s t) (hâ‚‚ : MapsTo e.symm t s) : BijOn e s t ,":=
  âŸ¨hâ‚, e.injective.injOn, fun b hb â†¦ âŸ¨e.symm b, hâ‚‚ hb, apply_symm_apply _ _âŸ©âŸ©",simp onlemma bijOn' hâ‚ hâ‚‚
Mathlib/NumberTheory/Divisors.lean,Nat.mem_properDivisors_prime_pow,mem_properDivisors_prime_pow,d4ee09ebb44515260fada6fe81009f5ed4807a9d,":= by
  rw [mem_properDivisors, Nat.dvd_prime_pow pp, â† exists_and_right]
  simp only [exists_prop, and_assoc]
  apply exists_congr
  intro a
  constructor <;> intro h
  Â· rcases h with âŸ¨_h_left, rfl, h_rightâŸ©
    rw [pow_lt_pow_iff_right pp.one_lt] at h_right
    exact âŸ¨h_right, by rflâŸ©
  Â· rcases h with âŸ¨h_left, rflâŸ©
    rw [pow_lt_pow_iff_right pp.one_lt]
    simp [h_left, le_of_lt]","error:  unknown identifier 'pow_lt_pow_iff_right'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.48660
case h.mp.intro.intro
n p : â„•
pp : Prime p
k a : â„•
_h_left : a â‰¤ k
h_right : p ^ a < p ^ k
âŠ¢ a < k âˆ§ p ^ a = p ^ a
error:  unknown identifier 'pow_lt_pow_iff_right'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.48692
case h.mpr.intro
n p : â„•
pp : Prime p
k a : â„•
h_left : a < k
âŠ¢ a â‰¤ k âˆ§ p ^ a = p ^ a âˆ§ p ^ a < p ^ k","theorem mem_properDivisors_prime_pow {p : â„•} (pp : p.Prime) (k : â„•) {x : â„•} :
    x âˆˆ properDivisors (p ^ k) â†” âˆƒ (j : â„•) (_ : j < k), x = p ^ j ",":= by
  rw [mem_properDivisors, Nat.dvd_prime_pow pp, â† exists_and_right]
  simp only [exists_prop, and_assoc]
  apply exists_congr
  intro a
  constructor <;> intro h
  Â· rcases h with âŸ¨_h_left, rfl, h_rightâŸ©
    rw [Nat.pow_lt_pow_iff_right pp.one_lt] at h_right
    exact âŸ¨h_right, rflâŸ©
  Â· rcases h with âŸ¨h_left, rflâŸ©
    rw [Nat.pow_lt_pow_iff_right pp.one_lt]
    simp [h_left, le_of_lt]","simp only [mem_properDivisors_prime_pow, mem_properDivisors_prime_pow]"
Mathlib/Order/Extension/Well.lean,WellFounded.exists_well_order_ge,exists_well_order_ge,f2145c79419f71f289bb918aa4cca851527698f5,":=
  âŸ¨hwf.wellOrderExtension.lt, fun _ _ h => Prod.Lex.left _ _ (hwf.rank_lt_of_rel h),
    wellOrderExtension.isWellOrder_lt hwfâŸ©","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  wellOrderExtension
has type
  WellFounded ?m.653 â†’ LinearOrder ?m.652","theorem exists_well_order_ge : âˆƒ s, r â‰¤ s âˆ§ IsWellOrder Î± s ",":=
  âŸ¨hwf.wellOrderExtension.lt, fun _ _ h => Prod.Lex.left _ _ (hwf.rank_lt_of_rel h), âŸ¨âŸ©âŸ©","rcases exists_well_order_ge with âŸ¨s, rss, hs_well_order_geâŸ©"
Mathlib/Geometry/Manifold/Metrizable.lean,ManifoldWithCorners.metrizableSpace,ManifoldWithCorners.metrizableSpace,9e34a191034458a56331f976ff7400a26407c888,":= by
  haveI := I.locally_compact; haveI := ChartedSpace.locallyCompact H M
  haveI : NormalSpace M := normal_of_paracompact_t2
  haveI := I.secondCountableTopology
  haveI := ChartedSpace.secondCountable_of_sigma_compact H M
  exact metrizableSpace_of_t3_second_countable M","error:  invalid field 'locally_compact', the environment does not contain 'ModelWithCorners.locally_compact'
  I
has type
  ModelWithCorners â„ E H
error:  unsolved goals
E : Type u_1
instâœâ· : NormedAddCommGroup E
instâœâ¶ : NormedSpace â„ E
instâœâµ : FiniteDimensional â„ E
H : Type u_2
instâœâ´ : TopologicalSpace H
I : ModelWithCorners â„ E H
M : Type u_3
instâœÂ³ : TopologicalSpace M
instâœÂ² : ChartedSpace H M
instâœÂ¹ : SigmaCompactSpace M
instâœ : T2Space M
âŠ¢ MetrizableSpace M","theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]
    [FiniteDimensional â„ E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners â„ E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M ",":= by
  haveI := I.locallyCompactSpace; haveI := ChartedSpace.locallyCompactSpace H M
  haveI := I.secondCountableTopology
  haveI := ChartedSpace.secondCountable_of_sigma_compact H M
  exact metrizableSpace_of_t3_second_countable M",apply MetrizableSpace.metrizableSpace_metrizableSpace
Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean,IsPrimitiveRoot.minpoly_dvd_cyclotomic,_root_.IsPrimitiveRoot.minpoly_dvd_cyclotomic,4968eba95a704a4a58e8b3735dc3733ee6d46c0d,":= by
  apply minpoly.isIntegrallyClosed_dvd (h.isIntegral hpos)
  simpa [aeval_def, evalâ‚‚_eq_eval_map, IsRoot.definition] using h.isRoot_cyclotomic hpos","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsRoot
has type
  ?m.47446[X] â†’ ?m.47446 â†’ Prop","theorem _root_.IsPrimitiveRoot.minpoly_dvd_cyclotomic {n : â„•} {K : Type*} [Field K] {Î¼ : K}
    (h : IsPrimitiveRoot Î¼ n) (hpos : 0 < n) [CharZero K] : minpoly â„¤ Î¼ âˆ£ cyclotomic n â„¤ ",":= by
  apply minpoly.isIntegrallyClosed_dvd (h.isIntegral hpos)
  simpa [aeval_def, evalâ‚‚_eq_eval_map, IsRoot.def] using h.isRoot_cyclotomic hpos",have : minpoly â„¤ Î¼ âˆ£ cyclotomic n â„¤ := minpoly.dvd_cyclotomic n â„¤
Mathlib/Topology/GDelta.lean,isMeagre_iff_countable_union_isNowhereDense,isMeagre_iff_countable_union_isNowhereDense,4acf29cf15ba1326f189b61f7e886396ab6d97c8,":= by
  rw [IsMeagre, mem_residual_iff, compl_bijective.surjective.image_surjective.exists]
  simp_rw [â† and_assoc, â† forall_and, ball_image_iff, â† isClosed_isNowhereDense_iff_compl,
    sInter_image, â† compl_iUnionâ‚‚, compl_subset_compl, â† sUnion_eq_biUnion, and_assoc]
  refine âŸ¨fun âŸ¨S, hS, hc, hsubâŸ© â†¦ âŸ¨S, fun s hs â†¦ (hS s hs).2, ?_, hsubâŸ©, ?_âŸ©
  Â· rw [â† compl_compl_image S]; exact hc.image _
  Â· intro âŸ¨S, hS, hc, hsubâŸ©
    use closure '' S
    rw [ball_image_iff]
    exact âŸ¨fun s hs â†¦ âŸ¨isClosed_closure, (hS s hs).closureâŸ©,
      (hc.image _).image _, hsub.trans (sUnion_mono_subsets fun s â†¦ subset_closure)âŸ©","warning:  `Set.ball_image_iff` has been deprecated, use `Set.forall_mem_image` instead
error:  application type mismatch
  hS s
argument
  s
has type
  Set X : Type u_5
but is expected to have type
  ?m.22198 âˆˆ S : Prop
warning:  `Set.ball_image_iff` has been deprecated, use `Set.forall_mem_image` instead","lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s â†” âˆƒ S : Set (Set X), (âˆ€ t âˆˆ S, IsNowhereDense t) âˆ§ S.Countable âˆ§ s âŠ† â‹ƒâ‚€ S ",":= by
  rw [IsMeagre, mem_residual_iff, compl_bijective.surjective.image_surjective.exists]
  simp_rw [â† and_assoc, â† forall_and, forall_mem_image, â† isClosed_isNowhereDense_iff_compl,
    sInter_image, â† compl_iUnionâ‚‚, compl_subset_compl, â† sUnion_eq_biUnion, and_assoc]
  refine âŸ¨fun âŸ¨S, hS, hc, hsubâŸ© â†¦ âŸ¨S, fun s hs â†¦ (hS hs).2, ?_, hsubâŸ©, ?_âŸ©
  Â· rw [â† compl_compl_image S]; exact hc.image _
  Â· intro âŸ¨S, hS, hc, hsubâŸ©
    use closure '' S
    rw [forall_mem_image]
    exact âŸ¨fun s hs â†¦ âŸ¨isClosed_closure, (hS s hs).closureâŸ©,
      (hc.image _).image _, hsub.trans (sUnion_mono_subsets fun s â†¦ subset_closure)âŸ©",constructor
Mathlib/NumberTheory/Multiplicity.lean,multiplicity.Int.pow_sub_pow,Int.pow_sub_pow,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  cases' n with n
  Â· simp only [multiplicity.zero, add_top, pow_zero, sub_self, Nat.zero_eq]
  have h : (multiplicity _ _).Dom := finite_nat_iff.mpr âŸ¨hp.ne_one, n.succ_posâŸ©
  rcases eq_coe_iff.mp (PartENat.natCast_get h).symm with âŸ¨âŸ¨k, hkâŸ©, hpnâŸ©
  conv_lhs => rw [hk, pow_mul, pow_mul]
  rw [Nat.prime_iff_prime_int] at hp
  rw [pow_sub_pow_of_prime hp, pow_prime_pow_sub_pow_prime_pow hp hp1 hxy hx, PartENat.natCast_get]
  Â· rw [â† geom_sumâ‚‚_mul]
    exact dvd_mul_of_dvd_right hxy _
  Â· exact fun h => hx (hp.dvd_of_dvd_pow h)
  Â· rw [Int.natCast_dvd_natCast]
    rintro âŸ¨c, rflâŸ©
    refine hpn âŸ¨c, ?_âŸ©
    rwa [pow_succ, mul_assoc]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  n.succ
R : Type u_1
nâœ : â„•
instâœ : CommRing R
a b xâœ yâœ : R
p : â„•
hp : Nat.Prime p
hp1 : Odd p
x y : â„¤
hxy : â†‘p âˆ£ x - y
hx : Â¬â†‘p âˆ£ x
n : â„•
h : (multiplicity p n.succ).Dom
hpn : Â¬p ^ ((multiplicity p n.succ).get h + 1) âˆ£ n.succ
k : â„•
hk : n.succ = p ^ (multiplicity p n.succ).get h * k
| multiplicity (â†‘p) (x ^ (n + 1) - y ^ (n + 1))
error:  application type mismatch
  pow_sub_pow hp hp1
argument
  hp1
has type
  Odd p : Prop
but is expected to have type
  â†‘p âˆ£ ?m.114179 - ?m.114180 : Prop
error:  application type mismatch
  Int.pow_sub_pow hp hp1
argument
  hp1
has type
  Odd p : Prop
but is expected to have type
  â†‘p âˆ£ ?m.116975 - ?m.116976 : Prop
error:  application type mismatch
  Int.pow_add_pow hp
argument
  hp
has type
  Nat.Prime p : Prop
but is expected to have type
  â†‘?m.120154 âˆ£ ?m.120155 + ?m.120156 : Prop
error:  application type mismatch
  multiplicity.Nat.pow_sub_pow Fact.out
argument
  Fact.out
has type
  Nat.Prime p : Prop
but is expected to have type
  ?m.164434 âˆ£ ?m.164435 - ?m.164436 : Prop
error:  application type mismatch
  multiplicity.Nat.pow_add_pow Fact.out
argument
  Fact.out
has type
  Nat.Prime p : Prop
but is expected to have type
  ?m.166313 âˆ£ ?m.166314 + ?m.166315 : Prop","theorem Int.pow_sub_pow {x y : â„¤} (hxy : â†‘p âˆ£ x - y) (hx : Â¬â†‘p âˆ£ x) (n : â„•) :
    multiplicity (â†‘p) (x ^ n - y ^ n) = multiplicity (â†‘p) (x - y) + multiplicity p n ",":= by
  cases' n with n
  Â· simp only [multiplicity.zero, add_top, pow_zero, sub_self, Nat.zero_eq]
  have h : (multiplicity _ _).Dom := finite_nat_iff.mpr âŸ¨hp.ne_one, n.succ_posâŸ©
  simp only [Nat.succ_eq_add_one] at h
  rcases eq_coe_iff.mp (PartENat.natCast_get h).symm with âŸ¨âŸ¨k, hkâŸ©, hpnâŸ©
  conv_lhs => rw [hk, pow_mul, pow_mul]
  rw [Nat.prime_iff_prime_int] at hp
  rw [pow_sub_pow_of_prime hp, pow_prime_pow_sub_pow_prime_pow hp hp1 hxy hx, PartENat.natCast_get]
  Â· rw [â† geom_sumâ‚‚_mul]
    exact dvd_mul_of_dvd_right hxy _
  Â· exact fun h => hx (hp.dvd_of_dvd_pow h)
  Â· rw [Int.natCast_dvd_natCast]
    rintro âŸ¨c, rflâŸ©
    refine hpn âŸ¨c, ?_âŸ©
    rwa [pow_succ, mul_assoc]","rw [multiplicity.multiplicity_eq_multiplicity, multiplicity_eq_multiplicity_eq_multiplicity,
  multiplicity_eq_multiplicity_eq_multiplicity_eq_multiplicity]"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.map_append,map_append,938069ac7c83a4980c46ca108d9947ab788c12ee,":=
  Seq'.map_append _ _ _",error:  unknown identifier 'Seq'.map_append',theorem map_append (f : Î± â†’ Î²) (s t) : map f (append s t) = append (map f s) (map f t) ,":=
  Seq.map_append _ _ _","rw [map_append, append, map_map, map_append, map_append, map_append, map_append]"
Mathlib/Topology/Algebra/Module/Basic.lean,TopologicalSpace.IsSeparable.span,TopologicalSpace.IsSeparable.span,554c20d1eb6d2f1f6a5b53ccd3a727a93147a4de,":= by
  rw [span_eq_iUnion_nat]
  apply isSeparable_iUnion (fun n â†¦ ?_)
  apply IsSeparable.image
  Â· have : IsSeparable {f : Fin n â†’ R Ã— M | âˆ€ (i : Fin n), f i âˆˆ Set.univ Ã—Ë¢ s} := by
      apply isSeparable_pi (fun i â†¦ (isSeparable_of_separableSpace Set.univ).prod hs)
    convert this
    simp
  Â· apply continuous_finset_sum _ (fun i _ â†¦ ?_)
    exact (continuous_fst.comp (continuous_apply i)).smul (continuous_snd.comp (continuous_apply i))","error:  function expected at
  isSeparable_iUnion
term has type
  IsSeparable (â‹ƒ i, ?m.54492 i) â†” âˆ€ (i : ?m.54490), IsSeparable (?m.54492 i)
warning:  @ContinuousLinearMap does not have a doc string
warning:  @ContinuousLinearMap does not have a doc string
warning:  @ContinuousLinearMap does not have a doc string
warning:  @ContinuousLinearEquiv does not have a doc string
warning:  @ContinuousLinearEquiv does not have a doc string
warning:  @ContinuousLinearEquiv does not have a doc string
warning:  @ContinuousLinearEquiv does not have a doc string
warning:  ContinuousSemilinearEquivClass does not have a doc string
warning:  ContinuousSemilinearEquivClass does not have a doc string
warning:  @comp does not have a doc string","lemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]
    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]
    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :
    IsSeparable (Submodule.span R s : Set M) ",":= by
  rw [span_eq_iUnion_nat]
  refine .iUnion fun n â†¦ .image ?_ ?_
  Â· have : IsSeparable {f : Fin n â†’ R Ã— M | âˆ€ (i : Fin n), f i âˆˆ Set.univ Ã—Ë¢ s} := by
      apply isSeparable_pi (fun i â†¦ .prod (.of_separableSpace Set.univ) hs)
    rwa [Set.univ_prod] at this
  Â· apply continuous_finset_sum _ (fun i _ â†¦ ?_)
    exact (continuous_fst.comp (continuous_apply i)).smul (continuous_snd.comp (continuous_apply i))",have : IsSeparable (Submodule.span R s : Set M) := isSeparable_span_span_span
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,2d8928f07c222f171d2f9371935aa5b8359f9d44,":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine' Or.inl âŸ¨hs, _âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine' mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, _âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine'
        mem_shadow_iff.2
          âŸ¨(t âŠ” u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, _, _âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine' âŸ¨hus, hsv.symm, âŸ¨x, _, _âŸ©, _âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right _ _, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) _
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  function expected at
  subset_union_right ?m.92173
term has type
  ?m.92172 âˆˆ ?m.92170 âˆª ?m.92171
error:  function expected at
  subset_union_left ?m.92639
term has type
  ?m.92638 âˆˆ ?m.92636 âˆª ?m.92637
error:  function expected at
  subset_union_right ?m.94506
term has type
  ?m.94505 âˆˆ ?m.94503 âˆª ?m.94504
error:  function expected at
  subset_union_left ?m.97300
term has type
  ?m.97299 âˆˆ ?m.97297 âˆª ?m.97298
error:  function expected at
  subset_union_left ?m.98875
term has type
  ?m.98874 âˆˆ ?m.98872 âˆª ?m.98873","theorem shadow_compression_subset_compression_shadow (u v : Finset Î±)
    (huv : âˆ€ x âˆˆ u, âˆƒ y âˆˆ v, IsCompressed (u.erase x) (v.erase y) ğ’œ) :
    âˆ‚ (ğ“’ u v ğ’œ) âŠ† ğ“’ u v (âˆ‚ ğ’œ) ",":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine Or.inl âŸ¨hs, ?_âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, ?_âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine mem_shadow_iff.2
        âŸ¨(t âŠ” u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine âŸ¨hus, hsv.symm, âŸ¨x, ?_, ?_âŸ©, ?_âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) ?_
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]",refine theorem_shadow_compression_subset_compression_subset_compression_subset_compression_subset_compression_shadow huv
Mathlib/Algebra/Associated.lean,prime_pow_iff,prime_pow_iff,3bb2cb9fea0fbb1bf6bf2e7773ba73b51952e9e5,":= by
  refine âŸ¨fun hp â†¦ ?_, fun âŸ¨hp, hnâŸ© â†¦ by simpa [hn]âŸ©
  suffices n = 1 by aesop
  cases' n with n
  Â· simp at hp
  Â· rw [Nat.succ.injEq]
    rw [pow_succ, prime_mul_iff] at hp
    rcases hp with âŸ¨hp, hpnâŸ© | âŸ¨hp, hpnâŸ©
    Â· by_contra contra
      rw [isUnit_pow_iff contra] at hpn
      exact hp.not_unit hpn
    Â· exfalso
      exact hpn.not_unit (hp.pow n)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  IsUnit (?m.93582 ^ n)
case succ.inl.intro
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Î´ : Type u_4
instâœ : CancelCommMonoidWithZero Î±
p : Î±
n : â„•
hp : Prime (p ^ n)
hpn : IsUnit p
contra : Â¬n = 0
âŠ¢ False
error:  application type mismatch
  Prime.not_unit hpn (IsUnit.pow n hp)
argument
  IsUnit.pow n hp
has type
  IsUnit ((p ^ n) ^ n) : Prop
but is expected to have type
  IsUnit p : Prop","lemma prime_pow_iff [CancelCommMonoidWithZero Î±] {p : Î±} {n : â„•} :
    Prime (p ^ n) â†” Prime p âˆ§ n = 1 ",":= by
  refine âŸ¨fun hp â†¦ ?_, fun âŸ¨hp, hnâŸ© â†¦ by simpa [hn]âŸ©
  suffices n = 1 by aesop
  cases' n with n
  Â· simp at hp
  Â· rw [Nat.succ.injEq]
    rw [pow_succ', prime_mul_iff] at hp
    rcases hp with âŸ¨hp, hpnâŸ© | âŸ¨hp, hpnâŸ©
    Â· by_contra contra
      rw [isUnit_pow_iff contra] at hpn
      exact hp.not_unit hpn
    Â· exfalso
      exact hpn.not_unit (hp.pow n)",constructor
Mathlib/Combinatorics/HalesJewett.lean,Combinatorics.Line.exists_mono_in_high_dimension,exists_mono_in_high_dimension,a36d8932e98ea1d7efcdd316318586a6329f53a3,":=
  Finite.induction_empty_option
  (
  fun {Î± Î±'} e =>
    forall_imp fun Îº =>
      forall_imp fun _ =>
        Exists.imp fun Î¹ =>
          Exists.imp fun _ h C =>
            let âŸ¨l, c, lcâŸ© := h fun v => C (e âˆ˜ v)
            âŸ¨l.map e, c, e.forall_congr_left.mp fun x => by rw [â† lc x, Line.map_apply]âŸ©)
  (by
    intro Îº _
    by_cases h : Nonempty Îº
    Â· refine' âŸ¨Unit, inferInstance, fun C => âŸ¨default, Classical.arbitrary _, PEmpty.recâŸ©âŸ©
    Â· exact âŸ¨Empty, inferInstance, fun C => (h âŸ¨C (Empty.rec)âŸ©).elimâŸ©)
  (by
    intro Î± _ ihÎ± Îº _
    cases nonempty_fintype Îº
    by_cases h : Nonempty Î±
    case neg =>
      refine âŸ¨Unit, inferInstance, fun C => âŸ¨diagonal _ Unit, C fun _ => none, ?_âŸ©âŸ©
      rintro (_ | âŸ¨aâŸ©)
      Â· rfl
      Â· exact (h âŸ¨aâŸ©).elim
    suffices key :
      âˆ€ r : â„•,
        âˆƒ (Î¹ : Type) (_ : Fintype Î¹),
          âˆ€ C : (Î¹ â†’ Option Î±) â†’ Îº,
            (âˆƒ s : ColorFocused C, Multiset.card s.lines = r) âˆ¨ âˆƒ l, IsMono C l by
      obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := key (Fintype.card Îº + 1)
      refine' âŸ¨Î¹, _inst, fun C => (hÎ¹ C).resolve_left _âŸ©
      rintro âŸ¨s, srâŸ©
      apply Nat.not_succ_le_self (Fintype.card Îº)
      rw [â† Nat.add_one, â† sr, â† Multiset.card_map, â† Finset.card_mk]
      exact Finset.card_le_univ âŸ¨_, s.distinct_colorsâŸ©
    intro r
    induction' r with r ihr
    Â· exact âŸ¨Empty, inferInstance, fun C => Or.inl âŸ¨default, Multiset.card_zeroâŸ©âŸ©
    obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := ihr
    specialize ihÎ± ((Î¹ â†’ Option Î±) â†’ Îº)
    obtain âŸ¨Î¹', _inst, hÎ¹'âŸ© := ihÎ±
    refine âŸ¨Sum Î¹ Î¹', inferInstance, ?_âŸ©
    intro C
    specialize hÎ¹' fun v' v => C (Sum.elim v (some âˆ˜ v'))
    obtain âŸ¨l', C', hl'âŸ© := hÎ¹'
    have mono_of_mono : (âˆƒ l, IsMono C' l) â†’ âˆƒ l, IsMono C l := by
      rintro âŸ¨l, c, hlâŸ©
      refine âŸ¨l.horizontal (some âˆ˜ l' (Classical.arbitrary Î±)), c, fun x => ?_âŸ©
      rw [Line.horizontal_apply, â† hl, â† hl']
    specialize hÎ¹ C'
    rcases hÎ¹ with (âŸ¨s, srâŸ© | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : âˆƒ p âˆˆ s.lines, (p : AlmostMono _).color = C' s.focus
    Â· obtain âŸ¨p, p_mem, hpâŸ© := h
      refine' Or.inr (mono_of_mono âŸ¨p.line, p.color, _âŸ©)
      rintro (_ | _)
      Â· rw [hp, s.is_focused p p_mem]
      Â· apply p.has_color
    refine' Or.inl âŸ¨âŸ¨(s.lines.map _).cons âŸ¨(l'.map some).vertical s.focus, C' s.focus, fun x => _âŸ©,
            Sum.elim s.focus (l'.map some none), _, _âŸ©, _âŸ©
    Â· refine' fun p => âŸ¨p.line.prod (l'.map some), p.color, fun x => _âŸ©
      rw [Line.prod_apply, Line.map_apply, â† p.has_color, â† congr_fun (hl' x)]
    Â· rw [vertical_apply, â† congr_fun (hl' x), Line.map_apply]
    Â· simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | âŸ¨q, hq, rflâŸ©)
      Â· simp only [vertical_apply]
      Â· simp only [prod_apply, s.is_focused q hq]
    Â· rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact âŸ¨fun âŸ¨q, hq, heâŸ© => h âŸ¨q, hq, heâŸ©, s.distinct_colorsâŸ©
    Â· rw [Multiset.card_cons, Multiset.card_map, sr])","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  c
Î± Î±' : Type u
e : Î± â‰ƒ Î±'
Îº : Type (max v u)
xâœÂ¹ : Finite Îº
Î¹ : Type
xâœ : Fintype Î¹
h : âˆ€ (C : (Î¹ â†’ Î±) â†’ Îº), âˆƒ l, IsMono C l
C : (Î¹ â†’ Î±') â†’ Îº
l : Line Î± Î¹
c : Îº
lc : âˆ€ (x : Î±), (fun v â†¦ C (â‡‘e âˆ˜ v)) ((fun x i â†¦ (l.idxFun i).getD x) x) = c
x : Î±
âŠ¢ ?m.6437 x
error:  application type mismatch
  Exists.intro c ((Equiv.forall_congr_left e).mp fun x â†¦ ?m.6452 x)
argument
  (Equiv.forall_congr_left e).mp fun x â†¦ ?m.6452 x
has type
  âˆ€ (b : Î±'), ?m.6437 (e.symm b) : Prop
but is expected to have type
  âˆ€ (x : Î±'), C ((fun x i â†¦ ((map (â‡‘e) l).idxFun i).getD x) x) = c : Prop","theorem exists_mono_in_high_dimension' :
    âˆ€ (Î± : Type u) [Finite Î±] (Îº : Type max v u) [Finite Îº],
      âˆƒ (Î¹ : Type) (_ : Fintype Î¹), âˆ€ C : (Î¹ â†’ Î±) â†’ Îº, âˆƒ l : Line Î± Î¹, l.IsMono C ",":=
  Finite.induction_empty_option
  (
  fun {Î± Î±'} e =>
    forall_imp fun Îº =>
      forall_imp fun _ =>
        Exists.imp fun Î¹ =>
          Exists.imp fun _ h C =>
            let âŸ¨l, c, lcâŸ© := h fun v => C (e âˆ˜ v)
            âŸ¨l.map e, c, e.forall_congr_right.mp fun x => by rw [â† lc x, Line.map_apply]âŸ©)
  (by
    intro Îº _
    by_cases h : Nonempty Îº
    Â· refine âŸ¨Unit, inferInstance, fun C => âŸ¨default, Classical.arbitrary _, PEmpty.recâŸ©âŸ©
    Â· exact âŸ¨Empty, inferInstance, fun C => (h âŸ¨C (Empty.rec)âŸ©).elimâŸ©)
  (by
    intro Î± _ ihÎ± Îº _
    cases nonempty_fintype Îº
    by_cases h : Nonempty Î±
    case neg =>
      refine âŸ¨Unit, inferInstance, fun C => âŸ¨diagonal _ Unit, C fun _ => none, ?_âŸ©âŸ©
      rintro (_ | âŸ¨aâŸ©)
      Â· rfl
      Â· exact (h âŸ¨aâŸ©).elim
    suffices key :
      âˆ€ r : â„•,
        âˆƒ (Î¹ : Type) (_ : Fintype Î¹),
          âˆ€ C : (Î¹ â†’ Option Î±) â†’ Îº,
            (âˆƒ s : ColorFocused C, Multiset.card s.lines = r) âˆ¨ âˆƒ l, IsMono C l by
      obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := key (Fintype.card Îº + 1)
      refine âŸ¨Î¹, _inst, fun C => (hÎ¹ C).resolve_left ?_âŸ©
      rintro âŸ¨s, srâŸ©
      apply Nat.not_succ_le_self (Fintype.card Îº)
      rw [â† Nat.add_one, â† sr, â† Multiset.card_map, â† Finset.card_mk]
      exact Finset.card_le_univ âŸ¨_, s.distinct_colorsâŸ©
    intro r
    induction' r with r ihr
    Â· exact âŸ¨Empty, inferInstance, fun C => Or.inl âŸ¨default, Multiset.card_zeroâŸ©âŸ©
    obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := ihr
    specialize ihÎ± ((Î¹ â†’ Option Î±) â†’ Îº)
    obtain âŸ¨Î¹', _inst, hÎ¹'âŸ© := ihÎ±
    refine âŸ¨Sum Î¹ Î¹', inferInstance, ?_âŸ©
    intro C
    specialize hÎ¹' fun v' v => C (Sum.elim v (some âˆ˜ v'))
    obtain âŸ¨l', C', hl'âŸ© := hÎ¹'
    have mono_of_mono : (âˆƒ l, IsMono C' l) â†’ âˆƒ l, IsMono C l := by
      rintro âŸ¨l, c, hlâŸ©
      refine âŸ¨l.horizontal (some âˆ˜ l' (Classical.arbitrary Î±)), c, fun x => ?_âŸ©
      rw [Line.horizontal_apply, â† hl, â† hl']
    specialize hÎ¹ C'
    rcases hÎ¹ with (âŸ¨s, srâŸ© | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : âˆƒ p âˆˆ s.lines, (p : AlmostMono _).color = C' s.focus
    Â· obtain âŸ¨p, p_mem, hpâŸ© := h
      refine Or.inr (mono_of_mono âŸ¨p.line, p.color, ?_âŸ©)
      rintro (_ | _)
      Â· rw [hp, s.is_focused p p_mem]
      Â· apply p.has_color
    refine Or.inl âŸ¨âŸ¨(s.lines.map ?_).cons âŸ¨(l'.map some).vertical s.focus, C' s.focus, fun x => ?_âŸ©,
            Sum.elim s.focus (l'.map some none), ?_, ?_âŸ©, ?_âŸ©
    Â· refine fun p => âŸ¨p.line.prod (l'.map some), p.color, fun x => ?_âŸ©
      rw [Line.prod_apply, Line.map_apply, â† p.has_color, â† congr_fun (hl' x)]
    Â· rw [vertical_apply, â† congr_fun (hl' x), Line.map_apply]
    Â· simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | âŸ¨q, hq, rflâŸ©)
      Â· simp only [vertical_apply]
      Â· simp only [prod_apply, s.is_focused q hq]
    Â· rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact âŸ¨fun âŸ¨q, hq, heâŸ© => h âŸ¨q, hq, heâŸ©, s.distinct_colorsâŸ©
    Â· rw [Multiset.card_cons, Multiset.card_map, sr])",cases' exists_mono_in_high_dimension' with Î± hÎ±
Mathlib/Geometry/Manifold/VectorBundle/Basic.lean,Bundle.contMDiffWithinAt_totalSpace,contMDiffWithinAt_totalSpace,2c616cf6d72eab2cc0cb8be21b40be572f4b56bf,":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, â† FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp_def,
    LocalEquiv.trans_apply, LocalEquiv.prod_coe, LocalEquiv.refl_coe, extChartAt_self_apply,
    modelWithCornersSelf_coe, id_def]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) â»Â¹' (trivializationAt F E (f xâ‚€).proj).baseSet âˆˆ ğ“[s] xâ‚€ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  Â· simp_rw [Function.comp, LocalHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  Â· simp only [mfld_simps]","error:  unknown identifier 'LocalEquiv.trans_apply'
error:  simp made no progress","theorem contMDiffWithinAt_totalSpace (f : M â†’ TotalSpace F E) {s : Set M} {xâ‚€ : M} :
    ContMDiffWithinAt IM (IB.prod ğ“˜(ğ•œ, F)) n f s xâ‚€ â†”
      ContMDiffWithinAt IM IB n (fun x => (f x).proj) s xâ‚€ âˆ§
      ContMDiffWithinAt IM ğ“˜(ğ•œ, F) n (fun x â†¦ (trivializationAt F E (f xâ‚€).proj (f x)).2) s xâ‚€ ",":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, â† FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe,
    extChartAt_self_apply, modelWithCornersSelf_coe, Function.id_def, â† chartedSpaceSelf_prod]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) â»Â¹' (trivializationAt F E (f xâ‚€).proj).baseSet âˆˆ ğ“[s] xâ‚€ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  Â· simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  Â· simp only [mfld_simps]","rw [contMDiffWithinAt_theorem, contMDiffWithinAt_theorem]"
Mathlib/Analysis/LocallyConvex/WithSeminorms.lean,SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf,SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf,277dea952df34759a39b00abcc615238ae32c506,":= by
  rw [p.withSeminorms_iff_nhds_eq_iInf,
    UniformAddGroup.ext_iff inferInstance (uniformAddGroup_iInf fun i => inferInstance),
    toTopologicalSpace_iInf, nhds_iInf]
  refine Eq.to_iff ?_
  congr
  funext i
  exact @comap_norm_nhds_zero _ (p i).toAddGroupSeminorm.toSeminormedAddGroup","error:  unknown identifier 'toTopologicalSpace_iInf'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.229718
ğ•œ : Type u_1
ğ•œâ‚‚ : Type u_2
ğ• : Type u_3
ğ•â‚‚ : Type u_4
E : Type u_5
F : Type u_6
G : Type u_7
Î¹ : Type u_8
Î¹' : Type u_9
instâœâ´ : NormedField ğ•œ
instâœÂ³ : AddCommGroup E
instâœÂ² : Module ğ•œ E
instâœÂ¹ : Nonempty Î¹
u : UniformSpace E
instâœ : UniformAddGroup E
p : SeminormFamily ğ•œ E Î¹
âŠ¢ ğ“ 0 = â¨… i, comap (â‡‘(p i)) (ğ“ 0) â†” ğ“ 0 = ğ“ 0","theorem SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf [u : UniformSpace E]
    [UniformAddGroup E] (p : SeminormFamily ğ•œ E Î¹) :
    WithSeminorms p â†” u = â¨… i, (p i).toSeminormedAddCommGroup.toUniformSpace ",":= by
  rw [p.withSeminorms_iff_nhds_eq_iInf,
    UniformAddGroup.ext_iff inferInstance (uniformAddGroup_iInf fun i => inferInstance),
    UniformSpace.toTopologicalSpace_iInf, nhds_iInf]
  congrm _ = â¨… i, ?_
  exact @comap_norm_nhds_zero _ (p i).toAddGroupSeminorm.toSeminormedAddGroup",constructor
Mathlib/NumberTheory/Modular.lean,ModularGroup.smul_eq_lcRow0_add,smul_eq_lcRow0_add,2aa3afc6b7f6110e2c9da6202a3b71cc7501f244,":= by
  have nonZ1 : (p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2 â‰  0 := by exact_mod_cast hp.sq_add_sq_ne_zero
  have : ((â†‘) : â„¤ â†’ â„) âˆ˜ p â‰  0 := fun h => hp.ne_zero (by ext i; simpa using congr_fun h i)
  have nonZ2 : (p 0 : â„‚) * z + p 1 â‰  0 := by simpa using linear_ne_zero _ z this
  field_simp [nonZ1, nonZ2, denom_ne_zero, num]
  rw [(by simp :
    (p 1 : â„‚) * z - p 0 = (p 1 * z - p 0) * â†‘(Matrix.det (â†‘g : Matrix (Fin 2) (Fin 2) â„¤)))]
  rw [â† hg, det_fin_two]
  simp only [Int.coe_castRingHom, coe_matrix_coe, Int.cast_mul, ofReal_int_cast, map_apply, denom,
    Int.cast_sub, coe_GLPos_coe_GL_coe_matrix]
  ring","error:  unknown identifier 'ofReal_int_cast'
info:  Try this: ring_nf
error:  unsolved goals
g : SL(2, â„¤)
z : â„
p : Fin 2 â†’ â„¤
hp : IsCoprime (p 0) (p 1)
hg : â†‘g 1 = p
nonZ1 : â†‘(p 0) ^ 2 + â†‘(p 1) ^ 2 â‰  0
this : Int.cast âˆ˜ p â‰  0
nonZ2 : â†‘(p 0) * â†‘z + â†‘(p 1) â‰  0
âŠ¢ â†‘(â†‘g 0 0) * â†‘z * â†‘(â†‘g 1 0) ^ 2 * â†‘(â†‘g 1 1) ^ 3 * 2 + â†‘(â†‘g 0 0) * â†‘z * â†‘(â†‘g 1 0) ^ 4 * â†‘(â†‘g 1 1) +
                        â†‘(â†‘g 0 0) * â†‘z * â†‘(â†‘g 1 1) ^ 5 +
                      â†‘(â†‘g 0 0) * â†‘z ^ 2 * â†‘(â†‘g 1 0) * â†‘(â†‘g 1 1) ^ 4 +
                    â†‘(â†‘g 0 0) * â†‘z ^ 2 * â†‘(â†‘g 1 0) ^ 3 * â†‘(â†‘g 1 1) ^ 2 * 2 +
                  â†‘(â†‘g 0 0) * â†‘z ^ 2 * â†‘(â†‘g 1 0) ^ 5 +
                â†‘z * â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) * â†‘(â†‘g 1 1) ^ 4 +
              â†‘z * â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 3 * â†‘(â†‘g 1 1) ^ 2 * 2 +
            â†‘z * â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 5 +
          â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 2 * â†‘(â†‘g 1 1) ^ 3 * 2 +
        â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 4 * â†‘(â†‘g 1 1) +
      â†‘(â†‘g 0 1) * â†‘(â†‘g 1 1) ^ 5 =
    â†‘(â†‘g 0 0) * â†‘z * â†‘(â†‘g 1 0) ^ 2 * â†‘(â†‘g 1 1) ^ 2 * â†‘(â†‘â†‘â†‘g 1 1) * 2 + â†‘(â†‘g 0 0) * â†‘z * â†‘(â†‘g 1 0) ^ 4 * â†‘(â†‘â†‘â†‘g 1 1) +
                        â†‘(â†‘g 0 0) * â†‘z * â†‘(â†‘g 1 1) ^ 4 * â†‘(â†‘â†‘â†‘g 1 1) +
                      â†‘(â†‘g 0 0) * â†‘z ^ 2 * â†‘(â†‘g 1 0) ^ 2 * â†‘(â†‘g 1 1) ^ 2 * â†‘(â†‘â†‘â†‘g 1 0) * 2 +
                    â†‘(â†‘g 0 0) * â†‘z ^ 2 * â†‘(â†‘g 1 0) ^ 4 * â†‘(â†‘â†‘â†‘g 1 0) +
                  â†‘(â†‘g 0 0) * â†‘z ^ 2 * â†‘(â†‘g 1 1) ^ 4 * â†‘(â†‘â†‘â†‘g 1 0) +
                â†‘z * â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 2 * â†‘(â†‘g 1 1) ^ 2 * â†‘(â†‘â†‘â†‘g 1 0) * 2 +
              â†‘z * â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 4 * â†‘(â†‘â†‘â†‘g 1 0) +
            â†‘z * â†‘(â†‘g 0 1) * â†‘(â†‘g 1 1) ^ 4 * â†‘(â†‘â†‘â†‘g 1 0) +
          â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 2 * â†‘(â†‘g 1 1) ^ 2 * â†‘(â†‘â†‘â†‘g 1 1) * 2 +
        â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 4 * â†‘(â†‘â†‘â†‘g 1 1) +
      â†‘(â†‘g 0 1) * â†‘(â†‘g 1 1) ^ 4 * â†‘(â†‘â†‘â†‘g 1 1)
warning:  fd does not have a doc string
warning:  fdo does not have a doc string","theorem smul_eq_lcRow0_add {p : Fin 2 â†’ â„¤} (hp : IsCoprime (p 0) (p 1)) (hg : (â†‘â‚˜g) 1 = p) :
    â†‘(g â€¢ z) =
      (lcRow0 p â†‘(g : SL(2, â„)) : â„‚) / ((p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2) +
        ((p 1 : â„‚) * z - p 0) / (((p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2) * (p 0 * z + p 1)) ",":= by
  have nonZ1 : (p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2 â‰  0 := mod_cast hp.sq_add_sq_ne_zero
  have : ((â†‘) : â„¤ â†’ â„) âˆ˜ p â‰  0 := fun h => hp.ne_zero (by ext i; simpa using congr_fun h i)
  have nonZ2 : (p 0 : â„‚) * z + p 1 â‰  0 := by simpa using linear_ne_zero _ z this
  field_simp [nonZ1, nonZ2, denom_ne_zero, num]
  rw [(by simp :
    (p 1 : â„‚) * z - p 0 = (p 1 * z - p 0) * â†‘(Matrix.det (â†‘g : Matrix (Fin 2) (Fin 2) â„¤)))]
  rw [â† hg, det_fin_two]
  simp only [Int.coe_castRingHom, coe_matrix_coe, Int.cast_mul, ofReal_intCast, map_apply, denom,
    Int.cast_sub, coe_GLPos_coe_GL_coe_matrix, coe'_apply_complex]
  ring","simp_rw [smul_eq_lcRow0_add, smul_eq_lcRow0_add, smul_eq_lcRow0_add]"
Mathlib/NumberTheory/Pell.lean,Pell.Solutionâ‚.eq_zero_of_d_neg,eq_zero_of_d_neg,a71231735e55fa1fc4000a42658641f766fde88b,":= by
  have h := a.prop
  contrapose! h
  have h1 := sq_pos_of_ne_zero a.x h.1
  have h2 := sq_pos_of_ne_zero a.y h.2
  nlinarith","error:  application type mismatch
  sq_pos_of_ne_zero a.x
argument
  a.x
has type
  â„¤ : Type
but is expected to have type
  ?m.11112 â‰  0 : Prop
error:  unsolved goals
d : â„¤
hâ‚€ : d < 0
a : Solutionâ‚ d
h : a.x â‰  0 âˆ§ a.y â‰  0
âŠ¢ a.x ^ 2 - d * a.y ^ 2 â‰  1",theorem eq_zero_of_d_neg (hâ‚€ : d < 0) (a : Solutionâ‚ d) : a.x = 0 âˆ¨ a.y = 0 ,":= by
  have h := a.prop
  contrapose! h
  have h1 := sq_pos_of_ne_zero h.1
  have h2 := sq_pos_of_ne_zero h.2
  nlinarith",simp only [eq_zero_of_d_neg]
Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean,TopCat.isTopologicalBasis_cofiltered_limit,isTopologicalBasis_cofiltered_limit,66c0098b0b62ad14d9c618b402e7673658137a7e,":= by
  classical
  let D := limitConeInfi F
  let E : C.pt â‰… D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | âˆƒ (j : _) (V : Set (F.obj j)), V âˆˆ T j âˆ§ U = D.Ï€.app j â»Â¹' V} by
    convert this.inducing hE
    ext U0
    constructor
    Â· rintro âŸ¨j, V, hV, rflâŸ©
      exact âŸ¨D.Ï€.app j â»Â¹' V, âŸ¨j, V, hV, rflâŸ©, rflâŸ©
    Â· rintro âŸ¨W, âŸ¨j, V, hV, rflâŸ©, rflâŸ©
      exact âŸ¨j, V, hV, rflâŸ©
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.Ï€.app j x using 1
  ext U0
  constructor
  Â· rintro âŸ¨j, V, hV, rflâŸ©
    let U : âˆ€ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine' âŸ¨U, {j}, _, _âŸ©
    Â· simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    Â· simp [U]
  Â· rintro âŸ¨U, G, h1, h2âŸ©
    obtain âŸ¨j, hjâŸ© := IsCofiltered.inf_objs_exists G
    let g : âˆ€ e âˆˆ G, j âŸ¶ e := fun _ he => (hj he).some
    let Vs : J â†’ Set (F.obj j) := fun e => if h : e âˆˆ G then F.map (g e h) â»Â¹' U e else Set.univ
    let V : Set (F.obj j) := â‹‚ (e : J) (_he : e âˆˆ G), Vs e
    refine' âŸ¨j, V, _, _âŸ©
    Â· 
      have :
        âˆ€ (S : Set (Set (F.obj j))) (E : Finset J) (P : J â†’ Set (F.obj j)) (_univ : Set.univ âˆˆ S)
          (_inter : âˆ€ A B : Set (F.obj j), A âˆˆ S â†’ B âˆˆ S â†’ A âˆ© B âˆˆ S)
          (_cond : âˆ€ (e : J) (_he : e âˆˆ E), P e âˆˆ S), (â‹‚ (e) (_he : e âˆˆ E), P e) âˆˆ S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine' hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 _)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine' this _ _ _ (univ _) (inter _) _
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    Â· 
      rw [h2]
      change _ = (D.Ï€.app j)â»Â¹' â‹‚ (e : J) (_ : e âˆˆ G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.Ï€.app e)â»Â¹' U e =
        (D.Ï€.app j) â»Â¹' if h : e âˆˆ G then F.map (g e h) â»Â¹' U e else Set.univ
      rw [dif_pos he, â† Set.preimage_comp]
      apply congrFun
      apply congrArg
      rw [â† coe_comp, D.w]
      rfl","error:  unknown identifier 'isTopologicalBasis_iInf'
error:  no goals to be solved","theorem isTopologicalBasis_cofiltered_limit (T : âˆ€ j, Set (Set (F.obj j)))
    (hT : âˆ€ j, IsTopologicalBasis (T j)) (univ : âˆ€ i : J, Set.univ âˆˆ T i)
    (inter : âˆ€ (i) (U1 U2 : Set (F.obj i)), U1 âˆˆ T i â†’ U2 âˆˆ T i â†’ U1 âˆ© U2 âˆˆ T i)
    (compat : âˆ€ (i j : J) (f : i âŸ¶ j) (V : Set (F.obj j)) (_hV : V âˆˆ T j), F.map f â»Â¹' V âˆˆ T i) :
    IsTopologicalBasis
      {U : Set C.pt | âˆƒ (j : _) (V : Set (F.obj j)), V âˆˆ T j âˆ§ U = C.Ï€.app j â»Â¹' V} ",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt â‰… D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | âˆƒ (j : _) (V : Set (F.obj j)), V âˆˆ T j âˆ§ U = D.Ï€.app j â»Â¹' V} by
    convert this.inducing hE
    ext U0
    constructor
    Â· rintro âŸ¨j, V, hV, rflâŸ©
      exact âŸ¨D.Ï€.app j â»Â¹' V, âŸ¨j, V, hV, rflâŸ©, rflâŸ©
    Â· rintro âŸ¨W, âŸ¨j, V, hV, rflâŸ©, rflâŸ©
      exact âŸ¨j, V, hV, rflâŸ©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.Ï€.app j x using 1
  ext U0
  constructor
  Â· rintro âŸ¨j, V, hV, rflâŸ©
    let U : âˆ€ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine âŸ¨U, {j}, ?_, ?_âŸ©
    Â· simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    Â· simp [U]
  Â· rintro âŸ¨U, G, h1, h2âŸ©
    obtain âŸ¨j, hjâŸ© := IsCofiltered.inf_objs_exists G
    let g : âˆ€ e âˆˆ G, j âŸ¶ e := fun _ he => (hj he).some
    let Vs : J â†’ Set (F.obj j) := fun e => if h : e âˆˆ G then F.map (g e h) â»Â¹' U e else Set.univ
    let V : Set (F.obj j) := â‹‚ (e : J) (_he : e âˆˆ G), Vs e
    refine âŸ¨j, V, ?_, ?_âŸ©
    Â· 
      have :
        âˆ€ (S : Set (Set (F.obj j))) (E : Finset J) (P : J â†’ Set (F.obj j)) (_univ : Set.univ âˆˆ S)
          (_inter : âˆ€ A B : Set (F.obj j), A âˆˆ S â†’ B âˆˆ S â†’ A âˆ© B âˆˆ S)
          (_cond : âˆ€ (e : J) (_he : e âˆˆ E), P e âˆˆ S), (â‹‚ (e) (_he : e âˆˆ E), P e) âˆˆ S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    Â· 
      rw [h2]
      change _ = (D.Ï€.app j)â»Â¹' â‹‚ (e : J) (_ : e âˆˆ G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.Ï€.app e)â»Â¹' U e =
        (D.Ï€.app j) â»Â¹' if h : e âˆˆ G then F.map (g e h) â»Â¹' U e else Set.univ
      rw [dif_pos he, â† Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [â† coe_comp, D.w] 
      rfl",refine theorem_isTopologicalBasis_isTopologicalBasis_cofiltered_limit _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ?_
Mathlib/Data/List/NodupEquivFin.lean,List.duplicate_iff_exists_distinct_get,duplicate_iff_exists_distinct_get,3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  classical
    rw [duplicate_iff_two_le_count, le_count_iff_replicate_sublist,
      sublist_iff_exists_fin_orderEmbedding_get_eq]
    constructor
    Â· rintro âŸ¨f, hfâŸ©
      refine' âŸ¨f âŸ¨0, by simpâŸ©, f âŸ¨1, by simpâŸ©,
        f.lt_iff_lt.2 (show (0 : â„•) < 1 from zero_lt_one), _âŸ©
      Â· rw [â† hf, â† hf]; simp
    Â· rintro âŸ¨n, m, hnm, h, h'âŸ©
      refine âŸ¨OrderEmbedding.ofStrictMono (fun i => if (i : â„•) = 0 then n else m) ?_, ?_âŸ©
      Â· rintro âŸ¨âŸ¨_ | iâŸ©, hiâŸ© âŸ¨âŸ¨_ | jâŸ©, hjâŸ©
        Â· simp
        Â· simp [hnm]
        Â· simp
        Â· simp only [Nat.lt_succ_iff, Nat.succ_le_succ_iff, replicate, length,
            nonpos_iff_eq_zero] at hi hj
          simp [hi, hj]
      Â· rintro âŸ¨âŸ¨_ | iâŸ©, hiâŸ©
        Â· simpa using h
        Â· simpa using h'","error:  unknown identifier 'zero_lt_one'
error:  unknown identifier 'nonpos_iff_eq_zero'
error:  unsolved goals
case mpr.intro.intro.intro.intro.refine_1.mk.succ.mk.succ
Î± : Type u_1
l : List Î±
x : Î±
n m : Fin l.length
hnm : n < m
h : x = l.get n
h' : x = l.get m
nâœÂ¹ : â„•
hiâœ : nâœÂ¹ + 1 < (replicate 2 x).length
nâœ : â„•
hjâœ : nâœ + 1 < (replicate 2 x).length
hi : nâœÂ¹ â‰¤ 0
hj : nâœ â‰¤ 0
âŠ¢ nâœ â‰¤ nâœÂ¹
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem duplicate_iff_exists_distinct_get {l : List Î±} {x : Î±} :
    l.Duplicate x â†”
      âˆƒ (n m : Fin l.length) (_ : n < m),
        x = l.get n âˆ§ x = l.get m ",":= by
  classical
    rw [duplicate_iff_two_le_count, le_count_iff_replicate_sublist,
      sublist_iff_exists_fin_orderEmbedding_get_eq]
    constructor
    Â· rintro âŸ¨f, hfâŸ©
      refine âŸ¨f âŸ¨0, by simpâŸ©, f âŸ¨1, by simpâŸ©, f.lt_iff_lt.2 (Nat.zero_lt_one), ?_âŸ©
      rw [â† hf, â† hf]; simp
    Â· rintro âŸ¨n, m, hnm, h, h'âŸ©
      refine âŸ¨OrderEmbedding.ofStrictMono (fun i => if (i : â„•) = 0 then n else m) ?_, ?_âŸ©
      Â· rintro âŸ¨âŸ¨_ | iâŸ©, hiâŸ© âŸ¨âŸ¨_ | jâŸ©, hjâŸ©
        Â· simp
        Â· simp [hnm]
        Â· simp
        Â· simp only [Nat.lt_succ_iff, Nat.succ_le_succ_iff, replicate, length, Nat.le_zero] at hi hj
          simp [hi, hj]
      Â· rintro âŸ¨âŸ¨_ | iâŸ©, hiâŸ©
        Â· simpa using h
        Â· simpa using h'",constructor
Mathlib/Analysis/InnerProductSpace/Basic.lean,InnerProductSpace.Core.normSq_eq_zero,normSq_eq_zero,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":=
  Iff.trans
    (by simp only [normSq, ext_iff, map_zero, inner_self_im, eq_self_iff_true, and_true_iff])
    (@inner_self_eq_zero ğ•œ _ _ _ _ _ _ x)","error:  function expected at
  inner_self_eq_zero
term has type
  âŸª?m.64621, ?m.64621âŸ«_ğ•œ = 0 â†” ?m.64621 = 0
error:  unsolved goals
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœÂ² : _root_.RCLike ğ•œ
instâœÂ¹ : AddCommGroup F
instâœ : Module ğ•œ F
c : Core ğ•œ F
x : F
âŠ¢ re âŸªx, xâŸ«_ğ•œ = 0 â†” ?m.64609",theorem normSq_eq_zero {x : F} : normSqF x = 0 â†” x = 0 ,":=
  Iff.trans
    (by simp only [normSq, ext_iff, map_zero, inner_self_im, eq_self_iff_true, and_true_iff])
    (@inner_self_eq_zero ğ•œ _ _ _ _ _ x)","rw [normSqF_eq_zero_iff, normSqF_eq_zero_iff, normSqF_eq_zero_iff]"
Mathlib/RingTheory/AdicCompletion/Functoriality.lean,AdicCompletion.sumInv_comp_sum,sumInv_comp_sum,477166fbcab40069a4fbe62e393a3d09efdb938f,":= by
  ext j x
  apply DirectSum.ext R (fun i â†¦ ?_)
  ext n
  simp only [LinearMap.coe_comp, Function.comp_apply, sum_lof, LinearMap.adicCompletion_mk,
    component_sumInv, mk_apply_coe, LinearMap.adicCauchy_apply_coe, Submodule.mkQ_apply,
    LinearMap.id_comp]
  rw [DirectSum.component.of, DirectSum.component.of]
  split
  Â· next h => subst h; simp
  Â· simp","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.348217 â†’+* ?m.348218) â†’
    (M : Type ?u.348214) â†’
      (Mâ‚‚ : Type ?u.348213) â†’
        [inst : AddCommMonoid M] â†’
          [inst_1 : AddCommMonoid Mâ‚‚] â†’
            [inst : Module ?m.348217 M] â†’ [inst : Module ?m.348218 Mâ‚‚] â†’ Type (max ?u.348214 ?u.348213)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.348447 â†’+* ?m.348448) â†’
    (M : Type ?u.348444) â†’
      (Mâ‚‚ : Type ?u.348443) â†’
        [inst : AddCommMonoid M] â†’
          [inst_1 : AddCommMonoid Mâ‚‚] â†’
            [inst : Module ?m.348447 M] â†’ [inst : Module ?m.348448 Mâ‚‚] â†’ Type (max ?u.348444 ?u.348443)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (component ?R ?Î¹ ?M ?i) ((lof ?R ?Î¹ ?M ?j) ?b)
case h
R : Type u_1
instâœÂ¹Â² : CommRing R
I : Ideal R
Mâœ : Type u_2
instâœÂ¹Â¹ : AddCommGroup Mâœ
instâœÂ¹â° : Module R Mâœ
N : Type u_3
instâœâ¹ : AddCommGroup N
instâœâ¸ : Module R N
P : Type u_4
instâœâ· : AddCommGroup P
instâœâ¶ : Module R P
T : Type u_5
instâœâµ : AddCommGroup T
instâœâ´ : Module (AdicCompletion I R) T
Î¹ : Type u_6
instâœÂ³ : DecidableEq Î¹
M : Î¹ â†’ Type u_7
instâœÂ² : (i : Î¹) â†’ AddCommGroup (M i)
instâœÂ¹ : (i : Î¹) â†’ Module R (M i)
instâœ : Fintype Î¹
j : Î¹
x : AdicCauchySequence I (M j)
i : Î¹
n : â„•
âŠ¢ â†‘((component R Î¹ (fun i â†¦ AdicCompletion I (M i)) i) ((sumInv I M) ((map I (lof R Î¹ M j)) ((mk I (M j)) x)))) n =
    â†‘((component R Î¹ (fun i â†¦ AdicCompletion I (M i)) i)
          ((lof (AdicCompletion I R) Î¹ (fun i â†¦ AdicCompletion I (M i)) j) ((mk I (M j)) x)))
      n",theorem sumInv_comp_sum : sumInv I M âˆ˜â‚— sum I M = LinearMap.id ,":= by
  ext j x
  apply DirectSum.ext (AdicCompletion I R) (fun i â†¦ ?_)
  ext n
  simp only [LinearMap.coe_comp, Function.comp_apply, sum_lof, map_mk, component_sumInv,
    mk_apply_coe, AdicCauchySequence.map_apply_coe, Submodule.mkQ_apply, LinearMap.id_comp]
  rw [DirectSum.component.of, DirectSum.component.of]
  split
  Â· next h => subst h; simp
  Â· simp","rw [â† sumInv_comp_sum, sumInv_comp_sum]"
Mathlib/MeasureTheory/Integral/FundThmCalculus.lean,intervalIntegral.sub_le_integral_of_hasDeriv_right_of_le,sub_le_integral_of_hasDeriv_right_of_le,9d12b609274b44fc79ae79f9347cf8a3782b6a95,":= by
  refine' le_of_forall_pos_le_add fun Îµ Îµpos => _
  rcases exists_lt_lowerSemicontinuous_integral_lt Ï† Ï†int Îµpos with
    âŸ¨G', f_lt_G', G'cont, G'int, G'lt_top, hG'âŸ©
  set s := {t | g t - g a â‰¤ âˆ« u in a..t, (G' u).toReal} âˆ© Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, âˆ« u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [â† uIcc_of_le hab] at G'int hcont âŠ¢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [s, inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b âŠ† {t | g t - g a â‰¤ âˆ« u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain âŸ¨y, g'_lt_y', y_lt_G'âŸ© : âˆƒ y : â„, (g' t : EReal) < y âˆ§ (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hÏ†g t ht.2)).trans_lt (f_lt_G' t))
    have I1 : âˆ€á¶  u in ğ“[>] t, (u - t) * y â‰¤ âˆ« w in t..u, (G' w).toReal := by
      have B : âˆ€á¶  u in ğ“ t, (y : EReal) < G' u := G'cont.eventually_lt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with âŸ¨m, M, âŸ¨hm, hMâŸ©, HâŸ©
      have : Ioo t (min M b) âˆˆ ğ“[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u âŠ† Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = âˆ« _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ â‰¤ âˆ« w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, â† integral_Icc_eq_integral_Ioc]
          apply set_integral_mono_ae_restrict
          Â· simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          Â· exact IntegrableOn.mono_set G'int I
          Â· have C1 : âˆ€áµ x : â„ âˆ‚volume.restrict (Icc t u), G' x < âˆ :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : âˆ€áµ x : â„ âˆ‚volume.restrict (Icc t u), x âˆˆ Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x âˆˆ Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : âˆ€á¶  u in ğ“[>] t, g u - g t â‰¤ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t âŸ¨ht.2.1, ht.2.2âŸ©).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [â† smul_eq_mul, sub_smul_slope] at this
    have I3 : âˆ€á¶  u in ğ“[>] t, g u - g t â‰¤ âˆ« w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : âˆ€á¶  u in ğ“[>] t, u âˆˆ Ioc t (min v b) := by
      refine' mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 âŸ¨min v b, _, Subset.rflâŸ©
      simp only [lt_min_iff, mem_Ioi]
      exact âŸ¨t_lt_v, ht.2.2âŸ©
    rcases (I3.and I4).exists with âŸ¨x, hx, h'xâŸ©
    refine' âŸ¨x, _, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'xâŸ©
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ â‰¤ (âˆ« w in a..t, (G' w).toReal) + âˆ« w in t..x, (G' w).toReal := (add_le_add ht.1 hx)
      _ = âˆ« w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        Â· rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        Â· rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a â‰¤ âˆ« y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ â‰¤ (âˆ« y in a..b, Ï† y) + Îµ := by
      convert hG'.le <;>
        Â· rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]","error:  invalid field 'eventually_lt', the environment does not contain 'LowerSemicontinuous.eventually_lt'
  G'cont
has type
  LowerSemicontinuous G'
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  G'cont
has type
  âˆ€ (x : â„), LowerSemicontinuousAt G' x
warning:  `MeasureTheory.set_integral_mono_ae_restrict` has been deprecated, use `MeasureTheory.setIntegral_mono_ae_restrict` instead","theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a â‰¤ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : âˆ€ x âˆˆ Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (Ï†int : IntegrableOn Ï† (Icc a b)) (hÏ†g : âˆ€ x âˆˆ Ico a b, g' x â‰¤ Ï† x) :
    g b - g a â‰¤ âˆ« y in a..b, Ï† y ",":= by
  refine le_of_forall_pos_le_add fun Îµ Îµpos => ?_
  rcases exists_lt_lowerSemicontinuous_integral_lt Ï† Ï†int Îµpos with
    âŸ¨G', f_lt_G', G'cont, G'int, G'lt_top, hG'âŸ©
  set s := {t | g t - g a â‰¤ âˆ« u in a..t, (G' u).toReal} âˆ© Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, âˆ« u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [â† uIcc_of_le hab] at G'int hcont âŠ¢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [s, inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b âŠ† {t | g t - g a â‰¤ âˆ« u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain âŸ¨y, g'_lt_y', y_lt_G'âŸ© : âˆƒ y : â„, (g' t : EReal) < y âˆ§ (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hÏ†g t ht.2)).trans_lt (f_lt_G' t))
    have I1 : âˆ€á¶  u in ğ“[>] t, (u - t) * y â‰¤ âˆ« w in t..u, (G' w).toReal := by
      have B : âˆ€á¶  u in ğ“ t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with âŸ¨m, M, âŸ¨hm, hMâŸ©, HâŸ©
      have : Ioo t (min M b) âˆˆ ğ“[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u âŠ† Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = âˆ« _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ â‰¤ âˆ« w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, â† integral_Icc_eq_integral_Ioc]
          apply setIntegral_mono_ae_restrict
          Â· simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          Â· exact IntegrableOn.mono_set G'int I
          Â· have C1 : âˆ€áµ x : â„ âˆ‚volume.restrict (Icc t u), G' x < âˆ :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : âˆ€áµ x : â„ âˆ‚volume.restrict (Icc t u), x âˆˆ Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x âˆˆ Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : âˆ€á¶  u in ğ“[>] t, g u - g t â‰¤ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t âŸ¨ht.2.1, ht.2.2âŸ©).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [â† smul_eq_mul, sub_smul_slope] at this
    have I3 : âˆ€á¶  u in ğ“[>] t, g u - g t â‰¤ âˆ« w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : âˆ€á¶  u in ğ“[>] t, u âˆˆ Ioc t (min v b) := by
      refine mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 âŸ¨min v b, ?_, Subset.rflâŸ©
      simp only [lt_min_iff, mem_Ioi]
      exact âŸ¨t_lt_v, ht.2.2âŸ©
    rcases (I3.and I4).exists with âŸ¨x, hx, h'xâŸ©
    refine âŸ¨x, ?_, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'xâŸ©
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ â‰¤ (âˆ« w in a..t, (G' w).toReal) + âˆ« w in t..x, (G' w).toReal := add_le_add ht.1 hx
      _ = âˆ« w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        Â· rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        Â· rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a â‰¤ âˆ« y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ â‰¤ (âˆ« y in a..b, Ï† y) + Îµ := by
      convert hG'.le <;>
        Â· rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]","have : âˆ€ x âˆˆ Ico a b, HasDerivWithinAt Ï† (Icc a b) Ï†int Ï†int Ï†int Ï†int Ï†int Ï†int Ï†int Ï†int Ï†int Ï†int"
Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean,Real.volume_preserving_transvectionStruct,volume_preserving_transvectionStruct,8fd52fff08d5334a76b5303b5f5b92c58426a674,":= by
  have ht : Measurable (toLin' t.toMatrix) :=
    (toLin' t.toMatrix).continuous_of_finiteDimensional.measurable
  refine âŸ¨ht, ?_âŸ©
  refine (pi_eq fun s hs â†¦ ?_).symm
  have h2s : MeasurableSet (univ.pi s) := .pi countable_univ fun i _ â†¦ hs i
  simp_rw [â† pi_pi, â† lintegral_indicator_one h2s]
  rw [lintegral_map (measurable_one.indicator h2s) ht, volume_pi]
  refine integral_eq_of_marginal_eq {t.i} ((measurable_one.indicator h2s).comp ht)
    (measurable_one.indicator h2s) ?_
  ext x
  induction' x using Quotient.inductionOn with x
  simp_rw [marginal_singleton_apply]
  cases t with | mk t_i t_j t_hij t_c =>
  simp [transvection, mulVec_stdBasisMatrix]
  simp_rw [Function.update_noteq t_hij.symm, â† Function.update_add, add_zero]
  rw [lintegral_add_right_eq_self fun xáµ¢ â†¦ indicator (univ.pi s) 1 (Function.update x t_i xáµ¢)]","error:  unknown identifier 'integral_eq_of_marginal_eq'
error:  no goals to be solved","theorem volume_preserving_transvectionStruct [DecidableEq Î¹] (t : TransvectionStruct Î¹ â„) :
    MeasurePreserving (toLin' t.toMatrix) ",":= by
  have ht : Measurable (toLin' t.toMatrix) :=
    (toLin' t.toMatrix).continuous_of_finiteDimensional.measurable
  refine âŸ¨ht, ?_âŸ©
  refine (pi_eq fun s hs â†¦ ?_).symm
  have h2s : MeasurableSet (univ.pi s) := .pi countable_univ fun i _ â†¦ hs i
  simp_rw [â† pi_pi, â† lintegral_indicator_one h2s]
  rw [lintegral_map (measurable_one.indicator h2s) ht, volume_pi]
  refine lintegral_eq_of_lmarginal_eq {t.i} ((measurable_one.indicator h2s).comp ht)
    (measurable_one.indicator h2s) ?_
  simp_rw [lmarginal_singleton]
  ext x
  cases t with | mk t_i t_j t_hij t_c =>
  simp [transvection, mulVec_stdBasisMatrix, t_hij.symm, â† Function.update_add,
    lintegral_add_right_eq_self fun xáµ¢ â†¦ indicator (univ.pi s) 1 (Function.update x t_i xáµ¢)]","refine MeasurePreserving.transvectionStruct volume_preserving_transvection_transvection_transvection
  volume_preserving_transvection_transvection_transvection volume_preserving_transvection
  volume_preserving_transvection_transvection_transvection volume_preserving_transvection
  volume_preserving_transvection_transvection_transvection volume_preserving_transvection
  volume_preserving_transvection_transvection_transvection volume_preserving_transvection
  volume_preserving_transvection_transvection_transvection volume_preserving_transvection
  volume_preserving_transvection_transvection_transvection volume_preserving_transvection
  volume_preserving_transvection_transvection_transvection volume_preserving_transvection t"
Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean,integrable_one_add_norm,integrable_one_add_norm,54daa04dd4fe92d1b3b2a82be4c246b43c601cab,":= by
  constructor
  Â· apply Measurable.aestronglyMeasurable (by fun_prop)
  have : (âˆ«â» a : E, â€–(1 + â€–aâ€–) ^ (-r)â€–â‚Š âˆ‚Î¼) = âˆ«â» a : E, ENNReal.ofReal ((1 + â€–aâ€–) ^ (-r)) âˆ‚Î¼ :=
    lintegral_nnnorm_eq_of_nonneg fun _ => rpow_nonneg (by positivity) _
  rw [HasFiniteIntegral, this]
  exact finite_integral_one_add_norm hnr","error:  `fun_prop` was unable to prove `Measurable fun x â†¦ (1 + â€–xâ€–) ^ (-r)`

Try running with discharger `fun_prop (disch:=aesop)` or with a different discharger tactic like `assumption`, `linarith`, `omega`.
Sometimes it is useful to run `fun_prop (disch:=trace_state; sorry)` which will print all the necessary subgoals for `fun_prop` to succeed.

Potential issues to fix:
  No theorems found for `HPow.hPow` in order to prove Measurable fun x â†¦ (1 + â€–xâ€–) ^ (-r)
  No theorems found for `HPow.hPow` in order to prove Measurable fun a â†¦ a ^ (-r)
  Failed to synthesize instance NontriviallyNormedField ?ğ•œ when applying theorem DifferentiableOn.continuousOn.
  No theorems found for `HPow.hPow` in order to prove IsProperMap fun a â†¦ a ^ (-r)
  Failed to synthesize instance NontriviallyNormedField ?ğ•œ when applying theorem Differentiable.continuous.
  Failed to synthesize instance DiscreteTopology â„ when applying theorem continuous_of_discreteTopology.
  Failed to prove necessary assumption 0 â‰¤ -r when applying theorem Real.continuous_rpow_const.
  No theorems found for `HPow.hPow` in order to prove IsProperMap fun a â†¦ a ^ (-r)
  Failed to synthesize instance NontriviallyNormedField ?ğ•œ when applying theorem Differentiable.continuous.
  Failed to synthesize instance DiscreteTopology â„ when applying theorem continuous_of_discreteTopology.
  Failed to prove necessary assumption 0 â‰¤ -r when applying theorem Real.continuous_rpow_const.

For more detailed information use `set_option trace.Meta.Tactic.fun_prop true`","theorem integrable_one_add_norm {r : â„} (hnr : (finrank â„ E : â„) < r) :
    Integrable (fun x â†¦ (1 + â€–xâ€–) ^ (-r)) Î¼ ",":= by
  constructor
  Â· measurability
  have : (âˆ«â» a : E, â€–(1 + â€–aâ€–) ^ (-r)â€–â‚Š âˆ‚Î¼) = âˆ«â» a : E, ENNReal.ofReal ((1 + â€–aâ€–) ^ (-r)) âˆ‚Î¼ :=
    lintegral_nnnorm_eq_of_nonneg fun _ => rpow_nonneg (by positivity) _
  rw [HasFiniteIntegral, this]
  exact finite_integral_one_add_norm hnr","have : Integrable (fun x â†¦ (1 + â€–xâ€–) ^ (-r)) Î¼ := by
  apply Integrable.integrable_of_integrable_of_integrable_norm_le integrable_const hnr"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.integral_cpow_mul_exp_neg_mul_Ioi,integral_cpow_mul_exp_neg_mul_Ioi,84f6d10f9a51f8c6472ec85f7cb1f39056781a29,":= by
  have aux : (1 / r : â„‚) ^ a = 1 / r * (1 / r) ^ (a - 1) := by
    nth_rewrite 2 [â† cpow_one (1 / r : â„‚)]
    rw [â† cpow_add _ _ (one_div_ne_zero <| ofReal_ne_zero.mpr hr.ne'), add_sub_cancel'_right]
  calc
    _ = âˆ« (t : â„) in Ioi 0, (1 / r) ^ (a - 1) * (r * t) ^ (a - 1) * exp (-(r * t)) := by
      refine MeasureTheory.set_integral_congr measurableSet_Ioi (fun x hx â†¦ ?_)
      rw [mem_Ioi] at hx
      rw [mul_cpow_ofReal_nonneg hr.le hx.le, â† mul_assoc, one_div, â† ofReal_inv,
        â† mul_cpow_ofReal_nonneg (inv_pos.mpr hr).le hr.le, â† ofReal_mul râ»Â¹, inv_mul_cancel hr.ne',
        ofReal_one, one_cpow, one_mul]
    _ = |1 / r| * âˆ« (t : â„) in Ioi (r * 0), (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      simp_rw [â† ofReal_mul]
      rw [integral_comp_mul_left_Ioi (fun x â†¦ _ * x ^ (a - 1) * exp (-x)) _ hr, mul_zero,
        real_smul, â† one_div]
    _ = 1 / r * âˆ« (t : â„) in Ioi 0, (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      rw [congr_arg Ioi (mul_zero r), _root_.abs_of_nonneg (one_div_pos.mpr hr).le, ofReal_div,
        ofReal_one]
    _ = 1 / r * (1 / r : â„‚) ^ (a - 1) * (âˆ« (t : â„) in Ioi 0, t ^ (a - 1) * exp (-t)) := by
      simp_rw [â† integral_mul_left, mul_assoc]
    _ = (1 / r) ^ a * Gamma a := by
      rw [aux, Gamma_eq_integral ha]
      congr 2 with x
      rw [ofReal_exp, ofReal_neg, mul_comm]","warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
error:  unsolved goals
a : â„‚
r : â„
ha : 0 < a.re
hr : 0 < r
aux : (1 / â†‘r) ^ a = 1 / â†‘r * (1 / â†‘r) ^ (a - 1)
âŠ¢ â†‘(1 / r) * âˆ« (x : â„) in Ioi 0, (1 / â†‘r) ^ (a - 1) * â†‘x ^ (a - 1) * cexp (-â†‘x) =
    â†‘|1 / r| * âˆ« (t : â„) in Ioi 0, (1 / â†‘r) ^ (a - 1) * â†‘t ^ (a - 1) * cexp (-â†‘t)","lemma integral_cpow_mul_exp_neg_mul_Ioi {a : â„‚} {r : â„} (ha : 0 < a.re) (hr : 0 < r) :
    âˆ« (t : â„) in Ioi 0, t ^ (a - 1) * exp (-(r * t)) = (1 / r) ^ a * Gamma a ",":= by
  have aux : (1 / r : â„‚) ^ a = 1 / r * (1 / r) ^ (a - 1) := by
    nth_rewrite 2 [â† cpow_one (1 / r : â„‚)]
    rw [â† cpow_add _ _ (one_div_ne_zero <| ofReal_ne_zero.mpr hr.ne'), add_sub_cancel]
  calc
    _ = âˆ« (t : â„) in Ioi 0, (1 / r) ^ (a - 1) * (r * t) ^ (a - 1) * exp (-(r * t)) := by
      refine MeasureTheory.setIntegral_congr measurableSet_Ioi (fun x hx â†¦ ?_)
      rw [mem_Ioi] at hx
      rw [mul_cpow_ofReal_nonneg hr.le hx.le, â† mul_assoc, one_div, â† ofReal_inv,
        â† mul_cpow_ofReal_nonneg (inv_pos.mpr hr).le hr.le, â† ofReal_mul râ»Â¹, inv_mul_cancel hr.ne',
        ofReal_one, one_cpow, one_mul]
    _ = 1 / r * âˆ« (t : â„) in Ioi 0, (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      simp_rw [â† ofReal_mul]
      rw [integral_comp_mul_left_Ioi (fun x â†¦ _ * x ^ (a - 1) * exp (-x)) _ hr, mul_zero,
        real_smul, â† one_div, ofReal_div, ofReal_one]
    _ = 1 / r * (1 / r : â„‚) ^ (a - 1) * (âˆ« (t : â„) in Ioi 0, t ^ (a - 1) * exp (-t)) := by
      simp_rw [â† integral_mul_left, mul_assoc]
    _ = (1 / r) ^ a * Gamma a := by
      rw [aux, Gamma_eq_integral ha]
      congr 2 with x
      rw [ofReal_exp, ofReal_neg, mul_comm]",simp_rw [integral_cpow_mul_exp_neg_mul_Ioi]
Mathlib/GroupTheory/Transfer.lean,MonoidHom.transfer_eq_pow_aux,transfer_eq_pow_aux,951e9e356bae97e849c7fcb6a4a2d7b981507062,":= by
  by_cases hH : H.index = 0
  Â· rw [hH, pow_zero]
    exact H.one_mem
  letI := fintypeOfIndexNeZero hH
  classical
    replace key : âˆ€ (k : â„•) (gâ‚€ : G), gâ‚€â»Â¹ * g ^ k * gâ‚€ âˆˆ H â†’ g ^ k âˆˆ H := fun k gâ‚€ hk =>
      (_root_.congr_arg (Â· âˆˆ H) (key k gâ‚€ hk)).mp hk
    replace key : âˆ€ q : G â§¸ H, g ^ period g q âˆˆ H := fun q =>
      key (period g q) q.out'
        (QuotientGroup.out'_conj_pow_period_mem H g q)
    let f : Quotient (orbitRel (zpowers g) (G â§¸ H)) â†’ zpowers g := fun q =>
      (âŸ¨g, mem_zpowers gâŸ© : zpowers g) ^ period g q.out'
    have hf : âˆ€ q, f q âˆˆ H.subgroupOf (zpowers g) := fun q => key q.out'
    replace key :=
      Subgroup.prod_mem (H.subgroupOf (zpowers g)) fun q (_ : q âˆˆ Finset.univ) => hf q
    simpa only [period_eq_card_zpowers_orbit, Finset.prod_pow_eq_pow_sum, Fintype.card_sigma,
      Fintype.card_congr (selfEquivSigmaOrbits (zpowers g) (G â§¸ H)), index_eq_card] using key","error:  unknown identifier 'QuotientGroup.out'_conj_pow_period_mem'
error:  unknown identifier 'period_eq_card_zpowers_orbit'
error:  type mismatch
  hâœ
has type
  âˆ c : Quotient (orbitRel (â†¥(zpowers g)) (G â§¸ H)), f c âˆˆ H.subgroupOf (zpowers g) : Prop
but is expected to have type
  g ^ âˆ‘ i : orbitRel.Quotient (â†¥(zpowers g)) (G â§¸ H), Fintype.card â†‘(orbit (â†¥(zpowers g)) (Quotient.out' i)) âˆˆ H : Prop","theorem transfer_eq_pow_aux (g : G)
    (key : âˆ€ (k : â„•) (gâ‚€ : G), gâ‚€â»Â¹ * g ^ k * gâ‚€ âˆˆ H â†’ gâ‚€â»Â¹ * g ^ k * gâ‚€ = g ^ k) :
    g ^ H.index âˆˆ H ",":= by
  by_cases hH : H.index = 0
  Â· rw [hH, pow_zero]
    exact H.one_mem
  letI := fintypeOfIndexNeZero hH
  classical
    replace key : âˆ€ (k : â„•) (gâ‚€ : G), gâ‚€â»Â¹ * g ^ k * gâ‚€ âˆˆ H â†’ g ^ k âˆˆ H := fun k gâ‚€ hk =>
      (_root_.congr_arg (Â· âˆˆ H) (key k gâ‚€ hk)).mp hk
    replace key : âˆ€ q : G â§¸ H, g ^ Function.minimalPeriod (g â€¢ Â·) q âˆˆ H := fun q =>
      key (Function.minimalPeriod (g â€¢ Â·) q) q.out'
        (QuotientGroup.out'_conj_pow_minimalPeriod_mem H g q)
    let f : Quotient (orbitRel (zpowers g) (G â§¸ H)) â†’ zpowers g := fun q =>
      (âŸ¨g, mem_zpowers gâŸ© : zpowers g) ^ Function.minimalPeriod (g â€¢ Â·) q.out'
    have hf : âˆ€ q, f q âˆˆ H.subgroupOf (zpowers g) := fun q => key q.out'
    replace key :=
      Subgroup.prod_mem (H.subgroupOf (zpowers g)) fun q (_ : q âˆˆ Finset.univ) => hf q
    simpa only [f, minimalPeriod_eq_card, Finset.prod_pow_eq_pow_sum, Fintype.card_sigma,
      Fintype.card_congr (selfEquivSigmaOrbits (zpowers g) (G â§¸ H)), index_eq_card] using key",refine theorem_theorem_mem transfer_eq_pow_aux transfer_eq_pow_aux transfer_eq_pow_aux transfer_eq_pow_aux
Mathlib/Combinatorics/SetFamily/Compression/Down.lean,Down.mem_compression,mem_compression,61ca0ea882c23bb336df737657ab5b9a48ebdbbe,":=
  by
  simp_rw [compression, mem_disjUnion, mem_filter, mem_image,
    decide_eq_true_eq, and_comm (a := (Â¬ s âˆˆ ğ’œ))]
  refine'
    or_congr_right
      (and_congr_left fun hs =>
        âŸ¨_, fun h => âŸ¨_, h, erase_insert <| insert_ne_self.1 <| ne_of_mem_of_not_mem h hsâŸ©âŸ©)
  rintro âŸ¨t, ht, rflâŸ©
  rwa [insert_erase (erase_ne_self.1 (ne_of_mem_of_not_mem ht hs).symm)]","warning:  @Down.compression does not have a doc string
error:  simp made no progress",theorem mem_compression : s âˆˆ ğ““ a ğ’œ â†” s âˆˆ ğ’œ âˆ§ s.erase a âˆˆ ğ’œ âˆ¨ s âˆ‰ ğ’œ âˆ§ insert a s âˆˆ ğ’œ ,":= by
  simp_rw [compression, mem_disjUnion, mem_filter, mem_image, and_comm (a := (Â¬ s âˆˆ ğ’œ))]
  refine
    or_congr_right
      (and_congr_left fun hs =>
        âŸ¨?_, fun h => âŸ¨_, h, erase_insert <| insert_ne_self.1 <| ne_of_mem_of_not_mem h hsâŸ©âŸ©)
  rintro âŸ¨t, ht, rflâŸ©
  rwa [insert_erase (erase_ne_self.1 (ne_of_mem_of_not_mem ht hs).symm)]",simp only [mem_compression]
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.Î´_comp_Ïƒ_of_le,Î´_comp_Ïƒ_of_le,7472132820a806816d92180a5476e45b47a8d68b,":=
  Hom.ext _ _ (OrderHom.ext _ _ (Fin.predAbove_succ_comp_succAbove_castSucc H))",error:  unknown constant 'Fin.predAbove_succ_comp_succAbove_castSucc',"theorem Î´_comp_Ïƒ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i â‰¤ Fin.castSucc j) :
    Î´ (Fin.castSucc i) â‰« Ïƒ j.succ = Ïƒ j â‰« Î´ i ",":= by
  ext k : 3
  dsimp [Ïƒ, Î´]
  rcases le_or_lt i k with (hik | hik)
  Â· rw [Fin.succAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hik),
    Fin.succ_predAbove_succ, Fin.succAbove_of_le_castSucc]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    Â· rwa [Fin.predAbove_of_le_castSucc _ _ hjk, Fin.castSucc_castPred]
    Â· rw [Fin.le_castSucc_iff, Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succ_pred]
      exact H.trans_lt hjk
  Â· rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hik)]
    have hjk := H.trans_lt' hik
    rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr
      (hjk.trans (Fin.castSucc_lt_succ _)).le),
      Fin.predAbove_of_le_castSucc _ _ hjk.le, Fin.castPred_castSucc, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_castPred]
    rwa [Fin.castSucc_castPred]","rw [Fin.castSucc_castSucc, Î´_comp_Ïƒ_of_le]"
Mathlib/NumberTheory/EllipticDivisibilitySequence.lean,normEDS_neg,normEDS_neg,eda04d24f539d275bf9161920e57d3d1d3781080,":= by
  rw [normEDS, preNormEDS_neg, Int.natAbs_neg, neg_mul, normEDS]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (-?a).natAbs
R : Type u
S : Type v
instâœÂ¹ : CommRing R
instâœ : CommRing S
W : â„¤ â†’ R
f : R â†’+* S
b c d : R
n : â„¤
âŠ¢ (-preNormEDS (b ^ 4) c d n * if Even (-n) then b else 1) = -normEDS b c d n",lemma normEDS_neg (n : â„¤) : normEDS b c d (-n) = -normEDS b c d n ,":= by
  simp only [normEDS, preNormEDS_neg, neg_mul, even_neg]","rw [normEDS_neg, normEDS_neg, normEDS_neg, normEDS_neg]"
Mathlib/CategoryTheory/Limits/HasLimits.lean,CategoryTheory.Limits.hasColimitOfIso,hasColimitOfIso,da3e3a365fffd6c256a62d8990639a4256687a5d,":=
  HasColimit.mk
    { cocone := (Cocones.precompose Î±.hom).obj (colimit.cocone F)
      isColimit :=
        { desc := fun s => colimit.desc F ((Cocones.precompose Î±.inv).obj s)
          fac := fun s j => by
            rw [Cocones.precompose_obj_Î¹, NatTrans.comp_app, colimit.cocone_Î¹]
            rw [Category.assoc, colimit.Î¹_desc, â† NatIso.app_hom, â† Iso.eq_inv_comp]; rfl
          uniq := fun s m w => by
            apply colimit.hom_ext; intro j
            rw [colimit.Î¹_desc, Cocones.precompose_obj_Î¹, NatTrans.comp_app, â† NatIso.app_inv,
              Iso.eq_inv_comp]
            simpa using w j } }","error:  tactic 'apply' failed, failed to unify
  ?f = ?f'
with
  m = (fun s â†¦ colimit.desc F ((Cocones.precompose Î±.inv).obj s)) s
J : Type uâ‚
instâœÂ³ : Category.{vâ‚, uâ‚} J
K : Type uâ‚‚
instâœÂ² : Category.{vâ‚‚, uâ‚‚} K
C : Type u
instâœÂ¹ : Category.{v, u} C
Fâœ F G : J â¥¤ C
instâœ : HasColimit F
Î± : G â‰… F
s : Cocone G
m : ((Cocones.precompose Î±.hom).obj (colimit.cocone F)).pt âŸ¶ s.pt
w : âˆ€ (j : J), ((Cocones.precompose Î±.hom).obj (colimit.cocone F)).Î¹.app j â‰« m = s.Î¹.app j
âŠ¢ m = (fun s â†¦ colimit.desc F ((Cocones.precompose Î±.inv).obj s)) s",theorem hasColimitOfIso {F G : J â¥¤ C} [HasColimit F] (Î± : G â‰… F) : HasColimit G ,":=
  HasColimit.mk
    { cocone := (Cocones.precompose Î±.hom).obj (colimit.cocone F)
      isColimit := (IsColimit.precomposeHomEquiv _ _).symm (colimit.isColimit F) }",haveI : HasColimit F := hasColimitOfIso F G
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime,cyclotomicRing_isIntegralClosure_of_prime,954582f0c09c6f4ec138a9365f445da0d3a83bfd,":= by
  haveI : CharZero â„š := StrictOrderedSemiring.to_charZero
  have hÎ¶ := zeta_spec (p ^ k) â„š (CyclotomicField (p ^ k) â„š)
  refine' âŸ¨IsFractionRing.injective _ _, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, _âŸ©, rflâŸ©, _âŸ©âŸ©
  Â· have := (isIntegralClosure_adjoin_singleton_of_prime_pow hÎ¶)
    obtain âŸ¨y, rflâŸ© := this.isIntegral_iff.1 h
    refine' adjoin_mono _ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hÎ¶.pow_eq_one
  Â· rintro âŸ¨y, rflâŸ©
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} â„¤ _) _)","error:  unknown constant 'StrictOrderedSemiring.to_charZero'
error:  function expected at
  integral {p ^ k} â„¤ ?m.69712
term has type
  Algebra.IsIntegral â„¤ ?m.69712","theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) â„¤ â„š) â„¤ (CyclotomicField (p ^ k) â„š) ",":= by
  have hÎ¶ := zeta_spec (p ^ k) â„š (CyclotomicField (p ^ k) â„š)
  refine âŸ¨IsFractionRing.injective _ _, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©, ?_âŸ©âŸ©
  Â· have := isIntegralClosure_adjoin_singleton_of_prime_pow hÎ¶
    obtain âŸ¨y, rflâŸ© := this.isIntegral_iff.1 h
    refine adjoin_mono ?_ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hÎ¶.pow_eq_one
  Â· rintro âŸ¨y, rflâŸ©
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} â„¤ _).isIntegral _)","refine IsIntegralClosure.cyclotomicRing_isIntegralClosure_of_prime_pow cyclotomicRing_isIntegralClosure_of_prime_pow
  cyclotomicRing_isIntegralClosure_of_prime_pow cyclotomicRing_isIntegralClosure_of_prime_pow cyclotomicRing_isIntegralClosure_of_prime_pow"
Mathlib/MeasureTheory/Measure/Haar/Basic.lean,MeasureTheory.Measure.div_mem_nhds_one_of_haar_pos,div_mem_nhds_one_of_haar_pos,488012d0f5ac537bb8055c310b3f223de3f6802e,":= by
  obtain âŸ¨K, hKE, hK, K_closed, hKposâŸ© :
      âˆƒ (K : Set G), K âŠ† E âˆ§ IsCompact K âˆ§ IsClosed K âˆ§ 0 < Î¼ K := by
    rcases MeasurableSet.exists_lt_isCompact hE hEpos with âŸ¨K, KE, K_comp, K_measâŸ©
    refine âŸ¨closure K, ?_, K_comp.closure, isClosed_closure, ?_âŸ©
    Â· exact IsCompact.closure_subset_of_measurableSet_of_group K_comp hE KE
    Â· rwa [K_comp.measure_closure_eq_of_group]
  obtain âŸ¨V, hV1, hVâŸ© : âˆƒ V âˆˆ ğ“ (1 : G), âˆ€ g âˆˆ V, Î¼ (g â€¢ K \ K) < Î¼ K :=
    exists_nhds_measure_smul_diff_lt hK K_closed hKpos.ne'
  have hv : âˆ€ v : G, v âˆˆ V â†’ Â¬Disjoint (v â€¢ K) K := by
    intro v hv hKv
    have Z := hV v hv
    rw [hKv.symm.sdiff_eq_right, measure_smul] at Z
    exact lt_irrefl _ Z
  suffices V âŠ† E / E from Filter.mem_of_superset hV1 this
  intro v hvV
  obtain âŸ¨x, hxK, hxvKâŸ© : âˆƒ x : G, x âˆˆ v â€¢ K âˆ§ x âˆˆ K := Set.not_disjoint_iff.1 (hv v hvV)
  refine âŸ¨x, hKE hxvK, vâ»Â¹ * x, hKE ?_, ?_âŸ©
  Â· simpa [mem_smul_set_iff_inv_smul_mem] using hxK
  Â· simp only [div_eq_iff_eq_mul, â† mul_assoc, mul_right_inv, one_mul]","warning:  `IsCompact.closure_subset_of_measurableSet_of_group` has been deprecated, use `IsCompact.closure_subset_measurableSet` instead
warning:  `IsCompact.measure_closure_eq_of_group` has been deprecated, use `IsCompact.measure_closure` instead
error:  unknown identifier 'exists_nhds_measure_smul_diff_lt'","theorem div_mem_nhds_one_of_haar_pos (Î¼ : Measure G) [IsHaarMeasure Î¼] [LocallyCompactSpace G]
    [InnerRegular Î¼] (E : Set G) (hE : MeasurableSet E) (hEpos : 0 < Î¼ E) :
    E / E âˆˆ ğ“ (1 : G) ",":= by
  obtain âŸ¨K, hKE, hK, K_closed, hKposâŸ© :
      âˆƒ (K : Set G), K âŠ† E âˆ§ IsCompact K âˆ§ IsClosed K âˆ§ 0 < Î¼ K := by
    rcases MeasurableSet.exists_lt_isCompact hE hEpos with âŸ¨K, KE, K_comp, K_measâŸ©
    refine âŸ¨closure K, ?_, K_comp.closure, isClosed_closure, ?_âŸ©
    Â· exact K_comp.closure_subset_measurableSet hE KE
    Â· rwa [K_comp.measure_closure]
  filter_upwards [eventually_nhds_one_measure_smul_diff_lt hK K_closed hKpos.ne' (Î¼ := Î¼)] with g hg
  have : Â¬Disjoint (g â€¢ K) K := fun hd â†¦ by
    rw [hd.symm.sdiff_eq_right, measure_smul] at hg
    exact hg.false
  rcases Set.not_disjoint_iff.1 this with âŸ¨_, âŸ¨x, hxK, rflâŸ©, hgxKâŸ©
  simpa using div_mem_div (hKE hgxK) (hKE hxK)",apply mem_of_superset self_mem_nhds_one_of_mem_nhds
Mathlib/LinearAlgebra/Matrix/Adjugate.lean,Matrix.cramer_eq_adjugate_mulVec,cramer_eq_adjugate_mulVec,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  nth_rw 2 [â† A.transpose_transpose]
  rw [â† adjugate_transpose, adjugate_def]
  have : b = âˆ‘ i, b i â€¢ Pi.single i 1 := by
    refine (pi_eq_sum_univ b).trans ?_
    congr with j
    simp [Pi.single_apply, eq_comm, Pi.smul_apply (b j)]
  conv_lhs =>
    rw [this]
  ext k
  simp [mulVec, dotProduct, mul_comm]","error:  failed to synthesize
  HSMul Î± ((j : n) â†’ ?m.88526 j) ?m.88897
(deterministic) timeout at `typeclass`, maximum number of heartbeats (20000) has been reached
use `set_option synthInstance.maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
use `set_option diagnostics true` to get diagnostic information
error:  unsolved goals
case e_f.h.h
m : Type u
n : Type v
Î± : Type w
instâœâ´ : DecidableEq n
instâœÂ³ : Fintype n
instâœÂ² : DecidableEq m
instâœÂ¹ : Fintype m
instâœ : CommRing Î±
A : Matrix n n Î±
b : n â†’ Î±
j xâœ : n
âŠ¢ (if j = xâœ then b j else 0) = sorryAx (n â†’ Î±) true xâœ
error:  unsolved goals
case h
m : Type u
n : Type v
Î± : Type w
instâœâ´ : DecidableEq n
instâœÂ³ : Fintype n
instâœÂ² : DecidableEq m
instâœÂ¹ : Fintype m
instâœ : CommRing Î±
A : Matrix n n Î±
b : n â†’ Î±
this : b = âˆ‘ i : n, sorryAx (n â†’ Î±) true
k : n
âŠ¢ A.cramer ((fun x â†¦ â†‘(Fintype.card n)) * sorryAx (n â†’ Î±) true) k = âˆ‘ x : n, b x * A.cramer (Pi.single x 1) k","theorem cramer_eq_adjugate_mulVec (A : Matrix n n Î±) (b : n â†’ Î±) :
    cramer A b = A.adjugate *áµ¥ b ",":= by
  nth_rw 2 [â† A.transpose_transpose]
  rw [â† adjugate_transpose, adjugate_def]
  have : b = âˆ‘ i, b i â€¢ (Pi.single i 1 : n â†’ Î±) := by
    refine (pi_eq_sum_univ b).trans ?_
    congr with j
    simp [Pi.single_apply, eq_comm, Pi.smul_apply (b j)]
  conv_lhs =>
    rw [this]
  ext k
  simp [mulVec, dotProduct, mul_comm]",rw [cramer_eq_adjugate_mulVec]
Mathlib/LinearAlgebra/TensorProduct/RightExactness.lean,Algebra.TensorProduct.map_ker,Algebra.TensorProduct.map_ker,01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  have : map f g = (map f (AlgHom.id R D)).comp (map (AlgHom.id R A) g) := ext rfl rfl
  rw [this]
  simp only [AlgHom.coe_ker, AlgHom.comp_toRingHom]
  rw [â† RingHom.comap_ker]
  simp only [â† AlgHom.coe_ker]
  rw [â† Algebra.TensorProduct.lTensor_ker _ hg, RingHom.ker_eq_comap_bot (map (AlgHom.id R A) g)]
  rw [â† Ideal.comap_map_of_surjective _ (lTensor.surjective A hg)]
  rw [Algebra.TensorProduct.rTensor_ker _ hf]
  apply congr_argâ‚‚ _ rfl
  simp only [AlgHom.coe_ideal_map, Ideal.map_map]
  rw [â† AlgHom.comp_toRingHom, Algebra.TensorProduct.map_comp_includeLeft]
  rfl",error:  unknown identifier 'lTensor.surjective',"theorem Algebra.TensorProduct.map_ker (hf : Function.Surjective f) (hg : Function.Surjective g) :
    RingHom.ker (map f g) =
      (RingHom.ker f).map (Algebra.TensorProduct.includeLeft : A â†’â‚[R] A âŠ—[R] C) âŠ”
        (RingHom.ker g).map (Algebra.TensorProduct.includeRight : C â†’â‚[R] A âŠ—[R] C) ",":= by
  have : map f g = (map f (AlgHom.id R D)).comp (map (AlgHom.id R A) g) := ext rfl rfl
  rw [this]
  simp only [AlgHom.coe_ker, AlgHom.comp_toRingHom]
  rw [â† RingHom.comap_ker]
  simp only [â† AlgHom.coe_ker]
  rw [â† Algebra.TensorProduct.lTensor_ker _ hg, RingHom.ker_eq_comap_bot (map (AlgHom.id R A) g)]
  rw [â† Ideal.comap_map_of_surjective (map (AlgHom.id R A) g) (LinearMap.lTensor_surjective A hg)]
  rw [Algebra.TensorProduct.rTensor_ker _ hf]
  apply congr_argâ‚‚ _ rfl
  simp only [AlgHom.coe_ideal_map, Ideal.map_map]
  rw [â† AlgHom.comp_toRingHom, Algebra.TensorProduct.map_comp_includeLeft]
  rfl","simp only [Algebra.TensorProduct.includeRight, Algebra.TensorProduct.includeRight,
  Algebra.TensorProduct.includeRight, Algebra.TensorProduct.includeRight]"
Mathlib/SetTheory/Ordinal/Notation.lean,ONote.fundamentalSequence_has_prop,fundamentalSequence_has_prop,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' o with a m b iha ihb; Â· exact rfl
  rw [fundamentalSequence]
  rcases e : b.fundamentalSequence with (âŸ¨_ | b'âŸ© | f) <;>
    simp only [FundamentalSequenceProp] <;>
    rw [e, FundamentalSequenceProp] at ihb
  Â· rcases e : a.fundamentalSequence with (âŸ¨_ | a'âŸ© | f) <;> cases' e' : m.natPred with m' <;>
      simp only [FundamentalSequenceProp] <;>
      rw [e, FundamentalSequenceProp] at iha <;>
      (try rw [show m = 1 by
            have := PNat.natPred_add_one m; rw [e'] at this; exact PNat.coe_inj.1 this.symm]) <;>
      (try rw [show m = m'.succ.succPNat by
              rw [â† e', â† PNat.coe_inj, Nat.succPNat_coe, â† Nat.add_one, PNat.natPred_add_one]]) <;>
      simp only [repr, iha, ihb, opow_lt_opow_iff_right one_lt_omega, add_lt_add_iff_left, add_zero,
        eq_self_iff_true, lt_add_iff_pos_right, lt_def, mul_one, Nat.cast_zero, Nat.cast_succ,
        Nat.succPNat_coe, opow_succ, opow_zero, mul_add_one, PNat.one_coe, succ_zero,
        true_and_iff, _root_.zero_add, zero_def]
    Â· decide
    Â· exact âŸ¨rfl, inferInstanceâŸ©
    Â· have := opow_pos (repr a') omega_pos
      refine'
        âŸ¨mul_isLimit this omega_isLimit, fun i =>
          âŸ¨this, _, fun H => @NF.oadd_zero _ _ (iha.2 H.fst)âŸ©, exists_lt_mul_omega'âŸ©
      rw [â† mul_succ, â† natCast_succ, Ordinal.mul_lt_mul_iff_left this]
      apply nat_lt_omega
    Â· have := opow_pos (repr a') omega_pos
      refine'
        âŸ¨add_isLimit _ (mul_isLimit this omega_isLimit), fun i => âŸ¨this, _, _âŸ©,
          exists_lt_add exists_lt_mul_omega'âŸ©
      Â· rw [â† mul_succ, â† natCast_succ, Ordinal.mul_lt_mul_iff_left this]
        apply nat_lt_omega
      Â· refine' fun H => H.fst.oadd _ (NF.below_of_lt' _ (@NF.oadd_zero _ _ (iha.2 H.fst)))
        rw [repr, â† zero_def, repr, add_zero, iha.1, opow_succ, Ordinal.mul_lt_mul_iff_left this]
        apply nat_lt_omega
    Â· rcases iha with âŸ¨h1, h2, h3âŸ©
      refine' âŸ¨opow_isLimit one_lt_omega h1, fun i => _, exists_lt_omega_opow' one_lt_omega h1 h3âŸ©
      obtain âŸ¨h4, h5, h6âŸ© := h2 i
      exact âŸ¨h4, h5, fun H => @NF.oadd_zero _ _ (h6 H.fst)âŸ©
    Â· rcases iha with âŸ¨h1, h2, h3âŸ©
      refine'
        âŸ¨add_isLimit _ (opow_isLimit one_lt_omega h1), fun i => _,
          exists_lt_add (exists_lt_omega_opow' one_lt_omega h1 h3)âŸ©
      obtain âŸ¨h4, h5, h6âŸ© := h2 i
      refine' âŸ¨h4, h5, fun H => H.fst.oadd _ (NF.below_of_lt' _ (@NF.oadd_zero _ _ (h6 H.fst)))âŸ©
      rwa [repr, â† zero_def, repr, add_zero, PNat.one_coe, Nat.cast_one, mul_one,
        opow_lt_opow_iff_right one_lt_omega]
  Â· refine'
      âŸ¨by rw [repr, ihb.1, add_succ, repr], fun H => H.fst.oadd _ (NF.below_of_lt' _ (ihb.2 H.snd))âŸ©
    have := H.snd'.repr_lt
    rw [ihb.1] at this
    exact (lt_succ _).trans this
  Â· rcases ihb with âŸ¨h1, h2, h3âŸ©
    simp only [repr]
    exact
      âŸ¨Ordinal.add_isLimit _ h1, fun i =>
        âŸ¨oadd_lt_oadd_3 (h2 i).1, oadd_lt_oadd_3 (h2 i).2.1, fun H =>
          H.fst.oadd _ (NF.below_of_lt' (lt_trans (h2 i).2.1 H.snd'.repr_lt) ((h2 i).2.2 H.snd))âŸ©,
        exists_lt_add h3âŸ©","warning:  unused variable `R'`
note: this linter can be disabled with `set_option linter.unusedVariables false`
error:  application type mismatch
  And.intro rfl
argument
  rfl
has type
  1 * â†‘â†‘m = 1 * â†‘â†‘m : Prop
but is expected to have type
  1 * â†‘â†‘m = succ (1 * â†‘m' + 1) : Prop
error:  application type mismatch
  âŸ¨fun i â†¦ âŸ¨this, âŸ¨?m.236228 i, ?m.236229 iâŸ©âŸ©, ONote.exists_lt_add ONote.exists_lt_mul_omega'âŸ©
argument
  ONote.exists_lt_add ONote.exists_lt_mul_omega'
has type
  âˆ€ â¦ƒa : Ordinal.{?u.236237}â¦„, a < ?m.236253 + ?m.236238 * Ï‰ â†’ âˆƒ i, a < ?m.236253 + (?m.236238 * â†‘i + ?m.236238) : Prop
but is expected to have type
  âˆ€ a < Ï‰ ^ a'.repr * Ï‰ * â†‘â†‘m,
    âˆƒ i, a < Ï‰ ^ a'.repr * Ï‰ * â†‘m' + Ï‰ ^ a'.repr * Ï‰ + (Ï‰ ^ a'.repr * â†‘i + Ï‰ ^ a'.repr) : Prop
error:  application type mismatch
  âŸ¨fun i â†¦ ?m.244893 i, ONote.exists_lt_add (ONote.exists_lt_omega_opow' one_lt_omega h1 h3)âŸ©
argument
  ONote.exists_lt_add (ONote.exists_lt_omega_opow' one_lt_omega h1 h3)
has type
  âˆ€ â¦ƒa_1 : Ordinal.{0}â¦„, a_1 < ?m.244948 + Ï‰ ^ a.repr â†’ âˆƒ i, a_1 < ?m.244948 + Ï‰ ^ (f i).repr : Prop
but is expected to have type
  âˆ€ a_1 < Ï‰ ^ a.repr * â†‘â†‘m, âˆƒ i, a_1 < Ï‰ ^ a.repr * â†‘m' + Ï‰ ^ a.repr + Ï‰ ^ (f i).repr : Prop",theorem fundamentalSequence_has_prop (o) : FundamentalSequenceProp o (fundamentalSequence o) ,":= by
  induction' o with a m b iha ihb; Â· exact rfl
  rw [fundamentalSequence]
  rcases e : b.fundamentalSequence with (âŸ¨_ | b'âŸ© | f) <;>
    simp only [FundamentalSequenceProp] <;>
    rw [e, FundamentalSequenceProp] at ihb
  Â· rcases e : a.fundamentalSequence with (âŸ¨_ | a'âŸ© | f) <;> cases' e' : m.natPred with m' <;>
      simp only [FundamentalSequenceProp] <;>
      rw [e, FundamentalSequenceProp] at iha <;>
      (try rw [show m = 1 by
            have := PNat.natPred_add_one m; rw [e'] at this; exact PNat.coe_inj.1 this.symm]) <;>
      (try rw [show m = (m' + 1).succPNat by
              rw [â† e', â† PNat.coe_inj, Nat.succPNat_coe, â† Nat.add_one, PNat.natPred_add_one]]) <;>
      simp only [repr, iha, ihb, opow_lt_opow_iff_right one_lt_omega, add_lt_add_iff_left, add_zero,
        eq_self_iff_true, lt_add_iff_pos_right, lt_def, mul_one, Nat.cast_zero, Nat.cast_succ,
        Nat.succPNat_coe, opow_succ, opow_zero, mul_add_one, PNat.one_coe, succ_zero,
        true_and_iff, _root_.zero_add, zero_def]
    Â· decide
    Â· exact âŸ¨rfl, inferInstanceâŸ©
    Â· have := opow_pos (repr a') omega_pos
      refine
        âŸ¨mul_isLimit this omega_isLimit, fun i =>
          âŸ¨this, ?_, fun H => @NF.oadd_zero _ _ (iha.2 H.fst)âŸ©, exists_lt_mul_omega'âŸ©
      rw [â† mul_succ, â† natCast_succ, Ordinal.mul_lt_mul_iff_left this]
      apply nat_lt_omega
    Â· have := opow_pos (repr a') omega_pos
      refine
        âŸ¨add_isLimit _ (mul_isLimit this omega_isLimit), fun i => âŸ¨this, ?_, ?_âŸ©,
          exists_lt_add exists_lt_mul_omega'âŸ©
      Â· rw [â† mul_succ, â† natCast_succ, Ordinal.mul_lt_mul_iff_left this]
        apply nat_lt_omega
      Â· refine fun H => H.fst.oadd _ (NF.below_of_lt' ?_ (@NF.oadd_zero _ _ (iha.2 H.fst)))
        rw [repr, â† zero_def, repr, add_zero, iha.1, opow_succ, Ordinal.mul_lt_mul_iff_left this]
        apply nat_lt_omega
    Â· rcases iha with âŸ¨h1, h2, h3âŸ©
      refine âŸ¨opow_isLimit one_lt_omega h1, fun i => ?_, exists_lt_omega_opow' one_lt_omega h1 h3âŸ©
      obtain âŸ¨h4, h5, h6âŸ© := h2 i
      exact âŸ¨h4, h5, fun H => @NF.oadd_zero _ _ (h6 H.fst)âŸ©
    Â· rcases iha with âŸ¨h1, h2, h3âŸ©
      refine
        âŸ¨add_isLimit _ (opow_isLimit one_lt_omega h1), fun i => ?_,
          exists_lt_add (exists_lt_omega_opow' one_lt_omega h1 h3)âŸ©
      obtain âŸ¨h4, h5, h6âŸ© := h2 i
      refine âŸ¨h4, h5, fun H => H.fst.oadd _ (NF.below_of_lt' ?_ (@NF.oadd_zero _ _ (h6 H.fst)))âŸ©
      rwa [repr, â† zero_def, repr, add_zero, PNat.one_coe, Nat.cast_one, mul_one,
        opow_lt_opow_iff_right one_lt_omega]
  Â· refine âŸ¨by
      rw [repr, ihb.1, add_succ, repr], fun H => H.fst.oadd _ (NF.below_of_lt' ?_ (ihb.2 H.snd))âŸ©
    have := H.snd'.repr_lt
    rw [ihb.1] at this
    exact (lt_succ _).trans this
  Â· rcases ihb with âŸ¨h1, h2, h3âŸ©
    simp only [repr]
    exact
      âŸ¨Ordinal.add_isLimit _ h1, fun i =>
        âŸ¨oadd_lt_oadd_3 (h2 i).1, oadd_lt_oadd_3 (h2 i).2.1, fun H =>
          H.fst.oadd _ (NF.below_of_lt' (lt_trans (h2 i).2.1 H.snd'.repr_lt) ((h2 i).2.2 H.snd))âŸ©,
        exists_lt_add h3âŸ©","rw [fundamentalSequence, fundamentalSequenceProp]"
Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean,MeasureTheory.measure_inter_null_of_null_left,measure_inter_null_of_null_left,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  measure_mono_null (inter_subset_left S T) h","warning:  `MeasureTheory.OuterMeasure.empty'` has been deprecated, use `MeasureTheory.measure_empty` instead
error:  application type mismatch
  inter_subset_left S
argument
  S
has type
  Set Î± : Type u_1
but is expected to have type
  ?m.24969 âˆˆ ?m.24967 âˆ© ?m.24968 : Prop",theorem measure_inter_null_of_null_left {S : Set Î±} (T : Set Î±) (h : Î¼ S = 0) : Î¼ (S âˆ© T) = 0 ,":=
  measure_mono_null inter_subset_left h",exact measure_inter_null_of_null_of_null_left _ _ _ h
Mathlib/MeasureTheory/Constructions/Prod/Basic.lean,measurable_measure_prod_mk_left_finite,measurable_measure_prod_mk_left_finite,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine' induction_on_inter (C := fun s => Measurable fun x => Î½ (Prod.mk x â»Â¹' s))
    generateFrom_prod.symm isPiSystem_prod _ _ _ _ hs
  Â· simp [measurable_zero, const_def]
  Â· rintro _ âŸ¨s, hs, t, _, rflâŸ©
    simp only [mk_preimage_prod_right_eq_if, measure_if]
    exact measurable_const.indicator hs
  Â· intro t ht h2t
    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top Î½ _)]
    exact h2t.const_sub _
  Â· intro f h1f h2f h3f
    simp_rw [preimage_iUnion]
    have : âˆ€ b, Î½ (â‹ƒ i, Prod.mk b â»Â¹' f i) = âˆ‘' i, Î½ (Prod.mk b â»Â¹' f i) := fun b =>
      measure_iUnion (fun i j hij => Disjoint.preimage _ (h1f hij)) fun i =>
        measurable_prod_mk_left (h2f i)
    simp_rw [this]
    apply Measurable.ennreal_tsum h3f","error:  unsolved goals
case refine'_1
Î± : Type u_1
Î±' : Type u_2
Î² : Type u_3
Î²' : Type u_4
Î³ : Type u_5
E : Type u_6
instâœâ¶ : MeasurableSpace Î±
instâœâµ : MeasurableSpace Î±'
instâœâ´ : MeasurableSpace Î²
instâœÂ³ : MeasurableSpace Î²'
instâœÂ² : MeasurableSpace Î³
Î¼ Î¼' : Measure Î±
Î½ Î½' : Measure Î²
Ï„ : Measure Î³
instâœÂ¹ : NormedAddCommGroup E
instâœ : IsFiniteMeasure Î½
s : Set (Î± Ã— Î²)
hs : MeasurableSet s
âŠ¢ Measurable (const Î± (Î½ âˆ…))","theorem measurable_measure_prod_mk_left_finite [IsFiniteMeasure Î½] {s : Set (Î± Ã— Î²)}
    (hs : MeasurableSet s) : Measurable fun x => Î½ (Prod.mk x â»Â¹' s) ",":= by
  refine induction_on_inter (C := fun s => Measurable fun x => Î½ (Prod.mk x â»Â¹' s))
    generateFrom_prod.symm isPiSystem_prod ?_ ?_ ?_ ?_ hs
  Â· simp
  Â· rintro _ âŸ¨s, hs, t, _, rflâŸ©
    simp only [mk_preimage_prod_right_eq_if, measure_if]
    exact measurable_const.indicator hs
  Â· intro t ht h2t
    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top Î½ _)]
    exact h2t.const_sub _
  Â· intro f h1f h2f h3f
    simp_rw [preimage_iUnion]
    have : âˆ€ b, Î½ (â‹ƒ i, Prod.mk b â»Â¹' f i) = âˆ‘' i, Î½ (Prod.mk b â»Â¹' f i) := fun b =>
      measure_iUnion (fun i j hij => Disjoint.preimage _ (h1f hij)) fun i =>
        measurable_prod_mk_left (h2f i)
    simp_rw [this]
    apply Measurable.ennreal_tsum h3f",exact measurable_measure_prod_mk_left_finite_measure hs
Mathlib/GroupTheory/OrderOfElement.lean,Fintype.card_zpowers,Fintype.card_zpowers,e8acc5ce2eae55793195ef3a2db2fbbe35cc03aa,":=
  (Fintype.card_eq.2 âŸ¨finEquivZpowers x $ isOfFinOrder_of_finite _âŸ©).symm.trans $
    Fintype.card_fin (orderOf x)",error:  unknown identifier 'finEquivZpowers',theorem Fintype.card_zpowers : Fintype.card (zpowers x) = orderOf x ,":=
  (Fintype.card_eq.2 âŸ¨finEquivZPowers x <| isOfFinOrder_of_finite _âŸ©).symm.trans <|
    Fintype.card_fin (orderOf x)","rw [orderOf, Fintype.card_zpowers]"
Mathlib/FieldTheory/Finite/Basic.lean,FiniteField.card_image_polynomial_eval,card_image_polynomial_eval,89feeaaf464cdb346baab6c7adb1bec331fe789a,:= sorry,"warning:  declaration uses 'sorry'
error:  application type mismatch
  exists_root_sum_quadratic g
argument
  g
has type
  (ZMod p)[X] : Type
but is expected to have type
  ?m.131368.degree = 2 : Prop
error:  expected type must not contain free or meta variables
  0 < ?m.131833","theorem card_image_polynomial_eval [DecidableEq R] [Fintype R] {p : R[X]} (hp : 0 < p.degree) :
    Fintype.card R â‰¤ natDegree p * (univ.image fun x => eval x p).card ",":=
  Finset.card_le_mul_card_image _ _ (fun a _ =>
    calc
      _ = (p - C a).roots.toFinset.card :=
        congr_arg card (by simp [Finset.ext_iff, â† mem_roots_sub_C hp])
      _ â‰¤ Multiset.card (p - C a).roots := Multiset.toFinset_card_le _
      _ â‰¤ _ := card_roots_sub_C' hp)",rw [card_image_polynomial_eval]
Mathlib/Analysis/Complex/CauchyIntegral.lean,Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  set A := closedBall c R \ ball c r
  obtain âŸ¨a, rflâŸ© : âˆƒ a, Real.exp a = r; exact âŸ¨Real.log r, Real.exp_log h0âŸ©
  obtain âŸ¨b, rflâŸ© : âˆƒ b, Real.exp b = R; exact âŸ¨Real.log R, Real.exp_log (h0.trans_le hle)âŸ©
  rw [Real.exp_le_exp] at hle
  suffices
    (âˆ« Î¸ in (0)..2 * Ï€, I â€¢ f (circleMap c (Real.exp b) Î¸)) =
      âˆ« Î¸ in (0)..2 * Ï€, I â€¢ f (circleMap c (Real.exp a) Î¸) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, â† exp_add, smul_smul, â†
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] Ã—â„‚ [[0, 2 * Ï€]]
  set g : â„‚ â†’ â„‚ := (Â· + Â·) c âˆ˜ exp
  have hdg : Differentiable â„‚ g := differentiable_exp.const_add _
  replace hs : (g â»Â¹' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z âŸ¨h, -âŸ©; simpa [dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f âˆ˜ g) R; exact hc.comp hdg.continuous.continuousOn h_maps
  replace hd :
    âˆ€ z âˆˆ Ioo (min a b) (max a b) Ã—â„‚ Ioo (min 0 (2 * Ï€)) (max 0 (2 * Ï€)) \ g â»Â¹' s,
      DifferentiableAt â„‚ (f âˆ˜ g) z
  Â· refine' fun z hz => (hd (g z) âŸ¨_, hz.2âŸ©).comp z (hdg _)
    simpa [dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [circleMap, exp_periodic _, sub_eq_zero, â† exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ âŸ¨a, 0âŸ© âŸ¨b, 2 * Ï€âŸ© _ hs hc hd","error:  unexpected token ';'; expected '|'
error:  unsolved goals
case intro.intro
E : Type u
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„‚ E
instâœ : CompleteSpace E
c : â„‚
f : â„‚ â†’ E
s : Set â„‚
a : â„
h0 : 0 < rexp a
b : â„
hle : a â‰¤ b
hd : âˆ€ z âˆˆ (ball c (rexp b) \ closedBall c (rexp a)) \ s, DifferentiableAt â„‚ f z
A : Set â„‚ := closedBall c (rexp b) \ ball c (rexp a)
R : Set â„‚ := [[a, b]] Ã—â„‚ [[0, 2 * Ï€]]
g : â„‚ â†’ â„‚ := (fun x x_1 â†¦ x + x_1) c âˆ˜ cexp
hdg : Differentiable â„‚ g
hs : (g â»Â¹' s).Countable
h_maps : MapsTo g R A
hc : ContinuousOn (f âˆ˜ g) R
âŠ¢ âˆ« (Î¸ : â„) in 0 ..2 * Ï€, I â€¢ f (circleMap c (rexp b) Î¸) = âˆ« (Î¸ : â„) in 0 ..2 * Ï€, I â€¢ f (circleMap c (rexp a) Î¸)","theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : â„‚}
    {r R : â„} (h0 : 0 < r) (hle : r â‰¤ R) {f : â„‚ â†’ E} {s : Set â„‚} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : âˆ€ z âˆˆ (ball c R \ closedBall c r) \ s, DifferentiableAt â„‚ f z) :
    (âˆ® z in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® z in C(c, r), (z - c)â»Â¹ â€¢ f z ",":= by
  set A := closedBall c R \ ball c r
  obtain âŸ¨a, rflâŸ© : âˆƒ a, Real.exp a = r := âŸ¨Real.log r, Real.exp_log h0âŸ©
  obtain âŸ¨b, rflâŸ© : âˆƒ b, Real.exp b = R := âŸ¨Real.log R, Real.exp_log (h0.trans_le hle)âŸ©
  rw [Real.exp_le_exp] at hle
  suffices
    (âˆ« Î¸ in (0)..2 * Ï€, I â€¢ f (circleMap c (Real.exp b) Î¸)) =
      âˆ« Î¸ in (0)..2 * Ï€, I â€¢ f (circleMap c (Real.exp a) Î¸) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, â† exp_add, smul_smul, â†
      div_eq_mul_inv, mul_div_cancel_leftâ‚€ _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] Ã—â„‚ [[0, 2 * Ï€]]
  set g : â„‚ â†’ â„‚ := (c + exp Â·)
  have hdg : Differentiable â„‚ g := differentiable_exp.const_add _
  replace hs : (g â»Â¹' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z âŸ¨h, -âŸ©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f âˆ˜ g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : âˆ€ z âˆˆ Ioo (min a b) (max a b) Ã—â„‚ Ioo (min 0 (2 * Ï€)) (max 0 (2 * Ï€)) \ g â»Â¹' s,
      DifferentiableAt â„‚ (f âˆ˜ g) z := by
    refine fun z hz => (hd (g z) âŸ¨?_, hz.2âŸ©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, â† exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ âŸ¨a, 0âŸ© âŸ¨b, 2 * Ï€âŸ© _ hs hc hd","refine theorem_circleIntegral_sub_center_inv_smul_eq_of_differentiable_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_center_inv_smul_eq_of_differentiable
  circleIntegral_sub_center_inv_smul_eq_of_differentiable_circleIntegral_sub_"
Mathlib/Analysis/SpecialFunctions/Integrals.lean,intervalIntegral.intervalIntegrable_rpow',intervalIntegrable_rpow',3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  suffices âˆ€ c : â„, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : âˆ€ c : â„, 0 â‰¤ c â†’ IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : âˆ€ x âˆˆ Ioo 0 c, HasDerivAt (fun x : â„ => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 â‰  0)]; ring
    apply integrableOn_deriv_of_nonneg _ hderiv
    Â· intro x hx; apply rpow_nonneg hx.1.le
    Â· refine' (continuousOn_id.rpow_const _).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  Â· exact this c hc
  Â· rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * Ï€))
    rw [intervalIntegrable_iff] at m âŠ¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 â‰¤ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]",error:  no goals to be solved,"theorem intervalIntegrable_rpow' {r : â„} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b ",":= by
  suffices âˆ€ c : â„, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact IntervalIntegrable.trans (this a).symm (this b)
  have : âˆ€ c : â„, 0 â‰¤ c â†’ IntervalIntegrable (fun x => x ^ r) volume 0 c := by
    intro c hc
    rw [intervalIntegrable_iff, uIoc_of_le hc]
    have hderiv : âˆ€ x âˆˆ Ioo 0 c, HasDerivAt (fun x : â„ => x ^ (r + 1) / (r + 1)) (x ^ r) x := by
      intro x hx
      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1
      field_simp [(by linarith : r + 1 â‰  0)]
    apply integrableOn_deriv_of_nonneg _ hderiv
    Â· intro x hx; apply rpow_nonneg hx.1.le
    Â· refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith
  intro c; rcases le_total 0 c with (hc | hc)
  Â· exact this c hc
  Â· rw [IntervalIntegrable.iff_comp_neg, neg_zero]
    have m := (this (-c) (by linarith)).smul (cos (r * Ï€))
    rw [intervalIntegrable_iff] at m âŠ¢
    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx
    rw [uIoc_of_le (by linarith : 0 â‰¤ -c)] at hx
    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,
      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]","have : IntervalIntegrable (fun x : â„ â†¦ x ^ r) volume (intervalIntegrable_rpow' _ _) :=
  IntervalIntegrable.intervalIntegrable_rpow' _ _"
Mathlib/Data/Set/Finite.lean,Set.Finite.bddBelow_biUnion,Finite.bddBelow_biUnion,cda5caa719c6f4cebb505d3bc9250e3bbaf0fc67,":=
  @Finite.bddAbove_biUnion Î±áµ’áµˆ _ _ _ _ _ H","error:  application type mismatch
  @bddAbove_biUnion Î±áµ’áµˆ ?m.193453 ?m.193454 ?m.193455 ?m.193456 ?m.193457 H
argument
  H
has type
  I.Finite : Prop
but is expected to have type
  ?m.193453 â†’ Set Î±áµ’áµˆ : Type (max ?u.193450 u)","theorem Finite.bddBelow_biUnion {I : Set Î²} {S : Î² â†’ Set Î±} (H : I.Finite) :
    BddBelow (â‹ƒ i âˆˆ I, S i) â†” âˆ€ i âˆˆ I, BddBelow (S i) ",":=
  @Finite.bddAbove_biUnion Î±áµ’áµˆ _ _ _ _ _ _ H","simp only [BddBelow, Set.biUnion_iUnion, Set.iUnion_eq_iUnion_bddBelow]"
Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean,Convex.taylor_approx_two_segment,Convex.taylor_approx_two_segment,8e31b5ac6bed8ba535a30f3442252684d2f151c1,":= by
  refine' IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun Îµ Îµpos => _) (isBigO_const_mul_self ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) _ _)
  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
  rcases Metric.mem_nhdsWithin_iff.1 (hx Îµpos) with âŸ¨Î´, Î´pos, sÎ´âŸ©
  have E1 : âˆ€á¶  h in ğ“[>] (0 : â„), h * (â€–vâ€– + â€–wâ€–) < Î´ := by
    have : Filter.Tendsto (fun h => h * (â€–vâ€– + â€–wâ€–)) (ğ“[>] (0 : â„)) (ğ“ (0 * (â€–vâ€– + â€–wâ€–))) :=
      (continuous_id.mul continuous_const).continuousWithinAt
    apply (tendsto_order.1 this).2 Î´
    simpa only [zero_mul] using Î´pos
  have E2 : âˆ€á¶  h in ğ“[>] (0 : â„), (h : â„) < 1 :=
    mem_nhdsWithin_Ioi_iff_exists_Ioo_subset.2
      âŸ¨(1 : â„), by simp only [mem_Ioi, zero_lt_one], fun x hx => hx.2âŸ©
  filter_upwards [E1, E2, self_mem_nhdsWithin] with h hÎ´ h_lt_1 hpos
  replace hpos : 0 < h := hpos
  have xt_mem : âˆ€ t âˆˆ Icc (0 : â„) 1, x + h â€¢ v + (t * h) â€¢ w âˆˆ interior s := by
    intro t ht
    have : x + h â€¢ v âˆˆ interior s := s_conv.add_smul_mem_interior xs hv âŸ¨hpos, h_lt_1.leâŸ©
    rw [â† smul_smul]
    apply s_conv.interior.add_smul_mem this _ ht
    rw [add_assoc] at hw
    rw [add_assoc, â† smul_add]
    exact s_conv.add_smul_mem_interior xs hw âŸ¨hpos, h_lt_1.leâŸ©
  let g t :=
    f (x + h â€¢ v + (t * h) â€¢ w) - (t * h) â€¢ f' x w - (t * h ^ 2) â€¢ f'' v w -
      ((t * h) ^ 2 / 2) â€¢ f'' w w
  set g' := fun t =>
    f' (x + h â€¢ v + (t * h) â€¢ w) (h â€¢ w) - h â€¢ f' x w - h ^ 2 â€¢ f'' v w - (t * h ^ 2) â€¢ f'' w w
    with hg'
  have g_deriv : âˆ€ t âˆˆ Icc (0 : â„) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by
    intro t ht
    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]
    Â· refine' (hf _ _).comp_hasDerivWithinAt _ _
      Â· exact xt_mem t ht
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.const_add, HasDerivAt.smul_const,
        hasDerivAt_mul_const]
    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· suffices H : HasDerivWithinAt (fun u => ((u * h) ^ 2 / 2) â€¢ f'' w w)
          ((((2 : â„•) : â„) * (t * h) ^ (2 - 1) * (1 * h) / 2) â€¢ f'' w w) (Icc 0 1) t
      Â· convert H using 2
        ring
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_id',
        HasDerivAt.pow, HasDerivAt.mul_const]
  have g'_bound : âˆ€ t âˆˆ Ico (0 : â„) 1, â€–g' tâ€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
    intro t ht
    have I : â€–h â€¢ v + (t * h) â€¢ wâ€– â‰¤ h * (â€–vâ€– + â€–wâ€–) :=
      calc
        â€–h â€¢ v + (t * h) â€¢ wâ€– â‰¤ â€–h â€¢ vâ€– + â€–(t * h) â€¢ wâ€– := norm_add_le _ _
        _ = h * â€–vâ€– + t * (h * â€–wâ€–) := by
          simp only [norm_smul, Real.norm_eq_abs, hpos.le, abs_of_nonneg, abs_mul, ht.left,
            mul_assoc]
        _ â‰¤ h * â€–vâ€– + 1 * (h * â€–wâ€–) := by gcongr; exact ht.2.le
        _ = h * (â€–vâ€– + â€–wâ€–) := by ring
    calc
      â€–g' tâ€– = â€–(f' (x + h â€¢ v + (t * h) â€¢ w) - f' x - f'' (h â€¢ v + (t * h) â€¢ w)) (h â€¢ w)â€– := by
        rw [hg']
        have : h * (t * h) = t * (h * h) := by ring
        simp only [ContinuousLinearMap.coe_sub', ContinuousLinearMap.map_add, pow_two,
          ContinuousLinearMap.add_apply, Pi.smul_apply, smul_sub, smul_add, smul_smul, â† sub_sub,
          ContinuousLinearMap.coe_smul', Pi.sub_apply, ContinuousLinearMap.map_smul, this]
      _ â‰¤ â€–f' (x + h â€¢ v + (t * h) â€¢ w) - f' x - f'' (h â€¢ v + (t * h) â€¢ w)â€– * â€–h â€¢ wâ€– :=
        (ContinuousLinearMap.le_op_norm _ _)
      _ â‰¤ Îµ * â€–h â€¢ v + (t * h) â€¢ wâ€– * â€–h â€¢ wâ€– := by
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        have H : x + h â€¢ v + (t * h) â€¢ w âˆˆ Metric.ball x Î´ âˆ© interior s := by
          refine' âŸ¨_, xt_mem t âŸ¨ht.1, ht.2.leâŸ©âŸ©
          rw [add_assoc, add_mem_ball_iff_norm]
          exact I.trans_lt hÎ´
        simpa only [mem_setOf_eq, add_assoc x, add_sub_cancel'] using sÎ´ H
      _ â‰¤ Îµ * (â€–h â€¢ vâ€– + â€–h â€¢ wâ€–) * â€–h â€¢ wâ€– := by
        gcongr
        apply (norm_add_le _ _).trans
        gcongr
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, ht.1, hpos.le, mul_assoc]
        exact mul_le_of_le_one_left (mul_nonneg hpos.le (norm_nonneg _)) ht.2.le
      _ = Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, hpos.le]; ring
  have I : â€–g 1 - g 0â€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
    simpa only [mul_one, sub_zero] using
      norm_image_sub_le_of_norm_deriv_le_segment' g_deriv g'_bound 1 (right_mem_Icc.2 zero_le_one)
  convert I using 1
  Â· congr 1
    simp only [Nat.one_ne_zero, add_zero, one_mul, zero_div, zero_mul, sub_zero,
      zero_smul, Ne.def, not_false_iff, bit0_eq_zero, zero_pow']
    abel
  Â· simp only [Real.norm_eq_abs, abs_mul, add_nonneg (norm_nonneg v) (norm_nonneg w), abs_of_nonneg,
      hpos.le, mul_assoc, pow_bit0_abs, norm_nonneg, abs_pow]","error:  unexpected token 'Â·'; expected 'by' or 'from'
error:  unsolved goals
case h
E : Type u_1
F : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace â„ E
instâœÂ¹ : NormedAddCommGroup F
instâœ : NormedSpace â„ F
s : Set E
s_conv : Convex â„ s
f : E â†’ F
f' : E â†’ E â†’L[â„] F
f'' : E â†’L[â„] E â†’L[â„] F
hf : âˆ€ x âˆˆ interior s, HasFDerivAt f (f' x) x
x : E
xs : x âˆˆ s
hx : âˆ€ â¦ƒc : â„â¦„, 0 < c â†’ âˆ€á¶  (x_1 : E) in ğ“[interior s] x, â€–f' x_1 - f' x - f'' (x_1 - x)â€– â‰¤ c * â€–x_1 - xâ€–
v w : E
hv : x + v âˆˆ interior s
hw : x + v + w âˆˆ interior s
Îµ : â„
Îµpos : 0 < Îµ
Î´ : â„
Î´pos : Î´ > 0
sÎ´ : Metric.ball x Î´ âˆ© interior s âŠ† {x_1 | (fun x_2 â†¦ â€–f' x_2 - f' x - f'' (x_2 - x)â€– â‰¤ Îµ * â€–x_2 - xâ€–) x_1}
E1 : âˆ€á¶  (h : â„) in ğ“[>] 0, h * (â€–vâ€– + â€–wâ€–) < Î´
E2 : âˆ€á¶  (h : â„) in ğ“[>] 0, h < 1
h : â„
hÎ´ : h * (â€–vâ€– + â€–wâ€–) < Î´
h_lt_1 : h < 1
hpos : 0 < h
xt_mem : âˆ€ t âˆˆ Icc 0 1, x + h â€¢ v + (t * h) â€¢ w âˆˆ interior s
g : â„ â†’ F :=
  fun t â†¦ f (x + h â€¢ v + (t * h) â€¢ w) - (t * h) â€¢ (f' x) w - (t * h ^ 2) â€¢ (f'' v) w - ((t * h) ^ 2 / 2) â€¢ (f'' w) w
g' : â„ â†’ F :=
  fun t â†¦ (f' (x + h â€¢ v + (t * h) â€¢ w)) (h â€¢ w) - h â€¢ (f' x) w - h ^ 2 â€¢ (f'' v) w - (t * h ^ 2) â€¢ (f'' w) w
hg' : g' = fun t â†¦ (f' (x + h â€¢ v + (t * h) â€¢ w)) (h â€¢ w) - h â€¢ (f' x) w - h ^ 2 â€¢ (f'' v) w - (t * h ^ 2) â€¢ (f'' w) w
g_deriv : âˆ€ t âˆˆ Icc 0 1, HasDerivWithinAt g (g' t) (Icc 0 1) t
âŠ¢ â€–f (x + h â€¢ v + h â€¢ w) - f (x + h â€¢ v) - h â€¢ (f' x) w - h ^ 2 â€¢ (f'' v) w - (h ^ 2 / 2) â€¢ (f'' w) wâ€– â‰¤
    Îµ * â€–(â€–vâ€– + â€–wâ€–) * â€–wâ€– * h ^ 2â€–","theorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v âˆˆ interior s)
    (hw : x + v + w âˆˆ interior s) :
    (fun h : â„ => f (x + h â€¢ v + h â€¢ w)
        - f (x + h â€¢ v) - h â€¢ f' x w - h ^ 2 â€¢ f'' v w - (h ^ 2 / 2) â€¢ f'' w w) =o[ğ“[>] 0]
      fun h => h ^ 2 ",":= by
  refine IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun Îµ Îµpos => ?_) (isBigO_const_mul_self ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) _ _)
  rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
  rcases Metric.mem_nhdsWithin_iff.1 (hx Îµpos) with âŸ¨Î´, Î´pos, sÎ´âŸ©
  have E1 : âˆ€á¶  h in ğ“[>] (0 : â„), h * (â€–vâ€– + â€–wâ€–) < Î´ := by
    have : Filter.Tendsto (fun h => h * (â€–vâ€– + â€–wâ€–)) (ğ“[>] (0 : â„)) (ğ“ (0 * (â€–vâ€– + â€–wâ€–))) :=
      (continuous_id.mul continuous_const).continuousWithinAt
    apply (tendsto_order.1 this).2 Î´
    simpa only [zero_mul] using Î´pos
  have E2 : âˆ€á¶  h in ğ“[>] (0 : â„), (h : â„) < 1 :=
    mem_nhdsWithin_Ioi_iff_exists_Ioo_subset.2
      âŸ¨(1 : â„), by simp only [mem_Ioi, zero_lt_one], fun x hx => hx.2âŸ©
  filter_upwards [E1, E2, self_mem_nhdsWithin] with h hÎ´ h_lt_1 hpos
  replace hpos : 0 < h := hpos
  have xt_mem : âˆ€ t âˆˆ Icc (0 : â„) 1, x + h â€¢ v + (t * h) â€¢ w âˆˆ interior s := by
    intro t ht
    have : x + h â€¢ v âˆˆ interior s := s_conv.add_smul_mem_interior xs hv âŸ¨hpos, h_lt_1.leâŸ©
    rw [â† smul_smul]
    apply s_conv.interior.add_smul_mem this _ ht
    rw [add_assoc] at hw
    rw [add_assoc, â† smul_add]
    exact s_conv.add_smul_mem_interior xs hw âŸ¨hpos, h_lt_1.leâŸ©
  let g t :=
    f (x + h â€¢ v + (t * h) â€¢ w) - (t * h) â€¢ f' x w - (t * h ^ 2) â€¢ f'' v w -
      ((t * h) ^ 2 / 2) â€¢ f'' w w
  set g' := fun t =>
    f' (x + h â€¢ v + (t * h) â€¢ w) (h â€¢ w) - h â€¢ f' x w - h ^ 2 â€¢ f'' v w - (t * h ^ 2) â€¢ f'' w w
    with hg'
  have g_deriv : âˆ€ t âˆˆ Icc (0 : â„) 1, HasDerivWithinAt g (g' t) (Icc 0 1) t := by
    intro t ht
    apply_rules [HasDerivWithinAt.sub, HasDerivWithinAt.add]
    Â· refine (hf _ ?_).comp_hasDerivWithinAt _ ?_
      Â· exact xt_mem t ht
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.const_add, HasDerivAt.smul_const,
        hasDerivAt_mul_const]
    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_mul_const]
    Â· suffices H : HasDerivWithinAt (fun u => ((u * h) ^ 2 / 2) â€¢ f'' w w)
          ((((2 : â„•) : â„) * (t * h) ^ (2 - 1) * (1 * h) / 2) â€¢ f'' w w) (Icc 0 1) t by
        convert H using 2
        ring
      apply_rules [HasDerivAt.hasDerivWithinAt, HasDerivAt.smul_const, hasDerivAt_id',
        HasDerivAt.pow, HasDerivAt.mul_const]
  have g'_bound : âˆ€ t âˆˆ Ico (0 : â„) 1, â€–g' tâ€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
    intro t ht
    have I : â€–h â€¢ v + (t * h) â€¢ wâ€– â‰¤ h * (â€–vâ€– + â€–wâ€–) :=
      calc
        â€–h â€¢ v + (t * h) â€¢ wâ€– â‰¤ â€–h â€¢ vâ€– + â€–(t * h) â€¢ wâ€– := norm_add_le _ _
        _ = h * â€–vâ€– + t * (h * â€–wâ€–) := by
          simp only [norm_smul, Real.norm_eq_abs, hpos.le, abs_of_nonneg, abs_mul, ht.left,
            mul_assoc]
        _ â‰¤ h * â€–vâ€– + 1 * (h * â€–wâ€–) := by gcongr; exact ht.2.le
        _ = h * (â€–vâ€– + â€–wâ€–) := by ring
    calc
      â€–g' tâ€– = â€–(f' (x + h â€¢ v + (t * h) â€¢ w) - f' x - f'' (h â€¢ v + (t * h) â€¢ w)) (h â€¢ w)â€– := by
        rw [hg']
        have : h * (t * h) = t * (h * h) := by ring
        simp only [ContinuousLinearMap.coe_sub', ContinuousLinearMap.map_add, pow_two,
          ContinuousLinearMap.add_apply, Pi.smul_apply, smul_sub, smul_add, smul_smul, â† sub_sub,
          ContinuousLinearMap.coe_smul', Pi.sub_apply, ContinuousLinearMap.map_smul, this]
      _ â‰¤ â€–f' (x + h â€¢ v + (t * h) â€¢ w) - f' x - f'' (h â€¢ v + (t * h) â€¢ w)â€– * â€–h â€¢ wâ€– :=
        (ContinuousLinearMap.le_opNorm _ _)
      _ â‰¤ Îµ * â€–h â€¢ v + (t * h) â€¢ wâ€– * â€–h â€¢ wâ€– := by
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        have H : x + h â€¢ v + (t * h) â€¢ w âˆˆ Metric.ball x Î´ âˆ© interior s := by
          refine âŸ¨?_, xt_mem t âŸ¨ht.1, ht.2.leâŸ©âŸ©
          rw [add_assoc, add_mem_ball_iff_norm]
          exact I.trans_lt hÎ´
        simpa only [mem_setOf_eq, add_assoc x, add_sub_cancel_left] using sÎ´ H
      _ â‰¤ Îµ * (â€–h â€¢ vâ€– + â€–h â€¢ wâ€–) * â€–h â€¢ wâ€– := by
        gcongr
        apply (norm_add_le _ _).trans
        gcongr
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, ht.1, hpos.le, mul_assoc]
        exact mul_le_of_le_one_left (mul_nonneg hpos.le (norm_nonneg _)) ht.2.le
      _ = Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
        simp only [norm_smul, Real.norm_eq_abs, abs_mul, abs_of_nonneg, hpos.le]; ring
  have I : â€–g 1 - g 0â€– â‰¤ Îµ * ((â€–vâ€– + â€–wâ€–) * â€–wâ€–) * h ^ 2 := by
    simpa only [mul_one, sub_zero] using
      norm_image_sub_le_of_norm_deriv_le_segment' g_deriv g'_bound 1 (right_mem_Icc.2 zero_le_one)
  convert I using 1
  Â· congr 1
    simp only [g, Nat.one_ne_zero, add_zero, one_mul, zero_div, zero_mul, sub_zero,
      zero_smul, Ne, not_false_iff, bit0_eq_zero, zero_pow]
    abel
  Â· simp only [Real.norm_eq_abs, abs_mul, add_nonneg (norm_nonneg v) (norm_nonneg w), abs_of_nonneg,
      hpos.le, mul_assoc, norm_nonneg, abs_pow]","simp only [Convex.taylor_approx_two_segment, Convex.taylor_approx_two_segment]"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.cons_append,cons_append,938069ac7c83a4980c46ca108d9947ab788c12ee,":=
  Seq'.cons_append _ _ _",error:  unknown identifier 'Seq'.cons_append',theorem cons_append (a : Î±) (s t) : append (cons a s) t = cons a (append s t) ,":=
  Seq.cons_append _ _ _","rw [cons_append, append, cons_append, append, cons_cons, cons_append, cons_append, cons_cons,
  cons_append, append, cons_append, append, append, append, append, append, append, append,
  cons_append, append, append, append, append, append, append, cons_append, append, append,
  append, append, append, append, append, append, append, append, append, append, append,
  cons_append, append, append, append, append, append, append, cons_append, append, append,
  append, append, append, append, append, append, append, append, append, append, append,
  cons_append, append, append, append, append, append, append, append, cons_append, append,
  cons_cons_append, append, append, append, append, append, append, append, append, append,
  append, append, append, append, append, append, append, append, append, append, append,
  cons_append, append, append, append, append, append, append, append, append, append,
  cons_append, append, append, append, append, append, append, append, append, append,
  cons_append, append, append, append, append, append, append, append, append]"
Mathlib/Algebra/Polynomial/Smeval.lean,Polynomial.smeval_at_natCast,smeval_at_natCast,25e538f3a737a71314ac143929711e67d0b14d73,":= by
  induction q with
  | h_add p q ph qh =>
    intro n
    simp only [add_mul, smeval_add, ph, qh, Nat.cast_add]
  | h_monomial n a =>
    intro n
    rw [smeval_monomial, smeval_monomial, nsmul_eq_mul, smul_eq_mul, Nat.cast_mul, Nat.cast_npow]",error:  invalid alternative name 'h_add',"theorem smeval_at_natCast (q : â„•[X]): âˆ€(n : â„•), q.smeval (n : S) = q.smeval n ",":= by
  induction q using Polynomial.induction_on' with
  | h_add p q ph qh =>
    intro n
    simp only [add_mul, smeval_add, ph, qh, Nat.cast_add]
  | h_monomial n a =>
    intro n
    rw [smeval_monomial, smeval_monomial, nsmul_eq_mul, smul_eq_mul, Nat.cast_mul, Nat.cast_npow]","simp only [smeval_at_natCast, smeval_smeval_at_natCast]"
Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean,SimpleGraph.isAdjMatrix_adjMatrix,isAdjMatrix_adjMatrix,be491e5ccecbea382c9ac5db0917dea23fb40bc5,":=
  { zero_or_one := fun i j => by by_cases Adj G i j <;> dsimp at h <;> simp [h] }","error:  unknown identifier 'h'
error:  unknown identifier 'h'
error:  unknown identifier 'h'
error:  unknown identifier 'h'
error:  unsolved goals
case pos
V : Type u_1
Î± : Type u_2
Î² : Type u_3
G : SimpleGraph V
instâœÂ² : DecidableRel G.Adj
instâœÂ¹ : Zero Î±
instâœ : One Î±
i j : V
hâœ : G.Adj i j
âŠ¢ (G.Adj i j â†’ 1 = 0) âˆ¨ (Â¬G.Adj i j â†’ 0 = 1)

case neg
V : Type u_1
Î± : Type u_2
Î² : Type u_3
G : SimpleGraph V
instâœÂ² : DecidableRel G.Adj
instâœÂ¹ : Zero Î±
instâœ : One Î±
i j : V
hâœ : Â¬G.Adj i j
âŠ¢ (G.Adj i j â†’ 1 = 0) âˆ¨ (Â¬G.Adj i j â†’ 0 = 1)",theorem isAdjMatrix_adjMatrix [Zero Î±] [One Î±] : (G.adjMatrix Î±).IsAdjMatrix ,":=
  { zero_or_one := fun i j => by by_cases h : G.Adj i j <;> simp [h] }",simp [isAdjMatrix_adjMatrix]
Mathlib/Order/Interval/Finset/Fin.lean,Fin.map_valEmbedding_Ici,map_valEmbedding_Ici,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  clear b
  ext x
  simp only [exists_prop, Embedding.coe_subtype, mem_Ici, mem_map, mem_Icc]
  constructor
  Â· rintro âŸ¨x, hx, rflâŸ©
    exact âŸ¨hx, le_tsub_of_add_le_right <| x.2âŸ©
  cases n
  Â· exact Fin.elim0 a
  Â· exact fun hx => âŸ¨âŸ¨x, Nat.lt_succ_iff.2 hx.2âŸ©, hx.1, rflâŸ©","error:  failed to synthesize
  OrderedSub â„•
use `set_option diagnostics true` to get diagnostic information",theorem map_valEmbedding_Ici : (Ici a).map Fin.valEmbedding = Icc â†‘a (n - 1) ,":= by
  clear b
  ext x
  simp only [exists_prop, Embedding.coe_subtype, mem_Ici, mem_map, mem_Icc]
  constructor
  Â· rintro âŸ¨x, hx, rflâŸ©
    exact âŸ¨hx, Nat.le_sub_of_add_le <| x.2âŸ©
  cases n
  Â· exact Fin.elim0 a
  Â· exact fun hx => âŸ¨âŸ¨x, Nat.lt_succ_iff.2 hx.2âŸ©, hx.1, rflâŸ©",rw [map_valEmbedding_Ici]
Mathlib/MeasureTheory/Constructions/Polish.lean,MeasureTheory.AnalyticSet.iUnion,AnalyticSet.iUnion,62d1e98c9775031911b945f049f84047fafbe5e1,":= by
  choose Î² hÎ² h'Î² f f_cont f_range using fun n =>
    analyticSet_iff_exists_polishSpace_range.1 (hs n)
  let Î³ := Î£n, Î² n
  let F : Î³ â†’ Î± := fun âŸ¨n, xâŸ© â†¦ f n x
  have F_cont : Continuous F := continuous_sigma f_cont
  have F_range : range F = â‹ƒ n, s n := by
    simp only [range_sigma_eq_iUnion_range, f_range]
  rw [â† F_range]
  exact analyticSet_range_of_polishSpace F_cont",error:  simp made no progress,"theorem AnalyticSet.iUnion [Countable Î¹] {s : Î¹ â†’ Set Î±} (hs : âˆ€ n, AnalyticSet (s n)) :
    AnalyticSet (â‹ƒ n, s n) ",":= by
  choose Î² hÎ² h'Î² f f_cont f_range using fun n =>
    analyticSet_iff_exists_polishSpace_range.1 (hs n)
  let Î³ := Î£n, Î² n
  let F : Î³ â†’ Î± := fun âŸ¨n, xâŸ© â†¦ f n x
  have F_cont : Continuous F := continuous_sigma f_cont
  have F_range : range F = â‹ƒ n, s n := by
    simp only [Î³, range_sigma_eq_iUnion_range, f_range]
  rw [â† F_range]
  exact analyticSet_range_of_polishSpace F_cont",refine AnalyticSet.iUnion_iUnion_of_analyticSet (fun n â†¦ s n) ?_
Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean,PrimeSpectrum.vanishingIdeal_irreducibleComponents,vanishingIdeal_irreducibleComponents,1833c6e43f5f2d80bf844f5bdf73c2f504fbdf8f,":= by
  rw [irreducibleComponents_eq_maximals_closed]
  simp_rw [IsIrreducibleClosed, and_comm]
  rw [minimalPrimes_eq_minimals, â† minimals_swap,
    â† PrimeSpectrum.vanishingIdeal_isClosed_isIrreducible, image_minimals_of_rel_iff_rel]
  exact fun s t hs _ â†¦ vanishingIdeal_anti_mono_iff hs.1","error:  unknown identifier 'IsIrreducibleClosed'
error:  simp made no progress","lemma vanishingIdeal_irreducibleComponents :
    vanishingIdeal '' (irreducibleComponents <| PrimeSpectrum R) =
    minimalPrimes R ",":= by
  rw [irreducibleComponents_eq_maximals_closed, minimalPrimes_eq_minimals, â† minimals_swap,
    â† PrimeSpectrum.vanishingIdeal_isClosed_isIrreducible, image_minimals_of_rel_iff_rel]
  exact fun s t hs _ â†¦ vanishingIdeal_anti_mono_iff hs.1",rw [minimalPrimes_eq_minimalPrimes]
Mathlib/Probability/Martingale/Convergence.lean,MeasureTheory.Submartingale.upcrossings_ae_lt_top,Submartingale.upcrossings_ae_lt_top,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  refine' ae_lt_top (hf.adapted.measurable_upcrossings hab) _
  have := hf.mul_lintegral_upcrossings_le_lintegral_pos_part a b
  rw [mul_comm, â† ENNReal.le_div_iff_mul_le] at this
  Â· refine' (lt_of_le_of_lt this (ENNReal.div_lt_top _ _)).ne
    Â· have hR' : âˆ€ n, âˆ«â» Ï‰, â€–f n Ï‰ - aâ€–â‚Š âˆ‚Î¼ â‰¤ R + â€–aâ€–â‚Š * Î¼ Set.univ := by
        simp_rw [snorm_one_eq_lintegral_nnnorm] at hbdd
        intro n
        refine' (lintegral_mono _ : âˆ«â» Ï‰, â€–f n Ï‰ - aâ€–â‚Š âˆ‚Î¼ â‰¤ âˆ«â» Ï‰, â€–f n Ï‰â€–â‚Š + â€–aâ€–â‚Š âˆ‚Î¼).trans _
        Â· intro Ï‰
          simp_rw [sub_eq_add_neg, â† nnnorm_neg a, â† ENNReal.coe_add, ENNReal.coe_le_coe]
          exact nnnorm_add_le _ _
        Â· simp_rw [lintegral_add_right _ measurable_const, lintegral_const]
          exact add_le_add (hbdd _) le_rfl
      refine' ne_of_lt (iSup_lt_iff.2 âŸ¨R + â€–aâ€–â‚Š * Î¼ Set.univ, ENNReal.add_lt_top.2
        âŸ¨ENNReal.coe_lt_top, ENNReal.mul_lt_top ENNReal.coe_lt_top.ne (measure_ne_top _ _)âŸ©,
        fun n => le_trans _ (hR' n)âŸ©)
      refine' lintegral_mono fun Ï‰ => _
      rw [ENNReal.ofReal_le_iff_le_toReal, ENNReal.coe_toReal, coe_nnnorm]
      by_cases hnonneg : 0 â‰¤ f n Ï‰ - a
      Â· rw [LatticeOrderedCommGroup.pos_of_nonneg _ hnonneg, Real.norm_eq_abs,
          abs_of_nonneg hnonneg]
      Â· rw [LatticeOrderedCommGroup.pos_of_nonpos _ (not_le.1 hnonneg).le]
        exact norm_nonneg _
      Â· simp only [Ne.def, ENNReal.coe_ne_top, not_false_iff]
    Â· simp only [hab, Ne.def, ENNReal.ofReal_eq_zero, sub_nonpos, not_le]
  Â· simp only [hab, Ne.def, ENNReal.ofReal_eq_zero, sub_nonpos, not_le, true_or_iff]
  Â· simp only [Ne.def, ENNReal.ofReal_ne_top, not_false_iff, true_or_iff]","error:  unknown identifier 'LatticeOrderedCommGroup.pos_of_nonneg'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.15362
case pos
Î© : Type u_1
Î¹ : Type u_2
m0 : MeasurableSpace Î©
Î¼ : Measure Î©
â„± : Filtration â„• m0
a b : â„
f : â„• â†’ Î© â†’ â„
Ï‰âœ : Î©
R : â„â‰¥0
instâœ : IsFiniteMeasure Î¼
hf : Submartingale f â„± Î¼
hbdd : âˆ€ (n : â„•), snorm (f n) 1 Î¼ â‰¤ â†‘R
hab : a < b
this : âˆ«â» (Ï‰ : Î©), upcrossings a b f Ï‰ âˆ‚Î¼ â‰¤ (â¨† N, âˆ«â» (Ï‰ : Î©), ENNReal.ofReal (f N Ï‰ - a)âº âˆ‚Î¼) / ENNReal.ofReal (b - a)
hR' : âˆ€ (n : â„•), âˆ«â» (Ï‰ : Î©), â†‘â€–f n Ï‰ - aâ€–â‚Š âˆ‚Î¼ â‰¤ â†‘R + â†‘â€–aâ€–â‚Š * Î¼ Set.univ
n : â„•
Ï‰ : Î©
hnonneg : 0 â‰¤ f n Ï‰ - a
âŠ¢ (f n Ï‰ - a)âº â‰¤ â€–f n Ï‰ - aâ€–
error:  unknown identifier 'LatticeOrderedCommGroup.pos_of_nonpos'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.15364
case neg
Î© : Type u_1
Î¹ : Type u_2
m0 : MeasurableSpace Î©
Î¼ : Measure Î©
â„± : Filtration â„• m0
a b : â„
f : â„• â†’ Î© â†’ â„
Ï‰âœ : Î©
R : â„â‰¥0
instâœ : IsFiniteMeasure Î¼
hf : Submartingale f â„± Î¼
hbdd : âˆ€ (n : â„•), snorm (f n) 1 Î¼ â‰¤ â†‘R
hab : a < b
this : âˆ«â» (Ï‰ : Î©), upcrossings a b f Ï‰ âˆ‚Î¼ â‰¤ (â¨† N, âˆ«â» (Ï‰ : Î©), ENNReal.ofReal (f N Ï‰ - a)âº âˆ‚Î¼) / ENNReal.ofReal (b - a)
hR' : âˆ€ (n : â„•), âˆ«â» (Ï‰ : Î©), â†‘â€–f n Ï‰ - aâ€–â‚Š âˆ‚Î¼ â‰¤ â†‘R + â†‘â€–aâ€–â‚Š * Î¼ Set.univ
n : â„•
Ï‰ : Î©
hnonneg : Â¬0 â‰¤ f n Ï‰ - a
âŠ¢ (f n Ï‰ - a)âº â‰¤ â€–f n Ï‰ - aâ€–
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.15379 â†’ ?m.15379 â†’ Prop
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.15500 â†’ ?m.15500 â†’ Prop
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.15618 â†’ ?m.15618 â†’ Prop
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.15801 â†’ ?m.15801 â†’ Prop
error:  simp made no progress","theorem Submartingale.upcrossings_ae_lt_top' [IsFiniteMeasure Î¼] (hf : Submartingale f â„± Î¼)
    (hbdd : âˆ€ n, snorm (f n) 1 Î¼ â‰¤ R) (hab : a < b) : âˆ€áµ Ï‰ âˆ‚Î¼, upcrossings a b f Ï‰ < âˆ ",":= by
  refine ae_lt_top (hf.adapted.measurable_upcrossings hab) ?_
  have := hf.mul_lintegral_upcrossings_le_lintegral_pos_part a b
  rw [mul_comm, â† ENNReal.le_div_iff_mul_le] at this
  Â· refine (lt_of_le_of_lt this (ENNReal.div_lt_top ?_ ?_)).ne
    Â· have hR' : âˆ€ n, âˆ«â» Ï‰, â€–f n Ï‰ - aâ€–â‚Š âˆ‚Î¼ â‰¤ R + â€–aâ€–â‚Š * Î¼ Set.univ := by
        simp_rw [snorm_one_eq_lintegral_nnnorm] at hbdd
        intro n
        refine (lintegral_mono ?_ : âˆ«â» Ï‰, â€–f n Ï‰ - aâ€–â‚Š âˆ‚Î¼ â‰¤ âˆ«â» Ï‰, â€–f n Ï‰â€–â‚Š + â€–aâ€–â‚Š âˆ‚Î¼).trans ?_
        Â· intro Ï‰
          simp_rw [sub_eq_add_neg, â† nnnorm_neg a, â† ENNReal.coe_add, ENNReal.coe_le_coe]
          exact nnnorm_add_le _ _
        Â· simp_rw [lintegral_add_right _ measurable_const, lintegral_const]
          exact add_le_add (hbdd _) le_rfl
      refine ne_of_lt (iSup_lt_iff.2 âŸ¨R + â€–aâ€–â‚Š * Î¼ Set.univ, ENNReal.add_lt_top.2
        âŸ¨ENNReal.coe_lt_top, ENNReal.mul_lt_top ENNReal.coe_lt_top.ne (measure_ne_top _ _)âŸ©,
        fun n => le_trans ?_ (hR' n)âŸ©)
      refine lintegral_mono fun Ï‰ => ?_
      rw [ENNReal.ofReal_le_iff_le_toReal, ENNReal.coe_toReal, coe_nnnorm]
      Â· by_cases hnonneg : 0 â‰¤ f n Ï‰ - a
        Â· rw [posPart_eq_self.2 hnonneg, Real.norm_eq_abs, abs_of_nonneg hnonneg]
        Â· rw [posPart_eq_zero.2 (not_le.1 hnonneg).le]
          exact norm_nonneg _
      Â· simp only [Ne, ENNReal.coe_ne_top, not_false_iff]
    Â· simp only [hab, Ne, ENNReal.ofReal_eq_zero, sub_nonpos, not_le]
  Â· simp only [hab, Ne, ENNReal.ofReal_eq_zero, sub_nonpos, not_le, true_or_iff]
  Â· simp only [Ne, ENNReal.ofReal_ne_top, not_false_iff, true_or_iff]",rw [upcrossings_ae_lt_top']
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow,discr_prime_pow,8802cc5585f54b80097a016895ed9e54bf69d452,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hÎ¶.powerBasis_gen _, â†
    hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : â„•+) : â„•) = 2 := rfl
  have hp2 : p = 2 â†’ k â‰  0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  Â· rcases eq_or_ne p 2 with (rfl | hp2)
    Â· rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with âŸ¨k, rflâŸ©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      Â· simp
      Â· norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    Â· replace hp2 : (p : â„•) â‰  2
      Â· rwa [Ne.def, â† coe_two, PNat.coe_inj]
      have hpo : Odd (p : â„•) := hp.out.odd_of_ne_two hp2
      obtain âŸ¨a, haâŸ© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, â† ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  Â· have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, â† PNat.pow_coe,
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Î¶ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Î¶ ^ (p : â„•) ^ k - 1) = (p : K) ^ (p : â„•) ^ k := by
      by_cases hp : p = 2
      Â· exact mod_cast hÎ¶.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      Â· exact mod_cast hÎ¶.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, â† map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, â† succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hÎ¶.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, â† pow_mul, â† mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [â† succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : â„•) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    Â· simp only [H, mul_comm _ (k + 1)]; norm_cast
    Â· 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by linarith)] at this
      exact absurd (pow_eq_zero h) this","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case e_a.inr
p : â„•+
k : â„•
K : Type u
L : Type v
Î¶ : L
instâœÂ³ : Field K
instâœÂ² : Field L
instâœÂ¹ : Algebra K L
instâœ : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime â†‘p)
hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))
hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1))) K)
hk : p ^ (k + 1) â‰  2
hne : NeZero â†‘â†‘(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : â†‘2 = 2
hp2âœ : p = 2 â†’ k â‰  0
hp2 : â†‘p â‰  2
âŠ¢ (-1) ^ (â†‘p ^ k * (â†‘p - 1) * (â†‘p ^ k * (â†‘p - 1) - 1) / 2) = (-1) ^ (â†‘p ^ k * (â†‘p - 1) / 2)
error:  unsolved goals
case e_a
p : â„•+
k : â„•
K : Type u
L : Type v
Î¶ : L
instâœÂ³ : Field K
instâœÂ² : Field L
instâœÂ¹ : Algebra K L
instâœ : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime â†‘p)
hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))
hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1))) K)
hk : p ^ (k + 1) â‰  2
hne : NeZero â†‘â†‘(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : â†‘2 = 2
hp2 : p = 2 â†’ k â‰  0
âŠ¢ (Algebra.norm K) ((aeval Î¶) (derivative (cyclotomic (â†‘p ^ (k + 1)) K))) = â†‘â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : â„•).Prime]
    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1)) : â„•) K))
    (hk : p ^ (k + 1) â‰  2) : discr K (hÎ¶.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : â„•).totient / 2) * p ^ ((p : â„•) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hÎ¶.powerBasis_gen _, â†
    hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : â„•+) : â„•) = 2 := rfl
  have hp2 : p = 2 â†’ k â‰  0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  Â· rcases eq_or_ne p 2 with (rfl | hp2)
    Â· rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with âŸ¨k, rflâŸ©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      Â· simp
      Â· simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    Â· replace hp2 : (p : â„•) â‰  2 := by rwa [Ne, â† coe_two, PNat.coe_inj]
      have hpo : Odd (p : â„•) := hp.out.odd_of_ne_two hp2
      obtain âŸ¨a, haâŸ© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, â† ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  Â· have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, â† PNat.pow_coe,
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Î¶ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Î¶ ^ (p : â„•) ^ k - 1) = (p : K) ^ (p : â„•) ^ k := by
      by_cases hp : p = 2
      Â· exact mod_cast hÎ¶.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      Â· exact mod_cast hÎ¶.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, â† map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, â† succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hÎ¶.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, â† pow_mul, â† mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [â† succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : â„•) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    Â· simp only [H, mul_comm _ (k + 1)]; norm_cast
    Â· 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this","have : Irreducible (cyclotomic (p ^ (k + 1) : â„•) K) := by
  have : Irreducible (cyclotomic (p ^ (k + 1) : â„•) K) :=
    Irreducible.cyclotomic.irreducible_cyclotomic_irreducible_factor hp.out K hirr"
Mathlib/Analysis/InnerProductSpace/Basic.lean,inner_mul_inner_self_le,inner_mul_inner_self_le,e46faedbd6353e165e5a0da6768aa2e7bd75f6d4,":= by
  have hdiscrim : âˆ€ (t : â„), 0 â‰¤ normSqF x * t * t  + 2 * â€–âŸªx, yâŸ«â€– * t + normSqF y := by
    intro t
    by_cases hzero : âŸªx, yâŸ« = 0
    Â· rw [hzero]
      simp only [norm_zero, mul_zero, zero_mul, add_zero]
      apply add_nonneg
      Â· rw [mul_assoc, â† sq, normSq]
        exact mul_nonneg inner_self_nonneg (sq_nonneg t)
      Â· rw [normSq]
        exact inner_self_nonneg
    Â· push_neg at hzero
      rw [â† norm_ne_zero_iff] at hzero
      have htxy: 0 â‰¤ normSqF (âŸªx,yâŸ« â€¢ x) * (t / â€–âŸªx,yâŸ«â€–) * (t / â€–âŸªx,yâŸ«â€–)
          + 2 * re âŸªâŸªx,yâŸ« â€¢ x, yâŸ« * (t / â€–âŸªx,yâŸ«â€–) + normSqF y := by
        exact cauchy_schwarz_aux (âŸªx,yâŸ« â€¢ x) y (t/â€–âŸªx,yâŸ«â€–)
      rw [inner_smul_left, RCLike.conj_mul, sq, â† RCLike.ofReal_mul, RCLike.ofReal_re, normSq,
        inner_smul_left, inner_smul_right, â† mul_assoc, RCLike.conj_mul, sq, â† RCLike.ofReal_mul]
        at htxy
      simp only [ofReal_mul, mul_re, ofReal_re, ofReal_im, mul_zero, sub_zero, mul_im, zero_mul,
        add_zero] at htxy
      rw [normSq, normSq]
      have : 0 â‰¤ â€–âŸªx, yâŸ«â€– / â€–âŸªx, yâŸ«â€– * â€–âŸªx, yâŸ«â€– / â€–âŸªx, yâŸ«â€– * re âŸªx, xâŸ« * t * t +
          â€–âŸªx, yâŸ«â€– / â€–âŸªx, yâŸ«â€– * 2 * â€–âŸªx, yâŸ«â€– * t + normSqF y := by
        calc 0 â‰¤ â€–âŸªx, yâŸ«â€– * â€–âŸªx, yâŸ«â€– * re âŸªx, xâŸ« * (t / â€–âŸªx, yâŸ«â€–) * (t / â€–âŸªx, yâŸ«â€–) +
          2 * (â€–âŸªx, yâŸ«â€– * â€–âŸªx, yâŸ«â€–) * (t / â€–âŸªx, yâŸ«â€–) + normSq y := htxy
          _ = â€–âŸªx, yâŸ«â€– / â€–âŸªx, yâŸ«â€– * â€–âŸªx, yâŸ«â€– / â€–âŸªx, yâŸ«â€– * re âŸªx, xâŸ« * t * t +
          â€–âŸªx, yâŸ«â€– / â€–âŸªx, yâŸ«â€– * 2* â€–âŸªx, yâŸ«â€– * t + normSq y := by ring
      rw [div_self hzero, one_mul, one_mul, div_self hzero, one_mul] at this
      exact this
  have hnegdiscrim : (2 * â€–âŸªx, yâŸ«â€–)^2 - 4 * normSqF x * normSqF y â‰¤ 0 := by
    rw [â† discrim]
    exact discrim_le_zero hdiscrim
  rw [normSq, normSq, sq] at hnegdiscrim
  nth_rw 1 [norm_inner_symm x y] at hnegdiscrim
  linarith","error:  function expected at
  cauchy_schwarz_aux (âŸªx, yâŸ«_ğ•œ â€¢ x) y
term has type
  normSq (âŸªâŸªx, yâŸ«_ğ•œ â€¢ x, yâŸ«_?m.110795 â€¢ âŸªx, yâŸ«_ğ•œ â€¢ x - âŸªâŸªx, yâŸ«_ğ•œ â€¢ x, âŸªx, yâŸ«_ğ•œ â€¢ xâŸ«_?m.110795 â€¢ y) =
    normSq (âŸªx, yâŸ«_ğ•œ â€¢ x) * (normSq (âŸªx, yâŸ«_ğ•œ â€¢ x) * normSq y - â€–âŸªâŸªx, yâŸ«_ğ•œ â€¢ x, yâŸ«_?m.110795â€– ^ 2)
error:  unknown identifier 'discrim'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.120075
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœÂ² : _root_.RCLike ğ•œ
instâœÂ¹ : AddCommGroup F
instâœ : Module ğ•œ F
c : Core ğ•œ F
x y : F
hdiscrim : âˆ€ (t : â„), 0 â‰¤ normSq x * t * t + 2 * â€–âŸªx, yâŸ«_ğ•œâ€– * t + normSq y
âŠ¢ (2 * â€–âŸªx, yâŸ«_ğ•œâ€–) ^ 2 - 4 * normSq x * normSq y â‰¤ 0","theorem inner_mul_inner_self_le (x y : F) : â€–âŸªx, yâŸ«â€– * â€–âŸªy, xâŸ«â€– â‰¤ re âŸªx, xâŸ« * re âŸªy, yâŸ« ",":= by
  rcases eq_or_ne x 0 with (rfl | hx)
  Â· simpa only [inner_zero_left, map_zero, zero_mul, norm_zero] using le_rfl
  Â· have hx' : 0 < normSqF x := inner_self_nonneg.lt_of_ne' (mt normSq_eq_zero.1 hx)
    rw [â† sub_nonneg, â† mul_nonneg_iff_right_nonneg_of_pos hx', â† normSq, â† normSq,
      norm_inner_symm y, â† sq, â† cauchy_schwarz_aux]
    exact inner_self_nonneg","have : â€–âŸªx, yâŸ«â€– â‰¤ â€–âŸªy, xâŸ«â€– * â€–âŸªy, yâŸ«â€– * â€–âŸªy, yâŸ«â€– := by
  rw [â† inner_mul_inner_self_le, â† inner_mul_inner_self_le, â† inner_mul_inner_self_le,
    â† inner_mul_inner_self_le, â† inner_mul_inner_self_le, â† inner_mul_inner_self_le,
    â† inner_mul_inner_self_le, â† inner_mul_inner_self_le, â† inner_mul_inner_self_le,
    â† inner_mul_inner_self_le, â† inner_mul_inner_self_le, â† inner_mul_inner_self_le,
    â† inner_mul_inner_self_le, â† inner_mul_inner_self_le, â† inner_mul_inner_self_le,
    â† inner_mul_inner_self_le, â† inner_mul_inner_self_le, â† inner_mul_inner_self_le,
    â† inner_mul_inner_self_le, â† inner_mul_inner_self_le, â† inner_mul_inner_self_le,
    â† inner_mul_inner_self_le, â† inner_mul_inner_self_le, â† inner_mul_inner_self_le,
    â† inner_mul_inner_self_le, â† inner_mul_inner_self_le, â† inner_mul_inner_self_le,
    â† inner_mul_inner_self_le, â† inner_mul_inner_self_le, â† inner_mul_inner_self_le,
    â† inner_mul_inner_self_le, â† inner_mul_inner_self_le, â† inner_mul_inner_self_le,
    â† inner_mul_inner_self_le, â† inner_mul_inner_self_le, â† inner_mul_inner_self_le,
    â† inner_mul_inner_self_le, â† inner_mul_inner_self_le, â† inner_mul_inner_self_le]"
Mathlib/Topology/Algebra/StarSubalgebra.lean,StarSubalgebra.closedEmbedding_inclusion,closedEmbedding_inclusion,20100f1475ea197bf6dea643b6ee137219455a51,":=
  { embedding_inclusion h with
    closed_range := isClosed_induced_iff.2
      âŸ¨Sâ‚, hSâ‚, by
          convert(Set.range_subtype_map id _).symm
          Â· rw [Set.image_id]; rfl
          Â· intro _ h'
            apply h h' âŸ© }",error:  'closed_range' is not a field of structure 'ClosedEmbedding',"theorem closedEmbedding_inclusion {Sâ‚ Sâ‚‚ : StarSubalgebra R A} (h : Sâ‚ â‰¤ Sâ‚‚)
    (hSâ‚ : IsClosed (Sâ‚ : Set A)) : ClosedEmbedding (inclusion h) ",":=
  { embedding_inclusion h with
    isClosed_range := isClosed_induced_iff.2
      âŸ¨Sâ‚, hSâ‚, by
          convert (Set.range_subtype_map id _).symm
          Â· rw [Set.image_id]; rfl
          Â· intro _ h'
            apply h h' âŸ© }",have hSâ‚‚ : IsClosed (inclusion h) := hSâ‚.isClosed_closedEmbedding
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.TauPackage.color_lt,color_lt,151feca7cd329a83c958aa6af46cb01fabc83bf1,":= by
  induction' i using Ordinal.induction with i IH
  let A : Set â„• :=
    â‹ƒ (j : { j // j < i })
      (_ : (closedBall (p.c (p.index j)) (p.r (p.index j)) âˆ©
        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty),
      {p.color j}
  have color_i : p.color i = sInf (univ \ A) := by rw [color]
  rw [color_i]
  have N_mem : N âˆˆ univ \ A := by
    simp only [not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff, mem_closedBall,
      not_and, mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]
    intro j ji _
    exact (IH j ji (ji.trans hi)).ne'
  suffices sInf (univ \ A) â‰  N by
    rcases (csInf_le (OrderBot.bddBelow (univ \ A)) N_mem).lt_or_eq with (H | H)
    Â· exact H
    Â· exact (this H).elim
  intro Inf_eq_N
  have :
    âˆ€ k, k < N â†’ âˆƒ j, j < i âˆ§
      (closedBall (p.c (p.index j)) (p.r (p.index j)) âˆ©
        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty âˆ§ k = p.color j := by
    intro k hk
    rw [â† Inf_eq_N] at hk
    have : k âˆˆ A := by
      simpa only [true_and_iff, mem_univ, Classical.not_not, mem_diff] using
        Nat.not_mem_of_lt_sInf hk
    simp only [mem_iUnion, mem_singleton_iff, exists_prop, Subtype.exists, exists_and_right,
      and_assoc] at this
    simpa only [exists_prop, mem_iUnion, mem_singleton_iff, mem_closedBall, Subtype.exists,
      Subtype.coe_mk]
  choose! g hg using this
  let G : â„• â†’ Ordinal := fun n => if n = N then i else g n
  have color_G : âˆ€ n, n â‰¤ N â†’ p.color (G n) = n := by
    intro n hn
    rcases hn.eq_or_lt with (rfl | H)
    Â· simp only; simp only [color_i, Inf_eq_N, if_true, eq_self_iff_true]
    Â· simp only; simp only [H.ne, (hg n H).right.right.symm, if_false]
  have G_lt_last : âˆ€ n, n â‰¤ N â†’ G n < p.lastStep := by
    intro n hn
    rcases hn.eq_or_lt with (rfl | H)
    Â· simp only; simp only [hi, if_true, eq_self_iff_true]
    Â· simp only; simp only [H.ne, (hg n H).left.trans hi, if_false]
  have fGn :
      âˆ€ n, n â‰¤ N â†’
        p.c (p.index (G n)) âˆ‰ p.iUnionUpTo (G n) âˆ§ p.R (G n) â‰¤ p.Ï„ * p.r (p.index (G n)) := by
    intro n hn
    have :
      p.index (G n) =
        Classical.epsilon fun t => p.c t âˆ‰ p.iUnionUpTo (G n) âˆ§ p.R (G n) â‰¤ p.Ï„ * p.r t :=
      by rw [index]; rfl
    rw [this]
    have : âˆƒ t, p.c t âˆ‰ p.iUnionUpTo (G n) âˆ§ p.R (G n) â‰¤ p.Ï„ * p.r t := by
      simpa only [not_exists, exists_prop, not_and, not_lt, not_le, mem_setOf_eq, not_forall] using
        not_mem_of_lt_csInf (G_lt_last n hn) (OrderBot.bddBelow _)
    exact Classical.epsilon_spec this
  have Gab :
    âˆ€ a b : Fin (Nat.succ N),
      G a < G b â†’
        p.r (p.index (G a)) â‰¤ dist (p.c (p.index (G a))) (p.c (p.index (G b))) âˆ§
          p.r (p.index (G b)) â‰¤ p.Ï„ * p.r (p.index (G a)) := by
    intro a b G_lt
    have ha : (a : â„•) â‰¤ N := Nat.lt_succ_iff.1 a.2
    have hb : (b : â„•) â‰¤ N := Nat.lt_succ_iff.1 b.2
    constructor
    Â· have := (fGn b hb).1
      simp only [iUnionUpTo, not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_le,
        Subtype.exists, Subtype.coe_mk] at this
      simpa only [dist_comm, mem_ball, not_lt] using this (G a) G_lt
    Â· apply le_trans _ (fGn a ha).2
      have B : p.c (p.index (G b)) âˆ‰ p.iUnionUpTo (G a) := by
        intro H; exact (fGn b hb).1 (p.monotone_iUnionUpTo G_lt.le H)
      let b' : { t // p.c t âˆ‰ p.iUnionUpTo (G a) } := âŸ¨p.index (G b), BâŸ©
      apply @le_ciSup _ _ _ (fun t : { t // p.c t âˆ‰ p.iUnionUpTo (G a) } => p.r t) _ b'
      refine' âŸ¨p.r_bound, fun t ht => _âŸ©
      simp only [exists_prop, mem_range, Subtype.exists, Subtype.coe_mk] at ht
      rcases ht with âŸ¨u, huâŸ©
      rw [â† hu.2]
      exact p.r_le _
  let sc : SatelliteConfig Î± N p.Ï„ :=
    { c := fun k => p.c (p.index (G k))
      r := fun k => p.r (p.index (G k))
      rpos := fun k => p.rpos (p.index (G k))
      h := by
        intro a b a_ne_b
        wlog G_le : G a â‰¤ G b generalizing a b
        Â· exact (this b a a_ne_b.symm (le_of_not_le G_le)).symm
        have G_lt : G a < G b := by
          rcases G_le.lt_or_eq with (H | H); Â· exact H
          have A : (a : â„•) â‰  b := Fin.val_injective.ne a_ne_b
          rw [â† color_G a (Nat.lt_succ_iff.1 a.2), â† color_G b (Nat.lt_succ_iff.1 b.2), H] at A
          exact (A rfl).elim
        exact Or.inl (Gab a b G_lt)
      hlast := by
        intro a ha
        have I : (a : â„•) < N := ha
        have : G a < G (Fin.last N) := by dsimp; simp [I.ne, (hg a I).1]
        exact Gab _ _ this
      inter := by
        intro a ha
        have I : (a : â„•) < N := ha
        have J : G (Fin.last N) = i := by dsimp; simp only [if_true, eq_self_iff_true]
        have K : G a = g a := by dsimp; simp [I.ne, (hg a I).1]
        convert dist_le_add_of_nonempty_closedBall_inter_closedBall (hg _ I).2.1 }
  exact hN.false sc","error:  tactic 'introN' failed, insufficient number of binders
Î± : Type u_1
instâœÂ¹ : MetricSpace Î±
Î² : Type u
instâœ : Nonempty Î²
p : TauPackage Î² Î±
N : â„•
hN : IsEmpty (SatelliteConfig Î± N p.Ï„)
i : Ordinal.{u}
IH : âˆ€ k < i, k < p.lastStep â†’ p.color k < N
hi : i < p.lastStep
A : Set â„• :=
  â‹ƒ j,
    â‹ƒ (_ :
      (closedBall (p.c (p.index â†‘j)) (p.r (p.index â†‘j)) âˆ© closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty),
      {p.color â†‘j}
color_i : p.color i = sInf (univ \ A)
j : N âˆˆ A
âŠ¢ False
error:  tactic 'assumption' failed
Î± : Type u_1
instâœÂ¹ : MetricSpace Î±
Î² : Type u
instâœ : Nonempty Î²
p : TauPackage Î² Î±
N : â„•
hN : IsEmpty (SatelliteConfig Î± N p.Ï„)
i : Ordinal.{u}
IH : âˆ€ k < i, k < p.lastStep â†’ p.color k < N
hi : i < p.lastStep
A : Set â„• :=
  â‹ƒ j,
    â‹ƒ (_ :
      (closedBall (p.c (p.index â†‘j)) (p.r (p.index â†‘j)) âˆ© closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty),
      {p.color â†‘j}
color_i : p.color i = sInf (univ \ A)
N_mem : N âˆˆ univ \ A
Inf_eq_N : sInf (univ \ A) = N
k : â„•
hk : k < sInf (univ \ A)
this : k âˆˆ A
âŠ¢ âˆƒ j < i,
    (closedBall (p.c (p.index j)) (p.r (p.index j)) âˆ© closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty âˆ§
      k = p.color j
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  application type mismatch
  this b
argument
  b
has type
  Fin N.succ : Type
but is expected to have type
  ?m.35073 â‰  ?m.35074 : Prop
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress","theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : â„•}
    (hN : IsEmpty (SatelliteConfig Î± N p.Ï„)) : p.color i < N ",":= by
  induction' i using Ordinal.induction with i IH
  let A : Set â„• :=
    â‹ƒ (j : { j // j < i })
      (_ : (closedBall (p.c (p.index j)) (p.r (p.index j)) âˆ©
        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty),
      {p.color j}
  have color_i : p.color i = sInf (univ \ A) := by rw [color]
  rw [color_i]
  have N_mem : N âˆˆ univ \ A := by
    simp only [A, not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff,
      mem_closedBall, not_and, mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]
    intro j ji _
    exact (IH j ji (ji.trans hi)).ne'
  suffices sInf (univ \ A) â‰  N by
    rcases (csInf_le (OrderBot.bddBelow (univ \ A)) N_mem).lt_or_eq with (H | H)
    Â· exact H
    Â· exact (this H).elim
  intro Inf_eq_N
  have :
    âˆ€ k, k < N â†’ âˆƒ j, j < i âˆ§
      (closedBall (p.c (p.index j)) (p.r (p.index j)) âˆ©
        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty âˆ§ k = p.color j := by
    intro k hk
    rw [â† Inf_eq_N] at hk
    have : k âˆˆ A := by
      simpa only [true_and_iff, mem_univ, Classical.not_not, mem_diff] using
        Nat.not_mem_of_lt_sInf hk
    simp only [mem_iUnion, mem_singleton_iff, exists_prop, Subtype.exists, exists_and_right,
      and_assoc] at this
    simpa only [A, exists_prop, mem_iUnion, mem_singleton_iff, mem_closedBall, Subtype.exists,
      Subtype.coe_mk]
  choose! g hg using this
  let G : â„• â†’ Ordinal := fun n => if n = N then i else g n
  have color_G : âˆ€ n, n â‰¤ N â†’ p.color (G n) = n := by
    intro n hn
    rcases hn.eq_or_lt with (rfl | H)
    Â· simp only [G]; simp only [color_i, Inf_eq_N, if_true, eq_self_iff_true]
    Â· simp only [G]; simp only [H.ne, (hg n H).right.right.symm, if_false]
  have G_lt_last : âˆ€ n, n â‰¤ N â†’ G n < p.lastStep := by
    intro n hn
    rcases hn.eq_or_lt with (rfl | H)
    Â· simp only [G]; simp only [hi, if_true, eq_self_iff_true]
    Â· simp only [G]; simp only [H.ne, (hg n H).left.trans hi, if_false]
  have fGn :
      âˆ€ n, n â‰¤ N â†’
        p.c (p.index (G n)) âˆ‰ p.iUnionUpTo (G n) âˆ§ p.R (G n) â‰¤ p.Ï„ * p.r (p.index (G n)) := by
    intro n hn
    have :
      p.index (G n) =
        Classical.epsilon fun t => p.c t âˆ‰ p.iUnionUpTo (G n) âˆ§ p.R (G n) â‰¤ p.Ï„ * p.r t := by
      rw [index]; rfl
    rw [this]
    have : âˆƒ t, p.c t âˆ‰ p.iUnionUpTo (G n) âˆ§ p.R (G n) â‰¤ p.Ï„ * p.r t := by
      simpa only [not_exists, exists_prop, not_and, not_lt, not_le, mem_setOf_eq, not_forall] using
        not_mem_of_lt_csInf (G_lt_last n hn) (OrderBot.bddBelow _)
    exact Classical.epsilon_spec this
  have Gab :
    âˆ€ a b : Fin (Nat.succ N),
      G a < G b â†’
        p.r (p.index (G a)) â‰¤ dist (p.c (p.index (G a))) (p.c (p.index (G b))) âˆ§
          p.r (p.index (G b)) â‰¤ p.Ï„ * p.r (p.index (G a)) := by
    intro a b G_lt
    have ha : (a : â„•) â‰¤ N := Nat.lt_succ_iff.1 a.2
    have hb : (b : â„•) â‰¤ N := Nat.lt_succ_iff.1 b.2
    constructor
    Â· have := (fGn b hb).1
      simp only [iUnionUpTo, not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_le,
        Subtype.exists, Subtype.coe_mk] at this
      simpa only [dist_comm, mem_ball, not_lt] using this (G a) G_lt
    Â· apply le_trans _ (fGn a ha).2
      have B : p.c (p.index (G b)) âˆ‰ p.iUnionUpTo (G a) := by
        intro H; exact (fGn b hb).1 (p.monotone_iUnionUpTo G_lt.le H)
      let b' : { t // p.c t âˆ‰ p.iUnionUpTo (G a) } := âŸ¨p.index (G b), BâŸ©
      apply @le_ciSup _ _ _ (fun t : { t // p.c t âˆ‰ p.iUnionUpTo (G a) } => p.r t) _ b'
      refine âŸ¨p.r_bound, fun t ht => ?_âŸ©
      simp only [exists_prop, mem_range, Subtype.exists, Subtype.coe_mk] at ht
      rcases ht with âŸ¨u, huâŸ©
      rw [â† hu.2]
      exact p.r_le _
  let sc : SatelliteConfig Î± N p.Ï„ :=
    { c := fun k => p.c (p.index (G k))
      r := fun k => p.r (p.index (G k))
      rpos := fun k => p.rpos (p.index (G k))
      h := by
        intro a b a_ne_b
        wlog G_le : G a â‰¤ G b generalizing a b
        Â· exact (this a_ne_b.symm (le_of_not_le G_le)).symm
        have G_lt : G a < G b := by
          rcases G_le.lt_or_eq with (H | H); Â· exact H
          have A : (a : â„•) â‰  b := Fin.val_injective.ne a_ne_b
          rw [â† color_G a (Nat.lt_succ_iff.1 a.2), â† color_G b (Nat.lt_succ_iff.1 b.2), H] at A
          exact (A rfl).elim
        exact Or.inl (Gab a b G_lt)
      hlast := by
        intro a ha
        have I : (a : â„•) < N := ha
        have : G a < G (Fin.last N) := by dsimp; simp [G, I.ne, (hg a I).1]
        exact Gab _ _ this
      inter := by
        intro a ha
        have I : (a : â„•) < N := ha
        have J : G (Fin.last N) = i := by dsimp; simp only [G, if_true, eq_self_iff_true]
        have K : G a = g a := by dsimp [G]; simp [I.ne, (hg a I).1]
        convert dist_le_add_of_nonempty_closedBall_inter_closedBall (hg _ I).2.1 }
  exact hN.false sc","simp only [SatelliteConfig, SatelliteConfig.lastStep, color_lt]"
Mathlib/Data/Fin/Tuple/NatAntidiagonal.lean,Multiset.Nat.nodup_antidiagonalTuple,nodup_antidiagonalTuple,388222f05155eadab4ebf5bf655aaca770cf9c53,":= by
  induction' k with k ih generalizing n
  Â· cases n
    Â· simp
    Â· simp [eq_comm]
  simp_rw [antidiagonalTuple, List.nodup_bind]
  constructor
  Â· intro i _
    exact (ih i.snd).map (Fin.cons_right_injective (Î± := fun _ => â„•) i.fst)
  induction' n with n n_ih
  Â· exact List.pairwise_singleton _ _
  Â· rw [List.Nat.antidiagonal_succ]
    refine' List.Pairwise.cons (fun a ha x hxâ‚ hxâ‚‚ => _) (n_ih.map _ fun a b h x hxâ‚ hxâ‚‚ => _)
    Â· rw [List.mem_map'] at hxâ‚ hxâ‚‚ ha
      obtain âŸ¨âŸ¨a, -, rflâŸ©, âŸ¨xâ‚, -, rflâŸ©, âŸ¨xâ‚‚, -, hâŸ©âŸ© := ha, hxâ‚, hxâ‚‚
      rw [Fin.cons_eq_cons] at h
      injection h.1
    Â· rw [List.mem_map'] at hxâ‚ hxâ‚‚
      obtain âŸ¨âŸ¨xâ‚, hxâ‚, rflâŸ©, âŸ¨xâ‚‚, hxâ‚‚, hâ‚â‚‚âŸ©âŸ© := hxâ‚, hxâ‚‚
      dsimp at hâ‚â‚‚
      rw [Fin.cons_eq_cons, Nat.succ_inj'] at hâ‚â‚‚
      obtain âŸ¨hâ‚â‚‚, rflâŸ© := hâ‚â‚‚
      rw [hâ‚â‚‚] at h
      exact h (List.mem_map_of_mem _ hxâ‚) (List.mem_map_of_mem _ hxâ‚‚)","error:  unknown constant 'List.mem_map''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.6296
case succ.right.succ.refine'_1
k : â„•
ih : âˆ€ (n : â„•), (antidiagonalTuple k n).Nodup
n : â„•
n_ih :
  Pairwise
    (fun a b â†¦
      (map (fun x â†¦ Fin.cons a.1 x) (antidiagonalTuple k a.2)).Disjoint
        (map (fun x â†¦ Fin.cons b.1 x) (antidiagonalTuple k b.2)))
    (antidiagonal n)
a : â„• Ã— â„•
ha : a âˆˆ map (Prod.map Nat.succ id) (antidiagonal n)
x : Fin (k + 1) â†’ â„•
hxâ‚ : x âˆˆ map (fun x â†¦ Fin.cons (0, n + 1).1 x) (antidiagonalTuple k (0, n + 1).2)
hxâ‚‚ : x âˆˆ map (fun x â†¦ Fin.cons a.1 x) (antidiagonalTuple k a.2)
âŠ¢ False
error:  unknown constant 'List.mem_map''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.6301
case succ.right.succ.refine'_2
k : â„•
ih : âˆ€ (n : â„•), (antidiagonalTuple k n).Nodup
n : â„•
n_ih :
  Pairwise
    (fun a b â†¦
      (map (fun x â†¦ Fin.cons a.1 x) (antidiagonalTuple k a.2)).Disjoint
        (map (fun x â†¦ Fin.cons b.1 x) (antidiagonalTuple k b.2)))
    (antidiagonal n)
a b : â„• Ã— â„•
h :
  (map (fun x â†¦ Fin.cons a.1 x) (antidiagonalTuple k a.2)).Disjoint
    (map (fun x â†¦ Fin.cons b.1 x) (antidiagonalTuple k b.2))
x : Fin (k + 1) â†’ â„•
hxâ‚ : x âˆˆ map (fun x â†¦ Fin.cons (Prod.map Nat.succ id a).1 x) (antidiagonalTuple k (Prod.map Nat.succ id a).2)
hxâ‚‚ : x âˆˆ map (fun x â†¦ Fin.cons (Prod.map Nat.succ id b).1 x) (antidiagonalTuple k (Prod.map Nat.succ id b).2)
âŠ¢ False",theorem nodup_antidiagonalTuple (k n : â„•) : List.Nodup (antidiagonalTuple k n) ,":= by
  induction' k with k ih generalizing n
  Â· cases n
    Â· simp
    Â· simp [eq_comm]
  simp_rw [antidiagonalTuple, List.nodup_bind]
  constructor
  Â· intro i _
    exact (ih i.snd).map (Fin.cons_right_injective (Î± := fun _ => â„•) i.fst)
  induction' n with n n_ih
  Â· exact List.pairwise_singleton _ _
  Â· rw [List.Nat.antidiagonal_succ]
    refine List.Pairwise.cons (fun a ha x hxâ‚ hxâ‚‚ => ?_) (n_ih.map _ fun a b h x hxâ‚ hxâ‚‚ => ?_)
    Â· rw [List.mem_map] at hxâ‚ hxâ‚‚ ha
      obtain âŸ¨âŸ¨a, -, rflâŸ©, âŸ¨xâ‚, -, rflâŸ©, âŸ¨xâ‚‚, -, hâŸ©âŸ© := ha, hxâ‚, hxâ‚‚
      rw [Fin.cons_eq_cons] at h
      injection h.1
    Â· rw [List.mem_map] at hxâ‚ hxâ‚‚
      obtain âŸ¨âŸ¨xâ‚, hxâ‚, rflâŸ©, âŸ¨xâ‚‚, hxâ‚‚, hâ‚â‚‚âŸ©âŸ© := hxâ‚, hxâ‚‚
      dsimp at hâ‚â‚‚
      rw [Fin.cons_eq_cons, Nat.succ_inj'] at hâ‚â‚‚
      obtain âŸ¨hâ‚â‚‚, rflâŸ© := hâ‚â‚‚
      rw [hâ‚â‚‚] at h
      exact h (List.mem_map_of_mem _ hxâ‚) (List.mem_map_of_mem _ hxâ‚‚)","simp [antidiagonalTuple, nodup_antidiagonalTuple]"
Mathlib/MeasureTheory/Integral/CircleIntegral.lean,circleIntegrable_sub_zpow_iff,circleIntegrable_sub_zpow_iff,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  constructor
  Â· intro h; contrapose! h; rcases h with âŸ¨hR, hn, hwâŸ©
    simp only [circleIntegrable_iff R, deriv_circleMap]
    rw [â† image_circleMap_Ioc] at hw; rcases hw with âŸ¨Î¸, hÎ¸, rflâŸ©
    replace hÎ¸ : Î¸ âˆˆ [[0, 2 * Ï€]] := Icc_subset_uIcc (Ioc_subset_Icc_self hÎ¸)
    refine' not_intervalIntegrable_of_sub_inv_isBigO_punctured _ Real.two_pi_pos.ne hÎ¸
    set f : â„ â†’ â„‚ := fun Î¸' => circleMap c R Î¸' - circleMap c R Î¸
    have : âˆ€á¶  Î¸' in ğ“[â‰ ] Î¸, f Î¸' âˆˆ ball (0 : â„‚) 1 \ {0} := by
      suffices âˆ€á¶  z in ğ“[â‰ ] circleMap c R Î¸, z - circleMap c R Î¸ âˆˆ ball (0 : â„‚) 1 \ {0} from
        ((differentiable_circleMap c R Î¸).hasDerivAt.tendsto_punctured_nhds
          (deriv_circleMap_ne_zero hR)).eventually this
      filter_upwards [self_mem_nhdsWithin, mem_nhdsWithin_of_mem_nhds (ball_mem_nhds _ zero_lt_one)]
      simp_all [dist_eq, sub_eq_zero]
    refine' (((hasDerivAt_circleMap c R Î¸).isBigO_sub.mono inf_le_left).inv_rev
      (this.mono fun Î¸' hâ‚ hâ‚‚ => absurd hâ‚‚ hâ‚.2)).trans _
    refine' IsBigO.of_bound |R|â»Â¹ (this.mono fun Î¸' hÎ¸' => _)
    set x := abs (f Î¸')
    suffices xâ»Â¹ â‰¤ x ^ n by
      simpa only [inv_mul_cancel_leftâ‚€, abs_eq_zero.not.2 hR, norm_eq_abs, map_invâ‚€,
        Algebra.id.smul_eq_mul, map_mul, abs_circleMap_zero, abs_I, mul_one, abs_zpow, Ne.def,
        not_false_iff] using this
    have : x âˆˆ Ioo (0 : â„) 1 := by simpa [x, and_comm] using hÎ¸'
    rw [â† zpow_neg_one]
    refine' (zpow_strictAnti this.1 this.2).le_iff_le.2 (Int.lt_add_one_iff.1 _); exact hn
  Â· rintro (rfl | H)
    exacts [circleIntegrable_zero_radius,
      ((continuousOn_id.sub continuousOn_const).zpowâ‚€ _ fun z hz =>
        H.symm.imp_left fun (hw : w âˆ‰ sphere c |R|) =>
          sub_ne_zero.2 <| ne_of_mem_of_not_mem hz hw).circleIntegrable']","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.91001 â†’ ?m.91001 â†’ Prop
error:  type mismatch
  hâœ
has type
  xâ»Â¹ â‰¤ x ^ n : Prop
but is expected to have type
  (Complex.abs (circleMap c R Î¸' - circleMap c R Î¸))â»Â¹ â‰¤
    |R|â»Â¹ * (|R| * Complex.abs (circleMap c R Î¸' - circleMap c R Î¸) ^ n) : Prop","theorem circleIntegrable_sub_zpow_iff {c w : â„‚} {R : â„} {n : â„¤} :
    CircleIntegrable (fun z => (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ w âˆ‰ sphere c |R| ",":= by
  constructor
  Â· intro h; contrapose! h; rcases h with âŸ¨hR, hn, hwâŸ©
    simp only [circleIntegrable_iff R, deriv_circleMap]
    rw [â† image_circleMap_Ioc] at hw; rcases hw with âŸ¨Î¸, hÎ¸, rflâŸ©
    replace hÎ¸ : Î¸ âˆˆ [[0, 2 * Ï€]] := Icc_subset_uIcc (Ioc_subset_Icc_self hÎ¸)
    refine not_intervalIntegrable_of_sub_inv_isBigO_punctured ?_ Real.two_pi_pos.ne hÎ¸
    set f : â„ â†’ â„‚ := fun Î¸' => circleMap c R Î¸' - circleMap c R Î¸
    have : âˆ€á¶  Î¸' in ğ“[â‰ ] Î¸, f Î¸' âˆˆ ball (0 : â„‚) 1 \ {0} := by
      suffices âˆ€á¶  z in ğ“[â‰ ] circleMap c R Î¸, z - circleMap c R Î¸ âˆˆ ball (0 : â„‚) 1 \ {0} from
        ((differentiable_circleMap c R Î¸).hasDerivAt.tendsto_punctured_nhds
          (deriv_circleMap_ne_zero hR)).eventually this
      filter_upwards [self_mem_nhdsWithin, mem_nhdsWithin_of_mem_nhds (ball_mem_nhds _ zero_lt_one)]
      simp_all [dist_eq, sub_eq_zero]
    refine (((hasDerivAt_circleMap c R Î¸).isBigO_sub.mono inf_le_left).inv_rev
      (this.mono fun Î¸' hâ‚ hâ‚‚ => absurd hâ‚‚ hâ‚.2)).trans ?_
    refine IsBigO.of_bound |R|â»Â¹ (this.mono fun Î¸' hÎ¸' => ?_)
    set x := abs (f Î¸')
    suffices xâ»Â¹ â‰¤ x ^ n by
      simpa only [inv_mul_cancel_leftâ‚€, abs_eq_zero.not.2 hR, norm_eq_abs, map_invâ‚€,
        Algebra.id.smul_eq_mul, map_mul, abs_circleMap_zero, abs_I, mul_one, abs_zpow, Ne,
        not_false_iff] using this
    have : x âˆˆ Ioo (0 : â„) 1 := by simpa [x, and_comm] using hÎ¸'
    rw [â† zpow_neg_one]
    refine (zpow_strictAnti this.1 this.2).le_iff_le.2 (Int.lt_add_one_iff.1 ?_); exact hn
  Â· rintro (rfl | H)
    exacts [circleIntegrable_zero_radius,
      ((continuousOn_id.sub continuousOn_const).zpowâ‚€ _ fun z hz =>
        H.symm.imp_left fun (hw : w âˆ‰ sphere c |R|) =>
          sub_ne_zero.2 <| ne_of_mem_of_not_mem hz hw).circleIntegrable']",rcases eq_or_lt_of_sphere_nonemptyR n with hn | hn
Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.lean,CategoryTheory.Limits.hasFiniteLimits_of_hasFiniteLimits_of_size,hasFiniteLimits_of_hasFiniteLimits_of_size,2ac7d87c221020b247729b180bbe2575cceb0700,"  out := fun J hJ hhJ => by
    haveI := h (ULiftHom.{w} (ULift.{w} J)) <| @CategoryTheory.finCategoryUlift J hJ hhJ
    have l : @Equivalence J (ULiftHom (ULift J)) hJ
                          (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) :=
      @ULiftHomULiftCategory.equiv J hJ
    apply @hasLimitsOfShape_of_equivalence (ULiftHom (ULift J))
      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) C _ J hJ
      (@Equivalence.symm J hJ (ULiftHom (ULift J))
      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) l) _
    class HasFiniteColimits : Prop where
  out (J : Type) [ğ’¥ : SmallCategory J] [@FinCategory J ğ’¥] : @HasColimitsOfShape J ğ’¥ C _",error:  'CategoryTheory.Limits.HasFiniteColimits' has already been declared,"theorem hasFiniteLimits_of_hasFiniteLimits_of_size
    (h : âˆ€ (J : Type w) {ğ’¥ : SmallCategory J} (_ : @FinCategory J ğ’¥), HasLimitsOfShape J C) :
    HasFiniteLimits C where
","  out := fun J hJ hhJ => by
    haveI := h (ULiftHom.{w} (ULift.{w} J)) <| @CategoryTheory.finCategoryUlift J hJ hhJ
    have l : @Equivalence J (ULiftHom (ULift J)) hJ
                          (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) :=
      @ULiftHomULiftCategory.equiv J hJ
    apply @hasLimitsOfShape_of_equivalence (ULiftHom (ULift J))
      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) C _ J hJ
      (@Equivalence.symm J hJ (ULiftHom (ULift J))
      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) l) _
    ",apply hasFiniteLimits_of_hasFiniteLimits_of_hasFiniteLimits_of_size
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.null_of_frequently_le_of_frequently_ge,null_of_frequently_le_of_frequently_ge,9d3887769246754772c178dd6c594378dce58448,":= by
  apply measure_null_of_locally_null s fun x _ => ?_
  obtain âŸ¨o, xo, o_open, Î¼oâŸ© : âˆƒ o : Set Î±, x âˆˆ o âˆ§ IsOpen o âˆ§ Î¼ o < âˆ :=
    Measure.exists_isOpen_measure_lt_top Î¼ x
  refine' âŸ¨s âˆ© o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), _âŸ©
  let s' := s âˆ© o
  by_contra h
  apply lt_irrefl (Ï s')
  calc
    Ï s' â‰¤ c * Î¼ s' := v.measure_le_of_frequently_le (c â€¢ Î¼) hÏ s' fun x hx => hc x hx.1
    _ < d * Î¼ s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt (measure_mono (inter_subset_right _ _)) Î¼o).ne
    _ â‰¤ Ï s' :=
      v.measure_le_of_frequently_le Ï ((Measure.AbsolutelyContinuous.refl Î¼).smul d) s' fun x hx =>
        hd x hx.1","error:  function expected at
  inter_subset_right ?m.58097
term has type
  ?m.58096 âˆˆ ?m.58095","theorem null_of_frequently_le_of_frequently_ge {c d : â„â‰¥0} (hcd : c < d) (s : Set Î±)
    (hc : âˆ€ x âˆˆ s, âˆƒá¶  a in v.filterAt x, Ï a â‰¤ c * Î¼ a)
    (hd : âˆ€ x âˆˆ s, âˆƒá¶  a in v.filterAt x, (d : â„â‰¥0âˆ) * Î¼ a â‰¤ Ï a) : Î¼ s = 0 ",":= by
  apply measure_null_of_locally_null s fun x _ => ?_
  obtain âŸ¨o, xo, o_open, Î¼oâŸ© : âˆƒ o : Set Î±, x âˆˆ o âˆ§ IsOpen o âˆ§ Î¼ o < âˆ :=
    Measure.exists_isOpen_measure_lt_top Î¼ x
  refine âŸ¨s âˆ© o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_âŸ©
  let s' := s âˆ© o
  by_contra h
  apply lt_irrefl (Ï s')
  calc
    Ï s' â‰¤ c * Î¼ s' := v.measure_le_of_frequently_le (c â€¢ Î¼) hÏ s' fun x hx => hc x hx.1
    _ < d * Î¼ s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt (measure_mono inter_subset_right) Î¼o).ne
    _ â‰¤ Ï s' :=
      v.measure_le_of_frequently_le Ï ((Measure.AbsolutelyContinuous.refl Î¼).smul d) s' fun x hx =>
        hd x hx.1",refine theorem_eq_zero_of_frequently_le_of_frequently_ge _ _ _ _ _ _ _ _ _ _ ?_
Mathlib/Algebra/DirectSum/Module.lean,DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top,isInternal_submodule_of_independent_of_iSup_eq_top,161c69c1dbf66cf3c7ec4f648a61551d044a43e4,":=
  âŸ¨hi.dfinsupp_lsum_injective,
    LinearMap.range_eq_top.1 <| (Submodule.iSup_eq_range_dfinsupp_lsum _).symm.trans hsâŸ©","error:  failed to synthesize
  SemilinearMapClass ((â¨ (i : Î¹), â†¥(A i)) â†’+ M) ?m.214079 (â¨ (i : Î¹), â†¥(A i)) M
use `set_option diagnostics true` to get diagnostic information","theorem isInternal_submodule_of_independent_of_iSup_eq_top {A : Î¹ â†’ Submodule R M}
    (hi : CompleteLattice.Independent A) (hs : iSup A = âŠ¤) : IsInternal A ",":=
  âŸ¨hi.dfinsupp_lsum_injective,
    (LinearMap.range_eq_top (f := DFinsupp.lsum _ _)).1 <|
      (Submodule.iSup_eq_range_dfinsupp_lsum _).symm.trans hsâŸ©",refine isInternal_of_isInternal_submodule_of_isInternal_submodule_of_isInternal_submodule_of_isInternal_submodule_of_isInternal_submodule
Mathlib/RingTheory/Discriminant.lean,Algebra.discr_zero_of_not_linearIndependent,discr_zero_of_not_linearIndependent,9e34a191034458a56331f976ff7400a26407c888,":= by
  classical
  obtain âŸ¨g, hg, i, hiâŸ© := Fintype.not_linearIndependent_iff.1 hli
  have : (traceMatrix A b).mulVec g = 0 := by
    ext i
    have : âˆ€ j, (trace A B) (b i * b j) * g j = (trace A B) (g j â€¢ b j * b i) := by
      intro j;
      simp [mul_comm]
    simp only [mulVec, dotProduct, traceMatrix_apply, Pi.zero_apply, traceForm_apply, fun j =>
      this j, â† LinearMap.map_sum, â† sum_mul, hg, MulZeroClass.zero_mul, LinearMap.map_zero]
  by_contra h
  rw [discr_def] at h
  simp [Matrix.eq_zero_of_mulVec_eq_zero h this] at hi","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.22531 â†’+* ?m.22532) â†’
    (M : Type ?u.22528) â†’
      (Mâ‚‚ : Type ?u.22527) â†’
        [inst : AddCommMonoid M] â†’
          [inst_1 : AddCommMonoid Mâ‚‚] â†’
            [inst : Module ?m.22531 M] â†’ [inst : Module ?m.22532 Mâ‚‚] â†’ Type (max ?u.22528 ?u.22527)
error:  unsolved goals
case h
A : Type u
B : Type v
C : Type z
Î¹ : Type w
instâœâ¹ : DecidableEq Î¹
instâœâ¸ : CommRing A
instâœâ· : CommRing B
instâœâ¶ : Algebra A B
instâœâµ : CommRing C
instâœâ´ : Algebra A C
Î¹' : Type u_1
instâœÂ³ : Fintype Î¹'
instâœÂ² : Fintype Î¹
instâœÂ¹ : DecidableEq Î¹'
instâœ : IsDomain A
b : Î¹ â†’ B
hli : Â¬LinearIndependent A b
g : Î¹ â†’ A
hg : âˆ‘ i : Î¹, g i â€¢ b i = 0
iâœ : Î¹
hi : g iâœ â‰  0
i : Î¹
this : âˆ€ (j : Î¹), (trace A B) (b i * b j) * g j = (trace A B) (g j â€¢ b j * b i)
âŠ¢ âˆ‘ x : Î¹, (trace A B) (g x â€¢ b x * b i) = 0","theorem discr_zero_of_not_linearIndependent [IsDomain A] {b : Î¹ â†’ B}
    (hli : Â¬LinearIndependent A b) : discr A b = 0 ",":= by
  classical
  obtain âŸ¨g, hg, i, hiâŸ© := Fintype.not_linearIndependent_iff.1 hli
  have : (traceMatrix A b) *áµ¥ g = 0 := by
    ext i
    have : âˆ€ j, (trace A B) (b i * b j) * g j = (trace A B) (g j â€¢ b j * b i) := by
      intro j;
      simp [mul_comm]
    simp only [mulVec, dotProduct, traceMatrix_apply, Pi.zero_apply, traceForm_apply, fun j =>
      this j, â† map_sum, â† sum_mul, hg, zero_mul, LinearMap.map_zero]
  by_contra h
  rw [discr_def] at h
  simp [Matrix.eq_zero_of_mulVec_eq_zero h this] at hi",rw [discr_zero_of_not_linearIndependent]
Mathlib/Data/ZMod/Basic.lean,ZMod.cast_one,cast_one,40085f5f4d3ac3fa83073044989c1dde599ea994,":= by
  cases' n with n
  Â· exact Int.cast_one
  show ((1 % (n + 1) : â„•) : R) = 1
  cases n
  Â· rw [Nat.dvd_one] at h
    subst m
    subsingleton [CharP.CharOne.subsingleton]
  rw [Nat.mod_eq_of_lt]
  Â· exact Nat.cast_one
  exact Nat.lt_of_sub_eq_succ rfl","error:  unknown tactic
error:  unsolved goals
case succ.zero
R : Type u_1
instâœÂ¹ : Ring R
instâœ : CharP R 1
âŠ¢ â†‘(1 % (0 + 1)) = 1
error:  unsolved goals
case succ.succ
R : Type u_1
instâœÂ¹ : Ring R
m : â„•
instâœ : CharP R m
nâœ : â„•
h : m âˆ£ nâœ + 1 + 1
âŠ¢ â†‘(1 % (nâœ + 1 + 1)) = 1",theorem cast_one (h : m âˆ£ n) : (cast (1 : ZMod n) : R) = 1 ,":= by
  cases' n with n
  Â· exact Int.cast_one
  show ((1 % (n + 1) : â„•) : R) = 1
  cases n;
  Â· rw [Nat.dvd_one] at h
    subst m
    have : Subsingleton R := CharP.CharOne.subsingleton
    apply Subsingleton.elim
  rw [Nat.mod_eq_of_lt]
  Â· exact Nat.cast_one
  exact Nat.lt_of_sub_eq_succ rfl","simp only [ZMod.cast_zero, ZMod.cast_zero, cast_zero]"
Mathlib/RingTheory/Polynomial/GaussLemma.lean,IsIntegrallyClosed.eq_map_mul_C_of_dvd,IsIntegrallyClosed.eq_map_mul_C_of_dvd,9f6d33884de569540c527b667d1573e1b97e1347,":= by
  have g_ne_0 : g â‰  0 := ne_zero_of_dvd_ne_zero (Monic.ne_zero <| hf.map (algebraMap R K)) hg
  suffices lem : âˆƒ g' : R[X], g'.map (algebraMap R K) = g * C g.leadingCoeffâ»Â¹
  Â· obtain âŸ¨g', hg'âŸ© := lem
    use g'
    rw [hg', mul_assoc, â† C_mul, inv_mul_cancel (leadingCoeff_ne_zero.mpr g_ne_0), C_1, mul_one]
  have g_mul_dvd : g * C g.leadingCoeffâ»Â¹ âˆ£ f.map (algebraMap R K) := by
    rwa [Associated.dvd_iff_dvd_left (show Associated (g * C g.leadingCoeffâ»Â¹) g from _)]
    rw [associated_mul_isUnit_left_iff]
    exact isUnit_C.mpr (inv_ne_zero <| leadingCoeff_ne_zero.mpr g_ne_0).isUnit
  let algeq :=
    (Subalgebra.equivOfEq _ _ <| integralClosure_eq_bot R _).trans
      (Algebra.botEquivOfInjective <| IsFractionRing.injective R <| K)
  have :
    (algebraMap R _).comp algeq.toAlgHom.toRingHom = (integralClosure R _).toSubring.subtype :=
    by ext x; conv_rhs => rw [â† algeq.symm_apply_apply x]; rfl
  have H :=
    (mem_lifts _).1
      (integralClosure.mem_lifts_of_monic_of_dvd_map K hf (monic_mul_leadingCoeff_inv g_ne_0)
        g_mul_dvd)
  refine' âŸ¨map algeq.toAlgHom.toRingHom _, _âŸ©
  Â· use! Classical.choose H
  Â· rw [map_map, this]
    exact Classical.choose_spec H",error:  unexpected token 'Â·'; expected 'by' or 'from',"theorem IsIntegrallyClosed.eq_map_mul_C_of_dvd [IsIntegrallyClosed R] {f : R[X]} (hf : f.Monic)
    {g : K[X]} (hg : g âˆ£ f.map (algebraMap R K)) :
    âˆƒ g' : R[X], g'.map (algebraMap R K) * (C <| leadingCoeff g) = g ",":= by
  have g_ne_0 : g â‰  0 := ne_zero_of_dvd_ne_zero (Monic.ne_zero <| hf.map (algebraMap R K)) hg
  suffices lem : âˆƒ g' : R[X], g'.map (algebraMap R K) = g * C g.leadingCoeffâ»Â¹ by
    obtain âŸ¨g', hg'âŸ© := lem
    use g'
    rw [hg', mul_assoc, â† C_mul, inv_mul_cancel (leadingCoeff_ne_zero.mpr g_ne_0), C_1, mul_one]
  have g_mul_dvd : g * C g.leadingCoeffâ»Â¹ âˆ£ f.map (algebraMap R K) := by
    rwa [Associated.dvd_iff_dvd_left (show Associated (g * C g.leadingCoeffâ»Â¹) g from _)]
    rw [associated_mul_isUnit_left_iff]
    exact isUnit_C.mpr (inv_ne_zero <| leadingCoeff_ne_zero.mpr g_ne_0).isUnit
  let algeq :=
    (Subalgebra.equivOfEq _ _ <| integralClosure_eq_bot R _).trans
      (Algebra.botEquivOfInjective <| IsFractionRing.injective R <| K)
  have :
    (algebraMap R _).comp algeq.toAlgHom.toRingHom = (integralClosure R _).toSubring.subtype := by
    ext x; (conv_rhs => rw [â† algeq.symm_apply_apply x]); rfl
  have H :=
    (mem_lifts _).1
      (integralClosure.mem_lifts_of_monic_of_dvd_map K hf (monic_mul_leadingCoeff_inv g_ne_0)
        g_mul_dvd)
  refine âŸ¨map algeq.toAlgHom.toRingHom ?_, ?_âŸ©
  Â· use! Classical.choose H
  Â· rw [map_map, this]
    exact Classical.choose_spec H","obtain âŸ¨g', hg'âŸ© := hg"
Mathlib/MeasureTheory/Measure/Haar/OfBasis.lean,parallelepiped_single,parallelepiped_single,df634f2a3b3d3eef3936f220d4bcc9b21e88770c,":= by
  ext x
  simp_rw [Set.uIcc, mem_parallelepiped_iff, Set.mem_Icc, Pi.le_def, â† forall_and, Pi.inf_apply,
    Pi.sup_apply, â† Pi.single_smul', Pi.one_apply, Pi.zero_apply, â† Pi.smul_apply',
    Finset.univ_sum_single (_ : Î¹ â†’ â„)]
  constructor
  Â· rintro âŸ¨t, ht, rflâŸ© i
    specialize ht i
    simp_rw [smul_eq_mul, Pi.mul_apply]
    cases' le_total (a i) 0 with hai hai
    Â· rw [sup_eq_left.mpr hai, inf_eq_right.mpr hai]
      exact âŸ¨le_mul_of_le_one_left hai ht.2, mul_nonpos_of_nonneg_of_nonpos ht.1 haiâŸ©
    Â· rw [sup_eq_right.mpr hai, inf_eq_left.mpr hai]
      exact âŸ¨mul_nonneg ht.1 hai, mul_le_of_le_one_left hai ht.2âŸ©
  Â· intro h
    refine' âŸ¨fun i => x i / a i, fun i => _, funext fun i => _âŸ©
    Â· specialize h i
      cases' le_total (a i) 0 with hai hai
      Â· rw [sup_eq_left.mpr hai, inf_eq_right.mpr hai] at h
        exact âŸ¨div_nonneg_of_nonpos h.2 hai, div_le_one_of_ge h.1 haiâŸ©
      Â· rw [sup_eq_right.mpr hai, inf_eq_left.mpr hai] at h
        exact âŸ¨div_nonneg h.1 hai, div_le_one_of_le h.2 haiâŸ©
    Â· specialize h i
      simp only [smul_eq_mul, Pi.mul_apply]
      cases' eq_or_ne (a i) 0 with hai hai
      Â· rw [hai, inf_idem, sup_idem, â† le_antisymm_iff] at h
        rw [hai, â† h, zero_div, zero_mul]
      Â· rw [div_mul_cancel _ hai]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.133997 / ?m.134011 * ?m.134011
case h.mpr.refine'_2.inr
Î¹ : Type u_1
Î¹' : Type u_2
E : Type u_3
F : Type u_4
instâœâ¶ : Fintype Î¹
instâœâµ : Fintype Î¹'
instâœâ´ : AddCommGroup E
instâœÂ³ : Module â„ E
instâœÂ² : AddCommGroup F
instâœÂ¹ : Module â„ F
instâœ : DecidableEq Î¹
a x : Î¹ â†’ â„
i : Î¹
h : 0 âŠ“ a i â‰¤ x i âˆ§ x i â‰¤ 0 âŠ” a i
hai : a i â‰  0
âŠ¢ x i = x i / a i * a i
error:  application type mismatch
  div_mul_cancel ?m.133997 hai
argument
  hai
has type
  a i â‰  0 : Prop
but is expected to have type
  ?m.133995 : Type ?u.133994","theorem parallelepiped_single [DecidableEq Î¹] (a : Î¹ â†’ â„) :
    (parallelepiped fun i => Pi.single i (a i)) = Set.uIcc 0 a ",":= by
  ext x
  simp_rw [Set.uIcc, mem_parallelepiped_iff, Set.mem_Icc, Pi.le_def, â† forall_and, Pi.inf_apply,
    Pi.sup_apply, â† Pi.single_smul', Pi.one_apply, Pi.zero_apply, â† Pi.smul_apply',
    Finset.univ_sum_single (_ : Î¹ â†’ â„)]
  constructor
  Â· rintro âŸ¨t, ht, rflâŸ© i
    specialize ht i
    simp_rw [smul_eq_mul, Pi.mul_apply]
    rcases le_total (a i) 0 with hai | hai
    Â· rw [sup_eq_left.mpr hai, inf_eq_right.mpr hai]
      exact âŸ¨le_mul_of_le_one_left hai ht.2, mul_nonpos_of_nonneg_of_nonpos ht.1 haiâŸ©
    Â· rw [sup_eq_right.mpr hai, inf_eq_left.mpr hai]
      exact âŸ¨mul_nonneg ht.1 hai, mul_le_of_le_one_left hai ht.2âŸ©
  Â· intro h
    refine âŸ¨fun i => x i / a i, fun i => ?_, funext fun i => ?_âŸ©
    Â· specialize h i
      rcases le_total (a i) 0 with hai | hai
      Â· rw [sup_eq_left.mpr hai, inf_eq_right.mpr hai] at h
        exact âŸ¨div_nonneg_of_nonpos h.2 hai, div_le_one_of_ge h.1 haiâŸ©
      Â· rw [sup_eq_right.mpr hai, inf_eq_left.mpr hai] at h
        exact âŸ¨div_nonneg h.1 hai, div_le_one_of_le h.2 haiâŸ©
    Â· specialize h i
      simp only [smul_eq_mul, Pi.mul_apply]
      rcases eq_or_ne (a i) 0 with hai | hai
      Â· rw [hai, inf_idem, sup_idem, â† le_antisymm_iff] at h
        rw [hai, â† h, zero_div, zero_mul]
      Â· rw [div_mul_cancelâ‚€ _ hai]",rw [â† parallelepiped_single.uIcc_eq]
Mathlib/MeasureTheory/Measure/Portmanteau.lean,MeasureTheory.exists_null_frontier_thickening,exists_null_frontier_thickening,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have mbles : âˆ€ r : â„, MeasurableSet (frontier (Metric.thickening r s)) :=
    fun r => isClosed_frontier.measurableSet
  have disjs := Metric.frontier_thickening_disjoint s
  have key := Measure.countable_meas_pos_of_disjoint_iUnion (Î¼ := Î¼) mbles disjs
  have aux := measure_diff_null (sâ‚ := Ioo a b) (Set.Countable.measure_zero key volume)
  have len_pos : 0 < ENNReal.ofReal (b - a) := by simp only [hab, ENNReal.ofReal_pos, sub_pos]
  rw [â† Real.volume_Ioo, â† aux] at len_pos
  rcases nonempty_of_measure_ne_zero len_pos.ne.symm with âŸ¨r, âŸ¨r_in_Ioo, hrâŸ©âŸ©
  refine' âŸ¨r, r_in_Ioo, _âŸ©
  simpa only [mem_setOf_eq, not_lt, le_zero_iff] using hr","error:  invalid argument name 'sâ‚' for function 'MeasureTheory.measure_diff_null'
error:  unsolved goals
Î© : Type u_1
instâœÂ³ : PseudoEMetricSpace Î©
instâœÂ² : MeasurableSpace Î©
instâœÂ¹ : OpensMeasurableSpace Î©
Î¼ : Measure Î©
instâœ : SigmaFinite Î¼
s : Set Î©
a b : â„
hab : a < b
mbles : âˆ€ (r : â„), MeasurableSet (frontier (Metric.thickening r s))
disjs : Pairwise (Disjoint on fun r â†¦ frontier (Metric.thickening r s))
key : {i | 0 < Î¼ (frontier (Metric.thickening i s))}.Countable
âŠ¢ âˆƒ r âˆˆ Ioo a b, Î¼ (frontier (Metric.thickening r s)) = 0","theorem exists_null_frontier_thickening (Î¼ : Measure Î©) [SigmaFinite Î¼] (s : Set Î©) {a b : â„}
    (hab : a < b) : âˆƒ r âˆˆ Ioo a b, Î¼ (frontier (Metric.thickening r s)) = 0 ",":= by
  have mbles : âˆ€ r : â„, MeasurableSet (frontier (Metric.thickening r s)) :=
    fun r => isClosed_frontier.measurableSet
  have disjs := Metric.frontier_thickening_disjoint s
  have key := Measure.countable_meas_pos_of_disjoint_iUnion (Î¼ := Î¼) mbles disjs
  have aux := measure_diff_null (s := Ioo a b) (Set.Countable.measure_zero key volume)
  have len_pos : 0 < ENNReal.ofReal (b - a) := by simp only [hab, ENNReal.ofReal_pos, sub_pos]
  rw [â† Real.volume_Ioo, â† aux] at len_pos
  rcases nonempty_of_measure_ne_zero len_pos.ne.symm with âŸ¨r, âŸ¨r_in_Ioo, hrâŸ©âŸ©
  refine âŸ¨r, r_in_Ioo, ?_âŸ©
  simpa only [mem_setOf_eq, not_lt, le_zero_iff] using hr","rcases exists_null_frontier_thickening_sigmaFinite_exists_null_frontier_thickening hab with
  âŸ¨r, r_pos, hrâŸ©"
Mathlib/LinearAlgebra/ExteriorAlgebra/Grading.lean,ExteriorAlgebra.Î¹Multi_span,Î¹Multi_span,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  rw [Submodule.eq_top_iff']
  intro x
  induction x
    using DirectSum.Decomposition.inductionOn fun i => LinearMap.range (Î¹ R (M := M)) ^ i with
  | h_zero => exact Submodule.zero_mem _
  | h_add _ _ hm hm' => exact Submodule.add_mem _ hm hm'
  | h_homogeneous hm =>
    let âŸ¨m, hmâŸ© := hm
    apply Set.mem_of_mem_of_subset hm
    rw [â† Î¹Multi_span_fixedDegree]
    refine Submodule.span_mono fun _ hx â†¦ ?_
    obtain âŸ¨y, rflâŸ© := hx
    exact âŸ¨âŸ¨_, yâŸ©, rflâŸ©","error:  failed to synthesize
  DirectSum.Decomposition fun i â†¦ LinearMap.range (Î¹ R) ^ i
use `set_option diagnostics true` to get diagnostic information
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â‹€[?R]^?n ?M
case h_homogeneous
R : Type u_1
M : Type u_2
instâœÂ² : CommRing R
instâœÂ¹ : AddCommGroup M
instâœ : Module R M
iâœ : â„•
hmâœ : â†¥(LinearMap.range (Î¹ R) ^ iâœ)
m : ExteriorAlgebra R M
hm : m âˆˆ LinearMap.range (Î¹ R) ^ iâœ
âŠ¢ â†‘(LinearMap.range (Î¹ R) ^ iâœ) âŠ† â†‘(Submodule.span R (Set.range fun x â†¦ (Î¹Multi R x.fst) x.snd))
error:  alternative 'x_0' has not been provided","lemma Î¹Multi_span :
    Submodule.span R (Set.range fun x : Î£ n, (Fin n â†’ M) => Î¹Multi R x.1 x.2) = âŠ¤ ",":= by
  rw [Submodule.eq_top_iff']
  intro x
  induction x using DirectSum.Decomposition.inductionOn fun i => â‹€[R]^i M with
  | h_zero => exact Submodule.zero_mem _
  | h_add _ _ hm hm' => exact Submodule.add_mem _ hm hm'
  | h_homogeneous hm =>
    let âŸ¨m, hmâŸ© := hm
    apply Set.mem_of_mem_of_subset hm
    rw [â† Î¹Multi_span_fixedDegree]
    refine Submodule.span_mono fun _ hx â†¦ ?_
    obtain âŸ¨y, rflâŸ© := hx
    exact âŸ¨âŸ¨_, yâŸ©, rflâŸ©","simp only [eq_top_iff, Submodule.mem_top]"
Mathlib/Topology/MetricSpace/GromovHausdorff.lean,GromovHausdorff.ghDist_le_of_approx_subsets,ghDist_le_of_approx_subsets,ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  refine le_of_forall_pos_le_add fun Î´ Î´0 => ?_
  rcases exists_mem_of_nonempty X with âŸ¨xX, _âŸ©
  rcases hs xX with âŸ¨xs, hxs, DxsâŸ©
  have sne : s.Nonempty := âŸ¨xs, hxsâŸ©
  letI : Nonempty s := sne.to_subtype
  have : 0 â‰¤ Îµâ‚‚ := le_trans (abs_nonneg _) (H âŸ¨xs, hxsâŸ© âŸ¨xs, hxsâŸ©)
  have : âˆ€ p q : s, |dist p q - dist (Î¦ p) (Î¦ q)| â‰¤ 2 * (Îµâ‚‚ / 2 + Î´) := fun p q =>
    calc
      |dist p q - dist (Î¦ p) (Î¦ q)| â‰¤ Îµâ‚‚ := H p q
      _ â‰¤ 2 * (Îµâ‚‚ / 2 + Î´) := by linarith
  letI : MetricSpace (Sum X Y) :=
    glueMetricApprox (fun x : s => (x : X)) (fun x => Î¦ x) (Îµâ‚‚ / 2 + Î´) (by linarith) this
  let Fl := @Sum.inl X Y
  let Fr := @Sum.inr X Y
  have Il : Isometry Fl := Isometry.of_dist_eq fun x y => rfl
  have Ir : Isometry Fr := Isometry.of_dist_eq fun x y => rfl
  have : ghDist X Y â‰¤ hausdorffDist (range Fl) (range Fr) := ghDist_le_hausdorffDist Il Ir
  have :
    hausdorffDist (range Fl) (range Fr) â‰¤
      hausdorffDist (range Fl) (Fl '' s) + hausdorffDist (Fl '' s) (range Fr) :=
    have B : IsBounded (range Fl) := (isCompact_range Il.continuous).isBounded
    hausdorffDist_triangle
      (hausdorffEdist_ne_top_of_nonempty_of_bounded (range_nonempty _) (sne.image _) B
        (B.subset (image_subset_range _ _)))
  have :
    hausdorffDist (Fl '' s) (range Fr) â‰¤
      hausdorffDist (Fl '' s) (Fr '' range Î¦) + hausdorffDist (Fr '' range Î¦) (range Fr) :=
    have B : IsBounded (range Fr) := (isCompact_range Ir.continuous).isBounded
    hausdorffDist_triangle'
      (hausdorffEdist_ne_top_of_nonempty_of_bounded ((range_nonempty _).image _) (range_nonempty _)
        (B.subset (image_subset_range _ _)) B)
  have : hausdorffDist (range Fl) (Fl '' s) â‰¤ Îµâ‚ := by
    rw [â† image_univ, hausdorffDist_image Il]
    have : 0 â‰¤ Îµâ‚ := le_trans dist_nonneg Dxs
    refine hausdorffDist_le_of_mem_dist this (fun x _ => hs x) fun x _ =>
      âŸ¨x, mem_univ _, by simpa only [dist_self]âŸ©
  have : hausdorffDist (Fl '' s) (Fr '' range Î¦) â‰¤ Îµâ‚‚ / 2 + Î´ := by
    refine hausdorffDist_le_of_mem_dist (by linarith) ?_ ?_
    Â· intro x' hx'
      rcases (Set.mem_image _ _ _).1 hx' with âŸ¨x, âŸ¨x_in_s, xx'âŸ©âŸ©
      rw [â† xx']
      use Fr (Î¦ âŸ¨x, x_in_sâŸ©), mem_image_of_mem Fr (mem_range_self _)
      exact le_of_eq (glueDist_glued_points (fun x : s => (x : X)) Î¦ (Îµâ‚‚ / 2 + Î´) âŸ¨x, x_in_sâŸ©)
    Â· intro x' hx'
      rcases (Set.mem_image _ _ _).1 hx' with âŸ¨y, âŸ¨y_in_s', yx'âŸ©âŸ©
      rcases mem_range.1 y_in_s' with âŸ¨x, xyâŸ©
      use Fl x, mem_image_of_mem _ x.2
      rw [â† yx', â† xy, dist_comm]
      exact le_of_eq (glueDist_glued_points (Z := s) (@Subtype.val X s.toPred) Î¦ (Îµâ‚‚ / 2 + Î´) x)
  have : hausdorffDist (Fr '' range Î¦) (range Fr) â‰¤ Îµâ‚ƒ := by
    rw [â† @image_univ _ _ Fr, hausdorffDist_image Ir]
    rcases exists_mem_of_nonempty Y with âŸ¨xY, _âŸ©
    rcases hs' xY with âŸ¨xs', Dxs'âŸ©
    have : 0 â‰¤ Îµâ‚ƒ := le_trans dist_nonneg Dxs'
    refine hausdorffDist_le_of_mem_dist this
      (fun x _ => âŸ¨x, mem_univ _, by simpa only [dist_self]âŸ©)
      fun x _ => ?_
    rcases hs' x with âŸ¨y, DyâŸ©
    exact âŸ¨Î¦ y, mem_range_self _, DyâŸ©
  linarith","error:  invalid field 'toPred', the environment does not contain 'Set.toPred'
  s
has type
  Set X
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  s
has type
  X â†’ Prop
error:  application type mismatch
  le_of_eq (glueDist_glued_points ?m.680961 Î¦ (Îµâ‚‚ / 2 + Î´) x)
argument
  glueDist_glued_points ?m.680961 Î¦ (Îµâ‚‚ / 2 + Î´) x
has type
  glueDist ?m.680961 Î¦ (Îµâ‚‚ / 2 + Î´) (inl (?m.680961 x)) (inr (Î¦ x)) = Îµâ‚‚ / 2 + Î´ : Prop
but is expected to have type
  dist (Fl â†‘x) (Fr (Î¦ x)) = Îµâ‚‚ / 2 + Î´ : Prop","theorem ghDist_le_of_approx_subsets {s : Set X} (Î¦ : s â†’ Y) {Îµâ‚ Îµâ‚‚ Îµâ‚ƒ : â„}
    (hs : âˆ€ x : X, âˆƒ y âˆˆ s, dist x y â‰¤ Îµâ‚) (hs' : âˆ€ x : Y, âˆƒ y : s, dist x (Î¦ y) â‰¤ Îµâ‚ƒ)
    (H : âˆ€ x y : s, |dist x y - dist (Î¦ x) (Î¦ y)| â‰¤ Îµâ‚‚) : ghDist X Y â‰¤ Îµâ‚ + Îµâ‚‚ / 2 + Îµâ‚ƒ ",":= by
  refine le_of_forall_pos_le_add fun Î´ Î´0 => ?_
  rcases exists_mem_of_nonempty X with âŸ¨xX, _âŸ©
  rcases hs xX with âŸ¨xs, hxs, DxsâŸ©
  have sne : s.Nonempty := âŸ¨xs, hxsâŸ©
  letI : Nonempty s := sne.to_subtype
  have : 0 â‰¤ Îµâ‚‚ := le_trans (abs_nonneg _) (H âŸ¨xs, hxsâŸ© âŸ¨xs, hxsâŸ©)
  have : âˆ€ p q : s, |dist p q - dist (Î¦ p) (Î¦ q)| â‰¤ 2 * (Îµâ‚‚ / 2 + Î´) := fun p q =>
    calc
      |dist p q - dist (Î¦ p) (Î¦ q)| â‰¤ Îµâ‚‚ := H p q
      _ â‰¤ 2 * (Îµâ‚‚ / 2 + Î´) := by linarith
  letI : MetricSpace (Sum X Y) :=
    glueMetricApprox (fun x : s => (x : X)) (fun x => Î¦ x) (Îµâ‚‚ / 2 + Î´) (by linarith) this
  let Fl := @Sum.inl X Y
  let Fr := @Sum.inr X Y
  have Il : Isometry Fl := Isometry.of_dist_eq fun x y => rfl
  have Ir : Isometry Fr := Isometry.of_dist_eq fun x y => rfl
  have : ghDist X Y â‰¤ hausdorffDist (range Fl) (range Fr) := ghDist_le_hausdorffDist Il Ir
  have :
    hausdorffDist (range Fl) (range Fr) â‰¤
      hausdorffDist (range Fl) (Fl '' s) + hausdorffDist (Fl '' s) (range Fr) :=
    have B : IsBounded (range Fl) := (isCompact_range Il.continuous).isBounded
    hausdorffDist_triangle
      (hausdorffEdist_ne_top_of_nonempty_of_bounded (range_nonempty _) (sne.image _) B
        (B.subset (image_subset_range _ _)))
  have :
    hausdorffDist (Fl '' s) (range Fr) â‰¤
      hausdorffDist (Fl '' s) (Fr '' range Î¦) + hausdorffDist (Fr '' range Î¦) (range Fr) :=
    have B : IsBounded (range Fr) := (isCompact_range Ir.continuous).isBounded
    hausdorffDist_triangle'
      (hausdorffEdist_ne_top_of_nonempty_of_bounded ((range_nonempty _).image _) (range_nonempty _)
        (B.subset (image_subset_range _ _)) B)
  have : hausdorffDist (range Fl) (Fl '' s) â‰¤ Îµâ‚ := by
    rw [â† image_univ, hausdorffDist_image Il]
    have : 0 â‰¤ Îµâ‚ := le_trans dist_nonneg Dxs
    refine hausdorffDist_le_of_mem_dist this (fun x _ => hs x) fun x _ =>
      âŸ¨x, mem_univ _, by simpa only [dist_self]âŸ©
  have : hausdorffDist (Fl '' s) (Fr '' range Î¦) â‰¤ Îµâ‚‚ / 2 + Î´ := by
    refine hausdorffDist_le_of_mem_dist (by linarith) ?_ ?_
    Â· intro x' hx'
      rcases (Set.mem_image _ _ _).1 hx' with âŸ¨x, âŸ¨x_in_s, xx'âŸ©âŸ©
      rw [â† xx']
      use Fr (Î¦ âŸ¨x, x_in_sâŸ©), mem_image_of_mem Fr (mem_range_self _)
      exact le_of_eq (glueDist_glued_points (fun x : s => (x : X)) Î¦ (Îµâ‚‚ / 2 + Î´) âŸ¨x, x_in_sâŸ©)
    Â· intro x' hx'
      rcases (Set.mem_image _ _ _).1 hx' with âŸ¨y, âŸ¨y_in_s', yx'âŸ©âŸ©
      rcases mem_range.1 y_in_s' with âŸ¨x, xyâŸ©
      use Fl x, mem_image_of_mem _ x.2
      rw [â† yx', â† xy, dist_comm]
      exact le_of_eq (glueDist_glued_points (Z := s) (@Subtype.val X s) Î¦ (Îµâ‚‚ / 2 + Î´) x)
  have : hausdorffDist (Fr '' range Î¦) (range Fr) â‰¤ Îµâ‚ƒ := by
    rw [â† @image_univ _ _ Fr, hausdorffDist_image Ir]
    rcases exists_mem_of_nonempty Y with âŸ¨xY, _âŸ©
    rcases hs' xY with âŸ¨xs', Dxs'âŸ©
    have : 0 â‰¤ Îµâ‚ƒ := le_trans dist_nonneg Dxs'
    refine hausdorffDist_le_of_mem_dist this
      (fun x _ => âŸ¨x, mem_univ _, by simpa only [dist_self]âŸ©)
      fun x _ => ?_
    rcases hs' x with âŸ¨y, DyâŸ©
    exact âŸ¨Î¦ y, mem_range_self _, DyâŸ©
  linarith",refine theorem_theorem_le_of_theorem ghDist_le_of_theorem ghDist_le_of_theorem hs Î¦ Îµâ‚ Îµâ‚‚ Îµâ‚ƒ hs'
Mathlib/Analysis/Calculus/FDeriv/Equiv.lean,HasFDerivAt.of_local_left_inverse,HasFDerivAt.of_local_left_inverse,bbc6e56d76341e236fa4e15748bebff612b5cb4f,":= by
  have : (fun x : F => g x - g a - f'.symm (x - a)) =O[ğ“ a]
      fun x : F => f' (g x - g a) - (x - a) := by
    refine' ((f'.symm : F â†’L[ğ•œ] E).isBigO_comp _ _).congr (fun x => _) fun _ => rfl
    simp
  refine' this.trans_isLittleO _
  clear this
  refine ((hf.comp_tendsto hg).symm.congr' (hfg.mono ?_) .rfl).trans_isBigO ?_
  Â· intro p hp
    simp [hp, hfg.self_of_nhds]
  Â· refine' ((hf.isBigO_sub_rev f'.antilipschitz).comp_tendsto hg).congr'
      (eventually_of_forall fun _ => rfl) (hfg.mono _)
    rintro p hp
    simp only [(Â· âˆ˜ Â·), hp, hfg.self_of_nhds]","error:  typeclass instance problem is stuck, it is often due to metavariables
  Norm ?m.459137","theorem HasFDerivAt.of_local_left_inverse {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F}
    (hg : ContinuousAt g a) (hf : HasFDerivAt f (f' : E â†’L[ğ•œ] F) (g a))
    (hfg : âˆ€á¶  y in ğ“ a, f (g y) = y) : HasFDerivAt g (f'.symm : F â†’L[ğ•œ] E) a ",":= by
  have : (fun x : F => g x - g a - f'.symm (x - a)) =O[ğ“ a]
      fun x : F => f' (g x - g a) - (x - a) := by
    refine ((f'.symm : F â†’L[ğ•œ] E).isBigO_comp _ _).congr (fun x => ?_) fun _ => rfl
    simp
  refine HasFDerivAtFilter.of_isLittleO <| this.trans_isLittleO ?_
  clear this
  refine ((hf.isLittleO.comp_tendsto hg).symm.congr' (hfg.mono ?_) .rfl).trans_isBigO ?_
  Â· intro p hp
    simp [hp, hfg.self_of_nhds]
  Â· refine ((hf.isBigO_sub_rev f'.antilipschitz).comp_tendsto hg).congr'
      (eventually_of_forall fun _ => rfl) (hfg.mono ?_)
    rintro p hp
    simp only [(Â· âˆ˜ Â·), hp, hfg.self_of_nhds]",refine theorem_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivAt_of_hasFDerivA
Mathlib/Topology/PartitionOfUnity.lean,PartitionOfUnity.exists_isSubordinate,exists_isSubordinate,47189ba3b5745e8b76312e34fe4a6c87e0d76e90,":= by
  rcases exists_subset_unionáµ¢_closure_subset hs ho (fun x _ => hf.point_finite x) hU with
    âŸ¨V, hsV, hVo, hVUâŸ©
  have hVU' : âˆ€ i, V i âŠ† U i := fun i => Subset.trans subset_closure (hVU i)
  rcases exists_subset_unionáµ¢_closure_subset hs hVo (fun x _ => (hf.subset hVU').point_finite x)
      hsV with
    âŸ¨W, hsW, hWo, hWVâŸ©
  choose f hfp hf0 hf1 hf01 using fun i =>
    h01 _ _ (isClosed_compl_iff.2 <| hVo i) isClosed_closure
      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))
  have hsupp : âˆ€ i, support (f i) âŠ† V i := fun i => support_subset_iff'.2 (hf0 i)
  refine' âŸ¨âŸ¨f, hf.subset fun i => Subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1,
      fun i x => (hf01 i x).2, fun x hx => _âŸ©,
    hfp, fun i => Subset.trans (closure_mono (hsupp i)) (hVU i)âŸ©
  rcases mem_unionáµ¢.1 (hsW hx) with âŸ¨i, hiâŸ©
  exact âŸ¨i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)âŸ©","error:  unknown identifier 'exists_subset_unionáµ¢_closure_subset'
error:  rcases tactic failed: xâœ : ?m.93115 is not an inductive datatype","theorem exists_isSubordinate_of_locallyFinite_of_prop [NormalSpace X] (p : (X â†’ â„) â†’ Prop)
    (h01 : âˆ€ s t, IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’
      âˆƒ f : C(X, â„), p f âˆ§ EqOn f 0 s âˆ§ EqOn f 1 t âˆ§ âˆ€ x, f x âˆˆ Icc (0 : â„) 1)
    (hs : IsClosed s) (U : Î¹ â†’ Set X) (ho : âˆ€ i, IsOpen (U i)) (hf : LocallyFinite U)
    (hU : s âŠ† â‹ƒ i, U i) : âˆƒ f : BumpCovering Î¹ X s, (âˆ€ i, p (f i)) âˆ§ f.IsSubordinate U ",":= by
  rcases exists_subset_iUnion_closure_subset hs ho (fun x _ => hf.point_finite x) hU with
    âŸ¨V, hsV, hVo, hVUâŸ©
  have hVU' : âˆ€ i, V i âŠ† U i := fun i => Subset.trans subset_closure (hVU i)
  rcases exists_subset_iUnion_closure_subset hs hVo (fun x _ => (hf.subset hVU').point_finite x)
      hsV with
    âŸ¨W, hsW, hWo, hWVâŸ©
  choose f hfp hf0 hf1 hf01 using fun i =>
    h01 _ _ (isClosed_compl_iff.2 <| hVo i) isClosed_closure
      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))
  have hsupp : âˆ€ i, support (f i) âŠ† V i := fun i => support_subset_iff'.2 (hf0 i)
  refine âŸ¨âŸ¨f, hf.subset fun i => Subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1,
      fun i x => (hf01 i x).2, fun x hx => ?_âŸ©,
    hfp, fun i => Subset.trans (closure_mono (hsupp i)) (hVU i)âŸ©
  rcases mem_iUnion.1 (hsW hx) with âŸ¨i, hiâŸ©
  exact âŸ¨i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)âŸ©","refine âŸ¨exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_o"
Mathlib/RingTheory/UniqueFactorizationDomain.lean,Associates.count_pow,count_pow,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' k with n h
  Â· rw [pow_zero, factors_one, Nat.zero_eq, zero_mul, count_zero hp]
  Â· rw [pow_succ', count_mul ha (pow_ne_zero _ ha) hp, h, Nat.succ_eq_add_one]
    ring","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
case zero
Î± : Type u_1
instâœâµ : CancelCommMonoidWithZero Î±
instâœâ´ : UniqueFactorizationMonoid Î±
instâœÂ³ : DecidableEq (Associates Î±)
instâœÂ² : (p : Associates Î±) â†’ Decidable (Irreducible p)
instâœÂ¹ : Nontrivial Î±
instâœ : DecidableEq (Associates Î±)
a : Associates Î±
ha : a â‰  0
p : Associates Î±
hp : Irreducible p
âŠ¢ p.count 0 = 0 * p.count a.factors
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ
Î± : Type u_1
instâœâµ : CancelCommMonoidWithZero Î±
instâœâ´ : UniqueFactorizationMonoid Î±
instâœÂ³ : DecidableEq (Associates Î±)
instâœÂ² : (p : Associates Î±) â†’ Decidable (Irreducible p)
instâœÂ¹ : Nontrivial Î±
instâœ : DecidableEq (Associates Î±)
a : Associates Î±
ha : a â‰  0
p : Associates Î±
hp : Irreducible p
n : â„•
h : p.count (a ^ n).factors = n * p.count a.factors
âŠ¢ p.count a.factors + n * p.count a.factors = (n + 1) * p.count a.factors","theorem count_pow [Nontrivial Î±] [DecidableEq (Associates Î±)] {a : Associates Î±} (ha : a â‰  0)
    {p : Associates Î±} (hp : Irreducible p) (k : â„•) :
    count p (a ^ k).factors = k * count p a.factors ",":= by
  induction' k with n h
  Â· rw [pow_zero, factors_one, zero_mul, count_zero hp]
  Â· rw [pow_succ', count_mul ha (pow_ne_zero _ ha) hp, h]
    ring","rw [factors_prod, factors_prod, factors_prod, factors_prod, factors_prod, factors_prod]"
Mathlib/LinearAlgebra/Basis.lean,union_support_maximal_linearIndependent_eq_range_basis,union_support_maximal_linearIndependent_eq_range_basis,b09462282225ca03a37b7e6afde435d1ab7552ef,":= by
  by_contra h
  simp only [â† Ne.def, ne_univ_iff_exists_not_mem, mem_iUnion, not_exists_not,
    Finsupp.mem_support_iff, Finset.mem_coe] at h
  obtain âŸ¨b', wâŸ© := h
  let v' : Option Îº â†’ M := fun o => o.elim (b b') v
  have r : range v âŠ† range v' := by
    rintro - âŸ¨k, rflâŸ©
    use some k
    rfl
  have r' : b b' âˆ‰ range v := by
    rintro âŸ¨k, pâŸ©
    simpa [w] using congr_arg (fun m => (b.repr m) b') p
  have r'' : range v â‰  range v' := by
    intro e
    have p : b b' âˆˆ range v' := by
      use none
      rfl
    rw [â† e] at p
    exact r' p
  have i' : LinearIndependent R ((â†‘) : range v' â†’ M) := by
    apply LinearIndependent.to_subtype_range
    rw [linearIndependent_iff]
    intro l z
    rw [Finsupp.total_option] at z
    simp only [Option.elim'] at z
    change _ + Finsupp.total Îº M R v l.some = 0 at z
    have lâ‚€ : l none = 0 := by
      rw [â† eq_neg_iff_add_eq_zero] at z
      replace z := neg_eq_iff_eq_neg.mpr z
      apply_fun fun x => b.repr x b' at z
      simp only [repr_self, LinearEquiv.map_smul, mul_one, Finsupp.single_eq_same, Pi.neg_apply,
        Finsupp.smul_single', LinearEquiv.map_neg, Finsupp.coe_neg] at z
      erw [FunLike.congr_fun (Finsupp.apply_total R (b.repr : M â†’â‚—[R] Î¹ â†’â‚€ R) v l.some) b'] at z
      simpa [Finsupp.total_apply, w] using z
    have lâ‚ : l.some = 0 := by
      rw [lâ‚€, zero_smul, zero_add] at z
      exact linearIndependent_iff.mp i _ z
    ext (_ | a)
    Â· simp only [lâ‚€, Finsupp.coe_zero, Pi.zero_apply]
    Â· erw [FunLike.congr_fun lâ‚ a]
      simp only [Finsupp.coe_zero, Pi.zero_apply]
  rw [LinearIndependent.Maximal] at m
  specialize m (range v') i' r
  exact r'' m","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.791054 â†’ ?m.791054 â†’ Prop
error:  simp made no progress","theorem union_support_maximal_linearIndependent_eq_range_basis {Î¹ : Type w} (b : Basis Î¹ R M)
    {Îº : Type w'} (v : Îº â†’ M) (i : LinearIndependent R v) (m : i.Maximal) :
    â‹ƒ k, ((b.repr (v k)).support : Set Î¹) = Set.univ ",":= by
  by_contra h
  simp only [â† Ne.eq_def, ne_univ_iff_exists_not_mem, mem_iUnion, not_exists_not,
    Finsupp.mem_support_iff, Finset.mem_coe] at h
  obtain âŸ¨b', wâŸ© := h
  let v' : Option Îº â†’ M := fun o => o.elim (b b') v
  have r : range v âŠ† range v' := by
    rintro - âŸ¨k, rflâŸ©
    use some k
    simp only [v', Option.elim_some]
  have r' : b b' âˆ‰ range v := by
    rintro âŸ¨k, pâŸ©
    simpa [w] using congr_arg (fun m => (b.repr m) b') p
  have r'' : range v â‰  range v' := by
    intro e
    have p : b b' âˆˆ range v' := by
      use none
      simp only [v', Option.elim_none]
    rw [â† e] at p
    exact r' p
  have i' : LinearIndependent R ((â†‘) : range v' â†’ M) := by
    apply LinearIndependent.to_subtype_range
    rw [linearIndependent_iff]
    intro l z
    rw [Finsupp.total_option] at z
    simp only [v', Option.elim'] at z
    change _ + Finsupp.total Îº M R v l.some = 0 at z
    have lâ‚€ : l none = 0 := by
      rw [â† eq_neg_iff_add_eq_zero] at z
      replace z := neg_eq_iff_eq_neg.mpr z
      apply_fun fun x => b.repr x b' at z
      simp only [repr_self, map_smul, mul_one, Finsupp.single_eq_same, Pi.neg_apply,
        Finsupp.smul_single', map_neg, Finsupp.coe_neg] at z
      erw [DFunLike.congr_fun (Finsupp.apply_total R (b.repr : M â†’â‚—[R] Î¹ â†’â‚€ R) v l.some) b'] at z
      simpa [Finsupp.total_apply, w] using z
    have lâ‚ : l.some = 0 := by
      rw [lâ‚€, zero_smul, zero_add] at z
      exact linearIndependent_iff.mp i _ z
    ext (_ | a)
    Â· simp only [lâ‚€, Finsupp.coe_zero, Pi.zero_apply]
    Â· erw [DFunLike.congr_fun lâ‚ a]
      simp only [Finsupp.coe_zero, Pi.zero_apply]
  rw [LinearIndependent.Maximal] at m
  specialize m (range v') i' r
  exact r'' m",simp [Set.eq_univ_iff_forall]
Mathlib/GroupTheory/PGroup.lean,IsPGroup.index,index,034139f67d1e53664a78cb1986579908d1f2fa67,":= by
  haveI := H.normalCore.fintypeQuotientOfFiniteIndex
  obtain âŸ¨n, hnâŸ© := iff_card.mp (hG.to_quotient H.normalCore)
  rw [â† Nat.card_eq_fintype_card] at hn
  obtain âŸ¨k, _, hk2âŸ© :=
    (Nat.dvd_prime_pow hp.out).mp
      ((congr_arg _ (H.normalCore.index_eq_card.trans hn)).mp
        (Subgroup.index_dvd_of_le H.normalCore_le))
  exact âŸ¨k, hk2âŸ©","error:  application type mismatch
  Eq.trans (Subgroup.index_eq_card H.normalCore) hn
argument
  hn
has type
  Nat.card (G â§¸ H.normalCore) = p ^ n : Prop
but is expected to have type
  card (G â§¸ H.normalCore) = ?m.18288 : Prop
error:  invalid field notation, function 'IsPGroup.index' does not have argument with type (IsPGroup ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'IsPGroup.card_orbit' does not have argument with type (IsPGroup ...) that can be used, it must be explicit or implicit with a unique name
error:  rcases tactic failed: xâœ : ?m.53343 is not an inductive datatype
error:  invalid field notation, function 'IsPGroup.card_modEq_card_fixedPoints' does not have argument with type (IsPGroup ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'IsPGroup.card_modEq_card_fixedPoints' does not have argument with type (IsPGroup ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'IsPGroup.exists_fixed_point_of_prime_dvd_card_of_fixed_point' does not have argument with type (IsPGroup ...) that can be used, it must be explicit or implicit with a unique name
error:  unsolved goals
case intro
p : â„•
G : Type u_1
instâœâ´ : Group G
hG : IsPGroup p G
hp : Fact (Nat.Prime p)
Î± : Type u_2
instâœÂ³ : MulAction G Î±
instâœÂ² : Fintype Î±
instâœÂ¹ : Nontrivial G
instâœ : Finite G
valâœ : Fintype G
âŠ¢ Nontrivial â†¥(Subgroup.center G)
error:  function expected at
  center_nontrivial
term has type
  Nontrivial â†¥(Subgroup.center ?m.59988)
error:  unsolved goals
p : â„•
G : Type u_1
instâœâ´ : Group G
hG : IsPGroup p G
hp : Fact (Nat.Prime p)
Î± : Type u_2
instâœÂ³ : MulAction G Î±
instâœÂ² : Fintype Î±
instâœÂ¹ : Nontrivial G
instâœ : Finite G
âŠ¢ âŠ¥ < Subgroup.center G
error:  function expected at
  center_nontrivial
term has type
  Nontrivial â†¥(center ?m.83782)","theorem index (H : Subgroup G) [H.FiniteIndex] : âˆƒ n : â„•, H.index = p ^ n ",":= by
  haveI := H.normalCore.fintypeQuotientOfFiniteIndex
  obtain âŸ¨n, hnâŸ© := iff_card.mp (hG.to_quotient H.normalCore)
  obtain âŸ¨k, _, hk2âŸ© :=
    (Nat.dvd_prime_pow hp.out).mp
      ((congr_arg _ (H.normalCore.index_eq_card.trans hn)).mp
        (Subgroup.index_dvd_of_le H.normalCore_le))
  exact âŸ¨k, hk2âŸ©","obtain âŸ¨n, hnâŸ© := H"
Mathlib/Algebra/Order/CauSeq/BigOperators.lean,IsCauSeq.geo_series,geo_series,03690a4c3252f422184189d0b6a6dd8d1c55d551,":= by
  have hx1' : abv x â‰  1 := fun h â†¦ by simp [h, lt_irrefl] at hx1
  refine of_abv ?_
  simp only [abv_pow abv, geom_sum_eq hx1']
  conv in _ / _ => rw [â† neg_div_neg_eq, neg_sub, neg_sub]
  have : 0 < 1 - abv x := sub_pos.2 hx1
  refine @of_mono_bounded _ _ _ _ _ ((1 : Î±) / (1 - abv x)) 0 ?_ ?_
  Â· intro n _
    rw [abs_of_nonneg]
    Â· gcongr
      exact sub_le_self _ (abv_pow abv x n â–¸ abv_nonneg _ _)
    refine div_nonneg (sub_nonneg.2 ?_) (sub_nonneg.2 <| le_of_lt hx1)
    exact pow_le_one _ (by positivity) hx1.le
  Â· intro n _
    rw [â† one_mul (abv x ^ n), pow_succ']
    gcongr","error:  type mismatch
  1 / (1 - abv x)
has type
  Î± : outParam (Type u_1)
but is expected to have type
  â„• : Type","lemma geo_series [Nontrivial Î²] (x : Î²) (hx1 : abv x < 1) :
    IsCauSeq abv fun n â†¦ âˆ‘ m âˆˆ range n, x ^ m ",":= by
  have hx1' : abv x â‰  1 := fun h â†¦ by simp [h, lt_irrefl] at hx1
  refine of_abv ?_
  simp only [abv_pow abv, geom_sum_eq hx1']
  conv in _ / _ => rw [â† neg_div_neg_eq, neg_sub, neg_sub]
  have : 0 < 1 - abv x := sub_pos.2 hx1
  refine @of_mono_bounded _ _ _ _ ((1 : Î±) / (1 - abv x)) 0 ?_ ?_
  Â· intro n _
    rw [abs_of_nonneg]
    Â· gcongr
      exact sub_le_self _ (abv_pow abv x n â–¸ abv_nonneg _ _)
    refine div_nonneg (sub_nonneg.2 ?_) (sub_nonneg.2 <| le_of_lt hx1)
    exact pow_le_one _ (by positivity) hx1.le
  Â· intro n _
    rw [â† one_mul (abv x ^ n), pow_succ']
    gcongr",refine IsCauSeq.isCauSeq_iff'.1 IsCauSeq.isCauSeq_iff'.1 IsCauSeq.isCauSeq ?_ ?_
Mathlib/Combinatorics/SimpleGraph/Clique.lean,SimpleGraph.cliqueSet_map,cliqueSet_map,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  ext s
  constructor
  Â· rintro âŸ¨hs, rflâŸ©
    have hs' : (s.preimage f <| f.injective.injOn _).map f = s := by
      classical
      rw [map_eq_image, image_preimage, filter_true_of_mem]
      rintro a ha
      obtain âŸ¨b, hb, hbaâŸ© := exists_mem_ne (hn.lt_of_le' <| Finset.card_pos.2 âŸ¨a, haâŸ©) a
      obtain âŸ¨c, _, _, hc, _âŸ© := hs ha hb hba.symm
      exact âŸ¨c, hcâŸ©
    refine âŸ¨s.preimage f <| f.injective.injOn _, âŸ¨?_, by rw [â† card_map f, hs']âŸ©, hs'âŸ©
    rw [coe_preimage]
    exact fun a ha b hb hab => map_adj_apply.1 (hs ha hb <| f.injective.ne hab)
  Â· rintro âŸ¨s, hs, rflâŸ©
    exact hs.map","error:  application type mismatch
  s.preimage â‡‘f â‹¯
argument
  Injective.injOn (Embedding.injective f) ?m.159552
has type
  âˆ€ â¦ƒxâ‚‚ : Î±â¦„, xâ‚‚ âˆˆ ?m.159550 â†’ f ?m.159551 = f xâ‚‚ â†’ ?m.159551 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn (â‡‘f) (â‡‘f â»Â¹' â†‘s) : Prop
error:  application type mismatch
  s.preimage â‡‘f â‹¯
argument
  Injective.injOn (Embedding.injective f) ?m.161759
has type
  âˆ€ â¦ƒxâ‚‚ : Î±â¦„, xâ‚‚ âˆˆ ?m.161757 â†’ f ?m.161758 = f xâ‚‚ â†’ ?m.161758 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn (â‡‘f) (â‡‘f â»Â¹' â†‘s) : Prop","theorem cliqueSet_map (hn : n â‰  1) (G : SimpleGraph Î±) (f : Î± â†ª Î²) :
    (G.map f).cliqueSet n = map f '' G.cliqueSet n ",":= by
  ext s
  constructor
  Â· rintro âŸ¨hs, rflâŸ©
    have hs' : (s.preimage f f.injective.injOn).map f = s := by
      classical
      rw [map_eq_image, image_preimage, filter_true_of_mem]
      rintro a ha
      obtain âŸ¨b, hb, hbaâŸ© := exists_mem_ne (hn.lt_of_le' <| Finset.card_pos.2 âŸ¨a, haâŸ©) a
      obtain âŸ¨c, _, _, hc, _âŸ© := hs ha hb hba.symm
      exact âŸ¨c, hcâŸ©
    refine âŸ¨s.preimage f f.injective.injOn, âŸ¨?_, by rw [â† card_map f, hs']âŸ©, hs'âŸ©
    rw [coe_preimage]
    exact fun a ha b hb hab => map_adj_apply.1 (hs ha hb <| f.injective.ne hab)
  Â· rintro âŸ¨s, hs, rflâŸ©
    exact hs.map","rw [cliqueSet_map, cliqueSet_map, cliqueSet_map]"
Mathlib/Topology/Connected/TotallyDisconnected.lean,isTotallyDisconnected_of_isClopen_set,isTotallyDisconnected_of_isClopen_set,5192777c94aec06289e492ce206d68fbbe72572c,":= by
  rintro S - hS
  unfold Set.Subsingleton
  by_contra! h_contra
  rcases h_contra with âŸ¨x, hx, y, hy, hxyâŸ©
  obtain âŸ¨U, hU, hxU, hyUâŸ© := hX hxy
  specialize
    hS U Uá¶œ hU.1 hU.compl.1 (fun a _ => em (a âˆˆ U)) âŸ¨x, hx, hxUâŸ© âŸ¨y, hy, hyUâŸ©
  rw [inter_compl_self, Set.inter_empty] at hS
  exact Set.not_nonempty_empty hS","error:  application type mismatch
  hS U Uá¶œ hU.left
argument
  hU.left
has type
  IsClosed U : Prop
but is expected to have type
  IsOpen U : Prop","theorem isTotallyDisconnected_of_isClopen_set {X : Type*} [TopologicalSpace X]
    (hX : Pairwise fun x y => âˆƒ (U : Set X), IsClopen U âˆ§ x âˆˆ U âˆ§ y âˆ‰ U) :
    IsTotallyDisconnected (Set.univ : Set X) ",":= by
  rintro S - hS
  unfold Set.Subsingleton
  by_contra! h_contra
  rcases h_contra with âŸ¨x, hx, y, hy, hxyâŸ©
  obtain âŸ¨U, hU, hxU, hyUâŸ© := hX hxy
  specialize
    hS U Uá¶œ hU.2 hU.compl.2 (fun a _ => em (a âˆˆ U)) âŸ¨x, hx, hxUâŸ© âŸ¨y, hy, hyUâŸ©
  rw [inter_compl_self, Set.inter_empty] at hS
  exact Set.not_nonempty_empty hS",refine IsTotallyDisconnected.isTotallyDisconnected_iff.mpr ?_
Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean,Real.Gamma_mul_Gamma_one_sub,Gamma_mul_Gamma_one_sub,916c75c1d9f2fcdcd11d5d5b32f69afcc94bb9c4,":= by
  have pi_ne : (Ï€ : â„‚) â‰  0 := Complex.ofReal_ne_zero.mpr pi_ne_zero
  by_cases hs : sin (â†‘Ï€ * z) = 0
  Â· 
    rw [hs, div_zero]
    rw [â† neg_eq_zero, â† Complex.sin_neg, â† mul_neg, Complex.sin_eq_zero_iff, mul_comm] at hs
    obtain âŸ¨k, hkâŸ© := hs
    rw [mul_eq_mul_right_iff, eq_false (ofReal_ne_zero.mpr pi_pos.ne'), or_false_iff,
      neg_eq_iff_eq_neg] at hk
    rw [hk]
    cases k
    Â· rw [Int.ofNat_eq_coe, Int.cast_ofNat, Complex.Gamma_neg_nat_eq_zero, zero_mul]
    Â· rw [Int.cast_negSucc, neg_neg, Nat.cast_add, Nat.cast_one, add_comm, sub_add_cancel',
        Complex.Gamma_neg_nat_eq_zero, MulZeroClass.mul_zero]
  refine' tendsto_nhds_unique ((GammaSeq_tendsto_Gamma z).mul (GammaSeq_tendsto_Gamma <| 1 - z)) _
  have : â†‘Ï€ / sin (â†‘Ï€ * z) = 1 * (Ï€ / sin (Ï€ * z)) := by rw [one_mul]
  convert Tendsto.congr' ((eventually_ne_atTop 0).mp (eventually_of_forall fun n hn =>
    (GammaSeq_mul z hn).symm)) (Tendsto.mul _ _)
  Â· convert tendsto_coe_nat_div_add_atTop (1 - z) using 1; ext1 n; rw [add_sub_assoc]
  Â· have : â†‘Ï€ / sin (â†‘Ï€ * z) = 1 / (sin (Ï€ * z) / Ï€) := by field_simp
    convert tendsto_const_nhds.div _ (div_ne_zero hs pi_ne)
    rw [â† tendsto_mul_iff_of_ne_zero tendsto_const_nhds pi_ne, div_mul_cancel _ pi_ne]
    convert tendsto_euler_sin_prod z using 1
    ext1 n; rw [mul_comm, â† mul_assoc]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â†‘(OfNat.ofNat ?n)
case pos.intro.ofNat
z : â„‚
pi_ne : â†‘Ï€ â‰  0
aâœ : â„•
hk : z = -â†‘(Int.ofNat aâœ)
âŠ¢ Gamma (-â†‘â†‘aâœ) * Gamma (1 - -â†‘â†‘aâœ) = 0
warning:  `sub_add_cancel'` has been deprecated, use `sub_add_cancel_left` instead
error:  unknown identifier 'tendsto_coe_nat_div_add_atTop'
error:  no goals to be solved
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.125750 / ?m.125764 * ?m.125764
case neg.convert_4.convert_5
z : â„‚
pi_ne : â†‘Ï€ â‰  0
hs : Â¬sin (â†‘Ï€ * z) = 0
thisâœ : â†‘Ï€ / sin (â†‘Ï€ * z) = 1 * (â†‘Ï€ / sin (â†‘Ï€ * z))
this : â†‘Ï€ / sin (â†‘Ï€ * z) = 1 / (sin (â†‘Ï€ * z) / â†‘Ï€)
âŠ¢ Tendsto (fun n â†¦ (z * âˆ j âˆˆ Finset.range n, (1 - z ^ 2 / (â†‘j + 1) ^ 2)) * â†‘Ï€) atTop (ğ“ (sin (â†‘Ï€ * z) / â†‘Ï€ * â†‘Ï€))
error:  application type mismatch
  div_mul_cancel ?m.125750 pi_ne
argument
  pi_ne
has type
  â†‘Ï€ â‰  0 : Prop
but is expected to have type
  ?m.125748 : Type ?u.125747",theorem Gamma_mul_Gamma_one_sub (z : â„‚) : Gamma z * Gamma (1 - z) = Ï€ / sin (Ï€ * z) ,":= by
  have pi_ne : (Ï€ : â„‚) â‰  0 := Complex.ofReal_ne_zero.mpr pi_ne_zero
  by_cases hs : sin (â†‘Ï€ * z) = 0
  Â· 
    rw [hs, div_zero]
    rw [â† neg_eq_zero, â† Complex.sin_neg, â† mul_neg, Complex.sin_eq_zero_iff, mul_comm] at hs
    obtain âŸ¨k, hkâŸ© := hs
    rw [mul_eq_mul_right_iff, eq_false (ofReal_ne_zero.mpr pi_pos.ne'), or_false_iff,
      neg_eq_iff_eq_neg] at hk
    rw [hk]
    cases k
    Â· rw [Int.ofNat_eq_coe, Int.cast_natCast, Complex.Gamma_neg_nat_eq_zero, zero_mul]
    Â· rw [Int.cast_negSucc, neg_neg, Nat.cast_add, Nat.cast_one, add_comm, sub_add_cancel_left,
        Complex.Gamma_neg_nat_eq_zero, mul_zero]
  refine tendsto_nhds_unique ((GammaSeq_tendsto_Gamma z).mul (GammaSeq_tendsto_Gamma <| 1 - z)) ?_
  have : â†‘Ï€ / sin (â†‘Ï€ * z) = 1 * (Ï€ / sin (Ï€ * z)) := by rw [one_mul]
  convert Tendsto.congr' ((eventually_ne_atTop 0).mp (eventually_of_forall fun n hn =>
    (GammaSeq_mul z hn).symm)) (Tendsto.mul _ _)
  Â· convert tendsto_natCast_div_add_atTop (1 - z) using 1; ext1 n; rw [add_sub_assoc]
  Â· have : â†‘Ï€ / sin (â†‘Ï€ * z) = 1 / (sin (Ï€ * z) / Ï€) := by field_simp
    convert tendsto_const_nhds.div _ (div_ne_zero hs pi_ne)
    rw [â† tendsto_mul_iff_of_ne_zero tendsto_const_nhds pi_ne, div_mul_cancelâ‚€ _ pi_ne]
    convert tendsto_euler_sin_prod z using 1
    ext1 n; rw [mul_comm, â† mul_assoc]","rw [Gamma_mul_Gamma_one_sub, Gamma_mul_Gamma_one_sub, Gamma_mul_Gamma_one_sub,
  Gamma_mul_Gamma_one_sub]"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,IsometryEquiv.hausdorffMeasure_image,hausdorffMeasure_image,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine' iSup_le fun R => iSup_le fun hR => _
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine' ENNReal.tsum_le_tsum fun n => _
      simp only [iSup_le_iff, nonempty_image_iff]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left s) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","warning:  `Set.nonempty_image_iff` has been deprecated, use `Set.image_nonempty` instead
error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set X : Type u_2
but is expected to have type
  ?m.169595 âˆˆ t n âˆ© ?m.169594 : Prop
error:  simp made no progress","theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s ",":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","rw [â† hausdorffMeasure_image_le, hausdorffMeasure_image_le, hausdorffMeasure_image_le]"
Mathlib/CategoryTheory/Limits/Constructions/FiniteProductsOfBinaryProducts.lean,CategoryTheory.hasFiniteCoproducts_of_has_binary_and_initial,hasFiniteCoproducts_of_has_binary_and_initial,3fcb15f5aa08e5cd66d3eaa95fa51be7f9820348,":= by
  refine' âŸ¨fun n => âŸ¨fun K => _âŸ©âŸ©
  letI := has_coproduct_fin n fun n => K.obj âŸ¨nâŸ©
  let that : K â‰… Discrete.functor fun n => K.obj âŸ¨nâŸ© := Discrete.natIso fun âŸ¨iâŸ© => Iso.refl _
  apply @hasColimitOfIso _ _ _ _ _ _ this that","error:  unknown identifier 'has_coproduct_fin'
error:  unsolved goals
J : Type v
instâœâ´ : SmallCategory J
C : Type u
instâœÂ³ : Category.{v, u} C
D : Type u'
instâœÂ² : Category.{v', u'} D
instâœÂ¹ : HasBinaryCoproducts C
instâœ : HasInitial C
n : â„•
K : Discrete (Fin n) â¥¤ C
âŠ¢ HasColimit K",theorem hasFiniteCoproducts_of_has_binary_and_initial : HasFiniteCoproducts C ,":= by
  refine âŸ¨fun n => âŸ¨fun K => ?_âŸ©âŸ©
  letI := hasCoproduct_fin n fun n => K.obj âŸ¨nâŸ©
  let that : K â‰… Discrete.functor fun n => K.obj âŸ¨nâŸ© := Discrete.natIso fun âŸ¨iâŸ© => Iso.refl _
  apply @hasColimitOfIso _ _ _ _ _ _ this that",refiniteCoproducts_of_has_binary_and_initial hasFiniteCoproducts_of_has_binary_and_initial
Mathlib/Computability/Primrec.lean,Primrec.nat_casesOn',nat_casesOn',b912476b37f2ea41ee51af7e63439f4a769be095,":=
  nat_rec hf (hg.compâ‚‚ fst <| comp fst snd).toâ‚‚","error:  application type mismatch
  Primrecâ‚‚.compâ‚‚ hg fst
argument
  fst
has type
  Primrec Prod.fst : Prop
but is expected to have type
  Primrecâ‚‚ ?m.76368 : Prop","theorem nat_casesOn' {f : Î± â†’ Î²} {g : Î± â†’ â„• â†’ Î²} (hf : Primrec f) (hg : Primrecâ‚‚ g) :
    Primrecâ‚‚ fun a (n : â„•) => (n.casesOn (f a) (g a) : Î²) ",":=
  nat_rec hf <| hg.compâ‚‚ Primrecâ‚‚.left <| compâ‚‚ fst Primrecâ‚‚.right",induction' hf : Primrecâ‚‚ nat_casesOn' nat_casesOn' nat_casesOn' nat_casesOn' nat_casesOn' nat_casesOn' nat_casesOn' nat_casesOn'
Mathlib/Analysis/BoxIntegral/Integrability.lean,BoxIntegral.hasIntegralIndicatorConst,hasIntegralIndicatorConst,1b93076c86e6da5d0a25d3465e84d13bd9ccfcc8,":= by
  refine' HasIntegral.of_mul â€–yâ€– fun Îµ Îµ0 => _
  lift Îµ to â„â‰¥0 using Îµ0.le; rw [NNReal.coe_pos] at Îµ0
  have A : Î¼ (s âˆ© Box.Icc I) â‰  âˆ :=
    ((measure_mono <| Set.inter_subset_right _ _).trans_lt (I.measure_Icc_lt_top Î¼)).ne
  have B : Î¼ (s âˆ© I) â‰  âˆ :=
    ((measure_mono <| Set.inter_subset_right _ _).trans_lt (I.measure_coe_lt_top Î¼)).ne
  obtain âŸ¨F, hFs, hFc, hÎ¼FâŸ© : âˆƒ F, F âŠ† s âˆ© Box.Icc I âˆ§ IsClosed F âˆ§ Î¼ ((s âˆ© Box.Icc I) \ F) < Îµ :=
    (hs.inter I.measurableSet_Icc).exists_isClosed_diff_lt A (ENNReal.coe_pos.2 Îµ0).ne'
  obtain âŸ¨U, hsU, hUo, hUt, hÎ¼UâŸ© :
      âˆƒ U, s âˆ© Box.Icc I âŠ† U âˆ§ IsOpen U âˆ§ Î¼ U < âˆ âˆ§ Î¼ (U \ (s âˆ© Box.Icc I)) < Îµ :=
    (hs.inter I.measurableSet_Icc).exists_isOpen_diff_lt A (ENNReal.coe_pos.2 Îµ0).ne'
  have : âˆ€ x âˆˆ s âˆ© Box.Icc I, âˆƒ r : Ioi (0 : â„), closedBall x r âŠ† U := fun x hx => by
    rcases nhds_basis_closedBall.mem_iff.1 (hUo.mem_nhds <| hsU hx) with âŸ¨r, hrâ‚€, hrâŸ©
    exact âŸ¨âŸ¨r, hrâ‚€âŸ©, hrâŸ©
  choose! rs hrsU using this
  have : âˆ€ x âˆˆ Box.Icc I \ s, âˆƒ r : Ioi (0 : â„), closedBall x r âŠ† Fá¶œ := fun x hx => by
    obtain âŸ¨r, hrâ‚€, hrâŸ© :=
      nhds_basis_closedBall.mem_iff.1 (hFc.isOpen_compl.mem_nhds fun hx' => hx.2 (hFs hx').1)
    exact âŸ¨âŸ¨r, hrâ‚€âŸ©, hrâŸ©
  choose! rs' hrs'F using this
  set r : (Î¹ â†’ â„) â†’ Ioi (0 : â„) := s.piecewise rs rs'
  refine' âŸ¨fun _ => r, fun c => l.rCond_of_bRiemann_eq_false hl, fun c Ï€ hÏ€ hÏ€p => _âŸ©; rw [mul_comm]
  dsimp [integralSum]
  simp only [mem_closedBall, dist_eq_norm, â† indicator_const_smul_apply,
    sum_indicator_eq_sum_filter, â† sum_smul, â† sub_smul, norm_smul, Real.norm_eq_abs, â†
    Prepartition.filter_boxes, â† Prepartition.measure_iUnion_toReal]
  gcongr
  set t := (Ï€.filter (Ï€.tag Â· âˆˆ s)).iUnion
  change abs ((Î¼ t).toReal - (Î¼ (s âˆ© I)).toReal) â‰¤ Îµ
  have htU : t âŠ† U âˆ© I := by
    simp only [TaggedPrepartition.iUnion_def, iUnion_subset_iff, TaggedPrepartition.mem_filter,
      and_imp]
    refine' fun J hJ hJs x hx => âŸ¨hrsU _ âŸ¨hJs, Ï€.tag_mem_Icc JâŸ© _, Ï€.le_of_mem' J hJ hxâŸ©
    simpa only [s.piecewise_eq_of_mem _ _ hJs] using hÏ€.1 J hJ (Box.coe_subset_Icc hx)
  refine' abs_sub_le_iff.2 âŸ¨_, _âŸ©
  Â· refine' (ENNReal.le_toReal_sub B).trans (ENNReal.toReal_le_coe_of_le_coe _)
    refine' (tsub_le_tsub (measure_mono htU) le_rfl).trans (le_measure_diff.trans _)
    refine' (measure_mono fun x hx => _).trans hÎ¼U.le
    exact âŸ¨hx.1.1, fun hx' => hx.2 âŸ¨hx'.1, hx.1.2âŸ©âŸ©
  Â· have hÎ¼t : Î¼ t â‰  âˆ := ((measure_mono (htU.trans (inter_subset_left _ _))).trans_lt hUt).ne
    refine' (ENNReal.le_toReal_sub hÎ¼t).trans (ENNReal.toReal_le_coe_of_le_coe _)
    refine' le_measure_diff.trans ((measure_mono _).trans hÎ¼F.le)
    rintro x âŸ¨âŸ¨hxs, hxIâŸ©, hxtâŸ©
    refine' âŸ¨âŸ¨hxs, Box.coe_subset_Icc hxIâŸ©, fun hxF => hxt _âŸ©
    simp only [TaggedPrepartition.iUnion_def, TaggedPrepartition.mem_filter, Set.mem_iUnion,
      exists_prop]
    rcases hÏ€p x hxI with âŸ¨J, hJÏ€, hxJâŸ©
    refine' âŸ¨J, âŸ¨hJÏ€, _âŸ©, hxJâŸ©
    contrapose hxF
    refine' hrs'F _ âŸ¨Ï€.tag_mem_Icc J, hxFâŸ© _
    simpa only [s.piecewise_eq_of_not_mem _ _ hxF] using hÏ€.1 J hJÏ€ (Box.coe_subset_Icc hxJ)","error:  function expected at
  Set.inter_subset_right ?m.4422
term has type
  ?m.4421 âˆˆ ?m.4420
error:  function expected at
  Set.inter_subset_right ?m.5102
term has type
  ?m.5101 âˆˆ ?m.5100
error:  simp made no progress
error:  overloaded, errors 
  function expected at
    Finset.inter_subset_left ?m.29933
  term has type
    ?m.29932 âˆˆ ?m.29930
  
  function expected at
    Set.inter_subset_left ?m.30071
  term has type
    ?m.30070 âˆˆ ?m.30068
error:  simp made no progress","theorem hasIntegralIndicatorConst (l : IntegrationParams) (hl : l.bRiemann = false)
    {s : Set (Î¹ â†’ â„)} (hs : MeasurableSet s) (I : Box Î¹) (y : E) (Î¼ : Measure (Î¹ â†’ â„))
    [IsLocallyFiniteMeasure Î¼] :
    HasIntegral.{u, v, v} I l (s.indicator fun _ => y) Î¼.toBoxAdditive.toSMul
      ((Î¼ (s âˆ© I)).toReal â€¢ y) ",":= by
  refine HasIntegral.of_mul â€–yâ€– fun Îµ Îµ0 => ?_
  lift Îµ to â„â‰¥0 using Îµ0.le; rw [NNReal.coe_pos] at Îµ0
  have A : Î¼ (s âˆ© Box.Icc I) â‰  âˆ :=
    ((measure_mono Set.inter_subset_right).trans_lt (I.measure_Icc_lt_top Î¼)).ne
  have B : Î¼ (s âˆ© I) â‰  âˆ :=
    ((measure_mono Set.inter_subset_right).trans_lt (I.measure_coe_lt_top Î¼)).ne
  obtain âŸ¨F, hFs, hFc, hÎ¼FâŸ© : âˆƒ F, F âŠ† s âˆ© Box.Icc I âˆ§ IsClosed F âˆ§ Î¼ ((s âˆ© Box.Icc I) \ F) < Îµ :=
    (hs.inter I.measurableSet_Icc).exists_isClosed_diff_lt A (ENNReal.coe_pos.2 Îµ0).ne'
  obtain âŸ¨U, hsU, hUo, hUt, hÎ¼UâŸ© :
      âˆƒ U, s âˆ© Box.Icc I âŠ† U âˆ§ IsOpen U âˆ§ Î¼ U < âˆ âˆ§ Î¼ (U \ (s âˆ© Box.Icc I)) < Îµ :=
    (hs.inter I.measurableSet_Icc).exists_isOpen_diff_lt A (ENNReal.coe_pos.2 Îµ0).ne'
  have : âˆ€ x âˆˆ s âˆ© Box.Icc I, âˆƒ r : Ioi (0 : â„), closedBall x r âŠ† U := fun x hx => by
    rcases nhds_basis_closedBall.mem_iff.1 (hUo.mem_nhds <| hsU hx) with âŸ¨r, hrâ‚€, hrâŸ©
    exact âŸ¨âŸ¨r, hrâ‚€âŸ©, hrâŸ©
  choose! rs hrsU using this
  have : âˆ€ x âˆˆ Box.Icc I \ s, âˆƒ r : Ioi (0 : â„), closedBall x r âŠ† Fá¶œ := fun x hx => by
    obtain âŸ¨r, hrâ‚€, hrâŸ© :=
      nhds_basis_closedBall.mem_iff.1 (hFc.isOpen_compl.mem_nhds fun hx' => hx.2 (hFs hx').1)
    exact âŸ¨âŸ¨r, hrâ‚€âŸ©, hrâŸ©
  choose! rs' hrs'F using this
  set r : (Î¹ â†’ â„) â†’ Ioi (0 : â„) := s.piecewise rs rs'
  refine âŸ¨fun _ => r, fun c => l.rCond_of_bRiemann_eq_false hl, fun c Ï€ hÏ€ hÏ€p => ?_âŸ©; rw [mul_comm]
  dsimp [integralSum]
  simp only [mem_closedBall, dist_eq_norm, â† indicator_const_smul_apply,
    sum_indicator_eq_sum_filter, â† sum_smul, â† sub_smul, norm_smul, Real.norm_eq_abs, â†
    Prepartition.filter_boxes, â† Prepartition.measure_iUnion_toReal]
  gcongr
  set t := (Ï€.filter (Ï€.tag Â· âˆˆ s)).iUnion
  change abs ((Î¼ t).toReal - (Î¼ (s âˆ© I)).toReal) â‰¤ Îµ
  have htU : t âŠ† U âˆ© I := by
    simp only [t, TaggedPrepartition.iUnion_def, iUnion_subset_iff, TaggedPrepartition.mem_filter,
      and_imp]
    refine fun J hJ hJs x hx => âŸ¨hrsU _ âŸ¨hJs, Ï€.tag_mem_Icc JâŸ© ?_, Ï€.le_of_mem' J hJ hxâŸ©
    simpa only [r, s.piecewise_eq_of_mem _ _ hJs] using hÏ€.1 J hJ (Box.coe_subset_Icc hx)
  refine abs_sub_le_iff.2 âŸ¨?_, ?_âŸ©
  Â· refine (ENNReal.le_toReal_sub B).trans (ENNReal.toReal_le_coe_of_le_coe ?_)
    refine (tsub_le_tsub (measure_mono htU) le_rfl).trans (le_measure_diff.trans ?_)
    refine (measure_mono fun x hx => ?_).trans hÎ¼U.le
    exact âŸ¨hx.1.1, fun hx' => hx.2 âŸ¨hx'.1, hx.1.2âŸ©âŸ©
  Â· have hÎ¼t : Î¼ t â‰  âˆ := ((measure_mono (htU.trans inter_subset_left)).trans_lt hUt).ne
    refine (ENNReal.le_toReal_sub hÎ¼t).trans (ENNReal.toReal_le_coe_of_le_coe ?_)
    refine le_measure_diff.trans ((measure_mono ?_).trans hÎ¼F.le)
    rintro x âŸ¨âŸ¨hxs, hxIâŸ©, hxtâŸ©
    refine âŸ¨âŸ¨hxs, Box.coe_subset_Icc hxIâŸ©, fun hxF => hxt ?_âŸ©
    simp only [t, TaggedPrepartition.iUnion_def, TaggedPrepartition.mem_filter, Set.mem_iUnion]
    rcases hÏ€p x hxI with âŸ¨J, hJÏ€, hxJâŸ©
    refine âŸ¨J, âŸ¨hJÏ€, ?_âŸ©, hxJâŸ©
    contrapose hxF
    refine hrs'F _ âŸ¨Ï€.tag_mem_Icc J, hxFâŸ© ?_
    simpa only [r, s.piecewise_eq_of_not_mem _ _ hxF] using hÏ€.1 J hJÏ€ (Box.coe_subset_Icc hxJ)","rw [â† hasIntegralIndicatorConst_smul, â† hasIntegralIndicatorConst_smul, â† hasIntegralIndicatorConst]"
Mathlib/Topology/QuasiSeparated.lean,IsQuasiSeparated.image_of_embedding,IsQuasiSeparated.image_of_embedding,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  intro U V hU hU' hU'' hV hV' hV''
  convert
    (H (f â»Â¹' U) (f â»Â¹' V)
      ?_ (h.continuous.1 _ hU') ?_ ?_ (h.continuous.1 _ hV') ?_).image h.continuous
  Â· symm
    rw [â† Set.preimage_inter, Set.image_preimage_eq_inter_range, Set.inter_eq_left]
    exact (Set.inter_subset_left _ _).trans (hU.trans (Set.image_subset_range _ _))
  Â· intro x hx
    rw [â† (h.inj.injOn _).mem_image_iff (Set.subset_univ _) trivial]
    exact hU hx
  Â· rw [h.isCompact_iff]
    convert hU''
    rw [Set.image_preimage_eq_inter_range, Set.inter_eq_left]
    exact hU.trans (Set.image_subset_range _ _)
  Â· intro x hx
    rw [â† (h.inj.injOn _).mem_image_iff (Set.subset_univ _) trivial]
    exact hV hx
  Â· rw [h.isCompact_iff]
    convert hV''
    rw [Set.image_preimage_eq_inter_range, Set.inter_eq_left]
    exact hV.trans (Set.image_subset_range _ _)","error:  function expected at
  Set.inter_subset_left ?m.8690
term has type
  ?m.8689 âˆˆ ?m.8687
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Function.Injective.injOn h.inj ?m.8765
has type
  ?m.8766 âˆˆ ?m.8763 â†’ f ?m.8764 = f ?m.8766 â†’ ?m.8764 = ?m.8766
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.8768
case convert_1
Î± : Type u_1
Î² : Type u_2
instâœÂ¹ : TopologicalSpace Î±
instâœ : TopologicalSpace Î²
f : Î± â†’ Î²
s : Set Î±
H : IsQuasiSeparated s
h : Embedding f
U V : Set Î²
hU : U âŠ† f '' s
hU' : IsOpen U
hU'' : IsCompact U
hV : V âŠ† f '' s
hV' : IsOpen V
hV'' : IsCompact V
x : Î±
hx : x âˆˆ f â»Â¹' U
âŠ¢ x âˆˆ s
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Function.Injective.injOn h.inj ?m.9634
has type
  ?m.9635 âˆˆ ?m.9632 â†’ f ?m.9633 = f ?m.9635 â†’ ?m.9633 = ?m.9635
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.9637
case convert_3
Î± : Type u_1
Î² : Type u_2
instâœÂ¹ : TopologicalSpace Î±
instâœ : TopologicalSpace Î²
f : Î± â†’ Î²
s : Set Î±
H : IsQuasiSeparated s
h : Embedding f
U V : Set Î²
hU : U âŠ† f '' s
hU' : IsOpen U
hU'' : IsCompact U
hV : V âŠ† f '' s
hV' : IsOpen V
hV'' : IsCompact V
x : Î±
hx : x âˆˆ f â»Â¹' V
âŠ¢ x âˆˆ s","theorem IsQuasiSeparated.image_of_embedding {s : Set Î±} (H : IsQuasiSeparated s) (h : Embedding f) :
    IsQuasiSeparated (f '' s) ",":= by
  intro U V hU hU' hU'' hV hV' hV''
  convert
    (H (f â»Â¹' U) (f â»Â¹' V)
      ?_ (h.continuous.1 _ hU') ?_ ?_ (h.continuous.1 _ hV') ?_).image h.continuous
  Â· symm
    rw [â† Set.preimage_inter, Set.image_preimage_eq_inter_range, Set.inter_eq_left]
    exact Set.inter_subset_left.trans (hU.trans (Set.image_subset_range _ _))
  Â· intro x hx
    rw [â† h.inj.injOn.mem_image_iff (Set.subset_univ _) trivial]
    exact hU hx
  Â· rw [h.isCompact_iff]
    convert hU''
    rw [Set.image_preimage_eq_inter_range, Set.inter_eq_left]
    exact hU.trans (Set.image_subset_range _ _)
  Â· intro x hx
    rw [â† h.inj.injOn.mem_image_iff (Set.subset_univ _) trivial]
    exact hV hx
  Â· rw [h.isCompact_iff]
    convert hV''
    rw [Set.image_preimage_eq_inter_range, Set.inter_eq_left]
    exact hV.trans (Set.image_subset_range _ _)",refine IsQuasiSeparated.image_of_embedding (s := s) (H := IsQuasiSeparated.image_of_embedding s) ?_
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.Measure.noAtoms_hausdorff,noAtoms_hausdorff,ced4d3c0af763b9fd00166e49cf999cf46c891cc,":= by
  refine âŸ¨fun x => _âŸ©
  rw [â† nonpos_iff_eq_zero, hausdorffMeasure_apply]
  refine iSupâ‚‚_le fun Îµ _ => iInfâ‚‚_le_of_le (fun _ => {x}) _ <| iInf_le_of_le (fun _ => _) _
  Â· exact subset_iUnion (fun _ => {x} : â„• â†’ Set X) 0
  Â· simp only [EMetric.diam_singleton, zero_le]
  Â· simp [hd]","error:  don't know how to synthesize placeholder
context:
Î¹ : Type u_1
X : Type u_2
Y : Type u_3
instâœÂ³ : EMetricSpace X
instâœÂ² : EMetricSpace Y
instâœÂ¹ : MeasurableSpace X
instâœ : BorelSpace X
d : â„
hd : 0 < d
x : X
âŠ¢ Î¼H[d] {x} = 0
error:  unsolved goals
Î¹ : Type u_1
X : Type u_2
Y : Type u_3
instâœÂ³ : EMetricSpace X
instâœÂ² : EMetricSpace Y
instâœÂ¹ : MeasurableSpace X
instâœ : BorelSpace X
d : â„
hd : 0 < d
âŠ¢ NoAtoms Î¼H[d]",theorem noAtoms_hausdorff {d : â„} (hd : 0 < d) : NoAtoms (hausdorffMeasure d : Measure X) ,":= by
  refine âŸ¨fun x => ?_âŸ©
  rw [â† nonpos_iff_eq_zero, hausdorffMeasure_apply]
  refine iSupâ‚‚_le fun Îµ _ => iInfâ‚‚_le_of_le (fun _ => {x}) ?_ <| iInf_le_of_le (fun _ => ?_) ?_
  Â· exact subset_iUnion (fun _ => {x} : â„• â†’ Set X) 0
  Â· simp only [EMetric.diam_singleton, zero_le]
  Â· simp [hd]","simp only [noAtoms_hausdorff, noAtoms_hausdorff]"
Mathlib/Topology/Category/Stonean/Basic.lean,Profinite.projective_of_extrDisc,projective_of_extrDisc,7d5d6eb658906f2c7b67de823bc202579000fb2e,":= by
  show Projective (Stonean.toProfinite.obj âŸ¨X.toTop, inferInstanceâŸ©)
  exact inferInstance","error:  invalid field 'toTop', the environment does not contain 'Profinite.toTop'
  X
has type
  Profinite","lemma projective_of_extrDisc {X : Profinite.{u}} (hX : ExtremallyDisconnected X) :
    Projective X ",":= by
  show Projective (Stonean.toProfinite.obj âŸ¨X.toCompHausâŸ©)
  exact inferInstance",apply projective_of_extremallyDisconnected
Mathlib/Topology/UniformSpace/Basic.lean,ball_inter_left,ball_inter_left,f33a8c19a1c116af0ea9bb6af0c85b1ef25cb15f,":=
  ball_mono (inter_subset_left V W) x","warning:  @compRel does not have a doc string
warning:  uniformity does not have a doc string
error:  application type mismatch
  inter_subset_left V
argument
  V
has type
  Set (Î² Ã— Î²) : Type ub
but is expected to have type
  ?m.66165 âˆˆ ?m.66163 âˆ© ?m.66164 : Prop",theorem ball_inter_left (x : Î²) (V W : Set (Î² Ã— Î²)) : ball x (V âˆ© W) âŠ† ball x V ,":=
  ball_mono inter_subset_left x","rw [ball_inter_left, ball_inter_left]"
Mathlib/Analysis/InnerProductSpace/PiL2.lean,Orthonormal.exists_orthonormalBasis_extension,Orthonormal.exists_orthonormalBasis_extension,5648120293e005e7ed12dc634bf3094a1835c21b,":= by
  obtain âŸ¨uâ‚€, huâ‚€s, huâ‚€, huâ‚€_maxâŸ© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot huâ‚€] at huâ‚€_max
  have huâ‚€_finite : uâ‚€.Finite := huâ‚€.linearIndependent.setFinite
  let u : Finset E := huâ‚€_finite.toFinset
  let fu : â†¥u â‰ƒ â†¥uâ‚€ := huâ‚€_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal ğ•œ ((â†‘) : u â†’ E) := by simpa using huâ‚€.comp _ fu.injective
  refine' âŸ¨u, OrthonormalBasis.mkOfOrthogonalEqBot hu _, _, _âŸ©
  Â· simpa using huâ‚€_max
  Â· simpa using huâ‚€s
  Â· simp","error:  type mismatch
  hâœ
has type
  span ğ•œ uâ‚€ = âŠ¤ : Prop
but is expected to have type
  span ğ•œ â†‘u = âŠ¤ : Prop
error:  type mismatch
  hâœ
has type
  uâ‚€ âŠ‡ v : Prop
but is expected to have type
  v âŠ† â†‘u : Prop","theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal ğ•œ ((â†‘) : v â†’ E)) :
    âˆƒ (u : Finset E) (b : OrthonormalBasis u ğ•œ E), v âŠ† u âˆ§ â‡‘b = ((â†‘) : u â†’ E) ",":= by
  obtain âŸ¨uâ‚€, huâ‚€s, huâ‚€, huâ‚€_maxâŸ© := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot huâ‚€] at huâ‚€_max
  have huâ‚€_finite : uâ‚€.Finite := huâ‚€.linearIndependent.setFinite
  let u : Finset E := huâ‚€_finite.toFinset
  let fu : â†¥u â‰ƒ â†¥uâ‚€ := huâ‚€_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal ğ•œ ((â†‘) : u â†’ E) := by simpa using huâ‚€.comp _ fu.injective
  refine âŸ¨u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_, ?_âŸ©
  Â· simpa [u] using huâ‚€_max
  Â· simpa [u] using huâ‚€s
  Â· simp","rw [OrthonormalBasis.extension, OrthonormalBasis.extension]"
Mathlib/RingTheory/IntegralClosure.lean,isIntegral_of_smul_mem_submodule,isIntegral_of_smul_mem_submodule,b1cd52acffa53bca04a33ddc14a40b2a62ed4308,":= by
  let A' : Subalgebra R A :=
    { carrier := { x | âˆ€ n âˆˆ N, x â€¢ n âˆˆ N }
      mul_mem' := fun {a b} ha hb n hn => smul_smul a b n â–¸ ha _ (hb _ hn)
      one_mem' := fun n hn => (one_smul A n).symm â–¸ hn
      add_mem' := fun {a b} ha hb n hn => (add_smul a b n).symm â–¸ N.add_mem (ha _ hn) (hb _ hn)
      zero_mem' := fun n _hn => (zero_smul A n).symm â–¸ N.zero_mem
      algebraMap_mem' := fun r n hn => (algebraMap_smul A r n).symm â–¸ N.smul_mem r hn }
  let f : A' â†’â‚[R] Module.End R N :=
    AlgHom.ofLinearMap
      { toFun := fun x => (DistribMulAction.toLinearMap R M x).restrict x.prop
        map_add' := by intros x y; ext; exact add_smul _ _ _
        map_smul' := by intros r s; ext; apply smul_assoc }
      (by ext; apply one_smul)
      (by intros x y; ext; apply mul_smul)
  obtain âŸ¨a, haâ‚, haâ‚‚âŸ© : âˆƒ a âˆˆ N, a â‰  (0 : M) := by
    by_contra' h'
    apply hN
    rwa [eq_bot_iff]
  have : Function.Injective f := by
    show Function.Injective f.toLinearMap
    rw [â† LinearMap.ker_eq_bot, eq_bot_iff]
    intro s hs
    have : s.1 â€¢ a = 0 := congr_arg Subtype.val (LinearMap.congr_fun hs âŸ¨a, haâ‚âŸ©)
    exact Subtype.ext ((eq_zero_or_eq_zero_of_smul_eq_zero this).resolve_right haâ‚‚)
  show IsIntegral R (A'.val âŸ¨x, hxâŸ©)
  rw [isIntegral_algHom_iff A'.val Subtype.val_injective, â† isIntegral_algHom_iff f this]
  haveI : Module.Finite R N := by rwa [Module.finite_def, Submodule.fg_top]
  apply Module.End.isIntegral","error:  unknown tactic
error:  unsolved goals
R : Type u_1
A : Type u_2
B : Type u_3
S : Type u_4
instâœÂ¹â° : CommRing R
instâœâ¹ : CommRing A
instâœâ¸ : Ring B
instâœâ· : CommRing S
instâœâ¶ : Algebra R A
instâœâµ : Algebra R B
fâœ : R â†’+* S
M : Type u_5
instâœâ´ : AddCommGroup M
instâœÂ³ : Module R M
instâœÂ² : Module A M
instâœÂ¹ : IsScalarTower R A M
instâœ : NoZeroSMulDivisors A M
N : Submodule R M
hN : N â‰  âŠ¥
hN' : N.FG
x : A
hx : âˆ€ n âˆˆ N, x â€¢ n âˆˆ N
A' : Subalgebra R A :=
  { carrier := {x | âˆ€ n âˆˆ N, x â€¢ n âˆˆ N}, mul_mem' := â‹¯, one_mem' := â‹¯, add_mem' := â‹¯, zero_mem' := â‹¯,
    algebraMap_mem' := â‹¯ }
f : â†¥A' â†’â‚[R] Module.End R â†¥N :=
  AlgHom.ofLinearMap { toFun := fun x â†¦ (DistribMulAction.toLinearMap R M x).restrict â‹¯, map_add' := â‹¯, map_smul' := â‹¯ }
    â‹¯ â‹¯
âŠ¢ âˆƒ a âˆˆ N, a â‰  0
error:  unsolved goals
case intro.intro
R : Type u_1
A : Type u_2
B : Type u_3
S : Type u_4
instâœÂ¹â° : CommRing R
instâœâ¹ : CommRing A
instâœâ¸ : Ring B
instâœâ· : CommRing S
instâœâ¶ : Algebra R A
instâœâµ : Algebra R B
fâœ : R â†’+* S
M : Type u_5
instâœâ´ : AddCommGroup M
instâœÂ³ : Module R M
instâœÂ² : Module A M
instâœÂ¹ : IsScalarTower R A M
instâœ : NoZeroSMulDivisors A M
N : Submodule R M
hN : N â‰  âŠ¥
hN' : N.FG
x : A
hx : âˆ€ n âˆˆ N, x â€¢ n âˆˆ N
A' : Subalgebra R A :=
  { carrier := {x | âˆ€ n âˆˆ N, x â€¢ n âˆˆ N}, mul_mem' := â‹¯, one_mem' := â‹¯, add_mem' := â‹¯, zero_mem' := â‹¯,
    algebraMap_mem' := â‹¯ }
f : â†¥A' â†’â‚[R] Module.End R â†¥N :=
  AlgHom.ofLinearMap { toFun := fun x â†¦ (DistribMulAction.toLinearMap R M x).restrict â‹¯, map_add' := â‹¯, map_smul' := â‹¯ }
    â‹¯ â‹¯
a : M
haâ‚ : a âˆˆ N
haâ‚‚ : a â‰  0
âŠ¢ IsIntegral R x","theorem isIntegral_of_smul_mem_submodule {M : Type*} [AddCommGroup M] [Module R M] [Module A M]
    [IsScalarTower R A M] [NoZeroSMulDivisors A M] (N : Submodule R M) (hN : N â‰  âŠ¥) (hN' : N.FG)
    (x : A) (hx : âˆ€ n âˆˆ N, x â€¢ n âˆˆ N) : IsIntegral R x ",":= by
  let A' : Subalgebra R A :=
    { carrier := { x | âˆ€ n âˆˆ N, x â€¢ n âˆˆ N }
      mul_mem' := fun {a b} ha hb n hn => smul_smul a b n â–¸ ha _ (hb _ hn)
      one_mem' := fun n hn => (one_smul A n).symm â–¸ hn
      add_mem' := fun {a b} ha hb n hn => (add_smul a b n).symm â–¸ N.add_mem (ha _ hn) (hb _ hn)
      zero_mem' := fun n _hn => (zero_smul A n).symm â–¸ N.zero_mem
      algebraMap_mem' := fun r n hn => (algebraMap_smul A r n).symm â–¸ N.smul_mem r hn }
  let f : A' â†’â‚[R] Module.End R N :=
    AlgHom.ofLinearMap
      { toFun := fun x => (DistribMulAction.toLinearMap R M x).restrict x.prop
        map_add' := by intros x y; ext; exact add_smul _ _ _
        map_smul' := by intros r s; ext; apply smul_assoc }
      (by ext; apply one_smul)
      (by intros x y; ext; apply mul_smul)
  obtain âŸ¨a, haâ‚, haâ‚‚âŸ© : âˆƒ a âˆˆ N, a â‰  (0 : M) := by
    by_contra! h'
    apply hN
    rwa [eq_bot_iff]
  have : Function.Injective f := by
    show Function.Injective f.toLinearMap
    rw [â† LinearMap.ker_eq_bot, eq_bot_iff]
    intro s hs
    have : s.1 â€¢ a = 0 := congr_arg Subtype.val (LinearMap.congr_fun hs âŸ¨a, haâ‚âŸ©)
    exact Subtype.ext ((eq_zero_or_eq_zero_of_smul_eq_zero this).resolve_right haâ‚‚)
  show IsIntegral R (A'.val âŸ¨x, hxâŸ©)
  rw [isIntegral_algHom_iff A'.val Subtype.val_injective, â† isIntegral_algHom_iff f this]
  haveI : Module.Finite R N := by rwa [Module.finite_def, Submodule.fg_top]
  apply Algebra.IsIntegral.isIntegral",refine IsIntegral.theorem_isIntegral_of_smul_mem_submodule ?_
Mathlib/Topology/Algebra/Module/LinearPMap.lean,LinearPMap.inverse_isClosable_iff,inverse_isClosable_iff,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  constructor
  Â· intro âŸ¨f', hâŸ©
    rw [LinearMap.ker_eq_bot']
    intro âŸ¨x, hxâŸ© hx'
    simp only [Submodule.mk_eq_zero]
    rw [toFun_eq_coe, eq_comm, image_iff] at hx'
    have : (0, x) âˆˆ graph f'
    Â· rw [â† h, inverse_graph hf]
      rw [â† hf'.graph_closure_eq_closure_graph, â† SetLike.mem_coe,
        Submodule.topologicalClosure_coe] at hx'
      apply image_closure_subset_closure_image continuous_swap
      simp only [Set.mem_image, Prod.exists, Prod.swap_prod_mk, Prod.mk.injEq]
      exact âŸ¨x, 0, hx', rfl, rflâŸ©
    exact graph_fst_eq_zero_snd f' this rfl
  Â· intro h
    use f.closure.inverse
    exact (closure_inverse_graph hf hf' h).symm","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case mp
R : Type u_1
E : Type u_2
F : Type u_3
instâœÂ¹Â¹ : CommRing R
instâœÂ¹â° : AddCommGroup E
instâœâ¹ : AddCommGroup F
instâœâ¸ : Module R E
instâœâ· : Module R F
instâœâ¶ : TopologicalSpace E
instâœâµ : TopologicalSpace F
instâœâ´ : ContinuousAdd E
instâœÂ³ : ContinuousAdd F
instâœÂ² : TopologicalSpace R
instâœÂ¹ : ContinuousSMul R E
instâœ : ContinuousSMul R F
f : E â†’â‚—.[R] F
hf : LinearMap.ker f.toFun = âŠ¥
hf' : f.IsClosable
f' : F â†’â‚—.[R] E
h : f.inverse.graph.topologicalClosure = f'.graph
x : E
hx : x âˆˆ f.closure.domain
hx' : (x, 0) âˆˆ f.closure.graph
this : (0, x) âˆˆ f'.graph
âŠ¢ x = 0
error:  unsolved goals
case mpr
R : Type u_1
E : Type u_2
F : Type u_3
instâœÂ¹Â¹ : CommRing R
instâœÂ¹â° : AddCommGroup E
instâœâ¹ : AddCommGroup F
instâœâ¸ : Module R E
instâœâ· : Module R F
instâœâ¶ : TopologicalSpace E
instâœâµ : TopologicalSpace F
instâœâ´ : ContinuousAdd E
instâœÂ³ : ContinuousAdd F
instâœÂ² : TopologicalSpace R
instâœÂ¹ : ContinuousSMul R E
instâœ : ContinuousSMul R F
f : E â†’â‚—.[R] F
hf : LinearMap.ker f.toFun = âŠ¥
hf' : f.IsClosable
âŠ¢ LinearMap.ker f.closure.toFun = âŠ¥ â†’ f.inverse.IsClosable","theorem inverse_isClosable_iff (hf : LinearMap.ker f.toFun = âŠ¥) (hf' : f.IsClosable) :
    f.inverse.IsClosable â†” LinearMap.ker f.closure.toFun = âŠ¥ ",":= by
  constructor
  Â· intro âŸ¨f', hâŸ©
    rw [LinearMap.ker_eq_bot']
    intro âŸ¨x, hxâŸ© hx'
    simp only [Submodule.mk_eq_zero]
    rw [toFun_eq_coe, eq_comm, image_iff] at hx'
    have : (0, x) âˆˆ graph f' := by
      rw [â† h, inverse_graph hf]
      rw [â† hf'.graph_closure_eq_closure_graph, â† SetLike.mem_coe,
        Submodule.topologicalClosure_coe] at hx'
      apply image_closure_subset_closure_image continuous_swap
      simp only [Set.mem_image, Prod.exists, Prod.swap_prod_mk, Prod.mk.injEq]
      exact âŸ¨x, 0, hx', rfl, rflâŸ©
    exact graph_fst_eq_zero_snd f' this rfl
  Â· intro h
    use f.closure.inverse
    exact (closure_inverse_graph hf hf' h).symm","simp only [LinearMap.ker_eq_bot, LinearMap.ker_eq_bot_iff, LinearMap.ker_eq_bot]"
Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean,Polynomial.exists_partition_polynomial_aux,exists_partition_polynomial_aux,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  have hbÎµ : 0 < cardPowDegree b â€¢ Îµ := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hÎµ
  induction' n with n ih
  Â· refine' âŸ¨finZeroElim, finZeroElimâŸ©
  have anti_archim' : âˆ€ {i j k} {Îµ : â„},
    (cardPowDegree (A i % b - A j % b) : â„) < Îµ â†’
      (cardPowDegree (A j % b - A k % b) : â„) < Îµ â†’
        (cardPowDegree (A i % b - A k % b) : â„) < Îµ := by
    intro i j k Îµ
    simp_rw [â† Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain âŸ¨t', ht'âŸ© := ih (Fin.tail A)
  rsuffices âŸ¨j, hjâŸ© :
    âˆƒ j, âˆ€ i, t' i = j â†” (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· refine' âŸ¨Fin.cons j t', fun iâ‚€ iâ‚ => _âŸ©
    refine' Fin.cases _ (fun iâ‚€ => _) iâ‚€ <;> refine' Fin.cases _ (fun iâ‚ => _) iâ‚
    Â· simpa using hbÎµ
    Â· rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj iâ‚
    Â· rw [Fin.cons_succ, Fin.cons_zero]
      exact hj iâ‚€
    Â· rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' iâ‚€ iâ‚
  obtain âŸ¨j, hjâŸ© : âˆƒ j, âˆ€ i : Fin n,
      t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ := by
    by_contra! hg
    obtain âŸ¨jâ‚€, jâ‚, j_ne, approxâŸ© := exists_approx_polynomial hb hÎµ
      (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (hg j))))
    revert j_ne approx
    refine' Fin.cases _ (fun jâ‚€ => _) jâ‚€ <;>
      refine' Fin.cases (fun j_ne approx => _) (fun jâ‚ j_ne approx => _) jâ‚
    Â· exact absurd rfl j_ne
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg jâ‚)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le] at approx
      have := (Classical.choose_spec (hg jâ‚€)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne.def, Fin.succ_inj] at j_ne
      have : jâ‚€ = jâ‚ := (Classical.choose_spec (hg jâ‚€)).1.symm.trans
        (((ht' (Classical.choose (hg jâ‚€)) (Classical.choose (hg jâ‚))).mpr approx).trans
          (Classical.choose_spec (hg jâ‚)).1)
      contradiction
  by_cases exists_nonempty_j : âˆƒ j, (âˆƒ i, t' i = j) âˆ§
      âˆ€ i, t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· obtain âŸ¨j, âŸ¨i, hiâŸ©, hjâŸ© := exists_nonempty_j
    refine' âŸ¨j, fun i' => âŸ¨hj i', fun hi' => _root_.trans ((ht' _ _).mpr _) hiâŸ©âŸ©
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  refine' âŸ¨j, fun i => âŸ¨hj i, fun hi => _âŸ©âŸ©
  have := exists_nonempty_j âŸ¨t' i, âŸ¨i, rflâŸ©, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')âŸ©
  contradiction","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.81178 â†’ ?m.81178 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.81180
case intro.intro.intro.refine'_2.refine'_2
Fq : Type u_1
instâœÂ¹ : Fintype Fq
instâœ : Field Fq
Îµ : â„
hÎµ : 0 < Îµ
b : Fq[X]
hb : b â‰  0
hbÎµ : 0 < cardPowDegree b â€¢ Îµ
n : â„•
ih :
  âˆ€ (A : Fin n â†’ Fq[X]),
    âˆƒ t, âˆ€ (iâ‚€ iâ‚ : Fin n), t iâ‚€ = t iâ‚ â†” â†‘(cardPowDegree (A iâ‚ % b - A iâ‚€ % b)) < cardPowDegree b â€¢ Îµ
A : Fin (n + 1) â†’ Fq[X]
anti_archim' :
  âˆ€ {i j k : Fin (n + 1)} {Îµ : â„},
    â†‘(cardPowDegree (A i % b - A j % b)) < Îµ â†’
      â†‘(cardPowDegree (A j % b - A k % b)) < Îµ â†’ â†‘(cardPowDegree (A i % b - A k % b)) < Îµ
t' : Fin n â†’ Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š)
ht' : âˆ€ (iâ‚€ iâ‚ : Fin n), t' iâ‚€ = t' iâ‚ â†” â†‘(cardPowDegree (Fin.tail A iâ‚ % b - Fin.tail A iâ‚€ % b)) < cardPowDegree b â€¢ Îµ
hg :
  âˆ€ (j : Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š)),
    âˆƒ i, t' i = j âˆ§ cardPowDegree b â€¢ Îµ â‰¤ â†‘(cardPowDegree (A 0 % b - A i.succ % b))
jâ‚€âœ jâ‚âœ : Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š).succ
jâ‚€ jâ‚ : Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š)
j_ne : jâ‚€.succ â‰  jâ‚.succ
approx : â†‘(cardPowDegree (A (Classical.choose â‹¯).succ % b - A (Classical.choose â‹¯).succ % b)) < cardPowDegree b â€¢ Îµ
âŠ¢ False","theorem exists_partition_polynomial_aux (n : â„•) {Îµ : â„} (hÎµ : 0 < Îµ) {b : Fq[X]} (hb : b â‰  0)
    (A : Fin n â†’ Fq[X]) : âˆƒ t : Fin n â†’ Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log (Fintype.card Fq)âŒ‰â‚Š),
      âˆ€ iâ‚€ iâ‚ : Fin n, t iâ‚€ = t iâ‚ â†”
        (cardPowDegree (A iâ‚ % b - A iâ‚€ % b) : â„) < cardPowDegree b â€¢ Îµ ",":= by
  have hbÎµ : 0 < cardPowDegree b â€¢ Îµ := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hÎµ
  induction' n with n ih
  Â· refine âŸ¨finZeroElim, finZeroElimâŸ©
  have anti_archim' : âˆ€ {i j k} {Îµ : â„},
    (cardPowDegree (A i % b - A j % b) : â„) < Îµ â†’
      (cardPowDegree (A j % b - A k % b) : â„) < Îµ â†’
        (cardPowDegree (A i % b - A k % b) : â„) < Îµ := by
    intro i j k Îµ
    simp_rw [â† Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain âŸ¨t', ht'âŸ© := ih (Fin.tail A)
  rsuffices âŸ¨j, hjâŸ© :
    âˆƒ j, âˆ€ i, t' i = j â†” (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· refine âŸ¨Fin.cons j t', fun iâ‚€ iâ‚ => ?_âŸ©
    refine Fin.cases ?_ (fun iâ‚€ => ?_) iâ‚€ <;> refine Fin.cases ?_ (fun iâ‚ => ?_) iâ‚
    Â· simpa using hbÎµ
    Â· rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj iâ‚
    Â· rw [Fin.cons_succ, Fin.cons_zero]
      exact hj iâ‚€
    Â· rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' iâ‚€ iâ‚
  obtain âŸ¨j, hjâŸ© : âˆƒ j, âˆ€ i : Fin n,
      t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ := by
    by_contra! hg
    obtain âŸ¨jâ‚€, jâ‚, j_ne, approxâŸ© := exists_approx_polynomial hb hÎµ
      (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (hg j))))
    revert j_ne approx
    refine Fin.cases ?_ (fun jâ‚€ => ?_) jâ‚€ <;>
      refine Fin.cases (fun j_ne approx => ?_) (fun jâ‚ j_ne approx => ?_) jâ‚
    Â· exact absurd rfl j_ne
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg jâ‚)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le] at approx
      have := (Classical.choose_spec (hg jâ‚€)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne, Fin.succ_inj] at j_ne
      have : jâ‚€ = jâ‚ := (Classical.choose_spec (hg jâ‚€)).1.symm.trans
        (((ht' (Classical.choose (hg jâ‚€)) (Classical.choose (hg jâ‚))).mpr approx).trans
          (Classical.choose_spec (hg jâ‚)).1)
      contradiction
  by_cases exists_nonempty_j : âˆƒ j, (âˆƒ i, t' i = j) âˆ§
      âˆ€ i, t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· obtain âŸ¨j, âŸ¨i, hiâŸ©, hjâŸ© := exists_nonempty_j
    refine âŸ¨j, fun i' => âŸ¨hj i', fun hi' => _root_.trans ((ht' _ _).mpr ?_) hiâŸ©âŸ©
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  refine âŸ¨j, fun i => âŸ¨hj i, fun hi => ?_âŸ©âŸ©
  have := exists_nonempty_j âŸ¨t' i, âŸ¨i, rflâŸ©, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')âŸ©
  contradiction","refine âŸ¨exists_partition_polynomial_polynomial_polynomial_polynomial_polynomial_polynomial_aux,
  exists_partition_polynomial_polynomial_polynomial_polynomial_polynomial_polynomial_polynomial_aux,
  exists_partition_polynomial_polynomial_polynomial_polynomial_auxâŸ©"
Mathlib/NumberTheory/Pell.lean,Pell.exists_of_not_isSquare,exists_of_not_isSquare,0f24aee7da46f85fee5cacc716172444ce31e582,":= by
  let Î¾ : â„ := sqrt d
  have hÎ¾ : Irrational Î¾ := by
    refine' irrational_nrt_of_notint_nrt 2 d (sq_sqrt <| Int.cast_nonneg.mpr hâ‚€.le) _ two_pos
    rintro âŸ¨x, hxâŸ©
    refine' hd âŸ¨x, @Int.cast_injective â„ _ _ d (x * x) _âŸ©
    rw [â† sq_sqrt <| Int.cast_nonneg.mpr hâ‚€.le, Int.cast_mul, â† hx, sq]
  obtain âŸ¨M, hMâ‚âŸ© := exists_int_gt (2 * |Î¾| + 1)
  have hM : {q : â„š | |q.1 ^ 2 - d * (q.2 : â„¤) ^ 2| < M}.Infinite := by
    refine' Infinite.mono (fun q h => _) (infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational hÎ¾)
    have h0 : 0 < (q.2 : â„) ^ 2 := pow_pos (Nat.cast_pos.mpr q.pos) 2
    have h1 : (q.num : â„) / (q.den : â„) = q := mod_cast q.num_div_den
    rw [mem_setOf, abs_sub_comm, â† @Int.cast_lt â„, â† div_lt_div_right (abs_pos_of_pos h0)]
    push_cast
    rw [â† abs_div, abs_sq, sub_div, mul_div_cancel _ h0.ne', â† div_pow, h1, â†
      sq_sqrt (Int.cast_pos.mpr hâ‚€).le, sq_sub_sq, abs_mul, â† mul_one_div]
    refine' mul_lt_mul'' (((abs_add Î¾ q).trans _).trans_lt hMâ‚) h (abs_nonneg _) (abs_nonneg _)
    rw [two_mul, add_assoc, add_le_add_iff_left, â† sub_le_iff_le_add']
    rw [mem_setOf, abs_sub_comm] at h
    refine' (abs_sub_abs_le_abs_sub (q : â„) Î¾).trans (h.le.trans _)
    rw [div_le_one h0, one_le_sq_iff_one_le_abs, Nat.abs_cast, Nat.one_le_cast]
    exact q.pos
  obtain âŸ¨m, hmâŸ© : âˆƒ m : â„¤, {q : â„š | q.1 ^ 2 - d * (q.den : â„¤) ^ 2 = m}.Infinite := by
    contrapose! hM
    simp only [not_infinite] at hM âŠ¢
    refine' (congr_arg _ (ext fun x => _)).mp (Finite.biUnion (finite_Ioo (-M) M) fun m _ => hM m)
    simp only [abs_lt, mem_setOf, mem_Ioo, mem_iUnion, exists_prop, exists_eq_right']
  have hmâ‚€ : m â‰  0 := by
    rintro rfl
    obtain âŸ¨q, hqâŸ© := hm.nonempty
    rw [mem_setOf, sub_eq_zero, mul_comm] at hq
    obtain âŸ¨a, haâŸ© := (Int.pow_dvd_pow_iff two_pos).mp âŸ¨d, hqâŸ©
    rw [ha, mul_pow, mul_right_inj' (pow_pos (Int.coe_nat_pos.mpr q.pos) 2).ne'] at hq
    exact hd âŸ¨a, sq a â–¸ hq.symmâŸ©
  haveI := neZero_iff.mpr (Int.natAbs_ne_zero.mpr hmâ‚€)
  let f : â„š â†’ ZMod m.natAbs Ã— ZMod m.natAbs := fun q => (q.num, q.den)
  obtain âŸ¨qâ‚, hâ‚ : qâ‚.num ^ 2 - d * (qâ‚.den : â„¤) ^ 2 = m,
      qâ‚‚, hâ‚‚ : qâ‚‚.num ^ 2 - d * (qâ‚‚.den : â„¤) ^ 2 = m, hne, hqfâŸ© :=
    hm.exists_ne_map_eq_of_mapsTo (mapsTo_univ f _) finite_univ
  obtain âŸ¨hq1 : (qâ‚.num : ZMod m.natAbs) = qâ‚‚.num, hq2 : (qâ‚.den : ZMod m.natAbs) = qâ‚‚.denâŸ© :=
    Prod.ext_iff.mp hqf
  have hdâ‚ : m âˆ£ qâ‚.num * qâ‚‚.num - d * (qâ‚.den * qâ‚‚.den) := by
    rw [â† Int.natAbs_dvd, â† ZMod.int_cast_zmod_eq_zero_iff_dvd]
    push_cast
    rw [hq1, hq2, â† sq, â† sq]
    norm_cast
    rw [ZMod.int_cast_zmod_eq_zero_iff_dvd, Int.natAbs_dvd, Nat.cast_pow, â† hâ‚‚]
  have hdâ‚‚ : m âˆ£ qâ‚.num * qâ‚‚.den - qâ‚‚.num * qâ‚.den := by
    rw [â† Int.natAbs_dvd, â† ZMod.int_cast_eq_int_cast_iff_dvd_sub]
    push_cast
    rw [hq1, hq2]
  replace hmâ‚€ : (m : â„š) â‰  0 := Int.cast_ne_zero.mpr hmâ‚€
  refine' âŸ¨(qâ‚.num * qâ‚‚.num - d * (qâ‚.den * qâ‚‚.den)) / m, (qâ‚.num * qâ‚‚.den - qâ‚‚.num * qâ‚.den) / m,
      _, _âŸ©
  Â· qify [hdâ‚, hdâ‚‚]
    field_simp [hmâ‚€]
    norm_cast
    conv_rhs =>
      rw [sq]
      congr
      Â· rw [â† hâ‚]
      Â· rw [â† hâ‚‚]
    push_cast
    ring
  Â· qify [hdâ‚‚]
    refine' div_ne_zero_iff.mpr âŸ¨_, hmâ‚€âŸ©
    exact_mod_cast mt sub_eq_zero.mp (mt Rat.eq_iff_mul_eq_mul.mpr hne)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.76736 * (?m.76767 / ?m.76736)
d : â„¤
hâ‚€ : 0 < d
hd : Â¬IsSquare d
Î¾ : â„ := âˆšâ†‘d
hÎ¾ : Irrational Î¾
M : â„¤
hMâ‚ : 2 * |Î¾| + 1 < â†‘M
q : â„š
h : q âˆˆ {q | |Î¾ - â†‘q| < 1 / â†‘q.den ^ 2}
h0 : 0 < â†‘q.den ^ 2
h1 : â†‘q.num / â†‘q.den = â†‘q
âŠ¢ |â†‘d * â†‘q.den ^ 2 / â†‘q.den ^ 2 - â†‘q.num ^ 2 / â†‘q.den ^ 2| < â†‘M / â†‘q.den ^ 2
error:  application type mismatch
  mul_div_cancel ?m.76736 (LT.lt.ne' h0)
argument
  LT.lt.ne' h0
has type
  â†‘q.den ^ 2 â‰  0 : Prop
but is expected to have type
  ?m.76734 : Type ?u.76733","theorem exists_of_not_isSquare (hâ‚€ : 0 < d) (hd : Â¬IsSquare d) :
    âˆƒ x y : â„¤, x ^ 2 - d * y ^ 2 = 1 âˆ§ y â‰  0 ",":= by
  let Î¾ : â„ := âˆšd
  have hÎ¾ : Irrational Î¾ := by
    refine irrational_nrt_of_notint_nrt 2 d (sq_sqrt <| Int.cast_nonneg.mpr hâ‚€.le) ?_ two_pos
    rintro âŸ¨x, hxâŸ©
    refine hd âŸ¨x, @Int.cast_injective â„ _ _ d (x * x) ?_âŸ©
    rw [â† sq_sqrt <| Int.cast_nonneg.mpr hâ‚€.le, Int.cast_mul, â† hx, sq]
  obtain âŸ¨M, hMâ‚âŸ© := exists_int_gt (2 * |Î¾| + 1)
  have hM : {q : â„š | |q.1 ^ 2 - d * (q.2 : â„¤) ^ 2| < M}.Infinite := by
    refine Infinite.mono (fun q h => ?_) (infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational hÎ¾)
    have h0 : 0 < (q.2 : â„) ^ 2 := pow_pos (Nat.cast_pos.mpr q.pos) 2
    have h1 : (q.num : â„) / (q.den : â„) = q := mod_cast q.num_div_den
    rw [mem_setOf, abs_sub_comm, â† @Int.cast_lt â„, â† div_lt_div_right (abs_pos_of_pos h0)]
    push_cast
    rw [â† abs_div, abs_sq, sub_div, mul_div_cancel_rightâ‚€ _ h0.ne', â† div_pow, h1, â†
      sq_sqrt (Int.cast_pos.mpr hâ‚€).le, sq_sub_sq, abs_mul, â† mul_one_div]
    refine mul_lt_mul'' (((abs_add Î¾ q).trans ?_).trans_lt hMâ‚) h (abs_nonneg _) (abs_nonneg _)
    rw [two_mul, add_assoc, add_le_add_iff_left, â† sub_le_iff_le_add']
    rw [mem_setOf, abs_sub_comm] at h
    refine (abs_sub_abs_le_abs_sub (q : â„) Î¾).trans (h.le.trans ?_)
    rw [div_le_one h0, one_le_sq_iff_one_le_abs, Nat.abs_cast, Nat.one_le_cast]
    exact q.pos
  obtain âŸ¨m, hmâŸ© : âˆƒ m : â„¤, {q : â„š | q.1 ^ 2 - d * (q.den : â„¤) ^ 2 = m}.Infinite := by
    contrapose! hM
    simp only [not_infinite] at hM âŠ¢
    refine (congr_arg _ (ext fun x => ?_)).mp (Finite.biUnion (finite_Ioo (-M) M) fun m _ => hM m)
    simp only [abs_lt, mem_setOf, mem_Ioo, mem_iUnion, exists_prop, exists_eq_right']
  have hmâ‚€ : m â‰  0 := by
    rintro rfl
    obtain âŸ¨q, hqâŸ© := hm.nonempty
    rw [mem_setOf, sub_eq_zero, mul_comm] at hq
    obtain âŸ¨a, haâŸ© := (Int.pow_dvd_pow_iff two_ne_zero).mp âŸ¨d, hqâŸ©
    rw [ha, mul_pow, mul_right_inj' (pow_pos (Int.natCast_pos.mpr q.pos) 2).ne'] at hq
    exact hd âŸ¨a, sq a â–¸ hq.symmâŸ©
  haveI := neZero_iff.mpr (Int.natAbs_ne_zero.mpr hmâ‚€)
  let f : â„š â†’ ZMod m.natAbs Ã— ZMod m.natAbs := fun q => (q.num, q.den)
  obtain âŸ¨qâ‚, hâ‚ : qâ‚.num ^ 2 - d * (qâ‚.den : â„¤) ^ 2 = m,
      qâ‚‚, hâ‚‚ : qâ‚‚.num ^ 2 - d * (qâ‚‚.den : â„¤) ^ 2 = m, hne, hqfâŸ© :=
    hm.exists_ne_map_eq_of_mapsTo (mapsTo_univ f _) finite_univ
  obtain âŸ¨hq1 : (qâ‚.num : ZMod m.natAbs) = qâ‚‚.num, hq2 : (qâ‚.den : ZMod m.natAbs) = qâ‚‚.denâŸ© :=
    Prod.ext_iff.mp hqf
  have hdâ‚ : m âˆ£ qâ‚.num * qâ‚‚.num - d * (qâ‚.den * qâ‚‚.den) := by
    rw [â† Int.natAbs_dvd, â† ZMod.intCast_zmod_eq_zero_iff_dvd]
    push_cast
    rw [hq1, hq2, â† sq, â† sq]
    norm_cast
    rw [ZMod.intCast_zmod_eq_zero_iff_dvd, Int.natAbs_dvd, Nat.cast_pow, â† hâ‚‚]
  have hdâ‚‚ : m âˆ£ qâ‚.num * qâ‚‚.den - qâ‚‚.num * qâ‚.den := by
    rw [â† Int.natAbs_dvd, â† ZMod.intCast_eq_intCast_iff_dvd_sub]
    push_cast
    rw [hq1, hq2]
  replace hmâ‚€ : (m : â„š) â‰  0 := Int.cast_ne_zero.mpr hmâ‚€
  refine âŸ¨(qâ‚.num * qâ‚‚.num - d * (qâ‚.den * qâ‚‚.den)) / m, (qâ‚.num * qâ‚‚.den - qâ‚‚.num * qâ‚.den) / m,
      ?_, ?_âŸ©
  Â· qify [hdâ‚, hdâ‚‚]
    field_simp [hmâ‚€]
    norm_cast
    conv_rhs =>
      rw [sq]
      congr
      Â· rw [â† hâ‚]
      Â· rw [â† hâ‚‚]
    push_cast
    ring
  Â· qify [hdâ‚‚]
    refine div_ne_zero_iff.mpr âŸ¨?_, hmâ‚€âŸ©
    exact mod_cast mt sub_eq_zero.mp (mt Rat.eq_iff_mul_eq_mul.mpr hne)","obtain âŸ¨x, y, hxy, hyâŸ© := exists_of_not_isSquare hâ‚€ hd"
Mathlib/MeasureTheory/Constructions/Pi.lean,generateFrom_pi,generateFrom_pi,961db629df93e5dbd02440deee4c37efcf2faa85,":= by
  cases nonempty_encodable Î¹
  apply le_antisymm
  Â· refine' iSup_le _; intro i; rw [comap_generateFrom]
    apply generateFrom_le; rintro _ âŸ¨s, hs, rflâŸ©; dsimp
    choose t h1t h2t using hC
    simp_rw [eval_preimage, â† h2t]
    rw [â† @iUnion_const _ â„• _ s]
    have : Set.pi univ (update (fun i' : Î¹ => iUnion (t i')) i (â‹ƒ _ : â„•, s)) =
        Set.pi univ fun k => â‹ƒ j : â„•,
        @update Î¹ (fun i' => Set (Î± i')) _ (fun i' => t i' j) i s k := by
      ext; simp_rw [mem_univ_pi]; apply forall_congr'; intro i'
      by_cases h : i' = i
      Â· subst h; simp
      Â· rw [â† Ne.eq_def] at h; simp [h]
    rw [this, â† iUnion_univ_pi]
    apply MeasurableSet.iUnion
    intro n; apply measurableSet_generateFrom
    apply mem_image_of_mem; intro j _; dsimp only
    by_cases h : j = i; subst h; rwa [update_same]; rw [update_noteq h]; apply h1t
  Â· apply generateFrom_le; rintro _ âŸ¨s, hs, rflâŸ©
    rw [univ_pi_eq_iInter]; apply MeasurableSet.iInter; intro i
    apply @measurable_pi_apply _ _ (fun i => generateFrom (C i))
    exact measurableSet_generateFrom (hs i (mem_univ i))",error:  dsimp made no progress,"theorem generateFrom_pi_eq {C : âˆ€ i, Set (Set (Î± i))} (hC : âˆ€ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) ",":= by
  cases nonempty_encodable Î¹
  apply le_antisymm
  Â· refine iSup_le ?_; intro i; rw [comap_generateFrom]
    apply generateFrom_le; rintro _ âŸ¨s, hs, rflâŸ©
    choose t h1t h2t using hC
    simp_rw [eval_preimage, â† h2t]
    rw [â† @iUnion_const _ â„• _ s]
    have : Set.pi univ (update (fun i' : Î¹ => iUnion (t i')) i (â‹ƒ _ : â„•, s)) =
        Set.pi univ fun k => â‹ƒ j : â„•,
        @update Î¹ (fun i' => Set (Î± i')) _ (fun i' => t i' j) i s k := by
      ext; simp_rw [mem_univ_pi]; apply forall_congr'; intro i'
      by_cases h : i' = i
      Â· subst h; simp
      Â· rw [â† Ne] at h; simp [h]
    rw [this, â† iUnion_univ_pi]
    apply MeasurableSet.iUnion
    intro n; apply measurableSet_generateFrom
    apply mem_image_of_mem; intro j _; dsimp only
    by_cases h : j = i
    Â· subst h; rwa [update_same]
    Â· rw [update_noteq h]; apply h1t
  Â· apply generateFrom_le; rintro _ âŸ¨s, hs, rflâŸ©
    rw [univ_pi_eq_iInter]; apply MeasurableSet.iInter; intro i
    apply @measurable_pi_apply _ _ (fun i => generateFrom (C i))
    exact measurableSet_generateFrom (hs i (mem_univ i))",apply generateFrom_eq_generateFrom_image generateFrom_pi_eq
Mathlib/Order/WellFoundedSet.lean,Set.PartiallyWellOrderedOn.partiallyWellOrderedOn_sublistForallâ‚‚,partiallyWellOrderedOn_sublistForallâ‚‚,b502dbb455f708f5af5e6017e88f53565165ab0a,":= by
  rcases isEmpty_or_nonempty Î±
  Â· exact subsingleton_of_subsingleton.partiallyWellOrderedOn
  inhabit Î±
  rw [iff_not_exists_isMinBadSeq List.length]
  rintro âŸ¨f, hf1, hf2âŸ©
  have hnil : âˆ€ n, f n â‰  List.nil := fun n con =>
    hf1.2 n n.succ n.lt_succ_self (con.symm â–¸ List.SublistForallâ‚‚.nil)
  have : âˆ€ n, (f n).headI âˆˆ s :=
    fun n => hf1.1 n _ (List.head!_mem_self (hnil n))
  obtain âŸ¨g, hgâŸ© := h.exists_monotone_subseq (fun n => (f n).headI) this
  have hf' :=
    hf2 (g 0) (fun n => if n < g 0 then f n else List.tail (f (g (n - g 0))))
      (fun m hm => (if_pos hm).symm) ?_
  swap;
  Â· simp only [if_neg (lt_irrefl (g 0)), tsub_self]
    rw [List.length_tail, â† Nat.pred_eq_sub_one]
    exact Nat.pred_lt fun con => hnil _ (List.length_eq_zero.1 con)
  rw [IsBadSeq] at hf'
  push_neg at hf'
  obtain âŸ¨m, n, mn, hmnâŸ© := hf' fun n x hx => by
    split_ifs at hx with hn
    exacts [hf1.1 _ _ hx, hf1.1 _ _ (List.tail_subset _ hx)]
  by_cases hn : n < g 0
  Â· apply hf1.2 m n mn
    rwa [if_pos hn, if_pos (mn.trans hn)] at hmn
  Â· obtain âŸ¨n', rflâŸ© := exists_add_of_le (not_lt.1 hn)
    rw [if_neg hn, add_comm (g 0) n', add_tsub_cancel_right] at hmn
    split_ifs at hmn with hm
    Â· apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le))
      exact _root_.trans hmn (List.tail_sublistForallâ‚‚_self _)
    Â· rw [â† tsub_lt_iff_left (le_of_not_lt hm)] at mn
      apply hf1.2 _ _ (g.lt_iff_lt.2 mn)
      rw [â† List.cons_head!_tail (hnil (g (m - g 0))), â† List.cons_head!_tail (hnil (g n'))]
      exact List.SublistForallâ‚‚.cons (hg _ _ (le_of_lt mn)) hmn","error:  type mismatch
  Nat.pred_lt fun con â†¦ hnil (g (g 0 - g 0)) (List.length_eq_zero.mp con)
has type
  (f (g (g 0 - g 0))).length.pred < (f (g (g 0 - g 0))).length : Prop
but is expected to have type
  (f (g (g 0 - g 0))).length.pred < (f (g 0)).length : Prop
error:  failed to synthesize
  ExistsAddOfLE â„•
use `set_option diagnostics true` to get diagnostic information
error:  rcases tactic failed: xâœ : ?m.63253 is not an inductive datatype","theorem partiallyWellOrderedOn_sublistForallâ‚‚ (r : Î± â†’ Î± â†’ Prop) [IsRefl Î± r] [IsTrans Î± r]
    {s : Set Î±} (h : s.PartiallyWellOrderedOn r) :
    { l : List Î± | âˆ€ x, x âˆˆ l â†’ x âˆˆ s }.PartiallyWellOrderedOn (List.SublistForallâ‚‚ r) ",":= by
  rcases isEmpty_or_nonempty Î±
  Â· exact subsingleton_of_subsingleton.partiallyWellOrderedOn
  inhabit Î±
  rw [iff_not_exists_isMinBadSeq List.length]
  rintro âŸ¨f, hf1, hf2âŸ©
  have hnil : âˆ€ n, f n â‰  List.nil := fun n con =>
    hf1.2 n n.succ n.lt_succ_self (con.symm â–¸ List.SublistForallâ‚‚.nil)
  have : âˆ€ n, (f n).headI âˆˆ s :=
    fun n => hf1.1 n _ (List.head!_mem_self (hnil n))
  obtain âŸ¨g, hgâŸ© := h.exists_monotone_subseq (fun n => (f n).headI) this
  have hf' :=
    hf2 (g 0) (fun n => if n < g 0 then f n else List.tail (f (g (n - g 0))))
      (fun m hm => (if_pos hm).symm) ?_
  swap;
  Â· simp only [if_neg (lt_irrefl (g 0)), Nat.sub_self]
    rw [List.length_tail, â† Nat.pred_eq_sub_one]
    exact Nat.pred_lt fun con => hnil _ (List.length_eq_zero.1 con)
  rw [IsBadSeq] at hf'
  push_neg at hf'
  obtain âŸ¨m, n, mn, hmnâŸ© := hf' fun n x hx => by
    split_ifs at hx with hn
    exacts [hf1.1 _ _ hx, hf1.1 _ _ (List.tail_subset _ hx)]
  by_cases hn : n < g 0
  Â· apply hf1.2 m n mn
    rwa [if_pos hn, if_pos (mn.trans hn)] at hmn
  Â· obtain âŸ¨n', rflâŸ© := Nat.exists_eq_add_of_le (not_lt.1 hn)
    rw [if_neg hn, add_comm (g 0) n', Nat.add_sub_cancel_right] at hmn
    split_ifs at hmn with hm
    Â· apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le))
      exact _root_.trans hmn (List.tail_sublistForallâ‚‚_self _)
    Â· rw [â† Nat.sub_lt_iff_lt_add (le_of_not_lt hm)] at mn
      apply hf1.2 _ _ (g.lt_iff_lt.2 mn)
      rw [â† List.cons_head!_tail (hnil (g (m - g 0))), â† List.cons_head!_tail (hnil (g n'))]
      exact List.SublistForallâ‚‚.cons (hg _ _ (le_of_lt mn)) hmn",apply partiallyWellOrderedOn_sublistForallâ‚‚
Mathlib/MeasureTheory/Measure/Typeclasses.lean,MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_topâ‚€,countable_meas_pos_of_disjoint_of_meas_iUnion_ne_topâ‚€,7dbc4ee943ff99bb5a359e820806969fa45b18b0,":= by
  set posmeas := { i : Î¹ | 0 < Î¼ (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : â„â‰¥0âˆ) < 1) with
    âŸ¨as, _, as_mem, as_limâŸ©
  set fairmeas := fun n : â„• => { i : Î¹ | as n â‰¤ Î¼ (As i) }
  have countable_union : posmeas = â‹ƒ n, fairmeas n := by
    have fairmeas_eq : âˆ€ n, fairmeas n = (fun i => Î¼ (As i)) â»Â¹' Ici (as n) := fun n => by
      simp only []
      rfl
    simpa only [fairmeas_eq, posmeas_def, â† preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : â„â‰¥0âˆ) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine' countable_iUnion fun n => Finite.countable _
  refine' finite_const_le_meas_of_disjoint_iUnionâ‚€ Î¼ (as_mem n).1 As_mble As_disj Union_As_finite",error:  simp made no progress,"theorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_topâ‚€ {Î¹ : Type*} {_ : MeasurableSpace Î±}
    (Î¼ : Measure Î±) {As : Î¹ â†’ Set Î±} (As_mble : âˆ€ i : Î¹, NullMeasurableSet (As i) Î¼)
    (As_disj : Pairwise (AEDisjoint Î¼ on As)) (Union_As_finite : Î¼ (â‹ƒ i, As i) â‰  âˆ) :
    Set.Countable { i : Î¹ | 0 < Î¼ (As i) } ",":= by
  set posmeas := { i : Î¹ | 0 < Î¼ (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : â„â‰¥0âˆ) < 1) with
    âŸ¨as, _, as_mem, as_limâŸ©
  set fairmeas := fun n : â„• => { i : Î¹ | as n â‰¤ Î¼ (As i) }
  have countable_union : posmeas = â‹ƒ n, fairmeas n := by
    have fairmeas_eq : âˆ€ n, fairmeas n = (fun i => Î¼ (As i)) â»Â¹' Ici (as n) := fun n => by
      simp only [fairmeas]
      rfl
    simpa only [fairmeas_eq, posmeas_def, â† preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : â„â‰¥0âˆ) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine countable_iUnion fun n => Finite.countable ?_
  exact finite_const_le_meas_of_disjoint_iUnionâ‚€ Î¼ (as_mem n).1 As_mble As_disj Union_As_finite","have : âˆ€ i, Î¼ (As i) â‰  âˆ := fun i â†¦ As_mble i"
Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Instances.lean,nonneg_iff_isSelfAdjoint_and_spectrumRestricts,nonneg_iff_isSelfAdjoint_and_spectrumRestricts,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  rw [SpectrumRestricts.nnreal_iff]
  refine âŸ¨fun ha â†¦ ?_, ?_âŸ©
  Â· rw [StarOrderedRing.nonneg_iff] at ha
    induction ha using AddSubmonoid.closure_induction' with
    | mem x hx =>
      obtain âŸ¨b, rflâŸ© := hx
      exact âŸ¨IsSelfAdjoint.star_mul_self b, spectrum_star_mul_self_nonnegâŸ©
    | one =>
      nontriviality A
      simp
    | mul x _ y _ hx hy =>
      rw [â† SpectrumRestricts.nnreal_iff] at hx hy âŠ¢
      exact âŸ¨hx.1.add hy.1, hx.2.nnreal_add hx.1 hy.1 hy.2âŸ©
  Â· rintro âŸ¨haâ‚, haâ‚‚âŸ©
    let s := cfc a Real.sqrt
    have : a = star s * s := by
      rw [â† cfc_id a (R := â„), â† cfc_star a (R := â„), â† cfc_mul ..]
      apply cfc_congr a
      peel haâ‚‚ with x hx _
      simp [Real.mul_self_sqrt this]
    exact this â–¸ star_mul_self_nonneg s","error:  unknown identifier 'spectrum_star_mul_self_nonneg'
error:  invalid field 'nnreal_add', the environment does not contain 'SpectrumRestricts.nnreal_add'
  hx.right
has type
  SpectrumRestricts x â‡‘ContinuousMap.realToNNReal
error:  invalid field 'nnreal_add', the environment does not contain 'QuasispectrumRestricts.nnreal_add'
  hx.right
has type
  QuasispectrumRestricts x â‡‘ContinuousMap.realToNNReal
error:  application type mismatch
  cfc a
argument
  a
has type
  A : Type u_1
but is expected to have type
  ?m.604472 â†’ ?m.604472 : Type ?u.604471","lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 â‰¤ a â†” IsSelfAdjoint a âˆ§ SpectrumRestricts a ContinuousMap.realToNNReal ",":= by
  refine âŸ¨fun ha â†¦ âŸ¨.of_nonneg ha, .nnreal_of_nonneg haâŸ©, ?_âŸ©
  rintro âŸ¨haâ‚, haâ‚‚âŸ©
  obtain âŸ¨x, hx, -, rflâŸ© := CFC.exists_sqrt_of_isSelfAdjoint_of_spectrumRestricts haâ‚ haâ‚‚
  simpa [sq, hx.star_eq] using star_mul_self_nonneg x",constructor
Mathlib/Topology/Separation/NotNormal.lean,IsClosed.mk_lt_continuum,IsClosed.mk_lt_continuum,161c69c1dbf66cf3c7ec4f648a61551d044a43e4,":= by
  by_contra! h
  rcases exists_countable_dense X with âŸ¨t, htc, htdâŸ©
  haveI := htc.to_subtype
  refine (Cardinal.cantor ğ” ).not_le ?_
  calc
    2 ^ ğ”  â‰¤ #C(s, â„) := by
      rw [(ContinuousMap.equivFnOfDiscrete _ _).cardinal_eq, mk_arrow, mk_real, lift_continuum,
        lift_uzero]
      exact (power_le_power_left two_ne_zero h).trans (power_le_power_right (nat_lt_continuum 2).le)
    _ â‰¤ #C(X, â„) := by
      choose f hf using (ContinuousMap.exists_restrict_eq_of_closed Â· hs)
      have hfi : Injective f := LeftInverse.injective hf
      exact mk_le_of_injective hfi
    _ â‰¤ #C(t, â„) := mk_le_of_injective <| ContinuousMap.injective_restrict htd
    _ â‰¤ #(t â†’ â„) := mk_le_of_injective DFunLike.coe_injective
    _ â‰¤ ğ”  := by
      rw [mk_arrow, mk_real, lift_uzero, lift_continuum, continuum, â† power_mul]
      exact power_le_power_left two_ne_zero mk_le_aleph0","warning:  `ContinuousMap.exists_restrict_eq_of_closed` has been deprecated, use `ContinuousMap.exists_restrict_eq` instead
error:  typeclass instance problem is stuck, it is often due to metavariables
  TietzeExtension (?m.3894 xâœ)","theorem IsClosed.mk_lt_continuum [NormalSpace X] {s : Set X} (hs : IsClosed s)
    [DiscreteTopology s] : #s < ğ”  ",":= by
  by_contra! h
  rcases exists_countable_dense X with âŸ¨t, htc, htdâŸ©
  haveI := htc.to_subtype
  refine (Cardinal.cantor ğ” ).not_le ?_
  calc
    2 ^ ğ”  â‰¤ #C(s, â„) := by
      rw [(ContinuousMap.equivFnOfDiscrete _ _).cardinal_eq, mk_arrow, mk_real, lift_continuum,
        lift_uzero]
      exact (power_le_power_left two_ne_zero h).trans (power_le_power_right (nat_lt_continuum 2).le)
    _ â‰¤ #C(X, â„) := by
      choose f hf using ContinuousMap.exists_restrict_eq (Y := â„) hs
      have hfi : Injective f := LeftInverse.injective hf
      exact mk_le_of_injective hfi
    _ â‰¤ #C(t, â„) := mk_le_of_injective <| ContinuousMap.injective_restrict htd
    _ â‰¤ #(t â†’ â„) := mk_le_of_injective DFunLike.coe_injective
    _ â‰¤ ğ”  := by
      rw [mk_arrow, mk_real, lift_uzero, lift_continuum, continuum, â† power_mul]
      exact power_le_power_left two_ne_zero mk_le_aleph0",refine lt_of_le_of_lt ?_ (mk_lt_continuum_le_mk_lt_continuum hs)
Mathlib/Order/Bounds/Basic.lean,union_upperBounds_subset_upperBounds_inter,union_upperBounds_subset_upperBounds_inter,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":=
  union_subset (upperBounds_mono_set <| inter_subset_left _ _)
    (upperBounds_mono_set <| inter_subset_right _ _)","error:  function expected at
  inter_subset_left ?m.16010
term has type
  ?m.16009 âˆˆ ?m.16007
error:  function expected at
  inter_subset_right ?m.16074
term has type
  ?m.16073 âˆˆ ?m.16072","theorem union_upperBounds_subset_upperBounds_inter :
    upperBounds s âˆª upperBounds t âŠ† upperBounds (s âˆ© t) ",":=
  union_subset (upperBounds_mono_set inter_subset_left)
    (upperBounds_mono_set inter_subset_right)",exact union_upperBounds_subset_upperBounds_inter union_upperBounds_subset_upperBounds_inter
Mathlib/CategoryTheory/Localization/Triangulated.lean,CategoryTheory.Triangulated.Localization.distinguished_cocone_triangle,distinguished_cocone_triangle,bb5ccc412d812c6019a24d2f31b52e65258aa0e4,":= by
  have := Localization.essSurj L W
  let f' := MorphismProperty.HasLeftCalculusOfFractions.liftMap L W f
  obtain âŸ¨Z, g, h, HâŸ© := Pretriangulated.distinguished_cocone_triangle _ _ f'
  refine' âŸ¨L.obj Z, (MorphismProperty.HasLeftCalculusOfFractions.liftMapIsoâ‚‚ L W f).hom â‰« L.map g,
    L.map h â‰« (L.commShiftIso (1 : â„¤)).hom.app _ â‰«
      (MorphismProperty.HasLeftCalculusOfFractions.liftMapIsoâ‚ L W f).invâŸ¦(1 : â„¤)âŸ§',
      _, _, HâŸ©
  refine' Triangle.isoMk _ _ (MorphismProperty.HasLeftCalculusOfFractions.liftMapIsoâ‚ L W f)
    (MorphismProperty.HasLeftCalculusOfFractions.liftMapIsoâ‚‚ L W f)
     (Iso.refl _) (MorphismProperty.HasLeftCalculusOfFractions.liftMap_fac L W f) (by simp) _
  dsimp
  simp only [assoc, id_comp, â† Functor.map_comp, Iso.inv_hom_id, Functor.map_id, comp_id]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  MorphismProperty.HasLeftCalculusOfFractions
has type
  MorphismProperty ?m.47109 â†’ Prop
error:  unsolved goals
C : Type u_1
D : Type u_2
instâœÂ¹âµ : Category.{u_4, u_1} C
instâœÂ¹â´ : Category.{u_3, u_2} D
L : C â¥¤ D
instâœÂ¹Â³ : HasShift C â„¤
instâœÂ¹Â² : Preadditive C
instâœÂ¹Â¹ : HasZeroObject C
instâœÂ¹â° : âˆ€ (n : â„¤), (shiftFunctor C n).Additive
instâœâ¹ : Pretriangulated C
instâœâ¸ : HasShift D â„¤
instâœâ· : L.CommShift â„¤
W : MorphismProperty C
instâœâ¶ : L.IsLocalization W
instâœâµ : W.IsCompatibleWithTriangulation
instâœâ´ : W.HasLeftCalculusOfFractions
instâœÂ³ : Preadditive D
instâœÂ² : HasZeroObject D
instâœÂ¹ : âˆ€ (n : â„¤), (shiftFunctor D n).Additive
instâœ : L.Additive
X Y : D
f : X âŸ¶ Y
this : L.EssSurj
âŠ¢ âˆƒ Z g h, Triangle.mk f g h âˆˆ L.essImageDistTriang","lemma distinguished_cocone_triangle {X Y : D} (f : X âŸ¶ Y) :
    âˆƒ (Z : D) (g : Y âŸ¶ Z) (h : Z âŸ¶ XâŸ¦(1 : â„¤)âŸ§),
      Triangle.mk f g h âˆˆ L.essImageDistTriang ",":= by
  have := essSurj_mapArrow L W
  obtain âŸ¨Ï†, âŸ¨eâŸ©âŸ© : âˆƒ (Ï† : Arrow C), Nonempty (L.mapArrow.obj Ï† â‰… Arrow.mk f) :=
    âŸ¨_, âŸ¨Functor.objObjPreimageIso _ _âŸ©âŸ©
  obtain âŸ¨Z, g, h, HâŸ© := Pretriangulated.distinguished_cocone_triangle Ï†.hom
  refine âŸ¨L.obj Z, e.inv.right â‰« L.map g,
    L.map h â‰« (L.commShiftIso (1 : â„¤)).hom.app _ â‰« e.hom.leftâŸ¦(1 : â„¤)âŸ§', _, ?_, HâŸ©
  refine Triangle.isoMk _ _ (Arrow.leftFunc.mapIso e.symm) (Arrow.rightFunc.mapIso e.symm)
    (Iso.refl _) e.inv.w.symm (by simp) ?_
  dsimp
  simp only [assoc, id_comp, â† Functor.map_comp, â† Arrow.comp_left, e.hom_inv_id, Arrow.id_left,
    Functor.mapArrow_obj_left, Functor.map_id, comp_id]",obtain âŸ¨YâŸ© := L.essImageDistTriang
Mathlib/RingTheory/IntegralClosure.lean,RingHom.isIntegralElem_leadingCoeff_mul,RingHom.isIntegralElem_leadingCoeff_mul,9e34a191034458a56331f976ff7400a26407c888,":= by
  by_cases h' : 1 â‰¤ p.natDegree
  Â· use normalizeScaleRoots p
    have : p â‰  0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_evalâ‚‚_leadingCoeff_mul p h' f x, h, MulZeroClass.mul_zero]
  Â· by_cases hp : p.map f = 0
    Â· apply_fun fun q => coeff q p.natDegree at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, MulZeroClass.zero_mul]
      exact f.is_integral_zero
    Â· rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', evalâ‚‚_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]","error:  invalid field 'is_integral_zero', the environment does not contain 'RingHom.is_integral_zero'
  f
has type
  R â†’+* S","theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.evalâ‚‚ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) ",":= by
  by_cases h' : 1 â‰¤ p.natDegree
  Â· use normalizeScaleRoots p
    have : p â‰  0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_evalâ‚‚_leadingCoeff_mul p h' f x, h, mul_zero]
  Â· by_cases hp : p.map f = 0
    Â· apply_fun fun q => coeff q p.natDegree at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, zero_mul]
      exact f.isIntegralElem_zero
    Â· rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', evalâ‚‚_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]",refine RingHom.isIntegralElem_leadingCoeff_mul_leadingCoeff_mul_leadingCoeff_mul h ?_
Mathlib/ModelTheory/Satisfiability.lean,FirstOrder.Language.Theory.models_iff_not_satisfiable,models_iff_not_satisfiable,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [models_sentence_iff, IsSatisfiable]
  refine
    âŸ¨fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T âˆª {Formula.not Ï†})
          (Set.subset_union_right _ _ (Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel (Set.subset_union_left _ _))),
      fun h M => ?_âŸ©
  contrapose! h
  rw [â† Sentence.realize_not] at h
  refine
    âŸ¨{  Carrier := M
        is_model := âŸ¨fun Ïˆ hÏˆ => hÏˆ.elim (realize_sentence_of_mem _) fun h' => ?_âŸ© }âŸ©
  rw [Set.mem_singleton_iff.1 h']
  exact h","warning:  @ModelsBoundedFormula does not have a doc string
error:  function expected at
  Set.subset_union_right ?m.33716
term has type
  ?m.33715 âˆˆ ?m.33713 âˆª ?m.33714
error:  function expected at
  Set.subset_union_left ?m.33942
term has type
  ?m.33941 âˆˆ ?m.33939 âˆª ?m.33940",theorem models_iff_not_satisfiable (Ï† : L.Sentence) : T âŠ¨áµ‡ Ï† â†” Â¬IsSatisfiable (T âˆª {Ï†.not}) ,":= by
  rw [models_sentence_iff, IsSatisfiable]
  refine
    âŸ¨fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T âˆª {Formula.not Ï†})
          (Set.subset_union_right (Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel Set.subset_union_left)),
      fun h M => ?_âŸ©
  contrapose! h
  rw [â† Sentence.realize_not] at h
  refine
    âŸ¨{  Carrier := M
        is_model := âŸ¨fun Ïˆ hÏˆ => hÏˆ.elim (realize_sentence_of_mem _) fun h' => ?_âŸ© }âŸ©
  rw [Set.mem_singleton_iff.1 h']
  exact h","refine âŸ¨fun h => ?_, fun h => ?_âŸ©"
Mathlib/Topology/UniformSpace/UniformEmbedding.lean,uniformEmbedding_inl,uniformEmbedding_inl,2ba547a6481ef513d87a606a16c441262be9e648,":=
  uniformEmbedding_iff'.2 âŸ¨Sum.inl_injective, uniformContinuous_inl, fun s hs =>
    âŸ¨Prod.map Sum.inl Sum.inl '' s âˆª range (Prod.map Sum.inr Sum.inr),
      union_mem_sup (image_mem_map hs) range_mem_map, fun x h => by simpa using hâŸ©âŸ©","error:  type mismatch
  hâœ
has type
  âˆƒ a b, (a, b) âˆˆ s âˆ§ (Sum.inl a, Sum.inl b) = Prod.map Sum.inl Sum.inl x : Prop
but is expected to have type
  x âˆˆ s : Prop",theorem uniformEmbedding_inl : UniformEmbedding (Sum.inl : Î± â†’ Î± âŠ• Î²) ,":=
  uniformEmbedding_iff'.2 âŸ¨Sum.inl_injective, uniformContinuous_inl, fun s hs =>
    âŸ¨Prod.map Sum.inl Sum.inl '' s âˆª range (Prod.map Sum.inr Sum.inr),
      union_mem_sup (image_mem_map hs) range_mem_map,
      fun x h => by simpa [Prod.map_apply'] using hâŸ©âŸ©",heorem_uniformEmbedding_inl uniformEmbedding_inl
Mathlib/Algebra/Homology/Localization.lean,ComplexShape.QFactorsThroughHomotopy_of_exists_prev,ComplexShape.QFactorsThroughHomotopy_of_exists_prev,1cb1056b5a19f416d3fae3469d51eedb4f5b48cb,"  areEqualizedByLocalization {K L f g} h := by
    let _ : DecidableRel c.Rel := by classical infer_instance
    exact h.map_eq_of_inverts_homotopyEquivalences hc _
      (MorphismProperty.IsInvertedBy.of_subset _ _ _
        (Localization.inverts _ (HomologicalComplex.quasiIso C _))
        (homotopyEquivalences_subset_quasiIso C _))","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  MorphismProperty.IsInvertedBy
has type
  MorphismProperty ?m.40182 â†’ ?m.40182 â¥¤ ?m.40359 â†’ Prop","lemma ComplexShape.QFactorsThroughHomotopy_of_exists_prev [CategoryWithHomology C] :
    c.QFactorsThroughHomotopy C where
","  areEqualizedByLocalization {K L f g} h := by
    have : DecidableRel c.Rel := by classical infer_instance
    exact h.map_eq_of_inverts_homotopyEquivalences hc _
      (MorphismProperty.IsInvertedBy.of_le _ _ _
        (Localization.inverts _ (HomologicalComplex.quasiIso C _))
        (homotopyEquivalences_le_quasiIso C _))",apply ComplexShape.QFactorsThroughHomotopy_of_exists_prev
Mathlib/Algebra/MonoidAlgebra/Basic.lean,AddMonoidAlgebra.ringHom_ext',ringHom_ext',848a6055965ceeab03ba2c4d2d0e4e0e9b07c6e6,":=
  ringHom_ext (RingHom.congr_fun hâ‚) (FunLike.congr_fun h_of)","error:  unknown constant 'FunLike.congr_fun'
warning:  AddMonoidAlgebra does not have a doc string","theorem ringHom_ext' {R} [Semiring k] [MulOneClass G] [Semiring R] {f g : MonoidAlgebra k G â†’+* R}
    (hâ‚ : f.comp singleOneRingHom = g.comp singleOneRingHom)
    (h_of :
      (f : MonoidAlgebra k G â†’* R).comp (of k G) = (g : MonoidAlgebra k G â†’* R).comp (of k G)) :
    f = g ",":=
  ringHom_ext (RingHom.congr_fun hâ‚) (DFunLike.congr_fun h_of)",simpa [singleOneRingHom] using h_of
Mathlib/Topology/ContinuousOn.lean,nhdsWithin_restrict'',nhdsWithin_restrict'',596865180ecc63dcd1d95809202e31027ac3ae38,":=
  le_antisymm (le_inf inf_le_left (le_principal_iff.mpr (inter_mem self_mem_nhdsWithin h)))
    (inf_le_inf_left _ (principal_mono.mpr (Set.inter_subset_left _ _)))","error:  function expected at
  inter_subset_left ?m.9529
term has type
  ?m.9528 âˆˆ ?m.9526","theorem nhdsWithin_restrict'' {a : Î±} (s : Set Î±) {t : Set Î±} (h : t âˆˆ ğ“[s] a) :
    ğ“[s] a = ğ“[s âˆ© t] a ",":=
  le_antisymm (le_inf inf_le_left (le_principal_iff.mpr (inter_mem self_mem_nhdsWithin h)))
    (inf_le_inf_left _ (principal_mono.mpr Set.inter_subset_left))",rw [nhdsWithin_restrict'']
Mathlib/LinearAlgebra/Finsupp.lean,Finsupp.lsum_single,lsum_single,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  sumAddHom_single (fun a => (â†‘(f a) : M â†’+ N)) i m",error:  unknown identifier 'sumAddHom_single',"theorem lsum_single (f : Î± â†’ M â†’â‚—[R] N) (i : Î±) (m : M) :
    Finsupp.lsum S f (Finsupp.single i m) = f i m ",":=
  Finsupp.sum_single_index (f i).map_zero","rw [Finsupp.lsum_single, Finsupp.lsum_single, Finsupp.single_eq_same]"
Mathlib/FieldTheory/Finite/Basic.lean,FiniteField.sum_pow_lt_card_sub_one,sum_pow_lt_card_sub_one,d618ff4f3388c25c5910e38dd87658b81cb6666f,":= by
  rcases eq_or_ne i 0 with rfl | hi
  Â· simp only [nsmul_one, sum_const, pow_zero, card_univ, CharP.cast_card_eq_zero]
  classical
  rw [â†Fintype.card_units, â†Subgroup.card_top] at h
  have key := sum_subgroup_pow_eq_zero (K := K) (G := âŠ¤) hi (by convert h)
  erw [Subgroup.sum_top ((Â· : KË£ â†’ K) ^ i : KË£ â†’ K)] at key
  rw [â†sum_units_nonunits, â† key]
  simp [hi]","error:  unknown constant 'CharP.cast_card_eq_zero'
error:  unsolved goals
case inl
K : Type u_1
R : Type u_2
instâœÂ¹ : Field K
instâœ : Fintype K
h : 0 < q - 1
âŠ¢ â†‘q = 0
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.card ?m.103433
case inr
K : Type u_1
R : Type u_2
instâœÂ¹ : Field K
instâœ : Fintype K
i : â„•
h : i < Fintype.card KË£
hi : i â‰  0
âŠ¢ âˆ‘ x : K, x ^ i = 0","theorem sum_pow_lt_card_sub_one (i : â„•) (h : i < q - 1) : âˆ‘ x : K, x ^ i = 0 ",":= by
  by_cases hi : i = 0
  Â· simp only [hi, nsmul_one, sum_const, pow_zero, card_univ, cast_card_eq_zero]
  classical
    have hiq : Â¬q - 1 âˆ£ i := by contrapose! h; exact Nat.le_of_dvd (Nat.pos_of_ne_zero hi) h
    let Ï† : KË£ â†ª K := âŸ¨fun x â†¦ x, Units.extâŸ©
    have : univ.map Ï† = univ \ {0} := by
      ext x
      simpa only [mem_map, mem_univ, Function.Embedding.coeFn_mk, true_and_iff, mem_sdiff,
        mem_singleton, Ï†] using isUnit_iff_ne_zero
    calc
      âˆ‘ x : K, x ^ i = âˆ‘ x âˆˆ univ \ {(0 : K)}, x ^ i := by
        rw [â† sum_sdiff ({0} : Finset K).subset_univ, sum_singleton, zero_pow hi, add_zero]
      _ = âˆ‘ x : KË£, (x ^ i : K) := by simp [Ï†, â† this, univ.sum_map Ï†]
      _ = 0 := by rw [sum_pow_units K i, if_neg]; exact hiq","simp only [sum_pow_lt_card_sub_one, sum_pow_lt_card_sub_one]"
Mathlib/CategoryTheory/Sites/Sheafification.lean,CategoryTheory.HasSheafify.mk',HasSheafify.mk',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,"  isRightAdjoint := âŸ¨âŸ¨F, adjâŸ©âŸ©
  isLeftExact :=
    let i : (h : IsRightAdjoint (sheafToPresheaf J A) := âŸ¨F, adjâŸ©) â†’
      F â‰… leftAdjoint (sheafToPresheaf J A) := fun _ â†¦
      adj.leftAdjointUniq (Adjunction.ofRightAdjoint (sheafToPresheaf J A))
    âŸ¨âŸ¨fun _ â†¦ preservesLimitsOfShapeOfNatIso (i _)âŸ©âŸ©","error:  application type mismatch
  Exists.intro F adj
argument
  adj
has type
  F âŠ£ sheafToPresheaf J A : Type (max (max (max (max uâ‚ uâ‚‚) vâ‚) vâ‚‚) uâ‚ vâ‚‚)
but is expected to have type
  Nonempty (F âŠ£ sheafToPresheaf J A) : Prop
error:  unknown identifier 'IsRightAdjoint'
error:  unknown identifier 'leftAdjoint'
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Adjunction
has type
  ?m.3996 â¥¤ ?m.4114 â†’ ?m.4114 â¥¤ ?m.3996 â†’ Type (max (max (max ?u.3993 ?u.3992) ?u.3995) ?u.3994)","theorem HasSheafify.mk' {F : (Cáµ’áµ– â¥¤ A) â¥¤ Sheaf J A} (adj : F âŠ£ sheafToPresheaf J A)
    [PreservesFiniteLimits F] : HasSheafify J A where
","  isRightAdjoint := âŸ¨F, âŸ¨adjâŸ©âŸ©
  isLeftExact := âŸ¨by
    have : (sheafToPresheaf J A).IsRightAdjoint := âŸ¨_, âŸ¨adjâŸ©âŸ©
    exact âŸ¨fun _ _ _ â†¦ preservesLimitsOfShapeOfNatIso
      (adj.leftAdjointUniq (Adjunction.ofIsRightAdjoint (sheafToPresheaf J A)))âŸ©âŸ©",apply HasSheafify.hasSheafify_of_hasSheafify
Mathlib/CategoryTheory/Adjunction/Reflective.lean,CategoryTheory.equivEssImageOfReflective_map_counitIso_app_hom,equivEssImageOfReflective_map_counitIso_app_hom,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,"  (Functor.essImageInclusion i).map (equivEssImageOfReflective_counitIso_app X).hom =
    inv (NatTrans.app (ofRightAdjoint i).unit X.obj) := by
    simp only [Functor.comp_obj, Functor.essImageInclusion_obj, Functor.toEssImage_obj_obj,
      equivEssImageOfReflective_counitIso_app, asIso, Iso.symm_mk, Functor.essImageInclusion_map,
      Functor.id_obj]
    rfl","error:  unknown identifier 'ofRightAdjoint'
error:  unknown identifier 'equivEssImageOfReflective_map_counitIso_app_hom'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.31459
case a
C : Type uâ‚
D : Type uâ‚‚
E : Type uâ‚ƒ
instâœÂ³ : Category.{vâ‚, uâ‚} C
instâœÂ² : Category.{vâ‚‚, uâ‚‚} D
instâœÂ¹ : Category.{vâ‚ƒ, uâ‚ƒ} E
i : D â¥¤ C
instâœ : Reflective i
X Y : i.EssImageSubcategory
f : X âŸ¶ Y
h : (reflectorAdjunction i).unit.app X.obj â‰« (reflector i â‹™ i).map f = f â‰« (reflectorAdjunction i).unit.app Y.obj
âŠ¢ i.essImageInclusion.map (((i.essImageInclusion â‹™ reflector i) â‹™ i.toEssImage).map f) â‰«
      i.essImageInclusion.map (equivEssImageOfReflective_counitIso_app Y).hom =
    i.essImageInclusion.map (equivEssImageOfReflective_counitIso_app X).hom â‰«
      i.essImageInclusion.map ((ğŸ­ i.EssImageSubcategory).map f)
error:  unknown identifier 'equivEssImageOfReflective_map_counitIso_app_hom'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.31883
case a
C : Type uâ‚
D : Type uâ‚‚
E : Type uâ‚ƒ
instâœÂ³ : Category.{vâ‚, uâ‚} C
instâœÂ² : Category.{vâ‚‚, uâ‚‚} D
instâœÂ¹ : Category.{vâ‚ƒ, uâ‚ƒ} E
i : D â¥¤ C
instâœ : Reflective i
X : D
âŠ¢ i.essImageInclusion.map
        (i.toEssImage.map
          ((NatIso.ofComponents (fun X â†¦ (asIso ((reflectorAdjunction i).counit.app X)).symm) â‹¯).hom.app X)) â‰«
      i.essImageInclusion.map
        ((NatIso.ofComponents equivEssImageOfReflective_counitIso_app â‹¯).hom.app (i.toEssImage.obj X)) =
    i.essImageInclusion.map (ğŸ™ (i.toEssImage.obj X))","lemma equivEssImageOfReflective_map_counitIso_app_hom [Reflective i]
    (X : Functor.EssImageSubcategory i) :
","  (Functor.essImageInclusion i).map (equivEssImageOfReflective_counitIso_app X).hom =
    inv (NatTrans.app (reflectorAdjunction i).unit X.obj) := by
    simp only [Functor.comp_obj, Functor.essImageInclusion_obj, Functor.toEssImage_obj_obj,
      equivEssImageOfReflective_counitIso_app, asIso, Iso.symm_mk, Functor.essImageInclusion_map,
      Functor.id_obj]
    rfl","simp only [equivEssImageOfReflective_map_counitIso_app_hom, equivEssImageOfReflective_map_counitIso_app]"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicOn.inv,inv,0788787e4cbf8892c4d5415e2a91fb7666b8fc59,":= by
  rcases hf with âŸ¨m, hfâŸ©
  by_cases h_eq : (fun z â†¦ (z - x) ^ m â€¢ f z) =á¶ [ğ“ x] 0
  Â· 
    apply (meromorphicAt_const 0 x).congr
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  Â· 
    obtain âŸ¨n, g, hg_an, hg_ne, hg_eqâŸ© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ğ•œ (fun z â†¦ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ğ•œ x).sub analyticAt_const).pow _
    refine âŸ¨n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_âŸ©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    Â· simp only [sub_self, pow_succ, zero_mul, zero_smul]
    Â· simp_rw [smul_eq_mul] at hfg âŠ¢
      have aux1 : f z â‰  0
      Â· have : (z - x) ^ n * g z â‰  0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [â† hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ, mul_assoc, hfg]
      ring","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case h.inl
ğ•œ : Type u_1
instâœÂ² : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace ğ•œ E
f : ğ•œ â†’ ğ•œ
m n : â„•
g : ğ•œ â†’ ğ•œ
z : ğ•œ
hg_ne' : g z â‰  0
hf : AnalyticAt ğ•œ (fun z_1 â†¦ (z_1 - z) ^ m â€¢ f z_1) z
h_eq : Â¬(fun z_1 â†¦ (z_1 - z) ^ m â€¢ f z_1) =á¶ [ğ“ z] 0
hg_an : AnalyticAt ğ•œ g z
hg_ne : g z â‰  0
hg_eq : âˆ€á¶  (z_1 : ğ•œ) in ğ“ z, (z_1 - z) ^ m â€¢ f z_1 = (z_1 - z) ^ n â€¢ g z_1
this : AnalyticAt ğ•œ (fun z_1 â†¦ (z_1 - z) ^ (m + 1)) z
hfg : (z - z) ^ m â€¢ f z = (z - z) ^ n â€¢ g z
âŠ¢ (0 ^ m * 0) â€¢ (g z)â»Â¹ = (0 ^ n * 0) â€¢ fâ»Â¹ z
error:  unsolved goals
case h.inr
ğ•œ : Type u_1
instâœÂ² : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace ğ•œ E
f : ğ•œ â†’ ğ•œ
x : ğ•œ
m : â„•
hf : AnalyticAt ğ•œ (fun z â†¦ (z - x) ^ m â€¢ f z) x
h_eq : Â¬(fun z â†¦ (z - x) ^ m â€¢ f z) =á¶ [ğ“ x] 0
n : â„•
g : ğ•œ â†’ ğ•œ
hg_an : AnalyticAt ğ•œ g x
hg_ne : g x â‰  0
hg_eq : âˆ€á¶  (z : ğ•œ) in ğ“ x, (z - x) ^ m â€¢ f z = (z - x) ^ n â€¢ g z
this : AnalyticAt ğ•œ (fun z â†¦ (z - x) ^ (m + 1)) x
z : ğ•œ
hfg : (z - x) ^ m * f z = (z - x) ^ n * g z
hg_ne' : g z â‰  0
hz_ne : z â‰  x
aux1 : f z â‰  0
âŠ¢ (z - x) ^ (m + 1) * (g z)â»Â¹ = (z - x) ^ (n + 1) * fâ»Â¹ z",lemma inv {f : ğ•œ â†’ ğ•œ} {x : ğ•œ} (hf : MeromorphicAt f x) : MeromorphicAt fâ»Â¹ x ,":= by
  rcases hf with âŸ¨m, hfâŸ©
  by_cases h_eq : (fun z â†¦ (z - x) ^ m â€¢ f z) =á¶ [ğ“ x] 0
  Â· 
    refine (MeromorphicAt.const 0 x).congr ?_
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  Â· 
    obtain âŸ¨n, g, hg_an, hg_ne, hg_eqâŸ© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ğ•œ (fun z â†¦ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ğ•œ x).sub analyticAt_const).pow _
    refine âŸ¨n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_âŸ©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    Â· simp only [sub_self, pow_succ, mul_zero, zero_smul]
    Â· simp_rw [smul_eq_mul] at hfg âŠ¢
      have aux1 : f z â‰  0 := by
        have : (z - x) ^ n * g z â‰  0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [â† hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ', mul_assoc, hfg]
      ring",simp [MeromorphicAt]
Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean,Finpartition.equitabilise_aux,equitabilise_aux,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  Â· refine' âŸ¨âŠ¥, by simp, _, by simpa using hs.symmâŸ©
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id.def, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      âŸ¨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _âŸ©
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 âˆ§ b = 0
  Â· simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (Î± := Finpartition âŠ¥) P
    exact âŸ¨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]âŸ©
  simp_rw [not_and_or, â† Ne.def, â† pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain âŸ¨hnâ‚€, hnâ‚, hnâ‚‚, hnâ‚ƒâŸ© : 0 < n âˆ§ n â‰¤ m + 1 âˆ§ n â‰¤ a * m + b * (m + 1) âˆ§
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, â† hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    Â· refine' âŸ¨m_pos, le_succ _, le_add_right (le_mul_of_pos_left â€¹0 < aâ€º), _âŸ©
      rw [tsub_add_eq_add_tsub (le_mul_of_pos_left h)]
    Â· refine' âŸ¨succ_pos', le_rfl, le_add_left (le_mul_of_pos_left <| hab.resolve_left â€¹Â¬0 < aâ€º), _âŸ©
      rw [â† add_tsub_assoc_of_le (le_mul_of_pos_left <| hab.resolve_left â€¹Â¬0 < aâ€º)]
  by_cases h : âˆ€ u âˆˆ P.parts, card u < m + 1
  Â· obtain âŸ¨t, hts, htnâŸ© := exists_smaller_set s n (hnâ‚‚.trans_eq hs)
    have ht : t.Nonempty := by rwa [â† card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff â€¹t âŠ† sâ€º, htn, hnâ‚ƒ]
    obtain âŸ¨R, hRâ‚, _, hRâ‚ƒâŸ© :=
      @ih (s \ t) (sdiff_ssubset hts â€¹t.Nonemptyâ€º) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine' âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), _, _, _âŸ©
    Â· simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => (card_le_card <| sdiff_subset _ _).trans (lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    Â· rw [hRâ‚ƒ, if_pos ha]
    rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg ha, tsub_add_cancel_of_le]
    Â· exact hab.resolve_left ha
    Â· intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg at h
  obtain âŸ¨u, huâ‚, huâ‚‚âŸ© := h
  obtain âŸ¨t, htu, htnâŸ© := exists_smaller_set _ _ (hnâ‚.trans huâ‚‚)
  have ht : t.Nonempty := by rwa [â† card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le huâ‚), htn, hnâ‚ƒ]
  obtain âŸ¨R, hRâ‚, hRâ‚‚, hRâ‚ƒâŸ© :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le huâ‚) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine' âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le huâ‚), _, _, _âŸ©
  Â· simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hRâ‚, htn, hn]
    exact ite_eq_or_eq _ _ _
  Â· conv in _ âˆˆ _ => rw [â† insert_erase huâ‚]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne.def, extend_parts]
    refine' âŸ¨_, fun x hx => (card_le_card _).trans <| hRâ‚‚ x _âŸ©
    Â· simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id.def]
      obtain rfl | hut := eq_or_ne u t
      Â· rw [sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)]
        exact bot_le
      refine'
        (card_le_card fun i => _).trans
          (hRâ‚‚ (u \ t) <| P.mem_avoid.2 âŸ¨u, huâ‚, fun i => hut <| i.antisymm htu, rflâŸ©)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id.def, not_or]
      exact fun hiâ‚ hiâ‚‚ hiâ‚ƒ =>
        âŸ¨âŸ¨hiâ‚, hiâ‚‚âŸ©, fun x hx hx' => hiâ‚ƒ _ hx <| hx'.trans <| sdiff_subset _ _âŸ©
    Â· apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      âŸ¨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) huâ‚ <| ne_of_mem_erase hx).sdiff_eq_leftâŸ©
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  Â· rw [hRâ‚ƒ, if_pos h]
  Â· rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)","error:  type mismatch
  hâœ
has type
  s.card = b : Prop
but is expected to have type
  (filter (fun i â†¦ i.card = 1) (Finset.map { toFun := singleton, inj' := â‹¯ } s)).card = b : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.6768 â†’ ?m.6768
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.12503 â†’ ?m.12503 â†’ Prop
error:  simp made no progress","theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    âˆƒ Q : Finpartition s,
      (âˆ€ x : Finset Î±, x âˆˆ Q.parts â†’ x.card = m âˆ¨ x.card = m + 1) âˆ§
        (âˆ€ x, x âˆˆ P.parts â†’ (x \ (Q.parts.filter fun y => y âŠ† x).biUnion id).card â‰¤ m) âˆ§
          (Q.parts.filter fun i => card i = m + 1).card = b ",":= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  Â· refine âŸ¨âŠ¥, by simp, ?_, by simpa [Finset.filter_true_of_mem] using hs.symmâŸ©
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      âŸ¨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _âŸ©
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 âˆ§ b = 0
  Â· simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (Î± := Finpartition âŠ¥) P
    exact âŸ¨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]âŸ©
  simp_rw [not_and_or, â† Ne.eq_def, â† pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain âŸ¨hnâ‚€, hnâ‚, hnâ‚‚, hnâ‚ƒâŸ© : 0 < n âˆ§ n â‰¤ m + 1 âˆ§ n â‰¤ a * m + b * (m + 1) âˆ§
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, â† hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    Â· refine âŸ¨m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ â€¹0 < aâ€º), ?_âŸ©
      rw [tsub_add_eq_add_tsub (Nat.le_mul_of_pos_left _ h)]
    Â· refine âŸ¨succ_pos', le_rfl,
        le_add_left (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º), ?_âŸ©
      rw [â† add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º)]
  by_cases h : âˆ€ u âˆˆ P.parts, card u < m + 1
  Â· obtain âŸ¨t, hts, htnâŸ© := exists_subset_card_eq (hnâ‚‚.trans_eq hs)
    have ht : t.Nonempty := by rwa [â† card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff â€¹t âŠ† sâ€º, htn, hnâ‚ƒ]
    obtain âŸ¨R, hRâ‚, _, hRâ‚ƒâŸ© :=
      @ih (s \ t) (sdiff_ssubset hts â€¹t.Nonemptyâ€º) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), ?_, ?_, ?_âŸ©
    Â· simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => (card_le_card sdiff_subset).trans (Nat.lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    Â· rw [hRâ‚ƒ, if_pos ha]
    rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg ha, tsub_add_cancel_of_le]
    Â· exact hab.resolve_left ha
    Â· intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg at h
  obtain âŸ¨u, huâ‚, huâ‚‚âŸ© := h
  obtain âŸ¨t, htu, htnâŸ© := exists_subset_card_eq (hnâ‚.trans huâ‚‚)
  have ht : t.Nonempty := by rwa [â† card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le huâ‚), htn, hnâ‚ƒ]
  obtain âŸ¨R, hRâ‚, hRâ‚‚, hRâ‚ƒâŸ© :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le huâ‚) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine
    âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le huâ‚), ?_, ?_, ?_âŸ©
  Â· simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hRâ‚, htn, hn]
    exact ite_eq_or_eq _ _ _
  Â· conv in _ âˆˆ _ => rw [â† insert_erase huâ‚]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne, extend_parts]
    refine âŸ¨?_, fun x hx => (card_le_card ?_).trans <| hRâ‚‚ x ?_âŸ©
    Â· simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id]
      obtain rfl | hut := eq_or_ne u t
      Â· rw [sdiff_eq_empty_iff_subset.2 subset_union_left]
        exact bot_le
      refine
        (card_le_card fun i => ?_).trans
          (hRâ‚‚ (u \ t) <| P.mem_avoid.2 âŸ¨u, huâ‚, fun i => hut <| i.antisymm htu, rflâŸ©)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id, not_or]
      exact fun hiâ‚ hiâ‚‚ hiâ‚ƒ =>
        âŸ¨âŸ¨hiâ‚, hiâ‚‚âŸ©, fun x hx hx' => hiâ‚ƒ _ hx <| hx'.trans sdiff_subsetâŸ©
    Â· apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      âŸ¨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) huâ‚ <| ne_of_mem_erase hx).sdiff_eq_leftâŸ©
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  Â· rw [hRâ‚ƒ, if_pos h]
  Â· rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)","refine âŸ¨Q, equitabilise_aux, equitabilise_aux, equitabilise_aux, hs, ?_âŸ©"
Mathlib/RingTheory/DedekindDomain/Ideal.lean,FractionalIdeal.coe_ideal_mul_inv,coe_ideal_mul_inv,db4b2acc70490f6bcea6872fdf1d716949f8c1e7,":= by
  apply mul_inv_cancel_of_le_one hI0
  by_cases hJ0 : I * (I : FractionalIdeal Aâ° K)â»Â¹ = 0
  Â· rw [hJ0, inv_zero']; exact zero_le _
  intro x hx
  have := IsDedekindDomain.isIntegrallyClosed A K
  suffices x âˆˆ integralClosure A K by
    rwa [IsIntegrallyClosed.integralClosure_eq_bot, Algebra.mem_bot, Set.mem_range,
      â† mem_one_iff] at this
  rw [mem_integralClosure_iff_mem_FG]
  have x_mul_mem : âˆ€ b âˆˆ (Iâ»Â¹ : FractionalIdeal Aâ° K), x * b âˆˆ (Iâ»Â¹ : FractionalIdeal Aâ° K) := by
    intro b hb
    rw [mem_inv_iff (coeIdeal_ne_zero.mpr hI0)]
    dsimp only at hx
    rw [val_eq_coe, mem_coe, mem_inv_iff hJ0] at hx
    simp only [mul_assoc, mul_comm b] at hx âŠ¢
    intro y hy
    exact hx _ (mul_mem_mul hy hb)
  refine âŸ¨AlgHom.range (Polynomial.aeval x : A[X] â†’â‚[A] K),
    isNoetherian_submodule.mp (isNoetherian (I : FractionalIdeal Aâ° K)â»Â¹) _ fun y hy => ?_,
    âŸ¨Polynomial.X, Polynomial.aeval_X xâŸ©âŸ©
  obtain âŸ¨p, rflâŸ© := (AlgHom.mem_range _).mp hy
  rw [Polynomial.aeval_eq_sum_range]
  refine Submodule.sum_mem _ fun i hi => Submodule.smul_mem _ _ ?_
  clear hi
  induction' i with i ih
  Â· rw [pow_zero]; exact one_mem_inv_coe_ideal hI0
  Â· show x ^ i.succ âˆˆ (Iâ»Â¹ : FractionalIdeal Aâ° K)
    rw [pow_succ]; exact x_mul_mem _ ih","error:  unknown constant 'IsDedekindDomain.isIntegrallyClosed'
error:  unsolved goals
case neg
R : Type u_1
A : Type u_2
K : Type u_3
instâœâ´ : CommRing R
instâœÂ³ : CommRing A
instâœÂ² : Field K
instâœÂ¹ : Algebra A K
instâœ : IsFractionRing A K
h : IsDedekindDomain A
I : Ideal A
hI0 : I â‰  âŠ¥
hJ0 : Â¬â†‘I * (â†‘I)â»Â¹ = 0
x : K
hx : x âˆˆ (fun a â†¦ â†‘a) (â†‘I * (â†‘I)â»Â¹)â»Â¹
âŠ¢ x âˆˆ (fun a â†¦ â†‘a) 1","theorem coe_ideal_mul_inv [h : IsDedekindDomain A] (I : Ideal A) (hI0 : I â‰  âŠ¥) :
    I * (I : FractionalIdeal Aâ° K)â»Â¹ = 1 ",":= by
  apply mul_inv_cancel_of_le_one hI0
  by_cases hJ0 : I * (I : FractionalIdeal Aâ° K)â»Â¹ = 0
  Â· rw [hJ0, inv_zero']; exact zero_le _
  intro x hx
  suffices x âˆˆ integralClosure A K by
    rwa [IsIntegrallyClosed.integralClosure_eq_bot, Algebra.mem_bot, Set.mem_range,
      â† mem_one_iff] at this
  rw [mem_integralClosure_iff_mem_fg]
  have x_mul_mem : âˆ€ b âˆˆ (Iâ»Â¹ : FractionalIdeal Aâ° K), x * b âˆˆ (Iâ»Â¹ : FractionalIdeal Aâ° K) := by
    intro b hb
    rw [mem_inv_iff (coeIdeal_ne_zero.mpr hI0)]
    dsimp only at hx
    rw [val_eq_coe, mem_coe, mem_inv_iff hJ0] at hx
    simp only [mul_assoc, mul_comm b] at hx âŠ¢
    intro y hy
    exact hx _ (mul_mem_mul hy hb)
  refine âŸ¨AlgHom.range (Polynomial.aeval x : A[X] â†’â‚[A] K),
    isNoetherian_submodule.mp (isNoetherian (I : FractionalIdeal Aâ° K)â»Â¹) _ fun y hy => ?_,
    âŸ¨Polynomial.X, Polynomial.aeval_X xâŸ©âŸ©
  obtain âŸ¨p, rflâŸ© := (AlgHom.mem_range _).mp hy
  rw [Polynomial.aeval_eq_sum_range]
  refine Submodule.sum_mem _ fun i hi => Submodule.smul_mem _ _ ?_
  clear hi
  induction' i with i ih
  Â· rw [pow_zero]; exact one_mem_inv_coe_ideal hI0
  Â· show x ^ i.succ âˆˆ (Iâ»Â¹ : FractionalIdeal Aâ° K)
    rw [pow_succ']; exact x_mul_mem _ ih",exact inv_eq_one_of_mul_eq_one _
Mathlib/Probability/Martingale/Convergence.lean,MeasureTheory.Submartingale.ae_tendsto_limitProcess,Submartingale.ae_tendsto_limitProcess,be55166c883a8ce6c537d5f0d2dd43baed489981,":= by
  classical
  suffices
      âˆƒ g, StronglyMeasurable[â¨† n, â„± n] g âˆ§ âˆ€áµ Ï‰ âˆ‚Î¼, Tendsto (fun n => f n Ï‰) atTop (ğ“ (g Ï‰)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Î© â†’ â„ := fun Ï‰ => if h : âˆƒ c, Tendsto (fun n => f n Ï‰) atTop (ğ“ c) then h.choose else 0
  have hle : (â¨† n, â„± n) â‰¤ m0 := sSup_le fun m âŸ¨n, hnâŸ© => hn â–¸ â„±.le _
  have hg' : âˆ€áµ Ï‰ âˆ‚Î¼.trim hle, Tendsto (fun n => f n Ï‰) atTop (ğ“ (g' Ï‰)) := by
    filter_upwards [hf.exists_ae_trim_tendsto_of_bdd hbdd] with Ï‰ hÏ‰
    simp_rw [dif_pos hÏ‰]
    exact hÏ‰.choose_spec
  have hg'm : @AEStronglyMeasurable _ _ _ (â¨† n, â„± n) g' (Î¼.trim hle) :=
    (@aemeasurable_of_tendsto_metrizable_ae' _ _ (â¨† n, â„± n) _ _ _ _ _ _ _
      (fun n => ((hf.stronglyMeasurable n).measurable.mono (le_sSup âŸ¨n, rflâŸ© : â„± n â‰¤ â¨† n, â„± n)
        le_rfl).aemeasurable) hg').aestronglyMeasurable
  obtain âŸ¨g, hgm, haeâŸ© := hg'm
  have hg : âˆ€áµ Ï‰ âˆ‚Î¼.trim hle, Tendsto (fun n => f n Ï‰) atTop (ğ“ (g Ï‰)) := by
    filter_upwards [hae, hg'] with Ï‰ hÏ‰ hg'Ï‰
    exact hÏ‰ â–¸ hg'Ï‰
  exact âŸ¨g, hgm, measure_eq_zero_of_trim_eq_zero hle hgâŸ©",error:  simp made no progress,"theorem Submartingale.ae_tendsto_limitProcess [IsFiniteMeasure Î¼] (hf : Submartingale f â„± Î¼)
    (hbdd : âˆ€ n, snorm (f n) 1 Î¼ â‰¤ R) :
    âˆ€áµ Ï‰ âˆ‚Î¼, Tendsto (fun n => f n Ï‰) atTop (ğ“ (â„±.limitProcess f Î¼ Ï‰)) ",":= by
  classical
  suffices
      âˆƒ g, StronglyMeasurable[â¨† n, â„± n] g âˆ§ âˆ€áµ Ï‰ âˆ‚Î¼, Tendsto (fun n => f n Ï‰) atTop (ğ“ (g Ï‰)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Î© â†’ â„ := fun Ï‰ => if h : âˆƒ c, Tendsto (fun n => f n Ï‰) atTop (ğ“ c) then h.choose else 0
  have hle : â¨† n, â„± n â‰¤ m0 := sSup_le fun m âŸ¨n, hnâŸ© => hn â–¸ â„±.le _
  have hg' : âˆ€áµ Ï‰ âˆ‚Î¼.trim hle, Tendsto (fun n => f n Ï‰) atTop (ğ“ (g' Ï‰)) := by
    filter_upwards [hf.exists_ae_trim_tendsto_of_bdd hbdd] with Ï‰ hÏ‰
    simp_rw [g', dif_pos hÏ‰]
    exact hÏ‰.choose_spec
  have hg'm : @AEStronglyMeasurable _ _ _ (â¨† n, â„± n) g' (Î¼.trim hle) :=
    (@aemeasurable_of_tendsto_metrizable_ae' _ _ (â¨† n, â„± n) _ _ _ _ _ _ _
      (fun n => ((hf.stronglyMeasurable n).measurable.mono (le_sSup âŸ¨n, rflâŸ© : â„± n â‰¤ â¨† n, â„± n)
        le_rfl).aemeasurable) hg').aestronglyMeasurable
  obtain âŸ¨g, hgm, haeâŸ© := hg'm
  have hg : âˆ€áµ Ï‰ âˆ‚Î¼.trim hle, Tendsto (fun n => f n Ï‰) atTop (ğ“ (g Ï‰)) := by
    filter_upwards [hae, hg'] with Ï‰ hÏ‰ hg'Ï‰
    exact hÏ‰ â–¸ hg'Ï‰
  exact âŸ¨g, hgm, measure_eq_zero_of_trim_eq_zero hle hgâŸ©",refine tendsto_limitProcess_of_ae_tendsto_limitProcess hf hbdd hbdd fun n => ?_
Mathlib/Topology/Compactness/Lindelof.lean,hasBasis_coclosedLindelof,hasBasis_coclosedLindelof,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  simp only [Filter.coclosedLindelof, iInf_and']
  refine hasBasis_biInf_principal' ?_ âŸ¨âˆ…, isClosed_empty, isLindelof_emptyâŸ©
  rintro s âŸ¨hsâ‚, hsâ‚‚âŸ© t âŸ¨htâ‚, htâ‚‚âŸ©
  exact âŸ¨s âˆª t, âŸ¨âŸ¨hsâ‚.union htâ‚, hsâ‚‚.union htâ‚‚âŸ©, compl_subset_compl.2 (subset_union_left _ _),
    compl_subset_compl.2 (subset_union_right _ _)âŸ©âŸ©","error:  function expected at
  subset_union_left ?m.40156
term has type
  ?m.40155 âˆˆ ?m.40153 âˆª ?m.40154
error:  function expected at
  subset_union_right ?m.40208
term has type
  ?m.40207 âˆˆ ?m.40205 âˆª ?m.40206","theorem hasBasis_coclosedLindelof :
    (Filter.coclosedLindelof X).HasBasis (fun s => IsClosed s âˆ§ IsLindelof s) compl ",":= by
  simp only [Filter.coclosedLindelof, iInf_and']
  refine hasBasis_biInf_principal' ?_ âŸ¨âˆ…, isClosed_empty, isLindelof_emptyâŸ©
  rintro s âŸ¨hsâ‚, hsâ‚‚âŸ© t âŸ¨htâ‚, htâ‚‚âŸ©
  exact âŸ¨s âˆª t, âŸ¨âŸ¨hsâ‚.union htâ‚, hsâ‚‚.union htâ‚‚âŸ©, compl_subset_compl.2 subset_union_left,
    compl_subset_compl.2 subset_union_rightâŸ©âŸ©",rw [â† hasBasis_coclosedLindelof.isClosed_iff] at hasBasis_coclosedLindelof
Mathlib/MeasureTheory/Group/Prod.lean,MeasureTheory.measure_lintegral_div_measure,measure_lintegral_div_measure,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  set g := fun y => f yâ»Â¹ / Î½ ((fun x => x * yâ»Â¹) â»Â¹' s)
  have hg : Measurable g :=
    (hf.comp measurable_inv).div ((measurable_measure_mul_right Î½ sm).comp measurable_inv)
  simp_rw [measure_mul_lintegral_eq Î¼ Î½ sm g hg, inv_inv]
  refine' lintegral_congr_ae _
  refine' (ae_measure_preimage_mul_right_lt_top_of_ne_zero Î¼ Î½ sm h2s h3s).mono fun x hx => _
  simp_rw [ENNReal.mul_div_cancel' (measure_mul_right_ne_zero Î½ h2s _) hx.ne]",error:  simp made no progress,"theorem measure_lintegral_div_measure [IsMulLeftInvariant Î½] (sm : MeasurableSet s) (h2s : Î½ s â‰  0)
    (h3s : Î½ s â‰  âˆ) (f : G â†’ â„â‰¥0âˆ) (hf : Measurable f) :
    (Î¼ s * âˆ«â» y, f yâ»Â¹ / Î½ ((fun x => x * yâ»Â¹) â»Â¹' s) âˆ‚Î½) = âˆ«â» x, f x âˆ‚Î¼ ",":= by
  set g := fun y => f yâ»Â¹ / Î½ ((fun x => x * yâ»Â¹) â»Â¹' s)
  have hg : Measurable g :=
    (hf.comp measurable_inv).div ((measurable_measure_mul_right Î½ sm).comp measurable_inv)
  simp_rw [measure_mul_lintegral_eq Î¼ Î½ sm g hg, g, inv_inv]
  refine lintegral_congr_ae ?_
  refine (ae_measure_preimage_mul_right_lt_top_of_ne_zero Î¼ Î½ sm h2s h3s).mono fun x hx => ?_
  simp_rw [ENNReal.mul_div_cancel' (measure_mul_right_ne_zero Î½ h2s _) hx.ne]",refine theorem_measure_lintegral_div_measure_eq_lintegral_div_measure ?_ ?_
Mathlib/CategoryTheory/Sites/Canonical.lean,CategoryTheory.Sheaf.isSheafFor_trans,isSheafFor_trans,a94e348e169a5be4a12ee3126b97e400fc7980e7,":= by
  have : (bind R fun Y f _ => S.pullback f : Presieve X) â‰¤ S := by
    rintro Z f âŸ¨W, f, g, hg, hf : S _, rflâŸ©
    apply hf
  apply Presieve.isSheafFor_subsieve_aux P this
  apply isSheafFor_bind _ _ _ hR hS
  Â· intro Y f hf Z g
    dsimp
    rw [â† pullback_comp]
    apply (hS (R.downward_closed hf _)).isSeparatedFor
  Â· intro Y f hf
    have : Sieve.pullback f (bind R fun T (k : T âŸ¶ X) (_ : R k) => pullback k S) =
        R.pullback f := by
      ext Z
      intro g
      constructor
      Â· rintro âŸ¨W, k, l, hl, _, commâŸ©
        rw [pullback_apply, â† comm]
        simp [hl]
      Â· intro a
        refine' âŸ¨Z, ğŸ™ Z, _, a, _âŸ©
        simp [hf]
    rw [this]
    apply hR' hf","error:  dsimp made no progress
error:  tactic 'introN' failed, insufficient number of binders
case h
C : Type u
instâœ : Category.{v, u} C
Pâœ : Cáµ’áµ– â¥¤ Type v
X Yâœ : C
Sâœ : Sieve X
Râœ : Presieve X
J Jâ‚‚ : GrothendieckTopology C
P : Cáµ’áµ– â¥¤ Type v
R S : Sieve X
hR : Presieve.IsSheafFor P R.arrows
hR' : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, S.arrows f â†’ Presieve.IsSeparatedFor P (Sieve.pullback f R).arrows
hS : âˆ€ â¦ƒY : Câ¦„ â¦ƒf : Y âŸ¶ Xâ¦„, R.arrows f â†’ Presieve.IsSheafFor P (Sieve.pullback f S).arrows
this : (Sieve.bind R.arrows fun Y f x â†¦ Sieve.pullback f S).arrows â‰¤ S.arrows
Y : C
f : Y âŸ¶ X
hf : S.arrows f
Z : C
fâœ : Z âŸ¶ Y
âŠ¢ (Sieve.pullback f (Sieve.bind R.arrows fun T k x â†¦ Sieve.pullback k S)).arrows fâœ â†” (Sieve.pullback f R).arrows fâœ","theorem isSheafFor_trans (P : Cáµ’áµ– â¥¤ Type v) (R S : Sieve X)
    (hR : Presieve.IsSheafFor P (R : Presieve X))
    (hR' : âˆ€ â¦ƒYâ¦„ â¦ƒf : Y âŸ¶ Xâ¦„ (_ : S f), Presieve.IsSeparatedFor P (R.pullback f : Presieve Y))
    (hS : âˆ€ â¦ƒYâ¦„ â¦ƒf : Y âŸ¶ Xâ¦„ (_ : R f), Presieve.IsSheafFor P (S.pullback f : Presieve Y)) :
    Presieve.IsSheafFor P (S : Presieve X) ",":= by
  have : (bind R fun Y f _ => S.pullback f : Presieve X) â‰¤ S := by
    rintro Z f âŸ¨W, f, g, hg, hf : S _, rflâŸ©
    apply hf
  apply Presieve.isSheafFor_subsieve_aux P this
  Â· apply isSheafFor_bind _ _ _ hR hS
    intro Y f hf Z g
    rw [â† pullback_comp]
    apply (hS (R.downward_closed hf _)).isSeparatedFor
  Â· intro Y f hf
    have : Sieve.pullback f (bind R fun T (k : T âŸ¶ X) (_ : R k) => pullback k S) =
        R.pullback f := by
      ext Z g
      constructor
      Â· rintro âŸ¨W, k, l, hl, _, commâŸ©
        rw [pullback_apply, â† comm]
        simp [hl]
      Â· intro a
        refine âŸ¨Z, ğŸ™ Z, _, a, ?_âŸ©
        simp [hf]
    rw [this]
    apply hR' hf",apply Presieve.isSheafFor_theorem_isSheafFor
Mathlib/Analysis/Convex/Basic.lean,MonotoneOn.convex_gt,MonotoneOn.convex_gt,03690a4c3252f422184189d0b6a6dd8d1c55d551,":=
  @MonotoneOn.convex_lt ğ•œ Eáµ’áµˆ Î²áµ’áµˆ _ _ _ _ _ _ _ _ _ _ hf.dual hs r","error:  application type mismatch
  @convex_lt ğ•œ Eáµ’áµˆ Î²áµ’áµˆ ?m.138156 ?m.138157 ?m.138158 ?m.138159 ?m.138160 ?m.138161 ?m.138162 ?m.138163 ?m.138164
    ?m.138165 (dual hf)
argument
  dual hf
has type
  MonotoneOn (â‡‘OrderDual.toDual âˆ˜ f âˆ˜ â‡‘OrderDual.ofDual) s : Prop
but is expected to have type
  Eáµ’áµˆ : Type u_2
error:  application type mismatch
  MonotoneOn.convex_gt ?m.146291 hf
argument
  hf
has type
  AntitoneOn f s : Prop
but is expected to have type
  Convex ğ•œ ?m.146289 : Prop","theorem MonotoneOn.convex_gt (hf : MonotoneOn f s) (hs : Convex ğ•œ s) (r : Î²) :
    Convex ğ•œ ({ x âˆˆ s | r < f x }) ",":=
  @MonotoneOn.convex_lt ğ•œ Eáµ’áµˆ Î²áµ’áµˆ _ _ _ _ _ _ _ hf.dual hs r","simp only [MonotoneOn.convex_gt, MonotoneOn.convex_gt]"
Mathlib/CategoryTheory/Sites/Plus.lean,CategoryTheory.GrothendieckTopology.plusMap_toPlus,plusMap_toPlus,e044580ec850092e8f63fd442e5a9b44c3651b83,":= by
  ext X : 2
  refine' colimit.hom_ext (fun S => _)
  dsimp only [plusMap, toPlus]
  let e : S.unop âŸ¶ âŠ¤ := homOfLE (OrderTop.le_top _)
  rw [Î¹_colimMap, â† colimit.w _ e.op, â† Category.assoc, â† Category.assoc]
  congr 1
  refine' Multiequalizer.hom_ext _ _ _ (fun I => _)
  erw [Multiequalizer.lift_Î¹]
  simp only [unop_op, op_unop, diagram_map, Category.assoc, limit.lift_Ï€,
    Multifork.ofÎ¹_Ï€_app]
  let ee : (J.pullback (I.map e).f).obj S.unop âŸ¶ âŠ¤ := homOfLE (OrderTop.le_top _)
  erw [â† colimit.w _ ee.op, Î¹_colimMap_assoc, colimit.Î¹_pre, diagramPullback_app,
    â† Category.assoc, â† Category.assoc]
  congr 1
  refine' Multiequalizer.hom_ext _ _ _ (fun II => _)
  convert (Multiequalizer.condition (S.unop.index P)
      âŸ¨_, _, _, II.f, ğŸ™ _, I.f, II.f â‰« I.f, I.hf,
        Sieve.downward_closed _ I.hf _, by simpâŸ©) using 1
  Â· dsimp [diagram]
    cases I
    simp only [Category.assoc, limit.lift_Ï€, Multifork.ofÎ¹_pt, Multifork.ofÎ¹_Ï€_app,
      Cover.Arrow.map_Y, Cover.Arrow.map_f]
    rfl
  Â· erw [Multiequalizer.lift_Î¹]
    dsimp [Cover.index]
    simp only [Functor.map_id, Category.comp_id]
    rfl","error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #5 provided
error:  application type mismatch
  @Cover.Arrow.Relation.mk C instâœÂ³ X.unop J S.unop I ?m.125321 II.Y II.f (ğŸ™ II.Y)
argument
  ğŸ™ II.Y
has type
  II.Y âŸ¶ II.Y : Type v
but is expected to have type
  II.Y âŸ¶ ?m.125321.Y : Type v",theorem plusMap_toPlus : J.plusMap (J.toPlus P) = J.toPlus (J.plusObj P) ,":= by
  ext X : 2
  refine colimit.hom_ext (fun S => ?_)
  dsimp only [plusMap, toPlus]
  let e : S.unop âŸ¶ âŠ¤ := homOfLE (OrderTop.le_top _)
  rw [Î¹_colimMap, â† colimit.w _ e.op, â† Category.assoc, â† Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun I => ?_)
  erw [Multiequalizer.lift_Î¹]
  simp only [unop_op, op_unop, diagram_map, Category.assoc, limit.lift_Ï€,
    Multifork.ofÎ¹_Ï€_app]
  let ee : (J.pullback (I.map e).f).obj S.unop âŸ¶ âŠ¤ := homOfLE (OrderTop.le_top _)
  erw [â† colimit.w _ ee.op, Î¹_colimMap_assoc, colimit.Î¹_pre, diagramPullback_app,
    â† Category.assoc, â† Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun II => ?_)
  convert Multiequalizer.condition (S.unop.index P)
    (Cover.Relation.mk I II.base { gâ‚ := II.f, gâ‚‚ := ğŸ™ _ }) using 1
  all_goals dsimp; simp","simp [J.toPlusMap_eq, plusMap_toPlus]"
Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean,AlgebraicGeometry.Î“Spec.adjunction_homEquiv_apply,adjunction_homEquiv_apply,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  dsimp [adjunction, Adjunction.restrictFullyFaithful, equivOfFullyFaithful]
  simp","error:  unknown identifier 'equivOfFullyFaithful'
error:  simp made no progress","theorem adjunction_homEquiv_apply {X : Scheme} {R : CommRingCatáµ’áµ–}
    (f : (op <| Scheme.Î“.obj <| op X) âŸ¶ R) :
    Î“Spec.adjunction.homEquiv X R f = locallyRingedSpaceAdjunction.homEquiv X.1 R f ",:= rfl,dsimp [locallyRingedSpaceAdjunction]
Mathlib/Analysis/Convex/Gauge.lean,Absorbent.gauge_set_nonempty,Absorbent.gauge_set_nonempty,f41d2e3dd69004ca4172132a94e749b22b59caae,":=
  let âŸ¨r, hrâ‚, hrâ‚‚âŸ© := absorbs x
  âŸ¨r, hrâ‚, hrâ‚‚ r (Real.norm_of_nonneg hrâ‚.le).geâŸ©","error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  âˆ€ â¦ƒx_1 : â„â¦„,
    x_1 âˆˆ {x_2 | (fun a â†¦ {x} âŠ† a â€¢ s) x_2}á¶œ â†’
      âˆ€ â¦ƒy : â„â¦„, y âˆˆ {x_2 | (fun a â†¦ {x} âŠ† a â€¢ s) x_2}á¶œ â†’ (fun x y â†¦ |x - y|) x_1 y â‰¤ r","theorem Absorbent.gauge_set_nonempty (absorbs : Absorbent â„ s) :
    { r : â„ | 0 < r âˆ§ x âˆˆ r â€¢ s }.Nonempty ",":=
  let âŸ¨r, hrâ‚, hrâ‚‚âŸ© := (absorbs x).exists_pos
  âŸ¨r, hrâ‚, hrâ‚‚ r (Real.norm_of_nonneg hrâ‚.le).ge rflâŸ©","obtain âŸ¨r, hr, hxâŸ© : âˆƒ r : â„, 0 < r âˆ§ x âˆˆ r â€¢ s := Absorbent.gauge_set_nonempty s"
Mathlib/NumberTheory/Padics/PadicVal.lean,padicValNat.padicValNat_eq_maxPowDiv,padicValNat_eq_maxPowDiv,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  ext p n
  by_cases h : 1 < p âˆ§ 0 < n
  Â· dsimp [padicValNat]
    rw [dif_pos âŸ¨Nat.ne_of_gt h.1,h.2âŸ©, maxPowDiv_eq_multiplicity_get h.1 h.2]
  Â· simp only [not_and_or,not_gt_eq,le_zero_iff] at h
    apply h.elim
    Â· intro h
      interval_cases p
      Â· simp [Classical.em]
      Â· dsimp [padicValNat, maxPowDiv]
        rw [go_eq, if_neg, dif_neg] <;> simp
    Â· intro h
      simp [h]","error:  unknown identifier 'go_eq'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.9947
case neg.left.Â«1Â»
pâœ p n : â„•
hâœ : 1 â‰¤ 1 âˆ¨ n = 0
h : 1 â‰¤ 1
âŠ¢ 0 = go 0 1 n",theorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv ,":= by
  ext p n
  by_cases h : 1 < p âˆ§ 0 < n
  Â· dsimp [padicValNat]
    rw [dif_pos âŸ¨Nat.ne_of_gt h.1,h.2âŸ©, maxPowDiv_eq_multiplicity_get h.1 h.2]
  Â· simp only [not_and_or,not_gt_eq,Nat.le_zero] at h
    apply h.elim
    Â· intro h
      interval_cases p
      Â· simp [Classical.em]
      Â· dsimp [padicValNat, maxPowDiv]
        rw [go, if_neg]; simp
    Â· intro h
      simp [h]",rw [padicValNat_eq_maxPowDiv]
Mathlib/LinearAlgebra/FiniteDimensional.lean,FiniteDimensional.of_fintype_basis,of_fintype_basis,44d0abee8c9db1dbf8d88d89f61bae7c34234d96,":= by
  cases nonempty_fintype Î¹
  exact âŸ¨âŸ¨Finset.univ.image h, by
    convert h.span_eq
    simpâŸ©âŸ©","error:  failed to synthesize
  DecidableEq V
use `set_option diagnostics true` to get diagnostic information
error:  simp made no progress",theorem of_fintype_basis {Î¹ : Type w} [Finite Î¹] (h : Basis Î¹ K V) : FiniteDimensional K V ,":=
  Module.Finite.of_basis h",have : FiniteDimensional K V := FiniteDimensional.of_fintype_basis h
Mathlib/Data/Real/Archimedean.lean,Real.exists_isLUB,exists_isLUB,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases hne, hbdd with âŸ¨âŸ¨L, hLâŸ©, âŸ¨U, hUâŸ©âŸ©
  have : âˆ€ d : â„•, BddAbove { m : â„¤ | âˆƒ y âˆˆ S, (m : â„) â‰¤ y * d } := by
    cases' exists_int_gt U with k hk
    refine fun d => âŸ¨k * d, fun z h => ?_âŸ©
    rcases h with âŸ¨y, yS, hyâŸ©
    refine Int.cast_le.1 (hy.trans ?_)
    push_cast
    exact mul_le_mul_of_nonneg_right ((hU yS).trans hk.le) d.cast_nonneg
  choose f hf using fun d : â„• =>
    Int.exists_greatest_of_bdd (this d) âŸ¨âŒŠL * dâŒ‹, L, hL, Int.floor_le _âŸ©
  have hfâ‚ : âˆ€ n > 0, âˆƒ y âˆˆ S, ((f n / n : â„š) : â„) â‰¤ y := fun n n0 =>
    let âŸ¨y, yS, hyâŸ© := (hf n).1
    âŸ¨y, yS, by simpa using (div_le_iff (Nat.cast_pos.2 n0 : (_ : â„) < _)).2 hyâŸ©
  have hfâ‚‚ : âˆ€ n > 0, âˆ€ y âˆˆ S, (y - ((n : â„•) : â„)â»Â¹) < (f n / n : â„š) := by
    intro n n0 y yS
    have := (Int.sub_one_lt_floor _).trans_le (Int.cast_le.2 <| (hf n).2 _ âŸ¨y, yS, Int.floor_le _âŸ©)
    simp only [Rat.cast_div, Rat.cast_intCast, Rat.cast_natCast, gt_iff_lt]
    rwa [lt_div_iff (Nat.cast_pos.2 n0 : (_ : â„) < _), sub_mul, _root_.inv_mul_cancel]
    exact ne_of_gt (Nat.cast_pos.2 n0)
  have hg : IsCauSeq abs (fun n => f n / n : â„• â†’ â„š) := by
    intro Îµ Îµ0
    suffices âˆ€ j â‰¥ âŒˆÎµâ»Â¹âŒ‰â‚Š, âˆ€ k â‰¥ âŒˆÎµâ»Â¹âŒ‰â‚Š, (f j / j - f k / k : â„š) < Îµ by
      refine âŸ¨_, fun j ij => abs_lt.2 âŸ¨?_, this _ ij _ le_rflâŸ©âŸ©
      rw [neg_lt, neg_sub]
      exact this _ le_rfl _ ij
    intro j ij k ik
    replace ij := le_trans (Nat.le_ceil _) (Nat.cast_le.2 ij)
    replace ik := le_trans (Nat.le_ceil _) (Nat.cast_le.2 ik)
    have j0 := Nat.cast_pos.1 ((inv_pos.2 Îµ0).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 Îµ0).trans_le ik)
    rcases hfâ‚ _ j0 with âŸ¨y, yS, hyâŸ©
    refine lt_of_lt_of_le ((@Rat.cast_lt â„ _ _ _).1 ?_) ((inv_le Îµ0 (Nat.cast_pos.2 k0)).1 ik)
    simpa using sub_lt_iff_lt_add'.2 (lt_of_le_of_lt hy <| sub_lt_iff_lt_add.1 <| hfâ‚‚ _ k0 _ yS)
  let g : CauSeq â„š abs := âŸ¨fun n => f n / n, hgâŸ©
  refine âŸ¨mk g, âŸ¨fun x xS => ?_, fun y h => ?_âŸ©âŸ©
  Â· refine le_of_forall_ge_of_dense fun z xz => ?_
    cases' exists_nat_gt (x - z)â»Â¹ with K hK
    refine le_mk_of_forall_le âŸ¨K, fun n nK => ?_âŸ©
    replace xz := sub_pos.2 xz
    replace hK := hK.le.trans (Nat.cast_le.2 nK)
    have n0 : 0 < n := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le hK)
    refine le_trans ?_ (hfâ‚‚ _ n0 _ xS).le
    rwa [le_sub_comm, inv_le (Nat.cast_pos.2 n0 : (_ : â„) < _) xz]
  Â· exact
      mk_le_of_forall_le
        âŸ¨1, fun n n1 =>
          let âŸ¨x, xS, hxâŸ© := hfâ‚ _ n1
          le_trans hx (h xS)âŸ©","error:  application type mismatch
  @Rat.cast_lt â„
argument
  â„
has type
  Type : Type 1
but is expected to have type
  â„š : Type
error:  no goals to be solved","theorem exists_isLUB {S : Set â„} (hne : S.Nonempty) (hbdd : BddAbove S) : âˆƒ x, IsLUB S x ",":= by
  rcases hne, hbdd with âŸ¨âŸ¨L, hLâŸ©, âŸ¨U, hUâŸ©âŸ©
  have : âˆ€ d : â„•, BddAbove { m : â„¤ | âˆƒ y âˆˆ S, (m : â„) â‰¤ y * d } := by
    cases' exists_int_gt U with k hk
    refine fun d => âŸ¨k * d, fun z h => ?_âŸ©
    rcases h with âŸ¨y, yS, hyâŸ©
    refine Int.cast_le.1 (hy.trans ?_)
    push_cast
    exact mul_le_mul_of_nonneg_right ((hU yS).trans hk.le) d.cast_nonneg
  choose f hf using fun d : â„• =>
    Int.exists_greatest_of_bdd (this d) âŸ¨âŒŠL * dâŒ‹, L, hL, Int.floor_le _âŸ©
  have hfâ‚ : âˆ€ n > 0, âˆƒ y âˆˆ S, ((f n / n : â„š) : â„) â‰¤ y := fun n n0 =>
    let âŸ¨y, yS, hyâŸ© := (hf n).1
    âŸ¨y, yS, by simpa using (div_le_iff (Nat.cast_pos.2 n0 : (_ : â„) < _)).2 hyâŸ©
  have hfâ‚‚ : âˆ€ n > 0, âˆ€ y âˆˆ S, (y - ((n : â„•) : â„)â»Â¹) < (f n / n : â„š) := by
    intro n n0 y yS
    have := (Int.sub_one_lt_floor _).trans_le (Int.cast_le.2 <| (hf n).2 _ âŸ¨y, yS, Int.floor_le _âŸ©)
    simp only [Rat.cast_div, Rat.cast_intCast, Rat.cast_natCast, gt_iff_lt]
    rwa [lt_div_iff (Nat.cast_pos.2 n0 : (_ : â„) < _), sub_mul, _root_.inv_mul_cancel]
    exact ne_of_gt (Nat.cast_pos.2 n0)
  have hg : IsCauSeq abs (fun n => f n / n : â„• â†’ â„š) := by
    intro Îµ Îµ0
    suffices âˆ€ j â‰¥ âŒˆÎµâ»Â¹âŒ‰â‚Š, âˆ€ k â‰¥ âŒˆÎµâ»Â¹âŒ‰â‚Š, (f j / j - f k / k : â„š) < Îµ by
      refine âŸ¨_, fun j ij => abs_lt.2 âŸ¨?_, this _ ij _ le_rflâŸ©âŸ©
      rw [neg_lt, neg_sub]
      exact this _ le_rfl _ ij
    intro j ij k ik
    replace ij := le_trans (Nat.le_ceil _) (Nat.cast_le.2 ij)
    replace ik := le_trans (Nat.le_ceil _) (Nat.cast_le.2 ik)
    have j0 := Nat.cast_pos.1 ((inv_pos.2 Îµ0).trans_le ij)
    have k0 := Nat.cast_pos.1 ((inv_pos.2 Îµ0).trans_le ik)
    rcases hfâ‚ _ j0 with âŸ¨y, yS, hyâŸ©
    refine lt_of_lt_of_le ((Rat.cast_lt (K := â„)).1 ?_) ((inv_le Îµ0 (Nat.cast_pos.2 k0)).1 ik)
    simpa using sub_lt_iff_lt_add'.2 (lt_of_le_of_lt hy <| sub_lt_iff_lt_add.1 <| hfâ‚‚ _ k0 _ yS)
  let g : CauSeq â„š abs := âŸ¨fun n => f n / n, hgâŸ©
  refine âŸ¨mk g, âŸ¨fun x xS => ?_, fun y h => ?_âŸ©âŸ©
  Â· refine le_of_forall_ge_of_dense fun z xz => ?_
    cases' exists_nat_gt (x - z)â»Â¹ with K hK
    refine le_mk_of_forall_le âŸ¨K, fun n nK => ?_âŸ©
    replace xz := sub_pos.2 xz
    replace hK := hK.le.trans (Nat.cast_le.2 nK)
    have n0 : 0 < n := Nat.cast_pos.1 ((inv_pos.2 xz).trans_le hK)
    refine le_trans ?_ (hfâ‚‚ _ n0 _ xS).le
    rwa [le_sub_comm, inv_le (Nat.cast_pos.2 n0 : (_ : â„) < _) xz]
  Â· exact
      mk_le_of_forall_le
        âŸ¨1, fun n n1 =>
          let âŸ¨x, xS, hxâŸ© := hfâ‚ _ n1
          le_trans hx (h xS)âŸ©","rcases hbdd with âŸ¨x, hxâŸ©"
Mathlib/Algebra/Order/Ring/Pow.lean,one_add_mul_le_pow,one_add_mul_le_pow,61ddcfa78d90f5773ac5739822ee3721851aa662,"  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 â‰¤ n * (a * a * (2 + a)) + a * a :=
      add_nonneg (mul_nonneg n.cast_nonneg (mul_nonneg Hsq H)) Hsq
    calc
      _ â‰¤ 1 + â†‘(n + 2) * a + (n * (a * a * (2 + a)) + a * a) := le_add_of_nonneg_right this
      _ = (1 + a) * (1 + a) * (1 + n * a) := by
          simp only [Nat.cast_add, add_mul, mul_add, one_mul, mul_one, â† one_add_one_eq_two,
            Nat.cast_one, add_assoc, add_right_inj]
          simp only [â† add_assoc, add_comm _ (â†‘n * a)]
          simp only [add_assoc, (n.cast_commute (_ : R)).left_comm]
          simp only [add_comm, add_left_comm]
      _ â‰¤ (1 + a) * (1 + a) * (1 + a) ^ n :=
        mul_le_mul_of_nonneg_left (one_add_mul_le_pow' Hsq Hsq' H _) Hsq'
      _ = (1 + a) ^ (n + 2) := by simp only [pow_succ, mul_assoc]","error:  unsolved goals
R : Type u_1
instâœ : OrderedSemiring R
a : R
Hsq : 0 â‰¤ a * a
Hsq' : 0 â‰¤ (1 + a) * (1 + a)
H : 0 â‰¤ 2 + a
n : â„•
this : 0 â‰¤ â†‘n * (a * a * (2 + a)) + a * a
âŠ¢ (1 + a) * ((1 + a) * (1 + a) ^ n) = (1 + a) ^ n * ((1 + a) * (1 + a))","lemma one_add_mul_le_pow' (Hsq : 0 â‰¤ a * a) (Hsq' : 0 â‰¤ (1 + a) * (1 + a)) (H : 0 â‰¤ 2 + a) :
    âˆ€ n : â„•, 1 + n * a â‰¤ (1 + a) ^ n
","  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 â‰¤ n * (a * a * (2 + a)) + a * a :=
      add_nonneg (mul_nonneg n.cast_nonneg (mul_nonneg Hsq H)) Hsq
    calc
      _ â‰¤ 1 + â†‘(n + 2) * a + (n * (a * a * (2 + a)) + a * a) := le_add_of_nonneg_right this
      _ = (1 + a) * (1 + a) * (1 + n * a) := by
          simp only [Nat.cast_add, add_mul, mul_add, one_mul, mul_one, â† one_add_one_eq_two,
            Nat.cast_one, add_assoc, add_right_inj]
          simp only [â† add_assoc, add_comm _ (â†‘n * a)]
          simp only [add_assoc, (n.cast_commute (_ : R)).left_comm]
          simp only [add_comm, add_left_comm]
      _ â‰¤ (1 + a) * (1 + a) * (1 + a) ^ n :=
        mul_le_mul_of_nonneg_left (one_add_mul_le_pow' Hsq Hsq' H _) Hsq'
      _ = (1 + a) ^ (n + 2) := by simp only [pow_succ', mul_assoc]",apply le_of_lt
Mathlib/Data/Complex/Basic.lean,Complex.div_ofNat_im,div_ofNat_im,9b243ae831d11cebac23a7a95ad1c107722bb200,:= div_nat_cast_im z n,"warning:  Complex does not have a doc string
warning:  Set.reProdIm does not have a doc string
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
error:  unknown identifier 'div_nat_cast_im'","lemma div_ofNat_im (z : â„‚) (n : â„•) [n.AtLeastTwo] :
    (z / no_index (OfNat.ofNat n)).im = z.im / OfNat.ofNat n ",:= div_natCast_im z n,simp [no_index_ne_zero]
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,affineSpan_le_toAffineSubspace_span,affineSpan_le_toAffineSubspace_span,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  intro x hx
  show x âˆˆ Submodule.span k s
  induction hx using affineSpan_induction' with
  | Hs x hx => exact Submodule.subset_span hx
  | Hc c u _ v _ w _ hu hv hw =>
    simp only [vsub_eq_sub, vadd_eq_add]
    apply Submodule.add_mem _ _ hw
    exact Submodule.smul_mem _ _ (Submodule.sub_mem _ hu hv)","error:  invalid alternative name 'Hs'
warning:  @AffineSubspace.Parallel does not have a doc string","lemma affineSpan_le_toAffineSubspace_span {s : Set V} :
    affineSpan k s â‰¤ (Submodule.span k s).toAffineSubspace ",":= by
  intro x hx
  show x âˆˆ Submodule.span k s
  induction hx using affineSpan_induction' with
  | mem x hx => exact Submodule.subset_span hx
  | smul_vsub_vadd c u _ v _ w _ hu hv hw =>
    simp only [vsub_eq_sub, vadd_eq_add]
    apply Submodule.add_mem _ _ hw
    exact Submodule.smul_mem _ _ (Submodule.sub_mem _ hu hv)",rw [AffineSubspace.le_toAffineSubspace_iff]
Mathlib/Topology/AlexandrovDiscrete.lean,isClopen_iUnion,isClopen_iUnion,13444d800e71a22689e60023576255503756cd93,:=,error:  unexpected token 'lemma'; expected term,"lemma isClopen_iUnion (hf : âˆ€ i, IsClopen (f i)) : IsClopen (â‹ƒ i, f i) ",":=
  âŸ¨isClosed_iUnion fun i â†¦ (hf i).1, isOpen_iUnion fun i â†¦ (hf i).2âŸ©",refine isClopen_iUnion_of_isClopen isClopen_iUnion (fun i â†¦ f i) ?_
Mathlib/Analysis/NormedSpace/RieszLemma.lean,riesz_lemma,riesz_lemma,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  classical
    obtain âŸ¨x, hxâŸ© : âˆƒ x : E, x âˆ‰ F := hF
    let d := Metric.infDist x F
    have hFn : (F : Set E).Nonempty := âŸ¨_, F.zero_memâŸ©
    have hdp : 0 < d :=
      lt_of_le_of_ne Metric.infDist_nonneg fun heq =>
        hx ((hFc.mem_iff_infDist_zero hFn).2 heq.symm)
    let r' := max r 2â»Â¹
    have hr' : r' < 1 := by
      simp [hr]
      norm_num
    have hlt : 0 < r' := lt_of_lt_of_le (by norm_num) (le_max_right r 2â»Â¹)
    have hdlt : d < d / r' := (lt_div_iff hlt).mpr ((mul_lt_iff_lt_one_right hdp).2 hr')
    obtain âŸ¨yâ‚€, hyâ‚€F, hxyâ‚€âŸ© : âˆƒ y âˆˆ F, dist x y < d / r' := (Metric.infDist_lt_iff hFn).mp hdlt
    have x_ne_yâ‚€ : x - yâ‚€ âˆ‰ F := by
      by_contra h
      have : x - yâ‚€ + yâ‚€ âˆˆ F := F.add_mem h hyâ‚€F
      simp only [neg_add_cancel_right, sub_eq_add_neg] at this
      exact hx this
    refine' âŸ¨x - yâ‚€, x_ne_yâ‚€, fun y hy => le_of_lt _âŸ©
    have hyâ‚€y : yâ‚€ + y âˆˆ F := F.add_mem hyâ‚€F hy
    calc
      r * â€–x - yâ‚€â€– â‰¤ r' * â€–x - yâ‚€â€– := by gcongr; apply le_max_left
      _ < d := by
        rw [â† dist_eq_norm]
        exact (lt_div_iff' hlt).1 hxyâ‚€
      _ â‰¤ dist x (yâ‚€ + y) := (Metric.infDist_le_dist_of_mem hyâ‚€y)
      _ = â€–x - yâ‚€ - yâ€– := by rw [sub_sub, dist_eq_norm]",error:  simp made no progress,"theorem riesz_lemma {F : Subspace ğ•œ E} (hFc : IsClosed (F : Set E)) (hF : âˆƒ x : E, x âˆ‰ F) {r : â„}
    (hr : r < 1) : âˆƒ xâ‚€ : E, xâ‚€ âˆ‰ F âˆ§ âˆ€ y âˆˆ F, r * â€–xâ‚€â€– â‰¤ â€–xâ‚€ - yâ€– ",":= by
  classical
    obtain âŸ¨x, hxâŸ© : âˆƒ x : E, x âˆ‰ F := hF
    let d := Metric.infDist x F
    have hFn : (F : Set E).Nonempty := âŸ¨_, F.zero_memâŸ©
    have hdp : 0 < d :=
      lt_of_le_of_ne Metric.infDist_nonneg fun heq =>
        hx ((hFc.mem_iff_infDist_zero hFn).2 heq.symm)
    let r' := max r 2â»Â¹
    have hr' : r' < 1 := by
      simp only [r', ge_iff_le, max_lt_iff, hr, true_and]
      norm_num
    have hlt : 0 < r' := lt_of_lt_of_le (by norm_num) (le_max_right r 2â»Â¹)
    have hdlt : d < d / r' := (lt_div_iff hlt).mpr ((mul_lt_iff_lt_one_right hdp).2 hr')
    obtain âŸ¨yâ‚€, hyâ‚€F, hxyâ‚€âŸ© : âˆƒ y âˆˆ F, dist x y < d / r' := (Metric.infDist_lt_iff hFn).mp hdlt
    have x_ne_yâ‚€ : x - yâ‚€ âˆ‰ F := by
      by_contra h
      have : x - yâ‚€ + yâ‚€ âˆˆ F := F.add_mem h hyâ‚€F
      simp only [neg_add_cancel_right, sub_eq_add_neg] at this
      exact hx this
    refine âŸ¨x - yâ‚€, x_ne_yâ‚€, fun y hy => le_of_lt ?_âŸ©
    have hyâ‚€y : yâ‚€ + y âˆˆ F := F.add_mem hyâ‚€F hy
    calc
      r * â€–x - yâ‚€â€– â‰¤ r' * â€–x - yâ‚€â€– := by gcongr; apply le_max_left
      _ < d := by
        rw [â† dist_eq_norm]
        exact (lt_div_iff' hlt).1 hxyâ‚€
      _ â‰¤ dist x (yâ‚€ + y) := Metric.infDist_le_dist_of_mem hyâ‚€y
      _ = â€–x - yâ‚€ - yâ€– := by rw [sub_sub, dist_eq_norm]","rcases hF with âŸ¨xâ‚€, hxâ‚€âŸ©"
Mathlib/Analysis/Complex/RealDeriv.lean,HasDerivAt.real_of_complex,HasDerivAt.real_of_complex,01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  have A : HasFDerivAt ((â†‘) : â„ â†’ â„‚) ofRealClm z := ofRealClm.hasFDerivAt
  have B :
    HasFDerivAt e ((ContinuousLinearMap.smulRight 1 e' : â„‚ â†’L[â„‚] â„‚).restrictScalars â„)
      (ofRealClm z) :=
    h.hasFDerivAt.restrictScalars â„
  have C : HasFDerivAt re reClm (e (ofRealClm z)) := reClm.hasFDerivAt
  convert (C.comp z (B.comp z A)).hasDerivAt
  rw [ContinuousLinearMap.comp_apply, ContinuousLinearMap.comp_apply]
  simp","error:  unknown identifier 'ofRealClm'
error:  unknown identifier 'ofRealClm.hasFDerivAt'
error:  unsolved goals
e : â„‚ â†’ â„‚
e' : â„‚
z : â„
h : HasDerivAt e e' â†‘z
âŠ¢ HasDerivAt (fun x â†¦ (e â†‘x).re) e'.re z","theorem HasDerivAt.real_of_complex (h : HasDerivAt e e' z) :
    HasDerivAt (fun x : â„ => (e x).re) e'.re z ",":= by
  have A : HasFDerivAt ((â†‘) : â„ â†’ â„‚) ofRealCLM z := ofRealCLM.hasFDerivAt
  have B :
    HasFDerivAt e ((ContinuousLinearMap.smulRight 1 e' : â„‚ â†’L[â„‚] â„‚).restrictScalars â„)
      (ofRealCLM z) :=
    h.hasFDerivAt.restrictScalars â„
  have C : HasFDerivAt re reCLM (e (ofRealCLM z)) := reCLM.hasFDerivAt
  convert (C.comp z (B.comp z A)).hasDerivAt
  rw [ContinuousLinearMap.comp_apply, ContinuousLinearMap.comp_apply]
  simp","simp only [hasDerivAt_iff_hasFDerivAt, hasDerivAt_iff_hasFDerivAt] at h"
Mathlib/NumberTheory/Bertrand.lean,Nat.exists_prime_lt_and_le_two_mul_succ,exists_prime_lt_and_le_two_mul_succ,693fd79515903b10b1d31f10dccfc49e633cf7ee,":= by
  by_cases p â‰¤ 2 * n; Â· exact âŸ¨p, prime_p, hn, hâŸ©
  exact H (lt_of_mul_lt_mul_left' (lt_of_lt_of_le (not_le.1 h) covering))","error:  unknown identifier 'h'
error:  unknown identifier 'h'","theorem exists_prime_lt_and_le_two_mul_succ {n} (q) {p : â„•} (prime_p : Nat.Prime p)
    (covering : p â‰¤ 2 * q) (H : n < q â†’ âˆƒ p : â„•, p.Prime âˆ§ n < p âˆ§ p â‰¤ 2 * n) (hn : n < p) :
    âˆƒ p : â„•, p.Prime âˆ§ n < p âˆ§ p â‰¤ 2 * n ",":= by
  by_cases h : p â‰¤ 2 * n; Â· exact âŸ¨p, prime_p, hn, hâŸ©
  exact H (lt_of_mul_lt_mul_left' (lt_of_lt_of_le (not_le.1 h) covering))","rcases exists_prime_lt_and_le_two_mul_succ n prime_p H with âŸ¨p', p'_p', p'_prime, hn, hp'âŸ©"
Mathlib/Analysis/Convex/Measure.lean,Convex.addHaar_frontier,addHaar_frontier,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  cases' ne_or_eq (affineSpan â„ s) âŠ¤ with hspan hspan
  Â· refine measure_mono_null ?_ (addHaar_affineSubspace _ _ hspan)
    exact frontier_subset_closure.trans
      (closure_minimal (subset_affineSpan _ _) (affineSpan â„ s).closed_of_finiteDimensional)
  rw [â† hs.interior_nonempty_iff_affineSpan_eq_top] at hspan
  rcases hspan with âŸ¨x, hxâŸ©
  suffices H : âˆ€ t : Set E, Convex â„ t â†’ x âˆˆ interior t â†’ IsBounded t â†’ Î¼ (frontier t) = 0 by
    let B : â„• â†’ Set E := fun n => ball x (n + 1)
    have : Î¼ (â‹ƒ n : â„•, frontier (s âˆ© B n)) = 0 := by
      refine measure_iUnion_null fun n =>
        H _ (hs.inter (convex_ball _ _)) ?_ (isBounded_ball.subset (inter_subset_right _ _))
      rw [interior_inter, isOpen_ball.interior_eq]
      exact âŸ¨hx, mem_ball_self (add_pos_of_nonneg_of_pos n.cast_nonneg zero_lt_one)âŸ©
    refine measure_mono_null (fun y hy => ?_) this; clear this
    set N : â„• := âŒŠdist y xâŒ‹â‚Š
    refine mem_iUnion.2 âŸ¨N, ?_âŸ©
    have hN : y âˆˆ B N := by simp [B, N, Nat.lt_floor_add_one]
    suffices y âˆˆ frontier (s âˆ© B N) âˆ© B N from this.1
    rw [frontier_inter_open_inter isOpen_ball]
    exact âŸ¨hy, hNâŸ©
  intro s hs hx hb
  replace hb : Î¼ (interior s) â‰  âˆ := (hb.subset interior_subset).measure_lt_top.ne
  suffices Î¼ (closure s) â‰¤ Î¼ (interior s) by
    rwa [frontier, measure_diff interior_subset_closure isOpen_interior.measurableSet hb,
      tsub_eq_zero_iff_le]
  set d : â„• := FiniteDimensional.finrank â„ E
  have : âˆ€ r : â„â‰¥0, 1 < r â†’ Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) := fun r hr â†¦ by
    refine (measure_mono <|
      hs.closure_subset_image_homothety_interior_of_one_lt hx r hr).trans_eq ?_
    rw [addHaar_image_homothety, â† NNReal.coe_pow, NNReal.abs_eq, ENNReal.ofReal_coe_nnreal]
  have : âˆ€á¶  (r : â„â‰¥0) in ğ“[>] 1, Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) :=
    mem_of_superset self_mem_nhdsWithin this
  refine ge_of_tendsto ?_ this
  refine (((ENNReal.continuous_mul_const hb).comp
    (ENNReal.continuous_coe.comp (continuous_pow d))).tendsto' _ _ ?_).mono_left nhdsWithin_le_nhds
  simp","error:  function expected at
  inter_subset_right ?m.13269
term has type
  ?m.13268 âˆˆ ?m.13267",theorem addHaar_frontier (hs : Convex â„ s) : Î¼ (frontier s) = 0 ,":= by
  cases' ne_or_eq (affineSpan â„ s) âŠ¤ with hspan hspan
  Â· refine measure_mono_null ?_ (addHaar_affineSubspace _ _ hspan)
    exact frontier_subset_closure.trans
      (closure_minimal (subset_affineSpan _ _) (affineSpan â„ s).closed_of_finiteDimensional)
  rw [â† hs.interior_nonempty_iff_affineSpan_eq_top] at hspan
  rcases hspan with âŸ¨x, hxâŸ©
  suffices H : âˆ€ t : Set E, Convex â„ t â†’ x âˆˆ interior t â†’ IsBounded t â†’ Î¼ (frontier t) = 0 by
    let B : â„• â†’ Set E := fun n => ball x (n + 1)
    have : Î¼ (â‹ƒ n : â„•, frontier (s âˆ© B n)) = 0 := by
      refine measure_iUnion_null fun n =>
        H _ (hs.inter (convex_ball _ _)) ?_ (isBounded_ball.subset inter_subset_right)
      rw [interior_inter, isOpen_ball.interior_eq]
      exact âŸ¨hx, mem_ball_self (add_pos_of_nonneg_of_pos n.cast_nonneg zero_lt_one)âŸ©
    refine measure_mono_null (fun y hy => ?_) this; clear this
    set N : â„• := âŒŠdist y xâŒ‹â‚Š
    refine mem_iUnion.2 âŸ¨N, ?_âŸ©
    have hN : y âˆˆ B N := by simp [B, N, Nat.lt_floor_add_one]
    suffices y âˆˆ frontier (s âˆ© B N) âˆ© B N from this.1
    rw [frontier_inter_open_inter isOpen_ball]
    exact âŸ¨hy, hNâŸ©
  intro s hs hx hb
  replace hb : Î¼ (interior s) â‰  âˆ := (hb.subset interior_subset).measure_lt_top.ne
  suffices Î¼ (closure s) â‰¤ Î¼ (interior s) by
    rwa [frontier, measure_diff interior_subset_closure isOpen_interior.measurableSet hb,
      tsub_eq_zero_iff_le]
  set d : â„• := FiniteDimensional.finrank â„ E
  have : âˆ€ r : â„â‰¥0, 1 < r â†’ Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) := fun r hr â†¦ by
    refine (measure_mono <|
      hs.closure_subset_image_homothety_interior_of_one_lt hx r hr).trans_eq ?_
    rw [addHaar_image_homothety, â† NNReal.coe_pow, NNReal.abs_eq, ENNReal.ofReal_coe_nnreal]
  have : âˆ€á¶  (r : â„â‰¥0) in ğ“[>] 1, Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) :=
    mem_of_superset self_mem_nhdsWithin this
  refine ge_of_tendsto ?_ this
  refine (((ENNReal.continuous_mul_const hb).comp
    (ENNReal.continuous_coe.comp (continuous_pow d))).tendsto' _ _ ?_).mono_left nhdsWithin_le_nhds
  simp",refine addHaar_frontier_eq_zero_of_addHaar_frontier_frontier hs addHaar_frontier hs ?_
Mathlib/CategoryTheory/Sites/Sheaf.lean,CategoryTheory.Presheaf.isSheaf_iff_multiequalizer,isSheaf_iff_multiequalizer,bfeaa186b46811aacfb5c266a1e6b12a55ab2920,":= by
  rw [isSheaf_iff_multifork]
  refine' forallâ‚‚_congr fun X S => âŸ¨_, _âŸ©
  Â· rintro âŸ¨hâŸ©
    let e : P.obj (op X) â‰… multiequalizer (S.index P) :=
      h.conePointUniqueUpToIso (limit.isLimit _)
    exact (inferInstance : IsIso e.hom)
  Â· intro h
    refine' âŸ¨IsLimit.ofIsoLimit (limit.isLimit _)
      (Iso.symm (Multifork.ext (asIso (S.toMultiequalizer P)) _))âŸ©
    intro a
    erw [limit.lift_Ï€]
    rfl","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Multifork
has type
  MulticospanIndex ?m.121891 â†’ Type (max (max ?u.121890 ?u.121888) ?u.121889)
error:  no goals to be solved","theorem isSheaf_iff_multiequalizer [âˆ€ (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)] :
    IsSheaf J P â†” âˆ€ (X : C) (S : J.Cover X), IsIso (S.toMultiequalizer P) ",":= by
  rw [isSheaf_iff_multifork]
  refine forallâ‚‚_congr fun X S => âŸ¨?_, ?_âŸ©
  Â· rintro âŸ¨hâŸ©
    let e : P.obj (op X) â‰… multiequalizer (S.index P) :=
      h.conePointUniqueUpToIso (limit.isLimit _)
    exact (inferInstance : IsIso e.hom)
  Â· intro h
    refine âŸ¨IsLimit.ofIsoLimit (limit.isLimit _) (Cones.ext ?_ ?_)âŸ©
    Â· apply (@asIso _ _ _ _ _ h).symm
    Â· intro a
      symm
      erw [IsIso.inv_comp_eq]
      dsimp
      simp","rw [isSheaf_iff_multiequalizer, isSheaf_iff_multiequalizer]"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime,cyclotomicRing_isIntegralClosure_of_prime,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  haveI : CharZero â„š := StrictOrderedSemiring.to_charZero
  have hÎ¶ := zeta_spec (p ^ k) â„š (CyclotomicField (p ^ k) â„š)
  refine âŸ¨IsFractionRing.injective _ _, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©, ?_âŸ©âŸ©
  Â· have := isIntegralClosure_adjoin_singleton_of_prime_pow hÎ¶
    obtain âŸ¨y, rflâŸ© := this.isIntegral_iff.1 h
    refine adjoin_mono ?_ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hÎ¶.pow_eq_one
  Â· rintro âŸ¨y, rflâŸ©
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} â„¤ _) _)","error:  unknown constant 'StrictOrderedSemiring.to_charZero'
error:  function expected at
  integral {p ^ k} â„¤ ?m.69712
term has type
  Algebra.IsIntegral â„¤ ?m.69712","theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) â„¤ â„š) â„¤ (CyclotomicField (p ^ k) â„š) ",":= by
  have hÎ¶ := zeta_spec (p ^ k) â„š (CyclotomicField (p ^ k) â„š)
  refine âŸ¨IsFractionRing.injective _ _, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©, ?_âŸ©âŸ©
  Â· have := isIntegralClosure_adjoin_singleton_of_prime_pow hÎ¶
    obtain âŸ¨y, rflâŸ© := this.isIntegral_iff.1 h
    refine adjoin_mono ?_ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hÎ¶.pow_eq_one
  Â· rintro âŸ¨y, rflâŸ©
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} â„¤ _).isIntegral _)","refine IsIntegralClosure.cyclotomicRing_isIntegralClosure_of_prime_pow cyclotomicRing_isIntegralClosure_of_prime_pow
  cyclotomicRing_isIntegralClosure_of_prime_pow cyclotomicRing_isIntegralClosure_of_prime_pow cyclotomicRing_isIntegralClosure_of_prime_pow"
Mathlib/LinearAlgebra/LinearIndependent.lean,linearIndependent_sum,linearIndependent_sum,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  classical
  rw [range_comp v, range_comp v]
  refine' âŸ¨_, _âŸ©
  Â· intro h
    refine' âŸ¨h.comp _ Sum.inl_injective, h.comp _ Sum.inr_injective, _âŸ©
    refine' h.disjoint_span_image _
    exact IsCompl.disjoint isCompl_range_inl_range_inr
  rintro âŸ¨hl, hr, hlrâŸ©
  rw [linearIndependent_iff'] at *
  intro s g hg i hi
  have :
    ((âˆ‘ i in s.preimage Sum.inl (Sum.inl_injective.injOn _), (fun x => g x â€¢ v x) (Sum.inl i)) +
        âˆ‘ i in s.preimage Sum.inr (Sum.inr_injective.injOn _), (fun x => g x â€¢ v x) (Sum.inr i)) =
      0 := by
    rw [Finset.sum_preimage' (g := fun x => g x â€¢ v x),
      Finset.sum_preimage' (g := fun x => g x â€¢ v x), â† Finset.sum_union, â† Finset.filter_or]
    Â· simpa only [â† mem_union, range_inl_union_range_inr, mem_univ, Finset.filter_True]
    Â· 
      refine Finset.disjoint_filter.2 fun x _ hx =>
        disjoint_left.1 ?_ hx
      exact IsCompl.disjoint isCompl_range_inl_range_inr
  Â· rw [â† eq_neg_iff_add_eq_zero] at this
    rw [disjoint_def'] at hlr
    have A := by
      refine hlr _ (sum_mem fun i _ => ?_) _ (neg_mem <| sum_mem fun i _ => ?_) this
      Â· exact smul_mem _ _ (subset_span âŸ¨Sum.inl i, mem_range_self _, rflâŸ©)
      Â· exact smul_mem _ _ (subset_span âŸ¨Sum.inr i, mem_range_self _, rflâŸ©)
    cases' i with i i
    Â· exact hl _ _ A i (Finset.mem_preimage.2 hi)
    Â· rw [this, neg_eq_zero] at A
      exact hr _ _ A i (Finset.mem_preimage.2 hi)","error:  application type mismatch
  s.preimage Sum.inl â‹¯
argument
  Injective.injOn Sum.inl_injective ?m.376732
has type
  âˆ€ â¦ƒxâ‚‚ : ?m.376722â¦„, xâ‚‚ âˆˆ ?m.376730 â†’ Sum.inl ?m.376731 = Sum.inl xâ‚‚ â†’ ?m.376731 = xâ‚‚ : Prop
but is expected to have type
  InjOn Sum.inl (Sum.inl â»Â¹' â†‘s) : Prop
error:  application type mismatch
  s.preimage Sum.inr â‹¯
argument
  Injective.injOn Sum.inr_injective ?m.378237
has type
  âˆ€ â¦ƒxâ‚‚ : ?m.378227â¦„, xâ‚‚ âˆˆ ?m.378235 â†’ Sum.inr ?m.378236 = Sum.inr xâ‚‚ â†’ ?m.378236 = xâ‚‚ : Prop
but is expected to have type
  InjOn Sum.inr (Sum.inr â»Â¹' â†‘s) : Prop","theorem linearIndependent_sum {v : Sum Î¹ Î¹' â†’ M} :
    LinearIndependent R v â†”
      LinearIndependent R (v âˆ˜ Sum.inl) âˆ§
        LinearIndependent R (v âˆ˜ Sum.inr) âˆ§
          Disjoint (Submodule.span R (range (v âˆ˜ Sum.inl)))
            (Submodule.span R (range (v âˆ˜ Sum.inr))) ",":= by
  classical
  rw [range_comp v, range_comp v]
  refine âŸ¨?_, ?_âŸ©
  Â· intro h
    refine âŸ¨h.comp _ Sum.inl_injective, h.comp _ Sum.inr_injective, ?_âŸ©
    refine h.disjoint_span_image ?_
    exact IsCompl.disjoint isCompl_range_inl_range_inr
  rintro âŸ¨hl, hr, hlrâŸ©
  rw [linearIndependent_iff'] at *
  intro s g hg i hi
  have :
    ((âˆ‘ i âˆˆ s.preimage Sum.inl Sum.inl_injective.injOn, (fun x => g x â€¢ v x) (Sum.inl i)) +
        âˆ‘ i âˆˆ s.preimage Sum.inr Sum.inr_injective.injOn, (fun x => g x â€¢ v x) (Sum.inr i)) =
      0 := by
    rw [Finset.sum_preimage' (g := fun x => g x â€¢ v x),
      Finset.sum_preimage' (g := fun x => g x â€¢ v x), â† Finset.sum_union, â† Finset.filter_or]
    Â· simpa only [â† mem_union, range_inl_union_range_inr, mem_univ, Finset.filter_True]
    Â· 
      refine Finset.disjoint_filter.2 fun x _ hx =>
        disjoint_left.1 ?_ hx
      exact IsCompl.disjoint isCompl_range_inl_range_inr
  rw [â† eq_neg_iff_add_eq_zero] at this
  rw [disjoint_def'] at hlr
  have A := by
    refine hlr _ (sum_mem fun i _ => ?_) _ (neg_mem <| sum_mem fun i _ => ?_) this
    Â· exact smul_mem _ _ (subset_span âŸ¨Sum.inl i, mem_range_self _, rflâŸ©)
    Â· exact smul_mem _ _ (subset_span âŸ¨Sum.inr i, mem_range_self _, rflâŸ©)
  cases' i with i i
  Â· exact hl _ _ A i (Finset.mem_preimage.2 hi)
  Â· rw [this, neg_eq_zero] at A
    exact hr _ _ A i (Finset.mem_preimage.2 hi)","rw [linearIndependent_sum_linearIndependent_sum, linearIndependent_sum_linearIndependent_sum]"
Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean,TopCat.isTopologicalBasis_cofiltered_limit,isTopologicalBasis_cofiltered_limit,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  classical
  let D := limitConeInfi F
  let E : C.pt â‰… D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | âˆƒ (j : _) (V : Set (F.obj j)), V âˆˆ T j âˆ§ U = D.Ï€.app j â»Â¹' V} by
    convert this.inducing hE
    ext U0
    constructor
    Â· rintro âŸ¨j, V, hV, rflâŸ©
      refine' âŸ¨D.Ï€.app j â»Â¹' V, âŸ¨j, V, hV, rflâŸ©, rflâŸ©
    Â· rintro âŸ¨W, âŸ¨j, V, hV, rflâŸ©, rflâŸ©
      refine' âŸ¨j, V, hV, rflâŸ©
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.Ï€.app j x using 1
  ext U0
  constructor
  Â· rintro âŸ¨j, V, hV, rflâŸ©
    let U : âˆ€ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine' âŸ¨U, {j}, _, _âŸ©
    Â· rintro i h
      rw [Finset.mem_singleton] at h
      dsimp
      rw [dif_pos h]
      subst h
      exact hV
    Â· dsimp
      simp
  Â· rintro âŸ¨U, G, h1, h2âŸ©
    obtain âŸ¨j, hjâŸ© := IsCofiltered.inf_objs_exists G
    let g : âˆ€ (e) (_he : e âˆˆ G), j âŸ¶ e := fun _ he => (hj he).some
    let Vs : J â†’ Set (F.obj j) := fun e => if h : e âˆˆ G then F.map (g e h) â»Â¹' U e else Set.univ
    let V : Set (F.obj j) := â‹‚ (e : J) (_he : e âˆˆ G), Vs e
    refine' âŸ¨j, V, _, _âŸ©
    Â· 
      have :
        âˆ€ (S : Set (Set (F.obj j))) (E : Finset J) (P : J â†’ Set (F.obj j)) (_univ : Set.univ âˆˆ S)
          (_inter : âˆ€ A B : Set (F.obj j), A âˆˆ S â†’ B âˆˆ S â†’ A âˆ© B âˆˆ S)
          (_cond : âˆ€ (e : J) (_he : e âˆˆ E), P e âˆˆ S), (â‹‚ (e) (_he : e âˆˆ E), P e) âˆˆ S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine' hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 _)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine' this _ _ _ (univ _) (inter _) _
      intro e he
      dsimp
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    Â· 
      rw [h2]
      change _ = (D.Ï€.app j)â»Â¹' â‹‚ (e : J) (_ : e âˆˆ G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.Ï€.app e)â»Â¹' U e =
        (D.Ï€.app j) â»Â¹' if h : e âˆˆ G then F.map (g e h) â»Â¹' U e else Set.univ
      rw [dif_pos he, â† Set.preimage_comp]
      apply congrFun
      apply congrArg
      rw [â†coe_comp, D.w]
      rfl","error:  unknown identifier 'isTopologicalBasis_iInf'
error:  no goals to be solved","theorem isTopologicalBasis_cofiltered_limit (T : âˆ€ j, Set (Set (F.obj j)))
    (hT : âˆ€ j, IsTopologicalBasis (T j)) (univ : âˆ€ i : J, Set.univ âˆˆ T i)
    (inter : âˆ€ (i) (U1 U2 : Set (F.obj i)), U1 âˆˆ T i â†’ U2 âˆˆ T i â†’ U1 âˆ© U2 âˆˆ T i)
    (compat : âˆ€ (i j : J) (f : i âŸ¶ j) (V : Set (F.obj j)) (_hV : V âˆˆ T j), F.map f â»Â¹' V âˆˆ T i) :
    IsTopologicalBasis
      {U : Set C.pt | âˆƒ (j : _) (V : Set (F.obj j)), V âˆˆ T j âˆ§ U = C.Ï€.app j â»Â¹' V} ",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt â‰… D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | âˆƒ (j : _) (V : Set (F.obj j)), V âˆˆ T j âˆ§ U = D.Ï€.app j â»Â¹' V} by
    convert this.inducing hE
    ext U0
    constructor
    Â· rintro âŸ¨j, V, hV, rflâŸ©
      exact âŸ¨D.Ï€.app j â»Â¹' V, âŸ¨j, V, hV, rflâŸ©, rflâŸ©
    Â· rintro âŸ¨W, âŸ¨j, V, hV, rflâŸ©, rflâŸ©
      exact âŸ¨j, V, hV, rflâŸ©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.Ï€.app j x using 1
  ext U0
  constructor
  Â· rintro âŸ¨j, V, hV, rflâŸ©
    let U : âˆ€ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine âŸ¨U, {j}, ?_, ?_âŸ©
    Â· simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    Â· simp [U]
  Â· rintro âŸ¨U, G, h1, h2âŸ©
    obtain âŸ¨j, hjâŸ© := IsCofiltered.inf_objs_exists G
    let g : âˆ€ e âˆˆ G, j âŸ¶ e := fun _ he => (hj he).some
    let Vs : J â†’ Set (F.obj j) := fun e => if h : e âˆˆ G then F.map (g e h) â»Â¹' U e else Set.univ
    let V : Set (F.obj j) := â‹‚ (e : J) (_he : e âˆˆ G), Vs e
    refine âŸ¨j, V, ?_, ?_âŸ©
    Â· 
      have :
        âˆ€ (S : Set (Set (F.obj j))) (E : Finset J) (P : J â†’ Set (F.obj j)) (_univ : Set.univ âˆˆ S)
          (_inter : âˆ€ A B : Set (F.obj j), A âˆˆ S â†’ B âˆˆ S â†’ A âˆ© B âˆˆ S)
          (_cond : âˆ€ (e : J) (_he : e âˆˆ E), P e âˆˆ S), (â‹‚ (e) (_he : e âˆˆ E), P e) âˆˆ S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    Â· 
      rw [h2]
      change _ = (D.Ï€.app j)â»Â¹' â‹‚ (e : J) (_ : e âˆˆ G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.Ï€.app e)â»Â¹' U e =
        (D.Ï€.app j) â»Â¹' if h : e âˆˆ G then F.map (g e h) â»Â¹' U e else Set.univ
      rw [dif_pos he, â† Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [â† coe_comp, D.w] 
      rfl",refine theorem_isTopologicalBasis_isTopologicalBasis_cofiltered_limit _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ?_
Mathlib/Analysis/Calculus/MeanValue.lean,image_le_of_liminf_slope_right_lt_deriv_boundary',image_le_of_liminf_slope_right_lt_deriv_boundary',2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  change Icc a b âŠ† { x | f x â‰¤ B x }
  set s := { x | f x â‰¤ B x } âˆ© Icc a b
  have A : ContinuousOn (fun x => (f x, B x)) (Icc a b) := hf.prod hB
  have : IsClosed s := by
    simp only [inter_comm]
    exact A.preimage_closed_of_closed isClosed_Icc OrderClosedTopology.isClosed_le'
  apply this.Icc_subset_of_forall_exists_gt ha
  rintro x âŸ¨hxB : f x â‰¤ B x, xabâŸ© y hy
  cases' hxB.lt_or_eq with hxB hxB
  Â· 
    refine' nonempty_of_mem (inter_mem _ (Ioc_mem_nhdsWithin_Ioi âŸ¨le_rfl, hyâŸ©))
    have : âˆ€á¶  x in ğ“[Icc a b] x, f x < B x :=
      A x (Ico_subset_Icc_self xab) (IsOpen.mem_nhds (isOpen_lt continuous_fst continuous_snd) hxB)
    have : âˆ€á¶  x in ğ“[>] x, f x < B x := nhdsWithin_le_of_mem (Icc_mem_nhdsWithin_Ioi xab) this
    exact this.mono fun y => le_of_lt
  Â· rcases exists_between (bound x xab hxB) with âŸ¨r, hfr, hrBâŸ©
    specialize hf' x xab r hfr
    have HB : âˆ€á¶  z in ğ“[>] x, r < slope B x z :=
      (hasDerivWithinAt_iff_tendsto_slope' <| lt_irrefl x).1 (hB' x xab).Ioi_of_Ici
        (Ioi_mem_nhds hrB)
    obtain âŸ¨z, hfz, hzB, hzâŸ© : âˆƒ z, slope f x z < r âˆ§ r < slope B x z âˆ§ z âˆˆ Ioc x y
    exact (hf'.and_eventually (HB.and (Ioc_mem_nhdsWithin_Ioi âŸ¨le_rfl, hyâŸ©))).exists
    refine' âŸ¨z, _, hzâŸ©
    have := (hfz.trans hzB).le
    rwa [slope_def_field, slope_def_field, div_le_div_right (sub_pos.2 hz.1), hxB,
      sub_le_sub_iff_right] at this",error:  simp made no progress,"theorem image_le_of_liminf_slope_right_lt_deriv_boundary' {f f' : â„ â†’ â„} {a b : â„}
    (hf : ContinuousOn f (Icc a b))
    (hf' : âˆ€ x âˆˆ Ico a b, âˆ€ r, f' x < r â†’ âˆƒá¶  z in ğ“[>] x, slope f x z < r)
    {B B' : â„ â†’ â„} (ha : f a â‰¤ B a) (hB : ContinuousOn B (Icc a b))
    (hB' : âˆ€ x âˆˆ Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)
    (bound : âˆ€ x âˆˆ Ico a b, f x = B x â†’ f' x < B' x) : âˆ€ â¦ƒxâ¦„, x âˆˆ Icc a b â†’ f x â‰¤ B x ",":= by
  change Icc a b âŠ† { x | f x â‰¤ B x }
  set s := { x | f x â‰¤ B x } âˆ© Icc a b
  have A : ContinuousOn (fun x => (f x, B x)) (Icc a b) := hf.prod hB
  have : IsClosed s := by
    simp only [s, inter_comm]
    exact A.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  apply this.Icc_subset_of_forall_exists_gt ha
  rintro x âŸ¨hxB : f x â‰¤ B x, xabâŸ© y hy
  cases' hxB.lt_or_eq with hxB hxB
  Â· 
    refine nonempty_of_mem (inter_mem ?_ (Ioc_mem_nhdsWithin_Ioi âŸ¨le_rfl, hyâŸ©))
    have : âˆ€á¶  x in ğ“[Icc a b] x, f x < B x :=
      A x (Ico_subset_Icc_self xab) (IsOpen.mem_nhds (isOpen_lt continuous_fst continuous_snd) hxB)
    have : âˆ€á¶  x in ğ“[>] x, f x < B x := nhdsWithin_le_of_mem (Icc_mem_nhdsWithin_Ioi xab) this
    exact this.mono fun y => le_of_lt
  Â· rcases exists_between (bound x xab hxB) with âŸ¨r, hfr, hrBâŸ©
    specialize hf' x xab r hfr
    have HB : âˆ€á¶  z in ğ“[>] x, r < slope B x z :=
      (hasDerivWithinAt_iff_tendsto_slope' <| lt_irrefl x).1 (hB' x xab).Ioi_of_Ici
        (Ioi_mem_nhds hrB)
    obtain âŸ¨z, hfz, hzB, hzâŸ© : âˆƒ z, slope f x z < r âˆ§ r < slope B x z âˆ§ z âˆˆ Ioc x y :=
      (hf'.and_eventually (HB.and (Ioc_mem_nhdsWithin_Ioi âŸ¨le_rfl, hyâŸ©))).exists
    refine âŸ¨z, ?_, hzâŸ©
    have := (hfz.trans hzB).le
    rwa [slope_def_field, slope_def_field, div_le_div_right (sub_pos.2 hz.1), hxB,
      sub_le_sub_iff_right] at this",refine theorem_image_le_of_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slop
Mathlib/CategoryTheory/Extensive.lean,CategoryTheory.FinitaryPreExtensive.hasPullbacks_of_is_coproduct,FinitaryPreExtensive.hasPullbacks_of_is_coproduct,e2426ff5dc46051d5747537177e0e66c5dc771e7,":= by
  classical
  let f : Î¹ â†’ C := F.obj âˆ˜ Discrete.mk
  have : F = Discrete.functor f :=
    Functor.hext (fun i â†¦ rfl) (by rintro âŸ¨iâŸ© âŸ¨jâŸ© âŸ¨âŸ¨rfl : i = jâŸ©âŸ©; simp)
  clear_value f
  subst this
  change Cofan f at c
  obtain âŸ¨iâŸ© := i
  let e : âˆ f â‰… f i â¨¿ (âˆ fun j : ({i}á¶œ : Set Î¹) â†¦ f j) :=
  { hom := Sigma.desc (fun j â†¦ if h : j = i then eqToHom (congr_arg f h) â‰« coprod.inl else
      Sigma.Î¹ (fun j : ({i}á¶œ : Set Î¹) â†¦ f j) âŸ¨j, hâŸ© â‰« coprod.inr)
    inv := coprod.desc (Sigma.Î¹ f i) (Sigma.desc <| fun j â†¦ Sigma.Î¹ f j)
    hom_inv_id := by aesop_cat
    inv_hom_id := by
      ext j
      Â· simp
      Â· simp only [coprod.desc_comp, colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app,
          eqToHom_refl, Category.id_comp, dite_true, BinaryCofan.mk_pt, BinaryCofan.Î¹_app_right,
          BinaryCofan.mk_inr, colimit.Î¹_desc_assoc, Discrete.functor_obj, Category.comp_id]
        exact dif_neg j.prop }
  let e' : c.pt â‰… f i â¨¿ (âˆ fun j : ({i}á¶œ : Set Î¹) â†¦ f j) :=
    hc.coconePointUniqueUpToIso (getColimitCocone _).2 â‰ªâ‰« e
  have : coprod.inl â‰« e'.inv = c.Î¹.app âŸ¨iâŸ©
  Â· simp only [Iso.trans_inv, coprod.desc_comp, colimit.Î¹_desc, BinaryCofan.mk_pt,
      BinaryCofan.Î¹_app_left, BinaryCofan.mk_inl]
    exact colimit.comp_coconePointUniqueUpToIso_inv _ _
  clear_value e'
  rw [â† this]
  have : IsPullback (ğŸ™ _) (g â‰« e'.hom) g e'.inv := IsPullback.of_horiz_isIso âŸ¨by simpâŸ©
  exact âŸ¨âŸ¨âŸ¨_, ((IsPullback.of_hasPullback (g â‰« e'.hom) coprod.inl).paste_horiz this).isLimitâŸ©âŸ©âŸ©","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case mk.mk.up.up
J : Type v'
instâœâ´ : Category.{u', v'} J
C : Type u
instâœÂ³ : Category.{v, u} C
D : Type u''
instâœÂ² : Category.{v'', u''} D
Xâœ Y : C
instâœÂ¹ : FinitaryPreExtensive C
Î¹ : Type u_1
instâœ : Finite Î¹
F : Discrete Î¹ â¥¤ C
c : Cocone F
hc : IsColimit c
iâœ : Discrete Î¹
X : C
g : X âŸ¶ ((Functor.const (Discrete Î¹)).obj c.pt).obj iâœ
f : Î¹ â†’ C := F.obj âˆ˜ Discrete.mk
i : Î¹
âŠ¢ ğŸ™ (F.obj { as := i }) = ğŸ™ (f i)
error:  unsolved goals
case mk
J : Type v'
instâœâ´ : Category.{u', v'} J
C : Type u
instâœÂ³ : Category.{v, u} C
D : Type u''
instâœÂ² : Category.{v'', u''} D
Xâœ Y : C
instâœÂ¹ : FinitaryPreExtensive C
Î¹ : Type u_1
instâœ : Finite Î¹
X : C
f : Î¹ â†’ C
c : Cofan f
hc : IsColimit c
i : Î¹
g : X âŸ¶ ((Functor.const (Discrete Î¹)).obj c.pt).obj { as := i }
e : âˆ f â‰… f i â¨¿ âˆ fun j â†¦ f â†‘j :=
  { hom := Sigma.desc fun j â†¦ if h : j = i then eqToHom â‹¯ â‰« coprod.inl else Sigma.Î¹ (fun j â†¦ f â†‘j) âŸ¨j, hâŸ© â‰« coprod.inr,
    inv := coprod.desc (Sigma.Î¹ f i) (Sigma.desc fun j â†¦ Sigma.Î¹ f â†‘j), hom_inv_id := â‹¯, inv_hom_id := â‹¯ }
e' : c.pt â‰… f i â¨¿ âˆ fun j â†¦ f â†‘j := hc.coconePointUniqueUpToIso (getColimitCocone (Discrete.functor f)).isColimit â‰ªâ‰« e
this : coprod.inl â‰« e'.inv = c.Î¹.app { as := i }
âŠ¢ HasPullback g (c.Î¹.app { as := i })","lemma FinitaryPreExtensive.hasPullbacks_of_is_coproduct [FinitaryPreExtensive C] {Î¹ : Type*}
    [Finite Î¹] {F : Discrete Î¹ â¥¤ C} {c : Cocone F} (hc : IsColimit c) (i : Discrete Î¹) {X : C}
    (g : X âŸ¶ _) : HasPullback g (c.Î¹.app i) ",":= by
  classical
  let f : Î¹ â†’ C := F.obj âˆ˜ Discrete.mk
  have : F = Discrete.functor f :=
    Functor.hext (fun i â†¦ rfl) (by rintro âŸ¨iâŸ© âŸ¨jâŸ© âŸ¨âŸ¨rfl : i = jâŸ©âŸ©; simp [f])
  clear_value f
  subst this
  change Cofan f at c
  obtain âŸ¨iâŸ© := i
  let e : âˆ f â‰… f i â¨¿ (âˆ fun j : ({i}á¶œ : Set Î¹) â†¦ f j) :=
  { hom := Sigma.desc (fun j â†¦ if h : j = i then eqToHom (congr_arg f h) â‰« coprod.inl else
      Sigma.Î¹ (fun j : ({i}á¶œ : Set Î¹) â†¦ f j) âŸ¨j, hâŸ© â‰« coprod.inr)
    inv := coprod.desc (Sigma.Î¹ f i) (Sigma.desc fun j â†¦ Sigma.Î¹ f j)
    hom_inv_id := by aesop_cat
    inv_hom_id := by
      ext j
      Â· simp
      Â· simp only [coprod.desc_comp, colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app,
          eqToHom_refl, Category.id_comp, dite_true, BinaryCofan.mk_pt, BinaryCofan.Î¹_app_right,
          BinaryCofan.mk_inr, colimit.Î¹_desc_assoc, Discrete.functor_obj, Category.comp_id]
        exact dif_neg j.prop }
  let e' : c.pt â‰… f i â¨¿ (âˆ fun j : ({i}á¶œ : Set Î¹) â†¦ f j) :=
    hc.coconePointUniqueUpToIso (getColimitCocone _).2 â‰ªâ‰« e
  have : coprod.inl â‰« e'.inv = c.Î¹.app âŸ¨iâŸ© := by
    simp only [e', Iso.trans_inv, coprod.desc_comp, colimit.Î¹_desc, BinaryCofan.mk_pt,
      BinaryCofan.Î¹_app_left, BinaryCofan.mk_inl]
    exact colimit.comp_coconePointUniqueUpToIso_inv _ _
  clear_value e'
  rw [â† this]
  have : IsPullback (ğŸ™ _) (g â‰« e'.hom) g e'.inv := IsPullback.of_horiz_isIso âŸ¨by simpâŸ©
  exact âŸ¨âŸ¨âŸ¨_, ((IsPullback.of_hasPullback (g â‰« e'.hom) coprod.inl).paste_horiz this).isLimitâŸ©âŸ©âŸ©","simp only [Discrete.functor_obj, Discrete.functor_obj, Discrete.functor_obj, Discrete.functor_obj]"
Mathlib/MeasureTheory/Integral/DivergenceTheorem.lean,MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable_auxâ‚,integral_divergence_of_hasFDerivWithinAt_off_countable_auxâ‚,3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  simp only [â† setIntegral_congr_set_ae (Box.coe_ae_eq_Icc _)]
  have A := (Hi.mono_set Box.coe_subset_Icc).hasBoxIntegral âŠ¥ rfl
  have B :=
    hasIntegral_GP_divergence_of_forall_hasDerivWithinAt I f f' (s âˆ© Box.Icc I)
      (hs.mono (inter_subset_left _ _)) (fun x hx => Hc _ hx.2) fun x hx =>
      Hd _ âŸ¨hx.1, fun h => hx.2 âŸ¨h, hx.1âŸ©âŸ©
  rw [continuousOn_pi] at Hc
  refine' (A.unique B).trans (sum_congr rfl fun i _ => _)
  refine congr_argâ‚‚ Sub.sub ?_ ?_
  Â· have := Box.continuousOn_face_Icc (Hc i) (Set.right_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Î¼ := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral âŠ¥ rfl).integral_eq
  Â· have := Box.continuousOn_face_Icc (Hc i) (Set.left_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Î¼ := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral âŠ¥ rfl).integral_eq","error:  overloaded, errors 
  function expected at
    Finset.inter_subset_left ?m.17305
  term has type
    ?m.17304 âˆˆ ?m.17302
  
  function expected at
    Set.inter_subset_left ?m.17442
  term has type
    ?m.17441 âˆˆ ?m.17439","theorem integral_divergence_of_hasFDerivWithinAt_off_countable_auxâ‚ (I : Box (Fin (n + 1)))
    (f : â„â¿âºÂ¹ â†’ Eâ¿âºÂ¹)
    (f' : â„â¿âºÂ¹ â†’ â„â¿âºÂ¹ â†’L[â„] Eâ¿âºÂ¹) (s : Set â„â¿âºÂ¹)
    (hs : s.Countable) (Hc : ContinuousOn f (Box.Icc I))
    (Hd : âˆ€ x âˆˆ (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x)
    (Hi : IntegrableOn (fun x => âˆ‘ i, f' x (e i) i) (Box.Icc I)) :
    (âˆ« x in Box.Icc I, âˆ‘ i, f' x (e i) i) =
      âˆ‘ i : Fin (n + 1),
        ((âˆ« x in Box.Icc (I.face i), f (i.insertNth (I.upper i) x) i) -
          âˆ« x in Box.Icc (I.face i), f (i.insertNth (I.lower i) x) i) ",":= by
  simp only [â† setIntegral_congr_set_ae (Box.coe_ae_eq_Icc _)]
  have A := (Hi.mono_set Box.coe_subset_Icc).hasBoxIntegral âŠ¥ rfl
  have B :=
    hasIntegral_GP_divergence_of_forall_hasDerivWithinAt I f f' (s âˆ© Box.Icc I)
      (hs.mono inter_subset_left) (fun x hx => Hc _ hx.2) fun x hx =>
      Hd _ âŸ¨hx.1, fun h => hx.2 âŸ¨h, hx.1âŸ©âŸ©
  rw [continuousOn_pi] at Hc
  refine (A.unique B).trans (sum_congr rfl fun i _ => ?_)
  refine congr_argâ‚‚ Sub.sub ?_ ?_
  Â· have := Box.continuousOn_face_Icc (Hc i) (Set.right_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Î¼ := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral âŠ¥ rfl).integral_eq
  Â· have := Box.continuousOn_face_Icc (Hc i) (Set.left_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Î¼ := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral âŠ¥ rfl).integral_eq",refine theorem_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithinAt_of_integral_divergence_of_hasFDerivWithi
Mathlib/RingTheory/ChainOfDivisors.lean,coe_factor_orderIso_map_eq_one_iff,coe_factor_orderIso_map_eq_one_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  âŸ¨fun hu => by
    rw [show u = (d.symm âŸ¨d âŸ¨u, hu'âŸ©, (d âŸ¨u, hu'âŸ©).propâŸ©) by
        simp only [Subtype.coe_eta, OrderIso.symm_apply_apply, Subtype.coe_mk]]
    conv_rhs => rw [â† factor_orderIso_map_one_eq_bot d.symm]
    congr, fun hu => by
    simp_rw [hu]
    conv_rhs => rw [â† factor_orderIso_map_one_eq_bot d]âŸ©","error:  unsolved goals
M : Type u_1
instâœÂ¹ : CancelCommMonoidWithZero M
N : Type u_2
instâœ : CancelCommMonoidWithZero N
m u : Associates M
n : Associates N
hu' : u â‰¤ m
d : â†‘(Set.Iic m) â‰ƒo â†‘(Set.Iic n)
hu : u = 1
âŠ¢ â†‘(d âŸ¨1, â‹¯âŸ©) = â†‘(d âŸ¨1, â‹¯âŸ©)","theorem coe_factor_orderIso_map_eq_one_iff {m u : Associates M} {n : Associates N} (hu' : u â‰¤ m)
    (d : Set.Iic m â‰ƒo Set.Iic n) : (d âŸ¨u, hu'âŸ© : Associates N) = 1 â†” u = 1 ",":=
  âŸ¨fun hu => by
    rw [show u = (d.symm âŸ¨d âŸ¨u, hu'âŸ©, (d âŸ¨u, hu'âŸ©).propâŸ©) by
        simp only [Subtype.coe_eta, OrderIso.symm_apply_apply, Subtype.coe_mk]]
    conv_rhs => rw [â† factor_orderIso_map_one_eq_bot d.symm]
    congr, fun hu => by
    simp_rw [hu]
    conv_rhs => rw [â† factor_orderIso_map_one_eq_bot d]
    rflâŸ©",constructor
Mathlib/Data/List/Sublists.lean,List.range_bind_sublistsLen_perm,range_bind_sublistsLen_perm,66caaeed4dccada03ce195a3f9db1c0009ee8118,":= by
  induction' l with h tl l_ih
  Â· simp [range_succ]
  Â· simp_rw [range_succ_eq_map, length, cons_bind, map_bind, sublistsLen_succ_cons, sublists'_cons,
      List.sublistsLen_zero, List.singleton_append]
    refine ((bind_append_perm (range (tl.length + 1)) _ _).symm.cons _).trans ?_
    simp_rw [â† List.bind_map, â† cons_append]
    rw [â† List.singleton_append, â† List.sublistsLen_zero tl]
    refine Perm.append ?_ (l_ih.map _)
    rw [List.range_succ, append_bind, bind_singleton,
      sublistsLen_of_length_lt (Nat.lt_succ_self _), append_nil, â†
      List.map_bind (fun n => sublistsLen n tl) Nat.succ, â†
      cons_bind 0 _ fun n => sublistsLen n tl, â† range_succ_eq_map]
    exact l_ih","warning:  `List.ret` has been deprecated, use `List.pure` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
error:  simp made no progress","theorem range_bind_sublistsLen_perm (l : List Î±) :
    ((List.range (l.length + 1)).bind fun n => sublistsLen n l) ~ sublists' l ",":= by
  induction' l with h tl l_ih
  Â· simp [range_succ]
  Â· simp_rw [range_succ_eq_map, length, bind_cons, bind_map, sublistsLen_succ_cons, sublists'_cons,
      List.sublistsLen_zero, List.singleton_append]
    refine ((bind_append_perm (range (tl.length + 1)) _ _).symm.cons _).trans ?_
    simp_rw [â† List.map_bind, â† cons_append]
    rw [â† List.singleton_append, â† List.sublistsLen_zero tl]
    refine Perm.append ?_ (l_ih.map _)
    rw [List.range_succ, append_bind, bind_singleton,
      sublistsLen_of_length_lt (Nat.lt_succ_self _), append_nil,
      â† List.bind_map Nat.succ fun n => sublistsLen n tl,
      â† bind_cons 0 _ fun n => sublistsLen n tl, â† range_succ_eq_map]
    exact l_ih",induction' l with _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
Mathlib/Order/WellFoundedSet.lean,Set.WellFoundedOn.acc_iff_wellFoundedOn,acc_iff_wellFoundedOn,62c2d6a1d2ffdbe5bcaa653b84d3602a209e4c8c,":= by
  tfae_have : 1 â†’ 2
  Â· refine fun h => âŸ¨fun b => InvImage.accessible _ ?_âŸ©
    rw [â† acc_transGen_iff] at h âŠ¢
    obtain h' | h' := reflTransGen_iff_eq_or_transGen.1 b.2
    Â· rwa [h'] at h
    Â· exact h.inv h'
  tfae_have : 2 â†’ 3 := fun h => h.subset fun _ => TransGen.to_reflTransGen
  tfae_have : 3 â†’ 1
  Â· refine fun h => Acc.intro _ (fun b hb => (h.apply âŸ¨b, .single hbâŸ©).of_fibration Subtype.val ?_)
    exact fun âŸ¨c, hcâŸ© d h => âŸ¨âŸ¨d, .head h hcâŸ©, h, rflâŸ©
  tfae_finish",error:  unexpected token ':'; expected numeral,"theorem acc_iff_wellFoundedOn {Î±} {r : Î± â†’ Î± â†’ Prop} {a : Î±} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r] ",":= by
  tfae_have 1 â†’ 2
  Â· refine fun h => âŸ¨fun b => InvImage.accessible _ ?_âŸ©
    rw [â† acc_transGen_iff] at h âŠ¢
    obtain h' | h' := reflTransGen_iff_eq_or_transGen.1 b.2
    Â· rwa [h'] at h
    Â· exact h.inv h'
  tfae_have 2 â†’ 3
  Â· exact fun h => h.subset fun _ => TransGen.to_reflTransGen
  tfae_have 3 â†’ 1
  Â· refine fun h => Acc.intro _ (fun b hb => (h.apply âŸ¨b, .single hbâŸ©).of_fibration Subtype.val ?_)
    exact fun âŸ¨c, hcâŸ© d h => âŸ¨âŸ¨d, .head h hcâŸ©, h, rflâŸ©
  tfae_finish",simp only [reflTransGen_eq_transGen]
Mathlib/MeasureTheory/Integral/PeakFunction.lean,tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto,tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine Metric.tendsto_nhds.2 fun Îµ Îµpos => ?_
  obtain âŸ¨Î´, hÎ´, Î´pos, Î´oneâŸ© : âˆƒ Î´, (Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * Î´ < Îµ âˆ§ 0 < Î´ âˆ§ Î´ < 1:= by
    have A :
      Tendsto (fun Î´ => (Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * Î´) (ğ“[>] 0)
        (ğ“ ((0 * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * 0)) := by
      apply Tendsto.mono_left _ nhdsWithin_le_nhds
      exact (tendsto_id.mul tendsto_const_nhds).add (tendsto_id.const_mul _)
    rw [zero_mul, zero_add, mul_zero] at A
    have : Ioo (0 : â„) 1 âˆˆ ğ“[>] 0 := Ioo_mem_nhdsWithin_Ioi âŸ¨le_rfl, zero_lt_oneâŸ©
    rcases (((tendsto_order.1 A).2 Îµ Îµpos).and this).exists with âŸ¨Î´, hÎ´, h'Î´âŸ©
    exact âŸ¨Î´, hÎ´, h'Î´.1, h'Î´.2âŸ©
  suffices âˆ€á¶  i in l, â€–âˆ« x in s, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ (Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * Î´ by
    filter_upwards [this] with i hi
    simp only [dist_zero_right]
    exact hi.trans_lt hÎ´
  obtain âŸ¨u, u_open, xâ‚€u, ut, huâŸ© :
      âˆƒ u, IsOpen u âˆ§ xâ‚€ âˆˆ u âˆ§ s âˆ© u âŠ† t âˆ§ âˆ€ x âˆˆ u âˆ© s, g x âˆˆ ball 0 Î´ := by
    rcases mem_nhdsWithin.1 (Filter.inter_mem h'ts (hcg (ball_mem_nhds _ Î´pos)))
      with âŸ¨u, u_open, xâ‚€u, huâŸ©
    refine âŸ¨u, u_open, xâ‚€u, ?_, hu.trans (inter_subset_right _ _)âŸ©
    rw [inter_comm]
    exact hu.trans (inter_subset_left _ _)
  filter_upwards [tendstoUniformlyOn_iff.1 (hlÏ† u u_open xâ‚€u) Î´ Î´pos,
    (tendsto_order.1 (tendsto_iff_norm_sub_tendsto_zero.1 hiÏ†)).2 Î´ Î´pos, hnÏ†,
    integrableOn_peak_smul_of_integrableOn_of_tendsto hs h'ts hlÏ† hiÏ† h'iÏ† hmg hcg]
    with i hi h'i hÏ†pos h''i
  have I : IntegrableOn (Ï† i) t Î¼ := by
    apply Integrable.of_integral_ne_zero (fun h â†¦ ?_)
    simp [h] at h'i
    linarith
  have B : â€–âˆ« x in s âˆ© u, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ 2 * Î´ :=
    calc
      â€–âˆ« x in s âˆ© u, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ âˆ« x in s âˆ© u, â€–Ï† i x â€¢ g xâ€– âˆ‚Î¼ :=
        norm_integral_le_integral_norm _
      _ â‰¤ âˆ« x in s âˆ© u, â€–Ï† i xâ€– * Î´ âˆ‚Î¼ := by
        refine setIntegral_mono_on ?_ ?_ (hs.inter u_open.measurableSet) fun x hx =?> _
        Â· exact IntegrableOn.mono_set h''i.norm (inter_subset_left _ _)
        Â· exact IntegrableOn.mono_set (I.norm.mul_const _) ut
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
        rw [inter_comm] at hu
        exact (mem_ball_zero_iff.1 (hu x hx)).le
      _ â‰¤ âˆ« x in t, â€–Ï† i xâ€– * Î´ âˆ‚Î¼ := by
        apply setIntegral_mono_set
        Â· exact I.norm.mul_const _
        Â· exact eventually_of_forall fun x => mul_nonneg (norm_nonneg _) Î´pos.le
        Â· exact eventually_of_forall ut
      _ = âˆ« x in t, Ï† i x * Î´ âˆ‚Î¼ := by
        apply setIntegral_congr ht fun x hx => ?_
        rw [Real.norm_of_nonneg (hÏ†pos _ (hts hx))]
      _ = (âˆ« x in t, Ï† i x âˆ‚Î¼) * Î´ := by rw [integral_mul_right]
      _ â‰¤ 2 * Î´ := by gcongr; linarith [(le_abs_self _).trans h'i.le]
  have C : â€–âˆ« x in s \ u, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼ :=
    calc
      â€–âˆ« x in s \ u, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ âˆ« x in s \ u, â€–Ï† i x â€¢ g xâ€– âˆ‚Î¼ :=
        norm_integral_le_integral_norm _
      _ â‰¤ âˆ« x in s \ u, Î´ * â€–g xâ€– âˆ‚Î¼ := by
        refine setIntegral_mono_on ?_ ?_ (hs.diff u_open.measurableSet) fun x hx => ?_
        Â· exact IntegrableOn.mono_set h''i.norm (diff_subset _ _)
        Â· exact IntegrableOn.mono_set (hmg.norm.const_mul _) (diff_subset _ _)
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le
      _ â‰¤ Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼ := by
        rw [integral_mul_left]
        apply mul_le_mul_of_nonneg_left (setIntegral_mono_set hmg.norm _ _) Î´pos.le
        Â· filter_upwards with x using norm_nonneg _
        Â· filter_upwards using diff_subset s u
  calc
    â€–âˆ« x in s, Ï† i x â€¢ g x âˆ‚Î¼â€– =
      â€–(âˆ« x in s \ u, Ï† i x â€¢ g x âˆ‚Î¼) + âˆ« x in s âˆ© u, Ï† i x â€¢ g x âˆ‚Î¼â€– := by
      conv_lhs => rw [â† diff_union_inter s u]
      rw [integral_union disjoint_sdiff_inter (hs.inter u_open.measurableSet)
          (h''i.mono_set (diff_subset _ _)) (h''i.mono_set (inter_subset_left _ _))]
    _ â‰¤ â€–âˆ« x in s \ u, Ï† i x â€¢ g x âˆ‚Î¼â€– + â€–âˆ« x in s âˆ© u, Ï† i x â€¢ g x âˆ‚Î¼â€– := norm_add_le _ _
    _ â‰¤ (Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * Î´ := add_le_add C B","error:  unexpected token '='; expected 'â†¦', '=>'
error:  unsolved goals
case refine_1
Î± : Type u_1
E : Type u_2
Î¹ : Type u_3
hm : MeasurableSpace Î±
Î¼ : Measure Î±
instâœâ´ : TopologicalSpace Î±
instâœÂ³ : BorelSpace Î±
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
g : Î± â†’ E
l : Filter Î¹
xâ‚€ : Î±
s t : Set Î±
Ï† : Î¹ â†’ Î± â†’ â„
a : E
instâœ : CompleteSpace E
hs : MeasurableSet s
ht : MeasurableSet t
hts : t âŠ† s
h'ts : t âˆˆ ğ“[s] xâ‚€
hnÏ† : âˆ€á¶  (i : Î¹) in l, âˆ€ x âˆˆ s, 0 â‰¤ Ï† i x
hlÏ† : âˆ€ (u : Set Î±), IsOpen u â†’ xâ‚€ âˆˆ u â†’ TendstoUniformlyOn Ï† 0 l (s \ u)
hiÏ† : Tendsto (fun i â†¦ âˆ« (x : Î±) in t, Ï† i x âˆ‚Î¼) l (ğ“ 1)
h'iÏ† : âˆ€á¶  (i : Î¹) in l, AEStronglyMeasurable (Ï† i) (Î¼.restrict s)
hmg : IntegrableOn g s Î¼
hcg : Tendsto g (ğ“[s] xâ‚€) (ğ“ 0)
Îµ : â„
Îµpos : Îµ > 0
Î´ : â„
hÎ´ : Î´ * âˆ« (x : Î±) in s, â€–g xâ€– âˆ‚Î¼ + 2 * Î´ < Îµ
Î´pos : 0 < Î´
Î´one : Î´ < 1
u : Set Î±
u_open : IsOpen u
xâ‚€u : xâ‚€ âˆˆ u
ut : s âˆ© u âŠ† t
hu : âˆ€ x âˆˆ u âˆ© s, g x âˆˆ ball 0 Î´
i : Î¹
hi : âˆ€ x âˆˆ s \ u, dist (0 x) (Ï† i x) < Î´
h'i : â€–âˆ« (x : Î±) in t, Ï† i x âˆ‚Î¼ - 1â€– < Î´
hÏ†pos : âˆ€ x âˆˆ s, 0 â‰¤ Ï† i x
h''i : IntegrableOn (fun x â†¦ Ï† i x â€¢ g x) s Î¼
I : IntegrableOn (Ï† i) t Î¼
âŠ¢ IntegrableOn (fun x â†¦ â€–Ï† i x â€¢ g xâ€–) (s âˆ© u) Î¼

case refine_2
Î± : Type u_1
E : Type u_2
Î¹ : Type u_3
hm : MeasurableSpace Î±
Î¼ : Measure Î±
instâœâ´ : TopologicalSpace Î±
instâœÂ³ : BorelSpace Î±
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
g : Î± â†’ E
l : Filter Î¹
xâ‚€ : Î±
s t : Set Î±
Ï† : Î¹ â†’ Î± â†’ â„
a : E
instâœ : CompleteSpace E
hs : MeasurableSet s
ht : MeasurableSet t
hts : t âŠ† s
h'ts : t âˆˆ ğ“[s] xâ‚€
hnÏ† : âˆ€á¶  (i : Î¹) in l, âˆ€ x âˆˆ s, 0 â‰¤ Ï† i x
hlÏ† : âˆ€ (u : Set Î±), IsOpen u â†’ xâ‚€ âˆˆ u â†’ TendstoUniformlyOn Ï† 0 l (s \ u)
hiÏ† : Tendsto (fun i â†¦ âˆ« (x : Î±) in t, Ï† i x âˆ‚Î¼) l (ğ“ 1)
h'iÏ† : âˆ€á¶  (i : Î¹) in l, AEStronglyMeasurable (Ï† i) (Î¼.restrict s)
hmg : IntegrableOn g s Î¼
hcg : Tendsto g (ğ“[s] xâ‚€) (ğ“ 0)
Îµ : â„
Îµpos : Îµ > 0
Î´ : â„
hÎ´ : Î´ * âˆ« (x : Î±) in s, â€–g xâ€– âˆ‚Î¼ + 2 * Î´ < Îµ
Î´pos : 0 < Î´
Î´one : Î´ < 1
u : Set Î±
u_open : IsOpen u
xâ‚€u : xâ‚€ âˆˆ u
ut : s âˆ© u âŠ† t
hu : âˆ€ x âˆˆ u âˆ© s, g x âˆˆ ball 0 Î´
i : Î¹
hi : âˆ€ x âˆˆ s \ u, dist (0 x) (Ï† i x) < Î´
h'i : â€–âˆ« (x : Î±) in t, Ï† i x âˆ‚Î¼ - 1â€– < Î´
hÏ†pos : âˆ€ x âˆˆ s, 0 â‰¤ Ï† i x
h''i : IntegrableOn (fun x â†¦ Ï† i x â€¢ g x) s Î¼
I : IntegrableOn (Ï† i) t Î¼
âŠ¢ IntegrableOn (fun x â†¦ â€–Ï† i xâ€– * Î´) (s âˆ© u) Î¼
error:  unsolved goals
case h
Î± : Type u_1
E : Type u_2
Î¹ : Type u_3
hm : MeasurableSpace Î±
Î¼ : Measure Î±
instâœâ´ : TopologicalSpace Î±
instâœÂ³ : BorelSpace Î±
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
g : Î± â†’ E
l : Filter Î¹
xâ‚€ : Î±
s t : Set Î±
Ï† : Î¹ â†’ Î± â†’ â„
a : E
instâœ : CompleteSpace E
hs : MeasurableSet s
ht : MeasurableSet t
hts : t âŠ† s
h'ts : t âˆˆ ğ“[s] xâ‚€
hnÏ† : âˆ€á¶  (i : Î¹) in l, âˆ€ x âˆˆ s, 0 â‰¤ Ï† i x
hlÏ† : âˆ€ (u : Set Î±), IsOpen u â†’ xâ‚€ âˆˆ u â†’ TendstoUniformlyOn Ï† 0 l (s \ u)
hiÏ† : Tendsto (fun i â†¦ âˆ« (x : Î±) in t, Ï† i x âˆ‚Î¼) l (ğ“ 1)
h'iÏ† : âˆ€á¶  (i : Î¹) in l, AEStronglyMeasurable (Ï† i) (Î¼.restrict s)
hmg : IntegrableOn g s Î¼
hcg : Tendsto g (ğ“[s] xâ‚€) (ğ“ 0)
Îµ : â„
Îµpos : Îµ > 0
Î´ : â„
hÎ´ : Î´ * âˆ« (x : Î±) in s, â€–g xâ€– âˆ‚Î¼ + 2 * Î´ < Îµ
Î´pos : 0 < Î´
Î´one : Î´ < 1
u : Set Î±
u_open : IsOpen u
xâ‚€u : xâ‚€ âˆˆ u
ut : s âˆ© u âŠ† t
hu : âˆ€ x âˆˆ u âˆ© s, g x âˆˆ ball 0 Î´
i : Î¹
hi : âˆ€ x âˆˆ s \ u, dist (0 x) (Ï† i x) < Î´
h'i : â€–âˆ« (x : Î±) in t, Ï† i x âˆ‚Î¼ - 1â€– < Î´
hÏ†pos : âˆ€ x âˆˆ s, 0 â‰¤ Ï† i x
h''i : IntegrableOn (fun x â†¦ Ï† i x â€¢ g x) s Î¼
I : IntegrableOn (Ï† i) t Î¼
B : â€–âˆ« (x : Î±) in s âˆ© u, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ 2 * Î´
âŠ¢ â€–âˆ« (x : Î±) in s, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ Î´ * âˆ« (x : Î±) in s, â€–g xâ€– âˆ‚Î¼ + 2 * Î´","theorem tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux
    (hs : MeasurableSet s) (ht : MeasurableSet t) (hts : t âŠ† s) (h'ts : t âˆˆ ğ“[s] xâ‚€)
    (hnÏ† : âˆ€á¶  i in l, âˆ€ x âˆˆ s, 0 â‰¤ Ï† i x)
    (hlÏ† : âˆ€ u : Set Î±, IsOpen u â†’ xâ‚€ âˆˆ u â†’ TendstoUniformlyOn Ï† 0 l (s \ u))
    (hiÏ† : Tendsto (fun i â†¦ âˆ« x in t, Ï† i x âˆ‚Î¼) l (ğ“ 1))
    (h'iÏ† : âˆ€á¶  i in l, AEStronglyMeasurable (Ï† i) (Î¼.restrict s))
    (hmg : IntegrableOn g s Î¼) (hcg : Tendsto g (ğ“[s] xâ‚€) (ğ“ 0)) :
    Tendsto (fun i : Î¹ => âˆ« x in s, Ï† i x â€¢ g x âˆ‚Î¼) l (ğ“ 0) ",":= by
  refine Metric.tendsto_nhds.2 fun Îµ Îµpos => ?_
  obtain âŸ¨Î´, hÎ´, Î´pos, Î´oneâŸ© : âˆƒ Î´, (Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * Î´ < Îµ âˆ§ 0 < Î´ âˆ§ Î´ < 1:= by
    have A :
      Tendsto (fun Î´ => (Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * Î´) (ğ“[>] 0)
        (ğ“ ((0 * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * 0)) := by
      apply Tendsto.mono_left _ nhdsWithin_le_nhds
      exact (tendsto_id.mul tendsto_const_nhds).add (tendsto_id.const_mul _)
    rw [zero_mul, zero_add, mul_zero] at A
    have : Ioo (0 : â„) 1 âˆˆ ğ“[>] 0 := Ioo_mem_nhdsWithin_Ioi âŸ¨le_rfl, zero_lt_oneâŸ©
    rcases (((tendsto_order.1 A).2 Îµ Îµpos).and this).exists with âŸ¨Î´, hÎ´, h'Î´âŸ©
    exact âŸ¨Î´, hÎ´, h'Î´.1, h'Î´.2âŸ©
  suffices âˆ€á¶  i in l, â€–âˆ« x in s, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ (Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * Î´ by
    filter_upwards [this] with i hi
    simp only [dist_zero_right]
    exact hi.trans_lt hÎ´
  obtain âŸ¨u, u_open, xâ‚€u, ut, huâŸ© :
      âˆƒ u, IsOpen u âˆ§ xâ‚€ âˆˆ u âˆ§ s âˆ© u âŠ† t âˆ§ âˆ€ x âˆˆ u âˆ© s, g x âˆˆ ball 0 Î´ := by
    rcases mem_nhdsWithin.1 (Filter.inter_mem h'ts (hcg (ball_mem_nhds _ Î´pos)))
      with âŸ¨u, u_open, xâ‚€u, huâŸ©
    refine âŸ¨u, u_open, xâ‚€u, ?_, hu.trans inter_subset_rightâŸ©
    rw [inter_comm]
    exact hu.trans inter_subset_left
  filter_upwards [tendstoUniformlyOn_iff.1 (hlÏ† u u_open xâ‚€u) Î´ Î´pos,
    (tendsto_order.1 (tendsto_iff_norm_sub_tendsto_zero.1 hiÏ†)).2 Î´ Î´pos, hnÏ†,
    integrableOn_peak_smul_of_integrableOn_of_tendsto hs h'ts hlÏ† hiÏ† h'iÏ† hmg hcg]
    with i hi h'i hÏ†pos h''i
  have I : IntegrableOn (Ï† i) t Î¼ := by
    apply Integrable.of_integral_ne_zero (fun h â†¦ ?_)
    simp [h] at h'i
    linarith
  have B : â€–âˆ« x in s âˆ© u, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ 2 * Î´ :=
    calc
      â€–âˆ« x in s âˆ© u, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ âˆ« x in s âˆ© u, â€–Ï† i x â€¢ g xâ€– âˆ‚Î¼ :=
        norm_integral_le_integral_norm _
      _ â‰¤ âˆ« x in s âˆ© u, â€–Ï† i xâ€– * Î´ âˆ‚Î¼ := by
        refine setIntegral_mono_on ?_ ?_ (hs.inter u_open.measurableSet) fun x hx => ?_
        Â· exact IntegrableOn.mono_set h''i.norm inter_subset_left
        Â· exact IntegrableOn.mono_set (I.norm.mul_const _) ut
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
        rw [inter_comm] at hu
        exact (mem_ball_zero_iff.1 (hu x hx)).le
      _ â‰¤ âˆ« x in t, â€–Ï† i xâ€– * Î´ âˆ‚Î¼ := by
        apply setIntegral_mono_set
        Â· exact I.norm.mul_const _
        Â· exact eventually_of_forall fun x => mul_nonneg (norm_nonneg _) Î´pos.le
        Â· exact eventually_of_forall ut
      _ = âˆ« x in t, Ï† i x * Î´ âˆ‚Î¼ := by
        apply setIntegral_congr ht fun x hx => ?_
        rw [Real.norm_of_nonneg (hÏ†pos _ (hts hx))]
      _ = (âˆ« x in t, Ï† i x âˆ‚Î¼) * Î´ := by rw [integral_mul_right]
      _ â‰¤ 2 * Î´ := by gcongr; linarith [(le_abs_self _).trans h'i.le]
  have C : â€–âˆ« x in s \ u, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼ :=
    calc
      â€–âˆ« x in s \ u, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ âˆ« x in s \ u, â€–Ï† i x â€¢ g xâ€– âˆ‚Î¼ :=
        norm_integral_le_integral_norm _
      _ â‰¤ âˆ« x in s \ u, Î´ * â€–g xâ€– âˆ‚Î¼ := by
        refine setIntegral_mono_on ?_ ?_ (hs.diff u_open.measurableSet) fun x hx => ?_
        Â· exact IntegrableOn.mono_set h''i.norm diff_subset
        Â· exact IntegrableOn.mono_set (hmg.norm.const_mul _) diff_subset
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le
      _ â‰¤ Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼ := by
        rw [integral_mul_left]
        apply mul_le_mul_of_nonneg_left (setIntegral_mono_set hmg.norm _ _) Î´pos.le
        Â· filter_upwards with x using norm_nonneg _
        Â· filter_upwards using diff_subset (s := s) (t := u)
  calc
    â€–âˆ« x in s, Ï† i x â€¢ g x âˆ‚Î¼â€– =
      â€–(âˆ« x in s \ u, Ï† i x â€¢ g x âˆ‚Î¼) + âˆ« x in s âˆ© u, Ï† i x â€¢ g x âˆ‚Î¼â€– := by
      conv_lhs => rw [â† diff_union_inter s u]
      rw [integral_union disjoint_sdiff_inter (hs.inter u_open.measurableSet)
          (h''i.mono_set diff_subset) (h''i.mono_set inter_subset_left)]
    _ â‰¤ â€–âˆ« x in s \ u, Ï† i x â€¢ g x âˆ‚Î¼â€– + â€–âˆ« x in s âˆ© u, Ï† i x â€¢ g x âˆ‚Î¼â€– := norm_add_le _ _
    _ â‰¤ (Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * Î´ := add_le_add C B",rw [tendsto_zero_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux]
Mathlib/Data/Multiset/Basic.lean,Multiset.count_map_eq_count',count_map_eq_count',31e46d90d4615cdb7dafe20fedfbb69501f33e7d,":= by
  by_cases H : x âˆˆ s
  Â· exact count_map_eq_count f _ (Set.injOn_of_injective hf _) _ H
  Â· rw [count_eq_zero_of_not_mem H, count_eq_zero, mem_map]
    rintro âŸ¨k, hks, hkxâŸ©
    rw [hf hkx] at hks
    contradiction","warning:  @cons does not have a doc string
warning:  `List.filter_congr'` has been deprecated, use `List.filter_congr` instead
error:  application type mismatch
  count_map_eq_count f ?m.280425 (Set.injOn_of_injective hf ?m.280442)
argument
  Set.injOn_of_injective hf ?m.280442
has type
  âˆ€ â¦ƒxâ‚‚ : Î±â¦„, xâ‚‚ âˆˆ ?m.280440 â†’ f ?m.280441 = f xâ‚‚ â†’ ?m.280441 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn f {x | x âˆˆ ?m.280425} : Prop
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead","theorem count_map_eq_count' [DecidableEq Î²] (f : Î± â†’ Î²) (s : Multiset Î±) (hf : Function.Injective f)
    (x : Î±) : (s.map f).count (f x) = s.count x ",":= by
  by_cases H : x âˆˆ s
  Â· exact count_map_eq_count f _ hf.injOn _ H
  Â· rw [count_eq_zero_of_not_mem H, count_eq_zero, mem_map]
    rintro âŸ¨k, hks, hkxâŸ©
    rw [hf hkx] at hks
    contradiction","rw [count_map_eq_count', count_map_eq_count', count_map_eq_count']"
Mathlib/Topology/Support.lean,LocallyFinite.exists_finset_nhd_mulSupport_subset,LocallyFinite.exists_finset_nhd_mulSupport_subset,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  obtain âŸ¨n, hn, hnfâŸ© := hlf x
  classical
    let is := hnf.toFinset.filter fun i => x âˆˆ U i
    let js := hnf.toFinset.filter fun j => x âˆ‰ U j
    refine'
      âŸ¨is, (n âˆ© â‹‚ j âˆˆ js, (mulTSupport (f j))á¶œ) âˆ© â‹‚ i âˆˆ is, U i, inter_mem (inter_mem hn _) _,
        inter_subset_right _ _, fun z hz => _âŸ©
    Â· exact (biInter_finset_mem js).mpr fun j hj => IsClosed.compl_mem_nhds (isClosed_mulTSupport _)
        (Set.not_mem_subset (hso j) (Finset.mem_filter.mp hj).2)
    Â· exact (biInter_finset_mem is).mpr fun i hi => (ho i).mem_nhds (Finset.mem_filter.mp hi).2
    Â· have hzn : z âˆˆ n := by
        rw [inter_assoc] at hz
        exact mem_of_mem_inter_left hz
      replace hz := mem_of_mem_inter_right (mem_of_mem_inter_left hz)
      simp only [Finset.mem_filter, Finite.mem_toFinset, mem_setOf_eq, mem_iInter, and_imp] at hz
      suffices (mulSupport fun i => f i z) âŠ† hnf.toFinset by
        refine' hnf.toFinset.subset_coe_filter_of_subset_forall _ this fun i hi => _
        specialize hz i âŸ¨z, âŸ¨hi, hznâŸ©âŸ©
        contrapose hz
        simp [hz, subset_mulTSupport (f i) hi]
      intro i hi
      simp only [Finite.coe_toFinset, mem_setOf_eq]
      exact âŸ¨z, âŸ¨hi, hznâŸ©âŸ©","error:  function expected at
  inter_subset_right ?m.39578
term has type
  ?m.39577 âˆˆ ?m.39576
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  Quot.lift (fun l â†¦ i âˆˆ l) â‹¯ js.val","theorem LocallyFinite.exists_finset_nhd_mulSupport_subset {U : Î¹ â†’ Set X} [One R] {f : Î¹ â†’ X â†’ R}
    (hlf : LocallyFinite fun i => mulSupport (f i)) (hso : âˆ€ i, mulTSupport (f i) âŠ† U i)
    (ho : âˆ€ i, IsOpen (U i)) (x : X) :
    âˆƒ (is : Finset Î¹), âˆƒ n, n âˆˆ ğ“ x âˆ§ (n âŠ† â‹‚ i âˆˆ is, U i) âˆ§
      âˆ€ z âˆˆ n, (mulSupport fun i => f i z) âŠ† is ",":= by
  obtain âŸ¨n, hn, hnfâŸ© := hlf x
  classical
    let is := hnf.toFinset.filter fun i => x âˆˆ U i
    let js := hnf.toFinset.filter fun j => x âˆ‰ U j
    refine
      âŸ¨is, (n âˆ© â‹‚ j âˆˆ js, (mulTSupport (f j))á¶œ) âˆ© â‹‚ i âˆˆ is, U i, inter_mem (inter_mem hn ?_) ?_,
        inter_subset_right, fun z hz => ?_âŸ©
    Â· exact (biInter_finset_mem js).mpr fun j hj => IsClosed.compl_mem_nhds (isClosed_mulTSupport _)
        (Set.not_mem_subset (hso j) (Finset.mem_filter.mp hj).2)
    Â· exact (biInter_finset_mem is).mpr fun i hi => (ho i).mem_nhds (Finset.mem_filter.mp hi).2
    Â· have hzn : z âˆˆ n := by
        rw [inter_assoc] at hz
        exact mem_of_mem_inter_left hz
      replace hz := mem_of_mem_inter_right (mem_of_mem_inter_left hz)
      simp only [js, Finset.mem_filter, Finite.mem_toFinset, mem_setOf_eq, mem_iInter,
        and_imp] at hz
      suffices (mulSupport fun i => f i z) âŠ† hnf.toFinset by
        refine hnf.toFinset.subset_coe_filter_of_subset_forall _ this fun i hi => ?_
        specialize hz i âŸ¨z, âŸ¨hi, hznâŸ©âŸ©
        contrapose hz
        simp [hz, subset_mulTSupport (f i) hi]
      intro i hi
      simp only [Finite.coe_toFinset, mem_setOf_eq]
      exact âŸ¨z, âŸ¨hi, hznâŸ©âŸ©","rcases exists_finset_nhd_mulSupport_subset_nhd_mulSupport_subset hlf ho x x with
  âŸ¨t, htU, htUâŸ©"
Mathlib/Order/Filter/Archimedean.lean,Filter.Tendsto.const_mul_atTop',Tendsto.const_mul_atTop',9a5e0ce9f9b714fd5383610a12746cded21f030f,":= by
  refine' tendsto_atTop.2 fun b => _
  obtain âŸ¨n : â„•, hn : 1 â‰¤ n â€¢ râŸ© := Archimedean.arch 1 hr
  rw [nsmul_eq_mul'] at hn
  filter_upwards [tendsto_atTop.1 hf (n * max b 0)]with x hx
  calc
    b â‰¤ 1 * max b 0 := by
    { rw [one_mul]
      exact le_max_left _ _ }
    _ â‰¤ r * n * max b 0 := by rel_congr
    _ = r * (n * max b 0) := by rw [mul_assoc]
    _ â‰¤ r * f x := by rel_congr","error:  unknown tactic
error:  unsolved goals
Î± : Type u_1
R : Type u_2
l : Filter Î±
f : Î± â†’ R
r : R
instâœÂ¹ : LinearOrderedSemiring R
instâœ : Archimedean R
hr : 0 < r
hf : Tendsto f l atTop
b : R
n : â„•
hn : 1 â‰¤ r * â†‘n
x : Î±
hx : â†‘n * max b 0 â‰¤ f x
âŠ¢ 1 * max b 0 â‰¤ r * â†‘n * max b 0
error:  unsolved goals
case h.calc.step
Î± : Type u_1
R : Type u_2
l : Filter Î±
f : Î± â†’ R
r : R
instâœÂ¹ : LinearOrderedSemiring R
instâœ : Archimedean R
hr : 0 < r
hf : Tendsto f l atTop
b : R
n : â„•
hn : 1 â‰¤ r * â†‘n
x : Î±
hx : â†‘n * max b 0 â‰¤ f x
âŠ¢ r * â†‘n * max b 0 â‰¤ r * f x","theorem Tendsto.const_mul_atTop' (hr : 0 < r) (hf : Tendsto f l atTop) :
    Tendsto (fun x => r * f x) l atTop ",":= by
  refine tendsto_atTop.2 fun b => ?_
  obtain âŸ¨n : â„•, hn : 1 â‰¤ n â€¢ râŸ© := Archimedean.arch 1 hr
  rw [nsmul_eq_mul'] at hn
  filter_upwards [tendsto_atTop.1 hf (n * max b 0)] with x hx
  calc
    b â‰¤ 1 * max b 0 := by
    { rw [one_mul]
      exact le_max_left _ _ }
    _ â‰¤ r * n * max b 0 := by gcongr
    _ = r * (n * max b 0) := by rw [mul_assoc]
    _ â‰¤ r * f x := by gcongr",rw [tendsto_const_mul_atTop'] at hf
Mathlib/Computability/AkraBazzi/AkraBazzi.lean,AkraBazziRecurrence.asympBound_pos,asympBound_pos,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  calc 0 < (n : â„) ^ p a b * (1 + 0)   : = by aesop (add safe Real.rpow_pos_of_pos)
       _ â‰¤ asympBound g a b n    := by
                    simp only [asympBound_def']
                    gcongr n^p a b * (1 + ?_)
                    have := R.g_nonneg
                    aesop (add safe Real.rpow_nonneg,
                               safe div_nonneg,
                               safe Finset.sum_nonneg)","error:  invalid 'calc' step, failed to synthesize `Trans` instance
  Trans Eq LT.lt ?m.382865
use `set_option diagnostics true` to get diagnostic information
error:  unexpected token ':'; expected command
error:  invalid field notation, function 'AkraBazziRecurrence.asympBound_pos' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'AkraBazziRecurrence.eventually_asympBound_pos' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'AkraBazziRecurrence.eventually_asympBound_pos' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'AkraBazziRecurrence.eventually_asympBound_r_pos' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'AkraBazziRecurrence.eventually_asympBound_pos' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name
error:  function expected at
  h_asympBound_r_pos n hn
term has type
  ?m.1168812 n
error:  invalid field notation, function 'AkraBazziRecurrence.eventually_asympBound_pos' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'AkraBazziRecurrence.eventually_asympBound_r_pos' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'AkraBazziRecurrence.eventually_asympBound_pos' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'AkraBazziRecurrence.asympBound_pos' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name
error:  no goals to be solved
error:  function expected at
  h_asympBound_r_pos n hn
term has type
  ?m.1382958 n
error:  invalid field notation, function 'AkraBazziRecurrence.T_isBigO_smoothingFn_mul_asympBound' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'AkraBazziRecurrence.smoothingFn_mul_asympBound_isBigO_T' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'AkraBazziRecurrence.isBigO_asympBound' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'AkraBazziRecurrence.isBigO_symm_asympBound' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name",lemma asympBound_pos (n : â„•) (hn : 0 < n) : 0 < asympBound g a b n ,":= by
  calc 0 < (n:â„) ^ p a b * (1 + 0)    := by aesop (add safe Real.rpow_pos_of_pos)
       _ â‰¤ asympBound g a b n    := by
                    simp only [asympBound_def']
                    gcongr n^p a b * (1 + ?_)
                    have := R.g_nonneg
                    aesop (add safe Real.rpow_nonneg,
                               safe div_nonneg,
                               safe Finset.sum_nonneg)",apply asympBound_pos
Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean,SimpleGraph.isAdjMatrix_adjMatrix,isAdjMatrix_adjMatrix,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  { zero_or_one := fun i j => by by_cases G.Adj i j <;> simp [h] }","error:  unknown identifier 'h'
error:  unknown identifier 'h'
error:  unsolved goals
case pos
V : Type u_1
Î± : Type u_2
Î² : Type u_3
G : SimpleGraph V
instâœÂ² : DecidableRel G.Adj
instâœÂ¹ : Zero Î±
instâœ : One Î±
i j : V
hâœ : G.Adj i j
âŠ¢ (G.Adj i j â†’ 1 = 0) âˆ¨ (Â¬G.Adj i j â†’ 0 = 1)

case neg
V : Type u_1
Î± : Type u_2
Î² : Type u_3
G : SimpleGraph V
instâœÂ² : DecidableRel G.Adj
instâœÂ¹ : Zero Î±
instâœ : One Î±
i j : V
hâœ : Â¬G.Adj i j
âŠ¢ (G.Adj i j â†’ 1 = 0) âˆ¨ (Â¬G.Adj i j â†’ 0 = 1)",theorem isAdjMatrix_adjMatrix [Zero Î±] [One Î±] : (G.adjMatrix Î±).IsAdjMatrix ,":=
  { zero_or_one := fun i j => by by_cases h : G.Adj i j <;> simp [h] }",simp [isAdjMatrix_adjMatrix]
Mathlib/Data/Set/Pointwise/Interval.lean,Set.Iio_add_bij,Iio_add_bij,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  image_add_const_Iio a b â–¸ ((add_left_injective _).injOn _).bijOn_image","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Function.Injective.injOn (add_left_injective ?m.292655) ?m.292716
has type
  âˆ€ â¦ƒxâ‚‚ : ?m.292706â¦„, xâ‚‚ âˆˆ ?m.292714 â†’ ?m.292715 + ?m.292655 = xâ‚‚ + ?m.292655 â†’ ?m.292715 = xâ‚‚",theorem Iio_add_bij : BijOn (Â· + a) (Iio b) (Iio (b + a)) ,":=
  image_add_const_Iio a b â–¸ (add_left_injective _).injOn.bijOn_image",refine Iio_add_bij.ext fun x hx => ?_
Mathlib/Topology/Order/LowerUpperTopology.lean,Topology.IsLower.isClosed_upperClosure,isClosed_upperClosure,0c24f831f1e333c5ed24e554039194a5b498d9c4,":= by
  simp only [â† UpperSet.iInf_Ici, UpperSet.coe_iInf]
  exact isClosed_biUnion h fun a _ => isClosed_Ici a",error:  unknown identifier 'isClosed_biUnion',theorem isClosed_upperClosure (h : s.Finite) : IsClosed (upperClosure s : Set Î±) ,":= by
  simp only [â† UpperSet.iInf_Ici, UpperSet.coe_iInf]
  exact h.isClosed_biUnion fun _ _ => isClosed_Ici",rw [upperClosure_eq_upperClosure]
Mathlib/Topology/CompactOpen.lean,ContinuousMap.isClopen_setOf_mapsTo,isClopen_setOf_mapsTo,cc09a527d23758e59089abfcd1d1b06188b4e507,":=
  âŸ¨isOpen_setOf_mapsTo hK hU.isOpen, isClosed_setOf_mapsTo hU.isClosed KâŸ©","error:  application type mismatch
  And.intro (isOpen_setOf_mapsTo hK (IsClopen.isOpen hU))
argument
  isOpen_setOf_mapsTo hK (IsClopen.isOpen hU)
has type
  IsOpen {f | MapsTo (â‡‘f) K U} : Prop
but is expected to have type
  IsClosed {f | MapsTo (â‡‘f) K U} : Prop
warning:  `ContinuousMap.curry'` has been deprecated, use `ContinuousMap.curry` instead","lemma isClopen_setOf_mapsTo (hK : IsCompact K) (hU : IsClopen U) :
    IsClopen {f : C(X, Y) | MapsTo f K U} ",":=
  âŸ¨isClosed_setOf_mapsTo hU.isClosed K, isOpen_setOf_mapsTo hK hU.isOpenâŸ©","refine IsClopen.isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isClopen ?_
  (isCompact_of_isClopen_setOf_mapsTo isClopen_setOf_mapsTo hK hU hU)"
Mathlib/Data/PFunctor/Multivariate/W.lean,MvPFunctor.w_ind,w_ind,9e34a191034458a56331f976ff7400a26407c888,":= by
  intro x; cases' x with a f
  apply @wp_ind n P Î± fun a f => C âŸ¨a, fâŸ©; dsimp
  intro a f f' ih'
  dsimp [wMk] at ih
  let ih'' := ih a (P.wPathDestLeft f') fun i => âŸ¨f i, P.wPathDestRight f' iâŸ©
  dsimp at ih''; rw [wPathCasesOn_eta] at ih''
  apply ih''
  apply ih'",error:  dsimp made no progress,"theorem w_ind {Î± : TypeVec n} {C : P.W Î± â†’ Prop}
    (ih : âˆ€ (a : P.A) (f' : P.drop.B a âŸ¹ Î±) (f : P.last.B a â†’ P.W Î±),
        (âˆ€ i, C (f i)) â†’ C (P.wMk a f' f)) :
    âˆ€ x, C x ",":= by
  intro x; cases' x with a f
  apply @wp_ind n P Î± fun a f => C âŸ¨a, fâŸ©
  intro a f f' ih'
  dsimp [wMk] at ih
  let ih'' := ih a (P.wPathDestLeft f') fun i => âŸ¨f i, P.wPathDestRight f' iâŸ©
  dsimp at ih''; rw [wPathCasesOn_eta] at ih''
  apply ih''
  apply ih'",induction' w_ind w_ind w_ind w_ind w_ind w_ind w_ind w_ind w_ind w_ind w_ind
Mathlib/Data/Nat/Log.lean,Nat.le_pow_iff_clog_le,le_pow_iff_clog_le,76620f7bc93be67fe98a87948024801e42a6f815,":= by
  induction' x using Nat.strong_induction_on with x ih generalizing y
  cases y
  Â· rw [pow_zero]
    refine' âŸ¨fun h => (clog_of_right_le_one h b).le, _âŸ©
    simp_rw [â† not_lt]
    contrapose!
    exact clog_pos hb
  have b_pos : 0 < b := (zero_lt_one' â„•).trans hb
  rw [clog]; split_ifs with h
  Â· rw [succ_eq_add_one, add_le_add_iff_right, â† ih ((x + b - 1) / b) (add_pred_div_lt hb h.2),
      Nat.div_le_iff_le_mul_add_pred b_pos, mul_comm b, â† Nat.pow_succ,
      add_tsub_assoc_of_le (Nat.succ_le_of_lt b_pos), add_le_add_iff_right]
  Â· exact iff_of_true ((not_lt.1 (not_and.1 h hb)).trans <| succ_le_of_lt <| pow_pos b_pos _)
      (zero_le _)","error:  unknown identifier 'pow_zero'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.20309
case h.zero
b : â„•
hb : 1 < b
x : â„•
ih : âˆ€ m < x, âˆ€ {y : â„•}, m â‰¤ b ^ y â†” clog b m â‰¤ y
âŠ¢ x â‰¤ b ^ 0 â†” clog b x â‰¤ 0
error:  unknown identifier 'zero_lt_one''
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case pos
b : â„•
hb : 1 < b
x : â„•
ih : âˆ€ m < x, âˆ€ {y : â„•}, m â‰¤ b ^ y â†” clog b m â‰¤ y
nâœ : â„•
b_pos : 0 < b
h : 1 < b âˆ§ 1 < x
âŠ¢ x â‰¤ b ^ (nâœ + 1) â†” clog b ((x + b - 1) / b) + 1 â‰¤ nâœ + 1
error:  unknown identifier 'pow_pos'",theorem le_pow_iff_clog_le {b : â„•} (hb : 1 < b) {x y : â„•} : x â‰¤ b ^ y â†” clog b x â‰¤ y ,":= by
  induction' x using Nat.strong_induction_on with x ih generalizing y
  cases y
  Â· rw [Nat.pow_zero]
    refine âŸ¨fun h => (clog_of_right_le_one h b).le, ?_âŸ©
    simp_rw [â† not_lt]
    contrapose!
    exact clog_pos hb
  have b_pos : 0 < b := zero_lt_of_lt hb
  rw [clog]; split_ifs with h
  Â· rw [Nat.add_le_add_iff_right, â† ih ((x + b - 1) / b) (add_pred_div_lt hb h.2),
      Nat.div_le_iff_le_mul_add_pred b_pos, Nat.mul_comm b, â† Nat.pow_succ,
      Nat.add_sub_assoc (Nat.succ_le_of_lt b_pos), Nat.add_le_add_iff_right]
  Â· exact iff_of_true ((not_lt.1 (not_and.1 h hb)).trans <| succ_le_of_lt <| Nat.pow_pos b_pos)
      (zero_le _)","refine âŸ¨fun h => ?_, fun h => ?_âŸ©"
Mathlib/Dynamics/OmegaLimit.lean,eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset,eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  let k := closure (image2 Ï• v s)
  have hk : IsCompact (k \ n) :=
    (hcâ‚.of_isClosed_subset isClosed_closure hvâ‚‚).diff hnâ‚
  let j u := (closure (image2 Ï• (u âˆ© v) s))á¶œ
  have hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u) := fun _ _ â†¦ isOpen_compl_iff.mpr isClosed_closure
  have hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u := by
    have : â‹ƒ u âˆˆ f, j u = â‹ƒ u : (â†¥f.sets), j u := biUnion_eq_iUnion _ _
    rw [this, diff_subset_comm, diff_iUnion]
    rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚] at hnâ‚‚
    simp_rw [j, diff_compl]
    rw [â† inter_iInter]
    exact Subset.trans (inter_subset_right _ _) hnâ‚‚
  rcases hk.elim_finite_subcover_image hjâ‚ hjâ‚‚ with âŸ¨g, hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f, hgâ‚‚, hgâ‚ƒâŸ©
  let w := (â‹‚ u âˆˆ g, u) âˆ© v
  have hwâ‚‚ : w âˆˆ f := by simpa [w, *]
  have hwâ‚ƒ : k \ n âŠ† (closure (image2 Ï• w s))á¶œ := by
    apply Subset.trans hgâ‚ƒ
    simp only [j, iUnion_subset_iff, compl_subset_compl]
    intros u hu
    mono
    refine' iInter_subset_of_subset u (iInter_subset_of_subset hu _)
    all_goals exact Subset.rfl
  have hwâ‚„ : ká¶œ âŠ† (closure (image2 Ï• w s))á¶œ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset (inter_subset_right _ _) Subset.rfl)
  have hnc : ná¶œ âŠ† k \ n âˆª ká¶œ := by rw [union_comm, â† inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 Ï• w s) âŠ† n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hwâ‚ƒ hwâ‚„))
  exact âŸ¨_, hwâ‚‚, hwâŸ©","warning:  @omegaLimit does not have a doc string
error:  function expected at
  inter_subset_right ?m.20994
term has type
  ?m.20993 âˆˆ ?m.20992
error:  function expected at
  inter_subset_right ?m.51646
term has type
  ?m.51645 âˆˆ ?m.51644","theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set Î²}
    (hcâ‚ : IsCompact c) (hcâ‚‚ : âˆƒ v âˆˆ f, closure (image2 Ï• v s) âŠ† c) {n : Set Î²} (hnâ‚ : IsOpen n)
    (hnâ‚‚ : Ï‰ f Ï• s âŠ† n) : âˆƒ u âˆˆ f, closure (image2 Ï• u s) âŠ† n ",":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  let k := closure (image2 Ï• v s)
  have hk : IsCompact (k \ n) :=
    (hcâ‚.of_isClosed_subset isClosed_closure hvâ‚‚).diff hnâ‚
  let j u := (closure (image2 Ï• (u âˆ© v) s))á¶œ
  have hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u) := fun _ _ â†¦ isOpen_compl_iff.mpr isClosed_closure
  have hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u := by
    have : â‹ƒ u âˆˆ f, j u = â‹ƒ u : (â†¥f.sets), j u := biUnion_eq_iUnion _ _
    rw [this, diff_subset_comm, diff_iUnion]
    rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚] at hnâ‚‚
    simp_rw [j, diff_compl]
    rw [â† inter_iInter]
    exact Subset.trans inter_subset_right hnâ‚‚
  rcases hk.elim_finite_subcover_image hjâ‚ hjâ‚‚ with âŸ¨g, hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f, hgâ‚‚, hgâ‚ƒâŸ©
  let w := (â‹‚ u âˆˆ g, u) âˆ© v
  have hwâ‚‚ : w âˆˆ f := by simpa [w, *]
  have hwâ‚ƒ : k \ n âŠ† (closure (image2 Ï• w s))á¶œ := by
    apply Subset.trans hgâ‚ƒ
    simp only [j, iUnion_subset_iff, compl_subset_compl]
    intros u hu
    mono
    refine iInter_subset_of_subset u (iInter_subset_of_subset hu ?_)
    all_goals exact Subset.rfl
  have hwâ‚„ : ká¶œ âŠ† (closure (image2 Ï• w s))á¶œ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset inter_subset_right Subset.rfl)
  have hnc : ná¶œ âŠ† k \ n âˆª ká¶œ := by rw [union_comm, â† inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 Ï• w s) âŠ† n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hwâ‚ƒ hwâ‚„))
  exact âŸ¨_, hwâ‚‚, hwâŸ©","rcases hcâ‚‚ with âŸ¨v, hv, hvâŸ©"
Mathlib/LinearAlgebra/AffineSpace/Independent.lean,AffineIndependent.affineIndependent_of_not_mem_span,AffineIndependent.affineIndependent_of_not_mem_span,141b72620243c872cad4ebe6d1abbfc83a8f9ece,":= by
  classical
    intro s w hw hs
    let s' : Finset { y // y â‰  i } := s.subtype (Â· â‰  i)
    let p' : { y // y â‰  i } â†’ P := fun x => p x
    by_cases his : i âˆˆ s âˆ§ w i â‰  0
    Â· refine' False.elim (hi _)
      let wm : Î¹ â†’ k := -(w i)â»Â¹ â€¢ w
      have hms : s.weightedVSub p wm = (0 : V) := by simp [hs]
      have hwm : âˆ‘ i in s, wm i = 0 := by simp [â† Finset.mul_sum, hw]
      have hwmi : wm i = -1 := by simp [his.2]
      let w' : { y // y â‰  i } â†’ k := fun x => wm x
      have hw' : âˆ‘ x in s', w' x = 1 := by
        simp_rw [Finset.sum_subtype_eq_sum_filter]
        rw [â† s.sum_filter_add_sum_filter_not (Â· â‰  i)] at hwm
        simp_rw [Classical.not_not] at hwm
        erw [Finset.filter_eq'] at hwm
        simp_rw [if_pos his.1, Finset.sum_singleton, hwmi, â† sub_eq_add_neg, sub_eq_zero] at hwm
        exact hwm
      rw [â† s.affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_one hms his.1 hwmi, â†
        (Subtype.range_coe : _ = { x | x â‰  i }), â† Set.range_comp, â†
        s.affineCombination_subtype_eq_filter]
      exact affineCombination_mem_affineSpan hw' p'
    Â· rw [not_and_or, Classical.not_not] at his
      let w' : { y // y â‰  i } â†’ k := fun x => w x
      have hw' : âˆ‘ x in s', w' x = 0 := by
        simp_rw [Finset.sum_subtype_eq_sum_filter]
        rw [Finset.sum_filter_of_ne, hw]
        rintro x hxs hwx rfl
        exact hwx (his.neg_resolve_left hxs)
      have hs' : s'.weightedVSub p' w' = (0 : V) := by
        simp_rw [Finset.weightedVSub_subtype_eq_filter]
        rw [Finset.weightedVSub_filter_of_ne, hs]
        rintro x hxs hwx rfl
        exact hwx (his.neg_resolve_left hxs)
      intro j hj
      by_cases hji : j = i
      Â· rw [hji] at hj
        exact hji.symm â–¸ his.neg_resolve_left hj
      Â· exact ha s' w' hw' hs' âŸ¨j, hjiâŸ© (Finset.mem_subtype.2 hj)","error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress","theorem AffineIndependent.affineIndependent_of_not_mem_span {p : Î¹ â†’ P} {i : Î¹}
    (ha : AffineIndependent k fun x : { y // y â‰  i } => p x)
    (hi : p i âˆ‰ affineSpan k (p '' { x | x â‰  i })) : AffineIndependent k p ",":= by
  classical
    intro s w hw hs
    let s' : Finset { y // y â‰  i } := s.subtype (Â· â‰  i)
    let p' : { y // y â‰  i } â†’ P := fun x => p x
    by_cases his : i âˆˆ s âˆ§ w i â‰  0
    Â· refine False.elim (hi ?_)
      let wm : Î¹ â†’ k := -(w i)â»Â¹ â€¢ w
      have hms : s.weightedVSub p wm = (0 : V) := by simp [wm, hs]
      have hwm : âˆ‘ i âˆˆ s, wm i = 0 := by simp [wm, â† Finset.mul_sum, hw]
      have hwmi : wm i = -1 := by simp [wm, his.2]
      let w' : { y // y â‰  i } â†’ k := fun x => wm x
      have hw' : âˆ‘ x âˆˆ s', w' x = 1 := by
        simp_rw [w', s', Finset.sum_subtype_eq_sum_filter]
        rw [â† s.sum_filter_add_sum_filter_not (Â· â‰  i)] at hwm
        simp_rw [Classical.not_not] at hwm
        erw [Finset.filter_eq'] at hwm
        simp_rw [if_pos his.1, Finset.sum_singleton, hwmi, â† sub_eq_add_neg, sub_eq_zero] at hwm
        exact hwm
      rw [â† s.affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_one hms his.1 hwmi, â†
        (Subtype.range_coe : _ = { x | x â‰  i }), â† Set.range_comp, â†
        s.affineCombination_subtype_eq_filter]
      exact affineCombination_mem_affineSpan hw' p'
    Â· rw [not_and_or, Classical.not_not] at his
      let w' : { y // y â‰  i } â†’ k := fun x => w x
      have hw' : âˆ‘ x âˆˆ s', w' x = 0 := by
        simp_rw [w', s', Finset.sum_subtype_eq_sum_filter]
        rw [Finset.sum_filter_of_ne, hw]
        rintro x hxs hwx rfl
        exact hwx (his.neg_resolve_left hxs)
      have hs' : s'.weightedVSub p' w' = (0 : V) := by
        simp_rw [w', s', p', Finset.weightedVSub_subtype_eq_filter]
        rw [Finset.weightedVSub_filter_of_ne, hs]
        rintro x hxs hwx rfl
        exact hwx (his.neg_resolve_left hxs)
      intro j hj
      by_cases hji : j = i
      Â· rw [hji] at hj
        exact hji.symm â–¸ his.neg_resolve_left hj
      Â· exact ha s' w' hw' hs' âŸ¨j, hjiâŸ© (Finset.mem_subtype.2 hj)","simp only [AffineIndependent, AffineIndependent.affineIndependent_affineIndependent_of_not_mem_span,
  AffineIndependent.affineIndependent_affineIndependent_affineIndependent_of_not_mem_span,
  AffineIndependent.affineIndependent_affineIndependent_affineIndependent_of_not_mem_span,
  AffineIndependent.affineIndependent_affineIndependent_affineIndependent_of_not_mem_span,
  AffineIndependent.affineIndependent_affineIndependent_affineIndependent_affineIndependent_affineIndependent_affineIndependent_affineIndependent_of_not_mem_span]"
Mathlib/Probability/Independence/Kernel.lean,ProbabilityTheory.kernel.IndepFun.ae_eq,IndepFun.ae_eq,ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  rintro _ _ âŸ¨A, hA, rflâŸ© âŸ¨B, hB, rflâŸ©
  filter_upwards [hf, hg, hfg _ _ âŸ¨_, hA, rflâŸ© âŸ¨_, hB, rflâŸ©] with a hf' hg' hfg'
  have h1 : f â»Â¹' A |>.toPred =áµ[Îº a] (f' â»Â¹' A).toPred := sorry 
  have h2 : g â»Â¹' B |>.toPred =áµ[Îº a] (g' â»Â¹' B).toPred := sorry 
  rwa [â† measure_congr h1, â† measure_congr h2, â† measure_congr (h1.inter h2)]","error:  invalid field 'toPred', the environment does not contain 'Set.toPred'
  f â»Â¹' A
has type
  Set Î©
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  f â»Â¹' A
has type
  Î© â†’ Prop
error:  invalid field 'toPred', the environment does not contain 'Set.toPred'
  f' â»Â¹' A
has type
  Set Î©
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  f' â»Â¹' A
has type
  Î© â†’ Prop
error:  unsolved goals
case h
Î± : Type u_1
Î© : Type u_2
Î¹ : Type u_3
Î² : Type u_4
Î²' : Type u_5
Î³ : Type u_6
Î³' : Type u_7
_mÎ± : MeasurableSpace Î±
_mÎ© : MeasurableSpace Î©
Îº : â†¥(kernel Î± Î©)
Î¼ : Measure Î±
f : Î© â†’ Î²
g : Î© â†’ Î²'
mÎ² : MeasurableSpace Î²
mÎ²' : MeasurableSpace Î²'
f' : Î© â†’ Î²
g' : Î© â†’ Î²'
hfg : IndepFun f g Îº Î¼
hf : âˆ€áµ (a : Î±) âˆ‚Î¼, f =á¶ [ae (Îº a)] f'
hg : âˆ€áµ (a : Î±) âˆ‚Î¼, g =á¶ [ae (Îº a)] g'
A : Set Î²
hA : MeasurableSet A
B : Set Î²'
hB : MeasurableSet B
a : Î±
hf' : f =á¶ [ae (Îº a)] f'
hg' : g =á¶ [ae (Îº a)] g'
hfg' : (Îº a) (f â»Â¹' A âˆ© g â»Â¹' B) = (Îº a) (f â»Â¹' A) * (Îº a) (g â»Â¹' B)
âŠ¢ (Îº a) (f' â»Â¹' A âˆ© g' â»Â¹' B) = (Îº a) (f' â»Â¹' A) * (Îº a) (g' â»Â¹' B)","theorem IndepFun.ae_eq {mÎ² : MeasurableSpace Î²} {mÎ²' : MeasurableSpace Î²'}
    {f' : Î© â†’ Î²} {g' : Î© â†’ Î²'} (hfg : IndepFun f g Îº Î¼)
    (hf : âˆ€áµ a âˆ‚Î¼, f =áµ[Îº a] f') (hg : âˆ€áµ a âˆ‚Î¼, g =áµ[Îº a] g') :
    IndepFun f' g' Îº Î¼ ",":= by
  rintro _ _ âŸ¨A, hA, rflâŸ© âŸ¨B, hB, rflâŸ©
  filter_upwards [hf, hg, hfg _ _ âŸ¨_, hA, rflâŸ© âŸ¨_, hB, rflâŸ©] with a hf' hg' hfg'
  have h1 : f â»Â¹' A =áµ[Îº a] f' â»Â¹' A := hf'.fun_comp A
  have h2 : g â»Â¹' B =áµ[Îº a] g' â»Â¹' B := hg'.fun_comp B
  rwa [â† measure_congr h1, â† measure_congr h2, â† measure_congr (h1.inter h2)]",refine IndepFun.indepFun_theorem_ae_eq IndepFun.ae_eq ?_ ?_ ?_
Mathlib/Combinatorics/SetFamily/HarrisKleitman.lean,IsLowerSet.le_card_inter_finset,IsLowerSet.le_card_inter_finset,2b42dc7c3f9ebf6e7f17bff850d9c0bc3f1cf75e,":= by
  induction' s using Finset.induction with a s hs ih generalizing ğ’œ â„¬
  Â· simp_rw [subset_empty, â† subset_singleton_iff', subset_singleton_iff] at hğ’œs hâ„¬s
    obtain rfl | rfl := hğ’œs
    Â· simp only [card_empty, empty_inter, mul_zero, zero_mul]
    obtain rfl | rfl := hâ„¬s
    Â· simp only [card_empty, inter_empty, mul_zero, zero_mul]
    Â· simp only [card_empty, pow_zero, inter_singleton_of_mem, mem_singleton, card_singleton]
  rw [card_insert_of_not_mem hs, â† card_memberSubfamily_add_card_nonMemberSubfamily a ğ’œ, â†
    card_memberSubfamily_add_card_nonMemberSubfamily a â„¬, add_mul, mul_add, mul_add,
    add_comm (_ * _), add_add_add_comm]
  refine'
    (add_le_add_right
          (mul_add_mul_le_mul_add_mul
              (card_le_of_subset hğ’œ.memberSubfamily_subset_nonMemberSubfamily) <|
            card_le_of_subset hâ„¬.memberSubfamily_subset_nonMemberSubfamily)
          _).trans
      _
  rw [â† two_mul, pow_succ, mul_assoc]
  have hâ‚€ :
    âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’ âˆ€ t âˆˆ ğ’.nonMemberSubfamily a, t âŠ† s :=
    by
    rintro ğ’ hğ’ t ht
    rw [mem_nonMemberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 (hğ’ _ ht.1)
  have hâ‚ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’ âˆ€ t âˆˆ ğ’.memberSubfamily a, t âŠ† s
    :=
    by
    rintro ğ’ hğ’ t ht
    rw [mem_memberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 ((subset_insert _ _).trans <| hğ’ _ ht.1)
  refine' mul_le_mul_left' _ _
  refine'
    (add_le_add (ih hğ’œ.memberSubfamily hâ„¬.memberSubfamily (hâ‚ _ hğ’œs) <| hâ‚ _ hâ„¬s) <|
          ih hğ’œ.nonMemberSubfamily hâ„¬.nonMemberSubfamily (hâ‚€ _ hğ’œs) <| hâ‚€ _ hâ„¬s).trans_eq
      _
  rw [â† mul_add, â† memberSubfamily_inter, â† nonMemberSubfamily_inter,
    card_memberSubfamily_add_card_nonMemberSubfamily]","error:  unsolved goals
case empty.inl
Î± : Type u_1
instâœ : DecidableEq Î±
a : Î±
â„¬ : Finset (Finset Î±)
hâ„¬ : IsLowerSet â†‘â„¬
hâ„¬s : â„¬ = âˆ… âˆ¨ â„¬ = {âˆ…}
hğ’œ : IsLowerSet â†‘âˆ…
âŠ¢ 0 â‰¤ 0
error:  unsolved goals
case empty.inr.inl
Î± : Type u_1
instâœ : DecidableEq Î±
a : Î±
hğ’œ : IsLowerSet â†‘{âˆ…}
hâ„¬ : IsLowerSet â†‘âˆ…
âŠ¢ 0 â‰¤ 0
error:  unsolved goals
case empty.inr.inr
Î± : Type u_1
instâœ : DecidableEq Î±
a : Î±
hğ’œ hâ„¬ : IsLowerSet â†‘{âˆ…}
âŠ¢ 1 * 1 â‰¤ 1 * 1
warning:  `Finset.card_le_of_subset` has been deprecated, use `Finset.card_le_card` instead
warning:  `Finset.card_le_of_subset` has been deprecated, use `Finset.card_le_card` instead
error:  type mismatch
  mul_le_mul_left' ?m.7430 ?m.7431
has type
  ?m.7431 * ?m.7428 â‰¤ ?m.7431 * ?m.7429 : Prop
but is expected to have type
  2 *
      ((Finset.memberSubfamily a ğ’œ).card * (Finset.memberSubfamily a â„¬).card +
        (Finset.nonMemberSubfamily a ğ’œ).card * (Finset.nonMemberSubfamily a â„¬).card) â‰¤
    2 ^ s.card * (2 * (ğ’œ âˆ© â„¬).card) : Prop","theorem IsLowerSet.le_card_inter_finset' (hğ’œ : IsLowerSet (ğ’œ : Set (Finset Î±)))
    (hâ„¬ : IsLowerSet (â„¬ : Set (Finset Î±))) (hğ’œs : âˆ€ t âˆˆ ğ’œ, t âŠ† s) (hâ„¬s : âˆ€ t âˆˆ â„¬, t âŠ† s) :
    ğ’œ.card * â„¬.card â‰¤ 2 ^ s.card * (ğ’œ âˆ© â„¬).card ",":= by
  induction' s using Finset.induction with a s hs ih generalizing ğ’œ â„¬
  Â· simp_rw [subset_empty, â† subset_singleton_iff', subset_singleton_iff] at hğ’œs hâ„¬s
    obtain rfl | rfl := hğ’œs
    Â· simp only [card_empty, zero_mul, empty_inter, mul_zero, le_refl]
    obtain rfl | rfl := hâ„¬s
    Â· simp only [card_empty, inter_empty, mul_zero, zero_mul, le_refl]
    Â· simp only [card_empty, pow_zero, inter_singleton_of_mem, mem_singleton, card_singleton,
        le_refl]
  rw [card_insert_of_not_mem hs, â† card_memberSubfamily_add_card_nonMemberSubfamily a ğ’œ, â†
    card_memberSubfamily_add_card_nonMemberSubfamily a â„¬, add_mul, mul_add, mul_add,
    add_comm (_ * _), add_add_add_comm]
  refine
    (add_le_add_right
          (mul_add_mul_le_mul_add_mul
              (card_le_card hğ’œ.memberSubfamily_subset_nonMemberSubfamily) <|
            card_le_card hâ„¬.memberSubfamily_subset_nonMemberSubfamily)
          _).trans
      ?_
  rw [â† two_mul, pow_succ', mul_assoc]
  have hâ‚€ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’
      âˆ€ t âˆˆ ğ’.nonMemberSubfamily a, t âŠ† s := by
    rintro ğ’ hğ’ t ht
    rw [mem_nonMemberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 (hğ’ _ ht.1)
  have hâ‚ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’
      âˆ€ t âˆˆ ğ’.memberSubfamily a, t âŠ† s := by
    rintro ğ’ hğ’ t ht
    rw [mem_memberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 ((subset_insert _ _).trans <| hğ’ _ ht.1)
  refine mul_le_mul_left' ?_ _
  refine (add_le_add (ih hğ’œ.memberSubfamily hâ„¬.memberSubfamily (hâ‚ _ hğ’œs) <| hâ‚ _ hâ„¬s) <|
    ih hğ’œ.nonMemberSubfamily hâ„¬.nonMemberSubfamily (hâ‚€ _ hğ’œs) <| hâ‚€ _ hâ„¬s).trans_eq ?_
  rw [â† mul_add, â† memberSubfamily_inter, â† nonMemberSubfamily_inter,
    card_memberSubfamily_add_card_nonMemberSubfamily]",refine theorem_theorem_eq_card_theorem IsLowerSet.le_card_theorem IsLowerSet.le_card_theorem IsLowerSet.le_card_theorem
Mathlib/MeasureTheory/Integral/FundThmCalculus.lean,intervalIntegral.sub_le_integral_of_hasDeriv_right_of_le_Ico,sub_le_integral_of_hasDeriv_right_of_le_Ico,9d12b609274b44fc79ae79f9347cf8a3782b6a95,":= by
  refine' le_of_forall_pos_le_add fun Îµ Îµpos => _
  rcases exists_lt_lowerSemicontinuous_integral_lt Ï† Ï†int Îµpos with
    âŸ¨G', f_lt_G', G'cont, G'int, G'lt_top, hG'âŸ©
  set s := {t | g t - g a â‰¤ âˆ« u in a..t, (G' u).toReal} âˆ© Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, âˆ« u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [â† uIcc_of_le hab] at G'int hcont âŠ¢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [s, inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b âŠ† {t | g t - g a â‰¤ âˆ« u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain âŸ¨y, g'_lt_y', y_lt_G'âŸ© : âˆƒ y : â„, (g' t : EReal) < y âˆ§ (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hÏ†g t ht.2)).trans_lt (f_lt_G' t))
    have I1 : âˆ€á¶  u in ğ“[>] t, (u - t) * y â‰¤ âˆ« w in t..u, (G' w).toReal := by
      have B : âˆ€á¶  u in ğ“ t, (y : EReal) < G' u := G'cont.eventually_lt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with âŸ¨m, M, âŸ¨hm, hMâŸ©, HâŸ©
      have : Ioo t (min M b) âˆˆ ğ“[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u âŠ† Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = âˆ« _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ â‰¤ âˆ« w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, â† integral_Icc_eq_integral_Ioc]
          apply set_integral_mono_ae_restrict
          Â· simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          Â· exact IntegrableOn.mono_set G'int I
          Â· have C1 : âˆ€áµ x : â„ âˆ‚volume.restrict (Icc t u), G' x < âˆ :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : âˆ€áµ x : â„ âˆ‚volume.restrict (Icc t u), x âˆˆ Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x âˆˆ Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : âˆ€á¶  u in ğ“[>] t, g u - g t â‰¤ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t âŸ¨ht.2.1, ht.2.2âŸ©).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [â† smul_eq_mul, sub_smul_slope] at this
    have I3 : âˆ€á¶  u in ğ“[>] t, g u - g t â‰¤ âˆ« w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : âˆ€á¶  u in ğ“[>] t, u âˆˆ Ioc t (min v b) := by
      refine' mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 âŸ¨min v b, _, Subset.rflâŸ©
      simp only [lt_min_iff, mem_Ioi]
      exact âŸ¨t_lt_v, ht.2.2âŸ©
    rcases (I3.and I4).exists with âŸ¨x, hx, h'xâŸ©
    refine' âŸ¨x, _, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'xâŸ©
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ â‰¤ (âˆ« w in a..t, (G' w).toReal) + âˆ« w in t..x, (G' w).toReal := (add_le_add ht.1 hx)
      _ = âˆ« w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        Â· rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        Â· rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a â‰¤ âˆ« y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ â‰¤ (âˆ« y in a..b, Ï† y) + Îµ := by
      convert hG'.le <;>
        Â· rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]","error:  invalid field 'eventually_lt', the environment does not contain 'LowerSemicontinuous.eventually_lt'
  G'cont
has type
  LowerSemicontinuous G'
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  G'cont
has type
  âˆ€ (x : â„), LowerSemicontinuousAt G' x
warning:  `MeasureTheory.set_integral_mono_ae_restrict` has been deprecated, use `MeasureTheory.setIntegral_mono_ae_restrict` instead","theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a â‰¤ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : âˆ€ x âˆˆ Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (Ï†int : IntegrableOn Ï† (Icc a b)) (hÏ†g : âˆ€ x âˆˆ Ico a b, g' x â‰¤ Ï† x) :
    g b - g a â‰¤ âˆ« y in a..b, Ï† y ",":= by
  refine le_of_forall_pos_le_add fun Îµ Îµpos => ?_
  rcases exists_lt_lowerSemicontinuous_integral_lt Ï† Ï†int Îµpos with
    âŸ¨G', f_lt_G', G'cont, G'int, G'lt_top, hG'âŸ©
  set s := {t | g t - g a â‰¤ âˆ« u in a..t, (G' u).toReal} âˆ© Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, âˆ« u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [â† uIcc_of_le hab] at G'int hcont âŠ¢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [s, inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b âŠ† {t | g t - g a â‰¤ âˆ« u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain âŸ¨y, g'_lt_y', y_lt_G'âŸ© : âˆƒ y : â„, (g' t : EReal) < y âˆ§ (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hÏ†g t ht.2)).trans_lt (f_lt_G' t))
    have I1 : âˆ€á¶  u in ğ“[>] t, (u - t) * y â‰¤ âˆ« w in t..u, (G' w).toReal := by
      have B : âˆ€á¶  u in ğ“ t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with âŸ¨m, M, âŸ¨hm, hMâŸ©, HâŸ©
      have : Ioo t (min M b) âˆˆ ğ“[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u âŠ† Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = âˆ« _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ â‰¤ âˆ« w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, â† integral_Icc_eq_integral_Ioc]
          apply setIntegral_mono_ae_restrict
          Â· simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          Â· exact IntegrableOn.mono_set G'int I
          Â· have C1 : âˆ€áµ x : â„ âˆ‚volume.restrict (Icc t u), G' x < âˆ :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : âˆ€áµ x : â„ âˆ‚volume.restrict (Icc t u), x âˆˆ Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x âˆˆ Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : âˆ€á¶  u in ğ“[>] t, g u - g t â‰¤ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t âŸ¨ht.2.1, ht.2.2âŸ©).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [â† smul_eq_mul, sub_smul_slope] at this
    have I3 : âˆ€á¶  u in ğ“[>] t, g u - g t â‰¤ âˆ« w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : âˆ€á¶  u in ğ“[>] t, u âˆˆ Ioc t (min v b) := by
      refine mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 âŸ¨min v b, ?_, Subset.rflâŸ©
      simp only [lt_min_iff, mem_Ioi]
      exact âŸ¨t_lt_v, ht.2.2âŸ©
    rcases (I3.and I4).exists with âŸ¨x, hx, h'xâŸ©
    refine âŸ¨x, ?_, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'xâŸ©
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ â‰¤ (âˆ« w in a..t, (G' w).toReal) + âˆ« w in t..x, (G' w).toReal := add_le_add ht.1 hx
      _ = âˆ« w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        Â· rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        Â· rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a â‰¤ âˆ« y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ â‰¤ (âˆ« y in a..b, Ï† y) + Îµ := by
      convert hG'.le <;>
        Â· rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]","have : âˆ€ x âˆˆ Ico a b, HasDerivWithinAt Ï† (Icc a b) Ï†int Ï†int Ï†int Ï†int Ï†int Ï†int Ï†int Ï†int Ï†int Ï†int"
Mathlib/SetTheory/Ordinal/Principal.lean,Ordinal.nfp_le_of_principal,nfp_le_of_principal,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  nfp_le fun n => (ho.iterate_lt hao n).le",error:  unknown identifier 'principal_nfp_blsubâ‚‚',"theorem nfp_le_of_principal {op : Ordinal â†’ Ordinal â†’ Ordinal} {a o : Ordinal} (hao : a < o)
    (ho : Principal op o) : nfp (op a) a â‰¤ o ",":=
  nfp_le fun n => (ho.iterate_lt hao n).le",rw [theorem] at ho
Mathlib/Data/Nat/Log.lean,Nat.le_pow_iff_clog_le,le_pow_iff_clog_le,1cffcd2031c393e756890a35b29ac8a99ee75725,":= by
  induction' x using Nat.strong_induction_on with x ih generalizing y
  cases y
  Â· rw [pow_zero]
    refine' âŸ¨fun h => (clog_of_right_le_one h b).le, _âŸ©
    simp_rw [â† not_lt]
    contrapose!
    exact clog_pos hb
  have b_pos : 0 < b := (zero_lt_one' â„•).trans hb
  rw [clog]; split_ifs with h
  Â· rw [add_le_add_iff_right, â† ih ((x + b - 1) / b) (add_pred_div_lt hb h.2),
      Nat.div_le_iff_le_mul_add_pred b_pos, mul_comm b, â† pow_succ,
      add_tsub_assoc_of_le (Nat.succ_le_of_lt b_pos), add_le_add_iff_right]
  Â· exact iff_of_true ((not_lt.1 (not_and.1 h hb)).trans <| succ_le_of_lt <| pow_pos b_pos _)
      (zero_le _)","error:  unknown identifier 'pow_zero'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.20309
case h.zero
b : â„•
hb : 1 < b
x : â„•
ih : âˆ€ m < x, âˆ€ {y : â„•}, m â‰¤ b ^ y â†” clog b m â‰¤ y
âŠ¢ x â‰¤ b ^ 0 â†” clog b x â‰¤ 0
error:  unknown identifier 'zero_lt_one''
error:  unknown identifier 'add_le_add_iff_right'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.20775
case pos
b : â„•
hb : 1 < b
x : â„•
ih : âˆ€ m < x, âˆ€ {y : â„•}, m â‰¤ b ^ y â†” clog b m â‰¤ y
nâœ : â„•
b_pos : 0 < b
h : 1 < b âˆ§ 1 < x
âŠ¢ x â‰¤ b ^ (nâœ + 1) â†” clog b ((x + b - 1) / b) + 1 â‰¤ nâœ + 1
error:  unknown identifier 'pow_pos'",theorem le_pow_iff_clog_le {b : â„•} (hb : 1 < b) {x y : â„•} : x â‰¤ b ^ y â†” clog b x â‰¤ y ,":= by
  induction' x using Nat.strong_induction_on with x ih generalizing y
  cases y
  Â· rw [Nat.pow_zero]
    refine âŸ¨fun h => (clog_of_right_le_one h b).le, ?_âŸ©
    simp_rw [â† not_lt]
    contrapose!
    exact clog_pos hb
  have b_pos : 0 < b := zero_lt_of_lt hb
  rw [clog]; split_ifs with h
  Â· rw [Nat.add_le_add_iff_right, â† ih ((x + b - 1) / b) (add_pred_div_lt hb h.2),
      Nat.div_le_iff_le_mul_add_pred b_pos, Nat.mul_comm b, â† Nat.pow_succ,
      Nat.add_sub_assoc (Nat.succ_le_of_lt b_pos), Nat.add_le_add_iff_right]
  Â· exact iff_of_true ((not_lt.1 (not_and.1 h hb)).trans <| succ_le_of_lt <| Nat.pow_pos b_pos)
      (zero_le _)","refine âŸ¨fun h => ?_, fun h => ?_âŸ©"
Mathlib/MeasureTheory/Measure/Haar/Disintegration.lean,LinearMap.exists_map_addHaar_eq_smul_addHaar,LinearMap.exists_map_addHaar_eq_smul_addHaar,c47ebbbece0d449dca95c589513159cdc2bab40d,":= by
  have : ProperSpace E := properSpace_of_locallyCompactSpace ğ•œ
  have : FiniteDimensional ğ•œ E := finiteDimensional_of_locallyCompactSpace ğ•œ
  have : ProperSpace F := by
    rcases subsingleton_or_nontrivial E with hE|hE
    Â· have : Subsingleton F := Function.Surjective.subsingleton h
      infer_instance
    Â· have : ProperSpace ğ•œ := properSpace_of_locallyCompact_module ğ•œ E
      have : FiniteDimensional ğ•œ F := Module.Finite.of_surjective L h
      exact FiniteDimensional.proper ğ•œ F
  let S : Submodule ğ•œ E := LinearMap.ker L
  obtain âŸ¨T, hTâŸ© : âˆƒ T : Submodule ğ•œ E, IsCompl S T := Submodule.exists_isCompl S
  let M : (S Ã— T) â‰ƒâ‚—[ğ•œ] E := Submodule.prodEquivOfIsCompl S T hT
  have M_cont : Continuous M.symm := LinearMap.continuous_of_finiteDimensional _
  let P : S Ã— T â†’â‚—[ğ•œ] T := LinearMap.snd ğ•œ S T
  have P_cont : Continuous P := LinearMap.continuous_of_finiteDimensional _
  have I : Function.Bijective (LinearMap.domRestrict L T) :=
    âŸ¨LinearMap.injective_domRestrict_iff.2 (IsCompl.inf_eq_bot hT.symm),
    (LinearMap.surjective_domRestrict_iff h).2 hT.symm.sup_eq_topâŸ©
  let L' : T â‰ƒâ‚—[ğ•œ] F := LinearEquiv.ofBijective (LinearMap.domRestrict L T) I
  have L'_cont : Continuous L' := LinearMap.continuous_of_finiteDimensional _
  have A : L = (L' : T â†’â‚—[ğ•œ] F).comp (P.comp (M.symm : E â†’â‚—[ğ•œ] (S Ã— T))) := by
    ext x
    obtain âŸ¨y, z, hyzâŸ© : âˆƒ (y : S) (z : T), M.symm x = (y, z) := âŸ¨_, _, rflâŸ©
    have : x = M (y, z) := by
      rw [â† hyz]; simp only [LinearEquiv.apply_symm_apply]
    simp [this]
  have I : Î¼.map L = ((Î¼.map M.symm).map P).map L' := by
    rw [Measure.map_map, Measure.map_map, A]
    Â· rfl
    Â· exact L'_cont.measurable.comp P_cont.measurable
    Â· exact M_cont.measurable
    Â· exact L'_cont.measurable
    Â· exact P_cont.measurable
  let Î¼S : Measure S := addHaar
  let Î¼T : Measure T := addHaar
  obtain âŸ¨câ‚€, câ‚€_pos, câ‚€_fin, hâ‚€âŸ© :
      âˆƒ câ‚€ : â„â‰¥0âˆ, câ‚€ â‰  0 âˆ§ câ‚€ â‰  âˆ âˆ§ Î¼.map M.symm = câ‚€ â€¢ Î¼S.prod Î¼T := by
    have : IsAddHaarMeasure (Î¼.map M.symm) :=
      M.toContinuousLinearEquiv.symm.isAddHaarMeasure_map Î¼
    exact isAddHaarMeasure_eq_smul _ _
  have J : (Î¼S.prod Î¼T).map P = (Î¼S univ) â€¢ Î¼T := map_snd_prod
  obtain âŸ¨câ‚, câ‚_pos, câ‚_fin, hâ‚âŸ© : âˆƒ câ‚ : â„â‰¥0âˆ, câ‚ â‰  0 âˆ§ câ‚ â‰  âˆ âˆ§ Î¼T.map L' = câ‚ â€¢ Î½ := by
    have : IsAddHaarMeasure (Î¼T.map L') :=
      L'.toContinuousLinearEquiv.isAddHaarMeasure_map Î¼T
    exact isAddHaarMeasure_eq_smul _ _
  refine âŸ¨câ‚€ * câ‚, by simp [pos_iff_ne_zero, câ‚€_pos, câ‚_pos], ENNReal.mul_lt_top câ‚€_fin câ‚_fin, ?_âŸ©
  simp only [I, hâ‚€, Measure.map_smul, J, smul_smul, hâ‚]
  rw [mul_assoc, mul_comm _ câ‚, â† mul_assoc]","warning:  `properSpace_of_locallyCompactSpace` has been deprecated, use `ProperSpace.of_locallyCompactSpace` instead
warning:  `finiteDimensional_of_locallyCompactSpace` has been deprecated, use `FiniteDimensional.of_locallyCompactSpace` instead
warning:  `properSpace_of_locallyCompact_module` has been deprecated, use `ProperSpace.of_locallyCompact_module` instead
error:  unsolved goals
case h.intro.intro
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœÂ¹Â² : NontriviallyNormedField ğ•œ
instâœÂ¹Â¹ : CompleteSpace ğ•œ
instâœÂ¹â° : NormedAddCommGroup E
instâœâ¹ : MeasurableSpace E
instâœâ¸ : BorelSpace E
instâœâ· : NormedSpace ğ•œ E
instâœâ¶ : NormedAddCommGroup F
instâœâµ : MeasurableSpace F
instâœâ´ : BorelSpace F
instâœÂ³ : NormedSpace ğ•œ F
L : E â†’â‚—[ğ•œ] F
Î¼ : Measure E
Î½ : Measure F
instâœÂ² : Î¼.IsAddHaarMeasure
instâœÂ¹ : Î½.IsAddHaarMeasure
instâœ : LocallyCompactSpace E
h : Function.Surjective â‡‘L
thisâœÂ² : ProperSpace E
thisâœÂ¹ : FiniteDimensional ğ•œ E
thisâœ : ProperSpace F
S : Submodule ğ•œ E := ker L
T : Submodule ğ•œ E
hT : IsCompl S T
M : (â†¥S Ã— â†¥T) â‰ƒâ‚—[ğ•œ] E := S.prodEquivOfIsCompl T hT
M_cont : Continuous â‡‘M.symm
P : â†¥S Ã— â†¥T â†’â‚—[ğ•œ] â†¥T := snd ğ•œ â†¥S â†¥T
P_cont : Continuous â‡‘P
I : Function.Bijective â‡‘(L.domRestrict T)
L' : â†¥T â‰ƒâ‚—[ğ•œ] F := LinearEquiv.ofBijective (L.domRestrict T) I
L'_cont : Continuous â‡‘L'
x : E
y : â†¥S
z : â†¥T
hyz : M.symm x = (y, z)
this : x = M (y, z)
âŠ¢ L (M (y, z)) = L' (P (y, z))
warning:  `MeasureTheory.Measure.isAddHaarMeasure_eq_smul` has been deprecated, use `MeasureTheory.Measure.isAddLeftInvariant_eq_smul` instead
error:  type mismatch
  isAddHaarMeasure_eq_smul ?m.76383 ?m.76384
has type
  ?m.76383 = ?m.76383.addHaarScalarFactor ?m.76384 â€¢ ?m.76384 : Prop
but is expected to have type
  âˆƒ câ‚€, câ‚€ â‰  0 âˆ§ câ‚€ â‰  âŠ¤ âˆ§ map (â‡‘M.symm) Î¼ = câ‚€ â€¢ Î¼S.prod Î¼T : Prop
warning:  `MeasureTheory.Measure.isAddHaarMeasure_eq_smul` has been deprecated, use `MeasureTheory.Measure.isAddLeftInvariant_eq_smul` instead
error:  type mismatch
  isAddHaarMeasure_eq_smul ?m.80155 ?m.80156
has type
  ?m.80155 = ?m.80155.addHaarScalarFactor ?m.80156 â€¢ ?m.80156 : Prop
but is expected to have type
  âˆƒ câ‚, câ‚ â‰  0 âˆ§ câ‚ â‰  âŠ¤ âˆ§ map (â‡‘L') Î¼T = câ‚ â€¢ Î½ : Prop","theorem LinearMap.exists_map_addHaar_eq_smul_addHaar' (h : Function.Surjective L) :
    âˆƒ (c : â„â‰¥0âˆ), 0 < c âˆ§ c < âˆ âˆ§ Î¼.map L = (c * addHaar (univ : Set (LinearMap.ker L))) â€¢ Î½ ",":= by
  have : ProperSpace E := .of_locallyCompactSpace ğ•œ
  have : FiniteDimensional ğ•œ E := .of_locallyCompactSpace ğ•œ
  have : ProperSpace F := by
    rcases subsingleton_or_nontrivial E with hE|hE
    Â· have : Subsingleton F := Function.Surjective.subsingleton h
      infer_instance
    Â· have : ProperSpace ğ•œ := .of_locallyCompact_module ğ•œ E
      have : FiniteDimensional ğ•œ F := Module.Finite.of_surjective L h
      exact FiniteDimensional.proper ğ•œ F
  let S : Submodule ğ•œ E := LinearMap.ker L
  obtain âŸ¨T, hTâŸ© : âˆƒ T : Submodule ğ•œ E, IsCompl S T := Submodule.exists_isCompl S
  let M : (S Ã— T) â‰ƒâ‚—[ğ•œ] E := Submodule.prodEquivOfIsCompl S T hT
  have M_cont : Continuous M.symm := LinearMap.continuous_of_finiteDimensional _
  let P : S Ã— T â†’â‚—[ğ•œ] T := LinearMap.snd ğ•œ S T
  have P_cont : Continuous P := LinearMap.continuous_of_finiteDimensional _
  have I : Function.Bijective (LinearMap.domRestrict L T) :=
    âŸ¨LinearMap.injective_domRestrict_iff.2 (IsCompl.inf_eq_bot hT.symm),
    (LinearMap.surjective_domRestrict_iff h).2 hT.symm.sup_eq_topâŸ©
  let L' : T â‰ƒâ‚—[ğ•œ] F := LinearEquiv.ofBijective (LinearMap.domRestrict L T) I
  have L'_cont : Continuous L' := LinearMap.continuous_of_finiteDimensional _
  have A : L = (L' : T â†’â‚—[ğ•œ] F).comp (P.comp (M.symm : E â†’â‚—[ğ•œ] (S Ã— T))) := by
    ext x
    obtain âŸ¨y, z, hyzâŸ© : âˆƒ (y : S) (z : T), M.symm x = (y, z) := âŸ¨_, _, rflâŸ©
    have : x = M (y, z) := by
      rw [â† hyz]; simp only [LinearEquiv.apply_symm_apply]
    simp [L', P, M, this]
  have I : Î¼.map L = ((Î¼.map M.symm).map P).map L' := by
    rw [Measure.map_map, Measure.map_map, A]
    Â· rfl
    Â· exact L'_cont.measurable.comp P_cont.measurable
    Â· exact M_cont.measurable
    Â· exact L'_cont.measurable
    Â· exact P_cont.measurable
  let Î¼S : Measure S := addHaar
  let Î¼T : Measure T := addHaar
  obtain âŸ¨câ‚€, câ‚€_pos, câ‚€_fin, hâ‚€âŸ© :
      âˆƒ câ‚€ : â„â‰¥0âˆ, câ‚€ â‰  0 âˆ§ câ‚€ â‰  âˆ âˆ§ Î¼.map M.symm = câ‚€ â€¢ Î¼S.prod Î¼T := by
    have : IsAddHaarMeasure (Î¼.map M.symm) :=
      M.toContinuousLinearEquiv.symm.isAddHaarMeasure_map Î¼
    refine âŸ¨addHaarScalarFactor (Î¼.map M.symm) (Î¼S.prod Î¼T), ?_, ENNReal.coe_ne_top,
      isAddLeftInvariant_eq_smul _ _âŸ©
    simpa only [ne_eq, ENNReal.coe_eq_zero] using
      (addHaarScalarFactor_pos_of_isAddHaarMeasure (Î¼.map M.symm) (Î¼S.prod Î¼T)).ne'
  have J : (Î¼S.prod Î¼T).map P = (Î¼S univ) â€¢ Î¼T := map_snd_prod
  obtain âŸ¨câ‚, câ‚_pos, câ‚_fin, hâ‚âŸ© : âˆƒ câ‚ : â„â‰¥0âˆ, câ‚ â‰  0 âˆ§ câ‚ â‰  âˆ âˆ§ Î¼T.map L' = câ‚ â€¢ Î½ := by
    have : IsAddHaarMeasure (Î¼T.map L') :=
      L'.toContinuousLinearEquiv.isAddHaarMeasure_map Î¼T
    refine âŸ¨addHaarScalarFactor (Î¼T.map L') Î½, ?_, ENNReal.coe_ne_top,
      isAddLeftInvariant_eq_smul _ _âŸ©
    simpa only [ne_eq, ENNReal.coe_eq_zero] using
      (addHaarScalarFactor_pos_of_isAddHaarMeasure (Î¼T.map L') Î½).ne'
  refine âŸ¨câ‚€ * câ‚, by simp [pos_iff_ne_zero, câ‚€_pos, câ‚_pos], ENNReal.mul_lt_top câ‚€_fin câ‚_fin, ?_âŸ©
  simp only [I, hâ‚€, Measure.map_smul, J, smul_smul, hâ‚]
  rw [mul_assoc, mul_comm _ câ‚, â† mul_assoc]","rcases LinearMap.exists_map_addHaar_eq_smul_addHaar' h with âŸ¨c, hc, hcL, hcLâŸ©"
Mathlib/Data/Nat/Bitwise.lean,Nat.bitwise_bit,bitwise_bit,47962ffc161f9f1d61aca7d3e6311c9b02cfc3df,":= by
  conv_lhs => unfold bitwise
  simp only [bit, ite_apply, bit1, bit0, Bool.cond_eq_ite]
  have h1 x :     (x + x) % 2 = 0 := by rw [â† two_mul, mul_comm]; apply mul_mod_left
  have h2 x : (x + x + 1) % 2 = 1 := by rw [â† two_mul, add_comm]; apply add_mul_mod_self_left
  have h3 x :     (x + x) / 2 = x := by
    rw [â† two_mul, mul_comm]; apply mul_div_left _ zero_lt_two
  have h4 x : (x + x + 1) / 2 = x := by rw [â† two_mul, add_comm]; simp [add_mul_div_left]
  cases a <;> cases b <;> simp [h1, h2, h3, h4] <;> split_ifs
    <;> simp_all (config := {decide := true})","warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  unknown identifier 'zero_lt_two'
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `Nat.mul_lt_mul'` has been deprecated, use `Nat.mul_lt_mul_of_le_of_lt` instead
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated","lemma bitwise_bit {f : Bool â†’ Bool â†’ Bool} (h : f false false = false := by rfl) (a m b n) :
    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n) ",":= by
  conv_lhs => unfold bitwise
  simp only [bit, ite_apply, bit1, bit0, Bool.cond_eq_ite]
  have h1 x :     (x + x) % 2 = 0 := by rw [â† two_mul, mul_comm]; apply mul_mod_left
  have h2 x : (x + x + 1) % 2 = 1 := by rw [â† two_mul, add_comm]; apply add_mul_mod_self_left
  have h3 x :     (x + x) / 2 = x := by omega
  have h4 x : (x + x + 1) / 2 = x := by rw [â† two_mul, add_comm]; simp [add_mul_div_left]
  cases a <;> cases b <;> simp [h1, h2, h3, h4] <;> split_ifs
    <;> simp_all (config := {decide := true})","rw [â† drop_bit, â† drop_bit, â† drop_bit, â† drop_bit, â† drop_bit, â† drop_bit]"
Mathlib/MeasureTheory/Measure/WithDensityFinite.lean,MeasureTheory.toFiniteAux_eq_zero_iff,toFiniteAux_eq_zero_iff,baeb455ef6580050bf79aa52a60b8d7af9c53dfe,":= by
  refine âŸ¨fun h â†¦ ?_, fun h â†¦ by simp [h, toFiniteAux_zero]âŸ©
  ext s hs
  rw [Measure.ext_iff] at h
  specialize h s hs
  simp only [toFiniteAux_apply, Measure.zero_toOuterMeasure, OuterMeasure.coe_zero, Pi.zero_apply,
    ENNReal.tsum_eq_zero, mul_eq_zero, ENNReal.inv_eq_zero] at h
  rw [â† sum_sFiniteSeq Î¼, Measure.sum_apply _ hs]
  simp only [Measure.zero_toOuterMeasure, OuterMeasure.coe_zero, Pi.zero_apply,
    ENNReal.tsum_eq_zero]
  intro n
  specialize h n
  simpa [ENNReal.mul_eq_top, measure_ne_top] using h",error:  simp made no progress,lemma toFiniteAux_eq_zero_iff [SFinite Î¼] : Î¼.toFiniteAux = 0 â†” Î¼ = 0 ,":= by
  refine âŸ¨fun h â†¦ ?_, fun h â†¦ by simp [h, toFiniteAux_zero]âŸ©
  ext s hs
  rw [Measure.ext_iff] at h
  specialize h s hs
  simp only [toFiniteAux_apply, Measure.coe_zero, Pi.zero_apply,
    ENNReal.tsum_eq_zero, mul_eq_zero, ENNReal.inv_eq_zero] at h
  rw [â† sum_sFiniteSeq Î¼, Measure.sum_apply _ hs]
  simp only [Measure.coe_zero, Pi.zero_apply, ENNReal.tsum_eq_zero]
  intro n
  specialize h n
  simpa [ENNReal.mul_eq_top, measure_ne_top] using h","rw [â† toFiniteAux_eq_zero_iff, toFiniteAux_eq_zero_iff]"
Mathlib/LinearAlgebra/BilinearForm/Properties.lean,LinearMap.BilinForm.dualBasis_dualBasis_flip,dualBasis_dualBasis_flip,31c261277bc3e8a52b74d248691ef6b40c75b452,":=
  LinearMap.BilinForm.dualBasis_dualBasis_flip (BilinForm.toLin B) hB b","warning:  `LinearMap.BilinForm.toLin` has been deprecated
error:  fail to show termination for
  LinearMap.BilinForm.dualBasis_dualBasis_flip
with errors
structural recursion cannot be used:

argument #1 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #2 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #3 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #4 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #5 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #6 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #7 cannot be used for structural recursion
  its type does not have a recursor

argument #8 cannot be used for structural recursion
  its type is not an inductive

argument #9 cannot be used for structural recursion
  its type is not an inductive

argument #10 cannot be used for structural recursion
  its type does not have a recursor

argument #11 cannot be used for structural recursion
  its type is not an inductive

argument #12 cannot be used for structural recursion
  its type does not have a recursor

Could not find a decreasing measure.
The arguments relate at each recursive call as follows:
(<, â‰¤, =: relation proved, ? all proofs failed, _: no proof attempted)
           
1) 357:2-71
Please use `termination_by` to specify a decreasing measure.","lemma dualBasis_dualBasis_flip (B : BilinForm K V) (hB : B.Nondegenerate) {Î¹}
    [Finite Î¹] [DecidableEq Î¹] (b : Basis Î¹ K V) :
    B.dualBasis hB (B.flip.dualBasis hB.flip b) = b ",":= by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j â†¦ ?_))
  simp_rw [apply_dualBasis_left, â† B.flip_apply, apply_dualBasis_left, @eq_comm _ i j]","simp only [Basis.dualBasis_flip, dualBasis_dualBasis_flip, dualBasis_flip]"
Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean,CategoryTheory.Limits.hasZeroObject_of_hasTerminal_object,hasZeroObject_of_hasTerminal_object,fa9300117f483b80e073a77baa9550bb539d4c07,":= by
  refine' âŸ¨âŸ¨âŠ¤_ C, fun X => âŸ¨âŸ¨âŸ¨0âŸ©, fun f => _âŸ©âŸ©, fun X => âŸ¨âŸ¨âŸ¨0âŸ©, by aesop_catâŸ©âŸ©âŸ©âŸ©
  calc
    f = ğŸ™ _ â‰« f := (Category.id_comp _).symm
    _ = 0 â‰« f := by congr!
    _ = 0 := zero_comp
    ","error:  unsolved goals
case h.e'_6
C : Type u
instâœÂ³ : Category.{v, u} C
D : Type u'
instâœÂ² : Category.{v', u'} D
instâœÂ¹ : HasZeroMorphisms C
instâœ : HasTerminal C
X : C
f : âŠ¤_ C âŸ¶ X
âŠ¢ ğŸ™ (âŠ¤_ C) = 0","theorem hasZeroObject_of_hasTerminal_object [HasZeroMorphisms C] [HasTerminal C] :
    HasZeroObject C ",":= by
  refine âŸ¨âŸ¨âŠ¤_ C, fun X => âŸ¨âŸ¨âŸ¨0âŸ©, fun f => ?_âŸ©âŸ©, fun X => âŸ¨âŸ¨âŸ¨0âŸ©, by aesop_catâŸ©âŸ©âŸ©âŸ©
  calc
    f = ğŸ™ _ â‰« f := (Category.id_comp _).symm
    _ = 0 â‰« f := by congr!; apply Subsingleton.elim
    _ = 0 := zero_comp",exact hasZeroObject_of_hasZeroObject_of_hasZeroObject_of_hasTerminal_object
Mathlib/Algebra/Polynomial/Lifts.lean,Polynomial.lifts_and_degree_eq_and_monic,lifts_and_degree_eq_and_monic,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  cases' subsingleton_or_nontrivial R with hR hR
  Â· obtain âŸ¨q, hqâŸ© := mem_lifts_and_degree_eq hlifts
    exact âŸ¨q, hq.1, hq.2, monic_of_subsingleton _âŸ©
  have H : erase p.natDegree p + X ^ p.natDegree = p := by
    simpa only [hp.leadingCoeff, C_1, one_mul, eraseLead] using eraseLead_add_C_mul_X_pow p
  by_cases h0 : erase p.natDegree p = 0
  Â· rw [â† H, h0, zero_add]
    refine âŸ¨X ^ p.natDegree, ?_,? _, monic_X_pow p.natDegreeâŸ©
    Â· rw [Polynomial.map_pow, map_X]
    Â· rw [degree_X_pow, degree_X_pow]
  obtain âŸ¨q, hqâŸ© := mem_lifts_and_degree_eq (erase_mem_lifts p.natDegree hlifts)
  have p_neq_0 : p â‰  0 := by intro hp; apply h0; rw [hp]; simp only [natDegree_zero, erase_zero]
  have hdeg : q.degree < (X ^ p.natDegree).degree := by
    rw [@degree_X_pow R, hq.2, â† degree_eq_natDegree p_neq_0]
    exact degree_erase_lt p_neq_0
  refine âŸ¨q + X ^ p.natDegree, ?_,? _, (monic_X_pow _).add_of_right hdegâŸ©
  Â· rw [Polynomial.map_add, hq.1, Polynomial.map_pow, map_X, H]
  Â· rw [degree_add_eq_right_of_degree_lt hdeg, degree_X_pow, degree_eq_natDegree hp.ne_zero]","error:  typeclass instance problem is stuck, it is often due to metavariables
  Semiring ?m.22684","theorem lifts_and_degree_eq_and_monic [Nontrivial S] {p : S[X]} (hlifts : p âˆˆ lifts f)
    (hp : p.Monic) : âˆƒ q : R[X], map f q = p âˆ§ q.degree = p.degree âˆ§ q.Monic ",":= by
  cases' subsingleton_or_nontrivial R with hR hR
  Â· obtain âŸ¨q, hqâŸ© := mem_lifts_and_degree_eq hlifts
    exact âŸ¨q, hq.1, hq.2, monic_of_subsingleton _âŸ©
  have H : erase p.natDegree p + X ^ p.natDegree = p := by
    simpa only [hp.leadingCoeff, C_1, one_mul, eraseLead] using eraseLead_add_C_mul_X_pow p
  by_cases h0 : erase p.natDegree p = 0
  Â· rw [â† H, h0, zero_add]
    refine âŸ¨X ^ p.natDegree, ?_, ?_, monic_X_pow p.natDegreeâŸ©
    Â· rw [Polynomial.map_pow, map_X]
    Â· rw [degree_X_pow, degree_X_pow]
  obtain âŸ¨q, hqâŸ© := mem_lifts_and_degree_eq (erase_mem_lifts p.natDegree hlifts)
  have p_neq_0 : p â‰  0 := by intro hp; apply h0; rw [hp]; simp only [natDegree_zero, erase_zero]
  have hdeg : q.degree < ((X : R[X]) ^ p.natDegree).degree := by
    rw [@degree_X_pow R, hq.2, â† degree_eq_natDegree p_neq_0]
    exact degree_erase_lt p_neq_0
  refine âŸ¨q + X ^ p.natDegree, ?_, ?_, (monic_X_pow _).add_of_right hdegâŸ©
  Â· rw [Polynomial.map_add, hq.1, Polynomial.map_pow, map_X, H]
  Â· rw [degree_add_eq_right_of_degree_lt hdeg, degree_X_pow, degree_eq_natDegree hp.ne_zero]","obtain âŸ¨q, hqâŸ© := mem_lifts_iff.1 hlifts"
Mathlib/RingTheory/DedekindDomain/Different.lean,FractionalIdeal.self_mul_dual,self_mul_dual,3465d1aaae242475fad59e688648a2285031d19e,":= by
  rw [mul_comm, dual_mul_self hI]","error:  application type mismatch
  dual_mul_self hI
argument
  hI
has type
  I â‰  0 : Prop
but is expected to have type
  Type ?u.431094 : Type (?u.431094 + 1)","lemma self_mul_dual :
    I * dual A K I = dual A K 1 ",":= by
  rw [mul_comm, dual_mul_self A K hI]",simp [self_mul_dual]
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean,MeasureTheory.AEFinStronglyMeasurable.exists_set_sigmaFinite,exists_set_sigmaFinite,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases hf with âŸ¨fs, hT_lt_top, h_approxâŸ©
  let T n := support (fs n)
  have hT_meas : âˆ€ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)
  let t := â‹ƒ n, T n
  refine âŸ¨t, MeasurableSet.iUnion hT_meas, ?_, ?_âŸ©
  Â· have h_fs_zero : âˆ€ n, âˆ€ x âˆˆ tá¶œ, fs n x = 0 := by
      intro n x hxt
      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt
      simpa [T] using hxt n
    refine fun x hxt => tendsto_nhds_unique (h_approx x) ?_
    rw [funext fun n => h_fs_zero n x hxt]
    exact tendsto_const_nhds
  Â· refine âŸ¨âŸ¨âŸ¨fun n => tá¶œ âˆª T n, fun _ => trivial, fun n => ?_, ?_âŸ©âŸ©âŸ©
    Â· rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,
        Set.compl_inter_self t, Set.empty_union]
      exact (measure_mono (Set.inter_subset_left _ _)).trans_lt (hT_lt_top n)
    Â· rw [â† Set.union_iUnion tá¶œ T]
      exact Set.compl_union_self _","error:  function expected at
  inter_subset_left ?m.176273
term has type
  ?m.176272 âˆˆ ?m.176270","theorem exists_set_sigmaFinite [Zero Î²] [TopologicalSpace Î²] [T2Space Î²]
    (hf : FinStronglyMeasurable f Î¼) :
    âˆƒ t, MeasurableSet t âˆ§ (âˆ€ x âˆˆ tá¶œ, f x = 0) âˆ§ SigmaFinite (Î¼.restrict t) ",":= by
  rcases hf with âŸ¨fs, hT_lt_top, h_approxâŸ©
  let T n := support (fs n)
  have hT_meas : âˆ€ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)
  let t := â‹ƒ n, T n
  refine âŸ¨t, MeasurableSet.iUnion hT_meas, ?_, ?_âŸ©
  Â· have h_fs_zero : âˆ€ n, âˆ€ x âˆˆ tá¶œ, fs n x = 0 := by
      intro n x hxt
      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt
      simpa [T] using hxt n
    refine fun x hxt => tendsto_nhds_unique (h_approx x) ?_
    rw [funext fun n => h_fs_zero n x hxt]
    exact tendsto_const_nhds
  Â· refine âŸ¨âŸ¨âŸ¨fun n => tá¶œ âˆª T n, fun _ => trivial, fun n => ?_, ?_âŸ©âŸ©âŸ©
    Â· rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,
        Set.compl_inter_self t, Set.empty_union]
      exact (measure_mono Set.inter_subset_left).trans_lt (hT_lt_top n)
    Â· rw [â† Set.union_iUnion tá¶œ T]
      exact Set.compl_union_self _","refine âŸ¨exists_set_sigmaFinite, exists_set_sigmaFinite, ?_, ?_âŸ©"
Mathlib/Topology/CompactOpen.lean,ContinuousMap.inducing_comp,inducing_comp,847a3fdc5138725139077c1ba700dd4bb54bb91c,"  induced := by
    simp only [compactOpen_eq_mapsTo, induced_generateFrom_eq, image_image2, hg.setOf_isOpen,
      image2_image_right, MapsTo, mem_preimage, preimage_setOf_eq, comp_apply]","error:  unknown identifier 'compactOpen_eq_mapsTo'
error:  simp made no progress
warning:  `ContinuousMap.curry'` has been deprecated, use `ContinuousMap.curry` instead","theorem inducing_comp (g : C(Y, Z)) (hg : Inducing g) : Inducing (g.comp : C(X, Y) â†’ C(X, Z)) where
","  induced := by
    simp only [compactOpen_eq, induced_generateFrom_eq, image_image2, hg.setOf_isOpen,
      image2_image_right, MapsTo, mem_preimage, preimage_setOf_eq, comp_apply]",apply Inducing.theorem_where
Mathlib/CategoryTheory/FiberedCategory/HomLift.lean,CategoryTheory.IsHomLift.eqToHom_domain_lift_id,eqToHom_domain_lift_id,95e75fcfd1c014add03de9b53a54ac3c1396bb20,  fac := by simp [eqToHom_map],"error:  function expected at
  p.IsHomLift (ğŸ™ R) (eqToHom hab)
term has type
  Prop
error:  simp made no progress","lemma eqToHom_domain_lift_id {p : ğ’³ â¥¤ ğ’®} {a b : ğ’³} (hab : a = b) {R : ğ’®} (hR : p.obj a = R) :
    p.IsHomLift (ğŸ™ R) (eqToHom hab) ",":= by
  subst hR hab; simp",simp [eqToHom_domain_lift_id]
Mathlib/MeasureTheory/Measure/Haar/Disintegration.lean,LinearMap.exists_map_addHaar_eq_smul_addHaar,LinearMap.exists_map_addHaar_eq_smul_addHaar,aa420cc4213ec00e046ed37661f7396b162d3e67,":= by
  have : ProperSpace E := .of_locallyCompactSpace ğ•œ
  have : FiniteDimensional ğ•œ E := finiteDimensional_of_locallyCompactSpace ğ•œ
  have : ProperSpace F := by
    rcases subsingleton_or_nontrivial E with hE|hE
    Â· have : Subsingleton F := Function.Surjective.subsingleton h
      infer_instance
    Â· have : ProperSpace ğ•œ := .of_locallyCompact_module ğ•œ E
      have : FiniteDimensional ğ•œ F := Module.Finite.of_surjective L h
      exact FiniteDimensional.proper ğ•œ F
  let S : Submodule ğ•œ E := LinearMap.ker L
  obtain âŸ¨T, hTâŸ© : âˆƒ T : Submodule ğ•œ E, IsCompl S T := Submodule.exists_isCompl S
  let M : (S Ã— T) â‰ƒâ‚—[ğ•œ] E := Submodule.prodEquivOfIsCompl S T hT
  have M_cont : Continuous M.symm := LinearMap.continuous_of_finiteDimensional _
  let P : S Ã— T â†’â‚—[ğ•œ] T := LinearMap.snd ğ•œ S T
  have P_cont : Continuous P := LinearMap.continuous_of_finiteDimensional _
  have I : Function.Bijective (LinearMap.domRestrict L T) :=
    âŸ¨LinearMap.injective_domRestrict_iff.2 (IsCompl.inf_eq_bot hT.symm),
    (LinearMap.surjective_domRestrict_iff h).2 hT.symm.sup_eq_topâŸ©
  let L' : T â‰ƒâ‚—[ğ•œ] F := LinearEquiv.ofBijective (LinearMap.domRestrict L T) I
  have L'_cont : Continuous L' := LinearMap.continuous_of_finiteDimensional _
  have A : L = (L' : T â†’â‚—[ğ•œ] F).comp (P.comp (M.symm : E â†’â‚—[ğ•œ] (S Ã— T))) := by
    ext x
    obtain âŸ¨y, z, hyzâŸ© : âˆƒ (y : S) (z : T), M.symm x = (y, z) := âŸ¨_, _, rflâŸ©
    have : x = M (y, z) := by
      rw [â† hyz]; simp only [LinearEquiv.apply_symm_apply]
    simp [this]
  have I : Î¼.map L = ((Î¼.map M.symm).map P).map L' := by
    rw [Measure.map_map, Measure.map_map, A]
    Â· rfl
    Â· exact L'_cont.measurable.comp P_cont.measurable
    Â· exact M_cont.measurable
    Â· exact L'_cont.measurable
    Â· exact P_cont.measurable
  let Î¼S : Measure S := addHaar
  let Î¼T : Measure T := addHaar
  obtain âŸ¨câ‚€, câ‚€_pos, câ‚€_fin, hâ‚€âŸ© :
      âˆƒ câ‚€ : â„â‰¥0âˆ, câ‚€ â‰  0 âˆ§ câ‚€ â‰  âˆ âˆ§ Î¼.map M.symm = câ‚€ â€¢ Î¼S.prod Î¼T := by
    have : IsAddHaarMeasure (Î¼.map M.symm) :=
      M.toContinuousLinearEquiv.symm.isAddHaarMeasure_map Î¼
    refine âŸ¨addHaarScalarFactor (Î¼.map M.symm) (Î¼S.prod Î¼T), ?_, ENNReal.coe_ne_top,
      isAddHaarMeasure_eq_smul _ _âŸ©
    simpa only [ne_eq, ENNReal.coe_eq_zero] using
      (addHaarScalarFactor_pos_of_isOpenPosMeasure (Î¼.map M.symm) (Î¼S.prod Î¼T)).ne'
  have J : (Î¼S.prod Î¼T).map P = (Î¼S univ) â€¢ Î¼T := map_snd_prod
  obtain âŸ¨câ‚, câ‚_pos, câ‚_fin, hâ‚âŸ© : âˆƒ câ‚ : â„â‰¥0âˆ, câ‚ â‰  0 âˆ§ câ‚ â‰  âˆ âˆ§ Î¼T.map L' = câ‚ â€¢ Î½ := by
    have : IsAddHaarMeasure (Î¼T.map L') :=
      L'.toContinuousLinearEquiv.isAddHaarMeasure_map Î¼T
    refine âŸ¨addHaarScalarFactor (Î¼T.map L') Î½, ?_, ENNReal.coe_ne_top,
      isAddHaarMeasure_eq_smul _ _âŸ©
    simpa only [ne_eq, ENNReal.coe_eq_zero] using
      (addHaarScalarFactor_pos_of_isOpenPosMeasure (Î¼T.map L') Î½).ne'
  refine âŸ¨câ‚€ * câ‚, by simp [pos_iff_ne_zero, câ‚€_pos, câ‚_pos], ENNReal.mul_lt_top câ‚€_fin câ‚_fin, ?_âŸ©
  simp only [I, hâ‚€, Measure.map_smul, J, smul_smul, hâ‚]
  rw [mul_assoc, mul_comm _ câ‚, â† mul_assoc]","warning:  `finiteDimensional_of_locallyCompactSpace` has been deprecated, use `FiniteDimensional.of_locallyCompactSpace` instead
error:  unsolved goals
case h.intro.intro
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœÂ¹Â² : NontriviallyNormedField ğ•œ
instâœÂ¹Â¹ : CompleteSpace ğ•œ
instâœÂ¹â° : NormedAddCommGroup E
instâœâ¹ : MeasurableSpace E
instâœâ¸ : BorelSpace E
instâœâ· : NormedSpace ğ•œ E
instâœâ¶ : NormedAddCommGroup F
instâœâµ : MeasurableSpace F
instâœâ´ : BorelSpace F
instâœÂ³ : NormedSpace ğ•œ F
L : E â†’â‚—[ğ•œ] F
Î¼ : Measure E
Î½ : Measure F
instâœÂ² : Î¼.IsAddHaarMeasure
instâœÂ¹ : Î½.IsAddHaarMeasure
instâœ : LocallyCompactSpace E
h : Function.Surjective â‡‘L
thisâœÂ² : ProperSpace E
thisâœÂ¹ : FiniteDimensional ğ•œ E
thisâœ : ProperSpace F
S : Submodule ğ•œ E := ker L
T : Submodule ğ•œ E
hT : IsCompl S T
M : (â†¥S Ã— â†¥T) â‰ƒâ‚—[ğ•œ] E := S.prodEquivOfIsCompl T hT
M_cont : Continuous â‡‘M.symm
P : â†¥S Ã— â†¥T â†’â‚—[ğ•œ] â†¥T := snd ğ•œ â†¥S â†¥T
P_cont : Continuous â‡‘P
I : Function.Bijective â‡‘(L.domRestrict T)
L' : â†¥T â‰ƒâ‚—[ğ•œ] F := LinearEquiv.ofBijective (L.domRestrict T) I
L'_cont : Continuous â‡‘L'
x : E
y : â†¥S
z : â†¥T
hyz : M.symm x = (y, z)
this : x = M (y, z)
âŠ¢ L (M (y, z)) = L' (P (y, z))
warning:  `MeasureTheory.Measure.isAddHaarMeasure_eq_smul` has been deprecated, use `MeasureTheory.Measure.isAddLeftInvariant_eq_smul` instead
warning:  `MeasureTheory.Measure.addHaarScalarFactor_pos_of_isOpenPosMeasure` has been deprecated, use `MeasureTheory.Measure.addHaarScalarFactor_pos_of_isAddHaarMeasure` instead
warning:  `MeasureTheory.Measure.isAddHaarMeasure_eq_smul` has been deprecated, use `MeasureTheory.Measure.isAddLeftInvariant_eq_smul` instead
warning:  `MeasureTheory.Measure.addHaarScalarFactor_pos_of_isOpenPosMeasure` has been deprecated, use `MeasureTheory.Measure.addHaarScalarFactor_pos_of_isAddHaarMeasure` instead","theorem LinearMap.exists_map_addHaar_eq_smul_addHaar' (h : Function.Surjective L) :
    âˆƒ (c : â„â‰¥0âˆ), 0 < c âˆ§ c < âˆ âˆ§ Î¼.map L = (c * addHaar (univ : Set (LinearMap.ker L))) â€¢ Î½ ",":= by
  have : ProperSpace E := .of_locallyCompactSpace ğ•œ
  have : FiniteDimensional ğ•œ E := .of_locallyCompactSpace ğ•œ
  have : ProperSpace F := by
    rcases subsingleton_or_nontrivial E with hE|hE
    Â· have : Subsingleton F := Function.Surjective.subsingleton h
      infer_instance
    Â· have : ProperSpace ğ•œ := .of_locallyCompact_module ğ•œ E
      have : FiniteDimensional ğ•œ F := Module.Finite.of_surjective L h
      exact FiniteDimensional.proper ğ•œ F
  let S : Submodule ğ•œ E := LinearMap.ker L
  obtain âŸ¨T, hTâŸ© : âˆƒ T : Submodule ğ•œ E, IsCompl S T := Submodule.exists_isCompl S
  let M : (S Ã— T) â‰ƒâ‚—[ğ•œ] E := Submodule.prodEquivOfIsCompl S T hT
  have M_cont : Continuous M.symm := LinearMap.continuous_of_finiteDimensional _
  let P : S Ã— T â†’â‚—[ğ•œ] T := LinearMap.snd ğ•œ S T
  have P_cont : Continuous P := LinearMap.continuous_of_finiteDimensional _
  have I : Function.Bijective (LinearMap.domRestrict L T) :=
    âŸ¨LinearMap.injective_domRestrict_iff.2 (IsCompl.inf_eq_bot hT.symm),
    (LinearMap.surjective_domRestrict_iff h).2 hT.symm.sup_eq_topâŸ©
  let L' : T â‰ƒâ‚—[ğ•œ] F := LinearEquiv.ofBijective (LinearMap.domRestrict L T) I
  have L'_cont : Continuous L' := LinearMap.continuous_of_finiteDimensional _
  have A : L = (L' : T â†’â‚—[ğ•œ] F).comp (P.comp (M.symm : E â†’â‚—[ğ•œ] (S Ã— T))) := by
    ext x
    obtain âŸ¨y, z, hyzâŸ© : âˆƒ (y : S) (z : T), M.symm x = (y, z) := âŸ¨_, _, rflâŸ©
    have : x = M (y, z) := by
      rw [â† hyz]; simp only [LinearEquiv.apply_symm_apply]
    simp [L', P, M, this]
  have I : Î¼.map L = ((Î¼.map M.symm).map P).map L' := by
    rw [Measure.map_map, Measure.map_map, A]
    Â· rfl
    Â· exact L'_cont.measurable.comp P_cont.measurable
    Â· exact M_cont.measurable
    Â· exact L'_cont.measurable
    Â· exact P_cont.measurable
  let Î¼S : Measure S := addHaar
  let Î¼T : Measure T := addHaar
  obtain âŸ¨câ‚€, câ‚€_pos, câ‚€_fin, hâ‚€âŸ© :
      âˆƒ câ‚€ : â„â‰¥0âˆ, câ‚€ â‰  0 âˆ§ câ‚€ â‰  âˆ âˆ§ Î¼.map M.symm = câ‚€ â€¢ Î¼S.prod Î¼T := by
    have : IsAddHaarMeasure (Î¼.map M.symm) :=
      M.toContinuousLinearEquiv.symm.isAddHaarMeasure_map Î¼
    refine âŸ¨addHaarScalarFactor (Î¼.map M.symm) (Î¼S.prod Î¼T), ?_, ENNReal.coe_ne_top,
      isAddLeftInvariant_eq_smul _ _âŸ©
    simpa only [ne_eq, ENNReal.coe_eq_zero] using
      (addHaarScalarFactor_pos_of_isAddHaarMeasure (Î¼.map M.symm) (Î¼S.prod Î¼T)).ne'
  have J : (Î¼S.prod Î¼T).map P = (Î¼S univ) â€¢ Î¼T := map_snd_prod
  obtain âŸ¨câ‚, câ‚_pos, câ‚_fin, hâ‚âŸ© : âˆƒ câ‚ : â„â‰¥0âˆ, câ‚ â‰  0 âˆ§ câ‚ â‰  âˆ âˆ§ Î¼T.map L' = câ‚ â€¢ Î½ := by
    have : IsAddHaarMeasure (Î¼T.map L') :=
      L'.toContinuousLinearEquiv.isAddHaarMeasure_map Î¼T
    refine âŸ¨addHaarScalarFactor (Î¼T.map L') Î½, ?_, ENNReal.coe_ne_top,
      isAddLeftInvariant_eq_smul _ _âŸ©
    simpa only [ne_eq, ENNReal.coe_eq_zero] using
      (addHaarScalarFactor_pos_of_isAddHaarMeasure (Î¼T.map L') Î½).ne'
  refine âŸ¨câ‚€ * câ‚, by simp [pos_iff_ne_zero, câ‚€_pos, câ‚_pos], ENNReal.mul_lt_top câ‚€_fin câ‚_fin, ?_âŸ©
  simp only [I, hâ‚€, Measure.map_smul, J, smul_smul, hâ‚]
  rw [mul_assoc, mul_comm _ câ‚, â† mul_assoc]","rcases LinearMap.exists_map_addHaar_eq_smul_addHaar' h with âŸ¨c, hc, hcL, hcLâŸ©"
Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean,MeasureTheory.exists_le_lowerSemicontinuous_lintegral_ge,exists_le_lowerSemicontinuous_lintegral_ge,2c23e43ba179a9dd2928e06c32f043d20e9798c8,":= by
  rcases ENNReal.exists_pos_sum_of_countable' Îµpos â„• with âŸ¨Î´, Î´pos, hÎ´âŸ©
  have :
    âˆ€ n,
      âˆƒ g : Î± â†’ â„â‰¥0,
        (âˆ€ x, SimpleFunc.eapproxDiff f n x â‰¤ g x) âˆ§
          LowerSemicontinuous g âˆ§
            (âˆ«â» x, g x âˆ‚Î¼) â‰¤ (âˆ«â» x, SimpleFunc.eapproxDiff f n x âˆ‚Î¼) + Î´ n :=
    fun n =>
    SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge Î¼ (SimpleFunc.eapproxDiff f n)
      (Î´pos n).ne'
  choose g f_le_g gcont hg using this
  refine' âŸ¨fun x => âˆ‘' n, g n x, fun x => _, _, _âŸ©
  Â· rw [â† SimpleFunc.tsum_eapproxDiff f hf]
    exact ENNReal.tsum_le_tsum fun n => ENNReal.coe_le_coe.2 (f_le_g n x)
  Â· refine' lowerSemicontinuous_tsum fun n => _
    exact
      ENNReal.continuous_coe.comp_lowerSemicontinuous (gcont n) fun x y hxy =>
        ENNReal.coe_le_coe.2 hxy
  Â· calc
      (âˆ«â» x, âˆ‘' n : â„•, g n x âˆ‚Î¼) = âˆ‘' n, âˆ«â» x, g n x âˆ‚Î¼ := by
        rw [lintegral_tsum fun n => (gcont n).measurable.coe_nnreal_ennreal.aemeasurable]
      _ â‰¤ âˆ‘' n, (âˆ«â» x, SimpleFunc.eapproxDiff f n x âˆ‚Î¼) + Î´ n := (ENNReal.tsum_le_tsum hg)
      _ = (âˆ‘' n, âˆ«â» x, SimpleFunc.eapproxDiff f n x âˆ‚Î¼) + âˆ‘' n, Î´ n := ENNReal.tsum_add
      _ â‰¤ (âˆ«â» x : Î±, f x âˆ‚Î¼) + Îµ := by
        refine' add_le_add _ hÎ´.le
        rw [â† lintegral_tsum]
        Â· simp_rw [SimpleFunc.tsum_eapproxDiff f hf, le_refl]
        Â· intro n; exact (SimpleFunc.measurable _).coe_nnreal_ennreal.aemeasurable",error:  unknown identifier 'n',"theorem exists_le_lowerSemicontinuous_lintegral_ge (f : Î± â†’ â„â‰¥0âˆ) (hf : Measurable f) {Îµ : â„â‰¥0âˆ}
    (Îµpos : Îµ â‰  0) :
    âˆƒ g : Î± â†’ â„â‰¥0âˆ,
      (âˆ€ x, f x â‰¤ g x) âˆ§ LowerSemicontinuous g âˆ§ (âˆ«â» x, g x âˆ‚Î¼) â‰¤ (âˆ«â» x, f x âˆ‚Î¼) + Îµ ",":= by
  rcases ENNReal.exists_pos_sum_of_countable' Îµpos â„• with âŸ¨Î´, Î´pos, hÎ´âŸ©
  have :
    âˆ€ n,
      âˆƒ g : Î± â†’ â„â‰¥0,
        (âˆ€ x, SimpleFunc.eapproxDiff f n x â‰¤ g x) âˆ§
          LowerSemicontinuous g âˆ§
            (âˆ«â» x, g x âˆ‚Î¼) â‰¤ (âˆ«â» x, SimpleFunc.eapproxDiff f n x âˆ‚Î¼) + Î´ n :=
    fun n =>
    SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge Î¼ (SimpleFunc.eapproxDiff f n)
      (Î´pos n).ne'
  choose g f_le_g gcont hg using this
  refine âŸ¨fun x => âˆ‘' n, g n x, fun x => ?_, ?_, ?_âŸ©
  Â· rw [â† SimpleFunc.tsum_eapproxDiff f hf]
    exact ENNReal.tsum_le_tsum fun n => ENNReal.coe_le_coe.2 (f_le_g n x)
  Â· refine lowerSemicontinuous_tsum fun n => ?_
    exact
      ENNReal.continuous_coe.comp_lowerSemicontinuous (gcont n) fun x y hxy =>
        ENNReal.coe_le_coe.2 hxy
  Â· calc
      âˆ«â» x, âˆ‘' n : â„•, g n x âˆ‚Î¼ = âˆ‘' n, âˆ«â» x, g n x âˆ‚Î¼ := by
        rw [lintegral_tsum fun n => (gcont n).measurable.coe_nnreal_ennreal.aemeasurable]
      _ â‰¤ âˆ‘' n, ((âˆ«â» x, SimpleFunc.eapproxDiff f n x âˆ‚Î¼) + Î´ n) := ENNReal.tsum_le_tsum hg
      _ = âˆ‘' n, âˆ«â» x, SimpleFunc.eapproxDiff f n x âˆ‚Î¼ + âˆ‘' n, Î´ n := ENNReal.tsum_add
      _ â‰¤ (âˆ«â» x : Î±, f x âˆ‚Î¼) + Îµ := by
        refine add_le_add ?_ hÎ´.le
        rw [â† lintegral_tsum]
        Â· simp_rw [SimpleFunc.tsum_eapproxDiff f hf, le_refl]
        Â· intro n; exact (SimpleFunc.measurable _).coe_nnreal_ennreal.aemeasurable",refine theorem_exists_le_lowerSemicontinuous_lintegral_ge_lowerSemicontinuous_lintegral_ge Îµ Îµpos ?_
Mathlib/Topology/Homotopy/HomotopyGroup.lean,GenLoop.homotopicTo,homotopicTo,0620eae008483cf7a815cce7f68256e53d6d8ac2,":= by
  refine Nonempty.map fun H => âŸ¨âŸ¨âŸ¨fun t => âŸ¨homotopyTo i H t, ?_âŸ©, ?_âŸ©, ?_, ?_?âŸ©, _âŸ©
  Â· rintro y âŸ¨i, iHâŸ©
    rw [homotopyTo_apply, H.eq_fst, p.2]
    all_goals apply Cube.insertAt_boundary; right; exact âŸ¨i, iHâŸ©
  Â· continuity
  iterate 2 intro; ext; erw [homotopyTo_apply, toLoop_apply]; swap
  Â· apply H.apply_zero
  Â· apply H.apply_one
  intro t y yH
  ext; erw [homotopyTo_apply]
  apply H.eq_fst; use i
  rw [funSplitAt_symm_apply, dif_pos rfl]; exact yH","warning:  GenLoop does not have a doc string
error:  don't know how to synthesize placeholder for argument 'prop''
context:
N : Type u_1
X : Type u_2
instâœÂ¹ : TopologicalSpace X
x : X
instâœ : DecidableEq N
i : N
p q : â†‘(Î©^ N X x)
H : (â†‘p).HomotopyRel (â†‘q) (Cube.boundary N)
âŠ¢ âˆ€ (t x_1 : â†‘I),
    x_1 âˆˆ {0, 1} â†’
      {
            toFun := fun x_2 â†¦
              { toFun := fun t â†¦ âŸ¨(homotopyTo i H) t, â‹¯âŸ©, continuous_toFun := ?m.172348, map_zero_left := ?m.172405,
                    map_one_left := ?_? }.toFun
                (t, x_2),
            continuous_toFun := â‹¯ }
          x_1 =
        (toLoop i p).toContinuousMap x_1
error:  unsolved goals
N : Type u_1
X : Type u_2
instâœÂ¹ : TopologicalSpace X
x : X
instâœ : DecidableEq N
i : N
p q : â†‘(Î©^ N X x)
âŠ¢ Homotopic p q â†’ Path.Homotopic (toLoop i p) (toLoop i q)","theorem homotopicTo (i : N) {p q : Î©^ N X x} :
    Homotopic p q â†’ (toLoop i p).Homotopic (toLoop i q) ",":= by
  refine Nonempty.map fun H => âŸ¨âŸ¨âŸ¨fun t => âŸ¨homotopyTo i H t, ?_âŸ©, ?_âŸ©, ?_, ?_âŸ©, ?_âŸ©
  Â· rintro y âŸ¨i, iHâŸ©
    rw [homotopyTo_apply, H.eq_fst, p.2]
    all_goals apply Cube.insertAt_boundary; right; exact âŸ¨i, iHâŸ©
  Â· continuity
  iterate 2 intro; ext; erw [homotopyTo_apply, toLoop_apply]; swap
  Â· apply H.apply_zero
  Â· apply H.apply_one
  intro t y yH
  ext; erw [homotopyTo_apply]
  apply H.eq_fst; use i
  rw [funSplitAt_symm_apply, dif_pos rfl]; exact yH","simp only [Homotopic, toLoop, Homotopic, Homotopic, homotopicTo]"
Mathlib/CategoryTheory/Filtered/Basic.lean,CategoryTheory.IsCofiltered.cone_nonempty,cone_nonempty,ba9ffb63c3a392ae937d6d012c9e01340814d771,":= by
  classical
  let O := Finset.univ.image F.obj
  let H : Finset (Î£' (X Y : C) (_ : X âˆˆ O) (_ : Y âˆˆ O), X âŸ¶ Y) :=
    Finset.univ.biUnion fun X : J =>
      Finset.univ.biUnion fun Y : J =>
        Finset.univ.image fun f : X âŸ¶ Y => âŸ¨F.obj X, F.obj Y, by simp, by simp, F.map fâŸ©
  obtain âŸ¨Z, f, wâŸ© := inf_exists O H
  refine' âŸ¨âŸ¨Z, âŸ¨fun X => f (by simp), _âŸ©âŸ©âŸ©
  intro j j' g
  dsimp
  simp only [Category.id_comp]
  symm
  apply w
  simp only [Finset.mem_biUnion, Finset.mem_univ, Finset.mem_image,
    PSigma.mk.injEq, true_and, exists_and_left]
  exact âŸ¨j, rfl, j', g, by simpâŸ©","error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress",theorem cone_nonempty (F : J â¥¤ C) : Nonempty (Cone F) ,":= by
  classical
  let O := Finset.univ.image F.obj
  let H : Finset (Î£' (X Y : C) (_ : X âˆˆ O) (_ : Y âˆˆ O), X âŸ¶ Y) :=
    Finset.univ.biUnion fun X : J =>
      Finset.univ.biUnion fun Y : J =>
        Finset.univ.image fun f : X âŸ¶ Y => âŸ¨F.obj X, F.obj Y, by simp [O], by simp [O], F.map fâŸ©
  obtain âŸ¨Z, f, wâŸ© := inf_exists O H
  refine âŸ¨âŸ¨Z, âŸ¨fun X => f (by simp [O]), ?_âŸ©âŸ©âŸ©
  intro j j' g
  dsimp
  simp only [Category.id_comp]
  symm
  apply w
  simp only [O, H, Finset.mem_biUnion, Finset.mem_univ, Finset.mem_image,
    PSigma.mk.injEq, true_and, exists_and_left]
  exact âŸ¨j, rfl, j', g, by simpâŸ©",heorem_cone_nonempty cone_nonempty F
Mathlib/LinearAlgebra/Matrix/Spectrum.lean,Matrix.IsHermitian.exists_eigenvector_of_ne_zero,exists_eigenvector_of_ne_zero,5250ed6b5cbd9c34a91206fe413e98dfc25abd1d,":= by
  classical
  have : hA.eigenvalues â‰  0 := by
    contrapose! h_ne
    have := hA.spectral_theorem2
    rwa [h_ne, Pi.comp_zero, RCLike.ofReal_zero, (by rfl : Function.const n (0 : ğ•œ) = fun _ â†¦ 0),
      diagonal_zero, mul_zero, zero_mul] at this
  obtain âŸ¨i, hiâŸ© := Function.ne_iff.mp this
  exact âŸ¨_, _, hi, hA.eigenvectorBasis.orthonormal.ne_zero i, hA.mulVec_eigenvectorBasis iâŸ©","error:  invalid field 'spectral_theorem2', the environment does not contain 'Matrix.IsHermitian.spectral_theorem2'
  hA
has type
  A.IsHermitian
error:  invalid field 'spectral_theorem2', the environment does not contain 'Eq.spectral_theorem2'
  hA
has type
  Aá´´ = A","lemma exists_eigenvector_of_ne_zero (hA : IsHermitian A) (h_ne : A â‰  0) :
    âˆƒ (v : n â†’ ğ•œ) (t : â„), t â‰  0 âˆ§ v â‰  0 âˆ§ A *áµ¥ v = t â€¢ v ",":= by
  classical
  have : hA.eigenvalues â‰  0 := by
    contrapose! h_ne
    have := hA.spectral_theorem
    rwa [h_ne, Pi.comp_zero, RCLike.ofReal_zero, (by rfl : Function.const n (0 : ğ•œ) = fun _ â†¦ 0),
      diagonal_zero, mul_zero, zero_mul] at this
  obtain âŸ¨i, hiâŸ© := Function.ne_iff.mp this
  exact âŸ¨_, _, hi, hA.eigenvectorBasis.orthonormal.ne_zero i, hA.mulVec_eigenvectorBasis iâŸ©","refine âŸ¨exists_eigenvector_of_ne_zero hA h_ne, ?_, ?_âŸ©"
Mathlib/GroupTheory/OrderOfElement.lean,Commute.isOfFinOrder_mul,isOfFinOrder_mul,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  orderOf_pos_iff.mp <|
    pos_of_dvd_of_pos h.orderOf_mul_dvd_mul_orderOf <| mul_pos (orderOf_pos' hx) (orderOf_pos' hy)","error:  unknown identifier 'orderOf_pos''
error:  unknown identifier 'orderOf_pos''",theorem isOfFinOrder_mul (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : IsOfFinOrder (x * y) ,":=
  orderOf_pos_iff.mp <|
    pos_of_dvd_of_pos h.orderOf_mul_dvd_mul_orderOf <| mul_pos hx.orderOf_pos hy.orderOf_pos",rw [isOfFinOrder_mul_isOfFinOrder_mul]
Mathlib/Data/Set/Sups.lean,Set.subset_sups_self,subset_sups_self,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= Î» _a ha â†¦ mem_sups.2 âŸ¨_, ha, _, ha, sup_idemâŸ©","warning:  @HasSups.sups does not have a doc string
warning:  @HasInfs.infs does not have a doc string
error:  application type mismatch
  âŸ¨ha, sup_idemâŸ©
argument
  sup_idem
has type
  âˆ€ (a : ?m.14263), a âŠ” a = a : Prop
but is expected to have type
  _a âŠ” _a = _a : Prop",lemma subset_sups_self : s âŠ† s âŠ» s ,":= fun _a ha â†¦ mem_sups.2 âŸ¨_, ha, _, ha, sup_idem _âŸ©",exact subset_sups_self subset_sups_self
Mathlib/Analysis/NormedSpace/HahnBanach/Separation.lean,separate_convex_open_set,separate_convex_open_set,445b8b76b8b15da90721b5973241d3c69fb5bcfb,":= by
  let f : E â†’â‚—.[â„] â„ := LinearPMap.mkSpanSingleton xâ‚€ 1 (ne_of_mem_of_not_mem hsâ‚€ hxâ‚€).symm
  have :=  exists_extension_of_le_sublinear f (gauge s) (fun c hc => gauge_smul_of_nonneg hc.le)
    (gauge_add_le hsâ‚ <| absorbent_nhds_zero <| hsâ‚‚.mem_nhds hsâ‚€) ?_
  obtain âŸ¨Ï†, hÏ†â‚, hÏ†â‚‚âŸ© := this
  have hÏ†â‚ƒ : Ï† xâ‚€ = 1 := by
    rw [â† f.domain.coe_mk xâ‚€ (Submodule.mem_span_singleton_self _), hÏ†â‚,
      LinearPMap.mkSpanSingleton'_apply_self]
  have hÏ†â‚„ : âˆ€ x âˆˆ s, Ï† x < 1 := fun x hx =>
    (hÏ†â‚‚ x).trans_lt (gauge_lt_one_of_mem_of_open hsâ‚‚ hx)
  Â· refine' âŸ¨âŸ¨Ï†, _âŸ©, hÏ†â‚ƒ, hÏ†â‚„âŸ©
    refine'
      Ï†.continuous_of_nonzero_on_open _ (hsâ‚‚.vadd (-xâ‚€)) (Nonempty.vadd_set âŸ¨0, hsâ‚€âŸ©)
        (vadd_set_subset_iff.mpr fun x hx => _)
    change Ï† (-xâ‚€ + x) â‰  0
    rw [map_add, map_neg]
    specialize hÏ†â‚„ x hx
    linarith
  rintro âŸ¨x, hxâŸ©
  obtain âŸ¨y, rflâŸ© := Submodule.mem_span_singleton.1 hx
  rw [LinearPMap.mkSpanSingleton'_apply]
  simp only [mul_one, Algebra.id.smul_eq_mul, Submodule.coe_mk]
  obtain h | h := le_or_lt y 0
  Â· exact h.trans (gauge_nonneg _)
  Â· rw [gauge_smul_of_nonneg h.le, smul_eq_mul, le_mul_iff_one_le_right h]
    exact
      one_le_gauge_of_not_mem (hsâ‚.starConvex hsâ‚€)
        (absorbent_nhds_zero <| hsâ‚‚.mem_nhds hsâ‚€).absorbs hxâ‚€",error:  unknown identifier 'gauge_lt_one_of_mem_of_open',"theorem separate_convex_open_set [TopologicalSpace E] [AddCommGroup E] [TopologicalAddGroup E]
    [Module â„ E] [ContinuousSMul â„ E] {s : Set E} (hsâ‚€ : (0 : E) âˆˆ s) (hsâ‚ : Convex â„ s)
    (hsâ‚‚ : IsOpen s) {xâ‚€ : E} (hxâ‚€ : xâ‚€ âˆ‰ s) : âˆƒ f : E â†’L[â„] â„, f xâ‚€ = 1 âˆ§ âˆ€ x âˆˆ s, f x < 1 ",":= by
  let f : E â†’â‚—.[â„] â„ := LinearPMap.mkSpanSingleton xâ‚€ 1 (ne_of_mem_of_not_mem hsâ‚€ hxâ‚€).symm
  have := exists_extension_of_le_sublinear f (gauge s) (fun c hc => gauge_smul_of_nonneg hc.le)
    (gauge_add_le hsâ‚ <| absorbent_nhds_zero <| hsâ‚‚.mem_nhds hsâ‚€) ?_
  Â· obtain âŸ¨Ï†, hÏ†â‚, hÏ†â‚‚âŸ© := this
    have hÏ†â‚ƒ : Ï† xâ‚€ = 1 := by
      rw [â† f.domain.coe_mk xâ‚€ (Submodule.mem_span_singleton_self _), hÏ†â‚,
        LinearPMap.mkSpanSingleton'_apply_self]
    have hÏ†â‚„ : âˆ€ x âˆˆ s, Ï† x < 1 := fun x hx =>
      (hÏ†â‚‚ x).trans_lt (gauge_lt_one_of_mem_of_isOpen hsâ‚‚ hx)
    refine âŸ¨âŸ¨Ï†, ?_âŸ©, hÏ†â‚ƒ, hÏ†â‚„âŸ©
    refine
      Ï†.continuous_of_nonzero_on_open _ (hsâ‚‚.vadd (-xâ‚€)) (Nonempty.vadd_set âŸ¨0, hsâ‚€âŸ©)
        (vadd_set_subset_iff.mpr fun x hx => ?_)
    change Ï† (-xâ‚€ + x) â‰  0
    rw [map_add, map_neg]
    specialize hÏ†â‚„ x hx
    linarith
  rintro âŸ¨x, hxâŸ©
  obtain âŸ¨y, rflâŸ© := Submodule.mem_span_singleton.1 hx
  rw [LinearPMap.mkSpanSingleton'_apply]
  simp only [mul_one, Algebra.id.smul_eq_mul, Submodule.coe_mk]
  obtain h | h := le_or_lt y 0
  Â· exact h.trans (gauge_nonneg _)
  Â· rw [gauge_smul_of_nonneg h.le, smul_eq_mul, le_mul_iff_one_le_right h]
    exact
      one_le_gauge_of_not_mem (hsâ‚.starConvex hsâ‚€)
        (absorbent_nhds_zero <| hsâ‚‚.mem_nhds hsâ‚€).absorbs hxâ‚€","rcases separate_convex_open_set separate_convex_open_set separate_convex_open_set
  separate_convex_open_set separate_convex_open_set separate_convex_open_set
  separate_convex_open_set separate_convex_open_set separate_convex_open_set
  separate_convex_open_set separate_convex_open_set separate_convex_open_set hsâ‚ hsâ‚‚ hxâ‚€ with
  âŸ¨f, hfâ‚, hfâ‚‚âŸ©"
Mathlib/Logic/Relator.lean,Relator.bi_total_eq,bi_total_eq,b72bb8581e966b6491cee1c5638e18fae2fc11b2,:=,error:  unexpected token 'variable'; expected term,lemma bi_total_eq {Î± : Type uâ‚} : Relator.BiTotal (@Eq Î±) ,":=
  { left := fun a => âŸ¨a, rflâŸ©, right := fun a => âŸ¨a, rflâŸ© }","simp [Relator.BiTotal, Relator.BiTotal]"
Mathlib/Algebra/Order/Monoid/Unbundled/Defs.lean,contravariant_lt_of_contravariant_le,contravariant_lt_of_contravariant_le,a9c207c4e1fa09020f6c257c6d7127ce2969efc6,":=
  And.left âˆ˜ contravariant_le_iff_contravariant_lt_and_eq.mp",error:  unknown constant 'contravariant_le_iff_contravariant_lt_and_eq.mp',"theorem contravariant_lt_of_contravariant_le [PartialOrder N] :
    Contravariant M N Î¼ (Â· â‰¤ Â·) â†’ Contravariant M N Î¼ (Â· < Â·) ",":=
  And.left âˆ˜ (contravariant_le_iff_contravariant_lt_and_eq M N Î¼).mp",exact contravariant_lt_of_contravariant
Mathlib/Topology/ContinuousFunction/Sigma.lean,ContinuousMap.exists_lift_sigma,exists_lift_sigma,51c7969308516887591959ccbfbdc2c71d086de1,":=
  let âŸ¨i, g, hg, hfgâŸ© := f.continuous.exists_lift_sigma
  âŸ¨i, âŸ¨g, hgâŸ©, FunLike.ext' hfgâŸ©",error:  unknown constant 'FunLike.ext'',"theorem exists_lift_sigma (f : C(X, Î£ i, Y i)) : âˆƒ i g, f = (sigmaMk i).comp g ",":=
  let âŸ¨i, g, hg, hfgâŸ© := f.continuous.exists_lift_sigma
  âŸ¨i, âŸ¨g, hgâŸ©, DFunLike.ext' hfgâŸ©","rw [exists_lift_sigma, exists_lift_sigma]"
Mathlib/RingTheory/DedekindDomain/Ideal.lean,IsDedekindDomain.HeightOneSpectrum.iInf_localization_eq_bot,iInf_localization_eq_bot,f08cd34408673926d8b49db267d81563a31b378d,":= by
  ext x
  rw [Algebra.mem_iInf]
  constructor
  by_cases hR : IsField R
  Â· rcases Function.bijective_iff_has_inverse.mp
      (IsField.localization_map_bijective (flip nonZeroDivisors.ne_zero rfl : 0 âˆ‰ Râ°) hR) with
      âŸ¨algebra_map_inv, _, algebra_map_right_invâŸ©
    exact fun _ => Algebra.mem_bot.mpr âŸ¨algebra_map_inv x, algebra_map_right_inv xâŸ©
  all_goals rw [â† MaximalSpectrum.iInf_localization_eq_bot, Algebra.mem_iInf]
  Â· exact fun hx âŸ¨v, hvâŸ© => hx ((equivMaximalSpectrum hR).symm âŸ¨v, hvâŸ©)
  Â· exact fun hx âŸ¨v, hv, hbotâŸ© => hx âŸ¨v, dimensionLeOne v hbot hvâŸ©","error:  typeclass instance problem is stuck, it is often due to metavariables
  IsLocalization Râ° ?m.364145
error:  unknown identifier 'dimensionLeOne'","theorem iInf_localization_eq_bot [Algebra R K] [hK : IsFractionRing R K] :
    (â¨… v : HeightOneSpectrum R,
        Localization.subalgebra.ofField K _ v.asIdeal.primeCompl_le_nonZeroDivisors) = âŠ¥ ",":= by
  ext x
  rw [Algebra.mem_iInf]
  constructor
  on_goal 1 => by_cases hR : IsField R
  Â· rcases Function.bijective_iff_has_inverse.mp
      (IsField.localization_map_bijective (Râ‚˜ := K) (flip nonZeroDivisors.ne_zero rfl : 0 âˆ‰ Râ°) hR)
      with âŸ¨algebra_map_inv, _, algebra_map_right_invâŸ©
    exact fun _ => Algebra.mem_bot.mpr âŸ¨algebra_map_inv x, algebra_map_right_inv xâŸ©
  all_goals rw [â† MaximalSpectrum.iInf_localization_eq_bot, Algebra.mem_iInf]
  Â· exact fun hx âŸ¨v, hvâŸ© => hx ((equivMaximalSpectrum hR).symm âŸ¨v, hvâŸ©)
  Â· exact fun hx âŸ¨v, hv, hbotâŸ© => hx âŸ¨v, hv.isMaximal hbotâŸ©","rw [â† iInf_localization_eq_bot_iff, iInf_localization_eq_bot]"
Mathlib/NumberTheory/Zsqrtd/Basic.lean,Zsqrtd.norm_conj,norm_conj,0ef23fba776dbe5bb848bbfc3337bedef4a59c82,":=
  Zsqrtd.coe_int_inj <| by rw [norm_eq_mul_conj, star_star, mul_comm, norm_eq_mul_conj]","warning:  `Zsqrtd.coe_int_inj` has been deprecated, use `Int.cast_inj` instead
error:  function expected at
  coe_int_inj
term has type
  â†‘?m.99563 = â†‘?m.99564 â†” ?m.99563 = ?m.99564",theorem norm_conj (x : â„¤âˆšd) : (star x).norm = x.norm ,":=
  Int.cast_inj.1 <| by rw [norm_eq_mul_conj, star_star, mul_comm, norm_eq_mul_conj]","rw [norm_eq_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star_star,
  norm_eq_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_eq_star_star_star,
  norm_eq_star_star_star_star_star, norm_eq_star_star_star_star, norm_e"
Mathlib/Algebra/Lie/Engel.lean,LieAlgebra.isEngelian_of_isNoetherian,LieAlgebra.isEngelian_of_isNoetherian,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  intro M _i1 _i2 _i3 _i4 h
  rw [â† isNilpotent_range_toEndomorphism_iff]
  let L' := (toEndomorphism R L M).range
  replace h : âˆ€ y : L', _root_.IsNilpotent (y : Module.End R M) := by
    rintro âŸ¨-, âŸ¨y, rflâŸ©âŸ©
    simp [h]
  change LieModule.IsNilpotent R L' M
  let s := {K : LieSubalgebra R L' | LieAlgebra.IsEngelian R K}
  have hs : s.Nonempty := âŸ¨âŠ¥, LieAlgebra.isEngelian_of_subsingletonâŸ©
  suffices âŠ¤ âˆˆ s by
    rw [â† isNilpotent_of_top_iff]
    apply this M
    simp [LieSubalgebra.toEndomorphism_eq, h]
  have : âˆ€ K âˆˆ s, K â‰  âŠ¤ â†’ âˆƒ K' âˆˆ s, K < K' := by
    rintro K (hKâ‚ : LieAlgebra.IsEngelian R K) hKâ‚‚
    apply LieAlgebra.exists_engelian_lieSubalgebra_of_lt_normalizer hKâ‚
    apply lt_of_le_of_ne K.le_normalizer
    rw [Ne.def, eq_comm, K.normalizer_eq_self_iff, â† Ne.def, â†
      LieSubmodule.nontrivial_iff_ne_bot R K]
    have : Nontrivial (L' â§¸ K.toLieSubmodule) := by
      replace hKâ‚‚ : K.toLieSubmodule â‰  âŠ¤ := by
        rwa [Ne.def, â† LieSubmodule.coe_toSubmodule_eq_iff, K.coe_toLieSubmodule,
          LieSubmodule.top_coeSubmodule, â† LieSubalgebra.top_coe_submodule,
          K.coe_to_submodule_eq_iff]
      exact Submodule.Quotient.nontrivial_of_lt_top _ hKâ‚‚.lt_top
    have : LieModule.IsNilpotent R K (L' â§¸ K.toLieSubmodule) := by
      apply hKâ‚
      intro x
      have hx := LieAlgebra.isNilpotent_ad_of_isNilpotent (h x)
      apply Module.End.IsNilpotent.mapQ ?_ hx
      intro X HX
      simp only [LieSubalgebra.coe_toLieSubmodule, LieSubalgebra.mem_coe_submodule] at HX
      simp only [LieSubalgebra.coe_toLieSubmodule, Submodule.mem_comap, ad_apply,
        LieSubalgebra.mem_coe_submodule]
      exact LieSubalgebra.lie_mem K x.prop HX
    exact nontrivial_max_triv_of_isNilpotent R K (L' â§¸ K.toLieSubmodule)
  haveI _i5 : IsNoetherian R L' := by
    refine isNoetherian_of_surjective L (LieHom.rangeRestrict (toEndomorphism R L M)) ?_
    simp only [LieHom.range_coeSubmodule, LieHom.coe_toLinearMap, LinearMap.range_eq_top]
    exact LieHom.surjective_rangeRestrict (toEndomorphism R L M)
  obtain âŸ¨K, hKâ‚, hKâ‚‚âŸ© := (LieSubalgebra.wellFounded_of_noetherian R L').has_min s hs
  have hKâ‚ƒ : K = âŠ¤ := by
    by_contra contra
    obtain âŸ¨K', hK'â‚, hK'â‚‚âŸ© := this K hKâ‚ contra
    exact hKâ‚‚ K' hK'â‚ hK'â‚‚
  exact hKâ‚ƒ â–¸ hKâ‚","error:  unknown identifier 'isNilpotent_range_toEndomorphism_iff'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.131345
R : Type uâ‚
L : Type uâ‚‚
Lâ‚‚ : Type uâ‚ƒ
Mâœ : Type uâ‚„
instâœâ¹ : CommRing R
instâœâ¸ : LieRing L
instâœâ· : LieAlgebra R L
instâœâ¶ : LieRing Lâ‚‚
instâœâµ : LieAlgebra R Lâ‚‚
instâœâ´ : AddCommGroup Mâœ
instâœÂ³ : Module R Mâœ
instâœÂ² : LieRingModule L Mâœ
instâœÂ¹ : LieModule R L Mâœ
instâœ : IsNoetherian R L
M : Type u_1
_i1 : AddCommGroup M
_i2 : Module R M
_i3 : LieRingModule L M
_i4 : LieModule R L M
h : âˆ€ (x : L), _root_.IsNilpotent ((toEnd R L M) x)
âŠ¢ LieModule.IsNilpotent R L M",theorem LieAlgebra.isEngelian_of_isNoetherian [IsNoetherian R L] : LieAlgebra.IsEngelian R L ,":= by
  intro M _i1 _i2 _i3 _i4 h
  rw [â† isNilpotent_range_toEnd_iff]
  let L' := (toEnd R L M).range
  replace h : âˆ€ y : L', _root_.IsNilpotent (y : Module.End R M) := by
    rintro âŸ¨-, âŸ¨y, rflâŸ©âŸ©
    simp [h]
  change LieModule.IsNilpotent R L' M
  let s := {K : LieSubalgebra R L' | LieAlgebra.IsEngelian R K}
  have hs : s.Nonempty := âŸ¨âŠ¥, LieAlgebra.isEngelian_of_subsingletonâŸ©
  suffices âŠ¤ âˆˆ s by
    rw [â† isNilpotent_of_top_iff]
    apply this M
    simp [LieSubalgebra.toEnd_eq, h]
  have : âˆ€ K âˆˆ s, K â‰  âŠ¤ â†’ âˆƒ K' âˆˆ s, K < K' := by
    rintro K (hKâ‚ : LieAlgebra.IsEngelian R K) hKâ‚‚
    apply LieAlgebra.exists_engelian_lieSubalgebra_of_lt_normalizer hKâ‚
    apply lt_of_le_of_ne K.le_normalizer
    rw [Ne, eq_comm, K.normalizer_eq_self_iff, â† Ne, â†
      LieSubmodule.nontrivial_iff_ne_bot R K]
    have : Nontrivial (L' â§¸ K.toLieSubmodule) := by
      replace hKâ‚‚ : K.toLieSubmodule â‰  âŠ¤ := by
        rwa [Ne, â† LieSubmodule.coe_toSubmodule_eq_iff, K.coe_toLieSubmodule,
          LieSubmodule.top_coeSubmodule, â† LieSubalgebra.top_coe_submodule,
          K.coe_to_submodule_eq_iff]
      exact Submodule.Quotient.nontrivial_of_lt_top _ hKâ‚‚.lt_top
    have : LieModule.IsNilpotent R K (L' â§¸ K.toLieSubmodule) := by
      apply hKâ‚
      intro x
      have hx := LieAlgebra.isNilpotent_ad_of_isNilpotent (h x)
      apply Module.End.IsNilpotent.mapQ ?_ hx
      intro X HX
      simp only [LieSubalgebra.coe_toLieSubmodule, LieSubalgebra.mem_coe_submodule] at HX
      simp only [LieSubalgebra.coe_toLieSubmodule, Submodule.mem_comap, ad_apply,
        LieSubalgebra.mem_coe_submodule]
      exact LieSubalgebra.lie_mem K x.prop HX
    exact nontrivial_max_triv_of_isNilpotent R K (L' â§¸ K.toLieSubmodule)
  haveI _i5 : IsNoetherian R L' := by
    refine isNoetherian_of_surjective L (LieHom.rangeRestrict (toEnd R L M)) ?_
    simp only [LieHom.range_coeSubmodule, LieHom.coe_toLinearMap, LinearMap.range_eq_top]
    exact LieHom.surjective_rangeRestrict (toEnd R L M)
  obtain âŸ¨K, hKâ‚, hKâ‚‚âŸ© := (LieSubalgebra.wellFounded_of_noetherian R L').has_min s hs
  have hKâ‚ƒ : K = âŠ¤ := by
    by_contra contra
    obtain âŸ¨K', hK'â‚, hK'â‚‚âŸ© := this K hKâ‚ contra
    exact hKâ‚‚ K' hK'â‚ hK'â‚‚
  exact hKâ‚ƒ â–¸ hKâ‚",rw [LieAlgebra.isEngelian_of_isNoetherian_of_isNoetherian]
Mathlib/Analysis/InnerProductSpace/Basic.lean,eq_of_norm_le_re_inner_eq_norm_sq,eq_of_norm_le_re_inner_eq_norm_sq,7529a8dd82ee9cd96b9be4733d8c4cd4bcd5f2a9,":= by
  suffices H : re âŸªx - y, x - yâŸ« â‰¤ 0
  Â· rwa [inner_self_nonpos, sub_eq_zero] at H
  have Hâ‚ : â€–xâ€– ^ 2 â‰¤ â€–yâ€– ^ 2 := by gcongr
  have Hâ‚‚ : re âŸªy, xâŸ« = â€–yâ€– ^ 2 := by rwa [â† inner_conj_symm, conj_re]
  simpa [inner_sub_left, inner_sub_right, â† norm_sq_eq_inner, h, Hâ‚‚] using Hâ‚",error:  unexpected token 'Â·'; expected 'by' or 'from',"theorem eq_of_norm_le_re_inner_eq_norm_sq {x y : E} (hle : â€–xâ€– â‰¤ â€–yâ€–) (h : re âŸªx, yâŸ« = â€–yâ€– ^ 2) :
    x = y ",":= by
  suffices H : re âŸªx - y, x - yâŸ« â‰¤ 0 by rwa [inner_self_nonpos, sub_eq_zero] at H
  have Hâ‚ : â€–xâ€– ^ 2 â‰¤ â€–yâ€– ^ 2 := by gcongr
  have Hâ‚‚ : re âŸªy, xâŸ« = â€–yâ€– ^ 2 := by rwa [â† inner_conj_symm, conj_re]
  simpa [inner_sub_left, inner_sub_right, â† norm_sq_eq_inner, h, Hâ‚‚] using Hâ‚",simp only [inner_self_eq_norm_le_re_inner_eq_norm_sq]
Mathlib/LinearAlgebra/Matrix/Transvection.lean,Matrix.Pivot.mul_listTransvecRow_last_row,mul_listTransvecRow_last_row,836ff98c79b1f367f60a02619e72140abcf77957,":= by
  suffices H :
    âˆ€ k : â„•,
      k â‰¤ r â†’
        (M * ((listTransvecRow M).take k).prod) (inr unit) (inl i) =
          if k â‰¤ i then M (inr unit) (inl i) else 0
  Â· have A : (listTransvecRow M).length = r := by simp [listTransvecRow]
    rw [â† List.take_length (listTransvecRow M), A]
    have : Â¬r â‰¤ i := by simp
    simpa only [this, ite_eq_right_iff] using H r le_rfl
  intro k hk
  induction' k with n IH
  Â· simp only [if_true, Matrix.mul_one, List.take_zero, zero_le', List.prod_nil, Nat.zero_eq]
  Â· have hnr : n < r := hk
    let n' : Fin r := âŸ¨n, hnrâŸ©
    have A :
      (listTransvecRow M).get? n =
        â†‘(transvection (inr unit) (inl n')
        (-M (inr unit) (inl n') / M (inr unit) (inr unit))) := by
      simp only [listTransvecRow, List.ofFnNthVal, hnr, dif_pos, List.get?_ofFn]
    simp only [List.take_succ, A, â† Matrix.mul_assoc, List.prod_append, Matrix.mul_one,
      List.prod_cons, List.prod_nil, Option.to_list_some]
    by_cases h : n' = i
    Â· have hni : n = i := by
        cases i
        simp only [Fin.mk_eq_mk] at h
        simp only [h]
      have : Â¬n.succ â‰¤ i := by simp only [â† hni, n.lt_succ_self, not_le]
      simp only [h, mul_transvection_apply_same, List.take, if_false,
        mul_listTransvecRow_last_col_take _ _ hnr.le, hni.le, this, if_true, IH hnr.le]
      field_simp [hM]
    Â· have hni : n â‰  i := by
        rintro rfl
        cases i
        tauto
      simp only [IH hnr.le, Ne.def, mul_transvection_apply_of_ne, Ne.symm h, inl.injEq,
        not_false_eq_true]
      rcases le_or_lt (n + 1) i with (hi | hi)
      Â· simp [hi, n.le_succ.trans hi, if_true]
      Â· rw [if_neg, if_neg]
        Â· simpa only [not_le] using hi
        Â· simpa only [hni.symm, not_le, or_false_iff] using Nat.lt_succ_iff_lt_or_eq.1 hi",error:  unexpected token 'Â·'; expected 'by' or 'from',"theorem mul_listTransvecRow_last_row (hM : M (inr unit) (inr unit) â‰  0) (i : Fin r) :
    (M * (listTransvecRow M).prod) (inr unit) (inl i) = 0 ",":= by
  suffices H :
    âˆ€ k : â„•,
      k â‰¤ r â†’
        (M * ((listTransvecRow M).take k).prod) (inr unit) (inl i) =
          if k â‰¤ i then M (inr unit) (inl i) else 0 by
    have A : (listTransvecRow M).length = r := by simp [listTransvecRow]
    rw [â† List.take_length (listTransvecRow M), A]
    have : Â¬r â‰¤ i := by simp
    simpa only [this, ite_eq_right_iff] using H r le_rfl
  intro k hk
  induction' k with n IH
  Â· simp only [if_true, Matrix.mul_one, List.take_zero, zero_le', List.prod_nil, Nat.zero_eq]
  Â· have hnr : n < r := hk
    let n' : Fin r := âŸ¨n, hnrâŸ©
    have A :
      (listTransvecRow M)[n]? =
        â†‘(transvection (inr unit) (inl n')
        (-M (inr unit) (inl n') / M (inr unit) (inr unit))) := by
      simp only [listTransvecRow, List.ofFnNthVal, hnr, dif_pos, List.getElem?_ofFn]
    simp only [List.take_succ, A, â† Matrix.mul_assoc, List.prod_append, Matrix.mul_one,
      List.prod_cons, List.prod_nil, Option.toList_some]
    by_cases h : n' = i
    Â· have hni : n = i := by
        cases i
        simp only [n', Fin.mk_eq_mk] at h
        simp only [h]
      have : Â¬n.succ â‰¤ i := by simp only [â† hni, n.lt_succ_self, not_le]
      simp only [h, mul_transvection_apply_same, List.take, if_false,
        mul_listTransvecRow_last_col_take _ _ hnr.le, hni.le, this, if_true, IH hnr.le]
      field_simp [hM]
    Â· have hni : n â‰  i := by
        rintro rfl
        cases i
        tauto
      simp only [IH hnr.le, Ne, mul_transvection_apply_of_ne, Ne.symm h, inl.injEq,
        not_false_eq_true]
      rcases le_or_lt (n + 1) i with (hi | hi)
      Â· simp [hi, n.le_succ.trans hi, if_true]
      Â· rw [if_neg, if_neg]
        Â· simpa only [not_le] using hi
        Â· simpa only [hni.symm, not_le, or_false_iff] using Nat.lt_succ_iff_lt_or_eq.1 hi",simp [listTransvecRow_last_row]
Mathlib/Computability/PartrecCode.lean,Nat.Partrec.Code.evaln_mono,evaln_mono,596865180ecc63dcd1d95809202e31027ac3ae38,"  | 0, kâ‚‚, c, n, x, _, h => by simp [evaln] at h
  | k + 1, kâ‚‚ + 1, c, n, x, hl, h => by
    have hl' := Nat.le_of_succ_le_succ hl
    have :
      âˆ€ {k kâ‚‚ n x : â„•} {oâ‚ oâ‚‚ : Option â„•},
        k â‰¤ kâ‚‚ â†’ (x âˆˆ oâ‚ â†’ x âˆˆ oâ‚‚) â†’
          x âˆˆ do { guard (n â‰¤ k); oâ‚ } â†’ x âˆˆ do { guard (n â‰¤ kâ‚‚); oâ‚‚ } := by
      simp only [Option.mem_def, bind, Option.bind_eq_some, Option.guard_eq_some', exists_and_left,
        exists_const, and_imp]
      introv h hâ‚ hâ‚‚ hâ‚ƒ
      exact âŸ¨le_trans hâ‚‚ h, hâ‚ hâ‚ƒâŸ©
    simp? at h âŠ¢ says simp only [Option.mem_def] at h âŠ¢
    induction' c with cf cg hf hg cf cg hf hg cf cg hf hg cf hf generalizing x n <;>
      rw [evaln] at h âŠ¢ <;> refine' this hl' (fun h => _) h
    iterate 4 exact h
    Â· 
      simp? [Seq.seq] at h âŠ¢ says
        simp only [Seq.seq, Option.map_eq_map, Option.mem_def, Option.bind_eq_some,
          Option.map_eq_some', exists_exists_and_eq_and] at h âŠ¢
      exact h.imp fun a => And.imp (hf _ _) <| Exists.imp fun b => And.imp_left (hg _ _)
    Â· 
      simp? [Bind.bind] at h âŠ¢ says simp only [bind, Option.mem_def, Option.bind_eq_some] at h âŠ¢
      exact h.imp fun a => And.imp (hg _ _) (hf _ _)
    Â· 
      revert h
      simp only [unpaired, bind, Option.mem_def]
      induction n.unpair.2 <;> simp
      Â· apply hf
      Â· exact fun y hâ‚ hâ‚‚ => âŸ¨y, evaln_mono hl' hâ‚, hg _ _ hâ‚‚âŸ©
    Â· 
      simp? [Bind.bind] at h âŠ¢ says
        simp only [unpaired, bind, pair_unpair, Option.pure_def, Option.mem_def,
          Option.bind_eq_some] at h âŠ¢
      refine h.imp fun x => And.imp (hf _ _) ?_
      by_cases x0 : x = 0 <;> simp [x0]
      exact evaln_mono hl'","error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  ?m.314376 y hâ‚ hâ‚‚
error:  type mismatch
  fun y hâ‚ hâ‚‚ â†¦ ?m.314377 y hâ‚ hâ‚‚
has type
  (y :
      ((evaln k (cf.prec cg) (Nat.pair (unpair n).1 nâœ)).bind fun i â†¦
          evaln (k + 1) cg (Nat.pair (unpair n).1 (Nat.pair nâœ i))) =
        some x) â†’
    (hâ‚ : ?m.314374 y) â†’ (hâ‚‚ : ?m.314375 y hâ‚) â†’ ?m.314376 y hâ‚ hâ‚‚ : Sort (imax ?u.314365 ?u.314368 ?u.314371)
but is expected to have type
  ((evaln k (cf.prec cg) (Nat.pair (unpair n).1 nâœ)).bind fun i â†¦
        evaln (k + 1) cg (Nat.pair (unpair n).1 (Nat.pair nâœ i))) =
      some x â†’
    ((evaln kâ‚‚ (cf.prec cg) (Nat.pair (unpair n).1 nâœ)).bind fun i â†¦
        evaln (kâ‚‚ + 1) cg (Nat.pair (unpair n).1 (Nat.pair nâœ i))) =
      some x : Prop","theorem evaln_mono : âˆ€ {kâ‚ kâ‚‚ c n x}, kâ‚ â‰¤ kâ‚‚ â†’ x âˆˆ evaln kâ‚ c n â†’ x âˆˆ evaln kâ‚‚ c n
","  | 0, kâ‚‚, c, n, x, _, h => by simp [evaln] at h
  | k + 1, kâ‚‚ + 1, c, n, x, hl, h => by
    have hl' := Nat.le_of_succ_le_succ hl
    have :
      âˆ€ {k kâ‚‚ n x : â„•} {oâ‚ oâ‚‚ : Option â„•},
        k â‰¤ kâ‚‚ â†’ (x âˆˆ oâ‚ â†’ x âˆˆ oâ‚‚) â†’
          x âˆˆ do { guard (n â‰¤ k); oâ‚ } â†’ x âˆˆ do { guard (n â‰¤ kâ‚‚); oâ‚‚ } := by
      simp only [Option.mem_def, bind, Option.bind_eq_some, Option.guard_eq_some', exists_and_left,
        exists_const, and_imp]
      introv h hâ‚ hâ‚‚ hâ‚ƒ
      exact âŸ¨le_trans hâ‚‚ h, hâ‚ hâ‚ƒâŸ©
    simp? at h âŠ¢ says simp only [Option.mem_def] at h âŠ¢
    induction' c with cf cg hf hg cf cg hf hg cf cg hf hg cf hf generalizing x n <;>
      rw [evaln] at h âŠ¢ <;> refine this hl' (fun h => ?_) h
    iterate 4 exact h
    Â· 
      simp? [Seq.seq, Option.bind_eq_some] at h âŠ¢ says
        simp only [Seq.seq, Option.map_eq_map, Option.mem_def, Option.bind_eq_some,
          Option.map_eq_some', exists_exists_and_eq_and] at h âŠ¢
      exact h.imp fun a => And.imp (hf _ _) <| Exists.imp fun b => And.imp_left (hg _ _)
    Â· 
      simp? [Bind.bind, Option.bind_eq_some] at h âŠ¢ says
        simp only [bind, Option.mem_def, Option.bind_eq_some] at h âŠ¢
      exact h.imp fun a => And.imp (hg _ _) (hf _ _)
    Â· 
      revert h
      simp only [unpaired, bind, Option.mem_def]
      induction n.unpair.2 <;> simp [Option.bind_eq_some]
      Â· apply hf
      Â· exact fun y hâ‚ hâ‚‚ => âŸ¨y, evaln_mono hl' hâ‚, hg _ _ hâ‚‚âŸ©
    Â· 
      simp? [Bind.bind, Option.bind_eq_some] at h âŠ¢ says
        simp only [unpaired, bind, pair_unpair, Option.pure_def, Option.mem_def,
          Option.bind_eq_some] at h âŠ¢
      refine h.imp fun x => And.imp (hf _ _) ?_
      by_cases x0 : x = 0 <;> simp [x0]
      exact evaln_mono hl'",refine evaln_mono evaln_mono (evaln_mono le_rfl ?_)
Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean,TopCat.fst_iso_of_right_embedding_range_subset,fst_iso_of_right_embedding_range_subset,fdfff7b3a618d890d340c3e3a74a9ad345cdf7b7,":= by
  let esto : (pullback f g : TopCat) â‰ƒâ‚œ X :=
    (fst_embedding_of_right_embedding f hg).toHomeomorph.trans
      { toFun := Subtype.val
        invFun := fun x =>
          âŸ¨x, by
            rw [pullback_fst_range]
            exact âŸ¨_, (H (Set.mem_range_self x)).choose_spec.symmâŸ©âŸ©
        left_inv := fun âŸ¨_, _âŸ© => rfl
        right_inv := fun x => rfl }
  convert IsIso.of_iso (isoOfHomeo esto)","error:  invalid field 'toHomeomorph', the environment does not contain 'Embedding.toHomeomorph'
  fst_embedding_of_right_embedding f hg
has type
  Embedding â‡‘pullback.fst
warning:  `CategoryTheory.IsIso.of_iso` has been deprecated, use `CategoryTheory.Iso.isIso_hom` instead
error:  unsolved goals
case h.e'_5
J : Type v
instâœ : SmallCategory J
Xâœ Yâœ Z : TopCat
X Y S : TopCat
f : X âŸ¶ S
g : Y âŸ¶ S
hg : Embedding â‡‘g
H : Set.range â‡‘f âŠ† Set.range â‡‘g
esto : â†‘(pullback f g) â‰ƒâ‚œ â†‘X := sorryAx (â†‘(pullback f g) â‰ƒâ‚œ â†‘X) true
âŠ¢ pullback.fst = (isoOfHomeo esto).hom","theorem fst_iso_of_right_embedding_range_subset {X Y S : TopCat} (f : X âŸ¶ S) {g : Y âŸ¶ S}
    (hg : Embedding g) (H : Set.range f âŠ† Set.range g) :
    IsIso (pullback.fst : pullback f g âŸ¶ X) ",":= by
  let esto : (pullback f g : TopCat) â‰ƒâ‚œ X :=
    (Homeomorph.ofEmbedding _ (fst_embedding_of_right_embedding f hg)).trans
      { toFun := Subtype.val
        invFun := fun x =>
          âŸ¨x, by
            rw [pullback_fst_range]
            exact âŸ¨_, (H (Set.mem_range_self x)).choose_spec.symmâŸ©âŸ©
        left_inv := fun âŸ¨_, _âŸ© => rfl
        right_inv := fun x => rfl }
  convert (isoOfHomeo esto).isIso_hom","have : IsIso (pullback.fst : pullback f g âŸ¶ X) := by
  rw [â† pullback.condition]
  infer_instance"
Mathlib/MeasureTheory/Measure/Regular.lean,MeasureTheory.Measure.InnerRegularWRT.isCompact_isClosed,isCompact_isClosed,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  intro F hF r hr
  set B : â„• â†’ Set X := compactCovering X
  have hBc : âˆ€ n, IsCompact (F âˆ© B n) := fun n => (isCompact_compactCovering X n).inter_left hF
  have hBU : â‹ƒ n, F âˆ© B n = F := by rw [â† inter_iUnion, iUnion_compactCovering, Set.inter_univ]
  have : Î¼ F = â¨† n, Î¼ (F âˆ© B n) := by
    rw [â† measure_iUnion_eq_iSup, hBU]
    exact Monotone.directed_le fun m n h => inter_subset_inter_right _ (compactCovering_subset _ h)
  rw [this] at hr
  rcases lt_iSup_iff.1 hr with âŸ¨n, hnâŸ©
  exact âŸ¨_, inter_subset_left _ _, hBc n, hnâŸ©","error:  function expected at
  inter_subset_left ?m.96224
term has type
  ?m.96223 âˆˆ ?m.96221","theorem isCompact_isClosed {X : Type*} [TopologicalSpace X] [SigmaCompactSpace X]
    [MeasurableSpace X] (Î¼ : Measure X) : InnerRegularWRT Î¼ IsCompact IsClosed ",":= by
  intro F hF r hr
  set B : â„• â†’ Set X := compactCovering X
  have hBc : âˆ€ n, IsCompact (F âˆ© B n) := fun n => (isCompact_compactCovering X n).inter_left hF
  have hBU : â‹ƒ n, F âˆ© B n = F := by rw [â† inter_iUnion, iUnion_compactCovering, Set.inter_univ]
  have : Î¼ F = â¨† n, Î¼ (F âˆ© B n) := by
    rw [â† measure_iUnion_eq_iSup, hBU]
    exact Monotone.directed_le fun m n h => inter_subset_inter_right _ (compactCovering_subset _ h)
  rw [this] at hr
  rcases lt_iSup_iff.1 hr with âŸ¨n, hnâŸ©
  exact âŸ¨_, inter_subset_left, hBc n, hnâŸ©","rw [InnerRegularWRT, InnerRegularWRT]"
Mathlib/Data/Finset/Basic.lean,Finset.union_subset_right,union_subset_right,48bda060b08a3013f32897b125fe26068de43109,":=
  Subset.trans (subset_union_right _ _) h","error:  function expected at
  subset_union_right ?m.84964
term has type
  ?m.84963 âˆˆ ?m.84961 âˆª ?m.84962",theorem union_subset_right {s t u : Finset Î±} (h : s âˆª t âŠ† u) : t âŠ† u ,":=
  Subset.trans subset_union_right h","rw [union_subset_right, union_subset_right]"
Mathlib/Data/Set/Finite.lean,Set.Finite.inter_of_left,Finite.inter_of_left,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  hs.subset <| inter_subset_left _ _","error:  function expected at
  inter_subset_left ?m.85047
term has type
  ?m.85046 âˆˆ ?m.85044",theorem Finite.inter_of_left {s : Set Î±} (hs : s.Finite) (t : Set Î±) : (s âˆ© t).Finite ,":=
  hs.subset inter_subset_left","refine Finite.inter_of_left {s : Set Î±, Finite.inter_of_left {s : Set Î±, Finite.inter_of_left {s : Set Î±, t} _) ?_"
Mathlib/MeasureTheory/Function/L1Space.lean,MeasureTheory.Integrable.measure_norm_ge_lt_top,Integrable.measure_norm_ge_lt_top,7dc162787d2a79bf721a83a87f641ace70251b17,":= by
  rw [show { x | Îµ â‰¤ â€–f xâ€– } = { x | ENNReal.ofReal Îµ â‰¤ â€–f xâ€–â‚Š } by
      simp only [ENNReal.ofReal, Real.toNNReal_le_iff_le_coe, ENNReal.coe_le_coe, coe_nnnorm]]
  refine' (meas_ge_le_mul_pow_snorm Î¼ one_ne_zero ENNReal.one_ne_top hf.1 _).trans_lt _
  Â· simpa only [Ne.def, ENNReal.ofReal_eq_zero, not_le] using hÎµ
  apply ENNReal.mul_lt_top
  Â· simpa only [ENNReal.one_toReal, ENNReal.rpow_one, Ne.def, ENNReal.inv_eq_top,
      ENNReal.ofReal_eq_zero, not_le] using hÎµ
  simpa only [ENNReal.one_toReal, ENNReal.rpow_one] using
    (memâ„’p_one_iff_integrable.2 hf).snorm_ne_top","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.221946 â†’ ?m.221946 â†’ Prop
error:  type mismatch
  hâœ
has type
  0 < Îµ : Prop
but is expected to have type
  ENNReal.ofReal Îµ â‰  0 : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.222058 â†’ ?m.222058 â†’ Prop
error:  type mismatch
  hâœ
has type
  0 < Îµ : Prop
but is expected to have type
  (ENNReal.ofReal Îµ)â»Â¹ â‰  âŠ¤ : Prop","theorem Integrable.measure_norm_ge_lt_top {f : Î± â†’ Î²} (hf : Integrable f Î¼) {Îµ : â„} (hÎµ : 0 < Îµ) :
    Î¼ { x | Îµ â‰¤ â€–f xâ€– } < âˆ ",":= by
  rw [show { x | Îµ â‰¤ â€–f xâ€– } = { x | ENNReal.ofReal Îµ â‰¤ â€–f xâ€–â‚Š } by
      simp only [ENNReal.ofReal, Real.toNNReal_le_iff_le_coe, ENNReal.coe_le_coe, coe_nnnorm]]
  refine (meas_ge_le_mul_pow_snorm Î¼ one_ne_zero ENNReal.one_ne_top hf.1 ?_).trans_lt ?_
  Â· simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hÎµ
  apply ENNReal.mul_lt_top
  Â· simpa only [ENNReal.one_toReal, ENNReal.rpow_one, Ne, ENNReal.inv_eq_top,
      ENNReal.ofReal_eq_zero, not_le] using hÎµ
  simpa only [ENNReal.one_toReal, ENNReal.rpow_one] using
    (memâ„’p_one_iff_integrable.2 hf).snorm_ne_top","simp only [measure_norm_ge_lt_top, Integrable.measure_norm_ge_lt_top]"
Mathlib/Analysis/Convex/StoneSeparation.lean,not_disjoint_segment_convexHull_triple,not_disjoint_segment_convexHull_triple,738b1a97e85d528d395f215b4057bad4704e2ceb,":= by
  rw [not_disjoint_iff]
  obtain âŸ¨az, bz, haz, hbz, habz, rflâŸ© := hz
  obtain rfl | haz' := haz.eq_or_lt
  Â· rw [zero_add] at habz
    rw [zero_smul, zero_add, habz, one_smul]
    refine' âŸ¨v, by apply right_mem_segment, segment_subset_convexHull _ _ hvâŸ© <;> simp
  obtain âŸ¨av, bv, hav, hbv, habv, rflâŸ© := hv
  obtain rfl | hav' := hav.eq_or_lt
  Â· rw [zero_add] at habv
    rw [zero_smul, zero_add, habv, one_smul]
    exact âŸ¨q, right_mem_segment _ _ _, subset_convexHull _ _ <| by simpâŸ©
  obtain âŸ¨au, bu, hau, hbu, habu, rflâŸ© := hu
  have hab : 0 < az * av + bz * au :=
    add_pos_of_pos_of_nonneg (mul_pos haz' hav') (mul_nonneg hbz hau)
  refine'
    âŸ¨(az * av / (az * av + bz * au)) â€¢ (au â€¢ x + bu â€¢ p) +
        (bz * au / (az * av + bz * au)) â€¢ (av â€¢ y + bv â€¢ q),
      âŸ¨_, _, _, _, _, rflâŸ©, _âŸ©
  Â· exact div_nonneg (mul_nonneg haz hav) hab.le
  Â· exact div_nonneg (mul_nonneg hbz hau) hab.le
  Â· rw [â† add_div, div_self hab.ne']
  rw [smul_add, smul_add, add_add_add_comm, add_comm, â† mul_smul, â† mul_smul]
  classical
    let w : Fin 3 â†’ ğ•œ := ![az * av * bu, bz * au * bv, au * av]
    let z : Fin 3 â†’ E := ![p, q, az â€¢ x + bz â€¢ y]
    have hwâ‚€ : âˆ€ i, 0 â‰¤ w i := by
      rintro i
      fin_cases i
      Â· exact mul_nonneg (mul_nonneg haz hav) hbu
      Â· exact mul_nonneg (mul_nonneg hbz hau) hbv
      Â· exact mul_nonneg hau hav
    have hw : âˆ‘ i, w i = az * av + bz * au := by
      trans az * av * bu + (bz * au * bv + au * av)
      Â· simp [Fin.sum_univ_succ, Fin.sum_univ_zero]
      rw [â† one_mul (au * av), â† habz, add_mul, â† add_assoc, add_add_add_comm, mul_assoc, â† mul_add,
        mul_assoc, â† mul_add, mul_comm av, â† add_mul, â† mul_add, add_comm bu, add_comm bv, habu,
        habv, one_mul, mul_one]
    have hz : âˆ€ i, z i âˆˆ ({p, q, az â€¢ x + bz â€¢ y} : Set E) := fun i => by fin_cases i <;> simp
    convert Finset.centerMass_mem_convexHull (Finset.univ : Finset (Fin 3)) (fun i _ => hwâ‚€ i)
        (by rwa [hw]) fun i _ => hz i
    rw [Finset.centerMass]
    simp_rw [div_eq_inv_mul, hw, mul_assoc, mul_smul (az * av + bz * au)â»Â¹, â† smul_add, add_assoc, â†
      mul_assoc]
    congr 3
    rw [â† mul_smul, â† mul_rotate, mul_right_comm, mul_smul, â† mul_smul _ av, mul_rotate,
      mul_smul _ bz, â† smul_add]
    simp only [smul_add, List.foldr, Matrix.cons_val_succ', Fin.mk_one,
      Matrix.cons_val_one, Matrix.head_cons, add_zero]","error:  unsolved goals
ğ•œ : Type u_1
E : Type u_2
Î¹ : Type u_3
instâœÂ² : LinearOrderedField ğ•œ
instâœÂ¹ : AddCommGroup E
instâœ : Module ğ•œ E
s t : Set E
p q x y : E
az bz : ğ•œ
haz : 0 â‰¤ az
hbz : 0 â‰¤ bz
habz : az + bz = 1
haz' : 0 < az
av bv : ğ•œ
hav : 0 â‰¤ av
hbv : 0 â‰¤ bv
habv : av + bv = 1
hav' : 0 < av
au bu : ğ•œ
hau : 0 â‰¤ au
hbu : 0 â‰¤ bu
habu : au + bu = 1
hab : 0 < az * av + bz * au
w : Fin 3 â†’ ğ•œ := ![az * av * bu, bz * au * bv, au * av]
z : Fin 3 â†’ E := ![p, q, az â€¢ x + bz â€¢ y]
hwâ‚€ : âˆ€ (i : Fin 3), 0 â‰¤ w i
âŠ¢ w 0 + (w 1 + w 2) = az * av * bu + (bz * au * bv + au * av)
error:  unsolved goals
case head
ğ•œ : Type u_1
E : Type u_2
Î¹ : Type u_3
instâœÂ² : LinearOrderedField ğ•œ
instâœÂ¹ : AddCommGroup E
instâœ : Module ğ•œ E
s t : Set E
p q x y : E
az bz : ğ•œ
haz : 0 â‰¤ az
hbz : 0 â‰¤ bz
habz : az + bz = 1
haz' : 0 < az
av bv : ğ•œ
hav : 0 â‰¤ av
hbv : 0 â‰¤ bv
habv : av + bv = 1
hav' : 0 < av
au bu : ğ•œ
hau : 0 â‰¤ au
hbu : 0 â‰¤ bu
habu : au + bu = 1
hab : 0 < az * av + bz * au
w : Fin 3 â†’ ğ•œ := ![az * av * bu, bz * au * bv, au * av]
z : Fin 3 â†’ E := ![p, q, az â€¢ x + bz â€¢ y]
hwâ‚€ : âˆ€ (i : Fin 3), 0 â‰¤ w i
hw : âˆ‘ i : Fin 3, w i = az * av + bz * au
âŠ¢ z 0 = p âˆ¨ z 0 = q âˆ¨ z 0 = az â€¢ x + bz â€¢ y

case tail.head
ğ•œ : Type u_1
E : Type u_2
Î¹ : Type u_3
instâœÂ² : LinearOrderedField ğ•œ
instâœÂ¹ : AddCommGroup E
instâœ : Module ğ•œ E
s t : Set E
p q x y : E
az bz : ğ•œ
haz : 0 â‰¤ az
hbz : 0 â‰¤ bz
habz : az + bz = 1
haz' : 0 < az
av bv : ğ•œ
hav : 0 â‰¤ av
hbv : 0 â‰¤ bv
habv : av + bv = 1
hav' : 0 < av
au bu : ğ•œ
hau : 0 â‰¤ au
hbu : 0 â‰¤ bu
habu : au + bu = 1
hab : 0 < az * av + bz * au
w : Fin 3 â†’ ğ•œ := ![az * av * bu, bz * au * bv, au * av]
z : Fin 3 â†’ E := ![p, q, az â€¢ x + bz â€¢ y]
hwâ‚€ : âˆ€ (i : Fin 3), 0 â‰¤ w i
hw : âˆ‘ i : Fin 3, w i = az * av + bz * au
âŠ¢ z 1 = p âˆ¨ z 1 = q âˆ¨ z 1 = az â€¢ x + bz â€¢ y

case tail.tail.head
ğ•œ : Type u_1
E : Type u_2
Î¹ : Type u_3
instâœÂ² : LinearOrderedField ğ•œ
instâœÂ¹ : AddCommGroup E
instâœ : Module ğ•œ E
s t : Set E
p q x y : E
az bz : ğ•œ
haz : 0 â‰¤ az
hbz : 0 â‰¤ bz
habz : az + bz = 1
haz' : 0 < az
av bv : ğ•œ
hav : 0 â‰¤ av
hbv : 0 â‰¤ bv
habv : av + bv = 1
hav' : 0 < av
au bu : ğ•œ
hau : 0 â‰¤ au
hbu : 0 â‰¤ bu
habu : au + bu = 1
hab : 0 < az * av + bz * au
w : Fin 3 â†’ ğ•œ := ![az * av * bu, bz * au * bv, au * av]
z : Fin 3 â†’ E := ![p, q, az â€¢ x + bz â€¢ y]
hwâ‚€ : âˆ€ (i : Fin 3), 0 â‰¤ w i
hw : âˆ‘ i : Fin 3, w i = az * av + bz * au
âŠ¢ z 2 = p âˆ¨ z 2 = q âˆ¨ z 2 = az â€¢ x + bz â€¢ y
error:  unsolved goals
case h.e'_4.e_a.e_a.e_a
ğ•œ : Type u_1
E : Type u_2
Î¹ : Type u_3
instâœÂ² : LinearOrderedField ğ•œ
instâœÂ¹ : AddCommGroup E
instâœ : Module ğ•œ E
s t : Set E
p q x y : E
az bz : ğ•œ
haz : 0 â‰¤ az
hbz : 0 â‰¤ bz
habz : az + bz = 1
haz' : 0 < az
av bv : ğ•œ
hav : 0 â‰¤ av
hbv : 0 â‰¤ bv
habv : av + bv = 1
hav' : 0 < av
au bu : ğ•œ
hau : 0 â‰¤ au
hbu : 0 â‰¤ bu
habu : au + bu = 1
hab : 0 < az * av + bz * au
w : Fin 3 â†’ ğ•œ := ![az * av * bu, bz * au * bv, au * av]
z : Fin 3 â†’ E := ![p, q, az â€¢ x + bz â€¢ y]
hwâ‚€ : âˆ€ (i : Fin 3), 0 â‰¤ w i
hw : âˆ‘ i : Fin 3, w i = az * av + bz * au
hz : âˆ€ (i : Fin 3), z i âˆˆ {p, q, az â€¢ x + bz â€¢ y}
âŠ¢ (au * av) â€¢ az â€¢ x + (au * av) â€¢ bz â€¢ y = w âŸ¨2, â‹¯âŸ© â€¢ z âŸ¨2, â‹¯âŸ©","theorem not_disjoint_segment_convexHull_triple {p q u v x y z : E} (hz : z âˆˆ segment ğ•œ x y)
    (hu : u âˆˆ segment ğ•œ x p) (hv : v âˆˆ segment ğ•œ y q) :
    Â¬Disjoint (segment ğ•œ u v) (convexHull ğ•œ {p, q, z}) ",":= by
  rw [not_disjoint_iff]
  obtain âŸ¨az, bz, haz, hbz, habz, rflâŸ© := hz
  obtain rfl | haz' := haz.eq_or_lt
  Â· rw [zero_add] at habz
    rw [zero_smul, zero_add, habz, one_smul]
    refine âŸ¨v, by apply right_mem_segment, segment_subset_convexHull ?_ ?_ hvâŸ© <;> simp
  obtain âŸ¨av, bv, hav, hbv, habv, rflâŸ© := hv
  obtain rfl | hav' := hav.eq_or_lt
  Â· rw [zero_add] at habv
    rw [zero_smul, zero_add, habv, one_smul]
    exact âŸ¨q, right_mem_segment _ _ _, subset_convexHull _ _ <| by simpâŸ©
  obtain âŸ¨au, bu, hau, hbu, habu, rflâŸ© := hu
  have hab : 0 < az * av + bz * au := by positivity
  refine âŸ¨(az * av / (az * av + bz * au)) â€¢ (au â€¢ x + bu â€¢ p) +
    (bz * au / (az * av + bz * au)) â€¢ (av â€¢ y + bv â€¢ q), âŸ¨_, _, ?_, ?_, ?_, rflâŸ©, ?_âŸ©
  Â· positivity
  Â· positivity
  Â· rw [â† add_div, div_self]; positivity
  rw [smul_add, smul_add, add_add_add_comm, add_comm, â† mul_smul, â† mul_smul]
  classical
    let w : Fin 3 â†’ ğ•œ := ![az * av * bu, bz * au * bv, au * av]
    let z : Fin 3 â†’ E := ![p, q, az â€¢ x + bz â€¢ y]
    have hwâ‚€ : âˆ€ i, 0 â‰¤ w i := by
      rintro i
      fin_cases i
      Â· exact mul_nonneg (mul_nonneg haz hav) hbu
      Â· exact mul_nonneg (mul_nonneg hbz hau) hbv
      Â· exact mul_nonneg hau hav
    have hw : âˆ‘ i, w i = az * av + bz * au := by
      trans az * av * bu + (bz * au * bv + au * av)
      Â· simp [w, Fin.sum_univ_succ, Fin.sum_univ_zero]
      rw [â† one_mul (au * av), â† habz, add_mul, â† add_assoc, add_add_add_comm, mul_assoc, â† mul_add,
        mul_assoc, â† mul_add, mul_comm av, â† add_mul, â† mul_add, add_comm bu, add_comm bv, habu,
        habv, one_mul, mul_one]
    have hz : âˆ€ i, z i âˆˆ ({p, q, az â€¢ x + bz â€¢ y} : Set E) := fun i => by fin_cases i <;> simp [z]
    convert Finset.centerMass_mem_convexHull (Finset.univ : Finset (Fin 3)) (fun i _ => hwâ‚€ i)
        (by rwa [hw]) fun i _ => hz i
    rw [Finset.centerMass]
    simp_rw [div_eq_inv_mul, hw, mul_assoc, mul_smul (az * av + bz * au)â»Â¹, â† smul_add, add_assoc, â†
      mul_assoc]
    congr 3
    rw [â† mul_smul, â† mul_rotate, mul_right_comm, mul_smul, â† mul_smul _ av, mul_rotate,
      mul_smul _ bz, â† smul_add]
    simp only [w, z, smul_add, List.foldr, Matrix.cons_val_succ', Fin.mk_one,
      Matrix.cons_val_one, Matrix.head_cons, add_zero]","simp only [mem_segment, not_disjoint_segment_convexHull_triple, not_disjoint_segment_convexHull_triple]"
Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean,Real.Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma,Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  let f : â„ â†’ â„ â†’ â„ â†’ â„ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjugateExponent (1 / a) (1 / b) := Real.isConjugateExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : âˆ€ c u x : â„, x âˆˆ Ioi (0 : â„) â†’ 0 â‰¤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : âˆ€ c u : â„, âˆ€áµ x : â„ âˆ‚volume.restrict (Ioi 0), 0 â‰¤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    âˆ€ {c x : â„} (_ : 0 < c) (u : â„) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg_of_nonneg hx.le) _), â† exp_mul, â† rpow_mul hx.le]
    congr 2 <;> Â· field_simp [hc.ne']; ring
  have f_mem_Lp :
    âˆ€ {c u : â„} (hc : 0 < c) (hu : 0 < u),
      Memâ„’p (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) â‰  0 := by
      rwa [Ne.def, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) â‰  âˆ := ENNReal.ofReal_ne_top
    rw [â† memâ„’p_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memâ„’p_one_iff_integrable]
    Â· apply Integrable.congr (GammaIntegral_convergent hu)
      refine' eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => _
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    Â· refine' ContinuousOn.aestronglyMeasurable _ measurableSet_Ioi
      refine' (Continuous.continuousOn _).mul (ContinuousAt.continuousOn fun x hx => _)
      Â· exact continuous_exp.comp (continuous_const.mul continuous_id')
      Â· exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  Â· refine' set_integral_congr measurableSet_Ioi fun x hx => _
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [â† exp_add, â† add_mul, â† neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [â† rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  Â· rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact set_integral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx","error:  unknown identifier 'IsConjugateExponent'
error:  unknown constant 'Real.isConjugateExponent_one_div'
error:  dsimp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.29851 â†’ ?m.29851 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.29853
s t a b : â„
hs : 0 < s
ht : 0 < t
ha : 0 < a
hb : 0 < b
hab : a + b = 1
f : â„ â†’ â„ â†’ â„ â†’ â„ := fun c u x â†¦ rexp (-c * x) * x ^ (c * (u - 1))
e : sorryAx (Sort ?u.25388) true
hab' : b = 1 - a
hst : 0 < a * s + b * t
posf : âˆ€ (c u x : â„), x âˆˆ Ioi 0 â†’ 0 â‰¤ f c u x
posf' : âˆ€ (c u : â„), âˆ€áµ (x : â„) âˆ‚volume.restrict (Ioi 0), 0 â‰¤ f c u x
fpow : âˆ€ {c x : â„}, 0 < c â†’ âˆ€ (u : â„), 0 < x â†’ rexp (-x) * x ^ (u - 1) = f c u x ^ (1 / c)
c u : â„
hc : 0 < c
hu : 0 < u
âŠ¢ ENNReal.ofReal (1 / c) â‰  0
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
error:  invalid occurrence of universe level 'u_1' at 'Real.convexOn_log_Gamma', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma.{u_1}
    (Eq.mp.{0} Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup._auxLemma.1.{0} hx)
    (Eq.mp.{0} Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup._auxLemma.1.{0} hy) ha hb hab
at declaration body
  convexOn_iff_forall_pos.mpr
    âŸ¨convex_Ioi 0,
      fun (x : â„) (hx : x âˆˆ Ioi 0) (y : â„) (hy : y âˆˆ Ioi 0) (a b : â„) (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) â†¦
      let_fun this : b = 1 - a :=
        Linarith.eq_of_not_lt_of_not_gt b (1 - a)
          (Not.intro fun (a_1 : b < 1 - a) â†¦
            Linarith.lt_irrefl
              (Eq.mp
                (congrArg (fun (_a : â„) â†¦ _a < 0)
                  (Mathlib.Tactic.Ring.of_eq
                    (Mathlib.Tactic.Ring.add_congr
                      (Mathlib.Tactic.Ring.neg_congr
                        (Mathlib.Tactic.Ring.sub_congr
                          (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf b)
                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)
                              (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))
                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat â„ Nat.cast_one))
                          (Mathlib.Tactic.Ring.sub_pf
                            (Mathlib.Tactic.Ring.neg_add
                              (Mathlib.Tactic.Ring.neg_one_mul
                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq
                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)
                                    (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1))
                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw â„ 1))
                                    (Eq.refl (Int.negOfNat 1)))))
                              Mathlib.Tactic.Ring.neg_zero)
                            (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast
                              (Mathlib.Tactic.Ring.add_pf_add_zero
                                (a ^ Nat.rawCast 1 * Nat.rawCast 1 + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))
                        (Mathlib.Tactic.Ring.neg_add
                          (Mathlib.Tactic.Ring.neg_one_mul
                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq
                              (Mathlib.Meta.NormNum.IsInt.to_isNat
                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)
                                  (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1))
                                  (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))
                          (Mathlib.Tactic.Ring.neg_add
                            (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)
                              (Mathlib.Tactic.Ring.neg_one_mul
                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq
                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)
                                    (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1))
                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw â„ 1))
                                    (Eq.refl (Int.negOfNat 1))))))
                            (Mathlib.Tactic.Ring.neg_add
                              (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)
                                (Mathlib.Tactic.Ring.neg_one_mul
                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq
                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)
                                      (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1))
                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw â„ 1))
                                      (Eq.refl (Int.negOfNat 1))))))
                              Mathlib.Tactic.Ring.neg_zero))))
                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b)
                        (Mathlib.Tactic.Ring.sub_congr
                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat â„ Nat.cast_one))
                          (Mathlib.Tactic.Ring.atom_pf a)
                          (Mathlib.Tactic.Ring.sub_pf
                            (Mathlib.Tactic.Ring.neg_add
                              (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)
                                (Mathlib.Tactic.Ring.neg_one_mul
                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq
                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)
                                      (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1))
                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw â„ 1))
                                      (Eq.refl (Int.negOfNat 1))))))
                              Mathlib.Tactic.Ring.neg_zero)
                            (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)
                              (Mathlib.Tactic.Ring.add_pf_zero_add
                                (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))
                        (Mathlib.Tactic.Ring.sub_pf
                          (Mathlib.Tactic.Ring.neg_add
                            (Mathlib.Tactic.Ring.neg_one_mul
                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq
                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)
                                  (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1))
                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw â„ 1))
                                  (Eq.refl (Int.negOfNat 1)))))
                            (Mathlib.Tactic.Ring.neg_add
                              (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)
                                (Mathlib.Tactic.Ring.neg_one_mul
                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq
                                    (Mathlib.Meta.NormNum.IsInt.to_isNat
                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)
                                        (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1))
                                        (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1))
                                        (Eq.refl (Int.ofNat 1)))))))
                              Mathlib.Tactic.Ring.neg_zero))
                          (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast
                            (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * Nat.rawCast 1)
                              (Mathlib.Tactic.Ring.add_pf_add_zero (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))
                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero
                        (Mathlib.Meta.NormNum.IsInt.to_isNat
                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)
                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw â„ 1))
                            (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0))))
                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero
                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)
                            (Mathlib.Meta.NormNum.IsInt.to_isNat
                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)
                                (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1))
                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw â„ 1))
                                (Eq.refl (Int.ofNat 0)))))
                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero
                            (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)
                              (Mathlib.Meta.NormNum.IsInt.to_isNat
                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)
                                  (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1))
                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw â„ 1))
                                  (Eq.refl (Int.ofNat 0)))))
                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))
                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat â„ Nat.cast_zero))))
                (Linarith.lt_of_eq_of_lt (neg_eq_zero.mpr (sub_eq_zero_of_eq hab)) (sub_neg_of_lt a_1))))
          (Not.intro fun (a_1 : 1 - a < b) â†¦
            Linarith.lt_irrefl
              (Eq.mp
                (congrArg (fun (_a : â„) â†¦ _a < 0)
                  (Mathlib.Tactic.Ring.of_eq
                    (Mathlib.Tactic.Ring.add_congr
                      (Mathlib.Tactic.Ring.sub_congr
                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf b)
                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)
                            (Mathlib.Tactic.Ring.add_pf_zero_add (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))
                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat â„ Nat.cast_one))
                        (Mathlib.Tactic.Ring.sub_pf
                          (Mathlib.Tactic.Ring.neg_add
                            (Mathlib.Tactic.Ring.neg_one_mul
                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq
                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)
                                  (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1))
                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw â„ 1))
                                  (Eq.refl (Int.negOfNat 1)))))
                            Mathlib.Tactic.Ring.neg_zero)
                          (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast
                            (Mathlib.Tactic.Ring.add_pf_add_zero
                              (a ^ Nat.rawCast 1 * Nat.rawCast 1 + (b ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))
                      (Mathlib.Tactic.Ring.sub_congr
                        (Mathlib.Tactic.Ring.sub_congr
                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat â„ Nat.cast_one))
                          (Mathlib.Tactic.Ring.atom_pf a)
                          (Mathlib.Tactic.Ring.sub_pf
                            (Mathlib.Tactic.Ring.neg_add
                              (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)
                                (Mathlib.Tactic.Ring.neg_one_mul
                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq
                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)
                                      (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1))
                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw â„ 1))
                                      (Eq.refl (Int.negOfNat 1))))))
                              Mathlib.Tactic.Ring.neg_zero)
                            (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)
                              (Mathlib.Tactic.Ring.add_pf_zero_add
                                (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))
                        (Mathlib.Tactic.Ring.atom_pf b)
                        (Mathlib.Tactic.Ring.sub_pf
                          (Mathlib.Tactic.Ring.neg_add
                            (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)
                              (Mathlib.Tactic.Ring.neg_one_mul
                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq
                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)
                                    (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1))
                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw â„ 1))
                                    (Eq.refl (Int.negOfNat 1))))))
                            Mathlib.Tactic.Ring.neg_zero)
                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)
                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)
                              (Mathlib.Tactic.Ring.add_pf_zero_add
                                (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))
                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero
                        (Mathlib.Meta.NormNum.IsInt.to_isNat
                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)
                            (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1))
                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw â„ 1))
                            (Eq.refl (Int.ofNat 0))))
                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero
                          (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)
                            (Mathlib.Meta.NormNum.IsInt.to_isNat
                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)
                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw â„ 1))
                                (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))
                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero
                            (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)
                              (Mathlib.Meta.NormNum.IsInt.to_isNat
                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)
                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw â„ 1))
                                  (Mathlib.Meta.NormNum.IsInt.of_raw â„ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))
                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))
                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat â„ Nat.cast_zero))))
                (Linarith.lt_of_eq_of_lt (sub_eq_zero_of_eq hab) (sub_neg_of_lt a_1))));
      Eq.ndrec (motive := fun (b : â„) â†¦
        0 < b â†’ a + b = 1 â†’ (log âˆ˜ Gamma) (a â€¢ x + b â€¢ y) â‰¤ a â€¢ (log âˆ˜ Gamma) x + b â€¢ (log âˆ˜ Gamma) y)
        (fun (hb : 0 < 1 - a) (hab : a + (1 - a) = 1) â†¦
          id
            (id
              (Eq.mpr
                (id
                  (congrArg (fun (_a : â„) â†¦ log (Gamma (a * x + (1 - a) * y)) â‰¤ _a + (1 - a) * log (Gamma y))
                    (Eq.symm
                      (log_rpow
                        (Gamma_pos_of_pos (Eq.mp Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup._auxLemma.1 hx))
                        a))))
                (Eq.mpr
                  (id
                    (congrArg (fun (_a : â„) â†¦ log (Gamma (a * x + (1 - a) * y)) â‰¤ log (Gamma x ^ a) + _a)
                      (Eq.symm
                        (log_rpow
                          (Gamma_pos_of_pos (Eq.mp Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup._auxLemma.1 hy))
                          (1 - a)))))
                  (Eq.mpr
                    (id
                      (congrArg (fun (_a : â„) â†¦ log (Gamma (a * x + (1 - a) * y)) â‰¤ _a)
                        (Eq.symm
                          (log_mul
                            (ne_of_gt
                              (rpow_pos_of_pos
                                (Gamma_pos_of_pos
                                  (Eq.mp Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup._auxLemma.1 hx))
                                a))
                            (ne_of_gt
                              (rpow_pos_of_pos
                                (Gamma_pos_of_pos
                                  (Eq.mp Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup._auxLemma.1 hy))
                                (1 - a)))))))
                    (log_le_log
                      (Gamma_pos_of_pos
                        (add_pos
                          (mul_pos ha (Eq.mp Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup._auxLemma.1 hx))
                          (mul_pos hb (Eq.mp Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup._auxLemma.1 hy))))
                      (Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma
                        (Eq.mp Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup._auxLemma.1 hx)
                        (Eq.mp Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup._auxLemma.1 hy) ha hb hab)))))))
        (Eq.symm this) hb habâŸ©
error:  unknown identifier 'convexOn_log_Gamma'
error:  unknown identifier 'convexOn_log_Gamma'
error:  unknown identifier 'convexOn_log_Gamma'
error:  unsolved goals
A : 0 < 3 / 2
âŠ¢ Gamma (3 / 2) < 1
error:  unknown identifier 'convexOn_log_Gamma.comp_affineMap'
error:  no goals to be solved
error:  unknown identifier 'convexOn_log_Gamma.comp_affineMap'
error:  no goals to be solved","theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : â„} (hs : 0 < s) (ht : 0 < t)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    Gamma (a * s + b * t) â‰¤ Gamma s ^ a * Gamma t ^ b ",":= by
  let f : â„ â†’ â„ â†’ â„ â†’ â„ := fun c u x => exp (-c * x) * x ^ (c * (u - 1))
  have e : IsConjExponent (1 / a) (1 / b) := Real.isConjExponent_one_div ha hb hab
  have hab' : b = 1 - a := by linarith
  have hst : 0 < a * s + b * t := add_pos (mul_pos ha hs) (mul_pos hb ht)
  have posf : âˆ€ c u x : â„, x âˆˆ Ioi (0 : â„) â†’ 0 â‰¤ f c u x := fun c u x hx =>
    mul_nonneg (exp_pos _).le (rpow_pos_of_pos hx _).le
  have posf' : âˆ€ c u : â„, âˆ€áµ x : â„ âˆ‚volume.restrict (Ioi 0), 0 â‰¤ f c u x := fun c u =>
    (ae_restrict_iff' measurableSet_Ioi).mpr (ae_of_all _ (posf c u))
  have fpow :
    âˆ€ {c x : â„} (_ : 0 < c) (u : â„) (_ : 0 < x), exp (-x) * x ^ (u - 1) = f c u x ^ (1 / c) := by
    intro c x hc u hx
    dsimp only [f]
    rw [mul_rpow (exp_pos _).le ((rpow_nonneg hx.le) _), â† exp_mul, â† rpow_mul hx.le]
    congr 2 <;> field_simp [hc.ne']; ring
  have f_mem_Lp :
    âˆ€ {c u : â„} (hc : 0 < c) (hu : 0 < u),
      Memâ„’p (f c u) (ENNReal.ofReal (1 / c)) (volume.restrict (Ioi 0)) := by
    intro c u hc hu
    have A : ENNReal.ofReal (1 / c) â‰  0 := by
      rwa [Ne, ENNReal.ofReal_eq_zero, not_le, one_div_pos]
    have B : ENNReal.ofReal (1 / c) â‰  âˆ := ENNReal.ofReal_ne_top
    rw [â† memâ„’p_norm_rpow_iff _ A B, ENNReal.toReal_ofReal (one_div_nonneg.mpr hc.le),
      ENNReal.div_self A B, memâ„’p_one_iff_integrable]
    Â· apply Integrable.congr (GammaIntegral_convergent hu)
      refine eventuallyEq_of_mem (self_mem_ae_restrict measurableSet_Ioi) fun x hx => ?_
      dsimp only
      rw [fpow hc u hx]
      congr 1
      exact (norm_of_nonneg (posf _ _ x hx)).symm
    Â· refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
      refine (Continuous.continuousOn ?_).mul (ContinuousAt.continuousOn fun x hx => ?_)
      Â· exact continuous_exp.comp (continuous_const.mul continuous_id')
      Â· exact continuousAt_rpow_const _ _ (Or.inl (mem_Ioi.mp hx).ne')
  rw [Gamma_eq_integral hs, Gamma_eq_integral ht, Gamma_eq_integral hst]
  convert
    MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg e (posf' a s) (posf' b t) (f_mem_Lp ha hs)
      (f_mem_Lp hb ht) using
    1
  Â· refine setIntegral_congr measurableSet_Ioi fun x hx => ?_
    dsimp only
    have A : exp (-x) = exp (-a * x) * exp (-b * x) := by
      rw [â† exp_add, â† add_mul, â† neg_add, hab, neg_one_mul]
    have B : x ^ (a * s + b * t - 1) = x ^ (a * (s - 1)) * x ^ (b * (t - 1)) := by
      rw [â† rpow_add hx, hab']; congr 1; ring
    rw [A, B]
    ring
  Â· rw [one_div_one_div, one_div_one_div]
    congr 2 <;> exact setIntegral_congr measurableSet_Ioi fun x hx => fpow (by assumption) _ hx","rw [Gamma_mul_add_mul_le_rpow_Gamma_mul_add_mul_le_rpow_Gamma_mul_add_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma
  s t a b hs ht hs ht ht hab, Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma
  s t a b ht ha hb hab, Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow_Gamma_mul_rpow]"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,HolderOnWith.hausdorffMeasure_image_le,hausdorffMeasure_image_le,3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine' ENNReal.tsum_le_tsum fun n => _
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left s) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set X : Type u_2
but is expected to have type
  ?m.169595 âˆˆ t n âˆ© ?m.169594 : Prop
error:  simp made no progress","theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s ",":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","rw [â† hausdorffMeasure_image_le, hausdorffMeasure_image_le, hausdorffMeasure_image_le]"
Mathlib/Topology/Semicontinuous.lean,LowerSemicontinuousWithinAt.add',LowerSemicontinuousWithinAt.add',200b13c6bec9232f07d98e431a27afa078e8f986,":= by
  rw [lowerSemicontinuousWithinAt_iff_eventually_lt] at hf hg âŠ¢
  intro y hy
  obtain âŸ¨u, v, u_open, xu, v_open, xv, hâŸ© :
    âˆƒ u v : Set Î³,
      IsOpen u âˆ§ f x âˆˆ u âˆ§ IsOpen v âˆ§ g x âˆˆ v âˆ§ u Ã—Ë¢ v âŠ† { p : Î³ Ã— Î³ | y < p.fst + p.snd } :=
    mem_nhds_prod_iff'.1 (hcont (isOpen_Ioi.mem_nhds hy))
  by_cases hxâ‚ : âˆƒ l, l < f x
  Â· obtain âŸ¨zâ‚, zâ‚lt, hâ‚âŸ© : âˆƒ zâ‚ < f x, Ioc zâ‚ (f x) âŠ† u :=
      exists_Ioc_subset_of_mem_nhds (u_open.mem_nhds xu) hxâ‚
    by_cases hxâ‚‚ : âˆƒ l, l < g x
    Â· obtain âŸ¨zâ‚‚, zâ‚‚lt, hâ‚‚âŸ© : âˆƒ zâ‚‚ < g x, Ioc zâ‚‚ (g x) âŠ† v :=
        exists_Ioc_subset_of_mem_nhds (v_open.mem_nhds xv) hxâ‚‚
      filter_upwards [hf zâ‚ zâ‚lt, hg zâ‚‚ zâ‚‚lt] with z hâ‚z hâ‚‚z
      have A1 : min (f z) (f x) âˆˆ u := by
        by_cases H : f z â‰¤ f x
        Â· simp [H]
          exact hâ‚ âŸ¨hâ‚z, HâŸ©
        Â· simp [le_of_not_le H]
          exact hâ‚ âŸ¨zâ‚lt, le_rflâŸ©
      have A2 : min (g z) (g x) âˆˆ v := by
        by_cases H : g z â‰¤ g x
        Â· simp [H]
          exact hâ‚‚ âŸ¨hâ‚‚z, HâŸ©
        Â· simp [le_of_not_le H]
          exact hâ‚‚ âŸ¨zâ‚‚lt, le_rflâŸ©
      have : (min (f z) (f x), min (g z) (g x)) âˆˆ u Ã—Ë¢ v := âŸ¨A1, A2âŸ©
      calc
        y < min (f z) (f x) + min (g z) (g x) := h this
        _ â‰¤ f z + g z := add_le_add (min_le_left _ _) (min_le_left _ _)

    Â· simp only [not_exists, not_lt] at hxâ‚‚
      filter_upwards [hf zâ‚ zâ‚lt] with z hâ‚z
      have A1 : min (f z) (f x) âˆˆ u := by
        by_cases H : f z â‰¤ f x
        Â· simp [H]
          exact hâ‚ âŸ¨hâ‚z, HâŸ©
        Â· simp [le_of_not_le H]
          exact hâ‚ âŸ¨zâ‚lt, le_rflâŸ©
      have : (min (f z) (f x), g x) âˆˆ u Ã—Ë¢ v := âŸ¨A1, xvâŸ©
      calc
        y < min (f z) (f x) + g x := h this
        _ â‰¤ f z + g z := add_le_add (min_le_left _ _) (hxâ‚‚ (g z))

  Â· simp only [not_exists, not_lt] at hxâ‚
    by_cases hxâ‚‚ : âˆƒ l, l < g x
    Â· obtain âŸ¨zâ‚‚, zâ‚‚lt, hâ‚‚âŸ© : âˆƒ zâ‚‚ < g x, Ioc zâ‚‚ (g x) âŠ† v :=
        exists_Ioc_subset_of_mem_nhds (v_open.mem_nhds xv) hxâ‚‚
      filter_upwards [hg zâ‚‚ zâ‚‚lt] with z hâ‚‚z
      have A2 : min (g z) (g x) âˆˆ v := by
        by_cases H : g z â‰¤ g x
        Â· simp [H]
          exact hâ‚‚ âŸ¨hâ‚‚z, HâŸ©
        Â· simp [le_of_not_le H]
          exact hâ‚‚ âŸ¨zâ‚‚lt, le_rflâŸ©
      have : (f x, min (g z) (g x)) âˆˆ u Ã—Ë¢ v := âŸ¨xu, A2âŸ©
      calc
        y < f x + min (g z) (g x) := h this
        _ â‰¤ f z + g z := add_le_add (hxâ‚ (f z)) (min_le_left _ _)
    Â· simp only [not_exists, not_lt] at hxâ‚ hxâ‚‚
      apply Filter.eventually_of_forall
      intro z
      have : (f x, g x) âˆˆ u Ã—Ë¢ v := âŸ¨xu, xvâŸ©
      calc
        y < f x + g x := h this
        _ â‰¤ f z + g z := add_le_add (hxâ‚ (f z)) (hxâ‚‚ (g z))","error:  unknown identifier 'lowerSemicontinuousWithinAt_iff_eventually_lt'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.73253
Î± : Type u_1
instâœâ´ : TopologicalSpace Î±
Î² : Type u_2
instâœÂ³ : Preorder Î²
fâœ gâœ : Î± â†’ Î²
x : Î±
s t : Set Î±
y z : Î²
Î¹ : Type u_3
Î³ : Type u_4
instâœÂ² : LinearOrderedAddCommMonoid Î³
instâœÂ¹ : TopologicalSpace Î³
instâœ : OrderTopology Î³
f g : Î± â†’ Î³
hf : LowerSemicontinuousWithinAt f s x
hg : LowerSemicontinuousWithinAt g s x
hcont : ContinuousAt (fun p â†¦ p.1 + p.2) (f x, g x)
âŠ¢ LowerSemicontinuousWithinAt (fun z â†¦ f z + g z) s x
error:  application type mismatch
  LowerSemicontinuousWithinAt.add' ?m.172031 hf hg
argument
  hg
has type
  UpperSemicontinuousWithinAt g s x : Prop
but is expected to have type
  ContinuousAt (fun p â†¦ p.1 + p.2) (?m.172029 x, f x) : Prop
error:  application type mismatch
  @lowerSemicontinuousWithinAt_sum Î± ?m.191770 x s Î¹ Î³áµ’áµˆ ?m.191773 ?m.191774 ?m.191775 ?m.191776 f
argument
  f
has type
  Î¹ â†’ Î± â†’ Î³ : Type (max (max u_1 u_3) u_4)
but is expected to have type
  Finset Î¹ : Type u_3","theorem LowerSemicontinuousWithinAt.add' {f g : Î± â†’ Î³} (hf : LowerSemicontinuousWithinAt f s x)
    (hg : LowerSemicontinuousWithinAt g s x)
    (hcont : ContinuousAt (fun p : Î³ Ã— Î³ => p.1 + p.2) (f x, g x)) :
    LowerSemicontinuousWithinAt (fun z => f z + g z) s x ",":= by
  intro y hy
  obtain âŸ¨u, v, u_open, xu, v_open, xv, hâŸ© :
    âˆƒ u v : Set Î³,
      IsOpen u âˆ§ f x âˆˆ u âˆ§ IsOpen v âˆ§ g x âˆˆ v âˆ§ u Ã—Ë¢ v âŠ† { p : Î³ Ã— Î³ | y < p.fst + p.snd } :=
    mem_nhds_prod_iff'.1 (hcont (isOpen_Ioi.mem_nhds hy))
  by_cases hxâ‚ : âˆƒ l, l < f x
  Â· obtain âŸ¨zâ‚, zâ‚lt, hâ‚âŸ© : âˆƒ zâ‚ < f x, Ioc zâ‚ (f x) âŠ† u :=
      exists_Ioc_subset_of_mem_nhds (u_open.mem_nhds xu) hxâ‚
    by_cases hxâ‚‚ : âˆƒ l, l < g x
    Â· obtain âŸ¨zâ‚‚, zâ‚‚lt, hâ‚‚âŸ© : âˆƒ zâ‚‚ < g x, Ioc zâ‚‚ (g x) âŠ† v :=
        exists_Ioc_subset_of_mem_nhds (v_open.mem_nhds xv) hxâ‚‚
      filter_upwards [hf zâ‚ zâ‚lt, hg zâ‚‚ zâ‚‚lt] with z hâ‚z hâ‚‚z
      have A1 : min (f z) (f x) âˆˆ u := by
        by_cases H : f z â‰¤ f x
        Â· simp [H]
          exact hâ‚ âŸ¨hâ‚z, HâŸ©
        Â· simp [le_of_not_le H]
          exact hâ‚ âŸ¨zâ‚lt, le_rflâŸ©
      have A2 : min (g z) (g x) âˆˆ v := by
        by_cases H : g z â‰¤ g x
        Â· simp [H]
          exact hâ‚‚ âŸ¨hâ‚‚z, HâŸ©
        Â· simp [le_of_not_le H]
          exact hâ‚‚ âŸ¨zâ‚‚lt, le_rflâŸ©
      have : (min (f z) (f x), min (g z) (g x)) âˆˆ u Ã—Ë¢ v := âŸ¨A1, A2âŸ©
      calc
        y < min (f z) (f x) + min (g z) (g x) := h this
        _ â‰¤ f z + g z := add_le_add (min_le_left _ _) (min_le_left _ _)

    Â· simp only [not_exists, not_lt] at hxâ‚‚
      filter_upwards [hf zâ‚ zâ‚lt] with z hâ‚z
      have A1 : min (f z) (f x) âˆˆ u := by
        by_cases H : f z â‰¤ f x
        Â· simp [H]
          exact hâ‚ âŸ¨hâ‚z, HâŸ©
        Â· simp [le_of_not_le H]
          exact hâ‚ âŸ¨zâ‚lt, le_rflâŸ©
      have : (min (f z) (f x), g x) âˆˆ u Ã—Ë¢ v := âŸ¨A1, xvâŸ©
      calc
        y < min (f z) (f x) + g x := h this
        _ â‰¤ f z + g z := add_le_add (min_le_left _ _) (hxâ‚‚ (g z))

  Â· simp only [not_exists, not_lt] at hxâ‚
    by_cases hxâ‚‚ : âˆƒ l, l < g x
    Â· obtain âŸ¨zâ‚‚, zâ‚‚lt, hâ‚‚âŸ© : âˆƒ zâ‚‚ < g x, Ioc zâ‚‚ (g x) âŠ† v :=
        exists_Ioc_subset_of_mem_nhds (v_open.mem_nhds xv) hxâ‚‚
      filter_upwards [hg zâ‚‚ zâ‚‚lt] with z hâ‚‚z
      have A2 : min (g z) (g x) âˆˆ v := by
        by_cases H : g z â‰¤ g x
        Â· simp [H]
          exact hâ‚‚ âŸ¨hâ‚‚z, HâŸ©
        Â· simp [le_of_not_le H]
          exact hâ‚‚ âŸ¨zâ‚‚lt, le_rflâŸ©
      have : (f x, min (g z) (g x)) âˆˆ u Ã—Ë¢ v := âŸ¨xu, A2âŸ©
      calc
        y < f x + min (g z) (g x) := h this
        _ â‰¤ f z + g z := add_le_add (hxâ‚ (f z)) (min_le_left _ _)
    Â· simp only [not_exists, not_lt] at hxâ‚ hxâ‚‚
      apply Filter.eventually_of_forall
      intro z
      have : (f x, g x) âˆˆ u Ã—Ë¢ v := âŸ¨xu, xvâŸ©
      calc
        y < f x + g x := h this
        _ â‰¤ f z + g z := add_le_add (hxâ‚ (f z)) (hxâ‚‚ (g z))","have : ContinuousWithinAt (fun p : Î³ Ã— Î³ => p.1 + p.2) (f x, g x) :=
  hf.continuousWithinAt.add' hg.continuousWithinAt hcont hf.continuousWithinAt"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.measure_limRatioMeas_zero,measure_limRatioMeas_zero,9d3887769246754772c178dd6c594378dce58448,":= by
  refine' measure_null_of_locally_null _ fun x _ => _
  obtain âŸ¨o, xo, o_open, Î¼oâŸ© : âˆƒ o : Set Î±, x âˆˆ o âˆ§ IsOpen o âˆ§ Î¼ o < âˆ :=
    Measure.exists_isOpen_measure_lt_top Î¼ x
  let s := {x : Î± | v.limRatioMeas hÏ x = 0} âˆ© o
  refine' âŸ¨s, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), le_antisymm _ bot_leâŸ©
  have Î¼s : Î¼ s â‰  âˆ := ((measure_mono (inter_subset_right _ _)).trans_lt Î¼o).ne
  have A : âˆ€ q : â„â‰¥0, 0 < q â†’ Ï s â‰¤ q * Î¼ s := by
    intro q hq
    apply v.measure_le_mul_of_subset_limRatioMeas_lt hÏ
    intro y hy
    have : v.limRatioMeas hÏ y = 0 := hy.1
    simp only [this, mem_setOf_eq, hq, ENNReal.coe_pos]
  have B : Tendsto (fun q : â„â‰¥0 => (q : â„â‰¥0âˆ) * Î¼ s) (ğ“[>] (0 : â„â‰¥0)) (ğ“ ((0 : â„â‰¥0) * Î¼ s)) := by
    apply ENNReal.Tendsto.mul_const _ (Or.inr Î¼s)
    rw [ENNReal.tendsto_coe]
    exact nhdsWithin_le_nhds
  simp only [zero_mul, ENNReal.coe_zero] at B
  apply ge_of_tendsto B
  filter_upwards [self_mem_nhdsWithin] using A","error:  function expected at
  inter_subset_right ?m.185264
term has type
  ?m.185263 âˆˆ ?m.185262",theorem measure_limRatioMeas_zero : Ï {x | v.limRatioMeas hÏ x = 0} = 0 ,":= by
  refine measure_null_of_locally_null _ fun x _ => ?_
  obtain âŸ¨o, xo, o_open, Î¼oâŸ© : âˆƒ o : Set Î±, x âˆˆ o âˆ§ IsOpen o âˆ§ Î¼ o < âˆ :=
    Measure.exists_isOpen_measure_lt_top Î¼ x
  let s := {x : Î± | v.limRatioMeas hÏ x = 0} âˆ© o
  refine âŸ¨s, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), le_antisymm ?_ bot_leâŸ©
  have Î¼s : Î¼ s â‰  âˆ := ((measure_mono inter_subset_right).trans_lt Î¼o).ne
  have A : âˆ€ q : â„â‰¥0, 0 < q â†’ Ï s â‰¤ q * Î¼ s := by
    intro q hq
    apply v.measure_le_mul_of_subset_limRatioMeas_lt hÏ
    intro y hy
    have : v.limRatioMeas hÏ y = 0 := hy.1
    simp only [this, mem_setOf_eq, hq, ENNReal.coe_pos]
  have B : Tendsto (fun q : â„â‰¥0 => (q : â„â‰¥0âˆ) * Î¼ s) (ğ“[>] (0 : â„â‰¥0)) (ğ“ ((0 : â„â‰¥0) * Î¼ s)) := by
    apply ENNReal.Tendsto.mul_const _ (Or.inr Î¼s)
    rw [ENNReal.tendsto_coe]
    exact nhdsWithin_le_nhds
  simp only [zero_mul, ENNReal.coe_zero] at B
  apply ge_of_tendsto B
  filter_upwards [self_mem_nhdsWithin] using A",rw [measure_limRatioMeas_zero]
Mathlib/Geometry/Manifold/AnalyticManifold.lean,ofSet_mem_analyticGroupoid,ofSet_mem_analyticGroupoid,adcd6dbf5035190e3fe4f23cfff2802d3d41537a,":= by
  rw [analyticGroupoid, mem_groupoid_of_pregroupoid]
  suffices h : AnalyticWithinOn ğ•œ (I âˆ˜ I.symm) (I.symm â»Â¹' s âˆ© range I) by
    simp [h, analyticPregroupoid]
  have hi : AnalyticWithinOn ğ•œ id (univ : Set E) := (analyticOn_id _).analyticWithinOn
  exact (hi.mono (subset_univ _)).congr (fun x hx â†¦ (I.right_inv hx.2).symm)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.10802 âˆˆ ?m.10801.groupoid
ğ•œ : Type u_1
instâœâ´ : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace ğ•œ E
H : Type u_3
instâœÂ¹ : TopologicalSpace H
I : ModelWithCorners ğ•œ E H
M : Type u_4
instâœ : TopologicalSpace M
s : Set H
hs : IsOpen s
âŠ¢ PartialHomeomorph.ofSet s hs âˆˆ
    contDiffGroupoid âŠ¤ I âŠ“
      {
          property := fun f s â†¦
            AnalyticOn ğ•œ (â†‘I âˆ˜ f âˆ˜ â†‘I.symm) (â†‘I.symm â»Â¹' s âˆ© interior (range â†‘I)) âˆ§
              â†‘I âˆ˜ f âˆ˜ â†‘I.symm '' (â†‘I.symm â»Â¹' s âˆ© interior (range â†‘I)) âŠ† interior (range â†‘I),
          comp := â‹¯, id_mem := â‹¯, locality := â‹¯, congr := â‹¯ }.groupoid","theorem ofSet_mem_analyticGroupoid {s : Set H} (hs : IsOpen s) :
    PartialHomeomorph.ofSet s hs âˆˆ analyticGroupoid I ",":= by
  rw [analyticGroupoid]
  refine And.intro (ofSet_mem_contDiffGroupoid âˆ I hs) ?_
  apply mem_groupoid_of_pregroupoid.mpr
  suffices h : AnalyticOn ğ•œ (I âˆ˜ I.symm) (I.symm â»Â¹' s âˆ© interior (range I)) âˆ§
      (I.symm â»Â¹' s âˆ© interior (range I)).image (I âˆ˜ I.symm) âŠ† interior (range I) by
    simp only [PartialHomeomorph.ofSet_apply, id_comp, PartialHomeomorph.ofSet_toPartialEquiv,
      PartialEquiv.ofSet_source, h, comp_apply, mem_range, image_subset_iff, true_and,
      PartialHomeomorph.ofSet_symm, PartialEquiv.ofSet_target, and_self]
    intro x hx
    refine mem_preimage.mpr ?_
    rw [â† I.right_inv (interior_subset hx.right)] at hx
    exact hx.right
  apply And.intro
  Â· have : AnalyticOn ğ•œ (1 : E â†’L[ğ•œ] E) (univ : Set E) := (fun x _ => (1 : E â†’L[ğ•œ] E).analyticAt x)
    exact (this.mono (subset_univ (s.preimage (I.symm) âˆ© interior (range I)))).congr
      ((hs.preimage I.continuous_symm).inter isOpen_interior)
      fun z hz => (I.right_inv (interior_subset hz.right)).symm
  Â· intro x hx
    simp only [comp_apply, mem_image] at hx
    rcases hx with âŸ¨y, hyâŸ©
    rw [â† hy.right, I.right_inv (interior_subset hy.left.right)]
    exact hy.left.right",rw [analyticGroupoid]
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicOn.pow,pow,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  induction' n with m hm
  Â· simpa only [Nat.zero_eq, pow_zero] using MeromorphicAt.const 1 x
  Â· simpa only [pow_succ'] using hm.mul hf","error:  type mismatch
  hâœ
has type
  MeromorphicAt (f ^ m * f) x : Prop
but is expected to have type
  MeromorphicAt (f * f ^ m) x : Prop",lemma pow {f : ğ•œ â†’ ğ•œ} {x : ğ•œ} (hf : MeromorphicAt f x) (n : â„•) : MeromorphicAt (f ^ n) x ,":= by
  induction' n with m hm
  Â· simpa only [Nat.zero_eq, pow_zero] using MeromorphicAt.const 1 x
  Â· simpa only [pow_succ] using hm.mul hf",induction' n with n ih generalizing x n
Mathlib/NumberTheory/NumberField/Embeddings.lean,NumberField.InfinitePlace.card_complex_embeddings,card_complex_embeddings,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  suffices âˆ€ w : { w : InfinitePlace K // IsComplex w }, (Finset.univ.filter
      fun Ï† : { Ï† // Â¬ ComplexEmbedding.IsReal Ï† } => mkComplex Ï† = w).card = 2 by
    rw [Fintype.card, Finset.card_eq_sum_ones, â† Finset.sum_fiberwise _ (fun Ï† => mkComplex Ï†)]
    simp_rw [Finset.sum_const, this, smul_eq_mul, mul_one, Fintype.card, Finset.card_eq_sum_ones,
      Finset.mul_sum]
  rintro âŸ¨w, hwâŸ©
  convert card_filter_mk_eq w
  Â· rw [â† Fintype.card_subtype, â† Fintype.card_subtype]
    refine Fintype.card_congr (Equiv.ofBijective ?_ âŸ¨fun _ _ h => ?_, fun âŸ¨Ï†, hÏ†âŸ© => ?_âŸ©)
    Â· exact fun âŸ¨Ï†, hÏ†âŸ© => âŸ¨Ï†.val, by rwa [Subtype.ext_iff] at hÏ†âŸ©
    Â· rwa [Subtype.mk_eq_mk, â† Subtype.ext_iff, â† Subtype.ext_iff] at h
    Â· refine âŸ¨âŸ¨âŸ¨Ï†, not_isReal_of_mk_isComplex (hÏ†.symm â–¸ hw)âŸ©, ?_âŸ©, rflâŸ©
      rwa [Subtype.ext_iff, mkComplex_coe]
  Â· simp_rw [mult, not_isReal_iff_isComplex.mpr hw, ite_false]","error:  unsolved goals
k : Type u_1
instâœÂ³ : Field k
K : Type u_2
instâœÂ² : Field K
F : Type u_3
instâœÂ¹ : Field F
instâœ : NumberField K
this : âˆ€ (w : { w // w.IsComplex }), (Finset.filter (fun Ï† â†¦ mkComplex Ï† = w) Finset.univ).card = 2
âŠ¢ âˆ‘ x : { w // w.IsComplex }, 2 = âˆ‘ i : { w // w.IsComplex }, 2 * 1","theorem card_complex_embeddings :
    card { Ï† : K â†’+* â„‚ // Â¬ComplexEmbedding.IsReal Ï† } = 2 * NrComplexPlaces K ",":= by
  suffices âˆ€ w : { w : InfinitePlace K // IsComplex w }, (Finset.univ.filter
      fun Ï† : { Ï† // Â¬ ComplexEmbedding.IsReal Ï† } => mkComplex Ï† = w).card = 2 by
    rw [Fintype.card, Finset.card_eq_sum_ones, â† Finset.sum_fiberwise _ (fun Ï† => mkComplex Ï†)]
    simp_rw [Finset.sum_const, this, smul_eq_mul, mul_one, Fintype.card, Finset.card_eq_sum_ones,
      Finset.mul_sum, Finset.sum_const, smul_eq_mul, mul_one]
  rintro âŸ¨w, hwâŸ©
  convert card_filter_mk_eq w
  Â· rw [â† Fintype.card_subtype, â† Fintype.card_subtype]
    refine Fintype.card_congr (Equiv.ofBijective ?_ âŸ¨fun _ _ h => ?_, fun âŸ¨Ï†, hÏ†âŸ© => ?_âŸ©)
    Â· exact fun âŸ¨Ï†, hÏ†âŸ© => âŸ¨Ï†.val, by rwa [Subtype.ext_iff] at hÏ†âŸ©
    Â· rwa [Subtype.mk_eq_mk, â† Subtype.ext_iff, â† Subtype.ext_iff] at h
    Â· refine âŸ¨âŸ¨âŸ¨Ï†, not_isReal_of_mk_isComplex (hÏ†.symm â–¸ hw)âŸ©, ?_âŸ©, rflâŸ©
      rwa [Subtype.ext_iff, mkComplex_coe]
  Â· simp_rw [mult, not_isReal_iff_isComplex.mpr hw, ite_false]","rw [â† card_complex_embeddings, â† card_complex_embeddings, card_complex_embeddings]"
Mathlib/Algebra/Star/Order.lean,star_nonneg_iff,star_nonneg_iff,061af0be124d0e0c5bf09a35c992ac5a09a5b364,":= by
  suffices âˆ€ x, 0 â‰¤ x â†’ 0 â‰¤ star x from
    âŸ¨by simpa only [star_star] using this (star x), this xâŸ©
  intro x hx
  rwa [star_eq_self_of_nonneg hx]","error:  application type mismatch
  this x
argument
  x
has type
  R : Type u
but is expected to have type
  â„• : Type
error:  application type mismatch
  star x
argument
  x
has type
  R : Type u
but is expected to have type
  â„• : Type
error:  unknown identifier 'star_eq_self_of_nonneg'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.67076
R : Type u
instâœÂ³ : NonUnitalSemiring R
instâœÂ² : PartialOrder R
instâœÂ¹ : StarRing R
instâœ : StarOrderedRing R
xâœ : R
x : â„•
hx : 0 â‰¤ x
âŠ¢ 0 â‰¤ star x",lemma star_nonneg_iff {x : R} : 0 â‰¤ star x â†” 0 â‰¤ x ,":= by
  simpa using star_le_star_iff (x := 0) (y := x)","rw [star_nonneg_iff, star_nonneg_iff]"
Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean,Polynomial.orderOf_root_cyclotomic_dvd,orderOf_root_cyclotomic_dvd,9e34a191034458a56331f976ff7400a26407c888,":= by
  apply orderOf_dvd_of_pow_eq_one
  suffices hpow : eval (Nat.castRingHom (ZMod p) a) (X ^ n - 1 : (ZMod p)[X]) = 0
  Â· simp only [eval_X, eval_one, eval_pow, eval_sub, eq_natCast] at hpow
    apply Units.val_eq_one.1
    simp only [sub_eq_zero.mp hpow, ZMod.coe_unitOfCoprime, Units.val_pow_eq_pow_val]
  rw [IsRoot.def] at hroot
  rw [â† prod_cyclotomic_eq_X_pow_sub_one hpos (ZMod p), â† Nat.cons_self_properDivisors hpos.ne',
    Finset.prod_cons, eval_mul, hroot, MulZeroClass.zero_mul]",error:  unexpected token 'Â·'; expected 'by' or 'from',"theorem orderOf_root_cyclotomic_dvd {n : â„•} (hpos : 0 < n) {p : â„•} [Fact p.Prime] {a : â„•}
    (hroot : IsRoot (cyclotomic n (ZMod p)) (Nat.castRingHom (ZMod p) a)) :
    orderOf (ZMod.unitOfCoprime a (coprime_of_root_cyclotomic hpos hroot)) âˆ£ n ",":= by
  apply orderOf_dvd_of_pow_eq_one
  suffices hpow : eval (Nat.castRingHom (ZMod p) a) (X ^ n - 1 : (ZMod p)[X]) = 0 by
    simp only [eval_X, eval_one, eval_pow, eval_sub, eq_natCast] at hpow
    apply Units.val_eq_one.1
    simp only [sub_eq_zero.mp hpow, ZMod.coe_unitOfCoprime, Units.val_pow_eq_pow_val]
  rw [IsRoot.def] at hroot
  rw [â† prod_cyclotomic_eq_X_pow_sub_one hpos (ZMod p), â† Nat.cons_self_properDivisors hpos.ne',
    Finset.prod_cons, eval_mul, hroot, zero_mul]",apply orderOf_root_cyclotomic_dvd
Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean,Matrix.SpecialLinearGroup.mem_center_iff,mem_center_iff,ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  rcases isEmpty_or_nonempty n with hn | âŸ¨âŸ¨iâŸ©âŸ©; Â· exact âŸ¨by aesop, by simp [Subsingleton.elim A 1]âŸ©
  refine âŸ¨fun h â†¦ âŸ¨A i i, ?_, ?_âŸ©, fun âŸ¨r, _, hrâŸ© â†¦ mem_center_iff.mpr fun B â†¦ ?_âŸ©
  Â· have : det ((scalar n) (A i i)) = 1 := (scalar_eq_self_of_mem_center h i).symm â–¸ A.property
    simpa using this
  Â· exact scalar_eq_self_of_mem_center h i
  Â· suffices â†‘â‚˜(B * A) = â†‘â‚˜(A * B) from Subtype.val_injective this
    simpa only [coe_mul, â† hr] using (scalar_commute (n := n) r (Commute.all r) B).symm","warning:  SpecialLinearGroup does not have a doc string
warning:  @transpose does not have a doc string
error:  application type mismatch
  mem_center_iff.mpr fun B â†¦ ?m.106560 B
argument
  fun B â†¦ ?m.106560 B
has type
  (B : ?m.106554) â†’ ?m.106559 B : Sort (imax ?u.106553 ?u.106556)
but is expected to have type
  âˆƒ r, r ^ Fintype.card n = 1 âˆ§ (scalar n) r = â†‘A : Prop
error:  no goals to be solved
error:  fail to show termination for
  Matrix.SpecialLinearGroup.mem_center_iff
with errors
structural recursion cannot be used:

argument #1 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #2 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #3 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #4 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #5 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #6 cannot be used for structural recursion
  it is unchanged in the recursive calls

well-founded recursion cannot be used, 'Matrix.SpecialLinearGroup.mem_center_iff' does not take any (non-fixed) arguments","theorem mem_center_iff {A : SpecialLinearGroup n R} :
    A âˆˆ center (SpecialLinearGroup n R) â†” âˆƒ (r : R), r ^ (Fintype.card n) = 1 âˆ§ scalar n r = A ",":= by
  rcases isEmpty_or_nonempty n with hn | âŸ¨âŸ¨iâŸ©âŸ©; Â· exact âŸ¨by aesop, by simp [Subsingleton.elim A 1]âŸ©
  refine âŸ¨fun h â†¦ âŸ¨A i i, ?_, ?_âŸ©, fun âŸ¨r, _, hrâŸ© â†¦ Subgroup.mem_center_iff.mpr fun B â†¦ ?_âŸ©
  Â· have : det ((scalar n) (A i i)) = 1 := (scalar_eq_self_of_mem_center h i).symm â–¸ A.property
    simpa using this
  Â· exact scalar_eq_self_of_mem_center h i
  Â· suffices â†‘â‚˜(B * A) = â†‘â‚˜(A * B) from Subtype.val_injective this
    simpa only [coe_mul, â† hr] using (scalar_commute (n := n) r (Commute.all r) B).symm",constructor
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.lintegral_abs_det_fderiv_le_addHaar_image_aux1,lintegral_abs_det_fderiv_le_addHaar_image_aux1,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  have :
    âˆ€ A : E â†’L[â„] E,
      âˆƒ Î´ : â„â‰¥0,
        0 < Î´ âˆ§
          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§
            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’
              ENNReal.ofReal |A.det| * Î¼ t â‰¤ Î¼ (g '' t) + Îµ * Î¼ t := by
    intro A
    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt Îµ Îµpos
    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©
    have I'' : âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ â†‘Î´'' â†’ |B.det - A.det| â‰¤ â†‘Îµ := by
      intro B hB
      rw [â† Real.dist_eq]
      apply (hÎ´' B _).le
      rw [dist_eq_norm]
      exact hB.trans_lt (half_lt_self Î´'pos)
    rcases eq_or_ne A.det 0 with (hA | hA)
    Â· refine âŸ¨Î´'', half_pos Î´'pos, I'', ?_âŸ©
      simp only [hA, forall_const, zero_mul, ENNReal.ofReal_zero, imp_true_iff,
        zero_le, abs_zero]
    let m : â„â‰¥0 := Real.toNNReal |A.det| - Îµ
    have I : (m : â„â‰¥0âˆ) < ENNReal.ofReal |A.det| := by
      simp only [m, ENNReal.ofReal, ENNReal.coe_sub]
      apply ENNReal.sub_lt_self ENNReal.coe_ne_top
      Â· simpa only [abs_nonpos_iff, Real.toNNReal_eq_zero, ENNReal.coe_eq_zero, Ne] using hA
      Â· simp only [Îµpos.ne', ENNReal.coe_eq_zero, Ne, not_false_iff]
    rcases ((mul_le_addHaar_image_of_lt_det Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©
    refine âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), ?_,? _âŸ©
    Â· intro B hB
      apply I'' _ (hB.trans _)
      simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
    Â· intro t g htg
      rcases eq_or_ne (Î¼ t) âˆ with (ht | ht)
      Â· simp only [ht, Îµpos.ne', ENNReal.mul_top, ENNReal.coe_eq_zero, le_top, Ne,
          not_false_iff, _root_.add_top]
      have := h t g (htg.mono_num (min_le_left _ _))
      rwa [ENNReal.coe_sub, ENNReal.sub_mul, tsub_le_iff_right] at this
      simp only [ht, imp_true_iff, Ne, not_false_iff]
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  have s_eq : s = â‹ƒ n, s âˆ© t n := by
    rw [â† inter_iUnion]
    exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left _ _)
  calc
    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) =
        âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| âˆ‚Î¼ := by
      conv_lhs => rw [s_eq]
      rw [lintegral_iUnion]
      Â· exact fun n => hs.inter (t_meas n)
      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right _ _
    _ â‰¤ âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono (inter_subset_left _ _)]
      intro x hx
      have I : |(f' x).det| â‰¤ |(A n).det| + Îµ :=
        calc
          |(f' x).det| = |(A n).det + ((f' x).det - (A n).det)| := by congr 1; abel
          _ â‰¤ |(A n).det| + |(f' x).det - (A n).det| := abs_add _ _
          _ â‰¤ |(A n).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(f' x).det| â‰¤ ENNReal.ofReal (|(A n).det| + Îµ) :=
          ENNReal.ofReal_le_ofReal I
        _ = ENNReal.ofReal |(A n).det| + Îµ := by
          simp only [ENNReal.ofReal_add, abs_nonneg, NNReal.zero_le_coe, ENNReal.ofReal_coe_nnreal]
    _ = âˆ‘' n, (ENNReal.ofReal |(A n).det| * Î¼ (s âˆ© t n) + Îµ * Î¼ (s âˆ© t n)) := by
      simp only [set_lintegral_const, lintegral_add_right _ measurable_const]
    _ â‰¤ âˆ‘' n, (Î¼ (f '' (s âˆ© t n)) + Îµ * Î¼ (s âˆ© t n) + Îµ * Î¼ (s âˆ© t n)) := by
      gcongr
      exact (hÎ´ (A _)).2.2 _ _ (ht _)
    _ = Î¼ (f '' s) + 2 * Îµ * Î¼ s := by
      conv_rhs => rw [s_eq]
      rw [image_iUnion, measure_iUnion]; rotate_left
      Â· intro i j hij
        apply Disjoint.image _ hf (inter_subset_left _ _) (inter_subset_left _ _)
        exact Disjoint.mono (inter_subset_right _ _) (inter_subset_right _ _) (t_disj hij)
      Â· intro i
        exact
          measurable_image_of_fderivWithin (hs.inter (t_meas i))
            (fun x hx => (hf' x hx.1).mono (inter_subset_left _ _))
            (hf.mono (inter_subset_left _ _))
      rw [measure_iUnion]; rotate_left
      Â· exact pairwise_disjoint_mono t_disj fun i => inter_subset_right _ _
      Â· exact fun i => hs.inter (t_meas i)
      rw [â† ENNReal.tsum_mul_left, â† ENNReal.tsum_add]
      congr 1
      ext1 i
      rw [mul_assoc, two_mul, add_assoc]","error:  function expected at
  inter_subset_left ?m.487300
term has type
  ?m.487299 âˆˆ ?m.487297
error:  function expected at
  inter_subset_right ?m.491737
term has type
  ?m.491736 âˆˆ ?m.491735
error:  function expected at
  inter_subset_left ?m.492037
term has type
  ?m.492036 âˆˆ ?m.492034
warning:  `MeasureTheory.set_lintegral_const` has been deprecated, use `MeasureTheory.setLIntegral_const` instead
error:  function expected at
  inter_subset_left ?m.505648
term has type
  ?m.505647 âˆˆ ?m.505645
error:  function expected at
  inter_subset_left ?m.506119
term has type
  ?m.506118 âˆˆ ?m.506116
error:  function expected at
  inter_subset_left ?m.506190
term has type
  ?m.506189 âˆˆ ?m.506187
error:  function expected at
  inter_subset_right ?m.506602
term has type
  ?m.506601 âˆˆ ?m.506600","theorem lintegral_abs_det_fderiv_le_addHaar_image_aux1 (hs : MeasurableSet s)
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) {Îµ : â„â‰¥0} (Îµpos : 0 < Îµ) :
    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) â‰¤ Î¼ (f '' s) + 2 * Îµ * Î¼ s ",":= by
  have :
    âˆ€ A : E â†’L[â„] E,
      âˆƒ Î´ : â„â‰¥0,
        0 < Î´ âˆ§
          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§
            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’
              ENNReal.ofReal |A.det| * Î¼ t â‰¤ Î¼ (g '' t) + Îµ * Î¼ t := by
    intro A
    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt Îµ Îµpos
    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©
    have I'' : âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ â†‘Î´'' â†’ |B.det - A.det| â‰¤ â†‘Îµ := by
      intro B hB
      rw [â† Real.dist_eq]
      apply (hÎ´' B _).le
      rw [dist_eq_norm]
      exact hB.trans_lt (half_lt_self Î´'pos)
    rcases eq_or_ne A.det 0 with (hA | hA)
    Â· refine âŸ¨Î´'', half_pos Î´'pos, I'', ?_âŸ©
      simp only [hA, forall_const, zero_mul, ENNReal.ofReal_zero, imp_true_iff,
        zero_le, abs_zero]
    let m : â„â‰¥0 := Real.toNNReal |A.det| - Îµ
    have I : (m : â„â‰¥0âˆ) < ENNReal.ofReal |A.det| := by
      simp only [m, ENNReal.ofReal, ENNReal.coe_sub]
      apply ENNReal.sub_lt_self ENNReal.coe_ne_top
      Â· simpa only [abs_nonpos_iff, Real.toNNReal_eq_zero, ENNReal.coe_eq_zero, Ne] using hA
      Â· simp only [Îµpos.ne', ENNReal.coe_eq_zero, Ne, not_false_iff]
    rcases ((mul_le_addHaar_image_of_lt_det Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©
    refine âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), ?_, ?_âŸ©
    Â· intro B hB
      apply I'' _ (hB.trans _)
      simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
    Â· intro t g htg
      rcases eq_or_ne (Î¼ t) âˆ with (ht | ht)
      Â· simp only [ht, Îµpos.ne', ENNReal.mul_top, ENNReal.coe_eq_zero, le_top, Ne,
          not_false_iff, _root_.add_top]
      have := h t g (htg.mono_num (min_le_left _ _))
      rwa [ENNReal.coe_sub, ENNReal.sub_mul, tsub_le_iff_right] at this
      simp only [ht, imp_true_iff, Ne, not_false_iff]
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  have s_eq : s = â‹ƒ n, s âˆ© t n := by
    rw [â† inter_iUnion]
    exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left
  calc
    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) =
        âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| âˆ‚Î¼ := by
      conv_lhs => rw [s_eq]
      rw [lintegral_iUnion]
      Â· exact fun n => hs.inter (t_meas n)
      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
    _ â‰¤ âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono inter_subset_left]
      intro x hx
      have I : |(f' x).det| â‰¤ |(A n).det| + Îµ :=
        calc
          |(f' x).det| = |(A n).det + ((f' x).det - (A n).det)| := by congr 1; abel
          _ â‰¤ |(A n).det| + |(f' x).det - (A n).det| := abs_add _ _
          _ â‰¤ |(A n).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(f' x).det| â‰¤ ENNReal.ofReal (|(A n).det| + Îµ) :=
          ENNReal.ofReal_le_ofReal I
        _ = ENNReal.ofReal |(A n).det| + Îµ := by
          simp only [ENNReal.ofReal_add, abs_nonneg, NNReal.zero_le_coe, ENNReal.ofReal_coe_nnreal]
    _ = âˆ‘' n, (ENNReal.ofReal |(A n).det| * Î¼ (s âˆ© t n) + Îµ * Î¼ (s âˆ© t n)) := by
      simp only [setLIntegral_const, lintegral_add_right _ measurable_const]
    _ â‰¤ âˆ‘' n, (Î¼ (f '' (s âˆ© t n)) + Îµ * Î¼ (s âˆ© t n) + Îµ * Î¼ (s âˆ© t n)) := by
      gcongr
      exact (hÎ´ (A _)).2.2 _ _ (ht _)
    _ = Î¼ (f '' s) + 2 * Îµ * Î¼ s := by
      conv_rhs => rw [s_eq]
      rw [image_iUnion, measure_iUnion]; rotate_left
      Â· intro i j hij
        apply Disjoint.image _ hf inter_subset_left inter_subset_left
        exact Disjoint.mono inter_subset_right inter_subset_right (t_disj hij)
      Â· intro i
        exact
          measurable_image_of_fderivWithin (hs.inter (t_meas i))
            (fun x hx => (hf' x hx.1).mono inter_subset_left)
            (hf.mono inter_subset_left)
      rw [measure_iUnion]; rotate_left
      Â· exact pairwise_disjoint_mono t_disj fun i => inter_subset_right
      Â· exact fun i => hs.inter (t_meas i)
      rw [â† ENNReal.tsum_mul_left, â† ENNReal.tsum_add]
      congr 1
      ext1 i
      rw [mul_assoc, two_mul, add_assoc]","refine theorem_lintegral_abs_det_fderiv_le_addHaar_image_aux1 lintegral_abs_det_fderiv_le_addHaar_image_aux1
  lintegral_abs_det_fderiv_le_addHaar_image_aux1 lintegral_abs_det_fderiv_le_addHaar_image_aux1 lintegral_abs_det_fderiv_le_addHaar_image_aux1
  lintegral_abs_det_fderiv_le_addHaar_image_aux1 lintegral_abs_det_fderiv_le_addHaar_image_aux1 lintegral_abs_det_fderiv_le_addHaar"
Mathlib/NumberTheory/SmoothNumbers.lean,Nat.smoothNumbersUpTo_card_add_roughNumbersUpTo_card,smoothNumbersUpTo_card_add_roughNumbersUpTo_card,df80f92cd37291ae10f3efaf1c701700cac70a5d,":= by
  rw [smoothNumbersUpTo, roughNumbersUpTo,
    â† Finset.card_union_of_disjoint <| Finset.disjoint_filter.mpr fun n _ hnâ‚‚ h â†¦ h.2 hnâ‚‚,
    Finset.filter_union_right]
  suffices : Finset.card (Finset.filter (fun x â†¦ x â‰  0) (Finset.range (succ N))) = N
  Â· convert this with n
    have hn : n âˆˆ smoothNumbers k â†’ n â‰  0 := ne_zero_of_mem_smoothNumbers
    tauto
  Â· rw [Finset.filter_ne', Finset.card_erase_of_mem <| Finset.mem_range_succ_iff.mpr <| zero_le N]
    simp",error:  unexpected token ':'; expected term,"lemma smoothNumbersUpTo_card_add_roughNumbersUpTo_card (N k : â„•) :
    (smoothNumbersUpTo N k).card + (roughNumbersUpTo N k).card = N ",":= by
  rw [smoothNumbersUpTo, roughNumbersUpTo,
    â† Finset.card_union_of_disjoint <| Finset.disjoint_filter.mpr fun n _ hnâ‚‚ h â†¦ h.2 hnâ‚‚,
    Finset.filter_union_right]
  suffices Finset.card (Finset.filter (fun x â†¦ x â‰  0) (Finset.range (succ N))) = N by
    have hn' (n) : n âˆˆ smoothNumbers k âˆ¨ n â‰  0 âˆ§ n âˆ‰ smoothNumbers k â†” n â‰  0 := by
      have : n âˆˆ smoothNumbers k â†’ n â‰  0 := ne_zero_of_mem_smoothNumbers
      refine âŸ¨fun H â†¦ Or.elim H this fun H â†¦ H.1, fun H â†¦ ?_âŸ©
      simp only [ne_eq, H, not_false_eq_true, true_and, or_not]
    rwa [Finset.filter_congr (s := Finset.range (succ N)) fun n _ â†¦ hn' n]
  rw [Finset.filter_ne', Finset.card_erase_of_mem <| Finset.mem_range_succ_iff.mpr <| zero_le N]
  simp only [Finset.card_range, succ_sub_succ_eq_sub, tsub_zero]","simp only [smoothNumbersUpTo, smoothNumbersUpTo, smoothNumbersUpTo,
  smoothNumbersUpTo, smoothNumbersUpTo]"
Mathlib/Analysis/BoxIntegral/Box/SubboxInduction.lean,BoxIntegral.Box.subbox_induction_on',subbox_induction_on',427e8bb60237df1d94184c0ffbde88acb1294fc5,":= by
  by_contra hpI
  replace H_ind := fun J hJ â†¦ not_imp_not.2 (H_ind J hJ)
  simp only [exists_imp, not_forall] at H_ind
  choose! s hs using H_ind
  set J : â„• â†’ Box Î¹ := fun m â†¦ ((fun J â†¦ splitCenterBox J (s J))^[m]) I
  have J_succ : âˆ€ m, J (m + 1) = splitCenterBox (J m) (s <| J m) :=
    fun m â†¦ iterate_succ_apply' _ _ _
  have hJmono : Antitone J :=
    antitone_nat_of_succ_le fun n â†¦ by simpa [J_succ] using splitCenterBox_le _ _
  have hJle : âˆ€ m, J m â‰¤ I := fun m â†¦ hJmono (zero_le m)
  have hJp : âˆ€ m, Â¬p (J m) :=
    fun m â†¦ Nat.recOn m hpI fun m â†¦ by simpa only [J_succ] using hs (J m) (hJle m)
  have hJsub : âˆ€ m i, (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m := by
    intro m i
    induction' m with m ihm
    Â· simp [Nat.zero_eq]
    simp only [pow_succ', J_succ, upper_sub_lower_splitCenterBox, ihm, div_div]
  have h0 : J 0 = I := rfl
  clear_value J
  clear hpI hs J_succ s
  set z : Î¹ â†’ â„ := â¨† m, (J m).lower
  have hzJ : âˆ€ m, z âˆˆ Box.Icc (J m) :=
    mem_iInter.1 (ciSup_mem_Inter_Icc_of_antitone_Icc
      ((@Box.Icc Î¹).monotone.comp_antitone hJmono) fun m â†¦ (J m).lower_le_upper)
  have hJl_mem : âˆ€ m, (J m).lower âˆˆ Box.Icc I := fun m â†¦ le_iff_Icc.1 (hJle m) (J m).lower_mem_Icc
  have hJu_mem : âˆ€ m, (J m).upper âˆˆ Box.Icc I := fun m â†¦ le_iff_Icc.1 (hJle m) (J m).upper_mem_Icc
  have hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“ z) :=
    tendsto_atTop_ciSup (antitone_lower.comp hJmono) âŸ¨I.upper, fun x âŸ¨m, hmâŸ© â†¦ hm â–¸ (hJl_mem m).2âŸ©
  have hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“ z) := by
    suffices Tendsto (fun m â†¦ (J m).upper - (J m).lower) atTop (ğ“ 0) by simpa using hJlz.add this
    refine' tendsto_pi_nhds.2 fun i â†¦ _
    simpa [hJsub] using
      tendsto_const_nhds.div_atTop (tendsto_pow_atTop_atTop_of_one_lt _root_.one_lt_two)
  replace hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“[Icc I.lower I.upper] z)
  Â· exact
      tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJlz (eventually_of_forall hJl_mem)
  replace hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“[Icc I.lower I.upper] z)
  Â· exact
      tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJuz (eventually_of_forall hJu_mem)
  rcases H_nhds z (h0 â–¸ hzJ 0) with âŸ¨U, hUz, hUâŸ©
  rcases(tendsto_lift'.1 (hJlz.Icc hJuz) U hUz).exists with âŸ¨m, hUmâŸ©
  exact hJp m (hU (J m) (hJle m) m (hzJ m) hUm (hJsub m))","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case zero
Î¹ : Type u_1
Iâœ Jâœ : Box Î¹
p : Box Î¹ â†’ Prop
I : Box Î¹
H_nhds :
  âˆ€ z âˆˆ Box.Icc I,
    âˆƒ U âˆˆ ğ“[Box.Icc I] z,
      âˆ€ J â‰¤ I,
        âˆ€ (m : â„•),
          z âˆˆ Box.Icc J â†’ Box.Icc J âŠ† U â†’ (âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J
hpI : Â¬p I
s : Box Î¹ â†’ Set Î¹
hs : âˆ€ J â‰¤ I, Â¬p J â†’ Â¬p (J.splitCenterBox (s J))
J : â„• â†’ Box Î¹ := fun m â†¦ (fun J â†¦ J.splitCenterBox (s J))^[m] I
J_succ : âˆ€ (m : â„•), J (m + 1) = (J m).splitCenterBox (s (J m))
hJmono : Antitone J
hJle : âˆ€ (m : â„•), J m â‰¤ I
hJp : âˆ€ (m : â„•), Â¬p (J m)
i : Î¹
âŠ¢ (J 0).upper i - (J 0).lower i = I.upper i - I.lower i
error:  unsolved goals
case succ
Î¹ : Type u_1
Iâœ Jâœ : Box Î¹
p : Box Î¹ â†’ Prop
I : Box Î¹
H_nhds :
  âˆ€ z âˆˆ Box.Icc I,
    âˆƒ U âˆˆ ğ“[Box.Icc I] z,
      âˆ€ J â‰¤ I,
        âˆ€ (m : â„•),
          z âˆˆ Box.Icc J â†’ Box.Icc J âŠ† U â†’ (âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J
hpI : Â¬p I
s : Box Î¹ â†’ Set Î¹
hs : âˆ€ J â‰¤ I, Â¬p J â†’ Â¬p (J.splitCenterBox (s J))
J : â„• â†’ Box Î¹ := fun m â†¦ (fun J â†¦ J.splitCenterBox (s J))^[m] I
J_succ : âˆ€ (m : â„•), J (m + 1) = (J m).splitCenterBox (s (J m))
hJmono : Antitone J
hJle : âˆ€ (m : â„•), J m â‰¤ I
hJp : âˆ€ (m : â„•), Â¬p (J m)
i : Î¹
m : â„•
ihm : (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m
âŠ¢ (I.upper i - I.lower i) / (2 ^ m * 2) = (I.upper i - I.lower i) / (2 * 2 ^ m)
error:  unsolved goals
Î¹ : Type u_1
Iâœ Jâœ : Box Î¹
p : Box Î¹ â†’ Prop
I : Box Î¹
H_nhds :
  âˆ€ z âˆˆ Box.Icc I,
    âˆƒ U âˆˆ ğ“[Box.Icc I] z,
      âˆ€ J â‰¤ I,
        âˆ€ (m : â„•),
          z âˆˆ Box.Icc J â†’ Box.Icc J âŠ† U â†’ (âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J
J : â„• â†’ Box Î¹
hJmono : Antitone J
hJle : âˆ€ (m : â„•), J m â‰¤ I
hJp : âˆ€ (m : â„•), Â¬p (J m)
hJsub : âˆ€ (m : â„•) (i : Î¹), (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m
h0 : J 0 = I
z : Î¹ â†’ â„ := â¨† m, (J m).lower
hzJ : âˆ€ (m : â„•), z âˆˆ Box.Icc (J m)
hJl_mem : âˆ€ (m : â„•), (J m).lower âˆˆ Box.Icc I
hJu_mem : âˆ€ (m : â„•), (J m).upper âˆˆ Box.Icc I
hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“ z)
hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“[Set.Icc I.lower I.upper] z)
âŠ¢ False","theorem subbox_induction_on' {p : Box Î¹ â†’ Prop} (I : Box Î¹)
    (H_ind : âˆ€ J â‰¤ I, (âˆ€ s, p (splitCenterBox J s)) â†’ p J)
    (H_nhds : âˆ€ z âˆˆ Box.Icc I, âˆƒ U âˆˆ ğ“[Box.Icc I] z, âˆ€ J â‰¤ I, âˆ€ (m : â„•), z âˆˆ Box.Icc J â†’
      Box.Icc J âŠ† U â†’ (âˆ€ i, J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J) :
    p I ",":= by
  by_contra hpI
  replace H_ind := fun J hJ â†¦ not_imp_not.2 (H_ind J hJ)
  simp only [exists_imp, not_forall] at H_ind
  choose! s hs using H_ind
  set J : â„• â†’ Box Î¹ := fun m â†¦ (fun J â†¦ splitCenterBox J (s J))^[m] I
  have J_succ : âˆ€ m, J (m + 1) = splitCenterBox (J m) (s <| J m) :=
    fun m â†¦ iterate_succ_apply' _ _ _
  have hJmono : Antitone J :=
    antitone_nat_of_succ_le fun n â†¦ by simpa [J_succ] using splitCenterBox_le _ _
  have hJle : âˆ€ m, J m â‰¤ I := fun m â†¦ hJmono (zero_le m)
  have hJp : âˆ€ m, Â¬p (J m) :=
    fun m â†¦ Nat.recOn m hpI fun m â†¦ by simpa only [J_succ] using hs (J m) (hJle m)
  have hJsub : âˆ€ m i, (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m := by
    intro m i
    induction' m with m ihm
    Â· simp [J, Nat.zero_eq]
    simp only [pow_succ, J_succ, upper_sub_lower_splitCenterBox, ihm, div_div]
  have h0 : J 0 = I := rfl
  clear_value J
  clear hpI hs J_succ s
  set z : Î¹ â†’ â„ := â¨† m, (J m).lower
  have hzJ : âˆ€ m, z âˆˆ Box.Icc (J m) :=
    mem_iInter.1 (ciSup_mem_iInter_Icc_of_antitone_Icc
      ((@Box.Icc Î¹).monotone.comp_antitone hJmono) fun m â†¦ (J m).lower_le_upper)
  have hJl_mem : âˆ€ m, (J m).lower âˆˆ Box.Icc I := fun m â†¦ le_iff_Icc.1 (hJle m) (J m).lower_mem_Icc
  have hJu_mem : âˆ€ m, (J m).upper âˆˆ Box.Icc I := fun m â†¦ le_iff_Icc.1 (hJle m) (J m).upper_mem_Icc
  have hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“ z) :=
    tendsto_atTop_ciSup (antitone_lower.comp hJmono) âŸ¨I.upper, fun x âŸ¨m, hmâŸ© â†¦ hm â–¸ (hJl_mem m).2âŸ©
  have hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“ z) := by
    suffices Tendsto (fun m â†¦ (J m).upper - (J m).lower) atTop (ğ“ 0) by simpa using hJlz.add this
    refine tendsto_pi_nhds.2 fun i â†¦ ?_
    simpa [hJsub] using
      tendsto_const_nhds.div_atTop (tendsto_pow_atTop_atTop_of_one_lt _root_.one_lt_two)
  replace hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“[Icc I.lower I.upper] z) :=
    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJlz (eventually_of_forall hJl_mem)
  replace hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“[Icc I.lower I.upper] z) :=
    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJuz (eventually_of_forall hJu_mem)
  rcases H_nhds z (h0 â–¸ hzJ 0) with âŸ¨U, hUz, hUâŸ©
  rcases (tendsto_lift'.1 (hJlz.Icc hJuz) U hUz).exists with âŸ¨m, hUmâŸ©
  exact hJp m (hU (J m) (hJle m) m (hzJ m) hUm (hJsub m))",refine theorem_theorem_Icc p I H_nhds H_ind H_nhds H_nhds H_ind H_nhds H_nhds H_ind H_nhds H_nhds
Mathlib/Data/NNRat/Defs.lean,NNRat.mul_def,mul_def,5f71dc2104c23870830cd3dd0cd165dd6913a60b,":= by
  ext; simp [Rat.mul_def', Rat.mkRat_eq, num_coe, den_coe]","error:  unknown constant 'Rat.mul_def''
error:  unknown constant 'Rat.mkRat_eq'
error:  unsolved goals
case a
p qâœ : â„šâ‰¥0
nâ‚ nâ‚‚ dâ‚ dâ‚‚ d : â„•
q r : â„šâ‰¥0
âŠ¢ â†‘q * â†‘r = Rat.divInt (â†‘q.num * â†‘r.num) (â†‘q.den * â†‘r.den)",lemma mul_def (q r : â„šâ‰¥0) : q * r = divNat (q.num * r.num) (q.den * r.den) ,":= by
  ext; simp [Rat.mul_eq_mkRat, Rat.mkRat_eq_divInt, num_coe, den_coe]","rw [mul_def, divNat_mul_divNat, divNat_mul_divNat, divNat_mul_den, divNat_mul_den]"
Mathlib/RingTheory/UniqueFactorizationDomain.lean,UniqueFactorizationMonoid.multiplicative_prime_power,multiplicative_prime_power,c342c339a777827331257acd880fea6d441a6aa6,":= by
  letI := Classical.decEq Î±
  induction' s with p s hps ih
  Â· simpa using h1 isUnit_one
  have hpr_p := is_prime _ (Finset.mem_insert_self _ _)
  have hpr_s : âˆ€ p âˆˆ s, Prime p := fun p hp => is_prime _ (Finset.mem_insert_of_mem hp)
  have hcp_p := fun i => prime_pow_coprime_prod_of_coprime_insert i p hps is_prime is_coprime
  have hcp_s : âˆ€áµ‰ (p âˆˆ s) (q âˆˆ s), p âˆ£ q â†’ p = q := fun p hp q hq =>
    is_coprime p (Finset.mem_insert_of_mem hp) q (Finset.mem_insert_of_mem hq)
  rw [Finset.prod_insert hps, Finset.prod_insert hps, Finset.prod_insert hps, hcp (hcp_p _),
    hpr _ hpr_p, hcp (hcp_p _), hpr _ hpr_p, hcp (hcp_p (fun p => i p + j p)), hpr _ hpr_p,
    ih hpr_s hcp_s, pow_add, mul_assoc, mul_left_comm (f p ^ j p), mul_assoc]","error:  type mismatch
  hâœ
has type
  f ?m.273119 = f ?m.273119 * f 1 : Prop
but is expected to have type
  f (Multiset.map (fun p â†¦ p ^ (i p + j p)) p).prod =
    f (Multiset.map (fun p â†¦ p ^ i p) p).prod * f (Multiset.map (fun p â†¦ p ^ j p) p).prod : Prop
error:  no goals to be solved","theorem multiplicative_prime_power {f : Î± â†’ Î²} (s : Finset Î±) (i j : Î± â†’ â„•)
    (is_prime : âˆ€ p âˆˆ s, Prime p) (is_coprime : âˆ€áµ‰ (p âˆˆ s) (q âˆˆ s), p âˆ£ q â†’ p = q)
    (h1 : âˆ€ {x y}, IsUnit y â†’ f (x * y) = f x * f y)
    (hpr : âˆ€ {p} (i : â„•), Prime p â†’ f (p ^ i) = f p ^ i)
    (hcp : âˆ€ {x y}, IsRelPrime x y â†’ f (x * y) = f x * f y) :
    f (âˆ p âˆˆ s, p ^ (i p + j p)) = f (âˆ p âˆˆ s, p ^ i p) * f (âˆ p âˆˆ s, p ^ j p) ",":= by
  letI := Classical.decEq Î±
  induction' s using Finset.induction_on with p s hps ih
  Â· simpa using h1 isUnit_one
  have hpr_p := is_prime _ (Finset.mem_insert_self _ _)
  have hpr_s : âˆ€ p âˆˆ s, Prime p := fun p hp => is_prime _ (Finset.mem_insert_of_mem hp)
  have hcp_p := fun i => prime_pow_coprime_prod_of_coprime_insert i p hps is_prime is_coprime
  have hcp_s : âˆ€áµ‰ (p âˆˆ s) (q âˆˆ s), p âˆ£ q â†’ p = q := fun p hp q hq =>
    is_coprime p (Finset.mem_insert_of_mem hp) q (Finset.mem_insert_of_mem hq)
  rw [Finset.prod_insert hps, Finset.prod_insert hps, Finset.prod_insert hps, hcp (hcp_p _),
    hpr _ hpr_p, hcp (hcp_p _), hpr _ hpr_p, hcp (hcp_p (fun p => i p + j p)), hpr _ hpr_p,
    ih hpr_s hcp_s, pow_add, mul_assoc, mul_left_comm (f p ^ j p), mul_assoc]",rw [theorem_multiplicative_prime_power]
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.Ïƒ_comp_Ïƒ,Ïƒ_comp_Ïƒ,1b5c1d10be0ae07fd997c78515f4ed4561b92535,":= by
  ext k : 3
  dsimp [Ïƒ]
  cases' k using Fin.lastCases with k
  Â· simp only [len_mk, Fin.predAbove_right_last]
  Â· cases' k using Fin.cases with k
    Â· rw [Fin.castSucc_zero, Fin.predAbove_below _ 0 (Fin.zero_le _),
      Fin.predAbove_below _ _ (Fin.zero_le _), Fin.castPred_zero,
      Fin.predAbove_below _ 0 (Fin.zero_le _), Fin.predAbove_below _ _ (Fin.zero_le _)]
    Â· rcases le_or_lt i k with (h | h)
      Â· simp_rw [Fin.predAbove_above i.castSucc _ (Fin.castSucc_lt_castSucc_iff.mpr
        (Fin.castSucc_lt_succ_iff.mpr h)), â† Fin.succ_castSucc, Fin.pred_succ,
        Fin.succ_predAbove_succ]
        rw [Fin.predAbove_above i _ (Fin.castSucc_lt_succ_iff.mpr _), Fin.pred_succ]
        rcases le_or_lt k j with (hkj | hkj)
        Â· rwa [Fin.predAbove_below _ _ (Fin.castSucc_le_castSucc_iff.mpr hkj),
          Fin.castPred_castSucc]
        Â· rw [Fin.predAbove_above _ _ (Fin.castSucc_lt_castSucc_iff.mpr hkj), Fin.le_pred_iff,
          Fin.succ_le_castSucc_iff]
          exact H.trans_lt hkj
      Â· simp_rw [Fin.predAbove_below i.castSucc _ (Fin.castSucc_le_castSucc_iff.mpr
        (Fin.succ_le_castSucc_iff.mpr h)), Fin.castPred_castSucc, â† Fin.succ_castSucc,
        Fin.succ_predAbove_succ]
        rw [Fin.predAbove_below _ k.castSucc (Fin.castSucc_le_castSucc_iff.mpr (h.le.trans H)),
        Fin.castPred_castSucc, Fin.predAbove_below _ k.succ
        (Fin.succ_le_castSucc_iff.mpr (H.trans_lt' h)), Fin.predAbove_below _ k.succ
        (Fin.succ_le_castSucc_iff.mpr h)]","error:  unknown constant 'Fin.predAbove_below'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.81170
case a.h.h.cast.zero
n : â„•
i j : Fin (n + 1)
H : i â‰¤ j
âŠ¢ j.predAbove (i.castSucc.predAbove 0) = i.predAbove (j.succ.predAbove 0)
error:  unknown constant 'Fin.predAbove_above'
error:  simp made no progress
error:  unknown constant 'Fin.predAbove_below'
error:  simp made no progress","theorem Ïƒ_comp_Ïƒ {n} {i j : Fin (n + 1)} (H : i â‰¤ j) :
    Ïƒ (Fin.castSucc i) â‰« Ïƒ j = Ïƒ j.succ â‰« Ïƒ i ",":= by
  ext k : 3
  dsimp [Ïƒ]
  cases' k using Fin.lastCases with k
  Â· simp only [len_mk, Fin.predAbove_right_last]
  Â· cases' k using Fin.cases with k
    Â· rw [Fin.castSucc_zero, Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),
      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _), Fin.castPred_zero,
      Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),
      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _)]
    Â· rcases le_or_lt i k with (h | h)
      Â· simp_rw [Fin.predAbove_of_castSucc_lt i.castSucc _ (Fin.castSucc_lt_castSucc_iff.mpr
        (Fin.castSucc_lt_succ_iff.mpr h)), â† Fin.succ_castSucc, Fin.pred_succ,
        Fin.succ_predAbove_succ]
        rw [Fin.predAbove_of_castSucc_lt i _ (Fin.castSucc_lt_succ_iff.mpr _), Fin.pred_succ]
        rcases le_or_lt k j with (hkj | hkj)
        Â· rwa [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hkj),
          Fin.castPred_castSucc]
        Â· rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hkj),
          Fin.le_pred_iff,
          Fin.succ_le_castSucc_iff]
          exact H.trans_lt hkj
      Â· simp_rw [Fin.predAbove_of_le_castSucc i.castSucc _ (Fin.castSucc_le_castSucc_iff.mpr
        (Fin.succ_le_castSucc_iff.mpr h)), Fin.castPred_castSucc, â† Fin.succ_castSucc,
        Fin.succ_predAbove_succ]
        rw [Fin.predAbove_of_le_castSucc _ k.castSucc
        (Fin.castSucc_le_castSucc_iff.mpr (h.le.trans H)),
        Fin.castPred_castSucc, Fin.predAbove_of_le_castSucc _ k.succ
        (Fin.succ_le_castSucc_iff.mpr (H.trans_lt' h)), Fin.predAbove_of_le_castSucc _ k.succ
        (Fin.succ_le_castSucc_iff.mpr h)]","rw [Fin.castSucc_castSucc, Fin.castSucc_castSucc]"
Mathlib/Data/Fin/Basic.lean,Fin.last_pos',last_pos',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,:= NeZero.pos n,"error:  invalid field notation, type is not of the form (C ...) where C is a constant
  NeZero
has type
  ?m.10378 â†’ Prop
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Fin.val_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated",theorem last_pos' [NeZero n] : 0 < last n ,:= n.pos_of_neZero,"rw [NeZero.neZero_eq, last_pos']"
Mathlib/Analysis/Complex/Convex.lean,Complex.convexHull_reProdIm,convexHull_reProdIm,a7fbc9ec101d941ce1e02955a6e130a25d5ab907,":=
  calc
    convexHull â„ (equivRealProdLm â»Â¹' (s Ã—Ë¢ t)) = equivRealProdLm â»Â¹' (convexHull â„ (s Ã—Ë¢ t)) := by
      simpa only [â† LinearEquiv.image_symm_eq_preimage]
        using equivRealProdLm.symm.toLinearMap.convexHull_image (s Ã—Ë¢ t)
    _ = convexHull â„ s Ã—â„‚ convexHull â„ t := by rw [convexHull_prod]; rfl","error:  invalid field 'convexHull_image', the environment does not contain 'LinearMap.convexHull_image'
  â†‘equivRealProdLm.symm
has type
  â„ Ã— â„ â†’â‚—[â„] â„‚","lemma convexHull_reProdIm (s t : Set â„) :
    convexHull â„ (s Ã—â„‚ t) = convexHull â„ s Ã—â„‚ convexHull â„ t ",":=
  calc
    convexHull â„ (equivRealProdLm â»Â¹' (s Ã—Ë¢ t)) = equivRealProdLm â»Â¹' convexHull â„ (s Ã—Ë¢ t) := by
      simpa only [â† LinearEquiv.image_symm_eq_preimage]
        using ((equivRealProdLm.symm.toLinearMap).image_convexHull (s Ã—Ë¢ t)).symm
    _ = convexHull â„ s Ã—â„‚ convexHull â„ t := by rw [convexHull_prod]; rfl","rw [convexHull_reProdIm, convexHull_reProdIm]"
Mathlib/Analysis/SpecificLimits/Normed.lean,TFAE_exists_lt_isLittleO_pow,TFAE_exists_lt_isLittleO_pow,42c941f09f8ae3bb55437f7781a1525d3db76fd3,":= by
  have A : Ico 0 R âŠ† Ioo (-R) R :=
    fun x hx â†¦ âŸ¨(neg_lt_zero.2 (hx.1.trans_lt hx.2)).trans_le hx.1, hx.2âŸ©
  have B : Ioo 0 R âŠ† Ioo (-R) R := Subset.trans Ioo_subset_Ico_self A
  tfae
    1 â†’ 3 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha, H.isBigOâŸ©
    2 â†’ 1 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, B ha, HâŸ©
    3 â†’ 2 := by
      rintro âŸ¨a, ha, HâŸ©
      rcases exists_between (abs_lt.2 ha) with âŸ¨b, hab, hbRâŸ©
      exact âŸ¨b, âŸ¨(abs_nonneg a).trans_lt hab, hbRâŸ©,
        H.trans_isLittleO (isLittleO_pow_pow_of_abs_lt_left (hab.trans_le (le_abs_self b)))âŸ©
    2 â†’ 4 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha, H.isBigOâŸ©
    4 â†’ 3 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, B ha, HâŸ©
    4 â†’ 6 := by
      rintro âŸ¨a, ha, HâŸ©
      rcases bound_of_isBigO_nat_atTop H with âŸ¨C, hCâ‚€, hCâŸ©
      refine' âŸ¨a, ha, C, hCâ‚€, fun n â†¦ _âŸ©
      simpa only [Real.norm_eq_abs, abs_pow, abs_of_nonneg ha.1.le] using
        hC (pow_ne_zero n ha.1.ne')
    6 â†’ 5 := fun âŸ¨a, ha, C, Hâ‚€, HâŸ© â†¦ âŸ¨a, ha.2, C, Or.inl Hâ‚€, HâŸ©
    5 â†’ 3 := by
      rintro âŸ¨a, ha, C, hâ‚€, HâŸ©
      rcases sign_cases_of_C_mul_pow_nonneg fun n â†¦ (abs_nonneg _).trans (H n) with
        (rfl | âŸ¨hCâ‚€, haâ‚€âŸ©)
      Â· obtain rfl : f = 0 := by
          ext n
          simpa using H n
        simp only [lt_irrefl, false_or_iff] at hâ‚€
        exact âŸ¨0, âŸ¨neg_lt_zero.2 hâ‚€, hâ‚€âŸ©, isBigO_zero _ _âŸ©
      exact âŸ¨a, A âŸ¨haâ‚€, haâŸ©,
        isBigO_of_le' _ fun n â†¦ (H n).trans <| mul_le_mul_of_nonneg_left (le_abs_self _) hCâ‚€.leâŸ©
    2 â†’ 8 := by
      rintro âŸ¨a, ha, HâŸ©
      refine' âŸ¨a, ha, (H.def zero_lt_one).mono fun n hn â†¦ _âŸ©
      rwa [Real.norm_eq_abs, Real.norm_eq_abs, one_mul, abs_pow, abs_of_pos ha.1] at hn
    8 â†’ 7 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha.2, HâŸ©
    7 â†’ 3 := by
      rintro âŸ¨a, ha, HâŸ©
      have : 0 â‰¤ a := nonneg_of_eventually_pow_nonneg (H.mono fun n â†¦ (abs_nonneg _).trans)
      refine' âŸ¨a, A âŸ¨this, haâŸ©, IsBigO.of_bound 1 _âŸ©
      simpa only [Real.norm_eq_abs, one_mul, abs_pow, abs_of_nonneg this]","error:  unknown tactic
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î¹ : Type u_3
f : â„• â†’ â„
R : â„
A : Set.Ico 0 R âŠ† Set.Ioo (-R) R
B : Set.Ioo 0 R âŠ† Set.Ioo (-R) R
âŠ¢ [âˆƒ a âˆˆ Set.Ioo (-R) R, f =o[atTop] fun x â†¦ a ^ x, âˆƒ a âˆˆ Set.Ioo 0 R, f =o[atTop] fun x â†¦ a ^ x,
      âˆƒ a âˆˆ Set.Ioo (-R) R, f =O[atTop] fun x â†¦ a ^ x, âˆƒ a âˆˆ Set.Ioo 0 R, f =O[atTop] fun x â†¦ a ^ x,
      âˆƒ a < R, âˆƒ C, (0 < C âˆ¨ 0 < R) âˆ§ âˆ€ (n : â„•), |f n| â‰¤ C * a ^ n,
      âˆƒ a âˆˆ Set.Ioo 0 R, âˆƒ C > 0, âˆ€ (n : â„•), |f n| â‰¤ C * a ^ n, âˆƒ a < R, âˆ€á¶  (n : â„•) in atTop, |f n| â‰¤ a ^ n,
      âˆƒ a âˆˆ Set.Ioo 0 R, âˆ€á¶  (n : â„•) in atTop, |f n| â‰¤ a ^ n].TFAE","theorem TFAE_exists_lt_isLittleO_pow (f : â„• â†’ â„) (R : â„) :
    TFAE
      [âˆƒ a âˆˆ Ioo (-R) R, f =o[atTop] (a ^ Â·), âˆƒ a âˆˆ Ioo 0 R, f =o[atTop] (a ^ Â·),
        âˆƒ a âˆˆ Ioo (-R) R, f =O[atTop] (a ^ Â·), âˆƒ a âˆˆ Ioo 0 R, f =O[atTop] (a ^ Â·),
        âˆƒ a < R, âˆƒ C : â„, (0 < C âˆ¨ 0 < R) âˆ§ âˆ€ n, |f n| â‰¤ C * a ^ n,
        âˆƒ a âˆˆ Ioo 0 R, âˆƒ C > 0, âˆ€ n, |f n| â‰¤ C * a ^ n, âˆƒ a < R, âˆ€á¶  n in atTop, |f n| â‰¤ a ^ n,
        âˆƒ a âˆˆ Ioo 0 R, âˆ€á¶  n in atTop, |f n| â‰¤ a ^ n] ",":= by
  have A : Ico 0 R âŠ† Ioo (-R) R :=
    fun x hx â†¦ âŸ¨(neg_lt_zero.2 (hx.1.trans_lt hx.2)).trans_le hx.1, hx.2âŸ©
  have B : Ioo 0 R âŠ† Ioo (-R) R := Subset.trans Ioo_subset_Ico_self A
  tfae_have 1 â†’ 3
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha, H.isBigOâŸ©
  tfae_have 2 â†’ 1
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, B ha, HâŸ©
  tfae_have 3 â†’ 2
  Â· rintro âŸ¨a, ha, HâŸ©
    rcases exists_between (abs_lt.2 ha) with âŸ¨b, hab, hbRâŸ©
    exact âŸ¨b, âŸ¨(abs_nonneg a).trans_lt hab, hbRâŸ©,
      H.trans_isLittleO (isLittleO_pow_pow_of_abs_lt_left (hab.trans_le (le_abs_self b)))âŸ©
  tfae_have 2 â†’ 4
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha, H.isBigOâŸ©
  tfae_have 4 â†’ 3
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, B ha, HâŸ©
  tfae_have 4 â†’ 6
  Â· rintro âŸ¨a, ha, HâŸ©
    rcases bound_of_isBigO_nat_atTop H with âŸ¨C, hCâ‚€, hCâŸ©
    refine âŸ¨a, ha, C, hCâ‚€, fun n â†¦ ?_âŸ©
    simpa only [Real.norm_eq_abs, abs_pow, abs_of_nonneg ha.1.le] using hC (pow_ne_zero n ha.1.ne')
  tfae_have 6 â†’ 5
  Â· exact fun âŸ¨a, ha, C, Hâ‚€, HâŸ© â†¦ âŸ¨a, ha.2, C, Or.inl Hâ‚€, HâŸ©
  tfae_have 5 â†’ 3
  Â· rintro âŸ¨a, ha, C, hâ‚€, HâŸ©
    rcases sign_cases_of_C_mul_pow_nonneg fun n â†¦ (abs_nonneg _).trans (H n) with (rfl | âŸ¨hCâ‚€, haâ‚€âŸ©)
    Â· obtain rfl : f = 0 := by
        ext n
        simpa using H n
      simp only [lt_irrefl, false_or_iff] at hâ‚€
      exact âŸ¨0, âŸ¨neg_lt_zero.2 hâ‚€, hâ‚€âŸ©, isBigO_zero _ _âŸ©
    exact âŸ¨a, A âŸ¨haâ‚€, haâŸ©,
      isBigO_of_le' _ fun n â†¦ (H n).trans <| mul_le_mul_of_nonneg_left (le_abs_self _) hCâ‚€.leâŸ©
  tfae_have 2 â†’ 8
  Â· rintro âŸ¨a, ha, HâŸ©
    refine âŸ¨a, ha, (H.def zero_lt_one).mono fun n hn â†¦ ?_âŸ©
    rwa [Real.norm_eq_abs, Real.norm_eq_abs, one_mul, abs_pow, abs_of_pos ha.1] at hn
  tfae_have 8 â†’ 7
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha.2, HâŸ©
  tfae_have 7 â†’ 3
  Â· rintro âŸ¨a, ha, HâŸ©
    have : 0 â‰¤ a := nonneg_of_eventually_pow_nonneg (H.mono fun n â†¦ (abs_nonneg _).trans)
    refine âŸ¨a, A âŸ¨this, haâŸ©, IsBigO.of_bound 1 ?_âŸ©
    simpa only [Real.norm_eq_abs, one_mul, abs_pow, abs_of_nonneg this]
  tfae_have 6 â†’ 7
  Â· exact fun h â†¦ tfae_8_to_7 <| tfae_2_to_8 <| tfae_3_to_2 <| tfae_5_to_3 <| tfae_6_to_5 h
  tfae_finish",refine TFAE_exists_lt_isLittleO_pow (f := f) (R := TFAE_exists_lt_isLittleO_pow f f R)
Mathlib/GroupTheory/PushoutI.lean,Monoid.PushoutI.inf_of_range_eq_base_range,inf_of_range_eq_base_range,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":=
  le_antisymm
    (by
      intro x âŸ¨âŸ¨gâ‚, hgâ‚âŸ©, âŸ¨gâ‚‚, hgâ‚‚âŸ©âŸ©
      by_contra hx
      have hx1 : x â‰  1 := by rintro rfl; simp_all only [ne_eq, one_mem, not_true_eq_false]
      have hgâ‚1 : gâ‚ â‰  1 :=
        ne_of_apply_ne (of (Ï† := Ï†) i) (by simp_all)
      have hgâ‚‚1 : gâ‚‚ â‰  1 :=
        ne_of_apply_ne (of (Ï† := Ï†) j) (by simp_all)
      have hgâ‚r : gâ‚ âˆ‰ (Ï† i).range := by
        rintro âŸ¨y, rflâŸ©
        subst hgâ‚
        exact hx (of_apply_eq_base Ï† i y â–¸ MonoidHom.mem_range.2 âŸ¨y, rflâŸ©)
      have hgâ‚‚r : gâ‚‚ âˆ‰ (Ï† j).range := by
        rintro âŸ¨y, rflâŸ©
        subst hgâ‚‚
        exact hx (of_apply_eq_base Ï† j y â–¸ MonoidHom.mem_range.2 âŸ¨y, rflâŸ©)
      let w : Word G := âŸ¨[âŸ¨_, gâ‚âŸ©, âŸ¨_, gâ‚‚â»Â¹âŸ©], by simp_all, by simp_allâŸ©
      have hw : Reduced Ï† w := by
        simp only [not_exists, ne_eq, Reduced, List.find?, List.mem_cons, List.mem_singleton,
          forall_eq_or_imp, not_false_eq_true, forall_const, forall_eq, true_and, hgâ‚r, hgâ‚‚r,
          List.mem_nil_iff, false_imp_iff, imp_true_iff, and_true, inv_mem_iff]
      have := hw.eq_empty_of_mem_range hÏ† (by
        simp only [Word.prod, List.map_cons, List.prod_cons, List.prod_nil,
          List.map_nil, map_mul, ofCoprodI_of, hgâ‚, hgâ‚‚, map_inv, map_one, mul_one,
          mul_inv_self, one_mem])
      simp [Word.empty] at this)
    (le_inf
      (by rw [â† of_comp_eq_base i]
          rintro _ âŸ¨h, rflâŸ©
          exact MonoidHom.mem_range.2 âŸ¨Ï† i h, rflâŸ©)
      (by rw [â† of_comp_eq_base j]
          rintro _ âŸ¨h, rflâŸ©
          exact MonoidHom.mem_range.2 âŸ¨Ï† j h, rflâŸ©))","error:  unsolved goals
Î¹ : Type u_1
G : Î¹ â†’ Type u_2
H : Type u_3
K : Type u_4
instâœÂ² : Monoid K
instâœÂ¹ : (i : Î¹) â†’ Group (G i)
instâœ : Group H
Ï† : (i : Î¹) â†’ H â†’* G i
hÏ† : âˆ€ (i : Î¹), Injective â‡‘(Ï† i)
i j : Î¹
hij : i â‰  j
x : PushoutI Ï†
gâ‚ : G i
hgâ‚ : (of i) gâ‚ = x
gâ‚‚ : G j
hgâ‚‚ : (of j) gâ‚‚ = x
hx : Â¬x âˆˆ (base Ï†).range
hx1 : x â‰  1
hgâ‚1 : gâ‚ â‰  1
hgâ‚‚1 : gâ‚‚ â‰  1
hgâ‚r : gâ‚ âˆ‰ (Ï† i).range
hgâ‚‚r : gâ‚‚ âˆ‰ (Ï† j).range
w : Word G := { toList := [âŸ¨i, gâ‚âŸ©, âŸ¨j, gâ‚‚â»Â¹âŸ©], ne_one := â‹¯, chain_ne := â‹¯ }
hw : Reduced Ï† w
this : w = { toList := [], ne_one := â‹¯, chain_ne := â‹¯ }
âŠ¢ False","theorem inf_of_range_eq_base_range (hÏ† : âˆ€ i, Injective (Ï† i)) {i j : Î¹} (hij : i â‰  j) :
    (of i).range âŠ“ (of j).range = (base Ï†).range ",":=
  le_antisymm
    (by
      intro x âŸ¨âŸ¨gâ‚, hgâ‚âŸ©, âŸ¨gâ‚‚, hgâ‚‚âŸ©âŸ©
      by_contra hx
      have hx1 : x â‰  1 := by rintro rfl; simp_all only [ne_eq, one_mem, not_true_eq_false]
      have hgâ‚1 : gâ‚ â‰  1 :=
        ne_of_apply_ne (of (Ï† := Ï†) i) (by simp_all)
      have hgâ‚‚1 : gâ‚‚ â‰  1 :=
        ne_of_apply_ne (of (Ï† := Ï†) j) (by simp_all)
      have hgâ‚r : gâ‚ âˆ‰ (Ï† i).range := by
        rintro âŸ¨y, rflâŸ©
        subst hgâ‚
        exact hx (of_apply_eq_base Ï† i y â–¸ MonoidHom.mem_range.2 âŸ¨y, rflâŸ©)
      have hgâ‚‚r : gâ‚‚ âˆ‰ (Ï† j).range := by
        rintro âŸ¨y, rflâŸ©
        subst hgâ‚‚
        exact hx (of_apply_eq_base Ï† j y â–¸ MonoidHom.mem_range.2 âŸ¨y, rflâŸ©)
      let w : Word G := âŸ¨[âŸ¨_, gâ‚âŸ©, âŸ¨_, gâ‚‚â»Â¹âŸ©], by simp_all, by simp_allâŸ©
      have hw : Reduced Ï† w := by
        simp only [not_exists, ne_eq, Reduced, List.find?, List.mem_cons, List.mem_singleton,
          forall_eq_or_imp, not_false_eq_true, forall_const, forall_eq, true_and, hgâ‚r, hgâ‚‚r,
          List.mem_nil_iff, false_imp_iff, imp_true_iff, and_true, inv_mem_iff]
      have := hw.eq_empty_of_mem_range hÏ† (by
        simp only [Word.prod, List.map_cons, List.prod_cons, List.prod_nil,
          List.map_nil, map_mul, ofCoprodI_of, hgâ‚, hgâ‚‚, map_inv, map_one, mul_one,
          mul_inv_self, one_mem])
      simp [w, Word.empty] at this)
    (le_inf
      (by rw [â† of_comp_eq_base i]
          rintro _ âŸ¨h, rflâŸ©
          exact MonoidHom.mem_range.2 âŸ¨Ï† i h, rflâŸ©)
      (by rw [â† of_comp_eq_base j]
          rintro _ âŸ¨h, rflâŸ©
          exact MonoidHom.mem_range.2 âŸ¨Ï† j h, rflâŸ©))","rw [â† inf_of_range_eq_base_range, inf_of_range_eq_base_range]"
Mathlib/SetTheory/Ordinal/Arithmetic.lean,Ordinal.one_add_omega,one_add_omega,162e9d88f2a813194aaa648791544b64eb14df1d,":= by
  refine' le_antisymm _ (le_add_left _ _)
  rw [omega, â† lift_one.{_, 0}, â† lift_add, lift_le, â† type_unit, â† type_sum_lex]
  refine' âŸ¨RelEmbedding.collapse (RelEmbedding.ofMonotone _ _)âŸ©
  Â· apply Sum.rec
    Â· exact fun _ => 0
    Â· exact Nat.succ
  Â· intro a b
    cases a <;> cases b <;> intro H <;> cases' H with _ _ H _ _ H <;>
      [exact H.elim; exact Nat.succ_pos _; exact Nat.succ_lt_succ H]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  lift.{?u.63187, ?u.63186} ?a + lift.{?u.63187, ?u.63186} ?b
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
r : Î± â†’ Î± â†’ Prop
s : Î² â†’ Î² â†’ Prop
t : Î³ â†’ Î³ â†’ Prop
âŠ¢ lift.{0, u_4} 1 + lift.{u_4, 0} (type fun x x_1 â†¦ x < x_1) â‰¤ lift.{u_4, 0} (type fun x x_1 â†¦ x < x_1)",theorem one_add_omega : 1 + Ï‰ = Ï‰ ,":= by
  refine le_antisymm ?_ (le_add_left _ _)
  rw [omega, â† lift_one.{0}, â† lift_add, lift_le, â† type_unit, â† type_sum_lex]
  refine âŸ¨RelEmbedding.collapse (RelEmbedding.ofMonotone ?_ ?_)âŸ©
  Â· apply Sum.rec
    Â· exact fun _ => 0
    Â· exact Nat.succ
  Â· intro a b
    cases a <;> cases b <;> intro H <;> cases' H with _ _ H _ _ H <;>
      [exact H.elim; exact Nat.succ_pos _; exact Nat.succ_lt_succ H]",simp [one_add_omega]
Mathlib/RingTheory/ClassGroup.lean,ClassGroup.induction,ClassGroup.induction,e406b2ea849d364a8088bb124711622aa6b81eeb,":=
  QuotientGroup.induction_on x fun I => by
    have : I = (Units.mapEquiv (canonicalEquiv Râ° K (FractionRing R)).toMulEquiv)
      (Units.mapEquiv (canonicalEquiv Râ° (FractionRing R) K).toMulEquiv I) := by
      simp [â† Units.eq_iff]
    rw [_root_.congr_arg
      (QuotientGroup.mk (s := (range <| toPrincipalIdeal R (FractionRing R)))) this]
    exact h _",error:  unknown identifier 'range',"theorem ClassGroup.induction {P : ClassGroup R â†’ Prop}
    (h : âˆ€ I : (FractionalIdeal Râ° K)Ë£, P (ClassGroup.mk I)) (x : ClassGroup R) : P x ",":=
  QuotientGroup.induction_on x fun I => by
    have : I = (Units.mapEquiv (canonicalEquiv Râ° K (FractionRing R)).toMulEquiv)
      (Units.mapEquiv (canonicalEquiv Râ° (FractionRing R) K).toMulEquiv I) := by
      simp [â† Units.eq_iff]
    rw [congr_arg (QuotientGroup.mk (s := (toPrincipalIdeal R (FractionRing R)).range)) this]
    exact h _",apply ClassGroup.induction_induction
Mathlib/RingTheory/Polynomial/Pochhammer.lean,descPochhammer_succ_right,descPochhammer_succ_right,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  suffices h : descPochhammer â„¤ (n + 1) = descPochhammer â„¤ n * (X - (n : â„¤[X])) by
    apply_fun Polynomial.map (algebraMap â„¤ R) at h
    simpa [descPochhammer_map, Polynomial.map_mul, Polynomial.map_add, map_X,
      Polynomial.map_intCast] using h
  induction' n with n ih
  Â· simp [descPochhammer]
  Â· conv_lhs =>
      rw [descPochhammer_succ_left, ih, mul_comp, â† mul_assoc, â† descPochhammer_succ_left, sub_comp,
          X_comp, natCast_comp]
    nth_rw 1 [Nat.succ_eq_add_one]
    rw [Nat.succ_eq_one_add, Nat.cast_add, Nat.cast_one, sub_add_eq_sub_sub]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ
R : Type u
instâœ : Ring R
n : â„•
ih : descPochhammer â„¤ (n + 1) = descPochhammer â„¤ n * (X - â†‘n)
âŠ¢ descPochhammer â„¤ (n + 1) * (X - 1 - â†‘n) = descPochhammer â„¤ (n + 1) * (X - â†‘(n + 1))","theorem descPochhammer_succ_right (n : â„•) :
    descPochhammer R (n + 1) = descPochhammer R n * (X - (n : R[X])) ",":= by
  suffices h : descPochhammer â„¤ (n + 1) = descPochhammer â„¤ n * (X - (n : â„¤[X])) by
    apply_fun Polynomial.map (algebraMap â„¤ R) at h
    simpa [descPochhammer_map, Polynomial.map_mul, Polynomial.map_add, map_X,
      Polynomial.map_intCast] using h
  induction' n with n ih
  Â· simp [descPochhammer]
  Â· conv_lhs =>
      rw [descPochhammer_succ_left, ih, mul_comp, â† mul_assoc, â† descPochhammer_succ_left, sub_comp,
          X_comp, natCast_comp]
    rw [Nat.cast_add, Nat.cast_one, sub_add_eq_sub_sub_swap]","rw [descPochhammer_succ_right, descPochhammer_succ_right]"
Mathlib/Geometry/Euclidean/Circumcenter.lean,EuclideanGeometry.existsUnique_dist_eq_of_insert,existsUnique_dist_eq_of_insert,a380f5a603bf5030bc30e58b1aed19567f67b98d,":= by
  haveI : Nonempty s := Set.Nonempty.to_subtype (hnps.mono hps)
  rcases hu with âŸ¨âŸ¨cc, crâŸ©, âŸ¨hcc, hcrâŸ©, hcccruâŸ©
  simp only at hcc hcr hcccru
  let x := dist cc (orthogonalProjection s p)
  let y := dist p (orthogonalProjection s p)
  have hy0 : y â‰  0 := dist_orthogonalProjection_ne_zero_of_not_mem hp
  let yccâ‚‚ := (x * x + y * y - cr * cr) / (2 * y)
  let ccâ‚‚ := (yccâ‚‚ / y) â€¢ (p -áµ¥ orthogonalProjection s p : V) +áµ¥ cc
  let crâ‚‚ := Real.sqrt (cr * cr + yccâ‚‚ * yccâ‚‚)
  use âŸ¨ccâ‚‚, crâ‚‚âŸ©
  simp (config := { zeta := false, proj := false }) only
  have hpo : p = (1 : â„) â€¢ (p -áµ¥ orthogonalProjection s p : V) +áµ¥ (orthogonalProjection s p : P) :=
    by simp
  constructor
  Â· constructor
    Â· refine' vadd_mem_of_mem_direction _ (mem_affineSpan â„ (Set.mem_insert_of_mem _ hcc))
      rw [direction_affineSpan]
      exact
        Submodule.smul_mem _ _
          (vsub_mem_vectorSpan â„ (Set.mem_insert _ _)
            (Set.mem_insert_of_mem _ (orthogonalProjection_mem _)))
    Â· intro p1 hp1
      rw [Sphere.mem_coe, mem_sphere, â† mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
        Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _))]
      cases' hp1 with hp1 hp1
      Â· rw [hp1]
        rw [hpo,
          dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd (orthogonalProjection_mem p) hcc _ _
            (vsub_orthogonalProjection_mem_direction_orthogonal s p),
          â† dist_eq_norm_vsub V p, dist_comm _ cc]
        field_simp [yccâ‚‚, hy0]
        ring
      Â· rw [dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq _ (hps hp1),
          orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hcc, Subtype.coe_mk,
          dist_of_mem_subset_mk_sphere hp1 hcr, dist_eq_norm_vsub V ccâ‚‚ cc, vadd_vsub, norm_smul, â†
          dist_eq_norm_vsub V, Real.norm_eq_abs, abs_div, abs_of_nonneg dist_nonneg,
          div_mul_cancel _ hy0, abs_mul_abs_self]
  Â· rintro âŸ¨ccâ‚ƒ, crâ‚ƒâŸ© âŸ¨hccâ‚ƒ, hcrâ‚ƒâŸ©
    simp only at hccâ‚ƒ hcrâ‚ƒ
    obtain âŸ¨tâ‚ƒ, ccâ‚ƒ', hccâ‚ƒ', hccâ‚ƒ''âŸ© :
      âˆƒ r : â„, âˆƒ p0 âˆˆ s, ccâ‚ƒ = r â€¢ (p -áµ¥ â†‘((orthogonalProjection s) p)) +áµ¥ p0 := by
      rwa [mem_affineSpan_insert_iff (orthogonalProjection_mem p)] at hccâ‚ƒ
    have hcrâ‚ƒ' : âˆƒ r, âˆ€ p1 âˆˆ ps, dist p1 ccâ‚ƒ = r :=
      âŸ¨crâ‚ƒ, fun p1 hp1 => dist_of_mem_subset_mk_sphere (Set.mem_insert_of_mem _ hp1) hcrâ‚ƒâŸ©
    rw [exists_dist_eq_iff_exists_dist_orthogonalProjection_eq hps ccâ‚ƒ, hccâ‚ƒ'',
      orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hccâ‚ƒ'] at hcrâ‚ƒ'
    cases' hcrâ‚ƒ' with crâ‚ƒ' hcrâ‚ƒ'
    have hu := hcccru âŸ¨ccâ‚ƒ', crâ‚ƒ'âŸ©
    simp only at hu
    replace hu := hu âŸ¨hccâ‚ƒ', hcrâ‚ƒ'âŸ©
    cases' hu
    have hcrâ‚ƒval : crâ‚ƒ = Real.sqrt (cr * cr + tâ‚ƒ * y * (tâ‚ƒ * y)) := by
      cases' hnps with p0 hp0
      have h' : â†‘(âŸ¨cc, hccâ‚ƒ'âŸ© : s) = cc := rfl
      rw [â† dist_of_mem_subset_mk_sphere (Set.mem_insert_of_mem _ hp0) hcrâ‚ƒ, hccâ‚ƒ'', â†
        mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
        Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _)),
        dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq _ (hps hp0),
        orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hccâ‚ƒ', h',
        dist_of_mem_subset_mk_sphere hp0 hcr, dist_eq_norm_vsub V _ cc, vadd_vsub, norm_smul, â†
        dist_eq_norm_vsub V p, Real.norm_eq_abs, â† mul_assoc, mul_comm _ |tâ‚ƒ|, â† mul_assoc,
        abs_mul_abs_self]
      ring
    replace hcrâ‚ƒ := dist_of_mem_subset_mk_sphere (Set.mem_insert _ _) hcrâ‚ƒ
    rw [hpo, hccâ‚ƒ'', hcrâ‚ƒval, â† mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
      dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd (orthogonalProjection_mem p) hccâ‚ƒ' _ _
        (vsub_orthogonalProjection_mem_direction_orthogonal s p),
      dist_comm, â† dist_eq_norm_vsub V p,
      Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _))] at hcrâ‚ƒ
    change x * x + _ * (y * y) = _ at hcrâ‚ƒ
    rw [show
        x * x + (1 - tâ‚ƒ) * (1 - tâ‚ƒ) * (y * y) = x * x + y * y - 2 * y * (tâ‚ƒ * y) + tâ‚ƒ * y * (tâ‚ƒ * y)
        by ring,
      add_left_inj] at hcrâ‚ƒ
    have htâ‚ƒ : tâ‚ƒ = yccâ‚‚ / y := by
      field_simp [yccâ‚‚, â† hcrâ‚ƒ, hy0]
      ring
    subst htâ‚ƒ
    change ccâ‚ƒ = ccâ‚‚ at hccâ‚ƒ''
    congr
    rw [hcrâ‚ƒval]
    congr 2
    field_simp [hy0]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.90264 / ?m.90278 * ?m.90278
case h.left.right.inr
V : Type u_1
P : Type u_2
instâœâ´ : NormedAddCommGroup V
instâœÂ³ : InnerProductSpace â„ V
instâœÂ² : MetricSpace P
instâœÂ¹ : NormedAddTorsor V P
s : AffineSubspace â„ P
instâœ : HasOrthogonalProjection s.direction
ps : Set P
hnps : ps.Nonempty
p : P
hps : ps âŠ† â†‘s
hp : p âˆ‰ s
this : Nonempty â†¥s
cc : P
cr : â„
hcccru : âˆ€ (y : Sphere P), y.center âˆˆ s âˆ§ ps âŠ† Metric.sphere y.center y.radius â†’ y = { center := cc, radius := cr }
hcc : cc âˆˆ s
hcr : ps âŠ† Metric.sphere cc cr
x : â„ := dist cc â†‘((orthogonalProjection s) p)
y : â„ := dist p â†‘((orthogonalProjection s) p)
hy0 : y â‰  0
yccâ‚‚ : â„ := (x * x + y * y - cr * cr) / (2 * y)
ccâ‚‚ : P := (yccâ‚‚ / y) â€¢ (p -áµ¥ â†‘((orthogonalProjection s) p)) +áµ¥ cc
crâ‚‚ : â„ := âˆš(cr * cr + yccâ‚‚ * yccâ‚‚)
hpo : p = 1 â€¢ (p -áµ¥ â†‘((orthogonalProjection s) p)) +áµ¥ â†‘((orthogonalProjection s) p)
p1 : P
hp1 : p1 âˆˆ ps
âŠ¢ cr * cr +
      |yccâ‚‚| / dist p â†‘((orthogonalProjection s) p) * dist p â†‘((orthogonalProjection s) p) *
        (|yccâ‚‚| / dist p â†‘((orthogonalProjection s) p) * dist p â†‘((orthogonalProjection s) p)) =
    cr * cr + yccâ‚‚ * yccâ‚‚
error:  application type mismatch
  div_mul_cancel ?m.90264 hy0
argument
  hy0
has type
  y â‰  0 : Prop
but is expected to have type
  ?m.90262 : Type ?u.90261","theorem existsUnique_dist_eq_of_insert {s : AffineSubspace â„ P}
    [HasOrthogonalProjection s.direction] {ps : Set P} (hnps : ps.Nonempty) {p : P} (hps : ps âŠ† s)
    (hp : p âˆ‰ s) (hu : âˆƒ! cs : Sphere P, cs.center âˆˆ s âˆ§ ps âŠ† (cs : Set P)) :
    âˆƒ! csâ‚‚ : Sphere P,
      csâ‚‚.center âˆˆ affineSpan â„ (insert p (s : Set P)) âˆ§ insert p ps âŠ† (csâ‚‚ : Set P) ",":= by
  haveI : Nonempty s := Set.Nonempty.to_subtype (hnps.mono hps)
  rcases hu with âŸ¨âŸ¨cc, crâŸ©, âŸ¨hcc, hcrâŸ©, hcccruâŸ©
  simp only at hcc hcr hcccru
  let x := dist cc (orthogonalProjection s p)
  let y := dist p (orthogonalProjection s p)
  have hy0 : y â‰  0 := dist_orthogonalProjection_ne_zero_of_not_mem hp
  let yccâ‚‚ := (x * x + y * y - cr * cr) / (2 * y)
  let ccâ‚‚ := (yccâ‚‚ / y) â€¢ (p -áµ¥ orthogonalProjection s p : V) +áµ¥ cc
  let crâ‚‚ := âˆš(cr * cr + yccâ‚‚ * yccâ‚‚)
  use âŸ¨ccâ‚‚, crâ‚‚âŸ©
  simp (config := { zeta := false, proj := false }) only
  have hpo : p = (1 : â„) â€¢ (p -áµ¥ orthogonalProjection s p : V) +áµ¥ (orthogonalProjection s p : P) :=
    by simp
  constructor
  Â· constructor
    Â· refine vadd_mem_of_mem_direction ?_ (mem_affineSpan â„ (Set.mem_insert_of_mem _ hcc))
      rw [direction_affineSpan]
      exact
        Submodule.smul_mem _ _
          (vsub_mem_vectorSpan â„ (Set.mem_insert _ _)
            (Set.mem_insert_of_mem _ (orthogonalProjection_mem _)))
    Â· intro p1 hp1
      rw [Sphere.mem_coe, mem_sphere, â† mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
        Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _))]
      cases' hp1 with hp1 hp1
      Â· rw [hp1]
        rw [hpo,
          dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd (orthogonalProjection_mem p) hcc _ _
            (vsub_orthogonalProjection_mem_direction_orthogonal s p),
          â† dist_eq_norm_vsub V p, dist_comm _ cc]
        field_simp [yccâ‚‚, hy0]
        ring
      Â· rw [dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq _ (hps hp1),
          orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hcc, Subtype.coe_mk,
          dist_of_mem_subset_mk_sphere hp1 hcr, dist_eq_norm_vsub V ccâ‚‚ cc, vadd_vsub, norm_smul, â†
          dist_eq_norm_vsub V, Real.norm_eq_abs, abs_div, abs_of_nonneg dist_nonneg,
          div_mul_cancelâ‚€ _ hy0, abs_mul_abs_self]
  Â· rintro âŸ¨ccâ‚ƒ, crâ‚ƒâŸ© âŸ¨hccâ‚ƒ, hcrâ‚ƒâŸ©
    simp only at hccâ‚ƒ hcrâ‚ƒ
    obtain âŸ¨tâ‚ƒ, ccâ‚ƒ', hccâ‚ƒ', hccâ‚ƒ''âŸ© :
      âˆƒ r : â„, âˆƒ p0 âˆˆ s, ccâ‚ƒ = r â€¢ (p -áµ¥ â†‘((orthogonalProjection s) p)) +áµ¥ p0 := by
      rwa [mem_affineSpan_insert_iff (orthogonalProjection_mem p)] at hccâ‚ƒ
    have hcrâ‚ƒ' : âˆƒ r, âˆ€ p1 âˆˆ ps, dist p1 ccâ‚ƒ = r :=
      âŸ¨crâ‚ƒ, fun p1 hp1 => dist_of_mem_subset_mk_sphere (Set.mem_insert_of_mem _ hp1) hcrâ‚ƒâŸ©
    rw [exists_dist_eq_iff_exists_dist_orthogonalProjection_eq hps ccâ‚ƒ, hccâ‚ƒ'',
      orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hccâ‚ƒ'] at hcrâ‚ƒ'
    cases' hcrâ‚ƒ' with crâ‚ƒ' hcrâ‚ƒ'
    have hu := hcccru âŸ¨ccâ‚ƒ', crâ‚ƒ'âŸ©
    simp only at hu
    replace hu := hu âŸ¨hccâ‚ƒ', hcrâ‚ƒ'âŸ©
    cases' hu
    have hcrâ‚ƒval : crâ‚ƒ = âˆš(cr * cr + tâ‚ƒ * y * (tâ‚ƒ * y)) := by
      cases' hnps with p0 hp0
      have h' : â†‘(âŸ¨cc, hccâ‚ƒ'âŸ© : s) = cc := rfl
      rw [â† dist_of_mem_subset_mk_sphere (Set.mem_insert_of_mem _ hp0) hcrâ‚ƒ, hccâ‚ƒ'', â†
        mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
        Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _)),
        dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq _ (hps hp0),
        orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hccâ‚ƒ', h',
        dist_of_mem_subset_mk_sphere hp0 hcr, dist_eq_norm_vsub V _ cc, vadd_vsub, norm_smul, â†
        dist_eq_norm_vsub V p, Real.norm_eq_abs, â† mul_assoc, mul_comm _ |tâ‚ƒ|, â† mul_assoc,
        abs_mul_abs_self]
      ring
    replace hcrâ‚ƒ := dist_of_mem_subset_mk_sphere (Set.mem_insert _ _) hcrâ‚ƒ
    rw [hpo, hccâ‚ƒ'', hcrâ‚ƒval, â† mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
      dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd (orthogonalProjection_mem p) hccâ‚ƒ' _ _
        (vsub_orthogonalProjection_mem_direction_orthogonal s p),
      dist_comm, â† dist_eq_norm_vsub V p,
      Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _))] at hcrâ‚ƒ
    change x * x + _ * (y * y) = _ at hcrâ‚ƒ
    rw [show
        x * x + (1 - tâ‚ƒ) * (1 - tâ‚ƒ) * (y * y) = x * x + y * y - 2 * y * (tâ‚ƒ * y) + tâ‚ƒ * y * (tâ‚ƒ * y)
        by ring,
      add_left_inj] at hcrâ‚ƒ
    have htâ‚ƒ : tâ‚ƒ = yccâ‚‚ / y := by field_simp [yccâ‚‚, â† hcrâ‚ƒ, hy0]
    subst htâ‚ƒ
    change ccâ‚ƒ = ccâ‚‚ at hccâ‚ƒ''
    congr
    rw [hcrâ‚ƒval]
    congr 2
    field_simp [hy0]",refine theorem_existsUnique_dist_eq_of_not_mem_affineSpan_insert ?_ ?_ ?_
Mathlib/NumberTheory/ArithmeticFunction.lean,ArithmeticFunction.cardFactors_multiset_prod,cardFactors_multiset_prod,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction s with
  | empty => simp
  | cons ih => simp_all [cardFactors_mul, not_or]","warning:  zeta does not have a doc string
warning:  Î¶ does not have a doc string
warning:  sigma does not have a doc string
warning:  Ïƒ does not have a doc string
warning:  cardFactors does not have a doc string
warning:  Î© does not have a doc string
error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
R : Type u_1
s : Multiset â„•
h0 : s.prod â‰  0
âŠ¢ Î© s.prod = (Multiset.map (â‡‘Î©) s).sum
warning:  cardDistinctFactors does not have a doc string
warning:  Ï‰ does not have a doc string
warning:  moebius does not have a doc string
warning:  Î¼ does not have a doc string","theorem cardFactors_multiset_prod {s : Multiset â„•} (h0 : s.prod â‰  0) :
    Î© s.prod = (Multiset.map Î© s).sum ",":= by
  induction s using Multiset.induction_on with
  | empty => simp
  | cons ih => simp_all [cardFactors_mul, not_or]","rw [Multiset.sum_eq_singleton, Multiset.sum_eq_singleton, Multiset.sum_eq_singleton]"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate,LinearIsometryEquiv.reflections_generate,9f377843ae74f8ea35a167e1fcc7752e1a90722a,":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine' âŸ¨[], rfl.le, show Ï† = 1 from _âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [Nat.zero_eq, le_zero_iff, Module.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      linarith
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine' âŸ¨x::l, Nat.succ_le_succ hl, _âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg ((Â· * Â·) Ï) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâµ : _root_.RCLike ğ•œ
instâœâ´ : NormedAddCommGroup E
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : InnerProductSpace ğ•œ E
instâœÂ¹ : InnerProductSpace â„ F
K : Submodule ğ•œ E
instâœ : FiniteDimensional â„ F
Ï† : F â‰ƒâ‚—áµ¢[â„] F
hn :
  finrank â„
      â†¥(LinearMap.ker
            (ContinuousLinearMap.id â„ F -
              â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }))á—® â‰¤
    0
âŠ¢ LinearMap.ker
      (ContinuousLinearMap.id â„ F -
        â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }) =
    âŠ¤","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional â„ F] {n : â„•}
    (Ï† : F â‰ƒâ‚—áµ¢[â„] F) (hn : finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—® â‰¤ n) :
    âˆƒ l : List F, l.length â‰¤ n âˆ§ Ï† = (l.map fun v => reflection (â„ âˆ™ v)á—®).prod ",":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine âŸ¨[], rfl.le, show Ï† = 1 from ?_âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      omega
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine âŸ¨x::l, Nat.succ_le_succ hl, ?_âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this","refine âŸ¨finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—®, ?_, ?_âŸ©"
Mathlib/Analysis/SpecificLimits/Normed.lean,TFAE_exists_lt_isLittleO_pow,TFAE_exists_lt_isLittleO_pow,9973ad6d9c71296bde9b541823189ecbd49322ba,":= by
  have A : Ico 0 R âŠ† Ioo (-R) R :=
    fun x hx â†¦ âŸ¨(neg_lt_zero.2 (hx.1.trans_lt hx.2)).trans_le hx.1, hx.2âŸ©
  have B : Ioo 0 R âŠ† Ioo (-R) R := Subset.trans Ioo_subset_Ico_self A
  tfae_have : 1 â†’ 3 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha, H.isBigOâŸ©
  tfae_have : 2 â†’ 1 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, B ha, HâŸ©
  tfae_have : 3 â†’ 2 := by
    rintro âŸ¨a, ha, HâŸ©
    rcases exists_between (abs_lt.2 ha) with âŸ¨b, hab, hbRâŸ©
    exact âŸ¨b, âŸ¨(abs_nonneg a).trans_lt hab, hbRâŸ©,
      H.trans_isLittleO (isLittleO_pow_pow_of_abs_lt_left (hab.trans_le (le_abs_self b)))âŸ©
  tfae_have : 2 â†’ 4 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha, H.isBigOâŸ©
  tfae_have : 4 â†’ 3 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, B ha, HâŸ©
  tfae_have : 4 â†’ 6 := by
    rintro âŸ¨a, ha, HâŸ©
    rcases bound_of_isBigO_nat_atTop H with âŸ¨C, hCâ‚€, hCâŸ©
    refine' âŸ¨a, ha, C, hCâ‚€, fun n â†¦ _âŸ©
    simpa only [Real.norm_eq_abs, abs_pow, abs_of_nonneg ha.1.le] using hC (pow_ne_zero n ha.1.ne')
  tfae_have : 6 â†’ 5 := fun âŸ¨a, ha, C, Hâ‚€, HâŸ© â†¦ âŸ¨a, ha.2, C, Or.inl Hâ‚€, HâŸ©
  tfae_have : 5 â†’ 3 := by
    rintro âŸ¨a, ha, C, hâ‚€, HâŸ©
    rcases sign_cases_of_C_mul_pow_nonneg fun n â†¦ (abs_nonneg _).trans (H n) with (rfl | âŸ¨hCâ‚€, haâ‚€âŸ©)
    Â· obtain rfl : f = 0 := by
        ext n
        simpa using H n
      simp only [lt_irrefl, false_or_iff] at hâ‚€
      exact âŸ¨0, âŸ¨neg_lt_zero.2 hâ‚€, hâ‚€âŸ©, isBigO_zero _ _âŸ©
    exact âŸ¨a, A âŸ¨haâ‚€, haâŸ©,
      isBigO_of_le' _ fun n â†¦ (H n).trans <| mul_le_mul_of_nonneg_left (le_abs_self _) hCâ‚€.leâŸ©
  tfae_have : 2 â†’ 8 := by
    rintro âŸ¨a, ha, HâŸ©
    refine' âŸ¨a, ha, (H.def zero_lt_one).mono fun n hn â†¦ _âŸ©
    rwa [Real.norm_eq_abs, Real.norm_eq_abs, one_mul, abs_pow, abs_of_pos ha.1] at hn
  tfae_have : 8 â†’ 7 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha.2, HâŸ©
  tfae_have : 7 â†’ 3 := by
    rintro âŸ¨a, ha, HâŸ©
    have : 0 â‰¤ a := nonneg_of_eventually_pow_nonneg (H.mono fun n â†¦ (abs_nonneg _).trans)
    refine' âŸ¨a, A âŸ¨this, haâŸ©, IsBigO.of_bound 1 _âŸ©
    simpa only [Real.norm_eq_abs, one_mul, abs_pow, abs_of_nonneg this]
  tfae_have : 6 â†’ 7 :=
    fun h â†¦ tfae_8_to_7 <| tfae_2_to_8 <| tfae_3_to_2 <| tfae_5_to_3 <| tfae_6_to_5 h
  tfae_finish",error:  unexpected token ':'; expected numeral,"theorem TFAE_exists_lt_isLittleO_pow (f : â„• â†’ â„) (R : â„) :
    TFAE
      [âˆƒ a âˆˆ Ioo (-R) R, f =o[atTop] (a ^ Â·), âˆƒ a âˆˆ Ioo 0 R, f =o[atTop] (a ^ Â·),
        âˆƒ a âˆˆ Ioo (-R) R, f =O[atTop] (a ^ Â·), âˆƒ a âˆˆ Ioo 0 R, f =O[atTop] (a ^ Â·),
        âˆƒ a < R, âˆƒ C : â„, (0 < C âˆ¨ 0 < R) âˆ§ âˆ€ n, |f n| â‰¤ C * a ^ n,
        âˆƒ a âˆˆ Ioo 0 R, âˆƒ C > 0, âˆ€ n, |f n| â‰¤ C * a ^ n, âˆƒ a < R, âˆ€á¶  n in atTop, |f n| â‰¤ a ^ n,
        âˆƒ a âˆˆ Ioo 0 R, âˆ€á¶  n in atTop, |f n| â‰¤ a ^ n] ",":= by
  have A : Ico 0 R âŠ† Ioo (-R) R :=
    fun x hx â†¦ âŸ¨(neg_lt_zero.2 (hx.1.trans_lt hx.2)).trans_le hx.1, hx.2âŸ©
  have B : Ioo 0 R âŠ† Ioo (-R) R := Subset.trans Ioo_subset_Ico_self A
  tfae_have 1 â†’ 3
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha, H.isBigOâŸ©
  tfae_have 2 â†’ 1
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, B ha, HâŸ©
  tfae_have 3 â†’ 2
  Â· rintro âŸ¨a, ha, HâŸ©
    rcases exists_between (abs_lt.2 ha) with âŸ¨b, hab, hbRâŸ©
    exact âŸ¨b, âŸ¨(abs_nonneg a).trans_lt hab, hbRâŸ©,
      H.trans_isLittleO (isLittleO_pow_pow_of_abs_lt_left (hab.trans_le (le_abs_self b)))âŸ©
  tfae_have 2 â†’ 4
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha, H.isBigOâŸ©
  tfae_have 4 â†’ 3
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, B ha, HâŸ©
  tfae_have 4 â†’ 6
  Â· rintro âŸ¨a, ha, HâŸ©
    rcases bound_of_isBigO_nat_atTop H with âŸ¨C, hCâ‚€, hCâŸ©
    refine âŸ¨a, ha, C, hCâ‚€, fun n â†¦ ?_âŸ©
    simpa only [Real.norm_eq_abs, abs_pow, abs_of_nonneg ha.1.le] using hC (pow_ne_zero n ha.1.ne')
  tfae_have 6 â†’ 5
  Â· exact fun âŸ¨a, ha, C, Hâ‚€, HâŸ© â†¦ âŸ¨a, ha.2, C, Or.inl Hâ‚€, HâŸ©
  tfae_have 5 â†’ 3
  Â· rintro âŸ¨a, ha, C, hâ‚€, HâŸ©
    rcases sign_cases_of_C_mul_pow_nonneg fun n â†¦ (abs_nonneg _).trans (H n) with (rfl | âŸ¨hCâ‚€, haâ‚€âŸ©)
    Â· obtain rfl : f = 0 := by
        ext n
        simpa using H n
      simp only [lt_irrefl, false_or_iff] at hâ‚€
      exact âŸ¨0, âŸ¨neg_lt_zero.2 hâ‚€, hâ‚€âŸ©, isBigO_zero _ _âŸ©
    exact âŸ¨a, A âŸ¨haâ‚€, haâŸ©,
      isBigO_of_le' _ fun n â†¦ (H n).trans <| mul_le_mul_of_nonneg_left (le_abs_self _) hCâ‚€.leâŸ©
  tfae_have 2 â†’ 8
  Â· rintro âŸ¨a, ha, HâŸ©
    refine âŸ¨a, ha, (H.def zero_lt_one).mono fun n hn â†¦ ?_âŸ©
    rwa [Real.norm_eq_abs, Real.norm_eq_abs, one_mul, abs_pow, abs_of_pos ha.1] at hn
  tfae_have 8 â†’ 7
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha.2, HâŸ©
  tfae_have 7 â†’ 3
  Â· rintro âŸ¨a, ha, HâŸ©
    have : 0 â‰¤ a := nonneg_of_eventually_pow_nonneg (H.mono fun n â†¦ (abs_nonneg _).trans)
    refine âŸ¨a, A âŸ¨this, haâŸ©, IsBigO.of_bound 1 ?_âŸ©
    simpa only [Real.norm_eq_abs, one_mul, abs_pow, abs_of_nonneg this]
  tfae_have 6 â†’ 7
  Â· exact fun h â†¦ tfae_8_to_7 <| tfae_2_to_8 <| tfae_3_to_2 <| tfae_5_to_3 <| tfae_6_to_5 h
  tfae_finish",refine TFAE_exists_lt_isLittleO_pow (f := f) (R := TFAE_exists_lt_isLittleO_pow f f R)
Mathlib/MeasureTheory/Measure/Haar/Quotient.lean,MeasureTheory.QuotientMeasureEqMeasurePreimage.smulInvariantMeasure_quotient,MeasureTheory.QuotientMeasureEqMeasurePreimage.smulInvariantMeasure_quotient,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,"  measure_preimage_smul g A hA := by
    have meas_Ï€ : Measurable Ï€ := continuous_quotient_mk'.measurable
    obtain âŸ¨ğ“•, hğ“•âŸ© := hasFun.ExistsIsFundamentalDomain
    have hğ“•_translate_fundom : IsFundamentalDomain Î“.op (g â€¢ ğ“•) Î½ :=
      hğ“•.smul_of_comm g
    rw [hğ“•.projection_respects_measure_apply (Î¼ := Î¼)
      (meas_Ï€ (measurableSet_preimage (measurable_const_smul g) hA)),
      hğ“•_translate_fundom.projection_respects_measure_apply (Î¼ := Î¼) hA]
    change Î½ ((Ï€ â»Â¹' _) âˆ© _) = Î½ ((Ï€ â»Â¹' _) âˆ© _)
    set Ï€_preA := Ï€ â»Â¹' A
    have : Ï€ â»Â¹' ((fun x : G â§¸ Î“ => g â€¢ x) â»Â¹' A) = (g * Â·) â»Â¹' Ï€_preA := by ext1; simp [Ï€_preA]
    rw [this]
    have : Î½ ((g * Â·) â»Â¹' Ï€_preA âˆ© ğ“•) = Î½ (Ï€_preA âˆ© (gâ»Â¹ * Â·) â»Â¹' ğ“•) := by
      trans Î½ ((g * Â·) â»Â¹' (Ï€_preA âˆ© (gâ»Â¹ * Â·) â»Â¹' ğ“•))
      Â· rw [preimage_inter]
        congr 2
        simp [Set.preimage]
      rw [measure_preimage_mul]
    rw [this, â† preimage_smul_inv]; rfl","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Î¼ ((fun x â†¦ g â€¢ x) â»Â¹' A)
case intro
G : Type u_1
instâœÂ¹â° : Group G
instâœâ¹ : MeasurableSpace G
instâœâ¸ : TopologicalSpace G
instâœâ· : TopologicalGroup G
instâœâ¶ : BorelSpace G
instâœâµ : PolishSpace G
Î½ : Measure G
Î“ : Subgroup G
instâœâ´ : Countable â†¥Î“
instâœÂ³ : T2Space (G â§¸ Î“)
instâœÂ² : SecondCountableTopology (G â§¸ Î“)
Î¼ : Measure (G â§¸ Î“)
instâœÂ¹ : QuotientMeasureEqMeasurePreimage Î½ Î¼
instâœ : Î½.IsMulLeftInvariant
hasFun : HasFundamentalDomain (â†¥Î“.op) G Î½
g : G
A : Set (G â§¸ Î“)
hA : MeasurableSet A
meas_Ï€ : Measurable QuotientGroup.mk
ğ“• : Set G
hğ“• : IsFundamentalDomain (â†¥Î“.op) ğ“• Î½
hğ“•_translate_fundom : IsFundamentalDomain (â†¥Î“.op) (g â€¢ ğ“•) Î½
âŠ¢ Î¼ ((fun x â†¦ g â€¢ x) â»Â¹' A) = Î¼ A","lemma MeasureTheory.QuotientMeasureEqMeasurePreimage.smulInvariantMeasure_quotient
    [IsMulLeftInvariant Î½] [hasFun : HasFundamentalDomain Î“.op G Î½] :
    SMulInvariantMeasure G (G â§¸ Î“) Î¼ where
","  measure_preimage_smul g A hA := by
    have meas_Ï€ : Measurable Ï€ := continuous_quotient_mk'.measurable
    obtain âŸ¨ğ“•, hğ“•âŸ© := hasFun.ExistsIsFundamentalDomain
    have hğ“•_translate_fundom : IsFundamentalDomain Î“.op (g â€¢ ğ“•) Î½ := hğ“•.smul_of_comm g
    erw [hğ“•.projection_respects_measure_apply (Î¼ := Î¼)
      (meas_Ï€ (measurableSet_preimage (measurable_const_smul g) hA)),
      hğ“•_translate_fundom.projection_respects_measure_apply (Î¼ := Î¼) hA]
    change Î½ ((Ï€ â»Â¹' _) âˆ© _) = Î½ ((Ï€ â»Â¹' _) âˆ© _)
    set Ï€_preA := Ï€ â»Â¹' A
    have : Ï€ â»Â¹' ((fun x : G â§¸ Î“ => g â€¢ x) â»Â¹' A) = (g * Â·) â»Â¹' Ï€_preA := by ext1; simp [Ï€_preA]
    rw [this]
    have : Î½ ((g * Â·) â»Â¹' Ï€_preA âˆ© ğ“•) = Î½ (Ï€_preA âˆ© (gâ»Â¹ * Â·) â»Â¹' ğ“•) := by
      trans Î½ ((g * Â·) â»Â¹' (Ï€_preA âˆ© (gâ»Â¹ * Â·) â»Â¹' ğ“•))
      Â· rw [preimage_inter]
        congr 2
        simp [Set.preimage]
      rw [measure_preimage_mul]
    rw [this, â† preimage_smul_inv]; rfl",refine HasFundamentalDomain.QuotientMeasureEqMeasureEqMeasureEqMeasurePreimage.smulInvariantMeasure_quotient ?_
Mathlib/Computability/AkraBazzi/AkraBazzi.lean,AkraBazziRecurrence.rpow_p_mul_one_add_smoothingFn_ge,rpow_p_mul_one_add_smoothingFn_ge,e3adc4f0695a3d67fb7d7efd6330f16323f31c79,":= by
  rw [Filter.eventually_all]
  intro i
  let q : â„ â†’ â„ := fun x => x ^ (p a b) * (1 + Îµ x)
  have h_diff_q : DifferentiableOn â„ q (Set.Ioi 1) := by
    refine DifferentiableOn.mul
        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)
        differentiableOn_one_add_smoothingFn
    rw [Set.mem_compl_singleton_iff]
    exact ne_of_gt <| zero_lt_one.trans hz
  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc
    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + Îµ z) x := by rfl
          _ =á¶ [atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + Îµ x)
              + x ^ (p a b) * deriv (fun z => 1 + Îµ z) x := by
                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'
                rw [deriv_mul] <;> aesop
          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by
                refine IsBigO.add ?left ?right
                case left => calc
                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + Îµ x))
                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + Îµ x) := by
                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)
                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=
                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO
                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]
                case right => calc
                  (fun x => x ^ (p a b) * deriv (fun z => 1 + Îµ z) x)
                      =O[atTop] (fun x => x ^ (p a b) * xâ»Â¹) := by
                        exact IsBigO.mul (isBigO_refl _ _)
                          isLittleO_deriv_one_add_smoothingFn.isBigO
                    _ =á¶ [atTop] fun x => x ^ ((p a b) - 1) := by
                        filter_upwards [eventually_gt_atTop 0] with x hx
                        rw [â† Real.rpow_neg_one, â† Real.rpow_add hx, â† sub_eq_add_neg]
  have h_main_norm : (fun (n:â„•) => â€–q (r i n) - q (b i * n)â€–)
      â‰¤á¶ [atTop] fun (n:â„•) => â€–(b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)â€– := by
    refine IsLittleO.eventuallyLE ?_
    calc
      (fun (n:â„•) => q (r i n) - q (b i * n))
          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by
            exact R.isBigO_apply_r_sub_b q h_diff_q
              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i
        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by
            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)
        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by
            exact IsBigO.mul (IsBigO.nat_cast_atTop h_deriv_q) (isBigO_refl _ _)
        _ =á¶ [atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by
            filter_upwards [eventually_ne_atTop 0] with n hn
            have hn' : (n:â„) â‰  0 := by positivity
            simp [â† mul_div_assoc, â† Real.rpow_add_one hn']
        _ = fun (n:â„•) => (n:â„) ^ (p a b) * (1 / (log n) ^ 2)   := by simp_rw [mul_div, mul_one]
        _ =Î˜[atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) := by
            refine IsTheta.symm ?_
            simp_rw [mul_assoc]
            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)
            have := R.b_pos i; positivity
        _ =Î˜[atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)
                  <| R.isTheta_smoothingFn_sub_self i
  have h_main : (fun (n:â„•) => q (b i * n) - q (r i n))
      â‰¤á¶ [atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
    calc (fun (n:â„•) => q (b i * n) - q (r i n))
           â‰¤á¶ [atTop] fun (n:â„•) => â€–q (r i n) - q (b i * n)â€– := by
              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _
         _ â‰¤á¶ [atTop] fun (n:â„•) => â€–(b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)â€– :=
              h_main_norm
         _ =á¶ [atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
              filter_upwards [eventually_gt_atTop âŒˆ(b i)â»Â¹âŒ‰â‚Š, eventually_gt_atTop 1] with n hn hn'
              refine norm_of_nonneg ?_
              have hâ‚ := R.b_pos i
              have hâ‚‚ : 0 â‰¤ Îµ (b i * n) - Îµ n := by
                refine sub_nonneg_of_le <|
                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le
                case n_gt_one =>
                  show 1 < (n:â„)
                  rw [Nat.one_lt_cast]
                  exact hn'
                case bn_gt_one =>
                  calc 1 = b i * (b i)â»Â¹ := by rw [mul_inv_cancel (by positivity)]
                      _ â‰¤ b i * âŒˆ(b i)â»Â¹âŒ‰â‚Š := by gcongr; exact Nat.le_ceil _
                      _ < b i * n := by gcongr; rw [Nat.cast_lt]; exact hn
                case le => calc b i * n â‰¤ 1 * n := by have := R.b_lt_one i; gcongr
                                        _ = n := by rw [one_mul]
              positivity
  filter_upwards [h_main] with n hn
  have hâ‚ : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)
      = (b i) ^ (p a b) * n ^ (p a b) * (1 + Îµ n) := by
    have := R.b_pos i
    simp only [mul_rpow (by positivity : (0:â„) â‰¤ b i) (by positivity : (0:â„) â‰¤ n)]
    ring
  show (b i) ^ (p a b) * n ^ (p a b) * (1 + Îµ n) â‰¤ q (r i n)
  rw [â† hâ‚, sub_le_iff_le_add', â† sub_le_iff_le_add]
  exact hn","warning:  `Asymptotics.IsBigO.nat_cast_atTop` has been deprecated, use `Asymptotics.IsBigO.natCast_atTop` instead
error:  simp made no progress","lemma rpow_p_mul_one_add_smoothingFn_ge :
    âˆ€á¶  (n : â„•) in atTop, âˆ€ i, (b i) ^ (p a b) * n ^ (p a b) * (1 + Îµ n)
      â‰¤ (r i n) ^ (p a b) * (1 + Îµ (r i n)) ",":= by
  rw [Filter.eventually_all]
  intro i
  let q : â„ â†’ â„ := fun x => x ^ (p a b) * (1 + Îµ x)
  have h_diff_q : DifferentiableOn â„ q (Set.Ioi 1) := by
    refine DifferentiableOn.mul
        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)
        differentiableOn_one_add_smoothingFn
    rw [Set.mem_compl_singleton_iff]
    rw [Set.mem_Ioi] at hz
    exact ne_of_gt <| zero_lt_one.trans hz
  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc
    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + Îµ z) x := by rfl
          _ =á¶ [atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + Îµ x)
              + x ^ (p a b) * deriv (fun z => 1 + Îµ z) x := by
                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'
                rw [deriv_mul] <;> aesop
          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by
                refine IsBigO.add ?left ?right
                case left => calc
                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + Îµ x))
                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + Îµ x) := by
                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)
                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=
                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO
                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]
                case right => calc
                  (fun x => x ^ (p a b) * deriv (fun z => 1 + Îµ z) x)
                      =O[atTop] (fun x => x ^ (p a b) * xâ»Â¹) := by
                        exact IsBigO.mul (isBigO_refl _ _)
                          isLittleO_deriv_one_add_smoothingFn.isBigO
                    _ =á¶ [atTop] fun x => x ^ ((p a b) - 1) := by
                        filter_upwards [eventually_gt_atTop 0] with x hx
                        rw [â† Real.rpow_neg_one, â† Real.rpow_add hx, â† sub_eq_add_neg]
  have h_main_norm : (fun (n:â„•) => â€–q (r i n) - q (b i * n)â€–)
      â‰¤á¶ [atTop] fun (n:â„•) => â€–(b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)â€– := by
    refine IsLittleO.eventuallyLE ?_
    calc
      (fun (n:â„•) => q (r i n) - q (b i * n))
          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by
            exact R.isBigO_apply_r_sub_b q h_diff_q
              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i
        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by
            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)
        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by
            exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)
        _ =á¶ [atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by
            filter_upwards [eventually_ne_atTop 0] with n hn
            have hn' : (n:â„) â‰  0 := by positivity
            simp [â† mul_div_assoc, â† Real.rpow_add_one hn']
        _ = fun (n:â„•) => (n:â„) ^ (p a b) * (1 / (log n) ^ 2)   := by simp_rw [mul_div, mul_one]
        _ =Î˜[atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) := by
            refine IsTheta.symm ?_
            simp_rw [mul_assoc]
            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)
            have := R.b_pos i; positivity
        _ =Î˜[atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)
                  <| R.isTheta_smoothingFn_sub_self i
  have h_main : (fun (n:â„•) => q (b i * n) - q (r i n))
      â‰¤á¶ [atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
    calc (fun (n:â„•) => q (b i * n) - q (r i n))
           â‰¤á¶ [atTop] fun (n:â„•) => â€–q (r i n) - q (b i * n)â€– := by
              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _
         _ â‰¤á¶ [atTop] fun (n:â„•) => â€–(b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)â€– :=
              h_main_norm
         _ =á¶ [atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
              filter_upwards [eventually_gt_atTop âŒˆ(b i)â»Â¹âŒ‰â‚Š, eventually_gt_atTop 1] with n hn hn'
              refine norm_of_nonneg ?_
              have hâ‚ := R.b_pos i
              have hâ‚‚ : 0 â‰¤ Îµ (b i * n) - Îµ n := by
                refine sub_nonneg_of_le <|
                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le
                case n_gt_one =>
                  show 1 < (n:â„)
                  rw [Nat.one_lt_cast]
                  exact hn'
                case bn_gt_one =>
                  calc 1 = b i * (b i)â»Â¹ := by rw [mul_inv_cancel (by positivity)]
                      _ â‰¤ b i * âŒˆ(b i)â»Â¹âŒ‰â‚Š := by gcongr; exact Nat.le_ceil _
                      _ < b i * n := by gcongr; rw [Nat.cast_lt]; exact hn
                case le => calc b i * n â‰¤ 1 * n := by have := R.b_lt_one i; gcongr
                                        _ = n := by rw [one_mul]
              positivity
  filter_upwards [h_main] with n hn
  have hâ‚ : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)
      = (b i) ^ (p a b) * n ^ (p a b) * (1 + Îµ n) := by
    have := R.b_pos i
    simp only [q, mul_rpow (by positivity : (0:â„) â‰¤ b i) (by positivity : (0:â„) â‰¤ n)]
    ring
  show (b i) ^ (p a b) * n ^ (p a b) * (1 + Îµ n) â‰¤ q (r i n)
  rw [â† hâ‚, sub_le_iff_le_add', â† sub_le_iff_le_add]
  exact hn",rw [eventually_atTop] at rpow_p_mul_one_add_smoothingFn_ge
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.hasIntegral_GP_pderiv,hasIntegral_GP_pderiv,c7bd9bd10c613e1788107ba753e252f069560f87,":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx â†¦ by
    by_cases hxs : x âˆˆ s
    exacts [Hs x hxs, (Hd x âŸ¨hx, hxsâŸ©).continuousWithinAt]
  set fI : â„ â†’ Box (Fin n) â†’ E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) â†’ Fin n â†’áµ‡áµƒ[â†‘(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) â†’áµ‡áµƒ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine' HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le _ _ _ s hs _ _
  Â·
    exact (volume : Measure (Fin (n + 1) â†’ â„)).toBoxAdditive.restrict _ le_top
  Â· exact fun J => ENNReal.toReal_nonneg
  Â· intro c x hx Îµ Îµ0
    have : âˆ€á¶  Î´ in ğ“[>] (0 : â„), Î´ âˆˆ Ioc (0 : â„) (1 / 2) âˆ§
        (âˆ€áµ‰ (yâ‚ âˆˆ closedBall x Î´ âˆ© (Box.Icc I)) (yâ‚‚ âˆˆ closedBall x Î´ âˆ© (Box.Icc I)),
              â€–f yâ‚ - f yâ‚‚â€– â‰¤ Îµ / 2) âˆ§ (2 * Î´) ^ (n + 1) * â€–f' x (Pi.single i 1)â€– â‰¤ Îµ / 2 := by
      refine' .and _ (.and _ _)
      Â· exact Ioc_mem_nhdsWithin_Ioi âŸ¨le_rfl, one_half_posâŸ©
      Â· rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Îµ0) with âŸ¨Î´â‚, Î´â‚0, hÎ´â‚âŸ©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi âŸ¨le_rfl, Î´â‚0âŸ©] with Î´ hÎ´ yâ‚ hyâ‚ yâ‚‚ hyâ‚‚
        have : closedBall x Î´ âˆ© (Box.Icc I) âŠ† closedBall x Î´â‚ âˆ© (Box.Icc I) :=
          inter_subset_inter_left _ (closedBall_subset_closedBall hÎ´.2)
        rw [â† dist_eq_norm]
        calc
          dist (f yâ‚) (f yâ‚‚) â‰¤ dist (f yâ‚) (f x) + dist (f yâ‚‚) (f x) := dist_triangle_right _ _ _
          _ â‰¤ Îµ / 2 / 2 + Îµ / 2 / 2 := (add_le_add (hÎ´â‚ _ <| this hyâ‚) (hÎ´â‚ _ <| this hyâ‚‚))
          _ = Îµ / 2 := add_halves _
      Â· have : ContinuousWithinAt (fun Î´ : â„ => (2 * Î´) ^ (n + 1) * â€–f' x (Pi.single i 1)â€–)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine' this.eventually (ge_mem_nhds _)
        simpa using half_pos Îµ0
    rcases this.exists with âŸ¨Î´, âŸ¨hÎ´0, hÎ´12âŸ©, hdfÎ´, hÎ´âŸ©
    refine' âŸ¨Î´, hÎ´0, fun J hJI hJÎ´ _ _ => add_halves Îµ â–¸ _âŸ©
    have Hl : J.lower i âˆˆ Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i âˆˆ Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : âˆ€ x âˆˆ Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJÎ´' : Box.Icc J âŠ† closedBall x Î´ âˆ© (Box.Icc I) := subset_inter hJÎ´ (Box.le_iff_Icc.1 hJI)
    have Hmaps : âˆ€ z âˆˆ Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Î´ âˆ© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJÎ´'
    simp only [dist_eq_norm]; dsimp [F]
    rw [â† integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine' (norm_sub_le _ _).trans (add_le_add _ _)
    Â· simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine' (mul_le_mul_of_nonneg_right _ <| norm_nonneg _).trans hÎ´
      have : âˆ€ j, |J.upper j - J.lower j| â‰¤ 2 * Î´ := fun j â†¦
        calc
          dist (J.upper j) (J.lower j) â‰¤ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ â‰¤ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
          _ â‰¤ Î´ + Î´ := (add_le_add (hJÎ´ J.upper_mem_Icc) (hJÎ´ J.lower_mem_Icc))
          _ = 2 * Î´ := (two_mul Î´).symm
      calc
        âˆ j, |J.upper j - J.lower j| â‰¤ âˆ j : Fin (n + 1), 2 * Î´ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Î´) ^ (n + 1) := by simp
    Â· refine' (norm_integral_le_of_le_const (fun y hy => hdfÎ´ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans _
      refine' (mul_le_mul_of_nonneg_right _ (half_pos Îµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine' prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => _
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) â‰¤
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ â‰¤ dist J.upper J.lower := (dist_le_pi_dist J.upper J.lower (i.succAbove j))
        _ â‰¤ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
        _ â‰¤ Î´ + Î´ := (add_le_add (hJÎ´ J.upper_mem_Icc) (hJÎ´ J.lower_mem_Icc))
        _ â‰¤ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  Â· intro c x hx Îµ Îµ0
    rcases exists_pos_mul_lt Îµ0 (2 * c) with âŸ¨Îµ', Îµ'0, hltâŸ©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1
      ((Hd x hx).isLittleO.definition Îµ'0) with âŸ¨Î´, Î´0, HÎ´âŸ©
    refine' âŸ¨Î´, Î´0, fun J hle hJÎ´ hxJ hJc => _âŸ©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine' (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Îµ'0 (fun y hy => HÎ´ _) (hJc rfl)).trans _
    Â· exact âŸ¨hJÎ´ hy, Box.le_iff_Icc.1 hle hyâŸ©
    Â· rw [mul_right_comm (2 : â„), â† Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg","error:  invalid field 'definition', the environment does not contain 'Asymptotics.IsLittleO.definition'
  (Hd x hx).isLittleO
has type
  (fun x' â†¦ f x' - f x - (f' x) (x' - x)) =o[ğ“[Box.Icc I] x] fun x' â†¦ x' - x
error:  type mismatch
  HÎ´ ?m.101432
has type
  ?m.101431 âˆˆ ?m.99938 : Prop
but is expected to have type
  â€–f y - ?m.101421 - ?m.101184 (y - x)â€– â‰¤ Îµ' * â€–y - xâ€– : Prop
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  E","theorem hasIntegral_GP_pderiv (f : (Fin (n + 1) â†’ â„) â†’ E)
    (f' : (Fin (n + 1) â†’ â„) â†’ (Fin (n + 1) â†’ â„) â†’L[â„] E) (s : Set (Fin (n + 1) â†’ â„))
    (hs : s.Countable) (Hs : âˆ€ x âˆˆ s, ContinuousWithinAt f (Box.Icc I) x)
    (Hd : âˆ€ x âˆˆ (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :
    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume
      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))
          BoxAdditiveMap.volume -
        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))
          BoxAdditiveMap.volume) ",":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx â†¦ by
    by_cases hxs : x âˆˆ s
    exacts [Hs x hxs, (Hd x âŸ¨hx, hxsâŸ©).continuousWithinAt]
  set fI : â„ â†’ Box (Fin n) â†’ E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) â†’ Fin n â†’áµ‡áµƒ[â†‘(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) â†’áµ‡áµƒ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le ?_ ?_ _ s hs ?_ ?_
  Â·
    exact (volume : Measure (Fin (n + 1) â†’ â„)).toBoxAdditive.restrict _ le_top
  Â· exact fun J => ENNReal.toReal_nonneg
  Â· intro c x hx Îµ Îµ0
    have : âˆ€á¶  Î´ in ğ“[>] (0 : â„), Î´ âˆˆ Ioc (0 : â„) (1 / 2) âˆ§
        (âˆ€áµ‰ (yâ‚ âˆˆ closedBall x Î´ âˆ© (Box.Icc I)) (yâ‚‚ âˆˆ closedBall x Î´ âˆ© (Box.Icc I)),
              â€–f yâ‚ - f yâ‚‚â€– â‰¤ Îµ / 2) âˆ§ (2 * Î´) ^ (n + 1) * â€–f' x (Pi.single i 1)â€– â‰¤ Îµ / 2 := by
      refine .and ?_ (.and ?_ ?_)
      Â· exact Ioc_mem_nhdsWithin_Ioi âŸ¨le_rfl, one_half_posâŸ©
      Â· rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Îµ0) with âŸ¨Î´â‚, Î´â‚0, hÎ´â‚âŸ©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi âŸ¨le_rfl, Î´â‚0âŸ©] with Î´ hÎ´ yâ‚ hyâ‚ yâ‚‚ hyâ‚‚
        have : closedBall x Î´ âˆ© (Box.Icc I) âŠ† closedBall x Î´â‚ âˆ© (Box.Icc I) := by gcongr; exact hÎ´.2
        rw [â† dist_eq_norm]
        calc
          dist (f yâ‚) (f yâ‚‚) â‰¤ dist (f yâ‚) (f x) + dist (f yâ‚‚) (f x) := dist_triangle_right _ _ _
          _ â‰¤ Îµ / 2 / 2 + Îµ / 2 / 2 := add_le_add (hÎ´â‚ _ <| this hyâ‚) (hÎ´â‚ _ <| this hyâ‚‚)
          _ = Îµ / 2 := add_halves _
      Â· have : ContinuousWithinAt (fun Î´ : â„ => (2 * Î´) ^ (n + 1) * â€–f' x (Pi.single i 1)â€–)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine this.eventually (ge_mem_nhds ?_)
        simpa using half_pos Îµ0
    rcases this.exists with âŸ¨Î´, âŸ¨hÎ´0, hÎ´12âŸ©, hdfÎ´, hÎ´âŸ©
    refine âŸ¨Î´, hÎ´0, fun J hJI hJÎ´ _ _ => add_halves Îµ â–¸ ?_âŸ©
    have Hl : J.lower i âˆˆ Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i âˆˆ Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : âˆ€ x âˆˆ Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJÎ´' : Box.Icc J âŠ† closedBall x Î´ âˆ© (Box.Icc I) := subset_inter hJÎ´ (Box.le_iff_Icc.1 hJI)
    have Hmaps : âˆ€ z âˆˆ Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Î´ âˆ© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJÎ´'
    simp only [dist_eq_norm]; dsimp [F]
    rw [â† integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine (norm_sub_le _ _).trans (add_le_add ?_ ?_)
    Â· simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine (mul_le_mul_of_nonneg_right ?_ <| norm_nonneg _).trans hÎ´
      have : âˆ€ j, |J.upper j - J.lower j| â‰¤ 2 * Î´ := fun j â†¦
        calc
          dist (J.upper j) (J.lower j) â‰¤ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ â‰¤ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
          _ â‰¤ Î´ + Î´ := add_le_add (hJÎ´ J.upper_mem_Icc) (hJÎ´ J.lower_mem_Icc)
          _ = 2 * Î´ := (two_mul Î´).symm
      calc
        âˆ j, |J.upper j - J.lower j| â‰¤ âˆ j : Fin (n + 1), 2 * Î´ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Î´) ^ (n + 1) := by simp
    Â· refine (norm_integral_le_of_le_const (fun y hy => hdfÎ´ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans ?_
      refine (mul_le_mul_of_nonneg_right ?_ (half_pos Îµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => ?_
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) â‰¤
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ â‰¤ dist J.upper J.lower := dist_le_pi_dist J.upper J.lower (i.succAbove j)
        _ â‰¤ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
        _ â‰¤ Î´ + Î´ := add_le_add (hJÎ´ J.upper_mem_Icc) (hJÎ´ J.lower_mem_Icc)
        _ â‰¤ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  Â· intro c x hx Îµ Îµ0
    rcases exists_pos_mul_lt Îµ0 (2 * c) with âŸ¨Îµ', Îµ'0, hltâŸ©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1
      ((Hd x hx).isLittleO.def Îµ'0) with âŸ¨Î´, Î´0, HÎ´âŸ©
    refine âŸ¨Î´, Î´0, fun J hle hJÎ´ hxJ hJc => ?_âŸ©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Îµ'0 (fun y hy => HÎ´ ?_) (hJc rfl)).trans ?_
    Â· exact âŸ¨hJÎ´ hy, Box.le_iff_Icc.1 hle hyâŸ©
    Â· rw [mul_right_comm (2 : â„), â† Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg","refine theorem_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_countable_of_eventually_countable_of_eventually_countable
  hasIntegral_countable_of_eventually_c"
Mathlib/Algebra/Homology/QuasiIso.lean,quasiIsoAt_iff',quasiIsoAt_iff',4773ba7abb162ea632c1ff5810cd5f45a1289422,":= by
  rw [quasiIsoAt_iff]
  exact ShortComplex.quasiIso_iff_of_arrow_mk_iso _ _
    (Arrow.isoOfNatIso (HomologicalComplex.natIsoSc' V c i j k hi hk) (Arrow.mk f))",error:  unknown identifier 'V',"lemma quasiIsoAt_iff' (f : K âŸ¶ L) (i j k : Î¹) (hi : c.prev j = i) (hk : c.next j = k)
    [K.HasHomology j] [L.HasHomology j] [(K.sc' i j k).HasHomology] [(L.sc' i j k).HasHomology] :
    QuasiIsoAt f j â†”
      ShortComplex.QuasiIso ((shortComplexFunctor' C c i j k).map f) ",":= by
  rw [quasiIsoAt_iff]
  exact ShortComplex.quasiIso_iff_of_arrow_mk_iso _ _
    (Arrow.isoOfNatIso (natIsoSc' C c i j k hi hk) (Arrow.mk f))",dsimp [shortComplexFunctor']
Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean,dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt,dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt,88676a0fc6cc37bc23ba9735a55e5ec60dda3449,":= by
  letI := B.finiteDimensional
  let P := minpoly R B.gen
  obtain âŸ¨n, hnâŸ© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  have finrank_K_L : FiniteDimensional.finrank K L = B.dim := B.finrank
  have deg_K_P : (minpoly K B.gen).natDegree = B.dim := B.natDegree_minpoly
  have deg_R_P : P.natDegree = B.dim := by
    rw [â† deg_K_P, minpoly.isIntegrallyClosed_eq_field_fractions' K hBint,
      (minpoly.monic hBint).natDegree_map (algebraMap R K)]
  choose! f hf using
    hei.isWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
      (minpoly.monic hBint)
  simp only [(minpoly.monic hBint).natDegree_map, deg_R_P] at hf
  suffices
      p ^ n.succ âˆ£ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n) by
    have hndiv : Â¬p ^ 2 âˆ£ (minpoly R B.gen).coeff 0 := fun h =>
      hei.not_mem ((span_singleton_pow p 2).symm â–¸ Ideal.mem_span_singleton.2 h)
    refine @Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd R _ _ _ _ n hp (?_ : _ âˆ£ _)  hndiv
    convert (IsUnit.dvd_mul_right âŸ¨(-1) ^ (n.succ * n), rflâŸ©).mpr this using 1
    push_cast
    ring_nf
    rw [mul_comm _ 2, pow_mul, neg_one_sq, one_pow, mul_one]
  have aux : âˆ€ i âˆˆ (range (Q.natDegree + 1)).erase 0, B.dim â‰¤ i + n := by
    intro i hi
    simp only [mem_range, mem_erase] at hi
    rw [hn]
    exact le_add_pred_of_pos _ hi.1
  have hintsum :
    IsIntegral R
      (z * B.gen ^ n - âˆ‘ x : â„• in (range (Q.natDegree + 1)).erase 0, Q.coeff x â€¢ f (x + n)) := by
    refine
      isIntegral_sub (isIntegral_mul hzint (IsIntegral.pow hBint _))
        (IsIntegral.sum _ fun i hi => isIntegral_smul _ ?_)
    exact adjoin_le_integralClosure hBint (hf _ (aux i hi)).1
  obtain âŸ¨r, hrâŸ© := isIntegral_iff.1 (isIntegral_norm K hintsum)
  use r
  apply IsFractionRing.injective R K
  simp only [_root_.map_mul, _root_.map_pow, _root_.map_neg, _root_.map_one]
  calc
    _ = norm K (Q.coeff 0 â€¢ B.gen ^ n) := ?_
    _ = norm K (p â€¢ (z * B.gen ^ n) -
          âˆ‘ x : â„• in (range (Q.natDegree + 1)).erase 0, p â€¢ Q.coeff x â€¢ f (x + n)) :=
        (congr_arg (norm K) (eq_sub_of_add_eq ?_))
    _ = _ := ?_
  Â· simp only [Algebra.smul_def, algebraMap_apply R K L, Algebra.norm_algebraMap, _root_.map_mul,
      _root_.map_pow, finrank_K_L, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map, â† hn]
    ring
  swap
  Â· simp_rw [â† smul_sum, â† smul_sub, Algebra.smul_def p, algebraMap_apply R K L, _root_.map_mul,
      Algebra.norm_algebraMap, finrank_K_L, hr, â† hn]
  calc
    _ = (Q.coeff 0 â€¢ â†‘1 + âˆ‘ x : â„• in (range (Q.natDegree + 1)).erase 0, Q.coeff x â€¢ B.gen ^ x) *
          B.gen ^ n := ?_
    _ = (Q.coeff 0 â€¢ B.gen ^ 0 +
        âˆ‘ x : â„• in (range (Q.natDegree + 1)).erase 0, Q.coeff x â€¢ B.gen ^ x) * B.gen ^ n :=
      by rw [_root_.pow_zero]
    _ = aeval B.gen Q * B.gen ^ n := ?_
    _ = _ := by rw [hQ, Algebra.smul_mul_assoc]
  Â· have : âˆ€ i âˆˆ (range (Q.natDegree + 1)).erase 0,
        Q.coeff i â€¢ (B.gen ^ i * B.gen ^ n) = p â€¢ Q.coeff i â€¢ f (i + n) := by
      intro i hi
      rw [â† pow_add, â† (hf _ (aux i hi)).2, â† Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]
    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]
  Â· rw [aeval_eq_sum_range,
      Finset.add_sum_erase (range (Q.natDegree + 1)) fun i => Q.coeff i â€¢ B.gen ^ i]
    simp","warning:  `PowerBasis.finiteDimensional` has been deprecated, use `PowerBasis.finite` instead
error:  unknown identifier 'isIntegral_sub'
error:  no goals to be solved","theorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} {Q : R[X]} (hQ : aeval B.gen Q = p â€¢ z)
    (hzint : IsIntegral R z) (hei : (minpoly R B.gen).IsEisensteinAt ğ“Ÿ) : p âˆ£ Q.coeff 0 ",":= by
  letI := B.finite
  let P := minpoly R B.gen
  obtain âŸ¨n, hnâŸ© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  have finrank_K_L : FiniteDimensional.finrank K L = B.dim := B.finrank
  have deg_K_P : (minpoly K B.gen).natDegree = B.dim := B.natDegree_minpoly
  have deg_R_P : P.natDegree = B.dim := by
    rw [â† deg_K_P, minpoly.isIntegrallyClosed_eq_field_fractions' K hBint,
      (minpoly.monic hBint).natDegree_map (algebraMap R K)]
  choose! f hf using
    hei.isWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
      (minpoly.monic hBint)
  simp only [(minpoly.monic hBint).natDegree_map, deg_R_P] at hf
  suffices
      p ^ n.succ âˆ£ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n) by
    have hndiv : Â¬p ^ 2 âˆ£ (minpoly R B.gen).coeff 0 := fun h =>
      hei.not_mem ((span_singleton_pow p 2).symm â–¸ Ideal.mem_span_singleton.2 h)
    refine @Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd R _ _ _ _ n hp (?_ : _ âˆ£ _) hndiv
    convert (IsUnit.dvd_mul_right âŸ¨(-1) ^ (n.succ * n), rflâŸ©).mpr this using 1
    push_cast
    ring_nf
    rw [mul_comm _ 2, pow_mul, neg_one_sq, one_pow, mul_one]
  have aux : âˆ€ i âˆˆ (range (Q.natDegree + 1)).erase 0, B.dim â‰¤ i + n := by
    intro i hi
    simp only [mem_range, mem_erase] at hi
    rw [hn]
    exact le_add_pred_of_pos _ hi.1
  have hintsum :
    IsIntegral R
      (z * B.gen ^ n - âˆ‘ x âˆˆ (range (Q.natDegree + 1)).erase 0, Q.coeff x â€¢ f (x + n)) := by
    refine (hzint.mul (hBint.pow _)).sub (.sum _ fun i hi => .smul _ ?_)
    exact adjoin_le_integralClosure hBint (hf _ (aux i hi)).1
  obtain âŸ¨r, hrâŸ© := isIntegral_iff.1 (isIntegral_norm K hintsum)
  use r
  apply IsFractionRing.injective R K
  simp only [_root_.map_mul, _root_.map_pow, _root_.map_neg, _root_.map_one]
  calc
    _ = norm K (Q.coeff 0 â€¢ B.gen ^ n) := ?_
    _ = norm K (p â€¢ (z * B.gen ^ n) -
          âˆ‘ x âˆˆ (range (Q.natDegree + 1)).erase 0, p â€¢ Q.coeff x â€¢ f (x + n)) :=
        (congr_arg (norm K) (eq_sub_of_add_eq ?_))
    _ = _ := ?_
  Â· simp only [Algebra.smul_def, algebraMap_apply R K L, Algebra.norm_algebraMap, _root_.map_mul,
      _root_.map_pow, finrank_K_L, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map, â† hn]
    ring
  swap
  Â· simp_rw [â† smul_sum, â† smul_sub, Algebra.smul_def p, algebraMap_apply R K L, _root_.map_mul,
      Algebra.norm_algebraMap, finrank_K_L, hr, â† hn]
  calc
    _ = (Q.coeff 0 â€¢ â†‘1 + âˆ‘ x âˆˆ (range (Q.natDegree + 1)).erase 0, Q.coeff x â€¢ B.gen ^ x) *
          B.gen ^ n := ?_
    _ = (Q.coeff 0 â€¢ B.gen ^ 0 +
        âˆ‘ x âˆˆ (range (Q.natDegree + 1)).erase 0, Q.coeff x â€¢ B.gen ^ x) * B.gen ^ n := by
      rw [_root_.pow_zero]
    _ = aeval B.gen Q * B.gen ^ n := ?_
    _ = _ := by rw [hQ, Algebra.smul_mul_assoc]
  Â· have : âˆ€ i âˆˆ (range (Q.natDegree + 1)).erase 0,
        Q.coeff i â€¢ (B.gen ^ i * B.gen ^ n) = p â€¢ Q.coeff i â€¢ f (i + n) := by
      intro i hi
      rw [â† pow_add, â† (hf _ (aux i hi)).2, â† Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]
    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]
  Â· rw [aeval_eq_sum_range,
      Finset.add_sum_erase (range (Q.natDegree + 1)) fun i => Q.coeff i â€¢ B.gen ^ i]
    simp","simp only [coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt,
  coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt]"
Mathlib/Probability/Kernel/WithDensity.lean,ProbabilityTheory.kernel.isSFiniteKernel_withDensity_of_isFiniteKernel,isSFiniteKernel_withDensity_of_isFiniteKernel,d609021a5f5b695133788ad1ee60c2185e028d87,":= by
  by_cases hf : Measurable (Function.uncurry f)
  swap; Â· rw [withDensity_of_not_measurable _ hf]; infer_instance
  let fs : â„• â†’ Î± â†’ Î² â†’ â„â‰¥0âˆ := fun n a b => min (f a b) (n + 1) - min (f a b) n
  have h_le : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ f a b â‰¤ n := by
    intro a b n hn
    have : (f a b).toReal â‰¤ n := Nat.le_of_ceil_le hn
    rw [â† ENNReal.le_ofReal_iff_toReal_le (hf_ne_top a b) _] at this
    Â· refine' this.trans (le_of_eq _)
      rw [ENNReal.ofReal_coe_nat]
    Â· norm_cast
      exact zero_le _
  have h_zero : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ fs n a b = 0 := by
    intro a b n hn
    suffices min (f a b) (n + 1) = f a b âˆ§ min (f a b) n = f a b by
      simp_rw [this.1, this.2, tsub_self (f a b)]
    exact âŸ¨min_eq_left ((h_le a b n hn).trans (le_add_of_nonneg_right zero_le_one)),
      min_eq_left (h_le a b n hn)âŸ©
  have hf_eq_tsum : f = âˆ‘' n, fs n := by
    have h_sum_a : âˆ€ a, Summable fun n => fs n a := by
      refine' fun a => Pi.summable.mpr fun b => _
      suffices âˆ€ n, n âˆ‰ Finset.range âŒˆ(f a b).toRealâŒ‰â‚Š â†’ fs n a b = 0 from
        summable_of_ne_finset_zero this
      intro n hn_not_mem
      rw [Finset.mem_range, not_lt] at hn_not_mem
      exact h_zero a b n hn_not_mem
    ext a b : 2
    rw [tsum_apply (Pi.summable.mpr h_sum_a), tsum_apply (h_sum_a a),
      ENNReal.tsum_eq_liminf_sum_nat]
    have h_finset_sum : âˆ€ n, âˆ‘ i in Finset.range n, fs i a b = min (f a b) n := by
      intro n
      induction' n with n hn
      Â· simp
      rw [Finset.sum_range_succ, hn]
      simp
    simp_rw [h_finset_sum]
    refine' (Filter.Tendsto.liminf_eq _).symm
    refine' Filter.Tendsto.congr' _ tendsto_const_nhds
    rw [Filter.EventuallyEq, Filter.eventually_atTop]
    exact âŸ¨âŒˆ(f a b).toRealâŒ‰â‚Š, fun n hn => (min_eq_left (h_le a b n hn)).symmâŸ©
  rw [hf_eq_tsum, withDensity_tsum _ fun n : â„• => _]
  swap; Â· exact fun _ => (hf.min measurable_const).sub (hf.min measurable_const)
  refine' isSFiniteKernel_sum fun n => _
  suffices IsFiniteKernel (withDensity Îº (fs n)) by haveI := this; infer_instance
  refine' isFiniteKernel_withDensity_of_bounded _ (ENNReal.coe_ne_top : â†‘n + 1 â‰  âˆ) fun a b => _
  beta_reduce
  norm_cast
  calc
    fs n a b â‰¤ min (f a b) (n + 1) := tsub_le_self
    _ â‰¤ n + 1 := (min_le_right _ _)
    _ = â†‘(n + 1) := by norm_cast","warning:  `ENNReal.ofReal_coe_nat` has been deprecated, use `ENNReal.ofReal_natCast` instead
error:  simp made no progress
error:  unsolved goals
case succ
Î± : Type u_1
Î² : Type u_2
Î¹ : Type u_3
mÎ± : MeasurableSpace Î±
mÎ² : MeasurableSpace Î²
Îºâœ : â†¥(kernel Î± Î²)
f : Î± â†’ Î² â†’ â„â‰¥0âˆ
Îº : â†¥(kernel Î± Î²)
instâœ : IsFiniteKernel Îº
hf_ne_top : âˆ€ (a : Î±) (b : Î²), f a b â‰  âŠ¤
hf : Measurable (Function.uncurry f)
fs : â„• â†’ Î± â†’ Î² â†’ â„â‰¥0âˆ := fun n a b â†¦ min (f a b) (â†‘n + 1) - min (f a b) â†‘n
h_le : âˆ€ (a : Î±) (b : Î²) (n : â„•), âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ f a b â‰¤ â†‘n
h_zero : âˆ€ (a : Î±) (b : Î²) (n : â„•), âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ fs n a b = 0
h_sum_a : âˆ€ (a : Î±), Summable fun n â†¦ fs n a
a : Î±
b : Î²
n : â„•
hn : âˆ‘ i âˆˆ Finset.range n, fs i a b = min (f a b) â†‘n
âŠ¢ min (f a b) â†‘n + fs n a b = min (f a b) (â†‘n + 1)","theorem isSFiniteKernel_withDensity_of_isFiniteKernel (Îº : kernel Î± Î²) [IsFiniteKernel Îº]
    (hf_ne_top : âˆ€ a b, f a b â‰  âˆ) : IsSFiniteKernel (withDensity Îº f) ",":= by
  by_cases hf : Measurable (Function.uncurry f)
  swap; Â· rw [withDensity_of_not_measurable _ hf]; infer_instance
  let fs : â„• â†’ Î± â†’ Î² â†’ â„â‰¥0âˆ := fun n a b => min (f a b) (n + 1) - min (f a b) n
  have h_le : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ f a b â‰¤ n := by
    intro a b n hn
    have : (f a b).toReal â‰¤ n := Nat.le_of_ceil_le hn
    rw [â† ENNReal.le_ofReal_iff_toReal_le (hf_ne_top a b) _] at this
    Â· refine this.trans (le_of_eq ?_)
      rw [ENNReal.ofReal_natCast]
    Â· norm_cast
      exact zero_le _
  have h_zero : âˆ€ a b n, âŒˆ(f a b).toRealâŒ‰â‚Š â‰¤ n â†’ fs n a b = 0 := by
    intro a b n hn
    suffices min (f a b) (n + 1) = f a b âˆ§ min (f a b) n = f a b by
      simp_rw [fs, this.1, this.2, tsub_self (f a b)]
    exact âŸ¨min_eq_left ((h_le a b n hn).trans (le_add_of_nonneg_right zero_le_one)),
      min_eq_left (h_le a b n hn)âŸ©
  have hf_eq_tsum : f = âˆ‘' n, fs n := by
    have h_sum_a : âˆ€ a, Summable fun n => fs n a := by
      refine fun a => Pi.summable.mpr fun b => ?_
      suffices âˆ€ n, n âˆ‰ Finset.range âŒˆ(f a b).toRealâŒ‰â‚Š â†’ fs n a b = 0 from
        summable_of_ne_finset_zero this
      intro n hn_not_mem
      rw [Finset.mem_range, not_lt] at hn_not_mem
      exact h_zero a b n hn_not_mem
    ext a b : 2
    rw [tsum_apply (Pi.summable.mpr h_sum_a), tsum_apply (h_sum_a a),
      ENNReal.tsum_eq_liminf_sum_nat]
    have h_finset_sum : âˆ€ n, âˆ‘ i âˆˆ Finset.range n, fs i a b = min (f a b) n := by
      intro n
      induction' n with n hn
      Â· simp
      rw [Finset.sum_range_succ, hn]
      simp [fs]
    simp_rw [h_finset_sum]
    refine (Filter.Tendsto.liminf_eq ?_).symm
    refine Filter.Tendsto.congr' ?_ tendsto_const_nhds
    rw [Filter.EventuallyEq, Filter.eventually_atTop]
    exact âŸ¨âŒˆ(f a b).toRealâŒ‰â‚Š, fun n hn => (min_eq_left (h_le a b n hn)).symmâŸ©
  rw [hf_eq_tsum, withDensity_tsum _ fun n : â„• => _]
  swap; Â· exact fun _ => (hf.min measurable_const).sub (hf.min measurable_const)
  refine isSFiniteKernel_sum fun n => ?_
  suffices IsFiniteKernel (withDensity Îº (fs n)) by haveI := this; infer_instance
  refine isFiniteKernel_withDensity_of_bounded _ (ENNReal.coe_ne_top : â†‘n + 1 â‰  âˆ) fun a b => ?_
  beta_reduce
  norm_cast
  calc
    fs n a b â‰¤ min (f a b) (n + 1) := tsub_le_self
    _ â‰¤ n + 1 := min_le_right _ _
    _ = â†‘(n + 1) := by norm_cast",refine isSFiniteKernel_withDensity_of_isFiniteKernel_withDensity_of_isFiniteKernel_withDensity_of_isFiniteKernel f
Mathlib/Topology/UniformSpace/UniformConvergence.lean,UniformCauchySeqOn.prod,UniformCauchySeqOn.prod,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  intro u hu
  rw [uniformity_prod_eq_prod, mem_map, mem_prod_iff] at hu
  obtain âŸ¨v, hv, w, hw, hvwâŸ© := hu
  simp_rw [mem_prod, Prod_map, and_imp, Prod.forall]
  rw [â† Set.image_subset_iff] at hvw
  apply (tendsto_swap4_prod.eventually ((h v hv).prod_mk (h' w hw))).mono
  intro x hx a b ha hb
  exact hvw âŸ¨_, mk_mem_prod (hx.1 a ha) (hx.2 b hb), rflâŸ©","warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  simp made no progress","theorem UniformCauchySeqOn.prod_map {Î¹' Î±' Î²' : Type*} [UniformSpace Î²'] {F' : Î¹' â†’ Î±' â†’ Î²'}
    {p' : Filter Î¹'} {s' : Set Î±'} (h : UniformCauchySeqOn F p s)
    (h' : UniformCauchySeqOn F' p' s') :
    UniformCauchySeqOn (fun i : Î¹ Ã— Î¹' => Prod.map (F i.1) (F' i.2)) (p Ã—Ë¢ p') (s Ã—Ë¢ s') ",":= by
  intro u hu
  rw [uniformity_prod_eq_prod, mem_map, mem_prod_iff] at hu
  obtain âŸ¨v, hv, w, hw, hvwâŸ© := hu
  simp_rw [mem_prod, and_imp, Prod.forall, Prod.map_apply]
  rw [â† Set.image_subset_iff] at hvw
  apply (tendsto_swap4_prod.eventually ((h v hv).prod_mk (h' w hw))).mono
  intro x hx a b ha hb
  exact hvw âŸ¨_, mk_mem_prod (hx.1 a ha) (hx.2 b hb), rflâŸ©",rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter] at h'
Mathlib/Logic/Godel/GodelBetaFunction.lean,Nat.coprimes_lt,coprimes_lt,a0aaee1988aacd949eed3bdab815151af4ba6098,":= by
  have hâ‚ : a i < supOfSeq a :=
    Nat.lt_add_one_iff.mpr (le_max_of_le_right $ Finset.le_sup (by simp))
  have hâ‚‚ : supOfSeq a â‰¤ (i + 1) * (supOfSeq a)! + 1 :=
    le_trans (self_le_factorial _) (le_trans (Nat.le_mul_of_pos_left (succ_pos _))
      (le_add_right _ _))
  simpa only [coprimes, List.get_ofFn] using lt_of_lt_of_le hâ‚ hâ‚‚","error:  application type mismatch
  Nat.le_mul_of_pos_left (succ_pos ?m.22129)
argument
  succ_pos ?m.22129
has type
  0 < ?m.22129.succ : Prop
but is expected to have type
  â„• : Type",lemma coprimes_lt (a : Fin m â†’ â„•) (i) : a i < coprimes a i ,":= by
  have hâ‚ : a i < supOfSeq a :=
    Nat.lt_add_one_iff.mpr (le_max_of_le_right $ Finset.le_sup (by simp))
  have hâ‚‚ : supOfSeq a â‰¤ (i + 1) * (supOfSeq a)! + 1 :=
    le_trans (self_le_factorial _) (le_trans (Nat.le_mul_of_pos_left (supOfSeq a)! (succ_pos i))
      (le_add_right _ _))
  simpa only [coprimes] using lt_of_lt_of_le hâ‚ hâ‚‚",rw [coprimes_lt_coprimes]
Mathlib/Data/Set/MemPartition.lean,memPartitionSet_succ,memPartitionSet_succ,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp [memPartitionSet]","error:  unsolved goals
Î± : Type u_1
f : â„• â†’ Set Î±
n : â„•
a : Î±
instâœ : Decidable (a âˆˆ f n)
âŠ¢ (if a âˆˆ f n then memPartitionSet f n a âˆ© f n else memPartitionSet f n a \ f n) =
    if a âˆˆ f n then memPartitionSet f n a âˆ© f n else memPartitionSet f n a \ f n","lemma memPartitionSet_succ (f : â„• â†’ Set Î±) (n : â„•) (a : Î±) [Decidable (a âˆˆ f n)] :
    memPartitionSet f (n + 1) a
      = if a âˆˆ f n then memPartitionSet f n a âˆ© f n else memPartitionSet f n a \ f n ",":= by
  simp [memPartitionSet]
  congr",split_ifs with h
Mathlib/Analysis/Normed/Group/Quotient.lean,quotient_norm_nonneg,quotient_norm_nonneg,2c51ddac66e30dac33162736742396566e191ff8,":=
  Real.infâ‚›_nonneg _ <| ball_image_iff.2 fun _ _ â†¦ norm_nonneg _",error:  unknown constant 'Real.infâ‚›_nonneg',theorem quotient_norm_nonneg (S : AddSubgroup M) (x : M â§¸ S) : 0 â‰¤ â€–xâ€– ,":=
  Real.sInf_nonneg _ <| forall_mem_image.2 fun _ _ â†¦ norm_nonneg _","simp only [quotient_norm_nonneg, quotient_norm_nonneg]"
Mathlib/Order/UpperLower/Basic.lean,LowerSet.sdiff_sup_lowerClosure,sdiff_sup_lowerClosure,049f6f9c146026f6debfbf18ad947c4aa57150cb,":= by
  refine' le_antisymm (sup_le sdiff_le_left $ lowerClosure_le.2 hts) fun a ha â†¦ _
  obtain hat | hat := em (a âˆˆ t)
  Â· exact subset_union_right _ _ (subset_lowerClosure hat)
  Â· refine subset_union_left _ _ âŸ¨ha, ?_âŸ©
    rintro âŸ¨b, hb, hbaâŸ©
    exact hat $ hst _ ha _ hb hba","error:  function expected at
  subset_union_right ?m.704076
term has type
  ?m.704075 âˆˆ ?m.704073 âˆª ?m.704074
error:  function expected at
  subset_union_left ?m.704118
term has type
  ?m.704117 âˆˆ ?m.704115 âˆª ?m.704116
error:  no goals to be solved","lemma sdiff_sup_lowerClosure (hts : t âŠ† s) (hst : âˆ€ b âˆˆ s, âˆ€ c âˆˆ t, c â‰¤ b â†’ b âˆˆ t) :
    s.sdiff t âŠ” lowerClosure t = s ",":= by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha â†¦ ?_
  obtain hat | hat := em (a âˆˆ t)
  Â· exact subset_union_right (subset_lowerClosure hat)
  Â· refine subset_union_left âŸ¨ha, ?_âŸ©
    rintro âŸ¨b, hb, hbaâŸ©
    exact hat <| hst _ ha _ hb hba",rw [sdiff_sup_lowerClosure]
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,direction_affineSpan,direction_affineSpan,f27ef6dc0fb66aa1c033b41bb16e840c0a1527a5,":= by
  apply le_antisymm
  Â· refine' Submodule.span_le.2 _
    rintro v âŸ¨p1, p3, âŸ¨p2, hp2, v1, hv1, hp1âŸ©, âŸ¨p4, hp4, v2, hv2, hp3âŸ©, rflâŸ©
    simp only [SetLike.mem_coe]
    set_like
  Â· exact vectorSpan_mono k (subset_spanPoints k s)","error:  unknown tactic
error:  unsolved goals
case a
k : Type u_1
V : Type u_2
P : Type u_3
instâœÂ³ : Ring k
instâœÂ² : AddCommGroup V
instâœÂ¹ : Module k V
instâœ : AffineSpace V P
s : Set P
âŠ¢ vectorSpan k s â‰¤ (affineSpan k s).direction
warning:  @AffineSubspace.Parallel does not have a doc string",theorem direction_affineSpan (s : Set P) : (affineSpan k s).direction = vectorSpan k s ,":= by
  apply le_antisymm
  Â· refine Submodule.span_le.2 ?_
    rintro v âŸ¨p1, âŸ¨p2, hp2, v1, hv1, hp1âŸ©, p3, âŸ¨p4, hp4, v2, hv2, hp3âŸ©, rflâŸ©
    simp only [SetLike.mem_coe]
    rw [hp1, hp3, vsub_vadd_eq_vsub_sub, vadd_vsub_assoc]
    exact
      (vectorSpan k s).sub_mem ((vectorSpan k s).add_mem hv1 (vsub_mem_vectorSpan k hp2 hp4)) hv2
  Â· exact vectorSpan_mono k (subset_spanPoints k s)","rw [vectorSpan_direction_eq_direction_vectorSpan k s, vectorSpan_direction_eq_vectorSpan k s]"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine Or.inl âŸ¨hs, ?_âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, ?_âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine
        mem_shadow_iff.2
          âŸ¨(t âŠ” u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine âŸ¨hus, hsv.symm, âŸ¨x, ?_, ?_âŸ©, ?_âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right _ _, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) ?_
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  function expected at
  subset_union_right ?m.92173
term has type
  ?m.92172 âˆˆ ?m.92170 âˆª ?m.92171
error:  function expected at
  subset_union_left ?m.92639
term has type
  ?m.92638 âˆˆ ?m.92636 âˆª ?m.92637
error:  function expected at
  subset_union_right ?m.94506
term has type
  ?m.94505 âˆˆ ?m.94503 âˆª ?m.94504
error:  function expected at
  subset_union_left ?m.97300
term has type
  ?m.97299 âˆˆ ?m.97297 âˆª ?m.97298
error:  function expected at
  subset_union_left ?m.98875
term has type
  ?m.98874 âˆˆ ?m.98872 âˆª ?m.98873","theorem shadow_compression_subset_compression_shadow (u v : Finset Î±)
    (huv : âˆ€ x âˆˆ u, âˆƒ y âˆˆ v, IsCompressed (u.erase x) (v.erase y) ğ’œ) :
    âˆ‚ (ğ“’ u v ğ’œ) âŠ† ğ“’ u v (âˆ‚ ğ’œ) ",":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine Or.inl âŸ¨hs, ?_âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, ?_âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine mem_shadow_iff.2
        âŸ¨(t âŠ” u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine âŸ¨hus, hsv.symm, âŸ¨x, ?_, ?_âŸ©, ?_âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) ?_
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]",refine theorem_shadow_compression_subset_compression_subset_compression_subset_compression_subset_compression_shadow huv
Mathlib/MeasureTheory/Constructions/Pi.lean,generateFrom_pi_eq,generateFrom_pi_eq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  cases nonempty_encodable Î¹
  apply le_antisymm
  Â· refine' iSup_le _; intro i; rw [comap_generateFrom]
    apply generateFrom_le; rintro _ âŸ¨s, hs, rflâŸ©; dsimp
    choose t h1t h2t using hC
    simp_rw [eval_preimage, â† h2t]
    rw [â† @iUnion_const _ â„• _ s]
    have : Set.pi univ (update (fun i' : Î¹ => iUnion (t i')) i (â‹ƒ _ : â„•, s)) =
        Set.pi univ fun k => â‹ƒ j : â„•,
        @update Î¹ (fun i' => Set (Î± i')) _ (fun i' => t i' j) i s k := by
      ext; simp_rw [mem_univ_pi]; apply forall_congr'; intro i'
      by_cases h : i' = i
      Â· subst h; simp
      Â· rw [â† Ne] at h; simp [h]
    rw [this, â† iUnion_univ_pi]
    apply MeasurableSet.iUnion
    intro n; apply measurableSet_generateFrom
    apply mem_image_of_mem; intro j _; dsimp only
    by_cases h : j = i; subst h; rwa [update_same]; rw [update_noteq h]; apply h1t
  Â· apply generateFrom_le; rintro _ âŸ¨s, hs, rflâŸ©
    rw [univ_pi_eq_iInter]; apply MeasurableSet.iInter; intro i
    apply @measurable_pi_apply _ _ (fun i => generateFrom (C i))
    exact measurableSet_generateFrom (hs i (mem_univ i))",error:  dsimp made no progress,"theorem generateFrom_pi_eq {C : âˆ€ i, Set (Set (Î± i))} (hC : âˆ€ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) ",":= by
  cases nonempty_encodable Î¹
  apply le_antisymm
  Â· refine iSup_le ?_; intro i; rw [comap_generateFrom]
    apply generateFrom_le; rintro _ âŸ¨s, hs, rflâŸ©
    choose t h1t h2t using hC
    simp_rw [eval_preimage, â† h2t]
    rw [â† @iUnion_const _ â„• _ s]
    have : Set.pi univ (update (fun i' : Î¹ => iUnion (t i')) i (â‹ƒ _ : â„•, s)) =
        Set.pi univ fun k => â‹ƒ j : â„•,
        @update Î¹ (fun i' => Set (Î± i')) _ (fun i' => t i' j) i s k := by
      ext; simp_rw [mem_univ_pi]; apply forall_congr'; intro i'
      by_cases h : i' = i
      Â· subst h; simp
      Â· rw [â† Ne] at h; simp [h]
    rw [this, â† iUnion_univ_pi]
    apply MeasurableSet.iUnion
    intro n; apply measurableSet_generateFrom
    apply mem_image_of_mem; intro j _; dsimp only
    by_cases h : j = i
    Â· subst h; rwa [update_same]
    Â· rw [update_noteq h]; apply h1t
  Â· apply generateFrom_le; rintro _ âŸ¨s, hs, rflâŸ©
    rw [univ_pi_eq_iInter]; apply MeasurableSet.iInter; intro i
    apply @measurable_pi_apply _ _ (fun i => generateFrom (C i))
    exact measurableSet_generateFrom (hs i (mem_univ i))",apply generateFrom_eq_generateFrom_image generateFrom_pi_eq
Mathlib/MeasureTheory/PiSystem.lean,isPiSystem_piiUnionInter,isPiSystem_piiUnionInter,c47ebbbece0d449dca95c589513159cdc2bab40d,":= by
  rintro t1 âŸ¨p1, hp1S, f1, hf1m, ht1_eqâŸ© t2 âŸ¨p2, hp2S, f2, hf2m, ht2_eqâŸ© h_nonempty
  simp_rw [piiUnionInter, Set.mem_setOf_eq]
  let g n := ite (n âˆˆ p1) (f1 n) Set.univ âˆ© ite (n âˆˆ p2) (f2 n) Set.univ
  have hp_union_ss : â†‘(p1 âˆª p2) âŠ† S := by
    simp only [hp1S, hp2S, Finset.coe_union, union_subset_iff, and_self_iff]
  use p1 âˆª p2, hp_union_ss, g
  have h_inter_eq : t1 âˆ© t2 = â‹‚ i âˆˆ p1 âˆª p2, g i := by
    rw [ht1_eq, ht2_eq]
    simp_rw [â† Set.inf_eq_inter]
    ext1 x
    simp only [inf_eq_inter, mem_inter_iff, mem_iInter, Finset.mem_union]
    refine' âŸ¨fun h i _ => _, fun h => âŸ¨fun i hi1 => _, fun i hi2 => _âŸ©âŸ©
    Â· split_ifs with h_1 h_2 h_2
      exacts [âŸ¨h.1 i h_1, h.2 i h_2âŸ©, âŸ¨h.1 i h_1, Set.mem_univ _âŸ©, âŸ¨Set.mem_univ _, h.2 i h_2âŸ©,
        âŸ¨Set.mem_univ _, Set.mem_univ _âŸ©]
    Â· specialize h i (Or.inl hi1)
      rw [if_pos hi1] at h
      exact h.1
    Â· specialize h i (Or.inr hi2)
      rw [if_pos hi2] at h
      exact h.2
  refine' âŸ¨fun n hn => _, h_inter_eqâŸ©
  simp only []
  split_ifs with hn1 hn2 h
  Â· refine' hpi n (f1 n) (hf1m n hn1) (f2 n) (hf2m n hn2) (Set.nonempty_iff_ne_empty.2 fun h => _)
    rw [h_inter_eq] at h_nonempty
    suffices h_empty : â‹‚ i âˆˆ p1 âˆª p2, g i = âˆ…
    exact (Set.not_nonempty_iff_eq_empty.mpr h_empty) h_nonempty
    refine' le_antisymm (Set.iInter_subset_of_subset n _) (Set.empty_subset _)
    refine' Set.iInter_subset_of_subset hn _
    simp_rw [if_pos hn1, if_pos hn2]
    exact h.subset
  Â· simp [hf1m n hn1]
  Â· simp [hf2m n h]
  Â· exact absurd hn (by simp [hn1, h])",error:  unexpected identifier; expected 'by' or 'from',"theorem isPiSystem_piiUnionInter (Ï€ : Î¹ â†’ Set (Set Î±)) (hpi : âˆ€ x, IsPiSystem (Ï€ x)) (S : Set Î¹) :
    IsPiSystem (piiUnionInter Ï€ S) ",":= by
  rintro t1 âŸ¨p1, hp1S, f1, hf1m, ht1_eqâŸ© t2 âŸ¨p2, hp2S, f2, hf2m, ht2_eqâŸ© h_nonempty
  simp_rw [piiUnionInter, Set.mem_setOf_eq]
  let g n := ite (n âˆˆ p1) (f1 n) Set.univ âˆ© ite (n âˆˆ p2) (f2 n) Set.univ
  have hp_union_ss : â†‘(p1 âˆª p2) âŠ† S := by
    simp only [hp1S, hp2S, Finset.coe_union, union_subset_iff, and_self_iff]
  use p1 âˆª p2, hp_union_ss, g
  have h_inter_eq : t1 âˆ© t2 = â‹‚ i âˆˆ p1 âˆª p2, g i := by
    rw [ht1_eq, ht2_eq]
    simp_rw [â† Set.inf_eq_inter]
    ext1 x
    simp only [g, inf_eq_inter, mem_inter_iff, mem_iInter, Finset.mem_union]
    refine âŸ¨fun h i _ => ?_, fun h => âŸ¨fun i hi1 => ?_, fun i hi2 => ?_âŸ©âŸ©
    Â· split_ifs with h_1 h_2 h_2
      exacts [âŸ¨h.1 i h_1, h.2 i h_2âŸ©, âŸ¨h.1 i h_1, Set.mem_univ _âŸ©, âŸ¨Set.mem_univ _, h.2 i h_2âŸ©,
        âŸ¨Set.mem_univ _, Set.mem_univ _âŸ©]
    Â· specialize h i (Or.inl hi1)
      rw [if_pos hi1] at h
      exact h.1
    Â· specialize h i (Or.inr hi2)
      rw [if_pos hi2] at h
      exact h.2
  refine âŸ¨fun n hn => ?_, h_inter_eqâŸ©
  simp only [g]
  split_ifs with hn1 hn2 h
  Â· refine hpi n (f1 n) (hf1m n hn1) (f2 n) (hf2m n hn2) (Set.nonempty_iff_ne_empty.2 fun h => ?_)
    rw [h_inter_eq] at h_nonempty
    suffices h_empty : â‹‚ i âˆˆ p1 âˆª p2, g i = âˆ… from
      (Set.not_nonempty_iff_eq_empty.mpr h_empty) h_nonempty
    refine le_antisymm (Set.iInter_subset_of_subset n ?_) (Set.empty_subset _)
    refine Set.iInter_subset_of_subset hn ?_
    simp_rw [g, if_pos hn1, if_pos hn2]
    exact h.subset
  Â· simp [hf1m n hn1]
  Â· simp [hf2m n h]
  Â· exact absurd hn (by simp [hn1, h])",rw [isPiSystem_piiUnionInter_piiUnionInter]
Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean,Matrix.isNilpotent_charpoly_sub_pow_of_isNilpotent,isNilpotent_charpoly_sub_pow_of_isNilpotent,bf6e4bb13f659a85fd8161ecb4867b3785573600,":= by
  nontriviality R
  let p : R[X] := M.charpolyRev
  have hp : p - 1 = X * (p /â‚˜ X) := by
    conv_lhs => rw [â† modByMonic_add_div p monic_X]
    simp [modByMonic_X]
  have : IsNilpotent (p /â‚˜ X) :=
    (Polynomial.isUnit_iff'.mp (isUnit_charpolyRev_of_IsNilpotent hM)).2
  have aux : (M.charpoly - X ^ (Fintype.card n)).natDegree â‰¤ M.charpoly.natDegree :=
    le_trans (natDegree_sub_le _ _) (by simp)
  rw [â† isNilpotent_reflect_iff aux, reflect_sub, â† reverse, M.reverse_charpoly]
  simpa [hp]","error:  unsolved goals
R : Type u
instâœâ´ : CommRing R
n G : Type v
instâœÂ³ : DecidableEq n
instâœÂ² : Fintype n
Î± Î² : Type v
instâœÂ¹ : DecidableEq Î±
M : Matrix n n R
pâœ : â„•
instâœ : Fact (Nat.Prime pâœ)
hM : IsNilpotent M
aâœ : Nontrivial R
p : R[X] := M.charpolyRev
âŠ¢ C (eval 0 p) + X * (p /â‚˜ X) - 1 = X * (p /â‚˜ X)
error:  unknown identifier 'isUnit_charpolyRev_of_IsNilpotent'","lemma isNilpotent_charpoly_sub_pow_of_isNilpotent (hM : IsNilpotent M) :
    IsNilpotent (M.charpoly - X ^ (Fintype.card n)) ",":= by
  nontriviality R
  let p : R[X] := M.charpolyRev
  have hp : p - 1 = X * (p /â‚˜ X) := by
    conv_lhs => rw [â† modByMonic_add_div p monic_X]
    simp [p, modByMonic_X]
  have : IsNilpotent (p /â‚˜ X) :=
    (Polynomial.isUnit_iff'.mp (isUnit_charpolyRev_of_isNilpotent hM)).2
  have aux : (M.charpoly - X ^ (Fintype.card n)).natDegree â‰¤ M.charpoly.natDegree :=
    le_trans (natDegree_sub_le _ _) (by simp)
  rw [â† isNilpotent_reflect_iff aux, reflect_sub, â† reverse, M.reverse_charpoly]
  simpa [hp]",have : IsNilpotent M.charpoly - X ^ (Fintype.card n) := isNilpotent_charpoly_sub_pow_of_isNilpotent
Mathlib/Data/Seq/Computation.lean,Computation.of_thinkN_terminates,of_thinkN_terminates,3c930599229893e1b6a931304cf4efff4a01b172,"  | âŸ¨âŸ¨a, hâŸ©âŸ© => âŸ¨âŸ¨a, (mem_thinkN _).1 hâŸ©âŸ©",error:  unknown identifier 'mem_thinkN',"theorem of_thinkN_terminates (s : Computation Î±) (n) : Terminates (thinkN s n) â†’ Terminates s
","  | âŸ¨âŸ¨a, hâŸ©âŸ© => âŸ¨âŸ¨a, (thinkN_mem _).1 hâŸ©âŸ©",rw [terminates_iff]
Mathlib/MeasureTheory/Measure/ProbabilityMeasure.lean,MeasureTheory.FiniteMeasure.self_eq_mass_mul_normalize,self_eq_mass_mul_normalize,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  obtain rfl | h := eq_or_ne Î¼ 0
  Â· simp
  have mass_nonzero : Î¼.mass â‰  0 := by rwa [Î¼.mass_nonzero_iff]
  simp only [normalize, dif_neg mass_nonzero]
  simp [ProbabilityMeasure.coe_mk, toMeasure_smul, mul_inv_cancel_leftâ‚€ mass_nonzero]","error:  unsolved goals
case inr
Î© : Type u_1
instâœ : Nonempty Î©
m0 : MeasurableSpace Î©
Î¼ : FiniteMeasure Î©
s : Set Î©
h : Î¼ â‰  0
mass_nonzero : Î¼.mass â‰  0
âŠ¢ Î¼ s = (â†‘Î¼ s).toNNReal",theorem self_eq_mass_mul_normalize (s : Set Î©) : Î¼ s = Î¼.mass * Î¼.normalize s ,":= by
  obtain rfl | h := eq_or_ne Î¼ 0
  Â· simp
  have mass_nonzero : Î¼.mass â‰  0 := by rwa [Î¼.mass_nonzero_iff]
  simp only [normalize, dif_neg mass_nonzero]
  simp [ProbabilityMeasure.coe_mk, toMeasure_smul, mul_inv_cancel_leftâ‚€ mass_nonzero, coeFn_def]","simp only [self_eq_mass_mul_normalize, self_eq_mass_mul_normalize]"
Mathlib/NumberTheory/Liouville/LiouvilleWith.lean,LiouvilleWith.mul_rat,mul_rat,693fd79515903b10b1d31f10dccfc49e633cf7ee,":= by
  rcases h.exists_pos with âŸ¨C, _hCâ‚€, hCâŸ©
  refine âŸ¨r.den ^ p * (|r| * C), (tendsto_id.nsmul_atTop r.pos).frequently (hC.mono ?_)âŸ©
  rintro n âŸ¨_hn, m, hne, hltâŸ©
  have A : (â†‘(r.num * m) : â„) / â†‘(r.den â€¢ id n) = m / n * r := by
    simp [â† div_mul_div_comm, â† r.cast_def, mul_comm]
  refine âŸ¨r.num * m, ?_, ?_âŸ©
  Â· rw [A]; simp [hne, hr]
  Â· rw [A, â† sub_mul, abs_mul]
    simp only [smul_eq_mul, id.def, Nat.cast_mul]
    refine (mul_lt_mul_of_pos_right hlt <| abs_pos.2 <| Rat.cast_ne_zero.2 hr).trans_le ?_
    rw [mul_rpow, mul_div_mul_left, mul_comm, mul_div_assoc]
    Â· simp only [Rat.cast_abs, le_refl]
    Â· exact (rpow_pos_of_pos (Nat.cast_pos.2 r.pos) _).ne'
    Â· exact Nat.cast_nonneg _
    Â· exact Nat.cast_nonneg _","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.28728 â†’ ?m.28728
error:  unsolved goals
case intro.intro.intro.intro.intro.refine_2
p q x y : â„
r : â„š
mâœ : â„¤
nâœ : â„•
h : LiouvilleWith p x
hr : r â‰  0
C : â„
_hCâ‚€ : 0 < C
hC : âˆƒá¶  (n : â„•) in atTop, 1 â‰¤ n âˆ§ âˆƒ m, x â‰  â†‘m / â†‘n âˆ§ |x - â†‘m / â†‘n| < C / â†‘n ^ p
n : â„•
_hn : 1 â‰¤ n
m : â„¤
hne : x â‰  â†‘m / â†‘n
hlt : |x - â†‘m / â†‘n| < C / â†‘n ^ p
A : â†‘(r.num * m) / â†‘(r.den â€¢ id n) = â†‘m / â†‘n * â†‘r
âŠ¢ |â†‘r| * (C / â†‘n ^ p) â‰¤ |â†‘r| * (C / â†‘(id n) ^ p)",theorem mul_rat (h : LiouvilleWith p x) (hr : r â‰  0) : LiouvilleWith p (x * r) ,":= by
  rcases h.exists_pos with âŸ¨C, _hCâ‚€, hCâŸ©
  refine âŸ¨r.den ^ p * (|r| * C), (tendsto_id.nsmul_atTop r.pos).frequently (hC.mono ?_)âŸ©
  rintro n âŸ¨_hn, m, hne, hltâŸ©
  have A : (â†‘(r.num * m) : â„) / â†‘(r.den â€¢ id n) = m / n * r := by
    simp [â† div_mul_div_comm, â† r.cast_def, mul_comm]
  refine âŸ¨r.num * m, ?_, ?_âŸ©
  Â· rw [A]; simp [hne, hr]
  Â· rw [A, â† sub_mul, abs_mul]
    simp only [smul_eq_mul, id, Nat.cast_mul]
    calc _ < C / â†‘n ^ p * |â†‘r| := by gcongr
      _ = â†‘r.den ^ p * (â†‘|r| * C) / (â†‘r.den * â†‘n) ^ p := ?_
    rw [mul_rpow, mul_div_mul_left, mul_comm, mul_div_assoc]
    Â· simp only [Rat.cast_abs, le_refl]
    all_goals positivity","simp [LiouvilleWith, hr]"
Mathlib/Topology/Category/Profinite/Nobeling.lean,Profinite.NobelingProof.CC_exact,CC_exact,798fd0aeb0b6cf012cc5a6e972d53c8fd4ffae3e,":= by
  dsimp [Linear_CC', Linear_CC'â‚€, Linear_CC'â‚] at hf
  simp only [sub_eq_zero, â† LocallyConstant.coe_inj, LocallyConstant.coe_comap,
    continuous_CC'â‚€, continuous_CC'â‚] at hf
  let Câ‚€C : C0 C ho â†’ C := fun x â†¦ âŸ¨x.val, x.prop.1âŸ©
  have hâ‚€ : Continuous Câ‚€C := Continuous.subtype_mk continuous_induced_dom _
  let Câ‚C : Ï€ (C1 C ho) (ord I Â· < o) â†’ C :=
    fun x â†¦ âŸ¨SwapTrue o x.val, (swapTrue_mem_C1 C hsC ho x).1âŸ©
  have hâ‚ : Continuous Câ‚C := Continuous.subtype_mk
    ((continuous_swapTrue o).comp continuous_subtype_val) _
  refine âŸ¨LocallyConstant.piecewise' ?_ (isClosed_C0 C hC ho)
      (isClosed_proj _ o (isClosed_C1 C hC ho)) (f.comap Câ‚€C) (f.comap Câ‚C) ?_, ?_âŸ©
  Â· rintro _ âŸ¨y, hyC, rflâŸ©
    simp only [Set.mem_union, Set.mem_setOf_eq, Set.mem_univ, iff_true]
    rw [â† union_C0C1_eq C ho] at hyC
    refine hyC.imp (fun hyC â†¦ ?_) (fun hyC â†¦ âŸ¨y, hyC, rflâŸ©)
    rwa [C0_projOrd C hsC ho hyC]
  Â· intro x hx
    simpa only [hâ‚€, hâ‚, LocallyConstant.coe_comap] using (congrFun hf âŸ¨x, hxâŸ©).symm
  Â· ext âŸ¨x, hxâŸ©
    rw [â† union_C0C1_eq C ho] at hx
    cases' hx with hxâ‚€ hxâ‚
    Â· have hxâ‚€' : ProjRestrict C (ord I Â· < o) âŸ¨x, hxâŸ© = x := by
        simpa only [ProjRestrict, Set.MapsTo.val_restrict_apply] using C0_projOrd C hsC ho hxâ‚€
      simp only [hxâ‚€', hxâ‚€, hâ‚€, LocallyConstant.piecewise'_apply_left, LocallyConstant.coe_comap,
        Function.comp_apply, Ï€s_apply, continuous_projRestrict]
    Â· have hxâ‚' : (ProjRestrict C (ord I Â· < o) âŸ¨x, hxâŸ©).val âˆˆ Ï€ (C1 C ho) (ord I Â· < o) := by
        simpa only [ProjRestrict, Set.MapsTo.val_restrict_apply] using âŸ¨x, hxâ‚, rflâŸ©
      simp only [Ï€s_apply, continuous_projRestrict, LocallyConstant.coe_comap, Function.comp_apply,
        hxâ‚', LocallyConstant.piecewise'_apply_right, hâ‚]
      congr
      exact C1_projOrd C hsC ho hxâ‚","error:  application type mismatch
  LocallyConstant.comap Câ‚€C
argument
  Câ‚€C
has type
  â†‘(C0 C ho) â†’ â†‘C : Type u
but is expected to have type
  C(â†‘(C0 C ho), ?m.433540) : Type (max u ?u.433530)
error:  application type mismatch
  LocallyConstant.comap Câ‚C
argument
  Câ‚C
has type
  â†‘(Ï€ (C1 C ho) fun x â†¦ ord I x < o) â†’ â†‘C : Type u
but is expected to have type
  C(â†‘(Ï€ (C1 C ho) fun x â†¦ ord I x < o), ?m.434371) : Type (max u ?u.434361)
error:  unknown identifier 'Ï€s_apply'
error:  simp made no progress
error:  unknown identifier 'Ï€s_apply'
error:  simp made no progress","theorem CC_exact {f : LocallyConstant C â„¤} (hf : Linear_CC' C hsC ho f = 0) :
    âˆƒ y, Ï€s C o y = f ",":= by
  dsimp [Linear_CC', Linear_CC'â‚€, Linear_CC'â‚] at hf
  simp only [sub_eq_zero, â† LocallyConstant.coe_inj, LocallyConstant.coe_comap,
    continuous_CC'â‚€, continuous_CC'â‚] at hf
  let Câ‚€C : C0 C ho â†’ C := fun x â†¦ âŸ¨x.val, x.prop.1âŸ©
  have hâ‚€ : Continuous Câ‚€C := Continuous.subtype_mk continuous_induced_dom _
  let Câ‚C : Ï€ (C1 C ho) (ord I Â· < o) â†’ C :=
    fun x â†¦ âŸ¨SwapTrue o x.val, (swapTrue_mem_C1 C hsC ho x).1âŸ©
  have hâ‚ : Continuous Câ‚C := Continuous.subtype_mk
    ((continuous_swapTrue o).comp continuous_subtype_val) _
  refine âŸ¨LocallyConstant.piecewise' ?_ (isClosed_C0 C hC ho)
      (isClosed_proj _ o (isClosed_C1 C hC ho)) (f.comap âŸ¨Câ‚€C, hâ‚€âŸ©) (f.comap âŸ¨Câ‚C, hâ‚âŸ©) ?_, ?_âŸ©
  Â· rintro _ âŸ¨y, hyC, rflâŸ©
    simp only [Set.mem_union, Set.mem_setOf_eq, Set.mem_univ, iff_true]
    rw [â† union_C0C1_eq C ho] at hyC
    refine hyC.imp (fun hyC â†¦ ?_) (fun hyC â†¦ âŸ¨y, hyC, rflâŸ©)
    rwa [C0_projOrd C hsC ho hyC]
  Â· intro x hx
    simpa only [hâ‚€, hâ‚, LocallyConstant.coe_comap] using (congrFun hf âŸ¨x, hxâŸ©).symm
  Â· ext âŸ¨x, hxâŸ©
    rw [â† union_C0C1_eq C ho] at hx
    cases' hx with hxâ‚€ hxâ‚
    Â· have hxâ‚€' : ProjRestrict C (ord I Â· < o) âŸ¨x, hxâŸ© = x := by
        simpa only [ProjRestrict, Set.MapsTo.val_restrict_apply] using C0_projOrd C hsC ho hxâ‚€
      simp only [Ï€s_apply_apply, hxâ‚€', hxâ‚€, LocallyConstant.piecewise'_apply_left,
        LocallyConstant.coe_comap, ContinuousMap.coe_mk, Function.comp_apply]
    Â· have hxâ‚' : (ProjRestrict C (ord I Â· < o) âŸ¨x, hxâŸ©).val âˆˆ Ï€ (C1 C ho) (ord I Â· < o) := by
        simpa only [ProjRestrict, Set.MapsTo.val_restrict_apply] using âŸ¨x, hxâ‚, rflâŸ©
      simp only [Câ‚C, Ï€s_apply_apply, continuous_projRestrict, LocallyConstant.coe_comap,
        Function.comp_apply, hxâ‚', LocallyConstant.piecewise'_apply_right, hâ‚]
      congr
      simp only [ContinuousMap.coe_mk, Subtype.mk.injEq]
      exact C1_projOrd C hsC ho hxâ‚","obtain âŸ¨y, hyâŸ© := CC_exact CC_exact hf"
Mathlib/MeasureTheory/Measure/Haar/Unique.lean,MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop,measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  apply le_antisymm ?_ (smul_measure_isMulInvariant_le_of_isCompact_closure Î¼' Î¼ hs h's)
  let Î½ := haarScalarFactor Î¼' Î¼ â€¢ Î¼
  change Î¼' s â‰¤ Î½ s
  obtain âŸ¨âŸ¨f, f_contâŸ©, hf, -, f_comp, -âŸ© : âˆƒ f : C(G, â„), EqOn f 1 (closure s) âˆ§ EqOn f 0 âˆ…
      âˆ§ HasCompactSupport f âˆ§ âˆ€ x, f x âˆˆ Icc (0 : â„) 1 :=
    exists_continuous_one_zero_of_isCompact h's isClosed_empty (disjoint_empty _)
  let t := f â»Â¹' {1}
  have t_closed : IsClosed t := isClosed_singleton.preimage f_cont
  have t_comp : IsCompact t := f_comp.isCompact_preimage f_cont isClosed_singleton (by simp)
  have st : s âŠ† t := (IsClosed.closure_subset_iff t_closed).mp hf
  have A : Î½ (t \ s) â‰¤ Î¼' (t \ s) := by
    apply smul_measure_isMulInvariant_le_of_isCompact_closure _ _ (t_closed.measurableSet.diff hs)
    exact t_comp.closure_of_subset (diff_subset t s)
  have B : Î¼' t = Î½ t :=
    measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport _ _ f_cont f_comp
  rwa [measure_diff st hs, measure_diff st hs, â† B, ENNReal.sub_le_sub_iff_left] at A
  Â· exact measure_mono st
  Â· exact t_comp.measure_lt_top.ne
  Â· exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne
  Â· exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne","error:  application type mismatch
  diff_subset t
argument
  t
has type
  Set G : Type u_1
but is expected to have type
  ?m.165361 âˆˆ ?m.165359 \ ?m.165360 : Prop","lemma measure_isMulInvariant_eq_smul_of_isCompact_closure_of_innerRegularCompactLTTop
    [LocallyCompactSpace G]
    (Î¼' Î¼ : Measure G) [IsHaarMeasure Î¼] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼']
    [InnerRegularCompactLTTop Î¼]
    {s : Set G} (hs : MeasurableSet s) (h's : IsCompact (closure s)) :
    Î¼' s = haarScalarFactor Î¼' Î¼ â€¢ Î¼ s ",":= by
  apply le_antisymm ?_ (smul_measure_isMulInvariant_le_of_isCompact_closure Î¼' Î¼ hs h's)
  let Î½ := haarScalarFactor Î¼' Î¼ â€¢ Î¼
  change Î¼' s â‰¤ Î½ s
  obtain âŸ¨âŸ¨f, f_contâŸ©, hf, -, f_comp, -âŸ© : âˆƒ f : C(G, â„), EqOn f 1 (closure s) âˆ§ EqOn f 0 âˆ…
      âˆ§ HasCompactSupport f âˆ§ âˆ€ x, f x âˆˆ Icc (0 : â„) 1 :=
    exists_continuous_one_zero_of_isCompact h's isClosed_empty (disjoint_empty _)
  let t := f â»Â¹' {1}
  have t_closed : IsClosed t := isClosed_singleton.preimage f_cont
  have t_comp : IsCompact t := f_comp.isCompact_preimage f_cont isClosed_singleton (by simp)
  have st : s âŠ† t := (IsClosed.closure_subset_iff t_closed).mp hf
  have A : Î½ (t \ s) â‰¤ Î¼' (t \ s) := by
    apply smul_measure_isMulInvariant_le_of_isCompact_closure _ _ (t_closed.measurableSet.diff hs)
    exact t_comp.closure_of_subset diff_subset
  have B : Î¼' t = Î½ t :=
    measure_preimage_isMulLeftInvariant_eq_smul_of_hasCompactSupport _ _ f_cont f_comp
  rwa [measure_diff st hs, measure_diff st hs, â† B, ENNReal.sub_le_sub_iff_left] at A
  Â· exact measure_mono st
  Â· exact t_comp.measure_lt_top.ne
  Â· exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne
  Â· exact ((measure_mono st).trans_lt t_comp.measure_lt_top).ne",have : IsCompact (closure s) := isCompact_closure_of_isCompact_closure_of_isCompact h's
Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean,Matrix.det_eq_of_forall_row_eq_smul_add_const,det_eq_of_forall_row_eq_smul_add_const,0308d0b2322ef84c2bd2612cb021cec6b1baa323,":= by
  induction s using Finset.induction_on generalizing B with
  | empty =>
    rintro c hs k - A_eq
    have : âˆ€ i, c i = 0 := by
      intro i
      specialize hs i
      contrapose! hs
      simp [hs]
    congr
    ext i j
    rw [A_eq, this, zero_mul, add_zero]
  | @insert i s _hi ih =>
    intro c hs k hk A_eq
    have hAi : A i = B i + c i â€¢ B k := funext (A_eq i)
    rw [@ih (updateRow B i (A i)) (Function.update c i 0), hAi, det_updateRow_add_smul_self]
    Â· exact mt (fun h => show k âˆˆ insert i s from h â–¸ Finset.mem_insert_self _ _) hk
    Â· intro i' hi'
      rw [Function.update_apply]
      split_ifs with hi'i
      Â· rfl
      Â· exact hs i' fun h => hi' ((Finset.mem_insert.mp h).resolve_left hi'i)
    Â· exact fun h => hk (Finset.mem_insert_of_mem h)
    Â· intro i' j'
      rw [updateRow_apply, Function.update_apply]
      split_ifs with hi'i
      Â· simp [hi'i]
      rw [A_eq, updateRow_ne fun h : k = i => hk <| h â–¸ Finset.mem_insert_self k s]","error:  type mismatch
  fun h â†¦ hk (mem_insert_of_mem h)
has type
  k âˆˆ s â†’ False : Prop
but is expected to have type
  n : Type u_2
error:  tactic 'introN' failed, insufficient number of binders
case insert.x
m : Type u_1
n : Type u_2
instâœâ´ : DecidableEq n
instâœÂ³ : Fintype n
instâœÂ² : DecidableEq m
instâœÂ¹ : Fintype m
R : Type v
instâœ : CommRing R
A : Matrix n n R
i : n
s : Finset n
_hi : i âˆ‰ s
ih :
  âˆ€ {B : Matrix n n R} (c : n â†’ R),
    (âˆ€ i âˆ‰ s, c i = 0) â†’ âˆ€ k âˆ‰ s, (âˆ€ (i j : n), A i j = B i j + c i * B k j) â†’ A.det = B.det
B : Matrix n n R
c : n â†’ R
hs : âˆ€ i_1 âˆ‰ insert i s, c i_1 = 0
k : n
hk : k âˆ‰ insert i s
A_eq : âˆ€ (i j : n), A i j = B i j + c i * B k j
hAi : A i = B i + c i â€¢ B k
i' : sorryAx n true âˆˆ s
âŠ¢ False
error:  unsolved goals
case insert.x
m : Type u_1
n : Type u_2
instâœâ´ : DecidableEq n
instâœÂ³ : Fintype n
instâœÂ² : DecidableEq m
instâœÂ¹ : Fintype m
R : Type v
instâœ : CommRing R
A : Matrix n n R
i : n
s : Finset n
_hi : i âˆ‰ s
ih :
  âˆ€ {B : Matrix n n R} (c : n â†’ R),
    (âˆ€ i âˆ‰ s, c i = 0) â†’ âˆ€ k âˆ‰ s, (âˆ€ (i j : n), A i j = B i j + c i * B k j) â†’ A.det = B.det
B : Matrix n n R
c : n â†’ R
hs : âˆ€ i_1 âˆ‰ insert i s, c i_1 = 0
k : n
hk : k âˆ‰ insert i s
A_eq : âˆ€ (i j : n), A i j = B i j + c i * B k j
hAi : A i = B i + c i â€¢ B k
âŠ¢ âˆ€ (i_1 j : n), A i_1 j = B.updateRow i (A i) i_1 j + update c i 0 i_1 * B.updateRow i (A i) (sorryAx n true) j","theorem det_eq_of_forall_row_eq_smul_add_const_aux {A B : Matrix n n R} {s : Finset n} :
    âˆ€ (c : n â†’ R) (_ : âˆ€ i, i âˆ‰ s â†’ c i = 0) (k : n) (_ : k âˆ‰ s)
      (_: âˆ€ i j, A i j = B i j + c i * B k j), det A = det B ",":= by
  induction s using Finset.induction_on generalizing B with
  | empty =>
    rintro c hs k - A_eq
    have : âˆ€ i, c i = 0 := by
      intro i
      specialize hs i
      contrapose! hs
      simp [hs]
    congr
    ext i j
    rw [A_eq, this, zero_mul, add_zero]
  | @insert i s _hi ih =>
    intro c hs k hk A_eq
    have hAi : A i = B i + c i â€¢ B k := funext (A_eq i)
    rw [@ih (updateRow B i (A i)) (Function.update c i 0), hAi, det_updateRow_add_smul_self]
    Â· exact mt (fun h => show k âˆˆ insert i s from h â–¸ Finset.mem_insert_self _ _) hk
    Â· intro i' hi'
      rw [Function.update_apply]
      split_ifs with hi'i
      Â· rfl
      Â· exact hs i' fun h => hi' ((Finset.mem_insert.mp h).resolve_left hi'i)
    Â· exact k
    Â· exact fun h => hk (Finset.mem_insert_of_mem h)
    Â· intro i' j'
      rw [updateRow_apply, Function.update_apply]
      split_ifs with hi'i
      Â· simp [hi'i]
      rw [A_eq, updateRow_ne fun h : k = i => hk <| h â–¸ Finset.mem_insert_self k s]","simp only [det_eq_of_forall_row_eq_smul_add_const_aux, det_eq_of_forall_row_eq_smul_add_const_aux,
  det_eq_of_forall_row_eq_smul_add_const_aux]"
Mathlib/CategoryTheory/Subterminal.lean,CategoryTheory.isSubterminal_of_mono_terminal_from,isSubterminal_of_mono_terminal_from,2dd4958071770ecb46fb7387966ae33bd0c0a71d,":= fun Z f g => by
  rw [â† cancel_mono (terminal.from A)]
  subsingleton","error:  unknown tactic
error:  unsolved goals
C : Type uâ‚
instâœÂ² : Category.{vâ‚, uâ‚} C
A : C
instâœÂ¹ : HasTerminal C
instâœ : Mono (terminal.from A)
Z : C
f g : Z âŸ¶ A
âŠ¢ f â‰« terminal.from A = g â‰« terminal.from A","theorem isSubterminal_of_mono_terminal_from [HasTerminal C] [Mono (terminal.from A)] :
    IsSubterminal A ",":= fun Z f g => by
  rw [â† cancel_mono (terminal.from A)]
  apply Subsingleton.elim",apply isSubterminal_of_mono_terminal_from
Mathlib/NumberTheory/SumTwoSquares.lean,ZMod.isSquare_neg_one_iff',ZMod.isSquare_neg_one_iff',d664a4757e1d5d6999ae3ca588b989e1039faee2,":= by
  have help : âˆ€ a b : ZMod 4, a â‰  3 â†’ b â‰  3 â†’ a * b â‰  3 := by decide
  rw [ZMod.isSquare_neg_one_iff hn]
  refine' âŸ¨_, fun H q _ => HâŸ©
  intro H
  refine' @induction_on_primes _ _ _ (fun p q hp hq hpq => _)
  Â· exact fun _ => by norm_num
  Â· exact fun _ => by norm_num
  Â· replace hp := H hp (dvd_of_mul_right_dvd hpq)
    replace hq := hq (dvd_of_mul_left_dvd hpq)
    rw [show 3 = 3 % 4 by norm_num, Ne.def, â† ZMod.nat_cast_eq_nat_cast_iff'] at hp hq âŠ¢
    rw [Nat.cast_mul]
    exact help p q hp hq","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.29098 â†’ ?m.29098 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.29100
case refine'_3
n : â„•
hn : Squarefree n
help : âˆ€ (a b : ZMod 4), a â‰  3 â†’ b â‰  3 â†’ a * b â‰  3
H : âˆ€ {q : â„•}, Nat.Prime q â†’ q âˆ£ n â†’ q % 4 â‰  3
p q : â„•
hpq : p * q âˆ£ n
hp : p % 4 â‰  3 % 4
hq : q % 4 â‰  3 % 4
âŠ¢ p * q % 4 â‰  3 % 4","theorem ZMod.isSquare_neg_one_iff' {n : â„•} (hn : Squarefree n) :
    IsSquare (-1 : ZMod n) â†” âˆ€ {q : â„•}, q âˆ£ n â†’ q % 4 â‰  3 ",":= by
  have help : âˆ€ a b : ZMod 4, a â‰  3 â†’ b â‰  3 â†’ a * b â‰  3 := by decide
  rw [ZMod.isSquare_neg_one_iff hn]
  refine âŸ¨?_, fun H q _ => HâŸ©
  intro H
  refine @induction_on_primes _ ?_ ?_ (fun p q hp hq hpq => ?_)
  Â· exact fun _ => by norm_num
  Â· exact fun _ => by norm_num
  Â· replace hp := H hp (dvd_of_mul_right_dvd hpq)
    replace hq := hq (dvd_of_mul_left_dvd hpq)
    rw [show 3 = 3 % 4 by norm_num, Ne, â† ZMod.natCast_eq_natCast_iff'] at hp hq âŠ¢
    rw [Nat.cast_mul]
    exact help p q hp hq",constructor
Mathlib/RingTheory/MvPowerSeries/Inverse.lean,MvPowerSeries.invOfUnit_eq',invOfUnit_eq',456553b604b7224438a4ca1e7546556ca6a53e89,":=
  rfl","error:  type mismatch
  rfl
has type
  Ï†.invOfUnit u = Ï†.invOfUnit u : Prop
but is expected to have type
  Ï†.invOfUnit u = Ï†â»Â¹ : Prop","theorem invOfUnit_eq' (Ï† : MvPowerSeries Ïƒ k) (u : Units k) (h : constantCoeff Ïƒ k Ï† = u) :
    invOfUnit Ï† u = Ï†â»Â¹ ",":= by
  rw [â† invOfUnit_eq Ï† (h.symm â–¸ u.ne_zero)]
  apply congrArg (invOfUnit Ï†)
  rw [Units.ext_iff]
  exact h.symm","simp only [invOfUnit, constantCoeff_invOfUnit, constantCoeff_invOfUnit]"
Mathlib/LinearAlgebra/Charpoly/ToMatrix.lean,LinearMap.charpoly_toMatrix,charpoly_toMatrix,7d5d6f444c6f7863a1ac69a54aa015863d411dfe,":= by
  let A := toMatrix b b f
  let b' := chooseBasis R M
  let Î¹' := ChooseBasisIndex R M
  let A' := toMatrix b' b' f
  let e := Basis.indexEquiv b b'
  let Ï† := reindexLinearEquiv R R e e
  let Ï†â‚ := reindexLinearEquiv R R e (Equiv.refl Î¹')
  let Ï†â‚‚ := reindexLinearEquiv R R (Equiv.refl Î¹') (Equiv.refl Î¹')
  let Ï†â‚ƒ := reindexLinearEquiv R R (Equiv.refl Î¹') e
  let P := b.toMatrix b'
  let Q := b'.toMatrix b
  have hPQ : C.mapMatrix (Ï†â‚ P) â¬ C.mapMatrix (Ï†â‚ƒ Q) = 1 := by
    rw [RingHom.mapMatrix_apply, RingHom.mapMatrix_apply, â† Matrix.map_mul,
      reindexLinearEquiv_mul R R, Basis.toMatrix_mul_toMatrix_flip,
      reindexLinearEquiv_one, â† RingHom.mapMatrix_apply, RingHom.map_one]
  calc
    A.charpoly = (reindex e e A).charpoly := (charpoly_reindex _ _).symm
    _ = det (scalar Î¹' X - C.mapMatrix (Ï† A)) := rfl
    _ = det (scalar Î¹' X - C.mapMatrix (Ï† (P â¬ A' â¬ Q))) := by
      rw [basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix]
    _ = det (scalar Î¹' X - C.mapMatrix (Ï†â‚ P â¬ Ï†â‚‚ A' â¬ Ï†â‚ƒ Q)) := by
      rw [reindexLinearEquiv_mul, reindexLinearEquiv_mul]
    _ = det (scalar Î¹' X - C.mapMatrix (Ï†â‚ P) â¬ C.mapMatrix A' â¬ C.mapMatrix (Ï†â‚ƒ Q)) := by simp
    _ = det (scalar Î¹' X â¬ C.mapMatrix (Ï†â‚ P) â¬ C.mapMatrix (Ï†â‚ƒ Q) -
          C.mapMatrix (Ï†â‚ P) â¬ C.mapMatrix A' â¬ C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [Matrix.mul_assoc ((scalar Î¹') X), hPQ, Matrix.mul_one]
    _ = det (C.mapMatrix (Ï†â‚ P) â¬ scalar Î¹' X â¬ C.mapMatrix (Ï†â‚ƒ Q) -
          C.mapMatrix (Ï†â‚ P) â¬ C.mapMatrix A' â¬ C.mapMatrix (Ï†â‚ƒ Q)) := by simp
    _ = det (C.mapMatrix (Ï†â‚ P) â¬ (scalar Î¹' X - C.mapMatrix A') â¬ C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [â† Matrix.sub_mul, â† Matrix.mul_sub]
    _ = det (C.mapMatrix (Ï†â‚ P)) * det (scalar Î¹' X - C.mapMatrix A') * det (C.mapMatrix (Ï†â‚ƒ Q)) :=
      by rw [det_mul, det_mul]
    _ = det (C.mapMatrix (Ï†â‚ P)) * det (C.mapMatrix (Ï†â‚ƒ Q)) * det (scalar Î¹' X - C.mapMatrix A') :=
      by ring
    _ = det (scalar Î¹' X - C.mapMatrix A') := by
      rw [â† det_mul, hPQ, det_one, one_mul]
    _ = f.charpoly := rfl",error:  expected token,"theorem charpoly_toMatrix {Î¹ : Type w} [DecidableEq Î¹] [Fintype Î¹] (b : Basis Î¹ R M) :
    (toMatrix b b f).charpoly = f.charpoly ",":= by
  let A := toMatrix b b f
  let b' := chooseBasis R M
  let Î¹' := ChooseBasisIndex R M
  let A' := toMatrix b' b' f
  let e := Basis.indexEquiv b b'
  let Ï† := reindexLinearEquiv R R e e
  let Ï†â‚ := reindexLinearEquiv R R e (Equiv.refl Î¹')
  let Ï†â‚‚ := reindexLinearEquiv R R (Equiv.refl Î¹') (Equiv.refl Î¹')
  let Ï†â‚ƒ := reindexLinearEquiv R R (Equiv.refl Î¹') e
  let P := b.toMatrix b'
  let Q := b'.toMatrix b
  have hPQ : C.mapMatrix (Ï†â‚ P) * C.mapMatrix (Ï†â‚ƒ Q) = 1 := by
    rw [RingHom.mapMatrix_apply, RingHom.mapMatrix_apply, â† Matrix.map_mul,
      reindexLinearEquiv_mul R R, Basis.toMatrix_mul_toMatrix_flip,
      reindexLinearEquiv_one, â† RingHom.mapMatrix_apply, RingHom.map_one]
  calc
    A.charpoly = (reindex e e A).charpoly := (charpoly_reindex _ _).symm
    _ = det (scalar Î¹' X - C.mapMatrix (Ï† A)) := rfl
    _ = det (scalar Î¹' X - C.mapMatrix (Ï† (P * A' * Q))) := by
      rw [basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix]
    _ = det (scalar Î¹' X - C.mapMatrix (Ï†â‚ P * Ï†â‚‚ A' * Ï†â‚ƒ Q)) := by
      rw [reindexLinearEquiv_mul, reindexLinearEquiv_mul]
    _ = det (scalar Î¹' X - C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by simp [Ï†â‚‚]
    _ = det (scalar Î¹' X * C.mapMatrix (Ï†â‚ P) * C.mapMatrix (Ï†â‚ƒ Q) -
          C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [Matrix.mul_assoc ((scalar Î¹') X), hPQ, Matrix.mul_one]
    _ = det (C.mapMatrix (Ï†â‚ P) * scalar Î¹' X * C.mapMatrix (Ï†â‚ƒ Q) -
          C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [scalar_commute _ commute_X]
    _ = det (C.mapMatrix (Ï†â‚ P) * (scalar Î¹' X - C.mapMatrix A') * C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [â† Matrix.sub_mul, â† Matrix.mul_sub]
    _ = det (C.mapMatrix (Ï†â‚ P)) * det (scalar Î¹' X - C.mapMatrix A') * det (C.mapMatrix (Ï†â‚ƒ Q)) :=
      by rw [det_mul, det_mul]
    _ = det (C.mapMatrix (Ï†â‚ P)) * det (C.mapMatrix (Ï†â‚ƒ Q)) * det (scalar Î¹' X - C.mapMatrix A') :=
      by ring
    _ = det (scalar Î¹' X - C.mapMatrix A') := by
      rw [â† det_mul, hPQ, det_one, one_mul]
    _ = f.charpoly := rfl","rw [charpoly_toMatrix_eq_charpoly, charmatrix_eq_charpoly]"
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,AffineMap.lineMap_mem_affineSpan_pair,AffineMap.lineMap_mem_affineSpan_pair,f27ef6dc0fb66aa1c033b41bb16e840c0a1527a5,":= by
  set_like","error:  unknown tactic
error:  unsolved goals
k : Type u_1
V : Type u_2
P : Type u_3
instâœÂ³ : Ring k
instâœÂ² : AddCommGroup V
instâœÂ¹ : Module k V
instâœ : AffineSpace V P
Î¹ : Type u_4
r : k
pâ‚ pâ‚‚ : P
âŠ¢ (lineMap pâ‚ pâ‚‚) r âˆˆ affineSpan k {pâ‚, pâ‚‚}
warning:  @AffineSubspace.Parallel does not have a doc string","theorem AffineMap.lineMap_mem_affineSpan_pair (r : k) (pâ‚ pâ‚‚ : P) :
    AffineMap.lineMap pâ‚ pâ‚‚ r âˆˆ line[k, pâ‚, pâ‚‚] ",":=
  AffineMap.lineMap_mem _ (left_mem_affineSpan_pair _ _ _) (right_mem_affineSpan_pair _ _ _)","simp only [lineMap_mem_affineSpan_pair, AffineMap.lineMap_mem_affineSpan_pair]"
Mathlib/Order/Monotone/Extension.lean,MonotoneOn.exists_monotone_extension,MonotoneOn.exists_monotone_extension,751f7c13f21c8209a7c021c922a9db93895d6b6c,":= by
  classical
    rcases hl with âŸ¨a, haâŸ©
    have hu' : âˆ€ x, BddAbove (f '' (Iic x âˆ© s)) := fun x =>
      hu.mono (image_subset _ (inter_subset_right _ _))
    let g : Î± â†’ Î² := fun x => if Disjoint (Iic x) s then a else supâ‚› (f '' (Iic x âˆ© s))
    have hgs : EqOn f g s := by
      intro x hx
      simp only []
      have : IsGreatest (Iic x âˆ© s) x := âŸ¨âŸ¨right_mem_Iic, hxâŸ©, fun y hy => hy.1âŸ©
      rw [if_neg this.nonempty.not_disjoint,
        ((h.mono <| inter_subset_right _ _).map_isGreatest this).csupâ‚›_eq]
    refine' âŸ¨g, fun x y hxy => _, hgsâŸ©
    by_cases hx : Disjoint (Iic x) s <;> by_cases hy : Disjoint (Iic y) s <;>
      simp only [if_pos, if_neg, not_false_iff, *, refl]
    Â· rcases not_disjoint_iff_nonempty_inter.1 hy with âŸ¨z, hzâŸ©
      exact le_csupâ‚›_of_le (hu' _) (mem_image_of_mem _ hz) (ha <| mem_image_of_mem _ hz.2)
    Â· exact (hx <| hy.mono_left <| Iic_subset_Iic.2 hxy).elim
    Â· rw [not_disjoint_iff_nonempty_inter] at hx hy
      refine' csupâ‚›_le_csupâ‚› (hu' _) (hx.image _) (image_subset _ _)
      exact inter_subset_inter_left _ (Iic_subset_Iic.2 hxy)","error:  function expected at
  inter_subset_right ?m.942
term has type
  ?m.941 âˆˆ ?m.940
error:  unknown identifier 'supâ‚›'
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  application type mismatch
  not_disjoint_iff_nonempty_inter.mp hy
argument
  hy
has type
  Disjoint (Iic y) s : Prop
but is expected to have type
  Â¬Disjoint ?m.3078 ?m.3079 : Prop
error:  unknown identifier 'le_csupâ‚›_of_le'
error:  invalid field 'mono_left', the environment does not contain 'Not.mono_left'
  hy
has type
  Â¬Disjoint (Iic y) s
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hy
has type
  Disjoint (Iic y) s â†’ False
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Â¬Disjoint ?m.3335 ?m.3336
case pos
Î± : Type u_1
Î² : Type u_2
instâœÂ¹ : LinearOrder Î±
instâœ : ConditionallyCompleteLinearOrder Î²
f : Î± â†’ Î²
s : Set Î±
aâœ b : Î±
h : MonotoneOn f s
hu : BddAbove (f '' s)
a : Î²
ha : a âˆˆ lowerBounds (f '' s)
hu' : âˆ€ (x : Î±), BddAbove (f '' (Iic x âˆ© s))
g : Î± â†’ Î² := fun x â†¦ if Disjoint (Iic x) s then a else sorryAx Î² true
hgs : EqOn f g s
x y : Î±
hxy : x â‰¤ y
hx : (Iic x âˆ© s).Nonempty
hy : Disjoint (Iic y) s
âŠ¢ g x â‰¤ g y
error:  unsolved goals
case neg
Î± : Type u_1
Î² : Type u_2
instâœÂ¹ : LinearOrder Î±
instâœ : ConditionallyCompleteLinearOrder Î²
f : Î± â†’ Î²
s : Set Î±
aâœ b : Î±
h : MonotoneOn f s
hu : BddAbove (f '' s)
a : Î²
ha : a âˆˆ lowerBounds (f '' s)
hu' : âˆ€ (x : Î±), BddAbove (f '' (Iic x âˆ© s))
g : Î± â†’ Î² := fun x â†¦ if Disjoint (Iic x) s then a else sorryAx Î² true
hgs : EqOn f g s
x y : Î±
hxy : x â‰¤ y
hx : Â¬Disjoint (Iic x) s
hy : Â¬Disjoint (Iic y) s
âŠ¢ g x â‰¤ g y","theorem MonotoneOn.exists_monotone_extension (h : MonotoneOn f s) (hl : BddBelow (f '' s))
    (hu : BddAbove (f '' s)) : âˆƒ g : Î± â†’ Î², Monotone g âˆ§ EqOn f g s ",":= by
  classical
    rcases hl with âŸ¨a, haâŸ©
    have hu' : âˆ€ x, BddAbove (f '' (Iic x âˆ© s)) := fun x =>
      hu.mono (image_subset _ inter_subset_right)
    let g : Î± â†’ Î² := fun x => if Disjoint (Iic x) s then a else sSup (f '' (Iic x âˆ© s))
    have hgs : EqOn f g s := by
      intro x hx
      simp only [g]
      have : IsGreatest (Iic x âˆ© s) x := âŸ¨âŸ¨right_mem_Iic, hxâŸ©, fun y hy => hy.1âŸ©
      rw [if_neg this.nonempty.not_disjoint,
        ((h.mono inter_subset_right).map_isGreatest this).csSup_eq]
    refine âŸ¨g, fun x y hxy => ?_, hgsâŸ©
    by_cases hx : Disjoint (Iic x) s <;> by_cases hy : Disjoint (Iic y) s <;>
      simp only [g, if_pos, if_neg, not_false_iff, *, refl]
    Â· rcases not_disjoint_iff_nonempty_inter.1 hy with âŸ¨z, hzâŸ©
      exact le_csSup_of_le (hu' _) (mem_image_of_mem _ hz) (ha <| mem_image_of_mem _ hz.2)
    Â· exact (hx <| hy.mono_left <| Iic_subset_Iic.2 hxy).elim
    Â· rw [not_disjoint_iff_nonempty_inter] at hx hy
      refine csSup_le_csSup (hu' _) (hx.image _) (image_subset _ ?_)
      exact inter_subset_inter_left _ (Iic_subset_Iic.2 hxy)","rcases exists_monotone_extension_exists_monotone_extension_extension h hl hu hv hu with
  âŸ¨g, g_mono, g_eqâŸ©"
Mathlib/Computability/Halting.lean,ComputablePred.halting_problem,halting_problem,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  (eval_part.compâ‚‚ Computable.id (Computable.const _)).dom_re","error:  application type mismatch
  Partrecâ‚‚.compâ‚‚ eval_part Computable.id
argument
  Computable.id
has type
  Computable id : Prop
but is expected to have type
  Computableâ‚‚ ?m.80042 : Prop",theorem halting_problem_re (n) : RePred fun c => (eval c n).Dom ,":=
  (eval_part.comp Computable.id (Computable.const _)).dom_re","simp only [halting_problem_re, halting_problem_re]"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.withDensity_le_mul,withDensity_le_mul,738ad0b1a96ead61d11b270ccd006461d3eb7397,":= by
  have t_ne_zero' : t â‰  0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : â„â‰¥0âˆ) â‰  0 := by simpa only [ENNReal.coe_eq_zero, Ne.def] using t_ne_zero'
  let Î½ := Î¼.withDensity (v.limRatioMeas hÏ)
  let f := v.limRatioMeas hÏ
  have f_meas : Measurable f := v.limRatioMeas_measurable hÏ
  have A : Î½ (s âˆ© f â»Â¹' {0}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) := by
    apply le_trans _ (zero_le _)
    have M : MeasurableSet (s âˆ© f â»Â¹' {0}) := hs.inter (f_meas (measurableSet_singleton _))
    simp only [nonpos_iff_eq_zero, M, withDensity_apply, lintegral_eq_zero_iff f_meas]
    apply (ae_restrict_iff' M).2
    exact eventually_of_forall fun x hx => hx.2
  have B : Î½ (s âˆ© f â»Â¹' {âˆ}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply withDensity_absolutelyContinuous Î¼ _
    rw [â† nonpos_iff_eq_zero]
    exact (measure_mono (inter_subset_right _ _)).trans (v.measure_limRatioMeas_top hÏ).le
  have C :
    âˆ€ n : â„¤,
      Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) â‰¤
        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))
    have M : MeasurableSet (s âˆ© f â»Â¹' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      (âˆ«â» x in s âˆ© f â»Â¹' I, f x âˆ‚Î¼) â‰¤ âˆ«â» x in s âˆ© f â»Â¹' I, (t : â„â‰¥0âˆ) ^ (n + 1) âˆ‚Î¼ :=
        lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => hx.2.2.le))
      _ = (t : â„â‰¥0âˆ) ^ (n + 1) * Î¼ (s âˆ© f â»Â¹' I) := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ = (t : â„â‰¥0âˆ) ^ (2 : â„¤) * ((t : â„â‰¥0âˆ) ^ (n - 1) * Î¼ (s âˆ© f â»Â¹' I)) := by
        rw [â† mul_assoc, â† ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top]
        congr 2
        abel
      _ â‰¤ (t : â„â‰¥0âˆ) ^ 2 * Ï (s âˆ© f â»Â¹' I) := by
        refine' mul_le_mul_left' _ _
        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne']
        apply v.mul_measure_le_of_subset_lt_limRatioMeas hÏ
        intro x hx
        apply lt_of_lt_of_le _ hx.2.1
        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne', ENNReal.coe_lt_coe, sub_eq_add_neg,
          zpow_addâ‚€ t_ne_zero']
        conv_rhs => rw [â† mul_one (t ^ n)]
        refine' mul_lt_mul' le_rfl _ (zero_le _) (NNReal.zpow_pos t_ne_zero' _)
        rw [zpow_neg_one]
        exact inv_lt_one ht
  calc
    Î½ s =
      Î½ (s âˆ© f â»Â¹' {0}) + Î½ (s âˆ© f â»Â¹' {âˆ}) +
        âˆ‘' n : â„¤, Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow Î½ f_meas hs ht
    _ â‰¤
        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) + ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) +
          âˆ‘' n : â„¤, ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico (t ^ n) (t ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï) f_meas hs ht).symm","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.192105 â†’ ?m.192105 â†’ Prop
error:  type mismatch
  hâœ
has type
  t â‰  0 : Prop
but is expected to have type
  â†‘t â‰  0 : Prop
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  invalid field 'withDensity_le_mul', the environment does not contain 'VitaliFamily.withDensity_le_mul'
  v
has type
  VitaliFamily Î¼","theorem withDensity_le_mul {s : Set Î±} (hs : MeasurableSet s) {t : â„â‰¥0} (ht : 1 < t) :
    Î¼.withDensity (v.limRatioMeas hÏ) s â‰¤ (t : â„â‰¥0âˆ) ^ 2 * Ï s ",":= by
  have t_ne_zero' : t â‰  0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : â„â‰¥0âˆ) â‰  0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let Î½ := Î¼.withDensity (v.limRatioMeas hÏ)
  let f := v.limRatioMeas hÏ
  have f_meas : Measurable f := v.limRatioMeas_measurable hÏ
  have A : Î½ (s âˆ© f â»Â¹' {0}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) := by
    apply le_trans _ (zero_le _)
    have M : MeasurableSet (s âˆ© f â»Â¹' {0}) := hs.inter (f_meas (measurableSet_singleton _))
    simp only [Î½, nonpos_iff_eq_zero, M, withDensity_apply, lintegral_eq_zero_iff f_meas]
    apply (ae_restrict_iff' M).2
    exact eventually_of_forall fun x hx => hx.2
  have B : Î½ (s âˆ© f â»Â¹' {âˆ}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply withDensity_absolutelyContinuous Î¼ _
    rw [â† nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hÏ).le
  have C :
    âˆ€ n : â„¤,
      Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) â‰¤
        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))
    have M : MeasurableSet (s âˆ© f â»Â¹' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [Î½, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      (âˆ«â» x in s âˆ© f â»Â¹' I, f x âˆ‚Î¼) â‰¤ âˆ«â» _ in s âˆ© f â»Â¹' I, (t : â„â‰¥0âˆ) ^ (n + 1) âˆ‚Î¼ :=
        lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => hx.2.2.le))
      _ = (t : â„â‰¥0âˆ) ^ (n + 1) * Î¼ (s âˆ© f â»Â¹' I) := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ = (t : â„â‰¥0âˆ) ^ (2 : â„¤) * ((t : â„â‰¥0âˆ) ^ (n - 1) * Î¼ (s âˆ© f â»Â¹' I)) := by
        rw [â† mul_assoc, â† ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top]
        congr 2
        abel
      _ â‰¤ (t : â„â‰¥0âˆ) ^ (2 : â„¤) * Ï (s âˆ© f â»Â¹' I) := by
        gcongr
        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne']
        apply v.mul_measure_le_of_subset_lt_limRatioMeas hÏ
        intro x hx
        apply lt_of_lt_of_le _ hx.2.1
        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne', ENNReal.coe_lt_coe, sub_eq_add_neg,
          zpow_addâ‚€ t_ne_zero']
        conv_rhs => rw [â† mul_one (t ^ n)]
        gcongr
        rw [zpow_neg_one]
        exact inv_lt_one ht
  calc
    Î½ s =
      Î½ (s âˆ© f â»Â¹' {0}) + Î½ (s âˆ© f â»Â¹' {âˆ}) +
        âˆ‘' n : â„¤, Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow Î½ f_meas hs ht
    _ â‰¤
        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) + ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) +
          âˆ‘' n : â„¤, ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico (t ^ n) (t ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï) f_meas hs ht).symm",refine (withDensity_le_mul hs t ht).trans ?_
Mathlib/Data/Fin/Tuple/Basic.lean,Fin.isSome_find_iff,isSome_find_iff,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,"  | 0, p, _ => iff_of_false (fun h â†¦ Bool.noConfusion h) fun âŸ¨i, _âŸ© â†¦ Fin.elim0' i
  | n + 1, p, _ =>
    âŸ¨fun h â†¦ by
      rw [Option.isSome_iff_exists] at h
      cases' h with i hi
      exact âŸ¨i, find_spec _ hiâŸ©, fun âŸ¨âŸ¨i, hinâŸ©, hiâŸ© â†¦ by
      dsimp [find]
      cases' h : find fun i : Fin n â†¦ p (i.castLT (Nat.lt_succ_of_lt i.2)) with j
      Â· split_ifs with hl
        Â· exact Option.isSome_some
        Â· have := (@isSome_find_iff n (fun x â†¦ p (x.castLT (Nat.lt_succ_of_lt x.2))) _).2
              âŸ¨âŸ¨i, lt_of_le_of_ne (Nat.le_of_lt_succ hin) fun h â†¦ by cases h; exact hl hiâŸ©, hiâŸ©
          rw [h] at this
          exact this
      Â· simpâŸ©",error:  unknown constant 'Fin.elim0'',"theorem isSome_find_iff :
    âˆ€ {n : â„•} {p : Fin n â†’ Prop} [DecidablePred p], (find p).isSome â†” âˆƒ i, p i
","  | 0, p, _ => iff_of_false (fun h â†¦ Bool.noConfusion h) fun âŸ¨i, _âŸ© â†¦ Fin.elim0 i
  | n + 1, p, _ =>
    âŸ¨fun h â†¦ by
      rw [Option.isSome_iff_exists] at h
      cases' h with i hi
      exact âŸ¨i, find_spec _ hiâŸ©, fun âŸ¨âŸ¨i, hinâŸ©, hiâŸ© â†¦ by
      dsimp [find]
      cases' h : find fun i : Fin n â†¦ p (i.castLT (Nat.lt_succ_of_lt i.2)) with j
      Â· split_ifs with hl
        Â· exact Option.isSome_some
        Â· have := (@isSome_find_iff n (fun x â†¦ p (x.castLT (Nat.lt_succ_of_lt x.2))) _).2
              âŸ¨âŸ¨i, lt_of_le_of_ne (Nat.le_of_lt_succ hin) fun h â†¦ by cases h; exact hl hiâŸ©, hiâŸ©
          rw [h] at this
          exact this
      Â· simpâŸ©","simp only [isSome_find_iff, exists_prop]"
Mathlib/Computability/AkraBazzi/AkraBazzi.lean,AkraBazziRecurrence.T_isBigO_smoothingFn_mul_asympBound,T_isBigO_smoothingFn_mul_asympBound,6861d9247d1a06a093e444c3a0319e5ec45263c2,":= by
  let b' := b (min_bi b) / 2
  have hb_pos : 0 < b' := R.bi_min_div_two_pos
  rw [isBigO_atTop_iff_eventually_exists]
  obtain âŸ¨câ‚, hcâ‚, h_sumTransform_auxâŸ© := R.eventually_atTop_sumTransform_ge
  filter_upwards [eventually_ge_atTop R.nâ‚€,       
      eventually_forall_ge_atTop.mpr eventually_one_sub_smoothingFn_pos,    
      eventually_forall_ge_atTop.mpr
        <| eventually_one_sub_smoothingFn_gt_const (1/2) (by norm_num),    
      eventually_forall_ge_atTop.mpr R.eventually_asympBound_pos,            
      eventually_forall_ge_atTop.mpr R.eventually_asympBound_r_pos,          
      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop
        R.eventually_asympBound_pos,   
      eventually_gt_atTop 0,                                                
      eventually_forall_ge_atTop.mpr R.eventually_one_sub_smoothingFn_r_pos,  
      eventually_forall_ge_atTop.mpr R.rpow_p_mul_one_sub_smoothingFn_le,    
      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop
        eventually_one_sub_smoothingFn_pos,   
      eventually_forall_ge_atTop.mpr h_sumTransform_aux,                     
      eventually_forall_ge_atTop.mpr R.eventually_bi_mul_le_r]               
    with nâ‚€ nâ‚€_ge_Rnâ‚€ h_smoothing_pos h_smoothing_gt_half
      h_asympBound_pos h_asympBound_r_pos h_asympBound_floor nâ‚€_pos h_smoothing_r_pos
      bound1 h_smoothingFn_floor h_sumTransform h_bi_le_r
  have h_base_nonempty := R.base_nonempty nâ‚€_pos
  let base_max : â„ :=
    (Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€).sup' h_base_nonempty
      fun n => T n / ((1 - Îµ n) * asympBound g a b n)
  set C := max (2 * câ‚â»Â¹) base_max with hC
  refine âŸ¨C, fun n hn => ?_âŸ©
  have h_base : âˆ€ n âˆˆ Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€, T n â‰¤ C * ((1 - Îµ n) * asympBound g a b n) := by
    intro n hn
    rw [Finset.mem_Ico] at hn
    have htmp1 : 0 < 1 - Îµ n := h_smoothingFn_floor n hn.1
    have htmp2 : 0 < asympBound g a b n := h_asympBound_floor n hn.1
    rw [â† _root_.div_le_iff (by positivity)]
    rw [â† Finset.mem_Ico] at hn
    calc T n / ((1 - Îµ â†‘n) * asympBound g a b n)
           â‰¤ (Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€).sup' h_base_nonempty
                (fun z => T z / ((1 - Îµ z) * asympBound g a b z)) :=
                  Finset.le_sup'_of_le _ (b := n) hn le_rfl
         _ â‰¤ C := le_max_right _ _
  have h_asympBound_pos' : 0 < asympBound g a b n := h_asympBound_pos n hn
  have h_one_sub_smoothingFn_pos' : 0 < 1 - Îµ n := h_smoothing_pos n hn
  rw [Real.norm_of_nonneg (R.T_nonneg n), Real.norm_of_nonneg (by positivity)]
  induction n using Nat.strongInductionOn with
  | ind n h_ind =>
    have b_mul_nâ‚€_le_ri i : âŒŠb' * â†‘nâ‚€âŒ‹â‚Š â‰¤ r i n := by
      exact_mod_cast calc âŒŠb' * (nâ‚€ : â„)âŒ‹â‚Š â‰¤ b' * nâ‚€      := Nat.floor_le <| by positivity
                                  _ â‰¤ b' * n        := by gcongr
                                  _ â‰¤ r i n      := h_bi_le_r n hn i
    have g_pos : 0 â‰¤ g n := R.g_nonneg n (by positivity)
    calc
      T n = (âˆ‘ i, a i * T (r i n)) + g n := by exact R.h_rec n <| nâ‚€_ge_Rnâ‚€.trans hn
        _ â‰¤ (âˆ‘ i, a i * (C * ((1 - Îµ (r i n)) * asympBound g a b (r i n)))) + g n := by
            gcongr (âˆ‘ i, a i * ?_) + g n with i _
            Â· exact le_of_lt <| R.a_pos _
            Â· if ri_lt_nâ‚€ : r i n < nâ‚€ then
                exact h_base _ <| by aesop
              else
                push_neg at ri_lt_nâ‚€
                exact h_ind (r i n) (R.r_lt_n _ _ (nâ‚€_ge_Rnâ‚€.trans hn)) ri_lt_nâ‚€
                  (h_asympBound_r_pos _ hn _) (h_smoothing_r_pos n hn i)
        _ = (âˆ‘ i, a i * (C * ((1 - Îµ (r i n)) * ((r i n) ^ (p a b)
                * (1 + (âˆ‘ u in range (r i n), g u / u ^ ((p a b) + 1))))))) + g n := by
            simp_rw [asympBound_def']
        _ = (âˆ‘ i, C * a i * ((r i n) ^ (p a b) * (1 - Îµ (r i n))
                * ((1 + (âˆ‘ u in range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by
            congr; ext; ring
        _ â‰¤ (âˆ‘ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n)
                * ((1 + (âˆ‘ u in range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by
            gcongr (âˆ‘ i, C * a i * (?_
                * ((1 + (âˆ‘ u in range (r i n), g u / u ^ ((p a b) + 1)))))) + g n with i
            Â· have := R.a_pos i
              positivity
            Â· refine add_nonneg zero_le_one <| Finset.sum_nonneg fun j _ => ?_
              rw [div_nonneg_iff]
              exact Or.inl âŸ¨R.g_nonneg j (by positivity), by positivityâŸ©
            Â· exact bound1 n hn i
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n)
                * ((1 + ((âˆ‘ u in range n, g u / u ^ ((p a b) + 1))
                - (âˆ‘ u in Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))) + g n := by
            congr; ext i; congr
            apply eq_sub_of_add_eq
            rw [add_comm]
            exact add_eq_of_eq_sub <| Finset.sum_Ico_eq_sub _
              <| le_of_lt <| R.r_lt_n i n <| nâ‚€_ge_Rnâ‚€.trans hn
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n) * ((n ^ (p a b)
                * (1 + (âˆ‘ u in range n, g u / u ^ ((p a b) + 1)))
                - n ^ (p a b) * (âˆ‘ u in Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))
                + g n := by
            congr; ext; ring
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n)
                * ((asympBound g a b n - sumTransform (p a b) g (r i n) n)))) + g n := by
            simp_rw [asympBound_def', sumTransform_def]
        _ â‰¤ (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n)
                * ((asympBound g a b n - câ‚ * g n)))) + g n := by
            gcongr with i
            Â· have := R.a_pos i
              positivity
            Â· have := R.b_pos i
              positivity
            Â· exact h_sumTransform n hn i
        _ = (âˆ‘ i, C * (1 - Îµ n) * ((asympBound g a b n - câ‚ * g n))
                * (a i * (b i) ^ (p a b))) + g n := by
            congr; ext; ring
        _ = C * (1 - Îµ n) * (asympBound g a b n - câ‚ * g n) + g n := by
            rw [â† Finset.mul_sum, R.sumCoeffsExp_p_eq_one, mul_one]
        _ = C * (1 - Îµ n) * asympBound g a b n + (1 - C * câ‚ * (1 - Îµ n)) * g n := by ring
        _ â‰¤ C * (1 - Îµ n) * asympBound g a b n + 0 := by
            gcongr
            refine mul_nonpos_of_nonpos_of_nonneg ?_ g_pos
            rw [sub_nonpos]
            calc 1 â‰¤ 2 * (câ‚â»Â¹ * câ‚) * (1/2) := by
                    rw [inv_mul_cancel (by positivity : câ‚ â‰  0)]; norm_num
                 _ = (2 * câ‚â»Â¹) * câ‚ * (1/2) := by ring
                 _ â‰¤ C * câ‚ * (1 - Îµ n) := by gcongr
                                              Â· rw [hC]; exact le_max_left _ _
                                              Â· exact le_of_lt <| h_smoothing_gt_half n hn
        _ = C * ((1 - Îµ n) * asympBound g a b n) := by ring","error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information","lemma T_isBigO_smoothingFn_mul_asympBound :
    T =O[atTop] (fun n => (1 - Îµ n) * asympBound g a b n) ",":= by
  let b' := b (min_bi b) / 2
  have hb_pos : 0 < b' := R.bi_min_div_two_pos
  rw [isBigO_atTop_iff_eventually_exists]
  obtain âŸ¨câ‚, hcâ‚, h_sumTransform_auxâŸ© := R.eventually_atTop_sumTransform_ge
  filter_upwards [eventually_ge_atTop R.nâ‚€,       
      eventually_forall_ge_atTop.mpr eventually_one_sub_smoothingFn_pos,    
      eventually_forall_ge_atTop.mpr
        <| eventually_one_sub_smoothingFn_gt_const (1/2) (by norm_num),    
      eventually_forall_ge_atTop.mpr R.eventually_asympBound_pos,            
      eventually_forall_ge_atTop.mpr R.eventually_asympBound_r_pos,          
      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop
        R.eventually_asympBound_pos,   
      eventually_gt_atTop 0,                                                
      eventually_forall_ge_atTop.mpr R.eventually_one_sub_smoothingFn_r_pos,  
      eventually_forall_ge_atTop.mpr R.rpow_p_mul_one_sub_smoothingFn_le,    
      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop
        eventually_one_sub_smoothingFn_pos,   
      eventually_forall_ge_atTop.mpr h_sumTransform_aux,                     
      eventually_forall_ge_atTop.mpr R.eventually_bi_mul_le_r]               
    with nâ‚€ nâ‚€_ge_Rnâ‚€ h_smoothing_pos h_smoothing_gt_half
      h_asympBound_pos h_asympBound_r_pos h_asympBound_floor nâ‚€_pos h_smoothing_r_pos
      bound1 h_smoothingFn_floor h_sumTransform h_bi_le_r
  have h_base_nonempty := R.base_nonempty nâ‚€_pos
  let base_max : â„ :=
    (Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€).sup' h_base_nonempty
      fun n => T n / ((1 - Îµ n) * asympBound g a b n)
  set C := max (2 * câ‚â»Â¹) base_max with hC
  refine âŸ¨C, fun n hn => ?_âŸ©
  have h_base : âˆ€ n âˆˆ Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€, T n â‰¤ C * ((1 - Îµ n) * asympBound g a b n) := by
    intro n hn
    rw [Finset.mem_Ico] at hn
    have htmp1 : 0 < 1 - Îµ n := h_smoothingFn_floor n hn.1
    have htmp2 : 0 < asympBound g a b n := h_asympBound_floor n hn.1
    rw [â† _root_.div_le_iff (by positivity)]
    rw [â† Finset.mem_Ico] at hn
    calc T n / ((1 - Îµ â†‘n) * asympBound g a b n)
           â‰¤ (Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€).sup' h_base_nonempty
                (fun z => T z / ((1 - Îµ z) * asympBound g a b z)) :=
                  Finset.le_sup'_of_le _ (b := n) hn le_rfl
         _ â‰¤ C := le_max_right _ _
  have h_asympBound_pos' : 0 < asympBound g a b n := h_asympBound_pos n hn
  have h_one_sub_smoothingFn_pos' : 0 < 1 - Îµ n := h_smoothing_pos n hn
  rw [Real.norm_of_nonneg (R.T_nonneg n), Real.norm_of_nonneg (by positivity)]
  induction n using Nat.strongInductionOn with
  | ind n h_ind =>
    have b_mul_nâ‚€_le_ri i : âŒŠb' * â†‘nâ‚€âŒ‹â‚Š â‰¤ r i n := by
      exact_mod_cast calc âŒŠb' * (nâ‚€ : â„)âŒ‹â‚Š â‰¤ b' * nâ‚€      := Nat.floor_le <| by positivity
                                  _ â‰¤ b' * n        := by gcongr
                                  _ â‰¤ r i n      := h_bi_le_r n hn i
    have g_pos : 0 â‰¤ g n := R.g_nonneg n (by positivity)
    calc
      T n = (âˆ‘ i, a i * T (r i n)) + g n := by exact R.h_rec n <| nâ‚€_ge_Rnâ‚€.trans hn
        _ â‰¤ (âˆ‘ i, a i * (C * ((1 - Îµ (r i n)) * asympBound g a b (r i n)))) + g n := by
            gcongr (âˆ‘ i, a i * ?_) + g n with i _
            Â· exact le_of_lt <| R.a_pos _
            Â· if ri_lt_nâ‚€ : r i n < nâ‚€ then
                exact h_base _ <| by
                  simp_all only [gt_iff_lt, Nat.ofNat_pos, div_pos_iff_of_pos_right,
                    eventually_atTop, ge_iff_le, sub_pos, one_div, mem_Ico, and_imp,
                    forall_true_left, mem_univ, and_self, b', C, base_max]
              else
                push_neg at ri_lt_nâ‚€
                exact h_ind (r i n) (R.r_lt_n _ _ (nâ‚€_ge_Rnâ‚€.trans hn)) ri_lt_nâ‚€
                  (h_asympBound_r_pos _ hn _) (h_smoothing_r_pos n hn i)
        _ = (âˆ‘ i, a i * (C * ((1 - Îµ (r i n)) * ((r i n) ^ (p a b)
                * (1 + (âˆ‘ u âˆˆ range (r i n), g u / u ^ ((p a b) + 1))))))) + g n := by
            simp_rw [asympBound_def']
        _ = (âˆ‘ i, C * a i * ((r i n) ^ (p a b) * (1 - Îµ (r i n))
                * ((1 + (âˆ‘ u âˆˆ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by
            congr; ext; ring
        _ â‰¤ (âˆ‘ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n)
                * ((1 + (âˆ‘ u âˆˆ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by
            gcongr (âˆ‘ i, C * a i * (?_
                * ((1 + (âˆ‘ u âˆˆ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n with i
            Â· have := R.a_pos i
              positivity
            Â· refine add_nonneg zero_le_one <| Finset.sum_nonneg fun j _ => ?_
              rw [div_nonneg_iff]
              exact Or.inl âŸ¨R.g_nonneg j (by positivity), by positivityâŸ©
            Â· exact bound1 n hn i
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n)
                * ((1 + ((âˆ‘ u âˆˆ range n, g u / u ^ ((p a b) + 1))
                - (âˆ‘ u âˆˆ Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))) + g n := by
            congr; ext i; congr
            refine eq_sub_of_add_eq ?_
            rw [add_comm]
            exact add_eq_of_eq_sub <| Finset.sum_Ico_eq_sub _
              <| le_of_lt <| R.r_lt_n i n <| nâ‚€_ge_Rnâ‚€.trans hn
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n) * ((n ^ (p a b)
                * (1 + (âˆ‘ u âˆˆ range n, g u / u ^ ((p a b) + 1)))
                - n ^ (p a b) * (âˆ‘ u âˆˆ Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))
                + g n := by
            congr; ext; ring
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n)
                * ((asympBound g a b n - sumTransform (p a b) g (r i n) n)))) + g n := by
            simp_rw [asympBound_def', sumTransform_def]
        _ â‰¤ (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n)
                * ((asympBound g a b n - câ‚ * g n)))) + g n := by
            gcongr with i
            Â· have := R.a_pos i
              positivity
            Â· have := R.b_pos i
              positivity
            Â· exact h_sumTransform n hn i
        _ = (âˆ‘ i, C * (1 - Îµ n) * ((asympBound g a b n - câ‚ * g n))
                * (a i * (b i) ^ (p a b))) + g n := by
            congr; ext; ring
        _ = C * (1 - Îµ n) * (asympBound g a b n - câ‚ * g n) + g n := by
            rw [â† Finset.mul_sum, R.sumCoeffsExp_p_eq_one, mul_one]
        _ = C * (1 - Îµ n) * asympBound g a b n + (1 - C * câ‚ * (1 - Îµ n)) * g n := by ring
        _ â‰¤ C * (1 - Îµ n) * asympBound g a b n + 0 := by
            gcongr
            refine mul_nonpos_of_nonpos_of_nonneg ?_ g_pos
            rw [sub_nonpos]
            calc 1 â‰¤ 2 * (câ‚â»Â¹ * câ‚) * (1/2) := by
                    rw [inv_mul_cancel (by positivity : câ‚ â‰  0)]; norm_num
                 _ = (2 * câ‚â»Â¹) * câ‚ * (1/2) := by ring
                 _ â‰¤ C * câ‚ * (1 - Îµ n) := by gcongr
                                              Â· rw [hC]; exact le_max_left _ _
                                              Â· exact le_of_lt <| h_smoothing_gt_half n hn
        _ = C * ((1 - Îµ n) * asympBound g a b n) := by ring",refine T_isBigO_smoothingFn_mul_asympBound.isBigO_smoothingFn_mul_asympBound ?_
Mathlib/Analysis/NormedSpace/Dual.lean,NormedSpace.norm_le_dual_bound,norm_le_dual_bound,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  classical
    by_cases h : x = 0
    Â· simp only [h, hMp, norm_zero]
    Â· obtain âŸ¨f, hfâ‚, hfxâŸ© : âˆƒ f : E â†’L[ğ•œ] ğ•œ, â€–fâ€– = 1 âˆ§ f x = â€–xâ€– := exists_dual_vector ğ•œ x h
      calc
        â€–xâ€– = â€–(â€–xâ€– : ğ•œ)â€– := IsROrC.norm_coe_norm.symm
        _ = â€–f xâ€– := by rw [hfx]
        _ â‰¤ M * â€–fâ€– := (hM f)
        _ = M := by rw [hfâ‚, mul_one]",error:  unknown identifier 'IsROrC.norm_coe_norm.symm',"theorem norm_le_dual_bound (x : E) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ f : Dual ğ•œ E, â€–f xâ€– â‰¤ M * â€–fâ€–) :
    â€–xâ€– â‰¤ M ",":= by
  classical
    by_cases h : x = 0
    Â· simp only [h, hMp, norm_zero]
    Â· obtain âŸ¨f, hfâ‚, hfxâŸ© : âˆƒ f : E â†’L[ğ•œ] ğ•œ, â€–fâ€– = 1 âˆ§ f x = â€–xâ€– := exists_dual_vector ğ•œ x h
      calc
        â€–xâ€– = â€–(â€–xâ€– : ğ•œ)â€– := RCLike.norm_coe_norm.symm
        _ = â€–f xâ€– := by rw [hfx]
        _ â‰¤ M * â€–fâ€– := hM f
        _ = M := by rw [hfâ‚, mul_one]",refine theorem_le_dual_bound_aux norm_le_dual_bound x hMp x hM f fun f hf => ?_
Mathlib/Analysis/Calculus/LocalExtr/Basic.lean,IsLocalMaxOn.hasFDerivWithinAt_nonpos,IsLocalMaxOn.hasFDerivWithinAt_nonpos,161c69c1dbf66cf3c7ec4f648a61551d044a43e4,":= by
  rcases hy with âŸ¨c, d, hd, hc, hcdâŸ©
  have hc' : Tendsto (â€–c Â·â€–) atTop atTop := tendsto_abs_atTop_atTop.comp hc
  suffices : âˆ€á¶  n in atTop, c n â€¢ (f (a + d n) - f a) â‰¤ 0
  Â· exact le_of_tendsto (hf.lim atTop hd hc' hcd) this
  replace hd : Tendsto (fun n => a + d n) atTop (ğ“[s] (a + 0))
  Â· exact tendsto_nhdsWithin_iff.2 âŸ¨tendsto_const_nhds.add (tangentConeAt.lim_zero _ hc' hcd), hdâŸ©
  rw [add_zero] at hd
  filter_upwards [hd.eventually h, hc.eventually_ge_atTop 0] with n hfn hcn
  exact mul_nonpos_of_nonneg_of_nonpos hcn (sub_nonpos.2 hfn)",error:  unexpected token ':'; expected term,"theorem IsLocalMaxOn.hasFDerivWithinAt_nonpos {s : Set E} (h : IsLocalMaxOn f s a)
    (hf : HasFDerivWithinAt f f' s a) {y} (hy : y âˆˆ posTangentConeAt s a) : f' y â‰¤ 0 ",":= by
  rcases hy with âŸ¨c, d, hd, hc, hcdâŸ©
  have hc' : Tendsto (â€–c Â·â€–) atTop atTop := tendsto_abs_atTop_atTop.comp hc
  suffices âˆ€á¶  n in atTop, c n â€¢ (f (a + d n) - f a) â‰¤ 0 from
    le_of_tendsto (hf.lim atTop hd hc' hcd) this
  replace hd : Tendsto (fun n => a + d n) atTop (ğ“[s] (a + 0)) :=
    tendsto_nhdsWithin_iff.2 âŸ¨tendsto_const_nhds.add (tangentConeAt.lim_zero _ hc' hcd), hdâŸ©
  rw [add_zero] at hd
  filter_upwards [hd.eventually h, hc.eventually_ge_atTop 0] with n hfn hcn
  exact mul_nonpos_of_nonneg_of_nonpos hcn (sub_nonpos.2 hfn)","simp only [posTangentConeAt, mem_posTangentConeAt] at hy"
Mathlib/CategoryTheory/Monoidal/Bimod.lean,Bimod.LeftUnitorBimod.hom_inv_id,hom_inv_id,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  dsimp [hom, homAux, inv, invAux]
  apply coequalizer.hom_ext
  slice_lhs 1 2 => rw [coequalizer.Ï€_desc]
  refine' (cancel_epi ((tensorRight _).map (coequalizer.Ï€ _ _))).1 _
  rw [tensorRight_map]
  slice_lhs 1 3 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]
  slice_lhs 3 4 => rw [coequalizer.Ï€_desc]
  slice_lhs 2 4 => rw [id_tensor_Ï€_preserves_coequalizer_inv_desc]
  slice_lhs 1 3 => rw [Iso.hom_inv_id_assoc]
  dsimp only [TensorBimod.X]
  slice_rhs 2 3 => rw [Category.comp_id]","error:  unsolved goals
case h
C : Type uâ‚
instâœâ´ : Category.{vâ‚, uâ‚} C
instâœÂ³ : MonoidalCategory C
A B : Mon_ C
M : Bimod A B
instâœÂ² : HasCoequalizers C
instâœÂ¹ : (X : C) â†’ PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (tensorLeft X)
instâœ : (X : C) â†’ PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (tensorRight X)
R S T U : Mon_ C
P : Bimod R S
Q : Bimod S T
L : Bimod T U
âŠ¢ coequalizer.Ï€ (P.actRight â–· Q.X) ((Î±_ P.X S.X Q.X).hom â‰« P.X â— Q.actLeft) â–· L.X â‰«
      coequalizer.Ï€ (TensorBimod.actRight P Q â–· L.X)
        ((Î±_ (coequalizer (P.actRight â–· Q.X) ((Î±_ P.X S.X Q.X).hom â‰« P.X â— Q.actLeft)) T.X L.X).hom â‰«
          coequalizer (P.actRight â–· Q.X) ((Î±_ P.X S.X Q.X).hom â‰« P.X â— Q.actLeft) â— L.actLeft) =
    coequalizer.Ï€ (P.actRight â–· Q.X) ((Î±_ P.X S.X Q.X).hom â‰« P.X â— Q.actLeft) â–· L.X â‰«
      coequalizer.Ï€ ((P.tensorBimod Q).actRight â–· L.X)
        ((Î±_ (P.tensorBimod Q).X T.X L.X).hom â‰« (P.tensorBimod Q).X â— L.actLeft)",theorem hom_inv_id : hom P Q L â‰« inv P Q L = ğŸ™ _ ,":= by
  dsimp [hom, homAux, inv, invAux]
  apply coequalizer.hom_ext
  slice_lhs 1 2 => rw [coequalizer.Ï€_desc]
  refine (cancel_epi ((tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_
  rw [tensorRight_map]
  slice_lhs 1 3 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]
  slice_lhs 3 4 => rw [coequalizer.Ï€_desc]
  slice_lhs 2 4 => rw [id_tensor_Ï€_preserves_coequalizer_inv_desc]
  slice_lhs 1 3 => rw [Iso.hom_inv_id_assoc]
  dsimp only [TensorBimod.X]
  slice_rhs 2 3 => rw [Category.comp_id]
  rfl","simp [inv, hom_inv_id]"
Mathlib/FieldTheory/NormalClosure.lean,Algebra.IsAlgebraic.normalClosure_le_iSup_adjoin,normalClosure_le_iSup_adjoin,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  iSup_le fun f _ âŸ¨x, hxâŸ© â†¦ le_iSup (Î± := IntermediateField F L) _ x <|
    IntermediateField.subset_adjoin F _ <| by
      rw [mem_rootSet_of_ne (minpoly.ne_zero <| isAlgebraic_iff_isIntegral.mp <| alg x), â† hx,
        AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom, aeval_algHom_apply, minpoly.aeval, map_zero]",error:  unknown identifier 'alg',"lemma normalClosure_le_iSup_adjoin :
    normalClosure F K L â‰¤ â¨† x : K, IntermediateField.adjoin F ((minpoly F x).rootSet L) ",":=
  iSup_le fun f _ âŸ¨x, hxâŸ© â†¦ le_iSup (Î± := IntermediateField F L) _ x <|
    IntermediateField.subset_adjoin F _ <| by
      rw [mem_rootSet_of_ne (minpoly.ne_zero (Algebra.IsIntegral.isIntegral x)), â† hx,
        AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom, aeval_algHom_apply, minpoly.aeval, map_zero]","rw [â† IntermediateField.adjoin_rootSet, â† IntermediateField.adjoin_rootSet]"
Mathlib/Algebra/BigOperators/Group/Multiset.lean,Multiset.prod_nat_mod,prod_nat_mod,c959b2f950b9c44268e36bcedef976356855e6fb,":= by
  induction s <;> simp [Nat.mul_mod, *]","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
F : Type u_1
Î¹ : Type u_2
Î± : Type u_3
Î² : Type u_4
Î³ : Type u_5
s : Multiset â„•
n : â„•
âŠ¢ s.prod % n = (map (fun x â†¦ x % n) s).prod % n",theorem prod_nat_mod (s : Multiset â„•) (n : â„•) : s.prod % n = (s.map (Â· % n)).prod % n ,":= by
  induction s using Multiset.induction <;> simp [Nat.mul_mod, *]","rw [Multiset.map_eq_map, Multiset.map_map, Multiset.map_mod, Multiset.prod_map_mod_mod]"
Mathlib/Analysis/Analytic/Composition.lean,FormalMultilinearSeries.applyComposition_update,applyComposition_update,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  ext k
  by_cases h : k = c.index j
  Â· rw [h]
    let r : Fin (c.blocksFun (c.index j)) â†’ Fin n := c.embedding (c.index j)
    simp only [Function.update_same]
    change p (c.blocksFun (c.index j)) (Function.update v j z âˆ˜ r) = _
    let j' := c.invEmbedding j
    suffices B : Function.update v j z âˆ˜ r = Function.update (v âˆ˜ r) j' z by rw [B]
    suffices C : Function.update v (r j') z âˆ˜ r = Function.update (v âˆ˜ r) j' z by
      convert C; exact (c.embedding_comp_inv j).symm
    exact Function.update_comp_eq_of_injective _ (c.embedding _).injective _ _
  Â· simp only [h, Function.update_eq_self, Function.update_noteq, Ne.def, not_false_iff]
    let r : Fin (c.blocksFun k) â†’ Fin n := c.embedding k
    change p (c.blocksFun k) (Function.update v j z âˆ˜ r) = p (c.blocksFun k) (v âˆ˜ r)
    suffices B : Function.update v j z âˆ˜ r = v âˆ˜ r by rw [B]
    apply Function.update_comp_eq_of_not_mem_range
    rwa [c.mem_range_embedding_iff']","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.80747 â†’ ?m.80747 â†’ Prop
error:  type mismatch
  this
has type
  (p (c.blocksFun k)) (Function.update v j z âˆ˜ r) = (p (c.blocksFun k)) (v âˆ˜ r) : Prop
but is expected to have type
  p.applyComposition c (Function.update v j z) k =
    Function.update (p.applyComposition c v) (c.index j)
      ((p (c.blocksFun (c.index j))) (Function.update (v âˆ˜ â‡‘(c.embedding (c.index j))) (c.invEmbedding j) z)) k : Prop
warning:  `List.get_splitWrtComposition` has been deprecated, use `List.getElem_splitWrtComposition` instead
warning:  `List.get_drop'` has been deprecated, use `List.getElem_drop'` instead
warning:  `List.get_take'` has been deprecated, use `List.getElem_take` instead","theorem applyComposition_update (p : FormalMultilinearSeries ğ•œ E F) {n : â„•} (c : Composition n)
    (j : Fin n) (v : Fin n â†’ E) (z : E) :
    p.applyComposition c (Function.update v j z) =
      Function.update (p.applyComposition c v) (c.index j)
        (p (c.blocksFun (c.index j))
          (Function.update (v âˆ˜ c.embedding (c.index j)) (c.invEmbedding j) z)) ",":= by
  ext k
  by_cases h : k = c.index j
  Â· rw [h]
    let r : Fin (c.blocksFun (c.index j)) â†’ Fin n := c.embedding (c.index j)
    simp only [Function.update_same]
    change p (c.blocksFun (c.index j)) (Function.update v j z âˆ˜ r) = _
    let j' := c.invEmbedding j
    suffices B : Function.update v j z âˆ˜ r = Function.update (v âˆ˜ r) j' z by rw [B]
    suffices C : Function.update v (r j') z âˆ˜ r = Function.update (v âˆ˜ r) j' z by
      convert C; exact (c.embedding_comp_inv j).symm
    exact Function.update_comp_eq_of_injective _ (c.embedding _).injective _ _
  Â· simp only [h, Function.update_eq_self, Function.update_noteq, Ne, not_false_iff]
    let r : Fin (c.blocksFun k) â†’ Fin n := c.embedding k
    change p (c.blocksFun k) (Function.update v j z âˆ˜ r) = p (c.blocksFun k) (v âˆ˜ r)
    suffices B : Function.update v j z âˆ˜ r = v âˆ˜ r by rw [B]
    apply Function.update_comp_eq_of_not_mem_range
    rwa [c.mem_range_embedding_iff']","simp only [Function.update_same, Function.update_same, Function.update_same, Function.update_same]"
Mathlib/CategoryTheory/Triangulated/HomologicalFunctor.lean,CategoryTheory.Functor.IsHomological.of_iso,IsHomological.of_iso,660d4d5e85504851f32fdcb363260a8048d0609c,"  exact T hT := ShortComplex.exact_of_iso (ShortComplex.mapNatIso _ e)
    (Fâ‚.map_distinguished_exact T hT)","error:  function expected at
  Fâ‚‚.IsHomological
term has type
  Prop
error:  failed to synthesize
  Fâ‚‚.PreservesZeroMorphisms
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'T'
error:  unknown identifier 'hT'
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsHomological
has type
  ?m.36715 â¥¤ ?m.36716 â†’ Prop","lemma IsHomological.of_iso {Fâ‚ Fâ‚‚ : C â¥¤ A} [Fâ‚.IsHomological] (e : Fâ‚ â‰… Fâ‚‚) :
    Fâ‚‚.IsHomological ",":=
  have := preservesZeroMorphisms_of_iso e
  âŸ¨fun T hT => ShortComplex.exact_of_iso (ShortComplex.mapNatIso _ e)
    (Fâ‚.map_distinguished_exact T hT)âŸ©",dsimp [IsHomological.of_isHomological]
Mathlib/Topology/Algebra/UniformRing.lean,UniformSpace.Completion.Continuous.mul,Continuous.mul,54d2d04a76999eff29e8b39b03fa3d5fc19ac0e3,":=
  hf.mul hg","error:  failed to synthesize
  ContinuousMul (Completion Î±)
use `set_option diagnostics true` to get diagnostic information","theorem Continuous.mul {Î² : Type*} [TopologicalSpace Î²] {f g : Î² â†’ Completion Î±}
    (hf : Continuous f) (hg : Continuous g) : Continuous fun b => f b * g b ",":=
  Continuous.comp continuous_mul (Continuous.prod_mk hf hg : _)",rw [continuous_iff_continuousOn_univ]
Mathlib/Analysis/NormedSpace/Star/GelfandDuality.lean,gelfandTransform_isometry,gelfandTransform_isometry,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  nontriviality A
  refine' AddMonoidHomClass.isometry_of_norm (gelfandTransform â„‚ A) fun a => _
  have : spectralRadius â„‚ (gelfandTransform â„‚ A (star a * a)) = spectralRadius â„‚ (star a * a) := by
    unfold spectralRadius; rw [spectrum.gelfandTransform_eq]
  rw [map_mul, (IsSelfAdjoint.star_mul_self _).spectralRadius_eq_nnnorm, gelfandTransform_map_star,
    (IsSelfAdjoint.star_mul_self (gelfandTransform â„‚ A a)).spectralRadius_eq_nnnorm] at this
  simp only [ENNReal.coe_eq_coe, CstarRing.nnnorm_star_mul_self, â† sq] at this
  simpa only [Function.comp_apply, NNReal.sqrt_sq] using
    congr_arg (((â†‘) : â„â‰¥0 â†’ â„) âˆ˜ â‡‘NNReal.sqrt) this","error:  unknown constant 'ENNReal.coe_eq_coe'
error:  application type mismatch
  congr_arg (NNReal.toReal âˆ˜ â‡‘NNReal.sqrt) this
argument
  this
has type
  â†‘(â€–(gelfandTransform â„‚ A) aâ€–â‚Š ^ 2) = â†‘(â€–aâ€–â‚Š ^ 2) : Prop
but is expected to have type
  ?m.47279 = ?m.47280 : Prop",theorem gelfandTransform_isometry : Isometry (gelfandTransform â„‚ A) ,":= by
  nontriviality A
  refine AddMonoidHomClass.isometry_of_norm (gelfandTransform â„‚ A) fun a => ?_
  have : spectralRadius â„‚ (gelfandTransform â„‚ A (star a * a)) = spectralRadius â„‚ (star a * a) := by
    unfold spectralRadius; rw [spectrum.gelfandTransform_eq]
  rw [map_mul, (IsSelfAdjoint.star_mul_self a).spectralRadius_eq_nnnorm, gelfandTransform_map_star,
    (IsSelfAdjoint.star_mul_self (gelfandTransform â„‚ A a)).spectralRadius_eq_nnnorm] at this
  simp only [ENNReal.coe_inj, CstarRing.nnnorm_star_mul_self, â† sq] at this
  simpa only [Function.comp_apply, NNReal.sqrt_sq] using
    congr_arg (((â†‘) : â„â‰¥0 â†’ â„) âˆ˜ â‡‘NNReal.sqrt) this",rw [isometry_iff_isometry_of_isometry gelfandTransform_isometry gelfandTransform_isometry]
Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean,Real.map_linearMap_volume_pi_eq_smul_volume_pi,map_linearMap_volume_pi_eq_smul_volume_pi,4b292e8968c43193b3dbd022dfbc7ddc03b3a7a8,":= by
  classical
    let M := LinearMap.toMatrix' f
    have A : LinearMap.det f = det M := by simp only [LinearMap.det_toMatrix']
    have B : f = toLin' M := by simp only [toLin'_toMatrix']
    rw [A, B]
    apply map_matrix_volume_pi_eq_smul_volume_pi
    rwa [A] at hf","error:  simp made no progress
error:  simp made no progress","theorem map_linearMap_volume_pi_eq_smul_volume_pi {f : (Î¹ â†’ â„) â†’â‚—[â„] Î¹ â†’ â„}
    (hf : LinearMap.det f â‰  0) : Measure.map f volume =
      ENNReal.ofReal (abs (LinearMap.det f)â»Â¹) â€¢ volume ",":= by
  classical
    let M := LinearMap.toMatrix' f
    have A : LinearMap.det f = det M := by simp only [M, LinearMap.det_toMatrix']
    have B : f = toLin' M := by simp only [M, toLin'_toMatrix']
    rw [A, B]
    apply map_matrix_volume_pi_eq_smul_volume_pi
    rwa [A] at hf","simp only [LinearMap.det_eq_det_theorem, hf, ENNReal.ofReal_one, ENNReal.ofReal_smul,
  ENNReal.ofReal_ofReal (abs (LinearMap.det f)â»Â¹),
  ENNReal.ofReal_ofReal (abs (LinearMap.det f)â»Â¹)]"
Mathlib/Analysis/Seminorm.lean,Seminorm.balanced_ball_zero,balanced_ball_zero,0bc9e28b50593c968afd9e45b23586cbdd0008e0,":= by
  rintro a ha x âŸ¨y, hy, hxâŸ©
  rw [mem_ball_zero, â† hx, map_smul_eq_mul]
  calc
    _ â‰¤ p y := mul_le_of_le_one_left (map_nonneg p _) ha
    _ < r := by rwa [mem_ball_zero] at hy","error:  failed to synthesize
  Preorder E
use `set_option diagnostics true` to get diagnostic information",theorem balanced_ball_zero (r : â„) : Balanced ğ•œ (ball p 0 r) ,":= by
  rintro a ha x âŸ¨y, hy, hxâŸ©
  rw [mem_ball_zero, â† hx, map_smul_eq_mul]
  calc
    _ â‰¤ p y := mul_le_of_le_one_left (apply_nonneg p _) ha
    _ < r := by rwa [mem_ball_zero] at hy",refine balanced_ball_zero (ball p (0 : â„) r) ?_
Mathlib/NumberTheory/Bertrand.lean,bertrand_main_inequality,bertrand_main_inequality,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  rw [â† @cast_le â„]
  simp only [cast_add, cast_one, cast_mul, cast_pow, â† Real.rpow_nat_cast]
  have n_pos : 0 < n := (by decide : 0 < 512).trans_le n_large
  have n2_pos : 1 â‰¤ 2 * n := mul_pos (by decide) n_pos
  refine' _root_.trans (mul_le_mul _ _ _ _)
      (Bertrand.real_main_inequality (by exact_mod_cast n_large))
  Â· refine' mul_le_mul_of_nonneg_left _ (Nat.cast_nonneg _)
    refine' Real.rpow_le_rpow_of_exponent_le (by exact_mod_cast n2_pos) _
    exact_mod_cast Real.nat_sqrt_le_real_sqrt
  Â· exact Real.rpow_le_rpow_of_exponent_le (by norm_num1) (cast_div_le.trans (by norm_cast))
  Â· exact Real.rpow_nonneg_of_nonneg (by norm_num1) _
  Â· refine' mul_nonneg (Nat.cast_nonneg _) _
    exact Real.rpow_nonneg_of_nonneg (mul_nonneg zero_le_two (Nat.cast_nonneg _)) _","warning:  `Real.rpow_nat_cast` has been deprecated, use `Real.rpow_natCast` instead
error:  unknown constant 'Real.rpow_nonneg_of_nonneg'
error:  unknown constant 'Real.rpow_nonneg_of_nonneg'","theorem bertrand_main_inequality {n : â„•} (n_large : 512 â‰¤ n) :
    n * (2 * n) ^ sqrt (2 * n) * 4 ^ (2 * n / 3) â‰¤ 4 ^ n ",":= by
  rw [â† @cast_le â„]
  simp only [cast_add, cast_one, cast_mul, cast_pow, â† Real.rpow_natCast]
  refine _root_.trans ?_ (Bertrand.real_main_inequality (by exact_mod_cast n_large))
  gcongr
  Â· have n2_pos : 0 < 2 * n := by positivity
    exact mod_cast n2_pos
  Â· exact_mod_cast Real.nat_sqrt_le_real_sqrt
  Â· norm_num1
  Â· exact cast_div_le.trans (by norm_cast)",rw [bertrand_main_inequality]
Mathlib/MeasureTheory/Integral/Bochner.lean,MeasureTheory.L1.integral_eq_norm_posPart_sub,integral_eq_norm_posPart_sub,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have ae_eqâ‚ : (toSimpleFunc f).posPart =áµ[Î¼] (toSimpleFunc (posPart f)).map norm := by
    filter_upwards [posPart_toSimpleFunc f] with _ h
    rw [SimpleFunc.map_apply, h]
    conv_lhs => rw [â† SimpleFunc.posPart_map_norm, SimpleFunc.map_apply]
  have ae_eqâ‚‚ : (toSimpleFunc f).negPart =áµ[Î¼] (toSimpleFunc (negPart f)).map norm := by
    filter_upwards [negPart_toSimpleFunc f] with _ h
    rw [SimpleFunc.map_apply, h]
    conv_lhs => rw [â† SimpleFunc.negPart_map_norm, SimpleFunc.map_apply]
  rw [integral, norm_eq_integral, norm_eq_integral, â† SimpleFunc.integral_sub]
  Â· show (toSimpleFunc f).integral Î¼ =
      ((toSimpleFunc (posPart f)).map norm - (toSimpleFunc (negPart f)).map norm).integral Î¼
    apply MeasureTheory.SimpleFunc.integral_congr (SimpleFunc.integrable f)
    filter_upwards [ae_eqâ‚, ae_eqâ‚‚] with _ hâ‚ hâ‚‚
    show _ = _ - _
    rw [â† hâ‚, â† hâ‚‚]
    have := (toSimpleFunc f).posPart_sub_negPart
    conv_lhs => rw [â† this]
  Â· exact (SimpleFunc.integrable f).pos_part.congr ae_eqâ‚
  Â· exact (SimpleFunc.integrable f).neg_part.congr ae_eqâ‚‚","error:  unsolved goals
case h
Î± : Type u_1
E : Type u_2
F : Type u_3
ğ•œ : Type u_4
instâœÂ¹â° : NormedAddCommGroup E
instâœâ¹ : NormedAddCommGroup F
m : MeasurableSpace Î±
Î¼ : Measure Î±
instâœâ¸ : NormedField ğ•œ
instâœâ· : NormedSpace ğ•œ E
instâœâ¶ : NormedSpace â„ E
instâœâµ : SMulCommClass â„ ğ•œ E
F' : Type u_5
instâœâ´ : NormedAddCommGroup F'
instâœÂ³ : NormedSpace â„ F'
E' : Type u_6
instâœÂ² : NormedAddCommGroup E'
instâœÂ¹ : NormedSpace â„ E'
instâœ : NormedSpace ğ•œ E'
f : â†¥(simpleFunc â„ 1 Î¼)
ae_eqâ‚ : â†‘(toSimpleFunc f).posPart =á¶ [ae Î¼] â†‘(SimpleFunc.map norm (toSimpleFunc (posPart f)))
ae_eqâ‚‚ : â†‘(toSimpleFunc f).negPart =á¶ [ae Î¼] â†‘(SimpleFunc.map norm (toSimpleFunc (negPart f)))
aâœ : Î±
hâ‚ : â†‘(toSimpleFunc f).posPart aâœ = â†‘(SimpleFunc.map norm (toSimpleFunc (posPart f))) aâœ
hâ‚‚ : â†‘(toSimpleFunc f).negPart aâœ = â†‘(SimpleFunc.map norm (toSimpleFunc (negPart f))) aâœ
this : (toSimpleFunc f).posPart - (toSimpleFunc f).negPart = toSimpleFunc f
âŠ¢ â†‘((toSimpleFunc f).posPart - (toSimpleFunc f).negPart) aâœ =
    â†‘(toSimpleFunc f).posPart aâœ - â†‘(toSimpleFunc f).negPart aâœ
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string",theorem integral_eq_norm_posPart_sub (f : Î± â†’â‚â‚›[Î¼] â„) : integral f = â€–posPart fâ€– - â€–negPart fâ€– ,":= by
  have ae_eqâ‚ : (toSimpleFunc f).posPart =áµ[Î¼] (toSimpleFunc (posPart f)).map norm := by
    filter_upwards [posPart_toSimpleFunc f] with _ h
    rw [SimpleFunc.map_apply, h]
    conv_lhs => rw [â† SimpleFunc.posPart_map_norm, SimpleFunc.map_apply]
  have ae_eqâ‚‚ : (toSimpleFunc f).negPart =áµ[Î¼] (toSimpleFunc (negPart f)).map norm := by
    filter_upwards [negPart_toSimpleFunc f] with _ h
    rw [SimpleFunc.map_apply, h]
    conv_lhs => rw [â† SimpleFunc.negPart_map_norm, SimpleFunc.map_apply]
  rw [integral, norm_eq_integral, norm_eq_integral, â† SimpleFunc.integral_sub]
  Â· show (toSimpleFunc f).integral Î¼ =
      ((toSimpleFunc (posPart f)).map norm - (toSimpleFunc (negPart f)).map norm).integral Î¼
    apply MeasureTheory.SimpleFunc.integral_congr (SimpleFunc.integrable f)
    filter_upwards [ae_eqâ‚, ae_eqâ‚‚] with _ hâ‚ hâ‚‚
    show _ = _ - _
    rw [â† hâ‚, â† hâ‚‚]
    have := (toSimpleFunc f).posPart_sub_negPart
    conv_lhs => rw [â† this]
    rfl
  Â· exact (SimpleFunc.integrable f).pos_part.congr ae_eqâ‚
  Â· exact (SimpleFunc.integrable f).neg_part.congr ae_eqâ‚‚","simp only [integral_eq_norm_posPart_sub, integral_eq_norm_posPart_sub]"
Mathlib/SetTheory/Cardinal/Divisibility.lean,Cardinal.nat_is_prime_iff,nat_is_prime_iff,8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85,":= by
  simp only [Prime, Nat.prime_iff]
  refine and_congr (by simp) (and_congr ?_ âŸ¨fun h b c hbc => ?_, fun h b c hbc =?> _âŸ©)
  Â· simp only [isUnit_iff, Nat.isUnit_iff]
    exact mod_cast Iff.rfl
  Â· exact mod_cast h b c (mod_cast hbc)
  cases' lt_or_le (b * c) â„µâ‚€ with h' h'
  Â· rcases mul_lt_aleph0_iff.mp h' with (rfl | rfl | âŸ¨hb, hcâŸ©)
    Â· simp
    Â· simp
    lift b to â„• using hb
    lift c to â„• using hc
    exact mod_cast h b c (mod_cast hbc)
  rcases aleph0_le_mul_iff.mp h' with âŸ¨hb, hc, hâ„µâ‚€âŸ©
  have hn : (n : Cardinal) â‰  0 := by
    intro h
    rw [h, zero_dvd_iff, mul_eq_zero] at hbc
    cases hbc <;> contradiction
  wlog hâ„µâ‚€b : â„µâ‚€ â‰¤ b
  refine (this h c b ?_ ?_ hc hb hâ„µâ‚€.symm hn (hâ„µâ‚€.resolve_left hâ„µâ‚€b)).symm <;> try assumption
  Â· rwa [mul_comm] at hbc
  Â· rwa [mul_comm] at h'
  Â· exact Or.inl (dvd_of_le_of_aleph0_le hn ((nat_lt_aleph0 n).le.trans hâ„µâ‚€b) hâ„µâ‚€b)","error:  unexpected token '='; expected 'â†¦', '=>'
error:  unsolved goals
case refine_1
a b : Cardinal.{u}
n m : â„•
âŠ¢ Â¬IsUnit â†‘n â†” Â¬IsUnit n

case refine_2
a bâœ : Cardinal.{u}
n m : â„•
h : âˆ€ (a b : Cardinal.{u_1}), â†‘n âˆ£ a * b â†’ â†‘n âˆ£ a âˆ¨ â†‘n âˆ£ b
b c : â„•
hbc : n âˆ£ b * c
âŠ¢ n âˆ£ b âˆ¨ n âˆ£ c",theorem nat_is_prime_iff : Prime (n : Cardinal) â†” n.Prime ,":= by
  simp only [Prime, Nat.prime_iff]
  refine and_congr (by simp) (and_congr ?_ âŸ¨fun h b c hbc => ?_, fun h b c hbc => ?_âŸ©)
  Â· simp only [isUnit_iff, Nat.isUnit_iff]
    exact mod_cast Iff.rfl
  Â· exact mod_cast h b c (mod_cast hbc)
  cases' lt_or_le (b * c) â„µâ‚€ with h' h'
  Â· rcases mul_lt_aleph0_iff.mp h' with (rfl | rfl | âŸ¨hb, hcâŸ©)
    Â· simp
    Â· simp
    lift b to â„• using hb
    lift c to â„• using hc
    exact mod_cast h b c (mod_cast hbc)
  rcases aleph0_le_mul_iff.mp h' with âŸ¨hb, hc, hâ„µâ‚€âŸ©
  have hn : (n : Cardinal) â‰  0 := by
    intro h
    rw [h, zero_dvd_iff, mul_eq_zero] at hbc
    cases hbc <;> contradiction
  wlog hâ„µâ‚€b : â„µâ‚€ â‰¤ b
  apply (this h c b _ _ hc hb hâ„µâ‚€.symm hn (hâ„µâ‚€.resolve_left hâ„µâ‚€b)).symm <;> try assumption
  Â· rwa [mul_comm] at hbc
  Â· rwa [mul_comm] at h'
  Â· exact Or.inl (dvd_of_le_of_aleph0_le hn ((nat_lt_aleph0 n).le.trans hâ„µâ‚€b) hâ„µâ‚€b)","rw [â† nat_is_prime_iff.prime_iff, nat_is_prime_iff.prime_iff]"
Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean,MvPolynomial.weightedHomogeneousComponent_zero,weightedHomogeneousComponent_zero,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  classical
  ext1 d
  rcases Classical.em (d = 0) with (rfl | hd)
  Â· simp only [coeff_weightedHomogeneousComponent, if_pos, map_zero, coeff_zero_C]
  Â· rw [coeff_weightedHomogeneousComponent, if_neg, coeff_C, if_neg (Ne.symm hd)]
    simp only [weightedDegree', LinearMap.toAddMonoidHom_coe, Finsupp.total_apply, Finsupp.sum,
      sum_eq_zero_iff, Finsupp.mem_support_iff, Ne.def, smul_eq_zero, not_forall, not_or,
      and_self_left, exists_prop]
    simp only [DFunLike.ext_iff, Finsupp.coe_zero, Pi.zero_apply, not_forall] at hd
    obtain âŸ¨i, hiâŸ© := hd
    exact âŸ¨i, hi, hw iâŸ©","error:  unknown identifier 'weightedDegree''
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.114863 â†’ ?m.114863 â†’ Prop
error:  simp made no progress","theorem weightedHomogeneousComponent_zero [NoZeroSMulDivisors â„• M] (hw : âˆ€ i : Ïƒ, w i â‰  0) :
    weightedHomogeneousComponent w 0 Ï† = C (coeff 0 Ï†) ",":= by
  classical
  ext1 d
  rcases Classical.em (d = 0) with (rfl | hd)
  Â· simp only [coeff_weightedHomogeneousComponent, if_pos, map_zero, coeff_zero_C]
  Â· rw [coeff_weightedHomogeneousComponent, if_neg, coeff_C, if_neg (Ne.symm hd)]
    simp only [weightedDegree, LinearMap.toAddMonoidHom_coe, Finsupp.total_apply, Finsupp.sum,
      sum_eq_zero_iff, Finsupp.mem_support_iff, Ne, smul_eq_zero, not_forall, not_or,
      and_self_left, exists_prop]
    simp only [DFunLike.ext_iff, Finsupp.coe_zero, Pi.zero_apply, not_forall] at hd
    obtain âŸ¨i, hiâŸ© := hd
    exact âŸ¨i, hi, hw iâŸ©",simp [weightedHomogeneousComponent_zero]
Mathlib/RingTheory/Trace.lean,Algebra.trace_algebraMap_of_basis,trace_algebraMap_of_basis,8dba065d4a693e23ed06348923cd5effc765cb75,":= by
  haveI := Classical.decEq Î¹
  rw [trace_apply, LinearMap.trace_eq_matrix_trace R b, Matrix.trace]
  convert Finset.sum_const x
  simp only [AlgHom.commutes, toMatrix_algebraMap, diag_apply, Matrix.scalar_apply_eq]","error:  unknown constant 'Matrix.scalar_apply_eq'
error:  unsolved goals
case h.e'_2.a
R : Type u_1
S : Type u_2
T : Type u_3
instâœâ¸ : CommRing R
instâœâ· : CommRing S
instâœâ¶ : CommRing T
instâœâµ : Algebra R S
instâœâ´ : Algebra R T
K : Type u_4
L : Type u_5
instâœÂ³ : Field K
instâœÂ² : Field L
instâœÂ¹ : Algebra K L
Î¹ Îº : Type w
instâœ : Fintype Î¹
b : Basis Î¹ R S
x : R
this : DecidableEq Î¹
xâœ : Î¹
aâœ : xâœ âˆˆ Finset.univ
âŠ¢ (scalar Î¹) x xâœ xâœ = x",theorem trace_algebraMap_of_basis (x : R) : trace R S (algebraMap R S x) = Fintype.card Î¹ â€¢ x ,":= by
  haveI := Classical.decEq Î¹
  rw [trace_apply, LinearMap.trace_eq_matrix_trace R b, Matrix.trace]
  convert Finset.sum_const x
  simp [-coe_lmul_eq_mul]","rw [trace_algebraMap_of_basis, trace_algebraMap_of_basis]"
Mathlib/Analysis/Calculus/MeanValue.lean,image_le_of_liminf_slope_right_lt_deriv_boundary',image_le_of_liminf_slope_right_lt_deriv_boundary',fdcecc6431ccffb2e1ba4fe8b297b20ee9baa42b,":= by
  change Icc a b âŠ† { x | f x â‰¤ B x }
  set s := { x | f x â‰¤ B x } âˆ© Icc a b
  have A : ContinuousOn (fun x => (f x, B x)) (Icc a b) := hf.prod hB
  have : IsClosed s := by
    simp only [inter_comm]
    exact A.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  apply this.Icc_subset_of_forall_exists_gt ha
  rintro x âŸ¨hxB : f x â‰¤ B x, xabâŸ© y hy
  cases' hxB.lt_or_eq with hxB hxB
  Â· 
    refine' nonempty_of_mem (inter_mem _ (Ioc_mem_nhdsWithin_Ioi âŸ¨le_rfl, hyâŸ©))
    have : âˆ€á¶  x in ğ“[Icc a b] x, f x < B x :=
      A x (Ico_subset_Icc_self xab) (IsOpen.mem_nhds (isOpen_lt continuous_fst continuous_snd) hxB)
    have : âˆ€á¶  x in ğ“[>] x, f x < B x := nhdsWithin_le_of_mem (Icc_mem_nhdsWithin_Ioi xab) this
    exact this.mono fun y => le_of_lt
  Â· rcases exists_between (bound x xab hxB) with âŸ¨r, hfr, hrBâŸ©
    specialize hf' x xab r hfr
    have HB : âˆ€á¶  z in ğ“[>] x, r < slope B x z :=
      (hasDerivWithinAt_iff_tendsto_slope' <| lt_irrefl x).1 (hB' x xab).Ioi_of_Ici
        (Ioi_mem_nhds hrB)
    obtain âŸ¨z, hfz, hzB, hzâŸ© : âˆƒ z, slope f x z < r âˆ§ r < slope B x z âˆ§ z âˆˆ Ioc x y
    exact (hf'.and_eventually (HB.and (Ioc_mem_nhdsWithin_Ioi âŸ¨le_rfl, hyâŸ©))).exists
    refine' âŸ¨z, _, hzâŸ©
    have := (hfz.trans hzB).le
    rwa [slope_def_field, slope_def_field, div_le_div_right (sub_pos.2 hz.1), hxB,
      sub_le_sub_iff_right] at this",error:  simp made no progress,"theorem image_le_of_liminf_slope_right_lt_deriv_boundary' {f f' : â„ â†’ â„} {a b : â„}
    (hf : ContinuousOn f (Icc a b))
    (hf' : âˆ€ x âˆˆ Ico a b, âˆ€ r, f' x < r â†’ âˆƒá¶  z in ğ“[>] x, slope f x z < r)
    {B B' : â„ â†’ â„} (ha : f a â‰¤ B a) (hB : ContinuousOn B (Icc a b))
    (hB' : âˆ€ x âˆˆ Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)
    (bound : âˆ€ x âˆˆ Ico a b, f x = B x â†’ f' x < B' x) : âˆ€ â¦ƒxâ¦„, x âˆˆ Icc a b â†’ f x â‰¤ B x ",":= by
  change Icc a b âŠ† { x | f x â‰¤ B x }
  set s := { x | f x â‰¤ B x } âˆ© Icc a b
  have A : ContinuousOn (fun x => (f x, B x)) (Icc a b) := hf.prod hB
  have : IsClosed s := by
    simp only [s, inter_comm]
    exact A.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  apply this.Icc_subset_of_forall_exists_gt ha
  rintro x âŸ¨hxB : f x â‰¤ B x, xabâŸ© y hy
  cases' hxB.lt_or_eq with hxB hxB
  Â· 
    refine nonempty_of_mem (inter_mem ?_ (Ioc_mem_nhdsWithin_Ioi âŸ¨le_rfl, hyâŸ©))
    have : âˆ€á¶  x in ğ“[Icc a b] x, f x < B x :=
      A x (Ico_subset_Icc_self xab) (IsOpen.mem_nhds (isOpen_lt continuous_fst continuous_snd) hxB)
    have : âˆ€á¶  x in ğ“[>] x, f x < B x := nhdsWithin_le_of_mem (Icc_mem_nhdsWithin_Ioi xab) this
    exact this.mono fun y => le_of_lt
  Â· rcases exists_between (bound x xab hxB) with âŸ¨r, hfr, hrBâŸ©
    specialize hf' x xab r hfr
    have HB : âˆ€á¶  z in ğ“[>] x, r < slope B x z :=
      (hasDerivWithinAt_iff_tendsto_slope' <| lt_irrefl x).1 (hB' x xab).Ioi_of_Ici
        (Ioi_mem_nhds hrB)
    obtain âŸ¨z, hfz, hzB, hzâŸ© : âˆƒ z, slope f x z < r âˆ§ r < slope B x z âˆ§ z âˆˆ Ioc x y :=
      (hf'.and_eventually (HB.and (Ioc_mem_nhdsWithin_Ioi âŸ¨le_rfl, hyâŸ©))).exists
    refine âŸ¨z, ?_, hzâŸ©
    have := (hfz.trans hzB).le
    rwa [slope_def_field, slope_def_field, div_le_div_right (sub_pos.2 hz.1), hxB,
      sub_le_sub_iff_right] at this",refine theorem_image_le_of_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slope_liminf_slop
Mathlib/MeasureTheory/Measure/Portmanteau.lean,MeasureTheory.tendsto_of_forall_isOpen_le_liminf,tendsto_of_forall_isOpen_le_liminf,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine ProbabilityMeasure.tendsto_iff_forall_integral_tendsto.mpr ?_
  apply tendsto_integral_of_forall_integral_le_liminf_integral
  intro f f_nn
  apply integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure (f := f) f_nn
  intro G G_open
  specialize h_opens G G_open
  simp only at h_opens
  have aux : ENNReal.ofNNReal (liminf (fun i â†¦ ENNReal.toNNReal ((Î¼s i : Measure Î©) G)) atTop) =
          liminf (ENNReal.ofNNReal âˆ˜ fun i â†¦ (ENNReal.toNNReal ((Î¼s i : Measure Î©) G))) atTop := by
    refine Monotone.map_liminf_of_continuousAt (F := atTop) ENNReal.coe_mono (Î¼s Â· G) ?_ ?_ ?_
    Â· apply ENNReal.continuous_coe.continuousAt
    Â· use 1
      simp only [eventually_map, ProbabilityMeasure.apply_le_one, eventually_atTop, ge_iff_le,
        implies_true, forall_const, exists_const]
    Â· use 0
      simp only [zero_le, eventually_map, eventually_atTop, ge_iff_le, implies_true, forall_const,
        exists_const]
  have obs := ENNReal.coe_mono h_opens
  simp only [ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure, aux] at obs
  convert obs
  simp only [Function.comp_apply, ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure]",error:  simp made no progress,"theorem tendsto_of_forall_isOpen_le_liminf {Î¼ : ProbabilityMeasure Î©}
    {Î¼s : â„• â†’ ProbabilityMeasure Î©}
    (h_opens : âˆ€ G, IsOpen G â†’ Î¼ G â‰¤ atTop.liminf (fun i â†¦ Î¼s i G)) :
    atTop.Tendsto (fun i â†¦ Î¼s i) (ğ“ Î¼) ",":= by
  refine ProbabilityMeasure.tendsto_iff_forall_integral_tendsto.mpr ?_
  apply tendsto_integral_of_forall_integral_le_liminf_integral
  intro f f_nn
  apply integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure (f := f) f_nn
  intro G G_open
  specialize h_opens G G_open
  have aux : ENNReal.ofNNReal (liminf (fun i â†¦ Î¼s i G) atTop) =
          liminf (ENNReal.ofNNReal âˆ˜ fun i â†¦ Î¼s i G) atTop := by
    refine Monotone.map_liminf_of_continuousAt (F := atTop) ENNReal.coe_mono (Î¼s Â· G) ?_ ?_ ?_
    Â· apply ENNReal.continuous_coe.continuousAt
    Â· use 1
      simp only [eventually_map, ProbabilityMeasure.apply_le_one, eventually_atTop, ge_iff_le,
        implies_true, forall_const, exists_const]
    Â· use 0
      simp only [zero_le, eventually_map, eventually_atTop, ge_iff_le, implies_true, forall_const,
        exists_const]
  have obs := ENNReal.coe_mono h_opens
  simp only [ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure, aux] at obs
  convert obs
  simp only [Function.comp_apply, ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure]",rw [tendsto_of_forall_isOpen_le_liminf]
Mathlib/NumberTheory/LSeries/Deriv.lean,LSeries_iteratedDeriv,LSeries_iteratedDeriv,8bd4b55183e8c2f473879114c8faa6f2a10f615c,":= by
  induction' m with m ih generalizing s
  Â· simp only [Nat.zero_eq, iteratedDeriv_zero, pow_zero, Function.iterate_zero, id_eq, one_mul]
  Â· have ih' : {s | abscissaOfAbsConv f < re s}.EqOn (iteratedDeriv m (LSeries f))
        ((-1) ^ m * LSeries (logMul^[m] f)) := fun _ hs â†¦ ih hs
    have := derivWithin_congr ih' (ih h)
    simp_rw [derivWithin_of_isOpen (isOpen_re_gt_EReal _) h] at this
    rw [iteratedDeriv_succ, this]
    simp only [Pi.mul_def, Pi.pow_apply, Pi.neg_apply, Pi.one_apply, deriv_const_mul_field',
      pow_succ', mul_assoc, neg_one_mul, Function.iterate_succ', Function.comp_def,
      LSeries_deriv <| absicssaOfAbsConv_logPowMul.symm â–¸ h]","error:  unsolved goals
case succ
f : â„• â†’ â„‚
m : â„•
ih : âˆ€ {s : â„‚}, abscissaOfAbsConv f < â†‘s.re â†’ iteratedDeriv m (LSeries f) s = (-1) ^ m * LSeries (logMul^[m] f) s
s : â„‚
h : abscissaOfAbsConv f < â†‘s.re
ih' : Set.EqOn (iteratedDeriv m (LSeries f)) ((-1) ^ m * LSeries (logMul^[m] f)) {s | abscissaOfAbsConv f < â†‘s.re}
this : deriv (iteratedDeriv m (LSeries f)) s = deriv ((-1) ^ m * LSeries (logMul^[m] f)) s
âŠ¢ (-1) ^ m * -LSeries (logMul (logMul^[m] f)) s = -(-1) ^ m * LSeries (logMul (logMul^[m] f)) s","lemma LSeries_iteratedDeriv {f : â„• â†’ â„‚} (m : â„•) {s : â„‚} (h : abscissaOfAbsConv f < s.re) :
    iteratedDeriv m (LSeries f) s = (-1) ^ m * LSeries (logMul^[m] f) s ",":= by
  induction' m with m ih generalizing s
  Â· simp only [Nat.zero_eq, iteratedDeriv_zero, pow_zero, Function.iterate_zero, id_eq, one_mul]
  Â· have ih' : {s | abscissaOfAbsConv f < re s}.EqOn (iteratedDeriv m (LSeries f))
        ((-1) ^ m * LSeries (logMul^[m] f)) := fun _ hs â†¦ ih hs
    have := derivWithin_congr ih' (ih h)
    simp_rw [derivWithin_of_isOpen (isOpen_re_gt_EReal _) h] at this
    rw [iteratedDeriv_succ, this]
    simp only [Pi.mul_def, Pi.pow_apply, Pi.neg_apply, Pi.one_apply, deriv_const_mul_field',
      pow_succ, mul_assoc, neg_one_mul, Function.iterate_succ', Function.comp_def,
      LSeries_deriv <| absicssaOfAbsConv_logPowMul.symm â–¸ h]",rw [iteratedDeriv_eq_iteratedDeriv_logMul_of_abscissaOfAbsConv_lt h]
Mathlib/Dynamics/OmegaLimit.lean,mem_omegaLimit_iff_frequently,mem_omegaLimit_iff_frequently,d14658b4fab8f69219eacfab3f0e2ad2951d7e1c,":= by
  simp_rw [frequently_iff, omegaLimit_def, mem_iInter, mem_closure_iff_nhds]
  constructor
  Â· intro h _ hn _ hu
    rcases h _ hu _ hn with âŸ¨_, _, _, _, ht, hx, hÏ•txâŸ©
    exact âŸ¨_, ht, _, hx, by rwa [mem_preimage, hÏ•tx]âŸ©
  Â· intro h _ hu _ hn
    rcases h _ hn hu with âŸ¨_, ht, _, hx, hÏ•txâŸ©
    exact âŸ¨_, hÏ•tx, _, _, ht, hx, rflâŸ©","warning:  @omegaLimit does not have a doc string
error:  application type mismatch
  And.intro ht
argument
  ht
has type
  Î± : Type u_2
but is expected to have type
  ?m.10851 âˆˆ Uâœ : Prop
error:  application type mismatch
  Exists.intro ht
argument
  ht
has type
  wâœÂ¹ âˆˆ iâœ : Prop
but is expected to have type
  Î± : Type u_2","theorem mem_omegaLimit_iff_frequently (y : Î²) :
    y âˆˆ Ï‰ f Ï• s â†” âˆ€ n âˆˆ ğ“ y, âˆƒá¶  t in f, (s âˆ© Ï• t â»Â¹' n).Nonempty ",":= by
  simp_rw [frequently_iff, omegaLimit_def, mem_iInter, mem_closure_iff_nhds]
  constructor
  Â· intro h _ hn _ hu
    rcases h _ hu _ hn with âŸ¨_, _, _, ht, _, hx, rflâŸ©
    exact âŸ¨_, ht, _, hx, by rwa [mem_preimage]âŸ©
  Â· intro h _ hu _ hn
    rcases h _ hn hu with âŸ¨_, ht, _, hx, hÏ•txâŸ©
    exact âŸ¨_, hÏ•tx, _, ht, _, hx, rflâŸ©","simp only [mem_omegaLimit_iff_iff_frequently, mem_omegaLimit_iff_iff_frequently]"
Mathlib/FieldTheory/SeparableClosure.lean,separableClosure.map_eq_of_separableClosure_eq_bot,separableClosure.map_eq_of_separableClosure_eq_bot,67bc82d1ddb7cf6ad83d9d67c3f839281acb4d63,":= by
  refine le_antisymm (map_le_of_algHom _) (fun x hx â†¦ ?_)
  obtain âŸ¨y, rflâŸ© := mem_bot.1 <| h â–¸ mem_separableClosure_iff.2
    (IsSeparable.of_isScalarTower E <| mem_separableClosure_iff.1 hx)
  exact âŸ¨y, (map_mem_separableClosure_iff <| IsScalarTower.toAlgHom F E K).mp hx, rflâŸ©","error:  unknown constant 'IsSeparable.of_isScalarTower'
error:  tactic 'subst' failed, invalid equality proof, it is not of the form (x = t) or (t = x)
  (algebraMap E K) y = ?m.6924
case intro
F : Type u
E : Type v
instâœâ¶ : Field F
instâœâµ : Field E
instâœâ´ : Algebra F E
K : Type w
instâœÂ³ : Field K
instâœÂ² : Algebra F K
instâœÂ¹ : Algebra E K
instâœ : IsScalarTower F E K
h : separableClosure E K = âŠ¥
x : K
hx : x âˆˆ separableClosure F K
y : E
hâœ : (algebraMap E K) y = ?m.6924
âŠ¢ x âˆˆ IntermediateField.map (IsScalarTower.toAlgHom F E K) (separableClosure F E)","theorem separableClosure.map_eq_of_separableClosure_eq_bot [Algebra E K] [IsScalarTower F E K]
    (h : separableClosure E K = âŠ¥) :
    (separableClosure F E).map (IsScalarTower.toAlgHom F E K) = separableClosure F K ",":= by
  refine le_antisymm (map_le_of_algHom _) (fun x hx â†¦ ?_)
  obtain âŸ¨y, rflâŸ© := mem_bot.1 <| h â–¸ mem_separableClosure_iff.2
    (mem_separableClosure_iff.1 hx |>.map_minpoly E)
  exact âŸ¨y, (map_mem_separableClosure_iff <| IsScalarTower.toAlgHom F E K).mp hx, rflâŸ©",exact separableClosure_eq_separableClosure_eq_bot F E K
Mathlib/Analysis/Calculus/FDeriv/Extend.lean,has_fderiv_at_boundary_of_tendsto_fderiv,has_fderiv_at_boundary_of_tendsto_fderiv,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  classical
    by_cases hx : x âˆ‰ closure s
    Â· rw [â† closure_closure] at hx; exact hasFDerivWithinAt_of_nmem_closure hx
    push_neg at hx
    rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, Asymptotics.isLittleO_iff]
    intro Îµ Îµ_pos
    obtain âŸ¨Î´, Î´_pos, hÎ´âŸ© : âˆƒ Î´ > 0, âˆ€ y âˆˆ s, dist y x < Î´ â†’ â€–fderiv â„ f y - f'â€– < Îµ := by
      simpa [dist_zero_right] using tendsto_nhdsWithin_nhds.1 h Îµ Îµ_pos
    set B := ball x Î´
    suffices âˆ€ y âˆˆ B âˆ© closure s, â€–f y - f x - (f' y - f' x)â€– â‰¤ Îµ * â€–y - xâ€– from
      mem_nhdsWithin_iff.2 âŸ¨Î´, Î´_pos, fun y hy => by simpa using this y hyâŸ©
    suffices
      âˆ€ p : E Ã— E,
        p âˆˆ closure ((B âˆ© s) Ã—Ë¢ (B âˆ© s)) â†’ â€–f p.2 - f p.1 - (f' p.2 - f' p.1)â€– â‰¤ Îµ * â€–p.2 - p.1â€– by
      rw [closure_prod_eq] at this
      intro y y_in
      apply this âŸ¨x, yâŸ©
      have : B âˆ© closure s âŠ† closure (B âˆ© s) := isOpen_ball.inter_closure
      exact âŸ¨this âŸ¨mem_ball_self Î´_pos, hxâŸ©, this y_inâŸ©
    have key : âˆ€ p : E Ã— E, p âˆˆ (B âˆ© s) Ã—Ë¢ (B âˆ© s) â†’
          â€–f p.2 - f p.1 - (f' p.2 - f' p.1)â€– â‰¤ Îµ * â€–p.2 - p.1â€– := by
      rintro âŸ¨u, vâŸ© âŸ¨u_in, v_inâŸ©
      have conv : Convex â„ (B âˆ© s) := (convex_ball _ _).inter s_conv
      have diff : DifferentiableOn â„ f (B âˆ© s) := f_diff.mono (inter_subset_right _ _)
      have bound : âˆ€ z âˆˆ B âˆ© s, â€–fderivWithin â„ f (B âˆ© s) z - f'â€– â‰¤ Îµ := by
        intro z z_in
        have h := hÎ´ z
        have : fderivWithin â„ f (B âˆ© s) z = fderiv â„ f z := by
          have op : IsOpen (B âˆ© s) := isOpen_ball.inter s_open
          rw [DifferentiableAt.fderivWithin _ (op.uniqueDiffOn z z_in)]
          exact (diff z z_in).differentiableAt (IsOpen.mem_nhds op z_in)
        rw [â† this] at h
        exact (le_of_lt (h z_in.2 z_in.1))
      simpa using conv.norm_image_sub_le_of_norm_fderivWithin_le' diff bound u_in v_in
    rintro âŸ¨u, vâŸ© uv_in
    refine' ContinuousWithinAt.closure_le uv_in _ _ key
    have f_cont' : âˆ€ y âˆˆ closure s, ContinuousWithinAt (f -  â‡‘f') s y := by
      intro y y_in
      exact Tendsto.sub (f_cont y y_in) f'.cont.continuousWithinAt
    all_goals
      have : (B âˆ© s) Ã—Ë¢ (B âˆ© s) âŠ† s Ã—Ë¢ s := by mono <;> exact inter_subset_right _ _
      obtain âŸ¨u_in, v_inâŸ© : u âˆˆ closure s âˆ§ v âˆˆ closure s := by
        simpa [closure_prod_eq] using closure_mono this uv_in
      apply ContinuousWithinAt.mono _ this
      simp only [ContinuousWithinAt]
    rw [nhdsWithin_prod_eq]
    Â· have : âˆ€ u v, f v - f u - (f' v - f' u) = f v - f' v - (f u - f' u) := by intros; abel
      simp only [this]
      exact
        Tendsto.comp continuous_norm.continuousAt
          ((Tendsto.comp (f_cont' v v_in) tendsto_snd).sub <|
            Tendsto.comp (f_cont' u u_in) tendsto_fst)
    Â· apply tendsto_nhdsWithin_of_tendsto_nhds
      rw [nhds_prod_eq]
      exact
        tendsto_const_nhds.mul
          (Tendsto.comp continuous_norm.continuousAt <| tendsto_snd.sub tendsto_fst)","error:  function expected at
  inter_subset_right ?m.39563
term has type
  ?m.39562 âˆˆ ?m.39561
error:  function expected at
  inter_subset_right ?m.79888
term has type
  ?m.79887 âˆˆ ?m.79886
error:  function expected at
  inter_subset_right ?m.79930
term has type
  ?m.79929 âˆˆ ?m.79928
error:  function expected at
  inter_subset_right ?m.107395
term has type
  ?m.107394 âˆˆ ?m.107393
error:  function expected at
  inter_subset_right ?m.107437
term has type
  ?m.107436 âˆˆ ?m.107435","theorem has_fderiv_at_boundary_of_tendsto_fderiv {f : E â†’ F} {s : Set E} {x : E} {f' : E â†’L[â„] F}
    (f_diff : DifferentiableOn â„ f s) (s_conv : Convex â„ s) (s_open : IsOpen s)
    (f_cont : âˆ€ y âˆˆ closure s, ContinuousWithinAt f s y)
    (h : Tendsto (fun y => fderiv â„ f y) (ğ“[s] x) (ğ“ f')) :
    HasFDerivWithinAt f f' (closure s) x ",":= by
  classical
    by_cases hx : x âˆ‰ closure s
    Â· rw [â† closure_closure] at hx; exact hasFDerivWithinAt_of_nmem_closure hx
    push_neg at hx
    rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, Asymptotics.isLittleO_iff]
    intro Îµ Îµ_pos
    obtain âŸ¨Î´, Î´_pos, hÎ´âŸ© : âˆƒ Î´ > 0, âˆ€ y âˆˆ s, dist y x < Î´ â†’ â€–fderiv â„ f y - f'â€– < Îµ := by
      simpa [dist_zero_right] using tendsto_nhdsWithin_nhds.1 h Îµ Îµ_pos
    set B := ball x Î´
    suffices âˆ€ y âˆˆ B âˆ© closure s, â€–f y - f x - (f' y - f' x)â€– â‰¤ Îµ * â€–y - xâ€– from
      mem_nhdsWithin_iff.2 âŸ¨Î´, Î´_pos, fun y hy => by simpa using this y hyâŸ©
    suffices
      âˆ€ p : E Ã— E,
        p âˆˆ closure ((B âˆ© s) Ã—Ë¢ (B âˆ© s)) â†’ â€–f p.2 - f p.1 - (f' p.2 - f' p.1)â€– â‰¤ Îµ * â€–p.2 - p.1â€– by
      rw [closure_prod_eq] at this
      intro y y_in
      apply this âŸ¨x, yâŸ©
      have : B âˆ© closure s âŠ† closure (B âˆ© s) := isOpen_ball.inter_closure
      exact âŸ¨this âŸ¨mem_ball_self Î´_pos, hxâŸ©, this y_inâŸ©
    have key : âˆ€ p : E Ã— E, p âˆˆ (B âˆ© s) Ã—Ë¢ (B âˆ© s) â†’
          â€–f p.2 - f p.1 - (f' p.2 - f' p.1)â€– â‰¤ Îµ * â€–p.2 - p.1â€– := by
      rintro âŸ¨u, vâŸ© âŸ¨u_in, v_inâŸ©
      have conv : Convex â„ (B âˆ© s) := (convex_ball _ _).inter s_conv
      have diff : DifferentiableOn â„ f (B âˆ© s) := f_diff.mono inter_subset_right
      have bound : âˆ€ z âˆˆ B âˆ© s, â€–fderivWithin â„ f (B âˆ© s) z - f'â€– â‰¤ Îµ := by
        intro z z_in
        have h := hÎ´ z
        have : fderivWithin â„ f (B âˆ© s) z = fderiv â„ f z := by
          have op : IsOpen (B âˆ© s) := isOpen_ball.inter s_open
          rw [DifferentiableAt.fderivWithin _ (op.uniqueDiffOn z z_in)]
          exact (diff z z_in).differentiableAt (IsOpen.mem_nhds op z_in)
        rw [â† this] at h
        exact le_of_lt (h z_in.2 z_in.1)
      simpa using conv.norm_image_sub_le_of_norm_fderivWithin_le' diff bound u_in v_in
    rintro âŸ¨u, vâŸ© uv_in
    have f_cont' : âˆ€ y âˆˆ closure s, ContinuousWithinAt (f -  â‡‘f') s y := by
      intro y y_in
      exact Tendsto.sub (f_cont y y_in) f'.cont.continuousWithinAt
    refine ContinuousWithinAt.closure_le uv_in ?_ ?_ key
    all_goals
      have : (B âˆ© s) Ã—Ë¢ (B âˆ© s) âŠ† s Ã—Ë¢ s := by gcongr <;> exact inter_subset_right
      obtain âŸ¨u_in, v_inâŸ© : u âˆˆ closure s âˆ§ v âˆˆ closure s := by
        simpa [closure_prod_eq] using closure_mono this uv_in
      apply ContinuousWithinAt.mono _ this
      simp only [ContinuousWithinAt]
    Â· rw [nhdsWithin_prod_eq]
      have : âˆ€ u v, f v - f u - (f' v - f' u) = f v - f' v - (f u - f' u) := by intros; abel
      simp only [this]
      exact
        Tendsto.comp continuous_norm.continuousAt
          ((Tendsto.comp (f_cont' v v_in) tendsto_snd).sub <|
            Tendsto.comp (f_cont' u u_in) tendsto_fst)
    Â· apply tendsto_nhdsWithin_of_tendsto_nhds
      rw [nhds_prod_eq]
      exact
        tendsto_const_nhds.mul
          (Tendsto.comp continuous_norm.continuousAt <| tendsto_snd.sub tendsto_fst)",apply theorem_has_fderiv_at_boundary_of_tendsto_fderiv
Mathlib/Topology/Instances/TrivSqZeroExt.lean,TrivSqZeroExt.nhds_def,nhds_def,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  cases x
  exact nhds_prod_eq","error:  dependent elimination failed, failed to solve equation
  x = inl râœ + inr mâœ",theorem nhds_def (x : tsze R M) : ğ“ x = (ğ“ x.fst).prod (ğ“ x.snd) ,":= by
  cases x using Prod.rec
  exact nhds_prod_eq","rw [â† prod_nhds_def, â† prod_nhds_def, â† prod_nhds_def]"
Mathlib/Probability/ProbabilityMassFunction/Basic.lean,PMF.toOuterMeasure_apply_eq_of_inter_support_eq,toOuterMeasure_apply_eq_of_inter_support_eq,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  le_antisymm (p.toOuterMeasure_mono (h.symm â–¸ Set.inter_subset_left t p.support))
    (p.toOuterMeasure_mono (h â–¸ Set.inter_subset_left s p.support))","error:  application type mismatch
  Set.inter_subset_left t
argument
  t
has type
  Set Î± : Type u_1
but is expected to have type
  ?m.26578 âˆˆ ?m.26576 âˆ© ?m.26577 : Prop
error:  application type mismatch
  Set.inter_subset_left s
argument
  s
has type
  Set Î± : Type u_1
but is expected to have type
  ?m.26996 âˆˆ ?m.26994 âˆ© ?m.26995 : Prop","theorem toOuterMeasure_apply_eq_of_inter_support_eq {s t : Set Î±}
    (h : s âˆ© p.support = t âˆ© p.support) : p.toOuterMeasure s = p.toOuterMeasure t ",":=
  le_antisymm (p.toOuterMeasure_mono (h.symm â–¸ Set.inter_subset_left))
    (p.toOuterMeasure_mono (h â–¸ Set.inter_subset_left))",rw [toOuterMeasure_apply_eq_of_inter_support_eq]
Mathlib/Topology/MetricSpace/Contracting.lean,ContractingWith.efixedPoint_eq_of_edist_lt_top',efixedPoint_eq_of_edist_lt_top',dcfb64b3e38d43c3b15398369eeddfcf7ceb6906,":= by
  refine' (hf.eq_or_edist_eq_top_of_fixedPoints _ _).elim id fun h' â†¦ False.elim (ne_of_lt _ h')
    <;> try apply efixedPoint_is_fixed_pt'
  change edistLtTopSetoid.Rel _ _
  trans x
  Â· apply Setoid.symm' 
    apply edist_efixedPoint_lt_top'
  trans y
  exact lt_top_iff_ne_top.2 hxy
  apply edist_efixedPoint_lt_top'","error:  type mismatch
  this
has type
  edistLtTopSetoid.Rel ?m.38236 ?m.38237 : Prop
but is expected to have type
  IsFixedPt f (efixedPoint' f hsc hsf hfs x hxs hx) : Prop
error:  unsolved goals
case refine'_1
Î± : Type u_1
instâœ : EMetricSpace Î±
cs : CompleteSpace Î±
K : â„â‰¥0
f : Î± â†’ Î±
hf : ContractingWith K f
s : Set Î±
hsc : IsComplete s
hsf : MapsTo f s s
hfs : ContractingWith K (MapsTo.restrict f s s hsf)
x : Î±
hxs : x âˆˆ s
hx : edist x (f x) â‰  âŠ¤
t : Set Î±
htc : IsComplete t
htf : MapsTo f t t
hft : ContractingWith K (MapsTo.restrict f t t htf)
y : Î±
hyt : y âˆˆ t
hy : edist y (f y) â‰  âŠ¤
hxy : edist x y â‰  âŠ¤
âŠ¢ IsFixedPt f (efixedPoint' f hsc hsf hfs x hxs hx)","theorem efixedPoint_eq_of_edist_lt_top' (hf : ContractingWith K f) {s : Set Î±} (hsc : IsComplete s)
    (hsf : MapsTo f s s) (hfs : ContractingWith K <| hsf.restrict f s s) {x : Î±} (hxs : x âˆˆ s)
    (hx : edist x (f x) â‰  âˆ) {t : Set Î±} (htc : IsComplete t) (htf : MapsTo f t t)
    (hft : ContractingWith K <| htf.restrict f t t) {y : Î±} (hyt : y âˆˆ t) (hy : edist y (f y) â‰  âˆ)
    (hxy : edist x y â‰  âˆ) :
    efixedPoint' f hsc hsf hfs x hxs hx = efixedPoint' f htc htf hft y hyt hy ",":= by
  refine (hf.eq_or_edist_eq_top_of_fixedPoints ?_ ?_).elim id fun h' â†¦ False.elim (ne_of_lt ?_ h')
    <;> try apply efixedPoint_isFixedPt'
  change edistLtTopSetoid.Rel _ _
  trans x
  Â· apply Setoid.symm' 
    apply edist_efixedPoint_lt_top'
  trans y
  Â· exact lt_top_iff_ne_top.2 hxy
  Â· apply edist_efixedPoint_lt_top'",rw [efixedPoint_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_eq_of_edist_
Mathlib/Computability/AkraBazzi/AkraBazzi.lean,AkraBazziRecurrence.T_isBigO_smoothingFn_mul_asympBound,T_isBigO_smoothingFn_mul_asympBound,93fe16b79b4d74f8ddaec22ca9d80d09915ac92b,":= by
  let b' := b (min_bi b) / 2
  have hb_pos : 0 < b' := R.bi_min_div_two_pos
  rw [isBigO_atTop_iff_eventually_exists]
  obtain âŸ¨câ‚, hcâ‚, h_sumTransform_auxâŸ© := R.eventually_atTop_sumTransform_ge
  filter_upwards [eventually_ge_atTop R.nâ‚€,       
      eventually_forall_ge_atTop.mpr eventually_one_sub_smoothingFn_pos,    
      eventually_forall_ge_atTop.mpr
        <| eventually_one_sub_smoothingFn_gt_const (1/2) (by norm_num),    
      eventually_forall_ge_atTop.mpr R.eventually_asympBound_pos,            
      eventually_forall_ge_atTop.mpr R.eventually_asympBound_r_pos,          
      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop
        R.eventually_asympBound_pos,   
      eventually_gt_atTop 0,                                                
      eventually_forall_ge_atTop.mpr R.eventually_one_sub_smoothingFn_r_pos,  
      eventually_forall_ge_atTop.mpr R.rpow_p_mul_one_sub_smoothingFn_le,    
      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop
        eventually_one_sub_smoothingFn_pos,   
      eventually_forall_ge_atTop.mpr h_sumTransform_aux,                     
      eventually_forall_ge_atTop.mpr R.eventually_bi_mul_le_r]               
    with nâ‚€ nâ‚€_ge_Rnâ‚€ h_smoothing_pos h_smoothing_gt_half
      h_asympBound_pos h_asympBound_r_pos h_asympBound_floor nâ‚€_pos h_smoothing_r_pos
      bound1 h_smoothingFn_floor h_sumTransform h_bi_le_r
  have h_base_nonempty := R.base_nonempty nâ‚€_pos
  let base_max : â„ :=
    (Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€).sup' h_base_nonempty
      fun n => T n / ((1 - Îµ n) * asympBound g a b n)
  set C := max (2 * câ‚â»Â¹) base_max with hC
  refine âŸ¨C, fun n hn => ?_âŸ©
  have h_base : âˆ€ n âˆˆ Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€, T n â‰¤ C * ((1 - Îµ n) * asympBound g a b n) := by
    intro n hn
    rw [Finset.mem_Ico] at hn
    have htmp1 : 0 < 1 - Îµ n := h_smoothingFn_floor n hn.1
    have htmp2 : 0 < asympBound g a b n := h_asympBound_floor n hn.1
    rw [â† _root_.div_le_iff (by positivity)]
    rw [â† Finset.mem_Ico] at hn
    calc T n / ((1 - Îµ â†‘n) * asympBound g a b n)
           â‰¤ (Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€).sup' h_base_nonempty
                (fun z => T z / ((1 - Îµ z) * asympBound g a b z)) :=
                  Finset.le_sup'_of_le _ (b := n) hn <| le_refl _
         _ â‰¤ C := le_max_right _ _
  have h_asympBound_pos' : 0 < asympBound g a b n := h_asympBound_pos n hn
  have h_one_sub_smoothingFn_pos' : 0 < 1 - Îµ n := h_smoothing_pos n hn
  rw [Real.norm_of_nonneg (R.T_nonneg n), Real.norm_of_nonneg (by positivity)]
  induction n using Nat.strongInductionOn
  case ind n h_ind =>
    have b_mul_nâ‚€_le_ri i : âŒŠb' * â†‘nâ‚€âŒ‹â‚Š â‰¤ r i n := by
      exact_mod_cast calc âŒŠb' * (nâ‚€ : â„)âŒ‹â‚Š â‰¤ b' * nâ‚€      := Nat.floor_le <| by positivity
                                  _ â‰¤ b' * n        := by gcongr
                                  _ â‰¤ r i n      := h_bi_le_r n hn i
    have g_pos : 0 â‰¤ g n := R.g_nonneg n (by positivity)
    calc
      T n = (âˆ‘ i, a i * T (r i n)) + g n := by exact R.h_rec n <| nâ‚€_ge_Rnâ‚€.trans hn
        _ â‰¤ (âˆ‘ i, a i * (C * ((1 - Îµ (r i n)) * asympBound g a b (r i n)))) + g n := by
            gcongr (âˆ‘ i, a i * ?_) + g n with i _
            Â· exact le_of_lt <| R.a_pos _
            Â· by_cases ri_lt_nâ‚€ : r i n < nâ‚€
              case pos => exact h_base _ <| by aesop
              case neg =>
                push_neg at ri_lt_nâ‚€
                exact h_ind (r i n) (R.r_lt_n _ _ (nâ‚€_ge_Rnâ‚€.trans hn)) ri_lt_nâ‚€
                  (h_asympBound_r_pos _ hn _) (h_smoothing_r_pos n hn i)
        _ = (âˆ‘ i, a i * (C * ((1 - Îµ (r i n)) * ((r i n) ^ (p a b)
                * (1 + (âˆ‘ u in range (r i n), g u / u ^ ((p a b) + 1))))))) + g n := by
            simp_rw [asympBound_def']
        _ = (âˆ‘ i, C * a i * ((r i n) ^ (p a b) * (1 - Îµ (r i n))
                * ((1 + (âˆ‘ u in range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by
            congr; ext; ring
        _ â‰¤ (âˆ‘ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n)
                * ((1 + (âˆ‘ u in range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by
            gcongr (âˆ‘ i, C * a i * (?_
                * ((1 + (âˆ‘ u in range (r i n), g u / u ^ ((p a b) + 1)))))) + g n with i
            Â· have := R.a_pos i
              positivity
            Â· refine add_nonneg zero_le_one <| Finset.sum_nonneg fun j _ => ?_
              rw [div_nonneg_iff]
              exact Or.inl âŸ¨R.g_nonneg j (by positivity), by positivityâŸ©
            Â· exact bound1 n hn i
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n)
                * ((1 + ((âˆ‘ u in range n, g u / u ^ ((p a b) + 1))
                - (âˆ‘ u in Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))) + g n := by
            congr; ext i; congr
            refine eq_sub_of_add_eq ?_
            rw [add_comm]
            exact add_eq_of_eq_sub <| Finset.sum_Ico_eq_sub _
              <| le_of_lt <| R.r_lt_n i n <| nâ‚€_ge_Rnâ‚€.trans hn
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n) * ((n ^ (p a b)
                * (1 + (âˆ‘ u in range n, g u / u ^ ((p a b) + 1)))
                - n ^ (p a b) * (âˆ‘ u in Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))
                + g n := by
            congr; ext; ring
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n)
                * ((asympBound g a b n - sumTransform (p a b) g (r i n) n)))) + g n := by
            simp_rw [asympBound_def', sumTransform_def]
        _ â‰¤ (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n)
                * ((asympBound g a b n - câ‚ * g n)))) + g n := by
            gcongr with i
            Â· have := R.a_pos i
              positivity
            Â· have := R.b_pos i
              positivity
            Â· exact h_sumTransform n hn i
        _ = (âˆ‘ i, C * (1 - Îµ n) * ((asympBound g a b n - câ‚ * g n))
                * (a i * (b i) ^ (p a b))) + g n := by
            congr; ext; ring
        _ = C * (1 - Îµ n) * (asympBound g a b n - câ‚ * g n) + g n := by
            rw [â† Finset.mul_sum, R.sumCoeffsExp_p_eq_one, mul_one]
        _ = C * (1 - Îµ n) * asympBound g a b n + (1 - C * câ‚ * (1 - Îµ n)) * g n := by ring
        _ â‰¤ C * (1 - Îµ n) * asympBound g a b n + 0 := by
            gcongr
            refine mul_nonpos_of_nonpos_of_nonneg ?_ g_pos
            rw [sub_nonpos]
            calc 1 â‰¤ 2 * (câ‚â»Â¹ * câ‚) * (1/2) := by
                    rw [inv_mul_cancel (by positivity : câ‚ â‰  0)]; norm_num
                 _ = (2 * câ‚â»Â¹) * câ‚ * (1/2) := by ring
                 _ â‰¤ C * câ‚ * (1 - Îµ n) := by gcongr
                                              Â· rw [hC]; exact le_max_left _ _
                                              Â· exact le_of_lt <| h_smoothing_gt_half n hn
        _ = C * ((1 - Îµ n) * asympBound g a b n) := by ring","error:  (deterministic) timeout at `isDefEq`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information","lemma T_isBigO_smoothingFn_mul_asympBound :
    T =O[atTop] (fun n => (1 - Îµ n) * asympBound g a b n) ",":= by
  let b' := b (min_bi b) / 2
  have hb_pos : 0 < b' := R.bi_min_div_two_pos
  rw [isBigO_atTop_iff_eventually_exists]
  obtain âŸ¨câ‚, hcâ‚, h_sumTransform_auxâŸ© := R.eventually_atTop_sumTransform_ge
  filter_upwards [eventually_ge_atTop R.nâ‚€,       
      eventually_forall_ge_atTop.mpr eventually_one_sub_smoothingFn_pos,    
      eventually_forall_ge_atTop.mpr
        <| eventually_one_sub_smoothingFn_gt_const (1/2) (by norm_num),    
      eventually_forall_ge_atTop.mpr R.eventually_asympBound_pos,            
      eventually_forall_ge_atTop.mpr R.eventually_asympBound_r_pos,          
      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop
        R.eventually_asympBound_pos,   
      eventually_gt_atTop 0,                                                
      eventually_forall_ge_atTop.mpr R.eventually_one_sub_smoothingFn_r_pos,  
      eventually_forall_ge_atTop.mpr R.rpow_p_mul_one_sub_smoothingFn_le,    
      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop
        eventually_one_sub_smoothingFn_pos,   
      eventually_forall_ge_atTop.mpr h_sumTransform_aux,                     
      eventually_forall_ge_atTop.mpr R.eventually_bi_mul_le_r]               
    with nâ‚€ nâ‚€_ge_Rnâ‚€ h_smoothing_pos h_smoothing_gt_half
      h_asympBound_pos h_asympBound_r_pos h_asympBound_floor nâ‚€_pos h_smoothing_r_pos
      bound1 h_smoothingFn_floor h_sumTransform h_bi_le_r
  have h_base_nonempty := R.base_nonempty nâ‚€_pos
  let base_max : â„ :=
    (Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€).sup' h_base_nonempty
      fun n => T n / ((1 - Îµ n) * asympBound g a b n)
  set C := max (2 * câ‚â»Â¹) base_max with hC
  refine âŸ¨C, fun n hn => ?_âŸ©
  have h_base : âˆ€ n âˆˆ Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€, T n â‰¤ C * ((1 - Îµ n) * asympBound g a b n) := by
    intro n hn
    rw [Finset.mem_Ico] at hn
    have htmp1 : 0 < 1 - Îµ n := h_smoothingFn_floor n hn.1
    have htmp2 : 0 < asympBound g a b n := h_asympBound_floor n hn.1
    rw [â† _root_.div_le_iff (by positivity)]
    rw [â† Finset.mem_Ico] at hn
    calc T n / ((1 - Îµ â†‘n) * asympBound g a b n)
           â‰¤ (Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€).sup' h_base_nonempty
                (fun z => T z / ((1 - Îµ z) * asympBound g a b z)) :=
                  Finset.le_sup'_of_le _ (b := n) hn le_rfl
         _ â‰¤ C := le_max_right _ _
  have h_asympBound_pos' : 0 < asympBound g a b n := h_asympBound_pos n hn
  have h_one_sub_smoothingFn_pos' : 0 < 1 - Îµ n := h_smoothing_pos n hn
  rw [Real.norm_of_nonneg (R.T_nonneg n), Real.norm_of_nonneg (by positivity)]
  induction n using Nat.strongInductionOn with
  | ind n h_ind =>
    have b_mul_nâ‚€_le_ri i : âŒŠb' * â†‘nâ‚€âŒ‹â‚Š â‰¤ r i n := by
      exact_mod_cast calc âŒŠb' * (nâ‚€ : â„)âŒ‹â‚Š â‰¤ b' * nâ‚€      := Nat.floor_le <| by positivity
                                  _ â‰¤ b' * n        := by gcongr
                                  _ â‰¤ r i n      := h_bi_le_r n hn i
    have g_pos : 0 â‰¤ g n := R.g_nonneg n (by positivity)
    calc
      T n = (âˆ‘ i, a i * T (r i n)) + g n := by exact R.h_rec n <| nâ‚€_ge_Rnâ‚€.trans hn
        _ â‰¤ (âˆ‘ i, a i * (C * ((1 - Îµ (r i n)) * asympBound g a b (r i n)))) + g n := by
            gcongr (âˆ‘ i, a i * ?_) + g n with i _
            Â· exact le_of_lt <| R.a_pos _
            Â· if ri_lt_nâ‚€ : r i n < nâ‚€ then
                exact h_base _ <| by
                  simp_all only [gt_iff_lt, Nat.ofNat_pos, div_pos_iff_of_pos_right,
                    eventually_atTop, ge_iff_le, sub_pos, one_div, mem_Ico, and_imp,
                    forall_true_left, mem_univ, and_self, b', C, base_max]
              else
                push_neg at ri_lt_nâ‚€
                exact h_ind (r i n) (R.r_lt_n _ _ (nâ‚€_ge_Rnâ‚€.trans hn)) ri_lt_nâ‚€
                  (h_asympBound_r_pos _ hn _) (h_smoothing_r_pos n hn i)
        _ = (âˆ‘ i, a i * (C * ((1 - Îµ (r i n)) * ((r i n) ^ (p a b)
                * (1 + (âˆ‘ u âˆˆ range (r i n), g u / u ^ ((p a b) + 1))))))) + g n := by
            simp_rw [asympBound_def']
        _ = (âˆ‘ i, C * a i * ((r i n) ^ (p a b) * (1 - Îµ (r i n))
                * ((1 + (âˆ‘ u âˆˆ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by
            congr; ext; ring
        _ â‰¤ (âˆ‘ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n)
                * ((1 + (âˆ‘ u âˆˆ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by
            gcongr (âˆ‘ i, C * a i * (?_
                * ((1 + (âˆ‘ u âˆˆ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n with i
            Â· have := R.a_pos i
              positivity
            Â· refine add_nonneg zero_le_one <| Finset.sum_nonneg fun j _ => ?_
              rw [div_nonneg_iff]
              exact Or.inl âŸ¨R.g_nonneg j (by positivity), by positivityâŸ©
            Â· exact bound1 n hn i
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n)
                * ((1 + ((âˆ‘ u âˆˆ range n, g u / u ^ ((p a b) + 1))
                - (âˆ‘ u âˆˆ Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))) + g n := by
            congr; ext i; congr
            refine eq_sub_of_add_eq ?_
            rw [add_comm]
            exact add_eq_of_eq_sub <| Finset.sum_Ico_eq_sub _
              <| le_of_lt <| R.r_lt_n i n <| nâ‚€_ge_Rnâ‚€.trans hn
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n) * ((n ^ (p a b)
                * (1 + (âˆ‘ u âˆˆ range n, g u / u ^ ((p a b) + 1)))
                - n ^ (p a b) * (âˆ‘ u âˆˆ Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))
                + g n := by
            congr; ext; ring
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n)
                * ((asympBound g a b n - sumTransform (p a b) g (r i n) n)))) + g n := by
            simp_rw [asympBound_def', sumTransform_def]
        _ â‰¤ (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n)
                * ((asympBound g a b n - câ‚ * g n)))) + g n := by
            gcongr with i
            Â· have := R.a_pos i
              positivity
            Â· have := R.b_pos i
              positivity
            Â· exact h_sumTransform n hn i
        _ = (âˆ‘ i, C * (1 - Îµ n) * ((asympBound g a b n - câ‚ * g n))
                * (a i * (b i) ^ (p a b))) + g n := by
            congr; ext; ring
        _ = C * (1 - Îµ n) * (asympBound g a b n - câ‚ * g n) + g n := by
            rw [â† Finset.mul_sum, R.sumCoeffsExp_p_eq_one, mul_one]
        _ = C * (1 - Îµ n) * asympBound g a b n + (1 - C * câ‚ * (1 - Îµ n)) * g n := by ring
        _ â‰¤ C * (1 - Îµ n) * asympBound g a b n + 0 := by
            gcongr
            refine mul_nonpos_of_nonpos_of_nonneg ?_ g_pos
            rw [sub_nonpos]
            calc 1 â‰¤ 2 * (câ‚â»Â¹ * câ‚) * (1/2) := by
                    rw [inv_mul_cancel (by positivity : câ‚ â‰  0)]; norm_num
                 _ = (2 * câ‚â»Â¹) * câ‚ * (1/2) := by ring
                 _ â‰¤ C * câ‚ * (1 - Îµ n) := by gcongr
                                              Â· rw [hC]; exact le_max_left _ _
                                              Â· exact le_of_lt <| h_smoothing_gt_half n hn
        _ = C * ((1 - Îµ n) * asympBound g a b n) := by ring",refine T_isBigO_smoothingFn_mul_asympBound.isBigO_smoothingFn_mul_asympBound ?_
Mathlib/Topology/Algebra/Module/LinearPMap.lean,LinearPMap.IsClosable.leIsClosable,IsClosable.leIsClosable,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  cases' hf with f' hf
  have : g.graph.topologicalClosure â‰¤ f'.graph := by
    rw [â† hf]
    exact Submodule.topologicalClosure_mono (le_graph_of_le hfg)
  refine' âŸ¨g.graph.topologicalClosure.toLinearPMap _, _âŸ©
  Â· intro x hx hx'
    cases x
    exact f'.graph_fst_eq_zero_snd (this hx) hx'
  rw [Submodule.toLinearPMap_graph_eq]","error:  application type mismatch
  Exists.intro (â†‘g.graph.topologicalClosure.toLinearPMap ?m.28814)
argument
  â†‘g.graph.topologicalClosure.toLinearPMap ?m.28814
has type
  F : Type u_3
but is expected to have type
  E â†’â‚—.[R] F : Type (max u_2 u_3)
error:  tactic 'introN' failed, insufficient number of binders
case intro
R : Type u_1
E : Type u_2
F : Type u_3
instâœÂ¹Â¹ : CommRing R
instâœÂ¹â° : AddCommGroup E
instâœâ¹ : AddCommGroup F
instâœâ¸ : Module R E
instâœâ· : Module R F
instâœâ¶ : TopologicalSpace E
instâœâµ : TopologicalSpace F
instâœâ´ : ContinuousAdd E
instâœÂ³ : ContinuousAdd F
instâœÂ² : TopologicalSpace R
instâœÂ¹ : ContinuousSMul R E
instâœ : ContinuousSMul R F
f g : E â†’â‚—.[R] F
hfg : g â‰¤ f
f' : E â†’â‚—.[R] F
hf : f.graph.topologicalClosure = f'.graph
this : g.graph.topologicalClosure â‰¤ f'.graph
âŠ¢ g.graph.topologicalClosure = (sorryAx (E â†’â‚—.[R] F) true).graph
error:  no goals to be solved","theorem IsClosable.leIsClosable {f g : E â†’â‚—.[R] F} (hf : f.IsClosable) (hfg : g â‰¤ f) :
    g.IsClosable ",":= by
  cases' hf with f' hf
  have : g.graph.topologicalClosure â‰¤ f'.graph := by
    rw [â† hf]
    exact Submodule.topologicalClosure_mono (le_graph_of_le hfg)
  use g.graph.topologicalClosure.toLinearPMap
  rw [Submodule.toLinearPMap_graph_eq]
  exact fun _ hx hx' => f'.graph_fst_eq_zero_snd (this hx) hx'",rw [IsClosable.leIsClosable_iff]
Mathlib/Topology/Separation.lean,IsCompact.finite_compact_cover,IsCompact.finite_compact_cover,ddffab96a653674eaf6ec54e6415f6fa7c2a49f7,":= by
  induction' t with x t hx ih generalizing U s
  Â· refine' âŸ¨fun _ => âˆ…, fun _ => isCompact_empty, fun i => empty_subset _, _âŸ©
    simpa only [subset_empty_iff, Finset.not_mem_empty, iUnion_false, iUnion_empty] using hsC
  simp only [Finset.set_biUnion_insert] at hsC
  simp only [Finset.forall_mem_insert] at hU
  have hU' : âˆ€ i âˆˆ t, IsOpen (U i) := fun i hi => hU.2 i hi
  rcases hs.binary_compact_cover hU.1 (isOpen_biUnion hU') hsC with
    âŸ¨Kâ‚, Kâ‚‚, h1Kâ‚, h1Kâ‚‚, h2Kâ‚, h2Kâ‚‚, hKâŸ©
  rcases ih h1Kâ‚‚ U hU' h2Kâ‚‚ with âŸ¨K, h1K, h2K, h3KâŸ©
  refine' âŸ¨update K x Kâ‚, _, _, _âŸ©
  Â· intro i
    rcases eq_or_ne i x with rfl | hi
    Â· simp only [update_same, h1Kâ‚]
    Â· simp only [update_noteq hi, h1K]
  Â· intro i
    rcases eq_or_ne i x with rfl | hi
    Â· simp only [update_same, h2Kâ‚]
    Â· simp only [update_noteq hi, h2K]
  Â· simp only [Finset.set_biUnion_insert_update _ hx, hK, h3K]","error:  type mismatch
  hâœ
has type
  s âŠ† â‹ƒ i âˆˆ { val := x, nodup := t }, U i : Prop
but is expected to have type
  s = âˆ… : Prop
error:  no goals to be solved","theorem IsCompact.finite_compact_cover {s : Set X} (hs : IsCompact s) {Î¹ : Type*}
    (t : Finset Î¹) (U : Î¹ â†’ Set X) (hU : âˆ€ i âˆˆ t, IsOpen (U i)) (hsC : s âŠ† â‹ƒ i âˆˆ t, U i) :
    âˆƒ K : Î¹ â†’ Set X, (âˆ€ i, IsCompact (K i)) âˆ§ (âˆ€ i, K i âŠ† U i) âˆ§ s = â‹ƒ i âˆˆ t, K i ",":= by
  induction' t using Finset.induction with x t hx ih generalizing U s
  Â· refine âŸ¨fun _ => âˆ…, fun _ => isCompact_empty, fun i => empty_subset _, ?_âŸ©
    simpa only [subset_empty_iff, Finset.not_mem_empty, iUnion_false, iUnion_empty] using hsC
  simp only [Finset.set_biUnion_insert] at hsC
  simp only [Finset.forall_mem_insert] at hU
  have hU' : âˆ€ i âˆˆ t, IsOpen (U i) := fun i hi => hU.2 i hi
  rcases hs.binary_compact_cover hU.1 (isOpen_biUnion hU') hsC with
    âŸ¨Kâ‚, Kâ‚‚, h1Kâ‚, h1Kâ‚‚, h2Kâ‚, h2Kâ‚‚, hKâŸ©
  rcases ih h1Kâ‚‚ U hU' h2Kâ‚‚ with âŸ¨K, h1K, h2K, h3KâŸ©
  refine âŸ¨update K x Kâ‚, ?_, ?_, ?_âŸ©
  Â· intro i
    rcases eq_or_ne i x with rfl | hi
    Â· simp only [update_same, h1Kâ‚]
    Â· simp only [update_noteq hi, h1K]
  Â· intro i
    rcases eq_or_ne i x with rfl | hi
    Â· simp only [update_same, h2Kâ‚]
    Â· simp only [update_noteq hi, h2K]
  Â· simp only [Finset.set_biUnion_insert_update _ hx, hK, h3K]","refine âŸ¨â‹ƒ i âˆˆ t, â‹ƒ i âˆˆ t, U i, isOpen_iUnion fun i â†¦ U i, isCompact_iUnion fun i â†¦ U i, ?_âŸ©"
Mathlib/RingTheory/Coprime/Ideal.lean,Ideal.iSup_iInf_eq_top_iff_pairwise,iSup_iInf_eq_top_iff_pairwise,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  haveI : DecidableEq Î¹ := Classical.decEq Î¹
  rw [eq_top_iff_one, Submodule.mem_iSup_finset_iff_exists_sum]
  refine h.cons_induction ?_ ?_ <;> clear t h
  Â· simp only [Finset.sum_singleton, Finset.coe_singleton, Set.pairwise_singleton, iff_true_iff]
    refine fun a => âŸ¨fun i => if h : i = a then âŸ¨1, ?_âŸ© else 0, ?_âŸ©
    Â· simp [h]
    Â· simp only [dif_pos, dif_ctx_congr, Submodule.coe_mk, eq_self_iff_true]
  intro a t hat h ih
  rw [Finset.coe_cons,
    Set.pairwise_insert_of_symmetric fun i j (h : I i âŠ” I j = âŠ¤) â†¦ (sup_comm _ _).trans h]
  constructor
  Â· rintro âŸ¨Î¼, hÎ¼âŸ©
    rw [Finset.sum_cons] at hÎ¼
    refine âŸ¨ih.mp âŸ¨Pi.single h.choose âŸ¨Î¼ a, ?a1âŸ© + fun i => âŸ¨Î¼ i, ?a2âŸ©, ?a3âŸ©, fun b hb ab => ?a4âŸ©
    case a1 =>
      have := Submodule.coe_mem (Î¼ a)
      rw [mem_iInf] at this âŠ¢
      intro i
      specialize this i
      rw [mem_iInf, mem_iInf] at this âŠ¢
      intro hi _
      apply this (Finset.subset_cons _ hi)
      rintro rfl
      exact hat hi
    case a2 =>
      have := Submodule.coe_mem (Î¼ i)
      simp only [mem_iInf] at this âŠ¢
      intro j hj ij
      exact this _ (Finset.subset_cons _ hj) ij
    case a3 =>
      rw [â† @if_pos _ _ h.choose_spec R (Î¼ a) 0, â† Finset.sum_pi_single', â† Finset.sum_add_distrib]
        at hÎ¼
      convert hÎ¼
      rename_i i _
      rw [Pi.add_apply, Submodule.coe_add, Submodule.coe_mk]
      by_cases hi : i = h.choose
      Â· rw [hi, Pi.single_eq_same, Pi.single_eq_same, Submodule.coe_mk]
      Â· rw [Pi.single_eq_of_ne hi, Pi.single_eq_of_ne hi, Submodule.coe_zero]
    case a4 =>
      rw [eq_top_iff_one, Submodule.mem_sup]
      rw [add_comm] at hÎ¼
      refine âŸ¨_, ?_, _, ?_, hÎ¼âŸ©
      Â· refine sum_mem _ fun x hx => ?_
        have := Submodule.coe_mem (Î¼ x)
        simp only [mem_iInf] at this
        apply this _ (Finset.mem_cons_self _ _)
        rintro rfl
        exact hat hx
      Â· have := Submodule.coe_mem (Î¼ a)
        simp only [mem_iInf] at this
        exact this _ (Finset.subset_cons _ hb) ab.symm
  Â· rintro âŸ¨hs, HbâŸ©
    obtain âŸ¨Î¼, hÎ¼âŸ© := ih.mpr hs
    have := sup_iInf_eq_top fun b hb => Hb b hb (ne_of_mem_of_not_mem hb hat).symm
    rw [eq_top_iff_one, Submodule.mem_sup] at this
    obtain âŸ¨u, hu, v, hv, huvâŸ© := this
    refine âŸ¨fun i => if hi : i = a then âŸ¨v, ?_âŸ© else âŸ¨u * Î¼ i, ?_âŸ©?, _âŸ©
    Â· simp only [mem_iInf] at hv âŠ¢
      intro j hj ij
      rw [Finset.mem_cons, â† hi] at hj
      exact hv _ (hj.resolve_left ij)
    Â· have := Submodule.coe_mem (Î¼ i)
      simp only [mem_iInf] at this âŠ¢
      intro j hj ij
      rcases Finset.mem_cons.mp hj with (rfl | hj)
      Â· exact mul_mem_right _ _ hu
      Â· exact mul_mem_left _ _ (this _ hj ij)
    Â· dsimp only
      rw [Finset.sum_cons, dif_pos rfl, add_comm]
      rw [â† mul_one u] at huv
      rw [â† huv, â† hÎ¼, Finset.mul_sum]
      congr 1
      apply Finset.sum_congr rfl
      intro j hj
      rw [dif_neg]
      rintro rfl
      exact hat hj",error:  unexpected token '?'; expected 'âŸ©',"theorem iSup_iInf_eq_top_iff_pairwise {t : Finset Î¹} (h : t.Nonempty) (I : Î¹ â†’ Ideal R) :
    (â¨† i âˆˆ t, â¨… (j) (_ : j âˆˆ t) (_ : j â‰  i), I j) = âŠ¤ â†”
      (t : Set Î¹).Pairwise fun i j => I i âŠ” I j = âŠ¤ ",":= by
  haveI : DecidableEq Î¹ := Classical.decEq Î¹
  rw [eq_top_iff_one, Submodule.mem_iSup_finset_iff_exists_sum]
  refine h.cons_induction ?_ ?_ <;> clear t h
  Â· simp only [Finset.sum_singleton, Finset.coe_singleton, Set.pairwise_singleton, iff_true_iff]
    refine fun a => âŸ¨fun i => if h : i = a then âŸ¨1, ?_âŸ© else 0, ?_âŸ©
    Â· simp [h]
    Â· simp only [dif_pos, dif_ctx_congr, Submodule.coe_mk, eq_self_iff_true]
  intro a t hat h ih
  rw [Finset.coe_cons,
    Set.pairwise_insert_of_symmetric fun i j (h : I i âŠ” I j = âŠ¤) â†¦ (sup_comm _ _).trans h]
  constructor
  Â· rintro âŸ¨Î¼, hÎ¼âŸ©
    rw [Finset.sum_cons] at hÎ¼
    refine âŸ¨ih.mp âŸ¨Pi.single h.choose âŸ¨Î¼ a, ?a1âŸ© + fun i => âŸ¨Î¼ i, ?a2âŸ©, ?a3âŸ©, fun b hb ab => ?a4âŸ©
    case a1 =>
      have := Submodule.coe_mem (Î¼ a)
      rw [mem_iInf] at this âŠ¢
      intro i
      specialize this i
      rw [mem_iInf, mem_iInf] at this âŠ¢
      intro hi _
      apply this (Finset.subset_cons _ hi)
      rintro rfl
      exact hat hi
    case a2 =>
      have := Submodule.coe_mem (Î¼ i)
      simp only [mem_iInf] at this âŠ¢
      intro j hj ij
      exact this _ (Finset.subset_cons _ hj) ij
    case a3 =>
      rw [â† @if_pos _ _ h.choose_spec R (Î¼ a) 0, â† Finset.sum_pi_single', â† Finset.sum_add_distrib]
        at hÎ¼
      convert hÎ¼
      rename_i i _
      rw [Pi.add_apply, Submodule.coe_add, Submodule.coe_mk]
      by_cases hi : i = h.choose
      Â· rw [hi, Pi.single_eq_same, Pi.single_eq_same, Submodule.coe_mk]
      Â· rw [Pi.single_eq_of_ne hi, Pi.single_eq_of_ne hi, Submodule.coe_zero]
    case a4 =>
      rw [eq_top_iff_one, Submodule.mem_sup]
      rw [add_comm] at hÎ¼
      refine âŸ¨_, ?_, _, ?_, hÎ¼âŸ©
      Â· refine sum_mem _ fun x hx => ?_
        have := Submodule.coe_mem (Î¼ x)
        simp only [mem_iInf] at this
        apply this _ (Finset.mem_cons_self _ _)
        rintro rfl
        exact hat hx
      Â· have := Submodule.coe_mem (Î¼ a)
        simp only [mem_iInf] at this
        exact this _ (Finset.subset_cons _ hb) ab.symm
  Â· rintro âŸ¨hs, HbâŸ©
    obtain âŸ¨Î¼, hÎ¼âŸ© := ih.mpr hs
    have := sup_iInf_eq_top fun b hb => Hb b hb (ne_of_mem_of_not_mem hb hat).symm
    rw [eq_top_iff_one, Submodule.mem_sup] at this
    obtain âŸ¨u, hu, v, hv, huvâŸ© := this
    refine âŸ¨fun i => if hi : i = a then âŸ¨v, ?_âŸ© else âŸ¨u * Î¼ i, ?_âŸ©, ?_âŸ©
    Â· simp only [mem_iInf] at hv âŠ¢
      intro j hj ij
      rw [Finset.mem_cons, â† hi] at hj
      exact hv _ (hj.resolve_left ij)
    Â· have := Submodule.coe_mem (Î¼ i)
      simp only [mem_iInf] at this âŠ¢
      intro j hj ij
      rcases Finset.mem_cons.mp hj with (rfl | hj)
      Â· exact mul_mem_right _ _ hu
      Â· exact mul_mem_left _ _ (this _ hj ij)
    Â· dsimp only
      rw [Finset.sum_cons, dif_pos rfl, add_comm]
      rw [â† mul_one u] at huv
      rw [â† huv, â† hÎ¼, Finset.mul_sum]
      congr 1
      apply Finset.sum_congr rfl
      intro j hj
      rw [dif_neg]
      rintro rfl
      exact hat hj","refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©"
Mathlib/Data/Matrix/PEquiv.lean,PEquiv.toMatrix_swap,toMatrix_swap,166d0bf5448fdaad518cf95891af45e08a3e9c35,":= by
  ext
  dsimp [toMatrix, single, Equiv.swap_apply_def, Equiv.toPEquiv, one_apply]
  rw [one_apply]
  split_ifs <;> simp_all","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  1 ?m.53380 ?m.53381
case a
k : Type u_1
l : Type u_2
m : Type u_3
n : Type u_4
Î± : Type v
instâœÂ¹ : DecidableEq n
instâœ : Ring Î±
i j iâœ jâœ : n
âŠ¢ (if jâœ âˆˆ some (if iâœ = i then j else if iâœ = j then i else iâœ) then 1 else 0) =
    ((((if iâœ = jâœ then 1 else 0) - if jâœ âˆˆ if iâœ = i then some i else none then 1 else 0) -
          if jâœ âˆˆ if iâœ = j then some j else none then 1 else 0) +
        if jâœ âˆˆ if iâœ = i then some j else none then 1 else 0) +
      if jâœ âˆˆ if iâœ = j then some i else none then 1 else 0","theorem toMatrix_swap [DecidableEq n] [Ring Î±] (i j : n) :
    (Equiv.swap i j).toPEquiv.toMatrix =
      (1 : Matrix n n Î±) - (single i i).toMatrix - (single j j).toMatrix + (single i j).toMatrix +
        (single j i).toMatrix ",":= by
  ext
  dsimp [toMatrix, single, Equiv.swap_apply_def, Equiv.toPEquiv, one_apply]
  split_ifs <;> simp_all","simp [DecidableEq, swap_apply, Equiv.swap_apply, Equiv.swap_apply]"
Mathlib/LinearAlgebra/Matrix/Transvection.lean,Matrix.updateRow_eq_transvection,updateRow_eq_transvection,38c07226a16718eb795d21b235c5dbe282be86b0,":= by
  cases nonempty_fintype n
  ext a b
  by_cases ha : i = a; by_cases hb : j = b
  Â· simp only [updateRow_self, transvection, ha, hb, Pi.add_apply, StdBasisMatrix.apply_same,
      one_apply_eq, Pi.smul_apply, mul_one, Algebra.id.smul_eq_mul, add_apply]
  Â· simp only [updateRow_self, transvection, ha, hb, StdBasisMatrix.apply_of_ne, Pi.add_apply,
      Ne.def, not_false_iff, Pi.smul_apply, and_false_iff, one_apply_ne, Algebra.id.smul_eq_mul,
      MulZeroClass.mul_zero, add_apply]
  Â· simp only [updateRow_ne, transvection, ha, Ne.symm ha, StdBasisMatrix.apply_of_ne, add_zero,
      Algebra.id.smul_eq_mul, Ne.def, not_false_iff, DMatrix.add_apply, Pi.smul_apply,
      MulZeroClass.mul_zero, false_and_iff, add_apply]","error:  unsolved goals
case pos
n : Type u_1
p : Type u_2
R : Type uâ‚‚
ğ•œ : Type u_3
instâœâ´ : Field ğ•œ
instâœÂ³ : DecidableEq n
instâœÂ² : DecidableEq p
instâœÂ¹ : CommRing R
i j : n
instâœ : Finite n
c : R
valâœ : Fintype n
a b : n
ha : i = a
hb : j = b
âŠ¢ 1 i b + c * 1 j b = 1 a b + c
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.3605 â†’ ?m.3605 â†’ Prop
error:  unsolved goals
case neg
n : Type u_1
p : Type u_2
R : Type uâ‚‚
ğ•œ : Type u_3
instâœâ´ : Field ğ•œ
instâœÂ³ : DecidableEq n
instâœÂ² : DecidableEq p
instâœÂ¹ : CommRing R
i j : n
instâœ : Finite n
c : R
valâœ : Fintype n
a b : n
ha : i = a
hb : Â¬j = b
âŠ¢ 1 i b + c * 1 j b = 1 a b + 0
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.4651 â†’ ?m.4651 â†’ Prop
error:  unsolved goals
case neg
n : Type u_1
p : Type u_2
R : Type uâ‚‚
ğ•œ : Type u_3
instâœâ´ : Field ğ•œ
instâœÂ³ : DecidableEq n
instâœÂ² : DecidableEq p
instâœÂ¹ : CommRing R
i j : n
instâœ : Finite n
c : R
valâœ : Fintype n
a b : n
ha : Â¬i = a
âŠ¢ updateRow 1 i (1 i + c â€¢ 1 j) a b = 1 a b","theorem updateRow_eq_transvection [Finite n] (c : R) :
    updateRow (1 : Matrix n n R) i ((1 : Matrix n n R) i + c â€¢ (1 : Matrix n n R) j) =
      transvection i j c ",":= by
  cases nonempty_fintype n
  ext a b
  by_cases ha : i = a
  Â· by_cases hb : j = b
    Â· simp only [ha, updateRow_self, Pi.add_apply, one_apply, Pi.smul_apply, hb, â†“reduceIte,
        smul_eq_mul, mul_one, transvection, add_apply, StdBasisMatrix.apply_same]
    Â· simp only [ha, updateRow_self, Pi.add_apply, one_apply, Pi.smul_apply, hb, â†“reduceIte,
        smul_eq_mul, mul_zero, add_zero, transvection, add_apply, and_false, not_false_eq_true,
        StdBasisMatrix.apply_of_ne]
  Â· simp only [updateRow_ne, transvection, ha, Ne.symm ha, StdBasisMatrix.apply_of_ne, add_zero,
      Algebra.id.smul_eq_mul, Ne, not_false_iff, DMatrix.add_apply, Pi.smul_apply,
      mul_zero, false_and_iff, add_apply]","rw [transvection, updateRow_eq_transvection]"
Mathlib/RingTheory/FractionalIdeal/Operations.lean,FractionalIdeal.isPrincipal_iff,isPrincipal_iff,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":=
  âŸ¨fun h => âŸ¨@generator _ _ _ _ _ (â†‘I) h, @eq_spanSingleton_of_principal _ _ _ _ _ _ _ _ I hâŸ©,
    fun âŸ¨x, hxâŸ© => { principal' := âŸ¨x, Eq.trans (congr_arg _ hx) (coe_spanSingleton _ x)âŸ© }âŸ©","error:  application type mismatch
  @eq_spanSingleton_of_principal ?m.432011 ?m.432012 ?m.432013 ?m.432014 ?m.432015 ?m.432016 ?m.432017 ?m.432018 I
argument
  I
has type
  FractionalIdeal S P : Type u_2
but is expected to have type
  (â†‘?m.432018).IsPrincipal : Prop","theorem isPrincipal_iff (I : FractionalIdeal S P) :
    IsPrincipal (I : Submodule R P) â†” âˆƒ x, I = spanSingleton S x ",":=
  âŸ¨fun h => âŸ¨@generator _ _ _ _ _ (â†‘I) h, @eq_spanSingleton_of_principal _ _ _ _ _ _ _ I hâŸ©,
    fun âŸ¨x, hxâŸ© => { principal' := âŸ¨x, Eq.trans (congr_arg _ hx) (coe_spanSingleton _ x)âŸ© }âŸ©",constructor
Mathlib/Probability/Kernel/CondDistrib.lean,ProbabilityTheory.condDistrib_ae_eq_condexp,condDistrib_ae_eq_condexp,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine ae_eq_condexp_of_forall_setIntegral_eq hX.comap_le ?_ ?_? ?_ _
  Â· exact (integrable_const _).indicator (hY hs)
  Â· exact fun t _ _ => (integrable_toReal_condDistrib hX.aemeasurable hs).integrableOn
  Â· intro t ht _
    rw [integral_toReal ((measurable_condDistrib hs).mono hX.comap_le le_rfl).aemeasurable
      (eventually_of_forall fun Ï‰ => measure_lt_top (condDistrib Y X Î¼ (X Ï‰)) _),
      integral_indicator_const _ (hY hs), Measure.restrict_apply (hY hs), smul_eq_mul, mul_one,
      inter_comm, set_lintegral_condDistrib_of_measurableSet hX hY.aemeasurable hs ht]
  Â· refine (Measurable.stronglyMeasurable ?_).aeStronglyMeasurable'
    exact @Measurable.ennreal_toReal _ (mÎ².comap X) _ (measurable_condDistrib hs)","error:  don't know how to synthesize placeholder for argument 'hgm'
context:
Î± : Type u_1
Î² : Type u_2
Î© : Type u_3
F : Type u_4
instâœâ´ : MeasurableSpace Î©
instâœÂ³ : StandardBorelSpace Î©
instâœÂ² : Nonempty Î©
instâœÂ¹ : NormedAddCommGroup F
mÎ± : MeasurableSpace Î±
Î¼ : Measure Î±
instâœ : IsFiniteMeasure Î¼
X : Î± â†’ Î²
Y : Î± â†’ Î©
mÎ² : MeasurableSpace Î²
s : Set Î©
t : Set Î²
f : Î² Ã— Î© â†’ F
hX : Measurable X
hY : Measurable Y
hs : MeasurableSet s
âŠ¢ AEStronglyMeasurable' (MeasurableSpace.comap X mÎ²) (fun a â†¦ (((condDistrib Y X Î¼) (X a)) s).toReal) Î¼
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î© : Type u_3
F : Type u_4
instâœâ´ : MeasurableSpace Î©
instâœÂ³ : StandardBorelSpace Î©
instâœÂ² : Nonempty Î©
instâœÂ¹ : NormedAddCommGroup F
mÎ± : MeasurableSpace Î±
Î¼ : Measure Î±
instâœ : IsFiniteMeasure Î¼
X : Î± â†’ Î²
Y : Î± â†’ Î©
mÎ² : MeasurableSpace Î²
s : Set Î©
t : Set Î²
f : Î² Ã— Î© â†’ F
hX : Measurable X
hY : Measurable Y
hs : MeasurableSet s
âŠ¢ (fun a â†¦ (((condDistrib Y X Î¼) (X a)) s).toReal) =á¶ [ae Î¼] Î¼[(Y â»Â¹' s).indicator fun Ï‰ â†¦ 1|MeasurableSpace.comap X mÎ²]","theorem condDistrib_ae_eq_condexp (hX : Measurable X) (hY : Measurable Y) (hs : MeasurableSet s) :
    (fun a => (condDistrib Y X Î¼ (X a) s).toReal) =áµ[Î¼] Î¼âŸ¦Y â»Â¹' s|mÎ².comap XâŸ§ ",":= by
  refine ae_eq_condexp_of_forall_setIntegral_eq hX.comap_le ?_ ?_ ?_ ?_
  Â· exact (integrable_const _).indicator (hY hs)
  Â· exact fun t _ _ => (integrable_toReal_condDistrib hX.aemeasurable hs).integrableOn
  Â· intro t ht _
    rw [integral_toReal ((measurable_condDistrib hs).mono hX.comap_le le_rfl).aemeasurable
      (eventually_of_forall fun Ï‰ => measure_lt_top (condDistrib Y X Î¼ (X Ï‰)) _),
      integral_indicator_const _ (hY hs), Measure.restrict_apply (hY hs), smul_eq_mul, mul_one,
      inter_comm, setLIntegral_condDistrib_of_measurableSet hX hY.aemeasurable hs ht]
  Â· refine (Measurable.stronglyMeasurable ?_).aeStronglyMeasurable'
    exact @Measurable.ennreal_toReal _ (mÎ².comap X) _ (measurable_condDistrib hs)",refine theorem_condexp_ae_eq_condexp_comap hX hY hs ?_ ?_
Mathlib/Topology/Separation.lean,connectedComponent_eq_iInter_isClopen,connectedComponent_eq_iInter_isClopen,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  apply Subset.antisymm connectedComponent_subset_iInter_isClopen
  refine' IsPreconnected.subset_connectedComponent _ (mem_iInter.2 fun s => s.2.2)
  have hs : @IsClosed X _ (â‹‚ s : { s : Set X // IsClopen s âˆ§ x âˆˆ s }, s) :=
    isClosed_iInter fun s => s.2.1.1
  rw [isPreconnected_iff_subset_of_fully_disjoint_closed hs]
  intro a b ha hb hab ab_disj
  rcases normal_separation ha hb ab_disj with âŸ¨u, v, hu, hv, hau, hbv, huvâŸ©
  obtain âŸ¨s, HâŸ© : âˆƒ s : Set X, IsClopen s âˆ§ x âˆˆ s âˆ§ s âŠ† u âˆª v
  Â· have H1 := (hu.union hv).isClosed_compl.isCompact.inter_iInter_nonempty
      (fun s : { s : Set X // IsClopen s âˆ§ x âˆˆ s } => s) fun s => s.2.1.1
    rw [â† not_disjoint_iff_nonempty_inter, imp_not_comm, not_forall] at H1
    cases' H1 (disjoint_compl_left_iff_subset.2 <| hab.trans <| union_subset_union hau hbv)
      with si H2
    refine' âŸ¨â‹‚ U âˆˆ si, Subtype.val U, _, _, _âŸ©
    Â· exact isClopen_biInter_finset fun s _ => s.2.1
    Â· exact mem_iInterâ‚‚.2 fun s _ => s.2.2
    Â· rwa [â† disjoint_compl_left_iff_subset, disjoint_iff_inter_eq_empty,
        â† not_nonempty_iff_eq_empty]
  Â· have H1 := isClopen_inter_of_disjoint_cover_clopen H.1 H.2.2 hu hv huv
    rw [union_comm] at H
    have H2 := isClopen_inter_of_disjoint_cover_clopen H.1 H.2.2 hv hu huv.symm
    by_cases hxu : x âˆˆ u <;> [left; right]
    Â· suffices â‹‚ s : { s : Set X // IsClopen s âˆ§ x âˆˆ s }, â†‘s âŠ† u
        from Disjoint.left_le_of_le_sup_right hab (huv.mono this hbv)
      Â· apply Subset.trans _ (inter_subset_right s u)
        exact iInter_subset (fun s : { s : Set X // IsClopen s âˆ§ x âˆˆ s } => s.1)
          âŸ¨s âˆ© u, H1, mem_inter H.2.1 hxuâŸ©
    Â· have h1 : x âˆˆ v :=
        (hab.trans (union_subset_union hau hbv) (mem_iInter.2 fun i => i.2.2)).resolve_left hxu
      suffices â‹‚ s : { s : Set X // IsClopen s âˆ§ x âˆˆ s }, â†‘s âŠ† v
        from (huv.symm.mono this hau).left_le_of_le_sup_left hab
      Â· refine Subset.trans ?_ (inter_subset_right s v)
        exact iInter_subset (fun s : { s : Set X // IsClopen s âˆ§ x âˆˆ s } => s.1)
          âŸ¨s âˆ© v, H2, mem_inter H.2.1 h1âŸ©","error:  application type mismatch
  inter_subset_right s
argument
  s
has type
  Set X : Type u_1
but is expected to have type
  ?m.213270 âˆˆ ?m.213268 âˆ© ?m.213269 : Prop
error:  application type mismatch
  inter_subset_right s
argument
  s
has type
  Set X : Type u_1
but is expected to have type
  ?m.214224 âˆˆ ?m.214222 âˆ© ?m.214223 : Prop","theorem connectedComponent_eq_iInter_isClopen [T2Space X] [CompactSpace X] (x : X) :
    connectedComponent x = â‹‚ s : { s : Set X // IsClopen s âˆ§ x âˆˆ s }, s ",":= by
  apply Subset.antisymm connectedComponent_subset_iInter_isClopen
  refine IsPreconnected.subset_connectedComponent ?_ (mem_iInter.2 fun s => s.2.2)
  have hs : @IsClosed X _ (â‹‚ s : { s : Set X // IsClopen s âˆ§ x âˆˆ s }, s) :=
    isClosed_iInter fun s => s.2.1.1
  rw [isPreconnected_iff_subset_of_fully_disjoint_closed hs]
  intro a b ha hb hab ab_disj
  rcases normal_separation ha hb ab_disj with âŸ¨u, v, hu, hv, hau, hbv, huvâŸ©
  obtain âŸ¨s, HâŸ© : âˆƒ s : Set X, IsClopen s âˆ§ x âˆˆ s âˆ§ s âŠ† u âˆª v := by
    have H1 := (hu.union hv).isClosed_compl.isCompact.inter_iInter_nonempty
      (fun s : { s : Set X // IsClopen s âˆ§ x âˆˆ s } => s) fun s => s.2.1.1
    rw [â† not_disjoint_iff_nonempty_inter, imp_not_comm, not_forall] at H1
    cases' H1 (disjoint_compl_left_iff_subset.2 <| hab.trans <| union_subset_union hau hbv)
      with si H2
    refine âŸ¨â‹‚ U âˆˆ si, Subtype.val U, ?_, ?_, ?_âŸ©
    Â· exact isClopen_biInter_finset fun s _ => s.2.1
    Â· exact mem_iInterâ‚‚.2 fun s _ => s.2.2
    Â· rwa [â† disjoint_compl_left_iff_subset, disjoint_iff_inter_eq_empty,
        â† not_nonempty_iff_eq_empty]
  Â· have H1 := isClopen_inter_of_disjoint_cover_clopen H.1 H.2.2 hu hv huv
    rw [union_comm] at H
    have H2 := isClopen_inter_of_disjoint_cover_clopen H.1 H.2.2 hv hu huv.symm
    by_cases hxu : x âˆˆ u <;> [left; right]
    Â· suffices â‹‚ s : { s : Set X // IsClopen s âˆ§ x âˆˆ s }, â†‘s âŠ† u
        from Disjoint.left_le_of_le_sup_right hab (huv.mono this hbv)
      Â· apply Subset.trans _ s.inter_subset_right
        exact iInter_subset (fun s : { s : Set X // IsClopen s âˆ§ x âˆˆ s } => s.1)
          âŸ¨s âˆ© u, H1, mem_inter H.2.1 hxuâŸ©
    Â· have h1 : x âˆˆ v :=
        (hab.trans (union_subset_union hau hbv) (mem_iInter.2 fun i => i.2.2)).resolve_left hxu
      suffices â‹‚ s : { s : Set X // IsClopen s âˆ§ x âˆˆ s }, â†‘s âŠ† v
        from (huv.symm.mono this hau).left_le_of_le_sup_left hab
      Â· refine Subset.trans ?_ s.inter_subset_right
        exact iInter_subset (fun s : { s : Set X // IsClopen s âˆ§ x âˆˆ s } => s.1)
          âŸ¨s âˆ© v, H2, mem_inter H.2.1 h1âŸ©",rw [connectedComponent_eq_iInter_isClopen]
Mathlib/GroupTheory/Schreier.lean,Subgroup.card_commutator_dvd_index_center_pow,card_commutator_dvd_index_center_pow,9e34a191034458a56331f976ff7400a26407c888,":= by
  by_cases hG : (center G).index = 0
  Â· simp_rw [hG, MulZeroClass.zero_mul, zero_add, pow_one, dvd_zero]
  haveI : FiniteIndex (center G) := âŸ¨hGâŸ©
  rw [â† ((center G).subgroupOf (_root_.commutator G)).card_mul_index, pow_succ']
  have h1 := relindex_dvd_index_of_normal (center G) (_root_.commutator G)
  refine' mul_dvd_mul _ h1
  haveI : FiniteIndex ((center G).subgroupOf (_root_.commutator G)) :=
    âŸ¨ne_zero_of_dvd_ne_zero hG h1âŸ©
  have h2 := rank_le_index_mul_rank ((center G).subgroupOf (_root_.commutator G))
  have h3 := Nat.mul_le_mul (Nat.le_of_dvd (Nat.pos_of_ne_zero hG) h1) (rank_commutator_le_card G)
  refine' dvd_trans _ (pow_dvd_pow (center G).index (h2.trans h3))
  apply card_dvd_exponent_pow_rank'
  intro g
  have := Abelianization.commutator_subset_ker (MonoidHom.transferCenterPow G) g.1.2
  simpa only [MonoidHom.mem_ker, Subtype.ext_iff] using this","error:  application type mismatch
  mul_dvd_mul ?m.48381 h1
argument
  h1
has type
  (center G).relindex (_root_.commutator G) âˆ£ (center G).index : Prop
but is expected to have type
  ((center G).subgroupOf (_root_.commutator G)).index âˆ£
    (center G).index ^ ((center G).index * Nat.card â†‘(commutatorSet G)) : Prop
error:  application type mismatch
  dvd_trans ?m.49559 (pow_dvd_pow (center G).index (LE.le.trans h2 h3))
argument
  pow_dvd_pow (center G).index (LE.le.trans h2 h3)
has type
  (center G).index ^ Group.rank â†¥((center G).subgroupOf (_root_.commutator G)) âˆ£
    (center G).index ^ ((center G).index * Nat.card â†‘(commutatorSet G)) : Prop
but is expected to have type
  (center G).index ^ Group.rank â†¥((center G).subgroupOf (_root_.commutator G)) âˆ£ (center G).index : Prop","theorem card_commutator_dvd_index_center_pow [Finite (commutatorSet G)] :
    Nat.card (_root_.commutator G) âˆ£
      (center G).index ^ ((center G).index * Nat.card (commutatorSet G) + 1) ",":= by
  by_cases hG : (center G).index = 0
  Â· simp_rw [hG, zero_mul, zero_add, pow_one, dvd_zero]
  haveI : FiniteIndex (center G) := âŸ¨hGâŸ©
  rw [â† ((center G).subgroupOf (_root_.commutator G)).card_mul_index, pow_succ]
  have h1 := relindex_dvd_index_of_normal (center G) (_root_.commutator G)
  refine mul_dvd_mul ?_ h1
  haveI : FiniteIndex ((center G).subgroupOf (_root_.commutator G)) :=
    âŸ¨ne_zero_of_dvd_ne_zero hG h1âŸ©
  have h2 := rank_le_index_mul_rank ((center G).subgroupOf (_root_.commutator G))
  have h3 := Nat.mul_le_mul (Nat.le_of_dvd (Nat.pos_of_ne_zero hG) h1) (rank_commutator_le_card G)
  refine dvd_trans ?_ (pow_dvd_pow (center G).index (h2.trans h3))
  apply card_dvd_exponent_pow_rank'
  intro g
  have := Abelianization.commutator_subset_ker (MonoidHom.transferCenterPow G) g.1.2
  simpa only [MonoidHom.mem_ker, Subtype.ext_iff] using this","rw [â† Nat.card_commutator_dvd_index_center_pow, Nat.card_commutator_dvd_index_center_pow]"
Mathlib/GroupTheory/OrderOfElement.lean,IsOfFinOrder.mem_powers_iff_mem_zpowers,IsOfFinOrder.mem_powers_iff_mem_zpowers,4b292e8968c43193b3dbd022dfbc7ddc03b3a7a8,":=
  âŸ¨fun âŸ¨n, hnâŸ© â†¦ âŸ¨n, by simp_allâŸ©, fun âŸ¨i, hiâŸ© â†¦ âŸ¨(i % orderOf x).natAbs, by
    dsimp only
    rwa [â† zpow_ofNat, Int.natAbs_of_nonneg <| Int.emod_nonneg _ <| Int.coe_nat_ne_zero_iff_pos.2 <|
      hx.orderOf_pos, zpow_mod_orderOf]âŸ©âŸ©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a ^ OfNat.ofNat ?n
G : Type u_1
H : Type u_2
A : Type u_3
Î± : Type u_4
Î² : Type u_5
instâœ : Group G
x y : G
iâœ : â„¤
hx : IsOfFinOrder x
xâœ : y âˆˆ zpowers x
i : â„¤
hi : (fun x_1 â†¦ x ^ x_1) i = y
âŠ¢ x ^ (i % â†‘(orderOf x)).natAbs = y","lemma IsOfFinOrder.mem_powers_iff_mem_zpowers (hx : IsOfFinOrder x) :
    y âˆˆ powers x â†” y âˆˆ zpowers x ",":=
  âŸ¨fun âŸ¨n, hnâŸ© â†¦ âŸ¨n, by simp_allâŸ©, fun âŸ¨i, hiâŸ© â†¦ âŸ¨(i % orderOf x).natAbs, by
    dsimp only
    rwa [â† zpow_natCast, Int.natAbs_of_nonneg <| Int.emod_nonneg _ <|
      Int.natCast_ne_zero_iff_pos.2 <| hx.orderOf_pos, zpow_mod_orderOf]âŸ©âŸ©",rw [mem_zpowers_iff_mem_zpowers]
Mathlib/CategoryTheory/Subobject/Basic.lean,CategoryTheory.Subobject.map_pullback,map_pullback,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  revert p
  apply Quotient.ind'
  intro a
  apply Quotient.sound
  apply ThinSkeleton.equiv_of_both_ways
  Â· refine MonoOver.homMk (pullback.lift pullback.fst _ ?_) (pullback.lift_snd _ _? _)
    change _ â‰« a.arrow â‰« h = (pullback.snd â‰« g) â‰« _
    rw [assoc, â† comm, pullback.condition_assoc]
  Â· refine MonoOver.homMk (pullback.lift pullback.fst
      (PullbackCone.IsLimit.lift t (pullback.fst â‰« a.arrow) pullback.snd ?_)
      (PullbackCone.IsLimit.lift_fst _ _ _ ?_).symm) ?_
    Â· rw [â† pullback.condition, assoc]
      rfl
    Â· dsimp
      rw [pullback.lift_snd_assoc]
      apply PullbackCone.IsLimit.lift_snd","error:  unknown identifier '_?'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  pullback.lift ?h ?k ?w â‰« pullback.snd â‰« ?h
case h.a.g.refine_2
C : Type uâ‚
instâœâ´ : Category.{vâ‚, uâ‚} C
Xâœ Yâœ Zâœ : C
D : Type uâ‚‚
instâœÂ³ : Category.{vâ‚‚, uâ‚‚} D
instâœÂ² : HasPullbacks C
X Y Z W : C
f : X âŸ¶ Y
g : X âŸ¶ Z
h : Y âŸ¶ W
k : Z âŸ¶ W
instâœÂ¹ : Mono h
instâœ : Mono g
comm : f â‰« h = g â‰« k
t : IsLimit (PullbackCone.mk f g comm)
a : MonoOver Y
âŠ¢ (pullback.fst â‰« a.arrow) â‰« h = pullback.snd â‰« k
error:  unsolved goals
case h.a.g.refine_3
C : Type uâ‚
instâœâ´ : Category.{vâ‚, uâ‚} C
Xâœ Yâœ Zâœ : C
D : Type uâ‚‚
instâœÂ³ : Category.{vâ‚‚, uâ‚‚} D
instâœÂ² : HasPullbacks C
X Y Z W : C
f : X âŸ¶ Y
g : X âŸ¶ Z
h : Y âŸ¶ W
k : Z âŸ¶ W
instâœÂ¹ : Mono h
instâœ : Mono g
comm : f â‰« h = g â‰« k
t : IsLimit (PullbackCone.mk f g comm)
a : MonoOver Y
âŠ¢ pullback.lift pullback.fst (PullbackCone.IsLimit.lift t (pullback.fst â‰« a.arrow) pullback.snd â‹¯) â‹¯ â‰«
      ((MonoOver.map g).obj ((MonoOver.pullback f).obj a)).arrow =
    ((MonoOver.pullback k).obj ((MonoOver.map h).obj a)).arrow","theorem map_pullback [HasPullbacks C] {X Y Z W : C} {f : X âŸ¶ Y} {g : X âŸ¶ Z} {h : Y âŸ¶ W} {k : Z âŸ¶ W}
    [Mono h] [Mono g] (comm : f â‰« h = g â‰« k) (t : IsLimit (PullbackCone.mk f g comm))
    (p : Subobject Y) : (map g).obj ((pullback f).obj p) = (pullback k).obj ((map h).obj p) ",":= by
  revert p
  apply Quotient.ind'
  intro a
  apply Quotient.sound
  apply ThinSkeleton.equiv_of_both_ways
  Â· refine MonoOver.homMk (pullback.lift pullback.fst _ ?_) (pullback.lift_snd _ _ _)
    change _ â‰« a.arrow â‰« h = (pullback.snd â‰« g) â‰« _
    rw [assoc, â† comm, pullback.condition_assoc]
  Â· refine MonoOver.homMk (pullback.lift pullback.fst
      (PullbackCone.IsLimit.lift t (pullback.fst â‰« a.arrow) pullback.snd _)
      (PullbackCone.IsLimit.lift_fst _ _ _ ?_).symm) ?_
    Â· rw [â† pullback.condition, assoc]
      rfl
    Â· dsimp
      rw [pullback.lift_snd_assoc]
      apply PullbackCone.IsLimit.lift_snd","rw [â† pullback.condition, pullback.condition, pullback.condition]"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.OuterMeasure.coe_mkMetric,OuterMeasure.coe_mkMetric,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [â† Measure.mkMetric_toOuterMeasure]","error:  unsolved goals
Î¹ : Type u_1
X : Type u_2
Y : Type u_3
instâœÂ³ : EMetricSpace X
instâœÂ² : EMetricSpace Y
instâœÂ¹ : MeasurableSpace X
instâœ : BorelSpace X
m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ
âŠ¢ â‡‘(Measure.mkMetric m).toOuterMeasure = â‡‘(Measure.mkMetric m)","theorem OuterMeasure.coe_mkMetric [MeasurableSpace X] [BorelSpace X] (m : â„â‰¥0âˆ â†’ â„â‰¥0âˆ) :
    â‡‘(OuterMeasure.mkMetric m : OuterMeasure X) = Measure.mkMetric m ",":= by
  rw [â† Measure.mkMetric_toOuterMeasure, Measure.coe_toOuterMeasure]","simp only [OuterMeasure.coe_mkMetric, OuterMeasure.coe_mkMetric, OuterMeasure.coe_mkMetric]"
Mathlib/CategoryTheory/Abelian/ProjectiveResolution.lean,CategoryTheory.ProjectiveResolution.ofComplex_exactAt_succ,ofComplex_exactAt_succ,694d45099647cdb1c319d63779b0005e3ea54f71,":= by
  rw [HomologicalComplex.exactAt_iff' _ (n + 2) (n + 1) n (by simp only [ChainComplex.prev]; rfl)
    (by simp), ShortComplex.exact_iff_of_iso (ofComplexSc'Iso Z n)]
  apply exact_d_f","error:  unknown identifier 'ofComplexSc'Iso'
error:  unsolved goals
case f
C : Type u
instâœÂ³ : Category.{v, u} C
instâœÂ² : Abelian C
instâœÂ¹ : HasProjectiveResolutions C
instâœ : EnoughProjectives C
Z : C
n : â„•
âŠ¢ ?X âŸ¶ ?Y

case X
C : Type u
instâœÂ³ : Category.{v, u} C
instâœÂ² : Abelian C
instâœÂ¹ : HasProjectiveResolutions C
instâœ : EnoughProjectives C
Z : C
n : â„•
âŠ¢ C

case Y
C : Type u
instâœÂ³ : Category.{v, u} C
instâœÂ² : Abelian C
instâœÂ¹ : HasProjectiveResolutions C
instâœ : EnoughProjectives C
Z : C
n : â„•
âŠ¢ C","lemma ofComplex_exactAt_succ (n : â„•) :
    (ofComplex Z).ExactAt (n + 1) ",":= by
  rw [HomologicalComplex.exactAt_iff' _ (n + 1 + 1) (n + 1) n (by simp) (by simp)]
  dsimp [ofComplex, HomologicalComplex.sc', HomologicalComplex.shortComplexFunctor',
      ChainComplex.mk', ChainComplex.mk]
  simp only [ChainComplex.of_d]
  match n with
  | 0 =>
    apply exact_d_f ((ChainComplex.mkAux _ _ _ (d (Projective.Ï€ Z)) (d (d (Projective.Ï€ Z))) _ _
      0).g)
  | n+1 =>
    apply exact_d_f ((ChainComplex.mkAux _ _ _ (d (Projective.Ï€ Z)) (d (d (Projective.Ï€ Z))) _ _
      (n+1)).g)",rw [exactAt_succ_iff]
Mathlib/Logic/Encodable/Basic.lean,Encodable.mem_decodeâ‚‚,mem_decodeâ‚‚,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  simpa [decodeâ‚‚] using âŸ¨fun âŸ¨_, hâ‚, rfl, hâ‚‚âŸ© => âŸ¨hâ‚, hâ‚‚âŸ©, fun âŸ¨hâ‚, hâ‚‚âŸ© => âŸ¨_, hâ‚, rfl, hâ‚‚âŸ©âŸ©","error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #4 provided
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #4 provided","theorem mem_decodeâ‚‚' [Encodable Î±] {n : â„•} {a : Î±} :
    a âˆˆ decodeâ‚‚ Î± n â†” a âˆˆ decode n âˆ§ encode a = n ",":= by
  simpa [decodeâ‚‚, bind_eq_some] using
    âŸ¨fun âŸ¨_, hâ‚, rfl, hâ‚‚âŸ© => âŸ¨hâ‚, hâ‚‚âŸ©, fun âŸ¨hâ‚, hâ‚‚âŸ© => âŸ¨_, hâ‚, rfl, hâ‚‚âŸ©âŸ©","simp only [decodeâ‚‚, mem_decodeâ‚‚, mem_decodeâ‚‚]"
Mathlib/Data/Complex/Basic.lean,Complex.im_eq_sub_conj,im_eq_sub_conj,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  have : (â†‘2 : â„ ) * I = 2 * I := rfl
  simp only [sub_conj, ofReal_mul, ofReal_one, ofReal_bit0, mul_right_comm, this,
    mul_div_cancel_left _ (mul_ne_zero two_ne_zero I_ne_zero : 2 * I â‰  0)]","warning:  Complex does not have a doc string
warning:  Set.reProdIm does not have a doc string
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
error:  unknown identifier 'ofReal_bit0'
error:  application type mismatch
  mul_div_cancel_left ?m.124711 (mul_ne_zero two_ne_zero I_ne_zero)
argument
  mul_ne_zero two_ne_zero I_ne_zero
has type
  2 * I â‰  0 : Prop
but is expected to have type
  ?m.124709 : Type ?u.124708
error:  unsolved goals
z : â„‚
this : â†‘2 * I = 2 * I
âŠ¢ â†‘z.im = 2 * I * â†‘z.im / (2 * I)",theorem im_eq_sub_conj (z : â„‚) : (z.im : â„‚) = (z - conj z) / (2 * I) ,":= by
  simp only [sub_conj, ofReal_mul, ofReal_ofNat, mul_right_comm,
    mul_div_cancel_leftâ‚€ _ (mul_ne_zero two_ne_zero I_ne_zero : 2 * I â‰  0)]","simp_rw [theorem, im_eq_sub_conj, div_div, div_div, div_div, div_div, div_div, div_div,
  div_mul_eq_mul_div, div_mul_eq_mul_div, div_mul_eq_mul_div, div_mul_eq_mul_div, div_mul_eq_mul_div,
  div_mul_eq_mul_div, div_mul_eq_mul_div, div_mul_eq_mul_div]"
Mathlib/MeasureTheory/Integral/TorusIntegral.lean,torusIntegral_succAbove,torusIntegral_succAbove,2c616cf6d72eab2cc0cb8be21b40be572f4b56bf,":= by
  set e : â„ Ã— â„â¿ â‰ƒáµ â„â¿âºÂ¹ := (MeasurableEquiv.piFinSuccAboveEquiv (fun _ => â„) i).symm
  have hem : MeasurePreserving e :=
    (volume_preserving_piFinSuccAboveEquiv (fun _ : Fin (n + 1) => â„) i).symm _
  have heÏ€ : (e â»Â¹' Icc 0 fun _ => 2 * Ï€) = Icc 0 (2 * Ï€) Ã—Ë¢ Icc (0 : â„â¿) fun _ => 2 * Ï€ :=
    ((OrderIso.piFinSuccAboveIso (fun _ => â„) i).symm.preimage_Icc _ _).trans (Icc_prod_eq _ _)
  rw [torusIntegral, â† hem.map_eq, set_integral_map_equiv, heÏ€, Measure.volume_eq_prod,
    set_integral_prod, circleIntegral_def_Icc]
  Â· refine' set_integral_congr measurableSet_Icc fun Î¸ _ => _
    simp only [torusIntegral, â† integral_smul, deriv_circleMap, i.prod_univ_succAbove _, smul_smul,
      torusMap, circleMap_zero]
    refine' set_integral_congr measurableSet_Icc fun Î˜ _ => _
    simp only [MeasurableEquiv.piFinSuccAboveEquiv_symm_apply, i.insertNth_apply_same,
      i.insertNth_apply_succAbove, Function.comp_def]
    congr 2
    simp only [funext_iff, i.forall_iff_succAbove, circleMap, Fin.insertNth_apply_same,
      eq_self_iff_true, Fin.insertNth_apply_succAbove, imp_true_iff, and_self_iff]
  Â· have := hf.function_integrable
    rwa [â† hem.integrableOn_comp_preimage e.measurableEmbedding, heÏ€] at this","warning:  @torusIntegral does not have a doc string
error:  unknown constant 'MeasurableEquiv.piFinSuccAboveEquiv'
error:  unknown identifier 'volume_preserving_piFinSuccAboveEquiv'
error:  type mismatch
  Eq.trans (OrderIso.preimage_Icc (OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm ?m.124422 ?m.124423)
    (Icc_prod_eq ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124422)
      ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124423))
has type
  â‡‘(OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm â»Â¹' Icc ?m.124422 ?m.124423 =
    Icc ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124422).1
        ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124423).1 Ã—Ë¢
      Icc ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124422).2
        ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124423).2 : Prop
but is expected to have type
  (â‡‘e â»Â¹' Icc 0 fun x â†¦ 2 * Ï€) = Icc 0 (2 * Ï€) Ã—Ë¢ Icc 0 fun x â†¦ 2 * Ï€ : Prop
warning:  `MeasureTheory.set_integral_map_equiv` has been deprecated, use `MeasureTheory.setIntegral_map_equiv` instead
warning:  `MeasureTheory.set_integral_prod` has been deprecated, use `MeasureTheory.setIntegral_prod` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
error:  unknown constant 'MeasurableEquiv.piFinSuccAboveEquiv_symm_apply'
error:  simp made no progress","theorem torusIntegral_succAbove {f : â„‚â¿âºÂ¹ â†’ E} {c : â„‚â¿âºÂ¹} {R : â„â¿âºÂ¹} (hf : TorusIntegrable f c R)
    (i : Fin (n + 1)) :
    (âˆ¯ x in T(c, R), f x) =
      âˆ® x in C(c i, R i), âˆ¯ y in T(c âˆ˜ i.succAbove, R âˆ˜ i.succAbove), f (i.insertNth x y) ",":= by
  set e : â„ Ã— â„â¿ â‰ƒáµ â„â¿âºÂ¹ := (MeasurableEquiv.piFinSuccAbove (fun _ => â„) i).symm
  have hem : MeasurePreserving e :=
    (volume_preserving_piFinSuccAbove (fun _ : Fin (n + 1) => â„) i).symm _
  have heÏ€ : (e â»Â¹' Icc 0 fun _ => 2 * Ï€) = Icc 0 (2 * Ï€) Ã—Ë¢ Icc (0 : â„â¿) fun _ => 2 * Ï€ :=
    ((OrderIso.piFinSuccAboveIso (fun _ => â„) i).symm.preimage_Icc _ _).trans (Icc_prod_eq _ _)
  rw [torusIntegral, â† hem.map_eq, setIntegral_map_equiv, heÏ€, Measure.volume_eq_prod,
    setIntegral_prod, circleIntegral_def_Icc]
  Â· refine setIntegral_congr measurableSet_Icc fun Î¸ _ => ?_
    simp (config := { unfoldPartialApp := true }) only [e, torusIntegral, â† integral_smul,
      deriv_circleMap, i.prod_univ_succAbove _, smul_smul, torusMap, circleMap_zero]
    refine setIntegral_congr measurableSet_Icc fun Î˜ _ => ?_
    simp only [MeasurableEquiv.piFinSuccAbove_symm_apply, i.insertNth_apply_same,
      i.insertNth_apply_succAbove, (Â· âˆ˜ Â·)]
    congr 2
    simp only [funext_iff, i.forall_iff_succAbove, circleMap, Fin.insertNth_apply_same,
      eq_self_iff_true, Fin.insertNth_apply_succAbove, imp_true_iff, and_self_iff]
  Â· have := hf.function_integrable
    rwa [â† hem.integrableOn_comp_preimage e.measurableEmbedding, heÏ€] at this","simp only [theorem, insertNth, Fin.succAbove_succAbove_succAbove]"
Mathlib/Topology/ShrinkingLemma.lean,ShrinkingLemma.PartialRefinement.exists_gt,exists_gt,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  have I : (s âˆ© â‹‚ (j) (_ : j â‰  i), (v j)á¶œ) âŠ† v i := by
    simp only [subset_def, mem_inter_iff, mem_iInter, and_imp]
    intro x hxs H
    rcases mem_iUnion.1 (v.subset_iUnion hxs) with âŸ¨j, hjâŸ©
    exact (em (j = i)).elim (fun h => h â–¸ hj) fun h => (H j h hj).elim
  have C : IsClosed (s âˆ© â‹‚ (j) (_ : j â‰  i), (v j)á¶œ) :=
    IsClosed.inter hs (isClosed_biInter fun _ _ => isClosed_compl_iff.2 <| v.isOpen _)
  rcases normal_exists_closure_subset C (v.isOpen i) I with âŸ¨vi, ovi, hvi, cviâŸ©
  refine âŸ¨âŸ¨update v i vi, insert i v.carrier, ?_, ?_,? ?_, _âŸ©,? _?, _âŸ©
  Â· intro j
    rcases eq_or_ne j i with (rfl| hne) <;> simp [*, v.isOpen]
  Â· refine fun x hx => mem_iUnion.2 ?_
    rcases em (âˆƒ j â‰  i, x âˆˆ v j) with (âŸ¨j, hji, hjâŸ© | h)
    Â· use j
      rwa [update_noteq hji]
    Â· push_neg at h
      use i
      rw [update_same]
      exact hvi âŸ¨hx, mem_biInter hâŸ©
  Â· rintro j (rfl | hj)
    Â· rwa [update_same, â† v.apply_eq hi]
    Â· rw [update_noteq (ne_of_mem_of_not_mem hj hi)]
      exact v.closure_subset hj
  Â· intro j hj
    rw [mem_insert_iff, not_or] at hj
    rw [update_noteq hj.1, v.apply_eq hj.2]
  Â· refine âŸ¨subset_insert _ _, fun j hj => ?_âŸ©
    exact (update_noteq (ne_of_mem_of_not_mem hj hi) _ _).symm
  Â· exact fun hle => hi (hle.1 <| mem_insert _ _)",error:  unexpected token '?'; expected '_' or identifier,"theorem exists_gt (v : PartialRefinement u s) (hs : IsClosed s) (i : Î¹) (hi : i âˆ‰ v.carrier) :
    âˆƒ v' : PartialRefinement u s, v < v' ",":= by
  have I : (s âˆ© â‹‚ (j) (_ : j â‰  i), (v j)á¶œ) âŠ† v i := by
    simp only [subset_def, mem_inter_iff, mem_iInter, and_imp]
    intro x hxs H
    rcases mem_iUnion.1 (v.subset_iUnion hxs) with âŸ¨j, hjâŸ©
    exact (em (j = i)).elim (fun h => h â–¸ hj) fun h => (H j h hj).elim
  have C : IsClosed (s âˆ© â‹‚ (j) (_ : j â‰  i), (v j)á¶œ) :=
    IsClosed.inter hs (isClosed_biInter fun _ _ => isClosed_compl_iff.2 <| v.isOpen _)
  rcases normal_exists_closure_subset C (v.isOpen i) I with âŸ¨vi, ovi, hvi, cviâŸ©
  refine âŸ¨âŸ¨update v i vi, insert i v.carrier, ?_, ?_, ?_, ?_âŸ©, ?_, ?_âŸ©
  Â· intro j
    rcases eq_or_ne j i with (rfl| hne) <;> simp [*, v.isOpen]
  Â· refine fun x hx => mem_iUnion.2 ?_
    rcases em (âˆƒ j â‰  i, x âˆˆ v j) with (âŸ¨j, hji, hjâŸ© | h)
    Â· use j
      rwa [update_noteq hji]
    Â· push_neg at h
      use i
      rw [update_same]
      exact hvi âŸ¨hx, mem_biInter hâŸ©
  Â· rintro j (rfl | hj)
    Â· rwa [update_same, â† v.apply_eq hi]
    Â· rw [update_noteq (ne_of_mem_of_not_mem hj hi)]
      exact v.closure_subset hj
  Â· intro j hj
    rw [mem_insert_iff, not_or] at hj
    rw [update_noteq hj.1, v.apply_eq hj.2]
  Â· refine âŸ¨subset_insert _ _, fun j hj => ?_âŸ©
    exact (update_noteq (ne_of_mem_of_not_mem hj hi) _ _).symm
  Â· exact fun hle => hi (hle.1 <| mem_insert _ _)","refine âŸ¨exists_gt _ _ _ hi, fun âŸ¨i, hiâŸ© => ?_âŸ©"
Mathlib/Geometry/Manifold/VectorBundle/Basic.lean,Bundle.contMDiffWithinAt_totalSpace,contMDiffWithinAt_totalSpace,1398a4f8e73f6556f7596e1792ca741fd88f7ba6,":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, â† FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe, extChartAt_self_apply,
    modelWithCornersSelf_coe, Function.id_def]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) â»Â¹' (trivializationAt F E (f xâ‚€).proj).baseSet âˆˆ ğ“[s] xâ‚€ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  Â· simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  Â· simp only [mfld_simps]","error:  typeclass instance problem is stuck, it is often due to metavariables
  ChartedSpace ?m.25494 ?m.25497","theorem contMDiffWithinAt_totalSpace (f : M â†’ TotalSpace F E) {s : Set M} {xâ‚€ : M} :
    ContMDiffWithinAt IM (IB.prod ğ“˜(ğ•œ, F)) n f s xâ‚€ â†”
      ContMDiffWithinAt IM IB n (fun x => (f x).proj) s xâ‚€ âˆ§
      ContMDiffWithinAt IM ğ“˜(ğ•œ, F) n (fun x â†¦ (trivializationAt F E (f xâ‚€).proj (f x)).2) s xâ‚€ ",":= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, â† FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe,
    extChartAt_self_apply, modelWithCornersSelf_coe, Function.id_def, â† chartedSpaceSelf_prod]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) â»Â¹' (trivializationAt F E (f xâ‚€).proj).baseSet âˆˆ ğ“[s] xâ‚€ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  Â· simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  Â· simp only [mfld_simps]","rw [contMDiffWithinAt_theorem, contMDiffWithinAt_theorem]"
Mathlib/RingTheory/FinitePresentation.lean,RingHom.FinitePresentation.comp,comp,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":=
  letI := f.toSMul
  letI := f.toAlgebra
  letI := (g.comp f).toSMul
  letI := (g.comp f).toAlgebra
  letI : Algebra.FinitePresentation A B := hf
  Algebra.FinitePresentation.of_surjective
    (f :=
      { g with
        toFun := g
        commutes' := fun _ => rfl })
    hg hker","error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  f
has type
  A â†’+* B
error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  g.comp f
has type
  A â†’+* C","theorem comp_surjective {f : A â†’+* B} {g : B â†’+* C} (hf : f.FinitePresentation) (hg : Surjective g)
    (hker : g.ker.FG) : (g.comp f).FinitePresentation ",":=
  letI := f.toAlgebra
  letI := (g.comp f).toAlgebra
  letI : Algebra.FinitePresentation A B := hf
  Algebra.FinitePresentation.of_surjective
    (f :=
      { g with
        toFun := g
        commutes' := fun _ => rfl })
    hg hker",exact FinitePresentation.of_comp hf hg
Mathlib/Analysis/NormedSpace/Pointwise.lean,infEdist_thickening,infEdist_thickening,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain hs | hs := lt_or_le (infEdist x s) (ENNReal.ofReal Î´)
  Â· rw [infEdist_zero_of_mem, tsub_eq_zero_of_le hs.le]
    exact hs
  refine' (tsub_le_iff_right.2 infEdist_le_infEdist_thickening_add).antisymm' _
  refine' le_sub_of_add_le_right ofReal_ne_top _
  refine' le_infEdist.2 fun z hz => le_of_forall_lt' fun r h => _
  cases' r with r
  Â· exact add_lt_top.2 âŸ¨lt_top_iff_ne_top.2 <| infEdist_ne_top âŸ¨z, self_subset_thickening hÎ´ _ hzâŸ©,
      ofReal_lt_topâŸ©
  have hr : 0 < â†‘r - Î´ := by
    refine' sub_pos_of_lt _
    have := hs.trans_lt ((infEdist_le_edist_of_mem hz).trans_lt h)
    rw [ofReal_eq_coe_nnreal hÎ´.le, some_eq_coe] at this
    exact mod_cast this
  rw [some_eq_coe, edist_lt_coe, â† dist_lt_coe, â† add_sub_cancel Î´ â†‘r] at h
  obtain âŸ¨y, hxy, hyzâŸ© := exists_dist_lt_lt hr hÎ´ h
  refine' (ENNReal.add_lt_add_right ofReal_ne_top <|
    infEdist_lt_iff.2 âŸ¨_, mem_thickening_iff.2 âŸ¨_, hz, hyzâŸ©, edist_lt_ofReal.2 hxyâŸ©).trans_le _
  rw [â† ofReal_add hr.le hÎ´.le, sub_add_cancel, ofReal_coe_nnreal]
  exact le_rfl","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  some ?a
ğ•œ : Type u_1
E : Type u_2
instâœÂ³ : NormedField ğ•œ
instâœÂ² : SeminormedAddCommGroup E
instâœÂ¹ : NormedSpace ğ•œ E
instâœ : NormedSpace â„ E
xâœ y zâœ : E
Î´ Îµ : â„
hÎ´ : 0 < Î´
s : Set E
x : E
hs : ENNReal.ofReal Î´ â‰¤ infEdist x s
z : E
hz : z âˆˆ s
r : NNReal
h : edist x z < â†‘r
this : â†‘âŸ¨Î´, â‹¯âŸ© < â†‘r
âŠ¢ Î´ < â†‘r
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  some ?a
case inr.coe
ğ•œ : Type u_1
E : Type u_2
instâœÂ³ : NormedField ğ•œ
instâœÂ² : SeminormedAddCommGroup E
instâœÂ¹ : NormedSpace ğ•œ E
instâœ : NormedSpace â„ E
xâœ y zâœ : E
Î´ Îµ : â„
hÎ´ : 0 < Î´
s : Set E
x : E
hs : ENNReal.ofReal Î´ â‰¤ infEdist x s
z : E
hz : z âˆˆ s
r : NNReal
h : edist x z < â†‘r
hr : 0 < â†‘r - Î´
âŠ¢ infEdist x (thickening Î´ s) + ENNReal.ofReal Î´ < â†‘r","theorem infEdist_thickening (hÎ´ : 0 < Î´) (s : Set E) (x : E) :
    infEdist x (thickening Î´ s) = infEdist x s - ENNReal.ofReal Î´ ",":= by
  obtain hs | hs := lt_or_le (infEdist x s) (ENNReal.ofReal Î´)
  Â· rw [infEdist_zero_of_mem, tsub_eq_zero_of_le hs.le]
    exact hs
  refine (tsub_le_iff_right.2 infEdist_le_infEdist_thickening_add).antisymm' ?_
  refine le_sub_of_add_le_right ofReal_ne_top ?_
  refine le_infEdist.2 fun z hz => le_of_forall_lt' fun r h => ?_
  cases' r with r
  Â· exact add_lt_top.2 âŸ¨lt_top_iff_ne_top.2 <| infEdist_ne_top âŸ¨z, self_subset_thickening hÎ´ _ hzâŸ©,
      ofReal_lt_topâŸ©
  have hr : 0 < â†‘r - Î´ := by
    refine sub_pos_of_lt ?_
    have := hs.trans_lt ((infEdist_le_edist_of_mem hz).trans_lt h)
    rw [ofReal_eq_coe_nnreal hÎ´.le] at this
    exact mod_cast this
  rw [edist_lt_coe, â† dist_lt_coe, â† add_sub_cancel Î´ â†‘r] at h
  obtain âŸ¨y, hxy, hyzâŸ© := exists_dist_lt_lt hr hÎ´ h
  refine (ENNReal.add_lt_add_right ofReal_ne_top <|
    infEdist_lt_iff.2 âŸ¨_, mem_thickening_iff.2 âŸ¨_, hz, hyzâŸ©, edist_lt_ofReal.2 hxyâŸ©).trans_le ?_
  rw [â† ofReal_add hr.le hÎ´.le, sub_add_cancel, ofReal_coe_nnreal]","simp only [infEdist_thickening, infEdist_thickening, infEdist_thickening, infEdist_thickening,
  infEdist_thickening, infEdist_thickening]"
Mathlib/NumberTheory/Cyclotomic/Basic.lean,IsCyclotomicExtension.splitting_field_cyclotomic,splitting_field_cyclotomic,6d1b77e97159c51b0084f053ab93299f39b3a009,":=
  { splits' := splits_cyclotomic K L (mem_singleton n)
    adjoin_rootSet' := by
      rw [â† ((iff_adjoin_eq_top {n} K L).1 inferInstance).2]
      letI := Classical.decEq L
      obtain âŸ¨Î¶ : L, hÎ¶âŸ© := IsCyclotomicExtension.exists_prim_root K (mem_singleton n)
      exact adjoin_roots_cyclotomic_eq_adjoin_nth_roots hÎ¶ }","error:  typeclass instance problem is stuck, it is often due to metavariables
  IsCyclotomicExtension {n} K ?m.183753",theorem splitting_field_cyclotomic : IsSplittingField K L (cyclotomic n K) ,":=
  { splits' := splits_cyclotomic K L (mem_singleton n)
    adjoin_rootSet' := by
      rw [â† ((iff_adjoin_eq_top {n} K L).1 inferInstance).2]
      letI := Classical.decEq L
      obtain âŸ¨Î¶ : L, hÎ¶âŸ© := IsCyclotomicExtension.exists_prim_root K (B := L) (mem_singleton n)
      exact adjoin_roots_cyclotomic_eq_adjoin_nth_roots hÎ¶ }",splitting_field_cyclotomic splitting_field_cyclotomic
Mathlib/LinearAlgebra/BilinearForm/DualLattice.lean,LinearMap.BilinForm.dualSubmodule_dualSubmodule_of_basis,dualSubmodule_dualSubmodule_of_basis,31c261277bc3e8a52b74d248691ef6b40c75b452,":=
  LinearMap.BilinForm.dualSubmodule_dualSubmodule_of_basis (BilinForm.toLin B) hB hB' b","warning:  `LinearMap.BilinForm.toLin` has been deprecated
error:  application type mismatch
  dualSubmodule_dualSubmodule_of_basis (toLin B)
argument
  toLin B
has type
  M â†’â‚—[S] M â†’â‚—[S] S : Type (max u_3 u_2 u_3)
but is expected to have type
  B.Nondegenerate : Prop","lemma dualSubmodule_dualSubmodule_of_basis
    {Î¹} [Finite Î¹] (hB : B.Nondegenerate) (hB' : B.IsSymm) (b : Basis Î¹ S M) :
    B.dualSubmodule (B.dualSubmodule (Submodule.span R (Set.range b))) =
      Submodule.span R (Set.range b) ",":= by
  classical
  letI := FiniteDimensional.of_fintype_basis b
  rw [dualSubmodule_span_of_basis B hB, dualSubmodule_span_of_basis B hB,
    dualBasis_dualBasis B hB hB']",rw [â† Submodule.span_eq]
Mathlib/MeasureTheory/Measure/Haar/Basic.lean,MeasureTheory.Measure.haar.chaar_sup_eq,chaar_sup_eq,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases SeparatedNhds.of_isCompact_isCompact_isClosed Kâ‚.2 Kâ‚‚.2 hâ‚‚ h
    with âŸ¨Uâ‚, Uâ‚‚, h1Uâ‚, h1Uâ‚‚, h2Uâ‚, h2Uâ‚‚, hUâŸ©
  rcases compact_open_separated_mul_right Kâ‚.2 h1Uâ‚ h2Uâ‚ with âŸ¨Lâ‚, h1Lâ‚, h2Lâ‚âŸ©
  rcases mem_nhds_iff.mp h1Lâ‚ with âŸ¨Vâ‚, h1Vâ‚, h2Vâ‚, h3Vâ‚âŸ©
  replace h2Lâ‚ := Subset.trans (mul_subset_mul_left h1Vâ‚) h2Lâ‚
  rcases compact_open_separated_mul_right Kâ‚‚.2 h1Uâ‚‚ h2Uâ‚‚ with âŸ¨Lâ‚‚, h1Lâ‚‚, h2Lâ‚‚âŸ©
  rcases mem_nhds_iff.mp h1Lâ‚‚ with âŸ¨Vâ‚‚, h1Vâ‚‚, h2Vâ‚‚, h3Vâ‚‚âŸ©
  replace h2Lâ‚‚ := Subset.trans (mul_subset_mul_left h1Vâ‚‚) h2Lâ‚‚
  let eval : (Compacts G â†’ â„) â†’ â„ := fun f => f Kâ‚ + f Kâ‚‚ - f (Kâ‚ âŠ” Kâ‚‚)
  have : Continuous eval :=
    ((continuous_apply Kâ‚).add (continuous_apply Kâ‚‚)).sub (continuous_apply (Kâ‚ âŠ” Kâ‚‚))
  rw [eq_comm, â† sub_eq_zero]; show chaar Kâ‚€ âˆˆ eval â»Â¹' {(0 : â„)}
  let V := Vâ‚ âˆ© Vâ‚‚
  apply
    mem_of_subset_of_mem _
      (chaar_mem_clPrehaar Kâ‚€
        âŸ¨âŸ¨Vâ»Â¹, (h2Vâ‚.inter h2Vâ‚‚).preimage continuous_invâŸ©, by
          simp only [V, mem_inv, inv_one, h3Vâ‚, h3Vâ‚‚, mem_inter_iff, true_and_iff]âŸ©)
  unfold clPrehaar; rw [IsClosed.closure_subset_iff]
  Â· rintro _ âŸ¨U, âŸ¨h1U, h2U, h3UâŸ©, rflâŸ©
    simp only [eval, mem_preimage, sub_eq_zero, mem_singleton_iff]; rw [eq_comm]
    apply prehaar_sup_eq
    Â· rw [h2U.interior_eq]; exact âŸ¨1, h3UâŸ©
    Â· refine disjoint_of_subset ?_ ?_ hU
      Â· refine Subset.trans (mul_subset_mul Subset.rfl ?_) h2Lâ‚
        exact Subset.trans (inv_subset.mpr h1U) (inter_subset_left _ _)
      Â· refine Subset.trans (mul_subset_mul Subset.rfl ?_) h2Lâ‚‚
        exact Subset.trans (inv_subset.mpr h1U) (inter_subset_right _ _)
  Â· apply continuous_iff_isClosed.mp this; exact isClosed_singleton","error:  function expected at
  inter_subset_left ?m.76370
term has type
  ?m.76369 âˆˆ ?m.76367
error:  application type mismatch
  inv_subset.mpr h1U
argument
  h1U
has type
  U âŠ† â†‘{ carrier := Vâ»Â¹, is_open' := â‹¯, mem' := â‹¯ }.toOpens : Prop
but is expected to have type
  U âŠ† ?m.76202â»Â¹ : Prop
error:  function expected at
  inter_subset_right ?m.76764
term has type
  ?m.76763 âˆˆ ?m.76762
error:  application type mismatch
  inv_subset.mpr h1U
argument
  h1U
has type
  U âŠ† â†‘{ carrier := Vâ»Â¹, is_open' := â‹¯, mem' := â‹¯ }.toOpens : Prop
but is expected to have type
  U âŠ† ?m.76726â»Â¹ : Prop","theorem chaar_sup_eq {Kâ‚€ : PositiveCompacts G}
    {Kâ‚ Kâ‚‚ : Compacts G} (h : Disjoint Kâ‚.1 Kâ‚‚.1) (hâ‚‚ : IsClosed Kâ‚‚.1) :
    chaar Kâ‚€ (Kâ‚ âŠ” Kâ‚‚) = chaar Kâ‚€ Kâ‚ + chaar Kâ‚€ Kâ‚‚ ",":= by
  rcases SeparatedNhds.of_isCompact_isCompact_isClosed Kâ‚.2 Kâ‚‚.2 hâ‚‚ h
    with âŸ¨Uâ‚, Uâ‚‚, h1Uâ‚, h1Uâ‚‚, h2Uâ‚, h2Uâ‚‚, hUâŸ©
  rcases compact_open_separated_mul_right Kâ‚.2 h1Uâ‚ h2Uâ‚ with âŸ¨Lâ‚, h1Lâ‚, h2Lâ‚âŸ©
  rcases mem_nhds_iff.mp h1Lâ‚ with âŸ¨Vâ‚, h1Vâ‚, h2Vâ‚, h3Vâ‚âŸ©
  replace h2Lâ‚ := Subset.trans (mul_subset_mul_left h1Vâ‚) h2Lâ‚
  rcases compact_open_separated_mul_right Kâ‚‚.2 h1Uâ‚‚ h2Uâ‚‚ with âŸ¨Lâ‚‚, h1Lâ‚‚, h2Lâ‚‚âŸ©
  rcases mem_nhds_iff.mp h1Lâ‚‚ with âŸ¨Vâ‚‚, h1Vâ‚‚, h2Vâ‚‚, h3Vâ‚‚âŸ©
  replace h2Lâ‚‚ := Subset.trans (mul_subset_mul_left h1Vâ‚‚) h2Lâ‚‚
  let eval : (Compacts G â†’ â„) â†’ â„ := fun f => f Kâ‚ + f Kâ‚‚ - f (Kâ‚ âŠ” Kâ‚‚)
  have : Continuous eval :=
    ((continuous_apply Kâ‚).add (continuous_apply Kâ‚‚)).sub (continuous_apply (Kâ‚ âŠ” Kâ‚‚))
  rw [eq_comm, â† sub_eq_zero]; show chaar Kâ‚€ âˆˆ eval â»Â¹' {(0 : â„)}
  let V := Vâ‚ âˆ© Vâ‚‚
  apply
    mem_of_subset_of_mem _
      (chaar_mem_clPrehaar Kâ‚€
        âŸ¨âŸ¨Vâ»Â¹, (h2Vâ‚.inter h2Vâ‚‚).preimage continuous_invâŸ©, by
          simp only [V, mem_inv, inv_one, h3Vâ‚, h3Vâ‚‚, mem_inter_iff, true_and_iff]âŸ©)
  unfold clPrehaar; rw [IsClosed.closure_subset_iff]
  Â· rintro _ âŸ¨U, âŸ¨h1U, h2U, h3UâŸ©, rflâŸ©
    simp only [eval, mem_preimage, sub_eq_zero, mem_singleton_iff]; rw [eq_comm]
    apply prehaar_sup_eq
    Â· rw [h2U.interior_eq]; exact âŸ¨1, h3UâŸ©
    Â· refine disjoint_of_subset ?_ ?_ hU
      Â· refine Subset.trans (mul_subset_mul Subset.rfl ?_) h2Lâ‚
        exact Subset.trans (inv_subset.mpr h1U) inter_subset_left
      Â· refine Subset.trans (mul_subset_mul Subset.rfl ?_) h2Lâ‚‚
        exact Subset.trans (inv_subset.mpr h1U) inter_subset_right
  Â· apply continuous_iff_isClosed.mp this; exact isClosed_singleton","simp only [chaar_sup_eq, chaar_sup_eq, chaar_sup_eq, chaar_sup_eq]"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicAt.order_eq_int_iff,order_eq_int_iff,1df5e9f2d5d2defceda7b95892bf4c4bb80859af,":= by
  unfold order
  by_cases h : hf.choose_spec.order = âŠ¤
  Â· rw [h, WithTop.map_top, â† WithTop.coe_nat, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun âŸ¨g, hg_an, hg_ne, hg_eqâŸ© â†¦ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, â† AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq âŠ¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, â† mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  Â· obtain âŸ¨m, hâŸ© := WithTop.ne_top_iff_exists.mp h
    rw [â† h, WithTop.map_coe, â† WithTop.coe_nat, â† WithTop.coe_sub, WithTop.coe_inj]
    obtain âŸ¨g, hg_an, hg_ne, hg_eqâŸ© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : âˆ€á¶  (z : ğ•œ) in ğ“[â‰ ] x, f z = (z - x) ^ (â†‘m - â†‘hf.choose : â„¤) â€¢ g z
    Â· rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [â† smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), â† mul_smul,
      â† zpow_addâ‚€ (sub_ne_zero.mpr hz), â† add_sub_assoc, add_sub_cancel', zpow_ofNat, zpow_ofNat]
    exact âŸ¨fun h â†¦ âŸ¨g, hg_an, hg_ne, h â–¸ hg_eqâŸ©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero âŸ¨g, hg_an, hg_ne, hg_eqâŸ©âŸ©",error:  unexpected token 'Â·'; expected '|',"lemma order_eq_int_iff {f : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) (n : â„¤) : hf.order = n â†”
    âˆƒ g : ğ•œ â†’ E, AnalyticAt ğ•œ g x âˆ§ g x â‰  0 âˆ§ âˆ€á¶  z in ğ“[â‰ ] x, f z = (z - x) ^ n â€¢ g z ",":= by
  unfold order
  by_cases h : hf.choose_spec.order = âŠ¤
  Â· rw [h, WithTop.map_top, â† WithTop.coe_natCast, top_sub,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun âŸ¨g, hg_an, hg_ne, hg_eqâŸ© â†¦ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, â† AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq âŠ¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, â† mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  Â· obtain âŸ¨m, hâŸ© := WithTop.ne_top_iff_exists.mp h
    rw [â† h, WithTop.map_coe, â† WithTop.coe_natCast, â† coe_sub, WithTop.coe_inj]
    obtain âŸ¨g, hg_an, hg_ne, hg_eqâŸ© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : âˆ€á¶  (z : ğ•œ) in ğ“[â‰ ] x, f z = (z - x) ^ (â†‘m - â†‘hf.choose : â„¤) â€¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [â† smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), â† mul_smul,
        â† zpow_addâ‚€ (sub_ne_zero.mpr hz), â† add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact âŸ¨fun h â†¦ âŸ¨g, hg_an, hg_ne, h â–¸ hg_eqâŸ©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero âŸ¨g, hg_an, hg_ne, hg_eqâŸ©âŸ©",constructor
Mathlib/CategoryTheory/Filtered/Final.lean,CategoryTheory.Functor.final_iff_of_isFiltered,Functor.final_iff_of_isFiltered,7956d7f062ae28fc75693c8b8e8a3b9650a2faad,":= by
  refine âŸ¨fun hF => âŸ¨?_, ?_âŸ©, fun h => final_of_exists_of_isFiltered F h.1 h.2âŸ©
  Â· intro d
    obtain âŸ¨fâŸ© : Nonempty (StructuredArrow d F) := IsConnected.is_nonempty
    exact âŸ¨_, âŸ¨f.homâŸ©âŸ©
  Â· intro d c s s'
    have : colimit.Î¹ (F â‹™ coyoneda.obj (op d)) c s = colimit.Î¹ (F â‹™ coyoneda.obj (op d)) c s' := by
      apply (Final.colimitCompCoyonedaIso F d).toEquiv.injective
      subsingleton
    obtain âŸ¨c', tâ‚, tâ‚‚, hâŸ© := (Types.FilteredColimit.colimit_eq_iff.{vâ‚, vâ‚, vâ‚} _).mp this
    refine âŸ¨IsFiltered.coeq tâ‚ tâ‚‚, tâ‚ â‰« IsFiltered.coeqHom tâ‚ tâ‚‚, ?_âŸ©
    conv_rhs => rw [IsFiltered.coeq_condition tâ‚ tâ‚‚]
    dsimp only [comp_obj, coyoneda_obj_obj, unop_op, Functor.comp_map, coyoneda_obj_map] at h
    simp [reassoc_of% h]","error:  unknown tactic
error:  unsolved goals
case a
C : Type vâ‚
instâœÂ² : Category.{vâ‚, vâ‚} C
D : Type uâ‚‚
instâœÂ¹ : Category.{vâ‚, uâ‚‚} D
F : C â¥¤ D
instâœ : IsFilteredOrEmpty C
hF : F.Final
d : D
c : C
s s' : d âŸ¶ F.obj c
âŠ¢ (Final.colimitCompCoyonedaIso F d).toEquiv (colimit.Î¹ (F â‹™ coyoneda.obj { unop := d }) c s) =
    (Final.colimitCompCoyonedaIso F d).toEquiv (colimit.Î¹ (F â‹™ coyoneda.obj { unop := d }) c s')
error:  unsolved goals
case refine_2
C : Type vâ‚
instâœÂ² : Category.{vâ‚, vâ‚} C
D : Type uâ‚‚
instâœÂ¹ : Category.{vâ‚, uâ‚‚} D
F : C â¥¤ D
instâœ : IsFilteredOrEmpty C
hF : F.Final
d : D
c : C
s s' : d âŸ¶ F.obj c
this : colimit.Î¹ (F â‹™ coyoneda.obj { unop := d }) c s = colimit.Î¹ (F â‹™ coyoneda.obj { unop := d }) c s'
âŠ¢ âˆƒ c' t, s â‰« F.map t = s' â‰« F.map t","theorem Functor.final_iff_of_isFiltered [IsFilteredOrEmpty C] :
    Final F â†” (âˆ€ d, âˆƒ c, Nonempty (d âŸ¶ F.obj c)) âˆ§ (âˆ€ {d : D} {c : C} (s s' : d âŸ¶ F.obj c),
      âˆƒ (c' : C) (t : c âŸ¶ c'), s â‰« F.map t = s' â‰« F.map t) ",":= by
  refine âŸ¨fun hF => âŸ¨?_, ?_âŸ©, fun h => final_of_exists_of_isFiltered F h.1 h.2âŸ©
  Â· intro d
    obtain âŸ¨fâŸ© : Nonempty (StructuredArrow d F) := IsConnected.is_nonempty
    exact âŸ¨_, âŸ¨f.homâŸ©âŸ©
  Â· intro d c s s'
    have : colimit.Î¹ (F â‹™ coyoneda.obj (op d)) c s = colimit.Î¹ (F â‹™ coyoneda.obj (op d)) c s' := by
      apply (Final.colimitCompCoyonedaIso F d).toEquiv.injective
      exact Subsingleton.elim _ _
    obtain âŸ¨c', tâ‚, tâ‚‚, hâŸ© := (Types.FilteredColimit.colimit_eq_iff.{vâ‚, vâ‚, vâ‚} _).mp this
    refine âŸ¨IsFiltered.coeq tâ‚ tâ‚‚, tâ‚ â‰« IsFiltered.coeqHom tâ‚ tâ‚‚, ?_âŸ©
    conv_rhs => rw [IsFiltered.coeq_condition tâ‚ tâ‚‚]
    dsimp only [comp_obj, coyoneda_obj_obj, unop_op, Functor.comp_map, coyoneda_obj_map] at h
    simp [reassoc_of% h]",constructor
Mathlib/RingTheory/PowerSeries/Basic.lean,PowerSeries.monomial_zero_eq_C,monomial_zero_eq_C,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":=
  rfl","error:  type mismatch
  rfl
has type
  â‡‘(monomial R 0) = â‡‘(monomial R 0) : Prop
but is expected to have type
  â‡‘(monomial R 0) = â‡‘(C R) : Prop
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated",theorem monomial_zero_eq_C : â‡‘(monomial R 0) = C R ,":= by
  erw [monomial, Finsupp.single_zero, MvPowerSeries.monomial_zero_eq_C]","simp [monomial_zero_eq_C, monomial_zero_eq_C]"
Mathlib/Topology/MetricSpace/GromovHausdorffRealized.lean,GromovHausdorff.HD_candidatesBDist_le,HD_candidatesBDist_le,1164db871d393fc2dfe5323e37c7e1a4e844cfcd,":= by
  refine' max_le (ciSup_le fun x => _) (ciSup_le fun y => _)
  Â· have A : (â¨… y, candidatesBDist X Y (inl x, inr y)) â‰¤ candidatesBDist X Y (inl x, inr default) :=
      ciInf_le (by simpa using HD_below_aux1 0) default
    have B : dist (inl x) (inr default) â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=
      calc
        dist (inl x) (inr (default : Y)) = dist x (default : X) + 1 + dist default default := rfl
        _ â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) := by
          apply add_le_add (add_le_add _ le_rfl) <;>
            exact dist_le_diam_of_mem bounded_of_compactSpace (mem_univ _) (mem_univ _)
    exact le_trans A B
  Â· have A : (â¨… x, candidatesBDist X Y (inl x, inr y)) â‰¤ candidatesBDist X Y (inl default, inr y) :=
      ciInf_le (by simpa using HD_below_aux2 0) default
    have B : dist (inl default) (inr y) â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=
      calc
        dist (inl (default : X)) (inr y) = dist default default + 1 + dist default y := rfl
        _ â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) := by
          apply add_le_add (add_le_add _ le_rfl) <;>
            exact dist_le_diam_of_mem bounded_of_compactSpace (mem_univ _) (mem_univ _)
    exact le_trans A B","error:  unknown identifier 'bounded_of_compactSpace'
error:  unknown identifier 'bounded_of_compactSpace'
error:  unknown identifier 'bounded_of_compactSpace'
error:  unknown identifier 'bounded_of_compactSpace'","theorem HD_candidatesBDist_le :
    HD (candidatesBDist X Y) â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) ",":= by
  refine max_le (ciSup_le fun x => ?_) (ciSup_le fun y => ?_)
  Â· have A : â¨… y, candidatesBDist X Y (inl x, inr y) â‰¤ candidatesBDist X Y (inl x, inr default) :=
      ciInf_le (by simpa using HD_below_aux1 0) default
    have B : dist (inl x) (inr default) â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=
      calc
        dist (inl x) (inr (default : Y)) = dist x (default : X) + 1 + dist default default := rfl
        _ â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) := by
          gcongr <;>
            exact dist_le_diam_of_mem isBounded_of_compactSpace (mem_univ _) (mem_univ _)
    exact le_trans A B
  Â· have A : â¨… x, candidatesBDist X Y (inl x, inr y) â‰¤ candidatesBDist X Y (inl default, inr y) :=
      ciInf_le (by simpa using HD_below_aux2 0) default
    have B : dist (inl default) (inr y) â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=
      calc
        dist (inl (default : X)) (inr y) = dist default default + 1 + dist default y := rfl
        _ â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) := by
          gcongr <;>
            exact dist_le_diam_of_mem isBounded_of_compactSpace (mem_univ _) (mem_univ _)
    exact le_trans A B","have HD_candidatesBDist_le : HD (candidatesBDist X Y) â‰¤ HD (candidatesBDist X Y) := by
  apply HD_candidatesBDist_le"
Mathlib/Topology/Order/LocalExtr.lean,IsLocalExtrOn.inter,IsLocalExtrOn.inter,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  hf.on_subset (inter_subset_left s t)","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set Î± : Type u
but is expected to have type
  ?m.3021 âˆˆ ?m.3019 âˆ© ?m.3020 : Prop",theorem IsLocalExtrOn.inter (hf : IsLocalExtrOn f s a) (t) : IsLocalExtrOn f (s âˆ© t) a ,":=
  hf.on_subset inter_subset_left",refine IsLocalExtrOn.inter_of_isLocalExtrOn f (s âˆ© t) _ _ _ _ _ _ _ _ ?_ ?_
Mathlib/GroupTheory/SpecificGroups/Dihedral.lean,DihedralGroup.orderOf_sr,orderOf_sr,81ba544bf02abe18dd2aecc651188fac71cf454e,":= by
  apply orderOf_eq_prime
  Â· rw [sq, sr_mul_self]
  Â· 
    revert n
    simp_rw [one_def, ne_eq, forall_const]","error:  unsolved goals
case hg1
âŠ¢ Â¬False",theorem orderOf_sr (i : ZMod n) : orderOf (sr i) = 2 ,":= by
  apply orderOf_eq_prime
  Â· rw [sq, sr_mul_self]
  Â· 
    revert n
    simp_rw [one_def, ne_eq, forall_const, not_false_eq_true]","rw [orderOf_sr, orderOf_sr]"
Mathlib/Topology/ContinuousFunction/Bounded.lean,BoundedContinuousFunction.arzela_ascoli,arzela_ascoli,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  simp_rw [Equicontinuous, Metric.equicontinuousAt_iff_pair] at H
  refine isCompact_of_totallyBounded_isClosed ?_ closed
  refine totallyBounded_of_finite_discretization fun Îµ Îµ0 => ?_
  rcases exists_between Îµ0 with âŸ¨Îµâ‚, Îµâ‚0, ÎµÎµâ‚âŸ©
  let Îµâ‚‚ := Îµâ‚ / 2 / 2
  have Îµâ‚‚0 : Îµâ‚‚ > 0 := half_pos (half_pos Îµâ‚0)
  have : âˆ€ x : Î±, âˆƒ U, x âˆˆ U âˆ§ IsOpen U âˆ§
      âˆ€ y âˆˆ U, âˆ€ z âˆˆ U, âˆ€ {f : Î± â†’áµ‡ Î²}, f âˆˆ A â†’ dist (f y) (f z) < Îµâ‚‚ := fun x =>
    let âŸ¨U, nhdsU, hUâŸ© := H x _ Îµâ‚‚0
    let âŸ¨V, VU, openV, xVâŸ© := _root_.mem_nhds_iff.1 nhdsU
    âŸ¨V, xV, openV, fun y hy z hz f hf => hU y (VU hy) z (VU hz) âŸ¨f, hfâŸ©âŸ©
  choose U hU using this
  rcases isCompact_univ.elim_finite_subcover_image (fun x _ => (hU x).2.1) fun x _ =>
      mem_biUnion (mem_univ _) (hU x).1 with
    âŸ¨tÎ±, _, hfin, htÎ±âŸ©
  rcases hfin.nonempty_fintype with âŸ¨_âŸ©
  rcases @finite_cover_balls_of_compact Î² _ _ isCompact_univ _ Îµâ‚‚0 with âŸ¨tÎ², _, hfin, htÎ²âŸ©
  rcases hfin.nonempty_fintype with âŸ¨_âŸ©
  choose F hF using fun y => show âˆƒ z âˆˆ tÎ², dist y z < Îµâ‚‚ by simpa using htÎ² (mem_univ y)
  refine âŸ¨tÎ± â†’ tÎ², by infer_instance, fun f a => âŸ¨F (f.1 a), (hF (f.1 a)).1âŸ©, ?_âŸ©
  rintro âŸ¨f, hfâŸ© âŸ¨g, hgâŸ© f_eq_g
  refine lt_of_le_of_lt ((dist_le <| le_of_lt Îµâ‚0).2 fun x => ?_) ÎµÎµâ‚
  obtain âŸ¨x', x'tÎ±, hx'âŸ© := mem_iUnionâ‚‚.1 (htÎ± (mem_univ x))
  calc
    dist (f x) (g x) â‰¤ dist (f x) (f x') + dist (g x) (g x') + dist (f x') (g x') :=
      dist_triangle4_right _ _ _ _
    _ â‰¤ Îµâ‚‚ + Îµâ‚‚ + Îµâ‚ / 2 := by
      refine le_of_lt (add_lt_add (add_lt_add ?_ ?_)? _)
      Â· exact (hU x').2.2 _ hx' _ (hU x').1 hf
      Â· exact (hU x').2.2 _ hx' _ (hU x').1 hg
      Â· have F_f_g : F (f x') = F (g x') :=
          (congr_arg (fun f : tÎ± â†’ tÎ² => (f âŸ¨x', x'tÎ±âŸ© : Î²)) f_eq_g : _)
        calc
          dist (f x') (g x') â‰¤ dist (f x') (F (f x')) + dist (g x') (F (f x')) :=
            dist_triangle_right _ _ _
          _ = dist (f x') (F (f x')) + dist (g x') (F (g x')) := by rw [F_f_g]
          _ < Îµâ‚‚ + Îµâ‚‚ := (add_lt_add (hF (f x')).2 (hF (g x')).2)
          _ = Îµâ‚ / 2 := add_halves _
    _ = Îµâ‚ := by rw [add_halves, add_halves]","error:  unexpected token '?'; expected ')', ',' or ':'
error:  unsolved goals
case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.mk.mk.intro.intro.calc.step
Fâœ : Type u_1
Î± : Type u
Î² : Type v
Î³ : Type w
instâœÂ³ : TopologicalSpace Î±
instâœÂ² : CompactSpace Î±
instâœÂ¹ : PseudoMetricSpace Î²
fâœ gâœ : Î± â†’áµ‡ Î²
xâœ : Î±
C : â„
instâœ : CompactSpace Î²
A : Set (Î± â†’áµ‡ Î²)
closed : IsClosed A
H : âˆ€ (xâ‚€ : Î±), âˆ€ Îµ > 0, âˆƒ U âˆˆ ğ“ xâ‚€, âˆ€ x âˆˆ U, âˆ€ x' âˆˆ U, âˆ€ (i : â†‘A), dist (â†‘i x) (â†‘i x') < Îµ
Îµ : â„
Îµ0 : Îµ > 0
Îµâ‚ : â„
Îµâ‚0 : 0 < Îµâ‚
ÎµÎµâ‚ : Îµâ‚ < Îµ
Îµâ‚‚ : â„ := Îµâ‚ / 2 / 2
Îµâ‚‚0 : Îµâ‚‚ > 0
U : Î± â†’ Set Î±
hU : âˆ€ (x : Î±), x âˆˆ U x âˆ§ IsOpen (U x) âˆ§ âˆ€ y âˆˆ U x, âˆ€ z âˆˆ U x, âˆ€ {f : Î± â†’áµ‡ Î²}, f âˆˆ A â†’ dist (f y) (f z) < Îµâ‚‚
tÎ± : Set Î±
leftâœÂ¹ : tÎ± âŠ† univ
hfinâœ : tÎ±.Finite
htÎ± : univ âŠ† â‹ƒ i âˆˆ tÎ±, U i
valâœÂ¹ : Fintype â†‘tÎ±
tÎ² : Set Î²
leftâœ : tÎ² âŠ† univ
hfin : tÎ².Finite
htÎ² : univ âŠ† â‹ƒ x âˆˆ tÎ², ball x Îµâ‚‚
valâœ : Fintype â†‘tÎ²
F : Î² â†’ Î²
hF : âˆ€ (y : Î²), F y âˆˆ tÎ² âˆ§ dist y (F y) < Îµâ‚‚
f : Î± â†’áµ‡ Î²
hf : f âˆˆ A
g : Î± â†’áµ‡ Î²
hg : g âˆˆ A
f_eq_g : (fun f a â†¦ âŸ¨F (â†‘f â†‘a), â‹¯âŸ©) âŸ¨f, hfâŸ© = (fun f a â†¦ âŸ¨F (â†‘f â†‘a), â‹¯âŸ©) âŸ¨g, hgâŸ©
x x' : Î±
x'tÎ± : x' âˆˆ tÎ±
hx' : x âˆˆ U x'
âŠ¢ Îµâ‚‚ + Îµâ‚‚ + Îµâ‚ / 2 â‰¤ Îµâ‚","theorem arzela_ascoliâ‚ [CompactSpace Î²] (A : Set (Î± â†’áµ‡ Î²)) (closed : IsClosed A)
    (H : Equicontinuous ((â†‘) : A â†’ Î± â†’ Î²)) : IsCompact A ",":= by
  simp_rw [Equicontinuous, Metric.equicontinuousAt_iff_pair] at H
  refine isCompact_of_totallyBounded_isClosed ?_ closed
  refine totallyBounded_of_finite_discretization fun Îµ Îµ0 => ?_
  rcases exists_between Îµ0 with âŸ¨Îµâ‚, Îµâ‚0, ÎµÎµâ‚âŸ©
  let Îµâ‚‚ := Îµâ‚ / 2 / 2
  have Îµâ‚‚0 : Îµâ‚‚ > 0 := half_pos (half_pos Îµâ‚0)
  have : âˆ€ x : Î±, âˆƒ U, x âˆˆ U âˆ§ IsOpen U âˆ§
      âˆ€ y âˆˆ U, âˆ€ z âˆˆ U, âˆ€ {f : Î± â†’áµ‡ Î²}, f âˆˆ A â†’ dist (f y) (f z) < Îµâ‚‚ := fun x =>
    let âŸ¨U, nhdsU, hUâŸ© := H x _ Îµâ‚‚0
    let âŸ¨V, VU, openV, xVâŸ© := _root_.mem_nhds_iff.1 nhdsU
    âŸ¨V, xV, openV, fun y hy z hz f hf => hU y (VU hy) z (VU hz) âŸ¨f, hfâŸ©âŸ©
  choose U hU using this
  obtain âŸ¨tÎ± : Set Î±, _, hfin, htÎ± : univ âŠ† â‹ƒ x âˆˆ tÎ±, U xâŸ© :=
    isCompact_univ.elim_finite_subcover_image (fun x _ => (hU x).2.1) fun x _ =>
      mem_biUnion (mem_univ _) (hU x).1
  rcases hfin.nonempty_fintype with âŸ¨_âŸ©
  obtain âŸ¨tÎ² : Set Î², _, hfin, htÎ² : univ âŠ† â‹ƒy âˆˆ tÎ², ball y Îµâ‚‚âŸ© :=
    @finite_cover_balls_of_compact Î² _ _ isCompact_univ _ Îµâ‚‚0
  rcases hfin.nonempty_fintype with âŸ¨_âŸ©
  choose F hF using fun y => show âˆƒ z âˆˆ tÎ², dist y z < Îµâ‚‚ by simpa using htÎ² (mem_univ y)
  refine âŸ¨tÎ± â†’ tÎ², by infer_instance, fun f a => âŸ¨F (f.1 a), (hF (f.1 a)).1âŸ©, ?_âŸ©
  rintro âŸ¨f, hfâŸ© âŸ¨g, hgâŸ© f_eq_g
  refine lt_of_le_of_lt ((dist_le <| le_of_lt Îµâ‚0).2 fun x => ?_) ÎµÎµâ‚
  obtain âŸ¨x', x'tÎ±, hx'âŸ© := mem_iUnionâ‚‚.1 (htÎ± (mem_univ x))
  calc
    dist (f x) (g x) â‰¤ dist (f x) (f x') + dist (g x) (g x') + dist (f x') (g x') :=
      dist_triangle4_right _ _ _ _
    _ â‰¤ Îµâ‚‚ + Îµâ‚‚ + Îµâ‚ / 2 := by
      refine le_of_lt (add_lt_add (add_lt_add ?_ ?_) ?_)
      Â· exact (hU x').2.2 _ hx' _ (hU x').1 hf
      Â· exact (hU x').2.2 _ hx' _ (hU x').1 hg
      Â· have F_f_g : F (f x') = F (g x') :=
          (congr_arg (fun f : tÎ± â†’ tÎ² => (f âŸ¨x', x'tÎ±âŸ© : Î²)) f_eq_g : _)
        calc
          dist (f x') (g x') â‰¤ dist (f x') (F (f x')) + dist (g x') (F (f x')) :=
            dist_triangle_right _ _ _
          _ = dist (f x') (F (f x')) + dist (g x') (F (g x')) := by rw [F_f_g]
          _ < Îµâ‚‚ + Îµâ‚‚ := (add_lt_add (hF (f x')).2 (hF (g x')).2)
          _ = Îµâ‚ / 2 := add_halves _
    _ = Îµâ‚ := by rw [add_halves, add_halves]",refine isCompact_iff_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact_of_isCompact A ?_
Mathlib/RingTheory/IntegralClosure.lean,RingHom.IsIntegralElem.of_mem_closure,RingHom.IsIntegralElem.of_mem_closure,787f21e24c1b4d0e7a88ac6d76f18bfb080d4d5c,":= by
  letI : Algebra R S := f.toAlgebra
  have := (IsIntegral.fg_adjoin_singleton hx).mul (IsIntegral.fg_adjoin_singleton hy)
  rw [â† Algebra.adjoin_union_coe_submodule, Set.singleton_union] at this
  exact
    IsIntegral.of_mem_of_fg (Algebra.adjoin R {x, y}) this z
      (Algebra.mem_adjoin_iff.2 <| Subring.closure_mono (Set.subset_union_right _ _) hz)","error:  function expected at
  Set.subset_union_right ?m.186439
term has type
  ?m.186438 âˆˆ ?m.186436 âˆª ?m.186437","theorem RingHom.IsIntegralElem.of_mem_closure {x y z : S} (hx : f.IsIntegralElem x)
    (hy : f.IsIntegralElem y) (hz : z âˆˆ Subring.closure ({x, y} : Set S)) : f.IsIntegralElem z ",":= by
  letI : Algebra R S := f.toAlgebra
  have := (IsIntegral.fg_adjoin_singleton hx).mul (IsIntegral.fg_adjoin_singleton hy)
  rw [â† Algebra.adjoin_union_coe_submodule, Set.singleton_union] at this
  exact
    IsIntegral.of_mem_of_fg (Algebra.adjoin R {x, y}) this z
      (Algebra.mem_adjoin_iff.2 <| Subring.closure_mono Set.subset_union_right hz)",apply Subring.closure_insert_subset
Mathlib/Order/WellFoundedSet.lean,Set.WellFoundedOn.acc_iff_wellFoundedOn,acc_iff_wellFoundedOn,9973ad6d9c71296bde9b541823189ecbd49322ba,":= by
  tfae_have : 1 â†’ 2 := by
    refine fun h => âŸ¨fun b => InvImage.accessible _ ?_âŸ©
    rw [â† acc_transGen_iff] at h âŠ¢
    obtain h' | h' := reflTransGen_iff_eq_or_transGen.1 b.2
    Â· rwa [h'] at h
    Â· exact h.inv h'
  tfae_have : 2 â†’ 3 := fun h => h.subset fun _ => TransGen.to_reflTransGen
  tfae_have : 3 â†’ 1 := by
    refine fun h => Acc.intro _ (fun b hb => (h.apply âŸ¨b, .single hbâŸ©).of_fibration Subtype.val ?_)
    exact fun âŸ¨c, hcâŸ© d h => âŸ¨âŸ¨d, .head h hcâŸ©, h, rflâŸ©
  tfae_finish",error:  unexpected token ':'; expected numeral,"theorem acc_iff_wellFoundedOn {Î±} {r : Î± â†’ Î± â†’ Prop} {a : Î±} :
    TFAE [Acc r a,
      WellFoundedOn { b | ReflTransGen r b a } r,
      WellFoundedOn { b | TransGen r b a } r] ",":= by
  tfae_have 1 â†’ 2
  Â· refine fun h => âŸ¨fun b => InvImage.accessible _ ?_âŸ©
    rw [â† acc_transGen_iff] at h âŠ¢
    obtain h' | h' := reflTransGen_iff_eq_or_transGen.1 b.2
    Â· rwa [h'] at h
    Â· exact h.inv h'
  tfae_have 2 â†’ 3
  Â· exact fun h => h.subset fun _ => TransGen.to_reflTransGen
  tfae_have 3 â†’ 1
  Â· refine fun h => Acc.intro _ (fun b hb => (h.apply âŸ¨b, .single hbâŸ©).of_fibration Subtype.val ?_)
    exact fun âŸ¨c, hcâŸ© d h => âŸ¨âŸ¨d, .head h hcâŸ©, h, rflâŸ©
  tfae_finish",simp only [reflTransGen_eq_transGen]
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exist_disjoint_covering_families,exist_disjoint_covering_families,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  cases isEmpty_or_nonempty Î²
  Â· refine' âŸ¨fun _ => âˆ…, fun _ => pairwiseDisjoint_empty, _âŸ©
    rw [â† image_univ, eq_empty_of_isEmpty (univ : Set Î²)]
    simp
  let p : TauPackage Î² Î± :=
    { q with
      Ï„
      one_lt_tau := hÏ„ }
  let s := fun i : Fin N =>
    â‹ƒ (k : Ordinal.{u}) (_ : k < p.lastStep) (_ : p.color k = i), ({p.index k} : Set Î²)
  refine' âŸ¨s, fun i => _, _âŸ©
  Â· 
    intro x hx y hy x_ne_y
    obtain âŸ¨jx, jx_lt, jxi, rflâŸ© :
      âˆƒ jx : Ordinal, jx < p.lastStep âˆ§ p.color jx = i âˆ§ x = p.index jx := by
      simpa only [exists_prop, mem_iUnion, mem_singleton_iff] using hx
    obtain âŸ¨jy, jy_lt, jyi, rflâŸ© :
      âˆƒ jy : Ordinal, jy < p.lastStep âˆ§ p.color jy = i âˆ§ y = p.index jy := by
      simpa only [exists_prop, mem_iUnion, mem_singleton_iff] using hy
    wlog jxy : jx â‰¤ jy generalizing jx jy
    Â· exact (this jy jy_lt jyi hy jx jx_lt jxi hx x_ne_y.symm (le_of_not_le jxy)).symm
    replace jxy : jx < jy := by
      rcases lt_or_eq_of_le jxy with (H | rfl); Â· { exact H }; Â· { exact (x_ne_y rfl).elim }
    let A : Set â„• :=
      â‹ƒ (j : { j // j < jy })
        (_ : (closedBall (p.c (p.index j)) (p.r (p.index j)) âˆ©
          closedBall (p.c (p.index jy)) (p.r (p.index jy))).Nonempty),
        {p.color j}
    have color_j : p.color jy = sInf (univ \ A) := by rw [TauPackage.color]
    have h : p.color jy âˆˆ univ \ A := by
      rw [color_j]
      apply csInf_mem
      refine' âŸ¨N, _âŸ©
      simp only [not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff, not_and,
        mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]
      intro k hk _
      exact (p.color_lt (hk.trans jy_lt) hN).ne'
    simp only [not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff, not_and,
      mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk] at h
    specialize h jx jxy
    contrapose! h
    simpa only [jxi, jyi, and_true_iff, eq_self_iff_true, â† not_disjoint_iff_nonempty_inter] using h
  Â· 
    refine' range_subset_iff.2 fun b => _
    obtain âŸ¨a, haâŸ© :
      âˆƒ a : Ordinal, a < p.lastStep âˆ§ dist (p.c b) (p.c (p.index a)) < p.r (p.index a) := by
      simpa only [iUnionUpTo, exists_prop, mem_iUnion, mem_ball, Subtype.exists,
        Subtype.coe_mk] using p.mem_iUnionUpTo_lastStep b
    simp only [exists_prop, mem_iUnion, mem_ball, mem_singleton_iff, biUnion_and', exists_eq_left,
      iUnion_exists, exists_and_left]
    exact âŸ¨âŸ¨p.color a, p.color_lt ha.1 hNâŸ©, a, rfl, haâŸ©","error:  type mismatch
  hâœ
has type
  x âˆˆ s i : Prop
but is expected to have type
  âˆƒ jx < p.lastStep, p.color jx = â†‘i âˆ§ x = p.index jx : Prop
error:  type mismatch
  hâœ
has type
  y âˆˆ s i : Prop
but is expected to have type
  âˆƒ jy < p.lastStep, p.color jy = â†‘i âˆ§ y = p.index jy : Prop
error:  tactic 'introN' failed, insufficient number of binders
case hs
Î± : Type u_1
instâœ : MetricSpace Î±
Î² : Type u
N : â„•
Ï„ : â„
hÏ„ : 1 < Ï„
hN : IsEmpty (SatelliteConfig Î± N Ï„)
q : BallPackage Î² Î±
hâœ : Nonempty Î²
p : TauPackage Î² Î± := { toBallPackage := q, Ï„ := Ï„, one_lt_tau := hÏ„ }
s : Fin N â†’ Set Î² := fun i â†¦ â‹ƒ k, â‹ƒ (_ : k < p.lastStep), â‹ƒ (_ : p.color k = â†‘i), {p.index k}
i : Fin N
jx : Ordinal.{u}
jx_lt : jx < p.lastStep
jxi : p.color jx = â†‘i
hx : p.index jx âˆˆ s i
jy : Ordinal.{u}
jy_lt : jy < p.lastStep
jyi : p.color jy = â†‘i
hy : p.index jy âˆˆ s i
x_ne_y : p.index jx â‰  p.index jy
jxy : jx < jy
A : Set â„• :=
  â‹ƒ j,
    â‹ƒ (_ :
      (closedBall (p.c (p.index â†‘j)) (p.r (p.index â†‘j)) âˆ© closedBall (p.c (p.index jy)) (p.r (p.index jy))).Nonempty),
      {p.color â†‘j}
color_j : p.color jy = sInf (univ \ A)
k : N âˆˆ A
âŠ¢ False
error:  application type mismatch
  h jx
argument
  jx
has type
  Ordinal.{u} : Type (u + 1)
but is expected to have type
  p.color jy âˆˆ A : Prop
error:  'specialize' requires a term of the form `h x_1 .. x_n` where `h` appears in the local context
error:  application type mismatch
  Exists.intro a
argument
  a
has type
  Ordinal.{u} : Type (u + 1)
but is expected to have type
  Î² : Type u","theorem exist_disjoint_covering_families {N : â„•} {Ï„ : â„} (hÏ„ : 1 < Ï„)
    (hN : IsEmpty (SatelliteConfig Î± N Ï„)) (q : BallPackage Î² Î±) :
    âˆƒ s : Fin N â†’ Set Î²,
      (âˆ€ i : Fin N, (s i).PairwiseDisjoint fun j => closedBall (q.c j) (q.r j)) âˆ§
        range q.c âŠ† â‹ƒ i : Fin N, â‹ƒ j âˆˆ s i, ball (q.c j) (q.r j) ",":= by
  cases isEmpty_or_nonempty Î²
  Â· refine âŸ¨fun _ => âˆ…, fun _ => pairwiseDisjoint_empty, ?_âŸ©
    rw [â† image_univ, eq_empty_of_isEmpty (univ : Set Î²)]
    simp
  let p : TauPackage Î² Î± :=
    { q with
      Ï„
      one_lt_tau := hÏ„ }
  let s := fun i : Fin N =>
    â‹ƒ (k : Ordinal.{u}) (_ : k < p.lastStep) (_ : p.color k = i), ({p.index k} : Set Î²)
  refine âŸ¨s, fun i => ?_, ?_âŸ©
  Â· 
    intro x hx y hy x_ne_y
    obtain âŸ¨jx, jx_lt, jxi, rflâŸ© :
      âˆƒ jx : Ordinal, jx < p.lastStep âˆ§ p.color jx = i âˆ§ x = p.index jx := by
      simpa only [s, exists_prop, mem_iUnion, mem_singleton_iff] using hx
    obtain âŸ¨jy, jy_lt, jyi, rflâŸ© :
      âˆƒ jy : Ordinal, jy < p.lastStep âˆ§ p.color jy = i âˆ§ y = p.index jy := by
      simpa only [s, exists_prop, mem_iUnion, mem_singleton_iff] using hy
    wlog jxy : jx â‰¤ jy generalizing jx jy
    Â· exact (this jy jy_lt jyi hy jx jx_lt jxi hx x_ne_y.symm (le_of_not_le jxy)).symm
    replace jxy : jx < jy := by
      rcases lt_or_eq_of_le jxy with (H | rfl); Â· { exact H }; Â· { exact (x_ne_y rfl).elim }
    let A : Set â„• :=
      â‹ƒ (j : { j // j < jy })
        (_ : (closedBall (p.c (p.index j)) (p.r (p.index j)) âˆ©
          closedBall (p.c (p.index jy)) (p.r (p.index jy))).Nonempty),
        {p.color j}
    have color_j : p.color jy = sInf (univ \ A) := by rw [TauPackage.color]
    have h : p.color jy âˆˆ univ \ A := by
      rw [color_j]
      apply csInf_mem
      refine âŸ¨N, ?_âŸ©
      simp only [A, not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff, not_and,
        mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]
      intro k hk _
      exact (p.color_lt (hk.trans jy_lt) hN).ne'
    simp only [A, not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff, not_and,
      mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk] at h
    specialize h jx jxy
    contrapose! h
    simpa only [jxi, jyi, and_true_iff, eq_self_iff_true, â† not_disjoint_iff_nonempty_inter] using h
  Â· 
    refine range_subset_iff.2 fun b => ?_
    obtain âŸ¨a, haâŸ© :
      âˆƒ a : Ordinal, a < p.lastStep âˆ§ dist (p.c b) (p.c (p.index a)) < p.r (p.index a) := by
      simpa only [iUnionUpTo, exists_prop, mem_iUnion, mem_ball, Subtype.exists,
        Subtype.coe_mk] using p.mem_iUnionUpTo_lastStep b
    simp only [s, exists_prop, mem_iUnion, mem_ball, mem_singleton_iff, biUnion_and',
      exists_eq_left, iUnion_exists, exists_and_left]
    exact âŸ¨âŸ¨p.color a, p.color_lt ha.1 hNâŸ©, a, rfl, haâŸ©","rcases exist_disjoint_covering_families hÏ„ hN with
  âŸ¨s, hs, hNâŸ©"
Mathlib/RingTheory/HahnSeries/Addition.lean,HahnSeries.min_order_le_order_add,min_order_le_order_add,428beac5eff6f206aaf1173f89acbc7fd5adf7db,":= by
  by_cases hx : x = 0; Â· simp [hx]
  by_cases hy : y = 0; Â· simp [hy]
  rw [order_of_ne hx, order_of_ne hy, order_of_ne hxy]
  exact MinLEMinAdd hx hy hxy",error:  unknown identifier 'MinLEMinAdd',"theorem min_order_le_order_add {Î“} [Zero Î“] [LinearOrder Î“] {x y : HahnSeries Î“ R}
    (hxy : x + y â‰  0) : min x.order y.order â‰¤ (x + y).order ",":= by
  by_cases hx : x = 0; Â· simp [hx]
  by_cases hy : y = 0; Â· simp [hy]
  rw [order_of_ne hx, order_of_ne hy, order_of_ne hxy]
  apply le_of_eq_of_le _ (Set.IsWF.min_le_min_of_subset (support_add_subset (x := x) (y := y)))
  Â· simp
  Â· simp [hy]
  Â· exact (Set.IsWF.min_union _ _ _ _).symm",rw [order_of_order_le_order hxy]
Mathlib/GroupTheory/Index.lean,Subgroup.index_eq_two_iff,index_eq_two_iff,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  simp only [index, Nat.card_eq_two_iff' ((1 : G) : G â§¸ H), ExistsUnique, inv_mem_iff,
    QuotientGroup.exists_mk, QuotientGroup.forall_mk, Ne, QuotientGroup.eq, mul_one,
    xor_iff_iff_not]
  refine
    exists_congr fun a => âŸ¨fun ha b => âŸ¨fun hba hb => ?_, fun hb =>? _âŸ©, fun ha => ?âŸ¨_, fun b hb ?=> _âŸ©âŸ©
  Â· exact ha.1 ((mul_mem_cancel_left hb).1 hba)
  Â· exact inv_inv b â–¸ ha.2 _ (mt (inv_mem_iff (x := b)).1 hb)
  Â· rw [â† inv_mem_iff (x := a), â† ha, inv_mul_self]
    exact one_mem _
  Â· rwa [ha, inv_mem_iff (x := b)]","error:  unexpected token 'âŸ¨'; expected '_' or identifier
error:  unsolved goals
case refine_1
G : Type u_1
instâœ : Group G
H K L : Subgroup G
a : G
ha : a âˆ‰ H âˆ§ âˆ€ x âˆ‰ H, xâ»Â¹ * a âˆˆ H
b : G
hba : b * a âˆˆ H
hb : b âˆˆ H
âŠ¢ False

case refine_2
G : Type u_1
instâœ : Group G
H K L : Subgroup G
a : G
ha : a âˆ‰ H âˆ§ âˆ€ x âˆ‰ H, xâ»Â¹ * a âˆˆ H
b : G
hb : b âˆ‰ H
âŠ¢ b * a âˆˆ H

case refine_3
G : Type u_1
instâœ : Group G
H K L : Subgroup G
a : G
ha : âˆ€ (b : G), b * a âˆˆ H â†” b âˆ‰ H
âŠ¢ a âˆ‰ H âˆ§ âˆ€ x âˆ‰ H, xâ»Â¹ * a âˆˆ H","theorem index_eq_two_iff : H.index = 2 â†” âˆƒ a, âˆ€ b, Xor' (b * a âˆˆ H) (b âˆˆ H) ",":= by
  simp only [index, Nat.card_eq_two_iff' ((1 : G) : G â§¸ H), ExistsUnique, inv_mem_iff,
    QuotientGroup.exists_mk, QuotientGroup.forall_mk, Ne, QuotientGroup.eq, mul_one,
    xor_iff_iff_not]
  refine exists_congr fun a =>
    âŸ¨fun ha b => âŸ¨fun hba hb => ?_, fun hb => ?_âŸ©, fun ha => âŸ¨?_, fun b hb => ?_âŸ©âŸ©
  Â· exact ha.1 ((mul_mem_cancel_left hb).1 hba)
  Â· exact inv_inv b â–¸ ha.2 _ (mt (inv_mem_iff (x := b)).1 hb)
  Â· rw [â† inv_mem_iff (x := a), â† ha, inv_mul_self]
    exact one_mem _
  Â· rwa [ha, inv_mem_iff (x := b)]",rw [index_eq_two_iff] at index_eq_two_iff
Mathlib/Data/DFinsupp/WellFounded.lean,DFinsupp.lex_fibration,lex_fibration,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rintro âŸ¨p, xâ‚, xâ‚‚âŸ© x âŸ¨i, hr, hsâŸ©
  simp_rw [piecewise_apply] at hs hr
  split_ifs at hs with hp
  Â· refine âŸ¨âŸ¨{ j | r j i â†’ j âˆˆ p }, piecewise xâ‚ x { j | r j i }, xâ‚‚âŸ©,
      .fst âŸ¨i, fun j hj â†¦ ?_, ?_âŸ©, ?_âŸ© <;> simp only [piecewise_apply, Set.mem_setOf_eq]
    Â· simp only [if_pos hj]
    Â· split_ifs with hi
      Â· rwa [hr i hi, if_pos hp] at hs
      Â· assumption
    Â· ext1 j
      simp only [piecewise_apply, Set.mem_setOf_eq]
      split_ifs with hâ‚ hâ‚‚ <;> try rfl
      Â· rw [hr j hâ‚‚, if_pos (hâ‚ hâ‚‚)]
      Â· rw [not_imp] at hâ‚
        rw [hr j hâ‚.1, if_neg hâ‚.2]
  Â· refine âŸ¨âŸ¨{ j | r j i âˆ§ j âˆˆ p }, xâ‚, piecewise xâ‚‚ x { j | r j i }âŸ©,
      .snd âŸ¨i, fun j hj â†¦ ?_, ?_âŸ©, ?_âŸ© <;> simp only [piecewise_apply, Set.mem_setOf_eq]
    Â· exact if_pos hj
    Â· split_ifs with hi
      Â· rwa [hr i hi, if_neg hp] at hs
      Â· assumption
    Â· ext1 j
      simp only [piecewise_apply, Set.mem_setOf_eq]
      split_ifs with hâ‚ hâ‚‚ <;> try rfl
      Â· rw [hr j hâ‚.1, if_pos hâ‚.2]
      Â· rw [hr j hâ‚‚, if_neg]
        simpa [hâ‚‚] using hâ‚","error:  ambiguous, possible interpretations 
  _root_.not_imp : Â¬(?m.5300 â†’ ?m.5301) â†” ?m.5300 âˆ§ Â¬?m.5301
  
  Classical.not_imp : Â¬(?m.5302 â†’ ?m.5303) â†” ?m.5302 âˆ§ Â¬?m.5303
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.5305
case neg
Î¹ : Type u_1
Î± : Î¹ â†’ Type u_2
instâœÂ¹ : (i : Î¹) â†’ Zero (Î± i)
r : Î¹ â†’ Î¹ â†’ Prop
s : (i : Î¹) â†’ Î± i â†’ Î± i â†’ Prop
instâœ : (i : Î¹) â†’ (s : Set Î¹) â†’ Decidable (i âˆˆ s)
p : Set Î¹
xâ‚ xâ‚‚ x : Î â‚€ (i : Î¹), Î± i
i : Î¹
hr : âˆ€ (j : Î¹), r j i â†’ x j = if j âˆˆ p then xâ‚ j else xâ‚‚ j
hp : i âˆˆ p
hs : s i (x i) (xâ‚ i)
j : Î¹
hâ‚ : Â¬(r j i â†’ j âˆˆ p)
âŠ¢ xâ‚‚ j = x j","theorem lex_fibration [âˆ€ (i) (s : Set Î¹), Decidable (i âˆˆ s)] :
    Fibration (InvImage (GameAdd (DFinsupp.Lex r s) (DFinsupp.Lex r s)) snd) (DFinsupp.Lex r s)
      fun x => piecewise x.2.1 x.2.2 x.1 ",":= by
  rintro âŸ¨p, xâ‚, xâ‚‚âŸ© x âŸ¨i, hr, hsâŸ©
  simp_rw [piecewise_apply] at hs hr
  split_ifs at hs with hp
  Â· refine âŸ¨âŸ¨{ j | r j i â†’ j âˆˆ p }, piecewise xâ‚ x { j | r j i }, xâ‚‚âŸ©,
      .fst âŸ¨i, fun j hj â†¦ ?_, ?_âŸ©, ?_âŸ© <;> simp only [piecewise_apply, Set.mem_setOf_eq]
    Â· simp only [if_pos hj]
    Â· split_ifs with hi
      Â· rwa [hr i hi, if_pos hp] at hs
      Â· assumption
    Â· ext1 j
      simp only [piecewise_apply, Set.mem_setOf_eq]
      split_ifs with hâ‚ hâ‚‚ <;> try rfl
      Â· rw [hr j hâ‚‚, if_pos (hâ‚ hâ‚‚)]
      Â· rw [Classical.not_imp] at hâ‚
        rw [hr j hâ‚.1, if_neg hâ‚.2]
  Â· refine âŸ¨âŸ¨{ j | r j i âˆ§ j âˆˆ p }, xâ‚, piecewise xâ‚‚ x { j | r j i }âŸ©,
      .snd âŸ¨i, fun j hj â†¦ ?_, ?_âŸ©, ?_âŸ© <;> simp only [piecewise_apply, Set.mem_setOf_eq]
    Â· exact if_pos hj
    Â· split_ifs with hi
      Â· rwa [hr i hi, if_neg hp] at hs
      Â· assumption
    Â· ext1 j
      simp only [piecewise_apply, Set.mem_setOf_eq]
      split_ifs with hâ‚ hâ‚‚ <;> try rfl
      Â· rw [hr j hâ‚.1, if_pos hâ‚.2]
      Â· rw [hr j hâ‚‚, if_neg]
        simpa [hâ‚‚] using hâ‚",induction' lex_fibration lex_fibration lex_fibration with i
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae,exists_disjoint_closedBall_covering_ae,b0906f1a9f950f5731cad2defb88e9843a7e3fc9,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine' âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, _âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, âŸ¨_, _, _âŸ©, _âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Î¼ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 âˆˆ ?m.116759 âˆª ?m.116760","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Î¼ : Measure Î±)
    [IsFiniteMeasure Î¼] (f : Î± â†’ Set â„) (s : Set Î±)
    (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty) :
    âˆƒ t : Set (Î± Ã— â„), t.Countable âˆ§ (âˆ€ p âˆˆ t, p.1 âˆˆ s) âˆ§ (âˆ€ p âˆˆ t, p.2 âˆˆ f p.1) âˆ§
      Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) = 0 âˆ§
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, ?_âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, âŸ¨?_, ?_, ?_âŸ©, ?_âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Î¼ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1",rw [exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux]
Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean,WeierstrassCurve.Projective.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,b999f5fc5a622c176ec2ff740c2226c15d01d750,":= by
  rw [fin3_def P, hPz] at hP âŠ¢
  rw [fin3_def Q, hQz] at hQ âŠ¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Fin.isValue, nonsingular_iff, equation_iff, Matrix.cons_val_one, Matrix.head_cons,
      Matrix.cons_val_two, Matrix.tail_cons, mul_zero, Matrix.cons_val_zero, add_zero, ne_eq,
      OfNat.ofNat_ne_zero, not_false_eq_true, zero_pow, zero_eq_mul, pow_eq_zero_iff, sub_self,
      not_true_eq_false, false_or] at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, or_true, not_true_eq_false, mul_zero, zero_mul, add_zero, pow_eq_zero_iff, false_or,
      true_and, pow_eq_zero hQ.left.symm] at *
  exact âŸ¨Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel _ hQ]âŸ©","error:  application type mismatch
  div_mul_cancel ?m.248490 hQ
argument
  hQ
has type
  Â¬Q 1 = 0 : Prop
but is expected to have type
  ?m.248488 : Type ?u.248487
error:  unsolved goals
R : Type u
instâœÂ¹ : CommRing R
Wâœ : Projective R
F : Type u
instâœ : Field F
W : Projective F
P Q : Fin 3 â†’ F
hPz : P 2 = 0
hQz : Q 2 = 0
hP : Â¬P 1 = 0
hQ : Â¬Q 1 = 0
âŠ¢ ![0, P 1 / Q 1 * Q 1, 0] = ![0, P 1, 0]","lemma equiv_of_Z_eq_zero {P Q : Fin 3 â†’ F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P â‰ˆ Q ",":= by
  rw [fin3_def P, hPz] at hP âŠ¢
  rw [fin3_def Q, hQz] at hQ âŠ¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact âŸ¨Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancelâ‚€ _ hQ]âŸ©","simp only [equiv_of_Z_eq_zero_lemma, equiv_of_Z_eq_zero_lemma, equiv_of_Z_eq_zero_lemma]"
Mathlib/RingTheory/PrincipalIdealDomain.lean,nonPrincipals_zorn,nonPrincipals_zorn,14167e48d13e9c2d72cbdff0431a8edba6021c34,":= by
  refine' âŸ¨supâ‚› c, _, fun J hJ => le_supâ‚› hJâŸ©
  rintro âŸ¨x, hxâŸ©
  have hxmem : x âˆˆ supâ‚› c := hx.symm â–¸ Submodule.mem_span_singleton_self x
  obtain âŸ¨J, hJc, hxJâŸ© := (Submodule.mem_supâ‚›_of_directed âŸ¨K, hKmemâŸ© hchain.directedOn).1 hxmem
  have hsupâ‚›J : supâ‚› c = J := le_antisymm (by simp [hx, Ideal.span_le, hxJ]) (le_supâ‚› hJc)
  specialize hs hJc
  rw [â† hsupâ‚›J, hx, nonPrincipals_def] at hs
  exact hs âŸ¨âŸ¨x, rflâŸ©âŸ©","error:  unknown identifier 'supâ‚›'
error:  unknown identifier 'le_supâ‚›'
error:  unknown identifier 'supâ‚›'
error:  unknown constant 'Submodule.mem_supâ‚›_of_directed'
error:  rcases tactic failed: xâœ : ?m.133784 is not an inductive datatype","theorem nonPrincipals_zorn (c : Set (Ideal R)) (hs : c âŠ† nonPrincipals R)
    (hchain : IsChain (Â· â‰¤ Â·) c) {K : Ideal R} (hKmem : K âˆˆ c) :
    âˆƒ I âˆˆ nonPrincipals R, âˆ€ J âˆˆ c, J â‰¤ I ",":= by
  refine âŸ¨sSup c, ?_, fun J hJ => le_sSup hJâŸ©
  rintro âŸ¨x, hxâŸ©
  have hxmem : x âˆˆ sSup c := hx.symm â–¸ Submodule.mem_span_singleton_self x
  obtain âŸ¨J, hJc, hxJâŸ© := (Submodule.mem_sSup_of_directed âŸ¨K, hKmemâŸ© hchain.directedOn).1 hxmem
  have hsSupJ : sSup c = J := le_antisymm (by simp [hx, Ideal.span_le, hxJ]) (le_sSup hJc)
  specialize hs hJc
  rw [â† hsSupJ, hx, nonPrincipals_def] at hs
  exact hs âŸ¨âŸ¨x, rflâŸ©âŸ©","obtain âŸ¨I, hIâŸ© := nonPrincipals_mem_nonPrincipals R"
Mathlib/NumberTheory/Harmonic/EulerMascheroni.lean,Real.strictAnti_eulerMascheroniSeq',strictAnti_eulerMascheroniSeq',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine strictAnti_nat_of_succ_lt (fun n â†¦ ?_)
  rcases Nat.eq_zero_or_pos n with rfl | hn
  Â· simp [eulerMascheroniSeq']
  simp_rw [eulerMascheroniSeq', (by simp : (n + 1 = 0) = False), eq_false_intro hn.ne', if_false]
  rw [â† sub_pos, sub_sub_sub_comm,
    harmonic_succ, Rat.cast_add, â† sub_sub, sub_self, zero_sub, sub_eq_add_neg, neg_sub,
    â† sub_eq_neg_add, sub_pos, â† log_div (by positivity) (by positivity), â† neg_lt_neg_iff,
    â† log_inv]
  refine (log_lt_sub_one_of_pos ?_ ?_).trans_le (le_of_eq ?_)
  Â· positivity
  Â· field_simp
  Â· field_simp",error:  simp made no progress,lemma strictAnti_eulerMascheroniSeq' : StrictAnti eulerMascheroniSeq' ,":= by
  refine strictAnti_nat_of_succ_lt (fun n â†¦ ?_)
  rcases Nat.eq_zero_or_pos n with rfl | hn
  Â· simp [eulerMascheroniSeq']
  simp_rw [eulerMascheroniSeq', eq_false_intro hn.ne', if_false]
  rw [â† sub_pos, sub_sub_sub_comm,
    harmonic_succ, Rat.cast_add, â† sub_sub, sub_self, zero_sub, sub_eq_add_neg, neg_sub,
    â† sub_eq_neg_add, sub_pos, â† log_div (by positivity) (by positivity), â† neg_lt_neg_iff,
    â† log_inv]
  refine (log_lt_sub_one_of_pos ?_ ?_).trans_le (le_of_eq ?_)
  Â· positivity
  Â· field_simp
  Â· field_simp",lemma strictAnti_eulerMascheroniSeq' strictAnti_eulerMascheroniSeq'
Mathlib/MeasureTheory/Decomposition/Jordan.lean,MeasureTheory.SignedMeasure.mutuallySingular_iff,mutuallySingular_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  constructor
  Â· rintro âŸ¨u, hmeas, huâ‚, huâ‚‚âŸ©
    obtain âŸ¨i, hiâ‚, hiâ‚‚, hiâ‚ƒ, hipos, hinegâŸ© := s.toJordanDecomposition_spec
    obtain âŸ¨j, hjâ‚, hjâ‚‚, hjâ‚ƒ, hjpos, hjnegâŸ© := t.toJordanDecomposition_spec
    refine âŸ¨u, hmeas, ?_, ?_âŸ©
    Â· rw [totalVariation, Measure.add_apply, hipos, hineg, toMeasureOfZeroLE_apply _ _ _ hmeas,
        toMeasureOfLEZero_apply _ _ _ hmeas]
      simp [huâ‚ _ (Set.inter_subset_right _ _), â† NNReal.eq_iff]
    Â· rw [totalVariation, Measure.add_apply, hjpos, hjneg,
        toMeasureOfZeroLE_apply _ _ _ hmeas.compl,
        toMeasureOfLEZero_apply _ _ _ hmeas.compl]
      simp [huâ‚‚ _ (Set.inter_subset_right _ _), â† NNReal.eq_iff]
  Â· rintro âŸ¨u, hmeas, huâ‚, huâ‚‚âŸ©
    exact
      âŸ¨u, hmeas, fun t htu => null_of_totalVariation_zero _ (measure_mono_null htu huâ‚),
        fun t htv => null_of_totalVariation_zero _ (measure_mono_null htv huâ‚‚)âŸ©","error:  function expected at
  Set.inter_subset_right ?m.92947
term has type
  ?m.92946 âˆˆ ?m.92945
error:  unsolved goals
case mp.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.refine_1
Î± : Type u_1
Î² : Type u_2
instâœ : MeasurableSpace Î±
s t : SignedMeasure Î±
u : Set Î±
hmeas : MeasurableSet u
huâ‚ : âˆ€ t âŠ† u, â†‘s t = 0
huâ‚‚ : âˆ€ t_1 âŠ† uá¶œ, â†‘t t_1 = 0
i : Set Î±
hiâ‚ : MeasurableSet i
hiâ‚‚ : VectorMeasure.restrict 0 i â‰¤ VectorMeasure.restrict s i
hiâ‚ƒ : VectorMeasure.restrict s iá¶œ â‰¤ VectorMeasure.restrict 0 iá¶œ
hipos : s.toJordanDecomposition.posPart = s.toMeasureOfZeroLE i hiâ‚ hiâ‚‚
hineg : s.toJordanDecomposition.negPart = s.toMeasureOfLEZero iá¶œ â‹¯ hiâ‚ƒ
j : Set Î±
hjâ‚ : MeasurableSet j
hjâ‚‚ : VectorMeasure.restrict 0 j â‰¤ VectorMeasure.restrict t j
hjâ‚ƒ : VectorMeasure.restrict t já¶œ â‰¤ VectorMeasure.restrict 0 já¶œ
hjpos : t.toJordanDecomposition.posPart = t.toMeasureOfZeroLE j hjâ‚ hjâ‚‚
hjneg : t.toJordanDecomposition.negPart = t.toMeasureOfLEZero já¶œ â‹¯ hjâ‚ƒ
âŠ¢ â†‘s (i âˆ© u) = 0 âˆ§ â†‘s (iá¶œ âˆ© u) = 0
error:  function expected at
  Set.inter_subset_right ?m.95077
term has type
  ?m.95076 âˆˆ ?m.95075
error:  unsolved goals
case mp.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.refine_2
Î± : Type u_1
Î² : Type u_2
instâœ : MeasurableSpace Î±
s t : SignedMeasure Î±
u : Set Î±
hmeas : MeasurableSet u
huâ‚ : âˆ€ t âŠ† u, â†‘s t = 0
huâ‚‚ : âˆ€ t_1 âŠ† uá¶œ, â†‘t t_1 = 0
i : Set Î±
hiâ‚ : MeasurableSet i
hiâ‚‚ : VectorMeasure.restrict 0 i â‰¤ VectorMeasure.restrict s i
hiâ‚ƒ : VectorMeasure.restrict s iá¶œ â‰¤ VectorMeasure.restrict 0 iá¶œ
hipos : s.toJordanDecomposition.posPart = s.toMeasureOfZeroLE i hiâ‚ hiâ‚‚
hineg : s.toJordanDecomposition.negPart = s.toMeasureOfLEZero iá¶œ â‹¯ hiâ‚ƒ
j : Set Î±
hjâ‚ : MeasurableSet j
hjâ‚‚ : VectorMeasure.restrict 0 j â‰¤ VectorMeasure.restrict t j
hjâ‚ƒ : VectorMeasure.restrict t já¶œ â‰¤ VectorMeasure.restrict 0 já¶œ
hjpos : t.toJordanDecomposition.posPart = t.toMeasureOfZeroLE j hjâ‚ hjâ‚‚
hjneg : t.toJordanDecomposition.negPart = t.toMeasureOfLEZero já¶œ â‹¯ hjâ‚ƒ
âŠ¢ â†‘t (j âˆ© uá¶œ) = 0 âˆ§ â†‘t (já¶œ âˆ© uá¶œ) = 0","theorem mutuallySingular_iff (s t : SignedMeasure Î±) :
    s âŸ‚áµ¥ t â†” s.totalVariation âŸ‚â‚˜ t.totalVariation ",":= by
  constructor
  Â· rintro âŸ¨u, hmeas, huâ‚, huâ‚‚âŸ©
    obtain âŸ¨i, hiâ‚, hiâ‚‚, hiâ‚ƒ, hipos, hinegâŸ© := s.toJordanDecomposition_spec
    obtain âŸ¨j, hjâ‚, hjâ‚‚, hjâ‚ƒ, hjpos, hjnegâŸ© := t.toJordanDecomposition_spec
    refine âŸ¨u, hmeas, ?_, ?_âŸ©
    Â· rw [totalVariation, Measure.add_apply, hipos, hineg, toMeasureOfZeroLE_apply _ _ _ hmeas,
        toMeasureOfLEZero_apply _ _ _ hmeas]
      simp [huâ‚ _ Set.inter_subset_right, â† NNReal.eq_iff]
    Â· rw [totalVariation, Measure.add_apply, hjpos, hjneg,
        toMeasureOfZeroLE_apply _ _ _ hmeas.compl,
        toMeasureOfLEZero_apply _ _ _ hmeas.compl]
      simp [huâ‚‚ _ Set.inter_subset_right, â† NNReal.eq_iff]
  Â· rintro âŸ¨u, hmeas, huâ‚, huâ‚‚âŸ©
    exact
      âŸ¨u, hmeas, fun t htu => null_of_totalVariation_zero _ (measure_mono_null htu huâ‚),
        fun t htv => null_of_totalVariation_zero _ (measure_mono_null htv huâ‚‚)âŸ©",rw [totalVariation_totalVariation]
Mathlib/Analysis/Calculus/FDeriv/Measurable.lean,measurableSet_of_differentiableWithinAt_Ici_of_isComplete,measurableSet_of_differentiableWithinAt_Ici_of_isComplete,fdbb97baae10f5304e9ce72344499cd3620a87c2,":= by
  simp only [differentiable_set_eq_d K hK, D]
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iUnion fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  exact measurableSet_b","error:  unknown identifier 'differentiable_set_eq_d'
error:  simp made no progress","theorem measurableSet_of_differentiableWithinAt_Ici_of_isComplete {K : Set F} (hK : IsComplete K) :
    MeasurableSet { x | DifferentiableWithinAt â„ f (Ici x) x âˆ§ derivWithin f (Ici x) x âˆˆ K } ",":= by
  simp only [differentiable_set_eq_D K hK, D]
  repeat apply_rules [MeasurableSet.iUnion, MeasurableSet.iInter] <;> intro
  exact measurableSet_B",refine IsComplete.isComplete_of_differentiableWithinAt_Ici_of_isComplete hK ?_
Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean,ae_restrict_of_ae_restrict_inter_Ioo,ae_restrict_of_ae_restrict_inter_Ioo,3d6731dcdc44a17f3f57d0ef17157c073bd131a7,":= by
  let T : s Ã— s â†’ Set â„ := fun p => Ioo p.1 p.2
  let u := â‹ƒ i : â†¥s Ã— â†¥s, T i
  have hfinite : (s \ u).Finite := s.finite_diff_iUnion_Ioo'
  obtain âŸ¨A, A_count, hAâŸ© :
    âˆƒ A : Set (â†¥s Ã— â†¥s), A.Countable âˆ§ (â‹ƒ i âˆˆ A, T i) = â‹ƒ i : â†¥s Ã— â†¥s, T i :=
    isOpen_iUnion_countable _ fun p => isOpen_Ioo
  have : s âŠ† s \ u âˆª â‹ƒ p âˆˆ A, s âˆ© T p := by
    intro x hx
    by_cases h'x : x âˆˆ â‹ƒ i : â†¥s Ã— â†¥s, T i
    Â· rw [â† hA] at h'x
      obtain âŸ¨p, pA, xpâŸ© : âˆƒ p : â†¥s Ã— â†¥s, p âˆˆ A âˆ§ x âˆˆ T p := by
        simpa only [mem_iUnion, exists_prop, SetCoe.exists, exists_and_right] using h'x
      right
      exact mem_biUnion pA âŸ¨hx, xpâŸ©
    Â· exact Or.inl âŸ¨hx, h'xâŸ©
  apply ae_restrict_of_ae_restrict_of_subset this
  rw [ae_restrict_union_iff, ae_restrict_biUnion_iff _ A_count]
  constructor
  Â· have : Î¼.restrict (s \ u) = 0 := by simp only [restrict_eq_zero, hfinite.measure_zero]
    simp only [this, ae_zero, eventually_bot]
  Â· rintro âŸ¨âŸ¨a, asâŸ©, âŸ¨b, bsâŸ©âŸ© -
    dsimp
    rcases le_or_lt b a with (hba | hab)
    Â· simp only [Ioo_eq_empty_of_le hba, inter_empty, restrict_empty, ae_zero, eventually_bot]
    Â· exact h a b as bs hab",error:  dsimp made no progress,"theorem ae_restrict_of_ae_restrict_inter_Ioo {Î¼ : Measure â„} [NoAtoms Î¼] {s : Set â„} {p : â„ â†’ Prop}
    (h : âˆ€ a b, a âˆˆ s â†’ b âˆˆ s â†’ a < b â†’ âˆ€áµ x âˆ‚Î¼.restrict (s âˆ© Ioo a b), p x) :
    âˆ€áµ x âˆ‚Î¼.restrict s, p x ",":= by
  let T : s Ã— s â†’ Set â„ := fun p => Ioo p.1 p.2
  let u := â‹ƒ i : â†¥s Ã— â†¥s, T i
  have hfinite : (s \ u).Finite := s.finite_diff_iUnion_Ioo'
  obtain âŸ¨A, A_count, hAâŸ© :
    âˆƒ A : Set (â†¥s Ã— â†¥s), A.Countable âˆ§ â‹ƒ i âˆˆ A, T i = â‹ƒ i : â†¥s Ã— â†¥s, T i :=
    isOpen_iUnion_countable _ fun p => isOpen_Ioo
  have : s âŠ† s \ u âˆª â‹ƒ p âˆˆ A, s âˆ© T p := by
    intro x hx
    by_cases h'x : x âˆˆ â‹ƒ i : â†¥s Ã— â†¥s, T i
    Â· rw [â† hA] at h'x
      obtain âŸ¨p, pA, xpâŸ© : âˆƒ p : â†¥s Ã— â†¥s, p âˆˆ A âˆ§ x âˆˆ T p := by
        simpa only [mem_iUnion, exists_prop, SetCoe.exists, exists_and_right] using h'x
      right
      exact mem_biUnion pA âŸ¨hx, xpâŸ©
    Â· exact Or.inl âŸ¨hx, h'xâŸ©
  apply ae_restrict_of_ae_restrict_of_subset this
  rw [ae_restrict_union_iff, ae_restrict_biUnion_iff _ A_count]
  constructor
  Â· have : Î¼.restrict (s \ u) = 0 := by simp only [restrict_eq_zero, hfinite.measure_zero]
    simp only [this, ae_zero, eventually_bot]
  Â· rintro âŸ¨âŸ¨a, asâŸ©, âŸ¨b, bsâŸ©âŸ© -
    dsimp [T]
    rcases le_or_lt b a with (hba | hab)
    Â· simp only [Ioo_eq_empty_of_le hba, inter_empty, restrict_empty, ae_zero, eventually_bot]
    Â· exact h a b as bs hab",rw [ae_restrict_of_ae_restrict_of_ae_restrict_of_Ioo]
Mathlib/LinearAlgebra/Trace.lean,LinearMap.trace_one,trace_one,3cd79561893bd947896097b56b0eef6a9bde9612,":= by
  have b := Module.Free.chooseBasis R M
  rw [trace_eq_matrix_trace R b, toMatrix_one, finrank_eq_card_chooseBasisIndex]
  simp","error:  failed to synthesize
  StrongRankCondition R
use `set_option diagnostics true` to get diagnostic information",theorem trace_one : trace R M 1 = (finrank R M : R) ,":= by
  cases subsingleton_or_nontrivial R
  Â· simp [eq_iff_true_of_subsingleton]
  have b := Module.Free.chooseBasis R M
  rw [trace_eq_matrix_trace R b, toMatrix_one, finrank_eq_card_chooseBasisIndex]
  simp",have trace_one : trace R M 1 = finrank R M := by simp [trace_one]
Mathlib/Order/OrderIsoNat.lean,exists_increasing_or_nonincreasing_subseq,exists_increasing_or_nonincreasing_subseq,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  classical
    let bad : Set â„• := { m | âˆ€ n, m < n â†’ Â¬r (f m) (f n) }
    by_cases hbad : Infinite bad
    Â· haveI := hbad
      refine âŸ¨Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => ?_âŸ©
      have h := @Set.mem_range_self _ _ â†‘(Nat.orderEmbeddingOfSet bad) m
      rw [Nat.orderEmbeddingOfSet_range bad] at h
      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)
    Â· rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad
      obtain âŸ¨m, hmâŸ© : âˆƒ m, âˆ€ n, m â‰¤ n â†’ Â¬n âˆˆ bad := by
        by_cases he : hbad.toFinset.Nonempty
        Â· refine'
            âŸ¨(hbad.toFinset.max' he).succ, fun n hn nbad =>
              Nat.not_succ_le_self _
                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))âŸ©
        Â· exact âŸ¨0, fun n _ nbad => he âŸ¨n, hbad.mem_toFinset.2 nbadâŸ©âŸ©
      have h : âˆ€ n : â„•, âˆƒ n' : â„•, n < n' âˆ§ r (f (n + m)) (f (n' + m)) := by
        intro n
        have h := hm _ (le_add_of_nonneg_left n.zero_le)
        simp only [bad, exists_prop, not_not, Set.mem_setOf_eq, not_forall] at h
        obtain âŸ¨n', hn1, hn2âŸ© := h
        obtain âŸ¨x, hpos, rflâŸ© := exists_pos_add_of_lt hn1
        refine âŸ¨n + x, add_lt_add_left hpos n, ?_âŸ©
        rw [add_assoc, add_comm x m, â† add_assoc]
        exact hn2
      let g' : â„• â†’ â„• := @Nat.rec (fun _ => â„•) m fun n gn => Nat.find (h gn)
      exact
        âŸ¨(RelEmbedding.natLT (fun n => g' n + m) fun n =>
              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,
          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2âŸ©","error:  failed to synthesize
  CovariantClass â„• â„• (Function.swap fun x x_1 â†¦ x + x_1) fun x x_1 â†¦ x â‰¤ x_1
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  exists_pos_add_of_lt hn1
argument
  hn1
has type
  @LT.lt â„• instLTNat (n + m) n' : Prop
but is expected to have type
  @LT.lt â„• Preorder.toLT (n + m) n' : Prop","theorem exists_increasing_or_nonincreasing_subseq' (r : Î± â†’ Î± â†’ Prop) (f : â„• â†’ Î±) :
    âˆƒ g : â„• â†ªo â„•,
      (âˆ€ n : â„•, r (f (g n)) (f (g (n + 1)))) âˆ¨ âˆ€ m n : â„•, m < n â†’ Â¬r (f (g m)) (f (g n)) ",":= by
  classical
    let bad : Set â„• := { m | âˆ€ n, m < n â†’ Â¬r (f m) (f n) }
    by_cases hbad : Infinite bad
    Â· haveI := hbad
      refine âŸ¨Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => ?_âŸ©
      have h := @Set.mem_range_self _ _ â†‘(Nat.orderEmbeddingOfSet bad) m
      rw [Nat.orderEmbeddingOfSet_range bad] at h
      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)
    Â· rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad
      obtain âŸ¨m, hmâŸ© : âˆƒ m, âˆ€ n, m â‰¤ n â†’ Â¬n âˆˆ bad := by
        by_cases he : hbad.toFinset.Nonempty
        Â· refine
            âŸ¨(hbad.toFinset.max' he).succ, fun n hn nbad =>
              Nat.not_succ_le_self _
                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))âŸ©
        Â· exact âŸ¨0, fun n _ nbad => he âŸ¨n, hbad.mem_toFinset.2 nbadâŸ©âŸ©
      have h : âˆ€ n : â„•, âˆƒ n' : â„•, n < n' âˆ§ r (f (n + m)) (f (n' + m)) := by
        intro n
        have h := hm _ (Nat.le_add_left m n)
        simp only [bad, exists_prop, not_not, Set.mem_setOf_eq, not_forall] at h
        obtain âŸ¨n', hn1, hn2âŸ© := h
        refine âŸ¨n + n' - n - m, by omega, ?_âŸ©
        convert hn2
        omega
      let g' : â„• â†’ â„• := @Nat.rec (fun _ => â„•) m fun n gn => Nat.find (h gn)
      exact
        âŸ¨(RelEmbedding.natLT (fun n => g' n + m) fun n =>
              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,
          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2âŸ©",simp only [exists_increasing_or_nonincreasing_subseq']
Mathlib/Computability/Primrec.lean,PrimrecPred.or,_root_.PrimrecPred.or,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  (Primrec.or.compâ‚‚ hp hq).of_eq fun n => by simp","error:  application type mismatch
  Primrecâ‚‚.compâ‚‚ Primrec.or hp
argument
  hp
has type
  PrimrecPred p : Prop
but is expected to have type
  Primrecâ‚‚ ?m.92952 : Prop
error:  simp made no progress","theorem _root_.PrimrecPred.or {p q : Î± â†’ Prop} [DecidablePred p] [DecidablePred q]
    (hp : PrimrecPred p) (hq : PrimrecPred q) : PrimrecPred fun a => p a âˆ¨ q a ",":=
  (Primrec.or.comp hp hq).of_eq fun n => by simp",refine PrimrecPred.or.imp (fun a â†¦ p a âˆ¨ q a âˆ¨ p a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a âˆ¨ q a âˆ£ q a
Mathlib/Geometry/Euclidean/Inversion/Calculus.lean,EuclideanGeometry.hasFDerivAt_inversion,hasFDerivAt_inversion,c480a87bf98e8eb1bd5a2eec1b3b1369bfff595d,":= by
  rcases add_left_surjective c x with âŸ¨x, rflâŸ©
  have : HasFDerivAt (inversion c R) (_ : F â†’L[â„] F) (c + x)
  Â· simp_rw [inversion, dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ğ•œ := â„) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := â„ âˆ™ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy â†¦ ?_)
  Â· have : ((â€–xâ€– ^ 2) ^ 2)â»Â¹ * (â€–xâ€– ^ 2) = (â€–xâ€– ^ 2)â»Â¹
    Â· rw [â† div_eq_inv_mul, sq (â€–xâ€– ^ 2), div_self_mul_self']
    dsimp
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
    rw [Pi.smul_apply, Pi.smul_apply, real_inner_self_eq_norm_sq]
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  Â· simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]
    rw [Pi.smul_apply, Pi.smul_apply]
    simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]","error:  unexpected token 'Â·'; expected '|'
error:  don't know how to synthesize placeholder for argument 'f''
context:
E : Type u_1
F : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace â„ E
instâœÂ¹ : NormedAddCommGroup F
instâœ : InnerProductSpace â„ F
a b c d y z : F
r R : â„
x : F
hx : (fun x â†¦ c + x) x â‰  c
âŠ¢ F â†’L[â„] F
error:  unsolved goals
case intro
E : Type u_1
F : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace â„ E
instâœÂ¹ : NormedAddCommGroup F
instâœ : InnerProductSpace â„ F
a b c d y z : F
r R : â„
x : F
hx : (fun x â†¦ c + x) x â‰  c
âŠ¢ HasFDerivAt (inversion c R)
    ((R / dist ((fun x â†¦ c + x) x) c) ^ 2 â€¢
      â†‘{ toLinearEquiv := (reflection (Submodule.span â„ {(fun x â†¦ c + x) x - c})á—®).toLinearEquiv, continuous_toFun := â‹¯,
          continuous_invFun := â‹¯ })
    ((fun x â†¦ c + x) x)","theorem hasFDerivAt_inversion (hx : x â‰  c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 â€¢ (reflection (â„ âˆ™ (x - c))á—® : F â†’L[â„] F)) x ",":= by
  rcases add_left_surjective c x with âŸ¨x, rflâŸ©
  have : HasFDerivAt (inversion c R) (?_ : F â†’L[â„] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ğ•œ := â„) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := â„ âˆ™ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy â†¦ ?_)
  Â· have : ((â€–xâ€– ^ 2) ^ 2)â»Â¹ * (â€–xâ€– ^ 2) = (â€–xâ€– ^ 2)â»Â¹ := by
      rw [â† div_eq_inv_mul, sq (â€–xâ€– ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  Â· simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]",have hasFDerivAt_inversion hx hasFDerivAt_inversion hx hasFDerivAt_inversion hx
Mathlib/Topology/Gluing.lean,TopCat.GlueData.Î¹_eq_iff_rel,Î¹_eq_iff_rel,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  constructor
  Â· delta GlueData.Î¹
    simp_rw [â† Multicoequalizer.Î¹_sigmaÏ€]
    intro h
    rw [â†
      show _ = Sigma.mk i x from ConcreteCategory.congr_hom (sigmaIsoSigma.{_, u} D.U).inv_hom_id _]
    rw [â†
      show _ = Sigma.mk j y from ConcreteCategory.congr_hom (sigmaIsoSigma.{_, u} D.U).inv_hom_id _]
    change InvImage D.Rel (sigmaIsoSigma.{_, u} D.U).hom _ _
    rw [â† (InvImage.equivalence _ _ D.rel_equiv).eqvGen_iff]
    refine' EqvGen.mono _ (D.eqvGen_of_Ï€_eq h : _)
    rintro _ _ âŸ¨xâŸ©
    obtain âŸ¨âŸ¨âŸ¨i, jâŸ©, yâŸ©, rflâŸ© :=
      (ConcreteCategory.bijective_of_isIso (sigmaIsoSigma.{u, u} _).inv).2 x
    unfold InvImage MultispanIndex.fstSigmaMap MultispanIndex.sndSigmaMap
    simp only [forget_map_eq_coe, Opens.inclusion_apply, TopCat.comp_app, sigmaIsoSigma_inv_apply,
      Cofan.mk_Î¹_app]
    rw [â† comp_apply, colimit.Î¹_desc, â† comp_apply, colimit.Î¹_desc]
    erw [sigmaIsoSigma_hom_Î¹_apply, sigmaIsoSigma_hom_Î¹_apply]
    exact Or.inr âŸ¨y, âŸ¨rfl, rflâŸ©âŸ©
  Â· rintro (âŸ¨âŸ¨âŸ©âŸ© | âŸ¨z, eâ‚, eâ‚‚âŸ©)
    Â· rfl
    dsimp only at *
    rw [â† eâ‚, â† eâ‚‚] at *
    simp","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?g (?f ?x)
case mp.Rel.intro.mk.mk
D : GlueData
iâœ jâœ : D.J
x : â†‘(D.U iâœ)
yâœ : â†‘(D.U jâœ)
h :
  (Sigma.Î¹ D.diagram.right iâœ â‰« Multicoequalizer.sigmaÏ€ D.diagram) x =
    (Sigma.Î¹ D.diagram.right jâœ â‰« Multicoequalizer.sigmaÏ€ D.diagram) yâœ
i j : D.J
y : â†‘(D.diagram.left (i, j))
âŠ¢ D.Rel
    ((sigmaIsoSigma D.U).hom
      ((Sigma.desc fun b â†¦ D.diagram.fst b â‰« Sigma.Î¹ D.diagram.right (D.diagram.fstFrom b))
        ((sigmaIsoSigma D.diagram.left).inv âŸ¨(i, j), yâŸ©)))
    ((sigmaIsoSigma D.U).hom
      ((Sigma.desc fun b â†¦ D.diagram.snd b â‰« Sigma.Î¹ D.diagram.right (D.diagram.sndFrom b))
        ((sigmaIsoSigma D.diagram.left).inv âŸ¨(i, j), yâŸ©)))
error:  unsolved goals
case mpr.inr.intro.intro
D : GlueData
i j : D.J
x : â†‘(D.U i)
y : â†‘(D.U j)
z : â†‘(D.V (âŸ¨i, xâŸ©.fst, âŸ¨j, yâŸ©.fst))
eâ‚ : (D.f i j) z = (D.f i j) z
eâ‚‚ : (D.f j i) ((D.t i j) z) = (D.f j i) ((D.t i j) z)
âŠ¢ (D.Î¹ i) ((D.f i j) z) = (D.Î¹ j) ((D.f j i) ((D.t i j) z))","theorem Î¹_eq_iff_rel (i j : D.J) (x : D.U i) (y : D.U j) :
    ğ–£.Î¹ i x = ğ–£.Î¹ j y â†” D.Rel âŸ¨i, xâŸ© âŸ¨j, yâŸ© ",":= by
  constructor
  Â· delta GlueData.Î¹
    simp_rw [â† Multicoequalizer.Î¹_sigmaÏ€]
    intro h
    rw [â†
      show _ = Sigma.mk i x from ConcreteCategory.congr_hom (sigmaIsoSigma.{_, u} D.U).inv_hom_id _]
    rw [â†
      show _ = Sigma.mk j y from ConcreteCategory.congr_hom (sigmaIsoSigma.{_, u} D.U).inv_hom_id _]
    change InvImage D.Rel (sigmaIsoSigma.{_, u} D.U).hom _ _
    rw [â† (InvImage.equivalence _ _ D.rel_equiv).eqvGen_iff]
    refine EqvGen.mono ?_ (D.eqvGen_of_Ï€_eq h : _)
    rintro _ _ âŸ¨xâŸ©
    obtain âŸ¨âŸ¨âŸ¨i, jâŸ©, yâŸ©, rflâŸ© :=
      (ConcreteCategory.bijective_of_isIso (sigmaIsoSigma.{u, u} _).inv).2 x
    unfold InvImage MultispanIndex.fstSigmaMap MultispanIndex.sndSigmaMap
    simp only [forget_map_eq_coe]
    erw [TopCat.comp_app, sigmaIsoSigma_inv_apply, â† comp_apply, â† comp_apply,
      colimit.Î¹_desc_assoc, â† comp_apply, â† comp_apply, colimit.Î¹_desc_assoc]
    erw [sigmaIsoSigma_hom_Î¹_apply, sigmaIsoSigma_hom_Î¹_apply]
    exact Or.inr âŸ¨y, âŸ¨rfl, rflâŸ©âŸ©
  Â· rintro (âŸ¨âŸ¨âŸ©âŸ© | âŸ¨z, eâ‚, eâ‚‚âŸ©)
    Â· rfl
    dsimp only at *
    rw [â† eâ‚, â† eâ‚‚] at *
    erw [D.glue_condition_apply] 
    rfl ",constructor
Mathlib/Analysis/Calculus/MeanValue.lean,eq_of_derivWithin_eq,eq_of_derivWithin_eq,9e34a191034458a56331f976ff7400a26407c888,":= by
  have A : âˆ€ y âˆˆ Ico a b, HasDerivWithinAt f (derivWithin f (Icc a b) y) (Ici y) y := fun y hy =>
    (fdiff y (mem_Icc_of_Ico hy)).hasDerivWithinAt.nhdsWithin (Icc_mem_nhdsWithin_Ici hy)
  have B : âˆ€ y âˆˆ Ico a b, HasDerivWithinAt g (derivWithin g (Icc a b) y) (Ici y) y := fun y hy =>
    (gdiff y (mem_Icc_of_Ico hy)).hasDerivWithinAt.nhdsWithin (Icc_mem_nhdsWithin_Ici hy)
  exact
    eq_of_has_deriv_right_eq A (fun y hy => (hderiv hy).symm â–¸ B y hy) fdiff.continuousOn
      gdiff.continuousOn hi","error:  invalid field 'nhdsWithin', the environment does not contain 'HasDerivWithinAt.nhdsWithin'
  DifferentiableWithinAt.hasDerivWithinAt (fdiff y (mem_Icc_of_Ico hy))
has type
  HasDerivWithinAt f (derivWithin f (Icc a b) y) (Icc a b) y
error:  invalid field 'nhdsWithin', the environment does not contain 'HasDerivAtFilter.nhdsWithin'
  DifferentiableWithinAt.hasDerivWithinAt (fdiff y (mem_Icc_of_Ico hy))
has type
  HasDerivAtFilter f (derivWithin f (Icc a b) y) y (ğ“[Icc a b] y)
error:  invalid field 'nhdsWithin', the environment does not contain 'HasFDerivAtFilter.nhdsWithin'
  DifferentiableWithinAt.hasDerivWithinAt (fdiff y (mem_Icc_of_Ico hy))
has type
  HasFDerivAtFilter f (smulRight 1 (derivWithin f (Icc a b) y)) y (ğ“[Icc a b] y)
error:  invalid field 'nhdsWithin', the environment does not contain 'HasDerivWithinAt.nhdsWithin'
  DifferentiableWithinAt.hasDerivWithinAt (gdiff y (mem_Icc_of_Ico hy))
has type
  HasDerivWithinAt g (derivWithin g (Icc a b) y) (Icc a b) y
error:  invalid field 'nhdsWithin', the environment does not contain 'HasDerivAtFilter.nhdsWithin'
  DifferentiableWithinAt.hasDerivWithinAt (gdiff y (mem_Icc_of_Ico hy))
has type
  HasDerivAtFilter g (derivWithin g (Icc a b) y) y (ğ“[Icc a b] y)
error:  invalid field 'nhdsWithin', the environment does not contain 'HasFDerivAtFilter.nhdsWithin'
  DifferentiableWithinAt.hasDerivWithinAt (gdiff y (mem_Icc_of_Ico hy))
has type
  HasFDerivAtFilter g (smulRight 1 (derivWithin g (Icc a b) y)) y (ğ“[Icc a b] y)","theorem eq_of_derivWithin_eq (fdiff : DifferentiableOn â„ f (Icc a b))
    (gdiff : DifferentiableOn â„ g (Icc a b))
    (hderiv : EqOn (derivWithin f (Icc a b)) (derivWithin g (Icc a b)) (Ico a b)) (hi : f a = g a) :
    âˆ€ y âˆˆ Icc a b, f y = g y ",":= by
  have A : âˆ€ y âˆˆ Ico a b, HasDerivWithinAt f (derivWithin f (Icc a b) y) (Ici y) y := fun y hy =>
    (fdiff y (mem_Icc_of_Ico hy)).hasDerivWithinAt.mono_of_mem (Icc_mem_nhdsWithin_Ici hy)
  have B : âˆ€ y âˆˆ Ico a b, HasDerivWithinAt g (derivWithin g (Icc a b) y) (Ici y) y := fun y hy =>
    (gdiff y (mem_Icc_of_Ico hy)).hasDerivWithinAt.mono_of_mem (Icc_mem_nhdsWithin_Ici hy)
  exact
    eq_of_has_deriv_right_eq A (fun y hy => (hderiv hy).symm â–¸ B y hy) fdiff.continuousOn
      gdiff.continuousOn hi","simp only [derivWithin, hderiv]"
Mathlib/Data/Matrix/Kronecker.lean,Matrix.kroneckerMapBilinear_mul_mul,kroneckerMapBilinear_mul_mul,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  ext âŸ¨i, i'âŸ© âŸ¨j, j'âŸ©
  simp only [kroneckerMapBilinear_apply_apply, mul_apply, â† Finset.univ_product_univ,
    Finset.sum_product, kroneckerMap_apply]
  simp_rw [f.map_sum, LinearMap.sum_apply, LinearMap.map_sum, h_comm]","error:  invalid field 'map_sum', the environment does not contain 'LinearMap.map_sum'
  f
has type
  Î± â†’â‚—[R] Î² â†’â‚—[R] Î³
error:  simp made no progress","theorem kroneckerMapBilinear_mul_mul [CommSemiring R] [Fintype m] [Fintype m']
    [NonUnitalNonAssocSemiring Î±] [NonUnitalNonAssocSemiring Î²] [NonUnitalNonAssocSemiring Î³]
    [Module R Î±] [Module R Î²] [Module R Î³] (f : Î± â†’â‚—[R] Î² â†’â‚—[R] Î³)
    (h_comm : âˆ€ a b a' b', f (a * b) (a' * b') = f a a' * f b b') (A : Matrix l m Î±)
    (B : Matrix m n Î±) (A' : Matrix l' m' Î²) (B' : Matrix m' n' Î²) :
    kroneckerMapBilinear f (A * B) (A' * B') =
      kroneckerMapBilinear f A A' * kroneckerMapBilinear f B B' ",":= by
  ext âŸ¨i, i'âŸ© âŸ¨j, j'âŸ©
  simp only [kroneckerMapBilinear_apply_apply, mul_apply, â† Finset.univ_product_univ,
    Finset.sum_product, kroneckerMap_apply]
  simp_rw [map_sum f, LinearMap.sum_apply, map_sum, h_comm]",refine theorem_kroneckerMapBilinear_mul_mul kroneckerMapBilinear_mul_mul kroneckerMapBilinear_mul_mul kroneckerMapBilinear_mul_mul
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow,discr_prime_pow,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hÎ¶.powerBasis_gen _, â†
    hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : â„•+) : â„•) = 2 := rfl
  have hp2 : p = 2 â†’ k â‰  0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  Â· rcases eq_or_ne p 2 with (rfl | hp2)
    Â· rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with âŸ¨k, rflâŸ©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      Â· simp
      Â· norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    Â· replace hp2 : (p : â„•) â‰  2 := by rwa [Ne.def, â† coe_two, PNat.coe_inj]
      have hpo : Odd (p : â„•) := hp.out.odd_of_ne_two hp2
      obtain âŸ¨a, haâŸ© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, â† ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  Â· have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, â† PNat.pow_coe,
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Î¶ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Î¶ ^ (p : â„•) ^ k - 1) = (p : K) ^ (p : â„•) ^ k := by
      by_cases hp : p = 2
      Â· exact mod_cast hÎ¶.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      Â· exact mod_cast hÎ¶.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, â† map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, â† succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hÎ¶.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, â† pow_mul, â† mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [â† succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : â„•) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    Â· simp only [H, mul_comm _ (k + 1)]; norm_cast
    Â· 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  2 * ?m.33273 / 2
case e_a.inl.intro
K : Type u
L : Type v
Î¶ : L
instâœÂ³ : Field K
instâœÂ² : Field L
instâœÂ¹ : Algebra K L
mf : Module.Finite K L
se : IsSeparable K L
coe_two : â†‘2 = 2
hp : Fact (Nat.Prime â†‘2)
k : â„•
instâœ : IsCyclotomicExtension {2 ^ (k.succ + 1)} K L
hÎ¶ : IsPrimitiveRoot Î¶ â†‘(2 ^ (k.succ + 1))
hirr : Irreducible (cyclotomic (â†‘(2 ^ (k.succ + 1))) K)
hk : 2 ^ (k.succ + 1) â‰  2
hne : NeZero â†‘â†‘(2 ^ (k.succ + 1))
hp2 : 2 = 2 â†’ k.succ â‰  0
âŠ¢ (-1) ^ (2 ^ k * (2 * (2 ^ k * 2 - 1)) / 2) = (-1) ^ (2 ^ k * 2 / 2)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.34336 â†’ ?m.34336 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.34338
p : â„•+
k : â„•
K : Type u
L : Type v
Î¶ : L
instâœÂ³ : Field K
instâœÂ² : Field L
instâœÂ¹ : Algebra K L
instâœ : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime â†‘p)
hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))
hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1))) K)
hk : p ^ (k + 1) â‰  2
hne : NeZero â†‘â†‘(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : â†‘2 = 2
hp2âœ : p = 2 â†’ k â‰  0
hp2 : p â‰  2
âŠ¢ â†‘p â‰  2
warning:  `Polynomial.C_eq_nat_cast` has been deprecated, use `Polynomial.C_eq_natCast` instead
warning:  `Polynomial.C_eq_nat_cast` has been deprecated, use `Polynomial.C_eq_natCast` instead
warning:  `Polynomial.aeval_nat_cast` has been deprecated, use `Polynomial.aeval_natCast` instead
warning:  `IsPrimitiveRoot.pow_sub_one_norm_prime_pow_of_ne_zero` has been deprecated, use `IsPrimitiveRoot.norm_pow_sub_one_eq_prime_pow_of_ne_zero` instead
warning:  `IsPrimitiveRoot.pow_sub_one_norm_prime_ne_two` has been deprecated, use `IsPrimitiveRoot.norm_pow_sub_one_of_prime_ne_two` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.60645 â†’ ?m.60645 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.60647
case e_a.refine_1
p : â„•+
k : â„•
K : Type u
L : Type v
Î¶ : L
instâœÂ³ : Field K
instâœÂ² : Field L
instâœÂ¹ : Algebra K L
instâœ : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime â†‘p)
hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))
hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1))) K)
hk : p ^ (k + 1) â‰  2
hne : NeZero â†‘â†‘(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : â†‘2 = 2
hp2 : p = 2 â†’ k â‰  0
H :
  (Algebra.norm K) ((aeval Î¶) (derivative (cyclotomic (â†‘p ^ (k + 1)) K))) * â†‘â†‘p ^ â†‘p ^ k =
    â†‘â†‘p ^ (â†‘p ^ k * (k.succ * (â†‘p - 1)).pred) * â†‘â†‘p ^ â†‘p ^ k
hnorm : (Algebra.norm K) (Î¶ ^ â†‘p ^ k - 1) = â†‘â†‘p ^ â†‘p ^ k
thisâœ : 0 < k.succ * (â†‘p - 1)
h : â†‘â†‘p ^ â†‘p ^ k = 0
this : â†‘â†‘p ^ (k + 1) â‰  0
âŠ¢ False","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : â„•).Prime]
    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1)) : â„•) K))
    (hk : p ^ (k + 1) â‰  2) : discr K (hÎ¶.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : â„•).totient / 2) * p ^ ((p : â„•) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hÎ¶.powerBasis_gen _, â†
    hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : â„•+) : â„•) = 2 := rfl
  have hp2 : p = 2 â†’ k â‰  0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  Â· rcases eq_or_ne p 2 with (rfl | hp2)
    Â· rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with âŸ¨k, rflâŸ©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      Â· simp
      Â· simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    Â· replace hp2 : (p : â„•) â‰  2 := by rwa [Ne, â† coe_two, PNat.coe_inj]
      have hpo : Odd (p : â„•) := hp.out.odd_of_ne_two hp2
      obtain âŸ¨a, haâŸ© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, â† ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  Â· have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, â† PNat.pow_coe,
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Î¶ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Î¶ ^ (p : â„•) ^ k - 1) = (p : K) ^ (p : â„•) ^ k := by
      by_cases hp : p = 2
      Â· exact mod_cast hÎ¶.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      Â· exact mod_cast hÎ¶.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, â† map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, â† succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hÎ¶.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, â† pow_mul, â† mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [â† succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : â„•) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    Â· simp only [H, mul_comm _ (k + 1)]; norm_cast
    Â· 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this","have : Irreducible (cyclotomic (p ^ (k + 1) : â„•) K) := by
  have : Irreducible (cyclotomic (p ^ (k + 1) : â„•) K) :=
    Irreducible.cyclotomic.irreducible_cyclotomic_irreducible_factor hp.out K hirr"
Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean,WeierstrassCurve.Jacobian.dblX_of_Z_eq_zero,dblX_of_Z_eq_zero,5f623dbbfb1d9c0f7f7df0c222909ea19906d81f,":= by
  linear_combination (norm := (rw [dblX, negY_of_Z_eq_zero hPz, hPz]; ring1))
    -8 * P x * (equation_of_Z_eq_zero hPz).mp hP","error:  ring failed, ring expressions not equal
R : Type u
instâœÂ¹ : CommRing R
W' : Jacobian R
F : Type v
instâœ : Field F
W : Jacobian F
P : Fin 3 â†’ R
hP : W'.Equation P
hPz : P z = 0
âŠ¢ W'.dblU P ^ 2 - P x ^ 4 * 9 = 0","lemma dblX_of_Z_eq_zero {P : Fin 3 â†’ R} (hP : W'.Equation P) (hPz : P z = 0) :
    W'.dblX P = (P x ^ 2) ^ 2 ",":= by
  linear_combination (norm := (rw [dblX, dblU_of_Z_eq_zero hPz, negY_of_Z_eq_zero hPz, hPz]; ring1))
    -8 * P x * (equation_of_Z_eq_zero hPz).mp hP","simp only [dblX, dblX_of_Z_eq_zero, dblX_eq_Z_eq_zero, dblX_of_Z_eq_zero, dblX_of_Z_eq_zero]"
Mathlib/MeasureTheory/Group/Measure.lean,MeasureTheory.measure_univ_of_isMulLeftInvariant,measure_univ_of_isMulLeftInvariant,488012d0f5ac537bb8055c310b3f223de3f6802e,":= by
  obtain âŸ¨K, hK, Kclosed, K1âŸ© : âˆƒ K : Set G, IsCompact K âˆ§ IsClosed K âˆ§ K âˆˆ ğ“ 1 :=
    exists_isCompact_isClosed_nhds_one G
  have K_pos : 0 < Î¼ K := measure_pos_of_nonempty_interior _ âŸ¨_, mem_interior_iff_mem_nhds.2 K1âŸ©
  have A : âˆ€ L : Set G, IsCompact L â†’ âˆƒ g : G, Disjoint L (g â€¢ K) := fun L hL =>
    exists_disjoint_smul_of_isCompact hL hK
  choose! g hg using A
  set L : â„• â†’ Set G := fun n => (fun T => T âˆª g T â€¢ K)^[n] K
  have Lcompact : âˆ€ n, IsCompact (L n) := by
    intro n
    induction' n with n IH
    Â· exact hK
    Â· simp_rw [iterate_succ']
      apply IsCompact.union IH (hK.smul (g (L n)))
  have Lclosed : âˆ€ n, IsClosed (L n) := by
    intro n
    induction' n with n IH
    Â· exact Kclosed
    Â· simp_rw [iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : âˆ€ n, Î¼ (L n) = (n + 1 : â„•) * Î¼ K := by
    intro n
    induction' n with n IH
    Â· simp only [one_mul, Nat.cast_one, iterate_zero, id.def, Nat.zero_eq, Nat.zero_add]
    Â· calc
        Î¼ (L (n + 1)) = Î¼ (L n) + Î¼ (g (L n) â€¢ K) := by
          simp_rw [iterate_succ']
          exact measure_union' (hg _ (Lcompact _)) (Lclosed _).measurableSet
        _ = (n + 1 + 1 : â„•) * Î¼ K := by
          simp only [IH, measure_smul, add_mul, Nat.cast_add, Nat.cast_one, one_mul]
  have N : Tendsto (fun n => Î¼ (L n)) atTop (ğ“ (âˆ * Î¼ K)) := by
    simp_rw [M]
    apply ENNReal.Tendsto.mul_const _ (Or.inl ENNReal.top_ne_zero)
    exact ENNReal.tendsto_nat_nhds_top.comp (tendsto_add_atTop_nat _)
  simp only [ENNReal.top_mul', K_pos.ne', if_false] at N
  apply top_le_iff.1
  exact le_of_tendsto' N fun n => measure_mono (subset_univ _)","warning:  `exists_isCompact_isClosed_nhds_one` has been deprecated, use `exists_mem_nhds_isCompact_isClosed` instead
error:  simp made no progress
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.183761 â†’ ?m.183761
error:  unsolved goals
case zero
ğ•œ : Type u_1
G : Type u_2
H : Type u_3
instâœÂ¹â° : MeasurableSpace G
instâœâ¹ : MeasurableSpace H
instâœâ¸ : TopologicalSpace G
instâœâ· : BorelSpace G
Î¼âœ : Measure G
instâœâ¶ : Group G
instâœâµ : TopologicalGroup G
instâœâ´ : Î¼âœ.IsMulLeftInvariant
instâœÂ³ : WeaklyLocallyCompactSpace G
instâœÂ² : NoncompactSpace G
Î¼ : Measure G
instâœÂ¹ : Î¼.IsOpenPosMeasure
instâœ : Î¼.IsMulLeftInvariant
K : Set G
hK : IsCompact K
Kclosed : IsClosed K
K1 : K âˆˆ ğ“ 1
K_pos : 0 < Î¼ K
g : Set G â†’ G
hg : âˆ€ (L : Set G), IsCompact L â†’ Disjoint L (g L â€¢ K)
L : â„• â†’ Set G := fun n â†¦ (fun T â†¦ T âˆª g T â€¢ K)^[n] K
Lcompact : âˆ€ (n : â„•), IsCompact (L n)
Lclosed : âˆ€ (n : â„•), IsClosed (L n)
âŠ¢ Î¼ (L 0) = Î¼ K
error:  simp made no progress","theorem measure_univ_of_isMulLeftInvariant [WeaklyLocallyCompactSpace G] [NoncompactSpace G]
    (Î¼ : Measure G) [IsOpenPosMeasure Î¼] [Î¼.IsMulLeftInvariant] : Î¼ univ = âˆ ",":= by
  obtain âŸ¨K, K1, hK, KclosedâŸ© : âˆƒ K âˆˆ ğ“ (1 : G), IsCompact K âˆ§ IsClosed K :=
    exists_mem_nhds_isCompact_isClosed 1
  have K_pos : 0 < Î¼ K := measure_pos_of_mem_nhds Î¼ K1
  have A : âˆ€ L : Set G, IsCompact L â†’ âˆƒ g : G, Disjoint L (g â€¢ K) := fun L hL =>
    exists_disjoint_smul_of_isCompact hL hK
  choose! g hg using A
  set L : â„• â†’ Set G := fun n => (fun T => T âˆª g T â€¢ K)^[n] K
  have Lcompact : âˆ€ n, IsCompact (L n) := by
    intro n
    induction' n with n IH
    Â· exact hK
    Â· simp_rw [L, iterate_succ']
      apply IsCompact.union IH (hK.smul (g (L n)))
  have Lclosed : âˆ€ n, IsClosed (L n) := by
    intro n
    induction' n with n IH
    Â· exact Kclosed
    Â· simp_rw [L, iterate_succ']
      apply IsClosed.union IH (Kclosed.smul (g (L n)))
  have M : âˆ€ n, Î¼ (L n) = (n + 1 : â„•) * Î¼ K := by
    intro n
    induction' n with n IH
    Â· simp only [L, one_mul, Nat.cast_one, iterate_zero, id, Nat.zero_eq, Nat.zero_add]
    Â· calc
        Î¼ (L (n + 1)) = Î¼ (L n) + Î¼ (g (L n) â€¢ K) := by
          simp_rw [L, iterate_succ']
          exact measure_union' (hg _ (Lcompact _)) (Lclosed _).measurableSet
        _ = (n + 1 + 1 : â„•) * Î¼ K := by
          simp only [IH, measure_smul, add_mul, Nat.cast_add, Nat.cast_one, one_mul]
  have N : Tendsto (fun n => Î¼ (L n)) atTop (ğ“ (âˆ * Î¼ K)) := by
    simp_rw [M]
    apply ENNReal.Tendsto.mul_const _ (Or.inl ENNReal.top_ne_zero)
    exact ENNReal.tendsto_nat_nhds_top.comp (tendsto_add_atTop_nat _)
  simp only [ENNReal.top_mul', K_pos.ne', if_false] at N
  apply top_le_iff.1
  exact le_of_tendsto' N fun n => measure_mono (subset_univ _)",exact measure_univ_of_isOpenPosMeasure_univ measure_univ_of_isOpenPosMeasure univ
Mathlib/Computability/Partrec.lean,Partrec.vector_mOfFn,vector_mOfFn,b912476b37f2ea41ee51af7e63439f4a769be095,"  | 0, _, _ => const _
  | n + 1, f, hf => by
    dsimp only [Vector.mOfFn, Nat.add_eq, Nat.add_zero, pure_eq_some, bind_eq_bind]
    exact
      (hf 0).bind
        (Partrec.bind ((vector_mOfFn fun i => hf i.succ).comp fst)
          (Primrec.vector_cons.to_comp.compâ‚‚ (snd.comp fst) snd).toâ‚‚)","error:  application type mismatch
  Computableâ‚‚.compâ‚‚ (Primrecâ‚‚.to_comp Primrec.vector_cons) (Computable.comp snd fst)
argument
  Computable.comp snd fst
has type
  Computable fun a â†¦ a.1.2 : Prop
but is expected to have type
  Computableâ‚‚ ?m.66955 : Prop
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information","theorem vector_mOfFn :
    âˆ€ {n} {f : Fin n â†’ Î± â†’. Ïƒ},
      (âˆ€ i, Partrec (f i)) â†’ Partrec fun a : Î± => Vector.mOfFn fun i => f i a
","  | 0, _, _ => const _
  | n + 1, f, hf => by
    simp only [Vector.mOfFn, Nat.add_eq, Nat.add_zero, pure_eq_some, bind_eq_bind]
    exact
      (hf 0).bind
        (Partrec.bind ((vector_mOfFn fun i => hf i.succ).comp fst)
          (Primrec.vector_cons.to_comp.comp (snd.comp fst) snd))",induction' vector_mOfFn with vector_mOfFn vector_mOfFn
Mathlib/Topology/FiberBundle/Basic.lean,FiberBundle.exists_trivialization_Icc_subset,FiberBundle.exists_trivialization_Icc_subset,5192777c94aec06289e492ce206d68fbbe72572c,":= by
  obtain âŸ¨ea, heaâŸ© : âˆƒ ea : Trivialization F (Ï€ F E), a âˆˆ ea.baseSet :=
    âŸ¨trivializationAt F E a, mem_baseSet_trivializationAt F E aâŸ©
  cases' lt_or_le b a with hab hab
  Â· exact âŸ¨ea, by simp [*]âŸ©
  set s : Set B := { x âˆˆ Icc a b | âˆƒ e : Trivialization F (Ï€ F E), Icc a x âŠ† e.baseSet }
  have ha : a âˆˆ s := âŸ¨left_mem_Icc.2 hab, ea, by simp [hea]âŸ©
  have sne : s.Nonempty := âŸ¨a, haâŸ©
  have hsb : b âˆˆ upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := âŸ¨b, hsbâŸ©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c âˆˆ Icc a b := âŸ¨hsc.1 ha, hsc.2 hsbâŸ©
  obtain âŸ¨-, ec : Trivialization F (Ï€ F E), hec : Icc a c âŠ† ec.baseSetâŸ© : c âˆˆ s := by
    rcases hc.1.eq_or_lt with heq | hlt
    Â· rwa [â† heq]
    refine âŸ¨hc, ?_âŸ©
    obtain âŸ¨ec, hcâŸ© : âˆƒ ec : Trivialization F (Ï€ F E), c âˆˆ ec.baseSet :=
      âŸ¨trivializationAt F E c, mem_baseSet_trivializationAt F E câŸ©
    obtain âŸ¨c', hc', hc'eâŸ© : âˆƒ c' âˆˆ Ico a c, Ioc c' c âŠ† ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain âŸ¨d, âŸ¨hdab, ead, hadâŸ©, hdâŸ© : âˆƒ d âˆˆ s, d âˆˆ Ioc c' c := hsc.exists_between hc'.2
    refine' âŸ¨ead.piecewiseLe ec d (had âŸ¨hdab.1, le_rflâŸ©) (hc'e hd), subset_ite.2 _âŸ©
    refine' âŸ¨fun x hx => had âŸ¨hx.1.1, hx.2âŸ©, fun x hx => hc'e âŸ¨hd.1.trans (not_le.1 hx.2), hx.1.2âŸ©âŸ©
  rcases hc.2.eq_or_lt with heq | hlt
  Â· exact âŸ¨ec, heq â–¸ hecâŸ©
  rsuffices âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, âˆƒ e : Trivialization F (Ï€ F E), Icc a d âŠ† e.baseSet
  Â· exact ((hsc.1 âŸ¨âŸ¨hc.1.trans hdcb.1.le, hdcb.2âŸ©, hdâŸ©).not_lt hdcb.1).elim
  obtain âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, Ico c d âŠ† ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec âŸ¨hc.1, le_rflâŸ©))
  have had : Ico a d âŠ† ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  Â· obtain âŸ¨ed, hedâŸ© : âˆƒ ed : Trivialization F (Ï€ F E), d âˆˆ ed.baseSet :=
      âŸ¨trivializationAt F E d, mem_baseSet_trivializationAt F E dâŸ©
    refine' âŸ¨d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono (inter_subset_right _ _) (inter_subset_right _ _)), fun x hx => _âŸ©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr âŸ¨hed, hdcb.1âŸ©, Or.inl âŸ¨had âŸ¨hx.1, hxdâŸ©, hxdâŸ©]
  Â· rw [disjoint_left] at he
    push_neg at he
    rcases he with âŸ¨d', hdd' : d' < d, hd'câŸ©
    exact âŸ¨d', âŸ¨hd'c, hdd'.le.trans hdcb.2âŸ©, ec, (Icc_subset_Ico_right hdd').trans hadâŸ©","error:  function expected at
  inter_subset_right ?m.16125
term has type
  ?m.16124 âˆˆ ?m.16123
error:  function expected at
  inter_subset_right ?m.16167
term has type
  ?m.16166 âˆˆ ?m.16165","theorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]
    [OrderTopology B] [FiberBundle F E] (a b : B) :
    âˆƒ e : Trivialization F (Ï€ F E), Icc a b âŠ† e.baseSet ",":= by
  obtain âŸ¨ea, heaâŸ© : âˆƒ ea : Trivialization F (Ï€ F E), a âˆˆ ea.baseSet :=
    âŸ¨trivializationAt F E a, mem_baseSet_trivializationAt F E aâŸ©
  cases' lt_or_le b a with hab hab
  Â· exact âŸ¨ea, by simp [*]âŸ©
  set s : Set B := { x âˆˆ Icc a b | âˆƒ e : Trivialization F (Ï€ F E), Icc a x âŠ† e.baseSet }
  have ha : a âˆˆ s := âŸ¨left_mem_Icc.2 hab, ea, by simp [hea]âŸ©
  have sne : s.Nonempty := âŸ¨a, haâŸ©
  have hsb : b âˆˆ upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := âŸ¨b, hsbâŸ©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c âˆˆ Icc a b := âŸ¨hsc.1 ha, hsc.2 hsbâŸ©
  obtain âŸ¨-, ec : Trivialization F (Ï€ F E), hec : Icc a c âŠ† ec.baseSetâŸ© : c âˆˆ s := by
    rcases hc.1.eq_or_lt with heq | hlt
    Â· rwa [â† heq]
    refine âŸ¨hc, ?_âŸ©
    obtain âŸ¨ec, hcâŸ© : âˆƒ ec : Trivialization F (Ï€ F E), c âˆˆ ec.baseSet :=
      âŸ¨trivializationAt F E c, mem_baseSet_trivializationAt F E câŸ©
    obtain âŸ¨c', hc', hc'eâŸ© : âˆƒ c' âˆˆ Ico a c, Ioc c' c âŠ† ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain âŸ¨d, âŸ¨hdab, ead, hadâŸ©, hdâŸ© : âˆƒ d âˆˆ s, d âˆˆ Ioc c' c := hsc.exists_between hc'.2
    refine âŸ¨ead.piecewiseLe ec d (had âŸ¨hdab.1, le_rflâŸ©) (hc'e hd), subset_ite.2 ?_âŸ©
    exact âŸ¨fun x hx => had âŸ¨hx.1.1, hx.2âŸ©, fun x hx => hc'e âŸ¨hd.1.trans (not_le.1 hx.2), hx.1.2âŸ©âŸ©
  rcases hc.2.eq_or_lt with heq | hlt
  Â· exact âŸ¨ec, heq â–¸ hecâŸ©
  rsuffices âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, âˆƒ e : Trivialization F (Ï€ F E), Icc a d âŠ† e.baseSet
  Â· exact ((hsc.1 âŸ¨âŸ¨hc.1.trans hdcb.1.le, hdcb.2âŸ©, hdâŸ©).not_lt hdcb.1).elim
  obtain âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, Ico c d âŠ† ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec âŸ¨hc.1, le_rflâŸ©))
  have had : Ico a d âŠ† ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  Â· obtain âŸ¨ed, hedâŸ© : âˆƒ ed : Trivialization F (Ï€ F E), d âˆˆ ed.baseSet :=
      âŸ¨trivializationAt F E d, mem_baseSet_trivializationAt F E dâŸ©
    refine âŸ¨d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono inter_subset_right inter_subset_right), fun x hx => ?_âŸ©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr âŸ¨hed, hdcb.1âŸ©, Or.inl âŸ¨had âŸ¨hx.1, hxdâŸ©, hxdâŸ©]
  Â· rw [disjoint_left] at he
    push_neg at he
    rcases he with âŸ¨d', hdd' : d' < d, hd'câŸ©
    exact âŸ¨d', âŸ¨hd'c, hdd'.le.trans hdcb.2âŸ©, ec, (Icc_subset_Ico_right hdd').trans hadâŸ©","rcases FiberBundle.exists_trivialization_Icc_subset with âŸ¨e, heâŸ©"
Mathlib/Data/Seq/Computation.lean,Computation.bind_pure,bind_pure,3c930599229893e1b6a931304cf4efff4a01b172,":= by
  apply eq_of_bisim fun câ‚ câ‚‚ => câ‚ = câ‚‚ âˆ¨ âˆƒ s, câ‚ = bind s (pure âˆ˜ f) âˆ§ câ‚‚ = map f s
  Â· intro câ‚ câ‚‚ h
    exact
      match câ‚, câ‚‚, h with
      | _, câ‚‚, Or.inl (Eq.refl _) => by cases' dest câ‚‚ with b cb <;> simp
      | _, _, Or.inr âŸ¨s, rfl, rflâŸ© => by
        induction' s using recOn' with _ s <;> simp
        exact Or.inr âŸ¨s, rfl, rflâŸ©
  Â· exact Or.inr âŸ¨s, rfl, rflâŸ©","error:  unknown identifier 'dest'
error:  tactic 'induction' failed, major premise type is not an inductive type 
  ?m.28354
Î± : Type u
Î² : Type v
Î³ : Type w
f : Î± â†’ Î²
s : Computation Î±
câ‚ câ‚‚âœ : Computation Î²
h : câ‚ = câ‚‚âœ âˆ¨ âˆƒ s, câ‚ = s.bind (pure âˆ˜ f) âˆ§ câ‚‚âœ = map f s
câ‚‚ : Computation Î²
xâœ : ?m.28354
âŠ¢ BisimO (fun câ‚ câ‚‚ â†¦ câ‚ = câ‚‚ âˆ¨ âˆƒ s, câ‚ = s.bind (pure âˆ˜ f) âˆ§ câ‚‚ = map f s) câ‚‚.destruct câ‚‚.destruct
error:  unknown identifier 'recOn''",theorem bind_pure (f : Î± â†’ Î²) (s) : bind s (pure âˆ˜ f) = map f s ,":= by
  apply eq_of_bisim fun câ‚ câ‚‚ => câ‚ = câ‚‚ âˆ¨ âˆƒ s, câ‚ = bind s (pure âˆ˜ f) âˆ§ câ‚‚ = map f s
  Â· intro câ‚ câ‚‚ h
    match câ‚, câ‚‚, h with
    | _, câ‚‚, Or.inl (Eq.refl _) => cases' destruct câ‚‚ with b cb <;> simp
    | _, _, Or.inr âŸ¨s, rfl, rflâŸ© =>
      apply recOn s <;> intro s <;> simp
      exact Or.inr âŸ¨s, rfl, rflâŸ©
  Â· exact Or.inr âŸ¨s, rfl, rflâŸ©","simp [map, bind, map, bind_pure, bind_pure]"
Mathlib/Analysis/SpecialFunctions/Integrals.lean,integral_pow_abs_sub_uIoc,integral_pow_abs_sub_uIoc,e92ad7acc4d771729f70601a74a3c091f330e507,":= by
  cases' le_or_lt a b with hab hab
  Â· calc
      âˆ« x in Î™ a b, |x - a| ^ n = âˆ« x in [a:b], |x - a| ^ n := by
        rw [uIoc_of_le hab, â† integral_of_le hab]
      _ = âˆ« x in [0:(b - a)], x ^ n := by
        simp only [integral_comp_sub_right fun x => |x| ^ n, sub_self]
        refine' integral_congr fun x hx => congr_argâ‚‚ Pow.pow (abs_of_nonneg <| _) rfl
        rw [uIcc_of_le (sub_nonneg.2 hab)] at hx
        exact hx.1
      _ = |b - a| ^ (n + 1) / (n + 1) := by simp [abs_of_nonneg (sub_nonneg.2 hab)]
  Â· calc
      âˆ« x in Î™ a b, |x - a| ^ n = âˆ« x in [b:a], |x - a| ^ n := by
        rw [uIoc_of_lt hab, â† integral_of_le hab.le]
      _ = âˆ« x in [b - a:0], (-x) ^ n := by
        simp only [integral_comp_sub_right fun x => |x| ^ n, sub_self]
        refine' integral_congr fun x hx => congr_argâ‚‚ Pow.pow (abs_of_nonpos <| _) rfl
        rw [uIcc_of_le (sub_nonpos.2 hab.le)] at hx
        exact hx.2
      _ = |b - a| ^ (n + 1) / (n + 1) := by
        simp [integral_comp_neg fun x => x ^ n, abs_of_neg (sub_neg.2 hab)]","error:  type mismatch
  a
has type
  â„ : Type
but is expected to have type
  â„• : Type
error:  type mismatch
  b
has type
  â„ : Type
but is expected to have type
  â„• : Type
error:  type mismatch
  b - a
has type
  â„ : outParam Type
but is expected to have type
  â„• : Type
error:  unsolved goals
a b : â„
n : â„•
hab : a â‰¤ b
âŠ¢ âˆ« (x : â„) in a..b, |x - a| ^ n = âˆ« (x : â„) in sorryAx (Set â„) true, |x - a| ^ n
error:  simp made no progress
error:  unsolved goals
a b : â„
n : â„•
hab : a â‰¤ b
âŠ¢ âˆ« (x : â„) in sorryAx (Set â„) true, x ^ n = (b - a) ^ (n + 1) / (â†‘n + 1)
error:  type mismatch
  b
has type
  â„ : Type
but is expected to have type
  â„• : Type
error:  type mismatch
  a
has type
  â„ : Type
but is expected to have type
  â„• : Type
error:  type mismatch
  b - a
has type
  â„ : outParam Type
but is expected to have type
  â„• : Type
error:  unknown identifier 'uIoc_of_lt'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.106442
a b : â„
n : â„•
hab : b < a
âŠ¢ âˆ« (x : â„) in Î™ a b, |x - a| ^ n = âˆ« (x : â„) in sorryAx (Set â„) true, |x - a| ^ n
error:  simp made no progress
error:  unsolved goals
a b : â„
n : â„•
hab : b < a
âŠ¢ âˆ« (x : â„) in sorryAx (Set â„) true, (-x) ^ n = (a - b) ^ (n + 1) / (â†‘n + 1)","theorem integral_pow_abs_sub_uIoc : âˆ« x in Î™ a b, |x - a| ^ n = |b - a| ^ (n + 1) / (n + 1) ",":= by
  rcases le_or_lt a b with hab | hab
  Â· calc
      âˆ« x in Î™ a b, |x - a| ^ n = âˆ« x in a..b, |x - a| ^ n := by
        rw [uIoc_of_le hab, â† integral_of_le hab]
      _ = âˆ« x in (0)..(b - a), x ^ n := by
        simp only [integral_comp_sub_right fun x => |x| ^ n, sub_self]
        refine integral_congr fun x hx => congr_argâ‚‚ Pow.pow (abs_of_nonneg <| ?_) rfl
        rw [uIcc_of_le (sub_nonneg.2 hab)] at hx
        exact hx.1
      _ = |b - a| ^ (n + 1) / (n + 1) := by simp [abs_of_nonneg (sub_nonneg.2 hab)]
  Â· calc
      âˆ« x in Î™ a b, |x - a| ^ n = âˆ« x in b..a, |x - a| ^ n := by
        rw [uIoc_of_ge hab.le, â† integral_of_le hab.le]
      _ = âˆ« x in b - a..0, (-x) ^ n := by
        simp only [integral_comp_sub_right fun x => |x| ^ n, sub_self]
        refine integral_congr fun x hx => congr_argâ‚‚ Pow.pow (abs_of_nonpos <| ?_) rfl
        rw [uIcc_of_le (sub_nonpos.2 hab.le)] at hx
        exact hx.2
      _ = |b - a| ^ (n + 1) / (n + 1) := by
        simp [integral_comp_neg fun x => x ^ n, abs_of_neg (sub_neg.2 hab)]",rw [integral_pow_abs_sub_uIoc]
Mathlib/Analysis/NormedSpace/Basic.lean,norm_zsmul,norm_zsmul,c86bc80f26aebc1f53b230ad6d93c599076697c4,":= by
  rw [zsmul_eq_smul_cast Î±, norm_smul]","warning:  NormedSpace does not have a doc string
error:  failed to synthesize
  Ring Î±
use `set_option diagnostics true` to get diagnostic information
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.5022
ğ•œ : Type u_1
ğ•œ' : Type u_2
E : Type u_3
F : Type u_4
Î± : Type u_5
instâœâµ : NormedField ğ•œ
instâœâ´ : SeminormedAddCommGroup E
instâœÂ³ : SeminormedAddCommGroup F
instâœÂ² : NormedSpace ğ•œ E
instâœÂ¹ : NormedSpace ğ•œ F
instâœ : NormedSpace ğ•œ E
n : â„¤
x : E
âŠ¢ â€–n â€¢ xâ€– = â€–â†‘nâ€– * â€–xâ€–
warning:  NormedAlgebra does not have a doc string",theorem norm_zsmul [NormedSpace ğ•œ E] (n : â„¤) (x : E) : â€–n â€¢ xâ€– = â€–(n : ğ•œ)â€– * â€–xâ€– ,":= by
  rw [â† norm_smul, â† Int.smul_one_eq_cast, smul_assoc, one_smul]","simp only [norm_zsmul, NormedSpace.norm_zsmul, NormedSpace.norm_zsmul, NormedSpace.norm_zsmul]"
Mathlib/Order/ConditionallyCompleteLattice/Basic.lean,exists_between_of_forall_le,exists_between_of_forall_le,bb17f9bbca775827bc6d27267b4a5539878160d1,":=
  âŸ¨infâ‚› t, fun x hx => le_cinfâ‚› tne <| hst x hx, fun _ hy => cinfâ‚›_le (sne.mono hst) hyâŸ©","error:  unknown identifier 'infâ‚›'
error:  unknown identifier 'le_cinfâ‚›'
error:  unknown identifier 'cinfâ‚›_le'","theorem exists_between_of_forall_le (sne : s.Nonempty) (tne : t.Nonempty)
    (hst : âˆ€ x âˆˆ s, âˆ€ y âˆˆ t, x â‰¤ y) : (upperBounds s âˆ© lowerBounds t).Nonempty ",":=
  âŸ¨sInf t, fun x hx => le_csInf tne <| hst x hx, fun _ hy => csInf_le (sne.mono hst) hyâŸ©",refine âŸ¨exists_between_of_forall_le exists_between_of_forall_le exists_between_of_forall_le sne hst ?_ ?_âŸ©
Mathlib/Topology/TietzeExtension.lean,ContinuousMap.exists_extension,ContinuousMap.exists_extension,050597bd179a992452551cc51fe5aea3b4bdaf61,":= by
  let e' : Xâ‚ â‰ƒâ‚œ Set.range e := he.toEmbedding.toHomeomorph
  obtain âŸ¨g, hgâŸ© := (f.comp e'.symm).exists_restrict_eq he.isClosed_range
  exact âŸ¨g, by ext x; simpa using congr($(hg) âŸ¨e' x, x, rflâŸ©)âŸ©","error:  invalid field 'toHomeomorph', the environment does not contain 'Embedding.toHomeomorph'
  he.toEmbedding
has type
  Embedding e
error:  application type mismatch
  Exists.intro x rfl
argument
  rfl
has type
  e x = e x : Prop
but is expected to have type
  e x = â†‘(e' x) : Prop","theorem ContinuousMap.exists_extension (f : C(Xâ‚, Y)) :
    âˆƒ (g : C(X, Y)), g.comp âŸ¨e, he.continuousâŸ© = f ",":= by
  let e' : Xâ‚ â‰ƒâ‚œ Set.range e := Homeomorph.ofEmbedding _ he.toEmbedding
  obtain âŸ¨g, hgâŸ© := (f.comp e'.symm).exists_restrict_eq he.isClosed_range
  exact âŸ¨g, by ext x; simpa using congr($(hg) âŸ¨e' x, x, rflâŸ©)âŸ©","simp only [ContinuousMap.exists_extension, exists_extension]"
Mathlib/RingTheory/WittVector/Isocrystal.lean,WittVector.isocrystal_classification,isocrystal_classification,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  haveI : Nontrivial V := FiniteDimensional.nontrivial_of_finrank_eq_succ h_dim
  obtain âŸ¨x, hxâŸ© : âˆƒ x : V, x â‰  0 := exists_ne 0
  have : Î¦(p, k) x â‰  0 := by simpa only [map_zero] using Î¦(p, k).injective.ne hx
  obtain âŸ¨a, ha, haxâŸ© : âˆƒ a : K(p, k), a â‰  0 âˆ§ Î¦(p, k) x = a â€¢ x := by
    rw [finrank_eq_one_iff_of_nonzero' x hx] at h_dim
    obtain âŸ¨a, haâŸ© := h_dim (Î¦(p, k) x)
    refine' âŸ¨a, _, ha.symmâŸ©
    intro ha'
    apply this
    simp only [â† ha, ha', zero_smul]
  obtain âŸ¨b, hb, m, hmbâŸ© := WittVector.exists_frobenius_solution_fractionRing p ha
  replace hmb : Ï†(p, k) b * a = (p : K(p, k)) ^ m * b := by convert hmb
  use m
  let Fâ‚€ : StandardOneDimIsocrystal p k m â†’â‚—[K(p, k)] V := LinearMap.toSpanSingleton K(p, k) V x
  let F : StandardOneDimIsocrystal p k m â‰ƒâ‚—[K(p, k)] V := by
    refine' LinearEquiv.ofBijective Fâ‚€ âŸ¨_, _âŸ©
    Â· rw [â† LinearMap.ker_eq_bot]
      exact LinearMap.ker_toSpanSingleton K(p, k) V hx
    Â· rw [â† LinearMap.range_eq_top]
      rw [â† (finrank_eq_one_iff_of_nonzero x hx).mp h_dim]
      rw [LinearMap.span_singleton_eq_range]
  let E := (LinearEquiv.smulOfNeZero K(p, k) _ _ hb).trans F
  refine' âŸ¨âŸ¨E, _âŸ©âŸ©
  simp only
  intro c
  rw [LinearEquiv.trans_apply, LinearEquiv.trans_apply, LinearEquiv.smulOfNeZero_apply,
    LinearEquiv.smulOfNeZero_apply, LinearEquiv.map_smul, LinearEquiv.map_smul]
  rw [LinearEquiv.ofBijective_apply, LinearEquiv.ofBijective_apply]
  erw [LinearMap.toSpanSingleton_apply K(p, k) V x c, LinearMap.toSpanSingleton_apply K(p, k) V x]
  simp only [hax, LinearEquiv.ofBijective_apply, LinearMap.toSpanSingleton_apply,
    LinearEquiv.map_smulâ‚›â‚—, StandardOneDimIsocrystal.frobenius_apply, Algebra.id.smul_eq_mul]
  simp only [â† mul_smul]
  congr 1
  erw [smul_eq_mul]
  simp only [map_zpowâ‚€, map_natCast]
  linear_combination Ï†(p, k) c * hmb",error:  simp made no progress,"theorem isocrystal_classification (k : Type*) [Field k] [IsAlgClosed k] [CharP k p] (V : Type*)
    [AddCommGroup V] [Isocrystal p k V] (h_dim : finrank K(p, k) V = 1) :
    âˆƒ m : â„¤, Nonempty (StandardOneDimIsocrystal p k m â‰ƒá¶ â±[p, k] V) ",":= by
  haveI : Nontrivial V := FiniteDimensional.nontrivial_of_finrank_eq_succ h_dim
  obtain âŸ¨x, hxâŸ© : âˆƒ x : V, x â‰  0 := exists_ne 0
  have : Î¦(p, k) x â‰  0 := by simpa only [map_zero] using Î¦(p, k).injective.ne hx
  obtain âŸ¨a, ha, haxâŸ© : âˆƒ a : K(p, k), a â‰  0 âˆ§ Î¦(p, k) x = a â€¢ x := by
    rw [finrank_eq_one_iff_of_nonzero' x hx] at h_dim
    obtain âŸ¨a, haâŸ© := h_dim (Î¦(p, k) x)
    refine âŸ¨a, ?_, ha.symmâŸ©
    intro ha'
    apply this
    simp only [â† ha, ha', zero_smul]
  obtain âŸ¨b, hb, m, hmbâŸ© := WittVector.exists_frobenius_solution_fractionRing p ha
  replace hmb : Ï†(p, k) b * a = (p : K(p, k)) ^ m * b := by convert hmb
  use m
  let Fâ‚€ : StandardOneDimIsocrystal p k m â†’â‚—[K(p, k)] V := LinearMap.toSpanSingleton K(p, k) V x
  let F : StandardOneDimIsocrystal p k m â‰ƒâ‚—[K(p, k)] V := by
    refine LinearEquiv.ofBijective Fâ‚€ âŸ¨?_, ?_âŸ©
    Â· rw [â† LinearMap.ker_eq_bot]
      exact LinearMap.ker_toSpanSingleton K(p, k) V hx
    Â· rw [â† LinearMap.range_eq_top]
      rw [â† (finrank_eq_one_iff_of_nonzero x hx).mp h_dim]
      rw [LinearMap.span_singleton_eq_range]
  refine âŸ¨âŸ¨(LinearEquiv.smulOfNeZero K(p, k) _ _ hb).trans F, fun c â†¦ ?_âŸ©âŸ©
  rw [LinearEquiv.trans_apply, LinearEquiv.trans_apply, LinearEquiv.smulOfNeZero_apply,
    LinearEquiv.smulOfNeZero_apply, LinearEquiv.map_smul, LinearEquiv.map_smul]
  rw [LinearEquiv.ofBijective_apply, LinearEquiv.ofBijective_apply]
  erw [LinearMap.toSpanSingleton_apply K(p, k) V x c, LinearMap.toSpanSingleton_apply K(p, k) V x]
  simp only [hax, LinearEquiv.ofBijective_apply, LinearMap.toSpanSingleton_apply,
    LinearEquiv.map_smulâ‚›â‚—, StandardOneDimIsocrystal.frobenius_apply, Algebra.id.smul_eq_mul]
  simp only [â† mul_smul]
  congr 1
  linear_combination Ï†(p, k) c * hmb","obtain âŸ¨m, hmâŸ© := finrank_eq_one_iff.mp h_dim"
Mathlib/MeasureTheory/Measure/OpenPos.lean,MeasureTheory.Measure.eqOn_open_of_ae_eq,eqOn_open_of_ae_eq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  replace h := ae_imp_of_ae_restrict h
  simp only [EventuallyEq, ae_iff, not_imp] at h
  have : IsOpen (U âˆ© { a | f a â‰  g a }) := by
    refine' isOpen_iff_mem_nhds.mpr fun a ha => inter_mem (hU.mem_nhds ha.1) _
    rcases ha with âŸ¨ha : a âˆˆ U, ha' : (f a, g a) âˆˆ (diagonal Y)á¶œâŸ©
    exact
      (hf.continuousAt (hU.mem_nhds ha)).prod_mk_nhds (hg.continuousAt (hU.mem_nhds ha))
        (isClosed_diagonal.isOpen_compl.mem_nhds ha')
  replace := (this.eq_empty_of_measure_zero h).le
  exact fun x hx => Classical.not_not.1 fun h => this âŸ¨hx, hâŸ©","error:  ambiguous, possible interpretations 
  _root_.not_imp : Â¬(?m.11750 â†’ ?m.11751) â†” ?m.11750 âˆ§ Â¬?m.11751
  
  Classical.not_imp : Â¬(?m.11752 â†’ ?m.11753) â†” ?m.11752 âˆ§ Â¬?m.11753
error:  application type mismatch
  IsOpen.eq_empty_of_measure_zero this h
argument
  h
has type
  Î¼ {a | Â¬(a âˆˆ U â†’ f a = g a)} = 0 : Prop
but is expected to have type
  Î¼ (U âˆ© {a | f a â‰  g a}) = 0 : Prop","theorem eqOn_open_of_ae_eq {f g : X â†’ Y} (h : f =áµ[Î¼.restrict U] g) (hU : IsOpen U)
    (hf : ContinuousOn f U) (hg : ContinuousOn g U) : EqOn f g U ",":= by
  replace h := ae_imp_of_ae_restrict h
  simp only [EventuallyEq, ae_iff, Classical.not_imp] at h
  have : IsOpen (U âˆ© { a | f a â‰  g a }) := by
    refine isOpen_iff_mem_nhds.mpr fun a ha => inter_mem (hU.mem_nhds ha.1) ?_
    rcases ha with âŸ¨ha : a âˆˆ U, ha' : (f a, g a) âˆˆ (diagonal Y)á¶œâŸ©
    exact
      (hf.continuousAt (hU.mem_nhds ha)).prod_mk_nhds (hg.continuousAt (hU.mem_nhds ha))
        (isClosed_diagonal.isOpen_compl.mem_nhds ha')
  replace := (this.eq_empty_of_measure_zero h).le
  exact fun x hx => Classical.not_not.1 fun h => this âŸ¨hx, hâŸ©",rw [eqOn_iff_eqOn]
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.IsReflection.length_mul_left_ne,length_mul_left_ne,89085fd549cb149c97d10e77f9506ec174187f88,":= by
  apply_fun (Â· % 2)
  dsimp only
  rw [length_mul_mod_two]
  intro h
  have := h â–¸ Nat.mod_two_add_add_odd_mod_two (â„“ w) ht.length_odd
  exact Nat.add_self_ne_one _ this","error:  invalid field 'length_odd', the environment does not contain 'CoxeterSystem.IsReflection.length_odd'
  ht
has type
  cs.IsReflection t
error:  invalid field 'length_odd', the environment does not contain 'Exists.length_odd'
  ht
has type
  âˆƒ w i, t = w * cs.simple i * wâ»Â¹
error:  invalid field notation, function 'CoxeterSystem.IsReflection.length_mul_left_ne' does not have argument with type (CoxeterSystem.IsReflection ...) that can be used, it must be explicit or implicit with a unique name",theorem length_mul_left_ne (w : W) : â„“ (w * t) â‰  â„“ w ,":= by
  suffices cs.lengthParity (w * t) â‰  cs.lengthParity w by
    contrapose! this
    simp only [lengthParity_eq_ofAdd_length, this]
  rcases ht with âŸ¨w, i, rflâŸ©
  simp [lengthParity_simple]","simp only [length_mul_left_ne, length_mul_left_ne]"
Mathlib/Data/Nat/Factorial/DoubleFactorial.lean,Nat.doubleFactorial_le_factorial,doubleFactorial_le_factorial,0bb63b2bff135338722ab98f6da549f3e6350f0a,"  | 0 => le_rfl
  | n + 1 => by
    rw [factorial_eq_mul_doubleFactorial]; exact le_mul_of_pos_right n.doubleFactorial_pos","warning:  doubleFactorial does not have a doc string
error:  unknown identifier 'le_mul_of_pos_right'","lemma doubleFactorial_le_factorial : âˆ€ n, nâ€¼ â‰¤ n !
","  | 0 => le_rfl
  | n + 1 => by
    rw [factorial_eq_mul_doubleFactorial]; exact Nat.le_mul_of_pos_right _ n.doubleFactorial_pos",rw [â† factorial_le_factorial_le_factorial]
Mathlib/Geometry/Manifold/IntegralCurve.lean,IsIntegralCurve.isIntegralCurveAt,IsIntegralCurve.isIntegralCurveAt,fa459a52b70eb1e82d98d32addd467b39f69d576,":= âŸ¨univ, Filter.univ_mem, fun t _ => h tâŸ©","error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  (ğ“ t).1 {x | (fun t â†¦ HasMFDerivAt ğ“˜(â„, â„) I Î³ t (ContinuousLinearMap.smulRight 1 (v (Î³ t)))) x}","lemma IsIntegralCurve.isIntegralCurveAt (h : IsIntegralCurve Î³ v) (t : â„) :
    IsIntegralCurveAt Î³ v t ",":= isIntegralCurveAt_iff.mpr âŸ¨univ, Filter.univ_mem, fun t _ â†¦ h tâŸ©",apply IsIntegralCurve.isIntegralCurveAt_isIntegralCurveAt
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow_ne_two,discr_prime_pow_ne_two,704efa4d928b79ac7249410b96a25d6fba557a5e,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hÎ¶.powerBasis_gen _, â†
    hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), succ_sub_one]
  have coe_two : ((2 : â„•+) : â„•) = 2 := rfl
  have hp2 : p = 2 â†’ k â‰  0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  Â· rcases eq_or_ne p 2 with (rfl | hp2)
    Â· rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with âŸ¨k, rflâŸ©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      Â· simp
      Â· norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    Â· replace hp2 : (p : â„•) â‰  2
      Â· rwa [Ne.def, â† coe_two, PNat.coe_inj]
      have hpo : Odd (p : â„•) := hp.out.odd_of_ne_two hp2
      obtain âŸ¨a, haâŸ© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]; Â· norm_cast
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, â† ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  Â· have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, â† PNat.pow_coe,
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Î¶ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, MulZeroClass.zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Î¶ ^ (p : â„•) ^ k - 1) = (p : K) ^ (p : â„•) ^ k := by
      by_cases hp : p = 2
      Â· exact_mod_cast hÎ¶.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      Â· exact_mod_cast hÎ¶.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, â† map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, â† succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hÎ¶.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, â† pow_mul, â† mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [â† succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : â„•) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    Â· simp only [H, mul_comm _ (k + 1)]; norm_cast
    Â· 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by linarith)] at this
      exact absurd (pow_eq_zero h) this","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case e_a.inr
p : â„•+
k : â„•
K : Type u
L : Type v
Î¶ : L
instâœÂ³ : Field K
instâœÂ² : Field L
instâœÂ¹ : Algebra K L
instâœ : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime â†‘p)
hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))
hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1))) K)
hk : p ^ (k + 1) â‰  2
hne : NeZero â†‘â†‘(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : â†‘2 = 2
hp2âœ : p = 2 â†’ k â‰  0
hp2 : â†‘p â‰  2
âŠ¢ (-1) ^ (â†‘p ^ k * (â†‘p - 1) * (â†‘p ^ k * (â†‘p - 1) - 1) / 2) = (-1) ^ (â†‘p ^ k * (â†‘p - 1) / 2)
error:  unsolved goals
case e_a
p : â„•+
k : â„•
K : Type u
L : Type v
Î¶ : L
instâœÂ³ : Field K
instâœÂ² : Field L
instâœÂ¹ : Algebra K L
instâœ : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime â†‘p)
hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))
hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1))) K)
hk : p ^ (k + 1) â‰  2
hne : NeZero â†‘â†‘(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : â†‘2 = 2
hp2 : p = 2 â†’ k â‰  0
âŠ¢ (Algebra.norm K) ((aeval Î¶) (derivative (cyclotomic (â†‘p ^ (k + 1)) K))) = â†‘â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : â„•).Prime]
    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1)) : â„•) K))
    (hk : p ^ (k + 1) â‰  2) : discr K (hÎ¶.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : â„•).totient / 2) * p ^ ((p : â„•) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hÎ¶.powerBasis_gen _, â†
    hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : â„•+) : â„•) = 2 := rfl
  have hp2 : p = 2 â†’ k â‰  0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  Â· rcases eq_or_ne p 2 with (rfl | hp2)
    Â· rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with âŸ¨k, rflâŸ©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      Â· simp
      Â· simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    Â· replace hp2 : (p : â„•) â‰  2 := by rwa [Ne, â† coe_two, PNat.coe_inj]
      have hpo : Odd (p : â„•) := hp.out.odd_of_ne_two hp2
      obtain âŸ¨a, haâŸ© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, â† ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  Â· have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, â† PNat.pow_coe,
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Î¶ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Î¶ ^ (p : â„•) ^ k - 1) = (p : K) ^ (p : â„•) ^ k := by
      by_cases hp : p = 2
      Â· exact mod_cast hÎ¶.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      Â· exact mod_cast hÎ¶.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, â† map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, â† succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hÎ¶.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, â† pow_mul, â† mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [â† succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : â„•) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    Â· simp only [H, mul_comm _ (k + 1)]; norm_cast
    Â· 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this","have : Irreducible (cyclotomic (p ^ (k + 1) : â„•) K) := by
  have : Irreducible (cyclotomic (p ^ (k + 1) : â„•) K) :=
    Irreducible.cyclotomic.irreducible_cyclotomic_irreducible_factor hp.out K hirr"
Mathlib/Algebra/Homology/TotalComplexShift.lean,HomologicalComplexâ‚‚.Dâ‚_totalShiftâ‚‚XIso_hom,Dâ‚_totalShiftâ‚‚XIso_hom,10f63baf7e1660a2ffa3e891eef40812f434a38f,":= by
  by_cases h : (up â„¤).Rel nâ‚€ nâ‚
  Â· ext âŸ¨p, qâŸ© hpq
    dsimp at h hpq
    dsimp [totalShiftâ‚‚XIso]
    rw [Î¹_Dâ‚_assoc, Linear.comp_units_smul, Î¹_totalDesc_assoc, Linear.units_smul_comp,
      Î¹_Dâ‚, smul_smul, ((shiftFunctorâ‚‚ C y).obj K).dâ‚_eq _ rfl _ _ (by dsimp; omega),
      K.dâ‚_eq _ rfl _ _ (by dsimp; omega)]
    dsimp
    rw [one_smul, one_smul, assoc, Î¹_totalDesc, Linear.comp_units_smul, â† Int.negOnePow_add]
    congr 2
    linarith
  Â· rw [Dâ‚_shape _ _ _ _ h, zero_comp, Dâ‚_shape, comp_zero, smul_zero]
    intro h'
    apply h
    dsimp at h' âŠ¢
    omega","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?K.Î¹Total ?câ‚â‚‚ ?iâ‚ ?iâ‚‚ ?iâ‚â‚‚ ?h â‰« ?K.Dâ‚ ?câ‚â‚‚ ?iâ‚â‚‚ ?iâ‚â‚‚' â‰« ?h
case pos.hfg.mk
C : Type u_1
instâœÂ² : Category.{u_2, u_1} C
instâœÂ¹ : Preadditive C
K L : HomologicalComplexâ‚‚ C (up â„¤) (up â„¤)
f : K âŸ¶ L
x y : â„¤
instâœ : K.HasTotal (up â„¤)
nâ‚€ nâ‚ nâ‚€' nâ‚' : â„¤
hâ‚€ : nâ‚€ + y = nâ‚€'
hâ‚ : nâ‚ + y = nâ‚'
h : nâ‚€ + 1 = nâ‚
p q : â„¤
hpq : p + q = nâ‚€
âŠ¢ (((shiftFunctorâ‚‚ C y).obj K).toGradedObject.Î¹MapObj ((up â„¤).Ï€ (up â„¤) (up â„¤)) (p, q) nâ‚€ hpq â‰«
      ((shiftFunctorâ‚‚ C y).obj K).Dâ‚ (up â„¤) nâ‚€ nâ‚ â‰«
        ((shiftFunctorâ‚‚ C y).obj K).totalDesc fun p q hpq â†¦ (p * y).negOnePow â€¢ K.Î¹Total (up â„¤) p (q + y) nâ‚' â‹¯) =
    ((shiftFunctorâ‚‚ C y).obj K).toGradedObject.Î¹MapObj ((up â„¤).Ï€ (up â„¤) (up â„¤)) (p, q) nâ‚€ hpq â‰«
      (y.negOnePow â€¢
        (((shiftFunctorâ‚‚ C y).obj K).totalDesc fun p q hpq â†¦ (p * y).negOnePow â€¢ K.Î¹Total (up â„¤) p (q + y) nâ‚€' â‹¯) â‰«
          K.Dâ‚ (up â„¤) nâ‚€' nâ‚')","lemma Dâ‚_totalShiftâ‚‚XIso_hom (nâ‚€ nâ‚ nâ‚€' nâ‚' : â„¤) (hâ‚€ : nâ‚€ + y = nâ‚€') (hâ‚ : nâ‚ + y = nâ‚') :
    ((shiftFunctorâ‚‚ C y).obj K).Dâ‚ (up â„¤) nâ‚€ nâ‚ â‰« (K.totalShiftâ‚‚XIso y nâ‚ nâ‚' hâ‚).hom =
      y.negOnePow â€¢ ((K.totalShiftâ‚‚XIso y nâ‚€ nâ‚€' hâ‚€).hom â‰« K.Dâ‚ (up â„¤) nâ‚€' nâ‚') ",":= by
  by_cases h : (up â„¤).Rel nâ‚€ nâ‚
  Â· apply total.hom_ext
    intro p q hpq
    dsimp at h hpq
    dsimp [totalShiftâ‚‚XIso]
    rw [Î¹_Dâ‚_assoc, Linear.comp_units_smul, Î¹_totalDesc_assoc, Linear.units_smul_comp,
      Î¹_Dâ‚, smul_smul, ((shiftFunctorâ‚‚ C y).obj K).dâ‚_eq _ rfl _ _ (by dsimp; omega),
      K.dâ‚_eq _ rfl _ _ (by dsimp; omega)]
    dsimp
    rw [one_smul, one_smul, assoc, Î¹_totalDesc, Linear.comp_units_smul, â† Int.negOnePow_add]
    congr 2
    linarith
  Â· rw [Dâ‚_shape _ _ _ _ h, zero_comp, Dâ‚_shape, comp_zero, smul_zero]
    intro h'
    apply h
    dsimp at h' âŠ¢
    omega","dsimp [totalShiftâ‚‚XIso, totalShiftâ‚‚XIso]"
Mathlib/Algebra/Algebra/Unitization.lean,Unitization.starAlgHom_ext,starAlgHom_ext,01d739c14a27d96463129c57bbb1982309f33ea6,":=
  Unitization.algHom_ext'' <| FunLike.congr_fun h",error:  unknown constant 'FunLike.congr_fun',"theorem starAlgHom_ext {Ï† Ïˆ : Unitization R A â†’â‹†â‚[R] C}
    (h : (Ï† : Unitization R A â†’â‹†â‚™â‚[R] C).comp (Unitization.inrNonUnitalStarAlgHom R A) =
      (Ïˆ : Unitization R A â†’â‹†â‚™â‚[R] C).comp (Unitization.inrNonUnitalStarAlgHom R A)) :
    Ï† = Ïˆ ",":=
  Unitization.algHom_ext'' <| DFunLike.congr_fun h",simp only [Unitization.comp_inrNonUnitalStarAlgHom_ext]
Mathlib/MeasureTheory/Measure/Tilted.lean,MeasureTheory.tilted_apply_eq_ofReal_integral',tilted_apply_eq_ofReal_integral',63aaa8cc21050b7a5cb193c6764569918728723b,":= by
  by_cases hf : Integrable (fun x â†¦ exp (f x)) Î¼
  Â· rw [tilted_apply' _ _ hs, â† ofReal_integral_eq_lintegral_ofReal]
    Â· exact hf.integrableOn.div_const _
    Â· exact ae_of_all _
        (fun _ â†¦ div_nonneg (exp_pos _).le (integral_nonneg (fun _ â†¦ (exp_pos _).le)))
  Â· simp only [hf, not_false_eq_true, tilted_of_not_integrable, Measure.zero_toOuterMeasure,
      OuterMeasure.coe_zero, Pi.zero_apply, integral_undef hf, div_zero, integral_zero,
      ENNReal.ofReal_zero]","error:  unsolved goals
case neg
Î± : Type u_1
mÎ± : MeasurableSpace Î±
Î¼ : Measure Î±
fâœ : Î± â†’ â„
s : Set Î±
f : Î± â†’ â„
hs : MeasurableSet s
hf : Â¬Integrable (fun x â†¦ rexp (f x)) Î¼
âŠ¢ 0 s = 0","lemma tilted_apply_eq_ofReal_integral' {s : Set Î±} (f : Î± â†’ â„) (hs : MeasurableSet s) :
    Î¼.tilted f s = ENNReal.ofReal (âˆ« a in s, exp (f a) / âˆ« x, exp (f x) âˆ‚Î¼ âˆ‚Î¼) ",":= by
  by_cases hf : Integrable (fun x â†¦ exp (f x)) Î¼
  Â· rw [tilted_apply' _ _ hs, â† ofReal_integral_eq_lintegral_ofReal]
    Â· exact hf.integrableOn.div_const _
    Â· exact ae_of_all _ (fun _ â†¦ by positivity)
  Â· simp only [hf, not_false_eq_true, tilted_of_not_integrable, Measure.coe_zero,
      Pi.zero_apply, integral_undef hf, div_zero, integral_zero, ENNReal.ofReal_zero]",rw [tilted_apply_eq_ofReal_integral']
Mathlib/MeasureTheory/Constructions/Pi.lean,generateFrom_pi_eq,generateFrom_pi_eq,961db629df93e5dbd02440deee4c37efcf2faa85,":= by
  cases nonempty_encodable Î¹
  apply le_antisymm
  Â· refine' iSup_le _; intro i; rw [comap_generateFrom]
    apply generateFrom_le; rintro _ âŸ¨s, hs, rflâŸ©; dsimp
    choose t h1t h2t using hC
    simp_rw [eval_preimage, â† h2t]
    rw [â† @iUnion_const _ â„• _ s]
    have : Set.pi univ (update (fun i' : Î¹ => iUnion (t i')) i (â‹ƒ _ : â„•, s)) =
        Set.pi univ fun k => â‹ƒ j : â„•,
        @update Î¹ (fun i' => Set (Î± i')) _ (fun i' => t i' j) i s k := by
      ext; simp_rw [mem_univ_pi]; apply forall_congr'; intro i'
      by_cases h : i' = i
      Â· subst h; simp
      Â· rw [â† Ne.eq_def] at h; simp [h]
    rw [this, â† iUnion_univ_pi]
    apply MeasurableSet.iUnion
    intro n; apply measurableSet_generateFrom
    apply mem_image_of_mem; intro j _; dsimp only
    by_cases h : j = i; subst h; rwa [update_same]; rw [update_noteq h]; apply h1t
  Â· apply generateFrom_le; rintro _ âŸ¨s, hs, rflâŸ©
    rw [univ_pi_eq_iInter]; apply MeasurableSet.iInter; intro i
    apply @measurable_pi_apply _ _ (fun i => generateFrom (C i))
    exact measurableSet_generateFrom (hs i (mem_univ i))",error:  dsimp made no progress,"theorem generateFrom_pi_eq {C : âˆ€ i, Set (Set (Î± i))} (hC : âˆ€ i, IsCountablySpanning (C i)) :
    (@MeasurableSpace.pi _ _ fun i => generateFrom (C i)) =
    generateFrom (pi univ '' pi univ C) ",":= by
  cases nonempty_encodable Î¹
  apply le_antisymm
  Â· refine iSup_le ?_; intro i; rw [comap_generateFrom]
    apply generateFrom_le; rintro _ âŸ¨s, hs, rflâŸ©
    choose t h1t h2t using hC
    simp_rw [eval_preimage, â† h2t]
    rw [â† @iUnion_const _ â„• _ s]
    have : Set.pi univ (update (fun i' : Î¹ => iUnion (t i')) i (â‹ƒ _ : â„•, s)) =
        Set.pi univ fun k => â‹ƒ j : â„•,
        @update Î¹ (fun i' => Set (Î± i')) _ (fun i' => t i' j) i s k := by
      ext; simp_rw [mem_univ_pi]; apply forall_congr'; intro i'
      by_cases h : i' = i
      Â· subst h; simp
      Â· rw [â† Ne] at h; simp [h]
    rw [this, â† iUnion_univ_pi]
    apply MeasurableSet.iUnion
    intro n; apply measurableSet_generateFrom
    apply mem_image_of_mem; intro j _; dsimp only
    by_cases h : j = i
    Â· subst h; rwa [update_same]
    Â· rw [update_noteq h]; apply h1t
  Â· apply generateFrom_le; rintro _ âŸ¨s, hs, rflâŸ©
    rw [univ_pi_eq_iInter]; apply MeasurableSet.iInter; intro i
    apply @measurable_pi_apply _ _ (fun i => generateFrom (C i))
    exact measurableSet_generateFrom (hs i (mem_univ i))",apply generateFrom_eq_generateFrom_image generateFrom_pi_eq
Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean,AffineMap.coe_mk,coe_mk,161a7501773058c7d39559d99d747edbacc56fbd,":=
  by simp only []",error:  simp made no progress,theorem coe_mk (f : P1 â†’ P2) (linear add) : ((mk f linear add : P1 â†’áµƒ[k] P2) : P1 â†’ P2) = f ,":=
  rfl","simp [linear, linear, linear, linear, linear, linear, linear]"
Mathlib/Analysis/LocallyConvex/Bounded.lean,Bornology.IsVonNBounded.image,IsVonNBounded.image,f604c54a405502d347263e43f1ec5093742cccfa,":= by
  let Ïƒ' := RingEquiv.ofBijective Ïƒ âŸ¨Ïƒ.injective, Ïƒ.surjectiveâŸ©
  have Ïƒ_iso : Isometry Ïƒ := AddMonoidHomClass.isometry_of_norm Ïƒ fun x => RingHomIsometric.is_iso
  have Ïƒ'_symm_iso : Isometry Ïƒ'.symm := Ïƒ_iso.right_inv Ïƒ'.right_inv
  have f_tendsto_zero := f.continuous.tendsto 0
  rw [map_zero] at f_tendsto_zero
  intro V hV
  rcases hs (f_tendsto_zero hV) with âŸ¨r, hrpos, hrâŸ©
  refine' âŸ¨r, hrpos, fun a ha => _âŸ©
  rw [â† Ïƒ'.apply_symm_apply a]
  have hanz : a â‰  0 := norm_pos_iff.mp (hrpos.trans_le ha)
  have : Ïƒ'.symm a â‰  0 := (map_ne_zero Ïƒ'.symm.toRingHom).mpr hanz
  change _ âŠ† Ïƒ _ â€¢ _
  rw [Set.image_subset_iff, preimage_smul_setâ‚›â‚— _ _ _ f this.isUnit]
  refine' hr (Ïƒ'.symm a) _
  rwa [Ïƒ'_symm_iso.norm_map_of_map_zero (map_zero _)]",error:  rcases tactic failed: xâœ : (cobounded ğ•œâ‚).1 {x | (fun a â†¦ s âŠ† a â€¢ â‡‘f â»Â¹' V) x} is not an inductive datatype,"theorem IsVonNBounded.image {Ïƒ : ğ•œâ‚ â†’+* ğ•œâ‚‚} [RingHomSurjective Ïƒ] [RingHomIsometric Ïƒ] {s : Set E}
    (hs : IsVonNBounded ğ•œâ‚ s) (f : E â†’SL[Ïƒ] F) : IsVonNBounded ğ•œâ‚‚ (f '' s) ",":= by
  have Ïƒ_iso : Isometry Ïƒ := AddMonoidHomClass.isometry_of_norm Ïƒ fun x => RingHomIsometric.is_iso
  have : map Ïƒ (ğ“ 0) = ğ“ 0 := by
    rw [Ïƒ_iso.embedding.map_nhds_eq, Ïƒ.surjective.range_eq, nhdsWithin_univ, map_zero]
  have hfâ‚€ : Tendsto f (ğ“ 0) (ğ“ 0) := f.continuous.tendsto' 0 0 (map_zero f)
  simp only [isVonNBounded_iff_tendsto_smallSets_nhds, â† this, tendsto_map'_iff] at hs âŠ¢
  simpa only [comp_def, image_smul_setâ‚›â‚— _ _ Ïƒ f] using hfâ‚€.image_smallSets.comp hs",have : IsVonNBounded ğ•œâ‚‚ (f '' s) := isVonNBounded_image _ _
Mathlib/Probability/Variance.lean,ProbabilityTheory.meas_ge_le_variance_div_sq,meas_ge_le_variance_div_sq,9ad07e7ddb192ef9ee24f6a4ed6bbb71d10b50b9,":= by
  rw [ENNReal.ofReal_div_of_pos (sq_pos_of_ne_zero _ hc.ne.symm), hX.ofReal_variance_eq]
  convert @meas_ge_le_evariance_div_sq _ _ _ hX.1 c.toNNReal (by simp [hc]) using 1
  Â· simp only [Real.coe_toNNReal', max_le_iff, abs_nonneg, and_true_iff]
  Â· rw [ENNReal.ofReal_pow hc.le]
    rfl","error:  function expected at
  sq_pos_of_ne_zero ?m.84973
term has type
  0 < ?m.84972 ^ 2","theorem meas_ge_le_variance_div_sq [@IsFiniteMeasure Î© _ â„™] {X : Î© â†’ â„} (hX : Memâ„’p X 2) {c : â„}
    (hc : 0 < c) : â„™ {Ï‰ | c â‰¤ |X Ï‰ - ğ”¼[X]|} â‰¤ ENNReal.ofReal (Var[X] / c ^ 2) ",":= by
  rw [ENNReal.ofReal_div_of_pos (sq_pos_of_ne_zero hc.ne.symm), hX.ofReal_variance_eq]
  convert @meas_ge_le_evariance_div_sq _ _ _ hX.1 c.toNNReal (by simp [hc]) using 1
  Â· simp only [Real.coe_toNNReal', max_le_iff, abs_nonneg, and_true_iff]
  Â· rw [ENNReal.ofReal_pow hc.le]
    rfl","rw [ENNReal.ofReal_div, ENNReal.ofReal_ofReal (Var[X] / c ^ 2),
  ENNReal.ofReal_ofReal (Var[X] / c ^ 2)]"
Mathlib/MeasureTheory/Constructions/Polish.lean,Measurable.measurableEmbedding,_root_.Measurable.measurableEmbedding,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":=
  { injective := f_inj
    measurable := f_meas
    measurableSet_image' := fun _u hu => hu.image_of_measurable_injOn f_meas (f_inj.injOn _) }","error:  application type mismatch
  MeasurableSet.image_of_measurable_injOn hu f_meas (Injective.injOn f_inj ?m.73937)
argument
  Injective.injOn f_inj ?m.73937
has type
  âˆ€ â¦ƒxâ‚‚ : Î³â¦„, xâ‚‚ âˆˆ ?m.73935 â†’ f ?m.73936 = f xâ‚‚ â†’ ?m.73936 = xâ‚‚ : Prop
but is expected to have type
  InjOn f _u : Prop","theorem _root_.Measurable.measurableEmbedding {f : Î³ â†’ Î±}
    [MeasurableSpace.CountablySeparated Î±]
    [MeasurableSpace Î³] [StandardBorelSpace Î³]
    (f_meas : Measurable f) (f_inj : Injective f) : MeasurableEmbedding f ",":=
  { injective := f_inj
    measurable := f_meas
    measurableSet_image' := fun _u hu => hu.image_of_measurable_injOn f_meas f_inj.injOn }",rw [MeasurableEmbedding.measurable_measurableEmbedding]
Mathlib/LinearAlgebra/Matrix/DotProduct.lean,Matrix.dotProduct_self_star_eq_zero,dotProduct_self_star_eq_zero,4b292e8968c43193b3dbd022dfbc7ddc03b3a7a8,":=
  (Finset.sum_eq_zero_iff_of_nonneg fun i _ => (@mul_star_self_nonneg _ _ _ _ (v i) : _)).trans <|
    by simp [Function.funext_iff, mul_eq_zero]","error:  application type mismatch
  @mul_star_self_nonneg ?m.27917 ?m.27918 ?m.27919 ?m.27920 (v i)
argument
  v i
has type
  R : Type u_4
but is expected to have type
  StarOrderedRing ?m.27917 : Prop",theorem dotProduct_self_star_eq_zero {v : n â†’ R} : dotProduct v (star v) = 0 â†” v = 0 ,":=
  (Finset.sum_eq_zero_iff_of_nonneg fun i _ => (mul_star_self_nonneg (r := v i) : _)).trans <|
    by simp [Function.funext_iff, mul_eq_zero]",simp [dotProduct_self_star_eq_zero]
Mathlib/SetTheory/Ordinal/Notation.lean,NONote.repr_mul,repr_mul,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,"  | 0, o, _, hâ‚‚ => by cases o <;> exact (zero_mul _).symm
  | oadd eâ‚ nâ‚ aâ‚, 0, _, _ => (mul_zero _).symm
  | oadd eâ‚ nâ‚ aâ‚, oadd eâ‚‚ nâ‚‚ aâ‚‚, hâ‚, hâ‚‚ => by
    have IH : repr (mul _ _) = _ := @repr_mul _ _ hâ‚ hâ‚‚.snd
    conv =>
      lhs
      simp [(Â· * Â·)]
    have ao : repr aâ‚ + Ï‰ ^ repr eâ‚ * (nâ‚ : â„•) = Ï‰ ^ repr eâ‚ * (nâ‚ : â„•) := by
      apply add_absorp hâ‚.snd'.repr_lt
      simpa using (Ordinal.mul_le_mul_iff_left <| opow_pos _ omega_pos).2 (natCast_le.2 nâ‚.2)
    by_cases e0 : eâ‚‚ = 0 <;> simp [e0, mul]
    Â· cases' Nat.exists_eq_succ_of_ne_zero nâ‚‚.ne_zero with x xe
      simp only [xe, hâ‚‚.zero_of_zero e0, repr, add_zero]
      rw [natCast_succ x, add_mul_succ _ ao, mul_assoc]
    Â· haveI := hâ‚.fst
      haveI := hâ‚‚.fst
      simp only [Mul.mul, mul, e0, ite_false, repr._eq_2, repr_add, opow_add, IH, repr, mul_add]
      rw [â† mul_assoc]
      congr 2
      have := mt repr_inj.1 e0
      rw [add_mul_limit ao (opow_isLimit_left omega_isLimit this), mul_assoc,
        mul_omega_dvd (natCast_pos.2 nâ‚.pos) (nat_lt_omega _)]
      simpa using opow_dvd_opow Ï‰ (one_le_iff_ne_zero.2 this)","error:  unknown constant 'ONote.repr._eq_2'
warning:  unused variable `R'`
note: this linter can be disabled with `set_option linter.unusedVariables false`","theorem repr_mul : âˆ€ (oâ‚ oâ‚‚) [NF oâ‚] [NF oâ‚‚], repr (oâ‚ * oâ‚‚) = repr oâ‚ * repr oâ‚‚
","  | 0, o, _, hâ‚‚ => by cases o <;> exact (zero_mul _).symm
  | oadd eâ‚ nâ‚ aâ‚, 0, _, _ => (mul_zero _).symm
  | oadd eâ‚ nâ‚ aâ‚, oadd eâ‚‚ nâ‚‚ aâ‚‚, hâ‚, hâ‚‚ => by
    have IH : repr (mul _ _) = _ := @repr_mul _ _ hâ‚ hâ‚‚.snd
    conv =>
      lhs
      simp [(Â· * Â·)]
    have ao : repr aâ‚ + Ï‰ ^ repr eâ‚ * (nâ‚ : â„•) = Ï‰ ^ repr eâ‚ * (nâ‚ : â„•) := by
      apply add_absorp hâ‚.snd'.repr_lt
      simpa using (Ordinal.mul_le_mul_iff_left <| opow_pos _ omega_pos).2 (natCast_le.2 nâ‚.2)
    by_cases e0 : eâ‚‚ = 0 <;> simp [e0, mul]
    Â· cases' Nat.exists_eq_succ_of_ne_zero nâ‚‚.ne_zero with x xe
      simp only [xe, hâ‚‚.zero_of_zero e0, repr, add_zero]
      rw [natCast_succ x, add_mul_succ _ ao, mul_assoc]
    Â· haveI := hâ‚.fst
      haveI := hâ‚‚.fst
      simp only [Mul.mul, mul, e0, ite_false, repr.eq_2, repr_add, opow_add, IH, repr, mul_add]
      rw [â† mul_assoc]
      congr 2
      have := mt repr_inj.1 e0
      rw [add_mul_limit ao (opow_isLimit_left omega_isLimit this), mul_assoc,
        mul_omega_dvd (natCast_pos.2 nâ‚.pos) (nat_lt_omega _)]
      simpa using opow_dvd_opow Ï‰ (one_le_iff_ne_zero.2 this)",induction' repr_mul repr_mul with oâ‚ oâ‚‚
Mathlib/Topology/Separation.lean,minimal_nonempty_open_subsingleton,minimal_nonempty_open_subsingleton,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  clear Y 
  refine' fun x hx y hy => of_not_not fun hxy => _
  rcases exists_isOpen_xor'_mem hxy with âŸ¨U, hUo, hUâŸ©
  wlog h : x âˆˆ U âˆ§ y âˆ‰ U
  Â· exact this hs hmin y hy x hx (Ne.symm hxy) U hUo hU.symm (hU.resolve_left h)
  cases' h with hxU hyU
  have : s âˆ© U = s := hmin (s âˆ© U) (inter_subset_left _ _) âŸ¨x, hx, hxUâŸ© (hs.inter hUo)
  exact hyU (this.symm.subset hy).2","error:  function expected at
  inter_subset_left ?m.38981
term has type
  ?m.38980 âˆˆ ?m.38978","theorem minimal_nonempty_open_subsingleton [T0Space X] {s : Set X} (hs : IsOpen s)
    (hmin : âˆ€ t, t âŠ† s â†’ t.Nonempty â†’ IsOpen t â†’ t = s) : s.Subsingleton ",":= by
  clear Y 
  refine fun x hx y hy => of_not_not fun hxy => ?_
  rcases exists_isOpen_xor'_mem hxy with âŸ¨U, hUo, hUâŸ©
  wlog h : x âˆˆ U âˆ§ y âˆ‰ U
  Â· exact this hs hmin y hy x hx (Ne.symm hxy) U hUo hU.symm (hU.resolve_left h)
  cases' h with hxU hyU
  have : s âˆ© U = s := hmin (s âˆ© U) inter_subset_left âŸ¨x, hx, hxUâŸ© (hs.inter hUo)
  exact hyU (this.symm.subset hy).2",rw [subsingleton_iff_isOpen_subsingleton]
Mathlib/Analysis/InnerProductSpace/Projection.lean,OrthogonalFamily.projection_directSum_coeAddHom,OrthogonalFamily.projection_directSum_coeAddHom,445b8b76b8b15da90721b5973241d3c69fb5bcfb,":= by
  induction' x using DirectSum.induction_on with j x x y hx hy
  Â· simp
  Â· simp_rw [DirectSum.coeAddMonoidHom_of, DirectSum.of]
    rw [Dfinsupp.singleAddHom_apply]
    obtain rfl | hij := Decidable.eq_or_ne i j
    Â· rw [orthogonalProjection_mem_subspace_eq_self, Dfinsupp.single_eq_same]
    Â· rw [orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero,
        Dfinsupp.single_eq_of_ne hij.symm]
      exact hV.isOrtho hij.symm x.prop
  Â· simp_rw [map_add, Dfinsupp.add_apply]
    exact congr_argâ‚‚ (Â· + Â·) hx hy","error:  unknown identifier 'Dfinsupp.singleAddHom_apply'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.979189
case H_basic
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâ¶ : _root_.RCLike ğ•œ
instâœâµ : NormedAddCommGroup E
instâœâ´ : NormedAddCommGroup F
instâœÂ³ : InnerProductSpace ğ•œ E
instâœÂ² : InnerProductSpace â„ F
K : Submodule ğ•œ E
Î¹ : Type u_4
instâœÂ¹ : DecidableEq Î¹
V : Î¹ â†’ Submodule ğ•œ E
hV : OrthogonalFamily ğ•œ (fun i â†¦ â†¥(V i)) fun i â†¦ (V i).subtypeâ‚—áµ¢
i : Î¹
instâœ : CompleteSpace â†¥(V i)
j : Î¹
x : â†¥(V j)
âŠ¢ (orthogonalProjection (V i)) â†‘x = ((DFinsupp.singleAddHom (fun i â†¦ â†¥(V i)) j) x) i
error:  unknown identifier 'Dfinsupp.add_apply'
error:  simp made no progress","theorem OrthogonalFamily.projection_directSum_coeAddHom [DecidableEq Î¹] {V : Î¹ â†’ Submodule ğ•œ E}
    (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) (x : â¨ i, V i) (i : Î¹)
    [CompleteSpace (V i)] :
    orthogonalProjection (V i) (DirectSum.coeAddMonoidHom V x) = x i ",":= by
  induction' x using DirectSum.induction_on with j x x y hx hy
  Â· simp
  Â· simp_rw [DirectSum.coeAddMonoidHom_of, DirectSum.of]
    erw [DFinsupp.singleAddHom_apply]
    obtain rfl | hij := Decidable.eq_or_ne i j
    Â· rw [orthogonalProjection_mem_subspace_eq_self, DFinsupp.single_eq_same]
    Â· rw [orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero,
        DFinsupp.single_eq_of_ne hij.symm]
      exact hV.isOrtho hij.symm x.prop
  Â· simp_rw [map_add]
    exact congr_argâ‚‚ (Â· + Â·) hx hy",simp only [orthogonalProjection]
Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean,CategoryTheory.comp_rightAdjointMate,comp_rightAdjointMate,ad0fb7237dfe64692bfd01c1bfd64cdf12e0ccd7,":= by
  rw [rightAdjointMate_comp]
  simp only [rightAdjointMate, comp_whiskerRight]
  simp only [â† Category.assoc]; congr 3; simp only [Category.assoc]
  simp only [â† MonoidalCategory.whiskerLeft_comp]; congr 2
  symm
  calc
    _ = ğŸ™ _ âŠ—â‰« (Î·_ Y Yá˜ â–· ğŸ™_ C â‰« (Y âŠ— Yá˜) â— Î·_ X Xá˜) âŠ—â‰« Y â— Yá˜ â— f â–· Xá˜ âŠ—â‰«
        Y â— Îµ_ Y Yá˜ â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by
      rw [tensorHom_def']; coherence
    _ = Î·_ X Xá˜ âŠ—â‰« (Î·_ Y Yá˜ â–· (X âŠ— Xá˜) â‰« (Y âŠ— Yá˜) â— f â–· Xá˜) âŠ—â‰«
        Y â— Îµ_ Y Yá˜ â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by
      rw [â† whisker_exchange]; coherence
    _ = Î·_ X Xá˜ âŠ—â‰« f â–· Xá˜ âŠ—â‰« (Î·_ Y Yá˜ â–· Y âŠ—â‰« Y â— Îµ_ Y Yá˜) â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by
      rw [â† whisker_exchange]; coherence
    _ = Î·_ X Xá˜ â‰« f â–· Xá˜ â‰« g â–· Xá˜ := by
      rw [evaluation_coevaluation''']; coherence","warning:  @coevaluation does not have a doc string
warning:  @evaluation does not have a doc string
warning:  @leftDual does not have a doc string
warning:  @rightDual does not have a doc string
warning:  @rightAdjointMate does not have a doc string
warning:  @leftAdjointMate does not have a doc string
error:  unknown identifier 'evaluation_coevaluation''''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.342916
C : Type uâ‚
instâœâ´ : Category.{vâ‚, uâ‚} C
instâœÂ³ : MonoidalCategory C
X Y Z : C
instâœÂ² : HasRightDual X
instâœÂ¹ : HasRightDual Y
instâœ : HasRightDual Z
f : X âŸ¶ Y
g : Y âŸ¶ Z
âŠ¢ Î·_ X Xá˜ âŠ—â‰« f â–· Xá˜ âŠ—â‰« (Î·_ Y Yá˜ â–· Y âŠ—â‰« Y â— Îµ_ Y Yá˜) â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ (Z âŠ— Xá˜) = Î·_ X Xá˜ â‰« f â–· Xá˜ â‰« g â–· Xá˜","theorem comp_rightAdjointMate {X Y Z : C} [HasRightDual X] [HasRightDual Y] [HasRightDual Z]
    {f : X âŸ¶ Y} {g : Y âŸ¶ Z} : (f â‰« g)á˜ = gá˜ â‰« fá˜ ",":= by
  rw [rightAdjointMate_comp]
  simp only [rightAdjointMate, comp_whiskerRight]
  simp only [â† Category.assoc]; congr 3; simp only [Category.assoc]
  simp only [â† MonoidalCategory.whiskerLeft_comp]; congr 2
  symm
  calc
    _ = ğŸ™ _ âŠ—â‰« (Î·_ Y Yá˜ â–· ğŸ™_ C â‰« (Y âŠ— Yá˜) â— Î·_ X Xá˜) âŠ—â‰« Y â— Yá˜ â— f â–· Xá˜ âŠ—â‰«
        Y â— Îµ_ Y Yá˜ â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by
      rw [tensorHom_def']; coherence
    _ = Î·_ X Xá˜ âŠ—â‰« (Î·_ Y Yá˜ â–· (X âŠ— Xá˜) â‰« (Y âŠ— Yá˜) â— f â–· Xá˜) âŠ—â‰«
        Y â— Îµ_ Y Yá˜ â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by
      rw [â† whisker_exchange]; coherence
    _ = Î·_ X Xá˜ âŠ—â‰« f â–· Xá˜ âŠ—â‰« (Î·_ Y Yá˜ â–· Y âŠ—â‰« Y â— Îµ_ Y Yá˜) â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by
      rw [â† whisker_exchange]; coherence
    _ = Î·_ X Xá˜ â‰« f â–· Xá˜ â‰« g â–· Xá˜ := by
      rw [evaluation_coevaluation'']; coherence","simp [rightAdjointMate, rightAdjointMate]"
Mathlib/LinearAlgebra/BilinearForm/Properties.lean,LinearMap.BilinForm.dualBasis_flip_dualBasis,dualBasis_flip_dualBasis,31c261277bc3e8a52b74d248691ef6b40c75b452,":=
  LinearMap.BilinForm.dualBasis_flip_dualBasis (BilinForm.toLin B) hB b","warning:  `LinearMap.BilinForm.toLin` has been deprecated
error:  fail to show termination for
  LinearMap.BilinForm.dualBasis_flip_dualBasis
with errors
structural recursion cannot be used:

argument #1 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #2 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #3 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #4 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #5 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #6 cannot be used for structural recursion
  its type does not have a recursor

argument #7 cannot be used for structural recursion
  its type is not an inductive

argument #8 cannot be used for structural recursion
  its type is not an inductive

argument #9 cannot be used for structural recursion
  its type does not have a recursor

argument #10 cannot be used for structural recursion
  its type is not an inductive

argument #11 cannot be used for structural recursion
  its type does not have a recursor

argument #12 cannot be used for structural recursion
  its type does not have a recursor

Could not find a decreasing measure.
The arguments relate at each recursive call as follows:
(<, â‰¤, =: relation proved, ? all proofs failed, _: no proof attempted)
           
1) 365:2-71
Please use `termination_by` to specify a decreasing measure.","lemma dualBasis_flip_dualBasis (B : BilinForm K V) (hB : B.Nondegenerate) {Î¹}
    [Finite Î¹] [DecidableEq Î¹] [FiniteDimensional K V] (b : Basis Î¹ K V) :
    B.flip.dualBasis hB.flip (B.dualBasis hB b) = b ",":=
  dualBasis_dualBasis_flip _ hB.flip b","rw [â† dualBasis_flip_dualBasis_flip, dualBasis_flip_dualBasis]"
Mathlib/RingTheory/PowerSeries/Order.lean,PowerSeries.le_order,le_order,c959b2f950b9c44268e36bcedef976356855e6fb,":= by
  induction n
  Â· show _ â‰¤ _
    rw [top_le_iff, order_eq_top]
    ext i
    exact h _ (PartENat.natCast_lt_top i)
  Â· apply nat_le_order
    simpa only [PartENat.coe_lt_coe] using h","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  âŠ¤ â‰¤ ?m.17936
case mk
R : Type u_1
instâœ : Semiring R
Ï†âœ Ï† : RâŸ¦XâŸ§
Domâœ : Prop
getâœ : Domâœ â†’ â„•
h : âˆ€ (i : â„•), â†‘i < { Dom := Domâœ, get := getâœ } â†’ (coeff R i) Ï† = 0
âŠ¢ { Dom := Domâœ, get := getâœ } â‰¤ Ï†.order
error:  no goals to be solved","theorem le_order (Ï† : RâŸ¦XâŸ§) (n : PartENat) (h : âˆ€ i : â„•, â†‘i < n â†’ coeff R i Ï† = 0) :
    n â‰¤ order Ï† ",":= by
  induction n using PartENat.casesOn
  Â· show _ â‰¤ _
    rw [top_le_iff, order_eq_top]
    ext i
    exact h _ (PartENat.natCast_lt_top i)
  Â· apply nat_le_order
    simpa only [PartENat.coe_lt_coe] using h",simp only [le_order_iff]
Mathlib/Data/Nat/Totient.lean,ZMod.card_units_eq_totient,_root_.ZMod.card_units_eq_totient,40b58304ad9cb6913d2d4e97172b2c306fdb61f2,":=
  calc
    Fintype.card (ZMod n)Ë£ = Fintype.card { x : ZMod n // x.val.coprime n } :=
      Fintype.card_congr ZMod.unitsEquivCoprime
    _ = Ï† n := by
      obtain âŸ¨m, rflâŸ© : âˆƒ m, n = m + 1 := exists_eq_succ_of_ne_zero NeZero.out
      simp only [totient, Finset.card_eq_sum_ones, Fintype.card_subtype, Finset.sum_filter, â†
        Fin.sum_univ_eq_sum_range, @Nat.coprime_comm (m + 1)]
      rfl","warning:  totient does not have a doc string
error:  invalid field 'coprime', the environment does not contain 'Nat.coprime'
  x.val
has type
  â„•
error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case intro
m : â„•
instâœÂ¹ : NeZero (m + 1)
instâœ : Fintype (ZMod (m + 1))Ë£
âŠ¢ sorryAx â„• true = âˆ‘ i : Fin (m + 1), if (â†‘i).Coprime (m + 1) then 1 else 0","theorem _root_.ZMod.card_units_eq_totient (n : â„•) [NeZero n] [Fintype (ZMod n)Ë£] :
    Fintype.card (ZMod n)Ë£ = Ï† n ",":=
  calc
    Fintype.card (ZMod n)Ë£ = Fintype.card { x : ZMod n // x.val.Coprime n } :=
      Fintype.card_congr ZMod.unitsEquivCoprime
    _ = Ï† n := by
      obtain âŸ¨m, rflâŸ© : âˆƒ m, n = m + 1 := exists_eq_succ_of_ne_zero NeZero.out
      simp only [totient, Finset.card_eq_sum_ones, Fintype.card_subtype, Finset.sum_filter, â†
        Fin.sum_univ_eq_sum_range, @Nat.coprime_comm (m + 1)]
      rfl","rw [ZMod.card_units_eq_totient, ZMod.card_units_eq_totient]"
Mathlib/Algebra/Lie/Weights/Killing.lean,LieAlgebra.killingForm_apply_eq_zero_of_mem_rootSpace_of_add_ne_zero,killingForm_apply_eq_zero_of_mem_rootSpace_of_add_ne_zero,9d3887769246754772c178dd6c594378dce58448,":= by
  let Ïƒ : (H â†’ K) â†’ (H â†’ K) := fun Î³ â†¦ Î± + (Î² + Î³)
  have hÏƒ : âˆ€ Î³, Ïƒ Î³ â‰  Î³ := fun Î³ â†¦ by simpa only [Ïƒ, â† add_assoc] using add_left_ne_self.mpr hÎ±Î²
  let f : Module.End K L := (ad K L x) âˆ˜â‚— (ad K L y)
  have hf : âˆ€ Î³, MapsTo f (rootSpace H Î³) (rootSpace H (Ïƒ Î³)) := fun Î³ â†¦
    (mapsTo_toEndomorphism_weightSpace_add_of_mem_rootSpace K L H L Î± (Î² + Î³) hx).comp <|
      mapsTo_toEndomorphism_weightSpace_add_of_mem_rootSpace K L H L Î² Î³ hy
  classical
  have hds := DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top
    (LieSubmodule.independent_iff_coe_toSubmodule.mp <| independent_weightSpace K H L)
    (LieSubmodule.iSup_eq_top_iff_coe_toSubmodule.mp <| iSup_weightSpace_eq_top K H L)
  exact LinearMap.trace_eq_zero_of_mapsTo_ne hds Ïƒ hÏƒ hf",error:  unknown identifier 'mapsTo_toEndomorphism_weightSpace_add_of_mem_rootSpace',"lemma killingForm_apply_eq_zero_of_mem_rootSpace_of_add_ne_zero {Î± Î² : H â†’ K} {x y : L}
    (hx : x âˆˆ rootSpace H Î±) (hy : y âˆˆ rootSpace H Î²) (hÎ±Î² : Î± + Î² â‰  0) :
    killingForm K L x y = 0 ",":= by
  let Ïƒ : (H â†’ K) â†’ (H â†’ K) := fun Î³ â†¦ Î± + (Î² + Î³)
  have hÏƒ : âˆ€ Î³, Ïƒ Î³ â‰  Î³ := fun Î³ â†¦ by simpa only [Ïƒ, â† add_assoc] using add_left_ne_self.mpr hÎ±Î²
  let f : Module.End K L := (ad K L x) âˆ˜â‚— (ad K L y)
  have hf : âˆ€ Î³, MapsTo f (rootSpace H Î³) (rootSpace H (Ïƒ Î³)) := fun Î³ â†¦
    (mapsTo_toEnd_weightSpace_add_of_mem_rootSpace K L H L Î± (Î² + Î³) hx).comp <|
      mapsTo_toEnd_weightSpace_add_of_mem_rootSpace K L H L Î² Î³ hy
  classical
  have hds := DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top
    (LieSubmodule.independent_iff_coe_toSubmodule.mp <| independent_weightSpace K H L)
    (LieSubmodule.iSup_eq_top_iff_coe_toSubmodule.mp <| iSup_weightSpace_eq_top K H L)
  exact LinearMap.trace_eq_zero_of_mapsTo_ne hds Ïƒ hÏƒ hf",rw [mem_rootSpace_of_mem_rootSpace_of_mem_rootSpace_of_mem_rootSpace_of_mem_rootSpace_of_mem_rootSpace_of_mem_rootSpace_of_mem_rootSpace_of_mem_rootSpace_of_mem_rootSpace_of_mem_rootSpace]
Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean,CategoryTheory.Equalizer.FirstObj.ext,FirstObj.ext,f76dc92a63457a8b36463cee1fe33a048c0ba0ce,":= by
  apply Limits.Types.limit_ext
  rintro âŸ¨iâŸ©
  exact h i","error:  application type mismatch
  h i
argument
  i
has type
  (Y : C) Ã— { f // R f } : Type (max u v)
but is expected to have type
  C : Type u","lemma FirstObj.ext (zâ‚ zâ‚‚ : FirstObj P R) (h : âˆ€ (Y : C) (f : Y âŸ¶ X)
    (hf : R f), (Pi.Ï€ _ âŸ¨Y, f, hfâŸ© : FirstObj P R âŸ¶ _) zâ‚ =
      (Pi.Ï€ _ âŸ¨Y, f, hfâŸ© : FirstObj P R âŸ¶ _) zâ‚‚) : zâ‚ = zâ‚‚ ",":= by
  apply Limits.Types.limit_ext
  rintro âŸ¨âŸ¨Y, f, hfâŸ©âŸ©
  exact h Y f hf",apply FirstObj.ext_ext
Mathlib/NumberTheory/Padics/PadicNorm.lean,padicNorm.nat_eq_one_iff,nat_eq_one_iff,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  rw [â† Int.coe_nat_dvd, â† int_eq_one_iff, Int.cast_ofNat]","warning:  `Int.coe_nat_dvd` has been deprecated, use `Int.natCast_dvd_natCast` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â†‘(OfNat.ofNat ?n)
p : â„•
hp : Fact (Nat.Prime p)
m : â„•
âŠ¢ padicNorm p â†‘m = 1 â†” padicNorm p â†‘â†‘m = 1",theorem nat_eq_one_iff (m : â„•) : padicNorm p m = 1 â†” Â¬p âˆ£ m ,":= by
  rw [â† Int.natCast_dvd_natCast, â† int_eq_one_iff, Int.cast_natCast]","rw [padicNorm_eq_one_iff, nat_eq_one_iff]"
Mathlib/NumberTheory/EllipticDivisibilitySequence.lean,normEDS_ofNat,normEDS_ofNat,eda04d24f539d275bf9161920e57d3d1d3781080,":= by
  rw [normEDS, preNormEDS_ofNat, Int.natAbs_ofNat]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (â†‘?n).natAbs
R : Type u
S : Type v
instâœÂ¹ : CommRing R
instâœ : CommRing S
W : â„¤ â†’ R
f : R â†’+* S
b c d : R
n : â„•
âŠ¢ (preNormEDS' (b ^ 4) c d n * if Even â†‘n then b else 1) = preNormEDS' (b ^ 4) c d n * if Even n then b else 1","lemma normEDS_ofNat (n : â„•) :
    normEDS b c d n = preNormEDS' (b ^ 4) c d n * if Even n then b else 1 ",":= by
  simp only [normEDS, preNormEDS_ofNat, Int.even_coe_nat]",split_ifs with h
Mathlib/RingTheory/MvPolynomial/Homogeneous.lean,MvPolynomial.IsHomogeneous.totalDegree,totalDegree,0491ec2f489bdface91d19cc62fcde7df6b31481,":= by
  rw [â† weightedTotalDegree_one, weightedTotalDegree_eq_zero_iff _ p]
  exact nonTorsionWeight_of (Function.const Ïƒ one_ne_zero)","error:  typeclass instance problem is stuck, it is often due to metavariables
  NoZeroSMulDivisors â„• ?m.31387
warning:  declaration uses 'sorry'","theorem totalDegree_zero_iff_isHomogeneous {p : MvPolynomial Ïƒ R} :
    p.totalDegree = 0 â†” IsHomogeneous p 0 ",":= by
  rw [â† weightedTotalDegree_one,
    â† isWeightedHomogeneous_zero_iff_weightedTotalDegree_eq_zero, IsHomogeneous]","simp [IsHomogeneous, IsHomogeneous]"
Mathlib/Probability/Cdf.lean,ProbabilityTheory.cdf_le_one,cdf_le_one,c4988d10a696972769fd676cb9977e896bf0a01b,:= condCdf_le_one _ _ _,error:  unknown identifier 'condCdf_le_one',lemma cdf_le_one (x : â„) : cdf Î¼ x â‰¤ 1 ,:= condCDF_le_one _ _ _,rw [cdf_le_one x]
Mathlib/MeasureTheory/Integral/FundThmCalculus.lean,intervalIntegral.integrableOn_deriv_right_of_nonneg,integrableOn_deriv_right_of_nonneg,878d95c40e4a93f407c45a5bfa059a77eaf8bde9,":= by
  by_cases hab : a < b; swap
  Â· simp [Ioc_eq_empty hab]
  rw [integrableOn_Ioc_iff_integrableOn_Ioo]
  have meas_g' : AEMeasurable g' (volume.restrict (Ioo a b)) := by
    apply (aemeasurable_derivWithin_Ioi g _).congr
    refine' (ae_restrict_mem measurableSet_Ioo).mono fun x hx => _
    exact (hderiv x hx).derivWithin (uniqueDiffWithinAt_Ioi _)
  suffices H : (âˆ«â» x in Ioo a b, â€–g' xâ€–â‚Š) â‰¤ ENNReal.ofReal (g b - g a)
  exact âŸ¨meas_g'.aestronglyMeasurable, H.trans_lt ENNReal.ofReal_lt_topâŸ©
  by_contra' H
  obtain âŸ¨f, fle, fint, hfâŸ© :
    âˆƒ f : SimpleFunc â„ â„â‰¥0,
      (âˆ€ x, f x â‰¤ â€–g' xâ€–â‚Š) âˆ§
        (âˆ«â» x : â„ in Ioo a b, f x) < âˆ âˆ§ ENNReal.ofReal (g b - g a) < âˆ«â» x : â„ in Ioo a b, f x :=
    exists_lt_lintegral_simpleFunc_of_lt_lintegral H
  let F : â„ â†’ â„ := (â†‘) âˆ˜ f
  have intF : IntegrableOn F (Ioo a b) := by
    refine' âŸ¨f.measurable.coe_nnreal_real.aestronglyMeasurable, _âŸ©
    simpa only [HasFiniteIntegral, comp_apply, NNReal.nnnorm_eq] using fint
  have A : (âˆ«â» x : â„ in Ioo a b, f x) = ENNReal.ofReal (âˆ« x in Ioo a b, F x) :=
    lintegral_coe_eq_integral _ intF
  rw [A] at hf
  have B : (âˆ« x : â„ in Ioo a b, F x) â‰¤ g b - g a := by
    rw [â† integral_Ioc_eq_integral_Ioo, â† intervalIntegral.integral_of_le hab.le]
    refine integral_le_sub_of_hasDeriv_right_of_le hab.le hcont hderiv ?_ fun x hx => ?_
    Â· rwa [integrableOn_Icc_iff_integrableOn_Ioo]
    Â· convert NNReal.coe_le_coe.2 (fle x)
      simp only [Real.norm_of_nonneg (g'pos x hx), coe_nnnorm]
  exact lt_irrefl _ (hf.trans_le (ENNReal.ofReal_le_ofReal B))",error:  unexpected identifier; expected 'by' or 'from',"theorem integrableOn_deriv_right_of_nonneg (hcont : ContinuousOn g (Icc a b))
    (hderiv : âˆ€ x âˆˆ Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (g'pos : âˆ€ x âˆˆ Ioo a b, 0 â‰¤ g' x) : IntegrableOn g' (Ioc a b) ",":= by
  by_cases hab : a < b; swap
  Â· simp [Ioc_eq_empty hab]
  rw [integrableOn_Ioc_iff_integrableOn_Ioo]
  have meas_g' : AEMeasurable g' (volume.restrict (Ioo a b)) := by
    apply (aemeasurable_derivWithin_Ioi g _).congr
    refine (ae_restrict_mem measurableSet_Ioo).mono fun x hx => ?_
    exact (hderiv x hx).derivWithin (uniqueDiffWithinAt_Ioi _)
  suffices H : (âˆ«â» x in Ioo a b, â€–g' xâ€–â‚Š) â‰¤ ENNReal.ofReal (g b - g a) from
    âŸ¨meas_g'.aestronglyMeasurable, H.trans_lt ENNReal.ofReal_lt_topâŸ©
  by_contra! H
  obtain âŸ¨f, fle, fint, hfâŸ© :
    âˆƒ f : SimpleFunc â„ â„â‰¥0,
      (âˆ€ x, f x â‰¤ â€–g' xâ€–â‚Š) âˆ§
        (âˆ«â» x : â„ in Ioo a b, f x) < âˆ âˆ§ ENNReal.ofReal (g b - g a) < âˆ«â» x : â„ in Ioo a b, f x :=
    exists_lt_lintegral_simpleFunc_of_lt_lintegral H
  let F : â„ â†’ â„ := (â†‘) âˆ˜ f
  have intF : IntegrableOn F (Ioo a b) := by
    refine âŸ¨f.measurable.coe_nnreal_real.aestronglyMeasurable, ?_âŸ©
    simpa only [F, HasFiniteIntegral, comp_apply, NNReal.nnnorm_eq] using fint
  have A : âˆ«â» x : â„ in Ioo a b, f x = ENNReal.ofReal (âˆ« x in Ioo a b, F x) :=
    lintegral_coe_eq_integral _ intF
  rw [A] at hf
  have B : (âˆ« x : â„ in Ioo a b, F x) â‰¤ g b - g a := by
    rw [â† integral_Ioc_eq_integral_Ioo, â† intervalIntegral.integral_of_le hab.le]
    refine integral_le_sub_of_hasDeriv_right_of_le hab.le hcont hderiv ?_ fun x hx => ?_
    Â· rwa [integrableOn_Icc_iff_integrableOn_Ioo]
    Â· convert NNReal.coe_le_coe.2 (fle x)
      simp only [Real.norm_of_nonneg (g'pos x hx), coe_nnnorm]
  exact lt_irrefl _ (hf.trans_le (ENNReal.ofReal_le_ofReal B))",have hcont : ContinuousOn g' (Icc a b) := hcont.continuousOn_iff.mp hcont
Mathlib/Analysis/Quaternion.lean,Quaternion.norm_piLp_equiv_symm_equivTuple,norm_piLp_equiv_symm_equivTuple,a2d4b97db742cef33d7ce3404f92ab85330707e5,":= by
  rw [norm_eq_sqrt_real_inner, norm_eq_sqrt_real_inner, inner_self, normSq_def', PiLp.inner_apply,
    Fin.sum_univ_four]
  simp_rw [IsROrC.inner_apply, starRingEnd_apply, star_trivial, â† sq]
  rfl","error:  unknown identifier 'IsROrC.inner_apply'
error:  simp made no progress","theorem norm_piLp_equiv_symm_equivTuple (x : â„) :
    â€–(WithLp.equiv 2 (Fin 4 â†’ _)).symm (equivTuple â„ x)â€– = â€–xâ€– ",":= by
  rw [norm_eq_sqrt_real_inner, norm_eq_sqrt_real_inner, inner_self, normSq_def', PiLp.inner_apply,
    Fin.sum_univ_four]
  simp_rw [RCLike.inner_apply, starRingEnd_apply, star_trivial, â† sq]
  rfl","simp only [equivTuple, norm_piLp_equiv_symm_equivTuple, norm_piLp_equiv_symm_equivTuple,
  norm_piLp_equiv_symm_equivTuple]"
Mathlib/MeasureTheory/Group/Prod.lean,MeasureTheory.quasiMeasurePreserving_inv,quasiMeasurePreserving_inv,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  refine' âŸ¨measurable_inv, AbsolutelyContinuous.mk fun s hsm hÎ¼s => _âŸ©
  rw [map_apply measurable_inv hsm, inv_preimage]
  have hf : Measurable fun z : G Ã— G => (z.2 * z.1, z.1â»Â¹) :=
    (measurable_snd.mul measurable_fst).prod_mk measurable_fst.inv
  suffices map (fun z : G Ã— G => (z.2 * z.1, z.1â»Â¹)) (Î¼.prod Î¼) (sâ»Â¹ Ã—Ë¢ sâ»Â¹) = 0 by
    simpa only [(measurePreserving_mul_prod_inv Î¼ Î¼).map_eq, prod_prod, mul_eq_zero (Mâ‚€ := â„â‰¥0âˆ),
      or_self_iff] using this
  have hsm' : MeasurableSet (sâ»Â¹ Ã—Ë¢ sâ»Â¹) := hsm.inv.prod hsm.inv
  simp_rw [map_apply hf hsm', prod_apply_symm (Î¼ := Î¼) (Î½ := Î¼) (hf hsm'), preimage_preimage,
    mk_preimage_prod, inv_preimage, inv_inv, measure_mono_null (inter_subset_right _ _) hÎ¼s,
    lintegral_zero]","error:  function expected at
  inter_subset_right ?m.32570
term has type
  ?m.32569 âˆˆ ?m.32568
error:  simp made no progress",theorem quasiMeasurePreserving_inv : QuasiMeasurePreserving (Inv.inv : G â†’ G) Î¼ Î¼ ,":= by
  refine âŸ¨measurable_inv, AbsolutelyContinuous.mk fun s hsm hÎ¼s => ?_âŸ©
  rw [map_apply measurable_inv hsm, inv_preimage]
  have hf : Measurable fun z : G Ã— G => (z.2 * z.1, z.1â»Â¹) :=
    (measurable_snd.mul measurable_fst).prod_mk measurable_fst.inv
  suffices map (fun z : G Ã— G => (z.2 * z.1, z.1â»Â¹)) (Î¼.prod Î¼) (sâ»Â¹ Ã—Ë¢ sâ»Â¹) = 0 by
    simpa only [(measurePreserving_mul_prod_inv Î¼ Î¼).map_eq, prod_prod, mul_eq_zero (Mâ‚€ := â„â‰¥0âˆ),
      or_self_iff] using this
  have hsm' : MeasurableSet (sâ»Â¹ Ã—Ë¢ sâ»Â¹) := hsm.inv.prod hsm.inv
  simp_rw [map_apply hf hsm', prod_apply_symm (Î¼ := Î¼) (Î½ := Î¼) (hf hsm'), preimage_preimage,
    mk_preimage_prod, inv_preimage, inv_inv, measure_mono_null inter_subset_right hÎ¼s,
    lintegral_zero]",refine quasiMeasurePreserving_inv.quasiMeasurePreserving.quasiMeasurePreserving.quasiMeasurePreserving
Mathlib/Topology/Algebra/Group/Basic.lean,exists_isCompact_isClosed_subset_isCompact_nhds_one,exists_isCompact_isClosed_subset_isCompact_nhds_one,084cfb354233793728fd0ef1054e9b156224e7f6,":= by
  rcases exists_open_nhds_one_mul_subset L1 with âŸ¨V, hVo, hVâ‚, hVLâŸ©
  have hcVL : closure V âŠ† L :=
    calc
      closure V = 1 * closure V := (one_mul _).symm
      _ âŠ† V * closure V :=
        mul_subset_mul_right <| singleton_subset_iff.2 hVâ‚
      _ = V * V := hVo.mul_closure _
      _ âŠ† L := hVL
  exact âŸ¨closure V, isCompact_of_isClosed_subset Lcomp isClosed_closure hcVL, isClosed_closure,
    hcVL, mem_of_superset (hVo.mem_nhds hVâ‚) subset_closureâŸ©",error:  unknown identifier 'isCompact_of_isClosed_subset',"theorem exists_isCompact_isClosed_subset_isCompact_nhds_one
    {L : Set G} (Lcomp : IsCompact L) (L1 : L âˆˆ ğ“ (1 : G)) :
    âˆƒ K : Set G, IsCompact K âˆ§ IsClosed K âˆ§ K âŠ† L âˆ§ K âˆˆ ğ“ (1 : G) ",":=
  let âŸ¨K, âŸ¨hK, hKâ‚, hKâ‚‚âŸ©, hKLâŸ© := (Lcomp.isCompact_isClosed_basis_nhds L1).mem_iff.1 L1
  âŸ¨K, hKâ‚, hKâ‚‚, hKL, hKâŸ©","refine âŸ¨exists_isCompact_isClosed_subset_isClosed_subset_isClosed_subset_isClosed_subset_isCompact_nhds_one, ?_âŸ©"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOnFilter,hasFDerivAt_of_tendstoUniformlyOnFilter,821d503181d6030794806a9ac2fb2b1f5dd5dfb3,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Îµ hÎµ).mono fun y hy => _
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",error:  simp made no progress,"theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ğ“ x))
    (hf : âˆ€á¶  n : Î¹ Ã— E in l Ã—Ë¢ ğ“ x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : âˆ€á¶  y in ğ“ x, Tendsto (fun n => f n y) l (ğ“ (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","refine theorem_hasFDerivAt_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_of_tendstoUniformlyOnFilter_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOn hasFDerivAt_contin"
Mathlib/Order/ConditionallyCompleteLattice/Basic.lean,WithTop.isGLB_sInf,isGLB_sInf,3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  constructor
  Â· show ite _ _ _ âˆˆ _
    split_ifs with h
    Â· intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    Â· rintro (âŸ¨âŸ© | a) ha
      Â· exact le_top
      refine some_le_some.2 (csInf_le ?_ ha)
      rcases hs with âŸ¨âŸ¨âŸ© | b, hbâŸ©
      Â· exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, â† top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact some_le_some.1 (hb hc)
  Â· show ite _ _ _ âˆˆ _
    split_ifs with h
    Â· intro _ _
      exact le_top
    Â· rintro (âŸ¨âŸ© | a) ha
      Â· exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      Â· refine' some_le_some.2 (le_csInf _ _)
        Â· classical
            contrapose! h
            rintro (âŸ¨âŸ© | a) ha
            Â· exact mem_singleton âŠ¤
            Â· exact (not_nonempty_iff_eq_empty.2 h âŸ¨a, haâŸ©).elim
        Â· intro b hb
          rw [â† some_le_some]
          exact ha hb","error:  function expected at
  h
term has type
  s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.intro.none
Î± : Type u_1
Î²âœ : Type u_2
Î³ : Type u_3
Î¹ : Sort u_4
instâœÂ¹ : ConditionallyCompleteLinearOrderBot Î±
Î² : Type u_5
instâœ : ConditionallyCompleteLattice Î²
s : Set (WithTop Î²)
h : Â¬(s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s)
a : Î²
ha : Option.some a âˆˆ s
hb : none âˆˆ lowerBounds s
âŠ¢ s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.none
Î± : Type u_1
Î²âœ : Type u_2
Î³ : Type u_3
Î¹ : Sort u_4
instâœÂ¹ : ConditionallyCompleteLinearOrderBot Î±
Î² : Type u_5
instâœ : ConditionallyCompleteLattice Î²
s : Set (WithTop Î²)
hs : BddBelow s
h : Â¬(s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s)
ha : none âˆˆ lowerBounds s
âŠ¢ s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.refine'_1
Î± : Type u_1
Î²âœ : Type u_2
Î³ : Type u_3
Î¹ : Sort u_4
instâœÂ¹ : ConditionallyCompleteLinearOrderBot Î±
Î² : Type u_5
instâœ : ConditionallyCompleteLattice Î²
s : Set (WithTop Î²)
hs : BddBelow s
a : Î²
ha : Option.some a âˆˆ lowerBounds s
h : (fun a â†¦ â†‘a) â»Â¹' s = âˆ…
âŠ¢ s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s
warning:  Don't mix Option and WithTop","theorem isGLB_sInf' {Î² : Type*} [ConditionallyCompleteLattice Î²] {s : Set (WithTop Î²)}
    (hs : BddBelow s) : IsGLB s (sInf s) ",":= by
  constructor
  Â· show ite _ _ _ âˆˆ _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    Â· intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    Â· rintro (âŸ¨âŸ© | a) ha
      Â· exact le_top
      refine coe_le_coe.2 (csInf_le ?_ ha)
      rcases hs with âŸ¨âŸ¨âŸ© | b, hbâŸ©
      Â· exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, â† top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact coe_le_coe.1 (hb hc)
  Â· show ite _ _ _ âˆˆ _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    Â· intro _ _
      exact le_top
    Â· rintro (âŸ¨âŸ© | a) ha
      Â· exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      Â· refine coe_le_coe.2 (le_csInf ?_ ?_)
        Â· classical
            contrapose! h
            rintro (âŸ¨âŸ© | a) ha
            Â· exact mem_singleton âŠ¤
            Â· exact (not_nonempty_iff_eq_empty.2 h âŸ¨a, haâŸ©).elim
        Â· intro b hb
          rw [â† coe_le_coe]
          exact ha hb","rw [â† isGLB_sInf', isGLB_sInf', isGLB_sInf']"
Mathlib/Analysis/LocallyConvex/Polar.lean,LinearMap.polar_weak_closed,polar_weak_closed,7e7ba10b27c57c170977a654f4c913d7009ac77d,":= by
  rw [polar_eq_interáµ¢]
  refine' isClosed_interáµ¢ fun x => isClosed_interáµ¢ fun _ => _
  exact isClosed_le (WeakBilin.eval_continuous B.flip x).norm continuous_const","error:  unknown identifier 'polar_eq_interáµ¢'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.46457
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâ´ : NormedCommRing ğ•œ
instâœÂ³ : AddCommMonoid E
instâœÂ² : AddCommMonoid F
instâœÂ¹ : Module ğ•œ E
instâœ : Module ğ•œ F
B : E â†’â‚—[ğ•œ] F â†’â‚—[ğ•œ] ğ•œ
s : Set E
âŠ¢ IsClosed (B.polar s)","theorem polar_weak_closed (s : Set E) : IsClosed[WeakBilin.instTopologicalSpace B.flip]
    (B.polar s) ",":= by
  rw [polar_eq_iInter]
  refine isClosed_iInter fun x => isClosed_iInter fun _ => ?_
  exact isClosed_le (WeakBilin.eval_continuous B.flip x).norm continuous_const","refine IsClosed.isClosed_iff.2 âŸ¨flip, ?_âŸ©"
Mathlib/CategoryTheory/Abelian/RightDerived.lean,CategoryTheory.Functor.rightDerived_map_eq,Functor.rightDerived_map_eq,9072ff84a0d139a344bf9eed4a00c4cd27596c79,":= by
  rw [â† cancel_mono (Q.isoRightDerivedObj F n).hom,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,","error:  unexpected token 'noncomputable'; expected ']'
error:  unsolved goals
C : Type u
instâœâµ : Category.{v, u} C
D : Type u_1
instâœâ´ : Category.{u_2, u_1} D
instâœÂ³ : Abelian C
instâœÂ² : HasInjectiveResolutions C
instâœÂ¹ : Abelian D
F : C â¥¤ D
instâœ : F.Additive
n : â„•
X Y : C
f : X âŸ¶ Y
P : InjectiveResolution X
Q : InjectiveResolution Y
g : P.cocomplex âŸ¶ Q.cocomplex
w : P.Î¹ â‰« g = (CochainComplex.singleâ‚€ C).map f â‰« Q.Î¹
âŠ¢ (P.isoRightDerivedObj F n).hom â‰«
      (F.mapHomologicalComplex (ComplexShape.up â„•) â‹™ HomologicalComplex.homologyFunctor D (ComplexShape.up â„•) n).map g =
    ((P.isoRightDerivedObj F n).hom â‰«
        (F.mapHomologicalComplex (ComplexShape.up â„•) â‹™ HomologicalComplex.homologyFunctor D (ComplexShape.up â„•) n).map
            g â‰«
          (Q.isoRightDerivedObj F n).inv) â‰«
      (Q.isoRightDerivedObj F n).hom

C : Type u
instâœâµ : Category.{v, u} C
D : Type u_1
instâœâ´ : Category.{u_2, u_1} D
instâœÂ³ : Abelian C
instâœÂ² : HasInjectiveResolutions C
instâœÂ¹ : Abelian D
F : C â¥¤ D
instâœ : F.Additive
n : â„•
X Y : C
f : X âŸ¶ Y
P : InjectiveResolution X
Q : InjectiveResolution Y
g : P.cocomplex âŸ¶ Q.cocomplex
w : P.Î¹ â‰« g = (CochainComplex.singleâ‚€ C).map f â‰« Q.Î¹
âŠ¢ P.Î¹.f 0 â‰« g.f 0 = f â‰« Q.Î¹.f 0","theorem Functor.rightDerived_map_eq (F : C â¥¤ D) [F.Additive] (n : â„•) {X Y : C} (f : X âŸ¶ Y)
    {P : InjectiveResolution X} {Q : InjectiveResolution Y} (g : P.cocomplex âŸ¶ Q.cocomplex)
    (w : P.Î¹ â‰« g = (CochainComplex.singleâ‚€ C).map f â‰« Q.Î¹) :
    (F.rightDerived n).map f =
      (P.isoRightDerivedObj F n).hom â‰«
        (F.mapHomologicalComplex _ â‹™ HomologicalComplex.homologyFunctor _ _ n).map g â‰«
          (Q.isoRightDerivedObj F n).inv ",":= by
  rw [â† cancel_mono (Q.isoRightDerivedObj F n).hom,
    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,
    assoc, assoc, Iso.inv_hom_id, comp_id]
  rw [â† HomologicalComplex.comp_f, w, HomologicalComplex.comp_f,
    CochainComplex.singleâ‚€_map_f_zero]","simp only [Functor.rightDerived_map_eq, Functor.rightDerived_map_eq,
  HomologicalComplex.homologyFunctor_map, HomologicalComplex.homologyFunctor_map,
  HomologicalComplex.homologyFunctor_map]"
Mathlib/Data/Nat/Bitwise.lean,Nat.bitwise_bit,bitwise_bit,cc9a7cc272508a3475a13e195a657c32a8045f5e,":= by
  conv_lhs => unfold bitwise
  simp (config := { unfoldPartialApp := true }) only [bit, bit1, bit0, Bool.cond_eq_ite]
  have h1 x :     (x + x) % 2 = 0 := by rw [â† two_mul, mul_comm]; apply mul_mod_left
  have h2 x : (x + x + 1) % 2 = 1 := by rw [â† two_mul, add_comm]; apply add_mul_mod_self_left
  have h3 x :     (x + x) / 2 = x := by rw [â† two_mul, mul_comm]; apply mul_div_left _ zero_lt_two
  have h4 x : (x + x + 1) / 2 = x := by rw [â† two_mul, add_comm]; simp [add_mul_div_left]
  cases a <;> cases b <;> simp [h1, h2, h3, h4] <;> split_ifs
    <;> simp_all (config := {decide := true})","warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  unknown identifier 'zero_lt_two'
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `Nat.mul_lt_mul'` has been deprecated, use `Nat.mul_lt_mul_of_le_of_lt` instead
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated","lemma bitwise_bit {f : Bool â†’ Bool â†’ Bool} (h : f false false = false := by rfl) (a m b n) :
    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n) ",":= by
  conv_lhs => unfold bitwise
  simp only [bit, ite_apply, bit1, bit0, Bool.cond_eq_ite]
  have h1 x :     (x + x) % 2 = 0 := by rw [â† two_mul, mul_comm]; apply mul_mod_left
  have h2 x : (x + x + 1) % 2 = 1 := by rw [â† two_mul, add_comm]; apply add_mul_mod_self_left
  have h3 x :     (x + x) / 2 = x := by omega
  have h4 x : (x + x + 1) / 2 = x := by rw [â† two_mul, add_comm]; simp [add_mul_div_left]
  cases a <;> cases b <;> simp [h1, h2, h3, h4] <;> split_ifs
    <;> simp_all (config := {decide := true})","rw [â† drop_bit, â† drop_bit, â† drop_bit, â† drop_bit, â† drop_bit, â† drop_bit]"
Mathlib/Analysis/Convex/Combination.lean,mk_mem_convexHull_prod,mk_mem_convexHull_prod,380ed288b1448ec6781a814b3487a6256011612c,":= by
  rw [mem_convexHull_iff_exists_fintype] at hx hy âŠ¢
  obtain âŸ¨Î¹, _, w, f, hwâ‚€, hwâ‚, hfs, hfâŸ© := hx
  obtain âŸ¨Îº, _, v, g, hvâ‚€, hvâ‚, hgt, hgâŸ© := hy
  have h_sum : âˆ‘ i : Î¹ Ã— Îº, w i.1 * v i.2 = 1 := by
    rw [Fintype.sum_prod_type, â† sum_mul_sum, hwâ‚, hvâ‚, mul_one]
  refine âŸ¨Î¹ Ã— Îº, inferInstance, fun p => w p.1 * v p.2, fun p â†¦ (f p.1, g p.2),
    fun p â†¦ mul_nonneg (hwâ‚€ _) (hvâ‚€ _), h_sum, fun p â†¦ âŸ¨hfs _, hgt _âŸ©, ?_âŸ©
  ext
  Â· simp_rw [Prod.fst_sum, Prod.smul_mk, Fintype.sum_prod_type, mul_comm (w _), mul_smul,
      sum_comm (Î³ := Î¹), â† Fintype.sum_smul_sum, hvâ‚, one_smul, hf]
  Â· simp_rw [Prod.snd_sum, Prod.smul_mk, Fintype.sum_prod_type, mul_smul, â† Fintype.sum_smul_sum,
      hwâ‚, one_smul, hg]","error:  unknown identifier 'mem_convexHull_iff_exists_fintype'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.301903
R : Type u_1
R' : Type u_2
E : Type u_3
F : Type u_4
Î¹ : Type u_5
Î¹' : Type u_6
Î± : Type u_7
instâœâ¸ : LinearOrderedField R
instâœâ· : LinearOrderedField R'
instâœâ¶ : AddCommGroup E
instâœâµ : AddCommGroup F
instâœâ´ : LinearOrderedAddCommGroup Î±
instâœÂ³ : Module R E
instâœÂ² : Module R F
instâœÂ¹ : Module R Î±
instâœ : OrderedSMul R Î±
s : Set E
i j : Î¹
c : R
tâœ : Finset Î¹
w : Î¹ â†’ R
z : Î¹ â†’ E
t : Set F
x : E
y : F
hx : x âˆˆ (convexHull R) s
hy : y âˆˆ (convexHull R) t
âŠ¢ (x, y) âˆˆ (convexHull R) (s Ã—Ë¢ t)","theorem mk_mem_convexHull_prod {t : Set F} {x : E} {y : F} (hx : x âˆˆ convexHull R s)
    (hy : y âˆˆ convexHull R t) : (x, y) âˆˆ convexHull R (s Ã—Ë¢ t) ",":= by
  rw [_root_.convexHull_eq] at hx hy âŠ¢
  obtain âŸ¨Î¹, a, w, S, hw, hw', hS, hSpâŸ© := hx
  obtain âŸ¨Îº, b, v, T, hv, hv', hT, hTpâŸ© := hy
  have h_sum : âˆ‘ i âˆˆ a Ã—Ë¢ b, w i.fst * v i.snd = 1 := by
    rw [Finset.sum_product, â† hw']
    congr
    ext i
    have : âˆ‘ y âˆˆ b, w i * v y = âˆ‘ y âˆˆ b, v y * w i := by
      congr
      ext
      simp [mul_comm]
    rw [this, â† Finset.sum_mul, hv']
    simp
  refine
    âŸ¨Î¹ Ã— Îº, a Ã—Ë¢ b, fun p => w p.1 * v p.2, fun p => (S p.1, T p.2), fun p hp => ?_, h_sum,
      fun p hp => ?_, ?_âŸ©
  Â· rw [mem_product] at hp
    exact mul_nonneg (hw p.1 hp.1) (hv p.2 hp.2)
  Â· rw [mem_product] at hp
    exact âŸ¨hS p.1 hp.1, hT p.2 hp.2âŸ©
  ext
  Â· rw [â† hSp, Finset.centerMass_eq_of_sum_1 _ _ hw', Finset.centerMass_eq_of_sum_1 _ _ h_sum]
    simp_rw [Prod.fst_sum, Prod.smul_mk]
    rw [Finset.sum_product]
    congr
    ext i
    have : (âˆ‘ j âˆˆ b, (w i * v j) â€¢ S i) = âˆ‘ j âˆˆ b, v j â€¢ w i â€¢ S i := by
      congr
      ext
      rw [mul_smul, smul_comm]
    rw [this, â† Finset.sum_smul, hv', one_smul]
  Â· rw [â† hTp, Finset.centerMass_eq_of_sum_1 _ _ hv', Finset.centerMass_eq_of_sum_1 _ _ h_sum]
    simp_rw [Prod.snd_sum, Prod.smul_mk]
    rw [Finset.sum_product, Finset.sum_comm]
    congr
    ext j
    simp_rw [mul_smul]
    rw [â† Finset.sum_smul, hw', one_smul]",rw [convexHull_prod_eq]
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding',exists_extension_norm_eq_of_closedEmbedding',ea54eb89c8a123dcfceeb11bd200d459f2f95413,":= by
  choose F hF_norm hF_dist using fun f : X â†’áµ‡ â„ => tietze_extension_step f e he
  set g : â„• â†’ Y â†’áµ‡ â„ := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : âˆ€ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : âˆ€ n, dist ((g n).compContinuous e) f â‰¤ (2 / 3) ^ n * â€–fâ€– := by
    intro n
    induction' n with n ihn
    Â· simp [g0]
    Â· rw [g_succ n, add_compContinuous, â† dist_sub_right, add_sub_cancel', pow_succ, mul_assoc]
      refine' (hF_dist _).trans (mul_le_mul_of_nonneg_left _ (by norm_num1))
      rwa [â† dist_eq_norm']
  have hg_dist : âˆ€ n, dist (g n) (g (n + 1)) â‰¤ 1 / 3 * â€–fâ€– * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = â€–F (f - (g n).compContinuous e)â€– := by
        rw [g_succ, dist_eq_norm', add_sub_cancel']
      _ â‰¤ â€–f - (g n).compContinuous eâ€– / 3 := (hF_norm _)
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ â‰¤ 1 / 3 * ((2 / 3) ^ n * â€–fâ€–) := (mul_le_mul_of_nonneg_left (hgf n) (by norm_num1))
      _ = 1 / 3 * â€–fâ€– * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ğ“ <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine' tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 _)
    refine' squeeze_zero (fun _ => dist_nonneg) hgf _
    rw [â† zero_mul â€–fâ€–]
    refine' (tendsto_pow_atTop_nhds_zero_of_lt_one _ _).mul tendsto_const_nhds <;> norm_num1
  refine' âŸ¨limUnder atTop g, le_antisymm _ _, hgeâŸ©
  Â· rw [â† dist_zero_left, â† g0]
    refine'
      (dist_le_of_le_geometric_of_tendstoâ‚€ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq _
    field_simp [show (3 - 2 : â„) = 1 by norm_num1]
  Â· rw [â† hge]
    exact norm_compContinuous_le _ _","warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  application type mismatch
  LE.le.trans (hF_dist (f - (g n).compContinuous e)) (mul_le_mul_of_nonneg_left ?m.115481 ?m.115895)
argument
  mul_le_mul_of_nonneg_left ?m.115481 ?m.115895
has type
  2 / 3 * â€–f - (g n).compContinuous eâ€– â‰¤ 2 / 3 * ?m.115476 : Prop
but is expected to have type
  2 / 3 * â€–f - (g n).compContinuous eâ€– â‰¤ (2 / 3) ^ n * (2 / 3 * â€–fâ€–) : Prop
error:  no goals to be solved
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead","theorem exists_extension_norm_eq_of_closedEmbedding' (f : X â†’áµ‡ â„) (e : C(X, Y))
    (he : ClosedEmbedding e) : âˆƒ g : Y â†’áµ‡ â„, â€–gâ€– = â€–fâ€– âˆ§ g.compContinuous e = f ",":= by
  choose F hF_norm hF_dist using fun f : X â†’áµ‡ â„ => tietze_extension_step f e he
  set g : â„• â†’ Y â†’áµ‡ â„ := fun n => (fun g => g + F (f - g.compContinuous e))^[n] 0
  have g0 : g 0 = 0 := rfl
  have g_succ : âˆ€ n, g (n + 1) = g n + F (f - (g n).compContinuous e) := fun n =>
    Function.iterate_succ_apply' _ _ _
  have hgf : âˆ€ n, dist ((g n).compContinuous e) f â‰¤ (2 / 3) ^ n * â€–fâ€– := by
    intro n
    induction' n with n ihn
    Â· simp [g0]
    Â· rw [g_succ n, add_compContinuous, â† dist_sub_right, add_sub_cancel_left, pow_succ', mul_assoc]
      refine (hF_dist _).trans (mul_le_mul_of_nonneg_left ?_ (by norm_num1))
      rwa [â† dist_eq_norm']
  have hg_dist : âˆ€ n, dist (g n) (g (n + 1)) â‰¤ 1 / 3 * â€–fâ€– * (2 / 3) ^ n := by
    intro n
    calc
      dist (g n) (g (n + 1)) = â€–F (f - (g n).compContinuous e)â€– := by
        rw [g_succ, dist_eq_norm', add_sub_cancel_left]
      _ â‰¤ â€–f - (g n).compContinuous eâ€– / 3 := hF_norm _
      _ = 1 / 3 * dist ((g n).compContinuous e) f := by rw [dist_eq_norm', one_div, div_eq_inv_mul]
      _ â‰¤ 1 / 3 * ((2 / 3) ^ n * â€–fâ€–) := mul_le_mul_of_nonneg_left (hgf n) (by norm_num1)
      _ = 1 / 3 * â€–fâ€– * (2 / 3) ^ n := by ac_rfl
  have hg_cau : CauchySeq g := cauchySeq_of_le_geometric _ _ (by norm_num1) hg_dist
  have :
    Tendsto (fun n => (g n).compContinuous e) atTop
      (ğ“ <| (limUnder atTop g).compContinuous e) :=
    ((continuous_compContinuous e).tendsto _).comp hg_cau.tendsto_limUnder
  have hge : (limUnder atTop g).compContinuous e = f := by
    refine tendsto_nhds_unique this (tendsto_iff_dist_tendsto_zero.2 ?_)
    refine squeeze_zero (fun _ => dist_nonneg) hgf ?_
    rw [â† zero_mul â€–fâ€–]
    refine (tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num1
  refine âŸ¨limUnder atTop g, le_antisymm ?_ ?_, hgeâŸ©
  Â· rw [â† dist_zero_left, â† g0]
    refine
      (dist_le_of_le_geometric_of_tendstoâ‚€ _ _ (by norm_num1)
        hg_dist hg_cau.tendsto_limUnder).trans_eq ?_
    field_simp [show (3 - 2 : â„) = 1 by norm_num1]
  Â· rw [â† hge]
    exact norm_compContinuous_le _ _","refine âŸ¨exists_extension_norm_eq_of_closedEmbedding', ?_, ?_âŸ©"
Mathlib/Computability/PartrecCode.lean,Nat.Partrec.Code.rec_prim,rec_prim,6085d5e27552de2d43997b4a52a8d9fcd4686071,":= by
  intros _ _ _ _ F
  let Gâ‚ : (Î± Ã— List Ïƒ) Ã— â„• Ã— â„• â†’ Option Ïƒ := fun p =>
    letI a := p.1.1; letI IH := p.1.2; letI n := p.2.1; letI m := p.2.2
    (IH.get? m).bind fun s =>
    (IH.get? m.unpair.1).bind fun sâ‚ =>
    (IH.get? m.unpair.2).map fun sâ‚‚ =>
    cond n.bodd
      (cond n.div2.bodd (rf a (ofNat Code m, s))
        (pc a (ofNat Code m.unpair.1, ofNat Code m.unpair.2, sâ‚, sâ‚‚)))
      (cond n.div2.bodd (co a (ofNat Code m.unpair.1, ofNat Code m.unpair.2, sâ‚, sâ‚‚))
        (pr a (ofNat Code m.unpair.1, ofNat Code m.unpair.2, sâ‚, sâ‚‚)))
  have : Primrec Gâ‚ :=
    option_bind (list_get?.compâ‚‚ (snd.comp fst) (snd.comp snd)) <| .toâ‚‚ <|
    option_bind ((list_get?.compâ‚‚ (snd.comp fst)
      (fst.comp <| Primrec.unpair.comp (snd.comp snd))).comp fst) <| .toâ‚‚ <|
    option_map ((list_get?.compâ‚‚ (snd.comp fst)
      (snd.comp <| Primrec.unpair.comp (snd.comp snd))).comp <| fst.comp fst) <| .toâ‚‚ <|
    have a := fst.comp (fst.comp <| fst.comp <| fst.comp fst)
    have n := fst.comp (snd.comp <| fst.comp <| fst.comp fst)
    have m := snd.comp (snd.comp <| fst.comp <| fst.comp fst)
    have mâ‚ := fst.comp (Primrec.unpair.comp m)
    have mâ‚‚ := snd.comp (Primrec.unpair.comp m)
    have s := snd.comp (fst.comp fst)
    have sâ‚ := snd.comp fst
    have sâ‚‚ := snd
    (nat_bodd.comp n).cond
      ((nat_bodd.comp <| nat_div2.comp n).cond
        (hrf.compâ‚‚ a (((Primrec.ofNat Code).comp m).pair s))
        (hpc.compâ‚‚ a (((Primrec.ofNat Code).comp mâ‚).pair <|
          ((Primrec.ofNat Code).comp mâ‚‚).pair <| sâ‚.pair sâ‚‚)))
      (Primrec.cond (nat_bodd.comp <| nat_div2.comp n)
        (hco.compâ‚‚ a (((Primrec.ofNat Code).comp mâ‚).pair <|
          ((Primrec.ofNat Code).comp mâ‚‚).pair <| sâ‚.pair sâ‚‚))
        (hpr.compâ‚‚ a (((Primrec.ofNat Code).comp mâ‚).pair <|
          ((Primrec.ofNat Code).comp mâ‚‚).pair <| sâ‚.pair sâ‚‚)))
  let G : Î± â†’ List Ïƒ â†’ Option Ïƒ := fun a IH =>
    IH.length.casesOn (some (z a)) fun n =>
    n.casesOn (some (s a)) fun n =>
    n.casesOn (some (l a)) fun n =>
    n.casesOn (some (r a)) fun n =>
    Gâ‚ ((a, IH), n, n.div2.div2)
  have' : Primrecâ‚‚ G := .toâ‚‚ <|
    nat_casesOn (list_length.comp snd) (option_some_iff.2 (hz.comp fst)) <| .toâ‚‚ <|
    nat_casesOn snd (option_some_iff.2 (hs.comp (fst.comp fst))) <| .toâ‚‚ <|
    nat_casesOn snd (option_some_iff.2 (hl.comp (fst.comp <| fst.comp fst))) <| .toâ‚‚ <|
    nat_casesOn snd (option_some_iff.2 (hr.comp (fst.comp <| fst.comp <| fst.comp fst))) <| .toâ‚‚ <|
    this.comp <|
      ((fst.pair snd).comp <| fst.comp <| fst.comp <| fst.comp <| fst).pair <|
      snd.pair <| nat_div2.comp <| nat_div2.comp snd
  refine (nat_strong_rec (fun a n => F a (ofNat Code n)) this.toâ‚‚ fun a n => ?_)
    |>.compâ‚‚ .id (encode_iff.2 hc) |>.of_eq fun a => by simp
  iterate 4 cases' n with n <;> [(simp [ofNatCode_eq, ofNatCode]; rfl); skip]
  simp only [G]; rw [List.length_map, List.length_range]
  let m := n.div2.div2
  show Gâ‚ ((a, (List.range (n + 4)).map fun n => F a (ofNat Code n)), n, m)
    = some (F a (ofNat Code (n + 4)))
  have hm : m < n + 4 := by
    simp only [m, div2_val]
    exact lt_of_le_of_lt
      (le_trans (Nat.div_le_self ..) (Nat.div_le_self ..))
      (Nat.succ_le_succ (Nat.le_add_right ..))
  have m1 : m.unpair.1 < n + 4 := lt_of_le_of_lt m.unpair_left_le hm
  have m2 : m.unpair.2 < n + 4 := lt_of_le_of_lt m.unpair_right_le hm
  simp only [List.get?_map, Gâ‚, hm, List.get?_range, m1, m2, m]
  rw [show ofNat Code (n + 4) = ofNatCode (n + 4) from rfl]
  simp only [ofNatCode]
  cases n.bodd <;> cases n.div2.bodd <;> rfl","error:  application type mismatch
  Primrecâ‚‚.compâ‚‚ list_get? (_root_.Primrec.comp snd fst)
argument
  _root_.Primrec.comp snd fst
has type
  Primrec fun a â†¦ a.1.2 : Prop
but is expected to have type
  Primrecâ‚‚ ?m.132759 : Prop
error:  application type mismatch
  Primrecâ‚‚.compâ‚‚ list_get? (_root_.Primrec.comp snd fst)
argument
  _root_.Primrec.comp snd fst
has type
  Primrec fun a â†¦ a.1.2 : Prop
but is expected to have type
  Primrecâ‚‚ ?m.360003 : Prop
error:  application type mismatch
  Primrecâ‚‚.compâ‚‚ list_get? (_root_.Primrec.comp snd fst)
argument
  _root_.Primrec.comp snd fst
has type
  Primrec fun a â†¦ a.1.2 : Prop
but is expected to have type
  Primrecâ‚‚ ?m.395717 : Prop
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information","theorem rec_prim' {Î± Ïƒ} [Primcodable Î±] [Primcodable Ïƒ] {c : Î± â†’ Code} (hc : Primrec c) {z : Î± â†’ Ïƒ}
    (hz : Primrec z) {s : Î± â†’ Ïƒ} (hs : Primrec s) {l : Î± â†’ Ïƒ} (hl : Primrec l) {r : Î± â†’ Ïƒ}
    (hr : Primrec r) {pr : Î± â†’ Code Ã— Code Ã— Ïƒ Ã— Ïƒ â†’ Ïƒ} (hpr : Primrecâ‚‚ pr)
    {co : Î± â†’ Code Ã— Code Ã— Ïƒ Ã— Ïƒ â†’ Ïƒ} (hco : Primrecâ‚‚ co) {pc : Î± â†’ Code Ã— Code Ã— Ïƒ Ã— Ïƒ â†’ Ïƒ}
    (hpc : Primrecâ‚‚ pc) {rf : Î± â†’ Code Ã— Ïƒ â†’ Ïƒ} (hrf : Primrecâ‚‚ rf) :
    let PR (a) cf cg hf hg := pr a (cf, cg, hf, hg)
    let CO (a) cf cg hf hg := co a (cf, cg, hf, hg)
    let PC (a) cf cg hf hg := pc a (cf, cg, hf, hg)
    let RF (a) cf hf := rf a (cf, hf)
    let F (a : Î±) (c : Code) : Ïƒ :=
      Nat.Partrec.Code.recOn c (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a)
    Primrec (fun a => F a (c a) : Î± â†’ Ïƒ) ",":= by
  intros _ _ _ _ F
  let Gâ‚ : (Î± Ã— List Ïƒ) Ã— â„• Ã— â„• â†’ Option Ïƒ := fun p =>
    letI a := p.1.1; letI IH := p.1.2; letI n := p.2.1; letI m := p.2.2
    (IH.get? m).bind fun s =>
    (IH.get? m.unpair.1).bind fun sâ‚ =>
    (IH.get? m.unpair.2).map fun sâ‚‚ =>
    cond n.bodd
      (cond n.div2.bodd (rf a (ofNat Code m, s))
        (pc a (ofNat Code m.unpair.1, ofNat Code m.unpair.2, sâ‚, sâ‚‚)))
      (cond n.div2.bodd (co a (ofNat Code m.unpair.1, ofNat Code m.unpair.2, sâ‚, sâ‚‚))
        (pr a (ofNat Code m.unpair.1, ofNat Code m.unpair.2, sâ‚, sâ‚‚)))
  have : Primrec Gâ‚ :=
    option_bind (list_get?.comp (snd.comp fst) (snd.comp snd)) <| .mk <|
    option_bind ((list_get?.comp (snd.comp fst)
      (fst.comp <| Primrec.unpair.comp (snd.comp snd))).comp fst) <| .mk <|
    option_map ((list_get?.comp (snd.comp fst)
      (snd.comp <| Primrec.unpair.comp (snd.comp snd))).comp <| fst.comp fst) <| .mk <|
    have a := fst.comp (fst.comp <| fst.comp <| fst.comp fst)
    have n := fst.comp (snd.comp <| fst.comp <| fst.comp fst)
    have m := snd.comp (snd.comp <| fst.comp <| fst.comp fst)
    have mâ‚ := fst.comp (Primrec.unpair.comp m)
    have mâ‚‚ := snd.comp (Primrec.unpair.comp m)
    have s := snd.comp (fst.comp fst)
    have sâ‚ := snd.comp fst
    have sâ‚‚ := snd
    (nat_bodd.comp n).cond
      ((nat_bodd.comp <| nat_div2.comp n).cond
        (hrf.comp a (((Primrec.ofNat Code).comp m).pair s))
        (hpc.comp a (((Primrec.ofNat Code).comp mâ‚).pair <|
          ((Primrec.ofNat Code).comp mâ‚‚).pair <| sâ‚.pair sâ‚‚)))
      (Primrec.cond (nat_bodd.comp <| nat_div2.comp n)
        (hco.comp a (((Primrec.ofNat Code).comp mâ‚).pair <|
          ((Primrec.ofNat Code).comp mâ‚‚).pair <| sâ‚.pair sâ‚‚))
        (hpr.comp a (((Primrec.ofNat Code).comp mâ‚).pair <|
          ((Primrec.ofNat Code).comp mâ‚‚).pair <| sâ‚.pair sâ‚‚)))
  let G : Î± â†’ List Ïƒ â†’ Option Ïƒ := fun a IH =>
    IH.length.casesOn (some (z a)) fun n =>
    n.casesOn (some (s a)) fun n =>
    n.casesOn (some (l a)) fun n =>
    n.casesOn (some (r a)) fun n =>
    Gâ‚ ((a, IH), n, n.div2.div2)
  have : Primrecâ‚‚ G := .mk <|
    nat_casesOn (list_length.comp snd) (option_some_iff.2 (hz.comp fst)) <| .mk <|
    nat_casesOn snd (option_some_iff.2 (hs.comp (fst.comp fst))) <| .mk <|
    nat_casesOn snd (option_some_iff.2 (hl.comp (fst.comp <| fst.comp fst))) <| .mk <|
    nat_casesOn snd (option_some_iff.2 (hr.comp (fst.comp <| fst.comp <| fst.comp fst))) <| .mk <|
    this.comp <|
      ((fst.pair snd).comp <| fst.comp <| fst.comp <| fst.comp <| fst).pair <|
      snd.pair <| nat_div2.comp <| nat_div2.comp snd
  refine (nat_strong_rec (fun a n => F a (ofNat Code n)) this.toâ‚‚ fun a n => ?_)
    |>.comp .id (encode_iff.2 hc) |>.of_eq fun a => by simp
  simp
  iterate 4 cases' n with n; Â· simp [ofNatCode_eq, ofNatCode]; rfl
  simp only [G]; rw [List.length_map, List.length_range]
  let m := n.div2.div2
  show Gâ‚ ((a, (List.range (n + 4)).map fun n => F a (ofNat Code n)), n, m)
    = some (F a (ofNat Code (n + 4)))
  have hm : m < n + 4 := by
    simp only [m, div2_val]
    exact lt_of_le_of_lt
      (le_trans (Nat.div_le_self ..) (Nat.div_le_self ..))
      (Nat.succ_le_succ (Nat.le_add_right ..))
  have m1 : m.unpair.1 < n + 4 := lt_of_le_of_lt m.unpair_left_le hm
  have m2 : m.unpair.2 < n + 4 := lt_of_le_of_lt m.unpair_right_le hm
  simp [Gâ‚]; simp [m, List.getElem?_map, List.getElem?_range, hm, m1, m2]
  rw [show ofNat Code (n + 4) = ofNatCode (n + 4) from rfl]
  simp [ofNatCode]
  cases n.bodd <;> cases n.div2.bodd <;> rfl",refine Primrec.recOn rec_prim' rec_prim' rec_prim' rec_prim' rec_prim' rec_prim' rec_prim' rf ?_
Mathlib/CategoryTheory/Preadditive/Yoneda/Projective.lean,CategoryTheory.Projective.projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj,projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [projective_iff_preservesEpimorphisms_coyoneda_obj]
  refine' âŸ¨fun h : (preadditiveCoyoneda.obj (op P) â‹™
      forget AddCommGroupCat).PreservesEpimorphisms => _, _âŸ©
  Â· exact Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveCoyoneda.obj (op P))
        (forget _)
  Â· intro
    exact (inferInstance : (preadditiveCoyoneda.obj (op P) â‹™ forget _).PreservesEpimorphisms)","error:  unknown identifier 'AddCommGroupCat'
error:  failed to synthesize
  (preadditiveCoyoneda.obj { unop := P } â‹™ forget AddCommGrp).PreservesEpimorphisms
use `set_option diagnostics true` to get diagnostic information
error:  no goals to be solved","theorem projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj (P : C) :
    Projective P â†” (preadditiveCoyoneda.obj (op P)).PreservesEpimorphisms ",":= by
  rw [projective_iff_preservesEpimorphisms_coyoneda_obj]
  refine âŸ¨fun h : (preadditiveCoyoneda.obj (op P) â‹™
      forget AddCommGrp).PreservesEpimorphisms => ?_, ?_âŸ©
  Â· exact Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveCoyoneda.obj (op P))
        (forget _)
  Â· intro
    exact (inferInstance : (preadditiveCoyoneda.obj (op P) â‹™ forget _).PreservesEpimorphisms)",rw [preservesEpimorphisms_preadditiveCoyoneda_obj]
Mathlib/Probability/Distributions/Gaussian.lean,ProbabilityTheory.gaussianPDFReal_inv_mul,gaussianPDFReal_inv_mul,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp only [gaussianPDFReal._eq_1, zero_lt_two, mul_nonneg_iff_of_pos_left, NNReal.zero_le_coe,
    Real.sqrt_mul', one_div, mul_inv_rev, NNReal.coe_mul, NNReal.coe_mk, NNReal.coe_pos]
  rw [â† mul_assoc]
  refine congr_argâ‚‚ _ ?_ ?_
  Â· field_simp
    rw [Real.sqrt_sq_eq_abs]
    ring_nf
    calc (Real.sqrt â†‘v)â»Â¹ * (Real.sqrt 2)â»Â¹ * (Real.sqrt Ï€)â»Â¹
      = (Real.sqrt â†‘v)â»Â¹ * (Real.sqrt 2)â»Â¹ * (Real.sqrt Ï€)â»Â¹ * (|c| * |c|â»Â¹) := by
          rw [mul_inv_cancel, mul_one]
          simp only [ne_eq, abs_eq_zero, hc, not_false_eq_true]
    _ = (Real.sqrt â†‘v)â»Â¹ * (Real.sqrt 2)â»Â¹ * (Real.sqrt Ï€)â»Â¹ * |c| * |c|â»Â¹ := by ring
  Â· congr 1
    field_simp
    congr 1
    ring","error:  unknown constant 'ProbabilityTheory.gaussianPDFReal._eq_1'
error:  simp made no progress","lemma gaussianPDFReal_inv_mul {Î¼ : â„} {v : â„â‰¥0} {c : â„} (hc : c â‰  0) (x : â„) :
    gaussianPDFReal Î¼ v (câ»Â¹ * x) = |c| * gaussianPDFReal (c * Î¼) (âŸ¨c^2, sq_nonneg _âŸ© * v) x ",":= by
  simp only [gaussianPDFReal.eq_1, zero_lt_two, mul_nonneg_iff_of_pos_left, NNReal.zero_le_coe,
    Real.sqrt_mul', one_div, mul_inv_rev, NNReal.coe_mul, NNReal.coe_mk, NNReal.coe_pos]
  rw [â† mul_assoc]
  refine congr_argâ‚‚ _ ?_ ?_
  Â· field_simp
    rw [Real.sqrt_sq_eq_abs]
    ring_nf
    calc (Real.sqrt â†‘v)â»Â¹ * (Real.sqrt 2)â»Â¹ * (Real.sqrt Ï€)â»Â¹
      = (Real.sqrt â†‘v)â»Â¹ * (Real.sqrt 2)â»Â¹ * (Real.sqrt Ï€)â»Â¹ * (|c| * |c|â»Â¹) := by
          rw [mul_inv_cancel, mul_one]
          simp only [ne_eq, abs_eq_zero, hc, not_false_eq_true]
    _ = (Real.sqrt â†‘v)â»Â¹ * (Real.sqrt 2)â»Â¹ * (Real.sqrt Ï€)â»Â¹ * |c| * |c|â»Â¹ := by ring
  Â· congr 1
    field_simp
    congr 1
    ring","simp [gaussianPDFReal_inv_mul, gaussianPDFReal_inv_mul, gaussianPDFReal_inv_mul]"
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.getD_rightInvSeq_mul_self,getD_rightInvSeq_mul_self,5549e23620db2b17d4924bff0c4de45d992f0b8d,":= by
  simp [getD_rightInvSeq, mul_assoc]
  rcases em (j < Ï‰.length) with hj | nhj
  Â· rw [get?_eq_get hj]
    simp [â† mul_assoc]
  Â· rw [get?_eq_none.mpr (by linarith)]
    simp","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Ï‰.get? j
case inl
B : Type u_1
W : Type u_2
instâœ : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
Ï‰ : List B
j : â„•
hj : j < Ï‰.length
âŠ¢ (cs.rightInvSeq Ï‰)[j]?.getD 1 * (cs.rightInvSeq Ï‰)[j]?.getD 1 = 1
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.96623.get? ?m.96624
case inr
B : Type u_1
W : Type u_2
instâœ : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
Ï‰ : List B
j : â„•
nhj : Â¬j < Ï‰.length
âŠ¢ (cs.rightInvSeq Ï‰)[j]?.getD 1 * (cs.rightInvSeq Ï‰)[j]?.getD 1 = 1","theorem getD_rightInvSeq_mul_self (Ï‰ : List B) (j : â„•) :
    ((ris Ï‰).getD j 1) * ((ris Ï‰).getD j 1) = 1 ",":= by
  simp_rw [getD_rightInvSeq, mul_assoc]
  rcases em (j < Ï‰.length) with hj | nhj
  Â· rw [get?_eq_get hj]
    simp [â† mul_assoc]
  Â· rw [get?_eq_none.mpr (by omega)]
    simp",simp [getD_rightInvSeq_mul_self]
Mathlib/Topology/Algebra/Order/LiminfLimsup.lean,Filter.Tendsto.liminf_eq,Filter.Tendsto.liminf_eq,8f4f347b47261491fcaffde5530e0b5f8490768e,":=
  liminfâ‚›_eq_of_le_nhds h",error:  unknown identifier 'liminfâ‚›_eq_of_le_nhds',"theorem Filter.Tendsto.liminf_eq {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} [NeBot f]
    (h : Tendsto u f (ğ“ a)) : liminf u f = a ",":=
  limsInf_eq_of_le_nhds h",refine liminf_eq_of_tendsto_liminf_eq ?_ ?_
Mathlib/LinearAlgebra/TensorProduct/Vanishing.lean,TensorProduct.vanishesTrivially_iff_sum_tmul_eq_zero_of_rTensor_injective,vanishesTrivially_iff_sum_tmul_eq_zero_of_rTensor_injective,53ef4ce0bcf22cccd58030d7502519c16120d7e5,":=
  âŸ¨sum_tmul_eq_zero_of_vanishesTrivially R m n,
    vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective R m n hmâŸ©","error:  application type mismatch
  sum_tmul_eq_zero_of_vanishesTrivially R m
argument
  m
has type
  Î¹ â†’ M : Type u
but is expected to have type
  VanishesTrivially R ?m.137318 ?m.137319 : Prop
error:  application type mismatch
  vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective R m
argument
  m
has type
  Î¹ â†’ M : Type u
but is expected to have type
  Injective â‡‘(rTensor ?m.138074 (span R (Set.range ?m.138079)).subtype) : Prop","theorem vanishesTrivially_iff_sum_tmul_eq_zero_of_rTensor_injective
    (hm : Injective (rTensor N (span R (Set.range m)).subtype)) :
    VanishesTrivially R m n â†” âˆ‘ i, m i âŠ—â‚œ n i = (0 : M âŠ—[R] N) ",":=
  âŸ¨sum_tmul_eq_zero_of_vanishesTrivially R,
    vanishesTrivially_of_sum_tmul_eq_zero_of_rTensor_injective R hmâŸ©","simp [VanishesTrivially, VanishesTrivially]"
Mathlib/LinearAlgebra/Matrix/Adjugate.lean,Matrix.adjugate_adjugate,adjugate_adjugate,c7bd9bd10c613e1788107ba753e252f069560f87,":= by
  cases' h_card : Fintype.card n with n'
  Â· haveI : IsEmpty n := Fintype.card_eq_zero_iff.mp h_card
    apply Subsingleton.elim
  cases n'
  Â· exact (h h_card).elim
  rw [â† h_card]
  let A' := mvPolynomialX n n â„¤
  suffices adjugate (adjugate A') = det A' ^ (Fintype.card n - 2) â€¢ A' by
    rw [â† mvPolynomialX_mapMatrix_aeval â„¤ A, â† AlgHom.map_adjugate, â† AlgHom.map_adjugate, this,
      â† AlgHom.map_det, â† AlgHom.map_pow, AlgHom.mapMatrix_apply, AlgHom.mapMatrix_apply,
      Matrix.map_smul' _ _ _ (_root_.map_mul _)]
  have h_card' : Fintype.card n - 2 + 1 = Fintype.card n - 1 := by simp [h_card]
  have is_reg : IsSMulRegular (MvPolynomial (n Ã— n) â„¤) (det A') := fun x y =>
    mul_left_cancelâ‚€ (det_mvPolynomialX_ne_zero n â„¤)
  apply is_reg.matrix
  simp only
  rw [smul_smul, â† pow_succ, h_card', det_smul_adjugate_adjugate]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a ^ ?n * ?a
case succ.succ.a
m : Type u
n : Type v
Î± : Type w
instâœâ´ : DecidableEq n
instâœÂ³ : Fintype n
instâœÂ² : DecidableEq m
instâœÂ¹ : Fintype m
instâœ : CommRing Î±
A : Matrix n n Î±
h : Fintype.card n â‰  1
nâœ : â„•
h_card : Fintype.card n = nâœ + 1 + 1
A' : Matrix n n (MvPolynomial (n Ã— n) â„¤) := mvPolynomialX n n â„¤
h_card' : Fintype.card n - 2 + 1 = Fintype.card n - 1
is_reg : IsSMulRegular (MvPolynomial (n Ã— n) â„¤) A'.det
âŠ¢ A'.det â€¢ A'.adjugate.adjugate = (A'.det * A'.det ^ (Fintype.card n - 2)) â€¢ A'","theorem adjugate_adjugate (A : Matrix n n Î±) (h : Fintype.card n â‰  1) :
    adjugate (adjugate A) = det A ^ (Fintype.card n - 2) â€¢ A ",":= by
  cases' h_card : Fintype.card n with n'
  Â· haveI : IsEmpty n := Fintype.card_eq_zero_iff.mp h_card
    apply Subsingleton.elim
  cases n'
  Â· exact (h h_card).elim
  rw [â† h_card]
  let A' := mvPolynomialX n n â„¤
  suffices adjugate (adjugate A') = det A' ^ (Fintype.card n - 2) â€¢ A' by
    rw [â† mvPolynomialX_mapMatrix_aeval â„¤ A, â† AlgHom.map_adjugate, â† AlgHom.map_adjugate, this,
      â† AlgHom.map_det, â† AlgHom.map_pow, AlgHom.mapMatrix_apply, AlgHom.mapMatrix_apply,
      Matrix.map_smul' _ _ _ (_root_.map_mul _)]
  have h_card' : Fintype.card n - 2 + 1 = Fintype.card n - 1 := by simp [h_card]
  have is_reg : IsSMulRegular (MvPolynomial (n Ã— n) â„¤) (det A') := fun x y =>
    mul_left_cancelâ‚€ (det_mvPolynomialX_ne_zero n â„¤)
  apply is_reg.matrix
  simp only
  rw [smul_smul, â† pow_succ', h_card', det_smul_adjugate_adjugate]","simp only [adjugate_adjugate_adjugate, det_adjugate_adjugate]"
Mathlib/RingTheory/IntegralRestrict.lean,Algebra.algebraMap_intNorm_fractionRing,Algebra.algebraMap_intNorm_fractionRing,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  haveI : IsIntegralClosure B A (FractionRing B) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (Algebra.IsIntegral.of_finite A B)
  haveI : IsLocalization (algebraMapSubmonoid B Aâ°) (FractionRing B) :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
      (isAlgebraic_of_isFractionRing _ _ (Algebra.IsIntegral.of_finite A B))
  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=
    Module.Finite_of_isLocalization A B _ _ Aâ°
  exact Algebra.map_intNormAux x","error:  function expected at
  IsIntegralClosure.of_isIntegrallyClosed ?m.545657 ?m.545658 ?m.545662
term has type
  IsIntegralClosure ?m.545657 ?m.545658 ?m.545662
error:  function expected at
  IsIntegralClosure.isLocalization ?m.547451 (FractionRing A) ?m.547464 ?m.547466
term has type
  IsLocalization (algebraMapSubmonoid ?m.547466 ?m.547451â°) ?m.547464","lemma Algebra.algebraMap_intNorm_fractionRing (x : B) :
    algebraMap A (FractionRing A) (Algebra.intNorm A B x) =
      Algebra.norm (FractionRing A) (algebraMap B (FractionRing B) x) ",":= by
  haveI : IsIntegralClosure B A (FractionRing B) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  haveI : IsLocalization (algebraMapSubmonoid B Aâ°) (FractionRing B) :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=
    Module.Finite_of_isLocalization A B _ _ Aâ°
  exact Algebra.map_intNormAux x",rw [Algebra.norm_algebraMap_intNorm_algebraMap_intNorm_algebraMap_intNorm_fractionRing]
Mathlib/Computability/TMToPartrec.lean,Turing.PartrecToTM2.pred_ok,pred_ok,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rcases v with (_ | âŸ¨_ | n, vâŸ©)
  Â· refine' âŸ¨none, TransGen.single _âŸ©
    simp
    rfl
  Â· refine' âŸ¨some Î“'.cons, TransGen.single _âŸ©
    simp
  refine' âŸ¨none, _âŸ©
  simp only [TM2.step, trList, trNat._eq_1, trNum, Nat.cast_succ, Num.add_one, Num.succ,
    List.tail_cons, List.headI_cons]
  cases' (n : Num) with a
  Â· simp [trPosNum, trNum, show Num.zero.succ' = PosNum.one from rfl]
    refine' TransGen.head rfl _
    simp only [Option.mem_def, TM2.stepAux, elim_main, List.head?_cons, Option.some.injEq,
      decide_False, List.tail_cons, elim_update_main, ne_eq, Function.update_noteq, elim_rev,
      elim_update_rev, natEnd, Function.update_same,  cond_true, cond_false]
    convert unrev_ok using 2
    simp
  simp only [Num.succ']
  suffices âˆ€ lâ‚, âˆƒ lâ‚' lâ‚‚' s',
    List.reverseAux lâ‚ (trPosNum a) = List.reverseAux lâ‚' lâ‚‚' âˆ§
      Reachesâ‚ (TM2.step tr)
        âŸ¨some (qâ‚.pred qâ‚‚), s, K'.elim (trPosNum a.succ ++ Î“'.cons :: trList v) lâ‚ c dâŸ©
        âŸ¨some (unrev qâ‚‚), s', K'.elim (lâ‚‚' ++ Î“'.cons :: trList v) lâ‚' c dâŸ© by
    obtain âŸ¨lâ‚', lâ‚‚', s', e, hâŸ© := this []
    simp only [List.reverseAux] at e
    refine' h.trans _
    convert unrev_ok using 2
    simp [e, List.reverseAux_eq]
  induction' a with m IH m IH generalizing s <;> intro lâ‚
  Â· refine' âŸ¨Î“'.bit1::lâ‚, [], some Î“'.cons, rfl, TransGen.head rfl (TransGen.single _)âŸ©
    simp [trPosNum, show PosNum.one.succ = PosNum.one.bit0 from rfl]
  Â· obtain âŸ¨lâ‚', lâ‚‚', s', e, hâŸ© := IH (some Î“'.bit0) (Î“'.bit1 :: lâ‚)
    refine' âŸ¨lâ‚', lâ‚‚', s', e, TransGen.head _ hâŸ©
    simp
    rfl
  Â· obtain âŸ¨a, l, e, hâŸ© : âˆƒ a l, (trPosNum m = a::l) âˆ§ natEnd a = false := by
      cases m <;> refine' âŸ¨_, _, rfl, rflâŸ©
    refine' âŸ¨Î“'.bit0 :: lâ‚, _, some a, rfl, TransGen.single _âŸ©
    simp [trPosNum, PosNum.succ, e, h, show some Î“'.bit1 â‰  some Î“'.bit0 by decide,
      Option.iget, -natEnd]
    rfl","error:  no goals to be solved
error:  unknown constant 'Turing.PartrecToTM2.trNat._eq_1'
error:  simp made no progress
error:  simp made no progress","theorem pred_ok (qâ‚ qâ‚‚ s v) (c d : List Î“') : âˆƒ s',
    Reachesâ‚ (TM2.step tr) âŸ¨some (Î›'.pred qâ‚ qâ‚‚), s, K'.elim (trList v) [] c dâŸ©
      (v.headI.rec âŸ¨some qâ‚, s', K'.elim (trList v.tail) [] c dâŸ© fun n _ =>
        âŸ¨some qâ‚‚, s', K'.elim (trList (n::v.tail)) [] c dâŸ©) ",":= by
  rcases v with (_ | âŸ¨_ | n, vâŸ©)
  Â· refine âŸ¨none, TransGen.single ?_âŸ©
    simp
  Â· refine âŸ¨some Î“'.cons, TransGen.single ?_âŸ©
    simp
  refine âŸ¨none, ?_âŸ©
  simp only [TM2.step, trList, trNat.eq_1, trNum, Nat.cast_succ, Num.add_one, Num.succ,
    List.tail_cons, List.headI_cons]
  cases' (n : Num) with a
  Â· simp [trPosNum, trNum, show Num.zero.succ' = PosNum.one from rfl]
    refine TransGen.head rfl ?_
    simp only [Option.mem_def, TM2.stepAux, elim_main, List.head?_cons, Option.some.injEq,
      decide_False, List.tail_cons, elim_update_main, ne_eq, Function.update_noteq, elim_rev,
      elim_update_rev, natEnd, Function.update_same,  cond_true, cond_false]
    convert unrev_ok using 2
    simp
  simp only [Num.succ']
  suffices âˆ€ lâ‚, âˆƒ lâ‚' lâ‚‚' s',
    List.reverseAux lâ‚ (trPosNum a) = List.reverseAux lâ‚' lâ‚‚' âˆ§
      Reachesâ‚ (TM2.step tr)
        âŸ¨some (qâ‚.pred qâ‚‚), s, K'.elim (trPosNum a.succ ++ Î“'.cons :: trList v) lâ‚ c dâŸ©
        âŸ¨some (unrev qâ‚‚), s', K'.elim (lâ‚‚' ++ Î“'.cons :: trList v) lâ‚' c dâŸ© by
    obtain âŸ¨lâ‚', lâ‚‚', s', e, hâŸ© := this []
    simp only [List.reverseAux] at e
    refine h.trans ?_
    convert unrev_ok using 2
    simp [e, List.reverseAux_eq]
  induction' a with m IH m IH generalizing s <;> intro lâ‚
  Â· refine âŸ¨Î“'.bit1::lâ‚, [], some Î“'.cons, rfl, TransGen.head rfl (TransGen.single ?_)âŸ©
    simp [trPosNum, show PosNum.one.succ = PosNum.one.bit0 from rfl]
  Â· obtain âŸ¨lâ‚', lâ‚‚', s', e, hâŸ© := IH (some Î“'.bit0) (Î“'.bit1 :: lâ‚)
    refine âŸ¨lâ‚', lâ‚‚', s', e, TransGen.head ?_ hâŸ©
    simp
    rfl
  Â· obtain âŸ¨a, l, e, hâŸ© : âˆƒ a l, (trPosNum m = a::l) âˆ§ natEnd a = false := by
      cases m <;> refine âŸ¨_, _, rfl, rflâŸ©
    refine âŸ¨Î“'.bit0 :: lâ‚, _, some a, rfl, TransGen.single ?_âŸ©
    simp [trPosNum, PosNum.succ, e, h, show some Î“'.bit1 â‰  some Î“'.bit0 by decide,
      Option.iget, -natEnd]
    rfl","simp only [TM2.step, TM2.step, elim_main, elim_main, elim_main, elim_main]"
Mathlib/Data/Nat/Multiplicity.lean,Nat.multiplicity_eq_card_pow_dvd,multiplicity_eq_card_pow_dvd,3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":=
  calc
    multiplicity m n = â†‘(Ico 1 <| (multiplicity m n).get (finite_nat_iff.2 âŸ¨hm, hnâŸ©) + 1).card := by
      simp
    _ = â†‘((Finset.Ico 1 b).filter fun i => m ^ i âˆ£ n).card :=
      congr_arg _ <|
        congr_arg card <|
          Finset.ext fun i => by
            rw [mem_filter, mem_Ico, mem_Ico, Nat.lt_succ_iff, â† @PartENat.coe_le_coe i,
              PartENat.natCast_get, â† pow_dvd_iff_le_multiplicity, and_right_comm]
            refine (and_iff_left_of_imp fun h => lt_of_le_of_lt ?_ hb).symm
            cases' m with m
            Â· rw [zero_eq, zero_pow, zero_dvd_iff] at h
              exacts [(hn.ne' h.2).elim, one_le_iff_ne_zero.1 h.1]
            exact le_log_of_pow_le (one_lt_iff_ne_zero_and_ne_one.2 âŸ¨m.succ_ne_zero, hmâŸ©)
                (le_of_dvd hn h.2)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  zero
case zero
n b : â„•
hn : 0 < n
i : â„•
hm : 0 â‰  1
hb : log 0 n < b
h : 1 â‰¤ i âˆ§ 0 ^ i âˆ£ n
âŠ¢ i â‰¤ log 0 n","theorem multiplicity_eq_card_pow_dvd {m n b : â„•} (hm : m â‰  1) (hn : 0 < n) (hb : log m n < b) :
    multiplicity m n = â†‘((Finset.Ico 1 b).filter fun i => m ^ i âˆ£ n).card ",":=
  calc
    multiplicity m n = â†‘(Ico 1 <| (multiplicity m n).get (finite_nat_iff.2 âŸ¨hm, hnâŸ©) + 1).card := by
      simp
    _ = â†‘((Finset.Ico 1 b).filter fun i => m ^ i âˆ£ n).card :=
      congr_arg _ <|
        congr_arg card <|
          Finset.ext fun i => by
            rw [mem_filter, mem_Ico, mem_Ico, Nat.lt_succ_iff, â† @PartENat.coe_le_coe i,
              PartENat.natCast_get, â† pow_dvd_iff_le_multiplicity, and_right_comm]
            refine (and_iff_left_of_imp fun h => lt_of_le_of_lt ?_ hb).symm
            cases' m with m
            Â· rw [zero_pow, zero_dvd_iff] at h
              exacts [(hn.ne' h.2).elim, one_le_iff_ne_zero.1 h.1]
            exact le_log_of_pow_le (one_lt_iff_ne_zero_and_ne_one.2 âŸ¨m.succ_ne_zero, hmâŸ©)
                (le_of_dvd hn h.2)","simp only [card_filter_of_not_multiplicity_eq_card_pow_dvd, card_Ico, card_Ico,
  card_filter_of_not_multiplicity_eq_card_pow_dvd]"
Mathlib/Order/RelSeries.lean,RelSeries.toList_chain',toList_chain',68b7e8e54105799a1ce7dbc912de18675e17874c,":= by
  rw [List.chain'_iff_get]
  intros i h
  have h' : i < x.length := by simpa [List.length_ofFn] using h
  convert x.step âŸ¨i, h'âŸ© <;>
  Â· rw [List.get_ofFn]
    congr 1","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (List.ofFn ?f).get ?i
case h.e'_1
Î± : Type u_1
r : Rel Î± Î±
Î² : Type u_2
s : Rel Î² Î²
x : RelSeries r
i : â„•
h : i < x.toList.length - 1
h' : i < x.length
âŠ¢ x.toList.get âŸ¨i, â‹¯âŸ© = x.toFun âŸ¨i, h'âŸ©.castSucc
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (List.ofFn ?f).get ?i
case h.e'_2
Î± : Type u_1
r : Rel Î± Î±
Î² : Type u_2
s : Rel Î² Î²
x : RelSeries r
i : â„•
h : i < x.toList.length - 1
h' : i < x.length
âŠ¢ x.toList.get âŸ¨i + 1, â‹¯âŸ© = x.toFun âŸ¨i, h'âŸ©.succ",lemma toList_chain' (x : RelSeries r) : x.toList.Chain' r ,":= by
  rw [List.chain'_iff_get]
  intros i h
  convert x.step âŸ¨i, by simpa [toList] using hâŸ© <;> apply List.get_ofFn",induction' x using RelSeries.RelSeries.RelSeries.RelSeries.RelSeries.RelSeries.Chain'
Mathlib/Algebra/Homology/Single.lean,HomologicalComplex.to_single_hom_ext,to_single_hom_ext,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  ext i
  by_cases i = j
  Â· subst h
    exact hfg
  Â· apply (isZero_single_obj_X c j A i h).eq_of_tgt","error:  unknown identifier 'h'
error:  unknown identifier 'h'","lemma to_single_hom_ext {K : HomologicalComplex V c} {j : Î¹} {A : V}
    {f g : K âŸ¶ (single V c j).obj A} (hfg : f.f j = g.f j) : f = g ",":= by
  ext i
  by_cases h : i = j
  Â· subst h
    exact hfg
  Â· apply (isZero_single_obj_X c j A i h).eq_of_tgt",simp only [single_eq_same]
Mathlib/Data/Finsupp/Basic.lean,Finsupp.mapDomain_add,mapDomain_add,67e80fd089fe45abea632652c43b78eba72d60e3,":= by
  classical
  simp [mapDomain]","error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Î¹ : Type u_4
M : Type u_5
M' : Type u_6
N : Type u_7
P : Type u_8
G : Type u_9
H : Type u_10
R : Type u_11
S : Type u_12
instâœ : AddCommMonoid M
v vâ‚ vâ‚‚ : Î± â†’â‚€ M
f : Î± â†’ Î²
âŠ¢ ((vâ‚ + vâ‚‚).sum fun a â†¦ single (f a)) = (vâ‚.sum fun a â†¦ single (f a)) + vâ‚‚.sum fun a â†¦ single (f a)",theorem mapDomain_add {f : Î± â†’ Î²} : mapDomain f (vâ‚ + vâ‚‚) = mapDomain f vâ‚ + mapDomain f vâ‚‚ ,":=
  sum_add_index' (fun _ => single_zero _) fun _ => single_add _","rw [mapDomain_eq_mapDomain, mapDomain_eq_mapDomain, mapDomain_eq_mapDomain, mapDomain_eq_mapDomain]"
Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Instances.lean,unitary_iff_isStarNormal_and_spectrum_subset_circle,unitary_iff_isStarNormal_and_spectrum_subset_circle,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  refine âŸ¨fun hu â†¦ ?_, ?_âŸ©
  Â· have h_normal := isStarNormal_of_mem_unitary hu
    refine âŸ¨h_normal, ?_âŸ©
    have h := unitary.star_mul_self_of_mem hu
    rw [â† cfc_id â„‚ u, â† cfc_star u id, â† cfc_mul .., â† cfc_one â„‚ u] at h
    have := eqOn_of_cfc_eq_cfc u h
    peel this with x hx _
    rw [SetLike.mem_coe, mem_circle_iff_normSq]
    simpa using congr($(this).re)
  Â· rintro âŸ¨_, huâŸ©
    rw [unitary.mem_iff, â† cfc_id â„‚ u, â† cfc_star, â† cfc_mul .., â† cfc_mul .., â† cfc_one â„‚ u]
    simp only [id_eq]
    constructor
    all_goals
      apply cfc_congr _ (fun x hx â†¦ ?_)
      simp only [RCLike.star_def, mul_comm x]
      apply hu at hx
      rwa [SetLike.mem_coe, mem_circle_iff_normSq, â† Complex.ofReal_injective.eq_iff,
        Complex.normSq_eq_conj_mul_self] at hx","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  star (cfc ?m.1036540 id)
case refine_1
A : Type u_1
instâœâµ : TopologicalSpace A
instâœâ´ : Ring A
instâœÂ³ : StarRing A
instâœÂ² : Algebra â„‚ A
instâœÂ¹ : StarModule â„‚ A
instâœ : ContinuousFunctionalCalculus â„‚ IsStarNormal
u : A
hu : u âˆˆ unitary A
h_normal : IsStarNormal u
h : star (cfc id u) * cfc id u = 1
âŠ¢ Ïƒ â„‚ u âŠ† â†‘circle
error:  application type mismatch
  cfc_star u
argument
  u
has type
  A : Type u_1
but is expected to have type
  ?m.1036125 â†’ ?m.1036125 : Type ?u.1036124","lemma unitary_iff_isStarNormal_and_spectrum_subset_circle {u : A} :
    u âˆˆ unitary A â†” IsStarNormal u âˆ§ spectrum â„‚ u âŠ† circle ",":= by
  refine âŸ¨fun hu â†¦ ?_, ?_âŸ©
  Â· have h_normal := isStarNormal_of_mem_unitary hu
    refine âŸ¨h_normal, ?_âŸ©
    have h := unitary.star_mul_self_of_mem hu
    rw [â† cfc_id â„‚ u, â† cfc_star id u, â† cfc_mul .., â† cfc_one â„‚ u] at h
    have := eqOn_of_cfc_eq_cfc h
    peel this with x hx _
    rw [SetLike.mem_coe, mem_circle_iff_normSq]
    simpa using congr($(this).re)
  Â· rintro âŸ¨_, huâŸ©
    rw [unitary.mem_iff, â† cfc_id â„‚ u, â† cfc_star, â† cfc_mul .., â† cfc_mul .., â† cfc_one â„‚ u]
    simp only [id_eq]
    constructor
    all_goals
      apply cfc_congr (fun x hx â†¦ ?_)
      simp only [RCLike.star_def, mul_comm x]
      apply hu at hx
      rwa [SetLike.mem_coe, mem_circle_iff_normSq, â† Complex.ofReal_injective.eq_iff,
        Complex.normSq_eq_conj_mul_self] at hx",simp [unitary_iff_isStarNormal__and_spectrum_subset_circle]
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ'
  Â· rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine' Or.inl âŸ¨hs, _âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine' mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, _âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine'
        mem_shadow_iff.2
          âŸ¨(t âŠ” u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, _, _âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine' âŸ¨hus, hsv.symm, âŸ¨x, _, _âŸ©, _âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right _ _, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) _
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans $ subset_union_left _ _),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  unexpected token 'Â·'; expected 'by' or 'from'","theorem shadow_compression_subset_compression_shadow (u v : Finset Î±)
    (huv : âˆ€ x âˆˆ u, âˆƒ y âˆˆ v, IsCompressed (u.erase x) (v.erase y) ğ’œ) :
    âˆ‚ (ğ“’ u v ğ’œ) âŠ† ğ“’ u v (âˆ‚ ğ’œ) ",":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine Or.inl âŸ¨hs, ?_âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, ?_âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine mem_shadow_iff.2
        âŸ¨(t âŠ” u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine âŸ¨hus, hsv.symm, âŸ¨x, ?_, ?_âŸ©, ?_âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) ?_
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]",refine theorem_shadow_compression_subset_compression_subset_compression_subset_compression_subset_compression_shadow huv
Mathlib/Topology/Category/TopCat/Limits/Products.lean,TopCat.binaryCofan_isColimit_iff,binaryCofan_isColimit_iff,fdfff7b3a618d890d340c3e3a74a9ad345cdf7b7,":= by
  classical
    constructor
    Â· rintro âŸ¨hâŸ©
      rw [â† show _ = c.inl from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) âŸ¨WalkingPair.leftâŸ©,
        â† show _ = c.inr from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) âŸ¨WalkingPair.rightâŸ©]
      dsimp
      refine' âŸ¨(homeoOfIso <| h.coconePointUniqueUpToIso
        (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inr, _âŸ©
      erw [Set.range_comp, â† eq_compl_iff_isCompl, coe_comp, coe_comp, Set.range_comp _ Sum.inr,
        â† Set.image_compl_eq (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]
      aesop
    Â· rintro âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ©
      have : âˆ€ x, x âˆˆ Set.range c.inl âˆ¨ x âˆˆ Set.range c.inr := by
        rw [eq_compl_iff_isCompl.mpr hâ‚ƒ.symm]
        exact fun _ => or_not
      refine' âŸ¨BinaryCofan.IsColimit.mk _ _ _ _ _âŸ©
      Â· intro T f g
        refine' ContinuousMap.mk _ _
        Â· exact fun x =>
            if h : x âˆˆ Set.range c.inl then f ((Equiv.ofInjective _ hâ‚.inj).symm âŸ¨x, hâŸ©)
            else g ((Equiv.ofInjective _ hâ‚‚.inj).symm âŸ¨x, (this x).resolve_left hâŸ©)
        rw [continuous_iff_continuousAt]
        intro x
        by_cases h : x âˆˆ Set.range c.inl
        Â· revert h x
          apply (IsOpen.continuousOn_iff _).mp
          Â· rw [continuousOn_iff_continuous_restrict]
            convert_to Continuous (f âˆ˜ hâ‚.toHomeomorph.symm)
            Â· ext âŸ¨x, hxâŸ©
              exact dif_pos hx
            apply Continuous.comp
            Â· exact f.continuous_toFun
            Â· continuity
          Â· exact hâ‚.isOpen_range
        Â· revert h x
          apply (IsOpen.continuousOn_iff _).mp
          Â· rw [continuousOn_iff_continuous_restrict]
            have : âˆ€ a, a âˆ‰ Set.range c.inl â†’ a âˆˆ Set.range c.inr := by
              rintro a (h : a âˆˆ (Set.range c.inl)á¶œ)
              rwa [eq_compl_iff_isCompl.mpr hâ‚ƒ.symm]
            convert_to Continuous
                (g âˆ˜ hâ‚‚.toHomeomorph.symm âˆ˜ Subtype.map _ this)
            Â· ext âŸ¨x, hxâŸ©
              exact dif_neg hx
            apply Continuous.comp
            Â· exact g.continuous_toFun
            Â· apply Continuous.comp
              Â· continuity
              Â· rw [embedding_subtype_val.toInducing.continuous_iff]
                exact continuous_subtype_val
          Â· change IsOpen (Set.range c.inl)á¶œ
            rw [â† eq_compl_iff_isCompl.mpr hâ‚ƒ.symm]
            exact hâ‚‚.isOpen_range
      Â· intro T f g
        ext x
        refine' (dif_pos _).trans _
        Â· exact âŸ¨x, rflâŸ©
        Â· dsimp; conv_lhs => erw [Equiv.ofInjective_symm_apply]
      Â· intro T f g
        ext x
        refine' (dif_neg _).trans _
        Â· rintro âŸ¨y, eâŸ©
          have : c.inr x âˆˆ Set.range c.inl âŠ“ Set.range c.inr := âŸ¨âŸ¨_, eâŸ©, âŸ¨_, rflâŸ©âŸ©
          rwa [disjoint_iff.mp hâ‚ƒ.1] at this
        Â· exact congr_arg g (Equiv.ofInjective_symm_apply _ _)
      Â· rintro T _ _ m rfl rfl
        ext x
        change m x = dite _ _ _
        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ âŸ¨_, _âŸ©).symm","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â‡‘(?f â‰« ?g)
case mp.intro
J : Type v
instâœ : SmallCategory J
X Y : TopCat
c : BinaryCofan X Y
h : IsColimit c
âŠ¢ â‡‘(h.coconePointUniqueUpToIso (X.binaryCofanIsColimit Y)).inv '' Set.range â‡‘(X.binaryCofan Y).inl =
    (Set.range (â‡‘(h.coconePointUniqueUpToIso (X.binaryCofanIsColimit Y)).inv âˆ˜ â‡‘(X.binaryCofan Y).inr))á¶œ
error:  invalid field 'toHomeomorph', the environment does not contain 'OpenEmbedding.toHomeomorph'
  hâ‚
has type
  OpenEmbedding â‡‘c.inl
error:  tactic 'aesop' failed, failed to prove the goal after exhaustive search.
Initial goal:
  case pos.convert_3.hf
  J : Type v
  instâœ : SmallCategory J
  X Y : TopCat
  c : BinaryCofan X Y
  hâ‚ : OpenEmbedding â‡‘c.inl
  hâ‚‚ : OpenEmbedding â‡‘c.inr
  hâ‚ƒ : IsCompl (Set.range â‡‘c.inl) (Set.range â‡‘c.inr)
  this :
    âˆ€ (x : â†‘(((Functor.const (Discrete WalkingPair)).obj c.pt).obj { as := WalkingPair.left })),
      x âˆˆ Set.range â‡‘c.inl âˆ¨ x âˆˆ Set.range â‡‘c.inr
  T : TopCat
  f : X âŸ¶ T
  g : Y âŸ¶ T
  âŠ¢ Continuous (sorryAx (â†‘(Set.range â‡‘c.inl) â†’ â†‘X) true)
Remaining goals after safe rules:
  J : Type v
  inst : SmallCategory J
  X Y : TopCat
  c : BinaryCofan X Y
  T : TopCat
  f : X âŸ¶ T
  g : Y âŸ¶ T
  hâ‚ : OpenEmbedding â‡‘c.inl
  hâ‚‚ : OpenEmbedding â‡‘c.inr
  hâ‚ƒ : IsCompl (Set.range â‡‘c.inl) (Set.range â‡‘c.inr)
  this : âˆ€ (x : â†‘c.pt), (âˆƒ y, c.inl y = x) âˆ¨ âˆƒ y, c.inr y = x
  âŠ¢ Continuous (sorryAx (â†‘(Set.range â‡‘c.inl) â†’ â†‘X) true)
error:  invalid field 'toHomeomorph', the environment does not contain 'OpenEmbedding.toHomeomorph'
  hâ‚‚
has type
  OpenEmbedding â‡‘c.inr
error:  tactic 'aesop' failed, failed to prove the goal after exhaustive search.
Initial goal:
  case neg.hf.hg
  J : Type v
  instâœ : SmallCategory J
  X Y : TopCat
  c : BinaryCofan X Y
  hâ‚ : OpenEmbedding â‡‘c.inl
  hâ‚‚ : OpenEmbedding â‡‘c.inr
  hâ‚ƒ : IsCompl (Set.range â‡‘c.inl) (Set.range â‡‘c.inr)
  thisâœ :
    âˆ€ (x : â†‘(((Functor.const (Discrete WalkingPair)).obj c.pt).obj { as := WalkingPair.left })),
      x âˆˆ Set.range â‡‘c.inl âˆ¨ x âˆˆ Set.range â‡‘c.inr
  T : TopCat
  f : X âŸ¶ T
  g : Y âŸ¶ T
  this : âˆ€ a âˆ‰ Set.range â‡‘c.inl, a âˆˆ Set.range â‡‘c.inr
  âŠ¢ Continuous (sorryAx (Subtype Exists â†’ â†‘Y) true)
Remaining goals after safe rules:
  J : Type v
  inst : SmallCategory J
  X Y : TopCat
  c : BinaryCofan X Y
  T : TopCat
  f : X âŸ¶ T
  g : Y âŸ¶ T
  hâ‚ : OpenEmbedding â‡‘c.inl
  hâ‚‚ : OpenEmbedding â‡‘c.inr
  hâ‚ƒ : IsCompl (Set.range â‡‘c.inl) (Set.range â‡‘c.inr)
  this_1 : âˆ€ (x : â†‘c.pt), (âˆƒ y, c.inl y = x) âˆ¨ âˆƒ y, c.inr y = x
  this : âˆ€ (a : â†‘c.pt), (âˆ€ (x : â†‘X), Â¬c.inl x = a) â†’ âˆƒ y, c.inr y = a
  âŠ¢ Continuous (sorryAx (Subtype Exists â†’ â†‘Y) true)
error:  type mismatch
  continuous_subtype_val
has type
  Continuous Subtype.val : Prop
but is expected to have type
  Continuous (Subtype.val âˆ˜ Subtype.map (fun a y â†¦ c.inr y = a) this) : Prop
error:  unsolved goals
case mpr.intro.intro.refine'_2.w.refine'_2
J : Type v
instâœ : SmallCategory J
X Y : TopCat
c : BinaryCofan X Y
hâ‚ : OpenEmbedding â‡‘c.inl
hâ‚‚ : OpenEmbedding â‡‘c.inr
hâ‚ƒ : IsCompl (Set.range â‡‘c.inl) (Set.range â‡‘c.inr)
this :
  âˆ€ (x : â†‘(((Functor.const (Discrete WalkingPair)).obj c.pt).obj { as := WalkingPair.left })),
    x âˆˆ Set.range â‡‘c.inl âˆ¨ x âˆˆ Set.range â‡‘c.inr
T : TopCat
f : X âŸ¶ T
g : Y âŸ¶ T
x : (forget TopCat).obj ((pair X Y).obj { as := WalkingPair.left })
âŠ¢ f x = f x","theorem binaryCofan_isColimit_iff {X Y : TopCat} (c : BinaryCofan X Y) :
    Nonempty (IsColimit c) â†”
      OpenEmbedding c.inl âˆ§ OpenEmbedding c.inr âˆ§ IsCompl (Set.range c.inl) (Set.range c.inr) ",":= by
  classical
    constructor
    Â· rintro âŸ¨hâŸ©
      rw [â† show _ = c.inl from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) âŸ¨WalkingPair.leftâŸ©,
        â† show _ = c.inr from
          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) âŸ¨WalkingPair.rightâŸ©]
      dsimp
      refine âŸ¨(homeoOfIso <| h.coconePointUniqueUpToIso
        (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inl,
          (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.openEmbedding.comp openEmbedding_inr, ?_âŸ©
      erw [Set.range_comp, â† eq_compl_iff_isCompl, Set.range_comp _ Sum.inr,
        â† Set.image_compl_eq (homeoOfIso <| h.coconePointUniqueUpToIso
            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]
    Â· rintro âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ©
      have : âˆ€ x, x âˆˆ Set.range c.inl âˆ¨ x âˆˆ Set.range c.inr := by
        rw [eq_compl_iff_isCompl.mpr hâ‚ƒ.symm]
        exact fun _ => or_not
      refine âŸ¨BinaryCofan.IsColimit.mk _ ?_ ?_ ?_ ?_âŸ©
      Â· intro T f g
        refine ContinuousMap.mk ?_ ?_
        Â· exact fun x =>
            if h : x âˆˆ Set.range c.inl then f ((Equiv.ofInjective _ hâ‚.inj).symm âŸ¨x, hâŸ©)
            else g ((Equiv.ofInjective _ hâ‚‚.inj).symm âŸ¨x, (this x).resolve_left hâŸ©)
        rw [continuous_iff_continuousAt]
        intro x
        by_cases h : x âˆˆ Set.range c.inl
        Â· revert h x
          apply (IsOpen.continuousOn_iff _).mp
          Â· rw [continuousOn_iff_continuous_restrict]
            convert_to Continuous (f âˆ˜ (Homeomorph.ofEmbedding _ hâ‚.toEmbedding).symm)
            Â· ext âŸ¨x, hxâŸ©
              exact dif_pos hx
            apply Continuous.comp
            Â· exact f.continuous_toFun
            Â· continuity
          Â· exact hâ‚.isOpen_range
        Â· revert h x
          apply (IsOpen.continuousOn_iff _).mp
          Â· rw [continuousOn_iff_continuous_restrict]
            have : âˆ€ a, a âˆ‰ Set.range c.inl â†’ a âˆˆ Set.range c.inr := by
              rintro a (h : a âˆˆ (Set.range c.inl)á¶œ)
              rwa [eq_compl_iff_isCompl.mpr hâ‚ƒ.symm]
            convert_to Continuous
                (g âˆ˜ (Homeomorph.ofEmbedding _ hâ‚‚.toEmbedding).symm âˆ˜ Subtype.map _ this)
            Â· ext âŸ¨x, hxâŸ©
              exact dif_neg hx
            apply Continuous.comp
            Â· exact g.continuous_toFun
            Â· apply Continuous.comp
              Â· continuity
              Â· rw [embedding_subtype_val.toInducing.continuous_iff]
                exact continuous_subtype_val
          Â· change IsOpen (Set.range c.inl)á¶œ
            rw [â† eq_compl_iff_isCompl.mpr hâ‚ƒ.symm]
            exact hâ‚‚.isOpen_range
      Â· intro T f g
        ext x
        refine (dif_pos ?_).trans ?_
        Â· exact âŸ¨x, rflâŸ©
        Â· dsimp
          conv_lhs => erw [Equiv.ofInjective_symm_apply]
          rfl 
      Â· intro T f g
        ext x
        refine (dif_neg ?_).trans ?_
        Â· rintro âŸ¨y, eâŸ©
          have : c.inr x âˆˆ Set.range c.inl âŠ“ Set.range c.inr := âŸ¨âŸ¨_, eâŸ©, âŸ¨_, rflâŸ©âŸ©
          rwa [disjoint_iff.mp hâ‚ƒ.1] at this
        Â· exact congr_arg g (Equiv.ofInjective_symm_apply _ _)
      Â· rintro T _ _ m rfl rfl
        ext x
        change m x = dite _ _ _
        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ âŸ¨_, _âŸ©).symm",constructor
Mathlib/Topology/UniformSpace/Ascoli.lean,ArzelaAscoli.compactSpace_of_closedEmbedding,ArzelaAscoli.compactSpace_of_closedEmbedding,4bd8363ebf8b75d032229f5474189f7293dd11b8,":=
  compactSpace_of_closed_inducing' ğ”–_compact F_clemb.toInducing F_clemb.closed_range
    F_eqcont F_pointwiseCompact","error:  invalid field 'closed_range', the environment does not contain 'ClosedEmbedding.closed_range'
  F_clemb
has type
  ClosedEmbedding (â‡‘(UniformOnFun.ofFun ğ”–) âˆ˜ F)","theorem ArzelaAscoli.compactSpace_of_closedEmbedding [TopologicalSpace Î¹] {ğ”– : Set (Set X)}
    (ğ”–_compact : âˆ€ K âˆˆ ğ”–, IsCompact K) (F_clemb : ClosedEmbedding (UniformOnFun.ofFun ğ”– âˆ˜ F))
    (F_eqcont : âˆ€ K âˆˆ ğ”–, EquicontinuousOn F K)
    (F_pointwiseCompact : âˆ€ K âˆˆ ğ”–, âˆ€ x âˆˆ K, âˆƒ Q, IsCompact Q âˆ§ âˆ€ i, F i x âˆˆ Q) :
    CompactSpace Î¹ ",":=
  compactSpace_of_closed_inducing' ğ”–_compact F_clemb.toInducing F_clemb.isClosed_range
    F_eqcont F_pointwiseCompact","refine CompactSpace.compactSpace_of_compact_space_of_equicontinuousOn ArzelaAscoli.compactSpace_of_closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding
  F_clemb.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding.closedEmbedding"
Mathlib/Data/Finsupp/Basic.lean,Finsupp.mapRange.addEquiv_symm,mapRange.addEquiv_symm,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.mapRange.addEquiv_symm (fun _ => f)",error:  unknown identifier 'DFinsupp.mapRange.addEquiv_symm',"theorem mapRange.addEquiv_symm (f : M â‰ƒ+ N) :
    ((mapRange.addEquiv f).symm : (Î± â†’â‚€ _) â‰ƒ+ _) = mapRange.addEquiv f.symm ",":=
  AddEquiv.ext fun _ => rfl",simp [mapRange.addEquiv_symm_apply]
Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean,Real.volume_le_diam,volume_le_diam,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  by_cases hs : Bornology.IsBounded s
  Â· rw [Real.ediam_eq hs, â† volume_Icc]
    exact volume.mono (Real.subset_Icc_sInf_sSup_of_isBounded hs)
  Â· rw [Metric.ediam_of_unbounded hs]; exact le_top",error:  unknown constant 'Real.subset_Icc_sInf_sSup_of_isBounded',theorem volume_le_diam (s : Set â„) : volume s â‰¤ EMetric.diam s ,":= by
  by_cases hs : Bornology.IsBounded s
  Â· rw [Real.ediam_eq hs, â† volume_Icc]
    exact volume.mono hs.subset_Icc_sInf_sSup
  Â· rw [Metric.ediam_of_unbounded hs]; exact le_top",have : EMetric.diam s = EMetric.diam s := EMetric.diam_mono volume_le_diam volume_le_diam
Mathlib/MeasureTheory/Integral/Lebesgue.lean,MeasureTheory.lintegral_iSup,lintegral_iSup,0ac02f4dacdee757591d884646ebd501c21f0eb9,":= by
  set c : â„â‰¥0 â†’ â„â‰¥0âˆ := (â†‘)
  set F := fun a : Î± => â¨† n, f n a
  have _ : Measurable F := measurable_iSup hf
  refine' le_antisymm _ (iSup_lintegral_le _)
  rw [lintegral_eq_nnreal]
  refine' iSup_le fun s => iSup_le fun hsf => _
  refine' ENNReal.le_of_forall_lt_one_mul_le fun a ha => _
  rcases ENNReal.lt_iff_exists_coe.1 ha with âŸ¨r, rfl, _âŸ©
  have ha : r < 1 := ENNReal.coe_lt_coe.1 ha
  let rs := s.map fun a => r * a
  have eq_rs : (const Î± r : Î± â†’â‚› â„â‰¥0âˆ) * map c s = rs.map c := by
    ext1 a
    exact ENNReal.coe_mul.symm
  have eq : âˆ€ p, rs.map c â»Â¹' {p} = â‹ƒ n, rs.map c â»Â¹' {p} âˆ© { a | p â‰¤ f n a } := by
    intro p
    rw [â† inter_iUnion]; nth_rw 1 [â† inter_univ (map c rs â»Â¹' {p})]
    refine' Set.ext fun x => and_congr_right fun hx => true_iff_iff.2 _
    by_cases p_eq : p = 0
    Â· simp [p_eq]
    simp only [coe_map, mem_preimage, Function.comp_apply, mem_singleton_iff] at hx
    subst hx
    have : r * s x â‰  0 := by rwa [Ne, â† ENNReal.coe_eq_zero]
    have : s x â‰  0 := by
      refine' mt _ this
      intro h
      rw [h, mul_zero]
    have : (rs.map c) x < â¨† n : â„•, f n x := by
      refine' lt_of_lt_of_le (ENNReal.coe_lt_coe.2 _) (hsf x)
      suffices r * s x < 1 * s x by simpa
      exact mul_lt_mul_of_pos_right ha (pos_iff_ne_zero.2 this)
    rcases lt_iSup_iff.1 this with âŸ¨i, hiâŸ©
    exact mem_iUnion.2 âŸ¨i, le_of_lt hiâŸ©
  have mono : âˆ€ r : â„â‰¥0âˆ, Monotone fun n => rs.map c â»Â¹' {r} âˆ© { a | r â‰¤ f n a } := by
    intro r i j h
    refine' inter_subset_inter (Subset.refl _) _
    intro x (hx : r â‰¤ f i x)
    exact le_trans hx (h_mono h x)
  have h_meas : âˆ€ n, MeasurableSet { a : Î± | (â‡‘(map c rs)) a â‰¤ f n a } := fun n =>
    measurableSet_le (SimpleFunc.measurable _) (hf n)
  calc
    (r : â„â‰¥0âˆ) * (s.map c).lintegral Î¼ = âˆ‘ r in (rs.map c).range, r * Î¼ (rs.map c â»Â¹' {r}) := by
      rw [â† const_mul_lintegral, eq_rs, SimpleFunc.lintegral]
    _ = âˆ‘ r in (rs.map c).range, r * Î¼ (â‹ƒ n, rs.map c â»Â¹' {r} âˆ© { a | r â‰¤ f n a }) := by
      simp only [(eq _).symm]
    _ = âˆ‘ r in (rs.map c).range, â¨† n, r * Î¼ (rs.map c â»Â¹' {r} âˆ© { a | r â‰¤ f n a }) :=
      (Finset.sum_congr rfl fun x _ => by
        rw [measure_iUnion_eq_iSup (mono x).directed_le, ENNReal.mul_iSup])
    _ = â¨† n, âˆ‘ r in (rs.map c).range, r * Î¼ (rs.map c â»Â¹' {r} âˆ© { a | r â‰¤ f n a }) := by
      rw [ENNReal.finset_sum_iSup_nat]
      intro p i j h
      exact mul_le_mul_left' (measure_mono <| mono p h) _
    _ â‰¤ â¨† n : â„•, ((rs.map c).restrict { a | (rs.map c) a â‰¤ f n a }).lintegral Î¼ := by
      refine' iSup_mono fun n => _
      rw [restrict_lintegral _ (h_meas n)]
      Â· refine' le_of_eq (Finset.sum_congr rfl fun r _ => _)
        congr 2 with a
        refine' and_congr_right _
        simp (config := { contextual := true })
    _ â‰¤ â¨† n, âˆ«â» a, f n a âˆ‚Î¼ := by
      refine' iSup_mono fun n => _
      rw [â† SimpleFunc.lintegral_eq_lintegral]
      refine' lintegral_mono fun a => _
      simp only [map_apply] at h_meas
      simp only [coe_map, restrict_apply _ (h_meas _), (Â· âˆ˜ Â·)]
      exact indicator_apply_le id","warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
error:  unknown constant 'ENNReal.coe_mul.symm'","theorem lintegral_iSup {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ n, Measurable (f n)) (h_mono : Monotone f) :
    âˆ«â» a, â¨† n, f n a âˆ‚Î¼ = â¨† n, âˆ«â» a, f n a âˆ‚Î¼ ",":= by
  set c : â„â‰¥0 â†’ â„â‰¥0âˆ := (â†‘)
  set F := fun a : Î± => â¨† n, f n a
  refine le_antisymm ?_ (iSup_lintegral_le _)
  rw [lintegral_eq_nnreal]
  refine iSup_le fun s => iSup_le fun hsf => ?_
  refine ENNReal.le_of_forall_lt_one_mul_le fun a ha => ?_
  rcases ENNReal.lt_iff_exists_coe.1 ha with âŸ¨r, rfl, _âŸ©
  have ha : r < 1 := ENNReal.coe_lt_coe.1 ha
  let rs := s.map fun a => r * a
  have eq_rs : rs.map c = (const Î± r : Î± â†’â‚› â„â‰¥0âˆ) * map c s := rfl
  have eq : âˆ€ p, rs.map c â»Â¹' {p} = â‹ƒ n, rs.map c â»Â¹' {p} âˆ© { a | p â‰¤ f n a } := by
    intro p
    rw [â† inter_iUnion]; nth_rw 1 [â† inter_univ (map c rs â»Â¹' {p})]
    refine Set.ext fun x => and_congr_right fun hx => true_iff_iff.2 ?_
    by_cases p_eq : p = 0
    Â· simp [p_eq]
    simp only [coe_map, mem_preimage, Function.comp_apply, mem_singleton_iff] at hx
    subst hx
    have : r * s x â‰  0 := by rwa [Ne, â† ENNReal.coe_eq_zero]
    have : s x â‰  0 := right_ne_zero_of_mul this
    have : (rs.map c) x < â¨† n : â„•, f n x := by
      refine lt_of_lt_of_le (ENNReal.coe_lt_coe.2 ?_) (hsf x)
      suffices r * s x < 1 * s x by simpa
      exact mul_lt_mul_of_pos_right ha (pos_iff_ne_zero.2 this)
    rcases lt_iSup_iff.1 this with âŸ¨i, hiâŸ©
    exact mem_iUnion.2 âŸ¨i, le_of_lt hiâŸ©
  have mono : âˆ€ r : â„â‰¥0âˆ, Monotone fun n => rs.map c â»Â¹' {r} âˆ© { a | r â‰¤ f n a } := by
    intro r i j h
    refine inter_subset_inter_right _ ?_
    simp_rw [subset_def, mem_setOf]
    intro x hx
    exact le_trans hx (h_mono h x)
  have h_meas : âˆ€ n, MeasurableSet {a : Î± | map c rs a â‰¤ f n a} := fun n =>
    measurableSet_le (SimpleFunc.measurable _) (hf n)
  calc
    (r : â„â‰¥0âˆ) * (s.map c).lintegral Î¼ = âˆ‘ r âˆˆ (rs.map c).range, r * Î¼ (rs.map c â»Â¹' {r}) := by
      rw [â† const_mul_lintegral, eq_rs, SimpleFunc.lintegral]
    _ = âˆ‘ r âˆˆ (rs.map c).range, r * Î¼ (â‹ƒ n, rs.map c â»Â¹' {r} âˆ© { a | r â‰¤ f n a }) := by
      simp only [(eq _).symm]
    _ = âˆ‘ r âˆˆ (rs.map c).range, â¨† n, r * Î¼ (rs.map c â»Â¹' {r} âˆ© { a | r â‰¤ f n a }) :=
      (Finset.sum_congr rfl fun x _ => by
        rw [measure_iUnion_eq_iSup (mono x).directed_le, ENNReal.mul_iSup])
    _ = â¨† n, âˆ‘ r âˆˆ (rs.map c).range, r * Î¼ (rs.map c â»Â¹' {r} âˆ© { a | r â‰¤ f n a }) := by
      refine ENNReal.finset_sum_iSup_nat fun p i j h â†¦ ?_
      gcongr _ * Î¼ ?_
      exact mono p h
    _ â‰¤ â¨† n : â„•, ((rs.map c).restrict { a | (rs.map c) a â‰¤ f n a }).lintegral Î¼ := by
      gcongr with n
      rw [restrict_lintegral _ (h_meas n)]
      refine le_of_eq (Finset.sum_congr rfl fun r _ => ?_)
      congr 2 with a
      refine and_congr_right ?_
      simp (config := { contextual := true })
    _ â‰¤ â¨† n, âˆ«â» a, f n a âˆ‚Î¼ := by
      simp only [â† SimpleFunc.lintegral_eq_lintegral]
      gcongr with n a
      simp only [map_apply] at h_meas
      simp only [coe_map, restrict_apply _ (h_meas _), (Â· âˆ˜ Â·)]
      exact indicator_apply_le id",rw [lintegral_iSup]
Mathlib/Topology/GDelta.lean,IsMeagre.inter,IsMeagre.inter,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  hs.mono (inter_subset_left s t)","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set X : Type u_5
but is expected to have type
  ?m.17055 âˆˆ ?m.17053 âˆ© ?m.17054 : Prop",lemma IsMeagre.inter {s t : Set X} (hs : IsMeagre s) : IsMeagre (s âˆ© t) ,":=
  hs.mono inter_subset_left",rw [IsMeagre.isMeagre_inter_of_isMeagre_isMeagre hs]
Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean,Polynomial.trailingDegree_X_pow,trailingDegree_X_pow,cdc0a3ef94c657b081c8511e7c849dd9c6410512,":= by
  rw [X_pow_eq_monomial, trailingDegree_monomial _ one_ne_zero]","error:  function expected at
  trailingDegree_monomial ?m.52191
term has type
  ((monomial ?m.52189) ?m.52188).trailingDegree = â†‘?m.52189
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.52259
R : Type u
S : Type v
a b : R
nâœ m : â„•
instâœÂ¹ : Semiring R
instâœ : Nontrivial R
p q : R[X]
n : â„•
âŠ¢ ((monomial n) 1).trailingDegree = â†‘n","lemma trailingDegree_X_pow (n : â„•) :
    (X ^ n : R[X]).trailingDegree = n ",":= by
  rw [X_pow_eq_monomial, trailingDegree_monomial one_ne_zero]","rw [trailingDegree_X_pow, trailingDegree_X_pow]"
Mathlib/Topology/MetricSpace/GromovHausdorffRealized.lean,GromovHausdorff.HD_candidatesBDist_le,HD_candidatesBDist_le,8b6ad263031461bf3063a00d8b478305b08c18d2,":= by
  refine' max_le (ciSup_le fun x => _) (ciSup_le fun y => _)
  Â· have A : â¨… y, candidatesBDist X Y (inl x, inr y) â‰¤ candidatesBDist X Y (inl x, inr default) :=
      ciInf_le (by simpa using HD_below_aux1 0) default
    have B : dist (inl x) (inr default) â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=
      calc
        dist (inl x) (inr (default : Y)) = dist x (default : X) + 1 + dist default default := rfl
        _ â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) := by
          gcongr <;>
            exact dist_le_diam_of_mem bounded_of_compactSpace (mem_univ _) (mem_univ _)
    exact le_trans A B
  Â· have A : â¨… x, candidatesBDist X Y (inl x, inr y) â‰¤ candidatesBDist X Y (inl default, inr y) :=
      ciInf_le (by simpa using HD_below_aux2 0) default
    have B : dist (inl default) (inr y) â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=
      calc
        dist (inl (default : X)) (inr y) = dist default default + 1 + dist default y := rfl
        _ â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) := by
          gcongr <;>
            exact dist_le_diam_of_mem bounded_of_compactSpace (mem_univ _) (mem_univ _)
    exact le_trans A B","error:  unknown identifier 'bounded_of_compactSpace'
error:  unknown identifier 'bounded_of_compactSpace'
error:  unknown identifier 'bounded_of_compactSpace'
error:  unknown identifier 'bounded_of_compactSpace'","theorem HD_candidatesBDist_le :
    HD (candidatesBDist X Y) â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) ",":= by
  refine max_le (ciSup_le fun x => ?_) (ciSup_le fun y => ?_)
  Â· have A : â¨… y, candidatesBDist X Y (inl x, inr y) â‰¤ candidatesBDist X Y (inl x, inr default) :=
      ciInf_le (by simpa using HD_below_aux1 0) default
    have B : dist (inl x) (inr default) â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=
      calc
        dist (inl x) (inr (default : Y)) = dist x (default : X) + 1 + dist default default := rfl
        _ â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) := by
          gcongr <;>
            exact dist_le_diam_of_mem isBounded_of_compactSpace (mem_univ _) (mem_univ _)
    exact le_trans A B
  Â· have A : â¨… x, candidatesBDist X Y (inl x, inr y) â‰¤ candidatesBDist X Y (inl default, inr y) :=
      ciInf_le (by simpa using HD_below_aux2 0) default
    have B : dist (inl default) (inr y) â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) :=
      calc
        dist (inl (default : X)) (inr y) = dist default default + 1 + dist default y := rfl
        _ â‰¤ diam (univ : Set X) + 1 + diam (univ : Set Y) := by
          gcongr <;>
            exact dist_le_diam_of_mem isBounded_of_compactSpace (mem_univ _) (mem_univ _)
    exact le_trans A B","have HD_candidatesBDist_le : HD (candidatesBDist X Y) â‰¤ HD (candidatesBDist X Y) := by
  apply HD_candidatesBDist_le"
Mathlib/Algebra/Module/PID.lean,Module.equiv_directSum_of_isTorsion,equiv_directSum_of_isTorsion,47fc87162ec995bcfae0692666202132e8166728,":= by
  obtain âŸ¨I, fI, _, p, hp, e, hâŸ© := Submodule.exists_isInternal_prime_power_torsion_of_pid hN
  haveI := fI
  have :
    âˆ€ i,
      âˆƒ (d : â„•) (k : Fin d â†’ â„•),
        Nonempty <| torsionBy R N (p i ^ e i) â‰ƒâ‚—[R] â¨ j, R â§¸ R âˆ™ p i ^ k j := by
    haveI := isNoetherian_of_fg_of_noetherian' (Module.finite_def.mp h')
    haveI := fun i => isNoetherian_submodule' (torsionBy R N <| p i ^ e i)
    exact fun i =>
      torsion_by_prime_power_decomposition.{u, v} (hp i)
        ((isTorsion'_powers_iff <| p i).mpr fun x => âŸ¨e i, smul_torsionBy _ _âŸ©)
  classical
  refine'
    âŸ¨Î£ i, Fin (this i).choose, inferInstance, fun âŸ¨i, _âŸ© => p i, fun âŸ¨i, _âŸ© => hp i, fun âŸ¨i, jâŸ© =>
      (this i).choose_spec.choose j,
      âŸ¨(LinearEquiv.ofBijective (DirectSum.coeLinearMap _) h).symm.trans <|
          (Dfinsupp.mapRange.linearEquiv fun i => (this i).choose_spec.choose_spec.some).trans <|
            (DirectSum.sigmaLcurryEquiv R).symm.trans
              (Dfinsupp.mapRange.linearEquiv fun i => quotEquivOfEq _ _ _)âŸ©âŸ©
  cases' i with i j
  simp only","error:  unknown identifier 'isNoetherian_of_fg_of_noetherian''
error:  unknown identifier 'Dfinsupp.mapRange.linearEquiv'
error:  unknown identifier 'i'
error:  tactic 'induction' failed, major premise type is not an inductive type 
  ?m.260025
case intro.intro.intro.intro.intro.intro.refine'_1
R : Type u
instâœâ¶ : CommRing R
instâœâµ : IsDomain R
instâœâ´ : IsPrincipalIdealRing R
M : Type v
instâœÂ³ : AddCommGroup M
instâœÂ² : Module R M
N : Type (max u v)
instâœÂ¹ : AddCommGroup N
instâœ : Module R N
h' : Finite R N
hN : IsTorsion R N
I : Type u
fI : Fintype I
wâœ : DecidableEq I
p : I â†’ R
hp : âˆ€ (i : I), Irreducible (p i)
e : I â†’ â„•
h : DirectSum.IsInternal fun i â†¦ torsionBy R N (p i ^ e i)
thisâœ : Fintype I
this : âˆ€ (i : I), âˆƒ d k, Nonempty (â†¥(torsionBy R N (p i ^ e i)) â‰ƒâ‚—[R] â¨ (j : Fin d), R â§¸ span R {p i ^ k j})
xâœ : ?m.260025
âŠ¢ R â†’+* R","theorem equiv_directSum_of_isTorsion [h' : Module.Finite R N] (hN : Module.IsTorsion R N) :
    âˆƒ (Î¹ : Type u) (_ : Fintype Î¹) (p : Î¹ â†’ R) (_ : âˆ€ i, Irreducible <| p i) (e : Î¹ â†’ â„•),
      Nonempty <| N â‰ƒâ‚—[R] â¨ i : Î¹, R â§¸ R âˆ™ p i ^ e i ",":= by
  obtain âŸ¨I, fI, _, p, hp, e, hâŸ© := Submodule.exists_isInternal_prime_power_torsion_of_pid hN
  haveI := fI
  have :
    âˆ€ i,
      âˆƒ (d : â„•) (k : Fin d â†’ â„•),
        Nonempty <| torsionBy R N (p i ^ e i) â‰ƒâ‚—[R] â¨ j, R â§¸ R âˆ™ p i ^ k j := by
    haveI := fun i => isNoetherian_submodule' (torsionBy R N <| p i ^ e i)
    exact fun i =>
      torsion_by_prime_power_decomposition.{u, v} (hp i)
        ((isTorsion'_powers_iff <| p i).mpr fun x => âŸ¨e i, smul_torsionBy _ _âŸ©)
  classical
  refine
    âŸ¨Î£ i, Fin (this i).choose, inferInstance, fun âŸ¨i, _âŸ© => p i, fun âŸ¨i, _âŸ© => hp i, fun âŸ¨i, jâŸ© =>
      (this i).choose_spec.choose j,
      âŸ¨(LinearEquiv.ofBijective (DirectSum.coeLinearMap _) h).symm.trans <|
          (DFinsupp.mapRange.linearEquiv fun i => (this i).choose_spec.choose_spec.some).trans <|
            (DirectSum.sigmaLcurryEquiv R).symm.trans
              (DFinsupp.mapRange.linearEquiv fun i => quotEquivOfEq _ _ ?_)âŸ©âŸ©
  cases' i with i j
  simp only","refine âŸ¨equiv_directSum_of_isTorsion, equiv_directSum_of_isTorsion, ?_âŸ©"
Mathlib/Data/Option/NAry.lean,Option.mem_mapâ‚‚_iff,mem_mapâ‚‚_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  by simp [mapâ‚‚]","error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Î´ : Type u_4
f : Î± â†’ Î² â†’ Î³
a : Option Î±
b : Option Î²
câœ : Option Î³
c : Î³
âŠ¢ (a.bind fun a â†¦ Option.map (f a) b) = some c â†” âˆƒ a', a = some a' âˆ§ âˆƒ x, b = some x âˆ§ f a' x = c","theorem mem_mapâ‚‚_iff {c : Î³} : c âˆˆ mapâ‚‚ f a b â†” âˆƒ a' b', a' âˆˆ a âˆ§ b' âˆˆ b âˆ§ f a' b' = c ",":= by
  simp [mapâ‚‚, bind_eq_some]","simp only [mem_mapâ‚‚_iff, mem_mapâ‚‚_iff]"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine âŸ¨[], rfl.le, show Ï† = 1 from ?_âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      omega
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine' âŸ¨x::l, Nat.succ_le_succ hl, _âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâµ : _root_.RCLike ğ•œ
instâœâ´ : NormedAddCommGroup E
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : InnerProductSpace ğ•œ E
instâœÂ¹ : InnerProductSpace â„ F
K : Submodule ğ•œ E
instâœ : FiniteDimensional â„ F
Ï† : F â‰ƒâ‚—áµ¢[â„] F
hn :
  finrank â„
      â†¥(LinearMap.ker
            (ContinuousLinearMap.id â„ F -
              â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }))á—® â‰¤
    0
âŠ¢ LinearMap.ker
      (ContinuousLinearMap.id â„ F -
        â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }) =
    âŠ¤","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional â„ F] {n : â„•}
    (Ï† : F â‰ƒâ‚—áµ¢[â„] F) (hn : finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—® â‰¤ n) :
    âˆƒ l : List F, l.length â‰¤ n âˆ§ Ï† = (l.map fun v => reflection (â„ âˆ™ v)á—®).prod ",":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine âŸ¨[], rfl.le, show Ï† = 1 from ?_âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      omega
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine âŸ¨x::l, Nat.succ_le_succ hl, ?_âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this","refine âŸ¨finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—®, ?_, ?_âŸ©"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicOn.inv,inv,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  rcases hf with âŸ¨m, hfâŸ©
  by_cases h_eq : (fun z â†¦ (z - x) ^ m â€¢ f z) =á¶ [ğ“ x] 0
  Â· 
    refine (MeromorphicAt.const 0 x).congr ?_
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  Â· 
    obtain âŸ¨n, g, hg_an, hg_ne, hg_eqâŸ© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ğ•œ (fun z â†¦ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ğ•œ x).sub analyticAt_const).pow _
    refine âŸ¨n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_âŸ©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    Â· simp only [sub_self, pow_succ, zero_mul, zero_smul]
    Â· simp_rw [smul_eq_mul] at hfg âŠ¢
      have aux1 : f z â‰  0 := by
        have : (z - x) ^ n * g z â‰  0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [â† hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ, mul_assoc, hfg]
      ring","error:  unsolved goals
case h.inl
ğ•œ : Type u_1
instâœÂ² : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace ğ•œ E
f : ğ•œ â†’ ğ•œ
m n : â„•
g : ğ•œ â†’ ğ•œ
z : ğ•œ
hg_ne' : g z â‰  0
hf : AnalyticAt ğ•œ (fun z_1 â†¦ (z_1 - z) ^ m â€¢ f z_1) z
h_eq : Â¬(fun z_1 â†¦ (z_1 - z) ^ m â€¢ f z_1) =á¶ [ğ“ z] 0
hg_an : AnalyticAt ğ•œ g z
hg_ne : g z â‰  0
hg_eq : âˆ€á¶  (z_1 : ğ•œ) in ğ“ z, (z_1 - z) ^ m â€¢ f z_1 = (z_1 - z) ^ n â€¢ g z_1
this : AnalyticAt ğ•œ (fun z_1 â†¦ (z_1 - z) ^ (m + 1)) z
hfg : (z - z) ^ m â€¢ f z = (z - z) ^ n â€¢ g z
âŠ¢ (0 ^ m * 0) â€¢ (g z)â»Â¹ = (0 ^ n * 0) â€¢ fâ»Â¹ z
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (z - x) ^ m * f z
case h.inr
ğ•œ : Type u_1
instâœÂ² : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace ğ•œ E
f : ğ•œ â†’ ğ•œ
x : ğ•œ
m : â„•
hf : AnalyticAt ğ•œ (fun z â†¦ (z - x) ^ m â€¢ f z) x
h_eq : Â¬(fun z â†¦ (z - x) ^ m â€¢ f z) =á¶ [ğ“ x] 0
n : â„•
g : ğ•œ â†’ ğ•œ
hg_an : AnalyticAt ğ•œ g x
hg_ne : g x â‰  0
hg_eq : âˆ€á¶  (z : ğ•œ) in ğ“ x, (z - x) ^ m â€¢ f z = (z - x) ^ n â€¢ g z
this : AnalyticAt ğ•œ (fun z â†¦ (z - x) ^ (m + 1)) x
z : ğ•œ
hfg : (z - x) ^ m * f z = (z - x) ^ n * g z
hg_ne' : g z â‰  0
hz_ne : z â‰  x
aux1 : f z â‰  0
âŠ¢ (z - x) ^ m * ((z - x) * f z) = (z - x) ^ (n + 1) * g z",lemma inv {f : ğ•œ â†’ ğ•œ} {x : ğ•œ} (hf : MeromorphicAt f x) : MeromorphicAt fâ»Â¹ x ,":= by
  rcases hf with âŸ¨m, hfâŸ©
  by_cases h_eq : (fun z â†¦ (z - x) ^ m â€¢ f z) =á¶ [ğ“ x] 0
  Â· 
    refine (MeromorphicAt.const 0 x).congr ?_
    rw [eventuallyEq_nhdsWithin_iff]
    filter_upwards [h_eq] with z hfz hz
    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,
      inv_zero]
  Â· 
    obtain âŸ¨n, g, hg_an, hg_ne, hg_eqâŸ© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq
    have : AnalyticAt ğ•œ (fun z â†¦ (z - x) ^ (m + 1)) x :=
      ((analyticAt_id ğ•œ x).sub analyticAt_const).pow _
    refine âŸ¨n + 1, (this.smul <| hg_an.inv hg_ne).congr ?_âŸ©
    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'
    rcases eq_or_ne z x with rfl | hz_ne
    Â· simp only [sub_self, pow_succ, mul_zero, zero_smul]
    Â· simp_rw [smul_eq_mul] at hfg âŠ¢
      have aux1 : f z â‰  0 := by
        have : (z - x) ^ n * g z â‰  0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'
        rw [â† hfg, mul_ne_zero_iff] at this
        exact this.2
      field_simp [sub_ne_zero.mpr hz_ne]
      rw [pow_succ', mul_assoc, hfg]
      ring",simp [MeromorphicAt]
Mathlib/CategoryTheory/Preadditive/Schur.lean,CategoryTheory.finrank_hom_simple_simple,finrank_hom_simple_simple,18b64d3b01560f3af84d7ae915a9f4830f705b5d,":=
  haveI :=
    subsingleton_of_forall_eq (0 : X âŸ¶ Y) fun f => by
      have p := not_congr (isIso_iff_nonzero f)
      simp only [Classical.not_not, Ne.def] at p
      refine' p.mp fun _ => h (asIso f)
  finrank_zero_of_subsingleton","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.8834 â†’ ?m.8834 â†’ Prop","theorem finrank_hom_simple_simple_eq_zero_of_not_iso [HasKernels C] [Linear ğ•œ C] {X Y : C}
    [Simple X] [Simple Y] (h : (X â‰… Y) â†’ False) : finrank ğ•œ (X âŸ¶ Y) = 0 ",":=
  haveI :=
    subsingleton_of_forall_eq (0 : X âŸ¶ Y) fun f => by
      have p := not_congr (isIso_iff_nonzero f)
      simp only [Classical.not_not, Ne] at p
      exact p.mp fun _ => h (asIso f)
  finrank_zero_of_subsingleton","rw [finrank_hom_simple_eq_zero_of_not_iso, finrank_hom_simple_eq_zero_of_not_iso]"
Mathlib/SetTheory/Ordinal/Topology.lean,Ordinal.mem_closure_tfae,mem_closure_tfae,738b1a97e85d528d395f215b4057bad4704e2ceb,":= by
  tfae_have 1 â†’ 2
  Â· simp only [mem_closure_iff_nhdsWithin_neBot, inter_comm s, nhdsWithin_inter', nhds_left_eq_nhds]
    exact id
  tfae_have 2 â†’ 3
  Â· intro h
    cases' (s âˆ© Iic a).eq_empty_or_nonempty with he hne
    Â· simp [he] at h
    Â· refine âŸ¨hne, (isLUB_of_mem_closure ?_ h).csSup_eq hneâŸ©
      exact fun x hx => hx.2
  tfae_have 3 â†’ 4
  Â· exact fun h => âŸ¨_, inter_subset_left _ _, h.1, bddAbove_Iic.mono (inter_subset_right _ _), h.2âŸ©
  tfae_have 4 â†’ 5
  Â· rintro âŸ¨t, hts, hne, hbdd, rflâŸ©
    have hlub : IsLUB t (sSup t) := isLUB_csSup hne hbdd
    let âŸ¨y, hytâŸ© := hne
    classical
      refine âŸ¨succ (sSup t), succ_ne_zero _, fun x _ => if x âˆˆ t then x else y, fun x _ => ?_, ?_âŸ©
      Â· simp only
        split_ifs with h <;> exact hts â€¹_â€º
      Â· refine le_antisymm (bsup_le fun x _ => ?_) (csSup_le hne fun x hx => ?_)
        Â· split_ifs <;> exact hlub.1 â€¹_â€º
        Â· refine (if_pos hx).symm.trans_le (le_bsup _ _ <| (hlub.1 hx).trans_lt (lt_succ _))
  tfae_have 5 â†’ 6
  Â· rintro âŸ¨o, hâ‚€, f, hfs, rflâŸ©
    exact âŸ¨_, out_nonempty_iff_ne_zero.2 hâ‚€, familyOfBFamily o f, fun _ => hfs _ _, rflâŸ©
  tfae_have 6 â†’ 1
  Â· rintro âŸ¨Î¹, hne, f, hfs, rflâŸ©
    rw [sup, iSup]
    exact closure_mono (range_subset_iff.2 hfs) <| csSup_mem_closure (range_nonempty f)
      (bddAbove_range.{u, u} f)
  tfae_finish","error:  overloaded, errors 
  function expected at
    Set.inter_subset_left ?m.7637
  term has type
    ?m.7636 âˆˆ ?m.7634
  
  function expected at
    List.inter_subset_left ?m.7679
  term has type
    ?m.7678 âˆˆ ?m.7676
error:  overloaded, errors 
  function expected at
    Set.inter_subset_right ?m.7891
  term has type
    ?m.7890 âˆˆ ?m.7889
  
  function expected at
    List.inter_subset_right ?m.7963
  term has type
    ?m.7962 âˆˆ ?m.7961","theorem mem_closure_tfae (a : Ordinal.{u}) (s : Set Ordinal) :
    TFAE [a âˆˆ closure s,
      a âˆˆ closure (s âˆ© Iic a),
      (s âˆ© Iic a).Nonempty âˆ§ sSup (s âˆ© Iic a) = a,
      âˆƒ t, t âŠ† s âˆ§ t.Nonempty âˆ§ BddAbove t âˆ§ sSup t = a,
      âˆƒ (o : Ordinal.{u}), o â‰  0 âˆ§ âˆƒ (f : âˆ€ x < o, Ordinal),
        (âˆ€ x hx, f x hx âˆˆ s) âˆ§ bsup.{u, u} o f = a,
      âˆƒ (Î¹ : Type u), Nonempty Î¹ âˆ§ âˆƒ f : Î¹ â†’ Ordinal, (âˆ€ i, f i âˆˆ s) âˆ§ sup.{u, u} f = a] ",":= by
  tfae_have 1 â†’ 2
  Â· simp only [mem_closure_iff_nhdsWithin_neBot, inter_comm s, nhdsWithin_inter', nhds_left_eq_nhds]
    exact id
  tfae_have 2 â†’ 3
  Â· intro h
    rcases (s âˆ© Iic a).eq_empty_or_nonempty with he | hne
    Â· simp [he] at h
    Â· refine âŸ¨hne, (isLUB_of_mem_closure ?_ h).csSup_eq hneâŸ©
      exact fun x hx => hx.2
  tfae_have 3 â†’ 4
  Â· exact fun h => âŸ¨_, inter_subset_left, h.1, bddAbove_Iic.mono inter_subset_right, h.2âŸ©
  tfae_have 4 â†’ 5
  Â· rintro âŸ¨t, hts, hne, hbdd, rflâŸ©
    have hlub : IsLUB t (sSup t) := isLUB_csSup hne hbdd
    let âŸ¨y, hytâŸ© := hne
    classical
      refine âŸ¨succ (sSup t), succ_ne_zero _, fun x _ => if x âˆˆ t then x else y, fun x _ => ?_, ?_âŸ©
      Â· simp only
        split_ifs with h <;> exact hts â€¹_â€º
      Â· refine le_antisymm (bsup_le fun x _ => ?_) (csSup_le hne fun x hx => ?_)
        Â· split_ifs <;> exact hlub.1 â€¹_â€º
        Â· refine (if_pos hx).symm.trans_le (le_bsup _ _ <| (hlub.1 hx).trans_lt (lt_succ _))
  tfae_have 5 â†’ 6
  Â· rintro âŸ¨o, hâ‚€, f, hfs, rflâŸ©
    exact âŸ¨_, out_nonempty_iff_ne_zero.2 hâ‚€, familyOfBFamily o f, fun _ => hfs _ _, rflâŸ©
  tfae_have 6 â†’ 1
  Â· rintro âŸ¨Î¹, hne, f, hfs, rflâŸ©
    rw [sup, iSup]
    exact closure_mono (range_subset_iff.2 hfs) <| csSup_mem_closure (range_nonempty f)
      (bddAbove_range.{u, u} f)
  tfae_finish",refine theorem_theorem mem_closure_tfae (a := Ordinal) s ?_ ?_ ?_
Mathlib/Topology/LocalAtTarget.lean,inducing_iff_inducing_of_iSup_eq_top,inducing_iff_inducing_of_iSup_eq_top,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp_rw [inducing_subtype_val.inducing_iff, inducing_iff_nhds, restrictPreimage,
    MapsTo.coe_restrict, restrict_eq, â† @Filter.comap_comap _ _ _ _ _ f]
  constructor
  Â· intro H i x
    rw [Function.comp_apply, â† H, â† inducing_subtype_val.nhds_eq_comap]
  Â· intro H x
    obtain âŸ¨i, hiâŸ© :=
      Opens.mem_iSup.mp
        (show f x âˆˆ iSup U by
          rw [hU]
          trivial)
    erw [â† OpenEmbedding.map_nhds_eq (h.1 _ (U i).2).openEmbedding_subtype_val âŸ¨x, hiâŸ©]
    rw [(H i) âŸ¨x, hiâŸ©, Filter.subtype_coe_map_comap, Function.comp_apply, Subtype.coe_mk,
      inf_eq_left, Filter.le_principal_iff]
    exact Filter.preimage_mem_comap ((U i).2.mem_nhds hi)","error:  invalid field 'inducing_iff', the environment does not contain 'Inducing.inducing_iff'
  inducing_subtype_val
has type
  Inducing Subtype.val
error:  simp made no progress
warning:  Used `tac1 <;> tac2` where `(tac1; tac2)` would suffice
note: this linter can be disabled with `set_option linter.unnecessarySeqFocus false`","theorem inducing_iff_inducing_of_iSup_eq_top (h : Continuous f) :
    Inducing f â†” âˆ€ i, Inducing ((U i).1.restrictPreimage f) ",":= by
  simp_rw [â† inducing_subtype_val.of_comp_iff, inducing_iff_nhds, restrictPreimage,
    MapsTo.coe_restrict, restrict_eq, â† @Filter.comap_comap _ _ _ _ _ f]
  constructor
  Â· intro H i x
    rw [Function.comp_apply, â† H, â† inducing_subtype_val.nhds_eq_comap]
  Â· intro H x
    obtain âŸ¨i, hiâŸ© :=
      Opens.mem_iSup.mp
        (show f x âˆˆ iSup U by
          rw [hU]
          trivial)
    erw [â† OpenEmbedding.map_nhds_eq (h.1 _ (U i).2).openEmbedding_subtype_val âŸ¨x, hiâŸ©]
    rw [(H i) âŸ¨x, hiâŸ©, Filter.subtype_coe_map_comap, Function.comp_apply, Subtype.coe_mk,
      inf_eq_left, Filter.le_principal_iff]
    exact Filter.preimage_mem_comap ((U i).2.mem_nhds hi)","refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©"
Mathlib/Data/ENNReal/Real.lean,ENNReal.ofReal_eq_one,ofReal_eq_one,0ca7fa3d58ef5029c63bb66806c6e04f2db23cef,":=
  ENNReal.coe_eq_coe.trans Real.toNNReal_eq_one",error:  unknown constant 'ENNReal.coe_eq_coe.trans',lemma ofReal_eq_one {r : â„} : ENNReal.ofReal r = 1 â†” r = 1 ,":=
  ENNReal.coe_inj.trans Real.toNNReal_eq_one","rw [â† ENNReal.ofReal_eq_one_iff, ENNReal.ofReal_eq_one_iff]"
Mathlib/Analysis/InnerProductSpace/Basic.lean,norm_add_mul_self,norm_add_mul_self,cfaaf51b1223a931e15d15067bb0c504c1943ffc,":= by
  repeat' rw [â† sq (M := â„)]
  exact norm_add_sq _ _ _","error:  function expected at
  norm_add_sq ?m.370775 ?m.370776
term has type
  â€–?m.370775 + ?m.370776â€– ^ 2 = â€–?m.370775â€– ^ 2 + 2 * re âŸª?m.370775, ?m.370776âŸ«_?m.370770 + â€–?m.370776â€– ^ 2","theorem norm_add_mul_self (x y : E) :
    â€–x + yâ€– * â€–x + yâ€– = â€–xâ€– * â€–xâ€– + 2 * re âŸªx, yâŸ« + â€–yâ€– * â€–yâ€– ",":= by
  repeat' rw [â† sq (M := â„)]
  exact norm_add_sq _ _","rw [theorem_theorem, norm_add_mul_self, norm_self, â† norm_add_mul_self, â† norm_add_mul_self]"
Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean,CategoryTheory.comp_rightAdjointMate,comp_rightAdjointMate,fc2d8a7fd4fce039a4cdee894cdb15ac1920b96c,":= by
  rw [rightAdjointMate_comp]
  simp only [rightAdjointMate, comp_tensor_id, Iso.cancel_iso_inv_left, id_tensor_comp,
    Category.assoc]
  symm
  iterate 5
    trans
    rw [â† Category.id_comp g, tensor_comp]
  rw [â† Category.assoc]
  symm
  iterate 2
    trans
    rw [â† Category.assoc]
  apply eq_whisker
  repeat'
    rw [â† @id_tensor_comp C]
  congr 1
  rw [â† id_tensor_comp_tensor_id (Î»_ (Xá˜)).hom g, id_tensor_rightUnitor_inv, Category.assoc,
    Category.assoc, rightUnitor_inv_naturality_assoc, â† associator_naturality_assoc, tensor_id,
    tensor_id_comp_id_tensor_assoc, â† associator_naturality_assoc]
  slice_rhs 2 3 =>
    rw [â† tensor_comp, tensor_id, Category.comp_id, â† Category.id_comp (Î·_ Y (Yá˜)), tensor_comp]
  rw [â† id_tensor_comp_tensor_id _ (Î·_ Y (Yá˜)), â† tensor_id]
  repeat' rw [@Category.assoc C]
  rw [pentagon_hom_inv_assoc, â† associator_naturality_assoc, associator_inv_naturality_assoc]
  slice_rhs 5 7 => rw [â† comp_tensor_id, â† comp_tensor_id, evaluation_coevaluation, comp_tensor_id]
  rw [associator_inv_naturality_assoc]
  slice_rhs 4 5 => rw [â† tensor_comp, leftUnitor_naturality, tensor_comp]
  repeat' rw [@Category.assoc C]
  rw [triangle_assoc_comp_right_inv_assoc, â† leftUnitor_tensor_assoc, leftUnitor_naturality_assoc,
    unitors_equal, â† Category.assoc, â† Category.assoc]
  simp","warning:  @coevaluation does not have a doc string
warning:  @evaluation does not have a doc string
warning:  @leftDual does not have a doc string
warning:  @rightDual does not have a doc string
warning:  @rightAdjointMate does not have a doc string
warning:  @leftAdjointMate does not have a doc string
error:  tactic 'apply' failed, failed to unify
  ?f â‰« ?h = ?g â‰« ?h
with
  ((Zá˜ â— Î·_ X Xá˜ â‰« Zá˜ â— (f â‰« g) â–· Xá˜) â‰« (Î±_ Zá˜ Z Xá˜).inv) â‰« Îµ_ Z Zá˜ â–· Xá˜ â‰« (Î»_ Xá˜).hom =
    (Zá˜ â— Î·_ Y Yá˜ â‰«
        Zá˜ â—
          ((ğŸ™ Y âŠ— (Ï_ Yá˜).inv) â‰«
            (ğŸ™ Y âŠ— Yá˜ â— Î·_ X Xá˜) â‰«
              (ğŸ™ Y âŠ— Yá˜ â— f â–· Xá˜) â‰« (ğŸ™ Y âŠ— (Î±_ Yá˜ Y Xá˜).inv) â‰« (ğŸ™ Y âŠ— Îµ_ Y Yá˜ â–· Xá˜) â‰« (g âŠ— (Î»_ Xá˜).hom))) â‰«
      (Î±_ Zá˜ Z Xá˜).inv â‰« Îµ_ Z Zá˜ â–· Xá˜ â‰« (Î»_ Xá˜).hom
C : Type uâ‚
instâœâ´ : Category.{vâ‚, uâ‚} C
instâœÂ³ : MonoidalCategory C
X Y Z : C
instâœÂ² : HasRightDual X
instâœÂ¹ : HasRightDual Y
instâœ : HasRightDual Z
f : X âŸ¶ Y
g : Y âŸ¶ Z
âŠ¢ ((Zá˜ â— Î·_ X Xá˜ â‰« Zá˜ â— (f â‰« g) â–· Xá˜) â‰« (Î±_ Zá˜ Z Xá˜).inv) â‰« Îµ_ Z Zá˜ â–· Xá˜ â‰« (Î»_ Xá˜).hom =
    (Zá˜ â— Î·_ Y Yá˜ â‰«
        Zá˜ â—
          ((ğŸ™ Y âŠ— (Ï_ Yá˜).inv) â‰«
            (ğŸ™ Y âŠ— Yá˜ â— Î·_ X Xá˜) â‰«
              (ğŸ™ Y âŠ— Yá˜ â— f â–· Xá˜) â‰« (ğŸ™ Y âŠ— (Î±_ Yá˜ Y Xá˜).inv) â‰« (ğŸ™ Y âŠ— Îµ_ Y Yá˜ â–· Xá˜) â‰« (g âŠ— (Î»_ Xá˜).hom))) â‰«
      (Î±_ Zá˜ Z Xá˜).inv â‰« Îµ_ Z Zá˜ â–· Xá˜ â‰« (Î»_ Xá˜).hom","theorem comp_rightAdjointMate {X Y Z : C} [HasRightDual X] [HasRightDual Y] [HasRightDual Z]
    {f : X âŸ¶ Y} {g : Y âŸ¶ Z} : (f â‰« g)á˜ = gá˜ â‰« fá˜ ",":= by
  rw [rightAdjointMate_comp]
  simp only [rightAdjointMate, comp_whiskerRight]
  simp only [â† Category.assoc]; congr 3; simp only [Category.assoc]
  simp only [â† MonoidalCategory.whiskerLeft_comp]; congr 2
  symm
  calc
    _ = ğŸ™ _ âŠ—â‰« (Î·_ Y Yá˜ â–· ğŸ™_ C â‰« (Y âŠ— Yá˜) â— Î·_ X Xá˜) âŠ—â‰« Y â— Yá˜ â— f â–· Xá˜ âŠ—â‰«
        Y â— Îµ_ Y Yá˜ â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by
      rw [tensorHom_def']; coherence
    _ = Î·_ X Xá˜ âŠ—â‰« (Î·_ Y Yá˜ â–· (X âŠ— Xá˜) â‰« (Y âŠ— Yá˜) â— f â–· Xá˜) âŠ—â‰«
        Y â— Îµ_ Y Yá˜ â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by
      rw [â† whisker_exchange]; coherence
    _ = Î·_ X Xá˜ âŠ—â‰« f â–· Xá˜ âŠ—â‰« (Î·_ Y Yá˜ â–· Y âŠ—â‰« Y â— Îµ_ Y Yá˜) â–· Xá˜ âŠ—â‰« g â–· Xá˜ âŠ—â‰« ğŸ™ _ := by
      rw [â† whisker_exchange]; coherence
    _ = Î·_ X Xá˜ â‰« f â–· Xá˜ â‰« g â–· Xá˜ := by
      rw [evaluation_coevaluation'']; coherence","simp [rightAdjointMate, rightAdjointMate]"
Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean,gramSchmidt_orthogonal,gramSchmidt_orthogonal,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  suffices âˆ€ a b : Î¹, a < b â†’ âŸªgramSchmidt ğ•œ f a, gramSchmidt ğ•œ f bâŸ« = 0 by
    cases' hâ‚€.lt_or_lt with ha hb
    Â· exact this _ _ ha
    Â· rw [inner_eq_zero_symm]
      exact this _ _ hb
  clear hâ‚€ a b
  intro a b hâ‚€
  revert a
  apply wellFounded_lt.induction b
  intro b ih a hâ‚€
  simp only [gramSchmidt_def ğ•œ f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr hâ‚€)]
  Â· by_cases h : gramSchmidt ğ•œ f a = 0
    Â· simp only [h, inner_zero_left, zero_div, zero_mul, sub_zero]
    Â· rw [IsROrC.ofReal_pow, â† inner_self_eq_norm_sq_to_K, div_mul_cancel, sub_self]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hiaâ‚ hiaâ‚‚
  Â· rw [inner_eq_zero_symm]
    exact ih a hâ‚€ i hiaâ‚
  Â· exact ih i (mem_Iio.1 hi) a hiaâ‚‚","error:  unknown identifier 'IsROrC.ofReal_pow'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.51260
case neg
ğ•œ : Type u_1
E : Type u_2
instâœâµ : RCLike ğ•œ
instâœâ´ : NormedAddCommGroup E
instâœÂ³ : InnerProductSpace ğ•œ E
Î¹ : Type u_3
instâœÂ² : LinearOrder Î¹
instâœÂ¹ : LocallyFiniteOrderBot Î¹
instâœ : IsWellOrder Î¹ fun x x_1 â†¦ x < x_1
f : Î¹ â†’ E
bâœ b : Î¹
ih : âˆ€ y < b, âˆ€ a < y, âŸªgramSchmidt ğ•œ f a, gramSchmidt ğ•œ f yâŸ«_ğ•œ = 0
a : Î¹
hâ‚€ : a < b
h : Â¬gramSchmidt ğ•œ f a = 0
âŠ¢ âŸªgramSchmidt ğ•œ f a, f bâŸ«_ğ•œ -
      âŸªgramSchmidt ğ•œ f a, f bâŸ«_ğ•œ / â†‘(â€–gramSchmidt ğ•œ f aâ€– ^ 2) * âŸªgramSchmidt ğ•œ f a, gramSchmidt ğ•œ f aâŸ«_ğ•œ =
    0","theorem gramSchmidt_orthogonal (f : Î¹ â†’ E) {a b : Î¹} (hâ‚€ : a â‰  b) :
    âŸªgramSchmidt ğ•œ f a, gramSchmidt ğ•œ f bâŸ« = 0 ",":= by
  suffices âˆ€ a b : Î¹, a < b â†’ âŸªgramSchmidt ğ•œ f a, gramSchmidt ğ•œ f bâŸ« = 0 by
    cases' hâ‚€.lt_or_lt with ha hb
    Â· exact this _ _ ha
    Â· rw [inner_eq_zero_symm]
      exact this _ _ hb
  clear hâ‚€ a b
  intro a b hâ‚€
  revert a
  apply wellFounded_lt.induction b
  intro b ih a hâ‚€
  simp only [gramSchmidt_def ğ•œ f b, inner_sub_right, inner_sum, orthogonalProjection_singleton,
    inner_smul_right]
  rw [Finset.sum_eq_single_of_mem a (Finset.mem_Iio.mpr hâ‚€)]
  Â· by_cases h : gramSchmidt ğ•œ f a = 0
    Â· simp only [h, inner_zero_left, zero_div, zero_mul, sub_zero]
    Â· rw [RCLike.ofReal_pow, â† inner_self_eq_norm_sq_to_K, div_mul_cancelâ‚€, sub_self]
      rwa [inner_self_ne_zero]
  intro i hi hia
  simp only [mul_eq_zero, div_eq_zero_iff, inner_self_eq_zero]
  right
  cases' hia.lt_or_lt with hiaâ‚ hiaâ‚‚
  Â· rw [inner_eq_zero_symm]
    exact ih a hâ‚€ i hiaâ‚
  Â· exact ih i (mem_Iio.1 hi) a hiaâ‚‚","have hâ‚ : âŸªgramSchmidt ğ•œ f a, gramSchmidt ğ•œ f bâŸ«âŸ« â‰  0 := by
  rw [â† inner_eq_zero_of_inner_eq_zero gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal, gramSchmidt_orthogonal,
    gramSchmidt_orthogonal]
  rfl"
Mathlib/MeasureTheory/Constructions/Prod/Integral.lean,MeasureTheory.continuous_integral_integral,continuous_integral_integral,9b5d788d575748c82ffdfc08ef4aaf0a3c6023f0,":= by
  rw [continuous_iff_continuousAt]; intro g
  refine
    tendsto_integral_of_L1 _ (L1.integrable_coeFn g).integral_prod_left
      (eventually_of_forall fun h => (L1.integrable_coeFn h).integral_prod_left) ?_
  simp_rw [â†
    lintegral_fn_integral_sub (fun x => (â€–xâ€–â‚Š : â„â‰¥0âˆ)) (L1.integrable_coeFn _)
      (L1.integrable_coeFn g)]
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds ?_ (fun i => zero_le _) ?_
  Â· exact fun i => âˆ«â» x, âˆ«â» y, â€–i (x, y) - g (x, y)â€–â‚Š âˆ‚Î½ âˆ‚Î¼
  swap; Â· exact fun i => lintegral_mono fun x => ennnorm_integral_le_lintegral_ennnorm _
  show
    Tendsto (fun i : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E => âˆ«â» x, âˆ«â» y : Î², â€–i (x, y) - g (x, y)â€–â‚Š âˆ‚Î½ âˆ‚Î¼) (ğ“ g)
      (ğ“ 0)
  have : âˆ€ i : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E, Measurable fun z => (â€–i z - g zâ€–â‚Š : â„â‰¥0âˆ) := fun i =>
    ((Lp.stronglyMeasurable i).sub (Lp.stronglyMeasurable g)).ennnorm
  conv =>
    congr
    ext
    rw [â† lintegral_prod_of_measurable _ (this _), â† L1.ofReal_norm_sub_eq_lintegral]
  rw [â† ofReal_zero]
  refine (continuous_ofReal.tendsto 0).comp ?_
  rw [â† tendsto_iff_norm_sub_tendsto_zero]; exact tendsto_id","error:  don't know how to synthesize implicit argument 'h'
  @tendsto_of_tendsto_of_tendsto_of_le_of_le â„â‰¥0âˆ (â†¥(Lp E 1 (Î¼.prod Î½))) ENNReal.instTopologicalSpace
    PartialOrder.toPreorder instOrderTopology (fun i â†¦ âˆ«â» (x : Î±), â†‘â€–âˆ« (y : Î²), â†‘â†‘i (x, y) - â†‘â†‘g (x, y) âˆ‚Î½â€–â‚Š âˆ‚Î¼)
    (fun x â†¦ 0) ?m.113248 (ğ“ g) 0 tendsto_const_nhds ?m.113460
    (fun i â†¦ zero_le (âˆ«â» (x : Î±), â†‘â€–âˆ« (y : Î²), â†‘â†‘i (x, y) - â†‘â†‘g (x, y) âˆ‚Î½â€–â‚Š âˆ‚Î¼)) ?m.113571
context:
Î± : Type u_1
Î±' : Type u_2
Î² : Type u_3
Î²' : Type u_4
Î³ : Type u_5
E : Type u_6
instâœÂ¹â° : MeasurableSpace Î±
instâœâ¹ : MeasurableSpace Î±'
instâœâ¸ : MeasurableSpace Î²
instâœâ· : MeasurableSpace Î²'
instâœâ¶ : MeasurableSpace Î³
Î¼ Î¼' : Measure Î±
Î½ Î½' : Measure Î²
Ï„ : Measure Î³
instâœâµ : NormedAddCommGroup E
instâœâ´ : SigmaFinite Î½
instâœÂ³ : NormedSpace â„ E
instâœÂ² : SigmaFinite Î¼
E' : Type u_7
instâœÂ¹ : NormedAddCommGroup E'
instâœ : NormedSpace â„ E'
g : â†¥(Lp E 1 (Î¼.prod Î½))
âŠ¢ â†¥(Lp E 1 (Î¼.prod Î½)) â†’ â„â‰¥0âˆ
error:  unsolved goals
Î± : Type u_1
Î±' : Type u_2
Î² : Type u_3
Î²' : Type u_4
Î³ : Type u_5
E : Type u_6
instâœÂ¹â° : MeasurableSpace Î±
instâœâ¹ : MeasurableSpace Î±'
instâœâ¸ : MeasurableSpace Î²
instâœâ· : MeasurableSpace Î²'
instâœâ¶ : MeasurableSpace Î³
Î¼ Î¼' : Measure Î±
Î½ Î½' : Measure Î²
Ï„ : Measure Î³
instâœâµ : NormedAddCommGroup E
instâœâ´ : SigmaFinite Î½
instâœÂ³ : NormedSpace â„ E
instâœÂ² : SigmaFinite Î¼
E' : Type u_7
instâœÂ¹ : NormedAddCommGroup E'
instâœ : NormedSpace â„ E'
g : â†¥(Lp E 1 (Î¼.prod Î½))
âŠ¢ Tendsto (fun i â†¦ âˆ«â» (x : Î±), â†‘â€–âˆ« (y : Î²), â†‘â†‘i (x, y) - â†‘â†‘g (x, y) âˆ‚Î½â€–â‚Š âˆ‚Î¼) (ğ“ g) (ğ“ 0)","theorem continuous_integral_integral :
    Continuous fun f : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E => âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼ ",":= by
  rw [continuous_iff_continuousAt]; intro g
  refine
    tendsto_integral_of_L1 _ (L1.integrable_coeFn g).integral_prod_left
      (eventually_of_forall fun h => (L1.integrable_coeFn h).integral_prod_left) ?_
  simp_rw [â†
    lintegral_fn_integral_sub (fun x => (â€–xâ€–â‚Š : â„â‰¥0âˆ)) (L1.integrable_coeFn _)
      (L1.integrable_coeFn g)]
  apply tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds _ (fun i => zero_le _) _
  Â· exact fun i => âˆ«â» x, âˆ«â» y, â€–i (x, y) - g (x, y)â€–â‚Š âˆ‚Î½ âˆ‚Î¼
  swap; Â· exact fun i => lintegral_mono fun x => ennnorm_integral_le_lintegral_ennnorm _
  show
    Tendsto (fun i : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E => âˆ«â» x, âˆ«â» y : Î², â€–i (x, y) - g (x, y)â€–â‚Š âˆ‚Î½ âˆ‚Î¼) (ğ“ g)
      (ğ“ 0)
  have : âˆ€ i : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E, Measurable fun z => (â€–i z - g zâ€–â‚Š : â„â‰¥0âˆ) := fun i =>
    ((Lp.stronglyMeasurable i).sub (Lp.stronglyMeasurable g)).ennnorm
  conv =>
    congr
    ext
    rw [â† lintegral_prod_of_measurable _ (this _), â† L1.ofReal_norm_sub_eq_lintegral]
  rw [â† ofReal_zero]
  refine (continuous_ofReal.tendsto 0).comp ?_
  rw [â† tendsto_iff_norm_sub_tendsto_zero]; exact tendsto_id",refine theorem_continuous_integral_integral_integral continuous_integral_integral_theorem
Mathlib/RingTheory/FiniteType.lean,AddMonoidAlgebra.freeAlgebra_lift_of_surjective_of_closure,freeAlgebra_lift_of_surjective_of_closure,5fb9beab28702fb284701d494bc9b7c5f52fef53,":= by
  intro f
  induction' f using induction_on with m f g ihf ihg r f ih
  Â· have : m âˆˆ closure S := hS.symm â–¸ mem_top _
    refine' closure_induction this (fun m hm => _) _ _
    Â· exact âŸ¨FreeAlgebra.Î¹ R âŸ¨m, hmâŸ©, FreeAlgebra.lift_Î¹_apply _ _âŸ©
    Â· exact âŸ¨1, AlgHom.map_one _âŸ©
    Â· rintro mâ‚ mâ‚‚ âŸ¨Pâ‚, hPâ‚âŸ© âŸ¨Pâ‚‚, hPâ‚‚âŸ©
      exact
        âŸ¨Pâ‚ * Pâ‚‚, by
          rw [AlgHom.map_mul, hPâ‚, hPâ‚‚, of_apply, of_apply, of_apply, single_mul_single,
            one_mul]; rflâŸ©
  Â· rcases ihf with âŸ¨P, rflâŸ©
    rcases ihg with âŸ¨Q, rflâŸ©
    exact âŸ¨P + Q, AlgHom.map_add _ _ _âŸ©
  Â· rcases ih with âŸ¨P, rflâŸ©
    exact âŸ¨r â€¢ P, AlgHom.map_smul _ _ _âŸ©","error:  ambiguous, possible interpretations 
  Submodule.closure_induction ?m.110689 ?m.110690 ?m.110691
    ?m.110692 : âˆƒ a, ((FreeAlgebra.lift R) fun s â†¦ of' R M â†‘s) a = (of R M) (Multiplicative.ofAdd m)
  
  AddSubmonoid.closure_induction this ?m.111012 ?m.111013
    ?m.111014 : âˆƒ a, ((FreeAlgebra.lift R) fun s â†¦ of' R M â†‘s) a = (of R M) (Multiplicative.ofAdd m)
error:  no goals to be solved","theorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}
    (hS : closure S = âŠ¤) :
    Function.Surjective
      (FreeAlgebra.lift R fun s : S => of' R M â†‘s : FreeAlgebra R S â†’ R[M]) ",":= by
  intro f
  induction' f using induction_on with m f g ihf ihg r f ih
  Â· have : m âˆˆ closure S := hS.symm â–¸ mem_top _
    refine AddSubmonoid.closure_induction this (fun m hm => ?_) ?_ ?_
    Â· exact âŸ¨FreeAlgebra.Î¹ R âŸ¨m, hmâŸ©, FreeAlgebra.lift_Î¹_apply _ _âŸ©
    Â· exact âŸ¨1, AlgHom.map_one _âŸ©
    Â· rintro mâ‚ mâ‚‚ âŸ¨Pâ‚, hPâ‚âŸ© âŸ¨Pâ‚‚, hPâ‚‚âŸ©
      exact
        âŸ¨Pâ‚ * Pâ‚‚, by
          rw [AlgHom.map_mul, hPâ‚, hPâ‚‚, of_apply, of_apply, of_apply, single_mul_single,
            one_mul]; rflâŸ©
  Â· rcases ihf with âŸ¨P, rflâŸ©
    rcases ihg with âŸ¨Q, rflâŸ©
    exact âŸ¨P + Q, AlgHom.map_add _ _ _âŸ©
  Â· rcases ih with âŸ¨P, rflâŸ©
    exact âŸ¨r â€¢ P, AlgHom.map_smul _ _ _âŸ©",apply FreeAlgebra.lift_surjective_of_surjective
Mathlib/NumberTheory/FermatPsp.lean,Nat.exists_infinite_pseudoprimes,exists_infinite_pseudoprimes,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  by_cases b_ge_two : 2 â‰¤ b
  Â· have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hpâ‚ hpâ‚‚
    have hâ‚ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have hâ‚‚ : 4 â‰¤ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have hâ‚ƒ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt hâ‚‚ (by norm_num))
    have hâ‚„ : 0 < b * (b ^ 2 - 1) := mul_pos hâ‚ hâ‚ƒ
    have hâ‚… : b * (b ^ 2 - 1) < p := by linarith
    have hâ‚† : Â¬p âˆ£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt hâ‚„ hâ‚…
    have hâ‚‡ : b â‰¤ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right hâ‚ƒ
    have hâ‚ˆ : 2 â‰¤ b * (b ^ 2 - 1) := le_trans b_ge_two hâ‚‡
    have hâ‚‰ : 2 < p := gt_of_gt_of_ge hâ‚… hâ‚ˆ
    have hâ‚â‚€ := psp_from_prime_gt_p b_ge_two hpâ‚‚ hâ‚‰
    use psp_from_prime b p
    constructor
    Â· exact psp_from_prime_psp b_ge_two hpâ‚‚ hâ‚‰ hâ‚†
    Â· exact le_trans (show m â‰¤ p by linarith) (le_of_lt hâ‚â‚€)
  Â· have hâ‚ : b = 1 := by linarith
    rw [hâ‚]
    use 2 * (m + 2)
    have : Â¬Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by norm_num) (by norm_num)
    exact âŸ¨fermatPsp_base_one (by linarith) this, by linarithâŸ©","error:  application type mismatch
  Nat.le_mul_of_pos_right hâ‚ƒ
argument
  hâ‚ƒ
has type
  0 < b ^ 2 - 1 : Prop
but is expected to have type
  â„• : Type
error:  unsolved goals
b : â„•
h : 1 â‰¤ b
m : â„•
b_ge_two : Â¬2 â‰¤ b
hâ‚ : b = 1
âŠ¢ Â¬m + 2 = 1","theorem exists_infinite_pseudoprimes {b : â„•} (h : 1 â‰¤ b) (m : â„•) :
    âˆƒ n : â„•, FermatPsp n b âˆ§ m â‰¤ n ",":= by
  by_cases b_ge_two : 2 â‰¤ b
  Â· have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hpâ‚ hpâ‚‚
    have hâ‚ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have hâ‚‚ : 4 â‰¤ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have hâ‚ƒ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt hâ‚‚ (by norm_num))
    have hâ‚„ : 0 < b * (b ^ 2 - 1) := mul_pos hâ‚ hâ‚ƒ
    have hâ‚… : b * (b ^ 2 - 1) < p := by omega
    have hâ‚† : Â¬p âˆ£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt hâ‚„ hâ‚…
    have hâ‚‡ : b â‰¤ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right _ hâ‚ƒ
    have hâ‚ˆ : 2 â‰¤ b * (b ^ 2 - 1) := le_trans b_ge_two hâ‚‡
    have hâ‚‰ : 2 < p := gt_of_gt_of_ge hâ‚… hâ‚ˆ
    have hâ‚â‚€ := psp_from_prime_gt_p b_ge_two hpâ‚‚ hâ‚‰
    use psp_from_prime b p
    constructor
    Â· exact psp_from_prime_psp b_ge_two hpâ‚‚ hâ‚‰ hâ‚†
    Â· exact le_trans (show m â‰¤ p by omega) (le_of_lt hâ‚â‚€)
  Â· have hâ‚ : b = 1 := by omega
    rw [hâ‚]
    use 2 * (m + 2)
    have : Â¬Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by omega) (by omega)
    exact âŸ¨fermatPsp_base_one (by omega) this, by omegaâŸ©","refine âŸ¨exists_infinite_pseudoprimes, fermatPse_exists_infinite_pseudoprimes, fermatPse_exists_infinite_pseudoprimes, ?_âŸ©"
Mathlib/SetTheory/Ordinal/Arithmetic.lean,Ordinal.add_mul_succ,add_mul_succ,25e538f3a737a71314ac143929711e67d0b14d73,":= by
  induction c with
  | Hâ‚ => simp only [succ_zero, mul_one]
  | Hâ‚‚ c IH =>
    rw [mul_succ, IH, â† add_assoc, add_assoc _ b, ba, â† mul_succ]
  | Hâ‚ƒ c l IH =>
    rw [mul_succ, add_mul_limit_aux ba l IH, mul_succ, add_assoc]","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
a b c : Ordinal.{u_1}
ba : b + a = a
âŠ¢ (a + b) * succ c = a * succ c + b",theorem add_mul_succ {a b : Ordinal} (c) (ba : b + a = a) : (a + b) * succ c = a * succ c + b ,":= by
  induction c using limitRecOn with
  | Hâ‚ => simp only [succ_zero, mul_one]
  | Hâ‚‚ c IH =>
    rw [mul_succ, IH, â† add_assoc, add_assoc _ b, ba, â† mul_succ]
  | Hâ‚ƒ c l IH =>
    rw [mul_succ, add_mul_limit_aux ba l IH, mul_succ, add_assoc]","rw [add_mul_succ, add_mul_succ]"
Mathlib/Order/SupClosed.lean,supClosed_iInter,supClosed_iInter,a380f5a603bf5030bc30e58b1aed19567f67b98d,:=,error:  unexpected token 'lemma'; expected term,"lemma supClosed_iInter (hf : âˆ€ i, SupClosed (f i)) : SupClosed (â‹‚ i, f i) ",":=
  supClosed_sInter <| forall_mem_range.2 hf",simp onlemma supClosed_iInter hf
Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean,Path.Homotopy.continuous_transAssocReparamAux,continuous_transAssocReparamAux,2ab2720bf60e325ecde05f72c30fd6346f06a460,":= by
  refine continuous_if_le ?_ ?_ (Continuous.continuousOn? _)
      (continuous_if_le ?_ ?_ (Continuous.continuousOn ?_) (Continuous.continuousOn ?_)? _).continuousOn
      ?_ <;>
    [continuity; continuity; continuity; continuity; continuity; continuity; continuity; skip;
      skip] <;>
    Â· intro x hx
      set_option tactic.skipAssignedInstances false in norm_num [hx]","error:  unexpected token '?'; expected ')', ',' or ':'
error:  unexpected identifier; expected command
warning:  fundamentalGroupoidFunctor does not have a doc string",theorem continuous_transAssocReparamAux : Continuous transAssocReparamAux ,":= by
  refine continuous_if_le ?_ ?_ (Continuous.continuousOn ?_)
    (continuous_if_le ?_ ?_
      (Continuous.continuousOn ?_) (Continuous.continuousOn ?_) ?_).continuousOn
      ?_ <;>
    [continuity; continuity; continuity; continuity; continuity; continuity; continuity; skip;
      skip] <;>
    Â· intro x hx
      norm_num [hx]",rw [continuous_transAssocReparamAux]
Mathlib/MeasureTheory/Measure/MeasureSpace.lean,MeasureTheory.measure_limsup_eq_zero,measure_limsup_eq_zero,4ec56805cfc9d94a085151eee145a71bd2ef3f51,":= by
  set t : â„• â†’ Set Î± := fun n => toMeasurable Î¼ (s n)
  have ht : (âˆ‘' i, Î¼ (t i)) â‰  âˆ := by simpa only [measure_toMeasurable] using hs
  suffices Î¼ (limsup t atTop) = 0 by
    have A : s â‰¤ t := fun n => subset_toMeasurable Î¼ (s n)
    exact measure_mono_null (limsup_le_limsup (eventually_of_forall (Pi.le_def.mp A))) this
  simp only [limsup_eq_iInf_iSup_of_nat', Set.iInf_eq_iInter, Set.iSup_eq_iUnion, â†
    nonpos_iff_eq_zero]
  refine'
    le_of_tendsto_of_tendsto'
      (tendsto_measure_iInter
        (fun i => MeasurableSet.iUnion fun b => measurableSet_toMeasurable _ _) _
        âŸ¨0, ne_top_of_le_ne_top ht (measure_iUnion_le t)âŸ©)
      (ENNReal.tendsto_sum_nat_add (Î¼ âˆ˜ t) ht) fun n => measure_iUnion_le _
  intro n m hnm x
  simp only [Set.mem_iUnion]
  exact fun âŸ¨i, hiâŸ© => âŸ¨i + (m - n), by simpa only [add_assoc, tsub_add_cancel_of_le hnm] using hiâŸ©","error:  type mismatch
  hâœ
has type
  âˆ‘' (i : â„•), Î¼ (s i) â‰  âŠ¤ : Prop
but is expected to have type
  âˆ‘' (i : â„•), Î¼ (t i) â‰  âŠ¤ : Prop
warning:  @Measure.AbsolutelyContinuous does not have a doc string","theorem measure_limsup_eq_zero {s : â„• â†’ Set Î±} (hs : (âˆ‘' i, Î¼ (s i)) â‰  âˆ) :
    Î¼ (limsup s atTop) = 0 ",":= by
  set t : â„• â†’ Set Î± := fun n => toMeasurable Î¼ (s n)
  have ht : (âˆ‘' i, Î¼ (t i)) â‰  âˆ := by simpa only [t, measure_toMeasurable] using hs
  suffices Î¼ (limsup t atTop) = 0 by
    have A : s â‰¤ t := fun n => subset_toMeasurable Î¼ (s n)
    exact measure_mono_null (limsup_le_limsup (eventually_of_forall (Pi.le_def.mp A))) this
  simp only [limsup_eq_iInf_iSup_of_nat', Set.iInf_eq_iInter, Set.iSup_eq_iUnion, â†
    nonpos_iff_eq_zero]
  refine
    le_of_tendsto_of_tendsto'
      (tendsto_measure_iInter
        (fun i => MeasurableSet.iUnion fun b => measurableSet_toMeasurable _ _) ?_
        âŸ¨0, ne_top_of_le_ne_top ht (measure_iUnion_le t)âŸ©)
      (ENNReal.tendsto_sum_nat_add (Î¼ âˆ˜ t) ht) fun n => measure_iUnion_le _
  intro n m hnm x
  simp only [Set.mem_iUnion]
  exact fun âŸ¨i, hiâŸ© => âŸ¨i + (m - n), by simpa only [add_assoc, tsub_add_cancel_of_le hnm] using hiâŸ©",rw [limsup_eq_limsup_eq_zero]
Mathlib/Combinatorics/Schnirelmann.lean,schnirelmannDensity_le_of_not_mem,schnirelmannDensity_le_of_not_mem,bb7a43e4a602b9c4e5cfce963ad6700c7d4c658d,":= by
  rcases k.eq_zero_or_pos with rfl | hk'
  Â· simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [â† one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  apply div_le_div_of_le (Nat.cast_nonneg _)
  rw [â† Nat.cast_pred hk', Nat.cast_le]
  suffices : (Ioc 0 k).filter (Â· âˆˆ A) âŠ† Ioo 0 k; exact (card_le_card this).trans_eq (by simp)
  rw [â† Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _",error:  unexpected token ':'; expected term,"lemma schnirelmannDensity_le_of_not_mem {k : â„•} (hk : k âˆ‰ A) :
    schnirelmannDensity A â‰¤ 1 - (kâ»Â¹ : â„) ",":= by
  rcases k.eq_zero_or_pos with rfl | hk'
  Â· simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [â† one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  gcongr
  rw [â† Nat.cast_pred hk', Nat.cast_le]
  suffices (Ioc 0 k).filter (Â· âˆˆ A) âŠ† Ioo 0 k from (card_le_card this).trans_eq (by simp)
  rw [â† Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _",rw [schnirelmannDensity_le_of_not_mem]
Mathlib/Topology/Algebra/InfiniteSum/Basic.lean,Function.Injective.tprod_eq,Function.Injective.tprod_eq,3b0baa425c7f4e18fdeeb7271bf104ecfee0d57a,":= by
  have : mulSupport f = g '' mulSupport (f âˆ˜ g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [â† Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  Â· have hfg_fin : (mulSupport (f âˆ˜ g)).Finite := hf_fin.preimage hg.injOn
    lift g to Î³ â†ª Î² using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, â† Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ â†¦ rfl
    simp [this]
  Â· have hf_fin' : Â¬ Set.Finite (mulSupport (f âˆ˜ g)) := by
      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      hg.hasProd_iff (mulSupport_subset_iff'.1 hf)]","error:  unsolved goals
case neg
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Î´ : Type u_4
instâœÂ¹ : CommMonoid Î±
instâœ : TopologicalSpace Î±
fâœ gâœ : Î² â†’ Î±
a aâ‚ aâ‚‚ : Î±
g : Î³ â†’ Î²
hg : Injective g
f : Î² â†’ Î±
hf : mulSupport f âŠ† Set.range g
this : mulSupport f = g '' mulSupport (f âˆ˜ g)
hf_fin : Â¬(mulSupport f).Finite
hf_fin' : Â¬(mulSupport (f âˆ˜ g)).Finite
âŠ¢ (if h : âˆƒ a, HasProd f a then Exists.choose â‹¯ else 1) =
    if h : âˆƒ a, HasProd (fun b â†¦ f b) a then Exists.choose â‹¯ else 1","theorem Function.Injective.tprod_eq {g : Î³ â†’ Î²} (hg : Injective g) {f : Î² â†’ Î±}
    (hf : mulSupport f âŠ† Set.range g) : âˆ' c, f (g c) = âˆ' b, f b ",":= by
  have : mulSupport f = g '' mulSupport (f âˆ˜ g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [â† Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  Â· have hfg_fin : (mulSupport (f âˆ˜ g)).Finite := hf_fin.preimage hg.injOn
    lift g to Î³ â†ª Î² using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, â† Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ â†¦ rfl
    simp [this]
  Â· have hf_fin' : Â¬ Set.Finite (mulSupport (f âˆ˜ g)) := by
      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      funext fun a => propext <| hg.hasProd_iff (mulSupport_subset_iff'.1 hf) (a := a)]",refine theorem_eq_theorem_of_mulSupport_subset_mulSupport_subset hf ?_ ?_ ?_
Mathlib/Data/Nat/Bits.lean,Nat.testBit_bit_succ,testBit_bit_succ,2ea14b79e1f7e6978b1265a8d41f7a305925875c,":= by
  have : bodd (((bit b n) >>> 1) >>> m) = bodd (n >>> m) := by
    simp only [shiftRight_eq_div_pow]
    simp [â† div2_val, div2_bit]
  rw [â† shiftRight_add, Nat.add_comm] at this
  simp only [bodd_eq_and_one_ne_zero] at this
  exact this","warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
error:  unknown identifier 'bodd_eq_and_one_ne_zero'
error:  simp made no progress
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated",lemma testBit_bit_succ (m b n) : testBit (bit b n) (succ m) = testBit n m ,":= by
  have : bodd (((bit b n) >>> 1) >>> m) = bodd (n >>> m) := by
    simp only [shiftRight_eq_div_pow]
    simp [â† div2_val, div2_bit]
  rw [â† shiftRight_add, Nat.add_comm] at this
  simp only [bodd_eq_one_and_ne_zero] at this
  exact this","rw [testBit_bit_succ, testBit_succ]"
Mathlib/GroupTheory/SchurZassenhaus.lean,Subgroup.SchurZassenhausInduction.step7,step7,5e0991f0a1ad69c57fd9d5f31370eec177716df6,":= by
  haveI := N.bot_or_nontrivial.resolve_left (step0 h1 h3)
  haveI : Fact (Fintype.card N).minFac.Prime := âŸ¨step4 h1 h3âŸ©
  exact sorry","warning:  declaration uses 'sorry'
error:  function expected at
  SchurZassenhausInduction.step7
term has type
  ?m.78400.IsCommutative
error:  unsolved goals
n : â„•
G : Type u
instâœÂ² : Group G
instâœÂ¹ : Fintype G
ih :
  âˆ€ m < Fintype.card G,
    âˆ€ {G : Type u} [inst : Group G] [inst_1 : Fintype G],
      Fintype.card G = m â†’
        âˆ€ {N : Subgroup G} [inst_2 : N.Normal], (Fintype.card â†¥N).Coprime N.index â†’ âˆƒ H, N.IsComplement' H
N : Subgroup G
instâœ : N.Normal
hN : (Fintype.card â†¥N).Coprime N.index
h3 : âˆ€ (x : Subgroup G), Â¬N.IsComplement' x
âŠ¢ False",theorem step7 : IsCommutative N ,":= by
  haveI := N.bot_or_nontrivial.resolve_left (step0 h1 h3)
  haveI : Fact (Fintype.card N).minFac.Prime := âŸ¨step4 h1 h3âŸ©
  exact
    âŸ¨âŸ¨fun g h => ((eq_top_iff.mp ((step3 h1 h2 h3 (center N)).resolve_left
      (step6 h1 h2 h3).bot_lt_center.ne') (mem_top h)).comm g).symmâŸ©âŸ©","rw [IsCommutative, IsCommutative, IsCommutative, IsCommutative]"
Mathlib/Order/WithBot.lean,WithTop.coe_le_coe,coe_le_coe,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  some_le_some",error:  unknown identifier 'some_le_some',theorem coe_le_coe : (a : WithBot Î±) â‰¤ b â†” a â‰¤ b ,":= by
  simp [LE.le]","simp only [WithBot.le_def, coe_le_coe]"
Mathlib/CategoryTheory/Abelian/Pseudoelements.lean,CategoryTheory.Abelian.Pseudoelement.epi_of_pseudo_surjective,epi_of_pseudo_surjective,1cb1056b5a19f416d3fae3469d51eedb4f5b48cb,":= by
  intro h
  let âŸ¨pbar, hpbarâŸ© := h (ğŸ™ Q)
  let âŸ¨p, hpâŸ© := Quotient.exists_rep pbar
  have : âŸ¦(p.hom â‰« f : Over Q)âŸ§ = âŸ¦â†‘(ğŸ™ Q)âŸ§ := by
    rw [â† hp] at hpbar
    exact hpbar
  let âŸ¨R, x, y, _, ey, commâŸ© := Quotient.exact this
  apply @epi_of_epi_fac _ _ _ _ _ (x â‰« p.hom) f y ey
  dsimp at comm
  rw [Category.assoc, comm]
  apply Category.comp_id","error:  don't know how to synthesize implicit argument 'Î±'
  @Eq (Quotient ?m.60038) âŸ¦Over.mk (p.hom â‰« f)âŸ§ âŸ¦Over.mk (ğŸ™ Q)âŸ§
context:
C : Type u
instâœÂ¹ : Category.{v, u} C
instâœ : Abelian C
P Q : C
f : P âŸ¶ Q
h : Function.Surjective (pseudoApply f)
pbar : Pseudoelement P
hpbar : pseudoApply f pbar = Quot.mk (PseudoEqual Q) (Over.mk (ğŸ™ Q))
p : Over P
hp : âŸ¦pâŸ§ = pbar
âŠ¢ Type (max u v)
error:  don't know how to synthesize placeholder for argument 's'
context:
C : Type u
instâœÂ¹ : Category.{v, u} C
instâœ : Abelian C
P Q : C
f : P âŸ¶ Q
h : Function.Surjective (pseudoApply f)
pbar : Pseudoelement P
hpbar : pseudoApply f pbar = Quot.mk (PseudoEqual Q) (Over.mk (ğŸ™ Q))
p : Over P
hp : âŸ¦pâŸ§ = pbar
âŠ¢ Setoid (Over Q)
error:  don't know how to synthesize placeholder for argument 's'
context:
C : Type u
instâœÂ¹ : Category.{v, u} C
instâœ : Abelian C
P Q : C
f : P âŸ¶ Q
h : Function.Surjective (pseudoApply f)
pbar : Pseudoelement P
hpbar : pseudoApply f pbar = Quot.mk (PseudoEqual Q) (Over.mk (ğŸ™ Q))
p : Over P
hp : âŸ¦pâŸ§ = pbar
âŠ¢ Setoid (Over Q)
error:  unsolved goals
C : Type u
instâœÂ¹ : Category.{v, u} C
instâœ : Abelian C
P Q : C
f : P âŸ¶ Q
h : Function.Surjective (pseudoApply f)
pbar : Pseudoelement P
hpbar : pseudoApply f pbar = Quot.mk (PseudoEqual Q) (Over.mk (ğŸ™ Q))
p : Over P
hp : âŸ¦pâŸ§ = pbar
âŠ¢ Epi f",theorem epi_of_pseudo_surjective {P Q : C} (f : P âŸ¶ Q) : Function.Surjective f â†’ Epi f ,":= by
  intro h
  have âŸ¨pbar, hpbarâŸ© := h (ğŸ™ Q)
  have âŸ¨p, hpâŸ© := Quotient.exists_rep pbar
  have : (âŸ¦(p.hom â‰« f : Over Q)âŸ§ : Quotient (setoid Q)) = âŸ¦â†‘(ğŸ™ Q)âŸ§ := by
    rw [â† hp] at hpbar
    exact hpbar
  have âŸ¨R, x, y, _, ey, commâŸ© := Quotient.exact this
  apply @epi_of_epi_fac _ _ _ _ _ (x â‰« p.hom) f y ey
  dsimp at comm
  rw [Category.assoc, comm]
  apply Category.comp_id",rw [epi_of_pseudo_surjective_surjective]
Mathlib/Analysis/Analytic/Composition.lean,FormalMultilinearSeries.comp_summable_nnreal,comp_summable_nnreal,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hp) with âŸ¨rp, rp_pos, hrpâŸ©
  simp only [lt_min_iff, ENNReal.coe_lt_one_iff, ENNReal.coe_pos] at hrp hrq rp_pos rq_pos
  obtain âŸ¨Cq, _hCq0, hCqâŸ© : âˆƒ Cq > 0, âˆ€ n, â€–q nâ€–â‚Š * rq ^ n â‰¤ Cq :=
    q.nnnorm_mul_pow_le_of_lt_radius hrq.2
  obtain âŸ¨Cp, hCp1, hCpâŸ© : âˆƒ Cp â‰¥ 1, âˆ€ n, â€–p nâ€–â‚Š * rp ^ n â‰¤ Cp := by
    rcases p.nnnorm_mul_pow_le_of_lt_radius hrp.2 with âŸ¨Cp, -, hCpâŸ©
    exact âŸ¨max Cp 1, le_max_right _ _, fun n => (hCp n).trans (le_max_left _ _)âŸ©
  let r0 : â„â‰¥0 := (4 * Cp)â»Â¹
  have r0_pos : 0 < r0 := inv_pos.2 (mul_pos zero_lt_four (zero_lt_one.trans_le hCp1))
  set r : â„â‰¥0 := rp * rq * r0
  have r_pos : 0 < r := mul_pos (mul_pos rp_pos rq_pos) r0_pos
  have I :
    âˆ€ i : Î£ n : â„•, Composition n, â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 â‰¤ Cq / 4 ^ i.1 := by
    rintro âŸ¨n, câŸ©
    have A
    calc
      â€–q c.lengthâ€–â‚Š * rq ^ n â‰¤ â€–q c.lengthâ€–â‚Š * rq ^ c.length :=
        mul_le_mul' le_rfl (pow_le_pow_of_le_one rq.2 hrq.1.le c.length_le)
      _ â‰¤ Cq := hCq _
    have B
    calc
      (âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n = âˆ i, â€–p (c.blocksFun i)â€–â‚Š * rp ^ c.blocksFun i := by
        simp only [Finset.prod_mul_distrib, Finset.prod_pow_eq_pow_sum, c.sum_blocksFun]
      _ â‰¤ âˆ _i : Fin c.length, Cp := (Finset.prod_le_prod' fun i _ => hCp _)
      _ = Cp ^ c.length := by simp
      _ â‰¤ Cp ^ n := pow_le_pow hCp1 c.length_le
    calc
      â€–q.compAlongComposition p câ€–â‚Š * r ^ n â‰¤
          (â€–q c.lengthâ€–â‚Š * âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * r ^ n :=
        mul_le_mul' (q.compAlongComposition_nnnorm p c) le_rfl
      _ = â€–q c.lengthâ€–â‚Š * rq ^ n * ((âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n) * r0 ^ n := by
        simp only [mul_pow]; ring
      _ â‰¤ Cq * Cp ^ n * r0 ^ n := (mul_le_mul' (mul_le_mul' A B) le_rfl)
      _ = Cq / 4 ^ n := by
        simp only
        field_simp [mul_pow, (zero_lt_one.trans_le hCp1).ne']
        ring
  refine' âŸ¨r, r_pos, NNReal.summable_of_le I _âŸ©
  simp_rw [div_eq_mul_inv]
  refine' Summable.mul_left _ _
  have : âˆ€ n : â„•, HasSum (fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹) (2 ^ (n - 1) / 4 ^ n) := by
    intro n
    convert hasSum_fintype fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹
    simp [Finset.card_univ, composition_card, div_eq_mul_inv]
  refine' NNReal.summable_sigma.2 âŸ¨fun n => (this n).summable, (NNReal.summable_nat_add_iff 1).1 _âŸ©
  convert (NNReal.summable_geometric (NNReal.div_lt_one_of_lt one_lt_two)).mul_left (1 / 4) using 1
  ext1 n
  rw [(this _).tsum_eq, add_tsub_cancel_right]
  field_simp [â† mul_assoc, pow_succ', mul_pow, show (4 : â„â‰¥0) = 2 * 2 by norm_num,
    mul_right_comm]","error:  unexpected token 'calc'; expected '|'
error:  unsolved goals
case intro.intro.intro.intro.intro.intro.intro.intro
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
G : Type u_4
H : Type u_5
instâœâ¸ : NontriviallyNormedField ğ•œ
instâœâ· : NormedAddCommGroup E
instâœâ¶ : NormedSpace ğ•œ E
instâœâµ : NormedAddCommGroup F
instâœâ´ : NormedSpace ğ•œ F
instâœÂ³ : NormedAddCommGroup G
instâœÂ² : NormedSpace ğ•œ G
instâœÂ¹ : NormedAddCommGroup H
instâœ : NormedSpace ğ•œ H
q : FormalMultilinearSeries ğ•œ F G
p : FormalMultilinearSeries ğ•œ E F
hq : 0 < q.radius
hp : 0 < p.radius
rq rp : â„â‰¥0
hrp : rp < 1 âˆ§ â†‘rp < p.radius
hrq : rq < 1 âˆ§ â†‘rq < q.radius
rp_pos : 0 < rp
rq_pos : 0 < rq
Cq : â„â‰¥0
_hCq0 : Cq > 0
hCq : âˆ€ (n : â„•), â€–q nâ€–â‚Š * rq ^ n â‰¤ Cq
Cp : â„â‰¥0
hCp1 : Cp â‰¥ 1
hCp : âˆ€ (n : â„•), â€–p nâ€–â‚Š * rp ^ n â‰¤ Cp
r0 : â„â‰¥0 := (4 * Cp)â»Â¹
r0_pos : 0 < r0
r : â„â‰¥0 := rp * rq * r0
r_pos : 0 < r
I : âˆ€ (i : (n : â„•) Ã— Composition n), â€–q.compAlongComposition p i.sndâ€–â‚Š * r ^ i.fst â‰¤ Cq / 4 ^ i.fst
âŠ¢ âˆƒ r > 0, Summable fun i â†¦ â€–q.compAlongComposition p i.sndâ€–â‚Š * r ^ i.fst
warning:  `List.get_splitWrtComposition` has been deprecated, use `List.getElem_splitWrtComposition` instead
warning:  `List.get_drop'` has been deprecated, use `List.getElem_drop'` instead
warning:  `List.get_take'` has been deprecated, use `List.getElem_take` instead","theorem comp_summable_nnreal (q : FormalMultilinearSeries ğ•œ F G) (p : FormalMultilinearSeries ğ•œ E F)
    (hq : 0 < q.radius) (hp : 0 < p.radius) :
    âˆƒ r > (0 : â„â‰¥0),
      Summable fun i : Î£ n, Composition n => â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 ",":= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hp) with âŸ¨rp, rp_pos, hrpâŸ©
  simp only [lt_min_iff, ENNReal.coe_lt_one_iff, ENNReal.coe_pos] at hrp hrq rp_pos rq_pos
  obtain âŸ¨Cq, _hCq0, hCqâŸ© : âˆƒ Cq > 0, âˆ€ n, â€–q nâ€–â‚Š * rq ^ n â‰¤ Cq :=
    q.nnnorm_mul_pow_le_of_lt_radius hrq.2
  obtain âŸ¨Cp, hCp1, hCpâŸ© : âˆƒ Cp â‰¥ 1, âˆ€ n, â€–p nâ€–â‚Š * rp ^ n â‰¤ Cp := by
    rcases p.nnnorm_mul_pow_le_of_lt_radius hrp.2 with âŸ¨Cp, -, hCpâŸ©
    exact âŸ¨max Cp 1, le_max_right _ _, fun n => (hCp n).trans (le_max_left _ _)âŸ©
  let r0 : â„â‰¥0 := (4 * Cp)â»Â¹
  have r0_pos : 0 < r0 := inv_pos.2 (mul_pos zero_lt_four (zero_lt_one.trans_le hCp1))
  set r : â„â‰¥0 := rp * rq * r0
  have r_pos : 0 < r := mul_pos (mul_pos rp_pos rq_pos) r0_pos
  have I :
    âˆ€ i : Î£ n : â„•, Composition n, â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 â‰¤ Cq / 4 ^ i.1 := by
    rintro âŸ¨n, câŸ©
    have A := calc
      â€–q c.lengthâ€–â‚Š * rq ^ n â‰¤ â€–q c.lengthâ€–â‚Š * rq ^ c.length :=
        mul_le_mul' le_rfl (pow_le_pow_of_le_one rq.2 hrq.1.le c.length_le)
      _ â‰¤ Cq := hCq _
    have B := calc
      (âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n = âˆ i, â€–p (c.blocksFun i)â€–â‚Š * rp ^ c.blocksFun i := by
        simp only [Finset.prod_mul_distrib, Finset.prod_pow_eq_pow_sum, c.sum_blocksFun]
      _ â‰¤ âˆ _i : Fin c.length, Cp := Finset.prod_le_prod' fun i _ => hCp _
      _ = Cp ^ c.length := by simp
      _ â‰¤ Cp ^ n := pow_le_pow_right hCp1 c.length_le
    calc
      â€–q.compAlongComposition p câ€–â‚Š * r ^ n â‰¤
          (â€–q c.lengthâ€–â‚Š * âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * r ^ n :=
        mul_le_mul' (q.compAlongComposition_nnnorm p c) le_rfl
      _ = â€–q c.lengthâ€–â‚Š * rq ^ n * ((âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n) * r0 ^ n := by
        ring
      _ â‰¤ Cq * Cp ^ n * r0 ^ n := mul_le_mul' (mul_le_mul' A B) le_rfl
      _ = Cq / 4 ^ n := by
        simp only [r0]
        field_simp [mul_pow, (zero_lt_one.trans_le hCp1).ne']
        ring
  refine âŸ¨r, r_pos, NNReal.summable_of_le I ?_âŸ©
  simp_rw [div_eq_mul_inv]
  refine Summable.mul_left _ ?_
  have : âˆ€ n : â„•, HasSum (fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹) (2 ^ (n - 1) / 4 ^ n) := by
    intro n
    convert hasSum_fintype fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹
    simp [Finset.card_univ, composition_card, div_eq_mul_inv]
  refine NNReal.summable_sigma.2 âŸ¨fun n => (this n).summable, (NNReal.summable_nat_add_iff 1).1 ?_âŸ©
  convert (NNReal.summable_geometric (NNReal.div_lt_one_of_lt one_lt_two)).mul_left (1 / 4) using 1
  ext1 n
  rw [(this _).tsum_eq, add_tsub_cancel_right]
  field_simp [â† mul_assoc, pow_succ, mul_pow, show (4 : â„â‰¥0) = 2 * 2 by norm_num,
    mul_right_comm]","rcases ENNReal.exists_pos_summable_nnreal_of_summable_nnreal hq p.radius with âŸ¨rq, rq_pos, hrqâŸ©"
Mathlib/Topology/Order/Basic.lean,isOpen_lt',isOpen_lt',46d4658f3d53b90e371238cba7834b12e431e312,:= isOpen_Ioi,"error:  type mismatch
  isOpen_Ioi
has type
  IsOpen (Ioi ?m.4557) : Prop
but is expected to have type
  IsOpen {b | a < b} : Prop
error:  failed to synthesize
  LinearOrder Î±
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  ClosedIicTopology Î±
use `set_option diagnostics true` to get diagnostic information",theorem isOpen_lt' (a : Î±) : IsOpen { b : Î± | a < b } ,":=
  isOpen_iff_generate_intervals.2 <| .basic _ âŸ¨a, .inl rflâŸ©",rw [â† isOpen_setOf_lt']
Mathlib/NumberTheory/DirichletCharacter/Basic.lean,DirichletCharacter.even_or_odd,even_or_odd,820f97a377780dd93a62e169ef9f405c7ae8d3d0,":= by
  suffices : Ïˆ (-1) ^ 2 = 1
  Â· convert sq_eq_one_iff.mp this
  Â· rw [â† map_pow _, neg_one_sq, map_one]",error:  unexpected token ':'; expected term,lemma even_or_odd [NoZeroDivisors S] : Ïˆ.Even âˆ¨ Ïˆ.Odd ,":= by
  suffices Ïˆ (-1) ^ 2 = 1 by convert sq_eq_one_iff.mp this
  rw [â† map_pow _, neg_one_sq, map_one]",cases' even_or_odd with even_or_odd even_or_odd
Mathlib/MeasureTheory/Measure/Typeclasses.lean,MeasureTheory.Measure.countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top,countable_meas_pos_of_disjoint_of_meas_iUnion_ne_top,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  set posmeas := { i : Î¹ | 0 < Î¼ (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : â„â‰¥0âˆ) < 1) with
    âŸ¨as, _, as_mem, as_limâŸ©
  set fairmeas := fun n : â„• => { i : Î¹ | as n â‰¤ Î¼ (As i) }
  have countable_union : posmeas = â‹ƒ n, fairmeas n := by
    have fairmeas_eq : âˆ€ n, fairmeas n = (fun i => Î¼ (As i)) â»Â¹' Ici (as n) := fun n => by
      simp only []
      rfl
    simpa only [fairmeas_eq, posmeas_def, â† preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : â„â‰¥0âˆ) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine' countable_iUnion fun n => Finite.countable _
  exact finite_const_le_meas_of_disjoint_iUnionâ‚€ Î¼ (as_mem n).1 As_mble As_disj Union_As_finite",error:  simp made no progress,"theorem countable_meas_pos_of_disjoint_of_meas_iUnion_ne_topâ‚€ {Î¹ : Type*} {_ : MeasurableSpace Î±}
    (Î¼ : Measure Î±) {As : Î¹ â†’ Set Î±} (As_mble : âˆ€ i : Î¹, NullMeasurableSet (As i) Î¼)
    (As_disj : Pairwise (AEDisjoint Î¼ on As)) (Union_As_finite : Î¼ (â‹ƒ i, As i) â‰  âˆ) :
    Set.Countable { i : Î¹ | 0 < Î¼ (As i) } ",":= by
  set posmeas := { i : Î¹ | 0 < Î¼ (As i) } with posmeas_def
  rcases exists_seq_strictAnti_tendsto' (zero_lt_one : (0 : â„â‰¥0âˆ) < 1) with
    âŸ¨as, _, as_mem, as_limâŸ©
  set fairmeas := fun n : â„• => { i : Î¹ | as n â‰¤ Î¼ (As i) }
  have countable_union : posmeas = â‹ƒ n, fairmeas n := by
    have fairmeas_eq : âˆ€ n, fairmeas n = (fun i => Î¼ (As i)) â»Â¹' Ici (as n) := fun n => by
      simp only [fairmeas]
      rfl
    simpa only [fairmeas_eq, posmeas_def, â† preimage_iUnion,
      iUnion_Ici_eq_Ioi_of_lt_of_tendsto (0 : â„â‰¥0âˆ) (fun n => (as_mem n).1) as_lim]
  rw [countable_union]
  refine countable_iUnion fun n => Finite.countable ?_
  exact finite_const_le_meas_of_disjoint_iUnionâ‚€ Î¼ (as_mem n).1 As_mble As_disj Union_As_finite","have : âˆ€ i, Î¼ (As i) â‰  âˆ := fun i â†¦ As_mble i"
Mathlib/MeasureTheory/Function/ConditionalExpectation/Real.lean,MeasureTheory.ae_bdd_condexp_of_ae_bdd,ae_bdd_condexp_of_ae_bdd,23a4924cf2b9935cd0d74bfddf0c256cc014b6a4,":= by
  by_cases hnm : m â‰¤ m0
  swap
  Â· simp_rw [condexp_of_not_le hnm, Pi.zero_apply, abs_zero]
    refine' eventually_of_forall fun _ => R.coe_nonneg
  by_cases hfint : Integrable f Î¼
  swap
  Â· simp_rw [condexp_undef hfint]
    filter_upwards [hbdd] with x hx
    rw [Pi.zero_apply, abs_zero]
    exact (abs_nonneg _).trans hx
  by_contra h
  change Î¼ _ â‰  0 at h
  simp only [â† zero_lt_iff, Set.compl_def, Set.mem_setOf_eq, not_le] at h
  suffices (Î¼ {x | â†‘R < |(Î¼[f|m]) x|}).toReal * â†‘R < (Î¼ {x | â†‘R < |(Î¼[f|m]) x|}).toReal * â†‘R by
    exact this.ne rfl
  refine' lt_of_lt_of_le (set_integral_gt_gt R.coe_nonneg _ _ h.ne.symm) _
  Â· simp_rw [â† Real.norm_eq_abs]
    exact (stronglyMeasurable_condexp.mono hnm).measurable.norm
  Â· exact integrable_condexp.abs.integrableOn
  refine' (set_integral_abs_condexp_le _ _).trans _
  Â· simp_rw [â† Real.norm_eq_abs]
    exact @measurableSet_lt _ _ _ _ _ m _ _ _ _ _ measurable_const
      stronglyMeasurable_condexp.norm.measurable
  simp only [â† smul_eq_mul, â† set_integral_const, NNReal.val_eq_coe, IsROrC.ofReal_real_eq_id,
    id.def]
  refine' set_integral_mono_ae hfint.abs.integrableOn _ _
  Â· refine' âŸ¨aestronglyMeasurable_const, lt_of_le_of_lt _
      (integrable_condexp.integrableOn : IntegrableOn (Î¼[f|m]) {x | â†‘R < |(Î¼[f|m]) x|} Î¼).2âŸ©
    refine' set_lintegral_mono (Measurable.nnnorm _).coe_nnreal_ennreal
      (stronglyMeasurable_condexp.mono hnm).measurable.nnnorm.coe_nnreal_ennreal fun x hx => _
    Â· exact measurable_const
    Â· rw [ENNReal.coe_le_coe, Real.nnnorm_of_nonneg R.coe_nonneg]
      exact Subtype.mk_le_mk.2 (le_of_lt hx)
  Â· exact hbdd","warning:  `MeasureTheory.set_integral_gt_gt` has been deprecated, use `MeasureTheory.setIntegral_gt_gt` instead
warning:  `MeasureTheory.set_integral_abs_condexp_le` has been deprecated, use `MeasureTheory.setIntegral_abs_condexp_le` instead
warning:  `MeasureTheory.set_integral_const` has been deprecated, use `MeasureTheory.setIntegral_const` instead
error:  unknown identifier 'IsROrC.ofReal_real_eq_id'
error:  overloaded, errors 
  invalid field notation, type is not of the form (C ...) where C is a constant
    _root_.id
  has type
    ?m.55844 â†’ ?m.55844
  
  unknown constant 'ContinuousLinearMap.id.def'
warning:  `MeasureTheory.set_integral_mono_ae` has been deprecated, use `MeasureTheory.setIntegral_mono_ae` instead
warning:  `MeasureTheory.set_lintegral_mono` has been deprecated, use `MeasureTheory.setLIntegral_mono` instead","theorem ae_bdd_condexp_of_ae_bdd {R : â„â‰¥0} {f : Î± â†’ â„} (hbdd : âˆ€áµ x âˆ‚Î¼, |f x| â‰¤ R) :
    âˆ€áµ x âˆ‚Î¼, |(Î¼[f|m]) x| â‰¤ R ",":= by
  by_cases hnm : m â‰¤ m0
  swap
  Â· simp_rw [condexp_of_not_le hnm, Pi.zero_apply, abs_zero]
    exact eventually_of_forall fun _ => R.coe_nonneg
  by_cases hfint : Integrable f Î¼
  swap
  Â· simp_rw [condexp_undef hfint]
    filter_upwards [hbdd] with x hx
    rw [Pi.zero_apply, abs_zero]
    exact (abs_nonneg _).trans hx
  by_contra h
  change Î¼ _ â‰  0 at h
  simp only [â† zero_lt_iff, Set.compl_def, Set.mem_setOf_eq, not_le] at h
  suffices (Î¼ {x | â†‘R < |(Î¼[f|m]) x|}).toReal * â†‘R < (Î¼ {x | â†‘R < |(Î¼[f|m]) x|}).toReal * â†‘R by
    exact this.ne rfl
  refine lt_of_lt_of_le (setIntegral_gt_gt R.coe_nonneg ?_ ?_ h.ne.symm) ?_
  Â· simp_rw [â† Real.norm_eq_abs]
    exact (stronglyMeasurable_condexp.mono hnm).measurable.norm
  Â· exact integrable_condexp.abs.integrableOn
  refine (setIntegral_abs_condexp_le ?_ _).trans ?_
  Â· simp_rw [â† Real.norm_eq_abs]
    exact @measurableSet_lt _ _ _ _ _ m _ _ _ _ _ measurable_const
      stronglyMeasurable_condexp.norm.measurable
  simp only [â† smul_eq_mul, â† setIntegral_const, NNReal.val_eq_coe, RCLike.ofReal_real_eq_id,
    _root_.id]
  refine setIntegral_mono_ae hfint.abs.integrableOn ?_ hbdd
  refine âŸ¨aestronglyMeasurable_const, lt_of_le_of_lt ?_
    (integrable_condexp.integrableOn : IntegrableOn (Î¼[f|m]) {x | â†‘R < |(Î¼[f|m]) x|} Î¼).2âŸ©
  refine setLIntegral_mono measurable_const.nnnorm.coe_nnreal_ennreal
    (stronglyMeasurable_condexp.mono hnm).measurable.nnnorm.coe_nnreal_ennreal fun x hx => ?_
  rw [ENNReal.coe_le_coe, Real.nnnorm_of_nonneg R.coe_nonneg]
  exact Subtype.mk_le_mk.2 (le_of_lt hx)",refine ae_bdd_condexp_of_ae_bdd.theorem_eventuallyLE ?_
Mathlib/Data/Nat/Cast/Defs.lean,Nat.binCast_eq,binCast_eq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  apply Nat.strongInductionOn n
  intros k hk
  cases k with
  | zero => rw [Nat.binCast, Nat.cast_zero]
  | succ k =>
      rw [Nat.binCast]
      by_cases h : (k + 1) % 2 = 0
      Â· rw [â† Nat.mod_add_div (succ k) 2]
        rw [if_pos h, hk _ <| Nat.div_lt_self (Nat.succ_pos k) (Nat.le_refl 2), â† Nat.cast_add]
        rw [Nat.succ_eq_add_one, h, Nat.zero_add, Nat.succ_mul, Nat.one_mul]
      Â· rw [â† Nat.mod_add_div (succ k) 2]
        rw [if_neg h, hk _ <| Nat.div_lt_self (Nat.succ_pos k) (Nat.le_refl 2), â† Nat.cast_add]
        have h1 := Or.resolve_left (Nat.mod_two_eq_zero_or_one (succ k)) h
        rw [h1, Nat.add_comm 1, Nat.succ_mul, Nat.one_mul]
        simp only [Nat.cast_add, Nat.cast_one]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  k.succ
case pos
R : Type u_1
instâœ : AddMonoidWithOne R
n k : â„•
hk : âˆ€ (m : â„•), m < k + 1 â†’ m.binCast = â†‘m
h : (k + 1) % 2 = 0
âŠ¢ (if (k + 1) % 2 = 0 then ((k + 1) / 2).binCast + ((k + 1) / 2).binCast
    else ((k + 1) / 2).binCast + ((k + 1) / 2).binCast + 1) =
    â†‘(k + 1)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  k.succ
case neg
R : Type u_1
instâœ : AddMonoidWithOne R
n k : â„•
hk : âˆ€ (m : â„•), m < k + 1 â†’ m.binCast = â†‘m
h : Â¬(k + 1) % 2 = 0
âŠ¢ (if (k + 1) % 2 = 0 then ((k + 1) / 2).binCast + ((k + 1) / 2).binCast
    else ((k + 1) / 2).binCast + ((k + 1) / 2).binCast + 1) =
    â†‘(k + 1)
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated","theorem binCast_eq [AddMonoidWithOne R] (n : â„•) :
    (Nat.binCast n : R) = ((n : â„•) : R) ",":= by
  apply Nat.strongInductionOn n
  intros k hk
  cases k with
  | zero => rw [Nat.binCast, Nat.cast_zero]
  | succ k =>
      rw [Nat.binCast]
      by_cases h : (k + 1) % 2 = 0
      Â· conv => rhs; rw [â† Nat.mod_add_div (k+1) 2]
        rw [if_pos h, hk _ <| Nat.div_lt_self (Nat.succ_pos k) (Nat.le_refl 2), â† Nat.cast_add]
        rw [h, Nat.zero_add, Nat.succ_mul, Nat.one_mul]
      Â· conv => rhs; rw [â† Nat.mod_add_div (k+1) 2]
        rw [if_neg h, hk _ <| Nat.div_lt_self (Nat.succ_pos k) (Nat.le_refl 2), â† Nat.cast_add]
        have h1 := Or.resolve_left (Nat.mod_two_eq_zero_or_one (succ k)) h
        rw [h1, Nat.add_comm 1, Nat.succ_mul, Nat.one_mul]
        simp only [Nat.cast_add, Nat.cast_one]",simp [AddMonoidWithOne.binCast]
Mathlib/SetTheory/Cardinal/Cofinality.lean,Ordinal.exists_fundamental_sequence,exists_fundamental_sequence,8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85,":= by
  suffices h : âˆƒ o f, IsFundamentalSequence a o f by
    rcases h with âŸ¨o, f, hfâŸ©
    exact âŸ¨_, hf.ord_cofâŸ©
  rcases exists_lsub_cof a with âŸ¨Î¹, f, hf, hÎ¹âŸ©
  rcases ord_eq Î¹ with âŸ¨r, wo, hrâŸ©
  haveI := wo
  let r' := Subrel r { i | âˆ€ j, r j i â†’ f j < f i }
  let hrr' : r' â†ªr r := Subrel.relEmbedding _ _
  haveI := hrr'.isWellOrder
  refine
    âŸ¨_, _, hrr'.ordinal_type_le.trans ?_, @fun i j _ h _ => (enum r' j h).prop _ ?_,
      le_antisymm (blsub_le fun i hi => lsub_le_iff.1 hf.le _) ?_âŸ©
  Â· rw [â† hÎ¹, hr]
  Â· change r (hrr'.1 _) (hrr'.1 _)
    rwa [hrr'.2, @enum_lt_enum _ r']
  Â· rw [â† hf, lsub_le_iff]
    intro i
    suffices h : âˆƒ i' hi', f i â‰¤ bfamilyOfFamily' r' (fun i => f i) i' hi' by
      rcases h with âŸ¨i', hi', hfgâŸ©
      exact hfg.trans_lt (lt_blsub _ _ _)
    by_cases h : âˆ€ j, r j i â†’ f j < f i
    Â· refine âŸ¨typein r' âŸ¨i, hâŸ©, typein_lt_type _ _, ?_âŸ©
      rw [bfamilyOfFamily'_typein]
    Â· push_neg at h
      cases' wo.wf.min_mem _ h with hji hij
      refine âŸ¨typein r' âŸ¨_, fun k hkj => lt_of_lt_of_le ?_ hijâŸ©, typein_lt_type _ ?_, ?_âŸ©
      Â· by_contra! H
        exact (wo.wf.not_lt_min _ h âŸ¨IsTrans.trans _ _ _ hkj hji, HâŸ©) hkj
      Â· rwa [bfamilyOfFamily'_typein]","error:  application type mismatch
  Exists.intro (typein_lt_type r' ?m.69301)
argument
  typein_lt_type r' ?m.69301
has type
  typein r' ?m.69301 < type r' : Prop
but is expected to have type
  typein r' âŸ¨â‹¯.min (fun x â†¦ r x i âˆ§ f i â‰¤ f x) h, â‹¯âŸ© < type r' : Prop","theorem exists_fundamental_sequence (a : Ordinal.{u}) :
    âˆƒ f, IsFundamentalSequence a a.cof.ord f ",":= by
  suffices h : âˆƒ o f, IsFundamentalSequence a o f by
    rcases h with âŸ¨o, f, hfâŸ©
    exact âŸ¨_, hf.ord_cofâŸ©
  rcases exists_lsub_cof a with âŸ¨Î¹, f, hf, hÎ¹âŸ©
  rcases ord_eq Î¹ with âŸ¨r, wo, hrâŸ©
  haveI := wo
  let r' := Subrel r { i | âˆ€ j, r j i â†’ f j < f i }
  let hrr' : r' â†ªr r := Subrel.relEmbedding _ _
  haveI := hrr'.isWellOrder
  refine
    âŸ¨_, _, hrr'.ordinal_type_le.trans ?_, @fun i j _ h _ => (enum r' j h).prop _ ?_,
      le_antisymm (blsub_le fun i hi => lsub_le_iff.1 hf.le _) ?_âŸ©
  Â· rw [â† hÎ¹, hr]
  Â· change r (hrr'.1 _) (hrr'.1 _)
    rwa [hrr'.2, @enum_lt_enum _ r']
  Â· rw [â† hf, lsub_le_iff]
    intro i
    suffices h : âˆƒ i' hi', f i â‰¤ bfamilyOfFamily' r' (fun i => f i) i' hi' by
      rcases h with âŸ¨i', hi', hfgâŸ©
      exact hfg.trans_lt (lt_blsub _ _ _)
    by_cases h : âˆ€ j, r j i â†’ f j < f i
    Â· refine âŸ¨typein r' âŸ¨i, hâŸ©, typein_lt_type _ _, ?_âŸ©
      rw [bfamilyOfFamily'_typein]
    Â· push_neg at h
      cases' wo.wf.min_mem _ h with hji hij
      refine âŸ¨typein r' âŸ¨_, fun k hkj => lt_of_lt_of_le ?_ hijâŸ©, typein_lt_type _ _, ?_âŸ©
      Â· by_contra! H
        exact (wo.wf.not_lt_min _ h âŸ¨IsTrans.trans _ _ _ hkj hji, HâŸ©) hkj
      Â· rwa [bfamilyOfFamily'_typein]","rcases exists_fundamental_sequence (a := exists_fundamental_sequence a) with
  âŸ¨f, hfâŸ©"
Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean,CategoryTheory.MorphismProperty.LeftFraction.map_hom_ofInv_id,map_hom_ofInv_id,9072ff84a0d139a344bf9eed4a00c4cd27596c79,":= by
  have := hL _ hs","error:  unsolved goals
C : Type u_1
D : Type u_2
instâœÂ¹ : Category.{u_3, u_1} C
instâœ : Category.{u_4, u_2} D
W : MorphismProperty C
X Y : C
s : Y âŸ¶ X
hs : W s
L : C â¥¤ D
hL : W.IsInvertedBy L
this : IsIso (L.map s)
âŠ¢ L.map s â‰« (ofInv s hs).map L hL = ğŸ™ (L.obj Y)
error:  unsolved goals
C : Type u_1
D : Type u_2
instâœÂ¹ : Category.{u_3, u_1} C
instâœ : Category.{u_4, u_2} D
W : MorphismProperty C
X Y : C
s : Y âŸ¶ X
hs : W s
L : C â¥¤ D
hL : W.IsInvertedBy L
this : IsIso (L.map s)
âŠ¢ L.map s â‰« (ofInv s hs).map L hL = ğŸ™ (L.obj Y)","lemma map_hom_ofInv_id (s : Y âŸ¶ X) (hs : W s) (L : C â¥¤ D) (hL : W.IsInvertedBy L) :
    L.map s â‰« (ofInv s hs).map L hL = ğŸ™ _ ",":= by
  letI := hL _ hs
  simp [map]","rw [â† cancel_mono ((ofInv s hs).map L hL), â† L.map_comp]"
Mathlib/MeasureTheory/Measure/Typeclasses.lean,MeasureTheory.Measure.measure_toMeasurable_inter_of_cover,measure_toMeasurable_inter_of_cover,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  have A : âˆƒ t', t' âŠ‡ t âˆ§ MeasurableSet t' âˆ§ âˆ€ u, MeasurableSet u â†’ Î¼ (t' âˆ© u) = Î¼ (t âˆ© u) := by
    let w n := toMeasurable Î¼ (t âˆ© v n)
    have hw : âˆ€ n, Î¼ (w n) < âˆ := by
      intro n
      simp_rw [measure_toMeasurable]
      exact (h'v n).lt_top
    set t' := â‹ƒ n, toMeasurable Î¼ (t âˆ© disjointed w n) with ht'
    have tt' : t âŠ† t' :=
      calc
        t âŠ† â‹ƒ n, t âˆ© disjointed w n := by
          rw [â† inter_iUnion, iUnion_disjointed, inter_iUnion]
          intro x hx
          rcases mem_iUnion.1 (hv hx) with âŸ¨n, hnâŸ©
          refine' mem_iUnion.2 âŸ¨n, _âŸ©
          have : x âˆˆ t âˆ© v n := âŸ¨hx, hnâŸ©
          exact âŸ¨hx, subset_toMeasurable Î¼ _ thisâŸ©
        _ âŠ† â‹ƒ n, toMeasurable Î¼ (t âˆ© disjointed w n) :=
          iUnion_mono fun n => subset_toMeasurable _ _
    refine' âŸ¨t', tt', MeasurableSet.iUnion fun n => measurableSet_toMeasurable Î¼ _, fun u hu => _âŸ©
    apply le_antisymm _ (measure_mono (inter_subset_inter tt' Subset.rfl))
    calc
      Î¼ (t' âˆ© u) â‰¤ âˆ‘' n, Î¼ (toMeasurable Î¼ (t âˆ© disjointed w n) âˆ© u) := by
        rw [ht', iUnion_inter]
        exact measure_iUnion_le _
      _ = âˆ‘' n, Î¼ (t âˆ© disjointed w n âˆ© u) := by
        congr 1
        ext1 n
        apply measure_toMeasurable_inter hu
        apply ne_of_lt
        calc
          Î¼ (t âˆ© disjointed w n) â‰¤ Î¼ (t âˆ© w n) :=
            measure_mono (inter_subset_inter_right _ (disjointed_le w n))
          _ â‰¤ Î¼ (w n) := (measure_mono (inter_subset_right _ _))
          _ < âˆ := hw n
      _ = âˆ‘' n, Î¼.restrict (t âˆ© u) (disjointed w n) := by
        congr 1
        ext1 n
        rw [restrict_apply, inter_comm t _, inter_assoc]
        refine MeasurableSet.disjointed (fun n => ?_) n
        exact measurableSet_toMeasurable _ _
      _ = Î¼.restrict (t âˆ© u) (â‹ƒ n, disjointed w n) := by
        rw [measure_iUnion]
        Â· exact disjoint_disjointed _
        Â· intro i
          refine MeasurableSet.disjointed (fun n => ?_) i
          exact measurableSet_toMeasurable _ _
      _ â‰¤ Î¼.restrict (t âˆ© u) univ := (measure_mono (subset_univ _))
      _ = Î¼ (t âˆ© u) := by rw [restrict_apply MeasurableSet.univ, univ_inter]
  rw [toMeasurable]
  split_ifs with ht
  Â· apply measure_congr
    exact ae_eq_set_inter ht.choose_spec.2.2 (ae_eq_refl _)
  Â· exact A.choose_spec.2.2 s hs","error:  simp made no progress
error:  function expected at
  inter_subset_right ?m.170374
term has type
  ?m.170373 âˆˆ ?m.170372","theorem measure_toMeasurable_inter_of_cover {s : Set Î±} (hs : MeasurableSet s) {t : Set Î±}
    {v : â„• â†’ Set Î±} (hv : t âŠ† â‹ƒ n, v n) (h'v : âˆ€ n, Î¼ (t âˆ© v n) â‰  âˆ) :
    Î¼ (toMeasurable Î¼ t âˆ© s) = Î¼ (t âˆ© s) ",":= by
  have A : âˆƒ t', t' âŠ‡ t âˆ§ MeasurableSet t' âˆ§ âˆ€ u, MeasurableSet u â†’ Î¼ (t' âˆ© u) = Î¼ (t âˆ© u) := by
    let w n := toMeasurable Î¼ (t âˆ© v n)
    have hw : âˆ€ n, Î¼ (w n) < âˆ := by
      intro n
      simp_rw [w, measure_toMeasurable]
      exact (h'v n).lt_top
    set t' := â‹ƒ n, toMeasurable Î¼ (t âˆ© disjointed w n) with ht'
    have tt' : t âŠ† t' :=
      calc
        t âŠ† â‹ƒ n, t âˆ© disjointed w n := by
          rw [â† inter_iUnion, iUnion_disjointed, inter_iUnion]
          intro x hx
          rcases mem_iUnion.1 (hv hx) with âŸ¨n, hnâŸ©
          refine mem_iUnion.2 âŸ¨n, ?_âŸ©
          have : x âˆˆ t âˆ© v n := âŸ¨hx, hnâŸ©
          exact âŸ¨hx, subset_toMeasurable Î¼ _ thisâŸ©
        _ âŠ† â‹ƒ n, toMeasurable Î¼ (t âˆ© disjointed w n) :=
          iUnion_mono fun n => subset_toMeasurable _ _
    refine âŸ¨t', tt', MeasurableSet.iUnion fun n => measurableSet_toMeasurable Î¼ _, fun u hu => ?_âŸ©
    apply le_antisymm _ (by gcongr)
    calc
      Î¼ (t' âˆ© u) â‰¤ âˆ‘' n, Î¼ (toMeasurable Î¼ (t âˆ© disjointed w n) âˆ© u) := by
        rw [ht', iUnion_inter]
        exact measure_iUnion_le _
      _ = âˆ‘' n, Î¼ (t âˆ© disjointed w n âˆ© u) := by
        congr 1
        ext1 n
        apply measure_toMeasurable_inter hu
        apply ne_of_lt
        calc
          Î¼ (t âˆ© disjointed w n) â‰¤ Î¼ (t âˆ© w n) := by
            gcongr
            exact disjointed_le w n
          _ â‰¤ Î¼ (w n) := measure_mono inter_subset_right
          _ < âˆ := hw n
      _ = âˆ‘' n, Î¼.restrict (t âˆ© u) (disjointed w n) := by
        congr 1
        ext1 n
        rw [restrict_apply, inter_comm t _, inter_assoc]
        refine MeasurableSet.disjointed (fun n => ?_) n
        exact measurableSet_toMeasurable _ _
      _ = Î¼.restrict (t âˆ© u) (â‹ƒ n, disjointed w n) := by
        rw [measure_iUnion]
        Â· exact disjoint_disjointed _
        Â· intro i
          refine MeasurableSet.disjointed (fun n => ?_) i
          exact measurableSet_toMeasurable _ _
      _ â‰¤ Î¼.restrict (t âˆ© u) univ := measure_mono (subset_univ _)
      _ = Î¼ (t âˆ© u) := by rw [restrict_apply MeasurableSet.univ, univ_inter]
  rw [toMeasurable]
  split_ifs with ht
  Â· apply measure_congr
    exact ae_eq_set_inter ht.choose_spec.2.2 (ae_eq_refl _)
  Â· exact A.choose_spec.2.2 s hs",rw [toMeasurable_inter_of_cover]
Mathlib/Topology/UniformSpace/Pi.lean,cauchy_pi_iff,cauchy_pi_iff,07d28ef76de6fda605a7eb6f6c9ef70c5c90b329,":= by
  simp_rw (config := { instances := true }) [Pi.uniformSpace_eq, cauchy_iInf_uniformSpace,
    cauchy_comap_uniformSpace]","error:  'instances' is not a field of structure 'Lean.Meta.Simp.Config'
error:  cannot evaluate code because 'sorryAx' uses 'sorry' and/or contains errors","lemma cauchy_pi_iff [Nonempty Î¹] {l : Filter (âˆ€ i, Î± i)} :
    Cauchy l â†” âˆ€ i, Cauchy (map (eval i) l) ",":= by
  simp_rw [Pi.uniformSpace_eq, cauchy_iInf_uniformSpace, cauchy_comap_uniformSpace]",constructor
Mathlib/Dynamics/OmegaLimit.lean,eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset',eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset',ed737e5773cdf087080f52542509535e7446ced4,":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  let k := closure (image2 Ï• v s)
  have hk : IsCompact (k \ n) :=
    (hcâ‚.of_isClosed_subset isClosed_closure hvâ‚‚).diff hnâ‚
  let j u := (closure (image2 Ï• (u âˆ© v) s))á¶œ
  have hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u) := fun _ _ â†¦ isOpen_compl_iff.mpr isClosed_closure
  have hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u := by
    have : â‹ƒ u âˆˆ f, j u = â‹ƒ u : (â†¥f.sets), j u := biUnion_eq_iUnion _ _
    rw [this, diff_subset_comm, diff_iUnion]
    rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚] at hnâ‚‚
    simp_rw [diff_compl]
    rw [â† inter_iInter]
    exact Subset.trans (inter_subset_right _ _) hnâ‚‚
  rcases hk.elim_finite_subcover_image hjâ‚ hjâ‚‚ with âŸ¨g, hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f, hgâ‚‚, hgâ‚ƒâŸ©
  let w := (â‹‚ u âˆˆ g, u) âˆ© v
  have hwâ‚‚ : w âˆˆ f := by simpa [*]
  have hwâ‚ƒ : k \ n âŠ† (closure (image2 Ï• w s))á¶œ := by
    apply Subset.trans hgâ‚ƒ
    simp only [iUnion_subset_iff, compl_subset_compl]
    intros u hu
    mono
    refine' iInter_subset_of_subset u (iInter_subset_of_subset hu _)
    all_goals exact Subset.rfl
  have hwâ‚„ : ká¶œ âŠ† (closure (image2 Ï• w s))á¶œ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset (inter_subset_right _ _) Subset.rfl)
  have hnc : ná¶œ âŠ† k \ n âˆª ká¶œ := by rw [union_comm, â† inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 Ï• w s) âŠ† n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hwâ‚ƒ hwâ‚„))
  exact âŸ¨_, hwâ‚‚, hwâŸ©","warning:  @omegaLimit does not have a doc string
error:  simp made no progress
error:  tactic 'assumption' failed
Ï„ : Type u_1
Î± : Type u_2
Î² : Type u_3
Î¹ : Type u_4
instâœ : TopologicalSpace Î²
f : Filter Ï„
Ï• : Ï„ â†’ Î± â†’ Î²
s sâ‚ sâ‚‚ : Set Î±
c : Set Î²
hcâ‚ : IsCompact c
n : Set Î²
hnâ‚ : IsOpen n
hnâ‚‚ : Ï‰ f Ï• s âŠ† n
v : Set Ï„
hvâ‚ : v âˆˆ f
hvâ‚‚ : closure (image2 Ï• v s) âŠ† c
k : Set Î² := closure (image2 Ï• v s)
hk : IsCompact (k \ n)
j : Set Ï„ â†’ Set Î² := fun u â†¦ (closure (image2 Ï• (u âˆ© v) s))á¶œ
hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u)
hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u
g : Set (Set Ï„)
hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f
hgâ‚‚ : g.Finite
hgâ‚ƒ : k \ n âŠ† â‹ƒ i âˆˆ g, j i
w : Set Ï„ := (â‹‚ u âˆˆ g, u) âˆ© v
âŠ¢ w âˆˆ f
error:  repeat1' made no progress
error:  function expected at
  inter_subset_right ?m.28407
term has type
  ?m.28406 âˆˆ ?m.28405","theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set Î²}
    (hcâ‚ : IsCompact c) (hcâ‚‚ : âˆƒ v âˆˆ f, closure (image2 Ï• v s) âŠ† c) {n : Set Î²} (hnâ‚ : IsOpen n)
    (hnâ‚‚ : Ï‰ f Ï• s âŠ† n) : âˆƒ u âˆˆ f, closure (image2 Ï• u s) âŠ† n ",":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  let k := closure (image2 Ï• v s)
  have hk : IsCompact (k \ n) :=
    (hcâ‚.of_isClosed_subset isClosed_closure hvâ‚‚).diff hnâ‚
  let j u := (closure (image2 Ï• (u âˆ© v) s))á¶œ
  have hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u) := fun _ _ â†¦ isOpen_compl_iff.mpr isClosed_closure
  have hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u := by
    have : â‹ƒ u âˆˆ f, j u = â‹ƒ u : (â†¥f.sets), j u := biUnion_eq_iUnion _ _
    rw [this, diff_subset_comm, diff_iUnion]
    rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚] at hnâ‚‚
    simp_rw [j, diff_compl]
    rw [â† inter_iInter]
    exact Subset.trans inter_subset_right hnâ‚‚
  rcases hk.elim_finite_subcover_image hjâ‚ hjâ‚‚ with âŸ¨g, hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f, hgâ‚‚, hgâ‚ƒâŸ©
  let w := (â‹‚ u âˆˆ g, u) âˆ© v
  have hwâ‚‚ : w âˆˆ f := by simpa [w, *]
  have hwâ‚ƒ : k \ n âŠ† (closure (image2 Ï• w s))á¶œ := by
    apply Subset.trans hgâ‚ƒ
    simp only [j, iUnion_subset_iff, compl_subset_compl]
    intros u hu
    mono
    refine iInter_subset_of_subset u (iInter_subset_of_subset hu ?_)
    all_goals exact Subset.rfl
  have hwâ‚„ : ká¶œ âŠ† (closure (image2 Ï• w s))á¶œ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset inter_subset_right Subset.rfl)
  have hnc : ná¶œ âŠ† k \ n âˆª ká¶œ := by rw [union_comm, â† inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 Ï• w s) âŠ† n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hwâ‚ƒ hwâ‚„))
  exact âŸ¨_, hwâ‚‚, hwâŸ©","rcases hcâ‚‚ with âŸ¨v, hv, hvâŸ©"
Mathlib/Dynamics/OmegaLimit.lean,eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset',eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset',a0ae54031c9160e2e2357f3bf0d8106847fdf1f5,":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  let k := closure (image2 Ï• v s)
  have hk : IsCompact (k \ n) :=
    IsCompact.diff (isCompact_of_isClosed_subset hcâ‚ isClosed_closure hvâ‚‚) hnâ‚
  let j u := closure (image2 Ï• (u âˆ© v) s)á¶œ
  have hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u) := fun _ _ â†¦ isOpen_compl_iff.mpr isClosed_closure
  have hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u := by
    have : (â‹ƒ u âˆˆ f, j u) = â‹ƒ u : (â†¥f.sets), j u := biUnion_eq_iUnion _ _
    rw [this, diff_subset_comm, diff_iUnion]
    rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚] at hnâ‚‚
    simp_rw [diff_compl]
    rw [â† inter_iInter]
    exact Subset.trans (inter_subset_right _ _) hnâ‚‚
  rcases hk.elim_finite_subcover_image hjâ‚ hjâ‚‚ with âŸ¨g, hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f, hgâ‚‚, hgâ‚ƒâŸ©
  let w := (â‹‚ u âˆˆ g, u) âˆ© v
  have hwâ‚‚ : w âˆˆ f := by simpa [*]
  have hwâ‚ƒ : k \ n âŠ† closure (image2 Ï• w s)á¶œ := by
    apply Subset.trans hgâ‚ƒ
    simp only [iUnion_subset_iff, compl_subset_compl]
    intros u hu
    mono*
    refine' iInter_subset_of_subset u (iInter_subset_of_subset hu _)
    all_goals exact Subset.rfl
  have hwâ‚„ : ká¶œ âŠ† closure (image2 Ï• w s)á¶œ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset (inter_subset_right _ _) Subset.rfl)
  have hnc : ná¶œ âŠ† k \ n âˆª ká¶œ := by rw [union_comm, â† inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 Ï• w s) âŠ† n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hwâ‚ƒ hwâ‚„))
  exact âŸ¨_, hwâ‚‚, hwâŸ©","warning:  @omegaLimit does not have a doc string
error:  unknown identifier 'isCompact_of_isClosed_subset'
error:  type mismatch
  isOpen_compl_iff.mpr isClosed_closure
has type
  IsOpen (closure ?m.18571)á¶œ : Prop
but is expected to have type
  IsOpen (j xâœÂ¹) : Prop
error:  simp made no progress
error:  tactic 'assumption' failed
Ï„ : Type u_1
Î± : Type u_2
Î² : Type u_3
Î¹ : Type u_4
instâœ : TopologicalSpace Î²
f : Filter Ï„
Ï• : Ï„ â†’ Î± â†’ Î²
s sâ‚ sâ‚‚ : Set Î±
c : Set Î²
hcâ‚ : IsCompact c
n : Set Î²
hnâ‚ : IsOpen n
hnâ‚‚ : Ï‰ f Ï• s âŠ† n
v : Set Ï„
hvâ‚ : v âˆˆ f
hvâ‚‚ : closure (image2 Ï• v s) âŠ† c
k : Set Î² := closure (image2 Ï• v s)
hk : IsCompact (k \ n)
j : Set Ï„ â†’ Set Î² := fun u â†¦ closure (image2 Ï• (u âˆ© v) s)á¶œ
hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u)
hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u
g : Set (Set Ï„)
hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f
hgâ‚‚ : g.Finite
hgâ‚ƒ : k \ n âŠ† â‹ƒ i âˆˆ g, j i
w : Set Ï„ := (â‹‚ u âˆˆ g, u) âˆ© v
âŠ¢ w âˆˆ f
error:  application type mismatch
  iInter_subset_of_subset u (iInter_subset_of_subset hu ?m.33087)
argument
  iInter_subset_of_subset hu ?m.33087
has type
  â‹‚ (i : u âˆˆ g), ?m.32986 i âŠ† ?m.32987 : Prop
but is expected to have type
  ?m.32896 u âŠ† ?m.32897 : Prop
error:  simp made no progress
error:  application type mismatch
  union_subset hwâ‚ƒ
argument
  hwâ‚ƒ
has type
  k \ n âŠ† closure (image2 Ï• w s)á¶œ : Prop
but is expected to have type
  k \ n âŠ† (closure (image2 Ï• w s))á¶œ : Prop","theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set Î²}
    (hcâ‚ : IsCompact c) (hcâ‚‚ : âˆƒ v âˆˆ f, closure (image2 Ï• v s) âŠ† c) {n : Set Î²} (hnâ‚ : IsOpen n)
    (hnâ‚‚ : Ï‰ f Ï• s âŠ† n) : âˆƒ u âˆˆ f, closure (image2 Ï• u s) âŠ† n ",":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  let k := closure (image2 Ï• v s)
  have hk : IsCompact (k \ n) :=
    (hcâ‚.of_isClosed_subset isClosed_closure hvâ‚‚).diff hnâ‚
  let j u := (closure (image2 Ï• (u âˆ© v) s))á¶œ
  have hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u) := fun _ _ â†¦ isOpen_compl_iff.mpr isClosed_closure
  have hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u := by
    have : â‹ƒ u âˆˆ f, j u = â‹ƒ u : (â†¥f.sets), j u := biUnion_eq_iUnion _ _
    rw [this, diff_subset_comm, diff_iUnion]
    rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚] at hnâ‚‚
    simp_rw [j, diff_compl]
    rw [â† inter_iInter]
    exact Subset.trans inter_subset_right hnâ‚‚
  rcases hk.elim_finite_subcover_image hjâ‚ hjâ‚‚ with âŸ¨g, hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f, hgâ‚‚, hgâ‚ƒâŸ©
  let w := (â‹‚ u âˆˆ g, u) âˆ© v
  have hwâ‚‚ : w âˆˆ f := by simpa [w, *]
  have hwâ‚ƒ : k \ n âŠ† (closure (image2 Ï• w s))á¶œ := by
    apply Subset.trans hgâ‚ƒ
    simp only [j, iUnion_subset_iff, compl_subset_compl]
    intros u hu
    mono
    refine iInter_subset_of_subset u (iInter_subset_of_subset hu ?_)
    all_goals exact Subset.rfl
  have hwâ‚„ : ká¶œ âŠ† (closure (image2 Ï• w s))á¶œ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset inter_subset_right Subset.rfl)
  have hnc : ná¶œ âŠ† k \ n âˆª ká¶œ := by rw [union_comm, â† inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 Ï• w s) âŠ† n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hwâ‚ƒ hwâ‚„))
  exact âŸ¨_, hwâ‚‚, hwâŸ©","rcases hcâ‚‚ with âŸ¨v, hv, hvâŸ©"
Mathlib/CategoryTheory/Limits/Shapes/Types.lean,CategoryTheory.Limits.Types.unique_of_type_equalizer,unique_of_type_equalizer,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  let y' : PUnit âŸ¶ Y := fun _ => y
  have hy' : y' â‰« g = y' â‰« h := funext fun _ => hy
  refine' âŸ¨(Fork.IsLimit.lift' t _ hy').1 âŸ¨âŸ©, congr_fun (Fork.IsLimit.lift' t y' _).2 âŸ¨âŸ©, _âŸ©
  intro x' hx'
  suffices : (fun _ : PUnit => x') = (Fork.IsLimit.lift' t y' hy').1
  rw [â† this]
  apply Fork.IsLimit.hom_ext t
  funext âŸ¨âŸ©
  apply hx'.trans (congr_fun (Fork.IsLimit.lift' t _ hy').2 âŸ¨âŸ©).symm",error:  unexpected token ':'; expected term,"theorem unique_of_type_equalizer (t : IsLimit (Fork.ofÎ¹ _ w)) (y : Y) (hy : g y = h y) :
    âˆƒ! x : X, f x = y ",":= by
  let y' : PUnit âŸ¶ Y := fun _ => y
  have hy' : y' â‰« g = y' â‰« h := funext fun _ => hy
  refine âŸ¨(Fork.IsLimit.lift' t _ hy').1 âŸ¨âŸ©, congr_fun (Fork.IsLimit.lift' t y' _).2 âŸ¨âŸ©, ?_âŸ©
  intro x' hx'
  suffices (fun _ : PUnit => x') = (Fork.IsLimit.lift' t y' hy').1 by
    rw [â† this]
  apply Fork.IsLimit.hom_ext t
  funext âŸ¨âŸ©
  apply hx'.trans (congr_fun (Fork.IsLimit.lift' t _ hy').2 âŸ¨âŸ©).symm",simp onlimit unique_of_type_equalizer unique_of_type_equalizer
Mathlib/SetTheory/Cardinal/Basic.lean,Cardinal.mk_set,mk_set,ef3c9bcd07782b044027916a64e925f3e4951707,":=
  mk_subtype_le s.toPred","warning:  mk does not have a doc string
error:  invalid field 'toPred', the environment does not contain 'Set.toPred'
  s
has type
  Set Î±
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  s
has type
  Î± â†’ Prop
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Cardinal.power_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  aleph0 does not have a doc string
warning:  powerlt does not have a doc string",theorem mk_set_le (s : Set Î±) : #s â‰¤ #Î± ,":=
  mk_subtype_le s",rw [mk_set_le]
Mathlib/Analysis/NormedSpace/Units.lean,Units.openEmbedding_val,openEmbedding_val,67a30f55cabb8ddd087043d4900eb7947be27d10,"  toEmbedding := embedding_val_mk'
    (fun _ âŸ¨u, huâŸ© â†¦ hu â–¸ (inverse_continuousAt u).continuousWithinAt) Ring.inverse_unit
  open_range := Units.isOpen",error:  'open_range' is not a field of structure 'OpenEmbedding',"theorem openEmbedding_val : OpenEmbedding (val : RË£ â†’ R) where
","  toEmbedding := embedding_val_mk'
    (fun _ âŸ¨u, huâŸ© â†¦ hu â–¸ (inverse_continuousAt u).continuousWithinAt) Ring.inverse_unit
  isOpen_range := Units.isOpen",rw [â† openEmbedding_val.openEmbedding_val.openEmbedding_val]
Mathlib/Analysis/Fourier/RiemannLebesgueLemma.lean,fourierIntegral_half_period_translate,fourierIntegral_half_period_translate,8b47045cfeaaaa81169d1df5347f2621da327ee6,":= by
  have hiw : âŸªi w, wâŸ« = 1 / 2 := by
    rw [inner_smul_left, inner_self_eq_norm_sq_to_K, RCLike.ofReal_real_eq_id, id.def,
      RCLike.conj_to_real, â† div_div, div_mul_cancelâ‚€]
    rwa [Ne.def, sq_eq_zero_iff, norm_eq_zero]
  have :
    (fun v : V => ğ (-âŸªv, wâŸ«) â€¢ f (v + i w)) =
      fun v : V => (fun x : V => -(ğ (-âŸªx, wâŸ«) â€¢ f x)) (v + i w) := by
    ext1 v
    simp_rw [inner_add_left, hiw, Submonoid.smul_def, Real.fourierChar_apply, neg_add, mul_add,
      ofReal_add, add_mul, exp_add]
    have : 2 * Ï€ * -(1 / 2) = -Ï€ := by field_simp; ring
    rw [this, ofReal_neg, neg_mul, exp_neg, exp_pi_mul_I, inv_neg, inv_one, mul_neg_one, neg_smul,
      neg_neg]
  rw [this]
  have := integral_add_right_eq_self (Î¼ := volume) (fun (x : V) â†¦ -(ğ (-âŸªx, wâŸ«) â€¢ f x))
    ((fun w â†¦ (1 / (2 * â€–wâ€– ^ (2 : â„•))) â€¢ w) w)
  rw [this]
  simp only [neg_smul, integral_neg]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.18941 â†’ ?m.18941
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.18943
E : Type u_1
V : Type u_2
instâœâ· : NormedAddCommGroup E
instâœâ¶ : NormedSpace â„‚ E
f : V â†’ E
instâœâµ : NormedAddCommGroup V
instâœâ´ : MeasurableSpace V
instâœÂ³ : BorelSpace V
instâœÂ² : InnerProductSpace â„ V
instâœÂ¹ : FiniteDimensional â„ V
instâœ : CompleteSpace E
w : V
hw : w â‰  0
âŠ¢ (starRingEnd â„) (1 / (2 * â€–wâ€– ^ 2)) * id â€–wâ€– ^ 2 = 1 / 2","theorem fourierIntegral_half_period_translate {w : V} (hw : w â‰  0) :
    (âˆ« v : V, ğ (-âŸªv, wâŸ«) â€¢ f (v + i w)) = -âˆ« v : V, ğ (-âŸªv, wâŸ«) â€¢ f v ",":= by
  have hiw : âŸªi w, wâŸ« = 1 / 2 := by
    rw [inner_smul_left, inner_self_eq_norm_sq_to_K, RCLike.ofReal_real_eq_id, id,
      RCLike.conj_to_real, â† div_div, div_mul_cancelâ‚€]
    rwa [Ne, sq_eq_zero_iff, norm_eq_zero]
  have :
    (fun v : V => ğ (-âŸªv, wâŸ«) â€¢ f (v + i w)) =
      fun v : V => (fun x : V => -(ğ (-âŸªx, wâŸ«) â€¢ f x)) (v + i w) := by
    ext1 v
    simp_rw [inner_add_left, hiw, Submonoid.smul_def, Real.fourierChar_apply, neg_add, mul_add,
      ofReal_add, add_mul, exp_add]
    have : 2 * Ï€ * -(1 / 2) = -Ï€ := by field_simp; ring
    rw [this, ofReal_neg, neg_mul, exp_neg, exp_pi_mul_I, inv_neg, inv_one, mul_neg_one, neg_smul,
      neg_neg]
  rw [this]
  have := integral_add_right_eq_self (Î¼ := volume) (fun (x : V) â†¦ -(ğ (-âŸªx, wâŸ«) â€¢ f x))
    ((fun w â†¦ (1 / (2 * â€–wâ€– ^ (2 : â„•))) â€¢ w) w)
  rw [this]
  simp only [neg_smul, integral_neg]",simp [fourierIntegral_half_period_translate]
Mathlib/MeasureTheory/Integral/CircleIntegral.lean,circleIntegral.integral_sub_zpow_of_ne,integral_sub_zpow_of_ne,c7bd9bd10c613e1788107ba753e252f069560f87,":= by
  rcases em (w âˆˆ sphere c |R| âˆ§ n < -1) with (âŸ¨hw, hnâŸ© | H)
  Â· exact integral_sub_zpow_of_undef (hn.trans (by decide)) hw
  push_neg at H
  have hd : âˆ€ z, z â‰  w âˆ¨ -1 â‰¤ n â†’
      HasDerivAt (fun z => (z - w) ^ (n + 1) / (n + 1)) ((z - w) ^ n) z := by
    intro z hne
    convert ((hasDerivAt_zpow (n + 1) _ (hne.imp _ _)).comp z
      ((hasDerivAt_id z).sub_const w)).div_const _ using 1
    Â· have hn' : (n + 1 : â„‚) â‰  0 := by
        rwa [Ne, â† eq_neg_iff_add_eq_zero, â† Int.cast_one, â† Int.cast_neg, Int.cast_inj]
      simp [mul_assoc, mul_div_cancel_left _ hn']
    exacts [sub_ne_zero.2, neg_le_iff_add_nonneg.1]
  refine' integral_eq_zero_of_hasDerivWithinAt' fun z hz => (hd z _).hasDerivWithinAt
  exact (ne_or_eq z w).imp_right fun (h : z = w) => H <| h â–¸ hz","error:  application type mismatch
  mul_div_cancel_left ?m.192024 hn'
argument
  hn'
has type
  â†‘n + 1 â‰  0 : Prop
but is expected to have type
  ?m.192022 : Type ?u.192021
error:  unsolved goals
case h.e'_7
E : Type u_1
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„‚ E
instâœ : CompleteSpace E
n : â„¤
hn : n â‰  -1
c w : â„‚
R : â„
H : w âˆˆ sphere c |R| â†’ -1 â‰¤ n
z : â„‚
hne : z â‰  w âˆ¨ -1 â‰¤ n
hn' : â†‘n + 1 â‰  0
âŠ¢ (z - w) ^ n = (â†‘n + 1) * (z - w) ^ n / (â†‘n + 1)","theorem integral_sub_zpow_of_ne {n : â„¤} (hn : n â‰  -1) (c w : â„‚) (R : â„) :
    (âˆ® z in C(c, R), (z - w) ^ n) = 0 ",":= by
  rcases em (w âˆˆ sphere c |R| âˆ§ n < -1) with (âŸ¨hw, hnâŸ© | H)
  Â· exact integral_sub_zpow_of_undef (hn.trans (by decide)) hw
  push_neg at H
  have hd : âˆ€ z, z â‰  w âˆ¨ -1 â‰¤ n â†’
      HasDerivAt (fun z => (z - w) ^ (n + 1) / (n + 1)) ((z - w) ^ n) z := by
    intro z hne
    convert ((hasDerivAt_zpow (n + 1) _ (hne.imp _ _)).comp z
      ((hasDerivAt_id z).sub_const w)).div_const _ using 1
    Â· have hn' : (n + 1 : â„‚) â‰  0 := by
        rwa [Ne, â† eq_neg_iff_add_eq_zero, â† Int.cast_one, â† Int.cast_neg, Int.cast_inj]
      simp [mul_assoc, mul_div_cancel_leftâ‚€ _ hn']
    exacts [sub_ne_zero.2, neg_le_iff_add_nonneg.1]
  refine integral_eq_zero_of_hasDerivWithinAt' fun z hz => (hd z ?_).hasDerivWithinAt
  exact (ne_or_eq z w).imp_right fun (h : z = w) => H <| h â–¸ hz","simp only [integral_sub_zpow_of_ne, integral_sub_zpow_of_ne]"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime_pow,cyclotomicRing_isIntegralClosure_of_prime_pow,76620f7bc93be67fe98a87948024801e42a6f815,":= by
  haveI : CharZero â„š := StrictOrderedSemiring.to_charZero
  have hÎ¶ := zeta_spec (p ^ k) â„š (CyclotomicField (p ^ k) â„š)
  refine âŸ¨IsFractionRing.injective _ _, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©, ?_âŸ©âŸ©
  Â· have := (isIntegralClosure_adjoin_singleton_of_prime_pow hÎ¶)
    obtain âŸ¨y, rflâŸ© := this.isIntegral_iff.1 h
    refine' adjoin_mono _ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hÎ¶.pow_eq_one
  Â· rintro âŸ¨y, rflâŸ©
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} â„¤ _) _)","error:  unknown constant 'StrictOrderedSemiring.to_charZero'
error:  function expected at
  integral {p ^ k} â„¤ ?m.69712
term has type
  Algebra.IsIntegral â„¤ ?m.69712","theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) â„¤ â„š) â„¤ (CyclotomicField (p ^ k) â„š) ",":= by
  have hÎ¶ := zeta_spec (p ^ k) â„š (CyclotomicField (p ^ k) â„š)
  refine âŸ¨IsFractionRing.injective _ _, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©, ?_âŸ©âŸ©
  Â· have := isIntegralClosure_adjoin_singleton_of_prime_pow hÎ¶
    obtain âŸ¨y, rflâŸ© := this.isIntegral_iff.1 h
    refine adjoin_mono ?_ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hÎ¶.pow_eq_one
  Â· rintro âŸ¨y, rflâŸ©
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} â„¤ _).isIntegral _)","refine IsIntegralClosure.cyclotomicRing_isIntegralClosure_of_prime_pow cyclotomicRing_isIntegralClosure_of_prime_pow
  cyclotomicRing_isIntegralClosure_of_prime_pow cyclotomicRing_isIntegralClosure_of_prime_pow cyclotomicRing_isIntegralClosure_of_prime_pow"
Mathlib/Analysis/NormedSpace/Connected.lean,Set.Countable.isPathConnected_compl_of_one_lt_rank,Set.Countable.isPathConnected_compl_of_one_lt_rank,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have : Nontrivial E := (rank_pos_iff_nontrivial (R := â„)).1 (zero_lt_one.trans h)
  obtain âŸ¨a, haâŸ© : sá¶œ.Nonempty := (hs.dense_compl â„).nonempty
  refine âŸ¨a, ha, ?_âŸ©
  intro b hb
  rcases eq_or_ne a b with rfl|hab
  Â· exact JoinedIn.refl ha
  let c := (2 : â„)â»Â¹ â€¢ (a + b)
  let x := (2 : â„)â»Â¹ â€¢ (b - a)
  have Ia : c - x = a := by
    simp only [c, x, smul_add, smul_sub]
    abel_nf
    simp [zsmul_eq_smul_cast â„ 2]
  have Ib : c + x = b := by
    simp only [c, x, smul_add, smul_sub]
    abel_nf
    simp [zsmul_eq_smul_cast â„ 2]
  have x_ne_zero : x â‰  0 := by simpa [x] using sub_ne_zero.2 hab.symm
  obtain âŸ¨y, hyâŸ© : âˆƒ y, LinearIndependent â„ ![x, y] :=
    exists_linearIndependent_pair_of_one_lt_rank h x_ne_zero
  have A : Set.Countable {t : â„ | ([c + x -[â„] c + t â€¢ y] âˆ© s).Nonempty} := by
    apply countable_setOf_nonempty_of_disjoint _ (fun t â†¦ inter_subset_right _ _) hs
    intro t t' htt'
    apply disjoint_iff_inter_eq_empty.2
    have N : {c + x} âˆ© s = âˆ… := by
      simpa only [singleton_inter_eq_empty, mem_compl_iff, Ib] using hb
    rw [inter_assoc, inter_comm s, inter_assoc, inter_self, â† inter_assoc, â† subset_empty_iff, â† N]
    apply inter_subset_inter_left
    apply Eq.subset
    apply segment_inter_eq_endpoint_of_linearIndependent_of_ne hy htt'.symm
  have B : Set.Countable {t : â„ | ([c - x -[â„] c + t â€¢ y] âˆ© s).Nonempty} := by
    apply countable_setOf_nonempty_of_disjoint _ (fun t â†¦ inter_subset_right _ _) hs
    intro t t' htt'
    apply disjoint_iff_inter_eq_empty.2
    have N : {c - x} âˆ© s = âˆ… := by
      simpa only [singleton_inter_eq_empty, mem_compl_iff, Ia] using ha
    rw [inter_assoc, inter_comm s, inter_assoc, inter_self, â† inter_assoc, â† subset_empty_iff, â† N]
    apply inter_subset_inter_left
    rw [sub_eq_add_neg _ x]
    apply Eq.subset
    apply segment_inter_eq_endpoint_of_linearIndependent_of_ne _ htt'.symm
    convert hy.units_smul ![-1, 1]
    simp [â† List.ofFn_inj]
  obtain âŸ¨t, htâŸ© : Set.Nonempty ({t : â„ | ([c + x -[â„] c + t â€¢ y] âˆ© s).Nonempty}
      âˆª {t : â„ | ([c - x -[â„] c + t â€¢ y] âˆ© s).Nonempty})á¶œ := ((A.union B).dense_compl â„).nonempty
  let z := c + t â€¢ y
  simp only [compl_union, mem_inter_iff, mem_compl_iff, mem_setOf_eq, not_nonempty_iff_eq_empty]
    at ht
  have JA : JoinedIn sá¶œ a z := by
    apply JoinedIn.of_segment_subset
    rw [subset_compl_iff_disjoint_right, disjoint_iff_inter_eq_empty]
    convert ht.2
    exact Ia.symm
  have JB : JoinedIn sá¶œ b z := by
    apply JoinedIn.of_segment_subset
    rw [subset_compl_iff_disjoint_right, disjoint_iff_inter_eq_empty]
    convert ht.1
    exact Ib.symm
  exact JA.trans JB.symm","error:  function expected at
  inter_subset_right ?m.26809
term has type
  ?m.26808 âˆˆ ?m.26807
error:  function expected at
  inter_subset_right ?m.28274
term has type
  ?m.28273 âˆˆ ?m.28272","theorem Set.Countable.isPathConnected_compl_of_one_lt_rank
    (h : 1 < Module.rank â„ E) {s : Set E} (hs : s.Countable) :
    IsPathConnected sá¶œ ",":= by
  have : Nontrivial E := (rank_pos_iff_nontrivial (R := â„)).1 (zero_lt_one.trans h)
  obtain âŸ¨a, haâŸ© : sá¶œ.Nonempty := (hs.dense_compl â„).nonempty
  refine âŸ¨a, ha, ?_âŸ©
  intro b hb
  rcases eq_or_ne a b with rfl|hab
  Â· exact JoinedIn.refl ha
  let c := (2 : â„)â»Â¹ â€¢ (a + b)
  let x := (2 : â„)â»Â¹ â€¢ (b - a)
  have Ia : c - x = a := by
    simp only [c, x, smul_add, smul_sub]
    abel_nf
    simp [zsmul_eq_smul_cast â„ 2]
  have Ib : c + x = b := by
    simp only [c, x, smul_add, smul_sub]
    abel_nf
    simp [zsmul_eq_smul_cast â„ 2]
  have x_ne_zero : x â‰  0 := by simpa [x] using sub_ne_zero.2 hab.symm
  obtain âŸ¨y, hyâŸ© : âˆƒ y, LinearIndependent â„ ![x, y] :=
    exists_linearIndependent_pair_of_one_lt_rank h x_ne_zero
  have A : Set.Countable {t : â„ | ([c + x -[â„] c + t â€¢ y] âˆ© s).Nonempty} := by
    apply countable_setOf_nonempty_of_disjoint _ (fun t â†¦ inter_subset_right) hs
    intro t t' htt'
    apply disjoint_iff_inter_eq_empty.2
    have N : {c + x} âˆ© s = âˆ… := by
      simpa only [singleton_inter_eq_empty, mem_compl_iff, Ib] using hb
    rw [inter_assoc, inter_comm s, inter_assoc, inter_self, â† inter_assoc, â† subset_empty_iff, â† N]
    apply inter_subset_inter_left
    apply Eq.subset
    apply segment_inter_eq_endpoint_of_linearIndependent_of_ne hy htt'.symm
  have B : Set.Countable {t : â„ | ([c - x -[â„] c + t â€¢ y] âˆ© s).Nonempty} := by
    apply countable_setOf_nonempty_of_disjoint _ (fun t â†¦ inter_subset_right) hs
    intro t t' htt'
    apply disjoint_iff_inter_eq_empty.2
    have N : {c - x} âˆ© s = âˆ… := by
      simpa only [singleton_inter_eq_empty, mem_compl_iff, Ia] using ha
    rw [inter_assoc, inter_comm s, inter_assoc, inter_self, â† inter_assoc, â† subset_empty_iff, â† N]
    apply inter_subset_inter_left
    rw [sub_eq_add_neg _ x]
    apply Eq.subset
    apply segment_inter_eq_endpoint_of_linearIndependent_of_ne _ htt'.symm
    convert hy.units_smul ![-1, 1]
    simp [â† List.ofFn_inj]
  obtain âŸ¨t, htâŸ© : Set.Nonempty ({t : â„ | ([c + x -[â„] c + t â€¢ y] âˆ© s).Nonempty}
      âˆª {t : â„ | ([c - x -[â„] c + t â€¢ y] âˆ© s).Nonempty})á¶œ := ((A.union B).dense_compl â„).nonempty
  let z := c + t â€¢ y
  simp only [compl_union, mem_inter_iff, mem_compl_iff, mem_setOf_eq, not_nonempty_iff_eq_empty]
    at ht
  have JA : JoinedIn sá¶œ a z := by
    apply JoinedIn.of_segment_subset
    rw [subset_compl_iff_disjoint_right, disjoint_iff_inter_eq_empty]
    convert ht.2
    exact Ia.symm
  have JB : JoinedIn sá¶œ b z := by
    apply JoinedIn.of_segment_subset
    rw [subset_compl_iff_disjoint_right, disjoint_iff_inter_eq_empty]
    convert ht.1
    exact Ib.symm
  exact JA.trans JB.symm",rw [isPathConnected_iff]
Mathlib/Data/Finset/Lattice.lean,Finset.sup_inf,sup_inf,dee5d9343d596781e8ec7749927ce52e2d12df27,":= by
  induction s using Finset.cons_induction with
  | empty => simp_rw [Finset.sup_empty, inf_bot_eq]
  | cons _ h => rw [sup_cons, sup_cons, inf_sup_left, h]","error:  tactic 'rewrite' failed, equality or iff proof expected
  Finset Î¹
case cons
F : Type u_1
Î± : Type u_2
Î² : Type u_3
Î³ : Type u_4
Î¹ : Type u_5
Îº : Type u_6
instâœÂ¹ : DistribLattice Î±
instâœ : OrderBot Î±
s : Finset Î¹
t : Finset Îº
fâœ : Î¹ â†’ Î±
g : Îº â†’ Î±
aâœÂ² : Î±
f : Î¹ â†’ Î±
a : Î±
aâœÂ¹ : Î¹
h : Finset Î¹
hâœ : aâœÂ¹ âˆ‰ h
aâœ : a âŠ“ h.sup f = h.sup fun i â†¦ a âŠ“ f i
âŠ¢ a âŠ“ f aâœÂ¹ âŠ” a âŠ“ h.sup f = a âŠ“ f aâœÂ¹ âŠ” h.sup fun i â†¦ a âŠ“ f i","theorem sup_inf_distrib_left (s : Finset Î¹) (f : Î¹ â†’ Î±) (a : Î±) :
    a âŠ“ s.sup f = s.sup fun i => a âŠ“ f i ",":= by
  induction s using Finset.cons_induction with
  | empty => simp_rw [Finset.sup_empty, inf_bot_eq]
  | cons _ _ _ h => rw [sup_cons, sup_cons, inf_sup_left, h]","rw [sup_inf_distrib_left, sup_inf_distrib_left]"
Mathlib/RingTheory/Polynomial/Hermite/Basic.lean,Polynomial.coeff_hermite_explicit,coeff_hermite_explicit,8a77514daeaf3b706a2b617d963d1f46e4504afb,"  | 0, _ => by simp
  | n + 1, 0 => by
    convert coeff_hermite_succ_zero (2 * n + 1) using 1
    rw [coeff_hermite_explicit n 1, (by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] :
      2 * (n + 1) - 1 = 2 * n + 1), Nat.doubleFactorial_add_one, Nat.choose_zero_right,
      Nat.choose_one_right, pow_succ]
    push_cast
    ring
  | n + 1, k + 1 => by
    let hermite_explicit : â„• â†’ â„• â†’ â„¤ := fun n k =>
      (-1) ^ n * (2 * n - 1)â€¼ * Nat.choose (2 * n + k) k
    have hermite_explicit_recur :
      âˆ€ n k : â„•,
        hermite_explicit (n + 1) (k + 1) =
          hermite_explicit (n + 1) k - (k + 2) * hermite_explicit n (k + 2) := by
      intro n k
      simp only [hermite_explicit]
      rw [mul_comm (â†‘k + _ : â„¤), sub_eq_add_neg]
      nth_rw 3 [neg_eq_neg_one_mul]
      simp only [mul_assoc, â† mul_add, pow_succ]
      congr 2
      norm_cast
      rw [(by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] : 2 * (n + 1) - 1 = 2 * n + 1),
        Nat.doubleFactorial_add_one, mul_comm (2 * n + 1)]
      simp only [mul_assoc, â† mul_add]
      congr 1
      rw [(by ring : 2 * (n + 1) + (k + 1) = 2 * n + 1 + (k + 1) + 1),
        (by ring : 2 * (n + 1) + k = 2 * n + 1 + (k + 1)),
        (by ring : 2 * n + (k + 2) = 2 * n + 1 + (k + 1))]
      rw [Nat.choose, Nat.choose_succ_right_eq (2 * n + 1 + (k + 1)) (k + 1), Nat.add_sub_cancel]
      ring
    change _ = hermite_explicit _ _
    rw [â† add_assoc, coeff_hermite_succ_succ, hermite_explicit_recur]
    congr
    Â· rw [coeff_hermite_explicit (n + 1) k]
    Â· rw [(by ring : 2 * (n + 1) + k = 2 * n + (k + 2)), coeff_hermite_explicit n (k + 2)]","info:  Try this: ring_nf
error:  unsolved goals
nâœ kâœ : â„•
hermite_explicit : â„• â†’ â„• â†’ â„¤ := fun n k â†¦ (-1) ^ n * â†‘(2 * n - 1)â€¼ * â†‘((2 * n + k).choose k)
n k : â„•
âŠ¢ -(â†‘(n * (n * 2 - 1)â€¼ * (2 + n * 2 + k).choose k * 2 + n * (n * 2 - 1)â€¼ * (2 + n * 2 + k).choose (1 + k) * 2 +
              (n * 2 - 1)â€¼ * (2 + n * 2 + k).choose k +
            (n * 2 - 1)â€¼ * (2 + n * 2 + k).choose (1 + k)) *
        (-1) ^ n) =
    -(â†‘(n * (n * 2 - 1)â€¼ * (2 + n * 2 + k).choose k * 2 + (n * 2 - 1)â€¼ * (2 + n * 2 + k).choose k) * (-1) ^ n) -
      â†‘(n * (n * 2 - 1)â€¼ * (2 + n * 2 + k).choose (1 + k) * 2 + (n * 2 - 1)â€¼ * (2 + n * 2 + k).choose (1 + k)) *
        (-1) ^ n","theorem coeff_hermite_explicit :
    âˆ€ n k : â„•, coeff (hermite (2 * n + k)) k = (-1) ^ n * (2 * n - 1)â€¼ * Nat.choose (2 * n + k) k
","  | 0, _ => by simp
  | n + 1, 0 => by
    convert coeff_hermite_succ_zero (2 * n + 1) using 1
    rw [coeff_hermite_explicit n 1, (by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] :
      2 * (n + 1) - 1 = 2 * n + 1), Nat.doubleFactorial_add_one, Nat.choose_zero_right,
      Nat.choose_one_right, pow_succ]
    push_cast
    ring
  | n + 1, k + 1 => by
    let hermite_explicit : â„• â†’ â„• â†’ â„¤ := fun n k =>
      (-1) ^ n * (2 * n - 1)â€¼ * Nat.choose (2 * n + k) k
    have hermite_explicit_recur :
      âˆ€ n k : â„•,
        hermite_explicit (n + 1) (k + 1) =
          hermite_explicit (n + 1) k - (k + 2) * hermite_explicit n (k + 2) := by
      intro n k
      simp only [hermite_explicit]
      rw [mul_comm (â†‘k + _ : â„¤), sub_eq_add_neg]
      nth_rw 3 [neg_eq_neg_one_mul]
      simp only [mul_assoc, â† mul_add, pow_succ']
      congr 2
      norm_cast
      rw [(by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] : 2 * (n + 1) - 1 = 2 * n + 1),
        Nat.doubleFactorial_add_one, mul_comm (2 * n + 1)]
      simp only [mul_assoc, â† mul_add]
      congr 1
      rw [(by ring : 2 * (n + 1) + (k + 1) = 2 * n + 1 + (k + 1) + 1),
        (by ring : 2 * (n + 1) + k = 2 * n + 1 + (k + 1)),
        (by ring : 2 * n + (k + 2) = 2 * n + 1 + (k + 1))]
      rw [Nat.choose, Nat.choose_succ_right_eq (2 * n + 1 + (k + 1)) (k + 1), Nat.add_sub_cancel]
      ring
    change _ = hermite_explicit _ _
    rw [â† add_assoc, coeff_hermite_succ_succ, hermite_explicit_recur]
    congr
    Â· rw [coeff_hermite_explicit (n + 1) k]
    Â· rw [(by ring : 2 * (n + 1) + k = 2 * n + (k + 2)), coeff_hermite_explicit n (k + 2)]","rw [Nat.choose_eq_zero_of_lt (by decide), Nat.choose_eq_zero_of_lt (by decide),
  Nat.choose_eq_zero_of_lt (by decide)]"
Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean,Real.volume_eq_stieltjes_id,volume_eq_stieltjes_id,1cce5367e4d13c82a93597fe7dc3e4a27c9e2733,":= by
  haveI : AddLeftInvariant StieltjesFunction.id.measure :=
    âŸ¨fun a =>
      Eq.symm <|
        Real.measure_ext_Ioo_rat fun p q => by
          simp only [Measure.map_apply (measurable_const_add a) measurableSet_Ioo,
            sub_sub_sub_cancel_right, StieltjesFunction.measure_Ioo, StieltjesFunction.id_leftLim,
            StieltjesFunction.id_apply, id.def, preimage_const_add_Ioo]âŸ©
  have A : StieltjesFunction.id.measure (stdOrthonormalBasis â„ â„).toBasis.parallelepiped = 1 := by
    change StieltjesFunction.id.measure (parallelepiped (stdOrthonormalBasis â„ â„)) = 1
    rcases parallelepiped_orthonormalBasis_one_dim (stdOrthonormalBasis â„ â„) with (H | H) <;>
      simp only [H, StieltjesFunction.measure_Icc, StieltjesFunction.id_apply, id.def, tsub_zero,
        StieltjesFunction.id_leftLim, sub_neg_eq_add, zero_add, ENNReal.ofReal_one]
  conv_rhs =>
    rw [addHaarMeasure_unique StieltjesFunction.id.measure
        (stdOrthonormalBasis â„ â„).toBasis.parallelepiped, A]
  simp only [volume, Basis.addHaar, one_smul]","error:  unknown identifier 'AddLeftInvariant'
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.1633 â†’ ?m.1633
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.2139 â†’ ?m.2139
error:  unsolved goals
case inl
Î¹ : Type u_1
instâœ : Fintype Î¹
this : sorryAx (Sort ?u.46) true
H : parallelepiped â‡‘(stdOrthonormalBasis â„ â„) = Icc 0 1
âŠ¢ ofReal (id 1) = 1

case inr
Î¹ : Type u_1
instâœ : Fintype Î¹
this : sorryAx (Sort ?u.46) true
H : parallelepiped â‡‘(stdOrthonormalBasis â„ â„) = Icc (-1) 0
âŠ¢ ofReal (id 0 + 1) = 1
error:  failed to synthesize
  StieltjesFunction.id.measure.IsAddLeftInvariant
use `set_option diagnostics true` to get diagnostic information
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.2599
Î¹ : Type u_1
instâœ : Fintype Î¹
this : sorryAx (Sort ?u.46) true
A : StieltjesFunction.id.measure â†‘(stdOrthonormalBasis â„ â„).toBasis.parallelepiped = 1
| StieltjesFunction.id.measure",theorem volume_eq_stieltjes_id : (volume : Measure â„) = StieltjesFunction.id.measure ,":= by
  haveI : IsAddLeftInvariant StieltjesFunction.id.measure :=
    âŸ¨fun a =>
      Eq.symm <|
        Real.measure_ext_Ioo_rat fun p q => by
          simp only [Measure.map_apply (measurable_const_add a) measurableSet_Ioo,
            sub_sub_sub_cancel_right, StieltjesFunction.measure_Ioo, StieltjesFunction.id_leftLim,
            StieltjesFunction.id_apply, id, preimage_const_add_Ioo]âŸ©
  have A : StieltjesFunction.id.measure (stdOrthonormalBasis â„ â„).toBasis.parallelepiped = 1 := by
    change StieltjesFunction.id.measure (parallelepiped (stdOrthonormalBasis â„ â„)) = 1
    rcases parallelepiped_orthonormalBasis_one_dim (stdOrthonormalBasis â„ â„) with (H | H) <;>
      simp only [H, StieltjesFunction.measure_Icc, StieltjesFunction.id_apply, id, tsub_zero,
        StieltjesFunction.id_leftLim, sub_neg_eq_add, zero_add, ENNReal.ofReal_one]
  conv_rhs =>
    rw [addHaarMeasure_unique StieltjesFunction.id.measure
        (stdOrthonormalBasis â„ â„).toBasis.parallelepiped, A]
  simp only [volume, Basis.addHaar, one_smul]",rw [StieltjesFunction.id_measure]
Mathlib/MeasureTheory/Measure/MeasureSpace.lean,MeasureTheory.measure_iUnion_eq_iSup,measure_iUnion_eq_iSup,4dd5efc4146f75be242abbd1962ef52988665580,":= by
  cases nonempty_encodable Î¹
  generalize ht : Function.extend Encodable.encode s âŠ¥ = t
  replace hd : Directed (Â· âŠ† Â·) t := ht â–¸ hd.extend_bot Encodable.encode_injective
  suffices Î¼ (â‹ƒ n, t n) = â¨† n, Î¼ (t n) by
    simp only [â† ht, Encodable.encode_injective.apply_extend Î¼, â† iSup_eq_iUnion,
      iSup_extend_bot Encodable.encode_injective, Function.comp_def, Pi.bot_apply, bot_eq_empty,
      measure_empty] at this
    exact this.trans (iSup_extend_bot Encodable.encode_injective _)
  clear! Î¹
  refine' le_antisymm _ (iSup_le fun i => measure_mono <| subset_iUnion _ _)
  set T : â„• â†’ Set Î± := fun n => toMeasurable Î¼ (t n)
  set Td : â„• â†’ Set Î± := disjointed T
  have hm : âˆ€ n, MeasurableSet (Td n) :=
    MeasurableSet.disjointed fun n => measurableSet_toMeasurable _ _
  calc
    Î¼ (â‹ƒ n, t n) â‰¤ Î¼ (â‹ƒ n, T n) := measure_mono (iUnion_mono fun i => subset_toMeasurable _ _)
    _ = Î¼ (â‹ƒ n, Td n) := by rw [iUnion_disjointed]
    _ â‰¤ âˆ‘' n, Î¼ (Td n) := (measure_iUnion_le _)
    _ = â¨† I : Finset â„•, âˆ‘ n in I, Î¼ (Td n) := ENNReal.tsum_eq_iSup_sum
    _ â‰¤ â¨† n, Î¼ (t n) := iSup_le fun I => by
      rcases hd.finset_le I with âŸ¨N, hNâŸ©
      calc
        (âˆ‘ n in I, Î¼ (Td n)) = Î¼ (â‹ƒ n âˆˆ I, Td n) :=
          (measure_biUnion_finset ((disjoint_disjointed T).set_pairwise I) fun n _ => hm n).symm
        _ â‰¤ Î¼ (â‹ƒ n âˆˆ I, T n) := (measure_mono (iUnionâ‚‚_mono fun n _hn => disjointed_subset _ _))
        _ = Î¼ (â‹ƒ n âˆˆ I, t n) := (measure_biUnion_toMeasurable I.countable_toSet _)
        _ â‰¤ Î¼ (t N) := (measure_mono (iUnionâ‚‚_subset hN))
        _ â‰¤ â¨† n, Î¼ (t n) := le_iSup (Î¼ âˆ˜ t) N","error:  application type mismatch
  apply_extend Î¼
argument
  Î¼
has type
  Measure Î± : Type u_1
but is expected to have type
  ?m.75510 = ?m.75511 â†’ ?m.75528 : Sort ?u.75512
error:  application type mismatch
  Eq.trans this (iSup_extend_bot Encodable.encode_injective ?m.78075)
argument
  iSup_extend_bot Encodable.encode_injective ?m.78075
has type
  â¨† j, Function.extend Encodable.encode ?m.78075 âŠ¥ j = â¨† i, ?m.78075 i : Prop
but is expected to have type
  â¨† n, Î¼ (Function.extend Encodable.encode s âŠ¥ n) = â¨† i, Î¼ (s i) : Prop
warning:  @Measure.AbsolutelyContinuous does not have a doc string","theorem measure_iUnion_eq_iSup [Countable Î¹] {s : Î¹ â†’ Set Î±} (hd : Directed (Â· âŠ† Â·) s) :
    Î¼ (â‹ƒ i, s i) = â¨† i, Î¼ (s i) ",":= by
  cases nonempty_encodable Î¹
  generalize ht : Function.extend Encodable.encode s âŠ¥ = t
  replace hd : Directed (Â· âŠ† Â·) t := ht â–¸ hd.extend_bot Encodable.encode_injective
  suffices Î¼ (â‹ƒ n, t n) = â¨† n, Î¼ (t n) by
    simp only [â† ht, Function.apply_extend Î¼, â† iSup_eq_iUnion,
      iSup_extend_bot Encodable.encode_injective, (Â· âˆ˜ Â·), Pi.bot_apply, bot_eq_empty,
      measure_empty] at this
    exact this.trans (iSup_extend_bot Encodable.encode_injective _)
  clear! Î¹
  refine le_antisymm ?_ (iSup_le fun i => measure_mono <| subset_iUnion _ _)
  set T : â„• â†’ Set Î± := fun n => toMeasurable Î¼ (t n)
  set Td : â„• â†’ Set Î± := disjointed T
  have hm : âˆ€ n, MeasurableSet (Td n) :=
    MeasurableSet.disjointed fun n => measurableSet_toMeasurable _ _
  calc
    Î¼ (â‹ƒ n, t n) â‰¤ Î¼ (â‹ƒ n, T n) := measure_mono (iUnion_mono fun i => subset_toMeasurable _ _)
    _ = Î¼ (â‹ƒ n, Td n) := by rw [iUnion_disjointed]
    _ â‰¤ âˆ‘' n, Î¼ (Td n) := measure_iUnion_le _
    _ = â¨† I : Finset â„•, âˆ‘ n âˆˆ I, Î¼ (Td n) := ENNReal.tsum_eq_iSup_sum
    _ â‰¤ â¨† n, Î¼ (t n) := iSup_le fun I => by
      rcases hd.finset_le I with âŸ¨N, hNâŸ©
      calc
        (âˆ‘ n âˆˆ I, Î¼ (Td n)) = Î¼ (â‹ƒ n âˆˆ I, Td n) :=
          (measure_biUnion_finset ((disjoint_disjointed T).set_pairwise I) fun n _ => hm n).symm
        _ â‰¤ Î¼ (â‹ƒ n âˆˆ I, T n) := measure_mono (iUnionâ‚‚_mono fun n _hn => disjointed_subset _ _)
        _ = Î¼ (â‹ƒ n âˆˆ I, t n) := measure_biUnion_toMeasurable I.countable_toSet _
        _ â‰¤ Î¼ (t N) := measure_mono (iUnionâ‚‚_subset hN)
        _ â‰¤ â¨† n, Î¼ (t n) := le_iSup (Î¼ âˆ˜ t) N",simp [measure_iUnion_eq_iSup]
Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean,Real.GammaSeq_tendsto_Gamma,GammaSeq_tendsto_Gamma,66444f12b4fdd8b7704fda89d16282bec494d3ac,":= by
  suffices âˆ€ m : â„•, -â†‘m < re s â†’ Tendsto (GammaSeq s) atTop (ğ“ <| GammaAux m s) by
    rw [Gamma]
    apply this
    rw [neg_lt]
    rcases lt_or_le 0 (re s) with (hs | hs)
    Â· exact (neg_neg_of_pos hs).trans_le (Nat.cast_nonneg _)
    Â· refine' (Nat.lt_floor_add_one _).trans_le _
      rw [sub_eq_neg_add, Nat.floor_add_one (neg_nonneg.mpr hs), Nat.cast_add_one]
  intro m
  induction' m with m IH generalizing s
  Â· 
    intro hs
    rw [Nat.cast_zero, neg_zero] at hs
    rw [â† Gamma_eq_GammaAux]
    Â· refine' Tendsto.congr' _ (approx_Gamma_integral_tendsto_Gamma_integral hs)
      refine' (eventually_ne_atTop 0).mp (eventually_of_forall fun n hn => _)
      exact (GammaSeq_eq_approx_Gamma_integral hs hn).symm
    Â· rwa [Nat.cast_zero, neg_lt_zero]
  Â· 
    intro hs
    rw [Nat.cast_succ, neg_add, â† sub_eq_add_neg, sub_lt_iff_lt_add, â† one_re, â† add_re] at hs
    rw [GammaAux]
    have := @Tendsto.congr' _ _ _ ?_ _ _
      ((eventually_ne_atTop 0).mp (eventually_of_forall fun n hn => ?_)) ((IH _ hs).div_const s)
    pick_goal 3; Â· exact GammaSeq_add_one_left s hn 
    conv at this => arg 1; intro n; rw [mul_comm]
    rwa [â† mul_one (GammaAux m (s + 1) / s), tendsto_mul_iff_of_ne_zero _ (one_ne_zero' â„‚)] at this
    simp_rw [add_assoc]
    exact tendsto_coe_nat_div_add_atTop (1 + s)",error:  unknown identifier 'tendsto_coe_nat_div_add_atTop',theorem GammaSeq_tendsto_Gamma (s : â„‚) : Tendsto (GammaSeq s) atTop (ğ“ <| Gamma s) ,":= by
  suffices âˆ€ m : â„•, -â†‘m < re s â†’ Tendsto (GammaSeq s) atTop (ğ“ <| GammaAux m s) by
    rw [Gamma]
    apply this
    rw [neg_lt]
    rcases lt_or_le 0 (re s) with (hs | hs)
    Â· exact (neg_neg_of_pos hs).trans_le (Nat.cast_nonneg _)
    Â· refine (Nat.lt_floor_add_one _).trans_le ?_
      rw [sub_eq_neg_add, Nat.floor_add_one (neg_nonneg.mpr hs), Nat.cast_add_one]
  intro m
  induction' m with m IH generalizing s
  Â· 
    intro hs
    rw [Nat.cast_zero, neg_zero] at hs
    rw [â† Gamma_eq_GammaAux]
    Â· refine Tendsto.congr' ?_ (approx_Gamma_integral_tendsto_Gamma_integral hs)
      refine (eventually_ne_atTop 0).mp (eventually_of_forall fun n hn => ?_)
      exact (GammaSeq_eq_approx_Gamma_integral hs hn).symm
    Â· rwa [Nat.cast_zero, neg_lt_zero]
  Â· 
    intro hs
    rw [Nat.cast_succ, neg_add, â† sub_eq_add_neg, sub_lt_iff_lt_add, â† one_re, â† add_re] at hs
    rw [GammaAux]
    have := @Tendsto.congr' _ _ _ ?_ _ _
      ((eventually_ne_atTop 0).mp (eventually_of_forall fun n hn => ?_)) ((IH _ hs).div_const s)
    pick_goal 3; Â· exact GammaSeq_add_one_left s hn 
    conv at this => arg 1; intro n; rw [mul_comm]
    rwa [â† mul_one (GammaAux m (s + 1) / s), tendsto_mul_iff_of_ne_zero _ (one_ne_zero' â„‚)] at this
    simp_rw [add_assoc]
    exact tendsto_natCast_div_add_atTop (1 + s)","rw [GammaSeq_tendsto_Gamma, GammaSeq_tendsto_Gamma]"
Mathlib/RingTheory/Polynomial/Chebyshev.lean,Polynomial.Chebyshev.mul_T,mul_T,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  induction k using Polynomial.Chebyshev.induct with
  | zero => simp [two_mul]
  | one => rw [T_add_one, T_one]; ring
  | add_two k ih1 ih2 =>
    have hâ‚ := T_add_two R (m + k)
    have hâ‚‚ := T_sub_two R (m - k)
    have hâ‚ƒ := T_add_two R k
    linear_combination (norm : = ring_nf) 2 * T R m * hâ‚ƒ - hâ‚‚ - hâ‚ - ih2 + 2 * (X : R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have hâ‚ := T_add_two R (m + (-k - 1))
    have hâ‚‚ := T_sub_two R (m - (-k - 1))
    have hâ‚ƒ := T_add_two R (-k - 1)
    linear_combination (norm : = ring_nf) 2 * T R m * hâ‚ƒ - hâ‚‚ - hâ‚ - ih2 + 2 * (X : R[X]) * ih1",error:  unexpected token '='; expected ')' or term,theorem mul_T (m k : â„¤) : 2 * T R m * T R k = T R (m + k) + T R (m - k) ,":= by
  induction k using Polynomial.Chebyshev.induct with
  | zero => simp [two_mul]
  | one => rw [T_add_one, T_one]; ring
  | add_two k ih1 ih2 =>
    have hâ‚ := T_add_two R (m + k)
    have hâ‚‚ := T_sub_two R (m - k)
    have hâ‚ƒ := T_add_two R k
    linear_combination (norm := ring_nf) 2 * T R m * hâ‚ƒ - hâ‚‚ - hâ‚ - ih2 + 2 * (X:R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have hâ‚ := T_add_two R (m + (-k - 1))
    have hâ‚‚ := T_sub_two R (m - (-k - 1))
    have hâ‚ƒ := T_add_two R (-k - 1)
    linear_combination (norm := ring_nf) 2 * T R m * hâ‚ƒ - hâ‚‚ - hâ‚ - ih2 + 2 * (X:R[X]) * ih1",have hâ‚ := T_sub_two R (m - k)
Mathlib/MeasureTheory/Measure/Hausdorff.lean,LipschitzOnWith.hausdorffMeasure_image_le,hausdorffMeasure_image_le,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine' iSup_le fun R => iSup_le fun hR => _
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine' ENNReal.tsum_le_tsum fun n => _
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left s) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set X : Type u_2
but is expected to have type
  ?m.169595 âˆˆ t n âˆ© ?m.169594 : Prop
error:  simp made no progress","theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s ",":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","rw [â† hausdorffMeasure_image_le, hausdorffMeasure_image_le, hausdorffMeasure_image_le]"
Mathlib/Topology/Algebra/StarSubalgebra.lean,StarSubalgebra.closedEmbedding_inclusion,closedEmbedding_inclusion,6b3f3fe208f0cdce581d713270301bed755856ed,":=
  { embedding_inclusion h with
    closed_range := isClosed_induced_iff.2
      âŸ¨Sâ‚, hSâ‚, by
          convert (Set.range_subtype_map id _).symm
          Â· rw [Set.image_id]; rfl
          Â· intro _ h'
            apply h h' âŸ© }",error:  'closed_range' is not a field of structure 'ClosedEmbedding',"theorem closedEmbedding_inclusion {Sâ‚ Sâ‚‚ : StarSubalgebra R A} (h : Sâ‚ â‰¤ Sâ‚‚)
    (hSâ‚ : IsClosed (Sâ‚ : Set A)) : ClosedEmbedding (inclusion h) ",":=
  { embedding_inclusion h with
    isClosed_range := isClosed_induced_iff.2
      âŸ¨Sâ‚, hSâ‚, by
          convert (Set.range_subtype_map id _).symm
          Â· rw [Set.image_id]; rfl
          Â· intro _ h'
            apply h h' âŸ© }",have hSâ‚‚ : IsClosed (inclusion h) := hSâ‚.isClosed_closedEmbedding
Mathlib/Data/Seq/Parallel.lean,Computation.map_parallel,map_parallel,3c930599229893e1b6a931304cf4efff4a01b172,":= by
  refine
    eq_of_bisim
      (fun c1 c2 =>
        âˆƒ l S,
          c1 = map f (corec parallel.aux1 (l, WSeq.data S)) âˆ§
            c2 = corec parallel.aux1 (l.map (map f), WSeq.data (S.map (map f))))
      ?_ âŸ¨[], S, rfl, rflâŸ©
  intro c1 c2 h
  rcases h with âŸ¨l, S, rfl, rflâŸ©
  have : parallel.aux2 (l.map (map f))
      = Sum.map f (List.map (map f)) (parallel.aux2 l) := by
    simp [parallel.aux2]
    induction' l with c l IH <;> simp
    rw [IH]
    cases List.foldr (fun c o =>
        match o with
        | Sum.inl a => Sum.inl a
        | Sum.inr ls => Sum.map id (Â· :: ls) (dest c)) (Sum.inr []) l <;>
      simp [parallel.aux2]
    cases dest c <;> simp
  simp [parallel.aux1]
  rw [this]
  cases' parallel.aux2 l with a l' <;> simp
  induction' S using WSeq.recOn' with c S S <;> simp <;> exact âŸ¨_, _, rfl, rflâŸ©","error:  unknown constant 'Stream'.WSeq.data'
error:  unknown constant 'Stream'.WSeq.data'
error:  application type mismatch
  Sum.map id fun x x â†¦ x :: ls
argument
  fun x x â†¦ x :: ls
has type
  ?m.22826 â†’ ?m.21875 â†’ List ?m.21875 : Type (max ?u.21874 ?u.22821)
but is expected to have type
  ?m.22826 â†’ List ?m.21875 : Type (max ?u.21874 ?u.22821)
error:  unknown identifier 'dest'
error:  simp made no progress
error:  simp made no progress
error:  unknown identifier 'dest'
error:  tactic 'induction' failed, major premise type is not an inductive type 
  ?m.24635
case cons.inl
Î± : Type u
Î² : Type v
f : Î± â†’ Î²
Sâœ S : WSeq (Computation Î±)
c : Computation Î±
l : List (Computation Î±)
IH :
  List.foldr
      (fun c o â†¦
        match o with
        | Sum.inl a => Sum.inl a
        | Sum.inr ls =>
          match c.destruct with
          | Sum.inl a => Sum.inl a
          | Sum.inr b => Sum.inr (b :: ls))
      (Sum.inr []) (List.map (map f) l) =
    Sum.map f (List.map (map f))
      (List.foldr
        (fun c o â†¦
          match o with
          | Sum.inl a => Sum.inl a
          | Sum.inr ls =>
            match c.destruct with
            | Sum.inl a => Sum.inl a
            | Sum.inr b => Sum.inr (b :: ls))
        (Sum.inr []) l)
valâœ : ?m.23292
xâœ : ?m.24635
âŠ¢ (match
      Sum.map f (List.map (map f))
        (List.foldr
          (fun c o â†¦
            match o with
            | Sum.inl a => Sum.inl a
            | Sum.inr ls =>
              match c.destruct with
              | Sum.inl a => Sum.inl a
              | Sum.inr b => Sum.inr (b :: ls))
          (Sum.inr []) l) with
    | Sum.inl a => Sum.inl a
    | Sum.inr ls =>
      match
        match
          match c.destruct with
          | Sum.inl a => Sum.inl a
          | Sum.inr b => Sum.inr (map f b) with
        | Sum.inl a => Sum.inl (f a)
        | Sum.inr b => Sum.inr b with
      | Sum.inl a => Sum.inl a
      | Sum.inr b => Sum.inr (b :: ls)) =
    Sum.map f (List.map (map f))
      (match
        List.foldr
          (fun c o â†¦
            match o with
            | Sum.inl a => Sum.inl a
            | Sum.inr ls =>
              match c.destruct with
              | Sum.inl a => Sum.inl a
              | Sum.inr b => Sum.inr (b :: ls))
          (Sum.inr []) l with
      | Sum.inl a => Sum.inl a
      | Sum.inr ls =>
        match c.destruct with
        | Sum.inl a => Sum.inl a
        | Sum.inr b => Sum.inr (b :: ls))
error:  unknown constant 'Stream'.WSeq.recOn''",theorem map_parallel (f : Î± â†’ Î²) (S) : map f (parallel S) = parallel (S.map (map f)) ,":= by
  refine
    eq_of_bisim
      (fun c1 c2 =>
        âˆƒ l S,
          c1 = map f (corec parallel.aux1 (l, S)) âˆ§
            c2 = corec parallel.aux1 (l.map (map f), S.map (map f)))
      ?_ âŸ¨[], S, rfl, rflâŸ©
  intro c1 c2 h
  exact
    match c1, c2, h with
    | _, _, âŸ¨l, S, rfl, rflâŸ© => by
      have : parallel.aux2 (l.map (map f))
          = lmap f (rmap (List.map (map f)) (parallel.aux2 l)) := by
        simp only [parallel.aux2, rmap, lmap]
        induction' l with c l IH <;> simp
        rw [IH]
        cases List.foldr _ _ _
        Â· simp
        Â· cases destruct c <;> simp
      simp only [BisimO, destruct_map, lmap, rmap, corec_eq, parallel.aux1.eq_1]
      rw [this]
      cases' parallel.aux2 l with a l' <;> simp
      induction' S using WSeq.recOn with c S S <;> simp <;>
        exact âŸ¨_, _, rfl, rflâŸ©","rw [parallel_map, map_parallel]"
Mathlib/Analysis/Convex/Caratheodory.lean,Caratheodory.mem_convexHull_erase,mem_convexHull_erase,2a87032320c8a6441a601ba5b37374ff532cf9b9,":= by
  simp only [Finset.convexHull_eq, mem_setOf_eq] at m âŠ¢
  obtain âŸ¨f, fpos, fsum, rflâŸ© := m
  obtain âŸ¨g, gcombo, gsum, gposâŸ© := exists_nontrivial_relation_sum_zero_of_not_affine_ind h
  replace gpos := exists_pos_of_sum_zero_of_exists_nonzero g gsum gpos
  clear h
  let s := @Finset.filter _ (fun z => 0 < g z) (fun _ => LinearOrder.decidableLT _ _) t
  obtain âŸ¨iâ‚€, mem, wâŸ© : âˆƒ iâ‚€ âˆˆ s, âˆ€ i âˆˆ s, f iâ‚€ / g iâ‚€ â‰¤ f i / g i := by
    apply s.exists_min_image fun z => f z / g z
    obtain âŸ¨x, hx, hgxâŸ© : âˆƒ x âˆˆ t, 0 < g x := gpos
    exact âŸ¨x, mem_filter.mpr âŸ¨hx, hgxâŸ©âŸ©
  have hg : 0 < g iâ‚€ := by
    rw [mem_filter] at mem
    exact mem.2
  have hiâ‚€ : iâ‚€ âˆˆ t := filter_subset _ _ mem
  let k : E â†’ ğ•œ := fun z => f z - f iâ‚€ / g iâ‚€ * g z
  have hk : k iâ‚€ = 0 := by field_simp [ne_of_gt hg]
  have ksum : (âˆ‘ e in t.erase iâ‚€, k e) = 1 := by
    calc
      (âˆ‘ e in t.erase iâ‚€, k e) = âˆ‘ e in t, k e := by
        conv_rhs => rw [â† insert_erase hiâ‚€, sum_insert (not_mem_erase iâ‚€ t), hk, zero_add]
      _ = âˆ‘ e in t, (f e - f iâ‚€ / g iâ‚€ * g e) := rfl
      _ = 1 := by rw [sum_sub_distrib, fsum, â† mul_sum, gsum, MulZeroClass.mul_zero, sub_zero]
  refine' âŸ¨âŸ¨iâ‚€, hiâ‚€âŸ©, k, _, by convert ksum, _âŸ©
  Â· simp only [and_imp, sub_nonneg, mem_erase, Ne.def, Subtype.coe_mk]
    intro e _ het
    by_cases hes : e âˆˆ s
    Â· have hge : 0 < g e := by
        rw [mem_filter] at hes
        exact hes.2
      rw [â† le_div_iff hge]
      exact w _ hes
    Â· calc
        _ â‰¤ 0 := by
          apply mul_nonpos_of_nonneg_of_nonpos
          Â· apply div_nonneg (fpos iâ‚€ (mem_of_subset (filter_subset _ t) mem)) (le_of_lt hg)
          Â· simpa only [mem_filter, het, true_and_iff, not_lt] using hes
        _ â‰¤ f e := fpos e het
  Â· rw [Subtype.coe_mk, centerMass_eq_of_sum_1 _ id ksum]
    calc
      (âˆ‘ e in t.erase iâ‚€, k e â€¢ e) = âˆ‘ e in t, k e â€¢ e := sum_erase _ (by rw [hk, zero_smul])
      _ = âˆ‘ e in t, (f e - f iâ‚€ / g iâ‚€ * g e) â€¢ e := rfl
      _ = t.centerMass f id := by
        simp only [sub_smul, mul_smul, sum_sub_distrib, â† smul_sum, gcombo, smul_zero, sub_zero,
          centerMass, fsum, inv_one, one_smul, id.def]","error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.8233 â†’ ?m.8233 â†’ Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.9488 * g e â‰¤ ?m.9489
case pos
ğ•œ : Type u_1
E : Type u
instâœÂ³ : LinearOrderedField ğ•œ
instâœÂ² : AddCommGroup E
instâœÂ¹ : Module ğ•œ E
instâœ : DecidableEq E
t : Finset E
f : E â†’ ğ•œ
fpos : âˆ€ y âˆˆ t, 0 â‰¤ f y
fsum : âˆ‘ y âˆˆ t, f y = 1
g : E â†’ ğ•œ
gcombo : âˆ‘ e âˆˆ t, g e â€¢ e = 0
gsum : âˆ‘ e âˆˆ t, g e = 0
gpos : âˆƒ i âˆˆ t, 0 < g i
s : Finset E := filter (fun z â†¦ 0 < g z) t
iâ‚€ : E
mem : iâ‚€ âˆˆ s
w : âˆ€ i âˆˆ s, f iâ‚€ / g iâ‚€ â‰¤ f i / g i
hg : 0 < g iâ‚€
hiâ‚€ : iâ‚€ âˆˆ t
k : E â†’ ğ•œ := fun z â†¦ f z - f iâ‚€ / g iâ‚€ * g z
hk : k iâ‚€ = 0
ksum : âˆ‘ e âˆˆ t.erase iâ‚€, k e = 1
e : E
aâœ : e â‰  iâ‚€
het : e âˆˆ t
hes : e âˆˆ s
hge : 0 < g e
âŠ¢ 0 â‰¤ k e
error:  tactic 'apply' failed, failed to unify
  ?a * ?b â‰¤ 0
with
  0 â‰¤ 0
ğ•œ : Type u_1
E : Type u
instâœÂ³ : LinearOrderedField ğ•œ
instâœÂ² : AddCommGroup E
instâœÂ¹ : Module ğ•œ E
instâœ : DecidableEq E
t : Finset E
f : E â†’ ğ•œ
fpos : âˆ€ y âˆˆ t, 0 â‰¤ f y
fsum : âˆ‘ y âˆˆ t, f y = 1
g : E â†’ ğ•œ
gcombo : âˆ‘ e âˆˆ t, g e â€¢ e = 0
gsum : âˆ‘ e âˆˆ t, g e = 0
gpos : âˆƒ i âˆˆ t, 0 < g i
s : Finset E := filter (fun z â†¦ 0 < g z) t
iâ‚€ : E
mem : iâ‚€ âˆˆ s
w : âˆ€ i âˆˆ s, f iâ‚€ / g iâ‚€ â‰¤ f i / g i
hg : 0 < g iâ‚€
hiâ‚€ : iâ‚€ âˆˆ t
k : E â†’ ğ•œ := fun z â†¦ f z - f iâ‚€ / g iâ‚€ * g z
hk : k iâ‚€ = 0
ksum : âˆ‘ e âˆˆ t.erase iâ‚€, k e = 1
e : E
aâœ : e â‰  iâ‚€
het : e âˆˆ t
hes : e âˆ‰ s
âŠ¢ 0 â‰¤ 0
error:  unsolved goals
case neg.calc.step
ğ•œ : Type u_1
E : Type u
instâœÂ³ : LinearOrderedField ğ•œ
instâœÂ² : AddCommGroup E
instâœÂ¹ : Module ğ•œ E
instâœ : DecidableEq E
t : Finset E
f : E â†’ ğ•œ
fpos : âˆ€ y âˆˆ t, 0 â‰¤ f y
fsum : âˆ‘ y âˆˆ t, f y = 1
g : E â†’ ğ•œ
gcombo : âˆ‘ e âˆˆ t, g e â€¢ e = 0
gsum : âˆ‘ e âˆˆ t, g e = 0
gpos : âˆƒ i âˆˆ t, 0 < g i
s : Finset E := filter (fun z â†¦ 0 < g z) t
iâ‚€ : E
mem : iâ‚€ âˆˆ s
w : âˆ€ i âˆˆ s, f iâ‚€ / g iâ‚€ â‰¤ f i / g i
hg : 0 < g iâ‚€
hiâ‚€ : iâ‚€ âˆˆ t
k : E â†’ ğ•œ := fun z â†¦ f z - f iâ‚€ / g iâ‚€ * g z
hk : k iâ‚€ = 0
ksum : âˆ‘ e âˆˆ t.erase iâ‚€, k e = 1
e : E
aâœ : e â‰  iâ‚€
het : e âˆˆ t
hes : e âˆ‰ s
âŠ¢ f e â‰¤ k e
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.14169 â†’ ?m.14169
error:  unsolved goals
ğ•œ : Type u_1
E : Type u
instâœÂ³ : LinearOrderedField ğ•œ
instâœÂ² : AddCommGroup E
instâœÂ¹ : Module ğ•œ E
instâœ : DecidableEq E
t : Finset E
f : E â†’ ğ•œ
fpos : âˆ€ y âˆˆ t, 0 â‰¤ f y
fsum : âˆ‘ y âˆˆ t, f y = 1
g : E â†’ ğ•œ
gcombo : âˆ‘ e âˆˆ t, g e â€¢ e = 0
gsum : âˆ‘ e âˆˆ t, g e = 0
gpos : âˆƒ i âˆˆ t, 0 < g i
s : Finset E := filter (fun z â†¦ 0 < g z) t
iâ‚€ : E
mem : iâ‚€ âˆˆ s
w : âˆ€ i âˆˆ s, f iâ‚€ / g iâ‚€ â‰¤ f i / g i
hg : 0 < g iâ‚€
hiâ‚€ : iâ‚€ âˆˆ t
k : E â†’ ğ•œ := fun z â†¦ f z - f iâ‚€ / g iâ‚€ * g z
hk : k iâ‚€ = 0
ksum : âˆ‘ e âˆˆ t.erase iâ‚€, k e = 1
âŠ¢ âˆ‘ x âˆˆ t, f x â€¢ x = âˆ‘ i âˆˆ t, f i â€¢ id i","theorem mem_convexHull_erase [DecidableEq E] {t : Finset E} (h : Â¬AffineIndependent ğ•œ ((â†‘) : t â†’ E))
    {x : E} (m : x âˆˆ convexHull ğ•œ (â†‘t : Set E)) :
    âˆƒ y : (â†‘t : Set E), x âˆˆ convexHull ğ•œ (â†‘(t.erase y) : Set E) ",":= by
  simp only [Finset.convexHull_eq, mem_setOf_eq] at m âŠ¢
  obtain âŸ¨f, fpos, fsum, rflâŸ© := m
  obtain âŸ¨g, gcombo, gsum, gposâŸ© := exists_nontrivial_relation_sum_zero_of_not_affine_ind h
  replace gpos := exists_pos_of_sum_zero_of_exists_nonzero g gsum gpos
  clear h
  let s := @Finset.filter _ (fun z => 0 < g z) (fun _ => LinearOrder.decidableLT _ _) t
  obtain âŸ¨iâ‚€, mem, wâŸ© : âˆƒ iâ‚€ âˆˆ s, âˆ€ i âˆˆ s, f iâ‚€ / g iâ‚€ â‰¤ f i / g i := by
    apply s.exists_min_image fun z => f z / g z
    obtain âŸ¨x, hx, hgxâŸ© : âˆƒ x âˆˆ t, 0 < g x := gpos
    exact âŸ¨x, mem_filter.mpr âŸ¨hx, hgxâŸ©âŸ©
  have hg : 0 < g iâ‚€ := by
    rw [mem_filter] at mem
    exact mem.2
  have hiâ‚€ : iâ‚€ âˆˆ t := filter_subset _ _ mem
  let k : E â†’ ğ•œ := fun z => f z - f iâ‚€ / g iâ‚€ * g z
  have hk : k iâ‚€ = 0 := by field_simp [k, ne_of_gt hg]
  have ksum : âˆ‘ e âˆˆ t.erase iâ‚€, k e = 1 := by
    calc
      âˆ‘ e âˆˆ t.erase iâ‚€, k e = âˆ‘ e âˆˆ t, k e := by
        conv_rhs => rw [â† insert_erase hiâ‚€, sum_insert (not_mem_erase iâ‚€ t), hk, zero_add]
      _ = âˆ‘ e âˆˆ t, (f e - f iâ‚€ / g iâ‚€ * g e) := rfl
      _ = 1 := by rw [sum_sub_distrib, fsum, â† mul_sum, gsum, mul_zero, sub_zero]
  refine âŸ¨âŸ¨iâ‚€, hiâ‚€âŸ©, k, ?_, by convert ksum, ?_âŸ©
  Â· simp only [k, and_imp, sub_nonneg, mem_erase, Ne, Subtype.coe_mk]
    intro e _ het
    by_cases hes : e âˆˆ s
    Â· have hge : 0 < g e := by
        rw [mem_filter] at hes
        exact hes.2
      rw [â† le_div_iff hge]
      exact w _ hes
    Â· calc
        _ â‰¤ 0 := by
          apply mul_nonpos_of_nonneg_of_nonpos
          Â· apply div_nonneg (fpos iâ‚€ (mem_of_subset (filter_subset _ t) mem)) (le_of_lt hg)
          Â· simpa only [s, mem_filter, het, true_and_iff, not_lt] using hes
        _ â‰¤ f e := fpos e het
  Â· rw [Subtype.coe_mk, centerMass_eq_of_sum_1 _ id ksum]
    calc
      âˆ‘ e âˆˆ t.erase iâ‚€, k e â€¢ e = âˆ‘ e âˆˆ t, k e â€¢ e := sum_erase _ (by rw [hk, zero_smul])
      _ = âˆ‘ e âˆˆ t, (f e - f iâ‚€ / g iâ‚€ * g e) â€¢ e := rfl
      _ = t.centerMass f id := by
        simp only [sub_smul, mul_smul, sum_sub_distrib, â† smul_sum, gcombo, smul_zero, sub_zero,
          centerMass, fsum, inv_one, one_smul, id]","simp only [convexHull_erase, mem_convexHull_erase] at m"
Mathlib/MeasureTheory/Integral/Lebesgue.lean,MeasureTheory.lintegral_tendsto_of_tendsto_of_monotone,lintegral_tendsto_of_tendsto_of_monotone,1c91c2706a3ccd891c3dcb859d92f31890fa3090,":= by
  have : Monotone fun n => âˆ«â» x, f n x âˆ‚Î¼ := fun i j hij =>
    lintegral_mono_ae (h_mono.mono fun x hx => hx hij)
  suffices key : âˆ«â» x, F x âˆ‚Î¼ = â¨† n, âˆ«â» x, f n x âˆ‚Î¼
  Â· rw [key]
    exact tendsto_atTop_iSup this
  rw [â† lintegral_iSup' hf h_mono]
  refine' lintegral_congr_ae _
  filter_upwards [h_mono,
    h_tendsto] with _ hx_mono hx_tendsto using tendsto_nhds_unique hx_tendsto
      (tendsto_atTop_iSup hx_mono)","warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
error:  unexpected token 'Â·'; expected 'by' or 'from'","theorem lintegral_tendsto_of_tendsto_of_monotone {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} {F : Î± â†’ â„â‰¥0âˆ}
    (hf : âˆ€ n, AEMeasurable (f n) Î¼) (h_mono : âˆ€áµ x âˆ‚Î¼, Monotone fun n => f n x)
    (h_tendsto : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => f n x) atTop (ğ“ <| F x)) :
    Tendsto (fun n => âˆ«â» x, f n x âˆ‚Î¼) atTop (ğ“ <| âˆ«â» x, F x âˆ‚Î¼) ",":= by
  have : Monotone fun n => âˆ«â» x, f n x âˆ‚Î¼ := fun i j hij =>
    lintegral_mono_ae (h_mono.mono fun x hx => hx hij)
  suffices key : âˆ«â» x, F x âˆ‚Î¼ = â¨† n, âˆ«â» x, f n x âˆ‚Î¼ by
    rw [key]
    exact tendsto_atTop_iSup this
  rw [â† lintegral_iSup' hf h_mono]
  refine lintegral_congr_ae ?_
  filter_upwards [h_mono, h_tendsto] with _ hx_mono hx_tendsto using
    tendsto_nhds_unique hx_tendsto (tendsto_atTop_iSup hx_mono)",rw [tendsto_lintegral_tendsto_of_tendsto_of_monotone hf h_mono h_tendsto]
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux,addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux,49cb73bac1b838aa7ba8d29f180ec1242e6d7e71,":= by
  rcases eq_empty_or_nonempty s with (rfl | h's); Â· simp only [measure_empty, zero_le, image_empty]
  have :
      âˆ€ A : E â†’L[â„] E, âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§
        âˆ€ (t : Set E), ApproximatesLinearOn f A t Î´ â†’
          Î¼ (f '' t) â‰¤ (Real.toNNReal |A.det| + Îµ : â„â‰¥0) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, h'âŸ©
    exact âŸ¨Î´, h', fun t ht => h t f htâŸ©
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, Af'âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := (measure_iUnion_le _)
    _ â‰¤ âˆ‘' n, (Real.toNNReal |(A n).det| + Îµ : â„â‰¥0) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2
      exact ht n
    _ = âˆ‘' n, Îµ * Î¼ (s âˆ© t n) := by
      congr with n
      rcases Af' h's n with âŸ¨y, ys, hyâŸ©
      simp only [hy, h'f' y ys, Real.toNNReal_zero, abs_zero, zero_add]
    _ â‰¤ Îµ * âˆ‘' n, Î¼ (closedBall 0 R âˆ© t n) := by
      rw [ENNReal.tsum_mul_left]
      refine' mul_le_mul_left' (ENNReal.tsum_le_tsum fun n => measure_mono _) _
      exact inter_subset_inter_left _ hs
    _ = Îµ * Î¼ (â‹ƒ n, closedBall 0 R âˆ© t n) := by
      rw [measure_iUnion]
      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right _ _
      Â· intro n
        exact measurableSet_closedBall.inter (t_meas n)
    _ â‰¤ Îµ * Î¼ (closedBall 0 R) := by
      rw [â† inter_iUnion]
      exact mul_le_mul_left' (measure_mono (inter_subset_left _ _)) _","error:  function expected at
  inter_subset_right ?m.329486
term has type
  ?m.329485 âˆˆ ?m.329484
error:  function expected at
  inter_subset_left ?m.330114
term has type
  ?m.330113 âˆˆ ?m.330111","theorem addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (R : â„) (hs : s âŠ† closedBall 0 R) (Îµ : â„â‰¥0)
    (Îµpos : 0 < Îµ) (h'f' : âˆ€ x âˆˆ s, (f' x).det = 0) : Î¼ (f '' s) â‰¤ Îµ * Î¼ (closedBall 0 R) ",":= by
  rcases eq_empty_or_nonempty s with (rfl | h's); Â· simp only [measure_empty, zero_le, image_empty]
  have :
      âˆ€ A : E â†’L[â„] E, âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§
        âˆ€ (t : Set E), ApproximatesLinearOn f A t Î´ â†’
          Î¼ (f '' t) â‰¤ (Real.toNNReal |A.det| + Îµ : â„â‰¥0) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, h'âŸ©
    exact âŸ¨Î´, h', fun t ht => h t f htâŸ©
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, Af'âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      rw [â† image_iUnion, â† inter_iUnion]
      gcongr
      exact subset_inter Subset.rfl t_cover
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Real.toNNReal |(A n).det| + Îµ : â„â‰¥0) * Î¼ (s âˆ© t n) := by
      gcongr
      exact (hÎ´ (A _)).2 _ (ht _)
    _ = âˆ‘' n, Îµ * Î¼ (s âˆ© t n) := by
      congr with n
      rcases Af' h's n with âŸ¨y, ys, hyâŸ©
      simp only [hy, h'f' y ys, Real.toNNReal_zero, abs_zero, zero_add]
    _ â‰¤ Îµ * âˆ‘' n, Î¼ (closedBall 0 R âˆ© t n) := by
      rw [ENNReal.tsum_mul_left]
      gcongr
    _ = Îµ * Î¼ (â‹ƒ n, closedBall 0 R âˆ© t n) := by
      rw [measure_iUnion]
      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
      Â· intro n
        exact measurableSet_closedBall.inter (t_meas n)
    _ â‰¤ Îµ * Î¼ (closedBall 0 R) := by
      rw [â† inter_iUnion]
      exact mul_le_mul_left' (measure_mono inter_subset_left) _",have : Î¼ (closedBall 0 R) âŠ† closedBall 0 R := closedBall_subset_closedBall_subset
Mathlib/AlgebraicTopology/DoldKan/Faces.lean,AlgebraicTopology.DoldKan.HigherFacesVanish.comp_HÏƒ_eq_zero,comp_HÏƒ_eq_zero,5facde50581cefe36eb491a50b05917b86b8b861,":= by
  simp only [HÏƒ, Homotopy.nullHomotopicMap'_f (c_mk (n + 2) (n + 1) rfl) (c_mk (n + 1) n rfl)]
  rw [hÏƒ'_eq_zero hqn (c_mk (n + 1) n rfl), comp_zero, zero_add]
  by_cases hqn' : n + 1 < q
  Â· rw [hÏƒ'_eq_zero hqn' (c_mk (n + 2) (n + 1) rfl), zero_comp, comp_zero]
  Â· simp only [hÏƒ'_eq (show n + 1 = 0 + q by omega) (c_mk (n + 2) (n + 1) rfl), pow_zero,
      Fin.mk_zero, one_zsmul, eqToHom_refl, comp_id, comp_sum,
      AlternatingFaceMapComplex.obj_d_eq]
    rw [â† Fin.sum_congr' _ (show 2 + (n + 1) = n + 1 + 2 by omega), Fin.sum_trunc]
    Â· simp only [Fin.sum_univ_castSucc, Fin.sum_univ_zero, zero_add, Fin.last, Fin.castLE_mk,
        Fin.cast_mk, Fin.castSucc_mk]
      simp only [Fin.mk_zero, Fin.val_zero, pow_zero, one_zsmul, Fin.mk_one, Fin.val_one, pow_one,
        neg_smul, comp_neg]
      erw [Î´_comp_Ïƒ_self, Î´_comp_Ïƒ_succ, add_right_neg]
    Â· intro j
      dsimp [Fin.cast, Fin.castLE, Fin.castLT]
      rw [comp_zsmul, comp_zsmul, Î´_comp_Ïƒ_of_gt', v.comp_Î´_eq_zero_assoc, zero_comp, zsmul_zero]
      Â· intro h
        simp only [Fin.pred, Fin.subNat, Fin.ext_iff, Nat.succ_add_sub_one,
          Fin.val_zero, add_eq_zero, false_and] at h
      Â· simp only [Fin.pred, Fin.subNat, Nat.pred_eq_sub_one, Nat.succ_add_sub_one]
        omega
      Â· simp only [Fin.lt_iff_val_lt_val]
        dsimp [Fin.succ]
        omega","error:  tactic 'introN' failed, insufficient number of binders
case neg.hf.H
C : Type u_1
instâœÂ¹ : Category.{u_2, u_1} C
instâœ : Preadditive C
X : SimplicialObject C
Y : C
n q : â„•
Ï† : Y âŸ¶ X _[n + 1]
v : HigherFacesVanish q Ï†
hqn : n < q
hqn' : Â¬n + 1 < q
j : Fin (n + 1)
âŠ¢ Fin.succ 0 < âŸ¨2 + â†‘j, â‹¯âŸ©
error:  simp made no progress","theorem comp_HÏƒ_eq_zero {Y : C} {n q : â„•} {Ï† : Y âŸ¶ X _[n + 1]} (v : HigherFacesVanish q Ï†)
    (hqn : n < q) : Ï† â‰« (HÏƒ q).f (n + 1) = 0 ",":= by
  simp only [HÏƒ, Homotopy.nullHomotopicMap'_f (c_mk (n + 2) (n + 1) rfl) (c_mk (n + 1) n rfl)]
  rw [hÏƒ'_eq_zero hqn (c_mk (n + 1) n rfl), comp_zero, zero_add]
  by_cases hqn' : n + 1 < q
  Â· rw [hÏƒ'_eq_zero hqn' (c_mk (n + 2) (n + 1) rfl), zero_comp, comp_zero]
  Â· simp only [hÏƒ'_eq (show n + 1 = 0 + q by omega) (c_mk (n + 2) (n + 1) rfl), pow_zero,
      Fin.mk_zero, one_zsmul, eqToHom_refl, comp_id, comp_sum,
      AlternatingFaceMapComplex.obj_d_eq]
    rw [â† Fin.sum_congr' _ (show 2 + (n + 1) = n + 1 + 2 by omega), Fin.sum_trunc]
    Â· simp only [Fin.sum_univ_castSucc, Fin.sum_univ_zero, zero_add, Fin.last, Fin.castLE_mk,
        Fin.cast_mk, Fin.castSucc_mk]
      simp only [Fin.mk_zero, Fin.val_zero, pow_zero, one_zsmul, Fin.mk_one, Fin.val_one, pow_one,
        neg_smul, comp_neg]
      erw [Î´_comp_Ïƒ_self, Î´_comp_Ïƒ_succ, add_right_neg]
    Â· intro j
      dsimp [Fin.cast, Fin.castLE, Fin.castLT]
      rw [comp_zsmul, comp_zsmul, Î´_comp_Ïƒ_of_gt', v.comp_Î´_eq_zero_assoc, zero_comp, zsmul_zero]
      Â· simp only [Fin.lt_iff_val_lt_val]
        dsimp [Fin.succ]
        omega
      Â· intro h
        simp only [Fin.pred, Fin.subNat, Fin.ext_iff, Nat.succ_add_sub_one,
          Fin.val_zero, add_eq_zero, false_and] at h
      Â· simp only [Fin.pred, Fin.subNat, Nat.pred_eq_sub_one, Nat.succ_add_sub_one]
        omega","simp only [HÏƒ, HigherFacesVanish.comp_HÏƒ_eq_zero, comp_HÏƒ_eq_zero, comp_HÏƒ_eq_zero]"
Mathlib/Topology/Metrizable/Uniformity.lean,PseudoMetricSpace.le_two_mul_dist_ofPreNNDist,le_two_mul_dist_ofPreNNDist,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  rw [dist_ofPreNNDist, â† NNReal.coe_two, â† NNReal.coe_mul, NNReal.mul_iInf, NNReal.coe_le_coe]
  refine le_ciInf fun l => ?_
  have hdâ‚€_trans : Transitive fun x y => d x y = 0 := by
    intro a b c hab hbc
    rw [â† nonpos_iff_eq_zero]
    simpa only [nonpos_iff_eq_zero, hab, hbc, dist_self c, max_self, mul_zero] using hd a b c c
  haveI : IsTrans X fun x y => d x y = 0 := âŸ¨hdâ‚€_transâŸ©
  induction' hn : length l using Nat.strong_induction_on with n ihn generalizing x y l
  simp only at ihn
  subst n
  set L := zipWith d (x::l) (l ++ [y])
  have hL_len : length L = length l + 1 := by simp [L]
  rcases eq_or_ne (d x y) 0 with hdâ‚€ | hdâ‚€
  Â· simp only [hdâ‚€, zero_le]
  rsuffices âŸ¨z, z', hxz, hzz', hz'yâŸ© : âˆƒ z z' : X, d x z â‰¤ L.sum âˆ§ d z z' â‰¤ L.sum âˆ§ d z' y â‰¤ L.sum
  Â· exact (hd x z z' y).trans (mul_le_mul_left' (max_le hxz (max_le hzz' hz'y)) _)
  set s : Set â„• := { m : â„• | 2 * (take m L).sum â‰¤ L.sum }
  have hsâ‚€ : 0 âˆˆ s := by simp [s]
  have hsne : s.Nonempty := âŸ¨0, hsâ‚€âŸ©
  obtain âŸ¨M, hMl, hMsâŸ© : âˆƒ M â‰¤ length l, IsGreatest s M := by
    have hs_ub : length l âˆˆ upperBounds s := by
      intro m hm
      rw [â† not_lt, Nat.lt_iff_add_one_le, â† hL_len]
      intro hLm
      rw [mem_setOf_eq, take_all_of_le hLm, two_mul, add_le_iff_nonpos_left, nonpos_iff_eq_zero,
          sum_eq_zero_iff, â† forall_iff_forall_mem, forall_zipWith,
          â† chain_append_singleton_iff_forallâ‚‚]
          at hm <;>
        [skip; simp]
      exact hdâ‚€ (hm.rel (mem_append.2 <| Or.inr <| mem_singleton_self _))
    have hs_bdd : BddAbove s := âŸ¨length l, hs_ubâŸ©
    exact âŸ¨sSup s, csSup_le hsne hs_ub, âŸ¨Nat.sSup_mem hsne hs_bdd, fun k => le_csSup hs_bddâŸ©âŸ©
  have hM_lt : M < length L := by rwa [hL_len, Nat.lt_succ_iff]
  have hM_ltx : M < length (x::l) := lt_length_left_of_zipWith hM_lt
  have hM_lty : M < length (l ++ [y]) := lt_length_right_of_zipWith hM_lt
  refine âŸ¨(x::l).get âŸ¨M, hM_ltxâŸ©, (l ++ [y]).get âŸ¨M, hM_ltyâŸ©, ?_, ?_?, _âŸ©
  Â· cases M with
    | zero =>
      simp [dist_self, List.get]
    | succ M =>
      rw [Nat.succ_le_iff] at hMl
      have hMl' : length (take M l) = M := (length_take _ _).trans (min_eq_left hMl.le)
      simp only [List.get]
      refine (ihn _ hMl _ _ _ hMl').trans ?_
      convert hMs.1.out
      rw [zipWith_distrib_take, take, take_succ, get?_append hMl, get?_eq_get hMl, â† Option.coe_def,
        Option.toList_some, take_append_of_le_length hMl.le]
  Â· exact single_le_sum (fun x _ => zero_le x) _ (mem_iff_get.2 âŸ¨âŸ¨M, hM_ltâŸ©, get_zipWithâŸ©)
  Â· rcases hMl.eq_or_lt with (rfl | hMl)
    Â· simp only [get_append_right' le_rfl, sub_self, get_singleton, dist_self, zero_le]
    rw [get_append _ hMl]
    have hlen : length (drop (M + 1) l) = length l - (M + 1) := length_drop _ _
    have hlen_lt : length l - (M + 1) < length l := Nat.sub_lt_of_pos_le M.succ_pos hMl
    refine (ihn _ hlen_lt _ y _ hlen).trans ?_
    rw [cons_get_drop_succ]
    have hMs' : L.sum â‰¤ 2 * (L.take (M + 1)).sum :=
      not_lt.1 fun h => (hMs.2 h.le).not_lt M.lt_succ_self
    rw [â† sum_take_add_sum_drop L (M + 1), two_mul, add_le_add_iff_left, â† add_le_add_iff_right,
      sum_take_add_sum_drop, â† two_mul] at hMs'
    convert hMs'
    rwa [zipWith_distrib_drop, drop, drop_append_of_le_length]","error:  don't know how to synthesize placeholder for argument 'right'
context:
X : Type u_1
d : X â†’ X â†’ â„â‰¥0
dist_self : âˆ€ (x : X), d x x = 0
dist_comm : âˆ€ (x y : X), d x y = d y x
hd : âˆ€ (xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ : X), d xâ‚ xâ‚„ â‰¤ 2 * max (d xâ‚ xâ‚‚) (max (d xâ‚‚ xâ‚ƒ) (d xâ‚ƒ xâ‚„))
hdâ‚€_trans : Transitive fun x y â†¦ d x y = 0
this : IsTrans X fun x y â†¦ d x y = 0
x y : X
l : List X
ihn : âˆ€ m < l.length, âˆ€ (x y : X) (l : List X), l.length = m â†’ d x y â‰¤ 2 * (zipWith d (x :: l) (l ++ [y])).sum
L : List â„â‰¥0 := zipWith d (x :: l) (l ++ [y])
hL_len : L.length = l.length + 1
hdâ‚€ : d x y â‰  0
s : Set â„• := {m | 2 * (take m L).sum â‰¤ L.sum}
hsâ‚€ : 0 âˆˆ s
hsne : s.Nonempty
M : â„•
hMl : M â‰¤ l.length
hMs : IsGreatest s M
hM_lt : M < L.length
hM_ltx : M < (x :: l).length
hM_lty : M < (l ++ [y]).length
âŠ¢ d ((l ++ [y]).get âŸ¨M, hM_ltyâŸ©) y â‰¤ L.sum
error:  unsolved goals
case intro.intro
X : Type u_1
d : X â†’ X â†’ â„â‰¥0
dist_self : âˆ€ (x : X), d x x = 0
dist_comm : âˆ€ (x y : X), d x y = d y x
hd : âˆ€ (xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ : X), d xâ‚ xâ‚„ â‰¤ 2 * max (d xâ‚ xâ‚‚) (max (d xâ‚‚ xâ‚ƒ) (d xâ‚ƒ xâ‚„))
hdâ‚€_trans : Transitive fun x y â†¦ d x y = 0
this : IsTrans X fun x y â†¦ d x y = 0
x y : X
l : List X
ihn : âˆ€ m < l.length, âˆ€ (x y : X) (l : List X), l.length = m â†’ d x y â‰¤ 2 * (zipWith d (x :: l) (l ++ [y])).sum
L : List â„â‰¥0 := zipWith d (x :: l) (l ++ [y])
hL_len : L.length = l.length + 1
hdâ‚€ : d x y â‰  0
s : Set â„• := {m | 2 * (take m L).sum â‰¤ L.sum}
hsâ‚€ : 0 âˆˆ s
hsne : s.Nonempty
M : â„•
hMl : M â‰¤ l.length
hMs : IsGreatest s M
hM_lt : M < L.length
hM_ltx : M < (x :: l).length
hM_lty : M < (l ++ [y]).length
âŠ¢ âˆƒ z z', d x z â‰¤ L.sum âˆ§ d z z' â‰¤ L.sum âˆ§ d z' y â‰¤ L.sum","theorem le_two_mul_dist_ofPreNNDist (d : X â†’ X â†’ â„â‰¥0) (dist_self : âˆ€ x, d x x = 0)
    (dist_comm : âˆ€ x y, d x y = d y x)
    (hd : âˆ€ xâ‚ xâ‚‚ xâ‚ƒ xâ‚„, d xâ‚ xâ‚„ â‰¤ 2 * max (d xâ‚ xâ‚‚) (max (d xâ‚‚ xâ‚ƒ) (d xâ‚ƒ xâ‚„))) (x y : X) :
    â†‘(d x y) â‰¤ 2 * @dist X
      (@PseudoMetricSpace.toDist X (PseudoMetricSpace.ofPreNNDist d dist_self dist_comm)) x y ",":= by
  rw [dist_ofPreNNDist, â† NNReal.coe_two, â† NNReal.coe_mul, NNReal.mul_iInf, NNReal.coe_le_coe]
  refine le_ciInf fun l => ?_
  have hdâ‚€_trans : Transitive fun x y => d x y = 0 := by
    intro a b c hab hbc
    rw [â† nonpos_iff_eq_zero]
    simpa only [nonpos_iff_eq_zero, hab, hbc, dist_self c, max_self, mul_zero] using hd a b c c
  haveI : IsTrans X fun x y => d x y = 0 := âŸ¨hdâ‚€_transâŸ©
  induction' hn : length l using Nat.strong_induction_on with n ihn generalizing x y l
  simp only at ihn
  subst n
  set L := zipWith d (x::l) (l ++ [y])
  have hL_len : length L = length l + 1 := by simp [L]
  rcases eq_or_ne (d x y) 0 with hdâ‚€ | hdâ‚€
  Â· simp only [hdâ‚€, zero_le]
  rsuffices âŸ¨z, z', hxz, hzz', hz'yâŸ© : âˆƒ z z' : X, d x z â‰¤ L.sum âˆ§ d z z' â‰¤ L.sum âˆ§ d z' y â‰¤ L.sum
  Â· exact (hd x z z' y).trans (mul_le_mul_left' (max_le hxz (max_le hzz' hz'y)) _)
  set s : Set â„• := { m : â„• | 2 * (take m L).sum â‰¤ L.sum }
  have hsâ‚€ : 0 âˆˆ s := by simp [s]
  have hsne : s.Nonempty := âŸ¨0, hsâ‚€âŸ©
  obtain âŸ¨M, hMl, hMsâŸ© : âˆƒ M â‰¤ length l, IsGreatest s M := by
    have hs_ub : length l âˆˆ upperBounds s := by
      intro m hm
      rw [â† not_lt, Nat.lt_iff_add_one_le, â† hL_len]
      intro hLm
      rw [mem_setOf_eq, take_all_of_le hLm, two_mul, add_le_iff_nonpos_left, nonpos_iff_eq_zero,
          sum_eq_zero_iff, â† forall_iff_forall_mem, forall_zipWith,
          â† chain_append_singleton_iff_forallâ‚‚]
          at hm <;>
        [skip; simp]
      exact hdâ‚€ (hm.rel (mem_append.2 <| Or.inr <| mem_singleton_self _))
    have hs_bdd : BddAbove s := âŸ¨length l, hs_ubâŸ©
    exact âŸ¨sSup s, csSup_le hsne hs_ub, âŸ¨Nat.sSup_mem hsne hs_bdd, fun k => le_csSup hs_bddâŸ©âŸ©
  have hM_lt : M < length L := by rwa [hL_len, Nat.lt_succ_iff]
  have hM_ltx : M < length (x::l) := lt_length_left_of_zipWith hM_lt
  have hM_lty : M < length (l ++ [y]) := lt_length_right_of_zipWith hM_lt
  refine âŸ¨(x::l)[M], (l ++ [y])[M], ?_, ?_, ?_âŸ©
  Â· cases M with
    | zero =>
      simp [dist_self, List.get]
    | succ M =>
      rw [Nat.succ_le_iff] at hMl
      have hMl' : length (take M l) = M := (length_take _ _).trans (min_eq_left hMl.le)
      refine (ihn _ hMl _ _ _ hMl').trans ?_
      convert hMs.1.out
      rw [zipWith_distrib_take, take, take_succ, getElem?_append hMl, getElem?_eq_getElem hMl,
        â† Option.coe_def, Option.toList_some, take_append_of_le_length hMl.le, getElem_cons_succ]
  Â· exact single_le_sum (fun x _ => zero_le x) _ (mem_iff_get.2 âŸ¨âŸ¨M, hM_ltâŸ©, getElem_zipWithâŸ©)
  Â· rcases hMl.eq_or_lt with (rfl | hMl)
    Â· simp only [getElem_append_right' le_rfl, sub_self, getElem_singleton, dist_self, zero_le]
    rw [getElem_append _ hMl]
    have hlen : length (drop (M + 1) l) = length l - (M + 1) := length_drop _ _
    have hlen_lt : length l - (M + 1) < length l := Nat.sub_lt_of_pos_le M.succ_pos hMl
    refine (ihn _ hlen_lt _ y _ hlen).trans ?_
    rw [cons_getElem_drop_succ]
    have hMs' : L.sum â‰¤ 2 * (L.take (M + 1)).sum :=
      not_lt.1 fun h => (hMs.2 h.le).not_lt M.lt_succ_self
    rw [â† sum_take_add_sum_drop L (M + 1), two_mul, add_le_add_iff_left, â† add_le_add_iff_right,
      sum_take_add_sum_drop, â† two_mul] at hMs'
    convert hMs'
    rwa [zipWith_distrib_drop, drop, drop_append_of_le_length]",refine theorem_theorem le_two_mul_dist_ofPreNNDist le_two_mul_dist_ofPreNNDist le_two_mul_dist
Mathlib/Topology/Bases.lean,TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds,isTopologicalBasis_of_isOpen_of_nhds,14580a34773ef6b2f1e5f307031f50c0a6d85dbb,":= by
  refine'
    âŸ¨fun tâ‚ htâ‚ tâ‚‚ htâ‚‚ x hx => h_nhds _ _ hx (IsOpen.inter (h_open _ htâ‚) (h_open _ htâ‚‚)), _, _âŸ©
  Â· refine' sUnion_eq_univ_iff.2 fun a => _
    rcases h_nhds a univ trivial isOpen_univ with âŸ¨u, hâ‚, hâ‚‚, -âŸ©
    exact âŸ¨u, hâ‚, hâ‚‚âŸ©
  Â· refine' (le_generateFrom h_open).antisymm fun u hu => _
    refine' (@isOpen_iff_nhds Î± (generateFrom s) u).mpr fun a ha => _
    rcases h_nhds a u ha hu with âŸ¨v, hvs, hav, hvuâŸ©
    rw [nhds_generateFrom]
    exact iInfâ‚‚_le_of_le v âŸ¨hav, hvsâŸ© (le_principal_iff.2 hvu)","error:  application type mismatch
  @isOpen_iff_nhds Î± (generateFrom s)
argument
  generateFrom s
has type
  TopologicalSpace Î± : Type u
but is expected to have type
  Set Î± : Type u","theorem isTopologicalBasis_of_isOpen_of_nhds {s : Set (Set Î±)} (h_open : âˆ€ u âˆˆ s, IsOpen u)
    (h_nhds : âˆ€ (a : Î±) (u : Set Î±), a âˆˆ u â†’ IsOpen u â†’ âˆƒ v âˆˆ s, a âˆˆ v âˆ§ v âŠ† u) :
    IsTopologicalBasis s ",":=
  .of_hasBasis_nhds <| fun a â†¦
    (nhds_basis_opens a).to_hasBasis' (by simpa [and_assoc] using h_nhds a)
      fun t âŸ¨hts, hatâŸ© â†¦ (h_open _ hts).mem_nhds hat",refine isTopologicalBasis_of_isTopologicalBasis_of_isOpen_of_isTopologicalBasis.isTopologicalBasis.isTopologicalBasis
Mathlib/Algebra/Lie/BaseChange.lean,LieSubmodule.lie_baseChange,lie_baseChange,fc0107e21675a8298fc7ac3cc6e26f680430b1b5,":= by
  set s : Set (A âŠ—[R] M) := { m | âˆƒ x âˆˆ I, âˆƒ n âˆˆ N, 1 âŠ—â‚œ â…x, nâ† = m}
  have : (TensorProduct.mk R A M 1) '' {m | âˆƒ x âˆˆ I, âˆƒ n âˆˆ N, â…x, nâ† = m} = s := by ext; simp
  rw [â† coe_toSubmodule_eq_iff, coe_baseChange, lieIdeal_oper_eq_linear_span',
    Submodule.baseChange_span, this, lieIdeal_oper_eq_linear_span']
  refine le_antisymm (Submodule.span_mono ?_) (Submodule.span_le.mpr ?_)
  Â· rintro - âŸ¨x, hx, m, hm, rflâŸ©
    exact âŸ¨1 âŠ—â‚œ x, tmul_mem_baseChange_of_mem 1 hx,
           1 âŠ—â‚œ m, tmul_mem_baseChange_of_mem 1 hm, by simpâŸ©
  Â· rintro - âŸ¨x, hx, m, hm, rflâŸ©
    revert m
    apply Submodule.span_induction
      (p := fun x' â†¦ âˆ€ m' âˆˆ N.baseChange A, â…x', m'â† âˆˆ Submodule.span A s) hx
    Â· rintro _ âŸ¨y : L, hy : y âˆˆ I, rflâŸ© m hm
      apply Submodule.span_induction (p := fun m' â†¦ â…(1 : A) âŠ—â‚œ[R] y, m'â† âˆˆ Submodule.span A s) hm
      Â· rintro - âŸ¨m', hm' : m' âˆˆ N, rflâŸ©
        rw [TensorProduct.mk_apply, LieAlgebra.ExtendScalars.bracket_tmul, mul_one]
        apply Submodule.subset_span
        exact âŸ¨y, hy, m', hm', rflâŸ©
      Â· simp
      Â· intro u v hu hv
        rw [lie_add]
        exact Submodule.add_mem _ hu hv
      Â· intro a u hu
        rw [lie_smul]
        exact Submodule.smul_mem _ a hu
    Â· simp
    Â· intro x y hx hy m' hm'
      rw [add_lie]
      exact Submodule.add_mem _ (hx _ hm') (hy _ hm')
    Â· intro a x hx m' hm'
      rw [smul_lie]
      exact Submodule.smul_mem _ a (hx _ hm')","error:  unsolved goals
case h
R : Type u_1
A : Type u_2
L : Type u_3
M : Type u_4
instâœâ¸ : CommRing R
instâœâ· : LieRing L
instâœâ¶ : LieAlgebra R L
instâœâµ : AddCommGroup M
instâœâ´ : Module R M
instâœÂ³ : LieRingModule L M
instâœÂ² : LieModule R L M
instâœÂ¹ : CommRing A
instâœ : Algebra R A
Nâœ : LieSubmodule R L M
I : LieIdeal R L
N : LieSubmodule R L M
s : Set (A âŠ—[R] M) := {m | âˆƒ x âˆˆ I, âˆƒ n âˆˆ N, 1 âŠ—â‚œ[R] â…x, nâ† = m}
xâœ : A âŠ—[R] M
âŠ¢ (âˆƒ a âˆˆ I, âˆƒ b âˆˆ N, 1 âŠ—â‚œ[R] â…a, bâ† = xâœ) â†” xâœ âˆˆ s","lemma lie_baseChange {I : LieIdeal R L} {N : LieSubmodule R L M} :
    â…I, Nâ†.baseChange A = â…I.baseChange A, N.baseChange Aâ† ",":= by
  set s : Set (A âŠ—[R] M) := { m | âˆƒ x âˆˆ I, âˆƒ n âˆˆ N, 1 âŠ—â‚œ â…x, nâ† = m}
  have : (TensorProduct.mk R A M 1) '' {m | âˆƒ x âˆˆ I, âˆƒ n âˆˆ N, â…x, nâ† = m} = s := by ext; simp [s]
  rw [â† coe_toSubmodule_eq_iff, coe_baseChange, lieIdeal_oper_eq_linear_span',
    Submodule.baseChange_span, this, lieIdeal_oper_eq_linear_span']
  refine le_antisymm (Submodule.span_mono ?_) (Submodule.span_le.mpr ?_)
  Â· rintro - âŸ¨x, hx, m, hm, rflâŸ©
    exact âŸ¨1 âŠ—â‚œ x, tmul_mem_baseChange_of_mem 1 hx,
           1 âŠ—â‚œ m, tmul_mem_baseChange_of_mem 1 hm, by simpâŸ©
  Â· rintro - âŸ¨x, hx, m, hm, rflâŸ©
    revert m
    apply Submodule.span_induction
      (p := fun x' â†¦ âˆ€ m' âˆˆ N.baseChange A, â…x', m'â† âˆˆ Submodule.span A s) hx
    Â· rintro _ âŸ¨y : L, hy : y âˆˆ I, rflâŸ© m hm
      apply Submodule.span_induction (p := fun m' â†¦ â…(1 : A) âŠ—â‚œ[R] y, m'â† âˆˆ Submodule.span A s) hm
      Â· rintro - âŸ¨m', hm' : m' âˆˆ N, rflâŸ©
        rw [TensorProduct.mk_apply, LieAlgebra.ExtendScalars.bracket_tmul, mul_one]
        apply Submodule.subset_span
        exact âŸ¨y, hy, m', hm', rflâŸ©
      Â· simp
      Â· intro u v hu hv
        rw [lie_add]
        exact Submodule.add_mem _ hu hv
      Â· intro a u hu
        rw [lie_smul]
        exact Submodule.smul_mem _ a hu
    Â· simp
    Â· intro x y hx hy m' hm'
      rw [add_lie]
      exact Submodule.add_mem _ (hx _ hm') (hy _ hm')
    Â· intro a x hx m' hm'
      rw [smul_lie]
      exact Submodule.smul_mem _ a (hx _ hm')",simp only [LieSubmodule.baseChange_baseChange]
Mathlib/GroupTheory/Nilpotent.lean,nilpotencyClass_quotient_center,nilpotencyClass_quotient_center,1f133ba3ecf4a913d3ab6afe5928c441a66b4865,":= by
  generalize hn : Group.nilpotencyClass G = n
  rcases n with (rfl | n)
  Â· simp [nilpotencyClass_zero_iff_subsingleton] at *
    exact Quotient.instSubsingletonQuotient (leftRel (center G))
  Â· suffices Group.nilpotencyClass (G â§¸ center G) = n by simpa
    apply le_antisymm
    Â· apply upperCentralSeries_eq_top_iff_nilpotencyClass_le.mp
      apply comap_injective (f := (mk' (center G))) (surjective_quot_mk _)
      rw [comap_upperCentralSeries_quotient_center, comap_top, â† hn]
      exact upperCentralSeries_nilpotencyClass
    Â· apply le_of_add_le_add_right
      calc
        n + 1 = n.succ := rfl
        _ = Group.nilpotencyClass G := (symm hn)
        _ â‰¤ Group.nilpotencyClass (G â§¸ center G) + 1 :=
          nilpotencyClass_le_of_ker_le_center _ (le_of_eq (ker_mk' _)) _","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  n + 1
case succ.a.a
G : Type u_1
instâœÂ¹ : Group G
H : Subgroup G
instâœ : H.Normal
hH : Group.IsNilpotent G
n : â„•
hn : Group.nilpotencyClass G = n + 1
âŠ¢ upperCentralSeries G n.succ = âŠ¤","theorem nilpotencyClass_quotient_center [hH : IsNilpotent G] :
    Group.nilpotencyClass (G â§¸ center G) = Group.nilpotencyClass G - 1 ",":= by
  generalize hn : Group.nilpotencyClass G = n
  rcases n with (rfl | n)
  Â· simp [nilpotencyClass_zero_iff_subsingleton] at *
    exact Quotient.instSubsingletonQuotient (leftRel (center G))
  Â· suffices Group.nilpotencyClass (G â§¸ center G) = n by simpa
    apply le_antisymm
    Â· apply upperCentralSeries_eq_top_iff_nilpotencyClass_le.mp
      apply comap_injective (f := (mk' (center G))) (surjective_quot_mk _)
      rw [comap_upperCentralSeries_quotient_center, comap_top, Nat.succ_eq_add_one, â† hn]
      exact upperCentralSeries_nilpotencyClass
    Â· apply le_of_add_le_add_right
      calc
        n + 1 = Group.nilpotencyClass G := hn.symm
        _ â‰¤ Group.nilpotencyClass (G â§¸ center G) + 1 :=
          nilpotencyClass_le_of_ker_le_center _ (le_of_eq (ker_mk' _)) _","suffices Group.nilpotencyClass G - 1 = Group.nilpotencyClass G - 1 by
  rw [theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center, theorem_eq_nilpotencyClass_quotient_center,
    theorem_eq_nilpotencyClass_quotient_center] at theorem_eq_nilpotencyClass_quotient_center]"
Mathlib/Analysis/Convex/Combination.lean,Convex.finsum_mem,Convex.finsum_mem,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  have hfin_w : (support (w âˆ˜ PLift.down)).Finite := by
    by_contra H
    rw [finsum, dif_neg H] at hâ‚
    exact zero_ne_one hâ‚
  have hsub : support ((fun i => w i â€¢ z i) âˆ˜ PLift.down) âŠ† hfin_w.toFinset :=
    (support_smul_subset_left _ _).trans hfin_w.coe_toFinset.ge
  rw [finsum_eq_sum_pLift_of_support_subset hsub]
  refine' hs.sum_mem (fun _ _ => hâ‚€ _) _ fun i hi => hz _ _
  Â· rwa [finsum, dif_pos hfin_w] at hâ‚
  Â· rwa [hfin_w.mem_toFinset] at hi","error:  unknown identifier 'finsum_eq_sum_pLift_of_support_subset'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.158555
R : Type u_1
R' : Type u_2
E : Type u_3
F : Type u_4
Î¹âœ : Type u_5
Î¹' : Type u_6
Î± : Type u_7
instâœâ¸ : LinearOrderedField R
instâœâ· : LinearOrderedField R'
instâœâ¶ : AddCommGroup E
instâœâµ : AddCommGroup F
instâœâ´ : LinearOrderedAddCommGroup Î±
instâœÂ³ : Module R E
instâœÂ² : Module R F
instâœÂ¹ : Module R Î±
instâœ : OrderedSMul R Î±
sâœ : Set E
i j : Î¹âœ
c : R
t : Finset Î¹âœ
wâœ : Î¹âœ â†’ R
zâœ : Î¹âœ â†’ E
Î¹ : Sort u_8
w : Î¹ â†’ R
z : Î¹ â†’ E
s : Set E
hs : Convex R s
hâ‚€ : âˆ€ (i : Î¹), 0 â‰¤ w i
hâ‚ : âˆ‘á¶  (i : Î¹), w i = 1
hz : âˆ€ (i : Î¹), w i â‰  0 â†’ z i âˆˆ s
hfin_w : (support (w âˆ˜ PLift.down)).Finite
hsub : support ((fun i â†¦ w i â€¢ z i) âˆ˜ PLift.down) âŠ† â†‘hfin_w.toFinset
âŠ¢ âˆ‘á¶  (i : Î¹), w i â€¢ z i âˆˆ s","theorem Convex.finsum_mem {Î¹ : Sort*} {w : Î¹ â†’ R} {z : Î¹ â†’ E} {s : Set E} (hs : Convex R s)
    (hâ‚€ : âˆ€ i, 0 â‰¤ w i) (hâ‚ : âˆ‘á¶  i, w i = 1) (hz : âˆ€ i, w i â‰  0 â†’ z i âˆˆ s) :
    (âˆ‘á¶  i, w i â€¢ z i) âˆˆ s ",":= by
  have hfin_w : (support (w âˆ˜ PLift.down)).Finite := by
    by_contra H
    rw [finsum, dif_neg H] at hâ‚
    exact zero_ne_one hâ‚
  have hsub : support ((fun i => w i â€¢ z i) âˆ˜ PLift.down) âŠ† hfin_w.toFinset :=
    (support_smul_subset_left _ _).trans hfin_w.coe_toFinset.ge
  rw [finsum_eq_sum_plift_of_support_subset hsub]
  refine hs.sum_mem (fun _ _ => hâ‚€ _) ?_ fun i hi => hz _ ?_
  Â· rwa [finsum, dif_pos hfin_w] at hâ‚
  Â· rwa [hfin_w.mem_toFinset] at hi","have hâ‚ : âˆ‘á¶  i, w i â‰  0 âˆ§ w i â‰  0 â†’ w i â‰  0 â†’ z i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ z i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ z i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ z i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ z i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ w i â‰  0 â†’ z i "
Mathlib/Topology/MetricSpace/CantorScheme.lean,CantorScheme.map_mem,map_mem,38dbcd8285bc4b1391619c12f158a7409f3dfc12,":= by
  have := x.property.some_mem
  rw [mem_interáµ¢] at this
  exact this n","error:  unknown identifier 'mem_interáµ¢'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.2658
Î² : Type u_1
Î± : Type u_2
A : List Î² â†’ Set Î±
x : â†‘(inducedMap A).fst
n : â„•
this : Set.Nonempty.some â‹¯ âˆˆ â‹‚ n, A (res (â†‘x) n)
âŠ¢ (inducedMap A).snd x âˆˆ A (res (â†‘x) n)",theorem map_mem (x : (inducedMap A).1) (n : â„•) : (inducedMap A).2 x âˆˆ A (res x n) ,":= by
  have := x.property.some_mem
  rw [mem_iInter] at this
  exact this n","simp only [mem_inducedMap_inducedMap, res_mem]"
Mathlib/Analysis/InnerProductSpace/Basic.lean,OrthogonalFamily.summable_iff_norm_sq_summable,OrthogonalFamily.summable_iff_norm_sq_summable,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  classical
    simp only [summable_iff_cauchySeq_finset, NormedAddCommGroup.cauchySeq_iff, Real.norm_eq_abs]
    constructor
    Â· intro hf Îµ hÎµ
      obtain âŸ¨a, HâŸ© := hf _ (sqrt_pos.mpr hÎµ)
      use a
      intro sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      rw [â† Finset.sum_sdiff_sub_sum_sdiff]
      refine' (abs_sub _ _).trans_lt _
      have : âˆ€ i, 0 â‰¤ â€–f iâ€– ^ 2 := fun i : Î¹ => sq_nonneg _
      simp only [Finset.abs_sum_of_nonneg' this]
      have : ((âˆ‘ i in sâ‚ \ sâ‚‚, â€–f iâ€– ^ 2) + âˆ‘ i in sâ‚‚ \ sâ‚, â€–f iâ€– ^ 2) < âˆšÎµ ^ 2 := by
        rw [â† hV.norm_sq_diff_sum, sq_lt_sq, abs_of_nonneg (sqrt_nonneg _),
          abs_of_nonneg (norm_nonneg _)]
        exact H sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      have hÎ· := sq_sqrt (le_of_lt hÎµ)
      linarith
    Â· intro hf Îµ hÎµ
      have hÎµ' : 0 < Îµ ^ 2 / 2 := half_pos (sq_pos_of_pos hÎµ)
      obtain âŸ¨a, HâŸ© := hf _ hÎµ'
      use a
      intro sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      refine' (abs_lt_of_sq_lt_sq' _ (le_of_lt hÎµ)).2
      have has : a â‰¤ sâ‚ âŠ“ sâ‚‚ := le_inf hsâ‚ hsâ‚‚
      rw [hV.norm_sq_diff_sum]
      have Hsâ‚ : âˆ‘ x : Î¹ in sâ‚ \ sâ‚‚, â€–f xâ€– ^ 2 < Îµ ^ 2 / 2 := by
        convert H _ hsâ‚ _ has
        have : sâ‚ âŠ“ sâ‚‚ âŠ† sâ‚ := Finset.inter_subset_left _ _
        rw [â† Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        Â· simp
        Â· exact fun i => sq_nonneg _
      have Hsâ‚‚ : âˆ‘ x : Î¹ in sâ‚‚ \ sâ‚, â€–f xâ€– ^ 2 < Îµ ^ 2 / 2 := by
        convert H _ hsâ‚‚ _ has
        have : sâ‚ âŠ“ sâ‚‚ âŠ† sâ‚‚ := Finset.inter_subset_right _ _
        rw [â† Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        Â· simp
        Â· exact fun i => sq_nonneg _
      linarith","error:  function expected at
  Finset.inter_subset_left ?m.1083969
term has type
  ?m.1083968 âˆˆ ?m.1083966
error:  function expected at
  Finset.inter_subset_right ?m.1089319
term has type
  ?m.1089318 âˆˆ ?m.1089317","theorem OrthogonalFamily.summable_iff_norm_sq_summable [CompleteSpace E] (f : âˆ€ i, G i) :
    (Summable fun i => V i (f i)) â†” Summable fun i => â€–f iâ€– ^ 2 ",":= by
  classical
    simp only [summable_iff_cauchySeq_finset, NormedAddCommGroup.cauchySeq_iff, Real.norm_eq_abs]
    constructor
    Â· intro hf Îµ hÎµ
      obtain âŸ¨a, HâŸ© := hf _ (sqrt_pos.mpr hÎµ)
      use a
      intro sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      rw [â† Finset.sum_sdiff_sub_sum_sdiff]
      refine (abs_sub _ _).trans_lt ?_
      have : âˆ€ i, 0 â‰¤ â€–f iâ€– ^ 2 := fun i : Î¹ => sq_nonneg _
      simp only [Finset.abs_sum_of_nonneg' this]
      have : ((âˆ‘ i âˆˆ sâ‚ \ sâ‚‚, â€–f iâ€– ^ 2) + âˆ‘ i âˆˆ sâ‚‚ \ sâ‚, â€–f iâ€– ^ 2) < âˆšÎµ ^ 2 := by
        rw [â† hV.norm_sq_diff_sum, sq_lt_sq, abs_of_nonneg (sqrt_nonneg _),
          abs_of_nonneg (norm_nonneg _)]
        exact H sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      have hÎ· := sq_sqrt (le_of_lt hÎµ)
      linarith
    Â· intro hf Îµ hÎµ
      have hÎµ' : 0 < Îµ ^ 2 / 2 := half_pos (sq_pos_of_pos hÎµ)
      obtain âŸ¨a, HâŸ© := hf _ hÎµ'
      use a
      intro sâ‚ hsâ‚ sâ‚‚ hsâ‚‚
      refine (abs_lt_of_sq_lt_sq' ?_ (le_of_lt hÎµ)).2
      have has : a â‰¤ sâ‚ âŠ“ sâ‚‚ := le_inf hsâ‚ hsâ‚‚
      rw [hV.norm_sq_diff_sum]
      have Hsâ‚ : âˆ‘ x âˆˆ sâ‚ \ sâ‚‚, â€–f xâ€– ^ 2 < Îµ ^ 2 / 2 := by
        convert H _ hsâ‚ _ has
        have : sâ‚ âŠ“ sâ‚‚ âŠ† sâ‚ := Finset.inter_subset_left
        rw [â† Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        Â· simp
        Â· exact fun i => sq_nonneg _
      have Hsâ‚‚ : âˆ‘ x âˆˆ sâ‚‚ \ sâ‚, â€–f xâ€– ^ 2 < Îµ ^ 2 / 2 := by
        convert H _ hsâ‚‚ _ has
        have : sâ‚ âŠ“ sâ‚‚ âŠ† sâ‚‚ := Finset.inter_subset_right
        rw [â† Finset.sum_sdiff this, add_tsub_cancel_right, Finset.abs_sum_of_nonneg']
        Â· simp
        Â· exact fun i => sq_nonneg _
      linarith","refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©"
Mathlib/LinearAlgebra/FreeModule/Norm.lean,associated_norm_prod_smith,associated_norm_prod_smith,f3695eb20c685cfcb5e45f75b1e68a59b8de7efb,":= by
  have hI := span_singleton_eq_bot.not.2 hf
  let b' := ringBasis b (span {f}) hI
  classical
  rw [â† Matrix.det_diagonal, â† LinearMap.det_toLin b']
  let e :=
    (b'.equiv ((span {f}).selfBasis b hI) <| Equiv.refl _).trans
      ((LinearEquiv.coord S S f hf).restrictScalars R)
  refine (LinearMap.associated_det_of_eq_comp e _ _ ?_).symm
  dsimp only [LinearEquiv.trans_apply]
  simp_rw [â† LinearEquiv.coe_toLinearMap, â† LinearMap.comp_apply, â† LinearMap.ext_iff]
  refine b'.ext fun i => ?_
  simp_rw [LinearMap.comp_apply, LinearEquiv.coe_toLinearMap, Matrix.toLin_apply, Basis.repr_self,
    Finsupp.single_eq_pi_single, Matrix.diagonal_mulVec_single, Pi.single_apply, ite_smul,
    zero_smul, Finset.sum_ite_eq', mul_one, if_pos (Finset.mem_univ _), b'.equiv_apply]
  change _ = f * _
  rw [mul_comm, â† smul_eq_mul, LinearEquiv.restrictScalars_apply, LinearEquiv.coord_apply_smul,
    Ideal.selfBasis_def]
  rfl",error:  simp made no progress,"theorem associated_norm_prod_smith [Fintype Î¹] (b : Basis Î¹ R S) {f : S} (hf : f â‰  0) :
    Associated (Algebra.norm R f) (âˆ i, smithCoeffs b _ (span_singleton_eq_bot.not.2 hf) i) ",":= by
  have hI := span_singleton_eq_bot.not.2 hf
  let b' := ringBasis b (span {f}) hI
  classical
  rw [â† Matrix.det_diagonal, â† LinearMap.det_toLin b']
  let e :=
    (b'.equiv ((span {f}).selfBasis b hI) <| Equiv.refl _).trans
      ((LinearEquiv.coord S S f hf).restrictScalars R)
  refine (LinearMap.associated_det_of_eq_comp e _ _ ?_).symm
  dsimp only [e, LinearEquiv.trans_apply]
  simp_rw [â† LinearEquiv.coe_toLinearMap, â† LinearMap.comp_apply, â† LinearMap.ext_iff]
  refine b'.ext fun i => ?_
  simp_rw [LinearMap.comp_apply, LinearEquiv.coe_toLinearMap, Matrix.toLin_apply, Basis.repr_self,
    Finsupp.single_eq_pi_single, Matrix.diagonal_mulVec_single, Pi.single_apply, ite_smul,
    zero_smul, Finset.sum_ite_eq', mul_one, if_pos (Finset.mem_univ _), b'.equiv_apply]
  change _ = f * _
  erw [mul_comm, â† smul_eq_mul, LinearEquiv.restrictScalars_apply, LinearEquiv.coord_apply_smul,
    Ideal.selfBasis_def]
  rfl",refine Associated.theorem_eq_of_associated_norm_prod_smith ?_ ?_
Mathlib/Topology/Algebra/Module/Cardinality.lean,cardinal_eq_of_mem_nhds_zero,cardinal_eq_of_mem_nhds_zero,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  obtain âŸ¨c, hcâŸ© : âˆƒ x : ğ•œ , 1 < â€–xâ€– := NormedField.exists_lt_norm ğ•œ 1
  have cn_ne : âˆ€ n, c^n â‰  0 := by
    intro n
    apply pow_ne_zero
    rintro rfl
    simp only [norm_zero] at hc
    exact lt_irrefl _ (hc.trans zero_lt_one)
  have A : âˆ€ (x : E), âˆ€á¶  n in (atTop : Filter â„•), x âˆˆ c^n â€¢ s := by
    intro x
    have : Tendsto (fun n â†¦ (c^n) â»Â¹ â€¢ x) atTop (ğ“ ((0 : ğ•œ) â€¢ x)) := by
      have : Tendsto (fun n â†¦ (c^n)â»Â¹) atTop (ğ“ 0) := by
        simp_rw [â† inv_pow]
        apply tendsto_pow_atTop_nhds_zero_of_norm_lt_one
        rw [norm_inv]
        exact inv_lt_one hc
      exact Tendsto.smul_const this x
    rw [zero_smul] at this
    filter_upwards [this hs] with n (hn : (c ^ n)â»Â¹ â€¢ x âˆˆ s)
    exact (mem_smul_set_iff_inv_smul_memâ‚€ (cn_ne n) _ _).2 hn
  have B : âˆ€ n, #(c^n â€¢ s : ) = #s : = by
    intro n
    have : (c^n â€¢ s : ) â‰ƒ s : =
    { toFun := fun x â†¦ âŸ¨(c^n)â»Â¹ â€¢ x.1, (mem_smul_set_iff_inv_smul_memâ‚€ (cn_ne n) _ _).1 x.2âŸ©
      invFun := fun x â†¦ âŸ¨(c^n) â€¢ x.1, smul_mem_smul_set x.2âŸ©
      left_inv := fun x â†¦ by simp [smul_smul, mul_inv_cancel (cn_ne n)]
      right_inv := fun x â†¦ by simp [smul_smul, inv_mul_cancel (cn_ne n)] }
    exact Cardinal.mk_congr this
  apply (Cardinal.mk_of_countable_eventually_mem A B).symm","error:  unexpected token ':'; expected '|'
error:  unsolved goals
case intro
E : Type u_1
ğ•œ : Type u_2
instâœâ´ : NontriviallyNormedField ğ•œ
instâœÂ³ : AddCommGroup E
instâœÂ² : Module ğ•œ E
instâœÂ¹ : TopologicalSpace E
instâœ : ContinuousSMul ğ•œ E
s : Set E
hs : s âˆˆ ğ“ 0
c : ğ•œ
hc : 1 < â€–câ€–
cn_ne : âˆ€ (n : â„•), c ^ n â‰  0
A : âˆ€ (x : E), âˆ€á¶  (n : â„•) in atTop, x âˆˆ c ^ n â€¢ s
B : âˆ€ (n : â„•), #â†‘(c ^ n â€¢ s) = #â†‘s
âŠ¢ #â†‘s = #E","lemma cardinal_eq_of_mem_nhds_zero
    {E : Type*} (ğ•œ : Type*) [NontriviallyNormedField ğ•œ] [AddCommGroup E] [Module ğ•œ E]
    [TopologicalSpace E] [ContinuousSMul ğ•œ E] {s : Set E} (hs : s âˆˆ ğ“ (0 : E)) : #s = #E ",":= by
  obtain âŸ¨c, hcâŸ© : âˆƒ x : ğ•œ , 1 < â€–xâ€– := NormedField.exists_lt_norm ğ•œ 1
  have cn_ne : âˆ€ n, c^n â‰  0 := by
    intro n
    apply pow_ne_zero
    rintro rfl
    simp only [norm_zero] at hc
    exact lt_irrefl _ (hc.trans zero_lt_one)
  have A : âˆ€ (x : E), âˆ€á¶  n in (atTop : Filter â„•), x âˆˆ c^n â€¢ s := by
    intro x
    have : Tendsto (fun n â†¦ (c^n) â»Â¹ â€¢ x) atTop (ğ“ ((0 : ğ•œ) â€¢ x)) := by
      have : Tendsto (fun n â†¦ (c^n)â»Â¹) atTop (ğ“ 0) := by
        simp_rw [â† inv_pow]
        apply tendsto_pow_atTop_nhds_zero_of_norm_lt_one
        rw [norm_inv]
        exact inv_lt_one hc
      exact Tendsto.smul_const this x
    rw [zero_smul] at this
    filter_upwards [this hs] with n (hn : (c ^ n)â»Â¹ â€¢ x âˆˆ s)
    exact (mem_smul_set_iff_inv_smul_memâ‚€ (cn_ne n) _ _).2 hn
  have B : âˆ€ n, #(c^n â€¢ s :) = #s := by
    intro n
    have : (c^n â€¢ s :) â‰ƒ s :=
    { toFun := fun x â†¦ âŸ¨(c^n)â»Â¹ â€¢ x.1, (mem_smul_set_iff_inv_smul_memâ‚€ (cn_ne n) _ _).1 x.2âŸ©
      invFun := fun x â†¦ âŸ¨(c^n) â€¢ x.1, smul_mem_smul_set x.2âŸ©
      left_inv := fun x â†¦ by simp [smul_smul, mul_inv_cancel (cn_ne n)]
      right_inv := fun x â†¦ by simp [smul_smul, inv_mul_cancel (cn_ne n)] }
    exact Cardinal.mk_congr this
  apply (Cardinal.mk_of_countable_eventually_mem A B).symm",rw [mem_nhds_zero_iff] at hs
Mathlib/Data/Multiset/Fintype.lean,Multiset.mem_of_mem_toEnumFinset,Multiset.mem_of_mem_toEnumFinset,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  Multiset.count_pos.mp <| pos_of_gt <| (m.mem_toEnumFinset p).mp h","error:  application type mismatch
  count_pos.mp (pos_of_gt ?m.5230)
argument
  pos_of_gt ?m.5230
has type
  @OfNat.ofNat â„• 0 Zero.toOfNat0 < ?m.5088 : Prop
but is expected to have type
  @OfNat.ofNat â„• 0 (instOfNatNat 0) < count p.1 m : Prop",theorem Multiset.mem_of_mem_toEnumFinset {p : Î± Ã— â„•} (h : p âˆˆ m.toEnumFinset) : p.1 âˆˆ m ,":=
  have := (m.mem_toEnumFinset p).mp h; Multiset.count_pos.mp (by omega)",rw [mem_of_mem_toEnumFinset]
Mathlib/Analysis/Convex/Independent.lean,convexIndependent_iff_finset,convexIndependent_iff_finset,6861d9247d1a06a093e444c3a0319e5ec45263c2,":= by
  refine' âŸ¨fun hc s x hx => hc s x _, fun h s x hx => _âŸ©
  Â· rwa [Finset.coe_image] at hx
  have hp : Injective p := by
    rintro a b hab
    rw [â† mem_singleton]
    refine' h {b} a _
    rw [hab, image_singleton, coe_singleton, convexHull_singleton]
    exact Set.mem_singleton _
  rw [convexHull_eq_union_convexHull_finite_subsets] at hx
  simp_rw [Set.mem_iUnion] at hx
  obtain âŸ¨t, ht, hxâŸ© := hx
  rw [â† hp.mem_set_image]
  apply ht
  suffices x âˆˆ t.preimage p (hp.injOn _) by rwa [mem_preimage, â† mem_coe] at this
  refine' h _ x _
  rwa [t.image_preimage p (hp.injOn _), filter_true_of_mem]
  Â· exact fun y hy => s.image_subset_range p (ht <| mem_coe.2 hy)","error:  application type mismatch
  t.preimage p â‹¯
argument
  Injective.injOn hp ?m.23740
has type
  âˆ€ â¦ƒxâ‚‚ : Î¹â¦„, xâ‚‚ âˆˆ ?m.23738 â†’ p ?m.23739 = p xâ‚‚ â†’ ?m.23739 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn p (p â»Â¹' â†‘t) : Prop
error:  application type mismatch
  image_preimage p t (Injective.injOn hp ?m.24167)
argument
  Injective.injOn hp ?m.24167
has type
  âˆ€ â¦ƒxâ‚‚ : Î¹â¦„, xâ‚‚ âˆˆ ?m.24165 â†’ p ?m.24166 = p xâ‚‚ â†’ ?m.24166 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn p (p â»Â¹' â†‘t) : Prop","theorem convexIndependent_iff_finset {p : Î¹ â†’ E} :
    ConvexIndependent ğ•œ p â†”
      âˆ€ (s : Finset Î¹) (x : Î¹), p x âˆˆ convexHull ğ•œ (s.image p : Set E) â†’ x âˆˆ s ",":= by
  refine âŸ¨fun hc s x hx => hc s x ?_, fun h s x hx => ?_âŸ©
  Â· rwa [Finset.coe_image] at hx
  have hp : Injective p := by
    rintro a b hab
    rw [â† mem_singleton]
    refine h {b} a ?_
    rw [hab, image_singleton, coe_singleton, convexHull_singleton]
    exact Set.mem_singleton _
  rw [convexHull_eq_union_convexHull_finite_subsets] at hx
  simp_rw [Set.mem_iUnion] at hx
  obtain âŸ¨t, ht, hxâŸ© := hx
  rw [â† hp.mem_set_image]
  refine ht ?_
  suffices x âˆˆ t.preimage p hp.injOn by rwa [mem_preimage, â† mem_coe] at this
  refine h _ x ?_
  rwa [t.image_preimage p hp.injOn, filter_true_of_mem]
  exact fun y hy => s.image_subset_range p (ht <| mem_coe.2 hy)","simp only [convexIndependent_iff_finset, convexHull_image]"
Mathlib/RingTheory/ReesAlgebra.lean,mem_reesAlgebra_iff_support,mem_reesAlgebra_iff_support,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  apply forall_congr'
  intro a
  rw [mem_support_iff, Iff.comm, imp_iff_right_iff, Ne, â† imp_iff_not_or]
  exact fun e => e.symm â–¸ (I ^ a).zero_mem","error:  ambiguous, possible interpretations 
  _root_.imp_iff_right_iff : (?m.8978 â†’ ?m.8979 â†” ?m.8979) â†” ?m.8978 âˆ¨ ?m.8979
  
  Classical.imp_iff_right_iff : (?m.8980 â†’ ?m.8981 â†” ?m.8981) â†” ?m.8980 âˆ¨ ?m.8981
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.8983
case h
R M : Type u
instâœÂ² : CommRing R
instâœÂ¹ : AddCommGroup M
instâœ : Module R M
I : Ideal R
f : R[X]
a : â„•
âŠ¢ f.coeff a â‰  0 â†’ f.coeff a âˆˆ I ^ a â†” f.coeff a âˆˆ I ^ a","theorem mem_reesAlgebra_iff_support (f : R[X]) :
    f âˆˆ reesAlgebra I â†” âˆ€ i âˆˆ f.support, f.coeff i âˆˆ I ^ i ",":= by
  apply forall_congr'
  intro a
  rw [mem_support_iff, Iff.comm, Classical.imp_iff_right_iff, Ne, â† imp_iff_not_or]
  exact fun e => e.symm â–¸ (I ^ a).zero_mem",rw [mem_reesAlgebra_iff_support]
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.tendsto_self_mul_Gamma_nhds_zero,tendsto_self_mul_Gamma_nhds_zero,7dc162787d2a79bf721a83a87f641ace70251b17,":= by
  rw [show ğ“ (1 : â„‚) = ğ“ (Gamma (0 + 1)) by simp only [zero_add, Complex.Gamma_one]]
  convert (Tendsto.mono_left _ nhdsWithin_le_nhds).congr'
    (eventuallyEq_of_mem self_mem_nhdsWithin Complex.Gamma_add_one)
  refine' ContinuousAt.comp (g := Gamma) _ (continuous_id.add continuous_const).continuousAt
  refine' (Complex.differentiableAt_Gamma _ fun m => _).continuousAt
  rw [zero_add, â† ofReal_nat_cast, â† ofReal_neg, â† ofReal_one, Ne.def, ofReal_inj]
  refine' (lt_of_le_of_lt _ zero_lt_one).ne'
  exact neg_nonpos.mpr (Nat.cast_nonneg _)","error:  unknown identifier 'ofReal_nat_cast'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.127050
case convert_1
m : â„•
âŠ¢ 1 â‰  -â†‘m",theorem tendsto_self_mul_Gamma_nhds_zero : Tendsto (fun z : â„‚ => z * Gamma z) (ğ“[â‰ ] 0) (ğ“ 1) ,":= by
  rw [show ğ“ (1 : â„‚) = ğ“ (Gamma (0 + 1)) by simp only [zero_add, Complex.Gamma_one]]
  convert (Tendsto.mono_left _ nhdsWithin_le_nhds).congr'
    (eventuallyEq_of_mem self_mem_nhdsWithin Complex.Gamma_add_one)
  refine ContinuousAt.comp (g := Gamma) ?_ (continuous_id.add continuous_const).continuousAt
  refine (Complex.differentiableAt_Gamma _ fun m => ?_).continuousAt
  rw [zero_add, â† ofReal_natCast, â† ofReal_neg, â† ofReal_one, Ne, ofReal_inj]
  refine (lt_of_le_of_lt ?_ zero_lt_one).ne'
  exact neg_nonpos.mpr (Nat.cast_nonneg _)",refine tendsto_self_mul_Gamma_nhds_zero.tendsto_left_mul_Gamma_nhds_zero tendsto_self_mul_Gamma_nhds_zero
Mathlib/Data/Finset/Image.lean,Finset.image_inter_subset,image_inter_subset,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  subset_inter (image_subset_image <| inter_subset_left _ _) <|
    image_subset_image <| inter_subset_right _ _","error:  function expected at
  inter_subset_left ?m.62987
term has type
  ?m.62986 âˆˆ ?m.62984
error:  function expected at
  inter_subset_right ?m.63182
term has type
  ?m.63181 âˆˆ ?m.63180","theorem image_inter_subset [DecidableEq Î±] (f : Î± â†’ Î²) (s t : Finset Î±) :
    (s âˆ© t).image f âŠ† s.image f âˆ© t.image f ",":=
  (image_mono f).map_inf_le s t","refine theorem_image_image_finset_image_finset_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset
  image_inter_subset [DecidableEr.image_image_finset_image_finset_image_finset_image_finset_image_finset_image_"
Mathlib/Combinatorics/SimpleGraph/Subgraph.lean,SimpleGraph.singletonSubgraph_fst_le_subgraphOfAdj,singletonSubgraph_fst_le_subgraphOfAdj,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  constructor <;> simp [-Set.bot_eq_empty]
  exact fun _ _ â†¦ False.elim",error:  no goals to be solved,"theorem singletonSubgraph_fst_le_subgraphOfAdj {u v : V} {h : G.Adj u v} :
    G.singletonSubgraph u â‰¤ G.subgraphOfAdj h ",":= by
  simp",rw [singletonSubgraph]
Mathlib/RingTheory/IntegralClosure.lean,RingHom.isIntegralElem_leadingCoeff_mul,RingHom.isIntegralElem_leadingCoeff_mul,3b4737b3b07aa77aaa08420241e83ad9c46eda8a,":= by
  by_cases h' : 1 â‰¤ p.natDegree
  Â· use normalizeScaleRoots p
    have : p â‰  0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_evalâ‚‚_leadingCoeff_mul p h' f x, h, MulZeroClass.mul_zero]
  Â· by_cases hp : p.map f = 0
    Â· apply_fun fun q => coeff q p.natDegree  at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, MulZeroClass.zero_mul]
      exact f.is_integral_zero
    Â· rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', evalâ‚‚_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]","error:  invalid field 'is_integral_zero', the environment does not contain 'RingHom.is_integral_zero'
  f
has type
  R â†’+* S","theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.evalâ‚‚ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) ",":= by
  by_cases h' : 1 â‰¤ p.natDegree
  Â· use normalizeScaleRoots p
    have : p â‰  0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_evalâ‚‚_leadingCoeff_mul p h' f x, h, mul_zero]
  Â· by_cases hp : p.map f = 0
    Â· apply_fun fun q => coeff q p.natDegree at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, zero_mul]
      exact f.isIntegralElem_zero
    Â· rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', evalâ‚‚_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]",refine RingHom.isIntegralElem_leadingCoeff_mul_leadingCoeff_mul_leadingCoeff_mul h ?_
Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean,AbsoluteValue.IsAdmissible.exists_approx,exists_approx,61ca0ea882c23bb336df737657ab5b9a48ebdbbe,":= by
  haveI := Classical.decEq R
  induction' n with n ih
  Â· intro Îµ _hÎµ b _hb A
    refine' âŸ¨0, 1, _, _âŸ©
    Â· simp
    rintro âŸ¨i, âŸ¨âŸ©âŸ©
  intro Îµ hÎµ b hb A
  let M := h.card Îµ
  obtain âŸ¨s, s_inj, hsâŸ© :
    âˆƒ s : Fin (M ^ n).succ â†’ Fin (M ^ n.succ).succ,
      Function.Injective s âˆ§ âˆ€ iâ‚€ iâ‚, (abv (A (s iâ‚) 0 % b - A (s iâ‚€) 0 % b) : â„) < abv b â€¢ Îµ :=
    by
    obtain âŸ¨t, htâŸ© :
      âˆƒ t : Fin (M ^ n.succ).succ â†’ Fin M,
        âˆ€ iâ‚€ iâ‚, t iâ‚€ = t iâ‚ â†’ (abv (A iâ‚ 0 % b - A iâ‚€ 0 % b) : â„) < abv b â€¢ Îµ :=
      h.exists_partition hÎµ hb fun x â†¦ A x 0
    obtain âŸ¨s, hsâŸ© :=
      @Fintype.exists_lt_card_fiber_of_mul_lt_card _ _ _ _ _ t (M ^ n)
        (by simpa only [Fintype.card_fin, pow_succ] using Nat.lt_succ_self (M ^ n.succ))
    refine'
      âŸ¨fun i â†¦ (Finset.univ.filter fun x â†¦ t x = s).toList.nthLe i _, _, fun iâ‚€ iâ‚ â†¦ ht _ _ _âŸ©
    Â· refine' i.2.trans_le _
      rwa [Finset.length_toList]
    Â· intro i j h
      ext
      exact Fin.mk.inj_iff.mp (List.nodup_iff_injective_get.mp (Finset.nodup_toList _) h)
    have :
      âˆ€ i h,
        (Finset.univ.filter fun x â†¦ t x = s).toList.nthLe i h âˆˆ
          Finset.univ.filter fun x â†¦ t x = s :=
      by
      intro i h
      exact Finset.mem_toList.mp (List.get_mem _ i h)
    obtain âŸ¨_, hâ‚€âŸ© := Finset.mem_filter.mp (this iâ‚€ _)
    obtain âŸ¨_, hâ‚âŸ© := Finset.mem_filter.mp (this iâ‚ _)
    exact hâ‚€.trans hâ‚.symm
  obtain âŸ¨kâ‚€, kâ‚, hk, hâŸ© := ih hÎµ hb fun x â†¦ Fin.tail (A (s x))
  refine' âŸ¨s kâ‚€, s kâ‚, fun h â†¦ hk (s_inj h), fun i â†¦ Fin.cases _ (fun i â†¦ _) iâŸ©
  Â· exact hs kâ‚€ kâ‚
  Â· exact h i","error:  type mismatch
  hâœ
has type
  M ^ n * M < (M ^ n * M).succ : Prop
but is expected to have type
  M * M ^ n < (M ^ n * M).succ : Prop
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem exists_approx_aux (n : â„•) (h : abv.IsAdmissible) :
    âˆ€ {Îµ : â„} (_hÎµ : 0 < Îµ) {b : R} (_hb : b â‰  0) (A : Fin (h.card Îµ ^ n).succ â†’ Fin n â†’ R),
      âˆƒ iâ‚€ iâ‚, iâ‚€ â‰  iâ‚ âˆ§ âˆ€ k, (abv (A iâ‚ k % b - A iâ‚€ k % b) : â„) < abv b â€¢ Îµ ",":= by
  haveI := Classical.decEq R
  induction' n with n ih
  Â· intro Îµ _hÎµ b _hb A
    refine âŸ¨0, 1, ?_, ?_âŸ©
    Â· simp
    rintro âŸ¨i, âŸ¨âŸ©âŸ©
  intro Îµ hÎµ b hb A
  let M := h.card Îµ
  obtain âŸ¨s, s_inj, hsâŸ© :
    âˆƒ s : Fin (M ^ n).succ â†’ Fin (M ^ n.succ).succ,
      Function.Injective s âˆ§ âˆ€ iâ‚€ iâ‚, (abv (A (s iâ‚) 0 % b - A (s iâ‚€) 0 % b) : â„) < abv b â€¢ Îµ := by
    obtain âŸ¨t, htâŸ© :
      âˆƒ t : Fin (M ^ n.succ).succ â†’ Fin M,
        âˆ€ iâ‚€ iâ‚, t iâ‚€ = t iâ‚ â†’ (abv (A iâ‚ 0 % b - A iâ‚€ 0 % b) : â„) < abv b â€¢ Îµ :=
      h.exists_partition hÎµ hb fun x â†¦ A x 0
    obtain âŸ¨s, hsâŸ© :=
      Fintype.exists_lt_card_fiber_of_mul_lt_card (f := t)
        (by simpa only [Fintype.card_fin, pow_succ'] using Nat.lt_succ_self (M ^ n.succ))
    refine âŸ¨fun i â†¦ (Finset.univ.filter fun x â†¦ t x = s).toList.get <| i.castLE ?_, fun i j h â†¦ ?_,
      fun iâ‚€ iâ‚ â†¦ ht _ _ ?_âŸ©
    Â· rwa [Finset.length_toList]
    Â· ext
      simpa [(Finset.nodup_toList _).getElem_inj_iff] using h
    Â· have : âˆ€ i h, t ((Finset.univ.filter fun x â†¦ t x = s).toList.get âŸ¨i, hâŸ©) = s := fun i h â†¦
        (Finset.mem_filter.mp (Finset.mem_toList.mp (List.get_mem _ i h))).2
      simp only [Nat.succ_eq_add_one, Finset.length_toList, List.get_eq_getElem] at this
      simp only [Nat.succ_eq_add_one, List.get_eq_getElem, Fin.coe_castLE]
      rw [this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ iâ‚.2) hs),
        this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ iâ‚€.2) hs)]
  obtain âŸ¨kâ‚€, kâ‚, hk, hâŸ© := ih hÎµ hb fun x â†¦ Fin.tail (A (s x))
  refine âŸ¨s kâ‚€, s kâ‚, fun h â†¦ hk (s_inj h), fun i â†¦ Fin.cases ?_ (fun i â†¦ ?_) iâŸ©
  Â· exact hs kâ‚€ kâ‚
  Â· exact h i",rw [theorem_exists_approx_aux]
Mathlib/Analysis/Convex/Extrema.lean,IsMinOn.of_isLocalMinOn_of_convexOn,IsMinOn.of_isLocalMinOn_of_convexOn,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  rintro c hc
  dsimp only [mem_setOf_eq]
  rw [IsLocalMinOn, nhdsWithin_Icc_eq_nhdsWithin_Ici a_lt_b] at h_local_min
  rcases hc.1.eq_or_lt with (rfl | a_lt_c)
  Â· exact le_rfl
  have Hâ‚ : âˆ€á¶  y in ğ“[>] a, f a â‰¤ f y :=
    h_local_min.filter_mono (nhdsWithin_mono _ Ioi_subset_Ici_self)
  have Hâ‚‚ : âˆ€á¶  y in ğ“[>] a, y âˆˆ Ioc a c := Ioc_mem_nhdsWithin_Ioi (left_mem_Ico.2 a_lt_c)
  rcases(Hâ‚.and Hâ‚‚).exists with âŸ¨y, hfy, hy_acâŸ©
  rcases(Convex.mem_Ioc a_lt_c).mp hy_ac with âŸ¨ya, yc, yaâ‚€, ycâ‚€, yac, rflâŸ©
  suffices : ya â€¢ f a + yc â€¢ f a â‰¤ ya â€¢ f a + yc â€¢ f c
  exact (smul_le_smul_iff_of_pos ycâ‚€).1 (le_of_add_le_add_left this)
  calc
    ya â€¢ f a + yc â€¢ f a = f a := by rw [â† add_smul, yac, one_smul]
    _ â‰¤ f (ya * a + yc * c) := hfy
    _ â‰¤ ya â€¢ f a + yc â€¢ f c := h_conv.2 (left_mem_Icc.2 a_lt_b.le) hc yaâ‚€ ycâ‚€.le yac",error:  unexpected token ':'; expected term,"theorem IsMinOn.of_isLocalMinOn_of_convexOn_Icc {f : â„ â†’ Î²} {a b : â„} (a_lt_b : a < b)
    (h_local_min : IsLocalMinOn f (Icc a b) a) (h_conv : ConvexOn â„ (Icc a b) f) :
    IsMinOn f (Icc a b) a ",":= by
  rintro c hc
  dsimp only [mem_setOf_eq]
  rw [IsLocalMinOn, nhdsWithin_Icc_eq_nhdsWithin_Ici a_lt_b] at h_local_min
  rcases hc.1.eq_or_lt with (rfl | a_lt_c)
  Â· exact le_rfl
  have Hâ‚ : âˆ€á¶  y in ğ“[>] a, f a â‰¤ f y :=
    h_local_min.filter_mono (nhdsWithin_mono _ Ioi_subset_Ici_self)
  have Hâ‚‚ : âˆ€á¶  y in ğ“[>] a, y âˆˆ Ioc a c := Ioc_mem_nhdsWithin_Ioi (left_mem_Ico.2 a_lt_c)
  rcases (Hâ‚.and Hâ‚‚).exists with âŸ¨y, hfy, hy_acâŸ©
  rcases (Convex.mem_Ioc a_lt_c).mp hy_ac with âŸ¨ya, yc, yaâ‚€, ycâ‚€, yac, rflâŸ©
  suffices ya â€¢ f a + yc â€¢ f a â‰¤ ya â€¢ f a + yc â€¢ f c from
    (smul_le_smul_iff_of_pos_left ycâ‚€).1 (le_of_add_le_add_left this)
  calc
    ya â€¢ f a + yc â€¢ f a = f a := by rw [â† add_smul, yac, one_smul]
    _ â‰¤ f (ya * a + yc * c) := hfy
    _ â‰¤ ya â€¢ f a + yc â€¢ f c := h_conv.2 (left_mem_Icc.2 a_lt_b.le) hc yaâ‚€ ycâ‚€.le yac","refine IsMinOn.of_isLocalMinOn_of_isLocalMinOn_of_isLocalMinOn_of_isLocalMinOn_of_convexOn_Icc
  h_local_min h_conv h_conv h_local_min h_local_min h_conv h_local_min h_local_min h_conv h_local_min h_local_min"
Mathlib/AlgebraicGeometry/EllipticCurve/Affine.lean,WeierstrassCurve.Affine.map_equation,map_equation,d889c7f5e24607f4a2965909f4b0ade97c39f766,":= by
  simp only [Equation, â† map_C, map_eval_polynomial, map_eq_zero_iff f hf]","error:  unknown identifier 'map_eval_polynomial'
error:  unsolved goals
R : Type u
instâœÂ¹ : CommRing R
W : Affine R
S : Type v
instâœ : CommRing S
f : R â†’+* S
hf : Function.Injective â‡‘f
x y : R
âŠ¢ evalEval (f x) (f y) (map W f).toAffine.polynomial = 0 â†” evalEval x y W.polynomial = 0","lemma map_equation (hf : Function.Injective f) (x y : R) :
    (W.map f).toAffine.Equation (f x) (f y) â†” W.Equation x y ",":= by
  simp only [Equation, map_polynomial, map_mapRingHom_evalEval, map_eq_zero_iff f hf]","simp only [Equation, map_equation]"
Mathlib/MeasureTheory/Integral/CircleIntegral.lean,circleIntegral.integral_sub_zpow_of_ne,integral_sub_zpow_of_ne,e92ad7acc4d771729f70601a74a3c091f330e507,":= by
  rcases em (w âˆˆ sphere c (|R|) âˆ§ n < -1) with (âŸ¨hw, hnâŸ© | H)
  Â· exact integral_sub_zpow_of_undef (hn.trans (by decide)) hw
  push_neg at H
  have hd : âˆ€ z, z â‰  w âˆ¨ -1 â‰¤ n â†’
      HasDerivAt (fun z => (z - w) ^ (n + 1) / (n + 1)) ((z - w) ^ n) z := by
    intro z hne
    convert ((hasDerivAt_zpow (n + 1) _ (hne.imp _ _)).comp z
      ((hasDerivAt_id z).sub_const w)).div_const _ using 1
    Â· have hn' : (n + 1 : â„‚) â‰  0 := by
        rwa [Ne, â† eq_neg_iff_add_eq_zero, â† Int.cast_one, â† Int.cast_neg, Int.cast_inj]
      simp [mul_assoc, mul_div_cancel_left _ hn']
    exacts [sub_ne_zero.2, neg_le_iff_add_nonneg.1]
  refine' integral_eq_zero_of_hasDerivWithinAt' fun z hz => (hd z _).hasDerivWithinAt
  exact (ne_or_eq z w).imp_right fun (h : z = w) => H <| h â–¸ hz","error:  application type mismatch
  mul_div_cancel_left ?m.192024 hn'
argument
  hn'
has type
  â†‘n + 1 â‰  0 : Prop
but is expected to have type
  ?m.192022 : Type ?u.192021
error:  unsolved goals
case h.e'_7
E : Type u_1
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„‚ E
instâœ : CompleteSpace E
n : â„¤
hn : n â‰  -1
c w : â„‚
R : â„
H : w âˆˆ sphere c |R| â†’ -1 â‰¤ n
z : â„‚
hne : z â‰  w âˆ¨ -1 â‰¤ n
hn' : â†‘n + 1 â‰  0
âŠ¢ (z - w) ^ n = (â†‘n + 1) * (z - w) ^ n / (â†‘n + 1)","theorem integral_sub_zpow_of_ne {n : â„¤} (hn : n â‰  -1) (c w : â„‚) (R : â„) :
    (âˆ® z in C(c, R), (z - w) ^ n) = 0 ",":= by
  rcases em (w âˆˆ sphere c |R| âˆ§ n < -1) with (âŸ¨hw, hnâŸ© | H)
  Â· exact integral_sub_zpow_of_undef (hn.trans (by decide)) hw
  push_neg at H
  have hd : âˆ€ z, z â‰  w âˆ¨ -1 â‰¤ n â†’
      HasDerivAt (fun z => (z - w) ^ (n + 1) / (n + 1)) ((z - w) ^ n) z := by
    intro z hne
    convert ((hasDerivAt_zpow (n + 1) _ (hne.imp _ _)).comp z
      ((hasDerivAt_id z).sub_const w)).div_const _ using 1
    Â· have hn' : (n + 1 : â„‚) â‰  0 := by
        rwa [Ne, â† eq_neg_iff_add_eq_zero, â† Int.cast_one, â† Int.cast_neg, Int.cast_inj]
      simp [mul_assoc, mul_div_cancel_leftâ‚€ _ hn']
    exacts [sub_ne_zero.2, neg_le_iff_add_nonneg.1]
  refine integral_eq_zero_of_hasDerivWithinAt' fun z hz => (hd z ?_).hasDerivWithinAt
  exact (ne_or_eq z w).imp_right fun (h : z = w) => H <| h â–¸ hz","simp only [integral_sub_zpow_of_ne, integral_sub_zpow_of_ne]"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.ext_iff',ext_iff',67e80fd089fe45abea632652c43b78eba72d60e3,":=
  âŸ¨fun h => h â–¸ âŸ¨rfl, fun _ _ => rflâŸ©, fun âŸ¨hâ‚, hâ‚‚âŸ© =>
    ext fun a => by
      exact if h : a âˆˆ f.support then hâ‚‚ a h else by
        have hf : f a = 0 := not_mem_support_iff.1 h
        have hg : g a = 0 := by rwa [hâ‚, not_mem_support_iff] at h
        rw [hf, hg]âŸ©","warning:  Finsupp does not have a doc string
error:  failed to synthesize
  Decidable (a âˆˆ f.support)
use `set_option diagnostics true` to get diagnostic information","theorem ext_iff' {f g : Î± â†’â‚€ M} : f = g â†” f.support = g.support âˆ§ âˆ€ x âˆˆ f.support, f x = g x ",":=
  âŸ¨fun h => h â–¸ âŸ¨rfl, fun _ _ => rflâŸ©, fun âŸ¨hâ‚, hâ‚‚âŸ© =>
    ext fun a => by
      classical
      exact if h : a âˆˆ f.support then hâ‚‚ a h else by
        have hf : f a = 0 := not_mem_support_iff.1 h
        have hg : g a = 0 := by rwa [hâ‚, not_mem_support_iff] at h
        rw [hf, hg]âŸ©","refine âŸ¨fun h => ?_, fun x hx => ?_âŸ©"
Mathlib/Topology/Algebra/Semigroup.lean,exists_idempotent_of_compact_t2_of_continuous_mul_left,exists_idempotent_of_compact_t2_of_continuous_mul_left,0ccf299781295df79fd6dbd49a4f98dc17cb7560,":= by
  let S : Set (Set M) :=
    { N | IsClosed N âˆ§ N.Nonempty âˆ§ âˆ€ (m) (_ : m âˆˆ N) (m') (_ : m' âˆˆ N), m * m' âˆˆ N }
  obtain âŸ¨N, âŸ¨N_closed, âŸ¨m, hmâŸ©, N_mulâŸ©, N_minimalâŸ© : âˆƒ N âˆˆ S, âˆ€ N' âˆˆ S, N' âŠ† N â†’ N' = N
  rotate_left 
  Â· use m
    have scaling_eq_self : (Â· * m) '' N = N :=
      by
      apply N_minimal
      Â· refine' âŸ¨(continuous_mul_left m).isClosedMap _ N_closed, âŸ¨_, âŸ¨m, hm, rflâŸ©âŸ©, _âŸ©
        rintro _ âŸ¨m'', hm'', rflâŸ© _ âŸ¨m', hm', rflâŸ©
        refine' âŸ¨m'' * m * m', N_mul _ (N_mul _ hm'' _ hm) _ hm', mul_assoc _ _ _âŸ©
      Â· rintro _ âŸ¨m', hm', rflâŸ©
        exact N_mul _ hm' _ hm
    have absorbing_eq_self : N âˆ© { m' | m' * m = m } = N :=
      by
      apply N_minimal
      Â· refine' âŸ¨N_closed.inter ((T1Space.t1 m).preimage (continuous_mul_left m)), _, _âŸ©
        Â· rwa [â† scaling_eq_self] at hm
        Â· rintro m'' âŸ¨mem'', eq'' : _ = mâŸ© m' âŸ¨mem', eq' : _ = mâŸ©
          refine' âŸ¨N_mul _ mem'' _ mem', _âŸ©
          rw [Set.mem_setOf_eq, mul_assoc, eq', eq'']
      apply Set.inter_subset_left
    rw [â† absorbing_eq_self] at hm
    exact hm.2
  refine' zorn_superset _ fun c hcs hc => _
  refine'
    âŸ¨â‹‚â‚€ c, âŸ¨isClosed_interâ‚› fun t ht => (hcs ht).1, _, fun m hm m' hm' => _âŸ©, fun s hs =>
      Set.interâ‚›_subset_of_mem hsâŸ©
  Â· obtain rfl | hcnemp := c.eq_empty_or_nonempty
    Â· rw [Set.interâ‚›_empty]
      apply Set.univ_nonempty
    convert
      @IsCompact.nonempty_interáµ¢_of_directed_nonempty_compact_closed _ _ _ hcnemp.coe_sort
        ((â†‘) : c â†’ Set M) ?_ ?_ ?_ ?_
    Â· simp only [Subtype.range_coe_subtype, Set.setOf_mem_eq]
      exact Set.interâ‚›_eq_interáµ¢
    Â· refine' DirectedOn.directed_val (IsChain.directedOn hc.symm)
    exacts[fun i => (hcs i.prop).2.1, fun i => (hcs i.prop).1.isCompact, fun i => (hcs i.prop).1]
  Â· rw [Set.mem_interâ‚›]
    exact fun t ht => (hcs ht).2.2 m (Set.mem_interâ‚›.mp hm t ht) m' (Set.mem_interâ‚›.mp hm' t ht)","error:  unknown identifier 'isClosed_interâ‚›'
error:  unknown constant 'Set.interâ‚›_subset_of_mem'
error:  unknown constant 'Set.interâ‚›_empty'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.6376
case refine'_1.inl
M : Type u_1
instâœâ´ : Nonempty M
instâœÂ³ : Semigroup M
instâœÂ² : TopologicalSpace M
instâœÂ¹ : CompactSpace M
instâœ : T2Space M
continuous_mul_left : âˆ€ (r : M), Continuous fun x â†¦ x * r
S : Set (Set M) := {N | IsClosed N âˆ§ N.Nonempty âˆ§ âˆ€ m âˆˆ N, âˆ€ m' âˆˆ N, m * m' âˆˆ N}
hcs : âˆ… âŠ† S
hc : IsChain (fun x x_1 â†¦ x âŠ† x_1) âˆ…
âŠ¢ (â‹‚â‚€ âˆ…).Nonempty
error:  invalid use of field notation with `@` modifier
error:  no goals to be solved
error:  unknown constant 'Set.mem_interâ‚›'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.6414
case refine'_2
M : Type u_1
instâœâ´ : Nonempty M
instâœÂ³ : Semigroup M
instâœÂ² : TopologicalSpace M
instâœÂ¹ : CompactSpace M
instâœ : T2Space M
continuous_mul_left : âˆ€ (r : M), Continuous fun x â†¦ x * r
S : Set (Set M) := {N | IsClosed N âˆ§ N.Nonempty âˆ§ âˆ€ m âˆˆ N, âˆ€ m' âˆˆ N, m * m' âˆˆ N}
c : Set (Set M)
hcs : c âŠ† S
hc : IsChain (fun x x_1 â†¦ x âŠ† x_1) c
m : M
hm : m âˆˆ â‹‚â‚€ c
m' : M
hm' : m' âˆˆ â‹‚â‚€ c
âŠ¢ m * m' âˆˆ â‹‚â‚€ c","theorem exists_idempotent_of_compact_t2_of_continuous_mul_left {M} [Nonempty M] [Semigroup M]
    [TopologicalSpace M] [CompactSpace M] [T2Space M]
    (continuous_mul_left : âˆ€ r : M, Continuous (Â· * r)) : âˆƒ m : M, m * m = m ",":= by
  let S : Set (Set M) :=
    { N | IsClosed N âˆ§ N.Nonempty âˆ§ âˆ€ (m) (_ : m âˆˆ N) (m') (_ : m' âˆˆ N), m * m' âˆˆ N }
  rsuffices âŸ¨N, âŸ¨N_closed, âŸ¨m, hmâŸ©, N_mulâŸ©, N_minimalâŸ© : âˆƒ N âˆˆ S, âˆ€ N' âˆˆ S, N' âŠ† N â†’ N' = N
  Â· use m
    have scaling_eq_self : (Â· * m) '' N = N := by
      apply N_minimal
      Â· refine âŸ¨(continuous_mul_left m).isClosedMap _ N_closed, âŸ¨_, âŸ¨m, hm, rflâŸ©âŸ©, ?_âŸ©
        rintro _ âŸ¨m'', hm'', rflâŸ© _ âŸ¨m', hm', rflâŸ©
        exact âŸ¨m'' * m * m', N_mul _ (N_mul _ hm'' _ hm) _ hm', mul_assoc _ _ _âŸ©
      Â· rintro _ âŸ¨m', hm', rflâŸ©
        exact N_mul _ hm' _ hm
    have absorbing_eq_self : N âˆ© { m' | m' * m = m } = N := by
      apply N_minimal
      Â· refine âŸ¨N_closed.inter ((T1Space.t1 m).preimage (continuous_mul_left m)), ?_, ?_âŸ©
        Â· rwa [â† scaling_eq_self] at hm
        Â· rintro m'' âŸ¨mem'', eq'' : _ = mâŸ© m' âŸ¨mem', eq' : _ = mâŸ©
          refine âŸ¨N_mul _ mem'' _ mem', ?_âŸ©
          rw [Set.mem_setOf_eq, mul_assoc, eq', eq'']
      apply Set.inter_subset_left
    rw [â† absorbing_eq_self] at hm
    exact hm.2
  refine zorn_superset _ fun c hcs hc => ?_
  refine
    âŸ¨â‹‚â‚€ c, âŸ¨isClosed_sInter fun t ht => (hcs ht).1, ?_, fun m hm m' hm' => ?_âŸ©, fun s hs =>
      Set.sInter_subset_of_mem hsâŸ©
  Â· obtain rfl | hcnemp := c.eq_empty_or_nonempty
    Â· rw [Set.sInter_empty]
      apply Set.univ_nonempty
    convert
      @IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed _ _ _ hcnemp.coe_sort
        ((â†‘) : c â†’ Set M) ?_ ?_ ?_ ?_
    Â· exact Set.sInter_eq_iInter
    Â· refine DirectedOn.directed_val (IsChain.directedOn hc.symm)
    exacts [fun i => (hcs i.prop).2.1, fun i => (hcs i.prop).1.isCompact, fun i => (hcs i.prop).1]
  Â· rw [Set.mem_sInter]
    exact fun t ht => (hcs ht).2.2 m (Set.mem_sInter.mp hm t ht) m' (Set.mem_sInter.mp hm' t ht)","rw [exists_idempotent_of_compact_t2_of_continuous_mul_left, exists_idempotent_of_compact_t2_of_continuous_mul_left]"
Mathlib/NumberTheory/LSeries/AbstractFuncEq.lean,WeakFEPair.hf_modif_int,hf_modif_int,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have : LocallyIntegrableOn (fun x : â„ â†¦ (P.Îµ * â†‘(x ^ (-P.k))) â€¢ P.gâ‚€) (Ioi 0) := by
    refine ContinuousOn.locallyIntegrableOn ?_ measurableSet_Ioi
    refine ContinuousAt.continuousOn (fun x (hx : 0 < x) â†¦ ?_)
    refine (continuousAt_const.mul ?_).smul continuousAt_const
    exact continuous_ofReal.continuousAt.comp (continuousAt_rpow_const _ _ (Or.inl hx.ne'))
  refine LocallyIntegrableOn.add (fun x hx â†¦ ?_) (fun x hx â†¦ ?_)
  Â· obtain âŸ¨s, hs, hs'âŸ© := P.hf_int.sub (locallyIntegrableOn_const _) x hx
    refine âŸ¨s, hs, ?_âŸ©
    rw [IntegrableOn, integrable_indicator_iff measurableSet_Ioi, IntegrableOn,
      Measure.restrict_restrict measurableSet_Ioi, â† IntegrableOn]
    exact hs'.mono_set (Set.inter_subset_right _ _)
  Â· obtain âŸ¨s, hs, hs'âŸ© := P.hf_int.sub this x hx
    refine âŸ¨s, hs, ?_âŸ©
    rw [IntegrableOn, integrable_indicator_iff measurableSet_Ioo, IntegrableOn,
      Measure.restrict_restrict measurableSet_Ioo, â† IntegrableOn]
    exact hs'.mono_set (Set.inter_subset_right _ _)","error:  function expected at
  inter_subset_right ?m.98594
term has type
  ?m.98593 âˆˆ ?m.98592
error:  function expected at
  inter_subset_right ?m.100631
term has type
  ?m.100630 âˆˆ ?m.100629","lemma hf_modif_int :
    LocallyIntegrableOn P.f_modif (Ioi 0) ",":= by
  have : LocallyIntegrableOn (fun x : â„ â†¦ (P.Îµ * â†‘(x ^ (-P.k))) â€¢ P.gâ‚€) (Ioi 0) := by
    refine ContinuousOn.locallyIntegrableOn ?_ measurableSet_Ioi
    refine ContinuousAt.continuousOn (fun x (hx : 0 < x) â†¦ ?_)
    refine (continuousAt_const.mul ?_).smul continuousAt_const
    exact continuous_ofReal.continuousAt.comp (continuousAt_rpow_const _ _ (Or.inl hx.ne'))
  refine LocallyIntegrableOn.add (fun x hx â†¦ ?_) (fun x hx â†¦ ?_)
  Â· obtain âŸ¨s, hs, hs'âŸ© := P.hf_int.sub (locallyIntegrableOn_const _) x hx
    refine âŸ¨s, hs, ?_âŸ©
    rw [IntegrableOn, integrable_indicator_iff measurableSet_Ioi, IntegrableOn,
      Measure.restrict_restrict measurableSet_Ioi, â† IntegrableOn]
    exact hs'.mono_set Set.inter_subset_right
  Â· obtain âŸ¨s, hs, hs'âŸ© := P.hf_int.sub this x hx
    refine âŸ¨s, hs, ?_âŸ©
    rw [IntegrableOn, integrable_indicator_iff measurableSet_Ioo, IntegrableOn,
      Measure.restrict_restrict measurableSet_Ioo, â† IntegrableOn]
    exact hs'.mono_set Set.inter_subset_right","have hf_modif_int : LocallyIntegrableOn P.f_modif (Ioi (0 : â„)) :=
  hf_modif_int.locallyIntegrableOn_f_modif_Ioc"
Mathlib/GroupTheory/Sylow.lean,not_dvd_index_sylow',not_dvd_index_sylow',8c7e2497d6b5ded2cb20ad30538ebffa5560f7a2,":= by
  intro h
  letI : Finite (G â§¸ (P : Subgroup G)) := (P : Subgroup G).finite_quotient_of_finiteIndex
  rw [index] at h
  obtain âŸ¨x, hxâŸ© := exists_prime_orderOf_dvd_card' (G := G â§¸ (P : Subgroup G)) p h
  have h := IsPGroup.of_card (((Nat.card_zpowers x).trans hx).trans (pow_one p).symm)
  let Q := (zpowers x).comap (QuotientGroup.mk' (P : Subgroup G))
  have hQ : IsPGroup p Q := by
    apply h.comap_of_ker_isPGroup
    rw [QuotientGroup.ker_mk']
    exact P.2
  replace hp := mt orderOf_eq_one_iff.mpr (ne_of_eq_of_ne hx hp.1.ne_one)
  rw [â† zpowers_eq_bot, â† Ne, â† bot_lt_iff_ne_bot, â†
    comap_lt_comap_of_surjective (QuotientGroup.mk'_surjective _), MonoidHom.comap_bot,
    QuotientGroup.ker_mk'] at hp
  exact hp.ne' (P.3 hQ hp.le)","error:  unknown identifier 'exists_prime_orderOf_dvd_card''
error:  rcases tactic failed: xâœ : ?m.102127 is not an inductive datatype","theorem not_dvd_index_sylow' [hp : Fact p.Prime] (P : Sylow p G) [(P : Subgroup G).Normal]
    [fP : FiniteIndex (P : Subgroup G)] : Â¬p âˆ£ (P : Subgroup G).index ",":= by
  intro h
  letI : Fintype (G â§¸ (P : Subgroup G)) := (P : Subgroup G).fintypeQuotientOfFiniteIndex
  rw [index_eq_card (P : Subgroup G)] at h
  obtain âŸ¨x, hxâŸ© := exists_prime_orderOf_dvd_card (G := G â§¸ (P : Subgroup G)) p h
  have h := IsPGroup.of_card ((Fintype.card_zpowers.trans hx).trans (pow_one p).symm)
  let Q := (zpowers x).comap (QuotientGroup.mk' (P : Subgroup G))
  have hQ : IsPGroup p Q := by
    apply h.comap_of_ker_isPGroup
    rw [QuotientGroup.ker_mk']
    exact P.2
  replace hp := mt orderOf_eq_one_iff.mpr (ne_of_eq_of_ne hx hp.1.ne_one)
  rw [â† zpowers_eq_bot, â† Ne, â† bot_lt_iff_ne_bot, â†
    comap_lt_comap_of_surjective (QuotientGroup.mk'_surjective _), MonoidHom.comap_bot,
    QuotientGroup.ker_mk'] at hp
  exact hp.ne' (P.3 hQ hp.le)",apply FiniteIndex.index_normal
Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean,CategoryTheory.InjectiveResolution.exactâ‚€,exactâ‚€,9072ff84a0d139a344bf9eed4a00c4cd27596c79,:=,error:  unexpected token 'def'; expected term,"lemma exactâ‚€ {Z : C} (I : InjectiveResolution Z) :
    (ShortComplex.mk _ _ I.Î¹_f_zero_comp_complex_d).Exact ",":=
  ShortComplex.exact_of_f_is_kernel _ I.isLimitKernelFork",rw [exact_iff_Î¹_f_zero_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_comp_c
Mathlib/Topology/UniformSpace/Cauchy.lean,UniformSpace.complete_of_convergent_controlled_sequences,complete_of_convergent_controlled_sequences,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  obtain âŸ¨U', -, hU'âŸ© := (ğ“¤ Î±).exists_antitone_seq
  have Hmem : âˆ€ n, U n âˆ© U' n âˆˆ ğ“¤ Î± := fun n => inter_mem (U_mem n) (hU'.2 âŸ¨n, Subset.refl _âŸ©)
  refine âŸ¨fun hf => (HU (seq hf Hmem) fun N m n hm hn => ?_).imp <|
    le_nhds_of_seq_tendsto_nhds _ _ fun s hs => ?_âŸ©
  Â· exact inter_subset_left _ _ (seq_pair_mem hf Hmem hm hn)
  Â· rcases hU'.1 hs with âŸ¨N, hNâŸ©
    exact âŸ¨N, Subset.trans (inter_subset_right _ _) hNâŸ©","error:  function expected at
  inter_subset_left ?m.115590
term has type
  ?m.115589 âˆˆ ?m.115587
error:  function expected at
  inter_subset_right ?m.115678
term has type
  ?m.115677 âˆˆ ?m.115676","theorem complete_of_convergent_controlled_sequences (U : â„• â†’ Set (Î± Ã— Î±)) (U_mem : âˆ€ n, U n âˆˆ ğ“¤ Î±)
    (HU : âˆ€ u : â„• â†’ Î±, (âˆ€ N m n, N â‰¤ m â†’ N â‰¤ n â†’ (u m, u n) âˆˆ U N) â†’ âˆƒ a, Tendsto u atTop (ğ“ a)) :
    CompleteSpace Î± ",":= by
  obtain âŸ¨U', -, hU'âŸ© := (ğ“¤ Î±).exists_antitone_seq
  have Hmem : âˆ€ n, U n âˆ© U' n âˆˆ ğ“¤ Î± := fun n => inter_mem (U_mem n) (hU'.2 âŸ¨n, Subset.refl _âŸ©)
  refine âŸ¨fun hf => (HU (seq hf Hmem) fun N m n hm hn => ?_).imp <|
    le_nhds_of_seq_tendsto_nhds _ _ fun s hs => ?_âŸ©
  Â· exact inter_subset_left (seq_pair_mem hf Hmem hm hn)
  Â· rcases hU'.1 hs with âŸ¨N, hNâŸ©
    exact âŸ¨N, Subset.trans inter_subset_right hNâŸ©",rw [complete_of_convergent_controlled_sequences]
Mathlib/Data/Multiset/Antidiagonal.lean,Multiset.mem_antidiagonal,mem_antidiagonal,ced2b4d50f342fd67dab9fde95e01ae0980a16eb,":=
  Quotient.inductionOn s <| fun l â†¦ by
    dsimp only [quot_mk_to_coe, antidiagonal_coe]
    refine' âŸ¨fun h => revzip_powersetAux h, fun h â†¦ _âŸ©
    haveI := Classical.decEq Î±
    simp only [revzip_powersetAux_lemma l revzip_powersetAux, h.symm, ge_iff_le, mem_coe, mem_map',
  mem_powersetAux]
    cases' x with xâ‚ xâ‚‚
    exact âŸ¨xâ‚, le_add_right _ _, by rw [add_tsub_cancel_left xâ‚ xâ‚‚]âŸ©","error:  unknown identifier 'mem_map''
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type with only one constructor 
  List.Mem (xâ‚, xâ‚‚) (List.map (fun x â†¦ (x, (xâ‚, xâ‚‚).1 + (xâ‚, xâ‚‚).2 - x)) (powersetAux l))","theorem mem_antidiagonal {s : Multiset Î±} {x : Multiset Î± Ã— Multiset Î±} :
    x âˆˆ antidiagonal s â†” x.1 + x.2 = s ",":=
  Quotient.inductionOn s fun l â†¦ by
    dsimp only [quot_mk_to_coe, antidiagonal_coe]
    refine âŸ¨fun h => revzip_powersetAux h, fun h â†¦ ?_âŸ©
    haveI := Classical.decEq Î±
    simp only [revzip_powersetAux_lemma l revzip_powersetAux, h.symm, ge_iff_le, mem_coe,
      List.mem_map, mem_powersetAux]
    cases' x with xâ‚ xâ‚‚
    exact âŸ¨xâ‚, le_add_right _ _, by rw [add_tsub_cancel_left xâ‚ xâ‚‚]âŸ©","rw [mem_antidiagonal, mem_antidiagonal]"
Mathlib/Topology/Instances/EReal.lean,EReal.nhds_bot_basis,nhds_bot_basis,f3df819bd51d0f3495e887909f4ab5efc2965f66,":= by
  refine nhds_bot_basis.to_hasBasis (fun x hx => ?_) fun _ _ â†¦ âŸ¨_, bot_lt_coe _, Subset.rflâŸ©
  rcases exists_rat_btwn_of_lt hx with âŸ¨y, -, hxyâŸ©
  exact âŸ¨_, trivial, Iio_subset_Iio hxy.leâŸ©","error:  application type mismatch
  And.intro (bot_lt_coe ?m.13211)
argument
  bot_lt_coe ?m.13211
has type
  âŠ¥ < â†‘?m.13211 : Prop
but is expected to have type
  True : Prop
error:  application type mismatch
  exists_rat_btwn_of_lt hx
argument
  hx
has type
  True : Prop
but is expected to have type
  ?m.13450 < ?m.13451 : Prop",theorem nhds_bot_basis : (ğ“ (âŠ¥ : EReal)).HasBasis (fun _ : â„ â†¦ True) (Iio Â·) ,":= by
  refine _root_.nhds_bot_basis.to_hasBasis (fun x hx => ?_) fun _ _ â†¦ âŸ¨_, bot_lt_coe _, Subset.rflâŸ©
  rcases exists_rat_btwn_of_lt hx with âŸ¨y, -, hxyâŸ©
  exact âŸ¨_, trivial, Iio_subset_Iio hxy.leâŸ©",refine (nhds_bot_basis.hasBasis nhds_bot_basis).mono ?_
Mathlib/NumberTheory/FunctionField.lean,functionField_iff,functionField_iff,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  let e := IsLocalization.algEquiv Fq[X]â° (RatFunc Fq) Fqt
  have : âˆ€ (c) (x : F), e c â€¢ x = c â€¢ x := by
    intro c x
    rw [Algebra.smul_def, Algebra.smul_def]
    congr
    refine congr_fun (f := fun c => algebraMap Fqt F (e c)) ?_ c 
    refine IsLocalization.ext (nonZeroDivisors Fq[X]) _ _ ?_ ?_? _? ?_ _ <;> intros <;>
      simp only [AlgEquiv.map_one, RingHom.map_one, AlgEquiv.map_mul, RingHom.map_mul,
        AlgEquiv.commutes, â† IsScalarTower.algebraMap_apply]
  constructor <;> intro h
  Â· let b := FiniteDimensional.finBasis (RatFunc Fq) F
    exact FiniteDimensional.of_fintype_basis (b.mapCoeffs e this)
  Â· let b := FiniteDimensional.finBasis Fqt F
    refine FiniteDimensional.of_fintype_basis (b.mapCoeffs e.symm ?_)
    intro c x; convert (this (e.symm c) x).symm; simp only [e.apply_symm_apply]",error:  unknown identifier '_?',"theorem functionField_iff (Fqt : Type*) [Field Fqt] [Algebra Fq[X] Fqt]
    [IsFractionRing Fq[X] Fqt] [Algebra (RatFunc Fq) F] [Algebra Fqt F] [Algebra Fq[X] F]
    [IsScalarTower Fq[X] Fqt F] [IsScalarTower Fq[X] (RatFunc Fq) F] :
    FunctionField Fq F â†” FiniteDimensional Fqt F ",":= by
  let e := IsLocalization.algEquiv Fq[X]â° (RatFunc Fq) Fqt
  have : âˆ€ (c) (x : F), e c â€¢ x = c â€¢ x := by
    intro c x
    rw [Algebra.smul_def, Algebra.smul_def]
    congr
    refine congr_fun (f := fun c => algebraMap Fqt F (e c)) ?_ c 
    refine IsLocalization.ext (nonZeroDivisors Fq[X]) _ _ ?_ ?_ ?_ ?_ ?_ <;> intros <;>
      simp only [map_one, map_mul, AlgEquiv.commutes, â† IsScalarTower.algebraMap_apply]
  constructor <;> intro h
  Â· let b := FiniteDimensional.finBasis (RatFunc Fq) F
    exact FiniteDimensional.of_fintype_basis (b.mapCoeffs e this)
  Â· let b := FiniteDimensional.finBasis Fqt F
    refine FiniteDimensional.of_fintype_basis (b.mapCoeffs e.symm ?_)
    intro c x; convert (this (e.symm c) x).symm; simp only [e.apply_symm_apply]",constructor
Mathlib/Combinatorics/Additive/FreimanHom.lean,IsMulFreimanHom.prod,IsMulFreimanHom.prod,754ba19de1471fd928c4fa0cc102d1f06f90e902,"  mapsTo := hâ‚.mapsTo.prodMap hâ‚‚.mapsTo
  map_prod_eq_map_prod s t hsA htA hs ht h := by
    simp only [mem_prod, forall_and, Prod.forall] at hsA htA
    simp only [Prod.map_apply, Prod.ext_iff, fst_prod, map_map, Function.comp_apply, snd_prod]
      at h âŠ¢
    rw [â† Function.comp_def, â† map_map, â† map_map, â† Function.comp_def fâ‚‚, â† map_map, â† map_map]
    exact âŸ¨hâ‚.map_prod_eq_map_prod (by simpa using hsA.1) (by simpa using htA.1) (by simpa)
      (by simpa) h.1, hâ‚‚.map_prod_eq_map_prod (by simpa [@forall_swap Î±â‚] using hsA.2)
      (by simpa [@forall_swap Î±â‚] using htA.2) (by simpa) (by simpa) h.2âŸ©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  fun x â†¦ fâ‚‚ (?g x)
F : Type u_1
Î± : Type u_2
Î² : Type u_3
Î³ : Type u_4
Î±â‚ : Type u_5
Î±â‚‚ : Type u_6
Î²â‚ : Type u_7
Î²â‚‚ : Type u_8
instâœÂ³ : CommMonoid Î±â‚
instâœÂ² : CommMonoid Î±â‚‚
instâœÂ¹ : CommMonoid Î²â‚
instâœ : CommMonoid Î²â‚‚
Aâ‚ : Set Î±â‚
Aâ‚‚ : Set Î±â‚‚
Bâ‚ : Set Î²â‚
Bâ‚‚ : Set Î²â‚‚
fâ‚ : Î±â‚ â†’ Î²â‚
fâ‚‚ : Î±â‚‚ â†’ Î²â‚‚
n : â„•
hâ‚ : IsMulFreimanHom n Aâ‚ Bâ‚ fâ‚
hâ‚‚ : IsMulFreimanHom n Aâ‚‚ Bâ‚‚ fâ‚‚
s t : Multiset (Î±â‚ Ã— Î±â‚‚)
hs : card s = n
ht : card t = n
hsA : (âˆ€ (a : Î±â‚) (b : Î±â‚‚), (a, b) âˆˆ s â†’ a âˆˆ Aâ‚) âˆ§ âˆ€ (a : Î±â‚) (b : Î±â‚‚), (a, b) âˆˆ s â†’ b âˆˆ Aâ‚‚
htA : (âˆ€ (a : Î±â‚) (b : Î±â‚‚), (a, b) âˆˆ t â†’ a âˆˆ Aâ‚) âˆ§ âˆ€ (a : Î±â‚) (b : Î±â‚‚), (a, b) âˆˆ t â†’ b âˆˆ Aâ‚‚
h : (map Prod.fst s).prod = (map Prod.fst t).prod âˆ§ (map Prod.snd s).prod = (map Prod.snd t).prod
âŠ¢ (map Prod.fst (map (Prod.map fâ‚ fâ‚‚) s)).prod = (map Prod.fst (map (Prod.map fâ‚ fâ‚‚) t)).prod âˆ§
    (map (fun x â†¦ (Prod.map fâ‚ fâ‚‚ x).2) s).prod = (map (fun x â†¦ (Prod.map fâ‚ fâ‚‚ x).2) t).prod","lemma IsMulFreimanHom.prod (hâ‚ : IsMulFreimanHom n Aâ‚ Bâ‚ fâ‚) (hâ‚‚ : IsMulFreimanHom n Aâ‚‚ Bâ‚‚ fâ‚‚) :
    IsMulFreimanHom n (Aâ‚ Ã—Ë¢ Aâ‚‚) (Bâ‚ Ã—Ë¢ Bâ‚‚) (Prod.map fâ‚ fâ‚‚) where
","  mapsTo := hâ‚.mapsTo.prodMap hâ‚‚.mapsTo
  map_prod_eq_map_prod s t hsA htA hs ht h := by
    simp only [mem_prod, forall_and, Prod.forall] at hsA htA
    simp only [Prod.ext_iff, fst_prod, snd_prod, map_map, Function.comp_apply, Prod.map_fst,
      Prod.map_snd] at h âŠ¢
    rw [â† Function.comp_def, â† map_map, â† map_map, â† Function.comp_def fâ‚‚, â† map_map, â† map_map]
    exact âŸ¨hâ‚.map_prod_eq_map_prod (by simpa using hsA.1) (by simpa using htA.1) (by simpa)
      (by simpa) h.1, hâ‚‚.map_prod_eq_map_prod (by simpa [@forall_swap Î±â‚] using hsA.2)
      (by simpa [@forall_swap Î±â‚] using htA.2) (by simpa) (by simpa) h.2âŸ©","simp only [IsMulFreimanHom.prod, IsMulFreimanHom.map_eq, IsMulFreimanHom.map_eq]"
Mathlib/Algebra/Group/Subgroup/Pointwise.lean,Subgroup.iSup_induction',iSup_induction',fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  suffices âˆƒ h, C x h from this.snd
  refine iSup_induction S (C := fun x => âˆƒ h, C x h) hx (fun i x hx => ?_) ?_ fun x y =?> _
  Â· exact âŸ¨_, hp i _ hxâŸ©
  Â· exact âŸ¨_, h1âŸ©
  Â· rintro âŸ¨_, CxâŸ© âŸ¨_, CyâŸ©
    exact âŸ¨_, hmul _ _ _ _ Cx CyâŸ©","error:  unexpected token '='; expected 'â†¦', '=>'
error:  unsolved goals
case refine_1
Î± : Type u_1
G : Type u_2
A : Type u_3
Sâœ : Type u_4
instâœÂ¹ : Group G
instâœ : AddGroup A
s : Set G
Î¹ : Sort u_5
S : Î¹ â†’ Subgroup G
C : (x : G) â†’ x âˆˆ â¨† i, S i â†’ Prop
hp : âˆ€ (i : Î¹) (x : G) (hx : x âˆˆ S i), C x â‹¯
h1 : C 1 â‹¯
hmul : âˆ€ (x y : G) (hx : x âˆˆ â¨† i, S i) (hy : y âˆˆ â¨† i, S i), C x hx â†’ C y hy â†’ C (x * y) â‹¯
xâœ : G
hxâœ : xâœ âˆˆ â¨† i, S i
i : Î¹
x : G
hx : x âˆˆ S i
âŠ¢ (fun x â†¦ âˆƒ (h : x âˆˆ â¨† i, S i), C x h) x

case refine_2
Î± : Type u_1
G : Type u_2
A : Type u_3
Sâœ : Type u_4
instâœÂ¹ : Group G
instâœ : AddGroup A
s : Set G
Î¹ : Sort u_5
S : Î¹ â†’ Subgroup G
C : (x : G) â†’ x âˆˆ â¨† i, S i â†’ Prop
hp : âˆ€ (i : Î¹) (x : G) (hx : x âˆˆ S i), C x â‹¯
h1 : C 1 â‹¯
hmul : âˆ€ (x y : G) (hx : x âˆˆ â¨† i, S i) (hy : y âˆˆ â¨† i, S i), C x hx â†’ C y hy â†’ C (x * y) â‹¯
x : G
hx : x âˆˆ â¨† i, S i
âŠ¢ (fun x â†¦ âˆƒ (h : x âˆˆ â¨† i, S i), C x h) 1","theorem iSup_induction' {Î¹ : Sort*} (S : Î¹ â†’ Subgroup G) {C : âˆ€ x, (x âˆˆ â¨† i, S i) â†’ Prop}
    (hp : âˆ€ (i), âˆ€ x (hx : x âˆˆ S i), C x (mem_iSup_of_mem i hx)) (h1 : C 1 (one_mem _))
    (hmul : âˆ€ x y hx hy, C x hx â†’ C y hy â†’ C (x * y) (mul_mem â€¹_â€º â€¹_â€º)) {x : G}
    (hx : x âˆˆ â¨† i, S i) : C x hx ",":= by
  suffices âˆƒ h, C x h from this.snd
  refine iSup_induction S (C := fun x => âˆƒ h, C x h) hx (fun i x hx => ?_) ?_ fun x y => ?_
  Â· exact âŸ¨_, hp i _ hxâŸ©
  Â· exact âŸ¨_, h1âŸ©
  Â· rintro âŸ¨_, CxâŸ© âŸ¨_, CyâŸ©
    exact âŸ¨_, hmul _ _ _ _ Cx CyâŸ©",simp only [Submodule.mem_iSup_of_mem] at hx
Mathlib/Topology/NoetherianSpace.lean,TopologicalSpace.noetherianSpace_TFAE,noetherianSpace_TFAE,62c2d6a1d2ffdbe5bcaa653b84d3602a209e4c8c,":= by
  tfae_have : 1 â†” 2
  Â· refine' (noetherianSpace_iff Î±).trans (Opens.compl_bijective.2.wellFounded_iff _)
    exact (@OrderIso.compl (Set Î±)).lt_iff_lt.symm
  tfae_have : 1 â†” 4 := noetherianSpace_iff_opens Î±
  tfae_have : 1 â†’ 3 := @NoetherianSpace.isCompact Î± _
  tfae_have : 3 â†’ 4 := fun h s => h s
  tfae_finish",error:  unexpected token ':'; expected numeral,"theorem noetherianSpace_TFAE :
    TFAE [NoetherianSpace Î±,
      WellFounded fun s t : Closeds Î± => s < t,
      âˆ€ s : Set Î±, IsCompact s,
      âˆ€ s : Opens Î±, IsCompact (s : Set Î±)] ",":= by
  tfae_have 1 â†” 2
  Â· refine (noetherianSpace_iff Î±).trans (Opens.compl_bijective.2.wellFounded_iff ?_)
    exact (@OrderIso.compl (Set Î±)).lt_iff_lt.symm
  tfae_have 1 â†” 4
  Â· exact noetherianSpace_iff_opens Î±
  tfae_have 1 â†’ 3
  Â· exact @NoetherianSpace.isCompact Î± _
  tfae_have 3 â†’ 4
  Â· exact fun h s => h s
  tfae_finish",have noetherianSpace_TFAE : NoetherianSpace Î± := noetherianSpace_TFAE
Mathlib/RingTheory/Polynomial/Chebyshev.lean,Polynomial.Chebyshev.U_neg_sub_one,U_neg_sub_one,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  induction n using Polynomial.Chebyshev.induct with
  | zero => simp
  | one => simp
  | add_two n ih1 ih2 =>
    have hâ‚ := U_add_one R n
    have hâ‚‚ := U_sub_two R (-n - 1)
    linear_combination (norm : = ring_nf) 2 * (X : R[X]) * ih1 - ih2 + hâ‚ + hâ‚‚
  | neg_add_one n ih1 ih2 =>
    have hâ‚ := U_eq R n
    have hâ‚‚ := U_sub_two R (-n)
    linear_combination (norm : = ring_nf) 2 * (X : R[X]) * ih1 - ih2 + hâ‚ + hâ‚‚",error:  unexpected token '='; expected ')' or term,theorem U_neg_sub_one (n : â„¤) : U R (-n - 1) = -U R (n - 1) ,":= by
  induction n using Polynomial.Chebyshev.induct with
  | zero => simp
  | one => simp
  | add_two n ih1 ih2 =>
    have hâ‚ := U_add_one R n
    have hâ‚‚ := U_sub_two R (-n - 1)
    linear_combination (norm := ring_nf) 2 * (X:R[X]) * ih1 - ih2 + hâ‚ + hâ‚‚
  | neg_add_one n ih1 ih2 =>
    have hâ‚ := U_eq R n
    have hâ‚‚ := U_sub_two R (-n)
    linear_combination (norm := ring_nf) 2 * (X:R[X]) * ih1 - ih2 + hâ‚ + hâ‚‚","rw [U_neg_sub_one, U_neg_sub_one]"
Mathlib/MeasureTheory/Integral/Asymptotics.lean,Asymptotics.IsBigO.integrableAtFilter,_root_.Asymptotics.IsBigO.integrableAtFilter,52854be362822e3e1dd0f9fa9f183a3e9d5dc753,":= by
  obtain âŸ¨C, hCâŸ© := hf.bound
  obtain âŸ¨C', hC'âŸ© := NormedField.exists_lt_norm F C
  obtain âŸ¨s, hsl, hsâŸ© := hC.exists_mem
  obtain âŸ¨t, htl, htâŸ© := hg
  obtain âŸ¨u, hul, huâŸ© := hfm
  obtain âŸ¨S, hS, hs_meas, hs_leâŸ© :=
    IsMeasurablyGenerated.exists_measurable_subset <| inter_mem (inter_mem hsl htl) hul
  use S, hS, hu.mono_measure <| Measure.restrict_mono (fun _ hx â†¦ (hs_le hx).2) le_rfl
  refine ht.mono_set (fun _ hx â†¦ (hs_le hx).1.2) |>.const_mul C' |>.2.mono ?_
  refine (ae_restrict_iff' hs_meas).mpr <| ae_of_all _ fun x hx => (hs x (hs_le hx).1.1).trans ?_
  rewrite [norm_mul]
  gcongr","error:  failed to synthesize
  NontriviallyNormedField F
use `set_option diagnostics true` to get diagnostic information
error:  rcases tactic failed: xâœ : ?m.1122 is not an inductive datatype","theorem _root_.Asymptotics.IsBigO.integrableAtFilter [IsMeasurablyGenerated l]
    (hf : f =O[l] g) (hfm : StronglyMeasurableAtFilter f l Î¼) (hg : IntegrableAtFilter g l Î¼) :
    IntegrableAtFilter f l Î¼ ",":= by
  obtain âŸ¨C, hCâŸ© := hf.bound
  obtain âŸ¨s, hsl, hsm, hfg, hf, hgâŸ© :=
    (hC.smallSets.and <| hfm.eventually.and hg.eventually).exists_measurable_mem_of_smallSets
  refine âŸ¨s, hsl, (hg.norm.const_mul C).mono hf ?_âŸ©
  refine (ae_restrict_mem hsm).mono fun x hx â†¦ ?_
  exact (hfg x hx).trans (le_abs_self _)",rw [IntegrableAtFilter]
Mathlib/Algebra/Lie/EngelSubalgebra.lean,LieSubalgebra.isNilpotent_of_forall_le_engel,isNilpotent_of_forall_le_engel,0c90739c91a34ba4dd9d7d87f450ddf45290a35a,":= by
  rw [LieAlgebra.isNilpotent_iff_forall]
  intro x
  let K : â„• â†’o Submodule R H :=
    âŸ¨fun n â†¦ LinearMap.ker ((ad R H x) ^ n), fun m n hmn â†¦ ?monoâŸ©
  case mono =>
    intro y hy
    rw [LinearMap.mem_ker] at hy âŠ¢
    exact LinearMap.pow_map_zero_of_le hmn hy
  obtain âŸ¨n, hnâŸ© := monotone_stabilizes_iff_noetherian.mpr inferInstance K
  use n
  ext y
  rw [coe_ad_pow]
  specialize h x x.2 y.2
  rw [mem_engel_iff] at h
  obtain âŸ¨m, hmâŸ© := h
  obtain (hmn|hmn) : m â‰¤ n âˆ¨ n â‰¤ m := le_total m n
  Â· exact LinearMap.pow_map_zero_of_le hmn hm
  Â· have : âˆ€ k : â„•, ((ad R L) x ^ k) y = 0 â†” y âˆˆ K k := by simp [Subtype.ext_iff, coe_ad_pow]
    rwa [this, â† hn m hmn, â† this] at hm",error:  simp made no progress,"lemma isNilpotent_of_forall_le_engel [IsNoetherian R L]
    (H : LieSubalgebra R L) (h : âˆ€ x âˆˆ H, H â‰¤ engel R x) :
    LieAlgebra.IsNilpotent R H ",":= by
  rw [LieAlgebra.isNilpotent_iff_forall]
  intro x
  let K : â„• â†’o Submodule R H :=
    âŸ¨fun n â†¦ LinearMap.ker ((ad R H x) ^ n), fun m n hmn â†¦ ?monoâŸ©
  case mono =>
    intro y hy
    rw [LinearMap.mem_ker] at hy âŠ¢
    exact LinearMap.pow_map_zero_of_le hmn hy
  obtain âŸ¨n, hnâŸ© := monotone_stabilizes_iff_noetherian.mpr inferInstance K
  use n
  ext y
  rw [coe_ad_pow]
  specialize h x x.2 y.2
  rw [mem_engel_iff] at h
  obtain âŸ¨m, hmâŸ© := h
  obtain (hmn|hmn) : m â‰¤ n âˆ¨ n â‰¤ m := le_total m n
  Â· exact LinearMap.pow_map_zero_of_le hmn hm
  Â· have : âˆ€ k : â„•, ((ad R L) x ^ k) y = 0 â†” y âˆˆ K k := by simp [K, Subtype.ext_iff, coe_ad_pow]
    rwa [this, â† hn m hmn, â† this] at hm",apply LieSubalgebra.isNilpotent_isNilpotent_of_le_engel
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_closedBall_covering_tsum_measure_le,exists_closedBall_covering_tsum_measure_le,b50a8b2e9760b6f582390d3948a953c553480df1,":= by
  obtain âŸ¨u, su, u_open, Î¼uâŸ© : âˆƒ U, U âŠ‡ s âˆ§ IsOpen U âˆ§ Î¼ U â‰¤ Î¼ s + Îµ / 2 :=
    Set.exists_isOpen_le_add _ _
      (by
        simpa only [or_false, Ne, ENNReal.div_eq_zero_iff, ENNReal.two_ne_top] using hÎµ)
  have : âˆ€ x âˆˆ s, âˆƒ R > 0, ball x R âŠ† u := fun x hx =>
    Metric.mem_nhds_iff.1 (u_open.mem_nhds (su hx))
  choose! R hR using this
  obtain âŸ¨t0, r0, t0_count, t0s, hr0, Î¼t0, t0_disjâŸ© :
    âˆƒ (t0 : Set Î±) (r0 : Î± â†’ â„), t0.Countable âˆ§ t0 âŠ† s âˆ§
      (âˆ€ x âˆˆ t0, r0 x âˆˆ f x âˆ© Ioo 0 (R x)) âˆ§ Î¼ (s \ â‹ƒ x âˆˆ t0, closedBall x (r0 x)) = 0 âˆ§
        t0.PairwiseDisjoint fun x => closedBall x (r0 x) :=
    exists_disjoint_closedBall_covering_ae Î¼ f s hf R fun x hx => (hR x hx).1
  let s' := s \ â‹ƒ x âˆˆ t0, closedBall x (r0 x)
  have s's : s' âŠ† s := diff_subset _ _
  obtain âŸ¨N, Ï„, hÏ„, HâŸ© : âˆƒ N Ï„, 1 < Ï„ âˆ§ IsEmpty (Besicovitch.SatelliteConfig Î± N Ï„) :=
    HasBesicovitchCovering.no_satelliteConfig
  obtain âŸ¨v, s'v, v_open, Î¼vâŸ© : âˆƒ v, v âŠ‡ s' âˆ§ IsOpen v âˆ§ Î¼ v â‰¤ Î¼ s' + Îµ / 2 / N :=
    Set.exists_isOpen_le_add _ _
      (by
        simp only [ne_eq, ENNReal.div_eq_zero_iff, hÎµ, ENNReal.two_ne_top, or_self,
          ENNReal.nat_ne_top, not_false_eq_true])
  have : âˆ€ x âˆˆ s', âˆƒ r1 âˆˆ f x âˆ© Ioo (0 : â„) 1, closedBall x r1 âŠ† v := by
    intro x hx
    rcases Metric.mem_nhds_iff.1 (v_open.mem_nhds (s'v hx)) with âŸ¨r, rpos, hrâŸ©
    rcases hf x (s's hx) (min r 1) (lt_min rpos zero_lt_one) with âŸ¨R', hR'âŸ©
    exact
      âŸ¨R', âŸ¨hR'.1, hR'.2.1, hR'.2.2.trans_le (min_le_right _ _)âŸ©,
        Subset.trans (closedBall_subset_ball (hR'.2.2.trans_le (min_le_left _ _))) hrâŸ©
  choose! r1 hr1 using this
  let q : BallPackage s' Î± :=
    { c := fun x => x
      r := fun x => r1 x
      rpos := fun x => (hr1 x.1 x.2).1.2.1
      r_bound := 1
      r_le := fun x => (hr1 x.1 x.2).1.2.2.le }
  obtain âŸ¨S, S_disj, hSâŸ© :
    âˆƒ S : Fin N â†’ Set s',
      (âˆ€ i : Fin N, (S i).PairwiseDisjoint fun j => closedBall (q.c j) (q.r j)) âˆ§
        range q.c âŠ† â‹ƒ i : Fin N, â‹ƒ j âˆˆ S i, ball (q.c j) (q.r j) :=
    exist_disjoint_covering_families hÏ„ H q
  have S_count : âˆ€ i, (S i).Countable := by
    intro i
    apply (S_disj i).countable_of_nonempty_interior fun j _ => ?_
    have : (ball (j : Î±) (r1 j)).Nonempty := nonempty_ball.2 (q.rpos _)
    exact this.mono ball_subset_interior_closedBall
  let r x := if x âˆˆ s' then r1 x else r0 x
  have r_t0 : âˆ€ x âˆˆ t0, r x = r0 x := by
    intro x hx
    have : Â¬x âˆˆ s' := by
      simp only [s', not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_lt, not_le,
        mem_diff, not_forall]
      intro _
      refine' âŸ¨x, hx, _âŸ©
      rw [dist_self]
      exact (hr0 x hx).2.1.le
    simp only [r, if_neg this]
  refine' âŸ¨t0 âˆª â‹ƒ i : Fin N, ((â†‘) : s' â†’ Î±) '' S i, r, _, _, _, _, _âŸ©
  Â· exact t0_count.union (countable_iUnion fun i => (S_count i).image _)
  Â· simp only [t0s, true_and_iff, union_subset_iff, image_subset_iff, iUnion_subset_iff]
    intro i x _
    exact s's x.2
  Â· intro x hx
    cases hx with
    | inl hx =>
      rw [r_t0 x hx]
      exact (hr0 _ hx).1
    | inr hx =>
      have h'x : x âˆˆ s' := by
        simp only [mem_iUnion, mem_image] at hx
        rcases hx with âŸ¨i, y, _, rflâŸ©
        exact y.2
      simp only [r, if_pos h'x, (hr1 x h'x).1.1]
  Â· intro x hx
    by_cases h'x : x âˆˆ s'
    Â· obtain âŸ¨i, y, ySi, xyâŸ© : âˆƒ (i : Fin N) (y : â†¥s'), y âˆˆ S i âˆ§ x âˆˆ ball (y : Î±) (r1 y) := by
        have A : x âˆˆ range q.c := by
          simpa only [not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_le,
            mem_setOf_eq, Subtype.range_coe_subtype, mem_diff] using h'x
        simpa only [mem_iUnion, mem_image, bex_def] using hS A
      refine' mem_iUnionâ‚‚.2 âŸ¨y, Or.inr _, _âŸ©
      Â· simp only [mem_iUnion, mem_image]
        exact âŸ¨i, y, ySi, rflâŸ©
      Â· have : (y : Î±) âˆˆ s' := y.2
        simp only [r, if_pos this]
        exact ball_subset_closedBall xy
    Â· obtain âŸ¨y, yt0, hxyâŸ© : âˆƒ y : Î±, y âˆˆ t0 âˆ§ x âˆˆ closedBall y (r0 y) := by
        simpa [s', hx, -mem_closedBall] using h'x
      refine' mem_iUnionâ‚‚.2 âŸ¨y, Or.inl yt0, _âŸ©
      rwa [r_t0 _ yt0]
  Â· 
    have A : (âˆ‘' x : t0, Î¼ (closedBall x (r x))) â‰¤ Î¼ s + Îµ / 2 :=
      calc
        (âˆ‘' x : t0, Î¼ (closedBall x (r x))) = âˆ‘' x : t0, Î¼ (closedBall x (r0 x)) := by
          congr 1; ext x; rw [r_t0 x x.2]
        _ = Î¼ (â‹ƒ x : t0, closedBall x (r0 x)) := by
          haveI : Encodable t0 := t0_count.toEncodable
          rw [measure_iUnion]
          Â· exact (pairwise_subtype_iff_pairwise_set _ _).2 t0_disj
          Â· exact fun i => measurableSet_closedBall
        _ â‰¤ Î¼ u := by
          apply measure_mono
          simp only [SetCoe.forall, Subtype.coe_mk, iUnion_subset_iff]
          intro x hx
          apply Subset.trans (closedBall_subset_ball (hr0 x hx).2.2) (hR x (t0s hx)).2
        _ â‰¤ Î¼ s + Îµ / 2 := Î¼u
    have B : âˆ€ i : Fin N, (âˆ‘' x : ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x))) â‰¤ Îµ / 2 / N :=
      fun i =>
      calc
        (âˆ‘' x : ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x))) =
            âˆ‘' x : S i, Î¼ (closedBall x (r x)) := by
          have : InjOn ((â†‘) : s' â†’ Î±) (S i) := Subtype.val_injective.injOn _
          let F : S i â‰ƒ ((â†‘) : s' â†’ Î±) '' S i := this.bijOn_image.equiv _
          exact (F.tsum_eq fun x => Î¼ (closedBall x (r x))).symm
        _ = âˆ‘' x : S i, Î¼ (closedBall x (r1 x)) := by
          congr 1; ext x; have : (x : Î±) âˆˆ s' := x.1.2; simp only [s', r, if_pos this]
        _ = Î¼ (â‹ƒ x : S i, closedBall x (r1 x)) := by
          haveI : Encodable (S i) := (S_count i).toEncodable
          rw [measure_iUnion]
          Â· exact (pairwise_subtype_iff_pairwise_set _ _).2 (S_disj i)
          Â· exact fun i => measurableSet_closedBall
        _ â‰¤ Î¼ v := by
          apply measure_mono
          simp only [SetCoe.forall, Subtype.coe_mk, iUnion_subset_iff]
          intro x xs' _
          exact (hr1 x xs').2
        _ â‰¤ Îµ / 2 / N := by have : Î¼ s' = 0 := Î¼t0; rwa [this, zero_add] at Î¼v
    calc
      (âˆ‘' x : â†¥(t0 âˆª â‹ƒ i : Fin N, ((â†‘) : s' â†’ Î±) '' S i), Î¼ (closedBall x (r x))) â‰¤
          (âˆ‘' x : t0, Î¼ (closedBall x (r x))) +
            âˆ‘' x : â‹ƒ i : Fin N, ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x)) :=
        ENNReal.tsum_union_le (fun x => Î¼ (closedBall x (r x))) _ _
      _ â‰¤
          (âˆ‘' x : t0, Î¼ (closedBall x (r x))) +
            âˆ‘ i : Fin N, âˆ‘' x : ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x)) :=
        (add_le_add le_rfl (ENNReal.tsum_iUnion_le (fun x => Î¼ (closedBall x (r x))) _))
      _ â‰¤ Î¼ s + Îµ / 2 + âˆ‘ i : Fin N, Îµ / 2 / N := by
        refine' add_le_add A _
        refine' Finset.sum_le_sum _
        intro i _
        exact B i
      _ â‰¤ Î¼ s + Îµ / 2 + Îµ / 2 := by
        refine' add_le_add le_rfl _
        simp only [Finset.card_fin, Finset.sum_const, nsmul_eq_mul, ENNReal.mul_div_le]
      _ = Î¼ s + Îµ := by rw [add_assoc, ENNReal.add_halves]","error:  function expected at
  diff_subset ?m.152257
term has type
  ?m.152256 âˆˆ ?m.152254
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  type mismatch
  Function.Injective.injOn Subtype.val_injective ?m.177674
has type
  âˆ€ â¦ƒxâ‚‚ : Subtype ?m.177651â¦„, xâ‚‚ âˆˆ ?m.177672 â†’ â†‘?m.177673 = â†‘xâ‚‚ â†’ ?m.177673 = xâ‚‚ : Prop
but is expected to have type
  InjOn Subtype.val (S i) : Prop","theorem exists_closedBall_covering_tsum_measure_le (Î¼ : Measure Î±) [SigmaFinite Î¼]
    [Measure.OuterRegular Î¼] {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0) (f : Î± â†’ Set â„) (s : Set Î±)
    (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty) :
    âˆƒ (t : Set Î±) (r : Î± â†’ â„), t.Countable âˆ§ t âŠ† s âˆ§ (âˆ€ x âˆˆ t, r x âˆˆ f x) âˆ§
      (s âŠ† â‹ƒ x âˆˆ t, closedBall x (r x)) âˆ§ (âˆ‘' x : t, Î¼ (closedBall x (r x))) â‰¤ Î¼ s + Îµ ",":= by
  obtain âŸ¨u, su, u_open, Î¼uâŸ© : âˆƒ U, U âŠ‡ s âˆ§ IsOpen U âˆ§ Î¼ U â‰¤ Î¼ s + Îµ / 2 :=
    Set.exists_isOpen_le_add _ _
      (by
        simpa only [or_false, Ne, ENNReal.div_eq_zero_iff, ENNReal.two_ne_top] using hÎµ)
  have : âˆ€ x âˆˆ s, âˆƒ R > 0, ball x R âŠ† u := fun x hx =>
    Metric.mem_nhds_iff.1 (u_open.mem_nhds (su hx))
  choose! R hR using this
  obtain âŸ¨t0, r0, t0_count, t0s, hr0, Î¼t0, t0_disjâŸ© :
    âˆƒ (t0 : Set Î±) (r0 : Î± â†’ â„), t0.Countable âˆ§ t0 âŠ† s âˆ§
      (âˆ€ x âˆˆ t0, r0 x âˆˆ f x âˆ© Ioo 0 (R x)) âˆ§ Î¼ (s \ â‹ƒ x âˆˆ t0, closedBall x (r0 x)) = 0 âˆ§
        t0.PairwiseDisjoint fun x => closedBall x (r0 x) :=
    exists_disjoint_closedBall_covering_ae Î¼ f s hf R fun x hx => (hR x hx).1
  let s' := s \ â‹ƒ x âˆˆ t0, closedBall x (r0 x)
  have s's : s' âŠ† s := diff_subset
  obtain âŸ¨N, Ï„, hÏ„, HâŸ© : âˆƒ N Ï„, 1 < Ï„ âˆ§ IsEmpty (Besicovitch.SatelliteConfig Î± N Ï„) :=
    HasBesicovitchCovering.no_satelliteConfig
  obtain âŸ¨v, s'v, v_open, Î¼vâŸ© : âˆƒ v, v âŠ‡ s' âˆ§ IsOpen v âˆ§ Î¼ v â‰¤ Î¼ s' + Îµ / 2 / N :=
    Set.exists_isOpen_le_add _ _
      (by simp only [ne_eq, ENNReal.div_eq_zero_iff, hÎµ, ENNReal.two_ne_top, or_self,
          ENNReal.natCast_ne_top, not_false_eq_true])
  have : âˆ€ x âˆˆ s', âˆƒ r1 âˆˆ f x âˆ© Ioo (0 : â„) 1, closedBall x r1 âŠ† v := by
    intro x hx
    rcases Metric.mem_nhds_iff.1 (v_open.mem_nhds (s'v hx)) with âŸ¨r, rpos, hrâŸ©
    rcases hf x (s's hx) (min r 1) (lt_min rpos zero_lt_one) with âŸ¨R', hR'âŸ©
    exact
      âŸ¨R', âŸ¨hR'.1, hR'.2.1, hR'.2.2.trans_le (min_le_right _ _)âŸ©,
        Subset.trans (closedBall_subset_ball (hR'.2.2.trans_le (min_le_left _ _))) hrâŸ©
  choose! r1 hr1 using this
  let q : BallPackage s' Î± :=
    { c := fun x => x
      r := fun x => r1 x
      rpos := fun x => (hr1 x.1 x.2).1.2.1
      r_bound := 1
      r_le := fun x => (hr1 x.1 x.2).1.2.2.le }
  obtain âŸ¨S, S_disj, hSâŸ© :
    âˆƒ S : Fin N â†’ Set s',
      (âˆ€ i : Fin N, (S i).PairwiseDisjoint fun j => closedBall (q.c j) (q.r j)) âˆ§
        range q.c âŠ† â‹ƒ i : Fin N, â‹ƒ j âˆˆ S i, ball (q.c j) (q.r j) :=
    exist_disjoint_covering_families hÏ„ H q
  have S_count : âˆ€ i, (S i).Countable := by
    intro i
    apply (S_disj i).countable_of_nonempty_interior fun j _ => ?_
    have : (ball (j : Î±) (r1 j)).Nonempty := nonempty_ball.2 (q.rpos _)
    exact this.mono ball_subset_interior_closedBall
  let r x := if x âˆˆ s' then r1 x else r0 x
  have r_t0 : âˆ€ x âˆˆ t0, r x = r0 x := by
    intro x hx
    have : Â¬x âˆˆ s' := by
      simp only [s', not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_lt, not_le,
        mem_diff, not_forall]
      intro _
      refine âŸ¨x, hx, ?_âŸ©
      rw [dist_self]
      exact (hr0 x hx).2.1.le
    simp only [r, if_neg this]
  refine âŸ¨t0 âˆª â‹ƒ i : Fin N, ((â†‘) : s' â†’ Î±) '' S i, r, ?_, ?_, ?_, ?_, ?_âŸ©
  Â· exact t0_count.union (countable_iUnion fun i => (S_count i).image _)
  Â· simp only [t0s, true_and_iff, union_subset_iff, image_subset_iff, iUnion_subset_iff]
    intro i x _
    exact s's x.2
  Â· intro x hx
    cases hx with
    | inl hx =>
      rw [r_t0 x hx]
      exact (hr0 _ hx).1
    | inr hx =>
      have h'x : x âˆˆ s' := by
        simp only [mem_iUnion, mem_image] at hx
        rcases hx with âŸ¨i, y, _, rflâŸ©
        exact y.2
      simp only [r, if_pos h'x, (hr1 x h'x).1.1]
  Â· intro x hx
    by_cases h'x : x âˆˆ s'
    Â· obtain âŸ¨i, y, ySi, xyâŸ© : âˆƒ (i : Fin N) (y : â†¥s'), y âˆˆ S i âˆ§ x âˆˆ ball (y : Î±) (r1 y) := by
        have A : x âˆˆ range q.c := by
          simpa only [not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_le,
            mem_setOf_eq, Subtype.range_coe_subtype, mem_diff] using h'x
        simpa only [mem_iUnion, mem_image, bex_def] using hS A
      refine mem_iUnionâ‚‚.2 âŸ¨y, Or.inr ?_, ?_âŸ©
      Â· simp only [mem_iUnion, mem_image]
        exact âŸ¨i, y, ySi, rflâŸ©
      Â· have : (y : Î±) âˆˆ s' := y.2
        simp only [r, if_pos this]
        exact ball_subset_closedBall xy
    Â· obtain âŸ¨y, yt0, hxyâŸ© : âˆƒ y : Î±, y âˆˆ t0 âˆ§ x âˆˆ closedBall y (r0 y) := by
        simpa [s', hx, -mem_closedBall] using h'x
      refine mem_iUnionâ‚‚.2 âŸ¨y, Or.inl yt0, ?_âŸ©
      rwa [r_t0 _ yt0]
  Â· 
    have A : (âˆ‘' x : t0, Î¼ (closedBall x (r x))) â‰¤ Î¼ s + Îµ / 2 :=
      calc
        (âˆ‘' x : t0, Î¼ (closedBall x (r x))) = âˆ‘' x : t0, Î¼ (closedBall x (r0 x)) := by
          congr 1; ext x; rw [r_t0 x x.2]
        _ = Î¼ (â‹ƒ x : t0, closedBall x (r0 x)) := by
          haveI : Encodable t0 := t0_count.toEncodable
          rw [measure_iUnion]
          Â· exact (pairwise_subtype_iff_pairwise_set _ _).2 t0_disj
          Â· exact fun i => measurableSet_closedBall
        _ â‰¤ Î¼ u := by
          apply measure_mono
          simp only [SetCoe.forall, Subtype.coe_mk, iUnion_subset_iff]
          intro x hx
          apply Subset.trans (closedBall_subset_ball (hr0 x hx).2.2) (hR x (t0s hx)).2
        _ â‰¤ Î¼ s + Îµ / 2 := Î¼u
    have B : âˆ€ i : Fin N, (âˆ‘' x : ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x))) â‰¤ Îµ / 2 / N :=
      fun i =>
      calc
        (âˆ‘' x : ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x))) =
            âˆ‘' x : S i, Î¼ (closedBall x (r x)) := by
          have : InjOn ((â†‘) : s' â†’ Î±) (S i) := Subtype.val_injective.injOn
          let F : S i â‰ƒ ((â†‘) : s' â†’ Î±) '' S i := this.bijOn_image.equiv _
          exact (F.tsum_eq fun x => Î¼ (closedBall x (r x))).symm
        _ = âˆ‘' x : S i, Î¼ (closedBall x (r1 x)) := by
          congr 1; ext x; have : (x : Î±) âˆˆ s' := x.1.2; simp only [s', r, if_pos this]
        _ = Î¼ (â‹ƒ x : S i, closedBall x (r1 x)) := by
          haveI : Encodable (S i) := (S_count i).toEncodable
          rw [measure_iUnion]
          Â· exact (pairwise_subtype_iff_pairwise_set _ _).2 (S_disj i)
          Â· exact fun i => measurableSet_closedBall
        _ â‰¤ Î¼ v := by
          apply measure_mono
          simp only [SetCoe.forall, Subtype.coe_mk, iUnion_subset_iff]
          intro x xs' _
          exact (hr1 x xs').2
        _ â‰¤ Îµ / 2 / N := by have : Î¼ s' = 0 := Î¼t0; rwa [this, zero_add] at Î¼v
    calc
      (âˆ‘' x : â†¥(t0 âˆª â‹ƒ i : Fin N, ((â†‘) : s' â†’ Î±) '' S i), Î¼ (closedBall x (r x))) â‰¤
          (âˆ‘' x : t0, Î¼ (closedBall x (r x))) +
            âˆ‘' x : â‹ƒ i : Fin N, ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x)) :=
        ENNReal.tsum_union_le (fun x => Î¼ (closedBall x (r x))) _ _
      _ â‰¤
          (âˆ‘' x : t0, Î¼ (closedBall x (r x))) +
            âˆ‘ i : Fin N, âˆ‘' x : ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x)) :=
        (add_le_add le_rfl (ENNReal.tsum_iUnion_le (fun x => Î¼ (closedBall x (r x))) _))
      _ â‰¤ Î¼ s + Îµ / 2 + âˆ‘ i : Fin N, Îµ / 2 / N := by
        gcongr
        apply B
      _ â‰¤ Î¼ s + Îµ / 2 + Îµ / 2 := by
        gcongr
        simp only [Finset.card_fin, Finset.sum_const, nsmul_eq_mul, ENNReal.mul_div_le]
      _ = Î¼ s + Îµ := by rw [add_assoc, ENNReal.add_halves]","refine theorem_exists_closedBall_covering_tsum_measure_le_add Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measur"
Mathlib/MeasureTheory/Integral/FundThmCalculus.lean,intervalIntegral.integrableOn_deriv_right_of_nonneg,integrableOn_deriv_right_of_nonneg,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  by_cases hab : a < b; swap
  Â· simp [Ioc_eq_empty hab]
  rw [integrableOn_Ioc_iff_integrableOn_Ioo]
  have meas_g' : AEMeasurable g' (volume.restrict (Ioo a b)) := by
    apply (aemeasurable_derivWithin_Ioi g _).congr
    refine' (ae_restrict_mem measurableSet_Ioo).mono fun x hx => _
    exact (hderiv x hx).derivWithin (uniqueDiffWithinAt_Ioi _)
  suffices H : (âˆ«â» x in Ioo a b, â€–g' xâ€–â‚Š) â‰¤ ENNReal.ofReal (g b - g a) from
    âŸ¨meas_g'.aestronglyMeasurable, H.trans_lt ENNReal.ofReal_lt_topâŸ©
  by_contra' H
  obtain âŸ¨f, fle, fint, hfâŸ© :
    âˆƒ f : SimpleFunc â„ â„â‰¥0,
      (âˆ€ x, f x â‰¤ â€–g' xâ€–â‚Š) âˆ§
        (âˆ«â» x : â„ in Ioo a b, f x) < âˆ âˆ§ ENNReal.ofReal (g b - g a) < âˆ«â» x : â„ in Ioo a b, f x :=
    exists_lt_lintegral_simpleFunc_of_lt_lintegral H
  let F : â„ â†’ â„ := (â†‘) âˆ˜ f
  have intF : IntegrableOn F (Ioo a b) := by
    refine' âŸ¨f.measurable.coe_nnreal_real.aestronglyMeasurable, _âŸ©
    simpa only [HasFiniteIntegral, comp_apply, NNReal.nnnorm_eq] using fint
  have A : âˆ«â» x : â„ in Ioo a b, f x = ENNReal.ofReal (âˆ« x in Ioo a b, F x) :=
    lintegral_coe_eq_integral _ intF
  rw [A] at hf
  have B : (âˆ« x : â„ in Ioo a b, F x) â‰¤ g b - g a := by
    rw [â† integral_Ioc_eq_integral_Ioo, â† intervalIntegral.integral_of_le hab.le]
    refine integral_le_sub_of_hasDeriv_right_of_le hab.le hcont hderiv ?_ fun x hx => ?_
    Â· rwa [integrableOn_Icc_iff_integrableOn_Ioo]
    Â· convert NNReal.coe_le_coe.2 (fle x)
      simp only [Real.norm_of_nonneg (g'pos x hx), coe_nnnorm]
  exact lt_irrefl _ (hf.trans_le (ENNReal.ofReal_le_ofReal B))","error:  unknown tactic
error:  unsolved goals
case pos
Î¹ : Type u_1
ğ•œ : Type u_2
E : Type u_3
F : Type u_4
A : Type u_5
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
fâœ : â„ â†’ E
g' g Ï† : â„ â†’ â„
a b : â„
instâœ : CompleteSpace E
f f' : â„ â†’ E
hcont : ContinuousOn g (Icc a b)
hderiv : âˆ€ x âˆˆ Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x
g'pos : âˆ€ x âˆˆ Ioo a b, 0 â‰¤ g' x
hab : a < b
meas_g' : AEMeasurable g' (volume.restrict (Ioo a b))
âŠ¢ âˆ«â» (x : â„) in Ioo a b, â†‘â€–g' xâ€–â‚Š â‰¤ ENNReal.ofReal (g b - g a)","theorem integrableOn_deriv_right_of_nonneg (hcont : ContinuousOn g (Icc a b))
    (hderiv : âˆ€ x âˆˆ Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (g'pos : âˆ€ x âˆˆ Ioo a b, 0 â‰¤ g' x) : IntegrableOn g' (Ioc a b) ",":= by
  by_cases hab : a < b; swap
  Â· simp [Ioc_eq_empty hab]
  rw [integrableOn_Ioc_iff_integrableOn_Ioo]
  have meas_g' : AEMeasurable g' (volume.restrict (Ioo a b)) := by
    apply (aemeasurable_derivWithin_Ioi g _).congr
    refine (ae_restrict_mem measurableSet_Ioo).mono fun x hx => ?_
    exact (hderiv x hx).derivWithin (uniqueDiffWithinAt_Ioi _)
  suffices H : (âˆ«â» x in Ioo a b, â€–g' xâ€–â‚Š) â‰¤ ENNReal.ofReal (g b - g a) from
    âŸ¨meas_g'.aestronglyMeasurable, H.trans_lt ENNReal.ofReal_lt_topâŸ©
  by_contra! H
  obtain âŸ¨f, fle, fint, hfâŸ© :
    âˆƒ f : SimpleFunc â„ â„â‰¥0,
      (âˆ€ x, f x â‰¤ â€–g' xâ€–â‚Š) âˆ§
        (âˆ«â» x : â„ in Ioo a b, f x) < âˆ âˆ§ ENNReal.ofReal (g b - g a) < âˆ«â» x : â„ in Ioo a b, f x :=
    exists_lt_lintegral_simpleFunc_of_lt_lintegral H
  let F : â„ â†’ â„ := (â†‘) âˆ˜ f
  have intF : IntegrableOn F (Ioo a b) := by
    refine âŸ¨f.measurable.coe_nnreal_real.aestronglyMeasurable, ?_âŸ©
    simpa only [F, HasFiniteIntegral, comp_apply, NNReal.nnnorm_eq] using fint
  have A : âˆ«â» x : â„ in Ioo a b, f x = ENNReal.ofReal (âˆ« x in Ioo a b, F x) :=
    lintegral_coe_eq_integral _ intF
  rw [A] at hf
  have B : (âˆ« x : â„ in Ioo a b, F x) â‰¤ g b - g a := by
    rw [â† integral_Ioc_eq_integral_Ioo, â† intervalIntegral.integral_of_le hab.le]
    refine integral_le_sub_of_hasDeriv_right_of_le hab.le hcont hderiv ?_ fun x hx => ?_
    Â· rwa [integrableOn_Icc_iff_integrableOn_Ioo]
    Â· convert NNReal.coe_le_coe.2 (fle x)
      simp only [Real.norm_of_nonneg (g'pos x hx), coe_nnnorm]
  exact lt_irrefl _ (hf.trans_le (ENNReal.ofReal_le_ofReal B))",have hcont : ContinuousOn g' (Icc a b) := hcont.continuousOn_iff.mp hcont
Mathlib/RingTheory/Polynomial/Cyclotomic/Expand.lean,Polynomial.cyclotomic_mul_prime_pow_eq,cyclotomic_mul_prime_pow_eq,c7bd9bd10c613e1788107ba753e252f069560f87,"  | 1, _ => by
    rw [pow_one, Nat.sub_self, pow_zero, mul_comm, cyclotomic_mul_prime_eq_pow_of_not_dvd R hm]
  | a + 2, _ => by
    have hdiv : p âˆ£ p ^ a.succ * m := âŸ¨p ^ a * m, by rw [â† mul_assoc, pow_succ]âŸ©
    rw [pow_succ, mul_assoc, mul_comm, cyclotomic_mul_prime_dvd_eq_pow R hdiv,
      cyclotomic_mul_prime_pow_eq _ _ a.succ_pos, â† pow_mul]
    congr 1
    simp only [tsub_zero, Nat.succ_sub_succ_eq_sub]
    rwa [Nat.mul_sub_right_distrib, mul_comm, pow_succ']","error:  unsolved goals
R : Type u_1
p m : â„•
instâœÂ² : Fact (Nat.Prime p)
instâœÂ¹ : Ring R
instâœ : CharP R p
hm : Â¬p âˆ£ m
a : â„•
xâœ : 0 < a + 2
âŠ¢ p ^ a * p * m = p * p ^ a * m
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  cyclotomic (p ^ a.succ * m * p) R
R : Type u_1
p m : â„•
instâœÂ² : Fact (Nat.Prime p)
instâœÂ¹ : Ring R
instâœ : CharP R p
hm : Â¬p âˆ£ m
a : â„•
xâœ : 0 < a + 2
hdiv : p âˆ£ p ^ a.succ * m
âŠ¢ cyclotomic (p * m * p ^ (a + 1)) R = cyclotomic m R ^ (p ^ (a + 1) * p - p ^ (a + 2 - 1))","theorem cyclotomic_mul_prime_pow_eq (R : Type*) {p m : â„•} [Fact (Nat.Prime p)] [Ring R] [CharP R p]
    (hm : Â¬p âˆ£ m) : âˆ€ {k}, 0 < k â†’ cyclotomic (p ^ k * m) R = cyclotomic m R ^ (p ^ k - p ^ (k - 1))
","  | 1, _ => by
    rw [pow_one, Nat.sub_self, pow_zero, mul_comm, cyclotomic_mul_prime_eq_pow_of_not_dvd R hm]
  | a + 2, _ => by
    have hdiv : p âˆ£ p ^ a.succ * m := âŸ¨p ^ a * m, by rw [â† mul_assoc, pow_succ']âŸ©
    rw [pow_succ', mul_assoc, mul_comm, cyclotomic_mul_prime_dvd_eq_pow R hdiv,
      cyclotomic_mul_prime_pow_eq _ _ a.succ_pos, â† pow_mul]
    Â· simp only [tsub_zero, Nat.succ_sub_succ_eq_sub]
      rw [Nat.mul_sub_right_distrib, mul_comm, pow_succ]
    Â· assumption","rw [cyclotomic_mul_prime_pow_eq, cyclotomic_mul_prime_pow_eq]"
Mathlib/Logic/Denumerable.lean,Nat.Subtype.lt_succ_self,lt_succ_self,a645d903a5e02e8cbb9215f6195147610bf99954,":=
  calc
    (x : â„•) â‰¤ (x + Nat.find (exists_succ x) : â„•) : = le_self_add
    _ < (succ x : â„•) := Nat.lt_succ_self (x + _)","warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
error:  type mismatch
  rfl
has type
  (â†‘x â‰¤ â†‘x + Nat.find â‹¯) = (â†‘x â‰¤ â†‘x + Nat.find â‹¯) : Prop
but is expected to have type
  x < succ x : Prop
error:  unexpected token ':'; expected command",theorem lt_succ_self (x : s) : x < succ x ,":=
  calc
    (x : â„•) â‰¤ (x + Nat.find (exists_succ x) : â„•) := le_add_right ..
    _ < (succ x : â„•) := Nat.lt_succ_self (x + _)",rw [succ_lt_succ_iff]
Mathlib/Data/List/NodupEquivFin.lean,List.sublist_iff_exists_fin_orderEmbedding_get_eq,sublist_iff_exists_fin_orderEmbedding_get_eq,b046c9e0f6ad05b9d218f3b9b832a04a3f9ae1d2,":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  Â· rintro âŸ¨f, hfâŸ©
    have h : âˆ€ {i : â„•}, i < l.length â†’ f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain âŸ¨h, -âŸ© := hf
      exact h
    refine' âŸ¨OrderEmbedding.ofMapLEIff (fun ix => âŸ¨f ix, h ix.is_ltâŸ©) _, _âŸ©
    Â· simp
    Â· intro i
      apply Option.some_injective
      simpa [get?_eq_get i.2, get?_eq_get (h i.2)] using hf i
  Â· rintro âŸ¨f, hfâŸ©
    refine'
      âŸ¨OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f âŸ¨i, hiâŸ© else i + l'.length)
          _,
        _âŸ©
    Â· intro i j h
      dsimp only
      split_ifs with hi hj hj
      Â· rwa [Fin.val_fin_lt, f.lt_iff_lt]
      Â· have := (f âŸ¨i, hiâŸ©).is_lt
        omega
      Â· exact absurd (h.trans hj) hi
      Â· simpa using h
    Â· intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      Â· rw [get?_eq_get hi, get?_eq_get, â† hf]
      Â· rw [get?_eq_none.mpr, get?_eq_none.mpr]
        Â· simp
        Â· simpa using hi","error:  type mismatch
  hâœ
has type
  some l[â†‘i] = l'[f â†‘i]? : Prop
but is expected to have type
  l[â†‘i] = l'[f â†‘i] : Prop
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem sublist_iff_exists_fin_orderEmbedding_get_eq {l l' : List Î±} :
    l <+ l' â†”
      âˆƒ f : Fin l.length â†ªo Fin l'.length,
        âˆ€ ix : Fin l.length, l.get ix = l'.get (f ix) ",":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  Â· rintro âŸ¨f, hfâŸ©
    have h : âˆ€ {i : â„•}, i < l.length â†’ f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain âŸ¨h, -âŸ© := hf
      exact h
    refine âŸ¨OrderEmbedding.ofMapLEIff (fun ix => âŸ¨f ix, h ix.is_ltâŸ©) ?_, ?_âŸ©
    Â· simp
    Â· intro i
      apply Option.some_injective
      simpa [getElem?_eq_getElem i.2, getElem?_eq_getElem (h i.2)] using hf i
  Â· rintro âŸ¨f, hfâŸ©
    refine
      âŸ¨OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f âŸ¨i, hiâŸ© else i + l'.length)
          ?_,
        ?_âŸ©
    Â· intro i j h
      dsimp only
      split_ifs with hi hj hj
      Â· rwa [Fin.val_fin_lt, f.lt_iff_lt]
      Â· have := (f âŸ¨i, hiâŸ©).is_lt
        omega
      Â· exact absurd (h.trans hj) hi
      Â· simpa using h
    Â· intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      Â· rw [get?_eq_get hi, get?_eq_get, â† hf]
      Â· rw [get?_eq_none.mpr, get?_eq_none.mpr]
        Â· simp
        Â· simpa using hi",simp only [Fin.exists_fin_orderEmbedding_get_eq]
Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/GaussSum.lean,FiniteField.isSquare_neg_two_iff,FiniteField.isSquare_neg_two_iff,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  classical
  by_cases hF : ringChar F = 2
  focus
    have h := FiniteField.even_card_of_char_two hF
    simp only [FiniteField.isSquare_of_char_two hF, true_iff_iff]
  rotate_left
  focus
    have h := FiniteField.odd_card_of_char_ne_two hF
    rw [â† quadraticChar_one_iff_isSquare (neg_ne_zero.mpr (Ring.two_ne_zero hF)),
      quadraticChar_neg_two hF, Ï‡â‚ˆ'_nat_eq_if_mod_eight]
    simp only [h, Nat.one_ne_zero, if_false, ite_eq_left_iff, Ne.def, (by decide : (-1 : â„¤) â‰  1),
      imp_false, Classical.not_not]
  all_goals
    rw [â† Nat.mod_mod_of_dvd _ (by norm_num : 2 âˆ£ 8)] at h
    have hâ‚ := Nat.mod_lt (Fintype.card F) (by decide : 0 < 8)
    revert hâ‚ h
    generalize Fintype.card F % 8 = n
    intros; interval_cases n <;> simp_all ","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.24683 â†’ ?m.24683 â†’ Prop","theorem FiniteField.isSquare_neg_two_iff :
    IsSquare (-2 : F) â†” Fintype.card F % 8 â‰  5 âˆ§ Fintype.card F % 8 â‰  7 ",":= by
  classical
  by_cases hF : ringChar F = 2
  Â· have h := FiniteField.even_card_of_char_two hF
    simp only [FiniteField.isSquare_of_char_two hF, true_iff_iff]
    omega
  Â· have h := FiniteField.odd_card_of_char_ne_two hF
    rw [â† quadraticChar_one_iff_isSquare (neg_ne_zero.mpr (Ring.two_ne_zero hF)),
      quadraticChar_neg_two hF, Ï‡â‚ˆ'_nat_eq_if_mod_eight]
    omega",have : Fintype.card F % 8 â‰  5 := by rw [Fintype.card_fin]; simp
Mathlib/Algebra/MvPolynomial/Equiv.lean,MvPolynomial.support_finSuccEquiv_nonempty,support_finSuccEquiv_nonempty,7962047919fd0329ddca78b1a70bd94a7b06f8ca,":= by
  rwa [Polynomial.support_nonempty, AddHomClass.map_ne_zero_iff]","error:  unknown constant 'AddHomClass.map_ne_zero_iff'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.165594
R : Type u
Sâ‚ : Type v
Sâ‚‚ : Type w
Sâ‚ƒ : Type x
Ïƒ : Type u_1
a a' aâ‚ aâ‚‚ : R
e : â„•
s : Ïƒ â†’â‚€ â„•
instâœ : CommSemiring R
n : â„•
f : MvPolynomial (Fin (n + 1)) R
h : f â‰  0
âŠ¢ (finSuccEquiv R n) f â‰  0","theorem support_finSuccEquiv_nonempty {f : MvPolynomial (Fin (n + 1)) R} (h : f â‰  0) :
    (finSuccEquiv R n f).support.Nonempty ",":= by
  rwa [Polynomial.support_nonempty, AddEquivClass.map_ne_zero_iff]",rw [support_nonempty_iff]
Mathlib/RingTheory/Polynomial/Hermite/Basic.lean,Polynomial.coeff_hermite_explicit,coeff_hermite_explicit,0bb63b2bff135338722ab98f6da549f3e6350f0a,"  | 0, _ => by simp
  | n + 1, 0 => by
    convert coeff_hermite_succ_zero (2 * n + 1) using 1
    rw [coeff_hermite_explicit n 1, (by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] :
      2 * (n + 1) - 1 = 2 * n + 1), Nat.doubleFactorial_add_one, Nat.choose_zero_right,
      Nat.choose_one_right, pow_succ]
    push_cast
    ring
  | n + 1, k + 1 => by
    let hermite_explicit : â„• â†’ â„• â†’ â„¤ := fun n k =>
      (-1) ^ n * (2 * n - 1)â€¼ * Nat.choose (2 * n + k) k
    have hermite_explicit_recur :
      âˆ€ n k : â„•,
        hermite_explicit (n + 1) (k + 1) =
          hermite_explicit (n + 1) k - (k + 2) * hermite_explicit n (k + 2) := by
      intro n k
      simp only
      rw [mul_comm (â†‘k + _ : â„¤), sub_eq_add_neg]
      nth_rw 3 [neg_eq_neg_one_mul]
      simp only [mul_assoc, â† mul_add, pow_succ]
      congr 2
      norm_cast
      rw [(by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] : 2 * (n + 1) - 1 = 2 * n + 1),
        Nat.doubleFactorial_add_one, mul_comm (2 * n + 1)]
      simp only [mul_assoc, â† mul_add]
      congr 1
      rw [(by ring : 2 * (n + 1) + (k + 1) = 2 * n + 1 + (k + 1) + 1),
        (by ring : 2 * (n + 1) + k = 2 * n + 1 + (k + 1)),
        (by ring : 2 * n + (k + 2) = 2 * n + 1 + (k + 1))]
      rw [Nat.choose, Nat.choose_succ_right_eq (2 * n + 1 + (k + 1)) (k + 1), Nat.add_sub_cancel,
        Int.negSucc_eq]
      ring_nf
      simp only [sub_eq_add_neg, â† neg_mul, â† right_distrib _ _ ((-(1 : â„¤)) ^ n), â† neg_add]
      norm_cast
      simp only [â† add_assoc, add_comm]
    change _ = hermite_explicit _ _
    rw [â† add_assoc, coeff_hermite_succ_succ, hermite_explicit_recur]
    congr
    Â· rw [coeff_hermite_explicit (n + 1) k]
    Â· rw [(by ring : 2 * (n + 1) + k = 2 * n + (k + 2)), coeff_hermite_explicit n (k + 2)]",error:  simp made no progress,"theorem coeff_hermite_explicit :
    âˆ€ n k : â„•, coeff (hermite (2 * n + k)) k = (-1) ^ n * (2 * n - 1)â€¼ * Nat.choose (2 * n + k) k
","  | 0, _ => by simp
  | n + 1, 0 => by
    convert coeff_hermite_succ_zero (2 * n + 1) using 1
    rw [coeff_hermite_explicit n 1, (by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] :
      2 * (n + 1) - 1 = 2 * n + 1), Nat.doubleFactorial_add_one, Nat.choose_zero_right,
      Nat.choose_one_right, pow_succ]
    push_cast
    ring
  | n + 1, k + 1 => by
    let hermite_explicit : â„• â†’ â„• â†’ â„¤ := fun n k =>
      (-1) ^ n * (2 * n - 1)â€¼ * Nat.choose (2 * n + k) k
    have hermite_explicit_recur :
      âˆ€ n k : â„•,
        hermite_explicit (n + 1) (k + 1) =
          hermite_explicit (n + 1) k - (k + 2) * hermite_explicit n (k + 2) := by
      intro n k
      simp only [hermite_explicit]
      rw [mul_comm (â†‘k + _ : â„¤), sub_eq_add_neg]
      nth_rw 3 [neg_eq_neg_one_mul]
      simp only [mul_assoc, â† mul_add, pow_succ']
      congr 2
      norm_cast
      rw [(by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] : 2 * (n + 1) - 1 = 2 * n + 1),
        Nat.doubleFactorial_add_one, mul_comm (2 * n + 1)]
      simp only [mul_assoc, â† mul_add]
      congr 1
      rw [(by ring : 2 * (n + 1) + (k + 1) = 2 * n + 1 + (k + 1) + 1),
        (by ring : 2 * (n + 1) + k = 2 * n + 1 + (k + 1)),
        (by ring : 2 * n + (k + 2) = 2 * n + 1 + (k + 1))]
      rw [Nat.choose, Nat.choose_succ_right_eq (2 * n + 1 + (k + 1)) (k + 1), Nat.add_sub_cancel]
      ring
    change _ = hermite_explicit _ _
    rw [â† add_assoc, coeff_hermite_succ_succ, hermite_explicit_recur]
    congr
    Â· rw [coeff_hermite_explicit (n + 1) k]
    Â· rw [(by ring : 2 * (n + 1) + k = 2 * n + (k + 2)), coeff_hermite_explicit n (k + 2)]","rw [Nat.choose_eq_zero_of_lt (by decide), Nat.choose_eq_zero_of_lt (by decide),
  Nat.choose_eq_zero_of_lt (by decide)]"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.addHaar_image_le_lintegral_abs_det_fderiv,addHaar_image_le_lintegral_abs_det_fderiv,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have :
    âˆ€ A : E â†’L[â„] E,
      âˆƒ Î´ : â„â‰¥0,
        0 < Î´ âˆ§
          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§
            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’
              Î¼ (g '' t) â‰¤ (ENNReal.ofReal |A.det| + Îµ) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©
    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt Îµ Îµpos
    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©
    refine' âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), _, _âŸ©
    Â· intro B hB
      rw [â† Real.dist_eq]
      apply (hÎ´' B _).le
      rw [dist_eq_norm]
      calc
        â€–B - Aâ€– â‰¤ (min Î´ Î´'' : â„â‰¥0) := hB
        _ â‰¤ Î´'' := by simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
        _ < Î´' := half_lt_self Î´'pos
    Â· intro t g htg
      exact h t g (htg.mono_num (min_le_left _ _))
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (ENNReal.ofReal |(A n).det| + Îµ) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2.2
      exact ht n
    _ = âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by
      simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
    _ â‰¤ âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono (inter_subset_left _ _)]
      intro x hx
      have I : |(A n).det| â‰¤ |(f' x).det| + Îµ :=
        calc
          |(A n).det| = |(f' x).det - ((f' x).det - (A n).det)| := by congr 1; abel
          _ â‰¤ |(f' x).det| + |(f' x).det - (A n).det| := abs_sub _ _
          _ â‰¤ |(f' x).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(A n).det| + Îµ â‰¤ ENNReal.ofReal (|(f' x).det| + Îµ) + Îµ :=
          add_le_add (ENNReal.ofReal_le_ofReal I) le_rfl
        _ = ENNReal.ofReal |(f' x).det| + 2 * Îµ := by
          simp only [ENNReal.ofReal_add, abs_nonneg, two_mul, add_assoc, NNReal.zero_le_coe,
            ENNReal.ofReal_coe_nnreal]
    _ = âˆ«â» x in â‹ƒ n, s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      have M : âˆ€ n : â„•, MeasurableSet (s âˆ© t n) := fun n => hs.inter (t_meas n)
      rw [lintegral_iUnion M]
      exact pairwise_disjoint_mono t_disj fun n => inter_subset_right _ _
    _ = âˆ«â» x in s, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      have : s = â‹ƒ n, s âˆ© t n := by
        rw [â† inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left _ _)
      rw [â† this]
    _ = (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s := by
      simp only [lintegral_add_right' _ aemeasurable_const, set_lintegral_const]","error:  function expected at
  inter_subset_left ?m.432033
term has type
  ?m.432032 âˆˆ ?m.432030
error:  function expected at
  inter_subset_right ?m.438719
term has type
  ?m.438718 âˆˆ ?m.438717
error:  function expected at
  inter_subset_left ?m.438934
term has type
  ?m.438933 âˆˆ ?m.438931
warning:  `MeasureTheory.set_lintegral_const` has been deprecated, use `MeasureTheory.setLIntegral_const` instead","theorem addHaar_image_le_lintegral_abs_det_fderiv_aux1 (hs : MeasurableSet s)
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) {Îµ : â„â‰¥0} (Îµpos : 0 < Îµ) :
    Î¼ (f '' s) â‰¤ (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s ",":= by
  have :
    âˆ€ A : E â†’L[â„] E,
      âˆƒ Î´ : â„â‰¥0,
        0 < Î´ âˆ§
          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§
            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’
              Î¼ (g '' t) â‰¤ (ENNReal.ofReal |A.det| + Îµ) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©
    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt Îµ Îµpos
    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©
    refine âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), ?_, ?_âŸ©
    Â· intro B hB
      rw [â† Real.dist_eq]
      apply (hÎ´' B _).le
      rw [dist_eq_norm]
      calc
        â€–B - Aâ€– â‰¤ (min Î´ Î´'' : â„â‰¥0) := hB
        _ â‰¤ Î´'' := by simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
        _ < Î´' := half_lt_self Î´'pos
    Â· intro t g htg
      exact h t g (htg.mono_num (min_le_left _ _))
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (ENNReal.ofReal |(A n).det| + Îµ) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2.2
      exact ht n
    _ = âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by
      simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
    _ â‰¤ âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono inter_subset_left]
      intro x hx
      have I : |(A n).det| â‰¤ |(f' x).det| + Îµ :=
        calc
          |(A n).det| = |(f' x).det - ((f' x).det - (A n).det)| := by congr 1; abel
          _ â‰¤ |(f' x).det| + |(f' x).det - (A n).det| := abs_sub _ _
          _ â‰¤ |(f' x).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(A n).det| + Îµ â‰¤ ENNReal.ofReal (|(f' x).det| + Îµ) + Îµ := by gcongr
        _ = ENNReal.ofReal |(f' x).det| + 2 * Îµ := by
          simp only [ENNReal.ofReal_add, abs_nonneg, two_mul, add_assoc, NNReal.zero_le_coe,
            ENNReal.ofReal_coe_nnreal]
    _ = âˆ«â» x in â‹ƒ n, s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      have M : âˆ€ n : â„•, MeasurableSet (s âˆ© t n) := fun n => hs.inter (t_meas n)
      rw [lintegral_iUnion M]
      exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
    _ = âˆ«â» x in s, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      rw [â† inter_iUnion, inter_eq_self_of_subset_left t_cover]
    _ = (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s := by
      simp only [lintegral_add_right' _ aemeasurable_const, setLIntegral_const]",refine theorem_addHaar_image_le_lintegral_abs_det_fderiv_aux1 hs hf' hf' Îµpos Îµpos.ne' ?_
Mathlib/RingTheory/PowerSeries/Basic.lean,PowerSeries.coeff_C,coeff_C,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":=
  coeff_monomial _ _ _","error:  type mismatch
  coeff_monomial n ?m.18723 ?m.18724
has type
  (coeff R n) ((monomial R ?m.18723) ?m.18724) = if n = ?m.18723 then ?m.18724 else 0 : Prop
but is expected to have type
  (coeff R n) ((C R) a) = if n = 0 then a else 0 : Prop
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated",theorem coeff_C (n : â„•) (a : R) : coeff R n (C R a : RâŸ¦XâŸ§) = if n = 0 then a else 0 ,":= by
  rw [â† monomial_zero_eq_C_apply, coeff_monomial]",split_ifs with h
Mathlib/Algebra/MonoidAlgebra/Ideal.lean,MonoidAlgebra.mem_ideal_span_of_image,MonoidAlgebra.mem_ideal_span_of_image,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  let RHS : Ideal (MonoidAlgebra k G) :=
    { carrier := { p | âˆ€ m : G, m âˆˆ p.support â†’ âˆƒ m' âˆˆ s, âˆƒ d, m = d * m' }
      add_mem' := fun {x y} hx hy m hm => by
        classical exact (Finset.mem_union.1 <| Finsupp.support_add hm).elim (hx m) (hy m)
      zero_mem' := fun m hm => by cases hm
      smul_mem' := fun x y hy m hm => by
        classical
        replace hm := Finset.mem_biUnion.mp (Finsupp.support_sum hm)
        obtain âŸ¨xm, -, hmâŸ© := hm
        replace hm := Finset.mem_biUnion.mp (Finsupp.support_sum hm)
        obtain âŸ¨ym, hym, hmâŸ© := hm
        replace hm := Finset.mem_singleton.mp (Finsupp.support_single_subset hm)
        obtain rfl := hm
        refine' (hy _ hym).imp fun sm p => And.imp_right _ p
        rintro âŸ¨d, rflâŸ©
        exact âŸ¨xm * d, (mul_assoc _ _ _).symmâŸ© }
  change _ â†” x âˆˆ RHS
  constructor
  Â· revert x
    rw [â† SetLike.le_def] 
    refine Ideal.span_le.2 ?_
    rintro _ âŸ¨i, hi, rflâŸ© m hm
    refine' âŸ¨_, hi, 1, _âŸ©
    obtain rfl := Finset.mem_singleton.mp (Finsupp.support_single_subset hm)
    exact (one_mul _).symm
  Â· intro hx
    rw [â† Finsupp.sum_single x]
    refine Ideal.sum_mem _ fun i hi => ?_  
    obtain âŸ¨d, hd, d2, rflâŸ© := hx _ hi
    convert Ideal.mul_mem_left _ (id <| Finsupp.single d2 <| x (d2 * d) : MonoidAlgebra k G) _
    pick_goal 3
    refine' Ideal.subset_span âŸ¨_, hd, rflâŸ©
    rw [id.def, MonoidAlgebra.of_apply, MonoidAlgebra.single_mul_single, mul_one]","error:  application type mismatch
  Finsupp.support_sum hm
argument
  hm
has type
  m âˆˆ (x â€¢ y).support : Prop
but is expected to have type
  m âˆˆ (?m.4588.sum ?m.4589).support : Prop
error:  unsolved goals
k : Type u_1
A : Type u_2
G : Type u_3
instâœÂ¹ : Monoid G
instâœ : Semiring k
s : Set G
xâœ x y : MonoidAlgebra k G
hy : y âˆˆ { carrier := {p | âˆ€ m âˆˆ p.support, âˆƒ m' âˆˆ s, âˆƒ d, m = d * m'}, add_mem' := â‹¯, zero_mem' := â‹¯ }.carrier
m : G
hm : m âˆˆ (x â€¢ y).support
âŠ¢ âˆƒ m' âˆˆ s, âˆƒ d, m = d * m'
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.11446 â†’ ?m.11446
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.11448
case h.e'_4
k : Type u_1
A : Type u_2
G : Type u_3
instâœÂ¹ : Monoid G
instâœ : Semiring k
s : Set G
x : MonoidAlgebra k G
RHS : Ideal (MonoidAlgebra k G) :=
  { carrier := {p | âˆ€ m âˆˆ p.support, âˆƒ m' âˆˆ s, âˆƒ d, m = d * m'}, add_mem' := â‹¯, zero_mem' := â‹¯, smul_mem' := â‹¯ }
hx : x âˆˆ RHS
d : G
hd : d âˆˆ s
d2 : G
hi : d2 * d âˆˆ x.support
âŠ¢ Finsupp.single (d2 * d) (x (d2 * d)) = id (Finsupp.single d2 (x (d2 * d))) * (of k G) d","theorem MonoidAlgebra.mem_ideal_span_of_image [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} :
    x âˆˆ Ideal.span (MonoidAlgebra.of k G '' s) â†” âˆ€ m âˆˆ x.support, âˆƒ m' âˆˆ s, âˆƒ d, m = d * m' ",":= by
  let RHS : Ideal (MonoidAlgebra k G) :=
    { carrier := { p | âˆ€ m : G, m âˆˆ p.support â†’ âˆƒ m' âˆˆ s, âˆƒ d, m = d * m' }
      add_mem' := fun {x y} hx hy m hm => by
        classical exact (Finset.mem_union.1 <| Finsupp.support_add hm).elim (hx m) (hy m)
      zero_mem' := fun m hm => by cases hm
      smul_mem' := fun x y hy m hm => by
        classical
        rw [smul_eq_mul, mul_def] at hm
        replace hm := Finset.mem_biUnion.mp (Finsupp.support_sum hm)
        obtain âŸ¨xm, -, hmâŸ© := hm
        replace hm := Finset.mem_biUnion.mp (Finsupp.support_sum hm)
        obtain âŸ¨ym, hym, hmâŸ© := hm
        obtain rfl := Finset.mem_singleton.mp (Finsupp.support_single_subset hm)
        refine (hy _ hym).imp fun sm p => And.imp_right ?_ p
        rintro âŸ¨d, rflâŸ©
        exact âŸ¨xm * d, (mul_assoc _ _ _).symmâŸ© }
  change _ â†” x âˆˆ RHS
  constructor
  Â· revert x
    rw [â† SetLike.le_def] 
    refine Ideal.span_le.2 ?_
    rintro _ âŸ¨i, hi, rflâŸ© m hm
    refine âŸ¨_, hi, 1, ?_âŸ©
    obtain rfl := Finset.mem_singleton.mp (Finsupp.support_single_subset hm)
    exact (one_mul _).symm
  Â· intro hx
    rw [â† Finsupp.sum_single x]
    refine Ideal.sum_mem _ fun i hi => ?_  
    obtain âŸ¨d, hd, d2, rflâŸ© := hx _ hi
    convert Ideal.mul_mem_left _ (id <| Finsupp.single d2 <| x (d2 * d) : MonoidAlgebra k G) _
    pick_goal 3
    Â· exact Ideal.subset_span âŸ¨_, hd, rflâŸ©
    rw [id, MonoidAlgebra.of_apply, MonoidAlgebra.single_mul_single, mul_one]",constructor
Mathlib/Algebra/Polynomial/Module/Basic.lean,PolynomialModule.eval_smul,eval_smul,c342c339a777827331257acd880fea6d441a6aa6,":= by
  apply induction_linear q
  Â· rw [smul_zero, map_zero, smul_zero]
  Â· intro f g eâ‚ eâ‚‚
    rw [smul_add, map_add, eâ‚, eâ‚‚, map_add, smul_add]
  intro i m
  induction' p with _ _ eâ‚ eâ‚‚
  Â· rw [add_smul, map_add, Polynomial.eval_add, eâ‚, eâ‚‚, add_smul]
  Â· rw [monomial_smul_single, eval_single, Polynomial.eval_monomial, eval_single, smul_comm, â†
      smul_smul, pow_add, mul_smul]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?r + ?s) â€¢ ?x
case hsingle.ofFinsupp
R : Type u_1
M : Type u_2
instâœÂ¹Â² : CommRing R
instâœÂ¹Â¹ : AddCommGroup M
instâœÂ¹â° : Module R M
I : Ideal R
S : Type u_3
instâœâ¹ : CommSemiring S
instâœâ¸ : Algebra S R
instâœâ· : Module S M
instâœâ¶ : IsScalarTower S R M
R' : Type u_4
M' : Type u_5
instâœâµ : CommRing R'
instâœâ´ : AddCommGroup M'
instâœÂ³ : Module R' M'
instâœÂ² : Algebra R R'
instâœÂ¹ : Module R M'
instâœ : IsScalarTower R R' M'
q : PolynomialModule R M
r : R
i : â„•
m : M
toFinsuppâœ : AddMonoidAlgebra R â„•
âŠ¢ (eval r) ({ toFinsupp := toFinsuppâœ } â€¢ (single R i) m) =
    Polynomial.eval r { toFinsupp := toFinsuppâœ } â€¢ (eval r) ((single R i) m)
error:  no goals to be solved","theorem eval_smul (p : R[X]) (q : PolynomialModule R M) (r : R) :
    eval r (p â€¢ q) = p.eval r â€¢ eval r q ",":= by
  apply induction_linear q
  Â· rw [smul_zero, map_zero, smul_zero]
  Â· intro f g eâ‚ eâ‚‚
    rw [smul_add, map_add, eâ‚, eâ‚‚, map_add, smul_add]
  intro i m
  induction' p using Polynomial.induction_on' with _ _ eâ‚ eâ‚‚
  Â· rw [add_smul, map_add, Polynomial.eval_add, eâ‚, eâ‚‚, add_smul]
  Â· rw [monomial_smul_single, eval_single, Polynomial.eval_monomial, eval_single, smul_comm, â†
      smul_smul, pow_add, mul_smul]","rw [eval_smul, eval_smul, eval_smul, eval_smul, eval_smul, eval_smul]"
Mathlib/Data/List/Cycle.lean,List.next_ne_head_ne_getLast,next_ne_head_ne_getLast,5facde50581cefe36eb491a50b05917b86b8b861,":= by
  rw [next, next, nextOr_cons_of_ne _ _ _ _ hy, nextOr_eq_nextOr_of_mem_of_ne]
  Â· rwa [getLast_cons] at hx
  Â· rwa [getLast_cons] at hx
    exact ne_nil_of_mem (by assumption)","error:  unsolved goals
case x_mem
Î± : Type u_1
instâœ : DecidableEq Î±
l : List Î±
x : Î±
hâœ : x âˆˆ l
y : Î±
h : x âˆˆ y :: l
hy : x â‰  y
hx : x â‰  (y :: l).getLast â‹¯
âŠ¢ l â‰  []
error:  no goals to be solved
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead","theorem next_ne_head_ne_getLast (h : x âˆˆ l) (y : Î±) (h : x âˆˆ y :: l) (hy : x â‰  y)
    (hx : x â‰  getLast (y :: l) (cons_ne_nil _ _)) :
    next (y :: l) x h = next l x (by simpa [hy] using h) ",":= by
  rw [next, next, nextOr_cons_of_ne _ _ _ _ hy, nextOr_eq_nextOr_of_mem_of_ne]
  Â· rwa [getLast_cons] at hx
    exact ne_nil_of_mem (by assumption)
  Â· rwa [getLast_cons] at hx","simp only [next_ne_head_ne_getLast, next_ne_head_ne_getLast, next_ne_head_ne_getLast,
  next_ne_head_ne_getLast, next_ne_head_ne_getLast, next_ne_head_ne_getLast]"
Mathlib/Geometry/Euclidean/Basic.lean,EuclideanGeometry.orthogonalProjectionFn_mem,orthogonalProjectionFn_mem,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [â† mem_coe, â† Set.singleton_subset_iff, â† inter_eq_singleton_orthogonalProjectionFn]
  exact Set.inter_subset_left _ _","error:  function expected at
  Set.inter_subset_left ?m.88147
term has type
  ?m.88146 âˆˆ ?m.88144","theorem orthogonalProjectionFn_mem {s : AffineSubspace â„ P} [Nonempty s]
    [HasOrthogonalProjection s.direction] (p : P) : orthogonalProjectionFn s p âˆˆ s ",":= by
  rw [â† mem_coe, â† Set.singleton_subset_iff, â† inter_eq_singleton_orthogonalProjectionFn]
  exact Set.inter_subset_left",have : orthogonalProjectionFn s p âˆˆ s := orthogonalProjectionFn_mem s p
Mathlib/Analysis/BoxIntegral/Partition/Basic.lean,BoxIntegral.Prepartition.card_filter_mem_Icc_le,card_filter_mem_Icc_le,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [â† Fintype.card_set]
  refine Finset.card_le_card_of_inj_on (fun J : Box Î¹ => { i | J.lower i = x i })
    (fun _ _ => Finset.mem_univ _) ?_
  simpa only [Finset.mem_filter] using Ï€.injOn_setOf_mem_Icc_setOf_lower_eq x","warning:  `Finset.card_le_card_of_inj_on` has been deprecated, use `Finset.card_le_card_of_injOn` instead
error:  type mismatch
  hâœ
has type
  InjOn (fun J â†¦ {i | J.lower i = x i}) {J | J âˆˆ Ï€ âˆ§ x âˆˆ Box.Icc J} : Prop
but is expected to have type
  InjOn (fun J â†¦ {i | J.lower i = x i}) â†‘(filter (fun J â†¦ x âˆˆ Box.Icc J) Ï€.boxes) : Prop","theorem card_filter_mem_Icc_le [Fintype Î¹] (x : Î¹ â†’ â„) :
    (Ï€.boxes.filter fun J : Box Î¹ => x âˆˆ Box.Icc J).card â‰¤ 2 ^ Fintype.card Î¹ ",":= by
  rw [â† Fintype.card_set]
  refine Finset.card_le_card_of_injOn (fun J : Box Î¹ => { i | J.lower i = x i })
    (fun _ _ => Finset.mem_univ _) ?_
  simpa using Ï€.injOn_setOf_mem_Icc_setOf_lower_eq x","rw [â† card_filter_mem_Icc_le, â† card_filter_mem_Icc_le]"
Mathlib/LinearAlgebra/Matrix/ZPow.lean,Matrix.pow_inv_comm',pow_inv_comm',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' n with n IH generalizing m
  Â· simp
  cases' m with m m
  Â· simp
  rcases nonsing_inv_cancel_or_zero A with (âŸ¨h, h'âŸ© | h)
  Â· simp only [Nat.succ_eq_add_one]
    calc
       Aâ»Â¹ ^ (m + 1) * A ^ (n + 1) = Aâ»Â¹ ^ m * (Aâ»Â¹ * A) * A ^ n := by
        simp only [pow_succ Aâ»Â¹, pow_succ' A, Matrix.mul_assoc]
      _ = A ^ n * Aâ»Â¹ ^ m := by simp only [h, Matrix.mul_one, Matrix.one_mul, IH m]
      _ = A ^ n * (A * Aâ»Â¹) * Aâ»Â¹ ^ m := by simp only [h', Matrix.mul_one, Matrix.one_mul]
      _ = A ^ (n + 1) * Aâ»Â¹ ^ (m + 1) := by
        simp only [pow_succ A, pow_succ' Aâ»Â¹, Matrix.mul_assoc]
  Â· simp [h]","error:  simp made no progress
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated",theorem pow_inv_comm' (A : M) (m n : â„•) : Aâ»Â¹ ^ m * A ^ n = A ^ n * Aâ»Â¹ ^ m ,":= by
  induction' n with n IH generalizing m
  Â· simp
  cases' m with m m
  Â· simp
  rcases nonsing_inv_cancel_or_zero A with (âŸ¨h, h'âŸ© | h)
  Â· calc
       Aâ»Â¹ ^ (m + 1) * A ^ (n + 1) = Aâ»Â¹ ^ m * (Aâ»Â¹ * A) * A ^ n := by
        simp only [pow_succ Aâ»Â¹, pow_succ' A, Matrix.mul_assoc]
      _ = A ^ n * Aâ»Â¹ ^ m := by simp only [h, Matrix.mul_one, Matrix.one_mul, IH m]
      _ = A ^ n * (A * Aâ»Â¹) * Aâ»Â¹ ^ m := by simp only [h', Matrix.mul_one, Matrix.one_mul]
      _ = A ^ (n + 1) * Aâ»Â¹ ^ (m + 1) := by
        simp only [pow_succ A, pow_succ' Aâ»Â¹, Matrix.mul_assoc]
  Â· simp [h]","rw [theorem_pow_inv_comm', Aâ»Â¹_pow_inv_comm', Aâ»Â¹_pow_inv_comm']"
Mathlib/MeasureTheory/Measure/Sub.lean,MeasureTheory.Measure.restrict_sub_eq_restrict_sub_restrict,restrict_sub_eq_restrict_sub_restrict,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  repeat rw [sub_def]
  have h_nonempty : { d | Î¼ â‰¤ d + Î½ }.Nonempty := âŸ¨Î¼, Measure.le_add_right le_rflâŸ©
  rw [restrict_sInf_eq_sInf_restrict h_nonempty h_meas_s]
  apply le_antisymm
  Â· refine' sInf_le_sInf_of_forall_exists_le _
    intro Î½' h_Î½'_in
    rw [mem_setOf_eq] at h_Î½'_in
    refine' âŸ¨Î½'.restrict s, _, restrict_le_selfâŸ©
    refine' âŸ¨Î½' + (âŠ¤ : Measure Î±).restrict sá¶œ, _, _âŸ©
    Â· rw [mem_setOf_eq, add_right_comm, Measure.le_iff]
      intro t h_meas_t
      repeat rw [â† measure_inter_add_diff t h_meas_s]
      refine' add_le_add _ _
      Â· rw [add_apply, add_apply]
        apply le_add_right _
        rw [â† restrict_eq_self Î¼ (inter_subset_right _ _),
          â† restrict_eq_self Î½ (inter_subset_right _ _)]
        apply h_Î½'_in
      Â· rw [add_apply, restrict_apply (h_meas_t.diff h_meas_s), diff_eq, inter_assoc, inter_self,
          â† add_apply]
        have h_mu_le_add_top : Î¼ â‰¤ Î½' + Î½ + âŠ¤ := by simp only [add_top, le_top]
        exact Measure.le_iff'.1 h_mu_le_add_top _
    Â· ext1 t h_meas_t
      simp [restrict_apply h_meas_t, restrict_apply (h_meas_t.inter h_meas_s), inter_assoc]
  Â· refine' sInf_le_sInf_of_forall_exists_le _
    refine' forall_mem_image.2 fun t h_t_in => âŸ¨t.restrict s, _, le_rflâŸ©
    rw [Set.mem_setOf_eq, â† restrict_add]
    exact restrict_mono Subset.rfl h_t_in","error:  function expected at
  inter_subset_right ?m.12759
term has type
  ?m.12758 âˆˆ ?m.12757
error:  function expected at
  inter_subset_right ?m.12812
term has type
  ?m.12811 âˆˆ ?m.12810","theorem restrict_sub_eq_restrict_sub_restrict (h_meas_s : MeasurableSet s) :
    (Î¼ - Î½).restrict s = Î¼.restrict s - Î½.restrict s ",":= by
  repeat rw [sub_def]
  have h_nonempty : { d | Î¼ â‰¤ d + Î½ }.Nonempty := âŸ¨Î¼, Measure.le_add_right le_rflâŸ©
  rw [restrict_sInf_eq_sInf_restrict h_nonempty h_meas_s]
  apply le_antisymm
  Â· refine sInf_le_sInf_of_forall_exists_le ?_
    intro Î½' h_Î½'_in
    rw [mem_setOf_eq] at h_Î½'_in
    refine âŸ¨Î½'.restrict s, ?_, restrict_le_selfâŸ©
    refine âŸ¨Î½' + (âŠ¤ : Measure Î±).restrict sá¶œ, ?_, ?_âŸ©
    Â· rw [mem_setOf_eq, add_right_comm, Measure.le_iff]
      intro t h_meas_t
      repeat rw [â† measure_inter_add_diff t h_meas_s]
      refine add_le_add ?_ ?_
      Â· rw [add_apply, add_apply]
        apply le_add_right _
        rw [â† restrict_eq_self Î¼ inter_subset_right,
          â† restrict_eq_self Î½ inter_subset_right]
        apply h_Î½'_in
      Â· rw [add_apply, restrict_apply (h_meas_t.diff h_meas_s), diff_eq, inter_assoc, inter_self,
          â† add_apply]
        have h_mu_le_add_top : Î¼ â‰¤ Î½' + Î½ + âŠ¤ := by simp only [add_top, le_top]
        exact Measure.le_iff'.1 h_mu_le_add_top _
    Â· ext1 t h_meas_t
      simp [restrict_apply h_meas_t, restrict_apply (h_meas_t.inter h_meas_s), inter_assoc]
  Â· refine sInf_le_sInf_of_forall_exists_le ?_
    refine forall_mem_image.2 fun t h_t_in => âŸ¨t.restrict s, ?_, le_rflâŸ©
    rw [Set.mem_setOf_eq, â† restrict_add]
    exact restrict_mono Subset.rfl h_t_in","simp_rw [restrict_sub_eq_restrict_sub_eq_restrict_sub_eq_restrict_sub_restrict,
  restrict_sub_eq_restrict_sub_eq_restrict_sub_restrict]"
Mathlib/Data/PNat/Xgcd.lean,PNat.gcdA'_coe,gcdA'_coe,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  dsimp [gcdA', gcdX, gcdW, XgcdType.w]
  rw [Nat.succ_eq_add_one, Nat.succ_eq_add_one, add_right_comm]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
a b : â„•+
âŠ¢ (a.xgcd b).wp + (a.xgcd b).x + 1 = (a.xgcd b).wp + 1 + (a.xgcd b).x",theorem gcdA'_coe : (gcdA' a b : â„•) = gcdW a b + gcdX a b ,":= by
  dsimp [gcdA', gcdX, gcdW, XgcdType.w]
  rw [add_right_comm]",apply theorem_eq_gcdW_of_gcdW_of_gcdW' a b gcdW'_coe
Mathlib/MeasureTheory/Integral/Lebesgue.lean,MeasureTheory.lintegral_tsum,lintegral_tsum,1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493,":= by
  simp only [ENNReal.tsum_eq_iSup_sum]
  rw [lintegral_iSup_directed]
  Â· simp [lintegral_finset_sum' _ fun i _ => hf i]
  Â· intro b
    exact Finset.aemeasurable_sum _ fun i _ => hf i
  Â· intro s t
    use s âˆª t
    constructor
    Â· exact fun a => Finset.sum_le_sum_of_subset (Finset.subset_union_left _ _)
    Â· exact fun a => Finset.sum_le_sum_of_subset (Finset.subset_union_right _ _)","warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
error:  function expected at
  Finset.subset_union_left ?m.330081
term has type
  ?m.330080 âˆˆ ?m.330078 âˆª ?m.330079
error:  function expected at
  Finset.subset_union_right ?m.330287
term has type
  ?m.330286 âˆˆ ?m.330284 âˆª ?m.330285","theorem lintegral_tsum [Countable Î²] {f : Î² â†’ Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ i, AEMeasurable (f i) Î¼) :
    âˆ«â» a, âˆ‘' i, f i a âˆ‚Î¼ = âˆ‘' i, âˆ«â» a, f i a âˆ‚Î¼ ",":= by
  simp only [ENNReal.tsum_eq_iSup_sum]
  rw [lintegral_iSup_directed]
  Â· simp [lintegral_finset_sum' _ fun i _ => hf i]
  Â· intro b
    exact Finset.aemeasurable_sum _ fun i _ => hf i
  Â· intro s t
    use s âˆª t
    constructor
    Â· exact fun a => Finset.sum_le_sum_of_subset Finset.subset_union_left
    Â· exact fun a => Finset.sum_le_sum_of_subset Finset.subset_union_right","simp only [lintegral_tsum, ENNReal.tsum_eq_iSup]"
Mathlib/RingTheory/DedekindDomain/Factorization.lean,Ideal.finite_mulSupport_coe,finite_mulSupport_coe,04cf8c4630518d88c67bf9ba4d4db872ea86f7e2,":= by
  rw [mulSupport]
  simp_rw [Ne.def, zpow_natCast, â† FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_one]
  exact finite_mulSupport hI","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.10383 â†’ ?m.10383 â†’ Prop
error:  simp made no progress","theorem finite_mulSupport_coe {I : Ideal R} (hI : I â‰  0) :
    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal Râ° K) ^
      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : â„¤)).Finite ",":= by
  rw [mulSupport]
  simp_rw [Ne, zpow_natCast, â† FractionalIdeal.coeIdeal_pow, FractionalIdeal.coeIdeal_eq_one]
  exact finite_mulSupport hI",apply Finite.subset (finite_mulSupport_coe {I : Ideal Râ° K)
Mathlib/Analysis/Calculus/BumpFunction/FiniteDimension.lean,ExistsContDiffBumpBase.y_pos_of_mem_ball,y_pos_of_mem_ball,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  simp only [mem_ball_zero_iff] at hx
  refine (integral_pos_iff_support_of_nonneg (w_mul_Ï†_nonneg D x) ?_).2? _
  Â· have F_comp : HasCompactSupport (w D) := w_compact_support E Dpos
    have B : LocallyIntegrable (Ï† : E â†’ â„) Î¼ :=
      (locallyIntegrable_const _).indicator measurableSet_closedBall
    have C : Continuous (w D : E â†’ â„) :=
      continuous_const.mul ((u_continuous E).comp (continuous_id.const_smul _))
    exact
      (HasCompactSupport.convolutionExistsLeft (lsmul â„ â„ : â„ â†’L[â„] â„ â†’L[â„] â„) F_comp C B
          x).integrable
  Â· set z := (D / (1 + D)) â€¢ x with hz
    have B : 0 < 1 + D := by linarith
    have C : ball z (D * (1 + D - â€–xâ€–) / (1 + D)) âŠ† support fun y : E => w D y * Ï† (x - y) := by
      intro y hy
      simp only [support_mul, w_support E Dpos]
      simp only [Ï†, mem_inter_iff, mem_support, Ne, indicator_apply_eq_zero,
        mem_closedBall_zero_iff, one_ne_zero, not_forall, not_false_iff, exists_prop, and_true_iff]
      constructor
      Â· apply ball_subset_ball' _ hy
        simp only [hz, norm_smul, abs_of_nonneg Dpos.le, abs_of_nonneg B.le, dist_zero_right,
          Real.norm_eq_abs, abs_div]
        simp only [div_le_iff B, field_simps]
        ring_nf
        rfl
      Â· have ID : â€–D / (1 + D) - 1â€– = 1 / (1 + D) := by
          rw [Real.norm_of_nonpos]
          Â· simp only [B.ne', Ne, not_false_iff, mul_one, neg_sub, add_tsub_cancel_right,
              field_simps]
          Â· simp only [B.ne', Ne, not_false_iff, mul_one, field_simps]
            apply div_nonpos_of_nonpos_of_nonneg _ B.le
            linarith only
        rw [â† mem_closedBall_iff_norm']
        apply closedBall_subset_closedBall' _ (ball_subset_closedBall hy)
        rw [â† one_smul â„ x, dist_eq_norm, hz, â† sub_smul, one_smul, norm_smul, ID]
        simp only [B.ne', div_le_iff B, field_simps]
        nlinarith only [hx, D_lt_one]
    apply lt_of_lt_of_le _ (measure_mono C)
    apply measure_ball_pos
    exact div_pos (mul_pos Dpos (by linarith only [hx])) B","error:  type mismatch
  (integral_pos_iff_support_of_nonneg (w_mul_Ï†_nonneg D x) ?m.214541).mpr
has type
  0 < ?m.214485 (support fun i â†¦ w D i * Ï† (x - i)) â†’ 0 < âˆ« (x_1 : E), w D x_1 * Ï† (x - x_1) âˆ‚?m.214485 : Prop
but is expected to have type
  0 < y D x : Prop
error:  unexpected token '?'; expected 'binder_predicate'","theorem y_pos_of_mem_ball {D : â„} {x : E} (Dpos : 0 < D) (D_lt_one : D < 1)
    (hx : x âˆˆ ball (0 : E) (1 + D)) : 0 < y D x ",":= by
  simp only [mem_ball_zero_iff] at hx
  refine (integral_pos_iff_support_of_nonneg (w_mul_Ï†_nonneg D x) ?_).2 ?_
  Â· have F_comp : HasCompactSupport (w D) := w_compact_support E Dpos
    have B : LocallyIntegrable (Ï† : E â†’ â„) Î¼ :=
      (locallyIntegrable_const _).indicator measurableSet_closedBall
    have C : Continuous (w D : E â†’ â„) :=
      continuous_const.mul ((u_continuous E).comp (continuous_id.const_smul _))
    exact
      (HasCompactSupport.convolutionExistsLeft (lsmul â„ â„ : â„ â†’L[â„] â„ â†’L[â„] â„) F_comp C B
          x).integrable
  Â· set z := (D / (1 + D)) â€¢ x with hz
    have B : 0 < 1 + D := by linarith
    have C : ball z (D * (1 + D - â€–xâ€–) / (1 + D)) âŠ† support fun y : E => w D y * Ï† (x - y) := by
      intro y hy
      simp only [support_mul, w_support E Dpos]
      simp only [Ï†, mem_inter_iff, mem_support, Ne, indicator_apply_eq_zero,
        mem_closedBall_zero_iff, one_ne_zero, not_forall, not_false_iff, exists_prop, and_true_iff]
      constructor
      Â· apply ball_subset_ball' _ hy
        simp only [hz, norm_smul, abs_of_nonneg Dpos.le, abs_of_nonneg B.le, dist_zero_right,
          Real.norm_eq_abs, abs_div]
        simp only [div_le_iff B, field_simps]
        ring_nf
        rfl
      Â· have ID : â€–D / (1 + D) - 1â€– = 1 / (1 + D) := by
          rw [Real.norm_of_nonpos]
          Â· simp only [B.ne', Ne, not_false_iff, mul_one, neg_sub, add_tsub_cancel_right,
              field_simps]
          Â· simp only [B.ne', Ne, not_false_iff, mul_one, field_simps]
            apply div_nonpos_of_nonpos_of_nonneg _ B.le
            linarith only
        rw [â† mem_closedBall_iff_norm']
        apply closedBall_subset_closedBall' _ (ball_subset_closedBall hy)
        rw [â† one_smul â„ x, dist_eq_norm, hz, â† sub_smul, one_smul, norm_smul, ID]
        simp only [B.ne', div_le_iff B, field_simps]
        nlinarith only [hx, D_lt_one]
    apply lt_of_lt_of_le _ (measure_mono C)
    apply measure_ball_pos
    exact div_pos (mul_pos Dpos (by linarith only [hx])) B",rw [mem_ball_zero_iff] at hx
Mathlib/Topology/MetricSpace/HausdorffDistance.lean,Metric.infDist_inter_closedBall_of_mem,infDist_inter_closedBall_of_mem,089ac90928952b8a08be66ede7ff142d0f9ba666,":= by
  replace h : y âˆˆ s âˆ© closedBall x (dist y x) := âŸ¨h, mem_closedBall.2 le_rflâŸ©
  refine le_antisymm ?_ (infDist_le_infDist_of_subset (inter_subset_left _ _) âŸ¨y, hâŸ©)
  refine not_lt.1 fun hlt => ?_
  rcases (infDist_lt_iff âŸ¨y, h.1âŸ©).mp hlt with âŸ¨z, hzs, hzâŸ©
  rcases le_or_lt (dist z x) (dist y x) with hle | hlt
  Â· exact hz.not_le (infDist_le_dist_of_mem âŸ¨hzs, hleâŸ©)
  Â· rw [dist_comm z, dist_comm y] at hlt
    exact (hlt.trans hz).not_le (infDist_le_dist_of_mem h)","error:  function expected at
  inter_subset_left ?m.75705
term has type
  ?m.75704 âˆˆ ?m.75702","theorem infDist_inter_closedBall_of_mem (h : y âˆˆ s) :
    infDist x (s âˆ© closedBall x (dist y x)) = infDist x s ",":= by
  replace h : y âˆˆ s âˆ© closedBall x (dist y x) := âŸ¨h, mem_closedBall.2 le_rflâŸ©
  refine le_antisymm ?_ (infDist_le_infDist_of_subset inter_subset_left âŸ¨y, hâŸ©)
  refine not_lt.1 fun hlt => ?_
  rcases (infDist_lt_iff âŸ¨y, h.1âŸ©).mp hlt with âŸ¨z, hzs, hzâŸ©
  rcases le_or_lt (dist z x) (dist y x) with hle | hlt
  Â· exact hz.not_le (infDist_le_dist_of_mem âŸ¨hzs, hleâŸ©)
  Â· rw [dist_comm z, dist_comm y] at hlt
    exact (hlt.trans hz).not_le (infDist_le_dist_of_mem h)","rw [infDist_inter_closedBall_of_mem, infDist_inter_closedBall_of_mem]"
Mathlib/MeasureTheory/Function/Egorov.lean,MeasureTheory.Egorov.measure_notConvergentSeq_tendsto_zero,measure_notConvergentSeq_tendsto_zero,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  cases' isEmpty_or_nonempty Î¹ with h h
  Â· have : (fun j => Î¼ (s âˆ© notConvergentSeq f g n j)) = fun j => 0 := by
      simp only [eq_iff_true_of_subsingleton]
    rw [this]
    exact tendsto_const_nhds
  rw [â† measure_inter_notConvergentSeq_eq_zero hfg n, Set.inter_iInter]
  refine' tendsto_measure_iInter (fun n => hsm.inter <| notConvergentSeq_measurableSet hf hg)
    (fun k l hkl => Set.inter_subset_inter_right _ <| notConvergentSeq_antitone hkl)
    âŸ¨h.some, ne_top_of_le_ne_top hs (measure_mono <| Set.inter_subset_left _ _)âŸ©","error:  function expected at
  inter_subset_left ?m.12441
term has type
  ?m.12440 âˆˆ ?m.12438","theorem measure_notConvergentSeq_tendsto_zero [SemilatticeSup Î¹] [Countable Î¹]
    (hf : âˆ€ n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g) (hsm : MeasurableSet s)
    (hs : Î¼ s â‰  âˆ) (hfg : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ Tendsto (fun n => f n x) atTop (ğ“ (g x))) (n : â„•) :
    Tendsto (fun j => Î¼ (s âˆ© notConvergentSeq f g n j)) atTop (ğ“ 0) ",":= by
  cases' isEmpty_or_nonempty Î¹ with h h
  Â· have : (fun j => Î¼ (s âˆ© notConvergentSeq f g n j)) = fun j => 0 := by
      simp only [eq_iff_true_of_subsingleton]
    rw [this]
    exact tendsto_const_nhds
  rw [â† measure_inter_notConvergentSeq_eq_zero hfg n, Set.inter_iInter]
  refine tendsto_measure_iInter (fun n => hsm.inter <| notConvergentSeq_measurableSet hf hg)
    (fun k l hkl => Set.inter_subset_inter_right _ <| notConvergentSeq_antitone hkl)
    âŸ¨h.some, ne_top_of_le_ne_top hs (measure_mono Set.inter_subset_left)âŸ©",simp only [notConvergentSeq_zero]
Mathlib/NumberTheory/DiophantineApproximation.lean,Real.exists_rat_eq_convergent',exists_rat_eq_convergent',61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Î¾ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  Â· replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Î¾).trans_lt h)
  Â· rw [Nat.cast_one, div_one]
    obtain âŸ¨_, hâ‚, hâ‚‚âŸ© := h
    rcases le_or_lt (u : â„) Î¾ with ht | ht
    Â· use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp hâ‚‚).2) <;> norm_num
    Â· replace hâ‚ := lt_sub_iff_add_lt'.mp (hâ‚ rfl)
      have hÎ¾â‚ : âŒŠÎ¾âŒ‹ = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact âŸ¨(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans hâ‚).le, htâŸ©
      rcases eq_or_ne Î¾ âŒŠÎ¾âŒ‹ with HÎ¾ | HÎ¾
      Â· rw [HÎ¾, hÎ¾â‚, cast_sub, cast_one, â† sub_eq_add_neg, sub_lt_sub_iff_left] at hâ‚
        exact False.elim (lt_irrefl _ <| hâ‚.trans one_half_lt_one)
      Â· have hÎ¾â‚‚ : âŒŠ(fract Î¾)â»Â¹âŒ‹ = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HÎ¾), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HÎ¾) zero_lt_two]
          refine' âŸ¨(fract_lt_one Î¾).le, _âŸ©
          rw [fract, hÎ¾â‚, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert hâ‚ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hÎ¾â‚, hÎ¾â‚‚, cast_sub, cast_one]
  Â· obtain âŸ¨huvâ‚€, huvâ‚âŸ© := auxâ‚‚ (Nat.cast_le.mpr ht) h
    have Hv : (v : â„š) â‰  0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huvâ‚' : (u - âŒŠÎ¾âŒ‹ * v).toNat < v := by zify; rwa [toNat_of_nonneg huvâ‚€.le]
    have inv : ContfracLegendre.Ass (fract Î¾)â»Â¹ v (u - âŒŠÎ¾âŒ‹ * â†‘v).toNat :=
      (toNat_of_nonneg huvâ‚€.le).symm â–¸ invariant (Nat.cast_le.mpr ht) h
    obtain âŸ¨n, hnâŸ© := ih (u - âŒŠÎ¾âŒ‹ * v).toNat huvâ‚' inv
    use n + 1
    rw [convergent_succ, â† hn,
      (mod_cast toNat_of_nonneg huvâ‚€.le : ((u - âŒŠÎ¾âŒ‹ * v).toNat : â„š) = u - âŒŠÎ¾âŒ‹ * v),
      cast_ofNat, inv_div, sub_div, mul_div_cancel_rightâ‚€ _ Hv, add_sub_cancel]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â†‘(OfNat.ofNat ?n)
case h
vâœ : â„¤
hv : 2 â‰¤ vâœ
v : â„•
ih : âˆ€ m < v, âˆ€ {Î¾ : â„} {u : â„¤}, ContfracLegendre.Ass Î¾ u â†‘m â†’ âˆƒ n, â†‘u / â†‘m = Î¾.convergent n
Î¾ : â„
u : â„¤
h : ContfracLegendre.Ass Î¾ u â†‘v
ht : 1 < v
huvâ‚€ : 0 < u - âŒŠÎ¾âŒ‹ * â†‘v
huvâ‚ : u - âŒŠÎ¾âŒ‹ * â†‘v < â†‘v
Hv : â†‘v â‰  0
huvâ‚' : (u - âŒŠÎ¾âŒ‹ * â†‘v).toNat < v
inv : ContfracLegendre.Ass (fract Î¾)â»Â¹ â†‘v â†‘(u - âŒŠÎ¾âŒ‹ * â†‘v).toNat
n : â„•
hn : â†‘â†‘v / â†‘(u - âŒŠÎ¾âŒ‹ * â†‘v).toNat = (fract Î¾)â»Â¹.convergent n
âŠ¢ â†‘u / â†‘v = â†‘âŒŠÎ¾âŒ‹ + (â†‘â†‘v / (â†‘u - â†‘âŒŠÎ¾âŒ‹ * â†‘v))â»Â¹","theorem exists_rat_eq_convergent' {v : â„•} (h' : ContfracLegendre.Ass Î¾ u v) :
    âˆƒ n, (u / v : â„š) = Î¾.convergent n ",":= by
  clear h; have h := h'; clear h'
  induction v using Nat.strong_induction_on generalizing Î¾ u with | h v ih => ?_
  rcases lt_trichotomy v 1 with (ht | rfl | ht)
  Â· replace h := h.2.2
    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,
      cast_zero, inv_zero] at h
    exact False.elim (lt_irrefl _ <| (abs_nonneg Î¾).trans_lt h)
  Â· rw [Nat.cast_one, div_one]
    obtain âŸ¨_, hâ‚, hâ‚‚âŸ© := h
    rcases le_or_lt (u : â„) Î¾ with ht | ht
    Â· use 0
      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]
      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp hâ‚‚).2) <;> norm_num
    Â· replace hâ‚ := lt_sub_iff_add_lt'.mp (hâ‚ rfl)
      have hÎ¾â‚ : âŒŠÎ¾âŒ‹ = u - 1 := by
        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]
        exact âŸ¨(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans hâ‚).le, htâŸ©
      rcases eq_or_ne Î¾ âŒŠÎ¾âŒ‹ with HÎ¾ | HÎ¾
      Â· rw [HÎ¾, hÎ¾â‚, cast_sub, cast_one, â† sub_eq_add_neg, sub_lt_sub_iff_left] at hâ‚
        exact False.elim (lt_irrefl _ <| hâ‚.trans one_half_lt_one)
      Â· have hÎ¾â‚‚ : âŒŠ(fract Î¾)â»Â¹âŒ‹ = 1 := by
          rw [floor_eq_iff, cast_one, le_inv zero_lt_one (fract_pos.mpr HÎ¾), inv_one,
            one_add_one_eq_two, inv_lt (fract_pos.mpr HÎ¾) zero_lt_two]
          refine âŸ¨(fract_lt_one Î¾).le, ?_âŸ©
          rw [fract, hÎ¾â‚, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]
          convert hâ‚ using 1
          rw [sub_eq_add_neg]
          norm_num
        use 1
        simp [convergent, hÎ¾â‚, hÎ¾â‚‚, cast_sub, cast_one]
  Â· obtain âŸ¨huvâ‚€, huvâ‚âŸ© := auxâ‚‚ (Nat.cast_le.mpr ht) h
    have Hv : (v : â„š) â‰  0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'
    have huvâ‚' : (u - âŒŠÎ¾âŒ‹ * v).toNat < v := by zify; rwa [toNat_of_nonneg huvâ‚€.le]
    have inv : ContfracLegendre.Ass (fract Î¾)â»Â¹ v (u - âŒŠÎ¾âŒ‹ * â†‘v).toNat :=
      (toNat_of_nonneg huvâ‚€.le).symm â–¸ invariant (Nat.cast_le.mpr ht) h
    obtain âŸ¨n, hnâŸ© := ih (u - âŒŠÎ¾âŒ‹ * v).toNat huvâ‚' inv
    use n + 1
    rw [convergent_succ, â† hn,
      (mod_cast toNat_of_nonneg huvâ‚€.le : ((u - âŒŠÎ¾âŒ‹ * v).toNat : â„š) = u - âŒŠÎ¾âŒ‹ * v),
      cast_natCast, inv_div, sub_div, mul_div_cancel_rightâ‚€ _ Hv, add_sub_cancel]","obtain âŸ¨n, hnâŸ© := exists_rat_eq_convergent'_exists_rat_eq_convergent_eq h'"
Mathlib/Analysis/Analytic/Basic.lean,HasFPowerSeriesOnBall.isBigO_image_sub_image_sub_deriv_principal,HasFPowerSeriesOnBall.isBigO_image_sub_image_sub_deriv_principal,c84d9003027b182d6e34911289aa4dc7700ea050,":= by
  lift r' to â„â‰¥0 using ne_top_of_lt hr
  rcases (zero_le r').eq_or_lt with (rfl | hr'0)
  Â· simp only [isBigO_bot, EMetric.ball_zero, principal_empty, ENNReal.coe_zero]
  obtain âŸ¨a, ha, C, hC : 0 < C, hpâŸ© :
    âˆƒ a âˆˆ Ioo (0 : â„) 1, âˆƒ C > 0, âˆ€ n : â„•, â€–p nâ€– * (r' : â„) ^ n â‰¤ C * a ^ n
  exact p.norm_mul_pow_le_mul_pow_of_lt_radius (hr.trans_le hf.r_le)
  simp only [â† le_div_iff (pow_pos (NNReal.coe_pos.2 hr'0) _)] at hp
  set L : E Ã— E â†’ â„ := fun y =>
    C * (a / r') ^ 2 * (â€–y - (x, x)â€– * â€–y.1 - y.2â€–) * (a / (1 - a) ^ 2 + 2 / (1 - a))
  have hL : âˆ€ y âˆˆ EMetric.ball (x, x) r', â€–f y.1 - f y.2 - p 1 fun _ => y.1 - y.2â€– â‰¤ L y := by
    intro y hy'
    have hy : y âˆˆ EMetric.ball x r Ã—Ë¢ EMetric.ball x r := by
      rw [EMetric.ball_prod_same]
      exact EMetric.ball_subset_ball hr.le hy'
    set A : â„• â†’ F := fun n => (p n fun _ => y.1 - x) - p n fun _ => y.2 - x
    have hA : HasSum (fun n => A (n + 2)) (f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) := by
      convert (hasSum_nat_add_iff' 2).2 ((hf.hasSum_sub hy.1).sub (hf.hasSum_sub hy.2)) using 1
      rw [Finset.sum_range_succ, Finset.sum_range_one, hf.coeff_zero, hf.coeff_zero, sub_self,
        zero_add, â† Subsingleton.pi_single_eq (0 : Fin 1) (y.1 - x), Pi.single,
        â† Subsingleton.pi_single_eq (0 : Fin 1) (y.2 - x), Pi.single, â† (p 1).map_sub, â† Pi.single,
        Subsingleton.pi_single_eq, sub_sub_sub_cancel_right]
    rw [EMetric.mem_ball, edist_eq_coe_nnnorm_sub, ENNReal.coe_lt_coe] at hy'
    set B : â„• â†’ â„ := fun n => C * (a / r') ^ 2 * (â€–y - (x, x)â€– * â€–y.1 - y.2â€–) * ((n + 2) * a ^ n)
    have hAB : âˆ€ n, â€–A (n + 2)â€– â‰¤ B n := fun n =>
      calc
        â€–A (n + 2)â€– â‰¤ â€–p (n + 2)â€– * â†‘(n + 2) * â€–y - (x, x)â€– ^ (n + 1) * â€–y.1 - y.2â€– := by
          simpa only [Fintype.card_fin, pi_norm_const, Prod.norm_def, Pi.sub_def,
            Prod.fst_sub, Prod.snd_sub, sub_sub_sub_cancel_right] using
            (p <| n + 2).norm_image_sub_le (fun _ => y.1 - x) fun _ => y.2 - x
        _ = â€–p (n + 2)â€– * â€–y - (x, x)â€– ^ n * (â†‘(n + 2) * â€–y - (x, x)â€– * â€–y.1 - y.2â€–) := by
          rw [pow_succ â€–y - (x, x)â€–]
          ring
        _ â‰¤ C * a ^ (n + 2) / â†‘r' ^ (n + 2)
            * â†‘r' ^ n * (â†‘(n + 2) * â€–y - (x, x)â€– * â€–y.1 - y.2â€–) := by
          have : 0 < a := ha.1
          gcongr
          Â· apply hp
          Â· apply hy'.le
        _ = B n := by
          unfold_let B
          field_simp [pow_succ]
          simp only [mul_assoc, mul_comm, mul_left_comm]
    have hBL : HasSum B (L y) := by
      apply HasSum.mul_left
      simp only [add_mul]
      have : â€–aâ€– < 1 := by simp only [Real.norm_eq_abs, abs_of_pos ha.1, ha.2]
      rw [div_eq_mul_inv, div_eq_mul_inv]
      exact (hasSum_coe_mul_geometric_of_norm_lt_1 this).add  
          ((hasSum_geometric_of_norm_lt_1 this).mul_left 2)
    exact hA.norm_le_of_bounded hBL hAB
  suffices L =O[ğ“Ÿ (EMetric.ball (x, x) r')] fun y => â€–y - (x, x)â€– * â€–y.1 - y.2â€– by
    refine' (IsBigO.of_bound 1 (eventually_principal.2 fun y hy => _)).trans this
    rw [one_mul]
    exact (hL y hy).trans (le_abs_self _)
  simp_rw [mul_right_comm _ (_ * _)]  
  exact (isBigO_refl _ _).const_mul_left _","warning:  `hasSum_coe_mul_geometric_of_norm_lt_1` has been deprecated, use `hasSum_coe_mul_geometric_of_norm_lt_one` instead
warning:  `hasSum_geometric_of_norm_lt_1` has been deprecated, use `hasSum_geometric_of_norm_lt_one` instead
error:  simp made no progress","theorem HasFPowerSeriesOnBall.isBigO_image_sub_image_sub_deriv_principal
    (hf : HasFPowerSeriesOnBall f p x r) (hr : r' < r) :
    (fun y : E Ã— E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) =O[ğ“Ÿ (EMetric.ball (x, x) r')]
      fun y => â€–y - (x, x)â€– * â€–y.1 - y.2â€– ",":= by
  lift r' to â„â‰¥0 using ne_top_of_lt hr
  rcases (zero_le r').eq_or_lt with (rfl | hr'0)
  Â· simp only [isBigO_bot, EMetric.ball_zero, principal_empty, ENNReal.coe_zero]
  obtain âŸ¨a, ha, C, hC : 0 < C, hpâŸ© :
      âˆƒ a âˆˆ Ioo (0 : â„) 1, âˆƒ C > 0, âˆ€ n : â„•, â€–p nâ€– * (r' : â„) ^ n â‰¤ C * a ^ n :=
    p.norm_mul_pow_le_mul_pow_of_lt_radius (hr.trans_le hf.r_le)
  simp only [â† le_div_iff (pow_pos (NNReal.coe_pos.2 hr'0) _)] at hp
  set L : E Ã— E â†’ â„ := fun y =>
    C * (a / r') ^ 2 * (â€–y - (x, x)â€– * â€–y.1 - y.2â€–) * (a / (1 - a) ^ 2 + 2 / (1 - a))
  have hL : âˆ€ y âˆˆ EMetric.ball (x, x) r', â€–f y.1 - f y.2 - p 1 fun _ => y.1 - y.2â€– â‰¤ L y := by
    intro y hy'
    have hy : y âˆˆ EMetric.ball x r Ã—Ë¢ EMetric.ball x r := by
      rw [EMetric.ball_prod_same]
      exact EMetric.ball_subset_ball hr.le hy'
    set A : â„• â†’ F := fun n => (p n fun _ => y.1 - x) - p n fun _ => y.2 - x
    have hA : HasSum (fun n => A (n + 2)) (f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) := by
      convert (hasSum_nat_add_iff' 2).2 ((hf.hasSum_sub hy.1).sub (hf.hasSum_sub hy.2)) using 1
      rw [Finset.sum_range_succ, Finset.sum_range_one, hf.coeff_zero, hf.coeff_zero, sub_self,
        zero_add, â† Subsingleton.pi_single_eq (0 : Fin 1) (y.1 - x), Pi.single,
        â† Subsingleton.pi_single_eq (0 : Fin 1) (y.2 - x), Pi.single, â† (p 1).map_sub, â† Pi.single,
        Subsingleton.pi_single_eq, sub_sub_sub_cancel_right]
    rw [EMetric.mem_ball, edist_eq_coe_nnnorm_sub, ENNReal.coe_lt_coe] at hy'
    set B : â„• â†’ â„ := fun n => C * (a / r') ^ 2 * (â€–y - (x, x)â€– * â€–y.1 - y.2â€–) * ((n + 2) * a ^ n)
    have hAB : âˆ€ n, â€–A (n + 2)â€– â‰¤ B n := fun n =>
      calc
        â€–A (n + 2)â€– â‰¤ â€–p (n + 2)â€– * â†‘(n + 2) * â€–y - (x, x)â€– ^ (n + 1) * â€–y.1 - y.2â€– := by
          simpa only [Fintype.card_fin, pi_norm_const, Prod.norm_def, Pi.sub_def,
            Prod.fst_sub, Prod.snd_sub, sub_sub_sub_cancel_right] using
            (p <| n + 2).norm_image_sub_le (fun _ => y.1 - x) fun _ => y.2 - x
        _ = â€–p (n + 2)â€– * â€–y - (x, x)â€– ^ n * (â†‘(n + 2) * â€–y - (x, x)â€– * â€–y.1 - y.2â€–) := by
          rw [pow_succ â€–y - (x, x)â€–]
          ring
        _ â‰¤ C * a ^ (n + 2) / â†‘r' ^ (n + 2)
            * â†‘r' ^ n * (â†‘(n + 2) * â€–y - (x, x)â€– * â€–y.1 - y.2â€–) := by
          have : 0 < a := ha.1
          gcongr
          Â· apply hp
          Â· apply hy'.le
        _ = B n := by
          field_simp [B, pow_succ]
          simp only [mul_assoc, mul_comm, mul_left_comm]
    have hBL : HasSum B (L y) := by
      apply HasSum.mul_left
      simp only [add_mul]
      have : â€–aâ€– < 1 := by simp only [Real.norm_eq_abs, abs_of_pos ha.1, ha.2]
      rw [div_eq_mul_inv, div_eq_mul_inv]
      exact (hasSum_coe_mul_geometric_of_norm_lt_one this).add  
          ((hasSum_geometric_of_norm_lt_one this).mul_left 2)
    exact hA.norm_le_of_bounded hBL hAB
  suffices L =O[ğ“Ÿ (EMetric.ball (x, x) r')] fun y => â€–y - (x, x)â€– * â€–y.1 - y.2â€– by
    refine (IsBigO.of_bound 1 (eventually_principal.2 fun y hy => ?_)).trans this
    rw [one_mul]
    exact (hL y hy).trans (le_abs_self _)
  simp_rw [L, mul_right_comm _ (_ * _)]
  exact (isBigO_refl _ _).const_mul_left _",refine theorem_isBigO_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_deriv_principal ?_ ?_
Mathlib/Algebra/CharP/CharAndCard.lean,prime_dvd_char_iff_dvd_card,prime_dvd_char_iff_dvd_card,9e34a191034458a56331f976ff7400a26407c888,":= by
  refine'
    âŸ¨fun h =>
      h.trans <|
        Int.coe_nat_dvd.mp <|
          (CharP.int_cast_eq_zero_iff R (ringChar R) (Fintype.card R)).mp <| by
            exact_mod_cast CharP.cast_card_eq_zero R,
      fun h => _âŸ©
  by_contra hâ‚€
  rcases exists_prime_addOrderOf_dvd_card p h with âŸ¨r, hrâŸ©
  have hrâ‚ := addOrderOf_nsmul_eq_zero r
  rw [hr, nsmul_eq_mul] at hrâ‚
  rcases IsUnit.exists_left_inv ((isUnit_iff_not_dvd_char R p).mpr hâ‚€) with âŸ¨u, huâŸ©
  apply_fun (Â· * Â·) u at hrâ‚
  rw [MulZeroClass.mul_zero, â† mul_assoc, hu, one_mul] at hrâ‚
  exact mt AddMonoid.addOrderOf_eq_one_iff.mpr (ne_of_eq_of_ne hr (Nat.Prime.ne_one Fact.out)) hrâ‚","warning:  `Int.coe_nat_dvd` has been deprecated, use `Int.natCast_dvd_natCast` instead
error:  unknown constant 'CharP.int_cast_eq_zero_iff'","theorem prime_dvd_char_iff_dvd_card {R : Type*} [CommRing R] [Fintype R] (p : â„•) [Fact p.Prime] :
    p âˆ£ ringChar R â†” p âˆ£ Fintype.card R ",":= by
  refine
    âŸ¨fun h =>
      h.trans <|
        Int.natCast_dvd_natCast.mp <|
          (CharP.intCast_eq_zero_iff R (ringChar R) (Fintype.card R)).mp <|
            mod_cast Nat.cast_card_eq_zero R,
      fun h => ?_âŸ©
  by_contra hâ‚€
  rcases exists_prime_addOrderOf_dvd_card p h with âŸ¨r, hrâŸ©
  have hrâ‚ := addOrderOf_nsmul_eq_zero r
  rw [hr, nsmul_eq_mul] at hrâ‚
  rcases IsUnit.exists_left_inv ((isUnit_iff_not_dvd_char R p).mpr hâ‚€) with âŸ¨u, huâŸ©
  apply_fun (Â· * Â·) u at hrâ‚
  rw [mul_zero, â† mul_assoc, hu, one_mul] at hrâ‚
  exact mt AddMonoid.addOrderOf_eq_one_iff.mpr (ne_of_eq_of_ne hr (Nat.Prime.ne_one Fact.out)) hrâ‚",constructor
Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean,MeasureTheory.Measure.rnDeriv_withDensity_right,rnDeriv_withDensity_right,6861d9247d1a06a093e444c3a0319e5ec45263c2,":= by
  have : SigmaFinite (Î½.withDensity f) := SigmaFinite.withDensity_of_ne_top hf hf_ne_top
  refine (withDensity_absolutelyContinuous' hf hf_ne_zero hf_ne_top).ae_eq ?_
  refine (Measure.eq_rnDerivâ‚€ (Î½ := Î½.withDensity f) ?_ Measure.MutuallySingular.zero_left ?_).symm
  Â· exact (hf.inv.mono_ac (withDensity_absolutelyContinuous _ _)).mul
      (Measure.measurable_rnDeriv _ _).aemeasurable
  Â· ext1 s hs
    conv_lhs => rw [â† Measure.withDensity_rnDeriv_eq _ _ hÎ¼Î½]
    rw [zero_add, withDensity_apply _ hs, withDensity_apply _ hs]
    rw [set_lintegral_withDensity_eq_set_lintegral_mul_non_measurableâ‚€ _ _ _ hs]
    Â· simp only [Pi.mul_apply]
      have : (fun a â†¦ f a * ((f a)â»Â¹ * Î¼.rnDeriv Î½ a)) =áµ[Î½] Î¼.rnDeriv Î½ := by
        filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2
        simp [â† mul_assoc, ENNReal.mul_inv_cancel, hx1, hx2]
      rw [lintegral_congr_ae (ae_restrict_of_ae this)]
    Â· apply ae_restrict_of_ae
      filter_upwards [hf_ne_top] with x hx using hx.lt_top
    Â· exact hf.restrict","error:  application type mismatch
  withDensity_absolutelyContinuous' hf hf_ne_zero hf_ne_top
argument
  hf_ne_top
has type
  âˆ€áµ (x : Î±) âˆ‚Î½, f x â‰  âŠ¤ : Prop
but is expected to have type
  (Î½.withDensity f) ?m.16000 = 0 : Prop
error:  no goals to be solved","lemma rnDeriv_withDensity_right_of_absolutelyContinuous {Î½ : Measure Î±} [SigmaFinite Î¼]
    [SigmaFinite Î½] (hÎ¼Î½ : Î¼ â‰ª Î½) (hf : AEMeasurable f Î½)
    (hf_ne_zero : âˆ€áµ x âˆ‚Î½, f x â‰  0) (hf_ne_top : âˆ€áµ x âˆ‚Î½, f x â‰  âˆ) :
    Î¼.rnDeriv (Î½.withDensity f) =áµ[Î½] fun x â†¦ (f x)â»Â¹ * Î¼.rnDeriv Î½ x ",":= by
  have : SigmaFinite (Î½.withDensity f) := SigmaFinite.withDensity_of_ne_top hf hf_ne_top
  refine (withDensity_absolutelyContinuous' hf hf_ne_zero).ae_eq ?_
  refine (Measure.eq_rnDerivâ‚€ (Î½ := Î½.withDensity f) ?_ Measure.MutuallySingular.zero_left ?_).symm
  Â· exact (hf.inv.mono_ac (withDensity_absolutelyContinuous _ _)).mul
      (Measure.measurable_rnDeriv _ _).aemeasurable
  Â· ext1 s hs
    conv_lhs => rw [â† Measure.withDensity_rnDeriv_eq _ _ hÎ¼Î½]
    rw [zero_add, withDensity_apply _ hs, withDensity_apply _ hs]
    rw [setLIntegral_withDensity_eq_setLIntegral_mul_non_measurableâ‚€ _ _ _ hs]
    Â· simp only [Pi.mul_apply]
      have : (fun a â†¦ f a * ((f a)â»Â¹ * Î¼.rnDeriv Î½ a)) =áµ[Î½] Î¼.rnDeriv Î½ := by
        filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2
        simp [â† mul_assoc, ENNReal.mul_inv_cancel, hx1, hx2]
      rw [lintegral_congr_ae (ae_restrict_of_ae this)]
    Â· refine ae_restrict_of_ae ?_
      filter_upwards [hf_ne_top] with x hx using hx.lt_top
    Â· exact hf.restrict","have hf_ne_zero : âˆ€áµ x âˆ‚Î½, f x â‰  âˆ := by simp [hf_ne_zero, hf_ne_zero, hf_ne_top]"
Mathlib/Algebra/Module/Torsion.lean,Ideal.CompleteLattice.Independent.linear_independent',CompleteLattice.Independent.linear_independent',10e4cb0958e9421c11ec57a20aeb1367810b8675,":= by
  refine' linearIndependent_iff_not_smul_mem_span.mpr fun i r hi => _
  replace hv := CompleteLattice.independent_def.mp hv i
  simp only [iSup_subtype', â† Submodule.span_range_eq_iSup (Î¹ := Subtype _), disjoint_iff] at hv
  have : r â€¢ v i âˆˆ âŠ¥ := by
    rw [â† hv, Submodule.mem_inf]
    refine' âŸ¨Submodule.mem_span_singleton.mpr âŸ¨r, rflâŸ©, _âŸ©
    convert hi
    ext
    simp
  rw [â† Submodule.mem_bot R, â† h_ne_zero i]
  simpa using this","error:  typeclass instance problem is stuck, it is often due to metavariables
  Membership M ?m.17958","theorem CompleteLattice.Independent.linear_independent' {Î¹ R M : Type*} {v : Î¹ â†’ M} [Ring R]
    [AddCommGroup M] [Module R M] (hv : CompleteLattice.Independent fun i => R âˆ™ v i)
    (h_ne_zero : âˆ€ i, Ideal.torsionOf R M (v i) = âŠ¥) : LinearIndependent R v ",":= by
  refine linearIndependent_iff_not_smul_mem_span.mpr fun i r hi => ?_
  replace hv := CompleteLattice.independent_def.mp hv i
  simp only [iSup_subtype', â† Submodule.span_range_eq_iSup (Î¹ := Subtype _), disjoint_iff] at hv
  have : r â€¢ v i âˆˆ (âŠ¥ : Submodule R M) := by
    rw [â† hv, Submodule.mem_inf]
    refine âŸ¨Submodule.mem_span_singleton.mpr âŸ¨r, rflâŸ©, ?_âŸ©
    convert hi
    ext
    simp
  rw [â† Submodule.mem_bot R, â† h_ne_zero i]
  simpa using this",rw [CompleteLattice.Independent.linear_independent']
Mathlib/Topology/Algebra/Group/Basic.lean,IsCompact.locallyCompactSpace_of_mem_nhds_of_group,IsCompact.locallyCompactSpace_of_mem_nhds_of_group,8539229286dc361b2ec76d083f7e1e313d4cb42b,":= by
  refine âŸ¨fun y n hn â†¦ ?_âŸ©
  have A : (y * xâ»Â¹) â€¢ K âˆˆ ğ“ y := by
    rw [â† preimage_smul_inv]
    exact (continuous_const_smul _).continuousAt.preimage_mem_nhds (by simpa using h)
  rcases exists_mem_nhds_isClosed_subset (inter_mem A hn) with âŸ¨L, hL, L_closed, LKâŸ©
  refine âŸ¨L, hL, LK.trans (inter_subset_right _ _), ?_âŸ©
  exact (hK.smul (y * xâ»Â¹)).of_isClosed_subset L_closed (LK.trans (inter_subset_left _ _))","error:  function expected at
  inter_subset_right ?m.388733
term has type
  ?m.388732 âˆˆ ?m.388731
error:  function expected at
  inter_subset_left ?m.392645
term has type
  ?m.392644 âˆˆ ?m.392642","theorem IsCompact.locallyCompactSpace_of_mem_nhds_of_group {K : Set G} (hK : IsCompact K) {x : G}
    (h : K âˆˆ ğ“ x) : LocallyCompactSpace G ",":= by
  suffices WeaklyLocallyCompactSpace G from inferInstance
  refine âŸ¨fun y â†¦ âŸ¨(y * xâ»Â¹) â€¢ K, ?_, ?_âŸ©âŸ©
  Â· exact hK.smul _
  Â· rw [â† preimage_smul_inv]
    exact (continuous_const_smul _).continuousAt.preimage_mem_nhds (by simpa using h)",have : IsCompact K := IsCompact.locallyCompactSpace_of_mem_nhds_of_group
Mathlib/Analysis/LocallyConvex/WithSeminorms.lean,norm_withSeminorms,norm_withSeminorms,5972f1186b2ca6a1d047e1c045628b6e94c2181b,":= by
  let p : SeminormFamily ğ•œ E (Fin 1) := fun _ => normSeminorm ğ•œ E
  refine'
    âŸ¨SeminormedAddCommGroup.toTopologicalAddGroup.ext
        p.addGroupFilterBasis.isTopologicalAddGroup _âŸ©
  refine' Filter.HasBasis.eq_of_same_basis Metric.nhds_basis_ball _
  rw [â† ball_normSeminorm ğ•œ E]
  refine'
    Filter.HasBasis.to_hasBasis p.addGroupFilterBasis.nhds_zero_hasBasis _ fun r hr =>
      âŸ¨(normSeminorm ğ•œ E).ball 0 r, p.basisSets_singleton_mem 0 hr, rfl.subsetâŸ©
  rintro U (hU : U âˆˆ p.basisSets)
  rcases p.basisSets_iff.mp hU with âŸ¨s, r, hr, hUâŸ©
  use r, hr
  rw [hU, id.def]
  by_cases h : s.Nonempty
  Â· rw [Finset.sup_const h]
  rw [Finset.not_nonempty_iff_eq_empty.mp h, Finset.sup_empty, ball_bot _ hr]
  exact Set.subset_univ _","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.238666 â†’ ?m.238666
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.238668
case right
ğ•œâœ : Type u_1
ğ•œâ‚‚ : Type u_2
ğ• : Type u_3
ğ•â‚‚ : Type u_4
Eâœ : Type u_5
F : Type u_6
G : Type u_7
Î¹ : Type u_8
Î¹' : Type u_9
ğ•œ : Type u_10
E : Type u_11
instâœÂ² : NormedField ğ•œ
instâœÂ¹ : SeminormedAddCommGroup E
instâœ : NormedSpace ğ•œ E
p : SeminormFamily ğ•œ E (Fin 1) := fun x â†¦ normSeminorm ğ•œ E
U : Set E
hUâœ : U âˆˆ p.basisSets
s : Finset (Fin 1)
r : â„
hr : 0 < r
hU : U = (s.sup p).ball 0 r
âŠ¢ (normSeminorm ğ•œ E).ball 0 r âŠ† id ((s.sup p).ball 0 r)","theorem norm_withSeminorms (ğ•œ E) [NormedField ğ•œ] [SeminormedAddCommGroup E] [NormedSpace ğ•œ E] :
    WithSeminorms fun _ : Fin 1 => normSeminorm ğ•œ E ",":= by
  let p : SeminormFamily ğ•œ E (Fin 1) := fun _ => normSeminorm ğ•œ E
  refine
    âŸ¨SeminormedAddCommGroup.toTopologicalAddGroup.ext
        p.addGroupFilterBasis.isTopologicalAddGroup ?_âŸ©
  refine Filter.HasBasis.eq_of_same_basis Metric.nhds_basis_ball ?_
  rw [â† ball_normSeminorm ğ•œ E]
  refine
    Filter.HasBasis.to_hasBasis p.addGroupFilterBasis.nhds_zero_hasBasis ?_ fun r hr =>
      âŸ¨(normSeminorm ğ•œ E).ball 0 r, p.basisSets_singleton_mem 0 hr, rfl.subsetâŸ©
  rintro U (hU : U âˆˆ p.basisSets)
  rcases p.basisSets_iff.mp hU with âŸ¨s, r, hr, hUâŸ©
  use r, hr
  rw [hU, id]
  by_cases h : s.Nonempty
  Â· rw [Finset.sup_const h]
  rw [Finset.not_nonempty_iff_eq_empty.mp h, Finset.sup_empty, ball_bot _ hr]
  exact Set.subset_univ _","simp only [norm_withSeminorms, norm_withSeminorms]"
Mathlib/Analysis/BoxIntegral/Basic.lean,BoxIntegral.HasIntegral.sum,HasIntegral.sum,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' s with a s ha ihs; Â· simp [hasIntegral_zero]
  simp only [Finset.sum_insert ha]; rw [Finset.forall_mem_insert] at h
  exact h.1.add (ihs h.2)","error:  unsolved goals
case mk
Î¹ : Type u
E : Type v
F : Type w
instâœâ´ : NormedAddCommGroup E
instâœÂ³ : NormedSpace â„ E
instâœÂ² : NormedAddCommGroup F
instâœÂ¹ : NormedSpace â„ F
I J : Box Î¹
Ï€ : TaggedPrepartition I
instâœ : Fintype Î¹
l : IntegrationParams
fâœ gâœ : (Î¹ â†’ â„) â†’ E
vol : Î¹ â†’áµ‡áµƒ[âŠ¤] E â†’L[â„] F
y y' : F
Î± : Type u_1
f : Î± â†’ (Î¹ â†’ â„) â†’ E
g : Î± â†’ F
a : Multiset Î±
s : a.Nodup
h : âˆ€ i âˆˆ { val := a, nodup := s }, HasIntegral I l (f i) vol (g i)
âŠ¢ HasIntegral I l (fun x â†¦ (Multiset.map (fun i â†¦ f i x) a).sum) vol (Multiset.map (fun i â†¦ g i) a).sum
error:  no goals to be solved","theorem HasIntegral.sum {Î± : Type*} {s : Finset Î±} {f : Î± â†’ â„â¿ â†’ E} {g : Î± â†’ F}
    (h : âˆ€ i âˆˆ s, HasIntegral I l (f i) vol (g i)) :
    HasIntegral I l (fun x => âˆ‘ i âˆˆ s, f i x) vol (âˆ‘ i âˆˆ s, g i) ",":= by
  induction' s using Finset.induction_on with a s ha ihs; Â· simp [hasIntegral_zero]
  simp only [Finset.sum_insert ha]; rw [Finset.forall_mem_insert] at h
  exact h.1.add (ihs h.2)",rw [hasIntegral_iff_hasIntegral_hasIntegral]
Mathlib/Data/Nat/Multiplicity.lean,Nat.multiplicity_eq_card_pow_dvd,multiplicity_eq_card_pow_dvd,8e31b5ac6bed8ba535a30f3442252684d2f151c1,":=
  calc
    multiplicity m n = â†‘(Ico 1 <| (multiplicity m n).get (finite_nat_iff.2 âŸ¨hm, hnâŸ©) + 1).card := by
      simp
    _ = â†‘((Finset.Ico 1 b).filter fun i => m ^ i âˆ£ n).card :=
      congr_arg _ <|
        congr_arg card <|
          Finset.ext fun i => by
            rw [mem_filter, mem_Ico, mem_Ico, lt_succ_iff, â† @PartENat.coe_le_coe i,
              PartENat.natCast_get, â† pow_dvd_iff_le_multiplicity, and_right_comm]
            refine' (and_iff_left_of_imp fun h => lt_of_le_of_lt _ hb).symm
            cases' m with m
            Â· rw [zero_eq, zero_pow, zero_dvd_iff] at h
              exacts [(hn.ne' h.2).elim, h.1]
            exact le_log_of_pow_le (one_lt_iff_ne_zero_and_ne_one.2 âŸ¨m.succ_ne_zero, hmâŸ©)
                (le_of_dvd hn h.2)","error:  unknown identifier 'lt_succ_iff'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.5044
m n b : â„•
hm : m â‰  1
hn : 0 < n
hb : log m n < b
i : â„•
âŠ¢ 1 â‰¤ i âˆ§ i < (multiplicity m n).get â‹¯ + 1 â†” (1 â‰¤ i âˆ§ i < b) âˆ§ m ^ i âˆ£ n","theorem multiplicity_eq_card_pow_dvd {m n b : â„•} (hm : m â‰  1) (hn : 0 < n) (hb : log m n < b) :
    multiplicity m n = â†‘((Finset.Ico 1 b).filter fun i => m ^ i âˆ£ n).card ",":=
  calc
    multiplicity m n = â†‘(Ico 1 <| (multiplicity m n).get (finite_nat_iff.2 âŸ¨hm, hnâŸ©) + 1).card := by
      simp
    _ = â†‘((Finset.Ico 1 b).filter fun i => m ^ i âˆ£ n).card :=
      congr_arg _ <|
        congr_arg card <|
          Finset.ext fun i => by
            rw [mem_filter, mem_Ico, mem_Ico, Nat.lt_succ_iff, â† @PartENat.coe_le_coe i,
              PartENat.natCast_get, â† pow_dvd_iff_le_multiplicity, and_right_comm]
            refine (and_iff_left_of_imp fun h => lt_of_le_of_lt ?_ hb).symm
            cases' m with m
            Â· rw [zero_pow, zero_dvd_iff] at h
              exacts [(hn.ne' h.2).elim, one_le_iff_ne_zero.1 h.1]
            exact le_log_of_pow_le (one_lt_iff_ne_zero_and_ne_one.2 âŸ¨m.succ_ne_zero, hmâŸ©)
                (le_of_dvd hn h.2)","simp only [card_filter_of_not_multiplicity_eq_card_pow_dvd, card_Ico, card_Ico,
  card_filter_of_not_multiplicity_eq_card_pow_dvd]"
Mathlib/MeasureTheory/Function/SimpleFuncDense.lean,MeasureTheory.SimpleFunc.tendsto_approxOn,tendsto_approxOn,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  haveI : Nonempty s := âŸ¨âŸ¨yâ‚€, hâ‚€âŸ©âŸ©
  rw [â† @Subtype.range_coe _ s, â† image_univ, â† (denseRange_denseSeq s).closure_eq] at hx
  simp (config := { iota := false }) only [approxOn, coe_comp]
  refine' tendsto_nearestPt (closure_minimal _ isClosed_closure hx)
  simp (config := { iota := false }) only [Nat.range_casesOn, closure_union, range_comp]
  exact
    Subset.trans (image_closure_subset_closure_image continuous_subtype_val)
      (subset_union_right _ _)","error:  overloaded, errors 
  110:7 overloaded, errors 
    function expected at
      Finset.subset_union_right ?m.27657
    term has type
      ?m.27656 âˆˆ ?m.27654 âˆª ?m.27655
    
    function expected at
      Set.subset_union_right ?m.27918
    term has type
      ?m.27917 âˆˆ ?m.27915 âˆª ?m.27916
  
  110:7 overloaded, errors 
    function expected at
      Finset.subset_union_right ?m.28434
    term has type
      ?m.28433 âˆˆ ?m.28431 âˆª ?m.28432
    
    function expected at
      Set.subset_union_right ?m.28557
    term has type
      ?m.28556 âˆˆ ?m.28554 âˆª ?m.28555","theorem tendsto_approxOn {f : Î² â†’ Î±} (hf : Measurable f) {s : Set Î±} {yâ‚€ : Î±} (hâ‚€ : yâ‚€ âˆˆ s)
    [SeparableSpace s] {x : Î²} (hx : f x âˆˆ closure s) :
    Tendsto (fun n => approxOn f hf s yâ‚€ hâ‚€ n x) atTop (ğ“ <| f x) ",":= by
  haveI : Nonempty s := âŸ¨âŸ¨yâ‚€, hâ‚€âŸ©âŸ©
  rw [â† @Subtype.range_coe _ s, â† image_univ, â† (denseRange_denseSeq s).closure_eq] at hx
  simp (config := { iota := false }) only [approxOn, coe_comp]
  refine tendsto_nearestPt (closure_minimal ?_ isClosed_closure hx)
  simp (config := { iota := false }) only [Nat.range_casesOn, closure_union, range_comp]
  exact
    Subset.trans (image_closure_subset_closure_image continuous_subtype_val)
      subset_union_right",simp only [mem_closure_iff_nhds] at hx
Mathlib/Topology/ContinuousOn.lean,IsOpenMap.continuousOn_image_of_leftInvOn,IsOpenMap.continuousOn_image_of_leftInvOn,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  refine' continuousOn_iff'.2 fun t ht => âŸ¨f '' (t âˆ© s), _, _âŸ©
  Â· rw [â† image_restrict]
    exact h _ (ht.preimage continuous_subtype_val)
  Â· rw [inter_eq_self_of_subset_left (image_subset f (inter_subset_right t s)), hleft.image_inter']","error:  application type mismatch
  inter_subset_right t
argument
  t
has type
  Set Î± : Type u_1
but is expected to have type
  ?m.113181 âˆˆ ?m.113179 âˆ© ?m.113180 : Prop","theorem IsOpenMap.continuousOn_image_of_leftInvOn {f : Î± â†’ Î²} {s : Set Î±}
    (h : IsOpenMap (s.restrict f)) {finv : Î² â†’ Î±} (hleft : LeftInvOn finv f s) :
    ContinuousOn finv (f '' s) ",":= by
  refine continuousOn_iff'.2 fun t ht => âŸ¨f '' (t âˆ© s), ?_, ?_âŸ©
  Â· rw [â† image_restrict]
    exact h _ (ht.preimage continuous_subtype_val)
  Â· rw [inter_eq_self_of_subset_left (image_subset f inter_subset_right), hleft.image_inter']","rw [continuousOn_image_of_leftInvOn, continuousOn_image_of_leftInvOn, continuousOn_image_of_leftInvOn,
  continuousOn_image_of_leftInvOn]"
Mathlib/Probability/Distributions/Uniform.lean,PMF.toMeasure_uniformOfFintype_apply,toMeasure_uniformOfFintype_apply,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp [uniformOfFintype, hs]
  rfl",error:  no goals to be solved,"theorem toMeasure_uniformOfFintype_apply [MeasurableSpace Î±] (hs : MeasurableSet s) :
    (uniformOfFintype Î±).toMeasure s = Fintype.card s / Fintype.card Î± ",":= by
  simp [uniformOfFintype, hs]","rw [â† uniformOfFintype_apply, uniformOfFintype_apply]"
Mathlib/Logic/Function/Basic.lean,Function.update_apply,update_apply,421c0a9cfd5d69bd3ccd40ea3f2ecf7bfd521648,:=,"error:  unexpected token '@['; expected term
warning:  @HasUncurry.uncurry does not have a doc string","theorem update_apply {Î² : Sort*} (f : Î± â†’ Î²) (a' : Î±) (b : Î²) (a : Î±) :
    update f a' b a = if a = a' then b else f a ",":= by
  rcases Decidable.eq_or_ne a a' with rfl | hne <;> simp [*]",split_ifs with h
Mathlib/RingTheory/FiniteType.lean,AddMonoidAlgebra.freeAlgebra_lift_of_surjective_of_closure,freeAlgebra_lift_of_surjective_of_closure,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  intro f
  induction' f using induction_on with m f g ihf ihg r f ih
  Â· have : m âˆˆ closure S := hS.symm â–¸ mem_top _
    refine AddSubmonoid.closure_induction this (fun m hm => ?_) ??_ _
    Â· exact âŸ¨FreeAlgebra.Î¹ R âŸ¨m, hmâŸ©, FreeAlgebra.lift_Î¹_apply _ _âŸ©
    Â· exact âŸ¨1, AlgHom.map_one _âŸ©
    Â· rintro mâ‚ mâ‚‚ âŸ¨Pâ‚, hPâ‚âŸ© âŸ¨Pâ‚‚, hPâ‚‚âŸ©
      exact
        âŸ¨Pâ‚ * Pâ‚‚, by
          rw [AlgHom.map_mul, hPâ‚, hPâ‚‚, of_apply, of_apply, of_apply, single_mul_single,
            one_mul]; rflâŸ©
  Â· rcases ihf with âŸ¨P, rflâŸ©
    rcases ihg with âŸ¨Q, rflâŸ©
    exact âŸ¨P + Q, AlgHom.map_add _ _ _âŸ©
  Â· rcases ih with âŸ¨P, rflâŸ©
    exact âŸ¨r â€¢ P, AlgHom.map_smul _ _ _âŸ©","error:  unexpected token '?'; expected '_' or identifier
error:  unsolved goals
case hadd
R : Type u_1
M : Type u_2
instâœÂ¹ : AddMonoid M
instâœ : CommSemiring R
S : Set M
hS : closure S = âŠ¤
f g : R[M]
ihf : âˆƒ a, ((FreeAlgebra.lift R) fun s â†¦ of' R M â†‘s) a = f
ihg : âˆƒ a, ((FreeAlgebra.lift R) fun s â†¦ of' R M â†‘s) a = g
âŠ¢ âˆƒ a, ((FreeAlgebra.lift R) fun s â†¦ of' R M â†‘s) a = f + g

case hsmul
R : Type u_1
M : Type u_2
instâœÂ¹ : AddMonoid M
instâœ : CommSemiring R
S : Set M
hS : closure S = âŠ¤
r : R
f : R[M]
ih : âˆƒ a, ((FreeAlgebra.lift R) fun s â†¦ of' R M â†‘s) a = f
âŠ¢ âˆƒ a, ((FreeAlgebra.lift R) fun s â†¦ of' R M â†‘s) a = r â€¢ f","theorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}
    (hS : closure S = âŠ¤) :
    Function.Surjective
      (FreeAlgebra.lift R fun s : S => of' R M â†‘s : FreeAlgebra R S â†’ R[M]) ",":= by
  intro f
  induction' f using induction_on with m f g ihf ihg r f ih
  Â· have : m âˆˆ closure S := hS.symm â–¸ mem_top _
    refine AddSubmonoid.closure_induction this (fun m hm => ?_) ?_ ?_
    Â· exact âŸ¨FreeAlgebra.Î¹ R âŸ¨m, hmâŸ©, FreeAlgebra.lift_Î¹_apply _ _âŸ©
    Â· exact âŸ¨1, AlgHom.map_one _âŸ©
    Â· rintro mâ‚ mâ‚‚ âŸ¨Pâ‚, hPâ‚âŸ© âŸ¨Pâ‚‚, hPâ‚‚âŸ©
      exact
        âŸ¨Pâ‚ * Pâ‚‚, by
          rw [AlgHom.map_mul, hPâ‚, hPâ‚‚, of_apply, of_apply, of_apply, single_mul_single,
            one_mul]; rflâŸ©
  Â· rcases ihf with âŸ¨P, rflâŸ©
    rcases ihg with âŸ¨Q, rflâŸ©
    exact âŸ¨P + Q, AlgHom.map_add _ _ _âŸ©
  Â· rcases ih with âŸ¨P, rflâŸ©
    exact âŸ¨r â€¢ P, AlgHom.map_smul _ _ _âŸ©",apply FreeAlgebra.lift_surjective_of_surjective
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOn,hasFDerivAt_of_tendstoUniformlyOn,56d6c36569bfa5f38809662c438716c5f84ec909,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  â€–(f' n.1 x - g' x) (n.2 - x)â€– â‰¤ â€–f' n.1 x - g' xâ€– * â€–n.2 - xâ€– : Prop
but is expected to have type
  â€–(f' n.1 x - g' x) (n.2 - x)â€– â‰¤ â€–(Prod.map (fun n â†¦ g' x - f' n x) id n).1â€– * â€–x - n.2â€– : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ğ“ x))
    (hf : âˆ€á¶  n : Î¹ Ã— E in l Ã—Ë¢ ğ“ x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : âˆ€á¶  y in ğ“ x, Tendsto (fun n => f n y) l (ğ“ (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","refine theorem_hasFDerivAt_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_of_tendstoUniformlyOnFilter_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOn hasFDerivAt_contin"
Mathlib/RingTheory/MvPowerSeries/Basic.lean,MvPowerSeries.X_pow_eq,X_pow_eq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' n with n ih
  Â· simp
  Â· rw [pow_succ, ih, Nat.succ_eq_add_one, Finsupp.single_add, X, monomial_mul_monomial, one_mul]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ
Ïƒ : Type u_1
R : Type u_2
instâœ : Semiring R
s : Ïƒ
n : â„•
ih : X s ^ n = (monomial R (single s n)) 1
âŠ¢ (monomial R (single s n)) 1 * X s = (monomial R (single s (n + 1))) 1
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated",theorem X_pow_eq (s : Ïƒ) (n : â„•) : (X s : MvPowerSeries Ïƒ R) ^ n = monomial R (single s n) 1 ,":= by
  induction' n with n ih
  Â· simp
  Â· rw [pow_succ, ih, Finsupp.single_add, X, monomial_mul_monomial, one_mul]","simp only [X_pow_eq, monomial, X_pow_eq, monomial]"
Mathlib/LinearAlgebra/Basis.lean,Basis.maximal,maximal,5068808d2b4c25cf905cf7fee10ded8e447c2346,":= fun w hi h => by
  apply le_antisymm h
  intro x p
  by_contra q
  have e := b.total_repr x
  let u : Î¹ â†ª w :=
    âŸ¨fun i => âŸ¨b i, h âŸ¨i, rflâŸ©âŸ©, fun i i' r =>
      b.injective (by simpa only [Subtype.mk_eq_mk] using r)âŸ©
  simp_rw [Finsupp.total_apply] at e
  replace e : ((b.repr x).sum fun (i : Î¹) (a : R) â†¦ a â€¢ (u i : M)) =
      ((âŸ¨x, pâŸ© : w) : M) := e
  rw [â† Finsupp.sum_embDomain (f := u) (g := fun x r â†¦ r â€¢ (x : M)), â† Finsupp.total_apply] at e
  refine' hi.total_ne_of_not_mem_support _ _ e
  simp only [Finset.mem_map, Finsupp.support_embDomain]
  rintro âŸ¨j, -, WâŸ©
  simp only [Embedding.coeFn_mk, Subtype.mk_eq_mk] at W
  apply q âŸ¨j, WâŸ©",error:  simp made no progress,theorem maximal [Nontrivial R] (b : Basis Î¹ R M) : b.linearIndependent.Maximal ,":= fun w hi h => by
  apply le_antisymm h
  intro x p
  by_contra q
  have e := b.total_repr x
  let u : Î¹ â†ª w :=
    âŸ¨fun i => âŸ¨b i, h âŸ¨i, rflâŸ©âŸ©, fun i i' r =>
      b.injective (by simpa only [Subtype.mk_eq_mk] using r)âŸ©
  simp_rw [Finsupp.total_apply] at e
  change ((b.repr x).sum fun (i : Î¹) (a : R) â†¦ a â€¢ (u i : M)) = ((âŸ¨x, pâŸ© : w) : M) at e
  rw [â† Finsupp.sum_embDomain (f := u) (g := fun x r â†¦ r â€¢ (x : M)), â† Finsupp.total_apply] at e
  refine hi.total_ne_of_not_mem_support _ ?_ e
  simp only [Finset.mem_map, Finsupp.support_embDomain]
  rintro âŸ¨j, -, WâŸ©
  simp only [u, Embedding.coeFn_mk, Subtype.mk_eq_mk] at W
  apply q âŸ¨j, WâŸ©",apply linearIndependent_maximal
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.factor_Î´_spec,factor_Î´_spec,d7f8050468d4e16195b721085d9c4536194abc3e,":= by
  apply Hom.ext
  ext k : 2
  specialize hj k
  rw [Ne.def, ext_iff] at hj
  dsimp [factor_Î´, Î´, Ïƒ, succAbove, predAbove]
  split <;> rename_i h0j
  all_goals
  Â· split <;> rename_i hjk <;>
    simp only [â† val_fin_lt,
      coe_castSucc, coe_pred, coe_castLT, succ_pred, castSucc_castLT] at h0j hjk âŠ¢
    Â· rw [if_neg]; omega
    Â· rw [if_pos]; omega","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.85724 â†’ ?m.85724 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.85726
case a.h.h
m n : â„•
f : [m] âŸ¶ [n + 1]
j : Fin (n + 2)
k : Fin ([m].len + 1)
hj : (Hom.toOrderHom f) k â‰  j
âŠ¢ (Hom.toOrderHom (factor_Î´ f j â‰« Î´ j)) k = (Hom.toOrderHom f) k","lemma factor_Î´_spec {m n : â„•} (f : ([m] : SimplexCategory) âŸ¶ [n+1]) (j : Fin (n+2))
    (hj : âˆ€ (k : Fin (m+1)), f.toOrderHom k â‰  j) :
    factor_Î´ f j â‰« Î´ j = f ",":= by
  ext k : 3
  specialize hj k
  dsimp [factor_Î´, Î´, Ïƒ]
  cases' j using cases with j
  Â· rw [predAbove_of_le_castSucc _ _ (zero_le _), castPred_zero, predAbove_of_castSucc_lt 0 _
    (castSucc_zero â–¸ pos_of_ne_zero hj),
    zero_succAbove, succ_pred]
  Â· rw [predAbove_of_castSucc_lt 0 _ (castSucc_zero â–¸ succ_pos _), pred_succ]
    rcases hj.lt_or_lt with (hj | hj)
    Â· rw [predAbove_of_le_castSucc j _]
      swap
      Â· exact (le_castSucc_iff.mpr hj)
      Â· rw [succAbove_of_castSucc_lt]
        swap
        Â· rwa [castSucc_lt_succ_iff, castPred_le_iff, le_castSucc_iff]
        rw [castSucc_castPred]
    Â· rw [predAbove_of_castSucc_lt]
      swap
      Â· exact (castSucc_lt_succ _).trans hj
      rw [succAbove_of_le_castSucc]
      swap
      Â· rwa [succ_le_castSucc_iff, lt_pred_iff]
      rw [succ_pred]","simp only [factor_Î´_spec, factor_Î´_spec_assoc, factor_Î´_spec_assoc,
  factor_Î´_spec_assoc, factor_Î´_spec_assoc]"
Mathlib/LinearAlgebra/Matrix/Hermitian.lean,Matrix.isHermitian_add_transpose_self,isHermitian_add_transpose_self,1c643aca968064296312bf5328c84d0c50cfe5ae,":=
  IsSelfAdjoint.add_star_self A","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsSelfAdjoint
has type
  ?m.17948 â†’ Prop",theorem isHermitian_add_transpose_self (A : Matrix n n Î±) : (A + Aá´´).IsHermitian ,":=
  isSelfAdjoint_add_star_self A","rw [IsHermitian, IsHermitian, IsHermitian]"
Mathlib/RingTheory/Smooth/Basic.lean,Algebra.FormallySmooth.of_isLocalization,of_isLocalization,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  constructor
  intro Q _ _ I e f
  sorry","warning:  declaration uses 'sorry'
error:  function expected at
  of_isLocalization
term has type
  FormallySmooth ?m.132502 ?m.132503
error:  function expected at
  FormallySmooth.of_isLocalization
term has type
  FormallySmooth ?m.138010 ?m.138011",theorem of_isLocalization : FormallySmooth R Râ‚˜ ,":= by
  constructor
  intro Q _ _ I e f
  have : âˆ€ x : M, IsUnit (algebraMap R Q x) := by
    intro x
    apply (IsNilpotent.isUnit_quotient_mk_iff âŸ¨2, eâŸ©).mp
    convert (IsLocalization.map_units Râ‚˜ x).map f
    simp only [Ideal.Quotient.mk_algebraMap, AlgHom.commutes]
  let this : Râ‚˜ â†’â‚[R] Q :=
    { IsLocalization.lift this with commutes' := IsLocalization.lift_eq this }
  use this
  apply AlgHom.coe_ringHom_injective
  refine IsLocalization.ringHom_ext M ?_
  ext
  simp",heorem of_isLocalization : FormallySmooth R Râ‚˜ := of_isLocalization
Mathlib/MeasureTheory/Measure/Restrict.lean,MeasureTheory.Measure.restrict_le_self,restrict_le_self,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  Measure.le_iff.2 fun t ht => calc
    Î¼.restrict s t = Î¼ (t âˆ© s) := restrict_apply ht
    _ â‰¤ Î¼ t := measure_mono <| inter_subset_left t s","error:  application type mismatch
  inter_subset_left t
argument
  t
has type
  Set Î± : Type u_2
but is expected to have type
  ?m.14144 âˆˆ ?m.14142 âˆ© ?m.14143 : Prop",theorem restrict_le_self : Î¼.restrict s â‰¤ Î¼ ,":=
  Measure.le_iff.2 fun t ht => calc
    Î¼.restrict s t = Î¼ (t âˆ© s) := restrict_apply ht
    _ â‰¤ Î¼ t := measure_mono inter_subset_left",rw [restrict_restrict_le_self]
Mathlib/Topology/Algebra/Valuation.lean,Valuation.subgroups_basis,subgroups_basis,916c75c1d9f2fcdcd11d5d5b32f69afcc94bb9c4,":=
  { inter := by
      rintro Î³â‚€ Î³â‚
      use min Î³â‚€ Î³â‚
      simp [Valuation.ltAddSubgroup]
      tauto
    mul := by
      rintro Î³
      cases' exists_square_le Î³ with Î³â‚€ h
      use Î³â‚€
      rintro - âŸ¨r, s, r_in, s_in, rflâŸ©
      calc
        (v (r * s) : Î“â‚€) = v r * v s := Valuation.map_mul _ _ _
        _ < Î³â‚€ * Î³â‚€ := (mul_lt_mulâ‚€ r_in s_in)
        _ â‰¤ Î³ := by exact_mod_cast h
    leftMul := by
      rintro x Î³
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | âŸ¨Î³x, HxâŸ©)
      Â· use (1 : Î“â‚€Ë£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, MulZeroClass.zero_mul]
        exact Units.zero_lt Î³
      Â· use Î³xâ»Â¹ * Î³
        rintro y (vy_lt : v y < â†‘(Î³xâ»Â¹ * Î³))
        change (v (x * y) : Î“â‚€) < Î³
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mulâ‚€ vy_lt
    rightMul := by
      rintro x Î³
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | âŸ¨Î³x, HxâŸ©)
      Â· use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, MulZeroClass.mul_zero]
        exact Units.zero_lt Î³
      Â· use Î³xâ»Â¹ * Î³
        rintro y (vy_lt : v y < â†‘(Î³xâ»Â¹ * Î³))
        change (v (y * x) : Î“â‚€) < Î³
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mulâ‚€ vy_lt }","error:  application type mismatch
  v s
argument
  s
has type
  r âˆˆ â†‘(v.ltAddSubgroup Î³â‚€) : Prop
but is expected to have type
  R : Type u
error:  invalid 'calc' step, failed to synthesize `Trans` instance
  Trans LT.lt Membership.mem ?m.35107
use `set_option diagnostics true` to get diagnostic information",theorem subgroups_basis : RingSubgroupsBasis fun Î³ : Î“â‚€Ë£ => (v.ltAddSubgroup Î³ : AddSubgroup R) ,":=
  { inter := by
      rintro Î³â‚€ Î³â‚
      use min Î³â‚€ Î³â‚
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro Î³
      cases' exists_square_le Î³ with Î³â‚€ h
      use Î³â‚€
      rintro - âŸ¨r, r_in, s, s_in, rflâŸ©
      calc
        (v (r * s) : Î“â‚€) = v r * v s := Valuation.map_mul _ _ _
        _ < Î³â‚€ * Î³â‚€ := mul_lt_mulâ‚€ r_in s_in
        _ â‰¤ Î³ := mod_cast h
    leftMul := by
      rintro x Î³
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | âŸ¨Î³x, HxâŸ©)
      Â· use (1 : Î“â‚€Ë£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt Î³
      Â· use Î³xâ»Â¹ * Î³
        rintro y (vy_lt : v y < â†‘(Î³xâ»Â¹ * Î³))
        change (v (x * y) : Î“â‚€) < Î³
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mulâ‚€ vy_lt
    rightMul := by
      rintro x Î³
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | âŸ¨Î³x, HxâŸ©)
      Â· use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt Î³
      Â· use Î³xâ»Â¹ * Î³
        rintro y (vy_lt : v y < â†‘(Î³xâ»Â¹ * Î³))
        change (v (y * x) : Î“â‚€) < Î³
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mulâ‚€ vy_lt }",refine RingSubgroupsBasis.ext fun Î³ => ?_
Mathlib/Algebra/BigOperators/Finsupp.lean,Finsupp.prod_fintype,prod_fintype,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.prod_eq_prod_fintype f h",error:  unknown identifier 'DFinsupp.prod_eq_prod_fintype',"theorem prod_fintype [Fintype Î±] (f : Î± â†’â‚€ M) (g : Î± â†’ M â†’ N) (h : âˆ€ i, g i 0 = 1) :
    f.prod g = âˆ i, g i (f i) ",":=
  f.prod_of_support_subset (subset_univ _) g fun x _ => h x","simp only [Finsupp.prod, Finsupp.prod, Finsupp.prod, h]"
Mathlib/MeasureTheory/SetSemiring.lean,MeasureTheory.IsSetSemiring.pairwiseDisjoint_diffFinsetâ‚€,pairwiseDisjoint_diffFinsetâ‚€,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  classical
  simp only [diffFinsetâ‚€, coe_sdiff, coe_singleton]
  exact Set.PairwiseDisjoint.subset
    (hC.exists_disjoint_finset_diff_eq hs hI).choose_spec.choose_spec.choose (Set.diff_subset _ _)","error:  invalid field 'choose_spec', the environment does not contain 'And.choose_spec'
  Exists.choose_spec (exists_disjoint_finset_diff_eq hC hs hI)
has type
  â†‘â‹¯.choose âŠ† C âˆ§ (â†‘â‹¯.choose).PairwiseDisjoint id âˆ§ s \ â‹ƒâ‚€ â†‘I = â‹ƒâ‚€ â†‘â‹¯.choose
error:  function expected at
  diff_subset ?m.22673
term has type
  ?m.22672 âˆˆ ?m.22670
error:  unsolved goals
Î± : Type u_1
C : Set (Set Î±)
s t : Set Î±
I : Finset (Set Î±)
hC : IsSetSemiring C
hs : s âˆˆ C
hI : â†‘I âŠ† C
âŠ¢ (â†‘â‹¯.choose \ {âˆ…}).PairwiseDisjoint id","lemma pairwiseDisjoint_diffFinsetâ‚€ (hC : IsSetSemiring C) (hs : s âˆˆ C) (hI : â†‘I âŠ† C) :
    PairwiseDisjoint (hC.diffFinsetâ‚€ hs hI : Set (Set Î±)) id ",":= by
  classical
  simp only [diffFinsetâ‚€, coe_sdiff, coe_singleton]
  exact Set.PairwiseDisjoint.subset
    (hC.exists_disjoint_finset_diff_eq hs hI).choose_spec.2.1 diff_subset",simp onlemma pairwiseDisjoint_diffFinsetâ‚€ hC hs hI hI
Mathlib/Algebra/Lie/CartanExists.lean,LieAlgebra.engel_isBot_of_isMin,engel_isBot_of_isMin,2d8928f07c222f171d2f9371935aa5b8359f9d44,":= by
  rcases E with âŸ¨_, x, hxU, rflâŸ©
  rintro âŸ¨_, y, hyU, rflâŸ©
  set Ex : {engel K x | x âˆˆ U} := âŸ¨engel K x, x, hxU, rflâŸ©
  set Ey : {engel K y | y âˆˆ U} := âŸ¨engel K y, y, hyU, rflâŸ©
  replace hUle : U â‰¤ Ex := hUle
  replace hmin : âˆ€ E, E â‰¤ Ex â†’ Ex â‰¤ E := @hmin
  let E : LieSubmodule K U L :=
  { engel K x with
    lie_mem := by rintro âŸ¨u, huâŸ© y hy; exact (engel K x).lie_mem (hUle hu) hy }
  obtain rfl|hxâ‚€ := eq_or_ne x 0
  Â· simpa [Ex, Ey] using hmin Ey
  let Q := L â§¸ E
  let r := finrank K E
  obtain hr|hr : r = finrank K L âˆ¨ r < finrank K L := (Submodule.finrank_le _).eq_or_lt
  Â· suffices engel K y â‰¤ engel K x from hmin Ey this
    suffices engel K x = âŠ¤ by simp_rw [this, le_top]
    apply LieSubalgebra.to_submodule_injective
    apply Submodule.eq_top_of_finrank_eq hr
  set x' : U := âŸ¨x, hxUâŸ©
  set y' : U := âŸ¨y, hyUâŸ©
  let u : U := y' - x'
  let Ï‡ : Polynomial (K[X]) := lieCharpoly K E x' u
  let Ïˆ : Polynomial (K[X]) := lieCharpoly K Q x' u
  suffices Ï‡ = X ^ r by
    apply_fun (fun p â†¦ p.map (evalRingHom 1)) at this
    simp_rw [Polynomial.map_pow, map_X, Ï‡, lieCharpoly_map_eval, one_smul, u, sub_add_cancel,
      r, LinearMap.charpoly_eq_X_pow_iff,
      Subtype.ext_iff, coe_toEndomorphism_pow, ZeroMemClass.coe_zero] at this
    intro z hz
    rw [mem_engel_iff]
    exact this âŸ¨z, hzâŸ©
  suffices âˆ€ i < r, Ï‡.coeff i = 0 by
    simp_rw [r, â† lieCharpoly_natDegree K E x' u] at this âŠ¢
    rw [(lieCharpoly_monic K E x' u).eq_X_pow_iff_natDegree_le_natTrailingDegree]
    exact le_natTrailingDegree (lieCharpoly_monic K E x' u).ne_zero this
  intro i hi
  obtain rfl|hi0 := eq_or_ne i 0
  Â· 
    apply eq_zero_of_forall_eval_zero_of_natDegree_lt_card _ _ ?deg
    case deg =>
      apply lt_of_lt_of_le _ hLK
      rw [Nat.cast_lt]
      apply lt_of_le_of_lt _ hr
      apply lieCharpoly_coeff_natDegree _ _ _ _ 0 r (zero_add r)
    intro Î±
    rw [â† coe_evalRingHom, â† coeff_map, lieCharpoly_map_eval,
      â† constantCoeff_apply, LinearMap.charpoly_constantCoeff_eq_zero_iff]
    let z := Î± â€¢ u + x'
    obtain hzâ‚€|hzâ‚€ := eq_or_ne z 0
    Â· 
      refine âŸ¨âŸ¨x, self_mem_engel K xâŸ©, ?_, ?_âŸ©
      Â· simpa [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero] using hxâ‚€
      Â· dsimp only [z] at hzâ‚€
        simp only [coe_bracket_of_module, hzâ‚€, LieHom.map_zero, LinearMap.zero_apply]
    refine âŸ¨âŸ¨z, hUle z.2âŸ©, ?_, ?_âŸ©
    Â· simpa only [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero, Subtype.ext_iff] using hzâ‚€
    Â· show â…z, _â† = (0 : E)
      ext
      exact lie_self z.1
  have hÏˆ : constantCoeff Ïˆ â‰  0 := by
    intro H
    obtain âŸ¨z, hz0, hxzâŸ© : âˆƒ z : Q, z â‰  0 âˆ§ â…x', zâ† = 0 := by
      apply_fun (evalRingHom 0) at H
      rw [constantCoeff_apply, â† coeff_map, lieCharpoly_map_eval,
        â† constantCoeff_apply, map_zero, LinearMap.charpoly_constantCoeff_eq_zero_iff] at H
      simpa only [coe_bracket_of_module, ne_eq, zero_smul, zero_add, toEndomorphism_apply_apply]
        using H
    apply hz0
    obtain âŸ¨z, rflâŸ© := LieSubmodule.Quotient.surjective_mk' E z
    have : â…x, zâ† âˆˆ E := by rwa [â† LieSubmodule.Quotient.mk_eq_zero']
    simp only [coe_bracket_of_module, LieSubmodule.mem_mk_iff', mem_coe_submodule, mem_engel_iff,
      LieSubmodule.Quotient.mk'_apply, LieSubmodule.Quotient.mk_eq_zero', E, Q] at this âŠ¢
    obtain âŸ¨n, hnâŸ© := this
    use n+1
    rwa [pow_succ]
  obtain âŸ¨s, hs, hsÏˆâŸ© : âˆƒ s : Finset K, r â‰¤ s.card âˆ§ âˆ€ Î± âˆˆ s, (constantCoeff Ïˆ).eval Î± â‰  0 := by
    classical
    let t := (constantCoeff Ïˆ).roots.toFinset
    have ht : t.card â‰¤ finrank K L - r := by
      refine (Multiset.toFinset_card_le _).trans ?_
      refine (card_roots' _).trans ?_
      rw [constantCoeff_apply]
      apply lieCharpoly_coeff_natDegree
      suffices finrank K Q + r = finrank K L by rw [â† this, zero_add, Nat.add_sub_cancel]
      apply Submodule.finrank_quotient_add_finrank
    obtain âŸ¨s, hsâŸ© := exists_finset_le_card K _ hLK
    use s \ t
    refine âŸ¨?_, ?_âŸ©
    Â· refine le_trans ?_ (Finset.le_card_sdiff _ _)
      omega
    Â· intro Î± hÎ±
      simp only [Finset.mem_sdiff, Multiset.mem_toFinset, mem_roots', IsRoot.def, not_and, t] at hÎ±
      exact hÎ±.2 hÏˆ
  apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero' _ s _ ?hcard
  case hcard =>
    apply lt_of_le_of_lt (lieCharpoly_coeff_natDegree _ _ _ _ i (r - i) _)
    Â· omega
    Â· dsimp only [r] at hi âŠ¢
      rw [Nat.add_sub_cancel' hi.le]
  intro Î± hÎ±
  rw [â† coe_evalRingHom, â† coeff_map, lieCharpoly_map_eval,
    (LinearMap.charpoly_eq_X_pow_iff _).mpr, coeff_X_pow, if_neg hi.ne]
  let v := Î± â€¢ u + x'
  suffices engel K (v : L) â‰¤ engel K x by
    replace this : engel K x â‰¤ engel K (v : L) := (hmin âŸ¨_, v, v.2, rflâŸ© this).ge
    intro z
    simpa only [mem_engel_iff, Subtype.ext_iff, coe_toEndomorphism_pow] using this z.2
  intro z hz
  show z âˆˆ E
  rw [â† LieSubmodule.Quotient.mk_eq_zero]
  set z' : Q := LieSubmodule.Quotient.mk' E z
  have hz' : âˆƒ n : â„•, (toEndomorphism K U Q v ^ n) z' = 0 := by
    rw [mem_engel_iff] at hz
    obtain âŸ¨n, hnâŸ© := hz
    use n
    apply_fun LieSubmodule.Quotient.mk' E at hn
    rw [LieModuleHom.map_zero] at hn
    rw [â† hn]
    clear hn
    induction n with
    | zero => simp only [Nat.zero_eq, pow_zero, LinearMap.one_apply]
    | succ n ih => rw [pow_succ', pow_succ', LinearMap.mul_apply, ih]; rfl
  classical
  set n := Nat.find hz' with _hn
  have hn : (toEndomorphism K U Q v ^ n) z' = 0 := Nat.find_spec hz'
  obtain hnâ‚€|âŸ¨k, hkâŸ© : n = 0 âˆ¨ âˆƒ k, n = k + 1 := by cases n <;> simp
  Â· simpa only [hnâ‚€, pow_zero, LinearMap.one_apply] using hn
  specialize hsÏˆ Î± hÎ±
  rw [â† coe_evalRingHom, constantCoeff_apply, â† coeff_map, lieCharpoly_map_eval,
    â† constantCoeff_apply, ne_eq, LinearMap.charpoly_constantCoeff_eq_zero_iff] at hsÏˆ
  contrapose! hsÏˆ
  use (toEndomorphism K U Q v ^ k) z'
  refine âŸ¨?_, ?_âŸ©
  Â· 
    apply Nat.find_min hz'; omega
  Â· rw [â† hn, hk, pow_succ', LinearMap.mul_apply]","error:  unknown identifier 'coe_toEndomorphism_pow'
error:  simp made no progress
error:  unknown identifier 'toEndomorphism_apply_apply'
error:  unknown identifier 'coe_toEndomorphism_pow'
error:  type mismatch
  hâœ
has type
  âˆƒ n, ((ad K L) â†‘v ^ n) â†‘z = 0 : Prop
but is expected to have type
  âˆƒ n, â†‘(((toEnd K â†¥U â†¥(engel K x).toSubmodule) (Î± â€¢ u + x') ^ n) z) = â†‘0 : Prop
error:  unknown identifier 'toEndomorphism'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  0
case h
K : Type u_1
L : Type u_2
instâœÂ³ : Field K
instâœÂ² : LieRing L
instâœÂ¹ : LieAlgebra K L
instâœ : Module.Finite K L
hLK : â†‘(finrank K L) â‰¤ #K
U : LieSubalgebra K L
x : L
hxU : x âˆˆ U
y : L
hyU : y âˆˆ U
Ex : â†‘{x | âˆƒ x_1 âˆˆ U, engel K x_1 = x} := âŸ¨engel K x, â‹¯âŸ©
Ey : â†‘{x | âˆƒ y âˆˆ U, engel K y = x} := âŸ¨engel K y, â‹¯âŸ©
hUle : U â‰¤ â†‘Ex
hmin : âˆ€ E â‰¤ Ex, Ex â‰¤ E
E : LieSubmodule K (â†¥U) L :=
  let __src := engel K x;
  { toSubmodule := __src.toSubmodule, lie_mem := â‹¯ }
hxâ‚€ : x â‰  0
Q : Type u_2 := L â§¸ E
r : â„• := finrank K â†¥â†‘E
hr : r < finrank K L
x' : â†¥U := âŸ¨x, hxUâŸ©
y' : â†¥U := âŸ¨y, hyUâŸ©
u : â†¥U := y' - x'
Ï‡ : K[X][X] := LieAlgebra.engel_isBot_of_isMin.lieCharpoly K (â†¥â†‘E) x' u
Ïˆ : K[X][X] := LieAlgebra.engel_isBot_of_isMin.lieCharpoly K Q x' u
i : â„•
hi : i < r
hi0 : i â‰  0
hÏˆ : constantCoeff Ïˆ â‰  0
s : Finset K
hs : r â‰¤ s.card
hsÏˆ : âˆ€ Î± âˆˆ s, eval Î± (constantCoeff Ïˆ) â‰  0
Î± : K
hÎ± : Î± âˆˆ s
v : â†¥U := Î± â€¢ u + x'
z : L
z' : Q := (LieSubmodule.Quotient.mk' E) z
n : â„•
hn : (LieSubmodule.Quotient.mk' E) (((ad K L) â†‘v ^ n) z) = 0
âŠ¢ sorryAx â„• true = 0
error:  unknown identifier 'toEndomorphism'
error:  unknown identifier 'toEndomorphism'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  0
case h.refine_2
K : Type u_1
L : Type u_2
instâœÂ³ : Field K
instâœÂ² : LieRing L
instâœÂ¹ : LieAlgebra K L
instâœ : Module.Finite K L
hLK : â†‘(finrank K L) â‰¤ #K
U : LieSubalgebra K L
x : L
hxU : x âˆˆ U
y : L
hyU : y âˆˆ U
Ex : â†‘{x | âˆƒ x_1 âˆˆ U, engel K x_1 = x} := âŸ¨engel K x, â‹¯âŸ©
Ey : â†‘{x | âˆƒ y âˆˆ U, engel K y = x} := âŸ¨engel K y, â‹¯âŸ©
hUle : U â‰¤ â†‘Ex
hmin : âˆ€ E â‰¤ Ex, Ex â‰¤ E
E : LieSubmodule K (â†¥U) L :=
  let __src := engel K x;
  { toSubmodule := __src.toSubmodule, lie_mem := â‹¯ }
hxâ‚€ : x â‰  0
Q : Type u_2 := L â§¸ E
r : â„• := finrank K â†¥â†‘E
hr : r < finrank K L
x' : â†¥U := âŸ¨x, hxUâŸ©
y' : â†¥U := âŸ¨y, hyUâŸ©
u : â†¥U := y' - x'
Ï‡ : K[X][X] := LieAlgebra.engel_isBot_of_isMin.lieCharpoly K (â†¥â†‘E) x' u
Ïˆ : K[X][X] := LieAlgebra.engel_isBot_of_isMin.lieCharpoly K Q x' u
i : â„•
hi : i < r
hi0 : i â‰  0
hÏˆ : constantCoeff Ïˆ â‰  0
s : Finset K
hs : r â‰¤ s.card
Î± : K
hÎ± : Î± âˆˆ s
v : â†¥U := Î± â€¢ u + x'
z : L
hz : z âˆˆ engel K â†‘v
z' : Q := (LieSubmodule.Quotient.mk' E) z
hz' : âˆƒ n, sorryAx â„• true = 0
n : â„• := Nat.find hz'
_hn : n = Nat.find hz'
hn : sorryAx â„• true = 0
k : â„•
hk : n = k + 1
hsÏˆ : z' â‰  0
âŠ¢ ((toEnd K (â†¥U) Q) (Î± â€¢ u + x')) (sorryAx Q true) = 0","lemma engel_isBot_of_isMin (hLK : finrank K L â‰¤ #K) (U : LieSubalgebra K L)
    (E : {engel K x | x âˆˆ U}) (hUle : U â‰¤ E) (hmin : IsMin E) :
    IsBot E ",":= by
  rcases E with âŸ¨_, x, hxU, rflâŸ©
  rintro âŸ¨_, y, hyU, rflâŸ©
  set Ex : {engel K x | x âˆˆ U} := âŸ¨engel K x, x, hxU, rflâŸ©
  set Ey : {engel K y | y âˆˆ U} := âŸ¨engel K y, y, hyU, rflâŸ©
  replace hUle : U â‰¤ Ex := hUle
  replace hmin : âˆ€ E, E â‰¤ Ex â†’ Ex â‰¤ E := @hmin
  let E : LieSubmodule K U L :=
  { engel K x with
    lie_mem := by rintro âŸ¨u, huâŸ© y hy; exact (engel K x).lie_mem (hUle hu) hy }
  obtain rfl|hxâ‚€ := eq_or_ne x 0
  Â· simpa [Ex, Ey] using hmin Ey
  let Q := L â§¸ E
  let r := finrank K E
  obtain hr|hr : r = finrank K L âˆ¨ r < finrank K L := (Submodule.finrank_le _).eq_or_lt
  Â· suffices engel K y â‰¤ engel K x from hmin Ey this
    suffices engel K x = âŠ¤ by simp_rw [this, le_top]
    apply LieSubalgebra.to_submodule_injective
    apply Submodule.eq_top_of_finrank_eq hr
  set x' : U := âŸ¨x, hxUâŸ©
  set y' : U := âŸ¨y, hyUâŸ©
  let u : U := y' - x'
  let Ï‡ : Polynomial (K[X]) := lieCharpoly K E x' u
  let Ïˆ : Polynomial (K[X]) := lieCharpoly K Q x' u
  suffices Ï‡ = X ^ r by
    apply_fun (fun p â†¦ p.map (evalRingHom 1)) at this
    simp_rw [Polynomial.map_pow, map_X, Ï‡, lieCharpoly_map_eval, one_smul, u, sub_add_cancel,
      r, LinearMap.charpoly_eq_X_pow_iff,
      Subtype.ext_iff, coe_toEnd_pow _ _ _ E, ZeroMemClass.coe_zero] at this
    intro z hz
    rw [mem_engel_iff]
    exact this âŸ¨z, hzâŸ©
  suffices âˆ€ i < r, Ï‡.coeff i = 0 by
    simp_rw [r, â† lieCharpoly_natDegree K E x' u] at this âŠ¢
    rw [(lieCharpoly_monic K E x' u).eq_X_pow_iff_natDegree_le_natTrailingDegree]
    exact le_natTrailingDegree (lieCharpoly_monic K E x' u).ne_zero this
  intro i hi
  obtain rfl|hi0 := eq_or_ne i 0
  Â· 
    apply eq_zero_of_forall_eval_zero_of_natDegree_lt_card _ _ ?deg
    case deg =>
      apply lt_of_lt_of_le _ hLK
      rw [Nat.cast_lt]
      apply lt_of_le_of_lt _ hr
      apply lieCharpoly_coeff_natDegree _ _ _ _ 0 r (zero_add r)
    intro Î±
    rw [â† coe_evalRingHom, â† coeff_map, lieCharpoly_map_eval,
      â† constantCoeff_apply, LinearMap.charpoly_constantCoeff_eq_zero_iff]
    let z := Î± â€¢ u + x'
    obtain hzâ‚€|hzâ‚€ := eq_or_ne z 0
    Â· 
      refine âŸ¨âŸ¨x, self_mem_engel K xâŸ©, ?_, ?_âŸ©
      Â· simpa [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero] using hxâ‚€
      Â· dsimp only [z] at hzâ‚€
        simp only [coe_bracket_of_module, hzâ‚€, LieHom.map_zero, LinearMap.zero_apply]
    refine âŸ¨âŸ¨z, hUle z.2âŸ©, ?_, ?_âŸ©
    Â· simpa only [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero, Subtype.ext_iff] using hzâ‚€
    Â· show â…z, _â† = (0 : E)
      ext
      exact lie_self z.1
  have hÏˆ : constantCoeff Ïˆ â‰  0 := by
    intro H
    obtain âŸ¨z, hz0, hxzâŸ© : âˆƒ z : Q, z â‰  0 âˆ§ â…x', zâ† = 0 := by
      apply_fun (evalRingHom 0) at H
      rw [constantCoeff_apply, â† coeff_map, lieCharpoly_map_eval,
        â† constantCoeff_apply, map_zero, LinearMap.charpoly_constantCoeff_eq_zero_iff] at H
      simpa only [coe_bracket_of_module, ne_eq, zero_smul, zero_add, toEnd_apply_apply]
        using H
    apply hz0
    obtain âŸ¨z, rflâŸ© := LieSubmodule.Quotient.surjective_mk' E z
    have : â…x, zâ† âˆˆ E := by rwa [â† LieSubmodule.Quotient.mk_eq_zero']
    simp only [coe_bracket_of_module, LieSubmodule.mem_mk_iff', mem_coe_submodule, mem_engel_iff,
      LieSubmodule.Quotient.mk'_apply, LieSubmodule.Quotient.mk_eq_zero', E, Q] at this âŠ¢
    obtain âŸ¨n, hnâŸ© := this
    use n+1
    rwa [pow_succ]
  obtain âŸ¨s, hs, hsÏˆâŸ© : âˆƒ s : Finset K, r â‰¤ s.card âˆ§ âˆ€ Î± âˆˆ s, (constantCoeff Ïˆ).eval Î± â‰  0 := by
    classical
    let t := (constantCoeff Ïˆ).roots.toFinset
    have ht : t.card â‰¤ finrank K L - r := by
      refine (Multiset.toFinset_card_le _).trans ?_
      refine (card_roots' _).trans ?_
      rw [constantCoeff_apply]
      apply lieCharpoly_coeff_natDegree
      suffices finrank K Q + r = finrank K L by rw [â† this, zero_add, Nat.add_sub_cancel]
      apply Submodule.finrank_quotient_add_finrank
    obtain âŸ¨s, hsâŸ© := exists_finset_le_card K _ hLK
    use s \ t
    refine âŸ¨?_, ?_âŸ©
    Â· refine le_trans ?_ (Finset.le_card_sdiff _ _)
      omega
    Â· intro Î± hÎ±
      simp only [Finset.mem_sdiff, Multiset.mem_toFinset, mem_roots', IsRoot.def, not_and, t] at hÎ±
      exact hÎ±.2 hÏˆ
  apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero' _ s _ ?hcard
  case hcard =>
    apply lt_of_le_of_lt (lieCharpoly_coeff_natDegree _ _ _ _ i (r - i) _)
    Â· omega
    Â· dsimp only [r] at hi âŠ¢
      rw [Nat.add_sub_cancel' hi.le]
  intro Î± hÎ±
  rw [â† coe_evalRingHom, â† coeff_map, lieCharpoly_map_eval,
    (LinearMap.charpoly_eq_X_pow_iff _).mpr, coeff_X_pow, if_neg hi.ne]
  let v := Î± â€¢ u + x'
  suffices engel K (v : L) â‰¤ engel K x by
    replace this : engel K x â‰¤ engel K (v : L) := (hmin âŸ¨_, v, v.2, rflâŸ© this).ge
    intro z
    simpa only [mem_engel_iff, Subtype.ext_iff, coe_toEnd_pow _ _ _ E] using this z.2
  intro z hz
  show z âˆˆ E
  rw [â† LieSubmodule.Quotient.mk_eq_zero]
  set z' : Q := LieSubmodule.Quotient.mk' E z
  have hz' : âˆƒ n : â„•, (toEnd K U Q v ^ n) z' = 0 := by
    rw [mem_engel_iff] at hz
    obtain âŸ¨n, hnâŸ© := hz
    use n
    apply_fun LieSubmodule.Quotient.mk' E at hn
    rw [LieModuleHom.map_zero] at hn
    rw [â† hn]
    clear hn
    induction n with
    | zero => simp only [Nat.zero_eq, pow_zero, LinearMap.one_apply]
    | succ n ih => rw [pow_succ', pow_succ', LinearMap.mul_apply, ih]; rfl
  classical
  set n := Nat.find hz' with _hn
  have hn : (toEnd K U Q v ^ n) z' = 0 := Nat.find_spec hz'
  obtain hnâ‚€|âŸ¨k, hkâŸ© : n = 0 âˆ¨ âˆƒ k, n = k + 1 := by cases n <;> simp
  Â· simpa only [hnâ‚€, pow_zero, LinearMap.one_apply] using hn
  specialize hsÏˆ Î± hÎ±
  rw [â† coe_evalRingHom, constantCoeff_apply, â† coeff_map, lieCharpoly_map_eval,
    â† constantCoeff_apply, ne_eq, LinearMap.charpoly_constantCoeff_eq_zero_iff] at hsÏˆ
  contrapose! hsÏˆ
  use (toEnd K U Q v ^ k) z'
  refine âŸ¨?_, ?_âŸ©
  Â· 
    apply Nat.find_min hz'; omega
  Â· rw [â† hn, hk, pow_succ', LinearMap.mul_apply]",exact IsBot.isBot_of_isMin E
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformly,hasFDerivAt_of_tendstoUniformly,0939faa78a0c4506a8aee4e86b897d6e84c6cb96,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @IsROrC.norm_ofReal ğ•œ _ _, IsROrC.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0); simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Îµ hÎµ).mono fun y hy => _
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  Â· 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",error:  unexpected token ';'; expected '|',"theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ğ“ x))
    (hf : âˆ€á¶  n : Î¹ Ã— E in l Ã—Ë¢ ğ“ x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : âˆ€á¶  y in ğ“ x, Tendsto (fun n => f n y) l (ğ“ (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","refine theorem_hasFDerivAt_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_of_tendstoUniformlyOnFilter_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOn hasFDerivAt_contin"
Mathlib/Data/Nat/Factorial/Basic.lean,Nat.descFactorial_eq_div,descFactorial_eq_div,4ad46d4a6677dcfb96418e03062ff39837a061ae,":= by
  apply mul_left_cancelâ‚€ (factorial_ne_zero (n - k))
  rw [factorial_mul_descFactorial h]
  exact (Nat.mul_div_cancel' <| factorial_dvd_factorial <| Nat.sub_le n k).symm",error:  unknown identifier 'mul_left_cancelâ‚€',theorem descFactorial_eq_div {n k : â„•} (h : k â‰¤ n) : n.descFactorial k = n ! / (n - k)! ,":= by
  apply Nat.mul_left_cancel (n - k).factorial_pos
  rw [factorial_mul_descFactorial h]
  exact (Nat.mul_div_cancel' <| factorial_dvd_factorial <| Nat.sub_le n k).symm","rw [descFactorial_eq_descFactorial, Nat.descFactorial_eq_factorial, descFactorial_eq_descFactorial,
  descFactorial_eq_descFactorial, descFactorial_eq_descFactorial, descFactorial_eq_descFactorial]"
Mathlib/Combinatorics/SetFamily/FourFunctions.lean,holley,holley,8a7d6ba3b03c4b2062f1ce69fca7b9125c7bc032,":= by
  obtain rfl | hf := hf.eq_or_lt
  Â· simp only [Pi.zero_apply, sum_const_zero, eq_comm, Fintype.sum_eq_zero_iff_of_nonneg hg] at hfg
    simp [hfg]
  obtain rfl | hg := hg.eq_or_lt
  Â· simp only [Pi.zero_apply, sum_const_zero, Fintype.sum_eq_zero_iff_of_nonneg hf.le] at hfg
    simp [hfg]
  have := four_functions_theorem g (Î¼ * f) f (Î¼ * g) hg.le (mul_nonneg hÎ¼â‚€ hf.le) hf.le
    (mul_nonneg hÎ¼â‚€ hg.le) (fun a b â†¦ ?_) univ univ
  Â· simpa [hfg, sum_pos hg] using this
  Â· simp_rw [Pi.mul_apply, mul_left_comm _ (Î¼ _), mul_comm (g _)]
    rw [sup_comm, inf_comm]
    exact mul_le_mul (hÎ¼ le_sup_left) (h _ _) (mul_nonneg (hf.le _) <| hg.le _) <| hÎ¼â‚€ _","error:  failed to synthesize
  DecidableEq Î±
use `set_option diagnostics true` to get diagnostic information
error:  simp made no progress","lemma holley (hÎ¼â‚€ : 0 â‰¤ Î¼) (hf : 0 â‰¤ f) (hg : 0 â‰¤ g) (hÎ¼ : Monotone Î¼)
    (hfg : âˆ‘ a, f a = âˆ‘ a, g a) (h : âˆ€ a b, f a * g b â‰¤ f (a âŠ“ b) * g (a âŠ” b)) :
    âˆ‘ a, Î¼ a * f a â‰¤ âˆ‘ a, Î¼ a * g a ",":= by
  classical
  obtain rfl | hf := hf.eq_or_lt
  Â· simp only [Pi.zero_apply, sum_const_zero, eq_comm, Fintype.sum_eq_zero_iff_of_nonneg hg] at hfg
    simp [hfg]
  obtain rfl | hg := hg.eq_or_lt
  Â· simp only [Pi.zero_apply, sum_const_zero, Fintype.sum_eq_zero_iff_of_nonneg hf.le] at hfg
    simp [hfg]
  have := four_functions_theorem g (Î¼ * f) f (Î¼ * g) hg.le (mul_nonneg hÎ¼â‚€ hf.le) hf.le
    (mul_nonneg hÎ¼â‚€ hg.le) (fun a b â†¦ ?_) univ univ
  Â· simpa [hfg, sum_pos hg] using this
  Â· simp_rw [Pi.mul_apply, mul_left_comm _ (Î¼ _), mul_comm (g _)]
    rw [sup_comm, inf_comm]
    exact mul_le_mul (hÎ¼ le_sup_left) (h _ _) (mul_nonneg (hf.le _) <| hg.le _) <| hÎ¼â‚€ _","simp_rw [â† hfg, â† hfg, â† hfg]"
Mathlib/MeasureTheory/Integral/Lebesgue.lean,MeasureTheory.lintegral_sum_measure,lintegral_sum_measure,46192548b739a832ab4063cf2549354a922755ef,":= by
  simp only [lintegral, iSup_subtype', SimpleFunc.lintegral_sum, ENNReal.tsum_eq_iSup_sum]
  rw [iSup_comm]
  congr; funext s
  induction' s with i s hi hs
  Â· simp
  simp only [Finset.sum_insert hi, â† hs]
  refine (ENNReal.iSup_add_iSup ?_).symm
  intro Ï† Ïˆ
  exact
    âŸ¨âŸ¨Ï† âŠ” Ïˆ, fun x => sup_le (Ï†.2 x) (Ïˆ.2 x)âŸ©,
      add_le_add (SimpleFunc.lintegral_mono le_sup_left le_rfl)
        (Finset.sum_le_sum fun j _ => SimpleFunc.lintegral_mono le_sup_right le_rfl)âŸ©","warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
error:  unsolved goals
case e_s.h.mk
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Î´ : Type u_4
mâœ : MeasurableSpace Î±
Î¼âœ Î½ : Measure Î±
m : MeasurableSpace Î±
Î¹ : Type u_5
f : Î± â†’ â„â‰¥0âˆ
Î¼ : Î¹ â†’ Measure Î±
i : Multiset Î¹
s : i.Nodup
âŠ¢ â¨† i_1, (Multiset.map (fun i â†¦ (â†‘i_1).lintegral (Î¼ i)) i).sum =
    (Multiset.map (fun i â†¦ â¨† x, (â†‘x).lintegral (Î¼ i)) i).sum
error:  no goals to be solved","theorem lintegral_sum_measure {m : MeasurableSpace Î±} {Î¹} (f : Î± â†’ â„â‰¥0âˆ) (Î¼ : Î¹ â†’ Measure Î±) :
    âˆ«â» a, f a âˆ‚Measure.sum Î¼ = âˆ‘' i, âˆ«â» a, f a âˆ‚Î¼ i ",":= by
  simp only [lintegral, iSup_subtype', SimpleFunc.lintegral_sum, ENNReal.tsum_eq_iSup_sum]
  rw [iSup_comm]
  congr; funext s
  induction' s using Finset.induction_on with i s hi hs
  Â· simp
  simp only [Finset.sum_insert hi, â† hs]
  refine (ENNReal.iSup_add_iSup ?_).symm
  intro Ï† Ïˆ
  exact
    âŸ¨âŸ¨Ï† âŠ” Ïˆ, fun x => sup_le (Ï†.2 x) (Ïˆ.2 x)âŸ©,
      add_le_add (SimpleFunc.lintegral_mono le_sup_left le_rfl)
        (Finset.sum_le_sum fun j _ => SimpleFunc.lintegral_mono le_sup_right le_rfl)âŸ©","simp only [lintegral_sum_measure, lintegral_sum_measure]"
Mathlib/MeasureTheory/Function/AEMeasurableOrder.lean,MeasureTheory.aemeasurable_of_exist_almost_disjoint_supersets,MeasureTheory.aemeasurable_of_exist_almost_disjoint_supersets,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  haveI : Encodable s := s_count.toEncodable
  have h' : âˆ€ p q, âˆƒ u v, MeasurableSet u âˆ§ MeasurableSet v âˆ§
      { x | f x < p } âŠ† u âˆ§ { x | q < f x } âŠ† v âˆ§ (p âˆˆ s â†’ q âˆˆ s â†’ p < q â†’ Î¼ (u âˆ© v) = 0) := by
    intro p q
    by_cases H : p âˆˆ s âˆ§ q âˆˆ s âˆ§ p < q
    Â· rcases h p H.1 q H.2.1 H.2.2 with âŸ¨u, v, hu, hv, h'u, h'v, hÎ¼âŸ©
      exact âŸ¨u, v, hu, hv, h'u, h'v, fun _ _ _ => hÎ¼âŸ©
    Â· refine
        âŸ¨univ, univ, MeasurableSet.univ, MeasurableSet.univ, subset_univ _, subset_univ _,
          fun ps qs pq => ?_âŸ©
      simp only [not_and] at H
      exact (H ps qs pq).elim
  choose! u v huv using h'
  let u' : Î² â†’ Set Î± := fun p => â‹‚ q âˆˆ s âˆ© Ioi p, u p q
  have u'_meas : âˆ€ i, MeasurableSet (u' i) := by
    intro i
    exact MeasurableSet.biInter (s_count.mono (inter_subset_left _ _)) fun b _ => (huv i b).1
  let f' : Î± â†’ Î² := fun x => â¨… i : s, piecewise (u' i) (fun _ => (i : Î²)) (fun _ => (âŠ¤ : Î²)) x
  have f'_meas : Measurable f' := by
    apply measurable_iInf
    exact fun i => Measurable.piecewise (u'_meas i) measurable_const measurable_const
  let t := â‹ƒ (p : s) (q : â†¥(s âˆ© Ioi p)), u' p âˆ© v p q
  have Î¼t : Î¼ t â‰¤ 0 :=
    calc
      Î¼ t â‰¤ âˆ‘' (p : s) (q : â†¥(s âˆ© Ioi p)), Î¼ (u' p âˆ© v p q) := by
        refine (measure_iUnion_le _).trans ?_
        refine ENNReal.tsum_le_tsum fun p => ?_
        haveI := (s_count.mono (inter_subset_left _ (Ioi â†‘p))).to_subtype
        apply measure_iUnion_le
      _ â‰¤ âˆ‘' (p : s) (q : â†¥(s âˆ© Ioi p)), Î¼ (u p q âˆ© v p q) := by
        gcongr with p q
        exact biInter_subset_of_mem q.2
      _ = âˆ‘' (p : s) (_ : â†¥(s âˆ© Ioi p)), (0 : â„â‰¥0âˆ) := by
        congr
        ext1 p
        congr
        ext1 q
        exact (huv p q).2.2.2.2 p.2 q.2.1 q.2.2
      _ = 0 := by simp only [tsum_zero]
  have ff' : âˆ€áµ x âˆ‚Î¼, f x = f' x := by
    have : âˆ€áµ x âˆ‚Î¼, x âˆ‰ t := by
      have : Î¼ t = 0 := le_antisymm Î¼t bot_le
      change Î¼ _ = 0
      convert this
      ext y
      simp only [not_exists, exists_prop, mem_setOf_eq, mem_compl_iff, not_not_mem]
    filter_upwards [this] with x hx
    apply (iInf_eq_of_forall_ge_of_forall_gt_exists_lt _ _).symm
    Â· intro i
      by_cases H : x âˆˆ u' i
      swap
      Â· simp only [H, le_top, not_false_iff, piecewise_eq_of_not_mem]
      simp only [H, piecewise_eq_of_mem]
      contrapose! hx
      obtain âŸ¨r, âŸ¨xr, rqâŸ©, rsâŸ© : âˆƒ r, r âˆˆ Ioo (i : Î²) (f x) âˆ© s :=
        dense_iff_inter_open.1 s_dense (Ioo i (f x)) isOpen_Ioo (nonempty_Ioo.2 hx)
      have A : x âˆˆ v i r := (huv i r).2.2.2.1 rq
      refine mem_iUnion.2 âŸ¨i, ?_âŸ©
      refine mem_iUnion.2 âŸ¨âŸ¨r, âŸ¨rs, xrâŸ©âŸ©, ?_âŸ©
      exact âŸ¨H, AâŸ©
    Â· intro q hq
      obtain âŸ¨r, âŸ¨xr, rqâŸ©, rsâŸ© : âˆƒ r, r âˆˆ Ioo (f x) q âˆ© s :=
        dense_iff_inter_open.1 s_dense (Ioo (f x) q) isOpen_Ioo (nonempty_Ioo.2 hq)
      refine âŸ¨âŸ¨r, rsâŸ©, ?_âŸ©
      have A : x âˆˆ u' r := mem_biInter fun i _ => (huv r i).2.2.1 xr
      simp only [A, rq, piecewise_eq_of_mem, Subtype.coe_mk]
  exact âŸ¨f', f'_meas, ff'âŸ©","error:  function expected at
  inter_subset_left ?m.2313
term has type
  ?m.2312 âˆˆ ?m.2310
error:  function expected at
  inter_subset_left ?m.5366
term has type
  ?m.5365 âˆˆ ?m.5363
error:  unsolved goals
Î± : Type u_1
m : MeasurableSpace Î±
Î¼ : Measure Î±
Î² : Type u_2
instâœâ¶ : CompleteLinearOrder Î²
instâœâµ : DenselyOrdered Î²
instâœâ´ : TopologicalSpace Î²
instâœÂ³ : OrderTopology Î²
instâœÂ² : SecondCountableTopology Î²
instâœÂ¹ : MeasurableSpace Î²
instâœ : BorelSpace Î²
s : Set Î²
s_count : s.Countable
s_dense : Dense s
f : Î± â†’ Î²
h :
  âˆ€ p âˆˆ s,
    âˆ€ q âˆˆ s, p < q â†’ âˆƒ u v, MeasurableSet u âˆ§ MeasurableSet v âˆ§ {x | f x < p} âŠ† u âˆ§ {x | q < f x} âŠ† v âˆ§ Î¼ (u âˆ© v) = 0
this : Encodable â†‘s
u v : Î² â†’ Î² â†’ Set Î±
huv :
  âˆ€ (p q : Î²),
    MeasurableSet (u p q) âˆ§
      MeasurableSet (v p q) âˆ§
        {x | f x < p} âŠ† u p q âˆ§ {x | q < f x} âŠ† v p q âˆ§ (p âˆˆ s â†’ q âˆˆ s â†’ p < q â†’ Î¼ (u p q âˆ© v p q) = 0)
u' : Î² â†’ Set Î± := fun p â†¦ â‹‚ q âˆˆ s âˆ© Ioi p, u p q
u'_meas : âˆ€ (i : Î²), MeasurableSet (u' i)
f' : Î± â†’ Î² := fun x â†¦ â¨… i, (u' â†‘i).piecewise (fun x â†¦ â†‘i) (fun x â†¦ âŠ¤) x
f'_meas : Measurable f'
t : Set Î± := â‹ƒ p, â‹ƒ q, u' â†‘p âˆ© v â†‘p â†‘q
p : â†‘s
âŠ¢ Î¼ (â‹ƒ q, u' â†‘p âˆ© v â†‘p â†‘q) â‰¤ âˆ‘' (q : â†‘(s âˆ© Ioi â†‘p)), Î¼ (u' â†‘p âˆ© v â†‘p â†‘q)","theorem MeasureTheory.aemeasurable_of_exist_almost_disjoint_supersets {Î± : Type*}
    {m : MeasurableSpace Î±} (Î¼ : Measure Î±) {Î² : Type*} [CompleteLinearOrder Î²] [DenselyOrdered Î²]
    [TopologicalSpace Î²] [OrderTopology Î²] [SecondCountableTopology Î²] [MeasurableSpace Î²]
    [BorelSpace Î²] (s : Set Î²) (s_count : s.Countable) (s_dense : Dense s) (f : Î± â†’ Î²)
    (h : âˆ€ p âˆˆ s, âˆ€ q âˆˆ s, p < q â†’ âˆƒ u v, MeasurableSet u âˆ§ MeasurableSet v âˆ§
      { x | f x < p } âŠ† u âˆ§ { x | q < f x } âŠ† v âˆ§ Î¼ (u âˆ© v) = 0) :
    AEMeasurable f Î¼ ",":= by
  haveI : Encodable s := s_count.toEncodable
  have h' : âˆ€ p q, âˆƒ u v, MeasurableSet u âˆ§ MeasurableSet v âˆ§
      { x | f x < p } âŠ† u âˆ§ { x | q < f x } âŠ† v âˆ§ (p âˆˆ s â†’ q âˆˆ s â†’ p < q â†’ Î¼ (u âˆ© v) = 0) := by
    intro p q
    by_cases H : p âˆˆ s âˆ§ q âˆˆ s âˆ§ p < q
    Â· rcases h p H.1 q H.2.1 H.2.2 with âŸ¨u, v, hu, hv, h'u, h'v, hÎ¼âŸ©
      exact âŸ¨u, v, hu, hv, h'u, h'v, fun _ _ _ => hÎ¼âŸ©
    Â· refine
        âŸ¨univ, univ, MeasurableSet.univ, MeasurableSet.univ, subset_univ _, subset_univ _,
          fun ps qs pq => ?_âŸ©
      simp only [not_and] at H
      exact (H ps qs pq).elim
  choose! u v huv using h'
  let u' : Î² â†’ Set Î± := fun p => â‹‚ q âˆˆ s âˆ© Ioi p, u p q
  have u'_meas : âˆ€ i, MeasurableSet (u' i) := by
    intro i
    exact MeasurableSet.biInter (s_count.mono inter_subset_left) fun b _ => (huv i b).1
  let f' : Î± â†’ Î² := fun x => â¨… i : s, piecewise (u' i) (fun _ => (i : Î²)) (fun _ => (âŠ¤ : Î²)) x
  have f'_meas : Measurable f' := by
    apply measurable_iInf
    exact fun i => Measurable.piecewise (u'_meas i) measurable_const measurable_const
  let t := â‹ƒ (p : s) (q : â†¥(s âˆ© Ioi p)), u' p âˆ© v p q
  have Î¼t : Î¼ t â‰¤ 0 :=
    calc
      Î¼ t â‰¤ âˆ‘' (p : s) (q : â†¥(s âˆ© Ioi p)), Î¼ (u' p âˆ© v p q) := by
        refine (measure_iUnion_le _).trans ?_
        refine ENNReal.tsum_le_tsum fun p => ?_
        haveI := (s_count.mono (s.inter_subset_left (t := Ioi â†‘p))).to_subtype
        apply measure_iUnion_le
      _ â‰¤ âˆ‘' (p : s) (q : â†¥(s âˆ© Ioi p)), Î¼ (u p q âˆ© v p q) := by
        gcongr with p q
        exact biInter_subset_of_mem q.2
      _ = âˆ‘' (p : s) (_ : â†¥(s âˆ© Ioi p)), (0 : â„â‰¥0âˆ) := by
        congr
        ext1 p
        congr
        ext1 q
        exact (huv p q).2.2.2.2 p.2 q.2.1 q.2.2
      _ = 0 := by simp only [tsum_zero]
  have ff' : âˆ€áµ x âˆ‚Î¼, f x = f' x := by
    have : âˆ€áµ x âˆ‚Î¼, x âˆ‰ t := by
      have : Î¼ t = 0 := le_antisymm Î¼t bot_le
      change Î¼ _ = 0
      convert this
      ext y
      simp only [not_exists, exists_prop, mem_setOf_eq, mem_compl_iff, not_not_mem]
    filter_upwards [this] with x hx
    apply (iInf_eq_of_forall_ge_of_forall_gt_exists_lt _ _).symm
    Â· intro i
      by_cases H : x âˆˆ u' i
      swap
      Â· simp only [H, le_top, not_false_iff, piecewise_eq_of_not_mem]
      simp only [H, piecewise_eq_of_mem]
      contrapose! hx
      obtain âŸ¨r, âŸ¨xr, rqâŸ©, rsâŸ© : âˆƒ r, r âˆˆ Ioo (i : Î²) (f x) âˆ© s :=
        dense_iff_inter_open.1 s_dense (Ioo i (f x)) isOpen_Ioo (nonempty_Ioo.2 hx)
      have A : x âˆˆ v i r := (huv i r).2.2.2.1 rq
      refine mem_iUnion.2 âŸ¨i, ?_âŸ©
      refine mem_iUnion.2 âŸ¨âŸ¨r, âŸ¨rs, xrâŸ©âŸ©, ?_âŸ©
      exact âŸ¨H, AâŸ©
    Â· intro q hq
      obtain âŸ¨r, âŸ¨xr, rqâŸ©, rsâŸ© : âˆƒ r, r âˆˆ Ioo (f x) q âˆ© s :=
        dense_iff_inter_open.1 s_dense (Ioo (f x) q) isOpen_Ioo (nonempty_Ioo.2 hq)
      refine âŸ¨âŸ¨r, rsâŸ©, ?_âŸ©
      have A : x âˆˆ u' r := mem_biInter fun i _ => (huv r i).2.2.1 xr
      simp only [A, rq, piecewise_eq_of_mem, Subtype.coe_mk]
  exact âŸ¨f', f'_meas, ff'âŸ©",apply aemeasurable_of_exist_almost_disjoint_supersets f
Mathlib/Analysis/SpecialFunctions/CompareExp.lean,Complex.IsExpCmpFilter.isLittleO_log_abs_re,isLittleO_log_abs_re,3b4737b3b07aa77aaa08420241e83ad9c46eda8a,":=
  calc
    (fun z => Real.log (abs z)) =O[l] fun z =>
        Real.log (Real.sqrt 2) + Real.log (max z.re (|z.im|)) :=
      IsBigO.of_bound 1 <|
        (hl.tendsto_re.eventually_ge_atTop 1).mono fun z hz => by
          have h2 : 0 < Real.sqrt 2 := by simp
          have hz' : 1 â‰¤ abs z := hz.trans (re_le_abs z)
          have _ : 0 < abs z := one_pos.trans_le hz'
          have hmâ‚€ : 0 < max z.re (|z.im|) := lt_max_iff.2 (Or.inl <| one_pos.trans_le hz)
          rw [one_mul, Real.norm_eq_abs, _root_.abs_of_nonneg (Real.log_nonneg hz')]
          refine' le_trans _ (le_abs_self _)
          rw [â† Real.log_mul, Real.log_le_log, â† _root_.abs_of_nonneg (le_trans zero_le_one hz)]
          exacts [abs_le_sqrt_two_mul_max z, one_pos.trans_le hz', mul_pos h2 hmâ‚€, h2.ne', hmâ‚€.ne']
    _ =o[l] re :=
      IsLittleO.add (isLittleO_const_left.2 <| Or.inr <| hl.tendsto_abs_re) <|
        isLittleO_iff_nat_mul_le.2 fun n => by
          filter_upwards [isLittleO_iff_nat_mul_le'.1 hl.isLittleO_log_re_re n,
            hl.abs_im_pow_eventuallyLE_exp_re n,
            hl.tendsto_re.eventually_gt_atTop 1] with z hre him hâ‚
          cases' le_total (|z.im|) z.re with hle hle
          Â· rwa [max_eq_left hle]
          Â· have H : 1 < |z.im| := hâ‚.trans_le hle
            norm_cast at *
            rwa [max_eq_right hle, Real.norm_eq_abs, Real.norm_eq_abs, abs_of_pos (Real.log_pos H),
              â† Real.log_pow, Real.log_le_iff_le_exp (pow_pos (one_pos.trans H) _),
              abs_of_pos (one_pos.trans hâ‚)]","error:  tactic 'rewrite' failed, equality or iff proof expected
  Real.log ?m.14247 â‰¤ Real.log ?m.14248
l : Filter â„‚
hl : IsExpCmpFilter l
z : â„‚
hz : 1 â‰¤ z.re
h2 : 0 < âˆš2
hz' : 1 â‰¤ abs z
xâœ : 0 < abs z
hmâ‚€ : 0 < max z.re |z.im|
âŠ¢ Real.log (abs z) â‰¤ Real.log (âˆš2 * max z.re |z.im|)",theorem isLittleO_log_abs_re (hl : IsExpCmpFilter l) : (fun z => Real.log (abs z)) =o[l] re ,":=
  calc
    (fun z => Real.log (abs z)) =O[l] fun z => Real.log (âˆš2) + Real.log (max z.re |z.im|) :=
      IsBigO.of_bound 1 <|
        (hl.tendsto_re.eventually_ge_atTop 1).mono fun z hz => by
          have h2 : 0 < âˆš2 := by simp
          have hz' : 1 â‰¤ abs z := hz.trans (re_le_abs z)
          have hmâ‚€ : 0 < max z.re |z.im| := lt_max_iff.2 (Or.inl <| one_pos.trans_le hz)
          rw [one_mul, Real.norm_eq_abs, _root_.abs_of_nonneg (Real.log_nonneg hz')]
          refine le_trans ?_ (le_abs_self _)
          rw [â† Real.log_mul, Real.log_le_log_iff, â† _root_.abs_of_nonneg (le_trans zero_le_one hz)]
          exacts [abs_le_sqrt_two_mul_max z, one_pos.trans_le hz', mul_pos h2 hmâ‚€, h2.ne', hmâ‚€.ne']
    _ =o[l] re :=
      IsLittleO.add (isLittleO_const_left.2 <| Or.inr <| hl.tendsto_abs_re) <|
        isLittleO_iff_nat_mul_le.2 fun n => by
          filter_upwards [isLittleO_iff_nat_mul_le'.1 hl.isLittleO_log_re_re n,
            hl.abs_im_pow_eventuallyLE_exp_re n,
            hl.tendsto_re.eventually_gt_atTop 1] with z hre him hâ‚
          rcases le_total |z.im| z.re with hle | hle
          Â· rwa [max_eq_left hle]
          Â· have H : 1 < |z.im| := hâ‚.trans_le hle
            norm_cast at *
            rwa [max_eq_right hle, Real.norm_eq_abs, Real.norm_eq_abs, abs_of_pos (Real.log_pos H),
              â† Real.log_pow, Real.log_le_iff_le_exp (pow_pos (one_pos.trans H) _),
              abs_of_pos (one_pos.trans hâ‚)]",rw [isLittleO_log_abs_re] at hl
Mathlib/Algebra/Algebra/Quasispectrum.lean,spectrum_subset_quasispectrum,spectrum_subset_quasispectrum,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  quasispectrum_eq_spectrum_union R a â–¸ Set.subset_union_left _ _","error:  function expected at
  Set.subset_union_left ?m.188598
term has type
  ?m.188597 âˆˆ ?m.188595 âˆª ?m.188596","lemma spectrum_subset_quasispectrum (R : Type*) {A : Type*} [CommSemiring R] [Ring A] [Algebra R A]
    (a : A) : spectrum R a âŠ† quasispectrum R a ",":=
  quasispectrum_eq_spectrum_union R a â–¸ Set.subset_union_left",apply quasispectrum_subset_quasispectrum_spectrum_subset_quasispectrum
Mathlib/MeasureTheory/Measure/Hausdorff.lean,HolderOnWith.hausdorffMeasure_image_le,hausdorffMeasure_image_le,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine' iSup_le fun R => iSup_le fun hR => _
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine' ENNReal.tsum_le_tsum fun n => _
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left s) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set X : Type u_2
but is expected to have type
  ?m.169595 âˆˆ t n âˆ© ?m.169594 : Prop
error:  simp made no progress","theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s ",":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","rw [â† hausdorffMeasure_image_le, hausdorffMeasure_image_le, hausdorffMeasure_image_le]"
Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean,jacobiSym.mod_right',mod_right',2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  rcases eq_or_ne a 0 with (rfl | haâ‚€)
  Â· rw [mul_zero, mod_zero]
  have hb' : Odd (b % (4 * a)) := hb.mod_even (Even.mul_right (by norm_num) _)
  rcases exists_eq_pow_mul_and_not_dvd haâ‚€ 2 (by norm_num) with âŸ¨e, a', haâ‚', haâ‚‚âŸ©
  have haâ‚ := odd_iff.mpr (two_dvd_ne_zero.mp haâ‚')
  nth_rw 2 [haâ‚‚]; nth_rw 1 [haâ‚‚]
  rw [Nat.cast_mul, mul_left, mul_left, quadratic_reciprocity' haâ‚ hb,
    quadratic_reciprocity' haâ‚ hb', Nat.cast_pow, pow_left, pow_left, Nat.cast_two, at_two hb,
    at_two hb']
  congr 1; swap; congr 1
  Â· simp_rw [qrSign]
    rw [Ï‡â‚„_nat_mod_four, Ï‡â‚„_nat_mod_four (b % (4 * a)), mod_mod_of_dvd b (dvd_mul_right 4 a)]
  Â· rw [mod_left â†‘(b % _), mod_left b, Int.coe_nat_mod, Int.emod_emod_of_dvd b]
    simp only [haâ‚‚, Nat.cast_mul, â† mul_assoc]
    exact dvd_mul_left (a' : â„¤) (â†‘4 * â†‘(2 ^ e))
  cases' e with e; Â· rfl
  Â· rw [Ï‡â‚ˆ_nat_mod_eight, Ï‡â‚ˆ_nat_mod_eight (b % (4 * a)), mod_mod_of_dvd b]
    use 2 ^ e * a'; rw [haâ‚‚, Nat.pow_succ]; ring","warning:  jacobiSym does not have a doc string
error:  unsolved goals
a b : â„•
hb : Odd b
haâ‚€ : a â‰  0
âŠ¢ Even 4
error:  unknown constant 'Int.coe_nat_mod'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.71657
case inr.intro.intro.intro.e_a.e_a
a b : â„•
hb : Odd b
haâ‚€ : a â‰  0
hb' : Odd (b % (4 * a))
e a' : â„•
haâ‚' : Â¬2 âˆ£ a'
haâ‚‚ : a = 2 ^ e * a'
haâ‚ : Odd a'
âŠ¢ J(â†‘b % â†‘a' | a') = J(â†‘(b % (4 * a)) % â†‘a' | a')",theorem mod_right' (a : â„•) {b : â„•} (hb : Odd b) : J(a | b) = J(a | b % (4 * a)) ,":= by
  rcases eq_or_ne a 0 with (rfl | haâ‚€)
  Â· rw [mul_zero, mod_zero]
  have hb' : Odd (b % (4 * a)) := hb.mod_even (Even.mul_right (by decide) _)
  rcases exists_eq_pow_mul_and_not_dvd haâ‚€ 2 (by norm_num) with âŸ¨e, a', haâ‚', haâ‚‚âŸ©
  have haâ‚ := odd_iff.mpr (two_dvd_ne_zero.mp haâ‚')
  nth_rw 2 [haâ‚‚]; nth_rw 1 [haâ‚‚]
  rw [Nat.cast_mul, mul_left, mul_left, quadratic_reciprocity' haâ‚ hb,
    quadratic_reciprocity' haâ‚ hb', Nat.cast_pow, pow_left, pow_left, Nat.cast_two, at_two hb,
    at_two hb']
  congr 1; swap;
  Â· congr 1
    Â· simp_rw [qrSign]
      rw [Ï‡â‚„_nat_mod_four, Ï‡â‚„_nat_mod_four (b % (4 * a)), mod_mod_of_dvd b (dvd_mul_right 4 a)]
    Â· rw [mod_left â†‘(b % _), mod_left b, Int.natCast_mod, Int.emod_emod_of_dvd b]
      simp only [haâ‚‚, Nat.cast_mul, â† mul_assoc]
      apply dvd_mul_left
  cases' e with e; Â· rfl
  Â· rw [Ï‡â‚ˆ_nat_mod_eight, Ï‡â‚ˆ_nat_mod_eight (b % (4 * a)), mod_mod_of_dvd b]
    use 2 ^ e * a'; rw [haâ‚‚, Nat.pow_succ]; ring",rw [â† mod_right'_eq_j(a : Odd b)]
Mathlib/Probability/Variance.lean,ProbabilityTheory.IndepFun.variance_sum,IndepFun.variance_sum,525ae9d15817f1ed908335d2ed89b534c3cbd387,":= by
  classical
  induction' s using Finset.induction_on with k s ks IH
  Â· simp only [Finset.sum_empty, variance_zero]
  rw [variance_def' (memâ„’p_finset_sum' _ hs), sum_insert ks, sum_insert ks]
  simp only [add_sq']
  calc
    ğ”¼[X k ^ 2 + (âˆ‘ i âˆˆ s, X i) ^ 2 + 2 * X k * âˆ‘ i âˆˆ s, X i] - ğ”¼[X k + âˆ‘ i âˆˆ s, X i] ^ 2 =
        ğ”¼[X k ^ 2] + ğ”¼[(âˆ‘ i âˆˆ s, X i) ^ 2] + ğ”¼[2 * X k * âˆ‘ i âˆˆ s, X i] -
          (ğ”¼[X k] + ğ”¼[âˆ‘ i âˆˆ s, X i]) ^ 2 := by
      rw [integral_add', integral_add', integral_add']
      Â· exact Memâ„’p.integrable one_le_two (hs _ (mem_insert_self _ _))
      Â· apply integrable_finset_sum' _ fun i hi => ?_
        exact Memâ„’p.integrable one_le_two (hs _ (mem_insert_of_mem hi))
      Â· exact Memâ„’p.integrable_sq (hs _ (mem_insert_self _ _))
      Â· apply Memâ„’p.integrable_sq
        exact memâ„’p_finset_sum' _ fun i hi => hs _ (mem_insert_of_mem hi)
      Â· apply Integrable.add
        Â· exact Memâ„’p.integrable_sq (hs _ (mem_insert_self _ _))
        Â· apply Memâ„’p.integrable_sq
          exact memâ„’p_finset_sum' _ fun i hi => hs _ (mem_insert_of_mem hi)
      Â· rw [mul_assoc]
        apply Integrable.const_mul _ (2 : â„)
        simp only [mul_sum, sum_apply, Pi.mul_apply]
        apply integrable_finset_sum _ fun i hi => ?_
        apply IndepFun.integrable_mul _ (Memâ„’p.integrable one_le_two (hs _ (mem_insert_self _ _)))
          (Memâ„’p.integrable one_le_two (hs _ (mem_insert_of_mem hi)))
        apply h (mem_insert_self _ _) (mem_insert_of_mem hi)
        exact fun hki => ks (hki.symm â–¸ hi)
    _ = Var[X k] + Var[âˆ‘ i âˆˆ s, X i] +
        (ğ”¼[2 * X k * âˆ‘ i âˆˆ s, X i] - 2 * ğ”¼[X k] * ğ”¼[âˆ‘ i âˆˆ s, X i]) := by
      rw [variance_def' (hs _ (mem_insert_self _ _)),
        variance_def' (memâ„’p_finset_sum' _ fun i hi => hs _ (mem_insert_of_mem hi))]
      ring
    _ = Var[X k] + Var[âˆ‘ i âˆˆ s, X i] := by
      simp_rw [Pi.mul_apply, Pi.ofNat_apply, Nat.cast_ofNat, sum_apply, mul_sum, mul_assoc,
        add_right_eq_self]
      rw [integral_finset_sum s fun i hi => ?_]; swap
      Â· apply Integrable.const_mul _ (2 : â„)
        apply IndepFun.integrable_mul _ (Memâ„’p.integrable one_le_two (hs _ (mem_insert_self _ _)))
          (Memâ„’p.integrable one_le_two (hs _ (mem_insert_of_mem hi)))
        apply h (mem_insert_self _ _) (mem_insert_of_mem hi)
        exact fun hki => ks (hki.symm â–¸ hi)
      rw [integral_finset_sum s fun i hi =>
          Memâ„’p.integrable one_le_two (hs _ (mem_insert_of_mem hi)),
        mul_sum, mul_sum, â† sum_sub_distrib]
      apply Finset.sum_eq_zero fun i hi => ?_
      rw [integral_mul_left, IndepFun.integral_mul', sub_self]
      Â· apply h (mem_insert_self _ _) (mem_insert_of_mem hi)
        exact fun hki => ks (hki.symm â–¸ hi)
      Â· exact Memâ„’p.aestronglyMeasurable (hs _ (mem_insert_self _ _))
      Â· exact Memâ„’p.aestronglyMeasurable (hs _ (mem_insert_of_mem hi))
    _ = Var[X k] + âˆ‘ i âˆˆ s, Var[X i] := by
      rw [IH (fun i hi => hs i (mem_insert_of_mem hi))
          (h.mono (by simp only [coe_insert, Set.subset_insert]))]","error:  tactic 'apply' failed, failed to unify
  Integrable (fun a â†¦ âˆ‘ i âˆˆ ?m.121524, ?m.121525 i a) ?m.121521
with
  Integrable (âˆ‘ i âˆˆ s, X k * X i) â„™
Î© : Type u_1
m : MeasurableSpace Î©
Xâœ : Î© â†’ â„
Î¼ : Measure Î©
instâœÂ¹ : MeasureSpace Î©
instâœ : IsProbabilityMeasure â„™
Î¹ : Type u_2
X : Î¹ â†’ Î© â†’ â„
k : Î¹
s : Finset Î¹
ks : k âˆ‰ s
IH :
  (âˆ€ i âˆˆ s, Memâ„’p (X i) 2 â„™) â†’
    ((â†‘s).Pairwise fun i j â†¦ IndepFun (X i) (X j) â„™) â†’ variance (âˆ‘ i âˆˆ s, X i) â„™ = âˆ‘ i âˆˆ s, variance (X i) â„™
hs : âˆ€ i âˆˆ insert k s, Memâ„’p (X i) 2 â„™
h : (â†‘(insert k s)).Pairwise fun i j â†¦ IndepFun (X i) (X j) â„™
âŠ¢ Integrable (âˆ‘ i âˆˆ s, X k * X i) â„™","theorem IndepFun.variance_sum [@IsProbabilityMeasure Î© _ â„™] {Î¹ : Type*} {X : Î¹ â†’ Î© â†’ â„}
    {s : Finset Î¹} (hs : âˆ€ i âˆˆ s, @Memâ„’p _ _ _ (_) (X i) 2 â„™)
    (h : Set.Pairwise â†‘s fun i j => @IndepFun _ _ _ (_) _ _ (X i) (X j) â„™) :
    Var[âˆ‘ i âˆˆ s, X i] = âˆ‘ i âˆˆ s, Var[X i] ",":= by
  classical
  induction' s using Finset.induction_on with k s ks IH
  Â· simp only [Finset.sum_empty, variance_zero]
  rw [variance_def' (memâ„’p_finset_sum' _ hs), sum_insert ks, sum_insert ks]
  simp only [add_sq']
  calc
    ğ”¼[X k ^ 2 + (âˆ‘ i âˆˆ s, X i) ^ 2 + 2 * X k * âˆ‘ i âˆˆ s, X i] - ğ”¼[X k + âˆ‘ i âˆˆ s, X i] ^ 2 =
        ğ”¼[X k ^ 2] + ğ”¼[(âˆ‘ i âˆˆ s, X i) ^ 2] + ğ”¼[2 * X k * âˆ‘ i âˆˆ s, X i] -
          (ğ”¼[X k] + ğ”¼[âˆ‘ i âˆˆ s, X i]) ^ 2 := by
      rw [integral_add', integral_add', integral_add']
      Â· exact Memâ„’p.integrable one_le_two (hs _ (mem_insert_self _ _))
      Â· apply integrable_finset_sum' _ fun i hi => ?_
        exact Memâ„’p.integrable one_le_two (hs _ (mem_insert_of_mem hi))
      Â· exact Memâ„’p.integrable_sq (hs _ (mem_insert_self _ _))
      Â· apply Memâ„’p.integrable_sq
        exact memâ„’p_finset_sum' _ fun i hi => hs _ (mem_insert_of_mem hi)
      Â· apply Integrable.add
        Â· exact Memâ„’p.integrable_sq (hs _ (mem_insert_self _ _))
        Â· apply Memâ„’p.integrable_sq
          exact memâ„’p_finset_sum' _ fun i hi => hs _ (mem_insert_of_mem hi)
      Â· rw [mul_assoc]
        apply Integrable.const_mul _ (2 : â„)
        rw [mul_sum, sum_fn]
        apply integrable_finset_sum _ fun i hi => ?_
        apply IndepFun.integrable_mul _ (Memâ„’p.integrable one_le_two (hs _ (mem_insert_self _ _)))
          (Memâ„’p.integrable one_le_two (hs _ (mem_insert_of_mem hi)))
        apply h (mem_insert_self _ _) (mem_insert_of_mem hi)
        exact fun hki => ks (hki.symm â–¸ hi)
    _ = Var[X k] + Var[âˆ‘ i âˆˆ s, X i] +
        (ğ”¼[2 * X k * âˆ‘ i âˆˆ s, X i] - 2 * ğ”¼[X k] * ğ”¼[âˆ‘ i âˆˆ s, X i]) := by
      rw [variance_def' (hs _ (mem_insert_self _ _)),
        variance_def' (memâ„’p_finset_sum' _ fun i hi => hs _ (mem_insert_of_mem hi))]
      ring
    _ = Var[X k] + Var[âˆ‘ i âˆˆ s, X i] := by
      simp_rw [Pi.mul_apply, Pi.ofNat_apply, Nat.cast_ofNat, sum_apply, mul_sum, mul_assoc,
        add_right_eq_self]
      rw [integral_finset_sum s fun i hi => ?_]; swap
      Â· apply Integrable.const_mul _ (2 : â„)
        apply IndepFun.integrable_mul _ (Memâ„’p.integrable one_le_two (hs _ (mem_insert_self _ _)))
          (Memâ„’p.integrable one_le_two (hs _ (mem_insert_of_mem hi)))
        apply h (mem_insert_self _ _) (mem_insert_of_mem hi)
        exact fun hki => ks (hki.symm â–¸ hi)
      rw [integral_finset_sum s fun i hi =>
          Memâ„’p.integrable one_le_two (hs _ (mem_insert_of_mem hi)),
        mul_sum, mul_sum, â† sum_sub_distrib]
      apply Finset.sum_eq_zero fun i hi => ?_
      rw [integral_mul_left, IndepFun.integral_mul', sub_self]
      Â· apply h (mem_insert_self _ _) (mem_insert_of_mem hi)
        exact fun hki => ks (hki.symm â–¸ hi)
      Â· exact Memâ„’p.aestronglyMeasurable (hs _ (mem_insert_self _ _))
      Â· exact Memâ„’p.aestronglyMeasurable (hs _ (mem_insert_of_mem hi))
    _ = Var[X k] + âˆ‘ i âˆˆ s, Var[X i] := by
      rw [IH (fun i hi => hs i (mem_insert_of_mem hi))
          (h.mono (by simp only [coe_insert, Set.subset_insert]))]",simp only [Variance.variance_sum]
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.addHaar_image_eq_zero_of_differentiableOn_of_addHaar_eq_zero,addHaar_image_eq_zero_of_differentiableOn_of_addHaar_eq_zero,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  refine' le_antisymm _ (zero_le _)
  have :
      âˆ€ A : E â†’L[â„] E, âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§
        âˆ€ (t : Set E), ApproximatesLinearOn f A t Î´ â†’
          Î¼ (f '' t) â‰¤ (Real.toNNReal |A.det| + 1 : â„â‰¥0) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + 1
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [ENNReal.ofReal, lt_add_iff_pos_right, zero_lt_one, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, h'âŸ©
    exact âŸ¨Î´, h', fun t ht => h t f htâŸ©
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, _, _, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = fderivWithin â„ f s y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s (fderivWithin â„ f s)
      (fun x xs => (hf x xs).hasFDerivWithinAt) Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := (measure_iUnion_le _)
    _ â‰¤ âˆ‘' n, (Real.toNNReal |(A n).det| + 1 : â„â‰¥0) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2
      exact ht n
    _ â‰¤ âˆ‘' n, ((Real.toNNReal |(A n).det| + 1 : â„â‰¥0) : â„â‰¥0âˆ) * 0 := by
      refine' ENNReal.tsum_le_tsum fun n => mul_le_mul_left' _ _
      exact le_trans (measure_mono (inter_subset_left _ _)) (le_of_eq hs)
    _ = 0 := by simp only [tsum_zero, mul_zero]","error:  unsolved goals
E : Type u_1
F : Type u_2
instâœâ· : NormedAddCommGroup E
instâœâ¶ : NormedSpace â„ E
instâœâµ : FiniteDimensional â„ E
instâœâ´ : NormedAddCommGroup F
instâœÂ³ : NormedSpace â„ F
s : Set E
f : E â†’ E
f' : E â†’ E â†’L[â„] E
instâœÂ² : MeasurableSpace E
instâœÂ¹ : BorelSpace E
Î¼ : Measure E
instâœ : Î¼.IsAddHaarMeasure
hf : DifferentiableOn â„ f s
hs : Î¼ s = 0
A : E â†’L[â„] E
m : â„â‰¥0 := |A.det|.toNNReal + 1
âŠ¢ |A.det|.toNNReal < m
error:  function expected at
  inter_subset_left ?m.310754
term has type
  ?m.310753 âˆˆ ?m.310751","theorem addHaar_image_eq_zero_of_differentiableOn_of_addHaar_eq_zero (hf : DifferentiableOn â„ f s)
    (hs : Î¼ s = 0) : Î¼ (f '' s) = 0 ",":= by
  refine le_antisymm ?_ (zero_le _)
  have :
      âˆ€ A : E â†’L[â„] E, âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§
        âˆ€ (t : Set E), ApproximatesLinearOn f A t Î´ â†’
          Î¼ (f '' t) â‰¤ (Real.toNNReal |A.det| + 1 : â„â‰¥0) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + 1
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, zero_lt_one, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, h'âŸ©
    exact âŸ¨Î´, h', fun t ht => h t f htâŸ©
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, _, _, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = fderivWithin â„ f s y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s (fderivWithin â„ f s)
      (fun x xs => (hf x xs).hasFDerivWithinAt) Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Real.toNNReal |(A n).det| + 1 : â„â‰¥0) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2
      exact ht n
    _ â‰¤ âˆ‘' n, ((Real.toNNReal |(A n).det| + 1 : â„â‰¥0) : â„â‰¥0âˆ) * 0 := by
      refine ENNReal.tsum_le_tsum fun n => mul_le_mul_left' ?_ _
      exact le_trans (measure_mono inter_subset_left) (le_of_eq hs)
    _ = 0 := by simp only [tsum_zero, mul_zero]",refine addHaar_image_eq_zero_of_differentiableOn_of_differentiableOn_of_differentiableOn hf hs hs 0 ?_
Mathlib/NumberTheory/SumTwoSquares.lean,Nat.eq_sq_add_sq_iff_eq_sq_mul,Nat.eq_sq_add_sq_iff_eq_sq_mul,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  constructor
  Â· rintro âŸ¨x, y, hâŸ©
    by_cases hxy : x = 0 âˆ§ y = 0
    Â· exact âŸ¨0, 1, by rw [h, hxy.1, hxy.2, zero_pow zero_lt_two, add_zero, zero_mul],
        âŸ¨0, by rw [zero_mul, neg_eq_zero, Fin.one_eq_zero_iff]âŸ©âŸ©
    Â· have hg := Nat.pos_of_ne_zero (mt Nat.gcd_eq_zero_iff.mp hxy)
      obtain âŸ¨g, xâ‚, yâ‚, _, hâ‚‚, hâ‚ƒ, hâ‚„âŸ© := Nat.exists_coprime' hg
      exact âŸ¨g, xâ‚ ^ 2 + yâ‚ ^ 2, by rw [h, hâ‚ƒ, hâ‚„]; ring,
        ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_coprime rfl hâ‚‚âŸ©
  Â· rintro âŸ¨a, b, hâ‚, hâ‚‚âŸ©
    obtain âŸ¨x', y', hâŸ© := Nat.eq_sq_add_sq_of_isSquare_mod_neg_one hâ‚‚
    exact âŸ¨a * x', a * y', by rw [hâ‚, h]; ringâŸ©","error:  application type mismatch
  zero_pow zero_lt_two
argument
  zero_lt_two
has type
  0 < 2 : Prop
but is expected to have type
  ?m.44012 â‰  0 : Prop","theorem Nat.eq_sq_add_sq_iff_eq_sq_mul {n : â„•} :
    (âˆƒ x y : â„•, n = x ^ 2 + y ^ 2) â†” âˆƒ a b : â„•, n = a ^ 2 * b âˆ§ IsSquare (-1 : ZMod b) ",":= by
  constructor
  Â· rintro âŸ¨x, y, hâŸ©
    by_cases hxy : x = 0 âˆ§ y = 0
    Â· exact âŸ¨0, 1, by rw [h, hxy.1, hxy.2, zero_pow two_ne_zero, add_zero, zero_mul],
        âŸ¨0, by rw [zero_mul, neg_eq_zero, Fin.one_eq_zero_iff]âŸ©âŸ©
    Â· have hg := Nat.pos_of_ne_zero (mt Nat.gcd_eq_zero_iff.mp hxy)
      obtain âŸ¨g, xâ‚, yâ‚, _, hâ‚‚, hâ‚ƒ, hâ‚„âŸ© := Nat.exists_coprime' hg
      exact âŸ¨g, xâ‚ ^ 2 + yâ‚ ^ 2, by rw [h, hâ‚ƒ, hâ‚„]; ring,
        ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_coprime rfl hâ‚‚âŸ©
  Â· rintro âŸ¨a, b, hâ‚, hâ‚‚âŸ©
    obtain âŸ¨x', y', hâŸ© := Nat.eq_sq_add_sq_of_isSquare_mod_neg_one hâ‚‚
    exact âŸ¨a * x', a * y', by rw [hâ‚, h]; ringâŸ©",simp only [Nat.eq_sq_add_sq_iff_eq_sq_add_sq_iff_eq_sq_add_sq_iff_eq_sq_mul]
Mathlib/Order/RelClasses.lean,subset_trans,subset_trans,047f73c34cd3e6bae28166f72847965b1a989c70,:= trans,"error:  ambiguous, possible interpretations 
  _root_.trans : a âŠ† b â†’ b âŠ† c â†’ a âŠ† c
  
  Trans.trans : a âŠ† b â†’ b âŠ† c â†’ a âŠ† c",lemma subset_trans [IsTrans Î± (Â· âŠ† Â·)] {a b c : Î±} : a âŠ† b â†’ b âŠ† c â†’ a âŠ† c ,:= _root_.trans,exact Subset.trans subset_trans hsubset_trans hsubset_trans
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean,Embedding.comp_stronglyMeasurable_iff,_root_.Embedding.comp_stronglyMeasurable_iff,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  letI := pseudoMetrizableSpacePseudoMetric Î³
  borelize Î² Î³
  refine'
    âŸ¨fun H => stronglyMeasurable_iff_measurable_separable.2 âŸ¨_, _âŸ©, fun H =>
      hg.continuous.comp_stronglyMeasurable HâŸ©
  Â· let G : Î² â†’ range g := rangeFactorization g
    have hG : ClosedEmbedding G :=
      { hg.codRestrict _ _ with
        closed_range := by
          rw [surjective_onto_range.range_eq]
          exact isClosed_univ }
    have : Measurable (G âˆ˜ f) := Measurable.subtype_mk H.measurable
    exact hG.measurableEmbedding.measurable_comp_iff.1 this
  Â· have : IsSeparable (g â»Â¹' range (g âˆ˜ f)) := hg.isSeparable_preimage H.isSeparable_range
    rwa [range_comp, hg.inj.preimage_image] at this",error:  'closed_range' is not a field of structure 'ClosedEmbedding',"theorem _root_.Embedding.comp_stronglyMeasurable_iff {m : MeasurableSpace Î±} [TopologicalSpace Î²]
    [PseudoMetrizableSpace Î²] [TopologicalSpace Î³] [PseudoMetrizableSpace Î³] {g : Î² â†’ Î³} {f : Î± â†’ Î²}
    (hg : Embedding g) : (StronglyMeasurable fun x => g (f x)) â†” StronglyMeasurable f ",":= by
  letI := pseudoMetrizableSpacePseudoMetric Î³
  borelize Î² Î³
  refine
    âŸ¨fun H => stronglyMeasurable_iff_measurable_separable.2 âŸ¨?_, ?_âŸ©, fun H =>
      hg.continuous.comp_stronglyMeasurable HâŸ©
  Â· let G : Î² â†’ range g := rangeFactorization g
    have hG : ClosedEmbedding G :=
      { hg.codRestrict _ _ with
        isClosed_range := by
          rw [surjective_onto_range.range_eq]
          exact isClosed_univ }
    have : Measurable (G âˆ˜ f) := Measurable.subtype_mk H.measurable
    exact hG.measurableEmbedding.measurable_comp_iff.1 this
  Â· have : IsSeparable (g â»Â¹' range (g âˆ˜ f)) := hg.isSeparable_preimage H.isSeparable_range
    rwa [range_comp, hg.inj.preimage_image] at this",rw [stronglyMeasurable_iff_stronglyMeasurable_iff]
Mathlib/Order/WellFoundedSet.lean,Set.PartiallyWellOrderedOn.partiallyWellOrderedOn_sublistForallâ‚‚,partiallyWellOrderedOn_sublistForallâ‚‚,047f73c34cd3e6bae28166f72847965b1a989c70,":= by
  rcases isEmpty_or_nonempty Î±
  Â· exact subsingleton_of_subsingleton.partiallyWellOrderedOn
  inhabit Î±
  rw [iff_not_exists_isMinBadSeq List.length]
  rintro âŸ¨f, hf1, hf2âŸ©
  have hnil : âˆ€ n, f n â‰  List.nil := fun n con =>
    hf1.2 n n.succ n.lt_succ_self (con.symm â–¸ List.SublistForallâ‚‚.nil)
  have : âˆ€ n, (f n).headI âˆˆ s
  Â· exact fun n => hf1.1 n _ (List.head!_mem_self (hnil n))
  obtain âŸ¨g, hgâŸ© := h.exists_monotone_subseq (fun n => (f n).headI) this
  have hf' :=
    hf2 (g 0) (fun n => if n < g 0 then f n else List.tail (f (g (n - g 0))))
      (fun m hm => (if_pos hm).symm) ?_
  swap;
  Â· simp only [if_neg (lt_irrefl (g 0)), tsub_self]
    rw [List.length_tail, â† Nat.pred_eq_sub_one]
    exact Nat.pred_lt fun con => hnil _ (List.length_eq_zero.1 con)
  rw [IsBadSeq] at hf'
  push_neg at hf'
  obtain âŸ¨m, n, mn, hmnâŸ© := hf' <| fun n x hx => by
    split_ifs at hx with hn
    exacts [hf1.1 _ _ hx, hf1.1 _ _ (List.tail_subset _ hx)]
  by_cases hn : n < g 0
  Â· apply hf1.2 m n mn
    rwa [if_pos hn, if_pos (mn.trans hn)] at hmn
  Â· obtain âŸ¨n', rflâŸ© := exists_add_of_le (not_lt.1 hn)
    rw [if_neg hn, add_comm (g 0) n', add_tsub_cancel_right] at hmn
    split_ifs at hmn with hm
    Â· apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le))
      exact trans hmn (List.tail_sublistForallâ‚‚_self _)
    Â· rw [â† tsub_lt_iff_left (le_of_not_lt hm)] at mn
      apply hf1.2 _ _ (g.lt_iff_lt.2 mn)
      rw [â† List.cons_head!_tail (hnil (g (m - g 0))), â† List.cons_head!_tail (hnil (g n'))]
      exact List.SublistForallâ‚‚.cons (hg _ _ (le_of_lt mn)) hmn","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case inr.intro.intro
Î¹ : Type u_1
Î± : Type u_2
Î² : Type u_3
Î³ : Type u_4
Ï€ : Î¹ â†’ Type u_5
râœ r : Î± â†’ Î± â†’ Prop
instâœÂ¹ : IsRefl Î± r
instâœ : IsTrans Î± r
s : Set Î±
h : s.PartiallyWellOrderedOn r
hâœ : Nonempty Î±
inhabited_h : Inhabited Î±
f : â„• â†’ List Î±
hf1 : IsBadSeq (List.SublistForallâ‚‚ r) {l | âˆ€ x âˆˆ l, x âˆˆ s} f
hf2 : âˆ€ (n : â„•), IsMinBadSeq (List.SublistForallâ‚‚ r) List.length {l | âˆ€ x âˆˆ l, x âˆˆ s} n f
hnil : âˆ€ (n : â„•), f n â‰  []
this : âˆ€ (n : â„•), (f n).headI âˆˆ s
âŠ¢ False","theorem partiallyWellOrderedOn_sublistForallâ‚‚ (r : Î± â†’ Î± â†’ Prop) [IsRefl Î± r] [IsTrans Î± r]
    {s : Set Î±} (h : s.PartiallyWellOrderedOn r) :
    { l : List Î± | âˆ€ x, x âˆˆ l â†’ x âˆˆ s }.PartiallyWellOrderedOn (List.SublistForallâ‚‚ r) ",":= by
  rcases isEmpty_or_nonempty Î±
  Â· exact subsingleton_of_subsingleton.partiallyWellOrderedOn
  inhabit Î±
  rw [iff_not_exists_isMinBadSeq List.length]
  rintro âŸ¨f, hf1, hf2âŸ©
  have hnil : âˆ€ n, f n â‰  List.nil := fun n con =>
    hf1.2 n n.succ n.lt_succ_self (con.symm â–¸ List.SublistForallâ‚‚.nil)
  have : âˆ€ n, (f n).headI âˆˆ s :=
    fun n => hf1.1 n _ (List.head!_mem_self (hnil n))
  obtain âŸ¨g, hgâŸ© := h.exists_monotone_subseq (fun n => (f n).headI) this
  have hf' :=
    hf2 (g 0) (fun n => if n < g 0 then f n else List.tail (f (g (n - g 0))))
      (fun m hm => (if_pos hm).symm) ?_
  swap;
  Â· simp only [if_neg (lt_irrefl (g 0)), Nat.sub_self]
    rw [List.length_tail, â† Nat.pred_eq_sub_one]
    exact Nat.pred_lt fun con => hnil _ (List.length_eq_zero.1 con)
  rw [IsBadSeq] at hf'
  push_neg at hf'
  obtain âŸ¨m, n, mn, hmnâŸ© := hf' fun n x hx => by
    split_ifs at hx with hn
    exacts [hf1.1 _ _ hx, hf1.1 _ _ (List.tail_subset _ hx)]
  by_cases hn : n < g 0
  Â· apply hf1.2 m n mn
    rwa [if_pos hn, if_pos (mn.trans hn)] at hmn
  Â· obtain âŸ¨n', rflâŸ© := Nat.exists_eq_add_of_le (not_lt.1 hn)
    rw [if_neg hn, add_comm (g 0) n', Nat.add_sub_cancel_right] at hmn
    split_ifs at hmn with hm
    Â· apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le))
      exact _root_.trans hmn (List.tail_sublistForallâ‚‚_self _)
    Â· rw [â† Nat.sub_lt_iff_lt_add (le_of_not_lt hm)] at mn
      apply hf1.2 _ _ (g.lt_iff_lt.2 mn)
      rw [â† List.cons_head!_tail (hnil (g (m - g 0))), â† List.cons_head!_tail (hnil (g n'))]
      exact List.SublistForallâ‚‚.cons (hg _ _ (le_of_lt mn)) hmn",apply partiallyWellOrderedOn_sublistForallâ‚‚
Mathlib/MeasureTheory/Measure/VectorMeasure.lean,MeasureTheory.VectorMeasure.restrict_le_restrict_iUnion,restrict_le_restrict_iUnion,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  refine restrict_le_restrict_of_subset_le v w fun a haâ‚ haâ‚‚ => ?_
  have haâ‚ƒ : â‹ƒ n, a âˆ© disjointed f n = a := by
    rwa [â† Set.inter_iUnion, iUnion_disjointed, Set.inter_eq_left]
  have haâ‚„ : Pairwise (Disjoint on fun n => a âˆ© disjointed f n) :=
    (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right
  rw [â† haâ‚ƒ, v.of_disjoint_iUnion_nat _ haâ‚„, w.of_disjoint_iUnion_nat _ haâ‚„]
  Â· refine tsum_le_tsum (fun n => (restrict_le_restrict_iff v w (hfâ‚ n)).1 (hfâ‚‚ n) ?_ ?_) ?_ ?_
    Â· exact haâ‚.inter (MeasurableSet.disjointed hfâ‚ n)
    Â· exact Set.Subset.trans (Set.inter_subset_right _ _) (disjointed_subset _ _)
    Â· refine (v.m_iUnion (fun n => ?_) ?_).summable
      Â· exact haâ‚.inter (MeasurableSet.disjointed hfâ‚ n)
      Â· exact (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right
    Â· refine (w.m_iUnion (fun n => ?_) ?_).summable
      Â· exact haâ‚.inter (MeasurableSet.disjointed hfâ‚ n)
      Â· exact (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right
  Â· intro n
    exact haâ‚.inter (MeasurableSet.disjointed hfâ‚ n)
  Â· exact fun n => haâ‚.inter (MeasurableSet.disjointed hfâ‚ n)","error:  function expected at
  inter_subset_right ?m.242462
term has type
  ?m.242461 âˆˆ ?m.242460
warning:  @VectorMeasure.AbsolutelyContinuous does not have a doc string
warning:  @VectorMeasure.MutuallySingular does not have a doc string","theorem restrict_le_restrict_iUnion {f : â„• â†’ Set Î±} (hfâ‚ : âˆ€ n, MeasurableSet (f n))
    (hfâ‚‚ : âˆ€ n, v â‰¤[f n] w) : v â‰¤[â‹ƒ n, f n] w ",":= by
  refine restrict_le_restrict_of_subset_le v w fun a haâ‚ haâ‚‚ => ?_
  have haâ‚ƒ : â‹ƒ n, a âˆ© disjointed f n = a := by
    rwa [â† Set.inter_iUnion, iUnion_disjointed, Set.inter_eq_left]
  have haâ‚„ : Pairwise (Disjoint on fun n => a âˆ© disjointed f n) :=
    (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right
  rw [â† haâ‚ƒ, v.of_disjoint_iUnion_nat _ haâ‚„, w.of_disjoint_iUnion_nat _ haâ‚„]
  Â· refine tsum_le_tsum (fun n => (restrict_le_restrict_iff v w (hfâ‚ n)).1 (hfâ‚‚ n) ?_ ?_) ?_ ?_
    Â· exact haâ‚.inter (MeasurableSet.disjointed hfâ‚ n)
    Â· exact Set.Subset.trans Set.inter_subset_right (disjointed_subset _ _)
    Â· refine (v.m_iUnion (fun n => ?_) ?_).summable
      Â· exact haâ‚.inter (MeasurableSet.disjointed hfâ‚ n)
      Â· exact (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right
    Â· refine (w.m_iUnion (fun n => ?_) ?_).summable
      Â· exact haâ‚.inter (MeasurableSet.disjointed hfâ‚ n)
      Â· exact (disjoint_disjointed _).mono fun i j => Disjoint.mono inf_le_right inf_le_right
  Â· intro n
    exact haâ‚.inter (MeasurableSet.disjointed hfâ‚ n)
  Â· exact fun n => haâ‚.inter (MeasurableSet.disjointed hfâ‚ n)",refine theorem_restrict_le_restrict_iUnion_of_measurableSet hfâ‚ f hfâ‚ hfâ‚‚ w ?_
Mathlib/GroupTheory/CoprodI.lean,FreeGroup.injective_lift_of_ping_pong,_root_.FreeGroup.injective_lift_of_ping_pong,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  have : FreeGroup.lift a =
      (CoprodI.lift fun i => FreeGroup.lift fun _ => a i).comp
        (@freeGroupEquivCoprodI Î¹).toMonoidHom := by
    ext i
    simp
  rw [this, MonoidHom.coe_comp]
  clear this
  refine Function.Injective.comp ?_ (MulEquiv.injective freeGroupEquivCoprodI)
  show Function.Injective (lift fun i : Î¹ => FreeGroup.lift fun _ => a i)
  let H : Î¹ â†’ Type _ := fun _i => FreeGroup Unit
  let f : âˆ€ i, H i â†’* G := fun i => FreeGroup.lift fun _ => a i
  let X' : Î¹ â†’ Set Î± := fun i => X i âˆª Y i
  apply lift_injective_of_ping_pong f _ X'
  show âˆ€ i, (X' i).Nonempty
  Â· exact fun i => Set.Nonempty.inl (hXnonempty i)
  show Pairwise fun i j => Disjoint (X' i) (X' j)
  Â· intro i j hij
    simp only [X']
    apply Disjoint.union_left <;> apply Disjoint.union_right
    Â· exact hXdisj hij
    Â· exact hXYdisj i j
    Â· exact (hXYdisj j i).symm
    Â· exact hYdisj hij
  show Pairwise fun i j => âˆ€ h : H i, h â‰  1 â†’ f i h â€¢ X' j âŠ† X' i
  Â· rintro i j hij
    refine FreeGroup.freeGroupUnitEquivInt.forall_congr_left'.mpr ?_
    intro n hne1
    change FreeGroup.lift (fun _ => a i) (FreeGroup.of () ^ n) â€¢ X' j âŠ† X' i
    simp only [map_zpow, FreeGroup.lift.of]
    change a i ^ n â€¢ X' j âŠ† X' i
    have hnne0 : n â‰  0 := by
      rintro rfl
      apply hne1
      simp [H]; rfl
    clear hne1
    simp only [X']
    cases' (lt_or_gt_of_ne hnne0).symm with hlt hgt
    Â· have h1n : 1 â‰¤ n := hlt
      calc
        a i ^ n â€¢ X' j âŠ† a i ^ n â€¢ (Y i)á¶œ :=
          smul_set_mono ((hXYdisj j i).union_left <| hYdisj hij.symm).subset_compl_right
        _ âŠ† X i := by
          clear hnne0 hlt
          refine Int.le_induction (P := fun n => a i ^ n â€¢ (Y i)á¶œ âŠ† X i) ?_ ?_ n h1n
          Â· dsimp
            rw [zpow_one]
            exact hX i
          Â· dsimp
            intro n _hle hi
            calc
              a i ^ (n + 1) â€¢ (Y i)á¶œ = (a i ^ n * a i) â€¢ (Y i)á¶œ := by rw [zpow_add, zpow_one]
              _ = a i ^ n â€¢ a i â€¢ (Y i)á¶œ := MulAction.mul_smul _ _ _
              _ âŠ† a i ^ n â€¢ X i := smul_set_mono <| hX i
              _ âŠ† a i ^ n â€¢ (Y i)á¶œ := smul_set_mono (hXYdisj i i).subset_compl_right
              _ âŠ† X i := hi
        _ âŠ† X' i := Set.subset_union_left _ _
    Â· have h1n : n â‰¤ -1 := by
        apply Int.le_of_lt_add_one
        simpa using hgt
      calc
        a i ^ n â€¢ X' j âŠ† a i ^ n â€¢ (X i)á¶œ :=
          smul_set_mono ((hXdisj hij.symm).union_left (hXYdisj i j).symm).subset_compl_right
        _ âŠ† Y i := by
          refine' Int.le_induction_down (P := fun n => a i ^ n â€¢ (X i)á¶œ âŠ† Y i) _ _ _ h1n
          Â· dsimp
            rw [zpow_neg, zpow_one]
            exact hY i
          Â· dsimp
            intro n _ hi
            calc
              a i ^ (n - 1) â€¢ (X i)á¶œ = (a i ^ n * (a i)â»Â¹) â€¢ (X i)á¶œ := by rw [zpow_sub, zpow_one]
              _ = a i ^ n â€¢ (a i)â»Â¹ â€¢ (X i)á¶œ := MulAction.mul_smul _ _ _
              _ âŠ† a i ^ n â€¢ Y i := smul_set_mono <| hY i
              _ âŠ† a i ^ n â€¢ (X i)á¶œ := smul_set_mono (hXYdisj i i).symm.subset_compl_right
              _ âŠ† Y i := hi
        _ âŠ† X' i := Set.subset_union_right _ _
  show _ âˆ¨ âˆƒ i, 3 â‰¤ #(H i)
  Â· inhabit Î¹
    right
    use Inhabited.default
    simp only [H]
    rw [FreeGroup.freeGroupUnitEquivInt.cardinal_eq, Cardinal.mk_denumerable]
    apply le_of_lt
    exact nat_lt_aleph0 3","warning:  `Equiv.forall_congr_left'` has been deprecated, use `Equiv.forall_congr_left` instead
error:  function expected at
  subset_union_left ?m.403394
term has type
  ?m.403393 âˆˆ ?m.403391 âˆª ?m.403392
error:  function expected at
  subset_union_right ?m.412891
term has type
  ?m.412890 âˆˆ ?m.412888 âˆª ?m.412889",theorem _root_.FreeGroup.injective_lift_of_ping_pong : Function.Injective (FreeGroup.lift a) ,":= by
  have : FreeGroup.lift a =
      (CoprodI.lift fun i => FreeGroup.lift fun _ => a i).comp
        (@freeGroupEquivCoprodI Î¹).toMonoidHom := by
    ext i
    simp
  rw [this, MonoidHom.coe_comp]
  clear this
  refine Function.Injective.comp ?_ (MulEquiv.injective freeGroupEquivCoprodI)
  show Function.Injective (lift fun i : Î¹ => FreeGroup.lift fun _ => a i)
  let H : Î¹ â†’ Type _ := fun _i => FreeGroup Unit
  let f : âˆ€ i, H i â†’* G := fun i => FreeGroup.lift fun _ => a i
  let X' : Î¹ â†’ Set Î± := fun i => X i âˆª Y i
  apply lift_injective_of_ping_pong f _ X'
  Â· show âˆ€ i, (X' i).Nonempty
    exact fun i => Set.Nonempty.inl (hXnonempty i)
  Â· show Pairwise fun i j => Disjoint (X' i) (X' j)
    intro i j hij
    simp only [X']
    apply Disjoint.union_left <;> apply Disjoint.union_right
    Â· exact hXdisj hij
    Â· exact hXYdisj i j
    Â· exact (hXYdisj j i).symm
    Â· exact hYdisj hij
  Â· show Pairwise fun i j => âˆ€ h : H i, h â‰  1 â†’ f i h â€¢ X' j âŠ† X' i
    rintro i j hij
    refine FreeGroup.freeGroupUnitEquivInt.forall_congr_left.mpr ?_
    intro n hne1
    change FreeGroup.lift (fun _ => a i) (FreeGroup.of () ^ n) â€¢ X' j âŠ† X' i
    simp only [map_zpow, FreeGroup.lift.of]
    change a i ^ n â€¢ X' j âŠ† X' i
    have hnne0 : n â‰  0 := by
      rintro rfl
      apply hne1
      simp [H]; rfl
    clear hne1
    simp only [X']
    cases' (lt_or_gt_of_ne hnne0).symm with hlt hgt
    Â· have h1n : 1 â‰¤ n := hlt
      calc
        a i ^ n â€¢ X' j âŠ† a i ^ n â€¢ (Y i)á¶œ :=
          smul_set_mono ((hXYdisj j i).union_left <| hYdisj hij.symm).subset_compl_right
        _ âŠ† X i := by
          clear hnne0 hlt
          refine Int.le_induction (P := fun n => a i ^ n â€¢ (Y i)á¶œ âŠ† X i) ?_ ?_ n h1n
          Â· dsimp
            rw [zpow_one]
            exact hX i
          Â· dsimp
            intro n _hle hi
            calc
              a i ^ (n + 1) â€¢ (Y i)á¶œ = (a i ^ n * a i) â€¢ (Y i)á¶œ := by rw [zpow_add, zpow_one]
              _ = a i ^ n â€¢ a i â€¢ (Y i)á¶œ := MulAction.mul_smul _ _ _
              _ âŠ† a i ^ n â€¢ X i := smul_set_mono <| hX i
              _ âŠ† a i ^ n â€¢ (Y i)á¶œ := smul_set_mono (hXYdisj i i).subset_compl_right
              _ âŠ† X i := hi
        _ âŠ† X' i := Set.subset_union_left
    Â· have h1n : n â‰¤ -1 := by
        apply Int.le_of_lt_add_one
        simpa using hgt
      calc
        a i ^ n â€¢ X' j âŠ† a i ^ n â€¢ (X i)á¶œ :=
          smul_set_mono ((hXdisj hij.symm).union_left (hXYdisj i j).symm).subset_compl_right
        _ âŠ† Y i := by
          refine Int.le_induction_down (P := fun n => a i ^ n â€¢ (X i)á¶œ âŠ† Y i) ?_ ?_ _ h1n
          Â· dsimp
            rw [zpow_neg, zpow_one]
            exact hY i
          Â· dsimp
            intro n _ hi
            calc
              a i ^ (n - 1) â€¢ (X i)á¶œ = (a i ^ n * (a i)â»Â¹) â€¢ (X i)á¶œ := by rw [zpow_sub, zpow_one]
              _ = a i ^ n â€¢ (a i)â»Â¹ â€¢ (X i)á¶œ := MulAction.mul_smul _ _ _
              _ âŠ† a i ^ n â€¢ Y i := smul_set_mono <| hY i
              _ âŠ† a i ^ n â€¢ (X i)á¶œ := smul_set_mono (hXYdisj i i).symm.subset_compl_right
              _ âŠ† Y i := hi
        _ âŠ† X' i := Set.subset_union_right
  show _ âˆ¨ âˆƒ i, 3 â‰¤ #(H i)
  inhabit Î¹
  right
  use Inhabited.default
  simp only [H]
  rw [FreeGroup.freeGroupUnitEquivInt.cardinal_eq, Cardinal.mk_denumerable]
  apply le_of_lt
  exact nat_lt_aleph0 3",refinjective_lift_of_injective _root_.FreeGroup.injective_lift_of_injective _root_.FreeGroup.injective_lift_of_injective
Mathlib/Algebra/Order/Field/Power.lean,Odd.zpow_neg_iff,Odd.zpow_neg_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  cases' hn with k hk; simpa only [hk, two_mul] using zpow_bit1_neg_iff","error:  unknown identifier 'zpow_bit1_neg_iff'
warning:  declaration uses 'sorry'
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated",theorem Odd.zpow_neg_iff (hn : Odd n) : a ^ n < 0 â†” a < 0 ,":= by
  refine âŸ¨lt_imp_lt_of_le_imp_le (zpow_nonneg Â· _), fun ha â†¦ ?_âŸ©
  obtain âŸ¨k, rflâŸ© := hn
  rw [zpow_add_oneâ‚€ ha.ne]
  exact mul_neg_of_pos_of_neg (Even.zpow_pos (even_two_mul _) ha.ne) ha","refine âŸ¨fun h => ?_, fun h => ?_âŸ©"
Mathlib/Probability/ProbabilityMassFunction/Integrals.lean,PMF.integral_eq_tsum,integral_eq_tsum,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= calc
  _ = âˆ« a in p.support, f a âˆ‚(p.toMeasure) := by rw [restrict_toMeasure_support p]
  _ = âˆ‘' (a : support p), (p.toMeasure {a.val}).toReal â€¢ f a := by
    apply integral_countable f p.support_countable
    rwa [restrict_toMeasure_support p]
  _ = âˆ‘' (a : support p), (p a).toReal â€¢ f a := by
    congr with x; congr
    apply PMF.toMeasure_apply_singleton p x (MeasurableSet.singleton _)
  _ = âˆ‘' a, (p a).toReal â€¢ f a :=
    tsum_subtype_eq_of_support_subset <| by calc
      (fun a â†¦ (p a).toReal â€¢ f a).support âŠ† (fun a â†¦ (p a).toReal).support :=
        Function.support_smul_subset_left _ _
      _ âŠ† support p := fun x h1 h2 => h1 (by simp [h2])","error:  tactic 'apply' failed, failed to unify
  p.toMeasure {â†‘x} = p â†‘x
with
  Measure Î± = PMF Î±
case e_f.h.e_a.e_a.h.e_1
Î± : Type u_1
instâœâ´ : MeasurableSpace Î±
instâœÂ³ : MeasurableSingletonClass Î±
E : Type u_2
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
instâœ : CompleteSpace E
p : PMF Î±
f : Î± â†’ E
hf : Integrable f p.toMeasure
x : â†‘p.support
âŠ¢ Measure Î± = PMF Î±","theorem integral_eq_tsum (p : PMF Î±) (f : Î± â†’ E) (hf : Integrable f p.toMeasure) :
    âˆ« a, f a âˆ‚(p.toMeasure) = âˆ‘' a, (p a).toReal â€¢ f a ",":= calc
  _ = âˆ« a in p.support, f a âˆ‚(p.toMeasure) := by rw [restrict_toMeasure_support p]
  _ = âˆ‘' (a : support p), (p.toMeasure {a.val}).toReal â€¢ f a := by
    apply integral_countable f p.support_countable
    rwa [restrict_toMeasure_support p]
  _ = âˆ‘' (a : support p), (p a).toReal â€¢ f a := by
    congr with x; congr 2
    apply PMF.toMeasure_apply_singleton p x (MeasurableSet.singleton _)
  _ = âˆ‘' a, (p a).toReal â€¢ f a :=
    tsum_subtype_eq_of_support_subset <| by calc
      (fun a â†¦ (p a).toReal â€¢ f a).support âŠ† (fun a â†¦ (p a).toReal).support :=
        Function.support_smul_subset_left _ _
      _ âŠ† support p := fun x h1 h2 => h1 (by simp [h2])",refine theorem_eq_tsum_smul_of_integral_eq_theorem hf ?_ ?_
Mathlib/Geometry/Euclidean/Sphere/SecondInter.lean,EuclideanGeometry.Sphere.secondInter_smul,Sphere.secondInter_smul,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  simp_rw [Sphere.secondInter, real_inner_smul_left, inner_smul_right, smul_smul,
    div_mul_eq_div_div]
  rw [mul_comm, â† mul_div_assoc, â† mul_div_assoc, mul_div_cancel_left _ hr, mul_comm, mul_assoc,
    mul_div_cancel_left _ hr, mul_comm]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.35813 * ?m.35827 / ?m.35813
V : Type u_1
P : Type u_2
instâœÂ³ : NormedAddCommGroup V
instâœÂ² : InnerProductSpace â„ V
instâœÂ¹ : MetricSpace P
instâœ : NormedAddTorsor V P
s : Sphere P
p : P
v : V
r : â„
hr : r â‰  0
âŠ¢ (r * (-2 * (r * âŸªv, p -áµ¥ s.centerâŸ«_â„) / r) / r / âŸªv, vâŸ«_â„) â€¢ v +áµ¥ p = (-2 * âŸªv, p -áµ¥ s.centerâŸ«_â„ / âŸªv, vâŸ«_â„) â€¢ v +áµ¥ p","theorem Sphere.secondInter_smul (s : Sphere P) (p : P) (v : V) {r : â„} (hr : r â‰  0) :
    s.secondInter p (r â€¢ v) = s.secondInter p v ",":= by
  simp_rw [Sphere.secondInter, real_inner_smul_left, inner_smul_right, smul_smul,
    div_mul_eq_div_div]
  rw [mul_comm, â† mul_div_assoc, â† mul_div_assoc, mul_div_cancel_leftâ‚€ _ hr, mul_comm, mul_assoc,
    mul_div_cancel_leftâ‚€ _ hr, mul_comm]","rw [secondInter, secondInter, secondInter, secondInter, secondInter, secondInter]"
Mathlib/Algebra/Lie/Weights/Basic.lean,LieModule.map_posFittingComp_le,map_posFittingComp_le,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [posFittingComp, posFittingComp, LieSubmodule.map_iSup]
  refine iSup_mono fun y â†¦ LieSubmodule.map_le_iff_le_comap.mpr fun m hm â†¦ ?_
  simp only [mem_posFittingCompOf] at hm
  simp only [LieSubmodule.mem_comap, mem_posFittingCompOf]
  intro k
  obtain âŸ¨n, hnâŸ© := hm k
  use f n
  rw [LieModule.toEndomorphism_pow_apply_map, hn]","error:  unknown constant 'LieModule.toEndomorphism_pow_apply_map'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.394406
case h
K : Type u_1
R : Type u_2
L : Type u_3
M : Type u_4
instâœÂ¹Â¹ : CommRing R
instâœÂ¹â° : LieRing L
instâœâ¹ : LieAlgebra R L
instâœâ¸ : LieAlgebra.IsNilpotent R L
instâœâ· : AddCommGroup M
instâœâ¶ : Module R M
instâœâµ : LieRingModule L M
instâœâ´ : LieModule R L M
Mâ‚‚ : Type u_5
instâœÂ³ : AddCommGroup Mâ‚‚
instâœÂ² : Module R Mâ‚‚
instâœÂ¹ : LieRingModule L Mâ‚‚
instâœ : LieModule R L Mâ‚‚
Ï‡ : L â†’ R
f : M â†’â‚—â…R,Lâ† Mâ‚‚
y : L
m : M
hm : âˆ€ (k : â„•), âˆƒ n, ((toEnd R L M) y ^ k) n = m
k : â„•
n : M
hn : ((toEnd R L M) y ^ k) n = m
âŠ¢ ((toEnd R L Mâ‚‚) y ^ k) (f n) = f m","lemma map_posFittingComp_le :
    (posFittingComp R L M).map f â‰¤ posFittingComp R L Mâ‚‚ ",":= by
  rw [posFittingComp, posFittingComp, LieSubmodule.map_iSup]
  refine iSup_mono fun y â†¦ LieSubmodule.map_le_iff_le_comap.mpr fun m hm â†¦ ?_
  simp only [mem_posFittingCompOf] at hm
  simp only [LieSubmodule.mem_comap, mem_posFittingCompOf]
  intro k
  obtain âŸ¨n, hnâŸ© := hm k
  use f n
  rw [LieModule.toEnd_pow_apply_map, hn]",rw [posFittingComp]
Mathlib/CategoryTheory/Extensive.lean,CategoryTheory.FinitaryPreExtensive.hasPullbacks_of_is_coproduct,FinitaryPreExtensive.hasPullbacks_of_is_coproduct,4921473a163eff7f3a005863259a8eb06e94bb74,":= by
  classical
  let f : Î¹ â†’ C := F.obj âˆ˜ Discrete.mk
  have : F = Discrete.functor f :=
    Functor.hext (fun i â†¦ rfl) (by rintro âŸ¨iâŸ© âŸ¨jâŸ© âŸ¨âŸ¨rfl : i = jâŸ©âŸ©; simp)
  clear_value f
  subst this
  change Cofan f at c
  obtain âŸ¨iâŸ© := i
  let e : âˆ f â‰… f i â¨¿ (âˆ fun j : ({i}á¶œ : Set Î¹) â†¦ f j) :=
  { hom := Sigma.desc (fun j â†¦ if h : j = i then eqToHom (congr_arg f h) â‰« coprod.inl else
      Sigma.Î¹ (fun j : ({i}á¶œ : Set Î¹) â†¦ f j) âŸ¨j, hâŸ© â‰« coprod.inr)
    inv := coprod.desc (Sigma.Î¹ f i) (Sigma.desc fun j â†¦ Sigma.Î¹ f j)
    hom_inv_id := by aesop_cat
    inv_hom_id := by
      ext j
      Â· simp
      Â· simp only [coprod.desc_comp, colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app,
          eqToHom_refl, Category.id_comp, dite_true, BinaryCofan.mk_pt, BinaryCofan.Î¹_app_right,
          BinaryCofan.mk_inr, colimit.Î¹_desc_assoc, Discrete.functor_obj, Category.comp_id]
        exact dif_neg j.prop }
  let e' : c.pt â‰… f i â¨¿ (âˆ fun j : ({i}á¶œ : Set Î¹) â†¦ f j) :=
    hc.coconePointUniqueUpToIso (getColimitCocone _).2 â‰ªâ‰« e
  have : coprod.inl â‰« e'.inv = c.Î¹.app âŸ¨iâŸ©
  Â· simp only [Iso.trans_inv, coprod.desc_comp, colimit.Î¹_desc, BinaryCofan.mk_pt,
      BinaryCofan.Î¹_app_left, BinaryCofan.mk_inl]
    exact colimit.comp_coconePointUniqueUpToIso_inv _ _
  clear_value e'
  rw [â† this]
  have : IsPullback (ğŸ™ _) (g â‰« e'.hom) g e'.inv := IsPullback.of_horiz_isIso âŸ¨by simpâŸ©
  exact âŸ¨âŸ¨âŸ¨_, ((IsPullback.of_hasPullback (g â‰« e'.hom) coprod.inl).paste_horiz this).isLimitâŸ©âŸ©âŸ©","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case mk.mk.up.up
J : Type v'
instâœâ´ : Category.{u', v'} J
C : Type u
instâœÂ³ : Category.{v, u} C
D : Type u''
instâœÂ² : Category.{v'', u''} D
Xâœ Y : C
instâœÂ¹ : FinitaryPreExtensive C
Î¹ : Type u_1
instâœ : Finite Î¹
F : Discrete Î¹ â¥¤ C
c : Cocone F
hc : IsColimit c
iâœ : Discrete Î¹
X : C
g : X âŸ¶ ((Functor.const (Discrete Î¹)).obj c.pt).obj iâœ
f : Î¹ â†’ C := F.obj âˆ˜ Discrete.mk
i : Î¹
âŠ¢ ğŸ™ (F.obj { as := i }) = ğŸ™ (f i)
error:  unsolved goals
case mk
J : Type v'
instâœâ´ : Category.{u', v'} J
C : Type u
instâœÂ³ : Category.{v, u} C
D : Type u''
instâœÂ² : Category.{v'', u''} D
Xâœ Y : C
instâœÂ¹ : FinitaryPreExtensive C
Î¹ : Type u_1
instâœ : Finite Î¹
X : C
f : Î¹ â†’ C
c : Cofan f
hc : IsColimit c
i : Î¹
g : X âŸ¶ ((Functor.const (Discrete Î¹)).obj c.pt).obj { as := i }
e : âˆ f â‰… f i â¨¿ âˆ fun j â†¦ f â†‘j :=
  { hom := Sigma.desc fun j â†¦ if h : j = i then eqToHom â‹¯ â‰« coprod.inl else Sigma.Î¹ (fun j â†¦ f â†‘j) âŸ¨j, hâŸ© â‰« coprod.inr,
    inv := coprod.desc (Sigma.Î¹ f i) (Sigma.desc fun j â†¦ Sigma.Î¹ f â†‘j), hom_inv_id := â‹¯, inv_hom_id := â‹¯ }
e' : c.pt â‰… f i â¨¿ âˆ fun j â†¦ f â†‘j := hc.coconePointUniqueUpToIso (getColimitCocone (Discrete.functor f)).isColimit â‰ªâ‰« e
this : coprod.inl â‰« e'.inv = c.Î¹.app { as := i }
âŠ¢ HasPullback g (c.Î¹.app { as := i })","lemma FinitaryPreExtensive.hasPullbacks_of_is_coproduct [FinitaryPreExtensive C] {Î¹ : Type*}
    [Finite Î¹] {F : Discrete Î¹ â¥¤ C} {c : Cocone F} (hc : IsColimit c) (i : Discrete Î¹) {X : C}
    (g : X âŸ¶ _) : HasPullback g (c.Î¹.app i) ",":= by
  classical
  let f : Î¹ â†’ C := F.obj âˆ˜ Discrete.mk
  have : F = Discrete.functor f :=
    Functor.hext (fun i â†¦ rfl) (by rintro âŸ¨iâŸ© âŸ¨jâŸ© âŸ¨âŸ¨rfl : i = jâŸ©âŸ©; simp [f])
  clear_value f
  subst this
  change Cofan f at c
  obtain âŸ¨iâŸ© := i
  let e : âˆ f â‰… f i â¨¿ (âˆ fun j : ({i}á¶œ : Set Î¹) â†¦ f j) :=
  { hom := Sigma.desc (fun j â†¦ if h : j = i then eqToHom (congr_arg f h) â‰« coprod.inl else
      Sigma.Î¹ (fun j : ({i}á¶œ : Set Î¹) â†¦ f j) âŸ¨j, hâŸ© â‰« coprod.inr)
    inv := coprod.desc (Sigma.Î¹ f i) (Sigma.desc fun j â†¦ Sigma.Î¹ f j)
    hom_inv_id := by aesop_cat
    inv_hom_id := by
      ext j
      Â· simp
      Â· simp only [coprod.desc_comp, colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app,
          eqToHom_refl, Category.id_comp, dite_true, BinaryCofan.mk_pt, BinaryCofan.Î¹_app_right,
          BinaryCofan.mk_inr, colimit.Î¹_desc_assoc, Discrete.functor_obj, Category.comp_id]
        exact dif_neg j.prop }
  let e' : c.pt â‰… f i â¨¿ (âˆ fun j : ({i}á¶œ : Set Î¹) â†¦ f j) :=
    hc.coconePointUniqueUpToIso (getColimitCocone _).2 â‰ªâ‰« e
  have : coprod.inl â‰« e'.inv = c.Î¹.app âŸ¨iâŸ© := by
    simp only [e', Iso.trans_inv, coprod.desc_comp, colimit.Î¹_desc, BinaryCofan.mk_pt,
      BinaryCofan.Î¹_app_left, BinaryCofan.mk_inl]
    exact colimit.comp_coconePointUniqueUpToIso_inv _ _
  clear_value e'
  rw [â† this]
  have : IsPullback (ğŸ™ _) (g â‰« e'.hom) g e'.inv := IsPullback.of_horiz_isIso âŸ¨by simpâŸ©
  exact âŸ¨âŸ¨âŸ¨_, ((IsPullback.of_hasPullback (g â‰« e'.hom) coprod.inl).paste_horiz this).isLimitâŸ©âŸ©âŸ©","simp only [Discrete.functor_obj, Discrete.functor_obj, Discrete.functor_obj, Discrete.functor_obj]"
Mathlib/GroupTheory/Perm/Support.lean,Equiv.Perm.mem_support_swap_mul_imp_mem_support_ne,mem_support_swap_mul_imp_mem_support_ne,848a859b767a9159257960fdeea9a255b1c2dd48,":= by
  simp only [mem_support, swap_apply_def, mul_apply, f.injective.eq_iff] at *
  by_cases h : f y = x
  Â· constructor <;> intro <;> simp_all only [if_true, eq_self_iff_true, not_true, Ne]
  Â· split_ifs at hy with hf heq <;>
    simp_all only [not_true]
    Â· exact âŸ¨h, hyâŸ©
    Â· exact âŸ¨hy, heqâŸ©","warning:  unused name: heq
error:  simp_all made no progress
error:  unknown identifier 'heq'","theorem mem_support_swap_mul_imp_mem_support_ne {x y : Î±} (hy : y âˆˆ support (swap x (f x) * f)) :
    y âˆˆ support f âˆ§ y â‰  x ",":= by
  simp only [mem_support, swap_apply_def, mul_apply, f.injective.eq_iff] at *
  by_cases h : f y = x
  Â· constructor <;> intro <;> simp_all only [if_true, eq_self_iff_true, not_true, Ne]
  Â· split_ifs at hy with heq
    Â· subst heq; exact âŸ¨h, hyâŸ©
    Â· exact âŸ¨hy, heqâŸ©",rw [mem_support_swap_mul_imp_mem_support_ne] at hy
Mathlib/Topology/Algebra/InfiniteSum/Basic.lean,tprod_setElem_eq_tprod_setElem_diff,tprod_setElem_eq_tprod_setElem_diff,5bc1ad1d20d0d38fd328824a49d24b475a371d9e,":=
  .symm <| (Set.inclusion_injective (Set.diff_subset s t)).tprod_eq (f := f âˆ˜ (â†‘)) <|
    mulSupport_subset_iff'.2 fun b hb â†¦ hfâ‚€ b <| by simpa using hb","error:  application type mismatch
  Set.diff_subset s
argument
  s
has type
  Set Î² : Type u_2
but is expected to have type
  ?m.124879 âˆˆ ?m.124877 \ ?m.124878 : Prop
error:  type mismatch
  hfâ‚€ ?m.125479 ?m.125480
has type
  f ?m.125479 = 1 : Prop
but is expected to have type
  (f âˆ˜ ?m.125305) b = 1 : Prop
error:  cannot coerce
  x
to type
  Î²
error:  type mismatch
  hâœ
has type
  â†‘b âˆ‰ ?m.124873 : Prop
but is expected to have type
  ?m.125479 âˆˆ t : Prop","lemma tprod_setElem_eq_tprod_setElem_diff {f : Î² â†’ Î±} (s t : Set Î²)
    (hfâ‚€ : âˆ€ b âˆˆ t, f b = 1) :
    âˆ' a : s, f a = âˆ' a : (s \ t : Set Î²), f a ",":=
  .symm <| (Set.inclusion_injective (t := s) Set.diff_subset).tprod_eq (f := f âˆ˜ (â†‘)) <|
    mulSupport_subset_iff'.2 fun b hb â†¦ hfâ‚€ b <| by simpa using hb","rw [tprod_setElem_eq_tprod_setElem_diff hfâ‚€, tprod_setElem_eq_tprod_setElem_diff]"
Mathlib/RingTheory/Adjoin/Tower.lean,fg_of_fg_of_fg,fg_of_fg_of_fg,9e34a191034458a56331f976ff7400a26407c888,":=
  let âŸ¨Bâ‚€, hABâ‚€, hBâ‚€CâŸ© := exists_subalgebra_of_fg A B C hAC hBC
  Algebra.fg_trans' (Bâ‚€.fg_top.2 hABâ‚€) <|
    Subalgebra.fg_of_submodule_fg <|
      have : IsNoetherianRing Bâ‚€ := isNoetherianRing_of_fg hABâ‚€
      have : IsNoetherian Bâ‚€ C := isNoetherian_of_fg_of_noetherian' hBâ‚€C
      fg_of_injective (IsScalarTower.toAlgHom Bâ‚€ B C).toLinearMap hBCi",error:  unknown identifier 'isNoetherian_of_fg_of_noetherian'',"theorem fg_of_fg_of_fg [IsNoetherianRing A] (hAC : (âŠ¤ : Subalgebra A C).FG)
    (hBC : (âŠ¤ : Submodule B C).FG) (hBCi : Function.Injective (algebraMap B C)) :
    (âŠ¤ : Subalgebra A B).FG ",":=
  let âŸ¨Bâ‚€, hABâ‚€, hBâ‚€CâŸ© := exists_subalgebra_of_fg A B C hAC hBC
  Algebra.fg_trans' (Bâ‚€.fg_top.2 hABâ‚€) <|
    Subalgebra.fg_of_submodule_fg <|
      have : IsNoetherianRing Bâ‚€ := isNoetherianRing_of_fg hABâ‚€
      have : Module.Finite Bâ‚€ C := âŸ¨hBâ‚€CâŸ©
      fg_of_injective (IsScalarTower.toAlgHom Bâ‚€ B C).toLinearMap hBCi",apply Submodule.fg_of_fg_of_fg_injective
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOnFilter,hasFDerivAt_of_tendstoUniformlyOnFilter,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @IsROrC.norm_ofReal ğ•œ _ _, IsROrC.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0); simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this Îµ hÎµ).mono fun y hy => _
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  Â· 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_op_norm (n.2 - x)",error:  unexpected token ';'; expected '|',"theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ğ“ x))
    (hf : âˆ€á¶  n : Î¹ Ã— E in l Ã—Ë¢ ğ“ x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : âˆ€á¶  y in ğ“ x, Tendsto (fun n => f n y) l (ğ“ (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","refine theorem_hasFDerivAt_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_of_tendstoUniformlyOnFilter_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOn hasFDerivAt_contin"
Mathlib/Analysis/Convex/Measure.lean,Convex.addHaar_frontier,addHaar_frontier,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  cases' ne_or_eq (affineSpan â„ s) âŠ¤ with hspan hspan
  Â· refine' measure_mono_null _ (addHaar_affineSubspace _ _ hspan)
    exact frontier_subset_closure.trans
      (closure_minimal (subset_affineSpan _ _) (affineSpan â„ s).closed_of_finiteDimensional)
  rw [â† hs.interior_nonempty_iff_affineSpan_eq_top] at hspan
  rcases hspan with âŸ¨x, hxâŸ©
  suffices H : âˆ€ t : Set E, Convex â„ t â†’ x âˆˆ interior t â†’ IsBounded t â†’ Î¼ (frontier t) = 0 by
    let B : â„• â†’ Set E := fun n => ball x (n + 1)
    have : Î¼ (â‹ƒ n : â„•, frontier (s âˆ© B n)) = 0 := by
      refine' measure_iUnion_null fun n =>
        H _ (hs.inter (convex_ball _ _)) _ (isBounded_ball.subset (inter_subset_right _ _))
      rw [interior_inter, isOpen_ball.interior_eq]
      exact âŸ¨hx, mem_ball_self (add_pos_of_nonneg_of_pos n.cast_nonneg zero_lt_one)âŸ©
    refine' measure_mono_null (fun y hy => _) this; clear this
    set N : â„• := âŒŠdist y xâŒ‹â‚Š
    refine' mem_iUnion.2 âŸ¨N, _âŸ©
    have hN : y âˆˆ B N := by simp [Nat.lt_floor_add_one]
    suffices y âˆˆ frontier (s âˆ© B N) âˆ© B N from this.1
    rw [frontier_inter_open_inter isOpen_ball]
    exact âŸ¨hy, hNâŸ©
  intro s hs hx hb
  replace hb : Î¼ (interior s) â‰  âˆ := (hb.subset interior_subset).measure_lt_top.ne
  suffices Î¼ (closure s) â‰¤ Î¼ (interior s) by
    rwa [frontier, measure_diff interior_subset_closure isOpen_interior.measurableSet hb,
      tsub_eq_zero_iff_le]
  set d : â„• := FiniteDimensional.finrank â„ E
  have : âˆ€ r : â„â‰¥0, 1 < r â†’ Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) := fun r hr â†¦ by
    refine' (measure_mono <|
      hs.closure_subset_image_homothety_interior_of_one_lt hx r hr).trans_eq _
    rw [addHaar_image_homothety, â† NNReal.coe_pow, NNReal.abs_eq, ENNReal.ofReal_coe_nnreal]
  have : âˆ€á¶  (r : â„â‰¥0) in ğ“[>] 1, Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) :=
    mem_of_superset self_mem_nhdsWithin this
  refine' ge_of_tendsto _ this
  refine' (((ENNReal.continuous_mul_const hb).comp
    (ENNReal.continuous_coe.comp (continuous_pow d))).tendsto' _ _ _).mono_left nhdsWithin_le_nhds
  simp","error:  function expected at
  inter_subset_right ?m.13269
term has type
  ?m.13268 âˆˆ ?m.13267
error:  unsolved goals
case refine'_2
E : Type u_1
instâœâµ : NormedAddCommGroup E
instâœâ´ : NormedSpace â„ E
instâœÂ³ : MeasurableSpace E
instâœÂ² : BorelSpace E
instâœÂ¹ : FiniteDimensional â„ E
Î¼ : Measure E
instâœ : Î¼.IsAddHaarMeasure
s : Set E
hs : Convex â„ s
x : E
hx : x âˆˆ interior s
H : âˆ€ (t : Set E), Convex â„ t â†’ x âˆˆ interior t â†’ Bornology.IsBounded t â†’ Î¼ (frontier t) = 0
B : â„• â†’ Set E := fun n â†¦ ball x (â†‘n + 1)
âŠ¢ â„• â†’ E

case refine'_3
E : Type u_1
instâœâµ : NormedAddCommGroup E
instâœâ´ : NormedSpace â„ E
instâœÂ³ : MeasurableSpace E
instâœÂ² : BorelSpace E
instâœÂ¹ : FiniteDimensional â„ E
Î¼ : Measure E
instâœ : Î¼.IsAddHaarMeasure
s : Set E
hs : Convex â„ s
x : E
hx : x âˆˆ interior s
H : âˆ€ (t : Set E), Convex â„ t â†’ x âˆˆ interior t â†’ Bornology.IsBounded t â†’ Î¼ (frontier t) = 0
B : â„• â†’ Set E := fun n â†¦ ball x (â†‘n + 1)
âŠ¢ â„• â†’ â„
error:  simp made no progress",theorem addHaar_frontier (hs : Convex â„ s) : Î¼ (frontier s) = 0 ,":= by
  cases' ne_or_eq (affineSpan â„ s) âŠ¤ with hspan hspan
  Â· refine measure_mono_null ?_ (addHaar_affineSubspace _ _ hspan)
    exact frontier_subset_closure.trans
      (closure_minimal (subset_affineSpan _ _) (affineSpan â„ s).closed_of_finiteDimensional)
  rw [â† hs.interior_nonempty_iff_affineSpan_eq_top] at hspan
  rcases hspan with âŸ¨x, hxâŸ©
  suffices H : âˆ€ t : Set E, Convex â„ t â†’ x âˆˆ interior t â†’ IsBounded t â†’ Î¼ (frontier t) = 0 by
    let B : â„• â†’ Set E := fun n => ball x (n + 1)
    have : Î¼ (â‹ƒ n : â„•, frontier (s âˆ© B n)) = 0 := by
      refine measure_iUnion_null fun n =>
        H _ (hs.inter (convex_ball _ _)) ?_ (isBounded_ball.subset inter_subset_right)
      rw [interior_inter, isOpen_ball.interior_eq]
      exact âŸ¨hx, mem_ball_self (add_pos_of_nonneg_of_pos n.cast_nonneg zero_lt_one)âŸ©
    refine measure_mono_null (fun y hy => ?_) this; clear this
    set N : â„• := âŒŠdist y xâŒ‹â‚Š
    refine mem_iUnion.2 âŸ¨N, ?_âŸ©
    have hN : y âˆˆ B N := by simp [B, N, Nat.lt_floor_add_one]
    suffices y âˆˆ frontier (s âˆ© B N) âˆ© B N from this.1
    rw [frontier_inter_open_inter isOpen_ball]
    exact âŸ¨hy, hNâŸ©
  intro s hs hx hb
  replace hb : Î¼ (interior s) â‰  âˆ := (hb.subset interior_subset).measure_lt_top.ne
  suffices Î¼ (closure s) â‰¤ Î¼ (interior s) by
    rwa [frontier, measure_diff interior_subset_closure isOpen_interior.measurableSet hb,
      tsub_eq_zero_iff_le]
  set d : â„• := FiniteDimensional.finrank â„ E
  have : âˆ€ r : â„â‰¥0, 1 < r â†’ Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) := fun r hr â†¦ by
    refine (measure_mono <|
      hs.closure_subset_image_homothety_interior_of_one_lt hx r hr).trans_eq ?_
    rw [addHaar_image_homothety, â† NNReal.coe_pow, NNReal.abs_eq, ENNReal.ofReal_coe_nnreal]
  have : âˆ€á¶  (r : â„â‰¥0) in ğ“[>] 1, Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) :=
    mem_of_superset self_mem_nhdsWithin this
  refine ge_of_tendsto ?_ this
  refine (((ENNReal.continuous_mul_const hb).comp
    (ENNReal.continuous_coe.comp (continuous_pow d))).tendsto' _ _ ?_).mono_left nhdsWithin_le_nhds
  simp",refine addHaar_frontier_eq_zero_of_addHaar_frontier_frontier hs addHaar_frontier hs ?_
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOn,hasFDerivAt_of_tendstoUniformlyOn,166d0bf5448fdaad518cf95891af45e08a3e9c35,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  â€–(f' n.1 x - g' x) (n.2 - x)â€– â‰¤ â€–f' n.1 x - g' xâ€– * â€–n.2 - xâ€– : Prop
but is expected to have type
  â€–(f' n.1 x - g' x) (n.2 - x)â€– â‰¤ â€–(Prod.map (fun n â†¦ g' x - f' n x) id n).1â€– * â€–x - n.2â€– : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ğ“ x))
    (hf : âˆ€á¶  n : Î¹ Ã— E in l Ã—Ë¢ ğ“ x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : âˆ€á¶  y in ğ“ x, Tendsto (fun n => f n y) l (ğ“ (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","refine theorem_hasFDerivAt_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_of_tendstoUniformlyOnFilter_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_tendstoUniformlyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter_of_eventuallyOnFilter
  hasFDerivAt_iff_tendstoUniformlyOnFilter_of_eventuallyOn hasFDerivAt_contin"
Mathlib/Combinatorics/SimpleGraph/Ends/Defs.lean,SimpleGraph.ComponentCompl.infinite_iff_in_all_ranges,infinite_iff_in_all_ranges,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  classical
    constructor
    Â· rintro Cinf L h
      obtain âŸ¨v, âŸ¨vK, rflâŸ©, vLâŸ© := Set.Infinite.nonempty (Set.Infinite.diff Cinf L.finite_toSet)
      exact âŸ¨componentComplMk _ vL, rflâŸ©
    Â· rintro h Cfin
      obtain âŸ¨D, eâŸ© := h (K âˆª Cfin.toFinset) (Finset.subset_union_left K Cfin.toFinset)
      obtain âŸ¨v, vDâŸ© := D.nonempty
      let Ddis := D.disjoint_right
      simp_rw [Finset.coe_union, Set.Finite.coe_toFinset, Set.disjoint_union_left,
        Set.disjoint_iff] at Ddis
      exact Ddis.right âŸ¨(ComponentCompl.hom_eq_iff_le _ _ _).mp e vD, vDâŸ©","error:  application type mismatch
  Finset.subset_union_left K
argument
  K
has type
  Finset V : Type u
but is expected to have type
  ?m.10416 âˆˆ ?m.10414 : Prop","theorem infinite_iff_in_all_ranges {K : Finset V} (C : G.ComponentCompl K) :
    C.supp.Infinite â†” âˆ€ (L) (h : K âŠ† L), âˆƒ D : G.ComponentCompl L, D.hom h = C ",":= by
  classical
    constructor
    Â· rintro Cinf L h
      obtain âŸ¨v, âŸ¨vK, rflâŸ©, vLâŸ© := Set.Infinite.nonempty (Set.Infinite.diff Cinf L.finite_toSet)
      exact âŸ¨componentComplMk _ vL, rflâŸ©
    Â· rintro h Cfin
      obtain âŸ¨D, eâŸ© := h (K âˆª Cfin.toFinset) Finset.subset_union_left
      obtain âŸ¨v, vDâŸ© := D.nonempty
      let Ddis := D.disjoint_right
      simp_rw [Finset.coe_union, Set.Finite.coe_toFinset, Set.disjoint_union_left,
        Set.disjoint_iff] at Ddis
      exact Ddis.right âŸ¨(ComponentCompl.hom_eq_iff_le _ _ _).mp e vD, vDâŸ©","simp only [infinite_iff_in_all_ranges, ComponentCompl]"
Mathlib/Topology/UniformSpace/Cauchy.lean,cauchy_prod_iff,cauchy_prod_iff,07d28ef76de6fda605a7eb6f6c9ef70c5c90b329,":= by
  simp_rw (config := { instances := true }) [instUniformSpaceProd, â† cauchy_comap_uniformSpace,
    â† cauchy_inf_uniformSpace]","error:  'instances' is not a field of structure 'Lean.Meta.Simp.Config'
error:  cannot evaluate code because 'sorryAx' uses 'sorry' and/or contains errors","lemma cauchy_prod_iff [UniformSpace Î²] {F : Filter (Î± Ã— Î²)} :
    Cauchy F â†” Cauchy (map Prod.fst F) âˆ§ Cauchy (map Prod.snd F) ",":= by
  simp_rw [instUniformSpaceProd, â† cauchy_comap_uniformSpace, â† cauchy_inf_uniformSpace]","refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©"
Mathlib/Topology/MetricSpace/HausdorffDistance.lean,EMetric.infEdist_image,infEdist_image,75499222cc11ae5a47a99ba69c3066b962a0dc6f,":= by
  simp only [infEdist, infáµ¢_image, hÎ¦.edist_eq]","error:  unknown identifier 'infáµ¢_image'
error:  unsolved goals
Î¹ : Sort u_1
Î± : Type u
Î² : Type v
instâœÂ¹ : PseudoEMetricSpace Î±
instâœ : PseudoEMetricSpace Î²
x y : Î±
s t : Set Î±
Î¦ : Î± â†’ Î²
hÎ¦ : Isometry Î¦
âŠ¢ â¨… y âˆˆ Î¦ '' t, edist (Î¦ x) y = â¨… y âˆˆ t, edist x y",theorem infEdist_image (hÎ¦ : Isometry Î¦) : infEdist (Î¦ x) (Î¦ '' t) = infEdist x t ,":= by
  simp only [infEdist, iInf_image, hÎ¦.edist_eq]","rw [infEdist_image, infEdist_image]"
Mathlib/Analysis/Complex/PhragmenLindelof.lean,PhragmenLindelof.right_half_plane_of_tendsto_zero_on_real,right_half_plane_of_tendsto_zero_on_real,e78bcd0f6da62739c580ef7cfadf16b23ff5d520,":= by
  revert z
  have hle : âˆ€ C', (âˆ€ x : â„, 0 â‰¤ x â†’ â€–f xâ€– â‰¤ C') â†’
      âˆ€ z : â„‚, 0 â‰¤ z.re â†’ â€–f zâ€– â‰¤ max C C' := fun C' hC' z hz â†¦ by
    rcases hexp with âŸ¨c, hc, B, hOâŸ©
    rcases le_total z.im 0 with h | h
    Â· refine quadrant_IV (hd.mono fun _ => And.left) âŸ¨c, hc, B, ?_âŸ©
          (fun x hx => (hC' x hx).trans <| le_max_right _ _)
          (fun x _ => (him x).trans (le_max_left _ _)) hz h
      exact hO.mono (inf_le_inf_left _ <| principal_mono.2 fun _ => And.left)
    Â· refine' quadrant_I (hd.mono fun _ => And.left) âŸ¨c, hc, B, ?_âŸ©
          (fun x hx => (hC' x hx).trans <| le_max_right _ _)
          (fun x _ => (him x).trans (le_max_left _ _)) hz h
      exact hO.mono (inf_le_inf_left _ <| principal_mono.2 fun _ => And.left)
  obtain âŸ¨xâ‚€, hxâ‚€, hmaxâŸ© : âˆƒ x : â„, 0 â‰¤ x âˆ§ âˆ€ y : â„, 0 â‰¤ y â†’ â€–f yâ€– â‰¤ â€–f xâ€– := by
    have hfc : ContinuousOn (fun x : â„ => f x) (Ici 0) := by
      refine' hd.continuousOn.comp continuous_ofReal.continuousOn fun x hx => _
      rwa [closure_setOf_lt_re]
    by_cases hâ‚€ : âˆ€ x : â„, 0 â‰¤ x â†’ f x = 0
    Â· refine' âŸ¨0, le_rfl, fun y hy => _âŸ©; rw [hâ‚€ y hy, hâ‚€ 0 le_rfl]
    push_neg at hâ‚€
    rcases hâ‚€ with âŸ¨xâ‚€, hxâ‚€, hneâŸ©
    have hlt : â€–(0 : E)â€– < â€–f xâ‚€â€– := by rwa [norm_zero, norm_pos_iff]
    suffices âˆ€á¶  x : â„ in cocompact â„ âŠ“ ğ“Ÿ (Ici 0), â€–f xâ€– â‰¤ â€–f xâ‚€â€– by
      simpa only [exists_prop] using hfc.norm.exists_forall_ge' isClosed_Ici hxâ‚€ this
    rw [cocompact_eq_atBot_atTop, inf_sup_right, (disjoint_atBot_principal_Ici (0 : â„)).eq_bot,
      bot_sup_eq]
    exact (hre.norm.eventually <| ge_mem_nhds hlt).filter_mono inf_le_left
  rcases le_or_lt â€–f xâ‚€â€– C with h | h
  Â·
    simpa only [max_eq_left h] using hle _ hmax
  Â· 
    replace hmax : IsMaxOn (norm âˆ˜ f) {z | 0 < z.re} xâ‚€
    Â· rintro z (hz : 0 < z.re)
      simpa [max_eq_right h.le] using hle _ hmax _ hz.le
    have : â€–f 0â€– = â€–f xâ‚€â€– := by
      apply norm_eq_norm_of_isMaxOn_of_ball_subset hd hmax
      intro z hz
      rw [mem_ball, dist_zero_left, dist_eq, norm_eq_abs, Complex.abs_of_nonneg hxâ‚€] at hz
      rw [mem_setOf_eq]
      contrapose! hz
      calc
        xâ‚€ â‰¤ xâ‚€ - z.re := (le_sub_self_iff _).2 hz
        _ â‰¤ |xâ‚€ - z.re| := (le_abs_self _)
        _ = |(z - xâ‚€).re| := by rw [sub_re, ofReal_re, _root_.abs_sub_comm]
        _ â‰¤ abs (z - xâ‚€) := abs_re_le_abs _
    refine' (h.not_le <| this â–¸ _).elim
    simpa using him 0","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case intro.intro.inr
E : Type u_1
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace â„‚ E
a b C : â„
f g : â„‚ â†’ E
hd : DiffContOnCl â„‚ f {z | 0 < z.re}
hexp : âˆƒ c < 2, âˆƒ B, f =O[cobounded â„‚ âŠ“ ğ“Ÿ {z | 0 < z.re}] fun z â†¦ expR (B * Complex.abs z ^ c)
hre : Tendsto (fun x â†¦ f â†‘x) atTop (ğ“ 0)
him : âˆ€ (x : â„), â€–f (â†‘x * I)â€– â‰¤ C
hle : âˆ€ (C' : â„), (âˆ€ (x : â„), 0 â‰¤ x â†’ â€–f â†‘xâ€– â‰¤ C') â†’ âˆ€ (z : â„‚), 0 â‰¤ z.re â†’ â€–f zâ€– â‰¤ max C C'
xâ‚€ : â„
hxâ‚€ : 0 â‰¤ xâ‚€
h : C < â€–f â†‘xâ‚€â€–
hmax : IsMaxOn (norm âˆ˜ f) {z | 0 < z.re} â†‘xâ‚€
âŠ¢ âˆ€ {z : â„‚}, 0 â‰¤ z.re â†’ â€–f zâ€– â‰¤ C","theorem right_half_plane_of_tendsto_zero_on_real (hd : DiffContOnCl â„‚ f {z | 0 < z.re})
    (hexp : âˆƒ c < (2 : â„), âˆƒ B,
      f =O[cobounded â„‚ âŠ“ ğ“Ÿ {z | 0 < z.re}] fun z => expR (B * abs z ^ c))
    (hre : Tendsto (fun x : â„ => f x) atTop (ğ“ 0)) (him : âˆ€ x : â„, â€–f (x * I)â€– â‰¤ C)
    (hz : 0 â‰¤ z.re) : â€–f zâ€– â‰¤ C ",":= by
  revert z
  have hle : âˆ€ C', (âˆ€ x : â„, 0 â‰¤ x â†’ â€–f xâ€– â‰¤ C') â†’
      âˆ€ z : â„‚, 0 â‰¤ z.re â†’ â€–f zâ€– â‰¤ max C C' := fun C' hC' z hz â†¦ by
    rcases hexp with âŸ¨c, hc, B, hOâŸ©
    rcases le_total z.im 0 with h | h
    Â· refine quadrant_IV (hd.mono fun _ => And.left) âŸ¨c, hc, B, ?_âŸ©
          (fun x hx => (hC' x hx).trans <| le_max_right _ _)
          (fun x _ => (him x).trans (le_max_left _ _)) hz h
      exact hO.mono (inf_le_inf_left _ <| principal_mono.2 fun _ => And.left)
    Â· refine quadrant_I (hd.mono fun _ => And.left) âŸ¨c, hc, B, ?_âŸ©
          (fun x hx => (hC' x hx).trans <| le_max_right _ _)
          (fun x _ => (him x).trans (le_max_left _ _)) hz h
      exact hO.mono (inf_le_inf_left _ <| principal_mono.2 fun _ => And.left)
  obtain âŸ¨xâ‚€, hxâ‚€, hmaxâŸ© : âˆƒ x : â„, 0 â‰¤ x âˆ§ âˆ€ y : â„, 0 â‰¤ y â†’ â€–f yâ€– â‰¤ â€–f xâ€– := by
    have hfc : ContinuousOn (fun x : â„ => f x) (Ici 0) := by
      refine hd.continuousOn.comp continuous_ofReal.continuousOn fun x hx => ?_
      rwa [closure_setOf_lt_re]
    by_cases hâ‚€ : âˆ€ x : â„, 0 â‰¤ x â†’ f x = 0
    Â· refine âŸ¨0, le_rfl, fun y hy => ?_âŸ©; rw [hâ‚€ y hy, hâ‚€ 0 le_rfl]
    push_neg at hâ‚€
    rcases hâ‚€ with âŸ¨xâ‚€, hxâ‚€, hneâŸ©
    have hlt : â€–(0 : E)â€– < â€–f xâ‚€â€– := by rwa [norm_zero, norm_pos_iff]
    suffices âˆ€á¶  x : â„ in cocompact â„ âŠ“ ğ“Ÿ (Ici 0), â€–f xâ€– â‰¤ â€–f xâ‚€â€– by
      simpa only [exists_prop] using hfc.norm.exists_isMaxOn' isClosed_Ici hxâ‚€ this
    rw [cocompact_eq_atBot_atTop, inf_sup_right, (disjoint_atBot_principal_Ici (0 : â„)).eq_bot,
      bot_sup_eq]
    exact (hre.norm.eventually <| ge_mem_nhds hlt).filter_mono inf_le_left
  rcases le_or_lt â€–f xâ‚€â€– C with h | h
  Â·
    simpa only [max_eq_left h] using hle _ hmax
  Â· 
    replace hmax : IsMaxOn (norm âˆ˜ f) {z | 0 < z.re} xâ‚€ := by
      rintro z (hz : 0 < z.re)
      simpa [max_eq_right h.le] using hle _ hmax _ hz.le
    have : â€–f 0â€– = â€–f xâ‚€â€– := by
      apply norm_eq_norm_of_isMaxOn_of_ball_subset hd hmax
      intro z hz
      rw [mem_ball, dist_zero_left, dist_eq, norm_eq_abs, Complex.abs_of_nonneg hxâ‚€] at hz
      rw [mem_setOf_eq]
      contrapose! hz
      calc
        xâ‚€ â‰¤ xâ‚€ - z.re := (le_sub_self_iff _).2 hz
        _ â‰¤ |xâ‚€ - z.re| := le_abs_self _
        _ = |(z - xâ‚€).re| := by rw [sub_re, ofReal_re, _root_.abs_sub_comm]
        _ â‰¤ abs (z - xâ‚€) := abs_re_le_abs _
    refine (h.not_le <| this â–¸ ?_).elim
    simpa using him 0",refine theorem_right_half_plane_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_of_tendsto_zero_
Mathlib/Analysis/Calculus/ParametricIntegral.lean,hasDerivAt_integral_of_dominated_loc_of_lip,hasDerivAt_integral_of_dominated_loc_of_lip,7beff720374cad9ecd5385d39c4e7aba2c4561b6,":= by
  set L : E â†’L[ğ•œ] ğ•œ â†’L[ğ•œ] E := ContinuousLinearMap.smulRightL ğ•œ ğ•œ E 1
  replace h_diff : âˆ€áµ a âˆ‚Î¼, HasFDerivAt (F Â· a) (L (F' a)) xâ‚€ :=
    h_diff.mono fun x hx â†¦ hx.hasFDerivAt
  have hm : AEStronglyMeasurable (L âˆ˜ F') Î¼ := L.continuous.comp_aestronglyMeasurable hF'_meas
  cases'
    hasFDerivAt_integral_of_dominated_loc_of_lip Îµ_pos hF_meas hF_int hm h_lipsch bound_integrable
      h_diff with
    hF'_int key
  replace hF'_int : Integrable F' Î¼ := by
    rw [â† integrable_norm_iff hm] at hF'_int
    simpa only [(Â· âˆ˜ Â·), integrable_norm_iff, hF'_meas, one_mul, norm_one,
      ContinuousLinearMap.comp_apply, ContinuousLinearMap.coe_restrict_scalarsL',
      ContinuousLinearMap.norm_restrictScalars, ContinuousLinearMap.norm_smulRightL_apply] using
      hF'_int
  refine âŸ¨hF'_int, ?_âŸ©
  simp_rw [hasDerivAt_iff_hasFDerivAt] at h_diff âŠ¢
  simpa only [(Â· âˆ˜ Â·), ContinuousLinearMap.integral_comp_comm _ hF'_int] using key","error:  type mismatch
  hâœ
has type
  Integrable (fun a â†¦ â€–L (F' a)â€–) Î¼ : Prop
but is expected to have type
  Integrable F' Î¼ : Prop
error:  failed to synthesize
  CompleteSpace E
use `set_option diagnostics true` to get diagnostic information
error:  type mismatch
  hâœ
has type
  HasFDerivAt (fun x â†¦ âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), L (F' a) âˆ‚Î¼) xâ‚€ : Prop
but is expected to have type
  HasFDerivAt (fun x â†¦ âˆ« (a : Î±), F x a âˆ‚Î¼) (ContinuousLinearMap.smulRight 1 (âˆ« (a : Î±), F' a âˆ‚Î¼)) xâ‚€ : Prop","theorem hasDerivAt_integral_of_dominated_loc_of_lip {F' : Î± â†’ E} (Îµ_pos : 0 < Îµ)
    (hF_meas : âˆ€á¶  x in ğ“ xâ‚€, AEStronglyMeasurable (F x) Î¼) (hF_int : Integrable (F xâ‚€) Î¼)
    (hF'_meas : AEStronglyMeasurable F' Î¼)
    (h_lipsch : âˆ€áµ a âˆ‚Î¼, LipschitzOnWith (Real.nnabs <| bound a) (F Â· a) (ball xâ‚€ Îµ))
    (bound_integrable : Integrable (bound : Î± â†’ â„) Î¼)
    (h_diff : âˆ€áµ a âˆ‚Î¼, HasDerivAt (F Â· a) (F' a) xâ‚€) :
    Integrable F' Î¼ âˆ§ HasDerivAt (fun x â†¦ âˆ« a, F x a âˆ‚Î¼) (âˆ« a, F' a âˆ‚Î¼) xâ‚€ ",":= by
  set L : E â†’L[ğ•œ] ğ•œ â†’L[ğ•œ] E := ContinuousLinearMap.smulRightL ğ•œ ğ•œ E 1
  replace h_diff : âˆ€áµ a âˆ‚Î¼, HasFDerivAt (F Â· a) (L (F' a)) xâ‚€ :=
    h_diff.mono fun x hx â†¦ hx.hasFDerivAt
  have hm : AEStronglyMeasurable (L âˆ˜ F') Î¼ := L.continuous.comp_aestronglyMeasurable hF'_meas
  cases'
    hasFDerivAt_integral_of_dominated_loc_of_lip Îµ_pos hF_meas hF_int hm h_lipsch bound_integrable
      h_diff with
    hF'_int key
  replace hF'_int : Integrable F' Î¼ := by
    rw [â† integrable_norm_iff hm] at hF'_int
    simpa only [L, (Â· âˆ˜ Â·), integrable_norm_iff, hF'_meas, one_mul, norm_one,
      ContinuousLinearMap.comp_apply, ContinuousLinearMap.coe_restrict_scalarsL',
      ContinuousLinearMap.norm_restrictScalars, ContinuousLinearMap.norm_smulRightL_apply] using
      hF'_int
  refine âŸ¨hF'_int, ?_âŸ©
  by_cases hE : CompleteSpace E; swap
  Â· simp [integral, hE]
    exact hasDerivAt_const xâ‚€ 0
  simp_rw [hasDerivAt_iff_hasFDerivAt] at h_diff âŠ¢
  simpa only [(Â· âˆ˜ Â·), ContinuousLinearMap.integral_comp_comm _ hF'_int] using key","have : âˆ€á¶  x in ğ“ xâ‚€, HasDerivAt (fun x â†¦ HasDerivAt (fun x â†¦ HasDerivAt (fun x â†¦ âˆ« a, F x a âˆ‚Î¼) xâ‚€) xâ‚€ :=
  h_lipsch.mono h_diff"
Mathlib/MeasureTheory/SetSemiring.lean,MeasureTheory.IsSetSemiring.pairwiseDisjoint_union_diffFinsetâ‚€,pairwiseDisjoint_union_diffFinsetâ‚€,3838c3f5cc8da3ed680a157f72d53020cd177151,":= by
  rw [pairwiseDisjoint_union]
  refine âŸ¨h_dis, hC.pairwiseDisjoint_diffFinsetâ‚€ hs hI, fun u hu v hv _ â†¦ ?_âŸ©
  simp_rw [id.def]
  exact disjoint_of_subset (subset_sUnion_of_mem hu) (subset_sUnion_of_mem hv)
    (hC.disjoint_sUnion_diffFinsetâ‚€ hs hI)","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.26839 â†’ ?m.26839
error:  simp made no progress","lemma pairwiseDisjoint_union_diffFinsetâ‚€ (hC : IsSetSemiring C) (hs : s âˆˆ C)
    (hI : â†‘I âŠ† C) (h_dis : PairwiseDisjoint (I : Set (Set Î±)) id) :
    PairwiseDisjoint (I âˆª hC.diffFinsetâ‚€ hs hI : Set (Set Î±)) id ",":= by
  rw [pairwiseDisjoint_union]
  refine âŸ¨h_dis, hC.pairwiseDisjoint_diffFinsetâ‚€ hs hI, fun u hu v hv _ â†¦ ?_âŸ©
  simp_rw [id]
  exact disjoint_of_subset (subset_sUnion_of_mem hu) (subset_sUnion_of_mem hv)
    (hC.disjoint_sUnion_diffFinsetâ‚€ hs hI)",refine PairwiseDisjoint.insjoint_diffFinsetâ‚€ hC hs hI ?_ ?_
Mathlib/RingTheory/ZMod.lean,isReduced_zmod,isReduced_zmod,a2d4b97db742cef33d7ce3404f92ab85330707e5,":= by
  rw [â† RingHom.ker_isRadical_iff_reduced_of_surjective
      (ZMod.ringHom_surjective <| Int.castRingHom <| ZMod n),
      ZMod.ker_int_castRingHom, â† isRadical_iff_span_singleton, isRadical_iff_squarefree_or_zero,
      Int.squarefree_coe_nat, Nat.cast_eq_zero]","error:  unknown constant 'ZMod.ker_int_castRingHom'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.4294
n : â„•
âŠ¢ (RingHom.ker (Int.castRingHom (ZMod n))).IsRadical â†” Squarefree n âˆ¨ n = 0",theorem isReduced_zmod {n : â„•} : IsReduced (ZMod n) â†” Squarefree n âˆ¨ n = 0 ,":= by
  rw [â† RingHom.ker_isRadical_iff_reduced_of_surjective
      (ZMod.ringHom_surjective <| Int.castRingHom <| ZMod n),
      ZMod.ker_intCastRingHom, â† isRadical_iff_span_singleton, isRadical_iff_squarefree_or_zero,
      Int.squarefree_natCast, Nat.cast_eq_zero]",constructor
Mathlib/FieldTheory/Normal.lean,Normal.minpoly_eq_iff_mem_orbit,Normal.minpoly_eq_iff_mem_orbit,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  refine âŸ¨fun he â†¦ ?_, fun âŸ¨f, heâŸ© â†¦ he â–¸ minpoly.algEquiv_eq f yâŸ©
  let Fx := AdjoinRoot (minpoly F x)
  have hx : aeval x (minpoly F x) = 0 := minpoly.aeval F x
  have hy : aeval y (minpoly F x) = 0 := he â–¸ minpoly.aeval F y
  let Ax : Algebra Fx E := (lift (algebraMap F E) x hx).toAlgebra
  have Tx : IsScalarTower F Fx E := IsScalarTower.of_ring_hom (liftHom _ x hx)
  let Ay : Algebra Fx E := (lift (algebraMap F E) y hy).toAlgebra
  have Ty : IsScalarTower F Fx E := IsScalarTower.of_ring_hom (liftHom _ y hy)
  haveI : Fact (Irreducible <| minpoly F x) := âŸ¨minpoly.irreducible <| h.isIntegral xâŸ©
  let f : E â‰ƒâ‚[F] E := @AlgEquiv.liftNormal F Fx Fx _ _ _ _ _ AlgEquiv.refl E _ _ Ay Ax Ty Tx _
  refine âŸ¨f, (congr_arg f (lift_root hy).symm).trans <| Eq.trans ?_ (lift_root hx)âŸ©
  exact @AlgEquiv.liftNormal_commutes F Fx Fx _ _ _ _ _ _ E _ _ Ay Ax Ty Tx _ (root _)","error:  application type mismatch
  lift (algebraMap F E)
argument
  algebraMap F E
has type
  F â†’+* E : Type (max u_1 u_6)
but is expected to have type
  IntermediateField ?m.245557 â†¥?m.245562 : Type ?u.245555
error:  unknown constant 'IsScalarTower.of_ring_hom'
error:  application type mismatch
  lift (algebraMap F E)
argument
  algebraMap F E
has type
  F â†’+* E : Type (max u_1 u_6)
but is expected to have type
  IntermediateField ?m.258492 â†¥?m.258497 : Type ?u.258490
error:  unknown constant 'IsScalarTower.of_ring_hom'
error:  unknown identifier 'lift_root'
error:  unknown identifier 'lift_root'
error:  unsolved goals
F : Type u_1
K : Type u_2
instâœÂ¹âµ : Field F
instâœÂ¹â´ : Field K
instâœÂ¹Â³ : Algebra F K
Kâ‚ : Type u_3
Kâ‚‚ : Type u_4
Kâ‚ƒ : Type u_5
instâœÂ¹Â² : Field F
instâœÂ¹Â¹ : Field Kâ‚
instâœÂ¹â° : Field Kâ‚‚
instâœâ¹ : Field Kâ‚ƒ
instâœâ¸ : Algebra F Kâ‚
instâœâ· : Algebra F Kâ‚‚
instâœâ¶ : Algebra F Kâ‚ƒ
Ï• : Kâ‚ â†’â‚[F] Kâ‚‚
Ï‡ : Kâ‚ â‰ƒâ‚[F] Kâ‚‚
Ïˆ : Kâ‚‚ â†’â‚[F] Kâ‚ƒ
Ï‰ : Kâ‚‚ â‰ƒâ‚[F] Kâ‚ƒ
E : Type u_6
instâœâµ : Field E
instâœâ´ : Algebra F E
instâœÂ³ : Algebra Kâ‚ E
instâœÂ² : Algebra Kâ‚‚ E
instâœÂ¹ : IsScalarTower F Kâ‚ E
instâœ : IsScalarTower F Kâ‚‚ E
h : Normal F E
x y : E
he : minpoly F x = minpoly F y
Fx : Type u_1 := AdjoinRoot (minpoly F x)
hx : (aeval x) (minpoly F x) = 0
hy : (aeval y) (minpoly F x) = 0
Ax : Algebra Fx E := sorryAx (Algebra Fx E) true
Tx : IsScalarTower F Fx E
Ay : Algebra Fx E := sorryAx (Algebra Fx E) true
Ty : IsScalarTower F Fx E
this : Fact (Irreducible (minpoly F x))
f : E â‰ƒâ‚[F] E := AlgEquiv.refl.liftNormal E
âŠ¢ x âˆˆ MulAction.orbit (E â‰ƒâ‚[F] E) y","theorem Normal.minpoly_eq_iff_mem_orbit [h : Normal F E] {x y : E} :
    minpoly F x = minpoly F y â†” x âˆˆ MulAction.orbit (E â‰ƒâ‚[F] E) y ",":= by
  refine âŸ¨fun he â†¦ ?_, fun âŸ¨f, heâŸ© â†¦ he â–¸ minpoly.algEquiv_eq f yâŸ©
  obtain âŸ¨Ï†, hÏ†âŸ© := exists_algHom_of_splits_of_aeval (normal_iff.mp h) (he â–¸ minpoly.aeval F x)
  exact âŸ¨AlgEquiv.ofBijective Ï† (Ï†.normal_bijective F E E), hÏ†âŸ©",rw [MulAction.mem_orbit_iff_minpoly_eq_iff_minpoly_eq_iff_minpoly_eq_iff_minpoly]
Mathlib/RingTheory/PowerSeries/Basic.lean,Polynomial.coeff_coe,coeff_coe,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":=
  rfl","error:  type mismatch
  rfl
has type
  (PowerSeries.coeff R n) â†‘Ï† = (PowerSeries.coeff R n) â†‘Ï† : Prop
but is expected to have type
  (PowerSeries.coeff R n) â†‘Ï† = Ï†.coeff n : Prop
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated",theorem coeff_coe (n) : PowerSeries.coeff R n Ï† = coeff Ï† n ,":=
  congr_arg (coeff Ï†) Finsupp.single_eq_same","rw [coeff_coe, PowerSeries.coeff_coe]"
Mathlib/RingTheory/Adjoin/Basic.lean,Algebra.mem_adjoin_of_map_mul,mem_adjoin_of_map_mul,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  refine
    @adjoin_induction R A _ _ _ _ _ (fun a => f a âˆˆ adjoin R (f '' (s âˆª {1}))) x h
      (fun a ha => subset_adjoin âŸ¨a, âŸ¨Set.subset_union_left _ _ ha, rflâŸ©âŸ©) (fun r => ?_)
      (fun y z hy hz => by simpa [hy, hz] using Subalgebra.add_mem _ hy hz) fun y z hy hz => by
      simpa [hy, hz, hf y z] using Subalgebra.mul_mem _ hy hz
  have : f 1 âˆˆ adjoin R (f '' (s âˆª {1})) :=
    subset_adjoin âŸ¨1, âŸ¨Set.subset_union_right _ _ <| Set.mem_singleton 1, rflâŸ©âŸ©
  convert Subalgebra.smul_mem (adjoin R (f '' (s âˆª {1}))) this r
  rw [algebraMap_eq_smul_one]
  exact f.map_smul _ _","error:  application type mismatch
  @adjoin_induction R A ?m.65751 ?m.65752 ?m.65753 ?m.65754 ?m.65755 fun a â†¦ f a âˆˆ adjoin R (â‡‘f '' (s âˆª {1}))
argument
  fun a â†¦ f a âˆˆ adjoin R (â‡‘f '' (s âˆª {1}))
has type
  A â†’ Prop : Type uA
but is expected to have type
  A : Type uA
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  ?m.67079 ?m.67080
error:  type mismatch
  hâœ
has type
  ?m.68373 y + ?m.68373 z âˆˆ ?m.68386 : Prop
but is expected to have type
  ?m.68373 (y * z) âˆˆ ?m.68386 : Prop","theorem mem_adjoin_of_map_mul {s} {x : A} {f : A â†’â‚—[R] B} (hf : âˆ€ aâ‚ aâ‚‚, f (aâ‚ * aâ‚‚) = f aâ‚ * f aâ‚‚)
    (h : x âˆˆ adjoin R s) : f x âˆˆ adjoin R (f '' (s âˆª {1})) ",":= by
  refine
    @adjoin_induction R A _ _ _ _ (fun a => f a âˆˆ adjoin R (f '' (s âˆª {1}))) x h
      (fun a ha => subset_adjoin âŸ¨a, âŸ¨Set.subset_union_left ha, rflâŸ©âŸ©) (fun r => ?_)
      (fun y z hy hz => by simpa [hy, hz] using Subalgebra.add_mem _ hy hz) fun y z hy hz => by
      simpa [hy, hz, hf y z] using Subalgebra.mul_mem _ hy hz
  have : f 1 âˆˆ adjoin R (f '' (s âˆª {1})) :=
    subset_adjoin âŸ¨1, âŸ¨Set.subset_union_right <| Set.mem_singleton 1, rflâŸ©âŸ©
  convert Subalgebra.smul_mem (adjoin R (f '' (s âˆª {1}))) this r
  rw [algebraMap_eq_smul_one]
  exact f.map_smul _ _","rw [adjoin_eq_adjoin_union_eq_adjoin_union, adjoin_eq_adjoin_union_eq_adjoin_union, adjoin_eq_adjoin_union]"
Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean,Complex.inv_Gammaâ„_one_sub,inv_Gammaâ„_one_sub,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  have h1 : Gammaâ„ s â‰  0 := by
    rw [Ne.def, Gammaâ„_eq_zero_iff, not_exists]
    intro n h
    specialize hs (2 * n)
    simp_all
  have h2 : âˆ€ (n : â„•), s â‰  -(2 * â†‘n + 1) := by
    intro n h
    specialize hs (2 * n + 1)
    simp_all
  rw [â† Gammaâ„_div_Gammaâ„_one_sub h2, â† div_eq_mul_inv, div_right_comm, div_self h1, one_div]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.74685 â†’ ?m.74685 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.74687
s : â„‚
hs : âˆ€ (n : â„•), s â‰  -â†‘n
âŠ¢ s.Gammaâ„ â‰  0","lemma inv_Gammaâ„_one_sub {s : â„‚} (hs : âˆ€ (n : â„•), s â‰  -n) :
    (Gammaâ„ (1 - s))â»Â¹ = Gammaâ„‚ s * cos (Ï€ * s / 2) * (Gammaâ„ s)â»Â¹ ",":= by
  have h1 : Gammaâ„ s â‰  0 := by
    rw [Ne, Gammaâ„_eq_zero_iff, not_exists]
    intro n h
    specialize hs (2 * n)
    simp_all
  have h2 : âˆ€ (n : â„•), s â‰  -(2 * â†‘n + 1) := by
    intro n h
    specialize hs (2 * n + 1)
    simp_all
  rw [â† Gammaâ„_div_Gammaâ„_one_sub h2, â† div_eq_mul_inv, div_right_comm, div_self h1, one_div]","rw [Gammaâ„_one_sub, Gammaâ„_one_sub]"
Mathlib/Order/RelSeries.lean,RelSeries.rel_of_lt,rel_of_lt,1813fcee84a9bc2e3717fa203ade0efea0eb684d,":= by
  induction i using Fin.inductionOn generalizing j with
  | h0 => induction j using Fin.inductionOn with
    | h0 => cases lt_irrefl _ h
    | hs j ihj =>
      by_cases H : 0 < Fin.castSucc j
      . exact IsTrans.trans _ _ _ (ihj H) (x.step _)
      . convert x.step _
        simp only [not_lt, Fin.le_zero_iff] at H
        exact H.symm
  | hs i _ => induction j using Fin.inductionOn with
    | h0 => cases not_lt_of_lt (Fin.succ_pos i) h
    | hs j ihj =>
      obtain (H|H) : i.succ = Fin.castSucc j âˆ¨ i.succ < Fin.castSucc j
      . change (i + 1 : â„•) < (j + 1 : â„•) at h
        rw [Nat.lt_succ_iff, le_iff_lt_or_eq] at h
        rcases h with (h|h)
        . right
          exact h
        . left
          ext
          exact h
      . rw [H]
        exact x.step _
      . exact IsTrans.trans _ _ _ (ihj H) (x.step _)",error:  invalid alternative name 'h0',"lemma rel_of_lt [IsTrans Î± r] (x : RelSeries r) {i j : Fin (x.length + 1)} (h : i < j) :
    r (x i) (x j) ",":=
  (Fin.liftFun_iff_succ r).mpr x.step h",rw [IsTrans.length_length] at j
Mathlib/Data/DFinsupp/WellFounded.lean,Pi.Lex.wellFounded,Pi.Lex.wellFounded,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  obtain h | âŸ¨âŸ¨xâŸ©âŸ© := isEmpty_or_nonempty (âˆ€ i, Î± i)
  Â· convert emptyWf.wf
  letI : âˆ€ i, Zero (Î± i) := fun i => âŸ¨(hs i).min âŠ¤ âŸ¨x i, trivialâŸ©âŸ©
  haveI := IsTrans.swap r; haveI := IsIrrefl.swap r; haveI := Fintype.ofFinite Î¹
  refine InvImage.wf equivFunOnFintype.symm (Lex.wellFounded' (fun i a => ?_) hs? _)
  exacts [(hs i).not_lt_min âŠ¤ _ trivial, Finite.wellFounded_of_trans_of_irrefl (Function.swap r)]","error:  unknown identifier 'hs?'
error:  unsolved goals
case inr.intro
Î¹ : Type u_1
Î± : Î¹ â†’ Type u_2
r : Î¹ â†’ Î¹ â†’ Prop
s : (i : Î¹) â†’ Î± i â†’ Î± i â†’ Prop
instâœÂ¹ : IsStrictTotalOrder Î¹ r
instâœ : Finite Î¹
hs : âˆ€ (i : Î¹), WellFounded (s i)
x : (i : Î¹) â†’ Î± i
thisâœÂ² : (i : Î¹) â†’ Zero (Î± i) := fun i â†¦ { zero := â‹¯.min âŠ¤ â‹¯ }
thisâœÂ¹ : IsTrans Î¹ (Function.swap r)
thisâœ : IsIrrefl Î¹ (Function.swap r)
this : Fintype Î¹
âŠ¢ WellFounded (Pi.Lex r fun {i} â†¦ s i)","theorem Pi.Lex.wellFounded [IsStrictTotalOrder Î¹ r] [Finite Î¹] (hs : âˆ€ i, WellFounded (s i)) :
    WellFounded (Pi.Lex r (fun {i} â†¦ s i)) ",":= by
  obtain h | âŸ¨âŸ¨xâŸ©âŸ© := isEmpty_or_nonempty (âˆ€ i, Î± i)
  Â· convert emptyWf.wf
  letI : âˆ€ i, Zero (Î± i) := fun i => âŸ¨(hs i).min âŠ¤ âŸ¨x i, trivialâŸ©âŸ©
  haveI := IsTrans.swap r; haveI := IsIrrefl.swap r; haveI := Fintype.ofFinite Î¹
  refine InvImage.wf equivFunOnFintype.symm (Lex.wellFounded' (fun i a => ?_) hs ?_)
  exacts [(hs i).not_lt_min âŠ¤ _ trivial, Finite.wellFounded_of_trans_of_irrefl (Function.swap r)]","simp only [IsStrictTotalOrder, IsStrictTotalOrder.wellFounded_isStrictTotalOrder,
  IsStrictTotalOrder.wellFounded_wellFounded_iff]"
Mathlib/Analysis/Convex/Caratheodory.lean,Caratheodory.mem_convexHull_erase,mem_convexHull_erase,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  simp only [Finset.convexHull_eq, mem_setOf_eq] at m âŠ¢
  obtain âŸ¨f, fpos, fsum, rflâŸ© := m
  obtain âŸ¨g, gcombo, gsum, gposâŸ© := exists_nontrivial_relation_sum_zero_of_not_affine_ind h
  replace gpos := exists_pos_of_sum_zero_of_exists_nonzero g gsum gpos
  clear h
  let s := @Finset.filter _ (fun z => 0 < g z) (fun _ => LinearOrder.decidableLT _ _) t
  obtain âŸ¨iâ‚€, mem, wâŸ© : âˆƒ iâ‚€ âˆˆ s, âˆ€ i âˆˆ s, f iâ‚€ / g iâ‚€ â‰¤ f i / g i := by
    apply s.exists_min_image fun z => f z / g z
    obtain âŸ¨x, hx, hgxâŸ© : âˆƒ x âˆˆ t, 0 < g x := gpos
    exact âŸ¨x, mem_filter.mpr âŸ¨hx, hgxâŸ©âŸ©
  have hg : 0 < g iâ‚€ := by
    rw [mem_filter] at mem
    exact mem.2
  have hiâ‚€ : iâ‚€ âˆˆ t := filter_subset _ _ mem
  let k : E â†’ ğ•œ := fun z => f z - f iâ‚€ / g iâ‚€ * g z
  have hk : k iâ‚€ = 0 := by field_simp [k, ne_of_gt hg]
  have ksum : âˆ‘ e in t.erase iâ‚€, k e = 1 := by
    calc
      âˆ‘ e in t.erase iâ‚€, k e = âˆ‘ e in t, k e := by
        conv_rhs => rw [â† insert_erase hiâ‚€, sum_insert (not_mem_erase iâ‚€ t), hk, zero_add]
      _ = âˆ‘ e in t, (f e - f iâ‚€ / g iâ‚€ * g e) := rfl
      _ = 1 := by rw [sum_sub_distrib, fsum, â† mul_sum, gsum, mul_zero, sub_zero]
  refine' âŸ¨âŸ¨iâ‚€, hiâ‚€âŸ©, k, _, by convert ksum, _âŸ©
  Â· simp only [k, and_imp, sub_nonneg, mem_erase, Ne.def, Subtype.coe_mk]
    intro e _ het
    by_cases hes : e âˆˆ s
    Â· have hge : 0 < g e := by
        rw [mem_filter] at hes
        exact hes.2
      rw [â† le_div_iff hge]
      exact w _ hes
    Â· calc
        _ â‰¤ 0 := by
          apply mul_nonpos_of_nonneg_of_nonpos
          Â· apply div_nonneg (fpos iâ‚€ (mem_of_subset (filter_subset _ t) mem)) (le_of_lt hg)
          Â· simpa only [s, mem_filter, het, true_and_iff, not_lt] using hes
        _ â‰¤ f e := fpos e het
  Â· rw [Subtype.coe_mk, centerMass_eq_of_sum_1 _ id ksum]
    calc
      âˆ‘ e in t.erase iâ‚€, k e â€¢ e = âˆ‘ e in t, k e â€¢ e := sum_erase _ (by rw [hk, zero_smul])
      _ = âˆ‘ e in t, (f e - f iâ‚€ / g iâ‚€ * g e) â€¢ e := rfl
      _ = t.centerMass f id := by
        simp only [sub_smul, mul_smul, sum_sub_distrib, â† smul_sum, gcombo, smul_zero, sub_zero,
          centerMass, fsum, inv_one, one_smul, id.def]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.12511 â†’ ?m.12511 â†’ Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.20170 â†’ ?m.20170
error:  unsolved goals
ğ•œ : Type u_1
E : Type u
instâœÂ³ : LinearOrderedField ğ•œ
instâœÂ² : AddCommGroup E
instâœÂ¹ : Module ğ•œ E
instâœ : DecidableEq E
t : Finset E
f : E â†’ ğ•œ
fpos : âˆ€ y âˆˆ t, 0 â‰¤ f y
fsum : âˆ‘ y âˆˆ t, f y = 1
g : E â†’ ğ•œ
gcombo : âˆ‘ e âˆˆ t, g e â€¢ e = 0
gsum : âˆ‘ e âˆˆ t, g e = 0
gpos : âˆƒ i âˆˆ t, 0 < g i
s : Finset E := filter (fun z â†¦ 0 < g z) t
iâ‚€ : E
mem : iâ‚€ âˆˆ s
w : âˆ€ i âˆˆ s, f iâ‚€ / g iâ‚€ â‰¤ f i / g i
hg : 0 < g iâ‚€
hiâ‚€ : iâ‚€ âˆˆ t
k : E â†’ ğ•œ := fun z â†¦ f z - f iâ‚€ / g iâ‚€ * g z
hk : k iâ‚€ = 0
ksum : âˆ‘ e âˆˆ t.erase iâ‚€, k e = 1
âŠ¢ âˆ‘ x âˆˆ t, f x â€¢ x = âˆ‘ i âˆˆ t, f i â€¢ id i","theorem mem_convexHull_erase [DecidableEq E] {t : Finset E} (h : Â¬AffineIndependent ğ•œ ((â†‘) : t â†’ E))
    {x : E} (m : x âˆˆ convexHull ğ•œ (â†‘t : Set E)) :
    âˆƒ y : (â†‘t : Set E), x âˆˆ convexHull ğ•œ (â†‘(t.erase y) : Set E) ",":= by
  simp only [Finset.convexHull_eq, mem_setOf_eq] at m âŠ¢
  obtain âŸ¨f, fpos, fsum, rflâŸ© := m
  obtain âŸ¨g, gcombo, gsum, gposâŸ© := exists_nontrivial_relation_sum_zero_of_not_affine_ind h
  replace gpos := exists_pos_of_sum_zero_of_exists_nonzero g gsum gpos
  clear h
  let s := @Finset.filter _ (fun z => 0 < g z) (fun _ => LinearOrder.decidableLT _ _) t
  obtain âŸ¨iâ‚€, mem, wâŸ© : âˆƒ iâ‚€ âˆˆ s, âˆ€ i âˆˆ s, f iâ‚€ / g iâ‚€ â‰¤ f i / g i := by
    apply s.exists_min_image fun z => f z / g z
    obtain âŸ¨x, hx, hgxâŸ© : âˆƒ x âˆˆ t, 0 < g x := gpos
    exact âŸ¨x, mem_filter.mpr âŸ¨hx, hgxâŸ©âŸ©
  have hg : 0 < g iâ‚€ := by
    rw [mem_filter] at mem
    exact mem.2
  have hiâ‚€ : iâ‚€ âˆˆ t := filter_subset _ _ mem
  let k : E â†’ ğ•œ := fun z => f z - f iâ‚€ / g iâ‚€ * g z
  have hk : k iâ‚€ = 0 := by field_simp [k, ne_of_gt hg]
  have ksum : âˆ‘ e âˆˆ t.erase iâ‚€, k e = 1 := by
    calc
      âˆ‘ e âˆˆ t.erase iâ‚€, k e = âˆ‘ e âˆˆ t, k e := by
        conv_rhs => rw [â† insert_erase hiâ‚€, sum_insert (not_mem_erase iâ‚€ t), hk, zero_add]
      _ = âˆ‘ e âˆˆ t, (f e - f iâ‚€ / g iâ‚€ * g e) := rfl
      _ = 1 := by rw [sum_sub_distrib, fsum, â† mul_sum, gsum, mul_zero, sub_zero]
  refine âŸ¨âŸ¨iâ‚€, hiâ‚€âŸ©, k, ?_, by convert ksum, ?_âŸ©
  Â· simp only [k, and_imp, sub_nonneg, mem_erase, Ne, Subtype.coe_mk]
    intro e _ het
    by_cases hes : e âˆˆ s
    Â· have hge : 0 < g e := by
        rw [mem_filter] at hes
        exact hes.2
      rw [â† le_div_iff hge]
      exact w _ hes
    Â· calc
        _ â‰¤ 0 := by
          apply mul_nonpos_of_nonneg_of_nonpos
          Â· apply div_nonneg (fpos iâ‚€ (mem_of_subset (filter_subset _ t) mem)) (le_of_lt hg)
          Â· simpa only [s, mem_filter, het, true_and_iff, not_lt] using hes
        _ â‰¤ f e := fpos e het
  Â· rw [Subtype.coe_mk, centerMass_eq_of_sum_1 _ id ksum]
    calc
      âˆ‘ e âˆˆ t.erase iâ‚€, k e â€¢ e = âˆ‘ e âˆˆ t, k e â€¢ e := sum_erase _ (by rw [hk, zero_smul])
      _ = âˆ‘ e âˆˆ t, (f e - f iâ‚€ / g iâ‚€ * g e) â€¢ e := rfl
      _ = t.centerMass f id := by
        simp only [sub_smul, mul_smul, sum_sub_distrib, â† smul_sum, gcombo, smul_zero, sub_zero,
          centerMass, fsum, inv_one, one_smul, id]","simp only [convexHull_erase, mem_convexHull_erase] at m"
Mathlib/Topology/CompactOpen.lean,ContinuousMap.continuous_comp,continuous_comp,07d28ef76de6fda605a7eb6f6c9ef70c5c90b329,":= by
  simp_rw (config := { instances := true }) [compactOpen_eq, continuous_generateFrom_iff,
    forall_image2_iff, mapsTo']
  rfl","error:  'instances' is not a field of structure 'Lean.Meta.Simp.Config'
error:  cannot evaluate code because 'sorryAx' uses 'sorry' and/or contains errors
warning:  `ContinuousMap.curry'` has been deprecated, use `ContinuousMap.curry` instead","lemma continuous_compactOpen {f : X â†’ C(Y, Z)} :
    Continuous f â†” âˆ€ K, IsCompact K â†’ âˆ€ U, IsOpen U â†’ IsOpen {x | MapsTo (f x) K U} ",":=
  continuous_generateFrom_iff.trans forall_image2_iff",constructor
Mathlib/Analysis/NormedSpace/FiniteDimension.lean,FiniteDimensional.of_isCompact_closedBall,FiniteDimensional.of_isCompact_closedBall,90f5fd4c1996deb807707cc41958c83c37f900bc,":= by
  by_contra hfin
  obtain âŸ¨R, f, Rgt, fle, lefâŸ© :
    âˆƒ (R : â„) (f : â„• â†’ E), 1 < R âˆ§ (âˆ€ n, â€–f nâ€– â‰¤ R) âˆ§ Pairwise fun m n => 1 â‰¤ â€–f m - f nâ€– :=
    exists_seq_norm_le_one_le_norm_sub hfin
  have rRpos : 0 < r / R := div_pos rpos (zero_lt_one.trans Rgt)
  obtain âŸ¨c, hcâŸ© : âˆƒ c : ğ•œ, 0 < â€–câ€– âˆ§ â€–câ€– < r / R := NormedField.exists_norm_lt _ rRpos
  let g := fun n : â„• => c â€¢ f n
  have A : âˆ€ n, g n âˆˆ Metric.closedBall (0 : E) r := by
    intro n
    simp only [norm_smul, dist_zero_right, Metric.mem_closedBall]
    calc
      â€–câ€– * â€–f nâ€– â‰¤ r / R * R := by gcongr; exact hc.2.le; apply fle
      _ = r := by field_simp [(zero_lt_one.trans Rgt).ne']
  obtain âŸ¨x : E, _ : x âˆˆ Metric.closedBall (0 : E) r, Ï† : â„• â†’ â„•, Ï†mono : StrictMono Ï†,
    Ï†lim : Tendsto (g âˆ˜ Ï†) atTop (ğ“ x)âŸ© := h.tendsto_subseq A
  have B : CauchySeq (g âˆ˜ Ï†) := Ï†lim.cauchySeq
  obtain âŸ¨N, hNâŸ© : âˆƒ N : â„•, âˆ€ n : â„•, N â‰¤ n â†’ dist ((g âˆ˜ Ï†) n) ((g âˆ˜ Ï†) N) < â€–câ€– :=
    Metric.cauchySeq_iff'.1 B â€–câ€– hc.1
  apply lt_irrefl â€–câ€–
  calc
    â€–câ€– â‰¤ dist (g (Ï† (N + 1))) (g (Ï† N)) := by
      conv_lhs => rw [â† mul_one â€–câ€–]
      simp only [dist_eq_norm, â† smul_sub, norm_smul]
      gcongr
      apply lef (ne_of_gt _)
      exact Ï†mono (Nat.lt_succ_self N)
    _ < â€–câ€– := hN (N + 1) (Nat.le_succ N)","error:  'calc' tactic failed, has type
  â€–câ€– * â€–f nâ€– â‰¤ r
but it is expected to have type
  â€–g nâ€– â‰¤ r
error:  gcongr did not make progress","theorem FiniteDimensional.of_isCompact_closedBallâ‚€ {r : â„} (rpos : 0 < r)
    (h : IsCompact (Metric.closedBall (0 : E) r)) : FiniteDimensional ğ•œ E ",":= by
  by_contra hfin
  obtain âŸ¨R, f, Rgt, fle, lefâŸ© :
    âˆƒ (R : â„) (f : â„• â†’ E), 1 < R âˆ§ (âˆ€ n, â€–f nâ€– â‰¤ R) âˆ§ Pairwise fun m n => 1 â‰¤ â€–f m - f nâ€– :=
    exists_seq_norm_le_one_le_norm_sub hfin
  have rRpos : 0 < r / R := div_pos rpos (zero_lt_one.trans Rgt)
  obtain âŸ¨c, hcâŸ© : âˆƒ c : ğ•œ, 0 < â€–câ€– âˆ§ â€–câ€– < r / R := NormedField.exists_norm_lt _ rRpos
  let g := fun n : â„• => c â€¢ f n
  have A : âˆ€ n, g n âˆˆ Metric.closedBall (0 : E) r := by
    intro n
    simp only [g, norm_smul, dist_zero_right, Metric.mem_closedBall]
    calc
      â€–câ€– * â€–f nâ€– â‰¤ r / R * R := by
        gcongr
        Â· exact hc.2.le
        Â· apply fle
      _ = r := by field_simp [(zero_lt_one.trans Rgt).ne']
  obtain âŸ¨x : E, _ : x âˆˆ Metric.closedBall (0 : E) r, Ï† : â„• â†’ â„•, Ï†mono : StrictMono Ï†,
    Ï†lim : Tendsto (g âˆ˜ Ï†) atTop (ğ“ x)âŸ© := h.tendsto_subseq A
  have B : CauchySeq (g âˆ˜ Ï†) := Ï†lim.cauchySeq
  obtain âŸ¨N, hNâŸ© : âˆƒ N : â„•, âˆ€ n : â„•, N â‰¤ n â†’ dist ((g âˆ˜ Ï†) n) ((g âˆ˜ Ï†) N) < â€–câ€– :=
    Metric.cauchySeq_iff'.1 B â€–câ€– hc.1
  apply lt_irrefl â€–câ€–
  calc
    â€–câ€– â‰¤ dist (g (Ï† (N + 1))) (g (Ï† N)) := by
      conv_lhs => rw [â† mul_one â€–câ€–]
      simp only [g, dist_eq_norm, â† smul_sub, norm_smul]
      gcongr
      apply lef (ne_of_gt _)
      exact Ï†mono (Nat.lt_succ_self N)
    _ < â€–câ€– := hN (N + 1) (Nat.le_succ N)",refine FiniteDimensional.finiteDimensional_finiteDimensional_finiteDimensional_finiteDimensional_finiteDimensional.finiteDimensional
Mathlib/LinearAlgebra/BilinearForm/DualLattice.lean,LinearMap.BilinForm.dualSubmodule_span_of_basis,dualSubmodule_span_of_basis,cd68b7a40dc884fd8f92d1fb14fa44c2c646ab69,":= by
  cases nonempty_fintype Î¹
  apply le_antisymm
  Â· intro x hx
    rw [â† (B.dualBasis hB b).sum_repr x]
    apply sum_mem
    rintro i -
    obtain âŸ¨r, hrâŸ© := hx (b i) (Submodule.subset_span âŸ¨_, rflâŸ©)
    simp only [dualBasis_repr_apply, â† hr, Algebra.linearMap_apply, algebraMap_smul]
    apply Submodule.smul_mem
    exact Submodule.subset_span âŸ¨_, rflâŸ©
  Â· rw [Submodule.span_le]
    rintro _ âŸ¨i, rflâŸ© y hy
    obtain âŸ¨f, rflâŸ© := (mem_span_range_iff_exists_fun _).mp hy
    simp only [sum_right, bilin_smul_right]
    apply sum_mem
    rintro j -
    rw [â† IsScalarTower.algebraMap_smul S (f j), B.bilin_smul_right, apply_dualBasis_left,
      mul_ite, mul_one, mul_zero, â† (algebraMap R S).map_zero, â† apply_ite]
    exact âŸ¨_, rflâŸ©","error:  unknown identifier 'bilin_smul_right'
error:  invalid field 'bilin_smul_right', the environment does not contain 'LinearMap.BilinForm.bilin_smul_right'
  B
has type
  BilinForm S M
error:  invalid field 'bilin_smul_right', the environment does not contain 'LinearMap.bilin_smul_right'
  B
has type
  M â†’â‚—[S] M â†’â‚—[S] S
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.149359
case intro.a.intro.intro.h
R : Type u_4
S : Type u_2
M : Type u_3
instâœâ¸ : CommRing R
instâœâ· : Field S
instâœâ¶ : AddCommGroup M
instâœâµ : Algebra R S
instâœâ´ : Module R M
instâœÂ³ : Module S M
instâœÂ² : IsScalarTower R S M
B : BilinForm S M
Î¹ : Type u_1
instâœÂ¹ : Finite Î¹
instâœ : DecidableEq Î¹
hB : B.Nondegenerate
b : Basis Î¹ S M
valâœ : Fintype Î¹
i : Î¹
f : Î¹ â†’ R
hy : âˆ‘ i : Î¹, f i â€¢ b i âˆˆ Submodule.span R (Set.range â‡‘b)
j : Î¹
âŠ¢ (B ((B.dualBasis hB b) i)) ((algebraMap R S) (f j) â€¢ b j) âˆˆ 1","lemma dualSubmodule_span_of_basis {Î¹} [Finite Î¹] [DecidableEq Î¹]
    (hB : B.Nondegenerate) (b : Basis Î¹ S M) :
    B.dualSubmodule (Submodule.span R (Set.range b)) =
      Submodule.span R (Set.range <| B.dualBasis hB b) ",":= by
  cases nonempty_fintype Î¹
  apply le_antisymm
  Â· intro x hx
    rw [â† (B.dualBasis hB b).sum_repr x]
    apply sum_mem
    rintro i -
    obtain âŸ¨r, hrâŸ© := hx (b i) (Submodule.subset_span âŸ¨_, rflâŸ©)
    simp only [dualBasis_repr_apply, â† hr, Algebra.linearMap_apply, algebraMap_smul]
    apply Submodule.smul_mem
    exact Submodule.subset_span âŸ¨_, rflâŸ©
  Â· rw [Submodule.span_le]
    rintro _ âŸ¨i, rflâŸ© y hy
    obtain âŸ¨f, rflâŸ© := (mem_span_range_iff_exists_fun _).mp hy
    simp only [map_sum, map_smul]
    apply sum_mem
    rintro j -
    rw [â† IsScalarTower.algebraMap_smul S (f j), map_smul]
    simp_rw [apply_dualBasis_left]
    rw [smul_eq_mul, mul_ite, mul_one, mul_zero, â† (algebraMap R S).map_zero, â† apply_ite]
    exact âŸ¨_, rflâŸ©",rw [â† Submodule.span_eq]
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.flatten_think,flatten_think,938069ac7c83a4980c46ca108d9947ab788c12ee,":=
  Seq'.destruct_eq_cons <| by simp [flatten, think]",error:  unknown identifier 'Seq'.destruct_eq_cons',theorem flatten_think (c : Computation (WSeq Î±)) : flatten c.think = think (flatten c) ,":=
  Seq.destruct_eq_cons <| by simp [flatten, think]",apply think_eq_think_of_think_eq
Mathlib/GroupTheory/Sylow.lean,Sylow.prime_dvd_card_quotient_normalizer,prime_dvd_card_quotient_normalizer,bb4cd53d3a46e1a0c6139fc0c07b126817cf1b6c,":=
  let âŸ¨s, hsâŸ© := exists_eq_mul_left_of_dvd hdvd
  have hcard : card (G â§¸ H) = s * p :=
    (mul_left_inj' (show card H â‰  0 from Fintype.card_ne_zero)).1
      (by
        rw [â† card_eq_card_quotient_mul_card_subgroup H, hH, hs, pow_succ', mul_assoc, mul_comm p])
  have hm :
    s * p % p =
      card (normalizer H â§¸ Subgroup.comap ((normalizer H).subtype : normalizer H â†’* G) H) % p :=
    hcard â–¸ (card_quotient_normalizer_modEq_card_quotient hH).symm
  Nat.dvd_of_mod_eq_zero (by rwa [Nat.mod_eq_zero_of_dvd (dvd_mul_left _ _), eq_comm] at hm)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.card (G â§¸ H) * Nat.card â†¥H
G : Type u
Î± : Type v
Î² : Type w
instâœÂ¹ : Group G
instâœ : Fintype G
p n : â„•
hp : Fact (Nat.Prime p)
hdvd : p ^ (n + 1) âˆ£ Fintype.card G
H : Subgroup G
hH : Fintype.card â†¥H = p ^ n
s : â„•
hs : Fintype.card G = s * p ^ (n + 1)
âŠ¢ Fintype.card (G â§¸ H) * Fintype.card â†¥H = s * p * Fintype.card â†¥H","theorem prime_dvd_card_quotient_normalizer [Fintype G] {p : â„•} {n : â„•} [hp : Fact p.Prime]
    (hdvd : p ^ (n + 1) âˆ£ card G) {H : Subgroup G} (hH : Fintype.card H = p ^ n) :
    p âˆ£ card (normalizer H â§¸ Subgroup.comap ((normalizer H).subtype : normalizer H â†’* G) H) ",":=
  let âŸ¨s, hsâŸ© := exists_eq_mul_left_of_dvd hdvd
  have hcard : card (G â§¸ H) = s * p :=
    (mul_left_inj' (show card H â‰  0 from Fintype.card_ne_zero)).1
      (by
        simp only [â† Nat.card_eq_fintype_card] at hs hH âŠ¢
        rw [â† card_eq_card_quotient_mul_card_subgroup H, hH, hs, pow_succ', mul_assoc, mul_comm p])
  have hm :
    s * p % p =
      card (normalizer H â§¸ Subgroup.comap ((normalizer H).subtype : normalizer H â†’* G) H) % p :=
    hcard â–¸ (card_quotient_normalizer_modEq_card_quotient hH).symm
  Nat.dvd_of_mod_eq_zero (by rwa [Nat.mod_eq_zero_of_dvd (dvd_mul_left _ _), eq_comm] at hm)",apply card_quotient_normalizer_quotient_normalizer
Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean,AlgebraicGeometry.sourceAffineLocally_respectsIso,sourceAffineLocally_respectsIso,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  apply AffineTargetMorphismProperty.respectsIso_mk
  Â· introv H U
    rw [â† hâ‚.cancel_right_isIso _ (Scheme.Î“.map (Scheme.restrictMapIso e.inv U.1).hom.op), â†
      Functor.map_comp, â† op_comp]
    convert H âŸ¨_, U.prop.map_isIso e.invâŸ© using 3
    haveI i1 : IsOpenImmersion
      (Scheme.ofRestrict Y ((Opens.map e.inv.val.base).obj U.1).openEmbedding â‰« e.inv) :=
      PresheafedSpace.IsOpenImmersion.comp _ _
    rw [IsOpenImmersion.isoOfRangeEq_hom_fac_assoc, Category.assoc,
      e.inv_hom_id_assoc]
  Â· introv H U
    rw [â† Category.assoc, op_comp, Functor.map_comp, hâ‚.cancel_left_isIso]
    exact H U","error:  invalid field 'map_isIso', the environment does not contain 'Membership.mem.map_isIso'
  Subtype.prop U
has type
  â†‘U âˆˆ X.affineOpens
error:  invalid field 'map_isIso', the environment does not contain 'Set.Mem.map_isIso'
  Subtype.prop U
has type
  Set.Mem (â†‘U) X.affineOpens
error:  invalid field 'map_isIso', the environment does not contain 'AlgebraicGeometry.Scheme.affineOpens.map_isIso'
  Subtype.prop U
has type
  X.affineOpens â†‘U
error:  invalid field 'map_isIso', the environment does not contain 'setOf.map_isIso'
  Subtype.prop U
has type
  {U | IsAffineOpen U} â†‘U
error:  invalid field 'map_isIso', the environment does not contain 'AlgebraicGeometry.IsAffineOpen.map_isIso'
  Subtype.prop U
has type
  IsAffineOpen â†‘U
error:  invalid field 'map_isIso', the environment does not contain 'AlgebraicGeometry.IsAffine.map_isIso'
  Subtype.prop U
has type
  IsAffine (X.restrict â‹¯)
error:  (deterministic) timeout at `isDefEq`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'sourceAffineLocally_respectsIso'
error:  unknown identifier 'sourceAffineLocally_respectsIso'
error:  unknown identifier 'sourceAffineLocally_respectsIso'","theorem sourceAffineLocally_respectsIso (hâ‚ : RingHom.RespectsIso @P) :
    (sourceAffineLocally @P).toProperty.RespectsIso ",":= by
  apply AffineTargetMorphismProperty.respectsIso_mk
  Â· introv H U
    rw [â† hâ‚.cancel_right_isIso _ (Scheme.Î“.map (Scheme.restrictMapIso e.inv U.1).hom.op), â†
      Functor.map_comp, â† op_comp]
    convert H âŸ¨_, U.prop.preimage_of_isIso e.invâŸ© using 3
    rw [IsOpenImmersion.isoOfRangeEq_hom_fac_assoc, Category.assoc,
      e.inv_hom_id_assoc]
  Â· introv H U
    rw [â† Category.assoc, op_comp, Functor.map_comp, hâ‚.cancel_left_isIso]
    exact H U",apply RespectsIso.respectsIso
Mathlib/Algebra/GradedMonoid.lean,SetLike.coe_list_dProd,SetLike.coe_list_dProd,241f6b3d77b73c8cf9cc212ebc1a27303a68c65d,":= by
  match l with
  | [] =>
    rw [List.dProd_nil, coe_gOne, List.map_nil, List.prod_nil]
  | head::tail =>
    rw [List.dProd_cons, coe_gMul, List.map_cons, List.prod_cons',
      SetLike.coe_list_dProd _ _ _ tail]","error:  unknown constant 'List.prod_cons''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.50118
Î¹ : Type u_1
R : Type u_2
Î± : Type u_3
S : Type u_4
instâœÂ³ : SetLike S R
instâœÂ² : Monoid R
instâœÂ¹ : AddMonoid Î¹
A : Î¹ â†’ S
instâœ : GradedMonoid A
fÎ¹ : Î± â†’ Î¹
fA : (a : Î±) â†’ â†¥(A (fÎ¹ a))
l : List Î±
head : Î±
tail : List Î±
âŠ¢ â†‘(fA head) * â†‘(tail.dProd fÎ¹ fA) = (â†‘(fA head) :: List.map (fun a â†¦ â†‘(fA a)) tail).prod","theorem SetLike.coe_list_dProd (A : Î¹ â†’ S) [SetLike.GradedMonoid A] (fÎ¹ : Î± â†’ Î¹)
    (fA : âˆ€ a, A (fÎ¹ a)) (l : List Î±) : â†‘(@List.dProd _ _ (fun i => â†¥(A i)) _ _ l fÎ¹ fA)
    = (List.prod (l.map fun a => fA a) : R) ",":= by
  match l with
  | [] =>
    rw [List.dProd_nil, coe_gOne, List.map_nil, List.prod_nil]
  | head::tail =>
    rw [List.dProd_cons, coe_gMul, List.map_cons, List.prod_cons,
      SetLike.coe_list_dProd _ _ _ tail]","simp only [List.map, List.map_map, List.prod_map, List.map_map, List.map_map,
  List.prod_cons, List.map_map, List.prod_cons, List.dProd_cons, List.dProd_map,
  List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_map,
  List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_map,
  List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_map,
  List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_map, List.dProd_map,
  List.dProd_cons, List.dProd_cons, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_cons, List.dProd_cons, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_cons, List.dProd_cons, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_cons, List.dProd_cons, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_cons, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_cons, List.dProd_cons, List.dProd_map, List.dProd_cons, List.dProd_map,
  List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_map,
  List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_cons, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_cons, List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map,
  List.dProd_map, List.dProd_map, List.dProd_map, List.dProd_map, Lis"
Mathlib/Order/WithBot.lean,WithTop.some_lt_some,some_lt_some,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  simp [LT.lt]","error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Î´ : Type u_4
a b : Î±
instâœ : LT Î±
âŠ¢ (âˆƒ b_1, Option.some b = â†‘b_1 âˆ§ âˆ€ (a_1 : Î±), Option.some a = â†‘a_1 â†’ a_1 < b_1) â†” a < b",theorem some_lt_some : @LT.lt (WithBot Î±) _ (Option.some a) (Option.some b) â†” a < b ,":=
  coe_lt_coe",simp only [Option.some_eq_some] at some_lt_some
Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean,Matrix.det_eq_of_forall_row_eq_smul_add_const,det_eq_of_forall_row_eq_smul_add_const,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction s generalizing B with
  | empty =>
    rintro c hs k - A_eq
    have : âˆ€ i, c i = 0 := by
      intro i
      specialize hs i
      contrapose! hs
      simp [hs]
    congr
    ext i j
    rw [A_eq, this, zero_mul, add_zero]
  | @insert i s _hi ih =>
    intro c hs k hk A_eq
    have hAi : A i = B i + c i â€¢ B k := funext (A_eq i)
    rw [@ih (updateRow B i (A i)) (Function.update c i 0), hAi, det_updateRow_add_smul_self]
    Â· exact mt (fun h => show k âˆˆ insert i s from h â–¸ Finset.mem_insert_self _ _) hk
    Â· intro i' hi'
      rw [Function.update_apply]
      split_ifs with hi'i
      Â· rfl
      Â· exact hs i' fun h => hi' ((Finset.mem_insert.mp h).resolve_left hi'i)
    Â· exact k
    Â· exact fun h => hk (Finset.mem_insert_of_mem h)
    Â· intro i' j'
      rw [updateRow_apply, Function.update_apply]
      split_ifs with hi'i
      Â· simp [hi'i]
      rw [A_eq, updateRow_ne fun h : k = i => hk <| h â–¸ Finset.mem_insert_self k s]",error:  invalid alternative name 'empty',"theorem det_eq_of_forall_row_eq_smul_add_const_aux {A B : Matrix n n R} {s : Finset n} :
    âˆ€ (c : n â†’ R) (_ : âˆ€ i, i âˆ‰ s â†’ c i = 0) (k : n) (_ : k âˆ‰ s)
      (_: âˆ€ i j, A i j = B i j + c i * B k j), det A = det B ",":= by
  induction s using Finset.induction_on generalizing B with
  | empty =>
    rintro c hs k - A_eq
    have : âˆ€ i, c i = 0 := by
      intro i
      specialize hs i
      contrapose! hs
      simp [hs]
    congr
    ext i j
    rw [A_eq, this, zero_mul, add_zero]
  | @insert i s _hi ih =>
    intro c hs k hk A_eq
    have hAi : A i = B i + c i â€¢ B k := funext (A_eq i)
    rw [@ih (updateRow B i (A i)) (Function.update c i 0), hAi, det_updateRow_add_smul_self]
    Â· exact mt (fun h => show k âˆˆ insert i s from h â–¸ Finset.mem_insert_self _ _) hk
    Â· intro i' hi'
      rw [Function.update_apply]
      split_ifs with hi'i
      Â· rfl
      Â· exact hs i' fun h => hi' ((Finset.mem_insert.mp h).resolve_left hi'i)
    Â· exact k
    Â· exact fun h => hk (Finset.mem_insert_of_mem h)
    Â· intro i' j'
      rw [updateRow_apply, Function.update_apply]
      split_ifs with hi'i
      Â· simp [hi'i]
      rw [A_eq, updateRow_ne fun h : k = i => hk <| h â–¸ Finset.mem_insert_self k s]","simp only [det_eq_of_forall_row_eq_smul_add_const_aux, det_eq_of_forall_row_eq_smul_add_const_aux,
  det_eq_of_forall_row_eq_smul_add_const_aux]"
Mathlib/CategoryTheory/Abelian/Pseudoelements.lean,CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono,pseudo_injective_of_mono,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  intro abar abar'
  refine' Quotient.inductionOnâ‚‚ abar abar' fun a a' ha => _
  apply Quotient.sound
  have : âŸ¦(a.hom â‰« f : Over Q)âŸ§ = âŸ¦â†‘(a'.hom â‰« f)âŸ§ := by convert ha
  have âŸ¨R, p, q, ep, Eq, commâŸ© := Quotient.exact this
  exact âŸ¨R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact commâŸ©","error:  don't know how to synthesize implicit argument 'Î±'
  @Eq (Quotient ?m.42591) âŸ¦Over.mk (a.hom â‰« f)âŸ§ âŸ¦Over.mk (a'.hom â‰« f)âŸ§
context:
C : Type u
instâœÂ² : Category.{v, u} C
instâœÂ¹ : Abelian C
P Q : C
f : P âŸ¶ Q
instâœ : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f âŸ¦aâŸ§ = pseudoApply f âŸ¦a'âŸ§
âŠ¢ Type (max u v)
error:  don't know how to synthesize placeholder for argument 's'
context:
C : Type u
instâœÂ² : Category.{v, u} C
instâœÂ¹ : Abelian C
P Q : C
f : P âŸ¶ Q
instâœ : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f âŸ¦aâŸ§ = pseudoApply f âŸ¦a'âŸ§
âŠ¢ Setoid (Over Q)
error:  don't know how to synthesize placeholder for argument 's'
context:
C : Type u
instâœÂ² : Category.{v, u} C
instâœÂ¹ : Abelian C
P Q : C
f : P âŸ¶ Q
instâœ : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f âŸ¦aâŸ§ = pseudoApply f âŸ¦a'âŸ§
âŠ¢ Setoid (Over Q)
error:  unsolved goals
case a
C : Type u
instâœÂ² : Category.{v, u} C
instâœÂ¹ : Abelian C
P Q : C
f : P âŸ¶ Q
instâœ : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f âŸ¦aâŸ§ = pseudoApply f âŸ¦a'âŸ§
âŠ¢ a â‰ˆ a'",theorem pseudo_injective_of_mono {P Q : C} (f : P âŸ¶ Q) [Mono f] : Function.Injective f ,":= by
  intro abar abar'
  refine Quotient.inductionOnâ‚‚ abar abar' fun a a' ha => ?_
  apply Quotient.sound
  have : (âŸ¦(a.hom â‰« f : Over Q)âŸ§ : Quotient (setoid Q)) = âŸ¦â†‘(a'.hom â‰« f)âŸ§ := by convert ha
  have âŸ¨R, p, q, ep, Eq, commâŸ© := Quotient.exact this
  exact âŸ¨R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact commâŸ©","rw [Function.Injective, Function.Injective]"
Mathlib/MeasureTheory/Constructions/Polish.lean,MeasureTheory.measurableSet_range_of_continuous_injective,measurableSet_range_of_continuous_injective,62d1e98c9775031911b945f049f84047fafbe5e1,":= by
  letI := upgradePolishSpace Î³
  obtain âŸ¨b, b_count, b_nonempty, hbâŸ© :
    âˆƒ b : Set (Set Î³), b.Countable âˆ§ âˆ… âˆ‰ b âˆ§ IsTopologicalBasis b := exists_countable_basis Î³
  haveI : Encodable b := b_count.toEncodable
  let A := { p : b Ã— b // Disjoint (p.1 : Set Î³) p.2 }
  have : âˆ€ p : A, âˆƒ q : Set Î²,
      f '' (p.1.1 : Set Î³) âŠ† q âˆ§ Disjoint (f '' (p.1.2 : Set Î³)) q âˆ§ MeasurableSet q := by
    intro p
    apply
      AnalyticSet.measurablySeparable ((hb.isOpen p.1.1.2).analyticSet_image f_cont)
        ((hb.isOpen p.1.2.2).analyticSet_image f_cont)
    exact Disjoint.image p.2 (f_inj.injOn univ) (subset_univ _) (subset_univ _)
  choose q hq1 hq2 q_meas using this
  let E : b â†’ Set Î² := fun s =>
    closure (f '' s) âˆ© â‹‚ (t : b) (ht : Disjoint s.1 t.1), q âŸ¨(s, t), htâŸ© \ q âŸ¨(t, s), ht.symmâŸ©
  obtain âŸ¨u, u_anti, u_pos, u_limâŸ© :
    âˆƒ u : â„• â†’ â„, StrictAnti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=
    exists_seq_strictAnti_tendsto (0 : â„)
  let F : â„• â†’ Set Î² := fun n => â‹ƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), E s
  suffices range f = â‹‚ n, F n by
    have E_meas : âˆ€ s : b, MeasurableSet (E s) := by
      intro b
      refine' isClosed_closure.measurableSet.inter _
      refine' MeasurableSet.iInter fun s => _
      exact MeasurableSet.iInter fun hs => (q_meas _).diff (q_meas _)
    have F_meas : âˆ€ n, MeasurableSet (F n) := by
      intro n
      refine' MeasurableSet.iUnion fun s => _
      exact MeasurableSet.iUnion fun _ => E_meas _
    rw [this]
    exact MeasurableSet.iInter fun n => F_meas n
  apply Subset.antisymm
  Â· rintro x âŸ¨y, rflâŸ©
    refine mem_iInter.2 fun n => ?_
    obtain âŸ¨s, sb, ys, hsâŸ© : âˆƒ (s : Set Î³), s âˆˆ b âˆ§ y âˆˆ s âˆ§ s âŠ† ball y (u n / 2) := by
      apply hb.mem_nhds_iff.1
      exact ball_mem_nhds _ (half_pos (u_pos n))
    have diam_s : diam s â‰¤ u n := by
      apply (diam_mono hs isBounded_ball).trans
      convert diam_ball (x := y) (half_pos (u_pos n)).le
      ring
    refine' mem_iUnion.2 âŸ¨âŸ¨s, sbâŸ©, _âŸ©
    refine' mem_iUnion.2 âŸ¨âŸ¨isBounded_ball.subset hs, diam_sâŸ©, _âŸ©
    apply mem_inter (subset_closure (mem_image_of_mem _ ys))
    refine' mem_iInter.2 fun t => mem_iInter.2 fun ht => âŸ¨_, _âŸ©
    Â· apply hq1
      exact mem_image_of_mem _ ys
    Â· apply disjoint_left.1 (hq2 âŸ¨(t, âŸ¨s, sbâŸ©), ht.symmâŸ©)
      exact mem_image_of_mem _ ys
  Â· intro x hx
    have C1 : âˆ€ n, âˆƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), x âˆˆ E s := fun n => by
      simpa only [mem_iUnion] using mem_iInter.1 hx n
    choose s hs hxs using C1
    have C2 : âˆ€ n, (s n).1.Nonempty := by
      intro n
      rw [nonempty_iff_ne_empty]
      intro hn
      have := (s n).2
      rw [hn] at this
      exact b_nonempty this
    choose y hy using C2
    have I : âˆ€ m n, ((s m).1 âˆ© (s n).1).Nonempty := by
      intro m n
      rw [â† not_disjoint_iff_nonempty_inter]
      by_contra! h
      have A : x âˆˆ q âŸ¨(s m, s n), hâŸ© \ q âŸ¨(s n, s m), h.symmâŸ© :=
        haveI := mem_iInter.1 (hxs m).2 (s n)
        (mem_iInter.1 this h : _)
      have B : x âˆˆ q âŸ¨(s n, s m), h.symmâŸ© \ q âŸ¨(s m, s n), hâŸ© :=
        haveI := mem_iInter.1 (hxs n).2 (s m)
        (mem_iInter.1 this h.symm : _)
      exact A.2 B.1
    have cauchy_y : CauchySeq y := by
      have : Tendsto (fun n => 2 * u n) atTop (ğ“ 0) := by
        simpa only [mul_zero] using u_lim.const_mul 2
      refine cauchySeq_of_le_tendsto_0' (fun n => 2 * u n) (fun m n hmn => ?_) this
      rcases I m n with âŸ¨z, zsm, zsnâŸ©
      calc
        dist (y m) (y n) â‰¤ dist (y m) z + dist z (y n) := dist_triangle _ _ _
        _ â‰¤ u m + u n :=
          (add_le_add ((dist_le_diam_of_mem (hs m).1 (hy m) zsm).trans (hs m).2)
            ((dist_le_diam_of_mem (hs n).1 zsn (hy n)).trans (hs n).2))
        _ â‰¤ 2 * u m := by linarith [u_anti.antitone hmn]
    haveI : Nonempty Î³ := âŸ¨y 0âŸ©
    let z := limUnder atTop y
    have y_lim : Tendsto y atTop (ğ“ z) := cauchy_y.tendsto_limUnder
    suffices f z = x by
      rw [â† this]
      exact mem_range_self _
    by_contra! hne
    obtain âŸ¨v, w, v_open, w_open, fzv, xw, hvwâŸ© := t2_separation hne
    obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´ > (0 : â„), ball z Î´ âŠ† f â»Â¹' v := by
      apply Metric.mem_nhds_iff.1
      exact f_cont.continuousAt.preimage_mem_nhds (v_open.mem_nhds fzv)
    obtain âŸ¨n, hnâŸ© : âˆƒ n, u n + dist (y n) z < Î´ :=
      haveI : Tendsto (fun n => u n + dist (y n) z) atTop (ğ“ 0) := by
        simpa only [add_zero] using u_lim.add (tendsto_iff_dist_tendsto_zero.1 y_lim)
      ((tendsto_order.1 this).2 _ Î´pos).exists
    have fsnv : f '' s n âŠ† v := by
      rw [image_subset_iff]
      apply Subset.trans _ hÎ´
      intro a ha
      calc
        dist a z â‰¤ dist a (y n) + dist (y n) z := dist_triangle _ _ _
        _ â‰¤ u n + dist (y n) z :=
          (add_le_add_right ((dist_le_diam_of_mem (hs n).1 ha (hy n)).trans (hs n).2) _)
        _ < Î´ := hn
    have : x âˆˆ closure v := closure_mono fsnv (hxs n).1
    exact disjoint_left.1 (hvw.closure_left w_open) this xw","error:  application type mismatch
  Disjoint.image p.property (Injective.injOn f_inj ?m.51560)
argument
  Injective.injOn f_inj ?m.51560
has type
  âˆ€ â¦ƒxâ‚‚ : Î³â¦„, xâ‚‚ âˆˆ ?m.51281 â†’ f ?m.51282 = f xâ‚‚ â†’ ?m.51282 = xâ‚‚ : Prop
but is expected to have type
  InjOn f ?m.51227 : Prop
error:  application type mismatch
  Injective.injOn f_inj univ
argument
  univ
has type
  Set ?m.51284 : Type ?u.51283
but is expected to have type
  ?m.51282 âˆˆ ?m.51281 : Prop
error:  type mismatch
  hâœ
has type
  x âˆˆ F n : Prop
but is expected to have type
  âˆƒ s, âˆƒ (_ : Bornology.IsBounded â†‘s âˆ§ diam â†‘s â‰¤ u n), x âˆˆ E s : Prop","theorem measurableSet_range_of_continuous_injective {Î² : Type*} [TopologicalSpace Î³]
    [PolishSpace Î³] [TopologicalSpace Î²] [T2Space Î²] [MeasurableSpace Î²] [OpensMeasurableSpace Î²]
    {f : Î³ â†’ Î²} (f_cont : Continuous f) (f_inj : Injective f) :
    MeasurableSet (range f) ",":= by
  letI := upgradePolishSpace Î³
  obtain âŸ¨b, b_count, b_nonempty, hbâŸ© :
    âˆƒ b : Set (Set Î³), b.Countable âˆ§ âˆ… âˆ‰ b âˆ§ IsTopologicalBasis b := exists_countable_basis Î³
  haveI : Encodable b := b_count.toEncodable
  let A := { p : b Ã— b // Disjoint (p.1 : Set Î³) p.2 }
  have : âˆ€ p : A, âˆƒ q : Set Î²,
      f '' (p.1.1 : Set Î³) âŠ† q âˆ§ Disjoint (f '' (p.1.2 : Set Î³)) q âˆ§ MeasurableSet q := by
    intro p
    apply
      AnalyticSet.measurablySeparable ((hb.isOpen p.1.1.2).analyticSet_image f_cont)
        ((hb.isOpen p.1.2.2).analyticSet_image f_cont)
    exact Disjoint.image p.2 f_inj.injOn (subset_univ _) (subset_univ _)
  choose q hq1 hq2 q_meas using this
  let E : b â†’ Set Î² := fun s =>
    closure (f '' s) âˆ© â‹‚ (t : b) (ht : Disjoint s.1 t.1), q âŸ¨(s, t), htâŸ© \ q âŸ¨(t, s), ht.symmâŸ©
  obtain âŸ¨u, u_anti, u_pos, u_limâŸ© :
      âˆƒ u : â„• â†’ â„, StrictAnti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=
    exists_seq_strictAnti_tendsto (0 : â„)
  let F : â„• â†’ Set Î² := fun n => â‹ƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), E s
  suffices range f = â‹‚ n, F n by
    have E_meas : âˆ€ s : b, MeasurableSet (E s) := by
      intro b
      refine isClosed_closure.measurableSet.inter ?_
      refine MeasurableSet.iInter fun s => ?_
      exact MeasurableSet.iInter fun hs => (q_meas _).diff (q_meas _)
    have F_meas : âˆ€ n, MeasurableSet (F n) := by
      intro n
      refine MeasurableSet.iUnion fun s => ?_
      exact MeasurableSet.iUnion fun _ => E_meas _
    rw [this]
    exact MeasurableSet.iInter fun n => F_meas n
  apply Subset.antisymm
  Â· rintro x âŸ¨y, rflâŸ©
    refine mem_iInter.2 fun n => ?_
    obtain âŸ¨s, sb, ys, hsâŸ© : âˆƒ (s : Set Î³), s âˆˆ b âˆ§ y âˆˆ s âˆ§ s âŠ† ball y (u n / 2) := by
      apply hb.mem_nhds_iff.1
      exact ball_mem_nhds _ (half_pos (u_pos n))
    have diam_s : diam s â‰¤ u n := by
      apply (diam_mono hs isBounded_ball).trans
      convert diam_ball (x := y) (half_pos (u_pos n)).le
      ring
    refine mem_iUnion.2 âŸ¨âŸ¨s, sbâŸ©, ?_âŸ©
    refine mem_iUnion.2 âŸ¨âŸ¨isBounded_ball.subset hs, diam_sâŸ©, ?_âŸ©
    apply mem_inter (subset_closure (mem_image_of_mem _ ys))
    refine mem_iInter.2 fun t => mem_iInter.2 fun ht => âŸ¨?_, ?_âŸ©
    Â· apply hq1
      exact mem_image_of_mem _ ys
    Â· apply disjoint_left.1 (hq2 âŸ¨(t, âŸ¨s, sbâŸ©), ht.symmâŸ©)
      exact mem_image_of_mem _ ys
  Â· intro x hx
    have C1 : âˆ€ n, âˆƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), x âˆˆ E s := fun n => by
      simpa only [F, mem_iUnion] using mem_iInter.1 hx n
    choose s hs hxs using C1
    have C2 : âˆ€ n, (s n).1.Nonempty := by
      intro n
      rw [nonempty_iff_ne_empty]
      intro hn
      have := (s n).2
      rw [hn] at this
      exact b_nonempty this
    choose y hy using C2
    have I : âˆ€ m n, ((s m).1 âˆ© (s n).1).Nonempty := by
      intro m n
      rw [â† not_disjoint_iff_nonempty_inter]
      by_contra! h
      have A : x âˆˆ q âŸ¨(s m, s n), hâŸ© \ q âŸ¨(s n, s m), h.symmâŸ© :=
        haveI := mem_iInter.1 (hxs m).2 (s n)
        (mem_iInter.1 this h : _)
      have B : x âˆˆ q âŸ¨(s n, s m), h.symmâŸ© \ q âŸ¨(s m, s n), hâŸ© :=
        haveI := mem_iInter.1 (hxs n).2 (s m)
        (mem_iInter.1 this h.symm : _)
      exact A.2 B.1
    have cauchy_y : CauchySeq y := by
      have : Tendsto (fun n => 2 * u n) atTop (ğ“ 0) := by
        simpa only [mul_zero] using u_lim.const_mul 2
      refine cauchySeq_of_le_tendsto_0' (fun n => 2 * u n) (fun m n hmn => ?_) this
      rcases I m n with âŸ¨z, zsm, zsnâŸ©
      calc
        dist (y m) (y n) â‰¤ dist (y m) z + dist z (y n) := dist_triangle _ _ _
        _ â‰¤ u m + u n :=
          (add_le_add ((dist_le_diam_of_mem (hs m).1 (hy m) zsm).trans (hs m).2)
            ((dist_le_diam_of_mem (hs n).1 zsn (hy n)).trans (hs n).2))
        _ â‰¤ 2 * u m := by linarith [u_anti.antitone hmn]
    haveI : Nonempty Î³ := âŸ¨y 0âŸ©
    let z := limUnder atTop y
    have y_lim : Tendsto y atTop (ğ“ z) := cauchy_y.tendsto_limUnder
    suffices f z = x by
      rw [â† this]
      exact mem_range_self _
    by_contra! hne
    obtain âŸ¨v, w, v_open, w_open, fzv, xw, hvwâŸ© := t2_separation hne
    obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´ > (0 : â„), ball z Î´ âŠ† f â»Â¹' v := by
      apply Metric.mem_nhds_iff.1
      exact f_cont.continuousAt.preimage_mem_nhds (v_open.mem_nhds fzv)
    obtain âŸ¨n, hnâŸ© : âˆƒ n, u n + dist (y n) z < Î´ :=
      haveI : Tendsto (fun n => u n + dist (y n) z) atTop (ğ“ 0) := by
        simpa only [add_zero] using u_lim.add (tendsto_iff_dist_tendsto_zero.1 y_lim)
      ((tendsto_order.1 this).2 _ Î´pos).exists
    have fsnv : f '' s n âŠ† v := by
      rw [image_subset_iff]
      apply Subset.trans _ hÎ´
      intro a ha
      calc
        dist a z â‰¤ dist a (y n) + dist (y n) z := dist_triangle _ _ _
        _ â‰¤ u n + dist (y n) z :=
          (add_le_add_right ((dist_le_diam_of_mem (hs n).1 ha (hy n)).trans (hs n).2) _)
        _ < Î´ := hn
    have : x âˆˆ closure v := closure_mono fsnv (hxs n).1
    exact disjoint_left.1 (hvw.closure_left w_open) this xw",exact MeasurableSet.range f
Mathlib/Topology/Separation.lean,minimal_nonempty_closed_subsingleton,minimal_nonempty_closed_subsingleton,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  clear Y 
  refine' fun x hx y hy => of_not_not fun hxy => _
  rcases exists_isOpen_xor'_mem hxy with âŸ¨U, hUo, hUâŸ©
  wlog h : x âˆˆ U âˆ§ y âˆ‰ U
  Â· refine this hs hmin y hy x hx (Ne.symm hxy) U hUo hU.symm (hU.resolve_left h)
  cases' h with hxU hyU
  have : s \ U = s := hmin (s \ U) (diff_subset _ _) âŸ¨y, hy, hyUâŸ© (hs.sdiff hUo)
  exact (this.symm.subset hx).2 hxU","error:  function expected at
  diff_subset ?m.37785
term has type
  ?m.37784 âˆˆ ?m.37782","theorem minimal_nonempty_closed_subsingleton [T0Space X] {s : Set X} (hs : IsClosed s)
    (hmin : âˆ€ t, t âŠ† s â†’ t.Nonempty â†’ IsClosed t â†’ t = s) : s.Subsingleton ",":= by
  clear Y 
  refine fun x hx y hy => of_not_not fun hxy => ?_
  rcases exists_isOpen_xor'_mem hxy with âŸ¨U, hUo, hUâŸ©
  wlog h : x âˆˆ U âˆ§ y âˆ‰ U
  Â· refine this hs hmin y hy x hx (Ne.symm hxy) U hUo hU.symm (hU.resolve_left h)
  cases' h with hxU hyU
  have : s \ U = s := hmin (s \ U) diff_subset âŸ¨y, hy, hyUâŸ© (hs.sdiff hUo)
  exact (this.symm.subset hx).2 hxU",rw [subsingleton_iff_isClosed_subsingleton]
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsPrimitiveRoot.discr_zeta_eq_discr_zeta_sub_one,discr_zeta_eq_discr_zeta_sub_one,22e97510854d6906cc856e022d297bf9cf8c9b3a,":= by
  haveI : NumberField K := @NumberField.mk _ _ _ (IsCyclotomicExtension.finiteDimensional {n} â„š K)
  have Hâ‚ : (aeval (hÎ¶.powerBasis â„š).gen) (X - 1 : â„¤[X]) = (hÎ¶.subOnePowerBasis â„š).gen := by simp
  have Hâ‚‚ : (aeval (hÎ¶.subOnePowerBasis â„š).gen) (X + 1 : â„¤[X]) = (hÎ¶.powerBasis â„š).gen := by simp
  refine' discr_eq_discr_of_toMatrix_coeff_isIntegral _ (fun i j => toMatrix_isIntegral Hâ‚ _ _ _ _)
    fun i j => toMatrix_isIntegral Hâ‚‚ _ _ _ _
  Â· exact hÎ¶.isIntegral n.pos
  Â· refine' minpoly.isIntegrallyClosed_eq_field_fractions' (K := â„š) (hÎ¶.isIntegral n.pos)
  Â· exact isIntegral_sub (hÎ¶.isIntegral n.pos) isIntegral_one
  Â· refine' minpoly.isIntegrallyClosed_eq_field_fractions' (K := â„š) _
    exact isIntegral_sub (hÎ¶.isIntegral n.pos) isIntegral_one","error:  unknown identifier 'isIntegral_sub'
error:  unknown identifier 'isIntegral_sub'","theorem discr_zeta_eq_discr_zeta_sub_one (hÎ¶ : IsPrimitiveRoot Î¶ n) :
    discr â„š (hÎ¶.powerBasis â„š).basis = discr â„š (hÎ¶.subOnePowerBasis â„š).basis ",":= by
  haveI : NumberField K := @NumberField.mk _ _ _ (IsCyclotomicExtension.finiteDimensional {n} â„š K)
  have Hâ‚ : (aeval (hÎ¶.powerBasis â„š).gen) (X - 1 : â„¤[X]) = (hÎ¶.subOnePowerBasis â„š).gen := by simp
  have Hâ‚‚ : (aeval (hÎ¶.subOnePowerBasis â„š).gen) (X + 1 : â„¤[X]) = (hÎ¶.powerBasis â„š).gen := by simp
  refine discr_eq_discr_of_toMatrix_coeff_isIntegral _ (fun i j => toMatrix_isIntegral Hâ‚ ?_ ?_ _ _)
    fun i j => toMatrix_isIntegral Hâ‚‚ ?_ ?_ _ _
  Â· exact hÎ¶.isIntegral n.pos
  Â· refine minpoly.isIntegrallyClosed_eq_field_fractions' (K := â„š) (hÎ¶.isIntegral n.pos)
  Â· exact (hÎ¶.isIntegral n.pos).sub isIntegral_one
  Â· refine minpoly.isIntegrallyClosed_eq_field_fractions' (K := â„š) ?_
    exact (hÎ¶.isIntegral n.pos).sub isIntegral_one",rw [hÎ¶.subOnePowerBasis_powerBasis]
Mathlib/Data/Set/Finite.lean,Set.union_finset_finite_of_range_finite,union_finset_finite_of_range_finite,5841a8d15e6905a0287a6ec353113b1dbfef9878,":= by
  rw [â† bunionáµ¢_range]
  exact h.bunionáµ¢ fun y _ => y.finite_to_set","error:  unknown identifier 'bunionáµ¢_range'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.109091
Î± : Type u
Î² : Type v
Î¹ : Sort w
Î³ : Type x
f : Î± â†’ Finset Î²
h : (range f).Finite
âŠ¢ (â‹ƒ a, â†‘(f a)).Finite","theorem union_finset_finite_of_range_finite (f : Î± â†’ Finset Î²) (h : (range f).Finite) :
    (â‹ƒ a, (f a : Set Î²)).Finite ",":= by
  rw [â† biUnion_range]
  exact h.biUnion fun y _ => y.finite_toSet",refine Finite.subset ?_ ?_
Mathlib/LinearAlgebra/LinearIndependent.lean,linearIndependent_iUnion_finite_subtype,linearIndependent_iUnion_finite_subtype,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
  rw [iUnion_eq_iUnion_finset f]
  apply linearIndependent_iUnion_of_directed
  Â· apply directed_of_isDirected_le
    exact fun tâ‚ tâ‚‚ ht => iUnion_mono fun i => iUnion_subset_iUnion_const fun h => ht h
  intro t
  induction' t with i s his ih
  Â· refine (linearIndependent_empty R M).mono ?_
    simp
  Â· rw [Finset.set_biUnion_insert]
    refine (hl _).union ih ?_
    rw [span_iUnionâ‚‚]
    exact hd i s s.finite_toSet his","error:  unsolved goals
case h.mk
Î¹âœ : Type u'
Î¹' : Type u_1
R : Type u_2
K : Type u_3
M : Type u_4
M' : Type u_5
M'' : Type u_6
V : Type u
V' : Type u_7
v : Î¹âœ â†’ M
instâœâ¶ : Ring R
instâœâµ : AddCommGroup M
instâœâ´ : AddCommGroup M'
instâœÂ³ : AddCommGroup M''
instâœÂ² : Module R M
instâœÂ¹ : Module R M'
instâœ : Module R M''
a b : R
x y : M
Î¹ : Type u_8
f : Î¹ â†’ Set M
hl : âˆ€ (i : Î¹), LinearIndependent R fun (x : â†‘(f i)) â†¦ â†‘x
hd : âˆ€ (i : Î¹) (t : Set Î¹), t.Finite â†’ i âˆ‰ t â†’ Disjoint (span R (f i)) (â¨† i âˆˆ t, span R (f i))
i : Multiset Î¹
s : i.Nodup
âŠ¢ âˆ€ i_1 âˆˆ i, f i_1 âŠ† âˆ…
error:  no goals to be solved","theorem linearIndependent_iUnion_finite_subtype {Î¹ : Type*} {f : Î¹ â†’ Set M}
    (hl : âˆ€ i, LinearIndependent R (fun x => x : f i â†’ M))
    (hd : âˆ€ i, âˆ€ t : Set Î¹, t.Finite â†’ i âˆ‰ t â†’ Disjoint (span R (f i)) (â¨† i âˆˆ t, span R (f i))) :
    LinearIndependent R (fun x => x : (â‹ƒ i, f i) â†’ M) ",":= by
  classical
  rw [iUnion_eq_iUnion_finset f]
  apply linearIndependent_iUnion_of_directed
  Â· apply directed_of_isDirected_le
    exact fun tâ‚ tâ‚‚ ht => iUnion_mono fun i => iUnion_subset_iUnion_const fun h => ht h
  intro t
  induction' t using Finset.induction_on with i s his ih
  Â· refine (linearIndependent_empty R M).mono ?_
    simp
  Â· rw [Finset.set_biUnion_insert]
    refine (hl _).union ih ?_
    rw [span_iUnionâ‚‚]
    exact hd i s s.finite_toSet his",rw [linearIndependent_iUnion_finite_subtype]
Mathlib/RingTheory/Regular/IsSMulRegular.lean,isSMulRegular_on_quot_iff_smul_mem_implies_mem,isSMulRegular_on_quot_iff_smul_mem_implies_mem,b6614ff09e1c04a05cb0835b781fc5c2d33b5c4d,":=
  Iff.trans (isSMulRegular_iff_smul_eq_zero_imp_eq_zero _ r) <|
    Iff.trans N.mkQ_surjective.forall <| by
      simp_rw [â† map_smul, N.mkQ_apply, Quotient.mk_eq_zero]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Quotient
has type
  Setoid ?m.67412 â†’ Sort ?u.67411
error:  simp made no progress","lemma isSMulRegular_on_quot_iff_smul_mem_implies_mem :
    IsSMulRegular (M â§¸ N) r â†” âˆ€ x : M, r â€¢ x âˆˆ N â†’ x âˆˆ N ",":=
  Iff.trans (isSMulRegular_iff_smul_eq_zero_imp_eq_zero _ r) <|
    Iff.trans N.mkQ_surjective.forall <| by
      simp_rw [â† map_smul, N.mkQ_apply, Submodule.Quotient.mk_eq_zero]","refine âŸ¨Quotienquotienquotienquot_iff_smul_mem_implies_mem, fun x hx â†¦ Quotienquotienquotienquot_iff_smul_mem_implies_memâŸ©"
Mathlib/Topology/MetricSpace/GromovHausdorff.lean,GromovHausdorff.totallyBounded,totallyBounded,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  refine' Metric.totallyBounded_of_finite_discretization fun Î´ Î´pos => _
  let Îµ := 1 / 5 * Î´
  have Îµpos : 0 < Îµ := mul_pos (by norm_num) Î´pos
  rcases Metric.tendsto_atTop.1 ulim Îµ Îµpos with âŸ¨n, hnâŸ©
  have u_le_Îµ : u n â‰¤ Îµ := by
    have := hn n le_rfl
    simp only [Real.dist_eq, add_zero, sub_eq_add_neg, neg_zero] at this
    exact le_of_lt (lt_of_le_of_lt (le_abs_self _) this)
  have :
    âˆ€ p : GHSpace,
      âˆƒ s : Set p.Rep, âˆƒ N â‰¤ K n, âˆƒ _ : Equiv s (Fin N), p âˆˆ t â†’ univ âŠ† â‹ƒ x âˆˆ s, ball x (u n) := by
    intro p
    by_cases hp : p âˆ‰ t
    Â· have : Nonempty (Equiv (âˆ… : Set p.Rep) (Fin 0)) := by
        rw [â† Fintype.card_eq];
        simp only [empty_card', Fintype.card_fin]
      use âˆ…, 0, bot_le, choice this
      exact fun hp' => (hp hp').elim
    Â· rcases hcov _ (Set.not_not_mem.1 hp) n with âŸ¨s, âŸ¨scard, scoverâŸ©âŸ©
      rcases Cardinal.lt_aleph0.1 (lt_of_le_of_lt scard (Cardinal.nat_lt_aleph0 _)) with âŸ¨N, hNâŸ©
      rw [hN, Cardinal.natCast_le] at scard
      have : #s = #(Fin N) := by rw [hN, Cardinal.mk_fin]
      cases' Quotient.exact this with E
      use s, N, scard, E
      simp only [scover, imp_true_iff]
  choose s N hN E hs using this
  let M := âŒŠÎµâ»Â¹ * max C 0âŒ‹â‚Š
  let F : GHSpace â†’ Î£ k : Fin (K n).succ, Fin k â†’ Fin k â†’ Fin M.succ := fun p =>
    âŸ¨âŸ¨N p, lt_of_le_of_lt (hN p) (Nat.lt_succ_self _)âŸ©, fun a b =>
      âŸ¨min M âŒŠÎµâ»Â¹ * dist ((E p).symm a) ((E p).symm b)âŒ‹â‚Š,
        (min_le_left _ _).trans_lt (Nat.lt_succ_self _)âŸ©âŸ©
  refine' âŸ¨_, _, fun p => F p, _âŸ©; infer_instance
  rintro âŸ¨p, ptâŸ© âŸ¨q, qtâŸ© hpq
  have Npq : N p = N q := Fin.ext_iff.1 (Sigma.mk.inj_iff.1 hpq).1
  let Î¨ : s p â†’ s q := fun x => (E q).symm (Fin.cast Npq ((E p) x))
  let Î¦ : s p â†’ q.Rep := fun x => Î¨ x
  have main : ghDist p.Rep q.Rep â‰¤ Îµ + Îµ / 2 + Îµ := by
    refine' ghDist_le_of_approx_subsets Î¦ _ _ _
    show âˆ€ x : p.Rep, âˆƒ y âˆˆ s p, dist x y â‰¤ Îµ
    Â· 
      intro x
      have : x âˆˆ â‹ƒ y âˆˆ s p, ball y (u n) := (hs p pt) (mem_univ _)
      rcases mem_iUnionâ‚‚.1 this with âŸ¨y, ys, hyâŸ©
      exact âŸ¨y, ys, le_trans (le_of_lt hy) u_le_ÎµâŸ©
    show âˆ€ x : q.Rep, âˆƒ z : s p, dist x (Î¦ z) â‰¤ Îµ
    Â· 
      intro x
      have : x âˆˆ â‹ƒ y âˆˆ s q, ball y (u n) := (hs q qt) (mem_univ _)
      rcases mem_iUnionâ‚‚.1 this with âŸ¨y, ys, hyâŸ©
      let i : â„• := E q âŸ¨y, ysâŸ©
      let hi := ((E q) âŸ¨y, ysâŸ©).2
      have ihi_eq : (âŸ¨i, hiâŸ© : Fin (N q)) = (E q) âŸ¨y, ysâŸ© := by rw [Fin.ext_iff, Fin.val_mk]
      have hiq : i < N q := hi
      have hip : i < N p := by rwa [Npq.symm] at hiq
      let z := (E p).symm âŸ¨i, hipâŸ©
      use z
      have C1 : (E p) z = âŸ¨i, hipâŸ© := (E p).apply_symm_apply âŸ¨i, hipâŸ©
      have C2 : Fin.cast Npq âŸ¨i, hipâŸ© = âŸ¨i, hiâŸ© := rfl
      have C3 : (E q).symm âŸ¨i, hiâŸ© = âŸ¨y, ysâŸ© := by
        rw [ihi_eq]; exact (E q).symm_apply_apply âŸ¨y, ysâŸ©
      have : Î¦ z = y := by simp only [Î¨, Î¦]; rw [C1, C2, C3]
      rw [this]
      exact le_trans (le_of_lt hy) u_le_Îµ
    show âˆ€ x y : s p, |dist x y - dist (Î¦ x) (Î¦ y)| â‰¤ Îµ
    Â· intro x y
      have : dist (Î¦ x) (Î¦ y) = dist (Î¨ x) (Î¨ y) := rfl
      rw [this]
      let i : â„• := E p x
      have hip : i < N p := ((E p) x).2
      have hiq : i < N q := by rwa [Npq] at hip
      have i' : i = (E q) (Î¨ x) := by simp only [Î¨, Equiv.apply_symm_apply, Fin.coe_cast]
      let j : â„• := E p y
      have hjp : j < N p := ((E p) y).2
      have hjq : j < N q := by rwa [Npq] at hjp
      have j' : j = (E q) (Î¨ y) := by simp only [Î¨, Equiv.apply_symm_apply, Fin.coe_cast]
      have Ap : ((F p).2 âŸ¨i, hipâŸ© âŸ¨j, hjpâŸ©).1 = âŒŠÎµâ»Â¹ * dist x yâŒ‹â‚Š :=
        calc
          ((F p).2 âŸ¨i, hipâŸ© âŸ¨j, hjpâŸ©).1 = ((F p).2 ((E p) x) ((E p) y)).1 := by
            congr
          _ = min M âŒŠÎµâ»Â¹ * dist x yâŒ‹â‚Š := by simp only [(E p).symm_apply_apply]
          _ = âŒŠÎµâ»Â¹ * dist x yâŒ‹â‚Š := by
            refine' min_eq_right (Nat.floor_mono _)
            refine' mul_le_mul_of_nonneg_left (le_trans _ (le_max_left _ _)) (inv_pos.2 Îµpos).le
            change dist (x : p.Rep) y â‰¤ C
            refine' (dist_le_diam_of_mem isCompact_univ.isBounded (mem_univ _) (mem_univ _)).trans _
            exact hdiam p pt
      have Aq : ((F q).2 âŸ¨i, hiqâŸ© âŸ¨j, hjqâŸ©).1 = âŒŠÎµâ»Â¹ * dist (Î¨ x) (Î¨ y)âŒ‹â‚Š :=
        calc
          ((F q).2 âŸ¨i, hiqâŸ© âŸ¨j, hjqâŸ©).1 = ((F q).2 ((E q) (Î¨ x)) ((E q) (Î¨ y))).1 := by
            exact congr_argâ‚‚ (Fin.val <| (F q).2 Â· Â·) (Fin.ext i') (Fin.ext j')
          _ = min M âŒŠÎµâ»Â¹ * dist (Î¨ x) (Î¨ y)âŒ‹â‚Š := by simp only [(E q).symm_apply_apply]
          _ = âŒŠÎµâ»Â¹ * dist (Î¨ x) (Î¨ y)âŒ‹â‚Š := by
            refine' min_eq_right (Nat.floor_mono _)
            refine' mul_le_mul_of_nonneg_left (le_trans _ (le_max_left _ _)) (inv_pos.2 Îµpos).le
            change dist (Î¨ x : q.Rep) (Î¨ y) â‰¤ C
            refine (dist_le_diam_of_mem isCompact_univ.isBounded (mem_univ _) (mem_univ _)).trans ?_
            exact hdiam q qt
      have : ((F p).2 âŸ¨i, hipâŸ© âŸ¨j, hjpâŸ©).1 = ((F q).2 âŸ¨i, hiqâŸ© âŸ¨j, hjqâŸ©).1 := by
        have hpq' : HEq (F p).snd (F q).snd := (Sigma.mk.inj_iff.1 hpq).2
        rw [Fin.heq_funâ‚‚_iff Npq Npq] at hpq'
        rw [â† hpq']
      have : âŒŠÎµâ»Â¹ * dist x yâŒ‹ = âŒŠÎµâ»Â¹ * dist (Î¨ x) (Î¨ y)âŒ‹ := by
        rw [Ap, Aq] at this
        have D : 0 â‰¤ âŒŠÎµâ»Â¹ * dist x yâŒ‹ :=
          floor_nonneg.2 (mul_nonneg (le_of_lt (inv_pos.2 Îµpos)) dist_nonneg)
        have D' : 0 â‰¤ âŒŠÎµâ»Â¹ * dist (Î¨ x) (Î¨ y)âŒ‹ :=
          floor_nonneg.2 (mul_nonneg (le_of_lt (inv_pos.2 Îµpos)) dist_nonneg)
        rw [â† Int.toNat_of_nonneg D, â† Int.toNat_of_nonneg D', Int.floor_toNat, Int.floor_toNat,
          this]
      have I :=
        calc
          |Îµâ»Â¹| * |dist x y - dist (Î¨ x) (Î¨ y)| = |Îµâ»Â¹ * (dist x y - dist (Î¨ x) (Î¨ y))| :=
            (abs_mul _ _).symm
          _ = |Îµâ»Â¹ * dist x y - Îµâ»Â¹ * dist (Î¨ x) (Î¨ y)| := by congr; ring
          _ â‰¤ 1 := le_of_lt (abs_sub_lt_one_of_floor_eq_floor this)
      calc
        |dist x y - dist (Î¨ x) (Î¨ y)| = Îµ * Îµâ»Â¹ * |dist x y - dist (Î¨ x) (Î¨ y)| := by
          rw [mul_inv_cancel (ne_of_gt Îµpos), one_mul]
        _ = Îµ * (|Îµâ»Â¹| * |dist x y - dist (Î¨ x) (Î¨ y)|) := by
          rw [abs_of_nonneg (le_of_lt (inv_pos.2 Îµpos)), mul_assoc]
        _ â‰¤ Îµ * 1 := (mul_le_mul_of_nonneg_left I (le_of_lt Îµpos))
        _ = Îµ := mul_one _
  calc
    dist p q = ghDist p.Rep q.Rep := dist_ghDist p q
    _ â‰¤ Îµ + Îµ / 2 + Îµ := main
    _ = Î´ / 2 := by simp only [Îµ, one_div]; ring
    _ < Î´ := half_lt_self Î´pos","error:  type mismatch
  choice ?m.703478
has type
  Quotient inferInstance : Type (max ?u.701770 ?u.701769)
but is expected to have type
  â†‘âˆ… â‰ƒ Fin 0 : Type
error:  application type mismatch
  choice this
argument
  this
has type
  Nonempty (â†‘âˆ… â‰ƒ Fin 0) : Prop
but is expected to have type
  (i : ?m.701771) â†’ Quotient (?m.701773 i) : Type (max ?u.701769 ?u.701770)","theorem totallyBounded {t : Set GHSpace} {C : â„} {u : â„• â†’ â„} {K : â„• â†’ â„•}
    (ulim : Tendsto u atTop (ğ“ 0)) (hdiam : âˆ€ p âˆˆ t, diam (univ : Set (GHSpace.Rep p)) â‰¤ C)
    (hcov : âˆ€ p âˆˆ t, âˆ€ n : â„•, âˆƒ s : Set (GHSpace.Rep p),
      (#s) â‰¤ K n âˆ§ univ âŠ† â‹ƒ x âˆˆ s, ball x (u n)) :
    TotallyBounded t ",":= by
  refine Metric.totallyBounded_of_finite_discretization fun Î´ Î´pos => ?_
  let Îµ := 1 / 5 * Î´
  have Îµpos : 0 < Îµ := mul_pos (by norm_num) Î´pos
  rcases Metric.tendsto_atTop.1 ulim Îµ Îµpos with âŸ¨n, hnâŸ©
  have u_le_Îµ : u n â‰¤ Îµ := by
    have := hn n le_rfl
    simp only [Real.dist_eq, add_zero, sub_eq_add_neg, neg_zero] at this
    exact le_of_lt (lt_of_le_of_lt (le_abs_self _) this)
  have :
    âˆ€ p : GHSpace,
      âˆƒ s : Set p.Rep, âˆƒ N â‰¤ K n, âˆƒ _ : Equiv s (Fin N), p âˆˆ t â†’ univ âŠ† â‹ƒ x âˆˆ s, ball x (u n) := by
    intro p
    by_cases hp : p âˆ‰ t
    Â· have : Nonempty (Equiv (âˆ… : Set p.Rep) (Fin 0)) := by
        rw [â† Fintype.card_eq];
        simp only [empty_card', Fintype.card_fin]
      use âˆ…, 0, bot_le, this.some
      exact fun hp' => (hp hp').elim
    Â· rcases hcov _ (Set.not_not_mem.1 hp) n with âŸ¨s, âŸ¨scard, scoverâŸ©âŸ©
      rcases Cardinal.lt_aleph0.1 (lt_of_le_of_lt scard (Cardinal.nat_lt_aleph0 _)) with âŸ¨N, hNâŸ©
      rw [hN, Cardinal.natCast_le] at scard
      have : #s = #(Fin N) := by rw [hN, Cardinal.mk_fin]
      cases' Quotient.exact this with E
      use s, N, scard, E
      simp only [scover, imp_true_iff]
  choose s N hN E hs using this
  let M := âŒŠÎµâ»Â¹ * max C 0âŒ‹â‚Š
  let F : GHSpace â†’ Î£ k : Fin (K n).succ, Fin k â†’ Fin k â†’ Fin M.succ := fun p =>
    âŸ¨âŸ¨N p, lt_of_le_of_lt (hN p) (Nat.lt_succ_self _)âŸ©, fun a b =>
      âŸ¨min M âŒŠÎµâ»Â¹ * dist ((E p).symm a) ((E p).symm b)âŒ‹â‚Š,
        (min_le_left _ _).trans_lt (Nat.lt_succ_self _)âŸ©âŸ©
  refine âŸ¨_, ?_, fun p => F p, ?_âŸ©;
  Â· infer_instance
  rintro âŸ¨p, ptâŸ© âŸ¨q, qtâŸ© hpq
  have Npq : N p = N q := Fin.ext_iff.1 (Sigma.mk.inj_iff.1 hpq).1
  let Î¨ : s p â†’ s q := fun x => (E q).symm (Fin.cast Npq ((E p) x))
  let Î¦ : s p â†’ q.Rep := fun x => Î¨ x
  have main : ghDist p.Rep q.Rep â‰¤ Îµ + Îµ / 2 + Îµ := by
    refine ghDist_le_of_approx_subsets Î¦ ?_ ?_ ?_
    Â· show âˆ€ x : p.Rep, âˆƒ y âˆˆ s p, dist x y â‰¤ Îµ
      intro x
      have : x âˆˆ â‹ƒ y âˆˆ s p, ball y (u n) := (hs p pt) (mem_univ _)
      rcases mem_iUnionâ‚‚.1 this with âŸ¨y, ys, hyâŸ©
      exact âŸ¨y, ys, le_trans (le_of_lt hy) u_le_ÎµâŸ©
    Â· show âˆ€ x : q.Rep, âˆƒ z : s p, dist x (Î¦ z) â‰¤ Îµ
      intro x
      have : x âˆˆ â‹ƒ y âˆˆ s q, ball y (u n) := (hs q qt) (mem_univ _)
      rcases mem_iUnionâ‚‚.1 this with âŸ¨y, ys, hyâŸ©
      let i : â„• := E q âŸ¨y, ysâŸ©
      let hi := ((E q) âŸ¨y, ysâŸ©).2
      have ihi_eq : (âŸ¨i, hiâŸ© : Fin (N q)) = (E q) âŸ¨y, ysâŸ© := by rw [Fin.ext_iff, Fin.val_mk]
      have hiq : i < N q := hi
      have hip : i < N p := by rwa [Npq.symm] at hiq
      let z := (E p).symm âŸ¨i, hipâŸ©
      use z
      have C1 : (E p) z = âŸ¨i, hipâŸ© := (E p).apply_symm_apply âŸ¨i, hipâŸ©
      have C2 : Fin.cast Npq âŸ¨i, hipâŸ© = âŸ¨i, hiâŸ© := rfl
      have C3 : (E q).symm âŸ¨i, hiâŸ© = âŸ¨y, ysâŸ© := by
        rw [ihi_eq]; exact (E q).symm_apply_apply âŸ¨y, ysâŸ©
      have : Î¦ z = y := by simp only [Î¨, Î¦]; rw [C1, C2, C3]
      rw [this]
      exact le_trans (le_of_lt hy) u_le_Îµ
    Â· show âˆ€ x y : s p, |dist x y - dist (Î¦ x) (Î¦ y)| â‰¤ Îµ
      intro x y
      have : dist (Î¦ x) (Î¦ y) = dist (Î¨ x) (Î¨ y) := rfl
      rw [this]
      let i : â„• := E p x
      have hip : i < N p := ((E p) x).2
      have hiq : i < N q := by rwa [Npq] at hip
      have i' : i = (E q) (Î¨ x) := by simp only [Î¨, Equiv.apply_symm_apply, Fin.coe_cast]
      let j : â„• := E p y
      have hjp : j < N p := ((E p) y).2
      have hjq : j < N q := by rwa [Npq] at hjp
      have j' : j = (E q) (Î¨ y) := by simp only [Î¨, Equiv.apply_symm_apply, Fin.coe_cast]
      have Ap : ((F p).2 âŸ¨i, hipâŸ© âŸ¨j, hjpâŸ©).1 = âŒŠÎµâ»Â¹ * dist x yâŒ‹â‚Š :=
        calc
          ((F p).2 âŸ¨i, hipâŸ© âŸ¨j, hjpâŸ©).1 = ((F p).2 ((E p) x) ((E p) y)).1 := by
            congr
          _ = min M âŒŠÎµâ»Â¹ * dist x yâŒ‹â‚Š := by simp only [(E p).symm_apply_apply]
          _ = âŒŠÎµâ»Â¹ * dist x yâŒ‹â‚Š := by
            refine min_eq_right (Nat.floor_mono ?_)
            refine mul_le_mul_of_nonneg_left (le_trans ?_ (le_max_left _ _)) (inv_pos.2 Îµpos).le
            change dist (x : p.Rep) y â‰¤ C
            refine (dist_le_diam_of_mem isCompact_univ.isBounded (mem_univ _) (mem_univ _)).trans ?_
            exact hdiam p pt
      have Aq : ((F q).2 âŸ¨i, hiqâŸ© âŸ¨j, hjqâŸ©).1 = âŒŠÎµâ»Â¹ * dist (Î¨ x) (Î¨ y)âŒ‹â‚Š :=
        calc
          ((F q).2 âŸ¨i, hiqâŸ© âŸ¨j, hjqâŸ©).1 = ((F q).2 ((E q) (Î¨ x)) ((E q) (Î¨ y))).1 := by
            exact congr_argâ‚‚ (Fin.val <| (F q).2 Â· Â·) (Fin.ext i') (Fin.ext j')
          _ = min M âŒŠÎµâ»Â¹ * dist (Î¨ x) (Î¨ y)âŒ‹â‚Š := by simp only [(E q).symm_apply_apply]
          _ = âŒŠÎµâ»Â¹ * dist (Î¨ x) (Î¨ y)âŒ‹â‚Š := by
            refine min_eq_right (Nat.floor_mono ?_)
            refine mul_le_mul_of_nonneg_left (le_trans ?_ (le_max_left _ _)) (inv_pos.2 Îµpos).le
            change dist (Î¨ x : q.Rep) (Î¨ y) â‰¤ C
            refine (dist_le_diam_of_mem isCompact_univ.isBounded (mem_univ _) (mem_univ _)).trans ?_
            exact hdiam q qt
      have : ((F p).2 âŸ¨i, hipâŸ© âŸ¨j, hjpâŸ©).1 = ((F q).2 âŸ¨i, hiqâŸ© âŸ¨j, hjqâŸ©).1 := by
        have hpq' : HEq (F p).snd (F q).snd := (Sigma.mk.inj_iff.1 hpq).2
        rw [Fin.heq_funâ‚‚_iff Npq Npq] at hpq'
        rw [â† hpq']
      have : âŒŠÎµâ»Â¹ * dist x yâŒ‹ = âŒŠÎµâ»Â¹ * dist (Î¨ x) (Î¨ y)âŒ‹ := by
        rw [Ap, Aq] at this
        have D : 0 â‰¤ âŒŠÎµâ»Â¹ * dist x yâŒ‹ :=
          floor_nonneg.2 (mul_nonneg (le_of_lt (inv_pos.2 Îµpos)) dist_nonneg)
        have D' : 0 â‰¤ âŒŠÎµâ»Â¹ * dist (Î¨ x) (Î¨ y)âŒ‹ :=
          floor_nonneg.2 (mul_nonneg (le_of_lt (inv_pos.2 Îµpos)) dist_nonneg)
        rw [â† Int.toNat_of_nonneg D, â† Int.toNat_of_nonneg D', Int.floor_toNat, Int.floor_toNat,
          this]
      have I :=
        calc
          |Îµâ»Â¹| * |dist x y - dist (Î¨ x) (Î¨ y)| = |Îµâ»Â¹ * (dist x y - dist (Î¨ x) (Î¨ y))| :=
            (abs_mul _ _).symm
          _ = |Îµâ»Â¹ * dist x y - Îµâ»Â¹ * dist (Î¨ x) (Î¨ y)| := by congr; ring
          _ â‰¤ 1 := le_of_lt (abs_sub_lt_one_of_floor_eq_floor this)
      calc
        |dist x y - dist (Î¨ x) (Î¨ y)| = Îµ * Îµâ»Â¹ * |dist x y - dist (Î¨ x) (Î¨ y)| := by
          rw [mul_inv_cancel (ne_of_gt Îµpos), one_mul]
        _ = Îµ * (|Îµâ»Â¹| * |dist x y - dist (Î¨ x) (Î¨ y)|) := by
          rw [abs_of_nonneg (le_of_lt (inv_pos.2 Îµpos)), mul_assoc]
        _ â‰¤ Îµ * 1 := mul_le_mul_of_nonneg_left I (le_of_lt Îµpos)
        _ = Îµ := mul_one _
  calc
    dist p q = ghDist p.Rep q.Rep := dist_ghDist p q
    _ â‰¤ Îµ + Îµ / 2 + Îµ := main
    _ = Î´ / 2 := by simp only [Îµ, one_div]; ring
    _ < Î´ := half_lt_self Î´pos",refine totallyBounded_iff.mpr fun x hx â†¦ ?_
Mathlib/MeasureTheory/Integral/CircleIntegral.lean,le_radius_cauchyPowerSeries,le_radius_cauchyPowerSeries,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  refine
    (cauchyPowerSeries f c R).le_radius_of_bound
      ((2 * Ï€)â»Â¹ * âˆ« Î¸ : â„ in (0)..2 * Ï€, â€–f (circleMap c R Î¸)â€–) fun n => ?_
  refine (mul_le_mul_of_nonneg_right (norm_cauchyPowerSeries_le _ _ _ _)
    (pow_nonneg R.coe_nonneg _)).trans ?_
  rw [_root_.abs_of_nonneg R.coe_nonneg]
  rcases eq_or_ne (R ^ n : â„) 0 with hR | hR
  Â· rw_mod_cast [hR, mul_zero]
    exact mul_nonneg (inv_nonneg.2 Real.two_pi_pos.le)
      (intervalIntegral.integral_nonneg Real.two_pi_pos.le fun _ _ => norm_nonneg _)
  Â· rw [inv_pow]
    have : (R : â„) ^ n â‰  0 : = by norm_cast at hR âŠ¢
    rw [inv_mul_cancel_rightâ‚€ this]","error:  unexpected token ':'; expected '|'
error:  unsolved goals
case inr
E : Type u_1
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„‚ E
instâœ : CompleteSpace E
f : â„‚ â†’ E
c : â„‚
R : â„â‰¥0
n : â„•
hR this : â†‘R ^ n â‰  0
âŠ¢ ((2 * Ï€)â»Â¹ * âˆ« (Î¸ : â„) in 0 ..2 * Ï€, â€–f (circleMap c (â†‘R) Î¸)â€–) * (â†‘R ^ n)â»Â¹ * â†‘R ^ n â‰¤
    (2 * Ï€)â»Â¹ * âˆ« (Î¸ : â„) in 0 ..2 * Ï€, â€–f (circleMap c (â†‘R) Î¸)â€–","theorem le_radius_cauchyPowerSeries (f : â„‚ â†’ E) (c : â„‚) (R : â„â‰¥0) :
    â†‘R â‰¤ (cauchyPowerSeries f c R).radius ",":= by
  refine
    (cauchyPowerSeries f c R).le_radius_of_bound
      ((2 * Ï€)â»Â¹ * âˆ« Î¸ : â„ in (0)..2 * Ï€, â€–f (circleMap c R Î¸)â€–) fun n => ?_
  refine (mul_le_mul_of_nonneg_right (norm_cauchyPowerSeries_le _ _ _ _)
    (pow_nonneg R.coe_nonneg _)).trans ?_
  rw [_root_.abs_of_nonneg R.coe_nonneg]
  rcases eq_or_ne (R ^ n : â„) 0 with hR | hR
  Â· rw_mod_cast [hR, mul_zero]
    exact mul_nonneg (inv_nonneg.2 Real.two_pi_pos.le)
      (intervalIntegral.integral_nonneg Real.two_pi_pos.le fun _ _ => norm_nonneg _)
  Â· rw [inv_pow]
    have : (R:â„) ^ n â‰  0 := by norm_cast at hR âŠ¢
    rw [inv_mul_cancel_rightâ‚€ this]",simp only [cauchyPowerSeries]
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_closedBall_covering_tsum_measure_le,exists_closedBall_covering_tsum_measure_le,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain âŸ¨u, su, u_open, Î¼uâŸ© : âˆƒ U, U âŠ‡ s âˆ§ IsOpen U âˆ§ Î¼ U â‰¤ Î¼ s + Îµ / 2 :=
    Set.exists_isOpen_le_add _ _
      (by
        simpa only [or_false, Ne, ENNReal.div_eq_zero_iff, ENNReal.two_ne_top] using hÎµ)
  have : âˆ€ x âˆˆ s, âˆƒ R > 0, ball x R âŠ† u := fun x hx =>
    Metric.mem_nhds_iff.1 (u_open.mem_nhds (su hx))
  choose! R hR using this
  obtain âŸ¨t0, r0, t0_count, t0s, hr0, Î¼t0, t0_disjâŸ© :
    âˆƒ (t0 : Set Î±) (r0 : Î± â†’ â„), t0.Countable âˆ§ t0 âŠ† s âˆ§
      (âˆ€ x âˆˆ t0, r0 x âˆˆ f x âˆ© Ioo 0 (R x)) âˆ§ Î¼ (s \ â‹ƒ x âˆˆ t0, closedBall x (r0 x)) = 0 âˆ§
        t0.PairwiseDisjoint fun x => closedBall x (r0 x) :=
    exists_disjoint_closedBall_covering_ae Î¼ f s hf R fun x hx => (hR x hx).1
  let s' := s \ â‹ƒ x âˆˆ t0, closedBall x (r0 x)
  have s's : s' âŠ† s := diff_subset _ _
  obtain âŸ¨N, Ï„, hÏ„, HâŸ© : âˆƒ N Ï„, 1 < Ï„ âˆ§ IsEmpty (Besicovitch.SatelliteConfig Î± N Ï„) :=
    HasBesicovitchCovering.no_satelliteConfig
  obtain âŸ¨v, s'v, v_open, Î¼vâŸ© : âˆƒ v, v âŠ‡ s' âˆ§ IsOpen v âˆ§ Î¼ v â‰¤ Î¼ s' + Îµ / 2 / N :=
    Set.exists_isOpen_le_add _ _
      (by simp only [ne_eq, ENNReal.div_eq_zero_iff, hÎµ, ENNReal.two_ne_top, or_self,
          ENNReal.natCast_ne_top, not_false_eq_true])
  have : âˆ€ x âˆˆ s', âˆƒ r1 âˆˆ f x âˆ© Ioo (0 : â„) 1, closedBall x r1 âŠ† v := by
    intro x hx
    rcases Metric.mem_nhds_iff.1 (v_open.mem_nhds (s'v hx)) with âŸ¨r, rpos, hrâŸ©
    rcases hf x (s's hx) (min r 1) (lt_min rpos zero_lt_one) with âŸ¨R', hR'âŸ©
    exact
      âŸ¨R', âŸ¨hR'.1, hR'.2.1, hR'.2.2.trans_le (min_le_right _ _)âŸ©,
        Subset.trans (closedBall_subset_ball (hR'.2.2.trans_le (min_le_left _ _))) hrâŸ©
  choose! r1 hr1 using this
  let q : BallPackage s' Î± :=
    { c := fun x => x
      r := fun x => r1 x
      rpos := fun x => (hr1 x.1 x.2).1.2.1
      r_bound := 1
      r_le := fun x => (hr1 x.1 x.2).1.2.2.le }
  obtain âŸ¨S, S_disj, hSâŸ© :
    âˆƒ S : Fin N â†’ Set s',
      (âˆ€ i : Fin N, (S i).PairwiseDisjoint fun j => closedBall (q.c j) (q.r j)) âˆ§
        range q.c âŠ† â‹ƒ i : Fin N, â‹ƒ j âˆˆ S i, ball (q.c j) (q.r j) :=
    exist_disjoint_covering_families hÏ„ H q
  have S_count : âˆ€ i, (S i).Countable := by
    intro i
    apply (S_disj i).countable_of_nonempty_interior fun j _ => ?_
    have : (ball (j : Î±) (r1 j)).Nonempty := nonempty_ball.2 (q.rpos _)
    exact this.mono ball_subset_interior_closedBall
  let r x := if x âˆˆ s' then r1 x else r0 x
  have r_t0 : âˆ€ x âˆˆ t0, r x = r0 x := by
    intro x hx
    have : Â¬x âˆˆ s' := by
      simp only [s', not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_lt, not_le,
        mem_diff, not_forall]
      intro _
      refine' âŸ¨x, hx, _âŸ©
      rw [dist_self]
      exact (hr0 x hx).2.1.le
    simp only [r, if_neg this]
  refine' âŸ¨t0 âˆª â‹ƒ i : Fin N, ((â†‘) : s' â†’ Î±) '' S i, r, _, _, _, _, _âŸ©
  Â· exact t0_count.union (countable_iUnion fun i => (S_count i).image _)
  Â· simp only [t0s, true_and_iff, union_subset_iff, image_subset_iff, iUnion_subset_iff]
    intro i x _
    exact s's x.2
  Â· intro x hx
    cases hx with
    | inl hx =>
      rw [r_t0 x hx]
      exact (hr0 _ hx).1
    | inr hx =>
      have h'x : x âˆˆ s' := by
        simp only [mem_iUnion, mem_image] at hx
        rcases hx with âŸ¨i, y, _, rflâŸ©
        exact y.2
      simp only [r, if_pos h'x, (hr1 x h'x).1.1]
  Â· intro x hx
    by_cases h'x : x âˆˆ s'
    Â· obtain âŸ¨i, y, ySi, xyâŸ© : âˆƒ (i : Fin N) (y : â†¥s'), y âˆˆ S i âˆ§ x âˆˆ ball (y : Î±) (r1 y) := by
        have A : x âˆˆ range q.c := by
          simpa only [not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_le,
            mem_setOf_eq, Subtype.range_coe_subtype, mem_diff] using h'x
        simpa only [mem_iUnion, mem_image, bex_def] using hS A
      refine' mem_iUnionâ‚‚.2 âŸ¨y, Or.inr _, _âŸ©
      Â· simp only [mem_iUnion, mem_image]
        exact âŸ¨i, y, ySi, rflâŸ©
      Â· have : (y : Î±) âˆˆ s' := y.2
        simp only [r, if_pos this]
        exact ball_subset_closedBall xy
    Â· obtain âŸ¨y, yt0, hxyâŸ© : âˆƒ y : Î±, y âˆˆ t0 âˆ§ x âˆˆ closedBall y (r0 y) := by
        simpa [s', hx, -mem_closedBall] using h'x
      refine' mem_iUnionâ‚‚.2 âŸ¨y, Or.inl yt0, _âŸ©
      rwa [r_t0 _ yt0]
  Â· 
    have A : (âˆ‘' x : t0, Î¼ (closedBall x (r x))) â‰¤ Î¼ s + Îµ / 2 :=
      calc
        (âˆ‘' x : t0, Î¼ (closedBall x (r x))) = âˆ‘' x : t0, Î¼ (closedBall x (r0 x)) := by
          congr 1; ext x; rw [r_t0 x x.2]
        _ = Î¼ (â‹ƒ x : t0, closedBall x (r0 x)) := by
          haveI : Encodable t0 := t0_count.toEncodable
          rw [measure_iUnion]
          Â· exact (pairwise_subtype_iff_pairwise_set _ _).2 t0_disj
          Â· exact fun i => measurableSet_closedBall
        _ â‰¤ Î¼ u := by
          apply measure_mono
          simp only [SetCoe.forall, Subtype.coe_mk, iUnion_subset_iff]
          intro x hx
          apply Subset.trans (closedBall_subset_ball (hr0 x hx).2.2) (hR x (t0s hx)).2
        _ â‰¤ Î¼ s + Îµ / 2 := Î¼u
    have B : âˆ€ i : Fin N, (âˆ‘' x : ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x))) â‰¤ Îµ / 2 / N :=
      fun i =>
      calc
        (âˆ‘' x : ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x))) =
            âˆ‘' x : S i, Î¼ (closedBall x (r x)) := by
          have : InjOn ((â†‘) : s' â†’ Î±) (S i) := Subtype.val_injective.injOn _
          let F : S i â‰ƒ ((â†‘) : s' â†’ Î±) '' S i := this.bijOn_image.equiv _
          exact (F.tsum_eq fun x => Î¼ (closedBall x (r x))).symm
        _ = âˆ‘' x : S i, Î¼ (closedBall x (r1 x)) := by
          congr 1; ext x; have : (x : Î±) âˆˆ s' := x.1.2; simp only [s', r, if_pos this]
        _ = Î¼ (â‹ƒ x : S i, closedBall x (r1 x)) := by
          haveI : Encodable (S i) := (S_count i).toEncodable
          rw [measure_iUnion]
          Â· exact (pairwise_subtype_iff_pairwise_set _ _).2 (S_disj i)
          Â· exact fun i => measurableSet_closedBall
        _ â‰¤ Î¼ v := by
          apply measure_mono
          simp only [SetCoe.forall, Subtype.coe_mk, iUnion_subset_iff]
          intro x xs' _
          exact (hr1 x xs').2
        _ â‰¤ Îµ / 2 / N := by have : Î¼ s' = 0 := Î¼t0; rwa [this, zero_add] at Î¼v
    calc
      (âˆ‘' x : â†¥(t0 âˆª â‹ƒ i : Fin N, ((â†‘) : s' â†’ Î±) '' S i), Î¼ (closedBall x (r x))) â‰¤
          (âˆ‘' x : t0, Î¼ (closedBall x (r x))) +
            âˆ‘' x : â‹ƒ i : Fin N, ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x)) :=
        ENNReal.tsum_union_le (fun x => Î¼ (closedBall x (r x))) _ _
      _ â‰¤
          (âˆ‘' x : t0, Î¼ (closedBall x (r x))) +
            âˆ‘ i : Fin N, âˆ‘' x : ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x)) :=
        (add_le_add le_rfl (ENNReal.tsum_iUnion_le (fun x => Î¼ (closedBall x (r x))) _))
      _ â‰¤ Î¼ s + Îµ / 2 + âˆ‘ i : Fin N, Îµ / 2 / N := by
        refine' add_le_add A _
        refine' Finset.sum_le_sum _
        intro i _
        exact B i
      _ â‰¤ Î¼ s + Îµ / 2 + Îµ / 2 := by
        refine' add_le_add le_rfl _
        simp only [Finset.card_fin, Finset.sum_const, nsmul_eq_mul, ENNReal.mul_div_le]
      _ = Î¼ s + Îµ := by rw [add_assoc, ENNReal.add_halves]","error:  function expected at
  diff_subset ?m.152257
term has type
  ?m.152256 âˆˆ ?m.152254
error:  type mismatch
  Function.Injective.injOn Subtype.val_injective ?m.177674
has type
  âˆ€ â¦ƒxâ‚‚ : Subtype ?m.177651â¦„, xâ‚‚ âˆˆ ?m.177672 â†’ â†‘?m.177673 = â†‘xâ‚‚ â†’ ?m.177673 = xâ‚‚ : Prop
but is expected to have type
  InjOn Subtype.val (S i) : Prop","theorem exists_closedBall_covering_tsum_measure_le (Î¼ : Measure Î±) [SigmaFinite Î¼]
    [Measure.OuterRegular Î¼] {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0) (f : Î± â†’ Set â„) (s : Set Î±)
    (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty) :
    âˆƒ (t : Set Î±) (r : Î± â†’ â„), t.Countable âˆ§ t âŠ† s âˆ§ (âˆ€ x âˆˆ t, r x âˆˆ f x) âˆ§
      (s âŠ† â‹ƒ x âˆˆ t, closedBall x (r x)) âˆ§ (âˆ‘' x : t, Î¼ (closedBall x (r x))) â‰¤ Î¼ s + Îµ ",":= by
  obtain âŸ¨u, su, u_open, Î¼uâŸ© : âˆƒ U, U âŠ‡ s âˆ§ IsOpen U âˆ§ Î¼ U â‰¤ Î¼ s + Îµ / 2 :=
    Set.exists_isOpen_le_add _ _
      (by
        simpa only [or_false, Ne, ENNReal.div_eq_zero_iff, ENNReal.two_ne_top] using hÎµ)
  have : âˆ€ x âˆˆ s, âˆƒ R > 0, ball x R âŠ† u := fun x hx =>
    Metric.mem_nhds_iff.1 (u_open.mem_nhds (su hx))
  choose! R hR using this
  obtain âŸ¨t0, r0, t0_count, t0s, hr0, Î¼t0, t0_disjâŸ© :
    âˆƒ (t0 : Set Î±) (r0 : Î± â†’ â„), t0.Countable âˆ§ t0 âŠ† s âˆ§
      (âˆ€ x âˆˆ t0, r0 x âˆˆ f x âˆ© Ioo 0 (R x)) âˆ§ Î¼ (s \ â‹ƒ x âˆˆ t0, closedBall x (r0 x)) = 0 âˆ§
        t0.PairwiseDisjoint fun x => closedBall x (r0 x) :=
    exists_disjoint_closedBall_covering_ae Î¼ f s hf R fun x hx => (hR x hx).1
  let s' := s \ â‹ƒ x âˆˆ t0, closedBall x (r0 x)
  have s's : s' âŠ† s := diff_subset
  obtain âŸ¨N, Ï„, hÏ„, HâŸ© : âˆƒ N Ï„, 1 < Ï„ âˆ§ IsEmpty (Besicovitch.SatelliteConfig Î± N Ï„) :=
    HasBesicovitchCovering.no_satelliteConfig
  obtain âŸ¨v, s'v, v_open, Î¼vâŸ© : âˆƒ v, v âŠ‡ s' âˆ§ IsOpen v âˆ§ Î¼ v â‰¤ Î¼ s' + Îµ / 2 / N :=
    Set.exists_isOpen_le_add _ _
      (by simp only [ne_eq, ENNReal.div_eq_zero_iff, hÎµ, ENNReal.two_ne_top, or_self,
          ENNReal.natCast_ne_top, not_false_eq_true])
  have : âˆ€ x âˆˆ s', âˆƒ r1 âˆˆ f x âˆ© Ioo (0 : â„) 1, closedBall x r1 âŠ† v := by
    intro x hx
    rcases Metric.mem_nhds_iff.1 (v_open.mem_nhds (s'v hx)) with âŸ¨r, rpos, hrâŸ©
    rcases hf x (s's hx) (min r 1) (lt_min rpos zero_lt_one) with âŸ¨R', hR'âŸ©
    exact
      âŸ¨R', âŸ¨hR'.1, hR'.2.1, hR'.2.2.trans_le (min_le_right _ _)âŸ©,
        Subset.trans (closedBall_subset_ball (hR'.2.2.trans_le (min_le_left _ _))) hrâŸ©
  choose! r1 hr1 using this
  let q : BallPackage s' Î± :=
    { c := fun x => x
      r := fun x => r1 x
      rpos := fun x => (hr1 x.1 x.2).1.2.1
      r_bound := 1
      r_le := fun x => (hr1 x.1 x.2).1.2.2.le }
  obtain âŸ¨S, S_disj, hSâŸ© :
    âˆƒ S : Fin N â†’ Set s',
      (âˆ€ i : Fin N, (S i).PairwiseDisjoint fun j => closedBall (q.c j) (q.r j)) âˆ§
        range q.c âŠ† â‹ƒ i : Fin N, â‹ƒ j âˆˆ S i, ball (q.c j) (q.r j) :=
    exist_disjoint_covering_families hÏ„ H q
  have S_count : âˆ€ i, (S i).Countable := by
    intro i
    apply (S_disj i).countable_of_nonempty_interior fun j _ => ?_
    have : (ball (j : Î±) (r1 j)).Nonempty := nonempty_ball.2 (q.rpos _)
    exact this.mono ball_subset_interior_closedBall
  let r x := if x âˆˆ s' then r1 x else r0 x
  have r_t0 : âˆ€ x âˆˆ t0, r x = r0 x := by
    intro x hx
    have : Â¬x âˆˆ s' := by
      simp only [s', not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_lt, not_le,
        mem_diff, not_forall]
      intro _
      refine âŸ¨x, hx, ?_âŸ©
      rw [dist_self]
      exact (hr0 x hx).2.1.le
    simp only [r, if_neg this]
  refine âŸ¨t0 âˆª â‹ƒ i : Fin N, ((â†‘) : s' â†’ Î±) '' S i, r, ?_, ?_, ?_, ?_, ?_âŸ©
  Â· exact t0_count.union (countable_iUnion fun i => (S_count i).image _)
  Â· simp only [t0s, true_and_iff, union_subset_iff, image_subset_iff, iUnion_subset_iff]
    intro i x _
    exact s's x.2
  Â· intro x hx
    cases hx with
    | inl hx =>
      rw [r_t0 x hx]
      exact (hr0 _ hx).1
    | inr hx =>
      have h'x : x âˆˆ s' := by
        simp only [mem_iUnion, mem_image] at hx
        rcases hx with âŸ¨i, y, _, rflâŸ©
        exact y.2
      simp only [r, if_pos h'x, (hr1 x h'x).1.1]
  Â· intro x hx
    by_cases h'x : x âˆˆ s'
    Â· obtain âŸ¨i, y, ySi, xyâŸ© : âˆƒ (i : Fin N) (y : â†¥s'), y âˆˆ S i âˆ§ x âˆˆ ball (y : Î±) (r1 y) := by
        have A : x âˆˆ range q.c := by
          simpa only [not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_le,
            mem_setOf_eq, Subtype.range_coe_subtype, mem_diff] using h'x
        simpa only [mem_iUnion, mem_image, bex_def] using hS A
      refine mem_iUnionâ‚‚.2 âŸ¨y, Or.inr ?_, ?_âŸ©
      Â· simp only [mem_iUnion, mem_image]
        exact âŸ¨i, y, ySi, rflâŸ©
      Â· have : (y : Î±) âˆˆ s' := y.2
        simp only [r, if_pos this]
        exact ball_subset_closedBall xy
    Â· obtain âŸ¨y, yt0, hxyâŸ© : âˆƒ y : Î±, y âˆˆ t0 âˆ§ x âˆˆ closedBall y (r0 y) := by
        simpa [s', hx, -mem_closedBall] using h'x
      refine mem_iUnionâ‚‚.2 âŸ¨y, Or.inl yt0, ?_âŸ©
      rwa [r_t0 _ yt0]
  Â· 
    have A : (âˆ‘' x : t0, Î¼ (closedBall x (r x))) â‰¤ Î¼ s + Îµ / 2 :=
      calc
        (âˆ‘' x : t0, Î¼ (closedBall x (r x))) = âˆ‘' x : t0, Î¼ (closedBall x (r0 x)) := by
          congr 1; ext x; rw [r_t0 x x.2]
        _ = Î¼ (â‹ƒ x : t0, closedBall x (r0 x)) := by
          haveI : Encodable t0 := t0_count.toEncodable
          rw [measure_iUnion]
          Â· exact (pairwise_subtype_iff_pairwise_set _ _).2 t0_disj
          Â· exact fun i => measurableSet_closedBall
        _ â‰¤ Î¼ u := by
          apply measure_mono
          simp only [SetCoe.forall, Subtype.coe_mk, iUnion_subset_iff]
          intro x hx
          apply Subset.trans (closedBall_subset_ball (hr0 x hx).2.2) (hR x (t0s hx)).2
        _ â‰¤ Î¼ s + Îµ / 2 := Î¼u
    have B : âˆ€ i : Fin N, (âˆ‘' x : ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x))) â‰¤ Îµ / 2 / N :=
      fun i =>
      calc
        (âˆ‘' x : ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x))) =
            âˆ‘' x : S i, Î¼ (closedBall x (r x)) := by
          have : InjOn ((â†‘) : s' â†’ Î±) (S i) := Subtype.val_injective.injOn
          let F : S i â‰ƒ ((â†‘) : s' â†’ Î±) '' S i := this.bijOn_image.equiv _
          exact (F.tsum_eq fun x => Î¼ (closedBall x (r x))).symm
        _ = âˆ‘' x : S i, Î¼ (closedBall x (r1 x)) := by
          congr 1; ext x; have : (x : Î±) âˆˆ s' := x.1.2; simp only [s', r, if_pos this]
        _ = Î¼ (â‹ƒ x : S i, closedBall x (r1 x)) := by
          haveI : Encodable (S i) := (S_count i).toEncodable
          rw [measure_iUnion]
          Â· exact (pairwise_subtype_iff_pairwise_set _ _).2 (S_disj i)
          Â· exact fun i => measurableSet_closedBall
        _ â‰¤ Î¼ v := by
          apply measure_mono
          simp only [SetCoe.forall, Subtype.coe_mk, iUnion_subset_iff]
          intro x xs' _
          exact (hr1 x xs').2
        _ â‰¤ Îµ / 2 / N := by have : Î¼ s' = 0 := Î¼t0; rwa [this, zero_add] at Î¼v
    calc
      (âˆ‘' x : â†¥(t0 âˆª â‹ƒ i : Fin N, ((â†‘) : s' â†’ Î±) '' S i), Î¼ (closedBall x (r x))) â‰¤
          (âˆ‘' x : t0, Î¼ (closedBall x (r x))) +
            âˆ‘' x : â‹ƒ i : Fin N, ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x)) :=
        ENNReal.tsum_union_le (fun x => Î¼ (closedBall x (r x))) _ _
      _ â‰¤
          (âˆ‘' x : t0, Î¼ (closedBall x (r x))) +
            âˆ‘ i : Fin N, âˆ‘' x : ((â†‘) : s' â†’ Î±) '' S i, Î¼ (closedBall x (r x)) :=
        (add_le_add le_rfl (ENNReal.tsum_iUnion_le (fun x => Î¼ (closedBall x (r x))) _))
      _ â‰¤ Î¼ s + Îµ / 2 + âˆ‘ i : Fin N, Îµ / 2 / N := by
        gcongr
        apply B
      _ â‰¤ Î¼ s + Îµ / 2 + Îµ / 2 := by
        gcongr
        simp only [Finset.card_fin, Finset.sum_const, nsmul_eq_mul, ENNReal.mul_div_le]
      _ = Î¼ s + Îµ := by rw [add_assoc, ENNReal.add_halves]","refine theorem_exists_closedBall_covering_tsum_measure_le_add Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measure_le
  exists_closedBall_covering_tsum_measure_le Î¼ exists_closedBall_covering_tsum_measur"
Mathlib/CategoryTheory/Limits/Fubini.lean,CategoryTheory.Limits.colimitIsoColimitCurryCompColim_Î¹_Î¹_inv,colimitIsoColimitCurryCompColim_Î¹_Î¹_inv,5d190454fbc8b3ab70bb2da0a0e9ec2a11df64a4,":= by
  simp [colimitIsoColimitCurryCompColim, Trans.simple, HasColimit.isoOfNatIso,
    colimitUncurryIsoColimitCompColim]","error:  unsolved goals
J K : Type v
instâœâµ : SmallCategory J
instâœâ´ : SmallCategory K
C : Type u
instâœÂ³ : Category.{v, u} C
F : J â¥¤ K â¥¤ C
G : J Ã— K â¥¤ C
instâœÂ² : HasColimitsOfShape K C
instâœÂ¹ : HasColimit G
instâœ : HasColimit (curry.obj G â‹™ colim)
j : J
k : K
âŠ¢ colimit.Î¹ (uncurry.obj (curry.obj G)) (j, k) â‰«
      (colimit.isColimit (uncurry.obj (curry.obj G))).map (colimit.cocone G) (currying.counitIso.hom.app G) =
    colimit.Î¹ G (j, k)","theorem colimitIsoColimitCurryCompColim_Î¹_Î¹_inv {j} {k} :
    colimit.Î¹ ((curry.obj G).obj j) k â‰« colimit.Î¹ (curry.obj G â‹™ colim) j â‰«
      (colimitIsoColimitCurryCompColim G).inv  = colimit.Î¹ _ (j, k) ",":= by
  set_option tactic.skipAssignedInstances false in
  simp [colimitIsoColimitCurryCompColim, Trans.simple, HasColimit.isoOfNatIso,
    colimitUncurryIsoColimitCompColim]",simp [colimitIsoColimitCurryCompColimitCurryCompColimitCurryCompColimitCurryCompColimitCurryCompColimitCurryCompColimitCurryCom
Mathlib/CategoryTheory/GradedObject/Associator.lean,CategoryTheory.GradedObject.Î¹_mapBifunctorAssociator_inv,Î¹_mapBifunctorAssociator_inv,adfdc22ddc32fb8dd361f5607921fa2eb9feb13f,":= by
  rw [â† cancel_mono ((mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).hom j),
    assoc, assoc, Iso.inv_hom_id_apply, comp_id, Î¹_mapBifunctorAssociator_hom,
    â† NatTrans.comp_app_assoc, â† NatTrans.comp_app, Iso.inv_hom_id_app,
    NatTrans.id_app, NatTrans.id_app, id_comp]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Iso
has type
  ?m.39598 â†’ ?m.39598 â†’ Type ?u.39597
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.39718
Câ‚ : Type u_1
Câ‚‚ : Type u_2
Câ‚â‚‚ : Type u_3
Câ‚‚â‚ƒ : Type u_4
Câ‚ƒ : Type u_5
Câ‚„ : Type u_6
instâœâ¹ : Category.{u_13, u_1} Câ‚
instâœâ¸ : Category.{u_15, u_2} Câ‚‚
instâœâ· : Category.{u_14, u_5} Câ‚ƒ
instâœâ¶ : Category.{u_11, u_6} Câ‚„
instâœâµ : Category.{u_17, u_3} Câ‚â‚‚
instâœâ´ : Category.{u_12, u_4} Câ‚‚â‚ƒ
Fâ‚â‚‚ : Câ‚ â¥¤ Câ‚‚ â¥¤ Câ‚â‚‚
G : Câ‚â‚‚ â¥¤ Câ‚ƒ â¥¤ Câ‚„
F : Câ‚ â¥¤ Câ‚‚â‚ƒ â¥¤ Câ‚„
Gâ‚‚â‚ƒ : Câ‚‚ â¥¤ Câ‚ƒ â¥¤ Câ‚‚â‚ƒ
associator : bifunctorCompâ‚â‚‚ Fâ‚â‚‚ G â‰… bifunctorCompâ‚‚â‚ƒ F Gâ‚‚â‚ƒ
Iâ‚ : Type u_7
Iâ‚‚ : Type u_8
Iâ‚ƒ : Type u_9
J : Type u_10
r : Iâ‚ Ã— Iâ‚‚ Ã— Iâ‚ƒ â†’ J
Ïâ‚â‚‚ : BifunctorCompâ‚â‚‚IndexData r
Ïâ‚‚â‚ƒ : BifunctorCompâ‚‚â‚ƒIndexData r
Xâ‚ : GradedObject Iâ‚ Câ‚
Xâ‚‚ : GradedObject Iâ‚‚ Câ‚‚
Xâ‚ƒ : GradedObject Iâ‚ƒ Câ‚ƒ
instâœÂ³ : (((mapBifunctor Fâ‚â‚‚ Iâ‚ Iâ‚‚).obj Xâ‚).obj Xâ‚‚).HasMap Ïâ‚â‚‚.p
instâœÂ² : (((mapBifunctor G Ïâ‚â‚‚.Iâ‚â‚‚ Iâ‚ƒ).obj (mapBifunctorMapObj Fâ‚â‚‚ Ïâ‚â‚‚.p Xâ‚ Xâ‚‚)).obj Xâ‚ƒ).HasMap Ïâ‚â‚‚.q
instâœÂ¹ : (((mapBifunctor Gâ‚‚â‚ƒ Iâ‚‚ Iâ‚ƒ).obj Xâ‚‚).obj Xâ‚ƒ).HasMap Ïâ‚‚â‚ƒ.p
instâœ : (((mapBifunctor F Iâ‚ Ïâ‚‚â‚ƒ.Iâ‚‚â‚ƒ).obj Xâ‚).obj (mapBifunctorMapObj Gâ‚‚â‚ƒ Ïâ‚‚â‚ƒ.p Xâ‚‚ Xâ‚ƒ)).HasMap Ïâ‚‚â‚ƒ.q
Hâ‚â‚‚ : HasGoodTrifunctorâ‚â‚‚Obj Fâ‚â‚‚ G Ïâ‚â‚‚ Xâ‚ Xâ‚‚ Xâ‚ƒ
Hâ‚‚â‚ƒ : HasGoodTrifunctorâ‚‚â‚ƒObj F Gâ‚‚â‚ƒ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ
iâ‚ : Iâ‚
iâ‚‚ : Iâ‚‚
iâ‚ƒ : Iâ‚ƒ
j : J
h : r (iâ‚, iâ‚‚, iâ‚ƒ) = j
âŠ¢ Î¹MapBifunctorBifunctorâ‚‚â‚ƒMapObj F Gâ‚‚â‚ƒ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ iâ‚ iâ‚‚ iâ‚ƒ j h â‰«
      (mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).inv j â‰«
        (mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).hom j =
    ((associator.inv.app (Xâ‚ iâ‚)).app (Xâ‚‚ iâ‚‚)).app (Xâ‚ƒ iâ‚ƒ) â‰«
      Î¹MapBifunctorâ‚â‚‚BifunctorMapObj Fâ‚â‚‚ G Ïâ‚â‚‚ Xâ‚ Xâ‚‚ Xâ‚ƒ iâ‚ iâ‚‚ iâ‚ƒ j h â‰«
        (mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).hom j","lemma Î¹_mapBifunctorAssociator_inv (iâ‚ : Iâ‚) (iâ‚‚ : Iâ‚‚) (iâ‚ƒ : Iâ‚ƒ) (j : J) (h : r (iâ‚, iâ‚‚, iâ‚ƒ) = j) :
    Î¹MapBifunctorBifunctorâ‚‚â‚ƒMapObj F Gâ‚‚â‚ƒ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ iâ‚ iâ‚‚ iâ‚ƒ j h â‰«
      (mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).inv j =
    ((associator.inv.app (Xâ‚ iâ‚)).app (Xâ‚‚ iâ‚‚)).app (Xâ‚ƒ iâ‚ƒ) â‰«
      Î¹MapBifunctorâ‚â‚‚BifunctorMapObj Fâ‚â‚‚ G Ïâ‚â‚‚ Xâ‚ Xâ‚‚ Xâ‚ƒ iâ‚ iâ‚‚ iâ‚ƒ j h ",":= by
  rw [â† cancel_mono ((mapBifunctorAssociator associator Ïâ‚â‚‚ Ïâ‚‚â‚ƒ Xâ‚ Xâ‚‚ Xâ‚ƒ).hom j),
    assoc, assoc, Iso.inv_hom_id_eval, comp_id, Î¹_mapBifunctorAssociator_hom,
    â† NatTrans.comp_app_assoc, â† NatTrans.comp_app, Iso.inv_hom_id_app,
    NatTrans.id_app, NatTrans.id_app, id_comp]",dsimp [mapBifunctorAssociator]
Mathlib/MeasureTheory/Measure/Hausdorff.lean,LipschitzOnWith.hausdorffMeasure_image_le,hausdorffMeasure_image_le,2e39f97941029a908858d0472e3091e677aa35e4,":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left s) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set X : Type u_2
but is expected to have type
  ?m.169595 âˆˆ t n âˆ© ?m.169594 : Prop
error:  simp made no progress","theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s ",":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","rw [â† hausdorffMeasure_image_le, hausdorffMeasure_image_le, hausdorffMeasure_image_le]"
Mathlib/Analysis/Complex/Polynomial.lean,Complex.exists_root,exists_root,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  contrapose! hf
  have : Metric.Bounded (Set.range (eval Â· f)â»Â¹)
  Â· obtain âŸ¨zâ‚€, hâ‚€âŸ© := f.exists_forall_norm_le
    simp only [Pi.inv_apply, bounded_iff_forall_norm_le, Set.forall_range_iff, norm_inv]
    exact âŸ¨â€–eval zâ‚€ fâ€–â»Â¹, fun z => inv_le_inv_of_le (norm_pos_iff.2 <| hf zâ‚€) (hâ‚€ z)âŸ©
  obtain âŸ¨c, hcâŸ© := (f.differentiable.inv hf).exists_const_forall_eq_of_bounded this
  Â· obtain rfl : f = C câ»Â¹ := Polynomial.funext fun z => by rw [eval_C, â† hc z, inv_inv]
    exact degree_C_le","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
f : â„‚[X]
hf : âˆ€ (z : â„‚), Â¬f.IsRoot z
this : sorryAx (Sort ?u.359) true
âŠ¢ f.degree â‰¤ 0
error:  invalid occurrence of universe level 'u_1' at 'Complex.isAlgClosed', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  exists_root.{u_1} (degree_pos_of_irreducible.{0} hp)
at declaration body
  IsAlgClosed.of_exists_root â„‚ fun (_p : â„‚[X]) (x : _p.Monic) (hp : Irreducible _p) â†¦
    exists_root (degree_pos_of_irreducible hp)
error:  failed to synthesize
  IsAlgClosed â„‚
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  IsAlgClosed â„‚
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  IsAlgClosed â„‚
use `set_option diagnostics true` to get diagnostic information","theorem exists_root {f : â„‚[X]} (hf : 0 < degree f) : âˆƒ z : â„‚, IsRoot f z ",":= by
  by_contra! hf'
  have (z : â„‚) : (f.eval z)â»Â¹ = 0 :=
    (f.differentiable.inv hf').apply_eq_of_tendsto_cocompact z <|
      Metric.cobounded_eq_cocompact (Î± := â„‚) â–¸ (Filter.tendsto_invâ‚€_cobounded.comp <| by
        simpa only [tendsto_norm_atTop_iff_cobounded]
          using f.tendsto_norm_atTop hf tendsto_norm_cobounded_atTop)
  obtain rfl : f = C 0 := Polynomial.funext fun z â†¦ inv_injective <| by simp [this]
  simp at hf","obtain âŸ¨z, hzâŸ© : âˆƒ z, degree f â‰  0 := degree_ne_zero_iff.mpr hf"
Mathlib/Topology/Order/UpperLowerSetTopology.lean,Topology.IsUpperSet.closure_eq_lowerClosure,closure_eq_lowerClosure,5553d1d4d9cb54aba8a3131a473b458da599a149,":= by
  rw [subset_antisymm_iff]
  constructor
  Â· apply closure_minimal subset_lowerClosure _
    rw [isClosed_iff_isLower]
    exact LowerSet.lower (lowerClosure s)
  Â· apply lowerClosure_min subset_closure (isClosed_isLower isClosed_closure)",error:  unknown identifier 'isClosed_isLower',lemma closure_eq_lowerClosure {s : Set Î±} : closure s = lowerClosure s ,":= by
  rw [subset_antisymm_iff]
  refine âŸ¨?_, lowerClosure_min subset_closure (isClosed_iff_isLower.1 isClosed_closure)âŸ©
  Â· apply closure_minimal subset_lowerClosure _
    rw [isClosed_iff_isLower]
    exact LowerSet.lower (lowerClosure s)","rw [closure_eq_lowerClosure, closure_eq_lowerClosure]"
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.tendsto_Lp_of_tendstoInMeasure,tendsto_Lp_of_tendstoInMeasure,ff33d25c791a3fac407c782b49018fcb63700d0d,":= by
  refine' tendsto_of_subseq_tendsto fun ns hns => _
  obtain âŸ¨ms, _, hms'âŸ© := TendstoInMeasure.exists_seq_tendsto_ae fun Îµ hÎµ => (hfg Îµ hÎµ).comp hns
  exact âŸ¨ms,
    tendsto_Lp_of_tendsto_ae Î¼ hp hp' (fun _ => hf _) hg (fun Îµ hÎµ =>
      let âŸ¨Î´, hÎ´, hÎ´'âŸ© := hui hÎµ
      âŸ¨Î´, hÎ´, fun i s hs hÎ¼s => hÎ´' _ s hs hÎ¼sâŸ©)
      hms'âŸ©","error:  application type mismatch
  tendsto_Lp_of_tendsto_ae Î¼
argument
  Î¼
has type
  Measure Î± : Type u_1
but is expected to have type
  1 â‰¤ ?m.208770 : Prop
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  ?m.212456","theorem tendsto_Lp_of_tendstoInMeasure [IsFiniteMeasure Î¼] (hp : 1 â‰¤ p) (hp' : p â‰  âˆ)
    (hf : âˆ€ n, AEStronglyMeasurable (f n) Î¼) (hg : Memâ„’p g p Î¼) (hui : UnifIntegrable f p Î¼)
    (hfg : TendstoInMeasure Î¼ f atTop g) : Tendsto (fun n => snorm (f n - g) p Î¼) atTop (ğ“ 0) ",":= by
  refine tendsto_of_subseq_tendsto fun ns hns => ?_
  obtain âŸ¨ms, _, hms'âŸ© := TendstoInMeasure.exists_seq_tendsto_ae fun Îµ hÎµ => (hfg Îµ hÎµ).comp hns
  exact âŸ¨ms,
    tendsto_Lp_of_tendsto_ae hp hp' (fun _ => hf _) hg (fun Îµ hÎµ =>
      let âŸ¨Î´, hÎ´, hÎ´'âŸ© := hui hÎµ
      âŸ¨Î´, hÎ´, fun i s hs hÎ¼s => hÎ´' _ s hs hÎ¼sâŸ©)
      hms'âŸ©",refine tendsto_Lp_of_tendstoInMeasure_of_unifIntegrable hp hp' hf hfg hf hfg hf hfg hfg hf hfg
Mathlib/Topology/PartitionOfUnity.lean,PartitionOfUnity.exists_isSubordinate_of_locallyFinite,exists_isSubordinate_of_locallyFinite,47189ba3b5745e8b76312e34fe4a6c87e0d76e90,":= by
  rcases exists_subset_unionáµ¢_closure_subset hs ho (fun x _ => hf.point_finite x) hU with
    âŸ¨V, hsV, hVo, hVUâŸ©
  have hVU' : âˆ€ i, V i âŠ† U i := fun i => Subset.trans subset_closure (hVU i)
  rcases exists_subset_unionáµ¢_closure_subset hs hVo (fun x _ => (hf.subset hVU').point_finite x)
      hsV with
    âŸ¨W, hsW, hWo, hWVâŸ©
  choose f hfp hf0 hf1 hf01 using fun i =>
    h01 _ _ (isClosed_compl_iff.2 <| hVo i) isClosed_closure
      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))
  have hsupp : âˆ€ i, support (f i) âŠ† V i := fun i => support_subset_iff'.2 (hf0 i)
  refine' âŸ¨âŸ¨f, hf.subset fun i => Subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1,
      fun i x => (hf01 i x).2, fun x hx => _âŸ©,
    hfp, fun i => Subset.trans (closure_mono (hsupp i)) (hVU i)âŸ©
  rcases mem_unionáµ¢.1 (hsW hx) with âŸ¨i, hiâŸ©
  exact âŸ¨i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)âŸ©","error:  unknown identifier 'exists_subset_unionáµ¢_closure_subset'
error:  rcases tactic failed: xâœ : ?m.93115 is not an inductive datatype","theorem exists_isSubordinate_of_locallyFinite_of_prop [NormalSpace X] (p : (X â†’ â„) â†’ Prop)
    (h01 : âˆ€ s t, IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’
      âˆƒ f : C(X, â„), p f âˆ§ EqOn f 0 s âˆ§ EqOn f 1 t âˆ§ âˆ€ x, f x âˆˆ Icc (0 : â„) 1)
    (hs : IsClosed s) (U : Î¹ â†’ Set X) (ho : âˆ€ i, IsOpen (U i)) (hf : LocallyFinite U)
    (hU : s âŠ† â‹ƒ i, U i) : âˆƒ f : BumpCovering Î¹ X s, (âˆ€ i, p (f i)) âˆ§ f.IsSubordinate U ",":= by
  rcases exists_subset_iUnion_closure_subset hs ho (fun x _ => hf.point_finite x) hU with
    âŸ¨V, hsV, hVo, hVUâŸ©
  have hVU' : âˆ€ i, V i âŠ† U i := fun i => Subset.trans subset_closure (hVU i)
  rcases exists_subset_iUnion_closure_subset hs hVo (fun x _ => (hf.subset hVU').point_finite x)
      hsV with
    âŸ¨W, hsW, hWo, hWVâŸ©
  choose f hfp hf0 hf1 hf01 using fun i =>
    h01 _ _ (isClosed_compl_iff.2 <| hVo i) isClosed_closure
      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))
  have hsupp : âˆ€ i, support (f i) âŠ† V i := fun i => support_subset_iff'.2 (hf0 i)
  refine âŸ¨âŸ¨f, hf.subset fun i => Subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1,
      fun i x => (hf01 i x).2, fun x hx => ?_âŸ©,
    hfp, fun i => Subset.trans (closure_mono (hsupp i)) (hVU i)âŸ©
  rcases mem_iUnion.1 (hsW hx) with âŸ¨i, hiâŸ©
  exact âŸ¨i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)âŸ©","refine âŸ¨exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite
  exists_isSubordinate_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_of_locallyFinite_o"
Mathlib/Analysis/NormedSpace/Unitization.lean,Unitization.norm_eq_sup,norm_eq_sup,5ccbcd7e4cf1c516e085964a7c17872d8de47255,":= by
  rw [norm_def, leftRegRep_apply, Prod.norm_def, sup_eq_max]","error:  unknown identifier 'leftRegRep_apply'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.92990
ğ•œ : Type u_1
A : Type u_2
instâœâµ : NontriviallyNormedField ğ•œ
instâœâ´ : NonUnitalNormedRing A
instâœÂ³ : NormedSpace ğ•œ A
instâœÂ² : IsScalarTower ğ•œ A A
instâœÂ¹ : SMulCommClass ğ•œ A A
instâœ : RegularNormedAlgebra ğ•œ A
x : Unitization ğ•œ A
âŠ¢ â€–(splitMul ğ•œ A) xâ€– = â€–x.fstâ€– âŠ” â€–(algebraMap ğ•œ (A â†’L[ğ•œ] A)) x.fst + (mul ğ•œ A) x.sndâ€–","theorem norm_eq_sup (x : Unitization ğ•œ A) :
    â€–xâ€– = â€–x.fstâ€– âŠ” â€–algebraMap ğ•œ (A â†’L[ğ•œ] A) x.fst + mul ğ•œ A x.sndâ€– ",":= by
  rw [norm_def, splitMul_apply, Prod.norm_def, sup_eq_max]","simp only [norm_eq_sup, norm_eq_sup, Unitization.algebraMap_apply, Unitization.algebraMap_apply,
  Unitization.algebraMap_apply]"
Mathlib/LinearAlgebra/Matrix/Spectrum.lean,Matrix.IsHermitian.rank_eq_rank_diagonal,rank_eq_rank_diagonal,500f09625c1cfaf931c3176192f29a271267bf51,":= by
  conv_lhs => rw [hA.spectral_theorem2]
  have hG : (hA.eigenvectorUnitary.1) * (star (hA.eigenvectorUnitary.1)) = 1 := by
          simp only [hA.eigenvectorUnitary.2, unitary.mul_star_self_of_mem]
  have hE := isUnit_det_of_right_inverse hG
  have hE1 := isUnit_det_of_left_inverse hG
  rw [mul_assoc ,rank_mul_eq_right_of_isUnit_det
  (B := diagonal (RCLike.ofReal (K := ğ•œ) âˆ˜ eigenvalues hA) * (star (hA.eigenvectorUnitary.1)))
  (A := (hA.eigenvectorUnitary.1)) (hA := hE)]
  rw [rank_mul_eq_left_of_isUnit_det
      (B := diagonal (RCLike.ofReal âˆ˜ eigenvalues hA)) (A := star (hA.eigenvectorUnitary.1)) hE1]
  simp only [rank_diagonal, Function.comp_apply, ne_eq, algebraMap.lift_map_eq_zero_iff]","error:  invalid field 'spectral_theorem2', the environment does not contain 'Matrix.IsHermitian.spectral_theorem2'
  hA
has type
  A.IsHermitian
error:  invalid field 'spectral_theorem2', the environment does not contain 'Eq.spectral_theorem2'
  hA
has type
  Aá´´ = A
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.98289
ğ•œ : Type u_1
instâœÂ² : RCLike ğ•œ
n : Type u_2
instâœÂ¹ : Fintype n
A : Matrix n n ğ•œ
instâœ : DecidableEq n
hA : A.IsHermitian
| A.rank",lemma rank_eq_rank_diagonal : A.rank = (Matrix.diagonal hA.eigenvalues).rank ,":= by
  conv_lhs => rw [hA.spectral_theorem, â† unitary.coe_star]
  simp [-isUnit_iff_ne_zero, -unitary.coe_star, rank_diagonal]",rw [rank_eq_rank_diagonal]
Mathlib/Topology/Compactness/Paracompact.lean,refinement_of_locallyCompact_sigmaCompact_of_nhds_basis,refinement_of_locallyCompact_sigmaCompact_of_nhds_basis,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  classical
    set K' : CompactExhaustion X := CompactExhaustion.choice X
    set K : CompactExhaustion X := K'.shiftr.shiftr
    set Kdiff := fun n â†¦ K (n + 1) \ interior (K n)
    have hKcov : âˆ€ x, x âˆˆ Kdiff (K'.find x + 1) := fun x â†¦ by
      simpa only [K'.find_shiftr] using
        diff_subset_diff_right interior_subset (K'.shiftr.mem_diff_shiftr_find x)
    have Kdiffc : âˆ€ n, IsCompact (Kdiff n âˆ© s) :=
      fun n â†¦ ((K.isCompact _).diff isOpen_interior).inter_right hs
    have : âˆ€ (n) (x : â†‘(Kdiff (n + 1) âˆ© s)), (K n)á¶œ âˆˆ ğ“ (x : X) :=
      fun n x â†¦ (K.isClosed n).compl_mem_nhds fun hx' â†¦ x.2.1.2 <| K.subset_interior_succ _ hx'
    choose! r hrp hr using fun n (x : â†‘(Kdiff (n + 1) âˆ© s)) â†¦ (hB x x.2.2).mem_iff.1 (this n x)
    have hxr : âˆ€ (n x) (hx : x âˆˆ Kdiff (n + 1) âˆ© s), B x (r n âŸ¨x, hxâŸ©) âˆˆ ğ“ x := fun n x hx â†¦
      (hB x hx.2).mem_of_mem (hrp _ âŸ¨x, hxâŸ©)
    choose T hT using fun n â†¦ (Kdiffc (n + 1)).elim_nhds_subcover' _ (hxr n)
    set T' : âˆ€ n, Set â†‘(Kdiff (n + 1) âˆ© s) := fun n â†¦ T n
    refine âŸ¨Î£n, T' n, fun a â†¦ a.2, fun a â†¦ r a.1 a.2, ?_,? _?, _âŸ©
    Â· rintro âŸ¨n, x, hxâŸ©
      exact âŸ¨x.2.2, hrp _ _âŸ©
    Â· refine fun x hx â†¦ mem_iUnion.2 ?_
      rcases mem_iUnionâ‚‚.1 (hT _ âŸ¨hKcov x, hxâŸ©) with âŸ¨âŸ¨c, hcâŸ©, hcT, hcxâŸ©
      exact âŸ¨âŸ¨_, âŸ¨c, hcâŸ©, hcTâŸ©, hcxâŸ©
    Â· intro x
      refine
        âŸ¨interior (K (K'.find x + 3)),
          IsOpen.mem_nhds isOpen_interior (K.subset_interior_succ _ (hKcov x).1), ?_âŸ©
      have : (â‹ƒ k â‰¤ K'.find x + 2, range (Sigma.mk k) : Set (Î£n, T' n)).Finite :=
        (finite_le_nat _).biUnion fun k _ â†¦ finite_range _
      apply this.subset
      rintro âŸ¨k, c, hcâŸ©
      simp only [mem_iUnion, mem_setOf_eq, mem_image, Subtype.coe_mk]
      rintro âŸ¨x, hxB : x âˆˆ B c (r k c), hxKâŸ©
      refine âŸ¨k, ?_, âŸ¨c, hcâŸ©, rflâŸ©
      have := (mem_compl_iff _ _).1 (hr k c hxB)
      contrapose! this with hnk
      exact K.subset hnk (interior_subset hxK)","error:  don't know how to synthesize placeholder for argument 'right'
context:
Î¹âœ : Type u
X : Type v
Y : Type w
instâœâ´ : TopologicalSpace X
instâœÂ³ : TopologicalSpace Y
instâœÂ² : WeaklyLocallyCompactSpace X
instâœÂ¹ : SigmaCompactSpace X
instâœ : T2Space X
Î¹ : X â†’ Type u
p : (x : X) â†’ Î¹ x â†’ Prop
B : (x : X) â†’ Î¹ x â†’ Set X
s : Set X
hs : IsClosed s
hB : âˆ€ x âˆˆ s, (ğ“ x).HasBasis (p x) (B x)
K' : CompactExhaustion X := CompactExhaustion.choice X
K : CompactExhaustion X := K'.shiftr.shiftr
Kdiff : â„• â†’ Set X := fun n â†¦ K (n + 1) \ interior (K n)
hKcov : âˆ€ (x : X), x âˆˆ Kdiff (K'.find x + 1)
Kdiffc : âˆ€ (n : â„•), IsCompact (Kdiff n âˆ© s)
this : âˆ€ (n : â„•) (x : â†‘(Kdiff (n + 1) âˆ© s)), (K n)á¶œ âˆˆ ğ“ â†‘x
r : (n : â„•) â†’ (x : â†‘(Kdiff (n + 1) âˆ© s)) â†’ Î¹ â†‘x
hrp : âˆ€ (n : â„•) (x : â†‘(Kdiff (n + 1) âˆ© s)), p (â†‘x) (r n x)
hr : âˆ€ (n : â„•) (x : â†‘(Kdiff (n + 1) âˆ© s)), B (â†‘x) (r n x) âŠ† (K n)á¶œ
hxr : âˆ€ (n : â„•) (x : X) (hx : x âˆˆ Kdiff (n + 1) âˆ© s), B x (r n âŸ¨x, hxâŸ©) âˆˆ ğ“ x
T : (n : â„•) â†’ Finset â†‘(Kdiff (n + 1) âˆ© s)
hT : âˆ€ (n : â„•), Kdiff (n + 1) âˆ© s âŠ† â‹ƒ x âˆˆ T n, B (â†‘x) (r n âŸ¨â†‘x, â‹¯âŸ©)
T' : (n : â„•) â†’ Set â†‘(Kdiff (n + 1) âˆ© s) := fun n â†¦ â†‘(T n)
âŠ¢ LocallyFinite fun a â†¦ B ((fun a â†¦ â†‘â†‘a.snd) a) ((fun a â†¦ r a.fst â†‘a.snd) a)
error:  unsolved goals
Î¹âœ : Type u
X : Type v
Y : Type w
instâœâ´ : TopologicalSpace X
instâœÂ³ : TopologicalSpace Y
instâœÂ² : WeaklyLocallyCompactSpace X
instâœÂ¹ : SigmaCompactSpace X
instâœ : T2Space X
Î¹ : X â†’ Type u
p : (x : X) â†’ Î¹ x â†’ Prop
B : (x : X) â†’ Î¹ x â†’ Set X
s : Set X
hs : IsClosed s
hB : âˆ€ x âˆˆ s, (ğ“ x).HasBasis (p x) (B x)
K' : CompactExhaustion X := CompactExhaustion.choice X
K : CompactExhaustion X := K'.shiftr.shiftr
Kdiff : â„• â†’ Set X := fun n â†¦ K (n + 1) \ interior (K n)
hKcov : âˆ€ (x : X), x âˆˆ Kdiff (K'.find x + 1)
Kdiffc : âˆ€ (n : â„•), IsCompact (Kdiff n âˆ© s)
this : âˆ€ (n : â„•) (x : â†‘(Kdiff (n + 1) âˆ© s)), (K n)á¶œ âˆˆ ğ“ â†‘x
r : (n : â„•) â†’ (x : â†‘(Kdiff (n + 1) âˆ© s)) â†’ Î¹ â†‘x
hrp : âˆ€ (n : â„•) (x : â†‘(Kdiff (n + 1) âˆ© s)), p (â†‘x) (r n x)
hr : âˆ€ (n : â„•) (x : â†‘(Kdiff (n + 1) âˆ© s)), B (â†‘x) (r n x) âŠ† (K n)á¶œ
hxr : âˆ€ (n : â„•) (x : X) (hx : x âˆˆ Kdiff (n + 1) âˆ© s), B x (r n âŸ¨x, hxâŸ©) âˆˆ ğ“ x
T : (n : â„•) â†’ Finset â†‘(Kdiff (n + 1) âˆ© s)
hT : âˆ€ (n : â„•), Kdiff (n + 1) âˆ© s âŠ† â‹ƒ x âˆˆ T n, B (â†‘x) (r n âŸ¨â†‘x, â‹¯âŸ©)
T' : (n : â„•) â†’ Set â†‘(Kdiff (n + 1) âˆ© s) := fun n â†¦ â†‘(T n)
âŠ¢ âˆƒ Î± c r, (âˆ€ (a : Î±), c a âˆˆ s âˆ§ p (c a) (r a)) âˆ§ s âŠ† â‹ƒ a, B (c a) (r a) âˆ§ LocallyFinite fun a â†¦ B (c a) (r a)","theorem refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set [WeaklyLocallyCompactSpace X]
    [SigmaCompactSpace X] [T2Space X] {Î¹ : X â†’ Type u} {p : âˆ€ x, Î¹ x â†’ Prop} {B : âˆ€ x, Î¹ x â†’ Set X}
    {s : Set X} (hs : IsClosed s) (hB : âˆ€ x âˆˆ s, (ğ“ x).HasBasis (p x) (B x)) :
    âˆƒ (Î± : Type v) (c : Î± â†’ X) (r : âˆ€ a, Î¹ (c a)),
      (âˆ€ a, c a âˆˆ s âˆ§ p (c a) (r a)) âˆ§
        (s âŠ† â‹ƒ a, B (c a) (r a)) âˆ§ LocallyFinite fun a â†¦ B (c a) (r a) ",":= by
  classical
    set K' : CompactExhaustion X := CompactExhaustion.choice X
    set K : CompactExhaustion X := K'.shiftr.shiftr
    set Kdiff := fun n â†¦ K (n + 1) \ interior (K n)
    have hKcov : âˆ€ x, x âˆˆ Kdiff (K'.find x + 1) := fun x â†¦ by
      simpa only [K'.find_shiftr] using
        diff_subset_diff_right interior_subset (K'.shiftr.mem_diff_shiftr_find x)
    have Kdiffc : âˆ€ n, IsCompact (Kdiff n âˆ© s) :=
      fun n â†¦ ((K.isCompact _).diff isOpen_interior).inter_right hs
    have : âˆ€ (n) (x : â†‘(Kdiff (n + 1) âˆ© s)), (K n)á¶œ âˆˆ ğ“ (x : X) :=
      fun n x â†¦ (K.isClosed n).compl_mem_nhds fun hx' â†¦ x.2.1.2 <| K.subset_interior_succ _ hx'
    choose! r hrp hr using fun n (x : â†‘(Kdiff (n + 1) âˆ© s)) â†¦ (hB x x.2.2).mem_iff.1 (this n x)
    have hxr : âˆ€ (n x) (hx : x âˆˆ Kdiff (n + 1) âˆ© s), B x (r n âŸ¨x, hxâŸ©) âˆˆ ğ“ x := fun n x hx â†¦
      (hB x hx.2).mem_of_mem (hrp _ âŸ¨x, hxâŸ©)
    choose T hT using fun n â†¦ (Kdiffc (n + 1)).elim_nhds_subcover' _ (hxr n)
    set T' : âˆ€ n, Set â†‘(Kdiff (n + 1) âˆ© s) := fun n â†¦ T n
    refine âŸ¨Î£n, T' n, fun a â†¦ a.2, fun a â†¦ r a.1 a.2, ?_, ?_, ?_âŸ©
    Â· rintro âŸ¨n, x, hxâŸ©
      exact âŸ¨x.2.2, hrp _ _âŸ©
    Â· refine fun x hx â†¦ mem_iUnion.2 ?_
      rcases mem_iUnionâ‚‚.1 (hT _ âŸ¨hKcov x, hxâŸ©) with âŸ¨âŸ¨c, hcâŸ©, hcT, hcxâŸ©
      exact âŸ¨âŸ¨_, âŸ¨c, hcâŸ©, hcTâŸ©, hcxâŸ©
    Â· intro x
      refine
        âŸ¨interior (K (K'.find x + 3)),
          IsOpen.mem_nhds isOpen_interior (K.subset_interior_succ _ (hKcov x).1), ?_âŸ©
      have : (â‹ƒ k â‰¤ K'.find x + 2, range (Sigma.mk k) : Set (Î£n, T' n)).Finite :=
        (finite_le_nat _).biUnion fun k _ â†¦ finite_range _
      apply this.subset
      rintro âŸ¨k, c, hcâŸ©
      simp only [mem_iUnion, mem_setOf_eq, mem_image, Subtype.coe_mk]
      rintro âŸ¨x, hxB : x âˆˆ B c (r k c), hxKâŸ©
      refine âŸ¨k, ?_, âŸ¨c, hcâŸ©, rflâŸ©
      have := (mem_compl_iff _ _).1 (hr k c hxB)
      contrapose! this with hnk
      exact K.subset hnk (interior_subset hxK)",refine theorem_refinement_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyCompact_of_locallyComp
Mathlib/MeasureTheory/Integral/MeanInequalities.lean,ENNReal.lintegral_prod_norm_pow_le,lintegral_prod_norm_pow_le,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction s generalizing p with
  | empty =>
    simp at hp
  | @insert iâ‚€ s hiâ‚€ ih =>
    rcases eq_or_ne (p iâ‚€) 1 with h2iâ‚€|h2iâ‚€
    Â· simp [hiâ‚€]
      have h2p : âˆ€ i âˆˆ s, p i = 0 := by
        simpa [hiâ‚€, h2iâ‚€, sum_eq_zero_iff_of_nonneg (fun i hi â†¦ h2p i <| mem_insert_of_mem hi)]
          using hp
      calc âˆ«â» a, f iâ‚€ a ^ p iâ‚€ * âˆ i âˆˆ s, f i a ^ p i âˆ‚Î¼
          = âˆ«â» a, f iâ‚€ a ^ p iâ‚€ * âˆ i âˆˆ s, 1 âˆ‚Î¼ := by
            congr! 3 with x
            apply prod_congr rfl fun i hi â†¦ by rw [h2p i hi, ENNReal.rpow_zero]
        _ â‰¤ (âˆ«â» a, f iâ‚€ a âˆ‚Î¼) ^ p iâ‚€ * âˆ i âˆˆ s, 1 := by simp [h2iâ‚€]
        _ = (âˆ«â» a, f iâ‚€ a âˆ‚Î¼) ^ p iâ‚€ * âˆ i âˆˆ s, (âˆ«â» a, f i a âˆ‚Î¼) ^ p i := by
            congr 1
            apply prod_congr rfl fun i hi â†¦ by rw [h2p i hi, ENNReal.rpow_zero]
    Â· have hpiâ‚€ : 0 â‰¤ 1 - p iâ‚€ := by
        simp_rw [sub_nonneg, â† hp, single_le_sum h2p (mem_insert_self ..)]
      have h2piâ‚€ : 1 - p iâ‚€ â‰  0 := by
        rwa [sub_ne_zero, ne_comm]
      let q := fun i â†¦ p i / (1 - p iâ‚€)
      have hq : âˆ‘ i âˆˆ s, q i = 1 := by
        rw [â† Finset.sum_div, â† sum_insert_sub hiâ‚€, hp, div_self h2piâ‚€]
      have h2q : âˆ€ i âˆˆ s, 0 â‰¤ q i :=
        fun i hi â†¦ div_nonneg (h2p i <| mem_insert_of_mem hi) hpiâ‚€
      calc âˆ«â» a, âˆ i âˆˆ insert iâ‚€ s, f i a ^ p i âˆ‚Î¼
          = âˆ«â» a, f iâ‚€ a ^ p iâ‚€ * âˆ i âˆˆ s, f i a ^ p i âˆ‚Î¼ := by simp [hiâ‚€]
        _ = âˆ«â» a, f iâ‚€ a ^ p iâ‚€ * (âˆ i âˆˆ s, f i a ^ q i) ^ (1 - p iâ‚€) âˆ‚Î¼ := by
            simp [â† ENNReal.prod_rpow_of_nonneg hpiâ‚€, â† ENNReal.rpow_mul,
              div_mul_cancelâ‚€ (h := h2piâ‚€)]
        _ â‰¤ (âˆ«â» a, f iâ‚€ a âˆ‚Î¼) ^ p iâ‚€ * (âˆ«â» a, âˆ i âˆˆ s, f i a ^ q i âˆ‚Î¼) ^ (1 - p iâ‚€) := by
            apply ENNReal.lintegral_mul_norm_pow_le
            Â· exact hf iâ‚€ <| mem_insert_self ..
            Â· exact s.aemeasurable_prod fun i hi â†¦ (hf i <| mem_insert_of_mem hi).pow_const _
            Â· exact h2p iâ‚€ <| mem_insert_self ..
            Â· exact hpiâ‚€
            Â· apply add_sub_cancel
        _ â‰¤ (âˆ«â» a, f iâ‚€ a âˆ‚Î¼) ^ p iâ‚€ * (âˆ i âˆˆ s, (âˆ«â» a, f i a âˆ‚Î¼) ^ q i) ^ (1 - p iâ‚€) := by
            gcongr 
            exact ih (fun i hi â†¦ hf i <| mem_insert_of_mem hi) hq h2q
        _ = (âˆ«â» a, f iâ‚€ a âˆ‚Î¼) ^ p iâ‚€ * âˆ i âˆˆ s, (âˆ«â» a, f i a âˆ‚Î¼) ^ p i := by
            simp [â† ENNReal.prod_rpow_of_nonneg hpiâ‚€, â† ENNReal.rpow_mul,
              div_mul_cancelâ‚€ (h := h2piâ‚€)]
        _ = âˆ i âˆˆ insert iâ‚€ s, (âˆ«â» a, f i a âˆ‚Î¼) ^ p i := by simp [hiâ‚€]",error:  invalid alternative name 'empty',"theorem lintegral_prod_norm_pow_le {Î± Î¹ : Type*} [MeasurableSpace Î±] {Î¼ : Measure Î±}
    (s : Finset Î¹) {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} (hf : âˆ€ i âˆˆ s, AEMeasurable (f i) Î¼)
    {p : Î¹ â†’ â„} (hp : âˆ‘ i âˆˆ s, p i = 1) (h2p : âˆ€ i âˆˆ s, 0 â‰¤ p i) :
    âˆ«â» a, âˆ i âˆˆ s, f i a ^ p i âˆ‚Î¼ â‰¤ âˆ i âˆˆ s, (âˆ«â» a, f i a âˆ‚Î¼) ^ p i ",":= by
  induction s using Finset.induction generalizing p with
  | empty =>
    simp at hp
  | @insert iâ‚€ s hiâ‚€ ih =>
    rcases eq_or_ne (p iâ‚€) 1 with h2iâ‚€|h2iâ‚€
    Â· simp [hiâ‚€]
      have h2p : âˆ€ i âˆˆ s, p i = 0 := by
        simpa [hiâ‚€, h2iâ‚€, sum_eq_zero_iff_of_nonneg (fun i hi â†¦ h2p i <| mem_insert_of_mem hi)]
          using hp
      calc âˆ«â» a, f iâ‚€ a ^ p iâ‚€ * âˆ i âˆˆ s, f i a ^ p i âˆ‚Î¼
          = âˆ«â» a, f iâ‚€ a ^ p iâ‚€ * âˆ i âˆˆ s, 1 âˆ‚Î¼ := by
            congr! 3 with x
            apply prod_congr rfl fun i hi â†¦ by rw [h2p i hi, ENNReal.rpow_zero]
        _ â‰¤ (âˆ«â» a, f iâ‚€ a âˆ‚Î¼) ^ p iâ‚€ * âˆ i âˆˆ s, 1 := by simp [h2iâ‚€]
        _ = (âˆ«â» a, f iâ‚€ a âˆ‚Î¼) ^ p iâ‚€ * âˆ i âˆˆ s, (âˆ«â» a, f i a âˆ‚Î¼) ^ p i := by
            congr 1
            apply prod_congr rfl fun i hi â†¦ by rw [h2p i hi, ENNReal.rpow_zero]
    Â· have hpiâ‚€ : 0 â‰¤ 1 - p iâ‚€ := by
        simp_rw [sub_nonneg, â† hp, single_le_sum h2p (mem_insert_self ..)]
      have h2piâ‚€ : 1 - p iâ‚€ â‰  0 := by
        rwa [sub_ne_zero, ne_comm]
      let q := fun i â†¦ p i / (1 - p iâ‚€)
      have hq : âˆ‘ i âˆˆ s, q i = 1 := by
        rw [â† Finset.sum_div, â† sum_insert_sub hiâ‚€, hp, div_self h2piâ‚€]
      have h2q : âˆ€ i âˆˆ s, 0 â‰¤ q i :=
        fun i hi â†¦ div_nonneg (h2p i <| mem_insert_of_mem hi) hpiâ‚€
      calc âˆ«â» a, âˆ i âˆˆ insert iâ‚€ s, f i a ^ p i âˆ‚Î¼
          = âˆ«â» a, f iâ‚€ a ^ p iâ‚€ * âˆ i âˆˆ s, f i a ^ p i âˆ‚Î¼ := by simp [hiâ‚€]
        _ = âˆ«â» a, f iâ‚€ a ^ p iâ‚€ * (âˆ i âˆˆ s, f i a ^ q i) ^ (1 - p iâ‚€) âˆ‚Î¼ := by
            simp [â† ENNReal.prod_rpow_of_nonneg hpiâ‚€, â† ENNReal.rpow_mul,
              div_mul_cancelâ‚€ (h := h2piâ‚€)]
        _ â‰¤ (âˆ«â» a, f iâ‚€ a âˆ‚Î¼) ^ p iâ‚€ * (âˆ«â» a, âˆ i âˆˆ s, f i a ^ q i âˆ‚Î¼) ^ (1 - p iâ‚€) := by
            apply ENNReal.lintegral_mul_norm_pow_le
            Â· exact hf iâ‚€ <| mem_insert_self ..
            Â· exact s.aemeasurable_prod fun i hi â†¦ (hf i <| mem_insert_of_mem hi).pow_const _
            Â· exact h2p iâ‚€ <| mem_insert_self ..
            Â· exact hpiâ‚€
            Â· apply add_sub_cancel
        _ â‰¤ (âˆ«â» a, f iâ‚€ a âˆ‚Î¼) ^ p iâ‚€ * (âˆ i âˆˆ s, (âˆ«â» a, f i a âˆ‚Î¼) ^ q i) ^ (1 - p iâ‚€) := by
            gcongr 
            exact ih (fun i hi â†¦ hf i <| mem_insert_of_mem hi) hq h2q
        _ = (âˆ«â» a, f iâ‚€ a âˆ‚Î¼) ^ p iâ‚€ * âˆ i âˆˆ s, (âˆ«â» a, f i a âˆ‚Î¼) ^ p i := by
            simp [â† ENNReal.prod_rpow_of_nonneg hpiâ‚€, â† ENNReal.rpow_mul,
              div_mul_cancelâ‚€ (h := h2piâ‚€)]
        _ = âˆ i âˆˆ insert iâ‚€ s, (âˆ«â» a, f i a âˆ‚Î¼) ^ p i := by simp [hiâ‚€]",rw [lintegral_prod_norm_pow_le]
Mathlib/Algebra/Group/Units.lean,isUnit_of_subsingleton,isUnit_of_subsingleton,25527279cf0fc38a336bb3b3d913a403b5f38ac1,":=
  âŸ¨âŸ¨a, a, by subsingleton, by subsingletonâŸ©, rflâŸ©","warning:  Units does not have a doc string
warning:  @divp does not have a doc string
error:  unknown tactic",theorem isUnit_of_subsingleton [Monoid M] [Subsingleton M] (a : M) : IsUnit a ,":=
  âŸ¨âŸ¨a, a, Subsingleton.elim _ _, Subsingleton.elim _ _âŸ©, rflâŸ©",exact isUnit_of_subsingleton a
Mathlib/Algebra/Lie/TraceForm.lean,LieModule.traceForm_eq_sum_finrank_nsmul_mul,traceForm_eq_sum_finrank_nsmul_mul,2d8928f07c222f171d2f9371935aa5b8359f9d44,":= by
  have hxy : âˆ€ Ï‡ : Weight K L M, MapsTo (toEndomorphism K L M x âˆ˜â‚— toEndomorphism K L M y)
      (weightSpace M Ï‡) (weightSpace M Ï‡) :=
    fun Ï‡ m hm â†¦ LieSubmodule.lie_mem _ <| LieSubmodule.lie_mem _ hm
  classical
  have hds := DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top
    (LieSubmodule.independent_iff_coe_toSubmodule.mp <| independent_weightSpace' K L M)
    (LieSubmodule.iSup_eq_top_iff_coe_toSubmodule.mp <| iSup_weightSpace_eq_top' K L M)
  simp_rw [traceForm_apply_apply, LinearMap.trace_eq_sum_trace_restrict hds hxy,
    â† traceForm_weightSpace_eq K L M _ x y]
  rfl","error:  unknown identifier 'toEndomorphism'
error:  unknown identifier 'toEndomorphism'
error:  application type mismatch
  ?m.509739.lie_mem hm
argument
  hm
has type
  m âˆˆ ?m.505992 Ï‡ : Prop
but is expected to have type
  m âˆˆ (â†‘?m.509739).carrier : Prop","lemma traceForm_eq_sum_finrank_nsmul_mul (x y : L) :
    traceForm K L M x y = âˆ‘ Ï‡ : Weight K L M, finrank K (weightSpace M Ï‡) â€¢ (Ï‡ x * Ï‡ y) ",":= by
  have hxy : âˆ€ Ï‡ : Weight K L M, MapsTo (toEnd K L M x âˆ˜â‚— toEnd K L M y)
      (weightSpace M Ï‡) (weightSpace M Ï‡) :=
    fun Ï‡ m hm â†¦ LieSubmodule.lie_mem _ <| LieSubmodule.lie_mem _ hm
  classical
  have hds := DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top
    (LieSubmodule.independent_iff_coe_toSubmodule.mp <| independent_weightSpace' K L M)
    (LieSubmodule.iSup_eq_top_iff_coe_toSubmodule.mp <| iSup_weightSpace_eq_top' K L M)
  simp_rw [traceForm_apply_apply, LinearMap.trace_eq_sum_trace_restrict hds hxy,
    â† traceForm_weightSpace_eq K L M _ x y]
  rfl",rw [traceForm_eq_sum_finrank_nsmul_mul]
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.unifIntegrable_of',unifIntegrable_of',6dc3dbdf49e99fd503fbaec82927b88abe45c948,":= by
  have hpzero := (lt_of_lt_of_le zero_lt_one hp).ne.symm
  by_cases hÎ¼ : Î¼ Set.univ = 0
  Â· rw [Measure.measure_univ_eq_zero] at hÎ¼
    exact hÎ¼.symm â–¸ unifIntegrable_zero_meas
  intro Îµ hÎµ
  obtain âŸ¨C, hCpos, hCâŸ© := h (Îµ / 2) (half_pos hÎµ)
  refine' âŸ¨(Îµ / (2 * C)) ^ ENNReal.toReal p,
    Real.rpow_pos_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos))) _,
    fun i s hs hÎ¼s => _âŸ©
  by_cases hÎ¼s' : Î¼ s = 0
  Â· rw [(snorm_eq_zero_iff ((hf i).indicator hs).aestronglyMeasurable hpzero).2
        (indicator_meas_zero hÎ¼s')]
    set_option tactic.skipAssignedInstances false in norm_num
  calc
    snorm (Set.indicator s (f i)) p Î¼ â‰¤
        snorm (Set.indicator (s âˆ© { x | C â‰¤ â€–f i xâ€–â‚Š }) (f i)) p Î¼ +
          snorm (Set.indicator (s âˆ© { x | â€–f i xâ€–â‚Š < C }) (f i)) p Î¼ := by
      refine' le_trans (Eq.le _) (snorm_add_le
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter (stronglyMeasurable_const.measurableSet_le (hf i).nnnorm))))
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter ((hf i).nnnorm.measurableSet_lt stronglyMeasurable_const))))
        hp)
      congr
      change _ = fun x => (s âˆ© { x : Î± | C â‰¤ â€–f i xâ€–â‚Š }).indicator (f i) x +
        (s âˆ© { x : Î± | â€–f i xâ€–â‚Š < C }).indicator (f i) x
      rw [â† Set.indicator_union_of_disjoint]
      Â· rw [â† Set.inter_union_distrib_left, (by ext; simp [le_or_lt] :
            { x : Î± | C â‰¤ â€–f i xâ€–â‚Š } âˆª { x : Î± | â€–f i xâ€–â‚Š < C } = Set.univ),
          Set.inter_univ]
      Â· refine' (Disjoint.inf_right' _ _).inf_left' _
        rw [disjoint_iff_inf_le]
        rintro x âŸ¨hxâ‚, hxâ‚‚âŸ©
        rw [Set.mem_setOf_eq] at hxâ‚ hxâ‚‚
        exact False.elim (hxâ‚‚.ne (eq_of_le_of_not_lt hxâ‚ (not_lt.2 hxâ‚‚.le)).symm)
    _ â‰¤ snorm (Set.indicator { x | C â‰¤ â€–f i xâ€–â‚Š } (f i)) p Î¼ +
        (C : â„â‰¥0âˆ) * Î¼ s ^ (1 / ENNReal.toReal p) := by
      refine' add_le_add
        (snorm_mono fun x => norm_indicator_le_of_subset (Set.inter_subset_right _ _) _ _) _
      rw [â† Set.indicator_indicator]
      rw [snorm_indicator_eq_snorm_restrict hs]
      have : âˆ€áµ x âˆ‚Î¼.restrict s, â€–{ x : Î± | â€–f i xâ€–â‚Š < C }.indicator (f i) xâ€– â‰¤ C := by
        filter_upwards
        simp_rw [norm_indicator_eq_indicator_norm]
        exact Set.indicator_le' (fun x (hx : _ < _) => hx.le) fun _ _ => NNReal.coe_nonneg _
      refine' le_trans (snorm_le_of_ae_bound this) _
      rw [mul_comm, Measure.restrict_apply' hs, Set.univ_inter, ENNReal.ofReal_coe_nnreal, one_div]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + C * ENNReal.ofReal (Îµ / (2 * C)) := by
      refine' add_le_add (hC i) (mul_le_mul_left' _ _)
      rwa [ENNReal.rpow_one_div_le_iff (ENNReal.toReal_pos hpzero hp'),
        ENNReal.ofReal_rpow_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos)))]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + ENNReal.ofReal (Îµ / 2) := by
      apply add_le_add_left
      rw [â† ENNReal.ofReal_coe_nnreal, â† ENNReal.ofReal_mul (NNReal.coe_nonneg _), â† div_div,
        mul_div_cancelâ‚€ _ (NNReal.coe_pos.2 hCpos).ne.symm]
    _ â‰¤ ENNReal.ofReal Îµ := by
      rw [â† ENNReal.ofReal_add (half_pos hÎµ).le (half_pos hÎµ).le, add_halves]","error:  function expected at
  inter_subset_right ?m.230357
term has type
  ?m.230356 âˆˆ ?m.230355","theorem unifIntegrable_of' (hp : 1 â‰¤ p) (hp' : p â‰  âˆ) {f : Î¹ â†’ Î± â†’ Î²}
    (hf : âˆ€ i, StronglyMeasurable (f i))
    (h : âˆ€ Îµ : â„, 0 < Îµ â†’ âˆƒ C : â„â‰¥0, 0 < C âˆ§
      âˆ€ i, snorm ({ x | C â‰¤ â€–f i xâ€–â‚Š }.indicator (f i)) p Î¼ â‰¤ ENNReal.ofReal Îµ) :
    UnifIntegrable f p Î¼ ",":= by
  have hpzero := (lt_of_lt_of_le zero_lt_one hp).ne.symm
  by_cases hÎ¼ : Î¼ Set.univ = 0
  Â· rw [Measure.measure_univ_eq_zero] at hÎ¼
    exact hÎ¼.symm â–¸ unifIntegrable_zero_meas
  intro Îµ hÎµ
  obtain âŸ¨C, hCpos, hCâŸ© := h (Îµ / 2) (half_pos hÎµ)
  refine âŸ¨(Îµ / (2 * C)) ^ ENNReal.toReal p,
    Real.rpow_pos_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos))) _,
    fun i s hs hÎ¼s => ?_âŸ©
  by_cases hÎ¼s' : Î¼ s = 0
  Â· rw [(snorm_eq_zero_iff ((hf i).indicator hs).aestronglyMeasurable hpzero).2
        (indicator_meas_zero hÎ¼s')]
    norm_num
  calc
    snorm (Set.indicator s (f i)) p Î¼ â‰¤
        snorm (Set.indicator (s âˆ© { x | C â‰¤ â€–f i xâ€–â‚Š }) (f i)) p Î¼ +
          snorm (Set.indicator (s âˆ© { x | â€–f i xâ€–â‚Š < C }) (f i)) p Î¼ := by
      refine le_trans (Eq.le ?_) (snorm_add_le
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter (stronglyMeasurable_const.measurableSet_le (hf i).nnnorm))))
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter ((hf i).nnnorm.measurableSet_lt stronglyMeasurable_const))))
        hp)
      congr
      change _ = fun x => (s âˆ© { x : Î± | C â‰¤ â€–f i xâ€–â‚Š }).indicator (f i) x +
        (s âˆ© { x : Î± | â€–f i xâ€–â‚Š < C }).indicator (f i) x
      rw [â† Set.indicator_union_of_disjoint]
      Â· rw [â† Set.inter_union_distrib_left, (by ext; simp [le_or_lt] :
            { x : Î± | C â‰¤ â€–f i xâ€–â‚Š } âˆª { x : Î± | â€–f i xâ€–â‚Š < C } = Set.univ),
          Set.inter_univ]
      Â· refine (Disjoint.inf_right' _ ?_).inf_left' _
        rw [disjoint_iff_inf_le]
        rintro x âŸ¨hxâ‚, hxâ‚‚âŸ©
        rw [Set.mem_setOf_eq] at hxâ‚ hxâ‚‚
        exact False.elim (hxâ‚‚.ne (eq_of_le_of_not_lt hxâ‚ (not_lt.2 hxâ‚‚.le)).symm)
    _ â‰¤ snorm (Set.indicator { x | C â‰¤ â€–f i xâ€–â‚Š } (f i)) p Î¼ +
        (C : â„â‰¥0âˆ) * Î¼ s ^ (1 / ENNReal.toReal p) := by
      refine add_le_add
        (snorm_mono fun x => norm_indicator_le_of_subset Set.inter_subset_right _ _) ?_
      rw [â† Set.indicator_indicator]
      rw [snorm_indicator_eq_snorm_restrict hs]
      have : âˆ€áµ x âˆ‚Î¼.restrict s, â€–{ x : Î± | â€–f i xâ€–â‚Š < C }.indicator (f i) xâ€– â‰¤ C := by
        filter_upwards
        simp_rw [norm_indicator_eq_indicator_norm]
        exact Set.indicator_le' (fun x (hx : _ < _) => hx.le) fun _ _ => NNReal.coe_nonneg _
      refine le_trans (snorm_le_of_ae_bound this) ?_
      rw [mul_comm, Measure.restrict_apply' hs, Set.univ_inter, ENNReal.ofReal_coe_nnreal, one_div]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + C * ENNReal.ofReal (Îµ / (2 * C)) := by
      refine add_le_add (hC i) (mul_le_mul_left' ?_ _)
      rwa [ENNReal.rpow_one_div_le_iff (ENNReal.toReal_pos hpzero hp'),
        ENNReal.ofReal_rpow_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos)))]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + ENNReal.ofReal (Îµ / 2) := by
      refine add_le_add_left ?_ _
      rw [â† ENNReal.ofReal_coe_nnreal, â† ENNReal.ofReal_mul (NNReal.coe_nonneg _), â† div_div,
        mul_div_cancelâ‚€ _ (NNReal.coe_pos.2 hCpos).ne.symm]
    _ â‰¤ ENNReal.ofReal Îµ := by
      rw [â† ENNReal.ofReal_add (half_pos hÎµ).le (half_pos hÎµ).le, add_halves]",refine UnifIntegrable.unifIntegrable_theorem_unifIntegrable_of' hp hp' hf hf hf hf hf
Mathlib/MeasureTheory/Function/Jacobian.lean,ApproximatesLinearOn.norm_fderiv_sub_le,_root_.ApproximatesLinearOn.norm_fderiv_sub_le,9e34a191034458a56331f976ff7400a26407c888,":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Î¼ s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.op_norm_le_bound _ Î´.2 fun z => ?_
  suffices H : âˆ€ Îµ, 0 < Îµ â†’ â€–(f' x - A) zâ€– â‰¤ (Î´ + Îµ) * (â€–zâ€– + Îµ) + â€–f' x - Aâ€– * Îµ
  Â· have :
      Tendsto (fun Îµ : â„ => ((Î´ : â„) + Îµ) * (â€–zâ€– + Îµ) + â€–f' x - Aâ€– * Îµ) (ğ“[>] 0)
        (ğ“ ((Î´ + 0) * (â€–zâ€– + 0) + â€–f' x - Aâ€– * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by continuity) 0) nhdsWithin_le_nhds
    simp only [add_zero, MulZeroClass.mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Îµ Îµpos
  have Bâ‚ : âˆ€á¶  r in ğ“[>] (0 : â„), (s âˆ© ({x} + r â€¢ closedBall z Îµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Î¼ s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Î¼ z Îµpos).ne'
  obtain âŸ¨Ï, Ïpos, hÏâŸ© :
    âˆƒ Ï > 0, ball x Ï âˆ© s âŠ† {y : E | â€–f y - f x - (f' x) (y - x)â€– â‰¤ Îµ * â€–y - xâ€–} :=
    mem_nhdsWithin_iff.1 (IsLittleO.def (hf' x xs) Îµpos)
  have Bâ‚‚ : âˆ€á¶  r in ğ“[>] (0 : â„), {x} + r â€¢ closedBall z Îµ âŠ† ball x Ï := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset bounded_closedBall (ball_mem_nhds x Ïpos)
  obtain âŸ¨r, âŸ¨y, âŸ¨ys, hyâŸ©âŸ©, rÏ, rposâŸ© :
    âˆƒ r : â„,
      (s âˆ© ({x} + r â€¢ closedBall z Îµ)).Nonempty âˆ§ {x} + r â€¢ closedBall z Îµ âŠ† ball x Ï âˆ§ 0 < r :=
    (Bâ‚.and (Bâ‚‚.and self_mem_nhdsWithin)).exists
  obtain âŸ¨a, az, yaâŸ© : âˆƒ a, a âˆˆ closedBall z Îµ âˆ§ y = x + r â€¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with âŸ¨a, az, haâŸ©
    exact âŸ¨a, az, by simp only [ha, add_neg_cancel_left]âŸ©
  have norm_a : â€–aâ€– â‰¤ â€–zâ€– + Îµ :=
    calc
      â€–aâ€– = â€–z + (a - z)â€– := by simp only [add_sub_cancel'_right]
      _ â‰¤ â€–zâ€– + â€–a - zâ€– := (norm_add_le _ _)
      _ â‰¤ â€–zâ€– + Îµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * â€–(f' x - A) aâ€– â‰¤ r * (Î´ + Îµ) * (â€–zâ€– + Îµ) :=
    calc
      r * â€–(f' x - A) aâ€– = â€–(f' x - A) (r â€¢ a)â€– := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = â€–f y - f x - A (y - x) - (f y - f x - (f' x) (y - x))â€– := by
        congr 1
        simp only [ya, add_sub_cancel', sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ â‰¤ â€–f y - f x - A (y - x)â€– + â€–f y - f x - (f' x) (y - x)â€– := (norm_sub_le _ _)
      _ â‰¤ Î´ * â€–y - xâ€– + Îµ * â€–y - xâ€– := (add_le_add (hf _ ys _ xs) (hÏ âŸ¨rÏ hy, ysâŸ©))
      _ = r * (Î´ + Îµ) * â€–aâ€– := by
        simp only [ya, add_sub_cancel', norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ â‰¤ r * (Î´ + Îµ) * (â€–zâ€– + Îµ) :=
        mul_le_mul_of_nonneg_left norm_a (mul_nonneg rpos.le (add_nonneg Î´.2 Îµpos.le))
  show â€–(f' x - A) zâ€– â‰¤ (Î´ + Îµ) * (â€–zâ€– + Îµ) + â€–f' x - Aâ€– * Îµ;
  exact
    calc
      â€–(f' x - A) zâ€– = â€–(f' x - A) a + (f' x - A) (z - a)â€– := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ â‰¤ â€–(f' x - A) aâ€– + â€–(f' x - A) (z - a)â€– := (norm_add_le _ _)
      _ â‰¤ (Î´ + Îµ) * (â€–zâ€– + Îµ) + â€–f' x - Aâ€– * â€–z - aâ€– := by
        apply add_le_add
        Â· rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
        Â· apply ContinuousLinearMap.le_op_norm
      _ â‰¤ (Î´ + Îµ) * (â€–zâ€– + Îµ) + â€–f' x - Aâ€– * Îµ :=
        add_le_add le_rfl
          (mul_le_mul_of_nonneg_left (mem_closedBall_iff_norm'.1 az) (norm_nonneg _))",error:  unexpected token 'Â·'; expected 'by' or 'from',"theorem _root_.ApproximatesLinearOn.norm_fderiv_sub_le {A : E â†’L[â„] E} {Î´ : â„â‰¥0}
    (hf : ApproximatesLinearOn f A s Î´) (hs : MeasurableSet s) (f' : E â†’ E â†’L[â„] E)
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) : âˆ€áµ x âˆ‚Î¼.restrict s, â€–f' x - Aâ€–â‚Š â‰¤ Î´ ",":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Î¼ s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ Î´.2 fun z => ?_
  suffices H : âˆ€ Îµ, 0 < Îµ â†’ â€–(f' x - A) zâ€– â‰¤ (Î´ + Îµ) * (â€–zâ€– + Îµ) + â€–f' x - Aâ€– * Îµ by
    have :
      Tendsto (fun Îµ : â„ => ((Î´ : â„) + Îµ) * (â€–zâ€– + Îµ) + â€–f' x - Aâ€– * Îµ) (ğ“[>] 0)
        (ğ“ ((Î´ + 0) * (â€–zâ€– + 0) + â€–f' x - Aâ€– * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by fun_prop) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Îµ Îµpos
  have Bâ‚ : âˆ€á¶  r in ğ“[>] (0 : â„), (s âˆ© ({x} + r â€¢ closedBall z Îµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Î¼ s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Î¼ z Îµpos).ne'
  obtain âŸ¨Ï, Ïpos, hÏâŸ© :
    âˆƒ Ï > 0, ball x Ï âˆ© s âŠ† {y : E | â€–f y - f x - (f' x) (y - x)â€– â‰¤ Îµ * â€–y - xâ€–} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Îµpos)
  have Bâ‚‚ : âˆ€á¶  r in ğ“[>] (0 : â„), {x} + r â€¢ closedBall z Îµ âŠ† ball x Ï := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x Ïpos)
  obtain âŸ¨r, âŸ¨y, âŸ¨ys, hyâŸ©âŸ©, rÏ, rposâŸ© :
    âˆƒ r : â„,
      (s âˆ© ({x} + r â€¢ closedBall z Îµ)).Nonempty âˆ§ {x} + r â€¢ closedBall z Îµ âŠ† ball x Ï âˆ§ 0 < r :=
    (Bâ‚.and (Bâ‚‚.and self_mem_nhdsWithin)).exists
  obtain âŸ¨a, az, yaâŸ© : âˆƒ a, a âˆˆ closedBall z Îµ âˆ§ y = x + r â€¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with âŸ¨a, az, haâŸ©
    exact âŸ¨a, az, by simp only [ha, add_neg_cancel_left]âŸ©
  have norm_a : â€–aâ€– â‰¤ â€–zâ€– + Îµ :=
    calc
      â€–aâ€– = â€–z + (a - z)â€– := by simp only [add_sub_cancel]
      _ â‰¤ â€–zâ€– + â€–a - zâ€– := norm_add_le _ _
      _ â‰¤ â€–zâ€– + Îµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * â€–(f' x - A) aâ€– â‰¤ r * (Î´ + Îµ) * (â€–zâ€– + Îµ) :=
    calc
      r * â€–(f' x - A) aâ€– = â€–(f' x - A) (r â€¢ a)â€– := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = â€–f y - f x - A (y - x) - (f y - f x - (f' x) (y - x))â€– := by
        congr 1
        simp only [ya, add_sub_cancel_left, sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ â‰¤ â€–f y - f x - A (y - x)â€– + â€–f y - f x - (f' x) (y - x)â€– := norm_sub_le _ _
      _ â‰¤ Î´ * â€–y - xâ€– + Îµ * â€–y - xâ€– := (add_le_add (hf _ ys _ xs) (hÏ âŸ¨rÏ hy, ysâŸ©))
      _ = r * (Î´ + Îµ) * â€–aâ€– := by
        simp only [ya, add_sub_cancel_left, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ â‰¤ r * (Î´ + Îµ) * (â€–zâ€– + Îµ) := by gcongr
  calc
    â€–(f' x - A) zâ€– = â€–(f' x - A) a + (f' x - A) (z - a)â€– := by
      congr 1
      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
      abel
    _ â‰¤ â€–(f' x - A) aâ€– + â€–(f' x - A) (z - a)â€– := norm_add_le _ _
    _ â‰¤ (Î´ + Îµ) * (â€–zâ€– + Îµ) + â€–f' x - Aâ€– * â€–z - aâ€– := by
      apply add_le_add
      Â· rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
      Â· apply ContinuousLinearMap.le_opNorm
    _ â‰¤ (Î´ + Îµ) * (â€–zâ€– + Îµ) + â€–f' x - Aâ€– * Îµ := by
      rw [mem_closedBall_iff_norm'] at az
      gcongr",approximatesLinearOn.norm_fderiv_sub_le
Mathlib/Data/PNat/Factors.lean,PrimeMultiset.prod_zero,prod_zero,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  dsimp [Prod]
  exact Multiset.prod_zero",error:  dsimp made no progress,theorem prod_zero : (0 : PrimeMultiset).prod = 1 ,":= by
  exact Multiset.prod_zero",simp [prod_zero]
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.addHaar_image_eq_zero_of_det_fderivWithin_eq_zero,addHaar_image_eq_zero_of_det_fderivWithin_eq_zero,49cb73bac1b838aa7ba8d29f180ec1242e6d7e71,":= by
  rcases eq_empty_or_nonempty s with (rfl | h's); Â· simp only [measure_empty, zero_le, image_empty]
  have :
      âˆ€ A : E â†’L[â„] E, âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§
        âˆ€ (t : Set E), ApproximatesLinearOn f A t Î´ â†’
          Î¼ (f '' t) â‰¤ (Real.toNNReal |A.det| + Îµ : â„â‰¥0) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, h'âŸ©
    exact âŸ¨Î´, h', fun t ht => h t f htâŸ©
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, Af'âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := (measure_iUnion_le _)
    _ â‰¤ âˆ‘' n, (Real.toNNReal |(A n).det| + Îµ : â„â‰¥0) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2
      exact ht n
    _ = âˆ‘' n, Îµ * Î¼ (s âˆ© t n) := by
      congr with n
      rcases Af' h's n with âŸ¨y, ys, hyâŸ©
      simp only [hy, h'f' y ys, Real.toNNReal_zero, abs_zero, zero_add]
    _ â‰¤ Îµ * âˆ‘' n, Î¼ (closedBall 0 R âˆ© t n) := by
      rw [ENNReal.tsum_mul_left]
      refine' mul_le_mul_left' (ENNReal.tsum_le_tsum fun n => measure_mono _) _
      exact inter_subset_inter_left _ hs
    _ = Îµ * Î¼ (â‹ƒ n, closedBall 0 R âˆ© t n) := by
      rw [measure_iUnion]
      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right _ _
      Â· intro n
        exact measurableSet_closedBall.inter (t_meas n)
    _ â‰¤ Îµ * Î¼ (closedBall 0 R) := by
      rw [â† inter_iUnion]
      exact mul_le_mul_left' (measure_mono (inter_subset_left _ _)) _","error:  function expected at
  inter_subset_right ?m.329486
term has type
  ?m.329485 âˆˆ ?m.329484
error:  function expected at
  inter_subset_left ?m.330114
term has type
  ?m.330113 âˆˆ ?m.330111","theorem addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (R : â„) (hs : s âŠ† closedBall 0 R) (Îµ : â„â‰¥0)
    (Îµpos : 0 < Îµ) (h'f' : âˆ€ x âˆˆ s, (f' x).det = 0) : Î¼ (f '' s) â‰¤ Îµ * Î¼ (closedBall 0 R) ",":= by
  rcases eq_empty_or_nonempty s with (rfl | h's); Â· simp only [measure_empty, zero_le, image_empty]
  have :
      âˆ€ A : E â†’L[â„] E, âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§
        âˆ€ (t : Set E), ApproximatesLinearOn f A t Î´ â†’
          Î¼ (f '' t) â‰¤ (Real.toNNReal |A.det| + Îµ : â„â‰¥0) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, h'âŸ©
    exact âŸ¨Î´, h', fun t ht => h t f htâŸ©
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, Af'âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      rw [â† image_iUnion, â† inter_iUnion]
      gcongr
      exact subset_inter Subset.rfl t_cover
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Real.toNNReal |(A n).det| + Îµ : â„â‰¥0) * Î¼ (s âˆ© t n) := by
      gcongr
      exact (hÎ´ (A _)).2 _ (ht _)
    _ = âˆ‘' n, Îµ * Î¼ (s âˆ© t n) := by
      congr with n
      rcases Af' h's n with âŸ¨y, ys, hyâŸ©
      simp only [hy, h'f' y ys, Real.toNNReal_zero, abs_zero, zero_add]
    _ â‰¤ Îµ * âˆ‘' n, Î¼ (closedBall 0 R âˆ© t n) := by
      rw [ENNReal.tsum_mul_left]
      gcongr
    _ = Îµ * Î¼ (â‹ƒ n, closedBall 0 R âˆ© t n) := by
      rw [measure_iUnion]
      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
      Â· intro n
        exact measurableSet_closedBall.inter (t_meas n)
    _ â‰¤ Îµ * Î¼ (closedBall 0 R) := by
      rw [â† inter_iUnion]
      exact mul_le_mul_left' (measure_mono inter_subset_left) _",have : Î¼ (closedBall 0 R) âŠ† closedBall 0 R := closedBall_subset_closedBall_subset
Mathlib/Combinatorics/SetFamily/HarrisKleitman.lean,IsUpperSet.le_card_inter_finset,IsUpperSet.le_card_inter_finset,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [â† isLowerSet_compl, â† coe_compl] at hğ’œ
  have := hğ’œ.card_inter_le_finset hâ„¬
  rwa [card_compl, Fintype.card_finset, tsub_mul, le_tsub_iff_le_tsub, â† mul_tsub, â†
    card_sdiff (inter_subset_right _ _), sdiff_inter_self_right, sdiff_compl,
    _root_.inf_comm] at this
  Â· exact mul_le_mul_left' (card_le_card <| inter_subset_right _ _) _
  Â· rw [â† Fintype.card_finset]
    exact mul_le_mul_right' (card_le_univ _) _","error:  function expected at
  inter_subset_right ?m.16474
term has type
  ?m.16473 âˆˆ ?m.16472
error:  function expected at
  inter_subset_right ?m.17374
term has type
  ?m.17373 âˆˆ ?m.17372","theorem IsUpperSet.le_card_inter_finset (hğ’œ : IsUpperSet (ğ’œ : Set (Finset Î±)))
    (hâ„¬ : IsUpperSet (â„¬ : Set (Finset Î±))) :
    ğ’œ.card * â„¬.card â‰¤ 2 ^ Fintype.card Î± * (ğ’œ âˆ© â„¬).card ",":= by
  rw [â† isLowerSet_compl, â† coe_compl] at hğ’œ
  have := hğ’œ.card_inter_le_finset hâ„¬
  rwa [card_compl, Fintype.card_finset, tsub_mul, le_tsub_iff_le_tsub, â† mul_tsub, â†
    card_sdiff inter_subset_right, sdiff_inter_self_right, sdiff_compl,
    _root_.inf_comm] at this
  Â· exact mul_le_mul_left' (card_le_card inter_subset_right) _
  Â· rw [â† Fintype.card_finset]
    exact mul_le_mul_right' (card_le_univ _) _","rw [â† card_inter_of_isUpperSet hğ’œ hâ„¬, card_inter_of_isUpperSet hğ’œ hâ„¬]"
Mathlib/Analysis/InnerProductSpace/Projection.lean,exists_norm_eq_iInf_of_complete_convex,exists_norm_eq_iInf_of_complete_convex,92beef58f265528359880ded59e9a73d818a6596,":= fun u => by
  let Î´ := â¨… w : K, â€–u - wâ€–
  letI : Nonempty K := ne.to_subtype
  have zero_le_Î´ : 0 â‰¤ Î´ := le_ciInf fun _ => norm_nonneg _
  have Î´_le : âˆ€ w : K, Î´ â‰¤ â€–u - wâ€– := ciInf_le âŸ¨0, Set.forall_range_iff.2 fun _ => norm_nonneg _âŸ©
  have Î´_le' : âˆ€ w âˆˆ K, Î´ â‰¤ â€–u - wâ€– := fun w hw => Î´_le âŸ¨w, hwâŸ©
  have exists_seq : âˆƒ w : â„• â†’ K, âˆ€ n, â€–u - w nâ€– < Î´ + 1 / (n + 1) := by
    have hÎ´ : âˆ€ n : â„•, Î´ < Î´ + 1 / (n + 1) := fun n =>
      lt_add_of_le_of_pos le_rfl Nat.one_div_pos_of_nat
    have h := fun n => exists_lt_of_ciInf_lt (hÎ´ n)
    let w : â„• â†’ K := fun n => Classical.choose (h n)
    exact âŸ¨w, fun n => Classical.choose_spec (h n)âŸ©
  rcases exists_seq with âŸ¨w, hwâŸ©
  have norm_tendsto : Tendsto (fun n => â€–u - w nâ€–) atTop (nhds Î´) := by
    have h : Tendsto (fun _ : â„• => Î´) atTop (nhds Î´) := tendsto_const_nhds
    have h' : Tendsto (fun n : â„• => Î´ + 1 / (n + 1)) atTop (nhds Î´) := by
      convert h.add tendsto_one_div_add_atTop_nhds_0_nat
      simp only [add_zero]
    exact tendsto_of_tendsto_of_tendsto_of_le_of_le h h' (fun x => Î´_le _) fun x => le_of_lt (hw _)
  have seq_is_cauchy : CauchySeq fun n => (w n : F) := by
    rw [cauchySeq_iff_le_tendsto_0]
    let b := fun n : â„• => 8 * Î´ * (1 / (n + 1)) + 4 * (1 / (n + 1)) * (1 / (n + 1))
    use fun n => sqrt (b n)
    constructor
    intro n
    exact sqrt_nonneg _
    constructor
    intro p q N hp hq
    let wp := (w p : F)
    let wq := (w q : F)
    let a := u - wq
    let b := u - wp
    let half := 1 / (2 : â„)
    let div := 1 / ((N : â„) + 1)
    have :
      4 * â€–u - half â€¢ (wq + wp)â€– * â€–u - half â€¢ (wq + wp)â€– + â€–wp - wqâ€– * â€–wp - wqâ€– =
        2 * (â€–aâ€– * â€–aâ€– + â€–bâ€– * â€–bâ€–) :=
      calc
        4 * â€–u - half â€¢ (wq + wp)â€– * â€–u - half â€¢ (wq + wp)â€– + â€–wp - wqâ€– * â€–wp - wqâ€– =
            2 * â€–u - half â€¢ (wq + wp)â€– * (2 * â€–u - half â€¢ (wq + wp)â€–) + â€–wp - wqâ€– * â€–wp - wqâ€– :=
          by ring
        _ =
            absR (2 : â„) * â€–u - half â€¢ (wq + wp)â€– * (absR (2 : â„) * â€–u - half â€¢ (wq + wp)â€–) +
              â€–wp - wqâ€– * â€–wp - wqâ€– := by
          rw [_root_.abs_of_nonneg]
          exact zero_le_two
        _ =
            â€–(2 : â„) â€¢ (u - half â€¢ (wq + wp))â€– * â€–(2 : â„) â€¢ (u - half â€¢ (wq + wp))â€– +
              â€–wp - wqâ€– * â€–wp - wqâ€– :=
          by simp [norm_smul]
        _ = â€–a + bâ€– * â€–a + bâ€– + â€–a - bâ€– * â€–a - bâ€– := by
          rw [smul_sub, smul_smul, mul_one_div_cancel (_root_.two_ne_zero : (2 : â„) â‰  0), â†
            one_add_one_eq_two, add_smul]
          simp only [one_smul]
          have eqâ‚ : wp - wq = a - b := (sub_sub_sub_cancel_left _ _ _).symm
          have eqâ‚‚ : u + u - (wq + wp) = a + b
          show u + u - (wq + wp) = u - wq + (u - wp)
          abel
          rw [eqâ‚, eqâ‚‚]
        _ = 2 * (â€–aâ€– * â€–aâ€– + â€–bâ€– * â€–bâ€–) := parallelogram_law_with_norm â„ _ _
    have eq : Î´ â‰¤ â€–u - half â€¢ (wq + wp)â€– := by
      rw [smul_add]
      apply Î´_le'
      apply hâ‚‚
      repeat' exact Subtype.mem _
      repeat' exact le_of_lt one_half_pos
      exact add_halves 1
    have eqâ‚ : 4 * Î´ * Î´ â‰¤ 4 * â€–u - half â€¢ (wq + wp)â€– * â€–u - half â€¢ (wq + wp)â€– := by
      simp_rw [mul_assoc]
      exact mul_le_mul_of_nonneg_left (mul_self_le_mul_self zero_le_Î´ eq) zero_le_four
    have eqâ‚‚ : â€–aâ€– * â€–aâ€– â‰¤ (Î´ + div) * (Î´ + div) :=
      mul_self_le_mul_self (norm_nonneg _)
        (le_trans (le_of_lt <| hw q) (add_le_add_left (Nat.one_div_le_one_div hq) _))
    have eqâ‚‚' : â€–bâ€– * â€–bâ€– â‰¤ (Î´ + div) * (Î´ + div) :=
      mul_self_le_mul_self (norm_nonneg _)
        (le_trans (le_of_lt <| hw p) (add_le_add_left (Nat.one_div_le_one_div hp) _))
    rw [dist_eq_norm]
    apply nonneg_le_nonneg_of_sq_le_sq
    Â· exact sqrt_nonneg _
    rw [mul_self_sqrt]
    calc
      â€–wp - wqâ€– * â€–wp - wqâ€– =
          2 * (â€–aâ€– * â€–aâ€– + â€–bâ€– * â€–bâ€–) - 4 * â€–u - half â€¢ (wq + wp)â€– * â€–u - half â€¢ (wq + wp)â€– := by
        rw [â† this]
        simp
      _ â‰¤ 2 * (â€–aâ€– * â€–aâ€– + â€–bâ€– * â€–bâ€–) - 4 * Î´ * Î´ := (sub_le_sub_left eqâ‚ _)
      _ â‰¤ 2 * ((Î´ + div) * (Î´ + div) + (Î´ + div) * (Î´ + div)) - 4 * Î´ * Î´ :=
        (sub_le_sub_right (mul_le_mul_of_nonneg_left (add_le_add eqâ‚‚ eqâ‚‚') (by norm_num)) _)
      _ = 8 * Î´ * div + 4 * div * div := by ring
    exact
      add_nonneg (mul_nonneg (mul_nonneg (by norm_num) zero_le_Î´) (le_of_lt Nat.one_div_pos_of_nat))
        (mul_nonneg (mul_nonneg (by norm_num) Nat.one_div_pos_of_nat.le) Nat.one_div_pos_of_nat.le)
    apply Tendsto.comp (f := b) (g := sqrt)
    Â· have : Tendsto sqrt (nhds 0) (nhds (sqrt 0)) := continuous_sqrt.continuousAt
      convert this
      exact sqrt_zero.symm
    have eqâ‚ : Tendsto (fun n : â„• => 8 * Î´ * (1 / (n + 1))) atTop (nhds (0 : â„)) := by
      convert(@tendsto_const_nhds _ _ _ (8 * Î´) _).mul tendsto_one_div_add_atTop_nhds_0_nat
      simp only [MulZeroClass.mul_zero]
    have : Tendsto (fun n : â„• => (4 : â„) * (1 / (n + 1))) atTop (nhds (0 : â„)) := by
      convert(@tendsto_const_nhds _ _ _ (4 : â„) _).mul tendsto_one_div_add_atTop_nhds_0_nat
      simp only [MulZeroClass.mul_zero]
    have eqâ‚‚ :
        Tendsto (fun n : â„• => (4 : â„) * (1 / (n + 1)) * (1 / (n + 1))) atTop (nhds (0 : â„)) := by
      convert this.mul tendsto_one_div_add_atTop_nhds_0_nat
      simp only [MulZeroClass.mul_zero]
    convert eqâ‚.add eqâ‚‚
    simp only [add_zero]
  rcases cauchySeq_tendsto_of_isComplete hâ‚ (fun n => Subtype.mem _) seq_is_cauchy with
    âŸ¨v, hv, w_tendstoâŸ©
  use v
  use hv
  have h_cont : Continuous fun v => â€–u - vâ€– :=
    Continuous.comp continuous_norm (Continuous.sub continuous_const continuous_id)
  have : Tendsto (fun n => â€–u - w nâ€–) atTop (nhds â€–u - vâ€–)
  convert Tendsto.comp h_cont.continuousAt w_tendsto
  exact tendsto_nhds_unique this norm_tendsto","error:  unexpected token 'show'; expected '|'
error:  unsolved goals
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâ´ : _root_.RCLike ğ•œ
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedAddCommGroup F
instâœÂ¹ : InnerProductSpace ğ•œ E
instâœ : InnerProductSpace â„ F
K : Set F
ne : K.Nonempty
hâ‚ : IsComplete K
hâ‚‚ : Convex â„ K
u : F
Î´ : â„ := â¨… w, â€–u - â†‘wâ€–
this : Nonempty â†‘K := Set.Nonempty.to_subtype ne
zero_le_Î´ : 0 â‰¤ Î´
Î´_le : âˆ€ (w : â†‘K), Î´ â‰¤ â€–u - â†‘wâ€–
Î´_le' : âˆ€ w âˆˆ K, Î´ â‰¤ â€–u - wâ€–
w : â„• â†’ â†‘K
hw : âˆ€ (n : â„•), â€–u - â†‘(w n)â€– < Î´ + 1 / (â†‘n + 1)
norm_tendsto : Tendsto (fun n â†¦ â€–u - â†‘(w n)â€–) atTop (ğ“ Î´)
bâœ : â„• â†’ â„ := fun n â†¦ 8 * Î´ * (1 / (â†‘n + 1)) + 4 * (1 / (â†‘n + 1)) * (1 / (â†‘n + 1))
p q N : â„•
hp : N â‰¤ p
hq : N â‰¤ q
wp : F := â†‘(w p)
wq : F := â†‘(w q)
a : F := u - wq
b : F := u - wp
half : â„ := 1 / 2
div : â„ := 1 / (â†‘N + 1)
eqâ‚ : wp - wq = a - b
eqâ‚‚ : u + u - (wq + wp) = a + b
âŠ¢ â€–u + u - (wq + wp)â€– * â€–u + u - (wq + wp)â€– + â€–wp - wqâ€– * â€–wp - wqâ€– = â€–a + bâ€– * â€–a + bâ€– + â€–a - bâ€– * â€–a - bâ€–
error:  unsolved goals
case h.right.left
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâ´ : _root_.RCLike ğ•œ
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedAddCommGroup F
instâœÂ¹ : InnerProductSpace ğ•œ E
instâœ : InnerProductSpace â„ F
K : Set F
ne : K.Nonempty
hâ‚ : IsComplete K
hâ‚‚ : Convex â„ K
u : F
Î´ : â„ := â¨… w, â€–u - â†‘wâ€–
thisâœ : Nonempty â†‘K := Set.Nonempty.to_subtype ne
zero_le_Î´ : 0 â‰¤ Î´
Î´_le : âˆ€ (w : â†‘K), Î´ â‰¤ â€–u - â†‘wâ€–
Î´_le' : âˆ€ w âˆˆ K, Î´ â‰¤ â€–u - wâ€–
w : â„• â†’ â†‘K
hw : âˆ€ (n : â„•), â€–u - â†‘(w n)â€– < Î´ + 1 / (â†‘n + 1)
norm_tendsto : Tendsto (fun n â†¦ â€–u - â†‘(w n)â€–) atTop (ğ“ Î´)
bâœ : â„• â†’ â„ := fun n â†¦ 8 * Î´ * (1 / (â†‘n + 1)) + 4 * (1 / (â†‘n + 1)) * (1 / (â†‘n + 1))
p q N : â„•
hp : N â‰¤ p
hq : N â‰¤ q
wp : F := â†‘(w p)
wq : F := â†‘(w q)
a : F := u - wq
b : F := u - wp
half : â„ := 1 / 2
div : â„ := 1 / (â†‘N + 1)
this : 4 * â€–u - half â€¢ (wq + wp)â€– * â€–u - half â€¢ (wq + wp)â€– + â€–wp - wqâ€– * â€–wp - wqâ€– = 2 * (â€–aâ€– * â€–aâ€– + â€–bâ€– * â€–bâ€–)
âŠ¢ dist â†‘(w p) â†‘(w q) â‰¤ âˆš(bâœ N)

case h.right.right
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâ´ : _root_.RCLike ğ•œ
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedAddCommGroup F
instâœÂ¹ : InnerProductSpace ğ•œ E
instâœ : InnerProductSpace â„ F
K : Set F
ne : K.Nonempty
hâ‚ : IsComplete K
hâ‚‚ : Convex â„ K
u : F
Î´ : â„ := â¨… w, â€–u - â†‘wâ€–
this : Nonempty â†‘K := Set.Nonempty.to_subtype ne
zero_le_Î´ : 0 â‰¤ Î´
Î´_le : âˆ€ (w : â†‘K), Î´ â‰¤ â€–u - â†‘wâ€–
Î´_le' : âˆ€ w âˆˆ K, Î´ â‰¤ â€–u - wâ€–
w : â„• â†’ â†‘K
hw : âˆ€ (n : â„•), â€–u - â†‘(w n)â€– < Î´ + 1 / (â†‘n + 1)
norm_tendsto : Tendsto (fun n â†¦ â€–u - â†‘(w n)â€–) atTop (ğ“ Î´)
b : â„• â†’ â„ := fun n â†¦ 8 * Î´ * (1 / (â†‘n + 1)) + 4 * (1 / (â†‘n + 1)) * (1 / (â†‘n + 1))
âŠ¢ Tendsto (fun n â†¦ âˆš(b n)) atTop (ğ“ 0)
error:  unsolved goals
case intro
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâ´ : _root_.RCLike ğ•œ
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedAddCommGroup F
instâœÂ¹ : InnerProductSpace ğ•œ E
instâœ : InnerProductSpace â„ F
K : Set F
ne : K.Nonempty
hâ‚ : IsComplete K
hâ‚‚ : Convex â„ K
u : F
Î´ : â„ := â¨… w, â€–u - â†‘wâ€–
this : Nonempty â†‘K := Set.Nonempty.to_subtype ne
zero_le_Î´ : 0 â‰¤ Î´
Î´_le : âˆ€ (w : â†‘K), Î´ â‰¤ â€–u - â†‘wâ€–
Î´_le' : âˆ€ w âˆˆ K, Î´ â‰¤ â€–u - wâ€–
w : â„• â†’ â†‘K
hw : âˆ€ (n : â„•), â€–u - â†‘(w n)â€– < Î´ + 1 / (â†‘n + 1)
norm_tendsto : Tendsto (fun n â†¦ â€–u - â†‘(w n)â€–) atTop (ğ“ Î´)
seq_is_cauchy : CauchySeq fun n â†¦ â†‘(w n)
âŠ¢ âˆƒ v âˆˆ K, â€–u - vâ€– = â¨… w, â€–u - â†‘wâ€–","theorem exists_norm_eq_iInf_of_complete_convex {K : Set F} (ne : K.Nonempty) (hâ‚ : IsComplete K)
    (hâ‚‚ : Convex â„ K) : âˆ€ u : F, âˆƒ v âˆˆ K, â€–u - vâ€– = â¨… w : K, â€–u - wâ€– ",":= fun u => by
  let Î´ := â¨… w : K, â€–u - wâ€–
  letI : Nonempty K := ne.to_subtype
  have zero_le_Î´ : 0 â‰¤ Î´ := le_ciInf fun _ => norm_nonneg _
  have Î´_le : âˆ€ w : K, Î´ â‰¤ â€–u - wâ€– := ciInf_le âŸ¨0, Set.forall_mem_range.2 fun _ => norm_nonneg _âŸ©
  have Î´_le' : âˆ€ w âˆˆ K, Î´ â‰¤ â€–u - wâ€– := fun w hw => Î´_le âŸ¨w, hwâŸ©
  have exists_seq : âˆƒ w : â„• â†’ K, âˆ€ n, â€–u - w nâ€– < Î´ + 1 / (n + 1) := by
    have hÎ´ : âˆ€ n : â„•, Î´ < Î´ + 1 / (n + 1) := fun n =>
      lt_add_of_le_of_pos le_rfl Nat.one_div_pos_of_nat
    have h := fun n => exists_lt_of_ciInf_lt (hÎ´ n)
    let w : â„• â†’ K := fun n => Classical.choose (h n)
    exact âŸ¨w, fun n => Classical.choose_spec (h n)âŸ©
  rcases exists_seq with âŸ¨w, hwâŸ©
  have norm_tendsto : Tendsto (fun n => â€–u - w nâ€–) atTop (ğ“ Î´) := by
    have h : Tendsto (fun _ : â„• => Î´) atTop (ğ“ Î´) := tendsto_const_nhds
    have h' : Tendsto (fun n : â„• => Î´ + 1 / (n + 1)) atTop (ğ“ Î´) := by
      convert h.add tendsto_one_div_add_atTop_nhds_zero_nat
      simp only [add_zero]
    exact tendsto_of_tendsto_of_tendsto_of_le_of_le h h' (fun x => Î´_le _) fun x => le_of_lt (hw _)
  have seq_is_cauchy : CauchySeq fun n => (w n : F) := by
    rw [cauchySeq_iff_le_tendsto_0]
    let b := fun n : â„• => 8 * Î´ * (1 / (n + 1)) + 4 * (1 / (n + 1)) * (1 / (n + 1))
    use fun n => âˆš(b n)
    constructor
    Â· intro n
      exact sqrt_nonneg _
    constructor
    Â· intro p q N hp hq
      let wp := (w p : F)
      let wq := (w q : F)
      let a := u - wq
      let b := u - wp
      let half := 1 / (2 : â„)
      let div := 1 / ((N : â„) + 1)
      have :
        4 * â€–u - half â€¢ (wq + wp)â€– * â€–u - half â€¢ (wq + wp)â€– + â€–wp - wqâ€– * â€–wp - wqâ€– =
          2 * (â€–aâ€– * â€–aâ€– + â€–bâ€– * â€–bâ€–) :=
        calc
          4 * â€–u - half â€¢ (wq + wp)â€– * â€–u - half â€¢ (wq + wp)â€– + â€–wp - wqâ€– * â€–wp - wqâ€– =
              2 * â€–u - half â€¢ (wq + wp)â€– * (2 * â€–u - half â€¢ (wq + wp)â€–) + â€–wp - wqâ€– * â€–wp - wqâ€– :=
            by ring
          _ =
              absR (2 : â„) * â€–u - half â€¢ (wq + wp)â€– * (absR (2 : â„) * â€–u - half â€¢ (wq + wp)â€–) +
                â€–wp - wqâ€– * â€–wp - wqâ€– := by
            rw [_root_.abs_of_nonneg]
            exact zero_le_two
          _ =
              â€–(2 : â„) â€¢ (u - half â€¢ (wq + wp))â€– * â€–(2 : â„) â€¢ (u - half â€¢ (wq + wp))â€– +
                â€–wp - wqâ€– * â€–wp - wqâ€– := by simp [norm_smul]
          _ = â€–a + bâ€– * â€–a + bâ€– + â€–a - bâ€– * â€–a - bâ€– := by
            rw [smul_sub, smul_smul, mul_one_div_cancel (_root_.two_ne_zero : (2 : â„) â‰  0), â†
              one_add_one_eq_two, add_smul]
            simp only [one_smul]
            have eqâ‚ : wp - wq = a - b := (sub_sub_sub_cancel_left _ _ _).symm
            have eqâ‚‚ : u + u - (wq + wp) = a + b := by
              show u + u - (wq + wp) = u - wq + (u - wp)
              abel
            rw [eqâ‚, eqâ‚‚]
          _ = 2 * (â€–aâ€– * â€–aâ€– + â€–bâ€– * â€–bâ€–) := parallelogram_law_with_norm â„ _ _
      have eq : Î´ â‰¤ â€–u - half â€¢ (wq + wp)â€– := by
        rw [smul_add]
        apply Î´_le'
        apply hâ‚‚
        repeat' exact Subtype.mem _
        repeat' exact le_of_lt one_half_pos
        exact add_halves 1
      have eqâ‚ : 4 * Î´ * Î´ â‰¤ 4 * â€–u - half â€¢ (wq + wp)â€– * â€–u - half â€¢ (wq + wp)â€– := by
        simp_rw [mul_assoc]
        gcongr
      have eqâ‚‚ : â€–aâ€– â‰¤ Î´ + div :=
          le_trans (le_of_lt <| hw q) (add_le_add_left (Nat.one_div_le_one_div hq) _)
      have eqâ‚‚' : â€–bâ€– â‰¤ Î´ + div :=
          le_trans (le_of_lt <| hw p) (add_le_add_left (Nat.one_div_le_one_div hp) _)
      rw [dist_eq_norm]
      apply nonneg_le_nonneg_of_sq_le_sq
      Â· exact sqrt_nonneg _
      rw [mul_self_sqrt]
      Â· calc
        â€–wp - wqâ€– * â€–wp - wqâ€– =
            2 * (â€–aâ€– * â€–aâ€– + â€–bâ€– * â€–bâ€–) - 4 * â€–u - half â€¢ (wq + wp)â€– * â€–u - half â€¢ (wq + wp)â€– := by
          simp [â† this]
        _ â‰¤ 2 * (â€–aâ€– * â€–aâ€– + â€–bâ€– * â€–bâ€–) - 4 * Î´ * Î´ := by gcongr
        _ â‰¤ 2 * ((Î´ + div) * (Î´ + div) + (Î´ + div) * (Î´ + div)) - 4 * Î´ * Î´ := by gcongr
        _ = 8 * Î´ * div + 4 * div * div := by ring
      positivity
    suffices Tendsto (fun x â†¦ âˆš(8 * Î´ * x + 4 * x * x) : â„ â†’ â„) (ğ“ 0) (ğ“ 0)
      from this.comp tendsto_one_div_add_atTop_nhds_zero_nat
    exact Continuous.tendsto' (by fun_prop) _ _ (by simp)
  rcases cauchySeq_tendsto_of_isComplete hâ‚ (fun n => Subtype.mem _) seq_is_cauchy with
    âŸ¨v, hv, w_tendstoâŸ©
  use v
  use hv
  have h_cont : Continuous fun v => â€–u - vâ€– :=
    Continuous.comp continuous_norm (Continuous.sub continuous_const continuous_id)
  have : Tendsto (fun n => â€–u - w nâ€–) atTop (ğ“ â€–u - vâ€–) := by
    convert Tendsto.comp h_cont.continuousAt w_tendsto
  exact tendsto_nhds_unique this norm_tendsto",refine theorem_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_iInf_of_exists_norm_eq_
Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean,contDiffGroupoid_zero_eq,contDiffGroupoid_zero_eq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  apply le_antisymm le_top
  intro u _
  change u âˆˆ contDiffGroupoid 0 I
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid, contDiffPregroupoid]
  simp only [contDiffOn_zero]
  constructor
  Â· refine' I.continuous.comp_continuousOn (u.continuousOn.comp I.continuousOn_symm _)
    exact (mapsTo_preimage _ _).mono_left (inter_subset_left _ _)
  Â· refine' I.continuous.comp_continuousOn (u.symm.continuousOn.comp I.continuousOn_symm _)
    exact (mapsTo_preimage _ _).mono_left (inter_subset_left _ _)","warning:  modelWithCornersSelf does not have a doc string
error:  function expected at
  inter_subset_left ?m.59314
term has type
  ?m.59313 âˆˆ ?m.59311
error:  function expected at
  inter_subset_left ?m.59645
term has type
  ?m.59644 âˆˆ ?m.59642",theorem contDiffGroupoid_zero_eq : contDiffGroupoid 0 I = continuousGroupoid H ,":= by
  apply le_antisymm le_top
  intro u _
  change u âˆˆ contDiffGroupoid 0 I
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid, contDiffPregroupoid]
  simp only [contDiffOn_zero]
  constructor
  Â· refine I.continuous.comp_continuousOn (u.continuousOn.comp I.continuousOn_symm ?_)
    exact (mapsTo_preimage _ _).mono_left inter_subset_left
  Â· refine I.continuous.comp_continuousOn (u.symm.continuousOn.comp I.continuousOn_symm ?_)
    exact (mapsTo_preimage _ _).mono_left inter_subset_left","rw [contDiffGroupoid, continuousGroupoid]"
Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean,AlgebraicTopology.AlternatingFaceMapComplex.d_squared,d_squared,6d1b77e97159c51b0084f053ab93299f39b3a009,":= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff, Fin.val_succ,
      Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa using hij
  Â· 
    rintro âŸ¨i, jâŸ© âŸ¨i', j'âŸ© hij hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine' âŸ¨(j'.pred _, Fin.castSucc i'), _, _âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_pred_of_lt hij'
    Â· simp only [Fin.castLT_castSucc, Fin.succ_pred]","error:  simp made no progress
error:  simp made no progress
error:  rcases tactic failed: aâœ : Quot.lift (fun l â†¦ (i, j) âˆˆ l) â‹¯ Sá¶œ.val is not an inductive datatype
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #3 provided
error:  no goals to be solved",theorem d_squared (n : â„•) : objD X (n + 1) â‰« objD X n = 0 ,":= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,
      Fin.val_succ, Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij âŸ¨i', j'âŸ© hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine âŸ¨(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'
    Â· simp only [Ï†, Fin.castLT_castSucc, Fin.succ_pred]
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa [S] using hij","simp only [objD, objDD, objDDD, d_squared, d_squared, d_squared, d_squared]"
Mathlib/NumberTheory/PellMatiyasevic.lean,Pell.eq_pow_of_pell,eq_pow_of_pell,d4ee09ebb44515260fada6fe81009f5ed4807a9d,":=
  have hya : y < a := (Nat.le_self_pow hk0 _).trans_lt hyk
  calc
    (â†‘(y ^ k) : â„¤) < a := Nat.cast_lt.2 hyk
    _ â‰¤ (a : â„¤) ^ 2 - (a - 1 : â„¤) ^ 2 - 1 := by
      rw [sub_sq, mul_one, one_pow, sub_add, sub_sub_cancel, two_mul, sub_sub, â† add_sub,
        le_add_iff_nonneg_right, sub_nonneg, Int.add_one_le_iff]
      norm_cast
      exact lt_of_le_of_lt (Nat.succ_le_of_lt (Nat.pos_of_ne_zero hy0)) hya
    _ â‰¤ (a : â„¤) ^ 2 - (a - y : â„¤) ^ 2 - 1 := by
      have := hya.le
      mono * <;> norm_cast <;> simp [Nat.zero_le, Nat.succ_le_of_lt (Nat.pos_of_ne_zero hy0)]
    _ = 2 * a * y - y * y - 1 := by ring","error:  unknown tactic
error:  unsolved goals
a y k : â„•
hy0 : y â‰  0
hk0 : k â‰  0
hyk : y ^ k < a
hya : y < a
this : y â‰¤ a
âŠ¢ â†‘a ^ 2 - (â†‘a - 1) ^ 2 - 1 â‰¤ â†‘a ^ 2 - (â†‘a - â†‘y) ^ 2 - 1","theorem eq_pow_of_pell_lem {a y k : â„•} (hy0 : y â‰  0) (hk0 : k â‰  0) (hyk : y ^ k < a) :
    (â†‘(y ^ k) : â„¤) < 2 * a * y - y * y - 1 ",":=
  have hya : y < a := (Nat.le_self_pow hk0 _).trans_lt hyk
  calc
    (â†‘(y ^ k) : â„¤) < a := Nat.cast_lt.2 hyk
    _ â‰¤ (a : â„¤) ^ 2 - (a - 1 : â„¤) ^ 2 - 1 := by
      rw [sub_sq, mul_one, one_pow, sub_add, sub_sub_cancel, two_mul, sub_sub, â† add_sub,
        le_add_iff_nonneg_right, sub_nonneg, Int.add_one_le_iff]
      norm_cast
      exact lt_of_le_of_lt (Nat.succ_le_of_lt (Nat.pos_of_ne_zero hy0)) hya
    _ â‰¤ (a : â„¤) ^ 2 - (a - y : â„¤) ^ 2 - 1 := by
      have := hya.le
      gcongr <;> norm_cast <;> omega
    _ = 2 * a * y - y * y - 1 := by ring",rw [theorem_eq_pow_of_pell_lem] at hyk
Mathlib/LinearAlgebra/Matrix/Transvection.lean,Matrix.Pivot.listTransvecCol_mul_last_row_drop,listTransvecCol_mul_last_row_drop,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine Nat.decreasingInduction' ?_ hk? _
  Â· intro n hn _ IH
    have hn' : n < (listTransvecCol M).length := by simpa [listTransvecCol] using hn
    rw [List.drop_eq_get_cons hn']
    simpa [listTransvecCol, Matrix.mul_assoc]
  Â· simp only [listTransvecCol, List.length_ofFn, le_refl, List.drop_eq_nil_of_le, List.prod_nil,
      Matrix.one_mul]","error:  unknown identifier 'hk?'
error:  unsolved goals
n : Type u_1
p : Type u_2
R : Type uâ‚‚
ğ•œ : Type u_3
instâœÂ³ : Field ğ•œ
instâœÂ² : DecidableEq n
instâœÂ¹ : DecidableEq p
instâœ : CommRing R
r : â„•
M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ğ•œ
i : Fin r âŠ• Unit
k : â„•
hk : k â‰¤ r
âŠ¢ ((List.drop k (listTransvecCol M)).prod * M) (inr ()) i = M (inr ()) i","theorem listTransvecCol_mul_last_row_drop (i : Sum (Fin r) Unit) {k : â„•} (hk : k â‰¤ r) :
    (((listTransvecCol M).drop k).prod * M) (inr unit) i = M (inr unit) i ",":= by
  refine Nat.decreasingInduction' ?_ hk ?_
  Â· intro n hn _ IH
    have hn' : n < (listTransvecCol M).length := by simpa [listTransvecCol] using hn
    rw [List.drop_eq_getElem_cons hn']
    simpa [listTransvecCol, Matrix.mul_assoc]
  Â· simp only [listTransvecCol, List.length_ofFn, le_refl, List.drop_eq_nil_of_le, List.prod_nil,
      Matrix.one_mul]","simp [listTransvecCol_mul_last_row_drop, listTransvecCol_mul_last_row_drop]"
Mathlib/Data/Fintype/Option.lean,Fintype.induction_empty_option,induction_empty_option,f805dd1a8f5243708d8b831bb207e63649ac1331,":= by
  obtain âŸ¨pâŸ© :=
    let f_empty := (fun i => by convert h_empty; simp)
    let h_option : âˆ€ {Î± : Type u} [Fintype Î±] [DecidableEq Î±],
          (âˆ€ (h : Fintype Î±), P Î±) â†’ âˆ€ (h : Fintype (Option Î±)), P (Option Î±)  := by
      rintro Î± hÎ± - PÎ± hÎ±'
      convert h_option Î± (PÎ± _)
      simp
    @truncRecEmptyOption (fun Î± => âˆ€ h, @P Î± h) (@fun Î± Î² e hÎ± hÎ² => @of_equiv Î± Î² hÎ² e (hÎ± _))
      f_empty h_option Î± _ (Classical.decEq Î±)
  Â· exact p _","error:  no goals to be solved
error:  no goals to be solved","theorem induction_empty_option {P : âˆ€ (Î± : Type u) [Fintype Î±], Prop}
    (of_equiv : âˆ€ (Î± Î²) [Fintype Î²] (e : Î± â‰ƒ Î²), @P Î± (@Fintype.ofEquiv Î± Î² â€¹_â€º e.symm) â†’ @P Î² â€¹_â€º)
    (h_empty : P PEmpty) (h_option : âˆ€ (Î±) [Fintype Î±], P Î± â†’ P (Option Î±)) (Î± : Type u)
    [h_fintype : Fintype Î±] : P Î± ",":= by
  obtain âŸ¨pâŸ© :=
    let f_empty := fun i => by convert h_empty
    let h_option : âˆ€ {Î± : Type u} [Fintype Î±] [DecidableEq Î±],
          (âˆ€ (h : Fintype Î±), P Î±) â†’ âˆ€ (h : Fintype (Option Î±)), P (Option Î±)  := by
      rintro Î± hÎ± - PÎ± hÎ±'
      convert h_option Î± (PÎ± _)
    @truncRecEmptyOption (fun Î± => âˆ€ h, @P Î± h) (@fun Î± Î² e hÎ± hÎ² => @of_equiv Î± Î² hÎ² e (hÎ± _))
      f_empty h_option Î± _ (Classical.decEq Î±)
  exact p _","simp only [Fintype.ofEquiv_symm_apply, induction_empty_option]"
Mathlib/Geometry/Manifold/Instances/Sphere.lean,mfderiv_coe_sphere_injective,mfderiv_coe_sphere_injective,42efba3d0573971469083f4c678037805b06c5df,":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ğ•œ := â„) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices Injective (fderiv â„ ((stereoInvFunAux (-v : E) âˆ˜ (â†‘)) âˆ˜ U.symm) 0) by
    convert this using 3 
    apply stereographic'_neg
  have : HasFDerivAt (stereoInvFunAux (-v : E) âˆ˜ (Subtype.val : (â„ âˆ™ (â†‘(-v) : E))á—® â†’ E))
      (â„ âˆ™ (â†‘(-v) : E))á—®.subtypeL (U.symm 0) := by
    simp only [coe_neg_sphere, map_zero]
    apply hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa only [coe_neg_sphere, Submodule.coe_subtypeL', Submodule.coeSubtype,
    LinearIsometryEquiv.coe_toContinuousLinearEquiv, EquivLike.injective_comp] using
    Subtype.coe_injective",error:  unknown identifier 'stereographic'_neg',"theorem mfderiv_coe_sphere_injective {n : â„•} [Fact (finrank â„ E = n + 1)] (v : sphere (0 : E) 1) :
    Injective (mfderiv (ğ“¡ n) ğ“˜(â„, E) ((â†‘) : sphere (0 : E) 1 â†’ E) v) ",":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ğ•œ := â„) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices Injective (fderiv â„ ((stereoInvFunAux (-v : E) âˆ˜ (â†‘)) âˆ˜ U.symm) 0) by
    convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddEquivClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have : HasFDerivAt (stereoInvFunAux (-v : E) âˆ˜ (Subtype.val : (â„ âˆ™ (â†‘(-v) : E))á—® â†’ E))
      (â„ âˆ™ (â†‘(-v) : E))á—®.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective",rw [mfderiv_coe_sphere_injective]
Mathlib/Algebra/FreeAlgebra.lean,FreeAlgebra.induction,induction,acf51aa5213fe1533e7b3b5b6ec403b3b329cede,":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X â†’ s := Subtype.coind (Î¹ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [Subtype.coind]
  suffices : a = lift R of a
  Â· rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a","error:  unexpected token ':'; expected term
error:  unsolved goals
case w.h
R : Type u_1
instâœ : CommSemiring R
X : Type u_2
C : FreeAlgebra R X â†’ Prop
h_grade0 : âˆ€ (r : R), C ((algebraMap R (FreeAlgebra R X)) r)
h_grade1 : âˆ€ (x : X), C (Î¹ R x)
h_mul : âˆ€ (a b : FreeAlgebra R X), C a â†’ C b â†’ C (a * b)
h_add : âˆ€ (a b : FreeAlgebra R X), C a â†’ C b â†’ C (a + b)
a : FreeAlgebra R X
s : Subalgebra R (FreeAlgebra R X) :=
  { carrier := C, mul_mem' := â‹¯, one_mem' := â‹¯, add_mem' := â‹¯, zero_mem' := â‹¯, algebraMap_mem' := h_grade0 }
of : X â†’ â†¥s := Subtype.coind (Î¹ R) h_grade1
xâœ : X
âŠ¢ Î¹ R xâœ = â†‘(of xâœ)","theorem induction {C : FreeAlgebra R X â†’ Prop}
    (h_grade0 : âˆ€ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : âˆ€ x, C (Î¹ R x))
    (h_mul : âˆ€ a b, C a â†’ C b â†’ C (a * b)) (h_add : âˆ€ a b, C a â†’ C b â†’ C (a + b))
    (a : FreeAlgebra R X) : C a ",":= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X â†’ s := Subtype.coind (Î¹ R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [of, Subtype.coind]
  suffices a = lift R of a by
    rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a",exact theorem_induction induction induction induction induction
Mathlib/Topology/Separation.lean,t2_iff_nhds,t2_iff_nhds,98740267311a24ae6a2fe792964006babfd6788e,":= by
  simp only [t2Space_iff_disjoint_nhds, disjoint_iff, neBot_iff, Ne.def, not_imp_comm, Pairwise]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.125860 â†’ ?m.125860 â†’ Prop","theorem t2_iff_nhds : T2Space X â†” âˆ€ {x y : X}, NeBot (ğ“ x âŠ“ ğ“ y) â†’ x = y ",":= by
  simp only [t2Space_iff_disjoint_nhds, disjoint_iff, neBot_iff, Ne, not_imp_comm, Pairwise]",constructor
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine Or.inl âŸ¨hs, ?_âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine' mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, _âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine'
        mem_shadow_iff.2
          âŸ¨(t âŠ” u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, _, _âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine âŸ¨hus, hsv.symm, âŸ¨x, ?_, ?_âŸ©, ?_ âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right _ _, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) _
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  function expected at
  subset_union_right ?m.92173
term has type
  ?m.92172 âˆˆ ?m.92170 âˆª ?m.92171
error:  function expected at
  subset_union_left ?m.92639
term has type
  ?m.92638 âˆˆ ?m.92636 âˆª ?m.92637
error:  function expected at
  subset_union_right ?m.94506
term has type
  ?m.94505 âˆˆ ?m.94503 âˆª ?m.94504
error:  function expected at
  subset_union_left ?m.97300
term has type
  ?m.97299 âˆˆ ?m.97297 âˆª ?m.97298
error:  ambiguous, possible interpretations 
  _root_.not_imp : Â¬(?m.97719 â†’ ?m.97720) â†” ?m.97719 âˆ§ Â¬?m.97720
  
  Classical.not_imp : Â¬(?m.97721 â†’ ?m.97722) â†” ?m.97721 âˆ§ Â¬?m.97722
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.97724
case neg
Î± : Type u_1
instâœ : DecidableEq Î±
ğ’œ : Finset (Finset Î±)
uâœ vâœ a : Finset Î±
r : â„•
u v : Finset Î±
huv : âˆ€ x âˆˆ u, âˆƒ y âˆˆ v, IsCompressed (u.erase x) (v.erase y) ğ’œ
ğ’œ' : Finset (Finset Î±) := ğ“’ u v ğ’œ
s : Finset Î±
hsğ’œ' : s âˆˆ âˆ‚ ğ’œ'
hsğ’œ : s âˆ‰ âˆ‚ ğ’œ
m : âˆ€ y âˆ‰ s, insert y s âˆ‰ ğ’œ
x : Î±
leftâœ : x âˆ‰ s
rightâœ : insert x s âˆˆ ğ’œ'
husâœ : u âŠ† insert x s
hvs : Disjoint v (insert x s)
thisâœÂ² : (insert x s âˆª v) \ u âˆˆ ğ’œ
hsv : Disjoint s v
hvu : Disjoint v u
hxv : x âˆ‰ v
thisâœÂ¹ : v \ u = v
thisâœ : x âˆ‰ u
hus : u âŠ† s
w : Î±
hwB : Â¬(w âˆˆ s âˆª v âˆ§ w âˆ‰ u)
hwğ’œ' : insert w ((s âˆª v) \ u) âˆˆ ğ’œ'
this : v âŠ† insert w ((s âˆª v) \ u)
hwu : w âˆ‰ u
âŠ¢ False","theorem shadow_compression_subset_compression_shadow (u v : Finset Î±)
    (huv : âˆ€ x âˆˆ u, âˆƒ y âˆˆ v, IsCompressed (u.erase x) (v.erase y) ğ’œ) :
    âˆ‚ (ğ“’ u v ğ’œ) âŠ† ğ“’ u v (âˆ‚ ğ’œ) ",":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine Or.inl âŸ¨hs, ?_âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, ?_âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine mem_shadow_iff.2
        âŸ¨(t âŠ” u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine âŸ¨hus, hsv.symm, âŸ¨x, ?_, ?_âŸ©, ?_âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) ?_
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]",refine theorem_shadow_compression_subset_compression_subset_compression_subset_compression_subset_compression_shadow huv
Mathlib/CategoryTheory/Sites/Plus.lean,CategoryTheory.GrothendieckTopology.plusMap_toPlus,plusMap_toPlus,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  ext X : 2
  refine colimit.hom_ext (fun S => ?_)
  dsimp only [plusMap, toPlus]
  let e : S.unop âŸ¶ âŠ¤ := homOfLE (OrderTop.le_top _)
  rw [Î¹_colimMap, â† colimit.w _ e.op, â† Category.assoc, â† Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun I => ?_)
  erw [Multiequalizer.lift_Î¹]
  simp only [unop_op, op_unop, diagram_map, Category.assoc, limit.lift_Ï€,
    Multifork.ofÎ¹_Ï€_app]
  let ee : (J.pullback (I.map e).f).obj S.unop âŸ¶ âŠ¤ := homOfLE (OrderTop.le_top _)
  erw [â† colimit.w _ ee.op, Î¹_colimMap_assoc, colimit.Î¹_pre, diagramPullback_app,
    â† Category.assoc, â† Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun II => ?_)
  convert (Multiequalizer.condition (S.unop.index P)
      âŸ¨_, _, _, II.f, ğŸ™ _, I.f, II.f â‰« I.f, I.hf,
        Sieve.downward_closed _ I.hf _, by simpâŸ©) using 1
  Â· dsimp [diagram]
    cases I
    simp only [Category.assoc, limit.lift_Ï€, Multifork.ofÎ¹_pt, Multifork.ofÎ¹_Ï€_app,
      Cover.Arrow.map_Y, Cover.Arrow.map_f]
    rfl
  Â· erw [Multiequalizer.lift_Î¹]
    dsimp [Cover.index]
    simp only [Functor.map_id, Category.comp_id]
    rfl","error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #5 provided
error:  application type mismatch
  @Cover.Arrow.Relation.mk C instâœÂ³ X.unop J S.unop I ?m.125321 II.Y II.f (ğŸ™ II.Y)
argument
  ğŸ™ II.Y
has type
  II.Y âŸ¶ II.Y : Type v
but is expected to have type
  II.Y âŸ¶ ?m.125321.Y : Type v",theorem plusMap_toPlus : J.plusMap (J.toPlus P) = J.toPlus (J.plusObj P) ,":= by
  ext X : 2
  refine colimit.hom_ext (fun S => ?_)
  dsimp only [plusMap, toPlus]
  let e : S.unop âŸ¶ âŠ¤ := homOfLE (OrderTop.le_top _)
  rw [Î¹_colimMap, â† colimit.w _ e.op, â† Category.assoc, â† Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun I => ?_)
  erw [Multiequalizer.lift_Î¹]
  simp only [unop_op, op_unop, diagram_map, Category.assoc, limit.lift_Ï€,
    Multifork.ofÎ¹_Ï€_app]
  let ee : (J.pullback (I.map e).f).obj S.unop âŸ¶ âŠ¤ := homOfLE (OrderTop.le_top _)
  erw [â† colimit.w _ ee.op, Î¹_colimMap_assoc, colimit.Î¹_pre, diagramPullback_app,
    â† Category.assoc, â† Category.assoc]
  congr 1
  refine Multiequalizer.hom_ext _ _ _ (fun II => ?_)
  convert Multiequalizer.condition (S.unop.index P)
    (Cover.Relation.mk I II.base { gâ‚ := II.f, gâ‚‚ := ğŸ™ _ }) using 1
  all_goals dsimp; simp","simp [J.toPlusMap_eq, plusMap_toPlus]"
Mathlib/MeasureTheory/Function/ContinuousMapDense.lean,MeasureTheory.Memâ„’p.exists_hasCompactSupport_snorm_sub_le,Memâ„’p.exists_hasCompactSupport_snorm_sub_le,2a6557e2b74660500c0cb5c37da161c4edbec35f,":= by
  suffices H :
    âˆƒ g : Î± â†’ E, snorm (f - g) p Î¼ â‰¤ Îµ âˆ§ Continuous g âˆ§ Memâ„’p g p Î¼ âˆ§ HasCompactSupport g
  Â· rcases H with âŸ¨g, hg, g_cont, g_mem, g_supportâŸ©
    exact âŸ¨g, g_support, hg, g_cont, g_memâŸ©
  apply hf.induction_dense hp _ _ _ _ hÎµ
  rotate_left
  Â· rintro f g âŸ¨f_cont, f_mem, hfâŸ© âŸ¨g_cont, g_mem, hgâŸ©
    exact âŸ¨f_cont.add g_cont, f_mem.add g_mem, hf.add hgâŸ©
  Â· rintro f âŸ¨_f_cont, f_mem, _hfâŸ©
    exact f_mem.aestronglyMeasurable
  intro c t ht htÎ¼ Îµ hÎµ
  rcases exists_Lp_half E Î¼ p hÎµ with âŸ¨Î´, Î´pos, hÎ´âŸ©
  obtain âŸ¨Î·, Î·pos, hÎ·âŸ© :
    âˆƒ Î· : â„â‰¥0, 0 < Î· âˆ§ âˆ€ s : Set Î±, Î¼ s â‰¤ Î· â†’ snorm (s.indicator fun _x => c) p Î¼ â‰¤ Î´
  exact exists_snorm_indicator_le hp c Î´pos.ne'
  have hÎ·_pos' : (0 : â„â‰¥0âˆ) < Î· := ENNReal.coe_pos.2 Î·pos
  obtain âŸ¨s, st, s_compact, Î¼sâŸ© : âˆƒ s, s âŠ† t âˆ§ IsCompact s âˆ§ Î¼ (t \ s) < Î·
  exact ht.exists_isCompact_diff_lt htÎ¼.ne hÎ·_pos'.ne'
  have hsÎ¼ : Î¼ s < âˆ := (measure_mono st).trans_lt htÎ¼
  have I1 : snorm ((s.indicator fun _y => c) - t.indicator fun _y => c) p Î¼ â‰¤ Î´ := by
    rw [â† snorm_neg, neg_sub, â† indicator_diff st]
    exact hÎ· _ Î¼s.le
  obtain âŸ¨k, k_compact, skâŸ© : âˆƒ k : Set Î±, IsCompact k âˆ§ s âŠ† interior k :=
    exists_compact_superset s_compact
  rcases exists_continuous_snorm_sub_le_of_closed hp s_compact.isClosed isOpen_interior sk hsÎ¼.ne c
      Î´pos.ne' with
    âŸ¨f, f_cont, I2, _f_bound, f_support, f_memâŸ©
  have I3 : snorm (f - t.indicator fun _y => c) p Î¼ â‰¤ Îµ := by
    convert
      (hÎ´ _ _
          (f_mem.aestronglyMeasurable.sub
            (aestronglyMeasurable_const.indicator s_compact.measurableSet))
          ((aestronglyMeasurable_const.indicator s_compact.measurableSet).sub
            (aestronglyMeasurable_const.indicator ht))
          I2 I1).le using 2
    simp only [sub_add_sub_cancel]
  refine' âŸ¨f, I3, f_cont, f_mem, HasCompactSupport.intro k_compact fun x hx => _âŸ©
  rw [â† Function.nmem_support]
  contrapose! hx
  exact interior_subset (f_support hx)",error:  unexpected token 'Â·'; expected 'by' or 'from',"theorem Memâ„’p.exists_hasCompactSupport_snorm_sub_le [WeaklyLocallyCompactSpace Î±] [Î¼.Regular]
    (hp : p â‰  âˆ) {f : Î± â†’ E} (hf : Memâ„’p f p Î¼) {Îµ : â„â‰¥0âˆ} (hÎµ : Îµ â‰  0) :
    âˆƒ g : Î± â†’ E, HasCompactSupport g âˆ§ snorm (f - g) p Î¼ â‰¤ Îµ âˆ§ Continuous g âˆ§ Memâ„’p g p Î¼ ",":= by
  suffices H :
      âˆƒ g : Î± â†’ E, snorm (f - g) p Î¼ â‰¤ Îµ âˆ§ Continuous g âˆ§ Memâ„’p g p Î¼ âˆ§ HasCompactSupport g by
    rcases H with âŸ¨g, hg, g_cont, g_mem, g_supportâŸ©
    exact âŸ¨g, g_support, hg, g_cont, g_memâŸ©
  apply hf.induction_dense hp _ _ _ _ hÎµ
  rotate_left
  Â· rintro f g âŸ¨f_cont, f_mem, hfâŸ© âŸ¨g_cont, g_mem, hgâŸ©
    exact âŸ¨f_cont.add g_cont, f_mem.add g_mem, hf.add hgâŸ©
  Â· rintro f âŸ¨_f_cont, f_mem, _hfâŸ©
    exact f_mem.aestronglyMeasurable
  intro c t ht htÎ¼ Îµ hÎµ
  rcases exists_Lp_half E Î¼ p hÎµ with âŸ¨Î´, Î´pos, hÎ´âŸ©
  obtain âŸ¨Î·, Î·pos, hÎ·âŸ© :
      âˆƒ Î· : â„â‰¥0, 0 < Î· âˆ§ âˆ€ s : Set Î±, Î¼ s â‰¤ Î· â†’ snorm (s.indicator fun _x => c) p Î¼ â‰¤ Î´ :=
    exists_snorm_indicator_le hp c Î´pos.ne'
  have hÎ·_pos' : (0 : â„â‰¥0âˆ) < Î· := ENNReal.coe_pos.2 Î·pos
  obtain âŸ¨s, st, s_compact, Î¼sâŸ© : âˆƒ s, s âŠ† t âˆ§ IsCompact s âˆ§ Î¼ (t \ s) < Î· :=
    ht.exists_isCompact_diff_lt htÎ¼.ne hÎ·_pos'.ne'
  have hsÎ¼ : Î¼ s < âˆ := (measure_mono st).trans_lt htÎ¼
  have I1 : snorm ((s.indicator fun _y => c) - t.indicator fun _y => c) p Î¼ â‰¤ Î´ := by
    rw [â† snorm_neg, neg_sub, â† indicator_diff st]
    exact hÎ· _ Î¼s.le
  obtain âŸ¨k, k_compact, skâŸ© : âˆƒ k : Set Î±, IsCompact k âˆ§ s âŠ† interior k :=
    exists_compact_superset s_compact
  rcases exists_continuous_snorm_sub_le_of_closed hp s_compact.isClosed isOpen_interior sk hsÎ¼.ne c
      Î´pos.ne' with
    âŸ¨f, f_cont, I2, _f_bound, f_support, f_memâŸ©
  have I3 : snorm (f - t.indicator fun _y => c) p Î¼ â‰¤ Îµ := by
    convert
      (hÎ´ _ _
          (f_mem.aestronglyMeasurable.sub
            (aestronglyMeasurable_const.indicator s_compact.measurableSet))
          ((aestronglyMeasurable_const.indicator s_compact.measurableSet).sub
            (aestronglyMeasurable_const.indicator ht))
          I2 I1).le using 2
    simp only [sub_add_sub_cancel]
  refine âŸ¨f, I3, f_cont, f_mem, HasCompactSupport.intro k_compact fun x hx => ?_âŸ©
  rw [â† Function.nmem_support]
  contrapose! hx
  exact interior_subset (f_support hx)","rcases exists_hasCompactSupport_snorm_sub_le Memâ„’p.exists_hasCompactSupport_snorm_sub_le
  with âŸ¨g, g_cont, g_cont, g_cont, g_cont, g_contâŸ©"
Mathlib/AlgebraicGeometry/Gluing.lean,AlgebraicGeometry.Scheme.GlueData.Î¹_eq_iff,Î¹_eq_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine Iff.trans ?_
    (TopCat.GlueData.Î¹_eq_iff_rel
      D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toTopGlueData
      i j x y)
  rw [â† ((TopCat.mono_iff_injective D.isoCarrier.inv).mp _).eq_iff]
  Â· simp_rw [â† comp_apply, â† D.Î¹_isoCarrier_inv]; rfl
  Â· infer_instance",error:  simp made no progress,"theorem Î¹_eq_iff (i j : D.J) (x : (D.U i).carrier) (y : (D.U j).carrier) :
    (ğ–£.Î¹ i).1.base x = (ğ–£.Î¹ j).1.base y â†” D.Rel âŸ¨i, xâŸ© âŸ¨j, yâŸ© ",":= by
  refine Iff.trans ?_
    (TopCat.GlueData.Î¹_eq_iff_rel
      D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toTopGlueData
      i j x y)
  rw [â† ((TopCat.mono_iff_injective D.isoCarrier.inv).mp _).eq_iff]
  Â· erw [â† comp_apply] 
    simp_rw [â† D.Î¹_isoCarrier_inv]
    rfl 
  Â· infer_instance",constructor
Mathlib/Computability/TMToPartrec.lean,Turing.PartrecToTM2.codeSupp_self,codeSupp_self,67ee3b7709353762fdc01cfb00722ee8c27ff6a5,":=
  Finset.Subset.trans (codeSupp'_self _ _) (Finset.subset_union_left _ _)","error:  function expected at
  Finset.subset_union_left ?m.333641
term has type
  ?m.333640 âˆˆ ?m.333638 âˆª ?m.333639",theorem codeSupp_self (c k) : trStmtsâ‚ (trNormal c k) âŠ† codeSupp c k ,":=
  Finset.Subset.trans (codeSupp'_self _ _) (Finset.union_subset_left fun _ a â†¦ a)","rw [codeSupp_self, codeSupp_self]"
Mathlib/Data/List/NodupEquivFin.lean,List.sublist_iff_exists_fin_orderEmbedding_get_eq,sublist_iff_exists_fin_orderEmbedding_get_eq,2b42dc7c3f9ebf6e7f17bff850d9c0bc3f1cf75e,":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  Â· rintro âŸ¨f, hfâŸ©
    have h : âˆ€ {i : â„•} (_ : i < l.length), f i < l'.length :=
      by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain âŸ¨h, -âŸ© := hf
      exact h
    refine' âŸ¨OrderEmbedding.ofMapLEIff (fun ix => âŸ¨f ix, h ix.is_ltâŸ©) _, _âŸ©
    Â· simp
    Â· intro i
      apply Option.some_injective
      simpa [get?_eq_get i.2, get?_eq_get (h i.2)] using hf i
  Â· rintro âŸ¨f, hfâŸ©
    refine'
      âŸ¨OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f âŸ¨i, hiâŸ© else i + l'.length)
          _,
        _âŸ©
    Â· intro i j h
      dsimp only
      split_ifs with hi hj hj
      Â· rwa [Fin.val_fin_lt, f.lt_iff_lt]
      Â· rw [add_comm]
        exact lt_add_of_lt_of_pos (Fin.is_lt _) (i.zero_le.trans_lt h)
      Â· exact absurd (h.trans hj) hi
      Â· simpa using h
    Â· intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      Â· rw [get?_eq_get hi, get?_eq_get, â† hf]
      Â· rw [get?_eq_none.mpr, get?_eq_none.mpr]
        Â· simp
        Â· simpa using hi","error:  type mismatch
  hâœ
has type
  some l[â†‘i] = l'[f â†‘i]? : Prop
but is expected to have type
  l[â†‘i] = l'[f â†‘i] : Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + ?b
case neg
Î± : Type u_1
l l' : List Î±
f : Fin l.length â†ªo Fin l'.length
hf : âˆ€ (ix : Fin l.length), l.get ix = l'.get (f ix)
i j : â„•
h : i < j
hi : i < l.length
hj : Â¬j < l.length
âŠ¢ â†‘(f âŸ¨i, hiâŸ©) < j + l'.length
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem sublist_iff_exists_fin_orderEmbedding_get_eq {l l' : List Î±} :
    l <+ l' â†”
      âˆƒ f : Fin l.length â†ªo Fin l'.length,
        âˆ€ ix : Fin l.length, l.get ix = l'.get (f ix) ",":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  Â· rintro âŸ¨f, hfâŸ©
    have h : âˆ€ {i : â„•}, i < l.length â†’ f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain âŸ¨h, -âŸ© := hf
      exact h
    refine âŸ¨OrderEmbedding.ofMapLEIff (fun ix => âŸ¨f ix, h ix.is_ltâŸ©) ?_, ?_âŸ©
    Â· simp
    Â· intro i
      apply Option.some_injective
      simpa [getElem?_eq_getElem i.2, getElem?_eq_getElem (h i.2)] using hf i
  Â· rintro âŸ¨f, hfâŸ©
    refine
      âŸ¨OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f âŸ¨i, hiâŸ© else i + l'.length)
          ?_,
        ?_âŸ©
    Â· intro i j h
      dsimp only
      split_ifs with hi hj hj
      Â· rwa [Fin.val_fin_lt, f.lt_iff_lt]
      Â· have := (f âŸ¨i, hiâŸ©).is_lt
        omega
      Â· exact absurd (h.trans hj) hi
      Â· simpa using h
    Â· intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      Â· rw [get?_eq_get hi, get?_eq_get, â† hf]
      Â· rw [get?_eq_none.mpr, get?_eq_none.mpr]
        Â· simp
        Â· simpa using hi",simp only [Fin.exists_fin_orderEmbedding_get_eq]
Mathlib/MeasureTheory/Group/FundamentalDomain.lean,MeasureTheory.IsFundamentalDomain.quotientMeasureEqMeasurePreimage_of_zero,IsFundamentalDomain.quotientMeasureEqMeasurePreimage_of_zero,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  apply fund_dom_s.quotientMeasureEqMeasurePreimage
  ext U meas_U
  simp only [zero_toOuterMeasure, OuterMeasure.coe_zero, Pi.zero_apply]
  convert (measure_inter_null_of_null_right (h := vol_s) (Quotient.mk Î±_mod_G â»Â¹' U)).symm
  rw [measure_map_restrict_apply (meas_U := meas_U)]",error:  simp made no progress,"theorem IsFundamentalDomain.quotientMeasureEqMeasurePreimage_of_zero
    {s : Set Î±} (fund_dom_s : IsFundamentalDomain G s Î½)
    (vol_s : Î½ s = 0) :
    QuotientMeasureEqMeasurePreimage Î½ (0 : Measure (Quotient Î±_mod_G)) ",":= by
  apply fund_dom_s.quotientMeasureEqMeasurePreimage
  ext U meas_U
  simp only [Measure.coe_zero, Pi.zero_apply]
  convert (measure_inter_null_of_null_right (h := vol_s) (Quotient.mk Î±_mod_G â»Â¹' U)).symm
  rw [measure_map_restrict_apply (meas_U := meas_U)]",rw [fund_dom_s.quotientMeasureEqMeasurePreimage_of_quotientMeasureEqMeasurePreimage]
