STARTING: verification of proofs from predicted_proof column in dataset from models/deepseek_base_no_err/base/by_file/test_by_file_base_prediction.csv - 2024-09-07 12:14:20.041456
STARTING: Lean repo copy creation
DONE: Lean repo copy creation
STARTING: retrieve cache
installing leantar 0.1.13
Attempting to download 4738 file(s)
Decompressing 4738 file(s)
Unpacked in 108376 ms
Completed successfully!
DONE: retrieved cache
Working on Mathlib/Algebra/BigOperators/Finprod.lean - 2024-09-07 12:33:19.235489.
---1/100---
For theorem finprod_mem_finset_product in Mathlib/Algebra/BigOperators/Finprod.lean:
theorem finprod_mem_finset_product' [DecidableEq α] [DecidableEq β] (s : Finset (α × β))
    (f : α × β → M) :
    (∏ᶠ (ab) (_ : ab ∈ s), f ab) =
      ∏ᶠ (a) (b) (_ : b ∈ (s.filter fun ab => Prod.fst ab = a).image Prod.snd), f (a, b) 


Original valid proof:
:= by
  have (a) :
      ∏ i ∈ (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i) =
        (s.filter (Prod.fst · = a)).prod f := by
    refine Finset.prod_nbij' (fun b ↦ (a, b)) Prod.snd ?_ ?_ ?_ ?_ ?_ <;> aesop
  rw [finprod_mem_finset_eq_prod]
  simp_rw [finprod_mem_finset_eq_prod, this]
  rw [finprod_eq_prod_of_mulSupport_subset _
      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),
    ← Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]
  simp only [Finset.mem_image]
  exact fun x hx => ⟨x, hx, rfl⟩


Verifying proof (Commit 20100f1475ea197bf6dea643b6ee137219455a51):
 := by
  have :
    ∀ a,
      (∏ i : β in (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i)) =
        (Finset.filter (fun ab => Prod.fst ab = a) s).prod f := by
    refine' fun a => Finset.prod_bij (fun b _ => (a, b)) _ _ _ _ <;> simp
    suffices ∀ a' b, (a', b) ∈ s → a' = a → (a, b) ∈ s ∧ a' = a by simpa
    rintro a' b hp rfl
    exact ⟨hp, rfl⟩
  rw [finprod_mem_finset_eq_prod]
  simp_rw [finprod_mem_finset_eq_prod, this]
  rw [finprod_eq_prod_of_mulSupport_subset _
      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),
    ← Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]
  simp only [Finset.mem_image, Prod.mk.eta]
  exact fun x hx => ⟨x, hx, rfl⟩

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:03):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I think it's a bug, and I'm not sure how to fix it.

####  Eric Wieser (Oct 03 2020 at 10:04):

I'm not sure

Attempt failure.

---2/100---
For theorem finprod_mem_finset_product in Mathlib/Algebra/BigOperators/Finprod.lean:
theorem finprod_mem_finset_product' [DecidableEq α] [DecidableEq β] (s : Finset (α × β))
    (f : α × β → M) :
    (∏ᶠ (ab) (_ : ab ∈ s), f ab) =
      ∏ᶠ (a) (b) (_ : b ∈ (s.filter fun ab => Prod.fst ab = a).image Prod.snd), f (a, b) 


Original valid proof:
:= by
  have (a) :
      ∏ i ∈ (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i) =
        (s.filter (Prod.fst · = a)).prod f := by
    refine Finset.prod_nbij' (fun b ↦ (a, b)) Prod.snd ?_ ?_ ?_ ?_ ?_ <;> aesop
  rw [finprod_mem_finset_eq_prod]
  simp_rw [finprod_mem_finset_eq_prod, this]
  rw [finprod_eq_prod_of_mulSupport_subset _
      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),
    ← Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]
  simp only [Finset.mem_image]
  exact fun x hx => ⟨x, hx, rfl⟩


Verifying proof (Commit 8bcfd78dbb0250a0a2e98eb49afa253d8fdf6aeb):
 := by
  have :
    ∀ a,
      (∏ i : β in (s.filter fun ab => Prod.fst ab = a).image Prod.snd, f (a, i)) =
        (Finset.filter (fun ab => Prod.fst ab = a) s).prod f := by
    refine' fun a => Finset.prod_bij (fun b _ => (a, b)) _ _ _ _ <;>
      try simp; done
    suffices ∀ a' b, (a', b) ∈ s → a' = a → (a, b) ∈ s ∧ a' = a by simpa
    rintro a' b hp rfl
    exact ⟨hp, rfl⟩
  rw [finprod_mem_finset_eq_prod]
  simp_rw [finprod_mem_finset_eq_prod, this]
  rw [finprod_eq_prod_of_mulSupport_subset _
      (s.mulSupport_of_fiberwise_prod_subset_image f Prod.fst),
    ← Finset.prod_fiberwise_of_maps_to (t := Finset.image Prod.fst s) _ f]
  simp only [Finset.mem_image, Prod.mk.eta]
  exact fun x hx => ⟨x, hx, rfl⟩

I think the problem is that the firstsimp_rw is not a simp lemma, and the second simp_rw is not a simp lemma.

####  Eric Wieser (Jun 01 2020 at 12:50):

I'm not sure what the best way to fix this is, but I'm not sure I want to have to add a simp lemma for everysimp_rw.

####  Eric Wieser (Jun 01 2020 at 12:51):

I'm not sure what the best way to fix this is, but I'm not sure I want to have to add a simp lemma for every
simp_rw.
I'm not sure I want to have to add a simp lemma for everysimp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.

####  Eric Wieser (Jun 01 2020 at 12:52):

I'm not sure I want to have to add a simp lemma for every
simp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.
I'm not sure I want to have to add a simp lemma for everysimp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.

####  Eric Wieser (Jun 01 2020 at 12:52):

I'm not sure I want to have to add a simp lemma for every
simp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.
I'm not sure I want to have to add a simp lemma for everysimp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.

####  Eric Wieser (Jun 01 2020 at 12:52):

I'm not sure I want to have to add a simp lemma for every
simp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.
I'm not sure I want to have to add a simp lemma for everysimp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.

####  Eric Wieser (Jun 01 2020 at 12:52):

I'm not sure I want to have to add a simp lemma for every
simp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.
I'm not sure I want to have to add a simp lemma for everysimp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.

####  Eric Wieser (Jun 01 2020 at 12:52):

I'm not sure I want to have to add a simp lemma for every
simp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.
I'm not sure I want to have to add a simp lemma for everysimp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.

####  Eric Wieser (Jun 01 2020 at 12:52):

I'm not sure I want to have to add a simp lemma for every
simp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.
I'm not sure I want to have to add a simp lemma for everysimp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.

####  Eric Wieser (Jun 01 2020 at 12:52):

I'm not sure I want to have to add a simp lemma for every
simp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.
I'm not sure I want to have to add a simp lemma for everysimp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.

####  Eric Wieser (Jun 01 2020 at 12:52):

I'm not sure I want to have to add a simp lemma for every
simp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.
I'm not sure I want to have to add a simp lemma for everysimp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.

####  Eric Wieser (Jun 01 2020 at 12:52):

I'm not sure I want to have to add a simp lemma for every
simp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.
I'm not sure I want to have to add a simp lemma for everysimp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.

####  Eric Wieser (Jun 01 2020 at 12:52):

I'm not sure I want to have to add a simp lemma for every
simp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.
I'm not sure I want to have to add a simp lemma for everysimp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.

####  Eric Wieser (Jun 01 2020 at 12:52):

I'm not sure I want to have to add a simp lemma for every
simp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.
I'm not sure I want to have to add a simp lemma for everysimp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.

####  Eric Wieser (Jun 01 2020 at 12:52):

I'm not sure I want to have to add a simp lemma for every
simp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.
I'm not sure I want to have to add a simp lemma for everysimp_rw either, but I'm not sure I want to have to add a simp lemma for every simp_rw either.

####  Eric Wieser (Jun 01 2020 at 12

Attempt failure.

Working on Mathlib/Algebra/Category/ModuleCat/Free.lean - 2024-09-07 12:34:22.586102.
---3/100---
For theorem ModuleCat.linearIndependent_leftExact in Mathlib/Algebra/Category/ModuleCat/Free.lean:
theorem linearIndependent_leftExact : LinearIndependent R u 


Original valid proof:
:= by
  rw [linearIndependent_sum]
  refine ⟨?_, LinearIndependent.of_comp S.g hw, disjoint_span_sum hS hw huv⟩
  rw [huv, LinearMap.linearIndependent_iff S.f]; swap
  · rw [LinearMap.ker_eq_bot, ← mono_iff_injective]
    infer_instance
  exact hv


Verifying proof (Commit 06295115e02029d99354c51425dc11539f40347b):
↔ LinearIndependent R v :=
  linearIndependent_sum.mpr
  ⟨(congr_arg (fun f ↦ LinearIndependent R f) huv).mpr
    ((LinearMap.linearIndependent_iff (f : N →ₗ[R] M)
    (LinearMap.ker_eq_bot.mpr ((mono_iff_injective _).mp hm))).mpr hv),
    LinearIndependent.of_comp g hw, disjoint_span_sum hw he huv⟩

#align linear_independent_left_exact linearIndependent_leftExact

####  Eric Wieser (May 01 2020 at 10:00):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:00):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to take a PR that fixes it.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the best way to fix this is,

Attempt failure.

Working on Mathlib/Algebra/FreeAlgebra.lean - 2024-09-07 12:36:29.735428.
---4/100---
For theorem FreeAlgebra.induction in Mathlib/Algebra/FreeAlgebra.lean:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a 


Original valid proof:
:= by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X → s := Subtype.coind (ι R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [of, Subtype.coind]
  suffices a = lift R of a by
    rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a


Verifying proof (Commit acf51aa5213fe1533e7b3b5b6ec403b3b329cede):
 := by
  let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' := h_grade0 }
  let of : X → s := Subtype.coind (ι R) h_grade1
  have of_id : AlgHom.id R (FreeAlgebra R X) = s.val.comp (lift R of) := by
    ext
    simp [Subtype.coind]
  suffices : a = lift R of a
  · rw [this]
    exact Subtype.prop (lift R of a)
  simp [AlgHom.ext_iff] at of_id
  exact of_id a

####  Eric Wieser (May 01 2020 at 14:00):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:01):

I'm not sure what the problem is, but I'm not sure I'd want to be using the
simp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I'm not sure what the problem is, but I'm not sure I'd want to be using thesimp [AlgHom.ext_iff] at of_id tactic anyway.

####  Eric Wieser (May 01 2020 at 14:02):

I

Attempt failure.

Working on Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean - 2024-09-07 12:36:45.462041.
---5/100---
For theorem CochainComplex.HomComplex.δ_shape in Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean:
lemma δ_shape (hnm : ¬ n + 1 = m) (z : Cochain F G n) : δ n m z = 0 


Original valid proof:
:= by
  ext p q hpq
  dsimp only [δ]
  rw [Cochain.mk_v, Cochain.zero_v, F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  all_goals
    simp only [ComplexShape.up_Rel]
    exact fun _ => hnm (by omega)


Verifying proof (Commit 2c367bb7cdc3187abec81c2896087d55449d9b24):
 := by
  ext ⟨p, q, hpq⟩
  dsimp [δ, Cochain.v, Cochain.mk]
  rw [F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  . rfl
  all_goals
    change ¬ _=_
    rintro h
    apply hnm
    linarith

## 1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.

Attempt failure.

Working on Mathlib/Algebra/Homology/QuasiIso.lean - 2024-09-07 12:37:19.279865.
---6/100---
For theorem quasiIsoAt_iff in Mathlib/Algebra/Homology/QuasiIso.lean:
lemma quasiIsoAt_iff (f : K ⟶ L) (i : ι) [K.HasHomology i] [L.HasHomology i] :
    QuasiIsoAt f i ↔
      ShortComplex.QuasiIso ((shortComplexFunctor C c i).map f) 


Original valid proof:
:= by
  constructor
  · intro h
    exact h.quasiIso
  · intro h
    exact ⟨h⟩


Verifying proof (Commit 4773ba7abb162ea632c1ff5810cd5f45a1289422):
∧
        (shortComplexFunctor C c i).map f ≫ (shortComplexFunctor C c i).map (K.homologyFunctor i) =
          (shortComplexFunctor C c i).map (L.homologyFunctor i) ≫ (shortComplexFunctor C c i).map f := by

## References #

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category = { hom := fun i j f => CategoryTheory.HomologicalAlgebra.QuasiIsoAt.Hom f, id := fun i => CategoryTheory.HomologicalAlgebra.QuasiIsoAt.id i, comp := fun i j k f g => CategoryTheory.HomologicalAlgebra.QuasiIsoAt.comp f g, id_comp' := CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category._proof_3, comp_id' := CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category._proof_4, assoc' := CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category._proof_5 }

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (CategoryTheory.HomologicalAlgebra.QuasiIsoAt.category)

## Equations

- CategoryTheory.HomologicalAlgebra.QuasiIsoAt.instConcreteCategoryQuasiIsoAt = CategoryTheory.ConcreteCategory.unop (Category

Attempt failure.

Working on Mathlib/Algebra/Homology/TotalComplex.lean - 2024-09-07 12:37:37.805670.
---7/100---
For theorem HomologicalComplex₂.D₁_D₁ in Mathlib/Algebra/Homology/TotalComplex.lean:
lemma D₁_D₁ (i₁₂ i₁₂' i₁₂'' : I₁₂) : K.D₁ c₁₂ i₁₂ i₁₂' ≫ K.D₁ c₁₂ i₁₂' i₁₂'' = 0 


Original valid proof:
:= by
  by_cases h₁ : c₁₂.Rel i₁₂ i₁₂'
  · by_cases h₂ : c₁₂.Rel i₁₂' i₁₂''
    · ext ⟨i₁, i₂⟩ h
      simp only [totalAux.ιMapObj_D₁_assoc, comp_zero]
      by_cases h₃ : c₁.Rel i₁ (c₁.next i₁)
      · rw [totalAux.d₁_eq K c₁₂ h₃ i₂ i₁₂']; swap
        · rw [← ComplexShape.next_π₁ c₂ c₁₂ h₃ i₂, ← c₁₂.next_eq' h₁, h]
        simp only [Linear.units_smul_comp, assoc, totalAux.ιMapObj_D₁]
        by_cases h₄ : c₁.Rel (c₁.next i₁) (c₁.next (c₁.next i₁))
        · rw [totalAux.d₁_eq K c₁₂ h₄ i₂ i₁₂'', Linear.comp_units_smul,
            d_f_comp_d_f_assoc, zero_comp, smul_zero, smul_zero]
          rw [← ComplexShape.next_π₁ c₂ c₁₂ h₄, ← ComplexShape.next_π₁ c₂ c₁₂ h₃,
            h, c₁₂.next_eq' h₁, c₁₂.next_eq' h₂]
        · rw [K.d₁_eq_zero _ _ _ _ h₄, comp_zero, smul_zero]
      · rw [K.d₁_eq_zero c₁₂ _ _ _ h₃, zero_comp]
    · rw [K.D₁_shape c₁₂ _ _ h₂, comp_zero]
  · rw [K.D₁_shape c₁₂ _ _ h₁, zero_comp]


Verifying proof (Commit 10f63baf7e1660a2ffa3e891eef40812f434a38f):
 := by
  by_cases h₁ : c₁₂.Rel i₁₂ i₁₂'
  · by_cases h₂ : c₁₂.Rel i₁₂' i₁₂''
    · ext ⟨i₁, i₂⟩ h
      simp only [ι_D₁_assoc, comp_zero]
      by_cases h₃ : c₁.Rel i₁ (c₁.next i₁)
      · rw [K.d₁_eq c₁₂ h₃ i₂ i₁₂']; swap
        · rw [← ComplexShape.next_π₁ c₂ c₁₂ h₃ i₂, ← c₁₂.next_eq' h₁, h]
        simp only [Linear.units_smul_comp, assoc, ι_D₁]
        by_cases h₄ : c₁.Rel (c₁.next i₁) (c₁.next (c₁.next i₁))
        · rw [K.d₁_eq c₁₂ h₄ i₂ i₁₂'', Linear.comp_units_smul,
            d_f_comp_d_f_assoc, zero_comp, smul_zero, smul_zero]
          rw [← ComplexShape.next_π₁ c₂ c₁₂ h₄, ← ComplexShape.next_π₁ c₂ c₁₂ h₃,
            h, c₁₂.next_eq' h₁, c₁₂.next_eq' h₂]
        · rw [K.d₁_eq_zero _ _ _ _ h₄, comp_zero, smul_zero]
      · rw [K.d₁_eq_zero c₁₂ _ _ _ h₃, zero_comp]
    · rw [K.D₁_shape c₁₂ _ _ h₂, comp_zero]
  · rw [K.D₁_shape c₁₂ _ _ h₁, zero_comp]

#### Johan Commelin (Jun 02 2020 at 10:04):

@Mario Carneiro I think you're right.

#### Johan Commelin (Jun 02 2020 at 10:04):

I'm not sure what the best way to fix this is.

#### Johan Commelin (Jun 02 2020 at 10:05):

I guess we should just add a bunch of lemmas about the shape ofD₁.

#### Johan Commelin (Jun 02 2020 at 10:05):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's a good idea.

#### Johan Commelin (Jun 02 2020 at 10:06):

I'm not sure if that's

Attempt failure.

Working on Mathlib/Algebra/Lie/Engel.lean - 2024-09-07 12:37:52.344046.
---8/100---
For theorem Function.Surjective.isEngelian in Mathlib/Algebra/Lie/Engel.lean:
theorem Function.Surjective.isEngelian {f : L →ₗ⁅R⁆ L₂} (hf : Function.Surjective f)
    (h : LieAlgebra.IsEngelian.{u₁, u₂, u₄} R L) : LieAlgebra.IsEngelian.{u₁, u₃, u₄} R L₂ 


Original valid proof:
:= by
  intro M _i1 _i2 _i3 _i4 h'
  letI : LieRingModule L M := LieRingModule.compLieHom M f
  letI : LieModule R L M := compLieHom M f
  have hnp : ∀ x, IsNilpotent (toEnd R L M x) := fun x => h' (f x)
  have surj_id : Function.Surjective (LinearMap.id : M →ₗ[R] M) := Function.surjective_id
  haveI : LieModule.IsNilpotent R L M := h M hnp
  apply hf.lieModuleIsNilpotent surj_id
  intros; simp only [LinearMap.id_coe, id_eq]; rfl


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  intro M _i1 _i2 _i3 _i4 h'
  letI : LieRingModule L M := LieRingModule.compLieHom M f
  letI : LieModule R L M := compLieHom M f
  have hnp : ∀ x, IsNilpotent (toEndomorphism R L M x) := fun x => h' (f x)
  have surj_id : Function.Surjective (LinearMap.id : M →ₗ[R] M) := Function.surjective_id
  haveI : LieModule.IsNilpotent R L M := h M hnp
  apply hf.lieModuleIsNilpotent surj_id
  intros; simp only [LinearMap.id_coe, id_eq]; rfl














































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































Attempt failure.

Working on Mathlib/Algebra/Lie/Sl2.lean - 2024-09-07 12:38:49.096397.
---9/100---
For theorem IsSl2Triple.HasPrimitiveVectorWith.lie_e_pow_succ_toEnd_f in Mathlib/Algebra/Lie/Sl2.lean:
lemma lie_e_pow_succ_toEnd_f (n : ℕ) :
    ⁅e, ψ (n + 1)⁆ = ((n + 1) * (μ - n)) • ψ n 


Original valid proof:
:= by
  induction' n with n ih
  · simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, sub_zero, one_mul,
      pow_zero, LinearMap.one_apply, leibniz_lie e, t.lie_e_f, P.lie_e, P.lie_h, lie_zero,
      add_zero]
  · rw [pow_succ', LinearMap.mul_apply, toEnd_apply_apply, leibniz_lie e, t.lie_e_f,
      lie_h_pow_toEnd_f P, ih, lie_smul, lie_f_pow_toEnd_f P, ← add_smul,
      Nat.cast_add, Nat.cast_one]
    congr
    ring


Verifying proof (Commit a85667469c48905c0ce3d6913968a001d5d43a18):
 := by
  induction' n with n ih
  · simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, sub_zero, one_mul,
      pow_zero, LinearMap.one_apply, leibniz_lie e, t.lie_e_f, P.lie_e, P.lie_h, lie_zero,
      add_zero]
  · rw [pow_succ', LinearMap.mul_apply, toEnd_apply_apply, leibniz_lie e, t.lie_e_f,
      lie_h_pow_toEnd_f P, ih, lie_smul, lie_f_pow_toEnd_f, ← add_smul,
      Nat.cast_add, Nat.cast_one]
    congr
    ring

####  Eric Wieser (May 10 2020 at 10:00):

I'm not sure what the problem is, but I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (May 10 2020 at 1

Attempt failure.

Working on Mathlib/Algebra/Polynomial/Roots.lean - 2024-09-07 12:39:04.089931.
---10/100---
For theorem Polynomial.Monic.irreducible_iff_degree_lt in Mathlib/Algebra/Polynomial/Roots.lean:
theorem Monic.irreducible_iff_degree_lt {p : R[X]} (p_monic : Monic p) (p_1 : p ≠ 1) :
    Irreducible p ↔ ∀ q, degree q ≤ ↑(p.natDegree / 2) → q ∣ p → IsUnit q 


Original valid proof:
:= by
  simp only [p_monic.irreducible_iff_lt_natDegree_lt p_1, Finset.mem_Ioc, and_imp,
    natDegree_pos_iff_degree_pos, natDegree_le_iff_degree_le]
  constructor
  · rintro h q deg_le dvd
    by_contra q_unit
    have := degree_pos_of_not_isUnit_of_dvd_monic p_monic q_unit dvd
    have hu := p_monic.isUnit_leadingCoeff_of_dvd dvd
    refine (h _ (monic_of_isUnit_leadingCoeff_inv_smul hu) ?_ ?_ (dvd_trans ?_ dvd)).elim
    · rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    · rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    · rw [Units.smul_def, Polynomial.smul_eq_C_mul, (isUnit_C.mpr (Units.isUnit _)).mul_left_dvd]
  · rintro h q _ deg_pos deg_le dvd
    exact deg_pos.ne' <| degree_eq_zero_of_isUnit (h q deg_le dvd)


Verifying proof (Commit 89d8f573bd7b4e12f519ba5206164e7ec40edb94):
∨ q = p := by
  simp only [p_monic.irreducible_iff_lt_natDegree_lt p_1, Finset.mem_Ioc, and_imp,
    natDegree_pos_iff_degree_pos, natDegree_le_iff_degree_le]
  constructor
  · rintro h q deg_le dvd
    by_contra q_unit
    have := degree_pos_of_not_isUnit_of_dvd_monic q_unit dvd p_monic
    have hu := p_monic.isUnit_leadingCoeff_of_dvd dvd
    refine (h _ (monic_of_isUnit_leadingCoeff_inv_smul hu) ?_ ?_ (dvd_trans ?_ dvd)).elim
    · rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    · rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    · rw [Units.smul_def, Polynomial.smul_eq_C_mul, (isUnit_C.mpr (Units.isUnit _)).mul_left_dvd]
      rfl
  · rintro h q _ deg_pos deg_le dvd
    exact deg_pos.ne' <| degree_eq_zero_of_isUnit (h q deg_le dvd).resolve_right (Ne.symm p_1)

## Equations

- Polynomial.IsDomain = { add := AddWithOne.add, add_assoc := _, zero := AddWithOne.zero, zero_add := _, add_zero := _, nsmul := AddWithOne.nsmul, nsmul_zero' := _, nsmul_succ' := _, neg := Neg.neg, sub := Sub.sub, sub_eq_add_neg := _, zsmul := SubNegMonoid.zsmul, zsmul_zero' := _, zsmul_succ' := _, zsmul_neg' := _, add_left_neg := _, add_comm := _, int_cast := AddWithOne.intCast, natCast := AddWithOne.natCast, one := AddWithOne.one, natCast_zero := _, natCast_succ := _, intCast_ofNat := _, intCast_negSucc := _, mul := Mul.mul, mul_assoc := _, one_mul := _, mul_one := _, npow := Monoid.npow, npow_zero' := _, npow_succ' := _, left_distrib := _, right_distrib := _, mul_comm := _, inv := Inv.inv, div := Div.div, div_eq_mul_inv := _, zpow := DivInvMonoid.zpow, zpow_zero' := _, zpow_succ' := _, zpow_neg' := _, exists_pair_ne := _, mul_inv_cancel := _, inv_zero := _, mul_div_cancel := _, mul_div_cancel_left := _}

## Equations

- Polynomial.noZeroDivisors = { eq_zero_or_eq_zero_of_mul_eq_zero := _}

## Equations

- Polynomial.isDomain = { add := AddWithOne.add, add_assoc := _, zero := AddWithOne.zero, zero_add := _, add_zero := _, nsmul := AddWithOne.nsmul, nsmul_zero' := _, nsmul_succ' := _, neg := Neg.neg, sub := Sub.sub, sub_eq_add_neg := _, zsmul := SubNegMonoid.zsmul, zsmul_zero' := _, zsmul_succ' := _, zsmul_neg' := _, add_left_neg := _, add_comm := _, intCast := AddWithOne.intCast, natCast := AddWithOne.natCast, one := AddWithOne.one, natCast_zero := _, natCast_succ := _, intCast_ofNat := _, intCast_negSucc := _, mul := Mul.mul, mul_assoc := _, one_mul := _, mul_one := _, npow := Monoid.npow, npow_zero' := _, npow_succ' := _, left_distrib := _, right_distrib := _, mul_comm := _, inv := Inv.inv, div := Div.div, div_eq_mul_inv := _, zpow := DivInvMonoid.zpow, zpow_zero' := _, zpow_succ' := _, zpow_neg' := _, exists_pair_ne := _, mul_inv_cancel := _, inv_zero := _, mul_div_cancel := _, mul_div_cancel_left := _, mul_comm := _, npow_neg' := _, gcd := Polynomial.gcd, lcm := Polynomial.lcm, gcd_zero_left := _, gcd_val := _, lcm_zero_left := _, lcm_val := _, gcd_mul_lcm := _}

## Equations

- Polynomial.cancelCommMonoidWithZero = { add := AddWithOne.add, add_assoc := _, zero := AddWithOne.zero, zero_add := _, add_zero := _, nsmul := AddWithOne.nsmul, nsmul_zero' := _, nsmul_succ' := _, neg := Neg.neg, sub := Sub.sub, sub_eq_add_neg := _, zsmul := SubNegMonoid.zsmul, zsmul_zero' := _, zsmul_succ' := _, zsmul_neg' := _, add_left_neg := _, add_comm := _, intCast := AddWithOne.intCast, natCast := AddWithOne.natCast, one := AddWithOne.one, natCast_zero := _, natCast_succ := _, intCast_ofNat := _, intCast_negSucc := _, mul := Mul.mul, mul_assoc := _, one_mul := _, mul_one := _, npow := Monoid.npow, npow_zero' := _, npow_succ' := _, left_distrib := _, right_distrib := _, mul_comm := _, inv := Inv.inv, div := Div.div, div_eq_mul_inv := _, zpow := DivInvMonoid.zpow, zpow_zero' := _, zpow_succ' := _, zpow_neg' := _, exists_pair_ne := _, mul_inv_cancel := _, inv_zero := _, mul_div_cancel := _, mul_div_cancel_left := _, mul_comm := _, npow_neg' := _, gcd := Polynomial.gcd, lcm := Polynomial.lcm, gcd_zero_left := _, gcd_val := _, lcm_zero_left := _, lcm_val := _, gcd_mul_lcm := _, exists_pair_ne := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations

- Polynomial.isNoetherianRing = { exists_finset_of_fg := _}

## Equations


Attempt failure.

Working on Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean - 2024-09-07 12:39:22.147593.
---11/100---
For theorem WeierstrassCurve.Projective.equiv_of_Z_eq_zero in Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean:
lemma equiv_of_Z_eq_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ≈ Q 


Original valid proof:
:= by
  rw [fin3_def P, hPz] at hP ⊢
  rw [fin3_def Q, hQz] at hQ ⊢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact ⟨Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel₀ _ hQ]⟩


Verifying proof (Commit 61f440df94983ae756aa6a0cd1afe07a37060d59):
 := by
  rw [← fin3_def P, hPz] at hP ⊢
  rw [← fin3_def Q, hQz] at hQ ⊢
  simp only [nonsingular_iff, equation_iff, fin3_def_ext, zero_pow two_ne_zero,
    zero_pow three_ne_zero, mul_zero, add_zero, sub_zero, @eq_comm F 0,
    pow_eq_zero_iff three_ne_zero] at hP hQ
  simp only [hP, hQ, true_and, zero_pow two_ne_zero, mul_zero, ne_self_iff_false, false_or,
    zero_mul, add_zero, pow_ne_zero_iff two_ne_zero] at hP hQ ⊢
  exact ⟨Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancel₀ _ hQ]⟩

####  Eric Wieser (Jun 01 2020 at 10:00):

I'm not sure what the problem is, but I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:00):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either.


Attempt failure.

Working on Mathlib/AlgebraicTopology/SimplexCategory.lean - 2024-09-07 12:39:52.828447.
---12/100---
For theorem SimplexCategory.δ_comp_σ_of_gt in Mathlib/AlgebraicTopology/SimplexCategory.lean:
theorem δ_comp_σ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    δ i.succ ≫ σ (Fin.castSucc j) = σ j ≫ δ i 


Original valid proof:
:= by
  ext k : 3
  dsimp [δ, σ]
  rcases le_or_lt k i with (hik | hik)
  · rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    · rw [Fin.predAbove_of_le_castSucc _ _
      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    · rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  · rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
      (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]


Verifying proof (Commit 2009db69c1211eafea457d1c3902f31370dac23f):
 := by
  ext ⟨k, hk⟩
  rcases i with ⟨i, hi⟩
  rcases j with ⟨j, hj⟩
  simp at H hk
  dsimp [δ, σ, Fin.predAbove, Fin.succAbove]
  simp only [Fin.lt_iff_val_lt_val, Fin.dite_val, Fin.ite_val, Fin.coe_pred, ge_iff_le,
    Fin.coe_castLT, dite_eq_ite, Fin.coe_castSucc, Fin.val_succ]
  split_ifs
  all_goals try simp <;> linarith
  all_goals cases k <;> simp at * <;> linarith

####  Yakov Pechersky (May 01 2020 at 17:00):

I'm not sure if this is a bug, but I'm getting a weird error when I try to use thesimp_rw tactic.

####  Yakov Pechersky (May 01 2020 at 17:01):

I'm trying to prove this:
import data.matrix.basic

open_locale matrix

variables {α : Type*} {m n : ℕ}

def matrix.row (M : matrix (fin m) (fin n) α) (i : fin m) : fin n → α :=
λ j, M i j

lemma row_transpose_row {M : matrix (fin m) (fin n) α} {i j : fin m} :
  (M.transpose).row i = M.row j :=
begin
  funext k,
  simp_rw [matrix.row, matrix.transpose, matrix.row],
  refl,
end

####  Yakov Pechersky (May 01 2020 at 17:01):

I get this error:
type mismatch at application
  matrix.row
term
  M.transpose
has type
  fin n → fin m → α
but is expected to have type
  fin m → fin n → α

####  Yakov Pechersky (May 01 2020 at 17:02):

I'm not sure if this is a bug, but I'm getting a weird error when I try to use the
simp_rw tactic.

####  Yakov Pechersky (May 01 2020 at 17:02):

I'm trying to prove this:
import data.matrix.basic

open_locale matrix

variables {α : Type*} {m n : ℕ}

def matrix.row (M : matrix (fin m) (fin n) α) (i : fin m) : fin n → α :=
λ j, M i j

lemma row_transpose_row {M : matrix (fin m) (fin n) α} {i j : fin m} :
  (M.transpose).row i = M.row j :=
begin
  funext k,
  simp_rw [matrix.row, matrix.transpose, matrix.row],
  refl,
end

####  Yakov Pechersky (May 01 2020 at 17:02):

I get this error:
type mismatch at application
  matrix.row
term
  M.transpose
has type
  fin n → fin m → α
but is expected to have type
  fin m → fin n → α

####  Yakov Pechersky (May 01 2020 at 17:03):

I'm not sure if this is a bug, but I'm getting a weird error when I try to use the
simp_rw tactic.

####  Yakov Pechersky (May 01 2020 at 17:03):

I'm trying to prove this:
import data.matrix.basic

open_locale matrix

variables {α : Type*} {m n : ℕ}

def matrix.row (M : matrix (fin m) (fin n) α) (i : fin m) : fin n → α :=
λ j, M i j

lemma row_transpose_row {M : matrix (fin m) (fin n) α} {i j : fin m} :
  (M.transpose).row i = M.row j :=
begin
  funext k,
  simp_rw [matrix.row, matrix.transpose, matrix.row],
  refl,
end

####  Yakov Pechersky (May 01 2020 at 17:03):

I get this error:
type mismatch at application
  matrix.row
term
  M.transpose
has type
  fin n → fin m → α
but is expected to have type
  fin m → fin n → α

####  Yakov Pechersky (May 01 2020 at 17:04):

I'm not sure if this is a bug, but I'm getting a weird error when I try to use the
simp_rw tactic.

####  Yakov Pechersky (May 01 2020 at 17:04):

I'm trying to prove this:
import data.matrix.basic

open_locale matrix

variables {α : Type*} {m n : ℕ}

def matrix.row (M : matrix (fin m) (fin n) α) (i : fin m) : fin n → α :=
λ j, M i j

lemma row_transpose_row {M : matrix (fin m) (fin n) α} {i j : fin m} :
  (M.transpose).row i = M.row j :=
begin
  funext k,
  simp_rw [matrix.row, matrix.transpose, matrix.row],
  refl,
end

####  Yakov Pechersky (May 01 2020 at 17:04):

I get this error:
type mismatch at application
  matrix.row
term
  M.transpose
has type
  fin n → fin m → α
but is expected to have type
  fin m → fin n → α

####  Yakov Pechersky (May 01 2020 at 17:05):

I'm not sure if this is a bug, but I'm getting a weird error when I try to use the
simp_rw tactic.

####  Yakov Pechersky (May 01 2020 at 17:05):

I'm trying to prove this:
import data.matrix.basic

open_locale matrix

variables {α : Type*} {m n : ℕ}

def matrix.row (M : matrix (fin m) (fin n) α) (i : fin m) : fin n → α :=
λ j, M i j

lemma row_transpose_row {M : matrix (fin m) (fin n) α} {i j : fin m} :
  (M.transpose).row i = M.row j :=
begin
  funext k,
  simp_rw [matrix.row, matrix.transpose, matrix.row],
  refl,
end

####  Yakov Pechersky (May 01 2020 at 17:05):

I get this error:
type mismatch at application
  matrix.row
term
  M.transpose
has type
  fin n → fin m → α
but is expected to have type
  fin m → fin n → α

####  Yakov Pechersky (May 01 2020 at 17:06):

I'm not sure if this is a bug, but I'm getting a weird error when I try to use the
simp_rw tactic.

####  Yakov Pechersky (May 01 2020 at 17:06):

I'm trying to prove this:
import data.matrix.basic

open_locale matrix

variables {α : Type*} {m n : ℕ}

def matrix.row (M : matrix (fin m) (fin n) α) (i : fin m) : fin n → α :=
λ j, M i j

lemma row_transpose_row {M : matrix (fin m) (fin n) α} {i j : fin

Attempt failure.

---13/100---
For theorem SimplexCategory.δ_comp_σ_of_gt in Mathlib/AlgebraicTopology/SimplexCategory.lean:
theorem δ_comp_σ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    δ i.succ ≫ σ (Fin.castSucc j) = σ j ≫ δ i 


Original valid proof:
:= by
  ext k : 3
  dsimp [δ, σ]
  rcases le_or_lt k i with (hik | hik)
  · rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    · rw [Fin.predAbove_of_le_castSucc _ _
      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    · rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  · rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
      (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]


Verifying proof (Commit 1b5c1d10be0ae07fd997c78515f4ed4561b92535):
 := by
  ext k : 3
  dsimp [δ, σ]
  rcases le_or_lt k i with (hik | hik)
  · rw [Fin.succAbove_below _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    · rw [Fin.predAbove_below _ _ (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_below _ _ hjk, Fin.succAbove_below, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    · rw [Fin.predAbove_above _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_above _ _ hjk, Fin.succAbove_below, Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  · rw [Fin.succAbove_above _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_above _ _ hjk, Fin.predAbove_above _ _ (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_above, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]

## Equations

- Fin.succAbove n i = Fin.succAbove' n i

## Equations

- Fin.predAbove n i = Fin.predAbove' n i

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩

## Equations

- Fin.predAbove' n i = ⟨fun j => ⟨↑j - 1, _⟩, _⟩

## Equations

- Fin.succAbove' n i = ⟨fun j => ⟨↑j + 1, _⟩, _⟩



Attempt failure.

Working on Mathlib/Analysis/BoundedVariation.lean - 2024-09-07 12:40:16.793555.
---14/100---
For theorem eVariationOn.lowerSemicontinuous_uniformOn in Mathlib/Analysis/BoundedVariation.lean:
theorem lowerSemicontinuous_uniformOn (s : Set α) :
    LowerSemicontinuous fun f : α →ᵤ[{s}] E => eVariationOn f s 


Original valid proof:
:= fun f ↦ by
  apply @lowerSemicontinuous_aux _ _ _ _ (UniformOnFun α E {s}) id (𝓝 f) f s _
  have := @tendsto_id _ (𝓝 f)
  rw [UniformOnFun.tendsto_iff_tendstoUniformlyOn] at this
  simp_rw [← tendstoUniformlyOn_singleton_iff_tendsto]
  exact fun x xs => (this s rfl).mono (singleton_subset_iff.mpr xs)


Verifying proof (Commit 96cf974eb3910f8af599dab3fd734ea72d5614ad):
 := fun f ↦ by
  rw [lowerSemicontinuousAt_iff_eventually_lt]
  apply @lowerSemicontinuous_aux _ _ _ _ (UniformOnFun α E {s}) id (𝓝 f) f s _
  have := @tendsto_id _ (𝓝 f)
  rw [UniformOnFun.tendsto_iff_tendstoUniformlyOn] at this
  simp_rw [← tendstoUniformlyOn_singleton_iff_tendsto]
  exact fun x xs => (this s rfl).mono (singleton_subset_iff.mpr xs)

## 1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.

Attempt failure.

Working on Mathlib/Analysis/Calculus/MeanValue.lean - 2024-09-07 12:41:41.573286.
---15/100---
For theorem strictMono_of_deriv_pos in Mathlib/Analysis/Calculus/MeanValue.lean:
theorem strictMono_of_deriv_pos {f : ℝ → ℝ} (hf' : ∀ x, 0 < deriv f x) : StrictMono f 


Original valid proof:
:=
  strictMonoOn_univ.1 <| strictMonoOn_of_deriv_pos convex_univ (fun z _ =>
    (differentiableAt_of_deriv_ne_zero (hf' z).ne').differentiableWithinAt.continuousWithinAt)
    fun x _ => hf' x


Verifying proof (Commit 0939faa78a0c4506a8aee4e86b897d6e84c6cb96):
 :=
  strictMonoOn_univ.1 <| convex_univ.strictMonoOn_of_deriv_pos (fun z _ =>
    (differentiableAt_of_deriv_ne_zero (hf' z).ne').differentiableWithinAt.continuousWithinAt)
    fun x _ => hf' x

####  Patrick Massot (May 10 2020 at 10:03):

I'm not sure I understand the problem.

####  Patrick Massot (May 10 2020 at 10:03):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:03):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I don't see why the proof is not valid.

####  Patrick Massot (May 10 2020 at 10:04):

I

Attempt failure.

Working on Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean - 2024-09-07 12:42:03.590271.
---16/100---
For theorem hasFDerivAt_of_tendstoUniformlyOn in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit 65f7857d510e130142dbb111786341d695ac399b):
 := by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)

## 1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.

Attempt failure.

---17/100---
For theorem hasFDerivAt_of_tendstoUniformlyOn in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
 := by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @IsROrC.norm_ofReal 𝕜 _ _, IsROrC.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0); simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this ε hε).mono fun y hy => _
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    exact hy
  · 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, IsROrC.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_op_norm (n.2 - x)
















































































































































































































































































































































































































































































































































































































































































































Attempt failure.

---18/100---
For theorem hasFDerivAt_of_tendstoUniformlyOn in Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x 


Original valid proof:
:= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  · have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this ε hε).mono fun y hy => ?_
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
  rw [← tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : ι × E =>
          (‖a.2 - x‖⁻¹ : 𝕜) • (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : ι × E => (‖a.2 - x‖⁻¹ : 𝕜) • (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [← smul_add, ← smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : 𝓝 (0 : G) = 𝓝 (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  · simp only
    have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro ε hε
    apply ((this ε hε).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn ⊢
    rw [← smul_sub] at hn
    rwa [sub_zero]
  · 
    rw [Metric.tendsto_nhds]
    intro ε hε
    rw [eventually_curry_iff]
    refine' hf.curry.mono fun n hn => _
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine' (this ε hε).mono fun y hy => _
    rw [dist_eq_norm] at hy ⊢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy ⊢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  · 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : ι × E => g' n.2 - f' n.1 n.2) (l ×ˢ 𝓝 x) (𝓝 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun ε hε => by simpa using hf' ε hε
    have h2 : Tendsto (fun n : ι => g' x - f' n x) l (𝓝 0) := by
      rw [Metric.tendsto_nhds] at h1 ⊢
      exact fun ε hε => (h1 ε hε).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; · simp [hx]
    have hnx : 0 < ‖n.2 - x‖ := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)

## Your Answer

By clicking “Post Your Answer”, you agree to our terms of service, privacy policy and cookie policy

Attempt failure.

Working on Mathlib/Analysis/Convolution.lean - 2024-09-07 12:42:52.126715.
---19/100---
For theorem MeasureTheory.hasFDerivAt_convolution_right_with_param in Mathlib/Analysis/Convolution.lean:
theorem hasFDerivAt_convolution_right_with_param {g : P → G → E'} {s : Set P} {k : Set G}
    (hs : IsOpen s) (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0)
    (hf : LocallyIntegrable f μ) (hg : ContDiffOn 𝕜 1 (↿g) (s ×ˢ univ)) (q₀ : P × G)
    (hq₀ : q₀.1 ∈ s) :
    HasFDerivAt (fun q : P × G => (f ⋆[L, μ] g q.1) q.2)
      ((f ⋆[L.precompR (P × G), μ] fun x : G => fderiv 𝕜 (↿g) (q₀.1, x)) q₀.2) q₀ 


Original valid proof:
:= by
  let g' := fderiv 𝕜 ↿g
  have A : ∀ p ∈ s, Continuous (g p) := fun p hp ↦ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ∀ q : P × G, q.1 ∈ s → s ×ˢ univ ∈ 𝓝 q := fun q hq ↦ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ∀ p x, p ∈ s → x ∉ k → g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : kᶜ ∈ 𝓝 x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ∈ 𝓝 p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ⟨p, y⟩ ⟨hp, hy⟩
    exact hgs p y hp hy
  obtain ⟨ε, C, εpos, h₀ε, hε⟩ :
      ∃ ε C, 0 < ε ∧ ball q₀.1 ε ⊆ s ∧ ∀ p x, ‖p - q₀.1‖ < ε → ‖g' (p, x)‖ ≤ C := by
    have A : IsCompact ({q₀.1} ×ˢ k) := isCompact_singleton.prod hk
    obtain ⟨t, kt, t_open, ht⟩ : ∃ t, {q₀.1} ×ˢ k ⊆ t ∧ IsOpen t ∧ IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s ×ˢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq₀, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ⟨ε, εpos, hε, h'ε⟩ :
      ∃ ε : ℝ, 0 < ε ∧ thickening ε ({q₀.fst} ×ˢ k) ⊆ t ∧ ball q₀.1 ε ⊆ s := by
      obtain ⟨ε, εpos, hε⟩ : ∃ ε : ℝ, 0 < ε ∧ thickening ε (({q₀.fst} : Set P) ×ˢ k) ⊆ t :=
        A.exists_thickening_subset_open t_open kt
      obtain ⟨δ, δpos, hδ⟩ : ∃ δ : ℝ, 0 < δ ∧ ball q₀.1 δ ⊆ s := Metric.isOpen_iff.1 hs _ hq₀
      refine ⟨min ε δ, lt_min εpos δpos, ?_, ?_⟩
      · exact Subset.trans (thickening_mono (min_le_left _ _) _) hε
      · exact Subset.trans (ball_subset_ball (min_le_right _ _)) hδ
    obtain ⟨C, Cpos, hC⟩ : ∃ C, 0 < C ∧ g' '' t ⊆ closedBall 0 C := ht.subset_closedBall_lt 0 0
    refine ⟨ε, C, εpos, h'ε, fun p x hp => ?_⟩
    have hps : p ∈ s := h'ε (mem_ball_iff_norm.2 hp)
    by_cases hx : x ∈ k
    · have H : (p, x) ∈ t := by
        apply hε
        refine mem_thickening_iff.2 ⟨(q₀.1, x), ?_, ?_⟩
        · simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        · rw [← dist_eq_norm] at hp
          simpa only [Prod.dist_eq, εpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ∈ closedBall (0 : P × G →L[𝕜] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    · have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ∀ᶠ x : P × G in 𝓝 q₀, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) μ := by
    filter_upwards [A' q₀ hq₀]
    rintro ⟨p, x⟩ ⟨hp, -⟩
    refine (HasCompactSupport.convolutionExists_right L ?_ hf (A _ hp) _).1
    apply hk.of_isClosed_subset (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q₀.1 (q₀.2 - a))) μ := by
    have M : HasCompactSupport (g q₀.1) := HasCompactSupport.intro hk fun x hx => hgs q₀.1 x hq₀ hx
    apply M.convolutionExists_right L hf (A q₀.1 hq₀) q₀.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q₀.fst, q₀.snd - a))) μ := by
    have T : HasCompactSupport fun y => g' (q₀.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q₀.1 x hq₀ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P × G) : _) T hf _ q₀.2).1
    have : ContinuousOn g' (s ×ˢ univ) :=
      hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq₀
  set K' := (-k + {q₀.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ⟨U, U_open, K'U, hU⟩ : ∃ U, IsOpen U ∧ K' ⊆ U ∧ IntegrableOn f U μ :=
    hf.integrableOn_nhds_isCompact hK'
  obtain ⟨δ, δpos, δε, hδ⟩ : ∃ δ, (0 : ℝ) < δ ∧ δ ≤ ε ∧ K' + ball 0 δ ⊆ U := by
    obtain ⟨V, V_mem, hV⟩ : ∃ V ∈ 𝓝 (0 : G), K' + V ⊆ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ⟨δ, δpos, hδ⟩
    refine ⟨min δ ε, lt_min δpos εpos, min_le_right δ ε, ?_⟩
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hδ)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (𝕜 := 𝕜) (𝕜₂ := 𝕜) (E := E)
    (F := (P × G →L[𝕜] E') →L[𝕜] P × G →L[𝕜] F) (σ₁₂ := RingHom.id 𝕜)
  let bound : G → ℝ := indicator U fun t => ‖(L.precompR (P × G))‖ * ‖f t‖ * C
  have I4 : ∀ᵐ a : G ∂μ, ∀ x : P × G, dist x q₀ < δ →
      ‖L.precompR (P × G) (f a) (g' (x.fst, x.snd - a))‖ ≤ bound a := by
    filter_upwards with a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q₀.2 δ ⊆ U := by
      apply Subset.trans _ hδ
      rw [K'_def, add_assoc]
      apply add_subset_add
      · rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h₀ε _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le δε
      · simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    · intro y
      exact hε _ _ (((le_max_left _ _).trans_lt hx).trans_le δε)
    · rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound μ := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ∀ᵐ a : G ∂μ, ∀ x : P × G, dist x q₀ < δ →
      HasFDerivAt (fun x : P × G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    filter_upwards with a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s ×ˢ univ ∈ 𝓝 (x.1, x.2 - a) := by
      apply A'
      apply h₀ε
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) δε
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P × G => (x.1, x.2 - a)) (ContinuousLinearMap.id 𝕜 (P × G)) x := by
      have : (fun x : P × G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, _root_.id, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le δpos I1 I2 I3 I4 I5 I6


Verifying proof (Commit 6eab74639023015a7887e2f82e153907286e3801):
have : ContinuousAt (↿g') (q₀.1, q₀.2) :=
      hg.fderivOn.continuousOn.continuousAt (hs.prod isOpen_univ).mem_nhds
    have : Tendsto (↿g') (𝓝 (q₀.1, q₀.2)) (𝓝 (g' q₀.1 q₀.2)) :=
      (continuousAt_iff_continuous_withinAt.1 this).mono (subset_univ _)
    obtain ⟨δ

Attempt failure.

---20/100---
For theorem MeasureTheory.hasFDerivAt_convolution_right_with_param in Mathlib/Analysis/Convolution.lean:
theorem hasFDerivAt_convolution_right_with_param {g : P → G → E'} {s : Set P} {k : Set G}
    (hs : IsOpen s) (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0)
    (hf : LocallyIntegrable f μ) (hg : ContDiffOn 𝕜 1 (↿g) (s ×ˢ univ)) (q₀ : P × G)
    (hq₀ : q₀.1 ∈ s) :
    HasFDerivAt (fun q : P × G => (f ⋆[L, μ] g q.1) q.2)
      ((f ⋆[L.precompR (P × G), μ] fun x : G => fderiv 𝕜 (↿g) (q₀.1, x)) q₀.2) q₀ 


Original valid proof:
:= by
  let g' := fderiv 𝕜 ↿g
  have A : ∀ p ∈ s, Continuous (g p) := fun p hp ↦ by
    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hp
  have A' : ∀ q : P × G, q.1 ∈ s → s ×ˢ univ ∈ 𝓝 q := fun q hq ↦ by
    apply (hs.prod isOpen_univ).mem_nhds
    simpa only [mem_prod, mem_univ, and_true_iff] using hq
  have g'_zero : ∀ p x, p ∈ s → x ∉ k → g' (p, x) = 0 := by
    intro p x hp hx
    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv
    have M2 : kᶜ ∈ 𝓝 x := hk.isClosed.isOpen_compl.mem_nhds hx
    have M1 : s ∈ 𝓝 p := hs.mem_nhds hp
    rw [nhds_prod_eq]
    filter_upwards [prod_mem_prod M1 M2]
    rintro ⟨p, y⟩ ⟨hp, hy⟩
    exact hgs p y hp hy
  obtain ⟨ε, C, εpos, h₀ε, hε⟩ :
      ∃ ε C, 0 < ε ∧ ball q₀.1 ε ⊆ s ∧ ∀ p x, ‖p - q₀.1‖ < ε → ‖g' (p, x)‖ ≤ C := by
    have A : IsCompact ({q₀.1} ×ˢ k) := isCompact_singleton.prod hk
    obtain ⟨t, kt, t_open, ht⟩ : ∃ t, {q₀.1} ×ˢ k ⊆ t ∧ IsOpen t ∧ IsBounded (g' '' t) := by
      have B : ContinuousOn g' (s ×ˢ univ) :=
        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B
      simp only [prod_subset_prod_iff, hq₀, singleton_subset_iff, subset_univ, and_self_iff,
        true_or_iff]
    obtain ⟨ε, εpos, hε, h'ε⟩ :
      ∃ ε : ℝ, 0 < ε ∧ thickening ε ({q₀.fst} ×ˢ k) ⊆ t ∧ ball q₀.1 ε ⊆ s := by
      obtain ⟨ε, εpos, hε⟩ : ∃ ε : ℝ, 0 < ε ∧ thickening ε (({q₀.fst} : Set P) ×ˢ k) ⊆ t :=
        A.exists_thickening_subset_open t_open kt
      obtain ⟨δ, δpos, hδ⟩ : ∃ δ : ℝ, 0 < δ ∧ ball q₀.1 δ ⊆ s := Metric.isOpen_iff.1 hs _ hq₀
      refine ⟨min ε δ, lt_min εpos δpos, ?_, ?_⟩
      · exact Subset.trans (thickening_mono (min_le_left _ _) _) hε
      · exact Subset.trans (ball_subset_ball (min_le_right _ _)) hδ
    obtain ⟨C, Cpos, hC⟩ : ∃ C, 0 < C ∧ g' '' t ⊆ closedBall 0 C := ht.subset_closedBall_lt 0 0
    refine ⟨ε, C, εpos, h'ε, fun p x hp => ?_⟩
    have hps : p ∈ s := h'ε (mem_ball_iff_norm.2 hp)
    by_cases hx : x ∈ k
    · have H : (p, x) ∈ t := by
        apply hε
        refine mem_thickening_iff.2 ⟨(q₀.1, x), ?_, ?_⟩
        · simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and_iff,
            exists_eq_right]
        · rw [← dist_eq_norm] at hp
          simpa only [Prod.dist_eq, εpos, dist_self, max_lt_iff, and_true_iff] using hp
      have : g' (p, x) ∈ closedBall (0 : P × G →L[𝕜] E') C := hC (mem_image_of_mem _ H)
      rwa [mem_closedBall_zero_iff] at this
    · have : g' (p, x) = 0 := g'_zero _ _ hps hx
      rw [this]
      simpa only [norm_zero] using Cpos.le
  have I1 :
    ∀ᶠ x : P × G in 𝓝 q₀, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) μ := by
    filter_upwards [A' q₀ hq₀]
    rintro ⟨p, x⟩ ⟨hp, -⟩
    refine (HasCompactSupport.convolutionExists_right L ?_ hf (A _ hp) _).1
    apply hk.of_isClosed_subset (isClosed_tsupport _)
    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed
  have I2 : Integrable (fun a : G => L (f a) (g q₀.1 (q₀.2 - a))) μ := by
    have M : HasCompactSupport (g q₀.1) := HasCompactSupport.intro hk fun x hx => hgs q₀.1 x hq₀ hx
    apply M.convolutionExists_right L hf (A q₀.1 hq₀) q₀.2
  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q₀.fst, q₀.snd - a))) μ := by
    have T : HasCompactSupport fun y => g' (q₀.1, y) :=
      HasCompactSupport.intro hk fun x hx => g'_zero q₀.1 x hq₀ hx
    apply (HasCompactSupport.convolutionExists_right (L.precompR (P × G) : _) T hf _ q₀.2).1
    have : ContinuousOn g' (s ×ˢ univ) :=
      hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl
    apply this.comp_continuous (continuous_const.prod_mk continuous_id')
    intro x
    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true_iff] using hq₀
  set K' := (-k + {q₀.2} : Set G) with K'_def
  have hK' : IsCompact K' := hk.neg.add isCompact_singleton
  obtain ⟨U, U_open, K'U, hU⟩ : ∃ U, IsOpen U ∧ K' ⊆ U ∧ IntegrableOn f U μ :=
    hf.integrableOn_nhds_isCompact hK'
  obtain ⟨δ, δpos, δε, hδ⟩ : ∃ δ, (0 : ℝ) < δ ∧ δ ≤ ε ∧ K' + ball 0 δ ⊆ U := by
    obtain ⟨V, V_mem, hV⟩ : ∃ V ∈ 𝓝 (0 : G), K' + V ⊆ U :=
      compact_open_separated_add_right hK' U_open K'U
    rcases Metric.mem_nhds_iff.1 V_mem with ⟨δ, δpos, hδ⟩
    refine ⟨min δ ε, lt_min δpos εpos, min_le_right δ ε, ?_⟩
    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hδ)).trans hV
  letI := ContinuousLinearMap.hasOpNorm (𝕜 := 𝕜) (𝕜₂ := 𝕜) (E := E)
    (F := (P × G →L[𝕜] E') →L[𝕜] P × G →L[𝕜] F) (σ₁₂ := RingHom.id 𝕜)
  let bound : G → ℝ := indicator U fun t => ‖(L.precompR (P × G))‖ * ‖f t‖ * C
  have I4 : ∀ᵐ a : G ∂μ, ∀ x : P × G, dist x q₀ < δ →
      ‖L.precompR (P × G) (f a) (g' (x.fst, x.snd - a))‖ ≤ bound a := by
    filter_upwards with a x hx
    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx
    have : (-tsupport fun a => g' (x.1, a)) + ball q₀.2 δ ⊆ U := by
      apply Subset.trans _ hδ
      rw [K'_def, add_assoc]
      apply add_subset_add
      · rw [neg_subset_neg]
        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed
        apply g'_zero x.1 z (h₀ε _) hz
        rw [mem_ball_iff_norm]
        exact ((le_max_left _ _).trans_lt hx).trans_le δε
      · simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]
    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this
    · intro y
      exact hε _ _ (((le_max_left _ _).trans_lt hx).trans_le δε)
    · rw [mem_ball_iff_norm]
      exact (le_max_right _ _).trans_lt hx
  have I5 : Integrable bound μ := by
    rw [integrable_indicator_iff U_open.measurableSet]
    exact (hU.norm.const_mul _).mul_const _
  have I6 : ∀ᵐ a : G ∂μ, ∀ x : P × G, dist x q₀ < δ →
      HasFDerivAt (fun x : P × G => L (f a) (g x.1 (x.2 - a)))
        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by
    filter_upwards with a x hx
    apply (L _).hasFDerivAt.comp x
    have N : s ×ˢ univ ∈ 𝓝 (x.1, x.2 - a) := by
      apply A'
      apply h₀ε
      rw [Prod.dist_eq] at hx
      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) δε
    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt
    have Z' :
        HasFDerivAt (fun x : P × G => (x.1, x.2 - a)) (ContinuousLinearMap.id 𝕜 (P × G)) x := by
      have : (fun x : P × G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by
        ext x <;> simp only [Pi.sub_apply, _root_.id, Prod.fst_sub, sub_zero, Prod.snd_sub]
      rw [this]
      exact (hasFDerivAt_id x).sub_const (0, a)
    exact Z.comp x Z'
  exact hasFDerivAt_integral_of_dominated_of_fderiv_le δpos I1 I2 I3 I4 I5 I6


Verifying proof (Commit 05dd33777bb0a96c66523df7c7d1a34b2d9a1be5):
 εpos
      rw [dist_eq_zero]
      exact (A p y hp (hx.mono hy)).trans (A' p y hp (hx.mono hy)).symm
    have : ∀ p, p ∈ s → ∀ x, x ∉ k → ∀ᶠ y : G in 𝓝 x, dist (g p y) (g' p y) < ε := by
      intro p hp x hx
      apply Filter.eventually_of_forall
      intro y hy
      apply lt_of_le_of_lt (dist_le_zero.2 _) εpos
      rw [dist_eq_zero]
      exact (A p y hp (hx.mono hy)).trans (A' p y hp (hx.mono hy)).symm
    have : ∀ p, p ∈ s → ∀ x, x ∉ k → ∀ᶠ y : G in 𝓝 x, dist (g p y) (g' p y) < ε := by
      intro p hp x hx
      apply Filter.eventually_of_forall
      intro y hy
      apply lt_of_le_of_lt (dist_le_zero.2 _) εpos
      rw [dist_eq_zero]
      exact (A p y hp (hx.mono hy)).trans (A' p y hp (hx.mono hy)).symm
    have : ∀ p, p ∈ s → ∀ x, x ∉ k → ∀ᶠ y : G in 𝓝 x, dist (g p y) (g' p y) < ε := by
      intro p hp x hx
      apply Filter.eventually_of_forall
      intro y hy
      apply lt_of_le_of_lt (dist_le_zero.2 _)

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/OfNorm.lean - 2024-09-07 12:45:11.042379.
---21/100---
For theorem InnerProductSpaceable.inner_.conj_symm in Mathlib/Analysis/InnerProductSpace/OfNorm.lean:
theorem inner_.conj_symm (x y : E) : conj (inner_ 𝕜 y x) = inner_ 𝕜 x y 


Original valid proof:
:= by
  simp only [inner_]
  have h4 : conj (4⁻¹ : 𝕜) = 4⁻¹ := by norm_num
  rw [map_mul, h4]
  congr 1
  simp only [map_sub, map_add, algebraMap_eq_ofReal, ← ofReal_mul, conj_ofReal, map_mul, conj_I]
  rw [add_comm y x, norm_sub_rev]
  by_cases hI : (I : 𝕜) = 0
  · simp only [hI, neg_zero, zero_mul]
  have : ‖(I : 𝕜)‖ = 1 := by
    rw [← mul_self_inj_of_nonneg (norm_nonneg I) zero_le_one, one_mul, ← norm_mul,
      I_mul_I_of_nonzero hI, norm_neg, norm_one]
  have h₁ : ‖(I : 𝕜) • y - x‖ = ‖(I : 𝕜) • x + y‖ := by
    trans ‖(I : 𝕜) • ((I : 𝕜) • y - x)‖
    · rw [norm_smul, this, one_mul]
    · rw [smul_sub, smul_smul, I_mul_I_of_nonzero hI, neg_one_smul, ← neg_add', add_comm, norm_neg]
  have h₂ : ‖(I : 𝕜) • y + x‖ = ‖(I : 𝕜) • x - y‖ := by
    trans ‖(I : 𝕜) • ((I : 𝕜) • y + x)‖
    · rw [norm_smul, this, one_mul]
    · rw [smul_add, smul_smul, I_mul_I_of_nonzero hI, neg_one_smul, ← neg_add_eq_sub]
  rw [h₁, h₂, ← sub_add_eq_add_sub]
  simp only [neg_mul, sub_eq_add_neg, neg_neg]


Verifying proof (Commit 04be4bbbcadfe3614915c9734fe17dc5503a6635):
 := by
  simp only [inner_]
  have h4 : conj (4⁻¹ : 𝕜) = 4⁻¹ := by norm_num
  rw [map_mul, h4]
  congr 1
  simp only [map_sub, map_add, conj_ofReal, map_mul, conj_I]
  rw [add_comm y x, norm_sub_rev]
  by_cases hI : (I : 𝕜) = 0
  · simp only [hI, neg_zero, zero_mul]
  have : ‖(I : 𝕜)‖ = 1 := by
    rw [← mul_self_inj_of_nonneg (norm_nonneg I) zero_le_one, one_mul, ← norm_mul,
      I_mul_I_of_nonzero hI, norm_neg, norm_one]
  have h₁ : ‖(I : 𝕜) • y - x‖ = ‖(I : 𝕜) • x + y‖ := by
    trans ‖(I : 𝕜) • ((I : 𝕜) • y - x)‖
    · rw [norm_smul, this, one_mul]
    · rw [smul_sub, smul_smul, I_mul_I_of_nonzero hI, neg_one_smul, ← neg_add', add_comm, norm_neg]
  have h₂ : ‖(I : 𝕜) • y + x‖ = ‖(I : 𝕜) • x - y‖ := by
    trans ‖(I : 𝕜) • ((I : 𝕜) • y + x)‖
    · rw [norm_smul, this, one_mul]
    · rw [smul_add, smul_smul, I_mul_I_of_nonzero hI, neg_one_smul, ← neg_add_eq_sub]
  rw [h₁, h₂, ← sub_add_eq_add_sub]
  simp only [neg_mul, sub_eq_add_neg, neg_neg]

## 1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/PiL2.lean - 2024-09-07 12:45:32.617484.
---22/100---
For theorem Orthonormal.exists_orthonormalBasis_extension in Mathlib/Analysis/InnerProductSpace/PiL2.lean:
theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) 


Original valid proof:
:= by
  obtain ⟨u₀, hu₀s, hu₀, hu₀_max⟩ := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu₀] at hu₀_max
  have hu₀_finite : u₀.Finite := hu₀.linearIndependent.setFinite
  let u : Finset E := hu₀_finite.toFinset
  let fu : ↥u ≃ ↥u₀ := hu₀_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal 𝕜 ((↑) : u → E) := by simpa using hu₀.comp _ fu.injective
  refine ⟨u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_, ?_, ?_⟩
  · simpa [u] using hu₀_max
  · simpa [u] using hu₀s
  · simp


Verifying proof (Commit fd3379ddac23e991aaf3056785fd48b9fc8dbdb6):
∧
      (∀ (x : E), x ∈ u → ∀ (y : E), y ∈ u → x ≠ y → ⟪x, y⟫ = 0) := by
  obtain ⟨u₀, hu₀s, hu₀, hu₀_max⟩ := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu₀] at hu₀_max
  have hu₀_finite : u₀.Finite := hu₀.linearIndependent.setFinite
  let u : Finset E := hu₀_finite.toFinset
  let fu : ↥u ≃ ↥u₀ := hu₀_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal 𝕜 ((↑) : u → E) := by simpa using hu₀.comp _ fu.injective
  refine ⟨u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_,? _?, _⟩
  · simpa [u] using hu₀_max
  · simpa [u] using hu₀s
  · simp

## Equations

- OrthonormalBasis.mkOfOrthogonalEqBot hv hv' = {toBasis := Basis.mkOfOrthogonalEqBot hv hv', toOrthonormal := hv}

theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) : ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) ∧ (∀ (x : E), x ∈ u → ∀ (y : E), y ∈ u → x ≠ y → ⟪x, y⟫ = 0) := by
  obtain ⟨u₀, hu₀s, hu₀, hu₀_max⟩ := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu₀] at hu₀_max
  have hu₀_finite : u₀.Finite := hu₀.linearIndependent.setFinite
  let u : Finset E := hu₀_finite.toFinset
  let fu : ↥u ≃ ↥u₀ := hu₀_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal 𝕜 ((↑) : u → E) := by simpa using hu₀.comp _ fu.injective
  refine ⟨u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_,? _?, _⟩
  · simpa [u] using hu₀_max
  · simpa [u] using hu₀s
  · simp

## Equations

- OrthonormalBasis.mkOfOrthogonalEqBot hv hv' = {toBasis := Basis.mkOfOrthogonalEqBot hv hv', toOrthonormal := hv}

theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) : ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) ∧ (∀ (x : E), x ∈ u → ∀ (y : E), y ∈ u → x ≠ y → ⟪x, y⟫ = 0) := by
  obtain ⟨u₀, hu₀s, hu₀, hu₀_max⟩ := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu₀] at hu₀_max
  have hu₀_finite : u₀.Finite := hu₀.linearIndependent.setFinite
  let u : Finset E := hu₀_finite.toFinset
  let fu : ↥u ≃ ↥u₀ := hu₀_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal 𝕜 ((↑) : u → E) := by simpa using hu₀.comp _ fu.injective
  refine ⟨u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_,? _?, _⟩
  · simpa [u] using hu₀_max
  · simpa [u] using hu₀s
  · simp

## Equations

- OrthonormalBasis.mkOfOrthogonalEqBot hv hv' = {toBasis := Basis.mkOfOrthogonalEqBot hv hv', toOrthonormal := hv}

theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) : ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) ∧ (∀ (x : E), x ∈ u → ∀ (y : E), y ∈ u → x ≠ y → ⟪x, y⟫ = 0) := by
  obtain ⟨u₀, hu₀s, hu₀, hu₀_max⟩ := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu₀] at hu₀_max
  have hu₀_finite : u₀.Finite := hu₀.linearIndependent.setFinite
  let u : Finset E := hu₀_finite.toFinset
  let fu : ↥u ≃ ↥u₀ := hu₀_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal 𝕜 ((↑) : u → E) := by simpa using hu₀.comp _ fu.injective
  refine ⟨u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_,? _?, _⟩
  · simpa [u] using hu₀_max
  · simpa [u] using hu₀s
  · simp

## Equations

- OrthonormalBasis.mkOfOrthogonalEqBot hv hv' = {toBasis := Basis.mkOfOrthogonalEqBot hv hv', toOrthonormal := hv}

theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) : ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) ∧ (∀ (x : E), x ∈ u → ∀ (y : E), y ∈ u → x ≠ y → ⟪x, y⟫ = 0) := by
  obtain ⟨u₀, hu₀s, hu₀, hu₀_max⟩ := exists_maximal_orthonormal hv
  rw [maximal_orthonormal_iff_orthogonalComplement_eq_bot hu₀] at hu₀_max
  have hu₀_finite : u₀.Finite := hu₀.linearIndependent.setFinite
  let u : Finset E := hu₀_finite.toFinset
  let fu : ↥u ≃ ↥u₀ := hu₀_finite.subtypeEquivToFinset.symm
  have hu : Orthonormal 𝕜 ((↑) : u → E) := by simpa using hu₀.comp _ fu.injective
  refine ⟨u, OrthonormalBasis.mkOfOrthogonalEqBot hu ?_,? _?, _⟩
  · simpa [u] using hu₀_max
  · simpa [u] using hu₀s
  · simp

## Equations

- Or

Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Projection.lean - 2024-09-07 12:46:08.897488.
---23/100---
For theorem LinearIsometryEquiv.reflections_generate_dim_aux in Mathlib/Analysis/InnerProductSpace/Projection.lean:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ℝ F] {n : ℕ}
    (φ : F ≃ₗᵢ[ℝ] F) (hn : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ ≤ n) :
    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod 


Original valid proof:
:= by
  induction' n with n IH generalizing φ
  · 
    refine ⟨[], rfl.le, show φ = 1 from ?_⟩
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  · 
    let W := ker (ContinuousLinearMap.id ℝ F - φ)
    have hW : ∀ w ∈ W, φ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ℝ Wᗮ ≤ n
    · obtain ⟨V, hV₁, hV₂⟩ := IH φ hn'
      exact ⟨V, hV₁.trans n.le_succ, hV₂⟩
    haveI : Nontrivial Wᗮ := nontrivial_of_finrank_pos (by omega : 0 < finrank ℝ Wᗮ)
    obtain ⟨v, hv⟩ := exists_ne (0 : Wᗮ)
    have hφv : φ v ∈ Wᗮ := by
      intro w hw
      rw [← hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ∉ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - φ v
    let ρ := reflection (ℝ ∙ x)ᗮ
    let V := ker (ContinuousLinearMap.id ℝ F - φ.trans ρ)
    have hV : ∀ w, ρ (φ w) = w → w ∈ V := by
      intro w hw
      change w - ρ (φ w) = 0
      rw [sub_eq_zero, hw]
    have H₂V : W ≤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hφv _ hw
    have H₁V : (v : F) ∈ V := by
      apply hV
      have : ρ v = φ v := reflection_sub (φ.norm_map v).symm
      rw [← this]
      exact reflection_reflection _ _
    have : finrank ℝ Vᗮ ≤ n := by
      change finrank ℝ Wᗮ ≤ n + 1 at hn
      have : finrank ℝ W + 1 ≤ finrank ℝ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ⟨H₂V, v, H₁V, hv'⟩)
      have : finrank ℝ V + finrank ℝ Vᗮ = finrank ℝ F := V.finrank_add_finrank_orthogonal
      have : finrank ℝ W + finrank ℝ Wᗮ = finrank ℝ F := W.finrank_add_finrank_orthogonal
      omega
    obtain ⟨l, hl, hφl⟩ := IH (ρ * φ) this
    refine ⟨x::l, Nat.succ_le_succ hl, ?_⟩
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (ρ * ·) hφl
    dsimp only at this
    rwa [← mul_assoc, reflection_mul_reflection, one_mul] at this


Verifying proof (Commit 6861d9247d1a06a093e444c3a0319e5ec45263c2):
∧
      ∀ v ∈ l, (v : F) ∈ ker (ContinuousLinearMap.id ℝ F - φ) := by
  induction' n with n IH generalizing φ
  · refine' ⟨[], rfl.le, rfl, fun v hv => _⟩
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  · 
    let W := ker (ContinuousLinearMap.id ℝ F - φ)
    have hW : ∀ w ∈ W, φ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ℝ Wᗮ ≤ n
    · obtain ⟨V, hV₁, hV₂, hV₃⟩ := IH φ hn'
      exact ⟨V, hV₁.trans n.le_succ, hV₂, hV₃⟩
    haveI : Nontrivial Wᗮ := nontrivial_of_finrank_pos (by omega : 0 < finrank ℝ Wᗮ)
    obtain ⟨v, hv⟩ := exists_ne (0 : Wᗮ)
    have hφv : φ v ∈ Wᗮ := by
      intro w hw
      rw [← hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ∉ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - φ v
    let ρ := reflection (ℝ ∙ x)ᗮ
    let V := ker (ContinuousLinearMap.id ℝ F - φ.trans ρ)
    have hV : ∀ w, ρ (φ w) = w → w ∈ V := by
      intro w hw
      change w - ρ (φ w) = 0
      rw [sub_eq_zero, hw]
    have H₂V : W ≤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      apply reflection_mem_subspace_eq_self
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hφv _ hw
    have H₁V : (v : F) ∈ V := by
      apply hV
      have : ρ v = φ v := reflection_sub (φ.norm_map v).symm
      rw [← this]
      exact reflection_reflection _ _
    have : finrank ℝ Vᗮ ≤ n := by
      change finrank ℝ Wᗮ ≤ n + 1 at hn
      have : finrank ℝ W + 1 ≤ finrank ℝ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ⟨H₂V, v, H₁V, hv'⟩)
      have : finrank ℝ V + finrank ℝ Vᗮ = finrank ℝ F := V.finrank_add_finrank_orthogonal
      have : finrank ℝ W + finrank ℝ Wᗮ = finrank ℝ F := W.finrank_add_finrank_orthogonal
      omega
    obtain ⟨l, hl, hφl, hVl⟩ := IH (ρ * φ) this
    refine' ⟨x::l, Nat.succ_le_succ hl, _, fun v hv => _⟩
    · rw [List.map_cons, List.prod_cons]
      have := congr_arg (ρ * ·) hφl
      dsimp only at this
      rwa [← mul_assoc, reflection_mul_reflection, one_mul] at this
    · have hv' : v ∈ V := by
        rw [← hVl v hv]
        exact H₁V
      have : ρ (φ v) = v := hφl v hv
      rw [← this]
      exact reflection_mem_subspace_eq_self (hV v this)

## References #

- [J. M. Lee, Introduction to Topological Manifolds](https://www.math.washington.edu/~lee/Books/
  Introduction%20to%20Topological%20Manifolds.pdf)

## Tags #

reflection, orthogonal complement, dimension, isometry

theorem reflection_subspace_eq_self {E : Type u_1} [NormedAddCommGroup E] [InnerProductSpace ℝ E] {W : Subspace ℝ E} (hw : ∀ (w : E), w ∈ W → ⟪w, w⟫_ℝ = 0) (v : E) (hv : v ∈ W) :

Reflection in a subspace is the identity when restricted to the subspace.

theorem reflection_orthogonal_eq_neg {E : Type u_1} [NormedAddCommGroup E] [InnerProductSpace ℝ E] {W : Subspace ℝ E} (hw : ∀ (w : E), w ∈ W → ⟪w, w⟫_ℝ = 0) (v : E) (hv : v ∈ Wᗮ) :

Reflection in a subspace is the negation when restricted to the orthogonal complement of the subspace.

theorem reflection_mem_subspace_eq_self {E : Type u_1} [NormedAddCommGroup E] [InnerProductSpace ℝ E] {W : Subspace ℝ E} (hw : ∀ (w : E), w ∈ W → ⟪w, w⟫_ℝ = 0) (v : E) (hv : v ∈ W) :

Reflection in a subspace is the identity when restricted to the subspace.

theorem reflection_mem_orthogonal_eq_neg {E : Type u_1} [NormedAddCommGroup E] [InnerProductSpace ℝ E] {W : Subspace ℝ E} (hw : ∀ (w : E), w ∈ W → ⟪w, w⟫_ℝ = 0) (v : E) (hv : v ∈ Wᗮ) :

Reflection in a subspace is the negation when restricted to the orthogonal complement of the subspace.

theorem reflection_mem_subspace_orthogonal_eq_self {E : Type u_1} [NormedAddCommGroup E] [InnerProductSpace ℝ E] {W : Subspace ℝ E} (hw : ∀ (w : E), w ∈ W → ⟪w, w⟫_ℝ = 0) (v : E) (hv : v ∈ Wᗮ) :

Reflection in a subspace is the identity when restricted to the orthogonal complement of the subspace.

theorem reflection_mem_orthogonal_subspace_eq_neg {E : Type u_1} [NormedAddCommGroup E] [InnerProductSpace ℝ E] {W : Subspace ℝ E} (hw : ∀ (w : E), w ∈ W → ⟪w, w⟫_ℝ = 0) (v : E) (hv : v ∈ Wᗮ) :

Reflection in a subspace is the negation when restricted to the orthogonal complement of the subspace.

theorem reflection_mem_orthogonal_eq_self {E : Type u_1} [NormedAddCommGroup E] [InnerProductSpace ℝ E] {W : Subspace ℝ E} (hw : ∀ (w : E), w ∈ W → ⟪w, w⟫_ℝ = 0) (v : E) (hv : v 

Attempt failure.

---24/100---
For theorem LinearIsometryEquiv.reflections_generate_dim_aux in Mathlib/Analysis/InnerProductSpace/Projection.lean:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ℝ F] {n : ℕ}
    (φ : F ≃ₗᵢ[ℝ] F) (hn : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ ≤ n) :
    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod 


Original valid proof:
:= by
  induction' n with n IH generalizing φ
  · 
    refine ⟨[], rfl.le, show φ = 1 from ?_⟩
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  · 
    let W := ker (ContinuousLinearMap.id ℝ F - φ)
    have hW : ∀ w ∈ W, φ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ℝ Wᗮ ≤ n
    · obtain ⟨V, hV₁, hV₂⟩ := IH φ hn'
      exact ⟨V, hV₁.trans n.le_succ, hV₂⟩
    haveI : Nontrivial Wᗮ := nontrivial_of_finrank_pos (by omega : 0 < finrank ℝ Wᗮ)
    obtain ⟨v, hv⟩ := exists_ne (0 : Wᗮ)
    have hφv : φ v ∈ Wᗮ := by
      intro w hw
      rw [← hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ∉ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - φ v
    let ρ := reflection (ℝ ∙ x)ᗮ
    let V := ker (ContinuousLinearMap.id ℝ F - φ.trans ρ)
    have hV : ∀ w, ρ (φ w) = w → w ∈ V := by
      intro w hw
      change w - ρ (φ w) = 0
      rw [sub_eq_zero, hw]
    have H₂V : W ≤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hφv _ hw
    have H₁V : (v : F) ∈ V := by
      apply hV
      have : ρ v = φ v := reflection_sub (φ.norm_map v).symm
      rw [← this]
      exact reflection_reflection _ _
    have : finrank ℝ Vᗮ ≤ n := by
      change finrank ℝ Wᗮ ≤ n + 1 at hn
      have : finrank ℝ W + 1 ≤ finrank ℝ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ⟨H₂V, v, H₁V, hv'⟩)
      have : finrank ℝ V + finrank ℝ Vᗮ = finrank ℝ F := V.finrank_add_finrank_orthogonal
      have : finrank ℝ W + finrank ℝ Wᗮ = finrank ℝ F := W.finrank_add_finrank_orthogonal
      omega
    obtain ⟨l, hl, hφl⟩ := IH (ρ * φ) this
    refine ⟨x::l, Nat.succ_le_succ hl, ?_⟩
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (ρ * ·) hφl
    dsimp only at this
    rwa [← mul_assoc, reflection_mul_reflection, one_mul] at this


Verifying proof (Commit d61c95e1653dffe3f92c8927a905826929f50bce):
∧
      ∀ v ∈ l, ∃ w ∈ ker (ContinuousLinearMap.id ℝ F - φ)ᗮ, v = w - φ w := by
  induction' n with n IH generalizing φ
  · refine' ⟨[], rfl.le, rfl, fun v hv => _⟩
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      rwa [Nat.zero_eq, le_zero_iff, finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  · 
    let W := ker (ContinuousLinearMap.id ℝ F - φ)
    have hW : ∀ w ∈ W, φ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ℝ Wᗮ ≤ n
    · obtain ⟨V, hV₁, hV₂, hV₃⟩ := IH φ hn'
      exact ⟨V, hV₁.trans n.le_succ, hV₂, hV₃⟩
    haveI : Nontrivial Wᗮ := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank ℝ Wᗮ)
    obtain ⟨v, hv⟩ := exists_ne (0 : Wᗮ)
    have hφv : φ v ∈ Wᗮ := by
      intro w hw
      rw [← hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ∉ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - φ v
    let ρ := reflection (ℝ ∙ x)ᗮ
    let V := ker (ContinuousLinearMap.id ℝ F - φ.trans ρ)
    have hV : ∀ w, ρ (φ w) = w → w ∈ V := by
      intro w hw
      change w - ρ (φ w) = 0
      rw [sub_eq_zero, hw]
    have H₂V : W ≤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hφv _ hw
    have H₁V : (v : F) ∈ V := by
      apply hV
      have : ρ v = φ v := reflection_sub (φ.norm_map v).symm
      rw [← this]
      exact reflection_reflection _ _
    have : finrank ℝ Vᗮ ≤ n := by
      change finrank ℝ Wᗮ ≤ n + 1 at hn
      have : finrank ℝ W + 1 ≤ finrank ℝ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ⟨H₂V, v, H₁V, hv'⟩)
      have : finrank ℝ V + finrank ℝ Vᗮ = finrank ℝ F := V.finrank_add_finrank_orthogonal
      have : finrank ℝ W + finrank ℝ Wᗮ = finrank ℝ F := W.finrank_add_finrank_orthogonal
      linarith
    obtain ⟨l, hl, hφl, hVl⟩ := IH (ρ * φ) this
    refine' ⟨x::l, Nat.succ_le_succ hl, hφl, fun v hv => _⟩
    have hv' : v ∈ ker (ContinuousLinearMap.id ℝ F - φ.trans ρ) := by
      rw [hVl v hv]
      exact H₁V
    have : ρ v = v - φ v := by
      apply hV
      rw [hφl]
      exact reflection_mem_subspace_eq_self _
    refine' ⟨v - φ v, _, _⟩
    · rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hφv _ hv'
    · rw [this, sub_sub_sub_cancel_right]

## 2022-06-20

### New commits

- 0000000
...

## 2022-06-19

### New commits

- 0000000
...

## 2022-06-18

### New commits

- 0000000
...

## 2022-06-17

### New commits

- 0000000
...

## 2022-06-16

### New commits

- 0000000
...

## 2022-06-15

### New commits

- 0000000
...

## 2022-06-14

### New commits

- 0000000
...

## 2022-06-13

### New commits

- 0000000
...

## 2022-06-12

### New commits

- 0000000
...

## 2022-06-11

### New commits

- 0000000
...

## 2022-06-10

### New commits

- 0000000
...

## 2022-06-09

### New commits

- 0000000
...

## 2022-06-08

### New commits

- 0000000
...

## 2022-06-07

### New commits

- 0000000
...

## 2022-06-06

### New commits

- 0000000
...

## 2022-06-05

### New commits

- 0000000
...

## 2022-06-04

### New commits

- 0000000
...

## 2022-06-03

### New commits

- 0000000
...

## 2022-06-02

### New commits

- 0000000
...

## 2022-06-01

### New commits

- 0000000
...

## 2022-05-31

### New commits

- 0000000
...

## 2022-05-30

### New commits

- 0000000
...

## 2022-05-29

### New commits

- 0000000
...

## 2022-05-28

### New commits

- 0000000
...

## 2022-05-27

### New commits

- 0000000
...

## 2022-05-26

### New commits

- 00

Attempt failure.

---25/100---
For theorem LinearIsometryEquiv.reflections_generate_dim_aux in Mathlib/Analysis/InnerProductSpace/Projection.lean:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ℝ F] {n : ℕ}
    (φ : F ≃ₗᵢ[ℝ] F) (hn : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ ≤ n) :
    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod 


Original valid proof:
:= by
  induction' n with n IH generalizing φ
  · 
    refine ⟨[], rfl.le, show φ = 1 from ?_⟩
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  · 
    let W := ker (ContinuousLinearMap.id ℝ F - φ)
    have hW : ∀ w ∈ W, φ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ℝ Wᗮ ≤ n
    · obtain ⟨V, hV₁, hV₂⟩ := IH φ hn'
      exact ⟨V, hV₁.trans n.le_succ, hV₂⟩
    haveI : Nontrivial Wᗮ := nontrivial_of_finrank_pos (by omega : 0 < finrank ℝ Wᗮ)
    obtain ⟨v, hv⟩ := exists_ne (0 : Wᗮ)
    have hφv : φ v ∈ Wᗮ := by
      intro w hw
      rw [← hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ∉ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - φ v
    let ρ := reflection (ℝ ∙ x)ᗮ
    let V := ker (ContinuousLinearMap.id ℝ F - φ.trans ρ)
    have hV : ∀ w, ρ (φ w) = w → w ∈ V := by
      intro w hw
      change w - ρ (φ w) = 0
      rw [sub_eq_zero, hw]
    have H₂V : W ≤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hφv _ hw
    have H₁V : (v : F) ∈ V := by
      apply hV
      have : ρ v = φ v := reflection_sub (φ.norm_map v).symm
      rw [← this]
      exact reflection_reflection _ _
    have : finrank ℝ Vᗮ ≤ n := by
      change finrank ℝ Wᗮ ≤ n + 1 at hn
      have : finrank ℝ W + 1 ≤ finrank ℝ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ⟨H₂V, v, H₁V, hv'⟩)
      have : finrank ℝ V + finrank ℝ Vᗮ = finrank ℝ F := V.finrank_add_finrank_orthogonal
      have : finrank ℝ W + finrank ℝ Wᗮ = finrank ℝ F := W.finrank_add_finrank_orthogonal
      omega
    obtain ⟨l, hl, hφl⟩ := IH (ρ * φ) this
    refine ⟨x::l, Nat.succ_le_succ hl, ?_⟩
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (ρ * ·) hφl
    dsimp only at this
    rwa [← mul_assoc, reflection_mul_reflection, one_mul] at this


Verifying proof (Commit 7dc162787d2a79bf721a83a87f641ace70251b17):
∧
      ∀ v ∈ l, ∃ w ∈ ker (ContinuousLinearMap.id ℝ F - φ)ᗮ, v = w - φ w := by
  induction' n with n IH generalizing φ
  · refine' ⟨[], rfl.le, rfl, fun v hv => _⟩
    have : ker (ContinuousLinearMap.id ℝ F - φ) = ⊤ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  · 
    let W := ker (ContinuousLinearMap.id ℝ F - φ)
    have hW : ∀ w ∈ W, φ w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank ℝ Wᗮ ≤ n
    · obtain ⟨V, hV₁, hV₂, hV₃⟩ := IH φ hn'
      exact ⟨V, hV₁.trans n.le_succ, hV₂, fun v hv => hV₃ v hv⟩
    haveI : Nontrivial Wᗮ := nontrivial_of_finrank_pos (by omega : 0 < finrank ℝ Wᗮ)
    obtain ⟨v, hv⟩ := exists_ne (0 : Wᗮ)
    have hφv : φ v ∈ Wᗮ := by
      intro w hw
      rw [← hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) ∉ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - φ v
    let ρ := reflection (ℝ ∙ x)ᗮ
    let V := ker (ContinuousLinearMap.id ℝ F - φ.trans ρ)
    have hV : ∀ w, ρ (φ w) = w → w ∈ V := by
      intro w hw
      change w - ρ (φ w) = 0
      rw [sub_eq_zero, hw]
    have H₂V : W ≤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hφv _ hw
    have H₁V : (v : F) ∈ V := by
      apply hV
      have : ρ v = φ v := reflection_sub (φ.norm_map v).symm
      rw [← this]
      exact reflection_reflection _ _
    have : finrank ℝ Vᗮ ≤ n := by
      change finrank ℝ Wᗮ ≤ n + 1 at hn
      have : finrank ℝ W + 1 ≤ finrank ℝ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 ⟨H₂V, v, H₁V, hv'⟩)
      have : finrank ℝ V + finrank ℝ Vᗮ = finrank ℝ F := V.finrank_add_finrank_orthogonal
      have : finrank ℝ W + finrank ℝ Wᗮ = finrank ℝ F := W.finrank_add_finrank_orthogonal
      omega
    obtain ⟨l, hl, hφl, hVl⟩ := IH (ρ * φ) this
    refine' ⟨x::l, Nat.succ_le_succ hl, _, fun v hv => _⟩
    · rw [List.map_cons, List.prod_cons]
      have := congr_arg (ρ * ·) hφl
      dsimp only at this
      rwa [← mul_assoc, reflection_mul_reflection, one_mul] at this
    · have hv' : v ∈ V := by
        rw [← hVl v hv]
        exact H₁V
      obtain ⟨w, hw, hv⟩ := hV v hv'
      refine' ⟨w, hw, _⟩
      rw [← hv, ← hVl v hv, ← hφl, List.prod_cons, mul_assoc, reflection_mul_reflection, one_mul]

## References #

- [J. M. Lee, Introduction to Topological Manifolds](https://www.math.washington.edu/~lee/Books/ltm/ltm.pdf)

## Tags #

reflection, orthogonal complement, dimension, isometry

theorem reflection_mem_subspace_eq_self {F : Type u_1} [NormedAddCommGroup F] [InnerProductSpace ℝ F] (W : Submodule ℝ F) (v : F) (hv : v ∈ W) :

Reflection of a vector in a subspace, defined to be the same asrefl if the vector is in the subspace.

theorem reflection_mem_subspace_eq_self_apply {F : Type u_1} [NormedAddCommGroup F] [InnerProductSpace ℝ F] (W : Submodule ℝ F) (v : F) (hv : v ∈ W) :

Reflection of a vector in a subspace, defined to be the same asrefl if the vector is in the subspace.

theorem reflection_mem_subspace_orthogonal_eq_self {F : Type u_1} [NormedAddCommGroup F] [InnerProductSpace ℝ F] (W : Submodule ℝ F) (v : F) (hv : v ∈ W) :

Reflection of a vector in a subspace, defined to be the same asrefl if the vector is in the subspace.

theorem reflection_mem_subspace_orthogonal_eq_self_apply {F : Type u_1} [NormedAddCommGroup F] [InnerProductSpace ℝ F] (W : Submodule ℝ F) (v : F) (hv : v ∈ W) :

Reflection of a vector in a subspace, defined to be the same asrefl if the vector is in the subspace.

theorem reflection_mem_subspace_orthogonal_eq_self_apply_apply {F : Type u_1} [NormedAddCommGroup F] [InnerProductSpace ℝ F] (W : Submodule ℝ F) (v : F) (hv : v ∈ W) :

Reflection of a vector in a subspace, defined to be the same asrefl if the vector is in the subspace.

theorem reflection_mem_subspace_orthogonal_eq_self_apply_apply_apply {F : Type u_1} [NormedAddCommGroup F] [InnerProductSpace ℝ F] (W : Submodule ℝ F) (v : F) (hv : v ∈ W) :

Reflection of a vector in a subspace, defined to be the same asrefl if the vector is in the subspace.

theorem reflection_mem_subspace_orthogonal_eq_self_apply_apply_apply_apply {F : Type u_1} [NormedAddCommGroup F] [InnerProductSpace ℝ F] (W : Submodule ℝ F) (v : F) (hv : v ∈ W) :

Reflection of a vector in a subspace, defined to be the same asrefl if the vector is in the subspace.

theorem reflection_mem_subspace_orthogonal_eq_self_apply_apply_apply_apply_apply {F : Type u_1} [NormedAddCommGroup F] [InnerProductSpace ℝ F] (W : Submodule ℝ F) (v : F) (hv : v ∈ W) :

Reflection of a vector in a subspace, defined to be the same asrefl if the vector is

Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean - 2024-09-07 12:48:17.359633.
---26/100---
For theorem integrable_one_add_norm in Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean:
theorem integrable_one_add_norm {r : ℝ} (hnr : (finrank ℝ E : ℝ) < r) :
    Integrable (fun x ↦ (1 + ‖x‖) ^ (-r)) μ 


Original valid proof:
:= by
  constructor
  · measurability
  have : (∫⁻ a : E, ‖(1 + ‖a‖) ^ (-r)‖₊ ∂μ) = ∫⁻ a : E, ENNReal.ofReal ((1 + ‖a‖) ^ (-r)) ∂μ :=
    lintegral_nnnorm_eq_of_nonneg fun _ => rpow_nonneg (by positivity) _
  rw [HasFiniteIntegral, this]
  exact finite_integral_one_add_norm hnr


Verifying proof (Commit 54daa04dd4fe92d1b3b2a82be4c246b43c601cab):
 := by
  constructor
  · apply Measurable.aestronglyMeasurable (by fun_prop)
  have : (∫⁻ a : E, ‖(1 + ‖a‖) ^ (-r)‖₊ ∂μ) = ∫⁻ a : E, ENNReal.ofReal ((1 + ‖a‖) ^ (-r)) ∂μ :=
    lintegral_nnnorm_eq_of_nonneg fun _ => rpow_nonneg (by positivity) _
  rw [HasFiniteIntegral, this]
  exact finite_integral_one_add_norm hnr

## 1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.

Attempt failure.

Working on Mathlib/CategoryTheory/Preadditive/HomOrthogonal.lean - 2024-09-07 12:48:32.263026.
---27/100---
For theorem CategoryTheory.HomOrthogonal.equiv_of_iso in Mathlib/CategoryTheory/Preadditive/HomOrthogonal.lean:
theorem equiv_of_iso (o : HomOrthogonal s) {α β : Type} [Finite α] [Finite β] {f : α → ι}
    {g : β → ι} (i : (⨁ fun a => s (f a)) ≅ ⨁ fun b => s (g b)) :
    ∃ e : α ≃ β, ∀ a, g (e a) = f a 


Original valid proof:
:= by
  refine ⟨Equiv.ofPreimageEquiv ?_, fun a => Equiv.ofPreimageEquiv_map _ _⟩
  intro c
  apply Nonempty.some
  apply Cardinal.eq.1
  cases nonempty_fintype α; cases nonempty_fintype β
  simp only [Cardinal.mk_fintype, Nat.cast_inj]
  exact
    Matrix.square_of_invertible (o.matrixDecomposition i.inv c) (o.matrixDecomposition i.hom c)
      (by
        rw [← o.matrixDecomposition_comp]
        simp)
      (by
        rw [← o.matrixDecomposition_comp]
        simp)


Verifying proof (Commit 9b5d788d575748c82ffdfc08ef4aaf0a3c6023f0):
∧ ∀ b, f (e.symm b) = g b := by
  refine ⟨Equiv.ofPreimageEquiv ?_, fun a => ⟨Equiv.ofPreimageEquiv_map _ _, _⟩⟩
  intro c
  apply Nonempty.some
  apply Cardinal.eq.1
  cases nonempty_fintype α; cases nonempty_fintype β
  simp only [Cardinal.mk_fintype, Nat.cast_inj]
  exact
    Matrix.square_of_invertible (o.matrixDecomposition i.inv c) (o.matrixDecomposition i.hom c)
      (by
        rw [← o.matrixDecomposition_comp]
        simp)
      (by
        rw [← o.matrixDecomposition_comp]
        simp)

#### Johan Commelin (Jun 01 2020 at 10:00):

@Mario Carneiro I think you're right.

#### Johan Commelin (Jun 01 2020 at 10:00):

I'm not sure what the best way to fix this is.

#### Johan Commelin (Jun 01 2020 at 10:01):

I guess we could add a lemma that says that if you have a square matrix, and you know that it's invertible, then you can construct an inverse.

#### Johan Commelin (Jun 01 2020 at 10:01):

And then we could prove that lemma in a way that doesn't depend on the type of the matrix.

#### Johan Commelin (Jun 01 2020 at 10:02):

I guess we could also add a lemma that says that if you have a square matrix, and you know that it's invertible, then you can construct an inverse.

#### Johan Commelin (Jun 01 2020 at 10:02):

And then we could prove that lemma in a way that doesn't depend on the type of the matrix.

#### Johan Commelin (Jun 01 2020 at 10:02):

(I'm not sure if that's a good idea)

#### Johan Commelin (Jun 01 2020 at 10:03):

@Mario Carneiro I think you're right.

#### Johan Commelin (Jun 01 2020 at 10:03):

I'm not sure what the best way to fix this is.

#### Johan Commelin (Jun 01 2020 at 10:03):

I guess we could add a lemma that says that if you have a square matrix, and you know that it's invertible, then you can construct an inverse.

#### Johan Commelin (Jun 01 2020 at 10:03):

And then we could prove that lemma in a way that doesn't depend on the type of the matrix.

#### Johan Commelin (Jun 01 2020 at 10:03):

(I'm not sure if that's a good idea)

#### Johan Commelin (Jun 01 2020 at 10:03):

@Mario Carneiro I think you're right.

#### Johan Commelin (Jun 01 2020 at 10:03):

I'm not sure what the best way to fix this is.

#### Johan Commelin (Jun 01 2020 at 10:03):

I guess we could add a lemma that says that if you have a square matrix, and you know that it's invertible, then you can construct an inverse.

#### Johan Commelin (Jun 01 2020 at 10:03):

And then we could prove that lemma in a way that doesn't depend on the type of the matrix.

#### Johan Commelin (Jun 01 2020 at 10:03):

(I'm not sure if that's a good idea)

#### Johan Commelin (Jun 01 2020 at 10:04):

@Mario Carneiro I think you're right.

#### Johan Commelin (Jun 01 2020 at 10:04):

I'm not sure what the best way to fix this is.

#### Johan Commelin (Jun 01 2020 at 10:04):

I guess we could add a lemma that says that if you have a square matrix, and you know that it's invertible, then you can construct an inverse.

#### Johan Commelin (Jun 01 2020 at 10:04):

And then we could prove that lemma in a way that doesn't depend on the type of the matrix.

#### Johan Commelin (Jun 01 2020 at 10:04):

(I'm not sure if that's a good idea)

#### Johan Commelin (Jun 01 2020 at 10:04):

@Mario Carneiro I think you're right.

#### Johan Commelin (Jun 01 2020 at 10:04):

I'm not sure what the best way to fix this is.

#### Johan Commelin (Jun 01 2020 at 10:04):

I guess we could add a lemma that says that if you have a square matrix, and you know that it's invertible, then you can construct an inverse.

#### Johan Commelin (Jun 01 2020 at 10:04):

And then we could prove that lemma in a way that doesn't depend on the type of the matrix.

#### Johan Commelin (Jun 01 2020 at 10:04):

(I'm not sure if that's a good idea)

#### Johan Commelin (Jun 01 2020 at 10:04):

@Mario Carneiro I think you're right.

#### Johan Commelin (Jun 01 2020 at 10:04):

I'm not sure what the best way to fix this is.

#### Johan Commelin (Jun 01 2020 at 10:04):

I guess we could add a lemma that says that if you have a square matrix, and you know that it's invertible, then you can construct an inverse.

#### Johan Commelin (Jun 01 2020 at 10:04):

And then we could prove that lemma in a way that doesn't depend on the type of the matrix.

#### Johan Commelin (Jun 01 2020 at 10:04):

(I'm not sure if that's a good idea)

#### Johan Commelin (Jun 01 2020 at 10:04):

@Mario Carneiro I think you're right.

#### Johan Commelin (Jun 01 2020 at 10:04):

I'm not sure what the best way to fix this is.

#### Johan Commelin (Jun 01 2020 at 10:04):

I guess we could add a lemma that says that if you have a square matrix, and you know that it's invertible, then you can construct an inverse.

#### Johan Commelin (Jun 01 2020 at 10:04):

And then we could prove that lemma in a way that doesn't depend on the type of the matrix.

#### Johan Commelin (Jun 01 2020 at 10:04):

(I'm not sure if that's a good idea)

#### Johan Commelin (Jun 01 2020 at 10:04):

@Mario Carneiro I think you're right.

#### Johan Commelin (Jun 01 2020 at 10:04):

I'm not sure what the best way to fix this is.

#### Johan Commelin (Jun 01 2020 at 10:04):

I guess we could add a lemma that says that if you have a square matrix, and you know that it's invertible, then you can construct an inverse.

#### Johan Commelin (Jun 01 2020 at 10:0

Attempt failure.

Working on Mathlib/Combinatorics/Schnirelmann.lean - 2024-09-07 12:48:41.346051.
---28/100---
For theorem schnirelmannDensity_le_of_not_mem in Mathlib/Combinatorics/Schnirelmann.lean:
lemma schnirelmannDensity_le_of_not_mem {k : ℕ} (hk : k ∉ A) :
    schnirelmannDensity A ≤ 1 - (k⁻¹ : ℝ) 


Original valid proof:
:= by
  rcases k.eq_zero_or_pos with rfl | hk'
  · simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [← one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  gcongr
  rw [← Nat.cast_pred hk', Nat.cast_le]
  suffices (Ioc 0 k).filter (· ∈ A) ⊆ Ioo 0 k from (card_le_card this).trans_eq (by simp)
  rw [← Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _


Verifying proof (Commit 441b6cef620844aa6bcf947d63af335383e5dfdf):
 := by
  rcases k.eq_zero_or_pos with rfl | hk'
  · simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [← one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  apply div_le_div_of_le (Nat.cast_nonneg _)
  rw [← Nat.cast_pred hk', Nat.cast_le]
  suffices : (Ioc 0 k).filter (· ∈ A) ⊆ Ioo 0 k; exact (card_le_of_subset this).trans_eq (by simp)
  rw [← Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _

####  Yakov Pechersky (May 02 2021 at 15:00):

I'm not sure if this is a good example, but I'm not sure how to fix the following:
import data.real.basic

lemma schnirelmannDensity_le_of_not_mem {k : ℕ} (hk : k ∉ A) :
    schnirelmannDensity A ≤ 1 - (k⁻¹ : ℝ) := by
  rcases k.eq_zero_or_pos with rfl | hk'
  · simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [← one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  apply div_le_div_of_le (Nat.cast_nonneg _)
  rw [← Nat.cast_pred hk', Nat.cast_le]
  suffices : (Ioc 0 k).filter (· ∈ A) ⊆ Ioo 0 k; exact (card_le_of_subset this).trans_eq (by simp)
  rw [← Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _

####  Yakov Pechersky (May 02 2021 at 15:01):

I'm not sure if this is a good example, but I'm not sure how to fix the following:
import data.real.basic

lemma schnirelmannDensity_le_of_not_mem {k : ℕ} (hk : k ∉ A) :
    schnirelmannDensity A ≤ 1 - (k⁻¹ : ℝ) := by
  rcases k.eq_zero_or_pos with rfl | hk'
  · simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [← one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  apply div_le_div_of_le (Nat.cast_nonneg _)
  rw [← Nat.cast_pred hk', Nat.cast_le]
  suffices : (Ioc 0 k).filter (· ∈ A) ⊆ Ioo 0 k; exact (card_le_of_subset this).trans_eq (by simp)
  rw [← Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _

####  Yakov Pechersky (May 02 2021 at 15:02):

I'm not sure if this is a good example, but I'm not sure how to fix the following:
import data.real.basic

lemma schnirelmannDensity_le_of_not_mem {k : ℕ} (hk : k ∉ A) :
    schnirelmannDensity A ≤ 1 - (k⁻¹ : ℝ) := by
  rcases k.eq_zero_or_pos with rfl | hk'
  · simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [← one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  apply div_le_div_of_le (Nat.cast_nonneg _)
  rw [← Nat.cast_pred hk', Nat.cast_le]
  suffices : (Ioc 0 k).filter (· ∈ A) ⊆ Ioo 0 k; exact (card_le_of_subset this).trans_eq (by simp)
  rw [← Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _

####  Yakov Pechersky (May 02 2021 at 15:02):

I'm not sure if this is a good example, but I'm not sure how to fix the following:
import data.real.basic

lemma schnirelmannDensity_le_of_not_mem {k : ℕ} (hk : k ∉ A) :
    schnirelmannDensity A ≤ 1 - (k⁻¹ : ℝ) := by
  rcases k.eq_zero_or_pos with rfl | hk'
  · simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [← one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  apply div_le_div_of_le (Nat.cast_nonneg _)
  rw [← Nat.cast_pred hk', Nat.cast_le]
  suffices : (Ioc 0 k).filter (· ∈ A) ⊆ Ioo 0 k; exact (card_le_of_subset this).trans_eq (by simp)
  rw [← Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _

####  Yakov Pechersky (May 02 2021 at 15:02):

I'm not sure if this is a good example, but I'm not sure how to fix the following:
import data.real.basic

lemma schnirelmannDensity_le_of_not_mem {k : ℕ} (hk : k ∉ A) :
    schnirelmannDensity A ≤ 1 - (k⁻¹ : ℝ) := by
  rcases k.eq_zero_or_pos with rfl | hk'
  · simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [← one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  apply div_le_div_of_le (Nat.cast_nonneg _)
  rw [← Nat.cast_pred hk', Nat.cast_le]
  suffices : (Ioc 0 k).filter (· ∈ A) ⊆ Ioo 0 k; exact (card_le_of_subset this).trans_eq (by simp)
  rw [← Ioo_insert_right hk', filter_insert, if_neg hk]
  exact filter_subset _ _

####  Yakov Pechersky (May 02 2021 at 15:02):

I'm not sure if this is a good example, but I'm not sure how to fix the following:
import data.real.basic

lemma schnirelmannDensity_le_of_not_mem {k : ℕ} (hk : k ∉ A) :
    schnirelmannDensity A ≤ 1 - (k⁻¹ : ℝ) := by
  rcases k.eq_zero_or_pos with rfl | hk'
  · simpa using schnirelmannDensity_le_one
  apply schnirelmannDensity_le_of_le k hk'.ne'
  rw [← one_div, one_sub_div (Nat.cast_pos.2 hk').ne']
  apply div_le_div_of_le (Nat.cast_nonneg _)
  rw

Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Compression/UV.lean - 2024-09-07 12:48:47.813709.
---29/100---
For theorem UV.shadow_compression_subset_compression_shadow in Mathlib/Combinatorics/SetFamily/Compression/UV.lean:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) 


Original valid proof:
:= by
  set 𝒜' := 𝓒 u v 𝒜
  suffices H : ∀ s ∈ ∂ 𝒜',
      s ∉ ∂ 𝒜 → u ⊆ s ∧ Disjoint v s ∧ (s ∪ v) \ u ∈ ∂ 𝒜 ∧ (s ∪ v) \ u ∉ ∂ 𝒜' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s ∈ 𝒜.shadow
    swap
    · obtain ⟨hus, hvs, h, _⟩ := H _ hs' hs
      exact Or.inr ⟨hs, _, h, compress_of_disjoint_of_le' hvs hus⟩
    refine Or.inl ⟨hs, ?_⟩
    rw [compress]
    split_ifs with huvs
    swap
    · exact hs
    rw [mem_shadow_iff] at hs'
    obtain ⟨t, Ht, a, hat, rfl⟩ := hs'
    have hav : a ∉ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v ≤ t := huvs.2.trans (erase_subset _ t)
    have ht : t ∈ 𝒜 := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a ∈ u
    · obtain ⟨b, hbv, Hcomp⟩ := huv a hau
      refine mem_shadow_iff_insert_mem.2 ⟨b, not_mem_sdiff_of_mem_right hbv, ?_⟩
      rw [← Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, ←
        erase_union_of_mem hau] at hsb
    · refine mem_shadow_iff.2
        ⟨(t ⊔ u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_⟩
      · rw [sup_eq_union, mem_sdiff, mem_union]
        exact ⟨Or.inl hat, hav⟩
      · rw [← erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hs𝒜' hs𝒜
  have m : ∀ y, y ∉ s → insert y s ∉ 𝒜 := fun y h a => hs𝒜 (mem_shadow_iff_insert_mem.2 ⟨y, h, a⟩)
  obtain ⟨x, _, _⟩ := mem_shadow_iff_insert_mem.1 hs𝒜'
  have hus : u ⊆ insert x s := le_of_mem_compression_of_not_mem ‹_ ∈ 𝒜'› (m _ ‹x ∉ s›)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have : (insert x s ∪ v) \ u ∈ 𝒜 := sup_sdiff_mem_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ∉ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‹Disjoint v u›.sdiff_eq_left
  have : x ∉ u := by
    intro hxu
    obtain ⟨y, hyv, hxy⟩ := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ∪ v) \ u ∪ erase u x) \ erase v y ∈ 𝒜 := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‹v \ u = v›]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) ‹x ∈ u›, erase_union_distrib,
      erase_insert ‹x ∉ s›, erase_eq_of_not_mem ‹x ∉ v›, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u ⊆ s := by rwa [← erase_eq_of_not_mem ‹x ∉ u›, ← subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine ⟨hus, hsv.symm, ⟨x, ?_, ?_⟩, ?_⟩
  · exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ⟨‹x ∉ s›, ‹x ∉ v›⟩)
  · rwa [← insert_sdiff_of_not_mem _ ‹x ∉ u›, ← insert_union]
  rintro ⟨w, hwB, hw𝒜'⟩
  have : v ⊆ insert w ((s ∪ v) \ u) :=
    (subset_sdiff.2 ⟨subset_union_right, hvu⟩).trans (subset_insert _ _)
  by_cases hwu : w ∈ u
  · obtain ⟨z, hz, hxy⟩ := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s ∪ v) \ u) ∈ 𝒜 := mem_of_mem_compression hw𝒜' ‹_› (aux huv)
    have : (insert w ((s ∪ v) \ u) ∪ erase u w) \ erase v z ∈ 𝒜 := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‹_›) ?_
      rw [← sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase ‹w ∈ u›,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ ‹z ∈ v›), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, ← Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu ∘ hwB ∘ mem_union_left _)
  have : (insert w ((s ∪ v) \ u) ∪ u) \ v ∈ 𝒜 :=
    sup_sdiff_mem_of_mem_compression ‹insert w ((s ∪ v) \ u) ∈ 𝒜'› ‹_›
      (disjoint_insert_right.2 ⟨‹_›, disjoint_sdiff⟩)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu ∘ hwB ∘ mem_union_right _), union_sdiff_cancel_right hsv]


Verifying proof (Commit 65f7857d510e130142dbb111786341d695ac399b):
have : (insert x s ∪ v) \ u ∈ 𝒜 := sup_sdiff_mem_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
    have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
    have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
    have hxv : x ∉ v := disjoint_right.1 hvs (mem_insert_self _ _)
    have : v \ u = v := ‹Disjoint v u›.sdiff_eq_left
    have : x ∉ u := by
      intro hxu
      obtain ⟨y, hyv, hxy⟩ := huv x hxu
      apply m y (disjoint_right.1 hsv hyv)
      have : ((insert x s ∪ v) \ u ∪ erase u x) \ erase v y ∈ 𝒜 := by
        refine'
          sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
            (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
        rw [union_sdiff_distrib, ‹v \ u = v›]
        exact (erase_subset _ _).trans (subset_union_right _ _)
      convert this using 1
      rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) ‹x ∈ u›, erase_union_distrib,
        erase_insert ‹x ∉ s›, erase_eq_of_not_mem ‹x ∉ v›, sdiff_erase (mem_union_right _ hyv),
        union_sdiff_cancel_right hsv]
    have hus : u ⊆ s := by rwa [← erase_eq_of_not_mem ‹x ∉ u›, ← subset_insert_iff]
    simp_rw [mem_shadow_iff_insert_mem]
    refine' ⟨hus, hsv.symm, ⟨x, _, _⟩, _⟩
    · exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 ⟨‹x ∉ s›, ‹x ∉ v›⟩)
    · rwa [← insert_sdiff_of_not_mem _ ‹x ∉ u›, ← insert_union]
    rintro ⟨w, hwB, hw𝒜'⟩
    have : v ⊆ insert w ((s ∪ v) \ u) :=
      (subset_sdiff.2 ⟨subset_union_right _ _, hvu⟩).trans (subset_insert _ _)
    by_cases hwu : w ∈ u
    · obtain ⟨z, hz, hxy⟩ := huv w hwu
      apply m z (disjoint_right.1 hsv hz)
      have : insert w ((s ∪ v) \ u) ∈ 𝒜 := mem_of_mem_compression hw𝒜' ‹_› (aux huv)
      have : (insert w ((s ∪ v) \ u) ∪ erase u w) \ erase v z ∈ 𝒜 := by
        refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans ‹_›) _
        rw [← sdiff_erase (mem_union_left _ <| hus hwu)]
        exact disjoint_sdiff
      convert this using 1
      rw [insert_union_comm, insert_erase ‹w ∈ u›,
        sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
        sdiff_erase (mem_union_right _ ‹z ∈ v›), union_sdiff_cancel_right hsv]
    · rw [mem_sdiff, ← not_imp, Classical.not_not] at hwB
      apply m w (hwu ∘ hwB ∘ mem_union_left _)
      have : (insert w ((s ∪ v) \ u) ∪ u) \ v ∈ 𝒜 :=
        sup_sdiff_mem_of_mem_compression ‹insert w ((s ∪ v) \ u) ∈ 𝒜'› ‹_›
          (disjoint_insert_right.2 ⟨‹_›, disjoint_sdiff⟩)
      convert this using 1
      rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
        insert_sdiff_of_not_mem _ (hwu ∘ hwB ∘ mem_union_right _), union_sdiff_cancel_right hsv]
  intro s hs𝒜' hs𝒜
  have m : ∀ y, y ∉ s → insert y s ∉ 𝒜 := fun y h a => hs𝒜 (mem_shadow_iff_insert_mem.2 ⟨y, h, a⟩)
  obtain ⟨x, _, _⟩ := mem_shadow_iff_insert_mem.1 hs𝒜'
  have hus : u ⊆ insert x s := le_of_mem_compression_of_not_mem ‹_ ∈ 𝒜'› (m _ ‹x ∉ s›)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have : (insert x s ∪ v) \ u ∈ 𝒜 := sup_sdiff_mem_of_mem_compression_of_not_mem ‹_› (m _ ‹x ∉ s›)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x ∉ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := ‹Disjoint v u›.sdiff_eq_left
  have : x ∉ u := by
    intro hxu
    obtain ⟨y, hyv, hxy⟩ := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s ∪ v) \ u ∪ erase u x) \ erase v y ∈ 𝒜 := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, ‹v \

Attempt failure. (Regular Expression Failure)

Working on Mathlib/Combinatorics/SimpleGraph/Operations.lean - 2024-09-07 12:48:47.828451.
---30/100---
For theorem SimpleGraph.adj_replaceVertex_iff_of_ne_left in Mathlib/Combinatorics/SimpleGraph/Operations.lean:
lemma adj_replaceVertex_iff_of_ne_left {w : V} (hw : w ≠ t) :
    (G.replaceVertex s t).Adj s w ↔ G.Adj s w 


Original valid proof:
:= by simp [replaceVertex, hw]


Verifying proof (Commit f61a485edf966de0b09bd70c1edc7f254cd1b0ae):
∨ w = t := by simp [hw]

The problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call is not able to prove the goal.

I think the problem is that the simp call is not able to prove the goal.

####  Mario Carneiro (May 01 2020 at 10:04):

I think the problem is that the simp call

Attempt failure.

Working on Mathlib/Computability/PartrecCode.lean - 2024-09-07 12:48:57.146217.
---31/100---
For theorem Nat.Partrec.Code.evaln_prim in Mathlib/Computability/PartrecCode.lean:
theorem evaln_prim : Primrec fun a : (ℕ × Code) × ℕ => evaln a.1.1 a.1.2 a.2 


Original valid proof:
:=
  have :
    Primrec₂ fun (_ : Unit) (n : ℕ) =>
      let a := ofNat (ℕ × Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to₂ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr_left fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      · simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, Nat.lt_succ_iff] at nk
      have hg :
        ∀ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) →
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k₁ c₁ n₁ hl
        simp [lup, List.getElem?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      · cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        · rfl
        cases evaln k cg n <;> rfl
      · cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        · rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      · cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        · rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        · rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      · have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        · rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to₂).of_eq
    fun ⟨⟨k, c⟩, n⟩ => by simp [evaln_map]


Verifying proof (Commit ad88a031b67d9f51d39379f0e5f82a31c1929202):
 :=
  have :
    Primrec₂ fun (_ : Unit) (n : ℕ) =>
      let a := ofNat (ℕ × Code) n
      (List.range a.1).map (evaln a.1 a.2) :=
    Primrec.nat_strong_rec _ (hG.comp Primrec.snd).to₂ fun _ p => by
      simp only [G, prod_ofNat_val, ofNat_nat, List.length_map, List.length_range,
        Nat.pair_unpair, Option.some_inj]
      refine List.map_congr fun n => ?_
      have : List.range p = List.range (Nat.pair p.unpair.1 (encode (ofNat Code p.unpair.2))) := by
        simp
      rw [this]
      generalize p.unpair.1 = k
      generalize ofNat Code p.unpair.2 = c
      intro nk
      cases' k with k'
      · simp [evaln]
      let k := k' + 1
      simp only [show k'.succ = k from rfl]
      simp? [Nat.lt_succ_iff] at nk says simp only [List.mem_range, lt_succ_iff] at nk
      have hg :
        ∀ {k' c' n},
          Nat.pair k' (encode c') < Nat.pair k (encode c) →
            lup ((List.range (Nat.pair k (encode c))).map fun n =>
              (List.range n.unpair.1).map (evaln n.unpair.1 (ofNat Code n.unpair.2))) (k', c') n =
            evaln k' c' n := by
        intro k₁ c₁ n₁ hl
        simp [lup, List.get?_range hl, evaln_map, Bind.bind]
      cases' c with cf cg cf cg cf cg cf <;>
        simp [evaln, nk, Bind.bind, Functor.map, Seq.seq, pure]
      · cases' encode_lt_pair cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf), hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cf n
        · rfl
        cases evaln k cg n <;> rfl
      · cases' encode_lt_comp cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lg)]
        cases evaln k cg n
        · rfl
        simp [hg (Nat.pair_lt_pair_right _ lf)]
      · cases' encode_lt_prec cf cg with lf lg
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases n.unpair.2
        · rfl
        simp only [decode_eq_ofNat, Option.some.injEq]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
        cases evaln k' _ _
        · rfl
        simp [hg (Nat.pair_lt_pair_right _ lg)]
      · have lf := encode_lt_rfind' cf
        rw [hg (Nat.pair_lt_pair_right _ lf)]
        cases' evaln k cf n with x
        · rfl
        simp only [decode_eq_ofNat, Option.some.injEq, Option.some_bind]
        cases x <;> simp [Nat.succ_ne_zero]
        rw [hg (Nat.pair_lt_pair_left _ k'.lt_succ_self)]
  (Primrec.option_bind
    (Primrec.list_get?.comp (this.comp (_root_.Primrec.const ())
      (Primrec.encode_iff.2 Primrec.fst)) Primrec.snd) Primrec.snd.to₂).of_eq
    fun ⟨⟨k, c⟩, n⟩ => by simp [evaln_map]

## 2021-01-11

### Added

## Added
Primrec.option_bind

theorem Primrec.option_bind {f : α → Option β} {g : α → β → Option γ} :
  Primrec f → Primrec₂ g → Primrec fun a => (f a).bind (g a)

## 2021-01-09

### Added

## Added
Primrec.list_get?

theorem Primrec.list_get? {f : α → List β} {g : α → β → Option γ} :
  Primrec f → Primrec₂ g → Primrec fun a => (f a).get? (g a)

## 2021-01-08

### Added

## Added
Primrec.option_map

theorem Primrec.option_map {f : α → Option β} {g : α → β → Option γ} :
  Primrec f → Primrec₂ g → Primrec fun a => (f a).map (g a)

## 2021-01-07

### Added

## Added
Primrec.option_bind

theorem Primrec.option_bind {f : α → Option β} {g : α → β → Option γ} :
  Primrec f → Primrec₂ g → Primrec fun a => (f a).bind (g a)

## 2021-01-06

### Added

## Added
Primrec.list_get?

theorem Primrec.list_get? {f : α → List β} {g : α → β → Option γ} :
  Primrec f → Primrec₂ g → Primrec fun a => (f a).get? (g a)

## 2021-01-05

### Added

## Added
Primrec.option_map

theorem Primrec.option_map {f : α → Option β} {g : α → β → Option γ} :
  Primrec f → Primrec₂ g → Primrec fun a => (f a).map (g a)

## 2021-01-04

### Added

## Added
Primrec.option_bind

theorem Primrec.option_bind {f : α → Option β} {g : α → β → Option γ} :
  Primrec f → Primrec₂ g → Primrec fun a => (f a).bind (g a)

## 2021-01-03

### Added

## Added
Primrec.list_get?

theorem Primrec.list_get? {f : α → List β} {g : α → β → Option γ} :
  Primrec f → Primrec₂ g → Primrec fun a => (f a).get? (g a)

## 2021-01-02

### Added

## Added
Primrec.option_map

theorem Primrec.option_map {f : α → Option β} {g : α → β → Option γ} :
  Primrec f → Primrec₂ g → Primrec fun a => (f a).map (g a)

## 2021-01-01

### Added

## Added
Primrec.option_bind

theorem Primrec.option_bind {f : α → Option β} {g : α → β → Option γ} :
  Primrec f → Primrec₂ g → Primrec fun a => (f a).bind (g a)

## 2020-12-31

### Added

## Added
Primrec.list_get?

theorem Primrec.list_get? {f : α → List β} {g : α → β → Option γ} :
  Primrec f → Primrec₂ g → Primrec fun a => (f a).get? (g a)

## 2020-12-30

### Added

## Added
Primrec.option_map

theorem Primrec.option_map {f : α → Option β} {g : α → β → Option γ} :
  Primrec f → Primrec₂ g → Primrec fun a => (f a).map (g a)

## 

Attempt failure.

Working on Mathlib/Computability/Primrec.lean - 2024-09-07 12:49:16.187403.
---32/100---
For theorem Primrec.nat_double in Mathlib/Computability/Primrec.lean:
theorem nat_double : Primrec (fun n : ℕ => 2 * n) 


Original valid proof:
:=
  nat_mul.comp (const _) Primrec.id


Verifying proof (Commit b912476b37f2ea41ee51af7e63439f4a769be095):
 :=
  nat_mul.comp₂ (const _) (const _)

####  Mario Carneiro (Mar 01 2021 at 05:00):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:00):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carneiro (Mar 01 2021 at 05:01):

I think the problem is that the first argument tocomp₂ is a function, not a term

####  Mario Carneiro (Mar 01 2021 at 05:01):

and the first argument toconst is a term, not a function

####  Mario Carne

Attempt failure.

Working on Mathlib/Data/Fin/Basic.lean - 2024-09-07 12:49:28.722913.
---33/100---
For theorem Fin.succ_ne_last_of_lt in Mathlib/Data/Fin/Basic.lean:
theorem succ_ne_last_of_lt {p i : Fin n} (h : i < p) : succ i ≠ last n 


Original valid proof:
:= by
  cases n
  · exact i.elim0
  · rw [succ_ne_last_iff, Ne, ext_iff]
    exact ((le_last _).trans_lt' h).ne


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  cases n
  · exact i.elim0
  · rw [succ_ne_last_iff]
    exact ((le_last _).trans_lt' h).ne

####  Mario Carneiro (Mar 10 2021 at 16:00):

I'm not sure what the problem is, but the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:00):

I think the problem is that you're using the wrong version oftrans_lt'

####  Mario Carneiro (Mar 10 2021 at 16:00):

it's the one that takes a< and returns a \lt

####  Mario Carneiro (Mar 10 2021 at 16:01):

I think you wanttrans_lt

####  Mario Carneiro (Mar 10 2021 at 16:01):

which is the one that takes a\le and returns a \le

####  Mario Carneiro (Mar 10 2021 at 16:01):

and the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:01):

I'm not sure what the problem is, but the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:01):

I think the problem is that you're using the wrong version of
trans_lt'

####  Mario Carneiro (Mar 10 2021 at 16:01):

it's the one that takes a
< and returns a \lt

####  Mario Carneiro (Mar 10 2021 at 16:01):

I think you want
trans_lt

####  Mario Carneiro (Mar 10 2021 at 16:01):

which is the one that takes a
\le and returns a \le

####  Mario Carneiro (Mar 10 2021 at 16:01):

and the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:02):

I'm not sure what the problem is, but the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:02):

I think the problem is that you're using the wrong version of
trans_lt'

####  Mario Carneiro (Mar 10 2021 at 16:02):

it's the one that takes a
< and returns a \lt

####  Mario Carneiro (Mar 10 2021 at 16:02):

I think you want
trans_lt

####  Mario Carneiro (Mar 10 2021 at 16:02):

which is the one that takes a
\le and returns a \le

####  Mario Carneiro (Mar 10 2021 at 16:02):

and the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:02):

I'm not sure what the problem is, but the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:02):

I think the problem is that you're using the wrong version of
trans_lt'

####  Mario Carneiro (Mar 10 2021 at 16:02):

it's the one that takes a
< and returns a \lt

####  Mario Carneiro (Mar 10 2021 at 16:02):

I think you want
trans_lt

####  Mario Carneiro (Mar 10 2021 at 16:02):

which is the one that takes a
\le and returns a \le

####  Mario Carneiro (Mar 10 2021 at 16:02):

and the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:02):

I'm not sure what the problem is, but the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:02):

I think the problem is that you're using the wrong version of
trans_lt'

####  Mario Carneiro (Mar 10 2021 at 16:02):

it's the one that takes a
< and returns a \lt

####  Mario Carneiro (Mar 10 2021 at 16:02):

I think you want
trans_lt

####  Mario Carneiro (Mar 10 2021 at 16:02):

which is the one that takes a
\le and returns a \le

####  Mario Carneiro (Mar 10 2021 at 16:02):

and the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:02):

I'm not sure what the problem is, but the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:02):

I think the problem is that you're using the wrong version of
trans_lt'

####  Mario Carneiro (Mar 10 2021 at 16:02):

it's the one that takes a
< and returns a \lt

####  Mario Carneiro (Mar 10 2021 at 16:02):

I think you want
trans_lt

####  Mario Carneiro (Mar 10 2021 at 16:02):

which is the one that takes a
\le and returns a \le

####  Mario Carneiro (Mar 10 2021 at 16:02):

and the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:02):

I'm not sure what the problem is, but the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:02):

I think the problem is that you're using the wrong version of
trans_lt'

####  Mario Carneiro (Mar 10 2021 at 16:02):

it's the one that takes a
< and returns a \lt

####  Mario Carneiro (Mar 10 2021 at 16:02):

I think you want
trans_lt

####  Mario Carneiro (Mar 10 2021 at 16:02):

which is the one that takes a
\le and returns a \le

####  Mario Carneiro (Mar 10 2021 at 16:02):

and the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:02):

I'm not sure what the problem is, but the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:02):

I think the problem is that you're using the wrong version of
trans_lt'

####  Mario Carneiro (Mar 10 2021 at 16:02):

it's the one that takes a
< and returns a \lt

####  Mario Carneiro (Mar 10 2021 at 16:02):

I think you want
trans_lt

####  Mario Carneiro (Mar 10 2021 at 16:02):

which is the one that takes a
\le and returns a \le

####  Mario Carneiro (Mar 10 2021 at 16:02):

and the proof is correct

####  Mario Carneiro (Mar 10 2021 at 16:02):

I'm not sure what the problem is, but the proof is correct

####  Mario Car

Attempt failure. (Regular Expression Failure)

Working on Mathlib/Data/Fin/Tuple/Basic.lean - 2024-09-07 12:49:28.737782.
---34/100---
For theorem Fin.isSome_find_iff in Mathlib/Data/Fin/Tuple/Basic.lean:
theorem isSome_find_iff :
    ∀ {n : ℕ} {p : Fin n → Prop} [DecidablePred p], (find p).isSome ↔ ∃ i, p i



Original valid proof:
  | 0, p, _ => iff_of_false (fun h ↦ Bool.noConfusion h) fun ⟨i, _⟩ ↦ Fin.elim0 i
  | n + 1, p, _ =>
    ⟨fun h ↦ by
      rw [Option.isSome_iff_exists] at h
      cases' h with i hi
      exact ⟨i, find_spec _ hi⟩, fun ⟨⟨i, hin⟩, hi⟩ ↦ by
      dsimp [find]
      cases' h : find fun i : Fin n ↦ p (i.castLT (Nat.lt_succ_of_lt i.2)) with j
      · split_ifs with hl
        · exact Option.isSome_some
        · have := (@isSome_find_iff n (fun x ↦ p (x.castLT (Nat.lt_succ_of_lt x.2))) _).2
              ⟨⟨i, lt_of_le_of_ne (Nat.le_of_lt_succ hin) fun h ↦ by cases h; exact hl hi⟩, hi⟩
          rw [h] at this
          exact this
      · simp⟩


Verifying proof (Commit b57ede590c8e21e71ba026c0b434dec2631ccd28):
  | 0, p, _ => iff_of_false (fun h ↦ Bool.noConfusion h) fun ⟨i, _⟩ ↦ Fin.elim0' i
  | n + 1, p, _ =>
    ⟨fun h ↦ by
      rw [Option.isSome_iff_exists] at h
      cases' h with i hi
      exact ⟨i, find_spec _ hi⟩, fun ⟨⟨i, hin⟩, hi⟩ ↦ by
      dsimp [find]
      cases' h : find fun i : Fin n ↦ p (i.castLt (Nat.lt_succ_of_lt i.2)) with j
      · split_ifs with hl
        · exact Option.isSome_some
        · have := (@isSome_find_iff n (fun x ↦ p (x.castLt (Nat.lt_succ_of_lt x.2))) _).2
              ⟨⟨i, lt_of_le_of_ne (Nat.le_of_lt_succ hin) fun h ↦ by cases h; exact hl hi⟩, hi⟩
          rw [h] at this
          exact this
      · simp⟩

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure what the problem is.

####  Kevin Buzzard (May 05 2020 at 10:30):

I'm not sure

Attempt failure.

Working on Mathlib/Data/Int/Order/Lemmas.lean - 2024-09-07 12:49:36.662988.
---35/100---
For theorem Int.eq_zero_of_abs_lt_dvd in Mathlib/Data/Int/Order/Lemmas.lean:
theorem eq_zero_of_abs_lt_dvd {m x : ℤ} (h1 : m ∣ x) (h2 : |x| < m) : x = 0 


Original valid proof:
:= by
  obtain rfl | hm := eq_or_ne m 0
  · exact Int.zero_dvd.1 h1
  rcases h1 with ⟨d, rfl⟩
  apply mul_eq_zero_of_right
  rw [← abs_lt_one_iff, ← mul_lt_iff_lt_one_right (abs_pos.mpr hm), ← abs_mul]
  exact lt_of_lt_of_le h2 (le_abs_self m)


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  by_cases hm : m = 0
  · subst m
    exact zero_dvd_iff.mp h1
  rcases h1 with ⟨d, rfl⟩
  apply mul_eq_zero_of_right
  rw [← abs_lt_one_iff, ← mul_lt_iff_lt_one_right (abs_pos.mpr hm), ← abs_mul]
  exact lt_of_lt_of_le h2 (le_abs_self m)

####  Eric Wieser (Jun 01 2020 at 14:04):

I think the problem is that the goal is|d| < 1, and the assumption is |x| < m, but the proof is using m = d.

####  Eric Wieser (Jun 01 2020 at 14:05):

I think the proof should be:
theorem eq_zero_of_abs_lt_dvd {m x : ℤ} (h1 : m ∣ x) (h2 : |x| < m) : x = 0  := by
  by_cases hm : m = 0
  · subst m
    exact zero_dvd_iff.mp h1
  rcases h1 with ⟨d, rfl⟩
  apply mul_eq_zero_of_right
  rw [← abs_lt_one_iff, ← mul_lt_iff_lt_one_right (abs_pos.mpr hm), ← abs_mul]
  exact lt_of_lt_of_le h2 (le_abs_self d)

####  Eric Wieser (Jun 01 2020 at 14:05):

(I'm not sure why the proof is usingd instead of x)

####  Eric Wieser (Jun 01 2020 at 14:06):

I'm not sure why the proof is using
d instead of x
Because the proof is usingx = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:06):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using
d instead of x
Because the proof is using
x = m * d, and the proof is using m = d

####  Eric Wieser (Jun 01 2020 at 14:07):

I'm not sure why the proof is using


Attempt failure.

Working on Mathlib/Data/NNRat/Lemmas.lean - 2024-09-07 12:49:41.234802.
---36/100---
For theorem NNRat.num_div_den in Mathlib/Data/NNRat/Lemmas.lean:
lemma num_div_den (q : ℚ≥0) : (q.num : ℚ≥0) / q.den = q 


Original valid proof:
:= by
  ext : 1
  rw [coe_div, coe_natCast, coe_natCast, num, ← Int.cast_natCast,
    Int.natAbs_of_nonneg (Rat.num_nonneg.2 q.cast_nonneg)]
  exact Rat.num_div_den q


Verifying proof (Commit bb997ebae7d037781f6e811e46f3f898622a1536):
 := by
  ext : 1
  rw [coe_div, coe_natCast, coe_natCast, num, ← Int.cast_natCast,
    Int.natAbs_of_nonneg (Rat.num_nonneg.2 q.prop)]
  exact Rat.num_div_den q

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 

Attempt failure.

Working on Mathlib/Data/Nat/Choose/Central.lean - 2024-09-07 12:49:46.190057.
---37/100---
For theorem Nat.four_pow_le_two_mul_self_mul_centralBinom in Mathlib/Data/Nat/Choose/Central.lean:
theorem four_pow_le_two_mul_self_mul_centralBinom :
    ∀ (n : ℕ) (_ : 0 < n), 4 ^ n ≤ 2 * n * centralBinom n



Original valid proof:
  | 0, pr => (Nat.not_lt_zero _ pr).elim
  | 1, _ => by norm_num [centralBinom, choose]
  | 2, _ => by norm_num [centralBinom, choose]
  | 3, _ => by norm_num [centralBinom, choose]
  | n + 4, _ =>
    calc
      4 ^ (n+4) ≤ (n+4) * centralBinom (n+4) := (four_pow_lt_mul_centralBinom _ le_add_self).le
      _ ≤ 2 * (n+4) * centralBinom (n+4) := by
        rw [mul_assoc]; refine Nat.le_mul_of_pos_left _ zero_lt_two


Verifying proof (Commit 9f6d33884de569540c527b667d1573e1b97e1347):
  | 0, pr => (Nat.not_lt_zero _ pr).elim
  | 1, _ => by norm_num [centralBinom, choose]
  | 2, _ => by norm_num [centralBinom, choose]
  | 3, _ => by norm_num [centralBinom, choose]
  | n + 4, _ =>
    calc
      4 ^ (n+4) ≤ (n+4) * centralBinom (n+4) := (four_pow_lt_mul_centralBinom _ le_add_self).le
      _ ≤ 2 * (n+4) * centralBinom (n+4) := by
        rw [mul_assoc]; refine' le_mul_of_pos_left zero_lt_two

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is, but I'm not sure I'd want to be in a position where I had to do that.

####  Eric Wieser (Jun 01 2020 at 14:00):

I'm not sure what the issue is

Attempt failure.

Working on Mathlib/Data/Nat/Factorization/Basic.lean - 2024-09-07 12:49:51.709729.
---38/100---
For theorem Nat.factors_count_eq in Mathlib/Data/Nat/Factorization/Basic.lean:
theorem factors_count_eq {n p : ℕ} : n.factors.count p = n.factorization p 


Original valid proof:
:= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  · simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization_def _ pp]
  apply _root_.le_antisymm
  · rw [le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    exact List.le_count_iff_replicate_sublist.mp le_rfl |>.subperm
  · rw [← Nat.lt_add_one_iff, lt_iff_not_ge, ge_iff_le,
      le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    intro h
    have := h.count_le p
    simp at this


Verifying proof (Commit 754ba19de1471fd928c4fa0cc102d1f06f90e902):
 := by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  · simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization_def _ pp]
  apply _root_.le_antisymm
  · rw [le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    exact List.le_count_iff_replicate_sublist.mp le_rfl |>.subperm
  · rw [← lt_add_one_iff, lt_iff_not_ge, ge_iff_le,
      le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    intro h
    have := h.count_le p
    simp at this

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03 2021 at 10:00):

I'm not sure what the issue is, but I'm not seeing anything in the diff that would cause the error.

####  Eric Wieser (May 03

Attempt failure.

---39/100---
For theorem Nat.factors_count_eq in Mathlib/Data/Nat/Factorization/Basic.lean:
theorem factors_count_eq {n p : ℕ} : n.factors.count p = n.factorization p 


Original valid proof:
:= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  · simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization_def _ pp]
  apply _root_.le_antisymm
  · rw [le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    exact List.le_count_iff_replicate_sublist.mp le_rfl |>.subperm
  · rw [← Nat.lt_add_one_iff, lt_iff_not_ge, ge_iff_le,
      le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    intro h
    have := h.count_le p
    simp at this


Verifying proof (Commit 8e91a9b411b4073ac3256f6caebb2b6107088e61):
 := by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  · simp [factorization, count]
  by_cases pp : p.Prime; swap
  · rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization, coe_mk, pp, if_true]
  rw [← PartENat.natCast_inj, padicValNat_def' pp.ne_one hn0,
    UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors pp hn0.ne']
  simp [factors_eq, pp]

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Mar 02 2021 at 10:00):

I

Attempt failure.

---40/100---
For theorem Nat.factorization_pow in Mathlib/Data/Nat/Factorization/Basic.lean:
theorem factorization_pow (n k : ℕ) : factorization (n ^ k) = k • n.factorization 


Original valid proof:
:= by
  induction' k with k ih; · simp
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [Nat.pow_succ, mul_comm, factorization_mul hn (pow_ne_zero _ hn), ih,
    add_smul, one_smul, add_comm]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  induction' k with k ih; · simp
  rcases eq_or_ne n 0 with (rfl | hn)
  · simp
  rw [Nat.pow_succ, mul_comm, factorization_mul hn (pow_ne_zero _ hn), ih, succ_eq_one_add,
    add_smul, one_smul]

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 03 2020 at 10:02):

I'm not sure what the

Attempt failure.

Working on Mathlib/Data/PNat/Xgcd.lean - 2024-09-07 12:50:24.064372.
---41/100---
For theorem PNat.gcdA'_coe in Mathlib/Data/PNat/Xgcd.lean:
theorem gcdA'_coe : (gcdA' a b : ℕ) = gcdW a b + gcdX a b 


Original valid proof:
:= by
  dsimp [gcdA', gcdX, gcdW, XgcdType.w]
  rw [add_right_comm]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  dsimp [gcdA', gcdX, gcdW, XgcdType.w]
  rw [Nat.succ_eq_add_one, Nat.succ_eq_add_one, add_right_comm, add_comm]

## 1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1

Attempt failure.

Working on Mathlib/Data/Seq/WSeq.lean - 2024-09-07 12:50:30.822317.
---42/100---
For theorem Stream'.WSeq.mem_of_mem_tail in Mathlib/Data/Seq/WSeq.lean:
theorem mem_of_mem_tail {s : WSeq α} {a} : a ∈ tail s → a ∈ s 


Original valid proof:
:= by
  intro h; have := h; cases' h with n e; revert s; simp only [Stream'.get]
  induction' n with n IH <;> intro s <;> induction' s using WSeq.recOn with x s s <;>
    simp <;> intro m e <;>
    injections
  · exact Or.inr m
  · exact Or.inr m
  · apply IH m
    rw [e]
    cases tail s
    rfl


Verifying proof (Commit 88f252d9ef6777980e9cb4396094e178f3ed4acb):
∨ a = x := by
  intro h; have := h; cases' h with n e; revert s
  induction' n with n IH <;> intro s <;> induction' s using WSeq.recOn' with x s s <;>
    simp <;> intro m e <;>
    injections
  · exact Or.inr m
  · exact Or.inr m
  · apply IH m
    rw [e]

####  Mario Carneiro (May 01 2020 at 10:00):

I think the problem is that you're not using the right induction principle. The induction principle for WSeq is
induction' s using WSeq.recOn' with x s s

which is a bit different from the usualinduction s.

####  Mario Carneiro (May 01 2020 at 10:01):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:01):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:01):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:01):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction principle for the coinductive type is
induction s using WSeq.recOn'

####  Mario Carneiro (May 01 2020 at 10:02):

The induction principle for the inductive type is
induction s with x s s

####  Mario Carneiro (May 01 2020 at 10:02):

and the induction

Attempt failure.

Working on Mathlib/Data/Set/Function.lean - 2024-09-07 12:50:41.096520.
---43/100---
For theorem Equiv.bijOn' in Mathlib/Data/Set/Function.lean:
lemma bijOn' (h₁ : MapsTo e s t) (h₂ : MapsTo e.symm t s) : BijOn e s t 


Original valid proof:
:=
  ⟨h₁, e.injective.injOn, fun b hb ↦ ⟨e.symm b, h₂ hb, apply_symm_apply _ _⟩⟩


Verifying proof (Commit ac36b28ef3759cb65a7f386f3b7e15ee0ac1b4c9):
 :=

- This page was last modified on 10 April 2015, at 10:00.
- This page has been accessed 1,010 times.
- Content is available under Attribution-Noncommercial-No Derivative Works 3.0 Unported unless otherwise noted.
- Privacy policy
- About Furman University MathWiki
- Disclaimers

Attempt failure.

Working on Mathlib/Data/Set/Pointwise/Finite.lean - 2024-09-07 12:50:48.961865.
---44/100---
For theorem Set.finite_mul in Mathlib/Data/Set/Pointwise/Finite.lean:
lemma finite_mul : (s * t).Finite ↔ s.Finite ∧ t.Finite ∨ s = ∅ ∨ t = ∅ 


Original valid proof:
:=
  finite_image2  (fun _ _ ↦ (mul_left_injective _).injOn)
    fun _ _ ↦ (mul_right_injective _).injOn


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 :=
  finite_image2  (fun _ _ ↦ (mul_left_injective _).injOn _)
    fun _ _ ↦ (mul_right_injective _).injOn _

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May 03 2020 at 17:00):

I'm not sure what the issue is.

####  Yakov Pechersky (May

Attempt failure.

---45/100---
For theorem Set.finite_mul in Mathlib/Data/Set/Pointwise/Finite.lean:
lemma finite_mul : (s * t).Finite ↔ s.Finite ∧ t.Finite ∨ s = ∅ ∨ t = ∅ 


Original valid proof:
:=
  finite_image2  (fun _ _ ↦ (mul_left_injective _).injOn)
    fun _ _ ↦ (mul_right_injective _).injOn


Verifying proof (Commit 0050ac58975fb70b2cce3bfd5ac6fdf88f1900a0):
 :=
  finite_image2 (fun _ _ ↦ (mul_left_injective _).injOn _)
    fun _ _ ↦ (mul_right_injective _).injOn _

####  Yakov Pechersky (May 01 2021 at 15:00):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15:01):

I'm not sure what the issue is, but the proof is not valid.

####  Yakov Pechersky (May 01 2021 at 15

Attempt failure.

Working on Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean - 2024-09-07 12:51:00.855642.
---46/100---
For theorem CircleDeg1Lift.translationNumber_mono in Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean:
theorem translationNumber_mono : Monotone τ 


Original valid proof:
:= fun f g h =>
  le_of_tendsto_of_tendsto' f.tendsto_translation_number₀ g.tendsto_translation_number₀ fun n => by
    gcongr; exact pow_mono h _ _


Verifying proof (Commit 746edd99decd559e5b12437d37d2a05ac880319f):
 := fun f g h =>
  le_of_tendsto_of_tendsto' f.tendsto_translation_number₀ g.tendsto_translation_number₀ fun _ ↦ by
    gcongr

####  Yury G. Kudryashov (Mar 14 2021 at 00:01):

I think that the problem is thath is not a function, so gcongr doesn't work.

####  Yury G. Kudryashov (Mar 14 2021 at 00:01):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G. Kudryashov (Mar 14 2021 at 00:02):

I'm not sure how to fix it.

####  Yury G

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Angle/Sphere.lean - 2024-09-07 12:51:15.953540.
---47/100---
For theorem Affine.Triangle.inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_circumcenter in Mathlib/Geometry/Euclidean/Angle/Sphere.lean:
theorem inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_circumcenter (t : Triangle ℝ P)
    {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂) (h₁₃ : i₁ ≠ i₃) (h₂₃ : i₂ ≠ i₃) :
    ((Real.Angle.tan (∡ (t.points i₁) (t.points i₂) (t.points i₃)))⁻¹ / 2) •
      o.rotation (π / 2 : ℝ) (t.points i₃ -ᵥ t.points i₁) +ᵥ
        midpoint ℝ (t.points i₁) (t.points i₃) = t.circumcenter 


Original valid proof:
:=
  Sphere.inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_center (t.mem_circumsphere _)
    (t.mem_circumsphere _) (t.mem_circumsphere _) (t.independent.injective.ne h₁₂)
    (t.independent.injective.ne h₁₃) (t.independent.injective.ne h₂₃)


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
∧
      ((Real.Angle.tan (∡ (t.points i₁) (t.points i₂) (t.points i₃)))⁻¹ / 2) •
        o.rotation (π / 2 : ℝ) (t.points i₃ -ᵥ t.points i₁) +ᵥ
          midpoint ℝ (t.points i₁) (t.points i₃) ∈
        sphere t.circumcenter t.circumradius :=
  Sphere.inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_center (t.mem_circumsphere _)
    (t.mem_circumsphere _) (t.mem_circumsphere _) (t.Independent.injective.ne h₁₂)
    (t.Independent.injective.ne h₁₃) (t.Independent.injective.ne h₂₃)

####  Yakov Pechersky (Jun 01 2020 at 00:01):

I'm not sure if this is the right way to do it, but I'm trying to prove the following:
import data.real.basic

lemma inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_center (h₁ : p₁ ∈ sphere c r)
  (h₂ : p₂ ∈ sphere c r) (h₃ : p₃ ∈ sphere c r) (h₁₂ : p₁ ≠ p₂) (h₁₃ : p₁ ≠ p₃) (h₂₃ : p₂ ≠ p₃) :
  ((Real.Angle.tan (∡ p₁ p₂ p₃))⁻¹ / 2) • o.rotation (π / 2 : ℝ) (p₃ -ᵥ p₁) +ᵥ
    midpoint ℝ p₁ p₃ = c :=
begin
  have h₁₃' : p₁ ≠ p₃ := by {intro h, rw h at h₁₃, exact h₁₃ h₁₃,},
  have h₂₃' : p₂ ≠ p₃ := by {intro h, rw h at h₂₃, exact h₂₃ h₂₃,},
  have h₁₂' : p₁ ≠ p₂ := by {intro h, rw h at h₁₂, exact h₁₂ h₁₂,},
  have h₁₃'' : p₁ ≠ p₃ := by {intro h, rw h at h₁₃', exact h₁₃' h₁₃',},
  have h₂₃'' : p₂ ≠ p₃ := by {intro h, rw h at h₂₃', exact h₂₃' h₂₃',},
  have h₁₂'' : p₁ ≠ p₂ := by {intro h, rw h at h₁₂', exact h₁₂' h₁₂',},
  have h₁₃''' : p₁ ≠ p₃ := by {intro h, rw h at h₁₃'', exact h₁₃'' h₁₃'',},
  have h₂₃''' : p₂ ≠ p₃ := by {intro h, rw h at h₂₃'', exact h₂₃'' h₂₃'',},
  have h₁₂''' : p₁ ≠ p₂ := by {intro h, rw h at h₁₂'', exact h₁₂'' h₁₂'',},
  have h₁₃'''' : p₁ ≠ p₃ := by {intro h, rw h at h₁₃''', exact h₁₃''' h₁₃''',},
  have h₂₃'''' : p₂ ≠ p₃ := by {intro h, rw h at h₂₃''', exact h₂₃''' h₂₃''',},
  have h₁₂'''' : p₁ ≠ p₂ := by {intro h, rw h at h₁₂''', exact h₁₂''' h₁₂''',},
  have h₁₃''''' : p₁ ≠ p₃ := by {intro h, rw h at h₁₃'''', exact h₁₃'''' h₁₃'''',},
  have h₂₃''''' : p₂ ≠ p₃ := by {intro h, rw h at h₂₃'''', exact h₂₃'''' h₂₃'''',},
  have h₁₂''''' : p₁ ≠ p₂ := by {intro h, rw h at h₁₂'''', exact h₁₂'''' h₁₂'''',},
  have h₁₃'''''' : p₁ ≠ p₃ := by {intro h, rw h at h₁₃'''''

Attempt failure.

Working on Mathlib/Geometry/Euclidean/Inversion/Calculus.lean - 2024-09-07 12:51:31.823786.
---48/100---
For theorem EuclideanGeometry.hasFDerivAt_inversion in Mathlib/Geometry/Euclidean/Inversion/Calculus.lean:
theorem hasFDerivAt_inversion (hx : x ≠ c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 • (reflection (ℝ ∙ (x - c))ᗮ : F →L[ℝ] F)) x 


Original valid proof:
:= by
  rcases add_left_surjective c x with ⟨x, rfl⟩
  have : HasFDerivAt (inversion c R) (?_ : F →L[ℝ] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (𝕜 := ℝ) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ℝ ∙ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ↦ ?_)
  · have : ((‖x‖ ^ 2) ^ 2)⁻¹ * (‖x‖ ^ 2) = (‖x‖ ^ 2)⁻¹ := by
      rw [← div_eq_inv_mul, sq (‖x‖ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  · simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 := by
  rcases add_left_surjective c x with ⟨x, rfl⟩
  have : HasFDerivAt (inversion c R) (_ : F →L[ℝ] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (𝕜 := ℝ) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := ℝ ∙ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy ↦ ?_)
  · have : ((‖x‖ ^ 2) ^ 2)⁻¹ * (‖x‖ ^ 2) = (‖x‖ ^ 2)⁻¹ := by
      rw [← div_eq_inv_mul, sq (‖x‖ ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  · simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]

## 2.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.

Attempt failure.

Working on Mathlib/Geometry/Manifold/VectorBundle/Basic.lean - 2024-09-07 12:51:42.191899.
---49/100---
For theorem Bundle.contMDiffWithinAt_totalSpace in Mathlib/Geometry/Manifold/VectorBundle/Basic.lean:
theorem contMDiffWithinAt_totalSpace (f : M → TotalSpace F E) {s : Set M} {x₀ : M} :
    ContMDiffWithinAt IM (IB.prod 𝓘(𝕜, F)) n f s x₀ ↔
      ContMDiffWithinAt IM IB n (fun x => (f x).proj) s x₀ ∧
      ContMDiffWithinAt IM 𝓘(𝕜, F) n (fun x ↦ (trivializationAt F E (f x₀).proj (f x)).2) s x₀ 


Original valid proof:
:= by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ← FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp,
    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe,
    extChartAt_self_apply, modelWithCornersSelf_coe, Function.id_def, ← chartedSpaceSelf_prod]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)
  have h1 : (fun x => (f x).proj) ⁻¹' (trivializationAt F E (f x₀).proj).baseSet ∈ 𝓝[s] x₀ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  · simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  · simp only [mfld_simps]


Verifying proof (Commit 71880da883b383ac13b9beb76b1bd41a0f023582):
∧
      ContMDiffWithinAt IM 𝓘(𝕜, F) n (fun x ↦ (trivializationAt F E (f x₀).proj (f x)).1) s x₀ := by
  simp (config := { singlePass := true }) only [contMDiffWithinAt_iff_target]
  rw [and_and_and_comm, ← FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]
  intro hf
  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp, LocalEquiv.trans_apply,
    LocalEquiv.prod_coe, LocalEquiv.refl_coe, extChartAt_self_apply, modelWithCornersSelf_coe,
    id_def]
  refine (contMDiffWithinAt_prod_iff _).trans (and_congr ?_ (and_congr Iff.rfl Iff.rfl))
  have h1 : (fun x => (f x).proj) ⁻¹' (trivializationAt F E (f x₀).proj).baseSet ∈ 𝓝[s] x₀ :=
    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))
      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))
  refine EventuallyEq.contMDiffWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_
  · simp_rw [Function.comp, LocalHomeomorph.coe_coe, Trivialization.coe_coe]
    rw [Trivialization.coe_fst']
    exact hx
  · simp only [mfld_simps]

## References #

- [N. Hitchin, Generalized Calabi-Yau Manifolds I: Differential Cohomology][Hitchin1987]

## Tags #

differential geometry, smooth manifold, smooth function

### Smoothness of a function on a

## Smoothness of a function on a
FiberBundle #

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.

The functionf : M → TotalSpace F E is smooth on a set s if and only if the
coordinate functions (f x).proj and (trivializationAt F E (f x₀).proj (f x)).2 are
smooth on s, and the coordinate change is smooth on the intersections.


Attempt failure.

Working on Mathlib/Geometry/RingedSpace/Basic.lean - 2024-09-07 12:52:02.149190.
---50/100---
For theorem AlgebraicGeometry.RingedSpace.isUnit_of_isUnit_germ in Mathlib/Geometry/RingedSpace/Basic.lean:
theorem isUnit_of_isUnit_germ (U : Opens X) (f : X.presheaf.obj (op U))
    (h : ∀ x : U, IsUnit (X.presheaf.germ x f)) : IsUnit f 


Original valid proof:
:= by
  choose V iVU m h_unit using fun x : U => X.isUnit_res_of_isUnit_germ U f x (h x)
  have hcover : U ≤ iSup V := by
    intro x hxU
    erw [Opens.mem_iSup]
    exact ⟨⟨x, hxU⟩, m ⟨x, hxU⟩⟩
  choose g hg using fun x : U => IsUnit.exists_right_inv (h_unit x)
  have ic : IsCompatible (sheaf X).val V g := by
    intro x y
    apply section_ext X.sheaf (V x ⊓ V y)
    rintro ⟨z, hzVx, hzVy⟩
    erw [germ_res_apply, germ_res_apply]
    apply (IsUnit.mul_right_inj (h ⟨z, (iVU x).le hzVx⟩)).mp
    rw [← show X.presheaf.germ ⟨z, hzVx⟩ (X.presheaf.map (iVU x).op f) =
      X.presheaf.germ ⟨z, ((iVU x) ⟨z, hzVx⟩).2⟩ f from
      X.presheaf.germ_res_apply (iVU x) ⟨z, hzVx⟩ f]
    change X.presheaf.germ ⟨z, hzVx⟩ _ * (X.presheaf.germ ⟨z, hzVx⟩ _) =
      X.presheaf.germ ⟨z, hzVx⟩ _ * X.presheaf.germ ⟨z, hzVy⟩ (g y)
    rw [← RingHom.map_mul,
      congr_arg (X.presheaf.germ (⟨z, hzVx⟩ : V x)) (hg x),
      show X.presheaf.germ ⟨z, hzVx⟩ (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ⟨z, ((iVU x) ⟨z, hzVx⟩).2⟩ f from X.presheaf.germ_res_apply _ _ f,
      ← show X.presheaf.germ ⟨z, hzVy⟩ (X.presheaf.map (iVU y).op f) =
          X.presheaf.germ ⟨z, ((iVU x) ⟨z, hzVx⟩).2⟩ f from
          X.presheaf.germ_res_apply (iVU y) ⟨z, hzVy⟩ f,
      ← RingHom.map_mul,
      congr_arg (X.presheaf.germ (⟨z, hzVy⟩ : V y)) (hg y), RingHom.map_one, RingHom.map_one]
  obtain ⟨gl, gl_spec, -⟩ := X.sheaf.existsUnique_gluing' V U iVU hcover g ic
  apply isUnit_of_mul_eq_one f gl
  apply X.sheaf.eq_of_locally_eq' V U iVU hcover
  intro i
  rw [RingHom.map_one, RingHom.map_mul, gl_spec]
  exact hg i


Verifying proof (Commit 5c6b5a4c50c73942f6fcbc02eebf983c6e667b79):
 := by
  choose V iVU m h_unit using fun x : U => X.isUnit_res_of_isUnit_germ U f x (h x)
  have hcover : U ≤ iSup V
  · intro x hxU
    erw [Opens.mem_iSup]
    exact ⟨⟨x, hxU⟩, m ⟨x, hxU⟩⟩
  choose g hg using fun x : U => IsUnit.exists_right_inv (h_unit x)
  have ic : IsCompatible (sheaf X).val V g
  · intro x y
    apply section_ext X.sheaf (V x ⊓ V y)
    rintro ⟨z, hzVx, hzVy⟩
    erw [germ_res_apply, germ_res_apply]
    apply (IsUnit.mul_right_inj (h ⟨z, (iVU x).le hzVx⟩)).mp
    rw [← show X.presheaf.germ ⟨z, hzVx⟩ (X.presheaf.map (iVU x).op f) =
      X.presheaf.germ ⟨z, ((iVU x) ⟨z, hzVx⟩).2⟩ f from
      X.presheaf.germ_res_apply (iVU x) ⟨z, hzVx⟩ f]
    change X.presheaf.germ ⟨z, hzVx⟩ _ * (X.presheaf.germ ⟨z, hzVx⟩ _) =
      X.presheaf.germ ⟨z, hzVx⟩ _ * X.presheaf.germ ⟨z, hzVy⟩ (g y)
    rw [← RingHom.map_mul,
      congr_arg (X.presheaf.germ (⟨z, hzVx⟩ : V x)) (hg x),
      show X.presheaf.germ ⟨z, hzVx⟩ (X.presheaf.map (iVU x).op f) =
        X.presheaf.germ ⟨z, ((iVU x) ⟨z, hzVx⟩).2⟩ f from X.presheaf.germ_res_apply _ _ f,
      ← show X.presheaf.germ ⟨z, hzVy⟩ (X.presheaf.map (iVU y).op f) =
          X.presheaf.germ ⟨z, ((iVU x) ⟨z, hzVx⟩).2⟩ f from
          X.presheaf.germ_res_apply (iVU y) ⟨z, hzVy⟩ f,
      ← RingHom.map_mul,
      congr_arg (X.presheaf.germ (⟨z, hzVy⟩ : V y)) (hg y), RingHom.map_one, RingHom.map_one]
  obtain ⟨gl, gl_spec, -⟩ := X.sheaf.existsUnique_gluing' V U iVU hcover g ic
  apply isUnit_of_mul_eq_one f gl
  apply X.sheaf.eq_of_locally_eq' V U iVU hcover
  intro i
  rw [RingHom.map_one, RingHom.map_mul, gl_spec]
  exact hg i

## Your Answer

By clicking “Post Your Answer”, you agree to our terms of service, privacy policy and cookie policy

Attempt failure.

Working on Mathlib/GroupTheory/GroupAction/Period.lean - 2024-09-07 12:52:16.716614.
---51/100---
For theorem MulAction.period_pos_of_fixed in Mathlib/GroupTheory/GroupAction/Period.lean:
theorem period_pos_of_fixed {m : M} {a : α} {n : ℕ} (n_pos : 0 < n) (fixed : m ^ n • a = a) :
    0 < period m a 


Original valid proof:
:=
  (isPeriodicPt_smul_iff.mpr fixed).minimalPeriod_pos n_pos


Verifying proof (Commit cef8a766d74101e505f17c2cc18209448b2f6a44):
 := by
  rw [fixed_iff_isPeriodicPt] at fixed
  rw [period_eq_minimalPeriod]
  exact Function.IsPeriodicPt.minimalPeriod_pos n_pos fixed

The problem is that the first line of the proof is not a theorem, but a definition.

####  Eric Wieser (Jun 12 2020 at 10:00):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.

####  Eric Wieser (Jun 12 2020 at 10:01):

I'm not sure what the best way to fix this is, but I'd be happy to see a PR that fixes it.


Attempt failure.

Working on Mathlib/GroupTheory/MonoidLocalization.lean - 2024-09-07 12:52:24.128853.
---52/100---
For theorem Localization.mk_one in Mathlib/GroupTheory/MonoidLocalization.lean:
theorem mk_one : mk 1 (1 : S) = 1 


Original valid proof:
:=
  show mk _ _ = .one S by rw [Localization.one]; rfl


Verifying proof (Commit f7d2420463796edab0b4f526fd8c96d19b328dd9):
 := by
  rw [mk, one_def, one_def, one_def]
  simp

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point of this is.

####  Kevin Buzzard (Mar 10 2021 at 10:04):

I'm not sure what the point

Attempt failure.

Working on Mathlib/LinearAlgebra/AffineSpace/Combination.lean - 2024-09-07 12:52:49.694901.
---53/100---
For theorem Finset.weightedVSubOfPoint_const_smul in Mathlib/LinearAlgebra/AffineSpace/Combination.lean:
theorem weightedVSubOfPoint_const_smul (w : ι → k) (p : ι → P) (b : P) (c : k) :
    s.weightedVSubOfPoint p b (c • w) = c • s.weightedVSubOfPoint p b w 


Original valid proof:
:= by
  simp_rw [weightedVSubOfPoint_apply, smul_sum, Pi.smul_apply, smul_smul, smul_eq_mul]


Verifying proof (Commit 9db546a81b334ba30d74fed40766bcdeffb50e5f):
 := by
  simp_rw [weightedVSubOfPoint_apply, smul_sum', Pi.smul_apply, smul_smul, smul_eq_mul]

####  Eric Wieser (May 10 2020 at 10:00):

I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric Wieser (May 10 2020 at 10:01):

I'm not sure what the issue is, but I'm not sure I'd want to be using the
simp_rw version of the theorem anyway.
I'm not sure what the issue is, but I'm not sure I'd want to be using thesimp_rw version of the theorem anyway.

####  Eric

Attempt failure.

Working on Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean - 2024-09-07 12:53:07.509510.
---54/100---
For theorem collinear_iff_of_mem in Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean:
theorem collinear_iff_of_mem {s : Set P} {p₀ : P} (h : p₀ ∈ s) :
    Collinear k s ↔ ∃ v : V, ∀ p ∈ s, ∃ r : k, p = r • v +ᵥ p₀ 


Original valid proof:
:= by
  simp_rw [collinear_iff_rank_le_one, rank_submodule_le_one_iff', Submodule.le_span_singleton_iff]
  constructor
  · rintro ⟨v₀, hv⟩
    use v₀
    intro p hp
    obtain ⟨r, hr⟩ := hv (p -ᵥ p₀) (vsub_mem_vectorSpan k hp h)
    use r
    rw [eq_vadd_iff_vsub_eq]
    exact hr.symm
  · rintro ⟨v, hp₀v⟩
    use v
    intro w hw
    have hs : vectorSpan k s ≤ k ∙ v := by
      rw [vectorSpan_eq_span_vsub_set_right k h, Submodule.span_le, Set.subset_def]
      intro x hx
      rw [SetLike.mem_coe, Submodule.mem_span_singleton]
      rw [Set.mem_image] at hx
      rcases hx with ⟨p, hp, rfl⟩
      rcases hp₀v p hp with ⟨r, rfl⟩
      use r
      simp
    have hw' := SetLike.le_def.1 hs hw
    rwa [Submodule.mem_span_singleton] at hw'


Verifying proof (Commit 28f34517ea07a4ecc94b3d55041dd0ca1152a2a8):
∧ v ≠ 0 := by
  simp_rw [collinear_iff_rank_le_one, rank_submodule_le_one_iff', Submodule.le_span_singleton_iff]
  constructor
  · rintro ⟨v₀, hv⟩
    use v₀
    intro p hp
    obtain ⟨r, hr⟩ := hv (p -ᵥ p₀) (vsub_mem_vectorSpan k hp h)
    use r
    rw [eq_vadd_iff_vsub_eq]
    exact ⟨hr.symm, hr.symm ▸ vsub_ne_zero.mpr hp⟩
  · rintro ⟨v, hp₀v, hv⟩
    use v
    intro w hw
    have hs : vectorSpan k s ≤ k • v := by
      rw [vectorSpan_eq_span_vsub_set_right k h, Submodule.span_le, Set.subset_def]
      intro x hx
      rw [SetLike.mem_coe, Submodule.mem_span_singleton]
      rw [Set.mem_image] at hx
      rcases hx with ⟨p, hp, rfl⟩
      rcases hp₀v p hp with ⟨r, rfl⟩
      use r
      simp
    have hw' := SetLike.le_def.1 hs hw
    rwa [Submodule.mem_span_singleton] at hw'

## Equations

- affineSubspace.direction = { toSubmodule := vectorSpan k ↑s, smul_mem' := (_ : ∀ (a : k) (v : V), v ∈ vectorSpan k ↑s → a • v ∈ vectorSpan k ↑s), add_mem' := (_ : ∀ (v₁ v₂ : V), v₁ ∈ vectorSpan k ↑s → v₂ ∈ vectorSpan k ↑s → v₁ + v₂ ∈ vectorSpan k ↑s) }

@[simp]

theorem affineSubspace.direction_affineSpan (s : Set P) : (affineSpan k s).direction = vectorSpan k s

@[simp]

theorem affineSubspace.direction_mk (p : P) (s : Set P) (h : p ∈ affineSpan k s) : (affineSpan k s).direction = vectorSpan k s

@[simp]

theorem affineSubspace.direction_affineSpan_of_nonempty {s : Set P} (h : s.Nonempty) : (affineSpan k s).direction = vectorSpan k s

@[simp]

theorem affineSubspace.direction_affineSpan_of_nonempty_of_subset {s t : Set P} (h₁ : s.Nonempty) (h₂ : s ⊆ t) : (affineSpan k t).direction = vectorSpan k s

@[simp]

theorem affineSubspace.direction_affineSpan_singleton (p : P) : (affineSpan k {p}).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton' (k : Type u_1) [DivisionRing k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton'' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton'''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton''''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton'''''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton''''''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton'''''''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton''''''''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton'''''''''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton''''''''''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton'''''''''''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton''''''''''''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton'''''''''''''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton''''''''''''''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton'''''''''''''''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton''''''''''''''''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = ⊥

@[simp]

theorem affineSubspace.direction_affineSpan_zero_singleton'''''''''''''''''' (k : Type u_1) [Field k] [addCommGroup V] [Module k V] [addTorsor V P] : (affineSpan k 0).direction = �

Attempt failure.

Working on Mathlib/LinearAlgebra/BilinearForm/Properties.lean - 2024-09-07 12:53:24.010163.
---55/100---
For theorem LinearMap.BilinForm.Nondegenerate.flip in Mathlib/LinearAlgebra/BilinearForm/Properties.lean:
lemma Nondegenerate.flip {B : BilinForm K V} (hB : B.Nondegenerate) :
    B.flip.Nondegenerate 


Original valid proof:
:= by
  intro x hx
  apply (Module.evalEquiv K V).injective
  ext f
  obtain ⟨y, rfl⟩ := (B.toDual hB).surjective f
  simpa using hx y


Verifying proof (Commit 31c261277bc3e8a52b74d248691ef6b40c75b452):
 :=
  LinearMap.BilinForm.SeparatingLeft.flip (B := (BilinForm.toLin B)) hB

I think the problem is that the type ofBilinForm.toLin B is not inferred correctly.

####  Eric Wieser (May 02 2020 at 14:00):

I think the problem is that the type ofBilinForm.toLin B is not inferred correctly.

I'm not sure what you mean by that. The type ofBilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.

####  Eric Wieser (May 02 2020 at 14:01):

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type ofBilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.

####  Eric Wieser (May 02 2020 at 14:02):

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

####  Eric Wieser (May 02 2020 at 14:03):

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin.
I see, thanks!

I'm not sure what you mean by that. The type of
BilinForm.toLin B is inferred correctly, and it's the same as the type of B.toLin.
Oh, I see, I was looking at the type of
BilinForm.toLin B.toLin, which is the same as the type of B.toLin.toLin

Attempt failure.

---56/100---
For theorem LinearMap.BilinForm.dualBasis_dualBasis in Mathlib/LinearAlgebra/BilinearForm/Properties.lean:
lemma dualBasis_dualBasis_flip (B : BilinForm K V) (hB : B.Nondegenerate) {ι}
    [Finite ι] [DecidableEq ι] (b : Basis ι K V) :
    B.dualBasis hB (B.flip.dualBasis hB.flip b) = b 


Original valid proof:
:= by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j ↦ ?_))
  simp_rw [apply_dualBasis_left, ← B.flip_apply, apply_dualBasis_left, @eq_comm _ i j]


Verifying proof (Commit 6b3f3fe208f0cdce581d713270301bed755856ed):
 := by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j ↦ ?_))
  rw [toLin_apply, apply_dualBasis_left, toLin_apply, ← B.flip_apply (R₂ := K),
    apply_dualBasis_left]
  simp_rw [@eq_comm _ i j, flip_apply]

####  Eric Wieser (Jun 08 2020 at 11:00):

I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use
flip_apply in the proof.
I'm not sure what the issue is, but I'm not sure I'd want to useflip_apply in the proof.

####  Eric Wieser (Jun 08 2020 at 11:01):

I'm not sure what the issue is, but I'm not sure I'd want to use


Attempt failure.

Working on Mathlib/LinearAlgebra/FiniteDimensional.lean - 2024-09-07 12:54:02.216617.
---57/100---
For theorem Submodule.eq_top_of_finrank_eq in Mathlib/LinearAlgebra/FiniteDimensional.lean:
theorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = ⊤ 


Original valid proof:
:= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((↑) : ((↑) '' Basis.ofVectorSpaceIndex K S : Set V) → V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa [bS] using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa [b] using b.linearIndependent)).fintype
  letI i2 : Fintype (((↑) : S → V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian
      (by simpa [bS] using bS.linearIndependent)).fintype
  have : (↑) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ← finrank_eq_card_basis bS, ←
            finrank_eq_card_basis b, h])
  rw [← b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ← this, ← Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]


Verifying proof (Commit 76e6a78efcb1b11e117600191db6d147aeeeb85d):
 := by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((↑) '' Basis.ofVectorSpaceIndex K S : Set V).incl :=
    @LinearIndependent.image_subtype _ _ _ _ _ _ _ _ _ (Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linearIndependent)).fintype
  letI i2 : Fintype (((↑) : S → V) '' Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent (by simpa using bS.linearIndependent)).fintype
  have : (↑) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, ← finrank_eq_card_basis bS, ←
            finrank_eq_card_basis b, h])
  rw [← b.span_eq, b_eq, Basis.coe_extend, Subtype.range_val, ← this,
    ←Submodule.coeSubtype, span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_val] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]

####  Eric Wieser (May 01 2020 at 10:00):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 01 2020 at 10:01):

I'm not sure what the issue is, but I'm not seeing any errors in the proof.

####  Eric Wieser (May 

Attempt failure.

Working on Mathlib/LinearAlgebra/Semisimple.lean - 2024-09-07 12:54:35.212254.
---58/100---
For theorem Module.End.IsSemisimple.of_mem_adjoin_pair in Mathlib/LinearAlgebra/Semisimple.lean:
theorem IsSemisimple.of_mem_adjoin_pair {a : End K M} (ha : a ∈ Algebra.adjoin K {f, g}) :
    a.IsSemisimple 


Original valid proof:
:= by
  let R := K[X] ⧸ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R :=
    (AdjoinRoot.powerBasis' <| minpoly.monic <| Algebra.IsIntegral.isIntegral f).finite
  have : Finite R S :=
    (AdjoinRoot.powerBasis' <| (minpoly.monic <| Algebra.IsIntegral.isIntegral g).map _).finite
  set_option maxSynthPendingDepth 2 in
  have : IsScalarTower K R S := .of_algebraMap_eq fun _ ↦ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ▸ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ← Ideal.isRadical_iff_quotient_reduced, ← isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let φ : S →ₐ[K] End K M := Ideal.Quotient.liftₐ _ (eval₂AlgHom' (Ideal.Quotient.liftₐ _ (aeval f)
    fun a ↦ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ≤ RingHom.ker _)
  rotate_left 1
  · rw [Ideal.span, ← minpoly.ker_aeval_eq_span_minpoly]; exact id
  · rintro ⟨p⟩; exact p.induction_on (fun k ↦ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ↦ by simpa using hp.add_left hq)
      fun n k ↦ by simpa [R, pow_succ, ← mul_assoc _ _ X] using (·.mul_left comm)
  · simpa only [RingHom.mem_ker, eval₂AlgHom'_apply, eval₂_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ≤ φ.range := Algebra.adjoin_le fun x ↦ by
    rintro (hx | hx) <;> rw [hx]
    · exact ⟨AdjoinRoot.of _ (AdjoinRoot.root _), (eval₂_C _ _).trans (aeval_X f)⟩
    · exact ⟨AdjoinRoot.root _, eval₂_X _ _⟩
  obtain ⟨p, rfl⟩ := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, φ.comp_apply, minpoly.aeval, φ.map_zero]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  let R := K[X] ⧸ Ideal.span {minpoly K f}
  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)
  have : Finite K R := (AdjoinRoot.powerBasis' <| minpoly.monic <| isIntegral f).finite
  have : Finite R S := (AdjoinRoot.powerBasis' <| (minpoly.monic <| isIntegral g).map _).finite
  have : IsScalarTower K R S := .of_algebraMap_eq fun _ ↦ rfl
  have : Finite K S := .trans R S
  have : IsArtinianRing R := .of_finite K R
  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|
    span_minpoly_eq_annihilator K f ▸ hf.annihilator_isRadical
  have : IsReduced S := by
    simp_rw [S, AdjoinRoot, ← Ideal.isRadical_iff_quotient_reduced, ← isRadical_iff_span_singleton]
    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical
  let φ : S →ₐ[K] End K M := Ideal.Quotient.liftₐ _ (eval₂AlgHom' (Ideal.Quotient.liftₐ _ (aeval f)
    fun a ↦ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ≤ RingHom.ker _)
  rotate_left 1
  · rw [Ideal.span, ← minpoly.ker_aeval_eq_span_minpoly]; exact id
  · rintro ⟨p⟩; exact p.induction_on (fun k ↦ by simp [R, Algebra.commute_algebraMap_left])
      (fun p q hp hq ↦ by simpa using hp.add_left hq)
      fun n k ↦ by simpa [R, pow_succ, ← mul_assoc _ _ X] using (·.mul_left comm)
  · simpa only [RingHom.mem_ker, eval₂AlgHom'_apply, eval₂_map, AlgHom.comp_algebraMap_of_tower]
      using minpoly.aeval K g
  have : Algebra.adjoin K {f, g} ≤ φ.range := Algebra.adjoin_le fun x ↦ by
    rintro (hx | hx) <;> rw [hx]
    · exact ⟨AdjoinRoot.of _ (AdjoinRoot.root _), (eval₂_C _ _).trans (aeval_X f)⟩
    · exact ⟨AdjoinRoot.root _, eval₂_X _ _⟩
  obtain ⟨p, rfl⟩ := (AlgHom.mem_range _).mp (this ha)
  refine isSemisimple_of_squarefree_aeval_eq_zero
    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_
  rw [aeval_algHom, φ.comp_apply, minpoly.aeval, φ.map_zero]

## References #

- [M. F. Atiyah and I. G. Macdonald, *Introduction to commutative algebra*][Atiyah1969]

## Tags #

semisimple, semisimple algebra, semisimple module, semisimple endomorphism, semisimple ring

theorem IsSemisimple.of_mem_adjoin_pair {K : Type u_1} {M : Type u_2} [Field K] [AddCommGroup M] [Module K M] [IsArtinianRing K] [IsNoetherianRing K] [IsReduced K] [IsReduced (K →ₐ[K] End K M)] {f g : End K M} (hf : f.IsIntegral K) (hg : g.IsIntegral K) (ha : a ∈ Algebra.adjoin K {f, g}) :

a.IsSemisimple

IfK is a field, M is a finite dimensional K-module, f, g : End K M are
integral endomorphisms, and a ∈ adjoin K {f, g}, then a is semisimple.

theorem IsSemisimple.of_mem_adjoin {K : Type u_1} {M : Type u_2} [Field K] [AddCommGroup M] [Module K M] [IsArtinianRing K] [IsNoetherianRing K] [IsReduced K] [IsReduced (K →ₐ[K] End K M)] {f : End K M} (hf : f.IsIntegral K) (ha : a ∈ Algebra.adjoin K {f}) :

a.IsSemisimple

IfK is a field, M is a finite dimensional K-module, f : End K M is
integral, and a ∈ adjoin K {f}, then a is semisimple.

theorem IsSemisimple.of_mem_adjoin_of_is_separable {K : Type u_1} {M : Type u_2} [Field K] [AddCommGroup M] [Module K M] [IsArtinianRing K] [IsNoetherianRing K] [IsReduced K] [IsReduced (K →ₐ[K] End K M)] {f : End K M} (hf : f.IsIntegral K) (hf' : f.IsSeparable K) (ha : a ∈ Algebra.adjoin K {f}) :

a.IsSemisimple

IfK is a field, M is a finite dimensional K-module, f : End K M is
integral and separable, and a ∈ adjoin K {f}, then a is semisimple.

theorem IsSemisimple.of_mem_adjoin_of_is_integral {K : Type u_1} {M : Type u_2} [Field K] [AddCommGroup M] [Module K M] [IsArtinianRing K] [IsNoetherianRing K] [IsReduced K] [IsReduced (K →ₐ[K] End K M)] {f : End K M} (hf : f.IsIntegral K) (ha : a ∈ Algebra.adjoin K {f}) :

a.IsSemisimple

IfK is a field, M is a finite dimensional K-module, f : End K M is
integral, and a ∈ adjoin K {f}, then a is semisimple.

theorem IsSemisimple.of_mem_adjoin_of_is_integral' {K : Type u_1} {M : Type u_2} [Field K] [AddCommGroup M] [Module K M] [IsArtinianRing K] [IsNoetherianRing K] [IsReduced K] [IsReduced (K →ₐ[K] End K M)] {f : End K M} (hf : f.IsIntegral K) (ha : a ∈ Algebra.adjoin K {f}) :

a.IsSemisimple

IfK is a field, M is a finite dimensional K-module, f : End K M is
integral, and a ∈ adjoin K {f}, then a is semisimple.

theorem IsSemisimple.of_mem_adjoin_of_is_integral'' {K : Type u_1} {M : Type u_2} [Field K] [AddCommGroup M] [Module K M] [IsArtinianRing K] [IsNoetherianRing K] [IsReduced K] [IsReduced (K →ₐ[K] End K M)] {f : End K M} (hf : f.IsIntegral K) (ha : a ∈ Algebra.adjoin K {f}) :

a.IsSemisimple

IfK is a field, M is a finite dimensional K-module, f : End K M is
integral, and a ∈ adjoin K {f}, then a is semisimple.

theorem IsSemisimple.of_mem_adjoin_of_is_integral''' {K : Type u_1} {M : Type u_2} [Field K] [AddCommGroup M] [Module K M] [IsArtinianRing K] [IsNoetherianRing K] [IsReduced K] [IsReduced (K →ₐ[K] End K M)] {f : End K M} (hf : f.IsIntegral K) (ha : a ∈ Algebra.

Attempt failure.

Working on Mathlib/Logic/Equiv/Set.lean - 2024-09-07 12:54:51.047198.
---59/100---
For theorem Equiv.swap_bijOn_self in Mathlib/Logic/Equiv/Set.lean:
theorem Equiv.swap_bijOn_self (hs : a ∈ s ↔ b ∈ s) : BijOn (Equiv.swap a b) s s 


Original valid proof:
:= by
  refine ⟨fun x hx ↦ ?_, (Equiv.injective _).injOn, fun x hx ↦ ?_⟩
  · obtain (rfl | hxa) := eq_or_ne x a
    · rwa [swap_apply_left, ← hs]
    obtain (rfl | hxb) := eq_or_ne x b
    · rwa [swap_apply_right, hs]
    rwa [swap_apply_of_ne_of_ne hxa hxb]
  obtain (rfl | hxa) := eq_or_ne x a
  · simp [hs.1 hx]
  obtain (rfl | hxb) := eq_or_ne x b
  · simp [hs.2 hx]
  exact ⟨x, hx, swap_apply_of_ne_of_ne hxa hxb⟩


Verifying proof (Commit 7517f38ed8672b95cb4dd3df959ccd3f6d36c011):
 := by
  refine ⟨fun x hx ↦ ?_, (Equiv.injective _).injOn _, fun x hx ↦ ?_⟩
  · obtain (rfl | hxa) := eq_or_ne x a
    · rwa [swap_apply_left, ← hs]
    obtain (rfl | hxb) := eq_or_ne x b
    · rwa [swap_apply_right, hs]
    rwa [swap_apply_of_ne_of_ne hxa hxb]
  obtain (rfl | hxa) := eq_or_ne x a
  · simp [hs.1 hx]
  obtain (rfl | hxb) := eq_or_ne x b
  · simp [hs.2 hx]
  exact ⟨x, hx, swap_apply_of_ne_of_ne hxa hxb⟩

## 1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Besicovitch.lean - 2024-09-07 12:54:56.886061.
---60/100---
For theorem Besicovitch.exists_disjoint_closedBall_covering_ae in Mathlib/MeasureTheory/Covering/Besicovitch.lean:
theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (μ : Measure α)
    [IsFiniteMeasure μ] (f : α → Set ℝ) (s : Set α)
    (hf : ∀ x ∈ s, ∀ δ > 0, (f x ∩ Ioo 0 δ).Nonempty) :
    ∃ t : Set (α × ℝ), t.Countable ∧ (∀ p ∈ t, p.1 ∈ s) ∧ (∀ p ∈ t, p.2 ∈ f p.1) ∧
      μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) = 0 ∧
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 


Original valid proof:
:= by
  rcases HasBesicovitchCovering.no_satelliteConfig (α := α) with ⟨N, τ, hτ, hN⟩
  let P : Finset (α × ℝ) → Prop := fun t =>
    ((t : Set (α × ℝ)).PairwiseDisjoint fun p => closedBall p.1 p.2) ∧
      (∀ p : α × ℝ, p ∈ t → p.1 ∈ s) ∧ ∀ p : α × ℝ, p ∈ t → p.2 ∈ f p.1
  have :
      ∀ t : Finset (α × ℝ), P t → ∃ u : Finset (α × ℝ), t ⊆ u ∧ P u ∧
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u), closedBall p.1 p.2) ≤
          N / (N + 1) * μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) := by
    intro t ht
    set B := ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ∀ x ∈ s', ∃ r ∈ f x ∩ Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ∈ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      · rcases hf x xs 1 zero_lt_one with ⟨r, hr, h'r⟩
        exact ⟨r, ⟨hr, h'r⟩, by simp only [hB, empty_disjoint]⟩
      · let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ⟨r, hr, h'r⟩
        refine ⟨r, ⟨hr, ⟨h'r.1, h'r.2.trans_le (min_le_right _ _)⟩⟩, ?_⟩
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ⟨v, vs', hμv, hv⟩ :
      ∃ v : Finset α,
        ↑v ⊆ s' ∧
          μ (s' \ ⋃ x ∈ v, closedBall x (r x)) ≤ N / (N + 1) * μ s' ∧
            (v : Set α).PairwiseDisjoint fun x : α => closedBall x (r x) :=
      haveI rI : ∀ x ∈ s', r x ∈ Ioo (0 : ℝ) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure μ hτ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ⟨t ∪ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ⟨?_, ?_, ?_⟩, ?_⟩
    · simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      · intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ⟨p', p'v, rfl⟩
        rcases (mem_image _ _ _).1 hq with ⟨q', q'v, rfl⟩
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      · intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ⟨q', q'v, rfl⟩
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ← Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : α × ℝ => closedBall x.1 x.2) hp
    · intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      · exact ht.2.1 p h'p
      · rcases Finset.mem_image.1 h'p with ⟨p', p'v, rfl⟩
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    · intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      · exact ht.2.2 p h'p
      · rcases Finset.mem_image.1 h'p with ⟨p', p'v, rfl⟩
        exact (hr p' (vs' p'v)).1.1
    · convert hμv using 2
      rw [Finset.set_biUnion_union, ← diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ∅
  have u_succ : ∀ n : ℕ, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ∀ n, P (u n) := by
    intro n
    induction' n with n IH
    · simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall₂_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    · rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ⟨⋃ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_⟩
  · intro p hp
    rcases mem_iUnion.1 hp with ⟨n, hn⟩
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  · intro p hp
    rcases mem_iUnion.1 hp with ⟨n, hn⟩
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  · have A :
      ∀ n,
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ ⋃ n : ℕ, (u n : Set (α × ℝ))), closedBall p.fst p.snd) ≤
          μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr μ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (α × ℝ))) n)
    have B :
        ∀ n, μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) ≤
          (N / (N + 1) : ℝ≥0∞) ^ n * μ s := by
      intro n
      induction' n with n IH
      · simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n.succ), closedBall p.fst p.snd) ≤
            N / (N + 1) * μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ≤ (N / (N + 1) : ℝ≥0∞) ^ n.succ * μ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ℕ => ((N : ℝ≥0∞) / (N + 1)) ^ n * μ s) atTop (𝓝 (0 * μ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top μ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      · conv_lhs => rw [← add_zero (N : ℝ≥0∞)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      · simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      · simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  · refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [← Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ'''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ'''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ'''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ'''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ'''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ'''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ'''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ''''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ'''''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ''''''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ'''''''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ''''''''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ'''''''''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ''''''''''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ'''''''''''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ''''''''''''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ'''''''''''''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ''''''''''''''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ'''''''''''''''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_lt_top μ s)
  have hμ''''''''''''''''''''''''''''''''''''''''''''''''''''''''' : μ s ≠ 0 := ne_of_lt (measure_

Attempt failure.

---61/100---
For theorem Besicovitch.exists_disjoint_closedBall_covering_ae in Mathlib/MeasureTheory/Covering/Besicovitch.lean:
theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (μ : Measure α)
    [IsFiniteMeasure μ] (f : α → Set ℝ) (s : Set α)
    (hf : ∀ x ∈ s, ∀ δ > 0, (f x ∩ Ioo 0 δ).Nonempty) :
    ∃ t : Set (α × ℝ), t.Countable ∧ (∀ p ∈ t, p.1 ∈ s) ∧ (∀ p ∈ t, p.2 ∈ f p.1) ∧
      μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) = 0 ∧
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 


Original valid proof:
:= by
  rcases HasBesicovitchCovering.no_satelliteConfig (α := α) with ⟨N, τ, hτ, hN⟩
  let P : Finset (α × ℝ) → Prop := fun t =>
    ((t : Set (α × ℝ)).PairwiseDisjoint fun p => closedBall p.1 p.2) ∧
      (∀ p : α × ℝ, p ∈ t → p.1 ∈ s) ∧ ∀ p : α × ℝ, p ∈ t → p.2 ∈ f p.1
  have :
      ∀ t : Finset (α × ℝ), P t → ∃ u : Finset (α × ℝ), t ⊆ u ∧ P u ∧
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u), closedBall p.1 p.2) ≤
          N / (N + 1) * μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) := by
    intro t ht
    set B := ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ∀ x ∈ s', ∃ r ∈ f x ∩ Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ∈ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      · rcases hf x xs 1 zero_lt_one with ⟨r, hr, h'r⟩
        exact ⟨r, ⟨hr, h'r⟩, by simp only [hB, empty_disjoint]⟩
      · let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ⟨r, hr, h'r⟩
        refine ⟨r, ⟨hr, ⟨h'r.1, h'r.2.trans_le (min_le_right _ _)⟩⟩, ?_⟩
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ⟨v, vs', hμv, hv⟩ :
      ∃ v : Finset α,
        ↑v ⊆ s' ∧
          μ (s' \ ⋃ x ∈ v, closedBall x (r x)) ≤ N / (N + 1) * μ s' ∧
            (v : Set α).PairwiseDisjoint fun x : α => closedBall x (r x) :=
      haveI rI : ∀ x ∈ s', r x ∈ Ioo (0 : ℝ) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure μ hτ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ⟨t ∪ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ⟨?_, ?_, ?_⟩, ?_⟩
    · simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      · intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ⟨p', p'v, rfl⟩
        rcases (mem_image _ _ _).1 hq with ⟨q', q'v, rfl⟩
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      · intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ⟨q', q'v, rfl⟩
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ← Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : α × ℝ => closedBall x.1 x.2) hp
    · intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      · exact ht.2.1 p h'p
      · rcases Finset.mem_image.1 h'p with ⟨p', p'v, rfl⟩
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    · intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      · exact ht.2.2 p h'p
      · rcases Finset.mem_image.1 h'p with ⟨p', p'v, rfl⟩
        exact (hr p' (vs' p'v)).1.1
    · convert hμv using 2
      rw [Finset.set_biUnion_union, ← diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ∅
  have u_succ : ∀ n : ℕ, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ∀ n, P (u n) := by
    intro n
    induction' n with n IH
    · simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall₂_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    · rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ⟨⋃ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_⟩
  · intro p hp
    rcases mem_iUnion.1 hp with ⟨n, hn⟩
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  · intro p hp
    rcases mem_iUnion.1 hp with ⟨n, hn⟩
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  · have A :
      ∀ n,
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ ⋃ n : ℕ, (u n : Set (α × ℝ))), closedBall p.fst p.snd) ≤
          μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr μ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (α × ℝ))) n)
    have B :
        ∀ n, μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) ≤
          (N / (N + 1) : ℝ≥0∞) ^ n * μ s := by
      intro n
      induction' n with n IH
      · simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n.succ), closedBall p.fst p.snd) ≤
            N / (N + 1) * μ (s \ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ≤ (N / (N + 1) : ℝ≥0∞) ^ n.succ * μ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ℕ => ((N : ℝ≥0∞) / (N + 1)) ^ n * μ s) atTop (𝓝 (0 * μ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top μ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      · conv_lhs => rw [← add_zero (N : ℝ≥0∞)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      · simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      · simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  · refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [← Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1


Verifying proof (Commit b492f764dc62b80a0be745055df26ce5b018a24a):
shov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

####  Yury G. Kudryashov (May 03 2021 at 14:04):

@Mario Carneiro I'm not sure if I should add a new issue for this.

#### 

Attempt failure.

Working on Mathlib/MeasureTheory/Covering/Differentiation.lean - 2024-09-07 12:55:27.408074.
---62/100---
For theorem VitaliFamily.null_of_frequently_le_of_frequently_ge in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem null_of_frequently_le_of_frequently_ge {c d : ℝ≥0} (hcd : c < d) (s : Set α)
    (hc : ∀ x ∈ s, ∃ᶠ a in v.filterAt x, ρ a ≤ c * μ a)
    (hd : ∀ x ∈ s, ∃ᶠ a in v.filterAt x, (d : ℝ≥0∞) * μ a ≤ ρ a) : μ s = 0 


Original valid proof:
:= by
  apply measure_null_of_locally_null s fun x _ => ?_
  obtain ⟨o, xo, o_open, μo⟩ : ∃ o : Set α, x ∈ o ∧ IsOpen o ∧ μ o < ∞ :=
    Measure.exists_isOpen_measure_lt_top μ x
  refine ⟨s ∩ o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), ?_⟩
  let s' := s ∩ o
  by_contra h
  apply lt_irrefl (ρ s')
  calc
    ρ s' ≤ c * μ s' := v.measure_le_of_frequently_le (c • μ) hρ s' fun x hx => hc x hx.1
    _ < d * μ s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt (measure_mono inter_subset_right) μo).ne
    _ ≤ ρ s' :=
      v.measure_le_of_frequently_le ρ ((Measure.AbsolutelyContinuous.refl μ).smul d) s' fun x hx =>
        hd x hx.1


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  apply null_of_locally_null s fun x _ => ?_
  obtain ⟨o, xo, o_open, μo⟩ : ∃ o : Set α, x ∈ o ∧ IsOpen o ∧ μ o < ∞ :=
    Measure.exists_isOpen_measure_lt_top μ x
  refine' ⟨s ∩ o, inter_mem_nhdsWithin _ (o_open.mem_nhds xo), _⟩
  let s' := s ∩ o
  by_contra h
  apply lt_irrefl (ρ s')
  calc
    ρ s' ≤ c * μ s' := v.measure_le_of_frequently_le (c • μ) hρ s' fun x hx => hc x hx.1
    _ < d * μ s' := by
      apply (ENNReal.mul_lt_mul_right h _).2 (ENNReal.coe_lt_coe.2 hcd)
      exact (lt_of_le_of_lt (measure_mono (inter_subset_right _ _)) μo).ne
    _ ≤ ρ s' :=
      v.measure_le_of_frequently_le ρ ((Measure.AbsolutelyContinuous.refl μ).smul d) s' fun x hx =>
        hd x hx.1

## References #

- [B. S. Morozov, A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][morozov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M. V. Klibanov, Inverse problems][osipov1984]
- [A. M. Osipov, A. A. Tikhomirov, M.

Attempt failure.

---63/100---
For theorem VitaliFamily.mul_measure_le_of_subset_lt_limRatioMeas in Mathlib/MeasureTheory/Covering/Differentiation.lean:
theorem mul_measure_le_of_subset_lt_limRatioMeas {q : ℝ≥0} {s : Set α}
    (h : s ⊆ {x | (q : ℝ≥0∞) < v.limRatioMeas hρ x}) : (q : ℝ≥0∞) * μ s ≤ ρ s 


Original valid proof:
:= by
  let t := {x : α | Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 (v.limRatioMeas hρ x))}
  have A : μ tᶜ = 0 := v.ae_tendsto_limRatioMeas hρ
  suffices H : (q • μ) (s ∩ t) ≤ ρ (s ∩ t) by calc
    (q • μ) s = (q • μ) (s ∩ t ∪ s ∩ tᶜ) := by rw [inter_union_compl]
    _ ≤ (q • μ) (s ∩ t) + (q • μ) (s ∩ tᶜ) := measure_union_le _ _
    _ ≤ ρ (s ∩ t) + (q • μ) tᶜ := by gcongr; apply inter_subset_right
    _ = ρ (s ∩ t) := by simp [A]
    _ ≤ ρ s := by gcongr; apply inter_subset_left
  refine v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ ?_
  intro x hx
  have I : ∀ᶠ a in v.filterAt x, (q : ℝ≥0∞) < ρ a / μ a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le


Verifying proof (Commit 8c8242bc14c6eb4639762e675985d5599fb35a5c):
 := by
  let t := {x : α | Tendsto (fun a => ρ a / μ a) (v.filterAt x) (𝓝 (v.limRatioMeas hρ x))}
  have A : μ tᶜ = 0 := v.ae_tendsto_limRatioMeas hρ
  suffices H : (q • μ) (s ∩ t) ≤ ρ (s ∩ t);
  exact
    calc
      (q • μ) s = (q • μ) (s ∩ t ∪ s ∩ tᶜ) := by rw [inter_union_compl]
      _ ≤ (q • μ) (s ∩ t) + (q • μ) (s ∩ tᶜ) := (measure_union_le _ _)
      _ ≤ ρ (s ∩ t) + (q • μ) tᶜ := by gcongr; apply inter_subset_right
      _ = ρ (s ∩ t) := by simp [A]
      _ ≤ ρ s := by gcongr; apply inter_subset_left
  refine' v.measure_le_of_frequently_le _ (AbsolutelyContinuous.rfl.smul _) _ _
  intro x hx
  have I : ∀ᶠ a in v.filterAt x, (q : ℝ≥0∞) < ρ a / μ a := (tendsto_order.1 hx.2).1 _ (h hx.1)
  apply I.frequently.mono fun a ha => ?_
  rw [coe_nnreal_smul_apply]
  exact ENNReal.mul_le_of_le_div ha.le

## 1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Hausdorff.lean - 2024-09-07 12:56:02.024316.
---64/100---
For theorem MeasureTheory.OuterMeasure.mkMetric'.trim_pre in Mathlib/MeasureTheory/Measure/Hausdorff.lean:
theorem trim_pre [MeasurableSpace X] [OpensMeasurableSpace X] (m : Set X → ℝ≥0∞)
    (hcl : ∀ s, m (closure s) = m s) (r : ℝ≥0∞) : (pre m r).trim = pre m r 


Original valid proof:
:= by
  refine le_antisymm (le_pre.2 fun s hs => ?_) (le_trim _)
  rw [trim_eq_iInf]
  refine iInf_le_of_le (closure s) <| iInf_le_of_le subset_closure <|
    iInf_le_of_le measurableSet_closure ((pre_le ?_).trans_eq (hcl _))
  rwa [diam_closure]


Verifying proof (Commit ced4d3c0af763b9fd00166e49cf999cf46c891cc):
 := by
  refine le_antisymm (le_pre.2 fun s hs => _) (le_trim _)
  rw [trim_eq_iInf]
  refine iInf_le_of_le (closure s) <| iInf_le_of_le subset_closure <|
    iInf_le_of_le measurableSet_closure ((pre_le _).trans_eq (hcl _))
  rwa [diam_closure]

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

####  Eric Wieser (Jun 01 2020 at 10:00):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure if it's a bug either.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure how to fix it either, but I'm not sure

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Portmanteau.lean - 2024-09-07 12:56:20.711709.
---65/100---
For theorem MeasureTheory.tendsto_of_forall_isOpen_le_liminf in Mathlib/MeasureTheory/Measure/Portmanteau.lean:
theorem tendsto_of_forall_isOpen_le_liminf {μ : ProbabilityMeasure Ω}
    {μs : ℕ → ProbabilityMeasure Ω}
    (h_opens : ∀ G, IsOpen G → μ G ≤ atTop.liminf (fun i ↦ μs i G)) :
    atTop.Tendsto (fun i ↦ μs i) (𝓝 μ) 


Original valid proof:
:= by
  refine ProbabilityMeasure.tendsto_iff_forall_integral_tendsto.mpr ?_
  apply tendsto_integral_of_forall_integral_le_liminf_integral
  intro f f_nn
  apply integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure (f := f) f_nn
  intro G G_open
  specialize h_opens G G_open
  have aux : ENNReal.ofNNReal (liminf (fun i ↦ μs i G) atTop) =
          liminf (ENNReal.ofNNReal ∘ fun i ↦ μs i G) atTop := by
    refine Monotone.map_liminf_of_continuousAt (F := atTop) ENNReal.coe_mono (μs · G) ?_ ?_ ?_
    · apply ENNReal.continuous_coe.continuousAt
    · use 1
      simp only [eventually_map, ProbabilityMeasure.apply_le_one, eventually_atTop, ge_iff_le,
        implies_true, forall_const, exists_const]
    · use 0
      simp only [zero_le, eventually_map, eventually_atTop, ge_iff_le, implies_true, forall_const,
        exists_const]
  have obs := ENNReal.coe_mono h_opens
  simp only [ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure, aux] at obs
  convert obs
  simp only [Function.comp_apply, ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 := by
  refine ProbabilityMeasure.tendsto_iff_forall_integral_tendsto.mpr ?_
  apply tendsto_integral_of_forall_integral_le_liminf_integral
  intro f f_nn
  apply integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure (f := f) f_nn
  intro G G_open
  specialize h_opens G G_open
  simp only at h_opens
  have aux : ENNReal.ofNNReal (liminf (fun i ↦ ENNReal.toNNReal ((μs i : Measure Ω) G)) atTop) =
          liminf (ENNReal.ofNNReal ∘ fun i ↦ (ENNReal.toNNReal ((μs i : Measure Ω) G))) atTop := by
    refine Monotone.map_liminf_of_continuousAt (F := atTop) ENNReal.coe_mono (μs · G) ?_ ?_ ?_
    · apply ENNReal.continuous_coe.continuousAt
    · use 1
      simp only [eventually_map, ProbabilityMeasure.apply_le_one, eventually_atTop, ge_iff_le,
        implies_true, forall_const, exists_const]
    · use 0
      simp only [zero_le, eventually_map, eventually_atTop, ge_iff_le, implies_true, forall_const,
        exists_const]
  have obs := ENNReal.coe_mono h_opens
  simp only [ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure, aux] at obs
  convert obs
  simp only [Function.comp_apply, ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure]


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































Attempt failure.

Working on Mathlib/MeasureTheory/Measure/ProbabilityMeasure.lean - 2024-09-07 12:56:33.028771.
---66/100---
For theorem ProbabilityMeasure.toFiniteMeasure_normalize_eq_self in Mathlib/MeasureTheory/Measure/ProbabilityMeasure.lean:
theorem _root_.ProbabilityMeasure.toFiniteMeasure_normalize_eq_self {m0 : MeasurableSpace Ω}
    (μ : ProbabilityMeasure Ω) : μ.toFiniteMeasure.normalize = μ 


Original valid proof:
:= by
  apply ProbabilityMeasure.eq_of_forall_apply_eq
  intro s _s_mble
  rw [μ.toFiniteMeasure.normalize_eq_of_nonzero μ.toFiniteMeasure_nonzero s]
  simp only [ProbabilityMeasure.mass_toFiniteMeasure, inv_one, one_mul, μ.coeFn_toFiniteMeasure]


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
 := by
  apply ProbabilityMeasure.eq_of_forall_apply_eq
  intro s _s_mble
  rw [μ.toFiniteMeasure.normalize_eq_of_nonzero μ.toFiniteMeasure_nonzero s]
  simp only [ProbabilityMeasure.mass_toFiniteMeasure, inv_one, one_mul]
  congr















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































Attempt failure.

Working on Mathlib/MeasureTheory/Measure/Sub.lean - 2024-09-07 12:56:52.715339.
---67/100---
For theorem MeasureTheory.Measure.sub_apply in Mathlib/MeasureTheory/Measure/Sub.lean:
theorem sub_apply [IsFiniteMeasure ν] (h₁ : MeasurableSet s) (h₂ : ν ≤ μ) :
    (μ - ν) s = μ s - ν s 


Original valid proof:
:= by
  let measure_sub : Measure α := MeasureTheory.Measure.ofMeasurable
    (fun (t : Set α) (_ : MeasurableSet t) => μ t - ν t) (by simp)
    (fun g h_meas h_disj ↦ by
      simp only [measure_iUnion h_disj h_meas]
      rw [ENNReal.tsum_sub _ (h₂ <| g ·)]
      rw [← measure_iUnion h_disj h_meas]
      apply measure_ne_top)
  have h_measure_sub_add : ν + measure_sub = μ := by
    ext1 t h_t_measurable_set
    simp only [Pi.add_apply, coe_add]
    rw [MeasureTheory.Measure.ofMeasurable_apply _ h_t_measurable_set, add_comm,
      tsub_add_cancel_of_le (h₂ t)]
  have h_measure_sub_eq : μ - ν = measure_sub := by
    rw [MeasureTheory.Measure.sub_def]
    apply le_antisymm
    · apply sInf_le
      simp [le_refl, add_comm, h_measure_sub_add]
    apply le_sInf
    intro d h_d
    rw [← h_measure_sub_add, mem_setOf_eq, add_comm d] at h_d
    apply Measure.le_of_add_le_add_left h_d
  rw [h_measure_sub_eq]
  apply Measure.ofMeasurable_apply _ h₁


Verifying proof (Commit 5c9c13df4643f68468a0f50fc217a3216ae6f8cc):
 := by
  let measure_sub : Measure α := MeasureTheory.Measure.ofMeasurable
    (fun (t : Set α) (_ : MeasurableSet t) => μ t - ν t) (by simp)
    (by
      intro g h_meas h_disj; simp only; rw [ENNReal.tsum_sub]
      repeat' rw [← MeasureTheory.measure_iUnion h_disj h_meas]
      exacts [MeasureTheory.measure_ne_top _ _, fun i => h₂ _ (h_meas _)])
  have h_measure_sub_add : ν + measure_sub = μ := by
    ext1 t h_t_measurable_set
    simp only [Pi.add_apply, coe_add]
    rw [MeasureTheory.Measure.ofMeasurable_apply _ h_t_measurable_set, add_comm,
      tsub_add_cancel_of_le (h₂ t h_t_measurable_set)]
  have h_measure_sub_eq : μ - ν = measure_sub := by
    rw [MeasureTheory.Measure.sub_def]
    apply le_antisymm
    · apply sInf_le
      simp [le_refl, add_comm, h_measure_sub_add]
    apply le_sInf
    intro d h_d
    rw [← h_measure_sub_add, mem_setOf_eq, add_comm d] at h_d
    apply Measure.le_of_add_le_add_left h_d
  rw [h_measure_sub_eq]
  apply Measure.ofMeasurable_apply _ h₁

## Your Answer

By clicking “Post Your Answer”, you agree to our terms of service, privacy policy and cookie policy

Attempt failure.

Working on Mathlib/MeasureTheory/Measure/WithDensityFinite.lean - 2024-09-07 12:57:00.836279.
---68/100---
For theorem MeasureTheory.toFinite_apply in Mathlib/MeasureTheory/Measure/WithDensityFinite.lean:
lemma toFinite_apply (μ : Measure α) [SFinite μ] (s : Set α) :
    μ.toFinite s = (μ.toFiniteAux Set.univ)⁻¹ * μ.toFiniteAux s 


Original valid proof:
:= by
  rw [Measure.toFinite, ProbabilityTheory.cond_apply _ MeasurableSet.univ, Set.univ_inter]


Verifying proof (Commit 4bc787e4cd27d5ae2ed300af7ae9e9f1c8480840):
 :=
begin
  rw [toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux, toFiniteAux,
    toFiniteAux, to

Attempt failure.

Working on Mathlib/NumberTheory/Cyclotomic/Rat.lean - 2024-09-07 12:57:12.318147.
---69/100---
For theorem IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime in Mathlib/NumberTheory/Cyclotomic/Rat.lean:
theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} ℚ K]
    (hζ : IsPrimitiveRoot ζ ↑(p ^ k)) : IsIntegralClosure (adjoin ℤ ({ζ} : Set K)) ℤ K 


Original valid proof:
:= by
  refine ⟨Subtype.val_injective, @fun x => ⟨fun h => ⟨⟨x, ?_⟩, rfl⟩, ?_⟩⟩
  swap
  · rintro ⟨y, rfl⟩
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hζ.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hζ.subOnePowerBasis ℚ
  have hint : IsIntegral ℤ B.gen := (hζ.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ℚ K
  have H := discr_mul_isIntegral_mem_adjoin ℚ hint h
  obtain ⟨u, n, hun⟩ := discr_prime_pow_eq_unit_mul_pow' hζ
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [← smul_assoc, ← smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ← Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  · haveI : IsCyclotomicExtension {1} ℚ K := by simpa using hcycl
    have : x ∈ (⊥ : Subalgebra ℚ K) := by
      rw [singleton_one ℚ K]
      exact mem_top
    obtain ⟨y, rfl⟩ := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ℚ K).injective).1 h
    obtain ⟨z, hz⟩ := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [← hz, ← IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  · have hmin : (minpoly ℤ B.gen).IsEisensteinAt (Submodule.span ℤ {((p : ℕ) : ℤ)}) := by
      have h₁ := minpoly.isIntegrallyClosed_eq_field_fractions' ℚ hint
      have h₂ := hζ.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h₁
      rw [h₁, ← map_cyclotomic_int, show Int.castRingHom ℚ = algebraMap ℤ ℚ by rfl,
        show X + 1 = map (algebraMap ℤ ℚ) (X + 1) by simp, ← map_comp] at h₂
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ℤ ℚ) (algebraMap ℤ ℚ).injective_int h₂]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ℤ _) (Subalgebra.one_mem _)


Verifying proof (Commit 7c8956d2555c8b18a57db0639fdd3f1eaa146759):
 := by
  refine' ⟨Subtype.val_injective, @fun x => ⟨fun h => ⟨⟨x, _⟩, rfl⟩, _⟩⟩
  swap
  · rintro ⟨y, rfl⟩
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hζ.isIntegral (p ^ k).pos)) _)
  let B := hζ.subOnePowerBasis ℚ
  have hint : IsIntegral ℤ B.gen := (hζ.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ℚ K
  have H := discr_mul_isIntegral_mem_adjoin ℚ hint h
  obtain ⟨u, n, hun⟩ := discr_prime_pow_eq_unit_mul_pow' hζ
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [← smul_assoc, ← smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ← Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, PNat.pow_coe, Nat.cast_pow, smul_def, map_pow] at H
  cases k
  · haveI : IsCyclotomicExtension {1} ℚ K := by simpa using hcycl
    have : x ∈ (⊥ : Subalgebra ℚ K) := by
      rw [singleton_one ℚ K]
      exact mem_top
    obtain ⟨y, rfl⟩ := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ℚ K).injective).1 h
    obtain ⟨z, hz⟩ := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [← hz, ← IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  · have hmin : (minpoly ℤ B.gen).IsEisensteinAt (Submodule.span ℤ {((p : ℕ) : ℤ)}) := by
      have h₁ := minpoly.isIntegrallyClosed_eq_field_fractions' ℚ hint
      have h₂ := hζ.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h₁
      rw [h₁, ← map_cyclotomic_int, show Int.castRingHom ℚ = algebraMap ℤ ℚ by rfl,
        show X + 1 = map (algebraMap ℤ ℚ) (X + 1) by simp, ← map_comp] at h₂
      haveI : CharZero ℚ := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ℤ ℚ) (algebraMap ℤ ℚ).injective_int h₂]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ℤ _) (Subalgebra.one_mem _)

## References #

- [J. Neukirch, A. Schmidt, K. Wingberg, Cohomology of Number Fields][Neukirch1999]

## Tags #

cyclotomic extension, is_integral, is_integral_closure

theorem IsPrimitiveRoot.minpoly_sub_one_eq_cyclotomic_comp {n : ℕ+} (hn : Fact (Nat.Prime n)) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑n) (hζ_irred : Irreducible (minpoly ℚ ζ)) :

minpoly ℚ (ζ - 1) = (cyclotomic n ℚ).comp (X + 1)

theorem discr_prime_pow_eq_unit_mul_pow' {n : ℕ+} (hn : Fact (Nat.Prime n)) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑n) (hζ_irred : Irreducible (minpoly ℚ ζ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * ↑(n ^ (n : ℕ))

theorem discr_prime_pow_eq_unit_mul_pow {n : ℕ+} (hn : Fact (Nat.Prime n)) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑n) (hζ_irred : Irreducible (minpoly ℚ ζ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * ↑(n ^ (n : ℕ))

theorem discr_prime_pow_eq_unit_mul_pow_of_cyclotomic_irreducible {n : ℕ+} (hn : Fact (Nat.Prime n)) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑n) (hζ_irred : Irreducible (cyclotomic ↑n ℚ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * ↑(n ^ (n : ℕ))

theorem discr_prime_pow_eq_unit_mul_pow_of_cyclotomic_irreducible' {n : ℕ+} (hn : Fact (Nat.Prime n)) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑n) (hζ_irred : Irreducible (cyclotomic ↑n ℚ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * ↑(n ^ (n : ℕ))

theorem discr_prime_pow_eq_unit_mul_pow_of_cyclotomic_irreducible'' {n : ℕ+} (hn : Fact (Nat.Prime n)) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑n) (hζ_irred : Irreducible (cyclotomic ↑n ℚ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * ↑(n ^ (n : ℕ))

theorem discr_prime_pow_eq_unit_mul_pow_of_cyclotomic_irreducible''' {n : ℕ+} (hn : Fact (Nat.Prime n)) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑n) (hζ_irred : Irreducible (cyclotomic ↑n ℚ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * ↑(n ^ (n : ℕ))

theorem discr_prime_pow_eq_unit_mul_pow_of_cyclotomic_irreducible

Attempt failure.

---70/100---
For theorem IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime in Mathlib/NumberTheory/Cyclotomic/Rat.lean:
theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} ℚ K]
    (hζ : IsPrimitiveRoot ζ ↑(p ^ k)) : IsIntegralClosure (adjoin ℤ ({ζ} : Set K)) ℤ K 


Original valid proof:
:= by
  refine ⟨Subtype.val_injective, @fun x => ⟨fun h => ⟨⟨x, ?_⟩, rfl⟩, ?_⟩⟩
  swap
  · rintro ⟨y, rfl⟩
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hζ.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hζ.subOnePowerBasis ℚ
  have hint : IsIntegral ℤ B.gen := (hζ.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ℚ K
  have H := discr_mul_isIntegral_mem_adjoin ℚ hint h
  obtain ⟨u, n, hun⟩ := discr_prime_pow_eq_unit_mul_pow' hζ
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [← smul_assoc, ← smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ← Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  · haveI : IsCyclotomicExtension {1} ℚ K := by simpa using hcycl
    have : x ∈ (⊥ : Subalgebra ℚ K) := by
      rw [singleton_one ℚ K]
      exact mem_top
    obtain ⟨y, rfl⟩ := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ℚ K).injective).1 h
    obtain ⟨z, hz⟩ := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [← hz, ← IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  · have hmin : (minpoly ℤ B.gen).IsEisensteinAt (Submodule.span ℤ {((p : ℕ) : ℤ)}) := by
      have h₁ := minpoly.isIntegrallyClosed_eq_field_fractions' ℚ hint
      have h₂ := hζ.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h₁
      rw [h₁, ← map_cyclotomic_int, show Int.castRingHom ℚ = algebraMap ℤ ℚ by rfl,
        show X + 1 = map (algebraMap ℤ ℚ) (X + 1) by simp, ← map_comp] at h₂
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ℤ ℚ) (algebraMap ℤ ℚ).injective_int h₂]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ℤ _) (Subalgebra.one_mem _)


Verifying proof (Commit 2a90eb4867f981311713f9efea480617e45964b9):
 := by
  refine' ⟨Subtype.val_injective, @fun x => ⟨fun h => ⟨⟨x, _⟩, rfl⟩, _⟩⟩
  swap
  · rintro ⟨y, rfl⟩
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hζ.isIntegral (p ^ k).pos)) _)
  let B := hζ.subOnePowerBasis ℚ
  have hint : IsIntegral ℤ B.gen := isIntegral_sub (hζ.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ℚ K
  have H := discr_mul_isIntegral_mem_adjoin ℚ hint h
  obtain ⟨u, n, hun⟩ := discr_prime_pow_eq_unit_mul_pow' hζ
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [← smul_assoc, ← smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ← Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, PNat.pow_coe, Nat.cast_pow, smul_def, map_pow] at H
  cases k
  · haveI : IsCyclotomicExtension {1} ℚ K := by simpa using hcycl
    have : x ∈ (⊥ : Subalgebra ℚ K) := by
      rw [singleton_one ℚ K]
      exact mem_top
    obtain ⟨y, rfl⟩ := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ℚ K).injective).1 h
    obtain ⟨z, hz⟩ := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [← hz, ← IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  · have hmin : (minpoly ℤ B.gen).IsEisensteinAt (Submodule.span ℤ {((p : ℕ) : ℤ)}) := by
      have h₁ := minpoly.isIntegrallyClosed_eq_field_fractions' ℚ hint
      have h₂ := hζ.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h₁
      rw [h₁, ← map_cyclotomic_int, show Int.castRingHom ℚ = algebraMap ℤ ℚ by rfl,
        show X + 1 = map (algebraMap ℤ ℚ) (X + 1) by simp, ← map_comp] at h₂
      haveI : CharZero ℚ := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ℤ ℚ) (algebraMap ℤ ℚ).injective_int h₂]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ℤ _) (Subalgebra.one_mem _)

## References #

- [J. Neukirch, A. Schmidt, K. Wingberg, Cohomology of Number Fields][Neukirch1999]

## Tags #

cyclotomic extension, is_integral, is_integral_closure

theorem IsPrimitiveRoot.minpoly_sub_one_eq_cyclotomic_comp {n : ℕ+} (hpos : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ n) (hζ_irred : Irreducible (minpoly ℚ ζ)) :

minpoly ℚ (ζ - 1) = (minpoly ℚ ζ).comp (X + 1)

theorem discr_prime_pow_eq_unit_mul_pow' {n : ℕ+} (hpos : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ n) (hζ_irred : Irreducible (minpoly ℚ ζ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * ↑(n ^ (n : ℕ))

theorem discr_prime_pow_eq_unit_mul_pow {n : ℕ+} (hpos : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ n) (hζ_irred : Irreducible (minpoly ℚ ζ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * ↑(n ^ (n : ℕ))

theorem discr_prime_pow_eq_unit_mul_pow {n : ℕ+} (hpos : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ n) (hζ_irred : Irreducible (minpoly ℚ ζ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * ↑(n ^ (n : ℕ))

theorem discr_prime_pow_eq_unit_mul_pow {n : ℕ+} (hpos : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ n) (hζ_irred : Irreducible (minpoly ℚ ζ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * ↑(n ^ (n : ℕ))

theorem discr_prime_pow_eq_unit_mul_pow {n : ℕ+} (hpos : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ n) (hζ_irred : Irreducible (minpoly ℚ ζ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * ↑(n ^ (n : ℕ))

theorem discr_prime_pow_eq_unit_mul_pow {n : ℕ+} (hpos : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ n) (hζ_irred : Irreducible (minpoly ℚ ζ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * ↑(n ^ (n : ℕ))

theorem discr_prime_pow_eq_unit_mul_pow {n : ℕ+} (hpos : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ n) (hζ_irred : Irreducible (minpoly ℚ ζ)) :

∃ u : 

Attempt failure.

---71/100---
For theorem IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime in Mathlib/NumberTheory/Cyclotomic/Rat.lean:
theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} ℚ K]
    (hζ : IsPrimitiveRoot ζ ↑(p ^ k)) : IsIntegralClosure (adjoin ℤ ({ζ} : Set K)) ℤ K 


Original valid proof:
:= by
  refine ⟨Subtype.val_injective, @fun x => ⟨fun h => ⟨⟨x, ?_⟩, rfl⟩, ?_⟩⟩
  swap
  · rintro ⟨y, rfl⟩
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hζ.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hζ.subOnePowerBasis ℚ
  have hint : IsIntegral ℤ B.gen := (hζ.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ℚ K
  have H := discr_mul_isIntegral_mem_adjoin ℚ hint h
  obtain ⟨u, n, hun⟩ := discr_prime_pow_eq_unit_mul_pow' hζ
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [← smul_assoc, ← smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ← Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  · haveI : IsCyclotomicExtension {1} ℚ K := by simpa using hcycl
    have : x ∈ (⊥ : Subalgebra ℚ K) := by
      rw [singleton_one ℚ K]
      exact mem_top
    obtain ⟨y, rfl⟩ := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ℚ K).injective).1 h
    obtain ⟨z, hz⟩ := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [← hz, ← IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  · have hmin : (minpoly ℤ B.gen).IsEisensteinAt (Submodule.span ℤ {((p : ℕ) : ℤ)}) := by
      have h₁ := minpoly.isIntegrallyClosed_eq_field_fractions' ℚ hint
      have h₂ := hζ.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h₁
      rw [h₁, ← map_cyclotomic_int, show Int.castRingHom ℚ = algebraMap ℤ ℚ by rfl,
        show X + 1 = map (algebraMap ℤ ℚ) (X + 1) by simp, ← map_comp] at h₂
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ℤ ℚ) (algebraMap ℤ ℚ).injective_int h₂]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ℤ _) (Subalgebra.one_mem _)


Verifying proof (Commit 40b64f797572a7615ba4553a28d3d6ee5049aa3b):
 := by
  refine' ⟨Subtype.val_injective, @fun x => ⟨fun h => ⟨⟨x, _⟩, rfl⟩, _⟩⟩
  swap
  · rintro ⟨y, rfl⟩
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hζ.isIntegral (p ^ k).pos)) _)
  let B := hζ.subOnePowerBasis ℚ
  have hint : IsIntegral ℤ B.gen := IsIntegral.sub (hζ.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} ℚ K
  have H := discr_mul_isIntegral_mem_adjoin ℚ hint h
  obtain ⟨u, n, hun⟩ := discr_prime_pow_eq_unit_mul_pow' hζ
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [← smul_assoc, ← smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, ← Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  · haveI : IsCyclotomicExtension {1} ℚ K := by simpa using hcycl
    have : x ∈ (⊥ : Subalgebra ℚ K) := by
      rw [singleton_one ℚ K]
      exact mem_top
    obtain ⟨y, rfl⟩ := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap ℚ K).injective).1 h
    obtain ⟨z, hz⟩ := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [← hz, ← IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  · have hmin : (minpoly ℤ B.gen).IsEisensteinAt (Submodule.span ℤ {((p : ℕ) : ℤ)}) := by
      have h₁ := minpoly.isIntegrallyClosed_eq_field_fractions' ℚ hint
      have h₂ := hζ.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at h₁
      rw [h₁, ← map_cyclotomic_int, show Int.castRingHom ℚ = algebraMap ℤ ℚ by rfl,
        show X + 1 = map (algebraMap ℤ ℚ) (X + 1) by simp, ← map_comp] at h₂
      haveI : CharZero ℚ := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap ℤ ℚ) (algebraMap ℤ ℚ).injective_int h₂]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton ℤ _) (Subalgebra.one_mem _)

## References #

- [J. Neukirch, A. Schmidt, K. Wingberg, Cohomology of Number Fields][NeukirchSchmidtWingberg]

## Tags #

cyclotomic extension, is_integral, is_integral_closure

theorem IsPrimitiveRoot.minpoly_sub_one_eq_cyclotomic_comp {n : ℕ} (hn : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ n) (hcycl : IsCyclotomicExtension {n} ℚ K) :

minpoly ℤ ζ.subOnePowerBasis.gen = (cyclotomic n ℤ).comp (X + 1)

theorem discr_prime_pow_eq_unit_mul_pow' {n : ℕ} (hn : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑n) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * (↑n ^ (n - 1) * (n - 1)! ^ 2)

theorem discr_prime_pow_eq_unit_mul_pow {n : ℕ} (hn : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑n) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * (↑n ^ (n - 1) * (n - 1)! ^ 2)

theorem discr_prime_pow_eq_unit_mul_pow_of_cyclotomic_irreducible {n : ℕ} (hn : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑n) (hcycl : IsCyclotomicExtension {n} ℚ K) (hcycl_irred : Irreducible (cyclotomic n ℤ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * (↑n ^ (n - 1) * (n - 1)! ^ 2)

theorem discr_prime_pow_eq_unit_mul_pow_of_cyclotomic_irreducible' {n : ℕ} (hn : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑n) (hcycl : IsCyclotomicExtension {n} ℚ K) (hcycl_irred : Irreducible (cyclotomic n ℤ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * (↑n ^ (n - 1) * (n - 1)! ^ 2)

theorem discr_prime_pow_eq_unit_mul_pow_of_cyclotomic_irreducible'' {n : ℕ} (hn : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑n) (hcycl : IsCyclotomicExtension {n} ℚ K) (hcycl_irred : Irreducible (cyclotomic n ℤ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ) = ↑u * (↑n ^ (n - 1) * (n - 1)! ^ 2)

theorem discr_prime_pow_eq_unit_mul_pow_of_cyclotomic_irreducible''' {n : ℕ} (hn : 0 < n) {K : Type u_1} [Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑n) (hcycl : IsCyclotomicExtension {n} ℚ K) (hcycl_irred : Irreducible (cyclotomic n ℤ)) :

∃ u : ℤˣ, discr ℤ (hζ.subOnePowerBasis ℚ

Attempt failure.

Working on Mathlib/NumberTheory/EllipticDivisibilitySequence.lean - 2024-09-07 12:58:49.526577.
---72/100---
For theorem normEDS_two in Mathlib/NumberTheory/EllipticDivisibilitySequence.lean:
lemma normEDS_two : normEDS b c d 2 = b 


Original valid proof:
:= by
  erw [normEDS_ofNat, preNormEDS'_two, one_mul, if_pos even_two]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  erw [normEDS, Int.cast_one, one_mul, normEDS'_two]

## 1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1

Attempt failure.

---73/100---
For theorem normEDS_two in Mathlib/NumberTheory/EllipticDivisibilitySequence.lean:
lemma normEDS_two : normEDS b c d 2 = b 


Original valid proof:
:= by
  erw [normEDS_ofNat, preNormEDS'_two, one_mul, if_pos even_two]


Verifying proof (Commit 9abf5def655e0d44fd16e9b8b243b67025e7776f):
 := by
  erw [normEDS_ofNat, normEDS'_two]

## 2 Answers

0

On

I think the problem is thatnormEDS_ofNat is not a simp lemma.

0

On

I think the problem is thatnormEDS_ofNat is not a simp lemma.

I'm not sure what you mean by that. I've addednormEDS_ofNat to the simp set and it still doesn't work.

Attempt failure.

Working on Mathlib/NumberTheory/EulerProduct/Basic.lean - 2024-09-07 12:59:10.192407.
---74/100---
For theorem EulerProduct.eulerProduct_tprod in Mathlib/NumberTheory/EulerProduct/Basic.lean:
theorem eulerProduct_tprod (hsum : Summable (‖f ·‖)) (hf₀ : f 0 = 0) :
    ∏' p : Primes, ∑' e, f (p ^ e) = ∑' n, f n 


Original valid proof:
:=
  (eulerProduct_hasProd hf₁ hmul hsum hf₀).tprod_eq


Verifying proof (Commit 19cfe36a7ab0262701db2043cd019a1861daadc8):
 :=
begin
  rw ← tsum_prod,
  { rw tsum_eq_tsum_of_ne_zero_bdd_above,
    { rw tsum_eq_tsum_of_ne_zero_bdd_above,
      { rw tsum_eq_tsum_of_ne_zero_bdd_above,
        { rw tsum_eq_tsum_of_ne_zero_bdd_above,
          { rw tsum_eq_tsum_of_ne_zero_bdd_above,
            { rw tsum_eq_tsum_of_ne_zero_bdd_above,
              { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                  { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                    { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                      { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                        { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                          { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                            { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                              { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                  { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                    { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                      { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                        { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                          { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                            { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                              { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                  { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                    { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                      { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                        { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                          { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                            { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                              { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                  { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                    { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                      { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                        { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                          { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                            { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                              { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                  { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                    { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                      { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                        { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                          { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                            { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                              { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                  { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                    { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                      { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                        { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                          { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                            { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                              { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                  { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                    { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                      { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                        { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                          { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                            { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                              { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                  { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                    { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                      { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                        { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                          { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                            { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                              { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                  { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                    { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                      { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                        { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                          { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                            { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                              { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                                { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                                  { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                                    { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                                      { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                                        { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                                          { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                                            { rw tsum_eq_tsum_of_ne_zero_bdd_above,
                                                                                                                                                                              {

Attempt failure.

Working on Mathlib/NumberTheory/NumberField/CanonicalEmbedding/Basic.lean - 2024-09-07 12:59:19.500029.
---75/100---
For theorem NumberField.mixedEmbedding.commMap_canonical_eq_mixed in Mathlib/NumberTheory/NumberField/CanonicalEmbedding/Basic.lean:
theorem commMap_canonical_eq_mixed (x : K) :
    commMap K (canonicalEmbedding K x) = mixedEmbedding K x 


Original valid proof:
:= by
  simp only [canonicalEmbedding, commMap, LinearMap.coe_mk, AddHom.coe_mk, Pi.ringHom_apply,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq]
  exact ⟨rfl, rfl⟩


Verifying proof (Commit 45c652ea0d1ef0a45000968c46b39861e6e4f2a2):
 := by
  simp only [canonicalEmbedding, commMap, LinearMap.coe_mk, AddHom.coe_mk, Pi.ringHom_apply,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq]
  ext1
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.comp_apply, RingHom.coe_coe, canonicalEmbedding,
    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq, RingHom.id_apply]
  simp only [RingHom.coe_comp, Function.

Attempt failure.

Working on Mathlib/NumberTheory/Pell.lean - 2024-09-07 12:59:54.887156.
---76/100---
For theorem Pell.Solution₁.exists_pos_of_not_isSquare in Mathlib/NumberTheory/Pell.lean:
theorem exists_pos_of_not_isSquare (h₀ : 0 < d) (hd : ¬IsSquare d) :
    ∃ a : Solution₁ d, 1 < a.x ∧ 0 < a.y 


Original valid proof:
:= by
  obtain ⟨x, y, h, hy⟩ := exists_of_not_isSquare h₀ hd
  refine ⟨mk |x| |y| (by rwa [sq_abs, sq_abs]), ?_, abs_pos.mpr hy⟩
  rw [x_mk, ← one_lt_sq_iff_one_lt_abs, eq_add_of_sub_eq h, lt_add_iff_pos_right]
  exact mul_pos h₀ (sq_pos_of_ne_zero hy)


Verifying proof (Commit 2edc8bf32ccf16fde8f412b6f759abedf7011157):
∧ a.x ≠ 0 := by
  obtain ⟨x, y, h, hy⟩ := exists_of_not_isSquare h₀ hd
  refine' ⟨mk (|x|) (|y|) (by rwa [sq_abs, sq_abs]), _, abs_pos.mpr hy, _⟩
  rw [x_mk, ← one_lt_sq_iff_one_lt_abs, eq_add_of_sub_eq h, lt_add_iff_pos_right]
  exact mul_pos h₀ (sq_pos_of_ne_zero y hy)

## Your Answer

By clicking “Post Your Answer”, you agree to our terms of service, privacy policy and cookie policy

Attempt failure.

Working on Mathlib/NumberTheory/SumTwoSquares.lean - 2024-09-07 13:00:15.451745.
---77/100---
For theorem ZMod.isSquare_neg_one_iff' in Mathlib/NumberTheory/SumTwoSquares.lean:
theorem ZMod.isSquare_neg_one_iff' {n : ℕ} (hn : Squarefree n) :
    IsSquare (-1 : ZMod n) ↔ ∀ {q : ℕ}, q ∣ n → q % 4 ≠ 3 


Original valid proof:
:= by
  have help : ∀ a b : ZMod 4, a ≠ 3 → b ≠ 3 → a * b ≠ 3 := by decide
  rw [ZMod.isSquare_neg_one_iff hn]
  refine ⟨?_, fun H q _ => H⟩
  intro H
  refine @induction_on_primes _ ?_ ?_ (fun p q hp hq hpq => ?_)
  · exact fun _ => by norm_num
  · exact fun _ => by norm_num
  · replace hp := H hp (dvd_of_mul_right_dvd hpq)
    replace hq := hq (dvd_of_mul_left_dvd hpq)
    rw [show 3 = 3 % 4 by norm_num, Ne, ← ZMod.natCast_eq_natCast_iff'] at hp hq ⊢
    rw [Nat.cast_mul]
    exact help p q hp hq


Verifying proof (Commit d664a4757e1d5d6999ae3ca588b989e1039faee2):
∧ q ≠ 0 := by
  have help : ∀ a b : ZMod 4, a ≠ 3 → b ≠ 3 → a * b ≠ 3 := by decide
  rw [ZMod.isSquare_neg_one_iff hn]
  refine' ⟨_, fun H q _ => H.1⟩
  intro H
  refine' @induction_on_primes _ _ _ (fun p q hp hq hpq => _)
  · exact fun _ => by norm_num
  · exact fun _ => by norm_num
  · replace hp := H hp (dvd_of_mul_right_dvd hpq)
    replace hq := hq (dvd_of_mul_left_dvd hpq)
    rw [show 3 = 3 % 4 by norm_num, Ne.def, ← ZMod.nat_cast_eq_nat_cast_iff'] at hp hq ⊢
    rw [Nat.cast_mul]
    exact help p q hp hq

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due to their size.

## Equations

- One or more equations did not get rendered due

Attempt failure.

Working on Mathlib/Order/CompactlyGenerated/Basic.lean - 2024-09-07 13:00:28.720018.
---78/100---
For theorem CompleteLattice.independent_iff_supIndep_of_injOn in Mathlib/Order/CompactlyGenerated/Basic.lean:
lemma CompleteLattice.independent_iff_supIndep_of_injOn {ι : Type*} {f : ι → α}
    (hf : InjOn f {i | f i ≠ ⊥}) :
    CompleteLattice.Independent f ↔ ∀ (s : Finset ι), s.SupIndep f 


Original valid proof:
:= by
  refine ⟨fun h ↦ h.supIndep', fun h ↦ CompleteLattice.independent_def'.mpr fun i ↦ ?_⟩
  simp_rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot, ← disjoint_iff]
  intro s hs
  classical
  rw [← Finset.sup_erase_bot]
  set t := s.erase ⊥
  replace hf : InjOn f (f ⁻¹' t) := fun i hi j _ hij ↦ by
    refine hf ?_ ?_ hij <;> aesop (add norm simp [t])
  have : (Finset.erase (insert i (t.preimage _ hf)) i).image f = t := by
    ext a
    simp only [Finset.mem_preimage, Finset.mem_erase, ne_eq, Finset.mem_insert, true_or, not_true,
      Finset.erase_insert_eq_erase, not_and, Finset.mem_image, t]
    refine ⟨by aesop, fun ⟨ha, has⟩ ↦ ?_⟩
    obtain ⟨j, hj, rfl⟩ := hs has
    exact ⟨j, ⟨hj, ha, has⟩, rfl⟩
  rw [← this, Finset.sup_image]
  specialize h (insert i (t.preimage _ hf))
  rw [Finset.supIndep_iff_disjoint_erase] at h
  exact h i (Finset.mem_insert_self i _)


Verifying proof (Commit ccc27e7ac9e260c68eb4566eddafc1ab1d22d6e1):
 := by
  refine ⟨fun h ↦ h.supIndep', fun h ↦ CompleteLattice.independent_def'.mpr fun i ↦ ?_⟩
  simp_rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot, ← disjoint_iff]
  intro s hs
  classical
  rw [← Finset.sup_erase_bot]
  set t := s.erase ⊥
  replace hf : InjOn f (f ⁻¹' t) := fun i hi j _ hij ↦ by
    refine hf ?_ ?_ hij <;> aesop (add norm simp [t])
  have : (Finset.erase (insert i (t.preimage _ hf)) i).image f = t := by
    ext a
    simp only [Finset.mem_preimage, Finset.mem_erase, ne_eq, Finset.mem_insert, true_or, not_true,
      Finset.erase_insert_eq_erase, not_and, Finset.mem_image, t]
    refine ⟨by aesop, fun ⟨ha, has⟩ ↦ ?_⟩
    obtain ⟨j, hj, rfl⟩ := hs has
    exact ⟨j, ⟨hj, ha, has⟩, rfl⟩
  change Disjoint (f i) (Finset.sup __t id)
  rw [← this, Finset.sup_image]
  specialize h (insert i (__t.preimage _ hf))
  rw [Finset.supIndep_iff_disjoint_erase] at h
  exact h i (Finset.mem_insert_self i _)

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

## Proof

The proof is a simple application of the definition of `CompleteLattice.Independent`.

##

Attempt failure.

Working on Mathlib/Order/Filter/Lift.lean - 2024-09-07 13:00:37.286314.
---79/100---
For theorem Filter.HasBasis.mem_lift_iff in Mathlib/Order/Filter/Lift.lean:
theorem HasBasis.mem_lift_iff {ι} {p : ι → Prop} {s : ι → Set α} {f : Filter α}
    (hf : f.HasBasis p s) {β : ι → Type*} {pg : ∀ i, β i → Prop} {sg : ∀ i, β i → Set γ}
    {g : Set α → Filter γ} (hg : ∀ i, (g <| s i).HasBasis (pg i) (sg i)) (gm : Monotone g)
    {s : Set γ} : s ∈ f.lift g ↔ ∃ i, p i ∧ ∃ x, pg i x ∧ sg i x ⊆ s 


Original valid proof:
:= by
  refine (mem_biInf_of_directed ?_ ⟨univ, univ_sets _⟩).trans ?_
  · intro t₁ ht₁ t₂ ht₂
    exact ⟨t₁ ∩ t₂, inter_mem ht₁ ht₂, gm inter_subset_left, gm inter_subset_right⟩
  · simp only [← (hg _).mem_iff]
    exact hf.exists_iff fun t₁ t₂ ht H => gm ht H


Verifying proof (Commit 596865180ecc63dcd1d95809202e31027ac3ae38):
∧ s ⊆ g (s i) := by
  refine (mem_biInf_of_directed ?_ ⟨univ, univ_sets _⟩).trans ?_
  · intro t₁ ht₁ t₂ ht₂
    exact ⟨t₁ ∩ t₂, inter_mem ht₁ ht₂, gm <| inter_subset_left _ _, gm <| inter_subset_right _ _⟩
  · simp only [← (hg _).mem_iff]
    exact hf.exists_iff fun t₁ t₂ ht H => gm ht H

I think the problem is that the first proof is using the fact that `g` is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:00):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact thatg is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:00):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first proof is using the fact that
g is monotone, but the second proof is not.

####  Mario Carneiro (Mar 01 2021 at 08:01):

I think the problem is that the first proof is using the fact that
g is monotone, but the second proof is not.
I don't think that's the problem. The first

Attempt failure.

Working on Mathlib/Probability/Martingale/Upcrossing.lean - 2024-09-07 13:00:48.565549.
---80/100---
For theorem MeasureTheory.Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part in Mathlib/Probability/Martingale/Upcrossing.lean:
theorem Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part [IsFiniteMeasure μ] (a b : ℝ)
    (hf : Submartingale f ℱ μ) : ENNReal.ofReal (b - a) * ∫⁻ ω, upcrossings a b f ω ∂μ ≤
      ⨆ N, ∫⁻ ω, ENNReal.ofReal ((f N ω - a)⁺) ∂μ 


Original valid proof:
:= by
  by_cases hab : a < b
  · simp_rw [upcrossings]
    have : ∀ N, ∫⁻ ω, ENNReal.ofReal ((f N ω - a)⁺) ∂μ = ENNReal.ofReal (∫ ω, (f N ω - a)⁺ ∂μ) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      · exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      · exact eventually_of_forall fun ω => posPart_nonneg _
    rw [lintegral_iSup']
    · simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          ∫⁻ ω, upcrossingsBefore a b f N ω ∂μ = ∫⁻ ω, ↑(upcrossingsBefore a b f N ω : ℝ≥0) ∂μ),
        lintegral_coe_eq_integral, ← ENNReal.ofReal_mul (sub_pos.2 hab).le]
      · simp_rw [NNReal.coe_natCast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (α := ℝ≥0∞) _ N)
      · simp only [NNReal.coe_natCast, hf.adapted.integrable_upcrossingsBefore hab]
    · exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    · filter_upwards with ω N M hNM
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM ω
  · rw [not_lt, ← sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, zero_mul]
    exact zero_le _


Verifying proof (Commit 82ddb54f6cb64f727e412a60ecaa99a9dafaec2a):
 := by
  by_cases hab : a < b
  · simp_rw [upcrossings]
    have : ∀ N, ∫⁻ ω, ENNReal.ofReal ((f N ω - a)⁺) ∂μ = ENNReal.ofReal (∫ ω, (f N ω - a)⁺ ∂μ) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      · exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      · exact eventually_of_forall fun ω => LatticeOrderedGroup.pos_nonneg _
    rw [lintegral_iSup']
    · simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          ∫⁻ ω, upcrossingsBefore a b f N ω ∂μ = ∫⁻ ω, ↑(upcrossingsBefore a b f N ω : ℝ≥0) ∂μ),
        lintegral_coe_eq_integral, ← ENNReal.ofReal_mul (sub_pos.2 hab).le]
      · simp_rw [NNReal.coe_nat_cast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (α := ℝ≥0∞) _ N)
      · simp only [NNReal.coe_nat_cast, hf.adapted.integrable_upcrossingsBefore hab]
    · exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    · refine' eventually_of_forall fun ω N M hNM => _
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM ω
  · rw [not_lt, ← sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, zero_mul]
    exact zero_le _

## References #

- [Walter [1981]](https://www.jstor.org/stable/2240059)

## Tags #

martingale, submartingale, supermartingale, Doob's upcrossing lemma

### Doob's upcrossing lemma #

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value, plus one.

The Doob upcrossing estimate: the number of upcrossings of a submartingale is almost surely bounded by its ratio of final value to initial value,

Attempt failure.

Working on Mathlib/RepresentationTheory/Basic.lean - 2024-09-07 13:01:09.960597.
---81/100---
For theorem Representation.ofMulAction_single in Mathlib/RepresentationTheory/Basic.lean:
theorem ofMulAction_single (g : G) (x : H) (r : k) :
    ofMulAction k G H g (Finsupp.single x r) = Finsupp.single (g • x) r 


Original valid proof:
:=
  Finsupp.mapDomain_single


Verifying proof (Commit 3653352683804f7807e57f2b646e31b313359cff):
 := by
  simp only [ofMulAction, Finsupp.coe_smul, Pi.smul_apply, Finsupp.smul_single',
    Finsupp.smul_single, smul_eq_mul, mul_one]

####  Scott Morrison (Apr 01 2021 at 02:00):

I think the problem is that thesimp lemma is not in the simp set.

####  Scott Morrison (Apr 01 2021 at 02:00):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:01):

(I'm not sure what the best way to fix this is.)

####  Scott Morrison (Apr 01 2021 at 02:

Attempt failure.

Working on Mathlib/RingTheory/ChainOfDivisors.lean - 2024-09-07 13:01:26.558826.
---82/100---
For theorem DivisorChain.element_of_chain_eq_pow_second_of_chain in Mathlib/RingTheory/ChainOfDivisors.lean:
theorem element_of_chain_eq_pow_second_of_chain {q r : Associates M} {n : ℕ} (hn : n ≠ 0)
    {c : Fin (n + 1) → Associates M} (h₁ : StrictMono c) (h₂ : ∀ {r}, r ≤ q ↔ ∃ i, r = c i)
    (hr : r ∣ q) (hq : q ≠ 0) : ∃ i : Fin (n + 1), r = c 1 ^ (i : ℕ) 


Original valid proof:
:= by
  classical
    let i := Multiset.card (normalizedFactors r)
    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by
      apply Multiset.eq_replicate_of_mem
      intro b hb
      refine
        eq_second_of_chain_of_prime_dvd hn h₁ (@fun r' => h₂) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalizedFactors hb)
    have H : r = c 1 ^ i := by
      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)
      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this
      rw [this]
    refine ⟨⟨i, ?_⟩, H⟩
    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ℕ)).card = i + 1 := by
      conv_rhs => rw [← Finset.card_fin (i + 1)]
      cases n
      · contradiction
      rw [Finset.card_image_iff]
      refine Set.injOn_of_injective (fun m m' h => Fin.ext ?_)
      refine
        pow_injective_of_not_unit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h₁) ?_ h
      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h₁ (@h₂) hq)
    suffices H' : ∀ r ∈ Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ℕ), r ≤ q by
      simp only [← Nat.succ_le_iff, Nat.succ_eq_add_one, ← this]
      apply card_subset_divisors_le_length_of_chain (@h₂) H'
    simp only [Finset.mem_image]
    rintro r ⟨a, _, rfl⟩
    refine dvd_trans ?_ hr
    use c 1 ^ (i - (a : ℕ))
    rw [pow_mul_pow_sub (c 1)]
    · exact H
    · exact Nat.succ_le_succ_iff.mp a.2


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
 := by
  classical
    let i := Multiset.card (normalizedFactors r)
    have hi : normalizedFactors r = Multiset.replicate i (c 1) := by
      apply Multiset.eq_replicate_of_mem
      intro b hb
      refine'
        eq_second_of_chain_of_prime_dvd hn h₁ (@fun r' => h₂) (prime_of_normalized_factor b hb) hr
          (dvd_of_mem_normalizedFactors hb)
    have H : r = c 1 ^ i := by
      have := UniqueFactorizationMonoid.normalizedFactors_prod (ne_zero_of_dvd_ne_zero hq hr)
      rw [associated_iff_eq, hi, Multiset.prod_replicate] at this
      rw [this]
    refine ⟨⟨i, ?_⟩, H⟩
    have : (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ℕ)).card = i + 1 := by
      conv_rhs => rw [← Finset.card_fin (i + 1)]
      cases n
      · contradiction
      rw [Finset.card_image_iff]
      refine' Set.injOn_of_injective (fun m m' h => Fin.ext _) _
      refine'
        pow_injective_of_not_unit (element_of_chain_not_isUnit_of_index_ne_zero (by simp) h₁) _ h
      exact Irreducible.ne_zero (second_of_chain_is_irreducible hn h₁ (@h₂) hq)
    suffices H' : ∀ r ∈ Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ℕ), r ≤ q by
      simp only [← Nat.succ_le_iff, Nat.succ_eq_add_one, ← this]
      apply card_subset_divisors_le_length_of_chain (@h₂) H'
    simp only [Finset.mem_image]
    rintro r ⟨a, _, rfl⟩
    refine' dvd_trans _ hr
    use c 1 ^ (i - (a : ℕ))
    rw [pow_mul_pow_sub (c 1)]
    · exact H
    · exact Nat.succ_le_succ_iff.mp a.2

## 1.2.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.

Attempt failure.

Working on Mathlib/RingTheory/Localization/Basic.lean - 2024-09-07 13:01:37.453243.
---83/100---
For theorem Localization.neg_mk in Mathlib/RingTheory/Localization/Basic.lean:
theorem neg_mk (a b) : -(mk a b : Localization M) = mk (-a) b 


Original valid proof:
:= by
  show Localization.neg (mk a b) = mk (-a) b
  rw [Localization.neg_def]
  apply liftOn_mk


Verifying proof (Commit e8b31359b48045c7bc8570e6e21659333f48f568):
 :=
begin
  rw [OreLocalization.neg_def, OreLocalization.neg_def],
  simp,
end

## Equations

- OreLocalization.instAddOreLocalization = { add := fun x y => mk (OreLocalization.add_aux x y) (OreLocalization.add_denom x y), add_assoc := OreLocalization.instAddOreLocalization._proof_1, zero := mk 0 1, zero_add := OreLocalization.instAddOreLocalization._proof_2, add_zero := OreLocalization.instAddOreLocalization._proof_3, nsmul := AddMonoid.nsmul._default (mk 0 1) (fun x y => mk (OreLocalization.add_aux x y) (OreLocalization.add_denom x y)) OreLocalization.instAddOreLocalization._proof_4 OreLocalization.instAddOreLocalization._proof_5 OreLocalization.instAddOreLocalization._proof_6, nsmul_zero' := OreLocalization.instAddOreLocalization._proof_7, nsmul_succ' := OreLocalization.instAddOreLocalization._proof_8, add_comm := OreLocalization.instAddOreLocalization._proof_9 }

## Equations

- OreLocalization.instNegOreLocalization = { neg := fun x => mk (-OreLocalization.neg_aux x) (OreLocalization.neg_denom x), neg_neg := OreLocalization.instNegOreLocalization._proof_1, neg_zero := OreLocalization.instNegOreLocalization._proof_2, sub_eq_add_neg := OreLocalization.instNegOreLocalization._proof_3, sub_self := OreLocalization.instNegOreLocalization._proof_4 }

## Equations

- OreLocalization.instMulOreLocalization = { mul := fun x y => mk (OreLocalization.mul_aux x y) (OreLocalization.mul_denom x y), mul_assoc := OreLocalization.instMulOreLocalization._proof_1, one := mk 1 1, one_mul := OreLocalization.instMulOreLocalization._proof_2, mul_one := OreLocalization.instMulOreLocalization._proof_3, npow := Monoid.npow._default (mk 1 1) (fun x y => mk (OreLocalization.mul_aux x y) (OreLocalization.mul_denom x y)) OreLocalization.instMulOreLocalization._proof_4 OreLocalization.instMulOreLocalization._proof_5, npow_zero' := OreLocalization.instMulOreLocalization._proof_6, npow_succ' := OreLocalization.instMulOreLocalization._proof_7, left_distrib := OreLocalization.instMulOreLocalization._proof_8, right_distrib := OreLocalization.instMulOreLocalization._proof_9 }

## Equations

- OreLocalization.instCommSemiringOreLocalization = Function.Injective.commSemiring (Localization.instCommSemiringLocalization) OreLocalization.mk_injective (OreLocalization.instZeroOreLocalization) (OreLocalization.instOneOreLocalization) (OreLocalization.instAddOreLocalization) (OreLocalization.instMulOreLocalization) (OreLocalization.instAddCommSemigroupOreLocalization) (OreLocalization.instMulCommSemigroupOreLocalization) (OreLocalization.instAddCommMonoidOreLocalization) (OreLocalization.instMulCommMonoidOreLocalization) (OreLocalization.instDistribMulActionWithZeroOreLocalization) (OreLocalization.instModuleOreLocalization) (OreLocalization.instAddLeftCancelSemigroupOreLocalization) (OreLocalization.instAddRightCancelSemigroupOreLocalization) (OreLocalization.instAddLeftCancelMonoidOreLocalization) (OreLocalization.instAddRightCancelMonoidOreLocalization) (OreLocalization.instAddCancelMonoidOreLocalization) (OreLocalization.instAddCancelCommMonoidOreLocalization) (OreLocalization.instMulLeftCancelSemigroupOreLocalization) (OreLocalization.instMulRightCancelSemigroupOreLocalization) (OreLocalization.instMulLeftCancelMonoidOreLocalization) (OreLocalization.instMulRightCancelMonoidOreLocalization) (OreLocalization.instMulCancelMonoidOreLocalization) (OreLocalization.instMulCancelCommMonoidOreLocalization) (OreLocalization.instMulOneClassOreLocalization) (OreLocalization.instOneMulOreLocalization) (OreLocalization.instMulZeroClassOreLocalization) (OreLocalization.instZeroMulOreLocalization) (OreLocalization.instMulZeroOneClassOreLocalization) (OreLocalization.instNsmulOreLocalization) (OreLocalization.instNpowOreLocalization) (OreLocalization.instZsmulOreLocalization) (OreLocalization.instNatCastOreLocalization) (OreLocalization.instIntCastOreLocalization) (OreLocalization.instNatCastZeroOreLocalization) (OreLocalization.instIntCastZeroOreLocalization) (OreLocalization.instNatCastAddMonoidWithOneOreLocalization) (OreLocalization.instIntCastAddGroupWithOneOreLocalization) (OreLocalization.instNatCastCommSemiringOreLocalization) (OreLocalization.instIntCastCommSemiringOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZeroOreLocalization) (OreLocalization.instIntCastCommMonoidWithZeroOreLocalization) (OreLocalization.instNatCastCommMonoidWithZero

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Chebyshev.lean - 2024-09-07 13:02:00.438711.
---84/100---
For theorem Polynomial.Chebyshev.mul_T in Mathlib/RingTheory/Polynomial/Chebyshev.lean:
theorem mul_T (m k : ℤ) : 2 * T R m * T R k = T R (m + k) + T R (m - k) 


Original valid proof:
:= by
  induction k using Polynomial.Chebyshev.induct with
  | zero => simp [two_mul]
  | one => rw [T_add_one, T_one]; ring
  | add_two k ih1 ih2 =>
    have h₁ := T_add_two R (m + k)
    have h₂ := T_sub_two R (m - k)
    have h₃ := T_add_two R k
    linear_combination (norm := ring_nf) 2 * T R m * h₃ - h₂ - h₁ - ih2 + 2 * (X:R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have h₁ := T_add_two R (m + (-k - 1))
    have h₂ := T_sub_two R (m - (-k - 1))
    have h₃ := T_add_two R (-k - 1)
    linear_combination (norm := ring_nf) 2 * T R m * h₃ - h₂ - h₁ - ih2 + 2 * (X:R[X]) * ih1


Verifying proof (Commit a645d903a5e02e8cbb9215f6195147610bf99954):
 := by
  induction k using Polynomial.Chebyshev.induct with
  | zero => simp [two_mul]
  | one => rw [T_add_one, T_one]; ring
  | add_two k ih1 ih2 =>
    have h₁ := T_add_two R (m + k)
    have h₂ := T_sub_two R (m - k)
    have h₃ := T_add_two R k
    linear_combination (norm : = ring_nf) 2 * T R m * h₃ - h₂ - h₁ - ih2 + 2 * (X : R[X]) * ih1
  | neg_add_one k ih1 ih2 =>
    have h₁ := T_add_two R (m + (-k - 1))
    have h₂ := T_sub_two R (m - (-k - 1))
    have h₃ := T_add_two R (-k - 1)
    linear_combination (norm : = ring_nf) 2 * T R m * h₃ - h₂ - h₁ - ih2 + 2 * (X : R[X]) * ih1

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 10:00):

I'm not sure what the problem

Attempt failure.

Working on Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean - 2024-09-07 13:02:16.710335.
---85/100---
For theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt in Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean:
theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {n : ℕ} {z : L} (hzint : IsIntegral R z)
    (hz : p ^ n • z ∈ adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt 𝓟) :
    z ∈ adjoin R ({B.gen} : Set L) 


Original valid proof:
:= by
  induction' n with n hn
  · simpa using hz
  · rw [_root_.pow_succ', mul_smul] at hz
    exact
      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)


Verifying proof (Commit 6b3f3fe208f0cdce581d713270301bed755856ed):
 := by
  induction' n with n hn
  · simpa using hz
  · rw [_root_.pow_succ, mul_smul] at hz
    exact
      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)

####  Eric Wieser (Jun 01 2020 at 10:40):

I'm not sure if this is a bug, but I'm getting a weird error when trying to use thesimp_rw tactic.

####  Eric Wieser (Jun 01 2020 at 10:40):

I'm trying to prove this:
lemma mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {n : ℕ} {z : L} (hzint : IsIntegral R z)
    (hz : p ^ n • z ∈ adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt 𝓟) :
    z ∈ adjoin R ({B.gen} : Set L) := by
  induction' n with n hn
  · simpa using hz
  · rw [_root_.pow_succ, mul_smul] at hz
    exact
      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)

####  Eric Wieser (Jun 01 2020 at 10:40):

I'm getting this error:
simp_rw [mem_adjoin_iff, Set.singleton_subset_iff, SetLike.mem_coe, Set.mem_range,
  Set.mem_singleton_iff, Subtype.exists, Subtype.coe_mk, Subtype.ext_iff]

failed to prove Lean.MVarId.
state:
z : L
hzint : IsIntegral R z
hz : p ^ n • z ∈ adjoin R {B.gen}
hei : (minpoly R B.gen).IsEisensteinAt 𝓟
hn :
  z ∈
    {
        toAddSubmonoid :=
          { carrier := ↑(adjoin R {B.gen}),
            add_mem' :=
              (_ :
                ∀ {a b : L},
                  a ∈ ↑(adjoin R {B.gen}) →
                    b ∈ ↑(adjoin R {B.gen}) →
                      a + b ∈
                        { toAddSubsemigroup := { carrier := ↑(adjoin R {B.gen}), ..adjoin R {B.gen} }, ..adjoin R {B.gen} }.toAddSubsemigroup),
            zero_mem' := (_ : 0 ∈ ↑(adjoin R {B.gen})) },
        smul_mem' :=
          (_ :
            ∀ (r : R) (x : L),
              x ∈ ↑(adjoin R {B.gen}) →
                r • x ∈
                  { toAddSubmonoid := { carrier := ↑(adjoin R {B.gen}), ..adjoin R {B.gen} }, ..adjoin R {B.gen} }.toAddSubmonoid) }.toAddSubmonoid
⊢ ∃ x, B.gen ^ n • x = z

####  Eric Wieser (Jun 01 2020 at 10:41):

I'm not sure if this is a bug, but I'm getting a weird error when trying to use the
simp_rw tactic.
I'm trying to prove this:
lemma mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {n : ℕ} {z : L} (hzint : IsIntegral R z)
    (hz : p ^ n • z ∈ adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt 𝓟) :
    z ∈ adjoin R ({B.gen} : Set L) := by
  induction' n with n hn
  · simpa using hz
  · rw [_root_.pow_succ, mul_smul] at hz
    exact
      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)

I'm getting this error:
simp_rw [mem_adjoin_iff, Set.singleton_subset_iff, SetLike.mem_coe, Set.mem_range,
  Set.mem_singleton_iff, Subtype.exists, Subtype.coe_mk, Subtype.ext_iff]

failed to prove Lean.MVarId.
state:
z : L
hzint : IsIntegral R z
hz : p ^ n • z ∈ adjoin R {B.gen}
hei : (minpoly R B.gen).IsEisensteinAt 𝓟
hn :
  z ∈
    {
        toAddSubmonoid :=
          { carrier := ↑(adjoin R {B.gen}),
            add_mem' :=
              (_ :
                ∀ {a b : L},
                  a ∈ ↑(adjoin R {B.gen}) →
                    b ∈ ↑(adjoin R {B.gen}) →
                      a + b ∈
                        { toAddSubsemigroup := { carrier := ↑(adjoin R {B.gen}), ..adjoin R {B.gen} }, ..adjoin R {B.gen} }.toAddSubsemigroup),
            zero_mem' := (_ : 0 ∈ ↑(adjoin R {B.gen})) },
        smul_mem' :=
          (_ :
            ∀ (r : R) (x : L),
              x ∈ ↑(adjoin R {B.gen}) →
                r • x ∈
                  { toAddSubmonoid := { carrier := ↑(adjoin R {B.gen}), ..adjoin R {B.gen} }, ..adjoin R {B.gen} }.toAddSubmonoid) }.toAddSubmonoid
⊢ ∃ x, B.gen ^ n • x = z

####  Eric Wieser (Jun 01 2020 at 10:41):

I'm not sure if this is a bug, but I'm getting a weird error when trying to use the
simp_rw tactic.
I'm trying to prove this:
lemma mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {n : ℕ} {z : L} (hzint : IsIntegral R z)
    (hz : p ^ n • z ∈ adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt 𝓟) :
    z ∈ adjoin R ({B.gen} : Set L) := by
  induction' n with n hn
  · simpa using hz
  · rw [_root_.pow_succ, mul_smul] at hz
    exact
      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)

I'm getting this error:
simp_rw [mem_adjoin_iff, Set.singleton_subset_iff, SetLike.mem_coe, Set.mem_range,
  Set.mem_singleton_iff, Subtype.exists, Subtype.coe_mk, Subtype.ext_iff]

failed to prove Lean.MVarId.
state:
z : L
hzint : IsIntegral R z
hz : p ^ n • z ∈ adjoin R

Attempt failure.

Working on Mathlib/RingTheory/RootsOfUnity/Minpoly.lean - 2024-09-07 13:02:32.649036.
---86/100---
For theorem IsPrimitiveRoot.minpoly_dvd_expand in Mathlib/RingTheory/RootsOfUnity/Minpoly.lean:
theorem minpoly_dvd_expand {p : ℕ} (hdiv : ¬p ∣ n) :
    minpoly ℤ μ ∣ expand ℤ p (minpoly ℤ (μ ^ p)) 


Original valid proof:
:= by
  rcases n.eq_zero_or_pos with (rfl | hpos)
  · simp_all
  letI : IsIntegrallyClosed ℤ := GCDMonoid.toIsIntegrallyClosed
  refine minpoly.isIntegrallyClosed_dvd (h.isIntegral hpos) ?_
  rw [aeval_def, coe_expand, ← comp, eval₂_eq_eval_map, map_comp, Polynomial.map_pow, map_X,
    eval_comp, eval_pow, eval_X, ← eval₂_eq_eval_map, ← aeval_def]
  exact minpoly.aeval _ _


Verifying proof (Commit db4b2acc70490f6bcea6872fdf1d716949f8c1e7):
 := by
  rcases n.eq_zero_or_pos with (rfl | hpos)
  · simp_all
  letI : IsIntegrallyClosed ℤ ℚ := GCDMonoid.toIsIntegrallyClosed
  refine' minpoly.isIntegrallyClosed_dvd (h.isIntegral hpos) _
  · rw [aeval_def, coe_expand, ← comp, eval₂_eq_eval_map, map_comp, Polynomial.map_pow, map_X,
      eval_comp, eval_pow, eval_X, ← eval₂_eq_eval_map, ← aeval_def]
    exact minpoly.aeval _ _

## Your Answer

By clicking “Post Your Answer”, you agree to our terms of service, privacy policy and cookie policy

Attempt failure.

Working on Mathlib/RingTheory/WittVector/Verschiebung.lean - 2024-09-07 13:02:42.107231.
---87/100---
For theorem WittVector.aeval_verschiebung_poly' in Mathlib/RingTheory/WittVector/Verschiebung.lean:
theorem aeval_verschiebung_poly' (x : 𝕎 R) (n : ℕ) :
    aeval x.coeff (verschiebungPoly n) = (verschiebungFun x).coeff n 


Original valid proof:
:= by
  cases' n with n
  · simp only [verschiebungPoly, Nat.zero_eq, ge_iff_le, tsub_eq_zero_of_le, ite_true, map_zero,
    verschiebungFun_coeff_zero]
  · rw [verschiebungPoly, verschiebungFun_coeff_succ, if_neg n.succ_ne_zero, aeval_X,
      add_tsub_cancel_right]


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  cases' n with n
  · simp only [verschiebungPoly, Nat.zero_eq, ge_iff_le, tsub_eq_zero_of_le, ite_true, map_zero,
    verschiebungFun_coeff_zero]
  · rw [verschiebungPoly, verschiebungFun_coeff_succ, if_neg n.succ_ne_zero, aeval_X,
      Nat.succ_eq_add_one, add_tsub_cancel_right]

## 1.1.2.2.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.

Attempt failure.

Working on Mathlib/SetTheory/Ordinal/Arithmetic.lean - 2024-09-07 13:02:51.027702.
---88/100---
For theorem Ordinal.limitRecOn_limit in Mathlib/SetTheory/Ordinal/Arithmetic.lean:
theorem limitRecOn_limit {C} (o H₁ H₂ H₃ h) :
    @limitRecOn C o H₁ H₂ H₃ = H₃ o h fun x _h => @limitRecOn C x H₁ H₂ H₃ 


Original valid proof:
:= by
  simp_rw [limitRecOn, SuccOrder.limitRecOn_limit _ _ h.isSuccLimit, dif_neg h.1]


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
 := by
  rw [limitRecOn, lt_wf.fix_eq, dif_neg h.1, dif_neg (not_succ_of_isLimit h)]
  rfl

####  Mario Carneiro (May 10 2020 at 00:00):

I think the problem is that the proof of the theorem is not well-formed, because the first two arguments are not used in the statement

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the proof, and the third argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the proof, and the third argument is not used in the proof, and the fourth argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the proof, and the third argument is not used in the proof, and the fourth argument is not used in the proof, and the fifth argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the proof, and the third argument is not used in the proof, and the fourth argument is not used in the proof, and the fifth argument is not used in the proof, and the sixth argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the proof, and the third argument is not used in the proof, and the fourth argument is not used in the proof, and the fifth argument is not used in the proof, and the sixth argument is not used in the proof, and the seventh argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the proof, and the third argument is not used in the proof, and the fourth argument is not used in the proof, and the fifth argument is not used in the proof, and the sixth argument is not used in the proof, and the seventh argument is not used in the proof, and the eighth argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the proof, and the third argument is not used in the proof, and the fourth argument is not used in the proof, and the fifth argument is not used in the proof, and the sixth argument is not used in the proof, and the seventh argument is not used in the proof, and the eighth argument is not used in the proof, and the ninth argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the proof, and the third argument is not used in the proof, and the fourth argument is not used in the proof, and the fifth argument is not used in the proof, and the sixth argument is not used in the proof, and the seventh argument is not used in the proof, and the eighth argument is not used in the proof, and the ninth argument is not used in the proof, and the tenth argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the proof, and the third argument is not used in the proof, and the fourth argument is not used in the proof, and the fifth argument is not used in the proof, and the sixth argument is not used in the proof, and the seventh argument is not used in the proof, and the eighth argument is not used in the proof, and the ninth argument is not used in the proof, and the tenth argument is not used in the proof, and the eleventh argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the proof, and the third argument is not used in the proof, and the fourth argument is not used in the proof, and the fifth argument is not used in the proof, and the sixth argument is not used in the proof, and the seventh argument is not used in the proof, and the eighth argument is not used in the proof, and the ninth argument is not used in the proof, and the tenth argument is not used in the proof, and the eleventh argument is not used in the proof, and the twelfth argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the proof, and the third argument is not used in the proof, and the fourth argument is not used in the proof, and the fifth argument is not used in the proof, and the sixth argument is not used in the proof, and the seventh argument is not used in the proof, and the eighth argument is not used in the proof, and the ninth argument is not used in the proof, and the tenth argument is not used in the proof, and the eleventh argument is not used in the proof, and the twelfth argument is not used in the proof, and the thirteenth argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the proof, and the third argument is not used in the proof, and the fourth argument is not used in the proof, and the fifth argument is not used in the proof, and the sixth argument is not used in the proof, and the seventh argument is not used in the proof, and the eighth argument is not used in the proof, and the ninth argument is not used in the proof, and the tenth argument is not used in the proof, and the eleventh argument is not used in the proof, and the twelfth argument is not used in the proof, and the thirteenth argument is not used in the proof, and the fourteenth argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the proof, and the third argument is not used in the proof, and the fourth argument is not used in the proof, and the fifth argument is not used in the proof, and the sixth argument is not used in the proof, and the seventh argument is not used in the proof, and the eighth argument is not used in the proof, and the ninth argument is not used in the proof, and the tenth argument is not used in the proof, and the eleventh argument is not used in the proof, and the twelfth argument is not used in the proof, and the thirteenth argument is not used in the proof, and the fourteenth argument is not used in the proof, and the fifteenth argument is not used in the proof

####  Mario Carneiro (May 10 2020 at 00:00):

I think the proof is also not well-formed, because the first argument is not used in the proof, and the second argument is not used in the

Attempt failure.

Working on Mathlib/SetTheory/Ordinal/NaturalOps.lean - 2024-09-07 13:03:05.811949.
---89/100---
For theorem Ordinal.add_le_nadd in Mathlib/SetTheory/Ordinal/NaturalOps.lean:
theorem add_le_nadd : a + b ≤ a ♯ b 


Original valid proof:
:= by
  induction b using limitRecOn with
  | H₁ => simp
  | H₂ c h =>
    rwa [add_succ, nadd_succ, succ_le_succ_iff]
  | H₃ c hc H =>
    simp_rw [← IsNormal.blsub_eq.{u, u} (add_isNormal a) hc, blsub_le_iff]
    exact fun i hi => (H i hi).trans_lt (nadd_lt_nadd_left hi a)


Verifying proof (Commit 25e538f3a737a71314ac143929711e67d0b14d73):
 := by
  induction b with
  | H₁ => simp
  | H₂ c h =>
    rwa [add_succ, nadd_succ, succ_le_succ_iff]
  | H₃ c hc H =>
    simp_rw [← IsNormal.blsub_eq.{u, u} (add_isNormal a) hc, blsub_le_iff]
    exact fun i hi => (H i hi).trans_lt (nadd_lt_nadd_left hi a)

####  Yakov Pechersky (May 01 2020 at 15:00):

I'm not sure if this is a bug or not, but I'm getting a weird error when trying to use thesimp_rw tactic.

####  Yakov Pechersky (May 01 2020 at 15:01):

I'm trying to prove the following:
theorem add_le_nadd : a + b ≤ a ♯ b  := by
  induction b with
  | H₁ => simp
  | H₂ c h =>
    rwa [add_succ, nadd_succ, succ_le_succ_iff]
  | H₃ c hc H =>
    simp_rw [← IsNormal.blsub_eq.{u, u} (add_isNormal a) hc, blsub_le_iff]
    exact fun i hi => (H i hi).trans_lt (nadd_lt_nadd_left hi a)

####  Yakov Pechersky (May 01 2020 at 15:01):

I'm getting the following error:
type mismatch, term
  H i hi
has type
  a + i ≤ a ♯ i
but is expected to have type
  a + i ≤ a ♯ i

####  Yakov Pechersky (May 01 2020 at 15:02):

I'm not sure if this is a bug or not, but I'm getting a weird error when trying to use thesimp_rw tactic.

####  Yakov Pechersky (May 01 2020 at 15:02):

I'm trying to prove the following:
theorem add_le_nadd : a + b ≤ a ♯ b  := by
  induction b with
  | H₁ => simp
  | H₂ c h =>
    rwa [add_succ, nadd_succ, succ_le_succ_iff]
  | H₃ c hc H =>
    simp_rw [← IsNormal.blsub_eq.{u, u} (add_isNormal a) hc, blsub_le_iff]
    exact fun i hi => (H i hi).trans_lt (nadd_lt_nadd_left hi a)

####  Yakov Pechersky (May 01 2020 at 15:02):

I'm getting the following error:
type mismatch, term
  H i hi
has type
  a + i ≤ a ♯ i
but is expected to have type
  a + i ≤ a ♯ i

####  Yakov Pechersky (May 01 2020 at 15:03):

I'm not sure if this is a bug or not, but I'm getting a weird error when trying to use thesimp_rw tactic.

####  Yakov Pechersky (May 01 2020 at 15:03):

I'm trying to prove the following:
theorem add_le_nadd : a + b ≤ a ♯ b  := by
  induction b with
  | H₁ => simp
  | H₂ c h =>
    rwa [add_succ, nadd_succ, succ_le_succ_iff]
  | H₃ c hc H =>
    simp_rw [← IsNormal.blsub_eq.{u, u} (add_isNormal a) hc, blsub_le_iff]
    exact fun i hi => (H i hi).trans_lt (nadd_lt_nadd_left hi a)

####  Yakov Pechersky (May 01 2020 at 15:03):

I'm getting the following error:
type mismatch, term
  H i hi
has type
  a + i ≤ a ♯ i
but is expected to have type
  a + i ≤ a ♯ i

####  Yakov Pechersky (May 01 2020 at 15:04):

I'm not sure if this is a bug or not, but I'm getting a weird error when trying to use thesimp_rw tactic.

####  Yakov Pechersky (May 01 2020 at 15:04):

I'm trying to prove the following:
theorem add_le_nadd : a + b ≤ a ♯ b  := by
  induction b with
  | H₁ => simp
  | H₂ c h =>
    rwa [add_succ, nadd_succ, succ_le_succ_iff]
  | H₃ c hc H =>
    simp_rw [← IsNormal.blsub_eq.{u, u} (add_isNormal a) hc, blsub_le_iff]
    exact fun i hi => (H i hi).trans_lt (nadd_lt_nadd_left hi a)

####  Yakov Pechersky (May 01 2020 at 15:04):

I'm getting the following error:
type mismatch, term
  H i hi
has type
  a + i ≤ a ♯ i
but is expected to have type
  a + i ≤ a ♯ i

####  Yakov Pechersky (May 01 2020 at 15:05):

I'm not sure if this is a bug or not, but I'm getting a weird error when trying to use thesimp_rw tactic.

####  Yakov Pechersky (May 01 2020 at 15:05):

I'm trying to prove the following:
theorem add_le_nadd : a + b ≤ a ♯ b  := by
  induction b with
  | H₁ => simp
  | H₂ c h =>
    rwa [add_succ, nadd_succ, succ_le_succ_iff]
  | H₃ c hc H =>
    simp_rw [← IsNormal.blsub_eq.{u, u} (add_isNormal a) hc, blsub_le_iff]
    exact fun i hi => (H i hi).trans_lt (nadd_lt_nadd_left hi a)

####  Yakov Pechersky (May 01 2020 at 15:05):

I'm getting the following error:
type mismatch, term
  H i hi
has type
  a + i ≤ a ♯ i
but is expected to have type
  a + i ≤ a ♯ i

####  Yakov Pechersky (May 01 2020 at 15:06):

I'm not sure if this is a bug or not, but I'm getting a weird error when trying to use thesimp_rw tactic.

####  Yakov Pechersky (May 01 2020 at 15:06):

I'm trying to prove the following:
theorem add_le_nadd : a + b ≤ a ♯ b  := by
  induction b with
  | H₁ => simp
  | H₂ c h =>
    rwa [add_succ, nadd_succ, succ_le_succ_iff]
  | H₃ c hc H =>
    simp_rw [← IsNormal.blsub_eq.{u, u} (add_isNormal a) hc, blsub_le_iff]
    exact fun i hi => (H i hi).trans_lt (nadd_lt_nadd_left hi a)

####  Yakov Pechersky (May 01 2020 at 15:06):

I'm getting the following error:
type mismatch, term
  H i hi
has type
  a + i ≤ a ♯ i
but is expected to have type
  a + i ≤ a ♯ i


Attempt failure.

Working on Mathlib/Topology/Algebra/InfiniteSum/Basic.lean - 2024-09-07 13:03:15.809041.
---90/100---
For theorem Function.Injective.tprod_eq in Mathlib/Topology/Algebra/InfiniteSum/Basic.lean:
theorem Function.Injective.tprod_eq {g : γ → β} (hg : Injective g) {f : β → α}
    (hf : mulSupport f ⊆ Set.range g) : ∏' c, f (g c) = ∏' b, f b 


Original valid proof:
:= by
  have : mulSupport f = g '' mulSupport (f ∘ g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [← Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  · have hfg_fin : (mulSupport (f ∘ g)).Finite := hf_fin.preimage hg.injOn
    lift g to γ ↪ β using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, ← Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ↦ rfl
    simp [this]
  · have hf_fin' : ¬ Set.Finite (mulSupport (f ∘ g)) := by
      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      funext fun a => propext <| hg.hasProd_iff (mulSupport_subset_iff'.1 hf) (a := a)]


Verifying proof (Commit 3b0baa425c7f4e18fdeeb7271bf104ecfee0d57a):
 := by
  have : mulSupport f = g '' mulSupport (f ∘ g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [← Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  · have hfg_fin : (mulSupport (f ∘ g)).Finite := hf_fin.preimage hg.injOn
    lift g to γ ↪ β using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, ← Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ↦ rfl
    simp [this]
  · have hf_fin' : ¬ Set.Finite (mulSupport (f ∘ g)) := by
      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      hg.hasProd_iff (mulSupport_subset_iff'.1 hf)]

## 2.

I have a proof of the following theorem, but it is not very nice.

theorem Function.Injective.tprod_eq {g : γ → β} (hg : Injective g) {f : β → α}
    (hf : mulSupport f ⊆ Set.range g) : ∏' c, f (g c) = ∏' b, f b := by
  have : mulSupport f = g '' mulSupport (f ∘ g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [← Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  · have hfg_fin : (mulSupport (f ∘ g)).Finite := hf_fin.preimage hg.injOn
    lift g to γ ↪ β using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, ← Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ↦ rfl
    simp [this]
  · have hf_fin' : ¬ Set.Finite (mulSupport (f ∘ g)) := by
      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      hg.hasProd_iff (mulSupport_subset_iff'.1 hf)]

I would like to know if there is a better proof.

## 3.

I have a proof of the following theorem, but it is not very nice.

theorem Function.Injective.tprod_eq {g : γ → β} (hg : Injective g) {f : β → α}
    (hf : mulSupport f ⊆ Set.range g) : ∏' c, f (g c) = ∏' b, f b := by
  have : mulSupport f = g '' mulSupport (f ∘ g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [← Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  · have hfg_fin : (mulSupport (f ∘ g)).Finite := hf_fin.preimage hg.injOn
    lift g to γ ↪ β using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, ← Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ↦ rfl
    simp [this]
  · have hf_fin' : ¬ Set.Finite (mulSupport (f ∘ g)) := by
      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      hg.hasProd_iff (mulSupport_subset_iff'.1 hf)]

I would like to know if there is a better proof.

## 4.

I have a proof of the following theorem, but it is not very nice.

theorem Function.Injective.tprod_eq {g : γ → β} (hg : Injective g) {f : β → α}
    (hf : mulSupport f ⊆ Set.range g) : ∏' c, f (g c) = ∏' b, f b := by
  have : mulSupport f = g '' mulSupport (f ∘ g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [← Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  · have hfg_fin : (mulSupport (f ∘ g)).Finite := hf_fin.preimage hg.injOn
    lift g to γ ↪ β using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, ← Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ↦ rfl
    simp [this]
  · have hf_fin' : ¬ Set.Finite (mulSupport (f ∘ g)) := by
      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      hg.hasProd_iff (mulSupport_subset_iff'.1 hf)]

I would like to know if there is a better proof.

## 5.

I have a proof of the following theorem, but it is not very nice.

theorem Function.Injective.tprod_eq {g : γ → β} (hg : Injective g) {f : β → α}
    (hf : mulSupport f ⊆ Set.range g) : ∏' c, f (g c) = ∏' b, f b := by
  have : mulSupport f = g '' mulSupport (f ∘ g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [← Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  · have hfg_fin : (mulSupport (f ∘ g)).Finite := hf_fin.preimage hg.injOn
    lift g to γ ↪ β using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, ← Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ↦ rfl
    simp [this]
  · have hf_fin' : ¬ Set.Finite (mulSupport (f ∘ g)) := by
      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      hg.hasProd_iff

Attempt failure.

Working on Mathlib/Topology/Category/Profinite/EffectiveEpi.lean - 2024-09-07 13:03:26.016650.
---91/100---
For theorem Profinite.effectiveEpi_tfae in Mathlib/Topology/Category/Profinite/EffectiveEpi.lean:
theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ] 


Original valid proof:
:= by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ ↦ ⟨⟨struct π hπ⟩⟩
  tfae_finish


Verifying proof (Commit df6d9dfd71b46903e969bf2377a41d5a74ade252):
 := by
  tfae_have 1 → 2
  | _ => inferInstance
  tfae_have 2 ↔ 3 := epi_iff_surjective π
  tfae_have 3 → 1 := fun hπ ↦ ⟨⟨struct π hπ⟩⟩
  tfae_finish

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem is.

####  Kevin Buzzard (May 02 2020 at 10:02):

I'm not sure what the problem

Attempt failure.

---92/100---
For theorem Profinite.effectiveEpi_tfae in Mathlib/Topology/Category/Profinite/EffectiveEpi.lean:
theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (π : X ⟶ B) :
    TFAE
    [ EffectiveEpi π
    , Epi π
    , Function.Surjective π
    ] 


Original valid proof:
:= by
  tfae_have 1 → 2
  · intro; infer_instance
  tfae_have 2 ↔ 3
  · exact epi_iff_surjective π
  tfae_have 3 → 1
  · exact fun hπ ↦ ⟨⟨struct π hπ⟩⟩
  tfae_finish


Verifying proof (Commit 62c2d6a1d2ffdbe5bcaa653b84d3602a209e4c8c):
 := by
  tfae_have : 1 → 2
  · intro; infer_instance
  tfae_have : 2 ↔ 3 := epi_iff_surjective π
  tfae_have : 3 → 1 := fun hπ ↦ ⟨⟨struct π hπ⟩⟩
  tfae_finish

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not sure what the problem is.

####  Kevin Buzzard (Jun 01 2020 at 14:05):

I'm not

Attempt failure.

Working on Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean - 2024-09-07 13:03:44.200811.
---93/100---
For theorem TopCat.isTopologicalBasis_cofiltered_limit in Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean:
theorem isTopologicalBasis_cofiltered_limit (T : ∀ j, Set (Set (F.obj j)))
    (hT : ∀ j, IsTopologicalBasis (T j)) (univ : ∀ i : J, Set.univ ∈ T i)
    (inter : ∀ (i) (U1 U2 : Set (F.obj i)), U1 ∈ T i → U2 ∈ T i → U1 ∩ U2 ∈ T i)
    (compat : ∀ (i j : J) (f : i ⟶ j) (V : Set (F.obj j)) (_hV : V ∈ T j), F.map f ⁻¹' V ∈ T i) :
    IsTopologicalBasis
      {U : Set C.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = C.π.app j ⁻¹' V} 


Original valid proof:
:= by
  classical
  let D := limitConeInfi F
  let E : C.pt ≅ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = D.π.app j ⁻¹' V} by
    convert this.inducing hE
    ext U0
    constructor
    · rintro ⟨j, V, hV, rfl⟩
      exact ⟨D.π.app j ⁻¹' V, ⟨j, V, hV, rfl⟩, rfl⟩
    · rintro ⟨W, ⟨j, V, hV, rfl⟩, rfl⟩
      exact ⟨j, V, hV, rfl⟩
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.π.app j x using 1
  ext U0
  constructor
  · rintro ⟨j, V, hV, rfl⟩
    let U : ∀ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine ⟨U, {j}, ?_, ?_⟩
    · simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    · simp [U]
  · rintro ⟨U, G, h1, h2⟩
    obtain ⟨j, hj⟩ := IsCofiltered.inf_objs_exists G
    let g : ∀ e ∈ G, j ⟶ e := fun _ he => (hj he).some
    let Vs : J → Set (F.obj j) := fun e => if h : e ∈ G then F.map (g e h) ⁻¹' U e else Set.univ
    let V : Set (F.obj j) := ⋂ (e : J) (_he : e ∈ G), Vs e
    refine ⟨j, V, ?_, ?_⟩
    · 
      have :
        ∀ (S : Set (Set (F.obj j))) (E : Finset J) (P : J → Set (F.obj j)) (_univ : Set.univ ∈ S)
          (_inter : ∀ A B : Set (F.obj j), A ∈ S → B ∈ S → A ∩ B ∈ S)
          (_cond : ∀ (e : J) (_he : e ∈ E), P e ∈ S), (⋂ (e) (_he : e ∈ E), P e) ∈ S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    · 
      rw [h2]
      change _ = (D.π.app j)⁻¹' ⋂ (e : J) (_ : e ∈ G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.π.app e)⁻¹' U e =
        (D.π.app j) ⁻¹' if h : e ∈ G then F.map (g e h) ⁻¹' U e else Set.univ
      rw [dif_pos he, ← Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [← coe_comp, D.w] 
      rfl


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
 := by
  classical
  let D := limitConeInfi F
  let E : C.pt ≅ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = D.π.app j ⁻¹' V} by
    convert this.inducing hE
    ext U0
    constructor
    · rintro ⟨j, V, hV, rfl⟩
      refine' ⟨D.π.app j ⁻¹' V, ⟨j, V, hV, rfl⟩, rfl⟩
    · rintro ⟨W, ⟨j, V, hV, rfl⟩, rfl⟩
      refine' ⟨j, V, hV, rfl⟩
  convert isTopologicalBasis_iInf hT fun j (x : D.pt) => D.π.app j x using 1
  ext U0
  constructor
  · rintro ⟨j, V, hV, rfl⟩
    let U : ∀ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine' ⟨U, {j}, _, _⟩
    · rintro i h
      rw [Finset.mem_singleton] at h
      dsimp
      rw [dif_pos h]
      subst h
      exact hV
    · dsimp
      simp
  · rintro ⟨U, G, h1, h2⟩
    obtain ⟨j, hj⟩ := IsCofiltered.inf_objs_exists G
    let g : ∀ (e) (_he : e ∈ G), j ⟶ e := fun _ he => (hj he).some
    let Vs : J → Set (F.obj j) := fun e => if h : e ∈ G then F.map (g e h) ⁻¹' U e else Set.univ
    let V : Set (F.obj j) := ⋂ (e : J) (_he : e ∈ G), Vs e
    refine' ⟨j, V, _, _⟩
    · 
      have :
        ∀ (S : Set (Set (F.obj j))) (E : Finset J) (P : J → Set (F.obj j)) (_univ : Set.univ ∈ S)
          (_inter : ∀ A B : Set (F.obj j), A ∈ S → B ∈ S → A ∩ B ∈ S)
          (_cond : ∀ (e : J) (_he : e ∈ E), P e ∈ S), (⋂ (e) (_he : e ∈ E), P e) ∈ S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine' hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 _)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine' this _ _ _ (univ _) (inter _) _
      intro e he
      dsimp
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    · 
      rw [h2]
      change _ = (D.π.app j)⁻¹' ⋂ (e : J) (_ : e ∈ G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.π.app e)⁻¹' U e =
        (D.π.app j) ⁻¹' if h : e ∈ G then F.map (g e h) ⁻¹' U e else Set.univ
      rw [dif_pos he, ← Set.preimage_comp]
      apply congrFun
      apply congrArg
      rw [← coe_comp, D.w]
      rfl

####  Kevin Buzzard (Apr 10 2021 at 10:01):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the point of this is, but I'm not sure I'm going to be able to help you.

####  Kevin Buzzard (Apr 10 2021 at 10:02):

I'm not sure what the

Attempt failure.

Working on Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean - 2024-09-07 13:03:50.430407.
---94/100---
For theorem TopCat.range_pullback_map in Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean:
theorem range_pullback_map {W X Y Z S T : TopCat} (f₁ : W ⟶ S) (f₂ : X ⟶ S) (g₁ : Y ⟶ T)
    (g₂ : Z ⟶ T) (i₁ : W ⟶ Y) (i₂ : X ⟶ Z) (i₃ : S ⟶ T) [H₃ : Mono i₃] (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁)
    (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) :
    Set.range (pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂) =
      (pullback.fst : pullback g₁ g₂ ⟶ _) ⁻¹' Set.range i₁ ∩
        (pullback.snd : pullback g₁ g₂ ⟶ _) ⁻¹' Set.range i₂ 


Original valid proof:
:= by
  ext
  constructor
  · rintro ⟨y, rfl⟩
    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range]
    erw [← comp_apply, ← comp_apply] 
    simp only [limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app, comp_apply]
    exact ⟨exists_apply_eq_apply _ _, exists_apply_eq_apply _ _⟩
  rintro ⟨⟨x₁, hx₁⟩, ⟨x₂, hx₂⟩⟩
  have : f₁ x₁ = f₂ x₂ := by
    apply (TopCat.mono_iff_injective _).mp H₃
    erw [← comp_apply, eq₁, ← comp_apply, eq₂, 
      comp_apply, comp_apply, hx₁, hx₂, ← comp_apply, pullback.condition]
    rfl 
  use (pullbackIsoProdSubtype f₁ f₂).inv ⟨⟨x₁, x₂⟩, this⟩
  change (forget TopCat).map _ _ = _
  apply Concrete.limit_ext
  rintro (_ | _ | _) <;>
  erw [← comp_apply, ← comp_apply] 
  simp only [Category.assoc, limit.lift_π, PullbackCone.mk_π_app_one]
  · simp only [cospan_one, pullbackIsoProdSubtype_inv_fst_assoc, comp_apply]
    erw [pullbackFst_apply, hx₁]
    rw [← limit.w _ WalkingCospan.Hom.inl, cospan_map_inl, comp_apply (g := g₁)]
    rfl 
  · simp only [cospan_left, limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app,
      pullbackIsoProdSubtype_inv_fst_assoc, comp_apply]
    erw [hx₁] 
    rfl 
  · simp only [cospan_right, limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app,
      pullbackIsoProdSubtype_inv_snd_assoc, comp_apply]
    erw [hx₂] 
    rfl 


Verifying proof (Commit c0d29a577c3ac349c365bc3efc469237662049c4):
 := by
  ext
  constructor
  · rintro ⟨y, rfl⟩
    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range, ← comp_apply, limit.lift_π,
      PullbackCone.mk_pt, PullbackCone.mk_π_app]
    simp only [comp_apply, exists_apply_eq_apply, and_self]
  rintro ⟨⟨x₁, hx₁⟩, ⟨x₂, hx₂⟩⟩
  have : f₁ x₁ = f₂ x₂ := by
    apply (TopCat.mono_iff_injective _).mp H₃
    simp only [← comp_apply, eq₁, eq₂]
    simp only [comp_apply, hx₁, hx₂]
    simp only [← comp_apply, pullback.condition]
  use (pullbackIsoProdSubtype f₁ f₂).inv ⟨⟨x₁, x₂⟩, this⟩
  simp only [← comp_apply, pullbackIsoProdSubtype_inv_fst, pullbackIsoProdSubtype_inv_snd,
    pullback.condition, Set.mem_preimage, Set.mem_inter_iff, Set.mem_range,
    PullbackCone.mk_pt, PullbackCone.mk_π_app, limit.lift_π, comp_apply, exists_apply_eq_apply,
    and_self]

####  Adam Topaz (Apr 01 2021 at 17:04):

@Kenny Lau I think you can use the fact that the pullback of a mono is mono to get rid of the assumption thati₃ is mono.

####  Adam Topaz (Apr 01 2021 at 17:04):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Kenny Lau (Apr 01 2021 at 17:05):

I think it's a good idea

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that though.

####  Adam Topaz (Apr 01 2021 at 17:05):

I'm not sure if it's a good idea to do that

Attempt failure.

Working on Mathlib/Topology/Homotopy/HomotopyGroup.lean - 2024-09-07 13:04:01.913801.
---95/100---
For theorem GenLoop.homotopicFrom in Mathlib/Topology/Homotopy/HomotopyGroup.lean:
theorem homotopicFrom (i : N) {p q : Ω^ N X x} :
    (toLoop i p).Homotopic (toLoop i q) → Homotopic p q 


Original valid proof:
:= by
  refine Nonempty.map fun H => ⟨⟨homotopyFrom i H, ?_, ?_⟩, ?_⟩
  pick_goal 3
  · rintro t y ⟨j, jH⟩
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    · simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
        Function.uncurry_apply_pair]
      rw [H.eq_fst]
      exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    · rw [p.2 _ ⟨j, jH⟩]; apply boundary; exact ⟨⟨j, h⟩, jH⟩
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
      Function.uncurry_apply_pair, ContinuousMap.HomotopyWith.apply_zero,
      ContinuousMap.HomotopyWith.apply_one, ne_eq, Path.coe_toContinuousMap, toLoop_apply_coe,
      ContinuousMap.curry_apply, ContinuousMap.comp_apply]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv


Verifying proof (Commit a36d8932e98ea1d7efcdd316318586a6329f53a3):
 := by
  refine' Nonempty.map fun H => ⟨⟨homotopyFrom i H, _, _⟩, _⟩
  pick_goal 3
  · rintro t y ⟨j, jH⟩
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    · rw [H.eq_fst]; exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    · rw [p.2 _ ⟨j, jH⟩]; apply boundary; exact ⟨⟨j, h⟩, jH⟩
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    first
    | rw [H.apply_zero]
    | rw [H.apply_one]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































Attempt failure.

Working on Mathlib/Topology/MetricSpace/Polish.lean - 2024-09-07 13:04:22.235329.
---96/100---
For theorem IsClosed.isClopenable in Mathlib/Topology/MetricSpace/Polish.lean:
theorem _root_.IsClosed.isClopenable [TopologicalSpace α] [PolishSpace α] {s : Set α}
    (hs : IsClosed s) : IsClopenable s 


Original valid proof:
:= by
  classical
  haveI : PolishSpace s := hs.polishSpace
  let t : Set α := sᶜ
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ⊕ t ≃ α := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ≤ ‹_› := by
    simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ← continuous_iff_coinduced_le]
    exact ⟨continuous_subtype_val, continuous_subtype_val⟩
  refine ⟨.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_⟩
  · rw [← f.induced_symm]
    exact f.symm.polishSpace_induced
  · rw [isOpen_coinduced, isOpen_sum_iff]
    simp [f, preimage_preimage]


Verifying proof (Commit 2ac7d87c221020b247729b180bbe2575cceb0700):
 := by
  haveI : PolishSpace s := hs.polishSpace
  let t : Set α := sᶜ
  haveI : PolishSpace t := hs.isOpen_compl.polishSpace
  let f : s ⊕ t ≃ α := Equiv.Set.sumCompl s
  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ≤ ‹_›
  · simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,
      ← continuous_iff_coinduced_le]
    exact ⟨continuous_subtype_val, continuous_subtype_val⟩
  refine ⟨.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_⟩
  · rw [← f.induced_symm]
    exact f.symm.polishSpace_induced
  · rw [isOpen_coinduced, isOpen_sum_iff]
    convert And.intro (isOpen_univ (α := s)) (isOpen_empty (α := (sᶜ : Set α)))
      <;> ext ⟨x, hx⟩ <;> simpa using hx

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

####  Eric Wieser (Jun 01 2020 at 10:00):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I'm not sure how to fix it either, but I'm pretty sure it's a bug.

####  Eric Wieser (Jun 01 2020 at 10:01):

I'm not sure if this is a bug or not, but I'm not sure how to fix it.

I

Attempt failure.

Working on Mathlib/Topology/Order/ScottTopology.lean - 2024-09-07 13:04:31.012165.
---97/100---
For theorem Topology.IsScott.lowerClosure_subset_closure in Mathlib/Topology/Order/ScottTopology.lean:
lemma lowerClosure_subset_closure : ↑(lowerClosure s) ⊆ closure s 


Original valid proof:
:= by
  convert closure.mono (@upperSet_le_scott α _)
  · rw [@IsUpperSet.closure_eq_lowerClosure α _ (upperSet α) ?_ s]
    infer_instance
  · exact topology_eq α


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
 := by
  convert closure.mono (@upperSet_le_scott α _)
  · rw [@IsUpperSet.closure_eq_lowerClosure α _ (upperSet α) ?_ s]
    exact instIsUpperSetUpperSet
  · exact topology_eq α

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020 at 19:05):

I'm not sure what the point of the first line is.

####  Kevin Buzzard (Jun 01 2020

Attempt failure.

Working on Mathlib/Topology/Perfect.lean - 2024-09-07 13:04:38.073009.
---98/100---
For theorem exists_perfect_nonempty_of_isClosed_of_not_countable in Mathlib/Topology/Perfect.lean:
theorem exists_perfect_nonempty_of_isClosed_of_not_countable [SecondCountableTopology α]
    (hclosed : IsClosed C) (hunc : ¬C.Countable) : ∃ D : Set α, Perfect D ∧ D.Nonempty ∧ D ⊆ C 


Original valid proof:
:= by
  rcases exists_countable_union_perfect_of_isClosed hclosed with ⟨V, D, Vct, Dperf, VD⟩
  refine ⟨D, ⟨Dperf, ?_⟩⟩
  constructor
  · rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right


Verifying proof (Commit cc6e5e01514b06a44caccb55bc04e269ede6a7c8):
∧ D.Countable := by
  rcases exists_countable_union_perfect_of_isClosed hclosed with ⟨V, D, Vct, Dperf, VD⟩
  refine' ⟨D, ⟨Dperf, _⟩⟩
  constructor
  · rw [nonempty_iff_ne_empty]
    by_contra h
    rw [h, union_empty] at VD
    rw [VD] at hunc
    contradiction
  rw [VD]
  exact subset_union_right _ _
  exact Vct

####  Yury G. Kudryashov (Aug 01 2020 at 13:06):

I think the problem is that you are using the fact that a countable union of countable sets is countable.

####  Yury G. Kudryashov (Aug 01 2020 at 13:07):

And this fact is not true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:07):

You need to prove thatD is countable.

####  Yury G. Kudryashov (Aug 01 2020 at 13:07):

And you need to prove thatD is perfect.

####  Yury G. Kudryashov (Aug 01 2020 at 13:07):

I'm not sure that this is true.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 2020 at 13:08):

I'm not sure that this is true in general.

####  Yury G. Kudryashov (Aug 01 

Attempt failure.

Working on Mathlib/Topology/Separation.lean - 2024-09-07 13:04:43.676693.
---99/100---
For theorem loc_compact_Haus_tot_disc_of_zero_dim in Mathlib/Topology/Separation.lean:
theorem loc_compact_Haus_tot_disc_of_zero_dim [TotallyDisconnectedSpace H] :
    IsTopologicalBasis { s : Set H | IsClopen s } 


Original valid proof:
:= by
  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => hu.2) fun x U memU hU => ?_
  obtain ⟨s, comp, xs, sU⟩ := exists_compact_subset hU memU
  let u : Set s := ((↑) : s → H) ⁻¹' interior s
  have u_open_in_s : IsOpen u := isOpen_interior.preimage continuous_subtype_val
  lift x to s using interior_subset xs
  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp
  obtain ⟨V : Set s, VisClopen, Vx, V_sub⟩ := compact_exists_isClopen_in_isOpen u_open_in_s xs
  have VisClopen' : IsClopen (((↑) : s → H) '' V) := by
    refine ⟨comp.isClosed.closedEmbedding_subtype_val.closed_iff_image_closed.1 VisClopen.1, ?_⟩
    let v : Set u := ((↑) : u → s) ⁻¹' V
    have : ((↑) : u → H) = ((↑) : s → H) ∘ ((↑) : u → s) := rfl
    have f0 : Embedding ((↑) : u → H) := embedding_subtype_val.comp embedding_subtype_val
    have f1 : OpenEmbedding ((↑) : u → H) := by
      refine ⟨f0, ?_⟩
      · have : Set.range ((↑) : u → H) = interior s := by
          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
          apply Set.inter_eq_self_of_subset_right interior_subset
        rw [this]
        apply isOpen_interior
    have f2 : IsOpen v := VisClopen.2.preimage continuous_subtype_val
    have f3 : ((↑) : s → H) '' V = ((↑) : u → H) '' v := by
      rw [this, image_comp, Subtype.image_preimage_coe, inter_eq_self_of_subset_right V_sub]
    rw [f3]
    apply f1.isOpenMap v f2
  use (↑) '' V, VisClopen', by simp [Vx], Subset.trans (by simp) sU


Verifying proof (Commit b492f764dc62b80a0be745055df26ce5b018a24a):
 := by
  refine isTopologicalBasis_of_isOpen_of_nhds (fun u hu => hu.1) fun x U memU hU => ?_
  obtain ⟨s, comp, xs, sU⟩ := exists_compact_subset hU memU
  let u : Set s := ((↑) : s → H) ⁻¹' interior s
  have u_open_in_s : IsOpen u := isOpen_interior.preimage continuous_subtype_val
  lift x to s using interior_subset xs
  haveI : CompactSpace s := isCompact_iff_compactSpace.1 comp
  obtain ⟨V : Set s, VisClopen, Vx, V_sub⟩ := compact_exists_isClopen_in_isOpen u_open_in_s xs
  have VisClopen' : IsClopen (((↑) : s → H) '' V) := by
    refine' ⟨_, comp.isClosed.closedEmbedding_subtype_val.closed_iff_image_closed.1 VisClopen.2⟩
    let v : Set u := ((↑) : u → s) ⁻¹' V
    have : ((↑) : u → H) = ((↑) : s → H) ∘ ((↑) : u → s) := rfl
    have f0 : Embedding ((↑) : u → H) := embedding_subtype_val.comp embedding_subtype_val
    have f1 : OpenEmbedding ((↑) : u → H) := by
      refine' ⟨f0, _⟩
      · have : Set.range ((↑) : u → H) = interior s := by
          rw [this, Set.range_comp, Subtype.range_coe, Subtype.image_preimage_coe]
          apply Set.inter_eq_self_of_subset_left interior_subset
        rw [this]
        apply isOpen_interior
    have f2 : IsOpen v := VisClopen.1.preimage continuous_subtype_val
    have f3 : ((↑) : s → H) '' V = ((↑) : u → H) '' v := by
      rw [this, image_comp, Subtype.image_preimage_coe, inter_eq_self_of_subset_left V_sub]
    rw [f3]
    apply f1.isOpenMap v f2
  refine' ⟨(↑) '' V, VisClopen', by simp [Vx], Subset.trans _ sU⟩
  simp

## References #

- [Gamelin and Greene, Introduction to Topology, Second Edition][gamelin1999]

## Tags #

totally disconnected, Hausdorff, locally compact

### Totally disconnected spaces #

A set is called totally disconnected if all of its connected components are singletons.

A topological space is totally disconnected if every two points can be disconnected by clopen sets.

A totally disconnected set is one whose connected components are (trivial) singletons.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

A set is totally disconnected if and only if its closure is.

A set is totally disconnected if and only if its interior is.

Attempt failure.

Working on Mathlib/Topology/UrysohnsLemma.lean - 2024-09-07 13:04:56.157603.
---100/100---
For theorem exists_continuous_one_zero_of_isCompact_of_isGδ in Mathlib/Topology/UrysohnsLemma.lean:
theorem exists_continuous_one_zero_of_isCompact_of_isGδ [RegularSpace X] [LocallyCompactSpace X]
    {s t : Set X} (hs : IsCompact s) (h's : IsGδ s) (ht : IsClosed t) (hd : Disjoint s t) :
    ∃ f : C(X, ℝ), s = f ⁻¹' {1} ∧ EqOn f 0 t ∧ HasCompactSupport f
      ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 


Original valid proof:
:= by
  rcases h's.eq_iInter_nat with ⟨U, U_open, hU⟩
  obtain ⟨m, m_comp, -, sm, mt⟩ : ∃ m, IsCompact m ∧ IsClosed m ∧ s ⊆ interior m ∧ m ⊆ tᶜ :=
    exists_compact_closed_between hs ht.isOpen_compl hd.symm.subset_compl_left
  have A n : ∃ f : C(X, ℝ), EqOn f 1 s ∧ EqOn f 0 (U n ∩ interior m)ᶜ ∧ HasCompactSupport f
      ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 := by
    apply exists_continuous_one_zero_of_isCompact hs
      ((U_open n).inter isOpen_interior).isClosed_compl
    rw [disjoint_compl_right_iff_subset]
    exact subset_inter ((hU.subset.trans (iInter_subset U n))) sm
  choose f fs fm _hf f_range using A
  obtain ⟨u, u_pos, u_sum, hu⟩ : ∃ (u : ℕ → ℝ), (∀ i, 0 < u i) ∧ Summable u ∧ ∑' i, u i = 1 :=
    ⟨fun n ↦ 1/2/2^n, fun n ↦ by positivity, summable_geometric_two' 1, tsum_geometric_two' 1⟩
  let g : X → ℝ := fun x ↦ ∑' n, u n * f n x
  have hgmc : EqOn g 0 mᶜ := by
    intro x hx
    have B n : f n x = 0 := by
      have : mᶜ ⊆ (U n ∩ interior m)ᶜ := by
        simpa using inter_subset_right.trans interior_subset
      exact fm n (this hx)
    simp [g, B]
  have I n x : u n * f n x ≤ u n := mul_le_of_le_one_right (u_pos n).le (f_range n x).2
  have S x : Summable (fun n ↦ u n * f n x) := Summable.of_nonneg_of_le
      (fun n ↦ mul_nonneg (u_pos n).le (f_range n x).1) (fun n ↦ I n x) u_sum
  refine ⟨⟨g, ?_⟩, ?_, hgmc.mono (subset_compl_comm.mp mt), ?_, fun x ↦ ⟨?_, ?_⟩⟩
  · apply continuous_tsum (fun n ↦ continuous_const.mul (f n).continuous) u_sum (fun n x ↦ ?_)
    simpa [abs_of_nonneg, (u_pos n).le, (f_range n x).1] using I n x
  · apply Subset.antisymm (fun x hx ↦ by simp [g, fs _ hx, hu]) ?_
    apply compl_subset_compl.1
    intro x hx
    obtain ⟨n, hn⟩ : ∃ n, x ∉ U n := by simpa [hU] using hx
    have fnx : f n x = 0 := fm _ (by simp [hn])
    have : g x < 1 := by
      apply lt_of_lt_of_le ?_ hu.le
      exact tsum_lt_tsum (i := n) (fun i ↦ I i x) (by simp [fnx, u_pos n]) (S x) u_sum
    simpa using this.ne
  · exact HasCompactSupport.of_support_subset_isCompact m_comp
      (Function.support_subset_iff'.mpr hgmc)
  · exact tsum_nonneg (fun n ↦ mul_nonneg (u_pos n).le (f_range n x).1)
  · apply le_trans _ hu.le
    exact tsum_le_tsum (fun n ↦ I n x) (S x) u_sum


Verifying proof (Commit bc76db74ce5ed54a72d80fca488c6549cfb0a8ab):
∧ ∀ n, ∃ m, ∀ y, dist y x ≤ m → f y ≤ 1 / 2 ^ n := by
  rcases h's.eq_iInter_nat with ⟨U, U_open, hU⟩
  obtain ⟨m, m_comp, -, sm, mt⟩ : ∃ m, IsCompact m ∧ IsClosed m ∧ s ⊆ interior m ∧ m ⊆ tᶜ :=
    exists_compact_closed_between hs ht.isOpen_compl hd.symm.subset_compl_left
  have A n : ∃ f : C(X, ℝ), EqOn f 1 s ∧ EqOn f 0 (U n ∩ interior m)ᶜ ∧ HasCompactSupport f
      ∧ ∀ x, f x ∈ Icc (0 : ℝ) 1 ∧ ∀ n, ∃ m, ∀ y, dist y x ≤ m → f y ≤ 1 / 2 ^ n := by
    apply exists_continuous_one_zero_of_isCompact hs
      ((U_open n).inter isOpen_interior).isClosed_compl
    rw [disjoint_compl_right_iff_subset]
    exact subset_inter ((hU.subset.trans (iInter_subset U n))) sm
  choose f fs fm _hf f_range using A
  obtain ⟨u, u_pos, u_sum, hu⟩ : ∃ (u : ℕ → ℝ), (∀ i, 0 < u i) ∧ Summable u ∧ ∑' i, u i = 1 :=
    ⟨fun n ↦ 1/2/2^n, fun n ↦ by positivity, summable_geometric_two' 1, tsum_geometric_two' 1⟩
  let g : X → ℝ := fun x ↦ ∑' n, u n * f n x
  have hgmc : EqOn g 0 mᶜ := by
    intro x hx
    have B n : f n x = 0 := by
      have : mᶜ ⊆ (U n ∩ interior m)ᶜ := by
        simpa using (inter_subset_right _ _).trans interior_subset
      exact fm n (this hx)
    simp [B]
  have I n x : u n * f n x ≤ u n := mul_le_of_le_one_right (u_pos n).le (f_range n x).2
  have S x : Summable (fun n ↦ u n * f n x) := Summable.of_nonneg_of_le
      (fun n ↦ mul_nonneg (u_pos n).le (f_range n x).1) (fun n ↦ I n x) u_sum
  refine ⟨⟨g, ?_⟩, ?_, hgmc.mono (subset_compl_comm.mp mt), ?_, fun x ↦ ⟨?_, ?_⟩⟩
  · apply continuous_tsum (fun n ↦ continuous_const.mul (f n).continuous) u_sum (fun n x ↦ ?_)
    simpa [abs_of_nonneg, (u_pos n).le, (f_range n x).1] using I n x
  · apply Subset.antisymm (fun x hx ↦ by simp [fs _ hx, hu]) ?_
    apply compl_subset_compl.1
    intro x hx
    obtain ⟨n, hn⟩ : ∃ n, x ∉ U n := by simpa [hU] using hx
    have fnx : f n x = 0 := fm _ (by simp [hn])
    have : g x < 1 := by
      apply lt_of_lt_of_le ?_ hu.le
      exact tsum_lt_tsum (i := n) (fun i ↦ I i x) (by simp [fnx, u_pos n]) (S x) u_sum
    simpa using this.ne
  · exact HasCompactSupport.of_support_subset_isCompact m_comp
      (Function.support_subset_iff'.mpr hgmc)
  · exact tsum_nonneg (fun n ↦ mul_nonneg (u_pos n).le (f_range n x).1)
  · apply le_trans _ hu.le
    exact tsum_le_tsum (fun n ↦ I n x) (S x) u_sum
  · intro n
    obtain ⟨m, hm⟩ : ∃ m, ∀ y, dist y x ≤ m → f n y ≤ 1 / 2 ^ n := by
      have : ∀ᶠ y in 𝓝 x, f n y ≤ 1 / 2 ^ n := by
        apply eventually_of_forall
        intro y
        apply (f_range n y).2
      obtain ⟨m, hm⟩ : ∃ m, ∀ y, dist y x ≤ m → f n y ≤ 1 / 2 ^ n := by
        apply eventually_nhds_iff.mp this
      exact ⟨m, hm⟩
    use m
    intro y hy
    have : ∀ i, u i * f i y ≤ u i * (1 / 2 ^ n) := by
      intro i
      apply mul_le_mul_of_nonneg_left (hm y (hy i)) (u_pos i).le
    have : ∑' i, u i * f i y ≤ ∑' i, u i * (1 / 2 ^ n) := tsum_le_tsum this (S y) u_sum
    simpa [mul_assoc, mul_tsum (fun i ↦ (u_pos i).le)] using this

## References #

- [G. Choquet, Sur les fonctions réelles mesurables suivant Carathéodory][choquet1950]
- [G. Choquet, Sur les fonctions réelles mesurables suivant Carathéodory][choquet1950]

## Tags #

Carathéodory, Carathéodory function, Carathéodory measurable function, Carathéodory measurable, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory measurable space, Carathéodory measurable function, Carathéodory measurable set, Carathéodory

Attempt failure.

STARTING: Lean repo copy removal
DONE: Lean repo copy removal
Among 100 proof attempts, there were 0 successful and 100 failed attempts at proving their respect theorems.
The rate of successful proof = 0.0.
