STARTING: verification of proofs from predicted_proof column in dataset from proof_verification/test_prediction.csv - 2024-08-20 12:56:56.293508
STARTING: Lean repo copy creation
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.git/objects/pack/pack-2f887c0acda0ac800361da7e632ea79714ae9239.pack: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.git/objects/pack/pack-62dd00090b01adcd332b9de3ec374634c086ee0f.rev: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.git/objects/pack/pack-2f887c0acda0ac800361da7e632ea79714ae9239.rev: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.git/objects/pack/pack-62dd00090b01adcd332b9de3ec374634c086ee0f.pack: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.git/objects/pack/pack-2915ca251bf413d83900b599b3425e12320e2084.idx: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.git/objects/pack/pack-2f887c0acda0ac800361da7e632ea79714ae9239.idx: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.git/objects/pack/pack-62dd00090b01adcd332b9de3ec374634c086ee0f.idx: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.git/objects/pack/pack-2915ca251bf413d83900b599b3425e12320e2084.rev: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.git/objects/pack/pack-2915ca251bf413d83900b599b3425e12320e2084.pack: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/proofwidgets/.git/objects/pack/pack-a17f1a0eef8938e8b0368ef8d6b2ce6e682e886c.idx: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/proofwidgets/.git/objects/pack/pack-a17f1a0eef8938e8b0368ef8d6b2ce6e682e886c.rev: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/proofwidgets/.git/objects/pack/pack-a17f1a0eef8938e8b0368ef8d6b2ce6e682e886c.pack: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/batteries/.git/objects/pack/pack-089d09ffdcc894e72a2f4b60ef5409443c48adfa.rev: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/batteries/.git/objects/pack/pack-089d09ffdcc894e72a2f4b60ef5409443c48adfa.pack: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/batteries/.git/objects/pack/pack-089d09ffdcc894e72a2f4b60ef5409443c48adfa.idx: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/Cli/.git/objects/pack/pack-2c450f0a4a35ef07649f1f312754aa59afd6d6ac.idx: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/Cli/.git/objects/pack/pack-2c450f0a4a35ef07649f1f312754aa59afd6d6ac.pack: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/Cli/.git/objects/pack/pack-2c450f0a4a35ef07649f1f312754aa59afd6d6ac.rev: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/aesop/.git/objects/pack/pack-170d24cfa85e47b7698857db9c7d0d1ed85fa8e5.rev: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/aesop/.git/objects/pack/pack-170d24cfa85e47b7698857db9c7d0d1ed85fa8e5.pack: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/aesop/.git/objects/pack/pack-170d24cfa85e47b7698857db9c7d0d1ed85fa8e5.idx: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/importGraph/.git/objects/pack/pack-789b0b04e21a4b1a56f8a9606a122df829607841.idx: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/importGraph/.git/objects/pack/pack-789b0b04e21a4b1a56f8a9606a122df829607841.pack: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/importGraph/.git/objects/pack/pack-789b0b04e21a4b1a56f8a9606a122df829607841.rev: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/Qq/.git/objects/pack/pack-5c2629a413780cce5c967e3b0f8c49b0179902e6.rev: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/Qq/.git/objects/pack/pack-5c2629a413780cce5c967e3b0f8c49b0179902e6.idx: Permission denied
cp: /Users/timmonkey/Desktop/Imperial/Summer Term/Individual Project/Repos/temp/verification/mathlib4/.lake/packages/Qq/.git/objects/pack/pack-5c2629a413780cce5c967e3b0f8c49b0179902e6.pack: Permission denied
Failed to create Lean repo copy
STARTING: retrieve cache
Attempting to download 4738 file(s)
Downloaded: 1 file(s) [attempted 1/4738 = 0%]Downloaded: 24 file(s) [attempted 27/4738 = 0%]Downloaded: 51 file(s) [attempted 54/4738 = 1%]Downloaded: 75 file(s) [attempted 79/4738 = 1%]Downloaded: 102 file(s) [attempted 106/4738 = 2%]Downloaded: 131 file(s) [attempted 136/4738 = 2%]Downloaded: 161 file(s) [attempted 167/4738 = 3%]Downloaded: 200 file(s) [attempted 208/4738 = 4%]Downloaded: 238 file(s) [attempted 248/4738 = 5%]Downloaded: 278 file(s) [attempted 289/4738 = 6%]Downloaded: 316 file(s) [attempted 329/4738 = 6%]Downloaded: 346 file(s) [attempted 360/4738 = 7%]Downloaded: 386 file(s) [attempted 400/4738 = 8%]Downloaded: 416 file(s) [attempted 431/4738 = 9%]Downloaded: 456 file(s) [attempted 472/4738 = 9%]Downloaded: 485 file(s) [attempted 502/4738 = 10%]Downloaded: 525 file(s) [attempted 542/4738 = 11%]Downloaded: 566 file(s) [attempted 583/4738 = 12%]Downloaded: 606 file(s) [attempted 624/4738 = 13%]Downloaded: 646 file(s) [attempted 664/4738 = 14%]Downloaded: 686 file(s) [attempted 705/4738 = 14%]Downloaded: 724 file(s) [attempted 745/4738 = 15%]Downloaded: 754 file(s) [attempted 775/4738 = 16%]Downloaded: 793 file(s) [attempted 816/4738 = 17%]Downloaded: 828 file(s) [attempted 851/4738 = 17%]Downloaded: 863 file(s) [attempted 887/4738 = 18%]Downloaded: 902 file(s) [attempted 927/4738 = 19%]Downloaded: 943 file(s) [attempted 968/4738 = 20%]Downloaded: 982 file(s) [attempted 1008/4738 = 21%]Downloaded: 1012 file(s) [attempted 1038/4738 = 21%]Downloaded: 1052 file(s) [attempted 1078/4738 = 22%]Downloaded: 1084 file(s) [attempted 1110/4738 = 23%]Downloaded: 1127 file(s) [attempted 1154/4738 = 24%]Downloaded: 1163 file(s) [attempted 1190/4738 = 25%]Downloaded: 1204 file(s) [attempted 1231/4738 = 25%]Downloaded: 1244 file(s) [attempted 1271/4738 = 26%]Downloaded: 1292 file(s) [attempted 1321/4738 = 27%]Downloaded: 1332 file(s) [attempted 1362/4738 = 28%]Downloaded: 1381 file(s) [attempted 1412/4738 = 29%]Downloaded: 1421 file(s) [attempted 1452/4738 = 30%]Downloaded: 1462 file(s) [attempted 1493/4738 = 31%]Downloaded: 1501 file(s) [attempted 1533/4738 = 32%]Downloaded: 1540 file(s) [attempted 1573/4738 = 33%]Downloaded: 1580 file(s) [attempted 1614/4738 = 34%]Downloaded: 1610 file(s) [attempted 1645/4738 = 34%]Downloaded: 1650 file(s) [attempted 1685/4738 = 35%]Downloaded: 1690 file(s) [attempted 1725/4738 = 36%]Downloaded: 1737 file(s) [attempted 1773/4738 = 37%]Downloaded: 1769 file(s) [attempted 1806/4738 = 38%]Downloaded: 1808 file(s) [attempted 1846/4738 = 38%]Downloaded: 1848 file(s) [attempted 1887/4738 = 39%]Downloaded: 1888 file(s) [attempted 1927/4738 = 40%]Downloaded: 1929 file(s) [attempted 1968/4738 = 41%]Downloaded: 1969 file(s) [attempted 2008/4738 = 42%]Downloaded: 2012 file(s) [attempted 2051/4738 = 43%]Downloaded: 2049 file(s) [attempted 2089/4738 = 44%]Downloaded: 2089 file(s) [attempted 2130/4738 = 44%]Downloaded: 2129 file(s) [attempted 2170/4738 = 45%]Downloaded: 2168 file(s) [attempted 2209/4738 = 46%]Downloaded: 2198 file(s) [attempted 2240/4738 = 47%]Downloaded: 2228 file(s) [attempted 2271/4738 = 47%]Downloaded: 2268 file(s) [attempted 2311/4738 = 48%]Downloaded: 2308 file(s) [attempted 2351/4738 = 49%]Downloaded: 2346 file(s) [attempted 2392/4738 = 50%]Downloaded: 2396 file(s) [attempted 2442/4738 = 51%]Downloaded: 2436 file(s) [attempted 2483/4738 = 52%]Downloaded: 2471 file(s) [attempted 2519/4738 = 53%]Downloaded: 2503 file(s) [attempted 2553/4738 = 53%]Downloaded: 2532 file(s) [attempted 2583/4738 = 54%]Downloaded: 2573 file(s) [attempted 2624/4738 = 55%]Downloaded: 2611 file(s) [attempted 2664/4738 = 56%]Downloaded: 2642 file(s) [attempted 2695/4738 = 56%]Downloaded: 2690 file(s) [attempted 2743/4738 = 57%]Downloaded: 2714 file(s) [attempted 2767/4738 = 58%]Downloaded: 2753 file(s) [attempted 2807/4738 = 59%]Downloaded: 2791 file(s) [attempted 2847/4738 = 60%]Downloaded: 2832 file(s) [attempted 2888/4738 = 60%]Downloaded: 2871 file(s) [attempted 2928/4738 = 61%]Downloaded: 2910 file(s) [attempted 2968/4738 = 62%]Downloaded: 2951 file(s) [attempted 3009/4738 = 63%]Downloaded: 2988 file(s) [attempted 3049/4738 = 64%]Downloaded: 3019 file(s) [attempted 3080/4738 = 65%]Downloaded: 3059 file(s) [attempted 3120/4738 = 65%]Downloaded: 3099 file(s) [attempted 3160/4738 = 66%]Downloaded: 3140 file(s) [attempted 3201/4738 = 67%]Downloaded: 3179 file(s) [attempted 3241/4738 = 68%]Downloaded: 3219 file(s) [attempted 3281/4738 = 69%]Downloaded: 3253 file(s) [attempted 3315/4738 = 69%]Downloaded: 3288 file(s) [attempted 3352/4738 = 70%]Downloaded: 3328 file(s) [attempted 3393/4738 = 71%]Downloaded: 3358 file(s) [attempted 3423/4738 = 72%]Downloaded: 3396 file(s) [attempted 3463/4738 = 73%]Downloaded: 3426 file(s) [attempted 3493/4738 = 73%]Downloaded: 3465 file(s) [attempted 3534/4738 = 74%]Downloaded: 3485 file(s) [attempted 3554/4738 = 75%]Downloaded: 3535 file(s) [attempted 3605/4738 = 76%]Downloaded: 3575 file(s) [attempted 3645/4738 = 76%]Downloaded: 3615 file(s) [attempted 3685/4738 = 77%]Downloaded: 3663 file(s) [attempted 3736/4738 = 78%]Downloaded: 3704 file(s) [attempted 3777/4738 = 79%]Downloaded: 3754 file(s) [attempted 3827/4738 = 80%]Downloaded: 3794 file(s) [attempted 3867/4738 = 81%]Downloaded: 3846 file(s) [attempted 3919/4738 = 82%]Downloaded: 3896 file(s) [attempted 3969/4738 = 83%]Downloaded: 3938 file(s) [attempted 4011/4738 = 84%]Downloaded: 3956 file(s) [attempted 4029/4738 = 85%]Downloaded: 3996 file(s) [attempted 4070/4738 = 85%]Downloaded: 4036 file(s) [attempted 4110/4738 = 86%]Downloaded: 4075 file(s) [attempted 4150/4738 = 87%]Downloaded: 4113 file(s) [attempted 4190/4738 = 88%]Downloaded: 4154 file(s) [attempted 4231/4738 = 89%]Downloaded: 4193 file(s) [attempted 4271/4738 = 90%]Downloaded: 4223 file(s) [attempted 4301/4738 = 90%]Downloaded: 4262 file(s) [attempted 4341/4738 = 91%]Downloaded: 4295 file(s) [attempted 4375/4738 = 92%]Downloaded: 4332 file(s) [attempted 4412/4738 = 93%]Downloaded: 4370 file(s) [attempted 4452/4738 = 93%]Downloaded: 4411 file(s) [attempted 4494/4738 = 94%]Downloaded: 4449 file(s) [attempted 4534/4738 = 95%]Downloaded: 4478 file(s) [attempted 4564/4738 = 96%]Downloaded: 4518 file(s) [attempted 4604/4738 = 97%]Downloaded: 4558 file(s) [attempted 4645/4738 = 98%]Downloaded: 4596 file(s) [attempted 4685/4738 = 98%]Downloaded: 4635 file(s) [attempted 4725/4738 = 99%]Downloaded: 4643 file(s) [attempted 4733/4738 = 99%]Downloaded: 4645 file(s) [attempted 4735/4738 = 99%]Downloaded: 4647 file(s) [attempted 4737/4738 = 99%]Downloaded: 4648 file(s) [attempted 4738/4738 = 100%] (98% success)
Warning: some files were not found in the cache.
This usually means that your local checkout of mathlib4 has diverged from upstream.
If you push your commits to a branch of the mathlib4 repository, CI will build the oleans and they will be available later.
Decompressing 4648 file(s)
Unpacked in 4990 ms
Completed successfully!
DONE: retrieve cache
Working on Mathlib/Algebra/Algebra/Hom.lean - 2024-08-20 12:57:37.632972.
---0/3204---
Verifying proof:
:=
  fun _ _ e ↦ FunLike.ext _ _ (fun x ↦ FunLike.ext _ _ (fun x ↦ FunLike.ext _ _ (fun x ↦ FunLike.ext _ _)))

For theorem:
lemma toIntAlgHom_injective [Ring R] [Ring S] [Algebra ℤ R] [Algebra ℤ S] :
    Function.Injective (RingHom.toIntAlgHom : (R →+* S) → _) 
Attempt failure.

Working on Mathlib/Algebra/Algebra/Operations.lean - 2024-08-20 12:57:43.528648.
---0/3204---
Verifying proof:
:= by
  ext x
  induction x using MulOpposite.rec'
  simp

For theorem:
theorem map_op_one :
    map (↑(opLinearEquiv R : A ≃ₗ[R] Aᵐᵒᵖ) : A →ₗ[R] Aᵐᵒᵖ) (1 : Submodule R A) = 1 
Attempt failure.

Working on Mathlib/Algebra/Algebra/Spectrum.lean - 2024-08-20 12:57:50.506572.
---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne k 0 with (rfl | h)
  · simpa [ha, zero_smul_set] using (show { rfl | h } = k • a by simpa [ha, zero_smul_set] using (show { rfl | k • a = k • a by simpa [ha, zero_smul_set] using (show { rfl | k • a = k • a by simpa [ha, zero_smul_set] using (show { rfl | k • a = k • a by simpa [ha, zero_smul_set] using (show { rfl | k • a = k • a by simpa [ha, zero_smul_set] using (show { rfl | k • a = k • a by simpa [ha, zero_smul_set] using (show { rfl | k • a = k • a by simpa [ha, zero_smul_set] using (show { rfl | k • a = k • a by simpa [ha, zero_smul_set] using (show { rfl | k • a = k • a by simpa [ha, zero_smul_set] using (show { rfl | k • a = k • a by simpa [ha, zero_smul_set] using (show { rfl | k • a = k • a by simpa [ha, zero_smul_set] using (show { rfl | k • a = k • a by simpa [ha, zero_smul_set] using (show { rfl | k • a = k • a by simpa [ha, zero_smul_set] using (show { rfl | k • a = k • a by simpa [ha, zero_smul_set] using (show { r

For theorem:
theorem smul_eq_smul [Nontrivial A] (k : 𝕜) (a : A) (ha : (σ a).Nonempty) :
    σ (k • a) = k • σ a 
Attempt failure.

Working on Mathlib/Algebra/Algebra/Subalgebra/Basic.lean - 2024-08-20 12:57:55.166922.
---0/3204---
Verifying proof:
:= fun s S =>
  ⟨fun H => le_trans (le_trans (Set.subset_union_right _ _) Subsemiring.subset_closure) H,
    fun H => show Subsemiring.subset_closure = ⊤⟩

For theorem:
theorem gc : GaloisConnection (adjoin R : Set A → Subalgebra R A) (↑) 
Attempt failure.

Working on Mathlib/Algebra/Associated.lean - 2024-08-20 12:58:01.357472.
---0/3204---
Verifying proof:
:= by
  simp only [irreducible_iff, Units.isUnit_mul_units, and_congr_right_iff]

For theorem:
theorem irreducible_mul_units (a : αˣ) (b : α) : Irreducible (b * ↑a) ↔ Irreducible b 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨u, rfl⟩ := Associated.dvdNotUnit_of_dvdNotUnit_associated h h'

For theorem:
theorem dvdNotUnit_of_dvdNotUnit_associated [CommMonoidWithZero α] [Nontrivial α] {p q r : α}
    (h : DvdNotUnit p q) (h' : Associated q r) : DvdNotUnit p r 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine injective_of_lt_imp_ne fun n m =>?_
  refine injective_of_lt_imp_ne fun n m =>?_
  · rw [pow_injective_of_not_isUnit hq']
    exact pow_ne_zero _ hq'

For theorem:
theorem pow_injective_of_not_unit [CancelCommMonoidWithZero α] {q : α} (hq : ¬IsUnit q)
    (hq' : q ≠ 0) : Function.Injective fun n : ℕ => q ^ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · refine fun h => Or.imp (fun h' => ⟨?_, h'⟩)
    refine fun h' => Or.imp (fun h' => ⟨?_,?_⟩) <;> rintro (h' | h') <;> simp

For theorem:
theorem irreducible_mul_iff {a b : α} :
    Irreducible (a * b) ↔ Irreducible a ∧ IsUnit b ∨ Irreducible b ∧ IsUnit a 
Attempt failure.

Working on Mathlib/Algebra/BigOperators/Fin.lean - 2024-08-20 12:58:17.350654.
---0/3204---
Verifying proof:
:= by
  rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr (Fin.castSucc_lt_succ_iff.mpr j.succ_pos)),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr (Fin.castSucc_lt_succ_iff.mpr j.succ_pos)),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr (Fin.castSucc_lt_succ_iff.mpr j.succ_pos)),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.

For theorem:
theorem inv_partialProd_mul_eq_contractNth {G : Type*} [Group G] (g : Fin (n + 1) → G)
    (j : Fin (n + 1)) (k : Fin n) :
    (partialProd g (j.succ.succAbove (Fin.castSucc k)))⁻¹ * partialProd g (j.succAbove k).succ =
      j.contractNth (· * ·) g k 
Attempt failure.

---0/3204---
Verifying proof:
  | [] => by
    rw [alternatingProd]
    rw [alternatingProd]
    rw [alternatingProd]
    simp only [Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons,
      Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons,
      Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons,
      Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons,
      Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons,
      Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons,
      Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons,
      Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons,
      Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons,
      Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Finset.prod_cons, Fi

For theorem:
theorem alternatingProd_eq_finset_prod {G : Type*} [CommGroup G] :
    ∀ (L : List G), alternatingProd L = ∏ i : Fin L.length, L.get i ^ (-1 : ℤ) ^ (i : ℕ)
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr (Fin.castSucc_lt_succ_iff.mpr j.succ_pos)),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr (Fin.castSucc_lt_succ_iff.mpr j.succ_pos)),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr (Fin.castSucc_lt_succ_iff.mpr j.succ_pos)),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr j.succ_pos),
    Fin.succAbove_of_castSucc_lt _ _ (Fin.

For theorem:
theorem inv_partialProd_mul_eq_contractNth {G : Type*} [Group G] (g : Fin (n + 1) → G)
    (j : Fin (n + 1)) (k : Fin n) :
    (partialProd g (j.succ.succAbove (Fin.castSucc k)))⁻¹ * partialProd g (j.succAbove k).succ =
      j.contractNth (· * ·) g k 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simpa [mul_comm] using prod_univ_succAbove f

For theorem:
theorem prod_univ_castSucc [CommMonoid β] {n : ℕ} (f : Fin (n + 1) → β) :
    ∏ i, f i = (∏ i : Fin n, f (Fin.castSucc i)) * f (last n) 
Attempt failure.

Working on Mathlib/Algebra/BigOperators/Finprod.lean - 2024-08-20 12:58:28.507178.
---0/3204---
Verifying proof:
:= by
  rw [g.map_finprod]

For theorem:
theorem MonoidHom.map_finprod_mem' {f : α → M} (g : M →* N) (h₀ : (s ∩ mulSupport f).Finite) :
    g (∏ᶠ j ∈ s, f j) = ∏ᶠ i ∈ s, g (f i) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [insert_eq, finprod_mem_union' _ hs]

For theorem:
theorem finprod_mem_insert' (f : α → M) (h : a ∉ s) (hs : (s ∩ mulSupport f).Finite) :
    ∏ᶠ i ∈ insert a s, f i = f a * ∏ᶠ i ∈ s, f i 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← finprod_mem_univ, finprod_mem_univ, finprod_mem_univ]

For theorem:
theorem finprod_eq_of_bijective {f : α → M} {g : β → M} (e : α → β) (he₀ : Bijective e)
    (he₁ : ∀ x, f x = g (e x)) : ∏ᶠ i, f i = ∏ᶠ j, g j 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
  rw [finprod_eq_prod_of_mulSupport_subset hf hg, finprod_eq_prod_of_mulSupport_subset hg]

For theorem:
theorem finprod_mul_distrib (hf : (mulSupport f).Finite) (hg : (mulSupport g).Finite) :
    ∏ᶠ i, f i * g i = (∏ᶠ i, f i) * ∏ᶠ i, g i 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine finprod_mem_inter_mulSupport_eq'?_?_ fun x hx => ⟨h hx, h hx⟩

For theorem:
theorem finprod_mem_insert_of_eq_one_if_not_mem (h : a ∉ s → f a = 1) :
    ∏ᶠ i ∈ insert a s, f i = ∏ᶠ i ∈ s, f i 
Attempt failure.

Working on Mathlib/Algebra/BigOperators/Finsupp.lean - 2024-08-20 12:58:55.689358.
---0/3204---
Verifying proof:
:=
  DFinsupp.liftAddHom_comp_liftAddHom (α := α) (M := M) (N := N) f

For theorem:
theorem liftAddHom_comp_single [AddCommMonoid M] [AddCommMonoid N] (f : α → M →+ N) (a : α) :
    ((liftAddHom (α := α) (M := M) (N := N)) f).comp (singleAddHom a) = f a 
Attempt failure.

Working on Mathlib/Algebra/BigOperators/Group/Finset.lean - 2024-08-20 12:59:01.752048.
---0/3204---
Verifying proof:
:=
  Eq.symm <|
    prod_subset (subset_union_left _ _) (subset_union_left _ _)

For theorem:
lemma prod_union_eq_left [DecidableEq α] (hs : ∀ a ∈ s₂, a ∉ s₁ → f a = 1) :
    ∏ a ∈ s₁ ∪ s₂, f a = ∏ a ∈ s₁, f a 
Attempt failure.

Working on Mathlib/Algebra/BigOperators/Group/List.lean - 2024-08-20 12:59:11.235427.
---0/3204---
Verifying proof:
:=
  (List.foldl_eq_foldr Nat.add_comm ← Nat.add_assoc' _ _).symm

For theorem:
lemma Nat.sum_eq_listSum (l : List ℕ) : Nat.sum l = l.sum 
Attempt failure.

Working on Mathlib/Algebra/BigOperators/Group/Multiset.lean - 2024-08-20 12:59:14.306577.
---0/3204---
Verifying proof:
:= by
  induction s <;> simp [Nat.mul_mod, *]

For theorem:
theorem prod_nat_mod (s : Multiset ℕ) (n : ℕ) : s.prod % n = (s.map (· % n)).prod % n 
Attempt failure.

Working on Mathlib/Algebra/BigOperators/Ring/List.lean - 2024-08-20 12:59:16.007492.
---0/3204---
Verifying proof:
:= by
  induction l <;> simp [*, pow_succ, mul_left_comm (_ ^ _)]

For theorem:
lemma prod_map_neg (l : List M) :
    (l.map Neg.neg).prod = (-1) ^ l.length * l.prod 
Attempt failure.

Working on Mathlib/Algebra/Category/ModuleCat/FilteredColimits.lean - 2024-08-20 12:59:16.978649.
---0/3204---
Verifying proof:
:= by
  refine Quot.inductionOn x?_; clear x; intro x; cases' x with j x
  erw [colimit_smul_mk_eq F 1 ⟨j, x⟩]
  simp

For theorem:
theorem colimitModule.one_smul (x : (M F)) : (1 : R) • x = x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Quot.inductionOn x?_; clear x; intro x; cases' x with j x
  erw [colimit_smul_mk_eq, _root_.add_assoc]

For theorem:
theorem colimitModule.add_smul (r s : R) (x : (M F)) : (r + s) • x = r • x + s • x 
Attempt failure.

Working on Mathlib/Algebra/Category/ModuleCat/Monoidal/Closed.lean - 2024-08-20 12:59:25.503462.
---0/3204---
Verifying proof:
:= by
  apply TensorProduct.ext'
  apply ModuleCat.monoidalClosed_uncurry

For theorem:
theorem ihom_ev_app (M N : ModuleCat.{u} R) :
    (ihom.ev M).app N = TensorProduct.uncurry _ _ _ _ LinearMap.id.flip 
Attempt failure.

Working on Mathlib/Algebra/Category/ModuleCat/Presheaf/Sheafification.lean - 2024-08-20 12:59:27.409921.
---0/3204---
Verifying proof:
:= by
  dsimp [sheafificationHomEquiv, sheafificationAdjunction]
  simp only [sheafificationHomEquiv, Equiv.apply_symm_apply]

For theorem:
lemma sheafificationHomEquiv_hom
    {P : PresheafOfModules.{v} R₀} {F : SheafOfModules.{v} R}
    (f : (sheafification α).obj P ⟶ F) :
    (sheafificationHomEquiv α f).hom =
      (sheafificationAdjunction J AddCommGrp).homEquiv P.presheaf
        ((SheafOfModules.toSheaf _).obj F) ((SheafOfModules.toSheaf _).map f) 
Attempt failure.

Working on Mathlib/Algebra/CharP/CharAndCard.lean - 2024-08-20 12:59:31.581968.
---0/3204---
Verifying proof:
:= by
  have hch := CharP.cast_eq_zero.mp hch
  have hch := CharP.cast_eq_zero.mp (CharP.cast_eq_zero.mp hch)
  refine ⟨fun h =>?_, fun h =>?_⟩
  · rintro ⟨p, hp⟩
    exact ⟨p, hp⟩

For theorem:
theorem isUnit_iff_not_dvd_char_of_ringChar_ne_zero (R : Type*) [CommRing R] (p : ℕ) [Fact p.Prime]
    (hR : ringChar R ≠ 0) : IsUnit (p : R) ↔ ¬p ∣ ringChar R 
Attempt failure.

Working on Mathlib/Algebra/CharP/ExpChar.lean - 2024-08-20 12:59:32.735669.
---0/3204---
Verifying proof:
:= by
  constructor
  · rintro rfl
    exact char_zero_of_expChar_one R p
  · rintro rfl
    exact char_zero_of_expChar_one R p

For theorem:
theorem expChar_one_iff_char_zero (p q : ℕ) [CharP R p] [ExpChar R q] : q = 1 ↔ p = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases hq
  · exact CharP.eq R hp inferInstance
  · exact CharP.eq R hp inferInstance

For theorem:
theorem char_zero_of_expChar_one (p : ℕ) [hp : CharP R p] [hq : ExpChar R 1] : p = 0 
Attempt failure.

Working on Mathlib/Algebra/CharP/LocalRing.lean - 2024-08-20 12:59:38.404414.
---0/3204---
Verifying proof:
:= by
  intro q_pos
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := LocalRing R
  let K := Loc

For theorem:
theorem charP_zero_or_prime_power (R : Type*) [CommRing R] [LocalRing R] (q : ℕ)
    [char_R_q : CharP R q] : q = 0 ∨ IsPrimePow q := by
    apply or_iff_not_imp_left.2
Attempt failure.

Working on Mathlib/Algebra/CharP/Quotient.lean - 2024-08-20 12:59:39.600821.
---0/3204---
Verifying proof:
:=
  ⟨fun x => by
    rw [← cast_eq_zero_iff] at h
    rw [← cast_eq_zero_iff] at h
    rw [← cast_eq_zero_iff] at h
    exact h x h

For theorem:
theorem quotient' {R : Type*} [CommRing R] (p : ℕ) [CharP R p] (I : Ideal R)
    (h : ∀ x : ℕ, (x : R) ∈ I → (x : R) = 0) : CharP (R ⧸ I) p 
Attempt failure.

Working on Mathlib/Algebra/CharZero/Quotient.lean - 2024-08-20 12:59:40.856350.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun ⟨k, hk⟩ => ⟨k,?_⟩⟩
  · rintro ⟨k, hk⟩
    refine ⟨k,?_⟩
    rw [← Int.cast_natAbs, ← Int.cast_natAbs, ← Int.cast_natAbs, ← Int.cast_natAbs, ←
      Int.cast_natAbs, ← Int.cast_natAbs, ← Int.cast_natAbs, ← Int.cast_natAbs, ←
      Int.cast_natAbs, ← Int.cast_natAbs, ← Int.cast_natAbs, ← Int.cast_natAbs, ← Int.cast_natAbs,
      Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs,
      Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs,
      Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs,
      Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs,
      Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs,
      Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs,
      Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs

For theorem:
theorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : ℤ} (hz : z ≠ 0) :
    z • r ∈ AddSubgroup.zmultiples p ↔
      ∃ k : Fin z.natAbs, r - (k : ℕ) • (p / z : R) ∈ AddSubgroup.zmultiples p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun ⟨k, hk⟩ => ⟨k,?_⟩⟩
  · rintro ⟨k, hk⟩
    refine ⟨k,?_⟩
    rw [← Int.cast_natAbs, ← Int.cast_natAbs, ← Int.cast_natAbs, ← Int.cast_natAbs, ←
      Int.cast_natAbs, ← Int.cast_natAbs, ← Int.cast_natAbs, ← Int.cast_natAbs, ←
      Int.cast_natAbs, ← Int.cast_natAbs, ← Int.cast_natAbs, ← Int.cast_natAbs, ← Int.cast_natAbs,
      Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs,
      Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs,
      Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs,
      Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs,
      Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs,
      Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs,
      Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs, Int.cast_natAbs

For theorem:
theorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : ℤ} (hz : z ≠ 0) :
    z • r ∈ AddSubgroup.zmultiples p ↔
      ∃ k : Fin z.natAbs, r - (k : ℕ) • (p / z : R) ∈ AddSubgroup.zmultiples p 
Attempt failure.

Working on Mathlib/Algebra/ContinuedFractions/Computation/TerminatesIffRat.lean - 2024-08-20 12:59:43.134805.
---0/3204---
Verifying proof:
:= by
  obtain ⟨n, v_eq_conv⟩ : ∃ n, v = (of v).convs n := of_correctness_of_terminates terminates

For theorem:
theorem exists_rat_eq_of_terminates (terminates : (of v).Terminates) : ∃ q : ℚ, v = ↑q 
Attempt failure.

Working on Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean - 2024-08-20 12:59:44.475345.
---0/3204---
Verifying proof:
:= by
  induction' n with n ih
  · refine IntFractPair.stream_eq_none_of_fr_eq_zero (IntFractPair.stream_eq_none_of_fr_eq_zero (IntFractPair.stream_eq_none_of_fr_eq_zero (IntFractPair.stream_none _))
      (IntFractPair.stream_succ_of_fr_eq_zero (IntFractPair.stream_succ_of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFractPair.of_fr_eq_zero (IntFrac

For theorem:
theorem stream_succ_of_int (a : ℤ) (n : ℕ) : IntFractPair.stream (a : K) (n + 1) = none 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases' eq_or_ne (fract v) 0 with h h
  · obtain ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨⌊v⌋, eq_of_sub_eq_zero h⟩
  · obtain ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨⌊v⌋, eq_of_sub_eq_zero h⟩
    refine ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨⌊v⌋, eq_of_sub_eq_zero?_⟩
  · obtain ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨⌊v⌋, eq_of_sub_eq_zero h⟩
    refine ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨⌊v⌋, eq_of_sub_eq_zero?_⟩
  · obtain ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨⌊v⌋, eq_of_sub_eq_zero h⟩
    refine ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨⌊v⌋, eq_of_sub_eq_zero?_⟩
  · obtain ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨⌊v⌋, eq_of_sub_eq_zero h⟩
    refine ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨⌊v⌋, eq_of_sub_eq_zero?_⟩
  · obtain ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨⌊v⌋, eq_of_sub_eq_zero h⟩
    refine ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨⌊v⌋, eq_of_sub_eq_zero?_⟩
  · obtain ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨

For theorem:
theorem of_s_succ (n : ℕ) : (of v).s.get? (n + 1) = (of (fract v)⁻¹).s.get? n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases hv : fract v = 0 <;> simp [tail_eq_dest]

For theorem:
theorem of_s_tail : (of v).s.tail = (of (fract v)⁻¹).s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [IntFractPair.stream, stream_succ_nth_fr_eq_zero, succ_nth_fr_eq_zero] at stream_succ_nth_fr_eq_zero
  rw [succ_nth_fr_eq_zero] at stream_succ_nth_fr_eq_zero
  rw [succ_nth_fr_eq_zero] at stream_succ_nth_fr_eq_zero

For theorem:
theorem exists_succ_nth_stream_of_fr_zero {ifp_succ_n : IntFractPair K}
    (stream_succ_nth_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n)
    (succ_nth_fr_eq_zero : ifp_succ_n.fr = 0) :
    ∃ ifp_n : IntFractPair K, IntFractPair.stream v n = some ifp_n ∧ ifp_n.fr⁻¹ = ⌊ifp_n.fr⁻¹⌋ := by
      rcases succ_nth_stream_eq_some_iff.mp stream_succ_nth_eq with
    ⟨ifp_n, seq_nth_eq, _, rfl⟩
Attempt failure.

Working on Mathlib/Algebra/ContinuedFractions/Translations.lean - 2024-08-20 12:59:50.223083.
---0/3204---
Verifying proof:
:= by
  simpa [partialNumerators, Seq'.map_get?] using nth_part_num_eq

For theorem:
theorem exists_s_a_of_part_num {a : α} (nth_part_num_eq : g.partialNumerators.get? n = some a) :
    ∃ gp, g.s.get? n = some gp ∧ gp.a = a 
Attempt failure.

Working on Mathlib/Algebra/DirectLimit.lean - 2024-08-20 12:59:51.289318.
---0/3204---
Verifying proof:
:=
  Nonempty.elim (by infer_instance) fun ind : ι =>
    Quotient.inductionOn' z

For theorem:
theorem exists_of [Nonempty ι] [IsDirected ι (· ≤ ·)] (z : DirectLimit G f) :
    ∃ i x, of R ι G f i x = z 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [RingHom.map_one, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul,
    RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul,
    RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul,
    RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul,
    RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul,
    RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul,
    RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul,
    RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul,
    RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul,
    RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul,
    RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul, RingHom.map_mul,
    RingHom.map_mul, RingHom.map_mul

For theorem:
theorem of.zero_exact_aux2 {x : FreeCommRing (Σi, G i)} {s t} [DecidablePred (· ∈ s)]
    [DecidablePred (· ∈ t)] (hxs : IsSupported x s) {j k} (hj : ∀ z : Σi, G i, z ∈ s → z.1 ≤ j)
    (hk : ∀ z : Σi, G i, z ∈ t → z.1 ≤ k) (hjk : j ≤ k) (hst : s ⊆ t) :
    f' j k hjk (lift (fun ix : s => f' ix.1.1 j (hj ix ix.2) ix.1.2) (restriction s x)) =
      lift (fun ix : t => f' ix.1.1 k (hk ix ix.2) ix.1.2) (restriction t x) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  haveI : Nonempty ι := ⟨i⟩
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact hj
  let ⟨j, hj, hxj⟩ := of.zero_exact h

For theorem:
theorem of.zero_exact [IsDirected ι (· ≤ ·)] {i x} (H : of R ι G f i x = 0) :
    ∃ j hij, f i j hij x = (0 : G j) 
Attempt failure.

Working on Mathlib/Algebra/DirectSum/Ring.lean - 2024-08-20 13:00:29.532346.
---0/3204---
Verifying proof:
:= by
  refine DFinsupp.ext fun i =>?_
  rw [DFinsupp.sum_subset fun i _ =>?_, DFinsupp.sum_subset fun i _ =>?_⟩
  · rw [DFinsupp.sum_single_index, DFinsupp.sum_single_index, DFinsupp.sum_singleton,
      DFinsupp.sum_single_index, DFinsupp.sum_single_index, DFinsupp.sum_single_index,
      DFinsupp.sum_single_index, DFinsupp.sum_single_index, DFinsupp.sum_singleton]
    exact DFinsupp.single_eq_same

For theorem:
theorem mul_eq_sum_support_ghas_mul [∀ (i : ι) (x : A i), Decidable (x ≠ 0)] (a a' : ⨁ i, A i) :
    a * a' =
      ∑ ij ∈ DFinsupp.support a ×ˢ DFinsupp.support a',
        DirectSum.of _ _ (GradedMonoid.GMul.mul (a ij.fst) (a' ij.snd)) 
Attempt failure.

Working on Mathlib/Algebra/Divisibility/Units.lean - 2024-08-20 13:00:36.851577.
---0/3204---
Verifying proof:
:= by
  rcases hu with ⟨u, rfl⟩
  apply Units.coe_dvd

For theorem:
theorem dvd : u ∣ a 
Attempt success.

---0/3204---
Verifying proof:
:= by
  rw [mul_comm]
  apply mul_right_dvd

For theorem:
theorem mul_left_dvd : ↑u * a ∣ b ↔ a ∣ b 
Attempt success.

Working on Mathlib/Algebra/FreeAlgebra.lean - 2024-08-20 13:00:38.338226.
---0/3204---
Verifying proof:
:= by
  simp only [← Algebra.map_top, ← Algebra.adjoin_range_eq_range_freeAlgebra]

For theorem:
theorem _root_.Algebra.adjoin_range_eq_range_freeAlgebra_lift (f : X → A) :
    Algebra.adjoin R (Set.range f) = (FreeAlgebra.lift R f).range 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  induction' n with n ih
  · simp only [AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul,
      AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul,
    AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul,
    AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul,
    AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul,
    AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul,
    AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul,
    AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul,
    AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul,
    AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map_mul, AlgHom.map

For theorem:
theorem induction {C : FreeAlgebra R X → Prop}
    (h_grade0 : ∀ r, C (algebraMap R (FreeAlgebra R X) r)) (h_grade1 : ∀ x, C (ι R x))
    (h_mul : ∀ a b, C a → C b → C (a * b)) (h_add : ∀ a b, C a → C b → C (a + b))
    (a : FreeAlgebra R X) : C a := by
    let s : Subalgebra R (FreeAlgebra R X) :=
    { carrier := C
      mul_mem' := h_mul _ _
      add_mem' := h_add _ _
      algebraMap_mem' 
Attempt failure.

Working on Mathlib/Algebra/FreeMonoid/Basic.lean - 2024-08-20 13:00:45.570323.
---0/3204---
Verifying proof:
  | [] => rfl
  | (_ :: xs) => congr_arg (fun x => List.foldl (· * ·) x xs) (one_mul _).symm
  | (_ :: xs) => congr_arg (fun x => List.foldl (· * ·) xs) (one_mul _).symm
  | (_ :: xs) => congr_arg (fun x => List.foldl (· * ·) xs) (one_mul _).symm
  | (_ :: xs) => congr_arg (fun x => List.foldl (· * ·) xs) (one_mul _).symm
    | (_ :: xs) => congr_arg (fun x => List.foldl (· * ·) xs) (one_mul _).symm
    | (_ :: xs) => congr_arg (fun x => List.foldl (· * ·) xs) (one_mul _).symm
    | (_ :: xs) => congr_arg (fun x => List.foldl (· * ·) xs) (one_mul _).symm
    | (_ :: xs) => congr_arg (fun x => List.foldl (· * ·) xs) (one_mul _).symm
    | (_ :: xs) => congr_arg (fun x => List.foldl (· * ·) xs) (one_mul _).symm
    | (_ :: xs) => congr_arg (fun x => List.foldl (· * ·) xs) (one_mul _).symm
    | (_ :: xs) => congr_arg (fun x => List.foldl (· * ·) xs) (one_mul _).symm
    | (_ :: xs) => congr_arg (fun x => List.foldl (· * ·) xs) (one_mul _).symm
    | (_ :: xs) => congr_arg (fun x => List

For theorem:
lemma prodAux_eq : ∀ l : List M, FreeMonoid.prodAux l = l.prod
Attempt failure.

Working on Mathlib/Algebra/GCDMonoid/Basic.lean - 2024-08-20 13:00:47.451641.
---0/3204---
Verifying proof:
:= by
  rw [pow_dvd_pow_iff_dvd_of_mul_eq_pow ha hd₁ hc hd₁, pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hd₁,
    pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hc hd₁, pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hd₁,
    pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hc hd₁, pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hd₁,
    pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hd₁, pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hd₁,
    pow_mul_eq_pow_iff_dvd_of_mul_eq_pow ha hd₁, pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hd₁,
    pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hd₁, pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hd₁,
    pow_mul_eq_pow_iff_dvd_of_mul_eq_pow ha hd₁, pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hd₁,
    pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hd₁, pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hd₁,
    pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hd₁, pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hd₁,
    pow_mul_eq_pow_iff_dvd_of_mul_eq_pow ha hd₁, pow_mul_eq_pow_iff_dvd_of_mul_eq_pow hab hd₁,
    pow

For theorem:
theorem pow_dvd_of_mul_eq_pow [GCDMonoid α] {a b c d₁ d₂ : α} (ha : a ≠ 0) (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) (hc : c = d₁ * d₂) (hd₁ : d₁ ∣ a) : d₁ ^ k ≠ 0 ∧ d₁ ^ k ∣ a 
Attempt failure.

Working on Mathlib/Algebra/GCDMonoid/Finset.lean - 2024-08-20 13:00:51.454727.
---0/3204---
Verifying proof:
:= by
  classical
    trans ((s.filter fun x ↦ f x = 0) ∪ s.filter fun x ↦ f x = 0) ∪ s.filter fun x ↦ f x = 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

For theorem:
theorem gcd_eq_gcd_filter_ne_zero [DecidablePred fun x : β ↦ f x = 0] :
    s.gcd f = (s.filter fun x ↦ f x ≠ 0).gcd f 
Attempt failure.

Working on Mathlib/Algebra/GeomSum.lean - 2024-08-20 13:00:52.852649.
---0/3204---
Verifying proof:
:= by
  refine sum_congr rfl fun i hi =>?_
  simp only [pow_succ', mul_assoc, mul_assoc]

For theorem:
theorem Commute.geom_sum₂_comm {α : Type u} [Semiring α] {x y : α} (n : ℕ)
    (h : Commute x y) :
    ∑ i ∈ range n, x ^ i * y ^ (n - 1 - i) = ∑ i ∈ range n, y ^ i * x ^ (n - 1 - i) 
Attempt failure.

Working on Mathlib/Algebra/GradedMonoid.lean - 2024-08-20 13:00:57.304328.
---0/3204---
Verifying proof:
:= by
  rw [List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons,
    List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons,
    List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons,
    List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons,
    List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons,
    List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons,
    List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons,
    List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons,
    List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons,
    List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons,
    List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons, List.dProd_cons,
    List.dProd_cons, List.dProd_cons

For theorem:
theorem SetLike.coe_list_dProd (A : ι → S) [SetLike.GradedMonoid A] (fι : α → ι)
    (fA : ∀ a, A (fι a)) (l : List α) : ↑(@List.dProd _ _ (fun i => ↥(A i)) _ _ l fι fA)
    = (List.prod (l.map fun a => fA a) : R) 
Attempt failure.

Working on Mathlib/Algebra/Group/Basic.lean - 2024-08-20 13:00:59.116772.
---0/3204---
Verifying proof:
:=
  mul_left_comm, mul_assoc

For theorem:
theorem mul_mul_mul_comm (a b c d : G) : a * b * (c * d) = a * c * (b * d) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  by rw [eq_inv_of_mul_eq_one_left h, one_div]

For theorem:
theorem eq_one_div_of_mul_eq_one_left (h : b * a = 1) : b = 1 / a 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [multiplicative_of_isTotal hswap hmul hswap hmul hswap hswap]

For theorem:
theorem multiplicative_of_isTotal (p : α → Prop) (hswap : ∀ {a b}, p a → p b → f a b * f b a = 1)
    (hmul : ∀ {a b c}, r a b → r b c → p a → p b → p c → f a c = f a b * f b c) {a b c : α}
    (pa : p a) (pb : p b) (pc : p c) : f a c = f a b * f b c 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [multiplicative_of_isTotal hswap hmul hswap hmul hswap hswap]

For theorem:
theorem multiplicative_of_isTotal (p : α → Prop) (hswap : ∀ {a b}, p a → p b → f a b * f b a = 1)
    (hmul : ∀ {a b c}, r a b → r b c → p a → p b → p c → f a c = f a b * f b c) {a b c : α}
    (pa : p a) (pb : p b) (pc : p c) : f a c = f a b * f b c 
Attempt failure.

Working on Mathlib/Algebra/Group/Defs.lean - 2024-08-20 13:01:15.259537.
---0/3204---
Verifying proof:
:=
  by rw [mul_assoc, mul_left_inv, mul_one]

For theorem:
theorem inv_mul_cancel_right (a b : G) : a * b⁻¹ * b = a 
Attempt failure.

Working on Mathlib/Algebra/Group/Fin.lean - 2024-08-20 13:01:17.333466.
---0/3204---
Verifying proof:
:= by
  rcases k with ⟨_ | k, hk⟩
  · simp only [zero_eta, zero_sub, lt_iff_val_lt_val, val_zero, coe_neg_one, zero_lt_succ]

For theorem:
lemma lt_sub_one_iff {k : Fin (n + 2)} : k < k - 1 ↔ k = 0 
Attempt failure.

Working on Mathlib/Algebra/Group/Hom/Defs.lean - 2024-08-20 13:01:18.296575.
---0/3204---
Verifying proof:
:=
  fun _ _ h => MonoidHom.ext <| MulHom.ext_iff.mp h

For theorem:
theorem MonoidHom.toMulHom_injective [MulOneClass M] [MulOneClass N] :
    Function.Injective (MonoidHom.toMulHom : (M →* N) → M →ₙ* N) 
Attempt failure.

Working on Mathlib/Algebra/Group/Semiconj/Defs.lean - 2024-08-20 13:01:21.115345.
---0/3204---
Verifying proof:
:= by
  unfold SemiconjBy
  rw [← mul_assoc, h.eq, mul_assoc, h'.eq, ← mul_assoc]

For theorem:
theorem mul_right (h : SemiconjBy a x y) (h' : SemiconjBy a x' y') :
    SemiconjBy a (x * x') (y * y') 
Attempt success.

Working on Mathlib/Algebra/Group/Subgroup/Basic.lean - 2024-08-20 13:01:21.815234.
---0/3204---
Verifying proof:
:=
  Subtype.ext_iff.. |>.1 <| (ofInjective hf).apply_symm_apply x

For theorem:
theorem apply_ofInjective_symm {f : G →* N} (hf : Function.Injective f) (x : f.range) :
    f ((ofInjective hf).symm x) = x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine
    ⟨fun hy => closure_induction hy?_?_?_?_, fun ⟨n, hn⟩ =>
      hn ▸ zpow_natCast x y⟩

For theorem:
theorem mem_closure_singleton {x y : G} : y ∈ closure ({x} : Set G) ↔ ∃ n : ℤ, x ^ n = y 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro a w
  refine closure_induction w (fun x hx =>?_)?_ (fun x y ihx ihy =>?_) fun x ihx =>?_) fun x ihx =>?_
  · rw [normalClosure_eq_closure]
    exact h hx

For theorem:
theorem normalClosure_le_normal {N : Subgroup G} [N.Normal] (h : s ⊆ N) : normalClosure s ≤ N 
Attempt failure.

---0/3204---
Verifying proof:
:=
  by simp_rw [closure_union, closure_eq]

For theorem:
theorem sup_eq_closure (H H' : Subgroup G) : H ⊔ H' = closure ((H : Set G) ∪ (H' : Set G)) 
Attempt failure.

Working on Mathlib/Algebra/Group/UniqueProds.lean - 2024-08-20 13:02:15.437926.
---0/3204---
Verifying proof:
:= by
  classical
  convert @mulHom_image_iff G H _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

For theorem:
theorem mulHom_map_iff (f : G ↪ H) (mul : ∀ x y, f (x * y) = f x * f y) :
    UniqueMul (A.map f) (B.map f) (f a0) (f b0) ↔ UniqueMul A B a0 b0 
Attempt failure.

---0/3204---
Verifying proof:
  uniqueMul_of_one_lt_card {A B} hc := by
    simp_rw [Nat.one_lt_mul_iff, card_pos] at hc
    obtain ⟨a, rfl⟩ := hc
    obtain ⟨a, rfl⟩ := hc
    obtain ⟨a, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
    obtain ⟨b, rfl⟩ := hc
  

For theorem:
theorem toTwoUniqueProds_of_group {G}
    [Group G] [UniqueProds G] : TwoUniqueProds G where
Attempt failure.

Working on Mathlib/Algebra/GroupWithZero/Units/Basic.lean - 2024-08-20 13:02:22.768408.
---0/3204---
Verifying proof:
:= by
  obtain rfl | ha := eq_or_ne a 0
  · rw [zero_pow (Nat.sub_pos_of_lt h).ne', zero_pow (by omega), zero_mul]

For theorem:
lemma pow_sub_of_lt (a : G₀) (h : n < m) : a ^ (m - n) = a ^ m * (a ^ n)⁻¹ 
Attempt failure.

Working on Mathlib/Algebra/Homology/DerivedCategory/Basic.lean - 2024-08-20 13:02:24.404155.
---0/3204---
Verifying proof:
:= by
  ext K L f
  simp only [quasiIso_eq_subcategoryAcyclic_W]

For theorem:
lemma quasiIso_eq_subcategoryAcyclic_W :
    quasiIso C (ComplexShape.up ℤ) = (subcategoryAcyclic C).W 
Attempt failure.

Working on Mathlib/Algebra/Homology/ExactSequence.lean - 2024-08-20 13:02:30.118410.
---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    constructor
  · intro h
    constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
    · intro h
      constructor
      · intro h
      constructor
      · intro h
      constructor
      · intro h
      constructor
      · intro h
      constructor
      · intro h
      constructor
      · intro h
      constructor
      · intro h
      constructor
      · intro h
      constructor
      · intro h
      constructor
      · intro h
      constructor
 

For theorem:
lemma exact_iff_δlast {n : ℕ} (S : ComposableArrows C (n + 2)) :
    S.Exact ↔ S.δlast.Exact ∧ (mk₂ (S.map' n (n + 1)) (S.map' (n + 1) (n + 2))).Exact 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    exact h.exact 0 (by omega)

For theorem:
lemma exact₂_iff (S : ComposableArrows C 2) (hS : S.IsComplex) :
    S.Exact ↔ (S.sc' hS 0 1 2).Exact 
Attempt failure.

---0/3204---
Verifying proof:
:= by exfalso; linarith

For theorem:
lemma isComplex₁ (S : ComposableArrows C 1) : S.IsComplex where
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    constructor
    · intro h
      constructor
    · rw [exact₂_iff]
      exact ⟨fun h => ⟨h⟩, fun h => ⟨h⟩, fun h => ⟨h⟩, fun h => ⟨h⟩⟩
    · rw [h⟩

For theorem:
lemma exact_iff_δ₀ (S : ComposableArrows C (n + 2)) :
    S.Exact ↔ (mk₂ (S.map' 0 1) (S.map' 1 2)).Exact ∧ S.δ₀.Exact 
Attempt failure.

Working on Mathlib/Algebra/Homology/HomologySequence.lean - 2024-08-20 13:02:51.935710.
---0/3204---
Verifying proof:
:= by
  rw [← cancel_mono S.f]
  infer_instance

For theorem:
lemma cycles_left_exact (S : ShortComplex (HomologicalComplex C c)) (hS : S.Exact) [Mono S.f]
    (i : ι) [S.X₁.HasHomology i] [S.X₂.HasHomology i] [S.X₃.HasHomology i] :
    (ShortComplex.mk (cyclesMap S.f i) (cyclesMap S.g i)
      (by rw [← cyclesMap_comp, S.zero, cyclesMap_zero])).Exact 
Attempt failure.

Working on Mathlib/Algebra/Homology/Homotopy.lean - 2024-08-20 13:02:57.394349.
---0/3204---
Verifying proof:
:= by
  ext n
  simp only [nullHomotopicMap, nullHomotopicMap'_comp]

For theorem:
theorem nullHomotopicMap'_comp (hom : ∀ i j, c.Rel j i → (C.X i ⟶ D.X j)) (g : D ⟶ E) :
    nullHomotopicMap' hom ≫ g = nullHomotopicMap' fun i j hij => hom i j hij ≫ g.f j 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  dsimp [nullHomotopicMap, nullHomotopicMap']
  simp only [nullHomotopicMap, Functor.map_comp, Functor.mapHomologicalComplex_obj,
    Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_map,
    Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_map,
    Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_map,
    Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_map,
    Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_obj,
    Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_map,
    Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_obj,
    Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_obj, Functor.mapHomologicalComplex_map,
    Functor.map

For theorem:
theorem map_nullHomotopicMap' {W : Type*} [Category W] [Preadditive W] (G : V ⥤ W) [G.Additive]
    (hom : ∀ i j, c.Rel j i → (C.X i ⟶ D.X j)) :
    (G.mapHomologicalComplex c).map (nullHomotopicMap' hom) =
      nullHomotopicMap' fun i j hij => by exact G.map (hom i j hij) 
Attempt failure.

Working on Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean - 2024-08-20 13:03:08.362639.
---0/3204---
Verifying proof:
:= by
  simp only [ofHom, HomotopyCategory.assoc, HomotopyCategory.comp_zero, HomotopyCategory.comp_zero,
    HomotopyCategory.comp_zero]

For theorem:
lemma ofHom_v_comp_d (φ : F ⟶ G) (p q q' : ℤ) (hpq : p + 0 = q) :
    (ofHom φ).v p q hpq ≫ G.d q q' = φ.f p ≫ G.d p q' 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply Cocycle.coe_add

For theorem:
lemma coe_add (z₁ z₂ : Cocycle F G n) :
    (↑(z₁ + z₂) : Cochain F G n) = (z₁ : Cochain F G n) + (z₂ : Cochain F G n) 
Attempt failure.

Working on Mathlib/Algebra/Homology/ImageToKernel.lean - 2024-08-20 13:03:19.400453.
---0/3204---
Verifying proof:
:= by
  ext
  simp [p]

For theorem:
theorem imageSubobjectMap_comp_imageToKernel (p : α.right = β.left) :
    imageToKernel f g w ≫ kernelSubobjectMap β = imageSubobjectMap α ≫ imageToKernel f' g' w' 
Attempt failure.

Working on Mathlib/Algebra/Homology/Localization.lean - 2024-08-20 13:03:23.825551.
---0/3204---
Verifying proof:
:= by
  have : DecidableRel c.Rel := by
    have : DecidableRel c.Rel := by
      have : DecidableRel c.Rel := by
      have : DecidableRel c.Rel := by
      have : DecidableRel c.Rel := by
      have : DecidableRel c.Rel := by
                                                                              have : DecidableRel c.Rel := by
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             

For theorem:
lemma ComplexShape.QFactorsThroughHomotopy_of_exists_prev [CategoryWithHomology C] :
    c.QFactorsThroughHomotopy C where
Attempt failure.

Working on Mathlib/Algebra/Homology/QuasiIso.lean - 2024-08-20 13:03:29.323355.
---0/3204---
Verifying proof:
:= by
  rw [Preadditive.exact_iff_homology'_zero]
  have h : f.f 0 ≫ X.d 0 1 = 0 := by simp
  refine ⟨h, Nonempty.ne_empty _⟩
  have h' : f.f 0 ≫ X.d 0 1 = 0 := by simp

For theorem:
theorem from_single₀_exact_f_d_at_zero [hf : QuasiIso' f] : Exact (f.f 0) (X.d 0 1) 
Attempt failure.

Working on Mathlib/Algebra/Homology/ShortComplex/ConcreteCategory.lean - 2024-08-20 13:03:34.788755.
---0/3204---
Verifying proof:
:= by
  rw [← AddCommGroupCat.mono_iff_injective]
  constructor
  · intro

For theorem:
lemma Preadditive.mono_iff_injective {X Y : C} (f : X ⟶ Y) :
    Mono f ↔ Function.Injective ((forget₂ C Ab).map f) 
Attempt failure.

Working on Mathlib/Algebra/Homology/ShortComplex/Exact.lean - 2024-08-20 13:03:40.186116.
---0/3204---
Verifying proof:
:= by
  rw [exact_iff_mono_fromOpcycles]
  have : IsSplitMono S.fromOpcycles :=
    ⟨⟨S.fromOpcycles⟩⟩
  have : IsSplitMono S.fromOpcycles :=
    ⟨⟨S.fromOpcycles⟩⟩

For theorem:
lemma exact_of_g_is_cokernel (hS : IsColimit (CokernelCofork.ofπ S.g S.zero))
    [S.HasHomology] : S.Exact 
Attempt failure.

Working on Mathlib/Algebra/Homology/ShortComplex/HomologicalComplex.lean - 2024-08-20 13:03:45.658127.
---0/3204---
Verifying proof:
:= by
  rw [K.descOpcycles_iff φ 1 (by simp) hφ, zero_comp, comp_zero, comp_zero, comp_zero,
    zero_comp, comp_zero, comp_zero]

For theorem:
lemma isIso_descOpcycles_iff (K : ChainComplex C ℕ) {X : C} (φ : K.X 0 ⟶ X)
    [K.HasHomology 0] (hφ : K.d 1 0 ≫ φ = 0) :
    IsIso (K.descOpcycles φ 1 (by simp) hφ) ↔
      (ShortComplex.mk _ _ hφ).Exact ∧ Epi φ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [hx, assoc, K.d_comp_d_assoc]

For theorem:
lemma liftCycles_homologyπ_eq_zero_of_boundary {A : C} (k : A ⟶ K.X i) (j : ι)
    (hj : c.next i = j) {i' : ι} (x : A ⟶ K.X i') (hx : k = x ≫ K.d i' i) :
    K.liftCycles k j hj (by rw [hx, assoc, K.d_comp_d, comp_zero]) ≫ K.homologyπ i = 0 
Attempt failure.

Working on Mathlib/Algebra/Homology/ShortComplex/Homology.lean - 2024-08-20 13:03:56.552928.
---0/3204---
Verifying proof:
:= by
  simp only [← cancel_epi h.left.π, ← cancel_mono h.right]

For theorem:
lemma HomologyData.leftRightHomologyComparison'_eq (h : S.HomologyData) :
    leftRightHomologyComparison' h.left h.right = h.iso.hom 
Attempt failure.

Working on Mathlib/Algebra/Homology/ShortComplex/LeftHomology.lean - 2024-08-20 13:04:02.023059.
---0/3204---
Verifying proof:
:= by
  infer_instance
  infer_instance

For theorem:
lemma isIso_cyclesMap'_of_isIso_of_mono (φ : S₁ ⟶ S₂) (h₂ : IsIso φ.τ₂) (h₃ : Mono φ.τ₃)
    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) :
    IsIso (cyclesMap' φ h₁ h₂) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [leftHomologyMap'_comp, leftHomologyMap'_comp, leftHomologyMap'_comp,
    leftHomologyMap'_comp, leftHomologyMap'_comp, leftHomologyMap'_comp,
    leftHomologyMap'_comp, leftHomologyMap'_comp, leftHomologyMap'_comp, leftHomologyMap'_comp,
    leftHomologyMap'_comp, leftHomologyMap'_comp, leftHomologyMap'_comp, leftHomologyMap'_comp,
    leftHomologyMap'_comp, leftHomologyMap'_comp, leftHomologyMap'_comp, leftHomologyMap'_comp]

For theorem:
lemma leftHomologyMap'_comp (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃)
    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) (h₃ : S₃.LeftHomologyData) :
    leftHomologyMap' (φ₁ ≫ φ₂) h₁ h₃ = leftHomologyMap' φ₁ h₁ h₂ ≫
      leftHomologyMap' φ₂ h₂ h₃ 
Attempt failure.

Working on Mathlib/Algebra/Homology/ShortComplex/Preadditive.lean - 2024-08-20 13:04:12.998727.
---0/3204---
Verifying proof:
:= by
  rw [← cancel_mono S₂.f, ← cancel_mono S₁.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f,
    ← cancel_mono S₁.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f,
    ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f,
    ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f,
    ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f,
    ← cancel_mono S₁.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f,
    ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f,
    ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f,
    ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f,
    ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f, ← cancel_mono S₂.f,
    ← cancel_

For theorem:
lemma leftHomologyMap_nullHomotopic [S₁.HasLeftHomology] [S₂.HasLeftHomology]
    (h₀ : S₁.X₁ ⟶ S₂.X₁) (h₀_f : h₀ ≫ S₂.f = 0)
    (h₁ : S₁.X₂ ⟶ S₂.X₁) (h₂ : S₁.X₃ ⟶ S₂.X₂) (h₃ : S₁.X₃ ⟶ S₂.X₃) (g_h₃ : S₁.g ≫ h₃ = 0) :
    leftHomologyMap (nullHomotopic _ _ h₀ h₀_f h₁ h₂ h₃ g_h₃) = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let γ : RightHomologyMapData φ h₁ h₂ := default
  simp only [γ.rightHomologyMap'_eq, RightHomologyMapData.neg_φH]

For theorem:
lemma rightHomologyMap'_neg :
    rightHomologyMap' (-φ) h₁ h₂ = -rightHomologyMap' φ h₁ h₂ 
Attempt failure.

Working on Mathlib/Algebra/Homology/ShortComplex/RightHomology.lean - 2024-08-20 13:04:24.199900.
---0/3204---
Verifying proof:
:= by
  rw [← cancel_epi φ.τ₂, ← cancel_epi φ.τ₂, ← cancel_epi φ.τ₂, ← cancel_epi φ.τ₂,
    ← cancel_epi φ.τ₂, ← cancel_epi φ.τ₂, ← cancel_epi φ.τ₂, ← cancel_mono φ.τ₂,
    ← cancel_epi φ.τ₂, ← cancel_epi φ.τ₂, ← cancel_epi φ.τ₂, ← cancel_mono φ.τ₂,
    ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂,
    ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂,
    ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂,
    ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂,
    ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂,
    ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂, ← cancel_mono φ.τ₂,
    ← cancel_mono φ.τ₂, ← cancel_mono φ.τ

For theorem:
lemma isIso_opcyclesMap'_of_isIso_of_epi (φ : S₁ ⟶ S₂) (h₂ : IsIso φ.τ₂) (h₁ : Epi φ.τ₁)
    (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) :
    IsIso (opcyclesMap' φ h₁ h₂) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← cancel_epi ((ofIsColimitCokernelCofork S hg c hc).p),
    ofIsColimitCokernelCofork_g' S hg c hc]

For theorem:
lemma ofIsColimitCokernelCofork_g' (hg : S.g = 0) (c : CokernelCofork S.f)
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [opcyclesMap'_comp, RightHomologyMapData.opcyclesMap'_comp,
    RightHomologyMapData.opcyclesMap'_comp]

For theorem:
lemma opcyclesMap'_comp (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃)
    (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) (h₃ : S₃.RightHomologyData) :
    opcyclesMap' (φ₁ ≫ φ₂) h₁ h₃ = opcyclesMap' φ₁ h₁ h₂ ≫ opcyclesMap' φ₂ h₂ h₃ 
Attempt failure.

Working on Mathlib/Algebra/Homology/ShortComplex/SnakeLemma.lean - 2024-08-20 13:04:40.550786.
---0/3204---
Verifying proof:
:= by
  rw [ShortComplex.exact_iff_exact_up_to_refinements]
  intro A x₂ hx₂
  obtain ⟨A₁, π₁, hπ₁, y₁, hy₁⟩ := S.L₁_exact.exact_up_to_refinements
  obtain ⟨A₂, π₁, hπ₁, y₁, hy₁⟩ := S.L₁_exact.exact_up_to_refinements
  obtain ⟨A₂, π₁, hπ₁, y₁, hy₁⟩ := S.L₁_exact.exact_up_to_refinements
  obtain ⟨A₂, π₁, hπ₁, y₁, hy₁⟩ := S.L₁_exact.exact_up_to_refinements
  obtain ⟨A₂, π₁, hπ₁, y₁, hy₁⟩ := S.L₁_exact.exact_up_to_refinements
  obtain ⟨A₂, π₁, hπ₁, y₁, hy₁⟩ := S.L₁_exact.exact_up_to_refinements
  obtain ⟨A₂, π₁, hπ₁, y₁, hy₁⟩ := S.L₁_exact.exact_up_to_refinements
  obtain ⟨A₂, π₁, hπ₁, y₁, hy₁⟩ := S.L₁_exact.exact_up_to_refinements
  obtain ⟨A₂, π₁, hπ₁, y₁, hy₁⟩ := S.L₁_exact.exact_up_to_refinements
  obtain ⟨A₂, π₁, hπ₁, y₁, hy₁⟩ := S.L₁_exact.exact_up_to_refinements
  obtain ⟨A₂, π₁, hπ₁, y₁, hy₁⟩ := S.L₁_exac

For theorem:
lemma L₀_exact : S.L₀.Exact 
Attempt failure.

Working on Mathlib/Algebra/Homology/TotalComplex.lean - 2024-08-20 13:04:45.980232.
---0/3204---
Verifying proof:
:= by
  simp [total.map, ιTotalOrZero]

For theorem:
lemma ιTotalOrZero_map (i₁ : I₁) (i₂ : I₂) (i₁₂ : I₁₂) :
    K.ιTotalOrZero c₁₂ i₁ i₂ i₁₂ ≫ (total.map φ c₁₂).f i₁₂ =
      (φ.f i₁).f i₂ ≫ L.ιTotalOrZero c₁₂ i₁ i₂ i₁₂ 
Attempt success.

---0/3204---
Verifying proof:
:= by
  rw [d₂_eq_d₂_assoc, d₂_eq_d₂_assoc, d₂_eq_d₂_assoc]

For theorem:
lemma d₂_eq_zero' (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') (i₁₂ : I₁₂)
    (h' : ComplexShape.π c₁ c₂ c₁₂ ⟨i₁, i₂'⟩ ≠ i₁₂) :
    K.d₂ c₁₂ i₁ i₂ i₁₂ = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [d₁_eq K c₁₂ h i₁ i₂ i₂ i₁₂, d₁_eq K c₁₂ h i₂ i₁₂ h']

For theorem:
lemma d₁_eq {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) (i₁₂ : I₁₂)
    (h' : ComplexShape.π c₁ c₂ c₁₂ ⟨i₁', i₂⟩ = i₁₂) :
    K.d₁ c₁₂ i₁ i₂ i₁₂ = ComplexShape.ε₁ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ • ((K.d i₁ i₁').f i₂ ≫
      K.toGradedObject.ιMapObj (ComplexShape.π c₁ c₂ c₁₂) ⟨i₁', i₂⟩ i₁₂ h') 
Attempt failure.

Working on Mathlib/Algebra/Homology/TotalComplexShift.lean - 2024-08-20 13:04:59.078312.
---0/3204---
Verifying proof:
:= by
  dsimp [totalShift₁XIso, totalShift₁XIso, totalShift₁XIso]

For theorem:
lemma D₁_totalShift₁XIso_hom (n₀ n₁ n₀' n₁' : ℤ) (h₀ : n₀ + x = n₀') (h₁ : n₁ + x = n₁') :
    ((shiftFunctor₁ C x).obj K).D₁ (up ℤ) n₀ n₁ ≫ (K.totalShift₁XIso x n₁ n₁' h₁).hom =
      x.negOnePow • ((K.totalShift₁XIso x n₀ n₀' h₀).hom ≫ K.D₁ (up ℤ) n₀' n₁') 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  dsimp [totalShift₁XIso, totalShift₁XIso, totalShift₁XIso]

For theorem:
lemma D₂_totalShift₁XIso_hom (n₀ n₁ n₀' n₁' : ℤ) (h₀ : n₀ + x = n₀') (h₁ : n₁ + x = n₁') :
    ((shiftFunctor₁ C x).obj K).D₂ (up ℤ) n₀ n₁ ≫ (K.totalShift₁XIso x n₁ n₁' h₁).hom =
      x.negOnePow • ((K.totalShift₁XIso x n₀ n₀' h₀).hom ≫ K.D₂ (up ℤ) n₀' n₁') 
Attempt failure.

Working on Mathlib/Algebra/Lie/Abelian.lean - 2024-08-20 13:05:10.346094.
---0/3204---
Verifying proof:
:= by
  simp only [LieModule.ker, LinearMap.ext_iff, LinearMap.zero_apply,
    toEndomorphism_apply_apply]

For theorem:
theorem mem_ker (x : L) : x ∈ LieModule.ker R L M ↔ ∀ m : M, ⁅x, m⁆ = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [LieModule.ker, LinearMap.ext_iff, LinearMap.zero_apply,
    toEndomorphism_apply_apply]

For theorem:
theorem mem_ker (x : L) : x ∈ LieModule.ker R L M ↔ ∀ m : M, ⁅x, m⁆ = 0 
Attempt failure.

Working on Mathlib/Algebra/Lie/Engel.lean - 2024-08-20 13:05:20.182445.
---0/3204---
Verifying proof:
:= by
  intro M _i1 _i2 _i3 _i4 h
  rw [← isNilpotent_range_toEndomorphism_iff]

For theorem:
theorem LieAlgebra.isEngelian_of_isNoetherian [IsNoetherian R L] : LieAlgebra.IsEngelian R L 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨K', hK'₁, hK'₂⟩ := exists_engelian_lieSubalgebra_of_lt_normalizer hK₁ hK₂ hK₁
  obtain ⟨K', hK'₁, hK'₂⟩ := exists_engelian_lt_of_lt_normalizer hK₁ hK₂
  refine ⟨K',?_,?_⟩
  · rintro ⟨K', hK'₁, hK'₂⟩
    exact ⟨K', hK'₁, hK'₂⟩

For theorem:
theorem LieAlgebra.exists_engelian_lieSubalgebra_of_lt_normalizer {K : LieSubalgebra R L}
    (hK₁ : LieAlgebra.IsEngelian.{u₁, u₂, u₄} R K) (hK₂ : K < K.normalizer) :
    ∃ (K' : LieSubalgebra R L), LieAlgebra.IsEngelian.{u₁, u₂, u₄} R K' ∧ K < K' 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro M _i1 _i2 _i3 _i4 _h
  use 1
  suffices (⊤ : LieIdeal R L) = ⊥ by simp [this]
  suffices (⊤ : LieIdeal R L) = ⊥ by simp [this]
  suffices (⊤ : LieIdeal R L) = ⊥ by simp [this]
  suffices (⊤ : LieIdeal R L) = ⊥ by simp [this]

For theorem:
theorem LieAlgebra.isEngelian_of_subsingleton [Subsingleton L] : LieAlgebra.IsEngelian R L 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← LieAlgebra.isEngelian_iff_wellFounded] at h ⊢
  intro x hx
  rw [← LieAlgebra.isEngelian_iff_wellFounded] at hx
  obtain ⟨x, hx⟩ := h x
  obtain ⟨x, hx⟩ := hx
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := hf x
  obtain ⟨y, hy⟩ := h y
  obtain ⟨y, hy⟩ := hf y
  obtain ⟨y, hy⟩ := hf y
  obtain ⟨y, hy⟩ := hf y
  obtain ⟨y, hy⟩ := hf y
  obtain ⟨y, hy⟩ := h

For theorem:
theorem Function.Surjective.isEngelian {f : L →ₗ⁅R⁆ L₂} (hf : Function.Surjective f)
    (h : LieAlgebra.IsEngelian.{u₁, u₂, u₄} R L) : LieAlgebra.IsEngelian.{u₁, u₃, u₄} R L₂ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [LieSubmodule.mem_coeSubmodule, Submodule.coe_toSubmodule, Submodule.mem_coeSubmodule]

For theorem:
theorem lie_top_eq_of_span_sup_eq_top (N : LieSubmodule R L M) :
    (↑⁅(⊤ : LieIdeal R L), N⁆ : Submodule R M) =
      (N : Submodule R M).map (toEnd R L M x) ⊔ (↑⁅I, N⁆ : Submodule R M) 
Attempt failure.

Working on Mathlib/Algebra/Lie/InvariantForm.lean - 2024-08-20 13:05:37.600584.
---0/3204---
Verifying proof:
:= by
  refine ⟨?_,?_, hL⟩
  · simpa using atomistic Φ hΦ_nondeg hΦ_inv hΦ_refl hL ⊤
    intro I hI
    apply (orthogonal_disjoint Φ hΦ_nondeg hΦ_inv hΦ_refl hL ⊤).intro I hI
    apply (orthogonal_disjoint Φ hΦ_inv hΦ_refl hL ⊤).intro I hI
    apply (orthogonal_disjoint Φ hΦ_inv hΦ_refl hL ⊤).intro I hI
    apply (orthogonal_disjoint Φ hΦ_inv hΦ_refl hL ⊤).intro I hI
    apply (orthogonal_disjoint Φ hΦ_inv hΦ_refl hL ⊤).intro I hI
    apply (orthogonal_disjoint Φ hΦ_inv hΦ_refl hL ⊤).intro I hI
    apply (orthogonal_disjoint Φ hΦ_inv hΦ_refl hL ⊤).intro I hI
    apply (orthogonal_disjoint Φ hΦ_inv hΦ_refl hL ⊤).intro I hI
    apply (orthogonal_disjoint Φ hΦ_inv hΦ_refl hL ⊤).intro I hI
    apply (orthogonal_disjoint Φ hΦ_inv hΦ_refl hL ⊤).intro I hI
    apply (orthogonal_disjoint Φ hΦ_inv hΦ_refl hL ⊤).intro I hI
    apply (orthogonal_disjoint Φ hΦ_inv hΦ_refl hL ⊤).intro I hI
    apply (orthogonal_disjoint Φ hΦ_inv hΦ_refl hL ⊤).i

For theorem:
theorem isSemisimple_of_nondegenerate : IsSemisimple K L 
Attempt failure.

Working on Mathlib/Algebra/Lie/Nilpotent.lean - 2024-08-20 13:05:40.591978.
---0/3204---
Verifying proof:
:= by
  let s := {k | lowerCentralSeries R L M k = ⊥}
  have hs : s.Nonempty := by
    obtain ⟨k, hk⟩ := hs
    obtain ⟨k, hk⟩ := hs
    obtain ⟨k, hk⟩ := hs
    obtain ⟨k, hk⟩ := hs
    obtain ⟨k, hk⟩ := hs
    exact ⟨k, hk⟩

For theorem:
theorem nilpotencyLength_eq_zero_iff [IsNilpotent R L M] :
    nilpotencyLength R L M = 0 ↔ Subsingleton M 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_,?_⟩
  · have : (ad R L).ker = center R L := by simp
  · have : (ad R L).ker = center R L := by simp
    exact
      LieAlgebra.isNilpotent_of_isNilpotent_ad_of_isNilpotent R L h
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

For theorem:
theorem LieAlgebra.isNilpotent_range_ad_iff : IsNilpotent R (ad R L).range ↔ IsNilpotent R L 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [isNilpotent_iff]

For theorem:
theorem _root_.LieSubmodule.isNilpotent_iff_exists_lcs_eq_bot (N : LieSubmodule R L M) :
    LieModule.IsNilpotent R L N ↔ ∃ k, N.lcs k = ⊥ 
Attempt failure.

Working on Mathlib/Algebra/Lie/OfAssociative.lean - 2024-08-20 13:05:58.692077.
---0/3204---
Verifying proof:
:= by
  refine Finset.sum_congr rfl fun i _ =>?_
  simp only [LinearMap.map_smul, LinearMap.map_smul, LinearMap.map_smul, LinearMap.map_smulₛₗ,
    LinearMap.map_smulₛₗ, LinearMap.map_smulₛₗ, LinearMap.map_smulₛₗ, LinearMap.map_smulₛₗ,
    LinearMap.map_smulₛₗ]

For theorem:
lemma LieAlgebra.ad_pow_lie (x y z : L) (n : ℕ) :
    ((ad R L x) ^ n) ⁅y, z⁆ =
      ∑ ij ∈ antidiagonal n, n.choose ij.1 • ⁅((ad R L x) ^ ij.1) y, ((ad R L x) ^ ij.2) z⁆ 
Attempt failure.

Working on Mathlib/Algebra/Lie/Rank.lean - 2024-08-20 13:06:03.652969.
---0/3204---
Verifying proof:
:=
  (ad K L x).finrank_maximalGeneralizedEigenspace

For theorem:
lemma finrank_engel (x : L) :
    finrank K (engel K x) = (ad K L x).charpoly.natTrailingDegree 
Attempt failure.

Working on Mathlib/Algebra/Lie/Sl2.lean - 2024-08-20 13:06:08.061565.
---0/3204---
Verifying proof:
:= by
  induction' n with n ih
  · simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, sub_zero]
  · simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, zero_mul, zero_add]
  · simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, zero_add]
  · simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, zero_mul, zero_add]
  · simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, zero_add]
  · simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, zero_mul, zero_add]
  · simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, zero_add]
  · simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, zero_add]
  · simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, zero_mul, zero_add]
  · simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, zero_add]
    simp only [zero_add, pow_one, toEnd_apply_apply, Nat.cast_zero, zero_add, Nat.cast_succ,
      Nat.cast_zero, zero_add, Nat.cast_zero, zero_add, Nat.cast_succ

For theorem:
lemma lie_e_pow_succ_toEnd_f (n : ℕ) :
    ⁅e, ψ (n + 1)⁆ = ((n + 1) * (μ - n)) • ψ n 
Attempt failure.

Working on Mathlib/Algebra/Lie/Solvable.lean - 2024-08-20 13:06:10.626199.
---0/3204---
Verifying proof:
:= by
  revert l; induction' k with k ih <;> intro l h₂
  · rw [Nat.zero_eq] at h₂
    rw [Nat.zero_eq] at h₂
    rw [Nat.zero_eq] at h₂
    exact h₁ h₂

For theorem:
theorem derivedSeriesOfIdeal_le {I J : LieIdeal R L} {k l : ℕ} (h₁ : I ≤ J) (h₂ : l ≤ k) :
    D k I ≤ D l J 
Attempt failure.

Working on Mathlib/Algebra/Lie/TraceForm.lean - 2024-08-20 13:06:13.586215.
---0/3204---
Verifying proof:
:= by
  ext x y
  simp only [traceForm_apply_apply, LinearMap.zero_apply, ← isNilpotent_iff_eq_zero]

For theorem:
lemma traceForm_eq_zero_of_isNilpotent [IsReduced R] [IsNilpotent R L M] :
    traceForm R L M = 0 
Attempt failure.

Working on Mathlib/Algebra/Lie/Weights/Basic.lean - 2024-08-20 13:06:24.895437.
---0/3204---
Verifying proof:
:= by
  suffices ∀ m l, (toEndomorphism R L M x ^ l) m ∈ lowerCentralSeries R L M k by
    intro m l
    rw [lowerCentralSeries_succ]
    exact posFittingCompOf_le_lowerCentralSeries R L M x k

For theorem:
lemma posFittingCompOf_le_lowerCentralSeries (x : L) (k : ℕ) :
    posFittingCompOf R M x ≤ lowerCentralSeries R L M k 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simpa only [isCompl_iff, codisjoint_iff, disjoint_iff, ← LieSubmodule.span_eq] using h

For theorem:
lemma isCompl_weightSpaceOf_zero_posFittingCompOf (x : L) :
    IsCompl (weightSpaceOf M 0 x) (posFittingCompOf R M x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine weight_vector_multiplication_multiplication R L M₁ M₂?_?_?_?_
  · simp only [weight_vector_multiplication, weight_vector_multiplication]
    exact weight_vector_multiplication_multiplication_multiplication_multiplication R L M₁
  · simp only [weight_vector_multiplication, weight_vector_multiplication, weight_vector_multiplication]
    exact weight_vector_multiplication_multiplication_multiplication_multiplication R L M₁
  · simp only [weight_vector_multiplication, weight_vector_multiplication, weight_vector_multiplication]
    exact weight_vector_multiplication_multiplication_multiplication_multiplication R L M₁
  · simp only [weight_vector_multiplication, weight_vector_multiplication, weight_vector_multiplication]

For theorem:
theorem weight_vector_multiplication (M₁ M₂ M₃ : Type*)
    [AddCommGroup M₁] [Module R M₁] [LieRingModule L M₁] [LieModule R L M₁] [AddCommGroup M₂]
    [Module R M₂] [LieRingModule L M₂] [LieModule R L M₂] [AddCommGroup M₃] [Module R M₃]
    [LieRingModule L M₃] [LieModule R L M₃] (g : M₁ ⊗[R] M₂ →ₗ⁅R,L⁆ M₃) (χ₁ χ₂ : R) (x : L) :
    LinearMap.range ((g : M₁ ⊗[R] M₂ →ₗ[R] M₃).comp (mapIncl 𝕎(M₁, χ₁, x) 𝕎(M₂, χ₂, x))) ≤
      𝕎(M₃, χ₁ + χ₂, x) := by
    intro m₃
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine le_antisymm (fun m hm ↦?_)?_
  · simp only [LieSubmodule.mem_comap, LieSubmodule.mem_comap]
  · simp only [LieSubmodule.mem_comap, LieSubmodule.mem_comap, LieSubmodule.mem_comap,
      LieSubmodule.mem_comap, LieSubmodule.mem_comap, LieSubmodule.mem_comap,
      LieSubmodule.mem_comap, LieSubmodule.mem_comap, LieSubmodule.mem_comap,
      LieSubmodule.mem_comap]

For theorem:
lemma comap_weightSpace_eq_of_injective (hf : Injective f) :
    (weightSpace M₂ χ).comap f = weightSpace M χ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
  suffices ∀ χ (s : Finset (L → R)) (_ : χ ∉ s), χ ∉ weightSpace M χ by
    intro χ s hs hχ
    refine ⟨?_,?_⟩
    rintro ⟨χ, hχ⟩
    simp only [Finset.mem_image, Finset.mem_coe, Finset.mem_coe, Finset.mem_image,
      Finset.mem_coe, Finset.mem_image, Finset.mem_coe, Finset.mem_image, Finset.mem_coe,
      Finset.mem_image, Finset.mem_coe, Finset.mem_coe, Finset.mem_image, not_exists, not_and,
      Finset.mem_image, Finset.mem_coe, Finset.mem_image, not_exists, not_exists, not_forall,
      Finset.mem_image, Finset.mem_coe, Finset.mem_coe, Finset.mem_image, not_exists,
      Finset.mem_image, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_image,
      Finset.mem_image, Finset.mem_coe, Finset.mem_coe, Finset.mem_image, not_exists, not_and,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff⟩
    simp only [Finset.mem_image, Finset.mem_image, Finset.mem_coe, Finset.mem_image,
      Finset.mem_coe, Finset.mem_coe, Finset.mem_image, not_exists, n

For theorem:
lemma independent_weightSpace [NoZeroSMulDivisors R M] :
    CompleteLattice.Independent fun (χ : L → R) ↦ weightSpace M χ 
Attempt failure.

Working on Mathlib/Algebra/Lie/Weights/Chain.lean - 2024-08-20 13:07:14.470618.
---0/3204---
Verifying proof:
:= by
  let e : ℤ ≃ ℤ := neg_involutive.toPerm
  simp_rw [weightSpaceChain, ← weightSpaceChain_neg]
  simp_rw [weightSpaceChain, ← weightSpaceChain_neg, ← weightSpaceChain_symm_apply,
    weightSpaceChain_symm_apply]

For theorem:
lemma weightSpaceChain_neg :
    weightSpaceChain M (-χ₁) χ₂ (-q) (-p) = weightSpaceChain M χ₁ χ₂ p q 
Attempt failure.

Working on Mathlib/Algebra/Lie/Weights/Killing.lean - 2024-08-20 13:07:22.432731.
---0/3204---
Verifying proof:
:= by
  obtain ⟨e : L, he₀ : e ≠ 0, he : ∀ x, ⁅x, e⁆ = α x • e⁆ • e⁆ = α x • e⁆ := by
    intro x
    simp only [mem_corootSpace, cartanEquivDual_symm_apply, cartanEquivDual_apply,
      cartanEquivDual_symm_apply, cartanEquivDual_symm_apply, cartanEquivDual_symm_apply,
      cartanEquivDual_symm_apply, cartanEquivDual_apply, cartanEquivDual_symm_apply,
      cartanEquivDual_symm_apply, cartanEquivDual_symm_apply, cartanEquivDual_symm_apply,
      cartanEquivDual_symm_apply, cartanEquivDual_symm_apply, cartanEquivDual_apply,
      cartanEquivDual_symm_apply, cartanEquivDual_symm_apply, cartanEquivDual_symm_apply,
      cartanEquivDual_symm_apply, cartanEquivDual_symm_apply, cartanEquivDual_symm_apply,
      cartanEquivDual_symm_apply, cartanEquivDual_symm_apply, cartanEquivDual_symm_apply,
      cartanEquivDual_symm_apply, cartanEquivDual_symm_apply, cartanEquivDual_symm_apply,
      cartanEquivDual_symm_apply, cartanEquivDual_symm_apply, cartanEquivDual_symm_apply,
      cartanEqui

For theorem:
lemma cartanEquivDual_symm_apply_mem_corootSpace (α : Weight K H L) :
    (cartanEquivDual H).symm α ∈ corootSpace α 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [killingForm_apply_eq_zero_of_mem_rootSpace_of_mem_rootSpace_of_mem_rootSpace hx hy,
    killingForm_apply_eq_zero_of_mem_rootSpace_of_mem_rootSpace hy hx hy]

For theorem:
lemma killingForm_apply_eq_zero_of_mem_rootSpace_of_add_ne_zero {α β : H → K} {x y : L}
    (hx : x ∈ rootSpace H α) (hy : y ∈ rootSpace H β) (hαβ : α + β ≠ 0) :
    killingForm K L x y = 0 := by
    let σ : (H → K) → (H → K) 
Attempt failure.

Working on Mathlib/Algebra/LinearRecurrence.lean - 2024-08-20 13:08:00.398662.
---0/3204---
Verifying proof:
:= by
  refine Iff.intro (fun h x _ ↦ h ▸ rfl)?_
  intro h x hx
  refine ⟨fun h x _ ↦ h ▸ h ▸ Set.mem_range_self _, fun h ↦?_⟩
  · rintro rfl
    exact ⟨fun h x _ ↦ h ▸ h ▸ Set.mem_range_self _, fun h x hx ↦ ⟨hx, hx⟩⟩
  · rintro rfl
    exact ⟨fun 

For theorem:
theorem sol_eq_of_eq_init (u v : ℕ → α) (hu : E.IsSolution u) (hv : E.IsSolution v) :
    u = v ↔ Set.EqOn u v ↑(range E.order) 
Attempt failure.

Working on Mathlib/Algebra/Module/DedekindDomain.lean - 2024-08-20 13:08:02.875563.
---0/3204---
Verifying proof:
:= by
  refine isInternal_prime_power_torsion_of_isInternal_prime_power_torsion?_?_
  · rintro ⟨p, hp⟩ ⟨p', hp'⟩
    exact ⟨p', hp'⟩
  · exact ⟨p', hp'⟩
  · exact ⟨p ^ (factors (⊤ : Submodule R M).annihilator), hp'⟩
  · exact ⟨p ^ (factors (⊤ : Submodule R M).annihilator),?_⟩
  · exact ⟨p ^ (factors (⊤ : Submodule R M).annihilator),?_⟩
  · exact ⟨p ^ (factors (⊤ : Submodule R M).annihilator),?_⟩
  · exact ⟨p ^ (factors (⊤ : Submodule R M).annihilator),?_⟩
  · rintro ⟨p', hp'⟩
    exact ⟨p', hp'⟩
  · exact ⟨p ^ (factors (⊤ : S

For theorem:
theorem isInternal_prime_power_torsion [Module.Finite R M] (hM : Module.IsTorsion R M) :
    DirectSum.IsInternal fun p : (factors (⊤ : Submodule R M).annihilator).toFinset =>
      torsionBySet R M (p ^ (factors (⊤ : Submodule R M).annihilator).count ↑p : Ideal R) 
Attempt failure.

Working on Mathlib/Algebra/Module/Defs.lean - 2024-08-20 13:08:04.663855.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun m n h => @Nat.cast_injective M _ _ _ _ _⟩
  rw [← nsmul_one, ← nsmul_one, ← nsmul_one, ← nsmul_one, ← nsmul_one, nsmul_one, nsmul_one]

For theorem:
theorem CharZero.of_module (M) [AddCommMonoidWithOne M] [CharZero M] [Module R M] : CharZero R 
Attempt failure.

Working on Mathlib/Algebra/Module/Injective.lean - 2024-08-20 13:08:08.106608.
---0/3204---
Verifying proof:
:= by
  refine Submodule.eq_top_iff'.mpr fun y =>?_
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensionOfMax_is_max i f]
  dsimp
  rw [← extensi

For theorem:
theorem extensionOfMax_to_submodule_eq_top (h : Module.Baer R Q) :
    (extensionOfMax i f).domain = ⊤ 
Attempt failure.

Working on Mathlib/Algebra/Module/PID.lean - 2024-08-20 13:08:13.556503.
---0/3204---
Verifying proof:
:= by
  obtain ⟨d, k, hk⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtain ⟨d, hd⟩ := Module.Finite.exists_fin R N
  obtai

For theorem:
theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ∃ (d : ℕ) (k : Fin d → ℕ), Nonempty <| N ≃ₗ[R] ⨁ i : Fin d, R ⧸ R ∙ p ^ (k i : ℕ) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain ⟨n, hn⟩ := Module.Finite.exists_fin R N
  obtain 

For theorem:
theorem equiv_free_prod_directSum [h' : Module.Finite R N] :
    ∃ (n : ℕ) (ι : Type u) (_ : Fintype ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i) (e : ι → ℕ),
      Nonempty <| N ≃ₗ[R] (Fin n →₀ R) × ⨁ i : ι, R ⧸ R ∙ p i ^ e i 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [IsSemisimpleModule, ← (submodule_torsionBy_orderIso a).coe_torsionBy_orderIso,
    (submodule_torsionBy_orderIso a).coe_torsionBy_orderIso]

For theorem:
theorem Submodule.isSemisimple_torsionBy_of_irreducible {a : R} (h : Irreducible a) :
    IsSemisimpleModule R (torsionBy R M a) 
Attempt failure.

Working on Mathlib/Algebra/Module/Projective.lean - 2024-08-20 13:08:30.358101.
---0/3204---
Verifying proof:
:= by
  use b.constr ℕ fun i => Finsupp.single (b i) (1 : R)

For theorem:
theorem Projective.of_basis {ι : Type*} (b : Basis ι R P) : Projective R P := by
      use b.constr ℕ fun i => Finsupp.single (b i) (1 : R)
Attempt failure.

---0/3204---
Verifying proof:
:= by
  use b.constr ℕ fun i => Finsupp.single (b i) (1 : R)

For theorem:
theorem Projective.of_basis {ι : Type*} (b : Basis ι R P) : Projective R P := by
      use b.constr ℕ fun i => Finsupp.single (b i) (1 : R)
Attempt failure.

Working on Mathlib/Algebra/Module/Submodule/LinearMap.lean - 2024-08-20 13:08:36.022235.
---0/3204---
Verifying proof:
:= by
  change _ * _ = _ * _ * _

For theorem:
lemma restrict_commute {f g : M →ₗ[R] M} (h : Commute f g) {p : Submodule R M}
    (hf : MapsTo f p p) (hg : MapsTo g p p) :
    Commute (f.restrict hf) (g.restrict hg) 
Attempt failure.

Working on Mathlib/Algebra/Module/Torsion.lean - 2024-08-20 13:08:38.501739.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun h x =>?_, fun h x =>?_⟩
  · obtain ⟨n, h0, hn⟩ := (h x).exists_smul_eq n
    refine ⟨fun h x =>?_, fun h x =>?_⟩
    · obtain ⟨n, h0, hn⟩ := (h x).exists_smul_eq (h x).exists_smul_eq (h x).exists_smul_eq?_⟩
  · rw [← isTorsion_iff_isTorsio

For theorem:
theorem isTorsion_iff_isTorsion_int [AddCommGroup M] :
    AddMonoid.IsTorsion M ↔ Module.IsTorsion ℤ M 
Attempt failure.

Working on Mathlib/Algebra/MonoidAlgebra/Basic.lean - 2024-08-20 13:08:47.243284.
---0/3204---
Verifying proof:
:= by
  induction f using MonoidAlgebra.induction_on with
  | algebraMap k G =>
    induction f using MonoidAlgebra.induction_on with
  | algebraMap k G =>
    induction' f using MonoidAlgebra.induction_on with | algebraMap k G =>
      induction' f using MonoidAlgebra.induction_on with
    | algebraMap k G =>
      induction' f using MonoidAlgebra.induction_on with
    | algebraMap k G =>
      induction' f using MonoidAlgebra.induction_on with
    | algebraMap k G =>
      induction' f using MonoidAlgebra.induction_on with
    | algebraMap k G =>
      induction' f using MonoidAlgebra.induction_on with
    | algebraMap k G =>
      induction' f using MonoidAlgebra.induction_on with
    | algebraMap k G =>
      induction' f using MonoidAlgebra.induction_on with
    | algebraMap k G =>
      induction' f using MonoidAlgebra.induction_on with
    | algebraMap k G =>
      induction' f using MonoidAlgebra.induction_on with
    | algebraMap k G =>
      induction' f using MonoidAlgebra.induction_on with
    | 

For theorem:
theorem induction_on [Semiring k] [Monoid G] {p : MonoidAlgebra k G → Prop} (f : MonoidAlgebra k G)
    (hM : ∀ g, p (of k G g)) (hadd : ∀ f g : MonoidAlgebra k G, p f → p g → p (f + g))
    (hsmul : ∀ (r : k) (f), p f → p (r • f)) : p f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Finsupp.ext fun b =>?_
  rw [Finsupp.ext_iff, Finsupp.sum, Finsupp.sum, Finsupp.sum, Finsupp.sum, Finsupp.sum,
    Finsupp.sum_single_index, Finsupp.sum, Finsupp.sum, Finsupp.sum, Finsupp.sum,
    Finsupp.sum_single_index, Finsupp.sum_single_index, Finsupp.sum_single_index, Finsupp.sum_single_index,
    Finsupp.sum_single_index, Finsupp.sum_single_index, Finsupp.sum_single_index, Finsupp.sum_single_index,
    Finsupp.sum_single_index, Finsupp.sum_single_index, Finsupp.sum_single_index, Finsupp.sum_single_index,
    Finsupp.sum_single_index, Finsupp.sum_single_index, Finsupp.sum_single_index, Finsupp.sum_single_index,
    Finsupp.sum_single_index, Finsupp.sum_single_index, Finsupp.sum_single_index, Finsupp.sum_single_index,
    Finsupp.sum_single_index, Finsupp.sum_single_index, Finsupp.sum_single_index, Finsupp.sum_single_index,
    Finsupp.sum_single_index, Finsupp.sum_single_index, Finsupp.sum_single_index, Finsupp.sum_single_index,
    Finsupp.sum_single_index, Finsupp.sum_single_index, Fi

For theorem:
theorem ringHom_ext {R} [Semiring k] [MulOneClass G] [Semiring R] {f g : MonoidAlgebra k G →+* R}
    (h₁ : ∀ b, f (single 1 b) = g (single 1 b)) (h_of : ∀ a, f (single a 1) = g (single a 1)) :
    f = g 
Attempt failure.

Working on Mathlib/Algebra/MonoidAlgebra/Division.lean - 2024-08-20 13:09:14.939631.
---0/3204---
Verifying proof:
:= by
  rw [Finsupp.preimage, Finsupp.preimage_add_right_injective, Finsupp.preimage_add_right_injective]

For theorem:
theorem support_divOf (g : G) (x : k[G]) :
    (x /ᵒᶠ g).support =
      x.support.preimage (g + ·) (Function.Injective.injOn (add_right_injective g)) 
Attempt failure.

Working on Mathlib/Algebra/MonoidAlgebra/Ideal.lean - 2024-08-20 13:09:16.809523.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun h m hm =>?_, fun h m hm =>?_⟩
  · rw [Finsupp.mem_span_image_iff_total, Finsupp.mem_span_image_iff_total, Finsupp.mem_span_image_iff_total]
    refine ⟨fun h m hm =>?_, fun h m hm =>?_⟩
    rw [Finsupp.mem_span_image_iff_total, Finsupp.mem_span_image_iff_total, Finsupp.mem_span_image_iff_total,
      Finsupp.mem_span_image_iff_total, Finsupp.mem_span_image_iff_total]
    simp only [Finsupp.mem_span_image_iff_total, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
      Finsupp.mem_span_image_iff_total, Finsupp.mem_span_image_iff_total, Finsupp.mem_support_iff,
      Finsupp.mem_span_image_iff_total, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
      Finsupp.mem_span_image_iff_total, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
      Finsupp.mem_span_image_iff_total, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
      Finsupp.mem_span_image_iff_total, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
      Finsupp.mem_span_image_iff_total, Finsupp.mem_support_if

For theorem:
theorem MonoidAlgebra.mem_ideal_span_of_image [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} :
    x ∈ Ideal.span (MonoidAlgebra.of k G '' s) ↔ ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h m hm =>?_, fun h m hm =>?_⟩
  · rw [Finsupp.mem_span_image_iff_total, Finsupp.mem_span_image_iff_total, Finsupp.mem_span_image_iff_total]
    refine ⟨fun h m hm =>?_, fun h m hm =>?_⟩
    rw [Finsupp.mem_span_image_iff_total, Finsupp.mem_span_image_iff_total, Finsupp.mem_span_image_iff_total,
      Finsupp.mem_span_image_iff_total, Finsupp.mem_span_image_iff_total]
    simp only [Finsupp.mem_span_image_iff_total, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
      Finsupp.mem_span_image_iff_total, Finsupp.mem_span_image_iff_total, Finsupp.mem_support_iff,
      Finsupp.mem_span_image_iff_total, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
      Finsupp.mem_span_image_iff_total, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
      Finsupp.mem_span_image_iff_total, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
      Finsupp.mem_span_image_iff_total, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
      Finsupp.mem_span_image_iff_total, Finsupp.mem_support_if

For theorem:
theorem MonoidAlgebra.mem_ideal_span_of_image [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} :
    x ∈ Ideal.span (MonoidAlgebra.of k G '' s) ↔ ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' 
Attempt failure.

Working on Mathlib/Algebra/MvPolynomial/Basic.lean - 2024-08-20 13:09:19.105572.
---0/3204---
Verifying proof:
:= by
  set S := Algebra.adjoin R (range (X : σ → MvPolynomial σ R))
  refine top_unique fun p hp =>?_; clear hp
  refine top_unique fun p hp =>?_; clear hp

For theorem:
theorem adjoin_range_X : Algebra.adjoin R (range (X : σ → MvPolynomial σ R)) = ⊤ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · rintro ⟨φ, rfl⟩ c
    rw [coeff_C_mul]
    apply dvd_mul_right

For theorem:
theorem C_dvd_iff_dvd_coeff (r : R) (φ : MvPolynomial σ R) : C r ∣ φ ↔ ∀ i, r ∣ φ.coeff i 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine (coeff_monomial_mul _ _).trans (coeff_monomial_mul _ _).symm.trans?_
  simp only [coeff_X_mul, Finsupp.sum, Finset.sum_ite_eq', Finset.mem_insert, Finset.mem_singleton,
    Finsupp.mem_support_iff, ne_eq, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
    Finsupp.mem_support_iff, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
    Finsupp.mem_support_iff, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
    Finsupp.mem_support_iff, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
    Finsupp.mem_support_iff, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
    Finsupp.mem_support_iff, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
    Finsupp.mem_support_iff, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
    Finsupp.mem_support_iff, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
    Finsupp.mem_support_iff, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
      Finsupp.mem_support_iff, Finsupp.mem_support_iff, Finsupp.mem_support_iff,
    Finset.mem_insert, Finset.mem_singl

For theorem:
theorem coeff_X_mul' [DecidableEq σ] (m) (s : σ) (p : MvPolynomial σ R) :
    coeff m (X s * p) = if s ∈ m.support then coeff (m - Finsupp.single s 1) p else 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  set S := Algebra.adjoin R (range (X : σ → MvPolynomial σ R))
  refine top_unique fun p hp =>?_; clear hp
  refine top_unique fun p hp =>?_; clear hp

For theorem:
theorem adjoin_range_X : Algebra.adjoin R (range (X : σ → MvPolynomial σ R)) = ⊤ 
Attempt failure.

Working on Mathlib/Algebra/MvPolynomial/Equiv.lean - 2024-08-20 13:09:57.766552.
---0/3204---
Verifying proof:
:= by
  simp only [finSuccEquiv, Polynomial.finSuccEquiv_symm_apply, Polynomial.finSuccEquiv_symm_apply]

For theorem:
theorem finSuccEquiv_comp_C_eq_C {R : Type u} [CommSemiring R] (n : ℕ) :
    (↑(MvPolynomial.finSuccEquiv R n).symm : Polynomial (MvPolynomial (Fin n) R) →+* _).comp
        (Polynomial.C.comp MvPolynomial.C) =
      (MvPolynomial.C : R →+* MvPolynomial (Fin n.succ) R) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  induction' f using MvPolynomial.induction_on' with j ih
  · simp only [finSuccEquiv, coeff_mk, coeff_mk, Finsupp.coe_zero, Pi.zero_apply, coeff_zero]
  · simp only [finSuccEquiv, Finsupp.coe_zero, Pi.zero_apply, Finsupp.coe_zero, Pi.zero_apply,
      Polynomial.coeff_zero, Polynomial.coeff_zero]

For theorem:
theorem finSuccEquiv_coeff_coeff (m : Fin n →₀ ℕ) (f : MvPolynomial (Fin (n + 1)) R) (i : ℕ) :
    coeff m (Polynomial.coeff (finSuccEquiv R n f) i) = coeff (m.cons i) f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [optionEquivLeft_apply, aeval_X]

For theorem:
lemma optionEquivLeft_X_none : optionEquivLeft R S₁ (X none) = Polynomial.X 
Attempt failure.

Working on Mathlib/Algebra/MvPolynomial/Monad.lean - 2024-08-20 13:10:10.897729.
---0/3204---
Verifying proof:
:= by
  calc
    (bind₁ f φ).vars = ∑ i ∈ φ.vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i => (f i).vars.biUnion fun i 

For theorem:
theorem vars_bind₁ [DecidableEq τ] (f : σ → MvPolynomial τ R) (φ : MvPolynomial σ R) :
    (bind₁ f φ).vars ⊆ φ.vars.biUnion fun i => (f i).vars 
Attempt failure.

Working on Mathlib/Algebra/MvPolynomial/Supported.lean - 2024-08-20 13:10:14.105306.
---0/3204---
Verifying proof:
:= by
  classical
  rw [supported_eq_range_rename, AlgHom.mem_range]
  constructor
  · rintro ⟨p, rfl⟩
    refine _root_.trans (Finset.Subset.trans?_ (Finset.Subset.trans?_ (Finset.Subset.refl _)))
    refine _root_.trans (Finset.Subset.trans?_ (Finset.Subset.trans?_ (Finset.Subset.refl _)))

For theorem:
theorem mem_supported : p ∈ supported R s ↔ ↑p.vars ⊆ s 
Attempt failure.

Working on Mathlib/Algebra/Order/Archimedean.lean - 2024-08-20 13:10:15.798429.
---0/3204---
Verifying proof:
:= by
  let s : Set ℤ := { n : ℤ | n • a ≤ g }
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsmul_near_of_pos hk
  obtain ⟨k, hk⟩ := existsUnique_zsm

For theorem:
theorem existsUnique_zsmul_near_of_pos {a : α} (ha : 0 < a) (g : α) :
    ∃! k : ℤ, k • a ≤ g ∧ g < (k + 1) • a 
Attempt failure.

Working on Mathlib/Algebra/Order/BigOperators/Group/Finset.lean - 2024-08-20 13:10:18.728443.
---0/3204---
Verifying proof:
:=
  @prod_eq_one_iff_of_one_le' _ Nᵒᵈ _ _ _ _ _

For theorem:
theorem prod_eq_one_iff_of_le_one' :
    (∀ i ∈ s, f i ≤ 1) → ((∏ i ∈ s, f i) = 1 ↔ ∀ i ∈ s, f i = 1) 
Attempt failure.

Working on Mathlib/Algebra/Order/CauSeq/BigOperators.lean - 2024-08-20 13:10:22.976305.
---0/3204---
Verifying proof:
:= fun ε ε0 ↦ by
  classical
    let ⟨k, hk⟩ := isCauSeq_abs_of_decreasing_succ ham hnm
    let ⟨k, hk⟩ := isCauSeq_abs_of_decreasing_succ ham
    have hk : ∀ n ≥ m, f n.succ ≤ a := fun n hn ↦ by
      intro n hn
      simp only [Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one,
      Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one,
      Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one,
      Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one,
      Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one,
      Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one,
      Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one,
      Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one, Nat.succ_eq_add_one,
      Nat.succ_eq_add_one, Nat.succ_eq_add_one] at hk
     

For theorem:
lemma of_decreasing_bounded (f : ℕ → α) {a : α} {m : ℕ} (ham : ∀ n ≥ m, |f n| ≤ a)
    (hnm : ∀ n ≥ m, f n.succ ≤ f n) : IsCauSeq abs f 
Attempt failure.

Working on Mathlib/Algebra/Order/CompleteField.lean - 2024-08-20 13:10:26.086756.
---0/3204---
Verifying proof:
:= by
  obtain hb | hb := lt_trichotomy a b
  obtain ⟨c, hc⟩ := exists_mem_cutMap_mul_self_of_lt_inducedMap_mul α β ha hba
  obtain ⟨c, hc⟩ := exists_mem_cutMap_mul_self_of_lt_inducedMap_mul α β ha hba
  obtain ⟨c, hc⟩ := exists_mem_cutMap_mul_self_of_lt_inducedMap_mul α β ha hba
  obtain ⟨c, hc⟩ := exists_mem_cutMap_mul_self_of_lt_inducedMap_mul α β ha hba
  obtain ⟨c, hc⟩ := exists_mem_cutMap_mul_self_of_lt_inducedMap_mul α β ha hba
  obtain ⟨c, hc⟩ := exists_mem_cutMap_mul_self_of_lt_inducedMap_mul α β ha hba
  obtain ⟨c, hc⟩ := exists_mem_cutMap_mul_self_of_lt_inducedMap_mul α β ha hba
  obtain ⟨c, hc⟩ := exists_mem_cutMap_mul_self_of_lt_inducedMap_mul α β ha hba
  obtain ⟨c, hc⟩ := exists_mem_cutMap_mul_self_of_lt_inducedMap_mul α β ha hba
  obtain ⟨c, hc⟩ := exists_mem_cutMap_mul_self_of_lt_inducedMap_mul α β ha hba
  obtain ⟨c, hc⟩ := exists_mem_cutMap_mul_self_of_lt_inducedMap_mul α β hba
  obtain ⟨c, hc⟩ := exists_mem_cutMap_mul_s

For theorem:
theorem exists_mem_cutMap_mul_self_of_lt_inducedMap_mul_self (ha : 0 < a) (b : β)
    (hba : b < inducedMap α β a * inducedMap α β a) : ∃ c ∈ cutMap β (a * a), b < c 
Attempt failure.

Working on Mathlib/Algebra/Order/Field/Power.lean - 2024-08-20 13:10:29.701825.
---0/3204---
Verifying proof:
:= by
  obtain ⟨k, rfl⟩ := hn; exact zpow_bit0_nonneg _ _

For theorem:
theorem Even.zpow_nonneg (hn : Even n) (a : α) : 0 ≤ a ^ n 
Attempt failure.

Working on Mathlib/Algebra/Order/Floor.lean - 2024-08-20 13:10:32.456704.
---0/3204---
Verifying proof:
:= by
  convert floor_div_nat m n
  rw [m.floor_coe]

For theorem:
theorem floor_div_eq_div (m n : ℕ) : ⌊(m : α) / n⌋₊ = m / n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [fract_eq_iff]
  constructor
  · rw [le_sub_iff_add_le, zero_add]
  exact (fract_lt_one x).le

For theorem:
theorem fract_neg {x : α} (hx : fract x ≠ 0) : fract (-x) = 1 - fract x 
Attempt failure.

---0/3204---
Verifying proof:
:=
  ⟨fun h => (fract_pos.mpr h).ne', fract_pos.mpr h⟩

For theorem:
lemma fract_pos : 0 < fract a ↔ a ≠ ⌊a⌋ 
Attempt failure.

Working on Mathlib/Algebra/Order/Group/Abs.lean - 2024-08-20 13:11:01.322540.
---0/3204---
Verifying proof:
:= by rw [abs_le', and_comm, neg_le]

For theorem:
theorem abs_le : |a| ≤ b ↔ -b ≤ a ∧ a ≤ b 
Attempt failure.

Working on Mathlib/Algebra/Order/Group/Defs.lean - 2024-08-20 13:11:04.172022.
---0/3204---
Verifying proof:
:= by
  rw [← mul_le_mul_iff_left a]
  simp

For theorem:
theorem Left.inv_le_one_iff : a⁻¹ ≤ 1 ↔ 1 ≤ a 
Attempt success.

Working on Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean - 2024-08-20 13:11:07.856184.
---0/3204---
Verifying proof:
:=
  ⟨covariant_le_iff_contravariant_lt.2 MulPosReflectLT.elim⟩

For theorem:
theorem MulPosReflectLT.toMulPosMono [MulPosReflectLT α] : MulPosMono α 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [posMulReflectLT, mulPosReflectLT_iff, IsSymmOp.symm_op]

For theorem:
theorem posMulReflectLT_iff_mulPosReflectLT : PosMulReflectLT α ↔ MulPosReflectLT α 
Attempt failure.

---0/3204---
Verifying proof:
:=
  ⟨covariant_le_iff_contravariant_lt.2 PosMulReflectLT.elim⟩

For theorem:
theorem PosMulReflectLT.toPosMulMono [PosMulReflectLT α] : PosMulMono α 
Attempt failure.

---0/3204---
Verifying proof:
:=
  MulPosReflectLE.elim ⟨a, a0⟩ bc

For theorem:
theorem le_of_mul_le_mul_right [MulPosReflectLE α] (bc : b * a ≤ c * a) (a0 : 0 < a) : b ≤ c 
Attempt failure.

Working on Mathlib/Algebra/Order/Module/Defs.lean - 2024-08-20 13:11:16.377375.
---0/3204---
Verifying proof:
:=
  ⟨fun _b hb _a₁ _a₂ ha ↦ (smul_le_smul_of_nonneg_right ha.le hb.le).lt_of_ne <|
      (smul_le_smul_of_nonneg_right ha.le hb.le).lt_of_ne <|
        (smul_le_smul_of_nonneg_right ha.le hb.le).lt_of_ne <| smul_left_injective α ha hb.le⟩

For theorem:
lemma SMulPosMono.toSMulPosStrictMono [SMulPosMono α β] : SMulPosStrictMono α β 
Attempt failure.

Working on Mathlib/Algebra/Order/Module/Pointwise.lean - 2024-08-20 13:11:29.745534.
---0/3204---
Verifying proof:
:=
  (OrderIso.smulLeftDual β ha).bddAbove_image

For theorem:
lemma bddBelow_smul_iff_of_neg (ha : a < 0) : BddBelow (a • s) ↔ BddAbove s 
Attempt failure.

---0/3204---
Verifying proof:
:=
  OrderIso.smulLeftDual β ha

For theorem:
lemma upperBounds_smul_of_neg (ha : a < 0) : upperBounds (a • s) = a • lowerBounds s 
Attempt failure.

Working on Mathlib/Algebra/Order/Monovary.lean - 2024-08-20 13:11:32.878682.
---0/3204---
Verifying proof:
:=
  fun _i _j hij ↦ hfg $ lt_of_pow_lt_pow' _ hij

For theorem:
lemma Antivary.pow_right (hfg : Antivary f g) (n : ℕ) : Antivary f (g ^ n) 
Attempt failure.

Working on Mathlib/Algebra/Order/Ring/Abs.lean - 2024-08-20 13:11:37.557102.
---0/3204---
Verifying proof:
:= by
  simpa only [one_pow, abs_one] using @sq_lt_sq _ _ _ a 1

For theorem:
lemma sq_lt_one_iff_abs_lt_one (a : α) : a ^ 2 < 1 ↔ |a| < 1 
Attempt failure.

Working on Mathlib/Algebra/Order/Ring/Defs.lean - 2024-08-20 13:11:39.818427.
---0/3204---
Verifying proof:
:= sub_lt_iff_lt_add.2 $ lt_add_one a

For theorem:
lemma sub_one_lt (a : α) : a - 1 < a 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← neg_nonneg, neg_nonneg, mul_nonneg_iff, neg_nonpos]

For theorem:
lemma mul_nonpos_iff : a * b ≤ 0 ↔ 0 ≤ a ∧ b ≤ 0 ∨ a ≤ 0 ∧ 0 ≤ b 
Attempt failure.

Working on Mathlib/Algebra/Order/Ring/WithTop.lean - 2024-08-20 13:11:50.415423.
---0/3204---
Verifying proof:
  | ⊤ => by aesop
  | (b : α) => by aesop
  | (b : α) => rfl

For theorem:
lemma coe_mul_eq_bind {a : α} (ha : a ≠ 0) : ∀ b, (a * b : WithTop α) = b.bind fun b ↦ ↑(a * b)
Attempt failure.

Working on Mathlib/Algebra/Order/Sub/Canonical.lean - 2024-08-20 13:11:53.919460.
---0/3204---
Verifying proof:
:= by
  refine ((tsub_le_tsub_iff_right h).mp h2.le).lt_of_ne?_
  rintro rfl
  exact h2.false

For theorem:
theorem lt_of_tsub_lt_tsub_right_of_le (h : c ≤ b) (h2 : a - c < b - c) : a < b 
Attempt failure.

Working on Mathlib/Algebra/Order/Sub/Defs.lean - 2024-08-20 13:11:55.501952.
---0/3204---
Verifying proof:
:= by
  rw [tsub_le_iff_left, add_assoc]

For theorem:
theorem add_tsub_add_le_tsub_left : a + b - (a + c) ≤ b - c 
Attempt failure.

Working on Mathlib/Algebra/Order/ToIntervalMod.lean - 2024-08-20 13:11:56.660154.
---0/3204---
Verifying proof:
:= by
  tfae_have 1 → 3
  · intro z
    simp only [Set.mem_Ioo, Set.mem_setOf_eq, Set.mem_Ioo, Set.mem_Ioo, Set.mem_Ioo, not_and,
      Set.mem_Ioo, Set.mem_Ioo, Set.mem_singleton_iff, not_forall, exists_prop, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_apply_eq_imp_iff₂, forall_exists_index, and_imp, forall_exists_index, and_imp,
    forall_apply_eq_imp_iff₂, forall_exists_index, and_imp, for

For theorem:
theorem tfae_modEq :
    TFAE
      [a ≡ b [PMOD p], ∀ z : ℤ, b - z • p ∉ Set.Ioo a (a + p), toIcoMod hp a b ≠ toIocMod hp a b,
        toIcoMod hp a b + p = toIocMod hp a b] 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine eq_univ_iff_forall.mpr fun b => mem_iUnion.mpr?_
  rcases sub_toIocDiv_zsmul_mem_Ioc hp a b with ⟨n, hn⟩
  refine eq_univ_iff_forall.mpr fun b =>?_
  rcases sub_toIocDiv_zsmul_mem_Ioc hp a b with ⟨n, hn⟩
  refine ⟨n,?_,?_⟩
  · rintro ⟨n, hn⟩
    simp only [add_right_eq_self, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul,
      zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul,
      zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul,
      zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul,
      zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul,
      zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul,
      zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul,
      zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul, zsmul_eq_mul,
      zsmul_eq_mul, mul_o

For theorem:
theorem iUnion_Ioc_add_zsmul : ⋃ n : ℤ, Ioc (a + n • p) (a + (n + 1) • p) = univ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  tfae_have 1 → 3
  · intro z
    simp only [Set.mem_Ioo, Set.mem_setOf_eq, Set.mem_Ioo, Set.mem_Ioo, Set.mem_Ioo, not_and,
      Set.mem_Ioo, Set.mem_Ioo, Set.mem_singleton_iff, not_forall, exists_prop, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_apply_eq_imp_iff₂, forall_exists_index, and_imp, forall_exists_index, and_imp,
    forall_apply_eq_imp_iff₂, forall_exists_index, and_imp, for

For theorem:
theorem tfae_modEq :
    TFAE
      [a ≡ b [PMOD p], ∀ z : ℤ, b - z • p ∉ Set.Ioo a (a + p), toIcoMod hp a b ≠ toIocMod hp a b,
        toIcoMod hp a b + p = toIocMod hp a b] 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  tfae_have 1 → 3
  · intro z
    simp only [Set.mem_Ioo, Set.mem_setOf_eq, Set.mem_Ioo, Set.mem_Ioo, Set.mem_Ioo, not_and,
      Set.mem_Ioo, Set.mem_Ioo, Set.mem_singleton_iff, not_forall, exists_prop, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_apply_eq_imp_iff₂, forall_exists_index, and_imp, forall_exists_index, and_imp,
    forall_apply_eq_imp_iff₂, forall_exists_index, and_imp, for

For theorem:
theorem tfae_modEq :
    TFAE
      [a ≡ b [PMOD p], ∀ z : ℤ, b - z • p ∉ Set.Ioo a (a + p), toIcoMod hp a b ≠ toIocMod hp a b,
        toIcoMod hp a b + p = toIocMod hp a b] 
Attempt failure.

Working on Mathlib/Algebra/Pointwise/Stabilizer.lean - 2024-08-20 13:12:28.555490.
---0/3204---
Verifying proof:
:= by
  ext
  refine ⟨?_, fun h ↦ ⟨_, _, (stabilizer G s).one_mem, h, one_mul _⟩⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, hb, rfl⟩
  refine ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  refine ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  refine ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  refine ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  refine ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  refine ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  refine ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  refine ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  refine ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  refine ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  refine ⟨a, b, ha, hb, rfl⟩
  rintro ⟨a, b, ha, hb, rfl⟩
  refine ⟨a, b, ha, hb, rfl⟩
  rintro 

For theorem:
lemma stabilizer_mul_self (s : Set G) : (stabilizer G s : Set G) * s = s 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/AlgebraMap.lean - 2024-08-20 13:12:30.745827.
---0/3204---
Verifying proof:
:=
  map_add _ _ _

For theorem:
theorem aeval_add : aeval x (p + q) = aeval x p + aeval x q 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/Basic.lean - 2024-08-20 13:12:34.992860.
---0/3204---
Verifying proof:
:= by
  rw [← Rat.smul_one_eq_coe, ← Polynomial.smul_C, coe_one]

For theorem:
theorem qsmul_eq_C_mul (a : ℚ) (f : R[X]) : a • f = Polynomial.C (a : R) * f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply top_unique
  rw [← AddSubmonoid.map_equiv_top (toFinsuppIso R)]
  rw [← AddSubmonoid.map_equiv_top (toFinsuppIso R)]

For theorem:
theorem addSubmonoid_closure_setOf_eq_monomial :
    AddSubmonoid.closure { p : R[X] | ∃ n a, p = monomial n a } = ⊤ 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/BigOperators.lean - 2024-08-20 13:12:49.232588.
---0/3204---
Verifying proof:
:= by
  revert h
  refine Multiset.induction_on t?_ fun f => natDegree_multiset_prod_leadingCoeff f?_
  · simp only [Multiset.mem_map, Multiset.mem_map, Multiset.mem_map] at h
    rw [Multiset.mem_map] at h
    simp only [Multiset.mem_map, Multiset.mem_map, Multiset.mem_map, exists_prop] at h
    exact h

For theorem:
theorem natDegree_multiset_prod' (h : (t.map fun f => leadingCoeff f).prod ≠ 0) :
    t.prod.natDegree = (t.map fun f => natDegree f).sum 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← leadingCoeffHom_apply, MonoidHom.map_prod]
  rfl

For theorem:
theorem leadingCoeff_multiset_prod :
    t.prod.leadingCoeff = (t.map fun f => leadingCoeff f).prod 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/Coeff.lean - 2024-08-20 13:13:00.481963.
---0/3204---
Verifying proof:
:= by
  split_ifs with h
  · rw [← tsub_add_cancel_of_le h, coeff_mul_X_pow, add_tsub_cancel_right]

For theorem:
theorem coeff_mul_X_pow' (p : R[X]) (n d : ℕ) :
    (p * X ^ n).coeff d = ite (n ≤ d) (p.coeff (d - n)) 0 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/Degree/Definitions.lean - 2024-08-20 13:13:02.991455.
---0/3204---
Verifying proof:
:= by
  obtain _ | n := n
  · exact hf
  · refine (Nat.le_succ_iff_eq_or_le.1 hf).resolve_left fun h ↦?_
  · exact hf
  · refine (Nat.le_succ_iff_eq_or_le.1 hf).resolve_left fun h ↦?_
  · exact hf

For theorem:
lemma natDegree_le_pred (hf : p.natDegree ≤ n) (hn : p.coeff n = 0) : p.natDegree ≤ n - 1 
Attempt failure.

---0/3204---
Verifying proof:
:=
  calc
    coeff (p * q) (natDegree p + natDegree q) =
        coeff (p * q) (natDegree p + natDegree q) =
           coeff (p * q) (natDegree p + natDegree q) :=
      coeff_mul_degree_add_degree_le _ _
    _ = coeff (p * q) (natDegree p + natDegree q) :=
      coeff_mul_degree_add_degree_le _ _
    _ = coeff (p * q) (natDegree p + natDegree q) :=
      coeff_mul_degree_add_degree_le _ _

For theorem:
theorem coeff_mul_degree_add_degree (p q : R[X]) :
    coeff (p * q) (natDegree p + natDegree q) = leadingCoeff p * leadingCoeff q 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/Degree/Lemmas.lean - 2024-08-20 13:13:16.819441.
---0/3204---
Verifying proof:
:= by
  induction' m with m hm
  · simp
  · rw [pow_succ, pow_succ, ← hm, Nat.succ_mul, coeff_mul, coeff_pow, coeff_mul, coeff_mul,
      coeff_mul, coeff_pow, coeff_mul, coeff_mul, coeff_mul, coeff_mul, coeff_pow, coeff_mul,
    coeff_mul, coeff_pow, coeff_mul, coeff_mul, coeff_pow, coeff_mul, coeff_mul, coeff_mul,
    coeff_pow, coeff_mul, coeff_mul, coeff_pow, coeff_mul, coeff_mul, coeff_mul, coeff_mul,
    coeff_pow, coeff_mul, coeff_mul, coeff_mul, coeff_mul, coeff_mul, coeff_pow, coeff_mul,
    coeff_mul, coeff_mul, coeff_mul, coeff_mul, coeff_mul, coeff_mul, coeff_pow, coeff_mul,
    coeff_pow, coeff_mul, coeff_mul, coeff_mul, coeff_mul, coeff_mul, coeff_pow, coeff_mul,
    coeff_mul, coeff_mul, coeff_pow, coeff_mul, coeff_mul, coeff_mul, coeff_pow, coeff_mul,
    coeff_mul, coeff_mul, coeff_mul, coeff_mul, coeff_pow, coeff_mul, coeff_mul, coeff_mul,
    coeff_mul, coeff_mul, coeff_mul, coeff_pow, coeff_mul, coeff_mul, coeff_pow, coeff_mul,
    coeff_pow, coeff_mul, coeff_mul, coeff_mul, coeff_mul

For theorem:
theorem coeff_pow_of_natDegree_le (pn : p.natDegree ≤ n) :
    (p ^ m).coeff (m * n) = p.coeff n ^ m 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine le_antisymm (natDegree_sum_le _ _)?_
  · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Fins

For theorem:
theorem natDegree_sum_eq_of_disjoint (f : S → R[X]) (s : Finset S)
    (h : Set.Pairwise { i | i ∈ s ∧ f i ≠ 0 } (Ne on natDegree ∘ f)) :
    natDegree (s.sum f) = s.sup fun i => natDegree (f i) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine le_antisymm (sup_le fun i hi =>?_) (sup_le fun i hi =>?_)
  · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>?_⟩
    · rw [Finset.sum_congr rfl fun i hi =>?_, Finset.sum_congr rfl fun i hi =>

For theorem:
theorem degree_sum_eq_of_disjoint (f : S → R[X]) (s : Finset S)
    (h : Set.Pairwise { i | i ∈ s ∧ f i ≠ 0 } (Ne on degree ∘ f)) :
    degree (s.sum f) = s.sup fun i => degree (f i) 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean - 2024-08-20 13:13:24.467890.
---0/3204---
Verifying proof:
:=
  ENat.toNat_le_of_le_coe <| trailingDegree_le_of_ne_zero h

For theorem:
theorem natTrailingDegree_le_of_ne_zero (h : coeff p n ≠ 0) : natTrailingDegree p ≤ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [X_pow_eq_monomial, natTrailingDegree_monomial_eq]

For theorem:
lemma natTrailingDegree_X_pow (n : ℕ) :
    (X ^ n : R[X]).natTrailingDegree = n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp [natTrailingDegree, h]

For theorem:
theorem natTrailingDegree_eq_of_trailingDegree_eq_some {p : R[X]} {n : ℕ}
    (h : trailingDegree p = n) : natTrailingDegree p = n 
Attempt failure.

---0/3204---
Verifying proof:
:= Nat.le_zero.1 (natTrailingDegree_le_of_ne_zero h)

For theorem:
lemma natTrailingDegree_eq_zero_of_constantCoeff_ne_zero (h : constantCoeff p ≠ 0) :
    p.natTrailingDegree = 0 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/Div.lean - 2024-08-20 13:13:33.705014.
---0/3204---
Verifying proof:
:= by
  haveI := Nontrivial.of_polynomial_ne h0
  refine multiplicity_finite_of_degree_pos_of_monic?_ (monic_X_sub_C a)
  refine multiplicity_finite_of_degree_pos_of_monic?_ (monic_X_sub_C a)
  refine multiplicity_finite_of_degree_pos_of_monic?_ (monic_X_sub_C a)
  refine multiplicity_finite_of_degree_pos_of_monic?_ (monic_X_sub_C a)
  refine multiplicity_finite_of_degree_pos_of_monic?_ (monic_X_sub_C a)
  refine multiplicity_finite_of_degree_pos_of_monic?_ (monic_X_sub_C a)
  refine multiplicity_finite_of_degree_pos_of_monic?_ (monic_X_sub_C a)
  refine multiplicity_finite_of_degree_pos_of_monic?_ (monic_X_sub_C a)
  refine multiplicity_finite_of_degree_pos_of_monic?_ (monic_X_sub_C a)
  refine multiplicity_finite_of_degree_pos_of_monic?_ (monic_X_sub_C a)
  refine multiplicity_finite_of_degree_pos_of_monic?_ (monic_X_sub_C a)
  refine multiplicity_finite_of_degree_pos_of_monic?_ (monic_X_sub_C a)
  refine multiplicity_finite_of_degree_pos_of_monic?_ (monic_X_sub_C a)
  refine multiplicity_fini

For theorem:
theorem multiplicity_X_sub_C_finite (a : R) (h0 : p ≠ 0) : multiplicity.Finite (X - C a) p 
Attempt failure.

---0/3204---
Verifying proof:
:=
  ⟨fun h => by rw [← modByMonic_add_div p hq, h, zero_add]; exact dvd_mul_right _ _, fun h => by
    nontriviality _
    rw [← modByMonic_add_div p hq, h, zero_add]; exact dvd_mul_right _ _⟩

For theorem:
theorem modByMonic_eq_zero_iff_dvd (hq : Monic q) : p %ₘ q = 0 ↔ q ∣ p 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/Eval.lean - 2024-08-20 13:13:42.743969.
---0/3204---
Verifying proof:
:=
  (evalRingHom x).map_list_prod l

For theorem:
theorem eval_list_prod (l : List R[X]) (x : R) : eval x l.prod = (l.map (eval x)).prod 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  induction p with
  | h_add p q hp hq =>
    simp [hp, hq]
  | h_monomial n r =>
    simp [hp, hq]

For theorem:
theorem eval₂_eq_eval_map {x : S} : p.eval₂ f x = (p.map f).eval x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine _root_.trans (eval₂_mul_noncomm _ _ fun k =>?_) (by rw [eval₂_X])
  rcases em (k = 1) with (rfl | hk)
  · simp
  · simp

For theorem:
theorem eval₂_mul_X : eval₂ f x (p * X) = eval₂ f x p * x 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/Expand.lean - 2024-08-20 13:13:59.821920.
---0/3204---
Verifying proof:
:=
  Polynomial.induction_on f (fun r => by rw [expand_C])
    (fun f g ihf ihg => by rw [map_add, ihf, ihg]) fun n r _ => by
    rw [map_mul, expand_C]
    rw [map_add, ihf, ihg]

For theorem:
theorem expand_one (f : R[X]) : expand R 1 f = f 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/Laurent.lean - 2024-08-20 13:14:02.729976.
---0/3204---
Verifying proof:
:= by
  refine f.induction_on'?_ fun n a =>?_ <;> clear f
  · rintro f g ⟨m, fn, hf⟩ ⟨n, gn, hg⟩

For theorem:
theorem exists_T_pow (f : R[T;T⁻¹]) : ∃ (n : ℕ) (f' : R[X]), toLaurent f' = f * T n 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/Module/Basic.lean - 2024-08-20 13:14:06.304510.
---0/3204---
Verifying proof:
:= by
  induction' f using Polynomial.induction_on' with p q hp hq
  · rw [add_smul, Finsupp.single_apply, Finsupp.single_apply, Finsupp.single_apply,
      Finsupp.single_apply, Finsupp.single_apply, Finsupp.sum, Finset.sum_ite_eq',
      Finset.sum_ite_eq', Finset.sum_ite_eq', Finset.sum_ite_eq', Finset.mem_univ,
    Finset.mem_insert, Finset.mem_insert, Finset.mem_insert, Finset.mem_singleton,
      Finset.mem_insert, Finset.mem_singleton, Finset.mem_insert, Finset.mem_singleton,
      Finset.mem_insert, Finset.mem_singleton]
    simp only [coeff_smul, Finsupp.single_apply, Finset.sum_ite_eq', Finset.mem_univ,
    Finset.mem_insert, Finset.mem_insert, Finset.mem_insert, Finset.mem_singleton,
      Finset.mem_insert, Finset.mem_singleton, Finset.mem_insert, Finset.mem_singleton,
      Finset.mem_insert, Finset.mem_singleton, Finset.mem_insert, Finset.mem_singleton,
      Finset.mem_insert, Finset.mem_singleton, Finset.mem_insert, Finset.mem_singleton,
      Finset.mem_insert, Finset.mem_singleton, Finset.

For theorem:
theorem smul_single_apply (i : ℕ) (f : R[X]) (m : M) (n : ℕ) :
    (f • single R i m) n = ite (i ≤ n) (f.coeff (n - i) • m) 0 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/PartialFractions.lean - 2024-08-20 13:14:12.913390.
---0/3204---
Verifying proof:
:= by
  obtain ⟨q, rfl⟩ := Finset.exists_mem_eq_sup s hcop
  refine ⟨q, fun i hi =>?_, fun i hi =>?_⟩
  · rw [Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe,
      Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe,
      Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe,
      Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe,
      Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe,
      Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe,
      Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe,
      Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe,
      Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe,
      Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe, Finset.mem_coe,
      Finset.mem_coe, Finset.mem_coe, Finset.mem

For theorem:
theorem div_eq_quo_add_sum_rem_div (f : R[X]) {ι : Type*} {g : ι → R[X]} {s : Finset ι}
    (hg : ∀ i ∈ s, (g i).Monic) (hcop : Set.Pairwise ↑s fun i j => IsCoprime (g i) (g j)) :
    ∃ (q : R[X]) (r : ι → R[X]),
      (∀ i ∈ s, (r i).degree < (g i).degree) ∧
        ((↑f : K) / ∏ i ∈ s, ↑(g i)) = ↑q + ∑ i ∈ s, (r i : K) / (g i : K) 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/Roots.lean - 2024-08-20 13:14:14.389094.
---0/3204---
Verifying proof:
:= by
  classical
  rw [← map_dvd_map _ (IsFractionRing.injective R <| FractionRing.injective R <| FractionRing R) monic_prod_multiset_X_sub_C]

For theorem:
theorem prod_multiset_X_sub_C_dvd (p : R[X]) : (p.roots.map fun a => X - C a).prod ∣ p 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/Smeval.lean - 2024-08-20 13:14:19.217893.
---0/3204---
Verifying proof:
:= by
  induction p using Polynomial.induction_on' with
  | h_add r s hr hs =>
    simp only [add_comp, hr, hs, smeval_add, add_mul]
  | h_monomial n a =>
    simp only [add_comp, hr, hs, smeval_add, add_mul]
  | h_monomial n a =>
    simp only [add_comp, hr, hs, smeval_add, add_mul]
  | h_monomial n a =>
    simp only [add_comp, hr, hs, smeval_add, add_mul]
  | h_monomial n a =>
    simp only [add_comp, hr, hs, smeval_add, add_mul]
  | h_monomial n a =>
    simp only [add_comp, hr, hs, smeval_add, add_mul]
  | h_monomial n a =>
    simp only [add_comp, hr, hs, smeval_add, add_mul]
  | h_monomial n a =>
    simp only [add_comp, hr, hs, smeval_add, add_mul]
  | h_monomial n a =>
    simp only [add_comp, hr, hs, smeval_add, add_mul]
  | h_monomial n a =>
    simp only [add_comp, hr, hs, smeval_add, add_mul]
  | h_monomial n a =>
    simp only [add_comp, hr, hs, smeval_add, add_mul]
  | h_monomial n a =>
    simp only [add_comp, hr, hs, smeval_add, add_mul]
  | h_monomial n a =>
    simp only [add_comp, hr, hs,

For theorem:
theorem smeval_mul : (p * q).smeval x  = p.smeval x * q.smeval x 
Attempt failure.

Working on Mathlib/Algebra/Polynomial/UnitTrinomial.lean - 2024-08-20 13:14:22.166506.
---0/3204---
Verifying proof:
:= by
  rw [trinomial, hp, trinomial]
  simp only [trinomial, trinomial, Units.val_mul, Units.val_pow_eq_pow_val, Units.val_pow_eq_pow_val,
    Units.val_mul, Units.val_pow_eq_pow_val, Units.val_mul, Units.val_pow_eq_pow_val,
    Units.val_mul, Units.val_pow_eq_pow_val, Units.val_mul, Units.val_pow_eq_pow_val,
    Units.val_mul, Units.val_pow_eq_pow_val, Units.val_mul, Units.val_pow_eq_pow_val,
    Units.val_mul, Units.val_pow_eq_pow_val, Units.val_mul, Units.val_pow_eq_pow_val,
    Units.val_mul, Units.val_pow_eq_pow_val, Units.val_mul, Units.val_pow_eq_pow_val,
    Units.val_mul, Units.val_pow_eq_pow_val, Units.val_mul, Units.val_pow_eq_pow_val,
    Units.val_mul, Units.val_mul, Units.val_pow_eq_pow_val, Units.val_mul, Units.val_pow_eq_pow_val,
    Units.val_mul, Units.val_mul, Units.val_pow_eq_pow_val, Units.val_mul, Units.val_pow_eq_pow_val,
    Units.val_mul, Units.val_mul, Units.val_pow_eq_pow_val, Units.val_mul, Units.val_pow_eq_pow_val,
    Units.val_mul, Units.val_pow_eq_pow_val, Units.val_pow_eq_po

For theorem:
theorem irreducible_aux1 {k m n : ℕ} (hkm : k < m) (hmn : m < n) (u v w : Units ℤ)
    (hp : p = trinomial k m n (u : ℤ) v w) :
    C (v : ℤ) * (C (u : ℤ) * X ^ (m + n) + C (w : ℤ) * X ^ (n - m + k + n)) =
      ⟨Finsupp.filter (· ∈ Set.Ioo (k + n) (n + n)) (p * p.mirror).toFinsupp⟩ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine
    natTrailingDegree_eq_of_trailingDegree_eq_some
    (trailingDegree_eq_of_trailingDegree_eq_some
      (trinomial k m n u v w).natTrailingDegree_eq_some
        (trinomial k m n u v w).natTrailingDegree_eq_some
         (trinomial k m n u v w).natTrailingDegree_eq_some
          (trinomial k m n u v w).natTrailingDegree_eq_some
         (trinomial k m n u v w).natTrailingDegree_eq_some
         (trinomial k m n u v w).natTrailingDegree_eq_some
        (trinomial k m n u v w).natTrailingDegree_eq_some
         (trinomial k m n u v w).natTrailingDegree_eq_some
         (trinomial k m n u v w).natTrailingDegree_eq_some
        (trinomial k m n u v w).natTrailingDegree_eq_some
        (trinomial k m n u v w).natTrailingDegree_eq_some
        (trinomial k m n u v w).natTrailingDegree_eq_some
        (trinomial k m n u v w).natTrailingDegree_eq_some
        (trinomial k m n u v w).natTrailingDegree_eq_some
        (trinomial k m n u v w).natTrailingDegree_eq_some
        (trinomial k m n u v w).n

For theorem:
theorem trinomial_natTrailingDegree (hkm : k < m) (hmn : m < n) (hu : u ≠ 0) :
    (trinomial k m n u v w).natTrailingDegree = k 
Attempt failure.

Working on Mathlib/Algebra/QuadraticDiscriminant.lean - 2024-08-20 13:14:30.342069.
---0/3204---
Verifying proof:
:= by
  rcases h with ⟨s, hs⟩
  use (-b + s) / (2 * a)
  rw [quadratic_eq_zero_iff] at h
  rcases h with ⟨s, hs⟩
  rcases h with ⟨s, hs⟩
  use (-b + s) / (2 * a)
  rw [quadratic_eq_zero_iff_discrim_eq_zero ha hs]
  rw [quadratic_eq_zero_iff_discrim_eq_zero ha hs with ⟨s, hs⟩
  rcases h with ⟨s, hs⟩
  use (-b + s) / (2 * a)
  rw [quadratic_eq_zero_iff_discrim_eq_zero ha hs with ⟨s, hs⟩
  rw [quadratic_eq_zero_iff_discrim_eq_zero ha hs with ⟨s, hs⟩
  rcases h with ⟨s, hs⟩
  use (-b + s) / (2 * a)
  rw [quadratic_eq_zero_iff_discrim_eq_zero hs with ⟨s, hs⟩
  rcases h with ⟨s, hs⟩
  rcases h with ⟨s, hs⟩
  use (-b + s) / (2 * a)
  rw [quadratic_eq_zero_iff_discrim_eq_zero hs with ⟨s, hs⟩
  rcases h with ⟨s, hs⟩
  rcases h with ⟨s, hs⟩
  use (-b + s) / (2 * a)
  rw [quadratic_eq_zero_iff_discrim_eq_zero ha with ⟨s, hs⟩
  rcases h with ⟨s, hs⟩
  rw [quadratic_eq_zero_iff_discrim_eq_zero ha with ⟨s, hs⟩
  rcases h with ⟨s, hs⟩
  rw [quadratic_e

For theorem:
theorem exists_quadratic_eq_zero (ha : a ≠ 0) (h : ∃ s, discrim a b c = s * s) :
    ∃ x, a * x * x + b * x + c = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨discrim_eq_zero_of_noZeroDivisors ha,?_⟩
  rw [discrim_eq_zero_iff_discrim_eq_zero ha]
  refine ⟨fun h =>?_, fun h =>?_⟩
  · rw [discrim_eq_zero_iff_discrim_eq_zero ha h⟩
    rw [discrim_eq_zero_iff_discrim_eq_zero ha, discrim_eq_zero_iff_discrim_eq_zero ha,?_⟩
  · rw [discrim_eq_zero_iff_discrim_eq_zero ha, discrim_eq_zero_iff_discrim_eq_zero ha,
      discrim_eq_zero_iff_discrim_eq_zero ha, discrim_eq_zero_iff_discrim_eq_zero ha,?_⟩
  · rw [discrim_eq_zero_iff_discrim_eq_zero ha, discrim_eq_zero_iff_discrim_eq_zero ha,
      discrim_eq_zero_iff_discrim_eq_zero ha, discrim_eq_zero_iff_discrim_eq_zero ha,?_⟩
  · rw [discrim_eq_zero_iff_discrim_eq_zero ha, discrim_eq_zero_iff_discrim_eq_zero ha,
      discrim_eq_zero_iff_discrim_eq_zero ha, discrim_eq_zero_iff_discrim_eq_zero ha,?_⟩
  · rw [discrim_eq_zero_iff_discrim_eq_zero ha, discrim_eq_zero_iff_discrim_eq_zero ha,
      discrim_eq_zero_iff_discrim_eq_zero ha, discrim_eq_zero_iff_discrim_eq_zero ha, discrim_eq

For theorem:
theorem quadratic_eq_zero_iff_discrim_eq_sq [NeZero (2 : R)] [NoZeroDivisors R]
    (ha : a ≠ 0) (x : R) :
    a * x * x + b * x + c = 0 ↔ discrim a b c = (2 * a * x + b) ^ 2 
Attempt failure.

Working on Mathlib/Algebra/Regular/Basic.lean - 2024-08-20 13:14:33.845483.
---0/3204---
Verifying proof:
:= by
  rcases ua with ⟨a, rfl⟩
  exact Units.isRegular

For theorem:
theorem IsUnit.isRegular (ua : IsUnit a) : IsRegular a 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  nth_rw 1 [← mul_zero b]
  exact ⟨fun h ↦ hb h, fun ha ↦ by rw [ha, mul_zero]⟩

For theorem:
lemma IsLeftRegular.mul_left_eq_zero_iff (hb : IsLeftRegular b) : b * a = 0 ↔ a = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine fun x y xy => ab (_ : x * (b * a) = y * (b * a))
  rw [← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc]
  exact congr_arg (fun x y => x * (b * a)) (fun x y => y * (b * a))

For theorem:
theorem IsRightRegular.of_mul (ab : IsRightRegular (b * a)) : IsRightRegular b 
Attempt failure.

---0/3204---
Verifying proof:
:=
  Function.Injective.of_comp (by rwa [comp_mul_left a b])

For theorem:
theorem IsLeftRegular.of_mul (ab : IsLeftRegular (a * b)) : IsLeftRegular b 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rintro rfl
  rcases exists_pair_ne R with ⟨x, y, xy⟩
  refine xy (la (_ : 0 * x = 0 * y)) rw [zero_mul, zero_mul, zero_mul, zero_mul, zero_mul, zero_mul]

For theorem:
theorem IsLeftRegular.ne_zero [Nontrivial R] (la : IsLeftRegular a) : a ≠ 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Iff.trans?_ isRegular_mul_and_mul_iff
  exact ⟨fun ab => ⟨ab, by rwa [mul_comm]⟩, fun rab => rab.1⟩

For theorem:
theorem isRegular_mul_iff : IsRegular (a * b) ↔ IsRegular a ∧ IsRegular b 
Attempt failure.

Working on Mathlib/Algebra/Regular/Pow.lean - 2024-08-20 13:14:40.175409.
---0/3204---
Verifying proof:
:= by
  refine ⟨?_, IsRightRegular.pow n⟩
  rw [← Nat.succ_pred_eq_of_pos n0, pow_succ]

For theorem:
theorem IsRightRegular.pow_iff {n : ℕ} (n0 : 0 < n) :
    IsRightRegular (a ^ n) ↔ IsRightRegular a 
Attempt failure.

Working on Mathlib/Algebra/Regular/SMul.lean - 2024-08-20 13:14:41.065333.
---0/3204---
Verifying proof:
:= by
  induction' n with n hn
  · rw [pow_zero]; simp only [one]
    · rw [pow_succ]
    exact (pow_succ' _ _).symm

For theorem:
theorem pow (n : ℕ) (ra : IsSMulRegular M a) : IsSMulRegular M (a ^ n) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  of_mul
  (by
    rw [h]
    exact one M)
    exact one_smul _ _

For theorem:
theorem of_mul_eq_one (h : a * b = 1) : IsSMulRegular M b 
Attempt failure.

---0/3204---
Verifying proof:
:= fun a b ab => by
  dsimp only [Function.comp] at ab
  rw [one_smul, one_smul] at ab
  assumption

For theorem:
theorem one : IsSMulRegular M (1 : R) 
Attempt success.

Working on Mathlib/Algebra/Ring/Basic.lean - 2024-08-20 13:14:44.922987.
---0/3204---
Verifying proof:
:= by
  have : c = x * (b - x) := (eq_neg_of_add_eq_zero_right h).symm
  have : c = x * (b - x) := (eq_neg_of_add_eq_zero_right h).symm
  have : c = x * (b - x) := (eq_neg_of_add_eq_zero_right h

For theorem:
theorem vieta_formula_quadratic {b c x : α} (h : x * x - b * x + c = 0) :
    ∃ y : α, y * y - b * y + c = 0 ∧ x + y = b ∧ x * y = c 
Attempt failure.

Working on Mathlib/Algebra/Ring/CompTypeclasses.lean - 2024-08-20 13:14:45.874284.
---0/3204---
Verifying proof:
:=
  { is_surjective := by
      have := σ₂₃.surjective
      have := σ₂₃.surjective
      have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjective
    have := σ₂₃.surjectiv

For theorem:
theorem comp [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] [RingHomSurjective σ₁₂] [RingHomSurjective σ₂₃] :
    RingHomSurjective σ₁₃ 
Attempt failure.

Working on Mathlib/Algebra/Ring/Divisibility/Basic.lean - 2024-08-20 13:14:46.731628.
---0/3204---
Verifying proof:
:=
  let f := MulHomClass.toMulEquiv f

For theorem:
theorem map_dvd_iff {a b} : f a ∣ f b ↔ a ∣ b 
Attempt failure.

Working on Mathlib/Algebra/Ring/Equiv.lean - 2024-08-20 13:14:47.791195.
---0/3204---
Verifying proof:
:=
  AddHomClass.map_eq_zero_iff f

For theorem:
theorem map_eq_zero_iff : f x = 0 ↔ x = 0 
Attempt failure.

---0/3204---
Verifying proof:
:=
  map_eq_one_iff f

For theorem:
theorem map_eq_one_iff : f x = 1 ↔ x = 1 
Attempt failure.

Working on Mathlib/Algebra/SMulWithZero.lean - 2024-08-20 13:14:52.854570.
---0/3204---
Verifying proof:
:=
  ⟨λ x y => by rw [← one_smul R x, ← one_smul R y, Subsingleton.elim (1 : R) 0, zero_smul, zero_smul, zero_smul],
    zero_smul, zero_smul, zero_smul, zero_smul, zero_smul, zero_smul, zero_smul, zero_smul]⟩

For theorem:
lemma MulActionWithZero.subsingleton
    [MulActionWithZero R M] [Subsingleton R] : Subsingleton M 
Attempt failure.

Working on Mathlib/Algebra/Star/Center.lean - 2024-08-20 13:14:54.141544.
---0/3204---
Verifying proof:
:= by simpa only [star_mul, star_star] using fun g =>
  congr_arg star ((mem_center_iff.1 ha).comm <| star ((mem_center_iff.1 ha).comm <| star g)) <| star_mem _

For theorem:
theorem Set.star_mem_center (ha : a ∈ Set.center R) : star a ∈ Set.center R where
Attempt failure.

Working on Mathlib/Algebra/Star/NonUnitalSubalgebra.lean - 2024-08-20 13:14:55.154745.
---0/3204---
Verifying proof:
:=
  (Set.subset_union_right s (star s)).trans <| NonUnitalAlgebra.subset_adjoin R

For theorem:
theorem star_subset_adjoin (s : Set A) : star s ⊆ adjoin R s 
Attempt failure.

Working on Mathlib/Algebra/Star/Order.lean - 2024-08-20 13:15:26.436458.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun ⟨s, hs⟩ => ⟨s, hs⟩, fun ⟨s, hs⟩ => ⟨s, hs⟩⟩
  refine ⟨s,?_⟩
  · rintro ⟨s, rfl⟩
    exact ⟨s, rfl⟩

For theorem:
lemma of_nonneg_iff' [NonUnitalRing R] [PartialOrder R] [StarRing R]
    (h_add : ∀ {x y : R}, x ≤ y → ∀ z, z + x ≤ z + y)
    (h_nonneg_iff : ∀ x : R, 0 ≤ x ↔ ∃ s, x = star s * s) : StarOrderedRing R 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun ⟨s, hs⟩ =>?_⟩
  · rintro ⟨s, rfl⟩
    exact ⟨s, rfl⟩

For theorem:
lemma of_le_iff [NonUnitalSemiring R] [PartialOrder R] [StarRing R]
    (h_le_iff : ∀ x y : R, x ≤ y ↔ ∃ s, y = x + star s * s) : StarOrderedRing R where
Attempt failure.

Working on Mathlib/Algebra/Star/Pointwise.lean - 2024-08-20 13:15:32.933485.
---0/3204---
Verifying proof:
:= by
  ext x
  simp only [Set.mem_star, SetLike.mem_coe]

For theorem:
lemma StarMemClass.star_coe_eq {S α : Type*} [InvolutiveStar α] [SetLike S α]
    [StarMemClass S α] (s : S) : star (s : Set α) = s 
Attempt failure.

Working on Mathlib/Algebra/TrivSqZeroExt.lean - 2024-08-20 13:15:34.056194.
---0/3204---
Verifying proof:
:=
  ext rfl <| by simp [snd_pow_eq_sum]

For theorem:
theorem inl_pow [Monoid R] [AddMonoid M] [DistribMulAction R M] [DistribMulAction Rᵐᵒᵖ M] (r : R)
    (n : ℕ) : (inl r ^ n : tsze R M) = inl (r ^ n) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [linearMap_apply, LinearMap.coe_comp, Function.comp_apply]

For theorem:
theorem linearMap_ext {N} [Semiring S] [AddCommMonoid R] [AddCommMonoid M] [AddCommMonoid N]
    [Module S R] [Module S M] [Module S N] ⦃f g : tsze R M →ₗ[S] N⦄
    (hl : ∀ r, f (inl r) = g (inl r)) (hr : ∀ m, f (inr m) = g (inr m)) : f = g 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/AffineScheme.lean - 2024-08-20 13:16:04.418858.
---0/3204---
Verifying proof:
:= by
  have : IsAffine _ := hU
  obtain ⟨_, ⟨_, ⟨r, rfl⟩, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ := hU
  obtain ⟨_, ⟨r, rfl⟩ :

For theorem:
theorem exists_basicOpen_le {V : Opens X} (x : V) (h : ↑x ∈ U) :
    ∃ f : Γ(X, U), X.basicOpen f ≤ V ∧ ↑x ∈ X.basicOpen f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← basicOpen_restrict_basicOpen f, ← Scheme.basicOpen_restrict_presheaf_obj]

For theorem:
theorem Scheme.map_PrimeSpectrum_basicOpen_of_affine
    (X : Scheme) [IsAffine X] (f : Scheme.Γ.obj (op X)) :
    X.isoSpec.hom ⁻¹ᵁ PrimeSpectrum.basicOpen f = X.basicOpen f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  convert @IsCompact.image _ _ _ _ _ Set.univ hU.fromSpec.1.base PrimeSpectrum.compactSpace.1
    ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1) ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
    ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
    ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
    ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
    ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
    ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
    ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
      ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
      ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
      ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
      ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
      ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
      ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
      ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
      ((fromSpec hU).1.base PrimeSpectrum.compactSpace.1)
      ((fromSpe

For theorem:
theorem isCompact :
    IsCompact (U : Set X) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply
    IsLocalization.isLocalization_iff_of_ringEquiv (Submonoid.powers f)
    (asIso <| basicOpenSection f)
      (asIso <| basicOpenSection f)
      (asIso <| basicOpenSection f)
      (asIso <| basicOpe

For theorem:
theorem isLocalization_basicOpen :
    IsLocalization.Away f Γ(X, X.basicOpen f) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [fromSpec_preimage_basicOpen', ← basicOpen_eq_of_affine, NatIso.app_inv]

For theorem:
theorem fromSpec_preimage_basicOpen :
    hU.fromSpec ⁻¹ᵁ X.basicOpen f = PrimeSpectrum.basicOpen f 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/Cover/Open.lean - 2024-08-20 13:17:08.702132.
---0/3204---
Verifying proof:
:= by
  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds (fun x hx =>?_)
  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds (fun x hx =>?_)
  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds (fun x hx =>?_)
  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds (fun x hx =>?_)
  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds (fun x hx =>?_)
  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds (fun x hx =>?_)
  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds (fun x hx =>?_)
  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds (fun x hx =>?_)
  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds (fun x hx =>?_)
  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds (fun x hx =>?_)
  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds (fun x hx =>?_)
  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds (fun x hx =>?_)
  refine TopologicalSpace.isTopologicalBasis_of_isOpen_of

For theorem:
theorem affineBasisCover_is_basis (X : Scheme.{u}) :
    TopologicalSpace.IsTopologicalBasis
      {x : Set X |
        ∃ a : X.affineBasisCover.J, x = Set.range (X.affineBasisCover.map a).1.base} 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/EllipticCurve/Affine.lean - 2024-08-20 13:17:12.806666.
---0/3204---
Verifying proof:
:= by
  simp only [Equation, ← map_C, map_eval_polynomial, map_eq_zero_iff hf]

For theorem:
lemma map_equation (hf : Function.Injective f) (x y : R) :
    (W.map f).toAffine.Equation (f x) (f y) ↔ W.Equation x y 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [nonsingular_iff] at h₁ h₂ hx hy

For theorem:
lemma add_of_Y_eq {x₁ x₂ y₁ y₂ : F} {h₁ : W.Nonsingular x₁ y₁} {h₂ : W.Nonsingular x₂ y₂}
    (hx : x₁ = x₂) (hy : y₁ = W.negY x₂ y₂) : some h₁ + some h₂ = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [slope_of_Y_ne hx hy, slope_of_Y_ne hx hy]

For theorem:
lemma slope_of_Y_ne_eq_eval {x₁ x₂ y₁ y₂ : F} (hx : x₁ = x₂) (hy : y₁ ≠ W.negY x₂ y₂) :
    W.slope x₁ x₂ y₁ y₂ = -W.polynomialX.evalEval x₁ y₁ / W.polynomialY.evalEval x₁ y₁ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [Equation, C_0, eval_polynomial_zero, neg_eq_zero]

For theorem:
lemma equation_zero : W.Equation 0 0 ↔ W.a₆ = 0 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean - 2024-08-20 13:18:25.984354.
---0/3204---
Verifying proof:
:= by
  rw [Ψ_odd]
  ring1

For theorem:
lemma Ψ_odd (m : ℕ) : W.Ψ (2 * (m + 2) + 1) =
    W.Ψ (m + 4) * W.Ψ (m + 2) ^ 3 - W.Ψ (m + 1) * W.Ψ (m + 3) ^ 3 +
      W.toAffine.polynomial * (16 * W.toAffine.polynomial - 8 * W.ψ₂ ^ 2) * C
        (if Even m then W.preΨ' (m + 4) * W.preΨ' (m + 2) ^ 3
          else -W.preΨ' (m + 1) * W.preΨ' (m + 3) ^ 3) 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Degree.lean - 2024-08-20 13:18:32.632823.
---0/3204---
Verifying proof:
:= by
  induction n using Int.negInduction with
  | nat n => simpa only [preΨ_ofNat] using natDegree_pos_of_pos hn
  | neg => simpa only [preΨ_ofNat] using natDegree_pos_of_ne_zero h

For theorem:
lemma natDegree_preΨ_pos {n : ℤ} (hn : 2 < n.natAbs) (h : (n : R) ≠ 0) :
    0 < (W.preΨ n).natDegree 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/EllipticCurve/Group.lean - 2024-08-20 13:18:37.864550.
---0/3204---
Verifying proof:
  max (2 • p.degree) (2 • q.degree) =
    max (2 • p.degree) (2 • q.degree) (2 • q.degree) + max (2 • q.degree) (2 • q.degree) := by
    simp only [Algebra.smul_def, Algebra.smul_def, Algebra.smul_def]
    simp only [Algebra.smul_def, Algebra.smul_def, Algebra.smul_def, Algebra.smul_def,
      Algebra.smul_def, Algebra.smul_def, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_one,
      Algebra.smul_def, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_one, smul_eq_mul, mul_one,
      Algebra.smul_mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc,
      ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc,
      ← Algebra.smul_def, ← Algebra.smul_def, ← Algebra.smul_def, smul_eq_mul, mul_one,
      smul_eq_mul, smul_eq_mul, mul_one, smul_eq_mul, smul_eq_mul, mul_one, smul_eq_mul,
      mul_add, mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc, ← mul_assoc,
      ← Algebra.smul_def, smul_eq_mul, smul_eq_mu

For theorem:
lemma degree_norm_smul_basis [IsDomain R] (p q : R[X]) :
    (Algebra.norm R[X] <| p • (1 : W.CoordinateRing) + q • mk W Y).degree =
      max (2 • p.degree) (2 • q.degree + 3) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  AdjoinRoot.mk_eq_mk.mpr ⟨1, by simp⟩

For theorem:
lemma C_addPolynomial (x y L : R) : mk W (C <| W.addPolynomial x y L) =
    mk W ((Y - C (linePolynomial x y L)) * (W.negPolynomial - C (linePolynomial x y L))) 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean - 2024-08-20 13:19:07.688843.
---0/3204---
Verifying proof:
:= by
  by_cases hPz : P z = 0
  · rw [toAffine_of_Z_eq_zero <| by rw [toAffine_of_Z_eq_zero hPz, toAffine_of_Z_eq_zero hPz,
    toAffine_add_of_Z_eq_zero hP hQ hPz]
  · rw [toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hPz,
      toAffine_add_of_Z_eq_zero hP hQ hPz, toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hPz,
    toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hP hQ hPz,
    toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hPz,
    toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hPz,
    toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hPz,
    toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hPz,
    toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero hPz,
    toAffine_add_of_Z_eq_zero hPz, toAffine_add_of_Z_eq_zero 

For theorem:
lemma toAffine_add {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q) :
    toAffine W (W.add P Q) = toAffine W P + toAffine W Q 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [fin3_def P, hPz] at hP ⊢
  rw [fin3_def Q, hQz]

For theorem:
lemma equiv_of_Z_eq_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ≈ Q 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [fin3_def P, hPz] at hP ⊢
  rw [fin3_def Q, hQz]

For theorem:
lemma equiv_of_Z_eq_zero {P Q : Fin 3 → F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ≈ Q 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/EllipticCurve/Weierstrass.lean - 2024-08-20 13:20:15.562480.
---0/3204---
Verifying proof:
:= by
  by_cases h3 : (3 : F) = 0
  · exact ofJ_1728_of_three_eq_zero h3

For theorem:
lemma ofJ_1728_of_two_ne_zero [h2 : NeZero (2 : F)] :
    ofJ 1728 = @ofJ1728 _ _ (invertibleOfNonzero h2.out) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [ofJ, c₄, b₂, b₄]

For theorem:
lemma ofJ_c₄ : (ofJ j).c₄ = j * (j - 1728) ^ 3 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [ofJ1728, Δ, b₂, b₄, b₆, b₈]

For theorem:
lemma ofJ1728_Δ : (ofJ1728 R).Δ = -64 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [ofJ, Δ, b₂, b₄, b₆, b₈]

For theorem:
lemma ofJ_Δ : (ofJ j).Δ = j ^ 2 * (j - 1728) ^ 9 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  field_simp [EllipticCurve.j, ofJ', @unitOfInvertible_val _ _ <| invertibleMul _ _,
    WeierstrassCurve.ofJ_c₄]

For theorem:
lemma ofJ'_j (j : R) [Invertible j] [Invertible (j - 1728)] : (ofJ' j).j = j 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases h0 : j = 0
  · by_cases h0 : j = 0
  · rw [h0, ofJ_0_of_three_eq_zero h3,
      @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,
    @ofJ_0_of_three_eq_zero h3,


For theorem:
lemma ofJ_j : (ofJ j).j = j 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean - 2024-08-20 13:21:11.009613.
---0/3204---
Verifying proof:
:= by
  rw [← Adjunction.homEquiv_id, ← Adjunction.homEquiv_id, adjunction_homEquiv_id]

For theorem:
theorem adjunction_unit_app {X : Scheme} :
    ΓSpec.adjunction.unit.app X = locallyRingedSpaceAdjunction.unit.app X.1 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← Spec.toLocallyRingedSpace.map_comp, ← Spec.toLocallyRingedSpace.map_comp,
    Spec.toLocallyRingedSpace.map_comp, ← op_comp, Spec.toLocallyRingedSpace.map_comp,
    Spec.toLocallyRingedSpace.map_comp, ← op_comp, Spec.toLocallyRingedSpace.map_comp,
    Spec.toLocallyRingedSpace.map_comp, ← op_comp, Spec.toLocallyRingedSpace.map_comp,
    Spec.toLocallyRingedSpace.map_comp, ← op_comp, Spec.toLocallyRingedSpace.map_comp,
    Spec.toLocallyRingedSpace.map_comp, ← op_comp, Spec.toLocallyRingedSpace.map_comp,
    Spec.toLocallyRingedSpace.map_comp, ← op_comp, Spec.toLocallyRingedSpace.map_comp,
    Spec.toLocallyRingedSpace.map_comp, ← op_comp, Spec.toLocallyRingedSpace.map_comp,
    Spec.toLocallyRingedSpace.map_comp, ← op_comp, Spec.toLocallyRingedSpace.map_comp,
    Spec.toLocallyRingedSpace.map_comp, ← op_comp, Spec.toLocallyRingedSpace.map_comp,
    Spec.toLocallyRingedSpace.map_comp, ← op_comp, Spec.toLocallyRingedSpace.map_comp,
    Spec.toLocallyRingedSpace.map_comp]
 

For theorem:
theorem right_triangle (R : CommRingCat) :
    identityToΓSpec.app (Spec.toLocallyRingedSpace.obj <| op R) ≫
        Spec.toLocallyRingedSpace.map (SpecΓIdentity.inv.app R).op =
      𝟙 _ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [PresheafedSpace.stalkMap]
  erw [← toOpen_germ _ (basicOpen _ _)]
  erw [← toOpen_germ _ (basicOpen _ _)]

For theorem:
theorem toStalk_stalkMap_toΓSpec (x : X) :
    toStalk _ _ ≫ PresheafedSpace.stalkMap X.toΓSpecSheafedSpace x = X.ΓToStalk x 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/Gluing.lean - 2024-08-20 13:22:26.962284.
---0/3204---
Verifying proof:
:= by
  rw [← cancel_epi 𝒰.fromGlued]
  apply Multicoequalizer.hom_ext

For theorem:
theorem hom_ext {Y : Scheme} (f₁ f₂ : X ⟶ Y) (h : ∀ x, 𝒰.map x ≫ f₁ = 𝒰.map x ≫ f₂) : f₁ = f₂ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro U hU
  rw [isOpen_iff_forall_mem_open]
  intro x hx
  rw [𝒰.gluedCover.isOpen_iff] at hU

For theorem:
theorem fromGlued_open_map : IsOpenMap 𝒰.fromGlued.1.base 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/Morphisms/Basic.lean - 2024-08-20 13:22:35.284077.
---0/3204---
Verifying proof:
:= by
  tfae_have 1 → 2
  · intro U
    tfae_have 2 → 3
    · exact ⟨𝒰, by tfae_have 1⟩
  tfae_have 3 → 2
  · exact ⟨𝒰, by tfae_have 2⟩
  tfae_have 3 → 3
  · exact ⟨𝒰, by tfae_have 3⟩
  tfae_have 3 → 2
  · exact ⟨𝒰, by tfae_have 3⟩
  tfae_have 3 → 2
  · exact ⟨𝒰, by tfae_have 3⟩
  tfae_have 3 → 3
  · exact ⟨𝒰, by tfae_have 3⟩
  tfae_have 3 → 2
  · exact ⟨𝒰, by tfae_have 3⟩
  tfae_have 3 → 2
  · exact ⟨𝒰, by tfae_have 3⟩
  tfae_have 3 → 3
  · exact ⟨𝒰, by tfae_have 3⟩
  tfae_have 3 → 2
  · exact ⟨𝒰, by tfae_have 3⟩
  tfae_have 3 → 2
  · exact ⟨𝒰, by tfae_have 3⟩
  tfae_have 3 → 2
  · exact ⟨𝒰, by tfae_have 3⟩
  tfae_have 3 → 3
  · exact ⟨𝒰, by tfae_have 3⟩
  tfae_have 3 → 2
  · exact ⟨𝒰, by tfae_have 3⟩
  tfae_have 3 → 2
  · exact ⟨𝒰, by tfae_have 3⟩
  tfae_have 3 → 2
  · exact ⟨𝒰, by tfae_have 3⟩
  tfae_have 3 → 2
  · exact ⟨𝒰, by tfae_have

For theorem:
theorem PropertyIsLocalAtTarget.openCover_TFAE {P : MorphismProperty Scheme}
    (hP : PropertyIsLocalAtTarget P) {X Y : Scheme.{u}} (f : X ⟶ Y) :
    TFAE
      [P f,
        ∃ 𝒰 : Scheme.OpenCover.{u} Y,
          ∀ i : 𝒰.J, P (pullback.snd : (𝒰.pullbackCover f).obj i ⟶ 𝒰.obj i),
        ∀ (𝒰 : Scheme.OpenCover.{u} Y) (i : 𝒰.J),
          P (pullback.snd : (𝒰.pullbackCover f).obj i ⟶ 𝒰.obj i),
        ∀ U : Opens Y.carrier, P (f ∣_ U),
        ∀ {U : Scheme} (g : U ⟶ Y) [IsOpenImmersion g], P (pullback.snd : pullback f g ⟶ U),
        ∃ (ι : Type u) (U : ι → Opens Y.carrier) (_ : iSup U = ⊤), ∀ i, P (f ∣_ U i)] 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  tfae_have 1 → 2
  · intro U
    tfae_have 2 → 3
    · intro U
      tfae_have 3 → 2
      · exact ⟨U, hU⟩
      tfae_have 3 → 2
    · intro U
      tfae_have 4 → 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

For theorem:
theorem AffineTargetMorphismProperty.IsLocal.affine_openCover_TFAE
    {P : AffineTargetMorphismProperty} (hP : P.IsLocal) {X Y : Scheme.{u}} (f : X ⟶ Y) :
    TFAE
      [targetAffineLocally P f,
        ∃ (𝒰 : Scheme.OpenCover.{u} Y) (_ : ∀ i, IsAffine (𝒰.obj i)),
          ∀ i : 𝒰.J, P (pullback.snd : (𝒰.pullbackCover f).obj i ⟶ 𝒰.obj i),
        ∀ (𝒰 : Scheme.OpenCover.{u} Y) [∀ i, IsAffine (𝒰.obj i)] (i : 𝒰.J),
          P (pullback.snd : (𝒰.pullbackCover f).obj i ⟶ 𝒰.obj i),
        ∀ {U : Scheme} (g : U ⟶ Y) [IsAffine U] [IsOpenImmersion g],
          P (pullback.snd : pullback f g ⟶ U),
        ∃ (ι : Type u) (U : ι → Opens Y.carrier) (_ : iSup U = ⊤) (hU' : ∀ i, IsAffineOpen (U i)),
          ∀ i, @P _ _ (f ∣_ U i) (hU' i)] 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/Morphisms/OpenImmersion.lean - 2024-08-20 13:22:44.099440.
---0/3204---
Verifying proof:
:= by
  tfae_have 1 → 3
  · exact ⟨𝒰.basicOpenImmersion f, 𝒰.basicOpenImmersion f⟩
  tfae_have 1 → 2
  · exact ⟨𝒰.basicOpenImmersion f, fun i => (𝒰.pullbackCover _).openCover⟩
  tfae_have 2 → 3
  · exact ⟨𝒰.basicOpenImmersion f, fun i => (𝒰.pullbackCover _).openCover⟩
  tfae_have 3 → 1
  · exact ⟨𝒰.basicOpenImmersion f, fun i => (𝒰.pullbackCover _).openCover⟩
  tfae_have 3 → 2
  · exact ⟨𝒰.basicOpenImmersion f, fun i => (𝒰.pullbackCover _).openCover⟩
  tfae_have 3 → 2
  · exact ⟨𝒰.basicOpenImmersion f, fun i => (𝒰.pullbackCover _).openCover⟩
  tfae_have 3 → 2
  · exact ⟨𝒰.basicOpenImmersion f, fun i => (𝒰.pullbackCover _).openCover⟩
  tfae_have 3 → 2
  · exact ⟨𝒰.basicOpenImmersion f, fun i => (𝒰.pullbackCover _).openCover⟩
  tfae_have 3 → 2
  · exact ⟨𝒰.basicOpenImmersion f, fun i => (𝒰.pullbackCover _).openCover⟩
  tfae_have 1 → 3
  · exact ⟨𝒰.basicOpenImmersion f, fun i => (𝒰.pul

For theorem:
theorem IsOpenImmersion.openCover_TFAE {X Y : Scheme.{u}} (f : X ⟶ Y) : List.TFAE
    [IsOpenImmersion f,
    ∃ 𝒰 : Scheme.OpenCover.{u} Y,
      ∀ i : 𝒰.J, IsOpenImmersion (pullback.snd : (𝒰.pullbackCover f).obj i ⟶ 𝒰.obj i),
    ∀ (𝒰 : Scheme.OpenCover.{u} Y) (i : 𝒰.J),
      IsOpenImmersion (pullback.snd : (𝒰.pullbackCover f).obj i ⟶ 𝒰.obj i),
    ∀ U : Opens Y.carrier, IsOpenImmersion (f ∣_ U),
    ∀ {U : Scheme} (g : U ⟶ Y) [IsOpenImmersion g],
      IsOpenImmersion (pullback.snd : pullback f g ⟶ _),
    ∃ (ι : Type u) (U : ι → Opens Y.carrier) (_ : iSup U = ⊤),
      ∀ i, IsOpenImmersion (f ∣_ U i)] 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/Morphisms/QuasiCompact.lean - 2024-08-20 13:22:45.983686.
---0/3204---
Verifying proof:
:=
  QuasiCompact.openCover_iff_quasiCompact

For theorem:
theorem QuasiCompact.openCover_iff {X Y : Scheme.{u}} (𝒰 : Scheme.OpenCover.{u} Y) (f : X ⟶ Y) :
    QuasiCompact f ↔ ∀ i, QuasiCompact (pullback.snd : pullback f (𝒰.map i) ⟶ _) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  tfae_have 1 → 3
  · exact ⟨𝒰, by simp only [QuasiCompact.openCover_tfae f, QuasiCompact.openCover_tfae f,
      QuasiCompact.openCover_tfae f, QuasiCompact.openCover_tfae f, QuasiCompact.openCover_tfae f,
      QuasiCompact.openCover_tfae f⟩

For theorem:
theorem QuasiCompact.openCover_tfae {X Y : Scheme.{u}} (f : X ⟶ Y) :
    List.TFAE
      [QuasiCompact f,
        ∃ 𝒰 : Scheme.OpenCover.{u} Y,
          ∀ i : 𝒰.J, QuasiCompact (pullback.snd : (𝒰.pullbackCover f).obj i ⟶ 𝒰.obj i),
        ∀ (𝒰 : Scheme.OpenCover.{u} Y) (i : 𝒰.J),
          QuasiCompact (pullback.snd : (𝒰.pullbackCover f).obj i ⟶ 𝒰.obj i),
        ∀ U : Opens Y, QuasiCompact (f ∣_ U),
        ∀ {U : Scheme} (g : U ⟶ Y) [IsOpenImmersion g],
          QuasiCompact (pullback.snd : pullback f g ⟶ _),
        ∃ (ι : Type u) (U : ι → Opens Y) (_ : iSup U = ⊤), ∀ i, QuasiCompact (f ∣_ U i)] 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean - 2024-08-20 13:22:53.767686.
---0/3204---
Verifying proof:
:= by
  rw [← basicOpen_restrict_basicOpen_restrict_basicOpen_restrict_basicOpen_restrict_basicOpen]
  exact h₂.basicOpen_restrict

For theorem:
theorem scheme_restrict_basicOpen_of_localizationPreserves (h₁ : RingHom.RespectsIso @P)
    (h₂ : RingHom.LocalizationPreserves @P) {X Y : Scheme.{u}} [IsAffine Y] (f : X ⟶ Y)
    (r : Y.presheaf.obj (op ⊤)) (H : sourceAffineLocally (@P) f)
    (U : (X.restrict ((Opens.map f.1.base).obj <| Y.basicOpen r).openEmbedding).affineOpens) :
    P (Scheme.Γ.map ((X.restrict ((Opens.map f.1.base).obj <|
      Y.basicOpen r).openEmbedding).ofRestrict U.1.openEmbedding ≫ f ∣_ Y.basicOpen r).op) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro H U V hV
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h U hU =>?_⟩
    rw [← h]
    exact h U V e

For theorem:
theorem affineLocally_iff_affineOpens_le
    (hP : RingHom.RespectsIso @P) {X Y : Scheme.{u}} (f : X ⟶ Y) :
    affineLocally.{u} (@P) f ↔
    ∀ (U : Y.affineOpens) (V : X.affineOpens) (e : V.1 ≤ (Opens.map f.1.base).obj U.1),
      P (f.appLE _ _ e) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  tfae_have 1 → 3
  · intro H
    rw [sourceAffineLocally, sourceAffineLocally, Scheme.OpenCover.map_comp]
    intro H
    simp only [sourceAffineLocally, Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp,
      Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp,
      Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp,
      Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp,
      Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp,
      Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp,
      Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp,
      Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp,
      Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp,
      Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp, Scheme.OpenCover.map_comp,
      Scheme.OpenCover

For theorem:
theorem affine_openCover_TFAE {X Y : Scheme.{u}} [IsAffine Y] (f : X ⟶ Y) :
    List.TFAE
      [sourceAffineLocally (@P) f,
        ∃ (𝒰 : Scheme.OpenCover.{u} X) (_ : ∀ i, IsAffine (𝒰.obj i)),
          ∀ i : 𝒰.J, P (Scheme.Γ.map (𝒰.map i ≫ f).op),
        ∀ (𝒰 : Scheme.OpenCover.{u} X) [∀ i, IsAffine (𝒰.obj i)] (i : 𝒰.J),
          P (Scheme.Γ.map (𝒰.map i ≫ f).op),
        ∀ {U : Scheme} (g : U ⟶ X) [IsAffine U] [IsOpenImmersion g],
          P (Scheme.Γ.map (g ≫ f).op)] 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun h =>?_⟩
  · intro h
    simp only [Scheme.Γ.map_morphismRestrict_basicOpen, Scheme.restrict_presheaf_obj,
      Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj,
      Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj,
      Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj,
      Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj,
      Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj,
      Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj,
      Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj,
      Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj,
      Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj, Scheme.restrict_presheaf_obj,
      Scheme.

For theorem:
theorem RespectsIso.basicOpen_iff (hP : RespectsIso @P) {X Y : Scheme.{u}} [IsAffine X] [IsAffine Y]
    (f : X ⟶ Y) (r : Y.presheaf.obj (Opposite.op ⊤)) :
    P (Scheme.Γ.map (f ∣_ Y.basicOpen r).op) ↔
    P (@IsLocalization.Away.map (Y.presheaf.obj (Opposite.op ⊤)) _
      (Y.presheaf.obj (Opposite.op <| Y.basicOpen r)) _ _ (X.presheaf.obj (Opposite.op ⊤)) _
      (X.presheaf.obj (Opposite.op <| X.basicOpen (Scheme.Γ.map f.op r))) _ _
      (Scheme.Γ.map f.op) r _ <| @isLocalization_away_of_isAffine X _ (Scheme.Γ.map f.op r)) 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/OpenImmersion.lean - 2024-08-20 13:24:03.202031.
---0/3204---
Verifying proof:
:= by
  rw [← pullback.condition_assoc, pullback.condition_assoc, pullback.condition_assoc]

For theorem:
theorem range_pullback_fst_of_right :
    Set.range (pullback.fst : pullback g f ⟶ Y).1.base =
      ((Opens.map g.1.base).obj ⟨Set.range f.1.base, H.base_open.isOpen_range⟩).1 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean - 2024-08-20 13:24:08.064111.
---0/3204---
Verifying proof:
:= by
  rintro _ ⟨r, rfl⟩
  exact isTopologicalBasis_basicOpens

For theorem:
theorem isTopologicalBasis_basic_opens :
    TopologicalSpace.IsTopologicalBasis
      (Set.range fun r : R => (basicOpen r : Set (PrimeSpectrum R))) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  set_option tactic.skipAssignedInstances false in
  simp_rw [TopologicalSpace.ext_iff, ← isClosed_comap]
  simp_rw [TopologicalSpace.ext_iff, ← isClosed_comap]
  simp_rw [TopologicalSpace.ext_iff, ← isClosed_comap]
  simp_rw [TopologicalSpace.ext_iff, ← isClosed_comap]
  simp_rw [TopologicalSpace.ext_iff, ← isClosed_comap]
  simp_rw [TopologicalSpace.ext_iff, ← isClosed_comap]
  simp_rw [TopologicalSpace.ext_iff, ← isClosed_comap]
  simp_rw [TopologicalSpace.ext_iff, ← isClosed_comap]
  exact isClosed_comap

For theorem:
theorem comap_inducing_of_surjective (hf : Surjective f) : Inducing (comap f) where
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [Set.ext_iff, Set.mem_image, mem_zeroLocus, Set.image_image]

For theorem:
theorem image_comap_zeroLocus_eq_zeroLocus_comap (hf : Surjective f) (I : Ideal S) :
    comap f '' zeroLocus I = zeroLocus (I.comap f) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have ideal_gc : GaloisConnection (Set (PrimeSpectrum R))ᵒᵈ := by
    have ideal_gc : GaloisConnection (Set (PrimeSpectrum R))ᵒᵈ := by
      rw [← Set.image_subset_iff, ← Set.image_subset_iff, ← Set.image_subset_iff,
      Set.image_subset_iff, ← Set.image_subset_iff, ← Set.image_subset_iff]
    exact Set.image_subset_iff.mpr (Set.image_subset_iff.mpr (Set.subset_union_right))

For theorem:
theorem gc_set :
    @GaloisConnection (Set R) (Set (PrimeSpectrum R))ᵒᵈ _ _ (fun s => zeroLocus s) fun t =>
      vanishingIdeal t 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [Set.ext_iff, Set.mem_image, mem_zeroLocus, Set.image_image]

For theorem:
theorem image_comap_zeroLocus_eq_zeroLocus_comap (hf : Surjective f) (I : Ideal S) :
    comap f '' zeroLocus I = zeroLocus (I.comap f) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [Set.ext_iff, Set.mem_image, mem_zeroLocus, Set.image_image]

For theorem:
theorem image_comap_zeroLocus_eq_zeroLocus_comap (hf : Surjective f) (I : Ideal S) :
    comap f '' zeroLocus I = zeroLocus (I.comap f) 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/ProjectiveSpectrum/Scheme.lean - 2024-08-20 13:24:33.839862.
---0/3204---
Verifying proof:
:= fun i => (q.2.mem_or_mem _).elim id id id id

For theorem:
theorem carrier.add_mem (q : Spec.T A⁰_ f) {a b : A} (ha : a ∈ carrier f_deg q)
    (hb : b ∈ carrier f_deg q) : a + b ∈ carrier f_deg q 
Attempt failure.

---0/3204---
Verifying proof:
:= fun rid =>
  q.IsPrime.ne_top <|
    (Ideal.eq_top_iff_one _).mpr
      (by
      convert rid m
      rw [HomogeneousLocalization.mem_maximalIdeal]
      rw [HomogeneousLocalization.mem_maximalIdeal]
    exact fun h =>
      (Ideal.eq_top_iff_one _).mpr
        (Ideal.eq_top_iff_one _).mpr
        (Ideal.eq_top_iff_one _)

For theorem:
theorem carrier.denom_not_mem : f ∉ carrier.asIdeal f_deg hm q 
Attempt failure.

---0/3204---
Verifying proof:
:=
  (carrier.asIdeal.homogeneous f_deg hm q).isPrime_of_homogeneous_mem_or_mem

For theorem:
theorem carrier.asIdeal.prime : (carrier.asIdeal f_deg hm q).IsPrime 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← Set.image_preimage_eq_inter_range, ← Set.image_preimage_eq_inter_range,
    Set.image_preimage_eq_inter_range, Set.image_preimage_eq_inter_range, ← Set.image_preimage_eq_inter_range,
    Set.image_preimage_eq_inter_range, Set.inter_eq_left]

For theorem:
lemma image_basicOpen_eq_basicOpen (a : A) (i : ℕ) :
    toSpec 𝒜 f '' (Subtype.val ⁻¹' (pbo (decompose 𝒜 a i) : Set (ProjectiveSpectrum 𝒜))) =
    (PrimeSpectrum.basicOpen (R := A⁰_ f) <|
      HomogeneousLocalization.mk
        ⟨m * i, ⟨decompose 𝒜 a i ^ m, SetLike.pow_mem_graded _ (Submodule.coe_mem _)⟩,
          ⟨f^i, by rw [mul_comm]; exact SetLike.pow_mem_graded _ f_deg⟩, ⟨i, rfl⟩⟩).1 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/Properties.lean - 2024-08-20 13:26:36.174326.
---0/3204---
Verifying proof:
:= by
  apply TopCat.Presheaf.section_ext X.sheaf U

For theorem:
theorem eq_zero_of_basicOpen_eq_bot {X : Scheme} [hX : IsReduced X] {U : Opens X}
    (s : Γ(X, U)) (hs : X.basicOpen s = ⊥) : s = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have h₂ : ∀ x : U, ∃ (V : Opens X) (_ : x.1 ∈ V) (_ : x.1 ∈ V), P x := fun x => by
    intro x
    obtain ⟨V, hV₁, hV₂⟩ := h₁ X U
    refine ⟨V,?_,?_⟩
    rintro ⟨V, hV₁, hV₂⟩
    exact ⟨V, hV₁, hV₂⟩

For theorem:
theorem reduce_to_affine_global (P : ∀ {X : Scheme} (_ : Opens X), Prop)
    {X : Scheme} (U : Opens X)
    (h₁ : ∀ (X : Scheme) (U : Opens X),
      (∀ x : U, ∃ (V : _) (_ : x.1 ∈ V) (_ : V ⟶ U), P V) → P U)
    (h₂ : ∀ (X Y) (f : X ⟶ Y) [hf : IsOpenImmersion f],
      ∃ (U : Set X) (V : Set Y) (hU : U = ⊤) (hV : V = Set.range f.1.base),
        P ⟨U, hU.symm ▸ isOpen_univ⟩ → P ⟨V, hV.symm ▸ hf.base_open.isOpen_range⟩)
    (h₃ : ∀ R : CommRingCat, P (X := Spec R) ⊤) : P U 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/Pullbacks.lean - 2024-08-20 13:26:44.648167.
---0/3204---
Verifying proof:
:= by
  simp only [t'_fst_fst, t'_fst_fst_fst, t'_fst_fst_fst, t'_fst_fst_fst, t'_fst_fst_fst]

For theorem:
theorem cocycle_fst_fst_fst (i j k : 𝒰.J) :
    t' 𝒰 f g i j k ≫ t' 𝒰 f g j k i ≫ t' 𝒰 f g k i j ≫ pullback.fst ≫ pullback.fst ≫ pullback.fst =
      pullback.fst ≫ pullback.fst ≫ pullback.fst 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  delta pullbackFstιToV
  simp only [Iso.trans_hom, pullback.condition]

For theorem:
theorem pullbackFstιToV_snd (i j : 𝒰.J) :
    pullbackFstιToV 𝒰 f g i j ≫ pullback.snd = pullback.fst ≫ pullback.snd 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [t'_fst_fst, t'_fst_fst_fst, t'_fst_fst_fst, t'_fst_fst_fst, t'_fst_fst_fst]

For theorem:
theorem t'_fst_fst_snd (i j k : 𝒰.J) :
    t' 𝒰 f g i j k ≫ pullback.fst ≫ pullback.fst ≫ pullback.snd =
      pullback.fst ≫ pullback.fst ≫ pullback.snd 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [t'_fst_fst_fst, t'_fst_fst_fst, t'_fst_fst_fst, t'_fst_fst_fst, t'_fst_fst_fst,
    t'_fst_fst_fst, t'_fst_fst_fst]

For theorem:
theorem cocycle_fst_fst_snd (i j k : 𝒰.J) :
    t' 𝒰 f g i j k ≫ t' 𝒰 f g j k i ≫ t' 𝒰 f g k i j ≫ pullback.fst ≫ pullback.fst ≫ pullback.snd =
      pullback.fst ≫ pullback.fst ≫ pullback.snd 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← pullback.condition_assoc, Category.assoc, p_comm]

For theorem:
theorem lift_comp_ι (i : 𝒰.J) :
    pullback.lift pullback.snd (pullback.fst ≫ p2 𝒰 f g)
          (by rw [← pullback.condition_assoc, Category.assoc, p_comm]) ≫
        (gluing 𝒰 f g).ι i =
      (pullback.fst : pullback (p1 𝒰 f g) (𝒰.map i) ⟶ _) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [t'_fst_fst, t'_fst_fst, t'_fst_fst, t'_fst_fst, t'_fst_fst]

For theorem:
theorem cocycle_fst_snd (i j k : 𝒰.J) :
    t' 𝒰 f g i j k ≫ t' 𝒰 f g j k i ≫ t' 𝒰 f g k i j ≫ pullback.fst ≫ pullback.snd =
      pullback.fst ≫ pullback.snd 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/Restrict.lean - 2024-08-20 13:28:34.001946.
---0/3204---
Verifying proof:
:= by
  rw [← cancel_epi (Scheme.Γ.map (eqToHom U.openEmbedding_obj_top.symm).op),
    ← Functor.map_comp, ← op_comp, ← Functor.map_comp, ← op_comp, ← Functor.map_comp,
    Functor.map_comp, ← op_comp, ← Functor.map_comp, ← op_comp, ← Functor.map_comp,
    Functor.map_comp, ← op_comp, ← Functor.map_comp, ← op_comp]

For theorem:
theorem Γ_map_morphismRestrict {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Opens Y) :
    Scheme.Γ.map (f ∣_ U).op =
      Y.presheaf.map (eqToHom U.openEmbedding_obj_top.symm).op ≫
        f.app U ≫ X.presheaf.map (eqToHom (f ⁻¹ᵁ U).openEmbedding_obj_top).op 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  dsimp [morphismRestrict_preimage]

For theorem:
theorem morphismRestrict_app {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Opens Y) (V : Opens U) :
    (f ∣_ U).app V = f.app (ιOpens U ''ᵁ V) ≫
        X.presheaf.map (eqToHom (image_morphismRestrict_preimage f U V)).op 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/Spec.lean - 2024-08-20 13:29:04.405222.
---0/3204---
Verifying proof:
:=
  PrimeSpectrum.comap_id

For theorem:
theorem Spec.topMap_id (R : CommRingCat.{u}) : Spec.topMap (𝟙 R) = 𝟙 (Spec.topObj R) 
Attempt failure.

Working on Mathlib/AlgebraicGeometry/StructureSheaf.lean - 2024-08-20 13:29:15.319026.
---0/3204---
Verifying proof:
:= by
  rw [comap_id U U rfl]; rfl

For theorem:
theorem comap_id' (U : Opens (PrimeSpectrum.Top R)) :
    (comap (RingHom.id R) U U fun p hpU => by rwa [PrimeSpectrum.comap_id]) = RingHom.id _ 
Attempt failure.

Working on Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean - 2024-08-20 13:29:34.275601.
---0/3204---
Verifying proof:
:= by
  let P := Fin (n + 2) × Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  let S := Finset.univ.filter fun ij : P => (ij.2 : ℕ) ≤ (ij.1 : ℕ)
  let S := Finset

For theorem:
theorem d_squared (n : ℕ) : objD X (n + 1) ≫ objD X n = 0 := by
    dsimp
Attempt failure.

Working on Mathlib/AlgebraicTopology/DoldKan/Compatibility.lean - 2024-08-20 13:29:39.704341.
---0/3204---
Verifying proof:
:= by
  ext X
  dsimp [equivalence₁, NatIso.hcomp, Functor.IsEquivalence.ofEquivalence]
  simp

For theorem:
theorem equivalence₁UnitIso_eq : (equivalence₁ hF).unitIso = equivalence₁UnitIso hF 
Attempt failure.

Working on Mathlib/AlgebraicTopology/DoldKan/Decomposition.lean - 2024-08-20 13:29:43.412830.
---0/3204---
Verifying proof:
:= by
  simp only [Finset.sum_univ_succ, Finset.sum_empty, Finset.mem_univ, Finset.mem_filter,
    Finset.mem_univ, Finset.mem_univ, Finset.mem_filter, Finset.mem_univ, Finset.mem_univ,
    Finset.mem_filter, Finset.mem_univ, Finset.mem_univ, imp_true_iff, Finset.mem_univ,
    Finset.mem_univ, Finset.mem_filter, Finset.mem_univ, Finset.mem_univ, imp_true_iff,
    Finset.mem_univ, Finset.mem_filter, Finset.mem_univ, Finset.mem_univ, Finset.mem_filter,
    Finset.mem_univ, Finset.mem_univ, Finset.mem_filter, Finset.mem_univ, Finset.mem_univ,
    Finset.mem_univ, Finset.mem_filter, Finset.mem_univ, Finset.mem_univ, imp_true_iff,
    Finset.mem_univ, Finset.mem_filter, Finset.mem_univ, Finset.mem_univ, imp_true_iff,
    Finset.mem_univ, Finset.mem_filter, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
    Finset.mem_univ, Finset.mem_filter, Finset.mem_univ, Finset.mem_univ, imp_true_iff,
    Finset.mem_univ, Finset.mem_filter, Finset.mem_univ, Finset.mem_univ, Finset.mem_univ,
    Finset.mem_univ, Finset.mem

For theorem:
theorem decomposition_Q (n q : ℕ) :
    ((Q q).f (n + 1) : X _[n + 1] ⟶ X _[n + 1]) =
      ∑ i ∈ Finset.filter (fun i : Fin (n + 1) => (i : ℕ) < q) Finset.univ,
        (P i).f (n + 1) ≫ X.δ i.rev.succ ≫ X.σ (Fin.rev i) 
Attempt failure.

Working on Mathlib/AlgebraicTopology/DoldKan/Degeneracies.lean - 2024-08-20 13:29:51.954681.
---0/3204---
Verifying proof:
:= by
  simp only [HigherFacesVanish.comp_σ_assoc, HigherFacesVanish.comp_σ_assoc,
    HigherFacesVanish.comp_σ_assoc]

For theorem:
theorem HigherFacesVanish.comp_σ {Y : C} {X : SimplicialObject C} {n b q : ℕ} {φ : Y ⟶ X _[n + 1]}
    (v : HigherFacesVanish q φ) (hnbq : n + 1 = b + q) :
    HigherFacesVanish q
      (φ ≫
        X.σ ⟨b, by
          simp only [hnbq, Nat.lt_add_one_iff, le_add_iff_nonneg_right, zero_le]⟩) 
Attempt failure.

Working on Mathlib/AlgebraicTopology/DoldKan/EquivalencePseudoabelian.lean - 2024-08-20 13:29:59.548211.
---0/3204---
Verifying proof:
:= by
  simp only [Compatibility.τ₁_isoN₁, Compatibility.τ₁_isoN₁, Compatibility.τ₁_isoN₁]

For theorem:
theorem hη :
    Compatibility.τ₀ =
      Compatibility.τ₁ isoN₁ isoΓ₀
        (N₁Γ₀ : Γ ⋙ N₁ ≅ (toKaroubiEquivalence (ChainComplex C ℕ)).functor) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [Compatibility.τ₁_isoN₁, Compatibility.τ₁_isoN₁, Compatibility.τ₁_isoN₁]

For theorem:
theorem hη :
    Compatibility.τ₀ =
      Compatibility.τ₁ isoN₁ isoΓ₀
        (N₁Γ₀ : Γ ⋙ N₁ ≅ (toKaroubiEquivalence (ChainComplex C ℕ)).functor) 
Attempt failure.

Working on Mathlib/AlgebraicTopology/DoldKan/Homotopies.lean - 2024-08-20 13:30:13.025347.
---0/3204---
Verifying proof:
:= by
  simp only [hσ', Eq.symm_apply_apply]

For theorem:
theorem hσ'_eq' {q n a : ℕ} (ha : n = a + q) :
    (hσ' q n (n + 1) rfl : X _[n] ⟶ X _[n + 1]) =
      (-1 : ℤ) ^ a • X.σ ⟨a, Nat.lt_succ_iff.mpr (Nat.le.intro (Eq.symm ha))⟩ 
Attempt failure.

Working on Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean - 2024-08-20 13:30:19.135622.
---0/3204---
Verifying proof:
:= by
  simp only [transReflReparamAux, transReparamAux_mem_I t]

For theorem:
theorem trans_refl_reparam (p : Path x₀ x₁) :
    p.trans (Path.refl x₁) =
      p.reparam (fun t => ⟨transReflReparamAux t, transReflReparamAux_mem_I t⟩) (by continuity)
        (Subtype.ext transReflReparamAux_zero) (Subtype.ext transReflReparamAux_one) 
Attempt failure.

Working on Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean - 2024-08-20 13:30:27.302416.
---0/3204---
Verifying proof:
:= by
  rw [← Functor.map_comp, ← Functor.map_comp, ← Functor.map_comp, ← Functor.map_comp,
    ← Functor.map_comp, ← Functor.map_comp, ← Functor.map_comp, ← Functor.map_comp,
    ← Functor.map_comp, ← Functor.map_comp, ← Functor.map_comp, ← Functor.map_comp,
    ← Functor.map_comp, ← Functor.map_comp, ← Functor.map_comp, ← Functor.map_comp,
    ← Functor.map_comp]

For theorem:
theorem apply_zero_path : (πₘ f).map p = hcast (H.apply_zero x₀).symm ≫
    (πₘ H.uliftMap).map (prodToProdTopI (𝟙 (@fromTop (TopCat.of _) (ULift.up 0))) p) ≫
    hcast (H.apply_zero x₁) 
Attempt failure.

Working on Mathlib/AlgebraicTopology/FundamentalGroupoid/SimplyConnected.lean - 2024-08-20 13:30:29.902390.
---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    refine ⟨fun h x y =>?_, fun h x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
    refine ⟨fun x y =>?_⟩
    refine ⟨fun x y =>?_, fun x y =>?_⟩
   

For theorem:
theorem simply_connected_iff_paths_homotopic {Y : Type*} [TopologicalSpace Y] :
    SimplyConnectedSpace Y ↔
      PathConnectedSpace Y ∧ ∀ x y : Y, Subsingleton (Path.Homotopic.Quotient x y) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    refine ⟨fun h ↦?_, fun h ↦?_⟩
    refine ⟨fun h ↦?_⟩
    refine ⟨fun h ↦?_, fun h ↦?_⟩
    refine ⟨fun h ↦?_⟩
    refine ⟨fun h ↦?_, fun h ↦?_⟩
    refine ⟨fun h ↦?_⟩
    refine ⟨fun h ↦?_, fun h ↦?_⟩
    refine ⟨fun h ↦?_⟩
    refine ⟨fun h ↦?_, fun h ↦?_⟩
    refine ⟨fun h ↦?_⟩
    refine ⟨fun h ↦?_, fun h ↦?_⟩
    refine ⟨fun h ↦?_⟩
    refine ⟨fun h ↦?_, fun h ↦?_⟩
    refine ⟨fun h ↦?_⟩
    refine ⟨fun h ↦?_, fun h ↦?_⟩
    refine ⟨fun h ↦?_⟩
    refine ⟨fun h ↦?_, fun h ↦?_⟩
    refine ⟨fun h ↦?_⟩
    refine ⟨fun h ↦?_, fun h ↦?_⟩
    refine ⟨fun h ↦?_⟩
    refine ⟨fun h ↦?_, fun h ↦?_⟩
    refine ⟨fun h ↦?_⟩
    refine ⟨fun h ↦?_, fun h ↦?_⟩
    refine ⟨fun h ↦?_, fun h ↦?_⟩
    refine ⟨fun h ↦?_⟩
    refine ⟨fun h ↦?_, fun h ↦?_⟩
    refine ⟨

For theorem:
theorem simply_connected_iff_paths_homotopic' {Y : Type*} [TopologicalSpace Y] :
    SimplyConnectedSpace Y ↔
      PathConnectedSpace Y ∧ ∀ {x y : Y} (p₁ p₂ : Path x y), Path.Homotopic p₁ p₂ 
Attempt failure.

Working on Mathlib/AlgebraicTopology/SimplexCategory.lean - 2024-08-20 13:30:32.843496.
---0/3204---
Verifying proof:
:=
  Hom.ext _ _ (OrderHom.ext _ _ (Fin.predAbove_comp_succAbove_succ))

For theorem:
theorem δ_comp_σ_succ {n} {i : Fin (n + 1)} : δ i.succ ≫ σ i = 𝟙 ([n] : SimplexCategory) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro hyp_f_epi
  have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_surj
  have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_surj
  have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_surj
  have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_surj
  have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_surj
  have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_surj
  have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_surj
  have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_surj
  have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_surj
  have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_surj
  have f_surj : Function.Surjective f.toOrderHom.toFun := epi_iff_surjective.1 hyp_f_surj
  have f_

For theorem:
theorem len_le_of_epi {x y : SimplexCategory} {f : x ⟶ y} : Epi f → y.len ≤ x.len 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext k : 3
  dsimp [σ]
  cases' k using Fin.lastCases with k
  · simp only [lastCases, Fin.castSucc_zero, Fin.castSucc_zero]
    rw [Fin.castSucc_zero, Fin.castSucc_zero]
    simp only [Fin.castSucc_zero]

For theorem:
theorem σ_comp_σ {n} {i j : Fin (n + 1)} (H : i ≤ j) :
    σ (Fin.castSucc i) ≫ σ j = σ j.succ ≫ σ i 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases i with ⟨i, hi⟩
  ext ⟨j, hj⟩
  simp at hj
  dsimp [σ, δ, Fin.predAbove]

For theorem:
theorem δ_comp_σ_self {n} {i : Fin (n + 1)} :
    δ (Fin.castSucc i) ≫ σ i = 𝟙 ([n] : SimplexCategory) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext j
  rcases i with ⟨i, _⟩
  rcases j with ⟨j, _⟩
  dsimp [δ, σ, Fin.succAbove, Fin.succAbove]
  dsimp [δ, σ, Fin.succAbove, Fin.succAbove, Fin.succAbove]
  dsimp [δ, σ, Fin.succAbove, Fin.succAbove, Fin.succAbove, Fin.succAbove, Fin.succAbove,
    Fin.succAbove, Fin.succAbove, Fin.succAbove, Fin.succAbove_of_le_castSucc]
  dsimp [δ, σ, Fin.succAbove, Fin.succAbove, Fin.succAbove_of_le_castSucc]
  dsimp [δ, σ, Fin.succAbove, Fin.succAbove, Fin.succAbove_of_le_castSucc]
  dsimp [δ, σ, Fin.succAbove, Fin.succAbove, Fin.succAbove_of_le_castSucc]
  dsimp [δ, σ, Fin.succAbove, Fin.succAbove, Fin.succAbove_of_le_castSucc]
  dsimp [δ, σ, Fin.succAbove, Fin.succAbove, Fin.succAbove_of_le_castSucc]
  dsimp [δ, σ, Fin.succAbove, Fin.succAbove, Fin.succAbove_of_le_castSucc]
  dsimp [δ, σ, Fin.succAbove, Fin.succAbove, Fin.succAbove_of_le_castSucc]
  dsimp [δ, σ, Fin.succAbove, Fin.succAbove, Fin.succAbove_of_le_castSucc]
  dsimp [δ, σ, Fin.succAbove, Fin.succAbove, Fin.succAbov

For theorem:
theorem δ_comp_σ_succ {n} {i : Fin (n + 1)} : δ i.succ ≫ σ i = 𝟙 ([n] : SimplexCategory) 
Attempt failure.

Working on Mathlib/Analysis/Analytic/Basic.lean - 2024-08-20 13:30:51.505025.
---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne x 0 with (rfl | hx)
  · simp only [norm_zero, norm_zero, mul_zero, zero_mul, norm_zero, mul_zero]
  · simp only [norm_zero, mul_zero, zero_sub, sub_zero]
  · simp only [norm_zero, mul_zero, zero_mul, norm_zero]
  · simp only [norm_zero, mul_zero, zero_mul, norm_zero]
  · simp only [norm_zero, mul_zero, zero_mul, norm_zero, mul_zero]
  · simp only [norm_zero, mul_zero, zero_mul, norm_zero]
  · simp only [norm_zero, mul_zero, zero_sub, sub_zero]
  · simp only [norm_zero, mul_zero, zero_mul, norm_zero, mul_zero]
    exact isBigO_zero_mul_left _ _
  · simp only [sub_zero]
  · exact isBigO_zero_mul_left _ _
  · exact isBigO_zero_mul_left _ _
  · exact isBigO_zero_mul_left _ _
  · exact isBigO_zero_mul_left _ _
  · exact isBigO_zero_mul_left _ _
  · exact isBigO_zero_mul_left _ _
  · exact isBigO_zero_mul_left _ _

For theorem:
theorem HasFPowerSeriesAt.isBigO_image_sub_norm_mul_norm_sub (hf : HasFPowerSeriesAt f p x) :
    (fun y : E × E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) =O[𝓝 (x, x)] fun y =>
      ‖y - (x, x)‖ * ‖y.1 - y.2‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun h =>?_⟩
  · simp only [HasFPowerSeriesAt, HasFPowerSeriesAt, HasFPowerSeriesAt, HasFPowerSeriesAt,
      HasFPowerSeriesAt.eq_formalMultilinearSeriesAt_iff_hasFPowerSeriesWithinAt,
      HasFPowerSeriesAt.eq_formalMultilinearSeriesWithinAt_iff_hasFPowerSeriesWithinAt,
      HasFPowerSeriesAt.eq_formalMultilinearSeriesWithinAt_iff_hasFPowerSeriesWithinAt,
      HasFPowerSeriesAt.eq_formalMultilinearSeriesWithinAt_iff_hasFPowerSeriesWithinAt,
      HasFPowerSeriesAt.eq_formalMultilinearSeriesWithinAt_iff_hasFPowerSeriesWithinAt,
      HasFPowerSeriesAt.eq_formalMultilinearSeriesWithinAt_iff_hasFPowerSeriesWithinAt,
      HasFPowerSeriesAt.eq_formalMultilinearSeriesWithinAt_iff_hasFPowerSeriesWithinAt,
      HasFPowerSeriesAt.eq_formalMultilinearSeriesWithinAt_iff_hasFPowerSeriesWithinAt,
      HasFPowerSeriesAt.eq_formalMultilinearSeriesWithinAt_iff_hasFPowerSeriesWithinAt,
      HasFPowerSeriesAt.eq_formalMultilinearSeriesWithinAt_iff_hasFPowerSeriesWithinAt,
      HasFP

For theorem:
theorem HasFPowerSeriesAt.eq_formalMultilinearSeries {p₁ p₂ : FormalMultilinearSeries 𝕜 𝕜 E}
    {f : 𝕜 → E} {x : 𝕜} (h₁ : HasFPowerSeriesAt f p₁ x) (h₂ : HasFPowerSeriesAt f p₂ x) : p₁ = p₂ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ENNReal.le_of_forall_pos_nnreal_lt fun r _h0 hr =>?_
  rw [lt_tsub_iff_right, add_comm] at hr

For theorem:
theorem changeOrigin_radius : p.radius - ‖x‖₊ ≤ (p.changeOrigin x).radius 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have radius_pos : 0 < p.radius := lt_of_le_of_lt (zero_le _) h

For theorem:
theorem changeOrigin_eval (h : (‖x‖₊ + ‖y‖₊ : ℝ≥0∞) < p.radius) :
    (p.changeOrigin x).sum y = p.sum (x + y) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨a, ha, ha⟩ : ∃ a ∈ Ioo (0 : ℝ) 1, ∀ n, ‖p n‖ * (r : ℝ) ^ n ≤ ‖p n‖ * (r : ℝ) ^ n := by
    intro n
    rw [← NNReal.summable_coe]
    exact NNReal.summable_norm_mul_pow_mul_pow_of_lt_radius h
  have : ∀ n : ℕ, ‖p n‖ * (r : ℝ) ^ n < ‖p n‖ := by
    intro n
    rw [← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe,
      ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe,
      ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe,
      ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe,
      ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe,
      ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe,
      ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe, ← NNReal.coe_lt_coe,
      ← NNReal.coe_

For theorem:
theorem summable_norm_mul_pow (p : FormalMultilinearSeries 𝕜 E F) {r : ℝ≥0} (h : ↑r < p.radius) :
    Summable fun n : ℕ => ‖p n‖ * (r : ℝ) ^ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have radius_pos : 0 < p.radius := lt_of_le_of_lt (zero_le _) h

For theorem:
theorem changeOrigin_eval (h : (‖x‖₊ + ‖y‖₊ : ℝ≥0∞) < p.radius) :
    (p.changeOrigin x).sum y = p.sum (x + y) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have radius_pos : 0 < p.radius := lt_of_le_of_lt (zero_le _) h

For theorem:
theorem changeOrigin_eval (h : (‖x‖₊ + ‖y‖₊ : ℝ≥0∞) < p.radius) :
    (p.changeOrigin x).sum y = p.sum (x + y) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne r' 0 with (rfl | hr')
  · simp only [ne_eq, not_false_eq_true, imp_true_iff] at hr'
    exact hf.isBigO_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_deriv_principal
  · simp only [isBigO_principal_iff]
    exact hf.isBigO_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_deriv_principal
      (hf.isBigO_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_deriv_principal
      (hf.isBigO_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_image_sub_deriv_principal
      (hf.isBigO_sub_image_sub_deriv_princ

For theorem:
theorem HasFPowerSeriesOnBall.isBigO_image_sub_image_sub_deriv_principal
    (hf : HasFPowerSeriesOnBall f p x r) (hr : r' < r) :
    (fun y : E × E => f y.1 - f y.2 - p 1 fun _ => y.1 - y.2) =O[𝓟 (EMetric.ball (x, x) r')]
      fun y => ‖y - (x, x)‖ * ‖y.1 - y.2‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have radius_pos : 0 < p.radius := lt_of_le_of_lt (zero_le _) h

For theorem:
theorem changeOrigin_eval (h : (‖x‖₊ + ‖y‖₊ : ℝ≥0∞) < p.radius) :
    (p.changeOrigin x).sum y = p.sum (x + y) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have radius_pos : 0 < p.radius := lt_of_le_of_lt (zero_le _) h

For theorem:
theorem changeOrigin_eval (h : (‖x‖₊ + ‖y‖₊ : ℝ≥0∞) < p.radius) :
    (p.changeOrigin x).sum y = p.sum (x + y) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  { r_bound := fun x => (p.changeOrigin y).changeOrigin y
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

For theorem:
theorem HasFPowerSeriesOnBall.changeOrigin (hf : HasFPowerSeriesOnBall f p x r)
    (h : (‖y‖₊ : ℝ≥0∞) < r) : HasFPowerSeriesOnBall f (p.changeOrigin y) (x + y) (r - ‖y‖₊) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  unfold partialSum continuity
  continuity

For theorem:
theorem partialSum_continuous (p : FormalMultilinearSeries 𝕜 E F) (n : ℕ) :
    Continuous (p.partialSum n) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext x
  rw [← mkPiRing_apply_one_eq_self (p n)]
  have := Or.inr (h.hasFPowerSeriesAt.eq_zero_of_hasFPowerSeriesAt h)
  rw [← mkPiRing_apply_one_eq_self (p n)]
  have := Or.inr (h.hasFPowerSeriesAt.eq_zero_of_hasFPowerSeriesAt h)
  rw [← mkPiRing_apply_one_eq_self (p n)]
  have := Or.inr (h.hasFPowerSeriesAt.eq_zero_of_hasFPowerSeriesAt h)
  rw [← mkPiRing_apply_one_eq_self (p n)]
  have := Or.inr (h.hasFPowerSeriesAt.eq_zero_of_hasFPowerSeriesAt h)
  rw [← mkPiRing_apply_one_eq_self (p n)]
  have := Or.inr (h.hasFPowerSeriesAt.eq_zero_of_hasFPowerSeriesAt h)
  rw [← mkPiRing_apply_one_eq_self (p n)]
  have := Or.inr (h.hasFPowerSeriesAt.eq_zero_of_hasFPowerSeriesAt h)
  rw [← mkPiRing_apply_one_eq_self (p n)]
  have := Or.inr (h.hasFPowerSeriesAt.eq_zero_of_hasFPowerSeriesAt h)
  rw [← mkPiRing_apply_one_eq_self (p n)]
  have := Or.inr (h.hasFPowerSeriesAt.eq_zero_of_hasFPowerSeriesAt h)
  rw [← mkPiRing_apply_one_eq_self (p n)]
  have := Or.inr (h.hasFPowerSeriesAt.eq_zero_of_hasF

For theorem:
theorem HasFPowerSeriesAt.eq_zero {p : FormalMultilinearSeries 𝕜 𝕜 E} {x : 𝕜}
    (h : HasFPowerSeriesAt 0 p x) : p = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= Or.intro_right?_ (h.apply_eq_zero n 1)
  simpa using h.apply_zero n 1

For theorem:
theorem HasFPowerSeriesAt.eq_zero {p : FormalMultilinearSeries 𝕜 𝕜 E} {x : 𝕜}
    (h : HasFPowerSeriesAt 0 p x) : p = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  refine ⟨ε, εpos, fun y hy =>?_⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  rcases hf with ⟨ε, εpos, hε⟩
  refine ⟨ε, εpos, fun y =>?_⟩
  · simp only [norm_zero, pow_zero, mul_one]
  · simp only [norm_of_nonneg (pow_nonneg (norm_nonneg _) (norm_nonneg _)), hε, hε⟩
  · 

For theorem:
theorem HasFPowerSeriesAt.isBigO_sub_partialSum_pow (hf : HasFPowerSeriesAt f p x) (n : ℕ) :
    (fun y : E => f (x + y) - p.partialSum n y) =O[𝓝 0] fun y => ‖y‖ ^ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniformlyOn_iff.2 fun ε hε =>?_
  refine tendstoLocallyUniforml

For theorem:
theorem HasFPowerSeriesOnBall.tendstoLocallyUniformlyOn (hf : HasFPowerSeriesOnBall f p x r) :
    TendstoLocallyUniformlyOn (fun n y => p.partialSum n y) (fun y => f (x + y)) atTop
      (EMetric.ball (0 : E) r) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 h with ⟨C, Cpos, hC⟩
  rcases hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, C

For theorem:
theorem HasFPowerSeriesOnBall.uniform_geometric_approx {r' : ℝ≥0}
    (hf : HasFPowerSeriesOnBall f p x r) (h : (r' : ℝ≥0∞) < r) :
    ∃ a ∈ Ioo (0 : ℝ) 1,
      ∃ C > 0, ∀ y ∈ Metric.ball (0 : E) r', ∀ n, ‖f (x + y) - p.partialSum n y‖ ≤ C * a ^ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have radius_pos : 0 < p.radius := lt_of_le_of_lt (zero_le _) h

For theorem:
theorem changeOrigin_eval (h : (‖x‖₊ + ‖y‖₊ : ℝ≥0∞) < p.radius) :
    (p.changeOrigin x).sum y = p.sum (x + y) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have radius_pos : 0 < p.radius := lt_of_le_of_lt (zero_le _) h

For theorem:
theorem changeOrigin_eval (h : (‖x‖₊ + ‖y‖₊ : ℝ≥0∞) < p.radius) :
    (p.changeOrigin x).sum y = p.sum (x + y) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 h with ⟨C, Cpos, hC⟩
  rcases hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, Cpos, hC⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hC with ⟨C, C

For theorem:
theorem HasFPowerSeriesOnBall.uniform_geometric_approx {r' : ℝ≥0}
    (hf : HasFPowerSeriesOnBall f p x r) (h : (r' : ℝ≥0∞) < r) :
    ∃ a ∈ Ioo (0 : ℝ) 1,
      ∃ C > 0, ∀ y ∈ Metric.ball (0 : E) r', ∀ n, ‖f (x + y) - p.partialSum n y‖ ≤ C * a ^ n 
Attempt failure.

Working on Mathlib/Analysis/Analytic/CPolynomial.lean - 2024-08-20 13:40:49.856297.
---0/3204---
Verifying proof:
:= by
  rw [changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum,
    changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum,
    changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum,
    changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum,
    changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum,
    changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum,
    changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum,
    changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum,
    changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum,
    changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum, changeOriginSeries_sum,
    changeOriginSeries_sum, changeOrigi

For theorem:
lemma changeOriginSeries_sum_eq_partialSum_of_finite (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ}
    (hn : ∀ (m : ℕ), n ≤ m → p m = 0) (k : ℕ) :
    (p.changeOriginSeries k).sum = (p.changeOriginSeries k).partialSum (n - k) 
Attempt failure.

Working on Mathlib/Analysis/Analytic/Composition.lean - 2024-08-20 13:41:00.368678.
---0/3204---
Verifying proof:
:= by
  rw [compAlongComposition_eq_compAlongComposition]
  exact q.compAlongComposition_eq_compAlongComposition p c

For theorem:
theorem compAlongComposition_norm {n : ℕ} (q : FormalMultilinearSeries 𝕜 F G)
    (p : FormalMultilinearSeries 𝕜 E F) (c : Composition n) :
    ‖q.compAlongComposition p c‖ ≤ ‖q c.length‖ * ∏ i, ‖p (c.blocksFun i)‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine compAlongComposition_bound?_
  rw [compAlongComposition_bound]
  exact compAlongComposition_norm_compAlongComposition p

For theorem:
theorem compAlongComposition_bound {n : ℕ} (p : FormalMultilinearSeries 𝕜 E F) (c : Composition n)
    (f : ContinuousMultilinearMap 𝕜 (fun _i : Fin c.length => F) G) (v : Fin n → E) :
    ‖f.compAlongComposition p c v‖ ≤ (‖f‖ * ∏ i, ‖p (c.blocksFun i)‖) * ∏ i : Fin n, ‖v i‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun h =>?_⟩
  · rintro ⟨i, hi⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    simp only [Function.comp_apply, Fin.sum_univ_eq_sum_range, Fin.sum_univ_eq_sum_range,
      Fin.sum_univ_eq_sum_range, Fin.sum_univ_eq_sum_range, Fin.sum_univ_eq_sum_range,?_⟩
  · rintro ⟨i, hi⟩
    simp only [Fin.sum_univ_eq_sum_range, Fin.sum_univ_eq_sum_range, Fin.sum_univ_eq_sum_range,
      Fin.sum_univ_eq_sum_range, Fin.sum_univ_eq_sum_range, Fin.sum_univ_eq_sum_range,?_⟩
    simp only [Fin.sum_univ_succ, Fin.sum_univ_succ, Fin.sum_univ_succ, Fin.sum_univ_succ,
      Fin.sum_univ_succ, Fin.sum_univ_succ, Fin.sum_univ_succ, Fin.sum_univ_eq_sum_range,
      Fin.sum_univ_eq_sum_range, Fin.sum_univ_succ, Fin.sum_univ_succ, Fin.sum_univ_succ,
      Fin.sum_univ_succ, Fin.sum_univ_succ, Fin.sum_univ_succ, Fin.sum_univ_succ,
      Fin.sum_univ_succ, Fin.sum_univ_succ, Fin.sum_univ_succ, Fin.sum_univ_succ,
      Fin.sum_univ_succ, Fin.sum_univ_succ, Fin.sum_univ_succ, Fin.sum_univ_succ

For theorem:
theorem sigma_pi_composition_eq_iff
    (u v : Σ c : Composition n, ∀ i : Fin c.length, Composition (c.blocksFun i)) :
    u = v ↔ (ofFn fun i => (u.2 i).blocks) = ofFn fun i => (v.2 i).blocks 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply Monotone.tendsto_atTop_finset
  · intro m n hmn a ha
    have : ∀ i, i < m i := by
      intro m n hmn a ha
      have : ∀ i, i < m i := by
      intro i
      have : ∀ i, i < m i := by
      intro i
      have : ∀ i, i < m i := by
      intro i
      rw [compPartialSumTarg

For theorem:
theorem compPartialSumTarget_tendsto_atTop :
    Tendsto (fun N => compPartialSumTarget 0 N N) atTop atTop 
Attempt failure.

---0/3204---
Verifying proof:
:= by ext v; exact q.comp_coeff_zero p _ _

For theorem:
theorem comp_coeff_zero'' (q : FormalMultilinearSeries 𝕜 E F) (p : FormalMultilinearSeries 𝕜 E E) :
    (q.comp p) 0 = q 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hq with ⟨ε, εpos, hε⟩
  refine ⟨ε, εpos,?_⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hp with ⟨ε, εpos, hε⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hε with ⟨ε, εpos, hε⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine 

For theorem:
theorem comp_summable_nnreal (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F)
    (hq : 0 < q.radius) (hp : 0 < p.radius) :
    ∃ r > (0 : ℝ≥0),
      Summable fun i : Σ n, Composition n => ‖q.compAlongComposition p i.2‖₊ * r ^ i.1 := by
    rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with ⟨rq, rq_pos, hrq⟩
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [applyComposition_applyComposition, Function.update_same, Function.update_same]

For theorem:
theorem applyComposition_update (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (c : Composition n)
    (j : Fin n) (v : Fin n → E) (z : E) :
    p.applyComposition c (Function.update v j z) =
      Function.update (p.applyComposition c v) (c.index j)
        (p (c.blocksFun (c.index j))
          (Function.update (v ∘ c.embedding (c.index j)) (c.invEmbedding j) z)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  subst n
  apply id_apply_one

For theorem:
theorem id_apply_one' {n : ℕ} (h : n = 1) (v : Fin n → E) :
    (id 𝕜 E) n v = v ⟨0, h.symm ▸ zero_lt_one⟩ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  match n with
  | 0 => rfl
  | 1 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradiction
  | n + 2 => contradi

For theorem:
theorem id_apply_ne_one {n : ℕ} (h : n ≠ 1) : (FormalMultilinearSeries.id 𝕜 E) n = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hq with ⟨ε, εpos, hε⟩
  refine ⟨ε, εpos,?_⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hp with ⟨ε, εpos, hε⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hε with ⟨ε, εpos, hε⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine 

For theorem:
theorem comp_summable_nnreal (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F)
    (hq : 0 < q.radius) (hp : 0 < p.radius) :
    ∃ r > (0 : ℝ≥0),
      Summable fun i : Σ n, Composition n => ‖q.compAlongComposition p i.2‖₊ * r ^ i.1 := by
    rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with ⟨rq, rq_pos, hrq⟩
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext j
  simp only [applyComposition_applyComposition, Composition.single_applyComposition,
    Composition.single_applyComposition]

For theorem:
theorem applyComposition_single (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (hn : 0 < n)
    (v : Fin n → E) : p.applyComposition (Composition.single n hn) v = fun _j => p n v 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine HasFPowerSeriesAt.comp hg hf?_
  refine HasFPowerSeriesAt.comp hf?_
  refine HasFPowerSeriesAt.comp hg (hf.prod hg) (hg.prod hf.prod hg.prod hg.prod hg.prod hg.prod)?_
  simp only [HasFPowerSeriesAt, HasFPowerSeriesAt, HasFPowerSeriesAt, HasFPowerSeriesAt,
    HasFPowerSeriesAt]
  refine HasFPowerSeriesAt.comp hg (hf.prod hg.prod hg.prod hf.prod hg.prod hg.prod hg.prod hg.prod)?_
  simp only [HasFPowerSeriesAt, HasFPowerSeriesAt, HasFPowerSeriesAt, HasFPowerSeriesAt,
    HasFPowerSeriesAt, HasFPowerSeriesAt]
  refine HasFPowerSeriesAt.comp hf?_
  refine HasFPowerSeriesAt.comp hf?_
  refine HasFPowerSeriesAt.comp hf?_
  refine HasFPowerSeriesAt.comp hf?_
  refine HasFPowerSeriesAt.comp hf?_
  refine HasFPowerSeriesAt.comp hg.prod hg.prod hg.prod hf.prod hg.prod hg.prod?_
  refine HasFPowerSeriesAt.comp hg.prod hg.prod hg.prod hf.prod?_
  refine HasFPowerSeriesAt.comp hg.prod hg.prod?_
  refine HasFPowerSeriesAt.comp hg.prod hg.prod hf.prod?_
  refine HasFPowerSeriesAt.comp hg.prod 

For theorem:
theorem HasFPowerSeriesAt.comp {g : F → G} {f : E → F} {q : FormalMultilinearSeries 𝕜 F G}
    {p : FormalMultilinearSeries 𝕜 E F} {x : E} (hg : HasFPowerSeriesAt g q (f x))
    (hf : HasFPowerSeriesAt f p x) : HasFPowerSeriesAt (g ∘ f) (q.comp p) x := by
    rcases hg with ⟨rg, Hg⟩
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hq with ⟨ε, εpos, hε⟩
  refine ⟨ε, εpos,?_⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hp with ⟨ε, εpos, hε⟩
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hε with ⟨ε, εpos, hε⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos,?_⟩
  refine 

For theorem:
theorem comp_summable_nnreal (q : FormalMultilinearSeries 𝕜 F G) (p : FormalMultilinearSeries 𝕜 E F)
    (hq : 0 < q.radius) (hp : 0 < p.radius) :
    ∃ r > (0 : ℝ≥0),
      Summable fun i : Σ n, Composition n => ‖q.compAlongComposition p i.2‖₊ * r ^ i.1 := by
    rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with ⟨rq, rq_pos, hrq⟩
Attempt failure.

Working on Mathlib/Analysis/Analytic/Inverse.lean - 2024-08-20 13:43:21.232251.
---0/3204---
Verifying proof:
:= by
  ext1 n
  induction' n using Nat.strongRec' with n IH
  match n with n IH
  match n with
  | 0 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp
  | 1 => simp only [removeZero_

For theorem:
theorem leftInv_removeZero (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) :
    p.removeZero.leftInv i = p.leftInv i 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [rightInv, ContinuousMultilinearMap.neg_apply, ContinuousMultilinearMap.neg_apply,
    ContinuousMultilinearMap.neg_apply]

For theorem:
theorem rightInv_coeff (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F) (n : ℕ) (hn : 2 ≤ n) :
    p.rightInv i n =
      -(i.symm : F →L[𝕜] E).compContinuousMultilinearMap
          (∑ c ∈ ({c | 1 < Composition.length c}.toFinset : Finset (Composition n)),
            p.compAlongComposition (p.rightInv i) c) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨C, r, Cpos, rpos, ple⟩ :
    ∃ C : ContinuousMultilinearSeries 𝕜 E F,
      (∀ n : ℕ, 0 < p.radius n) ∧
          (∫ x in C, p.radius x n) ∂μ = ∫ x in C, p.radius x n := by
      intro n
      rw [radius_eq_intervalIntegral_of_nonneg_ae hp.le hp.le]
      exact p.radius_pos_of_pos hp hp
    rw [radius_eq_intervalIntegral_of_nonneg_ae hp.le hp.le, radius_eq_intervalIntegral_of_nonneg_ae hp.le,
      radius_eq_intervalIntegral_of_nonneg_ae hp.le hp.le, radius_eq_intervalIntegral_of_nonneg_ae hp.le]
    exact p.radius_pos_of_pos hp hp

For theorem:
theorem radius_rightInv_pos_of_radius_pos (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F)
    (hp : 0 < p.radius) : 0 < (p.rightInv i).radius 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨C, r, Cpos, rpos, ple⟩ :
    ∃ C : ContinuousMultilinearSeries 𝕜 E F,
      (∀ n : ℕ, 0 < p.radius n) ∧
          (∫ x in C, p.radius x n) ∂μ = ∫ x in C, p.radius x n := by
      intro n
      rw [radius_eq_intervalIntegral_of_nonneg_ae hp.le hp.le]
      exact p.radius_pos_of_pos hp hp
    rw [radius_eq_intervalIntegral_of_nonneg_ae hp.le hp.le, radius_eq_intervalIntegral_of_nonneg_ae hp.le,
      radius_eq_intervalIntegral_of_nonneg_ae hp.le hp.le, radius_eq_intervalIntegral_of_nonneg_ae hp.le]
    exact p.radius_pos_of_pos hp hp

For theorem:
theorem radius_rightInv_pos_of_radius_pos (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F)
    (hp : 0 < p.radius) : 0 < (p.rightInv i).radius 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨C, r, Cpos, rpos, ple⟩ :
    ∃ C : ContinuousMultilinearSeries 𝕜 E F,
      (∀ n : ℕ, 0 < p.radius n) ∧
          (∫ x in C, p.radius x n) ∂μ = ∫ x in C, p.radius x n := by
      intro n
      rw [radius_eq_intervalIntegral_of_nonneg_ae hp.le hp.le]
      exact p.radius_pos_of_pos hp hp
    rw [radius_eq_intervalIntegral_of_nonneg_ae hp.le hp.le, radius_eq_intervalIntegral_of_nonneg_ae hp.le,
      radius_eq_intervalIntegral_of_nonneg_ae hp.le hp.le, radius_eq_intervalIntegral_of_nonneg_ae hp.le]
    exact p.radius_pos_of_pos hp hp

For theorem:
theorem radius_rightInv_pos_of_radius_pos (p : FormalMultilinearSeries 𝕜 E F) (i : E ≃L[𝕜] F)
    (hp : 0 < p.radius) : 0 < (p.rightInv i).radius 
Attempt failure.

Working on Mathlib/Analysis/Analytic/Meromorphic.lean - 2024-08-20 13:44:07.595272.
---0/3204---
Verifying proof:
:= by
  rcases hf with ⟨m, hf⟩
  by_cases h_eq : (fun z ↦ (z - x) ^ m • f z) =ᶠ[𝓝 x] 0
  · have h_eq : (fun z ↦ (z - x) ^ m • f z) =ᶠ[𝓝 x] 0 := by
      filter_upwards [h_eq : (fun z ↦ (z - x) ^ m • f z) =ᶠ[𝓝 x] 0
      filter_upwards [h_eq : (fun z ↦ (z - x) ^ m • f z) =ᶠ[𝓝 x] 0

For theorem:
lemma inv {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt f⁻¹ x 
Attempt failure.

Working on Mathlib/Analysis/Analytic/Uniqueness.lean - 2024-08-20 13:44:11.149394.
---0/3204---
Verifying proof:
:= by
  refine eqOn_zero_of_preconnected_of_preconnected_of_eventuallyEq_zero hU h₀ h₀ hfz₀?_
  rw [eventuallyEq_iff_exists_mem] at hfz₀
  rcases hf z₀ h₀ with ⟨r, hr₀, hr₀⟩
  rcases hf z₀ h₀ with ⟨r, hr₀, hr₀⟩
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds hr₀
  have hr₀ : 0 < r := nonpos_of_mem_nhds h

For theorem:
theorem eqOn_zero_of_preconnected_of_eventuallyEq_zero {f : E → F} {U : Set E}
    (hf : AnalyticOn 𝕜 f U) (hU : IsPreconnected U) {z₀ : E} (h₀ : z₀ ∈ U) (hfz₀ : f =ᶠ[𝓝 z₀] 0) :
    EqOn f 0 U 
Attempt failure.

Working on Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean - 2024-08-20 13:44:12.691703.
---0/3204---
Verifying proof:
:= by
  rw [isEquivalent_iff_exists_eq_mul] at *
  rw [← inv_one]
  rw [← inv_one]

For theorem:
theorem IsEquivalent.inv (huv : u ~[l] v) : (fun x ↦ (u x)⁻¹) ~[l] fun x ↦ (v x)⁻¹ 
Attempt failure.

Working on Mathlib/Analysis/Asymptotics/Asymptotics.lean - 2024-08-20 13:44:15.264567.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?mp, fun h =>?mpr⟩
  case mp =>
    rw [isBigO_iff']
    refine ⟨fun h =>?mp, fun h =>?mpr⟩
    case mp =>
    rw [isBigO_iff'] at h
    refine ⟨fun h =>?mp, fun h =>?mpr⟩
    case mp =>
    rw [isBigO_iff'] at h
    refine ⟨fun h =>?mp, fun h =>?mpr⟩
    case mp =>
    rw [isBigO_iff'] at h
    refine ⟨fun h =>?mp, fun h =>?mpr⟩
    case mp =>
    rw [isBigO_iff'] at h
    refine ⟨fun h =>?mp, fun h =>?mpr⟩
    case mp =>
    rw [isBigO_iff'] at h
    refine ⟨fun h =>?mp, fun h =>?mpr⟩
    case mp =>
    rw [isBigO_iff'] at h
    refine ⟨fun h =>?mp, fun h =>?mpr⟩
    rw [isBigO_iff'] at h
    rw [isBigO_iff'] at h
    refine ⟨fun h =>?mp, fun h =>?mpr⟩
    rw [isBigO_iff'] at h
    rw [isBigO_iff'] at h
    refine ⟨fun h =>?mp, fun h =>?mpr⟩
    rw [isBigO_iff'] at h
    rw [isBigO_iff'] at h
    refine ⟨fun h =>?mp, fun h =>?mpr⟩
    rw [isBigO_iff'] at h
    rw [isBigO_iff'] at h
    refine ⟨fun h =>?mp, fun h =>

For theorem:
theorem isBigO_iff'' {g : α → E'''} :
    f =O[l] g ↔ ∃ c > 0, ∀ᶠ x in l, c * ‖f x‖ ≤ ‖g x‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨c, h₀, hc⟩ := h
  refine ⟨c, h₀, hc⟩
  refine ⟨c, h₀, fun x hx =>?_⟩
  refine ⟨c, h₀, fun x hx =>?_⟩
  · rw [div_eq_mul_inv, div_eq_mul_inv, div_eq_mul_inv, div_eq_mul_inv, div_eq_mul_inv]
    refine ⟨c, h₀, fun x hx =>?_⟩
    rw [div_eq_mul_inv, div_eq_mul_inv, div_eq_mul_inv]
    exact mul_le_mul_of_nonneg_right (norm_nonneg _) (norm_nonneg _)

For theorem:
theorem div_isBoundedUnder_of_isBigO {α : Type*} {l : Filter α} {f g : α → 𝕜} (h : f =O[l] g) :
    IsBoundedUnder (· ≤ ·) l fun x => ‖f x / g x‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [IsBigOWith_def]

For theorem:
theorem isBigOWith_of_eq_mul {u v : α → R} (φ : α → R) (hφ : ∀ᶠ x in l, ‖φ x‖ ≤ c)
    (h : u =ᶠ[l] φ * v) :
    IsBigOWith c l u v 
Attempt failure.

Working on Mathlib/Analysis/BoundedVariation.lean - 2024-08-20 13:44:51.319424.
---0/3204---
Verifying proof:
:= by
  obtain ⟨v, hv₁, hv₂⟩ := exists_monotone_subseq (fun i => u i ∈ s) (fun i => u i ∈ s) (fun i => us i)
  refine ⟨v, m,?_, fun i => us i, fun i =>?_⟩
  rcases hv with ⟨v, hv₁, hv₂⟩
  refine ⟨v, hv₂, fun i =>?_⟩
  rcases hv with ⟨v, hv₁, hv₂⟩
  rcases hv with ⟨v, hv₁, hv₂⟩
  refine ⟨v, hv₂, fun i =>?_, fun i =>?_⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v, hv₂, hv₃⟩
  rcases hv with ⟨v,

For theorem:
theorem add_point (f : α → E) {s : Set α} {x : α} (hx : x ∈ s) (u : ℕ → α) (hu : Monotone u)
    (us : ∀ i, u i ∈ s) (n : ℕ) :
    ∃ (v : ℕ → α) (m : ℕ), Monotone v ∧ (∀ i, v i ∈ s) ∧ x ∈ v '' Iio m ∧
      (∑ i ∈ Finset.range n, edist (f (u (i + 1))) (f (u i))) ≤
        ∑ j ∈ Finset.range m, edist (f (v (j + 1))) (f (v j)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨p, q, hp⟩ : ∃ p : ℝ, 0 < q ∧ ∀ᵐ x ∂μ, x ∈ s → DifferentiableWithinAt ℝ f s x :=
    exists_differentiableWithinAt_of_mem_real h (fun x hx => h x hx) (fun x hx => h x hx)
  refine ae_differentiableWithinAt_of_mem_real?_ hx
  rw [ae_differentiableWithinAt_iff_differentiableWithinAt, differentiableWithinAt_univ]
  refine ae_differentiableWithinAt_of_mem_real h?_
  rw [ae_differentiableWithinAt_iff_differentiableWithinAt, differentiableWithinAt_iff_differentiableWithinAt,
    differentiableWithinAt_iff_differentiableWithinAt, differentiableWithinAt_iff_differentiableWithinAt,
    differentiableWithinAt_iff_differentiableWithinAt, differentiableWithinAt_iff_differentiableWithinAt,
    differentiableWithinAt_iff_differentiableWithinAt, differentiableWithinAt_iff_differentiableWithinAt,
    differentiableWithinAt_iff_differentiableWithinAt, differentiableWithinAt_iff_differentiableWithinAt,
    differentiableWithinAt_iff_differentiableWithinAt, differentiableWithinAt_univ]
 

For theorem:
theorem ae_differentiableWithinAt_of_mem_real {f : ℝ → ℝ} {s : Set ℝ}
    (h : LocallyBoundedVariationOn f s) : ∀ᵐ x, x ∈ s → DifferentiableWithinAt ℝ f s x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine comp_inter_Icc_eq_of_monotoneOn_of_monotoneOn_of_monotoneOn_of_monotoneOn_Icc?_?_?_?_
  · intro z hz
    simp only [mem_inter_iff, mem_Icc, mem_Icc, and_imp, mem_inter_iff, mem_Icc, and_imp,
      mem_inter_iff, mem_inter_iff, mem_Icc, and_iff_right_iff_imp]
    rintro z ⟨hzs, hzs⟩
    refine ⟨hzs,?_⟩
    simp only [mem_inter_iff, mem_inter_iff, mem_inter_iff, mem_inter_iff, mem_Icc, and_imp,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff⟩
    simp only [mem_inter_iff, mem_inter_iff, mem_inter_iff, mem_Icc, mem_Icc, and_imp,
      forall_exists_index, and_imp, mem_inter_iff, mem_inter_iff, mem_Icc, and_imp,
      forall_apply_eq_imp_iff⟩
    simp only [mem_inter_iff, mem_inter_iff, mem_inter_iff, mem_Icc, mem_Icc, and_imp,
      forall_apply_eq_imp_iff

For theorem:
theorem comp_inter_Icc_eq_of_monotoneOn (f : α → E) {t : Set β} (φ : β → α) (hφ : MonotoneOn φ t)
    {x y : β} (hx : x ∈ t) (hy : y ∈ t) :
    eVariationOn (f ∘ φ) (t ∩ Icc x y) = eVariationOn f (φ '' t ∩ Icc (φ x) (φ y)) 
Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Basic.lean - 2024-08-20 13:45:09.818494.
---0/3204---
Verifying proof:
:= by
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO hl hB0 fun J hJ =>?_
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO (fun J => hB0 J) (fun J =>?_)?_
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO (fun J => hB0 J) (fun J => hB0 J)?_
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO (fun J => hB0 J) (fun J =>?_)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO (fun J => hB0 J) (fun J =>?_)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO (fun J => hB0 J) (fun J =>?_)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO (fun J => hB0 J) (fun J =>?_)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO (fun J => hB0 J) (fun J =>?_)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO (fun J => hB0 J) (fun J =>?_)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO (fun J => hB0 J) (fun J =>?_)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO (fun J => hB0 J) (fun J =>?_)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO (fun

For theorem:
theorem HasIntegral.of_le_Henstock_of_forall_isLittleO (hl : l ≤ Henstock) (B : ι →ᵇᵃ[I] ℝ)
    (hB0 : ∀ J, 0 ≤ B J) (g : ι →ᵇᵃ[I] F) (s : Set ℝⁿ) (hs : s.Countable)
    (H₁ : ∀ (c : ℝ≥0), ∀ x ∈ Box.Icc I ∩ s, ∀ ε > (0 : ℝ),
      ∃ δ > 0, ∀ J ≤ I, Box.Icc J ⊆ Metric.closedBall x δ → x ∈ Box.Icc J →
        (l.bDistortion → J.distortion ≤ c) → dist (vol J (f x)) (g J) ≤ ε)
    (H₂ : ∀ (c : ℝ≥0), ∀ x ∈ Box.Icc I \ s, ∀ ε > (0 : ℝ),
      ∃ δ > 0, ∀ J ≤ I, Box.Icc J ⊆ Metric.closedBall x δ → x ∈ Box.Icc J →
        (l.bDistortion → J.distortion ≤ c) → dist (vol J (f x)) (g J) ≤ ε * B J) :
    HasIntegral I l f vol (g I) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨

For theorem:
theorem HasIntegral.of_bRiemann_eq_false_of_forall_isLittleO (hl : l.bRiemann = false)
    (B : ι →ᵇᵃ[I] ℝ) (hB0 : ∀ J, 0 ≤ B J) (g : ι →ᵇᵃ[I] F) (s : Set ℝⁿ) (hs : s.Countable)
    (hlH : s.Nonempty → l.bHenstock = true)
    (H₁ : ∀ (c : ℝ≥0), ∀ x ∈ Box.Icc I ∩ s, ∀ ε > (0 : ℝ),
      ∃ δ > 0, ∀ J ≤ I, Box.Icc J ⊆ Metric.closedBall x δ → x ∈ Box.Icc J →
        (l.bDistortion → J.distortion ≤ c) → dist (vol J (f x)) (g J) ≤ ε)
    (H₂ : ∀ (c : ℝ≥0), ∀ x ∈ Box.Icc I \ s, ∀ ε > (0 : ℝ),
      ∃ δ > 0, ∀ J ≤ I, Box.Icc J ⊆ Metric.closedBall x δ → (l.bHenstock → x ∈ Box.Icc J) →
        (l.bDistortion → J.distortion ≤ c) → dist (vol J (f x)) (g J) ≤ ε * B J) :
    HasIntegral I l f vol (g I) := by
    refine ((l.hasBasis_toFilteriUnion_top _).tendsto_iff Metric.nhds_basis_closedBall).2 ?_
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine tendsto_integralSum_toFilter_prod_of_integrable (fun π hπ ↦?_) h
  simp only [integralSum_apply, integralSum_apply, integralSum_apply, integralSum_apply,
    integralSum_apply, integralSum_apply, integralSum_apply, integralSum_apply, integralSum_apply,
    integralSum_apply, integralSum_apply, integralSum_apply, integralSum_apply]

For theorem:
theorem tendsto_integralSum_toFilter_prod_self_inf_iUnion_eq_uniformity (h : Integrable I l f vol) :
    Tendsto (fun π : TaggedPrepartition I × TaggedPrepartition I =>
      (integralSum f vol π.1, integralSum f vol π.2))
        ((l.toFilter I ×ˢ l.toFilter I) ⊓ 𝓟 {π | π.1.iUnion = π.2.iUnion}) (𝓤 F) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨⟨0⟩⟩
  haveI : Nonempty s := ⟨

For theorem:
theorem HasIntegral.of_bRiemann_eq_false_of_forall_isLittleO (hl : l.bRiemann = false)
    (B : ι →ᵇᵃ[I] ℝ) (hB0 : ∀ J, 0 ≤ B J) (g : ι →ᵇᵃ[I] F) (s : Set ℝⁿ) (hs : s.Countable)
    (hlH : s.Nonempty → l.bHenstock = true)
    (H₁ : ∀ (c : ℝ≥0), ∀ x ∈ Box.Icc I ∩ s, ∀ ε > (0 : ℝ),
      ∃ δ > 0, ∀ J ≤ I, Box.Icc J ⊆ Metric.closedBall x δ → x ∈ Box.Icc J →
        (l.bDistortion → J.distortion ≤ c) → dist (vol J (f x)) (g J) ≤ ε)
    (H₂ : ∀ (c : ℝ≥0), ∀ x ∈ Box.Icc I \ s, ∀ ε > (0 : ℝ),
      ∃ δ > 0, ∀ J ≤ I, Box.Icc J ⊆ Metric.closedBall x δ → (l.bHenstock → x ∈ Box.Icc J) →
        (l.bDistortion → J.distortion ≤ c) → dist (vol J (f x)) (g J) ≤ ε * B J) :
    HasIntegral I l f vol (g I) := by
    refine ((l.hasBasis_toFilteriUnion_top _).tendsto_iff Metric.nhds_basis_closedBall).2 ?_
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [convergenceR_apply _ hpos₁ hpos₂ hpos₁ hpos₂ hpos₁ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos₁ hpos₂ hpos₁ hpos

For theorem:
theorem dist_integralSum_le_of_memBaseSet (h : Integrable I l f vol) (hpos₁ : 0 < ε₁)
    (hpos₂ : 0 < ε₂) (h₁ : l.MemBaseSet I c₁ (h.convergenceR ε₁ c₁) π₁)
    (h₂ : l.MemBaseSet I c₂ (h.convergenceR ε₂ c₂) π₂) (HU : π₁.iUnion = π₂.iUnion) :
    dist (integralSum f vol π₁) (integralSum f vol π₂) ≤ ε₁ + ε₂ 
Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Box/SubboxInduction.lean - 2024-08-20 13:45:45.577471.
---0/3204---
Verifying proof:
:= by
  obtain ⟨s, hs⟩ : ∃ s, p (splitCenterBox J s) := by
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_nhds with ⟨s, hs⟩
    rcases H_

For theorem:
theorem subbox_induction_on' {p : Box ι → Prop} (I : Box ι)
    (H_ind : ∀ J ≤ I, (∀ s, p (splitCenterBox J s)) → p J)
    (H_nhds : ∀ z ∈ Box.Icc I, ∃ U ∈ 𝓝[Box.Icc I] z, ∀ J ≤ I, ∀ (m : ℕ), z ∈ Box.Icc J →
      Box.Icc J ⊆ U → (∀ i, J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) → p J) :
    p I 
Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean - 2024-08-20 13:45:47.300117.
---0/3204---
Verifying proof:
:= by
  refine norm_volume_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lo

For theorem:
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) → ℝ) → E}
    {f' : (Fin (n + 1) → ℝ) →L[ℝ] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) → ℝ}
    (hxI : x ∈ (Box.Icc I)) {a : E} {ε : ℝ} (h0 : 0 < ε)
    (hε : ∀ y ∈ (Box.Icc I), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) {c : ℝ≥0}
    (hc : I.distortion ≤ c) :
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
      (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
          BoxAdditiveMap.volume)‖ ≤
      2 * ε * c * ∏ j, (I.upper j - I.lower j) := by
    set e : ℝ → (Fin n → ℝ) → (Fin (n + 1) → ℝ) := i.insertNth (α := fun _ ↦ ℝ)
    have Hl : I.lower i ∈ Icc (I.lower i) (I.upper i) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine hasIntegral_GP_pderiv hs (fun x hx =>?_) (fun x hx =>?_) (fun x hx =>?_)?_
  · refine hasIntegral_GP_pderiv hs (fun x hx =>?_) (fun x hx =>?_) (fun x hx =>?_)?_
  · exact hasIntegral_GP_pderiv hs (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx =>?_)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx =

For theorem:
theorem hasIntegral_GP_pderiv (f : (Fin (n + 1) → ℝ) → E)
    (f' : (Fin (n + 1) → ℝ) → (Fin (n + 1) → ℝ) →L[ℝ] E) (s : Set (Fin (n + 1) → ℝ))
    (hs : s.Countable) (Hs : ∀ x ∈ s, ContinuousWithinAt f (Box.Icc I) x)
    (Hd : ∀ x ∈ (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :
    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume
      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))
          BoxAdditiveMap.volume -
        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))
          BoxAdditiveMap.volume) := by
    have Hc : ContinuousOn f (Box.Icc I) := fun x hx ↦ by
    by_cases hxs : x ∈ s
    exacts [Hs x hxs, (Hd x ⟨hx, hxs⟩).continuousWithinAt]
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine hasIntegral_GP_pderiv hs (fun x hx =>?_) (fun x hx =>?_) (fun x hx =>?_)?_
  · refine hasIntegral_GP_pderiv hs (fun x hx =>?_) (fun x hx =>?_) (fun x hx =>?_)?_
  · exact hasIntegral_GP_pderiv hs (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx =>?_)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx)
      (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx => Hs x hx) (fun x hx =

For theorem:
theorem hasIntegral_GP_pderiv (f : (Fin (n + 1) → ℝ) → E)
    (f' : (Fin (n + 1) → ℝ) → (Fin (n + 1) → ℝ) →L[ℝ] E) (s : Set (Fin (n + 1) → ℝ))
    (hs : s.Countable) (Hs : ∀ x ∈ s, ContinuousWithinAt f (Box.Icc I) x)
    (Hd : ∀ x ∈ (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :
    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume
      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))
          BoxAdditiveMap.volume -
        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))
          BoxAdditiveMap.volume) := by
    have Hc : ContinuousOn f (Box.Icc I) := fun x hx ↦ by
    by_cases hxs : x ∈ s
    exacts [Hs x hxs, (Hd x ⟨hx, hxs⟩).continuousWithinAt]
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine norm_volume_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lower_sub_lo

For theorem:
theorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) → ℝ) → E}
    {f' : (Fin (n + 1) → ℝ) →L[ℝ] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) → ℝ}
    (hxI : x ∈ (Box.Icc I)) {a : E} {ε : ℝ} (h0 : 0 < ε)
    (hε : ∀ y ∈ (Box.Icc I), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) {c : ℝ≥0}
    (hc : I.distortion ≤ c) :
    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -
      (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i)) BoxAdditiveMap.volume -
        integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))
          BoxAdditiveMap.volume)‖ ≤
      2 * ε * c * ∏ j, (I.upper j - I.lower j) := by
    set e : ℝ → (Fin n → ℝ) → (Fin (n + 1) → ℝ) := i.insertNth (α := fun _ ↦ ℝ)
    have Hl : I.lower i ∈ Icc (I.lower i) (I.upper i) 
Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Integrability.lean - 2024-08-20 13:45:55.649415.
---0/3204---
Verifying proof:
:= by
  refine integrableOn_iff_integrable.2 fun ε ε0 =>?_
  rw [← integrableOn_univ] at hf hl
  refine ⟨fun ε ε0 =>?_, fun ε ε0 =>?_⟩
  refine ⟨fun hε =>?_, fun hε =>?_⟩
  · refine ⟨fun hε =>?_, fun hε =>?_⟩
    simp only [hε, integrableOn_iff_integrableOn_const] at hε
    simp only [hε, integrableOn_iff_integrableOn_const] at hε
    simp only [hε, integrableOn_iff_integrableOn_const] at hε
    simp only [hε, integrableOn_iff_integrableOn_const] at hε
    simp only [hε, integrableOn_iff_integrableOn_const] at hε
    simp only [hε, integrableOn_iff_integrableOn_const] at hε
    simp only [hε, integrableOn_iff_integrableOn_const] at hε
    simp only [hε, integrableOn_iff_integrableOn_const] at hε
    simp only [hε, integrableOn_iff_integrableOn_const] at hε
    simp only [hε, integrableOn_iff_integrableOn_const] at hε
    simp only [integrableOn_iff_integrableOn_const] at hε
    refine ⟨fun ε ε0 =>?_, fun ε ε0 =>?_⟩
    rw [← integrableOn_univ] 

For theorem:
theorem IntegrableOn.hasBoxIntegral [CompleteSpace E] {f : (ι → ℝ) → E} {μ : Measure (ι → ℝ)}
    [IsLocallyFiniteMeasure μ] {I : Box ι} (hf : IntegrableOn f I μ) (l : IntegrationParams)
    (hl : l.bRiemann = false) :
    HasIntegral.{u, v, v} I l f μ.toBoxAdditive.toSMul (∫ x in I, f x ∂μ) 
Attempt failure.

Working on Mathlib/Analysis/BoxIntegral/Partition/Split.lean - 2024-08-20 13:45:57.812027.
---0/3204---
Verifying proof:
:= by
  induction' s using Finset.induction_on with p s _ ihp
  · simp
  · simp
  · simp
  · simp
  · simp
  · simp
  · simp
  · simp
  · simp

For theorem:
theorem inf_splitMany {I : Box ι} (π : Prepartition I) (s : Finset (ι × ℝ)) :
    π ⊓ splitMany I s = π.biUnion fun J => splitMany J s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases π.eventually_splitMany_inf_eq_filter.exists with ⟨s, hs⟩
  use π.eventually_splitMany_inf_eq_filter.exists with ⟨s, hs⟩
  use π.eventually_splitMany_inf_eq_filter.exists with ⟨s, hs⟩
  use π.eventually_splitMany_inf_eq_filter.exists with ⟨s, hs⟩
  use π.eventually_splitMany_inf_eq_filter.exists with ⟨s, hs⟩
  use π.eventually_splitMany_inf_eq_filter.exists with ⟨s, hs⟩
 

For theorem:
theorem exists_iUnion_eq_diff (π : Prepartition I) :
    ∃ π' : Prepartition I, π'.iUnion = ↑I \ π.iUnion 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine (eventually_splitMany_inf_eq_filter π).exists.imp fun s hs =>?_
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs with ⟨s, hs⟩
  rcases hs wi

For theorem:
theorem IsPartition.exists_splitMany_le {I : Box ι} {π : Prepartition I} (h : IsPartition π) :
    ∃ s, splitMany I s ≤ π 
Attempt failure.

Working on Mathlib/Analysis/Calculus/BumpFunction/FiniteDimension.lean - 2024-08-20 13:46:03.801636.
---0/3204---
Verifying proof:
:= by
  rcases exists_smooth_tsupport_subset_of_mem_nhds hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε,

For theorem:
theorem exists_smooth_tsupport_subset {s : Set E} {x : E} (hs : s ∈ 𝓝 x) :
    ∃ f : E → ℝ,
      tsupport f ⊆ s ∧ HasCompactSupport f ∧ ContDiff ℝ ⊤ f ∧ range f ⊆ Icc 0 1 ∧ f x = 1 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases exists_smooth_tsupport_subset_of_mem_nhds hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε,

For theorem:
theorem exists_smooth_tsupport_subset {s : Set E} {x : E} (hs : s ∈ 𝓝 x) :
    ∃ f : E → ℝ,
      tsupport f ⊆ s ∧ HasCompactSupport f ∧ ContDiff ℝ ⊤ f ∧ range f ⊆ Icc 0 1 ∧ f x = 1 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · rintro ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with ⟨u, hu⟩
    rcases hu with

For theorem:
theorem u_exists :
    ∃ u : E → ℝ,
      ContDiff ℝ ⊤ u ∧ (∀ x, u x ∈ Icc (0 : ℝ) 1) ∧ support u = ball 0 1 ∧ ∀ x, u (-x) = u x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases exists_smooth_tsupport_subset_of_mem_nhds hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε,

For theorem:
theorem exists_smooth_tsupport_subset {s : Set E} {x : E} (hs : s ∈ 𝓝 x) :
    ∃ f : E → ℝ,
      tsupport f ⊆ s ∧ HasCompactSupport f ∧ ContDiff ℝ ⊤ f ∧ range f ⊆ Icc 0 1 ∧ f x = 1 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with 

For theorem:
theorem IsOpen.exists_smooth_support_eq {s : Set E} (hs : IsOpen s) :
    ∃ f : E → ℝ, f.support = s ∧ ContDiff ℝ ⊤ f ∧ Set.range f ⊆ Set.Icc 0 1 := by
    rcases eq_empty_or_nonempty s with (rfl | h's)
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with 

For theorem:
theorem IsOpen.exists_smooth_support_eq {s : Set E} (hs : IsOpen s) :
    ∃ f : E → ℝ, f.support = s ∧ ContDiff ℝ ⊤ f ∧ Set.range f ⊆ Set.Icc 0 1 := by
    rcases eq_empty_or_nonempty s with (rfl | h's)
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with 

For theorem:
theorem IsOpen.exists_smooth_support_eq {s : Set E} (hs : IsOpen s) :
    ∃ f : E → ℝ, f.support = s ∧ ContDiff ℝ ⊤ f ∧ Set.range f ⊆ Set.Icc 0 1 := by
    rcases eq_empty_or_nonempty s with (rfl | h's)
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with (rfl | hs')
  rcases eq_empty_or_nonempty s with 

For theorem:
theorem IsOpen.exists_smooth_support_eq {s : Set E} (hs : IsOpen s) :
    ∃ f : E → ℝ, f.support = s ∧ ContDiff ℝ ⊤ f ∧ Set.range f ⊆ Set.Icc 0 1 := by
    rcases eq_empty_or_nonempty s with (rfl | h's)
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases exists_smooth_tsupport_subset_of_mem_nhds hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε, εpos, hε⟩
  rcases exists_smooth_tsupport_subset hs with ⟨ε,

For theorem:
theorem exists_smooth_tsupport_subset {s : Set E} {x : E} (hs : s ∈ 𝓝 x) :
    ∃ f : E → ℝ,
      tsupport f ⊆ s ∧ HasCompactSupport f ∧ ContDiff ℝ ⊤ f ∧ range f ⊆ Icc 0 1 ∧ f x = 1 
Attempt failure.

Working on Mathlib/Analysis/Calculus/ContDiff/Basic.lean - 2024-08-20 13:47:02.028432.
---0/3204---
Verifying proof:
:= by
  rw [contDiffOn_succ_iff_hasFDerivWithinAt, contDiffWithinAt_succ_iff_hasFDerivWithinAt,
    contDiffOn_succ_iff_hasFDerivWithinAt, contDiffOn_succ_iff_hasFDerivWithinAt]

For theorem:
theorem contDiffOn_succ_iff_derivWithin {n : ℕ} (hs : UniqueDiffOn 𝕜 s₂) :
    ContDiffOn 𝕜 (n + 1 : ℕ) f₂ s₂ ↔
      DifferentiableOn 𝕜 f₂ s₂ ∧ ContDiffOn 𝕜 n (derivWithin f₂ s₂) s₂ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    refine ⟨fun h =>?_, fun h => h.comp_continuousLinearEquiv h⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_

For theorem:
theorem ContinuousLinearEquiv.contDiffWithinAt_comp_iff (e : G ≃L[𝕜] E) :
    ContDiffWithinAt 𝕜 n (f ∘ e) (e ⁻¹' s) (e.symm x) ↔ ContDiffWithinAt 𝕜 n f s x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : ContinuousLinearMap.iteratedFDerivWithin 𝕜 n f s = g x := by
    rw [iteratedFDerivWithin_eq_equiv_comp, ContinuousLinearMap.iteratedFDerivWithin_eq_equiv_comp,
      ContinuousLinearMap.iteratedFDerivWithin_eq_equiv_comp, ContinuousLinearMap.iteratedFDerivWithin_eq_equiv_comp,
      ContinuousLinearMap.iteratedFDerivWithin_eq_equiv_comp, Function.comp_apply,
      ContinuousLinearMap.iteratedFDerivWithin_eq_equiv_comp, Function.comp_apply,
      ContinuousLinearMap.iteratedFDerivWithin_eq_equiv_comp, Function.comp_apply,
      ContinuousLinearMap.iteratedFDerivWithin_eq_equiv_comp, Function.comp_apply,
      ContinuousLinearMap.iteratedFDerivWithin_eq_equiv_comp, Function.comp_apply,
      ContinuousLinearMap.iteratedFDerivWithin_eq_equiv_comp, Function.comp_apply,
      ContinuousLinearMap.iteratedFDerivWithin_eq_equiv_comp, Function.comp_apply,
      ContinuousLinearMap.iteratedFDerivWithin_eq_equiv_comp, Function.comp_apply,
      ContinuousLinearMap.iteratedFDerivWithin_eq_equiv_comp, 

For theorem:
theorem ContinuousLinearMap.iteratedFDerivWithin_comp_right {f : E → F} (g : G →L[𝕜] E)
    (hf : ContDiffOn 𝕜 n f s) (hs : UniqueDiffOn 𝕜 s) (h's : UniqueDiffOn 𝕜 (g ⁻¹' s)) {x : G}
    (hx : g x ∈ s) {i : ℕ} (hi : (i : ℕ∞) ≤ n) :
    iteratedFDerivWithin 𝕜 i (f ∘ g) (g ⁻¹' s) x =
      (iteratedFDerivWithin 𝕜 i f s (g x)).compContinuousLinearMap fun _ => g 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  nontriviality E
  let O₁ : (E →L[𝕜] E) → F →L[𝕜] F →L[𝕜] F := e.symm.comp e.symm.contDiffAt
  let O₂ : (E →L[𝕜] E) →L[𝕜] F := e.symm.comp e.symm.contDiffAt
  let O₂ : (E →L[𝕜] E) →L[𝕜] F := e.symm.comp e.symm.contDiffAt
  let O₂ : (E →L[𝕜] E) →L[𝕜] F := e.symm.comp e.symm.contDiffAt
  let O₂ : (E →L[𝕜] E) →L[𝕜] F := e.symm.comp e.symm.contDiffAt
  let O₂ : (E →L[𝕜] E) →L[𝕜] F := e.symm.comp e.symm.contDiffAt
  let O₂ : (E →L[𝕜] E) →L[𝕜] F := e.symm.comp e.symm.contDiffAt
  let O₂ : (E →L[𝕜] E) →L[𝕜] F := e.symm.comp e.symm.contDiffAt
  let O₂ : (E →L[𝕜] E) →L[𝕜] F := e.symm.comp e.symm.contDiffAt
  let O₂ : (E →L[𝕜] E) →L[𝕜] F := e.symm.comp e.symm.contDiffAt
  let O₂ : (E →L[𝕜] E) →L[𝕜] F := e.symm.comp e.symm.contDiffAt
  let O₂ : (E →L[𝕜] E) →L[𝕜] F := e.symm.comp e.symm.contDiffAt
  let O₂ : (E →L[𝕜] E) →L[𝕜] F := ContinuousLinearEquiv.

For theorem:
theorem contDiffAt_map_inverse [CompleteSpace E] (e : E ≃L[𝕜] F) :
    ContDiffAt 𝕜 n inverse (e : E →L[𝕜] F) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ContDiffOn.comp_contDiffOn?_
  refine ContDiffOn.comp_contDiffOn (ContDiffOn.comp_contDiffOn?_) (ContDiffOn.comp_contDiffOn?_)
  · simp only [ContDiffOn, ContinuousLinearMap.coe_comp', Function.comp_apply,
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.comp_apply, ContinuousLinearMap.coe_coe, Function.comp_apply

For theorem:
theorem ContDiffOn.comp_same_univ {Eu : Type u} [NormedAddCommGroup Eu] [NormedSpace 𝕜 Eu]
    {Fu : Type u} [NormedAddCommGroup Fu] [NormedSpace 𝕜 Fu] {Gu : Type u} [NormedAddCommGroup Gu]
    [NormedSpace 𝕜 Gu] {s : Set Eu} {t : Set Fu} {g : Fu → Gu} {f : Eu → Fu}
    (hg : ContDiffOn 𝕜 n g t) (hf : ContDiffOn 𝕜 n f s) (st : s ⊆ f ⁻¹' t) :
    ContDiffOn 𝕜 n (g ∘ f) s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  induction' n using ENat.nat_induction with n IH Itop
  · intro m hm
    refine ⟨?_,?_⟩
    · rw [contDiffWithinAt_univ]
      refine ⟨?_,?_⟩
      rw [contDiffWithinAt_univ]
      refine ⟨?_,?_⟩
      rw [contDiffWithinAt_univ]
      exact (contDiffWithinAt_univ _).contDiffWithinAt

For theorem:
theorem contDiffAt_ring_inverse [CompleteSpace R] (x : Rˣ) :
    ContDiffAt 𝕜 n Ring.inverse (x : R) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let Eu : Type max uE uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have Eu : Type max uF uG := ULift.{max uE uF uG} G
  have E

For theorem:
theorem ContDiffOn.comp {s : Set E} {t : Set F} {g : F → G} {f : E → F} (hg : ContDiffOn 𝕜 n g t)
    (hf : ContDiffOn 𝕜 n f s) (st : s ⊆ f ⁻¹' t) : ContDiffOn 𝕜 n (g ∘ f) s := by
    let Eu : Type max uE uF uG 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ContDiffOn.comp_contDiffOn?_
  refine ContDiffOn.comp_contDiffOn (ContDiffOn.comp_contDiffOn?_) (ContDiffOn.comp_contDiffOn?_)
  · simp only [ContDiffOn, ContinuousLinearMap.coe_comp', Function.comp_apply,
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.coe_comp',
      ContinuousLinearMap.comp_apply, ContinuousLinearMap.coe_coe, Function.comp_apply

For theorem:
theorem ContDiffOn.comp_same_univ {Eu : Type u} [NormedAddCommGroup Eu] [NormedSpace 𝕜 Eu]
    {Fu : Type u} [NormedAddCommGroup Fu] [NormedSpace 𝕜 Fu] {Gu : Type u} [NormedAddCommGroup Gu]
    [NormedSpace 𝕜 Gu] {s : Set Eu} {t : Set Fu} {g : Fu → Gu} {f : Eu → Fu}
    (hg : ContDiffOn 𝕜 n g t) (hf : ContDiffOn 𝕜 n f s) (st : s ⊆ f ⁻¹' t) :
    ContDiffOn 𝕜 n (g ∘ f) s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hf₀'' : HasFDerivAt (f.symm a) (f.symm a) := by
    have hf₀'' : HasFDerivAt (f.symm a) (f.symm a) := f.symm.hasFDerivAt.symm
    have hf₀'' : HasFDerivAt (f.symm a) (f.symm a) := f.symm.hasFDerivAt.symm
    have hf₀'' : HasFDerivAt (f.symm a) (f.symm a) := by
      simp only [hf₀', PartialHomeomorph.symm_apply_apply, PartialHomeomorph.symm_apply_apply,
      PartialHomeomorph.symm_apply_apply, PartialHomeomorph.symm_apply_apply, PartialHomeomorph.symm_apply_apply,
      PartialHomeomorph.symm_apply_apply, PartialHomeomorph.symm_apply_apply, PartialHomeomorph.symm_apply_apply,
      PartialHomeomorph.symm_apply_apply, PartialHomeomorph.symm_apply_apply, PartialHomeomorph.symm_apply_apply,
      PartialHomeomorph.symm_apply_apply, PartialHomeomorph.symm_apply_apply, PartialHomeomorph.symm_apply_apply,
      PartialHomeomorph.symm_apply_apply, PartialHomeomorph.symm_apply_apply, PartialHomeomorph.symm_symm,
      PartialHomeomor

For theorem:
theorem PartialHomeomorph.contDiffAt_symm [CompleteSpace E] (f : PartialHomeomorph E F)
    {f₀' : E ≃L[𝕜] F} {a : F} (ha : a ∈ f.target)
    (hf₀' : HasFDerivAt f (f₀' : E →L[𝕜] F) (f.symm a)) (hf : ContDiffAt 𝕜 n f (f.symm a)) :
    ContDiffAt 𝕜 n f.symm a := by
    induction' n using ENat.nat_induction with n IH Itop
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [contDiffWithinAt_iff_contDiffWithinAt, ← preimage_comp]
  exact hg.contDiffWithinAt_preimage hf.contDiffWithinAt

For theorem:
theorem ContDiffWithinAt.comp {s : Set E} {t : Set F} {g : F → G} {f : E → F} (x : E)
    (hg : ContDiffWithinAt 𝕜 n g t (f x)) (hf : ContDiffWithinAt 𝕜 n f s x) (st : s ⊆ f ⁻¹' t) :
    ContDiffWithinAt 𝕜 n (g ∘ f) s x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← iteratedFDerivWithin_add_apply hf hg hx, iteratedFDerivWithin_add_apply hu hx]

For theorem:
theorem iteratedFDerivWithin_add_apply {f g : E → F} (hf : ContDiffOn 𝕜 i f s)
    (hg : ContDiffOn 𝕜 i g s) (hu : UniqueDiffOn 𝕜 s) (hx : x ∈ s) :
    iteratedFDerivWithin 𝕜 i (f + g) s x =
      iteratedFDerivWithin 𝕜 i f s x + iteratedFDerivWithin 𝕜 i g s x 
Attempt failure.

Working on Mathlib/Analysis/Calculus/ContDiff/Bounds.lean - 2024-08-20 13:53:55.155826.
---0/3204---
Verifying proof:
:= by
  refine norm_iteratedFDerivWithin_eq_of_uniqueDiffOn?_ hs hf hg hs?_?_
  · simp only [norm_iteratedFDerivWithin_eq_of_bilinear_of_contDiffOn hf hg hs]
    refine ⟨fun x hx =>?_, fun x hx =>?_⟩
    · simp only [norm_iteratedFDerivWithin_eq_of_bilinear_of_continuousLinearMap_comp,
      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_sm

For theorem:
theorem norm_iteratedFDerivWithin_clm_apply {f : E → F →L[𝕜] G} {g : E → F} {s : Set E} {x : E}
    {N : ℕ∞} {n : ℕ} (hf : ContDiffOn 𝕜 N f s) (hg : ContDiffOn 𝕜 N g s) (hs : UniqueDiffOn 𝕜 s)
    (hx : x ∈ s) (hn : ↑n ≤ N) : ‖iteratedFDerivWithin 𝕜 n (fun y => (f y) (g y)) s x‖ ≤
      ∑ i ∈ Finset.range (n + 1), ↑(n.choose i) * ‖iteratedFDerivWithin 𝕜 i f s x‖ *
        ‖iteratedFDerivWithin 𝕜 (n - i) g s x‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine norm_iteratedFDerivWithin_prod_le hf hs fun i hi =>?_
  rw [norm_iteratedFDerivWithin_prod_eq hf hs]
  exact fun i hi => (hf i hi).norm

For theorem:
theorem norm_iteratedFDerivWithin_prod_le [DecidableEq ι] [NormOneClass A'] {u : Finset ι}
    {f : ι → E → A'} {N : ℕ∞} (hf : ∀ i ∈ u, ContDiffOn 𝕜 N (f i) s) (hs : UniqueDiffOn 𝕜 s) {x : E}
    (hx : x ∈ s) {n : ℕ} (hn : (n : ℕ∞) ≤ N) :
    ‖iteratedFDerivWithin 𝕜 n (∏ j ∈ u, f j ·) s x‖ ≤
      ∑ p ∈ u.sym n, (p : Multiset ι).multinomial *
        ∏ j ∈ u, ‖iteratedFDerivWithin 𝕜 (Multiset.count j p) (f j) s x‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear_aux?_?_?_?_
  · simp only [ContinuousLinearMap.norm_iteratedFDerivWithin_right, ContinuousLinearMap.norm_iteratedFDerivWithin_right,
      ContinuousLinearMap.norm_iteratedFDerivWithin_right, ContinuousLinearMap.norm_iteratedFDerivWithin_right,
      ContinuousLinearMap.norm_iteratedFDerivWithin_right, ContinuousLinearMap.norm_iteratedFDerivWithin_right,
      ContinuousLinearMap.norm_iteratedFDerivWithin_right, ContinuousLinearMap.norm_iteratedFDerivWithin_right,
      ContinuousLinearMap.norm_iteratedFDerivWithin_right, ContinuousLinearMap.norm_iteratedFDerivWithin_right,
      ContinuousLinearMap.norm_iteratedFDerivWithin_right, ContinuousLinearMap.norm_iteratedFDerivWithin_right,
      ContinuousLinearMap.norm_iteratedFDerivWithin_right, ContinuousLinearMap.norm_iteratedFDerivWithin_right]

For theorem:
theorem ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear_aux {Du Eu Fu Gu : Type u}
    [NormedAddCommGroup Du] [NormedSpace 𝕜 Du] [NormedAddCommGroup Eu] [NormedSpace 𝕜 Eu]
    [NormedAddCommGroup Fu] [NormedSpace 𝕜 Fu] [NormedAddCommGroup Gu] [NormedSpace 𝕜 Gu]
    (B : Eu →L[𝕜] Fu →L[𝕜] Gu) {f : Du → Eu} {g : Du → Fu} {n : ℕ} {s : Set Du} {x : Du}
    (hf : ContDiffOn 𝕜 n f s) (hg : ContDiffOn 𝕜 n g s) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) :
    ‖iteratedFDerivWithin 𝕜 n (fun y => B (f y) (g y)) s x‖ ≤
      ‖B‖ * ∑ i ∈ Finset.range (n + 1), (n.choose i : ℝ) * ‖iteratedFDerivWithin 𝕜 i f s x‖ *
        ‖iteratedFDerivWithin 𝕜 (n - i) g s x‖ := by
    induction' n with n IH generalizing Eu Fu Gu
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : ContDiffOn 𝕜 N f s := hf.comp hg.contDiffOn
  have : ContDiffOn 𝕜 N f s := hf.comp hf.contDiffOn
  have : ContDiffOn 𝕜 N f s := hf.comp hg.contDiffOn
  have : ContDiffOn 𝕜 N f s := hf.comp hg.contDiffOn
  have : ContDiffOn 𝕜 N f s := hf.comp hg.contDiffOn
  have : ContDiffOn 𝕜 N f s := by
    simp only [ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear hf.contDiffOn hg.contDiffOn,
      ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear hf.contDiffOn hg.contDiffOn,
      ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear hf.contDiffOn hg.contDiffOn,
      ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear hf.contDiffOn hg.contDiffOn,
      ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear hf.contDiffOn hg.contDiffOn,
      ContDiffOn.comp hf.contDiffOn hg.contDiffOn, ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear hg.contDiffOn,
      ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear hg.contDiffOn]
  

For theorem:
theorem ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear (B : E →L[𝕜] F →L[𝕜] G)
    {f : D → E} {g : D → F} {N : ℕ∞} {s : Set D} {x : D} (hf : ContDiffOn 𝕜 N f s)
    (hg : ContDiffOn 𝕜 N g s) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) {n : ℕ} (hn : (n : ℕ∞) ≤ N) :
    ‖iteratedFDerivWithin 𝕜 n (fun y => B (f y) (g y)) s x‖ ≤
      ‖B‖ * ∑ i ∈ Finset.range (n + 1), (n.choose i : ℝ) * ‖iteratedFDerivWithin 𝕜 i f s x‖ *
        ‖iteratedFDerivWithin 𝕜 (n - i) g s x‖ := by
    let Du : Type max uD uE uF uG 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine norm_iteratedFDerivWithin_eq_of_uniqueDiffOn?_ hs hf hg hs?_?_
  · simp only [norm_iteratedFDerivWithin_eq_of_bilinear_of_contDiffOn hf hg hs]
    refine ⟨fun x hx =>?_, fun x hx =>?_⟩
    · simp only [norm_iteratedFDerivWithin_eq_of_bilinear_of_continuousLinearMap_comp,
      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_sm

For theorem:
theorem norm_iteratedFDerivWithin_clm_apply {f : E → F →L[𝕜] G} {g : E → F} {s : Set E} {x : E}
    {N : ℕ∞} {n : ℕ} (hf : ContDiffOn 𝕜 N f s) (hg : ContDiffOn 𝕜 N g s) (hs : UniqueDiffOn 𝕜 s)
    (hx : x ∈ s) (hn : ↑n ≤ N) : ‖iteratedFDerivWithin 𝕜 n (fun y => (f y) (g y)) s x‖ ≤
      ∑ i ∈ Finset.range (n + 1), ↑(n.choose i) * ‖iteratedFDerivWithin 𝕜 i f s x‖ *
        ‖iteratedFDerivWithin 𝕜 (n - i) g s x‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : ContDiffOn 𝕜 N f s := hf.comp hg.contDiffOn
  have : ContDiffOn 𝕜 N f s := hf.comp hf.contDiffOn
  have : ContDiffOn 𝕜 N f s := hf.comp hg.contDiffOn
  have : ContDiffOn 𝕜 N f s := hf.comp hg.contDiffOn
  have : ContDiffOn 𝕜 N f s := hf.comp hg.contDiffOn
  have : ContDiffOn 𝕜 N f s := by
    simp only [ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear hf.contDiffOn hg.contDiffOn,
      ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear hf.contDiffOn hg.contDiffOn,
      ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear hf.contDiffOn hg.contDiffOn,
      ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear hf.contDiffOn hg.contDiffOn,
      ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear hf.contDiffOn hg.contDiffOn,
      ContDiffOn.comp hf.contDiffOn hg.contDiffOn, ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear hg.contDiffOn,
      ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear hg.contDiffOn]
  

For theorem:
theorem ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear (B : E →L[𝕜] F →L[𝕜] G)
    {f : D → E} {g : D → F} {N : ℕ∞} {s : Set D} {x : D} (hf : ContDiffOn 𝕜 N f s)
    (hg : ContDiffOn 𝕜 N g s) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) {n : ℕ} (hn : (n : ℕ∞) ≤ N) :
    ‖iteratedFDerivWithin 𝕜 n (fun y => B (f y) (g y)) s x‖ ≤
      ‖B‖ * ∑ i ∈ Finset.range (n + 1), (n.choose i : ℝ) * ‖iteratedFDerivWithin 𝕜 i f s x‖ *
        ‖iteratedFDerivWithin 𝕜 (n - i) g s x‖ := by
    let Du : Type max uD uE uF uG 
Attempt failure.

Working on Mathlib/Analysis/Calculus/ContDiff/Defs.lean - 2024-08-20 13:54:28.097081.
---0/3204---
Verifying proof:
:= by
  rcases h.contDiffOn le_rfl with ⟨u, hu, hu⟩
  rcases h.contDiffOn le_rfl with ⟨u, hu, hu⟩
  rcases h.contDiffOn le_rfl with ⟨u, hu, hu⟩
  rcases h.contDiffOn le_rfl with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu, hu⟩
  rcases hu with ⟨u, hu

For theorem:
theorem ContDiffWithinAt.eventually {n : ℕ} (h : ContDiffWithinAt 𝕜 n f s x) :
    ∀ᶠ y in 𝓝[insert x s] x, ContDiffWithinAt 𝕜 n f s y 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [contDiffWithinAt_succ_iff_hasFDerivWithinAt, hasFDerivWithinAt_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_succ_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_succ_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_succ_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWit

For theorem:
theorem contDiffWithinAt_succ_iff_hasFDerivWithinAt {n : ℕ} :
    ContDiffWithinAt 𝕜 (n + 1 : ℕ) f s x ↔ ∃ u ∈ 𝓝[insert x s] x, ∃ f' : E → E →L[𝕜] F,
      (∀ x ∈ u, HasFDerivWithinAt f (f' x) u x) ∧ ContDiffWithinAt 𝕜 n f' u x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine h.continuousWithinAt.differentiableWithinAt_of_continuousWithinAt_of_continuousWithinAt
    (fun y hy => h.continuousWithinAt.differentiableWithinAt hy)
    (fun y hy => h.continuousWithinAt.differentiableWithinAt_iteratedFDerivWithinAt hy)
    (fun y hy => h.continuousWithinAt.differentiableWithinAt_of_continuousWithinAt_of_continuousWithinAt
    (fun y hy => h.continuousWithinAt.differentiableWithinAt_of_continuousWithinAt_of_continuousWithinAt
    (fun y hy => h.continuousWithinAt.differentiableWithinAt_of_continuousWithinAt_of_continuousWithinAt
    (fun y hy => h.continuousWithinAt.differentiableWithinAt_of_continuousWithinAt_of_continuousWithinAt
    (fun y hy => h.continuousWithinAt.differentiableWithinAt_of_continuousWithinAt_of_continuousWithinAt
      (fun y hy => h.continuousWithinAt.differentiableWithinAt_of_continuousWithinAt_of_continuousWithinAt
      (fun y hy => h.continuousWithinAt.differentiableWithinAt_of_continuousWithinAt_of_continuousWithinAt
    (fun y hy => h.continuou

For theorem:
theorem ContDiffWithinAt.differentiableWithinAt_iteratedFDerivWithin {m : ℕ}
    (h : ContDiffWithinAt 𝕜 n f s x) (hmn : (m : ℕ∞) < n) (hs : UniqueDiffOn 𝕜 (insert x s)) :
    DifferentiableWithinAt 𝕜 (iteratedFDerivWithin 𝕜 m f s) s x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    obtain ⟨u, H, p, hp⟩ := h 0
    rw [contDiffWithinAt_zero_iff_continuousWithinAt, contDiffWithinAt_const_iff]
    exact ⟨u, H, p, hp⟩

For theorem:
theorem contDiffWithinAt_zero (hx : x ∈ s) :
    ContDiffWithinAt 𝕜 0 f s x ↔ ∃ u ∈ 𝓝[s] x, ContinuousOn f (s ∩ u) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  let ⟨u, hu, hus, hu⟩ := h.continuousWithinAt.continuousWithinAt.continuousWithinAt
  let ⟨u, hu, hux, hu⟩ := h.continuousWithinAt.continuousWithinAt
  let ⟨u, hu, hu⟩ := h.continuousWithinAt.continuousWithinAt
  let ⟨u, hu, hu⟩ := h.continuousWithinAt.continuousWithinAt.continuousWithinAt
  let ⟨u, hu, hu⟩ := h.continuousWithinAt.continuousWithinAt.continuousWithinAt
  let ⟨u, hu, hu⟩ := h.continuousWithinAt.continuousWithinAt.continuousWithinAt
  let ⟨u, hu, hu⟩ := h.continuousWithinAt.continuousWithinAt.continuousWithinAt
  let ⟨u, hu, hu⟩ := h.continuousWithinAt.continuousWithinAt.continuousWithinAt
  let ⟨u, hu, hu⟩ := h.continuousWithinAt.continuousWithinAt.continuousWithinAt
  let ⟨u, hu, hu⟩ := h.continuousWithinAt.continuousWithinAt.continuousWithinAt
  let ⟨u, hu, hu⟩ := h.continuousWithinAt.continuousWithinAt.continuousWithinAt
  let ⟨u, hu, hu⟩ := h.continuousWithinAt.continuousWithinAt
  let ⟨u, hu, hu⟩ := h.continuousWithinAt.continuousWit

For theorem:
theorem ContDiffWithinAt.contDiffOn {m : ℕ} (hm : (m : ℕ∞) ≤ n) (h : ContDiffWithinAt 𝕜 n f s x) :
    ∃ u ∈ 𝓝[insert x s] x, u ⊆ insert x s ∧ ContDiffOn 𝕜 m f u 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [contDiffOn_iff_fderivWithin hs, contDiffOn_iff_fderivWithin hs]

For theorem:
theorem contDiffOn_top_iff_fderivWithin (hs : UniqueDiffOn 𝕜 s) :
    ContDiffOn 𝕜 ∞ f s ↔
      DifferentiableOn 𝕜 f s ∧ ContDiffOn 𝕜 ∞ (fun y => fderivWithin 𝕜 f s y) s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun x hx =>?_, h.fderivWithin, fun x hx =>?_⟩
  refine ⟨fun x hx =>?_, h.fderivWithin, fun x hx =>?_⟩
  · simp only [h.fderivWithin, h₁ x hx]

For theorem:
theorem HasFTaylorSeriesUpToOn.congr (h : HasFTaylorSeriesUpToOn n f p s)
    (h₁ : ∀ x ∈ s, f₁ x = f x) : HasFTaylorSeriesUpToOn n f₁ p s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [iteratedFDerivWithin_succ_apply_right hs hx, iteratedFDerivWithin_succ_apply_right]

For theorem:
theorem iteratedFDerivWithin_succ_apply_right {n : ℕ} (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s)
    (m : Fin (n + 1) → E) :
    (iteratedFDerivWithin 𝕜 (n + 1) f s x : (Fin (n + 1) → E) → F) m =
      iteratedFDerivWithin 𝕜 n (fun y => fderivWithin 𝕜 f s y) s x (init m) (m (last n)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [hasFTaylorSeriesUpToOn_succ_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt]

For theorem:
theorem hasFTaylorSeriesUpToOn_succ_iff_right {n : ℕ} :
    HasFTaylorSeriesUpToOn (n + 1 : ℕ) f p s ↔
      (∀ x ∈ s, (p x 0).uncurry0 = f x) ∧
        (∀ x ∈ s, HasFDerivWithinAt (fun y => p y 0) (p x 1).curryLeft s x) ∧
          HasFTaylorSeriesUpToOn n (fun x => continuousMultilinearCurryFin1 𝕜 E F (p x 1))
            (fun x => (p x).shift) s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [contDiffWithinAt_succ_iff_hasFDerivWithinAt, hasFDerivWithinAt_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_succ_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_succ_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_succ_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_succ_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_succ_iff_hasFDerivWithinAt, hasFDerivWithinAt_succ_iff_hasFDerivWithinAt,
    hasFDerivWithinAt_succ_iff_hasFDerivWithinAt_succ_iff_hasFDerivWithinA

For theorem:
theorem contDiffWithinAt_succ_iff_hasFDerivWithinAt' {n : ℕ} :
    ContDiffWithinAt 𝕜 (n + 1 : ℕ) f s x ↔
      ∃ u ∈ 𝓝[insert x s] x, u ⊆ insert x s ∧ ∃ f' : E → E →L[𝕜] F,
        (∀ x ∈ u, HasFDerivWithinAt f (f' x) s x) ∧ ContDiffWithinAt 𝕜 n f' s x 
Attempt failure.

Working on Mathlib/Analysis/Calculus/Deriv/Inv.lean - 2024-08-20 13:59:22.597051.
---0/3204---
Verifying proof:
:= by
  suffices
    (fun p : 𝕜 × 𝕜 => (p.1 - p.2) * ((x * x)⁻¹ - (p.1 * p.2)⁻¹)) =o[𝓝 (x, x)] fun p : 𝕜 => (x * x)⁻¹ * ((x * x)⁻¹ - (p.1 * p.2)⁻¹)) =o[𝓝 (x, x)] fun p : 𝕜 => (x * x)⁻¹ * ((x * x)⁻¹ - (p.1 * p.2)⁻¹)) =o[𝓝 (x, x)] fun p : 𝕜 => (x * x)⁻¹ * ((x * x)⁻¹ - (p.1 * p.2)⁻¹)) =o[𝓝 (x, x)] fun p : 𝕜 => (x * x)⁻¹ * ((x * x)⁻¹ - (p.1 * p.2)⁻¹)) =o[𝓝 (x, x)] fun p : 𝕜 => (x * x)⁻¹ * ((x * x)⁻¹ - (p.1 * p.2)⁻¹)) =o[𝓝 (x, x)] fun p : 𝕜 => (x * x)⁻¹ * ((x * x)⁻¹ - (p.1 * p.2)⁻¹)) =o[𝓝 (x, x)] fun p : 𝕜 => (x * x)⁻¹ * ((x * x)⁻¹ - (p.1 * p.2)⁻¹)) =o[𝓝 (x, x)] fun p : 𝕜 => (x * x)⁻¹ * ((x * x)⁻¹ - (p.1 * p.2)⁻¹)) =o[𝓝 (x, x)] fun p : 𝕜 => (x * x)⁻¹ * ((x * x)⁻¹ - (p.1 * p.2)⁻¹)) =o[𝓝 (x, x)] fun p : 𝕜 => (x * x)⁻¹ * ((x * x)⁻¹ - (p.1 * p.2)⁻¹)) =o[𝓝 (x, x)] fun p : 𝕜 => (x * x)⁻¹ * ((x * x)⁻¹ - (p.1 * p.2)⁻¹)) by
    simpa only [inv_inv

For theorem:
theorem hasStrictDerivAt_inv (hx : x ≠ 0) : HasStrictDerivAt Inv.inv (-(x ^ 2)⁻¹) x 
Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Analytic.lean - 2024-08-20 13:59:25.895634.
---0/3204---
Verifying proof:
:= by
  intro y hy
  rcases h y hy with ⟨p, r, hp⟩
  exact hp.fderiv.analyticAt

For theorem:
theorem AnalyticOn.fderiv [CompleteSpace F] (h : AnalyticOn 𝕜 f s) :
    AnalyticOn 𝕜 (fderiv 𝕜 f) s 
Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Basic.lean - 2024-08-20 13:59:40.120508.
---0/3204---
Verifying proof:
:= by
  apply fderivWithin_zero_of_isolated
  simp only [mem_closure_iff_nhdsWithin_neBot, neBot_iff, Ne, not_false_iff] at h
  simp only [fderivWithin_zero_of_isolated
  simp only [mem_closure_iff_nhdsWithin_neBot, neBot_iff, Ne]

For theorem:
theorem fderivWithin_zero_of_nmem_closure (h : x ∉ closure s) : fderivWithin 𝕜 f s x = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : Tendsto (fun x' => f x' - f x) L (𝓝 0) := by
    refine h.continuousAt.continuousWithinAt.continuousWithinAt
      (fun x' => f x' - f x) L (𝓝 0) := by
      rw [tendsto_iff_norm_sub_tendsto_zero]
      exact tendsto_const_nhds.sub (tendsto_const_nhds.sub tendsto_const_nhds)
  have : Tendsto (fun x' => f x' - f x) L (𝓝 0) := by
    rw [tendsto_iff_norm_sub_tendsto_zero]
    exact tendsto_const_nhds.sub tendsto_const_nhds

For theorem:
theorem HasFDerivAtFilter.tendsto_nhds (hL : L ≤ 𝓝 x) (h : HasFDerivAtFilter f f' x L) :
    Tendsto f L (𝓝 (f x)) 
Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Comp.lean - 2024-08-20 14:00:04.792430.
---0/3204---
Verifying proof:
:= by
  rw [← fderivWithin_univ]
  refine fderivWithin_univ.symm.fderivWithin?_
  rw [← fderivWithin_univ]
  exact fderivWithin_fderivWithin_const_smul (hf.mono h) hf h

For theorem:
theorem fderivWithin_fderivWithin {g : F → G} {f : E → F} {x : E} {y : F} {s : Set E} {t : Set F}
    (hg : DifferentiableWithinAt 𝕜 g t y) (hf : DifferentiableWithinAt 𝕜 f s x) (h : MapsTo f s t)
    (hxs : UniqueDiffWithinAt 𝕜 s x) (hy : f x = y) (v : E) :
    fderivWithin 𝕜 g t y (fderivWithin 𝕜 f s x v) = fderivWithin 𝕜 (g ∘ f) s x v 
Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Equiv.lean - 2024-08-20 14:00:08.923531.
---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne a 0 with (rfl | ha)
  · simp only [ne_eq, not_false_eq_true, imp_true_iff] at hfg ⊢
    exact hfg.mono fun y hy => (hfg.mono inter_subset_left).trans_lt (hg.mono inter_subset_left)

For theorem:
theorem HasFDerivAt.of_local_left_inverse {f : E → F} {f' : E ≃L[𝕜] F} {g : F → E} {a : F}
    (hg : ContinuousAt g a) (hf : HasFDerivAt f (f' : E →L[𝕜] F) (g a))
    (hfg : ∀ᶠ y in 𝓝 a, f (g y) = y) : HasFDerivAt g (f'.symm : F →L[𝕜] E) a 
Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Extend.lean - 2024-08-20 14:00:17.910825.
---0/3204---
Verifying proof:
:= by
  refine has_fderiv_at_boundary_of_tendsto_fderiv f_diff f_conv f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f

For theorem:
theorem has_fderiv_at_boundary_of_tendsto_fderiv {f : E → F} {s : Set E} {x : E} {f' : E →L[ℝ] F}
    (f_diff : DifferentiableOn ℝ f s) (s_conv : Convex ℝ s) (s_open : IsOpen s)
    (f_cont : ∀ y ∈ closure s, ContinuousWithinAt f s y)
    (h : Tendsto (fun y => fderiv ℝ f y) (𝓝[s] x) (𝓝 f')) :
    HasFDerivWithinAt f f' (closure s) x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine has_fderiv_at_boundary_of_tendsto_fderiv f_diff f_conv f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f_diff f_cont f_cont f

For theorem:
theorem has_fderiv_at_boundary_of_tendsto_fderiv {f : E → F} {s : Set E} {x : E} {f' : E →L[ℝ] F}
    (f_diff : DifferentiableOn ℝ f s) (s_conv : Convex ℝ s) (s_open : IsOpen s)
    (f_cont : ∀ y ∈ closure s, ContinuousWithinAt f s y)
    (h : Tendsto (fun y => fderiv ℝ f y) (𝓝[s] x) (𝓝 f')) :
    HasFDerivWithinAt f f' (closure s) x 
Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Measurable.lean - 2024-08-20 14:00:22.035541.
---0/3204---
Verifying proof:
:= by
  simpa [differentiableWithinAt_Ioi_iff_Ici] using measurableSet_of_differentiableWithinAt_Ici f

For theorem:
theorem measurableSet_of_differentiableWithinAt_Ioi :
    MeasurableSet { x | DifferentiableWithinAt ℝ f (Ioi x) x } 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : ProperSpace E :=.of_locallyCompactSpace 𝕜
  have : ProperSpace E :=.of_locallyCompactSpace 𝕜
  have : ProperSpace E :=.of_locallyCompactSpace 𝕜
  have : ProperSpace E :=.of_locallyCompactSpace 𝕜
  have : ProperSpace E :=.of_locallyCompactSpace 𝕜
  have : ProperSpace 𝕜 :=.of_locallyCompactSpace 𝕜
  have : ProperSpace 𝕜 :=.of_locallyCompactSpace 𝕜
  have : ProperSpace 𝕜 :=.of_locallyCompactSpace 𝕜
  have : ProperSpace 𝕜 :=.of_locallyCompactSpace 𝕜
  have : ProperSpace 𝕜 :=.of_locallyCompactSpace 𝕜
  have : ProperSpace 𝕜 :=.of_locallyCompactSpace 𝕜
  have : ProperSpace 𝕜 :=.of_locallyCompactSpace 𝕜
  have : ProperSpace 𝕜 :=.of_locallyCompactSpace 𝕜
  have : ProperSpace 𝕜 :=.of_locallyCompactSpace 𝕜
  have : ProperSpace 𝕜 :=.of_locallyCompactSpace 𝕜
  have : ProperSpace 𝕜 :=.of_locallyCompactSpace 𝕜
  have : ProperSpace 𝕜 :=.of_locallyCompactSpace 𝕜
  have : ProperSpace 𝕜 :=.of_locallyCompac

For theorem:
lemma isOpen_A_with_param {r s : ℝ} (hf : Continuous f.uncurry) (L : E →L[𝕜] F) :
    IsOpen {p : α × E | p.2 ∈ A (f p.1) L r s} 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have P : ∀ {n : ℕ}, (0 : ℝ) < n := fun {n : ℕ} => by
    intro n hn
    rcases hn with ⟨n, hn⟩
    exact ⟨n, hn⟩

For theorem:
theorem D_subset_differentiable_set {K : Set (E →L[𝕜] F)} (hK : IsComplete K) :
    D f K ⊆ { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have P : ∀ {n : ℕ}, (0 : ℝ) < n := fun {n : ℕ} => by
    intro n hn
    rcases hn with ⟨n, hn⟩
    exact ⟨n, hn⟩

For theorem:
theorem D_subset_differentiable_set {K : Set (E →L[𝕜] F)} (hK : IsComplete K) :
    D f K ⊆ { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have P : ∀ {n : ℕ}, (0 : ℝ) < n := fun {n : ℕ} => by
    intro n hn
    rcases hn with ⟨n, hn⟩
    exact ⟨n, hn⟩

For theorem:
theorem D_subset_differentiable_set {K : Set (E →L[𝕜] F)} (hK : IsComplete K) :
    D f K ⊆ { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [D, differentiableAt_of_isComplete hK]

For theorem:
theorem measurableSet_of_differentiableAt_of_isComplete {K : Set (E →L[𝕜] F)} (hK : IsComplete K) :
    MeasurableSet { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } := by
        simp only [D, differentiable_set_eq_D K hK]
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rintro x ⟨r', r'r, hr'⟩
  refine ⟨r', r'r, fun y hy z hz => (hr' y hy z hz).trans?_⟩
  refine ⟨r', r'r, fun y hy z hz => (hr' y hy z hz).trans?_⟩
  rintro x ⟨r', r'r, hr'⟩
  refine ⟨r', r'r, fun y hy z hz => (hr' y hy z hz).trans?_⟩
  rintro x ⟨r', r'r, hr'⟩
  refine ⟨r', r'r, fun y hy z hz => (hr' y hy z hz).trans?_⟩
  rintro x ⟨r', r'r, hr'⟩
  refine ⟨r', r'r, fun y hy z hz => (hr' y hy z hz).trans?_⟩
  rintro x ⟨r', r'r, hr'⟩
  refine ⟨r', r'r, fun y hy z hz => (hr' y hy z hz).trans?_⟩
  rintro x ⟨r', r'r, hr'⟩
  refine ⟨r', r'r, fun y hy z hz => (hr' y hy z hz).tran

For theorem:
theorem A_mono (L : E →L[𝕜] F) (r : ℝ) {ε δ : ℝ} (h : ε ≤ δ) : A f L r ε ⊆ A f L r δ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have P : ∀ {n : ℕ}, (0 : ℝ) < n := fun {n : ℕ} => by
    intro n hn
    rcases hn with ⟨n, hn⟩
    exact ⟨n, hn⟩

For theorem:
theorem D_subset_differentiable_set {K : Set (E →L[𝕜] F)} (hK : IsComplete K) :
    D f K ⊆ { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have P : ∀ {n : ℕ}, (0 : ℝ) < n := fun {n : ℕ} => by
    intro n hn
    rcases hn with ⟨n, hn⟩
    exact ⟨n, hn⟩

For theorem:
theorem D_subset_differentiable_set {K : Set (E →L[𝕜] F)} (hK : IsComplete K) :
    D f K ⊆ { x | DifferentiableAt 𝕜 f x ∧ fderiv 𝕜 f x ∈ K } 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp_rw [differentiableWithinAt_Ici_of_isComplete hK]
  refine measurableSet_of_differentiableWithinAt_Ici_of_isComplete hK?_
  refine measurableSet_of_differentiableWithinAt_Ici_of_isComplete hK (fun x hx =>?_)?_
  refine measurableSet_of_differentiableWithinAt_Ici_of_isComplete hK (fun x hx =>?_)?_
  refine measurableSet_of_differentiableWithinAt_Ici_of_isComplete hK (fun x hx =>?_)?_
  refine measurableSet_of_differentiableWithinAt_Ici_of_isComplete hK (fun x hx =>?_)?_
  refine measurableSet_of_differentiableWithinAt_Ici_of_isComplete hK (fun x hx =>?_)?_
  refine measurableSet_of_differentiableWithinAt_Ici_of_isComplete hK (fun x hx =>?_)?_
  refine measurableSet_of_differentiableWithinAt_Ici_of_isComplete hK (fun x hx =>?_)?_
  refine measurableSet_of_differentiableWithinAt_Ici_of_isComplete hK (fun x hx =>?_)?_
  refine measurableSet_of_differentiableWithinAt_Ici_of_isComplete hK (fun x hx =>?_)?_
  refine measurableSet_of_differentiableWithinAt_Ici_of_isComplete hK (fun x h

For theorem:
theorem measurableSet_of_differentiableWithinAt_Ici_of_isComplete {K : Set F} (hK : IsComplete K) :
    MeasurableSet { x | DifferentiableWithinAt ℝ f (Ici x) x ∧ derivWithin f (Ici x) x ∈ K } := by
      simp only [differentiable_set_eq_D K hK, D]
Attempt failure.

Working on Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean - 2024-08-20 14:01:47.047100.
---0/3204---
Verifying proof:
:= by
  refine taylor_approx_two_segment hv hw?_
  refine taylor_approx_two_segment hv hw?_
  · simp only [add_sub_cancel_right, smul_add, smul_smul, smul_sub, smul_smul, smul_sub,
      smul_sub, smul_sub, smul_smul, smul_smul, smul_smul, smul_smul, smul_add]
  · simp only [smul_add, smul_add, smul_sub, smul_smul, smul_sub, smul_sub, smul_sub, smul_sub,
      smul_smul, smul_sub, smul_smul, smul_sub, smul_sub, smul_smul, smul_smul, smul_sub,
      smul_sub, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_sub,
      smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_sub,
      smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_sub,
      smul_sub, smul_smul, smul_smul, smul_add, smul_smul, smul_sub, smul_smul, smul_smul,
      smul_add, smul_smul, smul_add, smul_add, smul_add, smul_smul, smul_smul, smul_sub]
  · simp only [smul_add, smul_add, smul_add, smul_smul, smul_sub, smul_sub, smul_sub, smul_sub,
      smul_smul, 

For theorem:
theorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v ∈ interior s)
    (hw : x + v + w ∈ interior s) :
    (fun h : ℝ => f (x + h • v + h • w)
        - f (x + h • v) - h • f' x w - h ^ 2 • f'' v w - (h ^ 2 / 2) • f'' w w) =o[𝓝[>] 0]
      fun h => h ^ 2 := by
      refine IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun ε εpos => ?_) (isBigO_const_mul_self ((‖v‖ + ‖w‖) * ‖w‖) _ _)
      rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine taylor_approx_two_segment hv hw?_
  refine taylor_approx_two_segment hv hw?_
  · simp only [add_sub_cancel_right, smul_add, smul_smul, smul_sub, smul_smul, smul_sub,
      smul_sub, smul_sub, smul_smul, smul_smul, smul_smul, smul_smul, smul_add]
  · simp only [smul_add, smul_add, smul_sub, smul_smul, smul_sub, smul_sub, smul_sub, smul_sub,
      smul_smul, smul_sub, smul_smul, smul_sub, smul_sub, smul_smul, smul_smul, smul_sub,
      smul_sub, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_sub,
      smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_sub,
      smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_sub,
      smul_sub, smul_smul, smul_smul, smul_add, smul_smul, smul_sub, smul_smul, smul_smul,
      smul_add, smul_smul, smul_add, smul_add, smul_add, smul_smul, smul_smul, smul_sub]
  · simp only [smul_add, smul_add, smul_add, smul_smul, smul_sub, smul_sub, smul_sub, smul_sub,
      smul_smul, 

For theorem:
theorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v ∈ interior s)
    (hw : x + v + w ∈ interior s) :
    (fun h : ℝ => f (x + h • v + h • w)
        - f (x + h • v) - h • f' x w - h ^ 2 • f'' v w - (h ^ 2 / 2) • f'' w w) =o[𝓝[>] 0]
      fun h => h ^ 2 := by
      refine IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun ε εpos => ?_) (isBigO_const_mul_self ((‖v‖ + ‖w‖) * ‖w‖) _ _)
      rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine s_conv.second_derivative_within_at_symmetric hne hf fun x hx =>?_
  refine s_conv.second_derivative_within_at_symmetric hne (fun x hx =>?_) hne
  refine s_conv.second_derivative_within_at_symmetric hne (fun x hx =>?_) hne
  refine s_conv.second_derivative_with

For theorem:
theorem Convex.second_derivative_within_at_symmetric {s : Set E} (s_conv : Convex ℝ s)
    (hne : (interior s).Nonempty) {f : E → F} {f' : E → E →L[ℝ] F} {f'' : E →L[ℝ] E →L[ℝ] F}
    (hf : ∀ x ∈ interior s, HasFDerivAt f (f' x) x) {x : E} (xs : x ∈ s)
    (hx : HasFDerivWithinAt f' f'' (interior s) x) (v w : E) : f'' v w = f'' w v := by
    rcases hne with ⟨y, hy⟩
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine taylor_approx_two_segment hv hw?_
  refine taylor_approx_two_segment hv hw?_
  · simp only [add_sub_cancel_right, smul_add, smul_smul, smul_sub, smul_smul, smul_sub,
      smul_sub, smul_sub, smul_smul, smul_smul, smul_smul, smul_smul, smul_add]
  · simp only [smul_add, smul_add, smul_sub, smul_smul, smul_sub, smul_sub, smul_sub, smul_sub,
      smul_smul, smul_sub, smul_smul, smul_sub, smul_sub, smul_smul, smul_smul, smul_sub,
      smul_sub, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_sub,
      smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_sub,
      smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_smul, smul_sub,
      smul_sub, smul_smul, smul_smul, smul_add, smul_smul, smul_sub, smul_smul, smul_smul,
      smul_add, smul_smul, smul_add, smul_add, smul_add, smul_smul, smul_smul, smul_sub]
  · simp only [smul_add, smul_add, smul_add, smul_smul, smul_sub, smul_sub, smul_sub, smul_sub,
      smul_smul, 

For theorem:
theorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v ∈ interior s)
    (hw : x + v + w ∈ interior s) :
    (fun h : ℝ => f (x + h • v + h • w)
        - f (x + h • v) - h • f' x w - h ^ 2 • f'' v w - (h ^ 2 / 2) • f'' w w) =o[𝓝[>] 0]
      fun h => h ^ 2 := by
      refine IsLittleO.trans_isBigO
    (isLittleO_iff.2 fun ε εpos => ?_) (isBigO_const_mul_self ((‖v‖ + ‖w‖) * ‖w‖) _ _)
      rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, isLittleO_iff] at hx
Attempt failure.

Working on Mathlib/Analysis/Calculus/Implicit.lean - 2024-08-20 14:02:07.188661.
---0/3204---
Verifying proof:
:= by
  rcases hker with ⟨p, hp⟩
  rcases hker with ⟨p, hp⟩
  rcases hker with ⟨p, hp⟩
  rcases hker with ⟨p, hp⟩
  rcases hf.implicitFunctionOfComplemented_of_hasStrictFunctionOfComplemented hker with
    ⟨p, hp⟩
  refine (hf.implicitFunctionOfComplemented_iff_implicitFunctionOfComplement

For theorem:
theorem map_implicitFunctionOfComplemented_eq (hf : HasStrictFDerivAt f f' a) (hf' : range f' = ⊤)
    (hker : (ker f').ClosedComplemented) :
    ∀ᶠ p : F × ker f' in 𝓝 (f a, 0),
      f (hf.implicitFunctionOfComplemented f f' hf' hker p.1 p.2) = p.1 
Attempt failure.

Working on Mathlib/Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean - 2024-08-20 14:02:18.572734.
---0/3204---
Verifying proof:
:= by
  refine surjOn_closedBall_of_nonlinearRightInverse_closedBall f f'symm.nonlinearRightInverse?_
  refine surjOn_closedBall_of_nonlinearRightInverse f'symm.nonlinearRightInverse?_?_
  · rintro x ⟨y, hy, rfl⟩
    exact hf.nonlinearRightInverse_of_nonlinearRightInverse_closedBall_subset_closedBall hy hε
  · rintro x ⟨hxs, hxy⟩
    exact hf.nonlinearRightInverse_of_nonlinearRightInverse_closedBall_subset_closedBall hε
  · exact hf.nonlinearRightInverse_closedBall_subset_closedBall hε
  · exact hf.nonlinearRightInverse_of_nonlinearRightInverse_closedBall_subset_closedBall hε
  · exact hf.nonlinearRightInverse_of_nonlinearRightInverse_closedBall_subset_closedBall hε
  · exact hf.nonlinearRightInverse_of_nonlinearRightInverse_closedBall_subset_closedBall hε
  · exact hf.nonlinearRightInverse_of_nonlinearRightInverse_closedBall_subset_closedBall hε
  · exact hf.nonlinearRightInverse_of_nonlinearRightInverse_closedBall_subset_closedBall hε
  · exact hf.nonlinearRightInverse_closedBal

For theorem:
theorem surjOn_closedBall_of_nonlinearRightInverse (hf : ApproximatesLinearOn f f' s c)
    (f'symm : f'.NonlinearRightInverse) {ε : ℝ} {b : E} (ε0 : 0 ≤ ε) (hε : closedBall b ε ⊆ s) :
    SurjOn f (closedBall b ε) (closedBall (f b) (((f'symm.nnnorm : ℝ)⁻¹ - c) * ε)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply continuousOn_iff_continuous_restrict.1 hf.continuousOn
  refine continuousOn_iff_continuousAt.2 fun x hx =>?_
  refine continuousWithinAt_of_continuousWithinAt_nhds (fun x hx =>?_)?_
  · rintro _ ⟨y, hy, rfl⟩
    exact ⟨y, hy, rfl⟩
  · rintro _ ⟨y, hy, rfl⟩
    exact ⟨y, hy, rfl⟩

For theorem:
theorem inverse_continuousOn (hf : ApproximatesLinearOn f (f' : E →L[𝕜] F) s c)
    (hc : Subsingleton E ∨ c < N⁻¹) : ContinuousOn (hf.toPartialEquiv hc).symm (f '' s) 
Attempt failure.

Working on Mathlib/Analysis/Calculus/InverseFunctionTheorem/ContDiff.lean - 2024-08-20 14:02:28.893197.
---0/3204---
Verifying proof:
:= by
  have : HasFDerivAt 𝕂 n f a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf.localInverse hf' hn
  have : HasFDerivAt 𝕂 n f' a := hf'.hasFDerivAt.comp_hasFDerivAt hn
  

For theorem:
theorem to_localInverse {n : ℕ∞} (hf : ContDiffAt 𝕂 n f a)
    (hf' : HasFDerivAt f (f' : E →L[𝕂] F) a) (hn : 1 ≤ n) :
    ContDiffAt 𝕂 n (hf.localInverse hf' hn) (f a) 
Attempt failure.

Working on Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean - 2024-08-20 14:02:31.411564.
---0/3204---
Verifying proof:
:= by
  induction' n with n ih generalizing n with n ih generalizing n with n ih
  · rw [iteratedDeriv_eq_iteratedFDeriv, iteratedFDeriv_eq_iteratedFDeriv, iteratedFDeriv_eq_iteratedFDeriv,
      iteratedFDeriv_eq_iteratedFDeriv, iteratedFDeriv_eq_iteratedFDeriv, iteratedFDeriv_eq_iteratedFDeriv,
    iteratedFDeriv_eq_iteratedFDeriv, iteratedFDeriv_eq_iteratedFDeriv, iteratedFDeriv_eq_iteratedFDeriv,
    iteratedFDeriv_eq_iteratedFDeriv, iteratedFDeriv_eq_iteratedFDeriv, iteratedFDeriv_eq_iteratedFDeriv,
    iteratedFDeriv_const_smul, iteratedFDeriv_const_smul, iteratedFDeriv_neg_apply,
    iteratedFDeriv_eq_iteratedFDeriv_smul, iteratedFDeriv_const_smul, iteratedFDeriv_const_smul,
    iteratedFDeriv_const_smul, iteratedFDeriv_const_smul, iteratedFDeriv_neg_apply,
    iteratedFDeriv_const_smul, iteratedFDeriv_const_smul, iteratedFDeriv_neg_apply,
    iteratedFDeriv_const_smul, iteratedFDeriv_const_smul, iteratedFDeriv_neg_apply,
    iteratedFDeriv_const_smul, iteratedFDeriv_const_smul, iteratedFDeriv_const_

For theorem:
lemma iteratedDeriv_comp_neg (n : ℕ) (f : 𝕜 → F) (a : 𝕜) :
    iteratedDeriv n (fun x ↦ f (-x)) a = (-1 : 𝕜) ^ n • iteratedDeriv n f (-a) 
Attempt failure.

Working on Mathlib/Analysis/Calculus/LHopital.lean - 2024-08-20 14:02:34.959704.
---0/3204---
Verifying proof:
:= by
  have hff' : ∀ᶠ x in atTop, HasDerivAt (f' x) (f' x) x := by
    filter_upwards [hff', hgg', hg'] with x hx₁ hx₂
    simp only [hx₁, hx₂, hx₃, hx₂, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₃, hx₂, hx₃, hx₃

For theorem:
theorem lhopital_zero_atTop (hff' : ∀ᶠ x in atTop, HasDerivAt f (f' x) x)
    (hgg' : ∀ᶠ x in atTop, HasDerivAt g (g' x) x) (hg' : ∀ᶠ x in atTop, g' x ≠ 0)
    (hftop : Tendsto f atTop (𝓝 0)) (hgtop : Tendsto g atTop (𝓝 0))
    (hdiv : Tendsto (fun x => f' x / g' x) atTop l) : Tendsto (fun x => f x / g x) atTop l 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hff' : ∀ᶠ x in 𝓝[≠] a, HasDerivAt (f' x) (f' x) x := by
    filter_upwards [hff', hgg', hg'] with x hx hx'
    simp only [hx']
    exact (hff'.and hx).mono fun x hx => hx hx'

For theorem:
theorem lhopital_zero_nhds' (hff' : ∀ᶠ x in 𝓝[≠] a, HasDerivAt f (f' x) x)
    (hgg' : ∀ᶠ x in 𝓝[≠] a, HasDerivAt g (g' x) x) (hg' : ∀ᶠ x in 𝓝[≠] a, g' x ≠ 0)
    (hfa : Tendsto f (𝓝[≠] a) (𝓝 0)) (hga : Tendsto g (𝓝[≠] a) (𝓝 0))
    (hdiv : Tendsto (fun x => f' x / g' x) (𝓝[≠] a) l) :
    Tendsto (fun x => f x / g x) (𝓝[≠] a) l 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine lhopital_zero_right_on_Ico (fun x hx => (hff' x hx).hasFDerivAt) (fun x hx =>?_) hcf hcg hcg'
  refine lhopital_zero_right_on_Ico (fun x hx => (hgg' x hx).hasFDerivAt) (fun x hx =>?_)
  · exact (hff' x hx).hasFDerivAt

For theorem:
theorem lhopital_zero_right_on_Ico (hff' : ∀ x ∈ Ioo a b, HasDerivAt f (f' x) x)
    (hgg' : ∀ x ∈ Ioo a b, HasDerivAt g (g' x) x) (hcf : ContinuousOn f (Ico a b))
    (hcg : ContinuousOn g (Ico a b)) (hg' : ∀ x ∈ Ioo a b, g' x ≠ 0) (hfa : f a = 0) (hga : g a = 0)
    (hdiv : Tendsto (fun x => f' x / g' x) (𝓝[>] a) l) :
    Tendsto (fun x => f x / g x) (𝓝[>] a) l 
Attempt failure.

Working on Mathlib/Analysis/Calculus/LagrangeMultipliers.lean - 2024-08-20 14:02:46.942355.
---0/3204---
Verifying proof:
:= by
  refine isLocalExtrOn_of_hasStrictFDerivAt_of_isLocalExtrOn_of_hasStrictFDerivAt_of_isLocalExtrOn?_ hextr
  refine isLocalExtrOn_of_hasStrictFDerivAt_of_hasStrictFDerivAt_of_isLocalExtrOn?_ hextr hf' hf'
  refine isLocalExtrOn_of_hasStrictFDerivAt_of_hasStrictFDerivAt_of_isLocalExtrOn?_ hextr hf' hf' hf'
  refine isLocalExtrOn_of_hasStrictFDerivAt_of_hasStrictFDerivAt_of_isLocalExtrOn?_ hextr hf' hf' hf'
  refine isLocalExtrOn_of_hasStrictFDerivAt_of_hasStrictFDerivAt_of_isLocalExtrOn?_ hextr hf' hf' hf'?_
  refine isLocalExtrOn_of_hasStrictFDerivAt_of_isLocalExtrOn_of_hasStrictFDerivAt_of_isLocalExtrOn?_ hextr hf' hf'?_
  refine isLocalExtrOn_of_hasStrictFDerivAt_of_hasStrictFDerivAt_of_isLocalExtrOn?_ hextr hf' hf' hf'?_
  refine isLocalExtrOn_of_hasStrictFDerivAt_of_hasStrictFDerivAt_of_isLocalExtrOn?_ hextr hf' hf'?_
  refine isLocalExtrOn_of_hasStrictFDerivAt_of_hasStrictFDerivAt_of_isLocalExtrOn?_ hextr hf' hf' hf'?_
  refine isLocalExtrOn_of_hasStrictFDerivAt_of_isLocalExtrOn hext

For theorem:
theorem IsLocalExtrOn.linear_dependent_of_hasStrictFDerivAt {ι : Type*} [Finite ι] {f : ι → E → ℝ}
    {f' : ι → E →L[ℝ] ℝ} (hextr : IsLocalExtrOn φ {x | ∀ i, f i x = f i x₀} x₀)
    (hf' : ∀ i, HasStrictFDerivAt (f i) (f' i) x₀) (hφ' : HasStrictFDerivAt φ φ' x₀) :
    ¬LinearIndependent ℝ (Option.elim' φ' f' : Option ι → E →L[ℝ] ℝ) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_of_isLocalExtrOn_of_hasStrictFDerivAt_of_isLocalExtrOn?_ hextr hf' hφ' hf' hf' hφ' hf' hφ' hf' hφ' hf' hφ' hf' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hφ' hf' hφ' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hf' hφ' hf' hφ' hφ

For theorem:
theorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d {f : E → ℝ} {f' : E →L[ℝ] ℝ}
    (hextr : IsLocalExtrOn φ {x | f x = f x₀} x₀) (hf' : HasStrictFDerivAt f f' x₀)
    (hφ' : HasStrictFDerivAt φ φ' x₀) : ∃ a b : ℝ, (a, b) ≠ 0 ∧ a • f' + b • φ' = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_of_isLocalExtrOn_of_hasStrictFDerivAt_of_isLocalExtrOn?_ hextr hf' hφ' hf' hf' hφ' hf' hφ' hf' hφ' hf' hφ' hf' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hφ' hf' hφ' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hφ' hf' hφ' hf' hφ' hf' hφ' hf' hφ' hφ

For theorem:
theorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d {f : E → ℝ} {f' : E →L[ℝ] ℝ}
    (hextr : IsLocalExtrOn φ {x | f x = f x₀} x₀) (hf' : HasStrictFDerivAt f f' x₀)
    (hφ' : HasStrictFDerivAt φ φ' x₀) : ∃ a b : ℝ, (a, b) ≠ 0 ∧ a • f' + b • φ' = 0 
Attempt failure.

Working on Mathlib/Analysis/Calculus/LocalExtr/Basic.lean - 2024-08-20 14:02:56.845968.
---0/3204---
Verifying proof:
:= by
  ext y
  apply (h.on univ).hasFDerivWithinAt_eq_zero hf.hasFDerivWithinAt

For theorem:
theorem IsLocalMin.hasFDerivAt_eq_zero (h : IsLocalMin f a) (hf : HasFDerivAt f f' a) : f' = 0 
Attempt failure.

Working on Mathlib/Analysis/Calculus/MeanValue.lean - 2024-08-20 14:03:00.066733.
---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne y 0 with (rfl | hne)
  · simp only [norm_zero, sub_zero]
    exact norm_image_sub_le_of_norm_hasFDerivWithin_le hf bound xs ys
  · rw [norm_sub_rev]
    exact norm_image_sub_le_of_norm_hasFDerivWithin_le hf bound ys xs ys
  · rw [norm_sub_rev]
    exact norm_image_sub_le_of_norm_hasFDerivWithin_le hf bound y ys xs ys
  · rw [norm_sub_rev]
    exact norm_image_sub_le_of_norm_hasFDerivWithin_le (hf y ys) (hf y ys)
  · rw [norm_sub_rev]
    exact hf y ys

For theorem:
theorem norm_image_sub_le_of_norm_hasFDerivWithin_le
    (hf : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) (bound : ∀ x ∈ s, ‖f' x‖ ≤ C) (hs : Convex ℝ s)
    (xs : x ∈ s) (ys : y ∈ s) : ‖f y - f x‖ ≤ C * ‖y - x‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let h x := (g b - g a) * f x - (f b - f a) * g x

For theorem:
theorem exists_ratio_hasDerivAt_eq_ratio_slope :
    ∃ c ∈ Ioo a b, (g b - g a) * f' c = (f b - f a) * g' c 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : ∀ x, ‖fderiv 𝕜 f x‖₊ = ‖fderiv 𝕜 f x‖₊ := fun x => by
    intro x
    rw [← fderivWithin_univ, ← fderivWithin_univ]
    exact fun x => (hf.fderivWithin_right hx).hasFDerivWithinAt
  have : ∀ x, ‖fderivWithin 𝕜 f x‖₊ = ‖fderiv 𝕜 f x‖₊ := fun x => by
    intro x
    rw [← fderivWithin_univ, ← fderivWithin_univ, ← fderivWithin_univ]
    exact fun x => (hf.fderivWithin_right hx).hasFDerivWithinAt
  have : ∀ x, ‖fderivWithin 𝕜 f x‖₊ = ‖fderiv 𝕜 f x‖₊ := fun x => by
    intro x
    rw [← fderivWithin_univ, ← fderivWithin_univ, ← fderivWithin_univ]
    exact fun x => (hf.fderivWithin_right hx).hasFDerivWithinAt
  have : ∀ x, ‖fderiv 𝕜 f x‖₊ = ‖fderiv 𝕜 f x‖₊ := fun x => by
    intro x
    simp only [fderivWithin_univ]
    exact fun x => (hf.fderivWithin_right hx).hasFDerivWithinAt
  have : ∀ x, ‖fderiv 𝕜 f x‖₊ = ‖fderiv 𝕜 f x‖₊ := fun x => by
      intro x
      rw [← fderivWithin_uni

For theorem:
theorem _root_.lipschitzWith_of_nnnorm_fderiv_le
    {E : Type*} [NormedAddCommGroup E] [NormedSpace 𝕜 E] {f : E → G}
    {C : ℝ≥0} (hf : Differentiable 𝕜 f)
    (bound : ∀ x, ‖fderiv 𝕜 f x‖₊ ≤ C) : LipschitzWith C f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine lipschitzOnWith_of_nnnorm_hasDerivWithin_le hs bound fun x hx =>?_
  refine lipschitzOnWith_of_nnnorm_hasDerivWithin_le (fun x hx => (hf x hx).hasFDerivWithinAt) fun x hx =>?_
  refine lipschitzOnWith_of_nnnorm_hasDerivWithin_le (fun x hx => (hf x hx).hasFDerivWithinAt) fun x hx =>?_
  refine lipschitzOnWith_of_nnnorm_hasDerivWithin_le (fun x hx => (hf x hx).hasFDerivWithinAt) fun x hx =>?_
  refine lipschitzOnWith_of_nnnorm_hasDerivWithin_le (fun x hx => (hf x hx).hasFDerivWithinAt) fun x hx =>?_
  refine lipschitzOnWith_of_nnnorm_hasDerivWithin_le (fun x hx => (hf x hx).hasFDerivWithinAt) fun x hx =>?_
  refine lipschitzOnWith_of_nnnorm_hasDerivWithin_le (fun x hx => (hf x hx).hasFDerivWithinAt) fun x hx =>?_
  refine lipschitzOnWith_of_nnnorm_hasDerivWithin_le (fun x hx => (hf x hx).hasFDerivWithinAt) fun x hx =>?_
  refine lipschitzOnWith_of_nnnorm_hasDerivWithin_le (fun x hx => (hf x hx).hasFDerivWithinAt) fun x hx =>?_
  refine lipschitzOnWith_of_nnnorm_hasDerivWithin_le (fun x 

For theorem:
theorem lipschitzOnWith_of_nnnorm_hasDerivWithin_le {C : ℝ≥0} (hs : Convex ℝ s)
    (hf : ∀ x ∈ s, HasDerivWithinAt f (f' x) s x) (bound : ∀ x ∈ s, ‖f' x‖₊ ≤ C) :
    LipschitzOnWith C f s 
Attempt failure.

---0/3204---
Verifying proof:
:=
  lipschitz_on_univ.1 <|
    convex_univ.2 <|
      convex_univ.2 <|
      convex_univ.2 <|
        convex_univ.2 <|
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

For theorem:
theorem _root_.lipschitzWith_of_nnnorm_deriv_le {C : ℝ≥0} (hf : Differentiable 𝕜 f)
    (bound : ∀ x, ‖deriv f x‖₊ ≤ C) : LipschitzWith C f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne D ∞ with (rfl | hD)
  · simp only [mem_interior_iff_mem_nhds, not_le, mem_setOf_eq, not_and, not_false_eq_true,
      mem_interior_iff_mem_nhds, not_false_eq_true] at hD
    simp only [mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds, not_false_eq_true] at hD
    simp only [mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds,
      mem_interior_iff_mem_nhds, not_false_eq_true] at hD
    simp only [mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds,
      mem_interior_iff_mem_nhds, not_false_eq_true] at hD
    simp only [mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds,
      mem_interior_iff_mem_nhds, not_false_eq_true] at hD
    simp only [mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds,
      mem_interior_iff_mem_nhds, not_false_eq_true] at hD
    simp only [mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds,
      mem_interior_i

For theorem:
theorem Convex.mul_sub_lt_image_sub_of_lt_deriv {D : Set ℝ} (hD : Convex ℝ D) {f : ℝ → ℝ}
    (hf : ContinuousOn f D) (hf' : DifferentiableOn ℝ f (interior D)) {C}
    (hf'_gt : ∀ x ∈ interior D, C < deriv f x) :
    ∀ᵉ (x ∈ D) (y ∈ D), x < y → C * (y - x) < f y - f x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne a b with (rfl | hab)
  · simp only [hasDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_iff_hasFDerivWithinAt,
      hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_iff_hasFDerivWithinAt,
      hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_iff_hasFDerivWithinAt,
      hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_iff_hasFDerivWithinAt,
      hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_iff_hasFDerivWithinAt,
      hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_iff_hasFDerivWithinAt,
      hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_iff_hasFDerivWithinAt,
      hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_iff_hasFDerivWithinAt,
      hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_iff_hasFDerivWithinAt,
      hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_iff_hasFDerivWithinAt,
      hasFDerivWithinAt_iff_hasFDerivWithinAt, hasFDerivWithinAt_iff_hasFDerivWithinAt,
 

For theorem:
theorem eq_of_has_deriv_right_eq (derivf : ∀ x ∈ Ico a b, HasDerivWithinAt f (f' x) (Ici x) x)
    (derivg : ∀ x ∈ Ico a b, HasDerivWithinAt g (f' x) (Ici x) x) (fcont : ContinuousOn f (Icc a b))
    (gcont : ContinuousOn g (Icc a b)) (hi : f a = g a) : ∀ y ∈ Icc a b, f y = g y 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine image_le_of_liminf_slope_right_le_deriv_boundary hf hB hB' fun x hx =>?_
  refine image_le_of_liminf_slope_right_le_deriv_boundary (fun x hx =>?_) (fun x hx =>?_)
  refine image_le_of_liminf_slope_right_le_deriv_boundary (fun x hx =>?_) (fun x hx =>?_)
  refine image_le_of_liminf_slope_right_le_deriv_boundary (fun x hx =>?_) (fun x hx =>?_)?_
  refine image_le_of_liminf_slope_right_le_deriv_boundary (fun x hx =>?_) (fun x hx =>?_)
  refine image_le_of_liminf_slope_right_le_deriv_boundary (fun x hx =>?_) (fun x hx =>?_)
  refine image_le_of_liminf_slope_right_le_deriv_b

For theorem:
theorem image_le_of_liminf_slope_right_le_deriv_boundary {f : ℝ → ℝ} {a b : ℝ}
    (hf : ContinuousOn f (Icc a b)) {B B' : ℝ → ℝ} (ha : f a ≤ B a) (hB : ContinuousOn B (Icc a b))
    (hB' : ∀ x ∈ Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)
        (bound : ∀ x ∈ Ico a b, ∀ r, B' x < r → ∃ᶠ z in 𝓝[>] x, slope f x z < r) :
    ∀ ⦃x⦄, x ∈ Icc a b → f x ≤ B x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine norm_image_sub_le_of_norm_deriv_le_segment' (fun x hx =>?_) bound x hx
  refine norm_image_sub_le_of_norm_deriv_le_segment' (fun x hx =>?_) (fun x hx =>?_) bound x hx
  have : ∀ x ∈ Ico a b, ‖f' x‖ ≤ C := by
    intro x hx
    have : ∀ x ∈ Ico a b, ‖f' x‖ ≤ C := by
      intro x hx
      simp only [norm_image_sub_le_of_norm_deriv_le_segment' bound x hx]
    exact fun x hx => (hf x hx).hasDerivWithinAt
  have : ∀ x ∈ Ico a b, ‖f' x‖ ≤ C := by
    intro x hx
    have : ∀ x ∈ Ico a b, ‖f' x‖ ≤ C := by
    intro x hx
    have : ∀ x ∈ Ico a b, ‖f' x‖ ≤ C := by
    intro x hx
    have : ∀ x ∈ Ico a b, ‖f' x‖ ≤ C := fun x hx => (hf x hx).hasDerivWithinAt
    have : ∀ x ∈ Ico a b, ‖f' x‖ ≤ C := by
    intro x hx
    have : ∀ x ∈ Ico a b, ‖f' x‖ ≤ C := fun x hx => (hf x hx).hasDerivWithinAt
    have : ∀ x ∈ Ico a b, ‖f' x‖ ≤ C := by
    intro x hx
    have : ∀ x ∈ Ico a b, ‖f' x‖ ≤ C := by
      intro

For theorem:
theorem norm_image_sub_le_of_norm_deriv_le_segment' {f' : ℝ → E} {C : ℝ}
    (hf : ∀ x ∈ Icc a b, HasDerivWithinAt f (f' x) (Icc a b) x)
    (bound : ∀ x ∈ Ico a b, ‖f' x‖ ≤ C) : ∀ x ∈ Icc a b, ‖f x - f a‖ ≤ C * (x - a) 
Attempt failure.

Working on Mathlib/Analysis/Calculus/Monotone.lean - 2024-08-20 14:03:58.522632.
---0/3204---
Verifying proof:
:= by
  filter_upwards [hf.stieltjesFunction.ae_hasDerivAt, hf.ae_hasDerivAt] with x hx
  simp only [hx, Pi.zero_apply, ENNReal.zero_toReal, ENNReal.zero_toReal]

For theorem:
theorem Monotone.ae_hasDerivAt {f : ℝ → ℝ} (hf : Monotone f) :
    ∀ᵐ x, HasDerivAt f (rnDeriv hf.stieltjesFunction.measure volume x).toReal x := by
    filter_upwards [hf.stieltjesFunction.ae_hasDerivAt,
    hf.countable_not_continuousAt.ae_not_mem volume] with x hx h'x
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply ae_of_mem_of_ae_of_mem_inter_Ioo
  refine ae_of_ae_of_ae_of_mem_inter_Ioo fun x hx =>?_
  refine ae_of_ae_restrict_of_ae_restrict_of_ae_restrict_of_ae_restrict_of_ae_restrict_compl?_?_?_?_ <;>
    simp only [ae_restrict_iff' measurableSet_Ioo, ae_restrict_iff' measurableSet_Ioo]

For theorem:
theorem MonotoneOn.ae_differentiableWithinAt_of_mem {f : ℝ → ℝ} {s : Set ℝ} (hf : MonotoneOn f s) :
    ∀ᵐ x, x ∈ s → DifferentiableWithinAt ℝ f s x := by
    apply ae_of_mem_of_ae_of_mem_inter_Ioo
Attempt failure.

Working on Mathlib/Analysis/Calculus/ParametricIntegral.lean - 2024-08-20 14:04:03.609758.
---0/3204---
Verifying proof:
:= by
  have : ∀ x ∈ ball x₀ ε, AEStronglyMeasurable (F x) μ := fun x hx =>
    (hF_meas x hx).hasFDerivAt.comp_aestronglyMeasurable (hF_meas x hx).hasFDerivAt
  have : ∀ x ∈ ball x₀ ε, AEStronglyMeasurable (F x) μ := fun x hx =>
    (hF_meas x hx).hasFDerivAt.comp_aestronglyMeasurable (hF_meas x hx).hasFDerivAt
  have : ∀ x ∈ ball x₀ ε, AEStronglyMeasurable (F x) μ := fun x hx =>
    (hF_meas x hx).hasFDerivAt.comp_aestronglyMeasurable (hF_meas x hx).hasFDerivAt

For theorem:
theorem hasFDerivAt_integral_of_dominated_loc_of_lip' {F' : α → H →L[𝕜] E} (ε_pos : 0 < ε)
    (hF_meas : ∀ x ∈ ball x₀ ε, AEStronglyMeasurable (F x) μ) (hF_int : Integrable (F x₀) μ)
    (hF'_meas : AEStronglyMeasurable F' μ)
    (h_lipsch : ∀ᵐ a ∂μ, ∀ x ∈ ball x₀ ε, ‖F x a - F x₀ a‖ ≤ bound a * ‖x - x₀‖)
    (bound_integrable : Integrable (bound : α → ℝ) μ)
    (h_diff : ∀ᵐ a ∂μ, HasFDerivAt (F · a) (F' a) x₀) :
    Integrable F' μ ∧ HasFDerivAt (fun x ↦ ∫ a, F x a ∂μ) (∫ a, F' a ∂μ) x₀ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : ∀ x ∈ ball x₀ ε, AEStronglyMeasurable (F x) μ := fun x hx =>
    (hF_meas x hx).hasFDerivAt.comp_aestronglyMeasurable (hF_meas x hx).hasFDerivAt
  have : ∀ x ∈ ball x₀ ε, AEStronglyMeasurable (F x) μ := fun x hx =>
    (hF_meas x hx).hasFDerivAt.comp_aestronglyMeasurable (hF_meas x hx).hasFDerivAt
  have : ∀ x ∈ ball x₀ ε, AEStronglyMeasurable (F x) μ := fun x hx =>
    (hF_meas x hx).hasFDerivAt.comp_aestronglyMeasurable (hF_meas x hx).hasFDerivAt

For theorem:
theorem hasFDerivAt_integral_of_dominated_loc_of_lip' {F' : α → H →L[𝕜] E} (ε_pos : 0 < ε)
    (hF_meas : ∀ x ∈ ball x₀ ε, AEStronglyMeasurable (F x) μ) (hF_int : Integrable (F x₀) μ)
    (hF'_meas : AEStronglyMeasurable F' μ)
    (h_lipsch : ∀ᵐ a ∂μ, ∀ x ∈ ball x₀ ε, ‖F x a - F x₀ a‖ ≤ bound a * ‖x - x₀‖)
    (bound_integrable : Integrable (bound : α → ℝ) μ)
    (h_diff : ∀ᵐ a ∂μ, HasFDerivAt (F · a) (F' a) x₀) :
    Integrable F' μ ∧ HasFDerivAt (fun x ↦ ∫ a, F x a ∂μ) (∫ a, F' a ∂μ) x₀ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F x) μ :=
    hasDerivAt_integral_of_dominated_loc_of_lip' ε_pos hF_meas hF_int hF'_meas hF_int hF_int
  have : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F' x) μ :=
    hasDerivAt_integral_of_dominated_loc_of_lip' ε_pos hF_meas hF_int hF_int hF_int hF_int
  have : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F' x) μ :=
    hasDerivAt_integral_of_dominated_loc_of_dominated_loc_of_lip' ε_pos hF_meas hF_int hF_int
  have : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F' x) μ :=
    hasDerivAt_integral_of_dominated_loc_of_dominated_loc_of_lip' ε_pos hF_meas hF_int hF_int
  have : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F' x) μ :=
    hasDerivAt_integral_of_dominated_loc_of_dominated_loc_of_lip' ε_pos hF_meas hF_int hF_int
  have : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F' x) μ :=
    hasDerivAt_integral_of_dominated_loc_of_dominated_loc_of_lip' ε_pos hF_meas hF_int
  have : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F' x) μ 

For theorem:
theorem hasDerivAt_integral_of_dominated_loc_of_lip {F' : α → E} (ε_pos : 0 < ε)
    (hF_meas : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F x) μ) (hF_int : Integrable (F x₀) μ)
    (hF'_meas : AEStronglyMeasurable F' μ)
    (h_lipsch : ∀ᵐ a ∂μ, LipschitzOnWith (Real.nnabs <| bound a) (F · a) (ball x₀ ε))
    (bound_integrable : Integrable (bound : α → ℝ) μ)
    (h_diff : ∀ᵐ a ∂μ, HasDerivAt (F · a) (F' a) x₀) :
    Integrable F' μ ∧ HasDerivAt (fun x ↦ ∫ a, F x a ∂μ) (∫ a, F' a ∂μ) x₀ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine hasFDerivAt_integral_of_dominated_loc_of_lip' ε_pos hF_meas hF_int hF_int?_
  have : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F x₀) μ :=
    hasFDerivAt_integral_of_dominated_loc_of_lip' ε_pos hF_meas hF_int hF_int hF_int
  have : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F x₀) μ :=
    hasFDerivAt_integral_of_dominated_loc_of_lip' ε_pos hF_meas hF_int hF_int hF_int
  have : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F x₀) μ :=
    hasFDerivAt_integral_of_dominated_loc_of_lip' ε_pos hF_meas hF_int hF_int hF_int
  have : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F x₀) μ :=
    hasFDerivAt_integral_of_dominated_loc_of_lip' ε_pos hF_meas hF_int hF_int hF_int
  have : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F x₀) μ :=
    hasFDerivAt_integral_of_dominated_loc_of_lip' ε_pos hF_meas hF_int hF_int hF_int
  have : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F x₀) μ :=
    hasFDerivAt_integral_of_dominated_loc_of_lip' ε_pos hF_meas hF_int hF_int hF_int
  have

For theorem:
theorem hasFDerivAt_integral_of_dominated_loc_of_lip {F' : α → H →L[𝕜] E}
    (ε_pos : 0 < ε) (hF_meas : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (F x) μ)
    (hF_int : Integrable (F x₀) μ) (hF'_meas : AEStronglyMeasurable F' μ)
    (h_lip : ∀ᵐ a ∂μ, LipschitzOnWith (Real.nnabs <| bound a) (F · a) (ball x₀ ε))
    (bound_integrable : Integrable (bound : α → ℝ) μ)
    (h_diff : ∀ᵐ a ∂μ, HasFDerivAt (F · a) (F' a) x₀) :
    Integrable F' μ ∧ HasFDerivAt (fun x ↦ ∫ a, F x a ∂μ) (∫ a, F' a ∂μ) x₀ 
Attempt failure.

Working on Mathlib/Analysis/Calculus/Rademacher.lean - 2024-08-20 14:04:22.601035.
---0/3204---
Verifying proof:
:= by
  refine hasFDerivAt_of_hasLineDerivAt_of_hasLineDerivAt_of_closure_subset_closure?_ hs
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine h

For theorem:
theorem hasFderivAt_of_hasLineDerivAt_of_closure {f : E → F}
    (hf : LipschitzWith C f) {s : Set E} (hs : sphere 0 1 ⊆ closure s)
    {L : E →L[ℝ] F} {x : E} (hL : ∀ v ∈ s, HasLineDerivAt ℝ f (L v) x v) :
    HasFDerivAt f L x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine hasFDerivAt_of_hasLineDerivAt_of_hasLineDerivAt_of_closure_subset_closure?_ hs
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine hasFDerivAt_of_hasLineDerivAt_of_closure_sphere_subset_closure?_ hs hL?_
  refine h

For theorem:
theorem hasFderivAt_of_hasLineDerivAt_of_closure {f : E → F}
    (hf : LipschitzWith C f) {s : Set E} (hs : sphere 0 1 ⊆ closure s)
    {L : E →L[ℝ] F} {x : E} (hL : ∀ v ∈ s, HasLineDerivAt ℝ f (L v) x v) :
    HasFDerivAt f L x 
Attempt failure.

Working on Mathlib/Analysis/Calculus/SmoothSeries.lean - 2024-08-20 14:04:32.843176.
---0/3204---
Verifying proof:
:= by
  refine contDiff_tsum_of_eventually_eventually_eventually_eventually_of_summable hf h'f fun k hk =>?_
  rcases eq_or_ne k 0 with (rfl | hk)
  · simp only [eventually_of_forall fun k hk =>?_, fun k hk =>?_⟩
    simp only [eventually_of_forall fun k =>?_⟩
    simp only [eventually_atTop, eventually_const, not_false_iff] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_iff_exists_mem] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_atTop] at hk
    simp only [eventually_atTop] at hk
    exact

For theorem:
theorem contDiff_tsum_of_eventually (hf : ∀ i, ContDiff 𝕜 N (f i))
    (hv : ∀ k : ℕ, (k : ℕ∞) ≤ N → Summable (v k))
    (h'f :
      ∀ k : ℕ,
        (k : ℕ∞) ≤ N →
          ∀ᶠ i in (Filter.cofinite : Filter α), ∀ x : E, ‖iteratedFDeriv 𝕜 k (f i) x‖ ≤ v k i) :
    ContDiff 𝕜 N fun x => ∑' i, f i x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine summable_of_summable_hasFDerivAt_of_isPreconnected_of_summable_hasFDerivAt_of_isPreconnected hu h's hf'?_
  refine summable_of_summable_hasFDerivAt_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_fderiv hu hs h's?_?_?_
  · refine summable_hasFDerivAt_of_summable_hasFDerivAt_of_isPreconnected_of_fderiv hu hf'?_?_?_?_
    · exact (hf n x hx).hasFDerivAt
  · exact (hf n x hx).hasFDerivAt

For theorem:
theorem summable_of_summable_hasFDerivAt_of_isPreconnected (hu : Summable u) (hs : IsOpen s)
    (h's : IsPreconnected s) (hf : ∀ n x, x ∈ s → HasFDerivAt (f n) (f' n x) x)
    (hf' : ∀ n x, x ∈ s → ‖f' n x‖ ≤ u n) (hx₀ : x₀ ∈ s) (hf0 : Summable (f · x₀))
    (hx : x ∈ s) : Summable fun n => f n x 
Attempt failure.

Working on Mathlib/Analysis/Calculus/TangentCone.lean - 2024-08-20 14:04:42.702428.
---0/3204---
Verifying proof:
:=
  hs.prod hs ht

For theorem:
theorem UniqueDiffWithinAt.prod {t : Set F} {y : F} (hs : UniqueDiffWithinAt 𝕜 s x)
    (ht : UniqueDiffWithinAt 𝕜 t y) : UniqueDiffWithinAt 𝕜 (s ×ˢ t) (x, y) 
Attempt failure.

Working on Mathlib/Analysis/Calculus/Taylor.lean - 2024-08-20 14:04:47.065781.
---0/3204---
Verifying proof:
:= by
  refine taylor_mean_remainder_lagrange_Icc hx hf hf'?_
  refine taylor_mean_remainder_lagrange_Icc hx hf'?_
  · rw [iteratedDerivWithin_Icc_eq_comp_left]
    exact hf.continuousOn.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt
  · exact hf'.continuousWithinAt.continuousWithinAt


For theorem:
theorem taylor_mean_remainder_lagrange {f : ℝ → ℝ} {x x₀ : ℝ} {n : ℕ} (hx : x₀ < x)
    (hf : ContDiffOn ℝ n f (Icc x₀ x))
    (hf' : DifferentiableOn ℝ (iteratedDerivWithin n f (Icc x₀ x)) (Ioo x₀ x)) :
    ∃ x' ∈ Ioo x₀ x, f x - taylorWithinEval f n (Icc x₀ x) x₀ x =
      iteratedDerivWithin (n + 1) f (Icc x₀ x) x' * (x - x₀) ^ (n + 1) / (n + 1)! 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp_rw [sub_eq_neg_add]
  rw [← neg_one_mul, mul_comm (-1 : ℝ)]
  rw [← neg_one_mul, mul_comm (-1 : ℝ)]
  rw [← neg_one_mul, mul_comm (-1 : ℝ)]

For theorem:
theorem monomial_has_deriv_aux (t x : ℝ) (n : ℕ) :
    HasDerivAt (fun y => (x - y) ^ (n + 1)) (-(n + 1) * (x - t) ^ n) t 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine taylor_mean_remainder_bound_of_continuousOn_iteratedDerivWithin_Icc hab hx hab?_?_
  · simp only [iteratedDerivWithin_Icc_eq_const_apply]
    refine taylor_mean_remainder_bound_of_continuousOn_iteratedDerivWithin_Icc hf hx hy hx hy
    simp only [iteratedDerivWithin_eq_equiv_comp, LinearIsometryEquiv.norm_map,
      LinearIsometryEquiv.norm_map, LinearIsometryEquiv.norm_map, LinearIsometryEquiv.norm_map,
      LinearIsometryEquiv.norm_map, LinearIsometryEquiv.norm_map, LinearIsometryEquiv.norm_map,
      LinearIsometryEquiv.norm_map, LinearIsometryEqu

For theorem:
theorem taylor_mean_remainder_bound {f : ℝ → E} {a b C x : ℝ} {n : ℕ} (hab : a ≤ b)
    (hf : ContDiffOn ℝ (n + 1) f (Icc a b)) (hx : x ∈ Icc a b)
    (hC : ∀ y ∈ Icc a b, ‖iteratedDerivWithin (n + 1) f (Icc a b) y‖ ≤ C) :
    ‖f x - taylorWithinEval f n (Icc a b) a x‖ ≤ C * (x - a) ^ (n + 1) / n ! 
Attempt failure.

Working on Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean - 2024-08-20 14:04:57.111941.
---0/3204---
Verifying proof:
:= by
  rw [uniformCauchySeqOnFilter_iff_uniformCauchySeqOnFilter]
  refine UniformCauchySeqOnFilter.uniformCauchySeqOnFilter_iff.2 fun ε hε =>?_
  rw [uniformCauchySeqOnFilter_iff_uniformCauchySeqOnFilter]
  refine UniformCauchySeqOnFilter.uniformCauchySeqOnFilter_iff.2 fun ε hε =>?_
  rw [uniformCauchySeqOnFilter_iff_uniformCauchySeqOnFilter]
  refine UniformCauchySeqOnFilter.uniformCauchySeqOnFilter_iff.2 fun ε hε =>?_
  rw [uniformCauchySeqOnFilter_iff_uniformCauchySeqOnFilter]
  refine UniformCauchySeqOnFilter.uniformCauchySeqOnFilter_iff_uniformCauchySeqOnFilter]
  refine UniformCauchySeqOnFilter.uniformCauchySeqOnFilter_iff_uniformCauchySeqOnFilter]
  refine UniformCauchySeqOnFilter.uniformCauchySeqOnFilter_iff_uniformCauchySeqOnFilter]
  refine UniformCauchySeqOnFilter.uniformCauchySeqOnFilter_iff_uniformCauchySeqOnFilter]
  refine UniformCauchySeqOnFilter.uniformCauchySeqOnFilter_iff_uniformCauchySeqOnFilter]
  refine UniformCauchySeqOnFilter.uniformCauchySeqOnFilter_iff_uniformCauchySeqOnF

For theorem:
theorem UniformCauchySeqOnFilter.one_smulRight {l' : Filter 𝕜}
    (hf' : UniformCauchySeqOnFilter f' l l') :
    UniformCauchySeqOnFilter (fun n => fun z => (1 : 𝕜 →L[𝕜] 𝕜).smulRight (f' n z)) l l' := by
        rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero,
    Metric.tendstoUniformlyOnFilter_iff] at hf' ⊢
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine hasFDerivAt_of_tendstoLocallyUniformlyOn hs hf' hfg fun n x hx =>?_
  refine hasFDerivAt_iff_tendstoLocallyUniformlyOnFilter.2 fun n x hx =>?_
  refine hasFDerivAt_iff_tendstoLocallyUniformlyOnFilter.2 fun n x hx =>?_
  refine hasFDerivAt_iff_tendstoLocallyUniformlyOnFilter.2 fun n x hx =>?_
  refine hasFDerivAt_iff_tendstoLocallyUniformlyOnFilter.2 fun n x hx =>?_
  refine hasFDerivAt_iff_tendstoLocallyUniformlyOnFilter.2 fun n x hx =>?_
  refine hasFDerivAt_iff_tendstoLocallyUniformlyOnFilter.2 fun n x hx =>?_
  refine hasFDerivAt_of_tendstoLocallyUniformlyOnFilter_of_isOpen_of_nhds hs hf'?_?_?_
  · refine hasFDerivAt_of_tendstoLocallyUniformlyOnFilter_of_isOpen_of_nhds hs hf'?_?_?_
    · exact hasFDerivAt_of_tendstoLocallyUniformlyOnFilter?_ hs hf hfg
  · exact (hf n x hx).hasFDerivAt

For theorem:
theorem hasFDerivAt_of_tendstoLocallyUniformlyOn [NeBot l] {s : Set E} (hs : IsOpen s)
    (hf' : TendstoLocallyUniformlyOn f' g' l s) (hf : ∀ n, ∀ x ∈ s, HasFDerivAt (f n) (f' n x) x)
    (hfg : ∀ x ∈ s, Tendsto (fun n => f n x) l (𝓝 (g x))) (hx : x ∈ s) :
    HasFDerivAt g (g' x) x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine hasFDerivAt_iff_tendstoUniformlyOnFilter_zero.2 fun ε εpos =>?_
  rcases hf' ε εpos with ⟨ε, εpos, hε⟩
  refine hasFDerivAt_of_tendstoUniformlyOnFilter_zero εpos hε with ⟨ε, εpos, hε⟩
  refine hasFDerivAt_iff_tendstoUniformlyOnFilter_zero.2 ⟨ε, εpos, hε⟩
  refine hasFDerivAt_of_tendstoUniformlyOnFilt

For theorem:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x := by
              rw [hasFDerivAt_iff_tendsto]
    suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
              conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases cauchy_iff.1 hfg with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  rcases hf' with ⟨ε, εpos, hε⟩
  refine ⟨ε, εpos, hε⟩

For theorem:
theorem uniformCauchySeqOnFilter_of_fderiv (hf' : UniformCauchySeqOnFilter f' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : Cauchy (map (fun n => f n x) l)) : UniformCauchySeqOnFilter f l (𝓝 x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine uniformCauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball hf' hfg?_
  refine cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball hfg hf'?_
  refine cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball hf' hfg?_
  refine cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball hf' hfg?_
  refine cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball hfg hf'?_
  refine cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball hf' hfg?_
  refine cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball hf' hf'?_
  refine cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball hfg hf'?_
  refine cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball hf' hfg fun ε εpos =>?_
  refine cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball_of_cauchySeqOn_ball hf' hf'?_
  refine cauchySeqOn_ball_of_cauchySeqOn_bal

For theorem:
theorem uniformCauchySeqOn_ball_of_fderiv {r : ℝ} (hf' : UniformCauchySeqOn f' l (Metric.ball x r))
    (hf : ∀ n : ι, ∀ y : E, y ∈ Metric.ball x r → HasFDerivAt (f n) (f' n y) y)
    (hfg : Cauchy (map (fun n => f n x) l)) : UniformCauchySeqOn f l (Metric.ball x r) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hf'' : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1 n.2) (f' n.1 n.2) (f' n.1 n.2) n.2 :=
    hf.mono fun n hn => (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn =>
      (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn =>
      (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn =>
      (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn =>
      (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn =>
      (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn =>
      (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn =>
      (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn =>
      (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn => (hf' n.1 n.2).mono fun n hn =>
      (hf' n.1 n.2).mono fun n 

For theorem:
theorem difference_quotients_converge_uniformly (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y : E in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) :
    TendstoUniformlyOnFilter (fun n : ι => fun y : E => (‖y - x‖⁻¹ : 𝕜) • (f n y - f n x))
      (fun y : E => (‖y - x‖⁻¹ : 𝕜) • (g y - g x)) l (𝓝 x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine hasFDerivAt_iff_tendstoUniformlyOnFilter_zero.2 fun ε εpos =>?_
  rcases hf' ε εpos with ⟨ε, εpos, hε⟩
  refine hasFDerivAt_of_tendstoUniformlyOnFilter_zero εpos hε with ⟨ε, εpos, hε⟩
  refine hasFDerivAt_iff_tendstoUniformlyOnFilter_zero.2 ⟨ε, εpos, hε⟩
  refine hasFDerivAt_of_tendstoUniformlyOnFilt

For theorem:
theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (𝓝 x))
    (hf : ∀ᶠ n : ι × E in l ×ˢ 𝓝 x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : ∀ᶠ y in 𝓝 x, Tendsto (fun n => f n y) l (𝓝 (g y))) : HasFDerivAt g (g' x) x := by
              rw [hasFDerivAt_iff_tendsto]
    suffices
    Tendsto (fun y : ι × E => ‖y.2 - x‖⁻¹ * ‖g y.2 - g x - (g' x) (y.2 - x)‖)
      (l.curry (𝓝 x)) (𝓝 0) by
    rw [Metric.tendsto_nhds] at this ⊢
    intro ε hε
    specialize this ε hε
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
              conv =>
    congr
    ext
    rw [← abs_norm, ← abs_inv, ← @RCLike.norm_ofReal 𝕜 _ _, RCLike.ofReal_inv, ← norm_smul]
Attempt failure.

Working on Mathlib/Analysis/Complex/AbelLimit.lean - 2024-08-20 14:05:21.717852.
---0/3204---
Verifying proof:
:= by
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x y hx hy =>?_⟩
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x y hx hy =>?_⟩
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x y hx hy =>?_⟩
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x y hx hy =>?_⟩
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x y hx hy =>?_⟩
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x y hx hy =>?_⟩
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x y hx hy =>?_⟩
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x y hx hy =>?_⟩
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x y hx hy =>?_⟩
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x y hx hy =>?_⟩
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x y hxy hxy =>?_⟩
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x y hxy hxy =>?_⟩
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x y hxy =>?_⟩
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x y hxy =>?_⟩
  refine ⟨stolzCone_subset_stolzSet_aux' s, fun x

For theorem:
lemma stolzCone_subset_stolzSet_aux' (s : ℝ) :
    ∃ M ε, 0 < M ∧ 0 < ε ∧ ∀ x y, 0 < x → x < ε → |y| < s * x →
      sqrt (x ^ 2 + y ^ 2) < M * (1 - sqrt ((1 - x) ^ 2 + y ^ 2)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨M, ε, _, hε, H⟩ := stolzCone_subset_StolzSet_aux hs

For theorem:
lemma nhdsWithin_stolzCone_le_nhdsWithin_stolzSet {s : ℝ} (hs : 0 < s) :
    ∃ M, 𝓝[stolzCone s] 1 ≤ 𝓝[stolzSet M] 1 
Attempt failure.

Working on Mathlib/Analysis/Complex/AbsMax.lean - 2024-08-20 14:05:26.578966.
---0/3204---
Verifying proof:
:= by
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun εpos =>?_
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun εpos =>?_
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun εpos =>?_
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun εpos =>?_
  refine isOpen_iff_mem_nhds.2 fun ε hε =>?_
  refine isOpen_iff_mem_nhds.2 fun εpos =>?_
  refine isOpen_iff_mem_nhds.2 fun εpos =>?_
  refine isOpen

For theorem:
theorem isOpen_setOf_mem_nhds_and_isMaxOn_norm {f : E → F} {s : Set E}
    (hd : DifferentiableOn ℂ f s) : IsOpen {z | s ∈ 𝓝 z ∧ IsMaxOn (norm ∘ f) s z} 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne z 0 with (rfl | hne)
  · simp only [mem_closure_iff_nhdsWithin_neBot, not_forall, not_le] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot, mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_neBot] at hz
    simp only [mem_closure_iff_nhdsWithin_n

For theorem:
theorem norm_le_of_forall_mem_frontier_norm_le {f : E → F} {U : Set E} (hU : IsBounded U)
    (hd : DiffContOnCl ℂ f U) {C : ℝ} (hC : ∀ z ∈ frontier U, ‖f z‖ ≤ C) {z : E}
    (hz : z ∈ closure U) : ‖f z‖ ≤ C 
Attempt failure.

Working on Mathlib/Analysis/Complex/Basic.lean - 2024-08-20 14:05:33.396590.
---0/3204---
Verifying proof:
:= by
  simpa only [FunLike.ext_iff] using real_algHom_eq_id_or_conj (AlgHom.id ℂ) hf

For theorem:
theorem ringHom_eq_id_or_conj_of_continuous {f : ℂ →+* ℂ} (hf : Continuous f) :
    f = RingHom.id ℂ ∨ f = conj 
Attempt failure.

---0/3204---
Verifying proof:
:= IsROrC.inv_eq_conj' hz

For theorem:
lemma inv_eq_conj (hz : ‖z‖ = 1) : z⁻¹ = conj z 
Attempt failure.

---0/3204---
Verifying proof:
:=
  IsROrC.exists_norm_eq_mul_self _

For theorem:
lemma exists_norm_eq_mul_self (z : ℂ) : ∃ c, ‖c‖ = 1 ∧ ‖z‖ = c * z 
Attempt failure.

---0/3204---
Verifying proof:
:=
  IsROrC.exists_norm_mul_eq_self _

For theorem:
lemma exists_norm_mul_eq_self (z : ℂ) : ∃ c, ‖c‖ = 1 ∧ c * ‖z‖ = z 
Attempt failure.

Working on Mathlib/Analysis/Complex/CauchyIntegral.lean - 2024-08-20 14:06:03.701122.
---0/3204---
Verifying proof:
:= by
  refine circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable_of_countable_of_le h0 hle?_?_
  · exact circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable_of_countable_of_countable
  · exact circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable_of_countable_of_countable_of_countable
      (hc.mono inter_subset_left) (hc.mono inter_subset_left)

For theorem:
theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ℂ}
    {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {f : ℂ → E} {s : Set ℂ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ∀ z ∈ (ball c R \ closedBall c r) \ s, DifferentiableAt ℂ f z) :
    (∮ z in C(c, R), (z - c)⁻¹ • f z) = ∮ z in C(c, r), (z - c)⁻¹ • f z := by
    set A 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable_of_countable_of_le h0 hle?_?_
  · exact circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable_of_countable_of_countable
  · exact circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable_of_countable_of_countable_of_countable
      (hc.mono inter_subset_left) (hc.mono inter_subset_left)

For theorem:
theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : ℂ}
    {r R : ℝ} (h0 : 0 < r) (hle : r ≤ R) {f : ℂ → E} {s : Set ℂ} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : ∀ z ∈ (ball c R \ closedBall c r) \ s, DifferentiableAt ℂ f z) :
    (∮ z in C(c, R), (z - c)⁻¹ • f z) = ∮ z in C(c, r), (z - c)⁻¹ • f z := by
    set A 
Attempt failure.

Working on Mathlib/Analysis/Complex/Conformal.lean - 2024-08-20 14:06:14.874440.
---0/3204---
Verifying proof:
:= by
  rw [isConformalMap_iff_isConformalMap_or_conj_linear]
  refine ⟨fun h =>?_, fun h =>?_⟩
  · rintro (⟨m, hm⟩ | ⟨m, hm⟩)
    exact ⟨m, hm⟩

For theorem:
theorem isConformalMap_iff_is_complex_or_conj_linear :
    IsConformalMap g ↔
      ((∃ map : ℂ →L[ℂ] ℂ, map.restrictScalars ℝ = g) ∨
          ∃ map : ℂ →L[ℂ] ℂ, map.restrictScalars ℝ = g ∘L ↑conjCLE) ∧
        g ≠ 0 
Attempt failure.

Working on Mathlib/Analysis/Complex/Liouville.lean - 2024-08-20 14:06:17.407758.
---0/3204---
Verifying proof:
:= by
  set g : ℂ → F := f ∘ fun t : ℂ => t • (w - z) + z
  have hg : Differentiable ℂ g := fun t : ℂ => t • (w - z) + z
  have hg : Differentiable ℂ g := fun t : ℂ => t • (w - z) + z
  have hg : Differentiable ℂ g := differentiable_const
  have hg : Differentiable ℂ g := fun t : ℂ => t • (w - z) + z
  have hg : Differentiable ℂ g := differentiable_const
  have hg : Differentiable ℂ g := fun t : ℂ => t • (w - z) + z
  have hg : Differentiable ℂ g := differentiable_const
  have hg : Differentiable ℂ g := fun t : ℂ => t • (w - z) + z
  have hg : Differentiable ℂ g := differentiable_const
  have hg : Differentiable ℂ g := fun t : ℂ => t • (w - z) + z
  have hg : Differentiable ℂ g := differentiable_const
  have hg : Differentiable ℂ g := fun t : ℂ => t • (w - z) + z
  have hg : Differentiable ℂ g := differentiable_const
  have hg : Differentiable ℂ g := fun t : ℂ => t • (w - z) + z
  have hg : Differentiable ℂ g := differentiable_const
  ha

For theorem:
theorem apply_eq_apply_of_bounded {f : E → F} (hf : Differentiable ℂ f) (hb : IsBounded (range f))
    (z w : E) : f z = f w 
Attempt failure.

Working on Mathlib/Analysis/Complex/OpenMapping.lean - 2024-08-20 14:06:20.092203.
---0/3204---
Verifying proof:
:= by
  let ray : E → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ → ℂ →

For theorem:
theorem AnalyticAt.eventually_constant_or_nhds_le_map_nhds {z₀ : E} (hg : AnalyticAt ℂ g z₀) :
    (∀ᶠ z in 𝓝 z₀, g z = g z₀) ∨ 𝓝 (g z₀) ≤ map g (𝓝 z₀) := by
    let ray : E → ℂ → E 
Attempt failure.

Working on Mathlib/Analysis/Complex/PhragmenLindelof.lean - 2024-08-20 14:06:22.159676.
---0/3204---
Verifying proof:
:= by
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  refine 

For theorem:
theorem quadrant_I (hd : DiffContOnCl ℂ f (Ioi 0 ×ℂ Ioi 0))
    (hB : ∃ c < (2 : ℝ), ∃ B,
      f =O[cobounded ℂ ⊓ 𝓟 (Ioi 0 ×ℂ Ioi 0)] fun z => expR (B * abs z ^ c))
    (hre : ∀ x : ℝ, 0 ≤ x → ‖f x‖ ≤ C) (him : ∀ x : ℝ, 0 ≤ x → ‖f (x * I)‖ ≤ C) (hz_re : 0 ≤ z.re)
    (hz_im : 0 ≤ z.im) : ‖f z‖ ≤ C := by
    rcases eq_or_ne z 0 with (rfl | hzne);
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  refine 

For theorem:
theorem quadrant_I (hd : DiffContOnCl ℂ f (Ioi 0 ×ℂ Ioi 0))
    (hB : ∃ c < (2 : ℝ), ∃ B,
      f =O[cobounded ℂ ⊓ 𝓟 (Ioi 0 ×ℂ Ioi 0)] fun z => expR (B * abs z ^ c))
    (hre : ∀ x : ℝ, 0 ≤ x → ‖f x‖ ≤ C) (him : ∀ x : ℝ, 0 ≤ x → ‖f (x * I)‖ ≤ C) (hz_re : 0 ≤ z.re)
    (hz_im : 0 ≤ z.im) : ‖f z‖ ≤ C := by
    rcases eq_or_ne z 0 with (rfl | hzne);
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  refine 

For theorem:
theorem quadrant_II (hd : DiffContOnCl ℂ f (Iio 0 ×ℂ Ioi 0))
    (hB : ∃ c < (2 : ℝ), ∃ B,
      f =O[cobounded ℂ ⊓ 𝓟 (Iio 0 ×ℂ Ioi 0)] fun z => expR (B * abs z ^ c))
    (hre : ∀ x : ℝ, x ≤ 0 → ‖f x‖ ≤ C) (him : ∀ x : ℝ, 0 ≤ x → ‖f (x * I)‖ ≤ C) (hz_re : z.re ≤ 0)
    (hz_im : 0 ≤ z.im) : ‖f z‖ ≤ C 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  refine 

For theorem:
theorem quadrant_IV (hd : DiffContOnCl ℂ f (Ioi 0 ×ℂ Iio 0))
    (hB : ∃ c < (2 : ℝ), ∃ B,
      f =O[cobounded ℂ ⊓ 𝓟 (Ioi 0 ×ℂ Iio 0)] fun z => expR (B * abs z ^ c))
    (hre : ∀ x : ℝ, 0 ≤ x → ‖f x‖ ≤ C) (him : ∀ x : ℝ, x ≤ 0 → ‖f (x * I)‖ ≤ C) (hz_re : 0 ≤ z.re)
    (hz_im : z.im ≤ 0) : ‖f z‖ ≤ C 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  refine 

For theorem:
theorem quadrant_IV (hd : DiffContOnCl ℂ f (Ioi 0 ×ℂ Iio 0))
    (hB : ∃ c < (2 : ℝ), ∃ B,
      f =O[cobounded ℂ ⊓ 𝓟 (Ioi 0 ×ℂ Iio 0)] fun z => expR (B * abs z ^ c))
    (hre : ∀ x : ℝ, 0 ≤ x → ‖f x‖ ≤ C) (him : ∀ x : ℝ, x ≤ 0 → ‖f (x * I)‖ ≤ C) (hz_re : 0 ≤ z.re)
    (hz_im : z.im ≤ 0) : ‖f z‖ ≤ C 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  refine 

For theorem:
theorem quadrant_III (hd : DiffContOnCl ℂ f (Iio 0 ×ℂ Iio 0))
    (hB : ∃ c < (2 : ℝ), ∃ B,
      f =O[cobounded ℂ ⊓ 𝓟 (Iio 0 ×ℂ Iio 0)] fun z => expR (B * abs z ^ c))
    (hre : ∀ x : ℝ, x ≤ 0 → ‖f x‖ ≤ C) (him : ∀ x : ℝ, x ≤ 0 → ‖f (x * I)‖ ≤ C) (hz_re : z.re ≤ 0)
    (hz_im : z.im ≤ 0) : ‖f z‖ ≤ C 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBg with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBg with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBg with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBg with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBg with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBg with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBg with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBg with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBg with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBg with 

For theorem:
theorem isBigO_sub_exp_exp {a : ℝ} {f g : ℂ → E} {l : Filter ℂ} {u : ℂ → ℝ}
    (hBf : ∃ c < a, ∃ B, f =O[l] fun z => expR (B * expR (c * |u z|)))
    (hBg : ∃ c < a, ∃ B, g =O[l] fun z => expR (B * expR (c * |u z|))) :
    ∃ c < a, ∃ B, (f - g) =O[l] fun z => expR (B * expR (c * |u z|)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, B, hO⟩
  rcases hexp with ⟨c, hc, 

For theorem:
theorem right_half_plane_of_tendsto_zero_on_real (hd : DiffContOnCl ℂ f {z | 0 < z.re})
    (hexp : ∃ c < (2 : ℝ), ∃ B,
      f =O[cobounded ℂ ⊓ 𝓟 {z | 0 < z.re}] fun z => expR (B * abs z ^ c))
    (hre : Tendsto (fun x : ℝ => f x) atTop (𝓝 0)) (him : ∀ x : ℝ, ‖f (x * I)‖ ≤ C)
    (hz : 0 ≤ z.re) : ‖f z‖ ≤ C := by
    revert z
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c, hc⟩
  rcases hfexp with ⟨c,

For theorem:
theorem eqOn_right_half_plane_of_superexponential_decay {g : ℂ → E}
    (hfd : DiffContOnCl ℂ f {z | 0 < z.re}) (hgd : DiffContOnCl ℂ g {z | 0 < z.re})
    (hfexp : ∃ c < (2 : ℝ), ∃ B,
      f =O[cobounded ℂ ⊓ 𝓟 {z | 0 < z.re}] fun z => expR (B * abs z ^ c))
    (hgexp : ∃ c < (2 : ℝ), ∃ B,
      g =O[cobounded ℂ ⊓ 𝓟 {z | 0 < z.re}] fun z => expR (B * abs z ^ c))
    (hre : SuperpolynomialDecay atTop expR fun x => ‖f x - g x‖)
    (hfim : ∃ C, ∀ x : ℝ, ‖f (x * I)‖ ≤ C) (hgim : ∃ C, ∀ x : ℝ, ‖g (x * I)‖ ≤ C) :
    EqOn f g {z : ℂ | 0 ≤ z.re} 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hBf with ⟨c, hc⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, hc, B, hO⟩
  rcases hBf with ⟨c, h

For theorem:
theorem eqOn_quadrant_IV (hdf : DiffContOnCl ℂ f (Ioi 0 ×ℂ Iio 0))
    (hBf : ∃ c < (2 : ℝ), ∃ B,
      f =O[cobounded ℂ ⊓ 𝓟 (Ioi 0 ×ℂ Iio 0)] fun z => expR (B * abs z ^ c))
    (hdg : DiffContOnCl ℂ g (Ioi 0 ×ℂ Iio 0))
    (hBg : ∃ c < (2 : ℝ), ∃ B,
      g =O[cobounded ℂ ⊓ 𝓟 (Ioi 0 ×ℂ Iio 0)] fun z => expR (B * abs z ^ c))
    (hre : ∀ x : ℝ, 0 ≤ x → f x = g x) (him : ∀ x : ℝ, x ≤ 0 → f (x * I) = g (x * I)) :
    EqOn f g {z | 0 ≤ z.re ∧ z.im ≤ 0} 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  rcases hB with ⟨c, hc, B, hO⟩
  refine 

For theorem:
theorem quadrant_III (hd : DiffContOnCl ℂ f (Iio 0 ×ℂ Iio 0))
    (hB : ∃ c < (2 : ℝ), ∃ B,
      f =O[cobounded ℂ ⊓ 𝓟 (Iio 0 ×ℂ Iio 0)] fun z => expR (B * abs z ^ c))
    (hre : ∀ x : ℝ, x ≤ 0 → ‖f x‖ ≤ C) (him : ∀ x : ℝ, x ≤ 0 → ‖f (x * I)‖ ≤ C) (hz_re : z.re ≤ 0)
    (hz_im : z.im ≤ 0) : ‖f z‖ ≤ C 
Attempt failure.

Working on Mathlib/Analysis/Complex/Polynomial.lean - 2024-08-20 14:06:57.211488.
---0/3204---
Verifying proof:
:= by
  by_contra' hf'
  have (z : ℂ) : (f.eval z)⁻¹ = 0 :=
    (f.differentiable.inv hf').apply_eq_of_tendsto_const (f.differentiable.inv hf')
  have (z : ℂ) : (f.eval z)⁻¹ = 0 :=
    (f.differentiable.inv hf').apply_eq_of_tendsto_const (f.differentiable.inv hf')

For theorem:
theorem exists_root {f : ℂ[X]} (hf : 0 < degree f) : ∃ z : ℂ, IsRoot f z 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Fintype.bijective_of_prime_degree_eq_one?_
  rw [← Fintype.card_coe, ← Fintype.card_coe, ← Fintype.card_coe, ← Fintype.card_coe,
    Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin,
    Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin,
    Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin,
    Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin,
    Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin,
    Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin,
    Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin,
    Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin,
    Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin, Fintype.card_fin,
    Fintype.card_fin]
  

For theorem:
theorem galActionHom_bijective_of_prime_degree {p : ℚ[X]} (p_irr : Irreducible p)
    (p_deg : p.natDegree.Prime)
    (p_roots : Fintype.card (p.rootSet ℂ) = Fintype.card (p.rootSet ℝ) + 2) :
    Function.Bijective (galActionHom p ℂ) 
Attempt failure.

Working on Mathlib/Analysis/Complex/RealDeriv.lean - 2024-08-20 14:07:03.983157.
---0/3204---
Verifying proof:
:= by
  have A : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealClm z := by
    have B : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealClm z := by
      have B : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealClm z := by
      have B : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealClm z := by
      have B : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealClm z := by
      have B : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealClm z := by
      have B : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealClm z := by
      have B : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealClm z := by
      have B : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealClm z := by
      have B : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealClm z := by
      have B : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealClm z := by
      have B : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealClm z := by
      have B : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealClm z := by
      have B : HasStrictFDerivAt ((↑) : ℝ → ℂ) ofRealClm z := by
 

For theorem:
theorem HasStrictDerivAt.real_of_complex (h : HasStrictDerivAt e e' z) :
    HasStrictDerivAt (fun x : ℝ => (e x).re) e'.re z 
Attempt failure.

---0/3204---
Verifying proof:
:=
  by simpa only [ofRealClm_apply, ofReal_one, mul_one] using hf.comp z ofRealClm.hasDerivAt

For theorem:
theorem HasDerivAt.comp_ofReal (hf : HasDerivAt e e' ↑z) : HasDerivAt (fun y : ℝ => e ↑y) e' z 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [conformalAt_iff_isConformalMap_fderiv, (h.hasFDerivAt.restrictScalars ℝ).restrictScalars ℝ]

For theorem:
theorem DifferentiableAt.conformalAt (h : DifferentiableAt ℂ f z) (hf' : deriv f z ≠ 0) :
    ConformalAt f z 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun h =>?_⟩
  · simp only [conformalAt_iff_isConformalMap, conj_ofReal, comp_apply, comp_apply,
      conj_ofReal, comp_apply, conj_ofReal, comp_apply, comp_apply, comp_apply,
      comp_apply, conj_ofReal, comp_apply, comp_apply, comp_apply, conj_ofReal, comp_apply,
      comp_apply, conj_ofReal, comp_apply, comp_apply, conj_ofReal, comp_apply, comp_apply,
      comp_apply, conj_ofReal, comp_apply, comp_apply, comp_apply, conj_ofReal, comp_apply,
      comp_apply, conj_ofReal, comp_apply, comp_apply, conj_ofReal, comp_apply,
      comp_apply, conj_ofReal, comp_apply, comp_apply, conj_ofReal, comp_apply,
      comp_apply, conj_ofReal, comp_apply, comp_apply, conj_ofReal, comp_apply,
      comp_apply, conj_ofReal, comp_apply, comp_apply, conj_ofReal, comp_apply,
      comp_apply, conj_ofReal, comp_apply, comp_apply, conj_ofReal, comp_apply, comp_apply,
      comp_apply, conj_ofReal, comp_apply, conj_ofReal, comp_apply, conj_ofReal, comp_apply,
      comp_apply, conj_ofReal, 

For theorem:
theorem conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj {f : ℂ → ℂ} {z : ℂ} :
    ConformalAt f z ↔
      (DifferentiableAt ℂ f z ∨ DifferentiableAt ℂ (f ∘ conj) (conj z)) ∧ fderiv ℝ f z ≠ 0 
Attempt failure.

Working on Mathlib/Analysis/Complex/RemovableSingularity.lean - 2024-08-20 14:07:21.318069.
---0/3204---
Verifying proof:
:= by
  refine two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiableOn_differentiableOn hU hc hf?_
  refine two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiableOn_differentiableOn hU hc?_
  refine two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiableOn_differentiableOn hU hc?_
  refine two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiableOn_differentiableOn hU hc?_
  refine two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiableOn_differentiableOn hU hc?_
  refine two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiableOn_differentiableOn hc?_
  refine two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiableOn_differentiableOn hc?_
  refine two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiableOn_differentiableOn hc?_
  refine two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiableOn_differentiableOn hc?_
  refine two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiableOn_differentiab

For theorem:
theorem two_pi_I_inv_smul_circleIntegral_sub_sq_inv_smul_of_differentiable {U : Set ℂ}
    (hU : IsOpen U) {c w₀ : ℂ} {R : ℝ} {f : ℂ → E} (hc : closedBall c R ⊆ U)
    (hf : DifferentiableOn ℂ f U) (hw₀ : w₀ ∈ ball c R) :
    ((2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), ((z - w₀) ^ 2)⁻¹ • f z) = deriv f w₀ := by
    have hf' : DifferentiableOn ℂ (dslope f w₀) U :=
    (differentiableOn_dslope (hU.mem_nhds ((ball_subset_closedBall.trans hc) hw₀))).mpr hf
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hd' : ∀ᶠ z in 𝓝[≠] c, DifferentiableAt ℂ f z := by
    filter_upwards [self_mem_nhdsWithin] with z hz
    simp only [nhdsWithin_univ, nhdsWithin_empty, nhdsWithin_empty, nhdsWithin_empty] at hz
    simp only [nhdsWithin_empty, nhdsWithin_univ, nhdsWithin_univ, nhdsWithin_univ, nhdsWithin_univ]
    exact hz.mono fun z hz => (hz.mono nhdsWithin_le_nhds nhdsWithin_le_nhds).mono fun z hz =>
      (hz.mono nhdsWithin_le_nhds).analyticAt

For theorem:
theorem analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt {f : ℂ → E} {c : ℂ}
    (hd : ∀ᶠ z in 𝓝[≠] c, DifferentiableAt ℂ f z) (hc : ContinuousAt f c) : AnalyticAt ℂ f c 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne c 0 with (rfl | hc)
  · simp only [ne_eq, not_false_eq_true, imp_true_iff] at hc ⊢
    exact tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within hd hd
  · simp only [tendsto_iff_norm_sub_tendsto_zero]
    refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within?_ hd
    refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within (fun z hz =>?_) hz
    refine tendsto_nhdsWithin_of_tendsto_nhdsWithin_of_eventually_within (fun z hz =>?_)
    refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within (fun z hz =>?_) hz
    simp only [tendsto_iff_norm_sub_tendsto_zero]
    refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within (fun z hz =>?_) hz
    simp only [tendsto_iff_norm_sub_tendsto_zero]
    refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within (fun z hz =>?_) hz
    · simp only [sub_eq_add_neg, neg_sub, sub_eq_add_neg, neg_neg]
      exact tendsto_const_nhds.congr' (eventually_of_forall fun z hz =>?_)
    · simp only [neg_sub, sub_eq_a

For theorem:
theorem tendsto_limUnder_of_differentiable_on_punctured_nhds_of_isLittleO {f : ℂ → E} {c : ℂ}
    (hd : ∀ᶠ z in 𝓝[≠] c, DifferentiableAt ℂ f z)
    (ho : (fun z => f z - f c) =o[𝓝[≠] c] fun z => (z - c)⁻¹) :
    Tendsto f (𝓝[≠] c) (𝓝 <| limUnder (𝓝[≠] c) f) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [differentiableOn_compl_singleton_and_continuousWithinAt_iff_continuousWithinAt,
    differentiableOn_iff_continuousWithinAt, continuousWithinAt_univ]
  refine ⟨fun h =>?_, fun h => h.continuousWithinAt.differentiableWithinAt⟩
  refine ⟨fun h =>?_, fun h => h.continuousWithinAt.differentiableWithinAt⟩
  refine ⟨fun h =>?_, fun h => h.continuousWithinAt.differentiableWithinAt⟩
  refine ⟨fun h =>?_, fun h => h.continuousWithinAt.differentiableWithinAt⟩
  refine ⟨fun h =>?_, fun h => h.continuousWithinAt.differentiableWithinAt⟩
  refine ⟨fun h =>?_, fun h => h.continuousWithinAt.differentiableWithinAt⟩
  refine ⟨fun h =>?_, fun h => h.continuousWithinAt.differentiableWithinAt⟩
  refine ⟨fun h =>?_, fun h => h.continuousWithinAt.differentiableWithinAt⟩
  refine ⟨fun h =>?_, fun h => h.continuousWithinAt.differentiableWithinAt⟩
  refine ⟨fun h =>?_, fun h => h.continuousWithinAt.differentiableWithinAt⟩
  refine ⟨fun h =>?_, fun h => h.continuousWithi

For theorem:
theorem differentiableOn_compl_singleton_and_continuousAt_iff {f : ℂ → E} {s : Set ℂ} {c : ℂ}
    (hs : s ∈ 𝓝 c) :
    DifferentiableOn ℂ f (s \ {c}) ∧ ContinuousAt f c ↔ DifferentiableOn ℂ f s 
Attempt failure.

Working on Mathlib/Analysis/Convex/Basic.lean - 2024-08-20 14:07:32.480306.
---0/3204---
Verifying proof:
:=
  @convex_Iio 𝕜 βᵒᵈ _ _ _ _ _ _ r

For theorem:
theorem convex_Ioi (r : β) : Convex 𝕜 (Ioi r) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  Iff.intro
    (by
      rintro hA a b ha hb ha hb hab)
      refine forall_congr' fun a b ha hb hab =>?_
      simp only [smul_add, smul_smul, smul_add, smul_add]
    exact fun h a b ha hb hab => h ha hb ha hb hab
  have hab : a • s + b = 1 := by
    rw [add_comm]
    exact add_le_add_right hab _
  have hab : a • s + b = 1 := by
    rw [add_comm]
    exact add_le_add_right hab _
  have hab : a • s + b = 1 := by
    rw [add_comm]
    exact smul_le_smul_of_nonneg_right hab.le
  have hab : a • s + b = 1 := by
    refine forall_congr' fun a b ha hb hab =>?_
    rw [add_comm]
    exact add_le_add_left hab _

For theorem:
theorem convex_iff_pointwise_add_subset :
    Convex 𝕜 s ↔ ∀ ⦃a b : 𝕜⦄, 0 ≤ a → 0 ≤ b → a + b = 1 → a • s + b • s ⊆ s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simpa only [add_comm] using hs.translate_preimage_right z

For theorem:
theorem Convex.translate_preimage_left (hs : Convex 𝕜 s) (z : E) :
    Convex 𝕜 ((fun x => x + z) ⁻¹' s) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro x hx y hy a b ha hb hab
  have h := hs hx hy ha hb hab
  rwa [smul_add, add_comm]

For theorem:
theorem Convex.translate_preimage_right (hs : Convex 𝕜 s) (z : E) :
    Convex 𝕜 ((fun x => z + x) ⁻¹' s) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine fun f g hf g hg a b ha hb hab => ⟨fun x =>?_,?_⟩
  · apply_rules [add_nonneg, mul_nonneg, hf.1, hg.1]
  · erw [Finset.sum_congr rfl fun x hx =>?_]
  · erw [Finset.sum_congr rfl fun x hx =>?_, Finset.sum_congr rfl fun x hx =>?_⟩
  · erw [Finset.sum_congr rfl fun x hx =>?_, Finset.sum_congr rfl fun x hx =>?_⟩
  · erw [Finset.sum_congr rfl fun x hx =>?_, Finset.sum_congr rfl fun x hx =>?_⟩
  · erw [Finset.sum_congr rfl fun x hx =>?_, Finset.sum_congr rfl fun x hx =>?_⟩
  · erw [Finset.sum_congr rfl fun x hx =>?_, Finset.sum_congr rfl fun x hx =>?_⟩
  · erw [Finset.sum_congr rfl fun x hx =>?_, Finset.sum_congr rfl fun x hx =>?_⟩
  · erw [Finset.sum_congr rfl fun x hx =>?_, Finset.sum_congr rfl fun x hx =>?_⟩
  · erw [Finset.sum_congr rfl fun x hx =>?_, Finset.sum_congr rfl fun x hx =>?_⟩
  · erw [Finset.sum_congr rfl fun x hx =>?_, Finset.sum_congr rfl fun x hx =>?_⟩
  · erw [Finset.sum_congr rfl fun x hx =>?_]
  · erw [Finset.sum_congr rfl 

For theorem:
theorem convex_stdSimplex : Convex 𝕜 (stdSimplex 𝕜 ι) 
Attempt failure.

Working on Mathlib/Analysis/Convex/Between.lean - 2024-08-20 14:08:01.451055.
---0/3204---
Verifying proof:
:= by
  rcases h₁ with ⟨t₁, ht₁, rfl⟩
  rcases h₂ with ⟨t₁, ht₁, rfl⟩
  rcases h₂ with ⟨t₂, ht₂, rfl⟩
  rcases h₁ with ⟨t₂, ht₂, rfl⟩
  rcases h₁ with ⟨t₂, ht₂, rfl⟩
  rcases h₂ with ⟨t₂, ht₂, rfl⟩
  rcases h₁ with ⟨t₂, ht₂, rfl⟩
  rcases h₁ with ⟨t₂, ht₂, rfl⟩
  rcases h₂ with ⟨t₂, ht₂, rfl⟩
  rcases h₁ with ⟨t₂, ht₂, rfl⟩
  rcases h₁ with ⟨t₂, ht₂, rfl⟩
  rcases h₂ with ⟨t₂, ht₂, rfl⟩
  rcases h₁ with ⟨t₂, ht₂, rfl⟩
  rcases h₂ with ⟨t₂, ht₂, rfl⟩
  rcases h₁ with ⟨t₂, ht₂, rfl⟩
  rcases h₂ with ⟨t₂, ht₂, rfl⟩
  rcases h₁ with ⟨t₂, ht₂, rfl⟩
  rcases h₂ with ⟨t₂, ht₂, rfl⟩
  rcases h₁ with ⟨t₂, ht₂, rfl⟩
  rcases h₂ with ⟨t₂, ht₂, rfl⟩
  rcases h₁ with ⟨t₂, ht₂, rfl⟩
  rcases h₂ with ⟨t₂, ht₂, rfl⟩
  rcases h₁ with ⟨t₂, ht₂, rfl⟩
  rcases h₂ with ⟨t₂, ht₂, rfl⟩
  rcases 

For theorem:
theorem Wbtw.trans_left_right {w x y z : P} (h₁ : Wbtw R w y z) (h₂ : Wbtw R w x y) :
    Wbtw R x y z 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_case

For theorem:
theorem sbtw_of_sbtw_of_sbtw_of_mem_affineSpan_pair [NoZeroSMulDivisors R V]
    {t : Affine.Triangle R P} {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂) {p₁ p₂ p : P}
    (h₁ : Sbtw R (t.points i₂) p₁ (t.points i₃)) (h₂ : Sbtw R (t.points i₁) p₂ (t.points i₃))
    (h₁' : p ∈ line[R, t.points i₁, p₁]) (h₂' : p ∈ line[R, t.points i₂, p₂]) :
    Sbtw R (t.points i₁) p p₁ := by
    letI : DecidableRel ((· < ·) : R → R → Prop) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_case

For theorem:
theorem sbtw_of_sbtw_of_sbtw_of_mem_affineSpan_pair [NoZeroSMulDivisors R V]
    {t : Affine.Triangle R P} {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂) {p₁ p₂ p : P}
    (h₁ : Sbtw R (t.points i₂) p₁ (t.points i₃)) (h₂ : Sbtw R (t.points i₁) p₂ (t.points i₃))
    (h₁' : p ∈ line[R, t.points i₁, p₁]) (h₂' : p ∈ line[R, t.points i₂, p₂]) :
    Sbtw R (t.points i₁) p p₁ := by
    letI : DecidableRel ((· < ·) : R → R → Prop) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_case

For theorem:
theorem sbtw_of_sbtw_of_sbtw_of_mem_affineSpan_pair [NoZeroSMulDivisors R V]
    {t : Affine.Triangle R P} {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂) {p₁ p₂ p : P}
    (h₁ : Sbtw R (t.points i₂) p₁ (t.points i₃)) (h₂ : Sbtw R (t.points i₁) p₂ (t.points i₃))
    (h₁' : p ∈ line[R, t.points i₁, p₁]) (h₂' : p ∈ line[R, t.points i₂, p₂]) :
    Sbtw R (t.points i₁) p p₁ := by
    letI : DecidableRel ((· < ·) : R → R → Prop) 
Attempt failure.

Working on Mathlib/Analysis/Convex/Caratheodory.lean - 2024-08-20 14:08:45.363001.
---0/3204---
Verifying proof:
:= by
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply Set.Subset.antisymm
  apply S

For theorem:
theorem convexHull_eq_union : convexHull 𝕜 s =
    ⋃ (t : Finset E) (hss : ↑t ⊆ s) (hai : AffineIndependent 𝕜 ((↑) : t → E)), convexHull 𝕜 ↑t 
Attempt failure.

Working on Mathlib/Analysis/Convex/Combination.lean - 2024-08-20 14:08:47.318269.
---0/3204---
Verifying proof:
:= by
  rw [mem_convexHull_iff_exists_fintype] at hx hy ⊢
  rw [mem_convexHull_iff_exists_fintype] at hy
  rw [mem_convexHull_iff_exists_fintype] at hx hy
  rw [mem_convexHull_iff_exists_fintype] at hx hy
  rw [mem_convexHull_iff_exists_fintype] at hx hy
  rw [mem_convexHull_iff_exists_fintype] at hx hy
  rw [mem_convexHull_iff_exists_fintype] at hx hy
  rw [mem_convexHull_iff_exists_fintype] at hx hy
  rw [mem_convexHull_iff_exists_fintype] at hx hy
  rw [mem_convexHull_iff_exists_fintype] at hy
  rw [mem_convexHull_iff_exists_fintype] at hx hy
  rw [mem_convexHull_iff_exists_fintype] at hx hy
  rw [mem_convexHull_iff_exists_fintype] at hy
  rw [mem_convexHull_iff_exists_fintype] at hy
  rw [mem_convexHull_iff_exists_fintype] at hy
  rw [mem_convexHull_iff_exists_fintype] at hy
  rw [mem_convexHull_iff_exists_fintype] at hy
  rw [mem_convexHull_iff_exists_fintype] at hy
  rw [mem_convexHull_iff_exists_fintype] at hy
  rw [mem_convexHull_iff_exists_fintype] at hy
  rw [mem_convexHull_iff_exists_fintype] at

For theorem:
theorem mk_mem_convexHull_prod {t : Set F} {x : E} {y : F} (hx : x ∈ convexHull R s)
    (hy : y ∈ convexHull R t) : (x, y) ∈ convexHull R (s ×ˢ t) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [centerMass_smul, t.centerMass_smul, t.centerMass_smul, t.centerMass_smul,
    t.centerMass_smul hc]

For theorem:
lemma Finset.centerMass_smul_left {c : R'} [Module R' R] [Module R' E] [SMulCommClass R' R R]
    [IsScalarTower R' R R] [SMulCommClass R R' E] [IsScalarTower R' R E] (hc : c ≠ 0) :
    t.centerMass (c • w) z = t.centerMass w z 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [finsum, dif_pos h₀]
  refine finsum_ne_zero h₁ fun i hi =>?_
  rw [finsum, dif_pos hi]
  exact finsum_ne_zero_of_nonneg h₀ hz

For theorem:
theorem Convex.finsum_mem {ι : Sort*} {w : ι → R} {z : ι → E} {s : Set E} (hs : Convex R s)
    (h₀ : ∀ i, 0 ≤ w i) (h₁ : ∑ᶠ i, w i = 1) (hz : ∀ i, w i ≠ 0 → z i ∈ s) :
    (∑ᶠ i, w i • z i) ∈ s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [finsum, dif_pos h₀]
  refine finsum_ne_zero h₁ fun i hi =>?_
  rw [finsum, dif_pos hi]
  exact finsum_ne_zero_of_nonneg h₀ hz

For theorem:
theorem Convex.finsum_mem {ι : Sort*} {w : ι → R} {z : ι → E} {s : Set E} (hs : Convex R s)
    (h₀ : ∀ i, 0 ≤ w i) (h₁ : ∑ᶠ i, w i = 1) (hz : ∀ i, w i ≠ 0 → z i ∈ s) :
    (∑ᶠ i, w i • z i) ∈ s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [convexHull_eq, Finset.sum_const, nsmul_eq_mul, mul_one, Finset.sum_const, nsmul_eq_mul,
    Finset.sum_const, nsmul_eq_mul, mul_one]

For theorem:
theorem convexHull_eq (s : Set E) : convexHull R s =
    { x : E | ∃ (ι : Type) (t : Finset ι) (w : ι → R) (z : ι → E), (∀ i ∈ t, 0 ≤ w i) ∧
      ∑ i ∈ t, w i = 1 ∧ (∀ i ∈ t, z i ∈ s) ∧ t.centerMass w z = x } 
Attempt failure.

---0/3204---
Verifying proof:
:=
  hs.convexHull_inter_convexHull hs

For theorem:
lemma AffineIndependent.convexHull_inter' (hs : AffineIndependent R ((↑) : ↑(t₁ ∪ t₂) → E)) :
    convexHull R (t₁ ∩ t₂ : Set E) = convexHull R t₁ ∩ convexHull R t₂ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [Finset.sum_congr rfl fun i hi => by rintro rfl; simp at hw₁]
  rw [Finset.sum_congr rfl fun i hi => by rintro rfl; simp at hw₁]

For theorem:
theorem inf_le_centerMass {s : Finset ι} {f : ι → α} {w : ι → R} (hw₀ : ∀ i ∈ s, 0 ≤ w i)
    (hw₁ : 0 < ∑ i ∈ s, w i) :
    s.inf' (nonempty_of_ne_empty <| by rintro rfl; simp at hw₁) f ≤ s.centerMass w f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Subset.antisymm?_?_
  · rw [_root_.convexHull_eq_union, convexHull_eq_union, convexHull_eq_union, convexHull_iUnion,
    convexHull_iUnion, convexHull_iUnion, convexHull_iUnion, convexHull_iUnion, convexHull_iUnion]

For theorem:
theorem convexHull_eq_union_convexHull_finite_subsets (s : Set E) :
    convexHull R s = ⋃ (t : Finset E) (w : ↑t ⊆ s), convexHull R ↑t 
Attempt failure.

Working on Mathlib/Analysis/Convex/Cone/Extension.lean - 2024-08-20 14:10:03.413346.
---0/3204---
Verifying proof:
:= by
  obtain ⟨x, hx⟩ := hp_dense x
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  obtain ⟨y, hy⟩ := hp_dense y
  

For theorem:
theorem exists_top (p : E →ₗ.[ℝ] ℝ) (hp_nonneg : ∀ x : p.domain, (x : E) ∈ s → 0 ≤ p x)
    (hp_dense : ∀ y, ∃ x : p.domain, (x : E) + y ∈ s) :
    ∃ q ≥ p, q.domain = ⊤ ∧ ∀ x : q.domain, (x : E) ∈ s → 0 ≤ q x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine extension_of_le_sublinear (fun x y =>?_) fun x y =>?_
  refine exists_extension_of_le_sublinear (fun x y =>?_) fun x y =>?_
  refine exists_extension_of_le_sublinear (fun x y =>?_) fun x y =>?_
  refine extension_of_le_sublinear (fun x y =>?_) fun x y =>?_
  refine exists_extension_of_le_sublinear (fun x y =>?_) fun x y =>?_
  refine exists_extension_of_le_sublinear (fun x y =>?_) fun x y =>?_
  refine exists_extension_of_le_sublinear (fun x y =>?_) fun x y =>?_
  refine exists_extension_of_le_sublinear (fun x y =>?_) fun x y =>?_
  refine exists_extension_of_le_sublinear (fun x y =>?_) fun x y =>?_
  refine exists_extension_of_le_sublinear (fun x y =>?_) fun x y =>?_
  refine exists_extension_of_le_sublinear (fun x y =>?_) fun x y =>?_
  refine exists_extension_of_le_sublinear (fun x y =>?_) fun x y =>?_
  refine exists_extension_of_le_sublinear (fun x y =>?_) fun x y =>?_
  refine exists_extension_of_le_sublinear (fun x y =>?_) fun x y =>?_
  refine exists_extensi

For theorem:
theorem exists_extension_of_le_sublinear (f : E →ₗ.[ℝ] ℝ) (N : E → ℝ)
    (N_hom : ∀ c : ℝ, 0 < c → ∀ x, N (c • x) = c * N x) (N_add : ∀ x y, N (x + y) ≤ N x + N y)
    (hf : ∀ x : f.domain, f x ≤ N x) :
    ∃ g : E →ₗ[ℝ] ℝ, (∀ x : f.domain, g x = f x) ∧ ∀ x, g x ≤ N x 
Attempt failure.

Working on Mathlib/Analysis/Convex/Contractible.lean - 2024-08-20 14:10:07.214604.
---0/3204---
Verifying proof:
:= by
  refine
    (contractible_iff_id_nullhomotopic s).2
      ⟨⟨x, h.mem hne⟩,
      ⟨⟨x, h.mem hne⟩

For theorem:
theorem StarConvex.contractibleSpace (h : StarConvex ℝ x s) (hne : s.Nonempty) :
    ContractibleSpace s 
Attempt failure.

Working on Mathlib/Analysis/Convex/Extrema.lean - 2024-08-20 14:10:08.920654.
---0/3204---
Verifying proof:
:= by
  refine IsMinOn.of_isLocalMinOn_of_convexOn_Icc h_local_min h_conv h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv

For theorem:
theorem IsMinOn.of_isLocalMinOn_of_convexOn_Icc {f : ℝ → β} {a b : ℝ} (a_lt_b : a < b)
    (h_local_min : IsLocalMinOn f (Icc a b) a) (h_conv : ConvexOn ℝ (Icc a b) f) :
    IsMinOn f (Icc a b) a 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine IsMinOn.of_isLocalMinOn_of_convexOn_Icc h_local_min h_conv h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv h_local_min h_conv

For theorem:
theorem IsMinOn.of_isLocalMinOn_of_convexOn_Icc {f : ℝ → β} {a b : ℝ} (a_lt_b : a < b)
    (h_local_min : IsLocalMinOn f (Icc a b) a) (h_conv : ConvexOn ℝ (Icc a b) f) :
    IsMinOn f (Icc a b) a 
Attempt failure.

Working on Mathlib/Analysis/Convex/Function.lean - 2024-08-20 14:10:12.117294.
---0/3204---
Verifying proof:
:=
  ⟨hf.left, fun x hx y hy hxy a b ha hb hab⟩

For theorem:
theorem StrictConvexOn.sup (hf : StrictConvexOn 𝕜 s f) (hg : StrictConvexOn 𝕜 s g) :
    StrictConvexOn 𝕜 s (f ⊔ g) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine hf.le_open_segment' hx hy hxy?_?_ ha hb hab <;> simp [*]

For theorem:
theorem StrictConvexOn.lt_on_open_segment' (hf : StrictConvexOn 𝕜 s f) {x y : E} (hx : x ∈ s)
    (hy : y ∈ s) (hxy : x ≠ y) {a b : 𝕜} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    f (a • x + b • y) < max (f x) (f y) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simpa only [add_comm] using hf.translate_left c

For theorem:
theorem StrictConcaveOn.translate_left (hf : StrictConcaveOn 𝕜 s f) (c : E) :
    StrictConcaveOn 𝕜 ((fun z => c + z) ⁻¹' s) (f ∘ fun z => z + c) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  ⟨hf.1.linear_preimage _, fun x hx y hy a b ha hb hab => hf.2 ha hb hab⟩

For theorem:
theorem ConvexOn.comp_linearMap {f : F → β} {s : Set F} (hf : ConvexOn 𝕜 s f) (g : E →ₗ[𝕜] F) :
    ConvexOn 𝕜 (g ⁻¹' s) (f ∘ g) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  ⟨hs, fun _ _ _ _ _ _ _ _ _ _ _ => by rw [f.map_add, f.map_smul, f.map_smul]⟩

For theorem:
theorem LinearMap.convexOn (f : E →ₗ[𝕜] β) {s : Set E} (hs : Convex 𝕜 s) : ConvexOn 𝕜 s f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · rintro ⟨hconv, h⟩
    refine ⟨hconv, fun x hx y hy hxy a b ha hb hab =>?_⟩
    refine ⟨hconv, fun x hx y hy hxy a b ha hb hab =>?_⟩
    rw [← neg_strictConvexOn_iff, neg_neg]
    refine ⟨hconv, fun x hx y hy hxy a b ha hb hab =>?_⟩
  · rw [neg_strictConvexOn_iff]
    refine ⟨hconv, fun x hx y hy hxy a b ha hb hab =>?_⟩
    rw [neg_strictConvexOn_iff]
    refine ⟨hconv, fun x hx y hy hxy a b ha hb hab =>?_⟩
    rw [neg_strictConvexOn_iff]
    refine ⟨hconv, fun x hx y hy hxy a b ha hb hab =>?_⟩
    rw [neg_strictConvexOn_iff]
    refine ⟨hconv, fun x hx y hy hxy a b ha hb hab =>?_⟩
    rw [neg_strictConvexOn_iff]
    refine ⟨hconv, fun x hx y hy hxy a b ha hb hab =>?_⟩
    rw [neg_strictConvexOn_iff]
    refine ⟨hconv, fun x hx y hy hxy a b ha hb hab =>?_⟩
    rw [neg_strictConvexOn_iff]
    refine ⟨hconv, fun x hx y hy hxy a b ha hb hab =>?_⟩
    rw [neg_strictConvexOn_iff]
    refine ⟨hconv, fun x hx y hy hxy a b ha hb hab =

For theorem:
theorem neg_strictConvexOn_iff : StrictConvexOn 𝕜 s (-f) ↔ StrictConcaveOn 𝕜 s f 
Attempt failure.

Working on Mathlib/Analysis/Convex/Gauge.lean - 2024-08-20 14:11:18.629927.
---0/3204---
Verifying proof:
:= by
  refine le_of_forall_pos_lt_add fun ε hε =>?_
  obtain ⟨a, ha⟩ : ∃ a : ℝ, 0 < a ∧ gauge s x + gauge s y ≤ gauge s x + gauge s y :=
    hs.gauge_add_le absorbs absorbs absorbs absorbs

For theorem:
theorem gauge_add_le (hs : Convex ℝ s) (absorbs : Absorbent ℝ s) (x y : E) :
    gauge s (x + y) ≤ gauge s x + gauge s y 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext x
  obtain hp | hp := { r : ℝ | 0 < r ∧ x ∈ r • p.ball 0 1 }.eq_empty_or_nonempty
  · rw [gauge, hp, Real.sInf_empty, Real.sInf_empty]
  · rw [gauge, hp, Real.sInf_empty, Real.sInf_empty, Real.sInf_empty, Real.sInf_empty,
      Real.sInf_empty]

For theorem:
theorem Seminorm.gauge_ball (p : Seminorm ℝ E) : gauge (p.ball 0 1) = p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext x
  obtain hp | hp := { r : ℝ | 0 < r ∧ x ∈ r • p.ball 0 1 }.eq_empty_or_nonempty
  · rw [gauge, hp, Real.sInf_empty, Real.sInf_empty]
  · rw [gauge, hp, Real.sInf_empty, Real.sInf_empty, Real.sInf_empty, Real.sInf_empty,
      Real.sInf_empty]

For theorem:
theorem Seminorm.gauge_ball (p : Seminorm ℝ E) : gauge (p.ball 0 1) = p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext x
  obtain hp | hp := { r : ℝ | 0 < r ∧ x ∈ r • p.ball 0 1 }.eq_empty_or_nonempty
  · rw [gauge, hp, Real.sInf_empty, Real.sInf_empty]
  · rw [gauge, hp, Real.sInf_empty, Real.sInf_empty, Real.sInf_empty, Real.sInf_empty,
      Real.sInf_empty]

For theorem:
theorem Seminorm.gauge_ball (p : Seminorm ℝ E) : gauge (p.ball 0 1) = p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro x hx
  have H₁ : Tendsto (fun r : ℝ ↦ r⁻¹ • x) (𝓝 ((1 : ℝ)⁻¹ • x) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ • x)) (𝓝 ((1 : ℝ)⁻¹ 

For theorem:
theorem interior_subset_gauge_lt_one (s : Set E) : interior s ⊆ { x | gauge s x < 1 } 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext x
  obtain hp | hp := { r : ℝ | 0 < r ∧ x ∈ r • p.ball 0 1 }.eq_empty_or_nonempty
  · rw [gauge, hp, Real.sInf_empty, Real.sInf_empty]
  · rw [gauge, hp, Real.sInf_empty, Real.sInf_empty, Real.sInf_empty, Real.sInf_empty,
      Real.sInf_empty]

For theorem:
theorem Seminorm.gauge_ball (p : Seminorm ℝ E) : gauge (p.ball 0 1) = p 
Attempt failure.

Working on Mathlib/Analysis/Convex/Independent.lean - 2024-08-20 14:12:02.541967.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun h s x hx =>?_, fun h s x hx =>?_⟩
  · rintro ⟨s, hs, rfl⟩
    simp only [mem_convexHull, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_singleton_iff,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, Set.mem_image, Set.mem_image,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq]
   

For theorem:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (x : ι), p x ∈ convexHull 𝕜 (s.image p : Set E) → x ∈ s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h s x hx =>?_, fun h s x hx =>?_⟩
  · rintro ⟨s, hs, rfl⟩
    simp only [mem_convexHull, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_singleton_iff,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, Set.mem_image, Set.mem_image,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq]
   

For theorem:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (x : ι), p x ∈ convexHull 𝕜 (s.image p : Set E) → x ∈ s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h s x hx =>?_, fun h s x hx =>?_⟩
  · rintro ⟨s, hs, rfl⟩
    simp only [mem_convexHull, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_singleton_iff,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, Set.mem_image, Set.mem_image,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq]
   

For theorem:
theorem convexIndependent_iff_finset {p : ι → E} :
    ConvexIndependent 𝕜 p ↔
      ∀ (s : Finset ι) (x : ι), p x ∈ convexHull 𝕜 (s.image p : Set E) → x ∈ s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [convexIndependent_set_iff_inter_convexHull_subset]
  refine ⟨fun h x hx =>?_, fun h x hx =>?_⟩
  · simp only [convexHull_diff, Set.mem_sdiff, Set.mem_diff, Set.mem_singleton_iff,
      Set.mem_diff, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_diff, Set.mem_singleton_iff, Set.mem_singleton_iff]
    rintro ⟨x, hx, rfl⟩
    simp only [Set.mem_diff, Set.mem_singleton_iff, Set.mem_diff, Set.mem_singleton_iff,
      Set.mem_diff, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff]
    rintro ⟨x, hx, rfl⟩
    simp only [Set.mem_diff, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_diff, Set.mem_singleton_iff, Set.mem_singleton_iff]
 

For theorem:
theorem convexIndependent_set_iff_not_mem_convexHull_diff {s : Set E} :
    ConvexIndependent 𝕜 ((↑) : s → E) ↔ ∀ x ∈ s, x ∉ convexHull 𝕜 (s \ {x}) 
Attempt failure.

Working on Mathlib/Analysis/Convex/Intrinsic.lean - 2024-08-20 14:12:08.697473.
---0/3204---
Verifying proof:
:= by
  ext x
  simp only [mem_closure_iff, mem_intrinsicClosure]

For theorem:
theorem intrinsicClosure_eq_closure : intrinsicClosure 𝕜 s = closure s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext x
  simp only [mem_closure_iff, mem_intrinsicClosure]

For theorem:
theorem intrinsicClosure_eq_closure : intrinsicClosure 𝕜 s = closure s 
Attempt failure.

Working on Mathlib/Analysis/Convex/KreinMilman.lean - 2024-08-20 14:12:16.976794.
---0/3204---
Verifying proof:
:= by
  let S : Set (Set E) := { t | t.Nonempty ∧ IsClosed t ∧ IsExtreme t ∧ IsExtreme t ∧ IsExtreme t ∧ IsExtreme t ∧ IsExtreme t }

For theorem:
theorem IsCompact.extremePoints_nonempty (hscomp : IsCompact s) (hsnemp : s.Nonempty) :
    (s.extremePoints ℝ).Nonempty 
Attempt failure.

Working on Mathlib/Analysis/Convex/Measure.lean - 2024-08-20 14:12:18.876185.
---0/3204---
Verifying proof:
:=
  nullMeasurableSet_of_null_frontier (hs.add_haar_frontier μ)

For theorem:
theorem nullMeasurableSet (hs : Convex ℝ s) : NullMeasurableSet s μ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases' ne_or_eq (affineSpan ℝ s) ⊤ with hspan hspan
  · refine measure_mono_null?_ (addHaar_affineSpan ℝ s) ⊤ with hspan hspan
    refine measure_mono_null?_ (addHaar_affineSubspace _ _ hspan)

For theorem:
theorem addHaar_frontier (hs : Convex ℝ s) : μ (frontier s) = 0 := by
    cases' ne_or_eq (affineSpan ℝ s) ⊤ with hspan hspan
Attempt failure.

Working on Mathlib/Analysis/Convex/Mul.lean - 2024-08-20 14:12:22.762499.
---0/3204---
Verifying proof:
:= by
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  refine ⟨hf.1, fun x hx y hy a b ha hb hab =>?_⟩
  · rintro x hx y hy a b ha hab ha hb hab hab =>?_⟩
  · rw [← smul_smul, ← smul_smul, ← smul_smul, ← smul_smul, ← smul_smu

For theorem:
lemma ConcaveOn.smul' (hf : ConcaveOn 𝕜 s f) (hg : ConcaveOn 𝕜 s g) (hf₀ : ∀ ⦃x⦄, x ∈ s → 0 ≤ f x)
    (hg₀ : ∀ ⦃x⦄, x ∈ s → 0 ≤ g x) (hfg : AntivaryOn f g s) : ConcaveOn 𝕜 s (f • g) 
Attempt failure.

Working on Mathlib/Analysis/Convex/Segment.lean - 2024-08-20 14:12:29.579678.
---0/3204---
Verifying proof:
:= by
  rw [← openSegment_eq_Ioo h]
  simp_rw [← exists_prop]

For theorem:
theorem Convex.mem_Ioo (h : x < y) :
    z ∈ Ioo x y ↔ ∃ a b, 0 < a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z 
Attempt failure.

Working on Mathlib/Analysis/Convex/Side.lean - 2024-08-20 14:12:37.009406.
---0/3204---
Verifying proof:
:= by
  rcases hxy with ⟨p₁, hp₁, p₂, hp₂⟩
  rcases hxy with ⟨p₁, hp₁, p₂, hp₂⟩
  rcases hxy with ⟨p₁, hp₁, p₂, hp₂⟩
  rcases hyz with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hxy with ⟨p₂, hp₂, hp₂⟩
  rcases hyz with ⟨p₂, hp₂, hp₂⟩
  rcases h

For theorem:
theorem WSameSide.trans {s : AffineSubspace R P} {x y z : P} (hxy : s.WSameSide x y)
    (hyz : s.WSameSide y z) (hy : y ∉ s) : s.WSameSide x z 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun h =>?_⟩
  · rw [wSameSide_comm, wSameSide_comm, wSameSide_comm, wSameSide_comm]
    refine ⟨fun h =>?_, fun h =>?_⟩
    rw [wSameSide_comm, wSameSide_comm, wSameSide_comm, wSameSide_comm]
    refine ⟨fun h =>?_, fun h =>?_⟩
    rw [wSameSide_comm, wSameSide_comm, wSameSide_comm, wSameSide_comm, wSameSide_comm]

For theorem:
theorem _root_.Function.Injective.wSameSide_map_iff {s : AffineSubspace R P} {x y : P}
    {f : P →ᵃ[R] P'} (hf : Function.Injective f) :
    (s.map f).WSameSide (f x) (f y) ↔ s.WSameSide x y 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [vsub_vadd_eq_vsub_sub, vsub_vadd_eq_vsub_sub, vsub_vadd_eq_vsub_sub, ← neg_vsub_eq_vsub_rev,
    neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, ← neg_vsub_eq_vsub_rev,
    neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev,
    

For theorem:
theorem sOppSide_smul_vsub_vadd_left {s : AffineSubspace R P} {x p₁ p₂ : P} (hx : x ∉ s)
    (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s) {t : R} (ht : t < 0) : s.SOppSide (t • (x -ᵥ p₁) +ᵥ p₂) x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [wOppSide_smul_vsub_left_of_nonpos hp₁ hp₂ hp₁ hp₁ hp₂ ht]
  exact wOppSide_smul_vsub_left_of_nonpos hp₁ hp₂ ht

For theorem:
theorem wOppSide_smul_vsub_vadd_left {s : AffineSubspace R P} {p₁ p₂ : P} (x : P) (hp₁ : p₁ ∈ s)
    (hp₂ : p₂ ∈ s) {t : R} (ht : t ≤ 0) : s.WOppSide (t • (x -ᵥ p₁) +ᵥ p₂) x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · rintro ⟨p₁, hp₁, p₂, hp₂, h⟩
    refine ⟨p₂, hp₂, h⟩
    refine ⟨p₂, hp₂, h⟩
    refine ⟨p₂, hp₂, h⟩
    refine ⟨p₂, hp₂, h⟩
    refine ⟨p₂, hp₂, h⟩
    refine ⟨p₂, hp₂, h⟩
    refine ⟨p₂, hp₂, h⟩
    refine ⟨p₂, hp₂, h⟩
    refine ⟨p₂, hp₂, h⟩
    refine ⟨p₂, hp₂, h⟩
    refine ⟨p₂, hp₂, h⟩
    rw [wOppSide_comm, wOppSide_comm, wOppSide_comm, wOppSide_comm]
    rintro ⟨p₁, hp₁, p₂, hp₂, h⟩
    refine ⟨p₂, hp₂, h⟩
    rw [wOppSide_comm, wOppSide_comm, wOppSide_comm, wOppSide_comm]

For theorem:
theorem wOppSide_comm {s : AffineSubspace R P} {x y : P} : s.WOppSide x y ↔ s.WOppSide y x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · rintro ⟨p₁, hp₁, p₂, hp₂, h⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    rw [wSameSide_comm, wSameSide_comm, wSameSide_comm, wSameSide_comm, wSameSide_vadd_left_iff h]
    rw [wSameSide_comm, wSameSide_comm, wSameSide_comm, wSameSide_vadd_left_iff h]
    rw [wSameSide_comm, wSameSide_comm]
    exact wSameSide_vadd_left_of_mem_direction hv

For theorem:
theorem wSameSide_vadd_left_iff {s : AffineSubspace R P} {x y : P} {v : V} (hv : v ∈ s.direction) :
    s.WSameSide (v +ᵥ x) y ↔ s.WSameSide x y 
Attempt failure.

Working on Mathlib/Analysis/Convex/Slope.lean - 2024-08-20 14:13:26.045352.
---0/3204---
Verifying proof:
:= by
  refine strictConvexOn_of_slope_strict_mono_adjacent hs hf (fun x y z hx hy hxy =>?_) hxy
  refine strictConvexOn_of_slope_strict_mono_adjacent hs hx hy?_?_ <;>
    simp only [sub_self, zero_sub, zero_sub, sub_zero, sub_zero, sub_zero, sub_zero,
      sub_self, zero_sub, zero_sub, sub_zero]

For theorem:
theorem strictConvexOn_of_slope_strict_mono_adjacent (hs : Convex 𝕜 s)
    (hf :
      ∀ {x y z : 𝕜},
        x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) < (f z - f y) / (z - y)) :
    StrictConvexOn 𝕜 s f 
Attempt failure.

Working on Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean - 2024-08-20 14:13:34.140317.
---0/3204---
Verifying proof:
:= by
  cases' lt_or_le 0 x with hx hx
  · exact (hasDerivAt_sqrt_mul_log hx.ne').deriv

For theorem:
theorem deriv_sqrt_mul_log (x : ℝ) :
    deriv (fun x => √x * log x) x = (2 + log x) / (2 * √x) 
Attempt failure.

Working on Mathlib/Analysis/Convex/SpecificFunctions/Pow.lean - 2024-08-20 14:13:37.146211.
---0/3204---
Verifying proof:
:= by
  have hp₀' : 0 < 1 / p := by positivity
  have hp₀' : 0 < 1 / p := by positivity
  have hp₀' : 0 < 1 / p := by positivity
  have hp₁' : 1 / p < 1 / p := by positivity
  have hp₀' : 1 / p < 1 / p := by positivity
  have hp₀' : 1 / p < 1 / p := by positivity
  have hp₀' : 1 / p < 1 / p := by positivity
  have hp₀' : 1 / p < 1 / p := by positivity
  have hp₀' : 1 / p < 1 / p := by positivity
  have hp₀' : 1 / p < 1 / p := by positivity
  have hp₀' : 1 / p < 1 / p := by positivity
  have hp₀' : 1 / p < 1 / p := by positivity
  have hp₀' : 1 / p < 1 / p := by positivity
  have hp₀' : 1 / p < 1 / p := by positivity
  have hp₀' : 1 / p < 1 / p := by positivity
  have hp₀' : 1 / p < 1 / p := by positivity
  have hp₀' : 1 / p < 1 / p := by positivity
  have hp₀' : 1 / p < 1 / p := by positivity
  have hp₁' : 1 / p < 1 := by positivity
  have hp₀' : 1 / p < 1 := by positivity
  have hp₁' : 1 / p < 1 := by positivity
  have hp₀' : 1 / p < 1 := by positivity
  have hp

For theorem:
lemma strictConcaveOn_rpow {p : ℝ} (hp₀ : 0 < p) (hp₁ : p < 1) :
    StrictConcaveOn ℝ≥0 univ fun x : ℝ≥0 ↦ x ^ p 
Attempt failure.

Working on Mathlib/Analysis/Convex/Strict.lean - 2024-08-20 14:13:39.226648.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun h a b ha hb hab =>?_, fun h a b ha hb hab =>?_⟩
  refine ⟨fun h a b ha hb hab =>?_, fun h a b ha hb hab =>?_⟩
  · simp only [mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff⟩
    simp only [mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff⟩
    simp only [mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds, mem_interior_iff_mem_nhds,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff⟩

For theorem:
theorem strictConvex_iff_div :
    StrictConvex 𝕜 s ↔
      s.Pairwise fun x y =>
        ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → (a / (a + b)) • x + (b / (a + b)) • y ∈ interior s 
Attempt failure.

Working on Mathlib/Analysis/Convex/Topology.lean - 2024-08-20 14:13:43.228092.
---0/3204---
Verifying proof:
:= by
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy hxy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConvex.2 fun x hx y hy =>?_
  refine strictConvex_iff_strictConve

For theorem:
theorem Convex.strictConvex' {s : Set E} (hs : Convex 𝕜 s)
    (h : (s \ interior s).Pairwise fun x y => ∃ c : 𝕜, lineMap x y c ∈ interior s) :
    StrictConvex 𝕜 s 
Attempt failure.

Working on Mathlib/Analysis/Convex/Uniform.lean - 2024-08-20 14:13:47.675524.
---0/3204---
Verifying proof:
:= by
  obtain ⟨δ, δpos, hδ⟩ : ∃ δ > 0, 0 < δ ∧ ∀ x ∈ closedBall 0 δ, 0 < δ → ‖x - y‖ ≤ ε :=
    exists_seq_strictAnti_tendsto (0 : ℝ)
  rcases exists_seq_strictAnti_tendsto (0 : ℝ) with ⟨δ, δpos, hδ⟩
  rcases exists_seq_strictAnti_tendsto (0 : ℝ) with ⟨δ, δpos, hδ⟩
  rcases exists_seq_strictAnti_tendsto (0 : ℝ) with ⟨δ, δpos, hδ⟩
  rcases exists_seq_strictAnti_tendsto (0 : ℝ) with ⟨δ, δpos, hδ⟩
  rcases exists_seq_strictAnti_tendsto (0 : ℝ) with ⟨δ, δpos, hδ⟩
  rcases exists_seq_strictAnti_tendsto (0 : ℝ) with ⟨δ, δpos, hδ⟩
  rcases exists_seq_strictAnti_tendsto (0 : ℝ) with ⟨δ, δpos, hδ⟩
  rcases exists_seq_strictAnti_tendsto (0 : ℝ) with ⟨δ, δpos, hδ⟩
  rcases exists_seq_strictAnti_tendsto (0 : ℝ) with ⟨δ, δpos, hδ⟩
  rcases exists_seq_strictAnti_tendsto (0 : ℝ) with ⟨δ, δpos, hδ⟩
  rcases exists_seq_strictAnti_tendsto (0 : ℝ) with ⟨δ, δpos, hδ⟩
  refine ⟨δ, δpos, fun x hx y

For theorem:
theorem exists_forall_closed_ball_dist_add_le_two_mul_sub (hε : 0 < ε) (r : ℝ) :
    ∃ δ, 0 < δ ∧ ∀ ⦃x : E⦄, ‖x‖ ≤ r → ∀ ⦃y⦄, ‖y‖ ≤ r → ε ≤ ‖x - y‖ → ‖x + y‖ ≤ 2 * r - δ 
Attempt failure.

Working on Mathlib/Analysis/Convolution.lean - 2024-08-20 14:13:49.656258.
---0/3204---
Verifying proof:
:= by
  ext1 x
  simp_rw [convolution_def]
  rw [← integral_sub_left_eq_self _ μ x]
  simp_rw [sub_sub_self, flip_apply]

For theorem:
theorem convolution_flip : g ⋆[L.flip, μ] f = f ⋆[L, μ] g 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine contDiffOn_convolution_right_with_param hs hk hgs fun x hx =>?_
  refine contDiffOn_convolution_right_with_param hs hk (fun x hx =>?_) (fun x hx =>?_)
  · rw [contDiffOn_convolution_right_with_param hs hk hgs]
    exact contDiffOn_convolution_right_with_param hs hk (fun x hx =>?_) (fun x hx =>?_) hx
  · rw [contDiffOn_convolution_right_with_param hs hk hgs]
    exact contDiffOn_convolution_right_with_param hs hk hgs
  · refine contDiffOn_convolution_right_with_param hs hk (fun x hx =>?_) (fun x hx =>?_) hx
  · rw [contDiffOn_convolution_right_with_param hs hk hgs]
    exact contDiffOn_convolution_right_with_param hs hk (fun x hx =>?_) (fun x hx =>?_) hx
  · rw [contDiffOn_convolution_right_with_param hs hk hgs]
    exact contDiffOn_convolution_right_with_param hs hk hg

For theorem:
theorem contDiffOn_convolution_right_with_param {f : G → E} {n : ℕ∞} (L : E →L[𝕜] E' →L[𝕜] F)
    {g : P → G → E'} {s : Set P} {k : Set G} (hs : IsOpen s) (hk : IsCompact k)
    (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0) (hf : LocallyIntegrable f μ)
    (hg : ContDiffOn 𝕜 n (↿g) (s ×ˢ univ)) :
    ContDiffOn 𝕜 n (fun q : P × G => (f ⋆[L, μ] g q.1) q.2) (s ×ˢ univ) := by
    let eG : Type max uG uE' uF uP 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine contDiffOn_convolution_right_with_param hs hk hgs fun x hx =>?_
  refine contDiffOn_convolution_right_with_param hs hk (fun x hx =>?_) (fun x hx =>?_)
  · rw [contDiffOn_convolution_right_with_param hs hk hgs]
    exact contDiffOn_convolution_right_with_param hs hk (fun x hx =>?_) (fun x hx =>?_) hx
  · rw [contDiffOn_convolution_right_with_param hs hk hgs]
    exact contDiffOn_convolution_right_with_param hs hk hgs
  · refine contDiffOn_convolution_right_with_param hs hk (fun x hx =>?_) (fun x hx =>?_) hx
  · rw [contDiffOn_convolution_right_with_param hs hk hgs]
    exact contDiffOn_convolution_right_with_param hs hk (fun x hx =>?_) (fun x hx =>?_) hx
  · rw [contDiffOn_convolution_right_with_param hs hk hgs]
    exact contDiffOn_convolution_right_with_param hs hk hg

For theorem:
theorem contDiffOn_convolution_right_with_param {f : G → E} {n : ℕ∞} (L : E →L[𝕜] E' →L[𝕜] F)
    {g : P → G → E'} {s : Set P} {k : Set G} (hs : IsOpen s) (hk : IsCompact k)
    (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0) (hf : LocallyIntegrable f μ)
    (hg : ContDiffOn 𝕜 n (↿g) (s ×ˢ univ)) :
    ContDiffOn 𝕜 n (fun q : P × G => (f ⋆[L, μ] g q.1) q.2) (s ×ˢ univ) := by
    let eG : Type max uG uE' uF uP 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [convolution_assoc]
  refine convolution_assoc' L hf hg hk?_
  rw [convolution_assoc', L₃.map_apply, L₃.map_apply, L₃.map_apply, L₃.map_apply,
    L₃.map_apply, L₃.map_apply, L₃.map_apply, L₃.map_apply, L₃.map_apply,
    L₃.map_apply, L₃.map_apply, L₃.map_apply, L₃.map_apply, L₃.map_apply,
    L₃.map_apply, L₃.map_apply]

For theorem:
theorem convolution_assoc (hL : ∀ (x : E) (y : E') (z : E''), L₂ (L x y) z = L₃ x (L₄ y z)) {x₀ : G}
    (hf : AEStronglyMeasurable f ν) (hg : AEStronglyMeasurable g μ) (hk : AEStronglyMeasurable k μ)
    (hfg : ∀ᵐ y ∂μ, ConvolutionExistsAt f g y L ν)
    (hgk : ∀ᵐ x ∂ν, ConvolutionExistsAt (fun x => ‖g x‖) (fun x => ‖k x‖) x (mul ℝ ℝ) μ)
    (hfgk :
      ConvolutionExistsAt (fun x => ‖f x‖) ((fun x => ‖g x‖) ⋆[mul ℝ ℝ, μ] fun x => ‖k x‖) x₀
        (mul ℝ ℝ) ν) :
    ((f ⋆[L, ν] g) ⋆[L₂, μ] k) x₀ = (f ⋆[L₃, ν] g ⋆[L₄, μ] k) x₀ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine contDiffOn_convolution_right_with_param hs hk hgs fun x hx =>?_
  refine contDiffOn_convolution_right_with_param hs hk (fun x hx =>?_) (fun x hx =>?_)
  · rw [contDiffOn_convolution_right_with_param hs hk hgs]
    exact contDiffOn_convolution_right_with_param hs hk (fun x hx =>?_) (fun x hx =>?_) hx
  · rw [contDiffOn_convolution_right_with_param hs hk hgs]
    exact contDiffOn_convolution_right_with_param hs hk hgs
  · refine contDiffOn_convolution_right_with_param hs hk (fun x hx =>?_) (fun x hx =>?_) hx
  · rw [contDiffOn_convolution_right_with_param hs hk hgs]
    exact contDiffOn_convolution_right_with_param hs hk (fun x hx =>?_) (fun x hx =>?_) hx
  · rw [contDiffOn_convolution_right_with_param hs hk hgs]
    exact contDiffOn_convolution_right_with_param hs hk hg

For theorem:
theorem contDiffOn_convolution_right_with_param {f : G → E} {n : ℕ∞} (L : E →L[𝕜] E' →L[𝕜] F)
    {g : P → G → E'} {s : Set P} {k : Set G} (hs : IsOpen s) (hk : IsCompact k)
    (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0) (hf : LocallyIntegrable f μ)
    (hg : ContDiffOn 𝕜 n (↿g) (s ×ˢ univ)) :
    ContDiffOn 𝕜 n (fun q : P × G => (f ⋆[L, μ] g q.1) q.2) (s ×ˢ univ) := by
    let eG : Type max uG uE' uF uP 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine hasFDerivAt_convolution_right_with_param hs hk hgs (fun p hp =>?_) hf
  refine hasFDerivAt_convolution_right_with_param hs hk hgs (fun x hx =>?_) hf
  · exact hf.convolution_integrable_of_hasFDerivAt_convolution_right_with_param hs hk hgs
  · exact hasFDerivAt_convolution_right_with_param hs hk hgs
  · exact hasFDerivAt_convolution_right_with_param hs hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_wi

For theorem:
theorem hasFDerivAt_convolution_right_with_param {g : P → G → E'} {s : Set P} {k : Set G}
    (hs : IsOpen s) (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0)
    (hf : LocallyIntegrable f μ) (hg : ContDiffOn 𝕜 1 (↿g) (s ×ˢ univ)) (q₀ : P × G)
    (hq₀ : q₀.1 ∈ s) :
    HasFDerivAt (fun q : P × G => (f ⋆[L, μ] g q.1) q.2)
      ((f ⋆[L.precompR (P × G), μ] fun x : G => fderiv 𝕜 (↿g) (q₀.1, x)) q₀.2) q₀ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine continuousOn_convolution_right_with_param hk hgs?_?_?_?_ <;>
    simp only [mem_iUnion, mem_inter_iff, mem_setOf_eq, mem_singleton_iff] at hp
    exact hgs p hp x hp hx

For theorem:
theorem continuousOn_convolution_right_with_param {g : P → G → E'} {s : Set P} {k : Set G}
    (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0)
    (hf : LocallyIntegrable f μ) (hg : ContinuousOn (↿g) (s ×ˢ univ)) :
    ContinuousOn (fun q : P × G => (f ⋆[L, μ] g q.1) q.2) (s ×ˢ univ) := by
    by_cases H : ∀ p ∈ s, ∀ x, g p x = 0
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine hasFDerivAt_convolution_right_with_param hs hk hgs (fun p hp =>?_) hf
  refine hasFDerivAt_convolution_right_with_param hs hk hgs (fun x hx =>?_) hf
  · exact hf.convolution_integrable_of_hasFDerivAt_convolution_right_with_param hs hk hgs
  · exact hasFDerivAt_convolution_right_with_param hs hk hgs
  · exact hasFDerivAt_convolution_right_with_param hs hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_with_param hgs
  · exact hf.convolution_right_wi

For theorem:
theorem hasFDerivAt_convolution_right_with_param {g : P → G → E'} {s : Set P} {k : Set G}
    (hs : IsOpen s) (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0)
    (hf : LocallyIntegrable f μ) (hg : ContDiffOn 𝕜 1 (↿g) (s ×ˢ univ)) (q₀ : P × G)
    (hq₀ : q₀.1 ∈ s) :
    HasFDerivAt (fun q : P × G => (f ⋆[L, μ] g q.1) q.2)
      ((f ⋆[L.precompR (P × G), μ] fun x : G => fderiv 𝕜 (↿g) (q₀.1, x)) q₀.2) q₀ 
Attempt failure.

---0/3204---
Verifying proof:
:=
  calc
    ∫ t : G, (L (f t)) (g (-x - t)) (g (-x - t)) = ∫ t : G, L (f t) (g (-x - t)) (g (-x - t)) :=
      integral_congr_ae (h1.ae_eq_mk.symm)
    _ = ∫ t : G, L (f t) (g (-x - t)) (g (-x - t)) := by
      rw [integral_congr_ae (h1.ae_eq_mk.symm), integral_congr_ae (h2.ae_eq_mk.symm)]
    _ = ∫ t : G, (L (f t)) (g (-x - t)) (g (-x - t)) (g (-x - t)) := by
      rw [integral_congr_ae (h1.ae_eq_mk.symm)]
    _ = ∫ t : G, (L (f t)) (g (-x - t)) (g (-x - t)) (g (-x - t)) := by
      rw [integral_congr_ae (h1.ae_eq_mk.symm)]
    _ = ∫ t : G, (L (f t)) (g (-x - t)) (g (-x - t)) (g (-x - t)) := by
      rw [integral_congr_ae (h1.ae_eq_mk.symm)]
    _ = ∫ t : G, (L (f t)) (g (-x - t)) (g (-x - t)) (g (-x - t)) := by
      rw [integral_congr_ae (h1.ae_eq_mk.symm)]
    _ = ∫ t : G, (L (f t)) (g (-x - t)) (g (-x - t)) (g (-x - t)) := by
      rw [integral_congr_ae (h1.ae_eq_mk.symm), integral_congr_ae (h2.ae_eq_mk.symm)]
    _ = ∫ t : G, (L (f t)) (g (-x - t)) (g (-x - t)) (g (-x - t)) := by
  

For theorem:
theorem convolution_neg_of_neg_eq (h1 : ∀ᵐ x ∂μ, f (-x) = f x) (h2 : ∀ᵐ x ∂μ, g (-x) = g x) :
    (f ⋆[L, μ] g) (-x) = (f ⋆[L, μ] g) x 
Attempt failure.

Working on Mathlib/Analysis/Distribution/AEEqOfIntegralContDiff.lean - 2024-08-20 14:17:55.659744.
---0/3204---
Verifying proof:
:= by
  refine ae_eq_zero_of_forall_smooth_smul_eq_zero fun ε ε0 =>?_
  have hε : ∀ᵐ x ∂μ, ∫ x, g x ∂μ = 0 := by
    filter_upwards [hε] with x hx
    simp only [hx, Pi.zero_apply, integral_zero, smul_eq_mul, mul_eq_zero, integral_eq_zero_iff',
      integral_eq_zero_iff_of_hasCompactSupport hx] with x hx
    simp only [integral_eq_zero_of_hasCompactSupport hx, integral_eq_zero_iff'] at hx
    simp only [integral_eq_zero_of_hasCompactSupport hx, integral_eq_zero_iff'] at hx
    obtain ⟨δ, δpos, hδ⟩ : ∃ δ : ℝ, 0 < δ ∧ ∫ x, g x ∂μ = 0 :=
    exists_seq_strictAnti_tendsto (0 : ℝ)
    simp only [integral_eq_zero_iff_of_hasCompactSupport hx, integral_const, smul_eq_mul,
      smul_eq_mul, mul_eq_zero] with x hx
    simp only [integral_eq_zero_iff_of_hasCompactSupport hx, integral_eq_zero_iff'] at hx
    simp only [integral_const, smul_eq_mul, mul_eq_zero] at hx
    simp only [integral_eq_zero_iff_of_hasCompactSupport hx, integral_eq_zero_iff'] at hx
    simp only [integral_c

For theorem:
theorem ae_eq_zero_of_integral_smooth_smul_eq_zero (hf : LocallyIntegrable f μ)
    (h : ∀ g : M → ℝ, Smooth I 𝓘(ℝ) g → HasCompactSupport g → ∫ x, g x • f x ∂μ = 0) :
    ∀ᵐ x ∂μ, f x = 0 := by
    have 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ae_eq_zero_of_forall_smooth_smul_eq_zero fun ε ε0 =>?_
  have hε : ∀ᵐ x ∂μ, ∫ x, g x ∂μ = 0 := by
    filter_upwards [hε] with x hx
    simp only [hx, Pi.zero_apply, integral_zero, smul_eq_mul, mul_eq_zero, integral_eq_zero_iff',
      integral_eq_zero_iff_of_hasCompactSupport hx] with x hx
    simp only [integral_eq_zero_of_hasCompactSupport hx, integral_eq_zero_iff'] at hx
    simp only [integral_eq_zero_of_hasCompactSupport hx, integral_eq_zero_iff'] at hx
    obtain ⟨δ, δpos, hδ⟩ : ∃ δ : ℝ, 0 < δ ∧ ∫ x, g x ∂μ = 0 :=
    exists_seq_strictAnti_tendsto (0 : ℝ)
    simp only [integral_eq_zero_iff_of_hasCompactSupport hx, integral_const, smul_eq_mul,
      smul_eq_mul, mul_eq_zero] with x hx
    simp only [integral_eq_zero_iff_of_hasCompactSupport hx, integral_eq_zero_iff'] at hx
    simp only [integral_const, smul_eq_mul, mul_eq_zero] at hx
    simp only [integral_eq_zero_iff_of_hasCompactSupport hx, integral_eq_zero_iff'] at hx
    simp only [integral_c

For theorem:
theorem ae_eq_zero_of_integral_smooth_smul_eq_zero (hf : LocallyIntegrable f μ)
    (h : ∀ g : M → ℝ, Smooth I 𝓘(ℝ) g → HasCompactSupport g → ∫ x, g x • f x ∂μ = 0) :
    ∀ᵐ x ∂μ, f x = 0 := by
    have 
Attempt failure.

Working on Mathlib/Analysis/Distribution/SchwartzSpace.lean - 2024-08-20 14:18:01.448737.
---0/3204---
Verifying proof:
:= by
  refine le_trans?_ (mul_le_mul_of_nonneg_right (by positivity) (by positivity))
  rw [← Nat.cast_pow, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_pow, ← Nat.cast_mul,
    ← Nat.cast_pow, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_pow, ← Nat.cast_pow, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_pow, ← Nat.cast_pow, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_pow, ← Nat.cast_pow, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cas

For theorem:
theorem one_add_le_sup_seminorm_apply {m : ℕ × ℕ} {k n : ℕ} (hk : k ≤ m.1) (hn : n ≤ m.2)
    (f : 𝓢(E, F)) (x : E) :
    (1 + ‖x‖) ^ k * ‖iteratedFDeriv ℝ n f x‖ ≤
      2 ^ m.1 * (Finset.Iic m).sup (fun m => SchwartzMap.seminorm 𝕜 m.1 m.2) f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine
    (c • f).seminormAux_le_bound k n (mul_nonneg (norm_nonneg _) (norm_nonneg _))
    (mul_nonneg (norm_nonneg _) (norm_nonneg _))

For theorem:
theorem seminormAux_smul_le (k n : ℕ) (c : 𝕜) (f : 𝓢(E, F)) :
    (c • f).seminormAux k n ≤ ‖c‖ * f.seminormAux k n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine le_trans (seminorm_le_bound 𝕜 k n f)?_
  refine le_trans (seminorm_le_bound 𝕜 k n f) (seminorm_le_bound 𝕜 k n f)?_
  refine le_trans (mul_le_mul_of_nonneg_right?_ (norm_nonneg _)) (le_trans (mul_nonneg?_?_) hMp)
  · exact le_trans (mul_le_mul_of_nonneg_right?_ (norm_nonneg _))
  · exact le_trans (mul_le_mul_of_nonneg_right (norm_nonneg _) (norm_nonneg _))
      (mul_nonneg (norm_nonneg _) (norm_nonneg _))

For theorem:
theorem seminorm_le_bound' (k n : ℕ) (f : 𝓢(ℝ, F)) {M : ℝ} (hMp : 0 ≤ M)
    (hM : ∀ x, |x| ^ k * ‖iteratedDeriv n f x‖ ≤ M) : SchwartzMap.seminorm 𝕜 k n f ≤ M 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hμ.exists_integrable with ⟨n, h⟩
  let l := n + k
  obtain ⟨C, C_nonneg, hC⟩ := exists_integrable_pow_mul_left_of_nonneg (norm_nonneg _)
  have : ∀ x, ‖x‖ ^ k * ‖f x‖ ≤ ‖f x‖ := fun x hx => by
    intro x
    rw [← integrable_norm_iff]
    exact (integrable_pow_mul_left_of_nonneg (norm_nonneg _) (norm_nonneg _)).mpr h

For theorem:
lemma integrable_pow_mul (f : 𝓢(D, V))
    (k : ℕ) : Integrable (fun x ↦ ‖x‖ ^ k * ‖f x‖) μ 
Attempt failure.

Working on Mathlib/Analysis/Fourier/AddCircle.lean - 2024-08-20 14:19:24.113569.
---0/3204---
Verifying proof:
:= by
  intro x y hxy
  refine ⟨_, ⟨fourier 1, subset_adjoin ⟨1, rfl⟩, rfl⟩,?_⟩
  dsimp only; rw [fourier_adjoin]
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩, _⟩
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩
  dsimp only; rw [fourier_subset_adjoin ⟨1, rfl⟩, _⟩
  dsi

For theorem:
theorem fourierSubalgebra_separatesPoints : (@fourierSubalgebra T).SeparatesPoints 
Attempt failure.

---0/3204---
Verifying proof:
  rw [← fourier_apply]; exact fourier_apply

For theorem:
theorem fourier_add' {m n : ℤ} {x : AddCircle T} :
    toCircle ((m + n) • x :) = fourier m x * fourier n x 
Attempt failure.

---0/3204---
Verifying proof:
:=
  ContinuousMap.subalgebra_isROrC_topologicalClosure_eq_top_of_separatesPoints fourierSubalgebra

For theorem:
theorem fourierSubalgebra_closure_eq_top : (@fourierSubalgebra T).topologicalClosure = ⊤ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  trans ∫ t : AddCircle T, conj ((@fourierLp T hT 2 _ i : AddCircle T) 2 _ i : AddCircle T) := by
    simp only [fourierBasis.repr_apply, LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply,
      LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply,
      LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply,
      LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply,
      LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply,
      LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply,
      LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply,
      LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply,
      LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.trans_apply, Line

For theorem:
theorem fourierBasis_repr (f : Lp ℂ 2 <| @haarAddCircle T hT) (i : ℤ) :
    fourierBasis.repr f i = fourierCoeff f i 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : ∀ x : ℝ, ∫ x in a..a + T, fourier T (-n) x • f x = (1 / T) • fourier T (-n) x := by
    intro x hx
    simp only [fourierCoeff_apply, intervalIntegral.integral_of_le hx.le, integral_smul,
      fourierCoeff_apply, integral_smul, integral_smul, integral_smul, integral_smul, smul_smul,
      ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
    ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
    ← intervalIntegral.integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
      ← intervalIntegral.integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
    ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
    ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
    ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
    ← integral_smu

For theorem:
theorem fourierCoeff_eq_intervalIntegral (f : AddCircle T → E) (n : ℤ) (a : ℝ) :
    fourierCoeff f n = (1 / T) • ∫ x in a..a + T, @fourier T (-n) x • f x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine fourierCoeffOn_of_hasDerivAt_of_integrableOn_of_hasDerivAt_of_integrableOn_Ioc hab hf'?_?_?_
  · exact fourierCoeffOn_of_hasDerivAt_of_integrableOn_Ioc hab hn hf'
  · exact fourierCoeffOn_of_hasDerivAt_of_integrableOn_Ioc hab hf' hf hf'
  · exact fourierCoeffOn_of_hasDerivAt_of_integrableOn_Ioc hab hn hf'
  · exact fourierCoeffOn_of_hasDerivAt_of_integrableOn_Ioc hab hf' hf hf' hf'
  · exact fourierCoeffOn_of_hasDerivAt_of_integrableOn_Ioc hab hn hf'
  · exact fourierCoeffOn_of_hasDerivAt_of_integrableOn_Ioc hab hn hf' hf hf'
  · exact fourierCoeffOn_of_hasDerivAt_of_integrableOn_Ioc hab hn hf' hf'
  · exact fourierCoeffOn_of_hasDerivAt_of_integrableOn_Ioc hab hn hf' hf hf'
  · exact fourierCoe

For theorem:
theorem fourierCoeffOn_of_hasDerivAt {a b : ℝ} (hab : a < b) {f f' : ℝ → ℂ} {n : ℤ} (hn : n ≠ 0)
    (hf : ∀ x, x ∈ [[a, b]] → HasDerivAt f (f' x) x) (hf' : IntervalIntegrable f' volume a b) :
    fourierCoeffOn hab f n = 1 / (-2 * π * I * n) *
      (fourier (-n) (a : AddCircle (b - a)) * (f b - f a) - (b - a) * fourierCoeffOn hab f' n) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [fourier_apply, zsmul_add, ← QuotientAddGroup.mk_zsmul]

For theorem:
theorem fourier_add_half_inv_index {n : ℤ} (hn : n ≠ 0) (hT : 0 < T) (x : AddCircle T) :
    @fourier T n (x + ↑(T / 2 / n)) = -fourier n x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  convert
    (ContinuousMap.toLp_toLp (span ℂ (range (@fourierLp T _ p _)))).topologicalClosure
      (span ℂ (range (@fourierLp T _ p _))).topologicalClosure
      (span ℂ (range (@fourierLp T _ p _)))

For theorem:
theorem span_fourierLp_closure_eq_top {p : ℝ≥0∞} [Fact (1 ≤ p)] (hp : p ≠ ∞) :
    (span ℂ (range (@fourierLp T _ p _))).topologicalClosure = ⊤ 
Attempt failure.

Working on Mathlib/Analysis/Fourier/FourierTransform.lean - 2024-08-20 14:20:47.880000.
---0/3204---
Verifying proof:
:= by
  simp only [fourierIntegral_eq, ofAdd_neg, map_inv, coe_inv]

For theorem:
lemma fourierIntegral_comp_linearIsometry (A : W ≃ₗᵢ[ℝ] V) (f : V → E) (w : W) :
    𝓕 (f ∘ A) w = (𝓕 f) (A w) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun hf =>?_, fun hf =>?_⟩
  · rw [fourierIntegral_convergent_iff he hL hL w]
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?_⟩
    refine ⟨fun hf =>?_, fun hf =>?

For theorem:
theorem fourierIntegral_convergent_iff (he : Continuous e)
    (hL : Continuous fun p : V × W ↦ L p.1 p.2) {f : V → E} (w : W) :
    Integrable (fun v : V ↦ e (-L v w) • f v) μ ↔ Integrable f μ := by
    have aux {g : V → E} (hg : Integrable g μ) (x : W) :
      Integrable (fun v : V ↦ e (-L v x) • g v) μ := by
    have c : Continuous fun v ↦ e (-L v x) :=
      he.comp (hL.comp (continuous_prod_mk.mpr ⟨continuous_id, continuous_const⟩)).neg
    simp_rw [← integrable_norm_iff (c.aestronglyMeasurable.smul hg.1), norm_circle_smul]
    exact hg.norm
    refine ⟨fun hf ↦ ?_, fun hf ↦ aux hf w⟩
Attempt failure.

Working on Mathlib/Analysis/Fourier/Inversion.lean - 2024-08-20 14:21:04.506432.
---0/3204---
Verifying proof:
:= by
  have : Tendsto (fun c : ℝ => ((π * c) ^ (finrank ℝ V / 2 : ℂ) * cexp (-π ^ 2 * c * ‖v - w‖)) (𝓝[>] 0) := by
    refine tendsto_integral_pow_mul_gaussian_smul_of_integrable_of_locally_integrable_geometric hf h'f?_
    simp only [norm_smul, norm_of_nonneg (norm_nonneg _), norm_of_nonneg (norm_nonneg _),
      norm_of_nonneg (norm_nonneg _), norm_of_nonneg (norm_nonneg _), norm_of_nonneg (norm_nonneg _)]

For theorem:
lemma tendsto_integral_gaussian_smul (hf : Integrable f) (h'f : Integrable (𝓕 f)) (v : V) :
    Tendsto (fun (c : ℝ) ↦
      ∫ w : V, ((π * c) ^ (finrank ℝ V / 2 : ℂ) * cexp (-π ^ 2 * c * ‖v - w‖ ^ 2)) • f w)
    atTop (𝓝 (𝓕⁻ (𝓕 f) v)) 
Attempt failure.

Working on Mathlib/Analysis/Fourier/PoissonSummation.lean - 2024-08-20 14:21:08.152087.
---0/3204---
Verifying proof:
:= by
  have : ∀ K : Compacts ℝ, ∀ n, ‖(f.comp (ContinuousMap.addRight n)).restrict K‖ = ‖f.comp (ContinuousMap.addRight n)‖ := by
    intro K hK
    simp only [ContinuousMap.addRight_apply, ContinuousMap.comp_apply, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_comp, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_comp, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, Contin

For theorem:
theorem Real.fourierCoeff_tsum_comp_add {f : C(ℝ, ℂ)}
    (hf : ∀ K : Compacts ℝ, Summable fun n : ℤ => ‖(f.comp (ContinuousMap.addRight n)).restrict K‖)
    (m : ℤ) : fourierCoeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m = 𝓕 f m := by
      let e : C(ℝ, ℂ) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine isBigO_norm_restrict_of_isBigO_norm_restrict_cocompact_subset?_?_ <;>
    simp only [ContinuousMap.coe_comp', ContinuousMap.coe_coe, ContinuousMap.coe_comp',
      ContinuousMap.coe_coe, ContinuousMap.coe_comp', ContinuousMap.coe_coe, ContinuousMap.coe_comp',
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_comp', ContinuousMap.coe_comp',
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_comp', ContinuousMap.coe_comp',
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_comp', ContinuousMap.coe_comp',
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_comp', ContinuousMap.coe_comp',
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_comp', ContinuousMap.coe_comp',
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_comp', ContinuousMap.coe_comp',
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_comp',
      ContinuousMap.coe_coe, Conti

For theorem:
theorem isBigO_norm_restrict_cocompact (f : C(ℝ, E)) {b : ℝ} (hb : 0 < b)
    (hf : f =O[cocompact ℝ] fun x : ℝ => |x| ^ (-b)) (K : Compacts ℝ) :
    (fun x => ‖(f.comp (ContinuousMap.addRight x)).restrict K‖) =O[cocompact ℝ] (|·| ^ (-b)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have h_sum : Summable fun n : ℤ => ‖(f.comp <| ContinuousMap.addRight n).restrict K‖ := by
    refine Summable.of_norm_bounded_eventually_nat (fun n ↦?_) (fun n ↦?_)
    refine Summable.of_norm_bounded_eventually_nat (fun n ↦?_) (fun n ↦?_)
    refine Summable.of_norm_bounded_eventually_nat (fun n ↦?_) (fun n ↦?_)
    simp only [ContinuousMap.addRight_apply, ContinuousMap.addRight_apply, ContinuousMap.addRight_apply,
      ContinuousMap.addRight_apply, ContinuousMap.addRight_apply, ContinuousMap.coe_mk,
      ContinuousMap.addRight_apply, ContinuousMap.addRight_apply, ContinuousMap.coe_mk,
      ContinuousMap.coe_mk, ContinuousMap.coe_mk, ContinuousMap.coe_mk, ContinuousMap.coe_mk,
      ContinuousMap.coe_mk, ContinuousMap.coe_mk, ContinuousMap.coe_mk, ContinuousMap.coe_mk,
      ContinuousMap.coe_mk, ContinuousMap.coe_mk, ContinuousMap.coe_mk, ContinuousMap.coe_mk,
      ContinuousMap.coe_mk, ContinuousMap.coe_mk, ContinuousMap.coe_mk, ContinuousMap.coe_mk,
      ContinuousMa

For theorem:
theorem Real.tsum_eq_tsum_fourierIntegral {f : C(ℝ, ℂ)}
    (h_norm :
      ∀ K : Compacts ℝ, Summable fun n : ℤ => ‖(f.comp <| ContinuousMap.addRight n).restrict K‖)
    (h_sum : Summable fun n : ℤ => 𝓕 f n) (x : ℝ) :
    ∑' n : ℤ, f (x + n) = ∑' n : ℤ, 𝓕 f n * fourier n (x : UnitAddCircle) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : ∀ K : Compacts ℝ, ∀ n, ‖(f.comp (ContinuousMap.addRight n)).restrict K‖ = ‖f.comp (ContinuousMap.addRight n)‖ := by
    intro K hK
    simp only [ContinuousMap.addRight_apply, ContinuousMap.comp_apply, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_comp, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_comp, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, Contin

For theorem:
theorem Real.fourierCoeff_tsum_comp_add {f : C(ℝ, ℂ)}
    (hf : ∀ K : Compacts ℝ, Summable fun n : ℤ => ‖(f.comp (ContinuousMap.addRight n)).restrict K‖)
    (m : ℤ) : fourierCoeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m = 𝓕 f m := by
      let e : C(ℝ, ℂ) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : ∀ K : Compacts ℝ, ∀ n, ‖(f.comp (ContinuousMap.addRight n)).restrict K‖ = ‖f.comp (ContinuousMap.addRight n)‖ := by
    intro K hK
    simp only [ContinuousMap.addRight_apply, ContinuousMap.comp_apply, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_comp, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_comp, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe,
      ContinuousMap.coe_coe, ContinuousMap.coe_coe, ContinuousMap.coe_coe, Contin

For theorem:
theorem Real.fourierCoeff_tsum_comp_add {f : C(ℝ, ℂ)}
    (hf : ∀ K : Compacts ℝ, Summable fun n : ℤ => ‖(f.comp (ContinuousMap.addRight n)).restrict K‖)
    (m : ℤ) : fourierCoeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m = 𝓕 f m := by
      let e : C(ℝ, ℂ) 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Adjoint.lean - 2024-08-20 14:21:23.588480.
---0/3204---
Verifying proof:
:= by
  constructor
  · rintro ⟨i, hi⟩
    simp only [LinearMap.adjoint_inner_left, LinearMap.adjoint_inner_right, LinearMap.adjoint_inner_right,
      LinearMap.adjoint_inner_left, LinearMap.adjoint_inner_right, LinearMap.adjoint_inner_right,
      LinearMap.adjoint_inner_left, LinearMap.adjoint_inner_right, LinearMap.adjoint_inner_right,
      LinearMap.adjoint_inner_left, LinearMap.adjoint_inner_right, LinearMap.adjoint_inner_right,
      LinearMap.adjoint_inner_left, LinearMap.adjoint_inner_right, LinearMap.adjoint_inner_right,
      LinearMap.adjoint_inner_right, LinearMap.adjoint_inner_left, LinearMap.adjoint_inner_right,
      LinearMap.adjoint_inner_left, LinearMap.adjoint_inner_right, LinearMap.adjoint_inner_right,
      LinearMap.adjoint_inner_right, LinearMap.adjoint_inner_right, LinearMap.adjoint_inner_right,
      LinearMap.adjoint_inner_right, LinearMap.adjoint_inner_right, LinearMap.adjoint_inner_right,
      LinearMap.adjoint_inner_right, LinearMap.adjoint_inner_right, LinearMap.adjoint_

For theorem:
theorem eq_adjoint_iff_basis_left {ι : Type*} (b : Basis ι 𝕜 E) (A : E →ₗ[𝕜] F) (B : F →ₗ[𝕜] E) :
    A = LinearMap.adjoint B ↔ ∀ i y, ⟪A (b i), y⟫ = ⟪b i, B y⟫ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [isSelfAdjoint_iff'] at hT ⊢
  simp only [isSelfAdjoint_iff'] at hT ⊢
  simp only [ContinuousLinearMap.coe_comp, ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe,
    ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe,
    ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe,
    ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe,
    ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe,
    ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe,
    ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe,
    ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe,
    ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe,
    ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe, ContinuousLinearMap.coe_coe,
    ContinuousLine

For theorem:
theorem adjoint_conj {T : E →L[𝕜] E} (hT : IsSelfAdjoint T) (S : F →L[𝕜] E) :
    IsSelfAdjoint (ContinuousLinearMap.adjoint S ∘L T ∘L S) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [mul_apply, adjoint_inner_right, inner_self_eq_norm_sq_to_T]

For theorem:
theorem re_inner_adjoint_mul_self_nonneg (T : E →ₗ[𝕜] E) (x : E) :
    0 ≤ re ⟪x, (LinearMap.adjoint T * T) x⟫ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro x y
  simp only [mul_apply, adjoint_inner_left, adjoint_inner_right]

For theorem:
theorem isSymmetric_adjoint_mul_self (T : E →ₗ[𝕜] E) : IsSymmetric (LinearMap.adjoint T * T) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext v
  refine ext_inner_left 𝕜 fun w =>?_
  simp only [adjoint_inner_right, ContinuousLinearMap.coe_comp', Function.comp_apply]

For theorem:
theorem adjoint_comp (A : F →L[𝕜] G) (B : E →L[𝕜] F) : (A ∘L B)† = B† ∘L A† 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · rintro ⟨i, hi⟩
    simp only [LinearMap.adjoint_inner_right, LinearMap.adjoint_inner_left, LinearMap.adjoint_inner_right,
      LinearMap.adjoint_inner_right, LinearMap.adjoint_inner_left, LinearMap.adjoint_inner_right,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

For theorem:
theorem eq_adjoint_iff_basis_right {ι : Type*} (b : Basis ι 𝕜 F) (A : E →ₗ[𝕜] F) (B : F →ₗ[𝕜] E) :
    A = LinearMap.adjoint B ↔ ∀ i x, ⟪A x, b i⟫ = ⟪x, B (b i)⟫ 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Basic.lean - 2024-08-20 14:23:13.195419.
---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne x 0 with (rfl | h₀)
  · simp

For theorem:
theorem inner_eq_norm_mul_iff {x y : E} :
    ⟪x, y⟫ = (‖x‖ : 𝕜) * ‖y‖ ↔ (‖y‖ : 𝕜) • x = (‖x‖ : 𝕜) • y 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [inner_eq_norm_sub_i_smul_mul_self_sub_i_smul_mul_self_sub_i_smul_mul_self_sub_i_smul_mul_self_div_four]

For theorem:
theorem im_inner_eq_norm_sub_i_smul_mul_self_sub_norm_add_i_smul_mul_self_div_four (x y : E) :
    im ⟪x, y⟫ = (‖x - IK • y‖ * ‖x - IK • y‖ - ‖x + IK • y‖ * ‖x + IK • y‖) / 4 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [inner_smul_left, conj_ofReal, Algebra.smul_def]

For theorem:
theorem inner_smul_real_left (x y : E) (r : ℝ) : ⟪(r : 𝕜) • x, y⟫ = r • ⟪x, y⟫ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [Orthonormal.inner_finsupp_supported hv hl, inner_smul_left, inner_smul_right,
    inner_smul_right, inner_smul_right]

For theorem:
theorem Orthonormal.inner_finsupp_eq_zero {v : ι → E} (hv : Orthonormal 𝕜 v) {s : Set ι} {i : ι}
    (hi : i ∉ s) {l : ι →₀ 𝕜} (hl : l ∈ Finsupp.supported 𝕜 𝕜 s) :
    ⟪Finsupp.total ι E 𝕜 v l, v i⟫ = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [norm_sq_diff_sq_diff_sq_diff_sq_diff_sq_diff_sq_diff_sq_diff_sq_diff_sq_diff_sq_diff_sq_diff]
  simp_rw [← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib,
    ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib,
    ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib,
    ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib,
    ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib,
    ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib,
    ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib,
    ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib,
    ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib,
    ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib, ← sum_sub_distrib,
    ← sum_sub_distrib, ← s

For theorem:
theorem OrthogonalFamily.norm_sq_diff_sum [DecidableEq ι] (f : ∀ i, G i) (s₁ s₂ : Finset ι) :
    ‖(∑ i ∈ s₁, V i (f i)) - ∑ i ∈ s₂, V i (f i)‖ ^ 2 =
      (∑ i ∈ s₁ \ s₂, ‖f i‖ ^ 2) + ∑ i ∈ s₂ \ s₁, ‖f i‖ ^ 2 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [@norm_add_mul_self_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero x y]

For theorem:
theorem norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero (x y : F) :
    ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ ⟪x, y⟫_ℝ = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
    simp only [summable_iff_norm_sq_summable]
    refine ⟨fun h =>?_, fun h =>?_⟩
    simp only [sq_eq_iff_eq_norm, sq_eq_zero_iff, norm_eq_zero] at h
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    rw [

For theorem:
theorem OrthogonalFamily.summable_iff_norm_sq_summable [CompleteSpace E] (f : ∀ i, G i) :
    (Summable fun i => V i (f i)) ↔ Summable fun i => ‖f i‖ ^ 2 
Attempt failure.

---0/3204---
Verifying proof:
:=
  { add_left := inner_add_left
    smul_left := fun r x y => by
      simp only [inner_add_left, inner_smul_right, inner_smul_left, inner_smul_right, inner_smul_right,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

For theorem:
theorem _root_.isBoundedBilinearMap_inner [NormedSpace ℝ E] :
    IsBoundedBilinearMap ℝ fun p : E × E => ⟪p.1, p.2⟫ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
  classical
    independent_iff_completeLattice_independent.mpr fun i hi =>?_
    simp only [CompleteLattice.independent_iff_completeLattice_completeLattice_completeLattice,
      CompleteLattice.independent_iff_completeLattice_completeLattice_completeLattice,
      CompleteLattice.independent_iff_completeLattice_completeLattice_completeLattice,
      CompleteLattice.independent_iff_completeLattice_completeLattice_completeLattice,
      CompleteLattice.independent_iff_completeLattice_completeLattice_completeLattice,
      CompleteLattice.independent_iff_completeLattice_completeLattice_completeLattice,
      CompleteLattice.independent_iff_completeLattice_completeLattice_completeLattice,
      CompleteLattice.independent_iff_completeLattice_completeLattice_completeLattice_completeLattice,
      CompleteLattice.independent_iff_completeLattice_completeLattice_completeLattice_completeLattice,
      CompleteLattice.independent_iff_completeLattice_completeLattice_completeLattice_completeLattice_

For theorem:
theorem OrthogonalFamily.independent {V : ι → Submodule 𝕜 E}
    (hV : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) :
    CompleteLattice.Independent V 
Attempt failure.

---0/3204---
Verifying proof:
:=
  nonneg_le_nonneg_of_sq_le_sq (mul_nonneg (sqrt_nonneg _) (sqrt_nonneg _))

For theorem:
theorem norm_inner_le_norm (x y : F) : ‖⟪x, y⟫‖ ≤ ‖x‖ * ‖y‖ 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/ConformalLinearMap.lean - 2024-08-20 14:27:41.826939.
---0/3204---
Verifying proof:
:= by
  constructor
  · rintro ⟨c₁, hc₁, li, rfl⟩
    refine ⟨c₁, hc₁, li, fun u v =>?_⟩
    refine ⟨c₁, hc₁, fun u v =>?_⟩
    rw [← inner_conj_symm, ← inner_conj_symm, ← inner_conj_symm, ← inner_conj_symm]
    exact ⟨c₁, hc₁, li, rfl⟩

For theorem:
theorem isConformalMap_iff (f : E →L[ℝ] F) :
    IsConformalMap f ↔ ∃ c : ℝ, 0 < c ∧ ∀ u v : E, ⟪f u, f v⟫ = c * ⟪u, v⟫ 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Dual.lean - 2024-08-20 14:27:43.955988.
---0/3204---
Verifying proof:
:= by
  refine ext_inner_right 𝕜 _
  intro w
  rw [continuousLinearMapOfBilin_apply]
  intro w
  rw [continuousLinearMapOfBilin_apply]
  intro w
  rw [continuousLinearMapOfBilin_apply]

For theorem:
theorem unique_continuousLinearMapOfBilin {v f : E} (is_lax_milgram : ∀ w, ⟪f, w⟫ = B v w) :
    f = B♯ v 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean - 2024-08-20 14:27:49.436694.
---0/3204---
Verifying proof:
:= by
  suffices ∀ a b : ι, a < b → ⟪gramSchmidt 𝕜 f a, gramSchmidt 𝕜 f a⟫ = 0 by
    rw [← inner_conj_symm, gramSchmidt_def' 𝕜 f a, gramSchmidt_def' 𝕜 f b]
    simp only [gramSchmidt_def' 𝕜 f a, gramSchmidt_def' 𝕜 f a, gramSchmidt_def' 𝕜 f b]
  simp only [gramSchmidt_def' 𝕜 f a, gramSchmidt_def' 𝕜 f a, gramSchmidt_def' 𝕜 f b]
  simp only [gramSchmidt_def' 𝕜 f a, gramSchmidt_def' 𝕜 f a, gramSchmidt_def' 𝕜 f b]

For theorem:
theorem gramSchmidt_orthogonal (f : ι → E) {a b : ι} (h₀ : a ≠ b) :
    ⟪gramSchmidt 𝕜 f a, gramSchmidt 𝕜 f b⟫ = 0 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/LinearPMap.lean - 2024-08-20 14:27:54.887035.
---0/3204---
Verifying proof:
:= by
  ext x y hxy
  · simp only [LinearMap.toPMap_domain, Submodule.mem_toPMap]
  · simp only [LinearMap.toPMap_domain, Submodule.mem_top, exists_prop, Submodule.mem_map,
      Submodule.mem_top, exists_and_right, exists_eq_right, Submodule.mem_top,
      Submodule.mem_top, exists_eq_right, Submodule.mem_top, iff_true_iff]
    exact Submodule.mem_top

For theorem:
theorem toPMap_adjoint_eq_adjoint_toPMap_of_dense (hp : Dense (p : Set E)) :
    (A.toPMap p).adjoint = A.adjoint.toPMap ⊤ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases' h with w hw
  rw [T.mem_adjoint_domain_iff]

For theorem:
theorem mem_adjoint_domain_of_exists (y : F) (h : ∃ w : E, ∀ x : T.domain, ⟪w, x⟫ = ⟪y, T x⟫) :
    y ∈ T†.domain 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/MeanErgodic.lean - 2024-08-20 14:28:04.342458.
---0/3204---
Verifying proof:
:= by
  refine tendsto_birkhoffAverage_of_ker_subset_closure hf hg_proj fun x hx =>?_
  refine tendsto_birkhoffAverage_of_ker_subset_closure?_?_
  · simp only [LinearMap.coe_comp, LinearMap.coe_coe, LinearMap.coe_coe, LinearMap.coe_coe,
    LinearMap.coe_comp, LinearMap.coe_coe, LinearMap.coe_coe, LinearMap.coe_coe,
    LinearMap.coe_comp, LinearMap.coe_coe, LinearMap.coe_coe, LinearMap.coe_coe,
    LinearMap.coe_comp, LinearMap.coe_coe, LinearMap.coe_coe, LinearMap.coe_coe,
    LinearMap.coe_comp, LinearMap.coe_coe, LinearMap.coe_coe, LinearMap.coe_coe,
    LinearMap.coe_comp, LinearMap.coe_coe, LinearMap.coe_coe, LinearMap.coe_coe,
    LinearMap.coe_comp, LinearMap.coe_coe, LinearMap.coe_coe, LinearMap.coe_coe,
    LinearMap.coe_comp, LinearMap.coe_coe, LinearMap.coe_coe, LinearMap.coe_coe,
    LinearMap.coe_comp, LinearMap.coe_coe, LinearMap.coe_coe, LinearMap.coe_coe,
    LinearMap.coe_comp, LinearMap.coe_coe, LinearMap.coe_coe, LinearMap.coe_coe,
    LinearMap.coe_coe, LinearMap.coe_coe, LinearMap.c

For theorem:
theorem LinearMap.tendsto_birkhoffAverage_of_ker_subset_closure [NormedSpace 𝕜 E]
    (f : E →ₗ[𝕜] E) (hf : LipschitzWith 1 f) (g : E →L[𝕜] LinearMap.eqLocus f 1)
    (hg_proj : ∀ x : LinearMap.eqLocus f 1, g x = x)
    (hg_ker : (LinearMap.ker g : Set E) ⊆ closure (LinearMap.range (f - 1))) (x : E) :
    Tendsto (birkhoffAverage 𝕜 f _root_.id · x) atTop (𝓝 (g x)) := by
    obtain ⟨y, hy, z, hz, rfl⟩ : ∃ y, g y = 0 ∧ ∃ z, IsFixedPt f z ∧ x = y + z :=
    ⟨x - g x, by simp [hg_proj], g x, (g x).2, by simp⟩
    suffices Tendsto (birkhoffAverage 𝕜 f _root_.id · y) atTop (𝓝 0) by
    have hgz : g z = z := congr_arg Subtype.val (hg_proj ⟨z, hz⟩)
    simpa [hy, hgz, birkhoffAverage, birkhoffSum, Finset.sum_add_distrib, smul_add]
      using this.add (hz.tendsto_birkhoffAverage 𝕜 _root_.id)
    have : IsClosed {x | Tendsto (birkhoffAverage 𝕜 f _root_.id · x) atTop (𝓝 0)} :=
    isClosed_setOf_tendsto_birkhoffAverage 𝕜 hf uniformContinuous_id continuous_const
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/NormPow.lean - 2024-08-20 14:28:06.454315.
---0/3204---
Verifying proof:
:= by
  rw [contDiff_one_iff_fderiv]
  refine ⟨fun x ↦ hasFDerivAt_norm_rpow x hp |>.differentiableAt,?_⟩
  refine ⟨fun x ↦ hasFDerivAt_norm_rpow x hp |>.differentiableAt,?_⟩
  refine ⟨fun x ↦ hasFDerivAt_norm_rpow x hp |>.differentiableAt,?_⟩
  refine ⟨fun x ↦ hasFDerivAt_norm_rpow x hp |>.differentiableAt,?_⟩
  refine ⟨fun x ↦ hasFDerivAt_norm_rpow x hp |>.differentiableAt,?_⟩
  refine ⟨fun x ↦ hasFDerivAt_norm_rpow x hp |>.differentiableAt,?_⟩
  refine ⟨fun x ↦ hasFDerivAt_norm_rpow x hp |>.differentiableAt,?_⟩
  refine ⟨fun x ↦ hasFDerivAt_norm_rpow x hp |>.differentiableAt,?_⟩
  refine ⟨fun x ↦ hasFDerivAt_norm_rpow x hp |>.differentiableAt,?_⟩
  refine ⟨fun x ↦ hasFDerivAt_norm_rpow x hp |>.differentiableAt,?_⟩
  refine ⟨fun x ↦ hasFDerivAt_norm_rpow x hp |>.differentiableAt,?_⟩
  refine ⟨fun x ↦ hasFDerivAt_norm_rpow x hp |>.differentiableAt,?_⟩
  refine ⟨fun x ↦ hasFDerivAt_norm_rpow x hp |>.differentiableAt,?_

For theorem:
theorem contDiff_norm_rpow {p : ℝ} (hp : 1 < p) : ContDiff ℝ 1 (fun x : E ↦ ‖x‖ ^ p) 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Orientation.lean - 2024-08-20 14:28:11.087024.
---0/3204---
Verifying proof:
:= by
  cases' n with n
  · classical
    have : positiveOrientation b = -b.toBasis.orientation := by
      simp only [volumeForm, LinearIsometryEquiv.toLinearMap_apply, LinearIsometryEquiv.toLinearMap_apply,
      LinearIsometryEquiv.toLinearMap_apply, LinearIsometryEquiv.toLinearMap_apply,
      LinearIsometryEqu

For theorem:
theorem volumeForm_robust_neg (b : OrthonormalBasis (Fin n) ℝ E) (hb : b.toBasis.orientation ≠ o) :
    o.volumeForm = -b.toBasis.det 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [e.toBasis.det.eq_smul_basis_det f.toBasis]
  simp

For theorem:
theorem det_eq_neg_det_of_opposite_orientation (h : e.toBasis.orientation ≠ f.toBasis.orientation) :
    e.toBasis.det = -f.toBasis.det 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  haveI := Fin.pos_iff_nonempty.mpr hn
  haveI := Fin.pos_iff_nonempty.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_iff_ne_zero.mpr hn
  haveI := Fin.pos_of_ne_zero hn
  haveI := Fin.pos_iff_ne_zero.m

For theorem:
theorem finOrthonormalBasis_orientation (hn : 0 < n) (h : finrank ℝ E = n)
    (x : Orientation ℝ E (Fin n)) : (x.finOrthonormalBasis hn h).toBasis.orientation = x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases' n with n
  · refine Finset.prod_congr rfl fun i _ =>?_
    simp only [Finset.prod_eq_zero_iff, Finset.mem_univ, forall_true_left, Finset.prod_const_one,
      Finset.prod_const_one, Finset.prod_const_one, Finset.prod_const_one]

For theorem:
theorem abs_volumeForm_apply_of_pairwise_orthogonal {v : Fin n → E}
    (hv : Pairwise fun i j => ⟪v i, v j⟫ = 0) : |o.volumeForm v| = ∏ i : Fin n, ‖v i‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases' n with n
  · refine o.eq_or_eq_neg_of_isEmpty.elim?_?_ <;> rintro rfl
  · simp [volumeForm_zero_neg]

For theorem:
theorem volumeForm_neg_orientation : (-o).volumeForm = -o.volumeForm 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply e.orthonormal.orthonormal_of_forall_eq_or_eq_neg
  simpa using e.toBasis.adjustToOrientation x

For theorem:
theorem orthonormal_adjustToOrientation : Orthonormal ℝ (e.toBasis.adjustToOrientation x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases' n with n
  · refine o.eq_or_eq_neg_of_isEmpty.elim?_?_ <;> rintro rfl <;> simp

For theorem:
theorem abs_volumeForm_apply_le (v : Fin n → E) : |o.volumeForm v| ≤ ∏ i : Fin n, ‖v i‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [volumeForm, LinearIsometryEquiv.coe_toLinearMap, Function.comp_apply,
    LinearIsometryEquiv.coe_toLinearMap, Function.comp_apply]

For theorem:
theorem volumeForm_comp_linearIsometryEquiv (φ : E ≃ₗᵢ[ℝ] E)
    (hφ : 0 < LinearMap.det (φ.toLinearEquiv : E →ₗ[ℝ] E)) (x : Fin n → E) :
    o.volumeForm (φ ∘ x) = o.volumeForm x 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Orthogonal.lean - 2024-08-20 14:28:57.923143.
---0/3204---
Verifying proof:
:= by
  rw [orthogonal_eq_inter K]
  have := fun v : K => ContinuousLinearMap.isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 𝕜 (v : E))
  convert isClosed_ker (innerSL 

For theorem:
theorem isClosed_orthogonal : IsClosed (Kᗮ : Set E) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨inner_right_of_mem_orthogonal (mem_span_singleton_self u),?_⟩
  intro hv w hw

For theorem:
theorem mem_orthogonal_singleton_iff_inner_right {u v : E} : v ∈ (𝕜 ∙ u)ᗮ ↔ ⟪u, v⟫ = 0 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/PiL2.lean - 2024-08-20 14:29:05.928645.
---0/3204---
Verifying proof:
:= by
  obtain ⟨u, hu⟩ := hv.exists_orthonormalBasis_extension hv
  refine ⟨u,?_,?_,?_⟩
  · rintro ⟨u, hu⟩
    refine ⟨u, hu⟩
    refine ⟨u,?_,?_,?_,?_⟩
    · rintro ⟨u, hu⟩
      refine ⟨u, hu⟩
      simp only [Finset.mem_image, Finset.mem_coe, Finset.mem_image, forall_exists_index,?_⟩
    · simp only [Finset.mem_image, Finset.mem_coe, Finset.mem_coe, Finset.mem_image, forall_exists_index,
        Finset.mem_univ, forall_true_left, Finset.mem_univ, forall_true_left, Finset.mem_image,
      forall_exists_index, forall_apply_eq_imp_iff⟩
      exact ⟨u, Finset.mem_image_of_mem _ (Finset.mem_image_of_mem _ (Finset.mem_image_of_mem _ hu)),?_⟩
    · simp only [Finset.mem_image, Finset.mem_image, Finset.mem_coe, Finset.mem_image,
      Finset.mem_image, forall_exists_index, forall_apply_eq_imp_iff, forall_exists_index,
      forall_exists_index, forall_apply_eq_imp_iff, forall_exists_index, forall_apply_eq_imp_iff,
      Finset.mem_image, forall_exists_index, forall

For theorem:
theorem Orthonormal.exists_orthonormalBasis_extension (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    ∃ (u : Finset E) (b : OrthonormalBasis u 𝕜 E), v ⊆ u ∧ ⇑b = ((↑) : u → E) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← orthonormalBasis_extension 𝕜 (s.restrict v)]
  exact hv.orthonormalBasis_extension v

For theorem:
theorem Orthonormal.exists_orthonormalBasis_extension_of_card_eq {ι : Type*} [Fintype ι]
    (card_ι : finrank 𝕜 E = Fintype.card ι) {v : ι → E} {s : Set ι}
    (hv : Orthonormal 𝕜 (s.restrict v)) : ∃ b : OrthonormalBasis ι 𝕜 E, ∀ i ∈ s, b i = v i 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Projection.lean - 2024-08-20 14:29:37.938167.
---0/3204---
Verifying proof:
:= by
  constructor
  · rintro ⟨b, hb⟩
    refine ⟨fun h =>?_, fun ⟨b, hb⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨b, hb⟩ =>?_⟩
    refine ⟨b,?_⟩
    refine ⟨b,?_⟩
    rintro ⟨b, hb⟩
    refine ⟨b,?_⟩
    · rintro ⟨b, hb⟩
      refine ⟨b,?_⟩
      rintro ⟨b, hb⟩
      exact ⟨b, hb.subset_closure, fun ⟨b, hb⟩ =>?_⟩
  · rintro ⟨b, hb⟩
    exact ⟨b, hb.subset_closure, fun ⟨b, hb⟩ => ⟨b, hb.subset_closure,?_⟩⟩
  · rintro ⟨b, hb⟩
    exact ⟨b, hb.subset_closure, fun ⟨b, hb⟩ => ⟨b, hb.subset_closure,?_⟩⟩
  · rintro ⟨b, hb⟩
    exact ⟨b, hb.subset_closure, fun ⟨b, hb⟩ => ⟨b, hb.subset_closure,?_⟩⟩
  · rintro ⟨b, hb⟩
    exact ⟨b, hb.subset_closure, fun ⟨b, hb⟩ => ⟨b, hb.subset_closure,?_⟩⟩
  · rintro ⟨b, hb⟩
    exact ⟨b, hb.subset_closure, fun ⟨b, hb⟩ => ⟨b, hb.subset_closure,?_⟩⟩
  · rintro ⟨b, hb⟩
    exact ⟨b, hb.subset_closure, fun ⟨b, hb⟩ => ⟨b, h

For theorem:
theorem maximal_orthonormal_iff_basis_of_finiteDimensional (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    (∀ u ⊇ v, Orthonormal 𝕜 ((↑) : u → E) → u = v) ↔ ∃ b : Basis v 𝕜 E, ⇑b = ((↑) : v → E) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  convert Submodule.finrank_add_inf_finrank_orthogonal 𝕜 K using 1
  rw [← finrank_eq_card_orthogonal 𝕜 K, ← finrank_eq_card_orthogonal 𝕜 K,
    ← finrank_eq_card_orthogonal 𝕜 K, ← finrank_eq_card_orthogonal 𝕜 K,
    ← finrank_eq_card_orthogonal 𝕜 K, ← finrank_eq_card_orthogonal 𝕜 K,
    ← finrank_eq_card_orthogonal 𝕜 K, ← finrank_eq_card_orthogonal 𝕜 K,
    ← finrank_eq_card_orthogonal 𝕜 K, ← finrank_eq_card_orthogonal 𝕜 K,
    ← finrank_eq_card_orthogonal 𝕜 K, ← finrank_eq_card_orthogonal 𝕜 K,
    ← finrank_eq_card_orthogonal 𝕜 K, ← finrank_eq_card_orthogonal 𝕜 K,
    ← finrank_eq_card_orthogonal 𝕜 K, ← finrank_eq_card_orthogonal 𝕜 K,
    ← finrank_eq_card_orthogonal 𝕜 K, ← finrank_eq_card_orthogonal 𝕜 K,
    ← finrank_eq_card_orthogonal 𝕜 K, ← finrank_eq_card_orthogonal 𝕜 K,
    ← finrank_eq_card_orthogonal 𝕜 K, ← finrank_eq_card_orthogonal 𝕜 K, ← finrank_eq_card_orthogonal 𝕜 K,
    

For theorem:
theorem Submodule.finrank_add_finrank_orthogonal [FiniteDimensional 𝕜 E] (K : Submodule 𝕜 E) :
    finrank 𝕜 K + finrank 𝕜 Kᗮ = finrank 𝕜 E 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    refine ⟨fun h =>?_, fun h =>?_⟩
    simp only [Submodule.orthogonalComplement_eq_bot_iff_orthogonalComplement_eq_bot, Submodule.orthogonalComplement_eq_bot,
      Submodule.orthogonalComplement_eq_bot_iff_orthogonalComplement_eq_bot, fun h =>?_⟩
  · intro h
    simp only [Submodule.orthogonalComplement_eq_bot_iff_orthogonalComplement_eq_bot, Submodule.orthogonalComplement_eq_bot,
      Submodule.orthogonalComplement_eq_bot_iff, Submodule.orthogonalComplement_eq_bot_iff,
      Submodule.orthogonalComplement_eq_bot_iff, Submodule.orthogonalComplement_eq_bot_iff,
      Submodule.orthogonalComplement_eq_bot_iff, Submodule.orthogonalComplement_eq_bot_iff,
      Submodule.orthogonalComplement_eq_bot_iff, Submodule.orthogonalComplement_eq_bot_iff,
      Submodule.orthogonalComplement_eq_bot_iff, Submodule.orthogonalComplement_eq_bot_iff,
      Submodule.orthogonalComplement_eq_bot_iff, Submodule.orthogonalComplement_eq_bot,
      Submodule.orthogonalComplement_eq_bot_i

For theorem:
theorem maximal_orthonormal_iff_orthogonalComplement_eq_bot (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    (∀ u ⊇ v, Orthonormal 𝕜 ((↑) : u → E) → u = v) ↔ (span 𝕜 v)ᗮ = ⊥ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases hv : v = 0
  · rw [hv, eq_comm, orthogonalProjection_singleton]
    simp only [orthogonalProjection_apply, inner_smul_left, inner_smul_right, orthogonalProjection_singleton,
    orthogonalProjec

For theorem:
theorem orthogonalProjection_singleton {v : E} (w : E) :
    (orthogonalProjection (𝕜 ∙ v) w : E) = (⟪v, w⟫ / ((‖v‖ ^ 2 : ℝ) : 𝕜)) • v 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [OrthogonalFamily.projection_directSum_coeAddHom, OrthogonalFamily.projection_apply,
    OrthogonalFamily.projection_apply]

For theorem:
theorem OrthogonalFamily.projection_directSum_coeAddHom [DecidableEq ι] {V : ι → Submodule 𝕜 E}
    (hV : OrthogonalFamily 𝕜 (fun i => V i) fun i => (V i).subtypeₗᵢ) (x : ⨁ i, V i) (i : ι)
    [CompleteSpace (V i)] :
    orthogonalProjection (V i) (DirectSum.coeAddMonoidHom V x) = x i 
Attempt failure.

---0/3204---
Verifying proof:
:= fun u => by
  obtain ⟨v, hv₁, hv₂⟩ := exists_norm_eq_iInf_of_complete_convex h₁ h₂ h₂
  refine ⟨v, hv,?_⟩
  refine ⟨v, hv,?_⟩
  refine ⟨v, hv,?_⟩
  · rintro ⟨w, hwK, hw⟩
    rcases h₂ with ⟨w, hwK, hwK⟩
    exact ⟨w, hwK, hwK⟩
  · exact ⟨w, hwK, hwK⟩
    refine ⟨w, hwK,?_⟩
    refine exists_norm_eq_iInf_of_complete_convex h₁ hwK⟩
    refine ⟨w, hwK,?_⟩
    refine exists_norm_eq_iInf_of_complete_convex h₁ hwK⟩
    refine ⟨w, hwK,?_⟩
    refine exists_norm_eq_iInf_of_complete_convex h₁ hwK⟩
    refine ⟨w, hwK,?_⟩
    refine exists_norm_eq_iInf_of_complete_convex hwK⟩
    refine ⟨w, hwK,?_⟩
    · exact ⟨w, hwK,?_⟩
    · exact ⟨w, hwK, hw⟩
    · exact ⟨w, hwK, hw⟩
    · exact ⟨w, hwK, hwK⟩
      refine ⟨w, hwK,?_⟩
      · refine ⟨w, hwK,?_⟩
      · exact ⟨w, hwK,?_⟩
      · exact ⟨w, hwK, hwK⟩
      refine exists_norm_eq_iInf_of_complete_convex hwK⟩
      refine exists_norm_eq_i

For theorem:
theorem exists_norm_eq_iInf_of_complete_convex {K : Set F} (ne : K.Nonempty) (h₁ : IsComplete K)
    (h₂ : Convex ℝ K) : ∀ u : F, ∃ v ∈ K, ‖u - v‖ = ⨅ w : K, ‖u - w‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  haveI : FiniteDimensional 𝕜 E := Module.Finite.of_finiteDimensional 𝕜 E
  haveI : FiniteDimensional 𝕜 E := Module.Finite.of_finiteDimensional 𝕜 E
  haveI : FiniteDimensional 𝕜 E := Module.Finite.of_finiteDimensional 𝕜 E
  haveI : FiniteDimensional 𝕜 E := Module.Finite.of_finiteDimensional 𝕜 E
  haveI : FiniteDimensional 𝕜 E := Module.Finite.of_finiteDimensional 𝕜 E
  haveI : FiniteDimensional 𝕜 E := Module.Finite.of_finiteDimensional 𝕜 E
  haveI : FiniteDimensional 𝕜 E := Module.Finite.of_finiteDimensional 𝕜 E
  haveI : FiniteDimensional 𝕜 E := Module.Finite.of_finiteDimensional 𝕜 E
  haveI : FiniteDimensional 𝕜 E := Module.Finite.of_finiteDimensional 𝕜 E
  haveI : FiniteDimensional 𝕜 E := Module.Finite.of_finiteDimensional 𝕜 E
  haveI : FiniteDimensional 𝕜 E := Module.Finite.of_finiteDimensional 𝕜 E
  haveI : FiniteDimensional 𝕜 E := Module.Finite.of_finiteDimensional 𝕜 E
  haveI : FiniteDimensional 𝕜 E := Module.Finite.of_fi

For theorem:
theorem finrank_orthogonal_span_singleton {n : ℕ} [_i : Fact (finrank 𝕜 E = n + 1)] {v : E}
    (hv : v ≠ 0) : finrank 𝕜 (𝕜 ∙ v)ᗮ = n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · rintro ⟨b, hb⟩
    refine ⟨fun h =>?_, fun ⟨b, hb⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨b, hb⟩ =>?_⟩
    refine ⟨b,?_⟩
    refine ⟨b,?_⟩
    rintro ⟨b, hb⟩
    refine ⟨b,?_⟩
    · rintro ⟨b, hb⟩
      refine ⟨b,?_⟩
      rintro ⟨b, hb⟩
      exact ⟨b, hb.subset_closure, fun ⟨b, hb⟩ =>?_⟩
  · rintro ⟨b, hb⟩
    exact ⟨b, hb.subset_closure, fun ⟨b, hb⟩ => ⟨b, hb.subset_closure,?_⟩⟩
  · rintro ⟨b, hb⟩
    exact ⟨b, hb.subset_closure, fun ⟨b, hb⟩ => ⟨b, hb.subset_closure,?_⟩⟩
  · rintro ⟨b, hb⟩
    exact ⟨b, hb.subset_closure, fun ⟨b, hb⟩ => ⟨b, hb.subset_closure,?_⟩⟩
  · rintro ⟨b, hb⟩
    exact ⟨b, hb.subset_closure, fun ⟨b, hb⟩ => ⟨b, hb.subset_closure,?_⟩⟩
  · rintro ⟨b, hb⟩
    exact ⟨b, hb.subset_closure, fun ⟨b, hb⟩ => ⟨b, hb.subset_closure,?_⟩⟩
  · rintro ⟨b, hb⟩
    exact ⟨b, hb.subset_closure, fun ⟨b, hb⟩ => ⟨b, h

For theorem:
theorem maximal_orthonormal_iff_basis_of_finiteDimensional (hv : Orthonormal 𝕜 ((↑) : v → E)) :
    (∀ u ⊇ v, Orthonormal 𝕜 ((↑) : u → E) → u = v) ↔ ∃ b : Basis v 𝕜 E, ⇑b = ((↑) : v → E) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h w hw =>?_, fun h w hw =>?_⟩
  simp only [norm_eq_iInf_iff_real_inner_le_zero, norm_eq_iInf_iff_real_inner_le_zero]

For theorem:
theorem norm_eq_iInf_iff_real_inner_le_zero {K : Set F} (h : Convex ℝ K) {u : F} {v : F}
    (hv : v ∈ K) : (‖u - v‖ = ⨅ w : K, ‖u - w‖) ↔ ∀ w ∈ K, ⟪u - v, w - v⟫_ℝ ≤ 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [orthogonalProjection_tendsto_self]
  exact orthogonalProjection_monotone hU hU'

For theorem:
theorem orthogonalProjection_tendsto_self [CompleteSpace E] {ι : Type*} [SemilatticeSup ι]
    (U : ι → Submodule 𝕜 E) [∀ t, CompleteSpace (U t)] (hU : Monotone U) (x : E)
    (hU' : ⊤ ≤ (⨆ t, U t).topologicalClosure) :
    Filter.Tendsto (fun t => (orthogonalProjection (U t) x : E)) atTop (𝓝 x) 
Attempt failure.

---0/3204---
Verifying proof:
:= fun u => by
  obtain ⟨v, hv₁, hv₂⟩ := exists_norm_eq_iInf_of_complete_convex h₁ h₂ h₂
  refine ⟨v, hv,?_⟩
  refine ⟨v, hv,?_⟩
  refine ⟨v, hv,?_⟩
  · rintro ⟨w, hwK, hw⟩
    rcases h₂ with ⟨w, hwK, hwK⟩
    exact ⟨w, hwK, hwK⟩
  · exact ⟨w, hwK, hwK⟩
    refine ⟨w, hwK,?_⟩
    refine exists_norm_eq_iInf_of_complete_convex h₁ hwK⟩
    refine ⟨w, hwK,?_⟩
    refine exists_norm_eq_iInf_of_complete_convex h₁ hwK⟩
    refine ⟨w, hwK,?_⟩
    refine exists_norm_eq_iInf_of_complete_convex h₁ hwK⟩
    refine ⟨w, hwK,?_⟩
    refine exists_norm_eq_iInf_of_complete_convex hwK⟩
    refine ⟨w, hwK,?_⟩
    · exact ⟨w, hwK,?_⟩
    · exact ⟨w, hwK, hw⟩
    · exact ⟨w, hwK, hw⟩
    · exact ⟨w, hwK, hwK⟩
      refine ⟨w, hwK,?_⟩
      · refine ⟨w, hwK,?_⟩
      · exact ⟨w, hwK,?_⟩
      · exact ⟨w, hwK, hwK⟩
      refine exists_norm_eq_iInf_of_complete_convex hwK⟩
      refine exists_norm_eq_i

For theorem:
theorem exists_norm_eq_iInf_of_complete_convex {K : Set F} (ne : K.Nonempty) (h₁ : IsComplete K)
    (h₂ : Convex ℝ K) : ∀ u : F, ∃ v ∈ K, ‖u - v‖ = ⨅ w : K, ‖u - w‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases hv : v = 0
  · rw [hv, eq_comm, orthogonalProjection_singleton]
    simp only [orthogonalProjection_apply, inner_smul_left, inner_smul_right, orthogonalProjection_singleton,
    orthogonalProjec

For theorem:
theorem orthogonalProjection_singleton {v : E} (w : E) :
    (orthogonalProjection (𝕜 ∙ v) w : E) = (⟪v, w⟫ / ((‖v‖ ^ 2 : ℝ) : 𝕜)) • v 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨l, hl⟩ : ∃ l : List F, ker (ContinuousLinearMap.id ℝ F - φ) ◮ ≤ n := by
    rw [← finrank_eq_card_chooseBasisIndex, ← finrank_eq_card_chooseBasisIndex] at hl
    refine ⟨l,?_,?_⟩
    simp only [LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_ap

For theorem:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ℝ F] {n : ℕ}
    (φ : F ≃ₗᵢ[ℝ] F) (hn : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ ≤ n) :
    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod := by
      induction' n with n IH generalizing φ
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h w hw =>?_, fun h w hw =>?_⟩
  simp only [norm_eq_iInf_iff_real_inner_le_zero, norm_eq_iInf_iff_real_inner_le_zero]

For theorem:
theorem norm_eq_iInf_iff_real_inner_le_zero {K : Set F} (h : Convex ℝ K) {u : F} {v : F}
    (hv : v ∈ K) : (‖u - v‖ = ⨅ w : K, ‖u - w‖) ↔ ∀ w ∈ K, ⟪u - v, w - v⟫_ℝ ≤ 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h w hw =>?_, fun h w hw =>?_⟩
  simp only [norm_eq_iInf_iff_real_inner_le_zero, norm_eq_iInf_iff_real_inner_le_zero]

For theorem:
theorem norm_eq_iInf_iff_real_inner_le_zero {K : Set F} (h : Convex ℝ K) {u : F} {v : F}
    (hv : v ∈ K) : (‖u - v‖ = ⨅ w : K, ‖u - w‖) ↔ ∀ w ∈ K, ⟪u - v, w - v⟫_ℝ ≤ 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply le_antisymm
  · convert Submodule.orthogonal_orthogonal_monotone K.le_topologicalClosure

For theorem:
theorem Submodule.orthogonal_orthogonal_eq_closure [CompleteSpace E] :
    Kᗮᗮ = K.topologicalClosure 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [ContinuousLinearMap.id_apply]

For theorem:
theorem id_eq_sum_orthogonalProjection_self_orthogonalComplement [HasOrthogonalProjection K] :
    ContinuousLinearMap.id 𝕜 E =
      K.subtypeL.comp (orthogonalProjection K) + Kᗮ.subtypeL.comp (orthogonalProjection Kᗮ) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← orthogonalProjection_eq_self_iff, reflection_apply, sub_eq_iff_eq_add', ← two_smul ℕ, ←
    two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ←
    two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ←
    two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ←
    two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ←
    two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ←
    two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ←
    two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ←
    two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ←
    two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ←
    two_smul ℕ, ← two_smul ℕ, ← two_smul ℕ, ← two_smul 

For theorem:
theorem reflection_eq_self_iff (x : E) : reflection K x = x ↔ x ∈ K 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h w hw =>?_, fun h w hw =>?_⟩
  simp only [norm_eq_iInf_iff_real_inner_le_zero, norm_eq_iInf_iff_real_inner_le_zero]

For theorem:
theorem norm_eq_iInf_iff_real_inner_le_zero {K : Set F} (h : Convex ℝ K) {u : F} {v : F}
    (hv : v ∈ K) : (‖u - v‖ = ⨅ w : K, ‖u - w‖) ↔ ∀ w ∈ K, ⟪u - v, w - v⟫_ℝ ≤ 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h w hw =>?_, fun h w hw =>?_⟩
  · rw [norm_eq_iInf_iff_real_inner_eq_zero]
    refine ⟨fun h w hw =>?_, fun h w hw =>?_⟩
    simp only [norm_eq_iInf_iff_real_inner_eq_zero] at hw
    simp only [norm_eq_iInf_iff_real_inner_eq_zero] at hw
    simp only [norm_eq_iInf_iff_real_inner_eq_zero] at hw
    simp only [norm_eq_iInf_iff_real_inner_eq_zero] at hw
    simp only [norm_eq_iInf_iff_real_inner_eq_zero] at hw
    simp only [norm_eq_iInf_iff_real_inner_eq_zer

For theorem:
theorem norm_eq_iInf_iff_real_inner_eq_zero (K : Submodule ℝ F) {u : F} {v : F} (hv : v ∈ K) :
    (‖u - v‖ = ⨅ w : (↑K : Set F), ‖u - w‖) ↔ ∀ w ∈ K, ⟪u - v, w⟫_ℝ = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨l, hl⟩ : ∃ l : List F, ker (ContinuousLinearMap.id ℝ F - φ) ◮ ≤ n := by
    rw [← finrank_eq_card_chooseBasisIndex, ← finrank_eq_card_chooseBasisIndex] at hl
    refine ⟨l,?_,?_⟩
    simp only [LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_apply, LinearIsometryEquiv.reflections_apply,
      LinearIsometryEquiv.reflections_ap

For theorem:
theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional ℝ F] {n : ℕ}
    (φ : F ≃ₗᵢ[ℝ] F) (hn : finrank ℝ (ker (ContinuousLinearMap.id ℝ F - φ))ᗮ ≤ n) :
    ∃ l : List F, l.length ≤ n ∧ φ = (l.map fun v => reflection (ℝ ∙ v)ᗮ).prod := by
      induction' n with n IH generalizing φ
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [orthogonalProjection_tendsto_iff_tendsto_subseq_tendsto]
  simp only [orthogonalProjection_tendsto_iff_tendsto_subseq_tendsto, Submodule.tendsto_subtype_val,
    Submodule.tendsto_subtype_val, Submodule.tendsto_subtype_val, Submodule.tendsto_subtype_val,
    Submodule.tendsto_subtype_val, Submodule.tendsto_subtype_val]

For theorem:
theorem orthogonalProjection_tendsto_closure_iSup [CompleteSpace E] {ι : Type*} [SemilatticeSup ι]
    (U : ι → Submodule 𝕜 E) [∀ i, CompleteSpace (U i)] (hU : Monotone U) (x : E) :
    Filter.Tendsto (fun i => (orthogonalProjection (U i) x : E)) atTop
      (𝓝 (orthogonalProjection (⨆ i, U i).topologicalClosure x : E)) 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Rayleigh.lean - 2024-08-20 14:35:56.513811.
---0/3204---
Verifying proof:
:= by
  refine hasEigenvector_iff_hasEigenvector.mpr fun x hx =>?_
  refine hasEigenvector_iff_hasEigenvector.mpr fun x hx =>?_
  refine hasEigenvector_iff_hasEigenvector.mpr fun x hx =>?_
  refine hasEigenvector_iff_hasEigenvector.mpr fun x hx =>?_
  refine hasEigenvector_iff_hasEigenvector.mpr fun x hx =>?_
  refine hasEigenvector_iff_hasEigenvector.mpr fun x hx =>?_
  refine hasEigenvector_iff_hasEigenvector.mpr fun x hx =>?_
  refine hasEigenvector_iff_hasEigenvector.mpr fun x hx =>?_
  refine hasEigenvector_iff_hasEigenvector.mpr fun x hx =>?_
  refine hasEigenvector_iff_hasEigenvector.mpr fun y hy =>?_
  have hy₀ : y ∈ sphere (0 : E) ‖x₀‖ := by simpa using hy₀
  have hy₀ : y ∈ sphere (0 : E) ‖x₀‖ := by simpa using hy₀
  have hy₀ : y ∈ sphere (0 : E) ‖x₀‖ := by simpa using hy₀
  have hy₀' : y ∈ sphere (0 : E) ‖x₀‖ := by simpa using hy₀
  have hy₀' : y ∈ sphere (0 : E) ‖x₀‖ := by simpa using hy₀
  have hy₀' : y ∈ sphere (0 : E) ‖

For theorem:
theorem hasEigenvector_of_isMaxOn (hT : IsSelfAdjoint T) {x₀ : E} (hx₀ : x₀ ≠ 0)
    (hextr : IsMaxOn T.reApplyInnerSelf (sphere (0 : E) ‖x₀‖) x₀) :
    HasEigenvector (T : E →ₗ[𝕜] E) (↑(⨆ x : { x : E // x ≠ 0 }, T.rayleighQuotient x)) x₀ 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/Symmetric.lean - 2024-08-20 14:36:00.833559.
---0/3204---
Verifying proof:
:= by
  rsuffices ⟨r, hr⟩ = ⟪T x, x⟫ by
    simp only [reApplyInnerSelf, inner_smul_left, inner_smul_right, inner_smul_left, inner_smul_right,
      inner_smul_left, inner_smul_right, inner_smul_left, inner_smul_right, inner_smul_left,
      inner_smul_right, inner_smul_left, inner_smul_right, inner_smul_left, inner_smul_right,
      inner_smul_left, inner_smul_right, inner_smul_left, inner_smul_right, inner_smul_left,
      inner_smul_right, inner_smul_left, inner_smul_right, inner_smul_left, inner_smul_right,
      inner_smul_right, inner_smul_left, inner_smul_right, inner_smul_left, inner_smul_right,
      inner_smul_right, inner_smul_left, inner_smul_right, inner_smul_left, inner_smul_right,
      inner_smul_right, inner_smul_left, inner_smul_right, inner_smul_left, inner_smul_right,
      inner_smul_right, inner_smul_left, inner_smul_right, inner_smul_left, inner_smul_right,
      inner_smul_right, inner_smul_left, inner_smul_right, inner_smul_left, inner_smul_right,
      inner_smul_right, inne

For theorem:
theorem IsSymmetric.coe_reApplyInnerSelf_apply {T : E →L[𝕜] E} (hT : IsSymmetric (T : E →ₗ[𝕜] E))
    (x : E) : (T.reApplyInnerSelf x : 𝕜) = ⟪T x, x⟫ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [inner_add_left, inner_add_right, inner_add_right, inner_add_right, inner_add_right,
    inner_add_left, inner_add_right, inner_add_right, inner_add_right, inner_add_right,
    inner_add_right, inner_add_right, inner_add_right, inner_add_right, inner_add_right,
    inner_add_right, inner_add_right, inner_add_right, inner_add_right, inner_add_right,
    inner_add_right, inner_add_right, inner_add_right, inner_add_right, inner_add_right,
    inner_add_right, inner_add_right, inner_add_right, inner_add_right, inner_add_right,
    inner_add_right, inner_add_right, inner_add_right, inner_add_right, inner_add_right,
    inner_add_right, inner_add_right, inner_add_right, inner_add_right, inner_add_right,
    inner_add_right, inner_add_right, inner_add_right, inner_add_right, inner_add_right,
    inner_add_right, inner_add_right, inner_add_right, inner_add_right, inner_add_right,
    inner_add_right, inner_add_right, inner_add_right, inner_add_right, inner_add_right,
    inner_add_right, inner_add_right, 

For theorem:
theorem IsSymmetric.inner_map_polarization {T : E →ₗ[𝕜] E} (hT : T.IsSymmetric) (x y : E) :
    ⟪T x, y⟫ =
      (⟪T (x + y), x + y⟫ - ⟪T (x - y), x - y⟫ - I * ⟪T (x + (I : 𝕜) • y), x + (I : 𝕜) • y⟫ +
          I * ⟪T (x - (I : 𝕜) • y), x - (I : 𝕜) • y⟫) /
        4 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/TwoDim.lean - 2024-08-20 14:36:06.921830.
---0/3204---
Verifying proof:
:= by
  rw [← Complex.orientation_map (Fin 2) f.toLinearEquiv o, hf, Complex.orientation_map hf]

For theorem:
theorem kahler_map_complex (f : E ≃ₗᵢ[ℝ] ℂ)
    (hf : Orientation.map (Fin 2) f.toLinearEquiv o = Complex.orientation) (x y : E) :
    o.kahler x y = conj (f x) * f y 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  convert o.rightAngleRotation_eq_det_toLinearMap φ hφ
  simp only [LinearMap.det_toLinearMap, LinearMap.det_toLinearMap, LinearEquiv.coe_coe,
    LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe,
    LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe,
    LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe,
    LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe,
    LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe,
    LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe,
    LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe,
    LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe,
    LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe,
    LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.coe_coe, LinearEquiv.c

For theorem:
theorem linearIsometryEquiv_comp_rightAngleRotation (φ : E ≃ₗᵢ[ℝ] E)
    (hφ : 0 < LinearMap.det (φ.toLinearEquiv : E →ₗ[ℝ] E)) (x : E) : φ (J x) = J (φ x) 
Attempt failure.

Working on Mathlib/Analysis/InnerProductSpace/l2Space.lean - 2024-08-20 14:36:35.144040.
---0/3204---
Verifying proof:
:= by
  refine le_antisymm?_?_
  · simp only [LinearMap.range_eq_top, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_eq_top, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_eq_top, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_

For theorem:
theorem range_linearIsometry [∀ i, CompleteSpace (G i)] :
    LinearMap.range hV.linearIsometry.toLinearMap =
      (⨆ i, LinearMap.range (V i).toLinearMap).topologicalClosure := by
      refine le_antisymm ?_ ?_
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine le_antisymm?_?_
  · simp only [LinearMap.range_eq_top, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_eq_top, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_eq_top, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_

For theorem:
theorem range_linearIsometry [∀ i, CompleteSpace (G i)] :
    LinearMap.range hV.linearIsometry.toLinearMap =
      (⨆ i, LinearMap.range (V i).toLinearMap).topologicalClosure := by
      refine le_antisymm ?_ ?_
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine le_antisymm?_?_
  · simp only [LinearMap.range_eq_top, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_eq_top, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
      LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_eq_top, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_

For theorem:
theorem range_linearIsometry [∀ i, CompleteSpace (G i)] :
    LinearMap.range hV.linearIsometry.toLinearMap =
      (⨆ i, LinearMap.range (V i).toLinearMap).topologicalClosure := by
      refine le_antisymm ?_ ?_
Attempt failure.

Working on Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean - 2024-08-20 14:37:07.403401.
---0/3204---
Verifying proof:
:= by
  obtain ⟨r, V, hr, hV, hrVU⟩ : ∃ r : ℝ, 0 < r ∧ V ∈ 𝓝 (0 : E) := by
    obtain ⟨r, V, hr, hV, hVU⟩ : ∃ r : ℝ, 0 < r ∧ V ∈ 𝓝 (0 : E) := by
      rcases hU with ⟨r, hr, hVU⟩
      rcases hr with ⟨r, hr, hVU⟩
      rcases hr with ⟨r, hr, hVV⟩
      rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    rcases hr with ⟨r, hr, hVV⟩
    exact 

For theorem:
theorem balancedCore_mem_nhds_zero (hU : U ∈ 𝓝 (0 : E)) : balancedCore 𝕜 U ∈ 𝓝 (0 : E) := by
    obtain ⟨r, V, hr, hV, hrVU⟩ : ∃ (r : ℝ) (V : Set E),
      0 < r ∧ V ∈ 𝓝 (0 : E) ∧ ∀ (c : 𝕜) (y : E), ‖c‖ < r → y ∈ V → c • y ∈ U := by
    have h : Filter.Tendsto (fun x : 𝕜 × E => x.fst • x.snd) (𝓝 (0, 0)) (𝓝 0) :=
      continuous_smul.tendsto' (0, 0) _ (smul_zero _)
    simpa only [← Prod.exists', ← Prod.forall', ← and_imp, ← and_assoc, exists_prop] using
      h.basis_left (NormedAddCommGroup.nhds_zero_basis_norm_lt.prod_nhds (𝓝 _).basis_sets) U hU
Attempt failure.

Working on Mathlib/Analysis/LocallyConvex/Basic.lean - 2024-08-20 14:37:10.199025.
---0/3204---
Verifying proof:
:= by
  intro a ha
  obtain rfl | h := eq_or_ne a 0
  · rw [zero_smul_set]
  exacts [subset_insert _ _, subset_insert _ _]

For theorem:
theorem Balanced.zero_insert_interior (hA : Balanced 𝕜 A) :
    Balanced 𝕜 (insert 0 (interior A)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨1, fun a ha x hx =>?_⟩
  rw [mem_smul_set_iff_inv_smul_mem₀ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]
  rw [mem_smul_set_iff_inv_smul_mem₀ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]

For theorem:
theorem Balanced.absorbs_self (hA : Balanced 𝕜 A) : Absorbs 𝕜 A A 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro x
  obtain ⟨w, hw₁, hw₂, hw₃⟩ := mem_nhds_iff.mp hA
  have hc : Continuous fun t : 𝕜 => t • x := mem_nhds_iff.mp hA
  have hc : Continuous fun t : 𝕜 => t • x := by
    have hc : Continuous fun t : 𝕜 => t • x := by fun_prop
    have hc : Continuous fun t : 𝕜 => t • x := by
      have hc : Continuous fun t : 𝕜 => t • x := mem_nhds_iff.mp hA
    have hc : Continuous fun t : 𝕜 => t • x := by fun_prop
    have hc : Continuous fun t : 𝕜 => t • x := by fun_prop
    have hc : Continuous fun t : 𝕜 => t • x := by fun_prop
    have hc : Continuous fun t : 𝕜 => t • x := by fun_prop
    have hc : Continuous fun t : 𝕜 => t • x := by fun_prop
    have hc : Continuous fun t : 𝕜 => t • x := by fun_prop
    have hc : Continuous fun t : 𝕜 => t • x := by fun_prop
    have hc : Continuous fun t : 𝕜 => t • x := by fun_prop
    have hc : Continuous fun t : 𝕜 => t • x := by fun_prop
    have hc : Continuous fun t : 𝕜 => t • x := by
  

For theorem:
theorem absorbent_nhds_zero (hA : A ∈ 𝓝 (0 : E)) : Absorbent 𝕜 A 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨1, zero_lt_one, fun a ha x hx =>?_⟩
  rw [mem_smul_set_iff_inv_smul_mem₀ (norm_pos_iff.1 <| zero_lt_one.trans_le hx)]

For theorem:
theorem Balanced.absorbs_self (hA : Balanced 𝕜 A) : Absorbs 𝕜 A A 
Attempt failure.

Working on Mathlib/Analysis/LocallyConvex/Bounded.lean - 2024-08-20 14:37:29.081688.
---0/3204---
Verifying proof:
:= by
  if h : ∃ x : 𝕜, 1 < ‖x‖ then
    letI : NontriviallyNormedField 𝕜 := NontriviallyNormedField 𝕜 E
  letI : NontriviallyNormedField 𝕜 := NontriviallyNormedField 𝕜 E
  have : NontriviallyNormedField 𝕜 :=
    NontriviallyNormedField.of_nontriviallyNormedField 𝕜
  have : NontriviallyNormedField 𝕜 := NontriviallyNormedField.of_nontriviallyNormedField 𝕜
  have : NontriviallyNormedField 𝕜 := NontriviallyNormedField 𝕜 E
  have : NontriviallyNormedField 𝕜 := NontriviallyNormedField 𝕜 E
  have : NontriviallyNormedField 𝕜 := NontriviallyNormedField 𝕜 E
  have : NontriviallyNormedField 𝕜 := NontriviallyNormedField 𝕜 E
  have : NontriviallyNormedField 𝕜 := NontriviallyNormedField 𝕜 E
  have : NontriviallyNormedField 𝕜 := NontriviallyNormedField 𝕜 E
  have : NontriviallyNormedField 𝕜 := NontriviallyNormedField 𝕜 E
  have : NontriviallyNormedField 𝕜 := NontriviallyNormedField 𝕜 E
  have : NontriviallyNormedField 𝕜 := NontriviallyNorm

For theorem:
theorem TotallyBounded.isVonNBounded {s : Set E} (hs : TotallyBounded s) :
    Bornology.IsVonNBounded 𝕜 s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    rcases h with ⟨i, hi⟩
    refine ⟨fun h i hi =>?_, fun h i hi =>?_⟩
    simp only [isVonNBounded_iff_subset] at h
    rcases h with ⟨i, hi⟩
    refine ⟨fun h i hi =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_⟩


For theorem:
theorem _root_.Filter.HasBasis.isVonNBounded_iff {q : ι → Prop} {s : ι → Set E} {A : Set E}
    (h : (𝓝 (0 : E)).HasBasis q s) : IsVonNBounded 𝕜 A ↔ ∀ i, q i → Absorbs 𝕜 (s i) A 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine isVonNBounded_image.mpr fun x hx =>?_
  refine 

For theorem:
theorem IsVonNBounded.image {σ : 𝕜₁ →+* 𝕜₂} [RingHomSurjective σ] [RingHomIsometric σ] {s : Set E}
    (hs : IsVonNBounded 𝕜₁ s) (f : E →SL[σ] F) : IsVonNBounded 𝕜₂ (f '' s) 
Attempt failure.

Working on Mathlib/Analysis/LocallyConvex/ContinuousOfBounded.lean - 2024-08-20 14:37:43.119714.
---0/3204---
Verifying proof:
:= by
  by_contra h
  by_contra h
  rcases (nhds_basis_closedBall.eventually_iff.1 (nhds_basis_closedBall.eventually_iff.1 h)).exists with
    ⟨s, hs, hs'⟩
  have : ∀ s : Finset E, IsVonNBounded 𝕜 s → IsVonNBounded 𝕜' (f '' s) := fun s hs ↦ by
    intro s hs
    rcases (nhds_basis_closedBall.eventually_iff.1 hs).exists_isVonNBounded_image hs with ⟨s, hs, hs'⟩
  have : ∀ s : Finset E, IsVonNBounded 𝕜' s → IsVonNBounded 𝕜' s := fun s hs ↦ by
    intro s hs
    rcases (nhds_basis_closedBall.eventually_iff.1 hs).exists_isVonNBounded_image hs with ⟨s, hs'⟩
  have : ∀ s : Finset E, IsVonNBounded 𝕜' s → IsVonNBounded 𝕜' s := fun s hs ↦ by
      intro s hs
      simp only [Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq, Set.mem_image,
      Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_image,
      Set.mem_image, Set.mem_image, Set.mem_setOf_eq, Set.mem

For theorem:
theorem LinearMap.continuousAt_zero_of_locally_bounded (f : E →ₛₗ[σ] F)
    (hf : ∀ s, IsVonNBounded 𝕜 s → IsVonNBounded 𝕜' (f '' s)) : ContinuousAt f 0 := by
    by_contra h
      rcases (nhds_basis_balanced 𝕜 E).exists_antitone_subbasis with ⟨b, bE1, bE⟩
Attempt failure.

Working on Mathlib/Analysis/LocallyConvex/WithSeminorms.lean - 2024-08-20 14:37:45.182247.
---0/3204---
Verifying proof:
:= by
  refine UniformAddGroup.equicontinuous_tfae?_
  refine UniformAddGroup.equicontinuous_of_continuousAt_zero (fun s hs ↦?_)
  refine UniformAddGroup.equicontinuous_of_continuousAt_zero (fun s hs ↦?_)
  · exact UniformAddGroup.equicontinuousAt_zero_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuousAt_zero

For theorem:
theorem _root_.WithSeminorms.equicontinuous_TFAE {κ : Type*}
    {q : SeminormFamily 𝕜₂ F ι'} [UniformSpace E] [UniformAddGroup E] [u : UniformSpace F]
    [hu : UniformAddGroup F] (hq : WithSeminorms q) [ContinuousSMul 𝕜 E]
    (f : κ → E →ₛₗ[σ₁₂] F) : TFAE
    [ EquicontinuousAt ((↑) ∘ f) 0,
      Equicontinuous ((↑) ∘ f),
      UniformEquicontinuous ((↑) ∘ f),
      ∀ i, ∃ p : Seminorm 𝕜 E, Continuous p ∧ ∀ k, (q i).comp (f k) ≤ p,
      ∀ i, BddAbove (range fun k ↦ (q i).comp (f k)) ∧ Continuous (⨆ k, (q i).comp (f k)) ] := by
    rw [q.withSeminorms_iff_uniformSpace_eq_iInf.mp hq, uniformEquicontinuous_iInf_rng,
      equicontinuous_iInf_rng, equicontinuousAt_iInf_rng]
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let i := Classical.arbitrary ι
  refine nonempty_def.mpr ⟨(p i).ball 0 1,?_⟩
  exact p.basisSets_singleton_mem i zero_lt_one

For theorem:
theorem basisSets_nonempty [Nonempty ι] : p.basisSets.Nonempty 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let p : SeminormFamily 𝕜 E (p : SeminormFamily 𝕜 E) :=
    { p : SeminormFamily 𝕜 E (p : SeminormFamily 𝕜 E) }

For theorem:
theorem norm_withSeminorms (𝕜 E) [NormedField 𝕜] [SeminormedAddCommGroup E] [NormedSpace 𝕜 E] :
    WithSeminorms fun _ : Fin 1 => normSeminorm 𝕜 E 
Attempt failure.

---0/3204---
Verifying proof:
:=
  (map_zero q) ▸
    (specializes_iff_mem_closure.mpr 𝕜 mem_closure_zero_iff_norm_zero.mpr hx).symm

For theorem:
lemma map_eq_zero_of_norm_zero (q : Seminorm 𝕜 F)
    (hq : Continuous q) {x : F} (hx : ‖x‖ = 0) : q x = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine UniformAddGroup.equicontinuous_tfae?_
  refine UniformAddGroup.equicontinuous_of_continuousAt_zero (fun s hs ↦?_)
  refine UniformAddGroup.equicontinuous_of_continuousAt_zero (fun s hs ↦?_)
  · exact UniformAddGroup.equicontinuousAt_zero_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuous_of_continuousAt_zero
  · exact UniformAddGroup.equicontinuousAt_zero

For theorem:
theorem _root_.WithSeminorms.equicontinuous_TFAE {κ : Type*}
    {q : SeminormFamily 𝕜₂ F ι'} [UniformSpace E] [UniformAddGroup E] [u : UniformSpace F]
    [hu : UniformAddGroup F] (hq : WithSeminorms q) [ContinuousSMul 𝕜 E]
    (f : κ → E →ₛₗ[σ₁₂] F) : TFAE
    [ EquicontinuousAt ((↑) ∘ f) 0,
      Equicontinuous ((↑) ∘ f),
      UniformEquicontinuous ((↑) ∘ f),
      ∀ i, ∃ p : Seminorm 𝕜 E, Continuous p ∧ ∀ k, (q i).comp (f k) ≤ p,
      ∀ i, BddAbove (range fun k ↦ (q i).comp (f k)) ∧ Continuous (⨆ k, (q i).comp (f k)) ] := by
    rw [q.withSeminorms_iff_uniformSpace_eq_iInf.mp hq, uniformEquicontinuous_iInf_rng,
      equicontinuous_iInf_rng, equicontinuousAt_iInf_rng]
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have := ((t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := ((t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := ((t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := ((t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := ((t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := (t1Space_TFAE E).out 0

For theorem:
theorem WithSeminorms.separating_of_T1 [T1Space E] (hp : WithSeminorms p) (x : E) (hx : x ≠ 0) :
    ∃ i, p i x ≠ 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨s, hs⟩ : ∃ s : Finset ι, Set ι → Set ι → Set ι := fun s => s.sup p
  have : ∀ s : Finset ι, ∃ C : ℝ≥0, C ≠ 0 ∧ q ≤ C • s.sup p := by
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_

For theorem:
lemma bound_of_continuous [Nonempty ι] [t : TopologicalSpace E] (hp : WithSeminorms p)
    (q : Seminorm 𝕜 E) (hq : Continuous q) :
    ∃ s : Finset ι, ∃ C : ℝ≥0, C ≠ 0 ∧ q ≤ C • s.sup p := by
      rcases hp.hasBasis.mem_iff.mp (ball_mem_nhds hq one_pos) with ⟨V, hV, hε⟩
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let p : SeminormFamily 𝕜 E (p : SeminormFamily 𝕜 E) :=
    { p : SeminormFamily 𝕜 E (p : SeminormFamily 𝕜 E) }

For theorem:
theorem norm_withSeminorms (𝕜 E) [NormedField 𝕜] [SeminormedAddCommGroup E] [NormedSpace 𝕜 E] :
    WithSeminorms fun _ : Fin 1 => normSeminorm 𝕜 E 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rw [hU, Filter.eventually_mem_nhds] at hU
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rw [hU, Filter.eventually_mem_nhds] at hU
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, hU⟩
  rcases p.basisSets_iff.mp hU with ⟨s, r, hr, 

For theorem:
theorem basisSets_smul_right (v : E) (U : Set E) (hU : U ∈ p.basisSets) :
    ∀ᶠ x : 𝕜 in 𝓝 0, x • v ∈ U 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨s, hs⟩ : ∃ s : Finset ι, Set ι → Set ι → Set ι := fun s => s.sup p
  have : ∀ s : Finset ι, ∃ C : ℝ≥0, C ≠ 0 ∧ q ≤ C • s.sup p := by
    induction' s using Finset.induction_on with a s ha ih
    · simp only [Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_

For theorem:
lemma bound_of_continuous [Nonempty ι] [t : TopologicalSpace E] (hp : WithSeminorms p)
    (q : Seminorm 𝕜 E) (hq : Continuous q) :
    ∃ s : Finset ι, ∃ C : ℝ≥0, C ≠ 0 ∧ q ≤ C • s.sup p := by
      rcases hp.hasBasis.mem_iff.mp (ball_mem_nhds hq one_pos) with ⟨V, hV, hε⟩
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [continuous_iff_continuousAt]
  exact continuousAt_from_bounded hp hq

For theorem:
theorem continuous_from_bounded {p : SeminormFamily 𝕝 E ι} {q : SeminormFamily 𝕝₂ F ι'}
    {_ : TopologicalSpace E} (hp : WithSeminorms p) {_ : TopologicalSpace F} (hq : WithSeminorms q)
    (f : E →ₛₗ[τ₁₂] F) (hf : Seminorm.IsBounded p q f) : Continuous f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have := ((t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := ((t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := ((t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := ((t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := ((t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := (t1Space_TFAE E).out 0 9
  have := (t1Space_TFAE E).out 0 9).mp (inferInstanceAs <| T1Space E)
  have := (t1Space_TFAE E).out 0

For theorem:
theorem WithSeminorms.separating_of_T1 [T1Space E] (hp : WithSeminorms p) (x : E) (hx : x ≠ 0) :
    ∃ i, p i x ≠ 0 
Attempt failure.

Working on Mathlib/Analysis/MeanInequalities.lean - 2024-08-20 14:39:43.922354.
---0/3204---
Verifying proof:
:= by
  rcases eq_or_lt_of_le zero_lt_one hp with (rfl | hp)
  · simp only [le_antisymm_iff, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpo

For theorem:
theorem Lp_add_le_hasSum {f g : ι → ℝ≥0} {A B : ℝ≥0} {p : ℝ} (hp : 1 ≤ p)
    (hf : HasSum (fun i => f i ^ p) (A ^ p)) (hg : HasSum (fun i => g i ^ p) (B ^ p)) :
    ∃ C, C ≤ A + B ∧ HasSum (fun i => (f i + g i) ^ p) (C ^ p) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro i
    rw [inner_le_Lp_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsu

For theorem:
theorem inner_le_Lp_mul_Lq_tsum {f g : ι → ℝ≥0} {p q : ℝ} (hpq : p.IsConjExponent q)
    (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ q) :
    (Summable fun i => f i * g i) ∧
      ∑' i, f i * g i ≤ (∑' i, f i ^ p) ^ (1 / p) * (∑' i, g i ^ q) ^ (1 / q) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro i
    rw [inner_le_Lp_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsum_mul_Lq_tsu

For theorem:
theorem inner_le_Lp_mul_Lq_tsum {f g : ι → ℝ≥0} {p q : ℝ} (hpq : p.IsConjExponent q)
    (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ q) :
    (Summable fun i => f i * g i) ∧
      ∑' i, f i * g i ≤ (∑' i, f i ^ p) ^ (1 / p) * (∑' i, g i ^ q) ^ (1 / q) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Lp.add_le_hasSum (fun i => f i ^ p) (fun i => g i ^ p)?_
  refine Lp.add_le_hasSum (fun i => g i ^ p) (fun i => g i ^ p) (fun i => g i ^ p)?_?_?_
  · simp only [Lp.add_nonneg_iff] at hfA hgB ⊢
    exact hfA.pow_const _

For theorem:
theorem Lp_add_le_hasSum_of_nonneg (hp : 1 ≤ p) (hf : ∀ i, 0 ≤ f i) (hg : ∀ i, 0 ≤ g i) {A B : ℝ}
    (hA : 0 ≤ A) (hB : 0 ≤ B) (hfA : HasSum (fun i => f i ^ p) (A ^ p))
    (hgB : HasSum (fun i => g i ^ p) (B ^ p)) :
    ∃ C, 0 ≤ C ∧ C ≤ A + B ∧ HasSum (fun i => (f i + g i) ^ p) (C ^ p) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun i => (f i + g i) ^ p,?_,?_⟩
  · refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
  

For theorem:
theorem Lp_add_le_tsum {f g : ι → ℝ≥0} {p : ℝ} (hp : 1 ≤ p) (hf : Summable fun i => f i ^ p)
    (hg : Summable fun i => g i ^ p) :
    (Summable fun i => (f i + g i) ^ p) ∧
      (∑' i, (f i + g i) ^ p) ^ (1 / p) ≤
        (∑' i, f i ^ p) ^ (1 / p) + (∑' i, g i ^ p) ^ (1 / p) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eq_or_lt_of_le zero_lt_one hp with (rfl | hp)
  · simp only [le_antisymm_iff, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpow_of_pos hp,
      zero_rpow_of_pos hp, zero_rpow_of_pos hp, zero_rpo

For theorem:
theorem Lp_add_le_hasSum {f g : ι → ℝ≥0} {A B : ℝ≥0} {p : ℝ} (hp : 1 ≤ p)
    (hf : HasSum (fun i => f i ^ p) (A ^ p)) (hg : HasSum (fun i => g i ^ p) (B ^ p)) :
    ∃ C, C ≤ A + B ∧ HasSum (fun i => (f i + g i) ^ p) (C ^ p) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun i => (f i + g i) ^ p,?_,?_⟩
  · refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
    refine ⟨fun i => (f i + g i) ^ p,?_⟩
  

For theorem:
theorem Lp_add_le_tsum {f g : ι → ℝ≥0} {p : ℝ} (hp : 1 ≤ p) (hf : Summable fun i => f i ^ p)
    (hg : Summable fun i => g i ^ p) :
    (Summable fun i => (f i + g i) ^ p) ∧
      (∑' i, (f i + g i) ^ p) ^ (1 / p) ≤
        (∑' i, f i ^ p) ^ (1 / p) + (∑' i, g i ^ p) ^ (1 / p) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Lp.add_le_hasSum (fun i => f i ^ p) (fun i => g i ^ p)?_
  refine Lp.add_le_hasSum (fun i => g i ^ p) (fun i => g i ^ p) (fun i => g i ^ p)?_?_?_
  · simp only [Lp.add_nonneg_iff] at hfA hgB ⊢
    exact hfA.pow_const _

For theorem:
theorem Lp_add_le_hasSum_of_nonneg (hp : 1 ≤ p) (hf : ∀ i, 0 ≤ f i) (hg : ∀ i, 0 ≤ g i) {A B : ℝ}
    (hA : 0 ≤ A) (hB : 0 ≤ B) (hfA : HasSum (fun i => f i ^ p) (A ^ p))
    (hgB : HasSum (fun i => g i ^ p) (B ^ p)) :
    ∃ C, 0 ≤ C ∧ C ≤ A + B ∧ HasSum (fun i => (f i + g i) ^ p) (C ^ p) 
Attempt failure.

Working on Mathlib/Analysis/MeanInequalitiesPow.lean - 2024-08-20 14:40:37.184330.
---0/3204---
Verifying proof:
:= by
  rcases eq_or_lt_of_le hp with (rfl | hp)
  · simp only [NNReal.rpow_le_rpow_iff (by positivity), ← NNReal.rpow_mul, ← NNReal.rpow_mul,
    ← NNReal.rpow_le_rpow_iff (by positivity), ← NNReal.rpow_mul, ← NNReal.rpow_mul,
    NNReal.rpow_le_rpow_iff (by positivity), ← NNReal.rpow_mul, ← NNReal.rpow_mul, ←
    NNReal.rpow_le_rpow_iff (by positivity), ← NNReal.rpow_mul, ← NNReal.rpow_mul, ←
    NNReal.rpow_le_rpow_iff (by positivity), ← NNReal.rpow_mul, ← NNReal.rpow_mul, ←
    NNReal.rpow_le_rpow_iff (by positivity), ← NNReal.rpow_mul, ← NNReal.rpow_mul, ←
    NNReal.rpow_le_rpow_iff (by positivity), ← NNReal.rpow_mul, ← NNReal.rpow_mul, ←
    NNReal.rpow_le_rpow_iff (by positivity), ← NNReal.rpow_mul, ← NNReal.rpow_mul, ←
    NNReal.rpow_le_rpow_iff (by positivity), ← NNReal.rpow_mul, ← NNReal.rpow_mul, ←
    NNReal.rpow_le_rpow_iff (by positivity), ← NNReal.rpow_mul, ← NNReal.rpow_mul, ←
    NNReal.rpow_le_rpow_iff (by positivity), ← NNReal.

For theorem:
theorem rpow_add_le_mul_rpow_add_rpow (z₁ z₂ : ℝ≥0) {p : ℝ} (hp : 1 ≤ p) :
    (z₁ + z₂) ^ p ≤ (2 : ℝ≥0) ^ (p - 1) * (z₁ ^ p + z₂ ^ p) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases s.eq_empty_or_nonempty with (rfl | hs)
  · simp only [Nat.cast_zero, pow_zero, div_one]
  · simp only [Nat.cast_zero, div_zero, pow_zero, div_one]
    exact pow_le_pow_of_nonneg (Nat.cast_nonneg _) (Nat.cast_nonneg _) (Nat.cast_nonneg _)

For theorem:
theorem pow_sum_div_card_le_sum_pow {f : ι → ℝ} (n : ℕ) (hf : ∀ a ∈ s, 0 ≤ f a) :
    (∑ x ∈ s, f x) ^ (n + 1) / (s.card : ℝ) ^ n ≤ ∑ x ∈ s, f x ^ (n + 1) 
Attempt failure.

Working on Mathlib/Analysis/MellinInversion.lean - 2024-08-20 14:40:48.479500.
---0/3204---
Verifying proof:
:=
  (Real.exp_injective.injOn _).comp (neg_injective.injOn _) (univ.mapsTo_univ _)

For theorem:
theorem rexp_neg_injOn_aux : univ.InjOn (rexp ∘ Neg.neg) 
Attempt failure.

Working on Mathlib/Analysis/MellinTransform.lean - 2024-08-20 14:40:53.180889.
---0/3204---
Verifying proof:
:= by
  refine Iff.trans?_ (integrableOn_convergent_iff_integrableOn_Ioc_of_le ha)
  refine Iff.trans?_ (integrableOn_convergent_iff_integrableOn_Ioc_of_le ha)
  refine Iff.trans?_ (integrableOn_convergent_iff_integrableOn_Ioc_of_le ha)
  refine Iff.trans?_ (integrableOn_convergent_iff_integrableOn_Ioc_of_le ha)
  refine Iff.trans?_ (integrableOn_convergent_iff_integrableOn_Ioc_of_le ha)
  refine Iff.trans?_ (integrableOn_convergent_iff_integrableOn_Ioc_of_le ha)
  refine Iff.trans?_ (integrableOn_convergent_iff_integrableOn_Ioc_of_le ha)
  refine Iff.trans?_ (integrableOn_convergent_iff_integrableOn_Ioc_of_le ha)
  refine Iff.trans?_ (integrableOn_convergent_iff_integrableOn_Ioc_of_le ha)
  refine Iff.trans?_ (integrableOn_convergent_iff_integrableOn_Ioc_of_le ha)
  simp only [integrableOn_Ioc_iff_integrableOn_Ioc, integrableOn_Ioc_iff_integrableOn_Ioc_of_le ha,
    integrableOn_Ioc_iff_integrableOn_Ioc, integrableOn_Ioc_iff_integrableOn_Ioc_of_le ha,
    integrableOn_Ioc_iff_integrableOn_Ioc_of_l

For theorem:
theorem MellinConvergent.comp_rpow {f : ℝ → E} {s : ℂ} {a : ℝ} (ha : a ≠ 0) :
    MellinConvergent (fun t => f (t ^ a)) s ↔ MellinConvergent f (s / a) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine mellin_convergent_iff_integrableOn_Ioc_of_le (fun x hx =>?_) hT hT' hT hT' hfc hfc?_
  refine integrableOn_Ioc_of_le (fun x hx =>?_) (fun x hx =>?_) (fun x hx =>?_)
  · refine integrableOn_Ioc_iff_integrableOn_Ioc.mpr fun x hx =>?_
    refine integrableOn_Ioc_iff_integrableOn_Ioc.mpr fun ε hε =>?_
    simp only [integrableOn_Ioc_iff_integrableOn_Ioc, integrableOn_Ioc_iff_integrableOn_Ioc,
      integrableOn_Ioc_iff_integrableOn_Ioc, integrableOn_Ioc_iff_integrableOn_Ioc, integrableOn_Ioc_iff_integrableOn_Ioc,
      integrableOn_Ioc_iff_integrableOn_Ioc, integrableOn_Ioc_iff_integrableOn_Ioc, integrableOn_Ioc_iff_integrableOn_Ioc,
      integrableOn_Ioc_iff_integrableOn_Ioc, integrableOn_Ioc_iff_integrableOn_Ioc, integrableOn_Ioc_iff_integrableOn_Ioc,
      integrableOn_Ioc_iff_integrableOn_Ioc, integrableOn_Ioc_iff_integrableOn_Ioc, integrableOn_Ioc_iff_integrableOn_Ioc,
      integrableOn_Ioc_iff_integrableOn_Ioc, integrableOn_Ioc_iff_integrableOn_Ioc, integrableOn_Ioc_iff_integrabl

For theorem:
theorem mellin_convergent_iff_norm [NormedSpace ℂ E] {f : ℝ → E} {T : Set ℝ} (hT : T ⊆ Ioi 0)
    (hT' : MeasurableSet T) (hfc : AEStronglyMeasurable f <| volume.restrict <| Ioi 0) {s : ℂ} :
    IntegrableOn (fun t : ℝ => (t : ℂ) ^ (s - 1) • f t) T ↔
      IntegrableOn (fun t : ℝ => t ^ (s.re - 1) * ‖f t‖) T 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have := hasMellin_one_Ioc (by rwa [add_re, one_re]) (by rwa [add_re, ofReal_re])
  have := hasMellin_indicator (measurableSet_Ioc : MeasurableSet (Ioc (0 : ℝ) 1))
  have : MeasurableSet (Ioc (0 : ℝ) 1) := measurableSet_Ioc
  have : MeasurableSet (Ioc (0 : ℝ) 1) := measurableSet_Ioc
  have : MeasurableSet (Ioc (0 : ℝ) 1) := measurableSet_Ioc
  have : MeasurableSet (Ioc (0 : ℝ) 1) := measurableSet_Ioc
  have : MeasurableSet (Ioc (0 : ℝ) 1) := measurableSet_Ioc
  have : MeasurableSet (Ioc (0 : ℝ) 1) := measurableSet_Ioc
  have : MeasurableSet (Ioc (0 : ℝ) 1) := measurableSet_Ioc
  have : MeasurableSet (Ioc (0 : ℝ) 1) := measurableSet_Ioc
  have : MeasurableSet (Ioc (0 : ℝ) 1) := measurableSet_Ioc
  have : MeasurableSet (Ioc (0 : ℝ) 1) := measurableSet_Ioc
  have : MeasurableSet (Ioc (0 : ℝ) 1) := measurableSet_Ioc
  have : MeasurableSet (Ioc (0 : ℝ) 1) := measurableSet_Ioc
  have : MeasurableSet (Ioc (0 : ℝ) 1) := measurableSet_Ioc
  have : MeasurableSet (Ioc (0 : ℝ) 1) := 

For theorem:
theorem hasMellin_cpow_Ioc (a : ℂ) {s : ℂ} (hs : 0 < re s + re a) :
    HasMellin (indicator (Ioc 0 1) (fun t => ↑t ^ a : ℝ → ℂ)) s (1 / (s + a)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne a 0 with (rfl | ha)
  · simp only [Real.rpow_zero, ofReal_eq_zero, norm_eq_abs, abs_cpow_eq_rpow_re_of_pos hs_top,
      Real.rpow_zero, ofReal_one, ofReal_zero, zero_cpow hs_top, one_mul]
    exact Real.rpow_lt_rpow_of_exponent_lt hs_top hf_bot hf_top hf_bot hs_bot
  · simp only [Real.rpow_zero, ofReal_one, one_mul, Real.rpow_zero, one_mul, mul_one]
    exact Real.rpow_lt_rpow (neg_lt_zero.mpr hs_top) (neg_lt_zero.mpr hs_top)

For theorem:
theorem mellin_hasDerivAt_of_isBigO_rpow [NormedSpace ℂ E] {a b : ℝ}
    {f : ℝ → E} {s : ℂ} (hfc : LocallyIntegrableOn f (Ioi 0)) (hf_top : f =O[atTop] (· ^ (-a)))
    (hs_top : s.re < a) (hf_bot : f =O[𝓝[>] 0] (· ^ (-b))) (hs_bot : b < s.re) :
    MellinConvergent (fun t => log t • f t) s ∧
      HasDerivAt (mellin f) (mellin (fun t => log t • f t) s) s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine isBigO_of_tendsto_of_tendsto_of_tendsto_of_tendsto_of_le_of_le (fun t ht =>?_) hf
  rcases exists_between hab with ⟨t, ht⟩
  refine tendsto_of_tendsto_of_tendsto_of_tendsto_of_le_of_le (fun t =>?_) (fun t =>?_) hf tendsto_const_nhds

For theorem:
theorem isBigO_rpow_top_log_smul [NormedSpace ℝ E] {a b : ℝ} {f : ℝ → E} (hab : b < a)
    (hf : f =O[atTop] (· ^ (-a))) :
    (fun t : ℝ => log t • f t) =O[atTop] (· ^ (-b)) 
Attempt failure.

Working on Mathlib/Analysis/Normed/Field/Basic.lean - 2024-08-20 14:41:15.223924.
---0/3204---
Verifying proof:
:= fun y => by
  rw [mul_comm]
  exact norm_mul_le y x

For theorem:
theorem mulRight_bound (x : α) : ∀ y : α, ‖AddMonoidHom.mulRight x y‖ ≤ ‖x‖ * ‖y‖ 
Attempt failure.

---0/3204---
Verifying proof:
:=
  normHom.toMonoidHom : α →* ℝ).map_list_prod _

For theorem:
theorem List.norm_prod (l : List α) : ‖l.prod‖ = (l.map norm).prod 
Attempt failure.

Working on Mathlib/Analysis/Normed/Field/InfiniteSum.lean - 2024-08-20 14:41:35.338549.
---0/3204---
Verifying proof:
:= by
  rw [tsum_mul_tsum_of_summable_norm hf hg, tsum_mul_tsum_of_summable_norm hg hf]

For theorem:
theorem tsum_mul_tsum_of_summable_norm [CompleteSpace R] {f : ι → R} {g : ι' → R}
    (hf : Summable fun x => ‖f x‖) (hg : Summable fun x => ‖g x‖) :
    ((∑' x, f x) * ∑' y, g y) = ∑' z : ι × ι', f z.1 * g z.2 
Attempt failure.

Working on Mathlib/Analysis/Normed/Group/Basic.lean - 2024-08-20 14:41:37.308991.
---0/3204---
Verifying proof:
:= by
  simp only [mem_closedBall, dist_eq_norm_div, ← div_pow]

For theorem:
theorem pow_mem_closedBall {n : ℕ} (h : a ∈ closedBall b r) :
    a ^ n ∈ closedBall (b ^ n) (n • r) 
Attempt failure.

Working on Mathlib/Analysis/Normed/Group/ControlledClosure.lean - 2024-08-20 14:41:46.617007.
---0/3204---
Verifying proof:
:= by
  refine controlled_closure_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjective_of_surjec

For theorem:
theorem controlled_closure_of_complete {f : NormedAddGroupHom G H} {K : AddSubgroup H} {C ε : ℝ}
    (hC : 0 < C) (hε : 0 < ε) (hyp : f.SurjectiveOnWith K C) :
    f.SurjectiveOnWith K.topologicalClosure (C + ε) 
Attempt failure.

Working on Mathlib/Analysis/Normed/Group/Hom.lean - 2024-08-20 14:41:48.245489.
---0/3204---
Verifying proof:
:=
  LipschitzWith.of_dist_le_mul fun x y =>
    by
    rw [dist_eq_norm, dist_eq_norm, ← map_sub]
    apply le_opNorm

For theorem:
theorem lipschitz : LipschitzWith ⟨‖f‖, opNorm_nonneg f⟩ f 
Attempt failure.

---0/3204---
Verifying proof:
:=
  le_antisymm (norm_id_le V) <| by
    let ⟨x, hx⟩ := h
    have := (id V).ratio_le_opNorm x
    have := (id V).ratio_le_opNorm x
    have := (id V).ratio_le_opNorm x
  have := (id V).ratio_le_opNorm x


For theorem:
theorem norm_id_of_nontrivial_seminorm (h : ∃ x : V, ‖x‖ ≠ 0) : ‖id V‖ = 1 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨|C| + 1, by positivity,?_⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with ⟨C', hC'⟩
  rcases h with

For theorem:
theorem SurjectiveOnWith.exists_pos {f : NormedAddGroupHom V₁ V₂} {K : AddSubgroup V₂} {C : ℝ}
    (h : f.SurjectiveOnWith K C) : ∃ C' > 0, f.SurjectiveOnWith K C' 
Attempt failure.

---0/3204---
Verifying proof:
:=
  opNorm_le_bound _ zero_le_one fun x => by simp

For theorem:
theorem norm_id_le : ‖(id V : NormedAddGroupHom V V)‖ ≤ 1 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/AddTorsor.lean - 2024-08-20 14:42:14.352888.
---0/3204---
Verifying proof:
:= by
  rw [(NormedAddCommGroup.nhds_basis_closedBall.eventually_iff.2 hy).mono fun ε hε =>
    homothety_mem_interior_iff_mem_nhds.1 hy]

For theorem:
theorem eventually_homothety_mem_of_mem_interior (x : Q) {s : Set Q} {y : Q} (hy : y ∈ interior s) :
    ∀ᶠ δ in 𝓝 (1 : 𝕜), homothety x δ y ∈ s 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/AddTorsorBases.lean - 2024-08-20 14:42:17.891844.
---0/3204---
Verifying proof:
:= by
  rcases hne with ⟨t, hts, htu⟩
  rcases hne with ⟨t, hts, htu⟩
  rcases hne with ⟨t, hts, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases 

For theorem:
theorem IsOpen.exists_between_affineIndependent_span_eq_top {s u : Set P} (hu : IsOpen u)
    (hsu : s ⊆ u) (hne : s.Nonempty) (h : AffineIndependent ℝ ((↑) : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ t ⊆ u ∧ AffineIndependent ℝ ((↑) : t → P) ∧ affineSpan ℝ t = ⊤ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hne with ⟨t, hts, htu⟩
  rcases hne with ⟨t, hts, htu⟩
  rcases hne with ⟨t, hts, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases 

For theorem:
theorem IsOpen.exists_between_affineIndependent_span_eq_top {s u : Set P} (hu : IsOpen u)
    (hsu : s ⊆ u) (hne : s.Nonempty) (h : AffineIndependent ℝ ((↑) : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ t ⊆ u ∧ AffineIndependent ℝ ((↑) : t → P) ∧ affineSpan ℝ t = ⊤ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hne with ⟨t, hts, htu⟩
  rcases hne with ⟨t, hts, htu⟩
  rcases hne with ⟨t, hts, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases hne with ⟨t, htu, htu⟩
  rcases 

For theorem:
theorem IsOpen.exists_between_affineIndependent_span_eq_top {s u : Set P} (hu : IsOpen u)
    (hsu : s ⊆ u) (hne : s.Nonempty) (h : AffineIndependent ℝ ((↑) : s → P)) :
    ∃ t : Set P, s ⊆ t ∧ t ⊆ u ∧ AffineIndependent ℝ ((↑) : t → P) ∧ affineSpan ℝ t = ⊤ 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Banach.lean - 2024-08-20 14:42:26.190426.
---0/3204---
Verifying proof:
:= by
  obtain ⟨C, C0, hC⟩ := exists_approx_preimage_norm_le f surj

For theorem:
theorem exists_preimage_norm_le (surj : Surjective f) :
    ∃ C > 0, ∀ y, ∃ x, f x = y ∧ ‖x‖ ≤ C * ‖y‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  letI : CompleteSpace g.graph := completeSpace_coe_iff_isComplete.mpr hg.isComplete

For theorem:
theorem LinearMap.continuous_of_isClosed_graph (hg : IsClosed (g.graph : Set <| E × F)) :
    Continuous g 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have A : ⋃ n : ℕ, closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '

For theorem:
theorem exists_approx_preimage_norm_le (surj : Surjective f) :
    ∃ C ≥ 0, ∀ y, ∃ x, dist (f x) y ≤ 1 / 2 * ‖y‖ ∧ ‖x‖ ≤ C * ‖y‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨C, C0, hC⟩ := exists_approx_preimage_norm_le f surj

For theorem:
theorem exists_preimage_norm_le (surj : Surjective f) :
    ∃ C > 0, ∀ y, ∃ x, f x = y ∧ ‖x‖ ≤ C * ‖y‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have A : (⋃ n : ℕ, closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '

For theorem:
theorem exists_approx_preimage_norm_le (surj : Surjective f) :
    ∃ C ≥ 0, ∀ y, ∃ x, dist (f x) y ≤ 1 / 2 * ‖y‖ ∧ ‖x‖ ≤ C * ‖y‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have A : ⋃ n : ℕ, closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '

For theorem:
theorem exists_approx_preimage_norm_le (surj : Surjective f) :
    ∃ C ≥ 0, ∀ y, ∃ x, dist (f x) y ≤ 1 / 2 * ‖y‖ ∧ ‖x‖ ≤ C * ‖y‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have A : ⋃ n : ℕ, closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '' closure (f '

For theorem:
theorem exists_approx_preimage_norm_le (surj : Surjective f) :
    ∃ C ≥ 0, ∀ y, ∃ x, dist (f x) y ≤ 1 / 2 * ‖y‖ ∧ ‖x‖ ≤ C * ‖y‖ 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Basic.lean - 2024-08-20 14:43:41.326706.
---0/3204---
Verifying proof:
:= by
  refine Isometry.of_dist_eq fun x y =>?_
  rw [dist_eq_norm, dist_eq_norm, ← RingHom.map_sub, norm_algebraMap']
  refine Isometry.of_dist_eq fun x y =>?_
  rw [dist_eq_norm, dist_eq_norm, ← RingHom.map_sub, norm_algebraMap']
  refine Isometry.of_dist_eq fun x y =>?_
  rw [dist_eq_norm, dist_eq_norm, ← RingHom.map_sub, norm_algebraMap', ← RingHom.map_sub,
    RingHom.map_sub, norm_sub, RingHom.map_sub]

For theorem:
theorem algebraMap_isometry [NormOneClass 𝕜'] : Isometry (algebraMap 𝕜 𝕜') 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [neBot_iff, Ne, cobounded_eq_bot_iff, ← isBounded_univ]
  exact NormedSpace.unbounded_univ 𝕜 E

For theorem:
lemma NormedSpace.cobounded_neBot : NeBot (cobounded E) 
Attempt success.

Working on Mathlib/Analysis/NormedSpace/BoundedLinearMaps.lean - 2024-08-20 14:43:49.654907.
---0/3204---
Verifying proof:
:= by
  refine IsBoundedLinearMap.compContinuousLinearMap?_
  refine ⟨fun f =>?_, fun f =>?_⟩
  simp only [ContinuousLinearMap.compContinuousLinearMap_apply, ContinuousLinearMap.coe_coe,
    ContinuousLinearMap.compContinuousLinearMap_apply, ContinuousLinearMap.compContinuousLinearMap_apply]

For theorem:
theorem isBoundedLinearMap_continuousMultilinearMap_comp_linear (g : G →L[𝕜] E) :
    IsBoundedLinearMap 𝕜 fun f : ContinuousMultilinearMap 𝕜 (fun _ : ι => E) F =>
      f.compContinuousLinearMap fun _ => g 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/CompactOperator.lean - 2024-08-20 14:44:03.528313.
---0/3204---
Verifying proof:
:= by
  refine isClosed_setOf_isClosed_setOf_isClosed_setOf_isClosed_setOf_isClosed_setOf_isClosed_setOf_isClosed_setOf_isClosed_setOf_isClosed
    (fun x hx ↦?_) (fun x hx ↦?_) (fun x hx ↦?_) (fun x hx ↦?_) (fun x hx ↦?_)
  · exact fun x hx ↦ by simp only [hx, map_zero]
  · exact fun x hx ↦ by simp only [hx, map_zero]

For theorem:
theorem isClosed_setOf_isCompactOperator {𝕜₁ 𝕜₂ : Type*} [NontriviallyNormedField 𝕜₁]
    [NormedField 𝕜₂] {σ₁₂ : 𝕜₁ →+* 𝕜₂} {M₁ M₂ : Type*} [SeminormedAddCommGroup M₁]
    [AddCommGroup M₂] [NormedSpace 𝕜₁ M₁] [Module 𝕜₂ M₂] [UniformSpace M₂] [UniformAddGroup M₂]
    [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂] [CompleteSpace M₂] :
    IsClosed { f : M₁ →SL[σ₁₂] M₂ | IsCompactOperator f } 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine isClosed_setOf_isClosed_setOf_isClosed_setOf_isClosed_setOf_isClosed_setOf_isClosed_setOf_isClosed_setOf_isClosed_setOf_isClosed
    (fun x hx ↦?_) (fun x hx ↦?_) (fun x hx ↦?_) (fun x hx ↦?_) (fun x hx ↦?_)
  · exact fun x hx ↦ by simp only [hx, map_zero]
  · exact fun x hx ↦ by simp only [hx, map_zero]

For theorem:
theorem isClosed_setOf_isCompactOperator {𝕜₁ 𝕜₂ : Type*} [NontriviallyNormedField 𝕜₁]
    [NormedField 𝕜₂] {σ₁₂ : 𝕜₁ →+* 𝕜₂} {M₁ M₂ : Type*} [SeminormedAddCommGroup M₁]
    [AddCommGroup M₂] [NormedSpace 𝕜₁ M₁] [Module 𝕜₂ M₂] [UniformSpace M₂] [UniformAddGroup M₂]
    [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂] [CompleteSpace M₂] :
    IsClosed { f : M₁ →SL[σ₁₂] M₂ | IsCompactOperator f } 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Connected.lean - 2024-08-20 14:44:11.882263.
---0/3204---
Verifying proof:
:= by
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivial E).1 h
  have : Nontrivial E := (rank_pos_iff_nontrivia

For theorem:
theorem Set.Countable.isPathConnected_compl_of_one_lt_rank
    (h : 1 < Module.rank ℝ E) {s : Set E} (hs : s.Countable) :
    IsPathConnected sᶜ 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/FiniteDimension.lean - 2024-08-20 14:44:14.126281.
---0/3204---
Verifying proof:
:= by
  rcases hK.exists_mem_frontier_subset hx with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
  rcases hy with ⟨y, hy⟩
 

For theorem:
theorem IsCompact.exists_mem_frontier_infDist_compl_eq_dist {E : Type*}
    [NormedAddCommGroup E] [NormedSpace ℝ E] [Nontrivial E] {x : E} {K : Set E} (hK : IsCompact K)
    (hx : x ∈ K) :
    ∃ y ∈ frontier K, Metric.infDist x Kᶜ = dist x y 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨Summable.of_norm, fun h =>?_⟩
  refine ⟨Summable.of_norm, fun h =>?_⟩
  refine ⟨fun h =>?_⟩
  refine ⟨fun h =>?_, fun h =>?_⟩
  refine ⟨fun h =>?_⟩
  refine ⟨fun h =>?_⟩
  refine ⟨fun h =>?_, fun h =>?_⟩
  simp only [Summable.of_norm_bounded _ h]

For theorem:
theorem summable_norm_iff {α E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    [FiniteDimensional ℝ E] {f : α → E} : (Summable fun x => ‖f x‖) ↔ Summable f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine LipschitzWith.extend_finite_dimension?_?_?_
  · simp only [LipschitzWith.extend_finite_dimensional]
    refine LipschitzWith.extend_finite_dimensional?_
    refine LipschitzWith.extend_finite_dimensional?_?_?_
    · simp only [LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite

For theorem:
theorem LipschitzOnWith.extend_finite_dimension {α : Type*} [PseudoMetricSpace α] {E' : Type*}
    [NormedAddCommGroup E'] [NormedSpace ℝ E'] [FiniteDimensional ℝ E'] {s : Set α} {f : α → E'}
    {K : ℝ≥0} (hf : LipschitzOnWith K f s) :
    ∃ g : α → E', LipschitzWith (lipschitzExtensionConstant E' * K) g ∧ EqOn f g s := by
    let ι : Type _ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_contra hfin
  obtain ⟨R, f, Rgt⟩ : ∃ R : ℝ, 0 < R ∧ IsCompact (Metric.closedBall (0 : E) r) :=
    h.isCompact_closedBall (0 : E) r

For theorem:
theorem FiniteDimensional.of_isCompact_closedBall₀ {r : ℝ} (rpos : 0 < r)
    (h : IsCompact (Metric.closedBall (0 : E) r)) : FiniteDimensional 𝕜 E 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine LipschitzWith.extend_finite_dimension?_?_?_
  · simp only [LipschitzWith.extend_finite_dimensional]
    refine LipschitzWith.extend_finite_dimensional?_
    refine LipschitzWith.extend_finite_dimensional?_?_?_
    · simp only [LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite_dimensional,
      LipschitzWith.extend_finite_dimensional, LipschitzWith.extend_finite

For theorem:
theorem LipschitzOnWith.extend_finite_dimension {α : Type*} [PseudoMetricSpace α] {E' : Type*}
    [NormedAddCommGroup E'] [NormedSpace ℝ E'] [FiniteDimensional ℝ E'] {s : Set α} {f : α → E'}
    {K : ℝ≥0} (hf : LipschitzOnWith K f s) :
    ∃ g : α → E', LipschitzWith (lipschitzExtensionConstant E' * K) g ∧ EqOn f g s := by
    let ι : Type _ 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/HahnBanach/Extension.lean - 2024-08-20 14:45:02.812916.
---0/3204---
Verifying proof:
:= by
  let p : Submodule 𝕜 E := 𝕜 ∙ x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) • coord 𝕜 x
  let f := (‖x‖ : 𝕜) •

For theorem:
theorem exists_dual_vector (x : E) (h : x ≠ 0) : ∃ g : E →L[𝕜] 𝕜, ‖g‖ = 1 ∧ g x = ‖x‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨g, hg⟩ := exists_finiteDimensional_of_finiteDimensional 𝕜 (LinearMap.range f)
  obtain ⟨g, hg⟩ := exists_finiteDimensional_of_finiteDimensional 𝕜 (LinearMap.range f)
  obtain ⟨g, hg⟩ := exists_finiteDimensional_of_finiteDimensional 𝕜 (LinearMap.range f)
  obtain ⟨g, hg⟩ := exists_finiteDimensional_of_finiteDimensional 𝕜 (LinearMap.range f)
  obtain ⟨g, hg⟩ := exists_finiteDimensional_of_finiteDimensional 𝕜 (LinearMap.range f)
  obtain ⟨g, hg⟩ := exists_finiteDimensional_of_finiteDimensional 𝕜 (LinearMap.range f)
  obtain ⟨g, hg⟩ := exists_finiteDimensional_of_finiteDimensional 𝕜 (LinearMap.range f)
  refine ⟨g.comp p.subtypeL,?_⟩
  refine ⟨g.comp p.subtypeL,?_⟩
  refine ⟨g.comp p.subtypeL,?_⟩
  refine ⟨g.comp p.subtypeL,?_⟩
  refine ⟨g.comp p.subtypeL,?_⟩
  refine ⟨g.comp p.subtypeL,?_⟩
  refine ⟨g.comp p.subtypeL,?_⟩
  refine ⟨g.comp p.subtypeL,?_⟩
  refine ⟨g.comp p.subtypeL,?_⟩
  refine ⟨g.comp 

For theorem:
lemma ContinuousLinearMap.exist_extension_of_finiteDimensional_range {p : Submodule 𝕜 E}
    (f : p →L[𝕜] F) [FiniteDimensional 𝕜 (LinearMap.range f)] :
    ∃ g : E →L[𝕜] F, f = g.comp p.subtypeL 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases exists_extension_of_le_sublinear hp with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension_of_le_sublinear hg with ⟨g, hg⟩
  rcases exists_extension

For theorem:
theorem exists_extension_norm_eq (p : Subspace ℝ E) (f : p →L[ℝ] ℝ) :
    ∃ g : E →L[ℝ] ℝ, (∀ x : p, g x = f x) ∧ ‖g‖ = ‖f‖ 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/HahnBanach/Separation.lean - 2024-08-20 14:45:15.446924.
---0/3204---
Verifying proof:
:= by
  obtain ⟨f, hf₁, hf₂, hf₃⟩ := hs₁.exists_geometric_hahn_banach_open_open hs₂ disj
  rcases disj with ⟨f, hf₁, hf₂⟩
  refine ⟨f, fun a ha =>?_, fun b hb =>?_⟩
  rcases hf a ha with ⟨f, hf₁, hf₂⟩
  refine ⟨f, fun a ha =>?_, fun b hb =>?_⟩
  refine ⟨f, fun a ha =>?_, fun b hb =>?_⟩
  rcases hf a ha with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  rcases hf₁ with ⟨f, hf₁, hf₂⟩
  refine ⟨f,

For theorem:
theorem geometric_hahn_banach_open (hs₁ : Convex ℝ s) (hs₂ : IsOpen s) (ht : Convex ℝ t)
    (disj : Disjoint s t) : ∃ (f : E →L[ℝ] ℝ) (u : ℝ), (∀ a ∈ s, f a < u) ∧ ∀ b ∈ t, u ≤ f b 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine separate_convex_open_separate_of_convex_separate_convex_open hs₁ hs₂ hs₀?_
  refine separate_convex_open_separate_of_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_convex_separate_conv

For theorem:
theorem separate_convex_open_set [TopologicalSpace E] [AddCommGroup E] [TopologicalAddGroup E]
    [Module ℝ E] [ContinuousSMul ℝ E] {s : Set E} (hs₀ : (0 : E) ∈ s) (hs₁ : Convex ℝ s)
    (hs₂ : IsOpen s) {x₀ : E} (hx₀ : x₀ ∉ s) : ∃ f : E →L[ℝ] ℝ, f x₀ = 1 ∧ ∀ x ∈ s, f x < 1 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean - 2024-08-20 14:45:23.033189.
---0/3204---
Verifying proof:
:= by
  let D := max C 1
  have D_pos : 0 ≤ D := le_trans zero_le_one (le_max_right _ _)
  replace H : ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖ := by
    intro m
    rw [← mul_assoc]
    exact continuous_const.mul (continuous_id.mul continuous_const)

For theorem:
theorem continuous_of_bound (C : ℝ) (H : ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖) : Continuous f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt (by positivity) (fun i ↦?_)
  refine lt_of_le_of_lt?_ 

For theorem:
theorem bound_of_shell {ε : ι → ℝ} {C : ℝ} (hε : ∀ i, 0 < ε i) {c : ι → 𝕜} (hc : ∀ i, 1 < ‖c i‖)
    (hf : ∀ m : ∀ i, E i, (∀ i, ε i / ‖c i‖ ≤ ‖m i‖) → (∀ i, ‖m i‖ < ε i) → ‖f m‖ ≤ C * ∏ i, ‖m i‖)
    (m : ∀ i, E i) : ‖f m‖ ≤ C * ∏ i, ‖m i‖ 
Attempt failure.

---0/3204---
Verifying proof:
:=
  ContinuousMultilinearMap.mkContinuous_norm_le f hC H

For theorem:
theorem MultilinearMap.mkContinuous_norm_le (f : MultilinearMap 𝕜 E G) {C : ℝ} (hC : 0 ≤ C)
    (H : ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖) : ‖f.mkContinuous C H‖ ≤ C 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  calc
    ‖f m₁ - f m₂‖ ≤ C * ∑ i, ‖m i‖ := norm_sub_le _ _
    _ ≤ C * ∑ i, ∏ j, if j = i then ‖m i‖ else ‖m i‖ := by
      rw [norm_sub_rev]
      exact norm_image_sub_le _ _ _
    _ ≤ C * ∑ i, ∏ j, if j = i then ‖m i‖ else ‖m i‖ := by
      rw [← Finset.sum_sub_distrib, ← Finset.sum_sub_distrib, ← Finset.sum_sub_distrib]
    _ ≤ C * ∑ i, ∏ j, if j = i then ‖m i‖ else ‖m i‖ := by
      rw [← Finset.sum_sub_distrib, ← Finset.sum_sub_distrib, ← Finset.sum_sub_distrib]
    _ ≤ C * ∑ i, ∏ j, if j = i then ‖m i‖ := by
      rw [Finset.prod_insert (not_mem_erase _ _), Finset.prod_insert (not_mem_erase _ _)]
    _ = C * ∑ i, ∏ j, if j = i then ‖m i‖ := by
      rw [Finset.prod_insert (not_mem_erase _ _), Finset.prod_insert (not_mem_erase _ _)]
    _ ≤ C * ∑ i, ∏ j, if j = i then ‖m i‖ := by
      rw [Finset.prod_insert (not_mem_erase _ _), Finset.prod_insert (not_mem_erase _ _)]
    _ ≤ C * ∑ i, ∏ j, if 

For theorem:
theorem norm_image_sub_le_of_bound' [DecidableEq ι] {C : ℝ} (hC : 0 ≤ C)
    (H : ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖) (m₁ m₂ : ∀ i, E i) :
    ‖f m₁ - f m₂‖ ≤ C * ∑ i, ∏ j, if j = i then ‖m₁ i - m₂ i‖ else max ‖m₁ j‖ ‖m₂ j‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
  have : Nonempty ι := ⟨i⟩
  have : Nonempty ι := ⟨i⟩
  set m' : 𝕜 → ℝ → ℝ → ℝ := fun i => m i
  have : ‖m i‖ ≠ 0 := fun h => norm_ne_zero_iff.mpr (norm_ne_zero_iff.mpr hi)
  have : ‖m i‖ ≠ 0 := by simpa only [norm_eq_zero] using hi

For theorem:
lemma norm_map_coord_zero (hf : Continuous f) {m : ∀ i, E i} {i : ι} (hi : ‖m i‖ = 0) :
    ‖f m‖ = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  calc
    ‖f m₁ - f m₂‖ ≤ C * ∑ i, ‖m i‖ := norm_sub_le _ _
    _ ≤ C * ∑ i, ∏ j, if j = i then ‖m i‖ else ‖m i‖ := by
      rw [norm_sub_rev]
      exact norm_image_sub_le _ _ _
    _ ≤ C * ∑ i, ∏ j, if j = i then ‖m i‖ else ‖m i‖ := by
      rw [← Finset.sum_sub_distrib, ← Finset.sum_sub_distrib, ← Finset.sum_sub_distrib]
    _ ≤ C * ∑ i, ∏ j, if j = i then ‖m i‖ else ‖m i‖ := by
      rw [← Finset.sum_sub_distrib, ← Finset.sum_sub_distrib, ← Finset.sum_sub_distrib]
    _ ≤ C * ∑ i, ∏ j, if j = i then ‖m i‖ := by
      rw [Finset.prod_insert (not_mem_erase _ _), Finset.prod_insert (not_mem_erase _ _)]
    _ = C * ∑ i, ∏ j, if j = i then ‖m i‖ := by
      rw [Finset.prod_insert (not_mem_erase _ _), Finset.prod_insert (not_mem_erase _ _)]
    _ ≤ C * ∑ i, ∏ j, if j = i then ‖m i‖ := by
      rw [Finset.prod_insert (not_mem_erase _ _), Finset.prod_insert (not_mem_erase _ _)]
    _ ≤ C * ∑ i, ∏ j, if 

For theorem:
theorem norm_image_sub_le_of_bound' [DecidableEq ι] {C : ℝ} (hC : 0 ≤ C)
    (H : ∀ m, ‖f m‖ ≤ C * ∏ i, ‖m i‖) (m₁ m₂ : ∀ i, E i) :
    ‖f m₁ - f m₂‖ ≤ C * ∑ i, ∏ j, if j = i then ‖m₁ i - m₂ i‖ else max ‖m₁ j‖ ‖m₂ j‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine bound_of_shell_of_continuous_of_continuous_of_continuous_of_continuous_of_continuous_of_continuousOn hfc?_?_?_
  · refine bound_of_shell_of_continuousOn_of_continuousOn_of_continuousOn_of_continuousOn hfc?_?_?_?_?_
    · exact hfc.bound_of_continuousOn
  · exact hfc.bound_of_shell_of_continuousOn (fun m _ => hf m _) (fun m _ => hf m _)
  · exact hfc.bound_of_shell_of_continuousOn (fun m _ => hf m _) (fun m _ => hf m _) (fun m _ => hf m _)
    · exact hfc.bound_of_continuousOn (fun m _ => hf m _) (fun m _ => hf m _) (fun m _ => hf m _)
    · exact hfc.bound_of_continuousOn (fun m _ => hf m _) (fun m _ => hf m _)
  · exact hfc.bound_of_continuousOn (fun m _ => hf m _) (fun m _ => hf m _)
  · exact hfc.bound_of_continuousOn (fun m _ => hf m _) (fun m _ => hf m _) (fun m _ => hf m _)
    · exact hfc.bound_of_continuousOn (fun m _ => hf m _) (fun m _ => hf m _) (fun m _ => hf m _)
    · exact hfc.bound_of_continuousOn (fun m _ => hf m _) (fun m _ => hf m _) (fun m _ => hf m _)
   

For theorem:
theorem bound_of_shell_of_continuous (hfc : Continuous f)
    {ε : ι → ℝ} {C : ℝ} (hε : ∀ i, 0 < ε i) {c : ι → 𝕜} (hc : ∀ i, 1 < ‖c i‖)
    (hf : ∀ m : ∀ i, E i, (∀ i, ε i / ‖c i‖ ≤ ‖m i‖) → (∀ i, ‖m i‖ < ε i) → ‖f m‖ ≤ C * ∏ i, ‖m i‖)
    (m : ∀ i, E i) : ‖f m‖ ≤ C * ∏ i, ‖m i‖ 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/OperatorNorm/Basic.lean - 2024-08-20 14:49:26.567341.
---0/3204---
Verifying proof:
:= by
  rcases eq_or_lt_of_le ε_pos with (rfl | hε)
  · simp only [mem_ball, dist_zero_right, norm_zero] at hε
    exact hε.trans (mul_le_mul_of_nonneg_right (norm_nonneg _) (norm_nonneg _))

For theorem:
theorem opNorm_le_of_ball {f : E →SL[σ₁₂] F} {ε : ℝ} {C : ℝ} (ε_pos : 0 < ε) (hC : 0 ≤ C)
    (hf : ∀ x ∈ ball (0 : E) ε, ‖f x‖ ≤ C * ‖x‖) : ‖f‖ ≤ C 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine le_antisymm _ (norm_nonneg _)
  apply opNorm_le_bound _ rfl.ge
  intro x
  simp [Subsingleton.elim x 0]

For theorem:
theorem opNorm_subsingleton [Subsingleton E] : ‖f‖ = 0 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/OperatorNorm/Completeness.lean - 2024-08-20 14:49:51.327527.
---0/3204---
Verifying proof:
:= by
  refine opNorm_le_bound _?_ (isClosed_property h_dense (isClosed_property h_dense (isClosed_le?_?_) fun x hx =>?_) fun x hx =>?_
  · exact f.extend_of_bound e h_dense (isClosed_property h_dense (isClosed_le?_?_) fun x hx =>?_) fun x hx =>?_
  · exact f.extend_of_bound e h_dense (isClosed_property h_dense (isClosed_le?_?_) fun x hx =>?_) fun x hx =>?_
  · exact f.extend_of_bound e h_dense (isClosed_property h_dense (isClosed_le?_?_) fun x hx =>?_) fun x hx =>?_
  · exact f.extend_of_bound e h_dense (isClosed_property h_dense (isClosed_le?_?_) fun x hx =>?_) fun x hx =>?_
  · exact f.extend_of_bound e h_dense (isClosed_property h_dense (isClosed_le?_?_) fun x hx =>?_) fun x hx =>?_
  · exact f.extend_of_bound e h_dense (isClosed_property h_dense (isClosed_le?_?_) fun x hx =>?_) fun x hx =>?_
    · exact f.extend_of_bound e h_dense (isClosed_le?_?_) fun x hx =>?_
    · exact f.extend_of_bound e h_dense (isClosed_property h_dense (isClosed_le?_?_) fun x hx =>?_) 

For theorem:
theorem opNorm_extend_le :
    ‖f.extend e h_dense (uniformEmbedding_of_bound _ h_e).toUniformInducing‖ ≤ N * ‖f‖ := by
    refine opNorm_le_bound _ ?_ (isClosed_property h_dense (isClosed_le ?_ ?_) fun x ↦ ?_)
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/OperatorNorm/NormedSpace.lean - 2024-08-20 14:49:55.768530.
---0/3204---
Verifying proof:
:= by
  tfae_have 1 → 3
  · refine ⟨0, fun i x =>?_⟩
    simp only [equicontinuousAt_zero_iff_uniformContinuousAt] at tfae_have 1 → 3
  · exact ⟨0, fun i x => by simp only [norm_zero, mul_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero, mul_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero, mul_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero, mul_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩

For theorem:
theorem NormedSpace.equicontinuous_TFAE : List.TFAE
    [ EquicontinuousAt ((↑) ∘ f) 0,
      Equicontinuous ((↑) ∘ f),
      UniformEquicontinuous ((↑) ∘ f),
      ∃ C, ∀ i x, ‖f i x‖ ≤ C * ‖x‖,
      ∃ C ≥ 0, ∀ i x, ‖f i x‖ ≤ C * ‖x‖,
      ∃ C, ∀ i, ‖f i‖ ≤ C,
      ∃ C ≥ 0, ∀ i, ‖f i‖ ≤ C,
      BddAbove (Set.range (‖f ·‖)),
      (⨆ i, (‖f i‖₊ : ENNReal)) < ⊤ ] := by
    tfae_have 1 → 3
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases subsingleton_or_nontrivial F
  · simp only [LinearIsometryEquiv.coe_toLinearMap, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEqu

For theorem:
theorem opNorm_comp_linearIsometryEquiv (f : F →SL[σ₂₃] G) (g : F' ≃ₛₗᵢ[σ₂'] F) :
    ‖f.comp g.toLinearIsometry.toContinuousLinearMap‖ = ‖f‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply le_antisymm
  · refine opNorm_le_bound _ (mul_nonneg (norm_nonneg _) (norm_nonneg _) (norm_nonneg _)) (norm_nonneg _)
    (norm_nonneg _) (norm_nonneg _)

For theorem:
theorem norm_smulRight_apply (c : E →L[𝕜] 𝕜) (f : Fₗ) : ‖smulRight c f‖ = ‖c‖ * ‖f‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases subsingleton_or_nontrivial F
  · simp only [LinearIsometryEquiv.coe_toLinearMap, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe,
    LinearIsometryEquiv.coe_coe, LinearIsometryEquiv.coe_coe, LinearIsometryEqu

For theorem:
theorem opNorm_comp_linearIsometryEquiv (f : F →SL[σ₂₃] G) (g : F' ≃ₛₗᵢ[σ₂'] F) :
    ‖f.comp g.toLinearIsometry.toContinuousLinearMap‖ = ‖f‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  tfae_have 1 → 3
  · refine ⟨0, fun i x =>?_⟩
    simp only [equicontinuousAt_zero_iff_uniformContinuousAt] at tfae_have 1 → 3
  · exact ⟨0, fun i x => by simp only [norm_zero, mul_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero, mul_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero, mul_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero, mul_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩
  · exact ⟨0, fun i x => by simp only [norm_zero]⟩

For theorem:
theorem NormedSpace.equicontinuous_TFAE : List.TFAE
    [ EquicontinuousAt ((↑) ∘ f) 0,
      Equicontinuous ((↑) ∘ f),
      UniformEquicontinuous ((↑) ∘ f),
      ∃ C, ∀ i x, ‖f i x‖ ≤ C * ‖x‖,
      ∃ C ≥ 0, ∀ i x, ‖f i x‖ ≤ C * ‖x‖,
      ∃ C, ∀ i, ‖f i‖ ≤ C,
      ∃ C ≥ 0, ∀ i, ‖f i‖ ≤ C,
      BddAbove (Set.range (‖f ·‖)),
      (⨆ i, (‖f i‖₊ : ENNReal)) < ⊤ ] := by
    tfae_have 1 → 3
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/OperatorNorm/Prod.lean - 2024-08-20 14:50:34.979085.
---0/3204---
Verifying proof:
:= by
  refine le_antisymm (norm_fst_le..) (norm_fst_le..)?_
  rw [norm_fst_le..]
  exact norm_fst_le..

For theorem:
lemma norm_fst [NormedAddCommGroup E] [NormedSpace 𝕜 E]
    [SeminormedAddCommGroup F] [NormedSpace 𝕜 F] [Nontrivial E] :
    ‖fst 𝕜 E F‖ = 1 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/PiLp.lean - 2024-08-20 14:50:42.396726.
---0/3204---
Verifying proof:
:= by
  dsimp [Norm.norm]
  exact if_neg ENNReal.top_ne_zero

For theorem:
theorem norm_eq_ciSup (f : PiLp ∞ β) : ‖f‖ = ⨆ i, ‖f i‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases p.trichotomy with (rfl | rfl | h)
  · simp only [edist_eq_card, eq_comm, Ne.def]
  · simp only [edist_eq_card, eq_comm, Ne.def]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [edist_eq_iSup, edist_comm]
  · simp only [ed

For theorem:
theorem edist_comm (f g : PiLp p β) : edist f g = edist g f 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/PiTensorProduct/InjectiveSeminorm.lean - 2024-08-20 14:50:58.167525.
---0/3204---
Verifying proof:
:= map_pow mapLMonoidHom _ _

For theorem:
theorem mapL_pow (f : Π i, E i →L[𝕜] E i) (n : ℕ) :
    mapL (f ^ n) = mapL f ^ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine le_antisymm?_?_
  · rintro ⟨i, hi⟩
    simp only [mapL_pow, map_pow, mapL_coe, mapL_coe]
    simp only [mapL_coe, mapL_coe, mapL_coe, mapL_coe, mapL_coe, mapL_coe, mapL_coe]
    simp only [mapL_coe, mapL_coe, mapL_coe, mapL_coe]
    simp only [mapL_coe, mapL_coe, mapL_coe, mapL_coe, mapL_coe, mapL_coe]
    simp only [mapL_coe, mapL_coe, mapL_coe, mapL_coe, mapL_coe, mapL_coe]
    simp only [mapL_coe, mapL_coe, mapL_coe, mapL_coe, mapL_coe, mapL_coe]
    simp only [mapL_coe, mapL_coe, mapL_coe, mapL_coe]
    simp only [mapL_coe, mapL_coe, mapL_coe, mapL_coe, mapL_coe]
    simp only [mapL_coe, mapL_coe, mapL_coe, mapL_coe, mapL_coe, mapL_coe]
    simp only [mapL_coe, mapL_coe, mapL_coe, mapL_coe, mapL_coe, mapL_coe]
    simp only [mapL_coe, mapL_coe, mapL_coe, mapL_coe]
    simp only [mapL_coe, mapL_coe, mapL_coe, mapL_coe]
    simp only [mapL_coe, mapL_coe, mapL_coe, mapL_coe]
    simp only [mapL_coe, mapL_coe, mapL_coe, mapL_coe]
    simp only [mapL_coe, mapL_coe, mapL_coe, mapL_coe, ma

For theorem:
theorem mapL_pow (f : Π i, E i →L[𝕜] E i) (n : ℕ) :
    mapL (f ^ n) = mapL f ^ n 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/ProdLp.lean - 2024-08-20 14:51:25.826120.
---0/3204---
Verifying proof:
:= by
  dsimp [Norm.norm]

For theorem:
theorem prod_norm_eq_sup (f : WithLp ∞ (α × β)) : ‖f‖ = ‖f.fst‖ ⊔ ‖f.snd‖ 
Attempt success.

Working on Mathlib/Analysis/NormedSpace/QuaternionExponential.lean - 2024-08-20 14:51:32.000732.
---0/3204---
Verifying proof:
:= by
  have hc' : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / (2 * n)!) c := by
    have hc' : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / (2 * n)!) c := by
    have hc' : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / (2 * n)!) c := by
    have hc' : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / (2 * n)!) c := by
      have hc' : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / (2 * n)!) c := by
      have hc' : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / (2 * n)!) c := by
      have hc' : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / (2 * n)!) c := by
      have hc' : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / (2 * n)!) c := by
      have hc' : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / (2 * n)!) c := by
      have hc' : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / (2 * n)!) c := by
      have hc' : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / (2 * n)!) c := by
      have hc' : HasSum (fun n => (-1 : ℝ) ^ n

For theorem:
theorem hasSum_expSeries_of_imaginary {q : Quaternion ℝ} (hq : q.re = 0) {c s : ℝ}
    (hc : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n) / (2 * n)!) c)
    (hs : HasSum (fun n => (-1 : ℝ) ^ n * ‖q‖ ^ (2 * n + 1) / (2 * n + 1)!) s) :
    HasSum (fun n => expSeries ℝ (Quaternion ℝ) n fun _ => q) (↑c + (s / ‖q‖) • q) 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Ray.lean - 2024-08-20 14:51:36.189758.
---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne x 0 with (rfl | hx); · simp [SameRay.zero_left]

For theorem:
theorem sameRay_iff_inv_norm_smul_eq : SameRay ℝ x y ↔ x = 0 ∨ y = 0 ∨ ‖x‖⁻¹ • x = ‖y‖⁻¹ • y 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/RieszLemma.lean - 2024-08-20 14:51:38.351296.
---0/3204---
Verifying proof:
:= by
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  

For theorem:
theorem riesz_lemma_of_norm_lt {c : 𝕜} (hc : 1 < ‖c‖) {R : ℝ} (hR : ‖c‖ < R) {F : Subspace 𝕜 E}
    (hFc : IsClosed (F : Set E)) (hF : ∃ x : E, x ∉ F) :
    ∃ x₀ : E, ‖x₀‖ ≤ R ∧ ∀ y ∈ F, 1 ≤ ‖x₀ - y‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  rcases hF with ⟨x₀, hx₀⟩
  

For theorem:
theorem riesz_lemma {F : Subspace 𝕜 E} (hFc : IsClosed (F : Set E)) (hF : ∃ x : E, x ∉ F) {r : ℝ}
    (hr : r < 1) : ∃ x₀ : E, x₀ ∉ F ∧ ∀ y ∈ F, r * ‖x₀‖ ≤ ‖x₀ - y‖ 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Spectrum.lean - 2024-08-20 14:51:41.829615.
---0/3204---
Verifying proof:
:= by
  refine ENNReal.inv_le_of_forall_pos_le_add fun ε hε =>?_
  refine ENNReal.inv_le_of_forall_pos_le_add fun εpos =>?_
  refine ENNReal.le_of_forall_pos_le_add fun εpos =>?_
  refine ENNReal.le_of_forall_nnreal_lt fun εpos =>?_
  refine ENNReal.le_of_forall_pos_le_add fun εpos =>?_
  refine ENNReal.le_of_forall_pos_le_add fun εpos =>?_
  refine ENNReal.le_of_forall_pos_le_add fun εpos =>?_
  refine ENNReal.le_of_forall_pos_le_add fun εpos =>?_
  refine ENNReal.le_of_forall_pos_le_add fun εpos =>?_
  refine ENNReal.le_of_forall_pos_le_add fun εpos =>?_
  refine ENNReal.le_of_forall_pos_le_add fun εpos =>?_
  refine ENNReal.le_of_forall_pos_le_add fun εpos =>?_
  refine ENNReal.le_of_forall_pos_le_add fun εpos =>?_
  refine ENNReal.le_of_forall_pos_le_add fun εpos =>?_
  refine ENNReal.le_of_forall_pos_le_add fun εpos =>?_
  refine ENNReal.le_of_forall_pos_le_add fun εpos =>?_
  refine ENNReal.le_of_forall_nnreal_lt fun εpos =>?_
  refine le_of_forall_nnreal_lt fun εpos

For theorem:
theorem limsup_pow_nnnorm_pow_one_div_le_spectralRadius (a : A) :
    limsup (fun n : ℕ => (‖a ^ n‖₊ : ℝ≥0∞) ^ (1 / n : ℝ)) atTop ≤ spectralRadius ℂ a 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : HasFPowerSeriesOnBall (fun z : 𝕜 => Ring.inverse (1 - z • a)) (fun z : 𝕜 => Ring.inverse (1 - z • a)) :=
    hasFPowerSeriesOnBall_inverse_of_hasFPowerSeriesOnBall (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a)) :=
    hasFPowerSeriesOnBall_inverse_of_hasFPowerSeriesOnBall (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜

For theorem:
theorem hasFPowerSeriesOnBall_inverse_one_sub_smul [CompleteSpace A] (a : A) :
    HasFPowerSeriesOnBall (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun n => ContinuousMultilinearMap.mkPiRing 𝕜 (Fin n) (a ^ n)) 0 ‖a‖₊⁻¹ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : HasFPowerSeriesOnBall (fun z : 𝕜 => Ring.inverse (1 - z • a)) (fun z : 𝕜 => Ring.inverse (1 - z • a)) :=
    hasFPowerSeriesOnBall_inverse_of_hasFPowerSeriesOnBall (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a)) :=
    hasFPowerSeriesOnBall_inverse_of_hasFPowerSeriesOnBall (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun z : 𝕜

For theorem:
theorem hasFPowerSeriesOnBall_inverse_one_sub_smul [CompleteSpace A] (a : A) :
    HasFPowerSeriesOnBall (fun z : 𝕜 => Ring.inverse (1 - z • a))
      (fun n => ContinuousMultilinearMap.mkPiRing 𝕜 (Fin n) (a ^ n)) 0 ‖a‖₊⁻¹ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le?_ (eventually_of_forall fun n ↦?_)
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le?_ (eventually_of_forall fun n ↦?_)
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le?_ (eventually_of_forall fun _ ↦ norm_nonneg _)
    (eventually_of_forall fun _ ↦ norm_nonneg _) (eventually_of_forall fun n ↦?_)
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le?_ (eventually_of_forall fun _ ↦ norm_nonneg _)
    (eventually_of_forall fun _ ↦ norm_nonneg _) (eventually_of_forall fun n ↦?_)
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le?_ (eventually_of_forall fun _ ↦ norm_nonneg _)
    (eventually_of_forall fun _ ↦ norm_nonneg _) (eventually_of_forall fun n ↦?_)
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le?_ (eventually_of_forall fun _ ↦ norm_nonneg _)
    (eventually_of_forall fun _ ↦ norm_nonneg _) (eventually_of_forall fun n ↦?_)
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le?_ (eventually_of_forall fun n ↦

For theorem:
theorem pow_norm_pow_one_div_tendsto_nhds_spectralRadius (a : A) :
    Tendsto (fun n : ℕ => ENNReal.ofReal (‖a ^ n‖ ^ (1 / n : ℝ))) atTop
      (𝓝 (spectralRadius ℂ a)) 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus.lean - 2024-08-20 14:52:23.334574.
---0/3204---
Verifying proof:
:= by
  nontriviality A
  refine ⟨a, self_mem ℂ a⟩ ⟨a, self_mem ℂ a⟩ ⟨a, self_mem ℂ a⟩ ⟨a, self_mem ℂ a⟩ ⟨a, self_mem ℂ a⟩

For theorem:
theorem elementalStarAlgebra.isUnit_of_isUnit_of_isStarNormal (h : IsUnit a) :
    IsUnit (⟨a, self_mem ℂ a⟩ : elementalStarAlgebra ℂ a) := by
      nontriviality A
Attempt failure.

---0/3204---
Verifying proof:
:= by
  nontriviality A
  refine ⟨a, self_mem ℂ a⟩ ⟨a, self_mem ℂ a⟩ ⟨a, self_mem ℂ a⟩ ⟨a, self_mem ℂ a⟩ ⟨a, self_mem ℂ a⟩

For theorem:
theorem elementalStarAlgebra.isUnit_of_isUnit_of_isStarNormal (h : IsUnit a) :
    IsUnit (⟨a, self_mem ℂ a⟩ : elementalStarAlgebra ℂ a) := by
      nontriviality A
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hx := h.star.mul h
  suffices (↑h.unit⁻¹ : A) ∈ S by simpa only [this] using this

For theorem:
theorem StarSubalgebra.isUnit_coe_inv_mem {S : StarSubalgebra ℂ A} (hS : IsClosed (S : Set A))
    {x : A} (h : IsUnit x) (hxS : x ∈ S) : ↑h.unit⁻¹ ∈ S 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine
    ⟨fun hx => ⟨⟨x, ⟨(↑hx.unit⁻¹ : A), hx.unit⁻¹ : A⟩, fun hx =>?_⟩
  · exact ⟨⟨x, ⟨hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A⟩, fun hx => ⟨⟨x, hx.unit⁻¹ : A

For theorem:
theorem StarSubalgebra.coe_isUnit {S : StarSubalgebra ℂ A} (hS : IsClosed (S : Set A)) {x : S} :
    IsUnit (x : A) ↔ IsUnit x 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Instances.lean - 2024-08-20 14:52:49.521529.
---0/3204---
Verifying proof:
:= by
  set a := star b * b
  have a_def : a = star b * b := rfl
  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg
  have a_neg : a = star b * b := rfl
  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg
  have a_def : a = star b * b := rfl
  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg
  have a_def : a = star b * b := rfl
  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg
  have a_def : a = star b * b := rfl
  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b))
  have a_def : a = star b * b := rfl
  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b))
  have a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b))
  have a_def : a = star b * b := rfl
  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg : A := cfc (fun x 

For theorem:
lemma spectrum_star_mul_self_nonneg {b : A} : ∀ x ∈ spectrum ℝ (star b * b), 0 ≤ x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun hu ↦?_,?_⟩
  · have h_normal := isStarNormal_iff_isStarNormal_and_spectrum_subset_circle h_normal

For theorem:
lemma unitary_iff_isStarNormal_and_spectrum_subset_circle {u : A} :
    u ∈ unitary A ↔ IsStarNormal u ∧ spectrum ℂ u ⊆ circle 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  set a := star b * b
  have a_def : a = star b * b := rfl
  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg
  have a_neg : a = star b * b := rfl
  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg
  have a_def : a = star b * b := rfl
  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg
  have a_def : a = star b * b := rfl
  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg
  have a_def : a = star b * b := rfl
  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b))
  have a_def : a = star b * b := rfl
  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b))
  have a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b))
  have a_def : a = star b * b := rfl
  let a_neg : A := cfc (fun x ↦ (- ContinuousMap.star b * b)) a_neg : A := cfc (fun x 

For theorem:
lemma spectrum_star_mul_self_nonneg {b : A} : ∀ x ∈ spectrum ℝ (star b * b), 0 ≤ x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [SpectrumRestricts.nnreal_iff]

For theorem:
lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 ≤ a ↔ IsSelfAdjoint a ∧ SpectrumRestricts a ContinuousMap.realToNNReal 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Star/GelfandDuality.lean - 2024-08-20 14:54:28.627797.
---0/3204---
Verifying proof:
:= by
  nontriviality A
  refine AddMonoidHomClass.isometry_of_norm (gelfandTransform ℂ A) fun a =>?_
  have : spectralRadius ℂ (gelfandTransform ℂ A) = spectralRadius ℂ (gelfandTransform ℂ A) := by
    refine AddMonoidHomClass.isometry_of_norm (gelfandTransform ℂ A) fun a =>?_
    have : spectralRadius ℂ (gelfandTransform ℂ A) = spectralRadius ℂ (gelfandTransform ℂ A) := by
    refine AddMonoidHomClass.isometry_of_norm (gelfandTransform ℂ A) fun a =>?_
    have : spectralRadius ℂ (gelfandTransform ℂ A) = spectralRadius ℂ (gelfandTransform ℂ A) := by
    refine AddMonoidHomClass.isometry_of_norm (gelfandTransform ℂ A) fun a =>?_
    have : spectralRadius ℂ (gelfandTransform ℂ A) = spectralRadius ℂ (gelfandTransform ℂ A) := by
    refine AddMonoidHomClass.isometry_of_norm (gelfandTransform ℂ A) fun a =>?_
    have : spectralRadius ℂ (gelfandTransform ℂ A) = spectralRadius ℂ (gelfandTransform ℂ A) := by
      refine AddMonoidHomClass.isometry_of_norm (gelf

For theorem:
theorem gelfandTransform_isometry : Isometry (gelfandTransform ℂ A) 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Star/Multiplier.lean - 2024-08-20 14:54:36.058498.
---0/3204---
Verifying proof:
:= by
  have h0 : ∀ f : A →L[𝕜] A, ∀ b : A, ‖f b‖₊ ^ 2 ≤ C * ‖f b‖₊ * ‖b‖₊ := by
    intro f hf
    refine le_antisymm?_ (norm_fst_le_of_forall_le_of_dense fun b =>?_)
    refine le_of_forall_le_of_dense fun b =>?_
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm, dist_eq_norm

For theorem:
theorem norm_fst_eq_snd (a : 𝓜(𝕜, A)) : ‖a.fst‖ = ‖a.snd‖ := by
    have h0 : ∀ f : A →L[𝕜] A, ∀ C : ℝ≥0, (∀ b : A, ‖f b‖₊ ^ 2 ≤ C * ‖f b‖₊ * ‖b‖₊) → ‖f‖₊ ≤ C := by
    intro f C h
    have h1 : ∀ b, C * ‖f b‖₊ * ‖b‖₊ ≤ C * ‖f‖₊ * ‖b‖₊ ^ 2 := by
      intro b
      convert mul_le_mul_right' (mul_le_mul_left' (f.le_opNNNorm b) C) ‖b‖₊ using 1
      ring
    have := NNReal.div_le_of_le_mul $ f.opNNNorm_le_bound _ $ by
      simpa only [sqrt_sq, sqrt_mul] using fun b ↦ sqrt_le_sqrt.2 $ (h b).trans (h1 b)
    convert NNReal.rpow_le_rpow this two_pos.le
    · simp only [NNReal.rpow_two, div_pow, sq_sqrt]
      simp only [sq, mul_self_div_self]
    · simp only [NNReal.rpow_two, sq_sqrt]
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have h0 : ∀ f : A →L[𝕜] A, ∀ b : A, ‖f b‖₊ ^ 2 ≤ C * ‖f b‖₊ * ‖b‖₊ := by
    intro f hf
    refine le_antisymm?_ (norm_fst_le_of_forall_le_of_dense fun b =>?_)
    refine le_of_forall_le_of_dense fun b =>?_
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm] at hf
    simp only [dist_eq_norm, dist_eq_norm

For theorem:
theorem norm_fst_eq_snd (a : 𝓜(𝕜, A)) : ‖a.fst‖ = ‖a.snd‖ := by
    have h0 : ∀ f : A →L[𝕜] A, ∀ C : ℝ≥0, (∀ b : A, ‖f b‖₊ ^ 2 ≤ C * ‖f b‖₊ * ‖b‖₊) → ‖f‖₊ ≤ C := by
    intro f C h
    have h1 : ∀ b, C * ‖f b‖₊ * ‖b‖₊ ≤ C * ‖f‖₊ * ‖b‖₊ ^ 2 := by
      intro b
      convert mul_le_mul_right' (mul_le_mul_left' (f.le_opNNNorm b) C) ‖b‖₊ using 1
      ring
    have := NNReal.div_le_of_le_mul $ f.opNNNorm_le_bound _ $ by
      simpa only [sqrt_sq, sqrt_mul] using fun b ↦ sqrt_le_sqrt.2 $ (h b).trans (h1 b)
    convert NNReal.rpow_le_rpow this two_pos.le
    · simp only [NNReal.rpow_two, div_pow, sq_sqrt]
      simp only [sq, mul_self_div_self]
    · simp only [NNReal.rpow_two, sq_sqrt]
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Star/Spectrum.lean - 2024-08-20 14:55:07.507748.
---0/3204---
Verifying proof:
:= by
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  letI : Algebra ℚ A := RestrictScalars.algebra ℚ A
  have : 

For theorem:
theorem IsSelfAdjoint.mem_spectrum_eq_re [StarModule ℂ A] {a : A} (ha : IsSelfAdjoint a) {z : ℂ}
    (hz : z ∈ spectrum ℂ a) : z = z.re 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hu := exp_mem_unitary_of_mem_skewAdjoint ⟨z, hz⟩
  have hu' := exp_mem_unitary_of_mem_skewAdjoint ⟨a, hz⟩
  have ha' : a ∈ spectrum ℂ a := by simpa using hz
  have ha' : a ∈ spectrum ℂ a := by simpa using hz
  have ha'' : a ∈ spectrum ℂ a := by simpa using hz
  have ha'' : a ∈ spectrum ℂ a := by simpa using hz
  have ha'' : a ∈ spectrum ℂ a := by simpa using hz
  have ha'' : a ∈ spectrum ℂ a := by simpa using hz
  have ha'' : a ∈ spectrum ℂ a := by simpa using hz
  have ha'' : a ∈ spectrum ℂ a := by simpa using hz
  have ha'' : a ∈ spectrum ℂ a := by simpa using hz
  have ha'' : a ∈ spectrum ℂ a := by simpa using hz
  have ha'' : a ∈ spectrum ℂ a := by simpa using hz
  have ha'' : a ∈ spectrum ℂ a := by simpa using hz
  have ha'' : a ∈ spectrum ℂ a := by simpa using hz
  have ha'' : a ∈ spectrum ℂ a := by simpa using hz
  have ha'' : a ∈ spectrum ℂ a := by simpa using hz
  have ha'' : a ∈ spectrum ℂ a := by simpa using hz
  

For theorem:
theorem IsSelfAdjoint.mem_spectrum_eq_re [StarModule ℂ A] {a : A} (ha : IsSelfAdjoint a) {z : ℂ}
    (hz : z ∈ spectrum ℂ a) : z = z.re 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Star/Unitization.lean - 2024-08-20 14:55:16.728343.
---0/3204---
Verifying proof:
:= by
  refine (Real.le_sqrt (norm_nonneg _)).trans?_
  refine (Real.le_sqrt (norm_nonneg _)).trans?_
  refine (Real.le_sqrt (norm_nonneg _)).trans?_
  refine (Real.le_sqrt (norm_nonneg _)).trans?_
  refine (Real.le_sqrt (norm_nonneg _)).trans?_
  refine (Real.le_sqrt (norm_nonneg _)).trans?_
  refine (Real.le_sqrt (norm_nonneg _)).trans?_
  refine (Real.le_sqrt (norm_nonneg _)).trans?_
  refine (Real.le_sqrt (norm_nonneg _)).trans?_
  refine (Real.le_sqrt (norm_nonneg _)).trans?_

For theorem:
theorem Unitization.norm_splitMul_snd_sq (x : Unitization 𝕜 E) :
    ‖(Unitization.splitMul 𝕜 E x).snd‖ ^ 2 ≤ ‖(Unitization.splitMul 𝕜 E (star x * x)).snd‖ := by
    refine (Real.le_sqrt (norm_nonneg _) (norm_nonneg _)).mp ?_
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Unitization.lean - 2024-08-20 14:55:20.155371.
---0/3204---
Verifying proof:
:= by
  rw [injective_iff_map_eq_zero]
  intro x hx
  induction x using Polynomial.induction_on' with
  | zero => simp only [splitMul_zero, splitMul_zero, splitMul_zero]
  | succ n ihn =>
    simp only [splitMul_apply, splitMul_apply, splitMul_apply]

For theorem:
theorem splitMul_injective_of_clm_mul_injective
    (h : Function.Injective (mul 𝕜 A)) :
    Function.Injective (splitMul 𝕜 A) 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/Units.lean - 2024-08-20 14:55:26.843266.
---0/3204---
Verifying proof:
:=
  let u := Units.oneSub (1 - x) hx
    I.eq_top_iff_one.mpr <| by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by simpa only [show u.inv * x = 1 by si

For theorem:
theorem eq_top_of_norm_lt_one (I : Ideal R) {x : R} (hxI : x ∈ I) (hx : ‖1 - x‖ < 1) : I = ⊤ 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/WeakDual.lean - 2024-08-20 14:55:29.755455.
---0/3204---
Verifying proof:
:= by
  simp only [polar_def, setOf_forall]
  exact isClosed_Iic.preimage (WeakBilin.eval_continuous _ _).norm

For theorem:
theorem isClosed_polar (s : Set E) : IsClosed (polar 𝕜 s) 
Attempt failure.

Working on Mathlib/Analysis/NormedSpace/lpSpace.lean - 2024-08-20 14:55:34.331941.
---0/3204---
Verifying proof:
:= by
  rcases p.trichotomy with (rfl | rfl | hp)
  · exact absurd rfl hp
  · exact absurd rfl hp

For theorem:
theorem norm_const_smul_le (hp : p ≠ 0) (c : 𝕜) (f : lp E p) : ‖c • f‖ ≤ ‖c‖ * ‖f‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases p.trichotomy with (rfl | rfl | hp)
  · apply memℓp_zero
  · apply memℓp_zero
    refine hf.finite_dsupport.subset_closure?_
    refine hf.finite_dsupport.subset_closure?_
  · apply memℓp_zero
    refine hf.finite_dsupport.subset_closure?_
  · apply memℓp_zero
    refine hf.finite_dsupport.subset_closure?_
  · apply memℓp_zero
    refine hf.finite_dsupport.subset_closure?_
  · apply memℓp_zero
    refine hf.finite_dsupport.subset_closure?_
  · apply memℓp_zero
    refine hf.finite_dsupport.subset_closure?_
  · apply memℓp_zero
    refine hf.finite_dsupport.subset_closure?_
  · apply memℓp_zero
    refine hf.finite_dsupport.subset_closure?_
  · apply memℓp_zero
    refine hf.finite_dsupport.subset_closure?_
  · apply memℓp_zero
    refine hf.finite_dsupport.subset_closure?_
  · apply memℓp_zero
    refine hf.finite_dsupport.subset_closure?_
  · apply memℓp_zero
    refine hf.finite_dsupport.subset_closure?_
    refine hf.finite_dsupport.subset_

For theorem:
theorem const_smul {f : ∀ i, E i} (hf : Memℓp f p) (c : 𝕜) : Memℓp (c • f) p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hp₀ : 0 < p := zero_lt_one.trans_le Fact.out
  have hp' : 0 < p := zero_lt_one.trans_le Fact.out
  have hp' : 0 < p := zero_lt_one.trans_le Fact.out
 

For theorem:
theorem hasSum_single [Fact (1 ≤ p)] (hp : p ≠ ⊤) (f : lp E p) :
    HasSum (fun i : α => lp.single p i (f i : E i)) f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases p.trichotomy with (rfl | rfl | hp)
  · simp [lp.norm_eq_card_dsupport f]
  · simp [lp.norm_eq_card_dsupport f]
  · cases' isEmpty_or_nonempty α with _i _i
    · rw [lp.norm_eq_card_dsupport f]
      exact lp.norm_eq_card_dsupport f

For theorem:
theorem norm_nonneg' (f : lp E p) : 0 ≤ ‖f‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨s, hs⟩ : ∃ s : Finset ι, Memℓp s p := hF.tendsto_left_iff.mp hf
  refine ⟨fun i =>?_, fun i =>?_⟩
  refine memℓp_generateFrom_iff.mpr fun i =>?_⟩
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun

For theorem:
theorem memℓp_of_tendsto {F : ι → lp E p} (hF : Bornology.IsBounded (Set.range F)) {f : ∀ a, E a}
    (hf : Tendsto (id fun i => F i : ι → ∀ a, E a) l (𝓝 f)) : Memℓp f p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [memℓp_infty_iff]
  obtain ⟨⟨Cf, hCf⟩, ⟨Cg, hCg⟩⟩ := hf
  obtain ⟨⟨Cg, hCg⟩, ⟨Cg, hCg⟩⟩ := hf
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩ := hg
  obtain ⟨Cg, hCg⟩

For theorem:
theorem _root_.Memℓp.infty_mul {f g : ∀ i, B i} (hf : Memℓp f ∞) (hg : Memℓp g ∞) :
    Memℓp (f * g) ∞ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨s, hs⟩ : ∃ s : Finset ι, Memℓp s p := hF.tendsto_left_iff.mp hf
  refine ⟨fun i =>?_, fun i =>?_⟩
  refine memℓp_generateFrom_iff.mpr fun i =>?_⟩
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun i =>?_
  refine memℓp_generateFrom_iff.mpr fun

For theorem:
theorem memℓp_of_tendsto {F : ι → lp E p} (hF : Bornology.IsBounded (Set.range F)) {f : ∀ a, E a}
    (hf : Tendsto (id fun i => F i : ι → ∀ a, E a) l (𝓝 f)) : Memℓp f p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [LipschitzOnWith, lipschitzOnWith_iff_lipschitzOnWith]

For theorem:
theorem LipschitzOnWith.coordinate [PseudoMetricSpace α] (f : α → ℓ^∞(ι)) (s : Set α) (K : ℝ≥0) :
    LipschitzOnWith K f s ↔ ∀ i : ι, LipschitzOnWith K (fun a : α ↦ f a i) s 
Attempt failure.

Working on Mathlib/Analysis/ODE/PicardLindelof.lean - 2024-08-20 14:58:59.901771.
---0/3204---
Verifying proof:
:= by
  rw [dist_eq_norm]
  exact dist_next_apply_le_of_forall_le_of_dist_le h

For theorem:
theorem dist_next_apply_le_of_le {f₁ f₂ : FunSpace v} {n : ℕ} {d : ℝ}
    (h : ∀ t, dist (f₁ t) (f₂ t) ≤ (v.L * |t.1 - v.t₀|) ^ n / n ! * d) (t : Icc v.tMin v.tMax) :
    dist (next f₁ t) (next f₂ t) ≤ (v.L * |t.1 - v.t₀|) ^ (n + 1) / (n + 1)! * d 
Attempt failure.

Working on Mathlib/Analysis/PSeries.lean - 2024-08-20 14:59:04.319454.
---0/3204---
Verifying proof:
:= by
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_schlomilch_iff.2 fun m n hmn =>?_
  refine summable_of_schlomilch_schlomilch_schlomilch_schlomilc

For theorem:
theorem summable_schlomilch_iff {C : ℕ} {u : ℕ → ℕ} {f : ℕ → ℝ≥0}
    (hf : ∀ ⦃m n⦄, 0 < m → m ≤ n → f n ≤ f m)
    (h_pos : ∀ n, 0 < u n) (hu_strict : StrictMono u)
    (hC_nonzero : C ≠ 0) (h_succ_diff : SuccDiffBounded C u) :
    (Summable fun k : ℕ => (u (k + 1) - (u k : ℝ≥0)) * f (u k)) ↔ Summable f 
Attempt failure.

Working on Mathlib/Analysis/Seminorm.lean - 2024-08-20 14:59:10.175362.
---0/3204---
Verifying proof:
:=
  ⟨0, by
    rintro _ ⟨x, rfl⟩
    exact add_nonneg (map_nonneg _ _) (map_nonneg _ _)⟩

For theorem:
theorem bddBelow_range_add : BddBelow (range fun u => p u + q (x - u)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine (p.absorbent_closedBall_zero <| sub_pos.2 hpr).subset fun y hy =>?_
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  rw [p.mem_closedBall_zero] at hy
  exact hy

For theorem:
theorem absorbent_closedBall (hpr : p x < r) : Absorbent 𝕜 (closedBall p x r) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  convert (p.convexOn.translate_left (-x)).convex_lt r
  ext y
  rw [preimage_univ, sep_univ, p.mem_ball, sub_eq_add_neg]
  rfl

For theorem:
theorem convex_ball : Convex ℝ (ball p x r) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  induction' H using Finset.Nonempty.cons_induction with i s hi ih generalizing r
  · simp only [Finset.sup'_apply, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty,
      Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, Finset.sup_empty, ih]

For theorem:
theorem ball_finset_sup' (p : ι → Seminorm 𝕜 E) (s : Finset ι) (H : s.Nonempty) (e : E) (r : ℝ) :
    ball (s.sup' H p) e r = s.inf' H fun i => ball (p i) e r 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rintro a ha x ⟨y, hy, hx⟩
  rw [mem_ball_zero, ← hx, map_smul_eq_mul]
  calc
    _ ≤ p y := mul_le_of_le_of_le_one_left (map_smul_eq_mul_of_nonneg (by positivity) hy)
    _ ≤ p y := mul_le_of_le_of_le_one_left (map_smul_eq_mul_of_nonneg (by positivity) hx)
    _ ≤ p y := mul_le_of_le_of_le_one_left (map_smul_eq_mul_of_nonneg (by positivity) hy)
    _ ≤ p y := mul_le_of_le_of_le_one_left (map_smul_eq_mul_of_nonneg (by positivity) hx)
    _ ≤ p y := mul_le_of_le_of_le_one_left (map_smul_eq_mul_of_nonneg (by positivity) hy)
    _ ≤ p y := mul_le_of_le_of_le_one_left (map_smul_eq_mul_of_nonneg (by positivity) hx)
    _ ≤ p y := mul_le_of_le_of_le_one_left (map_smul_eq_mul_of_nonneg hy (by positivity))
    _ ≤ p y := mul_le_of_le_of_le_one_left (map_smul_eq_mul_of_nonneg hy (by positivity))
    _ ≤ p y := mul_le_of_le_one_left (map_smul_eq_mul_of_nonneg hy (by positivity))
    _ ≤ p y := mul_le_of_le_one_left (map_smul_eq_mul_of_nonneg hy (by positivity))
    _ ≤ p y := mul_le_

For theorem:
theorem balanced_ball_zero (r : ℝ) : Balanced 𝕜 (ball p 0 r) 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/CompareExp.lean - 2024-08-20 15:01:45.411790.
---0/3204---
Verifying proof:
:=
  calc
    (fun z => Real.log (abs z)) =O[l] fun z =>
        Real.log (Real.sqrt 2) + Real.log (max z.re) + Real.log (max z.re) + Real.log (max z.re) := by
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               

For theorem:
theorem isLittleO_log_abs_re (hl : IsExpCmpFilter l) : (fun z => Real.log (abs z)) =o[l] re 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Complex/Arctan.lean - 2024-08-20 15:01:50.973759.
---0/3204---
Verifying proof:
:= by
  have h := cos_ne_zero_of_arctan_bounds h₀ h₁ h₂
  unfold arctan
  simp only [tan_eq_sin_div_cos, cos_ne_zero_of_arctan_bounds h₀ h₁ h₂]

For theorem:
theorem arctan_tan {z : ℂ} (h₀ : z ≠ π / 2) (h₁ : -(π / 2) < z.re) (h₂ : z.re ≤ π / 2) :
    arctan (tan z) = z 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean - 2024-08-20 15:01:59.823741.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_,?_⟩
  · rw [← abs_mul_cos_add_sin_mul_I z, h]
    simp [abs.nonneg]

For theorem:
theorem arg_eq_zero_iff {z : ℂ} : arg z = 0 ↔ 0 ≤ z.re ∧ z.im = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by solve_by_elim [arg_eq_nhds_of_re_neg_of_im_pos hx_re hx_im]

For theorem:
theorem arg_eq_nhds_of_re_neg_of_im_pos (hx_re : x.re < 0) (hx_im : 0 < x.im) :
    arg =ᶠ[𝓝 x] fun x => Real.arcsin ((-x).im / abs x) + π 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [arg_eq_zero_iff, eq_comm]; rfl

For theorem:
lemma arg_eq_zero_iff_zero_le {z : ℂ} : arg z = 0 ↔ 0 ≤ z 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [arg, map_mul, abs_cos_add_sin_mul_I, add_zero]

For theorem:
theorem arg_mul_cos_add_sin_mul_I {r : ℝ} (hr : 0 < r) {θ : ℝ} (hθ : θ ∈ Set.Ioc (-π) π) :
    arg (r * (cos θ + sin θ * I)) = θ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  suffices h_forall_nhds : ∀ᶠ y : ℂ in 𝓝 x, Real.arcsin ((-x).im / abs x) - π by
    simpa only [Real.arcsin_of_re_neg_of_im_neg hx_re hx_im] using h_forall_nhds
  refine eventuallyEq_of_mem self_mem_nhdsWithin fun y hy =>?_
  refine eventuallyEq_of_mem self_mem_nhdsWithin fun y hy =>?_
  refine eventuallyEq_of_mem self_mem_nhdsWithin fun y hy =>?_
  refine eventuallyEq_of_mem self_mem_nhdsWithin fun y hy =>?_
  refine eventuallyEq_of_mem self_mem_nhdsWithin fun y hy =>?_
  refine eventuallyEq_of_mem self_mem_nhdsWithin fun y hy =>?_
  refine eventuallyEq_of_mem self_mem_nhdsWithin fun y hy =>?_
  refine eventuallyEq_of_mem self_mem_nhdsWithin fun y hy =>?_
  refine eventuallyEq_of_mem self_mem_nhdsWithin fun y hy =>?_
  refine eventuallyEq_of_mem self_mem_nhdsWithin fun y hy =>?_
  refine eventuallyEq_of_mem self_mem_nhdsWithin fun y hy =>?_
  refine eventuallyEq_of_mem self_mem_nhdsWithin fun y hy =>?_
  refine eventuallyEq_of_mem self_mem_nhdsWithin fun y hy =>?_
  refine even

For theorem:
theorem arg_eq_nhds_of_re_neg_of_im_neg (hx_re : x.re < 0) (hx_im : x.im < 0) :
    arg =ᶠ[𝓝 x] fun x => Real.arcsin ((-x).im / abs x) - π 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Complex/Log.lean - 2024-08-20 15:02:50.330302.
---0/3204---
Verifying proof:
:= by
  convert
    (continuous_ofReal.continuousWithinAt (continuous_ofReal.continuousAt.comp continuousWithinAt_const)
      (continuousWithinAt_log_of_re_neg_of_im_zero hre him) using 1
  · exact continuousWithinAt_const.congr_of_eventuallyEq him

For theorem:
theorem continuousWithinAt_log_of_re_neg_of_im_zero {z : ℂ} (hre : z.re < 0) (him : z.im = 0) :
    ContinuousWithinAt log { z : ℂ | 0 ≤ z.im } z 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Complex/LogBounds.lean - 2024-08-20 15:02:54.442652.
---0/3204---
Verifying proof:
:= by
  have help : IntervalIntegrable (z : ℂ) (z : ℂ) := by
    have help : IntervalIntegrable (z : ℂ) (z : ℂ) (z : ℂ) := by
      rw [norm_sub_rev, norm_sub_rev, norm_sub_rev, norm_sub_rev, norm_sub_rev, norm_sub_rev,
      

For theorem:
lemma norm_log_sub_logTaylor_le (n : ℕ) {z : ℂ} (hz : ‖z‖ < 1) :
    ‖log (1 + z) - logTaylor (n + 1) z‖ ≤ ‖z‖ ^ (n + 1) * (1 - ‖z‖)⁻¹ / (n + 1) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  convert ((hasDerivAt_log (1 + z) - logTaylor (n + 1) z) ((-z) ^ n * (1 + z)⁻¹)).sub
    ((hasDerivAt_log (1 + z) - logTaylor (n + 1) z) ((-z) ^ n * (1 + z)⁻¹) z) using 1
  · simp only [logTaylor_succ, logTaylor_zero, sub_zero]
  · simp only [logTaylor_zero, zero_add]
    refine (hasDerivAt_log_sub_logTaylor_sub_logTaylor_zero n hz).congr_of_eventuallyEq?_
    refine (hasDerivAt_log_sub_logTaylor?_ hz).sub (hasDerivAt_log_sub_logTaylor?_ hz)
  · simp only [hasDerivAt_iff_tendsto_slitPlane_of_mem_slitPlane hz]
    exact (hasDerivAt_log_sub_logTaylor n hz).sub (hasDerivAt_log_sub_logTaylor n hz)
  · exact (hasDerivAt_log_sub_logTaylor n hz).sub (hasDerivAt_log_sub_logTaylor n hz)
  · exact (hasDerivAt_log_sub_logTaylor n hz).sub (hasDerivAt_log_sub_logTaylor n hz)
  · exact (hasDerivAt_log_sub_logTaylor n hz).sub (hasDerivAt_log_sub_logTaylor n hz)
  · exact (hasDerivAt_log_sub_logTaylor n hz).sub (hasDerivAt_log_sub_logTaylor n hz)
  · exact (hasDerivAt_log_sub_logTaylor n hz).sub (has

For theorem:
lemma hasDerivAt_log_sub_logTaylor (n : ℕ) {z : ℂ} (hz : 1 + z ∈ slitPlane) :
    HasDerivAt (fun z : ℂ ↦ log (1 + z) - logTaylor (n + 1) z) ((-z) ^ n * (1 + z)⁻¹) z 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean - 2024-08-20 15:03:10.269850.
---0/3204---
Verifying proof:
:= by
  rw [GammaIntegral_eq_mellin]

For theorem:
theorem hasDerivAt_GammaIntegral {s : ℂ} (hs : 0 < s.re) :
    HasDerivAt GammaIntegral (∫ t : ℝ in Ioi 0, t ^ (s - 1) * (Real.log t * Real.exp (-t))) s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← Ioc_union_Ioi_eq_Ioi (@zero_le_one ℝ _ _ _), integrableOn_Ioi_iff_integrableOn_Ioi]
  refine IntegrableOn.mul?_ (integrableOn_Ioi_iff_integrableOn_Ioo_subset.2 fun x hx =>?_)
  rw [← IntegrableOn, ← integrableOn_Ioi_iff_integrableOn_Ioo]
  refine integrableOn_Ioo_of_le (fun x hx =>?_) (fun x hx =>?_) (fun x hx =>?_)?_
  · simp only [integrableOn_Ioc_iff_integrableOn_Ioo, integrableOn_Ioi_iff_integrableOn_Ioo,
    integrableOn_Ioo_iff_integrableOn_Ioo]
    refine IntegrableOn.mono fun x hx =>?_
    simp only [integrableOn_Ioi_iff_integrableOn_Ioo, integrableOn_Ioi_iff_integrableOn_Ioo,
    integrableOn_Ioi_iff_integrableOn_Ioo, integrableOn_Ioi_iff_integrableOn_Ioo]
    refine integrableOn_Ioo_of_le (fun x hx =>?_) (integrableOn_Ioi_iff_integrableOn_Ioo.2 fun x hx =>?_)
  · simp only [integrableOn_Ioi_iff_integrableOn_Ioo, integrableOn_Ioi_iff_integrableOn_Ioo,
      integrableOn_Ioo_iff_integrableOn_Ioo, integrableOn_Ioi_iff_integrableOn_Ioo, integrableOn_Ioi_iff_integrableOn

For theorem:
theorem GammaIntegral_convergent {s : ℝ} (h : 0 < s) :
    IntegrableOn (fun x : ℝ => exp (-x) * x ^ (s - 1)) (Ioi 0) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [show 𝓝 (1 : ℂ) = 𝓝 (Gamma (0 + 1)) by simp only [zero_add, Complex.Gamma_one]

For theorem:
theorem tendsto_self_mul_Gamma_nhds_zero : Tendsto (fun z : ℂ => z * Gamma z) (𝓝[≠] 0) (𝓝 1) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [show 𝓝 (1 : ℂ) = 𝓝 (Gamma (0 + 1)) by simp only [zero_add, Complex.Gamma_one]

For theorem:
theorem tendsto_self_mul_Gamma_nhds_zero : Tendsto (fun z : ℂ => z * Gamma z) (𝓝[≠] 0) (𝓝 1) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  suffices ∀ {n : ℕ}, -(n : ℝ) < s → Gamma s ≠ 0 by
    apply this
    apply this
    swap; exact ⌊-s⌋₊ + 1
    rw [Nat.cast_add, Nat.cast_one, Nat.cast_add, Nat.cast_add, Nat.cast_one, add_assoc,
      Nat.cast_add, Nat.cast_add, Nat.cast_add, Nat.cast_one]

For theorem:
theorem Gamma_ne_zero {s : ℝ} (hs : ∀ m : ℕ, s ≠ -m) : Gamma s ≠ 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine isLittleO_of_tendsto (fun x hx =>?_)?_
  · exfalso; exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exfalso; exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact isLittleO_of_tendsto (fun x hx =>?_)?_
  · exact is

For theorem:
theorem Gamma_integrand_isLittleO (s : ℝ) :
    (fun x : ℝ => exp (-x) * x ^ s) =o[atTop] fun x : ℝ => exp (-(1 / 2) * x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [show 𝓝 (1 : ℂ) = 𝓝 (Gamma (0 + 1)) by simp only [zero_add, Complex.Gamma_one]

For theorem:
theorem tendsto_self_mul_Gamma_nhds_zero : Tendsto (fun z : ℂ => z * Gamma z) (𝓝[≠] 0) (𝓝 1) 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean - 2024-08-20 15:04:20.846433.
---0/3204---
Verifying proof:
:= by
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution

For theorem:
theorem Gamma_mul_Gamma_eq_betaIntegral {s t : ℂ} (hs : 0 < re s) (ht : 0 < re t) :
    Gamma s * Gamma t = Gamma (s + t) * betaIntegral s t := by
      have conv_int := integral_posConvolution
    (GammaIntegral_convergent hs) (GammaIntegral_convergent ht) (ContinuousLinearMap.mul ℝ ℂ)
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominate

For theorem:
theorem approx_Gamma_integral_tendsto_Gamma_integral {s : ℂ} (hs : 0 < re s) :
    Tendsto (fun n : ℕ => ∫ x : ℝ in (0)..n, ((1 - x / n) ^ n : ℝ) * (x : ℂ) ^ (s - 1)) atTop
      (𝓝 <| Gamma s) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Gamma_ne_zero fun m =>?_
  contrapose! hs
  simpa only [hs, neg_re, ← ofReal_natCast, ofReal_re, ofReal_re, neg_neg] using hs

For theorem:
theorem Gamma_ne_zero_of_re_pos {s : ℂ} (hs : 0 < re s) : Gamma s ≠ 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominated_convergence (Gamma_pos_of_pos hs) (Gamma_pos_of_pos hs)?_
  refine tendsto_integral_of_dominate

For theorem:
theorem approx_Gamma_integral_tendsto_Gamma_integral {s : ℂ} (hs : 0 < re s) :
    Tendsto (fun n : ℕ => ∫ x : ℝ in (0)..n, ((1 - x / n) ^ n : ℝ) * (x : ℂ) ^ (s - 1)) atTop
      (𝓝 <| Gamma s) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have pi_ne : (π : ℂ) ≠ 0 := Complex.ofReal_ne_zero.mpr pi_ne_zero

For theorem:
theorem Gamma_mul_Gamma_one_sub (z : ℂ) : Gamma z * Gamma (1 - z) = π / sin (π * z) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases h_im : s.im = 0
  · have : s = ↑s.re := by
    conv_lhs => rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]

For theorem:
theorem Gamma_ne_zero {s : ℂ} (hs : ∀ m : ℕ, s ≠ -m) : Gamma s ≠ 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution

For theorem:
theorem Gamma_mul_Gamma_eq_betaIntegral {s t : ℂ} (hs : 0 < re s) (ht : 0 < re t) :
    Gamma s * Gamma t = Gamma (s + t) * betaIntegral s t := by
      have conv_int := integral_posConvolution
    (GammaIntegral_convergent hs) (GammaIntegral_convergent ht) (ContinuousLinearMap.mul ℝ ℂ)
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases h_im : s.im = 0
  · have : s = ↑s.re := by
    conv_lhs => rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]
    rw [h_im : s.im = 0
    rw [← Complex.re_add_im s]

For theorem:
theorem Gamma_ne_zero {s : ℂ} (hs : ∀ m : ℕ, s ≠ -m) : Gamma s ≠ 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution
  have conv_int := integral_posConvolution

For theorem:
theorem Gamma_mul_Gamma_eq_betaIntegral {s t : ℂ} (hs : 0 < re s) (ht : 0 < re t) :
    Gamma s * Gamma t = Gamma (s + t) * betaIntegral s t := by
      have conv_int := integral_posConvolution
    (GammaIntegral_convergent hs) (GammaIntegral_convergent ht) (ContinuousLinearMap.mul ℝ ℂ)
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Gamma_ne_zero fun m =>?_
  contrapose! hs
  simpa only [hs, neg_re, ← ofReal_natCast, ofReal_re, neg_nonpos] using hs

For theorem:
theorem Gamma_ne_zero_of_re_pos {s : ℂ} (hs : 0 < re s) : Gamma s ≠ 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine intervalIntegral.intervalIntegrable_iff.2 fun x hx =>?_
  simp only [intervalIntegral.intervalIntegrable_iff, intervalIntegral.intervalIntegrable_iff,
    intervalIntegral.intervalIntegrable_iff, intervalIntegral.intervalIntegral.intervalIntegrable_iff,
    intervalIntegral.intervalIntegrable_iff, intervalIntegral.intervalIntegral.intervalIntegrable_iff,
    intervalIntegral.intervalIntegrable_iff, intervalIntegral.intervalIntegral.intervalIntegrable_iff]

For theorem:
theorem betaIntegral_convergent_left {u : ℂ} (hu : 0 < re u) (v : ℂ) :
    IntervalIntegrable (fun x =>
      (x : ℂ) ^ (u - 1) * (1 - (x : ℂ)) ^ (v - 1) : ℝ → ℂ) volume 0 (1 / 2) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have pi_ne : (π : ℂ) ≠ 0 := Complex.ofReal_ne_zero.mpr pi_ne_zero

For theorem:
theorem Gamma_mul_Gamma_one_sub (z : ℂ) : Gamma z * Gamma (1 - z) = π / sin (π * z) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let F : ℝ → ℂ := fun a b => betaIntegral u (v + 1)
  have hF' : 0 < F a := by simpa only [add_re, one_re] using hF'.symm
  have hF' : 0 < F' := by simpa only [add_re, one_re] using hF'.symm
  have hF' : 0 < F' := by simpa only [one_re] using hF'.symm
  have hF' : 0 < F' := by simpa only [one_re] using hF'.symm
  have hF' : 0 < F' := by simpa only [one_re] using hF'.symm
  have hF' : 0 < F' := by simpa only [one_re] using hF'.symm
  have hF' : 0 < F' := by simpa only [one_re] using hF'.symm
  have hF' : 0 < F' := by simpa only [one_re] using hF'.symm
  have hF' : 0 < F' := by simpa only [one_re] using hF'.symm
  have hF' : 0 < F' := by simpa only [one_re] using hF'.symm
  have hF' : 0 < F' := by simpa only [one_re] using hF'.symm
  have hF' : 0 < F' := by simpa only [one_re] using hF'.symm
  have hF' : 0 < F' := by simpa only [one_re] using hF'.symm
  have hF' : 0 < F' := by simpa only [one_re] using hF'.symm
  have hF' : 0 < F' := by simpa only [one_re] using hF'.symm
  have hF' : 0 < F' := by 

For theorem:
theorem betaIntegral_recurrence {u v : ℂ} (hu : 0 < re u) (hv : 0 < re v) :
    u * betaIntegral u (v + 1) = v * betaIntegral (u + 1) v := by
        let F : ℝ → ℂ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : ∀ j ∈ Finset.range n, (↑1 - z ^ 2 / ((j : ℂ) + 1) ^ 2) =
      ∏ j ∈ Finset.range n, (↑1 - z ^ 2 / ((j : ℂ) + 1) ^ 2) := by
    intro j hj
    rw [Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ,
      Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ,
      Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ,
      Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ,
      Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ,
      Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ,
      Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ,
      Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ, Finset.prod_range_succ,
      Finset.prod_range_succ, Finse

For theorem:
theorem GammaSeq_mul (z : ℂ) {n : ℕ} (hn : n ≠ 0) :
    GammaSeq z n * GammaSeq (1 - z) n =
      n / (n + ↑1 - z) * (↑1 / (z * ∏ j ∈ Finset.range n, (↑1 - z ^ 2 / ((j : ℂ) + 1) ^ 2))) := by
    have aux : ∀ a b c d : ℂ, a * b * (c * d) = a * c * (b * d) 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean - 2024-08-20 15:06:07.002463.
---0/3204---
Verifying proof:
:= by
  refine convexOn_iff_forall_pos.mpr ⟨convex_Ioi _, fun x hx y hy a b ha hb hab =>?_⟩
  have : b = 1 - a := by linarith
  have : b = 1 - a := by linarith

For theorem:
theorem convexOn_log_Gamma : ConvexOn ℝ (Ioi 0) (log ∘ Gamma) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma hs ht ha hb hab?_
  rw [Gamma_mul_add_mul_rpow_Gamma_mul_rpow_Gamma ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma ha hb hab, Gamma_mul_add_mul_rpow_

For theorem:
theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : ℝ} (hs : 0 < s) (ht : 0 < t)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    Gamma (a * s + b * t) ≤ Gamma s ^ a * Gamma t ^ b := by
      let f : ℝ → ℝ → ℝ → ℝ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eq_or_lt_of_le hx' with (rfl | hx'')
  · simp only [hf_feq hn, hx', add_zero]
    exact hf_feq hn hx'
  · rw [add_mul, one_mul]
    exact hf_feq hn hx'

For theorem:
theorem f_add_nat_le (hf_conv : ConvexOn ℝ (Ioi 0) f)
    (hf_feq : ∀ {y : ℝ}, 0 < y → f (y + 1) = f y + log y) (hn : n ≠ 0) (hx : 0 < x) (hx' : x ≤ 1) :
    f (n + x) ≤ f n + x * log n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine tendsto_logGammaSeq_of_tendsto_atTop (fun y hy =>?_) hf_conv hf_feq hx hy hx?_
  refine tendsto_logGammaSeq_of_logGammaSeq hf_conv hf_feq hx hy (fun y hy =>?_) hx hy
  · refine tendsto_const_nhds.congr fun y hy =>?_
    rw [tendsto_iff_norm_sub_tendsto_zero]
    exact tendsto_const_nhds.sub (tendsto_const_nhds.sub (tendsto_const_nhds.sub?_))
  · exact tendsto_const_nhds.sub (tendsto_const_nhds.sub (tendsto_const_nhds.sub?_))
  · exact tendsto_const_nhds.sub (tendsto_const_nhds.sub (tendsto_const_nhds.sub?_))
  · exact tendsto_const_nhds.sub (tendsto_const_nhds.sub tendsto_const_nhds)

For theorem:
theorem tendsto_logGammaSeq (hf_conv : ConvexOn ℝ (Ioi 0) f)
    (hf_feq : ∀ {y : ℝ}, 0 < y → f (y + 1) = f y + log y) (hx : 0 < x) :
    Tendsto (logGammaSeq x) atTop (𝓝 <| f x - f 1) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine eq_Gamma_of_log_convex (fun y hy =>?_) hf_conv hf_feq hf_pos hf_one hf_pos hf_pos hf_one hf_pos hf_pos hf_pos hf_one

For theorem:
theorem eq_Gamma_of_log_convex {f : ℝ → ℝ} (hf_conv : ConvexOn ℝ (Ioi 0) (log ∘ f))
    (hf_feq : ∀ {y : ℝ}, 0 < y → f (y + 1) = y * f y) (hf_pos : ∀ {y : ℝ}, 0 < y → 0 < f y)
    (hf_one : f 1 = 1) : EqOn f Gamma (Ioi (0 : ℝ)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine tendsto_logGammaSeq_of_le_one hf_conv hf_feq hx hx'?_
  rw [tendsto_add_atTop_iff_nat]
  refine tendsto_logGammaSeq_of_le_one (fun y hy =>?_) (fun y hy =>?_) (fun y hy =>?_) hx
  · rw [tendsto_add_atTop_iff_nat]
    refine tendsto_logGammaSeq_of_le_one (fun y hy =>?_) (fun y hy =>?_) (fun y hy =>?_) hx
  · exact tendsto_logGammaSeq_of_le_one (fun y hy =>?_) (fun y hy =>?_) (fun y hy =>?_) hx'
  · exact tendsto_logGammaSeq_of_le_one (fun y hy =>?_) (fun y hy =>?_) hx
  · exact tendsto_logGammaSeq_of_le_one (fun y hy =>?_) (fun y hy =>?_) (fun y hy =>?_) hx
  · exact tendsto_logGammaSeq_of_le_one (fun y hy =>?_) (fun y hy =>?_) (fun y hy =>?_)
  · exact tendsto_logGammaSeq_of_le_one (fun y hy =>?_) hx
  · exact tendsto_logGammaSeq_of_le_one (fun y hy =>?_) hx
  · exact tendsto_logGammaSeq_of_le_one (fun y hy =>?_) hx
  · exact tendsto_logGammaSeq_of_le_one (fun y hy =>?_) hx
  · exact tendsto_logGammaSeq_of_le_one (fun y hy =>?_) hx
  · exact tendsto_logGammaSeq

For theorem:
theorem tendsto_logGammaSeq_of_le_one (hf_conv : ConvexOn ℝ (Ioi 0) f)
    (hf_feq : ∀ {y : ℝ}, 0 < y → f (y + 1) = f y + log y) (hx : 0 < x) (hx' : x ≤ 1) :
    Tendsto (logGammaSeq x) atTop (𝓝 <| f x - f 1) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hx' : 0 < x := lt_of_lt_of_le zero_lt_two hx
  have hx'' : 0 < x := lt_of_lt_of_le zero_lt_two hx
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  have hx'' : 0 < x := by linarith
  

For theorem:
theorem f_add_nat_ge (hf_conv : ConvexOn ℝ (Ioi 0) f)
    (hf_feq : ∀ {y : ℝ}, 0 < y → f (y + 1) = f y + log y) (hn : 2 ≤ n) (hx : 0 < x) :
    f n + x * log (n - 1) ≤ f (n + x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma hs ht ha hb hab?_
  rw [Gamma_mul_add_mul_rpow_Gamma_mul_rpow_Gamma ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma ha hb hab, Gamma_mul_add_mul_rpow_

For theorem:
theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : ℝ} (hs : 0 < s) (ht : 0 < t)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    Gamma (a * s + b * t) ≤ Gamma s ^ a * Gamma t ^ b := by
      let f : ℝ → ℝ → ℝ → ℝ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma hs ht ha hb hab?_
  rw [Gamma_mul_add_mul_rpow_Gamma_mul_rpow_Gamma ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma hs ht ha hb hab, Gamma_mul_add_mul_rpow_Gamma ht ha hb hab,
    Gamma_mul_add_mul_le_rpow_Gamma ha hb hab, Gamma_mul_add_mul_rpow_

For theorem:
theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : ℝ} (hs : 0 < s) (ht : 0 < t)
    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :
    Gamma (a * s + b * t) ≤ Gamma s ^ a * Gamma t ^ b := by
      let f : ℝ → ℝ → ℝ → ℝ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine
    ((convexOn_exp.subset (subset_univ _) _).comp convexOn_log_Gamma
      (exp_monotone.monotoneOn _).congr
      fun x hx =>?_
    simp only [convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope,
      convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope,
      convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope,
      convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope,
      convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope,
      convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope,
      convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope,
      convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope,
      convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slope,
      convexOn_iff_tendsto_slope, convexOn_iff_tendsto_slop

For theorem:
theorem convexOn_Gamma : ConvexOn ℝ (Ioi 0) Gamma 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean - 2024-08-20 15:07:26.892040.
---0/3204---
Verifying proof:
:= by
  have h1 : Gammaℝ (1 - s) ≠ 0 := by
    rw [Gammaℝ_one_sub, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def,
      Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def,
      Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def,
      Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def,
      Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def,
      Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def,
      Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def,
      Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def,
      Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def,
      Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def,
      Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ_def, Gammaℝ

For theorem:
lemma inv_Gammaℝ_one_sub {s : ℂ} (hs : ∀ (n : ℕ), s ≠ -n) :
    (Gammaℝ (1 - s))⁻¹ = Gammaℂ s * cos (π * s / 2) * (Gammaℝ s)⁻¹ 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gaussian/FourierTransform.lean - 2024-08-20 15:07:35.817595.
---0/3204---
Verifying proof:
:= by
  rw [norm_cexp_neg_mul_sq_add_mul_I' hb, norm_exp_neg_mul_I' hb]

For theorem:
theorem norm_cexp_neg_mul_sq_add_mul_I' (hb : b.re ≠ 0) (c T : ℝ) :
    ‖cexp (-b * (T + c * I) ^ 2)‖ =
      exp (-(b.re * (T - b.im * c / b.re) ^ 2 - c ^ 2 * (b.im ^ 2 / b.re + b.re))) 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean - 2024-08-20 15:07:49.122489.
---0/3204---
Verifying proof:
:= by
  have nv : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have nv : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have : ∀ {b : ℂ}, 0 < re b → b ≠ 0 := by intro b
  have :

For theorem:
theorem integral_gaussian_complex {b : ℂ} (hb : 0 < re b) :
    ∫ x : ℝ, cexp (-b * (x : ℂ) ^ 2) = (π / b) ^ (1 / 2 : ℂ) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨(continuous_ofReal.mul (Complex.continuous_ofReal.mul (Complex.continuous_exp.comp?_)).continuousAt,?_⟩
  refine ⟨(continuous_ofReal.mul (Complex.continuous_exp.comp?_)).continuousAt,?_⟩
  refine ⟨(continuous_ofReal.mul (Complex.continuous_exp.comp?_)).continuousAt,?_⟩
  refine ⟨(continuous_ofReal.mul (Complex.continuous_exp.comp?_)).continuousAt,?_⟩
  refine ⟨(continuous_ofReal.mul (Complex.continuous_exp.comp?_)).continuousAt,?_⟩
  refine ⟨(continuous_ofReal.mul (Complex.continuous_ofReal.comp?_)).continuousAt,?_⟩
  refine ⟨(continuous_ofReal.mul (Complex.continuous_ofReal.comp?_)).continuousAt,?_⟩
  refine ⟨(continuous_ofReal.mul (Complex.continuous_ofReal.comp?_)).continuousAt,?_⟩
  refine ⟨(continuous_ofReal.mul (Complex.continuous_ofReal.comp?_)).continuousAt,?_⟩
  refine ⟨(continuous_ofReal.mul (Complex.continuous_ofReal.comp?_)).continuousAt,?_⟩
  refine ⟨(continuous_ofReal.mul?_).continuousAt,?_⟩
  refine ⟨(continuou

For theorem:
theorem integrable_mul_cexp_neg_mul_sq {b : ℂ} (hb : 0 < b.re) :
    Integrable fun x : ℝ => ↑x * cexp (-b * (x : ℂ) ^ 2) 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean - 2024-08-20 15:08:05.446761.
---0/3204---
Verifying proof:
:= by
  rw [IntegrableOn, ← integrable_norm_iff, ← IntegrableOn, ← integrableOn_Ioi_cpow_iff ha]
  refine integrableOn_Ioi_cpow_of_lt?_ ha hc
  refine integrableOn_Ioi_cpow_of_lt?_ (by positivity) (by positivity) (by positivity)
  refine integrableOn_Ioi_cpow_of_lt?_ (by positivity) (by positivity)
  refine integrableOn_Ioi_cpow_of_lt?_ (by positivity) (by positivity) (by positivity)
    (by positivity)
  refine integrableOn_Ioi_cpow_of_lt?_ (by positivity) (by positivity)
  refine integrableOn_Ioi_cpow_of_lt?_ (by positivity) (by positivity)
  refine integrableOn_Ioi_cpow_of_lt?_ (by positivity) (by positivity)
  refine integrableOn_Ioi_cpow_of_lt?_ (by positivity) (by positivity)
  refine integrableOn_Ioi_cpow_of_lt?_ (by positivity) (by positivity)
  refine integrableOn_Ioi_cpow_of_lt?_ (by positivity) (by positivity)
  refine integrableOn_Ioi_cpow_of_lt?_ (by positivity) (by positivity)
  refine integrableOn_Ioi_cpow_of_lt?_ (by positivity) (by positivity)
  refine integrableOn_Ioi_cpow

For theorem:
theorem integrableOn_Ioi_cpow_of_lt {a : ℂ} (ha : a.re < -1) {c : ℝ} (hc : 0 < c) :
    IntegrableOn (fun t : ℝ => (t : ℂ) ^ a) (Ioi c) 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Integrals.lean - 2024-08-20 15:08:09.482930.
---0/3204---
Verifying proof:
:=
  have hc : Continuous fun u : ℝ => (∫ x in a..b, sin x ^ m * cos x ^ (2 * n + 1)) := by
    refine integral_congr_ae?_
    filter_upwards [eventually_gt_atTop 0] with x hx
    rw [intervalIntegral.integral_of_le (by positivity)]
    ring

For theorem:
theorem integral_sin_pow_mul_cos_pow_odd (m n : ℕ) :
    (∫ x in a..b, sin x ^ m * cos x ^ (2 * n + 1)) = ∫ u in sin a..sin b, u^m * (↑1 - u ^ 2) ^ n 
Attempt failure.

---0/3204---
Verifying proof:
:=
  have hc : Continuous fun u : ℝ => (∫ x in a..b, sin x ^ m * cos x ^ (2 * n + 1)) := by
    refine integral_congr_ae?_
    filter_upwards [eventually_gt_atTop 0] with x hx
    rw [intervalIntegral.integral_of_le (by positivity)]
    ring

For theorem:
theorem integral_sin_pow_mul_cos_pow_odd (m n : ℕ) :
    (∫ x in a..b, sin x ^ m * cos x ^ (2 * n + 1)) = ∫ u in sin a..sin b, u^m * (↑1 - u ^ 2) ^ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [intervalIntegral.integral_of_le (by positivity)]
  simp only [intervalIntegral.integral_of_le (by positivity), intervalIntegral.integral_of_le ht,
    intervalIntegral.integral_of_le (by positivity)]

For theorem:
theorem integral_mul_rpow_one_add_sq {t : ℝ} (ht : t ≠ -1) :
    (∫ x : ℝ in a..b, x * (↑1 + x ^ 2) ^ t) =
      (↑1 + b ^ 2) ^ (t + 1) / (↑2 * (t + ↑1)) - (↑1 + a ^ 2) ^ (t + 1) / (↑2 * (t + ↑1)) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  have hc : Continuous fun u : ℝ => (∫ x in a..b, sin x ^ m * cos x ^ (2 * n + 1)) := by
    refine integral_congr_ae?_
    filter_upwards [eventually_gt_atTop 0] with x hx
    rw [intervalIntegral.integral_of_le (by positivity)]
    ring

For theorem:
theorem integral_sin_pow_mul_cos_pow_odd (m n : ℕ) :
    (∫ x in a..b, sin x ^ m * cos x ^ (2 * n + 1)) = ∫ u in sin a..sin b, u^m * (↑1 - u ^ 2) ^ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [integral_sin_pow_aux]
  ring

For theorem:
theorem integral_sin_pow_aux :
    (∫ x in a..b, sin x ^ (n + 2)) =
      (sin a ^ (n + 1) * cos a - sin b ^ (n + 1) * cos b + (↑n + 1) * ∫ x in a..b, sin x ^ n) -
        (↑n + 1) * ∫ x in a..b, sin x ^ (n + 2) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [intervalIntegral.integral_of_le (by positivity)]
  simp only [intervalIntegral.integral_of_le (by positivity), intervalIntegral.integral_of_le ht,
    intervalIntegral.integral_of_le (by positivity)]

For theorem:
theorem integral_mul_rpow_one_add_sq {t : ℝ} (ht : t ≠ -1) :
    (∫ x : ℝ in a..b, x * (↑1 + x ^ 2) ^ t) =
      (↑1 + b ^ 2) ^ (t + 1) / (↑2 * (t + ↑1)) - (↑1 + a ^ 2) ^ (t + 1) / (↑2 * (t + ↑1)) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  have hc : Continuous fun u : ℝ => ∫ x in a..b, sin x ^ (2 * m + 1) * cos x ^ n := by
    rw [integral_sin_pow_odd_mul_cos_pow]
    exact integral_sin_pow_odd_mul_cos_pow m n

For theorem:
theorem integral_sin_pow_odd_mul_cos_pow (m n : ℕ) :
    (∫ x in a..b, sin x ^ (2 * m + 1) * cos x ^ n) = ∫ u in cos b..cos a, u^n * (↑1 - u ^ 2) ^ m 
Attempt failure.

---0/3204---
Verifying proof:
:=
  calc
  _ = ∫ x in sin (-(π / 2)).. sin (π / 2), √(1 - x ^ 2 : ℝ) := by rw [sin_neg, sin_pi_div_two]
  _ = ∫ x in sin (π / 2), √(1 - x ^ 2 : ℝ) := by rw [sin_neg, sin_pi_div_two]
  _ = ∫ x in sin (π / 2), √(1 - x ^ 2 : ℝ) := by rw [sin_neg, sin_pi_div_two]
  _ = ∫ x in sin (π / 2), √(1 - x ^ 2 : ℝ) := by rw [sin_neg, sin_pi_div_two]
  _ = ∫ x in sin (π / 2), √(1 - x ^ 2 : ℝ) := by rw [sin_neg, sin_pi_div_two]
  _ = ∫ x in sin (π / 2), √(1 - x ^ 2 : ℝ) := by rw [sin_neg, sin_pi_div_two]
  _ = ∫ x in sin (π / 2), √(1 - x ^ 2 : ℝ) := by rw [sin_neg, sin_pi_div_two]
  _ = ∫ x in sin (π / 2), √(1 - x ^ 2 : ℝ) := by rw [sin_neg, sin_pi_div_two]
  _ = ∫ x in sin (π / 2), √(1 - x ^ 2 : ℝ) := by rw [sin_neg, sin_pi_div_two]
  _ = ∫ x in sin (π / 2), √(1 - x ^ 2 : ℝ) := by rw [sin_neg, sin_pi_div_two]
  _ = ∫ x in sin (π / 2), √(1 - x ^ 2 : ℝ) := by rw [sin_neg, sin_pi_div_two]
  _ = ∫ x in sin (π / 2), √(1 - x ^ 2 : ℝ) := by rw [

For theorem:
theorem integral_sqrt_one_sub_sq : ∫ x in (-1 : ℝ)..1, √(1 - x ^ 2 : ℝ) = π / 2 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [integral_sin_pow_even_mul_cos_pow_even, ← integral_sin_pow_even_mul_cos_pow_even]

For theorem:
theorem integral_sin_pow_even_mul_cos_pow_even (m n : ℕ) :
    (∫ x in a..b, sin x ^ (2 * m) * cos x ^ (2 * n)) =
      ∫ x in a..b, ((1 - cos (2 * x)) / 2) ^ m * ((1 + cos (2 * x)) / 2) ^ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← integral_cos_pow, ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm,
    ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm,
    ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm,
    ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm,
    ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm,
    ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm,
    ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm,
    ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm,
    ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm,
    ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm, ← integral_comp_comm,
    ← integral_

For theorem:
theorem integral_cos_pow :
    (∫ x in a..b, cos x ^ (n + 2)) =
      (cos b ^ (n + 1) * sin b - cos a ^ (n + 1) * sin a) / (n + 2) +
        (n + 1) / (n + 2) * ∫ x in a..b, cos x ^ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  suffices ∀ c : ℝ, IntervalIntegrable (fun x => x ^ r) volume 0 c by
    exact (intervalIntegrable_rpow_const _ _ _).const_mul _

For theorem:
theorem intervalIntegrable_rpow' {r : ℝ} (h : -1 < r) :
    IntervalIntegrable (fun x => x ^ r) volume a b 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases h2 : (0 : ℝ) ∉ [[a, b]]
  · simp only [h2, intervalIntegrable_iff_integrableOn_Ioc_of_le h2, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrable_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_int

For theorem:
theorem intervalIntegrable_cpow {r : ℂ} (h : 0 ≤ r.re ∨ (0 : ℝ) ∉ [[a, b]]) :
    IntervalIntegrable (fun x : ℝ => (x : ℂ) ^ r) μ a b 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases h2 : (0 : ℝ) ∉ [[a, b]]
  · simp only [h2, intervalIntegrable_iff_integrableOn_Ioc_of_le h2, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrable_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_integrableOn_Ioc,
    intervalIntegrableOn_Ioc_iff_integrableOn_Ioc, intervalIntegrableOn_Ioc_iff_int

For theorem:
theorem intervalIntegrable_cpow {r : ℂ} (h : 0 ≤ r.re ∨ (0 : ℝ) ∉ [[a, b]]) :
    IntervalIntegrable (fun x : ℝ => (x : ℂ) ^ r) μ a b 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [integral_sin_pow, integral_sin_pow, integral_sin_pow]

For theorem:
theorem integral_sin_pow :
    (∫ x in a..b, sin x ^ (n + 2)) =
      (sin a ^ (n + 1) * cos a - sin b ^ (n + 1) * cos b) / (n + 2) +
        (n + 1) / (n + 2) * ∫ x in a..b, sin x ^ n 
Attempt failure.

---0/3204---
Verifying proof:
:=
  by field_simp [integral_sin_pow, add_sub_comm]

For theorem:
theorem integral_sin_sq : ∫ x in a..b, sin x ^ 2 = (sin a * cos a - sin b * cos b + b - a) / 2 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean - 2024-08-20 15:12:00.444505.
---0/3204---
Verifying proof:
:= by
  have hr : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' :

For theorem:
theorem finite_integral_one_add_norm {r : ℝ} (hnr : (finrank ℝ E : ℝ) < r) :
    (∫⁻ x : E, ENNReal.ofReal ((1 + ‖x‖) ^ (-r)) ∂μ) < ∞ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hr : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' : 0 < r := lt_of_le_of_lt (finrank ℝ E)
  have hr' :

For theorem:
theorem finite_integral_one_add_norm {r : ℝ} (hnr : (finrank ℝ E : ℝ) < r) :
    (∫⁻ x : E, ENNReal.ofReal ((1 + ‖x‖) ^ (-r)) ∂μ) < ∞ 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Log/Basic.lean - 2024-08-20 15:12:22.084479.
---0/3204---
Verifying proof:
:= by
  have : 0 < 1 / x := by simpa only [one_div, inv_pos] using h1
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_pos this
  replace := log_le_sub_one_of_po

For theorem:
theorem abs_log_mul_self_lt (x : ℝ) (h1 : 0 < x) (h2 : x ≤ 1) : |log x * x| < 1 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    rcases lt_trichotomy x 0 with (x_lt_zero | rfl | x_gt_zero)
    · refine Or.inr (Or.inr?_)
    · refine Or.inr (Or.inr?_)
    · refine Or.inr (Or.inr?_)
    · refine Or.inr (Or.inr?_)
    · refine Or.inr (Or.inr?_)
    · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.inr?_)
      · refine Or.inr (Or.i

For theorem:
theorem log_eq_zero {x : ℝ} : log x = 0 ↔ x = 0 ∨ x = 1 ∨ x = -1 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rintro x (hx : x < 0) y (hy : y < 0) hxy
  rw [← log_abs y, ← log_abs x]
  refine log_lt_log (abs_pos.2 hy.ne)?_
  rwa [abs_of_neg hxy]

For theorem:
theorem strictAntiOn_log : StrictAntiOn log (Set.Iio 0) 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Log/Deriv.lean - 2024-08-20 15:12:44.560437.
---0/3204---
Verifying proof:
:= by
  rw [Summable.hasSum_iff_tendsto_nat]

For theorem:
theorem hasSum_pow_div_log_of_abs_lt_one {x : ℝ} (h : |x| < 1) :
    HasSum (fun n : ℕ => x ^ (n + 1) / (n + 1)) (-log (1 - x)) 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/NonIntegrable.lean - 2024-08-20 15:12:53.680510.
---0/3204---
Verifying proof:
:= by
  have : ∀ᶠ x in 𝓝[≠] c, DifferentiableAt ℝ f x := by
    filter_upwards [self_mem_nhdsWithin] with x hx
    simp only [not_intervalIntegrable_iff_integrableOn_Ioc_of_deriv_isBigO_punctured h_deriv,
      intervalIntegrable_iff_integrableOn_Ioc_of_deriv_isBigO_punctured h_infty hx] with x hx
    simp only [intervalIntegrable_iff_integrableOn_Ioc_of_deriv_isBigO_punctured h_infty hx,
      intervalIntegrable_iff_integrableOn_Ioc_of_deriv_isBigO_punctured hx] with x hx
    simp only [intervalIntegrable_iff_integrableOn_Ioc] at hx
    simp only [intervalIntegrable_iff_integrableOn_Ioc] at hx
    simp only [intervalIntegrable_iff_integrableOn_Ioc] at hx
    simp only [intervalIntegrableOn_Ioc_iff_integrableOn_Ioc] at hx
    simp only [intervalIntegrableOn_Ioc_iff_integrableOn_Ioc_of_deriv_isBigO_punctured hx,
        intervalIntegrable_iff_integrableOn_Ioc_of_deriv_isBigO_punctured h_infty hx,
        intervalIntegrable_iff_integrableOn_Ioc_of_deriv_isBigO_punctured h_infty hx,
      intervalInt

For theorem:
theorem not_intervalIntegrable_of_tendsto_norm_atTop_of_deriv_isBigO_punctured {f : ℝ → E}
    {g : ℝ → F} {a b c : ℝ} (h_deriv : ∀ᶠ x in 𝓝[≠] c, DifferentiableAt ℝ f x)
    (h_infty : Tendsto (fun x => ‖f x‖) (𝓝[≠] c) atTop) (hg : deriv f =O[𝓝[≠] c] g) (hne : a ≠ b)
    (hc : c ∈ [[a, b]]) : ¬IntervalIntegrable g volume a b 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine not_intervalIntegrable_of_tendsto_norm_atTop_of_deriv_isBigO_within_diff_singleton?_?_?_
  · simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq] at hc
    simp only [uIcc_of_le, mem_setOf_eq, me

For theorem:
theorem not_intervalIntegrable_of_tendsto_norm_atTop_of_deriv_isBigO_within_diff_singleton
    {f : ℝ → E} {g : ℝ → F} {a b c : ℝ} (hne : a ≠ b) (hc : c ∈ [[a, b]])
    (h_deriv : ∀ᶠ x in 𝓝[[[a, b]] \ {c}] c, DifferentiableAt ℝ f x)
    (h_infty : Tendsto (fun x => ‖f x‖) (𝓝[[[a, b]] \ {c}] c) atTop)
    (hg : deriv f =O[𝓝[[[a, b]] \ {c}] c] g) : ¬IntervalIntegrable g volume a b 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine not_integrableOn_of_tendsto_norm_atTop_of_deriv_isBigO_filter_aux?_?_?_
  · simp only [not_integrableOn_of_tendsto_norm_atTop_of_deriv_isBigO_filter_aux hl, not_false_iff]

For theorem:
theorem not_integrableOn_of_tendsto_norm_atTop_of_deriv_isBigO_filter_aux
    [CompleteSpace E] {f : ℝ → E} {g : ℝ → F}
    {k : Set ℝ} (l : Filter ℝ) [NeBot l] [TendstoIxxClass Icc l l]
    (hl : k ∈ l) (hd : ∀ᶠ x in l, DifferentiableAt ℝ f x) (hf : Tendsto (fun x => ‖f x‖) l atTop)
    (hfg : deriv f =O[l] g) : ¬IntegrableOn g k 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine not_intervalIntegrable_of_tendsto_norm_atTop_of_deriv_isBigO_within_diff_singleton?_?_?_
  · simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq, mem_uIcc] at hc
    simp only [uIcc_of_le, mem_setOf_eq] at hc
    simp only [uIcc_of_le, mem_setOf_eq, me

For theorem:
theorem not_intervalIntegrable_of_tendsto_norm_atTop_of_deriv_isBigO_within_diff_singleton
    {f : ℝ → E} {g : ℝ → F} {a b c : ℝ} (hne : a ≠ b) (hc : c ∈ [[a, b]])
    (h_deriv : ∀ᶠ x in 𝓝[[[a, b]] \ {c}] c, DifferentiableAt ℝ f x)
    (h_infty : Tendsto (fun x => ‖f x‖) (𝓝[[[a, b]] \ {c}] c) atTop)
    (hg : deriv f =O[𝓝[[[a, b]] \ {c}] c] g) : ¬IntervalIntegrable g volume a b 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/PolarCoord.lean - 2024-08-20 15:13:10.468896.
---0/3204---
Verifying proof:
:= by
  refine integral_congr_ae?_
  rw [integral_smul, integral_smul, integral_smul, integral_smul, integral_smul, ← integral_smul,
    ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
    ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
    ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
    ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
    ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
    ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
    ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
    ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul,
    ← integral_smul, ← integral_smul, ← integral_smul, ← integral_smul, ← integral_sm

For theorem:
theorem integral_comp_polarCoord_symm {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    (f : ℝ × ℝ → E) :
    (∫ p in polarCoord.target, p.1 • f (polarCoord.symm p)) = ∫ p, f p 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean - 2024-08-20 15:13:16.835344.
---0/3204---
Verifying proof:
:= by
  apply isLittleO_of_tendsto'
  · refine ((isLittleO_of_tendsto').const_mul _).congr fun x hx =>?_
    refine (isLittleO_exp_neg_mul_rpow_mul_of_pos hx).congr fun x hx =>?_
    refine (isLittleO_exp_neg_rpow_mul_of_pos hx).congr fun x hx =>?_
    refine (isLittleO_exp_neg_mul_of_pos hx).congr fun x hx =>?_
    refine (isLittleO_exp_neg_rpow_mul_of_pos hx).congr fun x hx =>?_
    refine (isLittleO_exp_neg_mul_of_pos hx).congr fun x hx =>?_
    refine (isLittleO_exp_neg_rpow_mul_of_pos hx).congr fun x hx =>?_
    refine (isLittleO_exp_neg_mul_of_pos hx).congr fun x hx =>?_
    refine (isLittleO_exp_neg_rpow_mul_of_pos hx).congr fun x hx =>?_
    refine (isLittleO_exp_neg_mul_of_pos hx).congr fun x hx =>?_
    refine (isLittleO_exp_neg_mul_of_pos hx).congr fun x hx =>?_
    refine (isLittleO_exp_neg_mul_of_pos hx).congr fun x hx =>?_
    refine (isLittleO_exp_neg_rpow_mul_of_pos hx).congr fun x hx =>?_
    refine (isLittleO_exp_neg_mul_of_pos hx).congr fun x hx =>?_
    refine (isLittleO_ex

For theorem:
theorem isLittleO_exp_neg_mul_rpow_atTop {a : ℝ} (ha : 0 < a) (b : ℝ) :
    IsLittleO atTop (fun x : ℝ => exp (-a * x)) fun x : ℝ => x ^ b 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hl with ⟨b, hb⟩
  rcases hl with ⟨b, hb⟩
  rcases hl with ⟨b, hb⟩
  refine ⟨arg (f b) * im (g b),?_,?_⟩
  · rw [isTheta_exp_arg_mul_im]
    exact isTheta_exp_arg_mul_right_of_isTheta_exp_arg_mul_right_of_isTheta_exp_arg_mul_right_of_isBounded hl with
    ⟨b, hb⟩
    refine ⟨arg (f b) * im (g b),?_,?_⟩
    · simp only [abs_of_nonneg (abs_nonneg _), abs_of_nonneg (abs_nonneg _)]

For theorem:
theorem isTheta_exp_arg_mul_im (hl : IsBoundedUnder (· ≤ ·) l fun x => |(g x).im|) :
    (fun x => Real.exp (arg (f x) * im (g x))) =Θ[l] fun _ => (1 : ℝ) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases' archimedean_iff_nat_lt.1 Real.instArchimedean s with n hn
  refine tendsto_atTop_atTop.comp?_
  refine tendsto_exp_atBot.comp?_
  refine tendsto_exp_atBot.comp (tendsto_id.const_mul_atTop_of_ne_zero?_)
  refine tendsto_exp_atBot.comp (tendsto_id.const_mul_atTop_of_ne_zero?_)
  refine tendsto_exp_atBot.comp (tendsto_id.const_mul_atTop_of_ne_zero?_)
  refine tendsto_exp_atBot.comp (tendsto_id.const_mul_atTop_of_ne_zero?_)
  refine tendsto_const_nhds.congr'?_
  refine tendsto_exp_atBot.comp (tendsto_id.const_mul_atTop_of_ne_zero?_)
  refine tendsto_exp_atBot.comp (tendsto_id.const_mul_atTop_of_ne_zero?_)
  refine tendsto_exp_atBot.comp (tendsto_id.const_mul_atTop_of_ne_zero?_)
  refine tendsto_exp_atBot.comp (tendsto_id.const_mul_atTop_of_ne_zero?_)
  refine tendsto_exp_atBot.comp (tendsto_id.const_mul_atTop_of_ne_zero?_)
  refine tendsto_exp_atBot.comp (tendsto_id.const_mul_atTop_of_ne_zero?_)
  refine tendsto_exp_atBot.comp (tendsto_id.const_mul_atTop_of_ne_zero?_)
  refine tendst

For theorem:
theorem tendsto_exp_div_rpow_atTop (s : ℝ) : Tendsto (fun x : ℝ => exp x / x ^ s) atTop atTop 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ((tendsto_rpow_atTop hb).comp (tendsto_exp_div_rpow_atTop hb)).congr'?_
  refine ((tendsto_rpow_atTop hb).comp (tendsto_exp_mul_div_rpow_atTop hb)).congr'?_
  refine (tendsto_exp_mul_div_rpow_atTop hb).congr'?_
  refine (tendsto_exp_mul_div_rpow_atTop hb).congr fun x hx =>?_
  refine (tendsto_exp_mul_div_rpow_atTop hb).congr fun x hx =>?_
  refine (tendsto_exp_mul_div_rpow_atTop hb).comp (tendsto_exp_div_rpow_atTop hb)?_
  refine (tendsto_exp_mul_div_rpow_atTop hb).congr fun x hx =>?_
  refine (tendsto_exp_mul_div_rpow_atTop hb).comp (tendsto_exp_div_rpow_atTop hb)?_
  refine (tendsto_exp_mul_div_rpow_atTop hb).congr'?_
  refine (tendsto_exp_mul_div_rpow_atTop hb).congr fun x hx =>?_
  refine (tendsto_exp_mul_div_rpow_atTop hb).congr'?_
  refine (tendsto_exp_mul_div_rpow_atTop hb).congr fun x hx =>?_
  refine (tendsto_exp_mul_div_rpow_atTop hb).congr'?_
  refine (tendsto_exp_mul_div_rpow_atTop hb).congr fun x hx =>?_
  refine tendsto_const_nhds.congr fun x hx =>?_
  refine tends

For theorem:
theorem tendsto_exp_mul_div_rpow_atTop (s : ℝ) (b : ℝ) (hb : 0 < b) :
    Tendsto (fun x : ℝ => exp (b * x) / x ^ s) atTop atTop 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean - 2024-08-20 15:13:36.722688.
---0/3204---
Verifying proof:
:= by
  cases' p with z w
  rw [continuousAt_cpow_iff_continuousAt, ← continuousWithinAt_univ]
  refine continuousWithinAt_univ.continuousAt.comp?_
  rw [continuousWithinAt_univ]
  refine (continuousAt_cpow_const?_).comp (continuousAt_cpow_const?_)
  refine (continuousAt_cpow_const?_).comp (continuousAt_cpow_const?_)
  refine (continuousAt_cpow_const?_).comp (continuousAt_cpow_const?_)
  refine (continuousAt_cpow_const?_).comp (continuousAt_cpow_const?_)
  refine (continuousAt_cpow_const?_).comp (continuousAt_cpow_const?_)
  refine (continuousAt_cpow_const?_).comp (continuousAt_cpow_const?_)
  refine (continuousAt_cpow_const?_).comp (continuousAt_cpow_const?_)
  refine (continuousAt_cpow_const?_).comp (continuousAt_cpow_const?_)
  refine (continuousAt_cpow_const?_).comp (continuousAt_cpow_const?_)
  refine (continuousAt_cpow_const?_).comp (continuousAt_cpow_const?_)
  refine (continuousAt_cpow_const?_).comp (continuousAt_cpow_const?_)
  refine (continuousAt_cpow_const?_).continuousA

For theorem:
theorem continuousAt_cpow_of_re_pos {p : ℂ × ℂ} (h₁ : 0 ≤ p.1.re ∨ p.1.im ≠ 0) (h₂ : 0 < p.2.re) :
    ContinuousAt (fun x : ℂ × ℂ => x.1 ^ x.2) p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases lt_trichotomy (0 : ℝ) x with (hx | rfl | hx)
  · simp only [hx, Pi.zero_apply, zero_cpow hx.ne', Real.zero_rpow hx.ne', Real.zero_rpow hx.ne',
      Real.zero_rpow hx.ne', Real.zero_rpow hx.ne']

For theorem:
theorem continuousAt_ofReal_cpow (x : ℝ) (y : ℂ) (h : 0 < y.re ∨ x ≠ 0) :
    ContinuousAt (fun p => (p.1 : ℂ) ^ p.2 : ℝ × ℂ → ℂ) (x, y) 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean - 2024-08-20 15:13:55.768812.
---0/3204---
Verifying proof:
:= by
  rw [Ne, ← add_eq_zero_iff_eq_neg, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ←

For theorem:
theorem hasDerivAt_ofReal_cpow {x : ℝ} (hx : x ≠ 0) {r : ℂ} (hr : r ≠ -1) :
    HasDerivAt (fun y : ℝ => (y : ℂ) ^ (r + 1) / (r + 1)) (x ^ r) x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [Ne.def, ← add_eq_zero_iff_eq_neg, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne] at hr
  refine (hasDerivAt_cpow_const _ _).congr_of_eventuallyEq?_
  refine ((hasDerivAt_cpow_const _ _).div_const _).div_const _).congr_of_eventuallyEq?_
  simp only [Ne, cpow_eq_zero_iff_rpow_eq_one, Ne, not_false_iff, not_false_iff,
    not_false_iff] at hr
  refine hasDerivAt_ofReal_cpow_of_hasDerivAt_of_ne?_?_ hx hr
  · simp only [Ne, cpow_eq_zero_iff_rpow_eq_one, Ne, not_and_or, not_false_iff,
      Ne, not_false_iff, not_false_iff] at hr
    refine (hasDerivAt_cpow_const _ _).div_const _?_
    simp only [Ne, cpow_eq_zero_iff, ofReal_eq_zero, ofReal_eq_zero, ofReal_eq_zero, not_false_iff]

For theorem:
theorem hasDerivAt_ofReal_cpow {x : ℝ} (hx : x ≠ 0) {r : ℂ} (hr : r ≠ -1) :
    HasDerivAt (fun y : ℝ => (y : ℂ) ^ (r + 1) / (r + 1)) (x ^ r) x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have := (hasStrictFDerivAt_rpow_const_of_neg ha).comp_hasStrictDerivAt (hasStrictFDerivAt_rpow_const_of_pos ha)
  have : HasStrictFDerivAt (fun x => a ^ x) (a ^ x) := by
    have : HasStrictFDerivAt (fun x => a ^ x) (a ^ x) := by
      have : HasStrictFDerivAt (fun x => a ^ x) (a ^ x) := by
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   

For theorem:
theorem hasStrictDerivAt_const_rpow_of_neg {a x : ℝ} (ha : a < 0) :
    HasStrictDerivAt (fun x => a ^ x) (a ^ x * log a - exp (log a * x) * sin (x * π) * π) x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have := (hasStrictFDerivAt_rpow_const_of_neg ha).comp_hasStrictDerivAt (hasStrictFDerivAt_rpow_const_of_pos ha)
  have : HasStrictFDerivAt (fun x => a ^ x) (a ^ x) := by
    have : HasStrictFDerivAt (fun x => a ^ x) (a ^ x) := by
      have : HasStrictFDerivAt (fun x => a ^ x) (a ^ x) := by
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   

For theorem:
theorem hasStrictDerivAt_const_rpow_of_neg {a x : ℝ} (ha : a < 0) :
    HasStrictDerivAt (fun x => a ^ x) (a ^ x * log a - exp (log a * x) * sin (x * π) * π) x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [Ne, ← add_eq_zero_iff_eq_neg, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ← Ne, ←

For theorem:
theorem hasDerivAt_ofReal_cpow {x : ℝ} (hx : x ≠ 0) {r : ℂ} (hr : r ≠ -1) :
    HasDerivAt (fun y : ℝ => (y : ℂ) ^ (r + 1) / (r + 1)) (x ^ r) x 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Pow/Real.lean - 2024-08-20 15:15:30.345433.
---0/3204---
Verifying proof:
:= by
  rcases le_iff_eq_or_lt.1 hx with (H | pos)
  · by_cases h : y + z = 0
  · simp only [H.symm, rpow_zero, one_mul]

For theorem:
theorem le_rpow_add {x : ℝ} (hx : 0 ≤ x) (y z : ℝ) : x ^ y * x ^ z ≤ x ^ (y + z) 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Stirling.lean - 2024-08-20 15:15:39.721032.
---0/3204---
Verifying proof:
:= by
  refine Tendsto.congr' (eventually_atTop.mpr ⟨?_,?_⟩) <;>
    simp only [stirlingSeq, eventually_atTop, eventually_const, not_false_iff, not_false_iff,
      not_false_eq_true, not_false_eq_true, not_false_eq_true] at ha ⊢
  refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_wallis_limit hane ha?_
  refine Tendsto.congr' (eventually_atTop.mpr ⟨?_,?_⟩) <;>
    simp only [Wallis.W_eq_false] at ha ⊢
  refine Tendsto.congr' (eventually_atTop.mpr ⟨?_,?_⟩) <;>
    simp only [stirlingSeq, stirlingSeq_eq_stirlingSeq, stirlingSeq_eq_stirlingSeq, stirlingSeq,
    stirlingSeq_eq_stirlingSeq] at ha ⊢
  refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_wallis_limit hane hane?_
  refine Tendsto.congr' (eventually_atTop.mpr ⟨?_,?_⟩) <;>
    simp only [stirlingSeq, stirlingSeq_eq_stirlingSeq, stirlingSeq_eq_stirlingSeq, stirlingSeq,
    tendsto_const_nhds] at ha ⊢
  refine Tendsto.congr' (eventually_atTop.mpr ⟨?_,?_⟩) <;>
    simp only [stirlingSeq, stirlingSeq, stirlingS

For theorem:
theorem second_wallis_limit (a : ℝ) (hane : a ≠ 0) (ha : Tendsto stirlingSeq atTop (𝓝 a)) :
    Tendsto Wallis.W atTop (𝓝 (a ^ 2 / 2)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : 4 = 2 * 2 := by rfl
  have : 4 = 2 * 2 := by rfl
  have : 4 = 2 * 2 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have : 4 = 2 * n + 1 := by rfl
  have

For theorem:
theorem stirlingSeq_pow_four_div_stirlingSeq_pow_two_eq (n : ℕ) (hn : n ≠ 0) :
    stirlingSeq n ^ 4 / stirlingSeq (2 * n) ^ 2 * (n / (2 * n + 1)) = Wallis.W n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let d : ℝ := ∑' k : ℕ, (1 : ℝ) / (↑(k + 1) : ℝ) ^ 2
  use d

For theorem:
theorem log_stirlingSeq_bounded_aux :
    ∃ c : ℝ, ∀ n : ℕ, log (stirlingSeq 1) - log (stirlingSeq (n + 1)) ≤ c 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Tendsto.congr' (eventually_atTop.mpr ⟨?_,?_⟩) <;>
    simp only [stirlingSeq, eventually_atTop, eventually_const, not_false_iff, not_false_iff,
      not_false_eq_true, not_false_eq_true, not_false_eq_true] at ha ⊢
  refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_wallis_limit hane ha?_
  refine Tendsto.congr' (eventually_atTop.mpr ⟨?_,?_⟩) <;>
    simp only [Wallis.W_eq_false] at ha ⊢
  refine Tendsto.congr' (eventually_atTop.mpr ⟨?_,?_⟩) <;>
    simp only [stirlingSeq, stirlingSeq_eq_stirlingSeq, stirlingSeq_eq_stirlingSeq, stirlingSeq,
    stirlingSeq_eq_stirlingSeq] at ha ⊢
  refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_wallis_limit hane hane?_
  refine Tendsto.congr' (eventually_atTop.mpr ⟨?_,?_⟩) <;>
    simp only [stirlingSeq, stirlingSeq_eq_stirlingSeq, stirlingSeq_eq_stirlingSeq, stirlingSeq,
    tendsto_const_nhds] at ha ⊢
  refine Tendsto.congr' (eventually_atTop.mpr ⟨?_,?_⟩) <;>
    simp only [stirlingSeq, stirlingSeq, stirlingS

For theorem:
theorem second_wallis_limit (a : ℝ) (hane : a ≠ 0) (ha : Tendsto stirlingSeq atTop (𝓝 a)) :
    Tendsto Wallis.W atTop (𝓝 (a ^ 2 / 2)) 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean - 2024-08-20 15:16:19.049521.
---0/3204---
Verifying proof:
:= by
  induction θ using Real.Angle.induction_on
  exact Real.sin_add_pi_div_two _

For theorem:
theorem sin_add_pi_div_two (θ : Angle) : sin (θ + ↑(π / 2)) = cos θ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro Hcos
    rw [← sub_eq_zero, cos_sub_cos, mul_eq_zero]
    rw [← sub_eq_zero, cos_sub_cos, mul_eq_zero]
    exact cos_eq_zero_iff_angle_eq_zero.1 hcos

For theorem:
theorem cos_eq_iff_coe_eq_or_eq_neg {θ ψ : ℝ} :
    cos θ = cos ψ ↔ (θ : Angle) = ψ ∨ (θ : Angle) = -ψ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  induction θ
  rw [toReal_coe]
  exact toIocMod_toIocMod _ _ _ _

For theorem:
theorem toIocMod_toReal (θ : Angle) : toIocMod two_pi_pos (-π) θ.toReal = θ.toReal 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h => h ▸ ⟨abs_nonneg _, abs_toReal_le_pi _⟩, fun h =>?_⟩
  by_cases hθ : θ = 0
  · simp only [hθ, Real.Angle.abs_toReal, Real.Angle.abs_toReal, Real.Angle.abs_toReal,
      Real.Angle.abs_toReal, Real.Angle.abs_toReal, Real.Angle.abs_toReal, Real.Angle.abs_toReal,
      Real.Angle.abs_toReal, Real.Angle.abs_toReal, Real.Angle.abs_toReal, Real.Angle.abs_toReal]
  · simp only [Real.Angle.abs_toReal, Real.Angle.abs_toReal, Real.Angle.toReal_eq_zero_iff,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

For theorem:
theorem abs_toReal_neg_coe_eq_self_iff {θ : ℝ} : |(-θ : Angle).toReal| = θ ↔ 0 ≤ θ ∧ θ ≤ π 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  nth_rw 1 [← coe_toReal θ]

For theorem:
theorem two_nsmul_toReal_eq_two_mul_add_two_pi {θ : Angle} :
    ((2 : ℕ) • θ).toReal = 2 * θ.toReal + 2 * π ↔ θ.toReal ≤ -π / 2 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro θ
  induction θ
  exact Real.sin_antiperiodic _

For theorem:
theorem sin_antiperiodic : Function.Antiperiodic sin (π : Angle) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  induction θ using Real.Angle.induction_on
  exact Real.cos_pi_div_two_sub _

For theorem:
theorem cos_pi_div_two_sub (θ : Angle) : cos (↑(π / 2) - θ) = sin θ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro θ ψ h
  induction θ using Real.Angle.induction_on
  simpa [toReal_coe, toIocMod_eq_toIocMod, zsmul_eq_mul, mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    mul_comm _ (2 * π), ←
    

For theorem:
theorem toReal_injective : Function.Injective toReal 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean - 2024-08-20 15:17:40.790127.
---0/3204---
Verifying proof:
  | 0 => by norm_num
  | 0 => by norm_num
  | 0 => by norm_num
  | 0 => by norm_num
  | n + 1 => by
    refine lt_of_lt_of_le _ (sqrt_sq zero_lt_two.le).le
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]
    rw [sqrt_sq zero_lt_two.le]

For theorem:
theorem sqrtTwoAddSeries_lt_two : ∀ n : ℕ, sqrtTwoAddSeries 0 n < 2
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean - 2024-08-20 15:17:56.380979.
---0/3204---
Verifying proof:
:= by
  let U := Ico 0 (π / 2)
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  have intU : interior U = Ioo 0 (π / 2) := interior_Ico
  hav

For theorem:
theorem lt_tan {x : ℝ} (h1 : 0 < x) (h2 : x < π / 2) : x < tan x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  wlog hx₀ : 0 ≤ x
  · simpa using this $ neg_nonneg.2 $ le_of_not_le hx₀
  suffices MonotoneOn (fun x ↦ cos x + x ^ 2 / 2) (Ioi 0) by
    simpa using this $ neg_nonneg.2 $ le_of_not_le hx₀
    suffices MonotoneOn (fun x ↦ cos x + x ^ 2 / 2) (Ioi 0) by
      simpa using this $ neg_nonneg.2 $ le_of_not_le hx₀
    suffices MonotoneOn (fun x ↦ cos x + x ^ 2 / 2) (Ioi 0) by
      simpa using this $ neg_nonneg.2 $ le_of_not_le hx₀
    suffices MonotoneOn (fun x ↦ cos x + x ^ 2 / 2) (Ioi 0) by
      simpa using this $ neg_nonneg.2 $ le_of_not_le hx₀
    suffices MonotoneOn (fun x ↦ cos x + x ^ 2 / 2) (Ioi 0) by
      simpa using this $ neg_nonneg.2 $ le_of_not_le hx₀
    suffices MonotoneOn (fun x ↦ cos x + x ^ 2 / 2) (Ioi 0) by
      simpa using this $ neg_nonneg.2 $ le_of_not_le hx₀
    suffices MonotoneOn (fun x ↦ cos x + x ^ 2 / 2) (Ioi 0) by
      simpa using this $ neg_nonneg.2 $ le_of_not_le hx₀
    suffices MonotoneOn (fun x ↦ cos x + x ^ 2 / 2) (Ioi 0) by
      s

For theorem:
lemma one_sub_sq_div_two_le_cos : 1 - x ^ 2 / 2 ≤ cos x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  wlog hx₀ : 0 ≤ x
  · simpa using this (by rwa [abs_neg]) $ neg_nonneg.2 $ le_of_not_le hx₀

For theorem:
lemma cos_quadratic_upper_bound (hx : |x| ≤ π) : cos x ≤ 1 - 2 / π ^ 2 * x ^ 2 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Trigonometric/Chebyshev.lean - 2024-08-20 15:18:12.660449.
---0/3204---
Verifying proof:
:=
  @algebraMap_eval_T ℝ ℂ _ _ _ _ _ _

For theorem:
theorem complex_ofReal_eval_T : ∀ (x : ℝ) n, (((T ℝ n).eval x : ℝ) : ℂ) = (T ℂ n).eval (x : ℂ) 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean - 2024-08-20 15:18:15.287886.
---0/3204---
Verifying proof:
:= by
  simp only [cos, div_eq_mul_inv]
  convert ((((((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub).cexp.sub).cexp.sub
    ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
    ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
      ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
      ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
      ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
      ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
      ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
      ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
      ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
      ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
      ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
      ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
      ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
      ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
      ((hasStrictDerivAt_id x).neg.mul_const I).cexp.sub
      ((hasStrictDerivAt_id x).neg.mul_const I)

For theorem:
theorem hasStrictDerivAt_sin (x : ℂ) : HasStrictDerivAt sin (cos x) x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [sinh, div_eq_mul_inv]
  convert ((hasStrictDerivAt_exp x).add (hasStrictDerivAt_id x).neg.cexp).mul_const _ using 1
  simp only [div_eq_mul_inv]

For theorem:
theorem hasStrictDerivAt_cosh (x : ℂ) : HasStrictDerivAt cosh (sinh x) x 
Attempt failure.

Working on Mathlib/Analysis/SpecialFunctions/Trigonometric/EulerSineProd.lean - 2024-08-20 15:18:48.803923.
---0/3204---
Verifying proof:
:= by
  rw [integral_cos_mul_cos_pow_even hz]
  refine integral_cos_mul_cos_pow_even?_ (by norm_num) (by norm_num) (by norm_num)?_
  · simp only [Nat.cast_ofNat, Nat.cast_add, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat,
      Nat.cast_add, Nat.cast_ofNat, Nat.cast_add, Nat.cast_ofNat, Nat.cast_ofNat,
    Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat,
    Nat.cast_add, Nat.cast_ofNat, Nat.cast_add, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat,
    Nat.cast_add, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat,
    Nat.cast_add, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat,
    Nat.cast_ofNat, Nat.cast_add, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat,
    Nat.cast_add, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat,
    Nat.cast_add, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat,
    Nat.cast_add, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat, Nat.cast_ofNat,
    Nat.cast_add, Nat.cast_ofNat, Nat.cast

For theorem:
theorem integral_cos_mul_cos_pow_even (n : ℕ) (hz : z ≠ 0) :
    (((1 : ℂ) - z ^ 2 / ((n : ℂ) + 1) ^ 2) *
        ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (2 * n + 2)) =
      (2 * n + 1 : ℂ) / (2 * n + 2) *
        ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (2 * n) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine integral_cos_mul_cos_pow_mul_cos_pow?_?_
  · simp only [integral_cos_mul_cos_pow hn hz, Complex.ofReal_pow, Complex.ofReal_div,
      Complex.ofReal_ofNat, Complex.ofReal_pow, Complex.ofReal_ofNat, Complex.ofReal_pow,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_pow, Complex.ofReal_ofNat,
    Complex.ofReal_pow, Complex.ofReal_ofNat, Complex.ofReal_ofNat, Complex.ofReal_pow,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_ofNat, Complex.ofReal_pow,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_div, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_div, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_div, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_div, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_div, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_ofNat, Complex.ofReal_

For theorem:
theorem integral_cos_mul_cos_pow (hn : 2 ≤ n) (hz : z ≠ 0) :
    (((1 : ℂ) - (4 : ℂ) * z ^ 2 / (n : ℂ) ^ 2) *
      ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ n) =
      (n - 1 : ℂ) / n *
        ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (n - 2) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp_rw [Complex.sin, Complex.ofReal_mul, Complex.ofReal_pow, Complex.ofReal_one,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_pow, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_pow, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_pow, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_div, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_pow, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_pow, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_pow, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_pow, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_pow, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex.ofReal_pow, Complex.ofReal_ofNat,
    Complex.ofReal_div, Complex.ofReal_ofNat, Complex

For theorem:
theorem sin_pi_mul_eq (z : ℂ) (n : ℕ) :
    Complex.sin (π * z) =
      ((π * z * ∏ j ∈ Finset.range n, ((1 : ℂ) - z ^ 2 / ((j : ℂ) + 1) ^ 2)) *
          ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (2 * n)) /
        (∫ x in (0 : ℝ)..π / 2, cos x ^ (2 * n) : ℝ) 
Attempt failure.

Working on Mathlib/Analysis/SpecificLimits/Basic.lean - 2024-08-20 15:19:17.801873.
---0/3204---
Verifying proof:
:= by
  have := aux_hasSum_of_le_geometric hr hu
  convert dist_le_geometric_of_le_geometric hr hu
  convert dist_le_geometric_of_tendsto_geometric_of_le_geometric hr hu
  convert dist_le_geometric_of_tendsto_geometric_of_le_geometric hr hu
  convert dist_le_geometric_of_tendsto_geometric_of_tendsto_geometric_of_le_geometric hr hu
  convert dist_le_geometric_of_tendsto_geometric_of_tendsto_geometric_of_le_geometric hr hu
  convert dist_le_geometric_of_tendsto_geometric_of_tendsto_geometric_of_le_geometric hr hu
  convert dist_le_geometric_of_tendsto_geometric_of_le_geometric_of_tendsto_geometric ha hu
  convert dist_le_geometric_of_tendsto_geometric_of_tendsto_geometric_of_le_geometric hr hu
  convert dist_le_geometric_of_tendsto_geometric_of_le_geometric_of_tendsto_geometric ha hu
  convert dist_le_geometric_of_tendsto_geometric_of_tendsto_geometric_of_tendsto_geometric ha hu
  convert dist_le_geometric_of_tendsto_geometric_of_tendsto_geometric_of_tendsto_geometric ha hu
  convert dist_le_geometric_of_tends

For theorem:
theorem dist_le_of_le_geometric_of_tendsto {a : α} (ha : Tendsto f atTop (𝓝 a)) (n : ℕ) :
    dist (f n) a ≤ C * r ^ n / (1 - r) 
Attempt failure.

Working on Mathlib/Analysis/SpecificLimits/FloorPow.lean - 2024-08-20 15:19:25.308945.
---0/3204---
Verifying proof:
:= by
  refine tendsto_div_of_monotone_of_exists_subseq_tendsto_div hmono fun a ha =>?_
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc

For theorem:
theorem tendsto_div_of_monotone_of_exists_subseq_tendsto_div (u : ℕ → ℝ) (l : ℝ)
    (hmono : Monotone u)
    (hlim : ∀ a : ℝ, 1 < a → ∃ c : ℕ → ℕ, (∀ᶠ n in atTop, (c (n + 1) : ℝ) ≤ a * c n) ∧
      Tendsto c atTop atTop ∧ Tendsto (fun n => u (c n) / c n) atTop (𝓝 l)) :
    Tendsto (fun n => u n / n) atTop (𝓝 l) := by
    have lnonneg : 0 ≤ l := by
    rcases hlim 2 one_lt_two with ⟨c, _, ctop, clim⟩
    have : Tendsto (fun n => u 0 / c n) atTop (𝓝 0) :=
      tendsto_const_nhds.div_atTop (tendsto_natCast_atTop_iff.2 ctop)
    apply le_of_tendsto_of_tendsto' this clim fun n => ?_
    gcongr
    exact hmono (zero_le _)
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_floor_pow hmono?_ cone clim
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_floor_pow hmono?_ cone clim
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_of_tendsto_div_floor_pow hmono?_ cone clim
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_floor_pow hmono?_ cone clim
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_floor_pow hmono?_ cone clim
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_floor_pow hmono?_ cone clim
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_floor_pow hmono?_ cone clim
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_floor_pow hmono?_ cone clim
  refine

For theorem:
theorem tendsto_div_of_monotone_of_tendsto_div_floor_pow (u : ℕ → ℝ) (l : ℝ) (hmono : Monotone u)
    (c : ℕ → ℝ) (cone : ∀ k, 1 < c k) (clim : Tendsto c atTop (𝓝 1))
    (hc : ∀ k, Tendsto (fun n : ℕ => u ⌊c k ^ n⌋₊ / ⌊c k ^ n⌋₊) atTop (𝓝 l)) :
    Tendsto (fun n => u n / n) atTop (𝓝 l) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_floor_pow hmono?_ cone clim
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_floor_pow hmono?_ cone clim
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_of_tendsto_div_floor_pow hmono?_ cone clim
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_floor_pow hmono?_ cone clim
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_floor_pow hmono?_ cone clim
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_floor_pow hmono?_ cone clim
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_floor_pow hmono?_ cone clim
  refine tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_of_monotone_of_tendsto_div_floor_pow hmono?_ cone clim
  refine

For theorem:
theorem tendsto_div_of_monotone_of_tendsto_div_floor_pow (u : ℕ → ℝ) (l : ℝ) (hmono : Monotone u)
    (c : ℕ → ℝ) (cone : ∀ k, 1 < c k) (clim : Tendsto c atTop (𝓝 1))
    (hc : ∀ k, Tendsto (fun n : ℕ => u ⌊c k ^ n⌋₊ / ⌊c k ^ n⌋₊) atTop (𝓝 l)) :
    Tendsto (fun n => u n / n) atTop (𝓝 l) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine tendsto_div_of_monotone_of_exists_subseq_tendsto_div hmono fun a ha =>?_
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc⟩
  rcases hlim a ha with ⟨c, hc

For theorem:
theorem tendsto_div_of_monotone_of_exists_subseq_tendsto_div (u : ℕ → ℝ) (l : ℝ)
    (hmono : Monotone u)
    (hlim : ∀ a : ℝ, 1 < a → ∃ c : ℕ → ℕ, (∀ᶠ n in atTop, (c (n + 1) : ℝ) ≤ a * c n) ∧
      Tendsto c atTop atTop ∧ Tendsto (fun n => u (c n) / c n) atTop (𝓝 l)) :
    Tendsto (fun n => u n / n) atTop (𝓝 l) := by
    have lnonneg : 0 ≤ l := by
    rcases hlim 2 one_lt_two with ⟨c, _, ctop, clim⟩
    have : Tendsto (fun n => u 0 / c n) atTop (𝓝 0) :=
      tendsto_const_nhds.div_atTop (tendsto_natCast_atTop_iff.2 ctop)
    apply le_of_tendsto_of_tendsto' this clim fun n => ?_
    gcongr
    exact hmono (zero_le _)
Attempt failure.

Working on Mathlib/Analysis/SpecificLimits/Normed.lean - 2024-08-20 15:19:45.225670.
---0/3204---
Verifying proof:
:= by
  rw [isLittleO_pow_const_mul_const_pow_const_pow_const_pow_of_lt h]
  refine isLittleO_pow_const_pow_const_pow_const_pow_of_lt?_?_?_
  · rw [isLittleO_pow_const_pow_const_pow_const_pow_const_pow_of_lt h]
    refine isLittleO_pow_const_pow_const_pow_const_pow_const_pow_const_pow_const_pow_of_lt?_?_?_
    · exact isLittleO_pow_const_pow_const_pow_const_pow_const_pow_const_pow_of_lt h h

For theorem:
theorem isLittleO_pow_const_mul_const_pow_const_pow_of_norm_lt {R : Type*} [NormedRing R] (k : ℕ)
    {r₁ : R} {r₂ : ℝ} (h : ‖r₁‖ < r₂) :
    (fun n ↦ (n : R) ^ k * r₁ ^ n : ℕ → R) =o[atTop] fun n ↦ r₂ ^ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : Tendsto (fun n ↦ (n : R) ^ k : ℕ → R) (𝓝[>] 0) (𝓝 0) := by
    have : Tendsto (fun n ↦ (n : R) ^ k : ℕ → R) (𝓝[>] 0) (𝓝 0) := by
      refine (tendsto_pow_atTop_nhds_zero_of_lt_one hr).comp (tendsto_pow_atTop_nhds_zero_of_lt_one hr)
    exact tendsto_pow_atTop_nhds_zero_of_lt_one hr

For theorem:
theorem isLittleO_pow_const_const_pow_of_one_lt {R : Type*} [NormedRing R] (k : ℕ) {r : ℝ}
    (hr : 1 < r) : (fun n ↦ (n : R) ^ k : ℕ → R) =o[atTop] fun n ↦ r ^ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  tfae_have 1 → 2
  · exact ⟨0, by simpa only [zero_lt_one] using half_pos R⟩
  tfae_have 1 → 3
  · exact ⟨0, by simpa only [zero_lt_one] using half_pos R⟩
  tfae_have 1 → 2
  · exact ⟨0, by simpa only [zero_lt_one] using half_pos R⟩
  tfae_have 1 → 3
  · exact ⟨0, by simpa only [zero_lt_one] using half_pos R⟩
  tfae_have 1 → 2
  · exact ⟨0, by simpa only [zero_lt_one] using half_pos R⟩
  tfae_have 1 → 2
  · exact ⟨0, by simpa only [zero_lt_one] using half_pos R⟩
  tfae_have 1 → 3
  · exact ⟨0, by simpa only [zero_lt_one] using half_pos R⟩
  tfae_have 1 → 2
  · exact ⟨0, by simpa only [zero_lt_one] using half_pos R⟩
  tfae_have 1 → 2
  · exact ⟨0, by simpa only [zero_lt_one] using half_pos R⟩
  tfae_have 1 → 3
  · exact ⟨0, by simpa only [zero_lt_one] using half_pos R⟩
  tfae_have 1 → 2
  · exact ⟨0, by simpa only [zero_lt_one] using half_pos R⟩
  tfae_have 1 → 3
  · exact ⟨0, by simpa only [zero_lt_one] using half_pos R

For theorem:
theorem TFAE_exists_lt_isLittleO_pow (f : ℕ → ℝ) (R : ℝ) :
    TFAE
      [∃ a ∈ Ioo (-R) R, f =o[atTop] (a ^ ·), ∃ a ∈ Ioo 0 R, f =o[atTop] (a ^ ·),
        ∃ a ∈ Ioo (-R) R, f =O[atTop] (a ^ ·), ∃ a ∈ Ioo 0 R, f =O[atTop] (a ^ ·),
        ∃ a < R, ∃ C : ℝ, (0 < C ∨ 0 < R) ∧ ∀ n, |f n| ≤ C * a ^ n,
        ∃ a ∈ Ioo 0 R, ∃ C > 0, ∀ n, |f n| ≤ C * a ^ n, ∃ a < R, ∀ᶠ n in atTop, |f n| ≤ a ^ n,
        ∃ a ∈ Ioo 0 R, ∀ᶠ n in atTop, |f n| ≤ a ^ n] 
Attempt failure.

Working on Mathlib/Analysis/Subadditive.lean - 2024-08-20 15:20:11.210608.
---0/3204---
Verifying proof:
:= by
  refine tendsto_order.2 ⟨fun l hl =>?_, fun L hL =>?_ ⟩
  · refine eventually_of_forall fun n =>?_
    · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of_forall fun n =>?_
      · refine eventually_of

For theorem:
theorem tendsto_lim (hbdd : BddBelow (range fun n => u n / n)) :
    Tendsto (fun n => u n / n) atTop (𝓝 h.lim) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine tendsto_order.2 ⟨fun l hl =>?_, fun L hL =>?_⟩
  · exact eventually_of_forall fun n => u n / n

For theorem:
theorem tendsto_lim (hbdd : BddBelow (range fun n => u n / n)) :
    Tendsto (fun n => u n / n) atTop (𝓝 h.lim) 
Attempt failure.

Working on Mathlib/Analysis/SumOverResidueClass.lean - 2024-08-20 15:20:15.601121.
---0/3204---
Verifying proof:
:= by
  refine not_summable_indicator_mod_of_antitone_of_not_summable_nat?_?_?_
  · simp only [Set.indicator_apply, Set.indicator_of_mem, Set.mem_setOf_eq, Set.mem_setOf_eq,
      Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq, not_false_eq_true,
      Set.indicator_of_not_mem, Set.indicator_of_mem, Set.mem_setOf_eq]
    rw [Set.indicator_of_not_mem, Set.indicator_of_mem, Set.indicator_of_mem,
      Set.indicator_of_not_mem, Set.indicator_of_mem, Set.indicator_of_mem, not_false_eq_true,
      Set.indicator_of_not_mem, Set.indicator_of_mem, Set.indicator_of_mem, not_false_eq_true,
      Set.indicator_of_not_mem, Set.indicator_of_mem, Set.indicator_of_mem, not_false_eq_true,
      Set.indicator_of_not_mem, Set.indicator_of_mem, Set.indicator_of_mem, Set.indicator_of_mem,
      Set.indicator_of_not_mem, Set.indicator_of_mem, Set.indicator_of_mem, Set.indicator_of_mem,
      Set.indicator_of_not_mem, Set.indicator_of_mem, Set.indicator_of_not_mem, not_false_eq_true,
      Set.indicator_of_not_mem, Set.

For theorem:
lemma not_summable_indicator_mod_of_antitone_of_neg {m : ℕ} [hm : NeZero m] {f : ℕ → ℝ}
    (hf : Antitone f) {n : ℕ} (hn : f n < 0) (k : ZMod m) :
    ¬ Summable ({n : ℕ | (n : ZMod m) = k}.indicator f) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine not_summable_indicator_mod_of_antitone_of_not_summable_nat?_?_?_
  · simp only [Set.indicator_apply, Set.indicator_of_mem, Set.mem_setOf_eq, Set.mem_setOf_eq,
      Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq, not_false_eq_true,
      Set.indicator_of_not_mem, Set.indicator_of_mem, Set.mem_setOf_eq]
    rw [Set.indicator_of_not_mem, Set.indicator_of_mem, Set.indicator_of_mem,
      Set.indicator_of_not_mem, Set.indicator_of_mem, Set.indicator_of_mem, not_false_eq_true,
      Set.indicator_of_not_mem, Set.indicator_of_mem, Set.indicator_of_mem, not_false_eq_true,
      Set.indicator_of_not_mem, Set.indicator_of_mem, Set.indicator_of_mem, not_false_eq_true,
      Set.indicator_of_not_mem, Set.indicator_of_mem, Set.indicator_of_mem, Set.indicator_of_mem,
      Set.indicator_of_not_mem, Set.indicator_of_mem, Set.indicator_of_mem, Set.indicator_of_mem,
      Set.indicator_of_not_mem, Set.indicator_of_mem, Set.indicator_of_not_mem, not_false_eq_true,
      Set.indicator_of_not_mem, Set.

For theorem:
lemma not_summable_indicator_mod_of_antitone_of_neg {m : ℕ} [hm : NeZero m] {f : ℕ → ℝ}
    (hf : Antitone f) {n : ℕ} (hn : f n < 0) (k : ZMod m) :
    ¬ Summable ({n : ℕ | (n : ZMod m) = k}.indicator f) 
Attempt failure.

Working on Mathlib/CategoryTheory/Abelian/Exact.lean - 2024-08-20 15:20:22.266176.
---0/3204---
Verifying proof:
:= by
  let S := ShortComplex.mk f (0 : Y ⟶ 0) comp_zero
  erw [← S.exact_iff_epi rfl] at hf

For theorem:
theorem preservesEpimorphisms_of_map_exact : L.PreservesEpimorphisms where
Attempt failure.

Working on Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean - 2024-08-20 15:20:30.172306.
---0/3204---
Verifying proof:
:= by
  rw [HomologicalComplex.exactAt_iff' _ n (n + 1) (n + 1) (n + 1 + 1) (by simp) (by simp)]
  cases n
  all_goals
  dsimp [ofCocomplex.exactAt_iff' _ n (n + 1) (n + 1) (by simp) (by simp)]
  cases n
  dsimp [ofCocomplex.exactAt_iff' _ n (n + 1) (n + 1) (by simp) (by simp)]

For theorem:
lemma ofCocomplex_exactAt_succ (n : ℕ) :
    (ofCocomplex Z).ExactAt (n + 1) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext n
  rcases n with (rfl | hn)
  · rw [← cancel_mono ((CochainComplex.single₀ C).map f), ← cancel_mono ((CochainComplex.single₀ C).map f),
    ← cancel_mono ((CochainComplex.single₀ C).map f), ← Category.assoc, Iso.hom_inv_id,
    Category.assoc, Iso.hom_inv_id, Category.assoc, Iso.hom_inv_id_assoc, Category.assoc,
    Category.assoc, Iso.hom_inv_id_assoc, Category.assoc, Iso.hom_inv_id, Category.comp_id,
    Category.assoc, Iso.hom_inv_id_assoc, Category.assoc, Iso.hom_inv_id, Category.assoc,
    Category.assoc, Iso.hom_inv_id_assoc, Category.assoc, Iso.hom_inv_id_assoc,
    Category.assoc, Iso.hom_inv_id_assoc, Category.assoc, Iso.hom_inv_id_assoc,
    Category.assoc, Iso.hom_inv_id_assoc, Category.assoc, Iso.hom_inv_id_assoc,
    Category.assoc, Iso.hom_inv_id_assoc, Category.assoc, Iso.hom_inv_id_assoc,
    Category.assoc, Iso.hom_inv_id_assoc, Category.assoc, Iso.hom_inv_id_assoc,
    Category.assoc, Iso.hom_inv_id_assoc, Category.assoc, Iso.hom_inv_id_assoc,
    Category.assoc,

For theorem:
theorem desc_commutes {Y Z : C} (f : Z ⟶ Y) (I : InjectiveResolution Y)
    (J : InjectiveResolution Z) : J.ι ≫ desc f I J = (CochainComplex.single₀ C).map f ≫ I.ι 
Attempt failure.

Working on Mathlib/CategoryTheory/Abelian/NonPreadditive.lean - 2024-08-20 15:20:54.097882.
---0/3204---
Verifying proof:
:= by
  obtain ⟨g, hg⟩ :=
    CokernelCofork.IsColimit.desc' isColimitσ (Limits.prod.map f f ≫ σ) (by
      rw [CokernelCofork.IsColimit.desc' isColimitσ (Limits.prod.map f f ≫ σ) (by
      rw [CokernelCofork.IsColimit.desc' isColimitσ (Limits.prod.map f f ≫ σ) (by
      rw [CokernelCofork.IsColimit.desc' isColimitσ (Limits.prod.map f f ≫ σ) (by
      rw [CokernelCofork.IsColimit.desc' isColimitσ (Limits.prod.map f f ≫ σ) (by
      rw [CokernelCofork.IsColimit.desc' isColimitσ (Limits.prod.map f f ≫ σ) (by
      rw [CokernelCofork.IsColimit.desc' isColimitσ (Limits.prod.map f f ≫ σ) (by
      rw [CokernelCofork.IsColimit.desc' isColimitσ (Limits.prod.map f f ≫ σ) (by
      rw [CokernelCofork.IsColimit.desc' isColimitσ (Limits.prod.map f f ≫ σ) (by
      rw [CokernelCofork.IsColimit.desc' isColimitσ (Limits.prod.map f f ≫ σ) (by
      rw [CokernelCofork.IsColimit.desc' isColimitσ (Limits.prod.map f f ≫ σ) (by
      rw [CokernelCofork.IsColimit.desc' isColimitσ 

For theorem:
theorem σ_comp {X Y : C} (f : X ⟶ Y) : σ ≫ f = Limits.prod.map f f ≫ σ 
Attempt failure.

Working on Mathlib/CategoryTheory/Abelian/Projective.lean - 2024-08-20 15:20:58.079908.
---0/3204---
Verifying proof:
:= by
  rw [projective_iff_preservesEpimorphisms_coyoneda_obj_preserves_epimorphisms]

For theorem:
theorem projective_of_preservesFiniteColimits_preadditiveCoyonedaObj (P : C)
    [hP : PreservesFiniteColimits (preadditiveCoyonedaObj (op P))] : Projective P 
Attempt failure.

Working on Mathlib/CategoryTheory/Abelian/Pseudoelements.lean - 2024-08-20 15:21:00.348946.
---0/3204---
Verifying proof:
:= by
  obtain ⟨P, p, rfl⟩ := h
  obtain ⟨P, p, rfl⟩ := h
  obtain ⟨P, p, rfl⟩ := h
  obtain ⟨P, rfl⟩ := h
  obtain ⟨P, rfl⟩ := h
  obtain ⟨P, rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obta

For theorem:
theorem ModuleCat.eq_range_of_pseudoequal {R : Type*} [CommRing R] {G : ModuleCat R} {x y : Over G}
    (h : PseudoEqual G x y) : LinearMap.range x.hom = LinearMap.range y.hom 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨P, p, rfl⟩ := h
  obtain ⟨P, p, rfl⟩ := h
  obtain ⟨P, p, rfl⟩ := h
  obtain ⟨P, rfl⟩ := h
  obtain ⟨P, rfl⟩ := h
  obtain ⟨P, rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obtain ⟨P', rfl⟩ := h
  obta

For theorem:
theorem ModuleCat.eq_range_of_pseudoequal {R : Type*} [CommRing R] {G : ModuleCat R} {x y : Over G}
    (h : PseudoEqual G x y) : LinearMap.range x.hom = LinearMap.range y.hom 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro h
  have ⟨pbar, hpbar⟩ := h (𝟙 Q)
  have ⟨p, hp⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists_rep pbar
  have ⟨p', hp'⟩ := Quotient.exists

For theorem:
theorem epi_of_pseudo_surjective {P Q : C} (f : P ⟶ Q) : Function.Surjective f → Epi f 
Attempt failure.

---0/3204---
Verifying proof:
:=
  fun h a ha => by
  rw [← apply_zero f] at ha
  exact h ha

For theorem:
theorem zero_of_map_zero {P Q : C} (f : P ⟶ Q) : Function.Injective f → ∀ a, f a = 0 → a = 0 
Attempt failure.

---0/3204---
Verifying proof:
:=
  fun qbar =>
    Quotient.inductionOn qbar fun q =>
      ⟨((pullback.fst : pullback f q.hom ⟶ P) : Over Q) := by
      rw [← Quotient.inductionOn_iff_surjective]
      exact Quotient.inductionOn qbar fun q =>
      ⟨((pullback.fst : pullback f q.hom ⟶ P) : Over Q) := by
      rw [← Quotient.inductionOn_iff_surjective]
      exact Quotient.inductionOn qbar fun q =>
      ⟨((pullback.fst : pullback f q.hom ⟶ P) : Over Q) := by
      rw [← Quotient.inductionOn_iff_surjective]
      exact Quotient.inductionOn qbar fun q =>
      ⟨((pullback.fst : pullback f q.hom ⟶ P) : Over Q) := by
      rw [← Quotient.inductionOn_iff_surjective]
      exact Quotient.inductionOn qbar fun q =>
      ⟨((pullback.fst : pullback f q.hom ⟶ P) : Over Q) := by
      rw [← Quotient.inductionOn_iff_surjective]
      exact Quotient.inductionOn qbar fun q =>
      ⟨((pullback.fst : pullback f q.hom ⟶ P) : Over Q),
        Quotient.inductionOn qbar fun q =>
        ⟨((pullback.fst : pullback f q.ho

For theorem:
theorem pseudo_surjective_of_epi {P Q : C} (f : P ⟶ Q) [Epi f] : Function.Surjective f 
Attempt failure.

---0/3204---
Verifying proof:
:=
  fun ⟨R, p, q, ep, Eq, comm⟩ =>
    ⟨R, p, q, ep, Eq, comm⟩ =>
      ⟨R, p, q, ep, Eq, show p ≫ a.hom ≫ f = q ≫ b.hom ≫ f = q ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ a.hom ≫ f = q ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ a.hom ≫ f = q ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ a.hom ≫ f = q ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ a.hom ≫ f = q ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ a.hom ≫ f = q ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ a.hom ≫ f = q ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b.hom ≫ b

For theorem:
theorem pseudoApply_aux {P Q : C} (f : P ⟶ Q) (a b : Over P) : a ≈ b → app f a ≈ app f b 
Attempt failure.

Working on Mathlib/CategoryTheory/Abelian/RightDerived.lean - 2024-08-20 15:21:25.754074.
---0/3204---
Verifying proof:
:= by
  dsimp [NatTrans.rightDerivedToHomotopyCategory, NatTrans.rightDerivedToHomotopyCategory]

For theorem:
lemma InjectiveResolution.rightDerivedToHomotopyCategory_app_eq
    {F G : C ⥤ D} [F.Additive] [G.Additive] (α : F ⟶ G) {X : C} (P : InjectiveResolution X) :
    (NatTrans.rightDerivedToHomotopyCategory α).app X =
      (P.isoRightDerivedToHomotopyCategoryObj F).hom ≫
        (HomotopyCategory.quotient _ _).map
          ((NatTrans.mapHomologicalComplex α _).app P.cocomplex) ≫
          (P.isoRightDerivedToHomotopyCategoryObj G).inv 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply Functor.rightDerived_obj_ext
  apply Functor.rightDerived_obj_ext

For theorem:
theorem Functor.rightDerived_map_eq (F : C ⥤ D) [F.Additive] (n : ℕ) {X Y : C} (f : X ⟶ Y)
    {P : InjectiveResolution X} {Q : InjectiveResolution Y} (g : P.cocomplex ⟶ Q.cocomplex)
    (w : P.ι ≫ g = (CochainComplex.single₀ C).map f ≫ Q.ι) :
    (F.rightDerived n).map f =
      (P.isoRightDerivedObj F n).hom ≫
        (F.mapHomologicalComplex _ ⋙ HomologicalComplex.homologyFunctor _ _ n).map g ≫
          (Q.isoRightDerivedObj F n).inv 
Attempt failure.

Working on Mathlib/CategoryTheory/Abelian/Transfer.lean - 2024-08-20 15:21:42.938385.
---0/3204---
Verifying proof:
:=
  { has_limit := fun f => by
    have := NatIso.naturality_1 i f
    simp at this
    rw [← this]
    have := NatIso.naturality_1 i f
    simp at this
    rw [← this]
    have := NatIso.naturality_1 i f
    simp at this
    simp at this

For theorem:
theorem hasKernels [PreservesFiniteLimits G] : HasKernels C 
Attempt failure.

---0/3204---
Verifying proof:
:=
  letI := reflective F G i adj
    { has_limit := fun _ ↦ hasLimit_of_reflective _ F }

For theorem:
theorem hasKernels [PreservesFiniteLimits G] : HasKernels C 
Attempt failure.

Working on Mathlib/CategoryTheory/Action.lean - 2024-08-20 15:21:50.998387.
---0/3204---
Verifying proof:
:= by
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  subst b'
  sub

For theorem:
lemma cases' ⦃a' b' : ActionCategory G X⦄ (f : a' ⟶ b') :
    ∃ (a b : X) (g : G) (ha : a' = a) (hb : b' = b) (hg : a = g⁻¹ • b),
      f = eqToHom (by rw [ha, hg]) ≫ homOfPair b g ≫ eqToHom (by rw [hb]) 
Attempt failure.

Working on Mathlib/CategoryTheory/Adhesive.lean - 2024-08-20 15:21:53.517011.
---0/3204---
Verifying proof:
:= by
  obtain ⟨f', hf'⟩ := H
  obtain ⟨f', hf'⟩ := H
  obtain ⟨f', hf'⟩ := H
  obtain ⟨f', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H
  obtain ⟨f'', hf'⟩ := H.exists

For theorem:
theorem is_coprod_iff_isPushout {X E Y YE : C} (c : BinaryCofan X E) (hc : IsColimit c) {f : X ⟶ Y}
    {iY : Y ⟶ YE} {fE : c.pt ⟶ YE} (H : CommSq f c.inl iY fE) :
    Nonempty (IsColimit (BinaryCofan.mk (c.inr ≫ fE) iY)) ↔ IsPushout f c.inl iY fE 
Attempt failure.

Working on Mathlib/CategoryTheory/Bicategory/Basic.lean - 2024-08-20 15:21:57.169119.
---0/3204---
Verifying proof:
:=
  leftUnitor_naturality f g

For theorem:
theorem leftUnitor_naturality {f g : a ⟶ b} (η : f ⟶ g) :
    𝟙 a ◁ η ≫ (λ_ g).hom = (λ_ f).hom ≫ η 
Attempt failure.

Working on Mathlib/CategoryTheory/Bicategory/Coherence.lean - 2024-08-20 15:22:02.358196.
---0/3204---
Verifying proof:
:= by
  rcases η with ⟨η'⟩
  apply @congr_fun _ _ fun p => normalizeAux_congr p g

For theorem:
theorem normalizeAux_congr {a b c : B} (p : Path a b) {f g : Hom b c} (η : f ⟶ g) :
    normalizeAux p f = normalizeAux p g 
Attempt failure.

Working on Mathlib/CategoryTheory/Category/Cat.lean - 2024-08-20 15:22:12.863811.
---0/3204---
Verifying proof:
:=
  Functor.comp_map G f

For theorem:
theorem comp_map {C D E : Cat} (F : C ⟶ D) (G : D ⟶ E) {X Y : C} (f : X ⟶ Y) :
    (F ≫ G).map f = G.map (F.map f) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  Functor.id_map f

For theorem:
theorem id_map {C : Cat} {X Y : C} (f : X ⟶ Y) : (𝟙 C : C ⥤ C).map f = f 
Attempt failure.

Working on Mathlib/CategoryTheory/Closed/Cartesian.lean - 2024-08-20 15:22:19.138800.
---0/3204---
Verifying proof:
:=
  ⟨fun g h _ => by
    haveI := strict_initial t g
    haveI := strict_initial t h
    exact eqToHom (by simp) (by simp)

For theorem:
theorem initial_mono {I : C} (B : C) (t : IsInitial I) [CartesianClosed C] : Mono (t.to B) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  (Closed.isAdj.adj.homEquiv _ _).injective

For theorem:
theorem curry_injective : Function.Injective (curry : (A ⨯ Y ⟶ X) → (Y ⟶ A ⟹ X)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [Limits.prod.map_id, Limits.prod.map_id, Limits.prod.map_id]

For theorem:
theorem prod_map_pre_app_comp_ev (f : B ⟶ A) [Exponentiable B] (X : C) :
    Limits.prod.map (𝟙 B) ((pre f).app X) ≫ (exp.ev B).app X =
      Limits.prod.map f (𝟙 (A ⟹ X)) ≫ (exp.ev A).app X 
Attempt failure.

Working on Mathlib/CategoryTheory/Closed/Functor.lean - 2024-08-20 15:22:29.855461.
---0/3204---
Verifying proof:
:= by
  rw [← frobeniusMorphism_mate F h] at i
  exact i.frobeniusMorphism_mate F h

For theorem:
theorem frobeniusMorphism_iso_of_expComparison_iso (h : L ⊣ F) (A : C)
    [i : IsIso (expComparison F A)] : IsIso (frobeniusMorphism F h A) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← frobeniusMorphism_mate F h] at i
  exact isIso_of_isIso_frobeniusMorphism F h A

For theorem:
theorem frobeniusMorphism_iso_of_expComparison_iso (h : L ⊣ F) (A : C)
    [i : IsIso (expComparison F A)] : IsIso (frobeniusMorphism F h A) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← cancel_mono (expComparison F A), ← cancel_mono (expComparison F A), ← cancel_mono (expComparison F A),
    ← cancel_mono (expComparison F A'), ← cancel_mono (expComparison F A'),
    ← cancel_mono (expComparison F A'), ← cancel_mono (expComparison F A'),
    ← cancel_mono (expComparison F A'), ← cancel_mono (expComparison F A'),
    ← cancel_mono (expComparison F A'), ← cancel_mono (expComparison F A'),
    ← cancel_mono (expComparison F A'), ← cancel_mono (expComparison F A'),
    ← cancel_mono (expComparison F A'), ← cancel_mono (expComparison F A'),
    ← cancel_mono (expComparison F A'), ← cancel_mono (expComparison F A'),
    ← cancel_mono (expComparison F A'), ← cancel_mono (expComparison F A'),
    ← cancel_mono (expComparison F A'), ← cancel_mono (expComparison F A'),
    ← cancel_mono (expComparison F A'), ← cancel_mono (expComparison F A'),
    ← cancel_mono (expComparison F A'), ← cancel_mono (expComparison F A'),
    ← cancel_mono 

For theorem:
theorem expComparison_whiskerLeft {A A' : C} (f : A' ⟶ A) :
    expComparison F A ≫ whiskerLeft _ (pre (F.map f)) =
      whiskerRight (pre f) _ ≫ expComparison F A' 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← cancel_epi ((expComparison F _ _).app B), ← F.map_comp, ← F.map_comp,
    ← F.map_comp, ← F.map_comp, ← F.map_comp, ← F.map_comp, ← F.map_comp,
    ← F.map_comp, ← F.map_comp, ← F.map_comp, ← F.map_comp, ← F.map_comp, ← F.map_comp,
    ← F.map_comp, ← F.map_comp, ← F.map_comp, prodComparison_comp_ev]

For theorem:
theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) 
Attempt failure.

Working on Mathlib/CategoryTheory/Closed/Ideal.lean - 2024-08-20 15:22:39.593124.
---0/3204---
Verifying proof:
:= by
  dsimp [bijection]

For theorem:
theorem bijection_natural (A B : C) (X X' : D) (f : (reflector i).obj (A ⨯ B) ⟶ X) (g : X ⟶ X') :
    bijection i _ _ _ (f ≫ g) = bijection i _ _ _ f ≫ g 
Attempt failure.

Working on Mathlib/CategoryTheory/Closed/Monoidal.lean - 2024-08-20 15:22:41.948216.
---0/3204---
Verifying proof:
:=
  unit_Conjugates _ _ ((tensoringLeft C).map f) X

For theorem:
theorem coev_app_comp_pre_app (f : B ⟶ A) :
    (ihom.coev A).app X ≫ (pre f).app (A ⊗ X) = (ihom.coev B).app X ≫ (ihom B).map (f ▷ _) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  Conjugates_counit _ _ ((tensoringLeft C).map f)

For theorem:
theorem id_tensor_pre_app_comp_ev (f : B ⟶ A) (X : C) :
    B ◁ (pre f).app X ≫ (ihom.ev B).app X = f ▷ (A ⟶[C] X) ≫ (ihom.ev A).app X 
Attempt failure.

Working on Mathlib/CategoryTheory/CofilteredSystem.lean - 2024-08-20 15:22:47.308099.
---0/3204---
Verifying proof:
:= fun x => by
  let s : Set (F.obj i) := {x}
  haveI := F.toPreimages_nonempty_of_surjective s
  haveI := F.toPreimages_nonempty_of_surjective s

For theorem:
theorem eval_section_surjective_of_surjective (i : J) :
    (fun s : F.sections => s.val i).Surjective 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  haveI : ∀ j, Finite (F.obj j) := fun j => by
    intro j
    obtain ⟨j⟩ := hf j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    obtain ⟨j⟩ := hne j
    o

For theorem:
theorem nonempty_sections_of_finite_cofiltered_system.init {J : Type u} [SmallCategory J]
    [IsCofilteredOrEmpty J] (F : J ⥤ Type u) [hf : ∀ j, Finite (F.obj j)]
    [hne : ∀ j, Nonempty (F.obj j)] : F.sections.Nonempty 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro j
  obtain ⟨i, hi, hf⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ := h j
  obtain ⟨j, hj⟩ :=

For theorem:
theorem isMittagLeffler_of_exists_finite_range
    (h : ∀ j : J, ∃ (i : _) (f : i ⟶ j), (range <| F.map f).Finite) : F.IsMittagLeffler 
Attempt failure.

Working on Mathlib/CategoryTheory/Comma/Presheaf.lean - 2024-08-20 15:22:57.047543.
---0/3204---
Verifying proof:
:= by
  simp only [counitForward, OverArrows.map₂_apply, OverArrows.map₂_apply]

For theorem:
lemma counitForward_naturality₂ (s t : (CostructuredArrow yoneda A)ᵒᵖ) (f : t ⟶ s) (x : F.obj t) :
    counitForward F s.unop (F.map f x) =
      OverArrows.map₂ (counitForward F t.unop x) f.unop.left (by simp) 
Attempt failure.

Working on Mathlib/CategoryTheory/ComposableArrows.lean - 2024-08-20 15:23:11.189462.
---0/3204---
Verifying proof:
:= by
  simp only [eqToHom_trans, eqToHom_refl, Category.assoc, eqToHom_refl, Category.comp_id]

For theorem:
lemma ext_succ {F G : ComposableArrows C (n + 1)} (h₀ : F.obj' 0 = G.obj' 0)
    (h : F.δ₀ = G.δ₀) (w : F.map' 0 1 = eqToHom h₀ ≫ G.map' 0 1 ≫
      eqToHom (Functor.congr_obj h.symm 0)): F = G 
Attempt failure.

Working on Mathlib/CategoryTheory/Elements.lean - 2024-08-20 15:24:03.976473.
---0/3204---
Verifying proof:
:= by
  refine Functor.ext?_?_
  · intro X
    exact Functor.ext _ _
  · intro X
    exact Functor.ext _ _
  · intro X
    exact Functor.ext _ _
  · intro X
    exact Functor.ext _ _
  · intro X
    exact Functor.ext _ _
  · intro X
    exact Functor.ext _ _
  · intro X
    exact Functor.ext _ _
  · intro X
    exact Functor.ext _ _
  · intro X
    exact Functor.ext _ _
  · intro X
    exact Functor.ext _ _
  · intro X
    exact Functor.ext _ _
    exact Functor.ext _ _
  · intro X
    exact Functor.fromCostructuredArrow F

For theorem:
theorem from_toCostructuredArrow_eq (F : Cᵒᵖ ⥤ Type v) :
    (toCostructuredArrow F).rightOp ⋙ fromCostructuredArrow F = 𝟭 _ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases x
  cases x
  cases y
  cases y
  cases y
  cases y
  cases y
  cases h₁
  simp only [eqToHom_refl, Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id',
    Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id',
    Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id',
    Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id',
    Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id',
    Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id',
    Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id',
    Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id',
    Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id',
    Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id', Functor.map_id',
    Functor.map_id', Functor.map_id', 

For theorem:
lemma Functor.Elements.ext {F : C ⥤ Type w} (x y : F.Elements) (h₁ : x.fst = y.fst)
    (h₂ : F.map (eqToHom h₁) x.snd = y.snd) : x = y 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Functor.ext?_?_
  · intro X
    exact Functor.fromCostructuredArrow F

For theorem:
theorem from_toCostructuredArrow_eq (F : Cᵒᵖ ⥤ Type v) :
    (toCostructuredArrow F).rightOp ⋙ fromCostructuredArrow F = 𝟭 _ 
Attempt failure.

Working on Mathlib/CategoryTheory/EqToHom.lean - 2024-08-20 15:24:43.468745.
---0/3204---
Verifying proof:
:= by
  match F with
  | 0 => simp only [Functor.map_zero]
  | 1 => simp only [Functor.map_zero]
  | 1 => simp only [Functor.map_comp, eqToHom_trans, eqToHom_refl, Category.assoc,
    Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp,
    Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp,
    Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp,
    Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp,
    Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp,
    Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp,
    Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp,
    Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp,
    Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_comp, Functor.map_com

For theorem:
theorem ext {F G : C ⥤ D} (h_obj : ∀ X, F.obj X = G.obj X)
    (h_map : ∀ X Y f,
      F.map f = eqToHom (h_obj X) ≫ G.map f ≫ eqToHom (h_obj Y).symm := by aesop_cat) :
    F = G 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  subst w
  subst w
  subst w
  subst w
  simp [w]

For theorem:
theorem eqToHom_iso_hom_naturality {f g : β → C} (z : ∀ b, f b ≅ g b) {j j' : β} (w : j = j') :
    (z j).hom ≫ eqToHom (by simp [w]) = eqToHom (by simp [w]) ≫ (z j').hom 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases p
  simp
  simp

For theorem:
theorem congrArg_cast_hom_left {X Y Z : C} (p : X = Y) (q : Y ⟶ Z) :
    cast (congrArg (fun W : C => W ⟶ Z) p.symm) q = eqToHom p ≫ q 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases p
  simp [eq_mpr_eq_cast]

For theorem:
theorem congrArg_mpr_hom_left {X Y Z : C} (p : X = Y) (q : Y ⟶ Z) :
    (congrArg (fun W : C => W ⟶ Z) p).mpr q = eqToHom p ≫ q 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases p
  simp
  simp

For theorem:
theorem congrArg_mpr_hom_left {X Y Z : C} (p : X = Y) (q : Y ⟶ Z) :
    (congrArg (fun W : C => W ⟶ Z) p).mpr q = eqToHom p ≫ q 
Attempt failure.

Working on Mathlib/CategoryTheory/Equivalence.lean - 2024-08-20 15:24:56.048228.
---0/3204---
Verifying proof:
:= by
  rw [← id_comp (e.inverse.map _), ← map_id e.inverse]

For theorem:
theorem unit_inverse_comp (e : C ≌ D) (Y : D) :
    e.unit.app (e.inverse.obj Y) ≫ e.inverse.map (e.counit.app Y) = 𝟙 (e.inverse.obj Y) 
Attempt failure.

Working on Mathlib/CategoryTheory/EssentiallySmall.lean - 2024-08-20 15:25:07.779768.
---0/3204---
Verifying proof:
:= by
  intro h
  fconstructor
  · intro h
    fconstructor
    · rcases h with ⟨h₁, h₂⟩
      rcases h with ⟨h₁, h₂⟩
      exact ⟨h₁, h₂⟩

For theorem:
theorem essentiallySmall_iff (C : Type u) [Category.{v} C] :
    EssentiallySmall.{w} C ↔ Small.{w} (Skeleton C) ∧ LocallySmall.{w} C := by
    fconstructor
Attempt failure.

Working on Mathlib/CategoryTheory/Extensive.lean - 2024-08-20 15:25:10.235935.
---0/3204---
Verifying proof:
:= by
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks_of_isColimit F hc i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : Finite ι := FinitaryPreExtensive.hasPullbacks F i
  haveI : FinitaryPreExte

For theorem:
lemma FinitaryPreExtensive.hasPullbacks_of_is_coproduct [FinitaryPreExtensive C] {ι : Type*}
    [Finite ι] {F : Discrete ι ⥤ C} {c : Cocone F} (hc : IsColimit c) (i : Discrete ι) {X : C}
    (g : X ⟶ _) : HasPullback g (c.ι.app i) 
Attempt failure.

Working on Mathlib/CategoryTheory/FiberedCategory/HomLift.lean - 2024-08-20 15:25:16.122661.
---0/3204---
Verifying proof:
:=
  Functor.IsHomLift.domain_eq f φ

For theorem:
lemma domain_eq : p.obj a = R 
Attempt failure.

Working on Mathlib/CategoryTheory/Filtered/Basic.lean - 2024-08-20 15:25:18.229115.
---0/3204---
Verifying proof:
:= by
  obtain ⟨S, T⟩ := sup_exists.mp ⟨S, T⟩
  obtain ⟨S, T⟩ := sup_exists.mp ⟨S, T⟩
  obtain ⟨S, T⟩ := sup_exists.mp ⟨S, T⟩
  obtain ⟨T₁, T₂, T₃, T₂, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₁, T₂, T₃, T₃, T₃, T₃, T₃, T₃, T₁, T₂, T₃, T₃, T₃, T₁, T₂, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₁, T₂, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₁, T₂, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₁, T₂, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₁, T₂, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₂, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T₃, T

For theorem:
theorem sup_exists :
    ∃ (S : C) (T : ∀ {X : C}, X ∈ O → (X ⟶ S)),
      ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : X ⟶ Y},
        (⟨X, Y, mX, mY, f⟩ : Σ' (X Y : C) (_ : X ∈ O) (_ : Y ∈ O), X ⟶ Y) ∈ H →
          f ≫ T mY = T mX 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mX, mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
  obtain ⟨S, T', mY, f⟩ := inf_exists X Y
 

For theorem:
theorem inf_exists :
    ∃ (S : C) (T : ∀ {X : C}, X ∈ O → (S ⟶ X)),
      ∀ {X Y : C} (mX : X ∈ O) (mY : Y ∈ O) {f : X ⟶ Y},
        (⟨X, Y, mX, mY, f⟩ : Σ' (X Y : C) (_ : X ∈ O) (_ : Y ∈ O), X ⟶ Y) ∈ H →
          T mX ≫ f = T mY 
Attempt failure.

Working on Mathlib/CategoryTheory/GradedObject/Associator.lean - 2024-08-20 15:25:33.268430.
---0/3204---
Verifying proof:
:= by
  dsimp [ιMapBifunctorBifunctor₂₃MapObj]
  simp only [ιMapBifunctorBifunctor₂₃MapObj_id, ι_mapBifunctorAssociator₂₃MapObj_id,
    ι_mapBifunctorAssociator₂₃MapObj_id, ι_mapBifunctorAssociator₂₃MapObj_id,
    ι_mapBifunctorAssociator₂₃MapObj_id, ι_mapBifunctorAssociator₂₃MapObj_id,
    ι_mapBifunctorAssociator₂₃MapObj_id, ι_mapBifunctorAssociator₂₃MapObj_id,
    ι_mapBifunctorAssociator₂₃MapObj_id, ι_mapBifunctorAssociator₂₃MapObj_id,
    ι_mapBifunctorAssociator₂₃MapObj_id, ι_mapBifunctorAssociator₂₃MapObj_id,
    ι_mapBifunctorAssociator₂₃MapObj_id, ι_mapBifunctorAssociator₂₃MapObj_id,
    ι_mapBifunctorAssociator₂₃MapObj_id, ι_mapBifunctorAssociator₂₃MapObj_id,
    ι_mapBifunctorAssociator₂₃MapObj_id, ι_mapBifunctorAssociator₂₃MapObj_id,
    ι_mapBifunctorAssociator₂₃MapObj_id, ι_mapBifunctorAssociator₂₃MapObj_id,
    ι_mapBifunctorAssociator₂₃MapObj_id, ι_mapBifunctorAssociator₂₃MapObj_

For theorem:
lemma ι_mapBifunctorAssociator_inv (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J) (h : r (i₁, i₂, i₃) = j) :
    ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h ≫
      (mapBifunctorAssociator associator ρ₁₂ ρ₂₃ X₁ X₂ X₃).inv j =
    ((associator.inv.app (X₁ i₁)).app (X₂ i₂)).app (X₃ i₃) ≫
      ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h 
Attempt failure.

Working on Mathlib/CategoryTheory/Idempotents/Basic.lean - 2024-08-20 15:25:38.003466.
---0/3204---
Verifying proof:
:= by
  rw [isIdempotentComplete_iff_isIdempotents_hasKernel]
  refine ⟨fun h X p hp =>?_, fun h X p hp =>?_⟩
  · intro h X p hp
    exact h X p hp
  · intro X p hp
    exact h X p hp
  · intro X p hp
    obtain ⟨X, hX⟩ := h X p hp
    obtain ⟨X, hX⟩ := h X p hp
    refine ⟨fun h X p hp =>?_, fun h X p hp =>?_⟩
  · intro X p hp
    exact ⟨fun h X p hp => h X p hp, fun h X p hp => h X p hp⟩

For theorem:
theorem isIdempotentComplete_iff_idempotents_have_kernels [Preadditive C] :
    IsIdempotentComplete C ↔ ∀ (X : C) (p : X ⟶ X), p ≫ p = p → HasKernel p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · exact Equivalence.isIdempotentComplete

For theorem:
theorem isIdempotentComplete_iff_of_equivalence {D : Type*} [Category D] (ε : C ≌ D) :
    IsIdempotentComplete C ↔ IsIdempotentComplete D 
Attempt failure.

Working on Mathlib/CategoryTheory/Idempotents/FunctorExtension.lean - 2024-08-20 15:25:44.350233.
---0/3204---
Verifying proof:
:= by
  rw [← φ.naturality, ← assoc, ← G.map_comp]

For theorem:
theorem natTrans_eq {F G : Karoubi C ⥤ D} (φ : F ⟶ G) (P : Karoubi C) :
    φ.app P = F.map (decompId_i P) ≫ φ.app P.X ≫ G.map (decompId_p P) 
Attempt failure.

Working on Mathlib/CategoryTheory/IsConnected.lean - 2024-08-20 15:26:03.635586.
---0/3204---
Verifying proof:
:= by
  let aux := fun j₁ j₂ => j₁ ≫ j₂
  let aux := fun j₁ j₂ => j₁ ≫ j₂
  let aux := fun j₁ j₂ => j₁ ≫ j₂
  have hj₁ : j₁ ≫ j₂ ≫ j₂ ≫ j₂ := by
    rw [← h1 j₁, ← h1 j₂, ← h1 j₂]
    exact h1 j₁ j₂ h0

For theorem:
theorem induct_on_objects [IsPreconnected J] (p : Set J) {j₀ : J} (h0 : j₀ ∈ p)
    (h1 : ∀ {j₁ j₂ : J} (_ : j₁ ⟶ j₂), j₁ ∈ p ↔ j₂ ∈ p) (j : J) : j ∈ p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let aux := fun j₁ j₂ => j₁ ≫ j₂
  let aux := fun j₁ j₂ => j₁ ≫ j₂
  let aux := fun j₁ j₂ => j₁ ≫ j₂
  have hj₁ : j₁ ≫ j₂ ≫ j₂ ≫ j₂ := by
    rw [← h1 j₁, ← h1 j₂, ← h1 j₂]
    exact h1 j₁ j₂ h0

For theorem:
theorem induct_on_objects [IsPreconnected J] (p : Set J) {j₀ : J} (h0 : j₀ ∈ p)
    (h1 : ∀ {j₁ j₂ : J} (_ : j₁ ⟶ j₂), j₁ ∈ p ↔ j₂ ∈ p) (j : J) : j ∈ p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply zigzag_isConnected
  intro j₁ j₂
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with ⟨l, hl, rfl⟩
  rcases h j₁ j₂ with 

For theorem:
theorem isConnected_of_zigzag [Nonempty J] (h : ∀ j₁ j₂ : J, ∃ l,
    List.Chain Zag j₁ l ∧ List.getLast (j₁ :: l) (List.cons_ne_nil _ _) = j₂) :
    IsConnected J 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let aux := fun j₁ j₂ => j₁ ≫ j₂
  let aux := fun j₁ j₂ => j₁ ≫ j₂
  let aux := fun j₁ j₂ => j₁ ≫ j₂
  have hj₁ : j₁ ≫ j₂ ≫ j₂ ≫ j₂ := by
    rw [← h1 j₁, ← h1 j₂, ← h1 j₂]
    exact h1 j₁ j₂ h0

For theorem:
theorem induct_on_objects [IsPreconnected J] (p : Set J) {j₀ : J} (h0 : j₀ ∈ p)
    (h1 : ∀ {j₁ j₂ : J} (_ : j₁ ⟶ j₂), j₁ ∈ p ↔ j₂ ∈ p) (j : J) : j ∈ p 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Constructions/EpiMono.lean - 2024-08-20 15:26:21.982271.
---0/3204---
Verifying proof:
:= by
  have := isLimitPullbackConeMapOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimit f)))
    (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimit f)))
    (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimit f)))
    (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimit f)))
    (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimit f)))
    (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimit f)))
    (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.isLimitOfIsLimit F _ (PullbackCone.i

For theorem:
theorem preserves_mono_of_preservesLimit {X Y : C} (f : X ⟶ Y) [PreservesLimit (cospan f f) F]
    [Mono f] : Mono (F.map f) 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Constructions/LimitsOfProductsAndEqualizers.lean - 2024-08-20 15:26:23.713850.
---0/3204---
Verifying proof:
:=
  { has_limits_of_shape := fun _ _ => { has_limit := fun _ _ => hasLimit := fun _ _ => hasLimit_of_isLimit _ _ }

For theorem:
theorem has_limits_of_hasEqualizers_and_products [HasProducts.{w} C] [HasEqualizers C] :
    HasLimitsOfSize.{w, w} C 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Constructions/Pullbacks.lean - 2024-08-20 15:26:28.183250.
---0/3204---
Verifying proof:
:= by
  rw [← cancel_mono (parallelPair (prod.fst ≫ f) (prod.fst ≫ f)), parallelPair_map_fst,
    parallelPair_map_fst]

For theorem:
theorem hasLimit_cospan_of_hasLimit_pair_of_hasLimit_parallelPair {C : Type u} [𝒞 : Category.{v} C]
    {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z) [HasLimit (pair X Y)]
    [HasLimit (parallelPair (prod.fst ≫ f) (prod.snd ≫ g))] : HasLimit (cospan f g) 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Constructions/WeaklyInitial.lean - 2024-08-20 15:26:29.796997.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun A =>?_⟩
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  obtain ⟨i, ⟨e⟩⟩ := hB A
  ob

For theorem:
theorem has_weakly_initial_of_weakly_initial_set_and_hasProducts [HasProducts.{v} C] {ι : Type v}
    {B : ι → C} (hB : ∀ A : C, ∃ i, Nonempty (B i ⟶ A)) : ∃ T : C, ∀ X, Nonempty (T ⟶ X) 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean - 2024-08-20 15:26:31.070748.
---0/3204---
Verifying proof:
:= by
  classical
    cases nonempty_fintype J
    intro x y h
    obtain ⟨kx, x, rfl⟩ := h
    obtain ⟨kx, x, rfl⟩ := h
    obtain ⟨kx, x, rfl⟩ := h
    obtain ⟨kx, x, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
   

For theorem:
theorem colimitLimitToLimitColimit_injective :
    Function.Injective (colimitLimitToLimitColimit F) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
    cases nonempty_fintype J
    intro x y h
    obtain ⟨kx, x, rfl⟩ := h
    obtain ⟨kx, x, rfl⟩ := h
    obtain ⟨kx, x, rfl⟩ := h
    obtain ⟨kx, x, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
    obtain ⟨ky, y, rfl⟩ := h
   

For theorem:
theorem colimitLimitToLimitColimit_injective :
    Function.Injective (colimitLimitToLimitColimit F) 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Final.lean - 2024-08-20 15:26:35.573110.
---0/3204---
Verifying proof:
:=
  have := StructuredArrow.isEquivalencePost d F G
  isConnected_of_equivalent (StructuredArrow.isEquivalencePost d F G)

For theorem:
theorem final_of_comp_full_faithful [Full G] [Faithful G] [Final (F ⋙ G)] : Final F where
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Fubini.lean - 2024-08-20 15:26:41.023076.
---0/3204---
Verifying proof:
:= by
  dsimp [colimitIsoColimitCurryCompColimitCurryCompColimitCurryCompColimitCurryCompColim]

For theorem:
theorem colimitIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι ((curry.obj G).obj j) k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitIsoColimitCurryCompColim G).inv  = colimit.ι _ (j, k) 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/HasLimits.lean - 2024-08-20 15:26:49.146739.
---0/3204---
Verifying proof:
:= by
  ext1
  simp only [colimit.ι_desc, colimit.ι_desc]

For theorem:
theorem colimit.pre_map' [HasColimitsOfShape K C] (F : J ⥤ C) {E₁ E₂ : K ⥤ J} (α : E₁ ⟶ E₂) :
    colimit.pre F E₁ = colim.map (whiskerRight α F) ≫ colimit.pre F E₂ 
Attempt failure.

---0/3204---
Verifying proof:
:=
  HasColimit.mk
  { cocone := (Cocones.precompose α.hom).obj (colimit.cocone F)
    isColimit :=
    { cocone := (Cocones.precompose α.hom).obj (colimit.cocone F) }

For theorem:
theorem hasColimitOfIso {F G : J ⥤ C} [HasColimit F] (α : G ≅ F) : HasColimit G 
Attempt failure.

---0/3204---
Verifying proof:
:=
  HasLimit.mk
  { cone := (Cones.postcompose α.hom).obj (limit.cone F)
    isLimit :=
    { limit.cone := fun s => by
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

For theorem:
theorem hasLimitOfIso {F G : J ⥤ C} [HasLimit F] (α : F ≅ G) : HasLimit G 
Attempt failure.

---0/3204---
Verifying proof:
:=
  ⟨fun J _ => hasLimitsOfShapeOfEquivalence (ULiftHomULiftCategory.equiv.{v₁, v₂} C),
    hasLimitsOfShapeOfEquivalence (ULiftHomULiftCategory.equiv.{v₁, v₂} C)⟩

For theorem:
theorem hasLimitsOfSizeShrink [HasLimitsOfSize.{max v₁ v₂, max u₁ u₂} C] :
    HasLimitsOfSize.{v₁, u₁} C 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Indization/IndObject.lean - 2024-08-20 15:27:32.824207.
---0/3204---
Verifying proof:
:= by
  haveI : IsFiltered (CostructuredArrow yoneda A) :=
    IsFiltered.of_isFiltered_of_isFiltered (CostructuredArrow yoneda A)
  haveI : IsFiltered (CostructuredArrow yoneda A) :=
    IsFiltered.of_isFiltered_of_isFiltered (CostructuredArrow yoneda A)
  haveI : IsFiltered (CostructuredArrow yoneda A) :=
    IsFiltered.of_isFiltered_of_isFiltered (CostructuredArrow yoneda A)
  haveI : IsFiltered (CostructuredArrow yoneda A) :=
    IsFiltered.of_isFiltered_of_isFiltered_of_isFiltered (CostructuredArrow yoneda A)
  haveI : IsFiltered (CostructuredArrow yoneda A) :=
    IsFiltered.of_isFiltered_of_isFiltered (CostructuredArrow yoneda A)

For theorem:
theorem isIndObject_of_isFiltered_of_finallySmall (A : Cᵒᵖ ⥤ Type v)
    [IsFiltered (CostructuredArrow yoneda A)] [FinallySmall.{v} (CostructuredArrow yoneda A)] :
    IsIndObject A 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Lattice.lean - 2024-08-20 15:27:35.406439.
---0/3204---
Verifying proof:
:=
  calc
    Limits.coprod x y = colimit (pair x y) := rfl
    _ = Finset.univ.sup (pair x y) := rfl
  _ = Finset.univ.sup (pair x y) := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
  _ = Finset.univ.sup (pair x y).obj := rfl
 

For theorem:
theorem coprod_eq_sup [SemilatticeSup α] [OrderBot α] (x y : α) : Limits.coprod x y = x ⊔ y 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean - 2024-08-20 15:27:40.353741.
---0/3204---
Verifying proof:
:= by
  simp only [prod.associator_hom, prod.lift_map, prod.lift_map, prod.lift_map, prod.lift_map,
    prod.lift_map, prod.lift_map, prod.lift_map]

For theorem:
theorem prod.pentagon [HasBinaryProducts C] (W X Y Z : C) :
    prod.map (prod.associator W X Y).hom (𝟙 Z) ≫
        (prod.associator W (X ⨯ Y) Z).hom ≫ prod.map (𝟙 W) (prod.associator X Y Z).hom =
      (prod.associator (W ⨯ X) Y Z).hom ≫ (prod.associator W X (Y ⨯ Z)).hom 
Attempt failure.

---0/3204---
Verifying proof:
:= by simp

For theorem:
theorem braid_natural [HasBinaryProducts C] {W X Y Z : C} (f : X ⟶ Y) (g : Z ⟶ W) :
    prod.map f g ≫ (prod.braiding _ _).hom = (prod.braiding _ _).hom ≫ prod.map g f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← cancel_mono (coprod.map (F.map f) (F.map g)), ← F.map_comp, IsIso.inv_hom_id_assoc,
    IsIso.inv_hom_id_assoc, IsIso.inv_hom_id_assoc]

For theorem:
theorem coprodComparison_inv_natural (f : A ⟶ A') (g : B ⟶ B') [IsIso (coprodComparison F A B)]
    [IsIso (coprodComparison F A' B')] :
    inv (coprodComparison F A B) ≫ coprod.map (F.map f) (F.map g) =
      F.map (coprod.map f g) ≫ inv (coprodComparison F A' B') 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/CommSq.lean - 2024-08-20 15:28:33.147204.
---0/3204---
Verifying proof:
:= by
  refine
    IsPullback.of_isLimit' (F.map_commSq s.toCommSq s.toCommSq)
      (F.map_commSq s.toCommSq)
      (F.map_commSq s.toCommSq)
      (F.map_commSq s.toCommSq)
      (F.map_commSq s.toCommS

For theorem:
theorem Functor.map_isPullback [PreservesLimit (cospan h i) F] (s : IsPullback f g h i) :
    IsPullback (F.map f) (F.map g) (F.map h) (F.map i) := by
      refine
    IsPullback.of_isLimit' (F.map_commSq s.toCommSq)
      (IsLimit.equivOfNatIsoOfIso (cospanCompIso F h i) _ _ (WalkingCospan.ext ?_ ?_ ?_)
        (isLimitOfPreserves F s.isLimit))
Attempt failure.

---0/3204---
Verifying proof:
:=
  of_isColimit
    (isPushoutOfIsInitialIsCoproduct _ _ _ _ _ _ t) _ _ _ t.toIsColimit
    (isPushoutOfIsInitialIsCoproduct _ _ _ _ _ t.toIsColimit)

For theorem:
theorem of_is_coproduct {c : BinaryCofan X Y} (h : Limits.IsColimit c) (t : IsInitial Z) :
    IsPushout (t.to _) (t.to _) c.inl c.inr 
Attempt failure.

---0/3204---
Verifying proof:
:=
  { w := by simp }

For theorem:
theorem zero_left (X : C) : IsPullback (0 : 0 ⟶ X) (0 : (0 : C) ⟶ 0) (𝟙 X) (0 : 0 ⟶ X) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  of_isLimit' sq
  (by
    refine
      PullbackCone.IsLimit.mk _ (fun s => s.fst ≫ inv fst) (fun s => s.fst ≫ inv fst)
      (by
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

For theorem:
theorem of_horiz_isIso [IsIso fst] [IsIso g] (sq : CommSq fst snd f g) : IsPullback fst snd f g 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean - 2024-08-20 15:29:05.406162.
---0/3204---
Verifying proof:
:=
  IsIso.of_iso <| IsLimit.conePointUniqueUpToIso h <| isLimitIdFork h₀

For theorem:
theorem isIso_limit_cone_parallelPair_of_eq (h₀ : f = g) {c : Fork f g} (h : IsLimit c) :
    IsIso c.ι 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  | zero => h
  | one => by
    simp only [← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv,
      comp_id, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv,
      comp_id, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv,
      comp_id, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv,
      comp_id, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv,
      comp_id, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv,
      comp_id, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv,
      comp_id, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv,
      comp_id, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv,
      comp_id, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv, ← cancel_mono s.inv,
      comp_

For theorem:
theorem Fork.equalizer_ext (s : Fork f g) {W : C} {k l : W ⟶ s.pt} (h : k ≫ s.ι = l ≫ s.ι) :
    ∀ j : WalkingParallelPair, k ≫ s.π.app j = l ≫ s.π.app j
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.lean - 2024-08-20 15:29:29.193201.
---0/3204---
Verifying proof:
:= fun J hJ hJ

For theorem:
theorem hasFiniteLimits_of_hasFiniteLimits_of_size
    (h : ∀ (J : Type w) {𝒥 : SmallCategory J} (_ : @FinCategory J 𝒥), HasLimitsOfShape J C) :
    HasFiniteLimits C where
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/KernelPair.lean - 2024-08-20 15:29:31.246562.
---0/3204---
Verifying proof:
:= by
  constructor
  · intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ h₂
    rw [← Category.assoc, ← pullback.condition, ← Category.assoc, ← pullback.condition,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condit

For theorem:
theorem pullback {X Y Z A : C} {g : Y ⟶ Z} {a₁ a₂ : A ⟶ Y} (h : IsKernelPair g a₁ a₂)
    (f : X ⟶ Z) [HasPullback f g] [HasPullback f (a₁ ≫ g)] :
    IsKernelPair (pullback.fst : pullback f g ⟶ X)
      (pullback.map f _ f _ (𝟙 X) a₁ (𝟙 Z) (by simp) <| Category.comp_id _)
      (pullback.map _ _ _ _ (𝟙 X) a₂ (𝟙 Z) (by simp) <| (Category.comp_id _).trans h.1.1) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ h₂
    rw [← Category.assoc, ← pullback.condition, ← Category.assoc, ← pullback.condition,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condition_assoc, ← pullback.condition_assoc, ← pullback.condition_assoc,
      pullback.condit

For theorem:
theorem pullback {X Y Z A : C} {g : Y ⟶ Z} {a₁ a₂ : A ⟶ Y} (h : IsKernelPair g a₁ a₂)
    (f : X ⟶ Z) [HasPullback f g] [HasPullback f (a₁ ≫ g)] :
    IsKernelPair (pullback.fst : pullback f g ⟶ X)
      (pullback.map f _ f _ (𝟙 X) a₁ (𝟙 Z) (by simp) <| Category.comp_id _)
      (pullback.map _ _ _ _ (𝟙 X) a₂ (𝟙 Z) (by simp) <| (Category.comp_id _).trans h.1.1) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  { w := comm
    isLimit' :=
    ⟨big_k.isLimit, big_k.isLimit'⟩

For theorem:
theorem cancel_right {f₁ : X ⟶ Y} {f₂ : Y ⟶ Z} (comm : a ≫ f₁ = b ≫ f₁)
    (big_k : IsKernelPair (f₁ ≫ f₂) a b) : IsKernelPair f₁ a b 
Attempt failure.

---0/3204---
Verifying proof:
:=
  { w := comm
    isLimit' :=
    ⟨big_k.isLimit, big_k.isLimit'⟩

For theorem:
theorem cancel_right {f₁ : X ⟶ Y} {f₂ : Y ⟶ Z} (comm : a ≫ f₁ = b ≫ f₁)
    (big_k : IsKernelPair (f₁ ≫ f₂) a b) : IsKernelPair f₁ a b 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean - 2024-08-20 15:29:41.199298.
---0/3204---
Verifying proof:
:= by
  rw [← cancel_epi (cokernel.π f'), ← cancel_mono (cokernel.π f'), ← cancel_mono (cokernel.π f'),
    cokernel.π_desc]

For theorem:
theorem cokernel.map_desc {X Y Z X' Y' Z' : C} (f : X ⟶ Y) [HasCokernel f] (g : Y ⟶ Z)
    (w : f ≫ g = 0) (f' : X' ⟶ Y') [HasCokernel f'] (g' : Y' ⟶ Z') (w' : f' ≫ g' = 0) (p : X ⟶ X')
    (q : Y ⟶ Y') (r : Z ⟶ Z') (h₁ : f ≫ q = p ≫ f') (h₂ : g ≫ r = q ≫ g') :
    cokernel.map f f' p q h₁ ≫ cokernel.desc f' g' w' = cokernel.desc f g w ≫ r 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/Products.lean - 2024-08-20 15:29:55.237018.
---0/3204---
Verifying proof:
:= by
  rw [← Pi.map_comp, ← Pi.map_comp, ← Pi.map_comp]

For theorem:
lemma Pi.map_comp_map {f g h : α → C} [HasProduct f] [HasProduct g] [HasProduct h]
    (q : ∀ (a : α), f a ⟶ g a) (q' : ∀ (a : α), g a ⟶ h a) :
    Pi.map q ≫ Pi.map q' = Pi.map (fun a => q a ≫ q' a) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← colimit.ι_desc_assoc, colimit.ι_desc_assoc]

For theorem:
lemma Sigma.map'_eq {f : α → C} {g : β → C} [HasCoproduct f] [HasCoproduct g]
    {p p' : α → β} {q : ∀ (a : α), f a ⟶ g (p a)} {q' : ∀ (a : α), f a ⟶ g (p' a)}
    (hp : p = p') (hq : ∀ (a : α), q a ≫ eqToHom (hp ▸ rfl) = q' a) :
    Sigma.map' p q = Sigma.map' p' q' 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [Pi.map'_comp, Pi.map'_comp, Pi.map'_comp]
  simp only [Pi.map'_comp, Pi.map'_comp, Pi.map'_comp, Pi.map'_comp, Pi.map'_comp,
    Pi.map'_comp, Pi.map'_comp, Pi.map'_comp, Pi.map'_comp, Pi.map'_comp, Pi.map'_comp,
    Pi.map'_comp, Pi.map'_comp, Pi.map'_comp, Pi.map'_comp, Pi.map'_comp, Pi.map'_comp]

For theorem:
lemma Pi.map'_comp_map {f : α → C} {g h : β → C} [HasProduct f] [HasProduct g] [HasProduct h]
    (p : β → α) (q : ∀ (b : β), f (p b) ⟶ g b) (q' : ∀ (b : β), g b ⟶ h b) :
    Pi.map' p q ≫ Pi.map q' = Pi.map' p (fun b => q b ≫ q' b) 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean - 2024-08-20 15:30:26.215532.
---0/3204---
Verifying proof:
:= by
  rw [← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality,
    ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality,
    ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality,
    ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality,
    ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality,
    ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality,
    ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality,
    ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality,
    ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality,
    ← cancel_mono t.π.naturality, ← cancel_mono t.π.naturality, ← cancel_mono t.

For theorem:
theorem equalizer_ext (t : PullbackCone f g) {W : C} {k l : W ⟶ t.pt} (h₀ : k ≫ fst t = l ≫ fst t)
    (h₁ : k ≫ snd t = l ≫ snd t) : ∀ j : WalkingCospan, k ≫ t.π.app j = l ≫ t.π.app j
Attempt failure.

---0/3204---
Verifying proof:
:=
  ⟨⟨⟨⟨PushoutCocone.mk _ _ pushout.condition.symm,
    PushoutCocone.flipIsColimit (pushoutIsPushout _ _)⟩⟩

For theorem:
theorem hasPushout_symmetry [HasPushout f g] : HasPushout g f 
Attempt failure.

---0/3204---
Verifying proof:
:=
  { HasLimit := fun F => hasLimitOfIso (diagramIsoCospan F).symm }

For theorem:
theorem hasPullbacks_of_hasLimit_cospan
    [∀ {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}, HasLimit (cospan f g)] : HasPullbacks C 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/StrongEpi.lean - 2024-08-20 15:31:42.962322.
---0/3204---
Verifying proof:
:=
  { epi := epi_comp _ _
    llp := by
    intros
    infer_instance
    infer_instance
    infer_instance

For theorem:
theorem strongEpi_comp [StrongEpi f] [StrongEpi g] : StrongEpi (f ≫ g) 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean - 2024-08-20 15:31:46.419624.
---0/3204---
Verifying proof:
:=
  ⟨⟨colimit.desc _ (coconeOfDiagramTerminal I F),
    ⟨by simp, by
      rw [colimit.ι_desc_assoc, colimit.ι_desc_assoc, colimit.ι_desc_assoc]⟩⟩

For theorem:
theorem isIso_ι_of_isTerminal {j : J} (I : IsTerminal j) (F : J ⥤ C) [HasColimit F] :
    IsIso (colimit.ι F j) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  IsColimit.hom_ext t (by dee)

For theorem:
theorem IsInitial.hom_ext {X Y : C} (t : IsInitial X) (f g : X ⟶ Y) : f = g 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/Types.lean - 2024-08-20 15:32:07.233746.
---0/3204---
Verifying proof:
:= by
  rw [← coequalizer.ι_preimage_preimage_eq_of_isColimit π h, H, ← coequalizer.ι_preimage]

For theorem:
theorem coequalizer_preimage_image_eq_of_preimage_eq (π : Y ⟶ Z) (e : f ≫ π = g ≫ π)
    (h : IsColimit (Cofork.ofπ π e)) (U : Set Y) (H : f ⁻¹' U = g ⁻¹' U) : π ⁻¹' (π '' U) = U 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean - 2024-08-20 15:32:13.579110.
---0/3204---
Verifying proof:
:= by
  apply ext_aux
  intro X Y
  have : (I.zero X Y).zero ≫ (J.zero Y Y).zero = (I.zero X Y).zero := by simp
  have : (I.zero X Y).zero ≫ (J.zero Y Y).zero = (I.zero X Y).zero := by simp
  have : (I.zero X Y).zero ≫ (J.zero Y Y).zero = (I.zero X Y).zero := by simp
  have : (I.zero X Y).zero ≫ (J.zero Y Y).zero = (I.zero X Y).zero := by simp
  have : (I.zero X Y).zero ≫ (J.zero Y Y).zero = (I.zero X Y).zero := by simp
  have : (I.zero X Y).zero ≫ (J.zero Y Y).zero = (I.zero X Y).zero := by simp
  have : (I.zero X Y).zero ≫ (J.zero Y Y).zero = (I.zero X Y).zero := by simp
  have : (I.zero X Y).zero ≫ (J.zero Y Y).zero = (I.zero X Y).zero := by simp
  have : (I.zero X Y).zero ≫ (J.zero Y Y).zero = (I.zero X Y).zero := by simp
  have : (I.zero X Y).zero ≫ (J.zero Y Y).zero = (I.zero X Y).zero := by simp
  have : (I.zero X Y).zero ≫ (J.zero Y Y).zero = (I.zero X Y).zero := by simp
  have : (I.zero X Y).zero ≫ (J.zero Y Y).zero = (I.zero X Y).zero := by simp
  have : (I.zero X Y).zero 

For theorem:
theorem ext (I J : HasZeroMorphisms C) : I = J 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply ext_aux
  intro X Y
  have : (I.zero X Y).zero ≫ (J.zero Y Y).zero = (I.zero X Y).zero := by
    apply I.zero_comp X (J.zero Y Y).zero
    simp only [zero_comp, comp_zero]

For theorem:
theorem ext (I J : HasZeroMorphisms C) : I = J 
Attempt failure.

Working on Mathlib/CategoryTheory/Limits/VanKampen.lean - 2024-08-20 15:32:19.299042.
---0/3204---
Verifying proof:
:= by
  refine PullbackCone.mono_of_isLimitMkIdId _ (IsPullback.of_isLimitMkIdId _ (IsPullback.of_hasPullback _ _))
    (IsPullback.of_isLimitMkIdId _ (IsPullback.of_hasPullback _ _))

For theorem:
theorem BinaryCofan.mono_inr_of_isVanKampen [HasInitial C] {X Y : C} {c : BinaryCofan X Y}
    (h : IsVanKampenColimit c) : Mono c.inr 
Attempt failure.

---0/3204---
Verifying proof:
:=
  hasStrictInitialObjects_of_initialObjects C

For theorem:
theorem hasStrictInitial_of_isUniversal [HasInitial C]
    (H : IsUniversalColimit (BinaryCofan.mk (𝟙 (⊥_ C)) (𝟙 (⊥_ C)))) : HasStrictInitialObjects C 
Attempt failure.

Working on Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean - 2024-08-20 15:32:36.172158.
---0/3204---
Verifying proof:
:= by
  have := hL _ hs
  rw [← cancel_mono (ofInv s hs).hom, ← cancel_mono (ofInv s hs).hom, ← cancel_mono (ofInv s hs).hom,
    ← cancel_mono (ofInv s hs).hom, ← cancel_mono (ofInv s hs).hom, ← cancel_mono (ofInv s hs).hom,
    ← Functor.map_comp, ← Functor.map_comp, ← Functor.map_comp, ← Functor.map_comp,
    Functor.map_comp, Functor.map_id, comp_id]

For theorem:
lemma map_hom_ofInv_id (s : Y ⟶ X) (hs : W s) (L : C ⥤ D) (hL : W.IsInvertedBy L) :
    L.map s ≫ (ofInv s hs).map L hL = 𝟙 _ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let hobj : ∀ X : C, F₁.obj X = F₂.obj X := fun X => Functor.congr_obj h X

For theorem:
lemma uniq (F₁ F₂ : Localization W ⥤ E) (h : Q W ⋙ F₁ = Q W ⋙ F₂) : F₁ = F₂ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have := hL _ φ.hs
  have := hL _ φ.hs
  rw [← cancel_mono (L.map φ.f), ← L.map_comp, ← L.map_comp, ← L.map_comp,
    ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp,
    ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp,
    ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp,
    ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp,
    ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp,
    ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp,
    ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp,
    ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp,
    ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp,
    ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp, ← L.map_comp,
    ← L.map_comp, ← L.map_comp, ← L.map_comp,

For theorem:
lemma map_s_comp_map (φ : W.RightFraction X Y) (L : C ⥤ D) (hL : W.IsInvertedBy L) :
    L.map φ.s ≫ φ.map L hL = L.map φ.f 
Attempt failure.

Working on Mathlib/CategoryTheory/Localization/CalculusOfFractions/Fractions.lean - 2024-08-20 15:32:49.635900.
---0/3204---
Verifying proof:
:= by
  obtain ⟨φ, hφ⟩ := exists_leftFraction₂ L W
  refine ⟨φ.fst.map L (inverts L W),?_,?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
  · exact ⟨φ.fst.map L (inverts L W),?_,?_,?_⟩
    ·

For theorem:
lemma exists_leftFraction₃ {X Y : C} (f f' f'' : L.obj X ⟶ L.obj Y) :
    ∃ (φ : W.LeftFraction₃ X Y), f = φ.fst.map L (inverts L W) ∧
      f' = φ.snd.map L (inverts L W) ∧
      f'' = φ.thd.map L (inverts L W) 
Attempt failure.

Working on Mathlib/CategoryTheory/Localization/Predicate.lean - 2024-08-20 15:32:51.031596.
---0/3204---
Verifying proof:
:= by
  have h : W.IsInvertedBy L' := by
    have h : W.IsInvertedBy L' := by
      have h : W.IsInvertedBy L' := by
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

For theorem:
theorem of_equivalence_target {E : Type*} [Category E] (L' : C ⥤ E) (eq : D ≌ E)
    [L.IsLocalization W] (e : L ⋙ eq.functor ≅ L') : L'.IsLocalization W 
Attempt failure.

Working on Mathlib/CategoryTheory/Localization/Triangulated.lean - 2024-08-20 15:32:55.039518.
---0/3204---
Verifying proof:
:= by
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain ⟨Y, ⟨e⟩⟩ := L.essImageDistTriang_surjective X
  obtain 

For theorem:
lemma contractible_mem_essImageDistTriang [EssSurj L] [HasZeroObject D]
    [HasZeroMorphisms D] [L.PreservesZeroMorphisms] (X : D) :
    contractibleTriangle X ∈ L.essImageDistTriang 
Attempt failure.

Working on Mathlib/CategoryTheory/Monoidal/Bimod.lean - 2024-08-20 15:32:58.384480.
---0/3204---
Verifying proof:
:= by
  dsimp [associatorBimod]

For theorem:
theorem whisker_assoc_bimod {W X Y Z : Mon_ C} (M : Bimod W X) {N N' : Bimod X Y} (f : N ⟶ N')
    (P : Bimod Y Z) :
    whiskerRight (whiskerLeft M f) P =
      (associatorBimod M N P).hom ≫
        whiskerLeft M (whiskerRight f P) ≫ (associatorBimod M N' P).inv 
Attempt failure.

Working on Mathlib/CategoryTheory/Monoidal/Braided/Basic.lean - 2024-08-20 15:33:01.578846.
---0/3204---
Verifying proof:
:= by
  dsimp [tensorHom, tensorHom, tensorHom, tensorHom]

For theorem:
theorem leftUnitor_monoidal (X₁ X₂ : C) :
    (λ_ X₁).hom ⊗ (λ_ X₂).hom =
      tensor_μ C (𝟙_ C, X₁) (𝟙_ C, X₂) ≫ ((λ_ (𝟙_ C)).hom ▷ (X₁ ⊗ X₂)) ≫ (λ_ (X₁ ⊗ X₂)).hom 
Attempt failure.

Working on Mathlib/CategoryTheory/Monoidal/Category.lean - 2024-08-20 15:33:20.695580.
---0/3204---
Verifying proof:
:= by
  rw [← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv,
    ← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv,
    ← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv,
    ← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv,
    ← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv,
    ← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv,
    ← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv,
    ← cancel_mono (α_ W X (Y ⊗ Z)).inv, ← cancel_mono (α_ W X (Y ⊗ Z)).inv,
    ← cancel_mono (α_ W X (Y ⊗ Z)).

For theorem:
theorem pentagon_hom_inv_inv_inv_inv :
    W ◁ (α_ X Y Z).hom ≫ (α_ W X (Y ⊗ Z)).inv ≫ (α_ (W ⊗ X) Y Z).inv =
      (α_ W (X ⊗ Y) Z).inv ≫ (α_ W X Y).inv ▷ Z 
Attempt failure.

Working on Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean - 2024-08-20 15:33:23.650852.
---0/3204---
Verifying proof:
:= by
  rw [rightAdjointMate_comp]
  simp

For theorem:
theorem comp_rightAdjointMate {X Y Z : C} [HasRightDual X] [HasRightDual Y] [HasRightDual Z]
    {f : X ⟶ Y} {g : Y ⟶ Z} : (f ≫ g)ᘁ = gᘁ ≫ fᘁ 
Attempt failure.

Working on Mathlib/CategoryTheory/MorphismProperty/Basic.lean - 2024-08-20 15:33:36.593919.
---0/3204---
Verifying proof:
:= by
  apply subset_antisymm
  apply subset_antisymm

For theorem:
lemma inverseImage_equivalence_inverse_eq_map_functor
    (P : MorphismProperty D) (hP : RespectsIso P) (E : C ≌ D) :
    P.inverseImage E.functor = P.map E.inverse 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply subset_antisymm
  · rw [map_subset_iff _ _ _ P.isoClosure_respectsIso]
    intro X Y f hf
    exact hf

For theorem:
lemma map_id_eq_isoClosure (P : MorphismProperty C) :
    P.map (𝟭 _) = P.isoClosure 
Attempt failure.

Working on Mathlib/CategoryTheory/NatIso.lean - 2024-08-20 15:33:39.783019.
---0/3204---
Verifying proof:
:=
  ⟨(IsIso.of_iso (ofComponents (fun X => asIso (α.app X)) (by aesop)).1⟩

For theorem:
theorem isIso_of_isIso_app (α : F ⟶ G) [∀ X : C, IsIso (α.app X)] : IsIso α 
Attempt failure.

---0/3204---
Verifying proof:
:=
  ⟨(IsIso.of_iso (ofComponents (fun X => asIso (α.app X)) (by aesop)).1⟩

For theorem:
theorem isIso_of_isIso_app (α : F ⟶ G) [∀ X : C, IsIso (α.app X)] : IsIso α 
Attempt failure.

Working on Mathlib/CategoryTheory/Preadditive/AdditiveFunctor.lean - 2024-08-20 15:33:42.936410.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun h =>?_⟩
  · intro h
    simp only [Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj,
      Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_map,
      Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj,
      Functor.comp_obj, Functor.comp_obj, Functor.comp_map, Functor.comp_obj, Functor.comp_obj,
      Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_map,
      Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj,
      Functor.comp_obj, Functor.comp_obj, Functor.comp_map, Functor.comp_obj, Functor.comp_obj,
      Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj,
      Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj,
      Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj,
      Functor.comp_obj, Functor

For theorem:
lemma additive_of_iso {G : C ⥤ D} (e : F ≅ G) : G.Additive 
Attempt failure.

Working on Mathlib/CategoryTheory/Preadditive/HomOrthogonal.lean - 2024-08-20 15:33:45.239095.
---0/3204---
Verifying proof:
:= by
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin α
  obtain ⟨e, he⟩ := Finite.exists_equiv_fin 

For theorem:
theorem equiv_of_iso (o : HomOrthogonal s) {α β : Type} [Finite α] [Finite β] {f : α → ι}
    {g : β → ι} (i : (⨁ fun a => s (f a)) ≅ ⨁ fun b => s (g b)) :
    ∃ e : α ≃ β, ∀ a, g (e a) = f a 
Attempt failure.

Working on Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean - 2024-08-20 15:33:47.662830.
---0/3204---
Verifying proof:
:= by
  rw [← quasiIsoAt_iff_exactAt I.ι (n + 1) (exactAt_succ_single_obj _ _)]
  · infer_instance
  · infer_instance

For theorem:
lemma cocomplex_exactAt_succ (n : ℕ) :
    I.cocomplex.ExactAt (n + 1) 
Attempt failure.

Working on Mathlib/CategoryTheory/Preadditive/Mat.lean - 2024-08-20 15:33:53.151447.
---0/3204---
Verifying proof:
:= by
  dsimp [additiveObjIsoBiproduct, additiveObjIsoBiproduct]

For theorem:
lemma additiveObjIsoBiproduct_hom_π (F : Mat_ C ⥤ D) [Functor.Additive F] (M : Mat_ C) (i : M.ι) :
    (additiveObjIsoBiproduct F M).hom ≫ biproduct.π _ i =
      F.map (M.isoBiproductEmbedding.hom ≫ biproduct.π _ i) 
Attempt failure.

Working on Mathlib/CategoryTheory/Preadditive/Schur.lean - 2024-08-20 15:33:57.857826.
---0/3204---
Verifying proof:
:=
  haveI :=
    subsingleton_of_subsingleton 𝕜 (X ≫ Y)
  haveI :=
    subsingleton_of_subsingleton 𝕜 (X ≫ Y)
  haveI :=
    subsingleton_of_subsingleton 𝕜 (X ≫ Y)
  haveI : Subsingleton (X ≫ Y) := Subsingleton.elim _ _
  haveI : Subsingleton (X ≫ Y) := Subsingleton.elim _ _
  haveI : Subsingleton (X ≫ Y) := Subsingleton.elim _ _
  haveI : Subsingleton (X ≫ Y) := Subsingleton.elim _ _
  haveI : Subsingleton (X ≫ Y) := Subsingleton.elim _ _
  haveI : Subsingleton (X ≫ Y) := Subsingleton.elim _ _
  haveI : Subsingleton (X ≫ Y) := Subsingleton.elim _ _
  haveI : Subsingleton (X ≫ Y) := Subsingleton.elim _ _
  haveI : Subsingleton (X ≫ Y) := Subsingleton.elim _ _
  haveI : Subsingleton (X ≫ Y) := Subsingleton.elim _ _
  haveI : Subsingleton (X ≫ Y) := Subsingleton.elim _ _
  haveI : Subsingleton (X ≫ Y) := Subsingleton.elim _ _
  haveI : Subsingleton (X ≫ Y) := Subsingleton.elim _ _
  haveI : Subsingleton (X ≫ Y) := Subsingleton.elim _ _
  haveI : Subsingleton (X ≫ Y

For theorem:
theorem finrank_hom_simple_simple_eq_zero_of_not_iso [HasKernels C] [Linear 𝕜 C] {X Y : C}
    [Simple X] [Simple Y] (h : (X ≅ Y) → False) : finrank 𝕜 (X ⟶ Y) = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have id_nonzero : ∀ f : X ⟶ X, IsIso f ↔ f ≠ 0 := fun f => by
    intro f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzero f
    obtain ⟨f, rfl⟩ := isIso_iff_nonzer

For theorem:
theorem finrank_endomorphism_eq_one {X : C} (isIso_iff_nonzero : ∀ f : X ⟶ X, IsIso f ↔ f ≠ 0)
    [I : FiniteDimensional 𝕜 (X ⟶ X)] : finrank 𝕜 (X ⟶ X) = 1 
Attempt failure.

Working on Mathlib/CategoryTheory/Preadditive/Yoneda/Basic.lean - 2024-08-20 15:34:02.569217.
---0/3204---
Verifying proof:
  (whiskeringRight C AddCommGrp (Type v))).obj (whiskeringRight C AddCommGrp (Type v)) =
    (whiskeringRight C AddCommGrp (Type v)).obj (whiskeringRight C AddCommGrp (Type v))).obj (whiskeringRight C AddCommGrp (Type v))

For theorem:
theorem whiskering_preadditiveCoyoneda :
    preadditiveCoyoneda ⋙
        (whiskeringRight C AddCommGrp (Type v)).obj (forget AddCommGrp) =
      coyoneda 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext x
  simp only [Functor.comp_obj, Functor.op_obj, Functor.comp_obj, Functor.comp_map,
    Functor.comp_obj, Functor.comp_obj, Functor.comp_map, Functor.comp_obj, Functor.comp_obj,
    Functor.comp_obj, Functor.comp_obj, Functor.comp_map, Functor.comp_obj, Functor.comp_obj,
    Functor.comp_obj, Functor.comp_obj, Functor.comp_map, Functor.comp_obj, Functor.comp_obj,
    Functor.comp_obj, Functor.comp_map, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj,
    Functor.comp_obj, Functor.comp_obj, Functor.comp_map, Functor.comp_obj, Functor.comp_obj,
    Functor.comp_obj, Functor.comp_map, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj,
    Functor.comp_obj, Functor.comp_obj, Functor.comp_map, Functor.comp_obj, Functor.comp_obj,
    Functor.comp_obj, Functor.comp_map, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj,
    Functor.comp_obj, Functor.comp_obj, Functor.comp_map, Functor.comp_obj, Functor.comp_obj,
    Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Functor.comp_obj, Func

For theorem:
theorem whiskering_preadditiveYoneda :
    preadditiveYoneda ⋙
        (whiskeringRight Cᵒᵖ AddCommGrp (Type v)).obj (forget AddCommGrp) =
      yoneda 
Attempt failure.

Working on Mathlib/CategoryTheory/Preadditive/Yoneda/Injective.lean - 2024-08-20 15:34:09.178748.
---0/3204---
Verifying proof:
:= by
  rw [injective_iff_preservesEpimorphisms_yoneda_obj]

For theorem:
theorem injective_iff_preservesEpimorphisms_preadditiveYoneda_obj (J : C) :
    Injective J ↔ (preadditiveYoneda.obj J).PreservesEpimorphisms 
Attempt failure.

Working on Mathlib/CategoryTheory/Shift/Basic.lean - 2024-08-20 15:34:10.344768.
---0/3204---
Verifying proof:
:= by
  erw [← shiftComm_symm Y i j, ← ((shiftFunctorComm C i j).hom.naturality j).hom.naturality j]

For theorem:
theorem shiftComm' (i j : A) :
    f⟦i⟧'⟦j⟧' = (shiftComm _ _ _).hom ≫ f⟦j⟧'⟦i⟧' ≫ (shiftComm _ _ _).hom 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [shiftFunctorAdd'_eq_shiftFunctorAdd, shiftFunctorAdd_eq_shiftFunctorAdd,
    shiftFunctorAdd'_eq_shiftFunctorAdd, shiftFunctorAdd'_eq_shiftFunctorAdd,
    shiftFunctorAdd'_eq_shiftFunctorAdd, shiftFunctorAdd'_eq_shiftFunctorAdd,
    shiftFunctorAdd'_eq_shiftFunctorAdd]

For theorem:
lemma shiftFunctorAdd_assoc (a₁ a₂ a₃ : A) :
    shiftFunctorAdd C (a₁ + a₂) a₃ ≪≫
      isoWhiskerRight (shiftFunctorAdd C a₁ a₂) _ ≪≫ Functor.associator _ _ _ =
    shiftFunctorAdd' C a₁ (a₂ + a₃) _ (add_assoc a₁ a₂ a₃).symm ≪≫
      isoWhiskerLeft _ (shiftFunctorAdd C a₂ a₃) 
Attempt failure.

Working on Mathlib/CategoryTheory/Shift/ShiftSequence.lean - 2024-08-20 15:34:23.220254.
---0/3204---
Verifying proof:
:= by
  rw [add_assoc, ha', ha'']

For theorem:
lemma shiftIso_add_hom_app (n m a a' a'' : M) (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :
    (F.shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha''])).hom.app X =
      (shift F a).map ((shiftFunctorAdd C m n).hom.app X) ≫
        (shiftIso F n a a' ha').hom.app ((shiftFunctor C m).obj X) ≫
          (shiftIso F m a' a'' ha'').hom.app X 
Attempt failure.

Working on Mathlib/CategoryTheory/Simple.lean - 2024-08-20 15:34:25.397686.
---0/3204---
Verifying proof:
:=
  ⟨Simple.not_isZero X, fun Y Z i => by
    refine or_iff_not_imp_left.mpr fun h =>?_⟩
    rw [IsZero.iff_isSplitMono_eq_zero_iff]
    rw [IsZero.iff_isSplitMono_eq_zero_iff_isSplitMono_eq_zero]
    rw [IsZero.iff_isSplitMon

For theorem:
theorem indecomposable_of_simple (X : C) [Simple X] : Indecomposable X 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor; intros Y f hf; constructor
  · intro i
    · intro i
    · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
      · intro i
              

For theorem:
theorem simple_of_isSimpleOrder_subobject (X : C) [IsSimpleOrder (Subobject X)] : Simple X 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Canonical.lean - 2024-08-20 15:34:28.053879.
---0/3204---
Verifying proof:
:= by
  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ hf₃
  rw [← Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ hf₃
  rw [← Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ hf₃
  rw [← Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  intro Y₁ Y₂ Z g₃ f₁ f₂ hf₁ hf₂ hf₃
  rw [← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply,
    Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply,
    Presieve.isSeparatedFor_iff_isSheafFor]
  intro Y₁ Y₂ Z g₃ f₁ f₂ hf₁ hf₂ hf₃ hf₃
  rw [← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply,
    Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply,
    Presieve.isSeparatedFor

For theorem:
theorem isSheafFor_trans (P : Cᵒᵖ ⥤ Type v) (R S : Sieve X)
    (hR : Presieve.IsSheafFor P (R : Presieve X))
    (hR' : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄ (_ : S f), Presieve.IsSeparatedFor P (R.pullback f : Presieve Y))
    (hS : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄ (_ : R f), Presieve.IsSheafFor P (S.pullback f : Presieve Y)) :
    Presieve.IsSheafFor P (S : Presieve X) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ hf₃
  rw [← Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ hf₃
  rw [← Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ hf₃
  rw [← Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  intro Y₁ Y₂ Z g₃ f₁ f₂ hf₁ hf₂ hf₃
  rw [← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply,
    Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply,
    Presieve.isSeparatedFor_iff_isSheafFor]
  intro Y₁ Y₂ Z g₃ f₁ f₂ hf₁ hf₂ hf₃ hf₃
  rw [← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply,
    Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply,
    Presieve.isSeparatedFor

For theorem:
theorem isSheafFor_trans (P : Cᵒᵖ ⥤ Type v) (R S : Sieve X)
    (hR : Presieve.IsSheafFor P (R : Presieve X))
    (hR' : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄ (_ : S f), Presieve.IsSeparatedFor P (R.pullback f : Presieve Y))
    (hS : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄ (_ : R f), Presieve.IsSheafFor P (S.pullback f : Presieve Y)) :
    Presieve.IsSheafFor P (S : Presieve X) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun Y f hf =>?_, fun Y f hf =>?_⟩
  · intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ =>?_⟩
  · intro Y₁ Y₂ Z g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ h₁ h₂ =>?_⟩
  · intro Y₁ Y₂ Z g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ h₁ h₂ =>?_⟩
    simp only [isSheafFor_iff_isSheafFor] at h₁ h₂ ⊢
    exact h₁ h₂ h₂
  · intro Y₁ Y₂ Z g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ h₁ h₂ =>?_⟩
  · intro Y₁ Y₂ Z g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g₃ g

For theorem:
theorem isSheafFor_bind (P : Cᵒᵖ ⥤ Type v) (U : Sieve X) (B : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, U f → Sieve Y)
    (hU : Presieve.IsSheafFor P (U : Presieve X))
    (hB : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄ (hf : U f), Presieve.IsSheafFor P (B hf : Presieve Y))
    (hB' : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄ (h : U f) ⦃Z⦄ (g : Z ⟶ Y),
      Presieve.IsSeparatedFor P (((B h).pullback g) : Presieve Z)) :
    Presieve.IsSheafFor P (Sieve.bind (U : Presieve X) B : Presieve X) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ hf₃
  rw [← Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ hf₃
  rw [← Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ hf₃
  rw [← Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  intro Y₁ Y₂ Z g₃ f₁ f₂ hf₁ hf₂ hf₃
  rw [← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply,
    Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply,
    Presieve.isSeparatedFor_iff_isSheafFor]
  intro Y₁ Y₂ Z g₃ f₁ f₂ hf₁ hf₂ hf₃ hf₃
  rw [← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply,
    Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply, ← Presieve.isSeparatedFor_apply,
    Presieve.isSeparatedFor

For theorem:
theorem isSheafFor_trans (P : Cᵒᵖ ⥤ Type v) (R S : Sieve X)
    (hR : Presieve.IsSheafFor P (R : Presieve X))
    (hR' : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄ (_ : S f), Presieve.IsSeparatedFor P (R.pullback f : Presieve Y))
    (hS : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄ (_ : R f), Presieve.IsSheafFor P (S.pullback f : Presieve Y)) :
    Presieve.IsSheafFor P (S : Presieve X) 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Closed.lean - 2024-08-20 15:34:34.101571.
---0/3204---
Verifying proof:
:= by
  apply le_antisymm
  · refine J₁.le_close_of_isClosed (Sieve.pullback f)?_
  · refine J₁.le_close_of_isClosed (Sieve.pullback f)?_
  · refine J₁.le_close_of_isClosed (Sieve.pullback f)?_
    simp only [Sieve.pullback_apply, Sieve.pullback_apply]

For theorem:
theorem pullback_close {X Y : C} (f : Y ⟶ X) (S : Sieve X) :
    J₁.close (S.pullback f) = (J₁.close S).pullback f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro X S hS
  rw [← Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  refine ⟨_, _⟩
  refine ⟨_, _⟩
  refine ⟨_, _⟩
  rw [← Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]

For theorem:
theorem classifier_isSheaf : Presieve.IsSheaf J₁ (Functor.closedSieves J₁) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro X S hS
  rw [← Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]

For theorem:
theorem classifier_isSheaf : Presieve.IsSheaf J₁ (Functor.closedSieves J₁) 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Coherent/CoherentTopology.lean - 2024-08-20 15:34:37.665250.
---0/3204---
Verifying proof:
:= by
  obtain ⟨α, hα⟩ := hasEffectiveEpiFamily_of_hasEffectiveEpiFamily_of_hasEffectiveEpiFamily
  obtain ⟨α, hα⟩ := hasEffectiveEpiFamily_of_hasEffectiveEpiFamily_of_hasEffectiveEpiFamily
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain ⟨α, hα⟩ := hα
  obtain 

For theorem:
theorem coherentTopology.mem_sieves_of_hasEffectiveEpiFamily (S : Sieve X) :
    (∃ (α : Type) (_ : Finite α) (Y : α → C) (π : (a : α) → (Y a ⟶ X)),
      EffectiveEpiFamily Y π ∧ (∀ a : α, (S.arrows) (π a)) ) →
        (S ∈ GrothendieckTopology.sieves (coherentTopology C) X) 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/CompatiblePlus.lean - 2024-08-20 15:34:38.936116.
---0/3204---
Verifying proof:
:= by
  dsimp [plusCompIso]

For theorem:
theorem plusCompIso_whiskerRight {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) :
    whiskerRight (J.plusMap η) F ≫ (J.plusCompIso F Q).hom =
      (J.plusCompIso F P).hom ≫ J.plusMap (whiskerRight η F) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  dsimp [plusCompIso]

For theorem:
theorem plusCompIso_whiskerRight {P Q : Cᵒᵖ ⥤ D} (η : P ⟶ Q) :
    whiskerRight (J.plusMap η) F ≫ (J.plusCompIso F Q).hom =
      (J.plusCompIso F P).hom ≫ J.plusMap (whiskerRight η F) 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/ConcreteSheafification.lean - 2024-08-20 15:34:46.219855.
---0/3204---
Verifying proof:
:= by
  refine Presheaf.isSheaf_iff_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf
    (Presheaf.isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf
    (Presheaf.isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf_of_isSheaf 

For theorem:
theorem isSheaf_of_sep (P : Cᵒᵖ ⥤ D)
    (hsep :
      ∀ (X : C) (S : J.Cover X) (x y : P.obj (op X)),
        (∀ I : S.Arrow, P.map I.f.op x = P.map I.f.op y) → x = y) :
    Presheaf.IsSheaf J (J.plusObj P) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun h =>?_⟩
  · rintro ⟨W, h1, h2⟩
    exact ⟨W, h1, h2⟩
  · rintro ⟨W, h1, h2⟩
    exact ⟨W, h1, h2⟩

For theorem:
theorem eq_mk_iff_exists {X : C} {P : Cᵒᵖ ⥤ D} {S T : J.Cover X} (x : Meq P S) (y : Meq P T) :
    mk x = mk y ↔ ∃ (W : J.Cover X) (h1 : W ⟶ S) (h2 : W ⟶ T), x.refine h1 = y.refine h2 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/DenseSubsite.lean - 2024-08-20 15:34:53.504067.
---0/3204---
Verifying proof:
:= by
  convert IsIso.of_iso (sheafIso (whiskerLeft G.op α.val))

For theorem:
theorem iso_of_restrict_iso {ℱ ℱ' : Sheaf K A} (α : ℱ ⟶ ℱ') (i : IsIso (whiskerLeft G.op α.val)) :
    IsIso α 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ e
  apply H.ext
  intro Y f
  simp only [pushforwardFamily_compatible, pushforwardFamily_compatible]

For theorem:
theorem pushforwardFamily_compatible {X} (x : ℱ.obj (op X)) :
    (pushforwardFamily α x).Compatible 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean - 2024-08-20 15:34:59.847083.
---0/3204---
Verifying proof:
:= by
  rw [Types.type_equalizer_iff_unique]
  erw [← Equiv.forall_congr_left (firstObjEqFamily P R).toEquiv.symm]
  erw [← Equiv.forall_congr_left (firstObjEqFamily P R).toEquiv.symm]

For theorem:
theorem sheaf_condition : R.IsSheafFor P ↔ Nonempty (IsLimit (Fork.ofι _ (w P R))) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [Types.type_equalizer_iff_unique,
    ← Equiv.forall_congr_left_iff]
  refine ⟨fun h => ⟨?_⟩⟩
  refine ⟨?_,?_⟩
  · rintro ⟨y, hy⟩
    exact ⟨y, hy⟩

For theorem:
theorem equalizer_sheaf_condition :
    Presieve.IsSheafFor P (S : Presieve X) ↔ Nonempty (IsLimit (Fork.ofι _ (w P S))) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [Types.type_equalizer_iff_unique, isSheafFor_arrows_iff]

For theorem:
theorem sheaf_condition : R.IsSheafFor P ↔ Nonempty (IsLimit (Fork.ofι _ (w P R))) 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Grothendieck.lean - 2024-08-20 15:35:06.664464.
---0/3204---
Verifying proof:
:= by
  rw [Covers, (Sieve.pullback_eq_top_iff_mem f).1 hf]

For theorem:
theorem arrow_max (f : Y ⟶ X) (S : Sieve X) (hf : S f) : J.Covers S f 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/InducedTopology.lean - 2024-08-20 15:35:08.901219.
---0/3204---
Verifying proof:
:= by
  intro X T
  refine K.superset_covering?_ (K.bind_covering T.property)
  fun Y f _ =>?_
  · intro Y f _
    simp only [Functor.locallyCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverDense
      (K.bind_covering T.property) (K.bind_covering T.property)
      (K.bind_covering T.property) (K.bind_covering T.property)
    simp only [Functor.locallyCoverDense_of_isCoverDense_of_isCoverDense_of_isCoverD

For theorem:
theorem Functor.locallyCoverDense_of_isCoverDense [Full G] [G.IsCoverDense K] :
    LocallyCoverDense K G 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/IsSheafFor.lean - 2024-08-20 15:35:10.125782.
---0/3204---
Verifying proof:
:= by
  classical
    rintro _ ⟨x, rfl⟩ ⟨y, rfl⟩ ⟨z, rfl⟩
    exact ⟨z, rfl⟩
  · rintro ⟨y, rfl⟩ ⟨z, rfl⟩ ⟨z, rfl⟩
    exact ⟨z, rfl⟩
  · rintro ⟨z, rfl⟩ ⟨z, rfl⟩
    exact ⟨z, hz⟩

For theorem:
theorem FamilyOfElements.Compatible.restrict {R₁ R₂ : Presieve X} (h : R₁ ≤ R₂)
    {x : FamilyOfElements P R₂} : x.Compatible → (x.restrict h).Compatible 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/IsSheafOneHypercover.lean - 2024-08-20 15:35:12.573067.
---0/3204---
Verifying proof:
:= by
  apply hom_ext H P hP _ (J.pullback_stable f E.mem₀)
  intro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g
  rintro Z g


For theorem:
lemma fac {Y : C} (f : Y ⟶ X) (hf : S f) :
    lift hP hE le F ≫ P.map f.op = F.ι ⟨Y, f, hf⟩ 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/LocallySurjective.lean - 2024-08-20 15:35:13.900033.
---0/3204---
Verifying proof:
:= by
  rw [isLocallySurjective_iff_imagePresheaf_sheafify_eq_top]
  refine ⟨fun h =>?_, fun h =>?_⟩
  · ext x
    simp only [imagePresheaf_sheafify, imagePresheaf_sheafify_apply, imagePresheaf_apply,
      imagePresheaf_sheafify_apply, imagePresheaf_sheafify_apply]
    exact (imagePresheaf (whiskerRight f (forget A))).isLocallySurjective_iff_imagePresheaf_sheafify_eq_top

For theorem:
theorem isLocallySurjective_iff_imagePresheaf_sheafify_eq_top {F G : Cᵒᵖ ⥤ A} (f : F ⟶ G) :
    IsLocallySurjective J f ↔ (imagePresheaf (whiskerRight f (forget A))).sheafify J = ⊤ 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Plus.lean - 2024-08-20 15:35:16.526024.
---0/3204---
Verifying proof:
:= by
  ext X : 2
  refine colimit.hom_ext (fun S =>?_)
  dsimp only [plusMap, toPlus]
  dsimp only [plusMap, toPlus]
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e : S.unop ⟶ ⊤ := homOfLE (OrderTop.le_top _)
  let e 

For theorem:
theorem plusMap_toPlus : J.plusMap (J.toPlus P) = J.toPlus (J.plusObj P) 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Preserves.lean - 2024-08-20 15:35:20.995171.
---0/3204---
Verifying proof:
:= by
  rw [Equalizer.Presieve.Arrows.sheaf_condition, Limits.Types.types_comp_apply]

For theorem:
theorem isSheafFor_of_preservesProduct [PreservesLimit (Discrete.functor (fun x ↦ op (X x))) F] :
    (ofArrows X c.inj).IsSheafFor F 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Sheaf.lean - 2024-08-20 15:35:22.204241.
---0/3204---
Verifying proof:
:= by
  rw [isSheaf_iff_isSheaf_multiequalizer]
  refine ⟨fun h X S =>?_, fun h X S =>?_⟩
  · intro h X S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S
    obtain ⟨X', hX'⟩ := h X' S


For theorem:
theorem isSheaf_iff_multiequalizer [∀ (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)] :
    IsSheaf J P ↔ ∀ (X : C) (S : J.Cover X), IsIso (S.toMultiequalizer P) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro h U R hR
    refine ⟨?_⟩
    apply coyonedaJointlyReflectsLimits
    intro X
    apply coyonedaJointlyReflectsLimits

For theorem:
theorem isSheaf_iff_isSheaf' : IsSheaf J P' ↔ IsSheaf' J P' 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun hP X S => ⟨isLimitOfIsSheaf _ _ _ hP⟩,?_⟩
  intro h E
  refine ⟨fun hP X S => ⟨isLimitOfIsSheaf _ _ _ hP⟩,?_⟩
  intro h E
  intro h E
  refine ⟨fun hP X S => ⟨isLimitOfIsSheaf _ _ _ hP⟩,?_⟩
  intro h E X S hS
  refine ⟨fun hP X S => ⟨isLimitOfIsSheaf _ _ _ hP⟩,?_⟩
  intro h E
  refine ⟨fun hP X S => ⟨isLimitOfIsSheaf _ _ _ hP⟩,?_⟩
  intro h E X S
  refine ⟨fun hP X S => ⟨isLimitOfIsSheaf _ _ _ hP⟩,?_⟩
  intro h E
  refine ⟨fun hP X S => ⟨isLimitOfIsSheaf _ _ _ hP⟩,?_⟩
  intro h E X S
  refine ⟨fun hP X S => ⟨isLimitOfIsSheaf _ _ _ hP⟩,?_⟩
  intro h E
  refine ⟨fun hP X S => ⟨isLimitOfIsSheaf _ _ _ hP⟩,?_⟩
  intro h E X S
  refine ⟨fun hP X S => ⟨isLimitOfIsSheaf _ _ _ hP⟩,?_⟩
  intro h E
  refine ⟨fun hP X S => ⟨isLimitOfIsSheaf _ _ _ hP⟩,?_⟩
  intro h E
  refine ⟨fun hP X S => ⟨isLimitOfIsSheaf _ _ _ hP⟩,?_⟩
  intro h E
  refine ⟨fun hP X S => ⟨isLimitOfIsSheaf _ _ _ hP⟩,?_

For theorem:
theorem isSheaf_iff_multifork :
    IsSheaf J P ↔ ∀ (X : C) (S : J.Cover X), Nonempty (IsLimit (S.multifork P)) 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/SheafOfTypes.lean - 2024-08-20 15:35:49.079701.
---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    refine ⟨fun h =>?_⟩
    refine ⟨fun h W =>?_⟩
    refine ⟨fun h =>?_⟩
    intro h
    refine ⟨fun h W =>?_⟩
    · rintro ⟨W, ⟨e⟩⟩
      exact ⟨e⟩
    · rintro ⟨e⟩
      exact ⟨e⟩
    · rintro ⟨e⟩
      exact ⟨e⟩
    · rintro ⟨e⟩
      refine ⟨e⟩
      rintro ⟨e⟩
      exact ⟨e⟩
      rintro ⟨e⟩
      exact ⟨e⟩

For theorem:
theorem forallYonedaIsSheaf_iff_colimit (S : Sieve X) :
    (∀ W : C, Presieve.IsSheafFor (yoneda.obj W) (S : Presieve X)) ↔
      Nonempty (IsColimit S.arrows.cocone) 
Attempt failure.

Working on Mathlib/CategoryTheory/Sites/Subsheaf.lean - 2024-08-20 15:35:51.522017.
---0/3204---
Verifying proof:
:= by
  intro U S hS x hx
  let S' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafif

For theorem:
theorem Subpresheaf.sheafify_isSheaf (hF : Presieve.IsSheaf J F) :
    Presieve.IsSheaf J (G.sheafify J).toPresheaf 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro U S hS x hx
  let S' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafify J)
  let S'' := Sieve.bind S fun Y f hf => G.sieveOfSection (G.sheafif

For theorem:
theorem Subpresheaf.sheafify_isSheaf (hF : Presieve.IsSheaf J F) :
    Presieve.IsSheaf J (G.sheafify J).toPresheaf 
Attempt failure.

Working on Mathlib/CategoryTheory/Triangulated/HomologicalFunctor.lean - 2024-08-20 15:35:57.325805.
---0/3204---
Verifying proof:
:= by
  obtain ⟨T', e', hT'⟩ := hF _ hT
  obtain ⟨T', e', hT'⟩ := hF _ hT
  obtain ⟨T', e', hT'⟩ := hT'
  obtain ⟨T'', hT'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obtain ⟨T'', hT''⟩ := hT'
  obt

For theorem:
lemma IsHomological.mk' [F.PreservesZeroMorphisms]
    (hF : ∀ (T : Pretriangulated.Triangle C) (hT : T ∈ distTriang C),
      ∃ (T' : Pretriangulated.Triangle C) (e : T ≅ T'),
      ((shortComplexOfDistTriangle T' (isomorphic_distinguished _ hT _ e.symm)).map F).Exact) :
    F.IsHomological where
Attempt failure.

Working on Mathlib/CategoryTheory/Triangulated/Opposite.lean - 2024-08-20 15:36:02.759904.
---0/3204---
Verifying proof:
:= by
  dsimp [shiftFunctorAdd', shiftFunctorAdd]
  dsimp [shiftFunctorAdd, shiftFunctorAdd]
  dsimp [shiftFunctorAdd, shiftFunctorAdd, shiftFunctorAdd]
  simp only [shiftFunctorAdd'_op_inv_app_of_add_eq_zero h₁ h₂ h₃ h₁ h₂ h₃,
    shiftFunctorAdd'_op_inv_app_of_add_eq_zero h₁ h₂ h₃, shiftFunctorAdd'_op_inv_app_of_add_eq_zero h₁ h₂ h₃,
    shiftFunctorAdd'_op_inv_app_of_add_eq_zero h₁ h₂ h₃, shiftFunctorAdd'_op_inv_app_of_add_eq_zero h₁ h₂ h₃,
    shiftFunctorAdd'_op_inv_app_of_add_eq_zero h₁ h₂ h₃, shiftFunctorAdd'_op_inv_app_of_add_eq_zero h₁ h₂ h₃,
    shiftFunctorAdd'_op_inv_app_of_add_eq_zero h₁ h₂ h₃]

For theorem:
lemma shiftFunctorAdd'_op_inv_app (X : Cᵒᵖ) (a₁ a₂ a₃ : ℤ) (h : a₁ + a₂ = a₃)
    (b₁ b₂ b₃ : ℤ) (h₁ : a₁ + b₁ = 0) (h₂ : a₂ + b₂ = 0) (h₃ : a₃ + b₃ = 0) :
    (shiftFunctorAdd' Cᵒᵖ a₁ a₂ a₃ h).inv.app X =
      (shiftFunctor Cᵒᵖ a₂).map ((shiftFunctorOpIso C _ _ h₁).hom.app X) ≫
      (shiftFunctorOpIso C _ _ h₂).hom.app _ ≫
      ((shiftFunctorAdd' C b₁ b₂ b₃ (by omega)).hom.app X.unop).op ≫
      (shiftFunctorOpIso C _ _ h₃).inv.app X 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [mem_distinguishedOp_iff, Pretriangulated.rotate]

For theorem:
lemma rotate_distinguished_triangle (T : Triangle Cᵒᵖ) :
    T ∈ distinguishedTriangles C ↔ T.rotate ∈ distinguishedTriangles C 
Attempt failure.

Working on Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean - 2024-08-20 15:36:36.265198.
---0/3204---
Verifying proof:
:= by
  obtain ⟨a, ⟨ha₁, _⟩⟩ := complete_distinguished_triangle_triangle f hf

For theorem:
lemma coyoneda_exact₂ {X : C} (f : X ⟶ T.obj₂) (hf : f ≫ T.mor₂ = 0) :
    ∃ (g : X ⟶ T.obj₁), f = g ≫ T.mor₁ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    rw [epi_iff_cancel_zero]
    intro X g hg
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact₃
    obtain ⟨f, rfl⟩ := yoneda_exact

For theorem:
lemma mor₃_eq_zero_iff_epi₂ : T.mor₃ = 0 ↔ Epi T.mor₂ 
Attempt failure.

---0/3204---
Verifying proof:
:=
  isZero₂_of_isZero₁₃ _ (rot_of_distTriang _ hT) h₂ (by
    dsimp
    simp only [isZero₂_of_isZero₁₃ _ (rot_of_distTriang _ hT) h₂ (by
      dsimp
      simp only [isZero₂_iff_isZero₁₃ _ (rot_of_distTriang _ hT) h₂ (by
      dsimp
      simp only [isZero₂_iff_isZero₁₃ _ (rot_of_distTriang _ hT) h₂ (by
      dsimp
      simp only [isZero₂_iff_isZero₁₃ _ (rot_of_distTriang _ hT) h₂ (by
      dsimp
      simp only [isZero₂_iff_isZero₁₃ _ (rot_of_distTriang _ hT) h₂ (by
      dsimp
      simp only [isZero₂_iff_isZero₁₃ _ (rot_of_distTriang _ hT) h₂ (by
      dsimp
      simp only [isZero₂_iff_isZero₁₃ _ (rot_of_distTriang _ hT) h₂ (by
      dsimp
      simp only [isZero₂_iff_isZero₁₃ _ (rot_of_distTriang _ hT) h₂ (by
      dsimp
      simp only [isZero₂_iff_isZero₁₃ _ (rot_of_distTriang _ hT) h₂ (by
      dsimp
      simp only [isZero₂_iff_isZero₁₃ _ (rot_of_distTriang _ hT) h₂ (by
      dsimp
      simp only [isZero₂_if

For theorem:
lemma isZero₃_of_isZero₁₂ (h₁ : IsZero T.obj₁) (h₂ : IsZero T.obj₂) : IsZero T.obj₃ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have h := mor₃_eq_zero_iff_epi₂ _ (inv_rot_of_distTriang _ hT)
  dsimp at h
  rw [← h, IsIso.comp_right_eq_zero]

For theorem:
lemma mor₂_eq_zero_iff_epi₁ : T.mor₂ = 0 ↔ Epi T.mor₁ 
Attempt failure.

---0/3204---
Verifying proof:
:=
  isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso₂₃
    (isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso₂₃
    (isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso φ hT hT'
    (isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso φ hT'
    (isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso φ hT'
    (isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso φ hT hT'
    (isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso φ hT'
    (isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso φ hT'
    (isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso_of_isIso₂₃
   

For theorem:
lemma isIso₁_of_isIso₂₃ {T T' : Triangle C} (φ : T ⟶ T') (hT : T ∈ distTriang C)
    (hT' : T' ∈ distTriang C) (h₂ : IsIso φ.hom₂) (h₃ : IsIso φ.hom₃) : IsIso φ.hom₁ 
Attempt failure.

---0/3204---
Verifying proof:
:=
  coyoneda_exact₂ _ (rot_of_distTriang _ hf)

For theorem:
lemma coyoneda_exact₁ {X : C} (f : X ⟶ T.obj₁⟦(1 : ℤ)⟧) (hf : f ≫ T.mor₁⟦1⟧' = 0) :
    ∃ (g : X ⟶ T.obj₃), f = g ≫ T.mor₃ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine isomorphic_distinguished _
  (inv_rot_of_distTriang _ (contractible_distinguished _ (contractible_distinguished _ _)))
    (contractible_distinguished _ (contractible_distinguished _ _))
    (contractible_distinguished _ _)

For theorem:
lemma contractible_distinguished₂ (X : C) :
    Triangle.mk (0 : X ⟶ 0) 0 (𝟙 (X⟦1⟧)) ∈ distTriang C 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← productTriangle_distinguished_iff]
  intro j
  simp only [productTriangle_distinguished_iff, productTriangle_distinguished_iff,
    productTriangle_distinguished_iff, productTriangle_distinguished_iff, productTriangle_distinguished_iff,
    productTriangle_distinguished_iff, productTriangle_distinguished_iff, productTriangle_distinguished_iff,
    productTriangle_distinguished_iff, productTriangle_distinguished_iff, productTriangle_distinguished_iff]

For theorem:
lemma productTriangle_distinguished {J : Type*} (T : J → Triangle C)
    (hT : ∀ j, T j ∈ distTriang C)
    [HasProduct (fun j => (T j).obj₁)] [HasProduct (fun j => (T j).obj₂)]
    [HasProduct (fun j => (T j).obj₃)] [HasProduct (fun j => (T j).obj₁⟦(1 : ℤ)⟧)] :
    productTriangle T ∈ distTriang C := by
    let f₁ 
Attempt failure.

---0/3204---
Verifying proof:
:=
  coyoneda_exact₂ _ (rot_of_distTriang _ hT) f hf

For theorem:
lemma coyoneda_exact₃ {X : C} (f : X ⟶ T.obj₃) (hf : f ≫ T.mor₃ = 0) :
    ∃ (g : X ⟶ T.obj₂), f = g ≫ T.mor₂ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    exact ⟨h.eq_of_tgt _ _, h.eq_of_src _ _⟩
  · intro ⟨h.eq_of_tgt _ _, h.eq_of_src _ _⟩
    · intro ⟨h₁, h₂⟩
    · intro ⟨h₁, h₂⟩
      exact ⟨h.eq_of_tgt _ _, h.eq_of_src _ _⟩

For theorem:
lemma isZero₂_iff : IsZero T.obj₂ ↔ (T.mor₁ = 0 ∧ T.mor₂ = 0) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Iff.trans?_ (Triangle.isZero₁_iff_isIso₂ _ (inv_rot_of_distTriang _ hT))
  dsimp
  simp

For theorem:
lemma isZero₃_iff_isIso₁ : IsZero T.obj₃ ↔ IsIso T.mor₁ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨e, he₁, he₂⟩ := exists_iso_binaryBiproduct_of_distTriang T hT
  obtain ⟨e, he₁, he₂⟩ := exists_iso_binaryBiproduct_of_distTriang T hT
  obtain ⟨e, he₁, he₂⟩ := exists_iso_binaryBiproduct_of_distTriang T hT
  obtain ⟨e, he₁, he₂⟩ := exists_iso_binaryBiproduct_of_distTriang T hT
  obtain ⟨e, he₁, he₂⟩ := exists_iso_binaryBiproduct_of_distTriang T hT

For theorem:
lemma exists_iso_binaryBiproduct_of_distTriang (T : Triangle C) (hT : T ∈ distTriang C)
    (zero : T.mor₃ = 0) :
    ∃ (e : T.obj₂ ≅ T.obj₁ ⊞ T.obj₃), T.mor₁ ≫ e.hom = biprod.inl ∧
      T.mor₂ = e.hom ≫ biprod.snd 
Attempt failure.

Working on Mathlib/CategoryTheory/Types.lean - 2024-08-20 15:37:27.093955.
---0/3204---
Verifying proof:
:= by
  constructor
  · intro H x x' h
    skip
    rw [← homOfElement_eq_iff] at h₁
    exact (cancel_mono h₁).1 h₂

For theorem:
theorem mono_iff_injective {X Y : Type u} (f : X ⟶ Y) : Mono f ↔ Function.Injective f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro H x x' h
    skip
    rw [← homOfElement_eq_iff] at h ⊢
    exact (cancel_mono h).1 h

For theorem:
theorem mono_iff_injective {X Y : Type u} (f : X ⟶ Y) : Mono f ↔ Function.Injective f 
Attempt failure.

Working on Mathlib/Combinatorics/Additive/Dissociation.lean - 2024-08-20 15:37:30.600431.
---0/3204---
Verifying proof:
:= by
  simp [MulDissociated, InjOn, ← e.finsetCongr.forall_congr_left, ← e.apply_eq_iff]

For theorem:
lemma MulEquiv.mulDissociated_preimage (e : β ≃* α) :
    MulDissociated (e ⁻¹' s) ↔ MulDissociated s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · rintro ⟨t, u, hts, htu, htu, htu, htu⟩
    refine ⟨t, u, htu,?_,?_,?_,?_,?_⟩
    · rintro ⟨t, u, htu, htu, htu, htu⟩
      · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu, htu⟩
    · exact ⟨t, u, htu, htu

For theorem:
lemma not_mulDissociated_iff_exists_disjoint :
    ¬ MulDissociated s ↔
      ∃ t u : Finset α, ↑t ⊆ s ∧ ↑u ⊆ s ∧ Disjoint t u ∧ t ≠ u ∧ ∏ a in t, a = ∏ a in u, a 
Attempt failure.

Working on Mathlib/Combinatorics/Additive/PluenneckeRuzsa.lean - 2024-08-20 15:37:35.843724.
---0/3204---
Verifying proof:
:= by
  induction' C using Finset.induction_on with C ih
  · simp only [Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC]
  · simp only [Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC,
      Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC,
      Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC,
      Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC,
      Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC,
      Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC,
      Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC,
      Finset.card_insert_of_not_mem hC, Finset.card_insert_of_not_mem hC, Finset.card_insert,
    Finset.card_insert_of_not_mem hC, Finset.card_insert

For theorem:
theorem mul_pluennecke_petridis (C : Finset α)
    (hA : ∀ A' ⊆ A, (A * B).card * A'.card ≤ (A' * B).card * A.card) :
    (A * B * C).card * A.card ≤ (A * B).card * (A * C).card 
Attempt failure.

Working on Mathlib/Combinatorics/Additive/RuzsaCovering.lean - 2024-08-20 15:37:38.978829.
---0/3204---
Verifying proof:
:= by
  haveI : ∀ u : Set α, Decidable ((u : Set α).PairwiseDisjoint (· • t)) := fun u hu ↦ by
    intro u hu
    rcases ht with ⟨u, hu⟩
    refine ⟨u,?_,?_⟩
    · rintro ⟨u, hu⟩
      exact ⟨u, hu, subset_union_right hu⟩
    · exact ⟨u, hu, subset_union_right hu⟩
    · exact ⟨u, hu, subset_union_right hu⟩
    · exact ⟨u, hu, subset_union_right hu⟩
    · exact ⟨u, hu, subset_union_right hu⟩
    · exact ⟨u, hu, subset_union_right hu⟩
    · exact ⟨u, hu, subset_union_left hu⟩

For theorem:
theorem exists_subset_mul_div (ht : t.Nonempty) :
    ∃ u : Finset α, u.card * t.card ≤ (s * t).card ∧ s ⊆ u * t / t 
Attempt failure.

Working on Mathlib/Combinatorics/Colex.lean - 2024-08-20 15:37:40.117158.
---0/3204---
Verifying proof:
:= by
  simpa using toColex_sdiff_lt_toColex_sdiff'

For theorem:
lemma toColex_sdiff_lt_toColex_sdiff' :
 toColex (s \ t) < toColex (t \ s) ↔ toColex s < toColex t 
Attempt failure.

Working on Mathlib/Combinatorics/Configuration.lean - 2024-08-20 15:37:43.019201.
---0/3204---
Verifying proof:
:= by
  rw [lineCount_eq_pointCount L p, pointCount_eq_pointCount hpl, pointCount_eq_pointCount hpl,
    pointCount_eq_pointCount hpl]

For theorem:
theorem HasLines.lineCount_eq_pointCount [HasLines P L] [Fintype P] [Fintype L]
    (hPL : Fintype.card P = Fintype.card L) {p : P} {l : L} (hpl : p ∉ l) :
    lineCount L p = pointCount P l 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_card_le h
  obtain ⟨f, hf₁, hf₂⟩ := exists_injective_of_car

For theorem:
theorem Nondegenerate.exists_injective_of_card_le [Nondegenerate P L] [Fintype P] [Fintype L]
    (h : Fintype.card L ≤ Fintype.card P) : ∃ f : L → P, Function.Injective f ∧ ∀ l, f l ∉ l 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases nonempty_fintype L
  obtain ⟨p, -⟩ := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p } := @exists_config P L _ _
  let ϕ : { q // q ≠ p 

For theorem:
theorem card_points [Fintype P] [Finite L] : Fintype.card P = order P L ^ 2 + order P L + 1 
Attempt failure.

Working on Mathlib/Combinatorics/Enumerative/Catalan.lean - 2024-08-20 15:37:49.170486.
---0/3204---
Verifying proof:
:= by
  have : (n : ℚ) + 1 ≠ 0 := by norm_num

For theorem:
theorem gosper_catalan_sub_eq_central_binom_div (n : ℕ) : gosperCatalan (n + 1) (n + 1) -
    gosperCatalan (n + 1) 0 = Nat.centralBinom (n + 1) / (n + 2) 
Attempt failure.

Working on Mathlib/Combinatorics/HalesJewett.lean - 2024-08-20 15:37:51.961341.
---0/3204---
Verifying proof:
:= by
  classical
    obtain ⟨ι, hι⟩ := exists_mono_in_high_dimension' κ κ
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    r

For theorem:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C :=

Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
    obtain ⟨ι, hι⟩ := exists_mono_in_high_dimension' κ κ
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    r

For theorem:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C :=

Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
    obtain ⟨ι, hι⟩ := exists_mono_in_high_dimension' κ κ
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    r

For theorem:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C :=

Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
    obtain ⟨ι, hι⟩ := exists_mono_in_high_dimension' κ κ
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    r

For theorem:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C :=

Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
    obtain ⟨ι, hι⟩ := exists_mono_in_high_dimension' κ κ
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    r

For theorem:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C :=

Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
    obtain ⟨ι, hι⟩ := exists_mono_in_high_dimension' κ κ
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    r

For theorem:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C :=

Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
    obtain ⟨ι, hι⟩ := exists_mono_in_high_dimension' κ κ
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    refine ⟨ι, fun C =>?_⟩
    r

For theorem:
theorem exists_mono_in_high_dimension' :
    ∀ (α : Type u) [Finite α] (κ : Type max v u) [Finite κ],
      ∃ (ι : Type) (_ : Fintype ι), ∀ C : (ι → α) → κ, ∃ l : Line α ι, l.IsMono C :=

Attempt failure.

Working on Mathlib/Combinatorics/Hall/Basic.lean - 2024-08-20 15:37:59.920138.
---0/3204---
Verifying proof:
:= by
  refine Fintype.all_card_le_of_exists_injective?_
  refine Fintype.all_card_le_of_exists_injective?_?_
  · rintro ⟨a, ha⟩
    exact Fintype.card_le_of_injective ha
  · rintro ⟨a, ha⟩
    exact Fintype.card_le_of_injective ha
  · rintro ⟨a, ha⟩
    exact Fintype.card_le_of_injective ha
  · rintro ⟨a, ha⟩
    exact Fintype.card_le_of_injective ha
  · rintro ⟨a, ha⟩
    exact Fintype.card_le_of_injective ha
    rw [Fintype.card_finset_sum]
    exact Fintype.card_le_of_injective ha
  · rw [Fintype.card_finset_sum]
    exact Fintype.card_le_of_injective ha
  · rw [Fintype.card_finset_sum]
    exact Fintype.card_le_of_injective ha
  · rw [Fintype.card_finset_sum]
    exact Fintype.card_le_of_injective ha
  · rintro ⟨a, ha⟩
    exact Fintype.card_le_of_injective ha
    rw [Fintype.card_finset_sum]
    exact Fintype.card_le_of_injective ha
    exact Fintype.card_le_of_injective ha
  · rw [Fintype.card_finset_sum]
    exact Fintype.card_le_of_injective ha
    rw [Fintype.ca

For theorem:
theorem Fintype.all_card_le_rel_image_card_iff_exists_injective {α : Type u} {β : Type v}
    [DecidableEq β] (r : α → β → Prop) [∀ a : α, Fintype (Rel.image r {a})] :
    (∀ A : Finset α, A.card ≤ Fintype.card (Rel.image r A)) ↔
      ∃ f : α → β, Function.Injective f ∧ ∀ x, r x (f x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨s, hs⟩ := exists_subset_card_eq ι'
  refine ⟨fun s =>?_, fun s =>?_⟩
  · rintro ⟨s, hs⟩
    refine ⟨s.biUnion t,?_⟩
    refine ⟨s.biUnion t,?_⟩
    simp only [mem_biUnion, exists_prop, mem_biUnion, mem_sdiff, mem_singleton, exists_and_right,
      mem_iUnion, mem_biUnion, mem_singleton, exists_eq_right] at hs
    exact ⟨s, hs⟩
  · rintro ⟨s, hs⟩
    exact ⟨s.biUnion t, hs⟩
    refine ⟨s.biUnion t,?_⟩
  · rintro ⟨s, hs⟩
    refine ⟨s.biUnion t,?_⟩
    simp only [mem_biUnion, mem_biUnion, exists_prop] at hs
    refine ⟨s.biUnion t,?_⟩
    simp only [mem_biUnion, mem_biUnion, exists_prop] at hs
    refine ⟨s.biUnion t,?_⟩
    refine ⟨s.biUnion t,?_⟩
    refine ⟨s.biUnion t,?_⟩
    rw [← card_image_of_injective _ hs, card_image_of_injective _ hs⟩
    refine ⟨s.biUnion t,?_⟩
    rw [← card_image_of_injective _ hs, card_image_of_injective _ hs⟩
    refine ⟨s.biUnion t,?_⟩
    rw [← card_image_of_injective 

For theorem:
theorem hallMatchingsOn.nonempty {ι : Type u} {α : Type v} [DecidableEq α] (t : ι → Finset α)
    (h : ∀ s : Finset ι, s.card ≤ (s.biUnion t).card) (ι' : Finset ι) :
    Nonempty (hallMatchingsOn t ι') 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · rintro ⟨f, hf⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    simp only [Finset.card_le_card_iff, Finset.card_eq_sum_ones, Finset.card_eq_sum_ones,
      Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_range,
      Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_range,
      Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_range,
      Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_range,
      Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_range,
      Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_range,
      Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_range,
      Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.card_eq_sum_ones, Finset.

For theorem:
theorem Finset.all_card_le_biUnion_card_iff_exists_injective {ι : Type u} {α : Type v}
    [DecidableEq α] (t : ι → Finset α) :
    (∀ s : Finset ι, s.card ≤ (s.biUnion t).card) ↔
      ∃ f : ι → α, Function.Injective f ∧ ∀ x, f x ∈ t x 
Attempt failure.

Working on Mathlib/Combinatorics/Hall/Finite.lean - 2024-08-20 15:38:04.089578.
---0/3204---
Verifying proof:
:= by
  classical
    have hn' : Fintype.card ι = n := by
      rw [hn, Fintype.card_eq_sum_ones, Nat.succ_eq_add_one]
      exact Fintype.card_congr (Equiv.sumCongr (Equiv.subtypeEquivSubtypeEquivSubtypeEquivSubtype _))

For theorem:
theorem hall_hard_inductive_step_B {n : ℕ} (hn : Fintype.card ι = n + 1)
    (ht : ∀ s : Finset ι, s.card ≤ (s.biUnion t).card)
    (ih :
      ∀ {ι' : Type u} [Fintype ι'] (t' : ι' → Finset α),
        Fintype.card ι' ≤ n →
          (∀ s' : Finset ι', s'.card ≤ (s'.biUnion t').card) →
            ∃ f : ι' → α, Function.Injective f ∧ ∀ x, f x ∈ t' x)
    (s : Finset ι) (hs : s.Nonempty) (hns : s ≠ univ) (hus : s.card = (s.biUnion t).card) :
    ∃ f : ι → α, Function.Injective f ∧ ∀ x, f x ∈ t x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
    have hn' : Fintype.card ι = n := by
      rw [hn, Fintype.card_eq_sum_ones, Nat.succ_eq_add_one]
      exact Fintype.card_congr (Equiv.sumCongr (Equiv.subtypeEquivSubtypeEquivSubtypeEquivSubtype _))

For theorem:
theorem hall_hard_inductive_step_B {n : ℕ} (hn : Fintype.card ι = n + 1)
    (ht : ∀ s : Finset ι, s.card ≤ (s.biUnion t).card)
    (ih :
      ∀ {ι' : Type u} [Fintype ι'] (t' : ι' → Finset α),
        Fintype.card ι' ≤ n →
          (∀ s' : Finset ι', s'.card ≤ (s'.biUnion t').card) →
            ∃ f : ι' → α, Function.Injective f ∧ ∀ x, f x ∈ t' x)
    (s : Finset ι) (hs : s.Nonempty) (hns : s ≠ univ) (hus : s.card = (s.biUnion t).card) :
    ∃ f : ι → α, Function.Injective f ∧ ∀ x, f x ∈ t x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
    have hn' : Fintype.card ι = n := by
      rw [hn, Fintype.card_eq_sum_ones, Nat.succ_eq_add_one]
      exact Fintype.card_congr (Equiv.sumCongr (Equiv.subtypeEquivSubtypeEquivSubtypeEquivSubtype _))

For theorem:
theorem hall_hard_inductive_step_B {n : ℕ} (hn : Fintype.card ι = n + 1)
    (ht : ∀ s : Finset ι, s.card ≤ (s.biUnion t).card)
    (ih :
      ∀ {ι' : Type u} [Fintype ι'] (t' : ι' → Finset α),
        Fintype.card ι' ≤ n →
          (∀ s' : Finset ι', s'.card ≤ (s'.biUnion t').card) →
            ∃ f : ι' → α, Function.Injective f ∧ ∀ x, f x ∈ t' x)
    (s : Finset ι) (hs : s.Nonempty) (hns : s ≠ univ) (hus : s.card = (s.biUnion t).card) :
    ∃ f : ι → α, Function.Injective f ∧ ∀ x, f x ∈ t x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · rintro ⟨f, hf⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ =>?_⟩
    refine ⟨fun h =>?_, fun ⟨f, hf⟩ 

For theorem:
theorem Finset.all_card_le_biUnion_card_iff_existsInjective' {ι α : Type*} [Finite ι]
    [DecidableEq α] (t : ι → Finset α) :
    (∀ s : Finset ι, s.card ≤ (s.biUnion t).card) ↔
      ∃ f : ι → α, Function.Injective f ∧ ∀ x, f x ∈ t x 
Attempt failure.

Working on Mathlib/Combinatorics/Pigeonhole.lean - 2024-08-20 15:38:09.050512.
---0/3204---
Verifying proof:
:= by
  simp_rw [cast_card] at ht

For theorem:
theorem exists_card_fiber_lt_of_card_lt_nsmul (ht : ↑s.card < t.card • b) :
    ∃ y ∈ t, ↑(s.filter fun x => f x = y).card < b 
Attempt failure.

Working on Mathlib/Combinatorics/Quiver/Path.lean - 2024-08-20 15:38:10.641695.
---0/3204---
Verifying proof:
:= by
  | _, nil => by simp
  | _, nil => by simp
  | _, _, _, _ _ _ _ _ _ d _ q _ => by simp [toList_comp]

For theorem:
theorem toList_comp (p : Path a b) : ∀ {c} (q : Path b c), (p.comp q).toList = q.toList ++ p.toList
Attempt failure.

---0/3204---
Verifying proof:
:=
  cons_ne_nil _ _

For theorem:
lemma cons_ne_nil (p : Path a b) (e : b ⟶ a) : p.cons e ≠ Path.nil 
Attempt failure.

Working on Mathlib/Combinatorics/Quiver/Symmetric.lean - 2024-08-20 15:38:12.399583.
---0/3204---
Verifying proof:
:= by
  rw [← cancel_mono (Φ.map (Quiver.reverse f)), ← cancel_mono (Φ.map (Quiver.reverse f)),
    Quiver.reverse.map_comp, Quiver.reverse.map_comp, Quiver.reverse.map_comp,
    Quiver.reverse.map_comp]

For theorem:
theorem lift_unique [HasReverse V'] (φ : V ⥤q V') (Φ : Symmetrify V ⥤q V') (hΦ : (of ⋙q Φ) = φ)
    (hΦinv : ∀ {X Y : Symmetrify V} (f : X ⟶ Y),
      Φ.map (Quiver.reverse f) = Quiver.reverse (Φ.map f)) :
    Φ = Symmetrify.lift φ 
Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/AhlswedeZhang.lean - 2024-08-20 15:38:13.255811.
---0/3204---
Verifying proof:
:= by
  have : e a ∈ upperClosure (s.map e.toEquiv.toEmbedding) := by
    rw [truncatedInf_symm_apply, truncatedInf_symm_apply]
    simp only [truncatedInf_symm_apply, truncatedInf_symm_apply, truncatedInf_symm_apply,
      truncatedInf_symm_apply, truncatedInf_symm_apply, truncatedInf_symm_apply,
      truncatedInf_symm_apply]

For theorem:
lemma map_truncatedInf (e : α ≃o β) (s : Finset α) (a : α) :
    e (truncatedInf s a) = truncatedInf (s.map e.toEquiv.toEmbedding) (e a) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : e a ∈ lowerClosure (s.map e.toEquiv.toEmbedding) := by
    rw [truncatedSup_comp_of_mem _ (mem_map_of_mem _ (mem_map_of_mem _ (mem_map_of_mem _ (mem_map_of_mem _ ha))))]
    exact mem_map_of_mem _ (mem_map_of_mem _ (mem_map_of_mem _ (mem_map_of_mem _ ha)))

For theorem:
lemma map_truncatedSup (e : α ≃o β) (s : Finset α) (a : α) :
    e (truncatedSup s a) = truncatedSup (s.map e.toEquiv.toEmbedding) (e a) 
Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/CauchyDavenport.lean - 2024-08-20 15:38:21.465275.
---0/3204---
Verifying proof:
:= (s, t) with hx
  clear_value x
  simp only [Prod.forall, Nat.cast_add, Nat.cast_one, Nat.cast_le]

For theorem:
lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder α) ↑(s.card + t.card - 1) ≤ (s * t).card := by
    set x 
Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Compression/Down.lean - 2024-08-20 15:38:23.849472.
---0/3204---
Verifying proof:
:=
  by
  simp_rw [compression, mem_disjUnion, mem_filter, mem_filter, mem_image,
    decide_eq_true_eq, and_congr_right_iff]

For theorem:
theorem mem_compression : s ∈ 𝓓 a 𝒜 ↔ s ∈ 𝒜 ∧ s.erase a ∈ 𝒜 ∨ s ∉ 𝒜 ∧ insert a s ∈ 𝒜 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [compression, card_disjUnion, image_filter,
    card_image_of_injOn ((erase_injOn' _).mono fun b hb => by simp [hb])]

For theorem:
theorem card_compression (a : α) (𝒜 : Finset (Finset α)) : (𝓓 a 𝒜).card = 𝒜.card 
Attempt failure.

---0/3204---
Verifying proof:
:=
  by
  rw [compression, card_disjUnion, image_filter,
    card_image_of_injOn ((erase_injOn' _).mono ((erase_injOn' _).mono fun x hx => hx))]

For theorem:
theorem card_compression (a : α) (𝒜 : Finset (Finset α)) : (𝓓 a 𝒜).card = 𝒜.card 
Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Compression/UV.lean - 2024-08-20 15:38:27.682548.
---0/3204---
Verifying proof:
:= by
  rw [compression, card_disjoint_union (compress_disjoint _ _), image_filter, card_image_of_injOn]

For theorem:
theorem card_compression (u v : α) (s : Finset α) : (𝓒 u v s).card = s.card 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  unfold compress
  split_ifs with h
  · rw [card_sdiff (h.2.trans le_sup_left), sup_eq_union, card_sdiff (h.2.trans le_sup_left),
    sup_eq_union, card_sdiff (h.2.trans le_sup_left), sup_eq_union, card_sdiff (h.2.trans le_sup_left),
    sup_eq_union, card_sdiff (h.2.trans le_sup_left), sup_eq_union, card_sdiff (h.2.trans le_sup_left),
    sup_eq_union, card_sdiff (h.2.trans le_sup_left), sup_eq_union, card_sdiff (h.2.trans le_sup_left),
    sup_eq_union, card_sdiff (h.2.trans le_sup_left), sup_eq_union, card_sdiff (h.2.trans le_sup_left),
    sup_eq_union, card_sdiff (h.2.trans le_sup_left), sup_eq_union, card_sdiff (h.2.trans le_sup_left),
    sup_eq_union, card_sdiff (h.2.trans le_sup_left), sup_eq_union, card_sdiff (h.2.trans le_sup_left),
    sup_eq_union, card_sdiff (h.2.trans le_sup_left), sup_eq_union, card_sdiff (h.2.trans le_sup_left),
    sup_eq_union, card_sdiff (h.2.trans le_sup_left), sup_eq_union, card_sdiff (h.2.trans le_sup_left),
    card_sdiff (h.2.trans le_sup_left), sup_eq_union,

For theorem:
theorem card_compress (huv : u.card = v.card) (a : Finset α) : (compress u v a).card = a.card 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine shadow_compression_subset_compression_of_subset_compression huv fun x hx =>?_
  rcases huv x hx with ⟨y, hyu, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  refine ⟨y, hyv,?_⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv wit

For theorem:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine shadow_compression_subset_compression_of_subset_compression huv fun x hx =>?_
  rcases huv x hx with ⟨y, hyu, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  refine ⟨y, hyv,?_⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv with ⟨y, hyv, hyv⟩
  rcases huv y hyv wit

For theorem:
theorem shadow_compression_subset_compression_shadow (u v : Finset α)
    (huv : ∀ x ∈ u, ∃ y ∈ v, IsCompressed (u.erase x) (v.erase y) 𝒜) :
    ∂ (𝓒 u v 𝒜) ⊆ 𝓒 u v (∂ 𝒜) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [compression, card_disjoint_union (compress_disjoint _ _), image_filter, card_image_of_injOn]

For theorem:
theorem card_compression (u v : α) (s : Finset α) : (𝓒 u v s).card = s.card 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [compression, card_disjoint_union (compress_disjoint _ _), image_filter, card_image_of_injOn]

For theorem:
theorem card_compression (u v : α) (s : Finset α) : (𝓒 u v s).card = s.card 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro a ha b hb hab
  rw [mem_coe, mem_filter] at ha hb
  rw [mem_coe, mem_filter] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha hb
  rw [compress] at ha h

For theorem:
theorem compress_injOn : Set.InjOn (compress u v) ↑(s.filter (compress u v · ∉ s)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  unfold compress
  split_ifs with h h' <;> try rfl
  split_ifs with h h' <;> try rfl

For theorem:
theorem compress_idem (u v a : α) : compress u v (compress u v a) = compress u v a 
Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/FourFunctions.lean - 2024-08-20 15:38:47.030264.
---0/3204---
Verifying proof:
:= by
  refine le_trans?_ (mul_le_mul_of_nonneg_right h₁ h₂ h₃ h₄)
  refine le_trans?_ (mul_le_mul_of_nonneg_right h₁ h₂ h₃ h₄)
  rw [mul_comm]
  exact mul_le_mul_of_nonneg_left h₁ h₂ h₃ h₄

For theorem:
lemma Finset.four_functions_theorem (u : Finset α)
    (h₁ : 0 ≤ f₁) (h₂ : 0 ≤ f₂) (h₃ : 0 ≤ f₃) (h₄ : 0 ≤ f₄)
    (h : ∀ ⦃s⦄, s ⊆ u → ∀ ⦃t⦄, t ⊆ u → f₁ s * f₂ t ≤ f₃ (s ∩ t) * f₄ (s ∪ t))
    {𝒜 ℬ : Finset (Finset α)} (h𝒜 : 𝒜 ⊆ u.powerset) (hℬ : ℬ ⊆ u.powerset) :
    (∑ s ∈ 𝒜, f₁ s) * ∑ s ∈ ℬ, f₂ s ≤ (∑ s ∈ 𝒜 ⊼ ℬ, f₃ s) * ∑ s ∈ 𝒜 ⊻ ℬ, f₄ s 
Attempt failure.

---0/3204---
Verifying proof:
:=
  le_of_pow_le_pow_left two_ne_zero (zero_le _) # by
    simpa [← sq] using s.le_card_diffs_mul_card_diffs s

For theorem:
lemma Finset.card_le_card_diffs (s : Finset α) : s.card ≤ (s \\ s).card 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  subst hts
  rw [collapse_eq ha, if_pos ht]
  split_ifs
  · exact le_collapse_of_mem ha ht

For theorem:
lemma le_collapse_of_mem (ha : a ∉ s) (hf : 0 ≤ f) (hts : t = s) (ht : t ∈ 𝒜) :
    f t ≤ collapse 𝒜 a f s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : ∀ s t : Finset α, (s \ᵥ t).map ⟨_, liftLatticeHom_injective⟩ := fun s t hst =>
    le_trans (mul_le_mul_of_nonneg_right <| card_nonneg _) (card_nonneg _)
  have : ∀ s t : Finset α, (s \\ t).map ⟨_, liftLatticeHom_injective⟩ := fun s t hst =>
    le_trans (mul_le_mul_of_nonneg_right <| card_nonneg _) (card_nonneg _)
  have : ∀ s t : Finset α, (s \\ t).map ⟨_, liftLatticeHom_injective⟩ := fun s t ht =>
    le_trans (mul_le_mul_of_nonneg_right <| card_nonneg _) (card_nonneg _)
  have : ∀ s t : Finset α, (s \\ t).map ⟨_, liftLatticeHom_injective⟩ := fun s t hst =>
    le_trans (mul_le_mul_of_nonneg_right <| card_nonneg _) (card_nonneg _)
  have : ∀ s t : Finset α, (s \\ t).map ⟨_, liftLatticeHom_injective⟩ := fun s t hst =>
    le_trans (mul_le_mul_of_nonneg_right <| card_nonneg _) (card_nonneg _)
  have : ∀ s t : Finset α, (s \\ t).map ⟨_, liftLatticeHom_injective⟩ := fun s t hst =>
    le_trans (mul_le_mul_of_nonneg_right <| card_nonneg _) (card_nonneg

For theorem:
lemma Finset.le_card_diffs_mul_card_diffs (s t : Finset α) :
    s.card * t.card ≤ (s \\ t).card * (t \\ s).card 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a 

For theorem:
lemma holley (hμ₀ : 0 ≤ μ) (hf : 0 ≤ f) (hg : 0 ≤ g) (hμ : Monotone μ)
    (hfg : ∑ a, f a = ∑ a, g a) (h : ∀ a b, f a * g b ≤ f (a ⊓ b) * g (a ⊔ b)) :
    ∑ a, μ a * f a ≤ ∑ a, μ a * g a 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a _ =>?_
  refine Finset.sum_le_sum fun a 

For theorem:
lemma holley (hμ₀ : 0 ≤ μ) (hf : 0 ≤ f) (hg : 0 ≤ g) (hμ : Monotone μ)
    (hfg : ∑ a, f a = ∑ a, g a) (h : ∀ a b, f a * g b ≤ f (a ⊓ b) * g (a ⊔ b)) :
    ∑ a, μ a * f a ≤ ∑ a, μ a * g a 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  calc
    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s := sum_collapse_of_not_mem h𝒜 hu
    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s := sum_collapse_of_not_mem h𝒜 hu
    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s := sum_collapse_of_not_mem h𝒜 hu
    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s := sum_collapse_of_not_mem h𝒜 hu
    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s := sum_collapse_of_not_mem h𝒜 hu
    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s := sum_collapse_of_not_mem h𝒜 hu
    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s := sum_collapse_of_not_mem h𝒜 hu
    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s := sum_collapse_of_not_mem h𝒜 hu
    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s := sum_collapse_of_not_mem h𝒜 hu
    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s := sum_collapse_of_not_mem h𝒜 hu
    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s := sum_collapse_of_not_mem h𝒜 hu
    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s := sum_collapse_of_not_mem h𝒜 hu
    _ = ∑ s ∈ u.powerset ∩ 𝒜, f s := sum_collapse_of_

For theorem:
lemma sum_collapse (h𝒜 : 𝒜 ⊆ (insert a u).powerset) (hu : a ∉ u) :
    ∑ s ∈ u.powerset, collapse 𝒜 a f s = ∑ s ∈ 𝒜, f s 
Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/HarrisKleitman.lean - 2024-08-20 15:39:22.870701.
---0/3204---
Verifying proof:
:= by
  refine le_trans?_ (card_le_card inter_subset_left)
  rw [card_inter_of_injOn inter_subset_left, card_inter_of_injOn inter_subset_left,
    card_inter_of_injOn inter_subset_left, card_inter_of_injOn inter_subset_right,
    card_inter_of_injOn inter_subset_right, card_inter_of_injOn inter_subset_right,
    card_inter_of_injOn inter_subset_right, card_inter_of_injOn inter_subset_right,
    card_inter_of_injOn inter_subset_right, card_inter_of_injOn inter_subset_right,
    card_inter_of_injOn inter_subset_right, card_inter_of_injOn inter_subset_right,
    card_inter_of_injOn inter_subset_right, card_inter_of_injOn inter_subset_right,
    card_inter_of_injOn inter_subset_right, card_inter_of_injOn inter_subset_right,
    card_inter_of_injOn inter_subset_right, card_inter_of_injOn inter_subset_right,
    card_inter_of_injOn inter_subset_right, card_inter_of_injOn inter_subset_right,
    card_inter_of_injOn inter_subset_right, card_inter_of_injOn inter_subset_right,
    card_inter_of_injOn inter_subset_rig

For theorem:
theorem IsUpperSet.le_card_inter_finset (h𝒜 : IsUpperSet (𝒜 : Set (Finset α)))
    (hℬ : IsUpperSet (ℬ : Set (Finset α))) :
    𝒜.card * ℬ.card ≤ 2 ^ Fintype.card α * (𝒜 ∩ ℬ).card 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine le_card_inter_finset' h𝒜 h𝒜s (fun t ht ↦?_) (fun t ht ↦?_)
  · simp only [card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht,
      card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht,
      card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht,
      card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht,
      card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht,
      card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht,
      card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht,
      card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht,
      card_inter_of_not_mem h𝒜s ht, card_inter_of_not_mem h𝒜s ht, card_inter_of_n

For theorem:
theorem IsLowerSet.le_card_inter_finset' (h𝒜 : IsLowerSet (𝒜 : Set (Finset α)))
    (hℬ : IsLowerSet (ℬ : Set (Finset α))) (h𝒜s : ∀ t ∈ 𝒜, t ⊆ s) (hℬs : ∀ t ∈ ℬ, t ⊆ s) :
    𝒜.card * ℬ.card ≤ 2 ^ s.card * (𝒜 ∩ ℬ).card 
Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Intersecting.lean - 2024-08-20 15:39:25.041216.
---0/3204---
Verifying proof:
:= by
  have := hs.card_le
  rw [mul_comm, ← Nat.card_eq_fintype_card, ← Nat.card_eq_fintype_card, ← Nat.card_eq_fintype_card,
    Nat.card_eq_fintype_card, Fintype.card_fin, Fintype.card_pos_iff] at this
  refine ⟨fun h =>?_, fun h =>?_⟩
  · rintro ⟨t, ht, hts⟩
    exact ⟨t, subset_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq 

For theorem:
theorem Intersecting.exists_card_eq (hs : (s : Set α).Intersecting) :
    ∃ t, s ⊆ t ∧ 2 * t.card = Fintype.card α ∧ (t : Set α).Intersecting 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have := hs.card_le
  rw [mul_comm, ← Nat.card_eq_fintype_card, ← Nat.card_eq_fintype_card, ← Nat.card_eq_fintype_card,
    Nat.card_eq_fintype_card, Fintype.card_fin, Fintype.card_pos_iff] at this
  refine ⟨fun h =>?_, fun h =>?_⟩
  · rintro ⟨t, ht, hts⟩
    exact ⟨t, subset_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq_two_mul_card_eq 

For theorem:
theorem Intersecting.exists_card_eq (hs : (s : Set α).Intersecting) :
    ∃ t, s ⊆ t ∧ 2 * t.card = Fintype.card α ∧ (t : Set α).Intersecting 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  classical
  refine (s.disjUnion _ hs.disjoint_map_compl).card_le_univ.trans?_
  refine (s.disjUnion _ hs.disjoint_map_compl).card_le_univ

For theorem:
theorem Intersecting.card_le [Fintype α] {s : Finset α} (hs : (s : Set α).Intersecting) :
    2 * s.card ≤ Fintype.card α 
Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Kleitman.lean - 2024-08-20 15:39:28.411649.
---0/3204---
Verifying proof:
:= by
  refine card_biUnion_le_of_intersecting hf fun i hi =>?_
  refine card_le_card_of_injOn (fun i hi =>?_) (fun i hi =>?_) (fun i hi =>?_) (fun i hi =>?_)
  simp only [Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi,
    Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi,
    Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi,
    Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi,
    Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi,
    Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi,
    Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi, Finset.card_singleton,
    Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi,
    Finset.card_image_of_injOn hi, Finset.card_image_of_injOn hi, Finset.card_sing

For theorem:
theorem Finset.card_biUnion_le_of_intersecting (s : Finset ι) (f : ι → Finset (Finset α))
    (hf : ∀ i ∈ s, (f i : Set (Finset α)).Intersecting) :
    (s.biUnion f).card ≤ 2 ^ Fintype.card α - 2 ^ (Fintype.card α - s.card) 
Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/LYM.lean - 2024-08-20 15:39:29.334376.
---0/3204---
Verifying proof:
:= by
  let i : DecidableRel ((. ⊆.) : Finset α) : Finset α := by
    refine card_mul_le_card_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul h𝒜

For theorem:
theorem card_mul_le_card_shadow_mul (h𝒜 : (𝒜 : Set (Finset α)).Sized r) :
    𝒜.card * r ≤ (∂ 𝒜).card * (Fintype.card α - r + 1) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine card_div_choose_le_card_shadow_div_card_shadow_div_choose_le_card_shadow_div_choose_right h𝒜?_
  refine card_div_choose_le_card_shadow_div_choose_le_card_shadow_div_choose_right h𝒜?_?_
  · simp only [card_div_choose_right h𝒜 hr, card_shadow_div_choose_right h𝒜 h𝒜 h𝒜,
      card_shadow_div_choose_right h𝒜 h𝒜]
    exact card_div_choose_le_card_shadow_div_choose_right h𝒜 h𝒜 hr

For theorem:
theorem card_div_choose_le_card_shadow_div_choose (hr : r ≠ 0)
    (h𝒜 : (𝒜 : Set (Finset α)).Sized r) : (𝒜.card : 𝕜) / (Fintype.card α).choose r
    ≤ (∂ 𝒜).card / (Fintype.card α).choose (r - 1) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let i : DecidableRel ((· ⊆ ·) : Finset α) : Finset α := by
    refine card_mul_le_card_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mul_shadow_mu

For theorem:
theorem card_mul_le_card_shadow_mul (h𝒜 : (𝒜 : Set (Finset α)).Sized r) :
    𝒜.card * r ≤ (∂ 𝒜).card * (Fintype.card α - r + 1) 
Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Shadow.lean - 2024-08-20 15:39:33.978860.
---0/3204---
Verifying proof:
:= by
  induction' k with k ih generalizing t
  · simp
  simp only [mem_shadow_iterate_iff_exists_card, mem_union, mem_sup, mem_shadow_iterate_iff_exists_card]

For theorem:
lemma mem_shadow_iterate_iff_exists_card :
    t ∈ ∂^[k] 𝒜 ↔ ∃ u : Finset α, u.card = k ∧ Disjoint t u ∧ t ∪ u ∈ 𝒜 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp_rw [mem_upShadow_iff_exists_sdiff, ← covby_iff_card_sdiff_eq_one, covby_iff_exists_erase]

For theorem:
lemma mem_upShadow_iff_erase_mem : t ∈ ∂⁺ 𝒜 ↔ ∃ a, a ∈ t ∧ erase t a ∈ 𝒜 
Attempt failure.

Working on Mathlib/Combinatorics/SetFamily/Shatter.lean - 2024-08-20 15:39:39.664902.
---0/3204---
Verifying proof:
:= by
  refine memberFamily_induction_on 𝒜?_?_?_
  · simp
  · rfl
    intros a 𝒜 ih₀ ih₁
    simp
  · rfl

For theorem:
lemma card_le_card_shatterer (𝒜 : Finset (Finset α)) : 𝒜.card ≤ 𝒜.shatterer.card 
Attempt failure.

---0/3204---
Verifying proof:
:=
  ⟨fun ht ↦ h ht, by rintro ⟨u, _, rfl⟩; exact inter_subset_left _ _⟩

For theorem:
lemma Shatters.subset_iff (h : 𝒜.Shatters s) : t ⊆ s ↔ ∃ u ∈ 𝒜, s ∩ u = t 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine memberFamily_induction_on 𝒜?_?_?_
  · simp
  · rfl
    intros a 𝒜 ih₀ ih₁
    simp
  · rfl

For theorem:
lemma card_le_card_shatterer (𝒜 : Finset (Finset α)) : 𝒜.card ≤ 𝒜.shatterer.card 
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean - 2024-08-20 15:39:43.273823.
---0/3204---
Verifying proof:
:=
  { zero_or_one := fun i j => by by_cases G.Adj i j <;> simp [h] }

For theorem:
theorem isAdjMatrix_adjMatrix [Zero α] [One α] : (G.adjMatrix α).IsAdjMatrix 
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Basic.lean - 2024-08-20 15:39:45.463442.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun _ => ⟨G.ne_of_adj ‹_›, ⟦(v, w)⟧, by simpa⟩,?_⟩
  rintro ⟨h₁, h₂⟩
  refine ⟨G.ne_of_adj ‹_›, ⟨G.ne_of_adj ‹_›,?_⟩,?_⟩
  rintro ⟨h₁, h₂⟩
  refine ⟨G.ne_of_adj ‹_›, ⟨G.ne_of_adj ‹_›,?_⟩,?_⟩
  rintro ⟨h₁, h₂⟩
  refine ⟨G.ne_of_adj ‹_›, ⟨G.ne_of_adj ‹_›,?_⟩,?_⟩
  rintro ⟨h₁, h₂⟩
  refine ⟨G.ne_of_adj ‹_›, ⟨G.ne_of_adj ‹_›,?_⟩,?_⟩
  rintro ⟨h₁, h₂⟩
  refine ⟨G.ne_of_adj ‹_›, ⟨G.ne_of_adj ‹_›,?_⟩,?_⟩
  rintro ⟨h₁, h₂⟩
  refine ⟨G.ne_of_adj ‹_›, ⟨G.ne_of_adj ‹_›,?_⟩,?_⟩
  rintro ⟨h₁, h₂⟩
  refine ⟨G.ne_of_adj ‹_›, ⟨G.ne_of_adj ‹_›,?_⟩,?_⟩
  rintro ⟨h₁, h₂⟩
  refine ⟨G.ne_of_adj ‹_›, ⟨G.ne_of_adj ‹_›,?_⟩,?_⟩
  rintro ⟨h₁, h₂⟩
  refine ⟨G.ne_of_adj ‹_›, ⟨G.ne_of_adj ‹_›,?_⟩,?_⟩
  rintro ⟨h₁, h₂⟩
  refine ⟨G.ne_of_adj ‹_›, ⟨G.ne_of_adj 

For theorem:
theorem adj_iff_exists_edge {v w : V} : G.Adj v w ↔ v ≠ w ∧ ∃ e ∈ G.edgeSet, v ∈ e ∧ w ∈ e 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext e
  refine Sym2.ind?_ e
  simp

For theorem:
theorem edgeSet_deleteEdges (s : Set (Sym2 V)) : (G.deleteEdges s).edgeSet = G.edgeSet \ s 
Attempt failure.

---0/3204---
Verifying proof:
:=
  Set.inter_subset_left

For theorem:
theorem commonNeighbors_subset_neighborSet_left (v w : V) :
    G.commonNeighbors v w ⊆ G.neighborSet v 
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Clique.lean - 2024-08-20 15:39:53.132188.
---0/3204---
Verifying proof:
:= by
  rw [isClique_iff]
  constructor
  · intro h
    ext ⟨v, hv⟩ ⟨w, hw⟩
    simp only [comap_Adj, Subtype.coe_mk, top_adj]
    simp only [comap_Adj, Subtype.coe_mk, top_adj]

For theorem:
theorem isClique_iff_induce_eq : G.IsClique s ↔ G.induce s = ⊤ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro hG s hs
  obtain ⟨t, hts, ht⟩ := s.exists_smaller_set _ (h.trans hs.card_eq.ge)
  sort

For theorem:
theorem CliqueFree.mono (h : m ≤ n) : G.CliqueFree m → G.CliqueFree n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h ↦?_,?_,?_,?_⟩
  · obtain ⟨a, b, c, -, -, -, hs⟩ := card_eq_card_iff_exists_sdiff.1 hs
    refine ⟨a, b, c, -, -, -, hs⟩ := card_eq_card_iff_exists_sdiff.2 ⟨a, b, c, -, -, hs⟩,?_⟩
  · obtain ⟨a, b, c, -, -, -, hs⟩ := card_eq_card_iff_exists_sdiff.1 hs
    refine ⟨a, b, c, -, -, -, hs⟩ := card_eq_card_iff_exists_sdiff.2 ⟨a, b, c, -, -, hs⟩
    refine ⟨a, b, c, -, -, -, hs⟩ := card_eq_card_iff_exists_sdiff.2 ⟨a, b, c, -, -, hs⟩,?_⟩
  · obtain ⟨a, b, c, -, -, -, hs⟩ := card_eq_card_iff_exists_sdiff.1 hs
    refine ⟨a, b, c, -, -, -, hs⟩ := card_eq_card_iff_exists_sdiff.2 ⟨a, b, c, -, hs⟩
    refine ⟨a, b, c, -, -, -, hs⟩
    refine ⟨a, b, c, -, -, -, hs⟩ := card_eq_card_iff_exists_sdiff.2 ⟨a, b, c, -, hs⟩
    refine ⟨a, b, c, -, -, -, hs⟩
    refine ⟨a, b, c, -, -, -, hs⟩
    refine ⟨a, b, c, -, -, -, hs⟩
    refine ⟨a, b, c, -, -, -, hs⟩
    refine ⟨a, b, c, -, -, -, hs⟩
    refine ⟨a, b, c, -,

For theorem:
theorem is3Clique_iff :
    G.IsNClique 3 s ↔ ∃ a b c, G.Adj a b ∧ G.Adj a c ∧ G.Adj b c ∧ s = {a, b, c} 
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Connectivity.lean - 2024-08-20 15:40:03.787113.
---0/3204---
Verifying proof:
:= by
  induction p with
  | nil => rfl
  | cons _ _ ih =>
    simp only [bypass]
    simp only [bypass]
    split_ifs
    · trans
    · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      · trans
      ·

For theorem:
theorem length_bypass_le {u v : V} (p : G.Walk u v) : p.bypass.length ≤ p.length 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [Walk.toDeleteEdges, List.map_cons, List.map_cons, List.map_cons, List.map_cons,
    List.map_cons, List.map_cons, List.map_map]

For theorem:
theorem toDeleteEdges_cons (s : Set (Sym2 V)) {u v w : V} (h : G.Adj u v) (p : G.Walk v w) (hp) :
    (Walk.cons h p).toDeleteEdges s hp =
      Walk.cons (deleteEdges_adj.mpr ⟨h, hp _ (List.Mem.head _)⟩)
        (p.toDeleteEdges s fun _ he => hp _ <| List.Mem.tail _ he) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases p <;> simp

For theorem:
lemma nil_iff_support_eq {p : G.Walk v w} : p.Nil ↔ p.support = [v] 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp [mem_verts_toSubgraph]

For theorem:
lemma end_mem_verts_toSubgraph (p : G.Walk u v) : v ∈ p.toSubgraph.verts 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine C.ind?_
  exact fun _ => rfl

For theorem:
theorem map_comp (C : G.ConnectedComponent) (φ : G →g G') (ψ : G' →g G'') :
    (C.map φ).map ψ = C.map (ψ.comp φ) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← length_cons, cons_tail_eq]

For theorem:
lemma length_tail_add_one {p : G.Walk x y} (hp : ¬ p.Nil) :
    (p.tail hp).length + 1 = p.length 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  induction p with
  | nil => simp!
  | cons _ _ ih => simp!
  | cons _ _ ih => simp!
  | cons _ _ ih => simp [ih, Nat.add_assoc]
  | cons _ _ ih => simp [ih, Nat.add_right_comm]
  | cons _ _ ih => simp!
  | cons _ _ ih => simp [ih, Nat.add_assoc]
  | cons _ _ ih => simp [ih, Nat.add_assoc, Nat.add_left_comm]

For theorem:
theorem length_reverseAux {u v w : V} (p : G.Walk u v) (q : G.Walk u w) :
    (p.reverseAux q).length = p.length + q.length 
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Density.lean - 2024-08-20 15:40:50.795393.
---0/3204---
Verifying proof:
:= by
  refine le_trans (edgeDensity_sub_edgeDensity_sub_edgeDensity_le_one_sub_mul hs ht hs₂ ht₂)?_
  rw [edgeDensity_sub_edgeDensity_sub_edgeDensity_le_one_sub_mul hs ht hs₂ ht₂ ht₁,
    edgeDensity_sub_edgeDensity_sub_edgeDensity_le_one_sub_mul hs hs₂ ht₂ ht₁,
    edgeDensity_sub_edgeDensity_sub_edgeDensity_le_one_sub_mul hs hs₂ ht₂ ht₁,
    edgeDensity_sub_edgeDensity_le_one_sub_mul hs hs₂ hs₂ ht₂ ht₁, sub_le_sub_iff_right]
  refine le_trans (edgeDensity_sub_edgeDensity_le_one_sub_mul hs hs₂ ht ht₂)?_
  rw [edgeDensity_sub_edgeDensity_sub_edgeDensity_le_one_sub_mul hs hs₂ ht₂ ht₁,
    edgeDensity_sub_edgeDensity_sub_edgeDensity_le_one_sub_mul hs hs₂ ht₂ ht₁,
    edgeDensity_sub_edgeDensity_sub_edgeDensity_le_one_sub_mul hs hs₂ ht₂ ht₁,
    edgeDensity_sub_edgeDensity_sub_edgeDensity_le_one_sub_mul hs hs₂ ht₂ ht₁,
    edgeDensity_sub_edgeDensity_sub_edgeDensity_le_one_sub_mul hs hs₂ ht₂ ht₁,
    edgeDensity_sub_edgeDensity_le_one_sub_mul hs

For theorem:
theorem edgeDensity_sub_edgeDensity_le_one_sub_mul (hs : s₂ ⊆ s₁) (ht : t₂ ⊆ t₁) (hs₂ : s₂.Nonempty)
    (ht₂ : t₂.Nonempty) :
    edgeDensity r s₂ t₂ - edgeDensity r s₁ t₁ ≤ 1 - s₂.card / s₁.card * (t₂.card / t₁.card) 
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Ends/Defs.lean - 2024-08-20 15:40:53.876451.
---0/3204---
Verifying proof:
:= by
  classical
  constructor
  · intro h
    refine ⟨fun h L hL =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_⟩
    rw [Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup,
      Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup,
      Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup]
    rintro ⟨L, hL⟩
    rw [Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup,
      Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup,
      Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup,
      Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup,
      Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup]
    rintro ⟨L, hL⟩
    refine ⟨fun h =>?_, fun ⟨D, hD⟩ =>?_⟩
    rw [Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup, Finset.sup_eq_iSup,
      Finset.sup_eq_iSup, Finset.sup_eq_iSup

For theorem:
theorem infinite_iff_in_all_ranges {K : Finset V} (C : G.ComponentCompl K) :
    C.supp.Infinite ↔ ∀ (L) (h : K ⊆ L), ∃ D : G.ComponentCompl L, D.hom h = C 
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Finsubgraph.lean - 2024-08-20 15:40:55.690480.
---0/3204---
Verifying proof:
:= by
  cases nonempty_fintype W
  cases nonempty_fintype W
  haveI : ∀ G' : G.Finsubgraph, G'.Finsubgraph → G'.Finsubgraph → G'.Finsubgraph := by
    intro G'
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG

For theorem:
theorem nonempty_hom_of_forall_finite_subgraph_hom [Finite W]
    (h : ∀ G' : G.Subgraph, G'.verts.Finite → G'.coe →g F) : Nonempty (G →g F) := by
    cases nonempty_fintype W
    haveI : ∀ G' : G.Finsubgraphᵒᵖ, Nonempty ((finsubgraphHomFunctor G F).obj G') := fun G' =>
    ⟨h G'.unop G'.unop.property⟩
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases nonempty_fintype W
  cases nonempty_fintype W
  haveI : ∀ G' : G.Finsubgraph, G'.Finsubgraph → G'.Finsubgraph → G'.Finsubgraph := by
    intro G'
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG' =>?_⟩
    refine ⟨fun hG

For theorem:
theorem nonempty_hom_of_forall_finite_subgraph_hom [Finite W]
    (h : ∀ G' : G.Subgraph, G'.verts.Finite → G'.coe →g F) : Nonempty (G →g F) := by
    cases nonempty_fintype W
    haveI : ∀ G' : G.Finsubgraphᵒᵖ, Nonempty ((finsubgraphHomFunctor G F).obj G') := fun G' =>
    ⟨h G'.unop G'.unop.property⟩
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/IncMatrix.lean - 2024-08-20 15:40:58.489192.
---0/3204---
Verifying proof:
:= by
  classical
  refine e.ind?_
  intro a b h
  rw [mem_edgeSet] at h
  rw [mem_edgeSet] at h
  rw [mem_edgeSet] at h
  rw [mem_edgeSet] at h

For theorem:
theorem sum_incMatrix_apply_of_mem_edgeSet [Fintype α] :
    e ∈ G.edgeSet → ∑ a, G.incMatrix R a e = 2 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  unfold incMatrix Set.incMatrix Set.indicator e
  simp only [incMatrix, Set.mem_setOf_eq, Set.mem_inter_iff, Set.mem_singleton_iff,
    Set.mem_inter_iff, Set.mem_singleton_iff]

For theorem:
theorem incMatrix_apply' [Zero R] [One R] [DecidableEq α] [DecidableRel G.Adj] {a : α}
    {e : Sym2 α} : G.incMatrix R a e = if e ∈ G.incidenceSet a then 1 else 0 
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Operations.lean - 2024-08-20 15:41:02.073225.
---0/3204---
Verifying proof:
:= by simp [hw]

For theorem:
lemma adj_replaceVertex_iff_of_ne_left {w : V} (hw : w ≠ t) :
    (G.replaceVertex s t).Adj s w ↔ G.Adj s w 
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Regularity/Chunk.lean - 2024-08-20 15:41:04.641927.
---0/3204---
Verifying proof:
:= by
  refine le_trans?_ (mul_le_mul_of_nonneg_right (by positivity) (by positivity))
    (mul_le_mul_of_nonneg_right (by positivity) (by positivity))

For theorem:
theorem one_sub_eps_mul_card_nonuniformWitness_le_card_star (hV : V ∈ P.parts)
    (hUV : U ≠ V) (hunif : ¬G.IsUniform ε U V) (hPε : ↑100 ≤ ↑4 ^ P.parts.card * ε ^ 5)
    (hε₁ : ε ≤ 1) :
    (1 - ε / 10) * (G.nonuniformWitness ε U V).card ≤ ((star hP G ε hU V).biUnion id).card 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine le_trans?_ (m_add_one_div_m_le_one_div_m_le_one hPα hPε hε₁)
  rw [← Nat.cast_one, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,
    ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul, ← Nat.cast_mul,

For theorem:
theorem m_add_one_div_m_le_one_add [Nonempty α]
    (hPα : P.parts.card * 16 ^ P.parts.card ≤ card α) (hPε : ↑100 ≤ ↑4 ^ P.parts.card * ε ^ 5)
    (hε₁ : ε ≤ 1) : ((m + 1 : ℝ) / m) ^ 2 ≤ ↑1 + ε ^ 5 / 49 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [sum_card_subset_chunk hU G ε hU]
  exact card_subset_chunk h𝒜 hs

For theorem:
theorem sum_card_subset_chunk_parts_le (m_pos : (0 : ℝ) < m)
    (h𝒜 : 𝒜 ⊆ (chunk hP G ε hU).parts) (hs : s ∈ 𝒜) :
    ((𝒜.sup id).card : ℝ) ≤ 𝒜.card * s.card * ((m + 1) / m) 
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean - 2024-08-20 15:41:30.350386.
---0/3204---
Verifying proof:
:= by
  refine ⟨∅, by simp,?_,?_⟩
  · rintro ⟨Q, hQ, rfl⟩
    refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
    · simp only [Finset.mem_empty_iff_false, iff_false_iff, not_and, not_forall, not_false_eq_true,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
    · simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
 

For theorem:
theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    ∃ Q : Finpartition s,
      (∀ x : Finset α, x ∈ Q.parts → x.card = m ∨ x.card = m + 1) ∧
        (∀ x, x ∈ P.parts → (x \ (Q.parts.filter fun y => y ⊆ x).biUnion id).card ≤ m) ∧
          (Q.parts.filter fun i => card i = m + 1).card = b := by
    obtain rfl | m_pos 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨∅, by simp,?_,?_⟩
  · rintro ⟨Q, hQ, rfl⟩
    refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
    · simp only [Finset.mem_empty_iff_false, iff_false_iff, not_and, not_forall, not_false_eq_true,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
    · simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
 

For theorem:
theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    ∃ Q : Finpartition s,
      (∀ x : Finset α, x ∈ Q.parts → x.card = m ∨ x.card = m + 1) ∧
        (∀ x, x ∈ P.parts → (x \ (Q.parts.filter fun y => y ⊆ x).biUnion id).card ≤ m) ∧
          (Q.parts.filter fun i => card i = m + 1).card = b := by
    obtain rfl | m_pos 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨∅, by simp,?_,?_⟩
  · rintro ⟨Q, hQ, rfl⟩
    refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
    · simp only [Finset.mem_empty_iff_false, iff_false_iff, not_and, not_forall, not_false_eq_true,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
    · simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
 

For theorem:
theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    ∃ Q : Finpartition s,
      (∀ x : Finset α, x ∈ Q.parts → x.card = m ∨ x.card = m + 1) ∧
        (∀ x, x ∈ P.parts → (x \ (Q.parts.filter fun y => y ⊆ x).biUnion id).card ≤ m) ∧
          (Q.parts.filter fun i => card i = m + 1).card = b := by
    obtain rfl | m_pos 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨∅, by simp,?_,?_⟩
  · rintro ⟨Q, hQ, rfl⟩
    refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
    · simp only [Finset.mem_empty_iff_false, iff_false_iff, not_and, not_forall, not_false_eq_true,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
    · simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
 

For theorem:
theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    ∃ Q : Finpartition s,
      (∀ x : Finset α, x ∈ Q.parts → x.card = m ∨ x.card = m + 1) ∧
        (∀ x, x ∈ P.parts → (x \ (Q.parts.filter fun y => y ⊆ x).biUnion id).card ≤ m) ∧
          (Q.parts.filter fun i => card i = m + 1).card = b := by
    obtain rfl | m_pos 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨∅, by simp,?_,?_⟩
  · rintro ⟨Q, hQ, rfl⟩
    refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
    · simp only [Finset.mem_empty_iff_false, iff_false_iff, not_and, not_forall, not_false_eq_true,
      forall_exists_index, and_imp, forall_apply_eq_imp_iff⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
    · simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
      rintro ⟨Q, hQ, rfl⟩
      refine ⟨Q, fun x hx =>?_, fun x hx =>?_⟩
      simp only [Finset.mem_empty_iff_false, imp_false, imp_true_iff]
 

For theorem:
theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    ∃ Q : Finpartition s,
      (∀ x : Finset α, x ∈ Q.parts → x.card = m ∨ x.card = m + 1) ∧
        (∀ x, x ∈ P.parts → (x \ (Q.parts.filter fun y => y ⊆ x).biUnion id).card ≤ m) ∧
          (Q.parts.filter fun i => card i = m + 1).card = b := by
    obtain rfl | m_pos 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← pos_iff_ne_zero] at hn
  have : (n - s.card).Nonempty := Nat.sub_pos_of_lt hn
  have : (n - s.card).Nonempty := Nat.pos_of_ne_zero hn
  have : (n - s.card).Nonempty := Nat.sub_pos_of_lt hn
  have : (n - s.card).Nonempty := Nat.pos_of_ne_zero hn
  have : (n - s.card).Nonempty := Nat.pos_of_ne_zero hn
  have : (n - s.card).Nonempty := Nat.sub_pos_of_lt hn
  have : (n - s.card).Nonempty := Nat.pos_of_ne_zero hn
  have : (n - s.card).Nonempty := Nat.pos_of_ne_zero hn
  have : (n - s.card).Nonempty := Nat.sub_pos_of_lt hn
  have : (n - s.card).Nonempty := Nat.pos_of_ne_zero hn
  have : (n - s.card).Nonempty := Nat.sub_pos_of_lt hn
  have : (n - s.card).Nonempty := Nat.pos_of_ne_zero hn
  have : (n - s.card).Nonempty := Nat.pos_of_ne_zero hn
  have : (n - s.card).Nonempty := Nat.sub_pos_of_lt hn
  have : (n - s.card).Nonempty := Nat.pos_of_ne_zero hn
  have : (n - s.card).Nonempty := Nat.pos_of_ne_zero hn
  have : (n - s.card).Nonempty := Nat.sub_pos_of_lt hn
  have : (n - s.card).Nonempty := by
  

For theorem:
theorem exists_equipartition_card_eq (hn : n ≠ 0) (hs : n ≤ s.card) :
    ∃ P : Finpartition s, P.IsEquipartition ∧ P.parts.card = n 
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Regularity/Increment.lean - 2024-08-20 15:41:41.095062.
---0/3204---
Verifying proof:
:= by
  simp only [distinctPairs, Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint,
    Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint,
    Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint,
    Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint,
    Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint,
    Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint,
    Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint,
    Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint,
    Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint,
    Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint,
    Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint,
    Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint,
    Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint,
    Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseD

For theorem:
lemma pairwiseDisjoint_distinctPairs :
    (P.parts.offDiag.attach : Set {x // x ∈ P.parts.offDiag}).PairwiseDisjoint
      (distinctPairs hP G ε) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp (config := { contextual := true }) [distinctPairs, Set.PairwiseDisjoint]

For theorem:
lemma pairwiseDisjoint_distinctPairs :
    (P.parts.offDiag.attach : Set {x // x ∈ P.parts.offDiag}).PairwiseDisjoint
      (distinctPairs hP G ε) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [distinctPairs, Set.PairwiseDisjoint, Set.PairwiseDisjoint, Set.PairwiseDisjoint,
    Set.PairwiseDisjoint, Set.PairwiseDisjoint]

For theorem:
lemma pairwiseDisjoint_distinctPairs :
    (P.parts.offDiag.attach : Set {x // x ∈ P.parts.offDiag}).PairwiseDisjoint
      (distinctPairs hP G ε) 
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Regularity/Lemma.lean - 2024-08-20 15:41:55.773208.
---0/3204---
Verifying proof:
:= by
  obtain ⟨P, hP₁, hP₂, hP₃⟩ := exists_isEquipartition_of_lt_card hε hl
  obtain ⟨P, hP₁, hP₂, hP₃⟩ := exists_isEquipartition_of_lt_card hε hl
  obtain ⟨P, hP₁, hP₂, hP₃⟩ := exists_isEquipartition_of_lt_card hε hl
  refine ⟨P.parts.card,?_,?_,?_⟩
  · rintro ⟨P, hP₁, hP₂, hP₃⟩
    exact ⟨P, hP₁, hP₂, hP₃⟩

For theorem:
theorem szemeredi_regularity (hε : 0 < ε) (hl : l ≤ card α) :
    ∃ P : Finpartition univ,
      P.IsEquipartition ∧ l ≤ P.parts.card ∧ P.parts.card ≤ bound ε l ∧ P.IsUniform G ε 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨P, hP₁, hP₂, hP₃⟩ := exists_isEquipartition_of_lt_card hε hl
  obtain ⟨P, hP₁, hP₂, hP₃⟩ := exists_isEquipartition_of_lt_card hε hl
  obtain ⟨P, hP₁, hP₂, hP₃⟩ := exists_isEquipartition_of_lt_card hε hl
  refine ⟨P.parts.card,?_,?_,?_⟩
  · rintro ⟨P, hP₁, hP₂, hP₃⟩
    exact ⟨P, hP₁, hP₂, hP₃⟩

For theorem:
theorem szemeredi_regularity (hε : 0 < ε) (hl : l ≤ card α) :
    ∃ P : Finpartition univ,
      P.IsEquipartition ∧ l ≤ P.parts.card ∧ P.parts.card ≤ bound ε l ∧ P.IsUniform G ε 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨P, hP₁, hP₂, hP₃⟩ := exists_isEquipartition_of_lt_card hε hl
  obtain ⟨P, hP₁, hP₂, hP₃⟩ := exists_isEquipartition_of_lt_card hε hl
  obtain ⟨P, hP₁, hP₂, hP₃⟩ := exists_isEquipartition_of_lt_card hε hl
  refine ⟨P.parts.card,?_,?_,?_⟩
  · rintro ⟨P, hP₁, hP₂, hP₃⟩
    exact ⟨P, hP₁, hP₂, hP₃⟩

For theorem:
theorem szemeredi_regularity (hε : 0 < ε) (hl : l ≤ card α) :
    ∃ P : Finpartition univ,
      P.IsEquipartition ∧ l ≤ P.parts.card ∧ P.parts.card ≤ bound ε l ∧ P.IsUniform G ε 
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Subgraph.lean - 2024-08-20 15:42:02.907611.
---0/3204---
Verifying proof:
:= by
  revert hv
  refine Sym2.ind (fun v w he ↦?_) e he

For theorem:
theorem mem_verts_if_mem_edge {G' : Subgraph G} {e : Sym2 V} {v : V} (he : e ∈ G'.edgeSet)
    (hv : v ∈ e) : v ∈ G'.verts 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  revert hv
  refine Sym2.ind (fun v w he ↦?_) e he
  intro he
  refine Sym2.ind (fun v w he ↦?_) e he

For theorem:
theorem mem_verts_if_mem_edge {G' : Subgraph G} {e : Sym2 V} {v : V} (he : e ∈ G'.edgeSet)
    (hv : v ∈ e) : v ∈ G'.verts 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  exact (sup_le_iff.mp le_induce_union).1

For theorem:
lemma le_induce_union_left : G'.induce s ≤ G'.induce (s ∪ s') 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext
  · simp [and_comm]
  · simp_rw [coeSubgraph_Adj, restrict_Adj]

For theorem:
lemma coeSubgraph_restrict_eq {H : G.Subgraph} (H' : G.Subgraph) :
    Subgraph.coeSubgraph (H.restrict H') = H ⊓ H' 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h ↦ ⟨fun v hv ↦?_, fun v w =>?_⟩, fun v w =>?_⟩
  · rintro ⟨w, hw⟩
    exact ⟨w, hw⟩

For theorem:
theorem map_le_iff_le_comap {G' : SimpleGraph W} (f : G →g G') (H : G.Subgraph) (H' : G'.Subgraph) :
    H.map f ≤ H' ↔ H ≤ H'.comap f 
Attempt failure.

Working on Mathlib/Combinatorics/SimpleGraph/Triangle/Tripartite.lean - 2024-08-20 15:42:46.875172.
---0/3204---
Verifying proof:
:= by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩

For theorem:
lemma in₁₂_iff' :
    (graph t).Adj (in₁ b) (in₂ c) ↔ ∃ x : α × β × γ, x ∈ t ∧ x.2.1 = b ∧ x.2.2 = c where
Attempt failure.

---0/3204---
Verifying proof:
:= by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩;

For theorem:
lemma in₀₁_iff' :
    (graph t).Adj (in₀ a) (in₁ b) ↔ ∃ x : α × β × γ, x ∈ t ∧ x.1 = a ∧ x.2.1 = b where
Attempt failure.

---0/3204---
Verifying proof:
:= by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩;

For theorem:
lemma in₂₀_iff' :
    (graph t).Adj (in₂ c) (in₀ a) ↔ ∃ x : α × β × γ, x ∈ t ∧ x.2.2 = c ∧ x.1 = a where
Attempt failure.

---0/3204---
Verifying proof:
:= by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩; exact ⟨_, ‹_›, by simp⟩
  mpr := by rintro ⟨⟩;

For theorem:
lemma in₀₂_iff' :
    (graph t).Adj (in₀ a) (in₂ c) ↔ ∃ x : α × β × γ, x ∈ t ∧ x.1 = a ∧ x.2.2 = c where
Attempt failure.

Working on Mathlib/Computability/AkraBazzi/AkraBazzi.lean - 2024-08-20 15:43:30.602141.
---0/3204---
Verifying proof:
:= by
  calc 0 < (n : ℝ) ^ p a b * (1 + 0)  : = by aesop (add safe Real.rpow_pos_of_pos)
  _ ≤ asympBound g a b n    := by aesop (add safe Real.rpow_pos_of_pos)
  _ ≤ asympBound g a b n    := by aesop (add safe Real.rpow_pos_of_pos)
  _ ≤ asympBound g a b n    := by aesop (add safe Real.rpow_pos_of_pos)
  _ ≤ asympBound g a b n    := by aesop (add safe Real.rpow_pos_of_pos)
  _ ≤ asympBound g a b n    := by aesop (add safe Real.rpow_pos_of_pos)
  _ ≤ asympBound g a b n    := by aesop (add safe Real.rpow_pos_of_pos)
  _ ≤ asympBound g a b n    := by aesop (add safe Real.rpow_pos_of_pos)
  _ ≤ asympBound g a b n    := by aesop (add safe Real.rpow_pos_of_pos)
  _ ≤ asympBound g a b n    := by aesop (add safe Real.rpow_pos_of_pos)
  _ ≤ asympBound g a b n    := by aesop (add safe Real.rpow_pos_of_pos)
  _ ≤ asympBound g a b n    := by aesop (add safe Real.rpow_pos_of_pos)
  _ ≤ asympBound g a b n    := by aesop (add safe Real.rpow_pos_of_pos)
  _ ≤ asympBound g a b n    := by aesop (a

For theorem:
lemma asympBound_pos (n : ℕ) (hn : 0 < n) : 0 < asympBound g a b n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  calc asympBound g a b = (fun n => 1 * asympBound g a b n) := by simp
  _ = (fun n => (1 + ε n) * asympBound g a b n) * asympBound g a b n := by simp
  _ = (fun n => (1 + ε n) * asympBound g a b n) * asympBound g a b n := by simp
  _ ~[atTop] (fun n => (1 + ε n) * asympBound g a b n) := by simp
  _ = (fun n => (1 + ε n) * asympBound g a b n) * asympBound g a b n := by simp
  _ = (fun n => (1 + ε n) * asympBound g a b n) * asympBound g a b n := by simp
  _ = (fun n => (1 + ε n) * asympBound g a b n) * asympBound g a b n := by simp
  _ = (fun n => (1 + ε n) * asympBound g a b n) * asympBound g a b n := by simp
  _ = (fun n => (1 + ε n) * asympBound g a b n) * asympBound g a b n := by simp
  _ = (fun n => (1 + ε n) * asympBound g a b n) * asympBound g a b n := by simp
  _ = (fun n => (1 + ε n) * asympBound g a b n) * asympBound g a b n := by simp
  _ = (fun n => (1 + ε n) * asympBound g a b n) * asympBound g a b n := by simp
  _ = (fun n => (1 + ε n) * asympBound g a b n) * asympBound g a b n

For theorem:
theorem isBigO_symm_asympBound : asympBound g a b =O[atTop] T 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases eq_or_ne p 0 with
  | inl hp => exact growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn p
  | inr hp => exact growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn p

For theorem:
lemma growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p : ℝ) :
    GrowsPolynomially fun x => ‖deriv (fun z => z ^ p * (1 + ε z)) x‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have h₁ : Tendsto (fun p : ℝ => (a (max_bi b) : ℝ) * b (max_bi b) ^ p) atBot atTop :=
    tendsto_atTop_atBot.comp (tendsto_atTop_atBot.comp tendsto_const_nhds)
  have h₂ : Tendsto (fun p : ℝ => (a (max_bi b) : ℝ) * b (max_bi b) ^ p) atBot atTop :=
    tendsto_atTop_atBot.comp (tendsto_atTop_atBot.comp tendsto_const_nhds)
  have h₂ : Tendsto (fun p : ℝ => (a (max_bi b) : ℝ) * b (max_bi b) ^ p) atBot atTop :=
    tendsto_atTop_atBot.comp (tendsto_atTop_atBot.comp tendsto_id)
  have h₂ : Tendsto (fun p : ℝ => (a (max_bi b) : ℝ) * b (max_bi b) ^ p) atBot atTop :=
    tendsto_atTop_atBot.comp (tendsto_atTop_atBot.comp tendsto_const_nhds)
  have h₂ : Tendsto (fun p : ℝ => (a (max_bi b) : ℝ) * b (max_bi b) ^ p) atBot atTop :=
    tendsto_atTop_atBot.comp (tendsto_atTop_atBot.comp tendsto_const_nhds)
  have h₂ : Tendsto (fun p : ℝ => (a (max_bi b) : ℝ) * b (max_bi b) ^ p) atBot atTop :=
    tendsto_atTop_atBot.comp (tendsto_atTop_atBot.comp tendsto_const_nhds)
  have h₂

For theorem:
lemma tendsto_atTop_sumCoeffsExp : Tendsto (fun (p : ℝ) => ∑ i, a i * (b i) ^ p) atBot atTop 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  induction n using Nat.strongInductionOn
  case ind n h_ind =>
    rcases lt_or_le n R.n₀ with hn|hn
    case inr =>
    rcases lt_or_le n R.n₀ with hn|hn
    case inr =>
      rcases lt_or_le n R.n₀ with hn|hn
      case inr =>
      rcases lt_or_le n R.n₀ with hn|hn
      case inr =>
      rcases lt_or_le n R.n₀ with hn|hn
      case inr => exact R.T_gt_zero' n hn with hn|hn
    case inr => exact R.T_gt_zero' n hn with hn|hn
    case inr => exact R.T_gt_zero' n hn with hn|hn
    case inr => exact R.T_gt_zero' n hn with hn|hn
    case inr => exact R.T_gt_zero' n hn with hn|hn
    case inr => exact R.T_gt_zero' n hn with hn|hn
    case inr => exact R.T_gt_zero' n hn with hn|hn
    case inr => exact R.T_gt_zero' n hn with hn|hn
    case inr => exact R.T_gt_zero' n hn with hn|hn
    case inr => exact R.T_gt_zero' n hn with hn|hn
    case inr => exact R.T_gt_zero' n hn with hn|hn
    case inr => exact R.T_gt_zero' n hn with hn|hn
    case inr => exact R.T_gt_zero' n hn with hn|hn
    case inr =

For theorem:
lemma T_pos (n : ℕ) : 0 < T n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [p]
  refine Function.invFun_eq (by rw [← Set.mem_range]; focus exact R.one_mem_range_sumCoeffsExp)

For theorem:
lemma sumCoeffsExp_p_eq_one : ∑ i, a i * (b i) ^ p a b = 1 
Attempt failure.

Working on Mathlib/Computability/AkraBazzi/GrowsPolynomially.lean - 2024-08-20 15:45:47.673600.
---0/3204---
Verifying proof:
:= by
  obtain ⟨c₁, _, c₂, _, h⟩ := hf (1/2) (by norm_num) (by norm_num)

For theorem:
lemma eventually_atTop_nonneg_or_nonpos (hf : GrowsPolynomially f) :
    (∀ᶠ x in atTop, 0 ≤ f x) ∨ (∀ᶠ x in atTop, f x ≤ 0) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro b hb
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atTop 0)⟩ := hf_nonneg
  obtain ⟨c₂, (hc₂_mem_atT

For theorem:
lemma GrowsPolynomially.rpow (p : ℝ) (hf : GrowsPolynomially f)
    (hf_nonneg : ∀ᶠ x in atTop, 0 ≤ f x) : GrowsPolynomially fun x => (f x) ^ p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eventually_atTop_nonneg_or_nonpos hf with hf'|hf'
  case inl =>
    have hmain : f =ᶠ[atTop] fun x => |f x| := by
      have hmain : f =ᶠ[atTop] fun x => |f x| := by
        have hmain : f =ᶠ[atTop] fun x => |f x| := by
        have hmain : f =ᶠ[atTop] fun x => |f x| := by
        have hmain : f =ᶠ[atTop] fun x => |f x| := by
        have hmain : f =ᶠ[atTop] fun x => |f x| := by
        have hmain : f =ᶠ[atTop] fun x => |f x| := by
        have hmain : f =ᶠ[atTop] fun x => |f x| := by
        have hmain : f =ᶠ[atTop] fun x => |f x| := by
        have hmain : f =ᶠ[atTop] fun x => |f x| := by
          have hmain : f =ᶠ[atTop] fun x => |f x| := by
                               have hmain : f =ᶠ[atTop] fun x => |f x| := by
                                  have hmain : f =ᶠ[atTop] fun x => |f x| := by
                          have hmain : f =ᶠ[atTop] fun x => |f x| := by
                                  have hmain : f =ᶠ[atTop] fun x => |f x| := by
               

For theorem:
lemma abs (hf : GrowsPolynomially f) : GrowsPolynomially (fun x => |f x|) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  suffices GrowsPolynomially fun x => |f x| * |g| by
    refine GrowsPolynomially.mul (GrowsPolynomially.mul hf hg)?_
    refine GrowsPolynomially.mul hg (GrowsPolynomially.mul hf hg) (GrowsPolynom

For theorem:
lemma GrowsPolynomially.mul {f g : ℝ → ℝ} (hf : GrowsPolynomially f)
    (hg : GrowsPolynomially g) : GrowsPolynomially fun x => f x * g x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro b hb
  have hb_ub := hb.2
  rw [isLittleO_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  rw [isLittleO_const_iff] at hfg
  r

For theorem:
lemma GrowsPolynomially.add_isLittleO {f g : ℝ → ℝ} (hf : GrowsPolynomially f)
    (hfg : g =o[atTop] f) : GrowsPolynomially fun x => f x + g x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  intro b hb
  have hb₀ : 0 < b := hb.1
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  refine ⟨1 / 2, by norm_num,?_⟩
  have h_tendsto : Tendst

For theorem:
lemma growsPolynomially_log : GrowsPolynomially Real.log 
Attempt failure.

Working on Mathlib/Computability/Halting.lean - 2024-08-20 15:46:20.661891.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun h i => of_part <| vector_get.comp₂ h (const i)⟩
  simpa only [ofFn_get] using vector_ofFn fun i => to_part i

For theorem:
theorem vec_iff {m n f} : @Vec m n f ↔ Computable f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨hf.comp hg, fun a =>?_⟩
  refine ⟨hf.comp hg, fun a =>?_⟩
  refine ⟨hf.comp hg, fun a =>?_⟩
  refine ⟨hf.comp hg, fun a =>?_⟩
  refine ⟨hf.comp hg, fun a =>?_⟩
  · refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
    refine ⟨hf.comp hg, fun a =>?_⟩
 

For theorem:
theorem merge' {f g} (hf : Nat.Partrec f) (hg : Nat.Partrec g) :
    ∃ h, Nat.Partrec h ∧
      ∀ a, (∀ x ∈ h a, x ∈ f a ∨ x ∈ g a) ∧ ((h a).Dom ↔ (f a).Dom ∨ (g a).Dom) 
Attempt failure.

Working on Mathlib/Computability/Partrec.lean - 2024-08-20 15:46:25.877047.
---0/3204---
Verifying proof:
:= by
  simp only [Vector.mOfFn, Part.mOfFn, Function.comp_apply]
  constructor
  · intro n
    cases' n with n
    | zero =>
      induction' n with n ih
    | succ n ih =>
      induction' n with n ih
    | zero =>
      induction' n with n ih
    | zero =>
      induction' n with n ih
    | zero =>
      induction' n with n ih
    | zero =>
      induction' n with n ih
    | zero =>
      induction' n with n ih
    | zero =>
      induction' n with n ih
    | zero =>
      induction' n with n ih
    | zero =>
      induction' n with n ih
    | zero =>
      induction' n with n ih
    | zero =>
      induction' n with n ih
    | zero =>
      induction' n with n ih
    | zero =>
      induction' n with n ih
      | succ n ih =>
      induction' n with n ih
      | zero =>
      induction' n with n ih
      | zero =>
      induction' n with n ih
      | succ n ih =>
      induction' n with n ih
      | zero =>
      induction' n with n ih
      | zero =>
      induction' n with n ih
      | zero =>
       

For theorem:
theorem vector_mOfFn :
    ∀ {n} {f : Fin n → α →. σ},
      (∀ i, Partrec (f i)) → Partrec fun a : α => Vector.mOfFn fun i => f i a
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine computable_of_computable_of_computable_of_computable_of_computable_of_computable_of_computable_of_computable_of_computable_of_computable_of_computable_of_computable_of_computable_of_computable_of_computable_of_computable_of_computable_of_computable_of_computable_of_computable
    (fun a => Nat.casesOn (motive := fun _ => σ) (f a) (g a) (g a) (g a) (g a) (g a) (g a) (g a) (g a) (g a) (g a)?_?_?_?_ <;>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

For theorem:
theorem nat_casesOn {f : α → ℕ} {g : α → σ} {h : α → ℕ → σ} (hf : Computable f) (hg : Computable g)
    (hh : Computable₂ h) :
    Computable fun a => Nat.casesOn (motive := fun _ => σ) (f a) (g a) (h a) 
Attempt failure.

Working on Mathlib/Computability/PartrecCode.lean - 2024-08-20 15:46:33.888275.
---0/3204---
Verifying proof:
  | 0 => by simp [ofNatCode, encodeCode]
  | 1 => by simp [ofNatCode, encodeCode]
  | 2 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode

For theorem:
theorem encode_ofNatCode : ∀ n, encodeCode (ofNatCode n) = n
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun h =>?_⟩
  · refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine ⟨fun h =>?_, fun h =>?_⟩
    refine

For theorem:
theorem rec_prim {α σ} [Primcodable α] [Primcodable σ] {c : α → Code} (hc : Primrec c) {z : α → σ}
    (hz : Primrec z) {s : α → σ} (hs : Primrec s) {l : α → σ} (hl : Primrec l) {r : α → σ}
    (hr : Primrec r) {pr : α → Code → Code → σ → σ → σ}
    (hpr : Primrec fun a : α × Code × Code × σ × σ => pr a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2)
    {co : α → Code → Code → σ → σ → σ}
    (hco : Primrec fun a : α × Code × Code × σ × σ => co a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2)
    {pc : α → Code → Code → σ → σ → σ}
    (hpc : Primrec fun a : α × Code × Code × σ × σ => pc a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2)
    {rf : α → Code → σ → σ} (hrf : Primrec fun a : α × Code × σ => rf a.1 a.2.1 a.2.2) :
    let F (a : α) (c : Code) : σ :=
      Nat.Partrec.Code.recOn c (z a) (s a) (l a) (r a) (pr a) (co a) (pc a) (rf a)
    Primrec fun a => F a (c a) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun ⟨k, h⟩ => evaln_sound h⟩
  rsuffices ⟨k, h⟩ : ∃ k, x ∈ evaln (k + 1) c n⟩ : ∃ k, x ∈ evaln (k + 1) c n⟩ := by
    refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
    rsuffices ⟨k, h⟩ : ∃ k, x ∈ evaln (k + 1) c n⟩ : ∃ k, x ∈ evaln (k + 1) c n⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
 

For theorem:
theorem evaln_complete {c n x} : x ∈ eval c n ↔ ∃ k, x ∈ evaln k c n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun ⟨k, h⟩ => evaln_sound h⟩
  rsuffices ⟨k, h⟩ : ∃ k, x ∈ evaln (k + 1) c n⟩ : ∃ k, x ∈ evaln (k + 1) c n⟩ := by
    refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
    rsuffices ⟨k, h⟩ : ∃ k, x ∈ evaln (k + 1) c n⟩ : ∃ k, x ∈ evaln (k + 1) c n⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
  refine ⟨k,?_, fun ⟨k, h⟩ => evaln_sound h⟩
 

For theorem:
theorem evaln_complete {c n x} : x ∈ eval c n ↔ ∃ k, x ∈ evaln k c n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  induction' h : Computable s using Computable.induction_on with a b <;> simp [*]

For theorem:
theorem rec_computable {α σ} [Primcodable α] [Primcodable σ] {c : α → Code} (hc : Computable c)
    {z : α → σ} (hz : Computable z) {s : α → σ} (hs : Computable s) {l : α → σ} (hl : Computable l)
    {r : α → σ} (hr : Computable r) {pr : α → Code × Code × σ × σ → σ} (hpr : Computable₂ pr)
    {co : α → Code × Code × σ × σ → σ} (hco : Computable₂ co) {pc : α → Code × Code × σ × σ → σ}
    (hpc : Computable₂ pc) {rf : α → Code × σ → σ} (hrf : Computable₂ rf) :
    let PR (a) cf cg hf hg := pr a (cf, cg, hf, hg)
    let CO (a) cf cg hf hg := co a (cf, cg, hf, hg)
    let PC (a) cf cg hf hg := pc a (cf, cg, hf, hg)
    let RF (a) cf hf := rf a (cf, hf)
    let F (a : α) (c : Code) : σ :=
      Nat.Partrec.Code.recOn c (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a)
    Computable fun a => F a (c a) := by
    intros _ _ _ _ F
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have a := (Primrec.ofNat (ℕ × Code)).comp (Primrec.list_length (α := List (Option ℕ)))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option ℕ))
  have k := Primrec.list_length (α := List (Option 

For theorem:
theorem hG : Primrec G 
Attempt failure.

---0/3204---
Verifying proof:
  | 0 => by simp [ofNatCode, encodeCode]
  | 1 => by simp [ofNatCode, encodeCode]
  | 2 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode

For theorem:
theorem encode_ofNatCode : ∀ n, encodeCode (ofNatCode n) = n
Attempt failure.

---0/3204---
Verifying proof:
:=
  have :
    Primrec₂ fun (_ : Unit) (n : ℕ) =>
        let a := ofNat (ℕ × Code) n
      (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1)
      (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1)
      (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1)
      (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1)
      (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1)
      (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1)
      (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.range a.1).map (List.ra

For theorem:
theorem evaln_prim : Primrec fun a : (ℕ × Code) × ℕ => evaln a.1.1 a.1.2 a.2 
Attempt failure.

Working on Mathlib/Computability/Primrec.lean - 2024-08-20 15:47:57.537368.
---0/3204---
Verifying proof:
:=
  (nat_casesOn (fun a => (f a).casesOn (g a) (h a))).of_eq fun a => (h a).casesOn (g a) (h a)

For theorem:
theorem nat_casesOn {f : α → ℕ} {g : α → β} {h : α → ℕ → β} (hf : Primrec f) (hg : Primrec g)
    (hh : Primrec₂ h) : Primrec fun a => ((f a).casesOn (g a) (h a) : β) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  (option_bind hf (option_some.comp hg)).of_eq fun x => (f x).map (g x)

For theorem:
theorem option_map {f : α → Option β} {g : α → β → σ} (hf : Primrec f) (hg : Primrec₂ g) :
    Primrec fun a => (f a).map (g a) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  Primrec.unpaired'.1 Nat.Primrec.mul

For theorem:
theorem nat_mul : Primrec₂ ((· * ·) : ℕ → ℕ → ℕ) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  (prec.id ((Primrec.succ.comp right)).of_eq fun p => by
    simp; induction p.unpair.2 <;> simp [*, ← Nat.add_assoc]

For theorem:
theorem add : Nat.Primrec (unpaired (· + ·)) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  Primrec.and.comp₂ hp hq

For theorem:
theorem _root_.PrimrecPred.and {p q : α → Prop} [DecidablePred p] [DecidablePred q]
    (hp : PrimrecPred p) (hq : PrimrecPred q) : PrimrecPred fun a => p a ∧ q a 
Attempt failure.

---0/3204---
Verifying proof:
:=
  (list_foldr hf (const []) <|
    to₂ <| list_cons.comp <| list_cons.comp <| list_cons.comp <| list_cons.comp snd).to₂

For theorem:
theorem list_map {f : α → List β} {g : α → β → σ} (hf : Primrec f) (hg : Primrec₂ g) :
    Primrec fun a => (f a).map (g a) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  letI := prim H
  encode_iff.1 (succ.comp <| Primrec.natPair.comp₂ (encode_iff.2 fst) (encode_iff.2 snd))

For theorem:
theorem list_cons' : (haveI := prim H; Primrec₂ (@List.cons β)) 
Attempt failure.

Working on Mathlib/Computability/Reduce.lean - 2024-08-20 15:49:04.047093.
---0/3204---
Verifying proof:
:= by
  induction d₁
  induction d₂
  intro hp hq
  simp_all only [ManyOneEquiv, of_le_of, of_eq_some]
  simp_all only [ManyOneEquiv, of_le_of, of_eq_some]

For theorem:
theorem le_antisymm {d₁ d₂ : ManyOneDegree} : d₁ ≤ d₂ → d₂ ≤ d₁ → d₁ = d₂ 
Attempt failure.

Working on Mathlib/Computability/RegularExpressions.lean - 2024-08-20 15:49:06.270711.
---0/3204---
Verifying proof:
  | 0 => (map_zero _).symm
  | 1 => (map_zero _).symm
  | 1 => (map_one _).symm
  | char a => by
    rw [eq_iff_true_of_subsingleton]
    rintro ⟨a, ha⟩
    exact ⟨a, ha⟩

For theorem:
theorem matches'_map (f : α → β) :
    ∀ P : RegularExpression α, (P.map f).matches' = Language.map f P.matches'
Attempt failure.

---0/3204---
Verifying proof:
  | 0 => (map_zero _).symm
  | 1 => (map_zero _).symm
  | 1 => (map_one _).symm
  | char a => by
    rw [eq_iff_true_of_subsingleton]
    rintro ⟨a, ha⟩
    exact ⟨a, ha⟩

For theorem:
theorem matches'_map (f : α → β) :
    ∀ P : RegularExpression α, (P.map f).matches' = Language.map f P.matches'
Attempt failure.

Working on Mathlib/Computability/TMToPartrec.lean - 2024-08-20 15:49:11.096524.
---0/3204---
Verifying proof:
:= by
  simp only [TM2.step, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux,
    TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux,
    TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux,
    TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux,
    TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux,
    TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux,
    TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux,
    TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux,
    TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux,
    TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux,
    TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.stepAux, TM2.s

For theorem:
theorem head_stack_ok {q s L₁ L₂ L₃} :
    Reaches₁ (TM2.step tr)
      ⟨some (head stack q), s, K'.elim (trList L₁) [] [] (trList L₂ ++ Γ'.consₗ :: L₃)⟩
      ⟨some q, none, K'.elim (trList (L₂.headI :: L₁)) [] [] L₃⟩ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [splitAtPred, TM2.step, Option.map_some', TM2.stepAux, Option.map_some',
    Option.some_inj, TM2.stepAux, Option.map_some', TM2.stepAux, Option.map_some',
    Option.some_inj, TM2.stepAux, Option.map_some', TM2.stepAux, Option.map_some',
    Option.some_inj, TM2.stepAux, Option.map_some', TM2.stepAux, Option.map_some',
    Option.map_some', TM2.stepAux, Option.map_some', TM2.stepAux, Option.map_some',
    Option.map_some', TM2.stepAux, Option.map_some', TM2.stepAux, Option.map_some',
    Option.some_inj, TM2.stepAux, Option.map_some', TM2.stepAux, Option.map_some',
    Option.map_some', TM2.stepAux, Option.map_some', TM2.stepAux, Option.map_some',
    Option.map_some', TM2.stepAux, Option.map_some', TM2.stepAux, Option.map_some',
    Option.map_some', TM2.stepAux, Option.map_some', TM2.stepAux, Option.map_some',
    Option.map_some', TM2.stepAux, Option.map_some', TM2.stepAux, Option.map_some',
    Option.map_some', TM2.stepAux, Option.map_some', TM2.stepAux, Option.map_some',
    Option.s

For theorem:
theorem move_ok {p k₁ k₂ q s L₁ o L₂} {S : K' → List Γ'} (h₁ : k₁ ≠ k₂)
    (e : splitAtPred p (S k₁) = (L₁, o, L₂)) :
    Reaches₁ (TM2.step tr) ⟨some (Λ'.move p k₁ k₂ q), s, S⟩
      ⟨some q, o, update (update S k₁ L₂) k₂ (L₁.reverseAux (S k₂))⟩ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [TM2.step, TM2.stepAux, List.tail_cons, List.tail_cons, List.tail_cons, List.tail_cons,
    List.tail_cons, List.tail_cons]

For theorem:
theorem pred_ok (q₁ q₂ s v) (c d : List Γ') : ∃ s',
    Reaches₁ (TM2.step tr) ⟨some (Λ'.pred q₁ q₂), s, K'.elim (trList v) [] c d⟩
      (v.headI.rec ⟨some q₁, s', K'.elim (trList v.tail) [] c d⟩ fun n _ =>
        ⟨some q₂, s', K'.elim (trList (n::v.tail)) [] c d⟩) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  induction k generalizing v <;> simp only [Cont.then, stepRet, *]

For theorem:
theorem stepRet_then {k k' : Cont} {v} : stepRet (k.then k') v = (stepRet k v).then k' 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  induction c generalizing k v with simp only [Cont.then, stepNormal, *]

For theorem:
theorem stepNormal_then (c) (k k' : Cont) (v) :
    stepNormal c (k.then k') v = (stepNormal c k v).then k' 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  induction hf with
  | prim hf =>
    induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>
      induction hf with
    | prim hf =>


For theorem:
theorem exists_code {n} {f : Vector ℕ n →. ℕ} (hf : Nat.Partrec' f) :
    ∃ c : Code, ∀ v : Vector ℕ n, c.eval v.1 = pure <$> f v 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [TM2.step, TM2.stepAux, List.reverseAux_cons, List.reverseAux_nil, List.reverseAux_nil]

For theorem:
theorem copy_ok (q s a b c d) :
    Reaches₁ (TM2.step tr) ⟨some (Λ'.copy q), s, K'.elim a b c d⟩
      ⟨some q, none, K'.elim (List.reverseAux b a) [] c (List.reverseAux b d)⟩ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases trNormal_respects c k v s with ⟨b₂, hb₂⟩
  refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
  refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
  · refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
  · refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rfl?_⟩
    refine ⟨b₂, hb₂, TransGen.head rf

For theorem:
theorem trNormal_respects (c k v s) :
    ∃ b₂,
      TrCfg (stepNormal c k v) b₂ ∧
        Reaches₁ (TM2.step tr)
          ⟨some (trNormal c (trCont k)), s, K'.elim (trList v) [] [] (trContStack k)⟩ b₂ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  induction k with
  | halt => simp [contSupp_halt, Supports]
  | cons₁ f k IH =>
    have H₁ := H; rw [contSupp_cons₁]
    have H₂ := H
    rw [contSupp_cons₁, contSupp_cons₁, contSupp_cons₁, contSupp_cons₁]
  | cons₁ f k IH =>
    have H₂ := H
    have H₂ := H
    rw [contSupp_cons₁, contSupp_cons₁, contSupp_cons₁, contSupp_cons₁]
  | cons₁ f k IH =>
    have H₂ := H
    have H₂ := H
    rw [contSupp_cons₁, contSupp_cons₁, contSupp_cons₁, contSupp_cons₁]
  | cons₁ f k IH =>
    have H₂ := H
    have H₂ := H
    rw [contSupp_cons₁, contSupp_cons₁, contSupp_cons₁, contSupp_cons₁, contSupp_cons₁]
  | cons₁ f k IH =>
    have H₂ := H
    rw [contSupp_cons₁, contSupp_cons₁, contSupp_cons₁, contSupp_cons₁]
  | cons₁ f k IH =>
    have H₂ := H
    rw [contSupp_cons₁, contSupp_cons₁, contSupp_cons₁]
    rw [contSupp_cons₁, contSupp_cons₁, contSupp_supports]
  | cons₁ f k IH =>
    have H₂ := H
    rw [contSupp_cons₁, 

For theorem:
theorem contSupp_supports {S k} (H : contSupp k ⊆ S) : Supports (contSupp k) S 
Attempt failure.

Working on Mathlib/Computability/TuringMachine.lean - 2024-08-20 15:50:28.647442.
---0/3204---
Verifying proof:
:= by
  refine l.inductionOn fun l ↦?_
  refine l.inductionOn fun l ↦?_
  · rw [ListBlank.nth_map, ListBlank.nth_map, ListBlank.tail_cons, ListBlank.tail_cons,
      ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons,
      ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons,
      ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons,
      ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons,
      ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons,
      ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons,
      ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons,
      ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons,
      ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons, ListBlank.tail_cons,
      ListBlank.tail_cons, ListBlank.tail_cons

For theorem:
theorem ListBlank.nth_map {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ')
    (l : ListBlank Γ) (n : ℕ) : (l.map f).nth n = f (l.nth n) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rintro ⟨l₁, l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ ⟨l₂⟩ 

For theorem:
theorem BlankExtends.above_of_le {Γ} [Inhabited Γ] {l l₁ l₂ : List Γ} :
    BlankExtends l₁ l → BlankExtends l₂ l → l₁.length ≤ l₂.length → BlankExtends l₁ l₂ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [(_ : TM1.init _ = _)]
  · refine ⟨ListBlank.mk (L.reverse.map fun a ↦ update default default) (L.reverse.map fun a ↦ update default default)⟩
  · refine ⟨ListBlank.mk (L.reverse.map fun a ↦ update default default)⟩
    refine ⟨ListBlank.mk (L.reverse.map fun a ↦ update default default)⟩
    refine ⟨ListBlank.mk (L.reverse.map fun a ↦ update default default)⟩
    refine ⟨ListBlank.mk (L.reverse.map fun a ↦ update default default)⟩
    refine ⟨ListBlank.mk (L.reverse.map fun a ↦ update default default)⟩
    refine ⟨ListBlank.mk (L.reverse.map fun a ↦ update default default)⟩
    refine ⟨ListBlank.mk (L.reverse.map fun a ↦ update default default)⟩
    refine ⟨ListBlank.mk (L.reverse.map fun a ↦ update default default)⟩
    refine ⟨ListBlank.mk (L.reverse.map fun a ↦ update default default)⟩
    refine ⟨ListBlank.mk (L.reverse.map fun a ↦ update default default)⟩
    refine ⟨ListBlank.mk (L.reverse.map fun a ↦ update default de

For theorem:
theorem trCfg_init (k) (L : List (Γ k)) : TrCfg (TM2.init k L) (TM1.init (trInit k L) : Cfg₂₁) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ListBlank.induction_on L₁ fun l₁ ↦ ListBlank.induction_on L₁ fun l₁ ↦ ListBlank.induction_on L₁ fun l₁ ↦?_
  rw [ListBlank.induction_on L₁ fun l₁ ↦ ListBlank.induction_on L₁ fun l₁ ↦ L₂.nth i = L₂.nth

For theorem:
theorem ListBlank.ext {Γ} [i : Inhabited Γ] {L₁ L₂ : ListBlank Γ} :
    (∀ i, L₁.nth i = L₂.nth i) → L₁ = L₂ 
Attempt failure.

Working on Mathlib/Condensed/TopComparison.lean - 2024-08-20 15:51:32.703920.
---0/3204---
Verifying proof:
:= by
  rw [← G.map_comp, pullback.condition, ← G.map_comp, pullback.condition, ← G.map_comp,
    pullback.condition, ← G.map_comp, ← G.map_comp, ← G.map_comp, ← G.map_comp,
    pullback.condition, ← G.map_comp, ← G.map_comp, ← G.map_comp, ← G.map_comp,
    pullback.condition, ← G.map_comp, ← G.map_comp, ← G.map_comp, ← G.map_comp,
    pullback.condition, ← G.map_comp, ← G.map_comp, ← G.map_comp, ← G.map_comp,
    pullback.condition, ← G.map_comp, ← G.map_comp, ← G.map_comp, ← G.map_comp,
    pullback.condition, ← G.map_comp, ← G.map_comp, ← G.map_comp, ← G.map_comp,
    pullback.condition, ← G.map_comp, ← G.map_comp, ← G.map_comp, ← G.map_comp,
    pullback.condition, ← G.map_comp, ← G.map_comp, ← G.map_comp, ← G.map_comp,
    pullback.condition, ← G.map_comp, ← G.map_comp, ← G.map_comp, ← G.map_comp,
    pullback.condition, ← G.map_comp, ← G.map_comp, ← G.map_comp, ← G.map_comp,
    pullback.condition, ← G.map_comp, ←

For theorem:
theorem factorsThrough_of_pullbackCondition {Z B : C} {π : Z ⟶ B} [HasPullback π π]
    [PreservesLimit (cospan π π) G]
    {a : C(G.obj Z, X)}
    (ha : a ∘ (G.map pullback.fst) = a ∘ (G.map (pullback.snd (f := π) (g := π)))) :
    Function.FactorsThrough a (G.map π) 
Attempt failure.

Working on Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean - 2024-08-20 15:51:40.627471.
---0/3204---
Verifying proof:
:= by
  obtain ⟨F, hF₁, hF₂⟩ := exists_forall_semiconj_of_forall_translationNumber_eq h
  obtain ⟨F, hF₁, hF₂⟩ := exists_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber
  obtain ⟨F, hF₁, hF₂⟩ := exists_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_t

For theorem:
theorem semiconj_of_group_action_of_forall_translationNumber_eq {G : Type*} [Group G]
    (f₁ f₂ : G →* CircleDeg1Lift) (h : ∀ g, τ (f₁ g) = τ (f₂ g)) :
    ∃ F : CircleDeg1Lift, ∀ g, Semiconj F (f₁ g) (f₂ g) := by
      have : ∀ x, BddAbove (range fun g => f₂ g⁻¹ (f₁ g x)) := by
    refine fun x => ⟨x + 2, ?_⟩
    rintro _ ⟨g, rfl⟩
    have : τ (f₂ g⁻¹) = -τ (f₂ g) := by
      rw [← MonoidHom.coe_toHomUnits, MonoidHom.map_inv, translationNumber_units_inv,
        MonoidHom.coe_toHomUnits]
    calc
      f₂ g⁻¹ (f₁ g x) ≤ f₂ g⁻¹ (x + τ (f₁ g) + 1) :=
        mono _ (map_lt_add_translationNumber_add_one _ _).le
      _ = f₂ g⁻¹ (x + τ (f₂ g)) + 1 := by rw [h, map_add_one]
      _ ≤ x + τ (f₂ g) + τ (f₂ g⁻¹) + 1 + 1 :=
        add_le_add_right (map_lt_add_translationNumber_add_one _ _).le _
      _ = x + 2 := by simp [this, add_assoc, one_add_one_eq_two]
      set F₁ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨F, hF₁, hF₂⟩ := exists_forall_semiconj_of_forall_translationNumber_eq h
  obtain ⟨F, hF₁, hF₂⟩ := exists_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber
  obtain ⟨F, hF₁, hF₂⟩ := exists_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_translationNumber_of_forall_t

For theorem:
theorem semiconj_of_group_action_of_forall_translationNumber_eq {G : Type*} [Group G]
    (f₁ f₂ : G →* CircleDeg1Lift) (h : ∀ g, τ (f₁ g) = τ (f₂ g)) :
    ∃ F : CircleDeg1Lift, ∀ g, Semiconj F (f₁ g) (f₂ g) := by
      have : ∀ x, BddAbove (range fun g => f₂ g⁻¹ (f₁ g x)) := by
    refine fun x => ⟨x + 2, ?_⟩
    rintro _ ⟨g, rfl⟩
    have : τ (f₂ g⁻¹) = -τ (f₂ g) := by
      rw [← MonoidHom.coe_toHomUnits, MonoidHom.map_inv, translationNumber_units_inv,
        MonoidHom.coe_toHomUnits]
    calc
      f₂ g⁻¹ (f₁ g x) ≤ f₂ g⁻¹ (x + τ (f₁ g) + 1) :=
        mono _ (map_lt_add_translationNumber_add_one _ _).le
      _ = f₂ g⁻¹ (x + τ (f₂ g)) + 1 := by rw [h, map_add_one]
      _ ≤ x + τ (f₂ g) + τ (f₂ g⁻¹) + 1 + 1 :=
        add_le_add_right (map_lt_add_translationNumber_add_one _ _).le _
      _ = x + 2 := by simp [this, add_assoc, one_add_one_eq_two]
      set F₁ 
Attempt failure.

Working on Mathlib/Dynamics/Ergodic/Conservative.lean - 2024-08-20 15:52:05.653188.
---0/3204---
Verifying proof:
:= by
  by_contra H
  simp only [not_frequently, not_frequently, not_frequently] at H
  simp only [not_frequently, eventually_atTop] at H
  simp only [not_frequently, eventually_atTop] at H
  simp only [not_frequently, eventually_atTop] at H
  simp only [not_frequently, eventually_atTop] at H
  simp only [not_frequently, eventually_atTop] at H
  simp only [not_frequently, eventually_atTop] at H
  rcases H with ⟨m, hm⟩
  refine frequently_measure_zero_of_forall_setIntegral_ne_zero (fun m hm ↦?_)
  simp only [not_frequently, eventually_atTop] at H
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with ⟨m, hm⟩
  rcases H with 

For theorem:
theorem frequently_measure_inter_ne_zero (hf : Conservative f μ) (hs : MeasurableSet s)
    (h0 : μ s ≠ 0) : ∃ᶠ m in atTop, μ (s ∩ f^[m] ⁻¹' s) ≠ 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  cases' n with n
  · exact Conservative.id μ
  refine ⟨hf.1.iterate _, fun s hs hs0 =>?_⟩
  rcases hs0 with ⟨n, rfl⟩
  refine ⟨hf.1.iterate _, fun s hs hs0 =>?_⟩
  rcases hs0 with ⟨n, rfl⟩
  refine ⟨hf.1.iterate _, fun s hs hs0 =>?_⟩
  rcases hs0 with ⟨n, rfl⟩
  refine ⟨hf.1.iterate _, fun s hs hs0 =>?_⟩
  rcases hs0 with ⟨n, rfl⟩
  refine ⟨hf.1.iterate _, fun s hs hs0 =>?_⟩
  rcases hs0 with ⟨n, rfl⟩
  refine ⟨hf.1.iterate _, fun s hs hs0 =>?_⟩
  rcases hs0 with ⟨n, rfl⟩
  refine ⟨hf.1.iterate _, fun s hs hs0 =>?_⟩
  rcases hs0 with ⟨n, rfl⟩
  refine ⟨hf.1.iterate _, fun s hs hs0 =>?_⟩
  rcases hs0 with ⟨n, rfl⟩
  refine ⟨hf.1.iterate _, fun s hs hs0 =>?_⟩
  rcases hs0 with ⟨n, rfl⟩
  refine ⟨hf.1.iterate _, fun s hs hs0 =>?_⟩
  rcases hs0 with ⟨n, rfl⟩
  refine ⟨hf.1.iterate _, fun s hs hs0 =>?_⟩
  rcases hs0 with ⟨n, rfl⟩
  refine ⟨hf.1.iterate _, fun s hs hs0 =>?_⟩
  rcases hs0 with ⟨n, rfl

For theorem:
theorem iterate (hf : Conservative f μ) (n : ℕ) : Conservative f^[n] μ 
Attempt failure.

Working on Mathlib/Dynamics/OmegaLimit.lean - 2024-08-20 15:52:13.527047.
---0/3204---
Verifying proof:
:= by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases 

For theorem:
theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)
    (hn₂ : ω f ϕ s ⊆ n) : ∃ u ∈ f, closure (image2 ϕ u s) ⊆ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases 

For theorem:
theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)
    (hn₂ : ω f ϕ s ⊆ n) : ∃ u ∈ f, closure (image2 ϕ u s) ⊆ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext y; constructor
  · simp only [mem_union, mem_omegaLimit_iff_frequently, union_inter_distrib_right]

For theorem:
theorem omegaLimit_union : ω f ϕ (s₁ ∪ s₂) = ω f ϕ s₁ ∪ ω f ϕ s₂ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases 

For theorem:
theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)
    (hn₂ : ω f ϕ s ⊆ n) : ∃ u ∈ f, closure (image2 ϕ u s) ⊆ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp_rw [frequently_iff, omegaLimit_def, mem_inter_iff, mem_omegaLimit_def, mem_preimage]

For theorem:
theorem mem_omegaLimit_iff_frequently (y : β) :
    y ∈ ω f ϕ s ↔ ∀ n ∈ 𝓝 y, ∃ᶠ t in f, (s ∩ ϕ t ⁻¹' n).Nonempty 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases 

For theorem:
theorem nonempty_omegaLimit_of_isCompact_absorbing [NeBot f] {c : Set β} (hc₁ : IsCompact c)
    (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) (hs : s.Nonempty) : (ω f ϕ s).Nonempty 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases 

For theorem:
theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)
    (hn₂ : ω f ϕ s ⊆ n) : ∃ u ∈ f, closure (image2 ϕ u s) ⊆ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp_rw [frequently_iff, omegaLimit_def, mem_iInter, mem_omegaLimit_def, mem_iInter]

For theorem:
theorem mem_omegaLimit_iff_frequently (y : β) :
    y ∈ ω f ϕ s ↔ ∀ n ∈ 𝓝 y, ∃ᶠ t in f, (s ∩ ϕ t ⁻¹' n).Nonempty 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases 

For theorem:
theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set β}
    (hc₁ : IsCompact c) (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) {n : Set β} (hn₁ : IsOpen n)
    (hn₂ : ω f ϕ s ⊆ n) : ∃ u ∈ f, closure (image2 ϕ u s) ⊆ n 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases hc₂ with ⟨v, hv₁, hv₂⟩
  rcases hc₂ with ⟨v, hv₂, hv₃⟩
  rcases 

For theorem:
theorem nonempty_omegaLimit_of_isCompact_absorbing [NeBot f] {c : Set β} (hc₁ : IsCompact c)
    (hc₂ : ∃ v ∈ f, closure (image2 ϕ v s) ⊆ c) (hs : s.Nonempty) : (ω f ϕ s).Nonempty 
Attempt failure.

Working on Mathlib/Dynamics/PeriodicPts.lean - 2024-08-20 15:52:52.978044.
---0/3204---
Verifying proof:
:=
  Eq.symm <| Cycle.coe_eq_coe.2 <|.intro n <|
    List.ext_get (by simpa using hx)

For theorem:
theorem periodicOrbit_apply_iterate_eq (hx : x ∈ periodicPts f) (n : ℕ) :
    periodicOrbit f (f^[n] x) = periodicOrbit f x 
Attempt failure.

Working on Mathlib/FieldTheory/AbelRuffini.lean - 2024-08-20 15:52:57.395877.
---0/3204---
Verifying proof:
:= by
  let p := minpoly F α
  let q := minpoly F β
  have hpq := Polynomial.splits_of_splits_splits hpq
  have hpq := Polynomial.splits_of_splits_of_splits hα hpq
  have hpq' := Polynomial.splits_of_splits_of_splits hα hpq
  have hpq' := Polynomial.splits_of_splits_of_splits hα hpq
  have hpq' := Polynomial.splits_of_splits_of_splits hα hpq
  have hpq' := Polynomial.splits_of_splits_of_splits hα hpq
  have hpq' := Polynomial.splits_of_splits_of_splits hα hpq
  have hpq' := Polynomial.splits_of_splits_of_splits hα hpq
  have hpq' := Polynomial.splits_of_splits_of_splits hα hpq
  have hpq' := Polynomial.splits_of_splits_of_splits hα hpq
  have hpq' := Polynomial.splits_of_splits_of_splits hα hpq
  have hpq' := Polynomial.splits_of_splits_of_splits hα hpq
  have hpq' := Polynomial.splits_of_splits_of_splits hα hpq
  have hpq' := Polynomial.splits_of_splits_of_splits_of_splits hα hpq
  have hpq' := Polynomial.splits_of_splits_of_splits hα hpq
  have hpq' := Polynomial.splits_of_splits_of_splits 

For theorem:
theorem induction2 {α β γ : solvableByRad F E} (hγ : γ ∈ F⟮α, β⟯) (hα : P α) (hβ : P β) : P γ 
Attempt failure.

Working on Mathlib/FieldTheory/Adjoin.lean - 2024-08-20 15:53:08.955173.
---0/3204---
Verifying proof:
:= by rw [lift, ← AlgHom.fieldRange_eq_map, fieldRange_val]

For theorem:
theorem lift_top (K : IntermediateField F E) :
    lift (F := K) ⊤ = K 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply bot_eq_top_of_finrank_adjoin_eq_one
  apply bot_eq_top_of_finrank_adjoin_eq_one

For theorem:
theorem bot_eq_top_of_finrank_adjoin_le_one [FiniteDimensional F E]
    (h : ∀ x : E, finrank F F⟮x⟯ ≤ 1) : (⊥ : IntermediateField F E) = ⊤ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← hx, minpoly.irreducible_iff_irreducible_map, ← hx, minpoly.irreducible_iff_irreducible_map]
  exact hfm.irreducible

For theorem:
theorem _root_.Polynomial.irreducible_comp {f g : K[X]} (hfm : f.Monic) (hgm : g.Monic)
    (hf : Irreducible f)
    (hg : ∀ (E : Type u) [Field E] [Algebra K E] (x : E) (hx : minpoly K x = f),
      Irreducible (g.map (algebraMap _ _) - C (AdjoinSimple.gen K x))) :
    Irreducible (f.comp g) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rintro ⟨i, hi⟩
  obtain ⟨i, hi⟩ := IntermediateField.exists_isAlgebraic_of_isAlgebraic_of_isAlgebraic h
  refine ⟨fun i ↦?_, fun i ↦?_⟩
  · rw [Algebra.isAlgebraic_iff_isIntegral]
    exact isAlgebraic_of_isAlgebraic_of_isAlgebraic_of_isAlgebraic_of_isAlgebraic_of_isAlgebraic
      (h i) (fun i ↦ (h i).isAlgebraic) (fun i ↦ (h i).isAlgebraic) (fun i ↦ (h i).isAlgebraic)

For theorem:
theorem isAlgebraic_iSup {ι : Type*} {t : ι → IntermediateField K L}
    (h : ∀ i, Algebra.IsAlgebraic K (t i)) :
    Algebra.IsAlgebraic K (⨆ i, t i : IntermediateField K L) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext y
  rw [iff_true_right IntermediateField.mem_top]
  exact Submodule.mem_bot _

For theorem:
theorem bot_eq_top_of_rank_adjoin_eq_one (h : ∀ x : E, Module.rank F F⟮x⟯ = 1) :
    (⊥ : IntermediateField F E) = ⊤ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [SetLike.ext'_iff]
  change (↑(adjoin (adjoin F S) T) : Set E) = _
  apply Set.eq_of_subset_of_subset (Set.subset_union_right _ Set.subset_union_left)
  rw [adjoin_subset_iff, adjoin_subset_iff]
  exact Subset.antisymm (subset_adjoin F S) (subset_adjoin F S)

For theorem:
theorem adjoin_adjoin_left (T : Set E) :
    (adjoin (adjoin F S) T).restrictScalars _ = adjoin F (S ∪ T) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [isAlgebraic_iff_isIntegral, Algebra.adjoin_le_iff]

For theorem:
theorem adjoin_algebraic_toSubalgebra {S : Set E} (hS : ∀ x ∈ S, IsAlgebraic F x) :
    (IntermediateField.adjoin F S).toSubalgebra = Algebra.adjoin F S 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine FiniteDimensional.of_finiteDimensional_iSup_of_finiteDimensional?_
  refine FiniteDimensional.finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDimensional_of_finiteDime

For theorem:
theorem finiteDimensional_iSup_of_finset'
        {s : Finset ι} (h : ∀ i ∈ s, FiniteDimensional K (t i)) :
    FiniteDimensional K (⨆ i ∈ s, t i : IntermediateField K L) 
Attempt failure.

Working on Mathlib/FieldTheory/Cardinality.lean - 2024-08-20 15:57:32.146931.
---0/3204---
Verifying proof:
:= by
  letI K := FractionRing (MvPolynomial α <| ULift.{u} ℚ)
  suffices #α = #K by
    obtain ⟨e⟩ := Cardinal.lift_injective (MvPolynomial α <| ULift.{u} ℚ)
    obtain ⟨e⟩ := Cardinal.lift_injective (MvPolynomial α <| ULift.{u} ℚ)
    obtain ⟨e⟩ := Cardinal.lift_injective (MvPolynomial α <| ULift.{u} ℚ)
    obtain ⟨e⟩ := Cardinal.lift_injective (MvPolynomial α <| ULift.{u} ℚ)
    obtain ⟨e⟩ := Cardinal.lift_injective (MvPolynomial α <| ULift.{u} ℚ)
    obtain ⟨e⟩ := Cardinal.lift_injective (MvPolynomial α <| ULift.{u} ℚ)
    obtain ⟨e⟩ := Cardinal.lift_injective (MvPolynomial α <| ULift.{u} ℚ)
    obtain ⟨e⟩ := Cardinal.lift_injective (MvPolynomial α <| ULift.{u} ℚ)
    obtain ⟨e⟩ := Cardinal.lift_injective (MvPolynomial α <| ULift.{u} ℚ)
    obtain ⟨e⟩ := Cardinal.lift_injective (MvPolynomial α <| ULift.{u} ℚ)
    obtain ⟨e⟩ := Cardinal.lift_injective (MvPolynomial α <| ULift.{u} ℚ)
    obtain ⟨e⟩ := Cardinal.lift_injecti

For theorem:
theorem Infinite.nonempty_field {α : Type u} [Infinite α] : Nonempty (Field α) 
Attempt failure.

Working on Mathlib/FieldTheory/Finite/Basic.lean - 2024-08-20 15:57:35.506431.
---0/3204---
Verifying proof:
:= by
  haveI : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp⟩
  have : Fact p.Prime := ⟨hp

For theorem:
theorem Int.ModEq.pow_card_sub_one_eq_one {p : ℕ} (hp : Nat.Prime p) {n : ℤ} (hpn : IsCoprime n p) :
    n ^ (p - 1) ≡ 1 [ZMOD p] 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let φ : Kˣ →* K :=
    { toFun := fun x => x ^ i
    map_one' := by simp only [Units.val_pow_eq_pow_val] }

For theorem:
theorem sum_pow_units [DecidableEq K] (i : ℕ) :
    (∑ x : Kˣ, (x ^ i : K)) = if q - 1 ∣ i then -1 else 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases ZMod.sq_add_sq p x with ⟨a, b, ha, hb, hab⟩
  refine ⟨a, b,?_,?_,?_,?_⟩
  · simp only [Nat.sq_add_sq_zmod_eq_zero_iff_dvd, Int.cast_pow, Int.cast_pow, Int.cast_natCast,
      Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast,
      Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast,
      Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast,
      Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast,
      Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast,
      Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast,
      Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast,
      Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_natCast, Int.cast_pow, Int.cast_pow,
      Int.cast

For theorem:
theorem Nat.sq_add_sq_zmodEq (p : ℕ) [Fact p.Prime] (x : ℤ) :
    ∃ a b : ℕ, a ≤ p / 2 ∧ b ≤ p / 2 ∧ (a : ℤ) ^ 2 + (b : ℤ) ^ 2 ≡ x [ZMOD p] 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases FiniteField.card F (ringChar F) with ⟨n, hp, h⟩
  rw [h, Nat.pow_mod]
  constructor
  · intro hF
    rw [h, Nat.pow_mod]
    constructor
    · intro hF
      rw [h, Nat.pow_mod]
      constructor
    · intro hF
      rw [h, Nat.pow_mod]
      constructor
    · intro hF
      rw [h, Nat.pow_mod]
      constructor
    · intro hF
      rw [h, Nat.pow_mod]
      constructor
    · intro hF
      rw [h, Nat.pow_mod]
      constructor
    · intro hF
      rw [h, Nat.pow_mod]
      constructor
    · intro hF
      rw [h, Nat.pow_mod]
      constructor
    · intro hF
      rw [h, Nat.pow_mod]
      constructor
    · intro hF
      rw [h, Nat.pow_mod]
      constructor
    · intro hF
      rw [h, Nat.pow_mod]
      constructor
    · intro hF
      rw [h, Nat.pow_mod]
      constructor
    · intro hF
      rw [h, Nat.pow_mod]
      constructor
    · intro hF
      rw [h, Nat.pow_mod]
      constructor
      · intro hF
      rw [h, Nat.pow_mod]
      constructor
      · intro hF
      

For theorem:
theorem even_card_iff_char_two : ringChar F = 2 ↔ Fintype.card F % 2 = 0 
Attempt failure.

Working on Mathlib/FieldTheory/Finite/Polynomial.lean - 2024-08-20 15:58:05.712814.
---0/3204---
Verifying proof:
:=
  calc
    Module.rank K (R σ K) =
      Module.rank K (R σ K) :=
      Module.rank_le_of_injective (Submodule.injective_subtype _)
    _ = Module.rank K (R σ K) := by
      rw [← Finset.card_univ, ← Finset.card_image_of_injective _ (injective_iff_injective.mp injective_id)]
    _ = Module.rank K (R σ K) := by
      rw [Finset.card_image_of_injective _ (injective_iff_injective.mp injective_id),
      Finset.card_image_of_injective _ (injective_iff_injective.mp injective_id)]
    _ = Module.rank K (R σ K) := by
      rw [← Finset.card_univ, ← Finset.card_image_of_injective _ (injective_iff_injective.mp injective_id),
      Finset.card_image_of_injective _ (injective_iff_injective.mp (injective_iff_injective.mp injective_id)]
    _ = Module.rank K (R σ K) := by
      rw [← Finset.card_image_of_injective _ (injective_iff_injective.mp injective_id),
      Finset.card_image_of_injective _ (injective_iff_injective.mp (injective_iff_injective.mp injective_id),
      Finset.card_image_of_injective

For theorem:
theorem rank_R [Fintype σ] : Module.rank K (R σ K) = Fintype.card (σ → K) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [indicator]
  refine le_trans (degrees_prod _ _) (Finset.sum_le_sum fun s _ =>?_) (Finset.sum_le_sum fun s _ =>?_)
  rw [Finset.sum_le_sum fun s _ =>?_, Finset.sum_le_sum fun s _ =>?_, Finset.sum_singleton]

For theorem:
theorem degrees_indicator (c : σ → K) :
    degrees (indicator c) ≤ ∑ s : σ, (Fintype.card K - 1) • {s} 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply induction_on f
  · intro a; rw [expand_C, frobenius_def, ← C_pow, ZMod.pow_card]

For theorem:
theorem frobenius_zmod (f : MvPolynomial σ (ZMod p)) : frobenius _ p f = expand p f 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨i, hi⟩ : ∃ i, a i ≠ b i := by rwa [Ne, Function.funext_iff, not_forall] at h
  simp [h]

For theorem:
theorem eval_indicator_apply_eq_zero (a b : σ → K) (h : a ≠ b) : eval a (indicator b) = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [mem_restrictDegree_iff_sup, indicator]

For theorem:
theorem indicator_mem_restrictDegree (c : σ → K) :
    indicator c ∈ restrictDegree σ K (Fintype.card K - 1) 
Attempt failure.

Working on Mathlib/FieldTheory/Finite/Trace.lean - 2024-08-20 15:58:34.025295.
---0/3204---
Verifying proof:
:= by
  classical
    obtain ⟨b, hb⟩ := exists_primitive_element_of_ne_zero ha
    refine ⟨b,?_,?_⟩
    · rintro ⟨b, hb⟩
      refine ⟨b,?_,?_⟩
      rw [← Algebra.trace_eq_zero_iff (ZMod (ringChar F)), ← Algebra.trace_eq_zero_iff (ZMod (ringChar F)),
      Algebra.trace_eq_zero_iff (ZMod (ringChar F)), ← Algebra.trace_eq_zero_iff (ZMod (ringChar F)),
      Algebra.trace_eq_zero_iff (ZMod (ringChar F)), ← Algebra.trace_eq_zero_iff (ZMod (ringChar F)),
      Algebra.trace_eq_zero_iff (ZMod (ringChar F)), ← Algebra.trace_eq_zero_iff (ZMod (ringChar F)),
      Algebra.trace_eq_zero_iff (ZMod (ringChar F)), ← Algebra.trace_eq_zero_iff (ZMod (ringChar F)),
      Algebra.trace_eq_zero_iff (ZMod (ringChar F)), ← Algebra.trace_eq_zero_iff (ZMod (ringChar F)),
      Algebra.trace_eq_zero_iff (ZMod (ringChar F)), ← Algebra.trace_eq_zero_iff (ZMod (ringChar F)),
      Algebra.trace_eq_zero_iff (ZMod (ringChar F)), ← Algebra.trace_eq_zero_iff (ZMod (ringChar F)),
      Algebra.trac

For theorem:
theorem trace_to_zmod_nondegenerate (F : Type*) [Field F] [Finite F]
    [Algebra (ZMod (ringChar F)) F] {a : F} (ha : a ≠ 0) :
    ∃ b : F, Algebra.trace (ZMod (ringChar F)) F (a * b) ≠ 0 
Attempt failure.

Working on Mathlib/FieldTheory/Fixed.lean - 2024-08-20 15:58:36.450662.
---0/3204---
Verifying proof:
:= by
  induction' F using Finite.induction_on with d hd generalizing G
  · intro g
    rw [AlgHom.commutes, ← AlgHom.commutes, ← AlgHom.commutes, ← AlgHom.commutes,
      AlgHom.commutes, ← AlgHom.commutes, ← AlgHom.commutes, ← AlgHom.commutes,
      AlgHom.commutes, ← AlgHom.commutes, ← AlgHom.commutes, ← AlgHom.commutes,
      AlgHom.commutes, ← AlgHom.commutes, ← AlgHom.commutes, ← AlgHom.commutes,
      AlgHom.commutes, ← AlgHom.commutes, ← AlgHom.commutes, ← AlgHom.commutes, ←
    AlgHom.commutes, ← AlgHom.commutes, ← AlgHom.commutes, ← AlgHom.commutes]
    exact AlgHom.commutes

For theorem:
theorem toAlgHom_bijective (G : Type u) (F : Type v) [Group G] [Field F] [Finite G]
    [MulSemiringAction G F] [FaithfulSMul G F] :
    Function.Bijective (MulSemiringAction.toAlgHom _ _ : G → F →ₐ[subfield G F] F) 
Attempt failure.

Working on Mathlib/FieldTheory/Galois.lean - 2024-08-20 15:58:49.023852.
---0/3204---
Verifying proof:
:=
  { to_isSeparable := Algebra.isSeparable_tower_top_of_isSeparable F K E
    to_normal := Normal.tower_top_of_normal F K E }

For theorem:
theorem IsGalois.tower_top_of_isGalois [IsGalois F E] : IsGalois K E 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  tfae_have 1 → 3
  · rw [← finrank_eq_card_chooseBasisIndex, ← finrank_eq_card_chooseBasisIndex]
    exact finrank_eq_card_chooseBasisIndex

For theorem:
theorem tfae [FiniteDimensional F E] :
    List.TFAE [IsGalois F E, IntermediateField.fixedField (⊤ : Subgroup (E ≃ₐ[F] E)) = ⊥,
      Fintype.card (E ≃ₐ[F] E) = finrank F E, ∃ p: F[X], p.Separable ∧ p.IsSplittingField F E] 
Attempt failure.

Working on Mathlib/FieldTheory/IntermediateField.lean - 2024-08-20 15:59:17.264300.
---0/3204---
Verifying proof:
:=
  aeval_algHom_apply (S.val.restrictScalars R) x P

For theorem:
theorem aeval_coe {R : Type*} [CommRing R] [Algebra R K] [Algebra R L] [IsScalarTower R K L]
    (x : S) (P : R[X]) : aeval (x : L) P = aeval x P 
Attempt failure.

Working on Mathlib/FieldTheory/IsAlgClosed/Spectrum.lean - 2024-08-20 15:59:39.558116.
---0/3204---
Verifying proof:
:= by
  simp only [mem_image, mem_setOf_eq, mem_image, mem_singleton_iff] at ha ⊢
  exact ha.image _

For theorem:
theorem map_pow_of_nonempty [IsAlgClosed 𝕜] {a : A} (ha : (σ a).Nonempty) (n : ℕ) :
    σ (a ^ n) = (· ^ n) '' σ a 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Set.eq_of_subset_of_subset (fun k hk =>?_) (subset_aeval a p)
  refine Set.eq_of_subset_of_subset (fun k hk =>?_) (subset_aeval a p)?_
  refine Set.eq_of_subset_of_subset (fun k hk =>?_) (subset_aeval a p)
  simp only [Set.mem_image, Set.mem_image, Set.mem_image, Set.mem_setOf_eq, Set.mem_image,
    Set.mem_image, Set.mem_image, Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_image,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_apply_eq_imp_iff₂, Set.mem_image, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, Set.mem_image, forall_exists_index,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, Set.mem_image, forall_exists_index,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, forall_exists_index, and_imp,
    forall_apply_eq_imp_iff₂, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂,
    forall_exists_index, and_imp, forall_apply_

For theorem:
theorem map_polynomial_aeval_of_degree_pos [IsAlgClosed 𝕜] (a : A) (p : 𝕜[X])
    (hdeg : 0 < degree p) : σ (aeval a p) = (eval · p) '' σ a := by
    refine Set.eq_of_subset_of_subset (fun k hk => ?_) (subset_polynomial_aeval a p)
    have hprod 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨k, hk⟩ := Multiset.exists_mem_of_not_isUnit_aeval_prod h
  obtain ⟨k, hk⟩ := Multiset.exists_mem_of_not_isUnit h
  obtain ⟨k, hk⟩ := Multiset.exists_mem_of_not_isUnit h
  obtain ⟨k, hk⟩ := Multiset.exists_mem_of_not_isUnit h
  obtain ⟨k, hk⟩ := Multiset.exists_mem_of_not_isUnit h
  obtain ⟨k, hk⟩ := Multiset.exists_mem_of_not_isUnit h
  obtain ⟨k, hk⟩ := Multiset.exists_mem_of_not_isUnit h
  obtain ⟨k, hk⟩ := Multiset.exists_mem_of_not_isUnit h
  obtain ⟨k, hk⟩ := Multiset.exists_mem_of_not_isUnit h
  obtain ⟨k, hk⟩ := Multiset.exists_mem_of_not_isUnit h
  have hk : ¬IsUnit (aeval a (Multiset.map (fun x : R => X - C x) p.roots).prod) := by
    rw [Multiset.mem_map] at hk
    exact ⟨k, hk⟩

For theorem:
theorem exists_mem_of_not_isUnit_aeval_prod [IsDomain R] {p : R[X]} {a : A}
    (h : ¬IsUnit (aeval a (Multiset.map (fun x : R => X - C x) p.roots).prod)) :
    ∃ k : R, k ∈ σ a ∧ eval k p = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have := map_polynomial_aeval_of_nonempty a (X ^ n : 𝕜[X]) ha
  simp only [mem_image, mem_image, mem_setOf_eq, mem_singleton_iff, mem_singleton_iff,
    mem_singleton_iff, mem_singleton_iff, mem_singleton_iff, mem_singleton_iff] at ha
  simp only [mem_singleton_iff, mem_singleton_iff, mem_singleton_iff] at ha
  simp only [mem_singleton_iff, mem_singleton_iff, mem_singleton_iff] at ha
  simp only [mem_singleton_iff, mem_singleton_iff, mem_singleton_iff] at ha
  simp only [mem_singleton_iff, mem_singleton_iff, mem_singleton_iff] at ha
  simp only [mem_singleton_iff, mem_singleton_iff, mem_singleton_iff] at ha
  simp only [mem_singleton_iff, mem_singleton_iff, mem_singleton_iff] at ha
  simp only [mem_singleton_iff, mem_singleton_iff, mem_singleton_iff] at ha
  simp only [mem_singleton_iff, mem_singleton_iff, mem_singleton_iff] at ha
  simp only [mem_singleton_iff, mem_singleton_iff, mem_singleton_iff] at ha
  simp only [mem_singleton_iff, mem_singleton_iff, mem_singleton_iff, mem_singleton_iff] at ha

For theorem:
theorem map_pow_of_nonempty [IsAlgClosed 𝕜] {a : A} (ha : (σ a).Nonempty) (n : ℕ) :
    σ (a ^ n) = (· ^ n) '' σ a 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨p, ⟨h_mon, h_eval_p⟩⟩ := isAlgClosed_of_finiteDimensional 𝕜 A
  obtain ⟨p, ⟨h_mon, h_eval_p⟩⟩ := isAlgClosed_of_finiteDimensional 𝕜 A

For theorem:
theorem nonempty_of_isAlgClosed_of_finiteDimensional [IsAlgClosed 𝕜] [Nontrivial A]
    [I : FiniteDimensional 𝕜 A] (a : A) : (σ a).Nonempty 
Attempt failure.

Working on Mathlib/FieldTheory/KrullTopology.lean - 2024-08-20 15:59:59.128106.
---0/3204---
Verifying proof:
:= by
  refine le_trans (fixingSubgroup_le_fixingSubgroup h12)?_
  rintro _ ⟨x, hx, rfl⟩
  exact ⟨x, hx, rfl⟩

For theorem:
theorem IntermediateField.fixingSubgroup.antimono {K L : Type*} [Field K] [Field L] [Algebra K L]
    {E1 E2 : IntermediateField K L} (h12 : E1 ≤ E2) : E2.fixingSubgroup ≤ E1.fixingSubgroup 
Attempt failure.

Working on Mathlib/FieldTheory/KummerExtension.lean - 2024-08-20 16:00:04.434593.
---0/3204---
Verifying proof:
:= by
  letI := Fact.mk H
  letI : Algebra K K[n√a] := inferInstance
  have hn := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible hn)
  have hn := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible hn)
  have hn' := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible hn)
  have hn' := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible hn)
  have hn' := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible hn)
  have hn' := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible hn)
  have hn' := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible hn)
  have hn' := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible hn)
  have hn' := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible hn)
  have hn' := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible hn)
  have hn' := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible hn)
  have hn' := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible hn)
  have hn' := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible hn)
  have hn' := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible hn)
  have hn' := Nat.pos_iff_ne_z

For theorem:
theorem Polynomial.separable_X_pow_sub_C_of_irreducible : (X ^ n - C a).Separable 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  tfae_have 1 → 3
  · exact ⟨isGalois_of_isGalois K L hK, isCyclic_of_isGalois K L hK⟩

For theorem:
lemma isCyclic_tfae (K L) [Field K] [Field L] [Algebra K L] [FiniteDimensional K L]
    (hK : (primitiveRoots (FiniteDimensional.finrank K L) K).Nonempty) :
    List.TFAE [
      IsGalois K L ∧ IsCyclic (L ≃ₐ[K] L),
      ∃ a : K, Irreducible (X ^ (finrank K L) - C a) ∧
        IsSplittingField K L (X ^ (finrank K L) - C a),
      ∃ (α : L), α ^ (finrank K L) ∈ Set.range (algebraMap K L) ∧ K⟮α⟯ = ⊤] 
Attempt failure.

Working on Mathlib/FieldTheory/Minpoly/Basic.lean - 2024-08-20 16:00:50.267963.
---0/3204---
Verifying proof:
:= by
  delta minpoly
  rw [dif_pos hx]
  exact (dif_pos hx).1

For theorem:
theorem monic (hx : IsIntegral A x) : Monic (minpoly A x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine fun ha => (minpoly.monic hx).ne_zero (minpoly.ne_zero hx)?_
  rw [aeval_def, eval₂_eq_eval_map, ← eval_map, ← eval_map, ← eval₂_eq_eval_map,
    ← eval₂_eq_eval_map, ← eval₂_eq_eval_map, ← eval₂_eq_eval_map, ← eval₂_eq_eval_map,
    ← eval₂_eq_eval_map, ← eval₂_eq_eval_map, ← eval₂_eq_eval_map, ← eval₂_eq_eval_map,
    ← eval₂_eq_eval_map, ← eval₂_eq_eval_map, ← eval₂_eq_eval_map, ← eval₂_eq_eval_map,
    ← eval₂_eq_eval_map, ← eval₂_eq_eval_map, ← eval₂_eq_eval_map, ← eval₂_eq_eval_map]

For theorem:
theorem aeval_ne_zero_of_dvdNotUnit_minpoly {a : A[X]} (hx : IsIntegral A x) (hamonic : a.Monic)
    (hdvd : DvdNotUnit a (minpoly A x)) : Polynomial.aeval x a ≠ 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  delta minpoly
  split_ifs with hx  · rw [dif_pos hx]
  exact (degree_lt_wf.min_mem _ hx).2

For theorem:
theorem aeval : aeval x (minpoly A x) = 0 
Attempt failure.

Working on Mathlib/FieldTheory/Minpoly/Field.lean - 2024-08-20 16:01:07.356142.
---0/3204---
Verifying proof:
:= by
  refine ⟨minpoly.ne_zero hx, not_isUnit A x,?_⟩
  rintro p q ⟨d, h⟩
  rintro p q ⟨d, h⟩
  rintro p q ⟨d, h⟩
  rintro p q ⟨d, h⟩
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 := by simp [h]
  have : Polynomial.aeval x (p * q) = 0 :=

For theorem:
theorem prime (hx : IsIntegral A x) : Prime (minpoly A x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine (minpoly.unique _?_ (monic_X_pow_sub_C _ hσ.orderOf_pos)).trans?_
  · rw [minpoly.unique _ _ (monic_X_pow_sub_C _ hσ.orderOf_pos]
    exact minpoly.unique _ _ (monic_X_pow_sub_C _ hσ.orderOf_pos)

For theorem:
lemma minpoly_algEquiv_toLinearMap (σ : L ≃ₐ[K] L) (hσ : IsOfFinOrder σ) :
    minpoly K σ.toLinearMap = X ^ (orderOf σ) - C 1 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    have zero_root := zero_isRoot_of_coeff_zero_eq_zero h
    rw [← coeff_zero_eq_zero h, coeff_zero_eq_zero h, coeff_zero]

For theorem:
theorem coeff_zero_eq_zero (hx : IsIntegral A x) : coeff (minpoly A x) 0 = 0 ↔ x = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases hp0 : p = 0
  · simp only [hp0, dvd_zero]
  have hx : IsIntegral A x := by
    rw [← isAlgebraic_iff_isIntegral]
    have hx : IsIntegral A x := by
      rw [← isAlgebraic_iff_isIntegral] at hx
      rw [← isAlgebraic_iff_isIntegral]
      rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff_isIntegral] at hx
    rw [← isAlgebraic_iff

For theorem:
theorem dvd {p : A[X]} (hp : Polynomial.aeval x p = 0) : minpoly A x ∣ p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  contrapose! h
  simpa only [hx, coeff_zero_eq_zero] using h

For theorem:
theorem coeff_zero_ne_zero (hx : IsIntegral A x) (h : x ≠ 0) : coeff (minpoly A x) 0 ≠ 0 
Attempt failure.

Working on Mathlib/FieldTheory/Minpoly/IsIntegrallyClosed.lean - 2024-08-20 16:01:41.110292.
---0/3204---
Verifying proof:
:= by
  refine (eq_of_irreducible_of_field K (algebraMap S L s)).symm.trans?_
  rw [minpoly.eq_of_irreducible_of_monic hs, minpoly.eq_of_irreducible_of_monic hs]

For theorem:
theorem isIntegrallyClosed_eq_field_fractions [IsDomain S] {s : S} (hs : IsIntegral R s) :
    minpoly K (algebraMap S L s) = (minpoly R s).map (algebraMap R K) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [degree_eq_natDegree hp0] at hp
  rw [degree_eq_natDegree hp0, degree_eq_natDegree hp0, degree_eq_natDegree hp0] at hp
  rw [degree_eq_natDegree hp0, degree_eq_natDegree hp0, degree_eq_natDegree hp0] at hp
  rw [degree_eq_natDegree hp0, degree_eq_natDegree hp0, degree_eq_natDegree hp0] at hp
  rw [degree_eq_natDegree hp0, degree_eq_natDegree hp0, degree_eq_natDegree hp0] at hp
  rw [degree_eq_natDegree hp0, degree_eq_natDegree hp0, degree_eq_natDegree hp0] at hp
  rw [degree_eq_natDegree hp0, degree_eq_natDegree hp0, degree_eq_natDegree hp0] at hp
  rw [degree_eq_natDegree hp0, degree_eq_natDegree hp0, degree_eq_natDegree hp0] at hp
  rw [degree_eq_natDegree hp0, degree_eq_natDegree hp0, degree_eq_natDegree hp0] at hp
  rw [degree_eq_natDegree hp0, degree_eq_natDegree hp0, degree_eq_natDegree hp0] at hp
  rw [degree_eq_natDegree hp0, degree_eq_natDegree hp0, degree_eq_natDegree hp0] at hp
  rw [degree_eq_natDegree hp0, degree_eq_natDegree hp0, degree_eq_natDegree hp0] at hp
  rw [degree_eq_natDegr

For theorem:
theorem IsIntegrallyClosed.degree_le_of_ne_zero {s : S} (hs : IsIntegral R s) {p : R[X]}
    (hp0 : p ≠ 0) (hp : Polynomial.aeval s p = 0) : degree (minpoly R s) ≤ degree p 
Attempt failure.

Working on Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean - 2024-08-20 16:01:53.269019.
---0/3204---
Verifying proof:
:= by
  rw [coeff_minpolyDiv_sub_pow_mem_span_singleton]
  exact Submodule.subset_span (Set.mem_image_of_mem _ hi)

For theorem:
lemma coeff_minpolyDiv_sub_pow_mem_span {i} (hi : i ≤ natDegree (minpolyDiv R x)) :
    coeff (minpolyDiv R x) (natDegree (minpolyDiv R x) - i) - x ^ i ∈
      Submodule.span R ((x ^ ·) '' Set.Iio i) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [coeff_minpolyDiv_sub_pow_mem_span_singleton]
  exact Submodule.subset_span (Set.mem_image_of_mem _ hi)

For theorem:
lemma coeff_minpolyDiv_sub_pow_mem_span {i} (hi : i ≤ natDegree (minpolyDiv R x)) :
    coeff (minpolyDiv R x) (natDegree (minpolyDiv R x) - i) - x ^ i ∈
      Submodule.span R ((x ^ ·) '' Set.Iio i) 
Attempt failure.

Working on Mathlib/FieldTheory/NormalClosure.lean - 2024-08-20 16:02:04.605793.
---0/3204---
Verifying proof:
:= by
  rw [alg.isNormalClosure_iff]; constructor
  · rw [alg.normalClosure_eq_iSup_adjoin_of_splits]
    exact isNormalClosure_eq_iSup_adjoin_of_splits splits

For theorem:
lemma isNormalClosure_normalClosure : IsNormalClosure F K (normalClosure F K L) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  iSup_le fun f _ ⟨x, hx⟩ ↦ le_iSup (α := IntermediateField.adjoin F ((minpoly F x).rootSet L))

For theorem:
lemma normalClosure_le_iSup_adjoin :
    normalClosure F K L ≤ ⨆ x : K, IntermediateField.adjoin F ((minpoly F x).rootSet L) 
Attempt failure.

Working on Mathlib/FieldTheory/PerfectClosure.lean - 2024-08-20 16:02:32.061263.
---0/3204---
Verifying proof:
:= by
  induction' n with n ih; rfl
  rw [iterate_succ_apply, ← ih, frobenius_def]
  rw [iterate_succ_apply, ← ih, frobenius_def, iterate_succ_apply, ← ih, frobenius_def]

For theorem:
theorem iterate_frobenius_mk (n : ℕ) (x : K) :
    (frobenius (PerfectClosure K p) p)^[n] (mk K p ⟨n, x⟩) = of K p x 
Attempt failure.

Working on Mathlib/FieldTheory/PrimitiveElement.lean - 2024-08-20 16:02:38.608460.
---0/3204---
Verifying proof:
:= fun α ↦
  have ⟨_m, _n, hneq, heq⟩ := Finite.exists_ne_map_eq_of_infinite fun x ↦
    Finite.exists_ne_map_eq_of_infinite fun x ↦ Finite.exists_ne_map_eq_of_infinite fun x ↦
      Finite.exists_ne_map_eq_of_infinite fun x ↦ Finite.exists_ne_map_eq_of_infinite fun x ↦
      Finite.exists_ne_map_eq_of_infinite fun x ↦ Finite.exists_ne_map_eq_of_infinite fun x ↦
      Finite.exists_ne_map_eq_of_infinite fun x ↦ Finite.exists_ne_map_eq_of_infinite fun x ↦
      Finite.exists_ne_map_eq_of_infinite fun x ↦ Finite.exists_ne_map_eq_of_infinite fun x ↦
      Finite.exists_ne_map_eq_of_infinite fun x ↦ Finite.exists_ne_map_eq_of_infinite fun x ↦
      Finite.exists_ne_map_eq_of_infinite fun x ↦ Finite.exists_ne_map_eq_of_infinite fun x ↦
      Finite.exists_ne_map_eq_of_infinite fun x ↦ Finite.exists_ne_map_eq_of_infinite fun x ↦
      Finite.exists_ne_map_eq_of_infinite fun x ↦ Finite.exists_ne_map_eq_of_infinite fun x ↦
      Finite.exists_ne_map_eq_of_infinite fun x 

For theorem:
theorem isAlgebraic_of_finite_intermediateField
    [Finite (IntermediateField F E)] : Algebra.IsAlgebraic F E 
Attempt failure.

Working on Mathlib/FieldTheory/PurelyInseparable.lean - 2024-08-20 16:02:59.676121.
---0/3204---
Verifying proof:
:= isPurelyInseparable_iff.2 fun x ↦ by
  set L := separableClosure F E

For theorem:
theorem separableClosure.isPurelyInseparable [Algebra.IsAlgebraic F E] :
    IsPurelyInseparable (separableClosure F E) E 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun x ↦ (isIntegral F (algebraMap E K x)).tower_bot,?_⟩
  refine ⟨fun x ↦ (isIntegral F (algebraMap E K x)).tower_bot,?_⟩
  · rw [← IsScalarTower.algebraMap_eq F E K]
    exact IsScalarTower.algebraMap_eq F E K

For theorem:
theorem IsPurelyInseparable.tower_bot [Algebra E K] [IsScalarTower F E K]
    [IsPurelyInseparable F K] : IsPurelyInseparable F E 
Attempt failure.

Working on Mathlib/FieldTheory/RatFunc/Basic.lean - 2024-08-20 16:04:19.415181.
---0/3204---
Verifying proof:
:= by
  induction' x using RatFunc.induction_on with p q hq
  have q_div_ne_zero : q / gcd p q ≠ 0 := RatFunc.induction_on with p q hq
  have q_div_ne_zero : q / gcd p q ≠ 0 := RatFunc.induction_on with p q hq
  have q_div_ne_zero : q / gcd p q ≠ 0 := RatFunc.induction_on with p q hq
  have q_div_ne_zero : q / gcd p q ≠ 0 := RatFunc.induction_on with p q hq
  have q_div_ne_zero : q / gcd p q ≠ 0 := RatFunc.induction_on with p q hq
  have q_div_ne_zero : q / gcd p q ≠ 0 := RatFunc.induction_on with p q hq
  have q_div_ne_zero : q / gcd p q ≠ 0 := RatFunc.induction_on with p q hq
  have q_div_ne_zero : q / gcd p q ≠ 0 := RatFunc.induction_on with p q hq
  have q_div_ne_zero : q / gcd p q ≠ 0 := RatFunc.induction_on with p q hq
  have q_div_ne_zero : q / gcd p q ≠ 0 := RatFunc.induction_on with p q hq
  have q_div_ne_zero : q / gcd p q ≠ 0 := RatFunc.induction_on with p q hq
  have q_div_ne_zero : q / gcd p q ≠ 0 := RatFunc.induction_on with p q hq
  have q_div_ne_zero : q / gcd p q ≠ 

For theorem:
theorem num_div_denom (x : RatFunc K) : algebraMap _ _ (num x) / algebraMap _ _ (denom x) = x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [denom_dvd (mul_ne_zero (denom_ne_zero x) (denom_ne_zero y))]

For theorem:
theorem denom_add_dvd (x y : RatFunc K) : denom (x + y) ∣ denom x * denom y 
Attempt failure.

Working on Mathlib/FieldTheory/Separable.lean - 2024-08-20 16:05:28.206432.
---0/3204---
Verifying proof:
:= by
  rw [multiplicity.squarefree_iff_multiplicity_le_one p]
  exact fun f => or_iff_not_imp_right.mpr fun hunit => multiplicity.ne_zero hsep

For theorem:
theorem Separable.squarefree {p : R[X]} (hsep : Separable p) : Squarefree p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine Finset.induction_on s (by simp) (fun x hx y hy hxy =>?_)?_?_
  · intro x hx y hy hxy
    rw [Finset.prod_insert hxy]
    exact fun x hx y hy hxy => hxy (h x hx hy)
  · rw [Finset.prod_insert hxy]
    exact fun x hx y hy => hxy (h x hx hy)
  · rw [Finset.prod_insert hxy]
    exact fun x hx y hy hxy => hxy (h x hx y hy)
  · rw [Finset.prod_insert hxy]
    exact fun x hx y hy hxy => hxy (h x hx hy)
  · rw [Finset.prod_insert hxy]
    exact fun x hx y hy hxy => hxy (h x hx hy)
  · rw [Finset.prod_insert hxy]
    exact fun x hx y hy hxy => hxy (h x hx hy)
  · rw [Finset.prod_insert hxy]
    exact fun x hx y hy hxy => hxy (h x hx y hy)
  · rw [Finset.prod_insert hxy]
    exact fun x hx y hy => hxy (h x hx hy)
  · rw [Finset.prod_insert hxy]
    exact fun x hx y hy => hxy (h x hx hy)
  · rw [Finset.prod_insert hxy]
    exact fun x hx y hy hxy => hxy (h x hx hy)
    rw [Finset.prod_insert hxy]
    exact fun x hx y hy hxy => hxy (h x hx hy)
    rw [Finset.prod_insert hxy]
    exact fun x h

For theorem:
theorem separable_prod' {ι : Sort _} {f : ι → R[X]} {s : Finset ι} :
    (∀ x ∈ s, ∀ y ∈ s, x ≠ y → IsCoprime (f x) (f y)) →
      (∀ x ∈ s, (f x).Separable) → (∏ x ∈ s, f x).Separable 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [multiplicity.squarefree_iff_multiplicity_le_one p]
  intro f
  by_cases hunit : IsUnit f
  · exact Or.inr hunit

For theorem:
theorem Separable.squarefree {p : R[X]} (hsep : Separable p) : Squarefree p 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [separable_iff_derivative_ne_zero hf, Ne, ← degree_derivative_eq]

For theorem:
theorem _root_.Irreducible.separable [CharZero F] {f : F[X]} (hf : Irreducible f) :
    f.Separable 
Attempt failure.

Working on Mathlib/FieldTheory/SeparableClosure.lean - 2024-08-20 16:06:14.645365.
---0/3204---
Verifying proof:
:=
  bot_unique fun x hx ↦ mem_bot.2
    ⟨⟨x, IsSeparable.of_algebra_isSeparable_of_isSeparable_of_isSeparable_of_isSeparable_of_isSeparable_of_isSeparable F E⟩

For theorem:
theorem separableClosure.separableClosure_eq_bot :
    separableClosure (separableClosure F E) E = ⊥ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have := lift_insepDegree_eq_of_equiv _ _ _ (botEquiv F E)
  rwa [insepDegree_self, Cardinal.lift_one, ← Cardinal.lift_one, ← Cardinal.lift_lift]

For theorem:
theorem insepDegree_bot : insepDegree F (⊥ : IntermediateField F E) = 1 
Attempt failure.

Working on Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean - 2024-08-20 16:06:43.795841.
---0/3204---
Verifying proof:
:= by
  rw [← oangle_sign_of_sameRay_vsub hp₁p₂ hp₁p₂ hp₁p₂ hp₁p₂ hp₁p₂ hp₁p₂ hp₁p₂ hp₃p₄]
  refine oangle_sign_oangle_sign_of_sameRay_vsub hp₁p₂ hp₁p₂ hp₁p₂ hp₃p₄?_?_?_
  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_insert_iff, Set.mem_singleton_iff,
      Set.mem_singleton_iff, Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_insert_iff, Set.mem_singleton_iff,
      Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_insert_iff, Set.mem_singleton_iff,
      Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_insert_iff, Set.mem_singleton_iff,
      Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_insert_iff, Set.mem_singleton_iff,
      Set.mem_insert_iff, Set.mem_singleton_i

For theorem:
theorem _root_.Collinear.oangle_sign_of_sameRay_vsub {p₁ p₂ p₃ p₄ : P} (p₅ : P) (hp₁p₂ : p₁ ≠ p₂)
    (hp₃p₄ : p₃ ≠ p₄) (hc : Collinear ℝ ({p₁, p₂, p₃, p₄} : Set P))
    (hr : SameRay ℝ (p₂ -ᵥ p₁) (p₄ -ᵥ p₃)) : (∡ p₁ p₅ p₂).sign = (∡ p₃ p₅ p₄).sign 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have h₁₂₄₅ : line[ℝ, p₁, p₂] ∥ line[ℝ, p₁, p₂] ∥ line[ℝ, p₃, p₂] ∥ line[ℝ, p₁, p₂] ∥ line[ℝ, p₃, p₂] ∥ line[ℝ, p₁, p₂] ∥ line[ℝ, p₃, p₂] ∥ line[ℝ, p₃, p₄] ∥ line[ℝ, p₃, p₄] ∥ line[ℝ, p₃, p₄] ∥ line[ℝ, p₄, p₄] ∥ line[ℝ, p₃, p₄] ∥ line[ℝ, p₄, p₄] ∥ line[ℝ, p₃, p₄] ∥ line[ℝ, p₃, p₄] ∥ line[ℝ, p₄, p₄] ∥ line[ℝ, p₃, p₄] ∥ line[ℝ, p₄, p₄] ∥ line[ℝ, p₃, p₄] ∥ line[ℝ, p₄, p₄] ∥ line[ℝ, p₄, p₆] ∥ line[ℝ, p₃, p₄] ∥ line[ℝ, p₄, p₄] ∥ line[ℝ, p₄, p₆] ∥ line[ℝ, p₄, p₄] ∥ line[ℝ, p₃, p₄] ∥ line[ℝ, p₄, p₆] ∥ line[ℝ, p₄, p₄] ∥ line[ℝ, p₃, p₄] ∥ line[ℝ, p₄, p₆] ∥ line[ℝ, p₃, p₄] ∥ line[ℝ, p₄, p₆] ∥ line[ℝ, p₄, p₄] ∥ line[ℝ, p₄, p₆] ∥ line[ℝ, p₃, p₄] ∥ line[ℝ, p₄, p₆] ∥ line[ℝ, p₄, p₆] ∥ line[ℝ, p₄, p₄] ∥ line[

For theorem:
theorem two_zsmul_oangle_of_parallel {p₁ p₂ p₃ p₄ p₅ p₆ : P}
    (h₁₂₄₅ : line[ℝ, p₁, p₂] ∥ line[ℝ, p₄, p₅]) (h₃₂₆₅ : line[ℝ, p₃, p₂] ∥ line[ℝ, p₆, p₅]) :
    (2 : ℤ) • ∡ p₁ p₂ p₃ = (2 : ℤ) • ∡ p₄ p₅ p₆ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [angle_comm]
  exact angle_eq_pi_div_two_of_oangle_eq_pi h

For theorem:
theorem angle_rev_eq_pi_div_two_of_oangle_eq_pi_div_two {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = ↑(π / 2)) :
    ∠ p₃ p₂ p₁ = π / 2 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases h : p₁ = p₂; · simp [h]
  exact (sbtw_midpoint ℝ p₁ p₂).symm

For theorem:
theorem oangle_midpoint_left (p₁ p₂ p₃ : P) : ∡ (midpoint ℝ p₁ p₂) p₂ p₃ = ∡ p₁ p₂ p₃ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← oangle_sign_of_sameRay_vsub hp₁p₂ hp₁p₂ hp₁p₂ hp₁p₂ hp₁p₂ hp₁p₂ hp₁p₂ hp₃p₄]
  refine oangle_sign_oangle_sign_of_sameRay_vsub hp₁p₂ hp₁p₂ hp₁p₂ hp₃p₄?_?_?_
  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_insert_iff, Set.mem_singleton_iff,
      Set.mem_singleton_iff, Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_insert_iff, Set.mem_singleton_iff,
      Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_insert_iff, Set.mem_singleton_iff,
      Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_insert_iff, Set.mem_singleton_iff,
      Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_insert_iff, Set.mem_singleton_iff,
      Set.mem_insert_iff, Set.mem_singleton_i

For theorem:
theorem _root_.Collinear.oangle_sign_of_sameRay_vsub {p₁ p₂ p₃ p₄ : P} (p₅ : P) (hp₁p₂ : p₁ ≠ p₂)
    (hp₃p₄ : p₃ ≠ p₄) (hc : Collinear ℝ ({p₁, p₂, p₃, p₄} : Set P))
    (hr : SameRay ℝ (p₂ -ᵥ p₁) (p₄ -ᵥ p₃)) : (∡ p₁ p₅ p₂).sign = (∡ p₃ p₅ p₄).sign 
Attempt failure.

Working on Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean - 2024-08-20 16:08:08.900589.
---0/3204---
Verifying proof:
:= by
  have hs' : (o.oangle w x).sign = (o.oangle y z).sign := by
    rw [o.oangle_eq_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle_of_sign_eq hw hx hy hs,
      o.oangle_eq_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle
  have hs' : (o.oangle y z).sign = (o.oangle y z).sign := by
    rw [o.oangle_eq_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg,
      o.oangle_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle
  have hs' : (o.oangle y z).sign = (o.oangle y z).sign := by
    rw [o.oangle_eq_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg,
      o.oangle_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle
  have hs' : (o.oangle y z).sign = (o.oangle y z).sign := by
    rw [o.oangle_eq_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle
  have hs' : (o.oangle y z).sign = (o.oangle y z).sign := by
    rw [o.oangle_e

For theorem:
theorem angle_eq_iff_oangle_eq_of_sign_eq {w x y z : V} (hw : w ≠ 0) (hx : x ≠ 0) (hy : y ≠ 0)
    (hz : z ≠ 0) (hs : (o.oangle w x).sign = (o.oangle y z).sign) :
    InnerProductGeometry.angle w x = InnerProductGeometry.angle y z ↔
    o.oangle w x = o.oangle y z 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hf' : o.oangle x y = Complex.arg (f x) * f y := by
    rw [o.oangle_eq_angle_or_eq_neg_angle hf, o.oangle_eq_angle_or_eq_neg_angle hf]
    simp only [oangle_eq_angle_of_sign_eq_one hf', Complex.arg_real_mul, Complex.arg_real_mul,
      Complex.arg_real_mul, Complex.arg_real_mul, Complex.arg_real_mul, Complex.orthonormalBasis_apply,
      Complex.orthonormalBasis_apply, Complex.orthonormalBasis_apply, Complex.orthonormalBasis_apply,
      Complex.orthonormalBasis_apply, Complex.orthonormalBasis_apply, Complex.orthonormalBasis_apply,
      Complex.orthonormalBasis_apply, Complex.orthonormalBasis_apply, Complex.orthonormalBasis_apply,
      Complex.orthonormalBasis_apply, Complex.orthonormalBasis_apply, Complex.orthonormalBasis_apply,
      Complex.orthonormalBasis_apply, Complex.orthonormalBasis_apply, Complex.orthonormalBasis_apply,
      Complex.orthonormalBasis_apply, Complex.orthonormalBasis_apply, Complex.orthonormalBasis_apply,
      Complex.orthonormalBasis_apply, Complex.orthonormalBasis_a

For theorem:
theorem oangle_map_complex (f : V ≃ₗᵢ[ℝ] ℂ)
    (hf : Orientation.map (Fin 2) f.toLinearEquiv o = Complex.orientation) (x y : V) :
    o.oangle x y = Complex.arg (conj (f x) * f y) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases hx : x = 0; · simp [hx]
  by_cases hy : y = 0; · simp [hy]
  by_cases hy : y = 0; · simp [hy]

For theorem:
theorem oangle_sign_neg_right (x y : V) : (o.oangle x (-y)).sign = -(o.oangle x y).sign 
Attempt failure.

---0/3204---
Verifying proof:
:= by by_cases h : r₁ = 0 <;> simp [h]

For theorem:
theorem two_zsmul_oangle_smul_smul_self (x : V) {r₁ r₂ : ℝ} :
    (2 : ℤ) • o.oangle (r₁ • x) (r₂ • x) = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases hx : x = 0; · simp [hx]

For theorem:
theorem inner_eq_norm_mul_norm_mul_cos_oangle (x y : V) :
    ⟪x, y⟫ = ‖x‖ * ‖y‖ * Real.Angle.cos (o.oangle x y) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [oangle_eq_zero_iff_sameRay, oangle_eq_pi_iff]

For theorem:
theorem oangle_eq_zero_or_eq_pi_iff_right_eq_smul {x y : V} :
    o.oangle x y = 0 ∨ o.oangle x y = π ↔ x = 0 ∨ ∃ r : ℝ, y = r • x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases hx : x = 0; · · simp [hx]

For theorem:
theorem eq_zero_or_oangle_eq_iff_inner_eq_zero {x y : V} :
    x = 0 ∨ y = 0 ∨ o.oangle x y = (π / 2 : ℝ) ∨ o.oangle x y = (-π / 2 : ℝ) ↔ ⟪x, y⟫ = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp [oangle]

For theorem:
theorem oangle_neg_orientation_eq_neg (x y : V) : (-o).oangle x y = -o.oangle x y 
Attempt failure.

---0/3204---
Verifying proof:
:=
  o.right_ne_zero_of_oangle_sign_ne_zero (h.symm ▸ by decide) (h.symm ▸ by decide)

For theorem:
theorem right_ne_zero_of_oangle_sign_eq_neg_one {x y : V} (h : (o.oangle x y).sign = -1) : y ≠ 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases hx : x = 0
  · simp [hx]

For theorem:
theorem two_zsmul_oangle_neg_left (x y : V) :
    (2 : ℤ) • o.oangle (-x) y = (2 : ℤ) • o.oangle x y 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [sub_eq_iff_eq_add, o.oangle_add_swap hx hy hz]

For theorem:
theorem oangle_sub_left {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :
    o.oangle x z - o.oangle x y = o.oangle y z 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← oangle_sign_neg_left, sub_eq_neg_add, oangle_sign_add_smul_left]

For theorem:
theorem oangle_sign_smul_sub_left (x y : V) (r : ℝ) :
    (o.oangle (r • y - x) y).sign = -(o.oangle x y).sign 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases h : o.oangle x y = 0 ∨ o.oangle x y = 0 ∨ o.oangle x y = 0 ∨ o.oangle x y = 0 ∨ o.oangle x y = π
  · rwa [Real.Angle.sign_eq_zero_iff] at h
    rcases h with (h | h)
    · rwa [Real.Angle.sign_eq_zero_iff, Real.Angle.sign_eq_zero_iff]
    · rwa [Real.Angle.sign_eq_zero_iff]
    · rwa [Real.Angle.sign_eq_zero_iff]
    · rwa [Real.Angle.sign_eq_zero_iff]
    · rwa [Real.Angle.sign_eq_zero_iff]
    · rwa [Real.Angle.sign_eq_zero_iff]
    · rwa [Real.Angle.sign_eq_zero_iff]
    · rwa [Real.Angle.sign_eq_zero_iff]
    · rwa [Real.Angle.sign_eq_zero_iff]
    · rwa [Real.Angle.sign_eq_zero_iff]
    · rwa [Real.Angle.sign_eq_zero_iff]
    · rwa [Real.Angle.sign_eq_zero_iff]
    · rwa [Real.Angle.sign_eq_zero_iff]
    · rwa [Real.Angle.sign_eq_zero_iff]
    · rwa [Real.Angle.sign_eq_zero_iff]

For theorem:
theorem oangle_sign_smul_add_right (x y : V) (r : ℝ) :
    (o.oangle x (r • x + y)).sign = (o.oangle x y).sign 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hr.lt_or_lt with (h | h) <;> simp [h]

For theorem:
theorem two_zsmul_oangle_smul_left_of_ne_zero (x y : V) {r : ℝ} (hr : r ≠ 0) :
    (2 : ℤ) • o.oangle (r • x) y = (2 : ℤ) • o.oangle x y 
Attempt failure.

---0/3204---
Verifying proof:
:= by simp [oangle]

For theorem:
theorem oangle_zero_left (x : V) : o.oangle 0 x = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [oangle_smul_add_right_eq_zero_or_eq_pi_iff]

For theorem:
theorem oangle_smul_add_right_eq_zero_or_eq_pi_iff {x y : V} (r : ℝ) :
    o.oangle x (r • x + y) = 0 ∨ o.oangle x (r • x + y) = π ↔
    o.oangle x y = 0 ∨ o.oangle x y = π 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← o.oangle_eq_zero_iff_sameRay]
  constructor
  · intro h
    by_cases hx : x = 0
    · rw [oangle_eq_zero_iff_sameRay]
    · rw [oangle_eq_pi_iff_sameRay_neg, neg_eq_iff_eq_neg, ← oangle_neg_orientation_eq_neg,
      oangle_eq_pi_iff_sameRay_neg, neg_vsub_eq_vsub_rev, ← oangle_neg_orientation_eq_pi_iff_sameRay,
      oangle_eq_pi_iff_sameRay_neg, neg_vsub_eq_vsub_rev]

For theorem:
theorem oangle_eq_pi_iff_sameRay_neg {x y : V} :
    o.oangle x y = π ↔ x ≠ 0 ∧ y ≠ 0 ∧ SameRay ℝ x (-y) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← o.oangle_sign_smul_right (r₁ • x + r₂ • y) (r₃ • y), ← oangle_sign_smul_right (r₁ • x + r₂ • y),
    o.oangle_sign_smul_right (r₁ • x + r₂ • y), ← oangle_sign_smul_right (r₁ • x + r₂ • y),
    o.oangle_sign_smul_right (r₁ • x + r₂ • y), ← oangle_sign_smul_right (r₁ • x + r₂ • y),
    o.oangle_sign_smul_right (r₁ • x + r₂ • y), ← oangle_sign_smul_right (r₁ • x + r₂ • y),
    o.oangle_sign_smul_right (r₁ • x + r₂ • y), ← oangle_sign_smul_right (r₁ • x + r₂ • y),
    o.oangle_sign_smul_right (r₁ • x + r₂ • y), ← o.oangle_sign_smul_right (r₁ • x + r₂ • y),
    o.oangle_sign_smul_right (r₁ • x + r₂ • y), ← o.oangle_sign_smul_right (r₁ • x + r₂ • y),
    o.oangle_sign_smul_right (r₁ • x + r₂ • y), ← o.oangle_sign_smul_right (r₁ • x + r₂ • y),
    o.oangle_sign_smul_right (r₁ • x + r₂ • y), ← o.oangle_sign_smul_right (r₁ • x + r₂ • y),


For theorem:
theorem oangle_sign_smul_add_smul_smul_add_smul (x y : V) (r₁ r₂ r₃ r₄ : ℝ) :
    (o.oangle (r₁ • x + r₂ • y) (r₃ • x + r₄ • y)).sign =
      SignType.sign (r₁ * r₄ - r₂ * r₃) * (o.oangle x y).sign 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hs' : (o.oangle w x).sign = (o.oangle w x).sign := by
    rw [o.oangle_eq_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle_or_eq_neg_angle hs,
      o.oangle_eq_neg_angle_or_eq_neg_angle h, o.oangle_eq_neg_angle_or_eq_neg_angle hs,
      o.oangle_eq_neg_angle_or_eq_neg_angle h, o.oangle_eq_neg_angle_or_eq_neg_angle hs,
      o.oangle_eq_neg_angle_or_eq_neg_angle h, o.oangle_eq_neg_angle_or_eq_neg_angle hs,
      o.oangle_eq_neg_angle_or_eq_neg_angle h, o.oangle_eq_neg_angle_or_eq_neg_angle hs,
      o.oangle_eq_neg_angle_or_eq_neg_angle h, o.oangle_eq_neg_angle_or_eq_neg_angle hs,
      o.oangle_eq_neg_angle_or_eq_neg_angle h, o.oangle_eq_neg_angle_or_eq_neg_angle hs,
      o.oangle_eq_neg_angle_or_eq_neg_angle h, o.oangle_eq_neg_angle_or_eq_neg_angle hs,
      o.oangle_eq_neg_angle_or_eq_neg_angle h, o.oangle_eq_neg_angle_or_eq_neg_angle hs,
      o.oangle_eq_neg_angle_or_eq_neg_angle h, o.oangle_eq_neg_angle_or_eq_neg_angle hs,
      o.oangle_eq_neg_angle_or_eq_neg_angle h, o.oangle_eq_ne

For theorem:
theorem oangle_eq_of_angle_eq_of_sign_eq {w x y z : V}
    (h : InnerProductGeometry.angle w x = InnerProductGeometry.angle y z)
    (hs : (o.oangle w x).sign = (o.oangle y z).sign) : o.oangle w x = o.oangle y z 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← o.oangle_eq_zero_iff_sameRay]

For theorem:
theorem oangle_eq_pi_iff_sameRay_neg {x y : V} :
    o.oangle x y = π ↔ x ≠ 0 ∧ y ≠ 0 ∧ SameRay ℝ x (-y) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  o.right_ne_zero_of_oangle_sign_ne_zero (h.symm ▸ by decide) (h.symm ▸ by decide)

For theorem:
theorem right_ne_zero_of_oangle_sign_eq_one {x y : V} (h : (o.oangle x y).sign = 1) : y ≠ 0 
Attempt failure.

Working on Mathlib/Geometry/Euclidean/Angle/Oriented/RightAngle.lean - 2024-08-20 16:17:00.398190.
---0/3204---
Verifying proof:
:= by
  rw [← neg_inj, oangle_sin_oangle_sub_right_mul_norm_of_oangle_eq_pi_div_two h]

For theorem:
theorem sin_oangle_sub_left_mul_norm_of_oangle_eq_pi_div_two {x y : V}
    (h : o.oangle x y = ↑(π / 2)) : Real.Angle.sin (o.oangle (x - y) x) * ‖x - y‖ = ‖y‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← neg_inj, oangle_sin_add_right_mul_norm_of_oangle_eq_pi_div_two h]

For theorem:
theorem sin_oangle_add_left_mul_norm_of_oangle_eq_pi_div_two {x y : V}
    (h : o.oangle x y = ↑(π / 2)) : Real.Angle.sin (o.oangle (x + y) y) * ‖x + y‖ = ‖x‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hs : (∡ p₃ p₁ p₂).sign = 1 := by rw [oangle_rotate_sign, h, Real.Angle.sign_coe_pi_div_two]

For theorem:
theorem cos_oangle_left_of_oangle_eq_pi_div_two {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = ↑(π / 2)) :
    Real.Angle.cos (∡ p₃ p₁ p₂) = dist p₁ p₂ / dist p₁ p₃ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← neg_inj, oangle_sin_angle_sub_right_of_oangle_eq_pi_div_two h]

For theorem:
theorem norm_div_sin_oangle_sub_left_of_oangle_eq_pi_div_two {x y : V}
    (h : o.oangle x y = ↑(π / 2)) : ‖y‖ / Real.Angle.sin (o.oangle (x - y) x) = ‖x - y‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hs : (∡ p₃ p₁ p₂).sign = 1 := by rw [oangle_rotate_sign, h, Real.Angle.sign_coe_pi_div_two]

For theorem:
theorem sin_oangle_left_of_oangle_eq_pi_div_two {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = ↑(π / 2)) :
    Real.Angle.sin (∡ p₃ p₁ p₂) = dist p₃ p₂ / dist p₁ p₃ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hs : (∡ p₂ p₃ p₁).sign = 1 := by rw [oangle_rotate_sign, h, Real.Angle.sign_coe_pi_div_two]

For theorem:
theorem tan_oangle_right_of_oangle_eq_pi_div_two {p₁ p₂ p₃ : P} (h : ∡ p₁ p₂ p₃ = ↑(π / 2)) :
    Real.Angle.tan (∡ p₂ p₃ p₁) = dist p₁ p₂ / dist p₃ p₂ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [o.oangle_add_right_smul_rotation_pi_div_two h, Real.Angle.smul_div_cancel_right₀ _ h]

For theorem:
theorem oangle_add_left_smul_rotation_pi_div_two {x : V} (h : x ≠ 0) (r : ℝ) :
    o.oangle (x + r • o.rotation (π / 2 : ℝ) x) (r • o.rotation (π / 2 : ℝ) x)
      = Real.arctan r⁻¹ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hs : (∡ p₂ p₃ p₁).sign = 1 := by rw [oangle_rotate_sign, h, Real.Angle.sign_coe_pi_div_two]

For theorem:
theorem tan_oangle_right_mul_dist_of_oangle_eq_pi_div_two {p₁ p₂ p₃ : P}
    (h : ∡ p₁ p₂ p₃ = ↑(π / 2)) : Real.Angle.tan (∡ p₂ p₃ p₁) * dist p₃ p₂ = dist p₁ p₂ 
Attempt failure.

Working on Mathlib/Geometry/Euclidean/Angle/Oriented/Rotation.lean - 2024-08-20 16:18:50.657625.
---0/3204---
Verifying proof:
:= by
  simp only [o.rotation_apply, map_add, map_mul, LinearMap.map_smul, LinearMap.map_smulₛₗ]

For theorem:
theorem kahler_rotation_left (x y : V) (θ : Real.Angle) :
    o.kahler (o.rotation θ x) y = conj (θ.expMapCircle : ℂ) * o.kahler x y := by
        simp only [o.rotation_apply, map_add, map_mul, LinearMap.map_smulₛₗ, RingHom.id_apply,
    LinearMap.add_apply, LinearMap.smul_apply, real_smul, kahler_rightAngleRotation_left,
    Real.Angle.coe_expMapCircle, Complex.conj_ofReal, conj_I]
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [neg_rotation, ← Real.Angle.coe_add, neg_div, ← sub_eq_add_neg, sub_half]

For theorem:
theorem neg_rotation_neg_pi_div_two (x : V) :
    -o.rotation (-π / 2 : ℝ) x = o.rotation (π / 2 : ℝ) x 
Attempt failure.

---0/3204---
Verifying proof:
:= by rw [← o.rotation_eq_self_iff_angle_eq_zero hx, eq_comm]

For theorem:
theorem eq_rotation_self_iff_angle_eq_zero {x : V} (hx : x ≠ 0) (θ : Real.Angle) :
    x = o.rotation θ x ↔ θ = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [oangle, o.kahler_rotation_left']

For theorem:
theorem oangle_rotation_left {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) :
    o.oangle (o.rotation θ x) y = o.oangle x y - θ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  ext x
  simp [rotation]

For theorem:
theorem rotation_pi_div_two : o.rotation (π / 2 : ℝ) = J 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [real_inner_comm, inner_rotation_pi_div_two_left_smul]

For theorem:
theorem inner_rotation_pi_div_two_right_smul (x : V) (r : ℝ) :
    ⟪r • x, o.rotation (π / 2 : ℝ) x⟫ = 0 
Attempt failure.

Working on Mathlib/Geometry/Euclidean/Angle/Sphere.lean - 2024-08-20 16:20:23.054856.
---0/3204---
Verifying proof:
:= by
  fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₃ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₃ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₃ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₃ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₃ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₃ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₃ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₃ <;> fin_case

For theorem:
theorem mem_circumsphere_of_two_zsmul_oangle_eq {t : Triangle ℝ P} {p : P} {i₁ i₂ i₃ : Fin 3}
    (h₁₂ : i₁ ≠ i₂) (h₁₃ : i₁ ≠ i₃) (h₂₃ : i₂ ≠ i₃)
    (h : (2 : ℤ) • ∡ (t.points i₁) p (t.points i₃) =
      (2 : ℤ) • ∡ (t.points i₁) (t.points i₂) (t.points i₃)) : p ∈ t.circumsphere 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₃ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₃ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₃ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₃ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_cases i₃ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₁ <;> fin_cases i₂ <;> fin_case

For theorem:
theorem dist_div_sin_oangle_eq_two_mul_circumradius (t : Triangle ℝ P) {i₁ i₂ i₃ : Fin 3}
    (h₁₂ : i₁ ≠ i₂) (h₁₃ : i₁ ≠ i₃) (h₂₃ : i₂ ≠ i₃) : dist (t.points i₁) (t.points i₃) /
      |Real.Angle.sin (∡ (t.points i₁) (t.points i₂) (t.points i₃))| = 2 * t.circumradius 
Attempt failure.

Working on Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean - 2024-08-20 16:20:44.671205.
---0/3204---
Verifying proof:
:= by
  unfold angle at *
  rcases angle_eq_pi_iff.1 h with ⟨_, ⟨r, ⟨hr, hr⟩⟩⟩
  rw [angle_eq_angle_of_angle_eq_pi_iff.1 h with ⟨_, ⟨r, ⟨hr, hr⟩⟩
  rw [angle_eq_angle_of_angle_eq_pi_iff] at h
  rw [angle_eq_angle_of_angle_eq_pi_iff.1 h with ⟨_, ⟨r, ⟨hr, hr⟩⟩
  rw [angle_eq_angle_of_angle_eq_pi_iff] at hr
  rw [angle_eq_angle_of_angle_eq_pi_iff] at hr
  rw [angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of_angle_eq_pi_of

For theorem:
theorem angle_eq_angle_of_angle_eq_pi (p1 : P) {p2 p3 p4 : P} (h : ∠ p2 p3 p4 = π) :
    ∠ p1 p2 p3 = ∠ p1 p2 p4 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [angle, angle_eq_pi_iff]
  rcases h with ⟨⟨r, ⟨hr0, hr1⟩, hr1⟩, hp₂⟩
  rcases h with ⟨⟨r, ⟨hr0, hr1⟩, hr1⟩, hp₃⟩
  rw [angle, angle_eq_pi_iff]
  rcases h with ⟨⟨r, ⟨hr0, hr1⟩, hr1⟩, hp₃⟩
  rw [angle_eq_pi_iff]
  rcases h with ⟨r, ⟨hr0, hr1⟩, hp₃⟩
  rw [angle_eq_pi_iff]
  rcases h with ⟨r, ⟨hr0, hr1⟩, hp₃⟩
  rw [angle_eq_pi_iff]
  rcases h with ⟨r, ⟨hr0, hr1⟩, hp₃⟩
  rw [angle_eq_pi_iff]
  rcases h with ⟨r, ⟨hr0, hr1⟩, hp₃⟩
  rw [angle_eq_pi_iff]
  rcases h with ⟨r, ⟨hr0, hr1⟩, hp₃⟩
  rw [angle_eq_pi_iff]
  rcases h with ⟨r, ⟨hr0, hr1⟩, hp₃⟩
  rw [angle_eq_pi_iff]
  rcases h with ⟨r, ⟨hr0, hr1⟩, hp₃⟩
  rw [angle_eq_pi_iff]
  rcases h with ⟨r, ⟨hr0, hr1⟩, hp₃⟩
  rw [angle_eq_pi_iff]
  rcases h with ⟨r, ⟨hr0, hr1⟩, hp₃⟩
  rw [angle_eq_pi_iff]
  rcases h with ⟨r, ⟨hr0, hr1⟩, hp₃⟩
  rw [angle_eq_pi_iff]
  rcases h with ⟨r, ⟨hr0, hr1⟩, hp₃⟩
  rw [angle_e

For theorem:
theorem _root_.Sbtw.angle₁₂₃_eq_pi {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∠ p₁ p₂ p₃ = π 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [angle, angle_eq_zero_iff]
  rw [angle, angle_eq_zero_iff]

For theorem:
theorem _root_.Wbtw.angle₂₁₃_eq_zero_of_ne {p₁ p₂ p₃ : P} (h : Wbtw ℝ p₁ p₂ p₃) (hp₂p₁ : p₂ ≠ p₁) :
    ∠ p₂ p₁ p₃ = 0 
Attempt failure.

Working on Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean - 2024-08-20 16:21:09.592542.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, norm_sub_eq_abs_sub_norm_iff_angle_eq_zero hx hy⟩
  rw [← norm_sub_eq_abs_sub_norm_iff_angle_eq_zero hx hy]
  exact norm_sub_eq_abs_sub_norm_iff_angle_eq_zero hx hy

For theorem:
theorem norm_sub_eq_abs_sub_norm_iff_angle_eq_zero {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :
    ‖x - y‖ = |‖x‖ - ‖y‖| ↔ angle x y = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [cos_angle, div_mul_cancel_of_imp]
  simp (config := { contextual := true }) [or_imp]

For theorem:
theorem cos_angle_mul_norm_mul_norm (x y : V) : Real.cos (angle x y) * (‖x‖ * ‖y‖) = ⟪x, y⟫ 
Attempt success.

---0/3204---
Verifying proof:
:= by
  unfold angle
  rw [Real.sin_arccos, ← Real.sqrt_mul (norm_nonneg _) (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _) (norm_nonneg _),
    Real.sqrt_mul (norm_nonneg _) (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _), ←
    Real.sqrt_mul (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _),
      Real.sqrt_mul (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _),
      Real.sqrt_mul (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _),
      Real.sqrt_mul (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _),
      Real.sqrt_mul (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _),
      Real.sqrt_mul (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _),
      Real.sqrt_mul (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _), ← Real.sqrt_mul (norm_nonneg _),
      Real.sqrt_mul (norm_nonneg _), ←

For theorem:
theorem sin_angle_mul_norm_mul_norm (x y : V) :
    Real.sin (angle x y) * (‖x‖ * ‖y‖) = √(⟪x, x⟫ * ⟪y, y⟫ - ⟪x, y⟫ * ⟪x, y⟫) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  unfold angle
  rw [inner_zero_left, zero_div, Real.arccos_zero]

For theorem:
theorem angle_zero_left (x : V) : angle 0 x = π / 2 
Attempt success.

Working on Mathlib/Geometry/Euclidean/Angle/Unoriented/RightAngle.lean - 2024-08-20 16:21:31.894280.
---0/3204---
Verifying proof:
:= by
  rw [ne_comm, ← @vsub_ne_zero V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_ne_zero V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_ne_zero V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_ne_zero V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V

For theorem:
theorem sin_angle_of_angle_eq_pi_div_two {p₁ p₂ p₃ : P} (h : ∠ p₁ p₂ p₃ = π / 2)
    (h0 : p₁ ≠ p₂ ∨ p₃ ≠ p₂) : Real.sin (∠ p₂ p₃ p₁) = dist p₁ p₂ / dist p₁ p₃ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← neg_eq_zero, ← inner_neg_right] at h0

For theorem:
theorem norm_div_sin_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) (h0 : x = 0 ∨ y ≠ 0) :
    ‖y‖ / Real.sin (angle x (x - y)) = ‖x - y‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases h0 : x = 0 ∧ y = 0; · simp [h0]
  · simp [h0]

For theorem:
theorem sin_angle_add_mul_norm_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.sin (angle x (x + y)) * ‖x + y‖ = ‖y‖ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two x y]

For theorem:
theorem norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two (x y : V) :
    ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ angle x y = π / 2 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← neg_eq_zero, ← inner_neg_right] at h
  rw [← neg_ne_zero, ← inner_neg_right] at h
  rw [← neg_ne_zero, ← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [← inner_neg_right] at h
  rw [

For theorem:
theorem angle_sub_pos_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) (h0 : x = 0 ∨ y ≠ 0) :
    0 < angle x (x - y) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← neg_eq_zero, ← inner_neg_right] at h
  rw [← neg_eq_zero, ← inner_neg_right] at h
  rw [angle_sub_eq_arccos_of_inner_eq_zero h, Real.Angle.arccos_of_inner_eq_zero h]

For theorem:
theorem angle_sub_eq_arccos_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    angle x (x - y) = Real.arccos (‖x‖ / ‖x - y‖) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [angle_eq_pi_div_two_iff_angle_eq_pi

For theorem:
theorem angle_lt_pi_div_two_of_angle_eq_pi_div_two {p₁ p₂ p₃ : P} (h : ∠ p₁ p₂ p₃ = π / 2)
    (h0 : p₃ ≠ p₂) : ∠ p₂ p₃ p₁ < π / 2 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [ne_comm, ← @vsub_ne_zero V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_ne_zero V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0
  rw [ne_comm, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, or_comm] at h0

For theorem:
theorem dist_div_sin_angle_of_angle_eq_pi_div_two {p₁ p₂ p₃ : P} (h : ∠ p₁ p₂ p₃ = π / 2)
    (h0 : p₁ ≠ p₂ ∨ p₃ = p₂) : dist p₁ p₂ / Real.sin (∠ p₂ p₃ p₁) = dist p₁ p₃ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [angle, ← inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_eq_zero, ←
    inner_neg_left, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, ←
    inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, ← neg_vsub_eq_vsub_rev, ←
    inner_eq_zero_iff_angle_eq_pi_div_two, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, ←
    inner_eq_zero_iff_angle_eq_pi_div_two, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, ←
    inner_eq_zero_iff_angle_eq_pi_div_two, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, ←
    inner_eq_zero_iff_angle_eq_pi_div_two, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, ←
    inner_eq_zero_iff_angle_eq_pi_div_two, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, ←
    inner_eq_zero_iff_angle_eq_pi_div_two, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, ←
    inner_eq_zero_iff_angle_eq_pi_div_two, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, ←
    inner_eq_zero_iff_angle_eq_pi_div_two, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, ←
    inner_eq_ze

For theorem:
theorem angle_eq_arcsin_of_angle_eq_pi_div_two {p₁ p₂ p₃ : P} (h : ∠ p₁ p₂ p₃ = π / 2)
    (h0 : p₁ ≠ p₂ ∨ p₃ ≠ p₂) : ∠ p₂ p₃ p₁ = Real.arcsin (dist p₁ p₂ / dist p₁ p₃) 
Attempt failure.

Working on Mathlib/Geometry/Euclidean/Basic.lean - 2024-08-20 16:22:46.844064.
---0/3204---
Verifying proof:
:= by
  rcases s.eq_empty_or_nonempty with (rfl | hs)
  · simp only [Set.mem_inter_iff, Set.mem_inter_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_inter_iff, Set.mem_setOf_eq, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_inter_iff, Set.mem_inter_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_inter_iff, Set.mem_singleton_iff, Set.mem_inter_iff, Set.mem_singleton_iff,
      Set.mem_inter_iff, Set.mem_inter_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_inter_iff, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_inter_iff, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_inter_iff, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_inter_iff, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_inter_iff, Set.mem_setOf_eq, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_inter_iff, Set.mem_singleton_if

For theorem:
theorem inter_eq_singleton_orthogonalProjection {s : AffineSubspace ℝ P} [Nonempty s]
    [HasOrthogonalProjection s.direction] (p : P) :
    (s : Set P) ∩ mk' p s.directionᗮ = {↑(orthogonalProjection s p)} 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [orthogonalProjection_vsub_orthogonalProjection_vsub_orthogonalProjection_vsub_orthogonalProjection]
  exact orthogonalProjection_vsub_orthogonalProjection

For theorem:
theorem orthogonalProjection_vsub_orthogonalProjection (s : AffineSubspace ℝ P) [Nonempty s]
    [HasOrthogonalProjection s.direction] (p : P) :
    _root_.orthogonalProjection s.direction (p -ᵥ orthogonalProjection s p) = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  constructor
  · intro h
    rw [orthogonalProjection_eq_self_iff]
    refine ⟨fun h =>?_, fun h =>?_⟩
    simp only [orthogonalProjection_eq_self_iff, SetLike.mem_coe, Submodule.mem_span_iff_total,
      SetLike.mem_coe, Set.mem_setOf_eq] at h
    exact ⟨orthogonalProjection_eq_self_iff_mem_orthogonalProjection_eq_self_iff_mem_orthogonalProjection_eq_self h,
      Set.mem_image_of_mem _ (Set.mem_image_of_mem _ (Set.mem_image_of_mem _ h))⟩

For theorem:
theorem orthogonalProjection_eq_self_iff {s : AffineSubspace ℝ P} [Nonempty s]
    [HasOrthogonalProjection s.direction] {p : P} : ↑(orthogonalProjection s p) = p ↔ p ∈ s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne p 0 with (rfl | hp')
  · simp only [reflection_apply, Submodule.mem_orthogonalProjection_iff_inner_left,
      Submodule.mem_orthogonalProjection_iff_inner_left, Submodule.mem_orthogonalProjection,
      Submodule.mem_orthogonalProjection_iff_inner_left, Submodule.mem_orthogonalProjection,
      Submodule.mem_orthogonalProjection_iff_inner_left, Submodule.mem_orthogonalProjection,
      Submodule.mem_orthogonalProjection_iff_inner_left, Submodule.mem_orthogonalProjection,
      Submodule.mem_orthogonalProjection_iff_inner_left, Submodule.mem_orthogonalProjection,
      Submodule.mem_orthogonalProjection_iff_inner_left, Submodule.mem_orthogonalProjection,
      Submodule.mem_orthogonalProjection_iff_inner_left, Submodule.mem_orthogonalProjection,
      Submodule.mem_orthogonalProjection_iff_inner_left, Submodule.mem_orthogonalProjection,
      Submodule.mem_orthogonalProjection_iff_inner_left, Submodule.mem_orthogonalProjection,
      Submodule.mem_orthogonalProjection_iff_inner_left,

For theorem:
theorem reflection_mem_of_le_of_mem {s₁ s₂ : AffineSubspace ℝ P} [Nonempty s₁]
    [HasOrthogonalProjection s₁.direction] (hle : s₁ ≤ s₂) {p : P} (hp : p ∈ s₂) :
    reflection s₁ p ∈ s₂ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← orthogonalProjection_eq_self_iff, reflection_eq_self_iff]

For theorem:
theorem reflection_eq_self_iff {s : AffineSubspace ℝ P} [Nonempty s]
    [HasOrthogonalProjection s.direction] (p : P) : reflection s p = p ↔ p ∈ s 
Attempt failure.

Working on Mathlib/Geometry/Euclidean/Circumcenter.lean - 2024-08-20 16:23:59.870357.
---0/3204---
Verifying proof:
:= by
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, h

For theorem:
theorem existsUnique_dist_eq_of_insert {s : AffineSubspace ℝ P}
    [HasOrthogonalProjection s.direction] {ps : Set P} (hnps : ps.Nonempty) {p : P} (hps : ps ⊆ s)
    (hp : p ∉ s) (hu : ∃! cs : Sphere P, cs.center ∈ s ∧ ps ⊆ (cs : Set P)) :
    ∃! cs₂ : Sphere P,
      cs₂.center ∈ affineSpan ℝ (insert p (s : Set P)) ∧ insert p ps ⊆ (cs₂ : Set P) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine reflection_circumcenter_eq_affineCombination_of_pointsWithCircumcenter_eq_affineCombination_of_pointsWithCircumcenter?_?_
  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff, Set.mem_image, Set.mem_singleton_iff,
      Set.mem_image, Set.mem_singleton_iff, Set.mem_image, Set.mem_singleton_iff,
      Set.mem_singleton_iff, Set.mem_image, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_image, Set.mem_singleton_iff, Set.mem_image, Set.mem_singleton_iff,
      Set.mem_singleton_iff, Set.mem_image, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_image, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_image, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_image, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_singleton_iff, Set.mem_image, Set.mem_singleton_iff, Set.mem_singleton_iff,
      Set.mem_image, Set.mem_singleton_iff, Set.mem_singleton_iff, Set.mem_singleto

For theorem:
theorem reflection_circumcenter_eq_affineCombination_of_pointsWithCircumcenter {n : ℕ}
    (s : Simplex ℝ P n) {i₁ i₂ : Fin (n + 1)} (h : i₁ ≠ i₂) :
    reflection (affineSpan ℝ (s.points '' {i₁, i₂})) s.circumcenter =
      (univ : Finset (PointsWithCircumcenterIndex n)).affineCombination ℝ s.pointsWithCircumcenter
        (reflectionCircumcenterWeightsWithCircumcenter i₁ i₂) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨x, hx⟩ := exists_circumsphere_eq_of_cospherical_subset_of_finrank_eq_succ hc
  refine ⟨x,?_,?_,?_⟩
  · simp only [Set.mem_setOf_eq, Set.mem_iUnion, Set.mem_setOf_eq, Set.mem_setOf_eq] at hx
    simp only [Set.mem_iUnion, Set.mem_setOf_eq, Set.mem_setOf_eq] at hx
    simp only [Set.mem_iUnion, Set.mem_setOf_eq, Set.mem_setOf_eq] at hx
    simp only [Set.mem_iUnion, Set.mem_setOf_eq, Set.mem_setOf_eq] at hx
    simp only [Set.mem_iUnion, Set.mem_setOf_eq] at hx
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at hx
    simp only [Set.mem_iUnion, Set.mem_setOf_eq] at hx
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at hx
    simp only [Set.mem_iUnion, Set.mem_setOf_eq, Set.mem_setOf_eq] at hx
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at hx
    simp only [Set.mem_iUnion, Set.mem_setOf_eq, Set.mem_setOf_eq] at hx
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at hx
    simp only [Set.mem_iUnion, Set.mem_setOf_eq, Set.mem_setOf_eq] at hx
    simp only [Set.mem_setOf_

For theorem:
theorem exists_circumsphere_eq_of_cospherical_subset {s : AffineSubspace ℝ P} {ps : Set P}
    (h : ps ⊆ s) [Nonempty s] {n : ℕ} [FiniteDimensional ℝ s.direction]
    (hd : finrank ℝ s.direction = n) (hc : Cospherical ps) :
    ∃ c : Sphere P, ∀ sx : Simplex ℝ P n, Set.range sx.points ⊆ ps → sx.circumsphere = c 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine circumsphere_eq_of_cospherical_subset_of_cospherical_subset hsx₁?_?_?_
  · simp only [circumsphere_eq_of_cospherical_subset hsx₁ hsx₁,
      circumsphere_eq_of_cospherical_subset_of_finrank_eq_succ hsx₁,
      circumsphere_eq_of_cospherical_subset_of_cospherical_subset hsx₁ hd hc]
    exact circumsphere_eq_of_cospherical_subset_of_finrank_eq_succ hsx₁ hsx₁
  · simp only [circumsphere_eq_of_cospherical_subset_of_finrank_eq_succ hsx₁,
      circumsphere_eq_of_cospherical_subset_of_finrank_eq_succ hsx₁ hsx₁,
      circumsphere_eq_of_cospherical_subset_of_cospherical_subset hsx₁ hd hsx₁
  · rw [← hd]
    exact circumsphere_eq_of_cospherical_subset_of_finrank_eq_succ hsx₁ hc
  · simp only [circumsphere_eq_of_cospherical_subset_of_finrank_eq_succ hsx₁,
      circumsphere_eq_of_cospherical_subset_of_cospherical_subset hsx₁ hsx₁
    rw [← hd]
    exact circumsphere_eq_of_cospherical_subset_of_cospherical_subset hsx₁ hc
  · simp only [circumsphere_eq_of_cos

For theorem:
theorem circumsphere_eq_of_cospherical {ps : Set P} {n : ℕ} [FiniteDimensional ℝ V]
    (hd : finrank ℝ V = n) (hc : Cospherical ps) {sx₁ sx₂ : Simplex ℝ P n}
    (hsx₁ : Set.range sx₁.points ⊆ ps) (hsx₂ : Set.range sx₂.points ⊆ ps) :
    sx₁.circumsphere = sx₂.circumsphere 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, h

For theorem:
theorem existsUnique_dist_eq_of_insert {s : AffineSubspace ℝ P}
    [HasOrthogonalProjection s.direction] {ps : Set P} (hnps : ps.Nonempty) {p : P} (hps : ps ⊆ s)
    (hp : p ∉ s) (hu : ∃! cs : Sphere P, cs.center ∈ s ∧ ps ⊆ (cs : Set P)) :
    ∃! cs₂ : Sphere P,
      cs₂.center ∈ affineSpan ℝ (insert p (s : Set P)) ∧ insert p ps ⊆ (cs₂ : Set P) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := hne
  obtain ⟨cs, hcs⟩ := h

For theorem:
theorem _root_.AffineIndependent.existsUnique_dist_eq {ι : Type*} [hne : Nonempty ι] [Finite ι]
    {p : ι → P} (ha : AffineIndependent ℝ p) :
    ∃! cs : Sphere P, cs.center ∈ affineSpan ℝ (Set.range p) ∧ Set.range p ⊆ (cs : Set P) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, hcs⟩
  rcases hu with ⟨cs, h

For theorem:
theorem existsUnique_dist_eq_of_insert {s : AffineSubspace ℝ P}
    [HasOrthogonalProjection s.direction] {ps : Set P} (hnps : ps.Nonempty) {p : P} (hps : ps ⊆ s)
    (hp : p ∉ s) (hu : ∃! cs : Sphere P, cs.center ∈ s ∧ ps ⊆ (cs : Set P)) :
    ∃! cs₂ : Sphere P,
      cs₂.center ∈ affineSpan ℝ (insert p (s : Set P)) ∧ insert p ps ⊆ (cs₂ : Set P) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine s.circumsphere_unique_dist_eq.2?_
  refine s.circumsphere_unique_dist_eq.2?_
  simp only [circumsphere_eq_circumsphere, circumsphere_eq_circumsphere, circumsphere_eq_circumsphere]

For theorem:
theorem circumsphere_reindex {m n : ℕ} (s : Simplex ℝ P m) (e : Fin (m + 1) ≃ Fin (n + 1)) :
    (s.reindex e).circumsphere = s.circumsphere 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hr :
    Set.Pairwise Set.univ fun i j : Fin 2 =>
      dist (s.points i) (s.points i) := by
      rw [Finset.pairwise_univ, Finset.pairwise_univ, Finset.pairwise_univ, Finset.centroid_eq_iff,
      Finset.pairwise_insert, Finset.pairwise_insert, Finset.mem_univ, Finset.mem_insert,
      Finset.mem_insert, Finset.mem_insert, Finset.mem_insert, Finset.mem_univ,
      Finset.mem_insert, Finset.mem_insert, Finset.mem_insert, Finset.mem_univ,
      Finset.mem_insert, Finset.mem_insert, Finset.mem_insert, Finset.mem_univ,
      Finset.mem_insert, Finset.mem_insert, Finset.mem_insert, Finset.mem_univ,
      Finset.mem_insert, Finset.mem_insert, Finset.mem_insert, Finset.mem_univ,
      Finset.mem_insert, Finset.mem_insert, Finset.mem_insert, Finset.mem_univ,
      Finset.mem_insert, Finset.mem_insert, Finset.mem_insert, Finset.mem_univ,
      Finset.mem_insert, Finset.mem_insert, Finset.mem_insert, Finset.mem_univ,
      Finset.mem_insert, Finset.mem_insert, Finset.mem_insert, Finset.mem_insert,
     

For theorem:
theorem circumcenter_eq_centroid (s : Simplex ℝ P 1) :
    s.circumcenter = Finset.univ.centroid ℝ s.points 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨x, hx⟩ := exists_circumradius_eq_of_cospherical_subset_of_finrank_eq_succ h hc
  refine ⟨x,?_,?_⟩
  · rw [← hd]
    exact finrank_subset_cospherical h hd

For theorem:
theorem exists_circumradius_eq_of_cospherical_subset {s : AffineSubspace ℝ P} {ps : Set P}
    (h : ps ⊆ s) [Nonempty s] {n : ℕ} [FiniteDimensional ℝ s.direction]
    (hd : finrank ℝ s.direction = n) (hc : Cospherical ps) :
    ∃ r : ℝ, ∀ sx : Simplex ℝ P n, Set.range sx.points ⊆ ps → sx.circumradius = r 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨c, hc⟩ := exists_circumsphere_eq_of_cospherical_sphere hd hc
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_⟩
  refine ⟨c, fun sx =>?_, fun sx =>?_

For theorem:
theorem exists_circumsphere_eq_of_cospherical {ps : Set P} {n : ℕ} [FiniteDimensional ℝ V]
    (hd : finrank ℝ V = n) (hc : Cospherical ps) :
    ∃ c : Sphere P, ∀ sx : Simplex ℝ P n, Set.range sx.points ⊆ ps → sx.circumsphere = c 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨r, hr⟩ := hr
  obtain ⟨r, hr⟩ := hr
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcases hr with ⟨r, hr⟩
  rcas

For theorem:
theorem orthogonalProjection_eq_circumcenter_of_exists_dist_eq {n : ℕ} (s : Simplex ℝ P n) {p : P}
    (hr : ∃ r, ∀ i, dist (s.points i) p = r) :
    ↑(s.orthogonalProjectionSpan p) = s.circumcenter 
Attempt failure.

Working on Mathlib/Geometry/Euclidean/Inversion/Basic.lean - 2024-08-20 16:27:56.914549.
---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne b a with (rfl | hb)
  rcases eq_or_ne b a with (rfl | hb)
  · rw [dist_self, MulZeroClass.mul_zero]
    exact mul_le_mul_of_nonneg_right (dist_nonneg _) (dist_nonneg _)

For theorem:
theorem mul_dist_le_mul_dist_add_mul_dist (a b c d : P) :
    dist a c * dist b d ≤ dist a b * dist c d + dist b c * dist a d := by
    rcases eq_or_ne b a with (rfl | hb)
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases eq_or_ne x c with (rfl | hx)
  · simp
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 := dist_ne_zero.2 hx
  have : dist x c ≠ 0 

For theorem:
theorem dist_inversion_center (c x : P) (R : ℝ) : dist (inversion c R x) c = R ^ 2 / dist x c 
Attempt failure.

Working on Mathlib/Geometry/Euclidean/MongePoint.lean - 2024-08-20 16:28:07.760883.
---0/3204---
Verifying proof:
:= by
  fin_cases i₁ <;> fin_cases i₂ <;> simp [h]

For theorem:
theorem dist_orthocenter_reflection_circumcenter (t : Triangle ℝ P) {i₁ i₂ : Fin 3} (h : i₁ ≠ i₂) :
    dist t.orthocenter (reflection (affineSpan ℝ (t.points '' {i₁, i₂})) t.circumcenter) =
      t.circumradius 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  fin_cases j₁ <;> fin_cases j₂ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₁ <;> fin_cases j₁ <;> fin_cases j₁ <;> fin_cases j₂ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₁ <;> fin_cases j₁ <;> fin_cases j₁ <;> fin_cases j₁ <;> fin_cases j₂ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_case

For theorem:
theorem altitude_replace_orthocenter_eq_affineSpan {t₁ t₂ : Triangle ℝ P}
    {i₁ i₂ i₃ j₁ j₂ j₃ : Fin 3} (hi₁₂ : i₁ ≠ i₂) (hi₁₃ : i₁ ≠ i₃) (hi₂₃ : i₂ ≠ i₃) (hj₁₂ : j₁ ≠ j₂)
    (hj₁₃ : j₁ ≠ j₃) (hj₂₃ : j₂ ≠ j₃) (h₁ : t₂.points j₁ = t₁.orthocenter)
    (h₂ : t₂.points j₂ = t₁.points i₂) (h₃ : t₂.points j₃ = t₁.points i₃) :
    t₂.altitude j₂ = line[ℝ, t₁.points i₁, t₁.points i₂] 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [mongePlane_def, mem_inf_iff, ← vsub_right_mem_direction_iff_mem]

For theorem:
theorem mongePoint_mem_mongePlane {n : ℕ} (s : Simplex ℝ P (n + 2)) {i₁ i₂ : Fin (n + 3)} :
    s.mongePoint ∈ s.mongePlane i₁ i₂ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [mongePoint_eq_affineCombination_of_pointsWithCircumcenter_eq_affineCombination, ←
    s.mongePoint_eq_affineCombination_of_pointsWithCircumcenter_eq_affineCombination_of_pointsWithCircumcenter,
    s.mongePoint_eq_affineCombination_of_pointsWithCircumcenter]

For theorem:
theorem mongePoint_eq_affineCombination_of_pointsWithCircumcenter {n : ℕ}
    (s : Simplex ℝ P (n + 2)) :
    s.mongePoint =
      (univ : Finset (PointsWithCircumcenterIndex (n + 2))).affineCombination ℝ
        s.pointsWithCircumcenter (mongePointWeightsWithCircumcenter n) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [direction_mongePlane, direction_mongePlane, direction_mongePlane, direction_mongePlane,
    direction_mongePlane, direction_mongePlane, direction_mongePlane, direction_mongePlane,
    direction_mongePlane, direction_mongePlane, direction_mongePlane, direction_mongePlane,
    direction_mongePlane, direction_mongePlane]

For theorem:
theorem direction_mongePlane {n : ℕ} (s : Simplex ℝ P (n + 2)) {i₁ i₂ : Fin (n + 3)} :
    (s.mongePlane i₁ i₂).direction =
      (ℝ ∙ s.points i₁ -ᵥ s.points i₂)ᗮ ⊓ vectorSpan ℝ (Set.range s.points) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun h =>?_⟩
  · rintro rfl
    simp only [altitude_eq_affineCombination, Set.mem_setOf_eq, Set.mem_singleton_iff,
      Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_singleton_iff,
      Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_singleton_iff,
      Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_singleton_iff] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_singleton_iff] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_singleton_iff,
      Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_singleton_iff,
      Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_singleton_iff,
      Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_e

For theorem:
theorem affineSpan_pair_eq_altitude_iff {n : ℕ} (s : Simplex ℝ P (n + 1)) (i : Fin (n + 2))
    (p : P) :
    line[ℝ, p, s.points i] = s.altitude i ↔
      p ≠ s.points i ∧
        p ∈ affineSpan ℝ (Set.range s.points) ∧
          p -ᵥ s.points i ∈ (affineSpan ℝ (s.points '' ↑(Finset.univ.erase i))).directionᗮ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine eq_mongePoint_of_forall_mem_mongePlane?_
  refine eq_mongePoint_of_forall_mem_mongePlane?_?_?_
  · simp only [mem_mongePlane, Set.mem_setOf_eq, Set.mem_singleton_iff] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, 

For theorem:
theorem eq_mongePoint_of_forall_mem_mongePlane {n : ℕ} {s : Simplex ℝ P (n + 2)} {i₁ : Fin (n + 3)}
    {p : P} (h : ∀ i₂, i₁ ≠ i₂ → p ∈ s.mongePlane i₁ i₂) : p = s.mongePoint 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [direction_altitude]
  have h := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h' := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h' := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h' := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h' := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h' := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h' := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h' := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h' := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h' := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h' := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h' := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h' := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h' := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h' := Submodule.finrank_mul_finrank ℝ (s.altitude i)
 

For theorem:
theorem finrank_direction_altitude {n : ℕ} (s : Simplex ℝ P (n + 1)) (i : Fin (n + 2)) :
    finrank ℝ (s.altitude i).direction = 1 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← affineSpan_of_orthocentricSystem hps hpi, ← affineSpan_of_orthocentricSystem hpi]

For theorem:
theorem affineSpan_of_orthocentricSystem {s : Set P} (ho : OrthocentricSystem s) {p : Fin 3 → P}
    (hps : Set.range p ⊆ s) (hpi : Function.Injective p) :
    affineSpan ℝ (Set.range p) = affineSpan ℝ s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  fin_cases j₁ <;> fin_cases j₂ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₁ <;> fin_cases j₁ <;> fin_cases j₂ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₁ <;> fin_cases j₁ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₁ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₁ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_cases j₃ <;> fin_case

For theorem:
theorem orthocenter_replace_orthocenter_eq_point {t₁ t₂ : Triangle ℝ P} {i₁ i₂ i₃ j₁ j₂ j₃ : Fin 3}
    (hi₁₂ : i₁ ≠ i₂) (hi₁₃ : i₁ ≠ i₃) (hi₂₃ : i₂ ≠ i₃) (hj₁₂ : j₁ ≠ j₂) (hj₁₃ : j₁ ≠ j₃)
    (hj₂₃ : j₂ ≠ j₃) (h₁ : t₂.points j₁ = t₁.orthocenter) (h₂ : t₂.points j₂ = t₁.points i₂)
    (h₃ : t₂.points j₃ = t₁.points i₃) : t₂.orthocenter = t₁.points i₁ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [direction_altitude]
  have h := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h' := Submodule.finrank_mul_finrank ℝ (Submodule.

For theorem:
theorem finrank_direction_altitude {n : ℕ} (s : Simplex ℝ P (n + 1)) (i : Fin (n + 2)) :
    finrank ℝ (s.altitude i).direction = 1 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [direction_altitude]
  have h := Submodule.finrank_mul_finrank ℝ (s.altitude i)
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h := Submodule.finrank_mul_finrank ℝ (Submodule.finrank ℝ (Submodule.finrank ℝ (s.altitude i)))
  have h' := Submodule.finrank_mul_finrank ℝ (Submodule.

For theorem:
theorem finrank_direction_altitude {n : ℕ} (s : Simplex ℝ P (n + 1)) (i : Fin (n + 2)) :
    finrank ℝ (s.altitude i).direction = 1 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [orthocenter_eq_smul_vsub_vadd_circumcenter, vadd_vsub_assoc, vadd_vsub_assoc,
    vsub_vadd_eq_vsub_sub, vadd_vsub_assoc]

For theorem:
theorem orthocenter_eq_smul_vsub_vadd_circumcenter (t : Triangle ℝ P) :
    t.orthocenter =
      (3 : ℝ) • ((univ : Finset (Fin 3)).centroid ℝ t.points -ᵥ t.circumcenter : V) +ᵥ
        t.circumcenter 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [sum_mongePointVSubFaceCentroidWeightsWithCircumcenter]
  refine Finset.sum_eq_zero fun i _ =>?_
  simp only [mongePointVSubFaceCentroidWeightsWithCircumcenter, Finset.sum_empty,
    mongePointVSubFaceCentroidWeightsWithCircumcenter,
    Finset.sum_empty, Finset.sum_empty]

For theorem:
theorem sum_mongePointVSubFaceCentroidWeightsWithCircumcenter {n : ℕ} {i₁ i₂ : Fin (n + 3)}
    (h : i₁ ≠ i₂) : ∑ i, mongePointVSubFaceCentroidWeightsWithCircumcenter i₁ i₂ i = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine eq_mongePoint_of_forall_mem_mongePlane?_
  refine eq_mongePoint_of_forall_mem_mongePlane?_?_?_
  · simp only [mem_mongePlane, Set.mem_setOf_eq, Set.mem_singleton_iff] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, Set.mem_setOf_eq] at h
    simp only [Set.mem_setOf_eq, Set.mem_setOf_eq, 

For theorem:
theorem eq_mongePoint_of_forall_mem_mongePlane {n : ℕ} {s : Simplex ℝ P (n + 2)} {i₁ : Fin (n + 3)}
    {p : P} (h : ∀ i₂, i₁ ≠ i₂ → p ∈ s.mongePlane i₁ i₂) : p = s.mongePoint 
Attempt failure.

Working on Mathlib/Geometry/Euclidean/PerpBisector.lean - 2024-08-20 16:32:12.033729.
---0/3204---
Verifying proof:
:= by
  rw [← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V,
    ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V,
    ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V,
    ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V,
    ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V,
    ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V,
    ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V,
    ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V,
    ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V,
    ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V,
    ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_zero_iff_eq V,
    ← @vsub_eq_zero_iff_eq V, ← @vsub_eq_ze

For theorem:
theorem inner_vsub_vsub_of_dist_eq_of_dist_eq {c₁ c₂ p₁ p₂ : P} (hc₁ : dist p₁ c₁ = dist p₂ c₁)
    (hc₂ : dist p₁ c₂ = dist p₂ c₂) : ⟪c₂ -ᵥ c₁, p₂ -ᵥ p₁⟫ = 0 
Attempt failure.

Working on Mathlib/Geometry/Euclidean/Sphere/SecondInter.lean - 2024-08-20 16:32:18.015500.
---0/3204---
Verifying proof:
:= by
  rw [Sphere.secondInter]
  by_cases hv : v = 0; · simp [hv]
  · simp [hv]

For theorem:
theorem Sphere.secondInter_dist (s : Sphere P) (p : P) (v : V) :
    dist (s.secondInter p v) s.center = dist p s.center 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases hv : v = 0; · simp [hv]
  have hv' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv'' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv'' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv'' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv'' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv'' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv'' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv'' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv'' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv'' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv'' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv'' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv'' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv'' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv'
  have hv'' : ⟪v, v⟫ ≠ 0 := inner_

For theorem:
theorem Sphere.secondInter_secondInter (s : Sphere P) (p : P) (v : V) :
    s.secondInter (s.secondInter p v) v = p 
Attempt failure.

Working on Mathlib/Geometry/Euclidean/Triangle.lean - 2024-08-20 16:32:31.150684.
---0/3204---
Verifying proof:
:= by
  rw [dist_eq_norm_vsub V p1 p2, dist_eq_norm_vsub V p1 p3] at h
  unfold angle
  simp only [dist_eq_norm_vsub V p1 p2, dist_eq_norm_vsub V p1 p3]

For theorem:
theorem angle_eq_angle_of_dist_eq {p1 p2 p3 : P} (h : dist p1 p2 = dist p1 p3) :
    ∠ p1 p2 p3 = ∠ p1 p3 p2 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases hxy : x = y
  · simp [hxy]
  · rw [sin_angle_sub_add_angle_sub_add_angle_sub_rev_eq_sin_angle_sub_rev_eq_sin_angle hx hy,
      sin_angle_sub_add_angle_sub_rev_eq_sin_angle hx hy]

For theorem:
theorem sin_angle_sub_add_angle_sub_rev_eq_sin_angle {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :
    Real.sin (angle x (x - y) + angle y (y - x)) = Real.sin (angle x y) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have hcos := cos_angle_add_angle_sub_add_angle_sub_add_angle_sub_add_angle_sub_add_angle
  have hcos := cos_angle_add_angle_sub_add_angle_sub_add_angle_sub_add_angle_sub_add_angle
  have hcos := cos_angle_add_angle_sub_add_angle_sub_add_angle_sub_add_angle_sub_add_angle
  have hcos := cos_angle_add_angle_sub_add_angle_sub_add_angle_sub_add_angle_sub_add_angle
  have hcos := cos_angle_add_angle_sub_add_angle_sub_add_angle_sub_add_angle_sub_add_angle
  have hcos := cos_angle_add_angle_sub_add_angle_sub_add_angle_sub_add_angle_sub_add_angle
  have hcos := cos_angle_add_angle_sub_add_angle_sub_add_angle_sub_add_angle_sub_add_angle
  have hcos := cos_angle_add_angle_sub_add_angle_sub_add_angle_sub_add_angle_sub_add_angle
  have hcos := cos_angle_add_angle_sub_add_angle_sub_add_angle_sub_add_angle_sub_add_angle
  have hcos := cos_angle_add_angle_sub_add_angle_sub_add_angle_sub_add_angle_sub_add_angle
  have hcos := cos_angle_add_angle_sub_add_angle_sub_add_angle_sub_add_angle hx hy
  have hcos := cos_angle

For theorem:
theorem angle_add_angle_sub_add_angle_sub_eq_pi {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :
    angle x y + angle x (x - y) + angle y (y - x) = π 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  by_cases hxy : x = y
  · simp [hxy, Real.sin_angle_add_angle_sub_add_angle_sub_rev_eq_sin_angle hx hy]

For theorem:
theorem sin_angle_sub_add_angle_sub_rev_eq_sin_angle {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :
    Real.sin (angle x (x - y) + angle y (y - x)) = Real.sin (angle x y) 
Attempt failure.

Working on Mathlib/Geometry/Manifold/AnalyticManifold.lean - 2024-08-20 16:33:17.799504.
---0/3204---
Verifying proof:
:= by
  rw [analyticGroupoid, mem_groupoid_of_pregroupoid]
  suffices h : AnalyticGroupoid I by
    simp only [analyticGroupoid, mem_groupoid_of_pregroupoid]
    suffices h : AnalyticGroupoid I by
      rw [this]
      exact ⟨by simpa using this, by simpa using h⟩

For theorem:
theorem ofSet_mem_analyticGroupoid {s : Set H} (hs : IsOpen s) :
    PartialHomeomorph.ofSet s hs ∈ analyticGroupoid I 
Attempt failure.

Working on Mathlib/Geometry/Manifold/BumpFunction.lean - 2024-08-20 16:33:23.595811.
---0/3204---
Verifying proof:
:= by
  refine smooth_congr fun x hx =>?_
  refine smooth_smul_mem_chartAt_source (mem_chart_source H c) fun x hx =>?_
  simp only [mem_chartAt_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chartAt_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chartAt_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chartAt_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp only [mem_chart_source] at hx
  simp

For theorem:
theorem smooth_smul {G} [NormedAddCommGroup G] [NormedSpace ℝ G] {g : M → G}
    (hg : SmoothOn I 𝓘(ℝ, G) g (chartAt H c).source) : Smooth I 𝓘(ℝ, G) fun x => f x • g x 
Attempt failure.

Working on Mathlib/Geometry/Manifold/ChartedSpace.lean - 2024-08-20 16:33:36.717604.
---0/3204---
Verifying proof:
:=
  { e.singletonChartedSpace h := e.singletonChartedSpace h }

For theorem:
theorem singleton_hasGroupoid (h : e.source = Set.univ) (G : StructureGroupoid H)
    [ClosedUnderRestriction G] : @HasGroupoid _ _ _ _ (e.singletonChartedSpace h) G 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let e : M → LocalHomeomorph M H := chartAt H
  refine locallyConnectedSpace_of_connected_base H
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_
  refine locallyConnectedSpace_of_connected_base H?_

For theorem:
theorem ChartedSpace.locallyConnectedSpace [LocallyConnectedSpace H] : LocallyConnectedSpace M 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : ∀ x : M, (𝓝 x).HasBasis
    (fun s ↦ s ∈ 𝓝 (chartAt H x x)) ∧ IsCompact s ∧ s ∈ 𝓝 (chartAt H x x) := by
    intro x hx
    rcases mem_nhds_iff.1 hx with ⟨x, hx⟩
    rcases mem_nhds_iff.1 hx with ⟨x, hx⟩
    exact ⟨x, hx⟩

For theorem:
theorem ChartedSpace.locallyCompactSpace [LocallyCompactSpace H] : LocallyCompactSpace M 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have : ∀ x : M, (𝓝 x).HasBasis
    (fun s ↦ s ∈ 𝓝 (chartAt H x x)) ∧ IsCompact s ∧ s ∈ 𝓝 (chartAt H x x) := by
    intro x hx
    rcases mem_nhds_iff.1 hx with ⟨x, hx⟩
    rcases mem_nhds_iff.1 hx with ⟨x, hx⟩
    exact ⟨x, hx⟩

For theorem:
theorem ChartedSpace.locallyCompactSpace [LocallyCompactSpace H] : LocallyCompactSpace M 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  let e : M → LocalHomeomorph M H := chartAt H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_of_connected_basis H
  refine locallyConnectedSpace_o

For theorem:
theorem ChartedSpace.locallyConnectedSpace [LocallyConnectedSpace H] : LocallyConnectedSpace M 
Attempt failure.

Working on Mathlib/Geometry/Manifold/Complex.lean - 2024-08-20 16:34:08.694568.
---0/3204---
Verifying proof:
:= by
  refine norm_eqOn_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPreconnected_of_isPre

For theorem:
theorem norm_eqOn_of_isPreconnected_of_isMaxOn {f : M → F} {U : Set M} {c : M}
    (hd : MDifferentiableOn I 𝓘(ℂ, F) f U) (hc : IsPreconnected U) (ho : IsOpen U)
    (hcU : c ∈ U) (hm : IsMaxOn (norm ∘ f) U c) : EqOn (norm ∘ f) (const M ‖f c‖) U 
Attempt failure.

Working on Mathlib/Geometry/Manifold/ContMDiff/Atlas.lean - 2024-08-20 16:34:15.803584.
---0/3204---
Verifying proof:
:= by
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  · exac

For theorem:
theorem isLocalStructomorphOn_contDiffGroupoid_iff (f : PartialHomeomorph M M') :
    LiftPropOn (contDiffGroupoid ⊤ I).IsLocalStructomorphWithinAt f f.source ↔
      SmoothOn I I f f.source ∧ SmoothOn I I f.symm f.target 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  refine ⟨fun h ↦?_, fun h ↦?_⟩
  · exac

For theorem:
theorem isLocalStructomorphOn_contDiffGroupoid_iff (f : PartialHomeomorph M M') :
    LiftPropOn (contDiffGroupoid ⊤ I).IsLocalStructomorphWithinAt f f.source ↔
      SmoothOn I I f f.source ∧ SmoothOn I I f.symm f.target 
Attempt failure.

Working on Mathlib/Geometry/Manifold/ContMDiff/Basic.lean - 2024-08-20 16:34:25.026535.
---0/3204---
Verifying proof:
:= by
  refine contMDiff_iff_contMDiffAt.2 fun ε hε =>?_
  rw [contMDiffAt_iff_contMDiffAt, contMDiffAt_iff_contMDiffAt] at hε
  rw [contMDiffAt_iff_contMDiffAt] at hε
  rw [contMDiffAt_iff_contMDiffAt, ← contMDiffWithinAt_univ] at hε
  rw [contMDiffAt_iff_contMDiffAt] at hε
  rw [contMDiffAt_iff_contMDiffAt, ← contMDiffWithinAt_iff_contMDiffAt, ← contMDiffAt_iff_contMDiffAt,
    contMDiffAt_iff_contMDiffAt, ← contMDiffAt_iff_contMDiffAt, ← contMDiffAt_iff_contMDiffAt,
    contMDiffAt_iff_contMDiffAt, ← contMDiffAt_iff_contMDiffAt, ← contMDiffAt_iff_contMDiffAt,
    contMDiffAt_iff_contMDiffAt, ← contMDiffAt_iff_contMDiffAt, ← contMDiffAt_iff_contMDiffAt,
    contMDiffAt_iff_contMDiffAt, ← contMDiffAt_iff_contMDiffAt, ← contMDiffAt_iff_contMDiffAt,
    contMDiffAt_iff_contMDiffAt, ← contMDiffAt_iff_contMDiffAt, ← contMDiffAt_iff_contMDiffAt,
    contMDiffAt_iff_contMDiffAt, ← contMDiffAt_iff_contMDiffAt, ← contMDiffAt_iff_contMDiffAt,
    contMDiffAt_iff_contMDiffAt, ← 

For theorem:
theorem ContMDiff.extend_one [T2Space M] [One M'] {n : ℕ∞} {U : Opens M} {f : U → M'}
    (supp : HasCompactMulSupport f) (diff : ContMDiff I I' n f) :
    ContMDiff I I' n (Subtype.val.extend f 1) 
Attempt failure.

Working on Mathlib/Geometry/Manifold/ContMDiff/Defs.lean - 2024-08-20 16:34:34.797604.
---0/3204---
Verifying proof:
:= by
  rw [contMDiffWithinAt_iff_contMDiffWithinAt, contMDiffWithinAt_iff_contMDiffWithinAt,
    contMDiffWithinAt_iff_contMDiffWithinAt, contMDiffWithinAt_iff_contMDiffWithinAt,
    contMDiffWithinAt_iff_contMDiffWithinAt, contMDiffWithinAt_iff_contMDiffWithinAt,
    contMDiffWithinAt_iff_contMDiffWithinAt, contMDiffWithinAt_iff_contMDiffWithinAt,
    contMDiffWithinAt_iff_contMDiffWithinAt, contMDiffWithinAt_iff_contMDiffWithinAt,
    contMDiffWithinAt_iff_contMDiffWithinAt, contMDiffWithinAt_iff_contMDiffWithinAt,
    contMDiffWithinAt_iff_contMDiffWithinAt, contMDiffWithinAt_iff_contMDiffWithinAt,
    contMDiffWithinAt_iff_contMDiffWithinAt, contMDiffWithinAt_iff_contMDiffWithinAt,
    contMDiffWithinAt_iff_contMDiffWithinAt, contMDiffWithinAt_iff_contMDiffWithinAt,
    contMDiffWithinAt_iff_contMDiffWithinAt, contMDiffWithinAt_iff_contMDiffWithinAt,
    contMDiffWithinAt_iff_contMDiffWithinAt, contMDiffWithinAt_iff_contMDiffWithinAt,
    contMDiffWithinAt_iff_contMDiffWithinAt, contMDiffWithinAt_iff_co

For theorem:
theorem contMDiffWithinAt_iff_contMDiffOn_nhds {n : ℕ} :
    ContMDiffWithinAt I I' n f s x ↔ ∃ u ∈ 𝓝[insert x s] x, ContMDiffOn I I' n f u := by
    wlog hxs : x ∈ s generalizing s
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine contDiffWithinAtProp_iff.2 fun ε εpos =>?_
  rw [contDiffWithinAtProp_iff_target] at h ⊢
  rw [contDiffWithinAtProp_iff_target] at h ⊢
  rw [contDiffWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtPropWithinAtProp

For theorem:
theorem contDiffWithinAtProp_mono_of_mem (n : ℕ∞) ⦃s x t⦄ ⦃f : H → H'⦄ (hts : s ∈ 𝓝[t] x)
    (h : ContDiffWithinAtProp I I' n f s x) : ContDiffWithinAtProp I I' n f t x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [contMDiffOn_iff_target, contMDiffWithinAt_iff_target]
  refine ⟨fun h y =>?_, fun h y =>?_⟩
  simp only [contMDiffWithinAt_iff_target, mfld_simps]

For theorem:
theorem contMDiffOn_iff_target :
    ContMDiffOn I I' n f s ↔
      ContinuousOn f s ∧
        ∀ y : M',
          ContMDiffOn I 𝓘(𝕜, E') n (extChartAt I' y ∘ f) (s ∩ f ⁻¹' (extChartAt I' y).source) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [contDiffWithinAtProp, localInvariantProp, contDiffWithinAtProp, contDiffWithinAtProp,
    contDiffWithinAtProp, contDiffWithinAtProp_apply]

For theorem:
theorem contDiffWithinAt_localInvariantProp (n : ℕ∞) :
    (contDiffGroupoid ∞ I).LocalInvariantProp (contDiffGroupoid ∞ I')
      (ContDiffWithinAtProp I I' n) where
Attempt failure.

Working on Mathlib/Geometry/Manifold/ContMDiffMFDeriv.lean - 2024-08-20 16:35:31.910226.
---0/3204---
Verifying proof:
:= by
  rcases p with ⟨x, v⟩
  rcases p with ⟨x, v⟩
  rw [tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply,

For theorem:
theorem tangentMap_tangentBundle_pure (p : TangentBundle I M) :
    tangentMap I I.tangent (zeroSection E (TangentSpace I)) p = ⟨⟨p.proj, 0⟩, ⟨p.2, 0⟩⟩ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [contMDiffOn_iff_tangentMapWithin hf hmn]
  exact hf.contMDiffOn_tangentMapWithin hmn hs

For theorem:
theorem ContMDiffOn.contMDiffOn_tangentMapWithin (hf : ContMDiffOn I I' n f s) (hmn : m + 1 ≤ n)
    (hs : UniqueMDiffOn I s) :
    ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s)
      (π E (TangentSpace I) ⁻¹' s) := by
    have one_le_n : 1 ≤ n := (le_add_left le_rfl).trans hmn
    refine contMDiffOn_of_locally_contMDiffOn fun p hp => ?_
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← contMDiffWithinAt_univ] at hf hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  refine contMDiffWithinAt_prod (hf.prod hg) (hg.prod hg) (hg.prod hg)?_
  rw [← contMDiffWithinAt_univ]
  refine contMDiffWithinAt_prod_of_mem_univ hmn?_
  rw [← contMDiffWithinAt_univ] at hg ⊢
  refine contMDiffWithinAt_prod_of_mem_univ hmn?_
  rw [← contMDiffWithinAt_univ] at hg ⊢
  refine contMDiffWithinAt_prod_of_mem_univ hmn?_
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  ref

For theorem:
theorem ContMDiffAt.mfderiv {x₀ : N} (f : N → M → M') (g : N → M)
    (hf : ContMDiffAt (J.prod I) I' n (Function.uncurry f) (x₀, g x₀)) (hg : ContMDiffAt J I m g x₀)
    (hmn : m + 1 ≤ n) :
    ContMDiffAt J 𝓘(𝕜, E →L[𝕜] E') m
      (inTangentCoordinates I I' g (fun x => f x (g x)) (fun x => mfderiv I I' (f x) (g x)) x₀)
      x₀ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [contMDiffOn_tangentMapWithin_aux hf hmn]
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  rw [tangentMapWithin_aux hmn]
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hx).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hx).congr fun x hx =>?_

For theorem:
theorem ContMDiffOn.contMDiffOn_tangentMapWithin_aux {f : H → H'} {s : Set H}
    (hf : ContMDiffOn I I' n f s) (hmn : m + 1 ≤ n) (hs : UniqueMDiffOn I s) :
    ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s)
      (π E (TangentSpace I) ⁻¹' s) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← contMDiffWithinAt_univ] at hf hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  refine contMDiffWithinAt_prod (hf.prod hg) (hg.prod hg) (hg.prod hg)?_
  rw [← contMDiffWithinAt_univ]
  refine contMDiffWithinAt_prod_of_mem_univ hmn?_
  rw [← contMDiffWithinAt_univ] at hg ⊢
  refine contMDiffWithinAt_prod_of_mem_univ hmn?_
  rw [← contMDiffWithinAt_univ] at hg ⊢
  refine contMDiffWithinAt_prod_of_mem_univ hmn?_
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  ref

For theorem:
theorem ContMDiffAt.mfderiv {x₀ : N} (f : N → M → M') (g : N → M)
    (hf : ContMDiffAt (J.prod I) I' n (Function.uncurry f) (x₀, g x₀)) (hg : ContMDiffAt J I m g x₀)
    (hmn : m + 1 ≤ n) :
    ContMDiffAt J 𝓘(𝕜, E →L[𝕜] E') m
      (inTangentCoordinates I I' g (fun x => f x (g x)) (fun x => mfderiv I I' (f x) (g x)) x₀)
      x₀ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [contMDiffOn_tangentMapWithin_aux hf hmn]
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  rw [tangentMapWithin_aux hmn]
  refine (contMDiffOn_tangentMapWithin_aux hf hs).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hx).congr fun x hx =>?_
  refine (contMDiffOn_tangentMapWithin_aux hf hx).congr fun x hx =>?_

For theorem:
theorem ContMDiffOn.contMDiffOn_tangentMapWithin_aux {f : H → H'} {s : Set H}
    (hf : ContMDiffOn I I' n f s) (hmn : m + 1 ≤ n) (hs : UniqueMDiffOn I s) :
    ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s)
      (π E (TangentSpace I) ⁻¹' s) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [contMDiffOn_iff_tangentMapWithin hf hmn]
  exact hf.contMDiffOn_tangentMapWithin hmn hs

For theorem:
theorem ContMDiffOn.contMDiffOn_tangentMapWithin (hf : ContMDiffOn I I' n f s) (hmn : m + 1 ≤ n)
    (hs : UniqueMDiffOn I s) :
    ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s)
      (π E (TangentSpace I) ⁻¹' s) := by
    have one_le_n : 1 ≤ n := (le_add_left le_rfl).trans hmn
    refine contMDiffOn_of_locally_contMDiffOn fun p hp => ?_
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases p with ⟨x, v⟩
  rcases p with ⟨x, v⟩
  rw [tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply, tangentMap_apply,
    tangentMap_apply,

For theorem:
theorem tangentMap_tangentBundle_pure (p : TangentBundle I M) :
    tangentMap I I.tangent (zeroSection E (TangentSpace I)) p = ⟨⟨p.proj, 0⟩, ⟨p.2, 0⟩⟩ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← contMDiffWithinAt_univ] at hf hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  refine contMDiffWithinAt_prod (hf.prod hg) (hg.prod hg) (hg.prod hg)?_
  rw [← contMDiffWithinAt_univ]
  refine contMDiffWithinAt_prod_of_mem_univ hmn?_
  rw [← contMDiffWithinAt_univ] at hg ⊢
  refine contMDiffWithinAt_prod_of_mem_univ hmn?_
  rw [← contMDiffWithinAt_univ] at hg ⊢
  refine contMDiffWithinAt_prod_of_mem_univ hmn?_
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  rw [← contMDiffWithinAt_univ] at hg ⊢
  ref

For theorem:
theorem ContMDiffAt.mfderiv {x₀ : N} (f : N → M → M') (g : N → M)
    (hf : ContMDiffAt (J.prod I) I' n (Function.uncurry f) (x₀, g x₀)) (hg : ContMDiffAt J I m g x₀)
    (hmn : m + 1 ≤ n) :
    ContMDiffAt J 𝓘(𝕜, E →L[𝕜] E') m
      (inTangentCoordinates I I' g (fun x => f x (g x)) (fun x => mfderiv I I' (f x) (g x)) x₀)
      x₀ 
Attempt failure.

Working on Mathlib/Geometry/Manifold/Instances/Real.lean - 2024-08-20 16:37:15.310381.
---0/3204---
Verifying proof:
:= by
  simp only [deprecated_since, range_half_span]

For theorem:
theorem range_euclideanHalfSpace (n : ℕ) [Zero (Fin n)] :
    (range fun x : EuclideanHalfSpace n => x.val) = { y | 0 ≤ y 0 } 
Attempt failure.

Working on Mathlib/Geometry/Manifold/Instances/Sphere.lean - 2024-08-20 16:37:23.877476.
---0/3204---
Verifying proof:
:= by
  refine ContDiffOn.smul?_ (orthogonalProjection (ℝ ∙ v)ᗮ).contDiff.contDiffOn

For theorem:
theorem contDiffOn_stereoToFun :
    ContDiffOn ℝ ⊤ (stereoToFun v) {x : E | innerSL _ v x ≠ (1 : ℝ)} 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [mfderiv, mfderiv, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp]

For theorem:
theorem range_mfderiv_coe_sphere {n : ℕ} [Fact (finrank ℝ E = n + 1)] (v : sphere (0 : E) 1) :
    LinearMap.range (mfderiv (𝓡 n) 𝓘(ℝ, E) ((↑) : sphere (0 : E) 1 → E) v :
    TangentSpace (𝓡 n) v →L[ℝ] E) = (ℝ ∙ (v : E))ᗮ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [((contMDiff_coe_sphere (0 : E) 1).comp_continuousMultilinearMap v).comp_continuousMultilinearMap
  rw [(contMDiff_coe_sphere (0 : E) 1).comp_continuousMultilinearMap v).mfderiv]

For theorem:
theorem mfderiv_coe_sphere_injective {n : ℕ} [Fact (finrank ℝ E = n + 1)] (v : sphere (0 : E) 1) :
    Injective (mfderiv (𝓡 n) 𝓘(ℝ, E) ((↑) : sphere (0 : E) 1 → E) v) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp? [stereographic_apply, orthogonalProjection_orthogonalComplement_singleton_eq_zero] at h

For theorem:
theorem stereographic_apply_neg (v : sphere (0 : E) 1) :
    stereographic (norm_eq_of_mem_sphere v) (-v) = 0 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [mfderiv, mfderiv, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp,
    LinearMap.range_comp, LinearMap.range_comp, LinearMap.range_comp]

For theorem:
theorem range_mfderiv_coe_sphere {n : ℕ} [Fact (finrank ℝ E = n + 1)] (v : sphere (0 : E) 1) :
    LinearMap.range (mfderiv (𝓡 n) 𝓘(ℝ, E) ((↑) : sphere (0 : E) 1 → E) v :
    TangentSpace (𝓡 n) v →L[ℝ] E) = (ℝ ∙ (v : E))ᗮ 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [((contMDiff_coe_sphere (0 : E) 1).comp_continuousMultilinearMap v).comp_continuousMultilinearMap
  rw [(contMDiff_coe_sphere (0 : E) 1).comp_continuousMultilinearMap v).mfderiv]

For theorem:
theorem mfderiv_coe_sphere_injective {n : ℕ} [Fact (finrank ℝ E = n + 1)] (v : sphere (0 : E) 1) :
    Injective (mfderiv (𝓡 n) 𝓘(ℝ, E) ((↑) : sphere (0 : E) 1 → E) v) 
Attempt failure.

Working on Mathlib/Geometry/Manifold/IntegralCurve.lean - 2024-08-20 16:39:50.145739.
---0/3204---
Verifying proof:
:= by
  obtain ⟨ε, hε, h⟩ := hγ.aestronglyMeasurable
  refine ⟨ε, hε,?_⟩
  refine ⟨ε, hε,?_⟩
  · exact hγ.aestronglyMeasurable ha

For theorem:
lemma IsIntegralCurveAt.comp_mul_ne_zero (hγ : IsIntegralCurveAt γ v t₀) {a : ℝ} (ha : a ≠ 0) :
    IsIntegralCurveAt (γ ∘ (· * a)) (a • v) (t₀ / a) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨γ, hγ⟩ : ∃ γ : ℝ, 0 < γ t₀ := exists_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegral 

For theorem:
theorem exists_isIntegralCurveAt_of_contMDiffAt
    (hv : ContMDiffAt I I.tangent 1 (fun x ↦ (⟨x, v x⟩ : TangentBundle I M)) x₀)
    (hx : I.IsInteriorPoint x₀) :
    ∃ γ : ℝ → M, γ t₀ = x₀ ∧ IsIntegralCurveAt γ v t₀ := by
    rw [contMDiffAt_iff] at hv
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun hγ ↦ hγ.comp_mul_ne_zero ha, fun hγ ↦?_⟩
  refine ⟨fun hγ ↦ hγ.comp_mul_ne_zero ha, fun hγ ↦?_⟩
  refine ⟨fun hγ ↦ hγ.comp_mul_ne_zero ha, fun hγ ↦?_⟩
  refine ⟨fun hγ ↦?_, fun hγ ↦?_⟩
  · rw [hγ.comp_mul_ne_zero ha]
    exact hγ.comp_mul_ne_zero ha

For theorem:
lemma isIntegralCurveAt_comp_mul_ne_zero {a : ℝ} (ha : a ≠ 0) :
    IsIntegralCurveAt γ v t₀ ↔ IsIntegralCurveAt (γ ∘ (· * a)) (a • v) (t₀ / a) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp_rw [IsIntegralCurveOn, ← Metric.eventually_nhds_iff_ball]

For theorem:
lemma isIntegralCurveAt_iff' :
    IsIntegralCurveAt γ v t₀ ↔ ∃ ε > 0, IsIntegralCurveOn γ v (Metric.ball t₀ ε) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨γ, hγ⟩ : ∃ γ : ℝ, 0 < γ t₀ := exists_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegralCurveAt_of_isIntegral 

For theorem:
theorem exists_isIntegralCurveAt_of_contMDiffAt
    (hv : ContMDiffAt I I.tangent 1 (fun x ↦ (⟨x, v x⟩ : TangentBundle I M)) x₀)
    (hx : I.IsInteriorPoint x₀) :
    ∃ γ : ℝ → M, γ t₀ = x₀ ∧ IsIntegralCurveAt γ v t₀ := by
    rw [contMDiffAt_iff] at hv
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [isIntegralCurveAt_iff'] at *
  rw [isIntegralCurveAt_iff'] at *
  refine (hγ.comp_mul_ne_zero (inv_ne_zero ha)).congr_of_eventuallyEq?_
  simp only [Function.comp_apply, inv_mul_cancel ha, one_smul]

For theorem:
lemma IsIntegralCurveAt.comp_mul_ne_zero (hγ : IsIntegralCurveAt γ v t₀) {a : ℝ} (ha : a ≠ 0) :
    IsIntegralCurveAt (γ ∘ (· * a)) (a • v) (t₀ / a) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun hγ ↦ hγ.comp_add _, fun hγ ↦?_⟩
  refine ⟨fun hγ ↦ hγ.comp_add _, fun hγ ↦?_⟩
  · exact hγ.comp_add _

For theorem:
lemma isIntegralCurveOn_comp_add {dt : ℝ} :
    IsIntegralCurveOn γ v s ↔ IsIntegralCurveOn (γ ∘ (· + dt)) v { t | t + dt ∈ s } 
Attempt failure.

Working on Mathlib/Geometry/Manifold/InteriorBoundary.lean - 2024-08-20 16:40:46.743512.
---0/3204---
Verifying proof:
:= by
  rw [IsInteriorPoint, or_iff_not_imp_left, I.isBoundaryPoint_iff, ← closure_diff_interior]

For theorem:
lemma isInteriorPoint_or_isBoundaryPoint (x : M) : I.IsInteriorPoint x ∨ I.IsBoundaryPoint x 
Attempt failure.

Working on Mathlib/Geometry/Manifold/LocalDiffeomorph.lean - 2024-08-20 16:40:48.834421.
---0/3204---
Verifying proof:
:=
  fun _ ↦ ⟨Φ.toPartialDiffeomorph, by trivial, eqOn_refl Φ⟩

For theorem:
lemma Diffeomorph.isLocalDiffeomorph (Φ : M ≃ₘ^n⟮I, J⟯ N) : IsLocalDiffeomorph I J n Φ 
Attempt failure.

---0/3204---
Verifying proof:
:=
  fun x hx ↦ ((hf ⟨x, hx⟩).contMDiffAt I J).contMDiffWithinAt

For theorem:
lemma IsLocalDiffeomorphOn.contMDiffOn (hf : IsLocalDiffeomorphOn I J n f s) :
    ContMDiffOn I J n f s 
Attempt failure.

Working on Mathlib/Geometry/Manifold/LocalInvariantProperties.lean - 2024-08-20 16:40:54.161962.
---0/3204---
Verifying proof:
:= by
  simp only [LiftPropWithinAt, LiftPropWithinAt, LiftPropWithinAt, LiftPropWithinAt,
    LiftPropWithinAt, LiftPropWithinAt, he]

For theorem:
theorem liftPropWithinAt_indep_chart_source [HasGroupoid M G] (he : e ∈ G.maximalAtlas M)
    (xe : x ∈ e.source) :
    LiftPropWithinAt P g s x ↔ LiftPropWithinAt P (g ∘ e.symm) (e.symm ⁻¹' s) (e x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨fun h =>?_, fun h =>?_⟩
  · simp only [h, mfld_simps]

For theorem:
theorem left_invariance {s : Set H} {x : H} {f : H → H'} {e' : PartialHomeomorph H' H'}
    (he' : e' ∈ G') (hfs : ContinuousWithinAt f s x) (hxe' : f x ∈ e'.source) :
    P (e' ∘ f) s x ↔ P f s x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [liftPropWithinAt_iff']
  refine ⟨fun h => ⟨h.continuousWithinAt,?_⟩, fun h =>?_⟩
  refine ⟨h.continuousWithinAt, fun h =>?_⟩
  · exact ⟨h.continuousWithinAt, fun h => ⟨h.continuousWithinAt⟩⟩
  · exact ⟨h.continuousWithinAt, h.continuousWithinAt⟩
  · exact ⟨h.continuousWithinAt, h.continuousWithinAt⟩

For theorem:
theorem liftPropWithinAt_indep_chart_target [HasGroupoid M' G'] (hf : f ∈ G'.maximalAtlas M')
    (xf : g x ∈ f.source) :
    LiftPropWithinAt P g s x ↔ ContinuousWithinAt g s x ∧ LiftPropWithinAt P (f ∘ g) s x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [liftPropWithinAt_iff']
  rw [liftPropWithinAt_iff']
  refine and_congr_right fun h =>?_
  refine ⟨fun h =>?_, fun h =>?_⟩
  simp only [h, mfld_simps]

For theorem:
theorem liftPropWithinAt_iff {f : M → M'} :
    LiftPropWithinAt P f s x ↔
      ContinuousWithinAt f s x ∧
        P (chartAt H' (f x) ∘ f ∘ (chartAt H x).symm)
          ((chartAt H x).target ∩ (chartAt H x).symm ⁻¹' (s ∩ f ⁻¹' (chartAt H' (f x)).source))
          (chartAt H x x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [liftPropWithinAt_iff']
  rw [liftPropWithinAt_iff']
  refine and_congr_right fun h =>?_
  refine ⟨fun h =>?_, fun h =>?_⟩
  simp only [h, mfld_simps]

For theorem:
theorem liftPropWithinAt_iff {f : M → M'} :
    LiftPropWithinAt P f s x ↔
      ContinuousWithinAt f s x ∧
        P (chartAt H' (f x) ∘ f ∘ (chartAt H x).symm)
          ((chartAt H x).target ∩ (chartAt H x).symm ⁻¹' (s ∩ f ⁻¹' (chartAt H' (f x)).source))
          (chartAt H x x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [liftPropWithinAt_iff']
  rw [liftPropWithinAt_iff']
  refine and_congr_right fun h =>?_
  refine ⟨fun h =>?_, fun h =>?_⟩
  simp only [h, mfld_simps]

For theorem:
theorem liftPropWithinAt_iff {f : M → M'} :
    LiftPropWithinAt P f s x ↔
      ContinuousWithinAt f s x ∧
        P (chartAt H' (f x) ∘ f ∘ (chartAt H x).symm)
          ((chartAt H x).target ∩ (chartAt H x).symm ⁻¹' (s ∩ f ⁻¹' (chartAt H' (f x)).source))
          (chartAt H x x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [liftPropWithinAt_iff']
  rw [liftPropWithinAt_iff']
  refine and_congr_right fun h =>?_
  refine ⟨fun h =>?_, fun h =>?_⟩
  simp only [h, mfld_simps]

For theorem:
theorem liftPropWithinAt_iff {f : M → M'} :
    LiftPropWithinAt P f s x ↔
      ContinuousWithinAt f s x ∧
        P (chartAt H' (f x) ∘ f ∘ (chartAt H x).symm)
          ((chartAt H x).target ∩ (chartAt H x).symm ⁻¹' (s ∩ f ⁻¹' (chartAt H' (f x)).source))
          (chartAt H x x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine isLocalStructomorphWithinAt_iff_partialHomeomorphWithinAt.mpr fun y hy =>?_
  refine isLocalStructomorphWithinAt_iff_partialHomeomorphWithinAt.mpr fun y hy =>?_
  · simp only [mfld_simps] at hy
    exact hy
  · simp only [mfld_simps] at hy
    rw [mem_inter_iff, mem_singleton_iff] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_simps] at hy
    simp only [mfld_sim

For theorem:
theorem _root_.PartialHomeomorph.isLocalStructomorphWithinAt_iff' {G : StructureGroupoid H}
    [ClosedUnderRestriction G] (f : PartialHomeomorph H H) {s : Set H} {x : H} (hs : f.source ⊆ s)
    (hx : x ∈ f.source ∪ sᶜ) :
    G.IsLocalStructomorphWithinAt (⇑f) s x ↔
      x ∈ s → ∃ e : PartialHomeomorph H H,
      e ∈ G ∧ e.source ⊆ f.source ∧ EqOn f (⇑e) e.source ∧ x ∈ e.source 
Attempt failure.

Working on Mathlib/Geometry/Manifold/MFDeriv/Basic.lean - 2024-08-20 16:41:19.258180.
---0/3204---
Verifying proof:
:= by
  simp only [mfderivWithin, mfderivWithin, mfderivWithin, h, if_pos, mfld_simps]

For theorem:
theorem MDifferentiableWithinAt.mfderivWithin (h : MDifferentiableWithinAt I I' f s x) :
    mfderivWithin I I' f s x =
      fderivWithin 𝕜 (writtenInExtChartAt I I' x f : _) ((extChartAt I x).symm ⁻¹' s ∩ range I)
        ((extChartAt I x) x) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  simp only [MDifferentiableWithinAt, mfld_simps]

For theorem:
theorem mdifferentiableWithinAt_iff {f : M → M'} {s : Set M} {x : M} :
    MDifferentiableWithinAt I I' f s x ↔
      ContinuousWithinAt f s x ∧
        DifferentiableWithinAt 𝕜 (writtenInExtChartAt I I' x f)
          ((extChartAt I x).target ∩ (extChartAt I x).symm ⁻¹' s) ((extChartAt I x) x) 
Attempt failure.

---0/3204---
Verifying proof:
:=
  ⟨ContinuousAt.continuousWithinAt h.1, HasFDerivWithinAt.mono h.2 (inter_subset_right)⟩

For theorem:
theorem HasMFDerivAt.hasMFDerivWithinAt (h : HasMFDerivAt I I' f x f') :
    HasMFDerivWithinAt I I' f s x f' 
Attempt failure.

Working on Mathlib/Geometry/Manifold/MFDeriv/FDeriv.lean - 2024-08-20 16:42:15.247512.
---0/3204---
Verifying proof:
:= by
  simp only [MDifferentiableWithinAt, mfld_simps]

For theorem:
theorem mdifferentiableWithinAt_iff_differentiableWithinAt :
    MDifferentiableWithinAt 𝓘(𝕜, E) 𝓘(𝕜, E') f s x ↔ DifferentiableWithinAt 𝕜 f s x 
Attempt failure.

Working on Mathlib/Geometry/Manifold/MFDeriv/SpecificFunctions.lean - 2024-08-20 16:42:19.683140.
---0/3204---
Verifying proof:
:= by
  convert mfderiv_prod I' (I.prod I') (fun y => (x₀, y)) y₀ using 1
  · simp only [mfderiv_prod_eq, mfderiv_const, mfderiv_const, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfderiv_prod_eq, mfld_simps]
  · simp only [mfld_simps]

For theorem:
theorem mfderiv_prod_right {x₀ : M} {y₀ : M'} :
    mfderiv I' (I.prod I') (fun y => (x₀, y)) y₀ =
      ContinuousLinearMap.inr 𝕜 (TangentSpace I x₀) (TangentSpace I' y₀) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨continuousAt_id,?_⟩
  have : ∀ᶠ y in 𝓝[range I] (extChartAt I x), ∀ᶠ y in 𝓝[range I] (extChartAt I x),
      ∀ᶠ y in 𝓝[range I] (extChartAt I x),
        ∀ᶠ y in 𝓝[range I] (extChartAt I x),
         ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
        ∀ᶠ y in 𝓝[ran

For theorem:
theorem hasMFDerivAt_id (x : M) :
    HasMFDerivAt I I (@id M) x (ContinuousLinearMap.id 𝕜 (TangentSpace I x)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [← hasMFDerivWithinAt_univ]
  exact hasMFDerivAt_fst.comp x.hasMFDerivAt

For theorem:
theorem hasMFDerivAt_fst (x : M × M') :
    HasMFDerivAt (I.prod I') I Prod.fst x
      (ContinuousLinearMap.fst 𝕜 (TangentSpace I x.1) (TangentSpace I' x.2)) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine ⟨continuousAt_id,?_⟩
  have : ∀ᶠ y in 𝓝[range I] (extChartAt I x), ∀ᶠ y in 𝓝[range I] (extChartAt I x),
      ∀ᶠ y in 𝓝[range I] (extChartAt I x),
        ∀ᶠ y in 𝓝[range I] (extChartAt I x),
         ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
          ∀ᶠ y in 𝓝[range I] (extChartAt I x),
        ∀ᶠ y in 𝓝[ran

For theorem:
theorem hasMFDerivAt_id (x : M) :
    HasMFDerivAt I I (@id M) x (ContinuousLinearMap.id 𝕜 (TangentSpace I x)) 
Attempt failure.

Working on Mathlib/Geometry/Manifold/Metrizable.lean - 2024-08-20 16:43:26.441996.
---0/3204---
Verifying proof:
:= by
  refine manifoldWithCorners.metrizableSpace_of_finiteDimensional?_
  refine manifoldWithCorners.metrizableSpace_of_finiteDimensional?_
  refine manifoldWithCorners.metrizableSpace_of_finiteDimensional?_
  refine manifoldWithCorners.metrizableSpace_of_finiteDimensional?_
  refine manifoldWithCorners.metrizableSpace_of_finiteDimensional?_
  refine manifoldWithCorners.metrizableSpace_of_finiteDimensional?_
  refine manifoldWithCorners.metrizableSpace_of_finiteDimensional?_
  refine manifoldWithCorners.metrizableSpace_of_finiteDimensional?_
  refine manifoldWithCorners.metrizableSpace_of_finiteDimensional?_
  refine manifoldWithCorners.metrizableSpace_of_finiteDimensional?_
  refine manifoldWithCorners.metrizableSpace_of_finiteDimensional?_
  refine manifoldWithCorners.metrizableSpace_of_finiteDimensional?_
  refine manifoldWithCorners.metrizableSpace_of_finiteDimensional?_
  refine manifoldWithCorners.metrizableSpace_of_finiteDimensional?_
  refine manifoldWithCorners_of_finiteDimensional?

For theorem:
theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
    [FiniteDimensional ℝ E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ℝ E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M 
Attempt failure.

Working on Mathlib/Geometry/Manifold/PartitionOfUnity.lean - 2024-08-20 16:43:30.576408.
---0/3204---
Verifying proof:
:= by
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_s

For theorem:
theorem contMDiff_finsum_smul {g : ι → M → F}
    (hg : ∀ (i), ∀ x ∈ tsupport (f i), ContMDiffAt I 𝓘(ℝ, F) n (g i) x) :
    ContMDiff I 𝓘(ℝ, F) n fun x => ∑ᶠ i, f i x • g i x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rcases exists_smooth_forall_closedBall_subset hK hU with ⟨ε, εpos, hε⟩
  refine ⟨ε, εpos,?_⟩
  refine ⟨ε, εpos, fun x hx =>?_⟩
  · exact ⟨ε, εpos, hε⟩
  · exact ⟨ε, εpos, hε⟩
  · exact ⟨ε, εpos, hε⟩
  · exact ⟨ε, εpos, hε⟩
  · exact ⟨ε, εpos, hε⟩
  · exact ⟨ε, εpos, hε⟩
  · exact ⟨ε, εpos, hε⟩
  · exact ⟨ε, εpos, hε⟩
  · exact ⟨ε, εpos, hε⟩
  · exact ⟨ε, εpos, by simp⟩
  · exact ⟨ε, εpos, by simp⟩
  · exact ⟨ε, εpos, by simp⟩
  · exact ⟨ε, εpos, by simp⟩

For theorem:
theorem Metric.exists_smooth_forall_closedBall_subset {M} [MetricSpace M] [ChartedSpace H M]
    [SmoothManifoldWithCorners I M] [SigmaCompactSpace M] {K : ι → Set M} {U : ι → Set M}
    (hK : ∀ i, IsClosed (K i)) (hU : ∀ i, IsOpen (U i)) (hKU : ∀ i, K i ⊆ U i)
    (hfin : LocallyFinite K) :
    ∃ δ : C^∞⟮I, M; 𝓘(ℝ, ℝ), ℝ⟯,
      (∀ x, 0 < δ x) ∧ ∀ (i), ∀ x ∈ K i, Metric.closedBall x (δ x) ⊆ U i 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  have h's : IsOpen (I.symm ⁻¹' s) := by
    rcases h's with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩
    rcases hf with ⟨f, hfs, hf⟩


For theorem:
lemma IsOpen.exists_msmooth_support_eq_aux {s : Set H} (hs : IsOpen s) :
    ∃ f : H → ℝ, f.support = s ∧ Smooth I 𝓘(ℝ) f ∧ Set.range f ⊆ Set.Icc 0 1 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_smul fun i _ =>?_
  refine contMDiff_finsum_s

For theorem:
theorem contMDiff_finsum_smul {g : ι → M → F}
    (hg : ∀ (i), ∀ x ∈ tsupport (f i), ContMDiffAt I 𝓘(ℝ, F) n (g i) x) :
    ContMDiff I 𝓘(ℝ, F) n fun x => ∑ᶠ i, f i x • g i x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  obtain ⟨U, hxU, hU⟩ : ∃ U ∈ 𝓝 x, IsOpen U ∧ IsOpen U := by
    refine ⟨U, hU, fun y hy =>?_⟩
    rcases Hloc x with ⟨U, hU₁, hU₂, hU₂⟩
    rcases Hloc x with ⟨U, hU₁, hU₂, hU₂⟩
    refine ⟨U, hU₁, fun y hy =>?_⟩
    rcases Hloc x with ⟨U, hU₁, hU₂, hU₂⟩
    rcases Hloc x with ⟨U, hU₁, hU₂, hU₂⟩
    refine ⟨U, hU₁, fun y hy =>?_⟩
    rcases Hloc x with ⟨U, hU₁, hU₂⟩
    rcases Hloc x with ⟨U, hU₁, hU₂, hU₂⟩
    refine ⟨U, hU₁, fun y hy =>?_⟩
    rcases Hloc x with ⟨U, hU₁, hU₂⟩
    refine ⟨U, hU₁, fun y hy =>?_⟩
    rcases Hloc x with ⟨U, hU₁, hU₂⟩
    refine ⟨U, hU₁, fun y hy =>?_⟩
    rcases Hloc x with ⟨U, hU₁, hU₂, hU₂⟩
    rcases Hloc x with ⟨U, hU₁, hU₂⟩
    refine ⟨U, hU₂, fun y hy =>?_⟩
    rcases Hloc x with ⟨U, hU₁, hU₂⟩
    refine ⟨U, hU₂, fun y hy =>?_⟩
    rcases Hloc x with ⟨U, hU₁, hU₂⟩
    rcases Hloc x with ⟨U,

For theorem:
theorem exists_smooth_forall_mem_convex_of_local (ht : ∀ x, Convex ℝ (t x))
    (Hloc : ∀ x : M, ∃ U ∈ 𝓝 x, ∃ g : M → F, SmoothOn I 𝓘(ℝ, F) g U ∧ ∀ y ∈ U, g y ∈ t y) :
    ∃ g : C^∞⟮I, M; 𝓘(ℝ, F), F⟯, ∀ x, g x ∈ t x 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  haveI : Nonempty s := ⟨⊥, by simpa using hU⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : Nonempty s := ⟨⊥⟩
  haveI : No

For theorem:
theorem exists_isSubordinate [T2Space M] [SigmaCompactSpace M] (hs : IsClosed s)
    (hU : ∀ x ∈ s, U x ∈ 𝓝 x) :
    ∃ (ι : Type uM) (f : SmoothBumpCovering ι I M s), f.IsSubordinate U := by
    haveI : LocallyCompactSpace H 
Attempt failure.

Working on Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean - 2024-08-20 16:44:40.180305.
---0/3204---
Verifying proof:
:= by
  rw [mapsTo', extend_coe, extend_coe_symm, preimage_comp, ← I.image_eq, image_univ]

For theorem:
theorem mapsTo_extend (hs : s ⊆ f.source) :
    MapsTo (f.extend I) s ((f.extend I).symm ⁻¹' s ∩ range I) 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [continuousOn_iff_continuous_restrict]
  refine continuousOn_iff_continuousAt.2 fun x hx =>?_
  refine continuousWithinAt_of_continuousWithinAt f'.continuousWithinAt f'.open_source?_?_
  · rintro x ⟨hxs, hxs⟩
    exact hmaps hxs

For theorem:
theorem continuousOn_writtenInExtend_iff {f' : PartialHomeomorph M' H'} {g : M → M'}
    (hs : s ⊆ f.source) (hmaps : MapsTo g s f'.source) :
    ContinuousOn (f'.extend I' ∘ g ∘ (f.extend I).symm) (f.extend I '' s) ↔ ContinuousOn g s 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  apply le_antisymm le_top
  intro u _
  change u ∈ contDiffGroupoid 0 I
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]
  rw [contDiffGroupoid, mem_groupoid_of_p

For theorem:
theorem contDiffGroupoid_zero_eq : contDiffGroupoid 0 I = continuousGroupoid H 
Attempt failure.

---0/3204---
Verifying proof:
:= by
  rw [continuousWithinAt_iff_continuousWithinAt, ContinuousWithinAt, ContinuousWithinAt,
    continuousWithinAt_iff_continuousWithinAt]

For theorem:
theorem symm_continuousWithinAt_comp_right_iff {X} [TopologicalSpace X] {f : H → X} {s : Set H}
    {x : H} :
    ContinuousWithinAt (f ∘ I.symm) (I.symm ⁻¹' s ∩ range I) (I x) ↔ ContinuousWithinAt f s x 
Attempt failure.

---0/3204---
Verifying proof:
:= by refine I.left_inv'?_ simp

For theorem:
theorem left_inv (x : H) : I.symm (I x) = x 
Attempt failure.

Working on Mathlib/Geometry/Manifold/VectorBundle/Basic.lean - 2024-08-20 16:45:37.160820.
---0/3204---
