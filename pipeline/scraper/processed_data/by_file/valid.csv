filepath,thm_name,decl_name,commit,failed_proof,error_msg,statement,proof
Mathlib/Algebra/GroupWithZero/Hom.lean,MonoidWithZeroHom.toMonoidHom_injective,toMonoidHom_injective,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  fun _ _ h ‚Ü¶ ext $ MonoidHom.ext_iff.mp h",error:  unknown constant 'MonoidHom.ext_iff.mp',lemma toMonoidHom_injective : Injective (toMonoidHom : (Œ± ‚Üí*‚ÇÄ Œ≤) ‚Üí Œ± ‚Üí* Œ≤) ,":=
  Injective.of_comp (f := DFunLike.coe) DFunLike.coe_injective"
Mathlib/Data/Real/GoldenRatio.lean,fib_golden_conj_exp,fib_golden_conj_exp,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  repeat rw [coe_fib_eq]
  rw [mul_div, div_sub_div_same, mul_sub, ‚Üê pow_succ]
  ring_nf
  have nz : sqrt 5 ‚â† 0 := by norm_num
  rw [‚Üê (mul_inv_cancel nz).symm, one_mul]","warning:  goldenRatio does not have a doc string
warning:  goldenConj does not have a doc string
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a ^ ?n * ?a
n : ‚Ñï
‚ä¢ (œÜ ^ (n + 1) - œà ^ (n + 1) - (œÜ * œÜ ^ n - œÜ * œà ^ n)) / ‚àö5 = œà ^ n",theorem fib_golden_conj_exp (n : ‚Ñï) : Nat.fib (n + 1) - œÜ * Nat.fib n = œà ^ n ,":= by
  repeat rw [coe_fib_eq]
  rw [mul_div, div_sub_div_same, mul_sub, ‚Üê pow_succ']
  ring_nf
  have nz : sqrt 5 ‚â† 0 := by norm_num
  rw [‚Üê (mul_inv_cancel nz).symm, one_mul]"
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.tendsto_Lp_of_tendsto_ae,tendsto_Lp_of_tendsto_ae,ff33d25c791a3fac407c782b49018fcb63700d0d,":= by
  rw [ENNReal.tendsto_atTop_zero]
  intro Œµ hŒµ
  by_cases h : Œµ < ‚àû; swap
  ¬∑ rw [not_lt, top_le_iff] at h
    exact ‚ü®0, fun n _ => by simp [h]‚ü©
  by_cases hŒº : Œº = 0
  ¬∑ exact ‚ü®0, fun n _ => by simp [hŒº]‚ü©
  have hŒµ' : 0 < Œµ.toReal / 3 :=
    div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (by norm_num)
  have hdivp : 0 ‚â§ 1 / p.toReal := by
    refine' one_div_nonneg.2 _
    rw [‚Üê ENNReal.zero_toReal, ENNReal.toReal_le_toReal ENNReal.zero_ne_top hp']
    exact le_trans (zero_le _) hp
  have hpow : 0 < measureUnivNNReal Œº ^ (1 / p.toReal) :=
    Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
  obtain ‚ü®Œ¥‚ÇÅ, hŒ¥‚ÇÅ, hsnorm‚ÇÅ‚ü© := hui hŒµ'
  obtain ‚ü®Œ¥‚ÇÇ, hŒ¥‚ÇÇ, hsnorm‚ÇÇ‚ü© := hg'.snorm_indicator_le Œº hp hp' hŒµ'
  obtain ‚ü®t, htm, ht‚ÇÅ, ht‚ÇÇ‚ü© := tendstoUniformlyOn_of_ae_tendsto' hf hg hfg (lt_min hŒ¥‚ÇÅ hŒ¥‚ÇÇ)
  rw [Metric.tendstoUniformlyOn_iff] at ht‚ÇÇ
  specialize ht‚ÇÇ (Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    (div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (mul_pos (by norm_num) hpow))
  obtain ‚ü®N, hN‚ü© := eventually_atTop.1 ht‚ÇÇ; clear ht‚ÇÇ
  refine' ‚ü®N, fun n hn => _‚ü©
  rw [‚Üê t.indicator_self_add_compl (f n - g)]
  refine' le_trans (snorm_add_le (((hf n).sub hg).indicator htm).aestronglyMeasurable
    (((hf n).sub hg).indicator htm.compl).aestronglyMeasurable hp) _
  rw [sub_eq_add_neg, Set.indicator_add' t, Set.indicator_neg']
  refine' le_trans (add_le_add_right (snorm_add_le ((hf n).indicator htm).aestronglyMeasurable
    (hg.indicator htm).neg.aestronglyMeasurable hp) _) _
  have hnf : snorm (t.indicator (f n)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine' hsnorm‚ÇÅ n t htm (le_trans ht‚ÇÅ _)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÅ.le]
    exact min_le_left _ _
  have hng : snorm (t.indicator g) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine' hsnorm‚ÇÇ t htm (le_trans ht‚ÇÅ _)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÇ.le]
    exact min_le_right _ _
  have hlt : snorm (t·∂ú.indicator (f n - g)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    specialize hN n hn
    have : 0 ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)) := by positivity
    have := snorm_sub_le_of_dist_bdd Œº hp' htm.compl this fun x hx =>
      (dist_comm (g x) (f n x) ‚ñ∏ (hN x hx).le :
        dist (f n x) (g x) ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    refine' le_trans this _
    rw [div_mul_eq_div_mul_one_div, ‚Üê ENNReal.ofReal_toReal (measure_lt_top Œº t·∂ú).ne,
      ENNReal.ofReal_rpow_of_nonneg ENNReal.toReal_nonneg hdivp, ‚Üê ENNReal.ofReal_mul, mul_assoc]
    ¬∑ refine' ENNReal.ofReal_le_ofReal (mul_le_of_le_one_right hŒµ'.le _)
      rw [mul_comm, mul_one_div, div_le_one]
      ¬∑ refine' Real.rpow_le_rpow ENNReal.toReal_nonneg
          (ENNReal.toReal_le_of_le_ofReal (measureUnivNNReal_pos hŒº).le _) hdivp
        rw [ENNReal.ofReal_coe_nnreal, coe_measureUnivNNReal]
        exact measure_mono (Set.subset_univ _)
      ¬∑ exact Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
    ¬∑ positivity
  have : ENNReal.ofReal (Œµ.toReal / 3) = Œµ / 3 := by
    rw [ENNReal.ofReal_div_of_pos (show (0 : ‚Ñù) < 3 by norm_num), ENNReal.ofReal_toReal h.ne]
    simp
  rw [this] at hnf hng hlt
  rw [snorm_neg, ‚Üê ENNReal.add_thirds Œµ, ‚Üê sub_eq_add_neg]
  exact add_le_add_three hnf hng hlt","error:  application type mismatch
  Mem‚Ñíp.snorm_indicator_le Œº
argument
  Œº
has type
  Measure Œ± : Type u_1
but is expected to have type
  1 ‚â§ ?m.125901 : Prop
error:  rcases tactic failed: x‚úù : ?m.127562 is not an inductive datatype","theorem tendsto_Lp_of_tendsto_ae_of_meas [IsFiniteMeasure Œº] (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû)
    {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (hf : ‚àÄ n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g)
    (hg' : Mem‚Ñíp g p Œº) (hui : UnifIntegrable f p Œº)
    (hfg : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (g x))) :
    Tendsto (fun n => snorm (f n - g) p Œº) atTop (ùìù 0) ",":= by
  rw [ENNReal.tendsto_atTop_zero]
  intro Œµ hŒµ
  by_cases h : Œµ < ‚àû; swap
  ¬∑ rw [not_lt, top_le_iff] at h
    exact ‚ü®0, fun n _ => by simp [h]‚ü©
  by_cases hŒº : Œº = 0
  ¬∑ exact ‚ü®0, fun n _ => by simp [hŒº]‚ü©
  have hŒµ' : 0 < Œµ.toReal / 3 :=
    div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (by norm_num)
  have hdivp : 0 ‚â§ 1 / p.toReal := by
    refine one_div_nonneg.2 ?_
    rw [‚Üê ENNReal.zero_toReal, ENNReal.toReal_le_toReal ENNReal.zero_ne_top hp']
    exact le_trans (zero_le _) hp
  have hpow : 0 < measureUnivNNReal Œº ^ (1 / p.toReal) :=
    Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
  obtain ‚ü®Œ¥‚ÇÅ, hŒ¥‚ÇÅ, hsnorm‚ÇÅ‚ü© := hui hŒµ'
  obtain ‚ü®Œ¥‚ÇÇ, hŒ¥‚ÇÇ, hsnorm‚ÇÇ‚ü© := hg'.snorm_indicator_le hp hp' hŒµ'
  obtain ‚ü®t, htm, ht‚ÇÅ, ht‚ÇÇ‚ü© := tendstoUniformlyOn_of_ae_tendsto' hf hg hfg (lt_min hŒ¥‚ÇÅ hŒ¥‚ÇÇ)
  rw [Metric.tendstoUniformlyOn_iff] at ht‚ÇÇ
  specialize ht‚ÇÇ (Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    (div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (mul_pos (by norm_num) hpow))
  obtain ‚ü®N, hN‚ü© := eventually_atTop.1 ht‚ÇÇ; clear ht‚ÇÇ
  refine ‚ü®N, fun n hn => ?_‚ü©
  rw [‚Üê t.indicator_self_add_compl (f n - g)]
  refine le_trans (snorm_add_le (((hf n).sub hg).indicator htm).aestronglyMeasurable
    (((hf n).sub hg).indicator htm.compl).aestronglyMeasurable hp) ?_
  rw [sub_eq_add_neg, Set.indicator_add' t, Set.indicator_neg']
  refine le_trans (add_le_add_right (snorm_add_le ((hf n).indicator htm).aestronglyMeasurable
    (hg.indicator htm).neg.aestronglyMeasurable hp) _) ?_
  have hnf : snorm (t.indicator (f n)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine hsnorm‚ÇÅ n t htm (le_trans ht‚ÇÅ ?_)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÅ.le]
    exact min_le_left _ _
  have hng : snorm (t.indicator g) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine hsnorm‚ÇÇ t htm (le_trans ht‚ÇÅ ?_)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÇ.le]
    exact min_le_right _ _
  have hlt : snorm (t·∂ú.indicator (f n - g)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    specialize hN n hn
    have : 0 ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)) := by positivity
    have := snorm_sub_le_of_dist_bdd Œº hp' htm.compl this fun x hx =>
      (dist_comm (g x) (f n x) ‚ñ∏ (hN x hx).le :
        dist (f n x) (g x) ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    refine le_trans this ?_
    rw [div_mul_eq_div_mul_one_div, ‚Üê ENNReal.ofReal_toReal (measure_lt_top Œº t·∂ú).ne,
      ENNReal.ofReal_rpow_of_nonneg ENNReal.toReal_nonneg hdivp, ‚Üê ENNReal.ofReal_mul, mul_assoc]
    ¬∑ refine ENNReal.ofReal_le_ofReal (mul_le_of_le_one_right hŒµ'.le ?_)
      rw [mul_comm, mul_one_div, div_le_one]
      ¬∑ refine Real.rpow_le_rpow ENNReal.toReal_nonneg
          (ENNReal.toReal_le_of_le_ofReal (measureUnivNNReal_pos hŒº).le ?_) hdivp
        rw [ENNReal.ofReal_coe_nnreal, coe_measureUnivNNReal]
        exact measure_mono (Set.subset_univ _)
      ¬∑ exact Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
    ¬∑ positivity
  have : ENNReal.ofReal (Œµ.toReal / 3) = Œµ / 3 := by
    rw [ENNReal.ofReal_div_of_pos (show (0 : ‚Ñù) < 3 by norm_num), ENNReal.ofReal_toReal h.ne]
    simp
  rw [this] at hnf hng hlt
  rw [snorm_neg, ‚Üê ENNReal.add_thirds Œµ, ‚Üê sub_eq_add_neg]
  exact add_le_add_three hnf hng hlt"
Mathlib/Algebra/Group/Hom/Defs.lean,MonoidHom.toMulHom_injective,MonoidHom.toMulHom_injective,5a4d524ac087a31fc20d0920ca4c9941545220a4,":=
  fun _ _ h => MonoidHom.ext <| MulHom.ext_iff.mp h",error:  unknown constant 'MulHom.ext_iff.mp',"theorem MonoidHom.toMulHom_injective [MulOneClass M] [MulOneClass N] :
    Function.Injective (MonoidHom.toMulHom : (M ‚Üí* N) ‚Üí M ‚Üí‚Çô* N) ",":=
  Function.Injective.of_comp (f := DFunLike.coe) DFunLike.coe_injective"
Mathlib/Analysis/Convex/Cone/Proper.lean,ProperCone.dual_dual,dual_dual,f5f44c598718f820c1ef4a18227ccd07887d9961,":=
  ProperCone.ext' <|
    (K : ConvexCone ‚Ñù E).innerDualCone_of_innerDualCone_eq_self K.nonempty' K.isClosed",error:  unknown constant 'ProperCone.ext'',theorem dual_dual (K : ProperCone ‚Ñù E) : K.dual.dual = K ,":=
  ProperCone.toPointedCone_injective <| PointedCone.toConvexCone_injective <|
    (K : ConvexCone ‚Ñù E).innerDualCone_of_innerDualCone_eq_self K.nonempty K.isClosed"
Mathlib/Algebra/Module/PID.lean,Module.torsion_by_prime_power_decomposition,torsion_by_prime_power_decomposition,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ simp only [Nat.zero_eq] at *
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
    clear IH
    ¬∑ have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine' ‚ü®x, h0, _‚ü©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'",error:  simp made no progress,"theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ‚àÉ (d : ‚Ñï) (k : Fin d ‚Üí ‚Ñï), Nonempty <| N ‚âÉ‚Çó[R] ‚®Å i : Fin d, R ‚ß∏ R ‚àô p ^ (k i : ‚Ñï) ",":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    ¬∑ obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
      clear IH
      have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ‚ü®x, h0, ?_‚ü©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'"
Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean,CategoryTheory.Pretriangulated.Triangle.mor‚ÇÉ_eq_zero_iff_epi‚ÇÇ,mor‚ÇÉ_eq_zero_iff_epi‚ÇÇ,8535b08ef59bcdb8a9d09a473f4b6c583f54aef0,":= by
  constructor
  ¬∑ intro h
    rw [epi_iff_cancel_zero]
    intro X g hg
    obtain ‚ü®f, rfl‚ü© := yoneda_exact‚ÇÉ T hT g hg
    rw [h, zero_comp]
  ¬∑ intro
    rw [‚Üê cancel_epi T.mor‚ÇÇ, comp_dist_triangle_mor_zero‚ÇÇ‚ÇÉ _ hT, comp_zero]","error:  unknown identifier 'comp_dist_triangle_mor_zero‚ÇÇ‚ÇÉ'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.83351
case mpr
C : Type u
inst‚úù‚Å¥ : Category.{v, u} C
inst‚úù¬≥ : HasZeroObject C
inst‚úù¬≤ : HasShift C ‚Ñ§
inst‚úù¬π : Preadditive C
inst‚úù : ‚àÄ (n : ‚Ñ§), (CategoryTheory.shiftFunctor C n).Additive
hC : Pretriangulated C
T : Triangle C
hT : T ‚àà distinguishedTriangles
a‚úù : Epi T.mor‚ÇÇ
‚ä¢ T.mor‚ÇÇ ‚â´ T.mor‚ÇÉ = T.mor‚ÇÇ ‚â´ 0",lemma mor‚ÇÉ_eq_zero_iff_epi‚ÇÇ : T.mor‚ÇÉ = 0 ‚Üî Epi T.mor‚ÇÇ ,":= by
  constructor
  ¬∑ intro h
    rw [epi_iff_cancel_zero]
    intro X g hg
    obtain ‚ü®f, rfl‚ü© := yoneda_exact‚ÇÉ T hT g hg
    rw [h, zero_comp]
  ¬∑ intro
    rw [‚Üê cancel_epi T.mor‚ÇÇ, comp_distTriang_mor_zero‚ÇÇ‚ÇÉ _ hT, comp_zero]"
Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean,dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt,dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt,0f24aee7da46f85fee5cacc716172444ce31e582,":= by
  letI := B.finiteDimensional
  let P := minpoly R B.gen
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  have finrank_K_L : FiniteDimensional.finrank K L = B.dim := B.finrank
  have deg_K_P : (minpoly K B.gen).natDegree = B.dim := B.natDegree_minpoly
  have deg_R_P : P.natDegree = B.dim := by
    rw [‚Üê deg_K_P, minpoly.isIntegrallyClosed_eq_field_fractions' K hBint,
      (minpoly.monic hBint).natDegree_map (algebraMap R K)]
  choose! f hf using
    hei.isWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
      (minpoly.monic hBint)
  simp only [(minpoly.monic hBint).natDegree_map, deg_R_P] at hf
  suffices
      p ^ n.succ ‚à£ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n) by
    have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
      hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
    refine @Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd R _ _ _ _ n hp (?_ : _ ‚à£ _) hndiv
    convert (IsUnit.dvd_mul_right ‚ü®(-1) ^ (n.succ * n), rfl‚ü©).mpr this using 1
    push_cast
    ring_nf
    rw [mul_comm _ 2, pow_mul, neg_one_sq, one_pow, mul_one]
  have aux : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0, B.dim ‚â§ i + n := by
    intro i hi
    simp only [mem_range, mem_erase] at hi
    rw [hn]
    exact le_add_pred_of_pos _ hi.1
  have hintsum :
    IsIntegral R
      (z * B.gen ^ n - ‚àë x : ‚Ñï in (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ f (x + n)) := by
    refine
      isIntegral_sub (isIntegral_mul hzint (IsIntegral.pow hBint _))
        (IsIntegral.sum _ fun i hi => isIntegral_smul _ ?_)
    exact adjoin_le_integralClosure hBint (hf _ (aux i hi)).1
  obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
  use r
  apply IsFractionRing.injective R K
  simp only [_root_.map_mul, _root_.map_pow, _root_.map_neg, _root_.map_one]
  calc
    _ = norm K (Q.coeff 0 ‚Ä¢ B.gen ^ n) := ?_
    _ = norm K (p ‚Ä¢ (z * B.gen ^ n) -
          ‚àë x : ‚Ñï in (range (Q.natDegree + 1)).erase 0, p ‚Ä¢ Q.coeff x ‚Ä¢ f (x + n)) :=
        (congr_arg (norm K) (eq_sub_of_add_eq ?_))
    _ = _ := ?_
  ¬∑ simp only [Algebra.smul_def, algebraMap_apply R K L, Algebra.norm_algebraMap, _root_.map_mul,
      _root_.map_pow, finrank_K_L, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map, ‚Üê hn]
    ring
  swap
  ¬∑ simp_rw [‚Üê smul_sum, ‚Üê smul_sub, Algebra.smul_def p, algebraMap_apply R K L, _root_.map_mul,
      Algebra.norm_algebraMap, finrank_K_L, hr, ‚Üê hn]
  calc
    _ = (Q.coeff 0 ‚Ä¢ ‚Üë1 + ‚àë x : ‚Ñï in (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) *
          B.gen ^ n := ?_
    _ = (Q.coeff 0 ‚Ä¢ B.gen ^ 0 +
        ‚àë x : ‚Ñï in (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) * B.gen ^ n :=
      by rw [_root_.pow_zero]
    _ = aeval B.gen Q * B.gen ^ n := ?_
    _ = _ := by rw [hQ, Algebra.smul_mul_assoc]
  ¬∑ have : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0,
        Q.coeff i ‚Ä¢ (B.gen ^ i * B.gen ^ n) = p ‚Ä¢ Q.coeff i ‚Ä¢ f (i + n) := by
      intro i hi
      rw [‚Üê pow_add, ‚Üê (hf _ (aux i hi)).2, ‚Üê Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]
    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]
  ¬∑ rw [aeval_eq_sum_range,
      Finset.add_sum_erase (range (Q.natDegree + 1)) fun i => Q.coeff i ‚Ä¢ B.gen ^ i]
    simp","warning:  `PowerBasis.finiteDimensional` has been deprecated, use `PowerBasis.finite` instead
error:  unknown identifier 'isIntegral_sub'
error:  no goals to be solved","theorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} {Q : R[X]} (hQ : aeval B.gen Q = p ‚Ä¢ z)
    (hzint : IsIntegral R z) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) : p ‚à£ Q.coeff 0 ",":= by
  letI := B.finite
  let P := minpoly R B.gen
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  have finrank_K_L : FiniteDimensional.finrank K L = B.dim := B.finrank
  have deg_K_P : (minpoly K B.gen).natDegree = B.dim := B.natDegree_minpoly
  have deg_R_P : P.natDegree = B.dim := by
    rw [‚Üê deg_K_P, minpoly.isIntegrallyClosed_eq_field_fractions' K hBint,
      (minpoly.monic hBint).natDegree_map (algebraMap R K)]
  choose! f hf using
    hei.isWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
      (minpoly.monic hBint)
  simp only [(minpoly.monic hBint).natDegree_map, deg_R_P] at hf
  suffices
      p ^ n.succ ‚à£ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n) by
    have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
      hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
    refine @Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd R _ _ _ _ n hp (?_ : _ ‚à£ _) hndiv
    convert (IsUnit.dvd_mul_right ‚ü®(-1) ^ (n.succ * n), rfl‚ü©).mpr this using 1
    push_cast
    ring_nf
    rw [mul_comm _ 2, pow_mul, neg_one_sq, one_pow, mul_one]
  have aux : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0, B.dim ‚â§ i + n := by
    intro i hi
    simp only [mem_range, mem_erase] at hi
    rw [hn]
    exact le_add_pred_of_pos _ hi.1
  have hintsum :
    IsIntegral R
      (z * B.gen ^ n - ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ f (x + n)) := by
    refine (hzint.mul (hBint.pow _)).sub (.sum _ fun i hi => .smul _ ?_)
    exact adjoin_le_integralClosure hBint (hf _ (aux i hi)).1
  obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
  use r
  apply IsFractionRing.injective R K
  simp only [_root_.map_mul, _root_.map_pow, _root_.map_neg, _root_.map_one]
  calc
    _ = norm K (Q.coeff 0 ‚Ä¢ B.gen ^ n) := ?_
    _ = norm K (p ‚Ä¢ (z * B.gen ^ n) -
          ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, p ‚Ä¢ Q.coeff x ‚Ä¢ f (x + n)) :=
        (congr_arg (norm K) (eq_sub_of_add_eq ?_))
    _ = _ := ?_
  ¬∑ simp only [Algebra.smul_def, algebraMap_apply R K L, Algebra.norm_algebraMap, _root_.map_mul,
      _root_.map_pow, finrank_K_L, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map, ‚Üê hn]
    ring
  swap
  ¬∑ simp_rw [‚Üê smul_sum, ‚Üê smul_sub, Algebra.smul_def p, algebraMap_apply R K L, _root_.map_mul,
      Algebra.norm_algebraMap, finrank_K_L, hr, ‚Üê hn]
  calc
    _ = (Q.coeff 0 ‚Ä¢ ‚Üë1 + ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) *
          B.gen ^ n := ?_
    _ = (Q.coeff 0 ‚Ä¢ B.gen ^ 0 +
        ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) * B.gen ^ n := by
      rw [_root_.pow_zero]
    _ = aeval B.gen Q * B.gen ^ n := ?_
    _ = _ := by rw [hQ, Algebra.smul_mul_assoc]
  ¬∑ have : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0,
        Q.coeff i ‚Ä¢ (B.gen ^ i * B.gen ^ n) = p ‚Ä¢ Q.coeff i ‚Ä¢ f (i + n) := by
      intro i hi
      rw [‚Üê pow_add, ‚Üê (hf _ (aux i hi)).2, ‚Üê Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]
    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]
  ¬∑ rw [aeval_eq_sum_range,
      Finset.add_sum_erase (range (Q.natDegree + 1)) fun i => Q.coeff i ‚Ä¢ B.gen ^ i]
    simp"
Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean,CategoryTheory.Limits.colimitLimitToLimitColimit_surjective,colimitLimitToLimitColimit_surjective,7ef0452b73878a90f60c80b3eed820f424b52005,":= by
  classical
    intro x
    have z := fun j => jointly_surjective'.{v, v} (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply.{v, v}, t, FunctorToTypes.map_comp_apply, Colimit.w_apply.{v, v}, e,
        ‚Üê Limit.w_apply' f, ‚Üê e]
      simp
    simp_rw [colimit_eq_iff.{v, v}] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (by
            rw [Finset.mem_biUnion]
            refine' ‚ü®j, Finset.mem_univ j, _‚ü©
            rw [Finset.mem_biUnion]
            refine' ‚ü®j', Finset.mem_univ j', _‚ü©
            rw [Finset.mem_image]
            refine' ‚ü®f, Finset.mem_univ _, _‚ü©
            rfl))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      exact k'O
      swap
      ¬∑ rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÅ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÇ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®f, Finset.mem_univ _, _‚ü©
        simp only [true_or_iff, eq_self_iff_true, and_self_iff, Finset.mem_insert, heq_iff_eq]
      ¬∑ rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÉ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÑ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®f', Finset.mem_univ _, _‚ü©
        simp only [eq_self_iff_true, or_true_iff, and_self_iff, Finset.mem_insert,
          Finset.mem_singleton, heq_iff_eq]
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk.{v, v}
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) :=
            by rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) :=
            by rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) :=
            by rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext'
      intro j
      simp only [id.def, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff.{v, v}, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine' ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), _‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","error:  application type mismatch
  jointly_surjective' (limit.œÄ (curry.obj F ‚ãô colim) j x)
argument
  limit.œÄ (curry.obj F ‚ãô colim) j x
has type
  (curry.obj F ‚ãô colim).obj j : Type v
but is expected to have type
  colimit ?m.27488 : Type v
error:  unsolved goals
J : Type u‚ÇÅ
K : Type u‚ÇÇ
inst‚úù‚Å¥ : SmallCategory J
inst‚úù¬≥ : Category.{v‚ÇÇ, u‚ÇÇ} K
inst‚úù¬≤ : Small.{v, u‚ÇÇ} K
inst‚úù¬π : FinCategory J
F : J √ó K ‚•§ Type v
inst‚úù : IsFiltered K
x : limit (curry.obj F ‚ãô colim)
‚ä¢ ‚àÉ a, colimitLimitToLimitColimit F a = x","theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) ",":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ‚Üê Limit.w_apply.{u‚ÇÅ, v, u‚ÇÅ} f, ‚Üê e]
      simp only [Functor.comp_map, Types.Colimit.Œπ_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact k'O
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) := by
            rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) := by
            rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext
      intro j
      simp only [id, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]"
Mathlib/Topology/UniformSpace/Cauchy.lean,UniformSpace.secondCountable_of_separable,secondCountable_of_separable,30e974bdfa5857c1b068086dfe767f91b6240c51,":= by
  rcases exists_countable_dense Œ± with ‚ü®s, hsc, hsd‚ü©
  obtain
    ‚ü®t : ‚Ñï ‚Üí Set (Œ± √ó Œ±), hto : ‚àÄ i : ‚Ñï, t i ‚àà (ùì§ Œ±).sets ‚àß IsOpen (t i) ‚àß SymmetricRel (t i),
      h_basis : (ùì§ Œ±).HasAntitoneBasis t‚ü© :=
    (@uniformity_hasBasis_open_symmetric Œ± _).exists_antitone_subbasis
  choose ht_mem hto hts using hto
  refine' ‚ü®‚ü®‚ãÉ x ‚àà s, range fun k => ball x (t k), hsc.biUnion fun x _ => countable_range _, _‚ü©‚ü©
  refine' (isTopologicalBasis_of_open_of_nhds _ _).eq_generateFrom
  ¬∑ simp only [mem_iUnion‚ÇÇ, mem_range]
    rintro _ ‚ü®x, _, k, rfl‚ü©
    exact isOpen_ball x (hto k)
  ¬∑ intro x V hxV hVo
    simp only [mem_iUnion‚ÇÇ, mem_range, exists_prop]
    rcases UniformSpace.mem_nhds_iff.1 (IsOpen.mem_nhds hVo hxV) with ‚ü®U, hU, hUV‚ü©
    rcases comp_symm_of_uniformity hU with ‚ü®U', hU', _, hUU'‚ü©
    rcases h_basis.toHasBasis.mem_iff.1 hU' with ‚ü®k, -, hk‚ü©
    rcases hsd.inter_open_nonempty (ball x <| t k) (isOpen_ball x (hto k))
        ‚ü®x, UniformSpace.mem_ball_self _ (ht_mem k)‚ü© with
      ‚ü®y, hxy, hys‚ü©
    refine' ‚ü®_, ‚ü®y, hys, k, rfl‚ü©, (hts k).subset hxy, fun z hz => _‚ü©
    exact hUV (ball_subset_of_comp_subset (hk hxy) hUU' (hk hz))","error:  unknown identifier 'isTopologicalBasis_of_open_of_nhds'
error:  no goals to be solved",theorem secondCountable_of_separable [SeparableSpace Œ±] : SecondCountableTopology Œ± ,":= by
  rcases exists_countable_dense Œ± with ‚ü®s, hsc, hsd‚ü©
  obtain
    ‚ü®t : ‚Ñï ‚Üí Set (Œ± √ó Œ±), hto : ‚àÄ i : ‚Ñï, t i ‚àà (ùì§ Œ±).sets ‚àß IsOpen (t i) ‚àß SymmetricRel (t i),
      h_basis : (ùì§ Œ±).HasAntitoneBasis t‚ü© :=
    (@uniformity_hasBasis_open_symmetric Œ± _).exists_antitone_subbasis
  choose ht_mem hto hts using hto
  refine ‚ü®‚ü®‚ãÉ x ‚àà s, range fun k => ball x (t k), hsc.biUnion fun x _ => countable_range _, ?_‚ü©‚ü©
  refine (isTopologicalBasis_of_isOpen_of_nhds ?_ ?_).eq_generateFrom
  ¬∑ simp only [mem_iUnion‚ÇÇ, mem_range]
    rintro _ ‚ü®x, _, k, rfl‚ü©
    exact isOpen_ball x (hto k)
  ¬∑ intro x V hxV hVo
    simp only [mem_iUnion‚ÇÇ, mem_range, exists_prop]
    rcases UniformSpace.mem_nhds_iff.1 (IsOpen.mem_nhds hVo hxV) with ‚ü®U, hU, hUV‚ü©
    rcases comp_symm_of_uniformity hU with ‚ü®U', hU', _, hUU'‚ü©
    rcases h_basis.toHasBasis.mem_iff.1 hU' with ‚ü®k, -, hk‚ü©
    rcases hsd.inter_open_nonempty (ball x <| t k) (isOpen_ball x (hto k))
        ‚ü®x, UniformSpace.mem_ball_self _ (ht_mem k)‚ü© with
      ‚ü®y, hxy, hys‚ü©
    refine ‚ü®_, ‚ü®y, hys, k, rfl‚ü©, (hts k).subset hxy, fun z hz => ?_‚ü©
    exact hUV (ball_subset_of_comp_subset (hk hxy) hUU' (hk hz))"
Mathlib/Analysis/Convex/Combination.lean,Set.Finite.convexHull_eq_image,Set.Finite.convexHull_eq_image,9b142a34ca7f54087659561fbf3f33a84286fd96,":= by
  letI := hs.fintype
  rw [‚Üê convexHull_basis_eq_stdSimplex, ‚Üê LinearMap.convexHull_image, ‚Üê Set.range_comp]
  apply congr_arg
  simp_rw [Function.comp]
  convert Subtype.range_coe.symm
  simp [LinearMap.sum_apply, ite_smul, Finset.filter_eq, Finset.mem_univ]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.568565 ‚Üí+* ?m.568566) ‚Üí
    (M : Type ?u.568562) ‚Üí
      (M‚ÇÇ : Type ?u.568561) ‚Üí
        [inst : AddCommMonoid M] ‚Üí
          [inst_1 : AddCommMonoid M‚ÇÇ] ‚Üí
            [inst : Module ?m.568565 M] ‚Üí [inst : Module ?m.568566 M‚ÇÇ] ‚Üí Type (max ?u.568562 ?u.568561)
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.568634
R : Type u_1
R' : Type u_2
E : Type u_3
F : Type u_4
Œπ : Type u_5
Œπ' : Type u_6
Œ± : Type u_7
inst‚úù‚Åπ : LinearOrderedField R
inst‚úù‚Å∏ : LinearOrderedField R'
inst‚úù‚Å∑ : AddCommGroup E
inst‚úù‚Å∂ : AddCommGroup F
inst‚úù‚Åµ : LinearOrderedAddCommGroup Œ±
inst‚úù‚Å¥ : Module R E
inst‚úù¬≥ : Module R F
inst‚úù¬≤ : Module R Œ±
inst‚úù¬π : OrderedSMul R Œ±
s‚úù : Set E
i j : Œπ
c : R
t : Finset Œπ
w : Œπ ‚Üí R
z : Œπ ‚Üí E
inst‚úù : Fintype Œπ
f : Œπ ‚Üí R
s : Set E
hs : s.Finite
this : Fintype ‚Üës := hs.fintype
‚ä¢ (convexHull R) s =
    ‚áë(‚àë x : ‚Üës, (LinearMap.proj x).smulRight ‚Üëx) '' (convexHull R) (range fun i j ‚Ü¶ if i = j then 1 else 0)","theorem Set.Finite.convexHull_eq_image {s : Set E} (hs : s.Finite) : convexHull R s =
    haveI := hs.fintype
    (‚áë(‚àë x : s, (@LinearMap.proj R s _ (fun _ => R) _ _ x).smulRight x.1)) '' stdSimplex R s ",":= by
  letI := hs.fintype
  rw [‚Üê convexHull_basis_eq_stdSimplex, LinearMap.image_convexHull, ‚Üê Set.range_comp]
  apply congr_arg
  simp_rw [Function.comp]
  convert Subtype.range_coe.symm
  simp [LinearMap.sum_apply, ite_smul, Finset.filter_eq, Finset.mem_univ]"
Mathlib/Probability/Process/Filtration.lean,MeasureTheory.Filtration.filtrationOfSet_eq_natural,filtrationOfSet_eq_natural,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  simp only [filtrationOfSet, natural, measurableSpace_iSup_eq, exists_prop, mk.injEq]
  ext1 i
  refine le_antisymm (generateFrom_le ?_) (generateFrom_le? _)
  ¬∑ rintro _ ‚ü®j, hij, rfl‚ü©
    refine measurableSet_generateFrom ‚ü®j, measurableSet_generateFrom ‚ü®hij, ?_‚ü©‚ü©
    rw [comap_eq_generateFrom]
    refine measurableSet_generateFrom ‚ü®{1}, measurableSet_singleton 1, ?_‚ü©
    ext x
    simp [Set.indicator_const_preimage_eq_union]
  ¬∑ rintro t ‚ü®n, ht‚ü©
    suffices MeasurableSpace.generateFrom {t | n ‚â§ i ‚àß
      MeasurableSet[MeasurableSpace.comap ((s n).indicator (fun _ => 1 : Œ© ‚Üí Œ≤)) mŒ≤] t} ‚â§
        MeasurableSpace.generateFrom {t | ‚àÉ (j : Œπ), j ‚â§ i ‚àß s j = t} by
      exact this _ ht
    refine generateFrom_le ?_
    rintro t ‚ü®hn, u, _, hu'‚ü©
    obtain heq | heq | heq | heq := Set.indicator_const_preimage (s n) u (1 : Œ≤)
    on_goal 4 => rw [Set.mem_singleton_iff] at heq
    all_goals rw [heq] at hu'; rw [‚Üê hu']
    exacts [MeasurableSet.univ, measurableSet_generateFrom ‚ü®n, hn, rfl‚ü©,
      MeasurableSet.compl (measurableSet_generateFrom ‚ü®n, hn, rfl‚ü©), measurableSet_empty _]","error:  unknown identifier 'generateFrom_le?'
error:  no goals to be solved","theorem filtrationOfSet_eq_natural [MulZeroOneClass Œ≤] [Nontrivial Œ≤] {s : Œπ ‚Üí Set Œ©}
    (hsm : ‚àÄ i, MeasurableSet[m] (s i)) :
    filtrationOfSet hsm = natural (fun i => (s i).indicator (fun _ => 1 : Œ© ‚Üí Œ≤)) fun i =>
      stronglyMeasurable_one.indicator (hsm i) ",":= by
  simp only [filtrationOfSet, natural, measurableSpace_iSup_eq, exists_prop, mk.injEq]
  ext1 i
  refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_)
  ¬∑ rintro _ ‚ü®j, hij, rfl‚ü©
    refine measurableSet_generateFrom ‚ü®j, measurableSet_generateFrom ‚ü®hij, ?_‚ü©‚ü©
    rw [comap_eq_generateFrom]
    refine measurableSet_generateFrom ‚ü®{1}, measurableSet_singleton 1, ?_‚ü©
    ext x
    simp [Set.indicator_const_preimage_eq_union]
  ¬∑ rintro t ‚ü®n, ht‚ü©
    suffices MeasurableSpace.generateFrom {t | n ‚â§ i ‚àß
      MeasurableSet[MeasurableSpace.comap ((s n).indicator (fun _ => 1 : Œ© ‚Üí Œ≤)) mŒ≤] t} ‚â§
        MeasurableSpace.generateFrom {t | ‚àÉ (j : Œπ), j ‚â§ i ‚àß s j = t} by
      exact this _ ht
    refine generateFrom_le ?_
    rintro t ‚ü®hn, u, _, hu'‚ü©
    obtain heq | heq | heq | heq := Set.indicator_const_preimage (s n) u (1 : Œ≤)
    on_goal 4 => rw [Set.mem_singleton_iff] at heq
    all_goals rw [heq] at hu'; rw [‚Üê hu']
    exacts [MeasurableSet.univ, measurableSet_generateFrom ‚ü®n, hn, rfl‚ü©,
      MeasurableSet.compl (measurableSet_generateFrom ‚ü®n, hn, rfl‚ü©), measurableSet_empty _]"
Mathlib/NumberTheory/Padics/PadicVal.lean,Nat.log_ne_padicValNat_succ,Nat.log_ne_padicValNat_succ,84f6d10f9a51f8c6472ec85f7cb1f39056781a29,":= by
  rw [Ne, log_eq_iff (by simp [hn])]
  rintro ‚ü®h1, h2‚ü©
  rw [‚Üê lt_add_one_iff, ‚Üê mul_one (2 ^ _)] at h1
  rw [‚Üê add_one_le_iff, pow_succ] at h2
  refine' not_dvd_of_between_consec_multiples h1 (lt_of_le_of_ne' h2 _) pow_padicValNat_dvd
  exact pow_succ_padicValNat_not_dvd (p := 2) n.succ_ne_zero ‚àò dvd_of_eq","error:  unknown identifier 'lt_add_one_iff'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.65770
case intro
p n : ‚Ñï
hn : n ‚â† 0
h1 : 2 ^ padicValNat 2 (n + 1) ‚â§ n
h2 : n < 2 ^ (padicValNat 2 (n + 1) + 1)
‚ä¢ False",lemma Nat.log_ne_padicValNat_succ {n : ‚Ñï} (hn : n ‚â† 0) : log 2 n ‚â† padicValNat 2 (n + 1) ,":= by
  rw [Ne, log_eq_iff (by simp [hn])]
  rintro ‚ü®h1, h2‚ü©
  rw [‚Üê Nat.lt_add_one_iff, ‚Üê mul_one (2 ^ _)] at h1
  rw [‚Üê add_one_le_iff, Nat.pow_succ] at h2
  refine not_dvd_of_between_consec_multiples h1 (lt_of_le_of_ne' h2 ?_) pow_padicValNat_dvd
  exact pow_succ_padicValNat_not_dvd (p := 2) n.succ_ne_zero ‚àò dvd_of_eq"
Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean,WeierstrassCurve.Jacobian.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,589c3bf0c57078fa2fc286439eaad37de0c2b369,":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp [nonsingular_iff, equation_iff] at hP hQ
  have hPx : P x ‚â† 0 := fun h => by simp [h] at hP; simp [hP] at hP
  have hQx : Q x ‚â† 0 := fun h => by simp [h] at hQ; simp [hQ] at hQ
  have hPy : P y ‚â† 0 := fun h => by simp [h] at hP; exact hPx <| pow_eq_zero hP.left.symm
  have hQy : Q y ‚â† 0 := fun h => by simp [h] at hQ; exact hQx <| pow_eq_zero hQ.left.symm
  use Units.mk0 _ <| mul_ne_zero (div_ne_zero hPy hPx) (div_ne_zero hQx hQy)
  simp [smul_fin3, mul_pow, div_pow]
  congr! 2
  ¬∑ 
    sorry
  ¬∑ 
    sorry","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ![P x, P y, P z]
R : Type u
inst‚úù¬π : CommRing R
W' : Jacobian R
F : Type v
inst‚úù : Field F
W : Jacobian F
P Q : Fin 3 ‚Üí F
hP : W.Nonsingular P
hQ : W.Nonsingular Q
hPz : P z = 0
hQz : Q z = 0
‚ä¢ P ‚âà Q","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  have hPx : IsUnit <| P x := isUnit_X_of_Z_eq_zero hP hPz
  have hPy : IsUnit <| P y := isUnit_Y_of_Z_eq_zero hP hPz
  have hQx : IsUnit <| Q x := isUnit_X_of_Z_eq_zero hQ hQz
  have hQy : IsUnit <| Q y := isUnit_Y_of_Z_eq_zero hQ hQz
  simp only [nonsingular_of_Z_eq_zero, equation_of_Z_eq_zero, hPz, hQz] at hP hQ
  use (hPy.unit / hPx.unit) * (hQx.unit / hQy.unit)
  simp only [Units.smul_def, smul_fin3, Units.val_mul, Units.val_div_eq_div_val, IsUnit.unit_spec,
    mul_pow, div_pow, hQz, mul_zero]
  conv_rhs => rw [‚Üê fin3_def P, hPz]
  congr! 2
  ¬∑ rw [hP.left, pow_succ, (hPx.pow 2).mul_div_cancel_left, hQ.left, pow_succ _ 2,
      (hQx.pow 2).div_mul_cancel_left, hQx.inv_mul_cancel_right]
  ¬∑ rw [‚Üê hP.left, pow_succ, (hPy.pow 2).mul_div_cancel_left, ‚Üê hQ.left, pow_succ _ 2,
      (hQy.pow 2).div_mul_cancel_left, hQy.inv_mul_cancel_right]"
Mathlib/Algebra/Module/PID.lean,Module.torsion_by_prime_power_decomposition,torsion_by_prime_power_decomposition,1cb1056b5a19f416d3fae3469d51eedb4f5b48cb,":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ simp only [Nat.zero_eq] at *
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ let _ : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
    clear IH
    ¬∑ have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine' ‚ü®x, h0, _‚ü©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'",error:  simp made no progress,"theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ‚àÉ (d : ‚Ñï) (k : Fin d ‚Üí ‚Ñï), Nonempty <| N ‚âÉ‚Çó[R] ‚®Å i : Fin d, R ‚ß∏ R ‚àô p ^ (k i : ‚Ñï) ",":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    ¬∑ obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
      clear IH
      have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ‚ü®x, h0, ?_‚ü©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'"
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow,discr_prime_pow,22e97510854d6906cc856e022d297bf9cf8c9b3a,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), succ_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2
      ¬∑ rwa [Ne.def, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]; ¬∑ norm_cast
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by linarith)] at this
      exact absurd (pow_eq_zero h) this","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case e_a.inr
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2‚úù : p = 2 ‚Üí k ‚â† 0
hp2 : ‚Üëp ‚â† 2
‚ä¢ (-1) ^ (‚Üëp ^ k * (‚Üëp - 1) * (‚Üëp ^ k * (‚Üëp - 1) - 1) / 2) = (-1) ^ (‚Üëp ^ k * (‚Üëp - 1) / 2)
error:  unsolved goals
case e_a
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2 : p = 2 ‚Üí k ‚â† 0
‚ä¢ (Algebra.norm K) ((aeval Œ∂) (derivative (cyclotomic (‚Üëp ^ (k + 1)) K))) = ‚Üë‚Üëp ^ (‚Üëp ^ k * ((‚Üëp - 1) * (k + 1) - 1))","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ‚Ñï).Prime]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1)) : ‚Ñï) K))
    (hk : p ^ (k + 1) ‚â† 2) : discr K (hŒ∂.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : ‚Ñï).totient / 2) * p ^ ((p : ‚Ñï) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this"
Mathlib/Data/List/NodupEquivFin.lean,List.sublist_iff_exists_fin_orderEmbedding_get_eq,sublist_iff_exists_fin_orderEmbedding_get_eq,b046c9e0f6ad05b9d218f3b9b832a04a3f9ae1d2,":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï}, i < l.length ‚Üí f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine' ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) _, _‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [get?_eq_get i.2, get?_eq_get (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine'
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          _,
        _‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ have := (f ‚ü®i, hi‚ü©).is_lt
        omega
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi","error:  type mismatch
  h‚úù
has type
  some l[‚Üëi] = l'[f ‚Üëi]? : Prop
but is expected to have type
  l[‚Üëi] = l'[f ‚Üëi] : Prop
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem sublist_iff_exists_fin_orderEmbedding_get_eq {l l' : List Œ±} :
    l <+ l' ‚Üî
      ‚àÉ f : Fin l.length ‚Ü™o Fin l'.length,
        ‚àÄ ix : Fin l.length, l.get ix = l'.get (f ix) ",":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï}, i < l.length ‚Üí f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) ?_, ?_‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [getElem?_eq_getElem i.2, getElem?_eq_getElem (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          ?_,
        ?_‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ have := (f ‚ü®i, hi‚ü©).is_lt
        omega
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi"
Mathlib/FieldTheory/IsAlgClosed/Spectrum.lean,spectrum.subset_polynomial_aeval,subset_polynomial_aeval,c7bd9bd10c613e1788107ba753e252f069560f87,":= by
  rintro _ ‚ü®k, hk, rfl‚ü©
  let q := C (eval k p) - p
  have hroot : IsRoot q k := by simp only [q, eval_C, eval_sub, sub_self, IsRoot.definition]
  rw [‚Üê mul_div_eq_iff_isRoot, ‚Üê neg_mul_neg, neg_sub] at hroot
  have aeval_q_eq : ‚Üë‚Çê (eval k p) - aeval a p = aeval a q := by
    simp only [q, aeval_C, AlgHom.map_sub, sub_left_inj]
  rw [mem_iff, aeval_q_eq, ‚Üê hroot, aeval_mul]
  have hcomm := (Commute.all (C k - X) (-(q / (X - C k)))).map (aeval a : ùïú[X] ‚Üí‚Çê[ùïú] A)
  apply mt fun h => (hcomm.isUnit_mul_iff.mp h).1
  simpa only [aeval_X, aeval_C, AlgHom.map_sub] using hk","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsRoot
has type
  ?m.21450[X] ‚Üí ?m.21450 ‚Üí Prop
error:  unsolved goals
ùïú : Type u
A : Type v
inst‚úù¬≤ : Field ùïú
inst‚úù¬π : Ring A
inst‚úù : Algebra ùïú A
a : A
p : ùïú[X]
k : ùïú
hk : k ‚àà œÉ a
q : ùïú[X] := C (eval k p) - p
‚ä¢ (C (eval k p) - p).IsRoot k",theorem subset_polynomial_aeval (a : A) (p : ùïú[X]) : (eval ¬∑ p) '' œÉ a ‚äÜ œÉ (aeval a p) ,":= by
  rintro _ ‚ü®k, hk, rfl‚ü©
  let q := C (eval k p) - p
  have hroot : IsRoot q k := by simp only [q, eval_C, eval_sub, sub_self, IsRoot.def]
  rw [‚Üê mul_div_eq_iff_isRoot, ‚Üê neg_mul_neg, neg_sub] at hroot
  have aeval_q_eq : ‚Üë‚Çê (eval k p) - aeval a p = aeval a q := by
    simp only [q, aeval_C, AlgHom.map_sub, sub_left_inj]
  rw [mem_iff, aeval_q_eq, ‚Üê hroot, aeval_mul]
  have hcomm := (Commute.all (C k - X) (-(q / (X - C k)))).map (aeval a : ùïú[X] ‚Üí‚Çê[ùïú] A)
  apply mt fun h => (hcomm.isUnit_mul_iff.mp h).1
  simpa only [aeval_X, aeval_C, AlgHom.map_sub] using hk"
Mathlib/Computability/AkraBazzi/AkraBazzi.lean,AkraBazziRecurrence.rpow_p_mul_one_add_smoothingFn_ge,rpow_p_mul_one_add_smoothingFn_ge,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  rw [Filter.eventually_all]
  intro i
  let q : ‚Ñù ‚Üí ‚Ñù := fun x => x ^ (p a b) * (1 + Œµ x)
  have h_diff_q : DifferentiableOn ‚Ñù q (Set.Ioi 1) := by
    refine DifferentiableOn.mul
        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)
        differentiableOn_one_add_smoothingFn
    rw [Set.mem_compl_singleton_iff]
    rw [Set.mem_Ioi] at hz
    exact ne_of_gt <| zero_lt_one.trans hz
  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc
    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + Œµ z) x := by rfl
          _ =·∂†[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + Œµ x)
              + x ^ (p a b) * deriv (fun z => 1 + Œµ z) x := by
                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'
                rw [deriv_mul] <;> aesop
          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by
                refine IsBigO.add ?left ?right
                case left => calc
                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + Œµ x))
                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + Œµ x) := by
                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)
                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=
                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO
                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]
                case right => calc
                  (fun x => x ^ (p a b) * deriv (fun z => 1 + Œµ z) x)
                      =O[atTop] (fun x => x ^ (p a b) * x‚Åª¬π) := by
                        exact IsBigO.mul (isBigO_refl _ _)
                          isLittleO_deriv_one_add_smoothingFn.isBigO
                    _ =·∂†[atTop] fun x => x ^ ((p a b) - 1) := by
                        filter_upwards [eventually_gt_atTop 0] with x hx
                        rw [‚Üê Real.rpow_neg_one, ‚Üê Real.rpow_add hx, ‚Üê sub_eq_add_neg]
  have h_main_norm : (fun (n : ‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ)
      ‚â§·∂†[atTop] fun (n : ‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ : = by
    refine IsLittleO.eventuallyLE ?_
    calc
      (fun (n : ‚Ñï) => q (r i n) - q (b i * n))
          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by
            exact R.isBigO_apply_r_sub_b q h_diff_q
              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i
        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by
            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)
        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by
            exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)
        _ =·∂†[atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by
            filter_upwards [eventually_ne_atTop 0] with n hn
            have hn' : (n : ‚Ñù) ‚â† 0 : = by positivity
            simp [‚Üê mul_div_assoc, ‚Üê Real.rpow_add_one hn']
        _ = fun (n : ‚Ñï) => (n : ‚Ñù) ^ (p a b) * (1 / (log n) ^ 2)  : = by simp_rw [mul_div, mul_one]
        _ =Œò[atTop] fun (n : ‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) : = by
            refine IsTheta.symm ?_
            simp_rw [mul_assoc]
            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)
            have := R.b_pos i; positivity
        _ =Œò[atTop] fun (n : ‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) : = by
            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)
                  <| R.isTheta_smoothingFn_sub_self i
  have h_main : (fun (n : ‚Ñï) => q (b i * n) - q (r i n))
      ‚â§·∂†[atTop] fun (n : ‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) : = by
    calc (fun (n : ‚Ñï) => q (b i * n) - q (r i n))
           ‚â§·∂†[atTop] fun (n : ‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ : = by
              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _
         _ ‚â§·∂†[atTop] fun (n : ‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ : =
              h_main_norm
         _ =·∂†[atTop] fun (n : ‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) : = by
              filter_upwards [eventually_gt_atTop ‚åà(b i)‚Åª¬π‚åâ‚Çä, eventually_gt_atTop 1] with n hn hn'
              refine norm_of_nonneg ?_
              have h‚ÇÅ := R.b_pos i
              have h‚ÇÇ : 0 ‚â§ Œµ (b i * n) - Œµ n := by
                refine sub_nonneg_of_le <|
                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le
                case n_gt_one =>
                  show 1 < (n : ‚Ñù)
                  rw [Nat.one_lt_cast]
                  exact hn'
                case bn_gt_one =>
                  calc 1 = b i * (b i)‚Åª¬π := by rw [mul_inv_cancel (by positivity)]
                      _ ‚â§ b i * ‚åà(b i)‚Åª¬π‚åâ‚Çä := by gcongr; exact Nat.le_ceil _
                      _ < b i * n := by gcongr; rw [Nat.cast_lt]; exact hn
                case le => calc b i * n ‚â§ 1 * n := by have := R.b_lt_one i; gcongr
                                        _ = n := by rw [one_mul]
              positivity
  filter_upwards [h_main] with n hn
  have h‚ÇÅ : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)
      = (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n) := by
    have := R.b_pos i
    simp only [q, mul_rpow (by positivity : (0 : ‚Ñù) ‚â§ b i) (by positivity : (0 : ‚Ñù) ‚â§ n)]
    ring
  show (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n) ‚â§ q (r i n)
  rw [‚Üê h‚ÇÅ, sub_le_iff_le_add', ‚Üê sub_le_iff_le_add]
  exact hn","error:  unexpected token ':'; expected '|'
error:  unsolved goals
Œ± : Type u_1
inst‚úù¬π : Fintype Œ±
inst‚úù : Nonempty Œ±
T : ‚Ñï ‚Üí ‚Ñù
g : ‚Ñù ‚Üí ‚Ñù
a b : Œ± ‚Üí ‚Ñù
r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï
R : AkraBazziRecurrence T g a b r
i : Œ±
q : ‚Ñù ‚Üí ‚Ñù := fun x ‚Ü¶ x ^ p a b * (1 + Œµ x)
h_diff_q : DifferentiableOn ‚Ñù q (Set.Ioi 1)
h_deriv_q : deriv q =O[atTop] fun x ‚Ü¶ x ^ (p a b - 1)
h_main_norm : (fun n ‚Ü¶ ‚Äñq ‚Üë(r i n) - q (b i * ‚Üën)‚Äñ) ‚â§·∂†[atTop] fun n ‚Ü¶ ‚Äñb i ^ p a b * ‚Üën ^ p a b * (Œµ (b i * ‚Üën) - Œµ ‚Üën)‚Äñ
‚ä¢ ‚àÄ·∂† (x : ‚Ñï) in atTop, b i ^ p a b * ‚Üëx ^ p a b * (1 + Œµ ‚Üëx) ‚â§ ‚Üë(r i x) ^ p a b * (1 + Œµ ‚Üë(r i x))
error:  invalid field notation, function 'AkraBazziRecurrence.rpow_p_mul_one_add_smoothingFn_ge' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name
error:  function expected at
  bound2 n hn
term has type
  ?m.1390944 n
error:  invalid field notation, function 'AkraBazziRecurrence.smoothingFn_mul_asympBound_isBigO_T' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'AkraBazziRecurrence.isBigO_symm_asympBound' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name","lemma rpow_p_mul_one_add_smoothingFn_ge :
    ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n)
      ‚â§ (r i n) ^ (p a b) * (1 + Œµ (r i n)) ",":= by
  rw [Filter.eventually_all]
  intro i
  let q : ‚Ñù ‚Üí ‚Ñù := fun x => x ^ (p a b) * (1 + Œµ x)
  have h_diff_q : DifferentiableOn ‚Ñù q (Set.Ioi 1) := by
    refine DifferentiableOn.mul
        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)
        differentiableOn_one_add_smoothingFn
    rw [Set.mem_compl_singleton_iff]
    rw [Set.mem_Ioi] at hz
    exact ne_of_gt <| zero_lt_one.trans hz
  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc
    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + Œµ z) x := by rfl
          _ =·∂†[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + Œµ x)
              + x ^ (p a b) * deriv (fun z => 1 + Œµ z) x := by
                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'
                rw [deriv_mul] <;> aesop
          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by
                refine IsBigO.add ?left ?right
                case left => calc
                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + Œµ x))
                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + Œµ x) := by
                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)
                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=
                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO
                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]
                case right => calc
                  (fun x => x ^ (p a b) * deriv (fun z => 1 + Œµ z) x)
                      =O[atTop] (fun x => x ^ (p a b) * x‚Åª¬π) := by
                        exact IsBigO.mul (isBigO_refl _ _)
                          isLittleO_deriv_one_add_smoothingFn.isBigO
                    _ =·∂†[atTop] fun x => x ^ ((p a b) - 1) := by
                        filter_upwards [eventually_gt_atTop 0] with x hx
                        rw [‚Üê Real.rpow_neg_one, ‚Üê Real.rpow_add hx, ‚Üê sub_eq_add_neg]
  have h_main_norm : (fun (n:‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ)
      ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ := by
    refine IsLittleO.eventuallyLE ?_
    calc
      (fun (n:‚Ñï) => q (r i n) - q (b i * n))
          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by
            exact R.isBigO_apply_r_sub_b q h_diff_q
              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i
        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by
            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)
        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by
            exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)
        _ =·∂†[atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by
            filter_upwards [eventually_ne_atTop 0] with n hn
            have hn' : (n:‚Ñù) ‚â† 0 := by positivity
            simp [‚Üê mul_div_assoc, ‚Üê Real.rpow_add_one hn']
        _ = fun (n:‚Ñï) => (n:‚Ñù) ^ (p a b) * (1 / (log n) ^ 2)   := by simp_rw [mul_div, mul_one]
        _ =Œò[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) := by
            refine IsTheta.symm ?_
            simp_rw [mul_assoc]
            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)
            have := R.b_pos i; positivity
        _ =Œò[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)
                  <| R.isTheta_smoothingFn_sub_self i
  have h_main : (fun (n:‚Ñï) => q (b i * n) - q (r i n))
      ‚â§·∂†[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
    calc (fun (n:‚Ñï) => q (b i * n) - q (r i n))
           ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ := by
              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _
         _ ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ :=
              h_main_norm
         _ =·∂†[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
              filter_upwards [eventually_gt_atTop ‚åà(b i)‚Åª¬π‚åâ‚Çä, eventually_gt_atTop 1] with n hn hn'
              refine norm_of_nonneg ?_
              have h‚ÇÅ := R.b_pos i
              have h‚ÇÇ : 0 ‚â§ Œµ (b i * n) - Œµ n := by
                refine sub_nonneg_of_le <|
                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le
                case n_gt_one =>
                  show 1 < (n:‚Ñù)
                  rw [Nat.one_lt_cast]
                  exact hn'
                case bn_gt_one =>
                  calc 1 = b i * (b i)‚Åª¬π := by rw [mul_inv_cancel (by positivity)]
                      _ ‚â§ b i * ‚åà(b i)‚Åª¬π‚åâ‚Çä := by gcongr; exact Nat.le_ceil _
                      _ < b i * n := by gcongr; rw [Nat.cast_lt]; exact hn
                case le => calc b i * n ‚â§ 1 * n := by have := R.b_lt_one i; gcongr
                                        _ = n := by rw [one_mul]
              positivity
  filter_upwards [h_main] with n hn
  have h‚ÇÅ : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)
      = (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n) := by
    have := R.b_pos i
    simp only [q, mul_rpow (by positivity : (0:‚Ñù) ‚â§ b i) (by positivity : (0:‚Ñù) ‚â§ n)]
    ring
  show (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n) ‚â§ q (r i n)
  rw [‚Üê h‚ÇÅ, sub_le_iff_le_add', ‚Üê sub_le_iff_le_add]
  exact hn"
Mathlib/Combinatorics/SetFamily/CauchyDavenport.lean,Finset.min_le_card_mul,Finset.min_le_card_mul,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain ‚ü®rfl, rfl‚ü© := hx
  refine' wellFoundedOn_devosMulRel.induction (P := fun x : Finset Œ± √ó Finset Œ± ‚Ü¶
    min (minOrder Œ±) ‚Üë(card x.1 + card x.2 - 1) ‚â§ card (x.1 * x.2)) ‚ü®hs, ht‚ü© _
  clear! x
  rintro ‚ü®s, t‚ü© ‚ü®hs, ht‚ü© ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  ¬∑ simpa only [‚Üê mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [‚Üê mul_inv_rev, add_comm, card_inv, true_and])
  obtain ‚ü®a, rfl‚ü© | ‚ü®a, ha, b, hb, hab‚ü© := hs.exists_eq_singleton_or_nontrivial
  ¬∑ simp [add_comm]
  obtain ‚ü®g, hg, hgs‚ü© : ‚àÉ g : Œ±, g ‚â† 1 ‚àß (s ‚à© op g ‚Ä¢ s).Nonempty :=
    ‚ü®b‚Åª¬π * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 ‚ü®ha, mem_smul_finset.2 ‚ü®_, hb, by simp‚ü©‚ü©‚ü©
  obtain hsg | hsg := eq_or_ne (op g ‚Ä¢ s) s
  ¬∑ have hS : (zpowers g : Set Œ±) ‚äÜ a‚Åª¬π ‚Ä¢ (s : Set Œ±) := by
      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (¬∑ ‚àà a‚Åª¬π ‚Ä¢ (s : Set Œ±))
        ‚ü®_, ha, inv_mul_self _‚ü© (fun c hc ‚Ü¶ ?_) fun c hc ‚Ü¶ ?_
      ¬∑ rw [‚Üê hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      ¬∑ simp only
        rwa [‚Üê op_smul_eq_mul, op_inv, ‚Üê Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          ‚Üê coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [‚Üê coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s ‚à© op g ‚Ä¢ s).card < s.card := card_lt_card ‚ü®inter_subset_left _ _, fun h ‚Ü¶
    hsg <| eq_of_superset_of_card_ge (h.trans <| inter_subset_right _ _) (card_smul_finset _ _).le‚ü©
  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (g‚Åª¬π ‚Ä¢ t)
  ¬∑ rw [‚Üê card_smul_finset g‚Åª¬π t]
    refine' Or.inr ((add_le_add_right hst _).trans _)
    rw [‚Üê card_union_of_disjoint hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  ¬∑ exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h ‚Ü¶ hstg.trans <| h.trans <| add_le_add_right aux1 _
  ¬∑ exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h ‚Ü¶
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _","error:  function expected at
  inter_subset_left ?m.46803
term has type
  ?m.46802 ‚àà ?m.46800
error:  function expected at
  inter_subset_right ?m.46987
term has type
  ?m.46986 ‚àà ?m.46985","lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder Œ±) ‚Üë(s.card + t.card - 1) ‚â§ (s * t).card ",":= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain ‚ü®rfl, rfl‚ü© := hx
  refine wellFoundedOn_devosMulRel.induction (P := fun x : Finset Œ± √ó Finset Œ± ‚Ü¶
    min (minOrder Œ±) ‚Üë(card x.1 + card x.2 - 1) ‚â§ card (x.1 * x.2)) ‚ü®hs, ht‚ü© ?_
  clear! x
  rintro ‚ü®s, t‚ü© ‚ü®hs, ht‚ü© ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  ¬∑ simpa only [‚Üê mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [‚Üê mul_inv_rev, add_comm, card_inv, true_and])
  obtain ‚ü®a, rfl‚ü© | ‚ü®a, ha, b, hb, hab‚ü© := hs.exists_eq_singleton_or_nontrivial
  ¬∑ simp [add_comm]
  obtain ‚ü®g, hg, hgs‚ü© : ‚àÉ g : Œ±, g ‚â† 1 ‚àß (s ‚à© op g ‚Ä¢ s).Nonempty :=
    ‚ü®b‚Åª¬π * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 ‚ü®ha, mem_smul_finset.2 ‚ü®_, hb, by simp‚ü©‚ü©‚ü©
  obtain hsg | hsg := eq_or_ne (op g ‚Ä¢ s) s
  ¬∑ have hS : (zpowers g : Set Œ±) ‚äÜ a‚Åª¬π ‚Ä¢ (s : Set Œ±) := by
      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (¬∑ ‚àà a‚Åª¬π ‚Ä¢ (s : Set Œ±))
        ‚ü®_, ha, inv_mul_self _‚ü© (fun c hc ‚Ü¶ ?_) fun c hc ‚Ü¶ ?_
      ¬∑ rw [‚Üê hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      ¬∑ simp only
        rwa [‚Üê op_smul_eq_mul, op_inv, ‚Üê Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          ‚Üê coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [‚Üê coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s ‚à© op g ‚Ä¢ s).card < s.card := card_lt_card ‚ü®inter_subset_left, fun h ‚Ü¶
    hsg <| eq_of_superset_of_card_ge (h.trans inter_subset_right) (card_smul_finset _ _).le‚ü©
  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (g‚Åª¬π ‚Ä¢ t)
  ¬∑ rw [‚Üê card_smul_finset g‚Åª¬π t]
    refine Or.inr ((add_le_add_right hst _).trans ?_)
    rw [‚Üê card_union_of_disjoint hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  ¬∑ exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h ‚Ü¶ hstg.trans <| h.trans <| add_le_add_right aux1 _
  ¬∑ exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h ‚Ü¶
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _"
Mathlib/ModelTheory/Satisfiability.lean,FirstOrder.Language.Formula.inf_semanticallyEquivalent_not_sup_not,inf_semanticallyEquivalent_not_sup_not,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= fun M v xs => by
  simp [and_iff_not_or_not]","warning:  @ModelsBoundedFormula does not have a doc string
error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information","theorem inf_semanticallyEquivalent_not_sup_not :
    T.SemanticallyEquivalent (œÜ ‚äì œà) (œÜ.not ‚äî œà.not).not ",":= fun M v xs => by
  simp"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/Algebra/Module/PID.lean,Module.torsion_by_prime_power_decomposition,torsion_by_prime_power_decomposition,149993021318d2b426f3d41570396b90e12fcb46,":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    ¬∑ obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
      clear IH
      have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ‚ü®x, h0, ?_‚ü©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'","error:  type mismatch
  R ‚ß∏ Submodule.span R {p ^ Option.rec (pOrder hN (s j)) k i}
has type
  Type u : Type (u + 1)
but is expected to have type
  (b : Option (Fin d)) ‚Üí Decidable (i = b) : Type
error:  application type mismatch
  (((lequivProdOfRightSplitExact ‚ãØ ?m.198963 ?m.198964).symm ‚â™‚â´‚Çó
            ((quotTorsionOfEquivSpanSingleton R N (s j)).symm ‚â™‚â´‚Çó
                  Submodule.quotEquivOfEq (torsionOf R N (s j)) (Ideal.span {p ^ pOrder hN (s j)}) ‚ãØ).prod
              ULift.moduleEquiv).trans
        ?m.204421).trans
    (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
argument
  DirectSum.lequivCongrLeft R (finSuccEquiv d).symm
has type
  (‚®Å (i : Option (Fin d)), ?m.205281 i) ‚âÉ‚Çó[R] ‚®Å (k : Fin (d + 1)), ?m.205281 ((finSuccEquiv d).symm.symm k) : Type u
but is expected to have type
  (‚®Å (i : Option (Fin d)), ?m.205281 i) ‚âÉ‚Çó[R]
    ‚®Å (i : Fin (d + 1)),
      R ‚ß∏ Submodule.span R {p ^ (fun i ‚Ü¶ Option.rec (pOrder hN (s j)) k i) ((finSuccEquiv d) i)} : Type u","theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ‚àÉ (d : ‚Ñï) (k : Fin d ‚Üí ‚Ñï), Nonempty <| N ‚âÉ‚Çó[R] ‚®Å i : Fin d, R ‚ß∏ R ‚àô p ^ (k i : ‚Ñï) ",":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    ¬∑ obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
      clear IH
      have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ‚ü®x, h0, ?_‚ü©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,52752d07e2044877cdc88db106f22ffbb1eec3fa,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a
  ¬∑ exact ‚ü®_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b
  ¬∑ exact ‚ü®_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine' (lt_add_iff_pos_right _).2 _
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine' (sub_lt_self_iff _).2 _
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine' ‚ü®x, xu, _, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine' ‚ü®xl y, xu, _, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]","error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/RingTheory/DedekindDomain/Ideal.lean,exists_multiset_prod_cons_le_and_prod_not_le,exists_multiset_prod_cons_le_and_prod_not_le,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  obtain ‚ü®Z‚ÇÄ, hZ‚ÇÄ‚ü© := PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain hNF hI0
  obtain ‚ü®Z, ‚ü®hZI, hprodZ‚ü©, h_eraseZ‚ü© :=
    wellFounded_lt.has_min
      {Z | (Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß (Z.map PrimeSpectrum.asIdeal).prod ‚â† ‚ä•}
      ‚ü®Z‚ÇÄ, hZ‚ÇÄ.1, hZ‚ÇÄ.2‚ü©
  obtain ‚ü®_, hPZ', hPM‚ü© := hM.isPrime.multiset_prod_le.mp (hZI.trans hIM)
  obtain ‚ü®P, hPZ, rfl‚ü© := Multiset.mem_map.mp hPZ'
  classical
    have := Multiset.map_erase PrimeSpectrum.asIdeal PrimeSpectrum.ext P Z
    obtain ‚ü®hP0, hZP0‚ü© : P.asIdeal ‚â† ‚ä• ‚àß ((Z.erase P).map PrimeSpectrum.asIdeal).prod ‚â† ‚ä• := by
      rwa [Ne.def, ‚Üê Multiset.cons_erase hPZ', Multiset.prod_cons, Ideal.mul_eq_bot, not_or, ‚Üê
        this] at hprodZ
    have hPM' := (P.IsPrime.isMaximal hP0).eq_of_le hM.ne_top hPM
    subst hPM'
    refine ‚ü®Z.erase P, ?_, ?_‚ü©
    ¬∑ convert hZI
      rw [this, Multiset.cons_erase hPZ']
    ¬∑ refine fun h => h_eraseZ (Z.erase P) ‚ü®h, ?_‚ü© (Multiset.erase_lt.mpr hPZ)
      exact hZP0","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.161826 ‚Üí ?m.161826 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.161828
R : Type u_1
A : Type u_2
K : Type u_3
inst‚úù‚Åµ : CommRing R
inst‚úù‚Å¥ : CommRing A
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Algebra A K
inst‚úù¬π : IsFractionRing A K
inst‚úù : IsDedekindDomain A
hNF : ¬¨IsField A
I M : Ideal A
hI0 : I ‚â† ‚ä•
hIM : I ‚â§ M
hM : M.IsMaximal
Z‚ÇÄ : Multiset (PrimeSpectrum A)
hZ‚ÇÄ : (Multiset.map PrimeSpectrum.asIdeal Z‚ÇÄ).prod ‚â§ I ‚àß (Multiset.map PrimeSpectrum.asIdeal Z‚ÇÄ).prod ‚â† ‚ä•
Z : Multiset (PrimeSpectrum A)
h_eraseZ :
  ‚àÄ x ‚àà {Z | (Multiset.map PrimeSpectrum.asIdeal Z).prod ‚â§ I ‚àß (Multiset.map PrimeSpectrum.asIdeal Z).prod ‚â† ‚ä•}, ¬¨x < Z
hZI : (Multiset.map PrimeSpectrum.asIdeal Z).prod ‚â§ I
hprodZ : (Multiset.map PrimeSpectrum.asIdeal Z).prod ‚â† ‚ä•
P : PrimeSpectrum A
hPZ : P ‚àà Z
hPZ' : P.asIdeal ‚àà Multiset.map PrimeSpectrum.asIdeal Z
hPM : P.asIdeal ‚â§ M
this : Multiset.map PrimeSpectrum.asIdeal (Z.erase P) = (Multiset.map PrimeSpectrum.asIdeal Z).erase P.asIdeal
‚ä¢ P.asIdeal ‚â† ‚ä• ‚àß (Multiset.map PrimeSpectrum.asIdeal (Z.erase P)).prod ‚â† ‚ä•
warning:  `PrimeSpectrum.IsPrime` has been deprecated, use `PrimeSpectrum.isPrime` instead","theorem exists_multiset_prod_cons_le_and_prod_not_le [IsDedekindDomain A] (hNF : ¬¨IsField A)
    {I M : Ideal A} (hI0 : I ‚â† ‚ä•) (hIM : I ‚â§ M) [hM : M.IsMaximal] :
    ‚àÉ Z : Multiset (PrimeSpectrum A),
      (M ::‚Çò Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß
        ¬¨Multiset.prod (Z.map PrimeSpectrum.asIdeal) ‚â§ I ",":= by
  obtain ‚ü®Z‚ÇÄ, hZ‚ÇÄ‚ü© := PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain hNF hI0
  obtain ‚ü®Z, ‚ü®hZI, hprodZ‚ü©, h_eraseZ‚ü© :=
    wellFounded_lt.has_min
      {Z | (Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß (Z.map PrimeSpectrum.asIdeal).prod ‚â† ‚ä•}
      ‚ü®Z‚ÇÄ, hZ‚ÇÄ.1, hZ‚ÇÄ.2‚ü©
  obtain ‚ü®_, hPZ', hPM‚ü© := hM.isPrime.multiset_prod_le.mp (hZI.trans hIM)
  obtain ‚ü®P, hPZ, rfl‚ü© := Multiset.mem_map.mp hPZ'
  classical
    have := Multiset.map_erase PrimeSpectrum.asIdeal PrimeSpectrum.ext P Z
    obtain ‚ü®hP0, hZP0‚ü© : P.asIdeal ‚â† ‚ä• ‚àß ((Z.erase P).map PrimeSpectrum.asIdeal).prod ‚â† ‚ä• := by
      rwa [Ne, ‚Üê Multiset.cons_erase hPZ', Multiset.prod_cons, Ideal.mul_eq_bot, not_or, ‚Üê
        this] at hprodZ
    have hPM' := (P.isPrime.isMaximal hP0).eq_of_le hM.ne_top hPM
    subst hPM'
    refine ‚ü®Z.erase P, ?_, ?_‚ü©
    ¬∑ convert hZI
      rw [this, Multiset.cons_erase hPZ']
    ¬∑ refine fun h => h_eraseZ (Z.erase P) ‚ü®h, ?_‚ü© (Multiset.erase_lt.mpr hPZ)
      exact hZP0"
Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean,CategoryTheory.Limits.colimitLimitToLimitColimit_surjective,colimitLimitToLimitColimit_surjective,5facde50581cefe36eb491a50b05917b86b8b861,":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ‚Üê Limit.w_apply.{u‚ÇÅ, v, u‚ÇÅ} f, ‚Üê e]
      simp only [Functor.comp_map, Types.Colimit.Œπ_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) := by
            rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) := by
            rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext
      intro j
      simp only [id, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.64355 ‚àà insert ?m.64356 ?m.64354
J : Type u‚ÇÅ
K : Type u‚ÇÇ
inst‚úù‚Å¥ : SmallCategory J
inst‚úù¬≥ : Category.{v‚ÇÇ, u‚ÇÇ} K
inst‚úù¬≤ : Small.{v, u‚ÇÇ} K
inst‚úù¬π : FinCategory J
F : J √ó K ‚•§ Type v
inst‚úù : IsFiltered K
x : limit (curry.obj F ‚ãô colim)
k : J ‚Üí K
y : (j : J) ‚Üí F.obj (j, k j)
e : ‚àÄ (j : J), colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô colim) j x
k' : K
g : (j : J) ‚Üí k j ‚ü∂ k'
kf : {j j' : J} ‚Üí (j ‚ü∂ j') ‚Üí K
hf gf : {j j' : J} ‚Üí (f : j ‚ü∂ j') ‚Üí k' ‚ü∂ kf f
wf : ‚àÄ {j j' : J} (f : j ‚ü∂ j'), F.map (ùüô j', g j' ‚â´ gf f) (y j') = F.map (f, g j ‚â´ hf f) (y j)
O : Finset K := (Finset.univ.biUnion fun j ‚Ü¶ Finset.univ.biUnion fun j' ‚Ü¶ Finset.image kf Finset.univ) ‚à™ {k'}
kfO : ‚àÄ {j j' : J} (f : j ‚ü∂ j'), kf f ‚àà O
k'O : k' ‚àà O
H : Finset ((X : K) √ó' (Y : K) √ó' (_ : X ‚àà O) √ó' (_ : Y ‚àà O) √ó' (X ‚ü∂ Y)) :=
  Finset.univ.biUnion fun j ‚Ü¶
    Finset.univ.biUnion fun j' ‚Ü¶
      Finset.univ.biUnion fun f ‚Ü¶ {‚ü®k', ‚ü®kf f, ‚ü®k'O, ‚ü®‚ãØ, gf f‚ü©‚ü©‚ü©‚ü©, ‚ü®k', ‚ü®kf f, ‚ü®k'O, ‚ü®‚ãØ, hf f‚ü©‚ü©‚ü©‚ü©}
k'' : K
i' : {X : K} ‚Üí X ‚àà O ‚Üí (X ‚ü∂ k'')
s' : ‚àÄ {X Y : K} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y}, ‚ü®X, ‚ü®Y, ‚ü®mX, ‚ü®mY, f‚ü©‚ü©‚ü©‚ü© ‚àà H ‚Üí f ‚â´ i' mY = i' mX
i : {j j' : J} ‚Üí (f : j ‚ü∂ j') ‚Üí kf f ‚ü∂ k'' := fun {j j'} f ‚Ü¶ i' ‚ãØ
j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ : J
f : j‚ÇÅ ‚ü∂ j‚ÇÇ
f' : j‚ÇÉ ‚ü∂ j‚ÇÑ
‚ä¢ ?m.60271 ‚àà ?m.61828 f'
error:  application type mismatch
  ‚ü®Finset.mem_univ j‚ÇÉ, Finset.mem_biUnion.mpr (Exists.intro j‚ÇÑ ‚ü®Finset.mem_univ j‚ÇÑ, ?m.62095‚ü©)‚ü©
argument
  Finset.mem_biUnion.mpr (Exists.intro j‚ÇÑ ‚ü®Finset.mem_univ j‚ÇÑ, ?m.62095‚ü©)
has type
  ?m.60271 ‚àà Finset.univ.biUnion ?m.61634 : Prop
but is expected to have type
  ?m.60271 ‚àà ?m.60196 j‚ÇÉ : Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  HEq ?a ?b
J : Type u‚ÇÅ
K : Type u‚ÇÇ
inst‚úù‚Å¥ : SmallCategory J
inst‚úù¬≥ : Category.{v‚ÇÇ, u‚ÇÇ} K
inst‚úù¬≤ : Small.{v, u‚ÇÇ} K
inst‚úù¬π : FinCategory J
F : J √ó K ‚•§ Type v
inst‚úù : IsFiltered K
x : limit (curry.obj F ‚ãô colim)
k : J ‚Üí K
y : (j : J) ‚Üí F.obj (j, k j)
e : ‚àÄ (j : J), colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô colim) j x
k' : K
g : (j : J) ‚Üí k j ‚ü∂ k'
kf : {j j' : J} ‚Üí (j ‚ü∂ j') ‚Üí K
hf gf : {j j' : J} ‚Üí (f : j ‚ü∂ j') ‚Üí k' ‚ü∂ kf f
wf : ‚àÄ {j j' : J} (f : j ‚ü∂ j'), F.map (ùüô j', g j' ‚â´ gf f) (y j') = F.map (f, g j ‚â´ hf f) (y j)
O : Finset K := (Finset.univ.biUnion fun j ‚Ü¶ Finset.univ.biUnion fun j' ‚Ü¶ Finset.image kf Finset.univ) ‚à™ {k'}
kfO : ‚àÄ {j j' : J} (f : j ‚ü∂ j'), kf f ‚àà O
k'O : k' ‚àà O
H : Finset ((X : K) √ó' (Y : K) √ó' (_ : X ‚àà O) √ó' (_ : Y ‚àà O) √ó' (X ‚ü∂ Y)) :=
  Finset.univ.biUnion fun j ‚Ü¶
    Finset.univ.biUnion fun j' ‚Ü¶
      Finset.univ.biUnion fun f ‚Ü¶ {‚ü®k', ‚ü®kf f, ‚ü®k'O, ‚ü®‚ãØ, gf f‚ü©‚ü©‚ü©‚ü©, ‚ü®k', ‚ü®kf f, ‚ü®k'O, ‚ü®‚ãØ, hf f‚ü©‚ü©‚ü©‚ü©}
k'' : K
i' : {X : K} ‚Üí X ‚àà O ‚Üí (X ‚ü∂ k'')
s' : ‚àÄ {X Y : K} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y}, ‚ü®X, ‚ü®Y, ‚ü®mX, ‚ü®mY, f‚ü©‚ü©‚ü©‚ü© ‚àà H ‚Üí f ‚â´ i' mY = i' mX
i : {j j' : J} ‚Üí (f : j ‚ü∂ j') ‚Üí kf f ‚ü∂ k'' := fun {j j'} f ‚Ü¶ i' ‚ãØ
j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ : J
f : j‚ÇÅ ‚ü∂ j‚ÇÇ
f' : j‚ÇÉ ‚ü∂ j‚ÇÑ
‚ä¢ k' = k' ‚àß kf f' = kf f ‚àß HEq ‚ü®‚ãØ, ‚ü®‚ãØ, hf f'‚ü©‚ü© ‚ü®k'O, ‚ü®‚ãØ, gf f‚ü©‚ü© ‚à®
    ‚ü®k', ‚ü®kf f', ‚ü®‚ãØ, ‚ü®‚ãØ, hf f'‚ü©‚ü©‚ü©‚ü© ‚àà {‚ü®k', ‚ü®kf f, ‚ü®k'O, ‚ü®‚ãØ, hf f‚ü©‚ü©‚ü©‚ü©}
error:  unsolved goals
case a
J : Type u‚ÇÅ
K : Type u‚ÇÇ
inst‚úù‚Å¥ : SmallCategory J
inst‚úù¬≥ : Category.{v‚ÇÇ, u‚ÇÇ} K
inst‚úù¬≤ : Small.{v, u‚ÇÇ} K
inst‚úù¬π : FinCategory J
F : J √ó K ‚•§ Type v
inst‚úù : IsFiltered K
x : limit (curry.obj F ‚ãô colim)
k : J ‚Üí K
y : (j : J) ‚Üí F.obj (j, k j)
e : ‚àÄ (j : J), colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô colim) j x
k' : K
g : (j : J) ‚Üí k j ‚ü∂ k'
kf : {j j' : J} ‚Üí (j ‚ü∂ j') ‚Üí K
hf gf : {j j' : J} ‚Üí (f : j ‚ü∂ j') ‚Üí k' ‚ü∂ kf f
wf : ‚àÄ {j j' : J} (f : j ‚ü∂ j'), F.map (ùüô j', g j' ‚â´ gf f) (y j') = F.map (f, g j ‚â´ hf f) (y j)
O : Finset K := (Finset.univ.biUnion fun j ‚Ü¶ Finset.univ.biUnion fun j' ‚Ü¶ Finset.image kf Finset.univ) ‚à™ {k'}
kfO : ‚àÄ {j j' : J} (f : j ‚ü∂ j'), kf f ‚àà O
k'O : k' ‚àà O
H : Finset ((X : K) √ó' (Y : K) √ó' (_ : X ‚àà O) √ó' (_ : Y ‚àà O) √ó' (X ‚ü∂ Y)) :=
  Finset.univ.biUnion fun j ‚Ü¶
    Finset.univ.biUnion fun j' ‚Ü¶
      Finset.univ.biUnion fun f ‚Ü¶ {‚ü®k', ‚ü®kf f, ‚ü®k'O, ‚ü®‚ãØ, gf f‚ü©‚ü©‚ü©‚ü©, ‚ü®k', ‚ü®kf f, ‚ü®k'O, ‚ü®‚ãØ, hf f‚ü©‚ü©‚ü©‚ü©}
k'' : K
i' : {X : K} ‚Üí X ‚àà O ‚Üí (X ‚ü∂ k'')
s' : ‚àÄ {X Y : K} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y}, ‚ü®X, ‚ü®Y, ‚ü®mX, ‚ü®mY, f‚ü©‚ü©‚ü©‚ü© ‚àà H ‚Üí f ‚â´ i' mY = i' mX
i : {j j' : J} ‚Üí (f : j ‚ü∂ j') ‚Üí kf f ‚ü∂ k'' := fun {j j'} f ‚Ü¶ i' ‚ãØ
j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ : J
f : j‚ÇÅ ‚ü∂ j‚ÇÇ
f' : j‚ÇÉ ‚ü∂ j‚ÇÑ
‚ä¢ ‚ü®k', ‚ü®kf f, ‚ü®‚ãØ, ‚ü®‚ãØ, gf f‚ü©‚ü©‚ü©‚ü© ‚àà H","theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) ",":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ‚Üê Limit.w_apply.{u‚ÇÅ, v, u‚ÇÅ} f, ‚Üê e]
      simp only [Functor.comp_map, Types.Colimit.Œπ_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact k'O
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) := by
            rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) := by
            rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext
      intro j
      simp only [id, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]"
Mathlib/Algebra/CharZero/Defs.lean,Nat.cast_add_one_ne_zero,cast_add_one_ne_zero,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  norm_cast
  exact n.succ_ne_zero",error:  no goals to be solved,theorem cast_add_one_ne_zero (n : ‚Ñï) : (n + 1 : R) ‚â† 0 ,":=
  mod_cast n.succ_ne_zero"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.join_nil,join_nil,88f252d9ef6777980e9cb4396094e178f3ed4acb,":=
  WSeq.ext _ _ <| Seq'.join_nil",error:  unknown constant 'Stream'.WSeq.ext',theorem join_nil : join nil = (nil : WSeq Œ±) ,":=
  Seq.join_nil"
Mathlib/CategoryTheory/Sites/Over.lean,CategoryTheory.GrothendieckTopology.over_map_compatiblePreserving,over_map_compatiblePreserving,e679d790a5eccb2980e393ed252d2214cbf6cd3a,"  compatible {F Z T x hx Y‚ÇÅ Y‚ÇÇ W f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ h} := by
    let W' : Over X := Over.mk (f‚ÇÅ.left ‚â´ Y‚ÇÅ.hom)
    let g‚ÇÅ' : W' ‚ü∂ Y‚ÇÅ := Over.homMk f‚ÇÅ.left
    let g‚ÇÇ' : W' ‚ü∂ Y‚ÇÇ := Over.homMk f‚ÇÇ.left
      (by simpa using (Over.forget _).congr_map h.symm =‚â´ Z.hom)
    let e : (Over.map f).obj W' ‚âÖ W := Over.isoMk (Iso.refl _)
      (by simpa using (Over.w f‚ÇÅ).symm)
    convert congr_arg (F.val.map e.inv.op)
      (hx g‚ÇÅ' g‚ÇÇ' hg‚ÇÅ hg‚ÇÇ (by ext; exact (Over.forget _).congr_map h)) using 1
    all_goals
      dsimp
      rw [‚Üê FunctorToTypes.map_comp_apply]
      apply congr_fun
      congr 1
      rw [‚Üê op_comp]
      congr 1
      ext
      simp","error:  type mismatch
  h‚úù
has type
  W.hom = f‚ÇÅ.left ‚â´ Y‚ÇÅ.hom ‚â´ f : Prop
but is expected to have type
  W.hom = W'.hom ‚â´ f : Prop
error:  unsolved goals
case h.e'_2.h.e_a.e_f.h
C : Type u
inst‚úù : Category.{v, u} C
J : GrothendieckTopology C
X Y : C
f : X ‚ü∂ Y
F : SheafOfTypes (J.over Y)
Z : Over X
T : Presieve Z
x : Presieve.FamilyOfElements ((Over.map f).op ‚ãô F.val) T
hx : x.Compatible
Y‚ÇÅ Y‚ÇÇ : Over X
W : Over Y
f‚ÇÅ : W ‚ü∂ (Over.map f).obj Y‚ÇÅ
f‚ÇÇ : W ‚ü∂ (Over.map f).obj Y‚ÇÇ
g‚ÇÅ : Y‚ÇÅ ‚ü∂ Z
g‚ÇÇ : Y‚ÇÇ ‚ü∂ Z
hg‚ÇÅ : T g‚ÇÅ
hg‚ÇÇ : T g‚ÇÇ
h : f‚ÇÅ ‚â´ (Over.map f).map g‚ÇÅ = f‚ÇÇ ‚â´ (Over.map f).map g‚ÇÇ
W' : Over X := Over.mk (f‚ÇÅ.left ‚â´ Y‚ÇÅ.hom)
g‚ÇÅ' : W' ‚ü∂ Y‚ÇÅ := Over.homMk f‚ÇÅ.left ‚ãØ
g‚ÇÇ' : W' ‚ü∂ Y‚ÇÇ := Over.homMk f‚ÇÇ.left ‚ãØ
e : (Over.map f).obj W' ‚âÖ W := Over.isoMk (Iso.refl ((Over.map f).obj W').left) ‚ãØ
‚ä¢ f‚ÇÅ.left = e.inv.left ‚â´ g‚ÇÅ'.left

case h.e'_3.h.e_a.e_f.h
C : Type u
inst‚úù : Category.{v, u} C
J : GrothendieckTopology C
X Y : C
f : X ‚ü∂ Y
F : SheafOfTypes (J.over Y)
Z : Over X
T : Presieve Z
x : Presieve.FamilyOfElements ((Over.map f).op ‚ãô F.val) T
hx : x.Compatible
Y‚ÇÅ Y‚ÇÇ : Over X
W : Over Y
f‚ÇÅ : W ‚ü∂ (Over.map f).obj Y‚ÇÅ
f‚ÇÇ : W ‚ü∂ (Over.map f).obj Y‚ÇÇ
g‚ÇÅ : Y‚ÇÅ ‚ü∂ Z
g‚ÇÇ : Y‚ÇÇ ‚ü∂ Z
hg‚ÇÅ : T g‚ÇÅ
hg‚ÇÇ : T g‚ÇÇ
h : f‚ÇÅ ‚â´ (Over.map f).map g‚ÇÅ = f‚ÇÇ ‚â´ (Over.map f).map g‚ÇÇ
W' : Over X := Over.mk (f‚ÇÅ.left ‚â´ Y‚ÇÅ.hom)
g‚ÇÅ' : W' ‚ü∂ Y‚ÇÅ := Over.homMk f‚ÇÅ.left ‚ãØ
g‚ÇÇ' : W' ‚ü∂ Y‚ÇÇ := Over.homMk f‚ÇÇ.left ‚ãØ
e : (Over.map f).obj W' ‚âÖ W := Over.isoMk (Iso.refl ((Over.map f).obj W').left) ‚ãØ
‚ä¢ f‚ÇÇ.left = e.inv.left ‚â´ g‚ÇÇ'.left","lemma over_map_compatiblePreserving {X Y : C} (f : X ‚ü∂ Y) :
    CompatiblePreserving (J.over Y) (Over.map f) where
","  compatible {F Z T x hx Y‚ÇÅ Y‚ÇÇ W f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ h} := by
    let W' : Over X := Over.mk (f‚ÇÅ.left ‚â´ Y‚ÇÅ.hom)
    let g‚ÇÅ' : W' ‚ü∂ Y‚ÇÅ := Over.homMk f‚ÇÅ.left
    let g‚ÇÇ' : W' ‚ü∂ Y‚ÇÇ := Over.homMk f‚ÇÇ.left
      (by simpa using (Over.forget _).congr_map h.symm =‚â´ Z.hom)
    let e : (Over.map f).obj W' ‚âÖ W := Over.isoMk (Iso.refl _)
      (by simpa [W'] using (Over.w f‚ÇÅ).symm)
    convert congr_arg (F.val.map e.inv.op)
      (hx g‚ÇÅ' g‚ÇÇ' hg‚ÇÅ hg‚ÇÇ (by ext; exact (Over.forget _).congr_map h)) using 1
    all_goals
      dsimp [e, W', g‚ÇÅ', g‚ÇÇ']
      rw [‚Üê FunctorToTypes.map_comp_apply]
      apply congr_fun
      congr 1
      rw [‚Üê op_comp]
      congr 1
      ext
      simp"
Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean,coeff_minpolyDiv_sub_pow_mem_span,coeff_minpolyDiv_sub_pow_mem_span,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  induction i with
  | zero => simp [(minpolyDiv_monic hx).leadingCoeff]
  | succ i IH =>
    rw [coeff_minpolyDiv, add_sub_assoc, pow_succ', ‚Üê sub_mul, Algebra.algebraMap_eq_smul_one]
    refine add_mem ?_ ?_
    ¬∑ apply Submodule.smul_mem
      apply Submodule.subset_span
      exact ‚ü®0, Nat.zero_lt_succ _, pow_zero _‚ü©
    ¬∑ rw [Nat.succ_eq_add_one, ‚Üê tsub_tsub, tsub_add_cancel_of_le
        (le_tsub_of_add_le_left (b := 1) hi)]
      apply SetLike.le_def.mp ?_
        (Submodule.mul_mem_mul (IH ((Nat.le_succ _).trans hi))
          (Submodule.mem_span_singleton_self x))
      rw [Submodule.span_mul_span, Set.mul_singleton, Set.image_image]
      apply Submodule.span_mono
      rintro _ ‚ü®j, hj, rfl‚ü©
      rw [Set.mem_Iio] at hj
      exact ‚ü®j + 1, Nat.add_lt_of_lt_sub hj, pow_succ' x j‚ü©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * ?c - ?b * ?c
case succ
R : Type u_2
K : Type ?u.79175
L : Type ?u.79178
S : Type u_1
inst‚úù‚Åµ : CommRing R
inst‚úù‚Å¥ : Field K
inst‚úù¬≥ : Field L
inst‚úù¬≤ : CommRing S
inst‚úù¬π : Algebra R S
inst‚úù : Algebra K L
x : S
hx : IsIntegral R x
i : ‚Ñï
IH :
  i ‚â§ (minpolyDiv R x).natDegree ‚Üí
    (minpolyDiv R x).coeff ((minpolyDiv R x).natDegree - i) - x ^ i ‚àà
      Submodule.span R ((fun x_1 ‚Ü¶ x ^ x_1) '' Set.Iio i)
hi : i + 1 ‚â§ (minpolyDiv R x).natDegree
‚ä¢ (algebraMap R S) ((minpoly R x).coeff ((minpolyDiv R x).natDegree - (i + 1) + 1)) +
      ((minpolyDiv R x).coeff ((minpolyDiv R x).natDegree - (i + 1) + 1) * x - x * x ^ i) ‚àà
    Submodule.span R ((fun x_1 ‚Ü¶ x ^ x_1) '' Set.Iio (i + 1))","lemma coeff_minpolyDiv_sub_pow_mem_span {i} (hi : i ‚â§ natDegree (minpolyDiv R x)) :
    coeff (minpolyDiv R x) (natDegree (minpolyDiv R x) - i) - x ^ i ‚àà
      Submodule.span R ((x ^ ¬∑) '' Set.Iio i) ",":= by
  induction i with
  | zero => simp [(minpolyDiv_monic hx).leadingCoeff]
  | succ i IH =>
    rw [coeff_minpolyDiv, add_sub_assoc, pow_succ, ‚Üê sub_mul, Algebra.algebraMap_eq_smul_one]
    refine add_mem ?_ ?_
    ¬∑ apply Submodule.smul_mem
      apply Submodule.subset_span
      exact ‚ü®0, Nat.zero_lt_succ _, pow_zero _‚ü©
    ¬∑ rw [‚Üê tsub_tsub, tsub_add_cancel_of_le (le_tsub_of_add_le_left (b := 1) hi)]
      apply SetLike.le_def.mp ?_
        (Submodule.mul_mem_mul (IH ((Nat.le_succ _).trans hi))
          (Submodule.mem_span_singleton_self x))
      rw [Submodule.span_mul_span, Set.mul_singleton, Set.image_image]
      apply Submodule.span_mono
      rintro _ ‚ü®j, hj, rfl‚ü©
      rw [Set.mem_Iio] at hj
      exact ‚ü®j + 1, Nat.add_lt_of_lt_sub hj, pow_succ x j‚ü©"
Mathlib/RingTheory/PowerSeries/Basic.lean,PowerSeries.coeff_zero_C,coeff_zero_C,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":=
  coeff_monomial_same 0 a","error:  type mismatch
  coeff_monomial_same 0 a
has type
  (coeff R 0) ((monomial R 0) a) = a : Prop
but is expected to have type
  (coeff R 0) ((C R) a) = a : Prop
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated",theorem coeff_zero_C (a : R) : coeff R 0 (C R a) = a ,":= by
  rw [coeff_C, if_pos rfl]"
Mathlib/Order/Monotone/Extension.lean,MonotoneOn.exists_monotone_extension,MonotoneOn.exists_monotone_extension,751f7c13f21c8209a7c021c922a9db93895d6b6c,":= by
  classical
    rcases hl with ‚ü®a, ha‚ü©
    have hu' : ‚àÄ x, BddAbove (f '' (Iic x ‚à© s)) := fun x =>
      hu.mono (image_subset _ (inter_subset_right _ _))
    let g : Œ± ‚Üí Œ≤ := fun x => if Disjoint (Iic x) s then a else sup‚Çõ (f '' (Iic x ‚à© s))
    have hgs : EqOn f g s := by
      intro x hx
      simp only []
      have : IsGreatest (Iic x ‚à© s) x := ‚ü®‚ü®right_mem_Iic, hx‚ü©, fun y hy => hy.1‚ü©
      rw [if_neg this.nonempty.not_disjoint,
        ((h.mono <| inter_subset_right _ _).map_isGreatest this).csup‚Çõ_eq]
    refine' ‚ü®g, fun x y hxy => _, hgs‚ü©
    by_cases hx : Disjoint (Iic x) s <;> by_cases hy : Disjoint (Iic y) s <;>
      simp only [if_pos, if_neg, not_false_iff, *, refl]
    ¬∑ rcases not_disjoint_iff_nonempty_inter.1 hy with ‚ü®z, hz‚ü©
      exact le_csup‚Çõ_of_le (hu' _) (mem_image_of_mem _ hz) (ha <| mem_image_of_mem _ hz.2)
    ¬∑ exact (hx <| hy.mono_left <| Iic_subset_Iic.2 hxy).elim
    ¬∑ rw [not_disjoint_iff_nonempty_inter] at hx hy
      refine' csup‚Çõ_le_csup‚Çõ (hu' _) (hx.image _) (image_subset _ _)
      exact inter_subset_inter_left _ (Iic_subset_Iic.2 hxy)","error:  function expected at
  inter_subset_right ?m.942
term has type
  ?m.941 ‚àà ?m.940
error:  unknown identifier 'sup‚Çõ'
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  application type mismatch
  not_disjoint_iff_nonempty_inter.mp hy
argument
  hy
has type
  Disjoint (Iic y) s : Prop
but is expected to have type
  ¬¨Disjoint ?m.3078 ?m.3079 : Prop
error:  unknown identifier 'le_csup‚Çõ_of_le'
error:  invalid field 'mono_left', the environment does not contain 'Not.mono_left'
  hy
has type
  ¬¨Disjoint (Iic y) s
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hy
has type
  Disjoint (Iic y) s ‚Üí False
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ¬¨Disjoint ?m.3335 ?m.3336
case pos
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬π : LinearOrder Œ±
inst‚úù : ConditionallyCompleteLinearOrder Œ≤
f : Œ± ‚Üí Œ≤
s : Set Œ±
a‚úù b : Œ±
h : MonotoneOn f s
hu : BddAbove (f '' s)
a : Œ≤
ha : a ‚àà lowerBounds (f '' s)
hu' : ‚àÄ (x : Œ±), BddAbove (f '' (Iic x ‚à© s))
g : Œ± ‚Üí Œ≤ := fun x ‚Ü¶ if Disjoint (Iic x) s then a else sorryAx Œ≤ true
hgs : EqOn f g s
x y : Œ±
hxy : x ‚â§ y
hx : (Iic x ‚à© s).Nonempty
hy : Disjoint (Iic y) s
‚ä¢ g x ‚â§ g y
error:  unsolved goals
case neg
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬π : LinearOrder Œ±
inst‚úù : ConditionallyCompleteLinearOrder Œ≤
f : Œ± ‚Üí Œ≤
s : Set Œ±
a‚úù b : Œ±
h : MonotoneOn f s
hu : BddAbove (f '' s)
a : Œ≤
ha : a ‚àà lowerBounds (f '' s)
hu' : ‚àÄ (x : Œ±), BddAbove (f '' (Iic x ‚à© s))
g : Œ± ‚Üí Œ≤ := fun x ‚Ü¶ if Disjoint (Iic x) s then a else sorryAx Œ≤ true
hgs : EqOn f g s
x y : Œ±
hxy : x ‚â§ y
hx : ¬¨Disjoint (Iic x) s
hy : ¬¨Disjoint (Iic y) s
‚ä¢ g x ‚â§ g y","theorem MonotoneOn.exists_monotone_extension (h : MonotoneOn f s) (hl : BddBelow (f '' s))
    (hu : BddAbove (f '' s)) : ‚àÉ g : Œ± ‚Üí Œ≤, Monotone g ‚àß EqOn f g s ",":= by
  classical
    rcases hl with ‚ü®a, ha‚ü©
    have hu' : ‚àÄ x, BddAbove (f '' (Iic x ‚à© s)) := fun x =>
      hu.mono (image_subset _ inter_subset_right)
    let g : Œ± ‚Üí Œ≤ := fun x => if Disjoint (Iic x) s then a else sSup (f '' (Iic x ‚à© s))
    have hgs : EqOn f g s := by
      intro x hx
      simp only [g]
      have : IsGreatest (Iic x ‚à© s) x := ‚ü®‚ü®right_mem_Iic, hx‚ü©, fun y hy => hy.1‚ü©
      rw [if_neg this.nonempty.not_disjoint,
        ((h.mono inter_subset_right).map_isGreatest this).csSup_eq]
    refine ‚ü®g, fun x y hxy => ?_, hgs‚ü©
    by_cases hx : Disjoint (Iic x) s <;> by_cases hy : Disjoint (Iic y) s <;>
      simp only [g, if_pos, if_neg, not_false_iff, *, refl]
    ¬∑ rcases not_disjoint_iff_nonempty_inter.1 hy with ‚ü®z, hz‚ü©
      exact le_csSup_of_le (hu' _) (mem_image_of_mem _ hz) (ha <| mem_image_of_mem _ hz.2)
    ¬∑ exact (hx <| hy.mono_left <| Iic_subset_Iic.2 hxy).elim
    ¬∑ rw [not_disjoint_iff_nonempty_inter] at hx hy
      refine csSup_le_csSup (hu' _) (hx.image _) (image_subset _ ?_)
      exact inter_subset_inter_left _ (Iic_subset_Iic.2 hxy)"
Mathlib/ModelTheory/Skolem.lean,FirstOrder.Language.exists_elementarySubstructure_card_eq,exists_elementarySubstructure_card_eq,2d8928f07c222f171d2f9371935aa5b8359f9d44,":= by
  obtain ‚ü®s', hs'‚ü© := Cardinal.le_mk_iff_exists_set.1 h4
  rw [‚Üê aleph0_le_lift.{_, w}] at h1
  rw [‚Üê hs'] at h1 h2 ‚ä¢
  refine'
    ‚ü®elementarySkolem‚ÇÅReduct (closure (L.sum L.skolem‚ÇÅ) (s ‚à™ Equiv.ulift '' s')),
      (s.subset_union_left _).trans subset_closure, _‚ü©
  have h := mk_image_eq_lift _ s' Equiv.ulift.injective
  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h
  rw [coeSort_elementarySkolem‚ÇÅReduct, ‚Üê h, lift_inj]
  refine'
    le_antisymm (lift_le.1 (lift_card_closure_le.trans _))
      (mk_le_mk_of_subset ((Set.subset_union_right _ _).trans subset_closure))
  rw [max_le_iff, aleph0_le_lift, ‚Üê aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]
  ¬∑ refine' ‚ü®h1, (mk_union_le _ _).trans _, (lift_le.2 card_functions_sum_skolem‚ÇÅ_le).trans _‚ü©
    ¬∑ rw [‚Üê lift_le, lift_add, h, add_comm, add_eq_max h1]
      exact max_le le_rfl h2
    ¬∑ rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, ‚Üê lift_le.{w'},
        lift_lift, lift_lift, ‚Üê aleph0_le_lift, h]
      refine' ‚ü®_, h1‚ü©
      rw [‚Üê lift_lift.{w', w}]
      refine' _root_.trans (lift_le.{w}.2 h3) _
      rw [lift_lift, ‚Üê lift_lift.{w, max u v}, ‚Üê hs', ‚Üê h, lift_lift]
  ¬∑ refine' _root_.trans _ (lift_le.2 (mk_le_mk_of_subset (Set.subset_union_right _ _)))
    rw [aleph0_le_lift, ‚Üê aleph0_le_lift, h]
    exact h1","error:  invalid field 'trans', the environment does not contain 'Membership.mem.trans'
  Set.subset_union_left ?m.26890
has type
  ?m.26889 ‚àà s ‚à™ ?m.26888
error:  invalid field 'trans', the environment does not contain 'Set.Mem.trans'
  Set.subset_union_left ?m.26890
has type
  Set.Mem ?m.26889 (s ‚à™ ?m.26888)
error:  invalid field 'trans', the environment does not contain 'Union.union.trans'
  Set.subset_union_left ?m.26890
has type
  (s ‚à™ ?m.26888) ?m.26889
error:  invalid field 'trans', the environment does not contain 'Set.union.trans'
  Set.subset_union_left ?m.26890
has type
  s.union ?m.26888 ?m.26889
error:  invalid field 'trans', the environment does not contain 'setOf.trans'
  Set.subset_union_left ?m.26890
has type
  {a | a ‚àà s ‚à® a ‚àà ?m.26888} ?m.26889
error:  invalid field 'trans', the environment does not contain 'Or.trans'
  Set.subset_union_left ?m.26890
has type
  ?m.26889 ‚àà s ‚à® ?m.26889 ‚àà ?m.26888
error:  function expected at
  Set.subset_union_right ?m.27688
term has type
  ?m.27687 ‚àà ?m.27685 ‚à™ ?m.27686
error:  function expected at
  Set.subset_union_right ?m.29978
term has type
  ?m.29977 ‚àà ?m.29975 ‚à™ ?m.29976","theorem exists_elementarySubstructure_card_eq (s : Set M) (Œ∫ : Cardinal.{w'}) (h1 : ‚Ñµ‚ÇÄ ‚â§ Œ∫)
    (h2 : Cardinal.lift.{w'} #s ‚â§ Cardinal.lift.{w} Œ∫)
    (h3 : Cardinal.lift.{w'} L.card ‚â§ Cardinal.lift.{max u v} Œ∫)
    (h4 : Cardinal.lift.{w} Œ∫ ‚â§ Cardinal.lift.{w'} #M) :
    ‚àÉ S : L.ElementarySubstructure M, s ‚äÜ S ‚àß Cardinal.lift.{w'} #S = Cardinal.lift.{w} Œ∫ ",":= by
  obtain ‚ü®s', hs'‚ü© := Cardinal.le_mk_iff_exists_set.1 h4
  rw [‚Üê aleph0_le_lift.{_, w}] at h1
  rw [‚Üê hs'] at h1 h2 ‚ä¢
  refine
    ‚ü®elementarySkolem‚ÇÅReduct (closure (L.sum L.skolem‚ÇÅ) (s ‚à™ Equiv.ulift '' s')),
      (s.subset_union_left).trans subset_closure, ?_‚ü©
  have h := mk_image_eq_lift _ s' Equiv.ulift.injective
  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h
  rw [coeSort_elementarySkolem‚ÇÅReduct, ‚Üê h, lift_inj]
  refine
    le_antisymm (lift_le.1 (lift_card_closure_le.trans ?_))
      (mk_le_mk_of_subset ((s.subset_union_right).trans subset_closure))
  rw [max_le_iff, aleph0_le_lift, ‚Üê aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]
  ¬∑ refine ‚ü®h1, (mk_union_le _ _).trans ?_, (lift_le.2 card_functions_sum_skolem‚ÇÅ_le).trans ?_‚ü©
    ¬∑ rw [‚Üê lift_le, lift_add, h, add_comm, add_eq_max h1]
      exact max_le le_rfl h2
    ¬∑ rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, ‚Üê lift_le.{w'},
        lift_lift, lift_lift, ‚Üê aleph0_le_lift, h]
      refine ‚ü®?_, h1‚ü©
      rw [‚Üê lift_lift.{w', w}]
      refine _root_.trans (lift_le.{w}.2 h3) ?_
      rw [lift_lift, ‚Üê lift_lift.{w, max u v}, ‚Üê hs', ‚Üê h, lift_lift]
  ¬∑ refine _root_.trans ?_ (lift_le.2 (mk_le_mk_of_subset Set.subset_union_right))
    rw [aleph0_le_lift, ‚Üê aleph0_le_lift, h]
    exact h1"
Mathlib/Geometry/Manifold/IntegralCurve.lean,IsIntegralCurveAt.comp_mul_ne_zero,IsIntegralCurveAt.comp_mul_ne_zero,7d7a7169c0c35b35c150a198dd8eaa2a47578e1d,":= by
  obtain ‚ü®Œµ, hŒµ, h‚ü© := isIntegralCurveAt_iff.mp hŒ≥
  rw [isIntegralCurveAt_iff]
  refine ‚ü®Œµ / |a|, by positivity, ?_‚ü©
  convert h.comp_mul a
  ext t
  rw [mem_setOf_eq, Metric.mem_ball, Metric.mem_ball, Real.dist_eq, Real.dist_eq,
    lt_div_iff (abs_pos.mpr ha), ‚Üê abs_mul, sub_mul, div_mul_cancel _ ha]","error:  failed to synthesize
  HDiv (Set ‚Ñù) ‚Ñù ?m.224149
use `set_option diagnostics true` to get diagnostic information
error:  not a positivity goal
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.225202 ‚àà Metric.ball ?m.225201 ?m.225203
case h.e'_13.h
E : Type u_1
inst‚úù‚Å∂ : NormedAddCommGroup E
inst‚úù‚Åµ : NormedSpace ‚Ñù E
inst‚úù‚Å¥ : CompleteSpace E
H : Type u_2
inst‚úù¬≥ : TopologicalSpace H
I : ModelWithCorners ‚Ñù E H
M : Type u_3
inst‚úù¬≤ : TopologicalSpace M
inst‚úù¬π : ChartedSpace H M
inst‚úù : SmoothManifoldWithCorners I M
Œ≥ Œ≥' : ‚Ñù ‚Üí M
v : (x : M) ‚Üí TangentSpace I x
s s' : Set ‚Ñù
t‚ÇÄ : ‚Ñù
hŒ≥ : IsIntegralCurveAt Œ≥ v t‚ÇÄ
a : ‚Ñù
ha : a ‚â† 0
Œµ : Set ‚Ñù
hŒµ : Œµ ‚àà ùìù t‚ÇÄ
h : IsIntegralCurveOn Œ≥ v Œµ
t : ‚Ñù
‚ä¢ t ‚àà sorryAx (Set ‚Ñù) true ‚Üî t * a ‚àà Œµ","lemma IsIntegralCurveAt.comp_mul_ne_zero (hŒ≥ : IsIntegralCurveAt Œ≥ v t‚ÇÄ) {a : ‚Ñù} (ha : a ‚â† 0) :
    IsIntegralCurveAt (Œ≥ ‚àò (¬∑ * a)) (a ‚Ä¢ v) (t‚ÇÄ / a) ",":= by
  rw [isIntegralCurveAt_iff'] at *
  obtain ‚ü®Œµ, hŒµ, h‚ü© := hŒ≥
  refine ‚ü®Œµ / |a|, by positivity, ?_‚ü©
  convert h.comp_mul a
  ext t
  rw [mem_setOf_eq, Metric.mem_ball, Metric.mem_ball, Real.dist_eq, Real.dist_eq,
    lt_div_iff (abs_pos.mpr ha), ‚Üê abs_mul, sub_mul, div_mul_cancel‚ÇÄ _ ha]"
Mathlib/Algebra/Order/Field/Power.lean,Even.zpow_pos_iff,Even.zpow_pos_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain ‚ü®k, rfl‚ü© := hn; exact zpow_bit0_pos_iff (by rintro rfl; simp at h)","error:  unknown identifier 'zpow_bit0_pos_iff'
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated",theorem Even.zpow_pos_iff (hn : Even n) (h : n ‚â† 0) : 0 < a ^ n ‚Üî a ‚â† 0 ,":= by
  obtain ‚ü®k, rfl‚ü© := hn
  rw [zpow_add' (by simp [em']), mul_self_pos, zpow_ne_zero_iff (by simpa using h)]"
Mathlib/Analysis/Complex/PhragmenLindelof.lean,PhragmenLindelof.horizontal_strip,horizontal_strip,e78bcd0f6da62739c580ef7cfadf16b23ff5d520,":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm
  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb
  wlog hC‚ÇÄ : 0 < C generalizing C
  ¬∑ refine' le_of_forall_le_of_dense fun C' hC' => this (fun w hw => _) (fun w hw => _) _
    ¬∑ exact (hle_a _ hw).trans hC'.le
    ¬∑ exact (hle_b _ hw).trans hC'.le
    ¬∑ refine' ((norm_nonneg (f (a * I))).trans (hle_a _ _)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=
    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB
  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with ‚ü®c, hc, B, hO‚ü©
  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)
  have hb' : d * b < œÄ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)
  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))
  suffices : ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C
  ¬∑ refine' le_of_tendsto (Tendsto.mono_left _ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ
  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :
    ‚àÉ Œ¥ : ‚Ñù,
      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by
    refine'
      ‚ü®Œµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Œµ‚ÇÄ
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),
        fun w hw => _‚ü©
    replace hw : |im (aff w)| ‚â§ d * b
    ¬∑ rw [‚Üê Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,
        mul_le_mul_left hd‚ÇÄ]
    simpa only [re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le
  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by
    refine' fun w hw => (hŒ¥ <| hw.by_cases _ _).trans (Real.exp_le_one_iff.2 _)
    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]
  obtain ‚ü®R, hzR, hR‚ü© :
    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by
    refine' ((eventually_gt_atTop _).and _).exists
    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,
      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices :
        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0)
    ¬∑ filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him
      calc
        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ ‚â§ C := hR
      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine' Real.tendsto_exp_atBot.comp _
    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0))
    ¬∑ rw [mul_zero, add_zero] at H
      refine' Tendsto.atBot_add _ tendsto_const_nhds
      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id
    refine' tendsto_const_nhds.add (tendsto_const_nhds.mul _)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable ‚ÑÇ (g Œµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b))
  exact (hgd.diffContOnCl.smul hfd).mono (inter_subset_right _ _)
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw
    by_cases him : w.im = a - b ‚à® w.im = a + b
    ¬∑ rw [norm_smul, ‚Üê one_mul C]
      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b); exact hw.resolve_left fun h => him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'
      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)
  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]
    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©",error:  unexpected token ':'; expected term,"theorem horizontal_strip (hfd : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo a b))
    (hB : ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo a b)]
      fun z ‚Ü¶ expR (B * expR (c * |z.re|)))
    (hle_a : ‚àÄ z : ‚ÑÇ, im z = a ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hle_b : ‚àÄ z, im z = b ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hza : a ‚â§ im z)
    (hzb : im z ‚â§ b) : ‚Äñf z‚Äñ ‚â§ C ",":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm
  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb
  wlog hC‚ÇÄ : 0 < C generalizing C
  ¬∑ refine le_of_forall_le_of_dense fun C' hC' => this (fun w hw => ?_) (fun w hw => ?_) ?_
    ¬∑ exact (hle_a _ hw).trans hC'.le
    ¬∑ exact (hle_b _ hw).trans hC'.le
    ¬∑ refine ((norm_nonneg (f (a * I))).trans (hle_a _ ?_)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=
    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB
  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with ‚ü®c, hc, B, hO‚ü©
  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)
  have hb' : d * b < œÄ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)
  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))
  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C by
    refine le_of_tendsto (Tendsto.mono_left ?_ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ
  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :
    ‚àÉ Œ¥ : ‚Ñù,
      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by
    refine
      ‚ü®Œµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Œµ‚ÇÄ
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),
        fun w hw => ?_‚ü©
    replace hw : |im (aff w)| ‚â§ d * b := by
      rw [‚Üê Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,
        mul_le_mul_left hd‚ÇÄ]
    simpa only [aff, re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le
  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by
    refine fun w hw => (hŒ¥ <| hw.by_cases ?_ ?_).trans (Real.exp_le_one_iff.2 ?_)
    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]
  obtain ‚ü®R, hzR, hR‚ü© :
    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by
    refine ((eventually_gt_atTop _).and ?_).exists
    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,
      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0) by
      filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him
      calc
        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ ‚â§ C := hR
      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine Real.tendsto_exp_atBot.comp ?_
    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine Tendsto.atBot_add ?_ tendsto_const_nhds
      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id
    refine tendsto_const_nhds.add (tendsto_const_nhds.mul ?_)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable ‚ÑÇ (g Œµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono inter_subset_right
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw
    by_cases him : w.im = a - b ‚à® w.im = a + b
    ¬∑ rw [norm_smul, ‚Üê one_mul C]
      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b) := hw.resolve_left fun h ‚Ü¶ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'
      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)
  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]
    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©"
Mathlib/Algebra/Lie/CartanExists.lean,LieAlgebra.engel_isBot_of_isMin,engel_isBot_of_isMin,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases E with ‚ü®_, x, hxU, rfl‚ü©
  rintro ‚ü®_, y, hyU, rfl‚ü©
  set Ex : {engel K x | x ‚àà U} := ‚ü®engel K x, x, hxU, rfl‚ü©
  set Ey : {engel K y | y ‚àà U} := ‚ü®engel K y, y, hyU, rfl‚ü©
  replace hUle : U ‚â§ Ex := hUle
  replace hmin : ‚àÄ E, E ‚â§ Ex ‚Üí Ex ‚â§ E := @hmin
  let E : LieSubmodule K U L :=
  { engel K x with
    lie_mem := by rintro ‚ü®u, hu‚ü© y hy; exact (engel K x).lie_mem (hUle hu) hy }
  obtain rfl|hx‚ÇÄ := eq_or_ne x 0
  ¬∑ simpa [Ex, Ey] using hmin Ey
  let Q := L ‚ß∏ E
  let r := finrank K E
  obtain hr|hr : r = finrank K L ‚à® r < finrank K L := (Submodule.finrank_le _).eq_or_lt
  ¬∑ suffices engel K y ‚â§ engel K x from hmin Ey this
    suffices engel K x = ‚ä§ by simp_rw [this, le_top]
    apply LieSubalgebra.to_submodule_injective
    apply Submodule.eq_top_of_finrank_eq hr
  set x' : U := ‚ü®x, hxU‚ü©
  set y' : U := ‚ü®y, hyU‚ü©
  let u : U := y' - x'
  let œá : Polynomial (K[X]) := lieCharpoly K E x' u
  let œà : Polynomial (K[X]) := lieCharpoly K Q x' u
  suffices œá = X ^ r by
    apply_fun (fun p ‚Ü¶ p.map (evalRingHom 1)) at this
    simp_rw [Polynomial.map_pow, map_X, œá, lieCharpoly_map_eval, one_smul, u, sub_add_cancel,
      r, LinearMap.charpoly_eq_X_pow_iff,
      Subtype.ext_iff, coe_toEnd_pow, ZeroMemClass.coe_zero] at this
    intro z hz
    rw [mem_engel_iff]
    exact this ‚ü®z, hz‚ü©
  suffices ‚àÄ i < r, œá.coeff i = 0 by
    simp_rw [r, ‚Üê lieCharpoly_natDegree K E x' u] at this ‚ä¢
    rw [(lieCharpoly_monic K E x' u).eq_X_pow_iff_natDegree_le_natTrailingDegree]
    exact le_natTrailingDegree (lieCharpoly_monic K E x' u).ne_zero this
  intro i hi
  obtain rfl|hi0 := eq_or_ne i 0
  ¬∑ 
    apply eq_zero_of_forall_eval_zero_of_natDegree_lt_card _ _ ?deg
    case deg =>
      apply lt_of_lt_of_le _ hLK
      rw [Nat.cast_lt]
      apply lt_of_le_of_lt _ hr
      apply lieCharpoly_coeff_natDegree _ _ _ _ 0 r (zero_add r)
    intro Œ±
    rw [‚Üê coe_evalRingHom, ‚Üê coeff_map, lieCharpoly_map_eval,
      ‚Üê constantCoeff_apply, LinearMap.charpoly_constantCoeff_eq_zero_iff]
    let z := Œ± ‚Ä¢ u + x'
    obtain hz‚ÇÄ|hz‚ÇÄ := eq_or_ne z 0
    ¬∑ 
      refine ‚ü®‚ü®x, self_mem_engel K x‚ü©, ?_, ?_‚ü©
      ¬∑ simpa [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero] using hx‚ÇÄ
      ¬∑ dsimp only [z] at hz‚ÇÄ
        simp only [coe_bracket_of_module, hz‚ÇÄ, LieHom.map_zero, LinearMap.zero_apply]
    refine ‚ü®‚ü®z, hUle z.2‚ü©, ?_, ?_‚ü©
    ¬∑ simpa only [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero, Subtype.ext_iff] using hz‚ÇÄ
    ¬∑ show ‚ÅÖz, _‚ÅÜ = (0 : E)
      ext
      exact lie_self z.1
  have hœà : constantCoeff œà ‚â† 0 := by
    intro H
    obtain ‚ü®z, hz0, hxz‚ü© : ‚àÉ z : Q, z ‚â† 0 ‚àß ‚ÅÖx', z‚ÅÜ = 0 := by
      apply_fun (evalRingHom 0) at H
      rw [constantCoeff_apply, ‚Üê coeff_map, lieCharpoly_map_eval,
        ‚Üê constantCoeff_apply, map_zero, LinearMap.charpoly_constantCoeff_eq_zero_iff] at H
      simpa only [coe_bracket_of_module, ne_eq, zero_smul, zero_add, toEnd_apply_apply]
        using H
    apply hz0
    obtain ‚ü®z, rfl‚ü© := LieSubmodule.Quotient.surjective_mk' E z
    have : ‚ÅÖx, z‚ÅÜ ‚àà E := by rwa [‚Üê LieSubmodule.Quotient.mk_eq_zero']
    simp only [coe_bracket_of_module, LieSubmodule.mem_mk_iff', mem_coe_submodule, mem_engel_iff,
      LieSubmodule.Quotient.mk'_apply, LieSubmodule.Quotient.mk_eq_zero', E, Q] at this ‚ä¢
    obtain ‚ü®n, hn‚ü© := this
    use n+1
    rwa [pow_succ]
  obtain ‚ü®s, hs, hsœà‚ü© : ‚àÉ s : Finset K, r ‚â§ s.card ‚àß ‚àÄ Œ± ‚àà s, (constantCoeff œà).eval Œ± ‚â† 0 := by
    classical
    let t := (constantCoeff œà).roots.toFinset
    have ht : t.card ‚â§ finrank K L - r := by
      refine (Multiset.toFinset_card_le _).trans ?_
      refine (card_roots' _).trans ?_
      rw [constantCoeff_apply]
      apply lieCharpoly_coeff_natDegree
      suffices finrank K Q + r = finrank K L by rw [‚Üê this, zero_add, Nat.add_sub_cancel]
      apply Submodule.finrank_quotient_add_finrank
    obtain ‚ü®s, hs‚ü© := exists_finset_le_card K _ hLK
    use s \ t
    refine ‚ü®?_, ?_‚ü©
    ¬∑ refine le_trans ?_ (Finset.le_card_sdiff _ _)
      omega
    ¬∑ intro Œ± hŒ±
      simp only [Finset.mem_sdiff, Multiset.mem_toFinset, mem_roots', IsRoot.def, not_and, t] at hŒ±
      exact hŒ±.2 hœà
  apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero' _ s _ ?hcard
  case hcard =>
    apply lt_of_le_of_lt (lieCharpoly_coeff_natDegree _ _ _ _ i (r - i) _)
    ¬∑ omega
    ¬∑ dsimp only [r] at hi ‚ä¢
      rw [Nat.add_sub_cancel' hi.le]
  intro Œ± hŒ±
  rw [‚Üê coe_evalRingHom, ‚Üê coeff_map, lieCharpoly_map_eval,
    (LinearMap.charpoly_eq_X_pow_iff _).mpr, coeff_X_pow, if_neg hi.ne]
  let v := Œ± ‚Ä¢ u + x'
  suffices engel K (v : L) ‚â§ engel K x by
    replace this : engel K x ‚â§ engel K (v : L) := (hmin ‚ü®_, v, v.2, rfl‚ü© this).ge
    intro z
    simpa only [mem_engel_iff, Subtype.ext_iff, coe_toEnd_pow] using this z.2
  intro z hz
  show z ‚àà E
  rw [‚Üê LieSubmodule.Quotient.mk_eq_zero]
  set z' : Q := LieSubmodule.Quotient.mk' E z
  have hz' : ‚àÉ n : ‚Ñï, (toEnd K U Q v ^ n) z' = 0 := by
    rw [mem_engel_iff] at hz
    obtain ‚ü®n, hn‚ü© := hz
    use n
    apply_fun LieSubmodule.Quotient.mk' E at hn
    rw [LieModuleHom.map_zero] at hn
    rw [‚Üê hn]
    clear hn
    induction n with
    | zero => simp only [Nat.zero_eq, pow_zero, LinearMap.one_apply]
    | succ n ih => rw [pow_succ', pow_succ', LinearMap.mul_apply, ih]; rfl
  classical
  set n := Nat.find hz' with _hn
  have hn : (toEnd K U Q v ^ n) z' = 0 := Nat.find_spec hz'
  obtain hn‚ÇÄ|‚ü®k, hk‚ü© : n = 0 ‚à® ‚àÉ k, n = k + 1 := by cases n <;> simp
  ¬∑ simpa only [hn‚ÇÄ, pow_zero, LinearMap.one_apply] using hn
  specialize hsœà Œ± hŒ±
  rw [‚Üê coe_evalRingHom, constantCoeff_apply, ‚Üê coeff_map, lieCharpoly_map_eval,
    ‚Üê constantCoeff_apply, ne_eq, LinearMap.charpoly_constantCoeff_eq_zero_iff] at hsœà
  contrapose! hsœà
  use (toEnd K U Q v ^ k) z'
  refine ‚ü®?_, ?_‚ü©
  ¬∑ 
    apply Nat.find_min hz'; omega
  ¬∑ rw [‚Üê hn, hk, pow_succ', LinearMap.mul_apply]","error:  simp made no progress
error:  type mismatch
  h‚úù
has type
  ‚àÉ n, ((ad K L) ‚Üëv ^ n) ‚Üëz = 0 : Prop
but is expected to have type
  ‚àÉ n, ‚Üë(((toEnd K ‚Ü•U ‚Ü•(engel K x).toSubmodule) (Œ± ‚Ä¢ u + x') ^ n) z) = ‚Üë0 : Prop","lemma engel_isBot_of_isMin (hLK : finrank K L ‚â§ #K) (U : LieSubalgebra K L)
    (E : {engel K x | x ‚àà U}) (hUle : U ‚â§ E) (hmin : IsMin E) :
    IsBot E ",":= by
  rcases E with ‚ü®_, x, hxU, rfl‚ü©
  rintro ‚ü®_, y, hyU, rfl‚ü©
  set Ex : {engel K x | x ‚àà U} := ‚ü®engel K x, x, hxU, rfl‚ü©
  set Ey : {engel K y | y ‚àà U} := ‚ü®engel K y, y, hyU, rfl‚ü©
  replace hUle : U ‚â§ Ex := hUle
  replace hmin : ‚àÄ E, E ‚â§ Ex ‚Üí Ex ‚â§ E := @hmin
  let E : LieSubmodule K U L :=
  { engel K x with
    lie_mem := by rintro ‚ü®u, hu‚ü© y hy; exact (engel K x).lie_mem (hUle hu) hy }
  obtain rfl|hx‚ÇÄ := eq_or_ne x 0
  ¬∑ simpa [Ex, Ey] using hmin Ey
  let Q := L ‚ß∏ E
  let r := finrank K E
  obtain hr|hr : r = finrank K L ‚à® r < finrank K L := (Submodule.finrank_le _).eq_or_lt
  ¬∑ suffices engel K y ‚â§ engel K x from hmin Ey this
    suffices engel K x = ‚ä§ by simp_rw [this, le_top]
    apply LieSubalgebra.to_submodule_injective
    apply Submodule.eq_top_of_finrank_eq hr
  set x' : U := ‚ü®x, hxU‚ü©
  set y' : U := ‚ü®y, hyU‚ü©
  let u : U := y' - x'
  let œá : Polynomial (K[X]) := lieCharpoly K E x' u
  let œà : Polynomial (K[X]) := lieCharpoly K Q x' u
  suffices œá = X ^ r by
    apply_fun (fun p ‚Ü¶ p.map (evalRingHom 1)) at this
    simp_rw [Polynomial.map_pow, map_X, œá, lieCharpoly_map_eval, one_smul, u, sub_add_cancel,
      r, LinearMap.charpoly_eq_X_pow_iff,
      Subtype.ext_iff, coe_toEnd_pow _ _ _ E, ZeroMemClass.coe_zero] at this
    intro z hz
    rw [mem_engel_iff]
    exact this ‚ü®z, hz‚ü©
  suffices ‚àÄ i < r, œá.coeff i = 0 by
    simp_rw [r, ‚Üê lieCharpoly_natDegree K E x' u] at this ‚ä¢
    rw [(lieCharpoly_monic K E x' u).eq_X_pow_iff_natDegree_le_natTrailingDegree]
    exact le_natTrailingDegree (lieCharpoly_monic K E x' u).ne_zero this
  intro i hi
  obtain rfl|hi0 := eq_or_ne i 0
  ¬∑ 
    apply eq_zero_of_forall_eval_zero_of_natDegree_lt_card _ _ ?deg
    case deg =>
      apply lt_of_lt_of_le _ hLK
      rw [Nat.cast_lt]
      apply lt_of_le_of_lt _ hr
      apply lieCharpoly_coeff_natDegree _ _ _ _ 0 r (zero_add r)
    intro Œ±
    rw [‚Üê coe_evalRingHom, ‚Üê coeff_map, lieCharpoly_map_eval,
      ‚Üê constantCoeff_apply, LinearMap.charpoly_constantCoeff_eq_zero_iff]
    let z := Œ± ‚Ä¢ u + x'
    obtain hz‚ÇÄ|hz‚ÇÄ := eq_or_ne z 0
    ¬∑ 
      refine ‚ü®‚ü®x, self_mem_engel K x‚ü©, ?_, ?_‚ü©
      ¬∑ simpa [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero] using hx‚ÇÄ
      ¬∑ dsimp only [z] at hz‚ÇÄ
        simp only [coe_bracket_of_module, hz‚ÇÄ, LieHom.map_zero, LinearMap.zero_apply]
    refine ‚ü®‚ü®z, hUle z.2‚ü©, ?_, ?_‚ü©
    ¬∑ simpa only [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero, Subtype.ext_iff] using hz‚ÇÄ
    ¬∑ show ‚ÅÖz, _‚ÅÜ = (0 : E)
      ext
      exact lie_self z.1
  have hœà : constantCoeff œà ‚â† 0 := by
    intro H
    obtain ‚ü®z, hz0, hxz‚ü© : ‚àÉ z : Q, z ‚â† 0 ‚àß ‚ÅÖx', z‚ÅÜ = 0 := by
      apply_fun (evalRingHom 0) at H
      rw [constantCoeff_apply, ‚Üê coeff_map, lieCharpoly_map_eval,
        ‚Üê constantCoeff_apply, map_zero, LinearMap.charpoly_constantCoeff_eq_zero_iff] at H
      simpa only [coe_bracket_of_module, ne_eq, zero_smul, zero_add, toEnd_apply_apply]
        using H
    apply hz0
    obtain ‚ü®z, rfl‚ü© := LieSubmodule.Quotient.surjective_mk' E z
    have : ‚ÅÖx, z‚ÅÜ ‚àà E := by rwa [‚Üê LieSubmodule.Quotient.mk_eq_zero']
    simp only [coe_bracket_of_module, LieSubmodule.mem_mk_iff', mem_coe_submodule, mem_engel_iff,
      LieSubmodule.Quotient.mk'_apply, LieSubmodule.Quotient.mk_eq_zero', E, Q] at this ‚ä¢
    obtain ‚ü®n, hn‚ü© := this
    use n+1
    rwa [pow_succ]
  obtain ‚ü®s, hs, hsœà‚ü© : ‚àÉ s : Finset K, r ‚â§ s.card ‚àß ‚àÄ Œ± ‚àà s, (constantCoeff œà).eval Œ± ‚â† 0 := by
    classical
    let t := (constantCoeff œà).roots.toFinset
    have ht : t.card ‚â§ finrank K L - r := by
      refine (Multiset.toFinset_card_le _).trans ?_
      refine (card_roots' _).trans ?_
      rw [constantCoeff_apply]
      apply lieCharpoly_coeff_natDegree
      suffices finrank K Q + r = finrank K L by rw [‚Üê this, zero_add, Nat.add_sub_cancel]
      apply Submodule.finrank_quotient_add_finrank
    obtain ‚ü®s, hs‚ü© := exists_finset_le_card K _ hLK
    use s \ t
    refine ‚ü®?_, ?_‚ü©
    ¬∑ refine le_trans ?_ (Finset.le_card_sdiff _ _)
      omega
    ¬∑ intro Œ± hŒ±
      simp only [Finset.mem_sdiff, Multiset.mem_toFinset, mem_roots', IsRoot.def, not_and, t] at hŒ±
      exact hŒ±.2 hœà
  apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero' _ s _ ?hcard
  case hcard =>
    apply lt_of_le_of_lt (lieCharpoly_coeff_natDegree _ _ _ _ i (r - i) _)
    ¬∑ omega
    ¬∑ dsimp only [r] at hi ‚ä¢
      rw [Nat.add_sub_cancel' hi.le]
  intro Œ± hŒ±
  rw [‚Üê coe_evalRingHom, ‚Üê coeff_map, lieCharpoly_map_eval,
    (LinearMap.charpoly_eq_X_pow_iff _).mpr, coeff_X_pow, if_neg hi.ne]
  let v := Œ± ‚Ä¢ u + x'
  suffices engel K (v : L) ‚â§ engel K x by
    replace this : engel K x ‚â§ engel K (v : L) := (hmin ‚ü®_, v, v.2, rfl‚ü© this).ge
    intro z
    simpa only [mem_engel_iff, Subtype.ext_iff, coe_toEnd_pow _ _ _ E] using this z.2
  intro z hz
  show z ‚àà E
  rw [‚Üê LieSubmodule.Quotient.mk_eq_zero]
  set z' : Q := LieSubmodule.Quotient.mk' E z
  have hz' : ‚àÉ n : ‚Ñï, (toEnd K U Q v ^ n) z' = 0 := by
    rw [mem_engel_iff] at hz
    obtain ‚ü®n, hn‚ü© := hz
    use n
    apply_fun LieSubmodule.Quotient.mk' E at hn
    rw [LieModuleHom.map_zero] at hn
    rw [‚Üê hn]
    clear hn
    induction n with
    | zero => simp only [Nat.zero_eq, pow_zero, LinearMap.one_apply]
    | succ n ih => rw [pow_succ', pow_succ', LinearMap.mul_apply, ih]; rfl
  classical
  set n := Nat.find hz' with _hn
  have hn : (toEnd K U Q v ^ n) z' = 0 := Nat.find_spec hz'
  obtain hn‚ÇÄ|‚ü®k, hk‚ü© : n = 0 ‚à® ‚àÉ k, n = k + 1 := by cases n <;> simp
  ¬∑ simpa only [hn‚ÇÄ, pow_zero, LinearMap.one_apply] using hn
  specialize hsœà Œ± hŒ±
  rw [‚Üê coe_evalRingHom, constantCoeff_apply, ‚Üê coeff_map, lieCharpoly_map_eval,
    ‚Üê constantCoeff_apply, ne_eq, LinearMap.charpoly_constantCoeff_eq_zero_iff] at hsœà
  contrapose! hsœà
  use (toEnd K U Q v ^ k) z'
  refine ‚ü®?_, ?_‚ü©
  ¬∑ 
    apply Nat.find_min hz'; omega
  ¬∑ rw [‚Üê hn, hk, pow_succ', LinearMap.mul_apply]"
Mathlib/Data/Fintype/Option.lean,Finite.induction_empty_option,Finite.induction_empty_option,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  cases nonempty_fintype Œ±
  refine Fintype.induction_empty_option ?_? ?_ _ Œ±
  exacts [fun Œ± Œ≤ _ => of_equiv, h_empty, @h_option]","error:  don't know how to synthesize placeholder
context:
Œ±‚úù : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
P : Type u ‚Üí Prop
of_equiv : ‚àÄ {Œ± Œ≤ : Type u}, Œ± ‚âÉ Œ≤ ‚Üí P Œ± ‚Üí P Œ≤
h_empty : P PEmpty.{u + 1}
h_option : ‚àÄ {Œ± : Type u} [inst : Fintype Œ±], P Œ± ‚Üí P (Option Œ±)
Œ± : Type u
inst‚úù : Finite Œ±
val‚úù : Fintype Œ±
‚ä¢ ‚àÄ (Œ± : Type u) [inst : Fintype Œ±], P Œ± ‚Üí P (Option Œ±)
error:  unsolved goals
case intro
Œ±‚úù : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
P : Type u ‚Üí Prop
of_equiv : ‚àÄ {Œ± Œ≤ : Type u}, Œ± ‚âÉ Œ≤ ‚Üí P Œ± ‚Üí P Œ≤
h_empty : P PEmpty.{u + 1}
h_option : ‚àÄ {Œ± : Type u} [inst : Fintype Œ±], P Œ± ‚Üí P (Option Œ±)
Œ± : Type u
inst‚úù : Finite Œ±
val‚úù : Fintype Œ±
‚ä¢ P Œ±","theorem Finite.induction_empty_option {P : Type u ‚Üí Prop} (of_equiv : ‚àÄ {Œ± Œ≤}, Œ± ‚âÉ Œ≤ ‚Üí P Œ± ‚Üí P Œ≤)
    (h_empty : P PEmpty) (h_option : ‚àÄ {Œ±} [Fintype Œ±], P Œ± ‚Üí P (Option Œ±)) (Œ± : Type u)
    [Finite Œ±] : P Œ± ",":= by
  cases nonempty_fintype Œ±
  refine Fintype.induction_empty_option ?_ ?_ ?_ Œ±
  exacts [fun Œ± Œ≤ _ => of_equiv, h_empty, @h_option]"
Mathlib/Topology/Category/Stonean/Basic.lean,Stonean.epi_iff_surjective,epi_iff_surjective,e2426ff5dc46051d5747537177e0e66c5dc771e7,":= by
  refine ‚ü®?_, ConcreteCategory.epi_of_surjective _‚ü©
  dsimp [Function.Surjective]
  intro h y
  by_contra' hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := C·∂ú
  have hUy : U ‚àà nhds y := by
    simp only [Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain ‚ü®V, hV, hyV, hVU‚ü© := isTopologicalBasis_clopen.mem_nhds_iff.mp hUy
  classical
  let g : Y ‚ü∂ mkFinite (ULift (Fin 2)) :=
    ‚ü®(LocallyConstant.ofClopen hV).map ULift.up, LocallyConstant.continuous _‚ü©
  let h : Y ‚ü∂ mkFinite (ULift (Fin 2)) := ‚ü®fun _ => ‚ü®1‚ü©, continuous_const‚ü©
  have H : h = g := by
    rw [‚Üê cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU ¬∑) ?_ 
    simpa only [Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H","error:  unknown tactic
error:  unsolved goals
X Y : Stonean
f : X ‚ü∂ Y
h : Epi f
y : CoeSort.coe Y
‚ä¢ ‚àÉ a, f a = y","lemma epi_iff_surjective {X Y : Stonean} (f : X ‚ü∂ Y) :
    Epi f ‚Üî Function.Surjective f ",":= by
  refine ‚ü®?_, ConcreteCategory.epi_of_surjective _‚ü©
  dsimp [Function.Surjective]
  intro h y
  by_contra! hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := C·∂ú
  have hUy : U ‚àà ùìù y := by
    simp only [C, Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain ‚ü®V, hV, hyV, hVU‚ü© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy
  classical
  let g : Y ‚ü∂ mkFinite (ULift (Fin 2)) :=
    ‚ü®(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _‚ü©
  let h : Y ‚ü∂ mkFinite (ULift (Fin 2)) := ‚ü®fun _ => ‚ü®1‚ü©, continuous_const‚ü©
  have H : h = g := by
    rw [‚Üê cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU ¬∑) ?_ 
    simpa only [U, Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,2d8928f07c222f171d2f9371935aa5b8359f9d44,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a
  ¬∑ exact ‚ü®_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b
  ¬∑ exact ‚ü®_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine' ‚ü®g + dg, fun y => _, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine' (lt_add_iff_pos_right _).2 _
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine' ‚ü®x, hxy.le, _‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine' ‚ü®g - dg, fun y => _, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine' (sub_lt_self_iff _).2 _
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine' ‚ü®x, xu, _, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine' ‚ü®xl y, xu, _, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]","error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/Data/Nat/Pairing.lean,Nat.max_sq_add_min_le_pair,max_sq_add_min_le_pair,e340032faef5a8ec252e988e6968b4f6b30277da,":= by
  rw [pair]
  cases' lt_or_le m n with h h
  ¬∑ rw [if_pos h, max_eq_right h.le, min_eq_left h.le, Nat.pow_two]
  rw [if_neg h.not_lt, max_eq_left h, min_eq_right h, Nat.pow_two, ‚Üê Nat.add_assoc',
    Nat.add_le_add_iff_left]
  exact Nat.le_add_left _ _","error:  unknown constant 'Nat.add_assoc''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.26470
case inr
m n : ‚Ñï
h : n ‚â§ m
‚ä¢ m * m + n ‚â§ m * m + m + n",theorem max_sq_add_min_le_pair (m n : ‚Ñï) : max m n ^ 2 + min m n ‚â§ pair m n ,":= by
  rw [pair]
  cases' lt_or_le m n with h h
  ¬∑ rw [if_pos h, max_eq_right h.le, min_eq_left h.le, Nat.pow_two]
  rw [if_neg h.not_lt, max_eq_left h, min_eq_right h, Nat.pow_two, Nat.add_assoc,
    Nat.add_le_add_iff_left]
  exact Nat.le_add_left _ _"
Mathlib/LinearAlgebra/QuadraticForm/Basic.lean,QuadraticForm.polar_zero_left,polar_zero_left,18f1e3ee387a3d040ba88fad8882f979755c163f,":= by
  simp only [polar, zero_add, QuadraticMap.map_zero, sub_zero, sub_self]","error:  unknown identifier 'QuadraticMap.map_zero'
error:  unsolved goals
S : Type u_1
T : Type u_2
R : Type u_3
M : Type u_4
N : Type u_5
inst‚úù¬≤ : CommRing R
inst‚úù¬π : AddCommGroup M
inst‚úù : Module R M
Q : QuadraticForm R M
y : M
‚ä¢ Q y - Q 0 - Q y = 0",theorem polar_zero_left (y : M) : polar Q 0 y = 0 ,":= by
  simp only [polar, zero_add, QuadraticForm.map_zero, sub_zero, sub_self]"
Mathlib/Geometry/Euclidean/MongePoint.lean,Affine.Triangle.altitude_replace_orthocenter_eq_affineSpan,altitude_replace_orthocenter_eq_affineSpan,0f24aee7da46f85fee5cacc716172444ce31e582,":= by
  symm
  rw [‚Üê h‚ÇÇ, t‚ÇÇ.affineSpan_pair_eq_altitude_iff]
  rw [h‚ÇÇ]
  use t‚ÇÅ.Independent.injective.ne hi‚ÇÅ‚ÇÇ
  have he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points) := by
    refine' ext_of_direction_eq _
      ‚ü®t‚ÇÅ.points i‚ÇÉ, mem_affineSpan ‚Ñù ‚ü®j‚ÇÉ, h‚ÇÉ‚ü©, mem_affineSpan ‚Ñù (Set.mem_range_self _)‚ü©
    refine' eq_of_le_of_finrank_eq (direction_le (spanPoints_subset_coe_of_subset_coe _)) _
    ¬∑ have hu : (Finset.univ : Finset (Fin 3)) = {j‚ÇÅ, j‚ÇÇ, j‚ÇÉ} := by
        clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
        fin_cases j‚ÇÅ <;> fin_cases j‚ÇÇ <;> fin_cases j‚ÇÉ <;> simp at hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ ‚ä¢
      rw [‚Üê Set.image_univ, ‚Üê Finset.coe_univ, hu, Finset.coe_insert, Finset.coe_insert,
        Finset.coe_singleton, Set.image_insert_eq, Set.image_insert_eq, Set.image_singleton, h‚ÇÅ, h‚ÇÇ,
        h‚ÇÉ, Set.insert_subset_iff, Set.insert_subset_iff, Set.singleton_subset_iff]
      exact
        ‚ü®t‚ÇÅ.orthocenter_mem_affineSpan, mem_affineSpan ‚Ñù (Set.mem_range_self _),
          mem_affineSpan ‚Ñù (Set.mem_range_self _)‚ü©
    ¬∑ rw [direction_affineSpan, direction_affineSpan,
        t‚ÇÅ.Independent.finrank_vectorSpan (Fintype.card_fin _),
        t‚ÇÇ.Independent.finrank_vectorSpan (Fintype.card_fin _)]
  rw [he]
  use mem_affineSpan ‚Ñù (Set.mem_range_self _)
  have hu : Finset.univ.erase j‚ÇÇ = {j‚ÇÅ, j‚ÇÉ} := by
    clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
    fin_cases j‚ÇÅ <;> fin_cases j‚ÇÇ <;> fin_cases j‚ÇÉ <;> simp at hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ ‚ä¢
  rw [hu, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton, h‚ÇÅ, h‚ÇÉ]
  have hle : (t‚ÇÅ.altitude i‚ÇÉ).direction·óÆ ‚â§ line[‚Ñù, t‚ÇÅ.orthocenter, t‚ÇÅ.points i‚ÇÉ].direction·óÆ :=
    Submodule.orthogonal_le (direction_le (affineSpan_orthocenter_point_le_altitude _ _))
  refine' hle ((t‚ÇÅ.vectorSpan_isOrtho_altitude_direction i‚ÇÉ) _)
  have hui : Finset.univ.erase i‚ÇÉ = {i‚ÇÅ, i‚ÇÇ} := by
    clear hle h‚ÇÇ h‚ÇÉ
    fin_cases i‚ÇÅ <;> fin_cases i‚ÇÇ <;> fin_cases i‚ÇÉ <;> simp at hi‚ÇÅ‚ÇÇ hi‚ÇÅ‚ÇÉ hi‚ÇÇ‚ÇÉ ‚ä¢
  rw [hui, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton]
  refine' vsub_mem_vectorSpan ‚Ñù (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_singleton _))","error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t‚ÇÅ
has type
  Triangle ‚Ñù P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t‚ÇÅ
has type
  Simplex ‚Ñù P 2
error:  unsolved goals
case head.tail.head.tail.tail.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ : True
‚ä¢ univ = {0, 1, 2}

case head.tail.tail.head.tail.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ : True
‚ä¢ univ = {0, 2, 1}

case tail.head.head.tail.tail.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ : True
‚ä¢ univ = {1, 0, 2}

case tail.head.tail.tail.head.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ : True
‚ä¢ univ = {1, 2, 0}

case tail.tail.head.head.tail.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ : True
‚ä¢ univ = {2, 0, 1}

case tail.tail.head.tail.head.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ : True
‚ä¢ univ = {2, 1, 0}
error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t‚ÇÅ
has type
  Triangle ‚Ñù P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t‚ÇÅ
has type
  Simplex ‚Ñù P 2
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.395181
case refine'_2
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ j‚ÇÅ j‚ÇÇ j‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
hj‚ÇÅ‚ÇÇ : j‚ÇÅ ‚â† j‚ÇÇ
hj‚ÇÅ‚ÇÉ : j‚ÇÅ ‚â† j‚ÇÉ
hj‚ÇÇ‚ÇÉ : j‚ÇÇ ‚â† j‚ÇÉ
h‚ÇÅ : t‚ÇÇ.points j‚ÇÅ = t‚ÇÅ.orthocenter
h‚ÇÇ : t‚ÇÇ.points j‚ÇÇ = t‚ÇÅ.points i‚ÇÇ
h‚ÇÉ : t‚ÇÇ.points j‚ÇÉ = t‚ÇÅ.points i‚ÇÉ
‚ä¢ finrank ‚Ñù ‚Ü•(vectorSpan ‚Ñù (Set.range t‚ÇÇ.points)) = finrank ‚Ñù ‚Ü•(vectorSpan ‚Ñù (Set.range t‚ÇÅ.points))
error:  unsolved goals
case head.tail.head.tail.tail.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points)
hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ : True
‚ä¢ univ.erase 1 = {0, 2}

case head.tail.tail.head.tail.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points)
hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ : True
‚ä¢ univ.erase 2 = {0, 1}

case tail.head.head.tail.tail.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points)
hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ : True
‚ä¢ univ.erase 0 = {1, 2}

case tail.head.tail.tail.head.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points)
hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ : True
‚ä¢ univ.erase 2 = {1, 0}

case tail.tail.head.head.tail.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points)
hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ : True
‚ä¢ univ.erase 0 = {2, 1}

case tail.tail.head.tail.head.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points)
hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ : True
‚ä¢ univ.erase 1 = {2, 0}
error:  unsolved goals
case head.tail.head.tail.tail.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
j‚ÇÅ j‚ÇÇ j‚ÇÉ : Fin 3
hj‚ÇÅ‚ÇÇ : j‚ÇÅ ‚â† j‚ÇÇ
hj‚ÇÅ‚ÇÉ : j‚ÇÅ ‚â† j‚ÇÉ
hj‚ÇÇ‚ÇÉ : j‚ÇÇ ‚â† j‚ÇÉ
h‚ÇÅ : t‚ÇÇ.points j‚ÇÅ = t‚ÇÅ.orthocenter
he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points)
hu : univ.erase j‚ÇÇ = {j‚ÇÅ, j‚ÇÉ}
hi‚ÇÅ‚ÇÇ hi‚ÇÅ‚ÇÉ hi‚ÇÇ‚ÇÉ : True
‚ä¢ univ.erase 2 = {0, 1}

case head.tail.tail.head.tail.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
j‚ÇÅ j‚ÇÇ j‚ÇÉ : Fin 3
hj‚ÇÅ‚ÇÇ : j‚ÇÅ ‚â† j‚ÇÇ
hj‚ÇÅ‚ÇÉ : j‚ÇÅ ‚â† j‚ÇÉ
hj‚ÇÇ‚ÇÉ : j‚ÇÇ ‚â† j‚ÇÉ
h‚ÇÅ : t‚ÇÇ.points j‚ÇÅ = t‚ÇÅ.orthocenter
he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points)
hu : univ.erase j‚ÇÇ = {j‚ÇÅ, j‚ÇÉ}
hi‚ÇÅ‚ÇÇ hi‚ÇÅ‚ÇÉ hi‚ÇÇ‚ÇÉ : True
‚ä¢ univ.erase 1 = {0, 2}

case tail.head.head.tail.tail.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
j‚ÇÅ j‚ÇÇ j‚ÇÉ : Fin 3
hj‚ÇÅ‚ÇÇ : j‚ÇÅ ‚â† j‚ÇÇ
hj‚ÇÅ‚ÇÉ : j‚ÇÅ ‚â† j‚ÇÉ
hj‚ÇÇ‚ÇÉ : j‚ÇÇ ‚â† j‚ÇÉ
h‚ÇÅ : t‚ÇÇ.points j‚ÇÅ = t‚ÇÅ.orthocenter
he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points)
hu : univ.erase j‚ÇÇ = {j‚ÇÅ, j‚ÇÉ}
hi‚ÇÅ‚ÇÇ hi‚ÇÅ‚ÇÉ hi‚ÇÇ‚ÇÉ : True
‚ä¢ univ.erase 2 = {1, 0}

case tail.head.tail.tail.head.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
j‚ÇÅ j‚ÇÇ j‚ÇÉ : Fin 3
hj‚ÇÅ‚ÇÇ : j‚ÇÅ ‚â† j‚ÇÇ
hj‚ÇÅ‚ÇÉ : j‚ÇÅ ‚â† j‚ÇÉ
hj‚ÇÇ‚ÇÉ : j‚ÇÇ ‚â† j‚ÇÉ
h‚ÇÅ : t‚ÇÇ.points j‚ÇÅ = t‚ÇÅ.orthocenter
he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points)
hu : univ.erase j‚ÇÇ = {j‚ÇÅ, j‚ÇÉ}
hi‚ÇÅ‚ÇÇ hi‚ÇÅ‚ÇÉ hi‚ÇÇ‚ÇÉ : True
‚ä¢ univ.erase 0 = {1, 2}

case tail.tail.head.head.tail.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
j‚ÇÅ j‚ÇÇ j‚ÇÉ : Fin 3
hj‚ÇÅ‚ÇÇ : j‚ÇÅ ‚â† j‚ÇÇ
hj‚ÇÅ‚ÇÉ : j‚ÇÅ ‚â† j‚ÇÉ
hj‚ÇÇ‚ÇÉ : j‚ÇÇ ‚â† j‚ÇÉ
h‚ÇÅ : t‚ÇÇ.points j‚ÇÅ = t‚ÇÅ.orthocenter
he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points)
hu : univ.erase j‚ÇÇ = {j‚ÇÅ, j‚ÇÉ}
hi‚ÇÅ‚ÇÇ hi‚ÇÅ‚ÇÉ hi‚ÇÇ‚ÇÉ : True
‚ä¢ univ.erase 1 = {2, 0}

case tail.tail.head.tail.head.head
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
j‚ÇÅ j‚ÇÇ j‚ÇÉ : Fin 3
hj‚ÇÅ‚ÇÇ : j‚ÇÅ ‚â† j‚ÇÇ
hj‚ÇÅ‚ÇÉ : j‚ÇÅ ‚â† j‚ÇÉ
hj‚ÇÇ‚ÇÉ : j‚ÇÇ ‚â† j‚ÇÉ
h‚ÇÅ : t‚ÇÇ.points j‚ÇÅ = t‚ÇÅ.orthocenter
he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points)
hu : univ.erase j‚ÇÇ = {j‚ÇÅ, j‚ÇÉ}
hi‚ÇÅ‚ÇÇ hi‚ÇÅ‚ÇÉ hi‚ÇÇ‚ÇÉ : True
‚ä¢ univ.erase 0 = {2, 1}","theorem altitude_replace_orthocenter_eq_affineSpan {t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P}
    {i‚ÇÅ i‚ÇÇ i‚ÇÉ j‚ÇÅ j‚ÇÇ j‚ÇÉ : Fin 3} (hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ) (hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ) (hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ) (hj‚ÇÅ‚ÇÇ : j‚ÇÅ ‚â† j‚ÇÇ)
    (hj‚ÇÅ‚ÇÉ : j‚ÇÅ ‚â† j‚ÇÉ) (hj‚ÇÇ‚ÇÉ : j‚ÇÇ ‚â† j‚ÇÉ) (h‚ÇÅ : t‚ÇÇ.points j‚ÇÅ = t‚ÇÅ.orthocenter)
    (h‚ÇÇ : t‚ÇÇ.points j‚ÇÇ = t‚ÇÅ.points i‚ÇÇ) (h‚ÇÉ : t‚ÇÇ.points j‚ÇÉ = t‚ÇÅ.points i‚ÇÉ) :
    t‚ÇÇ.altitude j‚ÇÇ = line[‚Ñù, t‚ÇÅ.points i‚ÇÅ, t‚ÇÅ.points i‚ÇÇ] ",":= by
  symm
  rw [‚Üê h‚ÇÇ, t‚ÇÇ.affineSpan_pair_eq_altitude_iff]
  rw [h‚ÇÇ]
  use t‚ÇÅ.independent.injective.ne hi‚ÇÅ‚ÇÇ
  have he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points) := by
    refine ext_of_direction_eq ?_
      ‚ü®t‚ÇÅ.points i‚ÇÉ, mem_affineSpan ‚Ñù ‚ü®j‚ÇÉ, h‚ÇÉ‚ü©, mem_affineSpan ‚Ñù (Set.mem_range_self _)‚ü©
    refine eq_of_le_of_finrank_eq (direction_le (spanPoints_subset_coe_of_subset_coe ?_)) ?_
    ¬∑ have hu : (Finset.univ : Finset (Fin 3)) = {j‚ÇÅ, j‚ÇÇ, j‚ÇÉ} := by
        clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
        fin_cases j‚ÇÅ <;> fin_cases j‚ÇÇ <;> fin_cases j‚ÇÉ
          <;> simp (config := {decide := true}) at hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ ‚ä¢
      rw [‚Üê Set.image_univ, ‚Üê Finset.coe_univ, hu, Finset.coe_insert, Finset.coe_insert,
        Finset.coe_singleton, Set.image_insert_eq, Set.image_insert_eq, Set.image_singleton, h‚ÇÅ, h‚ÇÇ,
        h‚ÇÉ, Set.insert_subset_iff, Set.insert_subset_iff, Set.singleton_subset_iff]
      exact
        ‚ü®t‚ÇÅ.orthocenter_mem_affineSpan, mem_affineSpan ‚Ñù (Set.mem_range_self _),
          mem_affineSpan ‚Ñù (Set.mem_range_self _)‚ü©
    ¬∑ rw [direction_affineSpan, direction_affineSpan,
        t‚ÇÅ.independent.finrank_vectorSpan (Fintype.card_fin _),
        t‚ÇÇ.independent.finrank_vectorSpan (Fintype.card_fin _)]
  rw [he]
  use mem_affineSpan ‚Ñù (Set.mem_range_self _)
  have hu : Finset.univ.erase j‚ÇÇ = {j‚ÇÅ, j‚ÇÉ} := by
    clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
    fin_cases j‚ÇÅ <;> fin_cases j‚ÇÇ <;> fin_cases j‚ÇÉ
      <;> simp (config := {decide := true}) at hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ ‚ä¢
  rw [hu, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton, h‚ÇÅ, h‚ÇÉ]
  have hle : (t‚ÇÅ.altitude i‚ÇÉ).direction·óÆ ‚â§ line[‚Ñù, t‚ÇÅ.orthocenter, t‚ÇÅ.points i‚ÇÉ].direction·óÆ :=
    Submodule.orthogonal_le (direction_le (affineSpan_orthocenter_point_le_altitude _ _))
  refine hle ((t‚ÇÅ.vectorSpan_isOrtho_altitude_direction i‚ÇÉ) ?_)
  have hui : Finset.univ.erase i‚ÇÉ = {i‚ÇÅ, i‚ÇÇ} := by
    clear hle h‚ÇÇ h‚ÇÉ
    fin_cases i‚ÇÅ <;> fin_cases i‚ÇÇ <;> fin_cases i‚ÇÉ
      <;> simp (config := {decide := true}) at hi‚ÇÅ‚ÇÇ hi‚ÇÅ‚ÇÉ hi‚ÇÇ‚ÇÉ ‚ä¢
  rw [hui, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton]
  exact vsub_mem_vectorSpan ‚Ñù (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_singleton _))"
Mathlib/Geometry/Manifold/Complex.lean,Complex.norm_eventually_eq_of_mdifferentiableAt_of_isLocalMax,Complex.norm_eventually_eq_of_mdifferentiableAt_of_isLocalMax,fc32fb1ee620bd1caec81914893aac3174a010c9,":= by
  set e := extChartAt I c
  have hI : range I = univ := ModelWithCorners.Boundaryless.range_eq_univ
  have H‚ÇÅ : ùìù[range I] (e c) = ùìù (e c) := by rw [hI, nhdsWithin_univ]
  have H‚ÇÇ : map e.symm (ùìù (e c)) = ùìù c
  ¬∑ rw [‚Üê map_extChartAt_symm_nhdsWithin_range I c, H‚ÇÅ]
  rw [‚Üê H‚ÇÇ, eventually_map]
  replace hd : ‚àÄ·∂† y in ùìù (e c), DifferentiableAt ‚ÑÇ (f ‚àò e.symm) y
  ¬∑ have : e.target ‚àà ùìù (e c) := H‚ÇÅ ‚ñ∏ extChartAt_target_mem_nhdsWithin I c
    filter_upwards [this, Tendsto.eventually H‚ÇÇ.le hd] with y hyt hy‚ÇÇ
    have hys : e.symm y ‚àà (chartAt H c).source
    ¬∑ rw [‚Üê extChartAt_source I c]
      exact (extChartAt I c).map_target hyt
    have hfy : f (e.symm y) ‚àà (chartAt F (0 : F)).source := mem_univ _
    rw [mdifferentiableAt_iff_of_mem_source hys hfy, hI, differentiableWithinAt_univ,
      e.right_inv hyt] at hy‚ÇÇ
    exact hy‚ÇÇ.2
  convert norm_eventually_eq_of_isLocalMax hd _
  ¬∑ exact congr_arg f (extChartAt_to_inv _ _).symm
  ¬∑ simpa only [IsLocalMax, IsMaxFilter, ‚Üê H‚ÇÇ, (¬∑ ‚àò ¬∑), extChartAt_to_inv] using hc","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
E : Type u_1
inst‚úù‚Åπ : NormedAddCommGroup E
inst‚úù‚Å∏ : NormedSpace ‚ÑÇ E
F : Type u_2
inst‚úù‚Å∑ : NormedAddCommGroup F
inst‚úù‚Å∂ : NormedSpace ‚ÑÇ F
H : Type u_3
inst‚úù‚Åµ : TopologicalSpace H
I : ModelWithCorners ‚ÑÇ E H
inst‚úù‚Å¥ : I.Boundaryless
M : Type u_4
inst‚úù¬≥ : TopologicalSpace M
inst‚úù¬≤ : CompactSpace M
inst‚úù¬π : ChartedSpace H M
inst‚úù : SmoothManifoldWithCorners I M
f : M ‚Üí F
c : M
hd : ‚àÄ·∂† (z : M) in ùìù c, MDifferentiableAt I ùìò(‚ÑÇ, F) f z
hc : IsLocalMax (norm ‚àò f) c
e : PartialEquiv M E := extChartAt I c
hI : range ‚ÜëI = univ
H‚ÇÅ : ùìù[range ‚ÜëI] ‚Üëe c = ùìù (‚Üëe c)
H‚ÇÇ : map (‚Üëe.symm) (ùìù (‚Üëe c)) = ùìù c
‚ä¢ ‚àÄ·∂† (y : M) in ùìù c, ‚Äñf y‚Äñ = ‚Äñf c‚Äñ","theorem Complex.norm_eventually_eq_of_mdifferentiableAt_of_isLocalMax {f : M ‚Üí F} {c : M}
    (hd : ‚àÄ·∂† z in ùìù c, MDifferentiableAt I ùìò(‚ÑÇ, F) f z) (hc : IsLocalMax (norm ‚àò f) c) :
    ‚àÄ·∂† y in ùìù c, ‚Äñf y‚Äñ = ‚Äñf c‚Äñ ",":= by
  set e := extChartAt I c
  have hI : range I = univ := ModelWithCorners.Boundaryless.range_eq_univ
  have H‚ÇÅ : ùìù[range I] (e c) = ùìù (e c) := by rw [hI, nhdsWithin_univ]
  have H‚ÇÇ : map e.symm (ùìù (e c)) = ùìù c := by
    rw [‚Üê map_extChartAt_symm_nhdsWithin_range I c, H‚ÇÅ]
  rw [‚Üê H‚ÇÇ, eventually_map]
  replace hd : ‚àÄ·∂† y in ùìù (e c), DifferentiableAt ‚ÑÇ (f ‚àò e.symm) y := by
    have : e.target ‚àà ùìù (e c) := H‚ÇÅ ‚ñ∏ extChartAt_target_mem_nhdsWithin I c
    filter_upwards [this, Tendsto.eventually H‚ÇÇ.le hd] with y hyt hy‚ÇÇ
    have hys : e.symm y ‚àà (chartAt H c).source := by
      rw [‚Üê extChartAt_source I c]
      exact (extChartAt I c).map_target hyt
    have hfy : f (e.symm y) ‚àà (chartAt F (0 : F)).source := mem_univ _
    rw [mdifferentiableAt_iff_of_mem_source hys hfy, hI, differentiableWithinAt_univ,
      e.right_inv hyt] at hy‚ÇÇ
    exact hy‚ÇÇ.2
  convert norm_eventually_eq_of_isLocalMax hd _
  ¬∑ exact congr_arg f (extChartAt_to_inv _ _).symm
  ¬∑ simpa only [e, IsLocalMax, IsMaxFilter, ‚Üê H‚ÇÇ, (¬∑ ‚àò ¬∑), extChartAt_to_inv] using hc"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.Measure.hausdorffMeasure_zero_or_top,hausdorffMeasure_zero_or_top,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  by_contra! H
  suffices ‚àÄ c : ‚Ñù‚â•0, c ‚â† 0 ‚Üí ŒºH[d‚ÇÇ] s ‚â§ c * ŒºH[d‚ÇÅ] s by
    rcases ENNReal.exists_nnreal_pos_mul_lt H.2 H.1 with ‚ü®c, hc0, hc‚ü©
    exact hc.not_le (this c (pos_iff_ne_zero.1 hc0))
  intro c hc
  refine' le_iff'.1 (mkMetric_mono_smul ENNReal.coe_ne_top (mod_cast hc) _) s
  have : 0 < ((c : ‚Ñù‚â•0‚àû) ^ (d‚ÇÇ - d‚ÇÅ)‚Åª¬π) := by
    rw [ENNReal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, Ne.def, ENNReal.coe_eq_zero,
      NNReal.rpow_eq_zero_iff]
    exact mt And.left hc
  filter_upwards [Ico_mem_nhdsWithin_Ici ‚ü®le_rfl, this‚ü©]
  rintro r ‚ü®hr‚ÇÄ, hrc‚ü©
  lift r to ‚Ñù‚â•0 using ne_top_of_lt hrc
  rw [Pi.smul_apply, smul_eq_mul,
    ‚Üê ENNReal.div_le_iff_le_mul (Or.inr ENNReal.coe_ne_top) (Or.inr <| mt ENNReal.coe_eq_zero.1 hc)]
  rcases eq_or_ne r 0 with (rfl | hr‚ÇÄ)
  ¬∑ rcases lt_or_le 0 d‚ÇÇ with (h‚ÇÇ | h‚ÇÇ)
    ¬∑ simp only [h‚ÇÇ, ENNReal.zero_rpow_of_pos, zero_le, ENNReal.zero_div, ENNReal.coe_zero]
    ¬∑ simp only [h.trans_le h‚ÇÇ, ENNReal.div_top, zero_le, ENNReal.zero_rpow_of_neg,
        ENNReal.coe_zero]
  ¬∑ have : (r : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne.def] using hr‚ÇÄ
    rw [‚Üê ENNReal.rpow_sub _ _ this ENNReal.coe_ne_top]
    refine' (ENNReal.rpow_lt_rpow hrc (sub_pos.2 h)).le.trans _
    rw [‚Üê ENNReal.rpow_mul, inv_mul_cancel (sub_pos.2 h).ne', ENNReal.rpow_one]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133229 ‚Üí ?m.133229 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.133231
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬≥ : EMetricSpace X
inst‚úù¬≤ : EMetricSpace Y
inst‚úù¬π : MeasurableSpace X
inst‚úù : BorelSpace X
d‚ÇÅ d‚ÇÇ : ‚Ñù
h : d‚ÇÅ < d‚ÇÇ
s : Set X
H : ŒºH[d‚ÇÇ] s ‚â† 0 ‚àß ŒºH[d‚ÇÅ] s ‚â† ‚ä§
c : ‚Ñù‚â•0
hc : c ‚â† 0
‚ä¢ ‚Üë(c ^ (d‚ÇÇ - d‚ÇÅ)‚Åª¬π) ‚â† 0
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.135616 ‚Üí ?m.135616 ‚Üí Prop
error:  type mismatch
  h‚úù
has type
  r ‚â† 0 : Prop
but is expected to have type
  ‚Üër ‚â† 0 : Prop","theorem hausdorffMeasure_zero_or_top {d‚ÇÅ d‚ÇÇ : ‚Ñù} (h : d‚ÇÅ < d‚ÇÇ) (s : Set X) :
    ŒºH[d‚ÇÇ] s = 0 ‚à® ŒºH[d‚ÇÅ] s = ‚àû ",":= by
  by_contra! H
  suffices ‚àÄ c : ‚Ñù‚â•0, c ‚â† 0 ‚Üí ŒºH[d‚ÇÇ] s ‚â§ c * ŒºH[d‚ÇÅ] s by
    rcases ENNReal.exists_nnreal_pos_mul_lt H.2 H.1 with ‚ü®c, hc0, hc‚ü©
    exact hc.not_le (this c (pos_iff_ne_zero.1 hc0))
  intro c hc
  refine le_iff'.1 (mkMetric_mono_smul ENNReal.coe_ne_top (mod_cast hc) ?_) s
  have : 0 < ((c : ‚Ñù‚â•0‚àû) ^ (d‚ÇÇ - d‚ÇÅ)‚Åª¬π) := by
    rw [ENNReal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, Ne, ENNReal.coe_eq_zero,
      NNReal.rpow_eq_zero_iff]
    exact mt And.left hc
  filter_upwards [Ico_mem_nhdsWithin_Ici ‚ü®le_rfl, this‚ü©]
  rintro r ‚ü®hr‚ÇÄ, hrc‚ü©
  lift r to ‚Ñù‚â•0 using ne_top_of_lt hrc
  rw [Pi.smul_apply, smul_eq_mul,
    ‚Üê ENNReal.div_le_iff_le_mul (Or.inr ENNReal.coe_ne_top) (Or.inr <| mt ENNReal.coe_eq_zero.1 hc)]
  rcases eq_or_ne r 0 with (rfl | hr‚ÇÄ)
  ¬∑ rcases lt_or_le 0 d‚ÇÇ with (h‚ÇÇ | h‚ÇÇ)
    ¬∑ simp only [h‚ÇÇ, ENNReal.zero_rpow_of_pos, zero_le, ENNReal.zero_div, ENNReal.coe_zero]
    ¬∑ simp only [h.trans_le h‚ÇÇ, ENNReal.div_top, zero_le, ENNReal.zero_rpow_of_neg,
        ENNReal.coe_zero]
  ¬∑ have : (r : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using hr‚ÇÄ
    rw [‚Üê ENNReal.rpow_sub _ _ this ENNReal.coe_ne_top]
    refine (ENNReal.rpow_lt_rpow hrc (sub_pos.2 h)).le.trans ?_
    rw [‚Üê ENNReal.rpow_mul, inv_mul_cancel (sub_pos.2 h).ne', ENNReal.rpow_one]"
Mathlib/Analysis/Analytic/CPolynomial.lean,FormalMultilinearSeries.changeOriginSeriesTerm_bound,changeOriginSeriesTerm_bound,b502dbb455f708f5af5e6017e88f53565165ab0a,":= by
  rw [changeOriginSeriesTerm, hn _ hkl, map_zero]","error:  failed to synthesize
  ZeroHomClass
    (ContinuousMultilinearMap ùïú (fun i ‚Ü¶ E) F ‚âÉ‚Çó·µ¢[ùïú]
      ContinuousMultilinearMap ùïú (fun i ‚Ü¶ E) (ContinuousMultilinearMap ùïú (fun i ‚Ü¶ E) F))
    (ContinuousMultilinearMap ùïú (fun i ‚Ü¶ E) F)
    (ContinuousMultilinearMap ùïú (fun i ‚Ü¶ E) (ContinuousMultilinearMap ùïú (fun i ‚Ü¶ E) F))
use `set_option diagnostics true` to get diagnostic information
error:  unsolved goals
ùïú : Type u_1
E : Type u_2
F : Type u_3
G : Type u_4
inst‚úù‚Å∂ : NontriviallyNormedField ùïú
inst‚úù‚Åµ : NormedAddCommGroup E
inst‚úù‚Å¥ : NormedSpace ùïú E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : NormedSpace ùïú F
inst‚úù¬π : NormedAddCommGroup G
inst‚úù : NormedSpace ùïú G
f g : E ‚Üí F
p‚úù¬π pf pg : FormalMultilinearSeries ùïú E F
x‚úù : E
r‚úù r' : ‚Ñù‚â•0‚àû
n‚úù m : ‚Ñï
p‚úù : FormalMultilinearSeries ùïú E F
x y : E
r R : ‚Ñù‚â•0
p : FormalMultilinearSeries ùïú E F
n : ‚Ñï
hn : ‚àÄ (m : ‚Ñï), n ‚â§ m ‚Üí p m = 0
k l : ‚Ñï
s : Finset (Fin (k + l))
hs : s.card = l
hkl : n ‚â§ k + l
‚ä¢ ZeroHomClass
    (ContinuousMultilinearMap ùïú (fun i ‚Ü¶ E) F ‚âÉ‚Çó·µ¢[ùïú]
      ContinuousMultilinearMap ùïú (fun i ‚Ü¶ E) (ContinuousMultilinearMap ùïú (fun i ‚Ü¶ E) F))
    (ContinuousMultilinearMap ùïú (fun i ‚Ü¶ E) F)
    (ContinuousMultilinearMap ùïú (fun i ‚Ü¶ E) (ContinuousMultilinearMap ùïú (fun i ‚Ü¶ E) F))","lemma changeOriginSeriesTerm_bound (p : FormalMultilinearSeries ùïú E F) {n : ‚Ñï}
    (hn : ‚àÄ (m : ‚Ñï), n ‚â§ m ‚Üí p m = 0) (k l : ‚Ñï) {s : Finset (Fin (k + l))}
    (hs : s.card = l) (hkl : n ‚â§ k + l) :
    p.changeOriginSeriesTerm k l s hs = 0 ",":= by
  set_option maxSynthPendingDepth 2 in
  rw [changeOriginSeriesTerm, hn _ hkl, map_zero]"
Mathlib/LinearAlgebra/TensorProduct/Vanishing.lean,TensorProduct.vanishesTrivially_of_sum_tmul_eq_zero,vanishesTrivially_of_sum_tmul_eq_zero,756ba8b867daa9b96d7e994a904de96a1eca6adf,":= by
  set G : (Œπ ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] M := Finsupp.total Œπ M R m with hG
  have G_basis_eq (i : Œπ) : G (Finsupp.single i 1) = m i := by simp [hG, toModule_lof]
  have G_surjective : Surjective G := by
    apply LinearMap.range_eq_top.mp
    apply top_le_iff.mp
    rw [‚Üê hm]
    apply Submodule.span_le.mpr
    rintro _ ‚ü®i, rfl‚ü©
    use Finsupp.single i 1, G_basis_eq i
  set en : (Œπ ‚Üí‚ÇÄ R) ‚äó[R] N := ‚àë i, Finsupp.single i 1 ‚äó‚Çú n i with hen
  have en_mem_ker : en ‚àà ker (rTensor N G) := by simp [hen, G_basis_eq, hmn]
  have exact_ker_subtype : Exact (ker G).subtype G := G.exact_subtype_ker_map
  have exact_rTensor_ker_subtype : Exact (rTensor N (ker G).subtype) (rTensor N G) :=
    rTensor_exact N exact_ker_subtype G_surjective
  have en_mem_range : en ‚àà range (rTensor N (ker G).subtype) :=
    exact_rTensor_ker_subtype.linearMap_ker_eq ‚ñ∏ en_mem_ker
  obtain ‚ü®kn, hkn‚ü© := en_mem_range
  obtain ‚ü®ma, rfl : kn = ‚àë kj ‚àà ma, kj.1 ‚äó‚Çú[R] kj.2‚ü© := exists_finset kn
  use ‚Üë‚Üëma, FinsetCoe.fintype ma
  use fun i ‚ü®‚ü®kj, _‚ü©, _‚ü© ‚Ü¶ (kj : Œπ ‚Üí‚ÇÄ R) i
  use fun ‚ü®‚ü®_, yj‚ü©, _‚ü© ‚Ü¶ yj
  constructor
  ¬∑ intro i
    apply_fun finsuppScalarLeft R N Œπ at hkn
    apply_fun (¬∑ i) at hkn
    symm at hkn
    simp only [map_sum, finsuppScalarLeft_apply_tmul, zero_smul, Finsupp.single_zero,
      Finsupp.sum_single_index, one_smul, Finsupp.finset_sum_apply, Finsupp.single_apply,
      Finset.sum_ite_eq', Finset.mem_univ, ‚ÜìreduceIte, rTensor_tmul, coeSubtype, Finsupp.sum_apply,
      Finsupp.sum_ite_eq', Finsupp.mem_support_iff, ne_eq, ite_not, en] at hkn
    simp only [Finset.univ_eq_attach, Finset.sum_attach ma (fun x ‚Ü¶ (x.1 : Œπ ‚Üí‚ÇÄ R) i ‚Ä¢ x.2)]
    convert hkn using 2 with x _
    split
    ¬∑ next h'x => rw [h'x, zero_smul]
    ¬∑ rfl
  ¬∑ rintro ‚ü®‚ü®‚ü®k, hk‚ü©, _‚ü©, _‚ü©
    simpa only [hG, Finsupp.total_apply, zero_smul, implies_true, Finsupp.sum_fintype] using
      mem_ker.mp hk","error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'vanishesTrivially_of_sum_tmul_eq_zero'
error:  unknown identifier 'vanishesTrivially_of_sum_tmul_eq_zero'","theorem vanishesTrivially_of_sum_tmul_eq_zero (hm : Submodule.span R (Set.range m) = ‚ä§)
    (hmn : ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N)) : VanishesTrivially R m n ",":= by
  set G : (Œπ ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] M := Finsupp.total Œπ M R m with hG
  have G_basis_eq (i : Œπ) : G (Finsupp.single i 1) = m i := by simp [hG, toModule_lof]
  have G_surjective : Surjective G := by
    apply LinearMap.range_eq_top.mp
    apply top_le_iff.mp
    rw [‚Üê hm]
    apply Submodule.span_le.mpr
    rintro _ ‚ü®i, rfl‚ü©
    use Finsupp.single i 1, G_basis_eq i
  set en : (Œπ ‚Üí‚ÇÄ R) ‚äó[R] N := ‚àë i, Finsupp.single i 1 ‚äó‚Çú n i with hen
  have en_mem_ker : en ‚àà ker (rTensor N G) := by simp [hen, G_basis_eq, hmn]
  have exact_ker_subtype : Exact (ker G).subtype G := G.exact_subtype_ker_map
  have exact_rTensor_ker_subtype : Exact (rTensor N (ker G).subtype) (rTensor N G) :=
    rTensor_exact (M := ‚Ü•(ker G)) N exact_ker_subtype G_surjective
  have en_mem_range : en ‚àà range (rTensor N (ker G).subtype) :=
    exact_rTensor_ker_subtype.linearMap_ker_eq ‚ñ∏ en_mem_ker
  obtain ‚ü®kn, hkn‚ü© := en_mem_range
  obtain ‚ü®ma, rfl : kn = ‚àë kj ‚àà ma, kj.1 ‚äó‚Çú[R] kj.2‚ü© := exists_finset kn
  use ‚Üë‚Üëma, FinsetCoe.fintype ma
  use fun i ‚ü®‚ü®kj, _‚ü©, _‚ü© ‚Ü¶ (kj : Œπ ‚Üí‚ÇÄ R) i
  use fun ‚ü®‚ü®_, yj‚ü©, _‚ü© ‚Ü¶ yj
  constructor
  ¬∑ intro i
    apply_fun finsuppScalarLeft R N Œπ at hkn
    apply_fun (¬∑ i) at hkn
    symm at hkn
    simp only [map_sum, finsuppScalarLeft_apply_tmul, zero_smul, Finsupp.single_zero,
      Finsupp.sum_single_index, one_smul, Finsupp.finset_sum_apply, Finsupp.single_apply,
      Finset.sum_ite_eq', Finset.mem_univ, ‚ÜìreduceIte, rTensor_tmul, coeSubtype, Finsupp.sum_apply,
      Finsupp.sum_ite_eq', Finsupp.mem_support_iff, ne_eq, ite_not, en] at hkn
    simp only [Finset.univ_eq_attach, Finset.sum_attach ma (fun x ‚Ü¶ (x.1 : Œπ ‚Üí‚ÇÄ R) i ‚Ä¢ x.2)]
    convert hkn using 2 with x _
    split
    ¬∑ next h'x => rw [h'x, zero_smul]
    ¬∑ rfl
  ¬∑ rintro ‚ü®‚ü®‚ü®k, hk‚ü©, _‚ü©, _‚ü©
    simpa only [hG, Finsupp.total_apply, zero_smul, implies_true, Finsupp.sum_fintype] using
      mem_ker.mp hk"
Mathlib/Data/Int/Cast/Basic.lean,Int.cast_add,cast_add,dc0b2fb410ce57ee8ea5b9ce5b357ce030465e7a,"  | (m : ‚Ñï), (n : ‚Ñï) => by simp [-Int.natCast_add, ‚Üê Int.ofNat_add]
  | (m : ‚Ñï), -[n+1] => by erw [cast_subNatNat, cast_natCast, cast_negSucc, sub_eq_add_neg]
  | -[m+1], (n : ‚Ñï) => by
    erw [cast_subNatNat, cast_natCast, cast_negSucc, sub_eq_iff_eq_add, add_assoc,
      eq_neg_add_iff_add_eq, ‚Üê Nat.cast_add, ‚Üê Nat.cast_add, Nat.add_comm]
  | -[m+1], -[n+1] =>
    show (-[m + n + 1+1] : R) = _ by
      rw [cast_negSucc, cast_negSucc, cast_negSucc, ‚Üê neg_add_rev, ‚Üê Nat.cast_add,
        Nat.add_right_comm m n 1, ‚Üê Nat.add_assoc', Nat.add_comm]","error:  unknown constant 'Nat.add_assoc''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.8474
R : Type u
inst‚úù : AddGroupWithOne R
m n : ‚Ñï
‚ä¢ -‚Üë(m + 1 + n + 1) = -‚Üë(n + 1 + (m + 1))
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Int.cast_bit0` has been deprecated","theorem cast_add : ‚àÄ m n, ((m + n : ‚Ñ§) : R) = m + n
","  | (m : ‚Ñï), (n : ‚Ñï) => by simp [-Int.natCast_add, ‚Üê Int.ofNat_add]
  | (m : ‚Ñï), -[n+1] => by erw [cast_subNatNat, cast_natCast, cast_negSucc, sub_eq_add_neg]
  | -[m+1], (n : ‚Ñï) => by
    erw [cast_subNatNat, cast_natCast, cast_negSucc, sub_eq_iff_eq_add, add_assoc,
      eq_neg_add_iff_add_eq, ‚Üê Nat.cast_add, ‚Üê Nat.cast_add, Nat.add_comm]
  | -[m+1], -[n+1] =>
    show (-[m + n + 1+1] : R) = _ by
      rw [cast_negSucc, cast_negSucc, cast_negSucc, ‚Üê neg_add_rev, ‚Üê Nat.cast_add,
        Nat.add_right_comm m n 1, Nat.add_assoc, Nat.add_comm]"
Mathlib/Probability/ConditionalProbability.lean,ProbabilityTheory.sum_meas_smul_cond_fiber,sum_meas_smul_cond_fiber,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  ext E hE
  calc
    _ = ‚àë x, Œº (X ‚Åª¬π' {x} ‚à© E) := by
      simp only [Measure.coe_finset_sum, smul_toOuterMeasure, OuterMeasure.coe_smul,
        Finset.sum_apply, Pi.smul_apply, smul_eq_mul]
      simp_rw [mul_comm (Œº _), cond_mul_eq_inter _ (hX (.singleton _))]
    _ = _ := by
      have : ‚ãÉ x ‚àà Finset.univ, X ‚Åª¬π' {x} ‚à© E = E := by simp; ext _; simp
      rw [‚Üê measure_biUnion_finset _ fun _ _ ‚Ü¶ (hX (.singleton _)).inter hE, this]
      aesop (add simp [PairwiseDisjoint, Set.Pairwise, Function.onFun, disjoint_left])","warning:  @cond does not have a doc string
warning:  @cond does not have a doc string
error:  simp made no progress","lemma sum_meas_smul_cond_fiber {X : Œ© ‚Üí Œ±} (hX : Measurable X) (Œº : Measure Œ©) [IsFiniteMeasure Œº] :
    ‚àë x, Œº (X ‚Åª¬π' {x}) ‚Ä¢ Œº[|X ‚Üê x] = Œº ",":= by
  ext E hE
  calc
    _ = ‚àë x, Œº (X ‚Åª¬π' {x} ‚à© E) := by
      simp only [Measure.coe_finset_sum, Measure.coe_smul, Finset.sum_apply,
        Pi.smul_apply, smul_eq_mul]
      simp_rw [mul_comm (Œº _), cond_mul_eq_inter _ (hX (.singleton _))]
    _ = _ := by
      have : ‚ãÉ x ‚àà Finset.univ, X ‚Åª¬π' {x} ‚à© E = E := by simp; ext _; simp
      rw [‚Üê measure_biUnion_finset _ fun _ _ ‚Ü¶ (hX (.singleton _)).inter hE, this]
      aesop (add simp [PairwiseDisjoint, Set.Pairwise, Function.onFun, disjoint_left])"
Mathlib/Analysis/Calculus/Taylor.lean,taylor_mean_remainder_lagrange,taylor_mean_remainder_lagrange,e5e7a3c38578dfab479b07cd58791d26d9ea89a8,":= by
  have gcont : ContinuousOn (fun t : ‚Ñù => (x - t) ^ (n + 1)) (Icc x‚ÇÄ x) := by
    refine' Continuous.continuousOn _
    exact (continuous_const.sub continuous_id').pow _ 
  have xy_ne : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí (x - y) ^ n ‚â† 0 := by
    intro y hy
    refine' pow_ne_zero _ _
    rw [mem_Ioo] at hy
    rw [sub_ne_zero]
    exact hy.2.ne'
  have hg' : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí -(‚Üën + 1) * (x - y) ^ n ‚â† 0 := fun y hy =>
    mul_ne_zero (neg_ne_zero.mpr (Nat.cast_add_one_ne_zero n)) (xy_ne y hy)
  rcases taylor_mean_remainder hx hf hf' gcont (fun y _ => monomial_has_deriv_aux y x _) hg' with
    ‚ü®y, hy, h‚ü©
  use y, hy
  simp only [sub_self, zero_pow, Ne.def, Nat.succ_ne_zero, not_false_iff, zero_sub, mul_neg] at h
  rw [h, neg_div, ‚Üê div_neg, neg_mul, neg_neg]
  field_simp [xy_ne y hy, Nat.factorial];  ring","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.136822 ‚Üí ?m.136822 ‚Üí Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  -?b / ?a
case right
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚Ñù E
f : ‚Ñù ‚Üí ‚Ñù
x x‚ÇÄ : ‚Ñù
n : ‚Ñï
hx : x‚ÇÄ < x
hf : ContDiffOn ‚Ñù (‚Üën) f (Icc x‚ÇÄ x)
hf' : DifferentiableOn ‚Ñù (iteratedDerivWithin n f (Icc x‚ÇÄ x)) (Ioo x‚ÇÄ x)
gcont : ContinuousOn (fun t ‚Ü¶ (x - t) ^ (n + 1)) (Icc x‚ÇÄ x)
xy_ne : ‚àÄ y ‚àà Ioo x‚ÇÄ x, (x - y) ^ n ‚â† 0
hg' : ‚àÄ y ‚àà Ioo x‚ÇÄ x, -(‚Üën + 1) * (x - y) ^ n ‚â† 0
y : ‚Ñù
hy : y ‚àà Ioo x‚ÇÄ x
h :
  f x - taylorWithinEval f n (Icc x‚ÇÄ x) x‚ÇÄ x =
    ((x - y) ^ n / ‚Üën ! * (0 ^ (n + 1) - (x - x‚ÇÄ) ^ (n + 1)) / (-(‚Üën + 1) * (x - y) ^ n)) ‚Ä¢
      iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) y
‚ä¢ ((x - y) ^ n / ‚Üën ! * (0 ^ (n + 1) - (x - x‚ÇÄ) ^ (n + 1)) / (-(‚Üën + 1) * (x - y) ^ n)) ‚Ä¢
      iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) y =
    iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) y * (x - x‚ÇÄ) ^ (n + 1) / ‚Üë(n + 1)!","theorem taylor_mean_remainder_lagrange {f : ‚Ñù ‚Üí ‚Ñù} {x x‚ÇÄ : ‚Ñù} {n : ‚Ñï} (hx : x‚ÇÄ < x)
    (hf : ContDiffOn ‚Ñù n f (Icc x‚ÇÄ x))
    (hf' : DifferentiableOn ‚Ñù (iteratedDerivWithin n f (Icc x‚ÇÄ x)) (Ioo x‚ÇÄ x)) :
    ‚àÉ x' ‚àà Ioo x‚ÇÄ x, f x - taylorWithinEval f n (Icc x‚ÇÄ x) x‚ÇÄ x =
      iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) x' * (x - x‚ÇÄ) ^ (n + 1) / (n + 1)! ",":= by
  have gcont : ContinuousOn (fun t : ‚Ñù => (x - t) ^ (n + 1)) (Icc x‚ÇÄ x) := by fun_prop
  have xy_ne : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí (x - y) ^ n ‚â† 0 := by
    intro y hy
    refine pow_ne_zero _ ?_
    rw [mem_Ioo] at hy
    rw [sub_ne_zero]
    exact hy.2.ne'
  have hg' : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí -(‚Üën + 1) * (x - y) ^ n ‚â† 0 := fun y hy =>
    mul_ne_zero (neg_ne_zero.mpr (Nat.cast_add_one_ne_zero n)) (xy_ne y hy)
  rcases taylor_mean_remainder hx hf hf' gcont (fun y _ => monomial_has_deriv_aux y x _) hg' with
    ‚ü®y, hy, h‚ü©
  use y, hy
  simp only [sub_self, zero_pow, Ne, Nat.succ_ne_zero, not_false_iff, zero_sub, mul_neg] at h
  rw [h, neg_div, ‚Üê div_neg, neg_mul, neg_neg]
  field_simp [xy_ne y hy, Nat.factorial]; ring"
Mathlib/Data/QPF/Univariate/Basic.lean,QPF.Fix.ind,Fix.ind,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have : Fix.mk (abs ‚ü®a, fun x => ‚ü¶f x‚üß‚ü©) = ‚ü¶Wrepr ‚ü®a, f‚ü©‚üß := by
    apply Quot.sound; apply Wequiv.abs'
    rw [PFunctor.W.dest_mk, abs_map, abs_repr, ‚Üê abs_map, PFunctor.map_eq]
    conv =>
      rhs
      simp only [Wrepr, recF_eq, PFunctor.W.dest_mk, abs_repr, Function.comp]
  rw [this]
  apply Quot.sound
  apply Wrepr_equiv","error:  unsolved goals
case a.h
F : Type u ‚Üí Type u
q : QPF F
a : (P F).A
f : (P F).B a ‚Üí (P F).W
‚ä¢ abs ‚ü®a, fixToW ‚àò fun x ‚Ü¶ ‚ü¶f x‚üß‚ü© =
    abs ((P F).map (recF fun x ‚Ü¶ PFunctor.W.mk (repr x)) (PFunctor.W.dest (WType.mk a f)))","theorem Fix.ind_aux (a : q.P.A) (f : q.P.B a ‚Üí q.P.W) :
    Fix.mk (abs ‚ü®a, fun x => ‚ü¶f x‚üß‚ü©) = ‚ü¶‚ü®a, f‚ü©‚üß ",":= by
  have : Fix.mk (abs ‚ü®a, fun x => ‚ü¶f x‚üß‚ü©) = ‚ü¶Wrepr ‚ü®a, f‚ü©‚üß := by
    apply Quot.sound; apply Wequiv.abs'
    rw [PFunctor.W.dest_mk, abs_map, abs_repr, ‚Üê abs_map, PFunctor.map_eq]
    simp only [Wrepr, recF_eq, PFunctor.W.dest_mk, abs_repr, Function.comp]
    rfl
  rw [this]
  apply Quot.sound
  apply Wrepr_equiv"
Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean,IsIntegralClosure.isDedekindDomain,IsIntegralClosure.isDedekindDomain,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  have : IsFractionRing C L := IsIntegralClosure.isFractionRing_of_finite_extension A K L C
  { IsIntegralClosure.isNoetherianRing A K L C,
    Ring.DimensionLEOne.isIntegralClosure A L C,
    (isIntegrallyClosed_iff L).mpr fun {x} hx =>
      ‚ü®IsIntegralClosure.mk' C x (isIntegral_trans (IsIntegralClosure.isIntegral_algebra A L) _ hx),
        IsIntegralClosure.algebraMap_mk' _ _ _‚ü© with : IsDedekindDomain C }","error:  function expected at
  isIntegral_trans ?m.154266 ?m.154267
term has type
  IsIntegral ?m.153783 ?m.154266
error:  application type mismatch
  isIntegral_trans (isIntegral_algebra A L)
argument
  isIntegral_algebra A L
has type
  Algebra.IsIntegral A ?m.153797 : Prop
but is expected to have type
  ?m.153785 : Type ?u.153780
error:  function expected at
  IsIntegralClosure.isDedekindDomain A K
term has type
  IsDedekindDomain K
error:  function expected at
  isDedekindDomain A (FractionRing A)
term has type
  IsDedekindDomain ‚Ü•(integralClosure A (FractionRing A))",theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C ,":=
  have : IsFractionRing C L := IsIntegralClosure.isFractionRing_of_finite_extension A K L C
  have : Algebra.IsIntegral A C := IsIntegralClosure.isIntegral_algebra A L
  { IsIntegralClosure.isNoetherianRing A K L C,
    Ring.DimensionLEOne.isIntegralClosure A L C,
    (isIntegrallyClosed_iff L).mpr fun {x} hx =>
      ‚ü®IsIntegralClosure.mk' C x (isIntegral_trans (R := A) _ hx),
        IsIntegralClosure.algebraMap_mk' _ _ _‚ü© with : IsDedekindDomain C }"
Mathlib/SetTheory/Ordinal/Arithmetic.lean,Ordinal.one_add_omega,one_add_omega,25e538f3a737a71314ac143929711e67d0b14d73,":= by
  refine le_antisymm ?_ (le_add_left _ _)
  rw [omega, ‚Üê lift_one.{_, 0}, ‚Üê lift_add, lift_le, ‚Üê type_unit, ‚Üê type_sum_lex]
  refine ‚ü®RelEmbedding.collapse (RelEmbedding.ofMonotone ?_ ?_)‚ü©
  ¬∑ apply Sum.rec
    ¬∑ exact fun _ => 0
    ¬∑ exact Nat.succ
  ¬∑ intro a b
    cases a <;> cases b <;> intro H <;> cases' H with _ _ H _ _ H <;>
      [exact H.elim; exact Nat.succ_pos _; exact Nat.succ_lt_succ H]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  lift.{?u.63187, ?u.63186} ?a + lift.{?u.63187, ?u.63186} ?b
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
r : Œ± ‚Üí Œ± ‚Üí Prop
s : Œ≤ ‚Üí Œ≤ ‚Üí Prop
t : Œ≥ ‚Üí Œ≥ ‚Üí Prop
‚ä¢ lift.{0, u_4} 1 + lift.{u_4, 0} (type fun x x_1 ‚Ü¶ x < x_1) ‚â§ lift.{u_4, 0} (type fun x x_1 ‚Ü¶ x < x_1)",theorem one_add_omega : 1 + œâ = œâ ,":= by
  refine le_antisymm ?_ (le_add_left _ _)
  rw [omega, ‚Üê lift_one.{0}, ‚Üê lift_add, lift_le, ‚Üê type_unit, ‚Üê type_sum_lex]
  refine ‚ü®RelEmbedding.collapse (RelEmbedding.ofMonotone ?_ ?_)‚ü©
  ¬∑ apply Sum.rec
    ¬∑ exact fun _ => 0
    ¬∑ exact Nat.succ
  ¬∑ intro a b
    cases a <;> cases b <;> intro H <;> cases' H with _ _ H _ _ H <;>
      [exact H.elim; exact Nat.succ_pos _; exact Nat.succ_lt_succ H]"
Mathlib/MeasureTheory/Constructions/Polish.lean,MeasureTheory.measurablySeparable_range_of_disjoint,measurablySeparable_range_of_disjoint,c541ced9974e0e3226a68554503a14a8e29cf1a5,":= by
  by_contra hfg
  have I : ‚àÄ n x y, ¬¨MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) ‚Üí
      ‚àÉ x' y', x' ‚àà cylinder x n ‚àß y' ‚àà cylinder y n ‚àß
      ¬¨MeasurablySeparable (f '' cylinder x' (n + 1)) (g '' cylinder y' (n + 1)) := by
    intro n x y
    contrapose!
    intro H
    rw [‚Üê iUnion_cylinder_update x n, ‚Üê iUnion_cylinder_update y n, image_iUnion, image_iUnion]
    refine' MeasurablySeparable.iUnion fun i j => _
    exact H _ _ (update_mem_cylinder _ _ _) (update_mem_cylinder _ _ _)
  let A :=
    { p : ‚Ñï √ó (‚Ñï ‚Üí ‚Ñï) √ó (‚Ñï ‚Üí ‚Ñï) //
      ¬¨MeasurablySeparable (f '' cylinder p.2.1 p.1) (g '' cylinder p.2.2 p.1) }
  have : ‚àÄ p : A, ‚àÉ q : A,
      q.1.1 = p.1.1 + 1 ‚àß q.1.2.1 ‚àà cylinder p.1.2.1 p.1.1 ‚àß q.1.2.2 ‚àà cylinder p.1.2.2 p.1.1 := by
    rintro ‚ü®‚ü®n, x, y‚ü©, hp‚ü©
    rcases I n x y hp with ‚ü®x', y', hx', hy', h'‚ü©
    exact ‚ü®‚ü®‚ü®n + 1, x', y'‚ü©, h'‚ü©, rfl, hx', hy'‚ü©
  choose F hFn hFx hFy using this
  let p0 : A := ‚ü®‚ü®0, fun _ => 0, fun _ => 0‚ü©, by simp [hfg]‚ü©
  let p : ‚Ñï ‚Üí A := fun n => F^[n] p0
  have prec : ‚àÄ n, p (n + 1) = F (p n) := fun n => by simp only [iterate_succ', Function.comp]
  have pn_fst : ‚àÄ n, (p n).1.1 = n := by
    intro n
    induction' n with n IH
    ¬∑ rfl
    ¬∑ simp only [prec, hFn, IH]
  have Ix : ‚àÄ m n, m + 1 ‚â§ n ‚Üí (p n).1.2.1 m = (p (m + 1)).1.2.1 m := by
    intro m
    apply Nat.le_induction
    ¬∑ rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.fst m = (p n).val.snd.fst m := by
      apply hFx (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  have Iy : ‚àÄ m n, m + 1 ‚â§ n ‚Üí (p n).1.2.2 m = (p (m + 1)).1.2.2 m := by
    intro m
    apply Nat.le_induction
    ¬∑ rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.snd m = (p n).val.snd.snd m := by
      apply hFy (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  set x : ‚Ñï ‚Üí ‚Ñï := fun n => (p (n + 1)).1.2.1 n with hx
  set y : ‚Ñï ‚Üí ‚Ñï := fun n => (p (n + 1)).1.2.2 n with hy
  have M : ‚àÄ n, ¬¨MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    intro n
    convert(p n).2 using 3
    ¬∑ rw [pn_fst, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hx]
      exact (Ix i n hi).symm
    ¬∑ rw [pn_fst, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hy]
      exact (Iy i n hi).symm
  obtain ‚ü®u, v, u_open, v_open, xu, yv, huv‚ü© :
    ‚àÉ u v : Set Œ±, IsOpen u ‚àß IsOpen v ‚àß f x ‚àà u ‚àß g y ‚àà v ‚àß Disjoint u v := by
    apply t2_separation
    exact disjoint_iff_forall_ne.1 h (mem_range_self _) (mem_range_self _)
  letI : MetricSpace (‚Ñï ‚Üí ‚Ñï) := metricSpaceNatNat
  obtain ‚ü®Œµx, Œµxpos, hŒµx‚ü© : ‚àÉ (Œµx : ‚Ñù), Œµx > 0 ‚àß Metric.ball x Œµx ‚äÜ f ‚Åª¬π' u := by
    apply Metric.mem_nhds_iff.1
    exact hf.continuousAt.preimage_mem_nhds (u_open.mem_nhds xu)
  obtain ‚ü®Œµy, Œµypos, hŒµy‚ü© : ‚àÉ (Œµy : ‚Ñù), Œµy > 0 ‚àß Metric.ball y Œµy ‚äÜ g ‚Åª¬π' v := by
    apply Metric.mem_nhds_iff.1
    exact hg.continuousAt.preimage_mem_nhds (v_open.mem_nhds yv)
  obtain ‚ü®n, hn‚ü© : ‚àÉ n : ‚Ñï, (1 / 2 : ‚Ñù) ^ n < min Œµx Œµy :=
    exists_pow_lt_of_lt_one (lt_min Œµxpos Œµypos) (by norm_num)
  have B : MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    refine' ‚ü®u, _, _, u_open.measurableSet‚ü©
    ¬∑ rw [image_subset_iff]
      apply Subset.trans _ hŒµx
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_left _ _))
    ¬∑ refine' Disjoint.mono_left _ huv.symm
      change g '' cylinder y n ‚äÜ v
      rw [image_subset_iff]
      apply Subset.trans _ hŒµy
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_right _ _))
  exact M n B",error:  simp made no progress,"theorem measurablySeparable_range_of_disjoint [T2Space Œ±] [MeasurableSpace Œ±]
    [OpensMeasurableSpace Œ±] {f g : (‚Ñï ‚Üí ‚Ñï) ‚Üí Œ±} (hf : Continuous f) (hg : Continuous g)
    (h : Disjoint (range f) (range g)) : MeasurablySeparable (range f) (range g) ",":= by
  by_contra hfg
  have I : ‚àÄ n x y, ¬¨MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) ‚Üí
      ‚àÉ x' y', x' ‚àà cylinder x n ‚àß y' ‚àà cylinder y n ‚àß
      ¬¨MeasurablySeparable (f '' cylinder x' (n + 1)) (g '' cylinder y' (n + 1)) := by
    intro n x y
    contrapose!
    intro H
    rw [‚Üê iUnion_cylinder_update x n, ‚Üê iUnion_cylinder_update y n, image_iUnion, image_iUnion]
    refine MeasurablySeparable.iUnion fun i j => ?_
    exact H _ _ (update_mem_cylinder _ _ _) (update_mem_cylinder _ _ _)
  let A :=
    { p : ‚Ñï √ó (‚Ñï ‚Üí ‚Ñï) √ó (‚Ñï ‚Üí ‚Ñï) //
      ¬¨MeasurablySeparable (f '' cylinder p.2.1 p.1) (g '' cylinder p.2.2 p.1) }
  have : ‚àÄ p : A, ‚àÉ q : A,
      q.1.1 = p.1.1 + 1 ‚àß q.1.2.1 ‚àà cylinder p.1.2.1 p.1.1 ‚àß q.1.2.2 ‚àà cylinder p.1.2.2 p.1.1 := by
    rintro ‚ü®‚ü®n, x, y‚ü©, hp‚ü©
    rcases I n x y hp with ‚ü®x', y', hx', hy', h'‚ü©
    exact ‚ü®‚ü®‚ü®n + 1, x', y'‚ü©, h'‚ü©, rfl, hx', hy'‚ü©
  choose F hFn hFx hFy using this
  let p0 : A := ‚ü®‚ü®0, fun _ => 0, fun _ => 0‚ü©, by simp [hfg]‚ü©
  let p : ‚Ñï ‚Üí A := fun n => F^[n] p0
  have prec : ‚àÄ n, p (n + 1) = F (p n) := fun n => by simp only [p, iterate_succ', Function.comp]
  have pn_fst : ‚àÄ n, (p n).1.1 = n := by
    intro n
    induction' n with n IH
    ¬∑ rfl
    ¬∑ simp only [prec, hFn, IH]
  have Ix : ‚àÄ m n, m + 1 ‚â§ n ‚Üí (p n).1.2.1 m = (p (m + 1)).1.2.1 m := by
    intro m
    apply Nat.le_induction
    ¬∑ rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.fst m = (p n).val.snd.fst m := by
      apply hFx (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  have Iy : ‚àÄ m n, m + 1 ‚â§ n ‚Üí (p n).1.2.2 m = (p (m + 1)).1.2.2 m := by
    intro m
    apply Nat.le_induction
    ¬∑ rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.snd m = (p n).val.snd.snd m := by
      apply hFy (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  set x : ‚Ñï ‚Üí ‚Ñï := fun n => (p (n + 1)).1.2.1 n with hx
  set y : ‚Ñï ‚Üí ‚Ñï := fun n => (p (n + 1)).1.2.2 n with hy
  have M : ‚àÄ n, ¬¨MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    intro n
    convert (p n).2 using 3
    ¬∑ rw [pn_fst, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hx]
      exact (Ix i n hi).symm
    ¬∑ rw [pn_fst, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hy]
      exact (Iy i n hi).symm
  obtain ‚ü®u, v, u_open, v_open, xu, yv, huv‚ü© :
      ‚àÉ u v : Set Œ±, IsOpen u ‚àß IsOpen v ‚àß f x ‚àà u ‚àß g y ‚àà v ‚àß Disjoint u v := by
    apply t2_separation
    exact disjoint_iff_forall_ne.1 h (mem_range_self _) (mem_range_self _)
  letI : MetricSpace (‚Ñï ‚Üí ‚Ñï) := metricSpaceNatNat
  obtain ‚ü®Œµx, Œµxpos, hŒµx‚ü© : ‚àÉ (Œµx : ‚Ñù), Œµx > 0 ‚àß Metric.ball x Œµx ‚äÜ f ‚Åª¬π' u := by
    apply Metric.mem_nhds_iff.1
    exact hf.continuousAt.preimage_mem_nhds (u_open.mem_nhds xu)
  obtain ‚ü®Œµy, Œµypos, hŒµy‚ü© : ‚àÉ (Œµy : ‚Ñù), Œµy > 0 ‚àß Metric.ball y Œµy ‚äÜ g ‚Åª¬π' v := by
    apply Metric.mem_nhds_iff.1
    exact hg.continuousAt.preimage_mem_nhds (v_open.mem_nhds yv)
  obtain ‚ü®n, hn‚ü© : ‚àÉ n : ‚Ñï, (1 / 2 : ‚Ñù) ^ n < min Œµx Œµy :=
    exists_pow_lt_of_lt_one (lt_min Œµxpos Œµypos) (by norm_num)
  have B : MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    refine ‚ü®u, ?_, ?_, u_open.measurableSet‚ü©
    ¬∑ rw [image_subset_iff]
      apply Subset.trans _ hŒµx
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_left _ _))
    ¬∑ refine Disjoint.mono_left ?_ huv.symm
      change g '' cylinder y n ‚äÜ v
      rw [image_subset_iff]
      apply Subset.trans _ hŒµy
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_right _ _))
  exact M n B"
Mathlib/Analysis/Normed/Group/Quotient.lean,quotient_norm_mk_le,quotient_norm_mk_le,2c51ddac66e30dac33162736742396566e191ff8,":=
  cinf‚Çõ_le (bddBelow_image_norm _) <| Set.mem_image_of_mem _ rfl",error:  unknown identifier 'cinf‚Çõ_le',theorem quotient_norm_mk_le (S : AddSubgroup M) (m : M) : ‚Äñmk' S m‚Äñ ‚â§ ‚Äñm‚Äñ ,":=
  csInf_le (bddBelow_image_norm _) <| Set.mem_image_of_mem _ rfl"
Mathlib/Computability/Halting.lean,Nat.Partrec'.rfindOpt,rfindOpt,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  ((rfind <| (of_prim (Primrec.nat_sub.comp‚ÇÇ (.const 1) Primrec.vector_head)).comp‚ÇÅ
      (fun n => Part.some (1 - n)) hf).bind ((prim Nat.Primrec'.pred).comp‚ÇÅ Nat.pred hf))
  |>.of_eq fun v => Part.ext fun b => by
    simp only [Nat.rfindOpt, exists_prop, tsub_eq_zero_iff_le, PFun.coe_val, Part.mem_bind_iff,
      Part.mem_some_iff, Option.mem_def, Part.mem_coe]
    refine exists_congr fun a =>
      (and_congr (iff_of_eq ?_) Iff.rfl).trans (and_congr_right fun h => ?_)
    ¬∑ congr; funext n; cases f (n ::·µ• v) <;> simp [Nat.succ_le_succ] <;> rfl
    ¬∑ have := Nat.rfind_spec h
      simp only [Part.coe_some, Part.mem_some_iff] at this
      revert this; cases' f (a ::·µ• v) <;> rintro ‚ü®‚ü©
      rw [‚Üê Option.some_inj, eq_comm]; rfl","error:  application type mismatch
  Primrec‚ÇÇ.comp‚ÇÇ Primrec.nat_sub (Primrec‚ÇÇ.const 1) Primrec.vector_head
argument
  Primrec.vector_head
has type
  Primrec Vector.head : Prop
but is expected to have type
  Primrec‚ÇÇ ?m.89803 : Prop","theorem rfindOpt {n} {f : Vector ‚Ñï (n + 1) ‚Üí ‚Ñï} (hf : @Partrec' (n + 1) f) :
    @Partrec' n fun v => Nat.rfindOpt fun a => ofNat (Option ‚Ñï) (f (a ::·µ• v)) ",":=
  ((rfind <|
        (of_prim (Primrec.nat_sub.comp (_root_.Primrec.const 1) Primrec.vector_head)).comp‚ÇÅ
          (fun n => Part.some (1 - n)) hf).bind
    ((prim Nat.Primrec'.pred).comp‚ÇÅ Nat.pred hf)).of_eq
    fun v =>
    Part.ext fun b => by
      simp only [Nat.rfindOpt, exists_prop, tsub_eq_zero_iff_le, PFun.coe_val, Part.mem_bind_iff,
        Part.mem_some_iff, Option.mem_def, Part.mem_coe]
      refine
        exists_congr fun a => (and_congr (iff_of_eq ?_) Iff.rfl).trans (and_congr_right fun h => ?_)
      ¬∑ congr
        funext n
        cases f (n ::·µ• v) <;> simp [Nat.succ_le_succ] <;> rfl
      ¬∑ have := Nat.rfind_spec h
        simp only [Part.coe_some, Part.mem_some_iff] at this
        revert this; cases' f (a ::·µ• v) with c <;> intro this
        ¬∑ cases this
        rw [‚Üê Option.some_inj, eq_comm]
        rfl"
Mathlib/RingTheory/Adjoin/PowerBasis.lean,PowerBasis.repr_mul_isIntegral,repr_mul_isIntegral,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  intro i
  rw [‚Üê B.basis.sum_repr x, ‚Üê B.basis.sum_repr y, Finset.sum_mul_sum, map_sum, Finset.sum_apply']
  refine' IsIntegral.sum _ fun I _ => _
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smul‚Çõ‚Çó,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine' isIntegral_mul (hy _) (isIntegral_mul (hx _) _)
  simp only [coe_basis, ‚Üê pow_add]
  refine' repr_gen_pow_isIntegral hB hmin _ _","error:  unknown identifier 'isIntegral_mul'
error:  no goals to be solved
error:  application type mismatch
  repr_mul_isIntegral hB
argument
  hB
has type
  IsIntegral R B.gen : Prop
but is expected to have type
  ‚àÄ (i : Fin ?m.77364.dim), IsIntegral ?m.77357 ((?m.77364.basis.repr ?m.77366) i) : Prop
error:  application type mismatch
  repr_pow_isIntegral hB
argument
  hB
has type
  IsIntegral R B.gen : Prop
but is expected to have type
  ‚àÄ (i : Fin ?m.83636.dim), IsIntegral ?m.83629 ((?m.83636.basis.repr ?m.83638) i) : Prop
error:  no goals to be solved","theorem repr_mul_isIntegral [IsDomain S] {x y : A} (hx : ‚àÄ i, IsIntegral R (B.basis.repr x i))
    (hy : ‚àÄ i, IsIntegral R (B.basis.repr y i))
    (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) :
    ‚àÄ i, IsIntegral R (B.basis.repr (x * y) i) ",":= by
  intro i
  rw [‚Üê B.basis.sum_repr x, ‚Üê B.basis.sum_repr y, Finset.sum_mul_sum, ‚Üê Finset.sum_product',
    map_sum, Finset.sum_apply']
  refine IsIntegral.sum _ fun I _ => ?_
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smul‚Çõ‚Çó,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine (hy _).mul ((hx _).mul ?_)
  simp only [coe_basis, ‚Üê pow_add]
  exact repr_gen_pow_isIntegral hB hmin _ _"
Mathlib/LinearAlgebra/TensorProduct/RightExactness.lean,Algebra.TensorProduct.map_ker,Algebra.TensorProduct.map_ker,01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  have : map f g = (map f (AlgHom.id R D)).comp (map (AlgHom.id R A) g) := ext rfl rfl
  rw [this]
  simp only [AlgHom.coe_ker, AlgHom.comp_toRingHom]
  rw [‚Üê RingHom.comap_ker]
  simp only [‚Üê AlgHom.coe_ker]
  rw [‚Üê Algebra.TensorProduct.lTensor_ker _ hg, RingHom.ker_eq_comap_bot (map (AlgHom.id R A) g)]
  rw [‚Üê Ideal.comap_map_of_surjective _ (lTensor.surjective A hg)]
  rw [Algebra.TensorProduct.rTensor_ker _ hf]
  apply congr_arg‚ÇÇ _ rfl
  simp only [AlgHom.coe_ideal_map, Ideal.map_map]
  rw [‚Üê AlgHom.comp_toRingHom, Algebra.TensorProduct.map_comp_includeLeft]
  rfl",error:  unknown identifier 'lTensor.surjective',"theorem Algebra.TensorProduct.map_ker (hf : Function.Surjective f) (hg : Function.Surjective g) :
    RingHom.ker (map f g) =
      (RingHom.ker f).map (Algebra.TensorProduct.includeLeft : A ‚Üí‚Çê[R] A ‚äó[R] C) ‚äî
        (RingHom.ker g).map (Algebra.TensorProduct.includeRight : C ‚Üí‚Çê[R] A ‚äó[R] C) ",":= by
  have : map f g = (map f (AlgHom.id R D)).comp (map (AlgHom.id R A) g) := ext rfl rfl
  rw [this]
  simp only [AlgHom.coe_ker, AlgHom.comp_toRingHom]
  rw [‚Üê RingHom.comap_ker]
  simp only [‚Üê AlgHom.coe_ker]
  rw [‚Üê Algebra.TensorProduct.lTensor_ker _ hg, RingHom.ker_eq_comap_bot (map (AlgHom.id R A) g)]
  rw [‚Üê Ideal.comap_map_of_surjective (map (AlgHom.id R A) g) (LinearMap.lTensor_surjective A hg)]
  rw [Algebra.TensorProduct.rTensor_ker _ hf]
  apply congr_arg‚ÇÇ _ rfl
  simp only [AlgHom.coe_ideal_map, Ideal.map_map]
  rw [‚Üê AlgHom.comp_toRingHom, Algebra.TensorProduct.map_comp_includeLeft]
  rfl"
Mathlib/Algebra/Homology/ShortComplex/HomologicalComplex.lean,HomologicalComplex.liftCycles_homologyœÄ_eq_zero_of_boundary,liftCycles_homologyœÄ_eq_zero_of_boundary,9072ff84a0d139a344bf9eed4a00c4cd27596c79,":= by
  by_cases c.Rel i' i
  ¬∑ obtain rfl := c.prev_eq' h
    exact (K.sc i).liftCycles_homologyœÄ_eq_zero_of_boundary _ x hx
  ¬∑ have : liftCycles K k j hj (by rw [hx, assoc, K.d_comp_d, comp_zero]) = 0 := by
      rw [K.shape _ _ h, comp_zero] at hx
      rw [‚Üê cancel_mono (K.iCycles i), zero_comp, liftCycles_i, hx]
    rw [this, zero_comp]","error:  unknown identifier 'h'
error:  tactic 'subst' failed, invalid equality proof, it is not of the form (x = t) or (t = x)
  c.prev ?m.31485 = ?m.31484
case pos
C : Type u_1
inst‚úù¬≤ : Category.{u_3, u_1} C
inst‚úù¬π : HasZeroMorphisms C
Œπ : Type u_2
c : ComplexShape Œπ
K L M : HomologicalComplex C c
œÜ : K ‚ü∂ L
œà : L ‚ü∂ M
i j‚úù k‚úù : Œπ
inst‚úù : K.HasHomology i
A : C
k : A ‚ü∂ K.X i
j : Œπ
hj : c.next i = j
i' : Œπ
x : A ‚ü∂ K.X i'
hx : k = x ‚â´ K.d i' i
h‚úù : c.Rel i' i
x‚úù : c.prev ?m.31485 = ?m.31484
‚ä¢ K.liftCycles k j hj ‚ãØ ‚â´ K.homologyœÄ i = 0
error:  unknown identifier 'h'","lemma liftCycles_homologyœÄ_eq_zero_of_boundary {A : C} (k : A ‚ü∂ K.X i) (j : Œπ)
    (hj : c.next i = j) {i' : Œπ} (x : A ‚ü∂ K.X i') (hx : k = x ‚â´ K.d i' i) :
    K.liftCycles k j hj (by rw [hx, assoc, K.d_comp_d, comp_zero]) ‚â´ K.homologyœÄ i = 0 ",":= by
  by_cases h : c.Rel i' i
  ¬∑ obtain rfl := c.prev_eq' h
    exact (K.sc i).liftCycles_homologyœÄ_eq_zero_of_boundary _ x hx
  ¬∑ have : liftCycles K k j hj (by rw [hx, assoc, K.d_comp_d, comp_zero]) = 0 := by
      rw [K.shape _ _ h, comp_zero] at hx
      rw [‚Üê cancel_mono (K.iCycles i), zero_comp, liftCycles_i, hx]
    rw [this, zero_comp]"
Mathlib/Data/Finset/Fold.lean,Finset.fold_op_rel_iff_or,fold_op_rel_iff_or,90adef390b0b6ace6b8981bd319263bfb32d514e,":= by
  classical
    induction' s with a s ha IH
    ¬∑ simp
    rw [Finset.fold_insert ha, hr, IH, ‚Üê or_assoc, @or_comm (r c (f a)), or_assoc]
    apply or_congr Iff.rfl
    constructor
    ¬∑ rintro (h‚ÇÅ | ‚ü®x, hx, h‚ÇÇ‚ü©)
      ¬∑ use a
        simp [h‚ÇÅ]
      ¬∑ refine' ‚ü®x, by simp [hx], h‚ÇÇ‚ü©
    ¬∑ rintro ‚ü®x, hx, h‚ü©
      exact (mem_insert.mp hx).imp (fun hx => by rwa [hx] at h) (fun hx => ‚ü®x, hx, h‚ü©)","error:  unsolved goals
case mk
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
op : Œ≤ ‚Üí Œ≤ ‚Üí Œ≤
hc : Std.Commutative op
ha : Std.Associative op
f : Œ± ‚Üí Œ≤
b : Œ≤
s‚úù : Finset Œ±
a‚úù : Œ±
r : Œ≤ ‚Üí Œ≤ ‚Üí Prop
hr : ‚àÄ {x y z : Œ≤}, r x (op y z) ‚Üî r x y ‚à® r x z
c : Œ≤
a : Multiset Œ±
s : a.Nodup
‚ä¢ r c (fold op b f { val := a, nodup := s }) ‚Üî r c b ‚à® ‚àÉ x ‚àà a, r c (f x)
error:  no goals to be solved","theorem fold_op_rel_iff_or {r : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (hr : ‚àÄ {x y z}, r x (op y z) ‚Üî r x y ‚à® r x z)
    {c : Œ≤} : r c (s.fold op b f) ‚Üî r c b ‚à® ‚àÉ x ‚àà s, r c (f x) ",":= by
  classical
    induction' s using Finset.induction_on with a s ha IH
    ¬∑ simp
    rw [Finset.fold_insert ha, hr, IH, ‚Üê or_assoc, @or_comm (r c (f a)), or_assoc]
    apply or_congr Iff.rfl
    constructor
    ¬∑ rintro (h‚ÇÅ | ‚ü®x, hx, h‚ÇÇ‚ü©)
      ¬∑ use a
        simp [h‚ÇÅ]
      ¬∑ refine ‚ü®x, by simp [hx], h‚ÇÇ‚ü©
    ¬∑ rintro ‚ü®x, hx, h‚ü©
      exact (mem_insert.mp hx).imp (fun hx => by rwa [hx] at h) (fun hx => ‚ü®x, hx, h‚ü©)"
Mathlib/Combinatorics/SetFamily/CauchyDavenport.lean,Finset.min_le_card_mul,Finset.min_le_card_mul,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain ‚ü®rfl, rfl‚ü© := hx
  refine wellFoundedOn_devosMulRel.induction (P := fun x : Finset Œ± √ó Finset Œ± ‚Ü¶
    min (minOrder Œ±) ‚Üë(card x.1 + card x.2 - 1) ‚â§ card (x.1 * x.2)) ‚ü®hs, ht‚ü© ?_
  clear! x
  rintro ‚ü®s, t‚ü© ‚ü®hs, ht‚ü© ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  ¬∑ simpa only [‚Üê mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [‚Üê mul_inv_rev, add_comm, card_inv, true_and])
  obtain ‚ü®a, rfl‚ü© | ‚ü®a, ha, b, hb, hab‚ü© := hs.exists_eq_singleton_or_nontrivial
  ¬∑ simp [add_comm]
  obtain ‚ü®g, hg, hgs‚ü© : ‚àÉ g : Œ±, g ‚â† 1 ‚àß (s ‚à© op g ‚Ä¢ s).Nonempty :=
    ‚ü®b‚Åª¬π * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 ‚ü®ha, mem_smul_finset.2 ‚ü®_, hb, by simp‚ü©‚ü©‚ü©
  obtain hsg | hsg := eq_or_ne (op g ‚Ä¢ s) s
  ¬∑ have hS : (zpowers g : Set Œ±) ‚äÜ a‚Åª¬π ‚Ä¢ (s : Set Œ±) := by
      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (¬∑ ‚àà a‚Åª¬π ‚Ä¢ (s : Set Œ±))
        ‚ü®_, ha, inv_mul_self _‚ü© (fun c hc ‚Ü¶ ?_) fun c hc ‚Ü¶ ?_
      ¬∑ rw [‚Üê hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      ¬∑ simp only
        rwa [‚Üê op_smul_eq_mul, op_inv, ‚Üê Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          ‚Üê coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [‚Üê coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s ‚à© op g ‚Ä¢ s).card < s.card := card_lt_card ‚ü®inter_subset_left _ _, fun h ‚Ü¶
    hsg <| eq_of_superset_of_card_ge (h.trans <| inter_subset_right _ _) (card_smul_finset _ _).le‚ü©
  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (g‚Åª¬π ‚Ä¢ t)
  ¬∑ rw [‚Üê card_smul_finset g‚Åª¬π t]
    refine Or.inr ((add_le_add_right hst _).trans ?_)
    rw [‚Üê card_union_of_disjoint hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  ¬∑ exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h ‚Ü¶ hstg.trans <| h.trans <| add_le_add_right aux1 _
  ¬∑ exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h ‚Ü¶
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _","error:  function expected at
  inter_subset_left ?m.46803
term has type
  ?m.46802 ‚àà ?m.46800
error:  function expected at
  inter_subset_right ?m.46987
term has type
  ?m.46986 ‚àà ?m.46985","lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder Œ±) ‚Üë(s.card + t.card - 1) ‚â§ (s * t).card ",":= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain ‚ü®rfl, rfl‚ü© := hx
  refine wellFoundedOn_devosMulRel.induction (P := fun x : Finset Œ± √ó Finset Œ± ‚Ü¶
    min (minOrder Œ±) ‚Üë(card x.1 + card x.2 - 1) ‚â§ card (x.1 * x.2)) ‚ü®hs, ht‚ü© ?_
  clear! x
  rintro ‚ü®s, t‚ü© ‚ü®hs, ht‚ü© ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  ¬∑ simpa only [‚Üê mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [‚Üê mul_inv_rev, add_comm, card_inv, true_and])
  obtain ‚ü®a, rfl‚ü© | ‚ü®a, ha, b, hb, hab‚ü© := hs.exists_eq_singleton_or_nontrivial
  ¬∑ simp [add_comm]
  obtain ‚ü®g, hg, hgs‚ü© : ‚àÉ g : Œ±, g ‚â† 1 ‚àß (s ‚à© op g ‚Ä¢ s).Nonempty :=
    ‚ü®b‚Åª¬π * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 ‚ü®ha, mem_smul_finset.2 ‚ü®_, hb, by simp‚ü©‚ü©‚ü©
  obtain hsg | hsg := eq_or_ne (op g ‚Ä¢ s) s
  ¬∑ have hS : (zpowers g : Set Œ±) ‚äÜ a‚Åª¬π ‚Ä¢ (s : Set Œ±) := by
      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (¬∑ ‚àà a‚Åª¬π ‚Ä¢ (s : Set Œ±))
        ‚ü®_, ha, inv_mul_self _‚ü© (fun c hc ‚Ü¶ ?_) fun c hc ‚Ü¶ ?_
      ¬∑ rw [‚Üê hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      ¬∑ simp only
        rwa [‚Üê op_smul_eq_mul, op_inv, ‚Üê Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          ‚Üê coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [‚Üê coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s ‚à© op g ‚Ä¢ s).card < s.card := card_lt_card ‚ü®inter_subset_left, fun h ‚Ü¶
    hsg <| eq_of_superset_of_card_ge (h.trans inter_subset_right) (card_smul_finset _ _).le‚ü©
  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (g‚Åª¬π ‚Ä¢ t)
  ¬∑ rw [‚Üê card_smul_finset g‚Åª¬π t]
    refine Or.inr ((add_le_add_right hst _).trans ?_)
    rw [‚Üê card_union_of_disjoint hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  ¬∑ exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h ‚Ü¶ hstg.trans <| h.trans <| add_le_add_right aux1 _
  ¬∑ exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h ‚Ü¶
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _"
Mathlib/Topology/Category/Profinite/Nobeling.lean,Profinite.NobelingProof.Products.max_eq_eval,Products.max_eq_eval,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have hlc : ((term I ho) :: l.Tail.val).Chain' (¬∑>¬∑) := by
    rw [‚Üê max_eq_o_cons_tail ho l hl hlh]; exact l.prop
  rw [max_eq_o_cons_tail' ho l hl hlh hlc, Products.evalCons]
  ext x
  simp only [Linear_CC', Linear_CC'‚ÇÅ, LocallyConstant.comap‚Çó, Linear_CC'‚ÇÄ, Subtype.coe_eta,
    LinearMap.sub_apply, LinearMap.coe_mk, AddHom.coe_mk, LocallyConstant.sub_apply,
    LocallyConstant.coe_comap, LocallyConstant.coe_mul, ContinuousMap.coe_mk, Function.comp_apply,
    Pi.mul_apply]
  rw [CC'‚ÇÅ, CC'‚ÇÄ, Products.eval_eq, Products.eval_eq, Products.eval_eq]
  simp only [mul_ite, mul_one, mul_zero]
  have hi' : ‚àÄ i, i ‚àà l.Tail.val ‚Üí (x.val i = SwapTrue o x.val i) := by
    intro i hi
    simp only [SwapTrue, @eq_comm _ (x.val i), ite_eq_right_iff, ord_term ho]
    rintro rfl
    exact ((List.Chain.rel hlc hi).ne rfl).elim
  have H : (‚àÄ i, i ‚àà l.Tail.val ‚Üí (x.val i = true)) =
      (‚àÄ i, i ‚àà l.Tail.val ‚Üí (SwapTrue o x.val i = true)) := by
    apply forall_congr; intro i; apply forall_congr; intro hi; rw [hi' i hi]
  simp only [H]
  split_ifs with h‚ÇÅ h‚ÇÇ h‚ÇÉ <;> try (dsimp [e])
  ¬∑ rw [if_pos (swapTrue_eq_true _ _), if_neg]
    ¬∑ rfl
    ¬∑ simp [mem_C'_eq_false C ho x x.prop, Bool.coe_false]
  ¬∑ push_neg at h‚ÇÇ; obtain ‚ü®i, hi‚ü© := h‚ÇÇ; exfalso; rw [hi' i hi.1] at hi; exact hi.2 (h‚ÇÅ i hi.1)
  ¬∑ push_neg at h‚ÇÅ; obtain ‚ü®i, hi‚ü© := h‚ÇÅ; exfalso; rw [‚Üê hi' i hi.1] at hi; exact hi.2 (h‚ÇÉ i hi.1)
  ¬∑ rfl",error:  no goals to be solved,"theorem Products.max_eq_eval [Inhabited I] (l : Products I) (hl : l.val ‚â† [])
    (hlh : l.val.head! = term I ho) :
    Linear_CC' C hsC ho (l.eval C) = l.Tail.eval (C' C ho) ",":= by
  have hlc : ((term I ho) :: l.Tail.val).Chain' (¬∑>¬∑) := by
    rw [‚Üê max_eq_o_cons_tail ho l hl hlh]; exact l.prop
  rw [max_eq_o_cons_tail' ho l hl hlh hlc, Products.evalCons]
  ext x
  simp only [Linear_CC', Linear_CC'‚ÇÅ, LocallyConstant.comap‚Çó, Linear_CC'‚ÇÄ, Subtype.coe_eta,
    LinearMap.sub_apply, LinearMap.coe_mk, AddHom.coe_mk, LocallyConstant.sub_apply,
    LocallyConstant.coe_comap, LocallyConstant.coe_mul, ContinuousMap.coe_mk, Function.comp_apply,
    Pi.mul_apply]
  rw [CC'‚ÇÅ, CC'‚ÇÄ, Products.eval_eq, Products.eval_eq, Products.eval_eq]
  simp only [mul_ite, mul_one, mul_zero]
  have hi' : ‚àÄ i, i ‚àà l.Tail.val ‚Üí (x.val i = SwapTrue o x.val i) := by
    intro i hi
    simp only [SwapTrue, @eq_comm _ (x.val i), ite_eq_right_iff, ord_term ho]
    rintro rfl
    exact ((List.Chain.rel hlc hi).ne rfl).elim
  have H : (‚àÄ i, i ‚àà l.Tail.val ‚Üí (x.val i = true)) =
      (‚àÄ i, i ‚àà l.Tail.val ‚Üí (SwapTrue o x.val i = true)) := by
    apply forall_congr; intro i; apply forall_congr; intro hi; rw [hi' i hi]
  simp only [H]
  split_ifs with h‚ÇÅ h‚ÇÇ h‚ÇÉ <;> try (dsimp [e])
  ¬∑ rw [if_pos (swapTrue_eq_true _ _), if_neg]
    ¬∑ rfl
    ¬∑ simp [mem_C'_eq_false C ho x x.prop, Bool.coe_false]
  ¬∑ push_neg at h‚ÇÇ; obtain ‚ü®i, hi‚ü© := h‚ÇÇ; exfalso; rw [hi' i hi.1] at hi; exact hi.2 (h‚ÇÅ i hi.1)
  ¬∑ push_neg at h‚ÇÅ; obtain ‚ü®i, hi‚ü© := h‚ÇÅ; exfalso; rw [‚Üê hi' i hi.1] at hi; exact hi.2 (h‚ÇÉ i hi.1)"
Mathlib/LinearAlgebra/Eigenspace/Minpoly.lean,Module.End.aeval_apply_of_hasEigenvector,aeval_apply_of_hasEigenvector,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine p.induction_on ?_ ??_ _
  ¬∑ intro a; simp [Module.algebraMap_end_apply]
  ¬∑ intro p q hp hq; simp [hp, hq, add_smul]
  ¬∑ intro n a hna
    rw [mul_comm, pow_succ', mul_assoc, AlgHom.map_mul, LinearMap.mul_apply, mul_comm, hna]
    simp only [mem_eigenspace_iff.1 h.1, smul_smul, aeval_X, eval_mul, eval_C, eval_pow, eval_X,
      LinearMap.map_smul‚Çõ‚Çó, RingHom.id_apply, mul_comm]",error:  unexpected token '?'; expected '_' or identifier,"theorem aeval_apply_of_hasEigenvector {f : End K V} {p : K[X]} {Œº : K} {x : V}
    (h : f.HasEigenvector Œº x) : aeval f p x = p.eval Œº ‚Ä¢ x ",":= by
  refine p.induction_on ?_ ?_ ?_
  ¬∑ intro a; simp [Module.algebraMap_end_apply]
  ¬∑ intro p q hp hq; simp [hp, hq, add_smul]
  ¬∑ intro n a hna
    rw [mul_comm, pow_succ', mul_assoc, AlgHom.map_mul, LinearMap.mul_apply, mul_comm, hna]
    simp only [mem_eigenspace_iff.1 h.1, smul_smul, aeval_X, eval_mul, eval_C, eval_pow, eval_X,
      LinearMap.map_smul‚Çõ‚Çó, RingHom.id_apply, mul_comm]"
Mathlib/Analysis/Calculus/Taylor.lean,taylor_mean_remainder_lagrange,taylor_mean_remainder_lagrange,e7cfa54a55b1673fdd85ff41e3d36bbae924e8be,":= by
  have gcont : ContinuousOn (fun t : ‚Ñù => (x - t) ^ (n + 1)) (Icc x‚ÇÄ x) := by
    refine' Continuous.continuousOn _
    exact (continuous_const.sub continuous_id').pow _ 
  have xy_ne : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí (x - y) ^ n ‚â† 0 := by
    intro y hy
    refine' pow_ne_zero _ _
    rw [mem_Ioo] at hy
    rw [sub_ne_zero]
    exact hy.2.ne'
  have hg' : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí -(‚Üën + 1) * (x - y) ^ n ‚â† 0 := fun y hy =>
    mul_ne_zero (neg_ne_zero.mpr (Nat.cast_add_one_ne_zero n)) (xy_ne y hy)
  rcases taylor_mean_remainder hx hf hf' gcont (fun y _ => monomial_has_deriv_aux y x _) hg' with
    ‚ü®y, hy, h‚ü©
  use y, hy
  simp only [sub_self, zero_pow', Ne.def, Nat.succ_ne_zero, not_false_iff, zero_sub, mul_neg] at h
  rw [h, neg_div, ‚Üê div_neg, neg_mul, neg_neg]
  field_simp [xy_ne y hy, Nat.factorial];  ring","error:  unknown identifier 'zero_pow''
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.136807 ‚Üí ?m.136807 ‚Üí Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  -?b / ?a
case right
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚Ñù E
f : ‚Ñù ‚Üí ‚Ñù
x x‚ÇÄ : ‚Ñù
n : ‚Ñï
hx : x‚ÇÄ < x
hf : ContDiffOn ‚Ñù (‚Üën) f (Icc x‚ÇÄ x)
hf' : DifferentiableOn ‚Ñù (iteratedDerivWithin n f (Icc x‚ÇÄ x)) (Ioo x‚ÇÄ x)
gcont : ContinuousOn (fun t ‚Ü¶ (x - t) ^ (n + 1)) (Icc x‚ÇÄ x)
xy_ne : ‚àÄ y ‚àà Ioo x‚ÇÄ x, (x - y) ^ n ‚â† 0
hg' : ‚àÄ y ‚àà Ioo x‚ÇÄ x, -(‚Üën + 1) * (x - y) ^ n ‚â† 0
y : ‚Ñù
hy : y ‚àà Ioo x‚ÇÄ x
h :
  f x - taylorWithinEval f n (Icc x‚ÇÄ x) x‚ÇÄ x =
    ((x - y) ^ n / ‚Üën ! * (0 ^ (n + 1) - (x - x‚ÇÄ) ^ (n + 1)) / (-(‚Üën + 1) * (x - y) ^ n)) ‚Ä¢
      iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) y
‚ä¢ ((x - y) ^ n / ‚Üën ! * (0 ^ (n + 1) - (x - x‚ÇÄ) ^ (n + 1)) / (-(‚Üën + 1) * (x - y) ^ n)) ‚Ä¢
      iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) y =
    iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) y * (x - x‚ÇÄ) ^ (n + 1) / ‚Üë(n + 1)!","theorem taylor_mean_remainder_lagrange {f : ‚Ñù ‚Üí ‚Ñù} {x x‚ÇÄ : ‚Ñù} {n : ‚Ñï} (hx : x‚ÇÄ < x)
    (hf : ContDiffOn ‚Ñù n f (Icc x‚ÇÄ x))
    (hf' : DifferentiableOn ‚Ñù (iteratedDerivWithin n f (Icc x‚ÇÄ x)) (Ioo x‚ÇÄ x)) :
    ‚àÉ x' ‚àà Ioo x‚ÇÄ x, f x - taylorWithinEval f n (Icc x‚ÇÄ x) x‚ÇÄ x =
      iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) x' * (x - x‚ÇÄ) ^ (n + 1) / (n + 1)! ",":= by
  have gcont : ContinuousOn (fun t : ‚Ñù => (x - t) ^ (n + 1)) (Icc x‚ÇÄ x) := by fun_prop
  have xy_ne : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí (x - y) ^ n ‚â† 0 := by
    intro y hy
    refine pow_ne_zero _ ?_
    rw [mem_Ioo] at hy
    rw [sub_ne_zero]
    exact hy.2.ne'
  have hg' : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí -(‚Üën + 1) * (x - y) ^ n ‚â† 0 := fun y hy =>
    mul_ne_zero (neg_ne_zero.mpr (Nat.cast_add_one_ne_zero n)) (xy_ne y hy)
  rcases taylor_mean_remainder hx hf hf' gcont (fun y _ => monomial_has_deriv_aux y x _) hg' with
    ‚ü®y, hy, h‚ü©
  use y, hy
  simp only [sub_self, zero_pow, Ne, Nat.succ_ne_zero, not_false_iff, zero_sub, mul_neg] at h
  rw [h, neg_div, ‚Üê div_neg, neg_mul, neg_neg]
  field_simp [xy_ne y hy, Nat.factorial]; ring"
Mathlib/LinearAlgebra/TensorProduct/RightExactness.lean,Algebra.TensorProduct.map_ker,Algebra.TensorProduct.map_ker,4b87b25f37ec0a84d277402f67adcc0e32c4ca30,":= by
  have : map f g = (map f (AlgHom.id R D)).comp (map (AlgHom.id R A) g) := ext rfl rfl
  rw [this]
  simp only [AlgHom.coe_ker, AlgHom.comp_toRingHom]
  rw [‚Üê RingHom.comap_ker]
  simp only [‚Üê AlgHom.coe_ker]
  rw [‚Üê Algebra.TensorProduct.lTensor_ker _ hg, RingHom.ker_eq_comap_bot (map (AlgHom.id R A) g)]
  rw [‚Üê Ideal.comap_map_of_surjective (map (AlgHom.id R A) g) (lTensor.surjective A hg)]
  rw [Algebra.TensorProduct.rTensor_ker _ hf]
  apply congr_arg‚ÇÇ _ rfl
  simp only [AlgHom.coe_ideal_map, Ideal.map_map]
  rw [‚Üê AlgHom.comp_toRingHom, Algebra.TensorProduct.map_comp_includeLeft]
  rfl",error:  unknown identifier 'lTensor.surjective',"theorem Algebra.TensorProduct.map_ker (hf : Function.Surjective f) (hg : Function.Surjective g) :
    RingHom.ker (map f g) =
      (RingHom.ker f).map (Algebra.TensorProduct.includeLeft : A ‚Üí‚Çê[R] A ‚äó[R] C) ‚äî
        (RingHom.ker g).map (Algebra.TensorProduct.includeRight : C ‚Üí‚Çê[R] A ‚äó[R] C) ",":= by
  have : map f g = (map f (AlgHom.id R D)).comp (map (AlgHom.id R A) g) := ext rfl rfl
  rw [this]
  simp only [AlgHom.coe_ker, AlgHom.comp_toRingHom]
  rw [‚Üê RingHom.comap_ker]
  simp only [‚Üê AlgHom.coe_ker]
  rw [‚Üê Algebra.TensorProduct.lTensor_ker _ hg, RingHom.ker_eq_comap_bot (map (AlgHom.id R A) g)]
  rw [‚Üê Ideal.comap_map_of_surjective (map (AlgHom.id R A) g) (LinearMap.lTensor_surjective A hg)]
  rw [Algebra.TensorProduct.rTensor_ker _ hf]
  apply congr_arg‚ÇÇ _ rfl
  simp only [AlgHom.coe_ideal_map, Ideal.map_map]
  rw [‚Üê AlgHom.comp_toRingHom, Algebra.TensorProduct.map_comp_includeLeft]
  rfl"
Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean,WeierstrassCurve.Jacobian.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,fa01869a99ed2fbab2a8018d7b90f0b21bff1372,":= by
  rw [‚Üê fin3_def P, hPz] at hP ‚ä¢
  rw [‚Üê fin3_def Q, hQz] at hQ ‚ä¢
  simp [nonsingular_iff, equation_iff] at hP hQ
  have hPx : P x ‚â† 0 := fun h => by simp [h] at hP; simp [hP] at hP
  have hQx : Q x ‚â† 0 := fun h => by simp [h] at hQ; simp [hQ] at hQ
  have hPy : P y ‚â† 0 := fun h => by simp [h] at hP; exact hPx <| pow_eq_zero hP.left.symm
  have hQy : Q y ‚â† 0 := fun h => by simp [h] at hQ; exact hQx <| pow_eq_zero hQ.left.symm
  use Units.mk0 _ <| mul_ne_zero (div_ne_zero hPy hPx) (div_ne_zero hQx hQy)
  simp [smul_fin3, mul_pow, div_pow]
  congr! 2
  ¬∑ field_simp [hP.left, hQ.left]
    ring1
  ¬∑ field_simp [‚Üê hP.left, ‚Üê hQ.left]
    ring1","error:  application type mismatch
  pow_eq_zero (Eq.symm hP.left)
argument
  Eq.symm hP.left
has type
  0 = P x : Prop
but is expected to have type
  P x ^ ?m.312435 = 0 : Prop
error:  unsolved goals
R : Type u
inst‚úù¬π : CommRing R
W' : Jacobian R
F : Type v
inst‚úù : Field F
W : Jacobian F
P Q : Fin 3 ‚Üí F
hPz : P z = 0
hQz : Q z = 0
hQ : Q y ^ 2 - Q x ^ 3 = 0 ‚àß (¬¨3 = 0 ‚àß ¬¨Q x = 0 ‚à® ¬¨2 = 0 ‚àß ¬¨Q y = 0 ‚à® (¬¨W.a‚ÇÅ = 0 ‚àß ¬¨Q x = 0) ‚àß ¬¨Q y = 0)
hPx : P x ‚â† 0
hQx : Q x ‚â† 0
h : P y = 0
hP : P x = 0 ‚àß ¬¨3 = 0 ‚àß ¬¨P x = 0
‚ä¢ False
error:  application type mismatch
  pow_eq_zero (Eq.symm hQ.left)
argument
  Eq.symm hQ.left
has type
  0 = Q x : Prop
but is expected to have type
  Q x ^ ?m.313674 = 0 : Prop
error:  unsolved goals
R : Type u
inst‚úù¬π : CommRing R
W' : Jacobian R
F : Type v
inst‚úù : Field F
W : Jacobian F
P Q : Fin 3 ‚Üí F
hPz : P z = 0
hQz : Q z = 0
hP : P y ^ 2 - P x ^ 3 = 0 ‚àß (¬¨3 = 0 ‚àß ¬¨P x = 0 ‚à® ¬¨2 = 0 ‚àß ¬¨P y = 0 ‚à® (¬¨W.a‚ÇÅ = 0 ‚àß ¬¨P x = 0) ‚àß ¬¨P y = 0)
hPx : P x ‚â† 0
hQx : Q x ‚â† 0
hPy : P y ‚â† 0
h : Q y = 0
hQ : Q x = 0 ‚àß ¬¨3 = 0 ‚àß ¬¨Q x = 0
‚ä¢ False
error:  simp made no progress
error:  no goals to be solved","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  have hPx : IsUnit <| P x := isUnit_X_of_Z_eq_zero hP hPz
  have hPy : IsUnit <| P y := isUnit_Y_of_Z_eq_zero hP hPz
  have hQx : IsUnit <| Q x := isUnit_X_of_Z_eq_zero hQ hQz
  have hQy : IsUnit <| Q y := isUnit_Y_of_Z_eq_zero hQ hQz
  simp only [nonsingular_of_Z_eq_zero, equation_of_Z_eq_zero, hPz, hQz] at hP hQ
  use (hPy.unit / hPx.unit) * (hQx.unit / hQy.unit)
  simp only [Units.smul_def, smul_fin3, Units.val_mul, Units.val_div_eq_div_val, IsUnit.unit_spec,
    mul_pow, div_pow, hQz, mul_zero]
  conv_rhs => rw [‚Üê fin3_def P, hPz]
  congr! 2
  ¬∑ rw [hP.left, pow_succ, (hPx.pow 2).mul_div_cancel_left, hQ.left, pow_succ _ 2,
      (hQx.pow 2).div_mul_cancel_left, hQx.inv_mul_cancel_right]
  ¬∑ rw [‚Üê hP.left, pow_succ, (hPy.pow 2).mul_div_cancel_left, ‚Üê hQ.left, pow_succ _ 2,
      (hQy.pow 2).div_mul_cancel_left, hQy.inv_mul_cancel_right]"
Mathlib/Analysis/Convex/Slope.lean,StrictConvexOn.slope_strict_mono_adjacent,StrictConvexOn.slope_strict_mono_adjacent,009b0477e0161944b3592293b39c80c15ae7a75a,":= by
  have hxz := hxy.trans hyz
  have hxz' := hxz.ne
  rw [‚Üê sub_pos] at hxy hxz hyz
  suffices f y / (y - x) + f y / (z - y) < f x / (y - x) + f z / (z - y) by
    ring_nf  at this‚ä¢
    linarith
  set a := (z - y) / (z - x)
  set b := (y - x) / (z - x)
  have hy : a ‚Ä¢ x + b ‚Ä¢ z = y := by
    field_simp
    rw [div_eq_iff] <;> [ring; linarith]
  have key :=
    hf.2 hx hz hxz' (div_pos hyz hxz) (div_pos hxy hxz)
      (show a + b = 1 by
        field_simp
        rw [div_eq_iff] <;> [ring; linarith])
  rw [hy] at key
  replace key := mul_lt_mul_of_pos_left key hxz
  field_simp [hxy.ne', hyz.ne', hxz.ne', mul_comm (z - x) _]  at key‚ä¢
  rw [div_lt_div_right]
  ¬∑ linarith
  ¬∑ nlinarith","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.48812 / ?m.48813 = ?m.48814
ùïú : Type u_1
inst‚úù : LinearOrderedField ùïú
s : Set ùïú
f : ùïú ‚Üí ùïú
hf : StrictConvexOn ùïú s f
x y z : ùïú
hx : x ‚àà s
hz : z ‚àà s
hxy : 0 < y - x
hyz : 0 < z - y
hxz : 0 < z - x
hxz' : x ‚â† z
a : ùïú := (z - y) / (z - x)
b : ùïú := (y - x) / (z - x)
‚ä¢ a * x + b * z = y
error:  simp made no progress","theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn ùïú s f) {x y z : ùïú}
    (hx : x ‚àà s) (hz : z ‚àà s) (hxy : x < y) (hyz : y < z) :
    (f y - f x) / (y - x) < (f z - f y) / (z - y) ",":= by
  have hxz := hxy.trans hyz
  have hxz' := hxz.ne
  rw [‚Üê sub_pos] at hxy hxz hyz
  suffices f y / (y - x) + f y / (z - y) < f x / (y - x) + f z / (z - y) by
    ring_nf at this ‚ä¢
    linarith
  set a := (z - y) / (z - x)
  set b := (y - x) / (z - x)
  have hy : a ‚Ä¢ x + b ‚Ä¢ z = y := by field_simp [a, b]; ring
  have key :=
    hf.2 hx hz hxz' (div_pos hyz hxz) (div_pos hxy hxz)
      (show a + b = 1 by field_simp [a, b])
  rw [hy] at key
  replace key := mul_lt_mul_of_pos_left key hxz
  field_simp [mul_comm (z - x) _] at key ‚ä¢
  rw [div_lt_div_right]
  ¬∑ linarith
  ¬∑ nlinarith"
Mathlib/Data/List/InsertNth.lean,List.get_insertNth_of_lt,get_insertNth_of_lt,e46f222cc4230a1443bc5f40bf94715a5f5fb154,":= by
  induction' n with n IH generalizing k l
  ¬∑ simp at hn
  ¬∑ cases' l with hd tl
    ¬∑ simp
    ¬∑ cases k
      ¬∑ simp [get]
      ¬∑ rw [Nat.succ_lt_succ_iff] at hn
        simpa using IH _ _ hn _","error:  don't know how to synthesize placeholder for argument 'hk'
context:
Œπ : Type u_1
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
l‚ÇÅ l‚ÇÇ : List Œ±
a x : Œ±
n : ‚Ñï
IH :
  ‚àÄ (l : List Œ±) (k : ‚Ñï),
    k < n ‚Üí
      ‚àÄ (hk : k < l.length) (hk' : optParam (k < (insertNth n x l).length) ‚ãØ),
        (insertNth n x l).get ‚ü®k, hk'‚ü© = l.get ‚ü®k, hk‚ü©
hd : Œ±
tl : List Œ±
n‚úù : ‚Ñï
hn : n‚úù < n
hk : n‚úù + 1 < (hd :: tl).length
hk' : optParam (n‚úù + 1 < (insertNth (n + 1) x (hd :: tl)).length) ‚ãØ
‚ä¢ n‚úù < tl.length
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  try 'simp' instead of 'simpa'
note: this linter can be disabled with `set_option linter.unnecessarySimpa false`
warning:  try 'simp at h' instead of 'simpa using h'
note: this linter can be disabled with `set_option linter.unnecessarySimpa false`
warning:  try 'simp at h' instead of 'simpa using h'
note: this linter can be disabled with `set_option linter.unnecessarySimpa false`","theorem get_insertNth_of_lt (l : List Œ±) (x : Œ±) (n k : ‚Ñï) (hn : k < n) (hk : k < l.length)
    (hk' : k < (insertNth n x l).length := hk.trans_le (length_le_length_insertNth _ _ _)) :
    (insertNth n x l).get ‚ü®k, hk'‚ü© = l.get ‚ü®k, hk‚ü© ",":= by
  simp_all [getElem_insertNth_of_lt]"
Mathlib/Algebra/MonoidAlgebra/NoZeroDivisors.lean,AddMonoidAlgebra.mul_apply_add_eq_mul_of_uniqueAdd,mul_apply_add_eq_mul_of_uniqueAdd,86fa78904617a77f296845ed7796b9cf988e76c2,:=,error:  unexpected token 'instance'; expected term,"theorem mul_apply_add_eq_mul_of_uniqueAdd [Add A] {f g : R[A]} {a0 b0 : A}
    (h : UniqueAdd f.support g.support a0 b0) :
    (f * g) (a0 + b0) = f a0 * g b0 ",":=
  MonoidAlgebra.mul_apply_mul_eq_mul_of_uniqueMul (A := Multiplicative A) h"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.hasIntegral_GP_pderiv,hasIntegral_GP_pderiv,c7bd9bd10c613e1788107ba753e252f069560f87,":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine' HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le _ _ _ s hs _ _
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine' .and _ (.and _ _)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) :=
          inter_subset_inter_left _ (closedBall_subset_closedBall hŒ¥.2)
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := (add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ))
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine' this.eventually (ge_mem_nhds _)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine' ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ _‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp [F]
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine' (norm_sub_le _ _).trans (add_le_add _ _)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine' (mul_le_mul_of_nonneg_right _ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
          _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine' (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans _
      refine' (mul_le_mul_of_nonneg_right _ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine' prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => _
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := (dist_le_pi_dist J.upper J.lower (i.succAbove j))
        _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
        _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1
      ((Hd x hx).isLittleO.definition Œµ'0) with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine' ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => _‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine' (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ _) (hJc rfl)).trans _
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg","error:  invalid field 'definition', the environment does not contain 'Asymptotics.IsLittleO.definition'
  (Hd x hx).isLittleO
has type
  (fun x' ‚Ü¶ f x' - f x - (f' x) (x' - x)) =o[ùìù[Box.Icc I] x] fun x' ‚Ü¶ x' - x
error:  type mismatch
  HŒ¥ ?m.101432
has type
  ?m.101431 ‚àà ?m.99938 : Prop
but is expected to have type
  ‚Äñf y - ?m.101421 - ?m.101184 (y - x)‚Äñ ‚â§ Œµ' * ‚Äñy - x‚Äñ : Prop
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  E","theorem hasIntegral_GP_pderiv (f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E)
    (f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E) (s : Set (Fin (n + 1) ‚Üí ‚Ñù))
    (hs : s.Countable) (Hs : ‚àÄ x ‚àà s, ContinuousWithinAt f (Box.Icc I) x)
    (Hd : ‚àÄ x ‚àà (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :
    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume
      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))
          BoxAdditiveMap.volume -
        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))
          BoxAdditiveMap.volume) ",":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le ?_ ?_ _ s hs ?_ ?_
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine .and ?_ (.and ?_ ?_)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) := by gcongr; exact hŒ¥.2
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ)
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine this.eventually (ge_mem_nhds ?_)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ ?_‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp [F]
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine (norm_sub_le _ _).trans (add_le_add ?_ ?_)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine (mul_le_mul_of_nonneg_right ?_ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
          _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans ?_
      refine (mul_le_mul_of_nonneg_right ?_ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => ?_
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := dist_le_pi_dist J.upper J.lower (i.succAbove j)
        _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
        _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1
      ((Hd x hx).isLittleO.def Œµ'0) with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => ?_‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ ?_) (hJc rfl)).trans ?_
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg"
Mathlib/MeasureTheory/Measure/Haar/Basic.lean,MeasureTheory.Measure.div_mem_nhds_one_of_haar_pos,div_mem_nhds_one_of_haar_pos,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  obtain ‚ü®K, hKE, hK, K_closed, hKpos‚ü© :
      ‚àÉ (K : Set G), K ‚äÜ E ‚àß IsCompact K ‚àß IsClosed K ‚àß 0 < Œº K := by
    rcases MeasurableSet.exists_lt_isCompact hE hEpos with ‚ü®K, KE, K_comp, K_meas‚ü©
    refine ‚ü®closure K, ?_, K_comp.closure, isClosed_closure, ?_‚ü©
    ¬∑ exact IsCompact.closure_subset_of_measurableSet_of_group K_comp hE KE
    ¬∑ rwa [K_comp.measure_closure_eq_of_group]
  obtain ‚ü®U, hUK, hU, hŒºUK‚ü© : ‚àÉ (U : Set G), K ‚äÜ U ‚àß IsOpen U ‚àß Œº U < Œº K + Œº K :=
    hK.exists_isOpen_lt_add hKpos.ne'
  obtain ‚ü®V, hV1, hVKU‚ü© : ‚àÉ V ‚àà ùìù (1 : G), V * K ‚äÜ U :=
    compact_open_separated_mul_left hK hU hUK
  have hv : ‚àÄ v : G, v ‚àà V ‚Üí ¬¨Disjoint ({v} * K) K := by
    intro v hv hKv
    have hKvsub : {v} * K ‚à™ K ‚äÜ U := by
      apply Set.union_subset _ hUK
      apply _root_.subset_trans _ hVKU
      apply Set.mul_subset_mul _ (Set.Subset.refl K)
      simp only [Set.singleton_subset_iff, hv]
    replace hKvsub := @measure_mono _ _ Œº _ _ hKvsub
    have hcontr := lt_of_le_of_lt hKvsub hŒºUK
    rw [measure_union hKv K_closed.measurableSet] at hcontr
    have hKtranslate : Œº ({v} * K) = Œº K := by
      simp only [singleton_mul, image_mul_left, measure_preimage_mul]
    rw [hKtranslate, lt_self_iff_false] at hcontr
    assumption
  suffices V ‚äÜ E / E from Filter.mem_of_superset hV1 this
  intro v hvV
  obtain ‚ü®x, hxK, hxvK‚ü© : ‚àÉ x : G, x ‚àà {v} * K ‚àß x ‚àà K := Set.not_disjoint_iff.1 (hv v hvV)
  refine' ‚ü®x, v‚Åª¬π * x, hKE hxvK, _, _‚ü©
  ¬∑ apply hKE
    simpa only [singleton_mul, image_mul_left, mem_preimage] using hxK
  ¬∑ simp only [div_eq_iff_eq_mul, ‚Üê mul_assoc, mul_right_inv, one_mul]","warning:  `IsCompact.closure_subset_of_measurableSet_of_group` has been deprecated, use `IsCompact.closure_subset_measurableSet` instead
warning:  `IsCompact.measure_closure_eq_of_group` has been deprecated, use `IsCompact.measure_closure` instead
error:  application type mismatch
  @measure_mono ?m.115970 ?m.115971 Œº
argument
  Œº
has type
  Measure G : Type u_1
but is expected to have type
  FunLike ?m.115971 (Set ?m.115970) ‚Ñù‚â•0‚àû : Type (max (max ?u.115968 ?u.115969) 0)
error:  type mismatch
  v‚Åª¬π * x
has type
  G : outParam (Type u_1)
but is expected to have type
  x ‚àà E : Prop
error:  application type mismatch
  Exists.intro (hKE hxvK)
argument
  hKE hxvK
has type
  x ‚àà E : Prop
but is expected to have type
  G : Type u_1
error:  unsolved goals
case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.refine'_2
G : Type u_1
inst‚úù‚Å∑ : Group G
inst‚úù‚Å∂ : TopologicalSpace G
inst‚úù‚Åµ : TopologicalGroup G
inst‚úù‚Å¥ : MeasurableSpace G
inst‚úù¬≥ : BorelSpace G
Œº : Measure G
inst‚úù¬≤ : Œº.IsHaarMeasure
inst‚úù¬π : LocallyCompactSpace G
inst‚úù : Œº.InnerRegular
E : Set G
hE : MeasurableSet E
hEpos : 0 < Œº E
K : Set G
hKE : K ‚äÜ E
hK : IsCompact K
K_closed : IsClosed K
hKpos : 0 < Œº K
U : Set G
hUK : K ‚äÜ U
hU : IsOpen U
hŒºUK : Œº U < Œº K + Œº K
V : Set G
hV1 : V ‚àà ùìù 1
hVKU : V * K ‚äÜ U
hv : ‚àÄ v ‚àà V, ¬¨Disjoint ({v} * K) K
v : G
hvV : v ‚àà V
x : G
hxK : x ‚àà {v} * K
hxvK : x ‚àà K
‚ä¢ x = v * sorryAx G true","theorem div_mem_nhds_one_of_haar_pos (Œº : Measure G) [IsHaarMeasure Œº] [LocallyCompactSpace G]
    [InnerRegular Œº] (E : Set G) (hE : MeasurableSet E) (hEpos : 0 < Œº E) :
    E / E ‚àà ùìù (1 : G) ",":= by
  obtain ‚ü®K, hKE, hK, K_closed, hKpos‚ü© :
      ‚àÉ (K : Set G), K ‚äÜ E ‚àß IsCompact K ‚àß IsClosed K ‚àß 0 < Œº K := by
    rcases MeasurableSet.exists_lt_isCompact hE hEpos with ‚ü®K, KE, K_comp, K_meas‚ü©
    refine ‚ü®closure K, ?_, K_comp.closure, isClosed_closure, ?_‚ü©
    ¬∑ exact K_comp.closure_subset_measurableSet hE KE
    ¬∑ rwa [K_comp.measure_closure]
  filter_upwards [eventually_nhds_one_measure_smul_diff_lt hK K_closed hKpos.ne' (Œº := Œº)] with g hg
  have : ¬¨Disjoint (g ‚Ä¢ K) K := fun hd ‚Ü¶ by
    rw [hd.symm.sdiff_eq_right, measure_smul] at hg
    exact hg.false
  rcases Set.not_disjoint_iff.1 this with ‚ü®_, ‚ü®x, hxK, rfl‚ü©, hgxK‚ü©
  simpa using div_mem_div (hKE hgxK) (hKE hxK)"
Mathlib/NumberTheory/Padics/PadicVal.lean,Nat.log_ne_padicValNat_succ,Nat.log_ne_padicValNat_succ,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [Ne, log_eq_iff (by simp [hn])]
  rintro ‚ü®h1, h2‚ü©
  rw [‚Üê lt_add_one_iff, ‚Üê mul_one (2 ^ _)] at h1
  rw [‚Üê add_one_le_iff, Nat.pow_succ] at h2
  refine not_dvd_of_between_consec_multiples h1 (lt_of_le_of_ne' h2 ?_) pow_padicValNat_dvd
  exact pow_succ_padicValNat_not_dvd (p := 2) n.succ_ne_zero ‚àò dvd_of_eq","error:  unknown identifier 'lt_add_one_iff'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.65770
case intro
p n : ‚Ñï
hn : n ‚â† 0
h1 : 2 ^ padicValNat 2 (n + 1) ‚â§ n
h2 : n < 2 ^ (padicValNat 2 (n + 1) + 1)
‚ä¢ False",lemma Nat.log_ne_padicValNat_succ {n : ‚Ñï} (hn : n ‚â† 0) : log 2 n ‚â† padicValNat 2 (n + 1) ,":= by
  rw [Ne, log_eq_iff (by simp [hn])]
  rintro ‚ü®h1, h2‚ü©
  rw [‚Üê Nat.lt_add_one_iff, ‚Üê mul_one (2 ^ _)] at h1
  rw [‚Üê add_one_le_iff, Nat.pow_succ] at h2
  refine not_dvd_of_between_consec_multiples h1 (lt_of_le_of_ne' h2 ?_) pow_padicValNat_dvd
  exact pow_succ_padicValNat_not_dvd (p := 2) n.succ_ne_zero ‚àò dvd_of_eq"
Mathlib/GroupTheory/CoprodI.lean,Monoid.CoprodI.Word.mem_smul_iff,mem_smul_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [of_smul_def, mem_rcons_iff, mem_equivPair_tail_iff, equivPair_head, or_assoc]
  by_cases hij : i = j
  ¬∑ subst i
    simp only [not_true, ne_eq, false_and, exists_prop, true_and, false_or]
    by_cases hw : ‚ü®j, m‚ÇÅ‚ü© ‚àà w.toList.tail
    ¬∑ simp [hw, show m‚ÇÅ ‚â† 1 from w.ne_one _ (List.mem_of_mem_tail hw)]
    ¬∑ simp only [hw, false_or, Option.mem_def, ne_eq, and_congr_right_iff]
      intro hm1
      split_ifs with h
      ¬∑ rcases h with ‚ü®hnil, rfl‚ü©
        simp only [List.head?_eq_head _ hnil, Option.some.injEq, ne_eq]
        constructor
        ¬∑ rintro rfl
          exact Or.inl ‚ü®_, rfl, rfl‚ü©
        ¬∑ rintro (‚ü®_, h, rfl‚ü© | hm')
          ¬∑ simp [Sigma.ext_iff] at h
            subst h
            rfl
          ¬∑ simp only [fstIdx, Option.map_eq_some', Sigma.exists,
              exists_and_right, exists_eq_right, not_exists, ne_eq] at hm'
            exact (hm'.1 (w.toList.head hnil).2 (by rw [List.head?_eq_head])).elim
      ¬∑ revert h
        rw [fstIdx]
        cases w.toList
        ¬∑ simp
        ¬∑ simp (config := {contextual := true}) [Sigma.ext_iff]
  ¬∑ rcases w with ‚ü®_ | _, _, _‚ü© <;>
    simp [or_comm, hij, Ne.symm hij, eq_comm]","error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
error:  unsolved goals
case neg.mk.cons
Œπ : Type u_1
M : Œπ ‚Üí Type u_2
inst‚úù¬≥ : (i : Œπ) ‚Üí Monoid (M i)
N : Type u_3
inst‚úù¬≤ : Monoid N
inst‚úù¬π : (i : Œπ) ‚Üí DecidableEq (M i)
inst‚úù : DecidableEq Œπ
i j : Œπ
m‚ÇÅ : M i
m‚ÇÇ : M j
hij : ¬¨i = j
head‚úù : (i : Œπ) √ó M i
tail‚úù : List ((i : Œπ) √ó M i)
ne_one‚úù : ‚àÄ l ‚àà head‚úù :: tail‚úù, l.snd ‚â† 1
chain_ne‚úù : List.Chain' (fun l l' ‚Ü¶ l.fst ‚â† l'.fst) (head‚úù :: tail‚úù)
‚ä¢ (‚ü®i, m‚ÇÅ‚ü© ‚àà { toList := head‚úù :: tail‚úù, ne_one := ne_one‚úù, chain_ne := chain_ne‚úù }.toList.tail ‚à®
      (i ‚â† j ‚àß
          ‚àÉ (h : { toList := head‚úù :: tail‚úù, ne_one := ne_one‚úù, chain_ne := chain_ne‚úù }.toList ‚â† []),
            { toList := head‚úù :: tail‚úù, ne_one := ne_one‚úù, chain_ne := chain_ne‚úù }.toList.head h = ‚ü®i, m‚ÇÅ‚ü©) ‚à®
        m‚ÇÅ ‚â† 1 ‚àß
          ‚àÉ (h : j = i),
            m‚ÇÅ =
              h ‚ñ∏
                (let __src := (equivPair j) { toList := head‚úù :: tail‚úù, ne_one := ne_one‚úù, chain_ne := chain_ne‚úù };
                  {
                    head :=
                      m‚ÇÇ *
                        if h :
                            ‚àÉ (h : { toList := head‚úù :: tail‚úù, ne_one := ne_one‚úù, chain_ne := chain_ne‚úù }.toList ‚â† []),
                              ({ toList := head‚úù :: tail‚úù, ne_one := ne_one‚úù, chain_ne := chain_ne‚úù }.toList.head
                                    h).fst =
                                j then
                          ‚ãØ ‚ñ∏ ({ toList := head‚úù :: tail‚úù, ne_one := ne_one‚úù, chain_ne := chain_ne‚úù }.toList.head ‚ãØ).snd
                        else 1,
                    tail := __src.tail, fstIdx_ne := ‚ãØ }).head) ‚Üî
    ¬¨i = j ‚àß ‚ü®i, m‚ÇÅ‚ü© ‚àà { toList := head‚úù :: tail‚úù, ne_one := ne_one‚úù, chain_ne := chain_ne‚úù }.toList ‚à®
      m‚ÇÅ ‚â† 1 ‚àß
        ‚àÉ (hij : i = j),
          ‚ü®i, m‚ÇÅ‚ü© ‚àà { toList := head‚úù :: tail‚úù, ne_one := ne_one‚úù, chain_ne := chain_ne‚úù }.toList.tail ‚à®
            (‚àÉ m',
                ‚ü®j, m'‚ü© ‚àà { toList := head‚úù :: tail‚úù, ne_one := ne_one‚úù, chain_ne := chain_ne‚úù }.toList.head? ‚àß
                  m‚ÇÅ = ‚ãØ ‚ñ∏ (m‚ÇÇ * m')) ‚à®
              { toList := head‚úù :: tail‚úù, ne_one := ne_one‚úù, chain_ne := chain_ne‚úù }.fstIdx ‚â† some j ‚àß m‚ÇÅ = ‚ãØ ‚ñ∏ m‚ÇÇ","theorem mem_smul_iff {i j : Œπ} {m‚ÇÅ : M i} {m‚ÇÇ : M j} {w : Word M} :
    ‚ü®_, m‚ÇÅ‚ü© ‚àà (of m‚ÇÇ ‚Ä¢ w).toList ‚Üî
      (¬¨i = j ‚àß ‚ü®i, m‚ÇÅ‚ü© ‚àà w.toList)
      ‚à® (m‚ÇÅ ‚â† 1 ‚àß ‚àÉ (hij : i = j),(‚ü®i, m‚ÇÅ‚ü© ‚àà w.toList.tail) ‚à®
        (‚àÉ m', ‚ü®j, m'‚ü© ‚àà w.toList.head? ‚àß m‚ÇÅ = hij ‚ñ∏ (m‚ÇÇ * m')) ‚à®
        (w.fstIdx ‚â† some j ‚àß m‚ÇÅ = hij ‚ñ∏ m‚ÇÇ)) ",":= by
  rw [of_smul_def, mem_rcons_iff, mem_equivPair_tail_iff, equivPair_head, or_assoc]
  by_cases hij : i = j
  ¬∑ subst i
    simp only [not_true, ne_eq, false_and, exists_prop, true_and, false_or]
    by_cases hw : ‚ü®j, m‚ÇÅ‚ü© ‚àà w.toList.tail
    ¬∑ simp [hw, show m‚ÇÅ ‚â† 1 from w.ne_one _ (List.mem_of_mem_tail hw)]
    ¬∑ simp only [hw, false_or, Option.mem_def, ne_eq, and_congr_right_iff]
      intro hm1
      split_ifs with h
      ¬∑ rcases h with ‚ü®hnil, rfl‚ü©
        simp only [List.head?_eq_head _ hnil, Option.some.injEq, ne_eq]
        constructor
        ¬∑ rintro rfl
          exact Or.inl ‚ü®_, rfl, rfl‚ü©
        ¬∑ rintro (‚ü®_, h, rfl‚ü© | hm')
          ¬∑ simp [Sigma.ext_iff] at h
            subst h
            rfl
          ¬∑ simp only [fstIdx, Option.map_eq_some', Sigma.exists,
              exists_and_right, exists_eq_right, not_exists, ne_eq] at hm'
            exact (hm'.1 (w.toList.head hnil).2 (by rw [List.head?_eq_head])).elim
      ¬∑ revert h
        rw [fstIdx]
        cases w.toList
        ¬∑ simp
        ¬∑ simp (config := {contextual := true}) [Sigma.ext_iff]
  ¬∑ rcases w with ‚ü®_ | _, _, _‚ü© <;>
    simp [or_comm, hij, Ne.symm hij]; rw [eq_comm]"
Mathlib/MeasureTheory/Integral/CircleTransform.lean,Complex.circleTransformDeriv_bound,circleTransformDeriv_bound,901e41cb79653a4c7b459bd61e06d90088b89b27,":= by
  obtain ‚ü®r, hr, hrx‚ü© := exists_lt_mem_ball_of_mem_ball hx
  obtain ‚ü®Œµ', hŒµ', H‚ü© := exists_ball_subset_ball hrx
  obtain ‚ü®‚ü®‚ü®a, b‚ü©, ‚ü®ha, hb‚ü©‚ü©, hab‚ü© :=
    abs_circleTransformBoundingFunction_le hr (pos_of_mem_ball hrx).le z
  let V : ‚Ñù ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ := fun Œ∏ w => circleTransformDeriv R z w (fun _ => 1) Œ∏
  obtain ‚ü®X, -, HX2‚ü© := (isCompact_sphere z R).exists_isMaxOn
    (NormedSpace.sphere_nonempty.2 hR.le) hf.norm
  refine ‚ü®abs (V b a) * abs (f X), Œµ', hŒµ', H.trans (ball_subset_ball hr.le), fun y v hv ‚Ü¶ ?_‚ü©
  obtain ‚ü®y1, hy1, hfun‚ü© :=
    Periodic.exists_mem_Ico‚ÇÄ (circleTransformDeriv_periodic R z v f) Real.two_pi_pos y
  have hy2 : y1 ‚àà [[0, 2 * œÄ]] := Icc_subset_uIcc <| Ico_subset_Icc_self hy1
  simp only [isMaxOn_iff, mem_sphere_iff_norm, norm_eq_abs] at HX2
  have := mul_le_mul (hab ‚ü®‚ü®v, y1‚ü©, ‚ü®ball_subset_closedBall (H hv), hy2‚ü©‚ü©)
    (HX2 (circleMap z R y1) (circleMap_mem_sphere z hR.le y1)) (Complex.abs.nonneg _)
    (Complex.abs.nonneg _)
  rw [hfun]
  simpa [circleTransformBoundingFunction, circleTransformDeriv, mul_assoc] using this","error:  type mismatch
  h‚úù
has type
  |œÄ|‚Åª¬π * (2‚Åª¬π * (|R| * ((abs (circleMap z R y1 - v) ^ 2)‚Åª¬π * abs (f (circleMap z R y1))))) ‚â§
    |œÄ|‚Åª¬π * (2‚Åª¬π * (|R| * ((abs (circleMap z R b - a) ^ 2)‚Åª¬π * abs (f X)))) : Prop
but is expected to have type
  |œÄ|‚Åª¬π * (2‚Åª¬π * (|R| * ((abs (circleMap z R y1 - v) ^ 2)‚Åª¬π * abs (f (circleMap z R y1))))) ‚â§
    abs (V b a) * abs (f X) : Prop","theorem circleTransformDeriv_bound {R : ‚Ñù} (hR : 0 < R) {z x : ‚ÑÇ} {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hx : x ‚àà ball z R)
    (hf : ContinuousOn f (sphere z R)) : ‚àÉ B Œµ : ‚Ñù, 0 < Œµ ‚àß
      ball x Œµ ‚äÜ ball z R ‚àß ‚àÄ (t : ‚Ñù), ‚àÄ y ‚àà ball x Œµ, ‚ÄñcircleTransformDeriv R z y f t‚Äñ ‚â§ B ",":= by
  obtain ‚ü®r, hr, hrx‚ü© := exists_lt_mem_ball_of_mem_ball hx
  obtain ‚ü®Œµ', hŒµ', H‚ü© := exists_ball_subset_ball hrx
  obtain ‚ü®‚ü®‚ü®a, b‚ü©, ‚ü®ha, hb‚ü©‚ü©, hab‚ü© :=
    abs_circleTransformBoundingFunction_le hr (pos_of_mem_ball hrx).le z
  let V : ‚Ñù ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ := fun Œ∏ w => circleTransformDeriv R z w (fun _ => 1) Œ∏
  obtain ‚ü®X, -, HX2‚ü© := (isCompact_sphere z R).exists_isMaxOn
    (NormedSpace.sphere_nonempty.2 hR.le) hf.norm
  refine ‚ü®abs (V b a) * abs (f X), Œµ', hŒµ', H.trans (ball_subset_ball hr.le), fun y v hv ‚Ü¶ ?_‚ü©
  obtain ‚ü®y1, hy1, hfun‚ü© :=
    Periodic.exists_mem_Ico‚ÇÄ (circleTransformDeriv_periodic R z v f) Real.two_pi_pos y
  have hy2 : y1 ‚àà [[0, 2 * œÄ]] := Icc_subset_uIcc <| Ico_subset_Icc_self hy1
  simp only [isMaxOn_iff, mem_sphere_iff_norm, norm_eq_abs] at HX2
  have := mul_le_mul (hab ‚ü®‚ü®v, y1‚ü©, ‚ü®ball_subset_closedBall (H hv), hy2‚ü©‚ü©)
    (HX2 (circleMap z R y1) (circleMap_mem_sphere z hR.le y1)) (Complex.abs.nonneg _)
    (Complex.abs.nonneg _)
  rw [hfun]
  simpa [V, circleTransformBoundingFunction, circleTransformDeriv, mul_assoc] using this"
Mathlib/Data/List/Basic.lean,List.get_pmap,get_pmap,a33aff49327d402aa56adea45bcb9c999637661a,":= by
  induction' l with hd tl hl generalizing n
  ¬∑ simp only [length, pmap] at hn
    exact absurd hn (not_lt_of_le n.zero_le)
  ¬∑ cases n
    ¬∑ simp
    ¬∑ simp [hl]","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_map` has been deprecated, use `List.getElem_map` instead
warning:  `List.get_map` has been deprecated, use `List.getElem_map` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_map` has been deprecated, use `List.get_map` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_map` has been deprecated, use `List.get_map` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_append_right_aux` has been deprecated
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_cons_length` has been deprecated, use `List.getElem_cons_length` instead
warning:  `List.drop_eq_get_cons` has been deprecated, use `List.drop_eq_getElem_cons` instead
warning:  `List.ext` has been deprecated
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_reverse_aux‚ÇÅ` has been deprecated
warning:  `List.get_reverse_aux‚ÇÇ` has been deprecated, use `List.getElem_reverse_aux‚ÇÇ` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_reverse` has been deprecated, use `List.getElem_reverse` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.ret` has been deprecated, use `List.pure` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_zero_scanl` has been deprecated, use `List.getElem_scanl_zero` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_zero_scanl` has been deprecated, use `List.get_zero_scanl` instead
warning:  `List.nthLe_append_right` has been deprecated, use `List.get_append_right'` instead
error:  unsolved goals
case cons.succ
Œπ : Type u_1
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
l‚ÇÅ l‚ÇÇ : List Œ±
p : Œ± ‚Üí Prop
f : (a : Œ±) ‚Üí p a ‚Üí Œ≤
hd : Œ±
tl : List Œ±
hl :
  ‚àÄ (h : ‚àÄ (a : Œ±), a ‚àà tl ‚Üí p a) {n : ‚Ñï} (hn : n < (pmap f tl h).length),
    (pmap f tl h).get ‚ü®n, hn‚ü© = f (tl.get ‚ü®n, ‚ãØ‚ü©) ‚ãØ
h : ‚àÄ (a : Œ±), a ‚àà hd :: tl ‚Üí p a
n‚úù : ‚Ñï
hn : n‚úù + 1 < (pmap f (hd :: tl) h).length
‚ä¢ (pmap f tl ‚ãØ)[n‚úù] = f tl[n‚úù] ‚ãØ
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem get_pmap {p : Œ± ‚Üí Prop} (f : ‚àÄ a, p a ‚Üí Œ≤) {l : List Œ±} (h : ‚àÄ a ‚àà l, p a) {n : ‚Ñï}
    (hn : n < (pmap f l h).length) :
    get (pmap f l h) ‚ü®n, hn‚ü© =
      f (get l ‚ü®n, @length_pmap _ _ p f l h ‚ñ∏ hn‚ü©)
        (h _ (get_mem l n (@length_pmap _ _ p f l h ‚ñ∏ hn))) ",":= by
  simp only [get_eq_getElem]
  simp [getElem_pmap]"
Mathlib/Data/List/Sym.lean,List.sym_one_eq,sym_one_eq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction xs with
  | nil => rfl
  | cons x xs ih =>
    rw [map_cons, ‚Üê ih, List.sym, List.sym, map_singleton, singleton_append]","error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case nil
Œ± : Type u_1
xs ys : List Œ±
n : ‚Ñï
‚ä¢ List.sym 1 [] = map (fun x ‚Ü¶ x ::‚Çõ Sym.nil) []",theorem sym_one_eq : xs.sym 1 = xs.map (¬∑ ::‚Çõ .nil) ,":= by
  induction xs with
  | nil => simp only [List.sym, Nat.succ_eq_add_one, Nat.reduceAdd, map_nil]
  | cons x xs ih =>
    rw [map_cons, ‚Üê ih, List.sym, List.sym, map_singleton, singleton_append]"
Mathlib/Topology/StoneCech.lean,continuous_stoneCechUnit,continuous_stoneCechUnit,fc8bedf644a081047899d36f264872fe3d2ab499,":=
  continuous_iff_ultrafilter.mpr fun x g gx => by
    have : (g.map pure).toFilter ‚â§ ùìù g := by
      rw [ultrafilter_converges_iff]
      exact (bind_pure _).symm
    have : (g.map stoneCechUnit : Filter (StoneCech Œ±)) ‚â§ ùìù ‚ü¶g‚üß :=
      continuousAt_iff_ultrafilter.mp (continuous_quotient_mk'.tendsto g) _ this
    rwa [show ‚ü¶g‚üß = ‚ü¶pure x‚üß from Quotient.sound <| convergent_eqv_pure gx] at this","error:  type mismatch
  ùìù ‚ü¶g‚üß
has type
  Filter (Quotient ?m.22971) : Type u
but is expected to have type
  Filter (StoneCech Œ±) : Type u
error:  unknown identifier 'convergent_eqv_pure'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚ü¶g‚üß
Œ± : Type u
inst‚úù : TopologicalSpace Œ±
x : Œ±
g : Ultrafilter Œ±
gx : ‚Üëg ‚â§ ùìù x
this‚úù : ‚Üë(Ultrafilter.map pure g) ‚â§ ùìù g
this : sorryAx (Sort ?u.22759) true
‚ä¢ Tendsto stoneCechUnit (‚Üëg) (ùìù (stoneCechUnit x))",theorem continuous_stoneCechUnit : Continuous (stoneCechUnit : Œ± ‚Üí StoneCech Œ±) ,":=
  (t2Quotient.continuous_mk _).comp continuous_preStoneCechUnit"
Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean,CategoryTheory.comp_rightAdjointMate,comp_rightAdjointMate,fbd911ae47a4882059f05c237019e9351be35660,":= by
  rw [rightAdjointMate_comp]
  simp_rw [rightAdjointMate, ‚Üê id_tensorHom, ‚Üê tensorHom_id]
  simp only [rightAdjointMate, comp_tensor_id, Iso.cancel_iso_inv_left, id_tensor_comp,
    Category.assoc]
  symm
  iterate 5
    trans
    rw [‚Üê Category.id_comp g, tensor_comp]
  rw [‚Üê Category.assoc]
  symm
  iterate 2
    trans
    rw [‚Üê Category.assoc]
  apply eq_whisker
  repeat'
    rw [‚Üê @id_tensor_comp C]
  congr 1
  rw [‚Üê id_tensor_comp_tensor_id (Œª_ (X·òÅ)).hom g, id_tensor_rightUnitor_inv, Category.assoc,
    Category.assoc, rightUnitor_inv_naturality'_assoc, ‚Üê associator_naturality_assoc, tensor_id,
    tensor_id_comp_id_tensor_assoc, ‚Üê associator_naturality_assoc]
  slice_rhs 2 3 =>
    rw [‚Üê tensor_comp, tensor_id, Category.comp_id, ‚Üê Category.id_comp (Œ∑_ Y (Y·òÅ)), tensor_comp]
  rw [‚Üê id_tensor_comp_tensor_id _ (Œ∑_ Y (Y·òÅ)), ‚Üê tensor_id]
  simp only [tensorHom_id, id_tensorHom, id_whiskerLeft, id_whiskerRight, whiskerRight_tensor,
    Category.assoc, Iso.inv_hom_id_assoc, pentagon_hom_hom_inv_hom_hom]
  rw [‚Üê associator_naturality_middle_assoc]
  simp_rw [‚Üê comp_whiskerRight_assoc, evaluation_coevaluation]
  coherence","warning:  @coevaluation does not have a doc string
warning:  @evaluation does not have a doc string
warning:  @leftDual does not have a doc string
warning:  @rightDual does not have a doc string
warning:  @rightAdjointMate does not have a doc string
warning:  @leftAdjointMate does not have a doc string
error:  unknown identifier 'id_tensor_rightUnitor_inv'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.202953
case w.e_g
C : Type u‚ÇÅ
inst‚úù‚Å¥ : Category.{v‚ÇÅ, u‚ÇÅ} C
inst‚úù¬≥ : MonoidalCategory C
X Y Z : C
inst‚úù¬≤ : HasRightDual X
inst‚úù¬π : HasRightDual Y
inst‚úù : HasRightDual Z
f : X ‚ü∂ Y
g : Y ‚ü∂ Z
‚ä¢ (Œ∑_ X X·òÅ ‚â´ (f ‚äó ùüô X·òÅ)) ‚â´ (g ‚äó ùüô X·òÅ) =
    Œ∑_ Y Y·òÅ ‚â´
      (ùüô Y ‚äó (œÅ_ Y·òÅ).inv) ‚â´
        (ùüô Y ‚äó ùüô Y·òÅ ‚äó Œ∑_ X X·òÅ) ‚â´
          (ùüô Y ‚äó ùüô Y·òÅ ‚äó f ‚äó ùüô X·òÅ) ‚â´ (ùüô Y ‚äó (Œ±_ Y·òÅ Y X·òÅ).inv) ‚â´ (ùüô Y ‚äó Œµ_ Y Y·òÅ ‚äó ùüô X·òÅ) ‚â´ (ùüô Y ‚äó (Œª_ X·òÅ).hom) ‚â´ (g ‚äó ùüô X·òÅ)","theorem comp_rightAdjointMate {X Y Z : C} [HasRightDual X] [HasRightDual Y] [HasRightDual Z]
    {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g)·òÅ = g·òÅ ‚â´ f·òÅ ",":= by
  rw [rightAdjointMate_comp]
  simp only [rightAdjointMate, comp_whiskerRight]
  simp only [‚Üê Category.assoc]; congr 3; simp only [Category.assoc]
  simp only [‚Üê MonoidalCategory.whiskerLeft_comp]; congr 2
  symm
  calc
    _ = ùüô _ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ ùüô_ C ‚â´ (Y ‚äó Y·òÅ) ‚óÅ Œ∑_ X X·òÅ) ‚äó‚â´ Y ‚óÅ Y·òÅ ‚óÅ f ‚ñ∑ X·òÅ ‚äó‚â´
        Y ‚óÅ Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [tensorHom_def']; coherence
    _ = Œ∑_ X X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ (X ‚äó X·òÅ) ‚â´ (Y ‚äó Y·òÅ) ‚óÅ f ‚ñ∑ X·òÅ) ‚äó‚â´
        Y ‚óÅ Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [‚Üê whisker_exchange]; coherence
    _ = Œ∑_ X X·òÅ ‚äó‚â´ f ‚ñ∑ X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ Y ‚äó‚â´ Y ‚óÅ Œµ_ Y Y·òÅ) ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [‚Üê whisker_exchange]; coherence
    _ = Œ∑_ X X·òÅ ‚â´ f ‚ñ∑ X·òÅ ‚â´ g ‚ñ∑ X·òÅ := by
      rw [evaluation_coevaluation'']; coherence"
Mathlib/Order/Monotone/Extension.lean,MonotoneOn.exists_monotone_extension,MonotoneOn.exists_monotone_extension,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  classical
    rcases hl with ‚ü®a, ha‚ü©
    have hu' : ‚àÄ x, BddAbove (f '' (Iic x ‚à© s)) := fun x =>
      hu.mono (image_subset _ (inter_subset_right _ _))
    let g : Œ± ‚Üí Œ≤ := fun x => if Disjoint (Iic x) s then a else sSup (f '' (Iic x ‚à© s))
    have hgs : EqOn f g s := by
      intro x hx
      simp only [g]
      have : IsGreatest (Iic x ‚à© s) x := ‚ü®‚ü®right_mem_Iic, hx‚ü©, fun y hy => hy.1‚ü©
      rw [if_neg this.nonempty.not_disjoint,
        ((h.mono <| inter_subset_right _ _).map_isGreatest this).csSup_eq]
    refine' ‚ü®g, fun x y hxy => _, hgs‚ü©
    by_cases hx : Disjoint (Iic x) s <;> by_cases hy : Disjoint (Iic y) s <;>
      simp only [g, if_pos, if_neg, not_false_iff, *, refl]
    ¬∑ rcases not_disjoint_iff_nonempty_inter.1 hy with ‚ü®z, hz‚ü©
      exact le_csSup_of_le (hu' _) (mem_image_of_mem _ hz) (ha <| mem_image_of_mem _ hz.2)
    ¬∑ exact (hx <| hy.mono_left <| Iic_subset_Iic.2 hxy).elim
    ¬∑ rw [not_disjoint_iff_nonempty_inter] at hx hy
      refine' csSup_le_csSup (hu' _) (hx.image _) (image_subset _ _)
      exact inter_subset_inter_left _ (Iic_subset_Iic.2 hxy)","error:  function expected at
  inter_subset_right ?m.942
term has type
  ?m.941 ‚àà ?m.940
error:  function expected at
  inter_subset_right ?m.1774
term has type
  ?m.1773 ‚àà ?m.1772","theorem MonotoneOn.exists_monotone_extension (h : MonotoneOn f s) (hl : BddBelow (f '' s))
    (hu : BddAbove (f '' s)) : ‚àÉ g : Œ± ‚Üí Œ≤, Monotone g ‚àß EqOn f g s ",":= by
  classical
    rcases hl with ‚ü®a, ha‚ü©
    have hu' : ‚àÄ x, BddAbove (f '' (Iic x ‚à© s)) := fun x =>
      hu.mono (image_subset _ inter_subset_right)
    let g : Œ± ‚Üí Œ≤ := fun x => if Disjoint (Iic x) s then a else sSup (f '' (Iic x ‚à© s))
    have hgs : EqOn f g s := by
      intro x hx
      simp only [g]
      have : IsGreatest (Iic x ‚à© s) x := ‚ü®‚ü®right_mem_Iic, hx‚ü©, fun y hy => hy.1‚ü©
      rw [if_neg this.nonempty.not_disjoint,
        ((h.mono inter_subset_right).map_isGreatest this).csSup_eq]
    refine ‚ü®g, fun x y hxy => ?_, hgs‚ü©
    by_cases hx : Disjoint (Iic x) s <;> by_cases hy : Disjoint (Iic y) s <;>
      simp only [g, if_pos, if_neg, not_false_iff, *, refl]
    ¬∑ rcases not_disjoint_iff_nonempty_inter.1 hy with ‚ü®z, hz‚ü©
      exact le_csSup_of_le (hu' _) (mem_image_of_mem _ hz) (ha <| mem_image_of_mem _ hz.2)
    ¬∑ exact (hx <| hy.mono_left <| Iic_subset_Iic.2 hxy).elim
    ¬∑ rw [not_disjoint_iff_nonempty_inter] at hx hy
      refine csSup_le_csSup (hu' _) (hx.image _) (image_subset _ ?_)
      exact inter_subset_inter_left _ (Iic_subset_Iic.2 hxy)"
Mathlib/CategoryTheory/Sites/IsSheafFor.lean,CategoryTheory.Presieve.isSheafFor_subsieve,isSheafFor_subsieve,ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  rw [‚Üê isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  constructor
  ¬∑ intro x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
    exact
      hS.isSeparatedFor _ _ _ (isAmalgamation_restrict h x t‚ÇÅ ht‚ÇÅ)
        (isAmalgamation_restrict h x t‚ÇÇ ht‚ÇÇ)
  ¬∑ intro x hx
    use hS.amalgamate _ (hx.restrict h)
    intro W j hj
    apply (trans hj).ext
    intro Y f hf
    rw [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, hS.valid_glue (hx.restrict h) _ hf,
      FamilyOfElements.restrict, ‚Üê hx (ùüô _) f (h _ _ hf) _ (id_comp _)]
    simp","error:  function expected at
  h ?m.93800 ?m.93802
term has type
  ?m.93801 ‚àà R","theorem isSheafFor_subsieve_aux (P : C·µí·µñ ‚•§ Type w) {S : Sieve X} {R : Presieve X}
    (h : (S : Presieve X) ‚â§ R) (hS : IsSheafFor P (S : Presieve X))
    (trans : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, R f ‚Üí IsSeparatedFor P (S.pullback f : Presieve Y)) :
    IsSheafFor P R ",":= by
  rw [‚Üê isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  constructor
  ¬∑ intro x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
    exact
      hS.isSeparatedFor _ _ _ (isAmalgamation_restrict h x t‚ÇÅ ht‚ÇÅ)
        (isAmalgamation_restrict h x t‚ÇÇ ht‚ÇÇ)
  ¬∑ intro x hx
    use hS.amalgamate _ (hx.restrict h)
    intro W j hj
    apply (trans hj).ext
    intro Y f hf
    rw [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, hS.valid_glue (hx.restrict h) _ hf,
      FamilyOfElements.restrict, ‚Üê hx (ùüô _) f (h _ hf) _ (id_comp _)]
    simp"
Mathlib/Data/Fin/VecNotation.lean,Matrix.vecAlt1_vecAppend,vecAlt1_vecAppend,f162a50743f98a06c47b8a451d514f96a4ed8362,":= by
  ext i
  simp_rw [Function.comp, vecAlt1, vecAppend_eq_ite]
  cases n with
  | zero =>
    cases' i with i hi
    simp only [Nat.zero_eq, zero_add, Nat.lt_one_iff] at hi; subst i; rfl
  | succ n =>
    split_ifs with h <;> simp_rw [bit1, bit0] <;> congr
    ¬∑ simp [Nat.mod_eq_of_lt h]
    ¬∑ rw [Fin.val_mk, not_lt] at h
      simp only [Fin.ext_iff, Fin.val_add, Fin.val_mk, Nat.mod_add_mod, Fin.val_one,
        Nat.mod_eq_sub_mod h, show 1 % (n + 2) = 1 from Nat.mod_eq_of_lt (by omega)]
      refine (Nat.mod_eq_of_lt ?_).symm
      rw [tsub_lt_iff_left h]
      exact Nat.add_succ_lt_add i.2 i.2","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
error:  tactic 'subst' failed, did not find equation for eliminating 'i'
case h.zero.mk
Œ± : Type u
m o : ‚Ñï
m' : Type u_1
n' : Type u_2
o' : Type u_3
v : Fin (0 + 1) ‚Üí Œ±
i : ‚Ñï
hi : i < 0 + 1
‚ä¢ (if h : ‚Üë‚ü®i, hi‚ü© + ‚Üë‚ü®i, hi‚ü© + 1 < 0 + 1 then v ‚ü®‚Üë‚ü®i, hi‚ü© + ‚Üë‚ü®i, hi‚ü© + 1, ‚ãØ‚ü©
    else v ‚ü®‚Üë‚ü®i, hi‚ü© + ‚Üë‚ü®i, hi‚ü© + 1 - (0 + 1), ‚ãØ‚ü©) =
    v (bit1 ‚ü®i, hi‚ü©)
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  unknown identifier 'tsub_lt_iff_left'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.37482
case neg.e_a.e_val
Œ± : Type u
m o : ‚Ñï
m' : Type u_1
n' : Type u_2
o' : Type u_3
n : ‚Ñï
v : Fin (n + 1 + 1) ‚Üí Œ±
i : Fin (n + 1 + 1)
h : n + 1 + 1 ‚â§ ‚Üëi + ‚Üëi + 1
‚ä¢ ‚Üëi + ‚Üëi + 1 - (n + 1 + 1) < n + 1 + 1
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated",theorem vecAlt1_vecAppend (v : Fin (n + 1) ‚Üí Œ±) : vecAlt1 rfl (vecAppend rfl v v) = v ‚àò bit1 ,":= by
  ext i
  simp_rw [Function.comp, vecAlt1, vecAppend_eq_ite]
  cases n with
  | zero =>
    cases' i with i hi
    simp only [Nat.zero_eq, Nat.zero_add, Nat.lt_one_iff] at hi; subst i; rfl
  | succ n =>
    split_ifs with h <;> simp_rw [bit1, bit0] <;> congr
    ¬∑ simp [Nat.mod_eq_of_lt, h]
    ¬∑ rw [Fin.val_mk, not_lt] at h
      simp only [Fin.ext_iff, Fin.val_add, Fin.val_mk, Nat.mod_add_mod, Fin.val_one,
        Nat.mod_eq_sub_mod h, show 1 % (n + 2) = 1 from Nat.mod_eq_of_lt (by omega)]
      refine (Nat.mod_eq_of_lt ?_).symm
      omega"
Mathlib/AlgebraicGeometry/Gluing.lean,AlgebraicGeometry.Scheme.OpenCover.fromGlued_open_map,fromGlued_open_map,67ee3b7709353762fdc01cfb00722ee8c27ff6a5,":= by
  intro U hU
  rw [isOpen_iff_forall_mem_open]
  intro x hx
  rw [ùí∞.gluedCover.isOpen_iff] at hU
  use ùí∞.fromGlued.val.base '' U ‚à© Set.range (ùí∞.map (ùí∞.f x)).1.base
  use Set.inter_subset_left _ _
  constructor
  ¬∑ rw [‚Üê Set.image_preimage_eq_inter_range]
    apply (show IsOpenImmersion (ùí∞.map (ùí∞.f x)) from inferInstance).base_open.isOpenMap
    convert hU (ùí∞.f x) using 1
    rw [‚Üê Œπ_fromGlued]; erw [coe_comp]; rw [Set.preimage_comp]
    congr! 1
    exact Set.preimage_image_eq _ ùí∞.fromGlued_injective
  ¬∑ exact ‚ü®hx, ùí∞.Covers x‚ü©","error:  function expected at
  Set.inter_subset_left ?m.147618
term has type
  ?m.147617 ‚àà ?m.147615
warning:  `AlgebraicGeometry.Scheme.OpenCover.Covers` has been deprecated, use `AlgebraicGeometry.Scheme.OpenCover.covers` instead",theorem fromGlued_open_map : IsOpenMap ùí∞.fromGlued.1.base ,":= by
  intro U hU
  rw [isOpen_iff_forall_mem_open]
  intro x hx
  rw [ùí∞.gluedCover.isOpen_iff] at hU
  use ùí∞.fromGlued.val.base '' U ‚à© Set.range (ùí∞.map (ùí∞.f x)).1.base
  use Set.inter_subset_left
  constructor
  ¬∑ rw [‚Üê Set.image_preimage_eq_inter_range]
    apply (show IsOpenImmersion (ùí∞.map (ùí∞.f x)) from inferInstance).base_open.isOpenMap
    convert hU (ùí∞.f x) using 1
    rw [‚Üê Œπ_fromGlued]; erw [coe_comp]; rw [Set.preimage_comp]
    congr! 1
    exact Set.preimage_image_eq _ ùí∞.fromGlued_injective
  ¬∑ exact ‚ü®hx, ùí∞.covers x‚ü©"
Mathlib/Topology/Algebra/Valuation.lean,Valuation.subgroups_basis,subgroups_basis,916c75c1d9f2fcdcd11d5d5b32f69afcc94bb9c4,":=
  { inter := by
      rintro Œ≥‚ÇÄ Œ≥‚ÇÅ
      use min Œ≥‚ÇÄ Œ≥‚ÇÅ
      simp [Valuation.ltAddSubgroup]
      tauto
    mul := by
      rintro Œ≥
      cases' exists_square_le Œ≥ with Œ≥‚ÇÄ h
      use Œ≥‚ÇÄ
      rintro - ‚ü®r, s, r_in, s_in, rfl‚ü©
      calc
        (v (r * s) : Œì‚ÇÄ) = v r * v s := Valuation.map_mul _ _ _
        _ < Œ≥‚ÇÄ * Œ≥‚ÇÄ := (mul_lt_mul‚ÇÄ r_in s_in)
        _ ‚â§ Œ≥ := by exact_mod_cast h
    leftMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use (1 : Œì‚ÇÄÀ£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, MulZeroClass.zero_mul]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (x * y) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt
    rightMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, MulZeroClass.mul_zero]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (y * x) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt }","error:  application type mismatch
  v s
argument
  s
has type
  r ‚àà ‚Üë(v.ltAddSubgroup Œ≥‚ÇÄ) : Prop
but is expected to have type
  R : Type u
error:  invalid 'calc' step, failed to synthesize `Trans` instance
  Trans LT.lt Membership.mem ?m.35107
use `set_option diagnostics true` to get diagnostic information",theorem subgroups_basis : RingSubgroupsBasis fun Œ≥ : Œì‚ÇÄÀ£ => (v.ltAddSubgroup Œ≥ : AddSubgroup R) ,":=
  { inter := by
      rintro Œ≥‚ÇÄ Œ≥‚ÇÅ
      use min Œ≥‚ÇÄ Œ≥‚ÇÅ
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro Œ≥
      cases' exists_square_le Œ≥ with Œ≥‚ÇÄ h
      use Œ≥‚ÇÄ
      rintro - ‚ü®r, r_in, s, s_in, rfl‚ü©
      calc
        (v (r * s) : Œì‚ÇÄ) = v r * v s := Valuation.map_mul _ _ _
        _ < Œ≥‚ÇÄ * Œ≥‚ÇÄ := mul_lt_mul‚ÇÄ r_in s_in
        _ ‚â§ Œ≥ := mod_cast h
    leftMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use (1 : Œì‚ÇÄÀ£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (x * y) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt
    rightMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (y * x) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt }"
Mathlib/Data/Setoid/Basic.lean,Setoid.sup_eq_eqvGen,sup_eq_eqvGen,294082ef61697f884a3de4f53ea12c01eccb0563,":= by
  rw [eqvGen_eq]
  apply congr_arg inf‚Çõ
  simp only [le_def, or_imp, ‚Üê forall_and]",error:  unknown identifier 'inf‚Çõ',"theorem sup_eq_eqvGen (r s : Setoid Œ±) :
    r ‚äî s = EqvGen.Setoid fun x y => r.Rel x y ‚à® s.Rel x y ",":= by
  rw [eqvGen_eq]
  apply congr_arg sInf
  simp only [le_def, or_imp, ‚Üê forall_and]"
Mathlib/Analysis/Convex/Slope.lean,convexOn_of_slope_mono_adjacent,convexOn_of_slope_mono_adjacent,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  LinearOrder.convexOn_of_lt hs fun x hx z hz hxz a b ha hb hab => by
    let y := a * x + b * z
    have hxy : x < y := by
      rw [‚Üê one_mul x, ‚Üê hab, add_mul]
      exact add_lt_add_left ((mul_lt_mul_left hb).2 hxz) _
    have hyz : y < z := by
      rw [‚Üê one_mul z, ‚Üê hab, add_mul]
      exact add_lt_add_right ((mul_lt_mul_left ha).2 hxz) _
    have : (f y - f x) * (z - y) ‚â§ (f z - f y) * (y - x) :=
      (div_le_div_iff (sub_pos.2 hxy) (sub_pos.2 hyz)).1 (hf hx hz hxy hyz)
    have hxz : 0 < z - x := sub_pos.2 (hxy.trans hyz)
    have ha : (z - y) / (z - x) = a := by
      rw [eq_comm, ‚Üê sub_eq_iff_eq_add'] at hab
      simp_rw [div_eq_iff hxz.ne', ‚Üê hab]
      ring
    have hb : (y - x) / (z - x) = b := by
      rw [eq_comm, ‚Üê sub_eq_iff_eq_add] at hab
      simp_rw [div_eq_iff hxz.ne', ‚Üê hab]
      ring
    rwa [sub_mul, sub_mul, sub_le_iff_le_add', ‚Üê add_sub_assoc, le_sub_iff_add_le, ‚Üê mul_add,
      sub_add_sub_cancel, ‚Üê le_div_iff hxz, add_div, mul_div_assoc, mul_div_assoc, mul_comm (f x),
      mul_comm (f z), ha, hb] at this","error:  simp made no progress
error:  simp made no progress","theorem convexOn_of_slope_mono_adjacent (hs : Convex ùïú s)
    (hf :
      ‚àÄ {x y z : ùïú},
        x ‚àà s ‚Üí z ‚àà s ‚Üí x < y ‚Üí y < z ‚Üí (f y - f x) / (y - x) ‚â§ (f z - f y) / (z - y)) :
    ConvexOn ùïú s f ",":=
  LinearOrder.convexOn_of_lt hs fun x hx z hz hxz a b ha hb hab => by
    let y := a * x + b * z
    have hxy : x < y := by
      rw [‚Üê one_mul x, ‚Üê hab, add_mul]
      exact add_lt_add_left ((mul_lt_mul_left hb).2 hxz) _
    have hyz : y < z := by
      rw [‚Üê one_mul z, ‚Üê hab, add_mul]
      exact add_lt_add_right ((mul_lt_mul_left ha).2 hxz) _
    have : (f y - f x) * (z - y) ‚â§ (f z - f y) * (y - x) :=
      (div_le_div_iff (sub_pos.2 hxy) (sub_pos.2 hyz)).1 (hf hx hz hxy hyz)
    have hxz : 0 < z - x := sub_pos.2 (hxy.trans hyz)
    have ha : (z - y) / (z - x) = a := by
      rw [eq_comm, ‚Üê sub_eq_iff_eq_add'] at hab
      dsimp [y]
      simp_rw [div_eq_iff hxz.ne', ‚Üê hab]
      ring
    have hb : (y - x) / (z - x) = b := by
      rw [eq_comm, ‚Üê sub_eq_iff_eq_add] at hab
      dsimp [y]
      simp_rw [div_eq_iff hxz.ne', ‚Üê hab]
      ring
    rwa [sub_mul, sub_mul, sub_le_iff_le_add', ‚Üê add_sub_assoc, le_sub_iff_add_le, ‚Üê mul_add,
      sub_add_sub_cancel, ‚Üê le_div_iff hxz, add_div, mul_div_assoc, mul_div_assoc, mul_comm (f x),
      mul_comm (f z), ha, hb] at this"
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.getD_leftInvSeq_mul_wordProd,getD_leftInvSeq_mul_wordProd,347dd6345c47c2528f8d803cfe10d51a378dc185,":= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [‚Üê take_append_drop (j + 1) œâ]
  rw [take_succ]
  simp [mul_assoc]
  simp [‚Üê mul_assoc]
  rcases em (j < œâ.length) with hj | nhj
  ¬∑ rw [get?_eq_get hj]
    simp
  ¬∑ rw [get?_eq_none.mpr (by linarith)]
    simp","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  œâ.get? j
case inl
B : Type u_1
W : Type u_2
inst‚úù : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
œâ : List B
j : ‚Ñï
hj : j < œâ.length
‚ä¢ cs.wordProd (take j œâ) * (Option.map cs.simple œâ[j]?).getD 1 * (cs.wordProd (take j œâ))‚Åª¬π *
      cs.wordProd (take j œâ ++ (œâ[j]?.toList ++ drop (j + 1) œâ)) =
    cs.wordProd (take j œâ ++ drop (j + 1) œâ)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.117244.get? ?m.117245
case inr
B : Type u_1
W : Type u_2
inst‚úù : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
œâ : List B
j : ‚Ñï
nhj : ¬¨j < œâ.length
‚ä¢ cs.wordProd (take j œâ) * (Option.map cs.simple œâ[j]?).getD 1 * (cs.wordProd (take j œâ))‚Åª¬π *
      cs.wordProd (take j œâ ++ (œâ[j]?.toList ++ drop (j + 1) œâ)) =
    cs.wordProd (take j œâ ++ drop (j + 1) œâ)","theorem getD_leftInvSeq_mul_wordProd (œâ : List B) (j : ‚Ñï) :
    ((lis œâ).getD j 1) * œÄ œâ = œÄ (œâ.eraseIdx j) ",":= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [‚Üê take_append_drop (j + 1) œâ]
  rw [take_succ]
  obtain lt | le := lt_or_le j œâ.length
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]
    simp
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_none le]
    simp"
Mathlib/Data/Finset/Card.lean,Finset.le_card_sdiff,le_card_sdiff,ea1b2576466eb49ae109b64acf312f52285dafce,":=
  calc
    card t - card s ‚â§ card t - card (s ‚à© t) :=
      Nat.sub_le_sub_left (card_le_card (inter_subset_left s t)) _
    _ = card (t \ (s ‚à© t)) := (card_sdiff (inter_subset_right s t)).symm
    _ ‚â§ card (t \ s) := by rw [sdiff_inter_self_right t s]","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Finset Œ± : Type u_1
but is expected to have type
  ?m.50785 ‚àà ?m.50783 ‚à© ?m.50784 : Prop
error:  application type mismatch
  inter_subset_right s
argument
  s
has type
  Finset Œ± : Type u_1
but is expected to have type
  ?m.51205 ‚àà ?m.51203 ‚à© ?m.51204 : Prop",theorem le_card_sdiff (s t : Finset Œ±) : t.card - s.card ‚â§ card (t \ s) ,":=
  calc
    card t - card s ‚â§ card t - card (s ‚à© t) :=
      Nat.sub_le_sub_left (card_le_card inter_subset_left) _
    _ = card (t \ (s ‚à© t)) := (card_sdiff inter_subset_right).symm
    _ ‚â§ card (t \ s) := by rw [sdiff_inter_self_right t s]"
Mathlib/Topology/Category/Stonean/Basic.lean,Stonean.epi_iff_surjective,epi_iff_surjective,592e720e2651f6e8a7faf0968b75697c3bcd3b55,":= by
  refine ‚ü®?_, ConcreteCategory.epi_of_surjective _‚ü©
  dsimp [Function.Surjective]
  intro h y
  by_contra' hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := C·∂ú
  have hUy : U ‚àà nhds y := by
    simp only [Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain ‚ü®V, hV, hyV, hVU‚ü© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy
  classical
  let g : Y ‚ü∂ mkFinite (ULift (Fin 2)) :=
    ‚ü®(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _‚ü©
  let h : Y ‚ü∂ mkFinite (ULift (Fin 2)) := ‚ü®fun _ => ‚ü®1‚ü©, continuous_const‚ü©
  have H : h = g := by
    rw [‚Üê cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU ¬∑) ?_ 
    simpa only [Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H","error:  unknown tactic
error:  unsolved goals
X Y : Stonean
f : X ‚ü∂ Y
h : Epi f
y : CoeSort.coe Y
‚ä¢ ‚àÉ a, f a = y","lemma epi_iff_surjective {X Y : Stonean} (f : X ‚ü∂ Y) :
    Epi f ‚Üî Function.Surjective f ",":= by
  refine ‚ü®?_, ConcreteCategory.epi_of_surjective _‚ü©
  dsimp [Function.Surjective]
  intro h y
  by_contra! hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := C·∂ú
  have hUy : U ‚àà ùìù y := by
    simp only [C, Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain ‚ü®V, hV, hyV, hVU‚ü© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy
  classical
  let g : Y ‚ü∂ mkFinite (ULift (Fin 2)) :=
    ‚ü®(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _‚ü©
  let h : Y ‚ü∂ mkFinite (ULift (Fin 2)) := ‚ü®fun _ => ‚ü®1‚ü©, continuous_const‚ü©
  have H : h = g := by
    rw [‚Üê cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU ¬∑) ?_ 
    simpa only [U, Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H"
Mathlib/FieldTheory/NormalClosure.lean,normalClosure.restrictScalars_eq,restrictScalars_eq,d216cf6b5637b095bc0d89e3c0412a0fc69ce92e,":= by
  classical
  have hi : ‚àÄ x : K, IsIntegral F x :=
    fun x ‚Ü¶ (isIntegral_algebraMap_iff (algebraMap K L).injective).mp (h.isIntegral _)
  refine' le_antisymm (iSup_le _) (iSup_le fun x => adjoin_le_iff.mpr fun y hy => _)
  ¬∑ rintro f _ ‚ü®x, rfl‚ü©
    refine' le_iSup (fun x => adjoin F ((minpoly F x).rootSet L)) x
        (subset_adjoin F ((minpoly F x).rootSet L) _)
    rw [mem_rootSet_of_ne (minpoly.ne_zero (hi x)), AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom,
      Polynomial.aeval_algHom_apply, minpoly.aeval, map_zero]
  ¬∑ rw [Polynomial.rootSet, Finset.mem_coe, Multiset.mem_toFinset] at hy
    let g := (algHomAdjoinIntegralEquiv F (hi x)).symm ‚ü®y, hy‚ü©
    refine' le_iSup (fun f : K ‚Üí‚Çê[F] L => f.fieldRange) ((g.liftNormal L).comp (toAlgHom F K L))
        ‚ü®x, (g.liftNormal_commutes L (AdjoinSimple.gen F x)).trans _‚ü©
    rw [Algebra.id.map_eq_id, RingHom.id_apply]
    apply PowerBasis.lift_gen
    change aeval y (minpoly F (AdjoinSimple.gen F x)) = 0
    exact minpoly_gen (hi x) ‚ñ∏ aeval_eq_zero_of_mem_rootSet (Multiset.mem_toFinset.mpr hy)","error:  unknown identifier 'h.isIntegral'
error:  application type mismatch
  le_antisymm (iSup_le ?m.142611)
argument
  iSup_le ?m.142611
has type
  iSup ?m.142609 ‚â§ ?m.142610 : Prop
but is expected to have type
  restrictScalars F (toAlgHom K (‚Ü•(normalClosure F K L)) L).fieldRange ‚â§ normalClosure F K L : Prop
error:  type mismatch
  adjoin_le_iff.mpr fun y hy ‚Ü¶ ?m.143874 y hy
has type
  adjoin ?m.143664 ?m.143812 ‚â§ ?m.143813 : Prop
but is expected to have type
  x.fieldRange ‚â§ restrictScalars F (toAlgHom K (‚Ü•(normalClosure F K L)) L).fieldRange : Prop","lemma restrictScalars_eq :
    (toAlgHom K (normalClosure F K L) L).fieldRange.restrictScalars F = normalClosure F K L ",":=
  SetLike.ext' Subtype.range_val"
Mathlib/Algebra/Group/Semiconj/Units.lean,SemiconjBy.units_zpow_right,units_zpow_right,7522333a174f8732fb5dc74bd22577480b44d681,"  | (n : ‚Ñï) => by simp only [zpow_ofNat, Units.val_pow_eq_pow_val, h, pow_right]
  | -[n+1] => by simp only [zpow_negSucc, Units.val_pow_eq_pow_val, units_inv_right, h, pow_right]",error:  simp made no progress,"lemma units_zpow_right {a : M} {x y : MÀ£} (h : SemiconjBy a x y) :
    ‚àÄ m : ‚Ñ§, SemiconjBy a ‚Üë(x ^ m) ‚Üë(y ^ m)
","  | (n : ‚Ñï) => by simp only [zpow_natCast, Units.val_pow_eq_pow_val, h, pow_right]
  | -[n+1] => by simp only [zpow_negSucc, Units.val_pow_eq_pow_val, units_inv_right, h, pow_right]"
Mathlib/Data/List/Cycle.lean,List.prev_next,prev_next,d46528409610b391797c6ae50b570899f3d41002,":= by
  obtain ‚ü®n, hn, rfl‚ü© := nthLe_of_mem hx
  simp only [next_nthLe, prev_nthLe, h, Nat.mod_add_mod]
  cases' l with hd tl
  ¬∑ simp at hx
  ¬∑ have : (n + 1 + length tl) % (length tl + 1) = n := by
      rw [length_cons, Nat.succ_eq_add_one] at hn
      rw [add_assoc, add_comm 1, Nat.add_mod_right, Nat.mod_eq_of_lt hn]
    simp only [length_cons, Nat.succ_sub_succ_eq_sub, Nat.sub_zero, Nat.succ_eq_add_one, this]","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
Œ± : Type u_1
inst‚úù : DecidableEq Œ±
l : List Œ±
x : Œ±
n : ‚Ñï
hd : Œ±
tl : List Œ±
h : (hd :: tl).Nodup
hn‚úù : n < (hd :: tl).length
hn : n < tl.length + 1
hx : (hd :: tl).nthLe n hn‚úù ‚àà hd :: tl
‚ä¢ (n + 1 + tl.length) % (tl.length + 1) = n
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead","theorem prev_next (l : List Œ±) (h : Nodup l) (x : Œ±) (hx : x ‚àà l) :
    prev l (next l x hx) (next_mem _ _ _) = x ",":= by
  obtain ‚ü®n, hn, rfl‚ü© := nthLe_of_mem hx
  simp only [next_nthLe, prev_nthLe, h, Nat.mod_add_mod]
  cases' l with hd tl
  ¬∑ simp at hx
  ¬∑ have : (n + 1 + length tl) % (length tl + 1) = n := by
      rw [length_cons] at hn
      rw [add_assoc, add_comm 1, Nat.add_mod_right, Nat.mod_eq_of_lt hn]
    simp only [length_cons, Nat.succ_sub_succ_eq_sub, Nat.sub_zero, Nat.succ_eq_add_one, this]"
Mathlib/Computability/TuringMachine.lean,Turing.TM2to1.tr_respects_aux‚ÇÇ,tr_respects_aux‚ÇÇ,0ef23fba776dbe5bb848bbfc3337bedef4a59c82,":= by
  dsimp only; simp; cases o with simp only [stWrite, stVar, trStAct, TM1.stepAux]
  | push f =>
    have := Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k (some (f v)))
    refine
      ‚ü®_, fun k' ‚Ü¶ ?_, by
        erw [Tape.move_right_n_head, List.length, Tape.mk'_nth_nat, this,
          addBottom_modifyNth fun a ‚Ü¶ update a k (some (f v)), Nat.add_one, iterate_succ']
        rfl‚ü©
    refine ListBlank.ext fun i ‚Ü¶ ?_
    rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
    by_cases h' : k' = k
    ¬∑ subst k'
      split_ifs with h
        <;> simp only [List.reverse_cons, Function.update_same, ListBlank.nth_mk, List.map]
      ¬∑ rw [List.getI_eq_get, List.get_append_right'] <;>
          simp only [h, List.get_singleton, List.length_map, List.length_reverse, Nat.succ_pos',
            List.length_append, lt_add_iff_pos_right, List.length, le_refl]
      rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk]
      cases' lt_or_gt_of_ne h with h h
      ¬∑ rw [List.getI_append]
        simpa only [List.length_map, List.length_reverse] using h
      ¬∑ rw [gt_iff_lt] at h
        rw [List.getI_eq_default, List.getI_eq_default] <;>
          simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
            List.length_append, List.length_map]
    ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
      rw [Function.update_noteq h']
  | peek f =>
    rw [Function.update_eq_self]
    use L, hL; rw [Tape.move_left_right]; congr
    cases e : S k; ¬∑ rfl
    rw [List.length_cons, iterate_succ', Function.comp, Tape.move_right_left,
      Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_snd, stk_nth_val _ (hL k), e,
      List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length]
    rfl
  | pop f =>
    cases' e : S k with hd tl
    ¬∑ simp only [Tape.mk'_head, ListBlank.head_cons, Tape.move_left_mk', List.length,
        Tape.write_mk', List.head?, iterate_zero_apply, List.tail_nil]
      rw [‚Üê e, Function.update_eq_self]
      exact ‚ü®L, hL, by rw [addBottom_head_fst, cond]‚ü©
    ¬∑ refine
        ‚ü®_, fun k' ‚Ü¶ ?_, by
          erw [List.length_cons, Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_succ_fst,
            cond, iterate_succ', Function.comp, Tape.move_right_left, Tape.move_right_n_head,
            Tape.mk'_nth_nat, Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k none),
            addBottom_modifyNth fun a ‚Ü¶ update a k none, addBottom_nth_snd,
            stk_nth_val _ (hL k), e,
            show (List.cons hd tl).reverse.get? tl.length = some hd by
              rw [List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length],
            List.head?, List.tail]‚ü©
      refine ListBlank.ext fun i ‚Ü¶ ?_
      rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
      by_cases h' : k' = k
      ¬∑ subst k'
        split_ifs with h <;> simp only [Function.update_same, ListBlank.nth_mk, List.tail]
        ¬∑ rw [List.getI_eq_default]
          ¬∑ rfl
          rw [h, List.length_reverse, List.length_map]
        rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk, e, List.map, List.reverse_cons]
        cases' lt_or_gt_of_ne h with h h
        ¬∑ rw [List.getI_append]
          simpa only [List.length_map, List.length_reverse] using h
        ¬∑ rw [gt_iff_lt] at h
          rw [List.getI_eq_default, List.getI_eq_default] <;>
            simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
              List.length_append, List.length_map]
      ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
        rw [Function.update_noteq h']","warning:  `List.get_append` has been deprecated, use `List.getElem_append` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get_replicate` has been deprecated, use `List.getElem_replicate` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  unused variable `M`
note: this linter can be disabled with `set_option linter.unusedVariables false`
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
error:  unsolved goals
case pos.h‚ÇÇ
K : Type u_1
inst‚úù¬≤ : DecidableEq K
Œì : K ‚Üí Type u_2
Œõ : Type u_3
inst‚úù¬π : Inhabited Œõ
œÉ : Type u_4
inst‚úù : Inhabited œÉ
k : K
q : TM1.Stmt Œì' Œõ' œÉ
v : œÉ
S : (k : K) ‚Üí List (Œì k)
L : ListBlank ((k : K) ‚Üí Option (Œì k))
hL : ‚àÄ (k : K), ListBlank.map (proj k) L = ListBlank.mk (List.map some (S k)).reverse
f : œÉ ‚Üí Œì k
this :
  ‚àÄ (L R : ListBlank Œì') (n : ‚Ñï),
    Tape.write ((R.nth n).1, update (R.nth n).2 k (some (f v))) ((Tape.move Dir.right)^[n] (Tape.mk' L R)) =
      (Tape.move Dir.right)^[n] (Tape.mk' L (ListBlank.modifyNth (fun a ‚Ü¶ (a.1, update a.2 k (some (f v)))) n R))
i : ‚Ñï
h : i = (S k).length
‚ä¢ (S k).length < (S k).length + (0 + 1)
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead","theorem tr_respects_aux‚ÇÇ {k : K} {q : Stmt‚ÇÇ‚ÇÅ} {v : œÉ} {S : ‚àÄ k, List (Œì k)}
    {L : ListBlank (‚àÄ k, Option (Œì k))}
    (hL : ‚àÄ k, L.map (proj k) = ListBlank.mk ((S k).map some).reverse) (o : StAct‚ÇÇ k) :
    let v' := stVar v (S k) o
    let Sk' := stWrite v (S k) o
    let S' := update S k Sk'
    ‚àÉ L' : ListBlank (‚àÄ k, Option (Œì k)),
      (‚àÄ k, L'.map (proj k) = ListBlank.mk ((S' k).map some).reverse) ‚àß
        TM1.stepAux (trStAct q o) v
            ((Tape.move Dir.right)^[(S k).length] (Tape.mk' ‚àÖ (addBottom L))) =
          TM1.stepAux q v' ((Tape.move Dir.right)^[(S' k).length] (Tape.mk' ‚àÖ (addBottom L'))) ",":= by
  dsimp only; simp; cases o with simp only [stWrite, stVar, trStAct, TM1.stepAux]
  | push f =>
    have := Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k (some (f v)))
    refine
      ‚ü®_, fun k' ‚Ü¶ ?_, by
        erw [Tape.move_right_n_head, List.length, Tape.mk'_nth_nat, this,
          addBottom_modifyNth fun a ‚Ü¶ update a k (some (f v)), Nat.add_one, iterate_succ']
        rfl‚ü©
    refine ListBlank.ext fun i ‚Ü¶ ?_
    rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
    by_cases h' : k' = k
    ¬∑ subst k'
      split_ifs with h
        <;> simp only [List.reverse_cons, Function.update_same, ListBlank.nth_mk, List.map]
      ¬∑ rw [List.getI_eq_get, List.get_append_right'] <;>
          simp only [List.length_singleton, h, List.length_reverse, List.length_map, Nat.sub_self,
            Fin.zero_eta, List.get_cons_zero, le_refl, List.length_append, Nat.lt_succ_self]
      rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk]
      cases' lt_or_gt_of_ne h with h h
      ¬∑ rw [List.getI_append]
        simpa only [List.length_map, List.length_reverse] using h
      ¬∑ rw [gt_iff_lt] at h
        rw [List.getI_eq_default, List.getI_eq_default] <;>
          simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
            List.length_append, List.length_map]
    ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
      rw [Function.update_noteq h']
  | peek f =>
    rw [Function.update_eq_self]
    use L, hL; rw [Tape.move_left_right]; congr
    cases e : S k; ¬∑ rfl
    rw [List.length_cons, iterate_succ', Function.comp, Tape.move_right_left,
      Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_snd, stk_nth_val _ (hL k), e,
      List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length]
    rfl
  | pop f =>
    cases' e : S k with hd tl
    ¬∑ simp only [Tape.mk'_head, ListBlank.head_cons, Tape.move_left_mk', List.length,
        Tape.write_mk', List.head?, iterate_zero_apply, List.tail_nil]
      rw [‚Üê e, Function.update_eq_self]
      exact ‚ü®L, hL, by rw [addBottom_head_fst, cond]‚ü©
    ¬∑ refine
        ‚ü®_, fun k' ‚Ü¶ ?_, by
          erw [List.length_cons, Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_succ_fst,
            cond, iterate_succ', Function.comp, Tape.move_right_left, Tape.move_right_n_head,
            Tape.mk'_nth_nat, Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k none),
            addBottom_modifyNth fun a ‚Ü¶ update a k none, addBottom_nth_snd,
            stk_nth_val _ (hL k), e,
            show (List.cons hd tl).reverse.get? tl.length = some hd by
              rw [List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length],
            List.head?, List.tail]‚ü©
      refine ListBlank.ext fun i ‚Ü¶ ?_
      rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
      by_cases h' : k' = k
      ¬∑ subst k'
        split_ifs with h <;> simp only [Function.update_same, ListBlank.nth_mk, List.tail]
        ¬∑ rw [List.getI_eq_default]
          ¬∑ rfl
          rw [h, List.length_reverse, List.length_map]
        rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk, e, List.map, List.reverse_cons]
        cases' lt_or_gt_of_ne h with h h
        ¬∑ rw [List.getI_append]
          simpa only [List.length_map, List.length_reverse] using h
        ¬∑ rw [gt_iff_lt] at h
          rw [List.getI_eq_default, List.getI_eq_default] <;>
            simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
              List.length_append, List.length_map]
      ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
        rw [Function.update_noteq h']"
Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean,Polynomial.trailingDegree_eq_zero,trailingDegree_eq_zero,ecea0219402fe1bd4e3d26207348c28474ddf87c,":= by
  rw [‚Üê nonpos_iff_eq_zero, trailingDegree, Finset.min_le]","error:  tactic 'rewrite' failed, equality or iff proof expected
  ‚àÉ b, ?m.10689.min = ‚Üëb ‚àß b ‚â§ ?a
R : Type u
S : Type v
a b : R
n m : ‚Ñï
inst‚úù : Semiring R
p q r : R[X]
‚ä¢ p.support.min ‚â§ 0 ‚Üî p.coeff 0 ‚â† 0",lemma trailingDegree_eq_zero : trailingDegree p = 0 ‚Üî coeff p 0 ‚â† 0 ,":= by
  obtain rfl | hp := eq_or_ne p 0
  ¬∑ simp [WithTop.top_ne_zero (Œ± := ‚Ñï)]
  ¬∑ exact (trailingDegree_eq_iff_natTrailingDegree_eq hp).trans $
      natTrailingDegree_eq_zero.trans $ or_iff_right hp"
Mathlib/Data/List/Enum.lean,List.enumFrom_append,enumFrom_append,0c824fb54f74f0c66db893166b73e377be2feb6f,":= by
  induction' xs with x xs IH generalizing ys n
  ¬∑ simp
  ¬∑ rw [cons_append, enumFrom_cons, IH, ‚Üê cons_append, ‚Üê enumFrom_cons, length, Nat.add_right_comm,
      ‚Üê Nat.add_assoc']","error:  unknown constant 'Nat.add_assoc''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.12759
case cons
Œ± : Type u_1
Œ≤ : Type u_2
x : Œ±
xs : List Œ±
IH : ‚àÄ (ys : List Œ±) (n : ‚Ñï), enumFrom n (xs ++ ys) = enumFrom n xs ++ enumFrom (n + xs.length) ys
ys : List Œ±
n : ‚Ñï
‚ä¢ enumFrom n (x :: xs) ++ enumFrom (n + xs.length + 1) ys = enumFrom n (x :: xs) ++ enumFrom (n + (xs.length + 1)) ys","theorem enumFrom_append (xs ys : List Œ±) (n : ‚Ñï) :
    enumFrom n (xs ++ ys) = enumFrom n xs ++ enumFrom (n + xs.length) ys ",":= by
  induction' xs with x xs IH generalizing ys n
  ¬∑ simp
  ¬∑ rw [cons_append, enumFrom_cons, IH, ‚Üê cons_append, ‚Üê enumFrom_cons, length, Nat.add_right_comm,
      Nat.add_assoc]"
Mathlib/Topology/Algebra/Module/Cardinality.lean,Set.Countable.dense_compl,Set.Countable.dense_compl,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  rw [‚Üê interior_eq_empty_iff_dense_compl]
  by_contra H
  apply lt_irrefl (‚Ñµ‚ÇÄ : Cardinal.{u})
  calc
    (‚Ñµ‚ÇÄ : Cardinal.{u}) < ùî† := aleph0_lt_continuum
    _ ‚â§ #(interior s) :=
      continuum_le_cardinal_of_is_open ùïú isOpen_interior (nmem_singleton_empty.1 H)
    _ ‚â§ #s := mk_le_mk_of_subset interior_subset
    _ ‚â§ ‚Ñµ‚ÇÄ := le_aleph0 hs",error:  unknown identifier 'continuum_le_cardinal_of_is_open',"theorem Set.Countable.dense_compl
    {E : Type u} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : s.Countable) : Dense s·∂ú ",":= by
  rw [‚Üê interior_eq_empty_iff_dense_compl]
  by_contra H
  apply lt_irrefl (‚Ñµ‚ÇÄ : Cardinal.{u})
  calc
    (‚Ñµ‚ÇÄ : Cardinal.{u}) < ùî† := aleph0_lt_continuum
    _ ‚â§ #(interior s) :=
      continuum_le_cardinal_of_isOpen ùïú isOpen_interior (nmem_singleton_empty.1 H)
    _ ‚â§ #s := mk_le_mk_of_subset interior_subset
    _ ‚â§ ‚Ñµ‚ÇÄ := le_aleph0 hs"
Mathlib/Geometry/Manifold/ContMDiff/Basic.lean,ContMDiff.extend_one,ContMDiff.extend_one,b502dbb455f708f5af5e6017e88f53565165ab0a,":= fun x ‚Ü¶ by
  refine contMDiff_of_mulTSupport (fun x h ‚Ü¶ ?_) _
  lift x to U using Subtype.coe_image_subset _ _
    (supp.mulTSupport_extend_one_subset continuous_subtype_val h)
  rw [‚Üê contMdiffAt_subtype_iff, ‚Üê comp_def, extend_comp Subtype.val_injective]
  exact diff.contMDiffAt","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  extend Subtype.val ?g ?e' ‚àò Subtype.val
case intro
ùïú : Type u_1
inst‚úù¬π‚Åπ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π‚Å∏ : NormedAddCommGroup E
inst‚úù¬π‚Å∑ : NormedSpace ùïú E
H : Type u_3
inst‚úù¬π‚Å∂ : TopologicalSpace H
I : ModelWithCorners ùïú E H
M : Type u_4
inst‚úù¬π‚Åµ : TopologicalSpace M
inst‚úù¬π‚Å¥ : ChartedSpace H M
inst‚úù¬π¬≥ : SmoothManifoldWithCorners I M
E' : Type u_5
inst‚úù¬π¬≤ : NormedAddCommGroup E'
inst‚úù¬π¬π : NormedSpace ùïú E'
H' : Type u_6
inst‚úù¬π‚Å∞ : TopologicalSpace H'
I' : ModelWithCorners ùïú E' H'
M' : Type u_7
inst‚úù‚Åπ : TopologicalSpace M'
inst‚úù‚Å∏ : ChartedSpace H' M'
inst‚úù‚Å∑ : SmoothManifoldWithCorners I' M'
E'' : Type u_8
inst‚úù‚Å∂ : NormedAddCommGroup E''
inst‚úù‚Åµ : NormedSpace ùïú E''
H'' : Type u_9
inst‚úù‚Å¥ : TopologicalSpace H''
I'' : ModelWithCorners ùïú E'' H''
M'' : Type u_10
inst‚úù¬≥ : TopologicalSpace M''
inst‚úù¬≤ : ChartedSpace H'' M''
e : PartialHomeomorph M H
e' : PartialHomeomorph M' H'
f‚úù f‚ÇÅ : M ‚Üí M'
s s‚ÇÅ t : Set M
x‚úù¬π : M
m n‚úù : ‚Ñï‚àû
inst‚úù¬π : T2Space M
inst‚úù : One M'
n : ‚Ñï‚àû
U : Opens M
f : ‚Ü•U ‚Üí M'
supp : HasCompactMulSupport f
diff : ContMDiff I I' n f
x‚úù : M
x : ‚Ü•U
h : ‚Üëx ‚àà mulTSupport (extend Subtype.val f 1)
‚ä¢ ContMDiffAt I I' n (extend Subtype.val f 1 ‚àò Subtype.val) x","theorem ContMDiff.extend_one [T2Space M] [One M'] {n : ‚Ñï‚àû} {U : Opens M} {f : U ‚Üí M'}
    (supp : HasCompactMulSupport f) (diff : ContMDiff I I' n f) :
    ContMDiff I I' n (Subtype.val.extend f 1) ",":= fun x ‚Ü¶ by
  refine contMDiff_of_mulTSupport (fun x h ‚Ü¶ ?_) _
  lift x to U using Subtype.coe_image_subset _ _
    (supp.mulTSupport_extend_one_subset continuous_subtype_val h)
  rw [‚Üê contMdiffAt_subtype_iff, ‚Üê comp_def]
  erw [ extend_comp Subtype.val_injective]
  exact diff.contMDiffAt"
Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean,Complex.Gamma‚Ñù_div_Gamma‚Ñù_one_sub,Gamma‚Ñù_div_Gamma‚Ñù_one_sub,c594080a3e4c06f2ce26bdc51d663062c084ce2d,":= by
  have : Gamma‚Ñù (s + 1) ‚â† 0 := by
    simpa only [Ne.def, Gamma‚Ñù_eq_zero_iff, not_exists, ‚Üê eq_sub_iff_add_eq,
      sub_eq_add_neg, ‚Üê neg_add]
  calc Gamma‚Ñù s / Gamma‚Ñù (1 - s)
  _ = (Gamma‚Ñù s * Gamma‚Ñù (s + 1)) / (Gamma‚Ñù (1 - s) * Gamma‚Ñù (1 + s)) := by
    rw [add_comm 1 s, mul_comm (Gamma‚Ñù (1 - s)) (Gamma‚Ñù (s + 1)), ‚Üê div_div,
      mul_div_cancel _ this]
  _ = (2 * (2 * œÄ) ^ (-s) * Gamma s) / ((cos (œÄ * s / 2))‚Åª¬π) := by
    rw [Gamma‚Ñù_one_sub_mul_Gamma‚Ñù_one_add, Gamma‚Ñù_mul_Gamma‚Ñù_add_one, Gamma‚ÑÇ_def]
  _ = _ := by rw [Gamma‚ÑÇ_def, div_eq_mul_inv, inv_inv]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.71491 ‚Üí ?m.71491 ‚Üí Prop
error:  tactic 'assumption' failed
s : ‚ÑÇ
hs : ‚àÄ (n : ‚Ñï), s ‚â† -(2 * ‚Üën + 1)
‚ä¢ (s + 1).Gamma‚Ñù ‚â† 0
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.73283 * (?m.73296 / ?m.73283)
s : ‚ÑÇ
hs : ‚àÄ (n : ‚Ñï), s ‚â† -(2 * ‚Üën + 1)
this : (s + 1).Gamma‚Ñù ‚â† 0
‚ä¢ s.Gamma‚Ñù / (1 - s).Gamma‚Ñù = s.Gamma‚Ñù * (s + 1).Gamma‚Ñù / (s + 1).Gamma‚Ñù / (1 - s).Gamma‚Ñù","lemma Gamma‚Ñù_div_Gamma‚Ñù_one_sub {s : ‚ÑÇ} (hs : ‚àÄ (n : ‚Ñï), s ‚â† -(2 * n + 1)) :
    Gamma‚Ñù s / Gamma‚Ñù (1 - s) = Gamma‚ÑÇ s * cos (œÄ * s / 2) ",":= by
  have : Gamma‚Ñù (s + 1) ‚â† 0 := by
    simpa only [Ne, Gamma‚Ñù_eq_zero_iff, not_exists, ‚Üê eq_sub_iff_add_eq,
      sub_eq_add_neg, ‚Üê neg_add]
  calc Gamma‚Ñù s / Gamma‚Ñù (1 - s)
  _ = (Gamma‚Ñù s * Gamma‚Ñù (s + 1)) / (Gamma‚Ñù (1 - s) * Gamma‚Ñù (1 + s)) := by
    rw [add_comm 1 s, mul_comm (Gamma‚Ñù (1 - s)) (Gamma‚Ñù (s + 1)), ‚Üê div_div,
      mul_div_cancel_right‚ÇÄ _ this]
  _ = (2 * (2 * œÄ) ^ (-s) * Gamma s) / ((cos (œÄ * s / 2))‚Åª¬π) := by
    rw [Gamma‚Ñù_one_sub_mul_Gamma‚Ñù_one_add, Gamma‚Ñù_mul_Gamma‚Ñù_add_one, Gamma‚ÑÇ_def]
  _ = _ := by rw [Gamma‚ÑÇ_def, div_eq_mul_inv, inv_inv]"
Mathlib/NumberTheory/ModularForms/JacobiTheta/OneVariable.lean,norm_jacobiTheta_sub_one_le,norm_jacobiTheta_sub_one_le,26dcb0a78bda63252389cd8290cafcd2d953c437,":= by
  suffices ‚Äñ‚àë' n : ‚Ñï, cexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ ‚â§
      rexp (-œÄ * œÑ.im) / (1 - rexp (-œÄ * œÑ.im)) by
    calc
      ‚ÄñjacobiTheta œÑ - 1‚Äñ = ‚Üë2 * ‚Äñ‚àë' n : ‚Ñï, cexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ := by
        rw [sub_eq_iff_eq_add'.mpr (jacobiTheta_eq_tsum_nat hœÑ), norm_mul, Complex.norm_eq_abs,
          Complex.abs_two]
      _ ‚â§ 2 * (rexp (-œÄ * œÑ.im) / (1 - rexp (-œÄ * œÑ.im))) := by gcongr
      _ = 2 / (1 - rexp (-œÄ * œÑ.im)) * rexp (-œÄ * œÑ.im) := by rw [div_mul_comm, mul_comm]
  have : ‚àÄ n : ‚Ñï, ‚Äñcexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ ‚â§ rexp (-œÄ * œÑ.im) ^ (n + 1) := by
    intro n
    simpa only [Int.cast_add, Int.cast_one] using norm_exp_mul_sq_le hœÑ (n + 1)
  have s : HasSum (fun n : ‚Ñï =>
      rexp (-œÄ * œÑ.im) ^ (n + 1)) (rexp (-œÄ * œÑ.im) / (1 - rexp (-œÄ * œÑ.im))) := by
    simp_rw [pow_succ, div_eq_mul_inv, hasSum_mul_left_iff (Real.exp_ne_zero _)]
    exact hasSum_geometric_of_lt_1 (exp_pos (-œÄ * œÑ.im)).le
      (exp_lt_one_iff.mpr <| mul_neg_of_neg_of_pos (neg_lt_zero.mpr pi_pos) hœÑ)
  have aux : Summable fun n : ‚Ñï => ‚Äñcexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ :=
    .of_nonneg_of_le (fun n => norm_nonneg _) this s.summable
  exact (norm_tsum_le_tsum_norm aux).trans ((tsum_mono aux s.summable this).trans_eq s.tsum_eq)",error:  simp made no progress,"theorem norm_jacobiTheta_sub_one_le {œÑ : ‚ÑÇ} (hœÑ : 0 < im œÑ) :
    ‚ÄñjacobiTheta œÑ - 1‚Äñ ‚â§ 2 / (1 - rexp (-œÄ * œÑ.im)) * rexp (-œÄ * œÑ.im) ",":= by
  suffices ‚Äñ‚àë' n : ‚Ñï, cexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ ‚â§
      rexp (-œÄ * œÑ.im) / (1 - rexp (-œÄ * œÑ.im)) by
    calc
      ‚ÄñjacobiTheta œÑ - 1‚Äñ = ‚Üë2 * ‚Äñ‚àë' n : ‚Ñï, cexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ := by
        rw [sub_eq_iff_eq_add'.mpr (jacobiTheta_eq_tsum_nat hœÑ), norm_mul, Complex.norm_eq_abs,
          Complex.abs_two]
      _ ‚â§ 2 * (rexp (-œÄ * œÑ.im) / (1 - rexp (-œÄ * œÑ.im))) := by gcongr
      _ = 2 / (1 - rexp (-œÄ * œÑ.im)) * rexp (-œÄ * œÑ.im) := by rw [div_mul_comm, mul_comm]
  have : ‚àÄ n : ‚Ñï, ‚Äñcexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ ‚â§ rexp (-œÄ * œÑ.im) ^ (n + 1) := by
    intro n
    simpa only [Int.cast_add, Int.cast_one] using norm_exp_mul_sq_le hœÑ (n + 1)
  have s : HasSum (fun n : ‚Ñï =>
      rexp (-œÄ * œÑ.im) ^ (n + 1)) (rexp (-œÄ * œÑ.im) / (1 - rexp (-œÄ * œÑ.im))) := by
    simp_rw [pow_succ', div_eq_mul_inv, hasSum_mul_left_iff (Real.exp_ne_zero _)]
    exact hasSum_geometric_of_lt_one (exp_pos (-œÄ * œÑ.im)).le
      (exp_lt_one_iff.mpr <| mul_neg_of_neg_of_pos (neg_lt_zero.mpr pi_pos) hœÑ)
  have aux : Summable fun n : ‚Ñï => ‚Äñcexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ :=
    .of_nonneg_of_le (fun n => norm_nonneg _) this s.summable
  exact (norm_tsum_le_tsum_norm aux).trans ((tsum_mono aux s.summable this).trans_eq s.tsum_eq)"
Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean,CategoryTheory.comp_rightAdjointMate,comp_rightAdjointMate,c1978269da4d93ac5da9e998859ea2c2a083e884,":= by
  rw [rightAdjointMate_comp]
  simp_rw [rightAdjointMate, ‚Üê id_tensorHom, ‚Üê tensorHom_id]
  simp only [rightAdjointMate, comp_tensor_id, Iso.cancel_iso_inv_left, id_tensor_comp,
    Category.assoc]
  symm
  iterate 5
    trans
    rw [‚Üê Category.id_comp g, tensor_comp]
  rw [‚Üê Category.assoc]
  symm
  iterate 2
    trans
    rw [‚Üê Category.assoc]
  apply eq_whisker
  repeat'
    rw [‚Üê @id_tensor_comp C]
  congr 1
  rw [‚Üê id_tensor_comp_tensor_id (Œª_ (X·òÅ)).hom g, id_tensor_rightUnitor_inv, Category.assoc,
    Category.assoc, rightUnitor_inv_naturality'_assoc, ‚Üê associator_naturality_assoc, tensor_id,
    tensor_id_comp_id_tensor_assoc, ‚Üê associator_naturality_assoc]
  slice_rhs 2 3 =>
    rw [‚Üê tensor_comp, tensor_id, Category.comp_id, ‚Üê Category.id_comp (Œ∑_ Y (Y·òÅ)), tensor_comp]
  rw [‚Üê id_tensor_comp_tensor_id _ (Œ∑_ Y (Y·òÅ)), ‚Üê tensor_id]
  simp only [tensorHom_id, id_tensorHom, id_whiskerLeft, id_whiskerRight, whiskerRight_tensor, Category.assoc,
    Iso.inv_hom_id_assoc, pentagon_hom_hom_inv_hom_hom]
  rw [‚Üê associator_naturality_middle_assoc]
  simp_rw [‚Üê comp_whiskerRight_assoc, evaluation_coevaluation]
  coherence","warning:  @coevaluation does not have a doc string
warning:  @evaluation does not have a doc string
warning:  @leftDual does not have a doc string
warning:  @rightDual does not have a doc string
warning:  @rightAdjointMate does not have a doc string
warning:  @leftAdjointMate does not have a doc string
error:  unknown identifier 'id_tensor_rightUnitor_inv'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.202953
case w.e_g
C : Type u‚ÇÅ
inst‚úù‚Å¥ : Category.{v‚ÇÅ, u‚ÇÅ} C
inst‚úù¬≥ : MonoidalCategory C
X Y Z : C
inst‚úù¬≤ : HasRightDual X
inst‚úù¬π : HasRightDual Y
inst‚úù : HasRightDual Z
f : X ‚ü∂ Y
g : Y ‚ü∂ Z
‚ä¢ (Œ∑_ X X·òÅ ‚â´ (f ‚äó ùüô X·òÅ)) ‚â´ (g ‚äó ùüô X·òÅ) =
    Œ∑_ Y Y·òÅ ‚â´
      (ùüô Y ‚äó (œÅ_ Y·òÅ).inv) ‚â´
        (ùüô Y ‚äó ùüô Y·òÅ ‚äó Œ∑_ X X·òÅ) ‚â´
          (ùüô Y ‚äó ùüô Y·òÅ ‚äó f ‚äó ùüô X·òÅ) ‚â´ (ùüô Y ‚äó (Œ±_ Y·òÅ Y X·òÅ).inv) ‚â´ (ùüô Y ‚äó Œµ_ Y Y·òÅ ‚äó ùüô X·òÅ) ‚â´ (ùüô Y ‚äó (Œª_ X·òÅ).hom) ‚â´ (g ‚äó ùüô X·òÅ)","theorem comp_rightAdjointMate {X Y Z : C} [HasRightDual X] [HasRightDual Y] [HasRightDual Z]
    {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g)·òÅ = g·òÅ ‚â´ f·òÅ ",":= by
  rw [rightAdjointMate_comp]
  simp only [rightAdjointMate, comp_whiskerRight]
  simp only [‚Üê Category.assoc]; congr 3; simp only [Category.assoc]
  simp only [‚Üê MonoidalCategory.whiskerLeft_comp]; congr 2
  symm
  calc
    _ = ùüô _ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ ùüô_ C ‚â´ (Y ‚äó Y·òÅ) ‚óÅ Œ∑_ X X·òÅ) ‚äó‚â´ Y ‚óÅ Y·òÅ ‚óÅ f ‚ñ∑ X·òÅ ‚äó‚â´
        Y ‚óÅ Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [tensorHom_def']; coherence
    _ = Œ∑_ X X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ (X ‚äó X·òÅ) ‚â´ (Y ‚äó Y·òÅ) ‚óÅ f ‚ñ∑ X·òÅ) ‚äó‚â´
        Y ‚óÅ Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [‚Üê whisker_exchange]; coherence
    _ = Œ∑_ X X·òÅ ‚äó‚â´ f ‚ñ∑ X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ Y ‚äó‚â´ Y ‚óÅ Œµ_ Y Y·òÅ) ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [‚Üê whisker_exchange]; coherence
    _ = Œ∑_ X X·òÅ ‚â´ f ‚ñ∑ X·òÅ ‚â´ g ‚ñ∑ X·òÅ := by
      rw [evaluation_coevaluation'']; coherence"
Mathlib/Algebra/Pointwise/Stabilizer.lean,MulAction.stabilizer_image_coe_quotient,stabilizer_image_coe_quotient,1efbb9e50a71340493cbce9f10f70a71b845c454,":= by
  ext a
  induction' a with a
  simp only [mem_stabilizer_iff, Subgroup.mem_bot, QuotientGroup.eq_one_iff]
  have : q a ‚Ä¢ q '' s = q '' (a ‚Ä¢ s) :=
    (image_smul_distrib (QuotientGroup.mk' <| stabilizer G s) _ _).symm
  rw [this]
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ by rw [h]‚ü©
  rwa [QuotientGroup.image_coe_inj, mul_smul_comm, stabilizer_mul_self] at h","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
case h
G : Type u_1
inst‚úù : CommGroup G
s : Set G
a : G ‚ß∏ stabilizer G s
‚ä¢ a ‚àà stabilizer (G ‚ß∏ stabilizer G s) (QuotientGroup.mk '' s) ‚Üî a ‚àà ‚ä•",lemma stabilizer_image_coe_quotient : stabilizer Q (q '' s) = ‚ä• ,":= by
  ext a
  induction' a using QuotientGroup.induction_on' with a
  simp only [mem_stabilizer_iff, Subgroup.mem_bot, QuotientGroup.eq_one_iff]
  have : q a ‚Ä¢ q '' s = q '' (a ‚Ä¢ s) :=
    (image_smul_distrib (QuotientGroup.mk' <| stabilizer G s) _ _).symm
  rw [this]
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ by rw [h]‚ü©
  rwa [QuotientGroup.image_coe_inj, mul_smul_comm, stabilizer_mul_self] at h"
Mathlib/NumberTheory/LegendreSymbol/AddCharacter.lean,AddChar.IsPrimitive.compMulHom_of_isPrimitive,IsPrimitive.compMulHom_of_isPrimitive,cfb67dc2b69e7e3c8df320d6d887e00dd240c448,":= by
  intro a a_ne_zero
  obtain ‚ü®r, ne_one‚ü© := hœÜ a a_ne_zero
  rw [mulShift_apply] at ne_one
  simp only [IsNontrivial, mulShift_apply, f.coe_compAddChar, Function.comp_apply]
  exact ‚ü®r, fun H ‚Ü¶ ne_one <| hf <| f.map_one ‚ñ∏ H‚ü©","error:  application type mismatch
  hœÜ a
argument
  a
has type
  R : Type u
but is expected to have type
  ?m.5756 ‚â† 0 : Prop
error:  no goals to be solved","lemma IsPrimitive.compMulHom_of_isPrimitive {R'' : Type*} [CommMonoid R''] {œÜ : AddChar R R'}
    {f : R' ‚Üí* R''} (hœÜ : œÜ.IsPrimitive) (hf : Function.Injective f) :
    (f.compAddChar œÜ).IsPrimitive ",":= fun a ha ‚Ü¶ by
  simpa [DFunLike.ext_iff] using (MonoidHom.compAddChar_injective_right f hf).ne (hœÜ ha)"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.OuterMeasure.mkMetric_mono,mkMetric_mono,ced4d3c0af763b9fd00166e49cf999cf46c891cc,":= by
  classical
  rcases (mem_nhdsWithin_Ici_iff_exists_Ico_subset' zero_lt_one).1 hle with ‚ü®r, hr0, hr‚ü©
  refine fun s =>
    le_of_tendsto_of_tendsto (mkMetric'.tendsto_pre _ s)
      (ENNReal.Tendsto.const_mul (mkMetric'.tendsto_pre _ s) (Or.inr hc))
      (mem_of_superset (Ioo_mem_nhdsWithin_Ioi ‚ü®le_rfl, hr0‚ü©) fun r' hr' => _)
  simp only [mem_setOf_eq, mkMetric'.pre, RingHom.id_apply]
  rw [‚Üê smul_eq_mul, ‚Üê smul_apply, smul_boundedBy hc]
  refine le_boundedBy.2 (fun t => (boundedBy_le _).trans _) _
  simp only [smul_eq_mul, Pi.smul_apply, extend, iInf_eq_if]
  split_ifs with ht
  ¬∑ apply hr
    exact ‚ü®zero_le _, ht.trans_lt hr'.2‚ü©
  ¬∑ simp [h0]","error:  don't know how to synthesize placeholder
context:
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬π : EMetricSpace X
inst‚úù : EMetricSpace Y
m‚ÇÅ m‚ÇÇ : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû
c : ‚Ñù‚â•0‚àû
hc : c ‚â† ‚ä§
h0 : c ‚â† 0
hle : m‚ÇÅ ‚â§·∂†[ùìù[‚â•] 0] c ‚Ä¢ m‚ÇÇ
r : ‚Ñù‚â•0‚àû
hr0 : r ‚àà Ioi 0
hr : Ico 0 r ‚äÜ {x | (fun x ‚Ü¶ m‚ÇÅ x ‚â§ (c ‚Ä¢ m‚ÇÇ) x) x}
s : Set X
r' : ‚Ñù‚â•0‚àû
hr' : r' ‚àà Ioo 0 r
‚ä¢ r' ‚àà
    {x |
      (fun x ‚Ü¶
          (fun r ‚Ü¶ (mkMetric'.pre (fun s ‚Ü¶ m‚ÇÅ (diam s)) r) s) x ‚â§
            (fun b ‚Ü¶ c * (mkMetric'.pre (fun s ‚Ü¶ m‚ÇÇ (diam s)) b) s) x)
        x}
error:  unsolved goals
case intro.intro
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬π : EMetricSpace X
inst‚úù : EMetricSpace Y
m‚ÇÅ m‚ÇÇ : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû
c : ‚Ñù‚â•0‚àû
hc : c ‚â† ‚ä§
h0 : c ‚â† 0
hle : m‚ÇÅ ‚â§·∂†[ùìù[‚â•] 0] c ‚Ä¢ m‚ÇÇ
r : ‚Ñù‚â•0‚àû
hr0 : r ‚àà Ioi 0
hr : Ico 0 r ‚äÜ {x | (fun x ‚Ü¶ m‚ÇÅ x ‚â§ (c ‚Ä¢ m‚ÇÇ) x) x}
‚ä¢ mkMetric m‚ÇÅ ‚â§ c ‚Ä¢ mkMetric m‚ÇÇ","theorem mkMetric_mono_smul {m‚ÇÅ m‚ÇÇ : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû} {c : ‚Ñù‚â•0‚àû} (hc : c ‚â† ‚àû) (h0 : c ‚â† 0)
    (hle : m‚ÇÅ ‚â§·∂†[ùìù[‚â•] 0] c ‚Ä¢ m‚ÇÇ) : (mkMetric m‚ÇÅ : OuterMeasure X) ‚â§ c ‚Ä¢ mkMetric m‚ÇÇ ",":= by
  classical
  rcases (mem_nhdsWithin_Ici_iff_exists_Ico_subset' zero_lt_one).1 hle with ‚ü®r, hr0, hr‚ü©
  refine fun s =>
    le_of_tendsto_of_tendsto (mkMetric'.tendsto_pre _ s)
      (ENNReal.Tendsto.const_mul (mkMetric'.tendsto_pre _ s) (Or.inr hc))
      (mem_of_superset (Ioo_mem_nhdsWithin_Ioi ‚ü®le_rfl, hr0‚ü©) fun r' hr' => ?_)
  simp only [mem_setOf_eq, mkMetric'.pre, RingHom.id_apply]
  rw [‚Üê smul_eq_mul, ‚Üê smul_apply, smul_boundedBy hc]
  refine le_boundedBy.2 (fun t => (boundedBy_le _).trans ?_) _
  simp only [smul_eq_mul, Pi.smul_apply, extend, iInf_eq_if]
  split_ifs with ht
  ¬∑ apply hr
    exact ‚ü®zero_le _, ht.trans_lt hr'.2‚ü©
  ¬∑ simp [h0]"
Mathlib/Analysis/Complex/RemovableSingularity.lean,Complex.differentiableOn_compl_singleton_and_continuousAt_iff,differentiableOn_compl_singleton_and_continuousAt_iff,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  refine' ‚ü®_, fun hd => ‚ü®hd.mono (diff_subset _ _), (hd.differentiableAt hs).continuousAt‚ü©‚ü©
  rintro ‚ü®hd, hc‚ü© x hx
  rcases eq_or_ne x c with (rfl | hne)
  ¬∑ refine' (analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt
      _ hc).differentiableAt.differentiableWithinAt
    refine' eventually_nhdsWithin_iff.2 ((eventually_mem_nhds.2 hs).mono fun z hz hzx => _)
    exact hd.differentiableAt (inter_mem hz (isOpen_ne.mem_nhds hzx))
  ¬∑ simpa only [DifferentiableWithinAt, HasFDerivWithinAt, hne.nhdsWithin_diff_singleton] using
      hd x ‚ü®hx, hne‚ü©","error:  function expected at
  diff_subset ?m.3430
term has type
  ?m.3429 ‚àà ?m.3427","theorem differentiableOn_compl_singleton_and_continuousAt_iff {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ} {c : ‚ÑÇ}
    (hs : s ‚àà ùìù c) :
    DifferentiableOn ‚ÑÇ f (s \ {c}) ‚àß ContinuousAt f c ‚Üî DifferentiableOn ‚ÑÇ f s ",":= by
  refine ‚ü®?_, fun hd => ‚ü®hd.mono diff_subset, (hd.differentiableAt hs).continuousAt‚ü©‚ü©
  rintro ‚ü®hd, hc‚ü© x hx
  rcases eq_or_ne x c with (rfl | hne)
  ¬∑ refine (analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt
      ?_ hc).differentiableAt.differentiableWithinAt
    refine eventually_nhdsWithin_iff.2 ((eventually_mem_nhds.2 hs).mono fun z hz hzx => ?_)
    exact hd.differentiableAt (inter_mem hz (isOpen_ne.mem_nhds hzx))
  ¬∑ simpa only [DifferentiableWithinAt, HasFDerivWithinAt, hne.nhdsWithin_diff_singleton] using
      hd x ‚ü®hx, hne‚ü©"
Mathlib/Probability/Distributions/Gaussian.lean,ProbabilityTheory.gaussianReal_map_add_const,gaussianReal_map_add_const,1aadd4f4012334f6f1cd811e685b9c75a27ee9ed,":= by
  by_cases hv : v = 0
  ¬∑ simp only [hv, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.add_const _) _
  let e : ‚Ñù ‚âÉ·µê ‚Ñù := (Homeomorph.addRight y).symm.toMeasurableEquiv
  have he' : ‚àÄ x, HasDerivAt e ((fun _ ‚Ü¶ 1) x) x := fun _ ‚Ü¶ (hasDerivAt_id _).sub_const y
  change (gaussianReal Œº v).map e.symm = gaussianReal (Œº + y) v
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs']
  simp only [abs_neg, abs_one, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, one_mul, ne_eq]
  rw [gaussianReal_apply_eq_integral _ hv hs']
  simp [gaussianPdfReal_sub _ y, Homeomorph.addRight, ‚Üê sub_eq_add_neg]","error:  application type mismatch
  gaussianReal_apply_eq_integral ?m.253953 hv hs'
argument
  hs'
has type
  MeasurableSet s' : Prop
but is expected to have type
  Set ‚Ñù : Type","lemma gaussianReal_map_add_const (y : ‚Ñù) :
    (gaussianReal Œº v).map (¬∑ + y) = gaussianReal (Œº + y) v ",":= by
  by_cases hv : v = 0
  ¬∑ simp only [hv, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.add_const _) _
  let e : ‚Ñù ‚âÉ·µê ‚Ñù := (Homeomorph.addRight y).symm.toMeasurableEquiv
  have he' : ‚àÄ x, HasDerivAt e ((fun _ ‚Ü¶ 1) x) x := fun _ ‚Ü¶ (hasDerivAt_id _).sub_const y
  change (gaussianReal Œº v).map e.symm = gaussianReal (Œº + y) v
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs']
  simp only [abs_neg, abs_one, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, one_mul, ne_eq]
  rw [gaussianReal_apply_eq_integral _ hv s']
  simp [e, gaussianPDFReal_sub _ y, Homeomorph.addRight, ‚Üê sub_eq_add_neg]"
Mathlib/CategoryTheory/Extensive.lean,CategoryTheory.FinitaryPreExtensive.sigma_desc_iso,FinitaryPreExtensive.sigma_desc_iso,e2426ff5dc46051d5747537177e0e66c5dc771e7,":= by
  suffices IsColimit (Cofan.mk _ ((fun _ ‚Ü¶ pullback.fst) : (a : Œ±) ‚Üí pullback f (œÄ a) ‚ü∂ _)) by
    change IsIso (this.coconePointUniqueUpToIso (getColimitCocone _).2).inv
    infer_instance
  let : IsColimit (Cofan.mk X œÄ)
  ¬∑ refine @IsColimit.ofPointIso (t := Cofan.mk X œÄ) (P := coproductIsCoproduct Z) ?_
    convert hœÄ
    simp [coproductIsCoproduct]
  refine (FinitaryPreExtensive.isUniversal_finiteCoproducts this
    (Cofan.mk _ ((fun _ ‚Ü¶ pullback.fst) : (a : Œ±) ‚Üí pullback f (œÄ a) ‚ü∂ _))
    (Discrete.natTrans <| fun i ‚Ü¶ pullback.snd) f ?_
    (NatTrans.equifibered_of_discrete _) ?_).some
  ¬∑ ext
    simp [pullback.condition]
  ¬∑ exact fun j ‚Ü¶ IsPullback.of_hasPullback f (œÄ j.as)","error:  unexpected token ':'; expected '_', identifier or term
error:  unsolved goals
J : Type v'
inst‚úù‚Å¥ : Category.{u', v'} J
C : Type u
inst‚úù¬≥ : Category.{v, u} C
D : Type u''
inst‚úù¬≤ : Category.{v'', u''} D
X‚úù Y‚úù : C
inst‚úù¬π : FinitaryPreExtensive C
Œ± : Type
inst‚úù : Finite Œ±
X : C
Z : Œ± ‚Üí C
œÄ : (a : Œ±) ‚Üí Z a ‚ü∂ X
Y : C
f : Y ‚ü∂ X
hœÄ : IsIso (Sigma.desc œÄ)
‚ä¢ IsColimit (Cofan.mk Y fun x ‚Ü¶ pullback.fst)","lemma FinitaryPreExtensive.sigma_desc_iso [FinitaryPreExtensive C] {Œ± : Type} [Finite Œ±] {X : C}
    {Z : Œ± ‚Üí C} (œÄ : (a : Œ±) ‚Üí Z a ‚ü∂ X) {Y : C} (f : Y ‚ü∂ X) (hœÄ : IsIso (Sigma.desc œÄ)) :
    IsIso (Sigma.desc ((fun _ ‚Ü¶ pullback.fst) : (a : Œ±) ‚Üí pullback f (œÄ a) ‚ü∂ _)) ",":= by
  suffices IsColimit (Cofan.mk _ ((fun _ ‚Ü¶ pullback.fst) : (a : Œ±) ‚Üí pullback f (œÄ a) ‚ü∂ _)) by
    change IsIso (this.coconePointUniqueUpToIso (getColimitCocone _).2).inv
    infer_instance
  let this : IsColimit (Cofan.mk X œÄ) := by
    refine @IsColimit.ofPointIso (t := Cofan.mk X œÄ) (P := coproductIsCoproduct Z) ?_
    convert hœÄ
    simp [coproductIsCoproduct]
  refine (FinitaryPreExtensive.isUniversal_finiteCoproducts this
    (Cofan.mk _ ((fun _ ‚Ü¶ pullback.fst) : (a : Œ±) ‚Üí pullback f (œÄ a) ‚ü∂ _))
    (Discrete.natTrans fun i ‚Ü¶ pullback.snd) f ?_
    (NatTrans.equifibered_of_discrete _) ?_).some
  ¬∑ ext
    simp [pullback.condition]
  ¬∑ exact fun j ‚Ü¶ IsPullback.of_hasPullback f (œÄ j.as)"
Mathlib/Combinatorics/Hall/Finite.lean,HallMarriageTheorem.hall_hard_inductive_step_B,hall_hard_inductive_step_B,9e34a191034458a56331f976ff7400a26407c888,":= by
  haveI := Classical.decEq Œπ
  rw [Nat.add_one] at hn
  have card_Œπ'_le : Fintype.card s ‚â§ n := by
    apply Nat.le_of_lt_succ
    calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card Œπ := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
  let t' : s ‚Üí Finset Œ± := fun x' => t x'
  rcases ih t' card_Œπ'_le (hall_cond_of_restrict ht) with ‚ü®f', hf', hsf'‚ü©
  set Œπ'' := (s : Set Œπ)·∂ú
  let t'' : Œπ'' ‚Üí Finset Œ± := fun a'' => t a'' \ s.biUnion t
  have card_Œπ''_le : Fintype.card Œπ'' ‚â§ n := by
    simp_rw [‚Üê Nat.lt_succ_iff, ‚Üê hn, ‚Üê Finset.coe_compl, coe_sort_coe]
    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]
  rcases ih t'' card_Œπ''_le (hall_cond_of_compl hus ht) with ‚ü®f'', hf'', hsf''‚ü©
  have f'_mem_biUnion : ‚àÄ (x') (hx' : x' ‚àà s), f' ‚ü®x', hx'‚ü© ‚àà s.biUnion t := by
    intro x' hx'
    rw [mem_biUnion]
    exact ‚ü®x', hx', hsf' _‚ü©
  have f''_not_mem_biUnion : ‚àÄ (x'') (hx'' : ¬¨x'' ‚àà s), ¬¨f'' ‚ü®x'', hx''‚ü© ‚àà s.biUnion t := by
    intro x'' hx''
    have h := hsf'' ‚ü®x'', hx''‚ü©
    rw [mem_sdiff] at h
    exact h.2
  have im_disj :
      ‚àÄ (x' x'' : Œπ) (hx' : x' ‚àà s) (hx'' : ¬¨x'' ‚àà s), f' ‚ü®x', hx'‚ü© ‚â† f'' ‚ü®x'', hx''‚ü© := by
    intro x x' hx' hx'' h
    apply f''_not_mem_biUnion x' hx''
    rw [‚Üê h]
    apply f'_mem_biUnion x
  refine' ‚ü®fun x => if h : x ‚àà s then f' ‚ü®x, h‚ü© else f'' ‚ü®x, h‚ü©, _, _‚ü©
  ¬∑ refine' hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)
  ¬∑ intro x
    simp only [of_eq_true]
    split_ifs with h <;> simp
    ¬∑ exact hsf' ‚ü®x, h‚ü©
    ¬∑ exact sdiff_subset _ _ (hsf'' ‚ü®x, h‚ü©)","error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  function expected at
  sdiff_subset ?m.40394
term has type
  ?m.40393 ‚àà ?m.40391","theorem hall_hard_inductive_step_B {n : ‚Ñï} (hn : Fintype.card Œπ = n + 1)
    (ht : ‚àÄ s : Finset Œπ, s.card ‚â§ (s.biUnion t).card)
    (ih :
      ‚àÄ {Œπ' : Type u} [Fintype Œπ'] (t' : Œπ' ‚Üí Finset Œ±),
        Fintype.card Œπ' ‚â§ n ‚Üí
          (‚àÄ s' : Finset Œπ', s'.card ‚â§ (s'.biUnion t').card) ‚Üí
            ‚àÉ f : Œπ' ‚Üí Œ±, Function.Injective f ‚àß ‚àÄ x, f x ‚àà t' x)
    (s : Finset Œπ) (hs : s.Nonempty) (hns : s ‚â† univ) (hus : s.card = (s.biUnion t).card) :
    ‚àÉ f : Œπ ‚Üí Œ±, Function.Injective f ‚àß ‚àÄ x, f x ‚àà t x ",":= by
  haveI := Classical.decEq Œπ
  rw [Nat.add_one] at hn
  have card_Œπ'_le : Fintype.card s ‚â§ n := by
    apply Nat.le_of_lt_succ
    calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card Œπ := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
  let t' : s ‚Üí Finset Œ± := fun x' => t x'
  rcases ih t' card_Œπ'_le (hall_cond_of_restrict ht) with ‚ü®f', hf', hsf'‚ü©
  set Œπ'' := (s : Set Œπ)·∂ú
  let t'' : Œπ'' ‚Üí Finset Œ± := fun a'' => t a'' \ s.biUnion t
  have card_Œπ''_le : Fintype.card Œπ'' ‚â§ n := by
    simp_rw [Œπ'', ‚Üê Nat.lt_succ_iff, ‚Üê hn, ‚Üê Finset.coe_compl, coe_sort_coe]
    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]
  rcases ih t'' card_Œπ''_le (hall_cond_of_compl hus ht) with ‚ü®f'', hf'', hsf''‚ü©
  have f'_mem_biUnion : ‚àÄ (x') (hx' : x' ‚àà s), f' ‚ü®x', hx'‚ü© ‚àà s.biUnion t := by
    intro x' hx'
    rw [mem_biUnion]
    exact ‚ü®x', hx', hsf' _‚ü©
  have f''_not_mem_biUnion : ‚àÄ (x'') (hx'' : ¬¨x'' ‚àà s), ¬¨f'' ‚ü®x'', hx''‚ü© ‚àà s.biUnion t := by
    intro x'' hx''
    have h := hsf'' ‚ü®x'', hx''‚ü©
    rw [mem_sdiff] at h
    exact h.2
  have im_disj :
      ‚àÄ (x' x'' : Œπ) (hx' : x' ‚àà s) (hx'' : ¬¨x'' ‚àà s), f' ‚ü®x', hx'‚ü© ‚â† f'' ‚ü®x'', hx''‚ü© := by
    intro x x' hx' hx'' h
    apply f''_not_mem_biUnion x' hx''
    rw [‚Üê h]
    apply f'_mem_biUnion x
  refine ‚ü®fun x => if h : x ‚àà s then f' ‚ü®x, h‚ü© else f'' ‚ü®x, h‚ü©, ?_, ?_‚ü©
  ¬∑ refine hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)
  ¬∑ intro x
    simp only [of_eq_true]
    split_ifs with h
    ¬∑ exact hsf' ‚ü®x, h‚ü©
    ¬∑ exact sdiff_subset (hsf'' ‚ü®x, h‚ü©)"
Mathlib/Analysis/MellinTransform.lean,mellin_hasDerivAt_of_isBigO_rpow,mellin_hasDerivAt_of_isBigO_rpow,8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85,":= by
  set F : ‚ÑÇ ‚Üí ‚Ñù ‚Üí E := fun (z : ‚ÑÇ) (t : ‚Ñù) => (t : ‚ÑÇ) ^ (z - 1) ‚Ä¢ f t
  set F' : ‚ÑÇ ‚Üí ‚Ñù ‚Üí E := fun (z : ‚ÑÇ) (t : ‚Ñù) => ((t : ‚ÑÇ) ^ (z - 1) * log t) ‚Ä¢ f t
  obtain ‚ü®v, hv0, hv1, hv2‚ü© : ‚àÉ v : ‚Ñù, 0 < v ‚àß v < s.re - b ‚àß v < a - s.re := by
    obtain ‚ü®w, hw1, hw2‚ü© := exists_between (sub_pos.mpr hs_top)
    obtain ‚ü®w', hw1', hw2'‚ü© := exists_between (sub_pos.mpr hs_bot)
    exact
      ‚ü®min w w', lt_min hw1 hw1', (min_le_right _ _).trans_lt hw2', (min_le_left _ _).trans_lt hw2‚ü©
  let bound : ‚Ñù ‚Üí ‚Ñù := fun t : ‚Ñù => (t ^ (s.re + v - 1) + t ^ (s.re - v - 1)) * |log t| * ‚Äñf t‚Äñ
  have h1 : ‚àÄ·∂† z : ‚ÑÇ in ùìù s, AEStronglyMeasurable (F z) (volume.restrict <| Ioi 0) := by
    refine eventually_of_forall fun z => AEStronglyMeasurable.smul ?_ hfc.aestronglyMeasurable
    refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
    refine ContinuousAt.continuousOn fun t ht => ?_
    exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
  have h2 : IntegrableOn (F s) (Ioi (0 : ‚Ñù)) := by
    exact mellinConvergent_of_isBigO_rpow hfc hf_top hs_top hf_bot hs_bot
  have h3 : AEStronglyMeasurable (F' s) (volume.restrict <| Ioi 0) := by
    apply LocallyIntegrableOn.aestronglyMeasurable
    refine hfc.continuousOn_smul isOpen_Ioi ((ContinuousAt.continuousOn fun t ht => ?_).mul ?_)
    ¬∑ exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
    ¬∑ refine continuous_ofReal.comp_continuousOn ?_
      exact continuousOn_log.mono (subset_compl_singleton_iff.mpr not_mem_Ioi_self)
  have h4 : ‚àÄ·µê t : ‚Ñù ‚àÇvolume.restrict (Ioi 0),
      ‚àÄ z : ‚ÑÇ, z ‚àà Metric.ball s v ‚Üí ‚ÄñF' z t‚Äñ ‚â§ bound t := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht z hz => ?_
    simp_rw [F', bound, norm_smul, norm_mul, Complex.norm_eq_abs (log _), Complex.abs_ofReal,
      mul_assoc]
    gcongr
    rw [Complex.norm_eq_abs, abs_cpow_eq_rpow_re_of_pos ht]
    rcases le_or_lt 1 t with h | h
    ¬∑ refine le_add_of_le_of_nonneg (rpow_le_rpow_of_exponent_le h ?_)
        (rpow_nonneg (zero_le_one.trans h) _)
      rw [sub_re, one_re, sub_le_sub_iff_right]
      rw [mem_ball_iff_norm, Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add'] at hz'
    ¬∑ refine
        le_add_of_nonneg_of_le (rpow_pos_of_pos ht _).le (rpow_le_rpow_of_exponent_ge ht h.le ?_)
      rw [sub_re, one_re, sub_le_iff_le_add, sub_add_cancel]
      rw [mem_ball_iff_norm', Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add, ‚Üê sub_le_iff_le_add'] at hz'
  have h5 : IntegrableOn bound (Ioi 0) := by
    simp_rw [bound, add_mul, mul_assoc]
    suffices ‚àÄ {j : ‚Ñù}, b < j ‚Üí j < a ‚Üí
        IntegrableOn (fun t : ‚Ñù => t ^ (j - 1) * (|log t| * ‚Äñf t‚Äñ)) (Ioi 0) volume by
      refine Integrable.add (this ?_ ?_) (this ?_ ?_)
      all_goals linarith
    ¬∑ intro j hj hj'
      obtain ‚ü®w, hw1, hw2‚ü© := exists_between hj
      obtain ‚ü®w', hw1', hw2'‚ü© := exists_between hj'
      refine mellin_convergent_of_isBigO_scalar ?_ ?_ hw1?' _ hw2
      ¬∑ simp_rw [mul_comm]
        refine hfc.norm.mul_continuousOn ?_ isOpen_Ioi
        refine Continuous.comp_continuousOn _root_.continuous_abs (continuousOn_log.mono ?_)
        exact subset_compl_singleton_iff.mpr not_mem_Ioi_self
      ¬∑ refine (isBigO_rpow_top_log_smul hw2' hf_top).norm_left.congr_left fun t ‚Ü¶ ?_
        simp only [norm_smul, Real.norm_eq_abs]
      ¬∑ refine (isBigO_rpow_zero_log_smul hw1 hf_bot).norm_left.congr_left fun t ‚Ü¶ ?_
        simp only [norm_smul, Real.norm_eq_abs]
  have h6 : ‚àÄ·µê t : ‚Ñù ‚àÇvolume.restrict (Ioi 0),
      ‚àÄ y : ‚ÑÇ, y ‚àà Metric.ball s v ‚Üí HasDerivAt (fun z : ‚ÑÇ => F z t) (F' y t) y := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht y _ => ?_
    have ht' : (t : ‚ÑÇ) ‚â† 0 := ofReal_ne_zero.mpr (ne_of_gt ht)
    have u1 : HasDerivAt (fun z : ‚ÑÇ => (t : ‚ÑÇ) ^ (z - 1)) (t ^ (y - 1) * log t) y := by
      convert ((hasDerivAt_id' y).sub_const 1).const_cpow (Or.inl ht') using 1
      rw [ofReal_log (le_of_lt ht)]
      ring
    exact u1.smul_const (f t)
  have main := hasDerivAt_integral_of_dominated_loc_of_deriv_le hv0 h1 h2 h3 h4 h5 h6
  simpa only [F', mul_smul] using main",error:  unknown identifier 'hw1?'',"theorem mellin_hasDerivAt_of_isBigO_rpow [NormedSpace ‚ÑÇ E] {a b : ‚Ñù}
    {f : ‚Ñù ‚Üí E} {s : ‚ÑÇ} (hfc : LocallyIntegrableOn f (Ioi 0)) (hf_top : f =O[atTop] (¬∑ ^ (-a)))
    (hs_top : s.re < a) (hf_bot : f =O[ùìù[>] 0] (¬∑ ^ (-b))) (hs_bot : b < s.re) :
    MellinConvergent (fun t => log t ‚Ä¢ f t) s ‚àß
      HasDerivAt (mellin f) (mellin (fun t => log t ‚Ä¢ f t) s) s ",":= by
  set F : ‚ÑÇ ‚Üí ‚Ñù ‚Üí E := fun (z : ‚ÑÇ) (t : ‚Ñù) => (t : ‚ÑÇ) ^ (z - 1) ‚Ä¢ f t
  set F' : ‚ÑÇ ‚Üí ‚Ñù ‚Üí E := fun (z : ‚ÑÇ) (t : ‚Ñù) => ((t : ‚ÑÇ) ^ (z - 1) * log t) ‚Ä¢ f t
  obtain ‚ü®v, hv0, hv1, hv2‚ü© : ‚àÉ v : ‚Ñù, 0 < v ‚àß v < s.re - b ‚àß v < a - s.re := by
    obtain ‚ü®w, hw1, hw2‚ü© := exists_between (sub_pos.mpr hs_top)
    obtain ‚ü®w', hw1', hw2'‚ü© := exists_between (sub_pos.mpr hs_bot)
    exact
      ‚ü®min w w', lt_min hw1 hw1', (min_le_right _ _).trans_lt hw2', (min_le_left _ _).trans_lt hw2‚ü©
  let bound : ‚Ñù ‚Üí ‚Ñù := fun t : ‚Ñù => (t ^ (s.re + v - 1) + t ^ (s.re - v - 1)) * |log t| * ‚Äñf t‚Äñ
  have h1 : ‚àÄ·∂† z : ‚ÑÇ in ùìù s, AEStronglyMeasurable (F z) (volume.restrict <| Ioi 0) := by
    refine eventually_of_forall fun z => AEStronglyMeasurable.smul ?_ hfc.aestronglyMeasurable
    refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
    refine ContinuousAt.continuousOn fun t ht => ?_
    exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
  have h2 : IntegrableOn (F s) (Ioi (0 : ‚Ñù)) := by
    exact mellinConvergent_of_isBigO_rpow hfc hf_top hs_top hf_bot hs_bot
  have h3 : AEStronglyMeasurable (F' s) (volume.restrict <| Ioi 0) := by
    apply LocallyIntegrableOn.aestronglyMeasurable
    refine hfc.continuousOn_smul isOpen_Ioi ((ContinuousAt.continuousOn fun t ht => ?_).mul ?_)
    ¬∑ exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
    ¬∑ refine continuous_ofReal.comp_continuousOn ?_
      exact continuousOn_log.mono (subset_compl_singleton_iff.mpr not_mem_Ioi_self)
  have h4 : ‚àÄ·µê t : ‚Ñù ‚àÇvolume.restrict (Ioi 0),
      ‚àÄ z : ‚ÑÇ, z ‚àà Metric.ball s v ‚Üí ‚ÄñF' z t‚Äñ ‚â§ bound t := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht z hz => ?_
    simp_rw [F', bound, norm_smul, norm_mul, Complex.norm_eq_abs (log _), Complex.abs_ofReal,
      mul_assoc]
    gcongr
    rw [Complex.norm_eq_abs, abs_cpow_eq_rpow_re_of_pos ht]
    rcases le_or_lt 1 t with h | h
    ¬∑ refine le_add_of_le_of_nonneg (rpow_le_rpow_of_exponent_le h ?_)
        (rpow_nonneg (zero_le_one.trans h) _)
      rw [sub_re, one_re, sub_le_sub_iff_right]
      rw [mem_ball_iff_norm, Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add'] at hz'
    ¬∑ refine
        le_add_of_nonneg_of_le (rpow_pos_of_pos ht _).le (rpow_le_rpow_of_exponent_ge ht h.le ?_)
      rw [sub_re, one_re, sub_le_iff_le_add, sub_add_cancel]
      rw [mem_ball_iff_norm', Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add, ‚Üê sub_le_iff_le_add'] at hz'
  have h5 : IntegrableOn bound (Ioi 0) := by
    simp_rw [bound, add_mul, mul_assoc]
    suffices ‚àÄ {j : ‚Ñù}, b < j ‚Üí j < a ‚Üí
        IntegrableOn (fun t : ‚Ñù => t ^ (j - 1) * (|log t| * ‚Äñf t‚Äñ)) (Ioi 0) volume by
      refine Integrable.add (this ?_ ?_) (this ?_ ?_)
      all_goals linarith
    ¬∑ intro j hj hj'
      obtain ‚ü®w, hw1, hw2‚ü© := exists_between hj
      obtain ‚ü®w', hw1', hw2'‚ü© := exists_between hj'
      refine mellin_convergent_of_isBigO_scalar ?_ ?_ hw1' ?_ hw2
      ¬∑ simp_rw [mul_comm]
        refine hfc.norm.mul_continuousOn ?_ isOpen_Ioi
        refine Continuous.comp_continuousOn _root_.continuous_abs (continuousOn_log.mono ?_)
        exact subset_compl_singleton_iff.mpr not_mem_Ioi_self
      ¬∑ refine (isBigO_rpow_top_log_smul hw2' hf_top).norm_left.congr_left fun t ‚Ü¶ ?_
        simp only [norm_smul, Real.norm_eq_abs]
      ¬∑ refine (isBigO_rpow_zero_log_smul hw1 hf_bot).norm_left.congr_left fun t ‚Ü¶ ?_
        simp only [norm_smul, Real.norm_eq_abs]
  have h6 : ‚àÄ·µê t : ‚Ñù ‚àÇvolume.restrict (Ioi 0),
      ‚àÄ y : ‚ÑÇ, y ‚àà Metric.ball s v ‚Üí HasDerivAt (fun z : ‚ÑÇ => F z t) (F' y t) y := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht y _ => ?_
    have ht' : (t : ‚ÑÇ) ‚â† 0 := ofReal_ne_zero.mpr (ne_of_gt ht)
    have u1 : HasDerivAt (fun z : ‚ÑÇ => (t : ‚ÑÇ) ^ (z - 1)) (t ^ (y - 1) * log t) y := by
      convert ((hasDerivAt_id' y).sub_const 1).const_cpow (Or.inl ht') using 1
      rw [ofReal_log (le_of_lt ht)]
      ring
    exact u1.smul_const (f t)
  have main := hasDerivAt_integral_of_dominated_loc_of_deriv_le hv0 h1 h2 h3 h4 h5 h6
  simpa only [F', mul_smul] using main"
Mathlib/Geometry/Manifold/ContMDiffMFDeriv.lean,TangentBundle.tangentMap_tangentBundle_pure,tangentMap_tangentBundle_pure,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  rcases p with ‚ü®x, v‚ü©
  have N : I.symm ‚Åª¬π' (chartAt H x).target ‚àà ùìù (I ((chartAt H x) x)) := by
    apply IsOpen.mem_nhds
    apply (LocalHomeomorph.open_target _).preimage I.continuous_invFun
    simp only [mfld_simps]
  have A : MDifferentiableAt I I.tangent (fun x => @TotalSpace.mk M E (TangentSpace I) x 0) x :=
    haveI : Smooth I (I.prod ùìò(ùïú, E)) (zeroSection E (TangentSpace I : M ‚Üí Type _)) :=
      Bundle.smooth_zeroSection ùïú (TangentSpace I : M ‚Üí Type _)
    this.mdifferentiableAt
  have B :
    fderivWithin ùïú (fun x' : E => (x', (0 : E))) (Set.range I) (I ((chartAt H x) x)) v = (v, 0)
  ¬∑ rw [fderivWithin_eq_fderiv, DifferentiableAt.fderiv_prod]
    ¬∑ simp
    ¬∑ exact differentiableAt_id'
    ¬∑ exact differentiableAt_const _
    ¬∑ exact ModelWithCorners.unique_diff_at_image I
    ¬∑ exact differentiableAt_id'.prod (differentiableAt_const _)
  simp (config := { unfoldPartialApp := true }) only [Bundle.zeroSection, tangentMap, mfderiv, A,
    if_pos, chartAt, FiberBundle.chartedSpace_chartAt, TangentBundle.trivializationAt_apply,
    tangentBundleCore, Function.comp_def, ContinuousLinearMap.map_zero, mfld_simps]
  rw [‚Üê fderivWithin_inter N] at B
  rw [‚Üê fderivWithin_inter N, ‚Üê B]
  congr 1
  refine' fderivWithin_congr (fun y hy => _) _
  ¬∑ simp only [mfld_simps] at hy
    simp only [hy, Prod.mk.inj_iff, mfld_simps]
  ¬∑ simp only [Prod.mk.inj_iff, mfld_simps]","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case mk
ùïú : Type u_1
inst‚úù¬≤‚Å¥ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬≤¬≥ : NormedAddCommGroup E
inst‚úù¬≤¬≤ : NormedSpace ùïú E
H : Type u_3
inst‚úù¬≤¬π : TopologicalSpace H
I : ModelWithCorners ùïú E H
M : Type u_4
inst‚úù¬≤‚Å∞ : TopologicalSpace M
inst‚úù¬π‚Åπ : ChartedSpace H M
Is : SmoothManifoldWithCorners I M
E' : Type u_5
inst‚úù¬π‚Å∏ : NormedAddCommGroup E'
inst‚úù¬π‚Å∑ : NormedSpace ùïú E'
H' : Type u_6
inst‚úù¬π‚Å∂ : TopologicalSpace H'
I' : ModelWithCorners ùïú E' H'
M' : Type u_7
inst‚úù¬π‚Åµ : TopologicalSpace M'
inst‚úù¬π‚Å¥ : ChartedSpace H' M'
I's : SmoothManifoldWithCorners I' M'
F : Type u_8
inst‚úù¬π¬≥ : NormedAddCommGroup F
inst‚úù¬π¬≤ : NormedSpace ùïú F
G : Type u_9
inst‚úù¬π¬π : TopologicalSpace G
J : ModelWithCorners ùïú F G
N‚úù : Type u_10
inst‚úù¬π‚Å∞ : TopologicalSpace N‚úù
inst‚úù‚Åπ : ChartedSpace G N‚úù
Js : SmoothManifoldWithCorners J N‚úù
F' : Type u_11
inst‚úù‚Å∏ : NormedAddCommGroup F'
inst‚úù‚Å∑ : NormedSpace ùïú F'
G' : Type u_12
inst‚úù‚Å∂ : TopologicalSpace G'
J' : ModelWithCorners ùïú F' G'
N' : Type u_13
inst‚úù‚Åµ : TopologicalSpace N'
inst‚úù‚Å¥ : ChartedSpace G' N'
J's : SmoothManifoldWithCorners J' N'
F‚ÇÅ : Type u_14
inst‚úù¬≥ : NormedAddCommGroup F‚ÇÅ
inst‚úù¬≤ : NormedSpace ùïú F‚ÇÅ
F‚ÇÇ : Type u_15
inst‚úù¬π : NormedAddCommGroup F‚ÇÇ
inst‚úù : NormedSpace ùïú F‚ÇÇ
f f‚ÇÅ : M ‚Üí M'
s s‚ÇÅ t : Set M
x‚úù : M
m n : ‚Ñï‚àû
x : M
v : TangentSpace I x
N : ‚ÜëI.symm ‚Åª¬π' (chartAt H x).target ‚àà ùìù (‚ÜëI (‚Üë(chartAt H x) x))
A : MDifferentiableAt I I.tangent (fun x ‚Ü¶ { proj := x, snd := 0 }) x
B : (fderivWithin ùïú (fun x' ‚Ü¶ (x', 0)) (range ‚ÜëI) (‚ÜëI (‚Üë(chartAt H x) x))) v = (v, 0)
‚ä¢ tangentMap I I.tangent (zeroSection E (TangentSpace I)) { proj := x, snd := v } =
    { proj := { proj := { proj := x, snd := v }.proj, snd := 0 }, snd := ({ proj := x, snd := v }.snd, 0) }","theorem tangentMap_tangentBundle_pure (p : TangentBundle I M) :
    tangentMap I I.tangent (zeroSection E (TangentSpace I)) p = ‚ü®‚ü®p.proj, 0‚ü©, ‚ü®p.2, 0‚ü©‚ü© ",":= by
  rcases p with ‚ü®x, v‚ü©
  have N : I.symm ‚Åª¬π' (chartAt H x).target ‚àà ùìù (I ((chartAt H x) x)) := by
    apply IsOpen.mem_nhds
    ¬∑ apply (PartialHomeomorph.open_target _).preimage I.continuous_invFun
    ¬∑ simp only [mfld_simps]
  have A : MDifferentiableAt I I.tangent (fun x => @TotalSpace.mk M E (TangentSpace I) x 0) x :=
    haveI : Smooth I (I.prod ùìò(ùïú, E)) (zeroSection E (TangentSpace I : M ‚Üí Type _)) :=
      Bundle.smooth_zeroSection ùïú (TangentSpace I : M ‚Üí Type _)
    this.mdifferentiableAt
  have B : fderivWithin ùïú (fun x' : E ‚Ü¶ (x', (0 : E))) (Set.range I) (I ((chartAt H x) x)) v
      = (v, 0) := by
    rw [fderivWithin_eq_fderiv, DifferentiableAt.fderiv_prod]
    ¬∑ simp
    ¬∑ exact differentiableAt_id'
    ¬∑ exact differentiableAt_const _
    ¬∑ exact ModelWithCorners.unique_diff_at_image I
    ¬∑ exact differentiableAt_id'.prod (differentiableAt_const _)
  simp (config := { unfoldPartialApp := true }) only [Bundle.zeroSection, tangentMap, mfderiv, A,
    if_pos, chartAt, FiberBundle.chartedSpace_chartAt, TangentBundle.trivializationAt_apply,
    tangentBundleCore, Function.comp_def, ContinuousLinearMap.map_zero, mfld_simps]
  rw [‚Üê fderivWithin_inter N] at B
  rw [‚Üê fderivWithin_inter N, ‚Üê B]
  congr 1
  refine fderivWithin_congr (fun y hy => ?_) ?_
  ¬∑ simp only [mfld_simps] at hy
    simp only [hy, Prod.mk.inj_iff, mfld_simps]
  ¬∑ simp only [Prod.mk.inj_iff, mfld_simps]"
Mathlib/Data/Set/Card.lean,Set.encard_diff_add_encard_inter,encard_diff_add_encard_inter,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [‚Üê encard_union_eq (disjoint_of_subset_right (inter_subset_right _ _) disjoint_sdiff_left),
    diff_union_inter]","error:  function expected at
  inter_subset_right ?m.18331
term has type
  ?m.18330 ‚àà ?m.18329","theorem encard_diff_add_encard_inter (s t : Set Œ±) :
    (s \ t).encard + (s ‚à© t).encard = s.encard ",":= by
  rw [‚Üê encard_union_eq (disjoint_of_subset_right inter_subset_right disjoint_sdiff_left),
    diff_union_inter]"
Mathlib/Data/Nat/Cast/Basic.lean,ext_nat'',ext_nat'',01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  apply FunLike.ext
  rintro (_ | n)
  ¬∑ simp [map_zero f, map_zero g]
  ¬∑ exact h_pos n.succ_pos",error:  unknown constant 'FunLike.ext',"theorem ext_nat'' [MonoidWithZeroHomClass F ‚Ñï A] (f g : F) (h_pos : ‚àÄ {n : ‚Ñï}, 0 < n ‚Üí f n = g n) :
    f = g ",":= by
  apply DFunLike.ext
  rintro (_ | n)
  ¬∑ simp [map_zero f, map_zero g]
  ¬∑ exact h_pos n.succ_pos"
Mathlib/Data/Num/Lemmas.lean,Num.cast_to_nat,cast_to_nat,fc94d7cf19de72da26bfb583fdb140d8737abb30,"  | 1 => Nat.cast_one
  | bit0 p => by simp [cast_to_nat p]
  | bit1 p => by simp [cast_to_nat p]","warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
error:  unsolved goals
Œ± : Type u_1
inst‚úù : AddMonoidWithOne Œ±
p : PosNum
‚ä¢ ‚Üë(_root_.bit0 ‚Üëp) = _root_.bit0 ‚Üëp
error:  unsolved goals
Œ± : Type u_1
inst‚úù : AddMonoidWithOne Œ±
p : PosNum
‚ä¢ ‚Üë(_root_.bit1 ‚Üëp) = _root_.bit1 ‚Üëp
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `castNum` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated","theorem cast_to_nat [AddMonoidWithOne Œ±] : ‚àÄ n : PosNum, ((n : ‚Ñï) : Œ±) = n
","  | 1 => Nat.cast_one
  | bit0 p => (Nat.cast_bit0 _).trans <| congr_arg _root_.bit0 p.cast_to_nat
  | bit1 p => (Nat.cast_bit1 _).trans <| congr_arg _root_.bit1 p.cast_to_nat"
Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean,hasDerivAt_ofReal_cpow,hasDerivAt_ofReal_cpow,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  rw [Ne.def, ‚Üê add_eq_zero_iff_eq_neg, ‚Üê Ne.def] at hr
  rcases lt_or_gt_of_ne hx.symm with (hx | hx)
  ¬∑ 
    apply HasDerivAt.comp_ofReal (e := fun y => (y : ‚ÑÇ) ^ (r + 1) / (r + 1))
    convert HasDerivAt.div_const (ùïú := ‚ÑÇ) ?_ (r + 1) using 1
    ¬∑ exact (mul_div_cancel _ hr).symm
    ¬∑ convert HasDerivAt.cpow_const ?_ ?_ using 1
      ¬∑ rw [add_sub_cancel, mul_comm]; exact (mul_one _).symm
      ¬∑ exact hasDerivAt_id (x : ‚ÑÇ)
      ¬∑ simp [hx]
  ¬∑ 
    have : ‚àÄ·∂† y : ‚Ñù in nhds x,
        (y : ‚ÑÇ) ^ (r + 1) / (r + 1) = (-y : ‚ÑÇ) ^ (r + 1) * exp (œÄ * I * (r + 1)) / (r + 1) := by
      refine' Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => _
      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]
    refine' HasDerivAt.congr_of_eventuallyEq _ this
    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]
    suffices HasDerivAt (fun y : ‚Ñù => (-‚Üëy) ^ (r + 1) * exp (‚ÜëœÄ * I * (r + 1)))
        ((r + 1) * (-‚Üëx) ^ r * exp (‚ÜëœÄ * I * r)) x by
      convert this.div_const (r + 1) using 1
      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel _ hr]
    rw [mul_add ((œÄ : ‚ÑÇ) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : ‚ÑÇ) (-1 : ‚ÑÇ),
      neg_one_mul]
    simp_rw [mul_neg, ‚Üê neg_mul, ‚Üê ofReal_neg]
    suffices HasDerivAt (fun y : ‚Ñù => ‚Üë(-y) ^ (r + 1)) (-(r + 1) * ‚Üë(-x) ^ r) x by
      convert this.neg.mul_const _ using 1; ring
    suffices HasDerivAt (fun y : ‚Ñù => ‚Üëy ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) (-x) by
      convert @HasDerivAt.scomp ‚Ñù _ ‚ÑÇ _ _ x ‚Ñù _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1
      rw [real_smul, ofReal_neg 1, ofReal_one]; ring
    suffices HasDerivAt (fun y : ‚ÑÇ => y ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) ‚Üë(-x) by
      exact this.comp_ofReal
    conv in ‚Üë_ ^ _ => rw [(by ring : r = r + 1 - 1)]
    convert HasDerivAt.cpow_const ?_ ?_ using 1
    ¬∑ rw [add_sub_cancel, add_sub_cancel]; exact (mul_one _).symm
    ¬∑ exact hasDerivAt_id ((-x : ‚Ñù) : ‚ÑÇ)
    ¬∑ simp [hx]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.106391 ‚Üí ?m.106391 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.106393
f g : ‚ÑÇ ‚Üí ‚ÑÇ
s : Set ‚ÑÇ
f' g' x‚úù c : ‚ÑÇ
x : ‚Ñù
hx : x ‚â† 0
r : ‚ÑÇ
hr : r ‚â† -1
‚ä¢ HasDerivAt (fun y ‚Ü¶ ‚Üëy ^ (r + 1) / (r + 1)) (‚Üëx ^ r) x","theorem hasDerivAt_ofReal_cpow {x : ‚Ñù} (hx : x ‚â† 0) {r : ‚ÑÇ} (hr : r ‚â† -1) :
    HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ (r + 1) / (r + 1)) (x ^ r) x ",":= by
  rw [Ne, ‚Üê add_eq_zero_iff_eq_neg, ‚Üê Ne] at hr
  rcases lt_or_gt_of_ne hx.symm with (hx | hx)
  ¬∑ 
    apply HasDerivAt.comp_ofReal (e := fun y => (y : ‚ÑÇ) ^ (r + 1) / (r + 1))
    convert HasDerivAt.div_const (ùïú := ‚ÑÇ) ?_ (r + 1) using 1
    ¬∑ exact (mul_div_cancel_right‚ÇÄ _ hr).symm
    ¬∑ convert HasDerivAt.cpow_const ?_ ?_ using 1
      ¬∑ rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm
      ¬∑ exact hasDerivAt_id (x : ‚ÑÇ)
      ¬∑ simp [hx]
  ¬∑ 
    have : ‚àÄ·∂† y : ‚Ñù in ùìù x,
        (y : ‚ÑÇ) ^ (r + 1) / (r + 1) = (-y : ‚ÑÇ) ^ (r + 1) * exp (œÄ * I * (r + 1)) / (r + 1) := by
      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_
      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]
    refine HasDerivAt.congr_of_eventuallyEq ?_ this
    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]
    suffices HasDerivAt (fun y : ‚Ñù => (-‚Üëy) ^ (r + 1) * exp (‚ÜëœÄ * I * (r + 1)))
        ((r + 1) * (-‚Üëx) ^ r * exp (‚ÜëœÄ * I * r)) x by
      convert this.div_const (r + 1) using 1
      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right‚ÇÄ _ hr]
    rw [mul_add ((œÄ : ‚ÑÇ) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : ‚ÑÇ) (-1 : ‚ÑÇ),
      neg_one_mul]
    simp_rw [mul_neg, ‚Üê neg_mul, ‚Üê ofReal_neg]
    suffices HasDerivAt (fun y : ‚Ñù => (‚Üë(-y) : ‚ÑÇ) ^ (r + 1)) (-(r + 1) * ‚Üë(-x) ^ r) x by
      convert this.neg.mul_const _ using 1; ring
    suffices HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) (-x) by
      convert @HasDerivAt.scomp ‚Ñù _ ‚ÑÇ _ _ x ‚Ñù _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1
      rw [real_smul, ofReal_neg 1, ofReal_one]; ring
    suffices HasDerivAt (fun y : ‚ÑÇ => y ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) ‚Üë(-x) by
      exact this.comp_ofReal
    conv in ‚Üë_ ^ _ => rw [(by ring : r = r + 1 - 1)]
    convert HasDerivAt.cpow_const ?_ ?_ using 1
    ¬∑ rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm
    ¬∑ exact hasDerivAt_id ((-x : ‚Ñù) : ‚ÑÇ)
    ¬∑ simp [hx]"
Mathlib/RingTheory/Adjoin/Basic.lean,Algebra.adjoin_algebraMap_image_union_eq_adjoin_adjoin,adjoin_algebraMap_image_union_eq_adjoin_adjoin,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  le_antisymm
    (closure_mono <|
      Set.union_subset (Set.range_subset_iff.2 fun r => Or.inl ‚ü®algebraMap R (adjoin R s) r,
        (IsScalarTower.algebraMap_apply _ _ _ _).symm‚ü©)
        (Set.union_subset_union_left _ fun _ ‚ü®_x, hx, hxs‚ü© => hxs ‚ñ∏ ‚ü®‚ü®_, subset_adjoin hx‚ü©, rfl‚ü©))
    (closure_le.2 <|
      Set.union_subset (Set.range_subset_iff.2 fun x => adjoin_mono (Set.subset_union_left _ _) <|
        Algebra.adjoin_algebraMap R A s ‚ñ∏ ‚ü®x, x.prop, rfl‚ü©)
        (Set.Subset.trans (Set.subset_union_right _ _) subset_adjoin))","error:  function expected at
  Set.subset_union_left ?m.103321
term has type
  ?m.103320 ‚àà ?m.103318 ‚à™ ?m.103319
error:  function expected at
  Set.subset_union_right ?m.103526
term has type
  ?m.103525 ‚àà ?m.103523 ‚à™ ?m.103524
error:  invalid constructor ‚ü®...‚ü©, expected type must be known
error:  invalid `‚ñ∏` notation, the equality
  adjoin_algebraMap R A s
has type 
  adjoin R (‚áë(algebraMap S A) '' s) = Subalgebra.map (IsScalarTower.toAlgHom R S A) (adjoin R s)
but neither side of the equality is mentioned in the type
  ?m.103806","theorem adjoin_algebraMap_image_union_eq_adjoin_adjoin (s : Set S) (t : Set A) :
    adjoin R (algebraMap S A '' s ‚à™ t) = (adjoin (adjoin R s) t).restrictScalars R ",":=
  le_antisymm
    (closure_mono <|
      Set.union_subset (Set.range_subset_iff.2 fun r => Or.inl ‚ü®algebraMap R (adjoin R s) r,
        (IsScalarTower.algebraMap_apply _ _ _ _).symm‚ü©)
        (Set.union_subset_union_left _ fun _ ‚ü®_x, hx, hxs‚ü© => hxs ‚ñ∏ ‚ü®‚ü®_, subset_adjoin hx‚ü©, rfl‚ü©))
    (closure_le.2 <|
      Set.union_subset (Set.range_subset_iff.2 fun x => adjoin_mono Set.subset_union_left <|
        Algebra.adjoin_algebraMap R A s ‚ñ∏ ‚ü®x, x.prop, rfl‚ü©)
        (Set.Subset.trans Set.subset_union_right subset_adjoin))"
Mathlib/Order/Partition/Finpartition.lean,Finpartition.mem_part_ofSetoid_iff_rel,mem_part_ofSetoid_iff_rel,ca263f4356a58c37b84beae902ab555c06685291,":= by
  simp_rw [part, ofSetoid, mem_univ, reduceDite]
  generalize_proofs H
  have := choose_spec _ _ H
  simp only [mem_univ, mem_image, true_and] at this
  obtain ‚ü®‚ü®_, hc‚ü©, this‚ü© := this
  simp only [‚Üê hc, mem_univ, mem_filter, true_and] at this ‚ä¢
  exact ‚ü®s.trans (s.symm this), s.trans this‚ü©","error:  unknown identifier 'reduceDite'
error:  simp made no progress","theorem mem_part_ofSetoid_iff_rel {s : Setoid Œ±} [DecidableRel s.r] {b : Œ±} :
    b ‚àà (ofSetoid s).part a ‚Üî s.r a b ",":= by
  simp_rw [part, ofSetoid, mem_univ, reduceDIte]
  generalize_proofs H
  have := choose_spec _ _ H
  simp only [mem_univ, mem_image, true_and] at this
  obtain ‚ü®‚ü®_, hc‚ü©, this‚ü© := this
  simp only [‚Üê hc, mem_univ, mem_filter, true_and] at this ‚ä¢
  exact ‚ü®s.trans (s.symm this), s.trans this‚ü©"
Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean,WeierstrassCurve.Jacobian.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,b61d88996d9475f4d18f0450a09885659a4e5a41,":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp [nonsingular_iff, equation_iff] at hP hQ
  have hPx : P x ‚â† 0 := fun h => by simp [h] at hP; simp [hP] at hP
  have hQx : Q x ‚â† 0 := fun h => by simp [h] at hQ; simp [hQ] at hQ
  have hPy : P y ‚â† 0 := fun h => by simp [h] at hP; exact hPx <| pow_eq_zero hP.left.symm
  have hQy : Q y ‚â† 0 := fun h => by simp [h] at hQ; exact hQx <| pow_eq_zero hQ.left.symm
  use Units.mk0 _ <| mul_ne_zero (div_ne_zero hPy hPx) (div_ne_zero hQx hQy)
  simp? [smul_fin3, mul_pow, div_pow] says
    simp only [Fin.isValue, Units.mk0_mul, smul_fin3, Units.val_mul, Units.val_mk0,
      mul_pow, div_pow, Matrix.cons_val_zero, Matrix.cons_val_one, Matrix.head_cons,
      Matrix.cons_val_two, Matrix.tail_cons, ‚Üìmul_zero]
  congr! 2
  ¬∑ field_simp [hP.left, hQ.left]
    ring1
  ¬∑ field_simp [‚Üê hP.left, ‚Üê hQ.left]
    ring1","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ![P x, P y, P z]
R : Type u
inst‚úù¬π : CommRing R
W' : Jacobian R
F : Type v
inst‚úù : Field F
W : Jacobian F
P Q : Fin 3 ‚Üí F
hP : W.Nonsingular P
hQ : W.Nonsingular Q
hPz : P z = 0
hQz : Q z = 0
‚ä¢ P ‚âà Q","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  have hPx : IsUnit <| P x := isUnit_X_of_Z_eq_zero hP hPz
  have hPy : IsUnit <| P y := isUnit_Y_of_Z_eq_zero hP hPz
  have hQx : IsUnit <| Q x := isUnit_X_of_Z_eq_zero hQ hQz
  have hQy : IsUnit <| Q y := isUnit_Y_of_Z_eq_zero hQ hQz
  simp only [nonsingular_of_Z_eq_zero, equation_of_Z_eq_zero, hPz, hQz] at hP hQ
  use (hPy.unit / hPx.unit) * (hQx.unit / hQy.unit)
  simp only [Units.smul_def, smul_fin3, Units.val_mul, Units.val_div_eq_div_val, IsUnit.unit_spec,
    mul_pow, div_pow, hQz, mul_zero]
  conv_rhs => rw [‚Üê fin3_def P, hPz]
  congr! 2
  ¬∑ rw [hP.left, pow_succ, (hPx.pow 2).mul_div_cancel_left, hQ.left, pow_succ _ 2,
      (hQx.pow 2).div_mul_cancel_left, hQx.inv_mul_cancel_right]
  ¬∑ rw [‚Üê hP.left, pow_succ, (hPy.pow 2).mul_div_cancel_left, ‚Üê hQ.left, pow_succ _ 2,
      (hQy.pow 2).div_mul_cancel_left, hQy.inv_mul_cancel_right]"
Mathlib/LinearAlgebra/TensorProduct/Submodule.lean,Submodule.comm_trans_rTensorOne,comm_trans_rTensorOne,6476f50fd255f9405ed097d5642d2a495a30b7ec,":= by
  refine LinearEquiv.toLinearMap_injective <| TensorProduct.ext' fun  ‚ü®m, hm‚ü© x ‚Ü¶ ?_
  obtain ‚ü®y, rfl‚ü© := mem_one.1 hm
  simp","error:  unsolved goals
case intro
R : Type u
S : Type v
inst‚úù¬≤ : CommSemiring R
inst‚úù¬π : Semiring S
inst‚úù : Algebra R S
M N : Submodule R S
x‚úù : ‚Ü•‚ä•
x : ‚Ü•M
y : R
hm : (algebraMap R S) y ‚àà ‚ä•
‚ä¢ M.rTensorOne (x ‚äó‚Çú[R] ‚ü®(algebraMap R S) y, hm‚ü©) = M.lTensorOne (‚ü®(algebraMap R S) y, hm‚ü© ‚äó‚Çú[R] x)","theorem comm_trans_rTensorOne :
    (TensorProduct.comm R _ _).trans M.rTensorOne = M.lTensorOne ",":= by
  refine LinearEquiv.toLinearMap_injective <| TensorProduct.ext' fun r m ‚Ü¶ ?_
  obtain ‚ü®x, h‚ü© := Algebra.mem_bot.1 r.2
  replace h : algebraMap R _ x = r := Subtype.val_injective h
  rw [‚Üê h]; simp"
Mathlib/Analysis/Seminorm.lean,Seminorm.closedBall_finset_sup',closedBall_finset_sup',dee5d9343d596781e8ec7749927ce52e2d12df27,":= by
  induction H using Finset.Nonempty.cons_induction with
  | singleton => simp
  | cons _ _ hs ih =>
    rw [Finset.sup'_cons hs, Finset.inf'_cons hs, closedBall_sup]
    simp only [inf_eq_inter, ih]","error:  application type mismatch
  Finset.sup'_cons hs
argument
  hs
has type
  a‚úù¬π ‚àâ s‚úù : Prop
but is expected to have type
  ?m.581016.Nonempty : Prop
error:  application type mismatch
  Finset.inf'_cons hs
argument
  hs
has type
  a‚úù¬π ‚àâ s‚úù : Prop
but is expected to have type
  ?m.581364.Nonempty : Prop
error:  unsolved goals
case cons
R : Type u_1
R' : Type u_2
ùïú : Type u_3
ùïú‚ÇÇ : Type u_4
ùïú‚ÇÉ : Type u_5
ùïù : Type u_6
E : Type u_7
E‚ÇÇ : Type u_8
E‚ÇÉ : Type u_9
F : Type u_10
G : Type u_11
Œπ : Type u_12
inst‚úù¬≤ : SeminormedRing ùïú
inst‚úù¬π : AddCommGroup E
inst‚úù : SMul ùïú E
p‚úù : Seminorm ùïú E
x y : E
r‚úù : ‚Ñù
p : Œπ ‚Üí Seminorm ùïú E
s : Finset Œπ
e : E
r : ‚Ñù
a‚úù¬π : Œπ
s‚úù : Finset Œπ
hs : a‚úù¬π ‚àâ s‚úù
ih : s‚úù.Nonempty
a‚úù : (s‚úù.sup' ih p).closedBall e r = s‚úù.inf' ih fun i ‚Ü¶ (p i).closedBall e r
‚ä¢ (p a‚úù¬π).closedBall e r ‚à© (s‚úù.sup' ‚ãØ p).closedBall e r =
    (p a‚úù¬π).closedBall e r ‚à© s‚úù.inf' ‚ãØ fun i ‚Ü¶ (p i).closedBall e r","theorem closedBall_finset_sup' (p : Œπ ‚Üí Seminorm ùïú E) (s : Finset Œπ) (H : s.Nonempty) (e : E)
    (r : ‚Ñù) : closedBall (s.sup' H p) e r = s.inf' H fun i => closedBall (p i) e r ",":= by
  induction H using Finset.Nonempty.cons_induction with
  | singleton => simp
  | cons _ _ _ hs ih =>
    rw [Finset.sup'_cons hs, Finset.inf'_cons hs, closedBall_sup]
    simp only [inf_eq_inter, ih]"
Mathlib/Data/Set/Basic.lean,Set.subset_union_of_subset_left,subset_union_of_subset_left,70dcc1355b9ce0a6754f8d809c95a171072d3aac,":=
  Subset.trans h (subset_union_left t u)","error:  application type mismatch
  subset_union_left t
argument
  t
has type
  Set Œ± : Type u
but is expected to have type
  ?m.30852 ‚àà ?m.30850 : Prop",theorem subset_union_of_subset_left {s t : Set Œ±} (h : s ‚äÜ t) (u : Set Œ±) : s ‚äÜ t ‚à™ u ,":=
  h.trans subset_union_left"
Mathlib/Topology/FiberBundle/Basic.lean,FiberBundle.exists_trivialization_Icc_subset,FiberBundle.exists_trivialization_Icc_subset,5192777c94aec06289e492ce206d68fbbe72572c,":= by
  obtain ‚ü®ea, hea‚ü© : ‚àÉ ea : Trivialization F (œÄ F E), a ‚àà ea.baseSet :=
    ‚ü®trivializationAt F E a, mem_baseSet_trivializationAt F E a‚ü©
  cases' lt_or_le b a with hab hab
  ¬∑ exact ‚ü®ea, by simp [*]‚ü©
  set s : Set B := { x ‚àà Icc a b | ‚àÉ e : Trivialization F (œÄ F E), Icc a x ‚äÜ e.baseSet }
  have ha : a ‚àà s := ‚ü®left_mem_Icc.2 hab, ea, by simp [hea]‚ü©
  have sne : s.Nonempty := ‚ü®a, ha‚ü©
  have hsb : b ‚àà upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := ‚ü®b, hsb‚ü©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c ‚àà Icc a b := ‚ü®hsc.1 ha, hsc.2 hsb‚ü©
  obtain ‚ü®-, ec : Trivialization F (œÄ F E), hec : Icc a c ‚äÜ ec.baseSet‚ü© : c ‚àà s := by
    rcases hc.1.eq_or_lt with heq | hlt
    ¬∑ rwa [‚Üê heq]
    refine ‚ü®hc, ?_‚ü©
    obtain ‚ü®ec, hc‚ü© : ‚àÉ ec : Trivialization F (œÄ F E), c ‚àà ec.baseSet :=
      ‚ü®trivializationAt F E c, mem_baseSet_trivializationAt F E c‚ü©
    obtain ‚ü®c', hc', hc'e‚ü© : ‚àÉ c' ‚àà Ico a c, Ioc c' c ‚äÜ ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain ‚ü®d, ‚ü®hdab, ead, had‚ü©, hd‚ü© : ‚àÉ d ‚àà s, d ‚àà Ioc c' c := hsc.exists_between hc'.2
    refine' ‚ü®ead.piecewiseLe ec d (had ‚ü®hdab.1, le_rfl‚ü©) (hc'e hd), subset_ite.2 _‚ü©
    refine' ‚ü®fun x hx => had ‚ü®hx.1.1, hx.2‚ü©, fun x hx => hc'e ‚ü®hd.1.trans (not_le.1 hx.2), hx.1.2‚ü©‚ü©
  rcases hc.2.eq_or_lt with heq | hlt
  ¬∑ exact ‚ü®ec, heq ‚ñ∏ hec‚ü©
  rsuffices ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, ‚àÉ e : Trivialization F (œÄ F E), Icc a d ‚äÜ e.baseSet
  ¬∑ exact ((hsc.1 ‚ü®‚ü®hc.1.trans hdcb.1.le, hdcb.2‚ü©, hd‚ü©).not_lt hdcb.1).elim
  obtain ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, Ico c d ‚äÜ ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec ‚ü®hc.1, le_rfl‚ü©))
  have had : Ico a d ‚äÜ ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  ¬∑ obtain ‚ü®ed, hed‚ü© : ‚àÉ ed : Trivialization F (œÄ F E), d ‚àà ed.baseSet :=
      ‚ü®trivializationAt F E d, mem_baseSet_trivializationAt F E d‚ü©
    refine' ‚ü®d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono (inter_subset_right _ _) (inter_subset_right _ _)), fun x hx => _‚ü©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr ‚ü®hed, hdcb.1‚ü©, Or.inl ‚ü®had ‚ü®hx.1, hxd‚ü©, hxd‚ü©]
  ¬∑ rw [disjoint_left] at he
    push_neg at he
    rcases he with ‚ü®d', hdd' : d' < d, hd'c‚ü©
    exact ‚ü®d', ‚ü®hd'c, hdd'.le.trans hdcb.2‚ü©, ec, (Icc_subset_Ico_right hdd').trans had‚ü©","error:  function expected at
  inter_subset_right ?m.16125
term has type
  ?m.16124 ‚àà ?m.16123
error:  function expected at
  inter_subset_right ?m.16167
term has type
  ?m.16166 ‚àà ?m.16165","theorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]
    [OrderTopology B] [FiberBundle F E] (a b : B) :
    ‚àÉ e : Trivialization F (œÄ F E), Icc a b ‚äÜ e.baseSet ",":= by
  obtain ‚ü®ea, hea‚ü© : ‚àÉ ea : Trivialization F (œÄ F E), a ‚àà ea.baseSet :=
    ‚ü®trivializationAt F E a, mem_baseSet_trivializationAt F E a‚ü©
  cases' lt_or_le b a with hab hab
  ¬∑ exact ‚ü®ea, by simp [*]‚ü©
  set s : Set B := { x ‚àà Icc a b | ‚àÉ e : Trivialization F (œÄ F E), Icc a x ‚äÜ e.baseSet }
  have ha : a ‚àà s := ‚ü®left_mem_Icc.2 hab, ea, by simp [hea]‚ü©
  have sne : s.Nonempty := ‚ü®a, ha‚ü©
  have hsb : b ‚àà upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := ‚ü®b, hsb‚ü©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c ‚àà Icc a b := ‚ü®hsc.1 ha, hsc.2 hsb‚ü©
  obtain ‚ü®-, ec : Trivialization F (œÄ F E), hec : Icc a c ‚äÜ ec.baseSet‚ü© : c ‚àà s := by
    rcases hc.1.eq_or_lt with heq | hlt
    ¬∑ rwa [‚Üê heq]
    refine ‚ü®hc, ?_‚ü©
    obtain ‚ü®ec, hc‚ü© : ‚àÉ ec : Trivialization F (œÄ F E), c ‚àà ec.baseSet :=
      ‚ü®trivializationAt F E c, mem_baseSet_trivializationAt F E c‚ü©
    obtain ‚ü®c', hc', hc'e‚ü© : ‚àÉ c' ‚àà Ico a c, Ioc c' c ‚äÜ ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain ‚ü®d, ‚ü®hdab, ead, had‚ü©, hd‚ü© : ‚àÉ d ‚àà s, d ‚àà Ioc c' c := hsc.exists_between hc'.2
    refine ‚ü®ead.piecewiseLe ec d (had ‚ü®hdab.1, le_rfl‚ü©) (hc'e hd), subset_ite.2 ?_‚ü©
    exact ‚ü®fun x hx => had ‚ü®hx.1.1, hx.2‚ü©, fun x hx => hc'e ‚ü®hd.1.trans (not_le.1 hx.2), hx.1.2‚ü©‚ü©
  rcases hc.2.eq_or_lt with heq | hlt
  ¬∑ exact ‚ü®ec, heq ‚ñ∏ hec‚ü©
  rsuffices ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, ‚àÉ e : Trivialization F (œÄ F E), Icc a d ‚äÜ e.baseSet
  ¬∑ exact ((hsc.1 ‚ü®‚ü®hc.1.trans hdcb.1.le, hdcb.2‚ü©, hd‚ü©).not_lt hdcb.1).elim
  obtain ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, Ico c d ‚äÜ ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec ‚ü®hc.1, le_rfl‚ü©))
  have had : Ico a d ‚äÜ ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  ¬∑ obtain ‚ü®ed, hed‚ü© : ‚àÉ ed : Trivialization F (œÄ F E), d ‚àà ed.baseSet :=
      ‚ü®trivializationAt F E d, mem_baseSet_trivializationAt F E d‚ü©
    refine ‚ü®d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono inter_subset_right inter_subset_right), fun x hx => ?_‚ü©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr ‚ü®hed, hdcb.1‚ü©, Or.inl ‚ü®had ‚ü®hx.1, hxd‚ü©, hxd‚ü©]
  ¬∑ rw [disjoint_left] at he
    push_neg at he
    rcases he with ‚ü®d', hdd' : d' < d, hd'c‚ü©
    exact ‚ü®d', ‚ü®hd'c, hdd'.le.trans hdcb.2‚ü©, ec, (Icc_subset_Ico_right hdd').trans had‚ü©"
Mathlib/MeasureTheory/Measure/AddContent.lean,MeasureTheory.addContent_union,addContent_union,a2d4b97db742cef33d7ce3404f92ab85330707e5,":= by
  by_cases hs_empty : s = ‚àÖ
  ¬∑ simp only [hs_empty, Set.empty_union, addContent_empty, zero_add]
  classical
  have h := addContent_sUnion (m := m) (I := {s, t}) ?_ ?_ ?_
  rotate_left
  ¬∑ simp only [coe_pair, Set.insert_subset_iff, hs, ht, Set.singleton_subset_iff, and_self_iff]
  ¬∑ simp only [coe_pair, Set.pairwiseDisjoint_insert, pairwiseDisjoint_singleton,
      mem_singleton_iff, Ne.def, id.def, forall_eq, true_and_iff]
    exact fun _ => h_dis
  ¬∑ simp only [coe_pair, sUnion_insert, sUnion_singleton]
    exact hst
  convert h
  ¬∑ simp only [coe_pair, sUnion_insert, sUnion_singleton]
  ¬∑ rw [sum_insert, sum_singleton]
    simp only [Finset.mem_singleton]
    refine fun hs_eq_t => hs_empty ?_
    rw [‚Üê hs_eq_t] at h_dis
    exact Disjoint.eq_bot_of_self h_dis","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.6002 ‚Üí ?m.6002 ‚Üí Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.6006 ‚Üí ?m.6006","lemma addContent_union' (hs : s ‚àà C) (ht : t ‚àà C) (hst : s ‚à™ t ‚àà C) (h_dis : Disjoint s t) :
    m (s ‚à™ t) = m s + m t ",":= by
  by_cases hs_empty : s = ‚àÖ
  ¬∑ simp only [hs_empty, Set.empty_union, addContent_empty, zero_add]
  classical
  have h := addContent_sUnion (m := m) (I := {s, t}) ?_ ?_ ?_
  rotate_left
  ¬∑ simp only [coe_pair, Set.insert_subset_iff, hs, ht, Set.singleton_subset_iff, and_self_iff]
  ¬∑ simp only [coe_pair, Set.pairwiseDisjoint_insert, pairwiseDisjoint_singleton,
      mem_singleton_iff, Ne, id, forall_eq, true_and_iff]
    exact fun _ => h_dis
  ¬∑ simp only [coe_pair, sUnion_insert, sUnion_singleton]
    exact hst
  convert h
  ¬∑ simp only [coe_pair, sUnion_insert, sUnion_singleton]
  ¬∑ rw [sum_insert, sum_singleton]
    simp only [Finset.mem_singleton]
    refine fun hs_eq_t => hs_empty ?_
    rw [‚Üê hs_eq_t] at h_dis
    exact Disjoint.eq_bot_of_self h_dis"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,fb54f94c133c9225bec877b481995fc98cd3a253,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,46481c44b177a9d51959788ea995f2a9518524b6,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a
  exact ‚ü®_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b
  exact ‚ü®_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.closed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x
    ¬∑ intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine' ‚ü®g + dg, fun y => _, funext hgf‚ü©
    ¬∑ have hay : a < (g + dg) y := by
        rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
        ¬∑ refine' (lt_add_iff_pos_right _).2 _
          calc
            0 < c - g y := sub_pos.2 hac
            _ = dg y := (dga rfl).symm
        ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      refine' ‚ü®x, hxy.le, _‚ü©
      rcases le_total c (g y) with hc | hc
      ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
      ¬∑ calc
          g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
          _ = b := by rw [hsub, add_sub_cancel'_right]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.closed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x
  ¬∑ intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine' ‚ü®g - dg, fun y => _, funext hgf‚ü©
  ¬∑ have hyb : (g - dg) y < b := by
      rcases (hgb y).eq_or_lt with (rfl | hlt)
      ¬∑ refine' (sub_lt_self_iff _).2 _
        calc
          0 < g y - c := sub_pos.2 hcb
          _ = dg y := (dgb rfl).symm
      ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
    rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
    cases' lt_or_le c (g y) with hc hc
    ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
      ¬∑ refine' ‚ü®x, xu, _, hyxu.le‚ü©
        calc
          f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
      ¬∑ have hay : a < (g - dg) y := by
          calc
            a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
            _ < g y - (b - c) := (sub_lt_sub_right hc _)
            _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
        rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
        exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
    ¬∑ refine' ‚ü®xl y, xu, _, hyxu.le‚ü©
      simp [dg0 (Or.inr hc), hxl]","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case intro.intro.inr.intro.intro.intro
X : Type u_1
Y : Type u_2
inst‚úù¬≥ : TopologicalSpace X
inst‚úù¬≤ : TopologicalSpace Y
inst‚úù¬π : NormalSpace Y
inst‚úù : Nonempty X
f : X ‚Üí·µá ‚Ñù
e : X ‚Üí Y
he : ClosedEmbedding e
inhabited_h : Inhabited X
a : ‚Ñù
ha : IsGLB (range ‚áëf) a
b : ‚Ñù
hb : IsLUB (range ‚áëf) b
hmem : ‚àÄ (x : X), f x ‚àà Icc a b
hle : a ‚â§ b
hlt : a < b
c : ‚Ñù := (a + b) / 2
hac : a < c
hcb : c < b
hsub : c - a = b - c
g : Y ‚Üí·µá ‚Ñù
hg_mem : ‚àÄ (y : Y), g y ‚àà Icc a b
ha' : ¬¨‚àÉ x, f x = a
hd : Disjoint (range e ‚à™ ‚áëg ‚Åª¬π' Ici c) (‚áëg ‚Åª¬π' {a})
dg : Y ‚Üí·µá ‚Ñù
dg0 : EqOn (‚áëdg) (Function.const Y 0) (range e ‚à™ ‚áëg ‚Åª¬π' Ici c)
dga : EqOn (‚áëdg) (Function.const Y (c - a)) (‚áëg ‚Åª¬π' {a})
dgmem : ‚àÄ (x : Y), dg x ‚àà Icc 0 (c - a)
hgf : ‚àÄ (x : X), (g + dg) (e x) = f x
‚ä¢ ‚àÉ g, (‚àÄ (y : Y), ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß ‚áëg ‚àò e = ‚áëf
error:  unsolved goals
case intro.intro.inr.intro.intro
X : Type u_1
Y : Type u_2
inst‚úù¬≥ : TopologicalSpace X
inst‚úù¬≤ : TopologicalSpace Y
inst‚úù¬π : NormalSpace Y
inst‚úù : Nonempty X
f : X ‚Üí·µá ‚Ñù
e : X ‚Üí Y
he : ClosedEmbedding e
inhabited_h : Inhabited X
a : ‚Ñù
ha : IsGLB (range ‚áëf) a
b : ‚Ñù
hb : IsLUB (range ‚áëf) b
hmem : ‚àÄ (x : X), f x ‚àà Icc a b
hle : a ‚â§ b
hlt : a < b
c : ‚Ñù := (a + b) / 2
hac : a < c
hcb : c < b
hsub : c - a = b - c
g : Y ‚Üí·µá ‚Ñù
hg_mem : ‚àÄ (y : Y), ‚àÉ x, g y ‚àà Icc (f x) b
hgf : ‚áëg ‚àò e = ‚áëf
‚ä¢ ‚àÉ g, (‚àÄ (y : Y), ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß ‚áëg ‚àò e = ‚áëf","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean,CategoryTheory.Limits.colimitLimitToLimitColimit_surjective,colimitLimitToLimitColimit_surjective,4e9ad32a390d245132183394a03b349e4f617c33,":= by
  classical
    intro x
    have z := fun j => jointly_surjective'.{v, v} (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply', t, FunctorToTypes.map_comp_apply, Colimit.w_apply', e, ‚Üê
        Limit.w_apply' f, ‚Üê e]
      simp
    simp_rw [colimit_eq_iff.{v, v}] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun {_} {_} f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun {_} {_} f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun {_} {_} f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j} {j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.bunion·µ¢ fun j => Finset.univ.bunion·µ¢ fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (by
            rw [Finset.mem_bunion·µ¢]
            refine' ‚ü®j, Finset.mem_univ j, _‚ü©
            rw [Finset.mem_bunion·µ¢]
            refine' ‚ü®j', Finset.mem_univ j', _‚ü©
            rw [Finset.mem_image]
            refine' ‚ü®f, Finset.mem_univ _, _‚ü©
            rfl))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£'(X Y : K)(_ : X ‚àà O)(_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.bunion·µ¢ fun j : J =>
        Finset.univ.bunion·µ¢ fun j' : J =>
          Finset.univ.bunion·µ¢ fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      exact k'O
      swap
      ¬∑ rw [Finset.mem_bunion·µ¢]
        refine' ‚ü®j‚ÇÅ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_bunion·µ¢]
        refine' ‚ü®j‚ÇÇ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_bunion·µ¢]
        refine' ‚ü®f, Finset.mem_univ _, _‚ü©
        simp only [true_or_iff, eq_self_iff_true, and_self_iff, Finset.mem_insert, heq_iff_eq]
      ¬∑ rw [Finset.mem_bunion·µ¢]
        refine' ‚ü®j‚ÇÉ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_bunion·µ¢]
        refine' ‚ü®j‚ÇÑ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_bunion·µ¢]
        refine' ‚ü®f', Finset.mem_univ _, _‚ü©
        simp only [eq_self_iff_true, or_true_iff, and_self_iff, Finset.mem_insert,
          Finset.mem_singleton, heq_iff_eq]
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk.{v, v}
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) :=
            by rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) :=
            by rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) :=
            by rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext'
      intro j
      simp only [id.def, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff.{v, v}, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine' ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), _‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","error:  application type mismatch
  jointly_surjective' (limit.œÄ (curry.obj F ‚ãô colim) j x)
argument
  limit.œÄ (curry.obj F ‚ãô colim) j x
has type
  (curry.obj F ‚ãô colim).obj j : Type v
but is expected to have type
  colimit ?m.27488 : Type v
error:  unsolved goals
J : Type u‚ÇÅ
K : Type u‚ÇÇ
inst‚úù‚Å¥ : SmallCategory J
inst‚úù¬≥ : Category.{v‚ÇÇ, u‚ÇÇ} K
inst‚úù¬≤ : Small.{v, u‚ÇÇ} K
inst‚úù¬π : FinCategory J
F : J √ó K ‚•§ Type v
inst‚úù : IsFiltered K
x : limit (curry.obj F ‚ãô colim)
‚ä¢ ‚àÉ a, colimitLimitToLimitColimit F a = x","theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) ",":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ‚Üê Limit.w_apply.{u‚ÇÅ, v, u‚ÇÅ} f, ‚Üê e]
      simp only [Functor.comp_map, Types.Colimit.Œπ_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact k'O
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) := by
            rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) := by
            rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext
      intro j
      simp only [id, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]"
Mathlib/Topology/Algebra/Monoid.lean,exists_open_nhds_one_mul_subset,exists_open_nhds_one_mul_subset,d5e426e86d22447ca931bc467da88f6348ae1700,":= by
  rcases exists_open_nhds_one_split hU with ‚ü®V, Vo, V1, hV‚ü©
  use V, Vo, V1
  rintro _ ‚ü®x, y, hx, hy, rfl‚ü©
  exact hV _ hx _ hy","error:  application type mismatch
  hV ?m.84591 hx
argument
  hx
has type
  M : Type u_3
but is expected to have type
  ?m.84591 ‚àà V : Prop","theorem exists_open_nhds_one_mul_subset {U : Set M} (hU : U ‚àà ùìù (1 : M)) :
    ‚àÉ V : Set M, IsOpen V ‚àß (1 : M) ‚àà V ‚àß V * V ‚äÜ U ",":= by
  simpa only [mul_subset_iff] using exists_open_nhds_one_split hU"
Mathlib/Topology/Irreducible.lean,isIrreducible_iff_sInter,isIrreducible_iff_sInter,c342c339a777827331257acd880fea6d441a6aa6,":= by
  refine ‚ü®fun h U hu hU => ?_, fun h => ‚ü®?_, ?_‚ü©‚ü©
  ¬∑ induction U with
    | empty => simpa using h.nonempty
    | @insert u U _ IH =>
      rw [Finset.coe_insert, sInter_insert]
      rw [Finset.forall_mem_insert] at hu hU
      exact h.2 _ _ hu.1 (U.finite_toSet.isOpen_sInter hu.2) hU.1 (IH hu.2 hU.2)
  ¬∑ simpa using h ‚àÖ
  ¬∑ intro u v hu hv hu' hv'
    simpa [*] using h {u, v}",error:  invalid alternative name 'empty',"theorem isIrreducible_iff_sInter :
    IsIrreducible s ‚Üî
      ‚àÄ (U : Finset (Set X)), (‚àÄ u ‚àà U, IsOpen u) ‚Üí (‚àÄ u ‚àà U, (s ‚à© u).Nonempty) ‚Üí
        (s ‚à© ‚ãÇ‚ÇÄ ‚ÜëU).Nonempty ",":= by
  refine ‚ü®fun h U hu hU => ?_, fun h => ‚ü®?_, ?_‚ü©‚ü©
  ¬∑ induction U using Finset.induction_on with
    | empty => simpa using h.nonempty
    | @insert u U _ IH =>
      rw [Finset.coe_insert, sInter_insert]
      rw [Finset.forall_mem_insert] at hu hU
      exact h.2 _ _ hu.1 (U.finite_toSet.isOpen_sInter hu.2) hU.1 (IH hu.2 hU.2)
  ¬∑ simpa using h ‚àÖ
  ¬∑ intro u v hu hv hu' hv'
    simpa [*] using h {u, v}"
Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean,MeasureTheory.Measure.rnDeriv_withDensity_withDensity_rnDeriv_right,rnDeriv_withDensity_withDensity_rnDeriv_right,0a88f90fd4cfa7135d7bd7e34ca7799b79b40573,":= by
  conv_rhs => rw [Œº.haveLebesgueDecomposition_add ŒΩ, add_comm]
  have hŒΩ_ac : ŒΩ ‚â™ ŒΩ.withDensity f := withDensity_absolutelyContinuous' hf hf_ne_zero hf_ne_top
  refine hŒΩ_ac.ae_eq ?_
  have : SigmaFinite (ŒΩ.withDensity f) := SigmaFinite.withDensity_of_ne_top hf hf_ne_top
  refine (rnDeriv_add_of_mutuallySingular _ _ _ ?_).symm
  exact ((mutuallySingular_singularPart Œº ŒΩ).symm.withDensity).symm","error:  application type mismatch
  withDensity_absolutelyContinuous' hf hf_ne_zero hf_ne_top
argument
  hf_ne_top
has type
  ‚àÄ·µê (x : Œ±) ‚àÇŒΩ, f x ‚â† ‚ä§ : Prop
but is expected to have type
  (ŒΩ.withDensity f) ?m.9325 = 0 : Prop","lemma rnDeriv_withDensity_withDensity_rnDeriv_right (Œº ŒΩ : Measure Œ±) [SigmaFinite Œº]
    [SigmaFinite ŒΩ] (hf : AEMeasurable f ŒΩ) (hf_ne_zero : ‚àÄ·µê x ‚àÇŒΩ, f x ‚â† 0)
    (hf_ne_top : ‚àÄ·µê x ‚àÇŒΩ, f x ‚â† ‚àû) :
    (ŒΩ.withDensity (Œº.rnDeriv ŒΩ)).rnDeriv (ŒΩ.withDensity f) =·µê[ŒΩ] Œº.rnDeriv (ŒΩ.withDensity f) ",":= by
  conv_rhs => rw [Œº.haveLebesgueDecomposition_add ŒΩ, add_comm]
  have hŒΩ_ac : ŒΩ ‚â™ ŒΩ.withDensity f := withDensity_absolutelyContinuous' hf hf_ne_zero
  refine hŒΩ_ac.ae_eq ?_
  have : SigmaFinite (ŒΩ.withDensity f) := SigmaFinite.withDensity_of_ne_top hf hf_ne_top
  refine (rnDeriv_add_of_mutuallySingular _ _ _ ?_).symm
  exact ((mutuallySingular_singularPart Œº ŒΩ).symm.withDensity).symm"
Mathlib/RingTheory/IntegralClosure.lean,RingHom.isIntegralElem_leadingCoeff_mul,RingHom.isIntegralElem_leadingCoeff_mul,9e34a191034458a56331f976ff7400a26407c888,":= by
  by_cases h' : 1 ‚â§ p.natDegree
  ¬∑ use normalizeScaleRoots p
    have : p ‚â† 0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_eval‚ÇÇ_leadingCoeff_mul p h' f x, h, MulZeroClass.mul_zero]
  ¬∑ by_cases hp : p.map f = 0
    ¬∑ apply_fun fun q => coeff q p.natDegree at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, MulZeroClass.zero_mul]
      exact f.is_integral_zero
    ¬∑ rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', eval‚ÇÇ_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]","error:  invalid field 'is_integral_zero', the environment does not contain 'RingHom.is_integral_zero'
  f
has type
  R ‚Üí+* S","theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval‚ÇÇ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) ",":= by
  by_cases h' : 1 ‚â§ p.natDegree
  ¬∑ use normalizeScaleRoots p
    have : p ‚â† 0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_eval‚ÇÇ_leadingCoeff_mul p h' f x, h, mul_zero]
  ¬∑ by_cases hp : p.map f = 0
    ¬∑ apply_fun fun q => coeff q p.natDegree at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, zero_mul]
      exact f.isIntegralElem_zero
    ¬∑ rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', eval‚ÇÇ_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]"
Mathlib/NumberTheory/Padics/PadicVal.lean,Nat.log_ne_padicValNat_succ,Nat.log_ne_padicValNat_succ,72841f2438e4683f880bebbf766b2d325b307880,":= by
  rw [Ne, log_eq_iff (by simp [hn])]
  rintro ‚ü®h1, h2‚ü©
  rw [‚Üê lt_add_one_iff, ‚Üê mul_one (2 ^ _)] at h1
  rw [‚Üê add_one_le_iff, Nat.pow_succ] at h2
  refine' not_dvd_of_between_consec_multiples h1 (lt_of_le_of_ne' h2 _) pow_padicValNat_dvd
  exact pow_succ_padicValNat_not_dvd (p := 2) n.succ_ne_zero ‚àò dvd_of_eq","error:  unknown identifier 'lt_add_one_iff'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.65770
case intro
p n : ‚Ñï
hn : n ‚â† 0
h1 : 2 ^ padicValNat 2 (n + 1) ‚â§ n
h2 : n < 2 ^ (padicValNat 2 (n + 1) + 1)
‚ä¢ False",lemma Nat.log_ne_padicValNat_succ {n : ‚Ñï} (hn : n ‚â† 0) : log 2 n ‚â† padicValNat 2 (n + 1) ,":= by
  rw [Ne, log_eq_iff (by simp [hn])]
  rintro ‚ü®h1, h2‚ü©
  rw [‚Üê Nat.lt_add_one_iff, ‚Üê mul_one (2 ^ _)] at h1
  rw [‚Üê add_one_le_iff, Nat.pow_succ] at h2
  refine not_dvd_of_between_consec_multiples h1 (lt_of_le_of_ne' h2 ?_) pow_padicValNat_dvd
  exact pow_succ_padicValNat_not_dvd (p := 2) n.succ_ne_zero ‚àò dvd_of_eq"
Mathlib/CategoryTheory/Monoidal/Bimod.lean,Bimod.AssociatorBimod.inv_hom_id,inv_hom_id,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  dsimp [hom, homAux, inv, invAux]
  apply coequalizer.hom_ext
  slice_lhs 1 2 => rw [coequalizer.œÄ_desc]
  refine' (cancel_epi ((tensorLeft _).map (coequalizer.œÄ _ _))).1 _
  rw [tensorLeft_map]
  slice_lhs 1 3 => rw [id_tensor_œÄ_preserves_coequalizer_inv_desc]
  slice_lhs 3 4 => rw [coequalizer.œÄ_desc]
  slice_lhs 2 4 => rw [œÄ_tensor_id_preserves_coequalizer_inv_desc]
  slice_lhs 1 3 => rw [Iso.inv_hom_id_assoc]
  dsimp only [TensorBimod.X]
  slice_rhs 2 3 => rw [Category.comp_id]","error:  unsolved goals
case h
C : Type u‚ÇÅ
inst‚úù‚Å¥ : Category.{v‚ÇÅ, u‚ÇÅ} C
inst‚úù¬≥ : MonoidalCategory C
A B : Mon_ C
M : Bimod A B
inst‚úù¬≤ : HasCoequalizers C
inst‚úù¬π : (X : C) ‚Üí PreservesColimitsOfSize.{0, 0, v‚ÇÅ, v‚ÇÅ, u‚ÇÅ, u‚ÇÅ} (tensorLeft X)
inst‚úù : (X : C) ‚Üí PreservesColimitsOfSize.{0, 0, v‚ÇÅ, v‚ÇÅ, u‚ÇÅ, u‚ÇÅ} (tensorRight X)
R S T U : Mon_ C
P : Bimod R S
Q : Bimod S T
L : Bimod T U
‚ä¢ P.X ‚óÅ coequalizer.œÄ (Q.actRight ‚ñ∑ L.X) ((Œ±_ Q.X T.X L.X).hom ‚â´ Q.X ‚óÅ L.actLeft) ‚â´
      coequalizer.œÄ (P.actRight ‚ñ∑ coequalizer (Q.actRight ‚ñ∑ L.X) ((Œ±_ Q.X T.X L.X).hom ‚â´ Q.X ‚óÅ L.actLeft))
        ((Œ±_ P.X S.X (coequalizer (Q.actRight ‚ñ∑ L.X) ((Œ±_ Q.X T.X L.X).hom ‚â´ Q.X ‚óÅ L.actLeft))).hom ‚â´
          P.X ‚óÅ TensorBimod.actLeft Q L) =
    P.X ‚óÅ coequalizer.œÄ (Q.actRight ‚ñ∑ L.X) ((Œ±_ Q.X T.X L.X).hom ‚â´ Q.X ‚óÅ L.actLeft) ‚â´
      coequalizer.œÄ (P.actRight ‚ñ∑ (Q.tensorBimod L).X)
        ((Œ±_ P.X S.X (Q.tensorBimod L).X).hom ‚â´ P.X ‚óÅ (Q.tensorBimod L).actLeft)",theorem inv_hom_id : inv P Q L ‚â´ hom P Q L = ùüô _ ,":= by
  dsimp [hom, homAux, inv, invAux]
  apply coequalizer.hom_ext
  slice_lhs 1 2 => rw [coequalizer.œÄ_desc]
  refine (cancel_epi ((tensorLeft _).map (coequalizer.œÄ _ _))).1 ?_
  rw [tensorLeft_map]
  slice_lhs 1 3 => rw [id_tensor_œÄ_preserves_coequalizer_inv_desc]
  slice_lhs 3 4 => rw [coequalizer.œÄ_desc]
  slice_lhs 2 4 => rw [œÄ_tensor_id_preserves_coequalizer_inv_desc]
  slice_lhs 1 3 => rw [Iso.inv_hom_id_assoc]
  dsimp only [TensorBimod.X]
  slice_rhs 2 3 => rw [Category.comp_id]
  rfl"
Mathlib/Data/Int/Cast/Lemmas.lean,AddMonoidHom.ext_int,ext_int,01d739c14a27d96463129c57bbb1982309f33ea6,":=
  have : f.comp (Int.ofNatHom : ‚Ñï ‚Üí+ ‚Ñ§) = g.comp (Int.ofNatHom : ‚Ñï ‚Üí+ ‚Ñ§) := ext_nat' _ _ h1
  have this' : ‚àÄ n : ‚Ñï, f n = g n := FunLike.ext_iff.1 this
  ext fun n => match n with
  | (n : ‚Ñï) => this' n
  | .negSucc n => eq_on_neg _ _ (this' <| n + 1)",error:  unknown constant 'FunLike.ext_iff',theorem ext_int [AddMonoid A] {f g : ‚Ñ§ ‚Üí+ A} (h1 : f 1 = g 1) : f = g ,":=
  have : f.comp (Int.ofNatHom : ‚Ñï ‚Üí+ ‚Ñ§) = g.comp (Int.ofNatHom : ‚Ñï ‚Üí+ ‚Ñ§) := ext_nat' _ _ h1
  have this' : ‚àÄ n : ‚Ñï, f n = g n := DFunLike.ext_iff.1 this
  ext fun n => match n with
  | (n : ‚Ñï) => this' n
  | .negSucc n => eq_on_neg _ _ (this' <| n + 1)"
Mathlib/Topology/MetricSpace/HausdorffDistance.lean,Metric.infDist_inter_closedBall_of_mem,infDist_inter_closedBall_of_mem,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  replace h : y ‚àà s ‚à© closedBall x (dist y x) := ‚ü®h, mem_closedBall.2 le_rfl‚ü©
  refine le_antisymm ?_ (infDist_le_infDist_of_subset (inter_subset_left _ _) ‚ü®y, h‚ü©)
  refine' not_lt.1 fun hlt => _
  rcases (infDist_lt_iff ‚ü®y, h.1‚ü©).mp hlt with ‚ü®z, hzs, hz‚ü©
  rcases le_or_lt (dist z x) (dist y x) with hle | hlt
  ¬∑ exact hz.not_le (infDist_le_dist_of_mem ‚ü®hzs, hle‚ü©)
  ¬∑ rw [dist_comm z, dist_comm y] at hlt
    exact (hlt.trans hz).not_le (infDist_le_dist_of_mem h)","error:  function expected at
  inter_subset_left ?m.75705
term has type
  ?m.75704 ‚àà ?m.75702","theorem infDist_inter_closedBall_of_mem (h : y ‚àà s) :
    infDist x (s ‚à© closedBall x (dist y x)) = infDist x s ",":= by
  replace h : y ‚àà s ‚à© closedBall x (dist y x) := ‚ü®h, mem_closedBall.2 le_rfl‚ü©
  refine le_antisymm ?_ (infDist_le_infDist_of_subset inter_subset_left ‚ü®y, h‚ü©)
  refine not_lt.1 fun hlt => ?_
  rcases (infDist_lt_iff ‚ü®y, h.1‚ü©).mp hlt with ‚ü®z, hzs, hz‚ü©
  rcases le_or_lt (dist z x) (dist y x) with hle | hlt
  ¬∑ exact hz.not_le (infDist_le_dist_of_mem ‚ü®hzs, hle‚ü©)
  ¬∑ rw [dist_comm z, dist_comm y] at hlt
    exact (hlt.trans hz).not_le (infDist_le_dist_of_mem h)"
Mathlib/Algebra/Lie/Weights/Basic.lean,LieModule.map_posFittingComp_le,map_posFittingComp_le,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [posFittingComp, posFittingComp, LieSubmodule.map_iSup]
  refine iSup_mono fun y ‚Ü¶ LieSubmodule.map_le_iff_le_comap.mpr fun m hm ‚Ü¶ ?_
  simp only [mem_posFittingCompOf] at hm
  simp only [LieSubmodule.mem_comap, mem_posFittingCompOf]
  intro k
  obtain ‚ü®n, hn‚ü© := hm k
  use f n
  rw [LieModule.toEndomorphism_pow_apply_map, hn]","error:  unknown constant 'LieModule.toEndomorphism_pow_apply_map'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.394406
case h
K : Type u_1
R : Type u_2
L : Type u_3
M : Type u_4
inst‚úù¬π¬π : CommRing R
inst‚úù¬π‚Å∞ : LieRing L
inst‚úù‚Åπ : LieAlgebra R L
inst‚úù‚Å∏ : LieAlgebra.IsNilpotent R L
inst‚úù‚Å∑ : AddCommGroup M
inst‚úù‚Å∂ : Module R M
inst‚úù‚Åµ : LieRingModule L M
inst‚úù‚Å¥ : LieModule R L M
M‚ÇÇ : Type u_5
inst‚úù¬≥ : AddCommGroup M‚ÇÇ
inst‚úù¬≤ : Module R M‚ÇÇ
inst‚úù¬π : LieRingModule L M‚ÇÇ
inst‚úù : LieModule R L M‚ÇÇ
œá : L ‚Üí R
f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ M‚ÇÇ
y : L
m : M
hm : ‚àÄ (k : ‚Ñï), ‚àÉ n, ((toEnd R L M) y ^ k) n = m
k : ‚Ñï
n : M
hn : ((toEnd R L M) y ^ k) n = m
‚ä¢ ((toEnd R L M‚ÇÇ) y ^ k) (f n) = f m","lemma map_posFittingComp_le :
    (posFittingComp R L M).map f ‚â§ posFittingComp R L M‚ÇÇ ",":= by
  rw [posFittingComp, posFittingComp, LieSubmodule.map_iSup]
  refine iSup_mono fun y ‚Ü¶ LieSubmodule.map_le_iff_le_comap.mpr fun m hm ‚Ü¶ ?_
  simp only [mem_posFittingCompOf] at hm
  simp only [LieSubmodule.mem_comap, mem_posFittingCompOf]
  intro k
  obtain ‚ü®n, hn‚ü© := hm k
  use f n
  rw [LieModule.toEnd_pow_apply_map, hn]"
Mathlib/Algebra/Homology/ShortComplex/HomologicalComplex.lean,CochainComplex.isoHomologyœÄ‚ÇÄ_inv_naturality,isoHomologyœÄ‚ÇÄ_inv_naturality,9072ff84a0d139a344bf9eed4a00c4cd27596c79,":= by
  simp only [‚Üê cancel_mono (L.homologyœÄ 0), ‚Üê cancel_epi (K.homologyœÄ 0),
    assoc, isoHomologyœÄ‚ÇÄ_inv_hom_id, comp_id, HomologicalComplex.homologyœÄ_naturality,
    isoHomologyœÄ‚ÇÄ_hom_inv_id_assoc]","error:  unknown identifier 'isoHomologyœÄ‚ÇÄ_inv_hom_id'
error:  unknown identifier 'isoHomologyœÄ‚ÇÄ_hom_inv_id_assoc'
error:  unsolved goals
C : Type u_1
inst‚úù¬≥ : Category.{u_2, u_1} C
inst‚úù¬≤ : HasZeroMorphisms C
K L : CochainComplex C ‚Ñï
œÜ : K ‚ü∂ L
inst‚úù¬π : HomologicalComplex.HasHomology K 0
inst‚úù : HomologicalComplex.HasHomology L 0
‚ä¢ HomologicalComplex.homologyœÄ K 0 ‚â´
      HomologicalComplex.homologyMap œÜ 0 ‚â´ L.isoHomologyœÄ‚ÇÄ.inv ‚â´ HomologicalComplex.homologyœÄ L 0 =
    HomologicalComplex.homologyœÄ K 0 ‚â´
      K.isoHomologyœÄ‚ÇÄ.inv ‚â´ HomologicalComplex.cyclesMap œÜ 0 ‚â´ HomologicalComplex.homologyœÄ L 0","lemma isoHomologyœÄ‚ÇÄ_inv_naturality [L.HasHomology 0] :
    HomologicalComplex.homologyMap œÜ 0 ‚â´ L.isoHomologyœÄ‚ÇÄ.inv =
      K.isoHomologyœÄ‚ÇÄ.inv ‚â´ HomologicalComplex.cyclesMap œÜ 0 ",":= by
  simp only [‚Üê cancel_epi (K.homologyœÄ 0), HomologicalComplex.homologyœÄ_naturality_assoc,
    HomologicalComplex.isoHomologyœÄ_hom_inv_id, comp_id,
    HomologicalComplex.isoHomologyœÄ_hom_inv_id_assoc]"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.erase_update_of_ne,erase_update_of_ne,67e80fd089fe45abea632652c43b78eba72d60e3,":= by
  rw [‚Üê update_eq_erase, ‚Üê update_eq_erase, update_comm _ ha]","warning:  Finsupp does not have a doc string
error:  unknown identifier 'update_eq_erase'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.70329
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
Œπ : Type u_4
M : Type u_5
M' : Type u_6
N : Type u_7
P : Type u_8
G : Type u_9
H : Type u_10
R : Type u_11
S : Type u_12
inst‚úù : Zero M
f : Œ± ‚Üí‚ÇÄ M
a a' : Œ±
ha : a ‚â† a'
b : M
‚ä¢ erase a (f.update a' b) = (erase a f).update a' b","theorem erase_update_of_ne (f : Œ± ‚Üí‚ÇÄ M) {a a' : Œ±} (ha : a ‚â† a') (b : M) :
    erase a (update f a' b) = update (erase a f) a' b ",":= by
  rw [erase_eq_update_zero, erase_eq_update_zero, update_comm _ ha]"
Mathlib/Topology/Perfect.lean,exists_countable_union_perfect_of_isClosed,exists_countable_union_perfect_of_isClosed,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  obtain ‚ü®b, bct, _, bbasis‚ü© := TopologicalSpace.exists_countable_basis Œ±
  let v := { U ‚àà b | (U ‚à© C).Countable }
  let V := ‚ãÉ U ‚àà v, U
  let D := C \ V
  have Vct : (V ‚à© C).Countable := by
    simp only [V, iUnion_inter, mem_sep_iff]
    apply Countable.biUnion
    ¬∑ exact Countable.mono (inter_subset_left _ _) bct
    ¬∑ exact inter_subset_right _ _
  refine ‚ü®V ‚à© C, D, Vct, ‚ü®?_,? _‚ü©, ?_‚ü©
  ¬∑ refine hclosed.sdiff (isOpen_biUnion fun _ ‚Ü¶ ?_)
    exact fun ‚ü®Ub, _‚ü© ‚Ü¶ IsTopologicalBasis.isOpen bbasis Ub
  ¬∑ rw [preperfect_iff_nhds]
    intro x xD E xE
    have : ¬¨(E ‚à© D).Countable := by
      intro h
      obtain ‚ü®U, hUb, xU, hU‚ü© : ‚àÉ U ‚àà b, x ‚àà U ‚àß U ‚äÜ E :=
        (IsTopologicalBasis.mem_nhds_iff bbasis).mp xE
      have hU_cnt : (U ‚à© C).Countable := by
        apply @Countable.mono _ _ (E ‚à© D ‚à™ V ‚à© C)
        ¬∑ rintro y ‚ü®yU, yC‚ü©
          by_cases h : y ‚àà V
          ¬∑ exact mem_union_right _ (mem_inter h yC)
          ¬∑ exact mem_union_left _ (mem_inter (hU yU) ‚ü®yC, h‚ü©)
        exact Countable.union h Vct
      have : U ‚àà v := ‚ü®hUb, hU_cnt‚ü©
      apply xD.2
      exact mem_biUnion this xU
    by_contra! h
    exact absurd (Countable.mono h (Set.countable_singleton _)) this
  ¬∑ rw [inter_comm, inter_union_diff]","error:  function expected at
  inter_subset_left ?m.6966
term has type
  ?m.6965 ‚àà ?m.6963
error:  function expected at
  inter_subset_right ?m.7008
term has type
  ?m.7007 ‚àà ?m.7006","theorem exists_countable_union_perfect_of_isClosed [SecondCountableTopology Œ±]
    (hclosed : IsClosed C) : ‚àÉ V D : Set Œ±, V.Countable ‚àß Perfect D ‚àß C = V ‚à™ D ",":= by
  obtain ‚ü®b, bct, _, bbasis‚ü© := TopologicalSpace.exists_countable_basis Œ±
  let v := { U ‚àà b | (U ‚à© C).Countable }
  let V := ‚ãÉ U ‚àà v, U
  let D := C \ V
  have Vct : (V ‚à© C).Countable := by
    simp only [V, iUnion_inter, mem_sep_iff]
    apply Countable.biUnion
    ¬∑ exact Countable.mono inter_subset_left bct
    ¬∑ exact inter_subset_right
  refine ‚ü®V ‚à© C, D, Vct, ‚ü®?_, ?_‚ü©, ?_‚ü©
  ¬∑ refine hclosed.sdiff (isOpen_biUnion fun _ ‚Ü¶ ?_)
    exact fun ‚ü®Ub, _‚ü© ‚Ü¶ IsTopologicalBasis.isOpen bbasis Ub
  ¬∑ rw [preperfect_iff_nhds]
    intro x xD E xE
    have : ¬¨(E ‚à© D).Countable := by
      intro h
      obtain ‚ü®U, hUb, xU, hU‚ü© : ‚àÉ U ‚àà b, x ‚àà U ‚àß U ‚äÜ E :=
        (IsTopologicalBasis.mem_nhds_iff bbasis).mp xE
      have hU_cnt : (U ‚à© C).Countable := by
        apply @Countable.mono _ _ (E ‚à© D ‚à™ V ‚à© C)
        ¬∑ rintro y ‚ü®yU, yC‚ü©
          by_cases h : y ‚àà V
          ¬∑ exact mem_union_right _ (mem_inter h yC)
          ¬∑ exact mem_union_left _ (mem_inter (hU yU) ‚ü®yC, h‚ü©)
        exact Countable.union h Vct
      have : U ‚àà v := ‚ü®hUb, hU_cnt‚ü©
      apply xD.2
      exact mem_biUnion this xU
    by_contra! h
    exact absurd (Countable.mono h (Set.countable_singleton _)) this
  ¬∑ rw [inter_comm, inter_union_diff]"
Mathlib/FieldTheory/IsAlgClosed/Spectrum.lean,spectrum.subset_polynomial_aeval,subset_polynomial_aeval,9e80ae3b111c3eecd16d15b3531b28b7aa19b56f,":= by
  rintro _ ‚ü®k, hk, rfl‚ü©
  let q := C (eval k p) - p
  have hroot : IsRoot q k := by simp only [eval_C, eval_sub, sub_self, IsRoot.def]
  rw [‚Üê mul_div_eq_iff_isRoot, ‚Üê neg_mul_neg, neg_sub] at hroot 
  have aeval_q_eq : ‚Üë‚Çê (eval k p) - aeval a p = aeval a q := by
    simp only [aeval_C, AlgHom.map_sub, sub_left_inj]
  rw [mem_iff, aeval_q_eq, ‚Üê hroot, aeval_mul]
  have hcomm := (Commute.all (C k - X) (-(q / (X - C k)))).map (aeval a : ùïú[X] ‚Üí‚Çê[ùïú] A)
  apply mt fun h => (hcomm.isUnit_mul_iff.mp h).1
  simpa only [aeval_X, aeval_C, AlgHom.map_sub] using hk","error:  unsolved goals
ùïú : Type u
A : Type v
inst‚úù¬≤ : Field ùïú
inst‚úù¬π : Ring A
inst‚úù : Algebra ùïú A
a : A
p : ùïú[X]
k : ùïú
hk : k ‚àà œÉ a
q : ùïú[X] := C (eval k p) - p
‚ä¢ eval k q = 0
error:  simp made no progress",theorem subset_polynomial_aeval (a : A) (p : ùïú[X]) : (eval ¬∑ p) '' œÉ a ‚äÜ œÉ (aeval a p) ,":= by
  rintro _ ‚ü®k, hk, rfl‚ü©
  let q := C (eval k p) - p
  have hroot : IsRoot q k := by simp only [q, eval_C, eval_sub, sub_self, IsRoot.def]
  rw [‚Üê mul_div_eq_iff_isRoot, ‚Üê neg_mul_neg, neg_sub] at hroot
  have aeval_q_eq : ‚Üë‚Çê (eval k p) - aeval a p = aeval a q := by
    simp only [q, aeval_C, AlgHom.map_sub, sub_left_inj]
  rw [mem_iff, aeval_q_eq, ‚Üê hroot, aeval_mul]
  have hcomm := (Commute.all (C k - X) (-(q / (X - C k)))).map (aeval a : ùïú[X] ‚Üí‚Çê[ùïú] A)
  apply mt fun h => (hcomm.isUnit_mul_iff.mp h).1
  simpa only [aeval_X, aeval_C, AlgHom.map_sub] using hk"
Mathlib/Geometry/Euclidean/MongePoint.lean,Affine.Simplex.mongePoint_eq_affineCombination_of_pointsWithCircumcenter,mongePoint_eq_affineCombination_of_pointsWithCircumcenter,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [mongePoint_eq_smul_vsub_vadd_circumcenter,
    centroid_eq_affineCombination_of_pointsWithCircumcenter,
    circumcenter_eq_affineCombination_of_pointsWithCircumcenter, affineCombination_vsub,
    ‚Üê LinearMap.map_smul, weightedVSub_vadd_affineCombination]
  congr with i
  rw [Pi.add_apply, Pi.smul_apply, smul_eq_mul, Pi.sub_apply]
  have hn1 : (n + 1 : ‚Ñù) ‚â† 0 := n.cast_add_one_ne_zero
  cases i <;>
      simp_rw [centroidWeightsWithCircumcenter, circumcenterWeightsWithCircumcenter,
        mongePointWeightsWithCircumcenter] <;>
    rw [add_tsub_assoc_of_le (by decide : 1 ‚â§ 2), (by decide : 2 - 1 = 1)]
  ¬∑ rw [if_pos (mem_univ _), sub_zero, add_zero, card_fin]
    have hn3 : (n + 2 + 1 : ‚Ñù) ‚â† 0 := by exact_mod_cast (n + 2).cast_add_one_ne_zero
    field_simp [hn1, hn3, mul_comm]
  ¬∑ field_simp [hn1]
    ring","error:  mod_cast has type
  ¬¨‚Üë(n + 2).succ = 0 : Prop
but is expected to have type
  ¬¨False : Prop","theorem mongePoint_eq_affineCombination_of_pointsWithCircumcenter {n : ‚Ñï}
    (s : Simplex ‚Ñù P (n + 2)) :
    s.mongePoint =
      (univ : Finset (PointsWithCircumcenterIndex (n + 2))).affineCombination ‚Ñù
        s.pointsWithCircumcenter (mongePointWeightsWithCircumcenter n) ",":= by
  rw [mongePoint_eq_smul_vsub_vadd_circumcenter,
    centroid_eq_affineCombination_of_pointsWithCircumcenter,
    circumcenter_eq_affineCombination_of_pointsWithCircumcenter, affineCombination_vsub,
    ‚Üê LinearMap.map_smul, weightedVSub_vadd_affineCombination]
  congr with i
  rw [Pi.add_apply, Pi.smul_apply, smul_eq_mul, Pi.sub_apply]
  have hn1 : (n + 1 : ‚Ñù) ‚â† 0 := n.cast_add_one_ne_zero
  cases i <;>
      simp_rw [centroidWeightsWithCircumcenter, circumcenterWeightsWithCircumcenter,
        mongePointWeightsWithCircumcenter] <;>
    rw [add_tsub_assoc_of_le (by decide : 1 ‚â§ 2), (by decide : 2 - 1 = 1)]
  ¬∑ rw [if_pos (mem_univ _), sub_zero, add_zero, card_fin]
    have hn3 : (n + 2 + 1 : ‚Ñù) ‚â† 0 := by norm_cast
    field_simp [hn1, hn3, mul_comm]
  ¬∑ field_simp [hn1]
    ring"
Mathlib/Analysis/Complex/PhragmenLindelof.lean,PhragmenLindelof.horizontal_strip,horizontal_strip,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm
  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb
  wlog hC‚ÇÄ : 0 < C generalizing C
  ¬∑ refine' le_of_forall_le_of_dense fun C' hC' => this (fun w hw => _) (fun w hw => _) _
    ¬∑ exact (hle_a _ hw).trans hC'.le
    ¬∑ exact (hle_b _ hw).trans hC'.le
    ¬∑ refine' ((norm_nonneg (f (a * I))).trans (hle_a _ _)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=
    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB
  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with ‚ü®c, hc, B, hO‚ü©
  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)
  have hb' : d * b < œÄ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)
  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))
  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C by
    refine' le_of_tendsto (Tendsto.mono_left _ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ
  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :
    ‚àÉ Œ¥ : ‚Ñù,
      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by
    refine'
      ‚ü®Œµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Œµ‚ÇÄ
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),
        fun w hw => _‚ü©
    replace hw : |im (aff w)| ‚â§ d * b := by
      rw [‚Üê Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,
        mul_le_mul_left hd‚ÇÄ]
    simpa only [aff, re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le
  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by
    refine' fun w hw => (hŒ¥ <| hw.by_cases _ _).trans (Real.exp_le_one_iff.2 _)
    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]
  obtain ‚ü®R, hzR, hR‚ü© :
    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by
    refine' ((eventually_gt_atTop _).and _).exists
    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,
      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0) by
      filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him
      calc
        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ ‚â§ C := hR
      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine' Real.tendsto_exp_atBot.comp _
    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine' Tendsto.atBot_add _ tendsto_const_nhds
      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id
    refine' tendsto_const_nhds.add (tendsto_const_nhds.mul _)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable ‚ÑÇ (g Œµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono (inter_subset_right _ _)
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw
    by_cases him : w.im = a - b ‚à® w.im = a + b
    ¬∑ rw [norm_smul, ‚Üê one_mul C]
      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b) := hw.resolve_left fun h ‚Ü¶ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'
      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)
  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]
    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©","error:  function expected at
  inter_subset_right ?m.85889
term has type
  ?m.85888 ‚àà ?m.85887","theorem horizontal_strip (hfd : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo a b))
    (hB : ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo a b)]
      fun z ‚Ü¶ expR (B * expR (c * |z.re|)))
    (hle_a : ‚àÄ z : ‚ÑÇ, im z = a ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hle_b : ‚àÄ z, im z = b ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hza : a ‚â§ im z)
    (hzb : im z ‚â§ b) : ‚Äñf z‚Äñ ‚â§ C ",":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm
  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb
  wlog hC‚ÇÄ : 0 < C generalizing C
  ¬∑ refine le_of_forall_le_of_dense fun C' hC' => this (fun w hw => ?_) (fun w hw => ?_) ?_
    ¬∑ exact (hle_a _ hw).trans hC'.le
    ¬∑ exact (hle_b _ hw).trans hC'.le
    ¬∑ refine ((norm_nonneg (f (a * I))).trans (hle_a _ ?_)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=
    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB
  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with ‚ü®c, hc, B, hO‚ü©
  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)
  have hb' : d * b < œÄ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)
  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))
  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C by
    refine le_of_tendsto (Tendsto.mono_left ?_ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ
  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :
    ‚àÉ Œ¥ : ‚Ñù,
      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by
    refine
      ‚ü®Œµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Œµ‚ÇÄ
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),
        fun w hw => ?_‚ü©
    replace hw : |im (aff w)| ‚â§ d * b := by
      rw [‚Üê Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,
        mul_le_mul_left hd‚ÇÄ]
    simpa only [aff, re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le
  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by
    refine fun w hw => (hŒ¥ <| hw.by_cases ?_ ?_).trans (Real.exp_le_one_iff.2 ?_)
    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]
  obtain ‚ü®R, hzR, hR‚ü© :
    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by
    refine ((eventually_gt_atTop _).and ?_).exists
    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,
      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0) by
      filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him
      calc
        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ ‚â§ C := hR
      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine Real.tendsto_exp_atBot.comp ?_
    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine Tendsto.atBot_add ?_ tendsto_const_nhds
      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id
    refine tendsto_const_nhds.add (tendsto_const_nhds.mul ?_)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable ‚ÑÇ (g Œµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono inter_subset_right
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw
    by_cases him : w.im = a - b ‚à® w.im = a + b
    ¬∑ rw [norm_smul, ‚Üê one_mul C]
      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b) := hw.resolve_left fun h ‚Ü¶ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'
      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)
  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]
    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©"
Mathlib/Order/Bounded.lean,Set.bounded_le_inter_le,bounded_le_inter_le,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  refine ‚ü®?_, Bounded.mono (Set.inter_subset_left s _)‚ü©
  rw [‚Üê @bounded_le_inter_lt _ s _ a]
  exact Bounded.mono fun x ‚ü®hx, hx'‚ü© => ‚ü®hx, le_of_lt hx'‚ü©","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set Œ± : Type u_1
but is expected to have type
  ?m.20507 ‚àà ?m.20505 ‚à© ?m.20506 : Prop","theorem bounded_le_inter_le [LinearOrder Œ±] (a : Œ±) :
    Bounded (¬∑ ‚â§ ¬∑) (s ‚à© { b | a ‚â§ b }) ‚Üî Bounded (¬∑ ‚â§ ¬∑) s ",":= by
  refine ‚ü®?_, Bounded.mono Set.inter_subset_left‚ü©
  rw [‚Üê @bounded_le_inter_lt _ s _ a]
  exact Bounded.mono fun x ‚ü®hx, hx'‚ü© => ‚ü®hx, le_of_lt hx'‚ü©"
Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean,CategoryTheory.Limits.colimitLimitToLimitColimit_surjective,colimitLimitToLimitColimit_surjective,14167e48d13e9c2d72cbdff0431a8edba6021c34,":= by
  classical
    intro x
    have z := fun j => jointly_surjective'.{v, v} (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply', t, FunctorToTypes.map_comp_apply, Colimit.w_apply', e, ‚Üê
        Limit.w_apply' f, ‚Üê e]
      simp
    simp_rw [colimit_eq_iff.{v, v}] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.bunion·µ¢ fun j => Finset.univ.bunion·µ¢ fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (by
            rw [Finset.mem_bunion·µ¢]
            refine' ‚ü®j, Finset.mem_univ j, _‚ü©
            rw [Finset.mem_bunion·µ¢]
            refine' ‚ü®j', Finset.mem_univ j', _‚ü©
            rw [Finset.mem_image]
            refine' ‚ü®f, Finset.mem_univ _, _‚ü©
            rfl))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£'(X Y : K)(_ : X ‚àà O)(_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.bunion·µ¢ fun j : J =>
        Finset.univ.bunion·µ¢ fun j' : J =>
          Finset.univ.bunion·µ¢ fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      exact k'O
      swap
      ¬∑ rw [Finset.mem_bunion·µ¢]
        refine' ‚ü®j‚ÇÅ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_bunion·µ¢]
        refine' ‚ü®j‚ÇÇ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_bunion·µ¢]
        refine' ‚ü®f, Finset.mem_univ _, _‚ü©
        simp only [true_or_iff, eq_self_iff_true, and_self_iff, Finset.mem_insert, heq_iff_eq]
      ¬∑ rw [Finset.mem_bunion·µ¢]
        refine' ‚ü®j‚ÇÉ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_bunion·µ¢]
        refine' ‚ü®j‚ÇÑ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_bunion·µ¢]
        refine' ‚ü®f', Finset.mem_univ _, _‚ü©
        simp only [eq_self_iff_true, or_true_iff, and_self_iff, Finset.mem_insert,
          Finset.mem_singleton, heq_iff_eq]
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk.{v, v}
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) :=
            by rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) :=
            by rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) :=
            by rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext'
      intro j
      simp only [id.def, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff.{v, v}, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine' ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), _‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","error:  application type mismatch
  jointly_surjective' (limit.œÄ (curry.obj F ‚ãô colim) j x)
argument
  limit.œÄ (curry.obj F ‚ãô colim) j x
has type
  (curry.obj F ‚ãô colim).obj j : Type v
but is expected to have type
  colimit ?m.27488 : Type v
error:  unsolved goals
J : Type u‚ÇÅ
K : Type u‚ÇÇ
inst‚úù‚Å¥ : SmallCategory J
inst‚úù¬≥ : Category.{v‚ÇÇ, u‚ÇÇ} K
inst‚úù¬≤ : Small.{v, u‚ÇÇ} K
inst‚úù¬π : FinCategory J
F : J √ó K ‚•§ Type v
inst‚úù : IsFiltered K
x : limit (curry.obj F ‚ãô colim)
‚ä¢ ‚àÉ a, colimitLimitToLimitColimit F a = x","theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) ",":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ‚Üê Limit.w_apply.{u‚ÇÅ, v, u‚ÇÅ} f, ‚Üê e]
      simp only [Functor.comp_map, Types.Colimit.Œπ_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact k'O
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) := by
            rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) := by
            rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext
      intro j
      simp only [id, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]"
Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean,AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one,AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  rw [‚Üê Finset.card_univ] at hc
  rw [‚Üê Set.image_univ, ‚Üê Finset.coe_univ, ‚Üê Finset.coe_image] at hle ‚ä¢
  exact hi.affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one hle hc","error:  failed to synthesize
  DecidableEq P
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  DecidableEq P
use `set_option diagnostics true` to get diagnostic information
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  invalid field 'affineSpan_eq_of_le_of_card_eq_finrank_add_one', the environment does not contain 'AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one'
  hi
has type
  AffineIndependent k p
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hi
has type
  ‚àÄ (s : Finset Œπ) (w : Œπ ‚Üí k), ‚àë i ‚àà s, w i = 0 ‚Üí (s.weightedVSub p) w = 0 ‚Üí ‚àÄ i ‚àà s, w i = 0","theorem AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one [Fintype Œπ] {p : Œπ ‚Üí P}
    (hi : AffineIndependent k p) {sp : AffineSubspace k P} [FiniteDimensional k sp.direction]
    (hle : affineSpan k (Set.range p) ‚â§ sp) (hc : Fintype.card Œπ = finrank k sp.direction + 1) :
    affineSpan k (Set.range p) = sp ",":= by
  classical
  rw [‚Üê Finset.card_univ] at hc
  rw [‚Üê Set.image_univ, ‚Üê Finset.coe_univ, ‚Üê Finset.coe_image] at hle ‚ä¢
  exact hi.affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one hle hc"
Mathlib/MeasureTheory/Decomposition/Jordan.lean,MeasureTheory.SignedMeasure.mutuallySingular_ennreal_iff,mutuallySingular_ennreal_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  constructor
  ¬∑ rintro ‚ü®u, hmeas, hu‚ÇÅ, hu‚ÇÇ‚ü©
    obtain ‚ü®i, hi‚ÇÅ, hi‚ÇÇ, hi‚ÇÉ, hpos, hneg‚ü© := s.toJordanDecomposition_spec
    refine' ‚ü®u, hmeas, _, _‚ü©
    ¬∑ rw [totalVariation, Measure.add_apply, hpos, hneg, toMeasureOfZeroLE_apply _ _ _ hmeas,
        toMeasureOfLEZero_apply _ _ _ hmeas]
      simp [hu‚ÇÅ _ (Set.inter_subset_right _ _), ‚Üê NNReal.eq_iff]
    ¬∑ rw [VectorMeasure.ennrealToMeasure_apply hmeas.compl]
      exact hu‚ÇÇ _ (Set.Subset.refl _)
  ¬∑ rintro ‚ü®u, hmeas, hu‚ÇÅ, hu‚ÇÇ‚ü©
    refine'
      VectorMeasure.MutuallySingular.mk u hmeas
        (fun t htu _ => null_of_totalVariation_zero _ (measure_mono_null htu hu‚ÇÅ)) fun t htv hmt =>
        _
    rw [‚Üê VectorMeasure.ennrealToMeasure_apply hmt]
    exact measure_mono_null htv hu‚ÇÇ","error:  function expected at
  Set.inter_subset_right ?m.97034
term has type
  ?m.97033 ‚àà ?m.97032
error:  unsolved goals
case mp.intro.intro.intro.intro.intro.intro.intro.intro.refine'_1
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù : MeasurableSpace Œ±
s : SignedMeasure Œ±
Œº : VectorMeasure Œ± ‚Ñù‚â•0‚àû
u : Set Œ±
hmeas : MeasurableSet u
hu‚ÇÅ : ‚àÄ t ‚äÜ u, ‚Üës t = 0
hu‚ÇÇ : ‚àÄ t ‚äÜ u·∂ú, ‚ÜëŒº t = 0
i : Set Œ±
hi‚ÇÅ : MeasurableSet i
hi‚ÇÇ : VectorMeasure.restrict 0 i ‚â§ VectorMeasure.restrict s i
hi‚ÇÉ : VectorMeasure.restrict s i·∂ú ‚â§ VectorMeasure.restrict 0 i·∂ú
hpos : s.toJordanDecomposition.posPart = s.toMeasureOfZeroLE i hi‚ÇÅ hi‚ÇÇ
hneg : s.toJordanDecomposition.negPart = s.toMeasureOfLEZero i·∂ú ‚ãØ hi‚ÇÉ
‚ä¢ ‚Üës (i ‚à© u) = 0 ‚àß ‚Üës (i·∂ú ‚à© u) = 0","theorem mutuallySingular_ennreal_iff (s : SignedMeasure Œ±) (Œº : VectorMeasure Œ± ‚Ñù‚â•0‚àû) :
    s ‚üÇ·µ• Œº ‚Üî s.totalVariation ‚üÇ‚Çò Œº.ennrealToMeasure ",":= by
  constructor
  ¬∑ rintro ‚ü®u, hmeas, hu‚ÇÅ, hu‚ÇÇ‚ü©
    obtain ‚ü®i, hi‚ÇÅ, hi‚ÇÇ, hi‚ÇÉ, hpos, hneg‚ü© := s.toJordanDecomposition_spec
    refine ‚ü®u, hmeas, ?_, ?_‚ü©
    ¬∑ rw [totalVariation, Measure.add_apply, hpos, hneg, toMeasureOfZeroLE_apply _ _ _ hmeas,
        toMeasureOfLEZero_apply _ _ _ hmeas]
      simp [hu‚ÇÅ _ Set.inter_subset_right, ‚Üê NNReal.eq_iff]
    ¬∑ rw [VectorMeasure.ennrealToMeasure_apply hmeas.compl]
      exact hu‚ÇÇ _ (Set.Subset.refl _)
  ¬∑ rintro ‚ü®u, hmeas, hu‚ÇÅ, hu‚ÇÇ‚ü©
    refine
      VectorMeasure.MutuallySingular.mk u hmeas
        (fun t htu _ => null_of_totalVariation_zero _ (measure_mono_null htu hu‚ÇÅ)) fun t htv hmt =>
        ?_
    rw [‚Üê VectorMeasure.ennrealToMeasure_apply hmt]
    exact measure_mono_null htv hu‚ÇÇ"
Mathlib/Analysis/Normed/Group/ControlledClosure.lean,controlled_closure_of_complete,controlled_closure_of_complete,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  rintro (h : H) (h_in : h ‚àà K.topologicalClosure)
  by_cases hyp_h : h = 0
  ¬∑ rw [hyp_h]
    use 0
    simp
  set b : ‚Ñï ‚Üí ‚Ñù := fun i => (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
  have b_pos : ‚àÄ i, 0 < b i := by
    intro i
    field_simp [hC]
    exact
      div_pos (mul_pos hŒµ (norm_pos_iff.mpr hyp_h)) (mul_pos (by norm_num : (0 : ‚Ñù) < 2 ^ i * 2) hC)
  obtain
    ‚ü®v : ‚Ñï ‚Üí H, lim_v : Tendsto (fun n : ‚Ñï => ‚àë k in range (n + 1), v k) atTop (ùìù h), v_in :
      ‚àÄ n, v n ‚àà K, hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0, hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n‚ü© :=
    controlled_sum_of_mem_closure h_in b_pos
  have : ‚àÄ n, ‚àÉ m' : G, f m' = v n ‚àß ‚Äñm'‚Äñ ‚â§ C * ‚Äñv n‚Äñ := fun n : ‚Ñï => hyp (v n) (v_in n)
  choose u hu hnorm_u using this
  set s : ‚Ñï ‚Üí G := fun n => ‚àë k in range (n + 1), u k
  have : CauchySeq s := by
    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one
    rintro n (hn : n ‚â• 1)
    calc
      ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ := hnorm_u n
      _ ‚â§ C * b n := by gcongr; exact (hv _ <| Nat.succ_le_iff.mp hn).le
      _ = (1 / 2) ^ n * (Œµ * ‚Äñh‚Äñ / 2) := by simp [mul_div_cancel' _ hC.ne.symm]
      _ = Œµ * ‚Äñh‚Äñ / 2 * (1 / 2) ^ n := mul_comm _ _
  obtain ‚ü®g : G, hg‚ü© := cauchySeq_tendsto_of_complete this
  refine' ‚ü®g, _, _‚ü©
  ¬∑ 
    have : f ‚àò s = fun n => ‚àë k in range (n + 1), v k := by
      ext n
      simp [map_sum, hu]
    rw [‚Üê this] at lim_v
    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v
  ¬∑ 
    suffices : ‚àÄ n, ‚Äñs n‚Äñ ‚â§ (C + Œµ) * ‚Äñh‚Äñ
    exact le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this
    intro n
    have hnorm‚ÇÄ : ‚Äñu 0‚Äñ ‚â§ C * b 0 + C * ‚Äñh‚Äñ := by
      have :=
        calc
          ‚Äñv 0‚Äñ ‚â§ ‚Äñh‚Äñ + ‚Äñv 0 - h‚Äñ := norm_le_insert' _ _
          _ ‚â§ ‚Äñh‚Äñ + b 0 := by gcongr
      calc
        ‚Äñu 0‚Äñ ‚â§ C * ‚Äñv 0‚Äñ := hnorm_u 0
        _ ‚â§ C * (‚Äñh‚Äñ + b 0) := by gcongr
        _ = C * b 0 + C * ‚Äñh‚Äñ := by rw [add_comm, mul_add]
    have : (‚àë k in range (n + 1), C * b k) ‚â§ Œµ * ‚Äñh‚Äñ :=
      calc
        (‚àë k in range (n + 1), C * b k) = (‚àë k in range (n + 1), (1 / 2 : ‚Ñù) ^ k) * (Œµ * ‚Äñh‚Äñ / 2) :=
          by simp only [mul_div_cancel' _ hC.ne.symm, ‚Üê sum_mul]
        _ ‚â§ 2 * (Œµ * ‚Äñh‚Äñ / 2) := by gcongr; apply sum_geometric_two_le
        _ = Œµ * ‚Äñh‚Äñ := mul_div_cancel' _ two_ne_zero
    calc
      ‚Äñs n‚Äñ ‚â§ ‚àë k in range (n + 1), ‚Äñu k‚Äñ := norm_sum_le _ _
      _ = (‚àë k in range n, ‚Äñu (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := (sum_range_succ' _ _)
      _ ‚â§ (‚àë k in range n, C * ‚Äñv (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := by gcongr; apply hnorm_u
      _ ‚â§ (‚àë k in range n, C * b (k + 1)) + (C * b 0 + C * ‚Äñh‚Äñ) := by
        gcongr with k; exact (hv _ k.succ_pos).le
      _ = (‚àë k in range (n + 1), C * b k) + C * ‚Äñh‚Äñ := by rw [‚Üê add_assoc, sum_range_succ']
      _ ‚â§ (C + Œµ) * ‚Äñh‚Äñ := by
        rw [add_comm, add_mul]
        apply add_le_add_left this","error:  unexpected token ':'; expected term
error:  unsolved goals
case h
G : Type u_1
inst‚úù¬≤ : NormedAddCommGroup G
inst‚úù¬π : CompleteSpace G
H : Type u_2
inst‚úù : NormedAddCommGroup H
f : NormedAddGroupHom G H
K : AddSubgroup H
C Œµ : ‚Ñù
hC : 0 < C
hŒµ : 0 < Œµ
hyp : f.SurjectiveOnWith K C
h : H
h_in : h ‚àà K.topologicalClosure
hyp_h : ¬¨h = 0
b : ‚Ñï ‚Üí ‚Ñù := fun i ‚Ü¶ (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
b_pos : ‚àÄ (i : ‚Ñï), 0 < b i
v : ‚Ñï ‚Üí H
lim_v : Tendsto (fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h)
v_in : ‚àÄ (n : ‚Ñï), v n ‚àà K
hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0
hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n
u : ‚Ñï ‚Üí G
hu : ‚àÄ (n : ‚Ñï), f (u n) = v n
hnorm_u : ‚àÄ (n : ‚Ñï), ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ
s : ‚Ñï ‚Üí G := fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), u k
this : CauchySeq s
g : G
hg : Tendsto s atTop (ùìù g)
n : ‚Ñï
‚ä¢ f (s n) = ‚àë k ‚àà range (n + 1), v k","theorem controlled_closure_of_complete {f : NormedAddGroupHom G H} {K : AddSubgroup H} {C Œµ : ‚Ñù}
    (hC : 0 < C) (hŒµ : 0 < Œµ) (hyp : f.SurjectiveOnWith K C) :
    f.SurjectiveOnWith K.topologicalClosure (C + Œµ) ",":= by
  rintro (h : H) (h_in : h ‚àà K.topologicalClosure)
  by_cases hyp_h : h = 0
  ¬∑ rw [hyp_h]
    use 0
    simp
  set b : ‚Ñï ‚Üí ‚Ñù := fun i => (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
  have b_pos (i) : 0 < b i := by field_simp [b, hC, hyp_h]
  obtain
    ‚ü®v : ‚Ñï ‚Üí H, lim_v : Tendsto (fun n : ‚Ñï => ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h), v_in :
      ‚àÄ n, v n ‚àà K, hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0, hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n‚ü© :=
    controlled_sum_of_mem_closure h_in b_pos
  have : ‚àÄ n, ‚àÉ m' : G, f m' = v n ‚àß ‚Äñm'‚Äñ ‚â§ C * ‚Äñv n‚Äñ := fun n : ‚Ñï => hyp (v n) (v_in n)
  choose u hu hnorm_u using this
  set s : ‚Ñï ‚Üí G := fun n => ‚àë k ‚àà range (n + 1), u k
  have : CauchySeq s := by
    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one
    ¬∑ rintro n (hn : n ‚â• 1)
      calc
        ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ := hnorm_u n
        _ ‚â§ C * b n := by gcongr; exact (hv _ <| Nat.succ_le_iff.mp hn).le
        _ = (1 / 2) ^ n * (Œµ * ‚Äñh‚Äñ / 2) := by simp [mul_div_cancel‚ÇÄ _ hC.ne.symm]
        _ = Œµ * ‚Äñh‚Äñ / 2 * (1 / 2) ^ n := mul_comm _ _
  obtain ‚ü®g : G, hg‚ü© := cauchySeq_tendsto_of_complete this
  refine ‚ü®g, ?_, ?_‚ü©
  ¬∑ 
    have : f ‚àò s = fun n => ‚àë k ‚àà range (n + 1), v k := by
      ext n
      simp [s, map_sum, hu]
    rw [‚Üê this] at lim_v
    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v
  ¬∑ 
    suffices ‚àÄ n, ‚Äñs n‚Äñ ‚â§ (C + Œµ) * ‚Äñh‚Äñ from
      le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this
    intro n
    have hnorm‚ÇÄ : ‚Äñu 0‚Äñ ‚â§ C * b 0 + C * ‚Äñh‚Äñ := by
      have :=
        calc
          ‚Äñv 0‚Äñ ‚â§ ‚Äñh‚Äñ + ‚Äñv 0 - h‚Äñ := norm_le_insert' _ _
          _ ‚â§ ‚Äñh‚Äñ + b 0 := by gcongr
      calc
        ‚Äñu 0‚Äñ ‚â§ C * ‚Äñv 0‚Äñ := hnorm_u 0
        _ ‚â§ C * (‚Äñh‚Äñ + b 0) := by gcongr
        _ = C * b 0 + C * ‚Äñh‚Äñ := by rw [add_comm, mul_add]
    have : (‚àë k ‚àà range (n + 1), C * b k) ‚â§ Œµ * ‚Äñh‚Äñ :=
      calc (‚àë k ‚àà range (n + 1), C * b k)
        _ = (‚àë k ‚àà range (n + 1), (1 / 2 : ‚Ñù) ^ k) * (Œµ * ‚Äñh‚Äñ / 2) := by
          simp only [mul_div_cancel‚ÇÄ _ hC.ne.symm, ‚Üê sum_mul]
        _ ‚â§ 2 * (Œµ * ‚Äñh‚Äñ / 2) := by gcongr; apply sum_geometric_two_le
        _ = Œµ * ‚Äñh‚Äñ := mul_div_cancel‚ÇÄ _ two_ne_zero
    calc
      ‚Äñs n‚Äñ ‚â§ ‚àë k ‚àà range (n + 1), ‚Äñu k‚Äñ := norm_sum_le _ _
      _ = (‚àë k ‚àà range n, ‚Äñu (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := sum_range_succ' _ _
      _ ‚â§ (‚àë k ‚àà range n, C * ‚Äñv (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := by gcongr; apply hnorm_u
      _ ‚â§ (‚àë k ‚àà range n, C * b (k + 1)) + (C * b 0 + C * ‚Äñh‚Äñ) := by
        gcongr with k; exact (hv _ k.succ_pos).le
      _ = (‚àë k ‚àà range (n + 1), C * b k) + C * ‚Äñh‚Äñ := by rw [‚Üê add_assoc, sum_range_succ']
      _ ‚â§ (C + Œµ) * ‚Äñh‚Äñ := by
        rw [add_comm, add_mul]
        apply add_le_add_left this"
Mathlib/MeasureTheory/Group/FundamentalDomain.lean,MeasureTheory.IsFundamentalDomain.quotientMeasureEqMeasurePreimage_of_zero,IsFundamentalDomain.quotientMeasureEqMeasurePreimage_of_zero,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  apply fund_dom_s.quotientMeasureEqMeasurePreimage
  ext U meas_U
  simp only [zero_toOuterMeasure, OuterMeasure.coe_zero, Pi.zero_apply]
  convert (measure_inter_null_of_null_right (h := vol_s) (Quotient.mk Œ±_mod_G ‚Åª¬π' U)).symm
  rw [measure_map_restrict_apply (meas_U := meas_U)]",error:  simp made no progress,"theorem IsFundamentalDomain.quotientMeasureEqMeasurePreimage_of_zero
    {s : Set Œ±} (fund_dom_s : IsFundamentalDomain G s ŒΩ)
    (vol_s : ŒΩ s = 0) :
    QuotientMeasureEqMeasurePreimage ŒΩ (0 : Measure (Quotient Œ±_mod_G)) ",":= by
  apply fund_dom_s.quotientMeasureEqMeasurePreimage
  ext U meas_U
  simp only [Measure.coe_zero, Pi.zero_apply]
  convert (measure_inter_null_of_null_right (h := vol_s) (Quotient.mk Œ±_mod_G ‚Åª¬π' U)).symm
  rw [measure_map_restrict_apply (meas_U := meas_U)]"
Mathlib/MeasureTheory/Measure/Content.lean,MeasureTheory.Content.measure_eq_content_of_regular,measure_eq_content_of_regular,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  refine' le_antisymm _ _
  ¬∑ apply ENNReal.le_of_forall_pos_le_add
    intro Œµ Œµpos _
    obtain ‚ü®K', K'_hyp‚ü© := contentRegular_exists_compact Œº H K (ne_bot_of_gt Œµpos)
    calc
      Œº.measure ‚ÜëK ‚â§ Œº.measure (interior ‚ÜëK') := by
        rw [Œº.measure_apply isOpen_interior.measurableSet,
          Œº.measure_apply K.isCompact.measurableSet]
        exact Œº.outerMeasure.mono K'_hyp.left
      _ ‚â§ Œº K' := by
        rw [Œº.measure_apply (IsOpen.measurableSet isOpen_interior)]
        exact Œº.outerMeasure_interior_compacts K'
      _ ‚â§ Œº K + Œµ := K'_hyp.right
  ¬∑ rw [Œº.measure_apply (IsCompact.measurableSet K.isCompact)]
    exact Œº.le_outerMeasure_compacts K","error:  failed to synthesize
  T2Space G
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  T2Space G
use `set_option diagnostics true` to get diagnostic information","theorem measure_eq_content_of_regular (H : MeasureTheory.Content.ContentRegular Œº)
    (K : TopologicalSpace.Compacts G) : Œº.measure ‚ÜëK = Œº K ",":= by
  refine le_antisymm ?_ ?_
  ¬∑ apply ENNReal.le_of_forall_pos_le_add
    intro Œµ Œµpos _
    obtain ‚ü®K', K'_hyp‚ü© := contentRegular_exists_compact Œº H K (ne_bot_of_gt Œµpos)
    calc
      Œº.measure ‚ÜëK ‚â§ Œº.measure (interior ‚ÜëK') := measure_mono K'_hyp.1
      _ ‚â§ Œº K' := by
        rw [Œº.measure_apply (IsOpen.measurableSet isOpen_interior)]
        exact Œº.outerMeasure_interior_compacts K'
      _ ‚â§ Œº K + Œµ := K'_hyp.right
  ¬∑ calc
    Œº K ‚â§ Œº ‚ü®closure K, K.2.closure‚ü© := Œº.mono _ _ subset_closure
    _ ‚â§ Œº.measure (closure K) := by
      rw [Œº.measure_apply (isClosed_closure.measurableSet)]
      exact Œº.le_outerMeasure_compacts _
    _ = Œº.measure K := Measure.OuterRegular.measure_closure_eq_of_isCompact K.2"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.hasIntegral_GP_pderiv,hasIntegral_GP_pderiv,1164cf04af901bdf18b9c65a9e173feb3a0278f9,":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x hx J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine' HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le _ _ _ s hs _ _
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine' .and _ (.and _ _)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) :=
          inter_subset_inter_left _ (closedBall_subset_closedBall hŒ¥.2)
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := (add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ))
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine' this.eventually (ge_mem_nhds _)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine' ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ _‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine' (norm_sub_le _ _).trans (add_le_add _ _)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine' (mul_le_mul_of_nonneg_right _ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
          _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        (‚àè j, |J.upper j - J.lower j|) ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine' (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans _
      refine' (mul_le_mul_of_nonneg_right _ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine' prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => _
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := (dist_le_pi_dist J.upper J.lower (i.succAbove j))
        _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
        _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
        _ ‚â§ 1 / 2 + 1 / 2 := (add_le_add hŒ¥12 hŒ¥12)
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases(nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1 ((Hd x hx).def Œµ'0) with
      ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine' ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => _‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine' (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ _) (hJc rfl)).trans _
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg","error:  dsimp made no progress
error:  invalid field 'def', the environment does not contain 'HasFDerivWithinAt.def'
  Hd x hx
has type
  HasFDerivWithinAt f (f' x) (Box.Icc I) x
error:  invalid field 'def', the environment does not contain 'HasFDerivAtFilter.def'
  Hd x hx
has type
  HasFDerivAtFilter f (f' x) x (ùìù[Box.Icc I] x)
error:  type mismatch
  HŒ¥ ?m.83042
has type
  ?m.83041 ‚àà ?m.81872 : Prop
but is expected to have type
  ‚Äñf y - ?m.83027 - ?m.82967 (y - x)‚Äñ ‚â§ Œµ' * ‚Äñy - x‚Äñ : Prop
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  E","theorem hasIntegral_GP_pderiv (f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E)
    (f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E) (s : Set (Fin (n + 1) ‚Üí ‚Ñù))
    (hs : s.Countable) (Hs : ‚àÄ x ‚àà s, ContinuousWithinAt f (Box.Icc I) x)
    (Hd : ‚àÄ x ‚àà (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :
    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume
      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))
          BoxAdditiveMap.volume -
        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))
          BoxAdditiveMap.volume) ",":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le ?_ ?_ _ s hs ?_ ?_
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine .and ?_ (.and ?_ ?_)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) := by gcongr; exact hŒ¥.2
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ)
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine this.eventually (ge_mem_nhds ?_)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ ?_‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp [F]
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine (norm_sub_le _ _).trans (add_le_add ?_ ?_)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine (mul_le_mul_of_nonneg_right ?_ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
          _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans ?_
      refine (mul_le_mul_of_nonneg_right ?_ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => ?_
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := dist_le_pi_dist J.upper J.lower (i.succAbove j)
        _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
        _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1
      ((Hd x hx).isLittleO.def Œµ'0) with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => ?_‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ ?_) (hJc rfl)).trans ?_
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg"
Mathlib/Data/Real/Sqrt.lean,Real.coe_sqrt,coe_sqrt,57f68575c03ebf22f387c64f95a2043b5f70d1df,":= by
  rw [sqrt_def, Real.toNNReal_coe]","warning:  sqrt does not have a doc string
error:  unknown identifier 'sqrt_def'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.22255
x‚úù y : ‚Ñù
x : ‚Ñù‚â•0
‚ä¢ ‚Üë(NNReal.sqrt x) = ‚àö‚Üëx",theorem coe_sqrt {x : ‚Ñù‚â•0} : (NNReal.sqrt x : ‚Ñù) = ‚àö(x : ‚Ñù) ,":= by
  rw [Real.sqrt, Real.toNNReal_coe]"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,4678cd95af487c57abbbafa86f7e9d18e634af75,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a
  exact ‚ü®_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b
  exact ‚ü®_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine' ‚ü®g + dg, fun y => _, funext hgf‚ü©
    ¬∑ have hay : a < (g + dg) y := by
        rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
        ¬∑ refine' (lt_add_iff_pos_right _).2 _
          calc
            0 < c - g y := sub_pos.2 hac
            _ = dg y := (dga rfl).symm
        ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      refine' ‚ü®x, hxy.le, _‚ü©
      rcases le_total c (g y) with hc | hc
      ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
      ¬∑ calc
          g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
          _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine' ‚ü®g - dg, fun y => _, funext hgf‚ü©
  ¬∑ have hyb : (g - dg) y < b := by
      rcases (hgb y).eq_or_lt with (rfl | hlt)
      ¬∑ refine' (sub_lt_self_iff _).2 _
        calc
          0 < g y - c := sub_pos.2 hcb
          _ = dg y := (dgb rfl).symm
      ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
    rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
    cases' lt_or_le c (g y) with hc hc
    ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
      ¬∑ refine' ‚ü®x, xu, _, hyxu.le‚ü©
        calc
          f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
      ¬∑ have hay : a < (g - dg) y := by
          calc
            a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
            _ < g y - (b - c) := (sub_lt_sub_right hc _)
            _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
        rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
        exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
    ¬∑ refine' ‚ü®xl y, xu, _, hyxu.le‚ü©
      simp [dg0 (Or.inr hc), hxl]","error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/MeasureTheory/Measure/Portmanteau.lean,MeasureTheory.exists_null_frontier_thickening,exists_null_frontier_thickening,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have mbles : ‚àÄ r : ‚Ñù, MeasurableSet (frontier (Metric.thickening r s)) :=
    fun r => isClosed_frontier.measurableSet
  have disjs := Metric.frontier_thickening_disjoint s
  have key := Measure.countable_meas_pos_of_disjoint_iUnion (Œº := Œº) mbles disjs
  have aux := measure_diff_null (s‚ÇÅ := Ioo a b) (Set.Countable.measure_zero key volume)
  have len_pos : 0 < ENNReal.ofReal (b - a) := by simp only [hab, ENNReal.ofReal_pos, sub_pos]
  rw [‚Üê Real.volume_Ioo, ‚Üê aux] at len_pos
  rcases nonempty_of_measure_ne_zero len_pos.ne.symm with ‚ü®r, ‚ü®r_in_Ioo, hr‚ü©‚ü©
  refine' ‚ü®r, r_in_Ioo, _‚ü©
  simpa only [mem_setOf_eq, not_lt, le_zero_iff] using hr","error:  invalid argument name 's‚ÇÅ' for function 'MeasureTheory.measure_diff_null'
error:  unsolved goals
Œ© : Type u_1
inst‚úù¬≥ : PseudoEMetricSpace Œ©
inst‚úù¬≤ : MeasurableSpace Œ©
inst‚úù¬π : OpensMeasurableSpace Œ©
Œº : Measure Œ©
inst‚úù : SigmaFinite Œº
s : Set Œ©
a b : ‚Ñù
hab : a < b
mbles : ‚àÄ (r : ‚Ñù), MeasurableSet (frontier (Metric.thickening r s))
disjs : Pairwise (Disjoint on fun r ‚Ü¶ frontier (Metric.thickening r s))
key : {i | 0 < Œº (frontier (Metric.thickening i s))}.Countable
‚ä¢ ‚àÉ r ‚àà Ioo a b, Œº (frontier (Metric.thickening r s)) = 0","theorem exists_null_frontier_thickening (Œº : Measure Œ©) [SigmaFinite Œº] (s : Set Œ©) {a b : ‚Ñù}
    (hab : a < b) : ‚àÉ r ‚àà Ioo a b, Œº (frontier (Metric.thickening r s)) = 0 ",":= by
  have mbles : ‚àÄ r : ‚Ñù, MeasurableSet (frontier (Metric.thickening r s)) :=
    fun r => isClosed_frontier.measurableSet
  have disjs := Metric.frontier_thickening_disjoint s
  have key := Measure.countable_meas_pos_of_disjoint_iUnion (Œº := Œº) mbles disjs
  have aux := measure_diff_null (s := Ioo a b) (Set.Countable.measure_zero key volume)
  have len_pos : 0 < ENNReal.ofReal (b - a) := by simp only [hab, ENNReal.ofReal_pos, sub_pos]
  rw [‚Üê Real.volume_Ioo, ‚Üê aux] at len_pos
  rcases nonempty_of_measure_ne_zero len_pos.ne.symm with ‚ü®r, ‚ü®r_in_Ioo, hr‚ü©‚ü©
  refine ‚ü®r, r_in_Ioo, ?_‚ü©
  simpa only [mem_setOf_eq, not_lt, le_zero_iff] using hr"
Mathlib/FieldTheory/PolynomialGaloisGroup.lean,Polynomial.Gal.restrictProd_injective,restrictProd_injective,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  by_cases hpq : p * q = 0
  ¬∑ have : Unique (p * q).Gal := by rw [hpq]; infer_instance
    exact fun f g _ => Eq.trans (Unique.eq_default f) (Unique.eq_default g).symm
  intro f g hfg
  classical
  simp only [restrictProd, restrictDvd_def] at hfg
  simp only [dif_neg hpq, MonoidHom.prod_apply, Prod.mk.inj_iff] at hfg
  ext (x hx)
  rw [rootSet_def, Polynomial.map_mul, Polynomial.roots_mul] at hx
  cases' Multiset.mem_add.mp (Multiset.mem_toFinset.mp hx) with h h
  ¬∑ haveI : Fact (p.Splits (algebraMap F (p * q).SplittingField)) :=
      ‚ü®splits_of_splits_of_dvd _ hpq (SplittingField.splits (p * q)) (dvd_mul_right p q)‚ü©
    have key :
      x =
        algebraMap p.SplittingField (p * q).SplittingField
          ((rootsEquivRoots p _).invFun
            ‚ü®x, (@Multiset.mem_toFinset _ (Classical.decEq _) _ _).mpr h‚ü©) :=
      Subtype.ext_iff.mp (Equiv.apply_symm_apply (rootsEquivRoots p _) ‚ü®x, _‚ü©).symm
    rw [key, ‚Üê AlgEquiv.restrictNormal_commutes, ‚Üê AlgEquiv.restrictNormal_commutes]
    exact congr_arg _ (AlgEquiv.ext_iff.mp hfg.1 _)
  ¬∑ haveI : Fact (q.Splits (algebraMap F (p * q).SplittingField)) :=
      ‚ü®splits_of_splits_of_dvd _ hpq (SplittingField.splits (p * q)) (dvd_mul_left q p)‚ü©
    have key :
      x =
        algebraMap q.SplittingField (p * q).SplittingField
          ((rootsEquivRoots q _).invFun
            ‚ü®x, (@Multiset.mem_toFinset _ (Classical.decEq _) _ _).mpr h‚ü©) :=
      Subtype.ext_iff.mp (Equiv.apply_symm_apply (rootsEquivRoots q _) ‚ü®x, _‚ü©).symm
    rw [key, ‚Üê AlgEquiv.restrictNormal_commutes, ‚Üê AlgEquiv.restrictNormal_commutes]
    exact congr_arg _ (AlgEquiv.ext_iff.mp hfg.2 _)
  ¬∑ rwa [Ne.def, mul_eq_zero, map_eq_zero, map_eq_zero, ‚Üê mul_eq_zero]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  map ?f (?m.83612 * ?m.83613)
case neg.h
F : Type u_1
inst‚úù¬≤ : Field F
p q : F[X]
E : Type u_2
inst‚úù¬π : Field E
inst‚úù : Algebra F E
hpq : ¬¨p * q = 0
f g : (p * q).Gal
hfg :
  (restrict p (p * q).SplittingField) f = (restrict p (p * q).SplittingField) g ‚àß
    (restrict q (p * q).SplittingField) f = (restrict q (p * q).SplittingField) g
x : (p * q).SplittingField
hx : x ‚àà ‚Üë((p * q).aroots (p * q).SplittingField).toFinset
‚ä¢ f x = g x",theorem restrictProd_injective : Function.Injective (restrictProd p q) ,":= by
  by_cases hpq : p * q = 0
  ¬∑ have : Unique (p * q).Gal := by rw [hpq]; infer_instance
    exact fun f g _ => Eq.trans (Unique.eq_default f) (Unique.eq_default g).symm
  intro f g hfg
  classical
  simp only [restrictProd, restrictDvd_def] at hfg
  simp only [dif_neg hpq, MonoidHom.prod_apply, Prod.mk.inj_iff] at hfg
  ext (x hx)
  rw [rootSet_def, aroots_mul hpq] at hx
  cases' Multiset.mem_add.mp (Multiset.mem_toFinset.mp hx) with h h
  ¬∑ haveI : Fact (p.Splits (algebraMap F (p * q).SplittingField)) :=
      ‚ü®splits_of_splits_of_dvd _ hpq (SplittingField.splits (p * q)) (dvd_mul_right p q)‚ü©
    have key :
      x =
        algebraMap p.SplittingField (p * q).SplittingField
          ((rootsEquivRoots p _).invFun
            ‚ü®x, (@Multiset.mem_toFinset _ (Classical.decEq _) _ _).mpr h‚ü©) :=
      Subtype.ext_iff.mp (Equiv.apply_symm_apply (rootsEquivRoots p _) ‚ü®x, _‚ü©).symm
    rw [key, ‚Üê AlgEquiv.restrictNormal_commutes, ‚Üê AlgEquiv.restrictNormal_commutes]
    exact congr_arg _ (AlgEquiv.ext_iff.mp hfg.1 _)
  ¬∑ haveI : Fact (q.Splits (algebraMap F (p * q).SplittingField)) :=
      ‚ü®splits_of_splits_of_dvd _ hpq (SplittingField.splits (p * q)) (dvd_mul_left q p)‚ü©
    have key :
      x =
        algebraMap q.SplittingField (p * q).SplittingField
          ((rootsEquivRoots q _).invFun
            ‚ü®x, (@Multiset.mem_toFinset _ (Classical.decEq _) _ _).mpr h‚ü©) :=
      Subtype.ext_iff.mp (Equiv.apply_symm_apply (rootsEquivRoots q _) ‚ü®x, _‚ü©).symm
    rw [key, ‚Üê AlgEquiv.restrictNormal_commutes, ‚Üê AlgEquiv.restrictNormal_commutes]
    exact congr_arg _ (AlgEquiv.ext_iff.mp hfg.2 _)"
Mathlib/Analysis/Complex/PhragmenLindelof.lean,PhragmenLindelof.horizontal_strip,horizontal_strip,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm
  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb
  wlog hC‚ÇÄ : 0 < C generalizing C
  ¬∑ refine' le_of_forall_le_of_dense fun C' hC' => this (fun w hw => _) (fun w hw => _) _
    ¬∑ exact (hle_a _ hw).trans hC'.le
    ¬∑ exact (hle_b _ hw).trans hC'.le
    ¬∑ refine' ((norm_nonneg (f (a * I))).trans (hle_a _ _)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=
    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB
  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with ‚ü®c, hc, B, hO‚ü©
  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)
  have hb' : d * b < œÄ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)
  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))
  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C by
    refine' le_of_tendsto (Tendsto.mono_left _ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ
  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :
    ‚àÉ Œ¥ : ‚Ñù,
      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by
    refine'
      ‚ü®Œµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Œµ‚ÇÄ
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),
        fun w hw => _‚ü©
    replace hw : |im (aff w)| ‚â§ d * b := by
      rw [‚Üê Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,
        mul_le_mul_left hd‚ÇÄ]
    simpa only [re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le
  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by
    refine' fun w hw => (hŒ¥ <| hw.by_cases _ _).trans (Real.exp_le_one_iff.2 _)
    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]
  obtain ‚ü®R, hzR, hR‚ü© :
    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by
    refine' ((eventually_gt_atTop _).and _).exists
    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,
      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0) by
      filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him
      calc
        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ ‚â§ C := hR
      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine' Real.tendsto_exp_atBot.comp _
    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine' Tendsto.atBot_add _ tendsto_const_nhds
      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id
    refine' tendsto_const_nhds.add (tendsto_const_nhds.mul _)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable ‚ÑÇ (g Œµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono (inter_subset_right _ _)
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw
    by_cases him : w.im = a - b ‚à® w.im = a + b
    ¬∑ rw [norm_smul, ‚Üê one_mul C]
      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b) := hw.resolve_left fun h ‚Ü¶ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'
      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)
  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]
    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©","error:  type mismatch
  h‚úù
has type
  Complex.abs (cexp (‚ÜëŒµ * (cexp (aff w) + cexp (-aff w)))) ‚â§ expR (Œµ * Real.cos (d * b) * expR |(aff w).re|) : Prop
but is expected to have type
  Complex.abs (g Œµ w) ‚â§ expR (Œµ * Real.cos (d * b) * expR (d * |w.re|)) : Prop
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'horizontal_strip'
error:  unknown identifier 'horizontal_strip'
error:  no goals to be solved
error:  unknown identifier 'horizontal_strip'
error:  no goals to be solved","theorem horizontal_strip (hfd : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo a b))
    (hB : ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo a b)]
      fun z ‚Ü¶ expR (B * expR (c * |z.re|)))
    (hle_a : ‚àÄ z : ‚ÑÇ, im z = a ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hle_b : ‚àÄ z, im z = b ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hza : a ‚â§ im z)
    (hzb : im z ‚â§ b) : ‚Äñf z‚Äñ ‚â§ C ",":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm
  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb
  wlog hC‚ÇÄ : 0 < C generalizing C
  ¬∑ refine le_of_forall_le_of_dense fun C' hC' => this (fun w hw => ?_) (fun w hw => ?_) ?_
    ¬∑ exact (hle_a _ hw).trans hC'.le
    ¬∑ exact (hle_b _ hw).trans hC'.le
    ¬∑ refine ((norm_nonneg (f (a * I))).trans (hle_a _ ?_)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=
    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB
  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with ‚ü®c, hc, B, hO‚ü©
  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)
  have hb' : d * b < œÄ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)
  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))
  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C by
    refine le_of_tendsto (Tendsto.mono_left ?_ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ
  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :
    ‚àÉ Œ¥ : ‚Ñù,
      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by
    refine
      ‚ü®Œµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Œµ‚ÇÄ
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),
        fun w hw => ?_‚ü©
    replace hw : |im (aff w)| ‚â§ d * b := by
      rw [‚Üê Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,
        mul_le_mul_left hd‚ÇÄ]
    simpa only [aff, re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le
  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by
    refine fun w hw => (hŒ¥ <| hw.by_cases ?_ ?_).trans (Real.exp_le_one_iff.2 ?_)
    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]
  obtain ‚ü®R, hzR, hR‚ü© :
    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by
    refine ((eventually_gt_atTop _).and ?_).exists
    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,
      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0) by
      filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him
      calc
        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ ‚â§ C := hR
      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine Real.tendsto_exp_atBot.comp ?_
    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine Tendsto.atBot_add ?_ tendsto_const_nhds
      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id
    refine tendsto_const_nhds.add (tendsto_const_nhds.mul ?_)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable ‚ÑÇ (g Œµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono inter_subset_right
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw
    by_cases him : w.im = a - b ‚à® w.im = a + b
    ¬∑ rw [norm_smul, ‚Üê one_mul C]
      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b) := hw.resolve_left fun h ‚Ü¶ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'
      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)
  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]
    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©"
Mathlib/MeasureTheory/Integral/Bochner.lean,MeasureTheory.L1.integral_eq_norm_posPart_sub,integral_eq_norm_posPart_sub,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have ae_eq‚ÇÅ : (toSimpleFunc f).posPart =·µê[Œº] (toSimpleFunc (posPart f)).map norm := by
    filter_upwards [posPart_toSimpleFunc f] with _ h
    rw [SimpleFunc.map_apply, h]
    conv_lhs => rw [‚Üê SimpleFunc.posPart_map_norm, SimpleFunc.map_apply]
  have ae_eq‚ÇÇ : (toSimpleFunc f).negPart =·µê[Œº] (toSimpleFunc (negPart f)).map norm := by
    filter_upwards [negPart_toSimpleFunc f] with _ h
    rw [SimpleFunc.map_apply, h]
    conv_lhs => rw [‚Üê SimpleFunc.negPart_map_norm, SimpleFunc.map_apply]
  rw [integral, norm_eq_integral, norm_eq_integral, ‚Üê SimpleFunc.integral_sub]
  ¬∑ show (toSimpleFunc f).integral Œº =
      ((toSimpleFunc (posPart f)).map norm - (toSimpleFunc (negPart f)).map norm).integral Œº
    apply MeasureTheory.SimpleFunc.integral_congr (SimpleFunc.integrable f)
    filter_upwards [ae_eq‚ÇÅ, ae_eq‚ÇÇ] with _ h‚ÇÅ h‚ÇÇ
    show _ = _ - _
    rw [‚Üê h‚ÇÅ, ‚Üê h‚ÇÇ]
    have := (toSimpleFunc f).posPart_sub_negPart
    conv_lhs => rw [‚Üê this]
  ¬∑ exact (SimpleFunc.integrable f).pos_part.congr ae_eq‚ÇÅ
  ¬∑ exact (SimpleFunc.integrable f).neg_part.congr ae_eq‚ÇÇ","error:  unsolved goals
case h
Œ± : Type u_1
E : Type u_2
F : Type u_3
ùïú : Type u_4
inst‚úù¬π‚Å∞ : NormedAddCommGroup E
inst‚úù‚Åπ : NormedAddCommGroup F
m : MeasurableSpace Œ±
Œº : Measure Œ±
inst‚úù‚Å∏ : NormedField ùïú
inst‚úù‚Å∑ : NormedSpace ùïú E
inst‚úù‚Å∂ : NormedSpace ‚Ñù E
inst‚úù‚Åµ : SMulCommClass ‚Ñù ùïú E
F' : Type u_5
inst‚úù‚Å¥ : NormedAddCommGroup F'
inst‚úù¬≥ : NormedSpace ‚Ñù F'
E' : Type u_6
inst‚úù¬≤ : NormedAddCommGroup E'
inst‚úù¬π : NormedSpace ‚Ñù E'
inst‚úù : NormedSpace ùïú E'
f : ‚Ü•(simpleFunc ‚Ñù 1 Œº)
ae_eq‚ÇÅ : ‚Üë(toSimpleFunc f).posPart =·∂†[ae Œº] ‚Üë(SimpleFunc.map norm (toSimpleFunc (posPart f)))
ae_eq‚ÇÇ : ‚Üë(toSimpleFunc f).negPart =·∂†[ae Œº] ‚Üë(SimpleFunc.map norm (toSimpleFunc (negPart f)))
a‚úù : Œ±
h‚ÇÅ : ‚Üë(toSimpleFunc f).posPart a‚úù = ‚Üë(SimpleFunc.map norm (toSimpleFunc (posPart f))) a‚úù
h‚ÇÇ : ‚Üë(toSimpleFunc f).negPart a‚úù = ‚Üë(SimpleFunc.map norm (toSimpleFunc (negPart f))) a‚úù
this : (toSimpleFunc f).posPart - (toSimpleFunc f).negPart = toSimpleFunc f
‚ä¢ ‚Üë((toSimpleFunc f).posPart - (toSimpleFunc f).negPart) a‚úù =
    ‚Üë(toSimpleFunc f).posPart a‚úù - ‚Üë(toSimpleFunc f).negPart a‚úù
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string",theorem integral_eq_norm_posPart_sub (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) : integral f = ‚ÄñposPart f‚Äñ - ‚ÄñnegPart f‚Äñ ,":= by
  have ae_eq‚ÇÅ : (toSimpleFunc f).posPart =·µê[Œº] (toSimpleFunc (posPart f)).map norm := by
    filter_upwards [posPart_toSimpleFunc f] with _ h
    rw [SimpleFunc.map_apply, h]
    conv_lhs => rw [‚Üê SimpleFunc.posPart_map_norm, SimpleFunc.map_apply]
  have ae_eq‚ÇÇ : (toSimpleFunc f).negPart =·µê[Œº] (toSimpleFunc (negPart f)).map norm := by
    filter_upwards [negPart_toSimpleFunc f] with _ h
    rw [SimpleFunc.map_apply, h]
    conv_lhs => rw [‚Üê SimpleFunc.negPart_map_norm, SimpleFunc.map_apply]
  rw [integral, norm_eq_integral, norm_eq_integral, ‚Üê SimpleFunc.integral_sub]
  ¬∑ show (toSimpleFunc f).integral Œº =
      ((toSimpleFunc (posPart f)).map norm - (toSimpleFunc (negPart f)).map norm).integral Œº
    apply MeasureTheory.SimpleFunc.integral_congr (SimpleFunc.integrable f)
    filter_upwards [ae_eq‚ÇÅ, ae_eq‚ÇÇ] with _ h‚ÇÅ h‚ÇÇ
    show _ = _ - _
    rw [‚Üê h‚ÇÅ, ‚Üê h‚ÇÇ]
    have := (toSimpleFunc f).posPart_sub_negPart
    conv_lhs => rw [‚Üê this]
    rfl
  ¬∑ exact (SimpleFunc.integrable f).pos_part.congr ae_eq‚ÇÅ
  ¬∑ exact (SimpleFunc.integrable f).neg_part.congr ae_eq‚ÇÇ"
Mathlib/Geometry/Euclidean/Sphere/SecondInter.lean,EuclideanGeometry.Sphere.secondInter_secondInter,Sphere.secondInter_secondInter,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  by_cases hv : v = 0; ¬∑ simp [hv]
  have hv' : ‚ü™v, v‚ü´ ‚â† 0 := inner_self_ne_zero.2 hv
  simp only [Sphere.secondInter, vadd_vsub_assoc, vadd_vadd, inner_add_right, inner_smul_right,
    div_mul_cancel _ hv']
  rw [‚Üê @vsub_eq_zero_iff_eq V, vadd_vsub, ‚Üê add_smul, ‚Üê add_div]
  convert zero_smul ‚Ñù (M := V) _
  convert zero_div (G‚ÇÄ := ‚Ñù) _
  ring","error:  application type mismatch
  div_mul_cancel ?m.39024 hv'
argument
  hv'
has type
  ‚ü™v, v‚ü´_‚Ñù ‚â† 0 : Prop
but is expected to have type
  ?m.39022 : Type ?u.39021
info:  Try this: ring_nf
error:  unsolved goals
case h.e'_2.h.e'_5
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
s : Sphere P
p : P
v : V
hv : ¬¨v = 0
hv' : ‚ü™v, v‚ü´_‚Ñù ‚â† 0
‚ä¢ -(‚ü™v, p -·µ• s.center‚ü´_‚Ñù * 4) + ‚ü™v, p -·µ• s.center‚ü´_‚Ñù * ‚ü™v, v‚ü´_‚Ñù * (‚ü™v, v‚ü´_‚Ñù)‚Åª¬π * 4 = 0","theorem Sphere.secondInter_secondInter (s : Sphere P) (p : P) (v : V) :
    s.secondInter (s.secondInter p v) v = p ",":= by
  by_cases hv : v = 0; ¬∑ simp [hv]
  have hv' : ‚ü™v, v‚ü´ ‚â† 0 := inner_self_ne_zero.2 hv
  simp only [Sphere.secondInter, vadd_vsub_assoc, vadd_vadd, inner_add_right, inner_smul_right,
    div_mul_cancel‚ÇÄ _ hv']
  rw [‚Üê @vsub_eq_zero_iff_eq V, vadd_vsub, ‚Üê add_smul, ‚Üê add_div]
  convert zero_smul ‚Ñù (M := V) _
  convert zero_div (G‚ÇÄ := ‚Ñù) _
  ring"
Mathlib/Topology/Homotopy/HomotopyGroup.lean,GenLoop.homotopicTo,homotopicTo,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine Nonempty.map fun H => ‚ü®‚ü®‚ü®fun t => ‚ü®homotopyTo i H t, ?_‚ü©,? _‚ü©?, _,? _?‚ü©, _‚ü©
  ¬∑ rintro y ‚ü®i, iH‚ü©
    rw [homotopyTo_apply, H.eq_fst, p.2]
    all_goals apply Cube.insertAt_boundary; right; exact ‚ü®i, iH‚ü©
  ¬∑ continuity
  iterate 2 intro; ext; erw [homotopyTo_apply, toLoop_apply]; swap
  ¬∑ apply H.apply_zero
  ¬∑ apply H.apply_one
  intro t y yH
  ext; erw [homotopyTo_apply]
  apply H.eq_fst; use i
  rw [funSplitAt_symm_apply, dif_pos rfl]; exact yH","warning:  GenLoop does not have a doc string
error:  unexpected token '?'; expected '‚ü©'","theorem homotopicTo (i : N) {p q : Œ©^ N X x} :
    Homotopic p q ‚Üí (toLoop i p).Homotopic (toLoop i q) ",":= by
  refine Nonempty.map fun H => ‚ü®‚ü®‚ü®fun t => ‚ü®homotopyTo i H t, ?_‚ü©, ?_‚ü©, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ rintro y ‚ü®i, iH‚ü©
    rw [homotopyTo_apply, H.eq_fst, p.2]
    all_goals apply Cube.insertAt_boundary; right; exact ‚ü®i, iH‚ü©
  ¬∑ continuity
  iterate 2 intro; ext; erw [homotopyTo_apply, toLoop_apply]; swap
  ¬∑ apply H.apply_zero
  ¬∑ apply H.apply_one
  intro t y yH
  ext; erw [homotopyTo_apply]
  apply H.eq_fst; use i
  rw [funSplitAt_symm_apply, dif_pos rfl]; exact yH"
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean,Embedding.comp_stronglyMeasurable_iff,_root_.Embedding.comp_stronglyMeasurable_iff,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  letI := pseudoMetrizableSpacePseudoMetric Œ≥
  borelize Œ≤ Œ≥
  refine'
    ‚ü®fun H => stronglyMeasurable_iff_measurable_separable.2 ‚ü®_, _‚ü©, fun H =>
      hg.continuous.comp_stronglyMeasurable H‚ü©
  ¬∑ let G : Œ≤ ‚Üí range g := rangeFactorization g
    have hG : ClosedEmbedding G :=
      { hg.codRestrict _ _ with
        closed_range := by
          rw [surjective_onto_range.range_eq]
          exact isClosed_univ }
    have : Measurable (G ‚àò f) := Measurable.subtype_mk H.measurable
    exact hG.measurableEmbedding.measurable_comp_iff.1 this
  ¬∑ have : IsSeparable (g ‚Åª¬π' range (g ‚àò f)) := hg.isSeparable_preimage H.isSeparable_range
    rwa [range_comp, hg.inj.preimage_image] at this",error:  'closed_range' is not a field of structure 'ClosedEmbedding',"theorem _root_.Embedding.comp_stronglyMeasurable_iff {m : MeasurableSpace Œ±} [TopologicalSpace Œ≤]
    [PseudoMetrizableSpace Œ≤] [TopologicalSpace Œ≥] [PseudoMetrizableSpace Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤}
    (hg : Embedding g) : (StronglyMeasurable fun x => g (f x)) ‚Üî StronglyMeasurable f ",":= by
  letI := pseudoMetrizableSpacePseudoMetric Œ≥
  borelize Œ≤ Œ≥
  refine
    ‚ü®fun H => stronglyMeasurable_iff_measurable_separable.2 ‚ü®?_, ?_‚ü©, fun H =>
      hg.continuous.comp_stronglyMeasurable H‚ü©
  ¬∑ let G : Œ≤ ‚Üí range g := rangeFactorization g
    have hG : ClosedEmbedding G :=
      { hg.codRestrict _ _ with
        isClosed_range := by
          rw [surjective_onto_range.range_eq]
          exact isClosed_univ }
    have : Measurable (G ‚àò f) := Measurable.subtype_mk H.measurable
    exact hG.measurableEmbedding.measurable_comp_iff.1 this
  ¬∑ have : IsSeparable (g ‚Åª¬π' range (g ‚àò f)) := hg.isSeparable_preimage H.isSeparable_range
    rwa [range_comp, hg.inj.preimage_image] at this"
Mathlib/SetTheory/Game/Basic.lean,SetTheory.PGame.zero_mul_equiv,zero_mul_equiv,223a00599681b25ea76850be1d4dde806a1f4e95,":=
  x.zero_mul.equiv","error:  invalid field 'zero_mul', the environment does not contain 'SetTheory.PGame.zero_mul'
  x
has type
  PGame",theorem zero_mul_equiv (x : PGame) : 0 * x ‚âà 0 ,":=
  (zeroMulRelabelling x).equiv"
Mathlib/Data/Nat/Cast/Basic.lean,nsmul_eq_mul',_root_.nsmul_eq_mul',151eb46ac9da80421706d0822fba0ae70d6ae557,":= by
  induction n with
  | zero => rw [zero_nsmul, Nat.cast_zero, mul_zero]
  | succ n ih => rw [succ_nsmul', ih, Nat.cast_succ, mul_add, mul_one]","error:  unsolved goals
case succ
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù : NonAssocSemiring Œ±
a : Œ±
n : ‚Ñï
ih : n ‚Ä¢ a = a * ‚Üën
‚ä¢ a + a * ‚Üën = a * ‚Üën + a",lemma _root_.nsmul_eq_mul' (a : Œ±) (n : ‚Ñï) : n ‚Ä¢ a = a * n ,":= by
  induction n with
  | zero => rw [zero_nsmul, Nat.cast_zero, mul_zero]
  | succ n ih => rw [succ_nsmul, ih, Nat.cast_succ, mul_add, mul_one]"
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,AffineSubspace.parallel_iff_direction_eq_and_eq_bot_iff_eq_bot,parallel_iff_direction_eq_and_eq_bot_iff_eq_bot,8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85,":= by
  refine ‚ü®fun h => ‚ü®h.direction_eq, ?_, ?_‚ü©, fun h =?> _‚ü©
  ¬∑ rintro rfl
    exact bot_parallel_iff_eq_bot.1 h
  ¬∑ rintro rfl
    exact parallel_bot_iff_eq_bot.1 h
  ¬∑ rcases h with ‚ü®hd, hb‚ü©
    by_cases hs‚ÇÅ : s‚ÇÅ = ‚ä•
    ¬∑ rw [hs‚ÇÅ, bot_parallel_iff_eq_bot]
      exact hb.1 hs‚ÇÅ
    ¬∑ have hs‚ÇÇ : s‚ÇÇ ‚â† ‚ä• := hb.not.1 hs‚ÇÅ
      rcases (nonempty_iff_ne_bot s‚ÇÅ).2 hs‚ÇÅ with ‚ü®p‚ÇÅ, hp‚ÇÅ‚ü©
      rcases (nonempty_iff_ne_bot s‚ÇÇ).2 hs‚ÇÇ with ‚ü®p‚ÇÇ, hp‚ÇÇ‚ü©
      refine ‚ü®p‚ÇÇ -·µ• p‚ÇÅ, (eq_iff_direction_eq_of_mem hp‚ÇÇ ?_).2 ?_‚ü©
      ¬∑ rw [mem_map]
        refine ‚ü®p‚ÇÅ, hp‚ÇÅ, ?_‚ü©
        simp
      ¬∑ simpa using hd.symm","warning:  @AffineSubspace.Parallel does not have a doc string
error:  unexpected token '='; expected '‚Ü¶', '=>'
error:  unsolved goals
case refine_1
k : Type u_1
V : Type u_2
P : Type u_3
inst‚úù¬≥ : Ring k
inst‚úù¬≤ : AddCommGroup V
inst‚úù¬π : Module k V
inst‚úù : AffineSpace V P
s‚ÇÅ s‚ÇÇ : AffineSubspace k P
h : s‚ÇÅ ‚à• s‚ÇÇ
‚ä¢ s‚ÇÅ = ‚ä• ‚Üí s‚ÇÇ = ‚ä•

case refine_2
k : Type u_1
V : Type u_2
P : Type u_3
inst‚úù¬≥ : Ring k
inst‚úù¬≤ : AddCommGroup V
inst‚úù¬π : Module k V
inst‚úù : AffineSpace V P
s‚ÇÅ s‚ÇÇ : AffineSubspace k P
h : s‚ÇÅ ‚à• s‚ÇÇ
‚ä¢ s‚ÇÇ = ‚ä• ‚Üí s‚ÇÅ = ‚ä•","theorem parallel_iff_direction_eq_and_eq_bot_iff_eq_bot {s‚ÇÅ s‚ÇÇ : AffineSubspace k P} :
    s‚ÇÅ ‚à• s‚ÇÇ ‚Üî s‚ÇÅ.direction = s‚ÇÇ.direction ‚àß (s‚ÇÅ = ‚ä• ‚Üî s‚ÇÇ = ‚ä•) ",":= by
  refine ‚ü®fun h => ‚ü®h.direction_eq, ?_, ?_‚ü©, fun h => ?_‚ü©
  ¬∑ rintro rfl
    exact bot_parallel_iff_eq_bot.1 h
  ¬∑ rintro rfl
    exact parallel_bot_iff_eq_bot.1 h
  ¬∑ rcases h with ‚ü®hd, hb‚ü©
    by_cases hs‚ÇÅ : s‚ÇÅ = ‚ä•
    ¬∑ rw [hs‚ÇÅ, bot_parallel_iff_eq_bot]
      exact hb.1 hs‚ÇÅ
    ¬∑ have hs‚ÇÇ : s‚ÇÇ ‚â† ‚ä• := hb.not.1 hs‚ÇÅ
      rcases (nonempty_iff_ne_bot s‚ÇÅ).2 hs‚ÇÅ with ‚ü®p‚ÇÅ, hp‚ÇÅ‚ü©
      rcases (nonempty_iff_ne_bot s‚ÇÇ).2 hs‚ÇÇ with ‚ü®p‚ÇÇ, hp‚ÇÇ‚ü©
      refine ‚ü®p‚ÇÇ -·µ• p‚ÇÅ, (eq_iff_direction_eq_of_mem hp‚ÇÇ ?_).2 ?_‚ü©
      ¬∑ rw [mem_map]
        refine ‚ü®p‚ÇÅ, hp‚ÇÅ, ?_‚ü©
        simp
      ¬∑ simpa using hd.symm"
Mathlib/Data/List/Cycle.lean,List.prev_reverse_eq_next,prev_reverse_eq_next,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  obtain ‚ü®k, hk, rfl‚ü© := nthLe_of_mem hx
  have lpos : 0 < l.length := k.zero_le.trans_lt hk
  have key : l.length - 1 - k < l.length :=
    (Nat.sub_le _ _).trans_lt (tsub_lt_self lpos Nat.succ_pos')
  rw [‚Üê nthLe_pmap l.next (fun _ h => h) (by simpa using hk)]
  simp_rw [‚Üê nthLe_reverse l k (key.trans_le (by simp)), pmap_next_eq_rotate_one _ h]
  rw [‚Üê nthLe_pmap l.reverse.prev fun _ h => h]
  ¬∑ simp_rw [pmap_prev_eq_rotate_length_sub_one _ (nodup_reverse.mpr h), rotate_reverse,
      length_reverse, Nat.mod_eq_of_lt (tsub_lt_self lpos Nat.succ_pos'),
      tsub_tsub_cancel_of_le (Nat.succ_le_of_lt lpos)]
    rw [‚Üê nthLe_reverse]
    ¬∑ simp [tsub_tsub_cancel_of_le (Nat.le_sub_one_of_lt hk)]
    ¬∑ simpa using (Nat.sub_le _ _).trans_lt (tsub_lt_self lpos Nat.succ_pos')
    ¬∑ simpa","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
error:  application type mismatch
  LE.le.trans_lt (Nat.sub_le (l.length - 1) k) (tsub_lt_self ?m.58380 ?m.58464)
argument
  tsub_lt_self ?m.58380 ?m.58464
has type
  @LT.lt ‚Ñï (@Preorder.toLT ‚Ñï (@PartialOrder.toPreorder ‚Ñï OrderedAddCommMonoid.toPartialOrder)) (l.length - 1)
    l.length : Prop
but is expected to have type
  @LT.lt ‚Ñï (@Preorder.toLT ‚Ñï (@PartialOrder.toPreorder ‚Ñï SemilatticeInf.toPartialOrder)) (l.length - 1) l.length : Prop","theorem prev_reverse_eq_next (l : List Œ±) (h : Nodup l) (x : Œ±) (hx : x ‚àà l) :
    prev l.reverse x (mem_reverse.mpr hx) = next l x hx ",":= by
  obtain ‚ü®k, hk, rfl‚ü© := nthLe_of_mem hx
  have lpos : 0 < l.length := k.zero_le.trans_lt hk
  have key : l.length - 1 - k < l.length := by omega
  rw [‚Üê nthLe_pmap l.next (fun _ h => h) (by simpa using hk)]
  simp_rw [‚Üê nthLe_reverse l k (key.trans_le (by simp)), pmap_next_eq_rotate_one _ h]
  rw [‚Üê nthLe_pmap l.reverse.prev fun _ h => h]
  ¬∑ simp_rw [pmap_prev_eq_rotate_length_sub_one _ (nodup_reverse.mpr h), rotate_reverse,
      length_reverse, Nat.mod_eq_of_lt (Nat.sub_lt lpos Nat.succ_pos'),
      Nat.sub_sub_self (Nat.succ_le_of_lt lpos)]
    rw [‚Üê nthLe_reverse]
    ¬∑ simp [Nat.sub_sub_self (Nat.le_sub_one_of_lt hk)]
    ¬∑ simpa using (Nat.sub_le _ _).trans_lt (Nat.sub_lt lpos Nat.succ_pos')
  ¬∑ simpa"
Mathlib/Data/Set/NAry.lean,Set.image2_subset,image2_subset,40d7ce18c4ab0f4427db2ca13c8c175781a09a5b,":= by
  rintro _ ‚ü®a, b, ha, hb, rfl‚ü©
  exact mem_image2_of_mem (hs ha) (ht hb)","error:  application type mismatch
  hs ha
argument
  ha
has type
  Œ≤ : Type u_3
but is expected to have type
  a ‚àà s : Prop",theorem image2_subset (hs : s ‚äÜ s') (ht : t ‚äÜ t') : image2 f s t ‚äÜ image2 f s' t' ,":= by
  rintro _ ‚ü®a, ha, b, hb, rfl‚ü©
  exact mem_image2_of_mem (hs ha) (ht hb)"
Mathlib/NumberTheory/NumberField/Embeddings.lean,NumberField.InfinitePlace.mem_orbit_iff,mem_orbit_iff,4fda6f75a24576d1bee6410cfcd8c2d587eaab96,":= by
  refine ‚ü®?_, exists_smul_eq_of_comap_eq w w'‚ü©
  rintro ‚ü®œÉ, rfl : œÉ ‚Ä¢ w = w'‚ü©
  rw [‚Üê mk_embedding w, comap_mk, smul_mk, comap_mk]
  congr 1; ext1; simp","error:  application type mismatch
  exists_smul_eq_of_comap_eq w
argument
  w
has type
  InfinitePlace K : Type u_2
but is expected to have type
  ?m.299442.comap (algebraMap ?m.299436 ?m.299438) = ?m.299443.comap (algebraMap ?m.299436 ?m.299438) : Prop","lemma mem_orbit_iff [IsGalois k K] {w w' : InfinitePlace K} :
    w' ‚àà MulAction.orbit (K ‚âÉ‚Çê[k] K) w ‚Üî w.comap (algebraMap k K) = w'.comap (algebraMap k K) ",":= by
  refine ‚ü®?_, exists_smul_eq_of_comap_eq‚ü©
  rintro ‚ü®œÉ, rfl : œÉ ‚Ä¢ w = w'‚ü©
  rw [‚Üê mk_embedding w, comap_mk, smul_mk, comap_mk]
  congr 1; ext1; simp"
Mathlib/GroupTheory/CommutingProbability.lean,DihedralGroup.commProb_odd,commProb_odd,84f6d10f9a51f8c6472ec85f7cb1f39056781a29,":= by
  rw [commProb_def', DihedralGroup.card_conjClasses_odd hn, nat_card]
  qify [show 2 ‚à£ n + 3 by rw [Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.odd_iff.mp hn]; rfl]
  rw [div_div, ‚Üê mul_assoc]
  congr","error:  no goals to be solved
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a / ?b / ?c
M : Type u_1
inst‚úù¬≥ : Mul M
inst‚úù¬≤ : Finite M
G : Type u_2
inst‚úù¬π : Group G
inst‚úù : Finite G
H : Subgroup G
n : ‚Ñï
hn : Odd n
‚ä¢ ‚Üë((n + 3) / 2) / (2 * ‚Üën) = (‚Üën + 3) / (4 * ‚Üën)","lemma commProb_odd {n : ‚Ñï} (hn : Odd n) :
    commProb (DihedralGroup n) = (n + 3) / (4 * n) ",":= by
  rw [commProb_def', DihedralGroup.card_conjClasses_odd hn, nat_card]
  qify [show 2 ‚à£ n + 3 by rw [Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.odd_iff.mp hn]]
  rw [div_div, ‚Üê mul_assoc]
  congr"
Mathlib/CategoryTheory/Adjunction/AdjointFunctorTheorems.lean,CategoryTheory.Limits.hasColimits_of_hasLimits_of_isCoseparating,hasColimits_of_hasLimits_of_isCoseparating,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  { has_colimits_of_shape := fun _ _ =>
      hasColimitsOfShape_iff_isRightAdjoint_const.2
        ‚ü®isRightAdjointOfPreservesLimitsOfIsCoseparating hùí¢ _‚ü© }",error:  unknown identifier 'isRightAdjointOfPreservesLimitsOfIsCoseparating',"theorem hasColimits_of_hasLimits_of_isCoseparating [HasLimits C] [WellPowered C] {ùí¢ : Set C}
    [Small.{v} ùí¢] (hùí¢ : IsCoseparating ùí¢) : HasColimits C ",":=
  { has_colimits_of_shape := fun _ _ =>
      hasColimitsOfShape_iff_isRightAdjoint_const.2
        (isRightAdjoint_of_preservesLimits_of_isCoseparating hùí¢ _) }"
Mathlib/Combinatorics/SimpleGraph/Clique.lean,SimpleGraph.cliqueFree_of_card_lt,cliqueFree_of_card_lt,4bb12799777bcb562597d8e6aeb57fabf0b92881,":= by
  by_contra h
  refine' Nat.lt_le_antisymm hc _
  rw [cliqueFree_iff, not_isEmpty_iff] at h
  simpa only [Fintype.card_fin] using Fintype.card_le_of_embedding h.some.toEmbedding","error:  unknown constant 'Nat.lt_le_antisymm'
error:  no goals to be solved",theorem cliqueFree_of_card_lt [Fintype Œ±] (hc : card Œ± < n) : G.CliqueFree n ,":= by
  by_contra h
  refine Nat.lt_le_asymm hc ?_
  rw [cliqueFree_iff, not_isEmpty_iff] at h
  simpa only [Fintype.card_fin] using Fintype.card_le_of_embedding h.some.toEmbedding"
Mathlib/Analysis/SpecialFunctions/Pow/Real.lean,Complex.norm_natCast_cpow_of_pos,norm_natCast_cpow_of_pos,5972f1186b2ca6a1d047e1c045628b6e94c2181b,":= by
  rw [norm_eq_abs, ‚Üê ofReal_nat_cast, abs_cpow_eq_rpow_re_of_pos (Nat.cast_pos.mpr hn) _]","error:  unknown identifier 'ofReal_nat_cast'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.65118
n : ‚Ñï
hn : 0 < n
s : ‚ÑÇ
‚ä¢ abs (‚Üën ^ s) = ‚Üën ^ s.re","lemma norm_natCast_cpow_of_pos {n : ‚Ñï} (hn : 0 < n) (s : ‚ÑÇ) :
    ‚Äñ(n : ‚ÑÇ) ^ s‚Äñ = (n : ‚Ñù) ^ (s.re) ",":= by
  rw [norm_eq_abs, ‚Üê ofReal_natCast, abs_cpow_eq_rpow_re_of_pos (Nat.cast_pos.mpr hn) _]"
Mathlib/Topology/Separation.lean,minimal_nonempty_open_subsingleton,minimal_nonempty_open_subsingleton,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  clear Y 
  refine fun x hx y hy => of_not_not fun hxy => ?_
  rcases exists_isOpen_xor'_mem hxy with ‚ü®U, hUo, hU‚ü©
  wlog h : x ‚àà U ‚àß y ‚àâ U
  ¬∑ exact this hs hmin y hy x hx (Ne.symm hxy) U hUo hU.symm (hU.resolve_left h)
  cases' h with hxU hyU
  have : s ‚à© U = s := hmin (s ‚à© U) (inter_subset_left _ _) ‚ü®x, hx, hxU‚ü© (hs.inter hUo)
  exact hyU (this.symm.subset hy).2","error:  function expected at
  inter_subset_left ?m.38981
term has type
  ?m.38980 ‚àà ?m.38978","theorem minimal_nonempty_open_subsingleton [T0Space X] {s : Set X} (hs : IsOpen s)
    (hmin : ‚àÄ t, t ‚äÜ s ‚Üí t.Nonempty ‚Üí IsOpen t ‚Üí t = s) : s.Subsingleton ",":= by
  clear Y 
  refine fun x hx y hy => of_not_not fun hxy => ?_
  rcases exists_isOpen_xor'_mem hxy with ‚ü®U, hUo, hU‚ü©
  wlog h : x ‚àà U ‚àß y ‚àâ U
  ¬∑ exact this hs hmin y hy x hx (Ne.symm hxy) U hUo hU.symm (hU.resolve_left h)
  cases' h with hxU hyU
  have : s ‚à© U = s := hmin (s ‚à© U) inter_subset_left ‚ü®x, hx, hxU‚ü© (hs.inter hUo)
  exact hyU (this.symm.subset hy).2"
Mathlib/Analysis/Complex/Liouville.lean,Differentiable.apply_eq_apply_of_bounded,apply_eq_apply_of_bounded,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  set g : ‚ÑÇ ‚Üí F := f ‚àò fun t : ‚ÑÇ => t ‚Ä¢ (w - z) + z
  suffices g 0 = g 1 by simpa
  apply liouville_theorem_aux
  exacts [hf.comp ((differentiable_id.smul_const (w - z)).add_const z),
    hb.subset (range_comp_subset_range _ _)]","error:  tactic 'assumption' failed
E : Type u
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedSpace ‚ÑÇ E
F : Type v
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : NormedSpace ‚ÑÇ F
f : E ‚Üí F
hf : Differentiable ‚ÑÇ f
hb : Bornology.IsBounded (range f)
z w : E
g : ‚ÑÇ ‚Üí F := f ‚àò fun t ‚Ü¶ t ‚Ä¢ (w - z) + z
this : g 0 = g 1
‚ä¢ f z = f w","theorem apply_eq_apply_of_bounded {f : E ‚Üí F} (hf : Differentiable ‚ÑÇ f) (hb : IsBounded (range f))
    (z w : E) : f z = f w ",":= by
  set g : ‚ÑÇ ‚Üí F := f ‚àò fun t : ‚ÑÇ => t ‚Ä¢ (w - z) + z
  suffices g 0 = g 1 by simpa [g]
  apply liouville_theorem_aux
  exacts [hf.comp ((differentiable_id.smul_const (w - z)).add_const z),
    hb.subset (range_comp_subset_range _ _)]"
Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean,WeierstrassCurve.Jacobian.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp [nonsingular_iff, equation_iff] at hP hQ
  have hPx : P x ‚â† 0 := fun h => by simp [h] at hP; simp [hP] at hP
  have hQx : Q x ‚â† 0 := fun h => by simp [h] at hQ; simp [hQ] at hQ
  have hPy : P y ‚â† 0 := fun h => by simp [h] at hP; exact hPx <| pow_eq_zero hP.left.symm
  have hQy : Q y ‚â† 0 := fun h => by simp [h] at hQ; exact hQx <| pow_eq_zero hQ.left.symm
  use Units.mk0 _ <| mul_ne_zero (div_ne_zero hPy hPx) (div_ne_zero hQx hQy)
  simp? [smul_fin3, mul_pow, div_pow] says
    simp only [Fin.isValue, Units.mk0_mul, Nat.succ_eq_add_one, Nat.reduceAdd,
      smul_fin3, Units.val_mul, Units.val_mk0, mul_pow, div_pow, Matrix.cons_val_zero,
      Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons, mul_zero]
  congr! 2
  ¬∑ field_simp [hP.left, hQ.left]
    ring1
  ¬∑ field_simp [‚Üê hP.left, ‚Üê hQ.left]
    ring1","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ![P x, P y, P z]
R : Type u
inst‚úù¬π : CommRing R
W' : Jacobian R
F : Type v
inst‚úù : Field F
W : Jacobian F
P Q : Fin 3 ‚Üí F
hP : W.Nonsingular P
hQ : W.Nonsingular Q
hPz : P z = 0
hQz : Q z = 0
‚ä¢ P ‚âà Q","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  have hPx : IsUnit <| P x := isUnit_X_of_Z_eq_zero hP hPz
  have hPy : IsUnit <| P y := isUnit_Y_of_Z_eq_zero hP hPz
  have hQx : IsUnit <| Q x := isUnit_X_of_Z_eq_zero hQ hQz
  have hQy : IsUnit <| Q y := isUnit_Y_of_Z_eq_zero hQ hQz
  simp only [nonsingular_of_Z_eq_zero, equation_of_Z_eq_zero, hPz, hQz] at hP hQ
  use (hPy.unit / hPx.unit) * (hQx.unit / hQy.unit)
  simp only [Units.smul_def, smul_fin3, Units.val_mul, Units.val_div_eq_div_val, IsUnit.unit_spec,
    mul_pow, div_pow, hQz, mul_zero]
  conv_rhs => rw [‚Üê fin3_def P, hPz]
  congr! 2
  ¬∑ rw [hP.left, pow_succ, (hPx.pow 2).mul_div_cancel_left, hQ.left, pow_succ _ 2,
      (hQx.pow 2).div_mul_cancel_left, hQx.inv_mul_cancel_right]
  ¬∑ rw [‚Üê hP.left, pow_succ, (hPy.pow 2).mul_div_cancel_left, ‚Üê hQ.left, pow_succ _ 2,
      (hQy.pow 2).div_mul_cancel_left, hQy.inv_mul_cancel_right]"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.Measure.hausdorffMeasure_zero_or_top,hausdorffMeasure_zero_or_top,693fd79515903b10b1d31f10dccfc49e633cf7ee,":= by
  by_contra' H
  suffices ‚àÄ c : ‚Ñù‚â•0, c ‚â† 0 ‚Üí ŒºH[d‚ÇÇ] s ‚â§ c * ŒºH[d‚ÇÅ] s by
    rcases ENNReal.exists_nnreal_pos_mul_lt H.2 H.1 with ‚ü®c, hc0, hc‚ü©
    exact hc.not_le (this c (pos_iff_ne_zero.1 hc0))
  intro c hc
  refine' le_iff'.1 (mkMetric_mono_smul ENNReal.coe_ne_top (mod_cast hc) _) s
  have : 0 < ((c : ‚Ñù‚â•0‚àû) ^ (d‚ÇÇ - d‚ÇÅ)‚Åª¬π) := by
    rw [ENNReal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, Ne.def, ENNReal.coe_eq_zero,
      NNReal.rpow_eq_zero_iff]
    exact mt And.left hc
  filter_upwards [Ico_mem_nhdsWithin_Ici ‚ü®le_rfl, this‚ü©]
  rintro r ‚ü®hr‚ÇÄ, hrc‚ü©
  lift r to ‚Ñù‚â•0 using ne_top_of_lt hrc
  rw [Pi.smul_apply, smul_eq_mul,
    ‚Üê ENNReal.div_le_iff_le_mul (Or.inr ENNReal.coe_ne_top) (Or.inr <| mt ENNReal.coe_eq_zero.1 hc)]
  rcases eq_or_ne r 0 with (rfl | hr‚ÇÄ)
  ¬∑ rcases lt_or_le 0 d‚ÇÇ with (h‚ÇÇ | h‚ÇÇ)
    ¬∑ simp only [h‚ÇÇ, ENNReal.zero_rpow_of_pos, zero_le, ENNReal.zero_div, ENNReal.coe_zero]
    ¬∑ simp only [h.trans_le h‚ÇÇ, ENNReal.div_top, zero_le, ENNReal.zero_rpow_of_neg,
        ENNReal.coe_zero]
  ¬∑ have : (r : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne.def] using hr‚ÇÄ
    rw [‚Üê ENNReal.rpow_sub _ _ this ENNReal.coe_ne_top]
    refine' (ENNReal.rpow_lt_rpow hrc (sub_pos.2 h)).le.trans _
    rw [‚Üê ENNReal.rpow_mul, inv_mul_cancel (sub_pos.2 h).ne', ENNReal.rpow_one]","error:  unknown tactic
error:  unsolved goals
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬≥ : EMetricSpace X
inst‚úù¬≤ : EMetricSpace Y
inst‚úù¬π : MeasurableSpace X
inst‚úù : BorelSpace X
d‚ÇÅ d‚ÇÇ : ‚Ñù
h : d‚ÇÅ < d‚ÇÇ
s : Set X
‚ä¢ ŒºH[d‚ÇÇ] s = 0 ‚à® ŒºH[d‚ÇÅ] s = ‚ä§","theorem hausdorffMeasure_zero_or_top {d‚ÇÅ d‚ÇÇ : ‚Ñù} (h : d‚ÇÅ < d‚ÇÇ) (s : Set X) :
    ŒºH[d‚ÇÇ] s = 0 ‚à® ŒºH[d‚ÇÅ] s = ‚àû ",":= by
  by_contra! H
  suffices ‚àÄ c : ‚Ñù‚â•0, c ‚â† 0 ‚Üí ŒºH[d‚ÇÇ] s ‚â§ c * ŒºH[d‚ÇÅ] s by
    rcases ENNReal.exists_nnreal_pos_mul_lt H.2 H.1 with ‚ü®c, hc0, hc‚ü©
    exact hc.not_le (this c (pos_iff_ne_zero.1 hc0))
  intro c hc
  refine le_iff'.1 (mkMetric_mono_smul ENNReal.coe_ne_top (mod_cast hc) ?_) s
  have : 0 < ((c : ‚Ñù‚â•0‚àû) ^ (d‚ÇÇ - d‚ÇÅ)‚Åª¬π) := by
    rw [ENNReal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, Ne, ENNReal.coe_eq_zero,
      NNReal.rpow_eq_zero_iff]
    exact mt And.left hc
  filter_upwards [Ico_mem_nhdsWithin_Ici ‚ü®le_rfl, this‚ü©]
  rintro r ‚ü®hr‚ÇÄ, hrc‚ü©
  lift r to ‚Ñù‚â•0 using ne_top_of_lt hrc
  rw [Pi.smul_apply, smul_eq_mul,
    ‚Üê ENNReal.div_le_iff_le_mul (Or.inr ENNReal.coe_ne_top) (Or.inr <| mt ENNReal.coe_eq_zero.1 hc)]
  rcases eq_or_ne r 0 with (rfl | hr‚ÇÄ)
  ¬∑ rcases lt_or_le 0 d‚ÇÇ with (h‚ÇÇ | h‚ÇÇ)
    ¬∑ simp only [h‚ÇÇ, ENNReal.zero_rpow_of_pos, zero_le, ENNReal.zero_div, ENNReal.coe_zero]
    ¬∑ simp only [h.trans_le h‚ÇÇ, ENNReal.div_top, zero_le, ENNReal.zero_rpow_of_neg,
        ENNReal.coe_zero]
  ¬∑ have : (r : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using hr‚ÇÄ
    rw [‚Üê ENNReal.rpow_sub _ _ this ENNReal.coe_ne_top]
    refine (ENNReal.rpow_lt_rpow hrc (sub_pos.2 h)).le.trans ?_
    rw [‚Üê ENNReal.rpow_mul, inv_mul_cancel (sub_pos.2 h).ne', ENNReal.rpow_one]"
Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean,CategoryTheory.Limits.colimitLimitToLimitColimit_surjective,colimitLimitToLimitColimit_surjective,a070b1f7d9c5435c82577c26578dcce0cf4e6ad0,":= by
  classical
    intro x
    have z := fun j => jointly_surjective'.{v, v} (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply'.{v,v}, t, FunctorToTypes.map_comp_apply, Colimit.w_apply'.{v,v}, e,
        ‚Üê Limit.w_apply' f, ‚Üê e]
      simp only [Functor.comp_map, Colimit.Œπ_map_apply'.{v,v}, curry_obj_map_app]
    simp_rw [colimit_eq_iff.{v, v}] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (by
            rw [Finset.mem_biUnion]
            refine' ‚ü®j, Finset.mem_univ j, _‚ü©
            rw [Finset.mem_biUnion]
            refine' ‚ü®j', Finset.mem_univ j', _‚ü©
            rw [Finset.mem_image]
            refine' ‚ü®f, Finset.mem_univ _, _‚ü©
            rfl))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      exact k'O
      swap
      ¬∑ rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÅ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÇ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®f, Finset.mem_univ _, _‚ü©
        simp only [true_or_iff, eq_self_iff_true, and_self_iff, Finset.mem_insert, heq_iff_eq]
      ¬∑ rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÉ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÑ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®f', Finset.mem_univ _, _‚ü©
        simp only [eq_self_iff_true, or_true_iff, and_self_iff, Finset.mem_insert,
          Finset.mem_singleton, heq_iff_eq]
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk.{v, v}
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) :=
            by rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) :=
            by rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) :=
            by rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext'
      intro j
      simp only [id.def, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff.{v, v}, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine' ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), _‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","error:  application type mismatch
  jointly_surjective' (limit.œÄ (curry.obj F ‚ãô colim) j x)
argument
  limit.œÄ (curry.obj F ‚ãô colim) j x
has type
  (curry.obj F ‚ãô colim).obj j : Type v
but is expected to have type
  colimit ?m.27488 : Type v
error:  unsolved goals
J : Type u‚ÇÅ
K : Type u‚ÇÇ
inst‚úù‚Å¥ : SmallCategory J
inst‚úù¬≥ : Category.{v‚ÇÇ, u‚ÇÇ} K
inst‚úù¬≤ : Small.{v, u‚ÇÇ} K
inst‚úù¬π : FinCategory J
F : J √ó K ‚•§ Type v
inst‚úù : IsFiltered K
x : limit (curry.obj F ‚ãô colim)
‚ä¢ ‚àÉ a, colimitLimitToLimitColimit F a = x","theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) ",":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ‚Üê Limit.w_apply.{u‚ÇÅ, v, u‚ÇÅ} f, ‚Üê e]
      simp only [Functor.comp_map, Types.Colimit.Œπ_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact k'O
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) := by
            rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) := by
            rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext
      intro j
      simp only [id, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]"
Mathlib/SetTheory/Game/Basic.lean,SetTheory.PGame.mul_zero_equiv,mul_zero_equiv,223a00599681b25ea76850be1d4dde806a1f4e95,":=
  x.mul_zero.equiv","error:  invalid field 'mul_zero', the environment does not contain 'SetTheory.PGame.mul_zero'
  x
has type
  PGame",theorem mul_zero_equiv (x : PGame) : x * 0 ‚âà 0 ,":=
  (mulZeroRelabelling x).equiv"
Mathlib/Algebra/Homology/ExactSequence.lean,CategoryTheory.ComposableArrows.exact_iff_Œ¥‚ÇÄ,exact_iff_Œ¥‚ÇÄ,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  constructor
  ¬∑ intro h
    constructor
    ¬∑ rw [exact‚ÇÇ_iff]; swap
      ¬∑ rw [isComplex‚ÇÇ_iff]
        exact h.toIsComplex.zero 0
      exact h.exact 0 (by linarith)
    ¬∑ exact Exact.mk (IsComplex.mk (fun i hi => h.toIsComplex.zero (i + 1)))
        (fun i hi => h.exact (i + 1))
  ¬∑ rintro ‚ü®h, h‚ÇÄ‚ü©
    refine' Exact.mk (IsComplex.mk (fun i hi => _)) (fun i hi => _)
    ¬∑ obtain _ | i := i
      ¬∑ exact h.toIsComplex.zero 0
      ¬∑ exact h‚ÇÄ.toIsComplex.zero i
    ¬∑ obtain _ | i := i
      ¬∑ exact h.exact 0
      ¬∑ exact h‚ÇÄ.exact i","error:  unknown tactic
error:  unsolved goals
C : Type u_1
inst‚úù¬π : Category.{u_2, u_1} C
inst‚úù : HasZeroMorphisms C
n : ‚Ñï
S‚úù : ComposableArrows C n
S : ComposableArrows C (n + 2)
h : S.Exact
‚ä¢ 0 + 2 ‚â§ n + 2
error:  unsolved goals
case mp.right
C : Type u_1
inst‚úù¬π : Category.{u_2, u_1} C
inst‚úù : HasZeroMorphisms C
n : ‚Ñï
S‚úù : ComposableArrows C n
S : ComposableArrows C (n + 2)
h : S.Exact
‚ä¢ S.Œ¥‚ÇÄ.Exact
error:  unsolved goals
case mpr
C : Type u_1
inst‚úù¬π : Category.{u_2, u_1} C
inst‚úù : HasZeroMorphisms C
n : ‚Ñï
S‚úù : ComposableArrows C n
S : ComposableArrows C (n + 2)
‚ä¢ (mk‚ÇÇ (S.map' 0 1 ‚ãØ ‚ãØ) (S.map' 1 2 ‚ãØ ‚ãØ)).Exact ‚àß S.Œ¥‚ÇÄ.Exact ‚Üí S.Exact","lemma exact_iff_Œ¥‚ÇÄ (S : ComposableArrows C (n + 2)) :
    S.Exact ‚Üî (mk‚ÇÇ (S.map' 0 1) (S.map' 1 2)).Exact ‚àß S.Œ¥‚ÇÄ.Exact ",":= by
  constructor
  ¬∑ intro h
    constructor
    ¬∑ rw [exact‚ÇÇ_iff]; swap
      ¬∑ rw [isComplex‚ÇÇ_iff]
        exact h.toIsComplex.zero 0
      exact h.exact 0 (by omega)
    ¬∑ exact Exact.mk (IsComplex.mk (fun i hi => h.toIsComplex.zero (i + 1)))
        (fun i hi => h.exact (i + 1))
  ¬∑ rintro ‚ü®h, h‚ÇÄ‚ü©
    refine Exact.mk (IsComplex.mk (fun i hi => ?_)) (fun i hi => ?_)
    ¬∑ obtain _ | i := i
      ¬∑ exact h.toIsComplex.zero 0
      ¬∑ exact h‚ÇÄ.toIsComplex.zero i
    ¬∑ obtain _ | i := i
      ¬∑ exact h.exact 0
      ¬∑ exact h‚ÇÄ.exact i"
Mathlib/MeasureTheory/Integral/DivergenceTheorem.lean,MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable_aux‚ÇÅ,integral_divergence_of_hasFDerivWithinAt_off_countable_aux‚ÇÅ,daf56f7104803477ea626b45f8979189439896db,":= by
  simp only [‚Üê set_integral_congr_set_ae (Box.coe_ae_eq_Icc _)]
  have A := (Hi.mono_set Box.coe_subset_Icc).hasBoxIntegral ‚ä• rfl
  have B :=
    hasIntegral_GP_divergence_of_forall_hasDerivWithinAt I f f' (s ‚à© Box.Icc I)
      (hs.mono (inter_subset_left _ _)) (fun x hx => Hc _ hx.2) fun x hx =>
      Hd _ ‚ü®hx.1, fun h => hx.2 ‚ü®h, hx.1‚ü©‚ü©
  rw [continuousOn_pi] at Hc
  refine' (A.unique B).trans (sum_congr rfl fun i _ => _)
  refine' congr_arg‚ÇÇ Sub.sub _ _
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.right_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.left_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq","warning:  `MeasureTheory.set_integral_congr_set_ae` has been deprecated, use `MeasureTheory.setIntegral_congr_set_ae` instead
error:  overloaded, errors 
  function expected at
    Finset.inter_subset_left ?m.17305
  term has type
    ?m.17304 ‚àà ?m.17302
  
  function expected at
    Set.inter_subset_left ?m.17442
  term has type
    ?m.17441 ‚àà ?m.17439","theorem integral_divergence_of_hasFDerivWithinAt_off_countable_aux‚ÇÅ (I : Box (Fin (n + 1)))
    (f : ‚Ñù‚Åø‚Å∫¬π ‚Üí E‚Åø‚Å∫¬π)
    (f' : ‚Ñù‚Åø‚Å∫¬π ‚Üí ‚Ñù‚Åø‚Å∫¬π ‚ÜíL[‚Ñù] E‚Åø‚Å∫¬π) (s : Set ‚Ñù‚Åø‚Å∫¬π)
    (hs : s.Countable) (Hc : ContinuousOn f (Box.Icc I))
    (Hd : ‚àÄ x ‚àà (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x)
    (Hi : IntegrableOn (fun x => ‚àë i, f' x (e i) i) (Box.Icc I)) :
    (‚à´ x in Box.Icc I, ‚àë i, f' x (e i) i) =
      ‚àë i : Fin (n + 1),
        ((‚à´ x in Box.Icc (I.face i), f (i.insertNth (I.upper i) x) i) -
          ‚à´ x in Box.Icc (I.face i), f (i.insertNth (I.lower i) x) i) ",":= by
  simp only [‚Üê setIntegral_congr_set_ae (Box.coe_ae_eq_Icc _)]
  have A := (Hi.mono_set Box.coe_subset_Icc).hasBoxIntegral ‚ä• rfl
  have B :=
    hasIntegral_GP_divergence_of_forall_hasDerivWithinAt I f f' (s ‚à© Box.Icc I)
      (hs.mono inter_subset_left) (fun x hx => Hc _ hx.2) fun x hx =>
      Hd _ ‚ü®hx.1, fun h => hx.2 ‚ü®h, hx.1‚ü©‚ü©
  rw [continuousOn_pi] at Hc
  refine (A.unique B).trans (sum_congr rfl fun i _ => ?_)
  refine congr_arg‚ÇÇ Sub.sub ?_ ?_
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.right_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.left_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq"
Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean,CategoryTheory.Limits.colimitLimitToLimitColimit_surjective,colimitLimitToLimitColimit_surjective,5da050a342e2ca6e5733645d6387e41f47fdb025,":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ‚Üê Limit.w_apply.{u‚ÇÅ, v, u‚ÇÅ} f, ‚Üê e]
      simp only [Functor.comp_map, Types.Colimit.Œπ_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact k'O
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) :=
            by rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) :=
            by rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) :=
            by rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext
      intro j
      simp only [id.def, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.74799 ‚Üí ?m.74799
error:  unsolved goals
case intro.intro.h.w
J : Type u‚ÇÅ
K : Type u‚ÇÇ
inst‚úù‚Å¥ : SmallCategory J
inst‚úù¬≥ : Category.{v‚ÇÇ, u‚ÇÇ} K
inst‚úù¬≤ : Small.{v, u‚ÇÇ} K
inst‚úù¬π : FinCategory J
F : J √ó K ‚•§ Type v
inst‚úù : IsFiltered K
x : limit (curry.obj F ‚ãô colim)
k : J ‚Üí K
y : (j : J) ‚Üí F.obj (j, k j)
e : ‚àÄ (j : J), colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô colim) j x
k' : K
g : (j : J) ‚Üí k j ‚ü∂ k'
kf : {j j' : J} ‚Üí (j ‚ü∂ j') ‚Üí K
hf gf : {j j' : J} ‚Üí (f : j ‚ü∂ j') ‚Üí k' ‚ü∂ kf f
wf : ‚àÄ {j j' : J} (f : j ‚ü∂ j'), F.map (ùüô j', g j' ‚â´ gf f) (y j') = F.map (f, g j ‚â´ hf f) (y j)
k'' : K
i : {j j' : J} ‚Üí (f : j ‚ü∂ j') ‚Üí kf f ‚ü∂ k''
s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ : J} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f'
j : J
‚ä¢ limit.œÄ ((curry.obj (swap K J ‚ãô F)).obj k'') j
      (id (Limit.mk ((curry.obj (swap K J ‚ãô F)).obj k'') (fun j ‚Ü¶ F.map (ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) (y j)) ‚ãØ)) =
    F.map (ùüô j, i (ùüô j)) (F.map (ùüô j, gf (ùüô j)) (F.map (ùüô j, g j) (y j)))","theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) ",":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ‚Üê Limit.w_apply.{u‚ÇÅ, v, u‚ÇÅ} f, ‚Üê e]
      simp only [Functor.comp_map, Types.Colimit.Œπ_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact k'O
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) := by
            rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) := by
            rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext
      intro j
      simp only [id, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a
  exact ‚ü®_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b
  exact ‚ü®_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.closed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine' ‚ü®g + dg, fun y => _, funext hgf‚ü©
    ¬∑ have hay : a < (g + dg) y := by
        rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
        ¬∑ refine' (lt_add_iff_pos_right _).2 _
          calc
            0 < c - g y := sub_pos.2 hac
            _ = dg y := (dga rfl).symm
        ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      refine' ‚ü®x, hxy.le, _‚ü©
      rcases le_total c (g y) with hc | hc
      ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
      ¬∑ calc
          g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
          _ = b := by rw [hsub, add_sub_cancel'_right]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.closed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine' ‚ü®g - dg, fun y => _, funext hgf‚ü©
  ¬∑ have hyb : (g - dg) y < b := by
      rcases (hgb y).eq_or_lt with (rfl | hlt)
      ¬∑ refine' (sub_lt_self_iff _).2 _
        calc
          0 < g y - c := sub_pos.2 hcb
          _ = dg y := (dgb rfl).symm
      ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
    rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
    cases' lt_or_le c (g y) with hc hc
    ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
      ¬∑ refine' ‚ü®x, xu, _, hyxu.le‚ü©
        calc
          f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
      ¬∑ have hay : a < (g - dg) y := by
          calc
            a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
            _ < g y - (b - c) := (sub_lt_sub_right hc _)
            _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
        rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
        exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
    ¬∑ refine' ‚ü®xl y, xu, _, hyxu.le‚ü©
      simp [dg0 (Or.inr hc), hxl]","error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  simp made no progress
error:  invalid field 'closed_range', the environment does not contain 'ClosedEmbedding.closed_range'
  he
has type
  ClosedEmbedding e
warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
error:  invalid field 'closed_range', the environment does not contain 'ClosedEmbedding.closed_range'
  he
has type
  ClosedEmbedding e","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/Data/List/Cycle.lean,List.prev_reverse_eq_next,prev_reverse_eq_next,d46528409610b391797c6ae50b570899f3d41002,":= by
  obtain ‚ü®k, hk, rfl‚ü© := nthLe_of_mem hx
  have lpos : 0 < l.length := k.zero_le.trans_lt hk
  have key : l.length - 1 - k < l.length := by omega
  rw [‚Üê nthLe_pmap l.next (fun _ h => h) (by simpa using hk)]
  simp_rw [‚Üê nthLe_reverse l k (key.trans_le (by simp)), pmap_next_eq_rotate_one _ h]
  rw [‚Üê nthLe_pmap l.reverse.prev fun _ h => h]
  ¬∑ simp_rw [pmap_prev_eq_rotate_length_sub_one _ (nodup_reverse.mpr h), rotate_reverse,
      length_reverse, Nat.mod_eq_of_lt (Nat.sub_lt lpos Nat.succ_pos'),
      Nat.sub_sub_self (Nat.succ_le_of_lt lpos)]
    rw [‚Üê nthLe_reverse]
    ¬∑ simp [Nat.sub_sub_self (Nat.le_sub_one_of_lt hk)]
    ¬∑ simpa using (Nat.sub_le _ _).trans_lt (Nat.sub_lt lpos Nat.succ_pos')
    ¬∑ simpa","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
error:  no goals to be solved
error:  unsolved goals
case intro.intro
Œ± : Type u_1
inst‚úù : DecidableEq Œ±
l‚úù : List Œ±
x : Œ±
l : List Œ±
h : l.Nodup
k : ‚Ñï
hk : k < l.length
hx : l.nthLe k hk ‚àà l
lpos : 0 < l.length
key : l.length - 1 - k < l.length
‚ä¢ l.length - 1 - k < (pmap l.reverse.prev l.reverse ‚ãØ).length","theorem prev_reverse_eq_next (l : List Œ±) (h : Nodup l) (x : Œ±) (hx : x ‚àà l) :
    prev l.reverse x (mem_reverse.mpr hx) = next l x hx ",":= by
  obtain ‚ü®k, hk, rfl‚ü© := nthLe_of_mem hx
  have lpos : 0 < l.length := k.zero_le.trans_lt hk
  have key : l.length - 1 - k < l.length := by omega
  rw [‚Üê nthLe_pmap l.next (fun _ h => h) (by simpa using hk)]
  simp_rw [‚Üê nthLe_reverse l k (key.trans_le (by simp)), pmap_next_eq_rotate_one _ h]
  rw [‚Üê nthLe_pmap l.reverse.prev fun _ h => h]
  ¬∑ simp_rw [pmap_prev_eq_rotate_length_sub_one _ (nodup_reverse.mpr h), rotate_reverse,
      length_reverse, Nat.mod_eq_of_lt (Nat.sub_lt lpos Nat.succ_pos'),
      Nat.sub_sub_self (Nat.succ_le_of_lt lpos)]
    rw [‚Üê nthLe_reverse]
    ¬∑ simp [Nat.sub_sub_self (Nat.le_sub_one_of_lt hk)]
    ¬∑ simpa using (Nat.sub_le _ _).trans_lt (Nat.sub_lt lpos Nat.succ_pos')
  ¬∑ simpa"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.single_eq_same,single_eq_same,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.single_eq_same","warning:  Finsupp does not have a doc string
error:  unknown identifier 'DFinsupp.single_eq_same'",theorem single_eq_same : (single a b : Œ± ‚Üí‚ÇÄ M) a = b ,":= by
  classical exact Pi.single_eq_same (f := fun _ ‚Ü¶ M) a b"
Mathlib/SetTheory/Cardinal/Basic.lean,Cardinal.mk_image_eq_lift,mk_image_eq_lift,174aab87467f5b4d401e0c47e13be4485271cd09,":=
  mk_image_eq_of_injOn_lift _ _ <| h.injOn _","warning:  mk does not have a doc string
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Cardinal.power_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  aleph0 does not have a doc string
error:  application type mismatch
  mk_image_eq_of_injOn_lift f s (Injective.injOn h ?m.197854)
argument
  Injective.injOn h ?m.197854
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Œ±‚¶Ñ, x‚ÇÇ ‚àà ?m.197852 ‚Üí f ?m.197853 = f x‚ÇÇ ‚Üí ?m.197853 = x‚ÇÇ : Prop
but is expected to have type
  InjOn f s : Prop
warning:  powerlt does not have a doc string","theorem mk_image_eq_lift {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (h : Injective f) :
    lift.{u} #(f '' s) = lift.{v} #s ",":=
  mk_image_eq_of_injOn_lift _ _ h.injOn"
Mathlib/RingTheory/Localization/Away/Basic.lean,exists_reduced_fraction',exists_reduced_fraction',3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  obtain ‚ü®‚ü®a‚ÇÄ, y‚ü©, H‚ü© := surj (Submonoid.powers x) b
  obtain ‚ü®d, hy‚ü© := (Submonoid.mem_powers_iff y.1 x).mp y.2
  have ha‚ÇÄ : a‚ÇÄ ‚â† 0 := by
    haveI :=
      @isDomain_of_le_nonZeroDivisors B _ R _ _ _ _ (Submonoid.powers x) _
        (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
    simp only [map_zero, ‚Üê hy, map_pow] at H
    apply ((injective_iff_map_eq_zero' (algebraMap R B)).mp _ a‚ÇÄ).mpr.mt
    ¬∑ rw [‚Üê H]
      apply mul_ne_zero hb (pow_ne_zero _ _)
      exact
        IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors B
          (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
          (mem_nonZeroDivisors_iff_ne_zero.mpr hx.ne_zero)
    ¬∑ exact IsLocalization.injective B (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
  simp only [‚Üê hy] at H
  obtain ‚ü®m, a, hyp1, hyp2‚ü© := WfDvdMonoid.max_power_factor ha‚ÇÄ hx
  refine ‚ü®a, m - d, ?_‚ü©
  rw [‚Üê mk'_one (M := Submonoid.powers x) B, selfZPow_pow_sub, selfZPow_natCast, selfZPow_natCast,
    ‚Üê map_pow _ _ d, mul_comm _ b, H, hyp2, map_mul, map_pow _ _ m]
  exact ‚ü®hyp1, congr_arg _ (IsLocalization.mk'_one _ _)‚ü©","error:  application type mismatch
  @isDomain_of_le_nonZeroDivisors B ?m.101151 R ?m.101152 ?m.101153 ?m.101154 ?m.101155 (Submonoid.powers x)
argument
  Submonoid.powers x
has type
  Submonoid R : Type u_1
but is expected to have type
  IsLocalization ?m.101155 B : Prop","theorem exists_reduced_fraction' {b : B} (hb : b ‚â† 0) (hx : Irreducible x) :
    ‚àÉ (a : R) (n : ‚Ñ§), ¬¨x ‚à£ a ‚àß selfZPow x B n * algebraMap R B a = b ",":= by
  obtain ‚ü®‚ü®a‚ÇÄ, y‚ü©, H‚ü© := surj (Submonoid.powers x) b
  obtain ‚ü®d, hy‚ü© := (Submonoid.mem_powers_iff y.1 x).mp y.2
  have ha‚ÇÄ : a‚ÇÄ ‚â† 0 := by
    haveI :=
      @isDomain_of_le_nonZeroDivisors B _ R _ _ _ (Submonoid.powers x) _
        (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
    simp only [map_zero, ‚Üê hy, map_pow] at H
    apply ((injective_iff_map_eq_zero' (algebraMap R B)).mp _ a‚ÇÄ).mpr.mt
    ¬∑ rw [‚Üê H]
      apply mul_ne_zero hb (pow_ne_zero _ _)
      exact
        IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors B
          (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
          (mem_nonZeroDivisors_iff_ne_zero.mpr hx.ne_zero)
    ¬∑ exact IsLocalization.injective B (powers_le_nonZeroDivisors_of_noZeroDivisors hx.ne_zero)
  simp only [‚Üê hy] at H
  obtain ‚ü®m, a, hyp1, hyp2‚ü© := WfDvdMonoid.max_power_factor ha‚ÇÄ hx
  refine ‚ü®a, m - d, ?_‚ü©
  rw [‚Üê mk'_one (M := Submonoid.powers x) B, selfZPow_pow_sub, selfZPow_natCast, selfZPow_natCast,
    ‚Üê map_pow _ _ d, mul_comm _ b, H, hyp2, map_mul, map_pow _ _ m]
  exact ‚ü®hyp1, congr_arg _ (IsLocalization.mk'_one _ _)‚ü©"
Mathlib/MeasureTheory/Function/Jacobian.lean,ApproximatesLinearOn.norm_fderiv_sub_le,_root_.ApproximatesLinearOn.norm_fderiv_sub_le,0939faa78a0c4506a8aee4e86b897d6e84c6cb96,":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ
  ¬∑ have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by continuity) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel'_right]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := (norm_add_le _ _)
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel', sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := (norm_sub_le _ _)
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel', norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
        mul_le_mul_of_nonneg_left norm_a (mul_nonneg rpos.le (add_nonneg Œ¥.2 Œµpos.le))
  show ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ;
  exact
    calc
      ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := (norm_add_le _ _)
      _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
        apply add_le_add
        ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
        ¬∑ apply ContinuousLinearMap.le_opNorm
      _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ :=
        add_le_add le_rfl
          (mul_le_mul_of_nonneg_left (mem_closedBall_iff_norm'.1 az) (norm_nonneg _))",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem _root_.ApproximatesLinearOn.norm_fderiv_sub_le {A : E ‚ÜíL[‚Ñù] E} {Œ¥ : ‚Ñù‚â•0}
    (hf : ApproximatesLinearOn f A s Œ¥) (hs : MeasurableSet s) (f' : E ‚Üí E ‚ÜíL[‚Ñù] E)
    (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) : ‚àÄ·µê x ‚àÇŒº.restrict s, ‚Äñf' x - A‚Äñ‚Çä ‚â§ Œ¥ ",":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ by
    have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by fun_prop) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel_left, sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := norm_sub_le _ _
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel_left, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) := by gcongr
  calc
    ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
      congr 1
      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
      abel
    _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
      apply add_le_add
      ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
      ¬∑ apply ContinuousLinearMap.le_opNorm
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ := by
      rw [mem_closedBall_iff_norm'] at az
      gcongr"
Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean,coeff_minpolyDiv_sub_pow_mem_span,coeff_minpolyDiv_sub_pow_mem_span,93fe16b79b4d74f8ddaec22ca9d80d09915ac92b,":= by
  induction i with
  | zero => simp [(minpolyDiv_monic hx).leadingCoeff]
  | succ i IH =>
    rw [coeff_minpolyDiv, add_sub_assoc, pow_succ', ‚Üê sub_mul, Algebra.algebraMap_eq_smul_one]
    refine add_mem ?_ ?_
    ¬∑ apply Submodule.smul_mem
      apply Submodule.subset_span
      exact ‚ü®0, Nat.zero_lt_succ _, pow_zero _‚ü©
    ¬∑ rw [Nat.succ_eq_add_one, ‚Üê tsub_tsub, tsub_add_cancel_of_le
        (le_tsub_of_add_le_left (b := 1) hi)]
      apply SetLike.le_def.mp ?_
        (Submodule.mul_mem_mul (IH ((Nat.le_succ _).trans hi))
          (Submodule.mem_span_singleton_self x))
      rw [Submodule.span_mul_span, Set.mul_singleton, Set.image_image]
      apply Submodule.span_mono
      rintro _ ‚ü®j, hj : j < i, rfl‚ü©
      exact ‚ü®j + 1, Nat.add_lt_of_lt_sub hj, pow_succ' x j‚ü©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * ?c - ?b * ?c
case succ
R : Type u_2
K : Type ?u.79175
L : Type ?u.79178
S : Type u_1
inst‚úù‚Åµ : CommRing R
inst‚úù‚Å¥ : Field K
inst‚úù¬≥ : Field L
inst‚úù¬≤ : CommRing S
inst‚úù¬π : Algebra R S
inst‚úù : Algebra K L
x : S
hx : IsIntegral R x
i : ‚Ñï
IH :
  i ‚â§ (minpolyDiv R x).natDegree ‚Üí
    (minpolyDiv R x).coeff ((minpolyDiv R x).natDegree - i) - x ^ i ‚àà
      Submodule.span R ((fun x_1 ‚Ü¶ x ^ x_1) '' Set.Iio i)
hi : i + 1 ‚â§ (minpolyDiv R x).natDegree
‚ä¢ (algebraMap R S) ((minpoly R x).coeff ((minpolyDiv R x).natDegree - (i + 1) + 1)) +
      ((minpolyDiv R x).coeff ((minpolyDiv R x).natDegree - (i + 1) + 1) * x - x * x ^ i) ‚àà
    Submodule.span R ((fun x_1 ‚Ü¶ x ^ x_1) '' Set.Iio (i + 1))","lemma coeff_minpolyDiv_sub_pow_mem_span {i} (hi : i ‚â§ natDegree (minpolyDiv R x)) :
    coeff (minpolyDiv R x) (natDegree (minpolyDiv R x) - i) - x ^ i ‚àà
      Submodule.span R ((x ^ ¬∑) '' Set.Iio i) ",":= by
  induction i with
  | zero => simp [(minpolyDiv_monic hx).leadingCoeff]
  | succ i IH =>
    rw [coeff_minpolyDiv, add_sub_assoc, pow_succ, ‚Üê sub_mul, Algebra.algebraMap_eq_smul_one]
    refine add_mem ?_ ?_
    ¬∑ apply Submodule.smul_mem
      apply Submodule.subset_span
      exact ‚ü®0, Nat.zero_lt_succ _, pow_zero _‚ü©
    ¬∑ rw [‚Üê tsub_tsub, tsub_add_cancel_of_le (le_tsub_of_add_le_left (b := 1) hi)]
      apply SetLike.le_def.mp ?_
        (Submodule.mul_mem_mul (IH ((Nat.le_succ _).trans hi))
          (Submodule.mem_span_singleton_self x))
      rw [Submodule.span_mul_span, Set.mul_singleton, Set.image_image]
      apply Submodule.span_mono
      rintro _ ‚ü®j, hj, rfl‚ü©
      rw [Set.mem_Iio] at hj
      exact ‚ü®j + 1, Nat.add_lt_of_lt_sub hj, pow_succ x j‚ü©"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.Measure.mkMetric_le_liminf_tsum,mkMetric_le_liminf_tsum,ced4d3c0af763b9fd00166e49cf999cf46c891cc,":= by
  haveI : ‚àÄ n, Encodable (Œπ n) := fun n => Encodable.ofCountable _
  simp only [mkMetric_apply]
  refine iSup‚ÇÇ_le fun Œµ hŒµ => _
  refine le_of_forall_le_of_dense fun c hc => _
  rcases ((frequently_lt_of_liminf_lt (by isBoundedDefault) hc).and_eventually
        ((hr.eventually (gt_mem_nhds hŒµ)).and (ht.and hst))).exists with
    ‚ü®n, hn, hrn, htn, hstn‚ü©
  set u : ‚Ñï ‚Üí Set X := fun j => ‚ãÉ b ‚àà decode‚ÇÇ (Œπ n) j, t n b
  refine iInf‚ÇÇ_le_of_le u (by rwa [iUnion_decode‚ÇÇ]) _
  refine iInf_le_of_le (fun j => _) _
  ¬∑ rw [EMetric.diam_iUnion_mem_option]
    exact iSup‚ÇÇ_le fun _ _ => (htn _).trans hrn.le
  ¬∑ calc
      (‚àë' j : ‚Ñï, ‚®Ü _ : (u j).Nonempty, m (diam (u j))) = _ :=
        tsum_iUnion_decode‚ÇÇ (fun t : Set X => ‚®Ü _ : t.Nonempty, m (diam t)) (by simp) _
      _ ‚â§ ‚àë' i : Œπ n, m (diam (t n i)) := ENNReal.tsum_le_tsum fun b => iSup_le fun _ => le_rfl
      _ ‚â§ c := hn.le","error:  don't know how to synthesize placeholder
context:
Œπ‚úù : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù‚Å¥ : EMetricSpace X
inst‚úù¬≥ : EMetricSpace Y
inst‚úù¬≤ : MeasurableSpace X
inst‚úù¬π : BorelSpace X
Œ≤ : Type u_4
Œπ : Œ≤ ‚Üí Type u_5
inst‚úù : ‚àÄ (n : Œ≤), Countable (Œπ n)
s : Set X
l : Filter Œ≤
r : Œ≤ ‚Üí ‚Ñù‚â•0‚àû
hr : Tendsto r l (ùìù 0)
t : (n : Œ≤) ‚Üí Œπ n ‚Üí Set X
ht : ‚àÄ·∂† (n : Œ≤) in l, ‚àÄ (i : Œπ n), diam (t n i) ‚â§ r n
hst : ‚àÄ·∂† (n : Œ≤) in l, s ‚äÜ ‚ãÉ i, t n i
m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû
this : (n : Œ≤) ‚Üí Encodable (Œπ n)
Œµ : ‚Ñù‚â•0‚àû
hŒµ : 0 < Œµ
‚ä¢ ‚®Ö t, ‚®Ö (_ : s ‚äÜ iUnion t), ‚®Ö (_ : ‚àÄ (n : ‚Ñï), diam (t n) ‚â§ Œµ), ‚àë' (n : ‚Ñï), ‚®Ü (_ : (t n).Nonempty), m (diam (t n)) ‚â§
    liminf (fun n ‚Ü¶ ‚àë' (i : Œπ n), m (diam (t n i))) l
error:  unsolved goals
Œπ‚úù : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù‚Å¥ : EMetricSpace X
inst‚úù¬≥ : EMetricSpace Y
inst‚úù¬≤ : MeasurableSpace X
inst‚úù¬π : BorelSpace X
Œ≤ : Type u_4
Œπ : Œ≤ ‚Üí Type u_5
inst‚úù : ‚àÄ (n : Œ≤), Countable (Œπ n)
s : Set X
l : Filter Œ≤
r : Œ≤ ‚Üí ‚Ñù‚â•0‚àû
hr : Tendsto r l (ùìù 0)
t : (n : Œ≤) ‚Üí Œπ n ‚Üí Set X
ht : ‚àÄ·∂† (n : Œ≤) in l, ‚àÄ (i : Œπ n), diam (t n i) ‚â§ r n
hst : ‚àÄ·∂† (n : Œ≤) in l, s ‚äÜ ‚ãÉ i, t n i
m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû
this : (n : Œ≤) ‚Üí Encodable (Œπ n)
‚ä¢ ‚®Ü r,
      ‚®Ü (_ : 0 < r),
        ‚®Ö t,
          ‚®Ö (_ : s ‚äÜ iUnion t), ‚®Ö (_ : ‚àÄ (n : ‚Ñï), diam (t n) ‚â§ r), ‚àë' (n : ‚Ñï), ‚®Ü (_ : (t n).Nonempty), m (diam (t n)) ‚â§
    liminf (fun n ‚Ü¶ ‚àë' (i : Œπ n), m (diam (t n i))) l","theorem mkMetric_le_liminf_tsum {Œ≤ : Type*} {Œπ : Œ≤ ‚Üí Type*} [‚àÄ n, Countable (Œπ n)] (s : Set X)
    {l : Filter Œ≤} (r : Œ≤ ‚Üí ‚Ñù‚â•0‚àû) (hr : Tendsto r l (ùìù 0)) (t : ‚àÄ n : Œ≤, Œπ n ‚Üí Set X)
    (ht : ‚àÄ·∂† n in l, ‚àÄ i, diam (t n i) ‚â§ r n) (hst : ‚àÄ·∂† n in l, s ‚äÜ ‚ãÉ i, t n i) (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) :
    mkMetric m s ‚â§ liminf (fun n => ‚àë' i, m (diam (t n i))) l ",":= by
  haveI : ‚àÄ n, Encodable (Œπ n) := fun n => Encodable.ofCountable _
  simp only [mkMetric_apply]
  refine iSup‚ÇÇ_le fun Œµ hŒµ => ?_
  refine le_of_forall_le_of_dense fun c hc => ?_
  rcases ((frequently_lt_of_liminf_lt (by isBoundedDefault) hc).and_eventually
        ((hr.eventually (gt_mem_nhds hŒµ)).and (ht.and hst))).exists with
    ‚ü®n, hn, hrn, htn, hstn‚ü©
  set u : ‚Ñï ‚Üí Set X := fun j => ‚ãÉ b ‚àà decode‚ÇÇ (Œπ n) j, t n b
  refine iInf‚ÇÇ_le_of_le u (by rwa [iUnion_decode‚ÇÇ]) ?_
  refine iInf_le_of_le (fun j => ?_) ?_
  ¬∑ rw [EMetric.diam_iUnion_mem_option]
    exact iSup‚ÇÇ_le fun _ _ => (htn _).trans hrn.le
  ¬∑ calc
      (‚àë' j : ‚Ñï, ‚®Ü _ : (u j).Nonempty, m (diam (u j))) = _ :=
        tsum_iUnion_decode‚ÇÇ (fun t : Set X => ‚®Ü _ : t.Nonempty, m (diam t)) (by simp) _
      _ ‚â§ ‚àë' i : Œπ n, m (diam (t n i)) := ENNReal.tsum_le_tsum fun b => iSup_le fun _ => le_rfl
      _ ‚â§ c := hn.le"
Mathlib/GroupTheory/Perm/List.lean,List.formPerm_pow_apply_nthLe,formPerm_pow_apply_nthLe,23bca4e7b9b89fb9b29c6e54108c10a745f95d0f,":=
  formPerm_pow_apply_get l h n k hk","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
error:  application type mismatch
  formPerm_pow_apply_get l h n k
argument
  k
has type
  ‚Ñï : Type
but is expected to have type
  Fin l.length : Type","theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) ",":=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©"
Mathlib/Analysis/SpecialFunctions/NonIntegrable.lean,not_integrableOn_of_tendsto_norm_atTop_of_deriv_isBigO_filter,not_integrableOn_of_tendsto_norm_atTop_of_deriv_isBigO_filter,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  intro hgi
  obtain ‚ü®C, hC‚ÇÄ, s, hsl, hsub, hfd, hg‚ü© :
    ‚àÉ (C : ‚Ñù) (_ : 0 ‚â§ C), ‚àÉ s ‚àà l, (‚àÄ x ‚àà s, ‚àÄ y ‚àà s, [[x, y]] ‚äÜ k) ‚àß
      (‚àÄ x ‚àà s, ‚àÄ y ‚àà s, ‚àÄ z ‚àà [[x, y]], DifferentiableAt ‚Ñù f z) ‚àß
        ‚àÄ x ‚àà s, ‚àÄ y ‚àà s, ‚àÄ z ‚àà [[x, y]], ‚Äñderiv f z‚Äñ ‚â§ C * ‚Äñg z‚Äñ := by
    rcases hfg.exists_nonneg with ‚ü®C, C‚ÇÄ, hC‚ü©
    have h : ‚àÄ·∂† x : ‚Ñù √ó ‚Ñù in l.prod l,
        ‚àÄ y ‚àà [[x.1, x.2]], (DifferentiableAt ‚Ñù f y ‚àß ‚Äñderiv f y‚Äñ ‚â§ C * ‚Äñg y‚Äñ) ‚àß y ‚àà k :=
      (tendsto_fst.uIcc tendsto_snd).eventually ((hd.and hC.bound).and hl).smallSets
    rcases mem_prod_self_iff.1 h with ‚ü®s, hsl, hs‚ü©
    simp only [prod_subset_iff, mem_setOf_eq] at hs
    exact ‚ü®C, C‚ÇÄ, s, hsl, fun x hx y hy z hz => (hs x hx y hy z hz).2, fun x hx y hy z hz =>
      (hs x hx y hy z hz).1.1, fun x hx y hy z hz => (hs x hx y hy z hz).1.2‚ü©
  replace hgi : IntegrableOn (fun x ‚Ü¶ C * ‚Äñg x‚Äñ) k := by exact hgi.norm.smul C
  obtain ‚ü®c, hc, d, hd, hlt‚ü© : ‚àÉ c ‚àà s, ‚àÉ d ‚àà s, (‚Äñf c‚Äñ + ‚à´ y in k, C * ‚Äñg y‚Äñ) < ‚Äñf d‚Äñ := by
    rcases Filter.nonempty_of_mem hsl with ‚ü®c, hc‚ü©
    have : ‚àÄ·∂† x in l, (‚Äñf c‚Äñ + ‚à´ y in k, C * ‚Äñg y‚Äñ) < ‚Äñf x‚Äñ :=
      hf.eventually (eventually_gt_atTop _)
    exact ‚ü®c, hc, (this.and hsl).exists.imp fun d hd => ‚ü®hd.2, hd.1‚ü©‚ü©
  specialize hsub c hc d hd; specialize hfd c hc d hd
  replace hg : ‚àÄ x ‚àà Œô c d, ‚Äñderiv f x‚Äñ ‚â§ C * ‚Äñg x‚Äñ :=
    fun z hz => hg c hc d hd z ‚ü®hz.1.le, hz.2‚ü©
  have hg_ae : ‚àÄ·µê x ‚àÇvolume.restrict (Œô c d), ‚Äñderiv f x‚Äñ ‚â§ C * ‚Äñg x‚Äñ :=
    (ae_restrict_mem measurableSet_uIoc).mono hg
  have hsub' : Œô c d ‚äÜ k := Subset.trans Ioc_subset_Icc_self hsub
  have hfi : IntervalIntegrable (deriv f) volume c d := by
    rw [intervalIntegrable_iff]
    have : IntegrableOn (fun x ‚Ü¶ C * ‚Äñg x‚Äñ) (Œô c d) := IntegrableOn.mono hgi hsub' le_rfl
    exact Integrable.mono' this (aestronglyMeasurable_deriv _ _) hg_ae
  refine' hlt.not_le (sub_le_iff_le_add'.1 _)
  calc
    ‚Äñf d‚Äñ - ‚Äñf c‚Äñ ‚â§ ‚Äñf d - f c‚Äñ := norm_sub_norm_le _ _
    _ = ‚Äñ‚à´ x in c..d, deriv f x‚Äñ := congr_arg _ (integral_deriv_eq_sub hfd hfi).symm
    _ = ‚Äñ‚à´ x in Œô c d, deriv f x‚Äñ := norm_integral_eq_norm_integral_Ioc _
    _ ‚â§ ‚à´ x in Œô c d, ‚Äñderiv f x‚Äñ := norm_integral_le_integral_norm _
    _ ‚â§ ‚à´ x in Œô c d, C * ‚Äñg x‚Äñ :=
      set_integral_mono_on hfi.norm.def (hgi.mono_set hsub') measurableSet_uIoc hg
    _ ‚â§ ‚à´ x in k, C * ‚Äñg x‚Äñ := by
      apply set_integral_mono_set hgi
        (ae_of_all _ fun x => mul_nonneg hC‚ÇÄ (norm_nonneg _)) hsub'.eventuallyLE","warning:  `MeasureTheory.set_integral_mono_on` has been deprecated, use `MeasureTheory.setIntegral_mono_on` instead
error:  invalid field 'def', the environment does not contain 'IntervalIntegrable.def'
  IntervalIntegrable.norm hfi
has type
  IntervalIntegrable (fun x ‚Ü¶ ‚Äñderiv f x‚Äñ) volume c d
error:  invalid field 'def', the environment does not contain 'And.def'
  IntervalIntegrable.norm hfi
has type
  IntegrableOn (fun x ‚Ü¶ ‚Äñderiv f x‚Äñ) (Ioc c d) volume ‚àß IntegrableOn (fun x ‚Ü¶ ‚Äñderiv f x‚Äñ) (Ioc d c) volume
warning:  `MeasureTheory.set_integral_mono_set` has been deprecated, use `MeasureTheory.setIntegral_mono_set` instead","theorem not_integrableOn_of_tendsto_norm_atTop_of_deriv_isBigO_filter_aux
    [CompleteSpace E] {f : ‚Ñù ‚Üí E} {g : ‚Ñù ‚Üí F}
    {k : Set ‚Ñù} (l : Filter ‚Ñù) [NeBot l] [TendstoIxxClass Icc l l]
    (hl : k ‚àà l) (hd : ‚àÄ·∂† x in l, DifferentiableAt ‚Ñù f x) (hf : Tendsto (fun x => ‚Äñf x‚Äñ) l atTop)
    (hfg : deriv f =O[l] g) : ¬¨IntegrableOn g k ",":= by
  intro hgi
  obtain ‚ü®C, hC‚ÇÄ, s, hsl, hsub, hfd, hg‚ü© :
    ‚àÉ (C : ‚Ñù) (_ : 0 ‚â§ C), ‚àÉ s ‚àà l, (‚àÄ x ‚àà s, ‚àÄ y ‚àà s, [[x, y]] ‚äÜ k) ‚àß
      (‚àÄ x ‚àà s, ‚àÄ y ‚àà s, ‚àÄ z ‚àà [[x, y]], DifferentiableAt ‚Ñù f z) ‚àß
        ‚àÄ x ‚àà s, ‚àÄ y ‚àà s, ‚àÄ z ‚àà [[x, y]], ‚Äñderiv f z‚Äñ ‚â§ C * ‚Äñg z‚Äñ := by
    rcases hfg.exists_nonneg with ‚ü®C, C‚ÇÄ, hC‚ü©
    have h : ‚àÄ·∂† x : ‚Ñù √ó ‚Ñù in l.prod l,
        ‚àÄ y ‚àà [[x.1, x.2]], (DifferentiableAt ‚Ñù f y ‚àß ‚Äñderiv f y‚Äñ ‚â§ C * ‚Äñg y‚Äñ) ‚àß y ‚àà k :=
      (tendsto_fst.uIcc tendsto_snd).eventually ((hd.and hC.bound).and hl).smallSets
    rcases mem_prod_self_iff.1 h with ‚ü®s, hsl, hs‚ü©
    simp only [prod_subset_iff, mem_setOf_eq] at hs
    exact ‚ü®C, C‚ÇÄ, s, hsl, fun x hx y hy z hz => (hs x hx y hy z hz).2, fun x hx y hy z hz =>
      (hs x hx y hy z hz).1.1, fun x hx y hy z hz => (hs x hx y hy z hz).1.2‚ü©
  replace hgi : IntegrableOn (fun x ‚Ü¶ C * ‚Äñg x‚Äñ) k := by exact hgi.norm.smul C
  obtain ‚ü®c, hc, d, hd, hlt‚ü© : ‚àÉ c ‚àà s, ‚àÉ d ‚àà s, (‚Äñf c‚Äñ + ‚à´ y in k, C * ‚Äñg y‚Äñ) < ‚Äñf d‚Äñ := by
    rcases Filter.nonempty_of_mem hsl with ‚ü®c, hc‚ü©
    have : ‚àÄ·∂† x in l, (‚Äñf c‚Äñ + ‚à´ y in k, C * ‚Äñg y‚Äñ) < ‚Äñf x‚Äñ :=
      hf.eventually (eventually_gt_atTop _)
    exact ‚ü®c, hc, (this.and hsl).exists.imp fun d hd => ‚ü®hd.2, hd.1‚ü©‚ü©
  specialize hsub c hc d hd; specialize hfd c hc d hd
  replace hg : ‚àÄ x ‚àà Œô c d, ‚Äñderiv f x‚Äñ ‚â§ C * ‚Äñg x‚Äñ :=
    fun z hz => hg c hc d hd z ‚ü®hz.1.le, hz.2‚ü©
  have hg_ae : ‚àÄ·µê x ‚àÇvolume.restrict (Œô c d), ‚Äñderiv f x‚Äñ ‚â§ C * ‚Äñg x‚Äñ :=
    (ae_restrict_mem measurableSet_uIoc).mono hg
  have hsub' : Œô c d ‚äÜ k := Subset.trans Ioc_subset_Icc_self hsub
  have hfi : IntervalIntegrable (deriv f) volume c d := by
    rw [intervalIntegrable_iff]
    have : IntegrableOn (fun x ‚Ü¶ C * ‚Äñg x‚Äñ) (Œô c d) := IntegrableOn.mono hgi hsub' le_rfl
    exact Integrable.mono' this (aestronglyMeasurable_deriv _ _) hg_ae
  refine hlt.not_le (sub_le_iff_le_add'.1 ?_)
  calc
    ‚Äñf d‚Äñ - ‚Äñf c‚Äñ ‚â§ ‚Äñf d - f c‚Äñ := norm_sub_norm_le _ _
    _ = ‚Äñ‚à´ x in c..d, deriv f x‚Äñ := congr_arg _ (integral_deriv_eq_sub hfd hfi).symm
    _ = ‚Äñ‚à´ x in Œô c d, deriv f x‚Äñ := norm_integral_eq_norm_integral_Ioc _
    _ ‚â§ ‚à´ x in Œô c d, ‚Äñderiv f x‚Äñ := norm_integral_le_integral_norm _
    _ ‚â§ ‚à´ x in Œô c d, C * ‚Äñg x‚Äñ :=
      setIntegral_mono_on hfi.norm.def' (hgi.mono_set hsub') measurableSet_uIoc hg
    _ ‚â§ ‚à´ x in k, C * ‚Äñg x‚Äñ := by
      apply setIntegral_mono_set hgi
        (ae_of_all _ fun x => mul_nonneg hC‚ÇÄ (norm_nonneg _)) hsub'.eventuallyLE"
Mathlib/Order/OrderIsoNat.lean,exists_increasing_or_nonincreasing_subseq,exists_increasing_or_nonincreasing_subseq,518c1e170f81dd769be38262c88a0aef65109d9f,":= by
  classical
    let bad : Set ‚Ñï := { m | ‚àÄ n, m < n ‚Üí ¬¨r (f m) (f n) }
    by_cases hbad : Infinite bad
    ¬∑ haveI := hbad
      refine' ‚ü®Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => _‚ü©
      have h := @Set.mem_range_self _ _ ‚Üë(Nat.orderEmbeddingOfSet bad) m
      rw [Nat.orderEmbeddingOfSet_range bad] at h
      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)
    ¬∑ rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad
      obtain ‚ü®m, hm‚ü© : ‚àÉ m, ‚àÄ n, m ‚â§ n ‚Üí ¬¨n ‚àà bad := by
        by_cases he : hbad.toFinset.Nonempty
        ¬∑ refine'
            ‚ü®(hbad.toFinset.max' he).succ, fun n hn nbad =>
              Nat.not_succ_le_self _
                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))‚ü©
        ¬∑ exact ‚ü®0, fun n _ nbad => he ‚ü®n, hbad.mem_toFinset.2 nbad‚ü©‚ü©
      have h : ‚àÄ n : ‚Ñï, ‚àÉ n' : ‚Ñï, n < n' ‚àß r (f (n + m)) (f (n' + m)) := by
        intro n
        have h := hm _ (le_add_of_nonneg_left n.zero_le)
        simp only [bad, exists_prop, not_not, Set.mem_setOf_eq, not_forall] at h
        obtain ‚ü®n', hn1, hn2‚ü© := h
        obtain ‚ü®x, hpos, rfl‚ü© := exists_pos_add_of_lt hn1
        refine' ‚ü®n + x, add_lt_add_left hpos n, _‚ü©
        rw [add_assoc, add_comm x m, ‚Üê add_assoc]
        exact hn2
      let g' : ‚Ñï ‚Üí ‚Ñï := @Nat.rec (fun _ => ‚Ñï) m fun n gn => Nat.find (h gn)
      exact
        ‚ü®(RelEmbedding.natLT (fun n => g' n + m) fun n =>
              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,
          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2‚ü©","error:  failed to synthesize
  CovariantClass ‚Ñï ‚Ñï (Function.swap fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  exists_pos_add_of_lt hn1
argument
  hn1
has type
  @LT.lt ‚Ñï instLTNat (n + m) n' : Prop
but is expected to have type
  @LT.lt ‚Ñï Preorder.toLT (n + m) n' : Prop","theorem exists_increasing_or_nonincreasing_subseq' (r : Œ± ‚Üí Œ± ‚Üí Prop) (f : ‚Ñï ‚Üí Œ±) :
    ‚àÉ g : ‚Ñï ‚Ü™o ‚Ñï,
      (‚àÄ n : ‚Ñï, r (f (g n)) (f (g (n + 1)))) ‚à® ‚àÄ m n : ‚Ñï, m < n ‚Üí ¬¨r (f (g m)) (f (g n)) ",":= by
  classical
    let bad : Set ‚Ñï := { m | ‚àÄ n, m < n ‚Üí ¬¨r (f m) (f n) }
    by_cases hbad : Infinite bad
    ¬∑ haveI := hbad
      refine ‚ü®Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => ?_‚ü©
      have h := @Set.mem_range_self _ _ ‚Üë(Nat.orderEmbeddingOfSet bad) m
      rw [Nat.orderEmbeddingOfSet_range bad] at h
      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)
    ¬∑ rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad
      obtain ‚ü®m, hm‚ü© : ‚àÉ m, ‚àÄ n, m ‚â§ n ‚Üí ¬¨n ‚àà bad := by
        by_cases he : hbad.toFinset.Nonempty
        ¬∑ refine
            ‚ü®(hbad.toFinset.max' he).succ, fun n hn nbad =>
              Nat.not_succ_le_self _
                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))‚ü©
        ¬∑ exact ‚ü®0, fun n _ nbad => he ‚ü®n, hbad.mem_toFinset.2 nbad‚ü©‚ü©
      have h : ‚àÄ n : ‚Ñï, ‚àÉ n' : ‚Ñï, n < n' ‚àß r (f (n + m)) (f (n' + m)) := by
        intro n
        have h := hm _ (Nat.le_add_left m n)
        simp only [bad, exists_prop, not_not, Set.mem_setOf_eq, not_forall] at h
        obtain ‚ü®n', hn1, hn2‚ü© := h
        refine ‚ü®n + n' - n - m, by omega, ?_‚ü©
        convert hn2
        omega
      let g' : ‚Ñï ‚Üí ‚Ñï := @Nat.rec (fun _ => ‚Ñï) m fun n gn => Nat.find (h gn)
      exact
        ‚ü®(RelEmbedding.natLT (fun n => g' n + m) fun n =>
              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,
          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2‚ü©"
Mathlib/Analysis/InnerProductSpace/Basic.lean,inner_mul_inner_self_le,inner_mul_inner_self_le,e46faedbd6353e165e5a0da6768aa2e7bd75f6d4,":= by
  have hdiscrim : ‚àÄ (t : ‚Ñù), 0 ‚â§ normSqF x * t * t  + 2 * ‚Äñ‚ü™x, y‚ü´‚Äñ * t + normSqF y := by
    intro t
    by_cases hzero : ‚ü™x, y‚ü´ = 0
    ¬∑ rw [hzero]
      simp only [norm_zero, mul_zero, zero_mul, add_zero]
      apply add_nonneg
      ¬∑ rw [mul_assoc, ‚Üê sq, normSq]
        exact mul_nonneg inner_self_nonneg (sq_nonneg t)
      ¬∑ rw [normSq]
        exact inner_self_nonneg
    ¬∑ push_neg at hzero
      rw [‚Üê norm_ne_zero_iff] at hzero
      have htxy: 0 ‚â§ normSqF (‚ü™x,y‚ü´ ‚Ä¢ x) * (t / ‚Äñ‚ü™x,y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x,y‚ü´‚Äñ)
          + 2 * re ‚ü™‚ü™x,y‚ü´ ‚Ä¢ x, y‚ü´ * (t / ‚Äñ‚ü™x,y‚ü´‚Äñ) + normSqF y := by
        exact cauchy_schwarz_aux (‚ü™x,y‚ü´ ‚Ä¢ x) y (t/‚Äñ‚ü™x,y‚ü´‚Äñ)
      rw [inner_smul_left, RCLike.conj_mul, sq, ‚Üê RCLike.ofReal_mul, RCLike.ofReal_re, normSq,
        inner_smul_left, inner_smul_right, ‚Üê mul_assoc, RCLike.conj_mul, sq, ‚Üê RCLike.ofReal_mul]
        at htxy
      simp only [ofReal_mul, mul_re, ofReal_re, ofReal_im, mul_zero, sub_zero, mul_im, zero_mul,
        add_zero] at htxy
      rw [normSq, normSq]
      have : 0 ‚â§ ‚Äñ‚ü™x, y‚ü´‚Äñ / ‚Äñ‚ü™x, y‚ü´‚Äñ * ‚Äñ‚ü™x, y‚ü´‚Äñ / ‚Äñ‚ü™x, y‚ü´‚Äñ * re ‚ü™x, x‚ü´ * t * t +
          ‚Äñ‚ü™x, y‚ü´‚Äñ / ‚Äñ‚ü™x, y‚ü´‚Äñ * 2 * ‚Äñ‚ü™x, y‚ü´‚Äñ * t + normSqF y := by
        calc 0 ‚â§ ‚Äñ‚ü™x, y‚ü´‚Äñ * ‚Äñ‚ü™x, y‚ü´‚Äñ * re ‚ü™x, x‚ü´ * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ) +
          2 * (‚Äñ‚ü™x, y‚ü´‚Äñ * ‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ) + normSq y := htxy
          _ = ‚Äñ‚ü™x, y‚ü´‚Äñ / ‚Äñ‚ü™x, y‚ü´‚Äñ * ‚Äñ‚ü™x, y‚ü´‚Äñ / ‚Äñ‚ü™x, y‚ü´‚Äñ * re ‚ü™x, x‚ü´ * t * t +
          ‚Äñ‚ü™x, y‚ü´‚Äñ / ‚Äñ‚ü™x, y‚ü´‚Äñ * 2* ‚Äñ‚ü™x, y‚ü´‚Äñ * t + normSq y := by ring
      rw [div_self hzero, one_mul, one_mul, div_self hzero, one_mul] at this
      exact this
  have hnegdiscrim : (2 * ‚Äñ‚ü™x, y‚ü´‚Äñ)^2 - 4 * normSqF x * normSqF y ‚â§ 0 := by
    rw [‚Üê discrim]
    exact discrim_le_zero hdiscrim
  rw [normSq, normSq, sq] at hnegdiscrim
  nth_rw 1 [norm_inner_symm x y] at hnegdiscrim
  linarith","error:  function expected at
  cauchy_schwarz_aux (‚ü™x, y‚ü´_ùïú ‚Ä¢ x) y
term has type
  normSq (‚ü™‚ü™x, y‚ü´_ùïú ‚Ä¢ x, y‚ü´_?m.110795 ‚Ä¢ ‚ü™x, y‚ü´_ùïú ‚Ä¢ x - ‚ü™‚ü™x, y‚ü´_ùïú ‚Ä¢ x, ‚ü™x, y‚ü´_ùïú ‚Ä¢ x‚ü´_?m.110795 ‚Ä¢ y) =
    normSq (‚ü™x, y‚ü´_ùïú ‚Ä¢ x) * (normSq (‚ü™x, y‚ü´_ùïú ‚Ä¢ x) * normSq y - ‚Äñ‚ü™‚ü™x, y‚ü´_ùïú ‚Ä¢ x, y‚ü´_?m.110795‚Äñ ^ 2)
error:  unknown identifier 'discrim'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.120075
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù¬≤ : _root_.RCLike ùïú
inst‚úù¬π : AddCommGroup F
inst‚úù : Module ùïú F
c : Core ùïú F
x y : F
hdiscrim : ‚àÄ (t : ‚Ñù), 0 ‚â§ normSq x * t * t + 2 * ‚Äñ‚ü™x, y‚ü´_ùïú‚Äñ * t + normSq y
‚ä¢ (2 * ‚Äñ‚ü™x, y‚ü´_ùïú‚Äñ) ^ 2 - 4 * normSq x * normSq y ‚â§ 0","theorem inner_mul_inner_self_le (x y : F) : ‚Äñ‚ü™x, y‚ü´‚Äñ * ‚Äñ‚ü™y, x‚ü´‚Äñ ‚â§ re ‚ü™x, x‚ü´ * re ‚ü™y, y‚ü´ ",":= by
  rcases eq_or_ne x 0 with (rfl | hx)
  ¬∑ simpa only [inner_zero_left, map_zero, zero_mul, norm_zero] using le_rfl
  ¬∑ have hx' : 0 < normSqF x := inner_self_nonneg.lt_of_ne' (mt normSq_eq_zero.1 hx)
    rw [‚Üê sub_nonneg, ‚Üê mul_nonneg_iff_right_nonneg_of_pos hx', ‚Üê normSq, ‚Üê normSq,
      norm_inner_symm y, ‚Üê sq, ‚Üê cauchy_schwarz_aux]
    exact inner_self_nonneg"
Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean,Matrix.SpecialLinearGroup.mem_center_iff,mem_center_iff,67a30f55cabb8ddd087043d4900eb7947be27d10,":= by
  rcases isEmpty_or_nonempty n with hn | ‚ü®‚ü®i‚ü©‚ü©; ¬∑ exact ‚ü®by aesop, by simp [Subsingleton.elim A 1]‚ü©
  refine ‚ü®fun h ‚Ü¶  ‚ü®A i i, ?_, ?_‚ü©, fun ‚ü®r, _, hr‚ü© ‚Ü¶ mem_center_iff.mpr fun B ‚Ü¶ ?_‚ü©
  ¬∑ have : det ((scalar n) (A i i)) = 1 := (scalar_eq_self_of_mem_center h i).symm ‚ñ∏ A.property
    simpa using this
  ¬∑ exact scalar_eq_self_of_mem_center h i
  ¬∑ suffices ‚Üë‚Çò(B * A) = ‚Üë‚Çò(A * B) from Subtype.val_injective this
    simpa only [coe_mul, ‚Üê hr] using (scalar_commute (n := n) r (Commute.all r) B).symm","warning:  SpecialLinearGroup does not have a doc string
warning:  @transpose does not have a doc string
error:  application type mismatch
  mem_center_iff.mpr fun B ‚Ü¶ ?m.106560 B
argument
  fun B ‚Ü¶ ?m.106560 B
has type
  (B : ?m.106554) ‚Üí ?m.106559 B : Sort (imax ?u.106553 ?u.106556)
but is expected to have type
  ‚àÉ r, r ^ Fintype.card n = 1 ‚àß (scalar n) r = ‚ÜëA : Prop
error:  no goals to be solved
error:  fail to show termination for
  Matrix.SpecialLinearGroup.mem_center_iff
with errors
structural recursion cannot be used:

argument #1 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #2 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #3 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #4 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #5 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #6 cannot be used for structural recursion
  it is unchanged in the recursive calls

well-founded recursion cannot be used, 'Matrix.SpecialLinearGroup.mem_center_iff' does not take any (non-fixed) arguments","theorem mem_center_iff {A : SpecialLinearGroup n R} :
    A ‚àà center (SpecialLinearGroup n R) ‚Üî ‚àÉ (r : R), r ^ (Fintype.card n) = 1 ‚àß scalar n r = A ",":= by
  rcases isEmpty_or_nonempty n with hn | ‚ü®‚ü®i‚ü©‚ü©; ¬∑ exact ‚ü®by aesop, by simp [Subsingleton.elim A 1]‚ü©
  refine ‚ü®fun h ‚Ü¶ ‚ü®A i i, ?_, ?_‚ü©, fun ‚ü®r, _, hr‚ü© ‚Ü¶ Subgroup.mem_center_iff.mpr fun B ‚Ü¶ ?_‚ü©
  ¬∑ have : det ((scalar n) (A i i)) = 1 := (scalar_eq_self_of_mem_center h i).symm ‚ñ∏ A.property
    simpa using this
  ¬∑ exact scalar_eq_self_of_mem_center h i
  ¬∑ suffices ‚Üë‚Çò(B * A) = ‚Üë‚Çò(A * B) from Subtype.val_injective this
    simpa only [coe_mul, ‚Üê hr] using (scalar_commute (n := n) r (Commute.all r) B).symm"
Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean,mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt,mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt,a76dc22f3a90e5ab96e9284d30276a87a4324a5d,":= by
  have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
    hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
  letI := finiteDimensional B
  set P := minpoly R B.gen with hP
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  haveI : NoZeroSMulDivisors R L := NoZeroSMulDivisors.trans R K L
  let _ := P.map (algebraMap R L)
  rw [adjoin_singleton_eq_range_aeval] at hz
  obtain ‚ü®Q‚ÇÅ, hQ‚ü© := hz
  set Q := Q‚ÇÅ %‚Çò P with hQ‚ÇÅ
  replace hQ : aeval B.gen Q = p ‚Ä¢ z
  ¬∑ rw [‚Üê modByMonic_add_div Q‚ÇÅ (minpoly.monic hBint)] at hQ
    simpa using hQ
  by_cases hQzero : Q = 0
  ¬∑ simp only [hQzero, Algebra.smul_def, zero_eq_mul, aeval_zero] at hQ
    cases' hQ with H H‚ÇÅ
    ¬∑ have : Function.Injective (algebraMap R L) := by
        rw [algebraMap_eq R K L]
        exact (algebraMap K L).injective.comp (IsFractionRing.injective R K)
      exfalso
      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)
    ¬∑ rw [H‚ÇÅ]
      exact Subalgebra.zero_mem _
  refine mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => ?_) hQ
  induction' i using Nat.case_strong_induction_on with j hind
  ¬∑ intro _
    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt hp hBint hQ hzint hei
  ¬∑ intro hj
    convert hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd _ hndiv
    exact n
    have H := degree_modByMonic_lt Q‚ÇÅ (minpoly.monic hBint)
    rw [‚Üê hQ‚ÇÅ, ‚Üê hP] at H
    replace H := Nat.lt_iff_add_one_le.1
      (lt_of_lt_of_le
        (lt_of_le_of_lt (Nat.lt_iff_add_one_le.1 (Nat.lt_of_succ_lt_succ (mem_range.1 hj)))
          (lt_succ_self _)) (Nat.lt_iff_add_one_le.1 ((natDegree_lt_natDegree_iff hQzero).2 H)))
    rw [add_assoc] at H
    have Hj : Q.natDegree + 1 = j + 1 + (Q.natDegree - j) := by
      rw [‚Üê add_comm 1, ‚Üê add_comm 1, add_assoc, add_right_inj,
        ‚Üê Nat.add_sub_assoc (Nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm,
        Nat.add_sub_cancel]
    choose! g hg using hind
    replace hg : ‚àÄ k ‚àà range (j + 1), Q.coeff k ‚Ä¢ B.gen ^ k = algebraMap R L p * g k ‚Ä¢ B.gen ^ k
    ¬∑ intro k hk
      rw [hg k (mem_range_succ_iff.1 hk)
        (mem_range_succ_iff.2
          (le_trans (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),
        Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, mul_assoc]
    choose! f hf using
      IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
        (minpoly.monic hBint) hei.isWeaklyEisensteinAt
    have hf‚ÇÅ : ‚àÄ k ‚àà (range (Q.natDegree - j)).erase 0,
        Q.coeff (j + 1 + k) ‚Ä¢ B.gen ^ (j + 1 + k) * B.gen ^ (P.natDegree - (j + 2)) =
        (algebraMap R L) p * Q.coeff (j + 1 + k) ‚Ä¢ f (k + P.natDegree - 1) := by
      intro k hk
      rw [smul_mul_assoc, ‚Üê pow_add, ‚Üê Nat.add_sub_assoc H, ‚Üê add_assoc j 1 1, add_comm (j + 1) 1,
        add_assoc (j + 1), add_comm _ (k + P.natDegree), Nat.add_sub_add_right,
        ‚Üê (hf (k + P.natDegree - 1) _).2, mul_smul_comm]
      rw [(minpoly.monic hBint).natDegree_map, add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact Nat.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    suffices
        p ^ n.succ ‚à£ Q.coeff (succ j) ^ n.succ *
          (minpoly R B.gen).coeff 0 ^ (succ j + (P.natDegree - (j + 2))) by
      convert this
      rw [Nat.succ_eq_add_one, add_assoc, ‚Üê Nat.add_sub_assoc H, ‚Üê add_assoc, add_comm (j + 1),
        Nat.add_sub_add_left, ‚Üê Nat.add_sub_assoc, Nat.add_sub_add_left, hP, ‚Üê
        (minpoly.monic hBint).natDegree_map (algebraMap R K), ‚Üê
        minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, natDegree_minpoly, hn, Nat.sub_one,
        Nat.pred_succ]
      linarith
    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_addLeftEmbedding _ _),
      sum_congr rfl hg, add_comm] at hQ
    replace hQ := congr_arg (fun x => x * B.gen ^ (P.natDegree - (j + 2))) hQ
    simp_rw [sum_map, addLeftEmbedding_apply, add_mul, sum_mul, mul_assoc] at hQ
    rw [‚Üê insert_erase
      (mem_range.2 (tsub_pos_iff_lt.2 <| Nat.lt_of_succ_lt_succ <| mem_range.1 hj)),
      sum_insert (not_mem_erase 0 _), add_zero, sum_congr rfl hf‚ÇÅ, ‚Üê mul_sum, ‚Üê mul_sum, add_assoc,
      ‚Üê mul_add, smul_mul_assoc, ‚Üê pow_add, Algebra.smul_def] at hQ
    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)
    have hintsum : IsIntegral R (z * B.gen ^ (P.natDegree - (j + 2)) -
        (‚àë x : ‚Ñï in (range (Q.natDegree - j)).erase 0,
          Q.coeff (j + 1 + x) ‚Ä¢ f (x + P.natDegree - 1) +
            ‚àë x : ‚Ñï in range (j + 1), g x ‚Ä¢ B.gen ^ x * B.gen ^ (P.natDegree - (j + 2)))) := by
      refine IsIntegral.sub (IsIntegral.mul hzint (IsIntegral.pow hBint _))
          (IsIntegral.add (IsIntegral.sum _ fun k hk => IsIntegral.smul _ ?_)
            (IsIntegral.sum _ fun k _ =>
              IsIntegral.mul (IsIntegral.smul _ (IsIntegral.pow hBint _)) (IsIntegral.pow hBint _)))
      refine adjoin_le_integralClosure hBint (hf _ ?_).1
      rw [(minpoly.monic hBint).natDegree_map (algebraMap R L)]
      rw [add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact _root_.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
    rw [Algebra.smul_def, mul_assoc, ‚Üê mul_sub, _root_.map_mul, algebraMap_apply R K L, map_pow,
      Algebra.norm_algebraMap, _root_.map_mul, algebraMap_apply R K L, Algebra.norm_algebraMap,
      finrank B, ‚Üê hr, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map,
      show (-1 : K) = algebraMap R K (-1) by simp, ‚Üê map_pow, ‚Üê map_pow, ‚Üê _root_.map_mul, ‚Üê
      map_pow, ‚Üê _root_.map_mul, ‚Üê map_pow, ‚Üê _root_.map_mul] at hQ
    have hppdiv : p ^ B.dim ‚à£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _
    rwa [‚Üê IsFractionRing.injective R K hQ, mul_comm, ‚Üê Units.coe_neg_one, mul_pow, ‚Üê
      Units.val_pow_eq_pow_val, ‚Üê Units.val_pow_eq_pow_val, mul_assoc,
      IsUnit.dvd_mul_left _ _ _ ‚ü®_, rfl‚ü©, mul_comm, ‚Üê Nat.succ_eq_add_one, hn] at hppdiv","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case intro.intro
R : Type u
K : Type v
L : Type z
p : R
inst‚úù¬π‚Å∞ : CommRing R
inst‚úù‚Åπ : Field K
inst‚úù‚Å∏ : Field L
inst‚úù‚Å∑ : Algebra K L
inst‚úù‚Å∂ : Algebra R L
inst‚úù‚Åµ : Algebra R K
inst‚úù‚Å¥ : IsScalarTower R K L
inst‚úù¬≥ : IsSeparable K L
inst‚úù¬≤ : IsDomain R
inst‚úù¬π : IsFractionRing R K
inst‚úù : IsIntegrallyClosed R
B : PowerBasis K L
hp : _root_.Prime p
hBint : IsIntegral R B.gen
z : L
hzint : IsIntegral R z
this‚úù : Module.Finite K L := finiteDimensional B
P : R[X] := minpoly R B.gen
hei : P.IsEisensteinAt (Submodule.span R {p})
hndiv : ¬¨p ^ 2 ‚à£ P.coeff 0
hP : P = minpoly R B.gen
n : ‚Ñï
hn : B.dim = n.succ
this : NoZeroSMulDivisors R L
x‚úù : L[X] := Polynomial.map (algebraMap R L) P
Q‚ÇÅ : R[X]
Q : R[X] := Q‚ÇÅ %‚Çò P
hQ‚ÇÅ : Q = Q‚ÇÅ %‚Çò P
hQ : (aeval B.gen) Q = p ‚Ä¢ z
‚ä¢ z ‚àà adjoin R {B.gen}","theorem mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} (hzint : IsIntegral R z)
    (hz : p ‚Ä¢ z ‚àà adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) :
    z ‚àà adjoin R ({B.gen} : Set L) ",":= by
  have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
    hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
  have := B.finite
  set P := minpoly R B.gen with hP
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  haveI : NoZeroSMulDivisors R L := NoZeroSMulDivisors.trans R K L
  let _ := P.map (algebraMap R L)
  rw [adjoin_singleton_eq_range_aeval] at hz
  obtain ‚ü®Q‚ÇÅ, hQ‚ü© := hz
  set Q := Q‚ÇÅ %‚Çò P with hQ‚ÇÅ
  replace hQ : aeval B.gen Q = p ‚Ä¢ z := by
    rw [‚Üê modByMonic_add_div Q‚ÇÅ (minpoly.monic hBint)] at hQ
    simpa using hQ
  by_cases hQzero : Q = 0
  ¬∑ simp only [hQzero, Algebra.smul_def, zero_eq_mul, aeval_zero] at hQ
    cases' hQ with H H‚ÇÅ
    ¬∑ have : Function.Injective (algebraMap R L) := by
        rw [algebraMap_eq R K L]
        exact (algebraMap K L).injective.comp (IsFractionRing.injective R K)
      exfalso
      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)
    ¬∑ rw [H‚ÇÅ]
      exact Subalgebra.zero_mem _
  refine mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => ?_) hQ
  induction' i using Nat.case_strong_induction_on with j hind
  ¬∑ intro _
    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt hp hBint hQ hzint hei
  ¬∑ intro hj
    convert hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd (n := n) _ hndiv
    have H := degree_modByMonic_lt Q‚ÇÅ (minpoly.monic hBint)
    rw [‚Üê hQ‚ÇÅ, ‚Üê hP] at H
    replace H := Nat.lt_iff_add_one_le.1
      (lt_of_lt_of_le
        (lt_of_le_of_lt (Nat.lt_iff_add_one_le.1 (Nat.lt_of_succ_lt_succ (mem_range.1 hj)))
          (lt_succ_self _)) (Nat.lt_iff_add_one_le.1 ((natDegree_lt_natDegree_iff hQzero).2 H)))
    have Hj : Q.natDegree + 1 = j + 1 + (Q.natDegree - j) := by
      rw [‚Üê add_comm 1, ‚Üê add_comm 1, add_assoc, add_right_inj,
        ‚Üê Nat.add_sub_assoc (Nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm,
        Nat.add_sub_cancel]
    choose! g hg using hind
    replace hg : ‚àÄ k ‚àà range (j + 1), Q.coeff k ‚Ä¢ B.gen ^ k =
        algebraMap R L p * g k ‚Ä¢ B.gen ^ k := by
      intro k hk
      rw [hg k (mem_range_succ_iff.1 hk)
        (mem_range_succ_iff.2
          (le_trans (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),
        Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, mul_assoc]
    choose! f hf using
      IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
        (minpoly.monic hBint) hei.isWeaklyEisensteinAt
    have hf‚ÇÅ : ‚àÄ k ‚àà (range (Q.natDegree - j)).erase 0,
        Q.coeff (j + 1 + k) ‚Ä¢ B.gen ^ (j + 1 + k) * B.gen ^ (P.natDegree - (j + 2)) =
        (algebraMap R L) p * Q.coeff (j + 1 + k) ‚Ä¢ f (k + P.natDegree - 1) := by
      intro k hk
      rw [smul_mul_assoc, ‚Üê pow_add, ‚Üê Nat.add_sub_assoc H, add_comm (j + 1) 1,
        add_assoc (j + 1), add_comm _ (k + P.natDegree), Nat.add_sub_add_right,
        ‚Üê (hf (k + P.natDegree - 1) _).2, mul_smul_comm]
      rw [(minpoly.monic hBint).natDegree_map, add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact Nat.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    suffices
        p ^ n.succ ‚à£ Q.coeff (succ j) ^ n.succ *
          (minpoly R B.gen).coeff 0 ^ (succ j + (P.natDegree - (j + 2))) by
      convert this
      rw [Nat.succ_eq_add_one, add_assoc, ‚Üê Nat.add_sub_assoc H, add_comm (j + 1),
        Nat.add_sub_add_left, ‚Üê Nat.add_sub_assoc, Nat.add_sub_add_left, hP, ‚Üê
        (minpoly.monic hBint).natDegree_map (algebraMap R K), ‚Üê
        minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, natDegree_minpoly, hn, Nat.sub_one,
        Nat.pred_succ]
      omega
    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_addLeftEmbedding _ _),
      sum_congr rfl hg, add_comm] at hQ
    replace hQ := congr_arg (fun x => x * B.gen ^ (P.natDegree - (j + 2))) hQ
    simp_rw [sum_map, addLeftEmbedding_apply, add_mul, sum_mul, mul_assoc] at hQ
    rw [‚Üê insert_erase
      (mem_range.2 (tsub_pos_iff_lt.2 <| Nat.lt_of_succ_lt_succ <| mem_range.1 hj)),
      sum_insert (not_mem_erase 0 _), add_zero, sum_congr rfl hf‚ÇÅ, ‚Üê mul_sum, ‚Üê mul_sum, add_assoc,
      ‚Üê mul_add, smul_mul_assoc, ‚Üê pow_add, Algebra.smul_def] at hQ
    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)
    have hintsum : IsIntegral R (z * B.gen ^ (P.natDegree - (j + 2)) -
        (‚àë x ‚àà (range (Q.natDegree - j)).erase 0,
          Q.coeff (j + 1 + x) ‚Ä¢ f (x + P.natDegree - 1) +
            ‚àë x ‚àà range (j + 1), g x ‚Ä¢ B.gen ^ x * B.gen ^ (P.natDegree - (j + 2)))) := by
      refine (hzint.mul (hBint.pow _)).sub
        (.add (.sum _ fun k hk => .smul _ ?_)
          (.sum _ fun k _ => .mul (.smul _ (.pow hBint _)) (hBint.pow _)))
      refine adjoin_le_integralClosure hBint (hf _ ?_).1
      rw [(minpoly.monic hBint).natDegree_map (algebraMap R L)]
      rw [add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact _root_.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
    rw [Algebra.smul_def, mul_assoc, ‚Üê mul_sub, _root_.map_mul, algebraMap_apply R K L, map_pow,
      Algebra.norm_algebraMap, _root_.map_mul, algebraMap_apply R K L, Algebra.norm_algebraMap,
      finrank B, ‚Üê hr, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map,
      show (-1 : K) = algebraMap R K (-1) by simp, ‚Üê map_pow, ‚Üê map_pow, ‚Üê _root_.map_mul, ‚Üê
      map_pow, ‚Üê _root_.map_mul, ‚Üê map_pow, ‚Üê _root_.map_mul] at hQ
    have hppdiv : p ^ B.dim ‚à£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _
    rwa [‚Üê IsFractionRing.injective R K hQ, mul_comm, ‚Üê Units.coe_neg_one, mul_pow, ‚Üê
      Units.val_pow_eq_pow_val, ‚Üê Units.val_pow_eq_pow_val, mul_assoc,
      Units.dvd_mul_left, mul_comm, ‚Üê Nat.succ_eq_add_one, hn] at hppdiv"
Mathlib/MeasureTheory/Measure/AddContent.lean,MeasureTheory.addContent_biUnion_le,addContent_biUnion_le,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
  induction' S with i S hiS h hs
  ¬∑ simp
  ¬∑ rw [Finset.sum_insert hiS]
    simp_rw [‚Üê Finset.mem_coe, Finset.coe_insert, Set.biUnion_insert]
    simp only [Finset.mem_insert, forall_eq_or_imp] at hs
    refine (addContent_union_le hC hs.1 (hC.biUnion_mem S hs.2)).trans ?_
    exact add_le_add le_rfl (h hs.2)","error:  unsolved goals
case mk
Œ± : Type u_1
C : Set (Set Œ±)
s‚úù t : Set Œ±
I : Finset (Set Œ±)
m m' : AddContent C
Œπ : Type u_2
hC : IsSetRing C
s : Œπ ‚Üí Set Œ±
i : Multiset Œπ
S : i.Nodup
hs : ‚àÄ n ‚àà { val := i, nodup := S }, s n ‚àà C
‚ä¢ m (‚ãÉ i_1 ‚àà i, s i_1) ‚â§ (Multiset.map (fun i ‚Ü¶ m (s i)) i).sum
error:  no goals to be solved","lemma addContent_biUnion_le {Œπ : Type*} (hC : IsSetRing C) {s : Œπ ‚Üí Set Œ±}
    {S : Finset Œπ} (hs : ‚àÄ n ‚àà S, s n ‚àà C) :
    m (‚ãÉ i ‚àà S, s i) ‚â§ ‚àë i ‚àà S, m (s i) ",":= by
  classical
  induction' S using Finset.induction with i S hiS h hs
  ¬∑ simp
  ¬∑ rw [Finset.sum_insert hiS]
    simp_rw [‚Üê Finset.mem_coe, Finset.coe_insert, Set.biUnion_insert]
    simp only [Finset.mem_insert, forall_eq_or_imp] at hs
    refine (addContent_union_le hC hs.1 (hC.biUnion_mem S hs.2)).trans ?_
    exact add_le_add le_rfl (h hs.2)"
Mathlib/LinearAlgebra/LinearPMap.lean,LinearPMap.smul_graph,smul_graph,dd9d2939f7f4933231c9afead607499e5a048f4f,":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  ¬∑ rw [mem_graph_iff] at h
    rcases h with ‚ü®y, hy, h‚ü©
    rw [LinearPMap.smul_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id.def,
      LinearMap.smul_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y
    simp [hy, h]
  rw [Submodule.mem_map] at h
  rcases h with ‚ü®x', hx', h‚ü©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id.def, LinearMap.smul_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' ‚ä¢
  rcases hx' with ‚ü®y, hy, hx'‚ü©
  use y
  rw [‚Üê h.1, ‚Üê h.2]
  simp [hy, hx']","warning:  LinearPMap does not have a doc string
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.532750 ‚Üí ?m.532750
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.536657 ‚Üí ?m.536657","theorem smul_graph (f : E ‚Üí‚Çó.[R] F) (z : M) :
    (z ‚Ä¢ f).graph =
      f.graph.map ((LinearMap.id : E ‚Üí‚Çó[R] E).prodMap (z ‚Ä¢ (LinearMap.id : F ‚Üí‚Çó[R] F))) ",":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  ¬∑ rw [mem_graph_iff] at h
    rcases h with ‚ü®y, hy, h‚ü©
    rw [LinearPMap.smul_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id,
      LinearMap.smul_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y, hy
  rw [Submodule.mem_map] at h
  rcases h with ‚ü®x', hx', h‚ü©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id, LinearMap.smul_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' ‚ä¢
  rcases hx' with ‚ü®y, hy, hx'‚ü©
  use y
  rw [‚Üê h.1, ‚Üê h.2]
  simp [hy, hx']"
Mathlib/Topology/Sheaves/Presheaf.lean,TopCat.Presheaf.id_pushforward,id_pushforward,c64a8cc65b547d6c3abd420df4b8923dee790c78,":= by
  apply CategoryTheory.Functor.ext
  ¬∑ intros a b f
    ext U
    ¬∑ erw [NatTrans.congr f (Opens.op_map_id_obj (op U))]
      ¬∑ simp only [Functor.op_obj, eqToHom_refl, CategoryTheory.Functor.map_id,
          Category.comp_id, Category.id_comp, Functor.id_obj, Functor.id_map]
      apply Pushforward.id_eq","error:  no goals to be solved
error:  unsolved goals
case h_obj
C : Type u
inst‚úù : Category.{v, u} C
X : TopCat
‚ä¢ ‚àÄ (X_1 : Presheaf C X), (pushforward C (ùüô X)).obj X_1 = (ùü≠ (Presheaf C X)).obj X_1",theorem id_pushforward {X : TopCat.{w}} : pushforward C (ùüô X) = ùü≠ (X.Presheaf C) ,":= by
  apply CategoryTheory.Functor.ext
  ¬∑ intros a b f
    ext U
    ¬∑ erw [NatTrans.congr f (Opens.op_map_id_obj (op U))]
      ¬∑ simp only [Functor.op_obj, eqToHom_refl, CategoryTheory.Functor.map_id,
          Category.comp_id, Category.id_comp, Functor.id_obj, Functor.id_map]
  ¬∑ apply Pushforward.id_eq"
Mathlib/Probability/Distributions/Gaussian.lean,ProbabilityTheory.gaussianReal_map_add_const,gaussianReal_map_add_const,ae8b24f33174f0b9fcd8f2d87ba6c65a18ae9ceb,":= by
  by_cases hv : v = 0
  ¬∑ simp only [hv, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.add_const _) _
  let e : ‚Ñù ‚âÉ·µê ‚Ñù := (Homeomorph.addRight y).symm.toMeasurableEquiv
  have he' : ‚àÄ x, HasDerivAt e ((fun _ ‚Ü¶ 1) x) x := fun _ ‚Ü¶ (hasDerivAt_id _).sub_const y
  change (gaussianReal Œº v).map e.symm = gaussianReal (Œº + y) v
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs']
  simp only [abs_neg, abs_one, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, one_mul, ne_eq]
  rw [gaussianReal_apply_eq_integral _ hv s']
  simp [gaussianPdfReal_sub _ y, Homeomorph.addRight, ‚Üê sub_eq_add_neg]","error:  unknown identifier 'gaussianPdfReal_sub'
error:  simp made no progress","lemma gaussianReal_map_add_const (y : ‚Ñù) :
    (gaussianReal Œº v).map (¬∑ + y) = gaussianReal (Œº + y) v ",":= by
  by_cases hv : v = 0
  ¬∑ simp only [hv, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.add_const _) _
  let e : ‚Ñù ‚âÉ·µê ‚Ñù := (Homeomorph.addRight y).symm.toMeasurableEquiv
  have he' : ‚àÄ x, HasDerivAt e ((fun _ ‚Ü¶ 1) x) x := fun _ ‚Ü¶ (hasDerivAt_id _).sub_const y
  change (gaussianReal Œº v).map e.symm = gaussianReal (Œº + y) v
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs']
  simp only [abs_neg, abs_one, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, one_mul, ne_eq]
  rw [gaussianReal_apply_eq_integral _ hv s']
  simp [e, gaussianPDFReal_sub _ y, Homeomorph.addRight, ‚Üê sub_eq_add_neg]"
Mathlib/RingTheory/PrincipalIdealDomain.lean,IsPrincipalIdealRing.of_prime,IsPrincipalIdealRing.of_prime,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  rw [‚Üê nonPrincipals_eq_empty_iff, Set.eq_empty_iff_forall_not_mem]
  intro J hJ
  obtain ‚ü®I, Ibad, -, Imax‚ü© := zorn_nonempty_partialOrder‚ÇÄ (nonPrincipals R) nonPrincipals_zorn _ hJ
  have Imax' : ‚àÄ {J}, I < J ‚Üí J.IsPrincipal := by
    intro J hJ
    by_contra He
    exact hJ.ne (Imax _ ((nonPrincipals_def R).2 He) hJ.le).symm
  by_cases hI1 : I = ‚ä§
  ¬∑ subst hI1
    exact Ibad top_isPrincipal
  refine Ibad (H I ‚ü®hI1, fun {x y} hxy => or_iff_not_imp_right.mpr fun hy => ?_‚ü©)
  obtain ‚ü®a, ha‚ü© : (I ‚äî span {y}).IsPrincipal :=
    Imax' (left_lt_sup.mpr (mt I.span_singleton_le_iff_mem.mp hy))
  suffices He : ¬¨(I.colon (span {y})).IsPrincipal by
    rw [‚Üê Imax _ ((nonPrincipals_def R).2 He) fun a ha =>
        Ideal.mem_colon_singleton.2 (mul_mem_right _ _ ha)]
    exact Ideal.mem_colon_singleton.2 hxy
  rintro ‚ü®b, hb‚ü©
  refine (nonPrincipals_def _).1 Ibad ‚ü®a * b, ?_‚ü©
  refine
    le_antisymm (Œ± := Ideal R) (fun i hi => ?_) <| (span_singleton_mul_span_singleton a b).ge.trans? _
  ¬∑ have hisup : i ‚àà I ‚äî span {y} := Ideal.mem_sup_left hi
    have : y ‚àà I ‚äî span {y} := Ideal.mem_sup_right (Ideal.mem_span_singleton_self y)
    erw [ha, mem_span_singleton'] at hisup this
    obtain ‚ü®v, rfl‚ü© := this
    obtain ‚ü®u, rfl‚ü© := hisup
    have hucolon : u ‚àà I.colon (span {v * a}) := by
      rw [Ideal.mem_colon_singleton, mul_comm v, ‚Üê mul_assoc]
      exact mul_mem_right _ _ hi
    erw [hb, mem_span_singleton'] at hucolon
    obtain ‚ü®z, rfl‚ü© := hucolon
    exact mem_span_singleton'.2 ‚ü®z, by ring‚ü©
  ¬∑ rw [‚Üê Ideal.submodule_span_eq, ‚Üê ha, Ideal.sup_mul, sup_le_iff,
      span_singleton_mul_span_singleton, mul_comm y, Ideal.span_singleton_le_iff_mem]
    exact ‚ü®mul_le_right, Ideal.mem_colon_singleton.1 <| hb.symm ‚ñ∏ Ideal.mem_span_singleton_self b‚ü©","error:  invalid field 'trans?', the environment does not contain 'LE.le.trans?'
  Eq.ge (span_singleton_mul_span_singleton a b)
has type
  Ideal.span {a * b} ‚â§ Ideal.span {a} * Ideal.span {b}
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Eq.ge (span_singleton_mul_span_singleton a b)
has type
  ?m.139941 ‚àà Ideal.span {a * b} ‚Üí ?m.139941 ‚àà Ideal.span {a} * Ideal.span {b}
error:  no goals to be solved","theorem IsPrincipalIdealRing.of_prime (H : ‚àÄ P : Ideal R, P.IsPrime ‚Üí P.IsPrincipal) :
    IsPrincipalIdealRing R ",":= by
  rw [‚Üê nonPrincipals_eq_empty_iff, Set.eq_empty_iff_forall_not_mem]
  intro J hJ
  obtain ‚ü®I, Ibad, -, Imax‚ü© := zorn_nonempty_partialOrder‚ÇÄ (nonPrincipals R) nonPrincipals_zorn _ hJ
  have Imax' : ‚àÄ {J}, I < J ‚Üí J.IsPrincipal := by
    intro J hJ
    by_contra He
    exact hJ.ne (Imax _ ((nonPrincipals_def R).2 He) hJ.le).symm
  by_cases hI1 : I = ‚ä§
  ¬∑ subst hI1
    exact Ibad top_isPrincipal
  refine Ibad (H I ‚ü®hI1, fun {x y} hxy => or_iff_not_imp_right.mpr fun hy => ?_‚ü©)
  obtain ‚ü®a, ha‚ü© : (I ‚äî span {y}).IsPrincipal :=
    Imax' (left_lt_sup.mpr (mt I.span_singleton_le_iff_mem.mp hy))
  suffices He : ¬¨(I.colon (span {y})).IsPrincipal by
    rw [‚Üê Imax _ ((nonPrincipals_def R).2 He) fun a ha =>
        Ideal.mem_colon_singleton.2 (mul_mem_right _ _ ha)]
    exact Ideal.mem_colon_singleton.2 hxy
  rintro ‚ü®b, hb‚ü©
  refine (nonPrincipals_def _).1 Ibad ‚ü®a * b, ?_‚ü©
  refine
    le_antisymm (Œ± := Ideal R) (fun i hi => ?_) <|
      (span_singleton_mul_span_singleton a b).ge.trans ?_
  ¬∑ have hisup : i ‚àà I ‚äî span {y} := Ideal.mem_sup_left hi
    have : y ‚àà I ‚äî span {y} := Ideal.mem_sup_right (Ideal.mem_span_singleton_self y)
    erw [ha, mem_span_singleton'] at hisup this
    obtain ‚ü®v, rfl‚ü© := this
    obtain ‚ü®u, rfl‚ü© := hisup
    have hucolon : u ‚àà I.colon (span {v * a}) := by
      rw [Ideal.mem_colon_singleton, mul_comm v, ‚Üê mul_assoc]
      exact mul_mem_right _ _ hi
    erw [hb, mem_span_singleton'] at hucolon
    obtain ‚ü®z, rfl‚ü© := hucolon
    exact mem_span_singleton'.2 ‚ü®z, by ring‚ü©
  ¬∑ rw [‚Üê Ideal.submodule_span_eq, ‚Üê ha, Ideal.sup_mul, sup_le_iff,
      span_singleton_mul_span_singleton, mul_comm y, Ideal.span_singleton_le_iff_mem]
    exact ‚ü®mul_le_right, Ideal.mem_colon_singleton.1 <| hb.symm ‚ñ∏ Ideal.mem_span_singleton_self b‚ü©"
Mathlib/NumberTheory/EllipticDivisibilitySequence.lean,normEDS_ofNat,normEDS_ofNat,eda04d24f539d275bf9161920e57d3d1d3781080,":= by
  rw [normEDS, preNormEDS_ofNat, Int.natAbs_ofNat]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (‚Üë?n).natAbs
R : Type u
S : Type v
inst‚úù¬π : CommRing R
inst‚úù : CommRing S
W : ‚Ñ§ ‚Üí R
f : R ‚Üí+* S
b c d : R
n : ‚Ñï
‚ä¢ (preNormEDS' (b ^ 4) c d n * if Even ‚Üën then b else 1) = preNormEDS' (b ^ 4) c d n * if Even n then b else 1","lemma normEDS_ofNat (n : ‚Ñï) :
    normEDS b c d n = preNormEDS' (b ^ 4) c d n * if Even n then b else 1 ",":= by
  simp only [normEDS, preNormEDS_ofNat, Int.even_coe_nat]"
Mathlib/LinearAlgebra/BilinearForm/DualLattice.lean,LinearMap.BilinForm.le_flip_dualSubmodule,le_flip_dualSubmodule,31c261277bc3e8a52b74d248691ef6b40c75b452,":=
  LinearMap.BilinForm.le_flip_dualSubmodule (BilinForm.toLin B)","error:  function expected at
  le_flip_dualSubmodule
term has type
  ?m.36513 ‚â§ B.flip.dualSubmodule ?m.36514 ‚Üî ?m.36514 ‚â§ B.dualSubmodule ?m.36513","lemma le_flip_dualSubmodule {N‚ÇÅ N‚ÇÇ : Submodule R M} :
    N‚ÇÅ ‚â§ B.flip.dualSubmodule N‚ÇÇ ‚Üî N‚ÇÇ ‚â§ B.dualSubmodule N‚ÇÅ ",":= by
  show (‚àÄ (x : M), x ‚àà N‚ÇÅ ‚Üí _) ‚Üî ‚àÄ (x : M), x ‚àà N‚ÇÇ ‚Üí _
  simp only [mem_dualSubmodule, Submodule.mem_one, flip_apply]
  exact forall‚ÇÇ_swap"
Mathlib/Data/List/Basic.lean,List.get_pmap,get_pmap,e4a42b363401ab96a870d4570f26f1827f33f7af,":= by
  induction' l with hd tl hl generalizing n
  ¬∑ simp only [length, pmap, not_lt_zero] at hn
  ¬∑ cases n
    ¬∑ simp
    ¬∑ simp [hl]","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_map` has been deprecated, use `List.getElem_map` instead
warning:  `List.get_map` has been deprecated, use `List.getElem_map` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_map` has been deprecated, use `List.get_map` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_map` has been deprecated, use `List.get_map` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_append_right_aux` has been deprecated
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_cons_length` has been deprecated, use `List.getElem_cons_length` instead
warning:  `List.drop_eq_get_cons` has been deprecated, use `List.drop_eq_getElem_cons` instead
warning:  `List.ext` has been deprecated
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_reverse_aux‚ÇÅ` has been deprecated
warning:  `List.get_reverse_aux‚ÇÇ` has been deprecated, use `List.getElem_reverse_aux‚ÇÇ` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_reverse` has been deprecated, use `List.getElem_reverse` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.ret` has been deprecated, use `List.pure` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_zero_scanl` has been deprecated, use `List.getElem_scanl_zero` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_zero_scanl` has been deprecated, use `List.get_zero_scanl` instead
warning:  `List.nthLe_append_right` has been deprecated, use `List.get_append_right'` instead
error:  unsolved goals
case cons.succ
Œπ : Type u_1
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
l‚ÇÅ l‚ÇÇ : List Œ±
p : Œ± ‚Üí Prop
f : (a : Œ±) ‚Üí p a ‚Üí Œ≤
hd : Œ±
tl : List Œ±
hl :
  ‚àÄ (h : ‚àÄ (a : Œ±), a ‚àà tl ‚Üí p a) {n : ‚Ñï} (hn : n < (pmap f tl h).length),
    (pmap f tl h).get ‚ü®n, hn‚ü© = f (tl.get ‚ü®n, ‚ãØ‚ü©) ‚ãØ
h : ‚àÄ (a : Œ±), a ‚àà hd :: tl ‚Üí p a
n‚úù : ‚Ñï
hn : n‚úù + 1 < (pmap f (hd :: tl) h).length
‚ä¢ (pmap f tl ‚ãØ)[n‚úù] = f tl[n‚úù] ‚ãØ
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem get_pmap {p : Œ± ‚Üí Prop} (f : ‚àÄ a, p a ‚Üí Œ≤) {l : List Œ±} (h : ‚àÄ a ‚àà l, p a) {n : ‚Ñï}
    (hn : n < (pmap f l h).length) :
    get (pmap f l h) ‚ü®n, hn‚ü© =
      f (get l ‚ü®n, @length_pmap _ _ p f l h ‚ñ∏ hn‚ü©)
        (h _ (get_mem l n (@length_pmap _ _ p f l h ‚ñ∏ hn))) ",":= by
  simp only [get_eq_getElem]
  simp [getElem_pmap]"
Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean,CategoryTheory.Limits.InitialMonoClass.of_isInitial,InitialMonoClass.of_isInitial,9e34a191034458a56331f976ff7400a26407c888,"  isInitial_mono_from {I'} X hI' := by
    dsimp
    rw [hI'.hom_ext (hI'.to X) ((hI'.uniqueUpToIso hI).hom ‚â´ hI.to X)]
    apply mono_comp",error:  dsimp made no progress,"theorem InitialMonoClass.of_isInitial {I : C} (hI : IsInitial I) (h : ‚àÄ X, Mono (hI.to X)) :
    InitialMonoClass C where
","  isInitial_mono_from {I'} X hI' := by
    rw [hI'.hom_ext (hI'.to X) ((hI'.uniqueUpToIso hI).hom ‚â´ hI.to X)]
    apply mono_comp"
Mathlib/MeasureTheory/SetSemiring.lean,MeasureTheory.IsSetSemiring.sUnion_diffFinset‚ÇÄ_subset,sUnion_diffFinset‚ÇÄ_subset,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [‚Üê hC.diff_sUnion_eq_sUnion_diffFinset‚ÇÄ]
  exact diff_subset _ _","error:  function expected at
  diff_subset ?m.24120
term has type
  ?m.24119 ‚àà ?m.24117","lemma sUnion_diffFinset‚ÇÄ_subset (hC : IsSetSemiring C) (hs : s ‚àà C) (hI : ‚ÜëI ‚äÜ C) :
    ‚ãÉ‚ÇÄ (hC.diffFinset‚ÇÄ hs hI : Set (Set Œ±)) ‚äÜ s ",":= by
  rw [‚Üê hC.diff_sUnion_eq_sUnion_diffFinset‚ÇÄ]
  exact diff_subset"
Mathlib/RingTheory/RingHomProperties.lean,RingHom.StableUnderBaseChange.pushout_inl,StableUnderBaseChange.pushout_inl,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  rw [‚Üê
    show _ = pushout.inl from
      colimit.isoColimitCocone_Œπ_inv ‚ü®_, CommRingCat.pushoutCoconeIsColimit f g‚ü©
        WalkingSpan.left,
    hP'.cancel_right_isIso]
  letI := f.toSMul
  letI := f.toAlgebra
  letI := g.toSMul
  letI := g.toAlgebra
  dsimp only [CommRingCat.pushoutCocone_inl, PushoutCocone.Œπ_app_left]
  apply hP R T S (TensorProduct R S T)
  exact H","error:  invalid field 'toSMul', the environment does not contain 'Quiver.Hom.toSMul'
  f
has type
  R ‚ü∂ S
error:  invalid field 'toSMul', the environment does not contain 'CategoryTheory.BundledHom.MapHom.toSMul'
  f
has type
  BundledHom.MapHom (BundledHom.MapHom SemiRingCat.AssocRingHom @Ring.toSemiring) (@CommRing.toRing) R.str S.str
error:  invalid field 'toSMul', the environment does not contain 'CategoryTheory.BundledHom.MapHom.toSMul'
  f
has type
  BundledHom.MapHom SemiRingCat.AssocRingHom (@Ring.toSemiring) CommRing.toRing CommRing.toRing
error:  invalid field 'toSMul', the environment does not contain 'SemiRingCat.AssocRingHom.toSMul'
  f
has type
  SemiRingCat.AssocRingHom ‚ÜëR ‚ÜëS
error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  f
has type
  ‚ÜëR ‚Üí+* ‚ÜëS
error:  unsolved goals
P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí (R ‚Üí+* S) ‚Üí Prop
hP : StableUnderBaseChange P
hP' : RespectsIso P
R S T : CommRingCat
f : R ‚ü∂ S
g : R ‚ü∂ T
H : P g
‚ä¢ P
    ({ cocone := CommRingCat.pushoutCocone f g, isColimit := CommRingCat.pushoutCoconeIsColimit f g }.cocone.Œπ.app
      WalkingSpan.left)","theorem StableUnderBaseChange.pushout_inl (hP : RingHom.StableUnderBaseChange @P)
    (hP' : RingHom.RespectsIso @P) {R S T : CommRingCat} (f : R ‚ü∂ S) (g : R ‚ü∂ T) (H : P g) :
    P (pushout.inl : S ‚ü∂ pushout f g) ",":= by
  rw [‚Üê
    show _ = pushout.inl from
      colimit.isoColimitCocone_Œπ_inv ‚ü®_, CommRingCat.pushoutCoconeIsColimit f g‚ü©
        WalkingSpan.left,
    hP'.cancel_right_isIso]
  letI := f.toAlgebra
  letI := g.toAlgebra
  dsimp only [CommRingCat.pushoutCocone_inl, PushoutCocone.Œπ_app_left]
  apply hP R T S (TensorProduct R S T)
  exact H"
Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean,CategoryTheory.MorphismProperty.RightFractionRel.trans,trans,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  obtain ‚ü®Z‚ÇÑ, t‚ÇÅ, t‚ÇÇ, hst, hft, ht‚ü© := h‚ÇÅ‚ÇÇ
  obtain ‚ü®Z‚ÇÖ, u‚ÇÇ, u‚ÇÉ, hsu, hfu, hu‚ü© := h‚ÇÇ‚ÇÉ
  obtain ‚ü®‚ü®v‚ÇÑ, v‚ÇÖ, hv‚ÇÖ‚ü©, fac‚ü© := HasLeftCalculusOfFractions.exists_leftFraction
    (RightFraction.mk (z‚ÇÅ.s ‚â´ t‚ÇÅ) ht (z‚ÇÉ.s ‚â´ u‚ÇÉ))
  simp only [Category.assoc] at fac
  have eq : z‚ÇÇ.s ‚â´ u‚ÇÇ ‚â´ v‚ÇÖ  = z‚ÇÇ.s ‚â´ t‚ÇÇ ‚â´ v‚ÇÑ := by
    simpa only [‚Üê reassoc_of% hsu, reassoc_of% hst] using fac
  obtain ‚ü®Z‚Çá, w, hw, fac'‚ü© := HasLeftCalculusOfFractions.ext _ _ _ z‚ÇÇ.hs eq
  simp only [Category.assoc] at fac'
  refine ‚ü®Z‚Çá, t‚ÇÅ ‚â´ v‚ÇÑ ‚â´ w, u‚ÇÉ ‚â´ v‚ÇÖ ‚â´ w, ?_, ?_?, _‚ü©
  ¬∑ rw [reassoc_of% fac]
  ¬∑ rw [reassoc_of% hft, ‚Üê fac', reassoc_of% hfu]
  ¬∑ rw [‚Üê reassoc_of% fac, ‚Üê reassoc_of% hsu, ‚Üê Category.assoc]
    exact W.comp_mem _ _ hu (W.comp_mem _ _ hv‚ÇÖ hw)","error:  don't know how to synthesize placeholder for argument 'h'
context:
C : Type u_1
D : Type u_2
inst‚úù¬≤ : Category.{u_3, u_1} C
inst‚úù¬π : Category.{?u.22549, u_2} D
W : MorphismProperty C
X Y : C
z‚ÇÅ z‚ÇÇ z‚ÇÉ : W.LeftFraction X Y
inst‚úù : W.HasLeftCalculusOfFractions
Z‚ÇÑ : C
t‚ÇÅ : z‚ÇÅ.Y' ‚ü∂ Z‚ÇÑ
t‚ÇÇ : z‚ÇÇ.Y' ‚ü∂ Z‚ÇÑ
hst : z‚ÇÅ.s ‚â´ t‚ÇÅ = z‚ÇÇ.s ‚â´ t‚ÇÇ
hft : z‚ÇÅ.f ‚â´ t‚ÇÅ = z‚ÇÇ.f ‚â´ t‚ÇÇ
ht : W (z‚ÇÅ.s ‚â´ t‚ÇÅ)
Z‚ÇÖ : C
u‚ÇÇ : z‚ÇÇ.Y' ‚ü∂ Z‚ÇÖ
u‚ÇÉ : z‚ÇÉ.Y' ‚ü∂ Z‚ÇÖ
hsu : z‚ÇÇ.s ‚â´ u‚ÇÇ = z‚ÇÉ.s ‚â´ u‚ÇÉ
hfu : z‚ÇÇ.f ‚â´ u‚ÇÇ = z‚ÇÉ.f ‚â´ u‚ÇÉ
hu : W (z‚ÇÇ.s ‚â´ u‚ÇÇ)
Y'‚úù : C
v‚ÇÑ : Z‚ÇÑ ‚ü∂ Y'‚úù
v‚ÇÖ : Z‚ÇÖ ‚ü∂ Y'‚úù
hv‚ÇÖ : W v‚ÇÖ
fac : z‚ÇÉ.s ‚â´ u‚ÇÉ ‚â´ v‚ÇÖ = z‚ÇÅ.s ‚â´ t‚ÇÅ ‚â´ v‚ÇÑ
eq : z‚ÇÇ.s ‚â´ u‚ÇÇ ‚â´ v‚ÇÖ = z‚ÇÇ.s ‚â´ t‚ÇÇ ‚â´ v‚ÇÑ
Z‚Çá : C
w : Y'‚úù ‚ü∂ Z‚Çá
hw : W w
fac' : u‚ÇÇ ‚â´ v‚ÇÖ ‚â´ w = t‚ÇÇ ‚â´ v‚ÇÑ ‚â´ w
‚ä¢ W (z‚ÇÅ.s ‚â´ t‚ÇÅ ‚â´ v‚ÇÑ ‚â´ w)
error:  unsolved goals
case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.mk.intro.intro.intro
C : Type u_1
D : Type u_2
inst‚úù¬≤ : Category.{u_3, u_1} C
inst‚úù¬π : Category.{?u.22549, u_2} D
W : MorphismProperty C
X Y : C
z‚ÇÅ z‚ÇÇ z‚ÇÉ : W.LeftFraction X Y
inst‚úù : W.HasLeftCalculusOfFractions
Z‚ÇÑ : C
t‚ÇÅ : z‚ÇÅ.Y' ‚ü∂ Z‚ÇÑ
t‚ÇÇ : z‚ÇÇ.Y' ‚ü∂ Z‚ÇÑ
hst : z‚ÇÅ.s ‚â´ t‚ÇÅ = z‚ÇÇ.s ‚â´ t‚ÇÇ
hft : z‚ÇÅ.f ‚â´ t‚ÇÅ = z‚ÇÇ.f ‚â´ t‚ÇÇ
ht : W (z‚ÇÅ.s ‚â´ t‚ÇÅ)
Z‚ÇÖ : C
u‚ÇÇ : z‚ÇÇ.Y' ‚ü∂ Z‚ÇÖ
u‚ÇÉ : z‚ÇÉ.Y' ‚ü∂ Z‚ÇÖ
hsu : z‚ÇÇ.s ‚â´ u‚ÇÇ = z‚ÇÉ.s ‚â´ u‚ÇÉ
hfu : z‚ÇÇ.f ‚â´ u‚ÇÇ = z‚ÇÉ.f ‚â´ u‚ÇÉ
hu : W (z‚ÇÇ.s ‚â´ u‚ÇÇ)
Y'‚úù : C
v‚ÇÑ : Z‚ÇÑ ‚ü∂ Y'‚úù
v‚ÇÖ : Z‚ÇÖ ‚ü∂ Y'‚úù
hv‚ÇÖ : W v‚ÇÖ
fac : z‚ÇÉ.s ‚â´ u‚ÇÉ ‚â´ v‚ÇÖ = z‚ÇÅ.s ‚â´ t‚ÇÅ ‚â´ v‚ÇÑ
eq : z‚ÇÇ.s ‚â´ u‚ÇÇ ‚â´ v‚ÇÖ = z‚ÇÇ.s ‚â´ t‚ÇÇ ‚â´ v‚ÇÑ
Z‚Çá : C
w : Y'‚úù ‚ü∂ Z‚Çá
hw : W w
fac' : u‚ÇÇ ‚â´ v‚ÇÖ ‚â´ w = t‚ÇÇ ‚â´ v‚ÇÑ ‚â´ w
‚ä¢ LeftFractionRel z‚ÇÅ z‚ÇÉ","lemma trans {X Y : C} {z‚ÇÅ z‚ÇÇ z‚ÇÉ : W.LeftFraction X Y}
    [HasLeftCalculusOfFractions W]
    (h‚ÇÅ‚ÇÇ : LeftFractionRel z‚ÇÅ z‚ÇÇ) (h‚ÇÇ‚ÇÉ : LeftFractionRel z‚ÇÇ z‚ÇÉ) :
    LeftFractionRel z‚ÇÅ z‚ÇÉ ",":= by
  obtain ‚ü®Z‚ÇÑ, t‚ÇÅ, t‚ÇÇ, hst, hft, ht‚ü© := h‚ÇÅ‚ÇÇ
  obtain ‚ü®Z‚ÇÖ, u‚ÇÇ, u‚ÇÉ, hsu, hfu, hu‚ü© := h‚ÇÇ‚ÇÉ
  obtain ‚ü®‚ü®v‚ÇÑ, v‚ÇÖ, hv‚ÇÖ‚ü©, fac‚ü© := HasLeftCalculusOfFractions.exists_leftFraction
    (RightFraction.mk (z‚ÇÅ.s ‚â´ t‚ÇÅ) ht (z‚ÇÉ.s ‚â´ u‚ÇÉ))
  simp only [Category.assoc] at fac
  have eq : z‚ÇÇ.s ‚â´ u‚ÇÇ ‚â´ v‚ÇÖ  = z‚ÇÇ.s ‚â´ t‚ÇÇ ‚â´ v‚ÇÑ := by
    simpa only [‚Üê reassoc_of% hsu, reassoc_of% hst] using fac
  obtain ‚ü®Z‚Çá, w, hw, fac'‚ü© := HasLeftCalculusOfFractions.ext _ _ _ z‚ÇÇ.hs eq
  simp only [Category.assoc] at fac'
  refine ‚ü®Z‚Çá, t‚ÇÅ ‚â´ v‚ÇÑ ‚â´ w, u‚ÇÉ ‚â´ v‚ÇÖ ‚â´ w, ?_, ?_, ?_‚ü©
  ¬∑ rw [reassoc_of% fac]
  ¬∑ rw [reassoc_of% hft, ‚Üê fac', reassoc_of% hfu]
  ¬∑ rw [‚Üê reassoc_of% fac, ‚Üê reassoc_of% hsu, ‚Üê Category.assoc]
    exact W.comp_mem _ _ hu (W.comp_mem _ _ hv‚ÇÖ hw)"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.hausdorffMeasure_pi_real,hausdorffMeasure_pi_real,ea70e843f6449df0777fbfebe222d09a083bd844,":= by
  classical
  refine'
    (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)
        (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) _).symm
  simp only [mem_iUnion, mem_singleton_iff]
  intro s hs
  choose a b H using hs
  obtain rfl : s = fun i => Ioo (Œ± := ‚Ñù) (a i) (b i)
  exact funext fun i => (H i).2
  replace H := fun i => (H i).1
  apply le_antisymm _
  ¬∑ have Hle : volume ‚â§ (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) := by
      refine' le_hausdorffMeasure _ _ ‚àû ENNReal.coe_lt_top fun s _ => _
      rw [ENNReal.rpow_nat_cast]
      exact Real.volume_pi_le_diam_pow s
    rw [‚Üê volume_pi_pi fun i => Ioo (a i : ‚Ñù) (b i)]
    exact Measure.le_iff'.1 Hle _
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := fun i => by
    simpa only [sub_nonneg, Rat.cast_le] using (H i).le
  let Œ≥ := fun n : ‚Ñï => ‚àÄ i : Œπ, Fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä
  let t : ‚àÄ n : ‚Ñï, Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f =>
    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)
  have A : Tendsto (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) atTop (ùìù 0) := by
    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]
  have B : ‚àÄ·∂† n in atTop, ‚àÄ i : Œ≥ n, diam (t n i) ‚â§ 1 / n := by
    refine' eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
    intro f
    refine' diam_pi_le_of_le fun b => _
    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel', ENNReal.ofReal_one, ENNReal.ofReal_coe_nat]
  have C : ‚àÄ·∂† n in atTop, (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ i : Œ≥ n, t n i := by
    refine' eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
    have npos : (0 : ‚Ñù) < n := Nat.cast_pos.2 hn
    intro x hx
    simp only [mem_Ioo, mem_univ_pi] at hx
    simp only [mem_iUnion, mem_Ioo, mem_univ_pi]
    let f : Œ≥ n := fun i =>
      ‚ü®‚åä(x i - a i) * n‚åã‚Çä, by
        apply Nat.floor_lt_ceil_of_lt_of_pos
        ¬∑ refine' (mul_lt_mul_right npos).2 _
          simp only [(hx i).right, sub_lt_sub_iff_right]
        ¬∑ refine' mul_pos _ npos
          simpa only [Rat.cast_lt, sub_pos] using H i‚ü©
    refine' ‚ü®f, fun i => ‚ü®_, _‚ü©‚ü©
    ¬∑ calc
        (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + (x i - a i) * n / n := by
          refine' add_le_add le_rfl ((div_le_div_right npos).2 _)
          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
        _ = x i := by field_simp [npos.ne']
    ¬∑ calc
        x i = (a i : ‚Ñù) + (x i - a i) * n / n := by field_simp [npos.ne']
        _ ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n :=
          add_le_add le_rfl ((div_le_div_right npos).2 (Nat.lt_floor_add_one _).le)
  calc
    ŒºH[Fintype.card Œπ] (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚â§
        liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, diam (t n i) ^ ((Fintype.card Œπ) : ‚Ñù)) atTop :=
      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : ‚Ñù) (b i))
        (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) A t B C
    _ ‚â§ liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, (1 / (n : ‚Ñù‚â•0‚àû)) ^ Fintype.card Œπ) atTop := by
      refine' liminf_le_liminf _ _
      ¬∑ filter_upwards [B] with _ hn
        apply Finset.sum_le_sum fun i _ => _
        simp only [ENNReal.rpow_nat_cast]
        intros i _
        exact pow_le_pow_left' (hn i) _
      ¬∑ isBoundedDefault
    _ = liminf (fun n : ‚Ñï => ‚àè i : Œπ, (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) atTop := by
      simp only [Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
    _ = ‚àè i : Œπ, volume (Ioo (a i : ‚Ñù) (b i)) := by
      simp only [Real.volume_Ioo]
      apply Tendsto.liminf_eq
      refine' ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => _) fun i _ => _
      ¬∑ apply
          Tendsto.congr' _
            ((ENNReal.continuous_ofReal.tendsto _).comp
              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_nat_cast_atTop_atTop))
        apply eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
        intros n hn
        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,
          ENNReal.ofReal_coe_nat]
      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne.def, not_false_iff]","warning:  `ENNReal.rpow_nat_cast` has been deprecated, use `ENNReal.rpow_natCast` instead
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
warning:  `ENNReal.ofReal_coe_nat` has been deprecated, use `ENNReal.ofReal_natCast` instead
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  i ‚àà univ ‚Üí x i ‚àà (fun i ‚Ü¶ Icc (‚Üë(a i) + ‚Üë‚Üë(f i) / ‚Üën) (‚Üë(a i) + (‚Üë‚Üë(f i) + 1) / ‚Üën)) i
error:  no goals to be solved
warning:  `ENNReal.rpow_nat_cast` has been deprecated, use `ENNReal.rpow_natCast` instead
error:  unsolved goals
Œπ‚úù : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù‚Å∂ : EMetricSpace X
inst‚úù‚Åµ : EMetricSpace Y
inst‚úù‚Å¥ : MeasurableSpace X
inst‚úù¬≥ : BorelSpace X
inst‚úù¬≤ : MeasurableSpace Y
inst‚úù¬π : BorelSpace Y
Œπ : Type u_4
inst‚úù : Fintype Œπ
a b : Œπ ‚Üí ‚Ñö
H : ‚àÄ (i : Œπ), a i < b i
I : ‚àÄ (i : Œπ), 0 ‚â§ ‚Üë(b i) - ‚Üë(a i)
Œ≥ : ‚Ñï ‚Üí Type u_4 := fun n ‚Ü¶ (i : Œπ) ‚Üí Fin ‚åà(‚Üë(b i) - ‚Üë(a i)) * ‚Üën‚åâ‚Çä
t : (n : ‚Ñï) ‚Üí Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f ‚Ü¶ univ.pi fun i ‚Ü¶ Icc (‚Üë(a i) + ‚Üë‚Üë(f i) / ‚Üën) (‚Üë(a i) + (‚Üë‚Üë(f i) + 1) / ‚Üën)
A : Tendsto (fun n ‚Ü¶ 1 / ‚Üën) atTop (ùìù 0)
B : ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ (i : Œ≥ n), diam (t n i) ‚â§ 1 / ‚Üën
C : ‚àÄ·∂† (n : ‚Ñï) in atTop, (univ.pi fun i ‚Ü¶ Ioo ‚Üë(a i) ‚Üë(b i)) ‚äÜ ‚ãÉ i, t n i
‚ä¢ liminf (fun n ‚Ü¶ ‚Üë(Fintype.card (Œ≥ n)) * (‚Üën)‚Åª¬π ^ Fintype.card Œπ) atTop =
    liminf (fun n ‚Ü¶ (‚àè x : Œπ, ‚Üë‚åà(‚Üë(b x) - ‚Üë(a x)) * ‚Üën‚åâ‚Çä) * (‚Üën)‚Åª¬π ^ Fintype.card Œπ) atTop
warning:  `tendsto_nat_cast_atTop_atTop` has been deprecated, use `tendsto_natCast_atTop_atTop` instead
warning:  `ENNReal.ofReal_coe_nat` has been deprecated, use `ENNReal.ofReal_natCast` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.246758 ‚Üí ?m.246758 ‚Üí Prop
error:  simp made no progress","theorem hausdorffMeasure_pi_real {Œπ : Type*} [Fintype Œπ] :
    (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) = volume ",":= by
  classical
  refine (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)
    (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) ?_).symm
  simp only [mem_iUnion, mem_singleton_iff]
  intro s hs
  choose a b H using hs
  obtain rfl : s = fun i => Ioo (Œ± := ‚Ñù) (a i) (b i) := funext fun i => (H i).2
  replace H := fun i => (H i).1
  apply le_antisymm _
  ¬∑ have Hle : volume ‚â§ (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) := by
      refine le_hausdorffMeasure _ _ ‚àû ENNReal.coe_lt_top fun s _ => ?_
      rw [ENNReal.rpow_natCast]
      exact Real.volume_pi_le_diam_pow s
    rw [‚Üê volume_pi_pi fun i => Ioo (a i : ‚Ñù) (b i)]
    exact Measure.le_iff'.1 Hle _
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := fun i => by
    simpa only [sub_nonneg, Rat.cast_le] using (H i).le
  let Œ≥ := fun n : ‚Ñï => ‚àÄ i : Œπ, Fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä
  let t : ‚àÄ n : ‚Ñï, Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f =>
    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)
  have A : Tendsto (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) atTop (ùìù 0) := by
    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]
  have B : ‚àÄ·∂† n in atTop, ‚àÄ i : Œ≥ n, diam (t n i) ‚â§ 1 / n := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => ?_‚ü©
    intro f
    refine diam_pi_le_of_le fun b => ?_
    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel_left, ENNReal.ofReal_one, ENNReal.ofReal_natCast]
  have C : ‚àÄ·∂† n in atTop, (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ i : Œ≥ n, t n i := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => ?_‚ü©
    have npos : (0 : ‚Ñù) < n := Nat.cast_pos.2 hn
    intro x hx
    simp only [mem_Ioo, mem_univ_pi] at hx
    simp only [t, mem_iUnion, mem_Ioo, mem_univ_pi]
    let f : Œ≥ n := fun i =>
      ‚ü®‚åä(x i - a i) * n‚åã‚Çä, by
        apply Nat.floor_lt_ceil_of_lt_of_pos
        ¬∑ refine (mul_lt_mul_right npos).2 ?_
          simp only [(hx i).right, sub_lt_sub_iff_right]
        ¬∑ refine mul_pos ?_ npos
          simpa only [Rat.cast_lt, sub_pos] using H i‚ü©
    refine ‚ü®f, fun i => ‚ü®?_, ?_‚ü©‚ü©
    ¬∑ calc
        (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + (x i - a i) * n / n := by
          gcongr
          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
        _ = x i := by field_simp [npos.ne']
    ¬∑ calc
        x i = (a i : ‚Ñù) + (x i - a i) * n / n := by field_simp [npos.ne']
        _ ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n := by
          gcongr
          exact (Nat.lt_floor_add_one _).le
  calc
    ŒºH[Fintype.card Œπ] (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚â§
        liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, diam (t n i) ^ ((Fintype.card Œπ) : ‚Ñù)) atTop :=
      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : ‚Ñù) (b i))
        (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) A t B C
    _ ‚â§ liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, (1 / (n : ‚Ñù‚â•0‚àû)) ^ Fintype.card Œπ) atTop := by
      refine liminf_le_liminf ?_ ?_
      ¬∑ filter_upwards [B] with _ hn
        apply Finset.sum_le_sum fun i _ => _
        simp only [ENNReal.rpow_natCast]
        intros i _
        exact pow_le_pow_left' (hn i) _
      ¬∑ isBoundedDefault
    _ = liminf (fun n : ‚Ñï => ‚àè i : Œπ, (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) atTop := by
      simp only [Œ≥, Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
    _ = ‚àè i : Œπ, volume (Ioo (a i : ‚Ñù) (b i)) := by
      simp only [Real.volume_Ioo]
      apply Tendsto.liminf_eq
      refine ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => ?_) fun i _ => ?_
      ¬∑ apply
          Tendsto.congr' _
            ((ENNReal.continuous_ofReal.tendsto _).comp
              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_natCast_atTop_atTop))
        apply eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
        intros n hn
        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,
          ENNReal.ofReal_natCast]
      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne, not_false_iff]"
Mathlib/RingTheory/UniqueFactorizationDomain.lean,UniqueFactorizationMonoid.multiplicative_prime_power,multiplicative_prime_power,c342c339a777827331257acd880fea6d441a6aa6,":= by
  letI := Classical.decEq Œ±
  induction' s with p s hps ih
  ¬∑ simpa using h1 isUnit_one
  have hpr_p := is_prime _ (Finset.mem_insert_self _ _)
  have hpr_s : ‚àÄ p ‚àà s, Prime p := fun p hp => is_prime _ (Finset.mem_insert_of_mem hp)
  have hcp_p := fun i => prime_pow_coprime_prod_of_coprime_insert i p hps is_prime is_coprime
  have hcp_s : ‚àÄ·µâ (p ‚àà s) (q ‚àà s), p ‚à£ q ‚Üí p = q := fun p hp q hq =>
    is_coprime p (Finset.mem_insert_of_mem hp) q (Finset.mem_insert_of_mem hq)
  rw [Finset.prod_insert hps, Finset.prod_insert hps, Finset.prod_insert hps, hcp (hcp_p _),
    hpr _ hpr_p, hcp (hcp_p _), hpr _ hpr_p, hcp (hcp_p (fun p => i p + j p)), hpr _ hpr_p,
    ih hpr_s hcp_s, pow_add, mul_assoc, mul_left_comm (f p ^ j p), mul_assoc]","error:  type mismatch
  h‚úù
has type
  f ?m.273119 = f ?m.273119 * f 1 : Prop
but is expected to have type
  f (Multiset.map (fun p ‚Ü¶ p ^ (i p + j p)) p).prod =
    f (Multiset.map (fun p ‚Ü¶ p ^ i p) p).prod * f (Multiset.map (fun p ‚Ü¶ p ^ j p) p).prod : Prop
error:  no goals to be solved","theorem multiplicative_prime_power {f : Œ± ‚Üí Œ≤} (s : Finset Œ±) (i j : Œ± ‚Üí ‚Ñï)
    (is_prime : ‚àÄ p ‚àà s, Prime p) (is_coprime : ‚àÄ·µâ (p ‚àà s) (q ‚àà s), p ‚à£ q ‚Üí p = q)
    (h1 : ‚àÄ {x y}, IsUnit y ‚Üí f (x * y) = f x * f y)
    (hpr : ‚àÄ {p} (i : ‚Ñï), Prime p ‚Üí f (p ^ i) = f p ^ i)
    (hcp : ‚àÄ {x y}, IsRelPrime x y ‚Üí f (x * y) = f x * f y) :
    f (‚àè p ‚àà s, p ^ (i p + j p)) = f (‚àè p ‚àà s, p ^ i p) * f (‚àè p ‚àà s, p ^ j p) ",":= by
  letI := Classical.decEq Œ±
  induction' s using Finset.induction_on with p s hps ih
  ¬∑ simpa using h1 isUnit_one
  have hpr_p := is_prime _ (Finset.mem_insert_self _ _)
  have hpr_s : ‚àÄ p ‚àà s, Prime p := fun p hp => is_prime _ (Finset.mem_insert_of_mem hp)
  have hcp_p := fun i => prime_pow_coprime_prod_of_coprime_insert i p hps is_prime is_coprime
  have hcp_s : ‚àÄ·µâ (p ‚àà s) (q ‚àà s), p ‚à£ q ‚Üí p = q := fun p hp q hq =>
    is_coprime p (Finset.mem_insert_of_mem hp) q (Finset.mem_insert_of_mem hq)
  rw [Finset.prod_insert hps, Finset.prod_insert hps, Finset.prod_insert hps, hcp (hcp_p _),
    hpr _ hpr_p, hcp (hcp_p _), hpr _ hpr_p, hcp (hcp_p (fun p => i p + j p)), hpr _ hpr_p,
    ih hpr_s hcp_s, pow_add, mul_assoc, mul_left_comm (f p ^ j p), mul_assoc]"
Mathlib/RingTheory/IntegralClosure.lean,leadingCoeff_smul_normalizeScaleRoots,leadingCoeff_smul_normalizeScaleRoots,787f21e24c1b4d0e7a88ac6d76f18bfb080d4d5c,":= by
  ext
  simp only [coeff_scaleRoots, normalizeScaleRoots, coeff_monomial, coeff_smul, Finset.smul_sum,
    Ne.def, Finset.sum_ite_eq', finset_sum_coeff, smul_ite, smul_zero, mem_support_iff]
  simp only [ge_iff_le, tsub_le_iff_right, smul_eq_mul, mul_ite, mul_one, mul_zero,
    Finset.sum_ite_eq', mem_support_iff, ne_eq, ite_not]
  split_ifs with h‚ÇÅ h‚ÇÇ
  ¬∑ simp [*]
  ¬∑ simp [*]
  ¬∑ rw [mul_comm, mul_assoc, ‚Üê pow_succ', tsub_right_comm,
      tsub_add_cancel_of_le]
    rw [Nat.succ_le_iff]
    exact tsub_pos_of_lt (lt_of_le_of_ne (le_natDegree_of_ne_zero h‚ÇÅ) h‚ÇÇ)","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.325583 ‚Üí ?m.325583 ‚Üí Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * ?a ^ ?n
case neg
R : Type u_1
A : Type u_2
B : Type u_3
S : Type u_4
inst‚úù‚Åµ : CommRing R
inst‚úù‚Å¥ : CommRing A
inst‚úù¬≥ : Ring B
inst‚úù¬≤ : CommRing S
inst‚úù¬π : Algebra R A
inst‚úù : Algebra R B
f‚úù¬π : R ‚Üí+* S
f‚úù : R ‚Üí+* B
f : R ‚Üí+* S
p‚úù : R[X]
x : S
p : R[X]
n‚úù : ‚Ñï
h‚ÇÅ : ¬¨p.coeff n‚úù = 0
h‚ÇÇ : ¬¨n‚úù = p.natDegree
‚ä¢ p.coeff n‚úù * (p.leadingCoeff ^ (p.natDegree - 1 - n‚úù) * p.leadingCoeff) =
    p.coeff n‚úù * p.leadingCoeff ^ (p.natDegree - n‚úù)","theorem leadingCoeff_smul_normalizeScaleRoots (p : R[X]) :
    p.leadingCoeff ‚Ä¢ normalizeScaleRoots p = scaleRoots p p.leadingCoeff ",":= by
  ext
  simp only [coeff_scaleRoots, normalizeScaleRoots, coeff_monomial, coeff_smul, Finset.smul_sum,
    Ne, Finset.sum_ite_eq', finset_sum_coeff, smul_ite, smul_zero, mem_support_iff]
  simp only [ge_iff_le, tsub_le_iff_right, smul_eq_mul, mul_ite, mul_one, mul_zero,
    Finset.sum_ite_eq', mem_support_iff, ne_eq, ite_not]
  split_ifs with h‚ÇÅ h‚ÇÇ
  ¬∑ simp [*]
  ¬∑ simp [*]
  ¬∑ rw [mul_comm, mul_assoc, ‚Üê pow_succ, tsub_right_comm,
      tsub_add_cancel_of_le]
    rw [Nat.succ_le_iff]
    exact tsub_pos_of_lt (lt_of_le_of_ne (le_natDegree_of_ne_zero h‚ÇÅ) h‚ÇÇ)"
Mathlib/Data/Set/Pointwise/BigOperators.lean,Set.multiset_prod_subset_multiset_prod,multiset_prod_subset_multiset_prod,554c20d1eb6d2f1f6a5b53ccd3a727a93147a4de,":= by
  induction t using Quotient.inductionOn
  simp_rw [Multiset.quot_mk_to_coe, Multiset.coe_map, Multiset.coe_prod]
  exact list_prod_subset_list_prod _ _ _ hf","error:  unknown constant 'Multiset.coe_map'
error:  simp made no progress","theorem multiset_prod_subset_multiset_prod (t : Multiset Œπ) (f‚ÇÅ f‚ÇÇ : Œπ ‚Üí Set Œ±)
    (hf : ‚àÄ i ‚àà t, f‚ÇÅ i ‚äÜ f‚ÇÇ i) : (t.map f‚ÇÅ).prod ‚äÜ (t.map f‚ÇÇ).prod ",":= by
  induction t using Quotient.inductionOn
  simp_rw [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]
  exact list_prod_subset_list_prod _ _ _ hf"
Mathlib/MeasureTheory/Constructions/Polish.lean,MeasureTheory.measurablySeparable_range_of_disjoint,measurablySeparable_range_of_disjoint,d6d62ea74239ff6c88440746251459d9b04d21e6,":= by
  by_contra hfg
  have I : ‚àÄ n x y, ¬¨MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) ‚Üí
      ‚àÉ x' y', x' ‚àà cylinder x n ‚àß y' ‚àà cylinder y n ‚àß
      ¬¨MeasurablySeparable (f '' cylinder x' (n + 1)) (g '' cylinder y' (n + 1)) := by
    intro n x y
    contrapose!
    intro H
    rw [‚Üê iUnion_cylinder_update x n, ‚Üê iUnion_cylinder_update y n, image_iUnion, image_iUnion]
    refine' MeasurablySeparable.iUnion fun i j => _
    exact H _ _ (update_mem_cylinder _ _ _) (update_mem_cylinder _ _ _)
  let A :=
    { p : ‚Ñï √ó (‚Ñï ‚Üí ‚Ñï) √ó (‚Ñï ‚Üí ‚Ñï) //
      ¬¨MeasurablySeparable (f '' cylinder p.2.1 p.1) (g '' cylinder p.2.2 p.1) }
  have : ‚àÄ p : A, ‚àÉ q : A,
      q.1.1 = p.1.1 + 1 ‚àß q.1.2.1 ‚àà cylinder p.1.2.1 p.1.1 ‚àß q.1.2.2 ‚àà cylinder p.1.2.2 p.1.1 := by
    rintro ‚ü®‚ü®n, x, y‚ü©, hp‚ü©
    rcases I n x y hp with ‚ü®x', y', hx', hy', h'‚ü©
    exact ‚ü®‚ü®‚ü®n + 1, x', y'‚ü©, h'‚ü©, rfl, hx', hy'‚ü©
  choose F hFn hFx hFy using this
  let p0 : A := ‚ü®‚ü®0, fun _ => 0, fun _ => 0‚ü©, by simp [hfg]‚ü©
  let p : ‚Ñï ‚Üí A := fun n => (F^[n]) p0
  have prec : ‚àÄ n, p (n + 1) = F (p n) := fun n => by simp only [iterate_succ', Function.comp]
  have pn_fst : ‚àÄ n, (p n).1.1 = n := by
    intro n
    induction' n with n IH
    ¬∑ rfl
    ¬∑ simp only [prec, hFn, IH]
  have Ix : ‚àÄ m n, m + 1 ‚â§ n ‚Üí (p n).1.2.1 m = (p (m + 1)).1.2.1 m := by
    intro m
    apply Nat.le_induction
    ¬∑ rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.fst m = (p n).val.snd.fst m := by
      apply hFx (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  have Iy : ‚àÄ m n, m + 1 ‚â§ n ‚Üí (p n).1.2.2 m = (p (m + 1)).1.2.2 m := by
    intro m
    apply Nat.le_induction
    ¬∑ rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.snd m = (p n).val.snd.snd m := by
      apply hFy (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  set x : ‚Ñï ‚Üí ‚Ñï := fun n => (p (n + 1)).1.2.1 n with hx
  set y : ‚Ñï ‚Üí ‚Ñï := fun n => (p (n + 1)).1.2.2 n with hy
  have M : ‚àÄ n, ¬¨MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    intro n
    convert(p n).2 using 3
    ¬∑ rw [pn_fst, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hx]
      exact (Ix i n hi).symm
    ¬∑ rw [pn_fst, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hy]
      exact (Iy i n hi).symm
  obtain ‚ü®u, v, u_open, v_open, xu, yv, huv‚ü© :
    ‚àÉ u v : Set Œ±, IsOpen u ‚àß IsOpen v ‚àß f x ‚àà u ‚àß g y ‚àà v ‚àß Disjoint u v := by
    apply t2_separation
    exact disjoint_iff_forall_ne.1 h (mem_range_self _) (mem_range_self _)
  letI : MetricSpace (‚Ñï ‚Üí ‚Ñï) := metricSpaceNatNat
  obtain ‚ü®Œµx, Œµxpos, hŒµx‚ü© : ‚àÉ (Œµx : ‚Ñù), Œµx > 0 ‚àß Metric.ball x Œµx ‚äÜ f ‚Åª¬π' u := by
    apply Metric.mem_nhds_iff.1
    exact hf.continuousAt.preimage_mem_nhds (u_open.mem_nhds xu)
  obtain ‚ü®Œµy, Œµypos, hŒµy‚ü© : ‚àÉ (Œµy : ‚Ñù), Œµy > 0 ‚àß Metric.ball y Œµy ‚äÜ g ‚Åª¬π' v := by
    apply Metric.mem_nhds_iff.1
    exact hg.continuousAt.preimage_mem_nhds (v_open.mem_nhds yv)
  obtain ‚ü®n, hn‚ü© : ‚àÉ n : ‚Ñï, (1 / 2 : ‚Ñù) ^ n < min Œµx Œµy :=
    exists_pow_lt_of_lt_one (lt_min Œµxpos Œµypos) (by norm_num)
  have B : MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    refine' ‚ü®u, _, _, u_open.measurableSet‚ü©
    ¬∑ rw [image_subset_iff]
      apply Subset.trans _ hŒµx
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_left _ _))
    ¬∑ refine' Disjoint.mono_left _ huv.symm
      change g '' cylinder y n ‚äÜ v
      rw [image_subset_iff]
      apply Subset.trans _ hŒµy
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_right _ _))
  exact M n B",error:  simp made no progress,"theorem measurablySeparable_range_of_disjoint [T2Space Œ±] [MeasurableSpace Œ±]
    [OpensMeasurableSpace Œ±] {f g : (‚Ñï ‚Üí ‚Ñï) ‚Üí Œ±} (hf : Continuous f) (hg : Continuous g)
    (h : Disjoint (range f) (range g)) : MeasurablySeparable (range f) (range g) ",":= by
  by_contra hfg
  have I : ‚àÄ n x y, ¬¨MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) ‚Üí
      ‚àÉ x' y', x' ‚àà cylinder x n ‚àß y' ‚àà cylinder y n ‚àß
      ¬¨MeasurablySeparable (f '' cylinder x' (n + 1)) (g '' cylinder y' (n + 1)) := by
    intro n x y
    contrapose!
    intro H
    rw [‚Üê iUnion_cylinder_update x n, ‚Üê iUnion_cylinder_update y n, image_iUnion, image_iUnion]
    refine MeasurablySeparable.iUnion fun i j => ?_
    exact H _ _ (update_mem_cylinder _ _ _) (update_mem_cylinder _ _ _)
  let A :=
    { p : ‚Ñï √ó (‚Ñï ‚Üí ‚Ñï) √ó (‚Ñï ‚Üí ‚Ñï) //
      ¬¨MeasurablySeparable (f '' cylinder p.2.1 p.1) (g '' cylinder p.2.2 p.1) }
  have : ‚àÄ p : A, ‚àÉ q : A,
      q.1.1 = p.1.1 + 1 ‚àß q.1.2.1 ‚àà cylinder p.1.2.1 p.1.1 ‚àß q.1.2.2 ‚àà cylinder p.1.2.2 p.1.1 := by
    rintro ‚ü®‚ü®n, x, y‚ü©, hp‚ü©
    rcases I n x y hp with ‚ü®x', y', hx', hy', h'‚ü©
    exact ‚ü®‚ü®‚ü®n + 1, x', y'‚ü©, h'‚ü©, rfl, hx', hy'‚ü©
  choose F hFn hFx hFy using this
  let p0 : A := ‚ü®‚ü®0, fun _ => 0, fun _ => 0‚ü©, by simp [hfg]‚ü©
  let p : ‚Ñï ‚Üí A := fun n => F^[n] p0
  have prec : ‚àÄ n, p (n + 1) = F (p n) := fun n => by simp only [p, iterate_succ', Function.comp]
  have pn_fst : ‚àÄ n, (p n).1.1 = n := by
    intro n
    induction' n with n IH
    ¬∑ rfl
    ¬∑ simp only [prec, hFn, IH]
  have Ix : ‚àÄ m n, m + 1 ‚â§ n ‚Üí (p n).1.2.1 m = (p (m + 1)).1.2.1 m := by
    intro m
    apply Nat.le_induction
    ¬∑ rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.fst m = (p n).val.snd.fst m := by
      apply hFx (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  have Iy : ‚àÄ m n, m + 1 ‚â§ n ‚Üí (p n).1.2.2 m = (p (m + 1)).1.2.2 m := by
    intro m
    apply Nat.le_induction
    ¬∑ rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.snd m = (p n).val.snd.snd m := by
      apply hFy (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  set x : ‚Ñï ‚Üí ‚Ñï := fun n => (p (n + 1)).1.2.1 n with hx
  set y : ‚Ñï ‚Üí ‚Ñï := fun n => (p (n + 1)).1.2.2 n with hy
  have M : ‚àÄ n, ¬¨MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    intro n
    convert (p n).2 using 3
    ¬∑ rw [pn_fst, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hx]
      exact (Ix i n hi).symm
    ¬∑ rw [pn_fst, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hy]
      exact (Iy i n hi).symm
  obtain ‚ü®u, v, u_open, v_open, xu, yv, huv‚ü© :
      ‚àÉ u v : Set Œ±, IsOpen u ‚àß IsOpen v ‚àß f x ‚àà u ‚àß g y ‚àà v ‚àß Disjoint u v := by
    apply t2_separation
    exact disjoint_iff_forall_ne.1 h (mem_range_self _) (mem_range_self _)
  letI : MetricSpace (‚Ñï ‚Üí ‚Ñï) := metricSpaceNatNat
  obtain ‚ü®Œµx, Œµxpos, hŒµx‚ü© : ‚àÉ (Œµx : ‚Ñù), Œµx > 0 ‚àß Metric.ball x Œµx ‚äÜ f ‚Åª¬π' u := by
    apply Metric.mem_nhds_iff.1
    exact hf.continuousAt.preimage_mem_nhds (u_open.mem_nhds xu)
  obtain ‚ü®Œµy, Œµypos, hŒµy‚ü© : ‚àÉ (Œµy : ‚Ñù), Œµy > 0 ‚àß Metric.ball y Œµy ‚äÜ g ‚Åª¬π' v := by
    apply Metric.mem_nhds_iff.1
    exact hg.continuousAt.preimage_mem_nhds (v_open.mem_nhds yv)
  obtain ‚ü®n, hn‚ü© : ‚àÉ n : ‚Ñï, (1 / 2 : ‚Ñù) ^ n < min Œµx Œµy :=
    exists_pow_lt_of_lt_one (lt_min Œµxpos Œµypos) (by norm_num)
  have B : MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    refine ‚ü®u, ?_, ?_, u_open.measurableSet‚ü©
    ¬∑ rw [image_subset_iff]
      apply Subset.trans _ hŒµx
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_left _ _))
    ¬∑ refine Disjoint.mono_left ?_ huv.symm
      change g '' cylinder y n ‚äÜ v
      rw [image_subset_iff]
      apply Subset.trans _ hŒµy
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_right _ _))
  exact M n B"
Mathlib/AlgebraicGeometry/Gluing.lean,AlgebraicGeometry.Scheme.GlueData.Œπ_eq_iff,Œπ_eq_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine Iff.trans ?_
    (TopCat.GlueData.Œπ_eq_iff_rel
      D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toTopGlueData
      i j x y)
  rw [‚Üê ((TopCat.mono_iff_injective D.isoCarrier.inv).mp _).eq_iff]
  ¬∑ simp_rw [‚Üê comp_apply, ‚Üê D.Œπ_isoCarrier_inv]; rfl
  ¬∑ infer_instance",error:  simp made no progress,"theorem Œπ_eq_iff (i j : D.J) (x : (D.U i).carrier) (y : (D.U j).carrier) :
    (ùñ£.Œπ i).1.base x = (ùñ£.Œπ j).1.base y ‚Üî D.Rel ‚ü®i, x‚ü© ‚ü®j, y‚ü© ",":= by
  refine Iff.trans ?_
    (TopCat.GlueData.Œπ_eq_iff_rel
      D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toTopGlueData
      i j x y)
  rw [‚Üê ((TopCat.mono_iff_injective D.isoCarrier.inv).mp _).eq_iff]
  ¬∑ erw [‚Üê comp_apply] 
    simp_rw [‚Üê D.Œπ_isoCarrier_inv]
    rfl 
  ¬∑ infer_instance"
Mathlib/Geometry/Manifold/ContMDiffMFDeriv.lean,ContMDiffOn.continuousOn_tangentMapWithin_aux,ContMDiffOn.continuousOn_tangentMapWithin_aux,a9e5c97a54df0543783bff424b120a30b61a4aac,":= by
  suffices h :
    ContinuousOn
      (fun p : H √ó E =>
        (f p.fst,
          (fderivWithin ùïú (writtenInExtChartAt I I' p.fst f) (I.symm ‚Åª¬π' s ‚à© range I)
                ((extChartAt I p.fst) p.fst) : E ‚ÜíL[ùïú] E') p.snd)) (Prod.fst ‚Åª¬π' s)
  ¬∑ have A := (tangentBundleModelSpaceHomeomorph H I).continuous
    rw [continuous_iff_continuousOn_univ] at A
    have B :=
      ((tangentBundleModelSpaceHomeomorph H' I').symm.continuous.comp_continuousOn h).comp' A
    have :
      univ ‚à© tangentBundleModelSpaceHomeomorph H I ‚Åª¬π' (Prod.fst ‚Åª¬π' s) =
        œÄ E (TangentSpace I) ‚Åª¬π' s :=
      by ext ‚ü®x, v‚ü©; simp only [mfld_simps]
    rw [this] at B
    apply B.congr
    rintro ‚ü®x, v‚ü© hx
    dsimp [tangentMapWithin]
    ext; ¬∑ rfl
    simp only [mfld_simps]
    apply congr_fun
    apply congr_arg
    rw [MDifferentiableWithinAt.mfderivWithin (hf.mdifferentiableOn hn x hx)]
    rfl
  suffices h :
    ContinuousOn
      (fun p : H √ó E =>
        (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) (I p.fst) : E ‚ÜíL[ùïú] E') p.snd)
      (Prod.fst ‚Åª¬π' s)
  ¬∑ dsimp [writtenInExtChartAt, extChartAt]
    exact (ContinuousOn.comp hf.continuousOn continuous_fst.continuousOn Subset.rfl).prod h
  suffices h : ContinuousOn (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I)) (I '' s)
  ¬∑ have C := ContinuousOn.comp h I.continuous_toFun.continuousOn Subset.rfl
    have A : Continuous fun q : (E ‚ÜíL[ùïú] E') √ó E => q.1 q.2 :=
      isBoundedBilinearMap_apply.continuous
    have B :
      ContinuousOn
        (fun p : H √ó E => (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) (I p.1), p.2))
        (Prod.fst ‚Åª¬π' s) := by
      apply ContinuousOn.prod _ continuous_snd.continuousOn
      refine C.comp continuousOn_fst ?_
      exact preimage_mono (subset_preimage_image _ _)
    exact A.comp_continuousOn B
  rw [contMDiffOn_iff] at hf
  let x : H := I.symm (0 : E)
  let y : H' := I'.symm (0 : E')
  have A := hf.2 x y
  simp only [I.image_eq, inter_comm, mfld_simps] at A ‚ä¢
  apply A.continuousOn_fderivWithin _ hn
  convert hs.uniqueDiffOn_target_inter x using 1
  simp only [inter_comm, mfld_simps]",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem ContMDiffOn.continuousOn_tangentMapWithin_aux {f : H ‚Üí H'} {s : Set H}
    (hf : ContMDiffOn I I' n f s) (hn : 1 ‚â§ n) (hs : UniqueMDiffOn I s) :
    ContinuousOn (tangentMapWithin I I' f s) (œÄ E (TangentSpace I) ‚Åª¬π' s) ",":= by
  suffices h :
    ContinuousOn
      (fun p : H √ó E =>
        (f p.fst,
          (fderivWithin ùïú (writtenInExtChartAt I I' p.fst f) (I.symm ‚Åª¬π' s ‚à© range I)
                ((extChartAt I p.fst) p.fst) : E ‚ÜíL[ùïú] E') p.snd)) (Prod.fst ‚Åª¬π' s) by
    have A := (tangentBundleModelSpaceHomeomorph H I).continuous
    rw [continuous_iff_continuousOn_univ] at A
    have B :=
      ((tangentBundleModelSpaceHomeomorph H' I').symm.continuous.comp_continuousOn h).comp' A
    have :
      univ ‚à© tangentBundleModelSpaceHomeomorph H I ‚Åª¬π' (Prod.fst ‚Åª¬π' s) =
        œÄ E (TangentSpace I) ‚Åª¬π' s := by
      ext ‚ü®x, v‚ü©; simp only [mfld_simps]
    rw [this] at B
    apply B.congr
    rintro ‚ü®x, v‚ü© hx
    dsimp [tangentMapWithin]
    ext; ¬∑ rfl
    simp only [mfld_simps]
    apply congr_fun
    apply congr_arg
    rw [MDifferentiableWithinAt.mfderivWithin (hf.mdifferentiableOn hn x hx)]
    rfl
  suffices h :
    ContinuousOn
      (fun p : H √ó E =>
        (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) (I p.fst) : E ‚ÜíL[ùïú] E') p.snd)
      (Prod.fst ‚Åª¬π' s) by
    dsimp [writtenInExtChartAt, extChartAt]
    exact (ContinuousOn.comp hf.continuousOn continuous_fst.continuousOn Subset.rfl).prod h
  suffices h : ContinuousOn (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I)) (I '' s) by
    have C := ContinuousOn.comp h I.continuous_toFun.continuousOn Subset.rfl
    have A : Continuous fun q : (E ‚ÜíL[ùïú] E') √ó E => q.1 q.2 :=
      isBoundedBilinearMap_apply.continuous
    have B :
      ContinuousOn
        (fun p : H √ó E => (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) (I p.1), p.2))
        (Prod.fst ‚Åª¬π' s) := by
      apply ContinuousOn.prod _ continuous_snd.continuousOn
      refine C.comp continuousOn_fst ?_
      exact preimage_mono (subset_preimage_image _ _)
    exact A.comp_continuousOn B
  rw [contMDiffOn_iff] at hf
  let x : H := I.symm (0 : E)
  let y : H' := I'.symm (0 : E')
  have A := hf.2 x y
  simp only [I.image_eq, inter_comm, mfld_simps] at A ‚ä¢
  apply A.continuousOn_fderivWithin _ hn
  convert hs.uniqueDiffOn_target_inter x using 1
  simp only [inter_comm, mfld_simps]"
Mathlib/Combinatorics/Additive/PluenneckeRuzsa.lean,Finset.card_add_nsmul_le,card_add_nsmul_le,d4ee09ebb44515260fada6fe81009f5ed4807a9d,":= by
  obtain rfl | hA := A.eq_empty_or_nonempty
  ¬∑ simp
  induction' n with n ih
  ¬∑ simp
  rw [succ_nsmul', ‚Üê add_assoc, _root_.pow_succ', mul_assoc, ‚Üê mul_div_right_comm, le_div_iff,
    ‚Üê cast_mul]
  swap
  ¬∑ exact cast_pos.2 hA.card_pos
  refine (cast_le.2 <| add_pluennecke_petridis _ hAB).trans ?_
  rw [cast_mul]
  gcongr","error:  ambiguous, possible interpretations 
  NNRat.cast_le.mpr ?m.79529 : ‚Üë?m.79251 ‚â§ ‚Üë?m.79252
  
  Nat.cast_le.mpr
    (add_pluennecke_petridis ?m.79653 hAB) : ‚Üë((A + B + ?m.79653).card * A.card) ‚â§ ‚Üë((A + B).card * (A + ?m.79653).card)
error:  no goals to be solved","theorem card_add_nsmul_le {Œ± : Type*} [AddCommGroup Œ±] [DecidableEq Œ±] {A B : Finset Œ±}
    (hAB : ‚àÄ A' ‚äÜ A, (A + B).card * A'.card ‚â§ (A' + B).card * A.card) (n : ‚Ñï) :
    (A + n ‚Ä¢ B).card ‚â§ ((A + B).card / A.card : ‚Ñö‚â•0) ^ n * A.card ",":= by
  obtain rfl | hA := A.eq_empty_or_nonempty
  ¬∑ simp
  induction' n with n ih
  ¬∑ simp
  rw [succ_nsmul', ‚Üê add_assoc, _root_.pow_succ', mul_assoc, ‚Üê mul_div_right_comm, le_div_iff,
    ‚Üê cast_mul]
  swap
  ¬∑ exact cast_pos.2 hA.card_pos
  refine (Nat.cast_le.2 <| add_pluennecke_petridis _ hAB).trans ?_
  rw [cast_mul]
  gcongr"
Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean,CategoryTheory.Limits.colimitLimitToLimitColimit_surjective,colimitLimitToLimitColimit_surjective,031f5489446cf55630d0efe44cc757d7a8aa007a,":= by
  classical
    intro x
    have z := fun j => jointly_surjective'.{v, v} (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply', t, FunctorToTypes.map_comp_apply, Colimit.w_apply', e, ‚Üê
        Limit.w_apply' f, ‚Üê e]
      simp
    simp_rw [colimit_eq_iff.{v, v}] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact k'O
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk.{v, v}
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) :=
            by rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) :=
            by rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) :=
            by rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext'
      intro j
      simp only [id.def, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff.{v, v}, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","error:  application type mismatch
  jointly_surjective' (limit.œÄ (curry.obj F ‚ãô colim) j x)
argument
  limit.œÄ (curry.obj F ‚ãô colim) j x
has type
  (curry.obj F ‚ãô colim).obj j : Type v
but is expected to have type
  colimit ?m.27488 : Type v
error:  unsolved goals
J : Type u‚ÇÅ
K : Type u‚ÇÇ
inst‚úù‚Å¥ : SmallCategory J
inst‚úù¬≥ : Category.{v‚ÇÇ, u‚ÇÇ} K
inst‚úù¬≤ : Small.{v, u‚ÇÇ} K
inst‚úù¬π : FinCategory J
F : J √ó K ‚•§ Type v
inst‚úù : IsFiltered K
x : limit (curry.obj F ‚ãô colim)
‚ä¢ ‚àÉ a, colimitLimitToLimitColimit F a = x","theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) ",":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ‚Üê Limit.w_apply.{u‚ÇÅ, v, u‚ÇÅ} f, ‚Üê e]
      simp only [Functor.comp_map, Types.Colimit.Œπ_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact k'O
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) := by
            rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) := by
            rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext
      intro j
      simp only [id, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]"
Mathlib/LinearAlgebra/LinearPMap.lean,LinearPMap.neg_graph,neg_graph,c438a06cb616a5e483fefc71bcf86a535642c566,":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  ¬∑ rw [mem_graph_iff] at h
    rcases h with ‚ü®y, hy, h‚ü©
    rw [LinearPMap.neg_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id.def,
      LinearMap.neg_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y, hy
  rw [Submodule.mem_map] at h
  rcases h with ‚ü®x', hx', h‚ü©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id.def, LinearMap.neg_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' ‚ä¢
  rcases hx' with ‚ü®y, hy, hx'‚ü©
  use y
  rw [‚Üê h.1, ‚Üê h.2]
  simp [hy, hx']","warning:  LinearPMap does not have a doc string
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.548521 ‚Üí ?m.548521
error:  unsolved goals
case right
R : Type u_1
inst‚úù‚Åπ : Ring R
E : Type u_2
inst‚úù‚Å∏ : AddCommGroup E
inst‚úù‚Å∑ : Module R E
F : Type u_3
inst‚úù‚Å∂ : AddCommGroup F
inst‚úù‚Åµ : Module R F
G : Type u_4
inst‚úù‚Å¥ : AddCommGroup G
inst‚úù¬≥ : Module R G
M : Type u_5
inst‚úù¬≤ : Monoid M
inst‚úù¬π : DistribMulAction M F
inst‚úù : SMulCommClass R M F
y‚úù : M
f : E ‚Üí‚Çó.[R] F
x_fst : E
x_snd : F
y : ‚Ü•(-f).domain
hy : ‚Üëy = (x_fst, x_snd).1
h : -‚Üëf y = (x_fst, x_snd).2
‚ä¢ id x_fst = x_fst ‚àß -id (‚Üëf y) = x_snd
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.550864 ‚Üí ?m.550864","theorem neg_graph (f : E ‚Üí‚Çó.[R] F) :
    (-f).graph =
    f.graph.map ((LinearMap.id : E ‚Üí‚Çó[R] E).prodMap (-(LinearMap.id : F ‚Üí‚Çó[R] F))) ",":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  ¬∑ rw [mem_graph_iff] at h
    rcases h with ‚ü®y, hy, h‚ü©
    rw [LinearPMap.neg_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id,
      LinearMap.neg_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y, hy
  rw [Submodule.mem_map] at h
  rcases h with ‚ü®x', hx', h‚ü©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id, LinearMap.neg_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' ‚ä¢
  rcases hx' with ‚ü®y, hy, hx'‚ü©
  use y
  rw [‚Üê h.1, ‚Üê h.2]
  simp [hy, hx']"
Mathlib/Order/WellFoundedSet.lean,Set.IsWF.min_union,IsWF.min_union,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  refine' le_antisymm (le_min (IsWF.min_le_min_of_subset (subset_union_left _ _))
    (IsWF.min_le_min_of_subset (subset_union_right _ _))) _
  rw [min_le_iff]
  exact ((mem_union _ _ _).1 ((hs.union ht).min_mem (union_nonempty.2 (.inl hsn)))).imp
    (hs.min_le _) (ht.min_le _)","error:  function expected at
  subset_union_left ?m.45260
term has type
  ?m.45259 ‚àà ?m.45257 ‚à™ ?m.45258
error:  function expected at
  subset_union_right ?m.45348
term has type
  ?m.45347 ‚àà ?m.45345 ‚à™ ?m.45346","theorem IsWF.min_union (hs : s.IsWF) (hsn : s.Nonempty) (ht : t.IsWF) (htn : t.Nonempty) :
    (hs.union ht).min (union_nonempty.2 (Or.intro_left _ hsn)) =
      Min.min (hs.min hsn) (ht.min htn) ",":= by
  refine le_antisymm (le_min (IsWF.min_le_min_of_subset subset_union_left)
    (IsWF.min_le_min_of_subset subset_union_right)) ?_
  rw [min_le_iff]
  exact ((mem_union _ _ _).1 ((hs.union ht).min_mem (union_nonempty.2 (.inl hsn)))).imp
    (hs.min_le _) (ht.min_le _)"
Mathlib/CategoryTheory/Sites/Coherent/Equivalence.lean,CategoryTheory.Equivalence.preregular,preregular,98740267311a24ae6a2fe792964006babfd6788e,"  exists_fac f œÄ _ := by
    obtain ‚ü®W, h', _, i', w‚ü© := Preregular.exists_fac (e.inverse.map f) (e.inverse.map œÄ)
    refine ‚ü®e.functor.obj W, e.functor.map h' ‚â´ e.counit.app _, inferInstance,
      e.functor.map i' ‚â´ e.counit.app _, ?_‚ü©
    simpa using congrArg ((fun f ‚Ü¶ f ‚â´ e.counit.app _) ‚àò e.functor.map) w","error:  function expected at
  Preregular D
term has type
  Prop
error:  unknown identifier 'f'
error:  unknown identifier 'œÄ'
error:  tactic 'cases' failed, nested error:
tactic 'induction' failed, recursor 'Exists.casesOn' can only eliminate into Prop
C : Type u_1
inst‚úù¬≤ : Category.{?u.11780, u_1} C
D : Type u_2
inst‚úù¬π : Category.{?u.11787, u_2} D
e : C ‚âå D
inst‚úù : Preregular C
x‚úù :
  ‚àÉ W h,
    ‚àÉ (_ : EffectiveEpi h),
      ‚àÉ i,
        i ‚â´ e.inverse.map (sorryAx (?m.12045 ‚ü∂ ?m.12046) true) = h ‚â´ e.inverse.map (sorryAx (?m.11948 ‚ü∂ ?m.12046) true)
‚ä¢ sorryAx (Sort u_3) true
error:  invalid field 'preregular', the environment does not contain 'CategoryTheory.Equivalence.preregular'
  equivSmallModel C
has type
  C ‚âå SmallModel.{u_3, u_4, u_1} C
error:  unknown identifier 'preregular'
error:  failed to synthesize
  Preregular D
use `set_option diagnostics true` to get diagnostic information
error:  invalid field 'preregular', the environment does not contain 'CategoryTheory.Equivalence.preregular'
  e
has type
  C ‚âå D
error:  failed to synthesize
  Preregular D
use `set_option diagnostics true` to get diagnostic information
error:  invalid field 'preregular', the environment does not contain 'CategoryTheory.Equivalence.preregular'
  e
has type
  C ‚âå D
error:  failed to synthesize
  Preregular D
use `set_option diagnostics true` to get diagnostic information
error:  typeclass instance problem is stuck, it is often due to metavariables
  Category.{u_4, u_4} ?m.23251",theorem preregular : Preregular D ,:= e.inverse.reflects_preregular
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,b50a8b2e9760b6f582390d3948a953c553480df1,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120516 ‚Üí ?m.120516
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.124403 ‚Üí ?m.124403
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà id ‚àÖ, closedBall p.1 p.2) ‚â§ Œº s
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/FieldTheory/Finite/Basic.lean,FiniteField.card_image_polynomial_eval,card_image_polynomial_eval,89feeaaf464cdb346baab6c7adb1bec331fe789a,:= sorry,"warning:  declaration uses 'sorry'
error:  application type mismatch
  exists_root_sum_quadratic g
argument
  g
has type
  (ZMod p)[X] : Type
but is expected to have type
  ?m.131368.degree = 2 : Prop
error:  expected type must not contain free or meta variables
  0 < ?m.131833","theorem card_image_polynomial_eval [DecidableEq R] [Fintype R] {p : R[X]} (hp : 0 < p.degree) :
    Fintype.card R ‚â§ natDegree p * (univ.image fun x => eval x p).card ",":=
  Finset.card_le_mul_card_image _ _ (fun a _ =>
    calc
      _ = (p - C a).roots.toFinset.card :=
        congr_arg card (by simp [Finset.ext_iff, ‚Üê mem_roots_sub_C hp])
      _ ‚â§ Multiset.card (p - C a).roots := Multiset.toFinset_card_le _
      _ ‚â§ _ := card_roots_sub_C' hp)"
Mathlib/Data/List/Basic.lean,List.erase_get,erase_get,a33aff49327d402aa56adea45bcb9c999637661a,":= by
  induction l with
  | nil => simp
  | cons a l IH =>
    cases i using Fin.cases with
    | zero => simp
    | succ i =>
      by_cases ha : a = l.get i
      ¬∑ simpa [ha] using .trans (perm_cons_erase (l.get_mem i i.isLt)) (.cons _ (IH i))
      ¬∑ simpa [ha] using IH i","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_map` has been deprecated, use `List.getElem_map` instead
warning:  `List.get_map` has been deprecated, use `List.getElem_map` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_map` has been deprecated, use `List.get_map` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_map` has been deprecated, use `List.get_map` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_append_right_aux` has been deprecated
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_cons_length` has been deprecated, use `List.getElem_cons_length` instead
warning:  `List.drop_eq_get_cons` has been deprecated, use `List.drop_eq_getElem_cons` instead
warning:  `List.ext` has been deprecated
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_reverse_aux‚ÇÅ` has been deprecated
warning:  `List.get_reverse_aux‚ÇÇ` has been deprecated, use `List.getElem_reverse_aux‚ÇÇ` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_reverse` has been deprecated, use `List.getElem_reverse` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.ret` has been deprecated, use `List.pure` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_zero_scanl` has been deprecated, use `List.getElem_scanl_zero` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_zero_scanl` has been deprecated, use `List.get_zero_scanl` instead
warning:  `List.nthLe_append_right` has been deprecated, use `List.get_append_right'` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
error:  type mismatch
  h‚úù
has type
  l.erase l[‚Üëi] ~ l.eraseIdx ‚Üëi : Prop
but is expected to have type
  (a :: l).erase l[‚Üëi] ~ a :: l.eraseIdx ‚Üëi : Prop","theorem erase_get [DecidableEq Œπ] {l : List Œπ} (i : Fin l.length) :
    Perm (l.erase (l.get i)) (l.eraseIdx ‚Üëi) ",":= by
  induction l with
  | nil => simp
  | cons a l IH =>
    cases i using Fin.cases with
    | zero => simp
    | succ i =>
      by_cases ha : a = l.get i
      ¬∑ simpa [ha] using .trans (perm_cons_erase (l.get_mem i i.isLt)) (.cons _ (IH i))
      ¬∑ simp only [get_eq_getElem] at IH ha ‚ä¢
        simpa [ha] using IH i"
Mathlib/Computability/Halting.lean,ComputablePred.halting_problem_re,halting_problem_re,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  (eval_part.comp‚ÇÇ Computable.id (Computable.const _)).dom_re","error:  application type mismatch
  Partrec‚ÇÇ.comp‚ÇÇ eval_part Computable.id
argument
  Computable.id
has type
  Computable id : Prop
but is expected to have type
  Computable‚ÇÇ ?m.80042 : Prop",theorem halting_problem_re (n) : RePred fun c => (eval c n).Dom ,":=
  (eval_part.comp Computable.id (Computable.const _)).dom_re"
Mathlib/Data/Nat/Choose/Basic.lean,Nat.choose_mul,choose_mul,0c824fb54f74f0c66db893166b73e377be2feb6f,"  | 0, _, hk => by simp [Nat.eq_zero_of_le_zero hk]
  | n + 1, 0, _ => by simp
  | n + 1, succ k, hk => by
    rcases lt_or_eq_of_le hk with hk‚ÇÅ | hk‚ÇÅ
    ¬∑ have h : choose n k * k.succ ! * (n - k)! = (k + 1) * n ! := by
        rw [‚Üê choose_mul_factorial_mul_factorial (le_of_succ_le_succ hk)]
        simp [factorial_succ, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc]
      have h‚ÇÅ : (n - k)! = (n - k) * (n - k.succ)! := by
        rw [‚Üê succ_sub_succ, succ_sub (le_of_lt_succ hk‚ÇÅ), factorial_succ]
      have h‚ÇÇ : choose n (succ k) * k.succ ! * ((n - k) * (n - k.succ)!) = (n - k) * n ! := by
        rw [‚Üê choose_mul_factorial_mul_factorial (le_of_lt_succ hk‚ÇÅ)]
        simp [factorial_succ, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc]
      have h‚ÇÉ : k * n ! ‚â§ n * n ! := Nat.mul_le_mul_right _ (le_of_succ_le_succ hk)
      rw [choose_succ_succ, Nat.add_mul, Nat.add_mul, succ_sub_succ, h, h‚ÇÅ, h‚ÇÇ, Nat.add_mul,
        Nat.mul_sub_right_distrib, factorial_succ, ‚Üê Nat.add_sub_assoc h‚ÇÉ, ‚Üê Nat.add_assoc',
        ‚Üê Nat.add_mul, Nat.add_sub_cancel_left, Nat.add_comm]
    ¬∑ rw [hk‚ÇÅ]; simp [hk‚ÇÅ, Nat.mul_comm, choose, Nat.sub_self]","error:  unknown constant 'Nat.add_assoc''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.10109
case inl
n k : ‚Ñï
hk : k.succ ‚â§ n + 1
hk‚ÇÅ : k.succ < n + 1
h : n.choose k * k.succ ! * (n - k)! = (k + 1) * n !
h‚ÇÅ : (n - k)! = (n - k) * (n - k.succ)!
h‚ÇÇ : n.choose k.succ * k.succ ! * ((n - k) * (n - k.succ)!) = (n - k) * n !
h‚ÇÉ : k * n ! ‚â§ n * n !
‚ä¢ k * n ! + 1 * n ! + n * n ! - k * n ! = (n + 1) * n !","theorem choose_mul_factorial_mul_factorial : ‚àÄ {n k}, k ‚â§ n ‚Üí choose n k * k ! * (n - k)! = n !
","  | 0, _, hk => by simp [Nat.eq_zero_of_le_zero hk]
  | n + 1, 0, _ => by simp
  | n + 1, succ k, hk => by
    rcases lt_or_eq_of_le hk with hk‚ÇÅ | hk‚ÇÅ
    ¬∑ have h : choose n k * k.succ ! * (n - k)! = (k + 1) * n ! := by
        rw [‚Üê choose_mul_factorial_mul_factorial (le_of_succ_le_succ hk)]
        simp [factorial_succ, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc]
      have h‚ÇÅ : (n - k)! = (n - k) * (n - k.succ)! := by
        rw [‚Üê succ_sub_succ, succ_sub (le_of_lt_succ hk‚ÇÅ), factorial_succ]
      have h‚ÇÇ : choose n (succ k) * k.succ ! * ((n - k) * (n - k.succ)!) = (n - k) * n ! := by
        rw [‚Üê choose_mul_factorial_mul_factorial (le_of_lt_succ hk‚ÇÅ)]
        simp [factorial_succ, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc]
      have h‚ÇÉ : k * n ! ‚â§ n * n ! := Nat.mul_le_mul_right _ (le_of_succ_le_succ hk)
      rw [choose_succ_succ, Nat.add_mul, Nat.add_mul, succ_sub_succ, h, h‚ÇÅ, h‚ÇÇ, Nat.add_mul,
        Nat.mul_sub_right_distrib, factorial_succ, ‚Üê Nat.add_sub_assoc h‚ÇÉ, Nat.add_assoc,
        ‚Üê Nat.add_mul, Nat.add_sub_cancel_left, Nat.add_comm]
    ¬∑ rw [hk‚ÇÅ]; simp [hk‚ÇÅ, Nat.mul_comm, choose, Nat.sub_self]"
Mathlib/Data/QPF/Multivariate/Constructions/Cofix.lean,MvQPF.liftR_map_last,liftR_map_last,67ee3b7709353762fdc01cfb00722ee8c27ff6a5,":=
  let h : Œπ ‚Üí { x : Œπ' √ó Œπ' // uncurry R x } := fun x => ‚ü®(f x, g x), hh x‚ü©
  let b : (Œ± ::: Œπ) ‚üπ _ := @diagSub n Œ± ::: h
  let c :
    (Subtype_ Œ±.repeatEq ::: { x // uncurry R x }) ‚üπ
      ((fun i : Fin2 n => { x // ofRepeat (Œ±.RelLast' R i.fs x) }) ::: Subtype (uncurry R)) :=
    ofSubtype _ ::: id
  have hh :
    subtypeVal _ ‚äö toSubtype _ ‚äö fromAppend1DropLast ‚äö c ‚äö b =
      ((id ::: f) ‚äó' (id ::: g)) ‚äö prod.diag := by
    dsimp [b]
    apply eq_of_drop_last_eq
    ¬∑ dsimp
      simp only [prod_map_id, dropFun_prod, dropFun_appendFun, dropFun_diag, TypeVec.id_comp,
        dropFun_toSubtype]
      erw [toSubtype_of_subtype_assoc, TypeVec.id_comp]
      clear liftR_map_last q mvf lawful F x R f g hh h b c
      ext (i x) : 2
      induction i with
      | fz => rfl
      | fs _ ih =>
        apply ih
    simp only [lastFun_from_append1_drop_last, lastFun_toSubtype, lastFun_appendFun,
      lastFun_subtypeVal, Function.id_comp, lastFun_comp, lastFun_prod]
    ext1
    rfl
  liftR_map _ _ _ _ (toSubtype _ ‚äö fromAppend1DropLast ‚äö c ‚äö b) hh",error:  unknown identifier 'mvf',"theorem liftR_map_last [lawful : LawfulMvFunctor F]
    {Œ± : TypeVec n} {Œπ Œπ'} (R : Œπ' ‚Üí Œπ' ‚Üí Prop)
    (x : F (Œ± ::: Œπ)) (f g : Œπ ‚Üí Œπ') (hh : ‚àÄ x : Œπ, R (f x) (g x)) :
    LiftR' (RelLast' _ R) ((id ::: f) <$$> x) ((id ::: g) <$$> x) ",":=
  let h : Œπ ‚Üí { x : Œπ' √ó Œπ' // uncurry R x } := fun x => ‚ü®(f x, g x), hh x‚ü©
  let b : (Œ± ::: Œπ) ‚üπ _ := @diagSub n Œ± ::: h
  let c :
    (Subtype_ Œ±.repeatEq ::: { x // uncurry R x }) ‚üπ
      ((fun i : Fin2 n => { x // ofRepeat (Œ±.RelLast' R i.fs x) }) ::: Subtype (uncurry R)) :=
    ofSubtype _ ::: id
  have hh :
    subtypeVal _ ‚äö toSubtype _ ‚äö fromAppend1DropLast ‚äö c ‚äö b =
      ((id ::: f) ‚äó' (id ::: g)) ‚äö prod.diag := by
    dsimp [b]
    apply eq_of_drop_last_eq
    ¬∑ dsimp
      simp only [prod_map_id, dropFun_prod, dropFun_appendFun, dropFun_diag, TypeVec.id_comp,
        dropFun_toSubtype]
      erw [toSubtype_of_subtype_assoc, TypeVec.id_comp]
      clear liftR_map_last q lawful F x R f g hh h b c
      ext (i x) : 2
      induction i with
      | fz => rfl
      | fs _ ih =>
        apply ih
    simp only [lastFun_from_append1_drop_last, lastFun_toSubtype, lastFun_appendFun,
      lastFun_subtypeVal, Function.id_comp, lastFun_comp, lastFun_prod]
    ext1
    rfl
  liftR_map _ _ _ _ (toSubtype _ ‚äö fromAppend1DropLast ‚äö c ‚äö b) hh"
Mathlib/Data/List/Cycle.lean,Cycle.induction_on,induction_on,56a65dd1165e3429d0a1c2ae59eab8c4e4c7fc24,":=
  Quotient.inductionOn s fun l => by
    refine List.recOn l ?_ ?_ <;> simp
    assumption'","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
error:  simp made no progress
error:  simp made no progress","theorem induction_on {C : Cycle Œ± ‚Üí Prop} (s : Cycle Œ±) (H0 : C nil)
    (HI : ‚àÄ (a) (l : List Œ±), C ‚Üël ‚Üí C ‚Üë(a :: l)) : C s ",":=
  Quotient.inductionOn' s fun l => by
    refine List.recOn l ?_ ?_ <;> simp
    assumption'"
Mathlib/LinearAlgebra/TensorProduct/RightExactness.lean,TensorProduct.map_ker,TensorProduct.map_ker,4b87b25f37ec0a84d277402f67adcc0e32c4ca30,":= by
  rw [‚Üê lTensor_comp_rTensor]
  rw [ker_comp]
  rw [‚Üê Exact.linearMap_ker_eq (rTensor_exact N' hfg hg)]
  rw [‚Üê Submodule.comap_map_eq]
  apply congr_arg‚ÇÇ _ rfl
  rw [range_eq_map, ‚Üê Submodule.map_comp, rTensor_comp_lTensor,
    Submodule.map_top]
  rw [‚Üê lTensor_comp_rTensor, range_eq_map, Submodule.map_comp,
    Submodule.map_top]
  rw [range_eq_top.mpr (rTensor.surjective M' hg), Submodule.map_top]
  rw [Exact.linearMap_ker_eq (lTensor_exact P hfg' hg')]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  rTensor
has type
  (M : Type ?u.520218) ‚Üí
    {N : Type ?u.520217} ‚Üí
      {P : Type ?u.520216} ‚Üí
        [inst : AddCommMonoid M] ‚Üí
          [inst_1 : AddCommMonoid N] ‚Üí
            [inst_2 : AddCommMonoid P] ‚Üí
              [inst_3 : Module ?m.520220 M] ‚Üí
                [inst_4 : Module ?m.520220 N] ‚Üí
                  [inst_5 : Module ?m.520220 P] ‚Üí (N ‚Üí‚Çó[?m.520220] P) ‚Üí N ‚äó[?m.520220] M ‚Üí‚Çó[?m.520220] P ‚äó[?m.520220] M","theorem TensorProduct.map_ker :
    ker (TensorProduct.map g g') = range (lTensor N f') ‚äî range (rTensor N' f) ",":= by
  rw [‚Üê lTensor_comp_rTensor]
  rw [ker_comp]
  rw [‚Üê Exact.linearMap_ker_eq (rTensor_exact N' hfg hg)]
  rw [‚Üê Submodule.comap_map_eq]
  apply congr_arg‚ÇÇ _ rfl
  rw [range_eq_map, ‚Üê Submodule.map_comp, rTensor_comp_lTensor,
    Submodule.map_top]
  rw [‚Üê lTensor_comp_rTensor, range_eq_map, Submodule.map_comp,
    Submodule.map_top]
  rw [range_eq_top.mpr (rTensor_surjective M' hg), Submodule.map_top]
  rw [Exact.linearMap_ker_eq (lTensor_exact P hfg' hg')]"
Mathlib/Analysis/Normed/Field/Basic.lean,nnnorm_pow_le,nnnorm_pow_le,bb57ebcc4194eb527dec55e15644d8e9cbdf30ca,"  | 1, _ => by simp only [pow_one]; rfl
  | n + 2, _ => by
    simpa only [pow_succ _ (n + 1)] using
      le_trans (nnnorm_mul_le _ _) (mul_le_mul_left' (nnnorm_pow_le' a n.succ_pos) _)","error:  type mismatch
  h‚úù
has type
  ‚Äña ^ (n + 1) * a ^ n.succ‚Äñ‚Çä ‚â§ ‚Äña ^ (n + 1)‚Äñ‚Çä * ‚Äña‚Äñ‚Çä ^ n.succ : Prop
but is expected to have type
  ‚Äña ^ (n + 1) * a‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä ^ (n + 1) * ‚Äña‚Äñ‚Çä : Prop","theorem nnnorm_pow_le' (a : Œ±) : ‚àÄ {n : ‚Ñï}, 0 < n ‚Üí ‚Äña ^ n‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä ^ n
","  | 1, _ => by simp only [pow_one, le_rfl]
  | n + 2, _ => by
    simpa only [pow_succ' _ (n + 1)] using
      le_trans (nnnorm_mul_le _ _) (mul_le_mul_left' (nnnorm_pow_le' a n.succ_pos) _)"
Mathlib/MeasureTheory/Integral/FundThmCalculus.lean,intervalIntegral.sub_le_integral_of_hasDeriv_right_of_le,sub_le_integral_of_hasDeriv_right_of_le,4a70d87f99917b0da1c5083b52b52653e78122d8,":= by
  refine' le_of_forall_pos_le_add fun Œµ Œµpos => _
  rcases exists_lt_lowerSemicontinuous_integral_lt œÜ œÜint Œµpos with
    ‚ü®G', f_lt_G', G'cont, G'int, G'lt_top, hG'‚ü©
  set s := {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} ‚à© Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, ‚à´ u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [‚Üê uIcc_of_le hab] at G'int hcont ‚ä¢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [inter_comm]
    exact this.preimage_closed_of_closed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b ‚äÜ {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain ‚ü®y, g'_lt_y', y_lt_G'‚ü© : ‚àÉ y : ‚Ñù, (g' t : EReal) < y ‚àß (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hœÜg t ht.2)).trans_lt (f_lt_G' t))
    have I1 : ‚àÄ·∂† u in ùìù[>] t, (u - t) * y ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      have B : ‚àÄ·∂† u in ùìù t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with ‚ü®m, M, ‚ü®hm, hM‚ü©, H‚ü©
      have : Ioo t (min M b) ‚àà ùìù[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u ‚äÜ Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = ‚à´ _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ ‚â§ ‚à´ w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, ‚Üê integral_Icc_eq_integral_Ioc]
          apply set_integral_mono_ae_restrict
          ¬∑ simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          ¬∑ exact IntegrableOn.mono_set G'int I
          ¬∑ have C1 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), G' x < ‚àû :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), x ‚àà Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x ‚àà Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t ‚ü®ht.2.1, ht.2.2‚ü©).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [‚Üê smul_eq_mul, sub_smul_slope] at this
    have I3 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : ‚àÄ·∂† u in ùìù[>] t, u ‚àà Ioc t (min v b) := by
      refine' mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 ‚ü®min v b, _, Subset.rfl‚ü©
      simp only [lt_min_iff, mem_Ioi]
      exact ‚ü®t_lt_v, ht.2.2‚ü©
    rcases (I3.and I4).exists with ‚ü®x, hx, h'x‚ü©
    refine' ‚ü®x, _, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x‚ü©
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ ‚â§ (‚à´ w in a..t, (G' w).toReal) + ‚à´ w in t..x, (G' w).toReal := (add_le_add ht.1 hx)
      _ = ‚à´ w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        ¬∑ rw [intervalIntegrable_iff_integrable_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        ¬∑ rw [intervalIntegrable_iff_integrable_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a ‚â§ ‚à´ y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ ‚â§ (‚à´ y in a..b, œÜ y) + Œµ := by
      convert hG'.le <;>
        ¬∑ rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]","error:  simp made no progress
warning:  `MeasureTheory.set_integral_mono_ae_restrict` has been deprecated, use `MeasureTheory.setIntegral_mono_ae_restrict` instead
error:  unknown identifier 'intervalIntegrable_iff_integrable_Ioc_of_le'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.311191
case hab
Œπ : Type u_1
ùïú : Type u_2
E : Type u_3
F : Type u_4
A : Type u_5
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚Ñù E
f : ‚Ñù ‚Üí E
g' g œÜ : ‚Ñù ‚Üí ‚Ñù
a b : ‚Ñù
hab : a ‚â§ b
hcont : ContinuousOn g (Icc a b)
hderiv : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x
œÜint : IntegrableOn œÜ (Icc a b) volume
hœÜg : ‚àÄ x ‚àà Ico a b, g' x ‚â§ œÜ x
Œµ : ‚Ñù
Œµpos : 0 < Œµ
G' : ‚Ñù ‚Üí EReal
f_lt_G' : ‚àÄ (x : ‚Ñù), ‚Üë(œÜ x) < G' x
G'cont : LowerSemicontinuous G'
G'int : Integrable (fun x ‚Ü¶ (G' x).toReal) (volume.restrict (Icc a b))
G'lt_top : ‚àÄ·µê (x : ‚Ñù) ‚àÇvolume.restrict (Icc a b), G' x < ‚ä§
hG' : ‚à´ (x : ‚Ñù) in Icc a b, (G' x).toReal ‚àÇvolume < ‚à´ (x : ‚Ñù) in Icc a b, œÜ x ‚àÇvolume + Œµ
s : Set ‚Ñù := {t | g t - g a ‚â§ ‚à´ (u : ‚Ñù) in a..t, (G' u).toReal} ‚à© Icc a b
s_closed : IsClosed s
t : ‚Ñù
ht : t ‚àà {t | g t - g a ‚â§ ‚à´ (u : ‚Ñù) in a..t, (G' u).toReal} ‚à© Ico a b
v : ‚Ñù
t_lt_v : v ‚àà Ioi t
y : ‚Ñù
g'_lt_y' : ‚Üë(g' t) < ‚Üëy
y_lt_G' : ‚Üëy < G' t
I1 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, (u - t) * y ‚â§ ‚à´ (w : ‚Ñù) in t..u, (G' w).toReal
I2 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, g u - g t ‚â§ (u - t) * y
I3 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, g u - g t ‚â§ ‚à´ (w : ‚Ñù) in t..u, (G' w).toReal
I4 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, u ‚àà Ioc t (min v b)
x : ‚Ñù
hx : g x - g t ‚â§ ‚à´ (w : ‚Ñù) in t..x, (G' w).toReal
h'x : x ‚àà Ioc t (min v b)
‚ä¢ IntervalIntegrable (fun x ‚Ü¶ (G' x).toReal) volume a t
error:  unknown identifier 'intervalIntegrable_iff_integrable_Ioc_of_le'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.311193
case hbc
Œπ : Type u_1
ùïú : Type u_2
E : Type u_3
F : Type u_4
A : Type u_5
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚Ñù E
f : ‚Ñù ‚Üí E
g' g œÜ : ‚Ñù ‚Üí ‚Ñù
a b : ‚Ñù
hab : a ‚â§ b
hcont : ContinuousOn g (Icc a b)
hderiv : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x
œÜint : IntegrableOn œÜ (Icc a b) volume
hœÜg : ‚àÄ x ‚àà Ico a b, g' x ‚â§ œÜ x
Œµ : ‚Ñù
Œµpos : 0 < Œµ
G' : ‚Ñù ‚Üí EReal
f_lt_G' : ‚àÄ (x : ‚Ñù), ‚Üë(œÜ x) < G' x
G'cont : LowerSemicontinuous G'
G'int : Integrable (fun x ‚Ü¶ (G' x).toReal) (volume.restrict (Icc a b))
G'lt_top : ‚àÄ·µê (x : ‚Ñù) ‚àÇvolume.restrict (Icc a b), G' x < ‚ä§
hG' : ‚à´ (x : ‚Ñù) in Icc a b, (G' x).toReal ‚àÇvolume < ‚à´ (x : ‚Ñù) in Icc a b, œÜ x ‚àÇvolume + Œµ
s : Set ‚Ñù := {t | g t - g a ‚â§ ‚à´ (u : ‚Ñù) in a..t, (G' u).toReal} ‚à© Icc a b
s_closed : IsClosed s
t : ‚Ñù
ht : t ‚àà {t | g t - g a ‚â§ ‚à´ (u : ‚Ñù) in a..t, (G' u).toReal} ‚à© Ico a b
v : ‚Ñù
t_lt_v : v ‚àà Ioi t
y : ‚Ñù
g'_lt_y' : ‚Üë(g' t) < ‚Üëy
y_lt_G' : ‚Üëy < G' t
I1 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, (u - t) * y ‚â§ ‚à´ (w : ‚Ñù) in t..u, (G' w).toReal
I2 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, g u - g t ‚â§ (u - t) * y
I3 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, g u - g t ‚â§ ‚à´ (w : ‚Ñù) in t..u, (G' w).toReal
I4 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, u ‚àà Ioc t (min v b)
x : ‚Ñù
hx : g x - g t ‚â§ ‚à´ (w : ‚Ñù) in t..x, (G' w).toReal
h'x : x ‚àà Ioc t (min v b)
‚ä¢ IntervalIntegrable (fun x ‚Ü¶ (G' x).toReal) volume t x","theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a ‚â§ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (œÜint : IntegrableOn œÜ (Icc a b)) (hœÜg : ‚àÄ x ‚àà Ico a b, g' x ‚â§ œÜ x) :
    g b - g a ‚â§ ‚à´ y in a..b, œÜ y ",":= by
  refine le_of_forall_pos_le_add fun Œµ Œµpos => ?_
  rcases exists_lt_lowerSemicontinuous_integral_lt œÜ œÜint Œµpos with
    ‚ü®G', f_lt_G', G'cont, G'int, G'lt_top, hG'‚ü©
  set s := {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} ‚à© Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, ‚à´ u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [‚Üê uIcc_of_le hab] at G'int hcont ‚ä¢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [s, inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b ‚äÜ {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain ‚ü®y, g'_lt_y', y_lt_G'‚ü© : ‚àÉ y : ‚Ñù, (g' t : EReal) < y ‚àß (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hœÜg t ht.2)).trans_lt (f_lt_G' t))
    have I1 : ‚àÄ·∂† u in ùìù[>] t, (u - t) * y ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      have B : ‚àÄ·∂† u in ùìù t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with ‚ü®m, M, ‚ü®hm, hM‚ü©, H‚ü©
      have : Ioo t (min M b) ‚àà ùìù[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u ‚äÜ Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = ‚à´ _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ ‚â§ ‚à´ w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, ‚Üê integral_Icc_eq_integral_Ioc]
          apply setIntegral_mono_ae_restrict
          ¬∑ simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          ¬∑ exact IntegrableOn.mono_set G'int I
          ¬∑ have C1 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), G' x < ‚àû :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), x ‚àà Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x ‚àà Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t ‚ü®ht.2.1, ht.2.2‚ü©).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [‚Üê smul_eq_mul, sub_smul_slope] at this
    have I3 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : ‚àÄ·∂† u in ùìù[>] t, u ‚àà Ioc t (min v b) := by
      refine mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 ‚ü®min v b, ?_, Subset.rfl‚ü©
      simp only [lt_min_iff, mem_Ioi]
      exact ‚ü®t_lt_v, ht.2.2‚ü©
    rcases (I3.and I4).exists with ‚ü®x, hx, h'x‚ü©
    refine ‚ü®x, ?_, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x‚ü©
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ ‚â§ (‚à´ w in a..t, (G' w).toReal) + ‚à´ w in t..x, (G' w).toReal := add_le_add ht.1 hx
      _ = ‚à´ w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        ¬∑ rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        ¬∑ rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a ‚â§ ‚à´ y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ ‚â§ (‚à´ y in a..b, œÜ y) + Œµ := by
      convert hG'.le <;>
        ¬∑ rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]"
Mathlib/Geometry/Manifold/ContMDiffMFDeriv.lean,ContMDiffOn.continuousOn_tangentMapWithin_aux,ContMDiffOn.continuousOn_tangentMapWithin_aux,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  suffices h :
    ContinuousOn
      (fun p : H √ó E =>
        (f p.fst,
          (fderivWithin ùïú (writtenInExtChartAt I I' p.fst f) (I.symm ‚Åª¬π' s ‚à© range I)
                ((extChartAt I p.fst) p.fst) : E ‚ÜíL[ùïú] E') p.snd)) (Prod.fst ‚Åª¬π' s)
  ¬∑ have A := (tangentBundleModelSpaceHomeomorph H I).continuous
    rw [continuous_iff_continuousOn_univ] at A
    have B :=
      ((tangentBundleModelSpaceHomeomorph H' I').symm.continuous.comp_continuousOn h).comp' A
    have :
      univ ‚à© tangentBundleModelSpaceHomeomorph H I ‚Åª¬π' (Prod.fst ‚Åª¬π' s) =
        œÄ E (TangentSpace I) ‚Åª¬π' s :=
      by ext ‚ü®x, v‚ü©; simp only [mfld_simps]
    rw [this] at B
    apply B.congr
    rintro ‚ü®x, v‚ü© hx
    dsimp [tangentMapWithin]
    ext; ¬∑ rfl
    simp only [mfld_simps]
    apply congr_fun
    apply congr_arg
    rw [MDifferentiableWithinAt.mfderivWithin (hf.mdifferentiableOn hn x hx)]
    rfl
  suffices h :
    ContinuousOn
      (fun p : H √ó E =>
        (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) (I p.fst) : E ‚ÜíL[ùïú] E') p.snd)
      (Prod.fst ‚Åª¬π' s)
  ¬∑ dsimp [writtenInExtChartAt, extChartAt]
    exact (ContinuousOn.comp hf.continuousOn continuous_fst.continuousOn Subset.rfl).prod h
  suffices h : ContinuousOn (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I)) (I '' s)
  ¬∑ have C := ContinuousOn.comp h I.continuous_toFun.continuousOn Subset.rfl
    have A : Continuous fun q : (E ‚ÜíL[ùïú] E') √ó E => q.1 q.2 :=
      isBoundedBilinearMapApply.continuous
    have B :
      ContinuousOn
        (fun p : H √ó E => (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) (I p.1), p.2))
        (Prod.fst ‚Åª¬π' s) := by
      apply ContinuousOn.prod _ continuous_snd.continuousOn
      refine C.comp continuousOn_fst ?_
      exact preimage_mono (subset_preimage_image _ _)
    exact A.comp_continuousOn B
  rw [contMDiffOn_iff] at hf
  let x : H := I.symm (0 : E)
  let y : H' := I'.symm (0 : E')
  have A := hf.2 x y
  simp only [I.image_eq, inter_comm, mfld_simps] at A ‚ä¢
  apply A.continuousOn_fderivWithin _ hn
  convert hs.uniqueDiffOn_target_inter x using 1
  simp only [inter_comm, mfld_simps]",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem ContMDiffOn.continuousOn_tangentMapWithin_aux {f : H ‚Üí H'} {s : Set H}
    (hf : ContMDiffOn I I' n f s) (hn : 1 ‚â§ n) (hs : UniqueMDiffOn I s) :
    ContinuousOn (tangentMapWithin I I' f s) (œÄ E (TangentSpace I) ‚Åª¬π' s) ",":= by
  suffices h :
    ContinuousOn
      (fun p : H √ó E =>
        (f p.fst,
          (fderivWithin ùïú (writtenInExtChartAt I I' p.fst f) (I.symm ‚Åª¬π' s ‚à© range I)
                ((extChartAt I p.fst) p.fst) : E ‚ÜíL[ùïú] E') p.snd)) (Prod.fst ‚Åª¬π' s) by
    have A := (tangentBundleModelSpaceHomeomorph H I).continuous
    rw [continuous_iff_continuousOn_univ] at A
    have B :=
      ((tangentBundleModelSpaceHomeomorph H' I').symm.continuous.comp_continuousOn h).comp' A
    have :
      univ ‚à© tangentBundleModelSpaceHomeomorph H I ‚Åª¬π' (Prod.fst ‚Åª¬π' s) =
        œÄ E (TangentSpace I) ‚Åª¬π' s := by
      ext ‚ü®x, v‚ü©; simp only [mfld_simps]
    rw [this] at B
    apply B.congr
    rintro ‚ü®x, v‚ü© hx
    dsimp [tangentMapWithin]
    ext; ¬∑ rfl
    simp only [mfld_simps]
    apply congr_fun
    apply congr_arg
    rw [MDifferentiableWithinAt.mfderivWithin (hf.mdifferentiableOn hn x hx)]
    rfl
  suffices h :
    ContinuousOn
      (fun p : H √ó E =>
        (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) (I p.fst) : E ‚ÜíL[ùïú] E') p.snd)
      (Prod.fst ‚Åª¬π' s) by
    dsimp [writtenInExtChartAt, extChartAt]
    exact (ContinuousOn.comp hf.continuousOn continuous_fst.continuousOn Subset.rfl).prod h
  suffices h : ContinuousOn (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I)) (I '' s) by
    have C := ContinuousOn.comp h I.continuous_toFun.continuousOn Subset.rfl
    have A : Continuous fun q : (E ‚ÜíL[ùïú] E') √ó E => q.1 q.2 :=
      isBoundedBilinearMap_apply.continuous
    have B :
      ContinuousOn
        (fun p : H √ó E => (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) (I p.1), p.2))
        (Prod.fst ‚Åª¬π' s) := by
      apply ContinuousOn.prod _ continuous_snd.continuousOn
      refine C.comp continuousOn_fst ?_
      exact preimage_mono (subset_preimage_image _ _)
    exact A.comp_continuousOn B
  rw [contMDiffOn_iff] at hf
  let x : H := I.symm (0 : E)
  let y : H' := I'.symm (0 : E')
  have A := hf.2 x y
  simp only [I.image_eq, inter_comm, mfld_simps] at A ‚ä¢
  apply A.continuousOn_fderivWithin _ hn
  convert hs.uniqueDiffOn_target_inter x using 1
  simp only [inter_comm, mfld_simps]"
Mathlib/MeasureTheory/Measure/Regular.lean,MeasureTheory.Measure.InnerRegularWRT.of_sigmaFinite,of_sigmaFinite,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  intro s hs r hr
  set B : ‚Ñï ‚Üí Set Œ± := spanningSets Œº
  have hBU : ‚ãÉ n, s ‚à© B n = s := by rw [‚Üê inter_iUnion, iUnion_spanningSets, inter_univ]
  have : Œº s = ‚®Ü n, Œº (s ‚à© B n) := by
    rw [‚Üê measure_iUnion_eq_iSup, hBU]
    exact Monotone.directed_le fun m n h => inter_subset_inter_right _ (monotone_spanningSets Œº h)
  rw [this] at hr
  rcases lt_iSup_iff.1 hr with ‚ü®n, hn‚ü©
  refine ‚ü®s ‚à© B n, inter_subset_left _ _, ‚ü®hs.inter (measurable_spanningSets Œº n), ?_‚ü©, hn‚ü©
  exact ((measure_mono (inter_subset_right _ _)).trans_lt (measure_spanningSets_lt_top Œº n)).ne","error:  function expected at
  inter_subset_left ?m.101697
term has type
  ?m.101696 ‚àà ?m.101694
error:  function expected at
  inter_subset_right ?m.101782
term has type
  ?m.101781 ‚àà ?m.101780","lemma of_sigmaFinite [SigmaFinite Œº] :
    InnerRegularWRT Œº (fun s ‚Ü¶ MeasurableSet s ‚àß Œº s ‚â† ‚àû) (fun s ‚Ü¶ MeasurableSet s) ",":= by
  intro s hs r hr
  set B : ‚Ñï ‚Üí Set Œ± := spanningSets Œº
  have hBU : ‚ãÉ n, s ‚à© B n = s := by rw [‚Üê inter_iUnion, iUnion_spanningSets, inter_univ]
  have : Œº s = ‚®Ü n, Œº (s ‚à© B n) := by
    rw [‚Üê measure_iUnion_eq_iSup, hBU]
    exact Monotone.directed_le fun m n h => inter_subset_inter_right _ (monotone_spanningSets Œº h)
  rw [this] at hr
  rcases lt_iSup_iff.1 hr with ‚ü®n, hn‚ü©
  refine ‚ü®s ‚à© B n, inter_subset_left, ‚ü®hs.inter (measurable_spanningSets Œº n), ?_‚ü©, hn‚ü©
  exact ((measure_mono inter_subset_right).trans_lt (measure_spanningSets_lt_top Œº n)).ne"
Mathlib/Geometry/Manifold/ContMDiffMFDeriv.lean,TangentBundle.tangentMap_tangentBundle_pure,tangentMap_tangentBundle_pure,01cbe052ff3f63d184556afa56666d0df4fed183,":= by
  rcases p with ‚ü®x, v‚ü©
  have N : I.symm ‚Åª¬π' (chartAt H x).target ‚àà ùìù (I ((chartAt H x) x)) := by
    apply IsOpen.mem_nhds
    apply (LocalHomeomorph.open_target _).preimage I.continuous_invFun
    simp only [mfld_simps]
  have A : MDifferentiableAt I I.tangent (fun x => @TotalSpace.mk M E (TangentSpace I) x 0) x :=
    haveI : Smooth I (I.prod ùìò(ùïú, E)) (zeroSection E (TangentSpace I : M ‚Üí Type _)) :=
      Bundle.smooth_zeroSection ùïú (TangentSpace I : M ‚Üí Type _)
    this.mdifferentiableAt
  have B :
    fderivWithin ùïú (fun x' : E => (x', (0 : E))) (Set.range I) (I ((chartAt H x) x)) v = (v, 0)
  ¬∑ rw [fderivWithin_eq_fderiv, DifferentiableAt.fderiv_prod]
    ¬∑ simp
    ¬∑ exact differentiableAt_id'
    ¬∑ exact differentiableAt_const _
    ¬∑ exact ModelWithCorners.unique_diff_at_image I
    ¬∑ exact differentiableAt_id'.prod (differentiableAt_const _)
  simp only [Bundle.zeroSection, tangentMap, mfderiv, A, if_pos, chartAt,
    FiberBundle.chartedSpace_chartAt, TangentBundle.trivializationAt_apply, tangentBundleCore,
    Function.comp, ContinuousLinearMap.map_zero, mfld_simps]
  rw [‚Üê fderivWithin_inter N] at B
  rw [‚Üê fderivWithin_inter N, ‚Üê B]
  congr 1
  refine' fderivWithin_congr (fun y hy => _) _
  ¬∑ simp only [mfld_simps] at hy
    simp only [hy, Prod.mk.inj_iff, mfld_simps]
  ¬∑ simp only [Prod.mk.inj_iff, mfld_simps]","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case mk
ùïú : Type u_1
inst‚úù¬≤‚Å¥ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬≤¬≥ : NormedAddCommGroup E
inst‚úù¬≤¬≤ : NormedSpace ùïú E
H : Type u_3
inst‚úù¬≤¬π : TopologicalSpace H
I : ModelWithCorners ùïú E H
M : Type u_4
inst‚úù¬≤‚Å∞ : TopologicalSpace M
inst‚úù¬π‚Åπ : ChartedSpace H M
Is : SmoothManifoldWithCorners I M
E' : Type u_5
inst‚úù¬π‚Å∏ : NormedAddCommGroup E'
inst‚úù¬π‚Å∑ : NormedSpace ùïú E'
H' : Type u_6
inst‚úù¬π‚Å∂ : TopologicalSpace H'
I' : ModelWithCorners ùïú E' H'
M' : Type u_7
inst‚úù¬π‚Åµ : TopologicalSpace M'
inst‚úù¬π‚Å¥ : ChartedSpace H' M'
I's : SmoothManifoldWithCorners I' M'
F : Type u_8
inst‚úù¬π¬≥ : NormedAddCommGroup F
inst‚úù¬π¬≤ : NormedSpace ùïú F
G : Type u_9
inst‚úù¬π¬π : TopologicalSpace G
J : ModelWithCorners ùïú F G
N‚úù : Type u_10
inst‚úù¬π‚Å∞ : TopologicalSpace N‚úù
inst‚úù‚Åπ : ChartedSpace G N‚úù
Js : SmoothManifoldWithCorners J N‚úù
F' : Type u_11
inst‚úù‚Å∏ : NormedAddCommGroup F'
inst‚úù‚Å∑ : NormedSpace ùïú F'
G' : Type u_12
inst‚úù‚Å∂ : TopologicalSpace G'
J' : ModelWithCorners ùïú F' G'
N' : Type u_13
inst‚úù‚Åµ : TopologicalSpace N'
inst‚úù‚Å¥ : ChartedSpace G' N'
J's : SmoothManifoldWithCorners J' N'
F‚ÇÅ : Type u_14
inst‚úù¬≥ : NormedAddCommGroup F‚ÇÅ
inst‚úù¬≤ : NormedSpace ùïú F‚ÇÅ
F‚ÇÇ : Type u_15
inst‚úù¬π : NormedAddCommGroup F‚ÇÇ
inst‚úù : NormedSpace ùïú F‚ÇÇ
f f‚ÇÅ : M ‚Üí M'
s s‚ÇÅ t : Set M
x‚úù : M
m n : ‚Ñï‚àû
x : M
v : TangentSpace I x
N : ‚ÜëI.symm ‚Åª¬π' (chartAt H x).target ‚àà ùìù (‚ÜëI (‚Üë(chartAt H x) x))
A : MDifferentiableAt I I.tangent (fun x ‚Ü¶ { proj := x, snd := 0 }) x
B : (fderivWithin ùïú (fun x' ‚Ü¶ (x', 0)) (range ‚ÜëI) (‚ÜëI (‚Üë(chartAt H x) x))) v = (v, 0)
‚ä¢ tangentMap I I.tangent (zeroSection E (TangentSpace I)) { proj := x, snd := v } =
    { proj := { proj := { proj := x, snd := v }.proj, snd := 0 }, snd := ({ proj := x, snd := v }.snd, 0) }","theorem tangentMap_tangentBundle_pure (p : TangentBundle I M) :
    tangentMap I I.tangent (zeroSection E (TangentSpace I)) p = ‚ü®‚ü®p.proj, 0‚ü©, ‚ü®p.2, 0‚ü©‚ü© ",":= by
  rcases p with ‚ü®x, v‚ü©
  have N : I.symm ‚Åª¬π' (chartAt H x).target ‚àà ùìù (I ((chartAt H x) x)) := by
    apply IsOpen.mem_nhds
    ¬∑ apply (PartialHomeomorph.open_target _).preimage I.continuous_invFun
    ¬∑ simp only [mfld_simps]
  have A : MDifferentiableAt I I.tangent (fun x => @TotalSpace.mk M E (TangentSpace I) x 0) x :=
    haveI : Smooth I (I.prod ùìò(ùïú, E)) (zeroSection E (TangentSpace I : M ‚Üí Type _)) :=
      Bundle.smooth_zeroSection ùïú (TangentSpace I : M ‚Üí Type _)
    this.mdifferentiableAt
  have B : fderivWithin ùïú (fun x' : E ‚Ü¶ (x', (0 : E))) (Set.range I) (I ((chartAt H x) x)) v
      = (v, 0) := by
    rw [fderivWithin_eq_fderiv, DifferentiableAt.fderiv_prod]
    ¬∑ simp
    ¬∑ exact differentiableAt_id'
    ¬∑ exact differentiableAt_const _
    ¬∑ exact ModelWithCorners.unique_diff_at_image I
    ¬∑ exact differentiableAt_id'.prod (differentiableAt_const _)
  simp (config := { unfoldPartialApp := true }) only [Bundle.zeroSection, tangentMap, mfderiv, A,
    if_pos, chartAt, FiberBundle.chartedSpace_chartAt, TangentBundle.trivializationAt_apply,
    tangentBundleCore, Function.comp_def, ContinuousLinearMap.map_zero, mfld_simps]
  rw [‚Üê fderivWithin_inter N] at B
  rw [‚Üê fderivWithin_inter N, ‚Üê B]
  congr 1
  refine fderivWithin_congr (fun y hy => ?_) ?_
  ¬∑ simp only [mfld_simps] at hy
    simp only [hy, Prod.mk.inj_iff, mfld_simps]
  ¬∑ simp only [Prod.mk.inj_iff, mfld_simps]"
Mathlib/Data/Finset/Fold.lean,Finset.fold_ite',fold_ite',0bebc04d590fc842eb010ce97ef06a3d798d31f2,":= by
  classical
    induction' s using Finset.induction_on with x s hx IH
    ¬∑ simp [hb]
    ¬∑ simp only [Finset.fold_insert hx]
      split_ifs with h
      ¬∑ have : x ‚àâ Finset.filter p s := by simp [hx]
        simp [Finset.filter_insert, h, Finset.fold_insert this, ha.assoc, IH]
      ¬∑ have : x ‚àâ Finset.filter (fun i => !p i) s := by simp [hx]
        simp [Finset.filter_insert, h, Finset.fold_insert this, IH, ‚Üê ha.assoc, hc.comm]","error:  unsolved goals
case neg
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
op : Œ≤ ‚Üí Œ≤ ‚Üí Œ≤
hc : Std.Commutative op
ha : Std.Associative op
f : Œ± ‚Üí Œ≤
b : Œ≤
s‚úù : Finset Œ±
a : Œ±
g : Œ± ‚Üí Œ≤
hb : op b b = b
p : Œ± ‚Üí Prop
inst‚úù : DecidablePred p
x : Œ±
s : Finset Œ±
hx : x ‚àâ s
IH :
  fold op b (fun i ‚Ü¶ if p i then f i else g i) s = op (fold op b f (filter p s)) (fold op b g (filter (fun i ‚Ü¶ ¬¨p i) s))
h : ¬¨p x
this : x ‚àâ filter (fun i ‚Ü¶ (!decide (p i)) = true) s
‚ä¢ op (op (g x) (fold op b f (filter p s))) (fold op b g (filter (fun i ‚Ü¶ ¬¨p i) s)) =
    op (fold op b f (filter p s)) (fold op b g (insert x (filter (fun i ‚Ü¶ ¬¨p i) s)))","theorem fold_ite' {g : Œ± ‚Üí Œ≤} (hb : op b b = b) (p : Œ± ‚Üí Prop) [DecidablePred p] :
    Finset.fold op b (fun i => ite (p i) (f i) (g i)) s =
      op (Finset.fold op b f (s.filter p)) (Finset.fold op b g (s.filter fun i => ¬¨p i)) ",":= by
  classical
    induction' s using Finset.induction_on with x s hx IH
    ¬∑ simp [hb]
    ¬∑ simp only [Finset.fold_insert hx]
      split_ifs with h
      ¬∑ have : x ‚àâ Finset.filter p s := by simp [hx]
        simp [Finset.filter_insert, h, Finset.fold_insert this, ha.assoc, IH]
      ¬∑ have : x ‚àâ Finset.filter (fun i => ¬¨ p i) s := by simp [hx]
        simp [Finset.filter_insert, h, Finset.fold_insert this, IH, ‚Üê ha.assoc, hc.comm]"
Mathlib/Combinatorics/Hall/Finite.lean,HallMarriageTheorem.hall_hard_inductive_step_B,hall_hard_inductive_step_B,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  haveI := Classical.decEq Œπ
  rw [Nat.add_one] at hn
  have card_Œπ'_le : Fintype.card s ‚â§ n := by
    apply Nat.le_of_lt_succ
    calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card Œπ := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
  let t' : s ‚Üí Finset Œ± := fun x' => t x'
  rcases ih t' card_Œπ'_le (hall_cond_of_restrict ht) with ‚ü®f', hf', hsf'‚ü©
  set Œπ'' := (s : Set Œπ)·∂ú
  let t'' : Œπ'' ‚Üí Finset Œ± := fun a'' => t a'' \ s.biUnion t
  have card_Œπ''_le : Fintype.card Œπ'' ‚â§ n := by
    simp_rw [Œπ'', ‚Üê Nat.lt_succ_iff, ‚Üê hn, ‚Üê Finset.coe_compl, coe_sort_coe]
    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]
  rcases ih t'' card_Œπ''_le (hall_cond_of_compl hus ht) with ‚ü®f'', hf'', hsf''‚ü©
  have f'_mem_biUnion : ‚àÄ (x') (hx' : x' ‚àà s), f' ‚ü®x', hx'‚ü© ‚àà s.biUnion t := by
    intro x' hx'
    rw [mem_biUnion]
    exact ‚ü®x', hx', hsf' _‚ü©
  have f''_not_mem_biUnion : ‚àÄ (x'') (hx'' : ¬¨x'' ‚àà s), ¬¨f'' ‚ü®x'', hx''‚ü© ‚àà s.biUnion t := by
    intro x'' hx''
    have h := hsf'' ‚ü®x'', hx''‚ü©
    rw [mem_sdiff] at h
    exact h.2
  have im_disj :
      ‚àÄ (x' x'' : Œπ) (hx' : x' ‚àà s) (hx'' : ¬¨x'' ‚àà s), f' ‚ü®x', hx'‚ü© ‚â† f'' ‚ü®x'', hx''‚ü© := by
    intro x x' hx' hx'' h
    apply f''_not_mem_biUnion x' hx''
    rw [‚Üê h]
    apply f'_mem_biUnion x
  refine ‚ü®fun x => if h : x ‚àà s then f' ‚ü®x, h‚ü© else f'' ‚ü®x, h‚ü©, ?_,? _‚ü©
  ¬∑ refine' hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)
  ¬∑ intro x
    simp only [of_eq_true]
    split_ifs with h
    ¬∑ exact hsf' ‚ü®x, h‚ü©
    ¬∑ exact sdiff_subset _ _ (hsf'' ‚ü®x, h‚ü©)","error:  function expected at
  sdiff_subset ?m.41056
term has type
  ?m.41055 ‚àà ?m.41053","theorem hall_hard_inductive_step_B {n : ‚Ñï} (hn : Fintype.card Œπ = n + 1)
    (ht : ‚àÄ s : Finset Œπ, s.card ‚â§ (s.biUnion t).card)
    (ih :
      ‚àÄ {Œπ' : Type u} [Fintype Œπ'] (t' : Œπ' ‚Üí Finset Œ±),
        Fintype.card Œπ' ‚â§ n ‚Üí
          (‚àÄ s' : Finset Œπ', s'.card ‚â§ (s'.biUnion t').card) ‚Üí
            ‚àÉ f : Œπ' ‚Üí Œ±, Function.Injective f ‚àß ‚àÄ x, f x ‚àà t' x)
    (s : Finset Œπ) (hs : s.Nonempty) (hns : s ‚â† univ) (hus : s.card = (s.biUnion t).card) :
    ‚àÉ f : Œπ ‚Üí Œ±, Function.Injective f ‚àß ‚àÄ x, f x ‚àà t x ",":= by
  haveI := Classical.decEq Œπ
  rw [Nat.add_one] at hn
  have card_Œπ'_le : Fintype.card s ‚â§ n := by
    apply Nat.le_of_lt_succ
    calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card Œπ := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
  let t' : s ‚Üí Finset Œ± := fun x' => t x'
  rcases ih t' card_Œπ'_le (hall_cond_of_restrict ht) with ‚ü®f', hf', hsf'‚ü©
  set Œπ'' := (s : Set Œπ)·∂ú
  let t'' : Œπ'' ‚Üí Finset Œ± := fun a'' => t a'' \ s.biUnion t
  have card_Œπ''_le : Fintype.card Œπ'' ‚â§ n := by
    simp_rw [Œπ'', ‚Üê Nat.lt_succ_iff, ‚Üê hn, ‚Üê Finset.coe_compl, coe_sort_coe]
    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]
  rcases ih t'' card_Œπ''_le (hall_cond_of_compl hus ht) with ‚ü®f'', hf'', hsf''‚ü©
  have f'_mem_biUnion : ‚àÄ (x') (hx' : x' ‚àà s), f' ‚ü®x', hx'‚ü© ‚àà s.biUnion t := by
    intro x' hx'
    rw [mem_biUnion]
    exact ‚ü®x', hx', hsf' _‚ü©
  have f''_not_mem_biUnion : ‚àÄ (x'') (hx'' : ¬¨x'' ‚àà s), ¬¨f'' ‚ü®x'', hx''‚ü© ‚àà s.biUnion t := by
    intro x'' hx''
    have h := hsf'' ‚ü®x'', hx''‚ü©
    rw [mem_sdiff] at h
    exact h.2
  have im_disj :
      ‚àÄ (x' x'' : Œπ) (hx' : x' ‚àà s) (hx'' : ¬¨x'' ‚àà s), f' ‚ü®x', hx'‚ü© ‚â† f'' ‚ü®x'', hx''‚ü© := by
    intro x x' hx' hx'' h
    apply f''_not_mem_biUnion x' hx''
    rw [‚Üê h]
    apply f'_mem_biUnion x
  refine ‚ü®fun x => if h : x ‚àà s then f' ‚ü®x, h‚ü© else f'' ‚ü®x, h‚ü©, ?_, ?_‚ü©
  ¬∑ refine hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)
  ¬∑ intro x
    simp only [of_eq_true]
    split_ifs with h
    ¬∑ exact hsf' ‚ü®x, h‚ü©
    ¬∑ exact sdiff_subset (hsf'' ‚ü®x, h‚ü©)"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicOn.add,add,1df5e9f2d5d2defceda7b95892bf4c4bb80859af,":= by
  rcases hf with ‚ü®m, hf‚ü©
  rcases hg with ‚ü®n, hg‚ü©
  refine ‚ü®max m n, ?_‚ü©
  have : (fun z ‚Ü¶ (z - x) ^ max m n ‚Ä¢ (f + g) z) = fun z ‚Ü¶ (z - x) ^ (max m n - m) ‚Ä¢
    ((z - x) ^ m ‚Ä¢ f z) + (z - x) ^ (max m n - n) ‚Ä¢ ((z - x) ^ n ‚Ä¢ g z)
  ¬∑ simp_rw [‚Üê mul_smul, ‚Üê pow_add, Nat.sub_add_cancel (Nat.le_max_left _ _),
      Nat.sub_add_cancel (Nat.le_max_right _ _), Pi.add_apply, smul_add]
  rw [this]
  exact ((((analyticAt_id ùïú x).sub analyticAt_const).pow _).smul hf).add
   ((((analyticAt_id ùïú x).sub analyticAt_const).pow _).smul hg)","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case intro.intro
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
f g : ùïú ‚Üí E
x : ùïú
m : ‚Ñï
hf : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ m ‚Ä¢ f z) x
n : ‚Ñï
hg : AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ n ‚Ä¢ g z) x
this :
  (fun z ‚Ü¶ (z - x) ^ max m n ‚Ä¢ (f + g) z) = fun z ‚Ü¶
    (z - x) ^ (max m n - m) ‚Ä¢ (z - x) ^ m ‚Ä¢ f z + (z - x) ^ (max m n - n) ‚Ä¢ (z - x) ^ n ‚Ä¢ g z
‚ä¢ AnalyticAt ùïú (fun z ‚Ü¶ (z - x) ^ max m n ‚Ä¢ (f + g) z) x","lemma add {f g : ùïú ‚Üí E} {x : ùïú} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :
    MeromorphicAt (f + g) x ",":= by
  rcases hf with ‚ü®m, hf‚ü©
  rcases hg with ‚ü®n, hg‚ü©
  refine ‚ü®max m n, ?_‚ü©
  have : (fun z ‚Ü¶ (z - x) ^ max m n ‚Ä¢ (f + g) z) = fun z ‚Ü¶ (z - x) ^ (max m n - m) ‚Ä¢
      ((z - x) ^ m ‚Ä¢ f z) + (z - x) ^ (max m n - n) ‚Ä¢ ((z - x) ^ n ‚Ä¢ g z) := by
    simp_rw [‚Üê mul_smul, ‚Üê pow_add, Nat.sub_add_cancel (Nat.le_max_left _ _),
      Nat.sub_add_cancel (Nat.le_max_right _ _), Pi.add_apply, smul_add]
  rw [this]
  exact ((((analyticAt_id ùïú x).sub analyticAt_const).pow _).smul hf).add
   ((((analyticAt_id ùïú x).sub analyticAt_const).pow _).smul hg)"
Mathlib/Algebra/Module/Torsion.lean,Ideal.CompleteLattice.Independent.linear_independent',CompleteLattice.Independent.linear_independent',10e4cb0958e9421c11ec57a20aeb1367810b8675,":= by
  refine' linearIndependent_iff_not_smul_mem_span.mpr fun i r hi => _
  replace hv := CompleteLattice.independent_def.mp hv i
  simp only [iSup_subtype', ‚Üê Submodule.span_range_eq_iSup (Œπ := Subtype _), disjoint_iff] at hv
  have : r ‚Ä¢ v i ‚àà ‚ä• := by
    rw [‚Üê hv, Submodule.mem_inf]
    refine' ‚ü®Submodule.mem_span_singleton.mpr ‚ü®r, rfl‚ü©, _‚ü©
    convert hi
    ext
    simp
  rw [‚Üê Submodule.mem_bot R, ‚Üê h_ne_zero i]
  simpa using this","error:  typeclass instance problem is stuck, it is often due to metavariables
  Membership M ?m.17958","theorem CompleteLattice.Independent.linear_independent' {Œπ R M : Type*} {v : Œπ ‚Üí M} [Ring R]
    [AddCommGroup M] [Module R M] (hv : CompleteLattice.Independent fun i => R ‚àô v i)
    (h_ne_zero : ‚àÄ i, Ideal.torsionOf R M (v i) = ‚ä•) : LinearIndependent R v ",":= by
  refine linearIndependent_iff_not_smul_mem_span.mpr fun i r hi => ?_
  replace hv := CompleteLattice.independent_def.mp hv i
  simp only [iSup_subtype', ‚Üê Submodule.span_range_eq_iSup (Œπ := Subtype _), disjoint_iff] at hv
  have : r ‚Ä¢ v i ‚àà (‚ä• : Submodule R M) := by
    rw [‚Üê hv, Submodule.mem_inf]
    refine ‚ü®Submodule.mem_span_singleton.mpr ‚ü®r, rfl‚ü©, ?_‚ü©
    convert hi
    ext
    simp
  rw [‚Üê Submodule.mem_bot R, ‚Üê h_ne_zero i]
  simpa using this"
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean,Embedding.comp_stronglyMeasurable_iff,_root_.Embedding.comp_stronglyMeasurable_iff,412e0c9b1645024df058234a0424e02c26633429,":= by
  letI := pseudoMetrizableSpacePseudoMetric Œ≥
  borelize Œ≤ Œ≥
  refine'
    ‚ü®fun H => stronglyMeasurable_iff_measurable_separable.2 ‚ü®_, _‚ü©, fun H =>
      hg.continuous.comp_stronglyMeasurable H‚ü©
  ¬∑ let G : Œ≤ ‚Üí range g := codRestrict g (range g) mem_range_self
    have hG : ClosedEmbedding G :=
      { hg.codRestrict _ _ with
        closed_range := by
          convert isClosed_univ (X := ‚Ü•(range g))
          apply eq_univ_of_forall
          rintro ‚ü®-, ‚ü®x, rfl‚ü©‚ü©
          exact mem_range_self x }
    have : Measurable (G ‚àò f) := Measurable.subtype_mk H.measurable
    exact hG.measurableEmbedding.measurable_comp_iff.1 this
  ¬∑ have : IsSeparable (g ‚Åª¬π' range (g ‚àò f)) := hg.isSeparable_preimage H.isSeparable_range
    convert this
    ext x
    simp [hg.inj.eq_iff]",error:  'closed_range' is not a field of structure 'ClosedEmbedding',"theorem _root_.Embedding.comp_stronglyMeasurable_iff {m : MeasurableSpace Œ±} [TopologicalSpace Œ≤]
    [PseudoMetrizableSpace Œ≤] [TopologicalSpace Œ≥] [PseudoMetrizableSpace Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤}
    (hg : Embedding g) : (StronglyMeasurable fun x => g (f x)) ‚Üî StronglyMeasurable f ",":= by
  letI := pseudoMetrizableSpacePseudoMetric Œ≥
  borelize Œ≤ Œ≥
  refine
    ‚ü®fun H => stronglyMeasurable_iff_measurable_separable.2 ‚ü®?_, ?_‚ü©, fun H =>
      hg.continuous.comp_stronglyMeasurable H‚ü©
  ¬∑ let G : Œ≤ ‚Üí range g := rangeFactorization g
    have hG : ClosedEmbedding G :=
      { hg.codRestrict _ _ with
        isClosed_range := by
          rw [surjective_onto_range.range_eq]
          exact isClosed_univ }
    have : Measurable (G ‚àò f) := Measurable.subtype_mk H.measurable
    exact hG.measurableEmbedding.measurable_comp_iff.1 this
  ¬∑ have : IsSeparable (g ‚Åª¬π' range (g ‚àò f)) := hg.isSeparable_preimage H.isSeparable_range
    rwa [range_comp, hg.inj.preimage_image] at this"
Mathlib/Probability/Kernel/RadonNikodym.lean,ProbabilityTheory.kernel.withDensity_one_sub_rnDerivAux,withDensity_one_sub_rnDerivAux,f5fbe095a20c0f89887bd82f51d1de028c627567,":= by
  have h_le : Œ∫ ‚â§ Œ∫ + Œ∑ := le_add_of_nonneg_right bot_le
  suffices withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))
      + withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))
      = Œ∫ + Œ∑ by
    ext a s
    have h : (withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))
          + withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))) a s
        = Œ∫ a s + Œ∑ a s := by
      rw [this]
      simp
    simp only [coeFn_add, Pi.add_apply, Measure.add_toOuterMeasure, OuterMeasure.coe_add]
      at h
    rwa [withDensity_rnDerivAux, add_comm, ENNReal.add_right_inj (measure_ne_top _ _)] at h
  have : ‚àÄ b, (Real.toNNReal b : ‚Ñù‚â•0‚àû) = ENNReal.ofReal b := fun _ ‚Ü¶ rfl
  simp_rw [this, ENNReal.ofReal_sub _ (rnDerivAux_nonneg h_le), ENNReal.ofReal_one]
  rw [withDensity_sub_add_cancel]
  ¬∑ rw [withDensity_one']
  ¬∑ exact measurable_const
  ¬∑ exact (measurable_rnDerivAux _ _).ennreal_ofReal
  ¬∑ intro a
    filter_upwards [rnDerivAux_le_one h_le] with x hx
    simp only [ENNReal.ofReal_le_one]
    exact hx","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.28285 ?m.28287 + ?m.28280 = ?m.28285 ?m.28287 + ?m.28281
case h.h
Œ± : Type u_1
Œ≥ : Type u_2
mŒ± : MeasurableSpace Œ±
mŒ≥ : MeasurableSpace Œ≥
Œ∫‚úù Œ∑‚úù : ‚Ü•(kernel Œ± Œ≥)
hŒ±Œ≥ : MeasurableSpace.CountableOrCountablyGenerated Œ± Œ≥
Œ∫ Œ∑ : ‚Ü•(kernel Œ± Œ≥)
inst‚úù¬π : IsFiniteKernel Œ∫
inst‚úù : IsFiniteKernel Œ∑
h_le : Œ∫ ‚â§ Œ∫ + Œ∑
this :
  ((withDensity (Œ∫ + Œ∑) fun a x ‚Ü¶ ‚Üë(1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x).toNNReal) +
      withDensity (Œ∫ + Œ∑) fun a x ‚Ü¶ ‚Üë(rnDerivAux Œ∫ (Œ∫ + Œ∑) a x).toNNReal) =
    Œ∫ + Œ∑
a : Œ±
s : Set Œ≥
a‚úù : MeasurableSet s
h : (Œ∫ a + (withDensity (Œ∫ + Œ∑) fun a x ‚Ü¶ ‚Üë(1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x).toNNReal) a) s = (Œ∫ a) s + (Œ∑ a) s
‚ä¢ ((withDensity (Œ∫ + Œ∑) fun a x ‚Ü¶ ‚Üë(1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x).toNNReal) a) s = (Œ∑ a) s","lemma withDensity_one_sub_rnDerivAux (Œ∫ Œ∑ : kernel Œ± Œ≥) [IsFiniteKernel Œ∫] [IsFiniteKernel Œ∑] :
    withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x)) = Œ∑ ",":= by
  have h_le : Œ∫ ‚â§ Œ∫ + Œ∑ := le_add_of_nonneg_right bot_le
  suffices withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))
      + withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))
      = Œ∫ + Œ∑ by
    ext a s
    have h : (withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))
          + withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))) a s
        = Œ∫ a s + Œ∑ a s := by
      rw [this]
      simp
    simp only [coeFn_add, Pi.add_apply, Measure.coe_add] at h
    rwa [withDensity_rnDerivAux, add_comm, ENNReal.add_right_inj (measure_ne_top _ _)] at h
  have : ‚àÄ b, (Real.toNNReal b : ‚Ñù‚â•0‚àû) = ENNReal.ofReal b := fun _ ‚Ü¶ rfl
  simp_rw [this, ENNReal.ofReal_sub _ (rnDerivAux_nonneg h_le), ENNReal.ofReal_one]
  rw [withDensity_sub_add_cancel]
  ¬∑ rw [withDensity_one']
  ¬∑ exact measurable_const
  ¬∑ exact (measurable_rnDerivAux _ _).ennreal_ofReal
  ¬∑ intro a
    filter_upwards [rnDerivAux_le_one h_le] with x hx
    simp only [ENNReal.ofReal_le_one]
    exact hx"
Mathlib/Data/Rat/Defs.lean,Rat.eq_iff_mul_eq_mul,eq_iff_mul_eq_mul,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  conv =>
    lhs
    rw [‚Üê num_divInt_den p, ‚Üê num_divInt_den q]
  apply Rat.divInt_eq_iff <;>
    ¬∑ rw [‚Üê Nat.cast_zero, Ne, Int.ofNat_inj]
      apply den_nz","error:  unknown constant 'Nat.cast_zero'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.27978
case z‚ÇÅ
q‚úù a b c p q : ‚Ñö
‚ä¢ ‚Üëp.den ‚â† 0
error:  unknown constant 'Nat.cast_zero'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.27980
case z‚ÇÇ
q‚úù a b c p q : ‚Ñö
‚ä¢ ‚Üëq.den ‚â† 0",theorem eq_iff_mul_eq_mul {p q : ‚Ñö} : p = q ‚Üî p.num * q.den = q.num * p.den ,":= by
  conv =>
    lhs
    rw [‚Üê num_divInt_den p, ‚Üê num_divInt_den q]
  apply Rat.divInt_eq_iff <;>
    ¬∑ rw [‚Üê Int.natCast_zero, Ne, Int.ofNat_inj]
      apply den_nz"
Mathlib/LinearAlgebra/LinearPMap.lean,LinearPMap.neg_graph,neg_graph,59c36da5834220170716566e80c451914feb876f,":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  ¬∑ rw [mem_graph_iff] at h
    rcases h with ‚ü®y, hy, h‚ü©
    rw [LinearPMap.neg_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id.def,
      LinearMap.neg_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y
    simp [hy, h]
  rw [Submodule.mem_map] at h
  rcases h with ‚ü®x', hx', h‚ü©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id.def, LinearMap.neg_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx'‚ä¢
  rcases hx' with ‚ü®y, hy, hx'‚ü©
  use y
  rw [‚Üê h.1, ‚Üê h.2]
  simp [hy, hx']","warning:  LinearPMap does not have a doc string
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.548521 ‚Üí ?m.548521
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.550936 ‚Üí ?m.550936","theorem neg_graph (f : E ‚Üí‚Çó.[R] F) :
    (-f).graph =
    f.graph.map ((LinearMap.id : E ‚Üí‚Çó[R] E).prodMap (-(LinearMap.id : F ‚Üí‚Çó[R] F))) ",":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  ¬∑ rw [mem_graph_iff] at h
    rcases h with ‚ü®y, hy, h‚ü©
    rw [LinearPMap.neg_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id,
      LinearMap.neg_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y, hy
  rw [Submodule.mem_map] at h
  rcases h with ‚ü®x', hx', h‚ü©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id, LinearMap.neg_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' ‚ä¢
  rcases hx' with ‚ü®y, hy, hx'‚ü©
  use y
  rw [‚Üê h.1, ‚Üê h.2]
  simp [hy, hx']"
Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean,MvPolynomial.weightedHomogeneousSubmodule_mul,weightedHomogeneousSubmodule_mul,9e34a191034458a56331f976ff7400a26407c888,":= by
  classical
  rw [Submodule.mul_le]
  intro œÜ hœÜ œà hœà c hc
  rw [coeff_mul] at hc
  obtain ‚ü®‚ü®d, e‚ü©, hde, H‚ü© := Finset.exists_ne_zero_of_sum_ne_zero hc
  have aux : coeff d œÜ ‚â† 0 ‚àß coeff e œà ‚â† 0 := by
    contrapose! H
    by_cases h : coeff d œÜ = 0 <;>
      simp_all only [Ne.def, not_false_iff, MulZeroClass.zero_mul, MulZeroClass.mul_zero]
  rw [‚Üê Finsupp.mem_antidiagonal.mp hde, ‚Üê hœÜ aux.1, ‚Üê hœà aux.2, map_add]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.29296 ‚Üí ?m.29296 ‚Üí Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.29928 ‚Üí ?m.29928 ‚Üí Prop
error:  unsolved goals
case neg
R : Type u_1
M : Type u_2
inst‚úù¬π : CommSemiring R
œÉ : Type u_3
inst‚úù : AddCommMonoid M
w : œÉ ‚Üí M
m n : M
œÜ : MvPolynomial œÉ R
hœÜ : œÜ ‚àà weightedHomogeneousSubmodule R w m
œà : MvPolynomial œÉ R
hœà : œà ‚àà weightedHomogeneousSubmodule R w n
c : œÉ ‚Üí‚ÇÄ ‚Ñï
hc : ‚àë x ‚àà antidiagonal c, coeff x.1 œÜ * coeff x.2 œà ‚â† 0
d e : œÉ ‚Üí‚ÇÄ ‚Ñï
hde : (d, e) ‚àà antidiagonal c
H : coeff d œÜ ‚â† 0 ‚Üí coeff e œà = 0
h : ¬¨coeff d œÜ = 0
‚ä¢ coeff d œÜ * coeff e œà = 0
error:  unknown constant 'Finsupp.mem_antidiagonal.mp'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.30084
case intro.mk.intro
R : Type u_1
M : Type u_2
inst‚úù¬π : CommSemiring R
œÉ : Type u_3
inst‚úù : AddCommMonoid M
w : œÉ ‚Üí M
m n : M
œÜ : MvPolynomial œÉ R
hœÜ : œÜ ‚àà weightedHomogeneousSubmodule R w m
œà : MvPolynomial œÉ R
hœà : œà ‚àà weightedHomogeneousSubmodule R w n
c : œÉ ‚Üí‚ÇÄ ‚Ñï
hc : ‚àë x ‚àà antidiagonal c, coeff x.1 œÜ * coeff x.2 œà ‚â† 0
d e : œÉ ‚Üí‚ÇÄ ‚Ñï
hde : (d, e) ‚àà antidiagonal c
H : coeff (d, e).1 œÜ * coeff (d, e).2 œà ‚â† 0
aux : coeff d œÜ ‚â† 0 ‚àß coeff e œà ‚â† 0
‚ä¢ (weightedDegree w) c = m + n","theorem weightedHomogeneousSubmodule_mul (w : œÉ ‚Üí M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ‚â§
      weightedHomogeneousSubmodule R w (m + n) ",":= by
  classical
  rw [Submodule.mul_le]
  intro œÜ hœÜ œà hœà c hc
  rw [coeff_mul] at hc
  obtain ‚ü®‚ü®d, e‚ü©, hde, H‚ü© := Finset.exists_ne_zero_of_sum_ne_zero hc
  have aux : coeff d œÜ ‚â† 0 ‚àß coeff e œà ‚â† 0 := by
    contrapose! H
    by_cases h : coeff d œÜ = 0 <;>
      simp_all only [Ne, not_false_iff, zero_mul, mul_zero]
  rw [‚Üê mem_antidiagonal.mp hde, ‚Üê hœÜ aux.1, ‚Üê hœà aux.2, map_add]"
Mathlib/AlgebraicGeometry/Pullbacks.lean,AlgebraicGeometry.Scheme.Pullback.gluedLift_p2,gluedLift_p2,8d72f500a692fb12cb594b710bb3ac6e29534e0d,":= by
  rw [‚Üê cancel_epi (ùí∞.pullbackCover s.fst).fromGlued]
  apply Multicoequalizer.hom_ext
  intro b
  erw [Multicoequalizer.inj_desc_assoc, Multicoequalizer.inj_desc_assoc]
  delta gluedLift
  simp_rw [‚Üê Category.assoc]
  rw [(ùí∞.pullbackCover s.fst).Œπ_glueMorphisms]
  simp_rw [Category.assoc]
  erw [Multicoequalizer.inj_desc, pullback.lift_snd]
  rw [pullbackSymmetry_hom_comp_snd_assoc]
  rfl","error:  unknown identifier 'Multicoequalizer.inj_desc_assoc'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.314526
case h
C : Type u
inst‚úù¬π : Category.{v, u} C
X Y Z : Scheme
ùí∞ : X.OpenCover
f : X ‚ü∂ Z
g : Y ‚ü∂ Z
inst‚úù : ‚àÄ (i : ùí∞.J), HasPullback (ùí∞.map i ‚â´ f) g
s : PullbackCone f g
b : (ùí∞.pullbackCover s.fst).gluedCover.diagram.R
‚ä¢ Multicoequalizer.œÄ (ùí∞.pullbackCover s.fst).gluedCover.diagram b ‚â´
      (ùí∞.pullbackCover s.fst).fromGlued ‚â´ gluedLift ùí∞ f g s ‚â´ p2 ùí∞ f g =
    Multicoequalizer.œÄ (ùí∞.pullbackCover s.fst).gluedCover.diagram b ‚â´ (ùí∞.pullbackCover s.fst).fromGlued ‚â´ s.snd",theorem gluedLift_p2 : gluedLift ùí∞ f g s ‚â´ p2 ùí∞ f g = s.snd ,":= by
  rw [‚Üê cancel_epi (ùí∞.pullbackCover s.fst).fromGlued]
  apply Multicoequalizer.hom_ext
  intro b
  simp_rw [OpenCover.fromGlued, Multicoequalizer.œÄ_desc_assoc, gluedLift, ‚Üê Category.assoc]
  simp_rw [(ùí∞.pullbackCover s.fst).Œπ_glueMorphisms]
  simp [p2, pullback.condition]"
Mathlib/RingTheory/ChainOfDivisors.lean,DivisorChain.eq_pow_second_of_chain_of_has_chain,eq_pow_second_of_chain_of_has_chain,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  classical
    obtain ‚ü®i, hi'‚ü© := element_of_chain_eq_pow_second_of_chain hn h‚ÇÅ (@fun r => h‚ÇÇ) (dvd_refl q) hq
    convert hi'
    refine' (Nat.lt_succ_iff.1 i.prop).antisymm' (Nat.le_of_succ_le_succ _)
    calc
      n + 1 = (Finset.univ : Finset (Fin (n + 1))).card := (Finset.card_fin _).symm
      _ = (Finset.univ.image c).card := (Finset.card_image_iff.mpr (h‚ÇÅ.injective.injOn _)).symm
      _ ‚â§ (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card :=
        (Finset.card_le_card ?_)
      _ ‚â§ (Finset.univ : Finset (Fin (i + 1))).card := Finset.card_image_le
      _ = i + 1 := Finset.card_fin _
    intro r hr
    obtain ‚ü®j, -, rfl‚ü© := Finset.mem_image.1 hr
    have := h‚ÇÇ.2 ‚ü®j, rfl‚ü©
    rw [hi'] at this
    have h := (dvd_prime_pow (show Prime (c 1) from ?_) i).1 this
    ¬∑ rcases h with ‚ü®u, hu, hu'‚ü©
      refine' Finset.mem_image.mpr ‚ü®u, Finset.mem_univ _, _‚ü©
      rw [associated_iff_eq] at hu'
      rw [Fin.val_cast_of_lt (Nat.lt_succ_of_le hu), hu']
    ¬∑ rw [‚Üê irreducible_iff_prime]
      exact second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq","error:  application type mismatch
  Finset.card_image_iff.mpr (Function.Injective.injOn (StrictMono.injective h‚ÇÅ) ?m.37447)
argument
  Function.Injective.injOn (StrictMono.injective h‚ÇÅ) ?m.37447
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Fin (n + 1)‚¶Ñ, x‚ÇÇ ‚àà ?m.37445 ‚Üí c ?m.37446 = c x‚ÇÇ ‚Üí ?m.37446 = x‚ÇÇ : Prop
but is expected to have type
  Set.InjOn ?m.37126 ‚Üë?m.37125 : Prop","theorem eq_pow_second_of_chain_of_has_chain {q : Associates M} {n : ‚Ñï} (hn : n ‚â† 0)
    {c : Fin (n + 1) ‚Üí Associates M} (h‚ÇÅ : StrictMono c)
    (h‚ÇÇ : ‚àÄ {r : Associates M}, r ‚â§ q ‚Üî ‚àÉ i, r = c i) (hq : q ‚â† 0) : q = c 1 ^ n ",":= by
  classical
    obtain ‚ü®i, hi'‚ü© := element_of_chain_eq_pow_second_of_chain hn h‚ÇÅ (@fun r => h‚ÇÇ) (dvd_refl q) hq
    convert hi'
    refine (Nat.lt_succ_iff.1 i.prop).antisymm' (Nat.le_of_succ_le_succ ?_)
    calc
      n + 1 = (Finset.univ : Finset (Fin (n + 1))).card := (Finset.card_fin _).symm
      _ = (Finset.univ.image c).card := (Finset.card_image_iff.mpr h‚ÇÅ.injective.injOn).symm
      _ ‚â§ (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card :=
        (Finset.card_le_card ?_)
      _ ‚â§ (Finset.univ : Finset (Fin (i + 1))).card := Finset.card_image_le
      _ = i + 1 := Finset.card_fin _
    intro r hr
    obtain ‚ü®j, -, rfl‚ü© := Finset.mem_image.1 hr
    have := h‚ÇÇ.2 ‚ü®j, rfl‚ü©
    rw [hi'] at this
    have h := (dvd_prime_pow (show Prime (c 1) from ?_) i).1 this
    ¬∑ rcases h with ‚ü®u, hu, hu'‚ü©
      refine Finset.mem_image.mpr ‚ü®u, Finset.mem_univ _, ?_‚ü©
      rw [associated_iff_eq] at hu'
      rw [Fin.val_cast_of_lt (Nat.lt_succ_of_le hu), hu']
    ¬∑ rw [‚Üê irreducible_iff_prime]
      exact second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a
  exact ‚ü®_, isGLB_ciInf (Real.bounded_iff_bddBelow_bddAbove.1 f.bounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b
  exact ‚ü®_, isLUB_ciSup (Real.bounded_iff_bddBelow_bddAbove.1 f.bounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.closed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x
    ¬∑ intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine' ‚ü®g + dg, fun y => _, funext hgf‚ü©
    ¬∑ have hay : a < (g + dg) y := by
        rcases(hg_mem y).1.eq_or_lt with (rfl | hlt)
        ¬∑ refine' (lt_add_iff_pos_right _).2 _
          calc
            0 < c - g y := sub_pos.2 hac
            _ = dg y := (dga rfl).symm
        ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      refine' ‚ü®x, hxy.le, _‚ü©
      cases' le_total c (g y) with hc hc
      ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
      ¬∑ calc
          g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
          _ = b := by rw [hsub, add_sub_cancel'_right]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.closed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x
  ¬∑ intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine' ‚ü®g - dg, fun y => _, funext hgf‚ü©
  ¬∑ have hyb : (g - dg) y < b := by
      rcases(hgb y).eq_or_lt with (rfl | hlt)
      ¬∑ refine' (sub_lt_self_iff _).2 _
        calc
          0 < g y - c := sub_pos.2 hcb
          _ = dg y := (dgb rfl).symm
      ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
    rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
    cases' lt_or_le c (g y) with hc hc
    ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
      ¬∑ refine' ‚ü®x, xu, _, hyxu.le‚ü©
        calc
          f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
      ¬∑ have hay : a < (g - dg) y := by
          calc
            a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
            _ < g y - (b - c) := (sub_lt_sub_right hc _)
            _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
        rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
        exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
    ¬∑ refine' ‚ü®xl y, xu, _, hyxu.le‚ü©
      simp [dg0 (Or.inr hc), hxl]","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case intro.intro.inr.intro.intro.intro
X : Type u_1
Y : Type u_2
inst‚úù¬≥ : TopologicalSpace X
inst‚úù¬≤ : TopologicalSpace Y
inst‚úù¬π : NormalSpace Y
inst‚úù : Nonempty X
f : X ‚Üí·µá ‚Ñù
e : X ‚Üí Y
he : ClosedEmbedding e
inhabited_h : Inhabited X
a : ‚Ñù
ha : IsGLB (range ‚áëf) a
b : ‚Ñù
hb : IsLUB (range ‚áëf) b
hmem : ‚àÄ (x : X), f x ‚àà Icc a b
hle : a ‚â§ b
hlt : a < b
c : ‚Ñù := (a + b) / 2
hac : a < c
hcb : c < b
hsub : c - a = b - c
g : Y ‚Üí·µá ‚Ñù
hg_mem : ‚àÄ (y : Y), g y ‚àà Icc a b
ha' : ¬¨‚àÉ x, f x = a
hd : Disjoint (range e ‚à™ ‚áëg ‚Åª¬π' Ici c) (‚áëg ‚Åª¬π' {a})
dg : Y ‚Üí·µá ‚Ñù
dg0 : EqOn (‚áëdg) (Function.const Y 0) (range e ‚à™ ‚áëg ‚Åª¬π' Ici c)
dga : EqOn (‚áëdg) (Function.const Y (c - a)) (‚áëg ‚Åª¬π' {a})
dgmem : ‚àÄ (x : Y), dg x ‚àà Icc 0 (c - a)
hgf : ‚àÄ (x : X), (g + dg) (e x) = f x
‚ä¢ ‚àÉ g, (‚àÄ (y : Y), ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß ‚áëg ‚àò e = ‚áëf
error:  unsolved goals
case intro.intro.inr.intro.intro
X : Type u_1
Y : Type u_2
inst‚úù¬≥ : TopologicalSpace X
inst‚úù¬≤ : TopologicalSpace Y
inst‚úù¬π : NormalSpace Y
inst‚úù : Nonempty X
f : X ‚Üí·µá ‚Ñù
e : X ‚Üí Y
he : ClosedEmbedding e
inhabited_h : Inhabited X
a : ‚Ñù
ha : IsGLB (range ‚áëf) a
b : ‚Ñù
hb : IsLUB (range ‚áëf) b
hmem : ‚àÄ (x : X), f x ‚àà Icc a b
hle : a ‚â§ b
hlt : a < b
c : ‚Ñù := (a + b) / 2
hac : a < c
hcb : c < b
hsub : c - a = b - c
g : Y ‚Üí·µá ‚Ñù
hg_mem : ‚àÄ (y : Y), ‚àÉ x, g y ‚àà Icc (f x) b
hgf : ‚áëg ‚àò e = ‚áëf
‚ä¢ ‚àÉ g, (‚àÄ (y : Y), ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß ‚áëg ‚àò e = ‚áëf","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/Analysis/Normed/Group/Basic.lean,squeeze_one_norm',squeeze_one_norm',f61e4ec87e55b6c47e60c339a947f9aa6bcc6e6d,":=
  tendsto_one_iff_norm_tendsto_one.2 <|
    squeeze_zero' (eventually_of_forall fun _n => norm_nonneg' _) h h'","warning:  @norm does not have a doc string
warning:  @nnnorm does not have a doc string
error:  unknown identifier 'tendsto_one_iff_norm_tendsto_one'","theorem squeeze_one_norm' {f : Œ± ‚Üí E} {a : Œ± ‚Üí ‚Ñù} {t‚ÇÄ : Filter Œ±} (h : ‚àÄ·∂† n in t‚ÇÄ, ‚Äñf n‚Äñ ‚â§ a n)
    (h' : Tendsto a t‚ÇÄ (ùìù 0)) : Tendsto f t‚ÇÄ (ùìù 1) ",":=
  tendsto_one_iff_norm_tendsto_zero.2 <|
    squeeze_zero' (eventually_of_forall fun _n => norm_nonneg' _) h h'"
Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean,CategoryTheory.MorphismProperty.LeftFraction.map_hom_ofInv_id,map_hom_ofInv_id,9072ff84a0d139a344bf9eed4a00c4cd27596c79,":= by
  have := hL _ hs","error:  unsolved goals
C : Type u_1
D : Type u_2
inst‚úù¬π : Category.{u_3, u_1} C
inst‚úù : Category.{u_4, u_2} D
W : MorphismProperty C
X Y : C
s : Y ‚ü∂ X
hs : W s
L : C ‚•§ D
hL : W.IsInvertedBy L
this : IsIso (L.map s)
‚ä¢ L.map s ‚â´ (ofInv s hs).map L hL = ùüô (L.obj Y)
error:  unsolved goals
C : Type u_1
D : Type u_2
inst‚úù¬π : Category.{u_3, u_1} C
inst‚úù : Category.{u_4, u_2} D
W : MorphismProperty C
X Y : C
s : Y ‚ü∂ X
hs : W s
L : C ‚•§ D
hL : W.IsInvertedBy L
this : IsIso (L.map s)
‚ä¢ L.map s ‚â´ (ofInv s hs).map L hL = ùüô (L.obj Y)","lemma map_hom_ofInv_id (s : Y ‚ü∂ X) (hs : W s) (L : C ‚•§ D) (hL : W.IsInvertedBy L) :
    L.map s ‚â´ (ofInv s hs).map L hL = ùüô _ ",":= by
  letI := hL _ hs
  simp [map]"
Mathlib/MeasureTheory/Integral/PeakFunction.lean,tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux,tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine Metric.tendsto_nhds.2 fun Œµ Œµpos => ?_
  obtain ‚ü®Œ¥, hŒ¥, Œ¥pos, Œ¥one‚ü© : ‚àÉ Œ¥, (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ < Œµ ‚àß 0 < Œ¥ ‚àß Œ¥ < 1:= by
    have A :
      Tendsto (fun Œ¥ => (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥) (ùìù[>] 0)
        (ùìù ((0 * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * 0)) := by
      apply Tendsto.mono_left _ nhdsWithin_le_nhds
      exact (tendsto_id.mul tendsto_const_nhds).add (tendsto_id.const_mul _)
    rw [zero_mul, zero_add, mul_zero] at A
    have : Ioo (0 : ‚Ñù) 1 ‚àà ùìù[>] 0 := Ioo_mem_nhdsWithin_Ioi ‚ü®le_rfl, zero_lt_one‚ü©
    rcases (((tendsto_order.1 A).2 Œµ Œµpos).and this).exists with ‚ü®Œ¥, hŒ¥, h'Œ¥‚ü©
    exact ‚ü®Œ¥, hŒ¥, h'Œ¥.1, h'Œ¥.2‚ü©
  suffices ‚àÄ·∂† i in l, ‚Äñ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ by
    filter_upwards [this] with i hi
    simp only [dist_zero_right]
    exact hi.trans_lt hŒ¥
  obtain ‚ü®u, u_open, x‚ÇÄu, ut, hu‚ü© :
      ‚àÉ u, IsOpen u ‚àß x‚ÇÄ ‚àà u ‚àß s ‚à© u ‚äÜ t ‚àß ‚àÄ x ‚àà u ‚à© s, g x ‚àà ball 0 Œ¥ := by
    rcases mem_nhdsWithin.1 (Filter.inter_mem h'ts (hcg (ball_mem_nhds _ Œ¥pos)))
      with ‚ü®u, u_open, x‚ÇÄu, hu‚ü©
    refine ‚ü®u, u_open, x‚ÇÄu, ?_, hu.trans (inter_subset_right _ _)‚ü©
    rw [inter_comm]
    exact hu.trans (inter_subset_left _ _)
  filter_upwards [tendstoUniformlyOn_iff.1 (hlœÜ u u_open x‚ÇÄu) Œ¥ Œ¥pos,
    (tendsto_order.1 (tendsto_iff_norm_sub_tendsto_zero.1 hiœÜ)).2 Œ¥ Œ¥pos, hnœÜ,
    integrableOn_peak_smul_of_integrableOn_of_tendsto hs h'ts hlœÜ hiœÜ h'iœÜ hmg hcg]
    with i hi h'i hœÜpos h''i
  have I : IntegrableOn (œÜ i) t Œº := by
    apply Integrable.of_integral_ne_zero (fun h ‚Ü¶ ?_)
    simp [h] at h'i
    linarith
  have B : ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ 2 * Œ¥ :=
    calc
      ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ ‚à´ x in s ‚à© u, ‚ÄñœÜ i x ‚Ä¢ g x‚Äñ ‚àÇŒº :=
        norm_integral_le_integral_norm _
      _ ‚â§ ‚à´ x in s ‚à© u, ‚ÄñœÜ i x‚Äñ * Œ¥ ‚àÇŒº := by
        refine setIntegral_mono_on ?_ ?_ (hs.inter u_open.measurableSet) fun x hx =?> _
        ¬∑ exact IntegrableOn.mono_set h''i.norm (inter_subset_left _ _)
        ¬∑ exact IntegrableOn.mono_set (I.norm.mul_const _) ut
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
        rw [inter_comm] at hu
        exact (mem_ball_zero_iff.1 (hu x hx)).le
      _ ‚â§ ‚à´ x in t, ‚ÄñœÜ i x‚Äñ * Œ¥ ‚àÇŒº := by
        apply setIntegral_mono_set
        ¬∑ exact I.norm.mul_const _
        ¬∑ exact eventually_of_forall fun x => mul_nonneg (norm_nonneg _) Œ¥pos.le
        ¬∑ exact eventually_of_forall ut
      _ = ‚à´ x in t, œÜ i x * Œ¥ ‚àÇŒº := by
        apply setIntegral_congr ht fun x hx => ?_
        rw [Real.norm_of_nonneg (hœÜpos _ (hts hx))]
      _ = (‚à´ x in t, œÜ i x ‚àÇŒº) * Œ¥ := by rw [integral_mul_right]
      _ ‚â§ 2 * Œ¥ := by gcongr; linarith [(le_abs_self _).trans h'i.le]
  have C : ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº :=
    calc
      ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ ‚à´ x in s \ u, ‚ÄñœÜ i x ‚Ä¢ g x‚Äñ ‚àÇŒº :=
        norm_integral_le_integral_norm _
      _ ‚â§ ‚à´ x in s \ u, Œ¥ * ‚Äñg x‚Äñ ‚àÇŒº := by
        refine setIntegral_mono_on ?_ ?_ (hs.diff u_open.measurableSet) fun x hx => ?_
        ¬∑ exact IntegrableOn.mono_set h''i.norm (diff_subset _ _)
        ¬∑ exact IntegrableOn.mono_set (hmg.norm.const_mul _) (diff_subset _ _)
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le
      _ ‚â§ Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº := by
        rw [integral_mul_left]
        apply mul_le_mul_of_nonneg_left (setIntegral_mono_set hmg.norm _ _) Œ¥pos.le
        ¬∑ filter_upwards with x using norm_nonneg _
        ¬∑ filter_upwards using diff_subset s u
  calc
    ‚Äñ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ =
      ‚Äñ(‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº) + ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ := by
      conv_lhs => rw [‚Üê diff_union_inter s u]
      rw [integral_union disjoint_sdiff_inter (hs.inter u_open.measurableSet)
          (h''i.mono_set (diff_subset _ _)) (h''i.mono_set (inter_subset_left _ _))]
    _ ‚â§ ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ + ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ := add_le_add C B","error:  unexpected token '='; expected '‚Ü¶', '=>'
error:  unsolved goals
case refine_1
Œ± : Type u_1
E : Type u_2
Œπ : Type u_3
hm : MeasurableSpace Œ±
Œº : Measure Œ±
inst‚úù‚Å¥ : TopologicalSpace Œ±
inst‚úù¬≥ : BorelSpace Œ±
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
g : Œ± ‚Üí E
l : Filter Œπ
x‚ÇÄ : Œ±
s t : Set Œ±
œÜ : Œπ ‚Üí Œ± ‚Üí ‚Ñù
a : E
inst‚úù : CompleteSpace E
hs : MeasurableSet s
ht : MeasurableSet t
hts : t ‚äÜ s
h'ts : t ‚àà ùìù[s] x‚ÇÄ
hnœÜ : ‚àÄ·∂† (i : Œπ) in l, ‚àÄ x ‚àà s, 0 ‚â§ œÜ i x
hlœÜ : ‚àÄ (u : Set Œ±), IsOpen u ‚Üí x‚ÇÄ ‚àà u ‚Üí TendstoUniformlyOn œÜ 0 l (s \ u)
hiœÜ : Tendsto (fun i ‚Ü¶ ‚à´ (x : Œ±) in t, œÜ i x ‚àÇŒº) l (ùìù 1)
h'iœÜ : ‚àÄ·∂† (i : Œπ) in l, AEStronglyMeasurable (œÜ i) (Œº.restrict s)
hmg : IntegrableOn g s Œº
hcg : Tendsto g (ùìù[s] x‚ÇÄ) (ùìù 0)
Œµ : ‚Ñù
Œµpos : Œµ > 0
Œ¥ : ‚Ñù
hŒ¥ : Œ¥ * ‚à´ (x : Œ±) in s, ‚Äñg x‚Äñ ‚àÇŒº + 2 * Œ¥ < Œµ
Œ¥pos : 0 < Œ¥
Œ¥one : Œ¥ < 1
u : Set Œ±
u_open : IsOpen u
x‚ÇÄu : x‚ÇÄ ‚àà u
ut : s ‚à© u ‚äÜ t
hu : ‚àÄ x ‚àà u ‚à© s, g x ‚àà ball 0 Œ¥
i : Œπ
hi : ‚àÄ x ‚àà s \ u, dist (0 x) (œÜ i x) < Œ¥
h'i : ‚Äñ‚à´ (x : Œ±) in t, œÜ i x ‚àÇŒº - 1‚Äñ < Œ¥
hœÜpos : ‚àÄ x ‚àà s, 0 ‚â§ œÜ i x
h''i : IntegrableOn (fun x ‚Ü¶ œÜ i x ‚Ä¢ g x) s Œº
I : IntegrableOn (œÜ i) t Œº
‚ä¢ IntegrableOn (fun x ‚Ü¶ ‚ÄñœÜ i x ‚Ä¢ g x‚Äñ) (s ‚à© u) Œº

case refine_2
Œ± : Type u_1
E : Type u_2
Œπ : Type u_3
hm : MeasurableSpace Œ±
Œº : Measure Œ±
inst‚úù‚Å¥ : TopologicalSpace Œ±
inst‚úù¬≥ : BorelSpace Œ±
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
g : Œ± ‚Üí E
l : Filter Œπ
x‚ÇÄ : Œ±
s t : Set Œ±
œÜ : Œπ ‚Üí Œ± ‚Üí ‚Ñù
a : E
inst‚úù : CompleteSpace E
hs : MeasurableSet s
ht : MeasurableSet t
hts : t ‚äÜ s
h'ts : t ‚àà ùìù[s] x‚ÇÄ
hnœÜ : ‚àÄ·∂† (i : Œπ) in l, ‚àÄ x ‚àà s, 0 ‚â§ œÜ i x
hlœÜ : ‚àÄ (u : Set Œ±), IsOpen u ‚Üí x‚ÇÄ ‚àà u ‚Üí TendstoUniformlyOn œÜ 0 l (s \ u)
hiœÜ : Tendsto (fun i ‚Ü¶ ‚à´ (x : Œ±) in t, œÜ i x ‚àÇŒº) l (ùìù 1)
h'iœÜ : ‚àÄ·∂† (i : Œπ) in l, AEStronglyMeasurable (œÜ i) (Œº.restrict s)
hmg : IntegrableOn g s Œº
hcg : Tendsto g (ùìù[s] x‚ÇÄ) (ùìù 0)
Œµ : ‚Ñù
Œµpos : Œµ > 0
Œ¥ : ‚Ñù
hŒ¥ : Œ¥ * ‚à´ (x : Œ±) in s, ‚Äñg x‚Äñ ‚àÇŒº + 2 * Œ¥ < Œµ
Œ¥pos : 0 < Œ¥
Œ¥one : Œ¥ < 1
u : Set Œ±
u_open : IsOpen u
x‚ÇÄu : x‚ÇÄ ‚àà u
ut : s ‚à© u ‚äÜ t
hu : ‚àÄ x ‚àà u ‚à© s, g x ‚àà ball 0 Œ¥
i : Œπ
hi : ‚àÄ x ‚àà s \ u, dist (0 x) (œÜ i x) < Œ¥
h'i : ‚Äñ‚à´ (x : Œ±) in t, œÜ i x ‚àÇŒº - 1‚Äñ < Œ¥
hœÜpos : ‚àÄ x ‚àà s, 0 ‚â§ œÜ i x
h''i : IntegrableOn (fun x ‚Ü¶ œÜ i x ‚Ä¢ g x) s Œº
I : IntegrableOn (œÜ i) t Œº
‚ä¢ IntegrableOn (fun x ‚Ü¶ ‚ÄñœÜ i x‚Äñ * Œ¥) (s ‚à© u) Œº
error:  unsolved goals
case h
Œ± : Type u_1
E : Type u_2
Œπ : Type u_3
hm : MeasurableSpace Œ±
Œº : Measure Œ±
inst‚úù‚Å¥ : TopologicalSpace Œ±
inst‚úù¬≥ : BorelSpace Œ±
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
g : Œ± ‚Üí E
l : Filter Œπ
x‚ÇÄ : Œ±
s t : Set Œ±
œÜ : Œπ ‚Üí Œ± ‚Üí ‚Ñù
a : E
inst‚úù : CompleteSpace E
hs : MeasurableSet s
ht : MeasurableSet t
hts : t ‚äÜ s
h'ts : t ‚àà ùìù[s] x‚ÇÄ
hnœÜ : ‚àÄ·∂† (i : Œπ) in l, ‚àÄ x ‚àà s, 0 ‚â§ œÜ i x
hlœÜ : ‚àÄ (u : Set Œ±), IsOpen u ‚Üí x‚ÇÄ ‚àà u ‚Üí TendstoUniformlyOn œÜ 0 l (s \ u)
hiœÜ : Tendsto (fun i ‚Ü¶ ‚à´ (x : Œ±) in t, œÜ i x ‚àÇŒº) l (ùìù 1)
h'iœÜ : ‚àÄ·∂† (i : Œπ) in l, AEStronglyMeasurable (œÜ i) (Œº.restrict s)
hmg : IntegrableOn g s Œº
hcg : Tendsto g (ùìù[s] x‚ÇÄ) (ùìù 0)
Œµ : ‚Ñù
Œµpos : Œµ > 0
Œ¥ : ‚Ñù
hŒ¥ : Œ¥ * ‚à´ (x : Œ±) in s, ‚Äñg x‚Äñ ‚àÇŒº + 2 * Œ¥ < Œµ
Œ¥pos : 0 < Œ¥
Œ¥one : Œ¥ < 1
u : Set Œ±
u_open : IsOpen u
x‚ÇÄu : x‚ÇÄ ‚àà u
ut : s ‚à© u ‚äÜ t
hu : ‚àÄ x ‚àà u ‚à© s, g x ‚àà ball 0 Œ¥
i : Œπ
hi : ‚àÄ x ‚àà s \ u, dist (0 x) (œÜ i x) < Œ¥
h'i : ‚Äñ‚à´ (x : Œ±) in t, œÜ i x ‚àÇŒº - 1‚Äñ < Œ¥
hœÜpos : ‚àÄ x ‚àà s, 0 ‚â§ œÜ i x
h''i : IntegrableOn (fun x ‚Ü¶ œÜ i x ‚Ä¢ g x) s Œº
I : IntegrableOn (œÜ i) t Œº
B : ‚Äñ‚à´ (x : Œ±) in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ 2 * Œ¥
‚ä¢ ‚Äñ‚à´ (x : Œ±) in s, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ Œ¥ * ‚à´ (x : Œ±) in s, ‚Äñg x‚Äñ ‚àÇŒº + 2 * Œ¥","theorem tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux
    (hs : MeasurableSet s) (ht : MeasurableSet t) (hts : t ‚äÜ s) (h'ts : t ‚àà ùìù[s] x‚ÇÄ)
    (hnœÜ : ‚àÄ·∂† i in l, ‚àÄ x ‚àà s, 0 ‚â§ œÜ i x)
    (hlœÜ : ‚àÄ u : Set Œ±, IsOpen u ‚Üí x‚ÇÄ ‚àà u ‚Üí TendstoUniformlyOn œÜ 0 l (s \ u))
    (hiœÜ : Tendsto (fun i ‚Ü¶ ‚à´ x in t, œÜ i x ‚àÇŒº) l (ùìù 1))
    (h'iœÜ : ‚àÄ·∂† i in l, AEStronglyMeasurable (œÜ i) (Œº.restrict s))
    (hmg : IntegrableOn g s Œº) (hcg : Tendsto g (ùìù[s] x‚ÇÄ) (ùìù 0)) :
    Tendsto (fun i : Œπ => ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº) l (ùìù 0) ",":= by
  refine Metric.tendsto_nhds.2 fun Œµ Œµpos => ?_
  obtain ‚ü®Œ¥, hŒ¥, Œ¥pos, Œ¥one‚ü© : ‚àÉ Œ¥, (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ < Œµ ‚àß 0 < Œ¥ ‚àß Œ¥ < 1:= by
    have A :
      Tendsto (fun Œ¥ => (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥) (ùìù[>] 0)
        (ùìù ((0 * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * 0)) := by
      apply Tendsto.mono_left _ nhdsWithin_le_nhds
      exact (tendsto_id.mul tendsto_const_nhds).add (tendsto_id.const_mul _)
    rw [zero_mul, zero_add, mul_zero] at A
    have : Ioo (0 : ‚Ñù) 1 ‚àà ùìù[>] 0 := Ioo_mem_nhdsWithin_Ioi ‚ü®le_rfl, zero_lt_one‚ü©
    rcases (((tendsto_order.1 A).2 Œµ Œµpos).and this).exists with ‚ü®Œ¥, hŒ¥, h'Œ¥‚ü©
    exact ‚ü®Œ¥, hŒ¥, h'Œ¥.1, h'Œ¥.2‚ü©
  suffices ‚àÄ·∂† i in l, ‚Äñ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ by
    filter_upwards [this] with i hi
    simp only [dist_zero_right]
    exact hi.trans_lt hŒ¥
  obtain ‚ü®u, u_open, x‚ÇÄu, ut, hu‚ü© :
      ‚àÉ u, IsOpen u ‚àß x‚ÇÄ ‚àà u ‚àß s ‚à© u ‚äÜ t ‚àß ‚àÄ x ‚àà u ‚à© s, g x ‚àà ball 0 Œ¥ := by
    rcases mem_nhdsWithin.1 (Filter.inter_mem h'ts (hcg (ball_mem_nhds _ Œ¥pos)))
      with ‚ü®u, u_open, x‚ÇÄu, hu‚ü©
    refine ‚ü®u, u_open, x‚ÇÄu, ?_, hu.trans inter_subset_right‚ü©
    rw [inter_comm]
    exact hu.trans inter_subset_left
  filter_upwards [tendstoUniformlyOn_iff.1 (hlœÜ u u_open x‚ÇÄu) Œ¥ Œ¥pos,
    (tendsto_order.1 (tendsto_iff_norm_sub_tendsto_zero.1 hiœÜ)).2 Œ¥ Œ¥pos, hnœÜ,
    integrableOn_peak_smul_of_integrableOn_of_tendsto hs h'ts hlœÜ hiœÜ h'iœÜ hmg hcg]
    with i hi h'i hœÜpos h''i
  have I : IntegrableOn (œÜ i) t Œº := by
    apply Integrable.of_integral_ne_zero (fun h ‚Ü¶ ?_)
    simp [h] at h'i
    linarith
  have B : ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ 2 * Œ¥ :=
    calc
      ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ ‚à´ x in s ‚à© u, ‚ÄñœÜ i x ‚Ä¢ g x‚Äñ ‚àÇŒº :=
        norm_integral_le_integral_norm _
      _ ‚â§ ‚à´ x in s ‚à© u, ‚ÄñœÜ i x‚Äñ * Œ¥ ‚àÇŒº := by
        refine setIntegral_mono_on ?_ ?_ (hs.inter u_open.measurableSet) fun x hx => ?_
        ¬∑ exact IntegrableOn.mono_set h''i.norm inter_subset_left
        ¬∑ exact IntegrableOn.mono_set (I.norm.mul_const _) ut
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
        rw [inter_comm] at hu
        exact (mem_ball_zero_iff.1 (hu x hx)).le
      _ ‚â§ ‚à´ x in t, ‚ÄñœÜ i x‚Äñ * Œ¥ ‚àÇŒº := by
        apply setIntegral_mono_set
        ¬∑ exact I.norm.mul_const _
        ¬∑ exact eventually_of_forall fun x => mul_nonneg (norm_nonneg _) Œ¥pos.le
        ¬∑ exact eventually_of_forall ut
      _ = ‚à´ x in t, œÜ i x * Œ¥ ‚àÇŒº := by
        apply setIntegral_congr ht fun x hx => ?_
        rw [Real.norm_of_nonneg (hœÜpos _ (hts hx))]
      _ = (‚à´ x in t, œÜ i x ‚àÇŒº) * Œ¥ := by rw [integral_mul_right]
      _ ‚â§ 2 * Œ¥ := by gcongr; linarith [(le_abs_self _).trans h'i.le]
  have C : ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº :=
    calc
      ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ ‚à´ x in s \ u, ‚ÄñœÜ i x ‚Ä¢ g x‚Äñ ‚àÇŒº :=
        norm_integral_le_integral_norm _
      _ ‚â§ ‚à´ x in s \ u, Œ¥ * ‚Äñg x‚Äñ ‚àÇŒº := by
        refine setIntegral_mono_on ?_ ?_ (hs.diff u_open.measurableSet) fun x hx => ?_
        ¬∑ exact IntegrableOn.mono_set h''i.norm diff_subset
        ¬∑ exact IntegrableOn.mono_set (hmg.norm.const_mul _) diff_subset
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le
      _ ‚â§ Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº := by
        rw [integral_mul_left]
        apply mul_le_mul_of_nonneg_left (setIntegral_mono_set hmg.norm _ _) Œ¥pos.le
        ¬∑ filter_upwards with x using norm_nonneg _
        ¬∑ filter_upwards using diff_subset (s := s) (t := u)
  calc
    ‚Äñ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ =
      ‚Äñ(‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº) + ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ := by
      conv_lhs => rw [‚Üê diff_union_inter s u]
      rw [integral_union disjoint_sdiff_inter (hs.inter u_open.measurableSet)
          (h''i.mono_set diff_subset) (h''i.mono_set inter_subset_left)]
    _ ‚â§ ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ + ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ := add_le_add C B"
Mathlib/CategoryTheory/Sites/Coherent/Equivalence.lean,CategoryTheory.Equivalence.preregular,preregular,49c707109b4578785aa3d8d5312404ee078b1999,":=
  reflects_preregular e.inverse","error:  unknown identifier 'reflects_preregular'
error:  invalid field notation, function 'CategoryTheory.Equivalence.preregular' does not have argument with type (CategoryTheory.Equivalence ...) that can be used, it must be explicit or implicit with a unique name
error:  function expected at
  preregular
term has type
  Preregular ?m.12078
error:  failed to synthesize
  Preregular D
use `set_option diagnostics true` to get diagnostic information
error:  invalid field notation, function 'CategoryTheory.Equivalence.preregular' does not have argument with type (CategoryTheory.Equivalence ...) that can be used, it must be explicit or implicit with a unique name
error:  failed to synthesize
  Preregular D
use `set_option diagnostics true` to get diagnostic information
error:  invalid field notation, function 'CategoryTheory.Equivalence.preregular' does not have argument with type (CategoryTheory.Equivalence ...) that can be used, it must be explicit or implicit with a unique name
error:  failed to synthesize
  Preregular D
use `set_option diagnostics true` to get diagnostic information
error:  typeclass instance problem is stuck, it is often due to metavariables
  Category.{u_4, u_4} ?m.22495",theorem preregular : Preregular D ,:= e.inverse.reflects_preregular
Mathlib/LinearAlgebra/Dimension/Finite.lean,rank_eq_zero_iff,rank_eq_zero_iff,b764e03d48c53e3f744636472c9d205d33ffdb4c,":= by
  nontriviality R
  constructor
  ¬∑ contrapose!
    rintro ‚ü®x, hx‚ü©
    rw [‚Üê Cardinal.one_le_iff_ne_zero]
    have : LinearIndependent R (fun _ : Unit ‚Ü¶ x)
    ¬∑ exact linearIndependent_iff.mpr (fun l hl ‚Ü¶ Finsupp.unique_ext <| not_not.mp fun H ‚Ü¶
        hx _ H ((Finsupp.total_unique _ _ _).symm.trans hl))
    simpa using this.cardinal_lift_le_rank
  ¬∑ intro h
    rw [‚Üê le_zero_iff, Module.rank_def]
    apply ciSup_le'
    intro ‚ü®s, hs‚ü©
    rw [nonpos_iff_eq_zero, Cardinal.mk_eq_zero_iff, ‚Üê not_nonempty_iff]
    rintro ‚ü®i : s‚ü©
    obtain ‚ü®a, ha, ha'‚ü© := h i
    apply ha
    simpa using DFunLike.congr_fun (linearIndependent_iff.mp hs (Finsupp.single i a) (by simpa)) i","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case mp.intro
R : Type u
M M‚ÇÅ : Type v
M' : Type v'
Œπ : Type w
inst‚úù‚Å∂ : Ring R
inst‚úù‚Åµ : AddCommGroup M
inst‚úù‚Å¥ : AddCommGroup M'
inst‚úù¬≥ : AddCommGroup M‚ÇÅ
inst‚úù¬≤ : Module R M
inst‚úù¬π : Module R M'
inst‚úù : Module R M‚ÇÅ
a‚úù : Nontrivial R
x : M
hx : ‚àÄ (a : R), a ‚â† 0 ‚Üí a ‚Ä¢ x ‚â† 0
this : LinearIndependent R fun x_1 ‚Ü¶ x
‚ä¢ 1 ‚â§ Module.rank R M
error:  unsolved goals
case mpr
R : Type u
M M‚ÇÅ : Type v
M' : Type v'
Œπ : Type w
inst‚úù‚Å∂ : Ring R
inst‚úù‚Åµ : AddCommGroup M
inst‚úù‚Å¥ : AddCommGroup M'
inst‚úù¬≥ : AddCommGroup M‚ÇÅ
inst‚úù¬≤ : Module R M
inst‚úù¬π : Module R M'
inst‚úù : Module R M‚ÇÅ
a‚úù : Nontrivial R
‚ä¢ (‚àÄ (x : M), ‚àÉ a, a ‚â† 0 ‚àß a ‚Ä¢ x = 0) ‚Üí Module.rank R M = 0","lemma rank_eq_zero_iff :
    Module.rank R M = 0 ‚Üî ‚àÄ x : M, ‚àÉ a : R, a ‚â† 0 ‚àß a ‚Ä¢ x = 0 ",":= by
  nontriviality R
  constructor
  ¬∑ contrapose!
    rintro ‚ü®x, hx‚ü©
    rw [‚Üê Cardinal.one_le_iff_ne_zero]
    have : LinearIndependent R (fun _ : Unit ‚Ü¶ x) :=
      linearIndependent_iff.mpr (fun l hl ‚Ü¶ Finsupp.unique_ext <| not_not.mp fun H ‚Ü¶
        hx _ H ((Finsupp.total_unique _ _ _).symm.trans hl))
    simpa using this.cardinal_lift_le_rank
  ¬∑ intro h
    rw [‚Üê le_zero_iff, Module.rank_def]
    apply ciSup_le'
    intro ‚ü®s, hs‚ü©
    rw [nonpos_iff_eq_zero, Cardinal.mk_eq_zero_iff, ‚Üê not_nonempty_iff]
    rintro ‚ü®i : s‚ü©
    obtain ‚ü®a, ha, ha'‚ü© := h i
    apply ha
    simpa using DFunLike.congr_fun (linearIndependent_iff.mp hs (Finsupp.single i a) (by simpa)) i"
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow,discr_prime_pow,8802cc5585f54b80097a016895ed9e54bf69d452,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2
      ¬∑ rwa [Ne.def, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by linarith)] at this
      exact absurd (pow_eq_zero h) this","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case e_a.inr
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2‚úù : p = 2 ‚Üí k ‚â† 0
hp2 : ‚Üëp ‚â† 2
‚ä¢ (-1) ^ (‚Üëp ^ k * (‚Üëp - 1) * (‚Üëp ^ k * (‚Üëp - 1) - 1) / 2) = (-1) ^ (‚Üëp ^ k * (‚Üëp - 1) / 2)
error:  unsolved goals
case e_a
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2 : p = 2 ‚Üí k ‚â† 0
‚ä¢ (Algebra.norm K) ((aeval Œ∂) (derivative (cyclotomic (‚Üëp ^ (k + 1)) K))) = ‚Üë‚Üëp ^ (‚Üëp ^ k * ((‚Üëp - 1) * (k + 1) - 1))","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ‚Ñï).Prime]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1)) : ‚Ñï) K))
    (hk : p ^ (k + 1) ‚â† 2) : discr K (hŒ∂.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : ‚Ñï).totient / 2) * p ^ ((p : ‚Ñï) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this"
Mathlib/LinearAlgebra/TensorProduct/Vanishing.lean,TensorProduct.vanishesTrivially_of_sum_tmul_eq_zero,vanishesTrivially_of_sum_tmul_eq_zero,e74b23a7367e1b915c3b087a017a86a703f00b48,":= by
  set G : (Œπ ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] M := Finsupp.total Œπ M R m with hG
  have G_basis_eq (i : Œπ) : G (Finsupp.single i 1) = m i := by simp [hG, toModule_lof]
  have G_surjective : Surjective G := by
    apply LinearMap.range_eq_top.mp
    apply top_le_iff.mp
    rw [‚Üê hm]
    apply Submodule.span_le.mpr
    rintro _ ‚ü®i, rfl‚ü©
    use Finsupp.single i 1, G_basis_eq i
  set en : (Œπ ‚Üí‚ÇÄ R) ‚äó[R] N := ‚àë i, Finsupp.single i 1 ‚äó‚Çú n i with hen
  have en_mem_ker : en ‚àà ker (rTensor N G) := by simp [hen, G_basis_eq, hmn]
  have exact_ker_subtype : Exact (ker G).subtype G := G.exact_subtype_ker_map
  have exact_rTensor_ker_subtype : Exact (rTensor N (ker G).subtype) (rTensor N G) :=
    rTensor_exact N exact_ker_subtype G_surjective
  have en_mem_range : en ‚àà range (rTensor N (ker G).subtype) :=
    exact_rTensor_ker_subtype.linearMap_ker_eq ‚ñ∏ en_mem_ker
  obtain ‚ü®kn, hkn‚ü© := en_mem_range
  obtain ‚ü®ma, rfl‚ü© := exists_finset kn
  use ‚Üë‚Üëma, FinsetCoe.fintype ma
  use fun i ‚ü®x, _‚ü© ‚Ü¶ (x.1 : Œπ ‚Üí‚ÇÄ R) i
  use fun ‚ü®x, _‚ü© ‚Ü¶ x.2
  constructor
  ¬∑ intro i
    apply_fun finsuppScalarLeft R N Œπ at hkn
    apply_fun (¬∑ i) at hkn
    symm at hkn
    simp only [map_sum, finsuppScalarLeft_apply_tmul, zero_smul, Finsupp.single_zero,
      Finsupp.sum_single_index, one_smul, Finsupp.finset_sum_apply, Finsupp.single_apply,
      Finset.sum_ite_eq', Finset.mem_univ, ‚ÜìreduceIte, rTensor_tmul, coeSubtype, Finsupp.sum_apply,
      Finsupp.sum_ite_eq', Finsupp.mem_support_iff, ne_eq, ite_not, en] at hkn
    simp only [Finset.univ_eq_attach, Finset.sum_attach ma (fun x ‚Ü¶ (x.1 : Œπ ‚Üí‚ÇÄ R) i ‚Ä¢ x.2)]
    convert hkn using 2 with x _
    split
    ¬∑ next h'x => rw [h'x, zero_smul]
    ¬∑ rfl
  ¬∑ rintro ‚ü®‚ü®‚ü®k, hk‚ü©, _‚ü©, _‚ü©
    simpa only [hG, Finsupp.total_apply, zero_smul, implies_true, Finsupp.sum_fintype] using
      mem_ker.mp hk","error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'vanishesTrivially_of_sum_tmul_eq_zero'
error:  unknown identifier 'vanishesTrivially_of_sum_tmul_eq_zero'","theorem vanishesTrivially_of_sum_tmul_eq_zero (hm : Submodule.span R (Set.range m) = ‚ä§)
    (hmn : ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N)) : VanishesTrivially R m n ",":= by
  set G : (Œπ ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] M := Finsupp.total Œπ M R m with hG
  have G_basis_eq (i : Œπ) : G (Finsupp.single i 1) = m i := by simp [hG, toModule_lof]
  have G_surjective : Surjective G := by
    apply LinearMap.range_eq_top.mp
    apply top_le_iff.mp
    rw [‚Üê hm]
    apply Submodule.span_le.mpr
    rintro _ ‚ü®i, rfl‚ü©
    use Finsupp.single i 1, G_basis_eq i
  set en : (Œπ ‚Üí‚ÇÄ R) ‚äó[R] N := ‚àë i, Finsupp.single i 1 ‚äó‚Çú n i with hen
  have en_mem_ker : en ‚àà ker (rTensor N G) := by simp [hen, G_basis_eq, hmn]
  have exact_ker_subtype : Exact (ker G).subtype G := G.exact_subtype_ker_map
  have exact_rTensor_ker_subtype : Exact (rTensor N (ker G).subtype) (rTensor N G) :=
    rTensor_exact (M := ‚Ü•(ker G)) N exact_ker_subtype G_surjective
  have en_mem_range : en ‚àà range (rTensor N (ker G).subtype) :=
    exact_rTensor_ker_subtype.linearMap_ker_eq ‚ñ∏ en_mem_ker
  obtain ‚ü®kn, hkn‚ü© := en_mem_range
  obtain ‚ü®ma, rfl : kn = ‚àë kj ‚àà ma, kj.1 ‚äó‚Çú[R] kj.2‚ü© := exists_finset kn
  use ‚Üë‚Üëma, FinsetCoe.fintype ma
  use fun i ‚ü®‚ü®kj, _‚ü©, _‚ü© ‚Ü¶ (kj : Œπ ‚Üí‚ÇÄ R) i
  use fun ‚ü®‚ü®_, yj‚ü©, _‚ü© ‚Ü¶ yj
  constructor
  ¬∑ intro i
    apply_fun finsuppScalarLeft R N Œπ at hkn
    apply_fun (¬∑ i) at hkn
    symm at hkn
    simp only [map_sum, finsuppScalarLeft_apply_tmul, zero_smul, Finsupp.single_zero,
      Finsupp.sum_single_index, one_smul, Finsupp.finset_sum_apply, Finsupp.single_apply,
      Finset.sum_ite_eq', Finset.mem_univ, ‚ÜìreduceIte, rTensor_tmul, coeSubtype, Finsupp.sum_apply,
      Finsupp.sum_ite_eq', Finsupp.mem_support_iff, ne_eq, ite_not, en] at hkn
    simp only [Finset.univ_eq_attach, Finset.sum_attach ma (fun x ‚Ü¶ (x.1 : Œπ ‚Üí‚ÇÄ R) i ‚Ä¢ x.2)]
    convert hkn using 2 with x _
    split
    ¬∑ next h'x => rw [h'x, zero_smul]
    ¬∑ rfl
  ¬∑ rintro ‚ü®‚ü®‚ü®k, hk‚ü©, _‚ü©, _‚ü©
    simpa only [hG, Finsupp.total_apply, zero_smul, implies_true, Finsupp.sum_fintype] using
      mem_ker.mp hk"
Mathlib/Data/List/NodupEquivFin.lean,List.sublist_iff_exists_fin_orderEmbedding_get_eq,sublist_iff_exists_fin_orderEmbedding_get_eq,2b42dc7c3f9ebf6e7f17bff850d9c0bc3f1cf75e,":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï} (_ : i < l.length), f i < l'.length :=
      by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine' ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) _, _‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [get?_eq_get i.2, get?_eq_get (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine'
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          _,
        _‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ rw [add_comm]
        exact lt_add_of_lt_of_pos (Fin.is_lt _) (i.zero_le.trans_lt h)
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi","error:  type mismatch
  h‚úù
has type
  some l[‚Üëi] = l'[f ‚Üëi]? : Prop
but is expected to have type
  l[‚Üëi] = l'[f ‚Üëi] : Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + ?b
case neg
Œ± : Type u_1
l l' : List Œ±
f : Fin l.length ‚Ü™o Fin l'.length
hf : ‚àÄ (ix : Fin l.length), l.get ix = l'.get (f ix)
i j : ‚Ñï
h : i < j
hi : i < l.length
hj : ¬¨j < l.length
‚ä¢ ‚Üë(f ‚ü®i, hi‚ü©) < j + l'.length
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem sublist_iff_exists_fin_orderEmbedding_get_eq {l l' : List Œ±} :
    l <+ l' ‚Üî
      ‚àÉ f : Fin l.length ‚Ü™o Fin l'.length,
        ‚àÄ ix : Fin l.length, l.get ix = l'.get (f ix) ",":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï}, i < l.length ‚Üí f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) ?_, ?_‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [getElem?_eq_getElem i.2, getElem?_eq_getElem (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          ?_,
        ?_‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ have := (f ‚ü®i, hi‚ü©).is_lt
        omega
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,98e78f90ec6f93268c84b413fdae7dce5cbee0e6,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a
  exact ‚ü®_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b
  exact ‚ü®_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.closed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x
    ¬∑ intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine' ‚ü®g + dg, fun y => _, funext hgf‚ü©
    ¬∑ have hay : a < (g + dg) y := by
        rcases(hg_mem y).1.eq_or_lt with (rfl | hlt)
        ¬∑ refine' (lt_add_iff_pos_right _).2 _
          calc
            0 < c - g y := sub_pos.2 hac
            _ = dg y := (dga rfl).symm
        ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      refine' ‚ü®x, hxy.le, _‚ü©
      cases' le_total c (g y) with hc hc
      ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
      ¬∑ calc
          g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
          _ = b := by rw [hsub, add_sub_cancel'_right]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.closed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x
  ¬∑ intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine' ‚ü®g - dg, fun y => _, funext hgf‚ü©
  ¬∑ have hyb : (g - dg) y < b := by
      rcases(hgb y).eq_or_lt with (rfl | hlt)
      ¬∑ refine' (sub_lt_self_iff _).2 _
        calc
          0 < g y - c := sub_pos.2 hcb
          _ = dg y := (dgb rfl).symm
      ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
    rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
    cases' lt_or_le c (g y) with hc hc
    ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
      ¬∑ refine' ‚ü®x, xu, _, hyxu.le‚ü©
        calc
          f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
      ¬∑ have hay : a < (g - dg) y := by
          calc
            a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
            _ < g y - (b - c) := (sub_lt_sub_right hc _)
            _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
        rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
        exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
    ¬∑ refine' ‚ü®xl y, xu, _, hyxu.le‚ü©
      simp [dg0 (Or.inr hc), hxl]","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case intro.intro.inr.intro.intro.intro
X : Type u_1
Y : Type u_2
inst‚úù¬≥ : TopologicalSpace X
inst‚úù¬≤ : TopologicalSpace Y
inst‚úù¬π : NormalSpace Y
inst‚úù : Nonempty X
f : X ‚Üí·µá ‚Ñù
e : X ‚Üí Y
he : ClosedEmbedding e
inhabited_h : Inhabited X
a : ‚Ñù
ha : IsGLB (range ‚áëf) a
b : ‚Ñù
hb : IsLUB (range ‚áëf) b
hmem : ‚àÄ (x : X), f x ‚àà Icc a b
hle : a ‚â§ b
hlt : a < b
c : ‚Ñù := (a + b) / 2
hac : a < c
hcb : c < b
hsub : c - a = b - c
g : Y ‚Üí·µá ‚Ñù
hg_mem : ‚àÄ (y : Y), g y ‚àà Icc a b
ha' : ¬¨‚àÉ x, f x = a
hd : Disjoint (range e ‚à™ ‚áëg ‚Åª¬π' Ici c) (‚áëg ‚Åª¬π' {a})
dg : Y ‚Üí·µá ‚Ñù
dg0 : EqOn (‚áëdg) (Function.const Y 0) (range e ‚à™ ‚áëg ‚Åª¬π' Ici c)
dga : EqOn (‚áëdg) (Function.const Y (c - a)) (‚áëg ‚Åª¬π' {a})
dgmem : ‚àÄ (x : Y), dg x ‚àà Icc 0 (c - a)
hgf : ‚àÄ (x : X), (g + dg) (e x) = f x
‚ä¢ ‚àÉ g, (‚àÄ (y : Y), ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß ‚áëg ‚àò e = ‚áëf
error:  unsolved goals
case intro.intro.inr.intro.intro
X : Type u_1
Y : Type u_2
inst‚úù¬≥ : TopologicalSpace X
inst‚úù¬≤ : TopologicalSpace Y
inst‚úù¬π : NormalSpace Y
inst‚úù : Nonempty X
f : X ‚Üí·µá ‚Ñù
e : X ‚Üí Y
he : ClosedEmbedding e
inhabited_h : Inhabited X
a : ‚Ñù
ha : IsGLB (range ‚áëf) a
b : ‚Ñù
hb : IsLUB (range ‚áëf) b
hmem : ‚àÄ (x : X), f x ‚àà Icc a b
hle : a ‚â§ b
hlt : a < b
c : ‚Ñù := (a + b) / 2
hac : a < c
hcb : c < b
hsub : c - a = b - c
g : Y ‚Üí·µá ‚Ñù
hg_mem : ‚àÄ (y : Y), ‚àÉ x, g y ‚àà Icc (f x) b
hgf : ‚áëg ‚àò e = ‚áëf
‚ä¢ ‚àÉ g, (‚àÄ (y : Y), ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß ‚áëg ‚àò e = ‚áëf","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean,Polynomial.degree_cyclotomic_pos,degree_cyclotomic_pos,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [degree_cyclotomic n R, Nat.cast_pos]; exact Nat.totient_pos hpos","error:  function expected at
  Nat.totient_pos
term has type
  0 < ?m.68089.totient ‚Üî 0 < ?m.68089","theorem degree_cyclotomic_pos (n : ‚Ñï) (R : Type*) (hpos : 0 < n) [Ring R] [Nontrivial R] :
    0 < (cyclotomic n R).degree ",":= by
  rwa [degree_cyclotomic n R, Nat.cast_pos, Nat.totient_pos]"
Mathlib/Analysis/Normed/Group/ControlledClosure.lean,controlled_closure_of_complete,controlled_closure_of_complete,ebf0b7502c334150094390d6111d33ee017c7f8a,":= by
  rintro (h : H) (h_in : h ‚àà K.topologicalClosure)
  by_cases hyp_h : h = 0
  ¬∑ rw [hyp_h]
    use 0
    simp
  set b : ‚Ñï ‚Üí ‚Ñù := fun i => (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
  have b_pos : ‚àÄ i, 0 < b i := by
    intro i
    field_simp [hC]
    exact
      div_pos (mul_pos hŒµ (norm_pos_iff.mpr hyp_h)) (mul_pos (by norm_num : (0 : ‚Ñù) < 2 ^ i * 2) hC)
  obtain
    ‚ü®v : ‚Ñï ‚Üí H, lim_v : Tendsto (fun n : ‚Ñï => ‚àë k in range (n + 1), v k) atTop (ùìù h), v_in :
      ‚àÄ n, v n ‚àà K, hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0, hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n‚ü© :=
    controlled_sum_of_mem_closure h_in b_pos
  have : ‚àÄ n, ‚àÉ m' : G, f m' = v n ‚àß ‚Äñm'‚Äñ ‚â§ C * ‚Äñv n‚Äñ := fun n : ‚Ñï => hyp (v n) (v_in n)
  choose u hu hnorm_u using this
  set s : ‚Ñï ‚Üí G := fun n => ‚àë k in range (n + 1), u k
  have : CauchySeq s := by
    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one
    rintro n (hn : n ‚â• 1)
    calc
      ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ := hnorm_u n
      _ ‚â§ C * b n := (mul_le_mul_of_nonneg_left (hv _ <| Nat.succ_le_iff.mp hn).le hC.le)
      _ = (1 / 2) ^ n * (Œµ * ‚Äñh‚Äñ / 2) := by simp [mul_div_cancel' _ hC.ne.symm]
      _ = Œµ * ‚Äñh‚Äñ / 2 * (1 / 2) ^ n := mul_comm _ _
  obtain ‚ü®g : G, hg‚ü© := cauchySeq_tendsto_of_complete this
  refine' ‚ü®g, _, _‚ü©
  ¬∑ 
    have : f ‚àò s = fun n => ‚àë k in range (n + 1), v k := by
      ext n
      simp [map_sum, hu]
    rw [‚Üê this] at lim_v
    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v
  ¬∑ 
    suffices : ‚àÄ n, ‚Äñs n‚Äñ ‚â§ (C + Œµ) * ‚Äñh‚Äñ
    exact le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this
    intro n
    have hnorm‚ÇÄ : ‚Äñu 0‚Äñ ‚â§ C * b 0 + C * ‚Äñh‚Äñ := by
      have :=
        calc
          ‚Äñv 0‚Äñ ‚â§ ‚Äñh‚Äñ + ‚Äñv 0 - h‚Äñ := norm_le_insert' _ _
          _ ‚â§ ‚Äñh‚Äñ + b 0 := by apply add_le_add_left hv‚ÇÄ.le
      calc
        ‚Äñu 0‚Äñ ‚â§ C * ‚Äñv 0‚Äñ := hnorm_u 0
        _ ‚â§ C * (‚Äñh‚Äñ + b 0) := (mul_le_mul_of_nonneg_left this hC.le)
        _ = C * b 0 + C * ‚Äñh‚Äñ := by rw [add_comm, mul_add]
    have : (‚àë k in range (n + 1), C * b k) ‚â§ Œµ * ‚Äñh‚Äñ :=
      calc
        (‚àë k in range (n + 1), C * b k) = (‚àë k in range (n + 1), (1 / 2 : ‚Ñù) ^ k) * (Œµ * ‚Äñh‚Äñ / 2) :=
          by simp only [mul_div_cancel' _ hC.ne.symm, ‚Üê sum_mul]
        _ ‚â§ 2 * (Œµ * ‚Äñh‚Äñ / 2) :=
          (mul_le_mul_of_nonneg_right (sum_geometric_two_le _) (by nlinarith [hŒµ, norm_nonneg h]))
        _ = Œµ * ‚Äñh‚Äñ := mul_div_cancel' _ two_ne_zero
    calc
      ‚Äñs n‚Äñ ‚â§ ‚àë k in range (n + 1), ‚Äñu k‚Äñ := norm_sum_le _ _
      _ = (‚àë k in range n, ‚Äñu (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := (sum_range_succ' _ _)
      _ ‚â§ (‚àë k in range n, C * ‚Äñv (k + 1)‚Äñ) + ‚Äñu 0‚Äñ :=
        (add_le_add_right (sum_le_sum fun _ _ => hnorm_u _) _)
      _ ‚â§ (‚àë k in range n, C * b (k + 1)) + (C * b 0 + C * ‚Äñh‚Äñ) :=
        (add_le_add (sum_le_sum fun k _ => mul_le_mul_of_nonneg_left (hv _ k.succ_pos).le hC.le)
          hnorm‚ÇÄ)
      _ = (‚àë k in range (n + 1), C * b k) + C * ‚Äñh‚Äñ := by rw [‚Üê add_assoc, sum_range_succ']
      _ ‚â§ (C + Œµ) * ‚Äñh‚Äñ := by
        rw [add_comm, add_mul]
        apply add_le_add_left this","error:  unexpected token ':'; expected term
error:  unsolved goals
case h
G : Type u_1
inst‚úù¬≤ : NormedAddCommGroup G
inst‚úù¬π : CompleteSpace G
H : Type u_2
inst‚úù : NormedAddCommGroup H
f : NormedAddGroupHom G H
K : AddSubgroup H
C Œµ : ‚Ñù
hC : 0 < C
hŒµ : 0 < Œµ
hyp : f.SurjectiveOnWith K C
h : H
h_in : h ‚àà K.topologicalClosure
hyp_h : ¬¨h = 0
b : ‚Ñï ‚Üí ‚Ñù := fun i ‚Ü¶ (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
b_pos : ‚àÄ (i : ‚Ñï), 0 < b i
v : ‚Ñï ‚Üí H
lim_v : Tendsto (fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h)
v_in : ‚àÄ (n : ‚Ñï), v n ‚àà K
hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0
hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n
u : ‚Ñï ‚Üí G
hu : ‚àÄ (n : ‚Ñï), f (u n) = v n
hnorm_u : ‚àÄ (n : ‚Ñï), ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ
s : ‚Ñï ‚Üí G := fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), u k
this : CauchySeq s
g : G
hg : Tendsto s atTop (ùìù g)
n : ‚Ñï
‚ä¢ f (s n) = ‚àë k ‚àà range (n + 1), v k","theorem controlled_closure_of_complete {f : NormedAddGroupHom G H} {K : AddSubgroup H} {C Œµ : ‚Ñù}
    (hC : 0 < C) (hŒµ : 0 < Œµ) (hyp : f.SurjectiveOnWith K C) :
    f.SurjectiveOnWith K.topologicalClosure (C + Œµ) ",":= by
  rintro (h : H) (h_in : h ‚àà K.topologicalClosure)
  by_cases hyp_h : h = 0
  ¬∑ rw [hyp_h]
    use 0
    simp
  set b : ‚Ñï ‚Üí ‚Ñù := fun i => (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
  have b_pos (i) : 0 < b i := by field_simp [b, hC, hyp_h]
  obtain
    ‚ü®v : ‚Ñï ‚Üí H, lim_v : Tendsto (fun n : ‚Ñï => ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h), v_in :
      ‚àÄ n, v n ‚àà K, hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0, hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n‚ü© :=
    controlled_sum_of_mem_closure h_in b_pos
  have : ‚àÄ n, ‚àÉ m' : G, f m' = v n ‚àß ‚Äñm'‚Äñ ‚â§ C * ‚Äñv n‚Äñ := fun n : ‚Ñï => hyp (v n) (v_in n)
  choose u hu hnorm_u using this
  set s : ‚Ñï ‚Üí G := fun n => ‚àë k ‚àà range (n + 1), u k
  have : CauchySeq s := by
    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one
    ¬∑ rintro n (hn : n ‚â• 1)
      calc
        ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ := hnorm_u n
        _ ‚â§ C * b n := by gcongr; exact (hv _ <| Nat.succ_le_iff.mp hn).le
        _ = (1 / 2) ^ n * (Œµ * ‚Äñh‚Äñ / 2) := by simp [mul_div_cancel‚ÇÄ _ hC.ne.symm]
        _ = Œµ * ‚Äñh‚Äñ / 2 * (1 / 2) ^ n := mul_comm _ _
  obtain ‚ü®g : G, hg‚ü© := cauchySeq_tendsto_of_complete this
  refine ‚ü®g, ?_, ?_‚ü©
  ¬∑ 
    have : f ‚àò s = fun n => ‚àë k ‚àà range (n + 1), v k := by
      ext n
      simp [s, map_sum, hu]
    rw [‚Üê this] at lim_v
    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v
  ¬∑ 
    suffices ‚àÄ n, ‚Äñs n‚Äñ ‚â§ (C + Œµ) * ‚Äñh‚Äñ from
      le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this
    intro n
    have hnorm‚ÇÄ : ‚Äñu 0‚Äñ ‚â§ C * b 0 + C * ‚Äñh‚Äñ := by
      have :=
        calc
          ‚Äñv 0‚Äñ ‚â§ ‚Äñh‚Äñ + ‚Äñv 0 - h‚Äñ := norm_le_insert' _ _
          _ ‚â§ ‚Äñh‚Äñ + b 0 := by gcongr
      calc
        ‚Äñu 0‚Äñ ‚â§ C * ‚Äñv 0‚Äñ := hnorm_u 0
        _ ‚â§ C * (‚Äñh‚Äñ + b 0) := by gcongr
        _ = C * b 0 + C * ‚Äñh‚Äñ := by rw [add_comm, mul_add]
    have : (‚àë k ‚àà range (n + 1), C * b k) ‚â§ Œµ * ‚Äñh‚Äñ :=
      calc (‚àë k ‚àà range (n + 1), C * b k)
        _ = (‚àë k ‚àà range (n + 1), (1 / 2 : ‚Ñù) ^ k) * (Œµ * ‚Äñh‚Äñ / 2) := by
          simp only [mul_div_cancel‚ÇÄ _ hC.ne.symm, ‚Üê sum_mul]
        _ ‚â§ 2 * (Œµ * ‚Äñh‚Äñ / 2) := by gcongr; apply sum_geometric_two_le
        _ = Œµ * ‚Äñh‚Äñ := mul_div_cancel‚ÇÄ _ two_ne_zero
    calc
      ‚Äñs n‚Äñ ‚â§ ‚àë k ‚àà range (n + 1), ‚Äñu k‚Äñ := norm_sum_le _ _
      _ = (‚àë k ‚àà range n, ‚Äñu (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := sum_range_succ' _ _
      _ ‚â§ (‚àë k ‚àà range n, C * ‚Äñv (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := by gcongr; apply hnorm_u
      _ ‚â§ (‚àë k ‚àà range n, C * b (k + 1)) + (C * b 0 + C * ‚Äñh‚Äñ) := by
        gcongr with k; exact (hv _ k.succ_pos).le
      _ = (‚àë k ‚àà range (n + 1), C * b k) + C * ‚Äñh‚Äñ := by rw [‚Üê add_assoc, sum_range_succ']
      _ ‚â§ (C + Œµ) * ‚Äñh‚Äñ := by
        rw [add_comm, add_mul]
        apply add_le_add_left this"
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow,discr_prime_pow,8dba065d4a693e23ed06348923cd5effc765cb75,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), succ_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2
      ¬∑ rwa [Ne.def, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact_mod_cast hŒ∂.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact_mod_cast hŒ∂.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by linarith)] at this
      exact absurd (pow_eq_zero h) this","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case e_a.inr
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2‚úù : p = 2 ‚Üí k ‚â† 0
hp2 : ‚Üëp ‚â† 2
‚ä¢ (-1) ^ (‚Üëp ^ k * (‚Üëp - 1) * (‚Üëp ^ k * (‚Üëp - 1) - 1) / 2) = (-1) ^ (‚Üëp ^ k * (‚Üëp - 1) / 2)
error:  unsolved goals
case e_a
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2 : p = 2 ‚Üí k ‚â† 0
‚ä¢ (Algebra.norm K) ((aeval Œ∂) (derivative (cyclotomic (‚Üëp ^ (k + 1)) K))) = ‚Üë‚Üëp ^ (‚Üëp ^ k * ((‚Üëp - 1) * (k + 1) - 1))","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ‚Ñï).Prime]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1)) : ‚Ñï) K))
    (hk : p ^ (k + 1) ‚â† 2) : discr K (hŒ∂.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : ‚Ñï).totient / 2) * p ^ ((p : ‚Ñï) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this"
Mathlib/MeasureTheory/Function/LocallyIntegrable.lean,MeasureTheory.locallyIntegrableOn_iff,locallyIntegrableOn_iff,98e78f90ec6f93268c84b413fdae7dce5cbee0e6,":= by
  refine' ‚ü®fun hf k hk => hf.integrableOn_compact_subset hk, fun hf x hx => _‚ü©
  cases hs with
  | inl hs =>
    exact
      let ‚ü®K, hK, h2K‚ü© := exists_compact_mem_nhds x
      ‚ü®_, inter_mem_nhdsWithin s h2K,
        hf _ (inter_subset_left _ _)
          (isCompact_of_isClosed_subset hK (hs.inter hK.isClosed) (inter_subset_right _ _))‚ü©
  | inr hs =>
    obtain ‚ü®K, hK, h2K, h3K‚ü© := exists_compact_subset hs hx
    refine' ‚ü®K, _, hf K h3K hK‚ü©
    simpa only [IsOpen.nhdsWithin_eq hs hx, interior_eq_nhds'] using h2K","error:  function expected at
  inter_subset_left ?m.10496
term has type
  ?m.10495 ‚àà ?m.10493
error:  unknown identifier 'isCompact_of_isClosed_subset'","theorem locallyIntegrableOn_iff [LocallyCompactSpace X] [T2Space X] (hs : IsClosed s ‚à® IsOpen s) :
    LocallyIntegrableOn f s Œº ‚Üî ‚àÄ (k : Set X), k ‚äÜ s ‚Üí (IsCompact k ‚Üí IntegrableOn f k Œº) ",":= by
  refine ‚ü®fun hf k hk => hf.integrableOn_compact_subset hk, fun hf x hx => ?_‚ü©
  cases hs with
  | inl hs =>
    exact
      let ‚ü®K, hK, h2K‚ü© := exists_compact_mem_nhds x
      ‚ü®_, inter_mem_nhdsWithin s h2K,
        hf _ inter_subset_left
          (hK.of_isClosed_subset (hs.inter hK.isClosed) inter_subset_right)‚ü©
  | inr hs =>
    obtain ‚ü®K, hK, h2K, h3K‚ü© := exists_compact_subset hs hx
    refine ‚ü®K, ?_, hf K h3K hK‚ü©
    simpa only [IsOpen.nhdsWithin_eq hs hx, interior_eq_nhds'] using h2K"
Mathlib/Probability/Martingale/BorelCantelli.lean,MeasureTheory.Submartingale.exists_tendsto_of_abs_bddAbove_aux,Submartingale.exists_tendsto_of_abs_bddAbove_aux,9e34a191034458a56331f976ff7400a26407c888,":= by
  have ht :
    ‚àÄ·µê œâ ‚àÇŒº, ‚àÄ i : ‚Ñï, ‚àÉ c, Tendsto (fun n => stoppedValue f (leastGE f i n) œâ) atTop (ùìù c) := by
    rw [ae_all_iff]
    exact fun i => Submartingale.exists_ae_tendsto_of_bdd (hf.stoppedValue_leastGE i)
      (hf.stoppedValue_leastGE_snorm_le' i.cast_nonneg hf0 hbdd)
  filter_upwards [ht] with œâ hœâ hœâb
  rw [BddAbove] at hœâb
  obtain ‚ü®i, hi‚ü© := exists_nat_gt hœâb.some
  have hib : ‚àÄ n, f n œâ < i := by
    intro n
    exact lt_of_le_of_lt ((mem_upperBounds.1 hœâb.some_mem) _ ‚ü®n, rfl‚ü©) hi
  have heq : ‚àÄ n, stoppedValue f (leastGE f i n) œâ = f n œâ := by
    intro n
    rw [leastGE]; unfold hitting; rw [stoppedValue]
    simp only
    rw [if_neg]
    simp only [Set.mem_Icc, Set.mem_union, Set.mem_Ici]
    push_neg
    exact fun j _ => hib j
  simp only [‚Üê heq, hœâ i]",error:  simp made no progress,"theorem Submartingale.exists_tendsto_of_abs_bddAbove_aux [IsFiniteMeasure Œº]
    (hf : Submartingale f ‚Ñ± Œº) (hf0 : f 0 = 0) (hbdd : ‚àÄ·µê œâ ‚àÇŒº, ‚àÄ i, |f (i + 1) œâ - f i œâ| ‚â§ R) :
    ‚àÄ·µê œâ ‚àÇŒº, BddAbove (Set.range fun n => f n œâ) ‚Üí ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù c) ",":= by
  have ht :
    ‚àÄ·µê œâ ‚àÇŒº, ‚àÄ i : ‚Ñï, ‚àÉ c, Tendsto (fun n => stoppedValue f (leastGE f i n) œâ) atTop (ùìù c) := by
    rw [ae_all_iff]
    exact fun i => Submartingale.exists_ae_tendsto_of_bdd (hf.stoppedValue_leastGE i)
      (hf.stoppedValue_leastGE_snorm_le' i.cast_nonneg hf0 hbdd)
  filter_upwards [ht] with œâ hœâ hœâb
  rw [BddAbove] at hœâb
  obtain ‚ü®i, hi‚ü© := exists_nat_gt hœâb.some
  have hib : ‚àÄ n, f n œâ < i := by
    intro n
    exact lt_of_le_of_lt ((mem_upperBounds.1 hœâb.some_mem) _ ‚ü®n, rfl‚ü©) hi
  have heq : ‚àÄ n, stoppedValue f (leastGE f i n) œâ = f n œâ := by
    intro n
    rw [leastGE]; unfold hitting; rw [stoppedValue]
    rw [if_neg]
    simp only [Set.mem_Icc, Set.mem_union, Set.mem_Ici]
    push_neg
    exact fun j _ => hib j
  simp only [‚Üê heq, hœâ i]"
Mathlib/RingTheory/Polynomial/Chebyshev.lean,Polynomial.Chebyshev.U_two,U_two,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp only [U]
  ring",error:  simp made no progress,theorem U_two : U R 2 = 4 * X ^ 2 - 1 ,":= by
  have := U_add_two R 0
  simp only [zero_add, U_one, U_zero] at this
  linear_combination this"
Mathlib/Topology/Sober.lean,quasiSober_of_open_cover,quasiSober_of_open_cover,8ffb78dfb7ae6d7a715b2782ac93ea174198224b,":= by
  rw [quasiSober_iff]
  intro t h h'
  obtain ‚ü®x, hx‚ü© := h.1
  obtain ‚ü®U, hU, hU'‚ü© : x ‚àà ‚ãÉ‚ÇÄ S := by
    rw [hS'']
    trivial
  haveI : QuasiSober U := hS' ‚ü®U, hU‚ü©
  have H : IsPreirreducible (U ‚Üì‚à© t) :=
    h.2.preimage (hS ‚ü®U, hU‚ü©).openEmbedding_subtype_val
  replace H : IsIrreducible (U ‚Üì‚à© t) := ‚ü®‚ü®‚ü®x, hU'‚ü©, by simpa using hx‚ü©, H‚ü©
  use H.genericPoint
  have := continuous_subtype_val.closure_preimage_subset _ H.genericPoint_spec.mem
  rw [h'.closure_eq] at this
  apply le_antisymm
  ¬∑ apply h'.closure_subset_iff.mpr
    simpa using this
  rw [‚Üê image_singleton, ‚Üê closure_image_closure continuous_subtype_val, H.genericPoint_spec.def]
  refine' (subset_closure_inter_of_isPreirreducible_of_isOpen h.2 (hS ‚ü®U, hU‚ü©) ‚ü®x, hx, hU'‚ü©).trans
    (closure_mono _)
  rw [inter_comm t, ‚Üê Subtype.image_preimage_coe]
  exact Set.image_subset _ subset_closure","error:  unexpected token '‚Üì'; expected ')', ',' or ':'
error:  unsolved goals
case intro.intro.intro
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬π : TopologicalSpace Œ±
inst‚úù : TopologicalSpace Œ≤
S : Set (Set Œ±)
hS : ‚àÄ (s : ‚ÜëS), IsOpen ‚Üës
hS' : ‚àÄ (s : ‚ÜëS), QuasiSober ‚Üë‚Üës
hS'' : ‚ãÉ‚ÇÄ S = ‚ä§
t : Set Œ±
h : IsIrreducible t
h' : IsClosed t
x : Œ±
hx : x ‚àà t
U : Set Œ±
hU : U ‚àà S
hU' : x ‚àà U
this : QuasiSober ‚ÜëU
H : IsPreirreducible U
‚ä¢ ‚àÉ x, IsGenericPoint x t","theorem quasiSober_of_open_cover (S : Set (Set Œ±)) (hS : ‚àÄ s : S, IsOpen (s : Set Œ±))
    [hS' : ‚àÄ s : S, QuasiSober s] (hS'' : ‚ãÉ‚ÇÄ S = ‚ä§) : QuasiSober Œ± ",":= by
  rw [quasiSober_iff]
  intro t h h'
  obtain ‚ü®x, hx‚ü© := h.1
  obtain ‚ü®U, hU, hU'‚ü© : x ‚àà ‚ãÉ‚ÇÄ S := by
    rw [hS'']
    trivial
  haveI : QuasiSober U := hS' ‚ü®U, hU‚ü©
  have H : IsPreirreducible ((‚Üë) ‚Åª¬π' t : Set U) :=
    h.2.preimage (hS ‚ü®U, hU‚ü©).openEmbedding_subtype_val
  replace H : IsIrreducible ((‚Üë) ‚Åª¬π' t : Set U) := ‚ü®‚ü®‚ü®x, hU'‚ü©, by simpa using hx‚ü©, H‚ü©
  use H.genericPoint
  have := continuous_subtype_val.closure_preimage_subset _ H.genericPoint_spec.mem
  rw [h'.closure_eq] at this
  apply le_antisymm
  ¬∑ apply h'.closure_subset_iff.mpr
    simpa using this
  rw [‚Üê image_singleton, ‚Üê closure_image_closure continuous_subtype_val, H.genericPoint_spec.def]
  refine (subset_closure_inter_of_isPreirreducible_of_isOpen h.2 (hS ‚ü®U, hU‚ü©) ‚ü®x, hx, hU'‚ü©).trans
    (closure_mono ?_)
  rw [inter_comm t, ‚Üê Subtype.image_preimage_coe]
  exact Set.image_subset _ subset_closure"
Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean,MeasureTheory.measure_inter_null_of_null_right,measure_inter_null_of_null_right,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  measure_mono_null (inter_subset_right S T) h","warning:  `MeasureTheory.OuterMeasure.empty'` has been deprecated, use `MeasureTheory.measure_empty` instead
error:  application type mismatch
  inter_subset_right S
argument
  S
has type
  Set Œ± : Type u_1
but is expected to have type
  ?m.24507 ‚àà ?m.24505 ‚à© ?m.24506 : Prop",theorem measure_inter_null_of_null_right (S : Set Œ±) {T : Set Œ±} (h : Œº T = 0) : Œº (S ‚à© T) = 0 ,":=
  measure_mono_null inter_subset_right h"
Mathlib/RingTheory/RingHom/Finite.lean,RingHom.finite_stableUnderBaseChange,finite_stableUnderBaseChange,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  refine StableUnderBaseChange.mk _ finite_respectsIso ?_
  classical
  introv h
  replace h : Module.Finite R T := by
    rw [RingHom.Finite] at h; convert h; ext; sorry; sorry
  suffices Module.Finite S (S ‚äó[R] T) by
    rw [RingHom.Finite]; convert this; congr; sorry; sorry; sorry 
  exact inferInstance","error:  no goals to be solved
error:  no goals to be solved",theorem finite_stableUnderBaseChange : StableUnderBaseChange @Finite ,":= by
  refine StableUnderBaseChange.mk _ finite_respectsIso ?_
  classical
  introv h
  replace h : Module.Finite R T := by
    rw [RingHom.Finite] at h; convert h; ext; simp_rw [Algebra.smul_def]; rfl
  suffices Module.Finite S (S ‚äó[R] T) by
    rw [RingHom.Finite]; convert this; congr; ext; simp_rw [Algebra.smul_def]; rfl
  exact inferInstance"
Mathlib/Order/JordanHolder.lean,CompositionSeries.toList_sorted,toList_sorted,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  List.pairwise_iff_get.2 fun i j h => by
    dsimp [toList]
    rw [List.get_ofFn, List.get_ofFn]
    exact s.strictMono h","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (List.ofFn ?f).get ?i
X : Type u
inst‚úù¬π : Lattice X
inst‚úù : JordanHolderLattice X
s : CompositionSeries X
i j : Fin (toList s).length
h : i < j
‚ä¢ (List.ofFn s.toFun)[‚Üëi] < (List.ofFn s.toFun)[‚Üëj]",theorem toList_sorted (s : CompositionSeries X) : s.toList.Sorted (¬∑ < ¬∑) ,":=
  List.pairwise_iff_get.2 fun i j h => by
    dsimp only [RelSeries.toList]
    rw [List.get_ofFn, List.get_ofFn]
    exact s.strictMono h"
Mathlib/Analysis/NormedSpace/Spectrum.lean,QuasispectrumRestricts.real_iff,real_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine ‚ü®fun h x hx ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ obtain ‚ü®x, -, rfl‚ü© := h.algebraMap_image.symm ‚ñ∏ hx
    simp
  ¬∑ exact .of_subset_range_algebraMap _ _ Complex.ofReal_re fun x hx ‚Ü¶ ‚ü®x.re, (h x hx).symm‚ü©","error:  function expected at
  of_subset_range_algebraMap ?m.390389 ?m.390390
term has type
  SpectrumRestricts ?m.390387 ?m.390388","lemma real_iff [Algebra ‚ÑÇ A] {a : A} :
    SpectrumRestricts a Complex.reCLM ‚Üî ‚àÄ x ‚àà spectrum ‚ÑÇ a, x = x.re ",":= by
  refine ‚ü®fun h x hx ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ obtain ‚ü®x, -, rfl‚ü© := h.algebraMap_image.symm ‚ñ∏ hx
    simp
  ¬∑ exact .of_subset_range_algebraMap Complex.ofReal_re fun x hx ‚Ü¶ ‚ü®x.re, (h x hx).symm‚ü©"
Mathlib/Data/PFunctor/Multivariate/M.lean,MvPFunctor.M.dest_map,M.dest_map,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  cases' x with a f
  rw [map_eq]
  conv =>
    rhs
    rw [M.dest, M.dest', map_eq, appendFun_comp_splitFun]","error:  unsolved goals
case mk
n : ‚Ñï
P : MvPFunctor.{u} (n + 1)
Œ± Œ≤ : TypeVec.{u} n
g : Œ± ‚üπ Œ≤
a : P.mp.A
f : P.mp.B a ‚üπ Œ±
‚ä¢ dest P ‚ü®a, g ‚äö f‚ü© =
    ‚ü®(PFunctor.M.dest ‚ü®a, f‚ü©.fst).fst,
      splitFun (g ‚äö pathDestLeft P ‚ãØ ‚ü®a, f‚ü©.snd)
        ((fun x ‚Ü¶ g <$$> x) ‚àò fun x ‚Ü¶ ‚ü®(PFunctor.M.dest ‚ü®a, f‚ü©.fst).snd x, pathDestRight P ‚ãØ ‚ü®a, f‚ü©.snd x‚ü©)‚ü©","theorem M.dest_map {Œ± Œ≤ : TypeVec n} (g : Œ± ‚üπ Œ≤) (x : P.M Œ±) :
    M.dest P (g <$$> x) = (appendFun g fun x => g <$$> x) <$$> M.dest P x ",":= by
  cases' x with a f
  rw [map_eq]
  conv =>
    rhs
    rw [M.dest, M.dest', map_eq, appendFun_comp_splitFun]
  rfl"
Mathlib/Geometry/Euclidean/MongePoint.lean,Affine.Triangle.altitude_replace_orthocenter_eq_affineSpan,altitude_replace_orthocenter_eq_affineSpan,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  symm
  rw [‚Üê h‚ÇÇ, t‚ÇÇ.affineSpan_pair_eq_altitude_iff]
  rw [h‚ÇÇ]
  use t‚ÇÅ.Independent.injective.ne hi‚ÇÅ‚ÇÇ
  have he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points) := by
    refine' ext_of_direction_eq _
      ‚ü®t‚ÇÅ.points i‚ÇÉ, mem_affineSpan ‚Ñù ‚ü®j‚ÇÉ, h‚ÇÉ‚ü©, mem_affineSpan ‚Ñù (Set.mem_range_self _)‚ü©
    refine' eq_of_le_of_finrank_eq (direction_le (spanPoints_subset_coe_of_subset_coe _)) _
    ¬∑ have hu : (Finset.univ : Finset (Fin 3)) = {j‚ÇÅ, j‚ÇÇ, j‚ÇÉ} := by
        clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
        fin_cases j‚ÇÅ <;> fin_cases j‚ÇÇ <;> fin_cases j‚ÇÉ
          <;> simp (config := {decide := true}) at hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ ‚ä¢
      rw [‚Üê Set.image_univ, ‚Üê Finset.coe_univ, hu, Finset.coe_insert, Finset.coe_insert,
        Finset.coe_singleton, Set.image_insert_eq, Set.image_insert_eq, Set.image_singleton, h‚ÇÅ, h‚ÇÇ,
        h‚ÇÉ, Set.insert_subset_iff, Set.insert_subset_iff, Set.singleton_subset_iff]
      exact
        ‚ü®t‚ÇÅ.orthocenter_mem_affineSpan, mem_affineSpan ‚Ñù (Set.mem_range_self _),
          mem_affineSpan ‚Ñù (Set.mem_range_self _)‚ü©
    ¬∑ rw [direction_affineSpan, direction_affineSpan,
        t‚ÇÅ.Independent.finrank_vectorSpan (Fintype.card_fin _),
        t‚ÇÇ.Independent.finrank_vectorSpan (Fintype.card_fin _)]
  rw [he]
  use mem_affineSpan ‚Ñù (Set.mem_range_self _)
  have hu : Finset.univ.erase j‚ÇÇ = {j‚ÇÅ, j‚ÇÉ} := by
    clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
    fin_cases j‚ÇÅ <;> fin_cases j‚ÇÇ <;> fin_cases j‚ÇÉ
      <;> simp (config := {decide := true}) at hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ ‚ä¢
  rw [hu, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton, h‚ÇÅ, h‚ÇÉ]
  have hle : (t‚ÇÅ.altitude i‚ÇÉ).direction·óÆ ‚â§ line[‚Ñù, t‚ÇÅ.orthocenter, t‚ÇÅ.points i‚ÇÉ].direction·óÆ :=
    Submodule.orthogonal_le (direction_le (affineSpan_orthocenter_point_le_altitude _ _))
  refine' hle ((t‚ÇÅ.vectorSpan_isOrtho_altitude_direction i‚ÇÉ) _)
  have hui : Finset.univ.erase i‚ÇÉ = {i‚ÇÅ, i‚ÇÇ} := by
    clear hle h‚ÇÇ h‚ÇÉ
    fin_cases i‚ÇÅ <;> fin_cases i‚ÇÇ <;> fin_cases i‚ÇÉ
      <;> simp (config := {decide := true}) at hi‚ÇÅ‚ÇÇ hi‚ÇÅ‚ÇÉ hi‚ÇÇ‚ÇÉ ‚ä¢
  rw [hui, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton]
  refine' vsub_mem_vectorSpan ‚Ñù (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_singleton _))","error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t‚ÇÅ
has type
  Triangle ‚Ñù P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t‚ÇÅ
has type
  Simplex ‚Ñù P 2
error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t‚ÇÅ
has type
  Triangle ‚Ñù P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t‚ÇÅ
has type
  Simplex ‚Ñù P 2
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.390259
case refine'_2
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ j‚ÇÅ j‚ÇÇ j‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
hj‚ÇÅ‚ÇÇ : j‚ÇÅ ‚â† j‚ÇÇ
hj‚ÇÅ‚ÇÉ : j‚ÇÅ ‚â† j‚ÇÉ
hj‚ÇÇ‚ÇÉ : j‚ÇÇ ‚â† j‚ÇÉ
h‚ÇÅ : t‚ÇÇ.points j‚ÇÅ = t‚ÇÅ.orthocenter
h‚ÇÇ : t‚ÇÇ.points j‚ÇÇ = t‚ÇÅ.points i‚ÇÇ
h‚ÇÉ : t‚ÇÇ.points j‚ÇÉ = t‚ÇÅ.points i‚ÇÉ
‚ä¢ finrank ‚Ñù ‚Ü•(vectorSpan ‚Ñù (Set.range t‚ÇÇ.points)) = finrank ‚Ñù ‚Ü•(vectorSpan ‚Ñù (Set.range t‚ÇÅ.points))","theorem altitude_replace_orthocenter_eq_affineSpan {t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P}
    {i‚ÇÅ i‚ÇÇ i‚ÇÉ j‚ÇÅ j‚ÇÇ j‚ÇÉ : Fin 3} (hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ) (hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ) (hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ) (hj‚ÇÅ‚ÇÇ : j‚ÇÅ ‚â† j‚ÇÇ)
    (hj‚ÇÅ‚ÇÉ : j‚ÇÅ ‚â† j‚ÇÉ) (hj‚ÇÇ‚ÇÉ : j‚ÇÇ ‚â† j‚ÇÉ) (h‚ÇÅ : t‚ÇÇ.points j‚ÇÅ = t‚ÇÅ.orthocenter)
    (h‚ÇÇ : t‚ÇÇ.points j‚ÇÇ = t‚ÇÅ.points i‚ÇÇ) (h‚ÇÉ : t‚ÇÇ.points j‚ÇÉ = t‚ÇÅ.points i‚ÇÉ) :
    t‚ÇÇ.altitude j‚ÇÇ = line[‚Ñù, t‚ÇÅ.points i‚ÇÅ, t‚ÇÅ.points i‚ÇÇ] ",":= by
  symm
  rw [‚Üê h‚ÇÇ, t‚ÇÇ.affineSpan_pair_eq_altitude_iff]
  rw [h‚ÇÇ]
  use t‚ÇÅ.independent.injective.ne hi‚ÇÅ‚ÇÇ
  have he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points) := by
    refine ext_of_direction_eq ?_
      ‚ü®t‚ÇÅ.points i‚ÇÉ, mem_affineSpan ‚Ñù ‚ü®j‚ÇÉ, h‚ÇÉ‚ü©, mem_affineSpan ‚Ñù (Set.mem_range_self _)‚ü©
    refine eq_of_le_of_finrank_eq (direction_le (spanPoints_subset_coe_of_subset_coe ?_)) ?_
    ¬∑ have hu : (Finset.univ : Finset (Fin 3)) = {j‚ÇÅ, j‚ÇÇ, j‚ÇÉ} := by
        clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
        fin_cases j‚ÇÅ <;> fin_cases j‚ÇÇ <;> fin_cases j‚ÇÉ
          <;> simp (config := {decide := true}) at hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ ‚ä¢
      rw [‚Üê Set.image_univ, ‚Üê Finset.coe_univ, hu, Finset.coe_insert, Finset.coe_insert,
        Finset.coe_singleton, Set.image_insert_eq, Set.image_insert_eq, Set.image_singleton, h‚ÇÅ, h‚ÇÇ,
        h‚ÇÉ, Set.insert_subset_iff, Set.insert_subset_iff, Set.singleton_subset_iff]
      exact
        ‚ü®t‚ÇÅ.orthocenter_mem_affineSpan, mem_affineSpan ‚Ñù (Set.mem_range_self _),
          mem_affineSpan ‚Ñù (Set.mem_range_self _)‚ü©
    ¬∑ rw [direction_affineSpan, direction_affineSpan,
        t‚ÇÅ.independent.finrank_vectorSpan (Fintype.card_fin _),
        t‚ÇÇ.independent.finrank_vectorSpan (Fintype.card_fin _)]
  rw [he]
  use mem_affineSpan ‚Ñù (Set.mem_range_self _)
  have hu : Finset.univ.erase j‚ÇÇ = {j‚ÇÅ, j‚ÇÉ} := by
    clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
    fin_cases j‚ÇÅ <;> fin_cases j‚ÇÇ <;> fin_cases j‚ÇÉ
      <;> simp (config := {decide := true}) at hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ ‚ä¢
  rw [hu, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton, h‚ÇÅ, h‚ÇÉ]
  have hle : (t‚ÇÅ.altitude i‚ÇÉ).direction·óÆ ‚â§ line[‚Ñù, t‚ÇÅ.orthocenter, t‚ÇÅ.points i‚ÇÉ].direction·óÆ :=
    Submodule.orthogonal_le (direction_le (affineSpan_orthocenter_point_le_altitude _ _))
  refine hle ((t‚ÇÅ.vectorSpan_isOrtho_altitude_direction i‚ÇÉ) ?_)
  have hui : Finset.univ.erase i‚ÇÉ = {i‚ÇÅ, i‚ÇÇ} := by
    clear hle h‚ÇÇ h‚ÇÉ
    fin_cases i‚ÇÅ <;> fin_cases i‚ÇÇ <;> fin_cases i‚ÇÉ
      <;> simp (config := {decide := true}) at hi‚ÇÅ‚ÇÇ hi‚ÇÅ‚ÇÉ hi‚ÇÇ‚ÇÉ ‚ä¢
  rw [hui, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton]
  exact vsub_mem_vectorSpan ‚Ñù (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_singleton _))"
Mathlib/Data/Fintype/Card.lean,Infinite.exists_subset_card_eq,exists_subset_card_eq,2fcaa477d134a83c884174e19b33d8bb7c52a503,":= by
  simpa using exists_superset_card_eq ‚àÖ _","error:  typeclass instance problem is stuck, it is often due to metavariables
  Fintype ?m.60032","theorem exists_subset_card_eq (Œ± : Type*) [Infinite Œ±] (n : ‚Ñï) : ‚àÉ s : Finset Œ±, s.card = n ",":=
  ‚ü®(range n).map (natEmbedding Œ±), by rw [card_map, card_range]‚ü©"
Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean,symm_trans_mem_contDiffGroupoid,symm_trans_mem_contDiffGroupoid,a310a89b3b6adc75dcde4df238382a90c1888d6c,":=
  haveI : e.symm.trans e ‚âà PartialHomeomorph.ofSet e.target e.open_target :=
    PartialHomeomorph.trans_symm_self _
  StructureGroupoid.eq_on_source _ (ofSet_mem_contDiffGroupoid n I e.open_target) this","warning:  modelWithCornersSelf does not have a doc string
error:  unknown constant 'PartialHomeomorph.trans_symm_self'
error:  unknown constant 'StructureGroupoid.eq_on_source'","theorem symm_trans_mem_contDiffGroupoid (e : PartialHomeomorph M H) :
    e.symm.trans e ‚àà contDiffGroupoid n I ",":=
  haveI : e.symm.trans e ‚âà PartialHomeomorph.ofSet e.target e.open_target :=
    PartialHomeomorph.symm_trans_self _
  StructureGroupoid.mem_of_eqOnSource _ (ofSet_mem_contDiffGroupoid n I e.open_target) this"
Mathlib/AlgebraicGeometry/Pullbacks.lean,AlgebraicGeometry.Scheme.Pullback.lift_comp_Œπ,lift_comp_Œπ,8d72f500a692fb12cb594b710bb3ac6e29534e0d,":= by
  apply ((gluing ùí∞ f g).openCover.pullbackCover pullback.fst).hom_ext
  intro j
  dsimp only [OpenCover.pullbackCover]
  trans pullbackFstŒπToV ùí∞ f g i j ‚â´ fV ùí∞ f g j i ‚â´ (gluing ùí∞ f g).Œπ _
  ¬∑ rw [‚Üê show _ = fV ùí∞ f g j i ‚â´ _ from (gluing ùí∞ f g).glue_condition j i]
    simp_rw [‚Üê Category.assoc]
    congr 1
    rw [gluing_f, gluing_t]
    apply pullback.hom_ext <;> simp_rw [Category.assoc]
    ¬∑ rw [t_fst_fst, pullback.lift_fst, pullbackFstŒπToV_snd]; rfl
    ¬∑ rw [t_fst_snd, pullback.lift_snd, pullbackFstŒπToV_fst_assoc, pullback.condition_assoc]
      erw [Multicoequalizer.inj_desc]
      rfl
  ¬∑ rw [pullback.condition, ‚Üê Category.assoc]
    congr 1
    apply pullback.hom_ext
    ¬∑ simp only [pullbackFstŒπToV_fst]; rfl
    ¬∑ simp only [pullbackFstŒπToV_fst]; rfl","error:  unknown identifier 'Multicoequalizer.inj_desc'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.356136
case e_a.h‚ÇÅ
C : Type u
inst‚úù¬π : Category.{v, u} C
X Y Z : Scheme
ùí∞ : X.OpenCover
f : X ‚ü∂ Z
g : Y ‚ü∂ Z
inst‚úù : ‚àÄ (i : ùí∞.J), HasPullback (ùí∞.map i ‚â´ f) g
s : PullbackCone f g
i : ùí∞.J
j : ((gluing ùí∞ f g).openCover.pullbackCover pullback.fst).J
‚ä¢ pullback.snd ‚â´ (gluing ùí∞ f g).openCover.map j ‚â´ p2 ùí∞ f g = pullback.snd ‚â´ pullback.snd","theorem lift_comp_Œπ (i : ùí∞.J) :
    pullback.lift pullback.snd (pullback.fst ‚â´ p2 ùí∞ f g)
          (by rw [‚Üê pullback.condition_assoc, Category.assoc, p_comm]) ‚â´
        (gluing ùí∞ f g).Œπ i =
      (pullback.fst : pullback (p1 ùí∞ f g) (ùí∞.map i) ‚ü∂ _) ",":= by
  apply ((gluing ùí∞ f g).openCover.pullbackCover pullback.fst).hom_ext
  intro j
  dsimp only [OpenCover.pullbackCover]
  trans pullbackFstŒπToV ùí∞ f g i j ‚â´ fV ùí∞ f g j i ‚â´ (gluing ùí∞ f g).Œπ _
  ¬∑ rw [‚Üê show _ = fV ùí∞ f g j i ‚â´ _ from (gluing ùí∞ f g).glue_condition j i]
    simp_rw [‚Üê Category.assoc]
    congr 1
    rw [gluing_f, gluing_t]
    apply pullback.hom_ext <;> simp_rw [Category.assoc]
    ¬∑ simp_rw [t_fst_fst, pullback.lift_fst, pullbackFstŒπToV_snd, GlueData.openCover_map]
    ¬∑ simp_rw [t_fst_snd, pullback.lift_snd, pullbackFstŒπToV_fst_assoc, pullback.condition_assoc,
        GlueData.openCover_map, p2]
      simp
  ¬∑ rw [pullback.condition, ‚Üê Category.assoc]
    simp_rw [pullbackFstŒπToV_fst, GlueData.openCover_map]"
Mathlib/Data/List/NodupEquivFin.lean,List.sublist_iff_exists_fin_orderEmbedding_get_eq,sublist_iff_exists_fin_orderEmbedding_get_eq,0630203384299a383b13c2b5141c4d3b351858a4,":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï}, i < l.length ‚Üí f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) ?_, ?_‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [get?_eq_get i.2, get?_eq_get (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          ?_,
        ?_‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ have := (f ‚ü®i, hi‚ü©).is_lt
        omega
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi","error:  type mismatch
  h‚úù
has type
  some l[‚Üëi] = l'[f ‚Üëi]? : Prop
but is expected to have type
  l[‚Üëi] = l'[f ‚Üëi] : Prop
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem sublist_iff_exists_fin_orderEmbedding_get_eq {l l' : List Œ±} :
    l <+ l' ‚Üî
      ‚àÉ f : Fin l.length ‚Ü™o Fin l'.length,
        ‚àÄ ix : Fin l.length, l.get ix = l'.get (f ix) ",":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï}, i < l.length ‚Üí f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) ?_, ?_‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [getElem?_eq_getElem i.2, getElem?_eq_getElem (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          ?_,
        ?_‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ have := (f ‚ü®i, hi‚ü©).is_lt
        omega
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi"
Mathlib/SetTheory/Cardinal/Divisibility.lean,Cardinal.nat_is_prime_iff,nat_is_prime_iff,8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85,":= by
  simp only [Prime, Nat.prime_iff]
  refine and_congr (by simp) (and_congr ?_ ‚ü®fun h b c hbc => ?_, fun h b c hbc =?> _‚ü©)
  ¬∑ simp only [isUnit_iff, Nat.isUnit_iff]
    exact mod_cast Iff.rfl
  ¬∑ exact mod_cast h b c (mod_cast hbc)
  cases' lt_or_le (b * c) ‚Ñµ‚ÇÄ with h' h'
  ¬∑ rcases mul_lt_aleph0_iff.mp h' with (rfl | rfl | ‚ü®hb, hc‚ü©)
    ¬∑ simp
    ¬∑ simp
    lift b to ‚Ñï using hb
    lift c to ‚Ñï using hc
    exact mod_cast h b c (mod_cast hbc)
  rcases aleph0_le_mul_iff.mp h' with ‚ü®hb, hc, h‚Ñµ‚ÇÄ‚ü©
  have hn : (n : Cardinal) ‚â† 0 := by
    intro h
    rw [h, zero_dvd_iff, mul_eq_zero] at hbc
    cases hbc <;> contradiction
  wlog h‚Ñµ‚ÇÄb : ‚Ñµ‚ÇÄ ‚â§ b
  refine (this h c b ?_ ?_ hc hb h‚Ñµ‚ÇÄ.symm hn (h‚Ñµ‚ÇÄ.resolve_left h‚Ñµ‚ÇÄb)).symm <;> try assumption
  ¬∑ rwa [mul_comm] at hbc
  ¬∑ rwa [mul_comm] at h'
  ¬∑ exact Or.inl (dvd_of_le_of_aleph0_le hn ((nat_lt_aleph0 n).le.trans h‚Ñµ‚ÇÄb) h‚Ñµ‚ÇÄb)","error:  unexpected token '='; expected '‚Ü¶', '=>'
error:  unsolved goals
case refine_1
a b : Cardinal.{u}
n m : ‚Ñï
‚ä¢ ¬¨IsUnit ‚Üën ‚Üî ¬¨IsUnit n

case refine_2
a b‚úù : Cardinal.{u}
n m : ‚Ñï
h : ‚àÄ (a b : Cardinal.{u_1}), ‚Üën ‚à£ a * b ‚Üí ‚Üën ‚à£ a ‚à® ‚Üën ‚à£ b
b c : ‚Ñï
hbc : n ‚à£ b * c
‚ä¢ n ‚à£ b ‚à® n ‚à£ c",theorem nat_is_prime_iff : Prime (n : Cardinal) ‚Üî n.Prime ,":= by
  simp only [Prime, Nat.prime_iff]
  refine and_congr (by simp) (and_congr ?_ ‚ü®fun h b c hbc => ?_, fun h b c hbc => ?_‚ü©)
  ¬∑ simp only [isUnit_iff, Nat.isUnit_iff]
    exact mod_cast Iff.rfl
  ¬∑ exact mod_cast h b c (mod_cast hbc)
  cases' lt_or_le (b * c) ‚Ñµ‚ÇÄ with h' h'
  ¬∑ rcases mul_lt_aleph0_iff.mp h' with (rfl | rfl | ‚ü®hb, hc‚ü©)
    ¬∑ simp
    ¬∑ simp
    lift b to ‚Ñï using hb
    lift c to ‚Ñï using hc
    exact mod_cast h b c (mod_cast hbc)
  rcases aleph0_le_mul_iff.mp h' with ‚ü®hb, hc, h‚Ñµ‚ÇÄ‚ü©
  have hn : (n : Cardinal) ‚â† 0 := by
    intro h
    rw [h, zero_dvd_iff, mul_eq_zero] at hbc
    cases hbc <;> contradiction
  wlog h‚Ñµ‚ÇÄb : ‚Ñµ‚ÇÄ ‚â§ b
  apply (this h c b _ _ hc hb h‚Ñµ‚ÇÄ.symm hn (h‚Ñµ‚ÇÄ.resolve_left h‚Ñµ‚ÇÄb)).symm <;> try assumption
  ¬∑ rwa [mul_comm] at hbc
  ¬∑ rwa [mul_comm] at h'
  ¬∑ exact Or.inl (dvd_of_le_of_aleph0_le hn ((nat_lt_aleph0 n).le.trans h‚Ñµ‚ÇÄb) h‚Ñµ‚ÇÄb)"
Mathlib/MeasureTheory/Measure/Typeclasses.lean,IsCompact.exists_open_superset_measure_lt_top',exists_open_superset_measure_lt_top',fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine IsCompact.induction_on h ?_ ?_? _? _
  ¬∑ use ‚àÖ
    simp [Superset]
  ¬∑ rintro s t hst ‚ü®U, htU, hUo, hU‚ü©
    exact ‚ü®U, hst.trans htU, hUo, hU‚ü©
  ¬∑ rintro s t ‚ü®U, hsU, hUo, hU‚ü© ‚ü®V, htV, hVo, hV‚ü©
    refine'
      ‚ü®U ‚à™ V, union_subset_union hsU htV, hUo.union hVo,
        (measure_union_le _ _).trans_lt <| ENNReal.add_lt_top.2 ‚ü®hU, hV‚ü©‚ü©
  ¬∑ intro x hx
    rcases (hŒº x hx).exists_mem_basis (nhds_basis_opens _) with ‚ü®U, ‚ü®hx, hUo‚ü©, hU‚ü©
    exact ‚ü®U, nhdsWithin_le_nhds (hUo.mem_nhds hx), U, Subset.rfl, hUo, hU‚ü©","error:  unknown identifier '_?'
error:  unsolved goals
Œ± : Type u_1
Œ≤ : Type u_2
Œ¥ : Type u_3
Œπ : Type u_4
inst‚úù¬π : TopologicalSpace Œ±
inst‚úù : MeasurableSpace Œ±
Œº : Measure Œ±
s : Set Œ±
h : IsCompact s
hŒº : ‚àÄ x ‚àà s, Œº.FiniteAtFilter (ùìù x)
‚ä¢ ‚àÉ U ‚äá s, IsOpen U ‚àß Œº U < ‚ä§","theorem exists_open_superset_measure_lt_top' (h : IsCompact s)
    (hŒº : ‚àÄ x ‚àà s, Œº.FiniteAtFilter (ùìù x)) : ‚àÉ U ‚äá s, IsOpen U ‚àß Œº U < ‚àû ",":= by
  refine IsCompact.induction_on h ?_ ?_ ?_ ?_
  ¬∑ use ‚àÖ
    simp [Superset]
  ¬∑ rintro s t hst ‚ü®U, htU, hUo, hU‚ü©
    exact ‚ü®U, hst.trans htU, hUo, hU‚ü©
  ¬∑ rintro s t ‚ü®U, hsU, hUo, hU‚ü© ‚ü®V, htV, hVo, hV‚ü©
    refine
      ‚ü®U ‚à™ V, union_subset_union hsU htV, hUo.union hVo,
        (measure_union_le _ _).trans_lt <| ENNReal.add_lt_top.2 ‚ü®hU, hV‚ü©‚ü©
  ¬∑ intro x hx
    rcases (hŒº x hx).exists_mem_basis (nhds_basis_opens _) with ‚ü®U, ‚ü®hx, hUo‚ü©, hU‚ü©
    exact ‚ü®U, nhdsWithin_le_nhds (hUo.mem_nhds hx), U, Subset.rfl, hUo, hU‚ü©"
Mathlib/Topology/MetricSpace/HausdorffDistance.lean,EMetric.infEdist_image,infEdist_image,75499222cc11ae5a47a99ba69c3066b962a0dc6f,":= by
  simp only [infEdist, inf·µ¢_image, hŒ¶.edist_eq]","error:  unknown identifier 'inf·µ¢_image'
error:  unsolved goals
Œπ : Sort u_1
Œ± : Type u
Œ≤ : Type v
inst‚úù¬π : PseudoEMetricSpace Œ±
inst‚úù : PseudoEMetricSpace Œ≤
x y : Œ±
s t : Set Œ±
Œ¶ : Œ± ‚Üí Œ≤
hŒ¶ : Isometry Œ¶
‚ä¢ ‚®Ö y ‚àà Œ¶ '' t, edist (Œ¶ x) y = ‚®Ö y ‚àà t, edist x y",theorem infEdist_image (hŒ¶ : Isometry Œ¶) : infEdist (Œ¶ x) (Œ¶ '' t) = infEdist x t ,":= by
  simp only [infEdist, iInf_image, hŒ¶.edist_eq]"
Mathlib/CategoryTheory/Abelian/Transfer.lean,CategoryTheory.AbelianOfAdjunction.hasCokernels,hasCokernels,cc1739507459696d3252d8621557ed8961dc17ad,":=
  letI := reflective F G i adj
  { has_colimit := fun _ ‚Ü¶ hasColimit_of_reflective _ F }","error:  unknown identifier 'reflective'
error:  unknown identifier 'hasColimit_of_reflective'
error:  function expected at
  hasCokernels
term has type
  HasCokernels ?m.86283
error:  unsolved goals
C : Type u‚ÇÅ
inst‚úù‚Å∑ : Category.{v, u‚ÇÅ} C
inst‚úù‚Å∂ : Preadditive C
inst‚úù‚Åµ : HasFiniteProducts C
D : Type u‚ÇÇ
inst‚úù‚Å¥ : Category.{v, u‚ÇÇ} D
inst‚úù¬≥ : Abelian D
F : C ‚•§ D
inst‚úù¬≤ : F.PreservesZeroMorphisms
G : D ‚•§ C
inst‚úù¬π : G.PreservesZeroMorphisms
inst‚úù : PreservesFiniteLimits G
i : F ‚ãô G ‚âÖ ùü≠ C
adj : G ‚ä£ F
this : HasKernels C
‚ä¢ Abelian C",theorem hasCokernels : HasCokernels C ,":=
  { has_colimit := fun f => by
      have : PreservesColimits G := adj.leftAdjointPreservesColimits
      have := NatIso.naturality_1 i f
      simp? at this says
        simp only [Functor.id_obj, Functor.comp_obj, Functor.comp_map, Functor.id_map] at this
      rw [‚Üê this]
      haveI : HasCokernel (G.map (F.map f) ‚â´ i.hom.app _) := Limits.hasCokernel_comp_iso _ _
      apply Limits.hasCokernel_epi_comp }"
Mathlib/Analysis/InnerProductSpace/Basic.lean,norm_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul,norm_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  have hx' : ‚Äñx‚Äñ ‚â† 0 := by simp [hx]
  have hr' : ‚Äñr‚Äñ ‚â† 0 := by simp [hr]
  rw [inner_smul_right, norm_mul, ‚Üê inner_self_re_eq_norm, inner_self_eq_norm_mul_norm, norm_smul]
  rw [‚Üê mul_assoc, ‚Üê div_div, mul_div_cancel _ hx', ‚Üê div_div, mul_comm, mul_div_cancel _ hr',
    div_self hx']","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.749317 * (?m.749334 / ?m.749317)
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Å¥ : _root_.RCLike ùïú
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
x : E
r : ùïú
hx : x ‚â† 0
hr : r ‚â† 0
hx' : ‚Äñx‚Äñ ‚â† 0
hr' : ‚Äñr‚Äñ ‚â† 0
‚ä¢ ‚Äñr‚Äñ * ‚Äñx‚Äñ * ‚Äñx‚Äñ / ‚Äñx‚Äñ / (‚Äñr‚Äñ * ‚Äñx‚Äñ) = 1","theorem norm_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul {x : E} {r : ùïú} (hx : x ‚â† 0)
    (hr : r ‚â† 0) : ‚Äñ‚ü™x, r ‚Ä¢ x‚ü´‚Äñ / (‚Äñx‚Äñ * ‚Äñr ‚Ä¢ x‚Äñ) = 1 ",":= by
  have hx' : ‚Äñx‚Äñ ‚â† 0 := by simp [hx]
  have hr' : ‚Äñr‚Äñ ‚â† 0 := by simp [hr]
  rw [inner_smul_right, norm_mul, ‚Üê inner_self_re_eq_norm, inner_self_eq_norm_mul_norm, norm_smul]
  rw [‚Üê mul_assoc, ‚Üê div_div, mul_div_cancel_right‚ÇÄ _ hx', ‚Üê div_div, mul_comm,
    mul_div_cancel_right‚ÇÄ _ hr', div_self hx']"
Mathlib/CategoryTheory/Limits/Presheaf.lean,CategoryTheory.final_toCostructuredArrow_comp_pre,final_toCostructuredArrow_comp_pre,a098b01d656bf4198a90120e3db58f6b84600f7a,":= by
  apply Functor.cofinal_of_isTerminal_colimit_comp_yoneda

  suffices IsTerminal (colimit ((c.toCostructuredArrow ‚ãô CostructuredArrow.pre F yoneda c.pt) ‚ãô
      CostructuredArrow.toOver yoneda c.pt)) by
    apply IsTerminal.isTerminalOfObj (overEquivPresheafCostructuredArrow c.pt).inverse
    apply IsTerminal.ofIso this
    refine ?_ ‚â™‚â´ (preservesColimitIso (overEquivPresheafCostructuredArrow c.pt).inverse _).symm
    apply HasColimit.isoOfNatIso
    exact isoWhiskerLeft _
      (CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow c.pt).isoCompInverse

  apply IsTerminal.ofIso Over.mkIdTerminal
  #adaptation_note
  let isc : IsColimit ((Over.forget _).mapCocone (colimit.cocone
      ((c.toCostructuredArrow.comp (CostructuredArrow.pre F yoneda c.pt)).comp
        (CostructuredArrow.toOver yoneda c.pt)))) := PreservesColimit.preserves
    (colimit.isColimit ((c.toCostructuredArrow ‚ãô CostructuredArrow.pre F yoneda c.pt) ‚ãô
      CostructuredArrow.toOver yoneda c.pt))
  exact Over.isoMk (hc.coconePointUniqueUpToIso isc) (hc.hom_ext fun i => by simp)","error:  Adaptation notes must be followed by a /-- comment -/
info:  Try this: #adaptation_note /-- comment -/","theorem final_toCostructuredArrow_comp_pre {c : Cocone (F ‚ãô yoneda)} (hc : IsColimit c) :
    Functor.Final (c.toCostructuredArrow ‚ãô CostructuredArrow.pre F yoneda c.pt) ",":= by
  apply Functor.cofinal_of_isTerminal_colimit_comp_yoneda

  suffices IsTerminal (colimit ((c.toCostructuredArrow ‚ãô CostructuredArrow.pre F yoneda c.pt) ‚ãô
      CostructuredArrow.toOver yoneda c.pt)) by
    apply IsTerminal.isTerminalOfObj (overEquivPresheafCostructuredArrow c.pt).inverse
    apply IsTerminal.ofIso this
    refine ?_ ‚â™‚â´ (preservesColimitIso (overEquivPresheafCostructuredArrow c.pt).inverse _).symm
    apply HasColimit.isoOfNatIso
    exact isoWhiskerLeft _
      (CostructuredArrow.toOverCompOverEquivPresheafCostructuredArrow c.pt).isoCompInverse

  apply IsTerminal.ofIso Over.mkIdTerminal
  let isc : IsColimit ((Over.forget _).mapCocone _) := PreservesColimit.preserves
    (colimit.isColimit ((c.toCostructuredArrow ‚ãô CostructuredArrow.pre F yoneda c.pt) ‚ãô
      CostructuredArrow.toOver yoneda c.pt))
  exact Over.isoMk (hc.coconePointUniqueUpToIso isc) (hc.hom_ext fun i => by simp)"
Mathlib/RingTheory/PrincipalIdealDomain.lean,IsPrincipalIdealRing.of_prime,IsPrincipalIdealRing.of_prime,0f225a7ff5582ff462b2ddd46bd386675bfefa78,":= by
  rw [‚Üê nonPrincipals_eq_empty_iff, Set.eq_empty_iff_forall_not_mem]
  intro J hJ
  obtain ‚ü®I, Ibad, -, Imax‚ü© := zorn_nonempty_partialOrder‚ÇÄ (nonPrincipals R) nonPrincipals_zorn _ hJ
  have Imax' : ‚àÄ {J}, I < J ‚Üí J.IsPrincipal :=
    by
    intro J hJ
    by_contra He
    exact hJ.ne (Imax _ ((nonPrincipals_def R).2 He) hJ.le).symm
  by_cases hI1 : I = ‚ä§
  ¬∑ subst hI1
    exact Ibad top_isPrincipal
  refine' Ibad (H I ‚ü®hI1, fun {x y} hxy => or_iff_not_imp_right.mpr fun hy => _‚ü©)
  obtain ‚ü®a, ha‚ü© : (I ‚äî span {y}).IsPrincipal :=
    Imax' (left_lt_sup.mpr (mt I.span_singleton_le_iff_mem.mp hy))
  suffices He : ¬¨(I.colon (span {y})).IsPrincipal
  ¬∑ rw [‚Üê Imax _ ((nonPrincipals_def R).2 He) fun a ha =>
        Ideal.mem_colon_singleton.2 (mul_mem_right _ _ ha)]
    exact Ideal.mem_colon_singleton.2 hxy
  rintro ‚ü®b, hb‚ü©
  refine (nonPrincipals_def _).1 Ibad ‚ü®a * b, ?_‚ü©
  refine'
    le_antisymm (Œ± := Ideal R) (fun i hi => _) <| (span_singleton_mul_span_singleton a b).ge.trans _
  ¬∑ have hisup : i ‚àà I ‚äî span {y} := Ideal.mem_sup_left hi
    have : y ‚àà I ‚äî span {y} := Ideal.mem_sup_right (Ideal.mem_span_singleton_self y)
    erw [ha, mem_span_singleton'] at hisup this
    obtain ‚ü®v, rfl‚ü© := this
    obtain ‚ü®u, rfl‚ü© := hisup
    have hucolon : u ‚àà I.colon (span {v * a}) :=
      by
      rw [Ideal.mem_colon_singleton, mul_comm v, ‚Üê mul_assoc]
      exact mul_mem_right _ _ hi
    erw [hb, mem_span_singleton'] at hucolon
    obtain ‚ü®z, rfl‚ü© := hucolon
    exact mem_span_singleton'.2 ‚ü®z, by ring‚ü©
  ¬∑ rw [‚Üê Ideal.submodule_span_eq, ‚Üê ha, Ideal.sup_mul, sup_le_iff,
      span_singleton_mul_span_singleton, mul_comm y, Ideal.span_singleton_le_iff_mem]
    exact ‚ü®mul_le_right, Ideal.mem_colon_singleton.1 <| hb.symm ‚ñ∏ Ideal.mem_span_singleton_self b‚ü©",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem IsPrincipalIdealRing.of_prime (H : ‚àÄ P : Ideal R, P.IsPrime ‚Üí P.IsPrincipal) :
    IsPrincipalIdealRing R ",":= by
  rw [‚Üê nonPrincipals_eq_empty_iff, Set.eq_empty_iff_forall_not_mem]
  intro J hJ
  obtain ‚ü®I, Ibad, -, Imax‚ü© := zorn_nonempty_partialOrder‚ÇÄ (nonPrincipals R) nonPrincipals_zorn _ hJ
  have Imax' : ‚àÄ {J}, I < J ‚Üí J.IsPrincipal := by
    intro J hJ
    by_contra He
    exact hJ.ne (Imax _ ((nonPrincipals_def R).2 He) hJ.le).symm
  by_cases hI1 : I = ‚ä§
  ¬∑ subst hI1
    exact Ibad top_isPrincipal
  refine Ibad (H I ‚ü®hI1, fun {x y} hxy => or_iff_not_imp_right.mpr fun hy => ?_‚ü©)
  obtain ‚ü®a, ha‚ü© : (I ‚äî span {y}).IsPrincipal :=
    Imax' (left_lt_sup.mpr (mt I.span_singleton_le_iff_mem.mp hy))
  suffices He : ¬¨(I.colon (span {y})).IsPrincipal by
    rw [‚Üê Imax _ ((nonPrincipals_def R).2 He) fun a ha =>
        Ideal.mem_colon_singleton.2 (mul_mem_right _ _ ha)]
    exact Ideal.mem_colon_singleton.2 hxy
  rintro ‚ü®b, hb‚ü©
  refine (nonPrincipals_def _).1 Ibad ‚ü®a * b, ?_‚ü©
  refine
    le_antisymm (Œ± := Ideal R) (fun i hi => ?_) <|
      (span_singleton_mul_span_singleton a b).ge.trans ?_
  ¬∑ have hisup : i ‚àà I ‚äî span {y} := Ideal.mem_sup_left hi
    have : y ‚àà I ‚äî span {y} := Ideal.mem_sup_right (Ideal.mem_span_singleton_self y)
    erw [ha, mem_span_singleton'] at hisup this
    obtain ‚ü®v, rfl‚ü© := this
    obtain ‚ü®u, rfl‚ü© := hisup
    have hucolon : u ‚àà I.colon (span {v * a}) := by
      rw [Ideal.mem_colon_singleton, mul_comm v, ‚Üê mul_assoc]
      exact mul_mem_right _ _ hi
    erw [hb, mem_span_singleton'] at hucolon
    obtain ‚ü®z, rfl‚ü© := hucolon
    exact mem_span_singleton'.2 ‚ü®z, by ring‚ü©
  ¬∑ rw [‚Üê Ideal.submodule_span_eq, ‚Üê ha, Ideal.sup_mul, sup_le_iff,
      span_singleton_mul_span_singleton, mul_comm y, Ideal.span_singleton_le_iff_mem]
    exact ‚ü®mul_le_right, Ideal.mem_colon_singleton.1 <| hb.symm ‚ñ∏ Ideal.mem_span_singleton_self b‚ü©"
Mathlib/GroupTheory/PGroup.lean,IsPGroup.center_nontrivial,center_nontrivial,8c7e2497d6b5ded2cb20ad30538ebffa5560f7a2,":= by
  classical
    have := (hG.of_equiv ConjAct.toConjAct).exists_fixed_point_of_prime_dvd_card_of_fixed_point G
    rw [ConjAct.fixedPoints_eq_center] at this
    have dvd : p ‚à£ Nat.card G := by
      obtain ‚ü®n, hn0, hn‚ü© := hG.nontrivial_iff_card.mp inferInstance
      exact hn.symm ‚ñ∏ dvd_pow_self _ (ne_of_gt hn0)
    obtain ‚ü®g, hg‚ü© := this dvd (Subgroup.center G).one_mem
    exact ‚ü®‚ü®1, ‚ü®g, hg.1‚ü©, mt Subtype.ext_iff.mp hg.2‚ü©‚ü©","error:  failed to synthesize
  Fintype G
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  Fintype G
use `set_option diagnostics true` to get diagnostic information
error:  rcases tactic failed: x‚úù : ?m.61822 is not an inductive datatype
error:  application type mismatch
  @this dvd
argument
  dvd
has type
  p ‚à£ Nat.card G : Prop
but is expected to have type
  p ‚à£ card G : Prop
error:  unsolved goals
case refine_1
p : ‚Ñï
G : Type u_1
inst‚úù‚Å¥ : Group G
hG : IsPGroup p G
hp : Fact (Nat.Prime p)
Œ± : Type u_2
inst‚úù¬≥ : MulAction G Œ±
inst‚úù¬≤ : Fintype Œ±
inst‚úù¬π : Nontrivial G
inst‚úù : Finite G
‚ä¢ Fintype G
error:  function expected at
  center_nontrivial
term has type
  Nontrivial ‚Ü•(Subgroup.center ?m.62990)
error:  unsolved goals
p : ‚Ñï
G : Type u_1
inst‚úù‚Å¥ : Group G
hG : IsPGroup p G
hp : Fact (Nat.Prime p)
Œ± : Type u_2
inst‚úù¬≥ : MulAction G Œ±
inst‚úù¬≤ : Fintype Œ±
inst‚úù¬π : Nontrivial G
inst‚úù : Finite G
‚ä¢ ‚ä• < Subgroup.center G
error:  function expected at
  center_nontrivial
term has type
  Nontrivial ‚Ü•(center ?m.86785)",theorem center_nontrivial [Nontrivial G] [Finite G] : Nontrivial (Subgroup.center G) ,":= by
  classical
    cases nonempty_fintype G
    have := (hG.of_equiv ConjAct.toConjAct).exists_fixed_point_of_prime_dvd_card_of_fixed_point G
    rw [ConjAct.fixedPoints_eq_center] at this
    have dvd : p ‚à£ card G := by
      obtain ‚ü®n, hn0, hn‚ü© := hG.nontrivial_iff_card.mp inferInstance
      exact hn.symm ‚ñ∏ dvd_pow_self _ (ne_of_gt hn0)
    obtain ‚ü®g, hg‚ü© := this dvd (Subgroup.center G).one_mem
    exact ‚ü®‚ü®1, ‚ü®g, hg.1‚ü©, mt Subtype.ext_iff.mp hg.2‚ü©‚ü©"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.hasIntegral_GP_pderiv,hasIntegral_GP_pderiv,3aed923ebb883491f0e657917c8bde69a3d10149,":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine' HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le _ _ _ s hs _ _
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine' .and _ (.and _ _)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) :=
          inter_subset_inter_left _ (closedBall_subset_closedBall hŒ¥.2)
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := (add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ))
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine' this.eventually (ge_mem_nhds _)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine' ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ _‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine' (norm_sub_le _ _).trans (add_le_add _ _)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine' (mul_le_mul_of_nonneg_right _ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
          _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine' (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans _
      refine' (mul_le_mul_of_nonneg_right _ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine' prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => _
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := (dist_le_pi_dist J.upper J.lower (i.succAbove j))
        _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
        _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1 ((Hd x hx).def Œµ'0) with
      ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine' ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => _‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine' (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ _) (hJc rfl)).trans _
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      gcongr
      exact ENNReal.toReal_nonneg","error:  dsimp made no progress
error:  invalid field 'def', the environment does not contain 'HasFDerivWithinAt.def'
  Hd x hx
has type
  HasFDerivWithinAt f (f' x) (Box.Icc I) x
error:  invalid field 'def', the environment does not contain 'HasFDerivAtFilter.def'
  Hd x hx
has type
  HasFDerivAtFilter f (f' x) x (ùìù[Box.Icc I] x)
error:  type mismatch
  HŒ¥ ?m.83042
has type
  ?m.83041 ‚àà ?m.81872 : Prop
but is expected to have type
  ‚Äñf y - ?m.83027 - ?m.82967 (y - x)‚Äñ ‚â§ Œµ' * ‚Äñy - x‚Äñ : Prop
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  E
error:  unsolved goals
case refine'_4.intro.intro.intro.intro.refine'_2.h‚ÇÇ
E : Type u
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
n : ‚Ñï
inst‚úù : CompleteSpace E
I : Box (Fin (n + 1))
i‚úù : Fin (n + 1)
f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E
f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E
s : Set (Fin (n + 1) ‚Üí ‚Ñù)
hs : s.Countable
Hs : ‚àÄ x ‚àà s, ContinuousWithinAt f (Box.Icc I) x
Hd : ‚àÄ x ‚àà Box.Icc I \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x
i : Fin (n + 1)
Hc : ContinuousOn f (Box.Icc I)
fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J ‚Ü¶ integral J GP (fun x ‚Ü¶ f (i.insertNth y x)) BoxAdditiveMap.volume
fb : ‚Üë(Set.Icc (I.lower i) (I.upper i)) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x ‚Ü¶ ‚ãØ.toBoxAdditive
F : Fin (n + 1) ‚Üí·µá·µÉ[‚ÜëI] E := BoxAdditiveMap.upperSubLower I i fI fb ‚ãØ
c : ‚Ñù‚â•0
x : Fin (n + 1) ‚Üí ‚Ñù
hx : x ‚àà Box.Icc I \ s
Œµ : ‚Ñù
Œµ0 : Œµ > 0
Œµ' : ‚Ñù
Œµ'0 : 0 < Œµ'
hlt : 2 * ‚Üëc * Œµ' < Œµ
Œ¥ : ‚Ñù
Œ¥0 : 0 < Œ¥
HŒ¥ : closedBall ?m.81703 Œ¥ ‚à© ?m.81805 ‚äÜ ?m.81872
J : Box (Fin (n + 1))
hle : J ‚â§ I
hJŒ¥ : Box.Icc J ‚äÜ closedBall x Œ¥
hxJ : x ‚àà Box.Icc J
hJc : GP.bDistortion = true ‚Üí J.distortion ‚â§ c
‚ä¢ volume.toBoxAdditive J ‚â§ (volume.toBoxAdditive.restrict ‚ÜëI ‚ãØ) J","theorem hasIntegral_GP_pderiv (f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E)
    (f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E) (s : Set (Fin (n + 1) ‚Üí ‚Ñù))
    (hs : s.Countable) (Hs : ‚àÄ x ‚àà s, ContinuousWithinAt f (Box.Icc I) x)
    (Hd : ‚àÄ x ‚àà (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :
    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume
      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))
          BoxAdditiveMap.volume -
        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))
          BoxAdditiveMap.volume) ",":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le ?_ ?_ _ s hs ?_ ?_
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine .and ?_ (.and ?_ ?_)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) := by gcongr; exact hŒ¥.2
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ)
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine this.eventually (ge_mem_nhds ?_)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ ?_‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp [F]
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine (norm_sub_le _ _).trans (add_le_add ?_ ?_)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine (mul_le_mul_of_nonneg_right ?_ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
          _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans ?_
      refine (mul_le_mul_of_nonneg_right ?_ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => ?_
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := dist_le_pi_dist J.upper J.lower (i.succAbove j)
        _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
        _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1
      ((Hd x hx).isLittleO.def Œµ'0) with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => ?_‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ ?_) (hJc rfl)).trans ?_
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg"
Mathlib/Topology/FiberBundle/Basic.lean,FiberBundle.exists_trivialization_Icc_subset,FiberBundle.exists_trivialization_Icc_subset,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  obtain ‚ü®ea, hea‚ü© : ‚àÉ ea : Trivialization F (œÄ F E), a ‚àà ea.baseSet :=
    ‚ü®trivializationAt F E a, mem_baseSet_trivializationAt F E a‚ü©
  cases' lt_or_le b a with hab hab
  ¬∑ exact ‚ü®ea, by simp [*]‚ü©
  set s : Set B := { x ‚àà Icc a b | ‚àÉ e : Trivialization F (œÄ F E), Icc a x ‚äÜ e.baseSet }
  have ha : a ‚àà s := ‚ü®left_mem_Icc.2 hab, ea, by simp [hea]‚ü©
  have sne : s.Nonempty := ‚ü®a, ha‚ü©
  have hsb : b ‚àà upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := ‚ü®b, hsb‚ü©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c ‚àà Icc a b := ‚ü®hsc.1 ha, hsc.2 hsb‚ü©
  obtain ‚ü®-, ec : Trivialization F (œÄ F E), hec : Icc a c ‚äÜ ec.baseSet‚ü© : c ‚àà s := by
    rcases hc.1.eq_or_lt with heq | hlt
    ¬∑ rwa [‚Üê heq]
    refine ‚ü®hc, ?_‚ü©
    obtain ‚ü®ec, hc‚ü© : ‚àÉ ec : Trivialization F (œÄ F E), c ‚àà ec.baseSet :=
      ‚ü®trivializationAt F E c, mem_baseSet_trivializationAt F E c‚ü©
    obtain ‚ü®c', hc', hc'e‚ü© : ‚àÉ c' ‚àà Ico a c, Ioc c' c ‚äÜ ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain ‚ü®d, ‚ü®hdab, ead, had‚ü©, hd‚ü© : ‚àÉ d ‚àà s, d ‚àà Ioc c' c := hsc.exists_between hc'.2
    refine ‚ü®ead.piecewiseLe ec d (had ‚ü®hdab.1, le_rfl‚ü©) (hc'e hd), subset_ite.2 ?_‚ü©
    exact ‚ü®fun x hx => had ‚ü®hx.1.1, hx.2‚ü©, fun x hx => hc'e ‚ü®hd.1.trans (not_le.1 hx.2), hx.1.2‚ü©‚ü©
  rcases hc.2.eq_or_lt with heq | hlt
  ¬∑ exact ‚ü®ec, heq ‚ñ∏ hec‚ü©
  rsuffices ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, ‚àÉ e : Trivialization F (œÄ F E), Icc a d ‚äÜ e.baseSet
  ¬∑ exact ((hsc.1 ‚ü®‚ü®hc.1.trans hdcb.1.le, hdcb.2‚ü©, hd‚ü©).not_lt hdcb.1).elim
  obtain ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, Ico c d ‚äÜ ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec ‚ü®hc.1, le_rfl‚ü©))
  have had : Ico a d ‚äÜ ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  ¬∑ obtain ‚ü®ed, hed‚ü© : ‚àÉ ed : Trivialization F (œÄ F E), d ‚àà ed.baseSet :=
      ‚ü®trivializationAt F E d, mem_baseSet_trivializationAt F E d‚ü©
    refine ‚ü®d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono (inter_subset_right _ _) (inter_subset_right _ _)), fun x hx => ?_‚ü©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr ‚ü®hed, hdcb.1‚ü©, Or.inl ‚ü®had ‚ü®hx.1, hxd‚ü©, hxd‚ü©]
  ¬∑ rw [disjoint_left] at he
    push_neg at he
    rcases he with ‚ü®d', hdd' : d' < d, hd'c‚ü©
    exact ‚ü®d', ‚ü®hd'c, hdd'.le.trans hdcb.2‚ü©, ec, (Icc_subset_Ico_right hdd').trans had‚ü©","error:  function expected at
  inter_subset_right ?m.16125
term has type
  ?m.16124 ‚àà ?m.16123
error:  function expected at
  inter_subset_right ?m.16167
term has type
  ?m.16166 ‚àà ?m.16165","theorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]
    [OrderTopology B] [FiberBundle F E] (a b : B) :
    ‚àÉ e : Trivialization F (œÄ F E), Icc a b ‚äÜ e.baseSet ",":= by
  obtain ‚ü®ea, hea‚ü© : ‚àÉ ea : Trivialization F (œÄ F E), a ‚àà ea.baseSet :=
    ‚ü®trivializationAt F E a, mem_baseSet_trivializationAt F E a‚ü©
  cases' lt_or_le b a with hab hab
  ¬∑ exact ‚ü®ea, by simp [*]‚ü©
  set s : Set B := { x ‚àà Icc a b | ‚àÉ e : Trivialization F (œÄ F E), Icc a x ‚äÜ e.baseSet }
  have ha : a ‚àà s := ‚ü®left_mem_Icc.2 hab, ea, by simp [hea]‚ü©
  have sne : s.Nonempty := ‚ü®a, ha‚ü©
  have hsb : b ‚àà upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := ‚ü®b, hsb‚ü©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c ‚àà Icc a b := ‚ü®hsc.1 ha, hsc.2 hsb‚ü©
  obtain ‚ü®-, ec : Trivialization F (œÄ F E), hec : Icc a c ‚äÜ ec.baseSet‚ü© : c ‚àà s := by
    rcases hc.1.eq_or_lt with heq | hlt
    ¬∑ rwa [‚Üê heq]
    refine ‚ü®hc, ?_‚ü©
    obtain ‚ü®ec, hc‚ü© : ‚àÉ ec : Trivialization F (œÄ F E), c ‚àà ec.baseSet :=
      ‚ü®trivializationAt F E c, mem_baseSet_trivializationAt F E c‚ü©
    obtain ‚ü®c', hc', hc'e‚ü© : ‚àÉ c' ‚àà Ico a c, Ioc c' c ‚äÜ ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain ‚ü®d, ‚ü®hdab, ead, had‚ü©, hd‚ü© : ‚àÉ d ‚àà s, d ‚àà Ioc c' c := hsc.exists_between hc'.2
    refine ‚ü®ead.piecewiseLe ec d (had ‚ü®hdab.1, le_rfl‚ü©) (hc'e hd), subset_ite.2 ?_‚ü©
    exact ‚ü®fun x hx => had ‚ü®hx.1.1, hx.2‚ü©, fun x hx => hc'e ‚ü®hd.1.trans (not_le.1 hx.2), hx.1.2‚ü©‚ü©
  rcases hc.2.eq_or_lt with heq | hlt
  ¬∑ exact ‚ü®ec, heq ‚ñ∏ hec‚ü©
  rsuffices ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, ‚àÉ e : Trivialization F (œÄ F E), Icc a d ‚äÜ e.baseSet
  ¬∑ exact ((hsc.1 ‚ü®‚ü®hc.1.trans hdcb.1.le, hdcb.2‚ü©, hd‚ü©).not_lt hdcb.1).elim
  obtain ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, Ico c d ‚äÜ ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec ‚ü®hc.1, le_rfl‚ü©))
  have had : Ico a d ‚äÜ ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  ¬∑ obtain ‚ü®ed, hed‚ü© : ‚àÉ ed : Trivialization F (œÄ F E), d ‚àà ed.baseSet :=
      ‚ü®trivializationAt F E d, mem_baseSet_trivializationAt F E d‚ü©
    refine ‚ü®d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono inter_subset_right inter_subset_right), fun x hx => ?_‚ü©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr ‚ü®hed, hdcb.1‚ü©, Or.inl ‚ü®had ‚ü®hx.1, hxd‚ü©, hxd‚ü©]
  ¬∑ rw [disjoint_left] at he
    push_neg at he
    rcases he with ‚ü®d', hdd' : d' < d, hd'c‚ü©
    exact ‚ü®d', ‚ü®hd'c, hdd'.le.trans hdcb.2‚ü©, ec, (Icc_subset_Ico_right hdd').trans had‚ü©"
Mathlib/Probability/Kernel/Disintegration/Density.lean,ProbabilityTheory.kernel.densityProcess_mono_set,densityProcess_mono_set,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  unfold densityProcess
  by_cases h0 : ŒΩ a (countablePartitionSet n x) = 0
  ¬∑ rw [h0, ENNReal.toReal_div, ENNReal.toReal_div]
    simp
  have h_ne_top : ‚àÄ s,
      Œ∫ a (countablePartitionSet n x √óÀ¢ s) / ŒΩ a (countablePartitionSet n x) ‚â† ‚ä§ := by
    intro s
    rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    refine fun h_top ‚Ü¶ eq_top_mono ?_ h_top
    exact meas_countablePartitionSet_le_of_fst_le hŒ∫ŒΩ n a x s
  rw [ENNReal.toReal_le_toReal (h_ne_top s) (h_ne_top s')]
  gcongr
  simp [prod_subset_prod_iff, subset_rfl, h]",error:  no goals to be solved,"lemma densityProcess_mono_set (hŒ∫ŒΩ : fst Œ∫ ‚â§ ŒΩ) (n : ‚Ñï) (a : Œ±) (x : Œ≥)
    {s s' : Set Œ≤} (h : s ‚äÜ s') :
    densityProcess Œ∫ ŒΩ n a x s ‚â§ densityProcess Œ∫ ŒΩ n a x s' ",":= by
  unfold densityProcess
  by_cases h0 : ŒΩ a (countablePartitionSet n x) = 0
  ¬∑ rw [h0, ENNReal.toReal_div, ENNReal.toReal_div]
    simp
  have h_ne_top : ‚àÄ s,
      Œ∫ a (countablePartitionSet n x √óÀ¢ s) / ŒΩ a (countablePartitionSet n x) ‚â† ‚ä§ := by
    intro s
    rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    refine fun h_top ‚Ü¶ eq_top_mono ?_ h_top
    exact meas_countablePartitionSet_le_of_fst_le hŒ∫ŒΩ n a x s
  rw [ENNReal.toReal_le_toReal (h_ne_top s) (h_ne_top s')]
  gcongr"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,7956d7f062ae28fc75693c8b8e8a3b9650a2faad,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a
  exact ‚ü®_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b
  exact ‚ü®_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine' ‚ü®g + dg, fun y => _, funext hgf‚ü©
    ¬∑ have hay : a < (g + dg) y := by
        rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
        ¬∑ refine' (lt_add_iff_pos_right _).2 _
          calc
            0 < c - g y := sub_pos.2 hac
            _ = dg y := (dga rfl).symm
        ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      refine' ‚ü®x, hxy.le, _‚ü©
      rcases le_total c (g y) with hc | hc
      ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
      ¬∑ calc
          g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
          _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine' ‚ü®g - dg, fun y => _, funext hgf‚ü©
  ¬∑ have hyb : (g - dg) y < b := by
      rcases (hgb y).eq_or_lt with (rfl | hlt)
      ¬∑ refine' (sub_lt_self_iff _).2 _
        calc
          0 < g y - c := sub_pos.2 hcb
          _ = dg y := (dgb rfl).symm
      ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
    rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
    cases' lt_or_le c (g y) with hc hc
    ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
      ¬∑ refine' ‚ü®x, xu, _, hyxu.le‚ü©
        calc
          f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
      ¬∑ have hay : a < (g - dg) y := by
          calc
            a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
            _ < g y - (b - c) := sub_lt_sub_right hc _
            _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
        rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
        exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
    ¬∑ refine' ‚ü®xl y, xu, _, hyxu.le‚ü©
      simp [dg0 (Or.inr hc), hxl]","error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.hasIntegral_GP_pderiv,hasIntegral_GP_pderiv,98e78f90ec6f93268c84b413fdae7dce5cbee0e6,":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine' HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le _ _ _ s hs _ _
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine' .and _ (.and _ _)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) :=
          inter_subset_inter_left _ (closedBall_subset_closedBall hŒ¥.2)
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := (add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ))
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine' this.eventually (ge_mem_nhds _)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine' ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ _‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine' (norm_sub_le _ _).trans (add_le_add _ _)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine' (mul_le_mul_of_nonneg_right _ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
          _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine' (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans _
      refine' (mul_le_mul_of_nonneg_right _ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine' prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => _
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := (dist_le_pi_dist J.upper J.lower (i.succAbove j))
        _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
        _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
        _ ‚â§ 1 / 2 + 1 / 2 := (add_le_add hŒ¥12 hŒ¥12)
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases(nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1 ((Hd x hx).def Œµ'0) with
      ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine' ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => _‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine' (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ _) (hJc rfl)).trans _
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg","error:  dsimp made no progress
error:  invalid field 'def', the environment does not contain 'HasFDerivWithinAt.def'
  Hd x hx
has type
  HasFDerivWithinAt f (f' x) (Box.Icc I) x
error:  invalid field 'def', the environment does not contain 'HasFDerivAtFilter.def'
  Hd x hx
has type
  HasFDerivAtFilter f (f' x) x (ùìù[Box.Icc I] x)
error:  type mismatch
  HŒ¥ ?m.83042
has type
  ?m.83041 ‚àà ?m.81872 : Prop
but is expected to have type
  ‚Äñf y - ?m.83027 - ?m.82967 (y - x)‚Äñ ‚â§ Œµ' * ‚Äñy - x‚Äñ : Prop
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  E","theorem hasIntegral_GP_pderiv (f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E)
    (f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E) (s : Set (Fin (n + 1) ‚Üí ‚Ñù))
    (hs : s.Countable) (Hs : ‚àÄ x ‚àà s, ContinuousWithinAt f (Box.Icc I) x)
    (Hd : ‚àÄ x ‚àà (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :
    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume
      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))
          BoxAdditiveMap.volume -
        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))
          BoxAdditiveMap.volume) ",":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le ?_ ?_ _ s hs ?_ ?_
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine .and ?_ (.and ?_ ?_)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) := by gcongr; exact hŒ¥.2
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ)
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine this.eventually (ge_mem_nhds ?_)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ ?_‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp [F]
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine (norm_sub_le _ _).trans (add_le_add ?_ ?_)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine (mul_le_mul_of_nonneg_right ?_ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
          _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans ?_
      refine (mul_le_mul_of_nonneg_right ?_ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => ?_
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := dist_le_pi_dist J.upper J.lower (i.succAbove j)
        _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
        _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1
      ((Hd x hx).isLittleO.def Œµ'0) with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => ?_‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ ?_) (hJc rfl)).trans ?_
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg"
Mathlib/Algebra/Module/Torsion.lean,Ideal.CompleteLattice.Independent.linear_independent',CompleteLattice.Independent.linear_independent',6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  refine linearIndependent_iff_not_smul_mem_span.mpr fun i r hi => ?_
  replace hv := CompleteLattice.independent_def.mp hv i
  simp only [iSup_subtype', ‚Üê Submodule.span_range_eq_iSup, disjoint_iff] at hv
  have : r ‚Ä¢ v i ‚àà ‚ä• := by
    rw [‚Üê hv, Submodule.mem_inf]
    refine' ‚ü®Submodule.mem_span_singleton.mpr ‚ü®r, rfl‚ü©, _‚ü©
    convert hi
    ext
    simp
  rw [‚Üê Submodule.mem_bot R, ‚Üê h_ne_zero i]
  simpa using this","error:  typeclass instance problem is stuck, it is often due to metavariables
  Membership M ?m.16614","theorem CompleteLattice.Independent.linear_independent' {Œπ R M : Type*} {v : Œπ ‚Üí M} [Ring R]
    [AddCommGroup M] [Module R M] (hv : CompleteLattice.Independent fun i => R ‚àô v i)
    (h_ne_zero : ‚àÄ i, Ideal.torsionOf R M (v i) = ‚ä•) : LinearIndependent R v ",":= by
  refine linearIndependent_iff_not_smul_mem_span.mpr fun i r hi => ?_
  replace hv := CompleteLattice.independent_def.mp hv i
  simp only [iSup_subtype', ‚Üê Submodule.span_range_eq_iSup (Œπ := Subtype _), disjoint_iff] at hv
  have : r ‚Ä¢ v i ‚àà (‚ä• : Submodule R M) := by
    rw [‚Üê hv, Submodule.mem_inf]
    refine ‚ü®Submodule.mem_span_singleton.mpr ‚ü®r, rfl‚ü©, ?_‚ü©
    convert hi
    ext
    simp
  rw [‚Üê Submodule.mem_bot R, ‚Üê h_ne_zero i]
  simpa using this"
Mathlib/Analysis/Calculus/BumpFunction/FiniteDimension.lean,exists_smooth_tsupport_subset,exists_smooth_tsupport_subset,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  obtain ‚ü®d : ‚Ñù, d_pos : 0 < d, hd : Euclidean.closedBall x d ‚äÜ s‚ü© :=
    Euclidean.nhds_basis_closedBall.mem_iff.1 hs
  let c : ContDiffBump (toEuclidean x) :=
    { rIn := d / 2
      rOut := d
      rIn_pos := half_pos d_pos
      rIn_lt_rOut := half_lt_self d_pos }
  let f : E ‚Üí ‚Ñù := c ‚àò toEuclidean
  have f_supp : f.support ‚äÜ Euclidean.ball x d := by
    intro y hy
    have : toEuclidean y ‚àà Function.support c := by
      simpa only [Function.mem_support, Function.comp_apply, Ne] using hy
    rwa [c.support_eq] at this
  have f_tsupp : tsupport f ‚äÜ Euclidean.closedBall x d := by
    rw [tsupport, ‚Üê Euclidean.closure_ball _ d_pos.ne']
    exact closure_mono f_supp
  refine ‚ü®f, f_tsupp.trans hd, ?_,? _,? _?, _‚ü©
  ¬∑ refine isCompact_of_isClosed_isBounded isClosed_closure ?_
    have : IsBounded (Euclidean.closedBall x d) := Euclidean.isCompact_closedBall.isBounded
    refine this.subset (Euclidean.isClosed_closedBall.closure_subset_iff.2 ?_)
    exact f_supp.trans Euclidean.ball_subset_closedBall
  ¬∑ apply c.contDiff.comp
    exact ContinuousLinearEquiv.contDiff _
  ¬∑ rintro t ‚ü®y, rfl‚ü©
    exact ‚ü®c.nonneg, c.le_one‚ü©
  ¬∑ apply c.one_of_mem_closedBall
    apply mem_closedBall_self
    exact (half_pos d_pos).le","error:  don't know how to synthesize placeholder for argument 'right'
context:
E : Type u_1
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
inst‚úù : FiniteDimensional ‚Ñù E
s : Set E
x : E
hs : s ‚àà ùìù x
d : ‚Ñù
d_pos : 0 < d
hd : Euclidean.closedBall x d ‚äÜ s
c : ContDiffBump (toEuclidean x) := { rIn := d / 2, rOut := d, rIn_pos := ‚ãØ, rIn_lt_rOut := ‚ãØ }
f : E ‚Üí ‚Ñù := ‚Üëc ‚àò ‚áëtoEuclidean
f_supp : support f ‚äÜ Euclidean.ball x d
f_tsupp : tsupport f ‚äÜ Euclidean.closedBall x d
‚ä¢ f x = 1
error:  unsolved goals
case intro.intro
E : Type u_1
inst‚úù¬≤ : NormedAddCommGroup E
inst‚úù¬π : NormedSpace ‚Ñù E
inst‚úù : FiniteDimensional ‚Ñù E
s : Set E
x : E
hs : s ‚àà ùìù x
d : ‚Ñù
d_pos : 0 < d
hd : Euclidean.closedBall x d ‚äÜ s
c : ContDiffBump (toEuclidean x) := { rIn := d / 2, rOut := d, rIn_pos := ‚ãØ, rIn_lt_rOut := ‚ãØ }
f : E ‚Üí ‚Ñù := ‚Üëc ‚àò ‚áëtoEuclidean
f_supp : support f ‚äÜ Euclidean.ball x d
f_tsupp : tsupport f ‚äÜ Euclidean.closedBall x d
‚ä¢ ‚àÉ f, tsupport f ‚äÜ s ‚àß HasCompactSupport f ‚àß ContDiff ‚Ñù ‚ä§ f ‚àß range f ‚äÜ Icc 0 1 ‚àß f x = 1","theorem exists_smooth_tsupport_subset {s : Set E} {x : E} (hs : s ‚àà ùìù x) :
    ‚àÉ f : E ‚Üí ‚Ñù,
      tsupport f ‚äÜ s ‚àß HasCompactSupport f ‚àß ContDiff ‚Ñù ‚ä§ f ‚àß range f ‚äÜ Icc 0 1 ‚àß f x = 1 ",":= by
  obtain ‚ü®d : ‚Ñù, d_pos : 0 < d, hd : Euclidean.closedBall x d ‚äÜ s‚ü© :=
    Euclidean.nhds_basis_closedBall.mem_iff.1 hs
  let c : ContDiffBump (toEuclidean x) :=
    { rIn := d / 2
      rOut := d
      rIn_pos := half_pos d_pos
      rIn_lt_rOut := half_lt_self d_pos }
  let f : E ‚Üí ‚Ñù := c ‚àò toEuclidean
  have f_supp : f.support ‚äÜ Euclidean.ball x d := by
    intro y hy
    have : toEuclidean y ‚àà Function.support c := by
      simpa only [Function.mem_support, Function.comp_apply, Ne] using hy
    rwa [c.support_eq] at this
  have f_tsupp : tsupport f ‚äÜ Euclidean.closedBall x d := by
    rw [tsupport, ‚Üê Euclidean.closure_ball _ d_pos.ne']
    exact closure_mono f_supp
  refine ‚ü®f, f_tsupp.trans hd, ?_, ?_, ?_, ?_‚ü©
  ¬∑ refine isCompact_of_isClosed_isBounded isClosed_closure ?_
    have : IsBounded (Euclidean.closedBall x d) := Euclidean.isCompact_closedBall.isBounded
    refine this.subset (Euclidean.isClosed_closedBall.closure_subset_iff.2 ?_)
    exact f_supp.trans Euclidean.ball_subset_closedBall
  ¬∑ apply c.contDiff.comp
    exact ContinuousLinearEquiv.contDiff _
  ¬∑ rintro t ‚ü®y, rfl‚ü©
    exact ‚ü®c.nonneg, c.le_one‚ü©
  ¬∑ apply c.one_of_mem_closedBall
    apply mem_closedBall_self
    exact (half_pos d_pos).le"
Mathlib/MeasureTheory/Decomposition/SignedLebesgue.lean,MeasureTheory.SignedMeasure.integrable_rnDeriv,integrable_rnDeriv,1d139ad79ce099e15226e6bbd1cf8e7d24be07d3,":= by
  refine Integrable.sub ?_ ?_ <;>
    ¬∑ constructor
      ¬∑ apply Measurable.aestronglyMeasurable
        fun_prop
      exact hasFiniteIntegral_toReal_of_lintegral_ne_top (lintegral_rnDeriv_lt_top _ Œº).ne","error:  `fun_prop` was unable to prove `Measurable fun x ‚Ü¶ (s.toJordanDecomposition.posPart.rnDeriv Œº x).toReal`

Try running with discharger `fun_prop (disch:=aesop)` or with a different discharger tactic like `assumption`, `linarith`, `omega`.
Sometimes it is useful to run `fun_prop (disch:=trace_state; sorry)` which will print all the necessary subgoals for `fun_prop` to succeed.

Potential issues to fix:
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a ‚Ü¶ s.toJordanDecomposition.posPart.rnDeriv Œº a
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem Continuous.measurable.
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a ‚Ü¶ s.toJordanDecomposition.posPart.rnDeriv Œº a
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem Continuous.measurable.

For more detailed information use `set_option trace.Meta.Tactic.fun_prop true`
error:  `fun_prop` was unable to prove `Measurable fun x ‚Ü¶ (s.toJordanDecomposition.negPart.rnDeriv Œº x).toReal`

Try running with discharger `fun_prop (disch:=aesop)` or with a different discharger tactic like `assumption`, `linarith`, `omega`.
Sometimes it is useful to run `fun_prop (disch:=trace_state; sorry)` which will print all the necessary subgoals for `fun_prop` to succeed.

Potential issues to fix:
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a ‚Ü¶ s.toJordanDecomposition.negPart.rnDeriv Œº a
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem Continuous.measurable.
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a ‚Ü¶ s.toJordanDecomposition.negPart.rnDeriv Œº a
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem Continuous.measurable.

For more detailed information use `set_option trace.Meta.Tactic.fun_prop true`",theorem integrable_rnDeriv (s : SignedMeasure Œ±) (Œº : Measure Œ±) : Integrable (rnDeriv s Œº) Œº ,":= by
  refine Integrable.sub ?_ ?_ <;>
    ¬∑ constructor
      ¬∑ 
        exact (((Measure.measurable_rnDeriv _ Œº
          ).ennreal_toNNReal).coe_nnreal_real).aestronglyMeasurable
      exact hasFiniteIntegral_toReal_of_lintegral_ne_top (lintegral_rnDeriv_lt_top _ Œº).ne"
Mathlib/NumberTheory/LSeries/HurwitzZeta.lean,HurwitzZeta.LSeriesHasSum_exp,LSeriesHasSum_exp,b5a9bb1efea5d0b8cb3f457065e6b3862e4564e8,":=
  (hasSum_expZeta_of_one_lt_re a hs).congr_fun
    (LSeries.term_of_ne_zero' (ne_zero_of_one_lt_re hs) _)",error:  unknown constant 'LSeries.term_of_ne_zero'',"lemma LSeriesHasSum_exp (a : ‚Ñù) {s : ‚ÑÇ} (hs : 1 < re s) :
    LSeriesHasSum (cexp <| 2 * œÄ * I * a * ¬∑) s (expZeta a s) ",":= by
  refine (hasSum_expZeta_of_one_lt_re a hs).congr_fun (fun n ‚Ü¶ ?_)
  rcases eq_or_ne n 0 with rfl | hn
  ¬∑ rw [LSeries.term_zero, Nat.cast_zero, zero_cpow (ne_zero_of_one_lt_re hs), div_zero]
  ¬∑ apply LSeries.term_of_ne_zero hn"
Mathlib/AlgebraicTopology/DoldKan/Compatibility.lean,AlgebraicTopology.DoldKan.Compatibility.equivalence‚ÇÅCounitIso_eq,equivalence‚ÇÅCounitIso_eq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  ext Y
  dsimp [equivalence‚ÇÅ, equivalence‚ÇÄ, Functor.IsEquivalence.inverse,
    Functor.IsEquivalence.ofEquivalence]
  simp","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Functor.IsEquivalence
has type
  ?m.10531 ‚•§ ?m.10551 ‚Üí Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Functor.IsEquivalence
has type
  ?m.10580 ‚•§ ?m.10600 ‚Üí Prop",theorem equivalence‚ÇÅCounitIso_eq : (equivalence‚ÇÅ hF).counitIso = equivalence‚ÇÅCounitIso hF ,":= by
  ext Y
  simp [equivalence‚ÇÅ, equivalence‚ÇÄ]"
Mathlib/Dynamics/PeriodicPts.lean,Function.periodicOrbit_eq_nil_iff_not_periodic_pt,periodicOrbit_eq_nil_iff_not_periodic_pt,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp only [periodicOrbit._eq_1, Cycle.coe_eq_nil, List.map_eq_nil, List.range_eq_nil]
  exact minimalPeriod_eq_zero_iff_nmem_periodicPts","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  periodicOrbit
has type
  (?m.33555 ‚Üí ?m.33555) ‚Üí ?m.33555 ‚Üí Cycle ?m.33555
error:  simp made no progress","theorem periodicOrbit_eq_nil_iff_not_periodic_pt :
    periodicOrbit f x = Cycle.nil ‚Üî x ‚àâ periodicPts f ",":= by
  simp only [periodicOrbit.eq_1, Cycle.coe_eq_nil, List.map_eq_nil, List.range_eq_nil]
  exact minimalPeriod_eq_zero_iff_nmem_periodicPts"
Mathlib/Algebra/Module/PID.lean,Module.torsion_by_prime_power_decomposition,torsion_by_prime_power_decomposition,d54553bd16569ed7d2a0974b7a9c2eb160081ba9,":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ simp only [Nat.zero_eq] at *
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
    clear IH
    ¬∑ have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine' ‚ü®x, h0, _‚ü©; rw [h1]
        simp only [LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one, (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'","error:  simp made no progress
error:  simp made no progress
error:  tactic 'rewrite' failed, motive is not type correct
case h.succ.intro.refine_3.intro.intro.refine_2.refine_2.H.h.h
R : Type u
inst‚úù‚Å∂ : CommRing R
inst‚úù‚Åµ : IsDomain R
inst‚úù‚Å¥ : IsPrincipalIdealRing R
M : Type v
inst‚úù¬≥ : AddCommGroup M
inst‚úù¬≤ : Module R M
p : R
hp : Irreducible p
hM : IsTorsion' M ‚Ü•(Submonoid.powers p)
dec : (x : M) ‚Üí Decidable (x = 0)
d : ‚Ñï
N : Type (max u v)
inst‚úù¬π : AddCommGroup N
inst‚úù : Module R N
hN : IsTorsion' N ‚Ü•(Submonoid.powers p)
s : Fin (d + 1) ‚Üí N
hs : Submodule.span R (Set.range s) = ‚ä§
this‚úù : (x : N) ‚Üí Decidable (x = 0)
j : Fin d.succ
hj : IsTorsionBy R N (p ^ pOrder hN (s j))
s' : Fin d ‚Üí N ‚ß∏ Submodule.span R {s j} := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
k : Fin d ‚Üí ‚Ñï
f : (N ‚ß∏ Submodule.span R {s j}) ‚âÉ‚Çó[R] ‚®Å (i : Fin d), R ‚ß∏ Submodule.span R {p ^ k i}
this :
  ‚àÄ (i : Fin d),
    ‚àÉ x,
      p ^ k i ‚Ä¢ x = 0 ‚àß
        f (Submodule.Quotient.mk x) = (DirectSum.lof R (Fin d) (fun i ‚Ü¶ R ‚ß∏ Submodule.span R {p ^ k i}) i) 1
i : Fin d
‚ä¢ f (Submodule.Quotient.mk ‚ãØ.choose) =
    (DirectSum.lof R (Fin d) (fun i ‚Ü¶ R ‚ß∏ Submodule.span R {p ^ k i}) i)
      ((Ideal.Quotient.mk (Submodule.span R {p ^ k i})) 1)
error:  failed to synthesize
  One (‚®Å (i : Fin d), R ‚ß∏ Submodule.span R {p ^ k i})
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  OneHomClass (R ‚ß∏ Submodule.span R {p ^ k i} ‚Üí‚Çó[R] ‚®Å (i : Fin d), R ‚ß∏ Submodule.span R {p ^ k i})
    (R ‚ß∏ Submodule.span R {p ^ k i}) (‚®Å (i : Fin d), R ‚ß∏ Submodule.span R {p ^ k i})
use `set_option diagnostics true` to get diagnostic information
error:  simp made no progress","theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ‚àÉ (d : ‚Ñï) (k : Fin d ‚Üí ‚Ñï), Nonempty <| N ‚âÉ‚Çó[R] ‚®Å i : Fin d, R ‚ß∏ R ‚àô p ^ (k i : ‚Ñï) ",":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    ¬∑ obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
      clear IH
      have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ‚ü®x, h0, ?_‚ü©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'"
Mathlib/Order/ConditionallyCompleteLattice/Basic.lean,WithTop.isGLB_sInf',isGLB_sInf',c151d0706a00b9e9399de0ded77d06d1106bd505,":= by
  constructor
  ¬∑ show ite _ _ _ ‚àà _
    split_ifs with h
    ¬∑ intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exact le_top
      refine' some_le_some.2 (csInf_le _ ha)
      rcases hs with ‚ü®‚ü®‚ü© | b, hb‚ü©
      ¬∑ exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, ‚Üê top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact some_le_some.1 (hb hc)
  ¬∑ show ite _ _ _ ‚àà _
    split_ifs with h
    ¬∑ intro _ _
      exact le_top
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      ¬∑ refine' some_le_some.2 (le_csInf _ _)
        ¬∑ classical
            contrapose! h
            rintro (‚ü®‚ü© | a) ha
            ¬∑ exact mem_singleton ‚ä§
            ¬∑ exact (h ‚ü®a, ha‚ü©).elim
        ¬∑ intro b hb
          rw [‚Üê some_le_some]
          exact ha hb","error:  function expected at
  h
term has type
  s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.intro.none
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
h : ¬¨(s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s)
a : Œ≤
ha : Option.some a ‚àà s
hb : none ‚àà lowerBounds s
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.none
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
hs : BddBelow s
h : ¬¨(s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s)
ha : none ‚àà lowerBounds s
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.refine'_1
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
hs : BddBelow s
a : Œ≤
ha : Option.some a ‚àà lowerBounds s
h : (fun a ‚Ü¶ ‚Üëa) ‚Åª¬π' s = ‚àÖ
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop","theorem isGLB_sInf' {Œ≤ : Type*} [ConditionallyCompleteLattice Œ≤] {s : Set (WithTop Œ≤)}
    (hs : BddBelow s) : IsGLB s (sInf s) ",":= by
  constructor
  ¬∑ show ite _ _ _ ‚àà _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    ¬∑ intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exact le_top
      refine coe_le_coe.2 (csInf_le ?_ ha)
      rcases hs with ‚ü®‚ü®‚ü© | b, hb‚ü©
      ¬∑ exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, ‚Üê top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact coe_le_coe.1 (hb hc)
  ¬∑ show ite _ _ _ ‚àà _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    ¬∑ intro _ _
      exact le_top
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      ¬∑ refine coe_le_coe.2 (le_csInf ?_ ?_)
        ¬∑ classical
            contrapose! h
            rintro (‚ü®‚ü© | a) ha
            ¬∑ exact mem_singleton ‚ä§
            ¬∑ exact (not_nonempty_iff_eq_empty.2 h ‚ü®a, ha‚ü©).elim
        ¬∑ intro b hb
          rw [‚Üê coe_le_coe]
          exact ha hb"
Mathlib/Analysis/Convex/SpecificFunctions/Pow.lean,Real.strictConcaveOn_rpow,strictConcaveOn_rpow,783c2cc3b72b0104b94f3708dd6af2f6563bdfd8,":= by
  have hp‚ÇÄ' : 0 < 1 / p := by positivity
  have hp‚ÇÅ' : 1 < 1 / p := by rw [one_lt_div hp‚ÇÄ]; exact hp‚ÇÅ
  let f := NNReal.orderIsoRpow (1 / p) hp‚ÇÄ'
  have h‚ÇÅ : StrictConvexOn ‚Ñù‚â•0 univ f := by
    refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
    exact (strictConvexOn_rpow hp‚ÇÅ').2 (by positivity : 0 ‚â§ x) (by positivity : 0 ‚â§ y)
      (by simp [hxy]) ha hb (by simp; norm_cast)
  have h‚ÇÇ : ‚àÄ x, f.symm x = x ^ p := by simp [NNReal.orderIsoRpow_symm_eq]
  refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
  simp only [‚Üê h‚ÇÇ]
  exact (f.strictConcaveOn_symm h‚ÇÅ).2 (Set.mem_univ x) (Set.mem_univ y) hxy ha hb hab",error:  simp made no progress,"lemma strictConcaveOn_rpow {p : ‚Ñù} (hp‚ÇÄ : 0 < p) (hp‚ÇÅ : p < 1) :
    StrictConcaveOn ‚Ñù‚â•0 univ fun x : ‚Ñù‚â•0 ‚Ü¶ x ^ p ",":= by
  have hp‚ÇÄ' : 0 < 1 / p := div_pos zero_lt_one hp‚ÇÄ
  have hp‚ÇÅ' : 1 < 1 / p := by rw [one_lt_div hp‚ÇÄ]; exact hp‚ÇÅ
  let f := NNReal.orderIsoRpow (1 / p) hp‚ÇÄ'
  have h‚ÇÅ : StrictConvexOn ‚Ñù‚â•0 univ f := by
    refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
    exact (strictConvexOn_rpow hp‚ÇÅ').2 x.2 y.2 (by simp [hxy]) ha hb (by simp; norm_cast)
  have h‚ÇÇ : ‚àÄ x, f.symm x = x ^ p := by simp [f, NNReal.orderIsoRpow_symm_eq]
  refine ‚ü®convex_univ, fun x mx y my hxy a b ha hb hab => ?_‚ü©
  simp only [‚Üê h‚ÇÇ]
  exact (f.strictConcaveOn_symm h‚ÇÅ).2 mx my hxy ha hb hab"
Mathlib/Algebra/Group/Subgroup/Finite.lean,Subgroup.pi_mem_of_mulSingle_mem,pi_mem_of_mulSingle_mem,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' I with i I hnmem ih generalizing x
  ¬∑ convert one_mem H
    ext i
    exact h1 i (Finset.not_mem_empty i)
  ¬∑ have : x = Function.update x i 1 * Pi.mulSingle i (x i) := by
      ext j
      by_cases heq : j = i
      ¬∑ subst heq
        simp
      ¬∑ simp [heq]
    rw [this]
    clear this
    apply mul_mem
    ¬∑ apply ih <;> clear ih
      ¬∑ intro j hj
        by_cases heq : j = i
        ¬∑ subst heq
          simp
        ¬∑ simp [heq]
          apply h1 j
          simpa [heq] using hj
      ¬∑ intro j hj
        have : j ‚â† i := by
          rintro rfl
          contradiction
        simp only [ne_eq, this, not_false_eq_true, Function.update_noteq]
        exact h2 _ (Finset.mem_insert_of_mem hj)
    ¬∑ apply h2
      simp","error:  application type mismatch
  h1 i (Finset.not_mem_empty i)
argument
  Finset.not_mem_empty i
has type
  i ‚àâ ‚àÖ : Prop
but is expected to have type
  i ‚àâ { val := i‚úù, nodup := I } : Prop
error:  no goals to be solved","theorem pi_mem_of_mulSingle_mem_aux [DecidableEq Œ∑] (I : Finset Œ∑) {H : Subgroup (‚àÄ i, f i)}
    (x : ‚àÄ i, f i) (h1 : ‚àÄ i, i ‚àâ I ‚Üí x i = 1) (h2 : ‚àÄ i, i ‚àà I ‚Üí Pi.mulSingle i (x i) ‚àà H) :
    x ‚àà H ",":= by
  induction' I using Finset.induction_on with i I hnmem ih generalizing x
  ¬∑ convert one_mem H
    ext i
    exact h1 i (Finset.not_mem_empty i)
  ¬∑ have : x = Function.update x i 1 * Pi.mulSingle i (x i) := by
      ext j
      by_cases heq : j = i
      ¬∑ subst heq
        simp
      ¬∑ simp [heq]
    rw [this]
    clear this
    apply mul_mem
    ¬∑ apply ih <;> clear ih
      ¬∑ intro j hj
        by_cases heq : j = i
        ¬∑ subst heq
          simp
        ¬∑ simp [heq]
          apply h1 j
          simpa [heq] using hj
      ¬∑ intro j hj
        have : j ‚â† i := by
          rintro rfl
          contradiction
        simp only [ne_eq, this, not_false_eq_true, Function.update_noteq]
        exact h2 _ (Finset.mem_insert_of_mem hj)
    ¬∑ apply h2
      simp"
Mathlib/Analysis/InnerProductSpace/Basic.lean,inner_mul_inner_self_le,inner_mul_inner_self_le,868e1449d619ac98cf19e96339acab3ba4f241aa,":= by
  have hdiscrim : ‚àÄ (t : ‚Ñù), 0 ‚â§ seminormSqF x * t * t  + 2 * ‚Äñ‚ü™x, y‚ü´‚Äñ * t + seminormSqF y := by
    intro t
    by_cases hzero : ‚ü™x, y‚ü´ = 0
    ¬∑ rw [hzero]
      simp only [norm_zero, mul_zero, zero_mul, add_zero]
      apply add_nonneg
      ¬∑ rw [mul_assoc, ‚Üê sq, seminormSq]
        exact mul_nonneg inner_self_nonneg (sq_nonneg t)
      ¬∑ rw [seminormSq]
        exact inner_self_nonneg
    ¬∑ push_neg at hzero
      rw [‚Üê norm_ne_zero_iff] at hzero
      have htxy: 0 ‚â§ seminormSqF (‚ü™x,y‚ü´ ‚Ä¢ x) * (t / ‚Äñ‚ü™x,y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x,y‚ü´‚Äñ)
          + 2 * re ‚ü™‚ü™x,y‚ü´ ‚Ä¢ x, y‚ü´ * (t / ‚Äñ‚ü™x,y‚ü´‚Äñ) + seminormSqF y := by
        exact cauchy_schwarz_aux' (‚ü™x,y‚ü´ ‚Ä¢ x) y (t/‚Äñ‚ü™x,y‚ü´‚Äñ)
      rw [inner_smul_left, RCLike.conj_mul, sq, ‚Üê RCLike.ofReal_mul, RCLike.ofReal_re, seminormSq,
        inner_smul_left, inner_smul_right, ‚Üê mul_assoc, RCLike.conj_mul, sq, ‚Üê RCLike.ofReal_mul]
        at htxy
      simp only [ofReal_mul, mul_re, ofReal_re, ofReal_im, mul_zero, sub_zero, mul_im, zero_mul,
        add_zero] at htxy
      rw [seminormSq, seminormSq]
      have : 0 ‚â§ ‚Äñ‚ü™x, y‚ü´‚Äñ / ‚Äñ‚ü™x, y‚ü´‚Äñ * ‚Äñ‚ü™x, y‚ü´‚Äñ / ‚Äñ‚ü™x, y‚ü´‚Äñ * re ‚ü™x, x‚ü´ * t * t +
          ‚Äñ‚ü™x, y‚ü´‚Äñ / ‚Äñ‚ü™x, y‚ü´‚Äñ * 2 * ‚Äñ‚ü™x, y‚ü´‚Äñ * t + seminormSqF y := by
        calc 0 ‚â§ ‚Äñ‚ü™x, y‚ü´‚Äñ * ‚Äñ‚ü™x, y‚ü´‚Äñ * re ‚ü™x, x‚ü´ * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ) +
          2 * (‚Äñ‚ü™x, y‚ü´‚Äñ * ‚Äñ‚ü™x, y‚ü´‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´‚Äñ) + seminormSq y := htxy
          _ = ‚Äñ‚ü™x, y‚ü´‚Äñ / ‚Äñ‚ü™x, y‚ü´‚Äñ * ‚Äñ‚ü™x, y‚ü´‚Äñ / ‚Äñ‚ü™x, y‚ü´‚Äñ * re ‚ü™x, x‚ü´ * t * t +
          ‚Äñ‚ü™x, y‚ü´‚Äñ / ‚Äñ‚ü™x, y‚ü´‚Äñ * 2* ‚Äñ‚ü™x, y‚ü´‚Äñ * t + seminormSq y := by ring
      rw [div_self hzero, one_mul, one_mul, div_self hzero, one_mul] at this
      exact this
  have hnegdiscrim : (2 * ‚Äñ‚ü™x, y‚ü´‚Äñ)^2 - 4 * seminormSqF x * seminormSqF y ‚â§ 0 := by
    rw [‚Üê discrim]
    exact discrim_le_zero hdiscrim
  rw [seminormSq, seminormSq, sq] at hnegdiscrim
  nth_rw 1 [norm_inner_symm x y] at hnegdiscrim
  linarith","error:  unknown identifier 'seminormSqF'
error:  unknown identifier 'seminormSqF'
error:  unknown identifier 'seminormSq'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.105448
case pos.ha
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù¬≤ : _root_.RCLike ùïú
inst‚úù¬π : AddCommGroup F
inst‚úù : Module ùïú F
c : Core ùïú F
x y : F
t : ‚Ñù
hzero : ‚ü™x, y‚ü´_ùïú = 0
‚ä¢ 0 ‚â§ sorryAx ‚Ñù true * t ^ 2
error:  unknown identifier 'seminormSq'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.105450
case pos.hb
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù¬≤ : _root_.RCLike ùïú
inst‚úù¬π : AddCommGroup F
inst‚úù : Module ùïú F
c : Core ùïú F
x y : F
t : ‚Ñù
hzero : ‚ü™x, y‚ü´_ùïú = 0
‚ä¢ 0 ‚â§ sorryAx ‚Ñù true
error:  unknown identifier 'seminormSqF'
error:  unknown identifier 'seminormSqF'
error:  unknown identifier 'cauchy_schwarz_aux''
error:  unknown identifier 'seminormSq'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.108772
case neg
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù¬≤ : _root_.RCLike ùïú
inst‚úù¬π : AddCommGroup F
inst‚úù : Module ùïú F
c : Core ùïú F
x y : F
t : ‚Ñù
hzero : ‚Äñ‚ü™x, y‚ü´_ùïú‚Äñ ‚â† 0
htxy :
  0 ‚â§
    sorryAx ‚Ñù true * (t / ‚Äñ‚ü™x, y‚ü´_ùïú‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´_ùïú‚Äñ) + 2 * (‚Äñ‚ü™x, y‚ü´_ùïú‚Äñ * ‚Äñ‚ü™x, y‚ü´_ùïú‚Äñ) * (t / ‚Äñ‚ü™x, y‚ü´_ùïú‚Äñ) +
      sorryAx ‚Ñù true
‚ä¢ 0 ‚â§ sorryAx ‚Ñù true * t * t + 2 * ‚Äñ‚ü™x, y‚ü´_ùïú‚Äñ * t + sorryAx ‚Ñù true
error:  unknown identifier 'seminormSqF'
error:  unknown identifier 'seminormSqF'
error:  unknown identifier 'discrim'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.109198
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù¬≤ : _root_.RCLike ùïú
inst‚úù¬π : AddCommGroup F
inst‚úù : Module ùïú F
c : Core ùïú F
x y : F
hdiscrim : ‚àÄ (t : ‚Ñù), 0 ‚â§ sorryAx ‚Ñù true * t * t + 2 * ‚Äñ‚ü™x, y‚ü´_ùïú‚Äñ * t + sorryAx ‚Ñù true
‚ä¢ (2 * ‚Äñ‚ü™x, y‚ü´_ùïú‚Äñ) ^ 2 - 4 * sorryAx ‚Ñù true * sorryAx ‚Ñù true ‚â§ 0
error:  unknown identifier 'seminormSq'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.109200
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù¬≤ : _root_.RCLike ùïú
inst‚úù¬π : AddCommGroup F
inst‚úù : Module ùïú F
c : Core ùïú F
x y : F
hdiscrim : ‚àÄ (t : ‚Ñù), 0 ‚â§ sorryAx ‚Ñù true * t * t + 2 * ‚Äñ‚ü™x, y‚ü´_ùïú‚Äñ * t + sorryAx ‚Ñù true
hnegdiscrim : (2 * ‚Äñ‚ü™x, y‚ü´_ùïú‚Äñ) ^ 2 - 4 * sorryAx ‚Ñù true * sorryAx ‚Ñù true ‚â§ 0
‚ä¢ ‚Äñ‚ü™x, y‚ü´_ùïú‚Äñ * ‚Äñ‚ü™y, x‚ü´_ùïú‚Äñ ‚â§ re ‚ü™x, x‚ü´_ùïú * re ‚ü™y, y‚ü´_ùïú","theorem inner_mul_inner_self_le (x y : F) : ‚Äñ‚ü™x, y‚ü´‚Äñ * ‚Äñ‚ü™y, x‚ü´‚Äñ ‚â§ re ‚ü™x, x‚ü´ * re ‚ü™y, y‚ü´ ",":= by
  rcases eq_or_ne x 0 with (rfl | hx)
  ¬∑ simpa only [inner_zero_left, map_zero, zero_mul, norm_zero] using le_rfl
  ¬∑ have hx' : 0 < normSqF x := inner_self_nonneg.lt_of_ne' (mt normSq_eq_zero.1 hx)
    rw [‚Üê sub_nonneg, ‚Üê mul_nonneg_iff_right_nonneg_of_pos hx', ‚Üê normSq, ‚Üê normSq,
      norm_inner_symm y, ‚Üê sq, ‚Üê cauchy_schwarz_aux]
    exact inner_self_nonneg"
Mathlib/RingTheory/Bialgebra/Hom.lean,BialgHom.coe_algHom_injective,coe_algHom_injective,3a75d0bf19f68430ce526cb9e63de3580baf57bf,":=
  LinearMap.toAddMonoidHom_injective.comp coe_linearMap_injective","warning:  BialgHom does not have a doc string
warning:  BialgHom does not have a doc string
error:  unknown identifier 'coe_linearMap_injective'
error:  stuck at solving universe constraint
  max (?u.118720+1) (?u.118721+1) =?= max (u_2+1) (u_3+1)
while trying to unify
  @Function.Injective.{max (u_2 + 1) (u_3 + 1),
      max (?u.118720 + 1)
        (?u.118721 + 1)} : {Œ± : Type (max u_2 u_3)} ‚Üí {Œ≤ : Type (max ?u.118720 ?u.118721)} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Prop
with
  @Function.Injective : {Œ± Œ≤ : Type (max u_2 u_3)} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Prop",theorem coe_algHom_injective : Function.Injective ((‚Üë) : (A ‚Üí‚Çêc[R] B) ‚Üí A ‚Üí‚Çê[R] B) ,":=
  fun œÜ‚ÇÅ œÜ‚ÇÇ H => coe_fn_injective <|
    show ((œÜ‚ÇÅ : A ‚Üí‚Çê[R] B) : A ‚Üí B) = ((œÜ‚ÇÇ : A ‚Üí‚Çê[R] B) : A ‚Üí B) from congr_arg _ H"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.Measure.noAtoms_hausdorff,noAtoms_hausdorff,ced4d3c0af763b9fd00166e49cf999cf46c891cc,":= by
  refine ‚ü®fun x => _‚ü©
  rw [‚Üê nonpos_iff_eq_zero, hausdorffMeasure_apply]
  refine iSup‚ÇÇ_le fun Œµ _ => iInf‚ÇÇ_le_of_le (fun _ => {x}) _ <| iInf_le_of_le (fun _ => _) _
  ¬∑ exact subset_iUnion (fun _ => {x} : ‚Ñï ‚Üí Set X) 0
  ¬∑ simp only [EMetric.diam_singleton, zero_le]
  ¬∑ simp [hd]","error:  don't know how to synthesize placeholder
context:
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬≥ : EMetricSpace X
inst‚úù¬≤ : EMetricSpace Y
inst‚úù¬π : MeasurableSpace X
inst‚úù : BorelSpace X
d : ‚Ñù
hd : 0 < d
x : X
‚ä¢ ŒºH[d] {x} = 0
error:  unsolved goals
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬≥ : EMetricSpace X
inst‚úù¬≤ : EMetricSpace Y
inst‚úù¬π : MeasurableSpace X
inst‚úù : BorelSpace X
d : ‚Ñù
hd : 0 < d
‚ä¢ NoAtoms ŒºH[d]",theorem noAtoms_hausdorff {d : ‚Ñù} (hd : 0 < d) : NoAtoms (hausdorffMeasure d : Measure X) ,":= by
  refine ‚ü®fun x => ?_‚ü©
  rw [‚Üê nonpos_iff_eq_zero, hausdorffMeasure_apply]
  refine iSup‚ÇÇ_le fun Œµ _ => iInf‚ÇÇ_le_of_le (fun _ => {x}) ?_ <| iInf_le_of_le (fun _ => ?_) ?_
  ¬∑ exact subset_iUnion (fun _ => {x} : ‚Ñï ‚Üí Set X) 0
  ¬∑ simp only [EMetric.diam_singleton, zero_le]
  ¬∑ simp [hd]"
Mathlib/CategoryTheory/Subobject/Lattice.lean,CategoryTheory.Subobject.finset_inf_factors,finset_inf_factors,c959b2f950b9c44268e36bcedef976356855e6fb,":= by
  classical
  induction' s with _ _ _ ih
  ¬∑ simp [top_factors]
  ¬∑ simp [ih]","error:  unsolved goals
case mk
C : Type u‚ÇÅ
inst‚úù¬≤ : Category.{v‚ÇÅ, u‚ÇÅ} C
X Y Z : C
D : Type u‚ÇÇ
inst‚úù¬π : Category.{v‚ÇÇ, u‚ÇÇ} D
inst‚úù : HasPullbacks C
I : Type u_1
A B : C
P : I ‚Üí Subobject B
f : A ‚ü∂ B
val‚úù : Multiset I
nodup‚úù : val‚úù.Nodup
‚ä¢ ({ val := val‚úù, nodup := nodup‚úù }.inf P).Factors f ‚Üî ‚àÄ i ‚àà val‚úù, (P i).Factors f
error:  no goals to be solved","theorem finset_inf_factors {I : Type*} {A B : C} {s : Finset I} {P : I ‚Üí Subobject B} (f : A ‚ü∂ B) :
    (s.inf P).Factors f ‚Üî ‚àÄ i ‚àà s, (P i).Factors f ",":= by
  classical
  induction' s using Finset.induction_on with _ _ _ ih
  ¬∑ simp [top_factors]
  ¬∑ simp [ih]"
Mathlib/Topology/Basic.lean,nhds_basis_opens,nhds_basis_opens,2ea14b79e1f7e6978b1265a8d41f7a305925875c,":= by
  rw [nhds_def]
  exact hasBasis_biInf_principal
    (fun s ‚ü®has, hs‚ü© t ‚ü®hat, ht‚ü© =>
      ‚ü®s ‚à© t, ‚ü®‚ü®has, hat‚ü©, IsOpen.inter hs ht‚ü©, ‚ü®inter_subset_left _ _, inter_subset_right _ _‚ü©‚ü©)
    ‚ü®univ, ‚ü®mem_univ x, isOpen_univ‚ü©‚ü©","error:  function expected at
  inter_subset_left ?m.48663
term has type
  ?m.48662 ‚àà ?m.48660
error:  function expected at
  inter_subset_right ?m.48705
term has type
  ?m.48704 ‚àà ?m.48703","theorem nhds_basis_opens (x : X) :
    (ùìù x).HasBasis (fun s : Set X => x ‚àà s ‚àß IsOpen s) fun s => s ",":= by
  rw [nhds_def]
  exact hasBasis_biInf_principal
    (fun s ‚ü®has, hs‚ü© t ‚ü®hat, ht‚ü© =>
      ‚ü®s ‚à© t, ‚ü®‚ü®has, hat‚ü©, IsOpen.inter hs ht‚ü©, ‚ü®inter_subset_left, inter_subset_right‚ü©‚ü©)
    ‚ü®univ, ‚ü®mem_univ x, isOpen_univ‚ü©‚ü©"
Mathlib/Data/List/NodupEquivFin.lean,List.sublist_iff_exists_fin_orderEmbedding_get_eq,sublist_iff_exists_fin_orderEmbedding_get_eq,5fb9beab28702fb284701d494bc9b7c5f52fef53,":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï} (_ : i < l.length), f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine' ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) _, _‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [get?_eq_get i.2, get?_eq_get (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine'
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          _,
        _‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ rw [add_comm]
        exact lt_add_of_lt_of_pos (Fin.is_lt _) (i.zero_le.trans_lt h)
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi","error:  type mismatch
  h‚úù
has type
  some l[‚Üëi] = l'[f ‚Üëi]? : Prop
but is expected to have type
  l[‚Üëi] = l'[f ‚Üëi] : Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + ?b
case neg
Œ± : Type u_1
l l' : List Œ±
f : Fin l.length ‚Ü™o Fin l'.length
hf : ‚àÄ (ix : Fin l.length), l.get ix = l'.get (f ix)
i j : ‚Ñï
h : i < j
hi : i < l.length
hj : ¬¨j < l.length
‚ä¢ ‚Üë(f ‚ü®i, hi‚ü©) < j + l'.length
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem sublist_iff_exists_fin_orderEmbedding_get_eq {l l' : List Œ±} :
    l <+ l' ‚Üî
      ‚àÉ f : Fin l.length ‚Ü™o Fin l'.length,
        ‚àÄ ix : Fin l.length, l.get ix = l'.get (f ix) ",":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï}, i < l.length ‚Üí f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) ?_, ?_‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [getElem?_eq_getElem i.2, getElem?_eq_getElem (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          ?_,
        ?_‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ have := (f ‚ü®i, hi‚ü©).is_lt
        omega
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi"
Mathlib/CategoryTheory/Filtered/Basic.lean,CategoryTheory.IsCofiltered.inf_objs_exists,inf_objs_exists,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
  induction' O with X O' nm h
  ¬∑ exact ‚ü®Classical.choice IsCofiltered.nonempty, by intro; simp‚ü©
  ¬∑ obtain ‚ü®S', w'‚ü© := h
    use min X S'
    rintro Y mY
    obtain rfl | h := eq_or_ne Y X
    ¬∑ exact ‚ü®minToLeft _ _‚ü©
    ¬∑ exact ‚ü®minToRight _ _ ‚â´ (w' (Finset.mem_of_mem_insert_of_ne mY h)).some‚ü©","error:  unsolved goals
C : Type u
inst‚úù¬π : Category.{v, u} C
inst‚úù : IsCofiltered C
X : Multiset C
O' : X.Nodup
X‚úù : C
‚ä¢ X‚úù ‚àà X ‚Üí Nonempty (Classical.choice ‚ãØ ‚ü∂ X‚úù)
error:  no goals to be solved","theorem inf_objs_exists (O : Finset C) : ‚àÉ S : C, ‚àÄ {X}, X ‚àà O ‚Üí Nonempty (S ‚ü∂ X) ",":= by
  classical
  induction' O using Finset.induction with X O' nm h
  ¬∑ exact ‚ü®Classical.choice IsCofiltered.nonempty, by intro; simp‚ü©
  ¬∑ obtain ‚ü®S', w'‚ü© := h
    use min X S'
    rintro Y mY
    obtain rfl | h := eq_or_ne Y X
    ¬∑ exact ‚ü®minToLeft _ _‚ü©
    ¬∑ exact ‚ü®minToRight _ _ ‚â´ (w' (Finset.mem_of_mem_insert_of_ne mY h)).some‚ü©"
Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Degree.lean,WeierstrassCurve.natDegree_Œ¶_le,natDegree_Œ¶_le,409be1ff4c306030afd38a2641547686c28f2646,":= by
  induction n using Int.negInduction with
  | nat n => exact (W.natDegree_coeff_Œ¶_ofNat n).left
  | neg ih => simp only [Œ¶_neg, Int.natAbs_neg, ih]","error:  invalid argument, variable is not a proposition or let-declaration
error:  unsolved goals
case neg
R : Type u
inst‚úù : CommRing R
W : WeierstrassCurve R
ih : ‚Ñï
a‚úù : (W.Œ¶ ‚Üëih).natDegree ‚â§ (‚Üëih).natAbs ^ 2
‚ä¢ (W.Œ¶ ‚Üëih).natDegree ‚â§ (‚Üëih).natAbs ^ 2",lemma natDegree_Œ¶_le (n : ‚Ñ§) : (W.Œ¶ n).natDegree ‚â§ n.natAbs ^ 2 ,":= by
  induction n using Int.negInduction with
  | nat n => exact (W.natDegree_coeff_Œ¶_ofNat n).left
  | neg => rwa [Œ¶_neg, Int.natAbs_neg]"
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.getD_leftInvSeq_mul_wordProd,getD_leftInvSeq_mul_wordProd,c0b6dfcca1c229cefe79308fd38d49cb11349366,":= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [‚Üê take_append_drop (j + 1) œâ]
  rw [take_succ]
  obtain lt | le := lt_or_le j œâ.length
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]
    simp
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_none.mpr le]
    simp","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  getElem?_eq_none
has type
  ?m.115667.length ‚â§ ?m.115668 ‚Üí ?m.115667[?m.115668]? = none
error:  unsolved goals
case inr
B : Type u_1
W : Type u_2
inst‚úù : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
œâ : List B
j : ‚Ñï
le : œâ.length ‚â§ j
‚ä¢ cs.wordProd (take j œâ) * (Option.map cs.simple œâ[j]?).getD 1 * (cs.wordProd (take j œâ))‚Åª¬π *
      cs.wordProd (take j œâ ++ (œâ[j]?.toList ++ drop (j + 1) œâ)) =
    cs.wordProd (take j œâ ++ drop (j + 1) œâ)","theorem getD_leftInvSeq_mul_wordProd (œâ : List B) (j : ‚Ñï) :
    ((lis œâ).getD j 1) * œÄ œâ = œÄ (œâ.eraseIdx j) ",":= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [‚Üê take_append_drop (j + 1) œâ]
  rw [take_succ]
  obtain lt | le := lt_or_le j œâ.length
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]
    simp
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_none le]
    simp"
Mathlib/Analysis/InnerProductSpace/Basic.lean,OrthogonalFamily.independent,OrthogonalFamily.independent,fea3e4ca6b3946e139a9a0aa0e864a2238aafd1d,":= by
  classical
    apply CompleteLattice.independent_of_dfinsupp_lsum_injective
    refine LinearMap.ker_eq_bot.mp ?_
    rw [Submodule.eq_bot_iff]
    intro v hv
    rw [LinearMap.mem_ker] at hv
    ext i
    suffices ‚ü™(v i : E), v i‚ü´ = 0 by simpa only [inner_self_eq_zero] using this
    calc
      ‚ü™(v i : E), v i‚ü´ = ‚ü™(v i : E), Dfinsupp.lsum ‚Ñï (fun i => (V i).subtype) v‚ü´ := by
        simpa only [Dfinsupp.sumAddHom_apply, Dfinsupp.lsum_apply_apply] using
          (hV.inner_right_dfinsupp v i (v i)).symm
      _ = 0 := by simp only [hv, inner_zero_right]","error:  unknown identifier 'Dfinsupp.lsum'
error:  unknown identifier 'Dfinsupp.sumAddHom_apply'
error:  unknown identifier 'Dfinsupp.lsum_apply_apply'
error:  unsolved goals
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Å∂ : _root_.RCLike ùïú
inst‚úù‚Åµ : NormedAddCommGroup E
inst‚úù‚Å¥ : InnerProductSpace ùïú E
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : InnerProductSpace ‚Ñù F
Œπ : Type u_4
G : Œπ ‚Üí Type u_5
inst‚úù¬π : (i : Œπ) ‚Üí NormedAddCommGroup (G i)
inst‚úù : (i : Œπ) ‚Üí InnerProductSpace ùïú (G i)
V‚úù : (i : Œπ) ‚Üí G i ‚Üí‚Çó·µ¢[ùïú] E
hV‚úù : OrthogonalFamily ùïú G V‚úù
dec_V : (i : Œπ) ‚Üí (x : G i) ‚Üí Decidable (x ‚â† 0)
V : Œπ ‚Üí Submodule ùïú E
hV : OrthogonalFamily ùïú (fun i ‚Ü¶ ‚Ü•(V i)) fun i ‚Ü¶ (V i).subtype‚Çó·µ¢
v : Œ†‚ÇÄ (i : Œπ), ‚Ü•(V i)
hv : ((DFinsupp.lsum ‚Ñï) fun i ‚Ü¶ (V i).subtype) v = 0
i : Œπ
‚ä¢ ‚ü™‚Üë(v i), sorryAx E true‚ü´_ùïú = 0","theorem OrthogonalFamily.independent {V : Œπ ‚Üí Submodule ùïú E}
    (hV : OrthogonalFamily ùïú (fun i => V i) fun i => (V i).subtype‚Çó·µ¢) :
    CompleteLattice.Independent V ",":= by
  classical
  apply CompleteLattice.independent_of_dfinsupp_lsum_injective
  refine LinearMap.ker_eq_bot.mp ?_
  rw [Submodule.eq_bot_iff]
  intro v hv
  rw [LinearMap.mem_ker] at hv
  ext i
  suffices ‚ü™(v i : E), v i‚ü´ = 0 by simpa only [inner_self_eq_zero] using this
  calc
    ‚ü™(v i : E), v i‚ü´ = ‚ü™(v i : E), DFinsupp.lsum ‚Ñï (fun i => (V i).subtype) v‚ü´ := by
      simpa only [DFinsupp.sumAddHom_apply, DFinsupp.lsum_apply_apply] using
        (hV.inner_right_dfinsupp v i (v i)).symm
    _ = 0 := by simp only [hv, inner_zero_right]"
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow,discr_prime_pow,6985e17b5d9334c9f3360397dd58f2f1d185ced1,":= by
  haveI hne := IsCyclotomicExtension.ne_zero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), succ_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2
      ¬∑ rwa [Ne.def, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]; ¬∑ norm_cast
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, MulZeroClass.zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact_mod_cast hŒ∂.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact_mod_cast hŒ∂.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by linarith)] at this
      exact absurd (pow_eq_zero h) this","error:  unexpected token '¬∑'; expected '|'
error:  don't know how to synthesize placeholder
context:
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
‚ä¢ Sort ?u.26898
error:  unsolved goals
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
‚ä¢ discr K ‚áë(IsPrimitiveRoot.powerBasis K hŒ∂).basis =
    (-1) ^ (œÜ (‚Üëp ^ (k + 1)) / 2) * ‚Üë‚Üëp ^ (‚Üëp ^ k * ((‚Üëp - 1) * (k + 1) - 1))","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ‚Ñï).Prime]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1)) : ‚Ñï) K))
    (hk : p ^ (k + 1) ‚â† 2) : discr K (hŒ∂.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : ‚Ñï).totient / 2) * p ^ ((p : ‚Ñï) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this"
Mathlib/Algebra/Module/Torsion.lean,Ideal.CompleteLattice.Independent.linear_independent',CompleteLattice.Independent.linear_independent',b7a77e87872c2b25b743c685f62544cccc9fafb5,":= by
  refine' linearIndependent_iff_not_smul_mem_span.mpr fun i r hi => _
  replace hv := CompleteLattice.independent_def.mp hv i
  simp only [iSup_subtype', ‚Üê Submodule.span_range_eq_iSup, disjoint_iff] at hv
  have : r ‚Ä¢ v i ‚àà ‚ä• := by
    rw [‚Üê hv, Submodule.mem_inf]
    refine' ‚ü®Submodule.mem_span_singleton.mpr ‚ü®r, rfl‚ü©, _‚ü©
    convert hi
    ext
    simp
  rw [‚Üê Submodule.mem_bot R, ‚Üê h_ne_zero i]
  simpa using this","error:  typeclass instance problem is stuck, it is often due to metavariables
  Membership M ?m.16614","theorem CompleteLattice.Independent.linear_independent' {Œπ R M : Type*} {v : Œπ ‚Üí M} [Ring R]
    [AddCommGroup M] [Module R M] (hv : CompleteLattice.Independent fun i => R ‚àô v i)
    (h_ne_zero : ‚àÄ i, Ideal.torsionOf R M (v i) = ‚ä•) : LinearIndependent R v ",":= by
  refine linearIndependent_iff_not_smul_mem_span.mpr fun i r hi => ?_
  replace hv := CompleteLattice.independent_def.mp hv i
  simp only [iSup_subtype', ‚Üê Submodule.span_range_eq_iSup (Œπ := Subtype _), disjoint_iff] at hv
  have : r ‚Ä¢ v i ‚àà (‚ä• : Submodule R M) := by
    rw [‚Üê hv, Submodule.mem_inf]
    refine ‚ü®Submodule.mem_span_singleton.mpr ‚ü®r, rfl‚ü©, ?_‚ü©
    convert hi
    ext
    simp
  rw [‚Üê Submodule.mem_bot R, ‚Üê h_ne_zero i]
  simpa using this"
Mathlib/LinearAlgebra/LinearPMap.lean,LinearPMap.neg_graph,neg_graph,dd9d2939f7f4933231c9afead607499e5a048f4f,":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  ¬∑ rw [mem_graph_iff] at h
    rcases h with ‚ü®y, hy, h‚ü©
    rw [LinearPMap.neg_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id.def,
      LinearMap.neg_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y
    simp [hy, h]
  rw [Submodule.mem_map] at h
  rcases h with ‚ü®x', hx', h‚ü©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id.def, LinearMap.neg_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' ‚ä¢
  rcases hx' with ‚ü®y, hy, hx'‚ü©
  use y
  rw [‚Üê h.1, ‚Üê h.2]
  simp [hy, hx']","warning:  LinearPMap does not have a doc string
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.548521 ‚Üí ?m.548521
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.550936 ‚Üí ?m.550936","theorem neg_graph (f : E ‚Üí‚Çó.[R] F) :
    (-f).graph =
    f.graph.map ((LinearMap.id : E ‚Üí‚Çó[R] E).prodMap (-(LinearMap.id : F ‚Üí‚Çó[R] F))) ",":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  ¬∑ rw [mem_graph_iff] at h
    rcases h with ‚ü®y, hy, h‚ü©
    rw [LinearPMap.neg_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id,
      LinearMap.neg_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y, hy
  rw [Submodule.mem_map] at h
  rcases h with ‚ü®x', hx', h‚ü©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id, LinearMap.neg_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' ‚ä¢
  rcases hx' with ‚ü®y, hy, hx'‚ü©
  use y
  rw [‚Üê h.1, ‚Üê h.2]
  simp [hy, hx']"
Mathlib/RingTheory/FreeCommRing.lean,FreeCommRing.map_subtype_val_restriction,map_subtype_val_restriction,2ab2720bf60e325ecde05f72c30fd6346f06a460,":= by
  refine Subring.InClosure.recOn hxs ?_? ?_ _? _
  ¬∑ rw [RingHom.map_one]
    rfl
  ¬∑ rw [map_neg, map_one]
    rfl
  ¬∑ rintro _ ‚ü®p, hps, rfl‚ü© n ih
    rw [RingHom.map_mul, restriction_of, dif_pos hps, RingHom.map_mul, map_of, ih]
  ¬∑ intro x y ihx ihy
    rw [RingHom.map_add, RingHom.map_add, ihx, ihy]","error:  unknown identifier '_?'
error:  unsolved goals
Œ± : Type u
Œ≤ : Type v
f : Œ± ‚Üí Œ≤
x : FreeCommRing Œ±
s : Set Œ±
inst‚úù : DecidablePred fun x ‚Ü¶ x ‚àà s
hxs : x.IsSupported s
‚ä¢ (map Subtype.val) ((restriction s) x) = x","theorem map_subtype_val_restriction {x} (s : Set Œ±) [DecidablePred (¬∑ ‚àà s)]
    (hxs : IsSupported x s) : map (‚Üë) (restriction s x) = x ",":= by
  refine Subring.InClosure.recOn hxs ?_ ?_ ?_ ?_
  ¬∑ rw [RingHom.map_one]
    rfl
  ¬∑ rw [map_neg, map_one]
    rfl
  ¬∑ rintro _ ‚ü®p, hps, rfl‚ü© n ih
    rw [RingHom.map_mul, restriction_of, dif_pos hps, RingHom.map_mul, map_of, ih]
  ¬∑ intro x y ihx ihy
    rw [RingHom.map_add, RingHom.map_add, ihx, ihy]"
Mathlib/Algebra/Lie/CartanExists.lean,LieAlgebra.engel_isBot_of_isMin,engel_isBot_of_isMin,f7604b291cb6988456f8087adebf9e3a4a5a2833,":= by
  rcases E with ‚ü®_, x, hxU, rfl‚ü©
  rintro ‚ü®_, y, hyU, rfl‚ü©
  set Ex : {engel K x | x ‚àà U} := ‚ü®engel K x, x, hxU, rfl‚ü©
  set Ey : {engel K y | y ‚àà U} := ‚ü®engel K y, y, hyU, rfl‚ü©
  replace hUle : U ‚â§ Ex := hUle
  replace hmin : ‚àÄ E, E ‚â§ Ex ‚Üí Ex ‚â§ E := @hmin
  let E : LieSubmodule K U L :=
  { engel K x with
    lie_mem := by rintro ‚ü®u, hu‚ü© y hy; exact (engel K x).lie_mem (hUle hu) hy }
  obtain rfl|hx‚ÇÄ := eq_or_ne x 0
  ¬∑ simpa [Ex, Ey] using hmin Ey
  let Q := L ‚ß∏ E
  let r := finrank K E
  obtain hr|hr : r = finrank K L ‚à® r < finrank K L := (Submodule.finrank_le _).eq_or_lt
  ¬∑ suffices engel K y ‚â§ engel K x from hmin Ey this
    suffices engel K x = ‚ä§ by simp_rw [this, le_top]
    apply LieSubalgebra.to_submodule_injective
    apply Submodule.eq_top_of_finrank_eq hr
  set x' : U := ‚ü®x, hxU‚ü©
  set y' : U := ‚ü®y, hyU‚ü©
  let u : U := y' - x'
  let œá : Polynomial (K[X]) := lieCharpoly K E x' u
  let œà : Polynomial (K[X]) := lieCharpoly K Q x' u
  suffices œá = X ^ r by
    apply_fun (fun p ‚Ü¶ p.map (evalRingHom 1)) at this
    simp_rw [Polynomial.map_pow, map_X, œá, lieCharpoly_map_eval, one_smul, u, sub_add_cancel,
      r, LinearMap.charpoly_eq_X_pow_iff,
      Subtype.ext_iff, coe_toEndomorphism_pow, ZeroMemClass.coe_zero] at this
    intro z hz
    rw [mem_engel_iff]
    exact this ‚ü®z, hz‚ü©
  suffices ‚àÄ i < r, œá.coeff i = 0 by
    simp_rw [r, ‚Üê lieCharpoly_natDegree K E x' u] at this ‚ä¢
    rw [(lieCharpoly_monic K E x' u).eq_X_pow_iff_natDegree_le_natTrailingDegree]
    exact le_natTrailingDegree (lieCharpoly_monic K E x' u).ne_zero this
  intro i hi
  obtain rfl|hi0 := eq_or_ne i 0
  ¬∑ 
    apply eq_zero_of_forall_eval_zero_of_natDegree_lt_card _ _ ?deg
    case deg =>
      apply lt_of_lt_of_le _ hLK
      rw [Nat.cast_lt]
      apply lt_of_le_of_lt _ hr
      apply lieCharpoly_coeff_natDegree _ _ _ _ 0 r (zero_add r)
    intro Œ±
    rw [‚Üê coe_evalRingHom, ‚Üê coeff_map, lieCharpoly_map_eval,
      ‚Üê constantCoeff_apply, LinearMap.charpoly_constantCoeff_eq_zero_iff]
    let z := Œ± ‚Ä¢ u + x'
    obtain hz‚ÇÄ|hz‚ÇÄ := eq_or_ne z 0
    ¬∑ 
      refine ‚ü®‚ü®x, self_mem_engel K x‚ü©, ?_, ?_‚ü©
      ¬∑ simpa [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero] using hx‚ÇÄ
      ¬∑ dsimp only [z] at hz‚ÇÄ
        simp only [coe_bracket_of_module, hz‚ÇÄ, LieHom.map_zero, LinearMap.zero_apply]
    refine ‚ü®‚ü®z, hUle z.2‚ü©, ?_, ?_‚ü©
    ¬∑ simpa only [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero, Subtype.ext_iff] using hz‚ÇÄ
    ¬∑ show ‚ÅÖz, _‚ÅÜ = (0 : E)
      ext
      exact lie_self z.1
  have hœà : constantCoeff œà ‚â† 0 := by
    intro H
    obtain ‚ü®z, hz0, hxz‚ü© : ‚àÉ z : Q, z ‚â† 0 ‚àß ‚ÅÖx', z‚ÅÜ = 0 := by
      apply_fun (evalRingHom 0) at H
      rw [constantCoeff_apply, ‚Üê coeff_map, lieCharpoly_map_eval,
        ‚Üê constantCoeff_apply, map_zero, LinearMap.charpoly_constantCoeff_eq_zero_iff] at H
      simpa only [coe_bracket_of_module, ne_eq, zero_smul, zero_add, toEndomorphism_apply_apply]
        using H
    apply hz0
    obtain ‚ü®z, rfl‚ü© := LieSubmodule.Quotient.surjective_mk' E z
    have : ‚ÅÖx, z‚ÅÜ ‚àà E := by rwa [‚Üê LieSubmodule.Quotient.mk_eq_zero']
    simp only [coe_bracket_of_module, LieSubmodule.mem_mk_iff', mem_coe_submodule, mem_engel_iff,
      LieSubmodule.Quotient.mk'_apply, LieSubmodule.Quotient.mk_eq_zero', E, Q] at this ‚ä¢
    obtain ‚ü®n, hn‚ü© := this
    use n+1
    rwa [pow_succ]
  obtain ‚ü®s, hs, hsœà‚ü© : ‚àÉ s : Finset K, r ‚â§ s.card ‚àß ‚àÄ Œ± ‚àà s, (constantCoeff œà).eval Œ± ‚â† 0 := by
    classical
    let t := (constantCoeff œà).roots.toFinset
    have ht : t.card ‚â§ finrank K L - r := by
      refine (Multiset.toFinset_card_le _).trans ?_
      refine (card_roots' _).trans ?_
      rw [constantCoeff_apply]
      apply lieCharpoly_coeff_natDegree
      suffices finrank K Q + r = finrank K L by rw [‚Üê this, zero_add, Nat.add_sub_cancel]
      apply Submodule.finrank_quotient_add_finrank
    obtain ‚ü®s, hs‚ü© := exists_finset_le_card K _ hLK
    use s \ t
    refine ‚ü®?_, ?_‚ü©
    ¬∑ refine le_trans ?_ (Finset.le_card_sdiff _ _)
      omega
    ¬∑ intro Œ± hŒ±
      simp only [Finset.mem_sdiff, Multiset.mem_toFinset, mem_roots', IsRoot.def, not_and, t] at hŒ±
      exact hŒ±.2 hœà
  apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero' _ s _ ?hcard
  case hcard =>
    apply lt_of_le_of_lt (lieCharpoly_coeff_natDegree _ _ _ _ i (r - i) _)
    ¬∑ omega
    ¬∑ dsimp only [r] at hi ‚ä¢
      rw [Nat.add_sub_cancel' hi.le]
  intro Œ± hŒ±
  rw [‚Üê coe_evalRingHom, ‚Üê coeff_map, lieCharpoly_map_eval,
    (LinearMap.charpoly_eq_X_pow_iff _).mpr, coeff_X_pow, if_neg hi.ne]
  let v := Œ± ‚Ä¢ u + x'
  suffices engel K (v : L) ‚â§ engel K x by
    replace this : engel K x ‚â§ engel K (v : L) := (hmin ‚ü®_, v, v.2, rfl‚ü© this).ge
    intro z
    simpa only [mem_engel_iff, Subtype.ext_iff, coe_toEndomorphism_pow] using this z.2
  intro z hz
  show z ‚àà E
  rw [‚Üê LieSubmodule.Quotient.mk_eq_zero]
  set z' : Q := LieSubmodule.Quotient.mk' E z
  have hz' : ‚àÉ n : ‚Ñï, (toEndomorphism K U Q v ^ n) z' = 0 := by
    rw [mem_engel_iff] at hz
    obtain ‚ü®n, hn‚ü© := hz
    use n
    apply_fun LieSubmodule.Quotient.mk' E at hn
    rw [LieModuleHom.map_zero] at hn
    rw [‚Üê hn]
    clear hn
    induction n with
    | zero => simp only [Nat.zero_eq, pow_zero, LinearMap.one_apply]
    | succ n ih => rw [pow_succ', pow_succ', LinearMap.mul_apply, ih]; rfl
  classical
  set n := Nat.find hz' with _hn
  have hn : (toEndomorphism K U Q v ^ n) z' = 0 := Nat.find_spec hz'
  obtain hn‚ÇÄ|‚ü®k, hk‚ü© : n = 0 ‚à® ‚àÉ k, n = k + 1 := by cases n <;> simp
  ¬∑ simpa only [hn‚ÇÄ, pow_zero, LinearMap.one_apply] using hn
  specialize hsœà Œ± hŒ±
  rw [‚Üê coe_evalRingHom, constantCoeff_apply, ‚Üê coeff_map, lieCharpoly_map_eval,
    ‚Üê constantCoeff_apply, ne_eq, LinearMap.charpoly_constantCoeff_eq_zero_iff] at hsœà
  contrapose!
  use (toEndomorphism K U Q v ^ k) z'
  refine ‚ü®?_, ?_‚ü©
  ¬∑ 
    apply Nat.find_min hz'; omega
  ¬∑ rw [‚Üê hn, hk, pow_succ', LinearMap.mul_apply]","error:  unknown identifier 'coe_toEndomorphism_pow'
error:  simp made no progress
error:  unknown identifier 'toEndomorphism_apply_apply'
error:  unknown identifier 'coe_toEndomorphism_pow'
error:  type mismatch
  h‚úù
has type
  ‚àÉ n, ((ad K L) ‚Üëv ^ n) ‚Üëz = 0 : Prop
but is expected to have type
  ‚àÉ n, ‚Üë(((toEnd K ‚Ü•U ‚Ü•(engel K x).toSubmodule) (Œ± ‚Ä¢ u + x') ^ n) z) = ‚Üë0 : Prop
error:  unknown identifier 'toEndomorphism'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  0
case h
K : Type u_1
L : Type u_2
inst‚úù¬≥ : Field K
inst‚úù¬≤ : LieRing L
inst‚úù¬π : LieAlgebra K L
inst‚úù : Module.Finite K L
hLK : ‚Üë(finrank K L) ‚â§ #K
U : LieSubalgebra K L
x : L
hxU : x ‚àà U
y : L
hyU : y ‚àà U
Ex : ‚Üë{x | ‚àÉ x_1 ‚àà U, engel K x_1 = x} := ‚ü®engel K x, ‚ãØ‚ü©
Ey : ‚Üë{x | ‚àÉ y ‚àà U, engel K y = x} := ‚ü®engel K y, ‚ãØ‚ü©
hUle : U ‚â§ ‚ÜëEx
hmin : ‚àÄ E ‚â§ Ex, Ex ‚â§ E
E : LieSubmodule K (‚Ü•U) L :=
  let __src := engel K x;
  { toSubmodule := __src.toSubmodule, lie_mem := ‚ãØ }
hx‚ÇÄ : x ‚â† 0
Q : Type u_2 := L ‚ß∏ E
r : ‚Ñï := finrank K ‚Ü•‚ÜëE
hr : r < finrank K L
x' : ‚Ü•U := ‚ü®x, hxU‚ü©
y' : ‚Ü•U := ‚ü®y, hyU‚ü©
u : ‚Ü•U := y' - x'
œá : K[X][X] := LieAlgebra.engel_isBot_of_isMin.lieCharpoly K (‚Ü•‚ÜëE) x' u
œà : K[X][X] := LieAlgebra.engel_isBot_of_isMin.lieCharpoly K Q x' u
i : ‚Ñï
hi : i < r
hi0 : i ‚â† 0
hœà : constantCoeff œà ‚â† 0
s : Finset K
hs : r ‚â§ s.card
hsœà : ‚àÄ Œ± ‚àà s, eval Œ± (constantCoeff œà) ‚â† 0
Œ± : K
hŒ± : Œ± ‚àà s
v : ‚Ü•U := Œ± ‚Ä¢ u + x'
z : L
z' : Q := (LieSubmodule.Quotient.mk' E) z
n : ‚Ñï
hn : (LieSubmodule.Quotient.mk' E) (((ad K L) ‚Üëv ^ n) z) = 0
‚ä¢ sorryAx ‚Ñï true = 0
error:  unknown identifier 'toEndomorphism'
error:  type mismatch
  Mathlib.Tactic.Contrapose.mtr ?m.196163
has type
  ?m.196161 ‚Üí ?m.196162 : Prop
but is expected to have type
  z' = 0 : Prop","lemma engel_isBot_of_isMin (hLK : finrank K L ‚â§ #K) (U : LieSubalgebra K L)
    (E : {engel K x | x ‚àà U}) (hUle : U ‚â§ E) (hmin : IsMin E) :
    IsBot E ",":= by
  rcases E with ‚ü®_, x, hxU, rfl‚ü©
  rintro ‚ü®_, y, hyU, rfl‚ü©
  set Ex : {engel K x | x ‚àà U} := ‚ü®engel K x, x, hxU, rfl‚ü©
  set Ey : {engel K y | y ‚àà U} := ‚ü®engel K y, y, hyU, rfl‚ü©
  replace hUle : U ‚â§ Ex := hUle
  replace hmin : ‚àÄ E, E ‚â§ Ex ‚Üí Ex ‚â§ E := @hmin
  let E : LieSubmodule K U L :=
  { engel K x with
    lie_mem := by rintro ‚ü®u, hu‚ü© y hy; exact (engel K x).lie_mem (hUle hu) hy }
  obtain rfl|hx‚ÇÄ := eq_or_ne x 0
  ¬∑ simpa [Ex, Ey] using hmin Ey
  let Q := L ‚ß∏ E
  let r := finrank K E
  obtain hr|hr : r = finrank K L ‚à® r < finrank K L := (Submodule.finrank_le _).eq_or_lt
  ¬∑ suffices engel K y ‚â§ engel K x from hmin Ey this
    suffices engel K x = ‚ä§ by simp_rw [this, le_top]
    apply LieSubalgebra.to_submodule_injective
    apply Submodule.eq_top_of_finrank_eq hr
  set x' : U := ‚ü®x, hxU‚ü©
  set y' : U := ‚ü®y, hyU‚ü©
  let u : U := y' - x'
  let œá : Polynomial (K[X]) := lieCharpoly K E x' u
  let œà : Polynomial (K[X]) := lieCharpoly K Q x' u
  suffices œá = X ^ r by
    apply_fun (fun p ‚Ü¶ p.map (evalRingHom 1)) at this
    simp_rw [Polynomial.map_pow, map_X, œá, lieCharpoly_map_eval, one_smul, u, sub_add_cancel,
      r, LinearMap.charpoly_eq_X_pow_iff,
      Subtype.ext_iff, coe_toEnd_pow _ _ _ E, ZeroMemClass.coe_zero] at this
    intro z hz
    rw [mem_engel_iff]
    exact this ‚ü®z, hz‚ü©
  suffices ‚àÄ i < r, œá.coeff i = 0 by
    simp_rw [r, ‚Üê lieCharpoly_natDegree K E x' u] at this ‚ä¢
    rw [(lieCharpoly_monic K E x' u).eq_X_pow_iff_natDegree_le_natTrailingDegree]
    exact le_natTrailingDegree (lieCharpoly_monic K E x' u).ne_zero this
  intro i hi
  obtain rfl|hi0 := eq_or_ne i 0
  ¬∑ 
    apply eq_zero_of_forall_eval_zero_of_natDegree_lt_card _ _ ?deg
    case deg =>
      apply lt_of_lt_of_le _ hLK
      rw [Nat.cast_lt]
      apply lt_of_le_of_lt _ hr
      apply lieCharpoly_coeff_natDegree _ _ _ _ 0 r (zero_add r)
    intro Œ±
    rw [‚Üê coe_evalRingHom, ‚Üê coeff_map, lieCharpoly_map_eval,
      ‚Üê constantCoeff_apply, LinearMap.charpoly_constantCoeff_eq_zero_iff]
    let z := Œ± ‚Ä¢ u + x'
    obtain hz‚ÇÄ|hz‚ÇÄ := eq_or_ne z 0
    ¬∑ 
      refine ‚ü®‚ü®x, self_mem_engel K x‚ü©, ?_, ?_‚ü©
      ¬∑ simpa [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero] using hx‚ÇÄ
      ¬∑ dsimp only [z] at hz‚ÇÄ
        simp only [coe_bracket_of_module, hz‚ÇÄ, LieHom.map_zero, LinearMap.zero_apply]
    refine ‚ü®‚ü®z, hUle z.2‚ü©, ?_, ?_‚ü©
    ¬∑ simpa only [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero, Subtype.ext_iff] using hz‚ÇÄ
    ¬∑ show ‚ÅÖz, _‚ÅÜ = (0 : E)
      ext
      exact lie_self z.1
  have hœà : constantCoeff œà ‚â† 0 := by
    intro H
    obtain ‚ü®z, hz0, hxz‚ü© : ‚àÉ z : Q, z ‚â† 0 ‚àß ‚ÅÖx', z‚ÅÜ = 0 := by
      apply_fun (evalRingHom 0) at H
      rw [constantCoeff_apply, ‚Üê coeff_map, lieCharpoly_map_eval,
        ‚Üê constantCoeff_apply, map_zero, LinearMap.charpoly_constantCoeff_eq_zero_iff] at H
      simpa only [coe_bracket_of_module, ne_eq, zero_smul, zero_add, toEnd_apply_apply]
        using H
    apply hz0
    obtain ‚ü®z, rfl‚ü© := LieSubmodule.Quotient.surjective_mk' E z
    have : ‚ÅÖx, z‚ÅÜ ‚àà E := by rwa [‚Üê LieSubmodule.Quotient.mk_eq_zero']
    simp only [coe_bracket_of_module, LieSubmodule.mem_mk_iff', mem_coe_submodule, mem_engel_iff,
      LieSubmodule.Quotient.mk'_apply, LieSubmodule.Quotient.mk_eq_zero', E, Q] at this ‚ä¢
    obtain ‚ü®n, hn‚ü© := this
    use n+1
    rwa [pow_succ]
  obtain ‚ü®s, hs, hsœà‚ü© : ‚àÉ s : Finset K, r ‚â§ s.card ‚àß ‚àÄ Œ± ‚àà s, (constantCoeff œà).eval Œ± ‚â† 0 := by
    classical
    let t := (constantCoeff œà).roots.toFinset
    have ht : t.card ‚â§ finrank K L - r := by
      refine (Multiset.toFinset_card_le _).trans ?_
      refine (card_roots' _).trans ?_
      rw [constantCoeff_apply]
      apply lieCharpoly_coeff_natDegree
      suffices finrank K Q + r = finrank K L by rw [‚Üê this, zero_add, Nat.add_sub_cancel]
      apply Submodule.finrank_quotient_add_finrank
    obtain ‚ü®s, hs‚ü© := exists_finset_le_card K _ hLK
    use s \ t
    refine ‚ü®?_, ?_‚ü©
    ¬∑ refine le_trans ?_ (Finset.le_card_sdiff _ _)
      omega
    ¬∑ intro Œ± hŒ±
      simp only [Finset.mem_sdiff, Multiset.mem_toFinset, mem_roots', IsRoot.def, not_and, t] at hŒ±
      exact hŒ±.2 hœà
  apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero' _ s _ ?hcard
  case hcard =>
    apply lt_of_le_of_lt (lieCharpoly_coeff_natDegree _ _ _ _ i (r - i) _)
    ¬∑ omega
    ¬∑ dsimp only [r] at hi ‚ä¢
      rw [Nat.add_sub_cancel' hi.le]
  intro Œ± hŒ±
  rw [‚Üê coe_evalRingHom, ‚Üê coeff_map, lieCharpoly_map_eval,
    (LinearMap.charpoly_eq_X_pow_iff _).mpr, coeff_X_pow, if_neg hi.ne]
  let v := Œ± ‚Ä¢ u + x'
  suffices engel K (v : L) ‚â§ engel K x by
    replace this : engel K x ‚â§ engel K (v : L) := (hmin ‚ü®_, v, v.2, rfl‚ü© this).ge
    intro z
    simpa only [mem_engel_iff, Subtype.ext_iff, coe_toEnd_pow _ _ _ E] using this z.2
  intro z hz
  show z ‚àà E
  rw [‚Üê LieSubmodule.Quotient.mk_eq_zero]
  set z' : Q := LieSubmodule.Quotient.mk' E z
  have hz' : ‚àÉ n : ‚Ñï, (toEnd K U Q v ^ n) z' = 0 := by
    rw [mem_engel_iff] at hz
    obtain ‚ü®n, hn‚ü© := hz
    use n
    apply_fun LieSubmodule.Quotient.mk' E at hn
    rw [LieModuleHom.map_zero] at hn
    rw [‚Üê hn]
    clear hn
    induction n with
    | zero => simp only [Nat.zero_eq, pow_zero, LinearMap.one_apply]
    | succ n ih => rw [pow_succ', pow_succ', LinearMap.mul_apply, ih]; rfl
  classical
  set n := Nat.find hz' with _hn
  have hn : (toEnd K U Q v ^ n) z' = 0 := Nat.find_spec hz'
  obtain hn‚ÇÄ|‚ü®k, hk‚ü© : n = 0 ‚à® ‚àÉ k, n = k + 1 := by cases n <;> simp
  ¬∑ simpa only [hn‚ÇÄ, pow_zero, LinearMap.one_apply] using hn
  specialize hsœà Œ± hŒ±
  rw [‚Üê coe_evalRingHom, constantCoeff_apply, ‚Üê coeff_map, lieCharpoly_map_eval,
    ‚Üê constantCoeff_apply, ne_eq, LinearMap.charpoly_constantCoeff_eq_zero_iff] at hsœà
  contrapose! hsœà
  use (toEnd K U Q v ^ k) z'
  refine ‚ü®?_, ?_‚ü©
  ¬∑ 
    apply Nat.find_min hz'; omega
  ¬∑ rw [‚Üê hn, hk, pow_succ', LinearMap.mul_apply]"
Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean,Real.Angle.sin_antiperiodic,sin_antiperiodic,c342c339a777827331257acd880fea6d441a6aa6,":= by
  intro Œ∏
  induction Œ∏
  exact Real.sin_antiperiodic _","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Œ∏ : Angle
‚ä¢ (Œ∏ + ‚ÜëœÄ).sin = -Œ∏.sin",theorem sin_antiperiodic : Function.Antiperiodic sin (œÄ : Angle) ,":= by
  intro Œ∏
  induction Œ∏ using Real.Angle.induction_on
  exact Real.sin_antiperiodic _"
Mathlib/CategoryTheory/Filtered/Basic.lean,CategoryTheory.IsFiltered.sup_objs_exists,sup_objs_exists,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
  induction' O with X O' nm h
  ¬∑ exact ‚ü®Classical.choice IsFiltered.nonempty, by intro; simp‚ü©
  ¬∑ obtain ‚ü®S', w'‚ü© := h
    use max X S'
    rintro Y mY
    obtain rfl | h := eq_or_ne Y X
    ¬∑ exact ‚ü®leftToMax _ _‚ü©
    ¬∑ exact ‚ü®(w' (Finset.mem_of_mem_insert_of_ne mY h)).some ‚â´ rightToMax _ _‚ü©","error:  unsolved goals
C : Type u
inst‚úù¬π : Category.{v, u} C
inst‚úù : IsFiltered C
X : Multiset C
O' : X.Nodup
X‚úù : C
‚ä¢ X‚úù ‚àà X ‚Üí Nonempty (X‚úù ‚ü∂ Classical.choice ‚ãØ)
error:  no goals to be solved","theorem sup_objs_exists (O : Finset C) : ‚àÉ S : C, ‚àÄ {X}, X ‚àà O ‚Üí Nonempty (X ‚ü∂ S) ",":= by
  classical
  induction' O using Finset.induction with X O' nm h
  ¬∑ exact ‚ü®Classical.choice IsFiltered.nonempty, by intro; simp‚ü©
  ¬∑ obtain ‚ü®S', w'‚ü© := h
    use max X S'
    rintro Y mY
    obtain rfl | h := eq_or_ne Y X
    ¬∑ exact ‚ü®leftToMax _ _‚ü©
    ¬∑ exact ‚ü®(w' (Finset.mem_of_mem_insert_of_ne mY h)).some ‚â´ rightToMax _ _‚ü©"
Mathlib/CategoryTheory/Adjunction/FullyFaithful.lean,CategoryTheory.Adjunction.inv_map_unit,inv_map_unit,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  IsIso.inv_eq_of_hom_inv_id h.left_triangle_components","error:  application type mismatch
  IsIso.inv_eq_of_hom_inv_id (left_triangle_components h)
argument
  left_triangle_components h
has type
  ‚àÄ (X : C), L.map (h.unit.app X) ‚â´ h.counit.app (L.obj X) = ùüô (L.obj X) : Prop
but is expected to have type
  L.map (h.unit.app X) ‚â´ h.counit.app (L.obj X) = ùüô (L.obj ((ùü≠ C).obj X)) : Prop","theorem inv_map_unit {X : C} [IsIso (h.unit.app X)] :
    inv (L.map (h.unit.app X)) = h.counit.app (L.obj X) ",":=
  IsIso.inv_eq_of_hom_inv_id (h.left_triangle_components X)"
Mathlib/Geometry/Euclidean/Basic.lean,EuclideanGeometry.orthogonalProjectionFn_mem,orthogonalProjectionFn_mem,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [‚Üê mem_coe, ‚Üê Set.singleton_subset_iff, ‚Üê inter_eq_singleton_orthogonalProjectionFn]
  exact Set.inter_subset_left _ _","error:  function expected at
  Set.inter_subset_left ?m.88147
term has type
  ?m.88146 ‚àà ?m.88144","theorem orthogonalProjectionFn_mem {s : AffineSubspace ‚Ñù P} [Nonempty s]
    [HasOrthogonalProjection s.direction] (p : P) : orthogonalProjectionFn s p ‚àà s ",":= by
  rw [‚Üê mem_coe, ‚Üê Set.singleton_subset_iff, ‚Üê inter_eq_singleton_orthogonalProjectionFn]
  exact Set.inter_subset_left"
Mathlib/SetTheory/Cardinal/SchroederBernstein.lean,Function.Embedding.schroeder_bernstein,schroeder_bernstein,2714dce065bad0ddf3bede6acabcadb21606d65b,":=
  by
  cases' isEmpty_or_nonempty Œ≤ with hŒ≤ hŒ≤
  ¬∑ have : IsEmpty Œ± := Function.isEmpty f
    exact ‚ü®_, ((Equiv.equivEmpty Œ±).trans (Equiv.equivEmpty Œ≤).symm).bijective‚ü©
  set F : Set Œ± ‚Üío Set Œ± :=
    { toFun := fun s => (g '' (f '' s)·∂ú)·∂ú
      monotone' := fun s t hst =>
        compl_subset_compl.mpr <| image_subset _ <| compl_subset_compl.mpr <| image_subset _ hst }
  set s : Set Œ± := OrderHom.lfp F
  have hs : (g '' (f '' s)·∂ú)·∂ú = s := F.map_lfp
  have hns : g '' (f '' s)·∂ú = s·∂ú := compl_injective (by simp [hs])
  set g' := invFun g
  have g'g : LeftInverse g' g := leftInverse_invFun hg
  have hg'ns : g' '' s·∂ú = (f '' s)·∂ú := by rw [‚Üê hns, g'g.image_image]
  set h : Œ± ‚Üí Œ≤ := s.piecewise f g'
  have : Surjective h := by rw [‚Üê range_iff_surjective, range_piecewise, hg'ns, union_compl_self]
  have : Injective h :=
    by
    refine' (injective_piecewise_iff _).2 ‚ü®hf.injOn _, _, _‚ü©
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®x', _, rfl‚ü© : x ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      obtain ‚ü®y', _, rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _, g'g _] at hxy
      rw [hxy]
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®y', hy', rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _] at hxy
      exact hy' ‚ü®x, hx, hxy‚ü©
  exact ‚ü®h, ‚ÄπInjective h‚Ä∫, ‚ÄπSurjective h‚Ä∫‚ü©","error:  application type mismatch
  And.intro (Injective.injOn hf ?m.1813)
argument
  Injective.injOn hf ?m.1813
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Œ±‚¶Ñ, x‚ÇÇ ‚àà ?m.1811 ‚Üí f ?m.1812 = f x‚ÇÇ ‚Üí ?m.1812 = x‚ÇÇ : Prop
but is expected to have type
  InjOn f s : Prop","theorem schroeder_bernstein {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ±} (hf : Function.Injective f)
    (hg : Function.Injective g) : ‚àÉ h : Œ± ‚Üí Œ≤, Bijective h ",":= by
  cases' isEmpty_or_nonempty Œ≤ with hŒ≤ hŒ≤
  ¬∑ have : IsEmpty Œ± := Function.isEmpty f
    exact ‚ü®_, ((Equiv.equivEmpty Œ±).trans (Equiv.equivEmpty Œ≤).symm).bijective‚ü©
  set F : Set Œ± ‚Üío Set Œ± :=
    { toFun := fun s => (g '' (f '' s)·∂ú)·∂ú
      monotone' := fun s t hst =>
        compl_subset_compl.mpr <| image_subset _ <| compl_subset_compl.mpr <| image_subset _ hst }
  set s : Set Œ± := OrderHom.lfp F
  have hs : (g '' (f '' s)·∂ú)·∂ú = s := F.map_lfp
  have hns : g '' (f '' s)·∂ú = s·∂ú := compl_injective (by simp [hs])
  set g' := invFun g
  have g'g : LeftInverse g' g := leftInverse_invFun hg
  have hg'ns : g' '' s·∂ú = (f '' s)·∂ú := by rw [‚Üê hns, g'g.image_image]
  set h : Œ± ‚Üí Œ≤ := s.piecewise f g'
  have : Surjective h := by rw [‚Üê range_iff_surjective, range_piecewise, hg'ns, union_compl_self]
  have : Injective h := by
    refine (injective_piecewise_iff _).2 ‚ü®hf.injOn, ?_, ?_‚ü©
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®x', _, rfl‚ü© : x ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      obtain ‚ü®y', _, rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _, g'g _] at hxy
      rw [hxy]
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®y', hy', rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _] at hxy
      exact hy' ‚ü®x, hx, hxy‚ü©
  exact ‚ü®h, ‚ÄπInjective h‚Ä∫, ‚ÄπSurjective h‚Ä∫‚ü©"
Mathlib/Analysis/Complex/PhragmenLindelof.lean,PhragmenLindelof.horizontal_strip,horizontal_strip,4da4e0ebfbf51ecc2e064d04970434177efdead3,":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm
  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb
  wlog hC‚ÇÄ : 0 < C generalizing C
  ¬∑ refine le_of_forall_le_of_dense fun C' hC' => this (fun w hw => ?_) (fun w hw => ?_?) _
    ¬∑ exact (hle_a _ hw).trans hC'.le
    ¬∑ exact (hle_b _ hw).trans hC'.le
    ¬∑ refine ((norm_nonneg (f (a * I))).trans (hle_a _ ?_)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=
    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB
  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with ‚ü®c, hc, B, hO‚ü©
  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)
  have hb' : d * b < œÄ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)
  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))
  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C by
    refine le_of_tendsto (Tendsto.mono_left ?_ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ
  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :
    ‚àÉ Œ¥ : ‚Ñù,
      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by
    refine
      ‚ü®Œµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Œµ‚ÇÄ
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),
        fun w hw => ?_‚ü©
    replace hw : |im (aff w)| ‚â§ d * b := by
      rw [‚Üê Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,
        mul_le_mul_left hd‚ÇÄ]
    simpa only [aff, re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le
  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by
    refine fun w hw => (hŒ¥ <| hw.by_cases ?_ ?_).trans (Real.exp_le_one_iff.2? _)
    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]
  obtain ‚ü®R, hzR, hR‚ü© :
    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by
    refine ((eventually_gt_atTop _).and ?_).exists
    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,
      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0) by
      filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him
      calc
        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ ‚â§ C := hR
      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine Real.tendsto_exp_atBot.comp ?_
    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine Tendsto.atBot_add ?_ tendsto_const_nhds
      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id
    refine tendsto_const_nhds.add (tendsto_const_nhds.mul ?_)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable ‚ÑÇ (g Œµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono (inter_subset_right _ _)
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw
    by_cases him : w.im = a - b ‚à® w.im = a + b
    ¬∑ rw [norm_smul, ‚Üê one_mul C]
      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b) := hw.resolve_left fun h ‚Ü¶ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'
      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)
  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]
    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©","error:  unexpected token '?'; expected ')', ',' or ':'
error:  don't know how to synthesize placeholder for argument 'hC‚ÇÄ'
context:
E : Type u_1
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚ÑÇ E
a b C : ‚Ñù
f g : ‚ÑÇ ‚Üí E
z : ‚ÑÇ
hfd : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo a b)
hB :
  ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo a b)] fun z ‚Ü¶ expR (B * expR (c * |z.re|))
hle_a : ‚àÄ (z : ‚ÑÇ), z.im = a ‚Üí ‚Äñf z‚Äñ ‚â§ C
hle_b : ‚àÄ (z : ‚ÑÇ), z.im = b ‚Üí ‚Äñf z‚Äñ ‚â§ C
hza : a < z.im
hzb : z.im < b
this : ‚àÄ {C : ‚Ñù}, (‚àÄ (z : ‚ÑÇ), z.im = a ‚Üí ‚Äñf z‚Äñ ‚â§ C) ‚Üí (‚àÄ (z : ‚ÑÇ), z.im = b ‚Üí ‚Äñf z‚Äñ ‚â§ C) ‚Üí 0 < C ‚Üí ‚Äñf z‚Äñ ‚â§ C
hC‚ÇÄ : ¬¨0 < C
C' : ‚Ñù
hC' : C < C'
‚ä¢ 0 < C'
error:  unsolved goals
case refine_1
E : Type u_1
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚ÑÇ E
C‚úù : ‚Ñù
f g‚úù : ‚ÑÇ ‚Üí E
z : ‚ÑÇ
C : ‚Ñù
hC‚ÇÄ : 0 < C
a b : ‚Ñù
hza : a - b < z.im
hle_a : ‚àÄ (z : ‚ÑÇ), z.im = a - b ‚Üí ‚Äñf z‚Äñ ‚â§ C
hzb : z.im < a + b
hle_b : ‚àÄ (z : ‚ÑÇ), z.im = a + b ‚Üí ‚Äñf z‚Äñ ‚â§ C
hfd : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo (a - b) (a + b))
hab : a - b < a + b
hb : 0 < b
hœÄb : 0 < œÄ / 2 / b
c : ‚Ñù
hc : c < œÄ / 2 / b
B : ‚Ñù
hO : f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo (a - b) (a + b))] fun z ‚Ü¶ expR (B * expR (c * |z.re|))
d : ‚Ñù
hd : d < œÄ / 2 / b
hcd : c < d
hd‚ÇÄ : 0 < d
hb' : d * b < œÄ / 2
aff : ‚ÑÇ ‚Üí ‚ÑÇ := fun w ‚Ü¶ ‚Üëd * (w - ‚Üëa * I)
g : ‚Ñù ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ := fun Œµ w ‚Ü¶ cexp (‚ÜëŒµ * (cexp (aff w) + cexp (-aff w)))
Œµ : ‚Ñù
Œµ‚ÇÄ : Œµ < 0
Œ¥ : ‚Ñù
Œ¥‚ÇÄ : Œ¥ < 0
hŒ¥ : ‚àÄ ‚¶Éw : ‚ÑÇ‚¶Ñ, w.im ‚àà Icc (a - b) (a + b) ‚Üí Complex.abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |w.re|))
w : ‚ÑÇ
hw : w.im = a - b ‚à® w.im = a + b
‚ä¢ w.im = a - b ‚Üí w.im ‚àà Icc (a - b) (a + b)

case refine_2
E : Type u_1
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚ÑÇ E
C‚úù : ‚Ñù
f g‚úù : ‚ÑÇ ‚Üí E
z : ‚ÑÇ
C : ‚Ñù
hC‚ÇÄ : 0 < C
a b : ‚Ñù
hza : a - b < z.im
hle_a : ‚àÄ (z : ‚ÑÇ), z.im = a - b ‚Üí ‚Äñf z‚Äñ ‚â§ C
hzb : z.im < a + b
hle_b : ‚àÄ (z : ‚ÑÇ), z.im = a + b ‚Üí ‚Äñf z‚Äñ ‚â§ C
hfd : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo (a - b) (a + b))
hab : a - b < a + b
hb : 0 < b
hœÄb : 0 < œÄ / 2 / b
c : ‚Ñù
hc : c < œÄ / 2 / b
B : ‚Ñù
hO : f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo (a - b) (a + b))] fun z ‚Ü¶ expR (B * expR (c * |z.re|))
d : ‚Ñù
hd : d < œÄ / 2 / b
hcd : c < d
hd‚ÇÄ : 0 < d
hb' : d * b < œÄ / 2
aff : ‚ÑÇ ‚Üí ‚ÑÇ := fun w ‚Ü¶ ‚Üëd * (w - ‚Üëa * I)
g : ‚Ñù ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ := fun Œµ w ‚Ü¶ cexp (‚ÜëŒµ * (cexp (aff w) + cexp (-aff w)))
Œµ : ‚Ñù
Œµ‚ÇÄ : Œµ < 0
Œ¥ : ‚Ñù
Œ¥‚ÇÄ : Œ¥ < 0
hŒ¥ : ‚àÄ ‚¶Éw : ‚ÑÇ‚¶Ñ, w.im ‚àà Icc (a - b) (a + b) ‚Üí Complex.abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |w.re|))
w : ‚ÑÇ
hw : w.im = a - b ‚à® w.im = a + b
‚ä¢ w.im = a + b ‚Üí w.im ‚àà Icc (a - b) (a + b)
error:  unsolved goals
case h.intro.intro
E : Type u_1
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚ÑÇ E
C‚úù : ‚Ñù
f g‚úù : ‚ÑÇ ‚Üí E
z : ‚ÑÇ
C : ‚Ñù
hC‚ÇÄ : 0 < C
a b : ‚Ñù
hza : a - b < z.im
hle_a : ‚àÄ (z : ‚ÑÇ), z.im = a - b ‚Üí ‚Äñf z‚Äñ ‚â§ C
hzb : z.im < a + b
hle_b : ‚àÄ (z : ‚ÑÇ), z.im = a + b ‚Üí ‚Äñf z‚Äñ ‚â§ C
hfd : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo (a - b) (a + b))
hab : a - b < a + b
hb : 0 < b
hœÄb : 0 < œÄ / 2 / b
c : ‚Ñù
hc : c < œÄ / 2 / b
B : ‚Ñù
hO : f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo (a - b) (a + b))] fun z ‚Ü¶ expR (B * expR (c * |z.re|))
d : ‚Ñù
hd : d < œÄ / 2 / b
hcd : c < d
hd‚ÇÄ : 0 < d
hb' : d * b < œÄ / 2
aff : ‚ÑÇ ‚Üí ‚ÑÇ := fun w ‚Ü¶ ‚Üëd * (w - ‚Üëa * I)
g : ‚Ñù ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ := fun Œµ w ‚Ü¶ cexp (‚ÜëŒµ * (cexp (aff w) + cexp (-aff w)))
Œµ : ‚Ñù
Œµ‚ÇÄ : Œµ < 0
Œ¥ : ‚Ñù
Œ¥‚ÇÄ : Œ¥ < 0
hŒ¥ : ‚àÄ ‚¶Éw : ‚ÑÇ‚¶Ñ, w.im ‚àà Icc (a - b) (a + b) ‚Üí Complex.abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |w.re|))
hg‚ÇÅ : ‚àÄ (w : ‚ÑÇ), w.im = a - b ‚à® w.im = a + b ‚Üí Complex.abs (g Œµ w) ‚â§ 1
‚ä¢ ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C","theorem horizontal_strip (hfd : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo a b))
    (hB : ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo a b)]
      fun z ‚Ü¶ expR (B * expR (c * |z.re|)))
    (hle_a : ‚àÄ z : ‚ÑÇ, im z = a ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hle_b : ‚àÄ z, im z = b ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hza : a ‚â§ im z)
    (hzb : im z ‚â§ b) : ‚Äñf z‚Äñ ‚â§ C ",":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm
  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb
  wlog hC‚ÇÄ : 0 < C generalizing C
  ¬∑ refine le_of_forall_le_of_dense fun C' hC' => this (fun w hw => ?_) (fun w hw => ?_) ?_
    ¬∑ exact (hle_a _ hw).trans hC'.le
    ¬∑ exact (hle_b _ hw).trans hC'.le
    ¬∑ refine ((norm_nonneg (f (a * I))).trans (hle_a _ ?_)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=
    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB
  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with ‚ü®c, hc, B, hO‚ü©
  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)
  have hb' : d * b < œÄ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)
  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))
  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C by
    refine le_of_tendsto (Tendsto.mono_left ?_ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ
  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :
    ‚àÉ Œ¥ : ‚Ñù,
      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by
    refine
      ‚ü®Œµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Œµ‚ÇÄ
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),
        fun w hw => ?_‚ü©
    replace hw : |im (aff w)| ‚â§ d * b := by
      rw [‚Üê Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,
        mul_le_mul_left hd‚ÇÄ]
    simpa only [aff, re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le
  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by
    refine fun w hw => (hŒ¥ <| hw.by_cases ?_ ?_).trans (Real.exp_le_one_iff.2 ?_)
    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]
  obtain ‚ü®R, hzR, hR‚ü© :
    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by
    refine ((eventually_gt_atTop _).and ?_).exists
    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,
      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0) by
      filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him
      calc
        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ ‚â§ C := hR
      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine Real.tendsto_exp_atBot.comp ?_
    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine Tendsto.atBot_add ?_ tendsto_const_nhds
      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id
    refine tendsto_const_nhds.add (tendsto_const_nhds.mul ?_)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable ‚ÑÇ (g Œµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono inter_subset_right
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw
    by_cases him : w.im = a - b ‚à® w.im = a + b
    ¬∑ rw [norm_smul, ‚Üê one_mul C]
      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b) := hw.resolve_left fun h ‚Ü¶ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'
      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)
  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]
    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©"
Mathlib/Topology/Algebra/Valuation.lean,Valuation.subgroups_basis,subgroups_basis,20100f1475ea197bf6dea643b6ee137219455a51,":=
  { inter := by
      rintro Œ≥‚ÇÄ Œ≥‚ÇÅ
      use min Œ≥‚ÇÄ Œ≥‚ÇÅ
      simp [Valuation.ltAddSubgroup]
      tauto
    mul := by
      rintro Œ≥
      cases' exists_square_le Œ≥ with Œ≥‚ÇÄ h
      use Œ≥‚ÇÄ
      rintro - ‚ü®r, s, r_in, s_in, rfl‚ü©
      calc
        (v (r * s) : Œì‚ÇÄ) = v r * v s := Valuation.map_mul _ _ _
        _ < Œ≥‚ÇÄ * Œ≥‚ÇÄ := (mul_lt_mul‚ÇÄ r_in s_in)
        _ ‚â§ Œ≥ := by exact_mod_cast h
    leftMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use (1 : Œì‚ÇÄÀ£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (x * y) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt
    rightMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (y * x) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt }","error:  application type mismatch
  v s
argument
  s
has type
  r ‚àà ‚Üë(v.ltAddSubgroup Œ≥‚ÇÄ) : Prop
but is expected to have type
  R : Type u
error:  invalid 'calc' step, failed to synthesize `Trans` instance
  Trans LT.lt Membership.mem ?m.35107
use `set_option diagnostics true` to get diagnostic information",theorem subgroups_basis : RingSubgroupsBasis fun Œ≥ : Œì‚ÇÄÀ£ => (v.ltAddSubgroup Œ≥ : AddSubgroup R) ,":=
  { inter := by
      rintro Œ≥‚ÇÄ Œ≥‚ÇÅ
      use min Œ≥‚ÇÄ Œ≥‚ÇÅ
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro Œ≥
      cases' exists_square_le Œ≥ with Œ≥‚ÇÄ h
      use Œ≥‚ÇÄ
      rintro - ‚ü®r, r_in, s, s_in, rfl‚ü©
      calc
        (v (r * s) : Œì‚ÇÄ) = v r * v s := Valuation.map_mul _ _ _
        _ < Œ≥‚ÇÄ * Œ≥‚ÇÄ := mul_lt_mul‚ÇÄ r_in s_in
        _ ‚â§ Œ≥ := mod_cast h
    leftMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use (1 : Œì‚ÇÄÀ£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (x * y) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt
    rightMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (y * x) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt }"
Mathlib/Algebra/Lie/Basic.lean,LieModule.compLieHom,LieModule.compLieHom,562ef64b30b31635aceb974705e1f5109e5b0bc1,":=
  { LieRingModule.compLieHom M f with
    smul_lie := fun t x m => by
      simp only [LieRingModule.compLieHom_apply, smul_lie, LieHom.map_smul]
    lie_smul := fun t x m => by
      simp only [LieRingModule.compLieHom_apply, lie_smul] }","warning:  LieHom does not have a doc string
error:  failed to synthesize
  LieRingModule L‚ÇÅ M
use `set_option diagnostics true` to get diagnostic information
warning:  LieEquiv does not have a doc string
warning:  LieModuleHom does not have a doc string
warning:  LieModuleEquiv does not have a doc string","theorem LieModule.compLieHom [Module R M] [LieModule R L‚ÇÇ M] :
    @LieModule R L‚ÇÅ M _ _ _ _ _ (LieRingModule.compLieHom M f) ",":=
  { __ := LieRingModule.compLieHom M f
    smul_lie := fun t x m => by
      simp only [LieRingModule.compLieHom_apply, smul_lie, LieHom.map_smul]
    lie_smul := fun t x m => by
      simp only [LieRingModule.compLieHom_apply, lie_smul] }"
Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean,MeasureTheory.exists_lt_lowerSemicontinuous_integral_lt,exists_lt_lowerSemicontinuous_integral_lt,7fa0a827960832ef960210f51c78c246882fbb79,":= by
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ / 2, (half_pos Œµpos).le‚ü©
  have Œ¥pos : 0 < Œ¥ := half_pos Œµpos
  let fp : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (f x)
  have int_fp : Integrable (fun x => (fp x : ‚Ñù)) Œº := hf.real_toNNReal
  rcases exists_lt_lowerSemicontinuous_integral_gt_nnreal fp int_fp Œ¥pos with
    ‚ü®gp, fp_lt_gp, gpcont, gp_lt_top, gp_integrable, gpint‚ü©
  let fm : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (-f x)
  have int_fm : Integrable (fun x => (fm x : ‚Ñù)) Œº := hf.neg.real_toNNReal
  rcases exists_upperSemicontinuous_le_integral_le fm int_fm Œ¥pos with
    ‚ü®gm, gm_le_fm, gmcont, gm_integrable, gmint‚ü©
  let g : Œ± ‚Üí EReal := fun x => (gp x : EReal) - gm x
  have ae_g : ‚àÄ·µê x ‚àÇŒº, (g x).toReal = (gp x : EReal).toReal - (gm x : EReal).toReal := by
    filter_upwards [gp_lt_top] with _ hx
    rw [EReal.toReal_sub] <;> simp [hx.ne]
  refine' ‚ü®g, ?lt, ?lsc, ?int, ?aelt, ?intlt‚ü©
  case int =>
    show Integrable (fun x => EReal.toReal (g x)) Œº
    rw [integrable_congr ae_g]
    convert gp_integrable.sub gm_integrable
    simp
  case intlt =>
    show (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) < (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ;
    exact
      calc
        (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) = ‚à´ x : Œ±, EReal.toReal (gp x) - EReal.toReal (gm x) ‚àÇŒº :=
          integral_congr_ae ae_g
        _ = (‚à´ x : Œ±, EReal.toReal (gp x) ‚àÇŒº) - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          simp only [EReal.toReal_coe_ennreal, ENNReal.coe_toReal]
          exact integral_sub gp_integrable gm_integrable
        _ < (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          apply sub_lt_sub_right
          convert gpint
          simp only [EReal.toReal_coe_ennreal]
        _ ‚â§ (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ((‚à´ x : Œ±, ‚Üë(fm x) ‚àÇŒº) - Œ¥) := (sub_le_sub_left gmint _)
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + 2 * Œ¥ := by
          simp_rw [integral_eq_integral_pos_part_sub_integral_neg_part hf]; ring
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ := by congr 1; field_simp [Œ¥, mul_comm]
  case aelt =>
    show ‚àÄ·µê x : Œ± ‚àÇŒº, g x < ‚ä§
    filter_upwards [gp_lt_top] with ?_ hx
    simp only [g, sub_eq_add_neg, Ne.def, (EReal.add_lt_top _ _).ne, lt_top_iff_ne_top,
      lt_top_iff_ne_top.1 hx, EReal.coe_ennreal_eq_top_iff, not_false_iff, EReal.neg_eq_top_iff,
      EReal.coe_ennreal_ne_bot]
  case lt =>
    show ‚àÄ x, (f x : EReal) < g x
    intro x
    rw [EReal.coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal (f x)]
    refine' EReal.sub_lt_sub_of_lt_of_le _ _ _ _
    ¬∑ simp only [EReal.coe_ennreal_lt_coe_ennreal_iff]; exact fp_lt_gp x
    ¬∑ simp only [ENNReal.coe_le_coe, EReal.coe_ennreal_le_coe_ennreal_iff]
      exact gm_le_fm x
    ¬∑ simp only [EReal.coe_ennreal_ne_bot, Ne.def, not_false_iff]
    ¬∑ simp only [EReal.coe_nnreal_ne_top, Ne.def, not_false_iff]
  case lsc =>
    show LowerSemicontinuous g
    apply LowerSemicontinuous.add'
    ¬∑ exact continuous_coe_ennreal_ereal.comp_lowerSemicontinuous gpcont fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
    ¬∑ apply continuous_neg.comp_upperSemicontinuous_antitone _ fun x y hxy =>
          EReal.neg_le_neg_iff.2 hxy
      dsimp
      apply continuous_coe_ennreal_ereal.comp_upperSemicontinuous _ fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
      exact ENNReal.continuous_coe.comp_upperSemicontinuous gmcont fun x y hxy =>
          ENNReal.coe_le_coe.2 hxy
    ¬∑ intro x
      exact EReal.continuousAt_add (by simp) (by simp)","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.139261 ‚Üí ?m.139261 ‚Üí Prop
error:  unsolved goals
case h
Œ± : Type u_1
inst‚úù‚Å¥ : TopologicalSpace Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : BorelSpace Œ±
Œº : Measure Œ±
inst‚úù¬π : Œº.WeaklyRegular
inst‚úù : SigmaFinite Œº
f : Œ± ‚Üí ‚Ñù
hf : Integrable f Œº
Œµ : ‚Ñù
Œµpos : 0 < Œµ
Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ / 2, ‚ãØ‚ü©
Œ¥pos : 0 < Œ¥
fp : Œ± ‚Üí ‚Ñù‚â•0 := fun x ‚Ü¶ (f x).toNNReal
int_fp : Integrable (fun x ‚Ü¶ ‚Üë(fp x)) Œº
gp : Œ± ‚Üí ‚Ñù‚â•0‚àû
fp_lt_gp : ‚àÄ (x : Œ±), ‚Üë(fp x) < gp x
gpcont : LowerSemicontinuous gp
gp_lt_top : ‚àÄ·µê (x : Œ±) ‚àÇŒº, gp x < ‚ä§
gp_integrable : Integrable (fun x ‚Ü¶ (gp x).toReal) Œº
gpint : ‚à´ (x : Œ±), (gp x).toReal ‚àÇŒº < ‚à´ (x : Œ±), ‚Üë(fp x) ‚àÇŒº + (fun a ‚Ü¶ ‚Üëa) Œ¥
fm : Œ± ‚Üí ‚Ñù‚â•0 := fun x ‚Ü¶ (-f x).toNNReal
int_fm : Integrable (fun x ‚Ü¶ ‚Üë(fm x)) Œº
gm : Œ± ‚Üí ‚Ñù‚â•0
gm_le_fm : ‚àÄ (x : Œ±), gm x ‚â§ fm x
gmcont : UpperSemicontinuous gm
gm_integrable : Integrable (fun x ‚Ü¶ ‚Üë(gm x)) Œº
gmint : ‚à´ (x : Œ±), ‚Üë(fm x) ‚àÇŒº - (fun a ‚Ü¶ ‚Üëa) Œ¥ ‚â§ ‚à´ (x : Œ±), ‚Üë(gm x) ‚àÇŒº
g : Œ± ‚Üí EReal := fun x ‚Ü¶ ‚Üë(gp x) - ‚Üë‚Üë(gm x)
ae_g : ‚àÄ·µê (x : Œ±) ‚àÇŒº, (g x).toReal = (‚Üë(gp x)).toReal - (‚Üë‚Üë(gm x)).toReal
x‚úù : Œ±
hx : gp x‚úù < ‚ä§
‚ä¢ ‚Üë(gp x‚úù) + -‚Üë‚Üë(gm x‚úù) ‚â† ‚ä§
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.140748 ‚Üí ?m.140748 ‚Üí Prop
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.140783 ‚Üí ?m.140783 ‚Üí Prop
error:  simp made no progress","theorem exists_lt_lowerSemicontinuous_integral_lt [SigmaFinite Œº] (f : Œ± ‚Üí ‚Ñù) (hf : Integrable f Œº)
    {Œµ : ‚Ñù} (Œµpos : 0 < Œµ) :
    ‚àÉ g : Œ± ‚Üí EReal,
      (‚àÄ x, (f x : EReal) < g x) ‚àß
      LowerSemicontinuous g ‚àß
      Integrable (fun x => EReal.toReal (g x)) Œº ‚àß
      (‚àÄ·µê x ‚àÇŒº, g x < ‚ä§) ‚àß (‚à´ x, EReal.toReal (g x) ‚àÇŒº) < (‚à´ x, f x ‚àÇŒº) + Œµ ",":= by
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ / 2, (half_pos Œµpos).le‚ü©
  have Œ¥pos : 0 < Œ¥ := half_pos Œµpos
  let fp : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (f x)
  have int_fp : Integrable (fun x => (fp x : ‚Ñù)) Œº := hf.real_toNNReal
  rcases exists_lt_lowerSemicontinuous_integral_gt_nnreal fp int_fp Œ¥pos with
    ‚ü®gp, fp_lt_gp, gpcont, gp_lt_top, gp_integrable, gpint‚ü©
  let fm : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (-f x)
  have int_fm : Integrable (fun x => (fm x : ‚Ñù)) Œº := hf.neg.real_toNNReal
  rcases exists_upperSemicontinuous_le_integral_le fm int_fm Œ¥pos with
    ‚ü®gm, gm_le_fm, gmcont, gm_integrable, gmint‚ü©
  let g : Œ± ‚Üí EReal := fun x => (gp x : EReal) - gm x
  have ae_g : ‚àÄ·µê x ‚àÇŒº, (g x).toReal = (gp x : EReal).toReal - (gm x : EReal).toReal := by
    filter_upwards [gp_lt_top] with _ hx
    rw [EReal.toReal_sub] <;> simp [hx.ne]
  refine ‚ü®g, ?lt, ?lsc, ?int, ?aelt, ?intlt‚ü©
  case int =>
    show Integrable (fun x => EReal.toReal (g x)) Œº
    rw [integrable_congr ae_g]
    convert gp_integrable.sub gm_integrable
    simp
  case intlt =>
    show (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) < (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ;
    exact
      calc
        (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) = ‚à´ x : Œ±, EReal.toReal (gp x) - EReal.toReal (gm x) ‚àÇŒº :=
          integral_congr_ae ae_g
        _ = (‚à´ x : Œ±, EReal.toReal (gp x) ‚àÇŒº) - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          simp only [EReal.toReal_coe_ennreal, ENNReal.coe_toReal]
          exact integral_sub gp_integrable gm_integrable
        _ < (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          apply sub_lt_sub_right
          convert gpint
          simp only [EReal.toReal_coe_ennreal]
        _ ‚â§ (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ((‚à´ x : Œ±, ‚Üë(fm x) ‚àÇŒº) - Œ¥) := sub_le_sub_left gmint _
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + 2 * Œ¥ := by
          simp_rw [integral_eq_integral_pos_part_sub_integral_neg_part hf]; ring
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ := by congr 1; field_simp [Œ¥, mul_comm]
  case aelt =>
    show ‚àÄ·µê x : Œ± ‚àÇŒº, g x < ‚ä§
    filter_upwards [gp_lt_top] with ?_ hx
    simp only [g, sub_eq_add_neg, Ne, (EReal.add_lt_top _ _).ne, lt_top_iff_ne_top,
      lt_top_iff_ne_top.1 hx, EReal.coe_ennreal_eq_top_iff, not_false_iff, EReal.neg_eq_top_iff,
      EReal.coe_ennreal_ne_bot]
  case lt =>
    show ‚àÄ x, (f x : EReal) < g x
    intro x
    rw [EReal.coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal (f x)]
    refine EReal.sub_lt_sub_of_lt_of_le ?_ ?_ ?_ ?_
    ¬∑ simp only [EReal.coe_ennreal_lt_coe_ennreal_iff]; exact fp_lt_gp x
    ¬∑ simp only [ENNReal.coe_le_coe, EReal.coe_ennreal_le_coe_ennreal_iff]
      exact gm_le_fm x
    ¬∑ simp only [EReal.coe_ennreal_ne_bot, Ne, not_false_iff]
    ¬∑ simp only [EReal.coe_nnreal_ne_top, Ne, not_false_iff]
  case lsc =>
    show LowerSemicontinuous g
    apply LowerSemicontinuous.add'
    ¬∑ exact continuous_coe_ennreal_ereal.comp_lowerSemicontinuous gpcont fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
    ¬∑ apply continuous_neg.comp_upperSemicontinuous_antitone _ fun x y hxy =>
          EReal.neg_le_neg_iff.2 hxy
      dsimp
      apply continuous_coe_ennreal_ereal.comp_upperSemicontinuous _ fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
      exact ENNReal.continuous_coe.comp_upperSemicontinuous gmcont fun x y hxy =>
          ENNReal.coe_le_coe.2 hxy
    ¬∑ intro x
      exact EReal.continuousAt_add (by simp) (by simp)"
Mathlib/GroupTheory/Perm/DomMulAct.lean,DomMulAct.mem_stabilizer_iff,mem_stabilizer_iff,453c456b049db19d87dc21aed1a69aaf23bd5e15,  simp only [MulAction.mem_stabilizer_iff]; rfl,"error:  unexpected token ';'; expected ':=', 'where' or '|'
error:  unknown identifier 'simp'
error:  unsolved goals
Œ± : Type u_1
Œπ : Type u_2
f : Œ± ‚Üí Œπ
g : (‚Ü•(stabilizer (Perm Œ±)·µà·µê·µÉ f))·µê·µí·µñ
i : Œπ
a : Œ±
‚ä¢ f a = i ‚Üî sorryAx (Œ± ‚Üí Œπ) true a = i","lemma mem_stabilizer_iff {g : (Perm Œ±)·µà·µê·µÉ} :
    g ‚àà stabilizer (Perm Œ±)·µà·µê·µÉ f ‚Üî f ‚àò (mk.symm g :) = f ",":= by
  simp only [MulAction.mem_stabilizer_iff]; rfl"
Mathlib/Algebra/Homology/LocalCohomology.lean,localCohomology.Ideal.exists_pow_le_of_le_radical_of_fG,Ideal.exists_pow_le_of_le_radical_of_fG,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  obtain ‚ü®k, hk‚ü© := J.exists_radical_pow_le_of_fg hJ
  use k
  calc
    I ^ k ‚â§ J.radical ^ k := Ideal.pow_mono hIJ _
    _ ‚â§ J := hk",error:  unknown constant 'Ideal.pow_mono',"theorem Ideal.exists_pow_le_of_le_radical_of_fG (hIJ : I ‚â§ J.radical) (hJ : J.radical.FG) :
    ‚àÉ k : ‚Ñï, I ^ k ‚â§ J ",":= by
  obtain ‚ü®k, hk‚ü© := J.exists_radical_pow_le_of_fg hJ
  use k
  calc
    I ^ k ‚â§ J.radical ^ k := Ideal.pow_right_mono hIJ _
    _ ‚â§ J := hk"
Mathlib/RingTheory/Ideal/Over.lean,Ideal.isMaximal_of_isIntegral_of_isMaximal_comap',isMaximal_of_isIntegral_of_isMaximal_comap',3a31aabe59645ce291dedbcbdd3f949a56d5178f,":=
  letI := f.toSMul
  let _ : Algebra R S := f.toAlgebra
  have : Algebra.IsIntegral R S := ‚ü®hf‚ü©
  isMaximal_of_isIntegral_of_isMaximal_comap (R := R) (S := S) I hI","error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  f
has type
  R ‚Üí+* S","theorem isMaximal_of_isIntegral_of_isMaximal_comap' (f : R ‚Üí+* S) (hf : f.IsIntegral) (I : Ideal S)
    [I.IsPrime] (hI : IsMaximal (I.comap f)) : IsMaximal I ",":=
  let _ : Algebra R S := f.toAlgebra
  have : Algebra.IsIntegral R S := ‚ü®hf‚ü©
  isMaximal_of_isIntegral_of_isMaximal_comap (R := R) (S := S) I hI"
Mathlib/MeasureTheory/Constructions/EventuallyMeasurable.lean,EventuallyMeasurable.congr,EventuallyMeasurable.congr,3a852238e910aa00b7aeeae15ef9801ca7178062,":=
  fun _ hs => EventuallyMeasurableSet.eventuallyMeasurableSet_of_eventuallyEq (hf hs)
    (hgf.preimage _)","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  EventuallyMeasurableSet
has type
  MeasurableSpace ?m.1859 ‚Üí (l : Filter ?m.1859) ‚Üí [inst : CountableInterFilter l] ‚Üí Set ?m.1859 ‚Üí Prop","theorem EventuallyMeasurable.congr
    (hf : EventuallyMeasurable m l f) (hgf : g =·∂†[l] f) : EventuallyMeasurable m l g ",":=
  fun _ hs => EventuallyMeasurableSet.congr (hf hs)
    (hgf.preimage _)"
Mathlib/Topology/Separation.lean,isPreirreducible_iff_subsingleton,isPreirreducible_iff_subsingleton,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine' ‚ü®fun h x hx y hy => _, Set.Subsingleton.isPreirreducible‚ü©
  by_contra e
  obtain ‚ü®U, V, hU, hV, hxU, hyV, h'‚ü© := t2_separation e
  exact ((h U V hU hV ‚ü®x, hx, hxU‚ü© ‚ü®y, hy, hyV‚ü©).mono <| inter_subset_right _ _).not_disjoint h'","error:  function expected at
  inter_subset_right ?m.167339
term has type
  ?m.167338 ‚àà ?m.167337","theorem isPreirreducible_iff_subsingleton [T2Space X] {S : Set X} :
    IsPreirreducible S ‚Üî S.Subsingleton ",":= by
  refine ‚ü®fun h x hx y hy => ?_, Set.Subsingleton.isPreirreducible‚ü©
  by_contra e
  obtain ‚ü®U, V, hU, hV, hxU, hyV, h'‚ü© := t2_separation e
  exact ((h U V hU hV ‚ü®x, hx, hxU‚ü© ‚ü®y, hy, hyV‚ü©).mono inter_subset_right).not_disjoint h'"
Mathlib/Algebra/Module/PID.lean,Module.torsion_by_prime_power_decomposition,torsion_by_prime_power_decomposition,dd9d2939f7f4933231c9afead607499e5a048f4f,":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ simp only [Nat.zero_eq] at *
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
    clear IH
    ¬∑ have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine' ‚ü®x, h0, _‚ü©; rw [h1]
        simp only [LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((@lequivProdOfRightSplitExact _ _ _ _ _ _ _ _ _ _ _ _
          ((f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          ((DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton.{u, u} (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one, (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'","error:  simp made no progress
error:  simp made no progress
error:  tactic 'rewrite' failed, motive is not type correct
case h.succ.intro.refine_3.intro.intro.refine_2.refine_2.H.h.h
R : Type u
inst‚úù‚Å∂ : CommRing R
inst‚úù‚Åµ : IsDomain R
inst‚úù‚Å¥ : IsPrincipalIdealRing R
M : Type v
inst‚úù¬≥ : AddCommGroup M
inst‚úù¬≤ : Module R M
p : R
hp : Irreducible p
hM : IsTorsion' M ‚Ü•(Submonoid.powers p)
dec : (x : M) ‚Üí Decidable (x = 0)
d : ‚Ñï
N : Type (max u v)
inst‚úù¬π : AddCommGroup N
inst‚úù : Module R N
hN : IsTorsion' N ‚Ü•(Submonoid.powers p)
s : Fin (d + 1) ‚Üí N
hs : Submodule.span R (Set.range s) = ‚ä§
this‚úù : (x : N) ‚Üí Decidable (x = 0)
j : Fin d.succ
hj : IsTorsionBy R N (p ^ pOrder hN (s j))
s' : Fin d ‚Üí N ‚ß∏ Submodule.span R {s j} := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
k : Fin d ‚Üí ‚Ñï
f : (N ‚ß∏ Submodule.span R {s j}) ‚âÉ‚Çó[R] ‚®Å (i : Fin d), R ‚ß∏ Submodule.span R {p ^ k i}
this :
  ‚àÄ (i : Fin d),
    ‚àÉ x,
      p ^ k i ‚Ä¢ x = 0 ‚àß
        f (Submodule.Quotient.mk x) = (DirectSum.lof R (Fin d) (fun i ‚Ü¶ R ‚ß∏ Submodule.span R {p ^ k i}) i) 1
i : Fin d
‚ä¢ f (Submodule.Quotient.mk ‚ãØ.choose) =
    (DirectSum.lof R (Fin d) (fun i ‚Ü¶ R ‚ß∏ Submodule.span R {p ^ k i}) i)
      ((Ideal.Quotient.mk (Submodule.span R {p ^ k i})) 1)
error:  failed to synthesize
  One (‚®Å (i : Fin d), R ‚ß∏ Submodule.span R {p ^ k i})
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  OneHomClass (R ‚ß∏ Submodule.span R {p ^ k i} ‚Üí‚Çó[R] ‚®Å (i : Fin d), R ‚ß∏ Submodule.span R {p ^ k i})
    (R ‚ß∏ Submodule.span R {p ^ k i}) (‚®Å (i : Fin d), R ‚ß∏ Submodule.span R {p ^ k i})
use `set_option diagnostics true` to get diagnostic information
error:  simp made no progress","theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ‚àÉ (d : ‚Ñï) (k : Fin d ‚Üí ‚Ñï), Nonempty <| N ‚âÉ‚Çó[R] ‚®Å i : Fin d, R ‚ß∏ R ‚àô p ^ (k i : ‚Ñï) ",":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    ¬∑ obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
      clear IH
      have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ‚ü®x, h0, ?_‚ü©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'"
Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean,dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt,dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt,9db546a81b334ba30d74fed40766bcdeffb50e5f,":= by
  letI := B.finiteDimensional
  let P := minpoly R B.gen
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  have finrank_K_L : FiniteDimensional.finrank K L = B.dim := B.finrank
  have deg_K_P : (minpoly K B.gen).natDegree = B.dim := B.natDegree_minpoly
  have deg_R_P : P.natDegree = B.dim := by
    rw [‚Üê deg_K_P, minpoly.isIntegrallyClosed_eq_field_fractions' K hBint,
      (minpoly.monic hBint).natDegree_map (algebraMap R K)]
  choose! f hf using
    hei.isWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
      (minpoly.monic hBint)
  simp only [(minpoly.monic hBint).natDegree_map, deg_R_P] at hf
  suffices
      p ^ n.succ ‚à£ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n) by
    have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
      hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
    refine @Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd R _ _ _ _ n hp (?_ : _ ‚à£ _) hndiv
    convert (IsUnit.dvd_mul_right ‚ü®(-1) ^ (n.succ * n), rfl‚ü©).mpr this using 1
    push_cast
    ring_nf
    rw [mul_comm _ 2, pow_mul, neg_one_sq, one_pow, mul_one]
  have aux : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0, B.dim ‚â§ i + n := by
    intro i hi
    simp only [mem_range, mem_erase] at hi
    rw [hn]
    exact le_add_pred_of_pos _ hi.1
  have hintsum :
    IsIntegral R
      (z * B.gen ^ n - ‚àë x : ‚Ñï in (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ f (x + n)) := by
    refine (hzint.mul (hBint.pow _)).sub (.sum _ fun i hi => .smul _ ?_)
    exact adjoin_le_integralClosure hBint (hf _ (aux i hi)).1
  obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
  use r
  apply IsFractionRing.injective R K
  simp only [_root_.map_mul, _root_.map_pow, _root_.map_neg, _root_.map_one]
  calc
    _ = norm K (Q.coeff 0 ‚Ä¢ B.gen ^ n) := ?_
    _ = norm K (p ‚Ä¢ (z * B.gen ^ n) -
          ‚àë x : ‚Ñï in (range (Q.natDegree + 1)).erase 0, p ‚Ä¢ Q.coeff x ‚Ä¢ f (x + n)) :=
        (congr_arg (norm K) (eq_sub_of_add_eq ?_))
    _ = _ := ?_
  ¬∑ simp only [Algebra.smul_def, algebraMap_apply R K L, Algebra.norm_algebraMap, _root_.map_mul,
      _root_.map_pow, finrank_K_L, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map, ‚Üê hn]
    ring
  swap
  ¬∑ simp_rw [‚Üê smul_sum', ‚Üê smul_sub, Algebra.smul_def p, algebraMap_apply R K L, _root_.map_mul,
      Algebra.norm_algebraMap, finrank_K_L, hr, ‚Üê hn]
  calc
    _ = (Q.coeff 0 ‚Ä¢ ‚Üë1 + ‚àë x : ‚Ñï in (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) *
          B.gen ^ n := ?_
    _ = (Q.coeff 0 ‚Ä¢ B.gen ^ 0 +
        ‚àë x : ‚Ñï in (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) * B.gen ^ n :=
      by rw [_root_.pow_zero]
    _ = aeval B.gen Q * B.gen ^ n := ?_
    _ = _ := by rw [hQ, Algebra.smul_mul_assoc]
  ¬∑ have : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0,
        Q.coeff i ‚Ä¢ (B.gen ^ i * B.gen ^ n) = p ‚Ä¢ Q.coeff i ‚Ä¢ f (i + n) := by
      intro i hi
      rw [‚Üê pow_add, ‚Üê (hf _ (aux i hi)).2, ‚Üê Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]
    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]
  ¬∑ rw [aeval_eq_sum_range,
      Finset.add_sum_erase (range (Q.natDegree + 1)) fun i => Q.coeff i ‚Ä¢ B.gen ^ i]
    simp","warning:  `PowerBasis.finiteDimensional` has been deprecated, use `PowerBasis.finite` instead
error:  unknown identifier 'smul_sum''
error:  simp made no progress","theorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} {Q : R[X]} (hQ : aeval B.gen Q = p ‚Ä¢ z)
    (hzint : IsIntegral R z) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) : p ‚à£ Q.coeff 0 ",":= by
  letI := B.finite
  let P := minpoly R B.gen
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  have finrank_K_L : FiniteDimensional.finrank K L = B.dim := B.finrank
  have deg_K_P : (minpoly K B.gen).natDegree = B.dim := B.natDegree_minpoly
  have deg_R_P : P.natDegree = B.dim := by
    rw [‚Üê deg_K_P, minpoly.isIntegrallyClosed_eq_field_fractions' K hBint,
      (minpoly.monic hBint).natDegree_map (algebraMap R K)]
  choose! f hf using
    hei.isWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
      (minpoly.monic hBint)
  simp only [(minpoly.monic hBint).natDegree_map, deg_R_P] at hf
  suffices
      p ^ n.succ ‚à£ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n) by
    have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
      hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
    refine @Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd R _ _ _ _ n hp (?_ : _ ‚à£ _) hndiv
    convert (IsUnit.dvd_mul_right ‚ü®(-1) ^ (n.succ * n), rfl‚ü©).mpr this using 1
    push_cast
    ring_nf
    rw [mul_comm _ 2, pow_mul, neg_one_sq, one_pow, mul_one]
  have aux : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0, B.dim ‚â§ i + n := by
    intro i hi
    simp only [mem_range, mem_erase] at hi
    rw [hn]
    exact le_add_pred_of_pos _ hi.1
  have hintsum :
    IsIntegral R
      (z * B.gen ^ n - ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ f (x + n)) := by
    refine (hzint.mul (hBint.pow _)).sub (.sum _ fun i hi => .smul _ ?_)
    exact adjoin_le_integralClosure hBint (hf _ (aux i hi)).1
  obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
  use r
  apply IsFractionRing.injective R K
  simp only [_root_.map_mul, _root_.map_pow, _root_.map_neg, _root_.map_one]
  calc
    _ = norm K (Q.coeff 0 ‚Ä¢ B.gen ^ n) := ?_
    _ = norm K (p ‚Ä¢ (z * B.gen ^ n) -
          ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, p ‚Ä¢ Q.coeff x ‚Ä¢ f (x + n)) :=
        (congr_arg (norm K) (eq_sub_of_add_eq ?_))
    _ = _ := ?_
  ¬∑ simp only [Algebra.smul_def, algebraMap_apply R K L, Algebra.norm_algebraMap, _root_.map_mul,
      _root_.map_pow, finrank_K_L, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map, ‚Üê hn]
    ring
  swap
  ¬∑ simp_rw [‚Üê smul_sum, ‚Üê smul_sub, Algebra.smul_def p, algebraMap_apply R K L, _root_.map_mul,
      Algebra.norm_algebraMap, finrank_K_L, hr, ‚Üê hn]
  calc
    _ = (Q.coeff 0 ‚Ä¢ ‚Üë1 + ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) *
          B.gen ^ n := ?_
    _ = (Q.coeff 0 ‚Ä¢ B.gen ^ 0 +
        ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) * B.gen ^ n := by
      rw [_root_.pow_zero]
    _ = aeval B.gen Q * B.gen ^ n := ?_
    _ = _ := by rw [hQ, Algebra.smul_mul_assoc]
  ¬∑ have : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0,
        Q.coeff i ‚Ä¢ (B.gen ^ i * B.gen ^ n) = p ‚Ä¢ Q.coeff i ‚Ä¢ f (i + n) := by
      intro i hi
      rw [‚Üê pow_add, ‚Üê (hf _ (aux i hi)).2, ‚Üê Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]
    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]
  ¬∑ rw [aeval_eq_sum_range,
      Finset.add_sum_erase (range (Q.natDegree + 1)) fun i => Q.coeff i ‚Ä¢ B.gen ^ i]
    simp"
Mathlib/Topology/Separation.lean,isPreirreducible_iff_subsingleton,isPreirreducible_iff_subsingleton,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  refine ‚ü®fun h x hx y hy => ?_, Set.Subsingleton.isPreirreducible‚ü©
  by_contra e
  obtain ‚ü®U, V, hU, hV, hxU, hyV, h'‚ü© := t2_separation e
  exact ((h U V hU hV ‚ü®x, hx, hxU‚ü© ‚ü®y, hy, hyV‚ü©).mono <| inter_subset_right _ _).not_disjoint h'","error:  function expected at
  inter_subset_right ?m.167339
term has type
  ?m.167338 ‚àà ?m.167337","theorem isPreirreducible_iff_subsingleton [T2Space X] {S : Set X} :
    IsPreirreducible S ‚Üî S.Subsingleton ",":= by
  refine ‚ü®fun h x hx y hy => ?_, Set.Subsingleton.isPreirreducible‚ü©
  by_contra e
  obtain ‚ü®U, V, hU, hV, hxU, hyV, h'‚ü© := t2_separation e
  exact ((h U V hU hV ‚ü®x, hx, hxU‚ü© ‚ü®y, hy, hyV‚ü©).mono inter_subset_right).not_disjoint h'"
Mathlib/Algebra/Homology/ShortComplex/ConcreteCategory.lean,CategoryTheory.Preadditive.epi_iff_surjective,Preadditive.epi_iff_surjective,bad931b7fc9f31f5ff5b8f408dd19bbe20a9f0e1,":= by
  rw [‚Üê AddCommGroupCat.epi_iff_surjective]
  constructor
  ¬∑ intro
    infer_instance
  ¬∑ apply Functor.epi_of_epi_map","error:  unknown identifier 'AddCommGroupCat.epi_iff_surjective'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.9216
C : Type u
inst‚úù‚Å∂ : Category.{v, u} C
inst‚úù‚Åµ : ConcreteCategory C
inst‚úù‚Å¥ : HasForget‚ÇÇ C Ab
inst‚úù¬≥ : Preadditive C
inst‚úù¬≤ : (forget‚ÇÇ C Ab).Additive
inst‚úù¬π : (forget‚ÇÇ C Ab).PreservesHomology
inst‚úù : HasZeroObject C
S : ShortComplex C
X Y : C
f : X ‚ü∂ Y
‚ä¢ Epi f ‚Üî Function.Surjective ‚áë((forget‚ÇÇ C Ab).map f)","lemma Preadditive.epi_iff_surjective {X Y : C} (f : X ‚ü∂ Y) :
    Epi f ‚Üî Function.Surjective ((forget‚ÇÇ C Ab).map f) ",":= by
  rw [‚Üê AddCommGrp.epi_iff_surjective]
  constructor
  ¬∑ intro
    infer_instance
  ¬∑ apply Functor.epi_of_epi_map"
Mathlib/Data/Set/Card.lean,Set.encard_singleton_inter,encard_singleton_inter,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [‚Üê encard_singleton x]; exact encard_le_card (inter_subset_left _ _)","error:  function expected at
  inter_subset_left ?m.29185
term has type
  ?m.29184 ‚àà ?m.29182",theorem encard_singleton_inter (s : Set Œ±) (x : Œ±) : ({x} ‚à© s).encard ‚â§ 1 ,":= by
  rw [‚Üê encard_singleton x]; exact encard_le_card inter_subset_left"
Mathlib/GroupTheory/Finiteness.lean,Submonoid.FG.map_injective,Submonoid.FG.map_injective,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  obtain ‚ü®s, hs‚ü© := h
  use s.preimage e (he.injOn _)
  apply Submonoid.map_injective_of_injective he
  rw [‚Üê hs, MonoidHom.map_mclosure e, Finset.coe_preimage]
  congr
  rw [Set.image_preimage_eq_iff, ‚Üê MonoidHom.coe_mrange e, ‚Üê Submonoid.closure_le, hs,
      MonoidHom.mrange_eq_map e]
  exact Submonoid.monotone_map le_top","error:  application type mismatch
  s.preimage ‚áëe ‚ãØ
argument
  Function.Injective.injOn he ?m.14971
has type
  ‚àÄ ‚¶Éx‚ÇÇ : M‚¶Ñ, x‚ÇÇ ‚àà ?m.14969 ‚Üí e ?m.14970 = e x‚ÇÇ ‚Üí ?m.14970 = x‚ÇÇ : Prop
but is expected to have type
  Set.InjOn (‚áëe) (‚áëe ‚Åª¬π' ‚Üës) : Prop","theorem Submonoid.FG.map_injective {M' : Type*} [Monoid M'] {P : Submonoid M} (e : M ‚Üí* M')
    (he : Function.Injective e) (h : (P.map e).FG) : P.FG ",":= by
  obtain ‚ü®s, hs‚ü© := h
  use s.preimage e he.injOn
  apply Submonoid.map_injective_of_injective he
  rw [‚Üê hs, MonoidHom.map_mclosure e, Finset.coe_preimage]
  congr
  rw [Set.image_preimage_eq_iff, ‚Üê MonoidHom.coe_mrange e, ‚Üê Submonoid.closure_le, hs,
      MonoidHom.mrange_eq_map e]
  exact Submonoid.monotone_map le_top"
Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean,MeasureTheory.Measure.tendsto_addHaar_inter_smul_one_of_density_one_aux,tendsto_addHaar_inter_smul_one_of_density_one_aux,1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493,":= by
  have I : ‚àÄ u v, Œº u ‚â† 0 ‚Üí Œº u ‚â† ‚àû ‚Üí MeasurableSet v ‚Üí
    Œº u / Œº u - Œº (v·∂ú ‚à© u) / Œº u = Œº (v ‚à© u) / Œº u := by
    intro u v uzero utop vmeas
    simp_rw [div_eq_mul_inv]
    rw [‚Üê ENNReal.sub_mul]; swap
    ¬∑ simp only [uzero, ENNReal.inv_eq_top, imp_true_iff, Ne, not_false_iff]
    congr 1
    apply
      ENNReal.sub_eq_of_add_eq (ne_top_of_le_ne_top utop (measure_mono (inter_subset_right _ _)))
    rw [inter_comm _ u, inter_comm _ u]
    exact measure_inter_add_diff u vmeas
  have L : Tendsto (fun r => Œº (s·∂ú ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 0) := by
    have A : Tendsto (fun r => Œº (closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1) := by
      apply tendsto_const_nhds.congr' _
      filter_upwards [self_mem_nhdsWithin]
      intro r hr
      rw [div_eq_mul_inv, ENNReal.mul_inv_cancel]
      ¬∑ exact (measure_closedBall_pos Œº _ hr).ne'
      ¬∑ exact measure_closedBall_lt_top.ne
    have B := ENNReal.Tendsto.sub A h (Or.inl ENNReal.one_ne_top)
    simp only [tsub_self] at B
    apply B.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    convert I (closedBall x r) s·∂ú (measure_closedBall_pos Œº _ rpos).ne'
      measure_closedBall_lt_top.ne hs.compl
    rw [compl_compl]
  have L' : Tendsto (fun r : ‚Ñù => Œº (s·∂ú ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 0) :=
    tendsto_addHaar_inter_smul_zero_of_density_zero Œº s·∂ú x L t ht h''t
  have L'' : Tendsto (fun r : ‚Ñù => Œº ({x} + r ‚Ä¢ t) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) := by
    apply tendsto_const_nhds.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    rw [addHaar_singleton_add_smul_div_singleton_add_smul Œº rpos.ne', ENNReal.div_self h't h''t]
  have := ENNReal.Tendsto.sub L'' L' (Or.inl ENNReal.one_ne_top)
  simp only [tsub_zero] at this
  apply this.congr' _
  filter_upwards [self_mem_nhdsWithin]
  rintro r (rpos : 0 < r)
  refine I ({x} + r ‚Ä¢ t) s ?_ ?_ hs
  ¬∑ simp only [h't, abs_of_nonneg rpos.le, pow_pos rpos, addHaar_smul, image_add_left,
      ENNReal.ofReal_eq_zero, not_le, or_false_iff, Ne, measure_preimage_add, abs_pow,
      singleton_add, mul_eq_zero]
  ¬∑ simp [h''t, ENNReal.ofReal_ne_top, addHaar_smul, image_add_left, ENNReal.mul_eq_top,
      Ne, not_false_iff, measure_preimage_add, singleton_add, and_false_iff, false_and_iff,
      or_self_iff]","error:  function expected at
  inter_subset_right ?m.538807
term has type
  ?m.538806 ‚àà ?m.538805","theorem tendsto_addHaar_inter_smul_one_of_density_one_aux (s : Set E) (hs : MeasurableSet s)
    (x : E) (h : Tendsto (fun r => Œº (s ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1))
    (t : Set E) (ht : MeasurableSet t) (h't : Œº t ‚â† 0) (h''t : Œº t ‚â† ‚àû) :
    Tendsto (fun r : ‚Ñù => Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) ",":= by
  have I : ‚àÄ u v, Œº u ‚â† 0 ‚Üí Œº u ‚â† ‚àû ‚Üí MeasurableSet v ‚Üí
    Œº u / Œº u - Œº (v·∂ú ‚à© u) / Œº u = Œº (v ‚à© u) / Œº u := by
    intro u v uzero utop vmeas
    simp_rw [div_eq_mul_inv]
    rw [‚Üê ENNReal.sub_mul]; swap
    ¬∑ simp only [uzero, ENNReal.inv_eq_top, imp_true_iff, Ne, not_false_iff]
    congr 1
    apply
      ENNReal.sub_eq_of_add_eq (ne_top_of_le_ne_top utop (measure_mono inter_subset_right))
    rw [inter_comm _ u, inter_comm _ u]
    exact measure_inter_add_diff u vmeas
  have L : Tendsto (fun r => Œº (s·∂ú ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 0) := by
    have A : Tendsto (fun r => Œº (closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1) := by
      apply tendsto_const_nhds.congr' _
      filter_upwards [self_mem_nhdsWithin]
      intro r hr
      rw [div_eq_mul_inv, ENNReal.mul_inv_cancel]
      ¬∑ exact (measure_closedBall_pos Œº _ hr).ne'
      ¬∑ exact measure_closedBall_lt_top.ne
    have B := ENNReal.Tendsto.sub A h (Or.inl ENNReal.one_ne_top)
    simp only [tsub_self] at B
    apply B.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    convert I (closedBall x r) s·∂ú (measure_closedBall_pos Œº _ rpos).ne'
      measure_closedBall_lt_top.ne hs.compl
    rw [compl_compl]
  have L' : Tendsto (fun r : ‚Ñù => Œº (s·∂ú ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 0) :=
    tendsto_addHaar_inter_smul_zero_of_density_zero Œº s·∂ú x L t ht h''t
  have L'' : Tendsto (fun r : ‚Ñù => Œº ({x} + r ‚Ä¢ t) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) := by
    apply tendsto_const_nhds.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    rw [addHaar_singleton_add_smul_div_singleton_add_smul Œº rpos.ne', ENNReal.div_self h't h''t]
  have := ENNReal.Tendsto.sub L'' L' (Or.inl ENNReal.one_ne_top)
  simp only [tsub_zero] at this
  apply this.congr' _
  filter_upwards [self_mem_nhdsWithin]
  rintro r (rpos : 0 < r)
  refine I ({x} + r ‚Ä¢ t) s ?_ ?_ hs
  ¬∑ simp only [h't, abs_of_nonneg rpos.le, pow_pos rpos, addHaar_smul, image_add_left,
      ENNReal.ofReal_eq_zero, not_le, or_false_iff, Ne, measure_preimage_add, abs_pow,
      singleton_add, mul_eq_zero]
  ¬∑ simp [h''t, ENNReal.ofReal_ne_top, addHaar_smul, image_add_left, ENNReal.mul_eq_top,
      Ne, not_false_iff, measure_preimage_add, singleton_add, and_false_iff, false_and_iff,
      or_self_iff]"
Mathlib/GroupTheory/OrderOfElement.lean,IsOfFinOrder.mem_powers_iff_mem_zpowers,IsOfFinOrder.mem_powers_iff_mem_zpowers,885169a38c6af917fce3dc18fe1ab2666f6f15e5,":=
  ‚ü®fun ‚ü®n, hn‚ü© ‚Ü¶ ‚ü®n, by simp_all‚ü©, fun ‚ü®i, hi‚ü© ‚Ü¶ ‚ü®(i % orderOf x).natAbs, by
    dsimp only
    rwa [‚Üê zpow_ofNat, Int.natAbs_of_nonneg $ Int.emod_nonneg _ $ Int.coe_nat_ne_zero_iff_pos.2 $
      hx.orderOf_pos, zpow_mod_orderOf]‚ü©‚ü©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a ^ OfNat.ofNat ?n
G : Type u_1
H : Type u_2
A : Type u_3
Œ± : Type u_4
Œ≤ : Type u_5
inst‚úù : Group G
x y : G
i‚úù : ‚Ñ§
hx : IsOfFinOrder x
x‚úù : y ‚àà zpowers x
i : ‚Ñ§
hi : (fun x_1 ‚Ü¶ x ^ x_1) i = y
‚ä¢ x ^ (i % ‚Üë(orderOf x)).natAbs = y","lemma IsOfFinOrder.mem_powers_iff_mem_zpowers (hx : IsOfFinOrder x) :
    y ‚àà powers x ‚Üî y ‚àà zpowers x ",":=
  ‚ü®fun ‚ü®n, hn‚ü© ‚Ü¶ ‚ü®n, by simp_all‚ü©, fun ‚ü®i, hi‚ü© ‚Ü¶ ‚ü®(i % orderOf x).natAbs, by
    dsimp only
    rwa [‚Üê zpow_natCast, Int.natAbs_of_nonneg <| Int.emod_nonneg _ <|
      Int.natCast_ne_zero_iff_pos.2 <| hx.orderOf_pos, zpow_mod_orderOf]‚ü©‚ü©"
Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean,AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one,AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one,3b4737b3b07aa77aaa08420241e83ad9c46eda8a,":= by
  rw [‚Üê Finset.card_univ] at hc
  rw [‚Üê Set.image_univ, ‚Üê Finset.coe_univ, ‚Üê Finset.coe_image] at hle‚ä¢
  exact hi.affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one hle hc","error:  failed to synthesize
  DecidableEq P
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  DecidableEq P
use `set_option diagnostics true` to get diagnostic information
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  invalid field 'affineSpan_eq_of_le_of_card_eq_finrank_add_one', the environment does not contain 'AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one'
  hi
has type
  AffineIndependent k p
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hi
has type
  ‚àÄ (s : Finset Œπ) (w : Œπ ‚Üí k), ‚àë i ‚àà s, w i = 0 ‚Üí (s.weightedVSub p) w = 0 ‚Üí ‚àÄ i ‚àà s, w i = 0","theorem AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one [Fintype Œπ] {p : Œπ ‚Üí P}
    (hi : AffineIndependent k p) {sp : AffineSubspace k P} [FiniteDimensional k sp.direction]
    (hle : affineSpan k (Set.range p) ‚â§ sp) (hc : Fintype.card Œπ = finrank k sp.direction + 1) :
    affineSpan k (Set.range p) = sp ",":= by
  classical
  rw [‚Üê Finset.card_univ] at hc
  rw [‚Üê Set.image_univ, ‚Üê Finset.coe_univ, ‚Üê Finset.coe_image] at hle ‚ä¢
  exact hi.affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one hle hc"
Mathlib/Combinatorics/Hall/Finite.lean,HallMarriageTheorem.hall_hard_inductive_step_B,hall_hard_inductive_step_B,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  haveI := Classical.decEq Œπ
  rw [Nat.add_one] at hn
  have card_Œπ'_le : Fintype.card s ‚â§ n := by
    apply Nat.le_of_lt_succ
    calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card Œπ := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
  let t' : s ‚Üí Finset Œ± := fun x' => t x'
  rcases ih t' card_Œπ'_le (hall_cond_of_restrict ht) with ‚ü®f', hf', hsf'‚ü©
  set Œπ'' := (s : Set Œπ)·∂ú
  let t'' : Œπ'' ‚Üí Finset Œ± := fun a'' => t a'' \ s.biUnion t
  have card_Œπ''_le : Fintype.card Œπ'' ‚â§ n := by
    simp_rw [Œπ'', ‚Üê Nat.lt_succ_iff, ‚Üê hn, ‚Üê Finset.coe_compl, coe_sort_coe]
    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]
  rcases ih t'' card_Œπ''_le (hall_cond_of_compl hus ht) with ‚ü®f'', hf'', hsf''‚ü©
  have f'_mem_biUnion : ‚àÄ (x') (hx' : x' ‚àà s), f' ‚ü®x', hx'‚ü© ‚àà s.biUnion t := by
    intro x' hx'
    rw [mem_biUnion]
    exact ‚ü®x', hx', hsf' _‚ü©
  have f''_not_mem_biUnion : ‚àÄ (x'') (hx'' : ¬¨x'' ‚àà s), ¬¨f'' ‚ü®x'', hx''‚ü© ‚àà s.biUnion t := by
    intro x'' hx''
    have h := hsf'' ‚ü®x'', hx''‚ü©
    rw [mem_sdiff] at h
    exact h.2
  have im_disj :
      ‚àÄ (x' x'' : Œπ) (hx' : x' ‚àà s) (hx'' : ¬¨x'' ‚àà s), f' ‚ü®x', hx'‚ü© ‚â† f'' ‚ü®x'', hx''‚ü© := by
    intro x x' hx' hx'' h
    apply f''_not_mem_biUnion x' hx''
    rw [‚Üê h]
    apply f'_mem_biUnion x
  refine' ‚ü®fun x => if h : x ‚àà s then f' ‚ü®x, h‚ü© else f'' ‚ü®x, h‚ü©, _, _‚ü©
  ¬∑ refine' hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)
  ¬∑ intro x
    simp only [of_eq_true]
    split_ifs with h
    ¬∑ exact hsf' ‚ü®x, h‚ü©
    ¬∑ exact sdiff_subset _ _ (hsf'' ‚ü®x, h‚ü©)","error:  function expected at
  sdiff_subset ?m.41056
term has type
  ?m.41055 ‚àà ?m.41053","theorem hall_hard_inductive_step_B {n : ‚Ñï} (hn : Fintype.card Œπ = n + 1)
    (ht : ‚àÄ s : Finset Œπ, s.card ‚â§ (s.biUnion t).card)
    (ih :
      ‚àÄ {Œπ' : Type u} [Fintype Œπ'] (t' : Œπ' ‚Üí Finset Œ±),
        Fintype.card Œπ' ‚â§ n ‚Üí
          (‚àÄ s' : Finset Œπ', s'.card ‚â§ (s'.biUnion t').card) ‚Üí
            ‚àÉ f : Œπ' ‚Üí Œ±, Function.Injective f ‚àß ‚àÄ x, f x ‚àà t' x)
    (s : Finset Œπ) (hs : s.Nonempty) (hns : s ‚â† univ) (hus : s.card = (s.biUnion t).card) :
    ‚àÉ f : Œπ ‚Üí Œ±, Function.Injective f ‚àß ‚àÄ x, f x ‚àà t x ",":= by
  haveI := Classical.decEq Œπ
  rw [Nat.add_one] at hn
  have card_Œπ'_le : Fintype.card s ‚â§ n := by
    apply Nat.le_of_lt_succ
    calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card Œπ := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
  let t' : s ‚Üí Finset Œ± := fun x' => t x'
  rcases ih t' card_Œπ'_le (hall_cond_of_restrict ht) with ‚ü®f', hf', hsf'‚ü©
  set Œπ'' := (s : Set Œπ)·∂ú
  let t'' : Œπ'' ‚Üí Finset Œ± := fun a'' => t a'' \ s.biUnion t
  have card_Œπ''_le : Fintype.card Œπ'' ‚â§ n := by
    simp_rw [Œπ'', ‚Üê Nat.lt_succ_iff, ‚Üê hn, ‚Üê Finset.coe_compl, coe_sort_coe]
    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]
  rcases ih t'' card_Œπ''_le (hall_cond_of_compl hus ht) with ‚ü®f'', hf'', hsf''‚ü©
  have f'_mem_biUnion : ‚àÄ (x') (hx' : x' ‚àà s), f' ‚ü®x', hx'‚ü© ‚àà s.biUnion t := by
    intro x' hx'
    rw [mem_biUnion]
    exact ‚ü®x', hx', hsf' _‚ü©
  have f''_not_mem_biUnion : ‚àÄ (x'') (hx'' : ¬¨x'' ‚àà s), ¬¨f'' ‚ü®x'', hx''‚ü© ‚àà s.biUnion t := by
    intro x'' hx''
    have h := hsf'' ‚ü®x'', hx''‚ü©
    rw [mem_sdiff] at h
    exact h.2
  have im_disj :
      ‚àÄ (x' x'' : Œπ) (hx' : x' ‚àà s) (hx'' : ¬¨x'' ‚àà s), f' ‚ü®x', hx'‚ü© ‚â† f'' ‚ü®x'', hx''‚ü© := by
    intro x x' hx' hx'' h
    apply f''_not_mem_biUnion x' hx''
    rw [‚Üê h]
    apply f'_mem_biUnion x
  refine ‚ü®fun x => if h : x ‚àà s then f' ‚ü®x, h‚ü© else f'' ‚ü®x, h‚ü©, ?_, ?_‚ü©
  ¬∑ refine hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)
  ¬∑ intro x
    simp only [of_eq_true]
    split_ifs with h
    ¬∑ exact hsf' ‚ü®x, h‚ü©
    ¬∑ exact sdiff_subset (hsf'' ‚ü®x, h‚ü©)"
Mathlib/Analysis/Fourier/FourierTransform.lean,Real.fourierIntegral_eq',fourierIntegral_eq',61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  simp_rw [fourierIntegral_eq, Real.fourierChar_apply, mul_neg, neg_mul]","warning:  Real.fourierChar does not have a doc string
warning:  @Real.fourierIntegral does not have a doc string
warning:  @Real.fourierIntegralInv does not have a doc string
error:  simp made no progress","lemma fourierIntegral_eq' (f : V ‚Üí E) (w : V) :
    ùìï f w = ‚à´ v, Complex.exp ((‚Üë(-2 * œÄ * ‚ü™v, w‚ü´) * Complex.I)) ‚Ä¢ f v ",":= by
  simp_rw [fourierIntegral_eq, Submonoid.smul_def, Real.fourierChar_apply, mul_neg, neg_mul]"
Mathlib/Algebra/Order/Group/MinMax.lean,max_inv_one,max_inv_one,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have := congr($(max_one_div_max_inv_one_eq_self a)‚Åª¬π)
  rwa [inv_div, div_eq_iff_eq_mul] at this","error:  don't know how to synthesize implicit argument 'a‚ÇÇ'
  @congr ?m.2890 ?m.2891 ?m.2892 ?m.2893 ?m.2894 ?m.2895
context:
Œ± : Type u_1
inst‚úù¬≤ : Group Œ±
inst‚úù¬π : LinearOrder Œ±
inst‚úù : CovariantClass Œ± Œ± (fun x x_1 ‚Ü¶ x * x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
a : Œ±
‚ä¢ ?m.2890
error:  don't know how to synthesize implicit argument 'a‚ÇÅ'
  @congr ?m.2890 ?m.2891 ?m.2892 ?m.2893 ?m.2894 ?m.2895
context:
Œ± : Type u_1
inst‚úù¬≤ : Group Œ±
inst‚úù¬π : LinearOrder Œ±
inst‚úù : CovariantClass Œ± Œ± (fun x x_1 ‚Ü¶ x * x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
a : Œ±
‚ä¢ ?m.2890
error:  don't know how to synthesize implicit argument 'f‚ÇÇ'
  @congr ?m.2890 ?m.2891 ?m.2892 ?m.2893 ?m.2894 ?m.2895
context:
Œ± : Type u_1
inst‚úù¬≤ : Group Œ±
inst‚úù¬π : LinearOrder Œ±
inst‚úù : CovariantClass Œ± Œ± (fun x x_1 ‚Ü¶ x * x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
a : Œ±
‚ä¢ ?m.2890 ‚Üí ?m.2891
error:  don't know how to synthesize implicit argument 'f‚ÇÅ'
  @congr ?m.2890 ?m.2891 ?m.2892 ?m.2893 ?m.2894 ?m.2895
context:
Œ± : Type u_1
inst‚úù¬≤ : Group Œ±
inst‚úù¬π : LinearOrder Œ±
inst‚úù : CovariantClass Œ± Œ± (fun x x_1 ‚Ü¶ x * x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
a : Œ±
‚ä¢ ?m.2890 ‚Üí ?m.2891
error:  don't know how to synthesize implicit argument 'Œ≤'
  @congr ?m.2890 ?m.2891 ?m.2892 ?m.2893 ?m.2894 ?m.2895
context:
Œ± : Type u_1
inst‚úù¬≤ : Group Œ±
inst‚úù¬π : LinearOrder Œ±
inst‚úù : CovariantClass Œ± Œ± (fun x x_1 ‚Ü¶ x * x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
a : Œ±
‚ä¢ Sort ?u.2888
error:  don't know how to synthesize implicit argument 'Œ±'
  @congr ?m.2890 ?m.2891 ?m.2892 ?m.2893 ?m.2894 ?m.2895
context:
Œ± : Type u_1
inst‚úù¬≤ : Group Œ±
inst‚úù¬π : LinearOrder Œ±
inst‚úù : CovariantClass Œ± Œ± (fun x x_1 ‚Ü¶ x * x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
a : Œ±
‚ä¢ Sort ?u.2889
error:  failed to infer 'let' declaration type
error:  unsolved goals
Œ± : Type u_1
inst‚úù¬≤ : Group Œ±
inst‚úù¬π : LinearOrder Œ±
inst‚úù : CovariantClass Œ± Œ± (fun x x_1 ‚Ü¶ x * x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
a : Œ±
‚ä¢ max a‚Åª¬π 1 = a‚Åª¬π * max a 1
error:  unexpected token '('; expected command",lemma max_inv_one (a : Œ±) : max a‚Åª¬π 1 = a‚Åª¬π * max a 1 ,":= by
  rw [eq_inv_mul_iff_mul_eq, ‚Üê eq_div_iff_mul_eq', max_one_div_max_inv_one_eq_self]"
Mathlib/MeasureTheory/Measure/MeasureSpace.lean,MeasureTheory.Measure.map_toOuterMeasure,map_toOuterMeasure,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [‚Üê trimmed, OuterMeasure.trim_eq_trim_iff]
  intro s hs
  rw [map_apply_of_aemeasurable hf hs, OuterMeasure.map_apply]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (map f Œº) s
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
Œ¥ : Type u_4
Œπ : Type u_5
R : Type u_6
R' : Type u_7
m0 : MeasurableSpace Œ±
inst‚úù¬π : MeasurableSpace Œ≤
inst‚úù : MeasurableSpace Œ≥
Œº Œº‚ÇÅ Œº‚ÇÇ Œº‚ÇÉ ŒΩ ŒΩ' ŒΩ‚ÇÅ ŒΩ‚ÇÇ : Measure Œ±
s‚úù s' t : Set Œ±
f : Œ± ‚Üí Œ≤
hf : AEMeasurable f Œº
s : Set Œ≤
hs : MeasurableSet s
‚ä¢ (map f Œº).toOuterMeasure s = ((OuterMeasure.map f) Œº.toOuterMeasure) s
warning:  @Measure.AbsolutelyContinuous does not have a doc string","theorem map_toOuterMeasure (hf : AEMeasurable f Œº) :
    (Œº.map f).toOuterMeasure = (OuterMeasure.map f Œº.toOuterMeasure).trim ",":= by
  rw [‚Üê trimmed, OuterMeasure.trim_eq_trim_iff]
  intro s hs
  simp [hf, hs]"
Mathlib/Computability/Primrec.lean,Primrec.list_range,list_range,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  (nat_rec' .id (const []) ((list_concat.comp‚ÇÇ snd fst).comp snd).to‚ÇÇ).of_eq fun n => by
    simp; induction n <;> simp [*, List.range_succ]","error:  application type mismatch
  Primrec‚ÇÇ.comp‚ÇÇ list_concat snd
argument
  snd
has type
  Primrec Prod.snd : Prop
but is expected to have type
  Primrec‚ÇÇ ?m.161059 : Prop
error:  unsolved goals
case succ
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
œÉ : Type u_4
inst‚úù¬≥ : Primcodable Œ±
inst‚úù¬≤ : Primcodable Œ≤
inst‚úù¬π : Primcodable Œ≥
inst‚úù : Primcodable œÉ
n‚úù : ‚Ñï
a‚úù : Nat.rec [] (fun n IH ‚Ü¶ ?m.160926 n‚úù (n, IH)) n‚úù = List.range n‚úù
‚ä¢ ?m.160926 (n‚úù + 1) (n‚úù, Nat.rec [] (fun n IH ‚Ü¶ ?m.160926 (n‚úù + 1) (n, IH)) n‚úù) = List.range n‚úù ++ [n‚úù]",theorem list_range : Primrec List.range ,":=
  (nat_rec' .id (const []) ((list_concat.comp snd fst).comp snd).to‚ÇÇ).of_eq fun n => by
    simp; induction n <;> simp [*, List.range_succ]"
Mathlib/MeasureTheory/Group/FundamentalDomain.lean,MeasureTheory.IsFundamentalDomain.measure_set_eq,measure_set_eq,b502dbb455f708f5af5e6017e88f53565165ab0a,":= by
  have : ‚à´‚Åª x in s, A.indicator 1 x ‚àÇŒº = ‚à´‚Åª x in t, A.indicator 1 x ‚àÇŒº := by
    refine hs.set_lintegral_eq ht (Set.indicator A fun _ => 1) fun g x ‚Ü¶ ?_
    convert (Set.indicator_comp_right (g ‚Ä¢ ¬∑ : Œ± ‚Üí Œ±) (g := fun _ ‚Ü¶ (1 : ‚Ñù‚â•0‚àû))).symm
    rw [hA g]
  simpa [Measure.restrict_apply hA‚ÇÄ, lintegral_indicator _ hA‚ÇÄ] using this","warning:  `MeasureTheory.IsFundamentalDomain.set_lintegral_eq` has been deprecated, use `MeasureTheory.IsFundamentalDomain.setLIntegral_eq` instead
error:  (kernel) unknown constant 'MeasureTheory.IsAddFundamentalDomain.set_lintegral_eq'
error:  (kernel) unknown constant 'MeasureTheory.IsAddFundamentalDomain.measure_set_eq'
error:  (kernel) unknown constant 'MeasureTheory.IsAddFundamentalDomain.addQuotientMeasure_eq'
error:  (kernel) unknown constant 'MeasureTheory.IsAddFundamentalDomain.addQuotientMeasureEqMeasurePreimage_addQuotientMeasure'
error:  @[to_additive] failed. Type mismatch in additive declaration. For help, see the docstring of `to_additive.attr`, section `Troubleshooting`. Failed to add declaration
MeasureTheory.IsAddFundamentalDomain.addQuotientMeasureEqMeasurePreimage_of_zero:
unknown constant 'MeasureTheory.IsAddFundamentalDomain.addQuotientMeasureEqMeasurePreimage'","theorem measure_set_eq (hs : IsFundamentalDomain G s Œº) (ht : IsFundamentalDomain G t Œº) {A : Set Œ±}
    (hA‚ÇÄ : MeasurableSet A) (hA : ‚àÄ g : G, (fun x => g ‚Ä¢ x) ‚Åª¬π' A = A) : Œº (A ‚à© s) = Œº (A ‚à© t) ",":= by
  have : ‚à´‚Åª x in s, A.indicator 1 x ‚àÇŒº = ‚à´‚Åª x in t, A.indicator 1 x ‚àÇŒº := by
    refine hs.setLIntegral_eq ht (Set.indicator A fun _ => 1) fun g x ‚Ü¶ ?_
    convert (Set.indicator_comp_right (g ‚Ä¢ ¬∑ : Œ± ‚Üí Œ±) (g := fun _ ‚Ü¶ (1 : ‚Ñù‚â•0‚àû))).symm
    rw [hA g]
  simpa [Measure.restrict_apply hA‚ÇÄ, lintegral_indicator _ hA‚ÇÄ] using this"
Mathlib/SetTheory/Game/PGame.lean,SetTheory.PGame.zero_add_equiv,zero_add_equiv,5ea7ea2ce2eab57e5b36fd3e05835034d956d762,":=
  x.zero_add.equiv","warning:  LF does not have a doc string
warning:  Fuzzy does not have a doc string
warning:  Relabelling does not have a doc string
error:  invalid field 'zero_add', the environment does not contain 'SetTheory.PGame.zero_add'
  x
has type
  PGame",theorem zero_add_equiv (x : PGame.{u}) : 0 + x ‚âà x ,":=
  (zeroAddRelabelling x).equiv"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a :=
    ‚ü®_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b :=
    ‚ü®_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]","error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/MeasureTheory/Decomposition/SignedLebesgue.lean,MeasureTheory.SignedMeasure.integrable_rnDeriv,integrable_rnDeriv,c4c52eaf7a157552d85930f5437818b02937c546,":= by
  refine Integrable.sub ?_ ?_ <;>
    ¬∑ constructor
      ¬∑ 
        apply Measurable.aestronglyMeasurable
        fun_prop
      exact hasFiniteIntegral_toReal_of_lintegral_ne_top (lintegral_rnDeriv_lt_top _ Œº).ne","error:  `fun_prop` was unable to prove `Measurable fun x ‚Ü¶ (s.toJordanDecomposition.posPart.rnDeriv Œº x).toReal`

Try running with discharger `fun_prop (disch:=aesop)` or with a different discharger tactic like `assumption`, `linarith`, `omega`.
Sometimes it is useful to run `fun_prop (disch:=trace_state; sorry)` which will print all the necessary subgoals for `fun_prop` to succeed.

Potential issues to fix:
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a ‚Ü¶ s.toJordanDecomposition.posPart.rnDeriv Œº a
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem Continuous.measurable.
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a ‚Ü¶ s.toJordanDecomposition.posPart.rnDeriv Œº a
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem Continuous.measurable.

For more detailed information use `set_option trace.Meta.Tactic.fun_prop true`
error:  `fun_prop` was unable to prove `Measurable fun x ‚Ü¶ (s.toJordanDecomposition.negPart.rnDeriv Œº x).toReal`

Try running with discharger `fun_prop (disch:=aesop)` or with a different discharger tactic like `assumption`, `linarith`, `omega`.
Sometimes it is useful to run `fun_prop (disch:=trace_state; sorry)` which will print all the necessary subgoals for `fun_prop` to succeed.

Potential issues to fix:
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a ‚Ü¶ s.toJordanDecomposition.negPart.rnDeriv Œº a
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem Continuous.measurable.
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a ‚Ü¶ s.toJordanDecomposition.negPart.rnDeriv Œº a
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Œ± when applying theorem Continuous.measurable.

For more detailed information use `set_option trace.Meta.Tactic.fun_prop true`",theorem integrable_rnDeriv (s : SignedMeasure Œ±) (Œº : Measure Œ±) : Integrable (rnDeriv s Œº) Œº ,":= by
  refine Integrable.sub ?_ ?_ <;>
    ¬∑ constructor
      ¬∑ 
        exact (((Measure.measurable_rnDeriv _ Œº
          ).ennreal_toNNReal).coe_nnreal_real).aestronglyMeasurable
      exact hasFiniteIntegral_toReal_of_lintegral_ne_top (lintegral_rnDeriv_lt_top _ Œº).ne"
Mathlib/Order/SuccPred/Basic.lean,Order.pred_lt_pred_of_not_isMin,pred_lt_pred_of_not_isMin,bdc47f6897bd41d0cbeacc8767dea09db3d4e1de,:=,error:  unexpected token 'theorem'; expected term,lemma pred_lt_pred_of_not_isMin (h : a < b) (ha : ¬¨ IsMin a) : pred a < pred b ,":=
  (pred_lt_iff_of_not_isMin ha).2 <| le_pred_of_lt h"
Mathlib/GroupTheory/Schreier.lean,Subgroup.exists_finset_card_le_mul,exists_finset_card_le_mul,8482748e47dd0298ce7e1428f4ff86994d6eb363,":= by
  letI := H.fintypeQuotientOfFiniteIndex
  haveI : DecidableEq G := Classical.decEq G
  obtain ‚ü®R‚ÇÄ, hR, hR1‚ü© := H.exists_right_transversal 1
  haveI : Fintype R‚ÇÄ := Fintype.ofEquiv _ (toEquiv hR)
  let R : Finset G := Set.toFinset R‚ÇÄ
  replace hR : (R : Set G) ‚àà rightTransversals (H : Set G) := by rwa [Set.coe_toFinset]
  replace hR1 : (1 : G) ‚àà R := by rwa [Set.mem_toFinset]
  refine ‚ü®_, ?_, closure_mul_image_eq_top' hR hR1 hS‚ü©
  calc
    _ ‚â§ (R * S).card := Finset.card_image_le
    _ ‚â§ (R √óÀ¢ S).card := Finset.card_image_le
    _ = R.card * S.card := R.card_product S
    _ = H.index * S.card := congr_arg (¬∑ * S.card) ?_
  calc
    R.card = Fintype.card R := (Fintype.card_coe R).symm
    _ = _ := (Fintype.card_congr (toEquiv hR)).symm
    _ = Fintype.card (G ‚ß∏ H) := QuotientGroup.card_quotient_rightRel H
    _ = H.index := by rw [index_eq_card, Nat.card_eq_fintype_card]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.card ?m.45221
G : Type u_1
inst‚úù¬π : Group G
H : Subgroup G
R‚úù S‚úù : Set G
inst‚úù : H.FiniteIndex
S : Finset G
hS : closure ‚ÜëS = ‚ä§
this‚úù¬π : Fintype (G ‚ß∏ H) := H.fintypeQuotientOfFiniteIndex
this‚úù : DecidableEq G
R‚ÇÄ : Set G
this : Fintype ‚ÜëR‚ÇÄ
R : Finset G := R‚ÇÄ.toFinset
hR : ‚ÜëR ‚àà rightTransversals ‚ÜëH
hR1 : 1 ‚àà R
‚ä¢ Fintype.card (G ‚ß∏ H) = Fintype.card (G ‚ß∏ H)","theorem exists_finset_card_le_mul [FiniteIndex H] {S : Finset G} (hS : closure (S : Set G) = ‚ä§) :
    ‚àÉ T : Finset H, T.card ‚â§ H.index * S.card ‚àß closure (T : Set H) = ‚ä§ ",":= by
  letI := H.fintypeQuotientOfFiniteIndex
  haveI : DecidableEq G := Classical.decEq G
  obtain ‚ü®R‚ÇÄ, hR, hR1‚ü© := H.exists_right_transversal 1
  haveI : Fintype R‚ÇÄ := Fintype.ofEquiv _ (toEquiv hR)
  let R : Finset G := Set.toFinset R‚ÇÄ
  replace hR : (R : Set G) ‚àà rightTransversals (H : Set G) := by rwa [Set.coe_toFinset]
  replace hR1 : (1 : G) ‚àà R := by rwa [Set.mem_toFinset]
  refine ‚ü®_, ?_, closure_mul_image_eq_top' hR hR1 hS‚ü©
  calc
    _ ‚â§ (R * S).card := Finset.card_image_le
    _ ‚â§ (R √óÀ¢ S).card := Finset.card_image_le
    _ = R.card * S.card := R.card_product S
    _ = H.index * S.card := congr_arg (¬∑ * S.card) ?_
  calc
    R.card = Fintype.card R := (Fintype.card_coe R).symm
    _ = _ := (Fintype.card_congr (toEquiv hR)).symm
    _ = Fintype.card (G ‚ß∏ H) := QuotientGroup.card_quotient_rightRel H
    _ = H.index := H.index_eq_card.symm"
Mathlib/MeasureTheory/Function/Jacobian.lean,ApproximatesLinearOn.norm_fderiv_sub_le,_root_.ApproximatesLinearOn.norm_fderiv_sub_le,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.op_norm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ
  ¬∑ have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by continuity) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel'_right]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := (norm_add_le _ _)
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel', sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := (norm_sub_le _ _)
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel', norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
        mul_le_mul_of_nonneg_left norm_a (mul_nonneg rpos.le (add_nonneg Œ¥.2 Œµpos.le))
  show ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ;
  exact
    calc
      ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := (norm_add_le _ _)
      _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
        apply add_le_add
        ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
        ¬∑ apply ContinuousLinearMap.le_op_norm
      _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ :=
        add_le_add le_rfl
          (mul_le_mul_of_nonneg_left (mem_closedBall_iff_norm'.1 az) (norm_nonneg _))",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem _root_.ApproximatesLinearOn.norm_fderiv_sub_le {A : E ‚ÜíL[‚Ñù] E} {Œ¥ : ‚Ñù‚â•0}
    (hf : ApproximatesLinearOn f A s Œ¥) (hs : MeasurableSet s) (f' : E ‚Üí E ‚ÜíL[‚Ñù] E)
    (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) : ‚àÄ·µê x ‚àÇŒº.restrict s, ‚Äñf' x - A‚Äñ‚Çä ‚â§ Œ¥ ",":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ by
    have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by fun_prop) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel_left, sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := norm_sub_le _ _
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel_left, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) := by gcongr
  calc
    ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
      congr 1
      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
      abel
    _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
      apply add_le_add
      ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
      ¬∑ apply ContinuousLinearMap.le_opNorm
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ := by
      rw [mem_closedBall_iff_norm'] at az
      gcongr"
Mathlib/RingTheory/Adjoin/Basic.lean,Algebra.adjoin_induction,adjoin_induction,ef3c9bcd07782b044027916a64e925f3e4951707,":=
  let S : Subalgebra R A :=
    { carrier := ‚ü®p‚ü©
      mul_mem' := mul _ _
      add_mem' := add _ _
      algebraMap_mem' := algebraMap }
  adjoin_le (show s ‚â§ S from mem) h","error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  A ‚Üí Prop
error:  type mismatch
  mem
has type
  ‚àÄ x ‚àà s, p x : Prop
but is expected to have type
  s ‚â§ ‚ÜëS : Prop","theorem adjoin_induction {p : A ‚Üí Prop} {x : A} (h : x ‚àà adjoin R s) (mem : ‚àÄ x ‚àà s, p x)
    (algebraMap : ‚àÄ r, p (algebraMap R A r)) (add : ‚àÄ x y, p x ‚Üí p y ‚Üí p (x + y))
    (mul : ‚àÄ x y, p x ‚Üí p y ‚Üí p (x * y)) : p x ",":=
  let S : Subalgebra R A :=
    { carrier := p
      mul_mem' := mul _ _
      add_mem' := add _ _
      algebraMap_mem' := algebraMap }
  adjoin_le (show s ‚â§ S from mem) h"
Mathlib/RingTheory/Artinian.lean,LinearMap.eventually_codisjoint_ker_pow_range_pow,eventually_codisjoint_ker_pow_range_pow,43b4712c74901b669d8c212f8523d4863290c5b0,":= by
  obtain ‚ü®n, hn : ‚àÄ m, n ‚â§ m ‚Üí LinearMap.range (f ^ n) = LinearMap.range (f ^ m)‚ü© :=
    monotone_stabilizes f.iterateRange
  refine eventually_atTop.mpr ‚ü®n, fun m hm ‚Ü¶ codisjoint_iff.mpr ?_‚ü©
  simp_rw [‚Üê hn _ hm, Submodule.eq_top_iff', Submodule.mem_sup]
  intro x
  suffices : ‚àÉ y, (f ^ m) ((f ^ n) y) = (f ^ m) x
  ¬∑ obtain ‚ü®y, hy‚ü© := this; exact ‚ü®x - (f ^ n) y, by simp [hy], (f ^ n) y, by simp‚ü©
  simp_rw [f.pow_apply n, f.pow_apply m, ‚Üê iterate_add_apply, ‚Üê f.pow_apply (m + n),
    ‚Üê f.pow_apply m, ‚Üê mem_range, ‚Üê hn _ (n.le_add_left m), hn _ hm]
  exact LinearMap.mem_range_self (f ^ m) x",error:  unexpected token ':'; expected term,"theorem eventually_codisjoint_ker_pow_range_pow (f : M ‚Üí‚Çó[R] M) :
    ‚àÄ·∂† n in atTop, Codisjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) ",":= by
  obtain ‚ü®n, hn : ‚àÄ m, n ‚â§ m ‚Üí LinearMap.range (f ^ n) = LinearMap.range (f ^ m)‚ü© :=
    monotone_stabilizes f.iterateRange
  refine eventually_atTop.mpr ‚ü®n, fun m hm ‚Ü¶ codisjoint_iff.mpr ?_‚ü©
  simp_rw [‚Üê hn _ hm, Submodule.eq_top_iff', Submodule.mem_sup]
  intro x
  rsuffices ‚ü®y, hy‚ü© : ‚àÉ y, (f ^ m) ((f ^ n) y) = (f ^ m) x
  ¬∑ exact ‚ü®x - (f ^ n) y, by simp [hy], (f ^ n) y, by simp‚ü©
  simp_rw [f.pow_apply n, f.pow_apply m, ‚Üê iterate_add_apply, ‚Üê f.pow_apply (m + n),
    ‚Üê f.pow_apply m, ‚Üê mem_range (f := _), ‚Üê hn _ (n.le_add_left m), hn _ hm]
  exact LinearMap.mem_range_self (f ^ m) x"
Mathlib/RingTheory/PrincipalIdealDomain.lean,IsPrincipalIdealRing.of_prime,IsPrincipalIdealRing.of_prime,d664a4757e1d5d6999ae3ca588b989e1039faee2,":= by
  rw [‚Üê nonPrincipals_eq_empty_iff, Set.eq_empty_iff_forall_not_mem]
  intro J hJ
  obtain ‚ü®I, Ibad, -, Imax‚ü© := zorn_nonempty_partialOrder‚ÇÄ (nonPrincipals R) nonPrincipals_zorn _ hJ
  have Imax' : ‚àÄ {J}, I < J ‚Üí J.IsPrincipal := by
    intro J hJ
    by_contra He
    exact hJ.ne (Imax _ ((nonPrincipals_def R).2 He) hJ.le).symm
  by_cases hI1 : I = ‚ä§
  ¬∑ subst hI1
    exact Ibad top_isPrincipal
  refine' Ibad (H I ‚ü®hI1, fun {x y} hxy => or_iff_not_imp_right.mpr fun hy => _‚ü©)
  obtain ‚ü®a, ha‚ü© : (I ‚äî span {y}).IsPrincipal :=
    Imax' (left_lt_sup.mpr (mt I.span_singleton_le_iff_mem.mp hy))
  suffices He : ¬¨(I.colon (span {y})).IsPrincipal
  ¬∑ rw [‚Üê Imax _ ((nonPrincipals_def R).2 He) fun a ha =>
        Ideal.mem_colon_singleton.2 (mul_mem_right _ _ ha)]
    exact Ideal.mem_colon_singleton.2 hxy
  rintro ‚ü®b, hb‚ü©
  refine (nonPrincipals_def _).1 Ibad ‚ü®a * b, ?_‚ü©
  refine'
    le_antisymm (Œ± := Ideal R) (fun i hi => _) <| (span_singleton_mul_span_singleton a b).ge.trans _
  ¬∑ have hisup : i ‚àà I ‚äî span {y} := Ideal.mem_sup_left hi
    have : y ‚àà I ‚äî span {y} := Ideal.mem_sup_right (Ideal.mem_span_singleton_self y)
    erw [ha, mem_span_singleton'] at hisup this
    obtain ‚ü®v, rfl‚ü© := this
    obtain ‚ü®u, rfl‚ü© := hisup
    have hucolon : u ‚àà I.colon (span {v * a}) := by
      rw [Ideal.mem_colon_singleton, mul_comm v, ‚Üê mul_assoc]
      exact mul_mem_right _ _ hi
    erw [hb, mem_span_singleton'] at hucolon
    obtain ‚ü®z, rfl‚ü© := hucolon
    exact mem_span_singleton'.2 ‚ü®z, by ring‚ü©
  ¬∑ rw [‚Üê Ideal.submodule_span_eq, ‚Üê ha, Ideal.sup_mul, sup_le_iff,
      span_singleton_mul_span_singleton, mul_comm y, Ideal.span_singleton_le_iff_mem]
    exact ‚ü®mul_le_right, Ideal.mem_colon_singleton.1 <| hb.symm ‚ñ∏ Ideal.mem_span_singleton_self b‚ü©",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem IsPrincipalIdealRing.of_prime (H : ‚àÄ P : Ideal R, P.IsPrime ‚Üí P.IsPrincipal) :
    IsPrincipalIdealRing R ",":= by
  rw [‚Üê nonPrincipals_eq_empty_iff, Set.eq_empty_iff_forall_not_mem]
  intro J hJ
  obtain ‚ü®I, Ibad, -, Imax‚ü© := zorn_nonempty_partialOrder‚ÇÄ (nonPrincipals R) nonPrincipals_zorn _ hJ
  have Imax' : ‚àÄ {J}, I < J ‚Üí J.IsPrincipal := by
    intro J hJ
    by_contra He
    exact hJ.ne (Imax _ ((nonPrincipals_def R).2 He) hJ.le).symm
  by_cases hI1 : I = ‚ä§
  ¬∑ subst hI1
    exact Ibad top_isPrincipal
  refine Ibad (H I ‚ü®hI1, fun {x y} hxy => or_iff_not_imp_right.mpr fun hy => ?_‚ü©)
  obtain ‚ü®a, ha‚ü© : (I ‚äî span {y}).IsPrincipal :=
    Imax' (left_lt_sup.mpr (mt I.span_singleton_le_iff_mem.mp hy))
  suffices He : ¬¨(I.colon (span {y})).IsPrincipal by
    rw [‚Üê Imax _ ((nonPrincipals_def R).2 He) fun a ha =>
        Ideal.mem_colon_singleton.2 (mul_mem_right _ _ ha)]
    exact Ideal.mem_colon_singleton.2 hxy
  rintro ‚ü®b, hb‚ü©
  refine (nonPrincipals_def _).1 Ibad ‚ü®a * b, ?_‚ü©
  refine
    le_antisymm (Œ± := Ideal R) (fun i hi => ?_) <|
      (span_singleton_mul_span_singleton a b).ge.trans ?_
  ¬∑ have hisup : i ‚àà I ‚äî span {y} := Ideal.mem_sup_left hi
    have : y ‚àà I ‚äî span {y} := Ideal.mem_sup_right (Ideal.mem_span_singleton_self y)
    erw [ha, mem_span_singleton'] at hisup this
    obtain ‚ü®v, rfl‚ü© := this
    obtain ‚ü®u, rfl‚ü© := hisup
    have hucolon : u ‚àà I.colon (span {v * a}) := by
      rw [Ideal.mem_colon_singleton, mul_comm v, ‚Üê mul_assoc]
      exact mul_mem_right _ _ hi
    erw [hb, mem_span_singleton'] at hucolon
    obtain ‚ü®z, rfl‚ü© := hucolon
    exact mem_span_singleton'.2 ‚ü®z, by ring‚ü©
  ¬∑ rw [‚Üê Ideal.submodule_span_eq, ‚Üê ha, Ideal.sup_mul, sup_le_iff,
      span_singleton_mul_span_singleton, mul_comm y, Ideal.span_singleton_le_iff_mem]
    exact ‚ü®mul_le_right, Ideal.mem_colon_singleton.1 <| hb.symm ‚ñ∏ Ideal.mem_span_singleton_self b‚ü©"
Mathlib/NumberTheory/NumberField/CanonicalEmbedding/ConvexBody.lean,NumberField.mixedEmbedding.convexBodySumFun_add_le,convexBodySumFun_add_le,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  simp_rw [convexBodySumFun, Prod.fst_add, Pi.add_apply, Prod.snd_add]
  refine (add_le_add
    (Finset.sum_le_sum (fun w _ => norm_add_le (x.1 w) (y.1 w)))
    (mul_le_mul_of_nonneg_left
      (Finset.sum_le_sum (fun w _ => norm_add_le (x.2 w) (y.2 w))) (by norm_num))).trans_eq ?_
  simp_rw [Finset.sum_add_distrib, mul_add]
  ring",error:  simp made no progress,"theorem convexBodySumFun_add_le (x y : E K) :
    convexBodySumFun (x + y) ‚â§ convexBodySumFun x + convexBodySumFun y ",":= by
  simp_rw [convexBodySumFun, ‚Üê Finset.sum_add_distrib, ‚Üê mul_add]
  exact Finset.sum_le_sum
    fun _ _ ‚Ü¶ mul_le_mul_of_nonneg_left (normAtPlace_add_le _ x y) (Nat.cast_pos.mpr mult_pos).le"
Mathlib/Analysis/Convex/Slope.lean,StrictConvexOn.slope_strict_mono_adjacent,StrictConvexOn.slope_strict_mono_adjacent,9900e14a3e4396503c547dbd655e9384b9500b79,":= by
  have hxz := hxy.trans hyz
  have hxz' := hxz.ne
  rw [‚Üê sub_pos] at hxy hxz hyz
  suffices f y / (y - x) + f y / (z - y) < f x / (y - x) + f z / (z - y) by
    ring_nf  at this‚ä¢
    linarith
  set a := (z - y) / (z - x)
  set b := (y - x) / (z - x)
  have hy : a ‚Ä¢ x + b ‚Ä¢ z = y := by
    field_simp
    rw [div_eq_iff] <;> [ring, linarith]
  have key :=
    hf.2 hx hz hxz' (div_pos hyz hxz) (div_pos hxy hxz)
      (show a + b = 1 by
        field_simp
        rw [div_eq_iff] <;> [ring, linarith])
  rw [hy] at key
  replace key := mul_lt_mul_of_pos_left key hxz
  field_simp [hxy.ne', hyz.ne', hxz.ne', mul_comm (z - x) _]  at key‚ä¢
  rw [div_lt_div_right]
  ¬∑ linarith
  ¬∑ nlinarith","error:  unexpected token ','; expected ']'","theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn ùïú s f) {x y z : ùïú}
    (hx : x ‚àà s) (hz : z ‚àà s) (hxy : x < y) (hyz : y < z) :
    (f y - f x) / (y - x) < (f z - f y) / (z - y) ",":= by
  have hxz := hxy.trans hyz
  have hxz' := hxz.ne
  rw [‚Üê sub_pos] at hxy hxz hyz
  suffices f y / (y - x) + f y / (z - y) < f x / (y - x) + f z / (z - y) by
    ring_nf at this ‚ä¢
    linarith
  set a := (z - y) / (z - x)
  set b := (y - x) / (z - x)
  have hy : a ‚Ä¢ x + b ‚Ä¢ z = y := by field_simp [a, b]; ring
  have key :=
    hf.2 hx hz hxz' (div_pos hyz hxz) (div_pos hxy hxz)
      (show a + b = 1 by field_simp [a, b])
  rw [hy] at key
  replace key := mul_lt_mul_of_pos_left key hxz
  field_simp [mul_comm (z - x) _] at key ‚ä¢
  rw [div_lt_div_right]
  ¬∑ linarith
  ¬∑ nlinarith"
Mathlib/Combinatorics/SetFamily/CauchyDavenport.lean,Finset.min_le_card_mul,Finset.min_le_card_mul,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain ‚ü®rfl, rfl‚ü© := hx
  refine wellFoundedOn_devosMulRel.induction (P := fun x : Finset Œ± √ó Finset Œ± ‚Ü¶
    min (minOrder Œ±) ‚Üë(card x.1 + card x.2 - 1) ‚â§ card (x.1 * x.2)) ‚ü®hs, ht‚ü© ?_
  clear! x
  rintro ‚ü®s, t‚ü© ‚ü®hs, ht‚ü© ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  ¬∑ simpa only [‚Üê mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [‚Üê mul_inv_rev, add_comm, card_inv, true_and])
  obtain ‚ü®a, rfl‚ü© | ‚ü®a, ha, b, hb, hab‚ü© := hs.exists_eq_singleton_or_nontrivial
  ¬∑ simp [add_comm]
  obtain ‚ü®g, hg, hgs‚ü© : ‚àÉ g : Œ±, g ‚â† 1 ‚àß (s ‚à© op g ‚Ä¢ s).Nonempty :=
    ‚ü®b‚Åª¬π * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 ‚ü®ha, mem_smul_finset.2 ‚ü®_, hb, by simp‚ü©‚ü©‚ü©
  obtain hsg | hsg := eq_or_ne (op g ‚Ä¢ s) s
  ¬∑ have hS : (zpowers g : Set Œ±) ‚äÜ a‚Åª¬π ‚Ä¢ (s : Set Œ±) := by
      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (¬∑ ‚àà a‚Åª¬π ‚Ä¢ (s : Set Œ±))
        ‚ü®_, ha, inv_mul_self _‚ü© (fun c hc ‚Ü¶ ?_) fun c hc ‚Ü¶ ?_
      ¬∑ rw [‚Üê hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      ¬∑ simp only
        rwa [‚Üê op_smul_eq_mul, op_inv, ‚Üê Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          ‚Üê coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [‚Üê coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s ‚à© op g ‚Ä¢ s).card < s.card := card_lt_card ‚ü®inter_subset_left _ _, fun h ‚Ü¶
    hsg <| eq_of_superset_of_card_ge (h.trans <| inter_subset_right _ _) (card_smul_finset _ _).le‚ü©
  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (g‚Åª¬π ‚Ä¢ t)
  ¬∑ rw [‚Üê card_smul_finset g‚Åª¬π t]
    refine' Or.inr ((add_le_add_right hst _).trans _)
    rw [‚Üê card_union_of_disjoint hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  ¬∑ exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h ‚Ü¶ hstg.trans <| h.trans <| add_le_add_right aux1 _
  ¬∑ exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h ‚Ü¶
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _","error:  function expected at
  inter_subset_left ?m.46803
term has type
  ?m.46802 ‚àà ?m.46800
error:  function expected at
  inter_subset_right ?m.46987
term has type
  ?m.46986 ‚àà ?m.46985","lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder Œ±) ‚Üë(s.card + t.card - 1) ‚â§ (s * t).card ",":= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain ‚ü®rfl, rfl‚ü© := hx
  refine wellFoundedOn_devosMulRel.induction (P := fun x : Finset Œ± √ó Finset Œ± ‚Ü¶
    min (minOrder Œ±) ‚Üë(card x.1 + card x.2 - 1) ‚â§ card (x.1 * x.2)) ‚ü®hs, ht‚ü© ?_
  clear! x
  rintro ‚ü®s, t‚ü© ‚ü®hs, ht‚ü© ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  ¬∑ simpa only [‚Üê mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [‚Üê mul_inv_rev, add_comm, card_inv, true_and])
  obtain ‚ü®a, rfl‚ü© | ‚ü®a, ha, b, hb, hab‚ü© := hs.exists_eq_singleton_or_nontrivial
  ¬∑ simp [add_comm]
  obtain ‚ü®g, hg, hgs‚ü© : ‚àÉ g : Œ±, g ‚â† 1 ‚àß (s ‚à© op g ‚Ä¢ s).Nonempty :=
    ‚ü®b‚Åª¬π * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 ‚ü®ha, mem_smul_finset.2 ‚ü®_, hb, by simp‚ü©‚ü©‚ü©
  obtain hsg | hsg := eq_or_ne (op g ‚Ä¢ s) s
  ¬∑ have hS : (zpowers g : Set Œ±) ‚äÜ a‚Åª¬π ‚Ä¢ (s : Set Œ±) := by
      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (¬∑ ‚àà a‚Åª¬π ‚Ä¢ (s : Set Œ±))
        ‚ü®_, ha, inv_mul_self _‚ü© (fun c hc ‚Ü¶ ?_) fun c hc ‚Ü¶ ?_
      ¬∑ rw [‚Üê hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      ¬∑ simp only
        rwa [‚Üê op_smul_eq_mul, op_inv, ‚Üê Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          ‚Üê coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [‚Üê coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s ‚à© op g ‚Ä¢ s).card < s.card := card_lt_card ‚ü®inter_subset_left, fun h ‚Ü¶
    hsg <| eq_of_superset_of_card_ge (h.trans inter_subset_right) (card_smul_finset _ _).le‚ü©
  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (g‚Åª¬π ‚Ä¢ t)
  ¬∑ rw [‚Üê card_smul_finset g‚Åª¬π t]
    refine Or.inr ((add_le_add_right hst _).trans ?_)
    rw [‚Üê card_union_of_disjoint hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  ¬∑ exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h ‚Ü¶ hstg.trans <| h.trans <| add_le_add_right aux1 _
  ¬∑ exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h ‚Ü¶
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _"
Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean,Complex.differentiable_one_div_Gamma,differentiable_one_div_Gamma,a7fbc9ec101d941ce1e02955a6e130a25d5ab907,":= by
  suffices : ‚àÄ n : ‚Ñï, ‚àÄ (s : ‚ÑÇ) (_ : -s.re < n), DifferentiableAt ‚ÑÇ (fun u : ‚ÑÇ => (Gamma u)‚Åª¬π) s
  exact fun s =>
    let ‚ü®n, h‚ü© := exists_nat_gt (-s.re)
    this n s h
  intro n
  induction' n with m hm
  ¬∑ intro s hs
    rw [Nat.cast_zero, neg_lt_zero] at hs
    suffices : ‚àÄ m : ‚Ñï, s ‚â† -‚Üëm; exact (differentiableAt_Gamma _ this).inv (Gamma_ne_zero this)
    contrapose! hs
    rcases hs with ‚ü®m, rfl‚ü©
    simpa only [neg_re, ‚Üê ofReal_nat_cast, ofReal_re, neg_nonpos] using Nat.cast_nonneg m
  ¬∑ intro s hs
    rw [funext one_div_Gamma_eq_self_mul_one_div_Gamma_add_one]
    specialize hm (s + 1) (by rwa [add_re, one_re, neg_add', sub_lt_iff_lt_add, ‚Üê Nat.cast_succ])
    refine' differentiableAt_id.mul (hm.comp s _)
    exact differentiableAt_id.add (differentiableAt_const _)",error:  unexpected token ':'; expected term,theorem differentiable_one_div_Gamma : Differentiable ‚ÑÇ fun s : ‚ÑÇ => (Gamma s)‚Åª¬π ,":= fun s ‚Ü¶ by
  rcases exists_nat_gt (-s.re) with ‚ü®n, hs‚ü©
  induction n generalizing s with
  | zero =>
    rw [Nat.cast_zero, neg_lt_zero] at hs
    suffices ‚àÄ m : ‚Ñï, s ‚â† -‚Üëm from (differentiableAt_Gamma _ this).inv (Gamma_ne_zero this)
    rintro m rfl
    apply hs.not_le
    simp
  | succ n ihn =>
    rw [funext one_div_Gamma_eq_self_mul_one_div_Gamma_add_one]
    specialize ihn (s + 1) (by rwa [add_re, one_re, neg_add', sub_lt_iff_lt_add, ‚Üê Nat.cast_succ])
    exact differentiableAt_id.mul (ihn.comp s <| differentiableAt_id.add_const _)"
Mathlib/Data/List/NodupEquivFin.lean,List.sublist_iff_exists_fin_orderEmbedding_get_eq,sublist_iff_exists_fin_orderEmbedding_get_eq,ec25cca0630aff3805accd410e27691c8e6c4315,":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï}, i < l.length ‚Üí f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine' ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) _, _‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [get?_eq_get i.2, get?_eq_get (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine'
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          _,
        _‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ rw [add_comm]
        exact lt_add_of_lt_of_pos (Fin.is_lt _) (i.zero_le.trans_lt h)
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi","error:  type mismatch
  h‚úù
has type
  some l[‚Üëi] = l'[f ‚Üëi]? : Prop
but is expected to have type
  l[‚Üëi] = l'[f ‚Üëi] : Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + ?b
case neg
Œ± : Type u_1
l l' : List Œ±
f : Fin l.length ‚Ü™o Fin l'.length
hf : ‚àÄ (ix : Fin l.length), l.get ix = l'.get (f ix)
i j : ‚Ñï
h : i < j
hi : i < l.length
hj : ¬¨j < l.length
‚ä¢ ‚Üë(f ‚ü®i, hi‚ü©) < j + l'.length
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem sublist_iff_exists_fin_orderEmbedding_get_eq {l l' : List Œ±} :
    l <+ l' ‚Üî
      ‚àÉ f : Fin l.length ‚Ü™o Fin l'.length,
        ‚àÄ ix : Fin l.length, l.get ix = l'.get (f ix) ",":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï}, i < l.length ‚Üí f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) ?_, ?_‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [getElem?_eq_getElem i.2, getElem?_eq_getElem (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          ?_,
        ?_‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ have := (f ‚ü®i, hi‚ü©).is_lt
        omega
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi"
Mathlib/Data/List/OfFn.lean,List.ofFn_succ,ofFn_succ,66caaeed4dccada03ce195a3f9db1c0009ee8118,":=
  ext_get (by simp) (fun i hi‚ÇÅ hi‚ÇÇ => by
    cases i
    ¬∑ simp; rfl
    ¬∑ simp)","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_ofFn` has been deprecated, use `List.get_ofFn` instead
error:  no goals to be solved
warning:  `List.nthLe` has been deprecated, use `List.get` instead",theorem ofFn_succ {n} (f : Fin (succ n) ‚Üí Œ±) : ofFn f = f 0 :: ofFn fun i => f i.succ ,":=
  ext_get (by simp) (fun i hi‚ÇÅ hi‚ÇÇ => by
    cases i
    ¬∑ simp
    ¬∑ simp)"
Mathlib/MeasureTheory/Function/ContinuousMapDense.lean,MeasureTheory.Mem‚Ñíp.exists_hasCompactSupport_snorm_sub_le,Mem‚Ñíp.exists_hasCompactSupport_snorm_sub_le,2a6557e2b74660500c0cb5c37da161c4edbec35f,":= by
  suffices H :
    ‚àÉ g : Œ± ‚Üí E, snorm (f - g) p Œº ‚â§ Œµ ‚àß Continuous g ‚àß Mem‚Ñíp g p Œº ‚àß HasCompactSupport g
  ¬∑ rcases H with ‚ü®g, hg, g_cont, g_mem, g_support‚ü©
    exact ‚ü®g, g_support, hg, g_cont, g_mem‚ü©
  apply hf.induction_dense hp _ _ _ _ hŒµ
  rotate_left
  ¬∑ rintro f g ‚ü®f_cont, f_mem, hf‚ü© ‚ü®g_cont, g_mem, hg‚ü©
    exact ‚ü®f_cont.add g_cont, f_mem.add g_mem, hf.add hg‚ü©
  ¬∑ rintro f ‚ü®_f_cont, f_mem, _hf‚ü©
    exact f_mem.aestronglyMeasurable
  intro c t ht htŒº Œµ hŒµ
  rcases exists_Lp_half E Œº p hŒµ with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©
  obtain ‚ü®Œ∑, Œ∑pos, hŒ∑‚ü© :
    ‚àÉ Œ∑ : ‚Ñù‚â•0, 0 < Œ∑ ‚àß ‚àÄ s : Set Œ±, Œº s ‚â§ Œ∑ ‚Üí snorm (s.indicator fun _x => c) p Œº ‚â§ Œ¥
  exact exists_snorm_indicator_le hp c Œ¥pos.ne'
  have hŒ∑_pos' : (0 : ‚Ñù‚â•0‚àû) < Œ∑ := ENNReal.coe_pos.2 Œ∑pos
  obtain ‚ü®s, st, s_compact, Œºs‚ü© : ‚àÉ s, s ‚äÜ t ‚àß IsCompact s ‚àß Œº (t \ s) < Œ∑
  exact ht.exists_isCompact_diff_lt htŒº.ne hŒ∑_pos'.ne'
  have hsŒº : Œº s < ‚àû := (measure_mono st).trans_lt htŒº
  have I1 : snorm ((s.indicator fun _y => c) - t.indicator fun _y => c) p Œº ‚â§ Œ¥ := by
    rw [‚Üê snorm_neg, neg_sub, ‚Üê indicator_diff st]
    exact hŒ∑ _ Œºs.le
  obtain ‚ü®k, k_compact, sk‚ü© : ‚àÉ k : Set Œ±, IsCompact k ‚àß s ‚äÜ interior k :=
    exists_compact_superset s_compact
  rcases exists_continuous_snorm_sub_le_of_closed hp s_compact.isClosed isOpen_interior sk hsŒº.ne c
      Œ¥pos.ne' with
    ‚ü®f, f_cont, I2, _f_bound, f_support, f_mem‚ü©
  have I3 : snorm (f - t.indicator fun _y => c) p Œº ‚â§ Œµ := by
    convert
      (hŒ¥ _ _
          (f_mem.aestronglyMeasurable.sub
            (aestronglyMeasurable_const.indicator s_compact.measurableSet))
          ((aestronglyMeasurable_const.indicator s_compact.measurableSet).sub
            (aestronglyMeasurable_const.indicator ht))
          I2 I1).le using 2
    simp only [sub_add_sub_cancel]
  refine' ‚ü®f, I3, f_cont, f_mem, HasCompactSupport.intro k_compact fun x hx => _‚ü©
  rw [‚Üê Function.nmem_support]
  contrapose! hx
  exact interior_subset (f_support hx)",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem Mem‚Ñíp.exists_hasCompactSupport_snorm_sub_le [WeaklyLocallyCompactSpace Œ±] [Œº.Regular]
    (hp : p ‚â† ‚àû) {f : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) {Œµ : ‚Ñù‚â•0‚àû} (hŒµ : Œµ ‚â† 0) :
    ‚àÉ g : Œ± ‚Üí E, HasCompactSupport g ‚àß snorm (f - g) p Œº ‚â§ Œµ ‚àß Continuous g ‚àß Mem‚Ñíp g p Œº ",":= by
  suffices H :
      ‚àÉ g : Œ± ‚Üí E, snorm (f - g) p Œº ‚â§ Œµ ‚àß Continuous g ‚àß Mem‚Ñíp g p Œº ‚àß HasCompactSupport g by
    rcases H with ‚ü®g, hg, g_cont, g_mem, g_support‚ü©
    exact ‚ü®g, g_support, hg, g_cont, g_mem‚ü©
  apply hf.induction_dense hp _ _ _ _ hŒµ
  rotate_left
  ¬∑ rintro f g ‚ü®f_cont, f_mem, hf‚ü© ‚ü®g_cont, g_mem, hg‚ü©
    exact ‚ü®f_cont.add g_cont, f_mem.add g_mem, hf.add hg‚ü©
  ¬∑ rintro f ‚ü®_f_cont, f_mem, _hf‚ü©
    exact f_mem.aestronglyMeasurable
  intro c t ht htŒº Œµ hŒµ
  rcases exists_Lp_half E Œº p hŒµ with ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü©
  obtain ‚ü®Œ∑, Œ∑pos, hŒ∑‚ü© :
      ‚àÉ Œ∑ : ‚Ñù‚â•0, 0 < Œ∑ ‚àß ‚àÄ s : Set Œ±, Œº s ‚â§ Œ∑ ‚Üí snorm (s.indicator fun _x => c) p Œº ‚â§ Œ¥ :=
    exists_snorm_indicator_le hp c Œ¥pos.ne'
  have hŒ∑_pos' : (0 : ‚Ñù‚â•0‚àû) < Œ∑ := ENNReal.coe_pos.2 Œ∑pos
  obtain ‚ü®s, st, s_compact, Œºs‚ü© : ‚àÉ s, s ‚äÜ t ‚àß IsCompact s ‚àß Œº (t \ s) < Œ∑ :=
    ht.exists_isCompact_diff_lt htŒº.ne hŒ∑_pos'.ne'
  have hsŒº : Œº s < ‚àû := (measure_mono st).trans_lt htŒº
  have I1 : snorm ((s.indicator fun _y => c) - t.indicator fun _y => c) p Œº ‚â§ Œ¥ := by
    rw [‚Üê snorm_neg, neg_sub, ‚Üê indicator_diff st]
    exact hŒ∑ _ Œºs.le
  obtain ‚ü®k, k_compact, sk‚ü© : ‚àÉ k : Set Œ±, IsCompact k ‚àß s ‚äÜ interior k :=
    exists_compact_superset s_compact
  rcases exists_continuous_snorm_sub_le_of_closed hp s_compact.isClosed isOpen_interior sk hsŒº.ne c
      Œ¥pos.ne' with
    ‚ü®f, f_cont, I2, _f_bound, f_support, f_mem‚ü©
  have I3 : snorm (f - t.indicator fun _y => c) p Œº ‚â§ Œµ := by
    convert
      (hŒ¥ _ _
          (f_mem.aestronglyMeasurable.sub
            (aestronglyMeasurable_const.indicator s_compact.measurableSet))
          ((aestronglyMeasurable_const.indicator s_compact.measurableSet).sub
            (aestronglyMeasurable_const.indicator ht))
          I2 I1).le using 2
    simp only [sub_add_sub_cancel]
  refine ‚ü®f, I3, f_cont, f_mem, HasCompactSupport.intro k_compact fun x hx => ?_‚ü©
  rw [‚Üê Function.nmem_support]
  contrapose! hx
  exact interior_subset (f_support hx)"
Mathlib/CategoryTheory/FiberedCategory/HomLift.lean,CategoryTheory.IsHomLift.id_lift_eqToHom_domain,id_lift_eqToHom_domain,95e75fcfd1c014add03de9b53a54ac3c1396bb20,  fac := by simp [eqToHom_map],"error:  function expected at
  p.IsHomLift (eqToHom hRS) (ùüô a)
term has type
  Prop
error:  simp made no progress","lemma id_lift_eqToHom_domain {p : ùí≥ ‚•§ ùíÆ} {R S : ùíÆ} (hRS : R = S) {a : ùí≥} (ha : p.obj a = R) :
    p.IsHomLift (eqToHom hRS) (ùüô a) ",":= by
  subst hRS ha; simp"
Mathlib/Computability/Primrec.lean,PrimrecPred.and,_root_.PrimrecPred.and,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  (Primrec.and.comp‚ÇÇ hp hq).of_eq fun n => by simp","error:  application type mismatch
  Primrec‚ÇÇ.comp‚ÇÇ Primrec.and hp
argument
  hp
has type
  PrimrecPred p : Prop
but is expected to have type
  Primrec‚ÇÇ ?m.92602 : Prop
error:  simp made no progress","theorem _root_.PrimrecPred.and {p q : Œ± ‚Üí Prop} [DecidablePred p] [DecidablePred q]
    (hp : PrimrecPred p) (hq : PrimrecPred q) : PrimrecPred fun a => p a ‚àß q a ",":=
  (Primrec.and.comp hp hq).of_eq fun n => by simp"
Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean,hasDerivAt_ofReal_cpow,hasDerivAt_ofReal_cpow,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  rw [Ne.def, ‚Üê add_eq_zero_iff_eq_neg, ‚Üê Ne.def] at hr
  rcases lt_or_gt_of_ne hx.symm with (hx | hx)
  ¬∑ 
    apply HasDerivAt.comp_ofReal (e := fun y => (y : ‚ÑÇ) ^ (r + 1) / (r + 1))
    convert HasDerivAt.div_const (ùïú := ‚ÑÇ) ?_ (r + 1) using 1
    ¬∑ exact (mul_div_cancel _ hr).symm
    ¬∑ convert HasDerivAt.cpow_const ?_ ?_ using 1
      ¬∑ rw [add_sub_cancel, mul_comm]; exact (mul_one _).symm
      ¬∑ exact hasDerivAt_id (x : ‚ÑÇ)
      ¬∑ simp [hx]
  ¬∑ 
    have : ‚àÄ·∂† y : ‚Ñù in ùìù x,
        (y : ‚ÑÇ) ^ (r + 1) / (r + 1) = (-y : ‚ÑÇ) ^ (r + 1) * exp (œÄ * I * (r + 1)) / (r + 1) := by
      refine' Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => _
      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]
    refine' HasDerivAt.congr_of_eventuallyEq _ this
    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]
    suffices HasDerivAt (fun y : ‚Ñù => (-‚Üëy) ^ (r + 1) * exp (‚ÜëœÄ * I * (r + 1)))
        ((r + 1) * (-‚Üëx) ^ r * exp (‚ÜëœÄ * I * r)) x by
      convert this.div_const (r + 1) using 1
      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel _ hr]
    rw [mul_add ((œÄ : ‚ÑÇ) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : ‚ÑÇ) (-1 : ‚ÑÇ),
      neg_one_mul]
    simp_rw [mul_neg, ‚Üê neg_mul, ‚Üê ofReal_neg]
    suffices HasDerivAt (fun y : ‚Ñù => (‚Üë(-y) : ‚ÑÇ) ^ (r + 1)) (-(r + 1) * ‚Üë(-x) ^ r) x by
      convert this.neg.mul_const _ using 1; ring
    suffices HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) (-x) by
      convert @HasDerivAt.scomp ‚Ñù _ ‚ÑÇ _ _ x ‚Ñù _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1
      rw [real_smul, ofReal_neg 1, ofReal_one]; ring
    suffices HasDerivAt (fun y : ‚ÑÇ => y ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) ‚Üë(-x) by
      exact this.comp_ofReal
    conv in ‚Üë_ ^ _ => rw [(by ring : r = r + 1 - 1)]
    convert HasDerivAt.cpow_const ?_ ?_ using 1
    ¬∑ rw [add_sub_cancel, add_sub_cancel]; exact (mul_one _).symm
    ¬∑ exact hasDerivAt_id ((-x : ‚Ñù) : ‚ÑÇ)
    ¬∑ simp [hx]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.106391 ‚Üí ?m.106391 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.106393
f g : ‚ÑÇ ‚Üí ‚ÑÇ
s : Set ‚ÑÇ
f' g' x‚úù c : ‚ÑÇ
x : ‚Ñù
hx : x ‚â† 0
r : ‚ÑÇ
hr : r ‚â† -1
‚ä¢ HasDerivAt (fun y ‚Ü¶ ‚Üëy ^ (r + 1) / (r + 1)) (‚Üëx ^ r) x","theorem hasDerivAt_ofReal_cpow {x : ‚Ñù} (hx : x ‚â† 0) {r : ‚ÑÇ} (hr : r ‚â† -1) :
    HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ (r + 1) / (r + 1)) (x ^ r) x ",":= by
  rw [Ne, ‚Üê add_eq_zero_iff_eq_neg, ‚Üê Ne] at hr
  rcases lt_or_gt_of_ne hx.symm with (hx | hx)
  ¬∑ 
    apply HasDerivAt.comp_ofReal (e := fun y => (y : ‚ÑÇ) ^ (r + 1) / (r + 1))
    convert HasDerivAt.div_const (ùïú := ‚ÑÇ) ?_ (r + 1) using 1
    ¬∑ exact (mul_div_cancel_right‚ÇÄ _ hr).symm
    ¬∑ convert HasDerivAt.cpow_const ?_ ?_ using 1
      ¬∑ rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm
      ¬∑ exact hasDerivAt_id (x : ‚ÑÇ)
      ¬∑ simp [hx]
  ¬∑ 
    have : ‚àÄ·∂† y : ‚Ñù in ùìù x,
        (y : ‚ÑÇ) ^ (r + 1) / (r + 1) = (-y : ‚ÑÇ) ^ (r + 1) * exp (œÄ * I * (r + 1)) / (r + 1) := by
      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_
      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]
    refine HasDerivAt.congr_of_eventuallyEq ?_ this
    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]
    suffices HasDerivAt (fun y : ‚Ñù => (-‚Üëy) ^ (r + 1) * exp (‚ÜëœÄ * I * (r + 1)))
        ((r + 1) * (-‚Üëx) ^ r * exp (‚ÜëœÄ * I * r)) x by
      convert this.div_const (r + 1) using 1
      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right‚ÇÄ _ hr]
    rw [mul_add ((œÄ : ‚ÑÇ) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : ‚ÑÇ) (-1 : ‚ÑÇ),
      neg_one_mul]
    simp_rw [mul_neg, ‚Üê neg_mul, ‚Üê ofReal_neg]
    suffices HasDerivAt (fun y : ‚Ñù => (‚Üë(-y) : ‚ÑÇ) ^ (r + 1)) (-(r + 1) * ‚Üë(-x) ^ r) x by
      convert this.neg.mul_const _ using 1; ring
    suffices HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) (-x) by
      convert @HasDerivAt.scomp ‚Ñù _ ‚ÑÇ _ _ x ‚Ñù _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1
      rw [real_smul, ofReal_neg 1, ofReal_one]; ring
    suffices HasDerivAt (fun y : ‚ÑÇ => y ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) ‚Üë(-x) by
      exact this.comp_ofReal
    conv in ‚Üë_ ^ _ => rw [(by ring : r = r + 1 - 1)]
    convert HasDerivAt.cpow_const ?_ ?_ using 1
    ¬∑ rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm
    ¬∑ exact hasDerivAt_id ((-x : ‚Ñù) : ‚ÑÇ)
    ¬∑ simp [hx]"
Mathlib/Analysis/Complex/PhragmenLindelof.lean,PhragmenLindelof.horizontal_strip,horizontal_strip,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm
  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb
  wlog hC‚ÇÄ : 0 < C generalizing C
  ¬∑ refine le_of_forall_le_of_dense fun C' hC' => this (fun w hw => ?_) (fun w hw => ?_) ?_
    ¬∑ exact (hle_a _ hw).trans hC'.le
    ¬∑ exact (hle_b _ hw).trans hC'.le
    ¬∑ refine ((norm_nonneg (f (a * I))).trans (hle_a _ ?_)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=
    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB
  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with ‚ü®c, hc, B, hO‚ü©
  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)
  have hb' : d * b < œÄ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)
  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))
  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C by
    refine le_of_tendsto (Tendsto.mono_left ?_ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ
  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :
    ‚àÉ Œ¥ : ‚Ñù,
      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by
    refine
      ‚ü®Œµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Œµ‚ÇÄ
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),
        fun w hw => ?_‚ü©
    replace hw : |im (aff w)| ‚â§ d * b := by
      rw [‚Üê Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,
        mul_le_mul_left hd‚ÇÄ]
    simpa only [aff, re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le
  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by
    refine fun w hw => (hŒ¥ <| hw.by_cases ?_ ?_).trans (Real.exp_le_one_iff.2 ?_)
    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]
  obtain ‚ü®R, hzR, hR‚ü© :
    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by
    refine ((eventually_gt_atTop _).and ?_).exists
    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,
      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0) by
      filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him
      calc
        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ ‚â§ C := hR
      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine Real.tendsto_exp_atBot.comp ?_
    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine Tendsto.atBot_add ?_ tendsto_const_nhds
      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id
    refine tendsto_const_nhds.add (tendsto_const_nhds.mul ?_)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable ‚ÑÇ (g Œµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono (inter_subset_right _ _)
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw
    by_cases him : w.im = a - b ‚à® w.im = a + b
    ¬∑ rw [norm_smul, ‚Üê one_mul C]
      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b) := hw.resolve_left fun h ‚Ü¶ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'
      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)
  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]
    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©","error:  function expected at
  inter_subset_right ?m.85889
term has type
  ?m.85888 ‚àà ?m.85887","theorem horizontal_strip (hfd : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo a b))
    (hB : ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo a b)]
      fun z ‚Ü¶ expR (B * expR (c * |z.re|)))
    (hle_a : ‚àÄ z : ‚ÑÇ, im z = a ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hle_b : ‚àÄ z, im z = b ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hza : a ‚â§ im z)
    (hzb : im z ‚â§ b) : ‚Äñf z‚Äñ ‚â§ C ",":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm
  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb
  wlog hC‚ÇÄ : 0 < C generalizing C
  ¬∑ refine le_of_forall_le_of_dense fun C' hC' => this (fun w hw => ?_) (fun w hw => ?_) ?_
    ¬∑ exact (hle_a _ hw).trans hC'.le
    ¬∑ exact (hle_b _ hw).trans hC'.le
    ¬∑ refine ((norm_nonneg (f (a * I))).trans (hle_a _ ?_)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=
    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB
  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with ‚ü®c, hc, B, hO‚ü©
  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)
  have hb' : d * b < œÄ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)
  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))
  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C by
    refine le_of_tendsto (Tendsto.mono_left ?_ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ
  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :
    ‚àÉ Œ¥ : ‚Ñù,
      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by
    refine
      ‚ü®Œµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Œµ‚ÇÄ
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),
        fun w hw => ?_‚ü©
    replace hw : |im (aff w)| ‚â§ d * b := by
      rw [‚Üê Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,
        mul_le_mul_left hd‚ÇÄ]
    simpa only [aff, re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le
  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by
    refine fun w hw => (hŒ¥ <| hw.by_cases ?_ ?_).trans (Real.exp_le_one_iff.2 ?_)
    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]
  obtain ‚ü®R, hzR, hR‚ü© :
    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by
    refine ((eventually_gt_atTop _).and ?_).exists
    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,
      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0) by
      filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him
      calc
        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ ‚â§ C := hR
      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine Real.tendsto_exp_atBot.comp ?_
    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine Tendsto.atBot_add ?_ tendsto_const_nhds
      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id
    refine tendsto_const_nhds.add (tendsto_const_nhds.mul ?_)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable ‚ÑÇ (g Œµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono inter_subset_right
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw
    by_cases him : w.im = a - b ‚à® w.im = a + b
    ¬∑ rw [norm_smul, ‚Üê one_mul C]
      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b) := hw.resolve_left fun h ‚Ü¶ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'
      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)
  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]
    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©"
Mathlib/Algebra/Homology/ShortComplex/SnakeLemma.lean,CategoryTheory.ShortComplex.SnakeInput.L‚ÇÅ'_exact,L‚ÇÅ'_exact,464b5661a0356eb905ffcbbb627071d5b3235fe7,":= by
  rw [ShortComplex.exact_iff_exact_up_to_refinements]
  intro A‚ÇÄ x‚ÇÉ hx‚ÇÉ
  dsimp at x‚ÇÉ hx‚ÇÉ
  obtain ‚ü®A‚ÇÅ, œÄ‚ÇÅ, hœÄ‚ÇÅ, p, hp‚ü© := surjective_up_to_refinements_of_epi S.L‚ÇÄ'.g x‚ÇÉ
  dsimp [L‚ÇÄ'] at p hp
  have hp' : (p ‚â´ S.œÜ‚ÇÅ) ‚â´ S.v‚ÇÇ‚ÇÉ.œÑ‚ÇÅ = 0 := by
    rw [assoc, ‚Üê S.snd_Œ¥, ‚Üê reassoc_of% hp, hx‚ÇÉ, comp_zero]
  obtain ‚ü®A‚ÇÇ, œÄ‚ÇÇ, hœÄ‚ÇÇ, x‚ÇÅ, hx‚ÇÅ‚ü© := S.exact_C‚ÇÅ_down.exact_up_to_refinements (p ‚â´ S.œÜ‚ÇÅ) hp'
  dsimp at x‚ÇÅ hx‚ÇÅ
  let x‚ÇÇ' := x‚ÇÅ ‚â´ S.L‚ÇÅ.f
  let x‚ÇÇ := œÄ‚ÇÇ ‚â´ p ‚â´ pullback.fst
  have hx‚ÇÇ' : (x‚ÇÇ - x‚ÇÇ') ‚â´ S.v‚ÇÅ‚ÇÇ.œÑ‚ÇÇ = 0 := by
    simp only [sub_comp, assoc, ‚Üê S.v‚ÇÅ‚ÇÇ.comm‚ÇÅ‚ÇÇ, ‚Üê reassoc_of% hx‚ÇÅ, œÜ‚ÇÇ, œÜ‚ÇÅ_L‚ÇÇ_f, sub_self]
  let k‚ÇÇ : A‚ÇÇ ‚ü∂ S.L‚ÇÄ.X‚ÇÇ := S.exact_C‚ÇÇ_up.lift _ hx‚ÇÇ'
  have hk‚ÇÇ : k‚ÇÇ ‚â´ S.v‚ÇÄ‚ÇÅ.œÑ‚ÇÇ = x‚ÇÇ - x‚ÇÇ' := S.exact_C‚ÇÇ_up.lift_f _ _
  have hk‚ÇÇ' : k‚ÇÇ ‚â´ S.L‚ÇÄ.g = œÄ‚ÇÇ ‚â´ p ‚â´ pullback.snd := by
    simp only [‚Üê cancel_mono S.v‚ÇÄ‚ÇÅ.œÑ‚ÇÉ, assoc, ‚Üê S.v‚ÇÄ‚ÇÅ.comm‚ÇÇ‚ÇÉ, reassoc_of% hk‚ÇÇ,
      sub_comp, S.L‚ÇÅ.zero, comp_zero, sub_zero, pullback.condition]
  exact ‚ü®A‚ÇÇ, œÄ‚ÇÇ ‚â´ œÄ‚ÇÅ, epi_comp _ _, k‚ÇÇ, by simp only [assoc, L‚ÇÅ'_f, ‚Üê hk‚ÇÇ', hp]‚ü©","error:  unsolved goals
C : Type u_1
inst‚úù¬π : Category.{u_2, u_1} C
inst‚úù : Abelian C
S : SnakeInput C
A‚ÇÄ : C
x‚ÇÉ : A‚ÇÄ ‚ü∂ S.L‚ÇÄ.X‚ÇÉ
hx‚ÇÉ : x‚ÇÉ ‚â´ S.Œ¥ = 0
A‚ÇÅ : C
œÄ‚ÇÅ : A‚ÇÅ ‚ü∂ A‚ÇÄ
hœÄ‚ÇÅ : Epi œÄ‚ÇÅ
p : A‚ÇÅ ‚ü∂ S.P
hp : œÄ‚ÇÅ ‚â´ x‚ÇÉ = p ‚â´ pullback.snd
hp' : (p ‚â´ S.œÜ‚ÇÅ) ‚â´ S.v‚ÇÇ‚ÇÉ.œÑ‚ÇÅ = 0
A‚ÇÇ : C
œÄ‚ÇÇ : A‚ÇÇ ‚ü∂ A‚ÇÅ
hœÄ‚ÇÇ : Epi œÄ‚ÇÇ
x‚ÇÅ : A‚ÇÇ ‚ü∂ S.L‚ÇÅ.X‚ÇÅ
hx‚ÇÅ : œÄ‚ÇÇ ‚â´ p ‚â´ S.œÜ‚ÇÅ = x‚ÇÅ ‚â´ S.v‚ÇÅ‚ÇÇ.œÑ‚ÇÅ
x‚ÇÇ' : A‚ÇÇ ‚ü∂ S.L‚ÇÅ.X‚ÇÇ := x‚ÇÅ ‚â´ S.L‚ÇÅ.f
x‚ÇÇ : A‚ÇÇ ‚ü∂ S.L‚ÇÅ.X‚ÇÇ := œÄ‚ÇÇ ‚â´ p ‚â´ pullback.fst
‚ä¢ x‚ÇÇ ‚â´ S.v‚ÇÅ‚ÇÇ.œÑ‚ÇÇ - x‚ÇÇ' ‚â´ S.v‚ÇÅ‚ÇÇ.œÑ‚ÇÇ = 0
error:  unsolved goals
C : Type u_1
inst‚úù¬π : Category.{u_2, u_1} C
inst‚úù : Abelian C
S : SnakeInput C
A‚ÇÄ : C
x‚ÇÉ : A‚ÇÄ ‚ü∂ S.L‚ÇÄ.X‚ÇÉ
hx‚ÇÉ : x‚ÇÉ ‚â´ S.Œ¥ = 0
A‚ÇÅ : C
œÄ‚ÇÅ : A‚ÇÅ ‚ü∂ A‚ÇÄ
hœÄ‚ÇÅ : Epi œÄ‚ÇÅ
p : A‚ÇÅ ‚ü∂ S.P
hp : œÄ‚ÇÅ ‚â´ x‚ÇÉ = p ‚â´ pullback.snd
hp' : (p ‚â´ S.œÜ‚ÇÅ) ‚â´ S.v‚ÇÇ‚ÇÉ.œÑ‚ÇÅ = 0
A‚ÇÇ : C
œÄ‚ÇÇ : A‚ÇÇ ‚ü∂ A‚ÇÅ
hœÄ‚ÇÇ : Epi œÄ‚ÇÇ
x‚ÇÅ : A‚ÇÇ ‚ü∂ S.L‚ÇÅ.X‚ÇÅ
hx‚ÇÅ : œÄ‚ÇÇ ‚â´ p ‚â´ S.œÜ‚ÇÅ = x‚ÇÅ ‚â´ S.v‚ÇÅ‚ÇÇ.œÑ‚ÇÅ
x‚ÇÇ' : A‚ÇÇ ‚ü∂ S.L‚ÇÅ.X‚ÇÇ := x‚ÇÅ ‚â´ S.L‚ÇÅ.f
x‚ÇÇ : A‚ÇÇ ‚ü∂ S.L‚ÇÅ.X‚ÇÇ := œÄ‚ÇÇ ‚â´ p ‚â´ pullback.fst
hx‚ÇÇ' : (x‚ÇÇ - x‚ÇÇ') ‚â´ S.v‚ÇÅ‚ÇÇ.œÑ‚ÇÇ = 0
k‚ÇÇ : A‚ÇÇ ‚ü∂ S.L‚ÇÄ.X‚ÇÇ := ‚ãØ.lift (x‚ÇÇ - x‚ÇÇ') hx‚ÇÇ'
hk‚ÇÇ : k‚ÇÇ ‚â´ S.v‚ÇÄ‚ÇÅ.œÑ‚ÇÇ = x‚ÇÇ - x‚ÇÇ'
‚ä¢ x‚ÇÇ ‚â´ S.L‚ÇÅ.g - x‚ÇÇ' ‚â´ S.L‚ÇÅ.g = œÄ‚ÇÇ ‚â´ p ‚â´ pullback.snd ‚â´ S.v‚ÇÄ‚ÇÅ.œÑ‚ÇÉ",lemma L‚ÇÅ'_exact : S.L‚ÇÅ'.Exact ,":= by
  rw [ShortComplex.exact_iff_exact_up_to_refinements]
  intro A‚ÇÄ x‚ÇÉ hx‚ÇÉ
  dsimp at x‚ÇÉ hx‚ÇÉ
  obtain ‚ü®A‚ÇÅ, œÄ‚ÇÅ, hœÄ‚ÇÅ, p, hp‚ü© := surjective_up_to_refinements_of_epi S.L‚ÇÄ'.g x‚ÇÉ
  dsimp [L‚ÇÄ'] at p hp
  have hp' : (p ‚â´ S.œÜ‚ÇÅ) ‚â´ S.v‚ÇÇ‚ÇÉ.œÑ‚ÇÅ = 0 := by
    rw [assoc, ‚Üê S.snd_Œ¥, ‚Üê reassoc_of% hp, hx‚ÇÉ, comp_zero]
  obtain ‚ü®A‚ÇÇ, œÄ‚ÇÇ, hœÄ‚ÇÇ, x‚ÇÅ, hx‚ÇÅ‚ü© := S.exact_C‚ÇÅ_down.exact_up_to_refinements (p ‚â´ S.œÜ‚ÇÅ) hp'
  dsimp at x‚ÇÅ hx‚ÇÅ
  let x‚ÇÇ' := x‚ÇÅ ‚â´ S.L‚ÇÅ.f
  let x‚ÇÇ := œÄ‚ÇÇ ‚â´ p ‚â´ pullback.fst
  have hx‚ÇÇ' : (x‚ÇÇ - x‚ÇÇ') ‚â´ S.v‚ÇÅ‚ÇÇ.œÑ‚ÇÇ = 0 := by
    simp only [x‚ÇÇ, x‚ÇÇ', sub_comp, assoc, ‚Üê S.v‚ÇÅ‚ÇÇ.comm‚ÇÅ‚ÇÇ, ‚Üê reassoc_of% hx‚ÇÅ, œÜ‚ÇÇ, œÜ‚ÇÅ_L‚ÇÇ_f, sub_self]
  let k‚ÇÇ : A‚ÇÇ ‚ü∂ S.L‚ÇÄ.X‚ÇÇ := S.exact_C‚ÇÇ_up.lift _ hx‚ÇÇ'
  have hk‚ÇÇ : k‚ÇÇ ‚â´ S.v‚ÇÄ‚ÇÅ.œÑ‚ÇÇ = x‚ÇÇ - x‚ÇÇ' := S.exact_C‚ÇÇ_up.lift_f _ _
  have hk‚ÇÇ' : k‚ÇÇ ‚â´ S.L‚ÇÄ.g = œÄ‚ÇÇ ‚â´ p ‚â´ pullback.snd := by
    simp only [x‚ÇÇ, x‚ÇÇ', ‚Üê cancel_mono S.v‚ÇÄ‚ÇÅ.œÑ‚ÇÉ, assoc, ‚Üê S.v‚ÇÄ‚ÇÅ.comm‚ÇÇ‚ÇÉ, reassoc_of% hk‚ÇÇ,
      sub_comp, S.L‚ÇÅ.zero, comp_zero, sub_zero, pullback.condition]
  exact ‚ü®A‚ÇÇ, œÄ‚ÇÇ ‚â´ œÄ‚ÇÅ, epi_comp _ _, k‚ÇÇ, by simp only [assoc, L‚ÇÅ'_f, ‚Üê hk‚ÇÇ', hp]‚ü©"
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.getD_leftInvSeq_mul_wordProd,getD_leftInvSeq_mul_wordProd,c12b2329e96636454fe77263b4a01b2265276ae9,":= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [‚Üê take_append_drop (j + 1) œâ]
  rw [take_succ]
  rcases em (j < œâ.length) with hj | nhj
  ¬∑ rw [get?_eq_get hj]
    simp [wordProd_append, wordProd_cons, mul_assoc]
  ¬∑ rw [get?_eq_none.mpr (by linarith)]
    simp","error:  unsolved goals
case inl
B : Type u_1
W : Type u_2
inst‚úù : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
œâ : List B
j : ‚Ñï
hj : j < œâ.length
‚ä¢ cs.simple œâ[j] * (cs.wordProd œâ[j]?.toList * cs.wordProd (drop (j + 1) œâ)) = cs.wordProd (drop (j + 1) œâ)
error:  unsolved goals
case inr
B : Type u_1
W : Type u_2
inst‚úù : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
œâ : List B
j : ‚Ñï
nhj : ¬¨j < œâ.length
‚ä¢ cs.wordProd (take j œâ ++ (œâ[j]?.toList ++ drop (j + 1) œâ)) = cs.wordProd (take j œâ ++ drop (j + 1) œâ)","theorem getD_leftInvSeq_mul_wordProd (œâ : List B) (j : ‚Ñï) :
    ((lis œâ).getD j 1) * œÄ œâ = œÄ (œâ.eraseIdx j) ",":= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [‚Üê take_append_drop (j + 1) œâ]
  rw [take_succ]
  obtain lt | le := lt_or_le j œâ.length
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]
    simp
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_none le]
    simp"
Mathlib/Data/Nat/Size.lean,Nat.size_bit,size_bit,5e6cc2996d8d96efe2a2db4359ae5e33c77fb5c3,":= by
  rw [size]
  conv =>
    lhs
    rw [binaryRec]
    simp [h]","warning:  `bit1` has been deprecated
error:  unsolved goals
b : Bool
n : ‚Ñï
h : bit b n ‚â† 0
‚ä¢ binaryRec 0 (fun x x ‚Ü¶ succ) (bit b n).div2 + 1 = (binaryRec 0 (fun x x ‚Ü¶ succ) n).succ
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated",theorem size_bit {b n} (h : bit b n ‚â† 0) : size (bit b n) = succ (size n) ,":= by
  rw [size]
  conv =>
    lhs
    rw [binaryRec]
    simp [h]
  rw [div2_bit]"
Mathlib/RingTheory/DedekindDomain/Different.lean,map_equiv_traceDual,map_equiv_traceDual,74a0c2a66f7ae56503022c9c00196e7cd32751a7,":= by
  show Submodule.map (FractionRing.algEquiv B L).toLinearEquiv.toLinearMap _ =
    traceDual A K (I.map (FractionRing.algEquiv B L).toLinearEquiv.toLinearMap)
  rw [Submodule.map_equiv_eq_comap_symm, Submodule.map_equiv_eq_comap_symm]
  ext x
  simp only [AlgEquiv.toLinearEquiv_symm, AlgEquiv.toLinearEquiv_toLinearMap,
    traceDual, traceForm_apply, Submodule.mem_comap, AlgEquiv.toLinearMap_apply,
    Submodule.mem_mk, AddSubmonoid.mem_mk, AddSubsemigroup.mem_mk, Set.mem_setOf_eq]
  apply (FractionRing.algEquiv B L).forall_congr
  simp only [restrictScalars_mem, traceForm_apply, AlgEquiv.toEquiv_eq_coe,
    EquivLike.coe_coe, mem_comap, AlgEquiv.toLinearMap_apply, AlgEquiv.symm_apply_apply]
  refine fun {y} ‚Ü¶ (forall_congr' fun hy ‚Ü¶ ?_)
  rw [LinearMap.toBilin_apply, traceForm_apply, mem_one,
    Algebra.trace_eq_of_equiv_equiv (FractionRing.algEquiv A K).toRingEquiv
    (FractionRing.algEquiv B L).toRingEquiv]
  swap
  ¬∑ apply IsLocalization.ringHom_ext (M := A‚Å∞); ext
    simp only [AlgEquiv.toRingEquiv_eq_coe, AlgEquiv.toRingEquiv_toRingHom, RingHom.coe_comp,
      RingHom.coe_coe, Function.comp_apply, AlgEquiv.commutes, ‚Üê IsScalarTower.algebraMap_apply]
    rw [IsScalarTower.algebraMap_apply A B (FractionRing B), AlgEquiv.commutes,
      ‚Üê IsScalarTower.algebraMap_apply]
  simp only [AlgEquiv.toRingEquiv_eq_coe, _root_.map_mul, AlgEquiv.coe_ringEquiv,
    AlgEquiv.apply_symm_apply]
  show (FractionRing.algEquiv A K).symm _ ‚àà (algebraMap A (FractionRing A)).range ‚Üî _
  rw [‚Üê (FractionRing.algEquiv A K).symm.toAlgHom.comp_algebraMap, ‚Üê RingHom.map_range,
    AlgEquiv.toAlgHom_eq_coe, AlgEquiv.coe_ringHom_commutes, Subring.mem_map_equiv]
  simp","warning:  `LinearMap.toBilin_apply` has been deprecated
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ((LinearMap.toBilin ?f) ?x) ?y
case h
A : Type u_1
K : Type u_2
L : Type u
B : Type u_3
inst‚úù¬π‚Åπ : CommRing A
inst‚úù¬π‚Å∏ : Field K
inst‚úù¬π‚Å∑ : CommRing B
inst‚úù¬π‚Å∂ : Field L
inst‚úù¬π‚Åµ : Algebra A K
inst‚úù¬π‚Å¥ : Algebra B L
inst‚úù¬π¬≥ : Algebra A B
inst‚úù¬π¬≤ : Algebra K L
inst‚úù¬π¬π : Algebra A L
inst‚úù¬π‚Å∞ : IsScalarTower A K L
inst‚úù‚Åπ : IsScalarTower A B L
inst‚úù‚Å∏ : IsDomain A
inst‚úù‚Å∑ : IsDomain B
inst‚úù‚Å∂ : IsFractionRing A K
inst‚úù‚Åµ : IsIntegralClosure B A L
inst‚úù‚Å¥ : IsFractionRing B L
inst‚úù¬≥ : FiniteDimensional K L
inst‚úù¬≤ : IsSeparable K L
inst‚úù¬π : IsIntegrallyClosed A
inst‚úù : NoZeroSMulDivisors A B
I : Submodule B (FractionRing B)
x : L
y : FractionRing B
hy : y ‚àà I
‚ä¢ (Algebra.trace (FractionRing A) (FractionRing B)) ((FractionRing.algEquiv B L).symm x * y) ‚àà 1 ‚Üî
    (Algebra.trace K L) (x * (FractionRing.algEquiv B L) y) ‚àà 1","lemma map_equiv_traceDual [NoZeroSMulDivisors A B] (I : Submodule B (FractionRing B)) :
    (traceDual A (FractionRing A) I).map (FractionRing.algEquiv B L) =
      traceDual A K (I.map (FractionRing.algEquiv B L)) ",":= by
  show Submodule.map (FractionRing.algEquiv B L).toLinearEquiv.toLinearMap _ =
    traceDual A K (I.map (FractionRing.algEquiv B L).toLinearEquiv.toLinearMap)
  rw [Submodule.map_equiv_eq_comap_symm, Submodule.map_equiv_eq_comap_symm]
  ext x
  simp only [AlgEquiv.toLinearEquiv_symm, AlgEquiv.toLinearEquiv_toLinearMap,
    traceDual, traceForm_apply, Submodule.mem_comap, AlgEquiv.toLinearMap_apply,
    Submodule.mem_mk, AddSubmonoid.mem_mk, AddSubsemigroup.mem_mk, Set.mem_setOf_eq]
  apply (FractionRing.algEquiv B L).forall_congr
  simp only [restrictScalars_mem, traceForm_apply, AlgEquiv.toEquiv_eq_coe,
    EquivLike.coe_coe, mem_comap, AlgEquiv.toLinearMap_apply, AlgEquiv.symm_apply_apply]
  refine fun {y} ‚Ü¶ (forall_congr' fun hy ‚Ü¶ ?_)
  rw [Algebra.trace_eq_of_equiv_equiv (FractionRing.algEquiv A K).toRingEquiv
    (FractionRing.algEquiv B L).toRingEquiv]
  swap
  ¬∑ apply IsLocalization.ringHom_ext (M := A‚Å∞); ext
    simp only [AlgEquiv.toRingEquiv_eq_coe, AlgEquiv.toRingEquiv_toRingHom, RingHom.coe_comp,
      RingHom.coe_coe, Function.comp_apply, AlgEquiv.commutes, ‚Üê IsScalarTower.algebraMap_apply]
    rw [IsScalarTower.algebraMap_apply A B (FractionRing B), AlgEquiv.commutes,
      ‚Üê IsScalarTower.algebraMap_apply]
  simp only [AlgEquiv.toRingEquiv_eq_coe, _root_.map_mul, AlgEquiv.coe_ringEquiv,
    AlgEquiv.apply_symm_apply, ‚Üê AlgEquiv.symm_toRingEquiv, mem_one, AlgEquiv.algebraMap_eq_apply]"
Mathlib/Analysis/Normed/Group/ControlledClosure.lean,controlled_closure_of_complete,controlled_closure_of_complete,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  rintro (h : H) (h_in : h ‚àà K.topologicalClosure)
  by_cases hyp_h : h = 0
  ¬∑ rw [hyp_h]
    use 0
    simp
  set b : ‚Ñï ‚Üí ‚Ñù := fun i => (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
  have b_pos : ‚àÄ i, 0 < b i := by
    intro i
    field_simp [hC]
    exact
      div_pos (mul_pos hŒµ (norm_pos_iff.mpr hyp_h)) (mul_pos (by norm_num : (0 : ‚Ñù) < 2 ^ i * 2) hC)
  obtain
    ‚ü®v : ‚Ñï ‚Üí H, lim_v : Tendsto (fun n : ‚Ñï => ‚àë k in range (n + 1), v k) atTop (ùìù h), v_in :
      ‚àÄ n, v n ‚àà K, hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0, hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n‚ü© :=
    controlled_sum_of_mem_closure h_in b_pos
  have : ‚àÄ n, ‚àÉ m' : G, f m' = v n ‚àß ‚Äñm'‚Äñ ‚â§ C * ‚Äñv n‚Äñ := fun n : ‚Ñï => hyp (v n) (v_in n)
  choose u hu hnorm_u using this
  set s : ‚Ñï ‚Üí G := fun n => ‚àë k in range (n + 1), u k
  have : CauchySeq s := by
    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one
    rintro n (hn : n ‚â• 1)
    calc
      ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ := hnorm_u n
      _ ‚â§ C * b n := by gcongr; exact (hv _ <| Nat.succ_le_iff.mp hn).le
      _ = (1 / 2) ^ n * (Œµ * ‚Äñh‚Äñ / 2) := by simp [mul_div_cancel' _ hC.ne.symm]
      _ = Œµ * ‚Äñh‚Äñ / 2 * (1 / 2) ^ n := mul_comm _ _
  obtain ‚ü®g : G, hg‚ü© := cauchySeq_tendsto_of_complete this
  refine' ‚ü®g, _, _‚ü©
  ¬∑ 
    have : f ‚àò s = fun n => ‚àë k in range (n + 1), v k := by
      ext n
      simp [map_sum, hu]
    rw [‚Üê this] at lim_v
    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v
  ¬∑ 
    suffices ‚àÄ n, ‚Äñs n‚Äñ ‚â§ (C + Œµ) * ‚Äñh‚Äñ from
      le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this
    intro n
    have hnorm‚ÇÄ : ‚Äñu 0‚Äñ ‚â§ C * b 0 + C * ‚Äñh‚Äñ := by
      have :=
        calc
          ‚Äñv 0‚Äñ ‚â§ ‚Äñh‚Äñ + ‚Äñv 0 - h‚Äñ := norm_le_insert' _ _
          _ ‚â§ ‚Äñh‚Äñ + b 0 := by gcongr
      calc
        ‚Äñu 0‚Äñ ‚â§ C * ‚Äñv 0‚Äñ := hnorm_u 0
        _ ‚â§ C * (‚Äñh‚Äñ + b 0) := by gcongr
        _ = C * b 0 + C * ‚Äñh‚Äñ := by rw [add_comm, mul_add]
    have : (‚àë k in range (n + 1), C * b k) ‚â§ Œµ * ‚Äñh‚Äñ :=
      calc
        (‚àë k in range (n + 1), C * b k) = (‚àë k in range (n + 1), (1 / 2 : ‚Ñù) ^ k) * (Œµ * ‚Äñh‚Äñ / 2) :=
          by simp only [mul_div_cancel' _ hC.ne.symm, ‚Üê sum_mul]
        _ ‚â§ 2 * (Œµ * ‚Äñh‚Äñ / 2) := by gcongr; apply sum_geometric_two_le
        _ = Œµ * ‚Äñh‚Äñ := mul_div_cancel' _ two_ne_zero
    calc
      ‚Äñs n‚Äñ ‚â§ ‚àë k in range (n + 1), ‚Äñu k‚Äñ := norm_sum_le _ _
      _ = (‚àë k in range n, ‚Äñu (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := (sum_range_succ' _ _)
      _ ‚â§ (‚àë k in range n, C * ‚Äñv (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := by gcongr; apply hnorm_u
      _ ‚â§ (‚àë k in range n, C * b (k + 1)) + (C * b 0 + C * ‚Äñh‚Äñ) := by
        gcongr with k; exact (hv _ k.succ_pos).le
      _ = (‚àë k in range (n + 1), C * b k) + C * ‚Äñh‚Äñ := by rw [‚Üê add_assoc, sum_range_succ']
      _ ‚â§ (C + Œµ) * ‚Äñh‚Äñ := by
        rw [add_comm, add_mul]
        apply add_le_add_left this","error:  simp made no progress
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancel‚ÇÄ` instead
error:  unsolved goals
case h
G : Type u_1
inst‚úù¬≤ : NormedAddCommGroup G
inst‚úù¬π : CompleteSpace G
H : Type u_2
inst‚úù : NormedAddCommGroup H
f : NormedAddGroupHom G H
K : AddSubgroup H
C Œµ : ‚Ñù
hC : 0 < C
hŒµ : 0 < Œµ
hyp : f.SurjectiveOnWith K C
h : H
h_in : h ‚àà K.topologicalClosure
hyp_h : ¬¨h = 0
b : ‚Ñï ‚Üí ‚Ñù := fun i ‚Ü¶ (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
b_pos : ‚àÄ (i : ‚Ñï), 0 < b i
v : ‚Ñï ‚Üí H
lim_v : Tendsto (fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h)
v_in : ‚àÄ (n : ‚Ñï), v n ‚àà K
hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0
hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n
u : ‚Ñï ‚Üí G
hu : ‚àÄ (n : ‚Ñï), f (u n) = v n
hnorm_u : ‚àÄ (n : ‚Ñï), ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ
s : ‚Ñï ‚Üí G := fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), u k
this : CauchySeq s
g : G
hg : Tendsto s atTop (ùìù g)
n : ‚Ñï
‚ä¢ f (s n) = ‚àë k ‚àà range (n + 1), v k
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancel‚ÇÄ` instead
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancel‚ÇÄ` instead","theorem controlled_closure_of_complete {f : NormedAddGroupHom G H} {K : AddSubgroup H} {C Œµ : ‚Ñù}
    (hC : 0 < C) (hŒµ : 0 < Œµ) (hyp : f.SurjectiveOnWith K C) :
    f.SurjectiveOnWith K.topologicalClosure (C + Œµ) ",":= by
  rintro (h : H) (h_in : h ‚àà K.topologicalClosure)
  by_cases hyp_h : h = 0
  ¬∑ rw [hyp_h]
    use 0
    simp
  set b : ‚Ñï ‚Üí ‚Ñù := fun i => (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
  have b_pos (i) : 0 < b i := by field_simp [b, hC, hyp_h]
  obtain
    ‚ü®v : ‚Ñï ‚Üí H, lim_v : Tendsto (fun n : ‚Ñï => ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h), v_in :
      ‚àÄ n, v n ‚àà K, hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0, hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n‚ü© :=
    controlled_sum_of_mem_closure h_in b_pos
  have : ‚àÄ n, ‚àÉ m' : G, f m' = v n ‚àß ‚Äñm'‚Äñ ‚â§ C * ‚Äñv n‚Äñ := fun n : ‚Ñï => hyp (v n) (v_in n)
  choose u hu hnorm_u using this
  set s : ‚Ñï ‚Üí G := fun n => ‚àë k ‚àà range (n + 1), u k
  have : CauchySeq s := by
    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one
    ¬∑ rintro n (hn : n ‚â• 1)
      calc
        ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ := hnorm_u n
        _ ‚â§ C * b n := by gcongr; exact (hv _ <| Nat.succ_le_iff.mp hn).le
        _ = (1 / 2) ^ n * (Œµ * ‚Äñh‚Äñ / 2) := by simp [mul_div_cancel‚ÇÄ _ hC.ne.symm]
        _ = Œµ * ‚Äñh‚Äñ / 2 * (1 / 2) ^ n := mul_comm _ _
  obtain ‚ü®g : G, hg‚ü© := cauchySeq_tendsto_of_complete this
  refine ‚ü®g, ?_, ?_‚ü©
  ¬∑ 
    have : f ‚àò s = fun n => ‚àë k ‚àà range (n + 1), v k := by
      ext n
      simp [s, map_sum, hu]
    rw [‚Üê this] at lim_v
    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v
  ¬∑ 
    suffices ‚àÄ n, ‚Äñs n‚Äñ ‚â§ (C + Œµ) * ‚Äñh‚Äñ from
      le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this
    intro n
    have hnorm‚ÇÄ : ‚Äñu 0‚Äñ ‚â§ C * b 0 + C * ‚Äñh‚Äñ := by
      have :=
        calc
          ‚Äñv 0‚Äñ ‚â§ ‚Äñh‚Äñ + ‚Äñv 0 - h‚Äñ := norm_le_insert' _ _
          _ ‚â§ ‚Äñh‚Äñ + b 0 := by gcongr
      calc
        ‚Äñu 0‚Äñ ‚â§ C * ‚Äñv 0‚Äñ := hnorm_u 0
        _ ‚â§ C * (‚Äñh‚Äñ + b 0) := by gcongr
        _ = C * b 0 + C * ‚Äñh‚Äñ := by rw [add_comm, mul_add]
    have : (‚àë k ‚àà range (n + 1), C * b k) ‚â§ Œµ * ‚Äñh‚Äñ :=
      calc (‚àë k ‚àà range (n + 1), C * b k)
        _ = (‚àë k ‚àà range (n + 1), (1 / 2 : ‚Ñù) ^ k) * (Œµ * ‚Äñh‚Äñ / 2) := by
          simp only [mul_div_cancel‚ÇÄ _ hC.ne.symm, ‚Üê sum_mul]
        _ ‚â§ 2 * (Œµ * ‚Äñh‚Äñ / 2) := by gcongr; apply sum_geometric_two_le
        _ = Œµ * ‚Äñh‚Äñ := mul_div_cancel‚ÇÄ _ two_ne_zero
    calc
      ‚Äñs n‚Äñ ‚â§ ‚àë k ‚àà range (n + 1), ‚Äñu k‚Äñ := norm_sum_le _ _
      _ = (‚àë k ‚àà range n, ‚Äñu (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := sum_range_succ' _ _
      _ ‚â§ (‚àë k ‚àà range n, C * ‚Äñv (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := by gcongr; apply hnorm_u
      _ ‚â§ (‚àë k ‚àà range n, C * b (k + 1)) + (C * b 0 + C * ‚Äñh‚Äñ) := by
        gcongr with k; exact (hv _ k.succ_pos).le
      _ = (‚àë k ‚àà range (n + 1), C * b k) + C * ‚Äñh‚Äñ := by rw [‚Üê add_assoc, sum_range_succ']
      _ ‚â§ (C + Œµ) * ‚Äñh‚Äñ := by
        rw [add_comm, add_mul]
        apply add_le_add_left this"
Mathlib/GroupTheory/NoncommPiCoprod.lean,Subgroup.eq_one_of_noncommProd_eq_one_of_independent,eq_one_of_noncommProd_eq_one_of_independent,c959b2f950b9c44268e36bcedef976356855e6fb,":= by
  classical
    revert heq1
    induction' s with i s hnmem ih
    ¬∑ simp
    ¬∑ have hcomm := comm.mono (Finset.coe_subset.2 <| Finset.subset_insert _ _)
      simp only [Finset.forall_mem_insert] at hmem
      have hmem_bsupr : s.noncommProd f hcomm ‚àà ‚®Ü i ‚àà (s : Set Œπ), K i := by
        refine Subgroup.noncommProd_mem _ _ ?_
        intro x hx
        have : K x ‚â§ ‚®Ü i ‚àà (s : Set Œπ), K i := le_iSup‚ÇÇ (f := fun i _ => K i) x hx
        exact this (hmem.2 x hx)
      intro heq1
      rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hnmem] at heq1
      have hnmem' : i ‚àâ (s : Set Œπ) := by simpa
      obtain ‚ü®heq1i : f i = 1, heq1S : s.noncommProd f _ = 1‚ü© :=
        Subgroup.disjoint_iff_mul_eq_one.mp (hind.disjoint_biSup hnmem') hmem.1 hmem_bsupr heq1
      intro i h
      simp only [Finset.mem_insert] at h
      rcases h with (rfl | h)
      ¬∑ exact heq1i
      ¬∑ refine ih hcomm hmem.2 heq1S _ h","error:  unsolved goals
case mk
G : Type u_1
inst‚úù : Group G
Œπ : Type u_2
f : Œπ ‚Üí G
K : Œπ ‚Üí Subgroup G
hind : CompleteLattice.Independent K
i : Multiset Œπ
s : i.Nodup
comm : (‚Üë{ val := i, nodup := s }).Pairwise fun a b ‚Ü¶ Commute (f a) (f b)
hmem : ‚àÄ x ‚àà { val := i, nodup := s }, f x ‚àà K x
‚ä¢ { val := i, nodup := s }.noncommProd f comm = 1 ‚Üí ‚àÄ i_1 ‚àà i, f i_1 = 1
error:  no goals to be solved","theorem eq_one_of_noncommProd_eq_one_of_independent {Œπ : Type*} (s : Finset Œπ) (f : Œπ ‚Üí G) (comm)
    (K : Œπ ‚Üí Subgroup G) (hind : CompleteLattice.Independent K) (hmem : ‚àÄ x ‚àà s, f x ‚àà K x)
    (heq1 : s.noncommProd f comm = 1) : ‚àÄ i ‚àà s, f i = 1 ",":= by
  classical
    revert heq1
    induction' s using Finset.induction_on with i s hnmem ih
    ¬∑ simp
    ¬∑ have hcomm := comm.mono (Finset.coe_subset.2 <| Finset.subset_insert _ _)
      simp only [Finset.forall_mem_insert] at hmem
      have hmem_bsupr : s.noncommProd f hcomm ‚àà ‚®Ü i ‚àà (s : Set Œπ), K i := by
        refine Subgroup.noncommProd_mem _ _ ?_
        intro x hx
        have : K x ‚â§ ‚®Ü i ‚àà (s : Set Œπ), K i := le_iSup‚ÇÇ (f := fun i _ => K i) x hx
        exact this (hmem.2 x hx)
      intro heq1
      rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hnmem] at heq1
      have hnmem' : i ‚àâ (s : Set Œπ) := by simpa
      obtain ‚ü®heq1i : f i = 1, heq1S : s.noncommProd f _ = 1‚ü© :=
        Subgroup.disjoint_iff_mul_eq_one.mp (hind.disjoint_biSup hnmem') hmem.1 hmem_bsupr heq1
      intro i h
      simp only [Finset.mem_insert] at h
      rcases h with (rfl | h)
      ¬∑ exact heq1i
      ¬∑ refine ih hcomm hmem.2 heq1S _ h"
Mathlib/MeasureTheory/Function/LocallyIntegrable.lean,MeasureTheory.locallyIntegrableOn_iff,locallyIntegrableOn_iff,b0906f1a9f950f5731cad2defb88e9843a7e3fc9,":= by
  refine' ‚ü®fun hf k hk => hf.integrableOn_compact_subset hk, fun hf x hx => _‚ü©
  cases hs with
  | inl hs =>
    exact
      let ‚ü®K, hK, h2K‚ü© := exists_compact_mem_nhds x
      ‚ü®_, inter_mem_nhdsWithin s h2K,
        hf _ (inter_subset_left _ _)
          (hK.of_isClosed_subset (hs.inter hK.isClosed) (inter_subset_right _ _))‚ü©
  | inr hs =>
    obtain ‚ü®K, hK, h2K, h3K‚ü© := exists_compact_subset hs hx
    refine' ‚ü®K, _, hf K h3K hK‚ü©
    simpa only [IsOpen.nhdsWithin_eq hs hx, interior_eq_nhds'] using h2K","error:  function expected at
  inter_subset_left ?m.10496
term has type
  ?m.10495 ‚àà ?m.10493
error:  function expected at
  inter_subset_right ?m.10593
term has type
  ?m.10592 ‚àà ?m.10591","theorem locallyIntegrableOn_iff [LocallyCompactSpace X] [T2Space X] (hs : IsClosed s ‚à® IsOpen s) :
    LocallyIntegrableOn f s Œº ‚Üî ‚àÄ (k : Set X), k ‚äÜ s ‚Üí (IsCompact k ‚Üí IntegrableOn f k Œº) ",":= by
  refine ‚ü®fun hf k hk => hf.integrableOn_compact_subset hk, fun hf x hx => ?_‚ü©
  cases hs with
  | inl hs =>
    exact
      let ‚ü®K, hK, h2K‚ü© := exists_compact_mem_nhds x
      ‚ü®_, inter_mem_nhdsWithin s h2K,
        hf _ inter_subset_left
          (hK.of_isClosed_subset (hs.inter hK.isClosed) inter_subset_right)‚ü©
  | inr hs =>
    obtain ‚ü®K, hK, h2K, h3K‚ü© := exists_compact_subset hs hx
    refine ‚ü®K, ?_, hf K h3K hK‚ü©
    simpa only [IsOpen.nhdsWithin_eq hs hx, interior_eq_nhds'] using h2K"
Mathlib/Algebra/Lie/Weights/Chain.lean,LieModule.exists_forall_mem_corootSpace_smul_add_eq_zero,exists_forall_mem_corootSpace_smul_add_eq_zero,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain ‚ü®p, hp‚ÇÄ, q, hq‚ÇÄ, hp, hq‚ü© := exists‚ÇÇ_weightSpace_smul_add_eq_bot M Œ± œá hŒ±
  let a := ‚àë i in Finset.Ioo p q, finrank R (weightSpace M (i ‚Ä¢ Œ± + œá)) ‚Ä¢ i
  let b := ‚àë i in Finset.Ioo p q, finrank R (weightSpace M (i ‚Ä¢ Œ± + œá))
  have hb : 0 < b := by
    replace hœá : Nontrivial (weightSpace M œá) := by rwa [LieSubmodule.nontrivial_iff_ne_bot]
    refine Finset.sum_pos' (fun _ _ ‚Ü¶ zero_le _) ‚ü®0, Finset.mem_Ioo.mpr ‚ü®hp‚ÇÄ, hq‚ÇÄ‚ü©, ?_‚ü©
    rw [zero_smul, zero_add]
    exact finrank_pos
  refine ‚ü®a, b, Int.ofNat_pos.mpr hb, fun x hx ‚Ü¶ ?_‚ü©
  let N : ‚Ñ§ ‚Üí Submodule R M := fun k ‚Ü¶ weightSpace M (k ‚Ä¢ Œ± + œá)
  have h‚ÇÅ : CompleteLattice.Independent fun (i : Finset.Ioo p q) ‚Ü¶ N i := by
    rw [‚Üê LieSubmodule.independent_iff_coe_toSubmodule]
    refine (independent_weightSpace R H M).comp fun i j hij ‚Ü¶ ?_
    exact SetCoe.ext <| smul_left_injective ‚Ñ§ hŒ± <| by rwa [add_left_inj] at hij
  have h‚ÇÇ : ‚àÄ i, MapsTo (toEndomorphism R H M x) ‚Üë(N i) ‚Üë(N i) := fun _ _ ‚Ü¶ LieSubmodule.lie_mem _
  have h‚ÇÉ : weightSpaceChain M Œ± œá p q = ‚®Ü i ‚àà Finset.Ioo p q, N i := by
    simp_rw [weightSpaceChain_def', LieSubmodule.iSup_coe_toSubmodule]
  rw [‚Üê trace_toEndomorphism_weightSpaceChain_eq_zero M Œ± œá p q hp hq hx,
    ‚Üê LieSubmodule.toEndomorphism_restrict_eq_toEndomorphism,
    LinearMap.trace_eq_sum_trace_restrict_of_eq_biSup _ h‚ÇÅ h‚ÇÇ (weightSpaceChain M Œ± œá p q) h‚ÇÉ]
  simp_rw [LieSubmodule.toEndomorphism_restrict_eq_toEndomorphism,
    trace_toEndomorphism_weightSpace, Pi.add_apply, Pi.smul_apply, smul_add, ‚Üê smul_assoc,
    Finset.sum_add_distrib, ‚Üê Finset.sum_smul, natCast_zsmul]",error:  unknown identifier 'toEndomorphism',"lemma exists_forall_mem_corootSpace_smul_add_eq_zero
    [IsDomain R] [IsPrincipalIdealRing R] [CharZero R] [NoZeroSMulDivisors R M] [IsNoetherian R M]
    (hŒ± : Œ± ‚â† 0) (hœá : weightSpace M œá ‚â† ‚ä•) :
    ‚àÉ a b : ‚Ñ§, 0 < b ‚àß ‚àÄ x ‚àà corootSpace Œ±, (a ‚Ä¢ Œ± + b ‚Ä¢ œá) x = 0 ",":= by
  obtain ‚ü®p, hp‚ÇÄ, q, hq‚ÇÄ, hp, hq‚ü© := exists‚ÇÇ_weightSpace_smul_add_eq_bot M Œ± œá hŒ±
  let a := ‚àë i ‚àà Finset.Ioo p q, finrank R (weightSpace M (i ‚Ä¢ Œ± + œá)) ‚Ä¢ i
  let b := ‚àë i ‚àà Finset.Ioo p q, finrank R (weightSpace M (i ‚Ä¢ Œ± + œá))
  have hb : 0 < b := by
    replace hœá : Nontrivial (weightSpace M œá) := by rwa [LieSubmodule.nontrivial_iff_ne_bot]
    refine Finset.sum_pos' (fun _ _ ‚Ü¶ zero_le _) ‚ü®0, Finset.mem_Ioo.mpr ‚ü®hp‚ÇÄ, hq‚ÇÄ‚ü©, ?_‚ü©
    rw [zero_smul, zero_add]
    exact finrank_pos
  refine ‚ü®a, b, Int.ofNat_pos.mpr hb, fun x hx ‚Ü¶ ?_‚ü©
  let N : ‚Ñ§ ‚Üí Submodule R M := fun k ‚Ü¶ weightSpace M (k ‚Ä¢ Œ± + œá)
  have h‚ÇÅ : CompleteLattice.Independent fun (i : Finset.Ioo p q) ‚Ü¶ N i := by
    rw [‚Üê LieSubmodule.independent_iff_coe_toSubmodule]
    refine (independent_weightSpace R H M).comp fun i j hij ‚Ü¶ ?_
    exact SetCoe.ext <| smul_left_injective ‚Ñ§ hŒ± <| by rwa [add_left_inj] at hij
  have h‚ÇÇ : ‚àÄ i, MapsTo (toEnd R H M x) ‚Üë(N i) ‚Üë(N i) := fun _ _ ‚Ü¶ LieSubmodule.lie_mem _
  have h‚ÇÉ : weightSpaceChain M Œ± œá p q = ‚®Ü i ‚àà Finset.Ioo p q, N i := by
    simp_rw [weightSpaceChain_def', LieSubmodule.iSup_coe_toSubmodule]
  rw [‚Üê trace_toEnd_weightSpaceChain_eq_zero M Œ± œá p q hp hq hx,
    ‚Üê LieSubmodule.toEnd_restrict_eq_toEnd,
    LinearMap.trace_eq_sum_trace_restrict_of_eq_biSup _ h‚ÇÅ h‚ÇÇ (weightSpaceChain M Œ± œá p q) h‚ÇÉ]
  simp_rw [LieSubmodule.toEnd_restrict_eq_toEnd,
    trace_toEnd_weightSpace, Pi.add_apply, Pi.smul_apply, smul_add, ‚Üê smul_assoc,
    Finset.sum_add_distrib, ‚Üê Finset.sum_smul, natCast_zsmul]"
Mathlib/Topology/CompactOpen.lean,ContinuousMap.tendsto_nhds_compactOpen,tendsto_nhds_compactOpen,3cce1eda4b282dfbc93f17b1a804e0df694f5f64,":= by
  simp_rw [compactOpen_eq_mapsTo, tendsto_nhds_generateFrom_iff, forall_image2_iff,
    mem_setOf, preimage_setOf_eq, eventually_iff]","error:  unknown identifier 'compactOpen_eq_mapsTo'
error:  simp made no progress
warning:  `ContinuousMap.curry'` has been deprecated, use `ContinuousMap.curry` instead","lemma tendsto_nhds_compactOpen {l : Filter Œ±} {f : Œ± ‚Üí C(Y, Z)} {g : C(Y, Z)} :
    Tendsto f l (ùìù g) ‚Üî
      ‚àÄ K, IsCompact K ‚Üí ‚àÄ U, IsOpen U ‚Üí MapsTo g K U ‚Üí ‚àÄ·∂† a in l, MapsTo (f a) K U ",":= by
  simp [nhds_compactOpen]"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.partialGamma_add_one,partialGamma_add_one,22e97510854d6906cc856e022d297bf9cf8c9b3a,":= by
  rw [partialGamma, partialGamma, add_sub_cancel]
  have F_der_I : ‚àÄ x : ‚Ñù, x ‚àà Ioo 0 X ‚Üí HasDerivAt (fun x => (-x).exp * x ^ s : ‚Ñù ‚Üí ‚ÑÇ)
      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by
    intro x hx
    have d1 : HasDerivAt (fun y : ‚Ñù => (-y).exp) (-(-x).exp) x := by
      simpa using (hasDerivAt_neg x).exp
    have d2 : HasDerivAt (fun y : ‚Ñù => ‚Üëy ^ s) (s * x ^ (s - 1)) x := by
      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id ‚Üëx) ?_
      simpa only [mul_one] using t.comp_ofReal
      simpa only [id.def, ofReal_re, ofReal_im, Ne.def, eq_self_iff_true, not_true, or_false_iff,
        mul_one] using hx.1
    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2
  have cont := (continuous_ofReal.comp continuous_neg.exp).mul (continuous_ofReal_cpow_const hs)
  have der_ible :=
    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)
  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible
  apply_fun fun x : ‚ÑÇ => -x at int_eval
  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)
      (Gamma_integrand_deriv_integrable_B hs hX),
    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval
  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]
  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : ‚Ñù ‚Üí ‚ÑÇ) =
      (fun x => s * (-x).exp * x ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) := by ext1; ring
  rw [this]
  have t := @integral_const_mul 0 X volume _ _ s fun x : ‚Ñù => (-x).exp * x ^ (s - 1)
  rw [‚Üê t, ofReal_zero, zero_cpow]
  ¬∑ rw [mul_zero, add_zero]; congr 2; ext1; ring
  ¬∑ contrapose! hs; rw [hs, zero_re]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + (?b - ?a)
s : ‚ÑÇ
hs : 0 < s.re
X : ‚Ñù
hX : 0 ‚â§ X
‚ä¢ ‚à´ (x : ‚Ñù) in 0 ..X, ‚Üë(rexp (-x)) * ‚Üëx ^ (s + 1 - 1) =
    (s * ‚à´ (x : ‚Ñù) in 0 ..X, ‚Üë(rexp (-x)) * ‚Üëx ^ (s - 1)) - ‚Üë(rexp (-X)) * ‚ÜëX ^ s","theorem partialGamma_add_one {s : ‚ÑÇ} (hs : 0 < s.re) {X : ‚Ñù} (hX : 0 ‚â§ X) :
    partialGamma (s + 1) X = s * partialGamma s X - (-X).exp * X ^ s ",":= by
  rw [partialGamma, partialGamma, add_sub_cancel_right]
  have F_der_I : ‚àÄ x : ‚Ñù, x ‚àà Ioo 0 X ‚Üí HasDerivAt (fun x => (-x).exp * x ^ s : ‚Ñù ‚Üí ‚ÑÇ)
      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by
    intro x hx
    have d1 : HasDerivAt (fun y : ‚Ñù => (-y).exp) (-(-x).exp) x := by
      simpa using (hasDerivAt_neg x).exp
    have d2 : HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ s) (s * x ^ (s - 1)) x := by
      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id ‚Üëx) ?_
      ¬∑ simpa only [mul_one] using t.comp_ofReal
      ¬∑ exact ofReal_mem_slitPlane.2 hx.1
    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2
  have cont := (continuous_ofReal.comp continuous_neg.rexp).mul (continuous_ofReal_cpow_const hs)
  have der_ible :=
    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)
  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible
  apply_fun fun x : ‚ÑÇ => -x at int_eval
  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)
      (Gamma_integrand_deriv_integrable_B hs hX),
    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval
  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]
  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : ‚Ñù ‚Üí ‚ÑÇ) =
      (fun x => s * (-x).exp * x ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) := by ext1; ring
  rw [this]
  have t := @integral_const_mul 0 X volume _ _ s fun x : ‚Ñù => (-x).exp * x ^ (s - 1)
  rw [‚Üê t, ofReal_zero, zero_cpow]
  ¬∑ rw [mul_zero, add_zero]; congr 2; ext1; ring
  ¬∑ contrapose! hs; rw [hs, zero_re]"
Mathlib/Analysis/Calculus/BumpFunction/FiniteDimension.lean,exists_smooth_tsupport_subset,exists_smooth_tsupport_subset,63aaa8cc21050b7a5cb193c6764569918728723b,":= by
  obtain ‚ü®d : ‚Ñù, d_pos : 0 < d, hd : Euclidean.closedBall x d ‚äÜ s‚ü© :=
    Euclidean.nhds_basis_closedBall.mem_iff.1 hs
  let c : ContDiffBump (toEuclidean x) :=
    { rIn := d / 2
      rOut := d
      rIn_pos := half_pos d_pos
      rIn_lt_rOut := half_lt_self d_pos }
  let f : E ‚Üí ‚Ñù := c ‚àò toEuclidean
  have f_supp : f.support ‚äÜ Euclidean.ball x d := by
    intro y hy
    have : toEuclidean y ‚àà Function.support c := by
      simpa only [Function.mem_support, Function.comp_apply, Ne.def] using hy
    rwa [c.support_eq] at this
  have f_tsupp : tsupport f ‚äÜ Euclidean.closedBall x d := by
    rw [tsupport, ‚Üê Euclidean.closure_ball _ d_pos.ne']
    exact closure_mono f_supp
  refine' ‚ü®f, f_tsupp.trans hd, _, _, _, _‚ü©
  ¬∑ refine' isCompact_of_isClosed_isBounded isClosed_closure _
    have : IsBounded (Euclidean.closedBall x d) := Euclidean.isCompact_closedBall.isBounded
    refine this.subset (Euclidean.isClosed_closedBall.closure_subset_iff.2 ?_)
    exact f_supp.trans Euclidean.ball_subset_closedBall
  ¬∑ apply c.contDiff.comp
    exact ContinuousLinearEquiv.contDiff _
  ¬∑ rintro t ‚ü®y, rfl‚ü©
    exact ‚ü®c.nonneg, c.le_one‚ü©
  ¬∑ apply c.one_of_mem_closedBall
    apply mem_closedBall_self
    exact (half_pos d_pos).le","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.10768 ‚Üí ?m.10768 ‚Üí Prop","theorem exists_smooth_tsupport_subset {s : Set E} {x : E} (hs : s ‚àà ùìù x) :
    ‚àÉ f : E ‚Üí ‚Ñù,
      tsupport f ‚äÜ s ‚àß HasCompactSupport f ‚àß ContDiff ‚Ñù ‚ä§ f ‚àß range f ‚äÜ Icc 0 1 ‚àß f x = 1 ",":= by
  obtain ‚ü®d : ‚Ñù, d_pos : 0 < d, hd : Euclidean.closedBall x d ‚äÜ s‚ü© :=
    Euclidean.nhds_basis_closedBall.mem_iff.1 hs
  let c : ContDiffBump (toEuclidean x) :=
    { rIn := d / 2
      rOut := d
      rIn_pos := half_pos d_pos
      rIn_lt_rOut := half_lt_self d_pos }
  let f : E ‚Üí ‚Ñù := c ‚àò toEuclidean
  have f_supp : f.support ‚äÜ Euclidean.ball x d := by
    intro y hy
    have : toEuclidean y ‚àà Function.support c := by
      simpa only [Function.mem_support, Function.comp_apply, Ne] using hy
    rwa [c.support_eq] at this
  have f_tsupp : tsupport f ‚äÜ Euclidean.closedBall x d := by
    rw [tsupport, ‚Üê Euclidean.closure_ball _ d_pos.ne']
    exact closure_mono f_supp
  refine ‚ü®f, f_tsupp.trans hd, ?_, ?_, ?_, ?_‚ü©
  ¬∑ refine isCompact_of_isClosed_isBounded isClosed_closure ?_
    have : IsBounded (Euclidean.closedBall x d) := Euclidean.isCompact_closedBall.isBounded
    refine this.subset (Euclidean.isClosed_closedBall.closure_subset_iff.2 ?_)
    exact f_supp.trans Euclidean.ball_subset_closedBall
  ¬∑ apply c.contDiff.comp
    exact ContinuousLinearEquiv.contDiff _
  ¬∑ rintro t ‚ü®y, rfl‚ü©
    exact ‚ü®c.nonneg, c.le_one‚ü©
  ¬∑ apply c.one_of_mem_closedBall
    apply mem_closedBall_self
    exact (half_pos d_pos).le"
Mathlib/Geometry/Manifold/ContMDiffMFDeriv.lean,ContMDiffOn.contMDiffOn_tangentMapWithin,ContMDiffOn.contMDiffOn_tangentMapWithin,f3695eb20c685cfcb5e45f75b1e68a59b8de7efb,":= by
  have m_le_n : m ‚â§ n := (le_add_right le_rfl).trans hmn
  have one_le_n : 1 ‚â§ n := (le_add_left le_rfl).trans hmn
  have U' : UniqueDiffOn ùïú (range I ‚à© I.symm ‚Åª¬π' s) := fun y hy ‚Ü¶ by
    simpa only [UniqueMDiffOn, UniqueMDiffWithinAt, hy.1, inter_comm, mfld_simps]
      using hs (I.symm y) hy.2
  rw [contMDiffOn_iff]
  refine' ‚ü®hf.continuousOn_tangentMapWithin_aux one_le_n hs, fun p q => _‚ü©
  suffices h :
    ContDiffOn ùïú m
      (((fun p : H' √ó E' => (I' p.fst, p.snd)) ‚àò TotalSpace.toProd H' E') ‚àò
        tangentMapWithin I I' f s ‚àò
          (TotalSpace.toProd H E).symm ‚àò fun p : E √ó E => (I.symm p.fst, p.snd))
      ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ univ)
  ¬∑ 
    convert h using 1
    ¬∑ ext1 ‚ü®x, y‚ü©
      simp only [mfld_simps]; rfl
    ¬∑ simp only [mfld_simps]
      rw [inter_prod, prod_univ, prod_univ]
      rfl
  change
    ContDiffOn ùïú m
      (fun p : E √ó E =>
        ((I' (f (I.symm p.fst)), (mfderivWithin I I' f s (I.symm p.fst) : E ‚Üí E') p.snd) : E' √ó E'))
      ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ univ)
  have hf' := contMDiffOn_iff.1 hf
  have A : ContDiffOn ùïú m (I' ‚àò f ‚àò I.symm) (range I ‚à© I.symm ‚Åª¬π' s) := by
    simpa only [mfld_simps] using (hf'.2 (I.symm 0) (I'.symm 0)).of_le m_le_n
  have B : ContDiffOn ùïú m
      ((I' ‚àò f ‚àò I.symm) ‚àò Prod.fst) ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ (univ : Set E)) :=
    A.comp contDiff_fst.contDiffOn (prod_subset_preimage_fst _ _)
  suffices C :
    ContDiffOn ùïú m
      (fun p : E √ó E => (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) p.1 : _) p.2)
      ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ (univ : Set E))
  ¬∑ refine ContDiffOn.prod B ?_
    refine C.congr fun p hp => ?_
    simp only [mfld_simps] at hp
    simp only [mfderivWithin, hf.mdifferentiableOn one_le_n _ hp.2, hp.1, if_pos, mfld_simps]
  have D :
    ContDiffOn ùïú m (fun x => fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) x)
      (range I ‚à© I.symm ‚Åª¬π' s) := by
    have : ContDiffOn ùïú n (I' ‚àò f ‚àò I.symm) (range I ‚à© I.symm ‚Åª¬π' s) := by
      simpa only [mfld_simps] using hf'.2 (I.symm 0) (I'.symm 0)
    simpa only [inter_comm] using this.fderivWithin U' hmn
  refine ContDiffOn.clm_apply ?_ contDiffOn_snd
  exact D.comp contDiff_fst.contDiffOn (prod_subset_preimage_fst _ _)",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem ContMDiffOn.contMDiffOn_tangentMapWithin_aux {f : H ‚Üí H'} {s : Set H}
    (hf : ContMDiffOn I I' n f s) (hmn : m + 1 ‚â§ n) (hs : UniqueMDiffOn I s) :
    ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s)
      (œÄ E (TangentSpace I) ‚Åª¬π' s) ",":= by
  have m_le_n : m ‚â§ n := (le_add_right le_rfl).trans hmn
  have one_le_n : 1 ‚â§ n := (le_add_left le_rfl).trans hmn
  have U' : UniqueDiffOn ùïú (range I ‚à© I.symm ‚Åª¬π' s) := fun y hy ‚Ü¶ by
    simpa only [UniqueMDiffOn, UniqueMDiffWithinAt, hy.1, inter_comm, mfld_simps]
      using hs (I.symm y) hy.2
  rw [contMDiffOn_iff]
  refine ‚ü®hf.continuousOn_tangentMapWithin_aux one_le_n hs, fun p q => ?_‚ü©
  suffices h :
    ContDiffOn ùïú m
      (((fun p : H' √ó E' => (I' p.fst, p.snd)) ‚àò TotalSpace.toProd H' E') ‚àò
        tangentMapWithin I I' f s ‚àò
          (TotalSpace.toProd H E).symm ‚àò fun p : E √ó E => (I.symm p.fst, p.snd))
      ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ univ) by
    convert h using 1
    ¬∑ ext1 ‚ü®x, y‚ü©
      simp only [mfld_simps]; rfl
    ¬∑ simp only [mfld_simps]
      rw [inter_prod, prod_univ, prod_univ]
      rfl
  change
    ContDiffOn ùïú m
      (fun p : E √ó E =>
        ((I' (f (I.symm p.fst)), (mfderivWithin I I' f s (I.symm p.fst) : E ‚Üí E') p.snd) : E' √ó E'))
      ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ univ)
  have hf' := contMDiffOn_iff.1 hf
  have A : ContDiffOn ùïú m (I' ‚àò f ‚àò I.symm) (range I ‚à© I.symm ‚Åª¬π' s) := by
    simpa only [mfld_simps] using (hf'.2 (I.symm 0) (I'.symm 0)).of_le m_le_n
  have B : ContDiffOn ùïú m
      ((I' ‚àò f ‚àò I.symm) ‚àò Prod.fst) ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ (univ : Set E)) :=
    A.comp contDiff_fst.contDiffOn (prod_subset_preimage_fst _ _)
  suffices C :
    ContDiffOn ùïú m
      (fun p : E √ó E => (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) p.1 : _) p.2)
      ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ (univ : Set E)) by
    refine ContDiffOn.prod B ?_
    refine C.congr fun p hp => ?_
    simp only [mfld_simps] at hp
    simp only [mfderivWithin, hf.mdifferentiableOn one_le_n _ hp.2, hp.1, if_pos, mfld_simps]
    rfl
  have D :
    ContDiffOn ùïú m (fun x => fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) x)
      (range I ‚à© I.symm ‚Åª¬π' s) := by
    have : ContDiffOn ùïú n (I' ‚àò f ‚àò I.symm) (range I ‚à© I.symm ‚Åª¬π' s) := by
      simpa only [mfld_simps] using hf'.2 (I.symm 0) (I'.symm 0)
    simpa only [inter_comm] using this.fderivWithin U' hmn
  refine ContDiffOn.clm_apply ?_ contDiffOn_snd
  exact D.comp contDiff_fst.contDiffOn (prod_subset_preimage_fst _ _)"
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,AffineSubspace.coe_direction_eq_vsub_set_right,coe_direction_eq_vsub_set_right,f27ef6dc0fb66aa1c033b41bb16e840c0a1527a5,":= by
  rw [coe_direction_eq_vsub_set ‚ü®p, hp‚ü©]
  refine' le_antisymm _ _
  ¬∑ rintro v ‚ü®p1, p2, hp1, hp2, rfl‚ü©
    exact ‚ü®p1 -·µ• p2 +·µ• p, by set_like, vadd_vsub _ _‚ü©
  ¬∑ rintro v ‚ü®p2, hp2, rfl‚ü©
    exact ‚ü®p2, p, hp2, hp, rfl‚ü©","error:  unknown tactic
error:  unsolved goals
k : Type u_1
V : Type u_2
P : Type u_3
inst‚úù¬≥ : Ring k
inst‚úù¬≤ : AddCommGroup V
inst‚úù¬π : Module k V
inst‚úù : AffineSpace V P
s : AffineSubspace k P
p : P
hp : p ‚àà s
p1 : P
p2 : p1 ‚àà ‚Üës
hp1 : P
hp2 : hp1 ‚àà ‚Üës
‚ä¢ p1 -·µ• sorryAx P true +·µ• p ‚àà ‚Üës ‚àß (fun x ‚Ü¶ x -·µ• p) (p1 -·µ• sorryAx P true +·µ• p) = (fun x x_1 ‚Ü¶ x -·µ• x_1) p1 hp1
error:  unsolved goals
case refine'_2
k : Type u_1
V : Type u_2
P : Type u_3
inst‚úù¬≥ : Ring k
inst‚úù¬≤ : AddCommGroup V
inst‚úù¬π : Module k V
inst‚úù : AffineSpace V P
s : AffineSubspace k P
p : P
hp : p ‚àà s
‚ä¢ (fun x ‚Ü¶ x -·µ• p) '' ‚Üës ‚â§ ‚Üës -·µ• ‚Üës
warning:  @AffineSubspace.Parallel does not have a doc string","theorem coe_direction_eq_vsub_set_right {s : AffineSubspace k P} {p : P} (hp : p ‚àà s) :
    (s.direction : Set V) = (¬∑ -·µ• p) '' s ",":= by
  rw [coe_direction_eq_vsub_set ‚ü®p, hp‚ü©]
  refine le_antisymm ?_ ?_
  ¬∑ rintro v ‚ü®p1, hp1, p2, hp2, rfl‚ü©
    exact ‚ü®p1 -·µ• p2 +·µ• p, vadd_mem_of_mem_direction (vsub_mem_direction hp1 hp2) hp, vadd_vsub _ _‚ü©
  ¬∑ rintro v ‚ü®p2, hp2, rfl‚ü©
    exact ‚ü®p2, hp2, p, hp, rfl‚ü©"
Mathlib/Geometry/Manifold/Complex.lean,Complex.norm_eventually_eq_of_mdifferentiableAt_of_isLocalMax,Complex.norm_eventually_eq_of_mdifferentiableAt_of_isLocalMax,01cbe052ff3f63d184556afa56666d0df4fed183,":= by
  set e := extChartAt I c
  have hI : range I = univ := ModelWithCorners.Boundaryless.range_eq_univ
  have H‚ÇÅ : ùìù[range I] (e c) = ùìù (e c) := by rw [hI, nhdsWithin_univ]
  have H‚ÇÇ : map e.symm (ùìù (e c)) = ùìù c
  ¬∑ rw [‚Üê map_extChartAt_symm_nhdsWithin_range I c, H‚ÇÅ]
  rw [‚Üê H‚ÇÇ, eventually_map]
  replace hd : ‚àÄ·∂† y in ùìù (e c), DifferentiableAt ‚ÑÇ (f ‚àò e.symm) y
  ¬∑ have : e.target ‚àà ùìù (e c) := H‚ÇÅ ‚ñ∏ extChartAt_target_mem_nhdsWithin I c
    filter_upwards [this, Tendsto.eventually H‚ÇÇ.le hd] with y hyt hy‚ÇÇ
    have hys : e.symm y ‚àà (chartAt H c).source
    ¬∑ rw [‚Üê extChartAt_source I c]
      exact (extChartAt I c).map_target hyt
    have hfy : f (e.symm y) ‚àà (chartAt F (0 : F)).source := mem_univ _
    rw [mdifferentiableAt_iff_of_mem_source hys hfy, hI, differentiableWithinAt_univ,
      e.right_inv hyt] at hy‚ÇÇ
    exact hy‚ÇÇ.2
  convert norm_eventually_eq_of_isLocalMax hd _
  ¬∑ exact congr_arg f (extChartAt_to_inv _ _).symm
  ¬∑ simpa only [IsLocalMax, IsMaxFilter, ‚Üê H‚ÇÇ, Function.comp_def, extChartAt_to_inv] using hc","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
E : Type u_1
inst‚úù‚Åπ : NormedAddCommGroup E
inst‚úù‚Å∏ : NormedSpace ‚ÑÇ E
F : Type u_2
inst‚úù‚Å∑ : NormedAddCommGroup F
inst‚úù‚Å∂ : NormedSpace ‚ÑÇ F
H : Type u_3
inst‚úù‚Åµ : TopologicalSpace H
I : ModelWithCorners ‚ÑÇ E H
inst‚úù‚Å¥ : I.Boundaryless
M : Type u_4
inst‚úù¬≥ : TopologicalSpace M
inst‚úù¬≤ : CompactSpace M
inst‚úù¬π : ChartedSpace H M
inst‚úù : SmoothManifoldWithCorners I M
f : M ‚Üí F
c : M
hd : ‚àÄ·∂† (z : M) in ùìù c, MDifferentiableAt I ùìò(‚ÑÇ, F) f z
hc : IsLocalMax (norm ‚àò f) c
e : PartialEquiv M E := extChartAt I c
hI : range ‚ÜëI = univ
H‚ÇÅ : ùìù[range ‚ÜëI] ‚Üëe c = ùìù (‚Üëe c)
H‚ÇÇ : map (‚Üëe.symm) (ùìù (‚Üëe c)) = ùìù c
‚ä¢ ‚àÄ·∂† (y : M) in ùìù c, ‚Äñf y‚Äñ = ‚Äñf c‚Äñ","theorem Complex.norm_eventually_eq_of_mdifferentiableAt_of_isLocalMax {f : M ‚Üí F} {c : M}
    (hd : ‚àÄ·∂† z in ùìù c, MDifferentiableAt I ùìò(‚ÑÇ, F) f z) (hc : IsLocalMax (norm ‚àò f) c) :
    ‚àÄ·∂† y in ùìù c, ‚Äñf y‚Äñ = ‚Äñf c‚Äñ ",":= by
  set e := extChartAt I c
  have hI : range I = univ := ModelWithCorners.Boundaryless.range_eq_univ
  have H‚ÇÅ : ùìù[range I] (e c) = ùìù (e c) := by rw [hI, nhdsWithin_univ]
  have H‚ÇÇ : map e.symm (ùìù (e c)) = ùìù c := by
    rw [‚Üê map_extChartAt_symm_nhdsWithin_range I c, H‚ÇÅ]
  rw [‚Üê H‚ÇÇ, eventually_map]
  replace hd : ‚àÄ·∂† y in ùìù (e c), DifferentiableAt ‚ÑÇ (f ‚àò e.symm) y := by
    have : e.target ‚àà ùìù (e c) := H‚ÇÅ ‚ñ∏ extChartAt_target_mem_nhdsWithin I c
    filter_upwards [this, Tendsto.eventually H‚ÇÇ.le hd] with y hyt hy‚ÇÇ
    have hys : e.symm y ‚àà (chartAt H c).source := by
      rw [‚Üê extChartAt_source I c]
      exact (extChartAt I c).map_target hyt
    have hfy : f (e.symm y) ‚àà (chartAt F (0 : F)).source := mem_univ _
    rw [mdifferentiableAt_iff_of_mem_source hys hfy, hI, differentiableWithinAt_univ,
      e.right_inv hyt] at hy‚ÇÇ
    exact hy‚ÇÇ.2
  convert norm_eventually_eq_of_isLocalMax hd _
  ¬∑ exact congr_arg f (extChartAt_to_inv _ _).symm
  ¬∑ simpa only [e, IsLocalMax, IsMaxFilter, ‚Üê H‚ÇÇ, (¬∑ ‚àò ¬∑), extChartAt_to_inv] using hc"
Mathlib/Computability/Primrec.lean,Primrec.list_casesOn,list_casesOn,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  letI := prim H
  have := option_casesOn snd (hg.comp fst) (hh.comp‚ÇÇ (fst.comp fst) snd).to‚ÇÇ
  have := (map_decode_iff.2 this.to‚ÇÇ).comp‚ÇÇ .id (encode_iff.2 hf)
  option_some_iff.1 <| this.of_eq fun a => by cases' f a with b l <;> simp [encodek]","error:  application type mismatch
  Primrec‚ÇÇ.comp‚ÇÇ hh (Primrec.comp fst fst)
argument
  Primrec.comp fst fst
has type
  Primrec fun a ‚Ü¶ a.1.1 : Prop
but is expected to have type
  Primrec‚ÇÇ ?m.115823 : Prop
error:  application type mismatch
  Primrec‚ÇÇ.comp‚ÇÇ (map_decode_iff.mpr (to‚ÇÇ this)) Primrec.id
argument
  Primrec.id
has type
  Primrec id : Prop
but is expected to have type
  Primrec‚ÇÇ ?m.146327 : Prop
error:  application type mismatch
  option_some_iff.mp (Primrec‚ÇÇ.of_eq this fun a ‚Ü¶ ?m.151657 a)
argument
  Primrec‚ÇÇ.of_eq this fun a ‚Ü¶ ?m.151657 a
has type
  Primrec‚ÇÇ ?m.150953 : Prop
but is expected to have type
  Primrec fun a ‚Ü¶ some (List.casesOn (f a) (g a) fun b l ‚Ü¶ h a (b, l)) : Prop
error:  unsolved goals
case nil
Œ± : Type u_1
Œ≤ : Type u_2
œÉ : Type u_3
inst‚úù¬≤ : Primcodable Œ±
inst‚úù¬π : Primcodable Œ≤
inst‚úù : Primcodable œÉ
H : Nat.Primrec fun n ‚Ü¶ encode (decode n)
f : Œ± ‚Üí List Œ≤
g : Œ± ‚Üí œÉ
h : Œ± ‚Üí Œ≤ √ó List Œ≤ ‚Üí œÉ
hf : Primrec f
hg : Primrec g
hh : Primrec‚ÇÇ h
this‚úù¬π : Primcodable (List Œ≤) := prim H
this‚úù :
  Primrec fun a ‚Ü¶ Option.casesOn a.2 (g a.1) fun b ‚Ü¶ (fun a b ‚Ü¶ h (?m.153154 a b) (?m.153155 a b)) (a, b).1 (a, b).2
this :
  Primrec‚ÇÇ fun a b ‚Ü¶
    Option.map
      (fun b_1 ‚Ü¶
        Option.casesOn (?m.153160 this‚úù a b, b_1).2 (g (?m.153160 this‚úù a b, b_1).1) fun b_2 ‚Ü¶
          (fun a b ‚Ü¶ h (?m.153154 a b) (?m.153155 a b)) ((?m.153160 this‚úù a b, b_1), b_2).1
            ((?m.153160 this‚úù a b, b_1), b_2).2)
      (decode (?m.153161 this‚úù a b))
a : Œ±
‚ä¢ ‚àÄ (b : ?m.153157 this‚úù),
    Option.map
        (fun b_1 ‚Ü¶
          Option.rec (g (?m.153160 this‚úù a b))
            (fun val ‚Ü¶ h (?m.153154 (?m.153160 this‚úù a b, b_1) val) (?m.153155 (?m.153160 this‚úù a b, b_1) val)) b_1)
        (decode (?m.153161 this‚úù a b)) =
      ?m.150953 a b

case cons
Œ± : Type u_1
Œ≤ : Type u_2
œÉ : Type u_3
inst‚úù¬≤ : Primcodable Œ±
inst‚úù¬π : Primcodable Œ≤
inst‚úù : Primcodable œÉ
H : Nat.Primrec fun n ‚Ü¶ encode (decode n)
f : Œ± ‚Üí List Œ≤
g : Œ± ‚Üí œÉ
h : Œ± ‚Üí Œ≤ √ó List Œ≤ ‚Üí œÉ
hf : Primrec f
hg : Primrec g
hh : Primrec‚ÇÇ h
this‚úù¬π : Primcodable (List Œ≤) := prim H
this‚úù :
  Primrec fun a ‚Ü¶ Option.casesOn a.2 (g a.1) fun b ‚Ü¶ (fun a b ‚Ü¶ h (?m.153154 a b) (?m.153155 a b)) (a, b).1 (a, b).2
this :
  Primrec‚ÇÇ fun a b ‚Ü¶
    Option.map
      (fun b_1 ‚Ü¶
        Option.casesOn (?m.153160 this‚úù a b, b_1).2 (g (?m.153160 this‚úù a b, b_1).1) fun b_2 ‚Ü¶
          (fun a b ‚Ü¶ h (?m.153154 a b) (?m.153155 a b)) ((?m.153160 this‚úù a b, b_1), b_2).1
            ((?m.153160 this‚úù a b, b_1), b_2).2)
      (decode (?m.153161 this‚úù a b))
a : Œ±
b : Œ≤
l : List Œ≤
‚ä¢ ‚àÄ (b : ?m.153157 this‚úù),
    Option.map
        (fun b_1 ‚Ü¶
          Option.rec (g (?m.153160 this‚úù a b))
            (fun val ‚Ü¶ h (?m.153154 (?m.153160 this‚úù a b, b_1) val) (?m.153155 (?m.153160 this‚úù a b, b_1) val)) b_1)
        (decode (?m.153161 this‚úù a b)) =
      ?m.150953 a b
error:  invalid occurrence of universe level 'u_4' at '_private.Mathlib.Computability.Primrec.0.list_foldl'', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  list_casesOn'.{max (max u_2 u_3) u_1, u_2, max u_2 u_3, u_4, u_5} H
    (Primrec.comp.{max (max u_2 u_3) u_1, max u_2 u_3, u_2} snd.{u_3, u_2} snd.{u_1, max u_2 u_3})
    snd.{u_1, max u_2 u_3}
    (to‚ÇÇ.{max (max u_2 u_3) u_1, u_2, max u_2 u_3}
      (Primrec.pair.{max (max u_2 u_3) u_1, u_3, u_2}
        (Primrec‚ÇÇ.comp.{max (max u_2 u_1) u_3, u_1, max u_2 u_3, u_3} hh
          (Primrec.comp.{max (max u_2 u_3) u_1, max (max u_2 u_3) u_1, u_1} fst.{u_1, max u_2 u_3}
            fst.{max u_1 u_2 u_3, u_2})
          (Primrec.pair.{max (max u_1 u_2) u_3, u_3, u_2}
            (Primrec.comp.{max (max u_1 u_2) u_3, max (max u_2 u_3) u_1, u_3}
              (Primrec.comp.{max (max u_2 u_3) u_1, max u_2 u_3, u_3} fst.{u_3, u_2} snd.{u_1, max u_2 u_3})
              fst.{max (max u_3 u_2) u_1, u_2})
            (Primrec.comp.{max (max u_1 u_2) u_3, u_2, u_2} fst.{u_2, u_2} snd.{max (max u_1 u_2) u_3, u_2})))
        (Primrec.comp.{max (max u_1 u_2) u_3, u_2, u_2} snd.{u_2, u_2} snd.{max (max u_1 u_2) u_3, u_2})))
at declaration body
  fun {Œ± : Type u_1} {Œ≤ : Type u_2} {œÉ : Type u_3} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable œÉ]
      (H : Nat.Primrec fun (n : ‚Ñï) ‚Ü¶ encode (decode n)) {f : Œ± ‚Üí List Œ≤} {g : Œ± ‚Üí œÉ} {h : Œ± ‚Üí œÉ √ó Œ≤ ‚Üí œÉ}
      (hf : Primrec f) (hg : Primrec g) (hh : Primrec‚ÇÇ h) ‚Ü¶
    let G : Œ± ‚Üí œÉ √ó List Œ≤ ‚Üí œÉ √ó List Œ≤ := fun (a : Œ±) (IH : œÉ √ó List Œ≤) ‚Ü¶
      List.casesOn IH.2 IH fun (b : Œ≤) (l : List Œ≤) ‚Ü¶ (h a (IH.1, b), l);
    let_fun hG : Primrec‚ÇÇ G :=
      list_casesOn' H (Primrec.comp snd snd) snd
        (to‚ÇÇ
          (Primrec.pair
            (Primrec‚ÇÇ.comp hh (Primrec.comp fst fst)
              (Primrec.pair (Primrec.comp (Primrec.comp fst snd) fst) (Primrec.comp fst snd)))
            (Primrec.comp snd snd)));
    let F : Œ± ‚Üí ‚Ñï ‚Üí œÉ √ó List Œ≤ := fun (a : Œ±) (n : ‚Ñï) ‚Ü¶ (G a)^[n] (g a, f a);
    let_fun hF : Primrec fun (a : Œ±) ‚Ü¶ (F a (encode (f a))).1 :=
      Primrec.comp fst (nat_iterate (encode_iff.mpr hf) (Primrec.pair hg hf) hG);
    let_fun this :
      ‚àÄ (a : Œ±) (n : ‚Ñï),
        F a n = (List.foldl (fun (s : œÉ) (b : Œ≤) ‚Ü¶ h a (s, b)) (g a) (List.take n (f a)), List.drop n (f a)) :=
      fun (a : Œ±) (n : ‚Ñï) ‚Ü¶
      id
        (Nat.recAux (motive := fun (n : ‚Ñï) ‚Ü¶
          ‚àÄ (l : List Œ≤) (x : œÉ),
            (G a)^[n] (x, l) = (List.foldl (fun (s : œÉ) (b : Œ≤) ‚Ü¶ h a (s, b)) x (List.take n l), List.drop n l))
          (fun (l : List Œ≤) (x : œÉ) ‚Ü¶ Eq.refl ((G a)^[0] (x, l)))
          (fun (n : ‚Ñï)
              (IH :
                ‚àÄ (l : List Œ≤) (x : œÉ),
                  (G a)^[n] (x, l) = (List.foldl (fun (s : œÉ) (b : Œ≤) ‚Ü¶ h a (s, b)) x (List.take n l), List.drop n l))
              (l : List Œ≤) (x : œÉ) ‚Ü¶
            id
              (List.casesOn (motive := fun (t : List Œ≤) ‚Ü¶
                l = t ‚Üí
                  (G a)^[n] (G a (x, l)) =
                    (List.foldl (fun (s : œÉ) (b : Œ≤) ‚Ü¶ h a (s, b)) x (List.take (n + 1) l), List.drop (n + 1) l))
                l
                (fun (h_1 : l = []) ‚Ü¶
                  Eq.symm h_1 ‚ñ∏
                    of_eq_true
                      (Eq.trans
                        (congr
                          (congrArg Eq
                            (Eq.trans ((fun (l : List Œ≤) (x : œÉ) ‚Ü¶ IH l x) [] x)
                              (congr
                                (congrArg
                                  (fun (x_1 : List Œ≤) ‚Ü¶ Prod.mk (List.foldl (fun (s : œÉ) (b : Œ≤) ‚Ü¶ h a (s, b)) x x_1))
                                  List.take_nil)
                                List.drop_nil)))
                          (congr
                            (congrArg
                              (fun (x_1 : List Œ≤) ‚Ü¶ Prod.mk (List.foldl (fun (s : œÉ) (b : Œ≤) ‚Ü¶ h a (s, b)) x x_1))
                              List.take_nil)
                            List.drop_nil))
                        (eq_self (x, []))))
                (fun (b : Œ≤) (l_1 : List Œ≤) (h_1 : l = b :: l_1) ‚Ü¶
                  Eq.symm h_1 ‚ñ∏
                    of_eq_true
                      (Eq.trans
                        (congrArg
                          (fun (x_1 : œÉ √ó List Œ≤) ‚Ü¶
                            x_1 =
                              (List.foldl (fun (s : œÉ) (b : Œ≤) ‚Ü¶ h a (s, b)) (h a (x, b)) (List.take n l_1),
                                List.drop n l_1))
                          ((fun (l : List Œ≤) (x : œÉ) ‚Ü¶ IH l x) l_1 (h a ((x, b :: l_1).1, b))))
                        (eq_self
                          (List.foldl (fun (s : œÉ) (b : Œ≤) ‚Ü¶ h a (s, b)) (h a (x, b)) (List.take n l_1),
                            List.drop n l_1))))
                (Eq.refl l)))
          n (f a) (g a));
    Primrec.of_eq hF fun (a : Œ±) ‚Ü¶
      Eq.mpr
        (id
          (congrArg (fun (_a : œÉ √ó List Œ≤) ‚Ü¶ _a.1 = List.foldl (fun (s : œÉ) (b : Œ≤) ‚Ü¶ h a (s, b)) (g a) (f a))
            (this a (encode (f a)))))
        (Eq.mpr
          (id
            (congrArg
              (fun (_a : List Œ≤) ‚Ü¶
                (List.foldl (fun (s : œÉ) (b : Œ≤) ‚Ü¶ h a (s, b)) (g a) _a, List.drop (encode (f a)) (f a)).1 =
                  List.foldl (fun (s : œÉ) (b : Œ≤) ‚Ü¶ h a (s, b)) (g a) (f a))
              (List.take_all_of_le (length_le_encode (f a)))))
          (Eq.refl (List.foldl (fun (s : œÉ) (b : Œ≤) ‚Ü¶ h a (s, b)) (g a) (f a), List.drop (encode (f a)) (f a)).1))
error:  unknown identifier 'list_foldl''
error:  unknown identifier 'list_foldl''
error:  invalid occurrence of universe level 'u_5' at 'Primrec.list_casesOn', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  list_casesOn'.{u_1, u_2, u_4, u_5, u_6} Primcodable.prim.{u_2}
at declaration body
  fun {Œ± : Type u_1} {Œ≤ : Type u_2} {œÉ : Type u_4} [Primcodable Œ±] [Primcodable Œ≤] [Primcodable œÉ] {f : Œ± ‚Üí List Œ≤}
      {g : Œ± ‚Üí œÉ} {h : Œ± ‚Üí Œ≤ √ó List Œ≤ ‚Üí œÉ} ‚Ü¶
    list_casesOn' Primcodable.prim
error:  unknown identifier 'list_foldl''
error:  unknown identifier 'list_casesOn'
error:  unknown identifier 'list_casesOn'","theorem list_casesOn' {f : Œ± ‚Üí List Œ≤} {g : Œ± ‚Üí œÉ} {h : Œ± ‚Üí Œ≤ √ó List Œ≤ ‚Üí œÉ}
    (hf : haveI := prim H; Primrec f) (hg : Primrec g) (hh : haveI := prim H; Primrec‚ÇÇ h) :
    @Primrec _ œÉ _ _ fun a => List.casesOn (f a) (g a) fun b l => h a (b, l) ",":=
  letI := prim H
  have :
    @Primrec _ (Option œÉ) _ _ fun a =>
      (@decode (Option (Œ≤ √ó List Œ≤)) _ (encode (f a))).map fun o => Option.casesOn o (g a) (h a) :=
    ((@map_decode_iff _ (Option (Œ≤ √ó List Œ≤)) _ _ _ _ _).2 <|
      to‚ÇÇ <|
        option_casesOn snd (hg.comp fst) (hh.comp‚ÇÇ (fst.comp‚ÇÇ Primrec‚ÇÇ.left) Primrec‚ÇÇ.right)).comp
      .id (encode_iff.2 hf)
  option_some_iff.1 <| this.of_eq fun a => by cases' f a with b l <;> simp [encodek]"
Mathlib/Combinatorics/SetFamily/FourFunctions.lean,Finset.card_le_card_diffs,Finset.card_le_card_diffs,603ba0edfa54651831a9bdebe4cdc81aa3172049,":=
  le_of_pow_le_pow 2 (zero_le _) two_pos $ by simpa [‚Üê sq] using s.le_card_diffs_mul_card_diffs s","warning:  `le_of_pow_le_pow` has been deprecated, use `le_of_pow_le_pow_left` instead
error:  numerals are data in Lean, but the expected type is a proposition
  ?m.408446 ‚â† 0 : Prop",lemma Finset.card_le_card_diffs (s : Finset Œ±) : s.card ‚â§ (s \\ s).card ,":=
  le_of_pow_le_pow_left two_ne_zero (zero_le _) <| by
    simpa [‚Üê sq] using s.le_card_diffs_mul_card_diffs s"
Mathlib/Order/Interval/Finset/Nat.lean,Nat.image_Ico_mod,image_Ico_mod,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  obtain rfl | ha := eq_or_ne a 0
  ¬∑ rw [range_zero, add_zero, Ico_self, image_empty]
  ext i
  simp only [mem_image, exists_prop, mem_range, mem_Ico]
  constructor
  ¬∑ rintro ‚ü®i, _, rfl‚ü©
    exact mod_lt i ha.bot_lt
  intro hia
  have hn := Nat.mod_add_div n a
  obtain hi | hi := lt_or_le i (n % a)
  ¬∑ refine ‚ü®i + a * (n / a + 1), ‚ü®?_, ?_‚ü©, ?_‚ü©
    ¬∑ rw [add_comm (n / a), Nat.mul_add, mul_one, ‚Üê add_assoc]
      refine hn.symm.le.trans (add_le_add_right ?_ _)
      simpa only [zero_add] using add_le_add (zero_le i) (Nat.mod_lt n ha.bot_lt).le
    ¬∑ refine lt_of_lt_of_le (add_lt_add_right hi (a * (n / a + 1))) ?_
      rw [Nat.mul_add, mul_one, ‚Üê add_assoc, hn]
    ¬∑ rw [Nat.add_mul_mod_self_left, Nat.mod_eq_of_lt hia]
  ¬∑ refine ‚ü®i + a * (n / a), ‚ü®?_, ?_‚ü©, ?_‚ü©
    ¬∑ exact hn.symm.le.trans (add_le_add_right hi _)
    ¬∑ rw [add_comm n a]
      refine add_lt_add_of_lt_of_le hia (le_trans ?_ hn.le)
      simp only [zero_le, le_add_iff_nonneg_left]
    ¬∑ rw [Nat.add_mul_mod_self_left, Nat.mod_eq_of_lt hia]","error:  failed to synthesize
  CovariantClass ‚Ñï ‚Ñï (Function.swap fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
use `set_option diagnostics true` to get diagnostic information
error:  no goals to be solved
error:  failed to synthesize
  CovariantClass ‚Ñï ‚Ñï (Function.swap fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x < x_1
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  CovariantClass ‚Ñï ‚Ñï (Function.swap fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  CovariantClass ‚Ñï ‚Ñï (fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
use `set_option diagnostics true` to get diagnostic information
error:  no goals to be solved",theorem image_Ico_mod (n a : ‚Ñï) : (Ico n (n + a)).image (¬∑ % a) = range a ,":= by
  obtain rfl | ha := eq_or_ne a 0
  ¬∑ rw [range_zero, add_zero, Ico_self, image_empty]
  ext i
  simp only [mem_image, exists_prop, mem_range, mem_Ico]
  constructor
  ¬∑ rintro ‚ü®i, _, rfl‚ü©
    exact mod_lt i ha.bot_lt
  intro hia
  have hn := Nat.mod_add_div n a
  obtain hi | hi := lt_or_le i (n % a)
  ¬∑ refine ‚ü®i + a * (n / a + 1), ‚ü®?_, ?_‚ü©, ?_‚ü©
    ¬∑ rw [add_comm (n / a), Nat.mul_add, mul_one, ‚Üê add_assoc]
      refine hn.symm.le.trans (Nat.add_le_add_right ?_ _)
      simpa only [zero_add] using add_le_add (zero_le i) (Nat.mod_lt n ha.bot_lt).le
    ¬∑ refine lt_of_lt_of_le (Nat.add_lt_add_right hi (a * (n / a + 1))) ?_
      rw [Nat.mul_add, mul_one, ‚Üê add_assoc, hn]
    ¬∑ rw [Nat.add_mul_mod_self_left, Nat.mod_eq_of_lt hia]
  ¬∑ refine ‚ü®i + a * (n / a), ‚ü®?_, ?_‚ü©, ?_‚ü©
    ¬∑ omega
    ¬∑ omega
    ¬∑ rw [Nat.add_mul_mod_self_left, Nat.mod_eq_of_lt hia]"
Mathlib/CategoryTheory/Preadditive/Yoneda/Projective.lean,CategoryTheory.Projective.projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj',projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [projective_iff_preservesEpimorphisms_coyoneda_obj]
  refine' ‚ü®fun h : (preadditiveCoyoneda.obj (op P) ‚ãô
      forget AddCommGroupCat).PreservesEpimorphisms => _, _‚ü©
  ¬∑ exact Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveCoyoneda.obj (op P))
        (forget _)
  ¬∑ intro
    exact (inferInstance : (preadditiveCoyoneda.obj (op P) ‚ãô forget _).PreservesEpimorphisms)","error:  unknown identifier 'AddCommGroupCat'
error:  failed to synthesize
  (preadditiveCoyoneda.obj { unop := P } ‚ãô forget AddCommGrp).PreservesEpimorphisms
use `set_option diagnostics true` to get diagnostic information
error:  no goals to be solved","theorem projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj' (P : C) :
    Projective P ‚Üî (preadditiveCoyoneda.obj (op P)).PreservesEpimorphisms ",":= by
  rw [projective_iff_preservesEpimorphisms_coyoneda_obj]
  refine ‚ü®fun h : (preadditiveCoyoneda.obj (op P) ‚ãô
      forget AddCommGrp).PreservesEpimorphisms => ?_, ?_‚ü©
  ¬∑ exact Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveCoyoneda.obj (op P))
        (forget _)
  ¬∑ intro
    exact (inferInstance : (preadditiveCoyoneda.obj (op P) ‚ãô forget _).PreservesEpimorphisms)"
Mathlib/ModelTheory/Satisfiability.lean,FirstOrder.Language.Theory.models_iff_not_satisfiable,models_iff_not_satisfiable,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [models_sentence_iff, IsSatisfiable]
  refine
    ‚ü®fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T ‚à™ {Formula.not œÜ})
          (Set.subset_union_right _ _ (Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel (Set.subset_union_left _ _))),
      fun h M => ?_‚ü©
  contrapose! h
  rw [‚Üê Sentence.realize_not] at h
  refine
    ‚ü®{  Carrier := M
        is_model := ‚ü®fun œà hœà => hœà.elim (realize_sentence_of_mem _) fun h' => ?_‚ü© }‚ü©
  rw [Set.mem_singleton_iff.1 h']
  exact h","warning:  @ModelsBoundedFormula does not have a doc string
error:  function expected at
  Set.subset_union_right ?m.33716
term has type
  ?m.33715 ‚àà ?m.33713 ‚à™ ?m.33714
error:  function expected at
  Set.subset_union_left ?m.33942
term has type
  ?m.33941 ‚àà ?m.33939 ‚à™ ?m.33940",theorem models_iff_not_satisfiable (œÜ : L.Sentence) : T ‚ä®·µá œÜ ‚Üî ¬¨IsSatisfiable (T ‚à™ {œÜ.not}) ,":= by
  rw [models_sentence_iff, IsSatisfiable]
  refine
    ‚ü®fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T ‚à™ {Formula.not œÜ})
          (Set.subset_union_right (Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel Set.subset_union_left)),
      fun h M => ?_‚ü©
  contrapose! h
  rw [‚Üê Sentence.realize_not] at h
  refine
    ‚ü®{  Carrier := M
        is_model := ‚ü®fun œà hœà => hœà.elim (realize_sentence_of_mem _) fun h' => ?_‚ü© }‚ü©
  rw [Set.mem_singleton_iff.1 h']
  exact h"
Mathlib/Data/Matrix/Kronecker.lean,Matrix.det_kronecker,det_kronecker,9e34a191034458a56331f976ff7400a26407c888,":=
  calc
    det (kroneckerMapBilinear f A B) =
        det (kroneckerMapBilinear f A 1 ‚¨ù kroneckerMapBilinear f 1 B) :=
      by rw [‚Üê kroneckerMapBilinear_mul_mul f h_comm, Matrix.mul_one, Matrix.one_mul]
    _ = det (blockDiagonal fun _ => A.map fun a => f a 1) *
        det (blockDiagonal fun _ => B.map fun b => f 1 b) := by
      rw [det_mul, ‚Üê diagonal_one, ‚Üê diagonal_one, kroneckerMapBilinear_apply_apply,
        kroneckerMap_diagonal_right _ fun _ => _, kroneckerMapBilinear_apply_apply,
        kroneckerMap_diagonal_left _ fun _ => _, det_reindex_self]
      ¬∑ intro; exact LinearMap.map_zero‚ÇÇ _ _
      ¬∑ intro; exact map_zero _
    _ = _ := by simp_rw [det_blockDiagonal, Finset.prod_const, Finset.card_univ]",error:  expected token,"theorem det_kroneckerMapBilinear [CommSemiring R] [Fintype m] [Fintype n] [DecidableEq m]
    [DecidableEq n] [CommRing Œ±] [CommRing Œ≤] [CommRing Œ≥] [Module R Œ±] [Module R Œ≤] [Module R Œ≥]
    (f : Œ± ‚Üí‚Çó[R] Œ≤ ‚Üí‚Çó[R] Œ≥) (h_comm : ‚àÄ a b a' b', f (a * b) (a' * b') = f a a' * f b b')
    (A : Matrix m m Œ±) (B : Matrix n n Œ≤) :
    det (kroneckerMapBilinear f A B) =
      det (A.map fun a => f a 1) ^ Fintype.card n * det (B.map fun b => f 1 b) ^ Fintype.card m ",":=
  calc
    det (kroneckerMapBilinear f A B) =
        det (kroneckerMapBilinear f A 1 * kroneckerMapBilinear f 1 B) := by
      rw [‚Üê kroneckerMapBilinear_mul_mul f h_comm, Matrix.mul_one, Matrix.one_mul]
    _ = det (blockDiagonal fun _ => A.map fun a => f a 1) *
        det (blockDiagonal fun _ => B.map fun b => f 1 b) := by
      rw [det_mul, ‚Üê diagonal_one, ‚Üê diagonal_one, kroneckerMapBilinear_apply_apply,
        kroneckerMap_diagonal_right _ fun _ => _, kroneckerMapBilinear_apply_apply,
        kroneckerMap_diagonal_left _ fun _ => _, det_reindex_self]
      ¬∑ intro; exact LinearMap.map_zero‚ÇÇ _ _
      ¬∑ intro; exact map_zero _
    _ = _ := by simp_rw [det_blockDiagonal, Finset.prod_const, Finset.card_univ]"
Mathlib/LinearAlgebra/Matrix/Spectrum.lean,Matrix.IsHermitian.det_eq_prod_eigenvalues,det_eq_prod_eigenvalues,aaa7a79ed9b6aeb68b9146319b3798dfc6cbf05e,":= by
  apply mul_left_cancel‚ÇÄ (det_ne_zero_of_left_inverse (A := star (eigenvectorUnitary hA).1) (B := (eigenvectorUnitary hA).1) ((Matrix.mem_unitaryGroup_iff).mp (eigenvectorUnitary hA).2))
  rw [‚Üêdet_mul, spectral_theorem3, det_mul, mul_comm, det_diagonal]
  simp_rw [Function.comp_apply]","error:  unknown identifier 'spectral_theorem3'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.91854
ùïú : Type u_1
inst‚úù¬≤ : RCLike ùïú
n : Type u_2
inst‚úù¬π : Fintype n
A : Matrix n n ùïú
inst‚úù : DecidableEq n
hA : A.IsHermitian
‚ä¢ (star ‚ÜëhA.eigenvectorUnitary * A).det = (star ‚ÜëhA.eigenvectorUnitary).det * ‚àè i : n, ‚Üë(hA.eigenvalues i)","theorem det_eq_prod_eigenvalues : det A = ‚àè i, (hA.eigenvalues i : ùïú) ",":= by
  convert congr_arg det hA.spectral_theorem
  rw [det_mul_right_comm]
  simp"
Mathlib/Algebra/Module/PID.lean,Module.torsion_by_prime_power_decomposition,torsion_by_prime_power_decomposition,5f71dc2104c23870830cd3dd0cd165dd6913a60b,":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ simp only [Nat.zero_eq] at *
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    ¬∑ obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
      clear IH
      have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine' ‚ü®x, h0, _‚ü©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'",error:  simp made no progress,"theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ‚àÉ (d : ‚Ñï) (k : Fin d ‚Üí ‚Ñï), Nonempty <| N ‚âÉ‚Çó[R] ‚®Å i : Fin d, R ‚ß∏ R ‚àô p ^ (k i : ‚Ñï) ",":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    ¬∑ obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
      clear IH
      have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ‚ü®x, h0, ?_‚ü©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'"
Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean,MvPolynomial.weightedTotalDegree_coe,weightedTotalDegree_coe,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  rw [Ne.def, ‚Üê weightedTotalDegree'_eq_bot_iff w p, ‚Üê Ne.def, WithBot.ne_bot_iff_exists] at hp
  obtain ‚ü®m, hm‚ü© := hp
  apply le_antisymm
  ¬∑ simp only [weightedTotalDegree, weightedTotalDegree', Finset.sup_le_iff, WithBot.coe_le_coe]
    intro b
    exact Finset.le_sup
  ¬∑ simp only [weightedTotalDegree]
    have hm' : weightedTotalDegree' w p ‚â§ m := le_of_eq hm.symm
    rw [‚Üê hm]
    simpa [weightedTotalDegree'] using hm'","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.5102 ‚Üí ?m.5102 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.5104
R : Type u_1
M : Type u_2
inst‚úù¬≥ : CommSemiring R
œÉ : Type u_3
inst‚úù¬≤ : AddCommMonoid M
inst‚úù¬π : SemilatticeSup M
inst‚úù : OrderBot M
w : œÉ ‚Üí M
p : MvPolynomial œÉ R
hp : p ‚â† 0
‚ä¢ weightedTotalDegree' w p = ‚Üë(weightedTotalDegree w p)","theorem weightedTotalDegree_coe (w : œÉ ‚Üí M) (p : MvPolynomial œÉ R) (hp : p ‚â† 0) :
    weightedTotalDegree' w p = ‚Üë(weightedTotalDegree w p) ",":= by
  rw [Ne, ‚Üê weightedTotalDegree'_eq_bot_iff w p, ‚Üê Ne, WithBot.ne_bot_iff_exists] at hp
  obtain ‚ü®m, hm‚ü© := hp
  apply le_antisymm
  ¬∑ simp only [weightedTotalDegree, weightedTotalDegree', Finset.sup_le_iff, WithBot.coe_le_coe]
    intro b
    exact Finset.le_sup
  ¬∑ simp only [weightedTotalDegree]
    have hm' : weightedTotalDegree' w p ‚â§ m := le_of_eq hm.symm
    rw [‚Üê hm]
    simpa [weightedTotalDegree'] using hm'"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.cons_append,cons_append,938069ac7c83a4980c46ca108d9947ab788c12ee,":=
  Seq'.cons_append _ _ _",error:  unknown identifier 'Seq'.cons_append',theorem cons_append (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) ,":=
  Seq.cons_append _ _ _"
Mathlib/Topology/Instances/EReal.lean,EReal.nhds_bot_basis,nhds_bot_basis,f3df819bd51d0f3495e887909f4ab5efc2965f66,":= by
  refine nhds_bot_basis.to_hasBasis (fun x hx => ?_) fun _ _ ‚Ü¶ ‚ü®_, bot_lt_coe _, Subset.rfl‚ü©
  rcases exists_rat_btwn_of_lt hx with ‚ü®y, -, hxy‚ü©
  exact ‚ü®_, trivial, Iio_subset_Iio hxy.le‚ü©","error:  application type mismatch
  And.intro (bot_lt_coe ?m.13211)
argument
  bot_lt_coe ?m.13211
has type
  ‚ä• < ‚Üë?m.13211 : Prop
but is expected to have type
  True : Prop
error:  application type mismatch
  exists_rat_btwn_of_lt hx
argument
  hx
has type
  True : Prop
but is expected to have type
  ?m.13450 < ?m.13451 : Prop",theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) ,":= by
  refine _root_.nhds_bot_basis.to_hasBasis (fun x hx => ?_) fun _ _ ‚Ü¶ ‚ü®_, bot_lt_coe _, Subset.rfl‚ü©
  rcases exists_rat_btwn_of_lt hx with ‚ü®y, -, hxy‚ü©
  exact ‚ü®_, trivial, Iio_subset_Iio hxy.le‚ü©"
Mathlib/Analysis/InnerProductSpace/Projection.lean,Dense.eq_of_sub_mem_orthogonal,eq_of_sub_mem_orthogonal,024515f0baa75bef704ce42921ed8103bcd73615,":= by
  rw [dense_iff_topologicalClosure_eq_top, topologicalClosure_eq_top_iff] at hK
  rwa [hK, Submodule.mem_bot, sub_eq_zero] at h","error:  failed to synthesize
  CompleteSpace E
use `set_option diagnostics true` to get diagnostic information
error:  unsolved goals
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Å¥ : _root_.RCLike ùïú
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : NormedAddCommGroup F
inst‚úù¬π : InnerProductSpace ùïú E
inst‚úù : InnerProductSpace ‚Ñù F
K : Submodule ùïú E
x y : E
hK : K.topologicalClosure = ‚ä§
h : x - y ‚àà K·óÆ
‚ä¢ CompleteSpace E",theorem eq_of_sub_mem_orthogonal (hK : Dense (K : Set E)) (h : x - y ‚àà K·óÆ) : x = y ,":=
  sub_eq_zero.1 <| eq_zero_of_mem_orthogonal hK h"
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.getD_leftInvSeq_mul_wordProd,getD_leftInvSeq_mul_wordProd,eb780daf7ddc0b2aff6bd37f400ad1275df42fc8,":= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [‚Üê take_append_drop (j + 1) œâ]
  rw [take_succ]
  obtain lt | le := lt_or_le j œâ.length
  ¬∑ rw [get?_eq_get lt]
    simp only [wordProd_append, wordProd_cons, mul_assoc]
    simp
  ¬∑ rw [get?_eq_none.mpr le]
    simp","error:  unsolved goals
case inl
B : Type u_1
W : Type u_2
inst‚úù : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
œâ : List B
j : ‚Ñï
lt : j < œâ.length
‚ä¢ cs.simple œâ[j] * (cs.wordProd œâ[j]?.toList * cs.wordProd (drop (j + 1) œâ)) = cs.wordProd (drop (j + 1) œâ)
error:  unsolved goals
case inr
B : Type u_1
W : Type u_2
inst‚úù : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
œâ : List B
j : ‚Ñï
le : œâ.length ‚â§ j
‚ä¢ cs.wordProd (take j œâ ++ (œâ[j]?.toList ++ drop (j + 1) œâ)) = cs.wordProd (take j œâ ++ drop (j + 1) œâ)","theorem getD_leftInvSeq_mul_wordProd (œâ : List B) (j : ‚Ñï) :
    ((lis œâ).getD j 1) * œÄ œâ = œÄ (œâ.eraseIdx j) ",":= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [‚Üê take_append_drop (j + 1) œâ]
  rw [take_succ]
  obtain lt | le := lt_or_le j œâ.length
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]
    simp
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_none le]
    simp"
Mathlib/RingTheory/DedekindDomain/Ideal.lean,exists_multiset_prod_cons_le_and_prod_not_le,exists_multiset_prod_cons_le_and_prod_not_le,d14658b4fab8f69219eacfab3f0e2ad2951d7e1c,":= by
  obtain ‚ü®Z‚ÇÄ, hZ‚ÇÄ‚ü© := PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain hNF hI0
  obtain ‚ü®Z, ‚ü®hZI, hprodZ‚ü©, h_eraseZ‚ü© :=
    wellFounded_lt.has_min
      {Z | (Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß (Z.map PrimeSpectrum.asIdeal).prod ‚â† ‚ä•}
      ‚ü®Z‚ÇÄ, hZ‚ÇÄ.1, hZ‚ÇÄ.2‚ü©
  have hZM : Multiset.prod (Z.map PrimeSpectrum.asIdeal) ‚â§ M := le_trans hZI hIM
  have hZ0 : Z ‚â† 0 := by rintro rfl; simp [hM.ne_top] at hZM
  obtain ‚ü®_, hPZ', hPM‚ü© := (hM.isPrime.multiset_prod_le (mt Multiset.map_eq_zero.mp hZ0)).mp hZM
  obtain ‚ü®P, hPZ, rfl‚ü© := Multiset.mem_map.mp hPZ'
  classical
    have := Multiset.map_erase PrimeSpectrum.asIdeal PrimeSpectrum.ext P Z
    obtain ‚ü®hP0, hZP0‚ü© : P.asIdeal ‚â† ‚ä• ‚àß ((Z.erase P).map PrimeSpectrum.asIdeal).prod ‚â† ‚ä• := by
      rwa [Ne.def, ‚Üê Multiset.cons_erase hPZ', Multiset.prod_cons, Ideal.mul_eq_bot, not_or, ‚Üê
        this] at hprodZ
    have hPM' := (P.IsPrime.isMaximal hP0).eq_of_le hM.ne_top hPM
    subst hPM'
    refine ‚ü®Z.erase P, ?_, ?_‚ü©
    ¬∑ convert hZI
      rw [this, Multiset.cons_erase hPZ']
    ¬∑ refine fun h => h_eraseZ (Z.erase P) ‚ü®h, ?_‚ü© (Multiset.erase_lt.mpr hPZ)
      exact hZP0","error:  function expected at
  Ideal.IsPrime.multiset_prod_le (Ideal.IsMaximal.isPrime hM)
term has type
  ?m.161784.prod ‚â§ M ‚Üî ‚àÉ I ‚àà ?m.161784, I ‚â§ M
error:  rcases tactic failed: x‚úù : ?m.161652 is not an inductive datatype","theorem exists_multiset_prod_cons_le_and_prod_not_le [IsDedekindDomain A] (hNF : ¬¨IsField A)
    {I M : Ideal A} (hI0 : I ‚â† ‚ä•) (hIM : I ‚â§ M) [hM : M.IsMaximal] :
    ‚àÉ Z : Multiset (PrimeSpectrum A),
      (M ::‚Çò Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß
        ¬¨Multiset.prod (Z.map PrimeSpectrum.asIdeal) ‚â§ I ",":= by
  obtain ‚ü®Z‚ÇÄ, hZ‚ÇÄ‚ü© := PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain hNF hI0
  obtain ‚ü®Z, ‚ü®hZI, hprodZ‚ü©, h_eraseZ‚ü© :=
    wellFounded_lt.has_min
      {Z | (Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß (Z.map PrimeSpectrum.asIdeal).prod ‚â† ‚ä•}
      ‚ü®Z‚ÇÄ, hZ‚ÇÄ.1, hZ‚ÇÄ.2‚ü©
  obtain ‚ü®_, hPZ', hPM‚ü© := hM.isPrime.multiset_prod_le.mp (hZI.trans hIM)
  obtain ‚ü®P, hPZ, rfl‚ü© := Multiset.mem_map.mp hPZ'
  classical
    have := Multiset.map_erase PrimeSpectrum.asIdeal PrimeSpectrum.ext P Z
    obtain ‚ü®hP0, hZP0‚ü© : P.asIdeal ‚â† ‚ä• ‚àß ((Z.erase P).map PrimeSpectrum.asIdeal).prod ‚â† ‚ä• := by
      rwa [Ne, ‚Üê Multiset.cons_erase hPZ', Multiset.prod_cons, Ideal.mul_eq_bot, not_or, ‚Üê
        this] at hprodZ
    have hPM' := (P.isPrime.isMaximal hP0).eq_of_le hM.ne_top hPM
    subst hPM'
    refine ‚ü®Z.erase P, ?_, ?_‚ü©
    ¬∑ convert hZI
      rw [this, Multiset.cons_erase hPZ']
    ¬∑ refine fun h => h_eraseZ (Z.erase P) ‚ü®h, ?_‚ü© (Multiset.erase_lt.mpr hPZ)
      exact hZP0"
Mathlib/Order/ConditionallyCompleteLattice/Basic.lean,WithTop.isGLB_sInf',isGLB_sInf',3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  constructor
  ¬∑ show ite _ _ _ ‚àà _
    split_ifs with h
    ¬∑ intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exact le_top
      refine some_le_some.2 (csInf_le ?_ ha)
      rcases hs with ‚ü®‚ü®‚ü© | b, hb‚ü©
      ¬∑ exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, ‚Üê top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact some_le_some.1 (hb hc)
  ¬∑ show ite _ _ _ ‚àà _
    split_ifs with h
    ¬∑ intro _ _
      exact le_top
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      ¬∑ refine' some_le_some.2 (le_csInf _ _)
        ¬∑ classical
            contrapose! h
            rintro (‚ü®‚ü© | a) ha
            ¬∑ exact mem_singleton ‚ä§
            ¬∑ exact (not_nonempty_iff_eq_empty.2 h ‚ü®a, ha‚ü©).elim
        ¬∑ intro b hb
          rw [‚Üê some_le_some]
          exact ha hb","error:  function expected at
  h
term has type
  s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.intro.none
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
h : ¬¨(s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s)
a : Œ≤
ha : Option.some a ‚àà s
hb : none ‚àà lowerBounds s
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.none
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
hs : BddBelow s
h : ¬¨(s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s)
ha : none ‚àà lowerBounds s
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.refine'_1
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
hs : BddBelow s
a : Œ≤
ha : Option.some a ‚àà lowerBounds s
h : (fun a ‚Ü¶ ‚Üëa) ‚Åª¬π' s = ‚àÖ
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop","theorem isGLB_sInf' {Œ≤ : Type*} [ConditionallyCompleteLattice Œ≤] {s : Set (WithTop Œ≤)}
    (hs : BddBelow s) : IsGLB s (sInf s) ",":= by
  constructor
  ¬∑ show ite _ _ _ ‚àà _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    ¬∑ intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exact le_top
      refine coe_le_coe.2 (csInf_le ?_ ha)
      rcases hs with ‚ü®‚ü®‚ü© | b, hb‚ü©
      ¬∑ exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, ‚Üê top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact coe_le_coe.1 (hb hc)
  ¬∑ show ite _ _ _ ‚àà _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    ¬∑ intro _ _
      exact le_top
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      ¬∑ refine coe_le_coe.2 (le_csInf ?_ ?_)
        ¬∑ classical
            contrapose! h
            rintro (‚ü®‚ü© | a) ha
            ¬∑ exact mem_singleton ‚ä§
            ¬∑ exact (not_nonempty_iff_eq_empty.2 h ‚ü®a, ha‚ü©).elim
        ¬∑ intro b hb
          rw [‚Üê coe_le_coe]
          exact ha hb"
Mathlib/Topology/Gluing.lean,TopCat.GlueData.MkCore.t_inv,MkCore.t_inv,0ea5bd2e88bc0475765f0292fb709ff692758ac2,":= by
  have := h.cocycle j i j x ?_
  ¬∑ rw [h.t_id] at this
    ¬∑ convert Subtype.eq this
    rw [h.V_id]
    trivial","error:  no goals to be solved
error:  unsolved goals
case refine_1
D : GlueData
h : MkCore
i j : h.J
x : ‚Ü•(h.V j i)
‚ä¢ ‚Üëx ‚àà h.V j j",theorem MkCore.t_inv (h : MkCore) (i j : h.J) (x : h.V j i) : h.t i j ((h.t j i) x) = x ,":= by
  have := h.cocycle j i j x ?_
  ¬∑ rw [h.t_id] at this
    ¬∑ convert Subtype.eq this
  rw [h.V_id]
  trivial"
Mathlib/MeasureTheory/Integral/DivergenceTheorem.lean,MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable_aux‚ÇÅ,integral_divergence_of_hasFDerivWithinAt_off_countable_aux‚ÇÅ,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp only [‚Üê setIntegral_congr_set_ae (Box.coe_ae_eq_Icc _)]
  have A := (Hi.mono_set Box.coe_subset_Icc).hasBoxIntegral ‚ä• rfl
  have B :=
    hasIntegral_GP_divergence_of_forall_hasDerivWithinAt I f f' (s ‚à© Box.Icc I)
      (hs.mono (inter_subset_left _ _)) (fun x hx => Hc _ hx.2) fun x hx =>
      Hd _ ‚ü®hx.1, fun h => hx.2 ‚ü®h, hx.1‚ü©‚ü©
  rw [continuousOn_pi] at Hc
  refine' (A.unique B).trans (sum_congr rfl fun i _ => _)
  refine' congr_arg‚ÇÇ Sub.sub _ _
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.right_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.left_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq","error:  overloaded, errors 
  function expected at
    Finset.inter_subset_left ?m.17305
  term has type
    ?m.17304 ‚àà ?m.17302
  
  function expected at
    Set.inter_subset_left ?m.17442
  term has type
    ?m.17441 ‚àà ?m.17439","theorem integral_divergence_of_hasFDerivWithinAt_off_countable_aux‚ÇÅ (I : Box (Fin (n + 1)))
    (f : ‚Ñù‚Åø‚Å∫¬π ‚Üí E‚Åø‚Å∫¬π)
    (f' : ‚Ñù‚Åø‚Å∫¬π ‚Üí ‚Ñù‚Åø‚Å∫¬π ‚ÜíL[‚Ñù] E‚Åø‚Å∫¬π) (s : Set ‚Ñù‚Åø‚Å∫¬π)
    (hs : s.Countable) (Hc : ContinuousOn f (Box.Icc I))
    (Hd : ‚àÄ x ‚àà (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x)
    (Hi : IntegrableOn (fun x => ‚àë i, f' x (e i) i) (Box.Icc I)) :
    (‚à´ x in Box.Icc I, ‚àë i, f' x (e i) i) =
      ‚àë i : Fin (n + 1),
        ((‚à´ x in Box.Icc (I.face i), f (i.insertNth (I.upper i) x) i) -
          ‚à´ x in Box.Icc (I.face i), f (i.insertNth (I.lower i) x) i) ",":= by
  simp only [‚Üê setIntegral_congr_set_ae (Box.coe_ae_eq_Icc _)]
  have A := (Hi.mono_set Box.coe_subset_Icc).hasBoxIntegral ‚ä• rfl
  have B :=
    hasIntegral_GP_divergence_of_forall_hasDerivWithinAt I f f' (s ‚à© Box.Icc I)
      (hs.mono inter_subset_left) (fun x hx => Hc _ hx.2) fun x hx =>
      Hd _ ‚ü®hx.1, fun h => hx.2 ‚ü®h, hx.1‚ü©‚ü©
  rw [continuousOn_pi] at Hc
  refine (A.unique B).trans (sum_congr rfl fun i _ => ?_)
  refine congr_arg‚ÇÇ Sub.sub ?_ ?_
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.right_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.left_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq"
Mathlib/GroupTheory/Archimedean.lean,AddSubgroup.cyclic_of_min,AddSubgroup.cyclic_of_min,b2c183a4cfb2a6ace4a8f3d43268a15c6e181daf,":= by
  obtain ‚ü®‚ü®a_in, a_pos‚ü©, a_min‚ü© := ha
  refine' le_antisymm _ (H.closure_le.mpr <| by simp [a_in])
  intro g g_in
  obtain ‚ü®k, ‚ü®nonneg, lt‚ü©, _‚ü© := existsUnique_zsmul_near_of_pos' a_pos g
  have h_zero : g - k ‚Ä¢ a = 0 := by
    by_contra h
    have h : a ‚â§ g - k ‚Ä¢ a := by
      refine' a_min ‚ü®_, _‚ü©
      ¬∑ set_like
      ¬∑ exact lt_of_le_of_ne nonneg (Ne.symm h)
    have h' : ¬¨a ‚â§ g - k ‚Ä¢ a := not_le.mpr lt
    contradiction
  simp [sub_eq_zero.mp h_zero, AddSubgroup.mem_closure_singleton]","error:  unknown tactic
error:  unsolved goals
case refine'_1
G : Type u_1
inst‚úù¬π : LinearOrderedAddCommGroup G
inst‚úù : Archimedean G
H : AddSubgroup G
a : G
a_min : a ‚àà lowerBounds {g | g ‚àà H ‚àß 0 < g}
a_in : a ‚àà H
a_pos : 0 < a
g : G
g_in : g ‚àà H
k : ‚Ñ§
right‚úù : ‚àÄ (y : ‚Ñ§), (fun k ‚Ü¶ 0 ‚â§ g - k ‚Ä¢ a ‚àß g - k ‚Ä¢ a < a) y ‚Üí y = k
nonneg : 0 ‚â§ g - k ‚Ä¢ a
lt : g - k ‚Ä¢ a < a
h : ¬¨g - k ‚Ä¢ a = 0
‚ä¢ g - k ‚Ä¢ a ‚àà H
error:  unsolved goals
case refine'_2
G : Type u_1
inst‚úù¬π : LinearOrderedAddCommGroup G
inst‚úù : Archimedean G
H : AddSubgroup G
a : G
a_min : a ‚àà lowerBounds {g | g ‚àà H ‚àß 0 < g}
a_in : a ‚àà H
a_pos : 0 < a
g : G
g_in : g ‚àà H
k : ‚Ñ§
right‚úù : ‚àÄ (y : ‚Ñ§), (fun k ‚Ü¶ 0 ‚â§ g - k ‚Ä¢ a ‚àß g - k ‚Ä¢ a < a) y ‚Üí y = k
nonneg : 0 ‚â§ g - k ‚Ä¢ a
lt : g - k ‚Ä¢ a < a
h : ¬¨g - k ‚Ä¢ a = 0
‚ä¢ 0 < g - k ‚Ä¢ a
error:  unsolved goals
G : Type u_1
inst‚úù¬π : LinearOrderedAddCommGroup G
inst‚úù : Archimedean G
H : AddSubgroup G
a : G
a_min : a ‚àà lowerBounds {g | g ‚àà H ‚àß 0 < g}
a_in : a ‚àà H
a_pos : 0 < a
g : G
g_in : g ‚àà H
k : ‚Ñ§
right‚úù : ‚àÄ (y : ‚Ñ§), (fun k ‚Ü¶ 0 ‚â§ g - k ‚Ä¢ a ‚àß g - k ‚Ä¢ a < a) y ‚Üí y = k
nonneg : 0 ‚â§ g - k ‚Ä¢ a
lt : g - k ‚Ä¢ a < a
h‚úù : ¬¨g - k ‚Ä¢ a = 0
h : a ‚â§ g - k ‚Ä¢ a
‚ä¢ False
error:  unsolved goals
case intro.intro.intro.intro.intro
G : Type u_1
inst‚úù¬π : LinearOrderedAddCommGroup G
inst‚úù : Archimedean G
H : AddSubgroup G
a : G
a_min : a ‚àà lowerBounds {g | g ‚àà H ‚àß 0 < g}
a_in : a ‚àà H
a_pos : 0 < a
g : G
g_in : g ‚àà H
k : ‚Ñ§
right‚úù : ‚àÄ (y : ‚Ñ§), (fun k ‚Ü¶ 0 ‚â§ g - k ‚Ä¢ a ‚àß g - k ‚Ä¢ a < a) y ‚Üí y = k
nonneg : 0 ‚â§ g - k ‚Ä¢ a
lt : g - k ‚Ä¢ a < a
h_zero : g - k ‚Ä¢ a = 0
‚ä¢ g ‚àà closure {a}","theorem AddSubgroup.cyclic_of_min {H : AddSubgroup G} {a : G}
    (ha : IsLeast { g : G | g ‚àà H ‚àß 0 < g } a) : H = AddSubgroup.closure {a} ",":= by
  obtain ‚ü®‚ü®a_in, a_pos‚ü©, a_min‚ü© := ha
  refine le_antisymm ?_ (H.closure_le.mpr <| by simp [a_in])
  intro g g_in
  obtain ‚ü®k, ‚ü®nonneg, lt‚ü©, _‚ü© := existsUnique_zsmul_near_of_pos' a_pos g
  have h_zero : g - k ‚Ä¢ a = 0 := by
    by_contra h
    have h : a ‚â§ g - k ‚Ä¢ a := by
      refine a_min ‚ü®?_, ?_‚ü©
      ¬∑ exact AddSubgroup.sub_mem H g_in (AddSubgroup.zsmul_mem H a_in k)
      ¬∑ exact lt_of_le_of_ne nonneg (Ne.symm h)
    have h' : ¬¨a ‚â§ g - k ‚Ä¢ a := not_le.mpr lt
    contradiction
  simp [sub_eq_zero.mp h_zero, AddSubgroup.mem_closure_singleton]"
Mathlib/MeasureTheory/Decomposition/SignedLebesgue.lean,MeasureTheory.SignedMeasure.singularPart_add_withDensity_rnDeriv_eq,singularPart_add_withDensity_rnDeriv_eq,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  conv_rhs =>
    rw [‚Üê toSignedMeasure_toJordanDecomposition s, JordanDecomposition.toSignedMeasure]
  rw [singularPart, rnDeriv,
    withDensity·µ•_sub' (integrable_toReal_of_lintegral_ne_top _ _)
      (integrable_toReal_of_lintegral_ne_top _ _),
    withDensity·µ•_toReal, withDensity·µ•_toReal, sub_eq_add_neg, sub_eq_add_neg,
    add_comm (s.toJordanDecomposition.posPart.singularPart Œº).toSignedMeasure, ‚Üê add_assoc,
    add_assoc (-(s.toJordanDecomposition.negPart.singularPart Œº).toSignedMeasure),
    ‚Üê toSignedMeasure_add, add_comm, ‚Üê add_assoc, ‚Üê neg_add, ‚Üê toSignedMeasure_add, add_comm,
    ‚Üê sub_eq_add_neg]
  convert rfl
  ¬∑ exact s.toJordanDecomposition.posPart.haveLebesgueDecomposition_add Œº
  ¬∑ rw [add_comm]
    exact s.toJordanDecomposition.negPart.haveLebesgueDecomposition_add Œº
  all_goals
    first
    | exact (lintegral_rnDeriv_lt_top _ _).ne
    | measurability",error:  failed to rewrite using equation theorems for 'MeasureTheory.SignedMeasure.rnDeriv',"theorem singularPart_add_withDensity_rnDeriv_eq [s.HaveLebesgueDecomposition Œº] :
    s.singularPart Œº + Œº.withDensity·µ• (s.rnDeriv Œº) = s ",":= by
  conv_rhs =>
    rw [‚Üê toSignedMeasure_toJordanDecomposition s, JordanDecomposition.toSignedMeasure]
  rw [singularPart, rnDeriv_def,
    withDensity·µ•_sub' (integrable_toReal_of_lintegral_ne_top _ _)
      (integrable_toReal_of_lintegral_ne_top _ _),
    withDensity·µ•_toReal, withDensity·µ•_toReal, sub_eq_add_neg, sub_eq_add_neg,
    add_comm (s.toJordanDecomposition.posPart.singularPart Œº).toSignedMeasure, ‚Üê add_assoc,
    add_assoc (-(s.toJordanDecomposition.negPart.singularPart Œº).toSignedMeasure),
    ‚Üê toSignedMeasure_add, add_comm, ‚Üê add_assoc, ‚Üê neg_add, ‚Üê toSignedMeasure_add, add_comm,
    ‚Üê sub_eq_add_neg]
  ¬∑ convert rfl
    ¬∑ exact s.toJordanDecomposition.posPart.haveLebesgueDecomposition_add Œº
    ¬∑ rw [add_comm]
      exact s.toJordanDecomposition.negPart.haveLebesgueDecomposition_add Œº
  all_goals
    first
    | exact (lintegral_rnDeriv_lt_top _ _).ne
    | measurability"
Mathlib/Data/Fin/Basic.lean,Fin.eq_one_of_neq_zero,eq_one_of_neq_zero,1fe877185360058a7e1ea01587273cca55ba199a,":=
  fin_two_eq_of_eq_zero_iff (by simpa only [iff_false] using hi)","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Fin.val_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  type mismatch
  h‚úù
has type
  i ‚â† 0 : Prop
but is expected to have type
  i = 0 ‚Üî 1 = 0 : Prop",lemma eq_one_of_neq_zero (i : Fin 2) (hi : i ‚â† 0) : i = 1 ,":=
  fin_two_eq_of_eq_zero_iff (by simpa only [one_eq_zero_iff, succ.injEq, iff_false] using hi)"
Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean,Complex.Gamma‚Ñù_div_Gamma‚Ñù_one_sub,Gamma‚Ñù_div_Gamma‚Ñù_one_sub,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  have : Gamma‚Ñù (s + 1) ‚â† 0 := by
    simpa only [Ne.def, Gamma‚Ñù_eq_zero_iff, not_exists, ‚Üê eq_sub_iff_add_eq,
      sub_eq_add_neg, ‚Üê neg_add]
  calc Gamma‚Ñù s / Gamma‚Ñù (1 - s)
  _ = (Gamma‚Ñù s * Gamma‚Ñù (s + 1)) / (Gamma‚Ñù (1 - s) * Gamma‚Ñù (1 + s)) := by
    rw [add_comm 1 s, mul_comm (Gamma‚Ñù (1 - s)) (Gamma‚Ñù (s + 1)), ‚Üê div_div,
      mul_div_cancel_right‚ÇÄ _ this]
  _ = (2 * (2 * œÄ) ^ (-s) * Gamma s) / ((cos (œÄ * s / 2))‚Åª¬π) := by
    rw [Gamma‚Ñù_one_sub_mul_Gamma‚Ñù_one_add, Gamma‚Ñù_mul_Gamma‚Ñù_add_one, Gamma‚ÑÇ_def]
  _ = _ := by rw [Gamma‚ÑÇ_def, div_eq_mul_inv, inv_inv]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.71491 ‚Üí ?m.71491 ‚Üí Prop
error:  tactic 'assumption' failed
s : ‚ÑÇ
hs : ‚àÄ (n : ‚Ñï), s ‚â† -(2 * ‚Üën + 1)
‚ä¢ (s + 1).Gamma‚Ñù ‚â† 0","lemma Gamma‚Ñù_div_Gamma‚Ñù_one_sub {s : ‚ÑÇ} (hs : ‚àÄ (n : ‚Ñï), s ‚â† -(2 * n + 1)) :
    Gamma‚Ñù s / Gamma‚Ñù (1 - s) = Gamma‚ÑÇ s * cos (œÄ * s / 2) ",":= by
  have : Gamma‚Ñù (s + 1) ‚â† 0 := by
    simpa only [Ne, Gamma‚Ñù_eq_zero_iff, not_exists, ‚Üê eq_sub_iff_add_eq,
      sub_eq_add_neg, ‚Üê neg_add]
  calc Gamma‚Ñù s / Gamma‚Ñù (1 - s)
  _ = (Gamma‚Ñù s * Gamma‚Ñù (s + 1)) / (Gamma‚Ñù (1 - s) * Gamma‚Ñù (1 + s)) := by
    rw [add_comm 1 s, mul_comm (Gamma‚Ñù (1 - s)) (Gamma‚Ñù (s + 1)), ‚Üê div_div,
      mul_div_cancel_right‚ÇÄ _ this]
  _ = (2 * (2 * œÄ) ^ (-s) * Gamma s) / ((cos (œÄ * s / 2))‚Åª¬π) := by
    rw [Gamma‚Ñù_one_sub_mul_Gamma‚Ñù_one_add, Gamma‚Ñù_mul_Gamma‚Ñù_add_one, Gamma‚ÑÇ_def]
  _ = _ := by rw [Gamma‚ÑÇ_def, div_eq_mul_inv, inv_inv]"
Mathlib/GroupTheory/Perm/Cycle/Basic.lean,Equiv.Perm.IsCycle.eq_on_support_inter_nonempty_congr,IsCycle.eq_on_support_inter_nonempty_congr,448e347a46707ed566863dec645b6eeb6829163a,":= by
  have hx'' : x ‚àà g.support := by rwa [mem_support, ‚Üê hx, ‚Üê mem_support]
  have : f.support ‚äÜ g.support := by
    intro y hy
    obtain ‚ü®k, rfl‚ü© := hf.exists_pow_eq (mem_support.mp hx') (mem_support.mp hy)
    rwa [pow_eq_on_of_mem_support h _ _ (mem_inter_of_mem hx' hx''), pow_apply_mem_support]
  rw [(inter_eq_left_iff_subset _ _).mpr this] at h
  exact hf.support_congr hg this h","error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.121153
Œπ : Type u_1
Œ± : Type u_2
Œ≤ : Type u_3
f g : Perm Œ±
x y : Œ±
inst‚úù¬π : DecidableEq Œ±
inst‚úù : Fintype Œ±
hf : f.IsCycle
hg : g.IsCycle
h : ‚àÄ x ‚àà f.support ‚à© g.support, f x = g x
hx : f x = g x
hx' : x ‚àà f.support
hx'' : x ‚àà g.support
this : f.support ‚äÜ g.support
‚ä¢ f = g","theorem IsCycle.eq_on_support_inter_nonempty_congr (hf : IsCycle f) (hg : IsCycle g)
    (h : ‚àÄ x ‚àà f.support ‚à© g.support, f x = g x)
    (hx : f x = g x) (hx' : x ‚àà f.support) : f = g ",":= by
  have hx'' : x ‚àà g.support := by rwa [mem_support, ‚Üê hx, ‚Üê mem_support]
  have : f.support ‚äÜ g.support := by
    intro y hy
    obtain ‚ü®k, rfl‚ü© := hf.exists_pow_eq (mem_support.mp hx') (mem_support.mp hy)
    rwa [pow_eq_on_of_mem_support h _ _ (mem_inter_of_mem hx' hx''), pow_apply_mem_support]
  rw [inter_eq_left.mpr this] at h
  exact hf.support_congr hg this h"
Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean,CategoryTheory.comp_rightAdjointMate,comp_rightAdjointMate,fc2d8a7fd4fce039a4cdee894cdb15ac1920b96c,":= by
  rw [rightAdjointMate_comp]
  simp only [rightAdjointMate, comp_tensor_id, Iso.cancel_iso_inv_left, id_tensor_comp,
    Category.assoc]
  symm
  iterate 5
    trans
    rw [‚Üê Category.id_comp g, tensor_comp]
  rw [‚Üê Category.assoc]
  symm
  iterate 2
    trans
    rw [‚Üê Category.assoc]
  apply eq_whisker
  repeat'
    rw [‚Üê @id_tensor_comp C]
  congr 1
  rw [‚Üê id_tensor_comp_tensor_id (Œª_ (X·òÅ)).hom g, id_tensor_rightUnitor_inv, Category.assoc,
    Category.assoc, rightUnitor_inv_naturality_assoc, ‚Üê associator_naturality_assoc, tensor_id,
    tensor_id_comp_id_tensor_assoc, ‚Üê associator_naturality_assoc]
  slice_rhs 2 3 =>
    rw [‚Üê tensor_comp, tensor_id, Category.comp_id, ‚Üê Category.id_comp (Œ∑_ Y (Y·òÅ)), tensor_comp]
  rw [‚Üê id_tensor_comp_tensor_id _ (Œ∑_ Y (Y·òÅ)), ‚Üê tensor_id]
  repeat' rw [@Category.assoc C]
  rw [pentagon_hom_inv_assoc, ‚Üê associator_naturality_assoc, associator_inv_naturality_assoc]
  slice_rhs 5 7 => rw [‚Üê comp_tensor_id, ‚Üê comp_tensor_id, evaluation_coevaluation, comp_tensor_id]
  rw [associator_inv_naturality_assoc]
  slice_rhs 4 5 => rw [‚Üê tensor_comp, leftUnitor_naturality, tensor_comp]
  repeat' rw [@Category.assoc C]
  rw [triangle_assoc_comp_right_inv_assoc, ‚Üê leftUnitor_tensor_assoc, leftUnitor_naturality_assoc,
    unitors_equal, ‚Üê Category.assoc, ‚Üê Category.assoc]
  simp","warning:  @coevaluation does not have a doc string
warning:  @evaluation does not have a doc string
warning:  @leftDual does not have a doc string
warning:  @rightDual does not have a doc string
warning:  @rightAdjointMate does not have a doc string
warning:  @leftAdjointMate does not have a doc string
error:  tactic 'apply' failed, failed to unify
  ?f ‚â´ ?h = ?g ‚â´ ?h
with
  ((Z·òÅ ‚óÅ Œ∑_ X X·òÅ ‚â´ Z·òÅ ‚óÅ (f ‚â´ g) ‚ñ∑ X·òÅ) ‚â´ (Œ±_ Z·òÅ Z X·òÅ).inv) ‚â´ Œµ_ Z Z·òÅ ‚ñ∑ X·òÅ ‚â´ (Œª_ X·òÅ).hom =
    (Z·òÅ ‚óÅ Œ∑_ Y Y·òÅ ‚â´
        Z·òÅ ‚óÅ
          ((ùüô Y ‚äó (œÅ_ Y·òÅ).inv) ‚â´
            (ùüô Y ‚äó Y·òÅ ‚óÅ Œ∑_ X X·òÅ) ‚â´
              (ùüô Y ‚äó Y·òÅ ‚óÅ f ‚ñ∑ X·òÅ) ‚â´ (ùüô Y ‚äó (Œ±_ Y·òÅ Y X·òÅ).inv) ‚â´ (ùüô Y ‚äó Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ) ‚â´ (g ‚äó (Œª_ X·òÅ).hom))) ‚â´
      (Œ±_ Z·òÅ Z X·òÅ).inv ‚â´ Œµ_ Z Z·òÅ ‚ñ∑ X·òÅ ‚â´ (Œª_ X·òÅ).hom
C : Type u‚ÇÅ
inst‚úù‚Å¥ : Category.{v‚ÇÅ, u‚ÇÅ} C
inst‚úù¬≥ : MonoidalCategory C
X Y Z : C
inst‚úù¬≤ : HasRightDual X
inst‚úù¬π : HasRightDual Y
inst‚úù : HasRightDual Z
f : X ‚ü∂ Y
g : Y ‚ü∂ Z
‚ä¢ ((Z·òÅ ‚óÅ Œ∑_ X X·òÅ ‚â´ Z·òÅ ‚óÅ (f ‚â´ g) ‚ñ∑ X·òÅ) ‚â´ (Œ±_ Z·òÅ Z X·òÅ).inv) ‚â´ Œµ_ Z Z·òÅ ‚ñ∑ X·òÅ ‚â´ (Œª_ X·òÅ).hom =
    (Z·òÅ ‚óÅ Œ∑_ Y Y·òÅ ‚â´
        Z·òÅ ‚óÅ
          ((ùüô Y ‚äó (œÅ_ Y·òÅ).inv) ‚â´
            (ùüô Y ‚äó Y·òÅ ‚óÅ Œ∑_ X X·òÅ) ‚â´
              (ùüô Y ‚äó Y·òÅ ‚óÅ f ‚ñ∑ X·òÅ) ‚â´ (ùüô Y ‚äó (Œ±_ Y·òÅ Y X·òÅ).inv) ‚â´ (ùüô Y ‚äó Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ) ‚â´ (g ‚äó (Œª_ X·òÅ).hom))) ‚â´
      (Œ±_ Z·òÅ Z X·òÅ).inv ‚â´ Œµ_ Z Z·òÅ ‚ñ∑ X·òÅ ‚â´ (Œª_ X·òÅ).hom","theorem comp_rightAdjointMate {X Y Z : C} [HasRightDual X] [HasRightDual Y] [HasRightDual Z]
    {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g)·òÅ = g·òÅ ‚â´ f·òÅ ",":= by
  rw [rightAdjointMate_comp]
  simp only [rightAdjointMate, comp_whiskerRight]
  simp only [‚Üê Category.assoc]; congr 3; simp only [Category.assoc]
  simp only [‚Üê MonoidalCategory.whiskerLeft_comp]; congr 2
  symm
  calc
    _ = ùüô _ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ ùüô_ C ‚â´ (Y ‚äó Y·òÅ) ‚óÅ Œ∑_ X X·òÅ) ‚äó‚â´ Y ‚óÅ Y·òÅ ‚óÅ f ‚ñ∑ X·òÅ ‚äó‚â´
        Y ‚óÅ Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [tensorHom_def']; coherence
    _ = Œ∑_ X X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ (X ‚äó X·òÅ) ‚â´ (Y ‚äó Y·òÅ) ‚óÅ f ‚ñ∑ X·òÅ) ‚äó‚â´
        Y ‚óÅ Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [‚Üê whisker_exchange]; coherence
    _ = Œ∑_ X X·òÅ ‚äó‚â´ f ‚ñ∑ X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ Y ‚äó‚â´ Y ‚óÅ Œµ_ Y Y·òÅ) ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [‚Üê whisker_exchange]; coherence
    _ = Œ∑_ X X·òÅ ‚â´ f ‚ñ∑ X·òÅ ‚â´ g ‚ñ∑ X·òÅ := by
      rw [evaluation_coevaluation'']; coherence"
Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean,MvPolynomial.weightedHomogeneousSubmodule_mul,weightedHomogeneousSubmodule_mul,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  classical
  rw [Submodule.mul_le]
  intro œÜ hœÜ œà hœà c hc
  rw [coeff_mul] at hc
  obtain ‚ü®‚ü®d, e‚ü©, hde, H‚ü© := Finset.exists_ne_zero_of_sum_ne_zero hc
  have aux : coeff d œÜ ‚â† 0 ‚àß coeff e œà ‚â† 0 := by
    contrapose! H
    by_cases h : coeff d œÜ = 0 <;>
      simp_all only [Ne.def, not_false_iff, zero_mul, mul_zero]
  rw [‚Üê mem_antidiagonal.mp hde, ‚Üê hœÜ aux.1, ‚Üê hœà aux.2, map_add]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.29296 ‚Üí ?m.29296 ‚Üí Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.29928 ‚Üí ?m.29928 ‚Üí Prop
error:  unsolved goals
case neg
R : Type u_1
M : Type u_2
inst‚úù¬π : CommSemiring R
œÉ : Type u_3
inst‚úù : AddCommMonoid M
w : œÉ ‚Üí M
m n : M
œÜ : MvPolynomial œÉ R
hœÜ : œÜ ‚àà weightedHomogeneousSubmodule R w m
œà : MvPolynomial œÉ R
hœà : œà ‚àà weightedHomogeneousSubmodule R w n
c : œÉ ‚Üí‚ÇÄ ‚Ñï
hc : ‚àë x ‚àà antidiagonal c, coeff x.1 œÜ * coeff x.2 œà ‚â† 0
d e : œÉ ‚Üí‚ÇÄ ‚Ñï
hde : (d, e) ‚àà antidiagonal c
H : coeff d œÜ ‚â† 0 ‚Üí coeff e œà = 0
h : ¬¨coeff d œÜ = 0
‚ä¢ coeff d œÜ * coeff e œà = 0","theorem weightedHomogeneousSubmodule_mul (w : œÉ ‚Üí M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ‚â§
      weightedHomogeneousSubmodule R w (m + n) ",":= by
  classical
  rw [Submodule.mul_le]
  intro œÜ hœÜ œà hœà c hc
  rw [coeff_mul] at hc
  obtain ‚ü®‚ü®d, e‚ü©, hde, H‚ü© := Finset.exists_ne_zero_of_sum_ne_zero hc
  have aux : coeff d œÜ ‚â† 0 ‚àß coeff e œà ‚â† 0 := by
    contrapose! H
    by_cases h : coeff d œÜ = 0 <;>
      simp_all only [Ne, not_false_iff, zero_mul, mul_zero]
  rw [‚Üê mem_antidiagonal.mp hde, ‚Üê hœÜ aux.1, ‚Üê hœà aux.2, map_add]"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.hausdorffMeasure_pi_real,hausdorffMeasure_pi_real,7dbc4ee943ff99bb5a359e820806969fa45b18b0,":= by
  classical
  refine (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)
    (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) ?_).symm
  simp only [mem_iUnion, mem_singleton_iff]
  intro s hs
  choose a b H using hs
  obtain rfl : s = fun i => Ioo (Œ± := ‚Ñù) (a i) (b i) := funext fun i => (H i).2
  replace H := fun i => (H i).1
  apply le_antisymm _
  ¬∑ have Hle : volume ‚â§ (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) := by
      refine' le_hausdorffMeasure _ _ ‚àû ENNReal.coe_lt_top fun s _ => _
      rw [ENNReal.rpow_nat_cast]
      exact Real.volume_pi_le_diam_pow s
    rw [‚Üê volume_pi_pi fun i => Ioo (a i : ‚Ñù) (b i)]
    exact Measure.le_iff'.1 Hle _
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := fun i => by
    simpa only [sub_nonneg, Rat.cast_le] using (H i).le
  let Œ≥ := fun n : ‚Ñï => ‚àÄ i : Œπ, Fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä
  let t : ‚àÄ n : ‚Ñï, Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f =>
    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)
  have A : Tendsto (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) atTop (ùìù 0) := by
    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]
  have B : ‚àÄ·∂† n in atTop, ‚àÄ i : Œ≥ n, diam (t n i) ‚â§ 1 / n := by
    refine' eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
    intro f
    refine' diam_pi_le_of_le fun b => _
    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel', ENNReal.ofReal_one, ENNReal.ofReal_coe_nat]
  have C : ‚àÄ·∂† n in atTop, (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ i : Œ≥ n, t n i := by
    refine' eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
    have npos : (0 : ‚Ñù) < n := Nat.cast_pos.2 hn
    intro x hx
    simp only [mem_Ioo, mem_univ_pi] at hx
    simp only [mem_iUnion, mem_Ioo, mem_univ_pi]
    let f : Œ≥ n := fun i =>
      ‚ü®‚åä(x i - a i) * n‚åã‚Çä, by
        apply Nat.floor_lt_ceil_of_lt_of_pos
        ¬∑ refine' (mul_lt_mul_right npos).2 _
          simp only [(hx i).right, sub_lt_sub_iff_right]
        ¬∑ refine' mul_pos _ npos
          simpa only [Rat.cast_lt, sub_pos] using H i‚ü©
    refine' ‚ü®f, fun i => ‚ü®_, _‚ü©‚ü©
    ¬∑ calc
        (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + (x i - a i) * n / n := by
          refine' add_le_add le_rfl ((div_le_div_right npos).2 _)
          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
        _ = x i := by field_simp [npos.ne']
    ¬∑ calc
        x i = (a i : ‚Ñù) + (x i - a i) * n / n := by field_simp [npos.ne']
        _ ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n :=
          add_le_add le_rfl ((div_le_div_right npos).2 (Nat.lt_floor_add_one _).le)
  calc
    ŒºH[Fintype.card Œπ] (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚â§
        liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, diam (t n i) ^ ((Fintype.card Œπ) : ‚Ñù)) atTop :=
      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : ‚Ñù) (b i))
        (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) A t B C
    _ ‚â§ liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, (1 / (n : ‚Ñù‚â•0‚àû)) ^ Fintype.card Œπ) atTop := by
      refine' liminf_le_liminf _ _
      ¬∑ filter_upwards [B] with _ hn
        apply Finset.sum_le_sum fun i _ => _
        simp only [ENNReal.rpow_nat_cast]
        intros i _
        exact pow_le_pow_left' (hn i) _
      ¬∑ isBoundedDefault
    _ = liminf (fun n : ‚Ñï => ‚àè i : Œπ, (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) atTop := by
      simp only [Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
    _ = ‚àè i : Œπ, volume (Ioo (a i : ‚Ñù) (b i)) := by
      simp only [Real.volume_Ioo]
      apply Tendsto.liminf_eq
      refine' ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => _) fun i _ => _
      ¬∑ apply
          Tendsto.congr' _
            ((ENNReal.continuous_ofReal.tendsto _).comp
              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_nat_cast_atTop_atTop))
        apply eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
        intros n hn
        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,
          ENNReal.ofReal_coe_nat]
      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne.def, not_false_iff]","warning:  `ENNReal.rpow_nat_cast` has been deprecated, use `ENNReal.rpow_natCast` instead
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
warning:  `ENNReal.ofReal_coe_nat` has been deprecated, use `ENNReal.ofReal_natCast` instead
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  i ‚àà univ ‚Üí x i ‚àà (fun i ‚Ü¶ Icc (‚Üë(a i) + ‚Üë‚Üë(f i) / ‚Üën) (‚Üë(a i) + (‚Üë‚Üë(f i) + 1) / ‚Üën)) i
error:  no goals to be solved
warning:  `ENNReal.rpow_nat_cast` has been deprecated, use `ENNReal.rpow_natCast` instead
error:  unsolved goals
Œπ‚úù : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù‚Å∂ : EMetricSpace X
inst‚úù‚Åµ : EMetricSpace Y
inst‚úù‚Å¥ : MeasurableSpace X
inst‚úù¬≥ : BorelSpace X
inst‚úù¬≤ : MeasurableSpace Y
inst‚úù¬π : BorelSpace Y
Œπ : Type u_4
inst‚úù : Fintype Œπ
a b : Œπ ‚Üí ‚Ñö
H : ‚àÄ (i : Œπ), a i < b i
I : ‚àÄ (i : Œπ), 0 ‚â§ ‚Üë(b i) - ‚Üë(a i)
Œ≥ : ‚Ñï ‚Üí Type u_4 := fun n ‚Ü¶ (i : Œπ) ‚Üí Fin ‚åà(‚Üë(b i) - ‚Üë(a i)) * ‚Üën‚åâ‚Çä
t : (n : ‚Ñï) ‚Üí Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f ‚Ü¶ univ.pi fun i ‚Ü¶ Icc (‚Üë(a i) + ‚Üë‚Üë(f i) / ‚Üën) (‚Üë(a i) + (‚Üë‚Üë(f i) + 1) / ‚Üën)
A : Tendsto (fun n ‚Ü¶ 1 / ‚Üën) atTop (ùìù 0)
B : ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ (i : Œ≥ n), diam (t n i) ‚â§ 1 / ‚Üën
C : ‚àÄ·∂† (n : ‚Ñï) in atTop, (univ.pi fun i ‚Ü¶ Ioo ‚Üë(a i) ‚Üë(b i)) ‚äÜ ‚ãÉ i, t n i
‚ä¢ liminf (fun n ‚Ü¶ ‚Üë(Fintype.card (Œ≥ n)) * (‚Üën)‚Åª¬π ^ Fintype.card Œπ) atTop =
    liminf (fun n ‚Ü¶ (‚àè x : Œπ, ‚Üë‚åà(‚Üë(b x) - ‚Üë(a x)) * ‚Üën‚åâ‚Çä) * (‚Üën)‚Åª¬π ^ Fintype.card Œπ) atTop
warning:  `tendsto_nat_cast_atTop_atTop` has been deprecated, use `tendsto_natCast_atTop_atTop` instead
warning:  `ENNReal.ofReal_coe_nat` has been deprecated, use `ENNReal.ofReal_natCast` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.246785 ‚Üí ?m.246785 ‚Üí Prop
error:  simp made no progress","theorem hausdorffMeasure_pi_real {Œπ : Type*} [Fintype Œπ] :
    (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) = volume ",":= by
  classical
  refine (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)
    (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) ?_).symm
  simp only [mem_iUnion, mem_singleton_iff]
  intro s hs
  choose a b H using hs
  obtain rfl : s = fun i => Ioo (Œ± := ‚Ñù) (a i) (b i) := funext fun i => (H i).2
  replace H := fun i => (H i).1
  apply le_antisymm _
  ¬∑ have Hle : volume ‚â§ (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) := by
      refine le_hausdorffMeasure _ _ ‚àû ENNReal.coe_lt_top fun s _ => ?_
      rw [ENNReal.rpow_natCast]
      exact Real.volume_pi_le_diam_pow s
    rw [‚Üê volume_pi_pi fun i => Ioo (a i : ‚Ñù) (b i)]
    exact Measure.le_iff'.1 Hle _
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := fun i => by
    simpa only [sub_nonneg, Rat.cast_le] using (H i).le
  let Œ≥ := fun n : ‚Ñï => ‚àÄ i : Œπ, Fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä
  let t : ‚àÄ n : ‚Ñï, Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f =>
    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)
  have A : Tendsto (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) atTop (ùìù 0) := by
    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]
  have B : ‚àÄ·∂† n in atTop, ‚àÄ i : Œ≥ n, diam (t n i) ‚â§ 1 / n := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => ?_‚ü©
    intro f
    refine diam_pi_le_of_le fun b => ?_
    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel_left, ENNReal.ofReal_one, ENNReal.ofReal_natCast]
  have C : ‚àÄ·∂† n in atTop, (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ i : Œ≥ n, t n i := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => ?_‚ü©
    have npos : (0 : ‚Ñù) < n := Nat.cast_pos.2 hn
    intro x hx
    simp only [mem_Ioo, mem_univ_pi] at hx
    simp only [t, mem_iUnion, mem_Ioo, mem_univ_pi]
    let f : Œ≥ n := fun i =>
      ‚ü®‚åä(x i - a i) * n‚åã‚Çä, by
        apply Nat.floor_lt_ceil_of_lt_of_pos
        ¬∑ refine (mul_lt_mul_right npos).2 ?_
          simp only [(hx i).right, sub_lt_sub_iff_right]
        ¬∑ refine mul_pos ?_ npos
          simpa only [Rat.cast_lt, sub_pos] using H i‚ü©
    refine ‚ü®f, fun i => ‚ü®?_, ?_‚ü©‚ü©
    ¬∑ calc
        (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + (x i - a i) * n / n := by
          gcongr
          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
        _ = x i := by field_simp [npos.ne']
    ¬∑ calc
        x i = (a i : ‚Ñù) + (x i - a i) * n / n := by field_simp [npos.ne']
        _ ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n := by
          gcongr
          exact (Nat.lt_floor_add_one _).le
  calc
    ŒºH[Fintype.card Œπ] (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚â§
        liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, diam (t n i) ^ ((Fintype.card Œπ) : ‚Ñù)) atTop :=
      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : ‚Ñù) (b i))
        (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) A t B C
    _ ‚â§ liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, (1 / (n : ‚Ñù‚â•0‚àû)) ^ Fintype.card Œπ) atTop := by
      refine liminf_le_liminf ?_ ?_
      ¬∑ filter_upwards [B] with _ hn
        apply Finset.sum_le_sum fun i _ => _
        simp only [ENNReal.rpow_natCast]
        intros i _
        exact pow_le_pow_left' (hn i) _
      ¬∑ isBoundedDefault
    _ = liminf (fun n : ‚Ñï => ‚àè i : Œπ, (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) atTop := by
      simp only [Œ≥, Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
    _ = ‚àè i : Œπ, volume (Ioo (a i : ‚Ñù) (b i)) := by
      simp only [Real.volume_Ioo]
      apply Tendsto.liminf_eq
      refine ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => ?_) fun i _ => ?_
      ¬∑ apply
          Tendsto.congr' _
            ((ENNReal.continuous_ofReal.tendsto _).comp
              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_natCast_atTop_atTop))
        apply eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
        intros n hn
        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,
          ENNReal.ofReal_natCast]
      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne, not_false_iff]"
Mathlib/Algebra/Polynomial/Module/Basic.lean,PolynomialModule.smul_single_apply,smul_single_apply,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' f with p q hp hq
  ¬∑ rw [add_smul, Finsupp.add_apply, hp, hq, coeff_add, add_smul]
    split_ifs
    exacts [rfl, zero_add 0]
  ¬∑ rw [monomial_smul_single, single_apply, coeff_monomial, ite_smul, zero_smul]
    by_cases h : i ‚â§ n
    ¬∑ simp_rw [eq_tsub_iff_add_eq_of_le h, if_pos h]
    ¬∑ rw [if_neg h, ite_eq_right_iff]
      intro e
      exfalso
      linarith","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?r + ?s) ‚Ä¢ ?x
case ofFinsupp
R : Type u_1
M : Type u_2
inst‚úù‚Å∂ : CommRing R
inst‚úù‚Åµ : AddCommGroup M
inst‚úù‚Å¥ : Module R M
I : Ideal R
S : Type u_3
inst‚úù¬≥ : CommSemiring S
inst‚úù¬≤ : Algebra S R
inst‚úù¬π : Module S M
inst‚úù : IsScalarTower S R M
i : ‚Ñï
m : M
n : ‚Ñï
p : AddMonoidAlgebra R ‚Ñï
‚ä¢ ({ toFinsupp := p } ‚Ä¢ (single R i) m) n = if i ‚â§ n then { toFinsupp := p }.coeff (n - i) ‚Ä¢ m else 0
error:  no goals to be solved","theorem smul_single_apply (i : ‚Ñï) (f : R[X]) (m : M) (n : ‚Ñï) :
    (f ‚Ä¢ single R i m) n = ite (i ‚â§ n) (f.coeff (n - i) ‚Ä¢ m) 0 ",":= by
  induction' f using Polynomial.induction_on' with p q hp hq
  ¬∑ rw [add_smul, Finsupp.add_apply, hp, hq, coeff_add, add_smul]
    split_ifs
    exacts [rfl, zero_add 0]
  ¬∑ rw [monomial_smul_single, single_apply, coeff_monomial, ite_smul, zero_smul]
    by_cases h : i ‚â§ n
    ¬∑ simp_rw [eq_tsub_iff_add_eq_of_le h, if_pos h]
    ¬∑ rw [if_neg h, ite_eq_right_iff]
      intro e
      exfalso
      linarith"
Mathlib/NumberTheory/Pell.lean,Pell.Solution‚ÇÅ.ext,ext,3fca282c58b247f313d18951a2f93d8341cd48a7,":=
  Subtype.ext <| ext.mpr ‚ü®hx, hy‚ü©","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  ext
has type
  ?m.4656.x = ?m.4657.x ‚Üí ?m.4656.y = ?m.4657.y ‚Üí ?m.4656 = ?m.4657",theorem ext {a b : Solution‚ÇÅ d} (hx : a.x = b.x) (hy : a.y = b.y) : a = b ,":=
  Subtype.ext <| Zsqrtd.ext _ _ hx hy"
Mathlib/Topology/UniformSpace/Cauchy.lean,CauchySeq.totallyBounded_range,CauchySeq.totallyBounded_range,14167e48d13e9c2d72cbdff0431a8edba6021c34,":= by
  refine' totallyBounded_iff_subset.2 fun a ha => _
  cases' cauchySeq_iff.1 hs a ha with n hn
  refine' ‚ü®s '' { k | k ‚â§ n }, image_subset_range _ _, (finite_le_nat _).image _, _‚ü©
  rw [range_subset_iff, bunion·µ¢_image]
  intro m
  rw [mem_union·µ¢‚ÇÇ]
  cases' le_total m n with hm hm
  exacts [‚ü®m, hm, refl_mem_uniformity ha‚ü©, ‚ü®n, le_refl n, hn m hm n le_rfl‚ü©]","error:  unknown identifier 'bunion·µ¢_image'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.108211
case intro
Œ± : Type u
Œ≤ : Type v
uniformSpace : UniformSpace Œ±
s : ‚Ñï ‚Üí Œ±
hs : CauchySeq s
a : Set (Œ± √ó Œ±)
ha : a ‚àà ùì§ Œ±
n : ‚Ñï
hn : ‚àÄ k ‚â• n, ‚àÄ l ‚â• n, (s k, s l) ‚àà a
‚ä¢ ‚àÄ (y : ‚Ñï), s y ‚àà ‚ãÉ y ‚àà s '' {k | k ‚â§ n}, {x | (x, y) ‚àà a}","theorem CauchySeq.totallyBounded_range {s : ‚Ñï ‚Üí Œ±} (hs : CauchySeq s) :
    TotallyBounded (range s) ",":= by
  refine totallyBounded_iff_subset.2 fun a ha => ?_
  cases' cauchySeq_iff.1 hs a ha with n hn
  refine ‚ü®s '' { k | k ‚â§ n }, image_subset_range _ _, (finite_le_nat _).image _, ?_‚ü©
  rw [range_subset_iff, biUnion_image]
  intro m
  rw [mem_iUnion‚ÇÇ]
  rcases le_total m n with hm | hm
  exacts [‚ü®m, hm, refl_mem_uniformity ha‚ü©, ‚ü®n, le_refl n, hn m hm n le_rfl‚ü©]"
Mathlib/AlgebraicGeometry/Gluing.lean,AlgebraicGeometry.Scheme.GlueData.Œπ_eq_iff,Œπ_eq_iff,6b4ce4f0e0b5f49e9b92d748d8a7a9a240de49f9,":= by
  refine' Iff.trans _
    (TopCat.GlueData.Œπ_eq_iff_rel
      D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toTopGlueData
      i j x y)
  rw [‚Üê ((TopCat.mono_iff_injective D.isoCarrier.inv).mp _).eq_iff]
  ¬∑ simp_rw [‚Üê comp_apply, ‚Üê D.Œπ_isoCarrier_inv]; rfl
  ¬∑ infer_instance",error:  simp made no progress,"theorem Œπ_eq_iff (i j : D.J) (x : (D.U i).carrier) (y : (D.U j).carrier) :
    (ùñ£.Œπ i).1.base x = (ùñ£.Œπ j).1.base y ‚Üî D.Rel ‚ü®i, x‚ü© ‚ü®j, y‚ü© ",":= by
  refine Iff.trans ?_
    (TopCat.GlueData.Œπ_eq_iff_rel
      D.toLocallyRingedSpaceGlueData.toSheafedSpaceGlueData.toPresheafedSpaceGlueData.toTopGlueData
      i j x y)
  rw [‚Üê ((TopCat.mono_iff_injective D.isoCarrier.inv).mp _).eq_iff]
  ¬∑ erw [‚Üê comp_apply] 
    simp_rw [‚Üê D.Œπ_isoCarrier_inv]
    rfl 
  ¬∑ infer_instance"
Mathlib/Order/WithBot.lean,WithBot.some_lt_some,some_lt_some,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  simp [LT.lt]","error:  unsolved goals
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
Œ¥ : Type u_4
a b : Œ±
inst‚úù : LT Œ±
‚ä¢ (‚àÉ b_1, Option.some b = ‚Üëb_1 ‚àß ‚àÄ (a_1 : Œ±), Option.some a = ‚Üëa_1 ‚Üí a_1 < b_1) ‚Üî a < b",theorem some_lt_some : @LT.lt (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a < b ,":=
  coe_lt_coe"
Mathlib/AlgebraicGeometry/OpenImmersion.lean,AlgebraicGeometry.IsOpenImmersion.range_pullback_fst_of_right,range_pullback_fst_of_right,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [‚Üê show _ = (pullback.fst : pullback g f ‚ü∂ _).1.base from
      PreservesPullback.iso_hom_fst Scheme.forgetToTop g f]
  erw [coe_comp]
  rw [Set.range_comp, Set.range_iff_surjective.mpr, ‚Üê
    @Set.preimage_univ _ _ (pullback.snd : pullback g.1.base f.1.base ‚ü∂ _)]
  ¬∑ erw [TopCat.pullback_fst_image_snd_preimage]
    rw [Set.image_univ]
    rfl
  rw [‚Üê TopCat.epi_iff_surjective]
  infer_instance","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Function.Surjective ‚áë?f
C : Type u
inst‚úù : Category.{v, u} C
X Y Z : Scheme
f : X ‚ü∂ Z
g : Y ‚ü∂ Z
H : IsOpenImmersion f
‚ä¢ Function.Surjective ‚áë(PreservesPullback.iso Scheme.forgetToTop g f).hom","theorem range_pullback_fst_of_right :
    Set.range (pullback.fst : pullback g f ‚ü∂ Y).1.base =
      ((Opens.map g.1.base).obj ‚ü®Set.range f.1.base, H.base_open.isOpen_range‚ü©).1 ",":= by
  rw [‚Üê show _ = (pullback.fst : pullback g f ‚ü∂ _).1.base from
      PreservesPullback.iso_hom_fst Scheme.forgetToTop g f]
  erw [coe_comp]
  rw [Set.range_comp, Set.range_iff_surjective.mpr, ‚Üê
    @Set.preimage_univ _ _ (pullback.snd : pullback g.1.base f.1.base ‚ü∂ _)]
  ¬∑ erw [TopCat.pullback_fst_image_snd_preimage]
    rw [Set.image_univ]
    rfl
  erw [‚Üê TopCat.epi_iff_surjective] 
  infer_instance"
Mathlib/Data/Nat/Choose/Basic.lean,Nat.choose_mul_factorial_mul_factorial,choose_mul_factorial_mul_factorial,0c824fb54f74f0c66db893166b73e377be2feb6f,"  | 0, _, hk => by simp [Nat.eq_zero_of_le_zero hk]
  | n + 1, 0, _ => by simp
  | n + 1, succ k, hk => by
    rcases lt_or_eq_of_le hk with hk‚ÇÅ | hk‚ÇÅ
    ¬∑ have h : choose n k * k.succ ! * (n - k)! = (k + 1) * n ! := by
        rw [‚Üê choose_mul_factorial_mul_factorial (le_of_succ_le_succ hk)]
        simp [factorial_succ, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc]
      have h‚ÇÅ : (n - k)! = (n - k) * (n - k.succ)! := by
        rw [‚Üê succ_sub_succ, succ_sub (le_of_lt_succ hk‚ÇÅ), factorial_succ]
      have h‚ÇÇ : choose n (succ k) * k.succ ! * ((n - k) * (n - k.succ)!) = (n - k) * n ! := by
        rw [‚Üê choose_mul_factorial_mul_factorial (le_of_lt_succ hk‚ÇÅ)]
        simp [factorial_succ, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc]
      have h‚ÇÉ : k * n ! ‚â§ n * n ! := Nat.mul_le_mul_right _ (le_of_succ_le_succ hk)
      rw [choose_succ_succ, Nat.add_mul, Nat.add_mul, succ_sub_succ, h, h‚ÇÅ, h‚ÇÇ, Nat.add_mul,
        Nat.mul_sub_right_distrib, factorial_succ, ‚Üê Nat.add_sub_assoc h‚ÇÉ, ‚Üê Nat.add_assoc',
        ‚Üê Nat.add_mul, Nat.add_sub_cancel_left, Nat.add_comm]
    ¬∑ rw [hk‚ÇÅ]; simp [hk‚ÇÅ, Nat.mul_comm, choose, Nat.sub_self]","error:  unknown constant 'Nat.add_assoc''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.10109
case inl
n k : ‚Ñï
hk : k.succ ‚â§ n + 1
hk‚ÇÅ : k.succ < n + 1
h : n.choose k * k.succ ! * (n - k)! = (k + 1) * n !
h‚ÇÅ : (n - k)! = (n - k) * (n - k.succ)!
h‚ÇÇ : n.choose k.succ * k.succ ! * ((n - k) * (n - k.succ)!) = (n - k) * n !
h‚ÇÉ : k * n ! ‚â§ n * n !
‚ä¢ k * n ! + 1 * n ! + n * n ! - k * n ! = (n + 1) * n !","theorem choose_mul_factorial_mul_factorial : ‚àÄ {n k}, k ‚â§ n ‚Üí choose n k * k ! * (n - k)! = n !
","  | 0, _, hk => by simp [Nat.eq_zero_of_le_zero hk]
  | n + 1, 0, _ => by simp
  | n + 1, succ k, hk => by
    rcases lt_or_eq_of_le hk with hk‚ÇÅ | hk‚ÇÅ
    ¬∑ have h : choose n k * k.succ ! * (n - k)! = (k + 1) * n ! := by
        rw [‚Üê choose_mul_factorial_mul_factorial (le_of_succ_le_succ hk)]
        simp [factorial_succ, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc]
      have h‚ÇÅ : (n - k)! = (n - k) * (n - k.succ)! := by
        rw [‚Üê succ_sub_succ, succ_sub (le_of_lt_succ hk‚ÇÅ), factorial_succ]
      have h‚ÇÇ : choose n (succ k) * k.succ ! * ((n - k) * (n - k.succ)!) = (n - k) * n ! := by
        rw [‚Üê choose_mul_factorial_mul_factorial (le_of_lt_succ hk‚ÇÅ)]
        simp [factorial_succ, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc]
      have h‚ÇÉ : k * n ! ‚â§ n * n ! := Nat.mul_le_mul_right _ (le_of_succ_le_succ hk)
      rw [choose_succ_succ, Nat.add_mul, Nat.add_mul, succ_sub_succ, h, h‚ÇÅ, h‚ÇÇ, Nat.add_mul,
        Nat.mul_sub_right_distrib, factorial_succ, ‚Üê Nat.add_sub_assoc h‚ÇÉ, Nat.add_assoc,
        ‚Üê Nat.add_mul, Nat.add_sub_cancel_left, Nat.add_comm]
    ¬∑ rw [hk‚ÇÅ]; simp [hk‚ÇÅ, Nat.mul_comm, choose, Nat.sub_self]"
Mathlib/Topology/Homotopy/HomotopyGroup.lean,GenLoop.homotopicTo,homotopicTo,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  refine Nonempty.map fun H => ‚ü®‚ü®‚ü®fun t => ‚ü®homotopyTo i H t, ?_‚ü©, ?_‚ü©?, _, ?_?‚ü©, _‚ü©
  ¬∑ rintro y ‚ü®i, iH‚ü©
    rw [homotopyTo_apply, H.eq_fst, p.2]
    all_goals apply Cube.insertAt_boundary; right; exact ‚ü®i, iH‚ü©
  ¬∑ continuity
  iterate 2 intro; ext; erw [homotopyTo_apply, toLoop_apply]; swap
  ¬∑ apply H.apply_zero
  ¬∑ apply H.apply_one
  intro t y yH
  ext; erw [homotopyTo_apply]
  apply H.eq_fst; use i
  rw [funSplitAt_symm_apply, dif_pos rfl]; exact yH","warning:  GenLoop does not have a doc string
error:  unexpected token '?'; expected '‚ü©'","theorem homotopicTo (i : N) {p q : Œ©^ N X x} :
    Homotopic p q ‚Üí (toLoop i p).Homotopic (toLoop i q) ",":= by
  refine Nonempty.map fun H => ‚ü®‚ü®‚ü®fun t => ‚ü®homotopyTo i H t, ?_‚ü©, ?_‚ü©, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ rintro y ‚ü®i, iH‚ü©
    rw [homotopyTo_apply, H.eq_fst, p.2]
    all_goals apply Cube.insertAt_boundary; right; exact ‚ü®i, iH‚ü©
  ¬∑ continuity
  iterate 2 intro; ext; erw [homotopyTo_apply, toLoop_apply]; swap
  ¬∑ apply H.apply_zero
  ¬∑ apply H.apply_one
  intro t y yH
  ext; erw [homotopyTo_apply]
  apply H.eq_fst; use i
  rw [funSplitAt_symm_apply, dif_pos rfl]; exact yH"
Mathlib/Order/SupClosed.lean,infClosed_sInter,infClosed_sInter,a380f5a603bf5030bc30e58b1aed19567f67b98d,:=,error:  unexpected token 'lemma'; expected term,"lemma infClosed_sInter (hS : ‚àÄ s ‚àà S, InfClosed s) : InfClosed (‚ãÇ‚ÇÄ S) ",":=
  fun _a ha _b hb _s hs ‚Ü¶ hS _ hs (ha _ hs) (hb _ hs)"
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,AffineSubspace.parallel_iff_direction_eq_and_eq_bot_iff_eq_bot,parallel_iff_direction_eq_and_eq_bot_iff_eq_bot,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine ‚ü®fun h => ‚ü®h.direction_eq, ?_,? _‚ü©, fun h =?> _‚ü©
  ¬∑ rintro rfl
    exact bot_parallel_iff_eq_bot.1 h
  ¬∑ rintro rfl
    exact parallel_bot_iff_eq_bot.1 h
  ¬∑ rcases h with ‚ü®hd, hb‚ü©
    by_cases hs‚ÇÅ : s‚ÇÅ = ‚ä•
    ¬∑ rw [hs‚ÇÅ, bot_parallel_iff_eq_bot]
      exact hb.1 hs‚ÇÅ
    ¬∑ have hs‚ÇÇ : s‚ÇÇ ‚â† ‚ä• := hb.not.1 hs‚ÇÅ
      rcases (nonempty_iff_ne_bot s‚ÇÅ).2 hs‚ÇÅ with ‚ü®p‚ÇÅ, hp‚ÇÅ‚ü©
      rcases (nonempty_iff_ne_bot s‚ÇÇ).2 hs‚ÇÇ with ‚ü®p‚ÇÇ, hp‚ÇÇ‚ü©
      refine ‚ü®p‚ÇÇ -·µ• p‚ÇÅ, (eq_iff_direction_eq_of_mem hp‚ÇÇ ?_).2? _‚ü©
      ¬∑ rw [mem_map]
        refine ‚ü®p‚ÇÅ, hp‚ÇÅ, ?_‚ü©
        simp
      ¬∑ simpa using hd.symm","warning:  @AffineSubspace.Parallel does not have a doc string
error:  unexpected token '='; expected '‚Ü¶', '=>'
error:  unsolved goals
case refine_1
k : Type u_1
V : Type u_2
P : Type u_3
inst‚úù¬≥ : Ring k
inst‚úù¬≤ : AddCommGroup V
inst‚úù¬π : Module k V
inst‚úù : AffineSpace V P
s‚ÇÅ s‚ÇÇ : AffineSubspace k P
h : s‚ÇÅ ‚à• s‚ÇÇ
‚ä¢ s‚ÇÅ = ‚ä• ‚Üí s‚ÇÇ = ‚ä•

case refine_2
k : Type u_1
V : Type u_2
P : Type u_3
inst‚úù¬≥ : Ring k
inst‚úù¬≤ : AddCommGroup V
inst‚úù¬π : Module k V
inst‚úù : AffineSpace V P
s‚ÇÅ s‚ÇÇ : AffineSubspace k P
h : s‚ÇÅ ‚à• s‚ÇÇ
‚ä¢ s‚ÇÇ = ‚ä• ‚Üí s‚ÇÅ = ‚ä•","theorem parallel_iff_direction_eq_and_eq_bot_iff_eq_bot {s‚ÇÅ s‚ÇÇ : AffineSubspace k P} :
    s‚ÇÅ ‚à• s‚ÇÇ ‚Üî s‚ÇÅ.direction = s‚ÇÇ.direction ‚àß (s‚ÇÅ = ‚ä• ‚Üî s‚ÇÇ = ‚ä•) ",":= by
  refine ‚ü®fun h => ‚ü®h.direction_eq, ?_, ?_‚ü©, fun h => ?_‚ü©
  ¬∑ rintro rfl
    exact bot_parallel_iff_eq_bot.1 h
  ¬∑ rintro rfl
    exact parallel_bot_iff_eq_bot.1 h
  ¬∑ rcases h with ‚ü®hd, hb‚ü©
    by_cases hs‚ÇÅ : s‚ÇÅ = ‚ä•
    ¬∑ rw [hs‚ÇÅ, bot_parallel_iff_eq_bot]
      exact hb.1 hs‚ÇÅ
    ¬∑ have hs‚ÇÇ : s‚ÇÇ ‚â† ‚ä• := hb.not.1 hs‚ÇÅ
      rcases (nonempty_iff_ne_bot s‚ÇÅ).2 hs‚ÇÅ with ‚ü®p‚ÇÅ, hp‚ÇÅ‚ü©
      rcases (nonempty_iff_ne_bot s‚ÇÇ).2 hs‚ÇÇ with ‚ü®p‚ÇÇ, hp‚ÇÇ‚ü©
      refine ‚ü®p‚ÇÇ -·µ• p‚ÇÅ, (eq_iff_direction_eq_of_mem hp‚ÇÇ ?_).2 ?_‚ü©
      ¬∑ rw [mem_map]
        refine ‚ü®p‚ÇÅ, hp‚ÇÅ, ?_‚ü©
        simp
      ¬∑ simpa using hd.symm"
Mathlib/RingTheory/WittVector/Identities.lean,WittVector.verschiebung_mul_frobenius,verschiebung_mul_frobenius,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  simp only []
  have : IsPoly‚ÇÇ p fun {R} [Rcr : CommRing R] x y ‚Ü¶ verschiebung (x * frobenius y) :=
    IsPoly.comp‚ÇÇ (hg := verschiebung_isPoly)
      (hf := IsPoly‚ÇÇ.comp (hh := mulIsPoly‚ÇÇ) (hf := idIsPolyI' p) (hg := frobenius_isPoly p))
  have : IsPoly‚ÇÇ p fun {R} [CommRing R] x y ‚Ü¶ verschiebung x * y :=
    IsPoly‚ÇÇ.comp (hh := mulIsPoly‚ÇÇ) (hf := verschiebung_isPoly) (hg := idIsPolyI' p)
  ghost_calc x y
  rintro ‚ü®‚ü© <;> ghost_simp [mul_assoc]",error:  simp made no progress,"theorem verschiebung_mul_frobenius (x y : ùïé R) :
    verschiebung (x * frobenius y) = verschiebung x * y ",":= by
  have : IsPoly‚ÇÇ p fun {R} [Rcr : CommRing R] x y ‚Ü¶ verschiebung (x * frobenius y) :=
    IsPoly.comp‚ÇÇ (hg := verschiebung_isPoly)
      (hf := IsPoly‚ÇÇ.comp (hh := mulIsPoly‚ÇÇ) (hf := idIsPolyI' p) (hg := frobenius_isPoly p))
  have : IsPoly‚ÇÇ p fun {R} [CommRing R] x y ‚Ü¶ verschiebung x * y :=
    IsPoly‚ÇÇ.comp (hh := mulIsPoly‚ÇÇ) (hf := verschiebung_isPoly) (hg := idIsPolyI' p)
  ghost_calc x y
  rintro ‚ü®‚ü© <;> ghost_simp [mul_assoc]"
Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean,MeasureTheory.exists_lt_lowerSemicontinuous_integral_lt,exists_lt_lowerSemicontinuous_integral_lt,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ / 2, (half_pos Œµpos).le‚ü©
  have Œ¥pos : 0 < Œ¥ := half_pos Œµpos
  let fp : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (f x)
  have int_fp : Integrable (fun x => (fp x : ‚Ñù)) Œº := hf.real_toNNReal
  rcases exists_lt_lowerSemicontinuous_integral_gt_nnreal fp int_fp Œ¥pos with
    ‚ü®gp, fp_lt_gp, gpcont, gp_lt_top, gp_integrable, gpint‚ü©
  let fm : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (-f x)
  have int_fm : Integrable (fun x => (fm x : ‚Ñù)) Œº := hf.neg.real_toNNReal
  rcases exists_upperSemicontinuous_le_integral_le fm int_fm Œ¥pos with
    ‚ü®gm, gm_le_fm, gmcont, gm_integrable, gmint‚ü©
  let g : Œ± ‚Üí EReal := fun x => (gp x : EReal) - gm x
  have ae_g : ‚àÄ·µê x ‚àÇŒº, (g x).toReal = (gp x : EReal).toReal - (gm x : EReal).toReal := by
    filter_upwards [gp_lt_top] with _ hx
    rw [EReal.toReal_sub] <;> simp [hx.ne]
  refine' ‚ü®g, ?lt, ?lsc, ?int, ?aelt, ?intlt‚ü©
  case int =>
    show Integrable (fun x => EReal.toReal (g x)) Œº
    rw [integrable_congr ae_g]
    convert gp_integrable.sub gm_integrable
    simp
  case intlt =>
    show (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) < (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ;
    exact
      calc
        (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) = ‚à´ x : Œ±, EReal.toReal (gp x) - EReal.toReal (gm x) ‚àÇŒº :=
          integral_congr_ae ae_g
        _ = (‚à´ x : Œ±, EReal.toReal (gp x) ‚àÇŒº) - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          simp only [EReal.toReal_coe_ennreal, ENNReal.coe_toReal]
          exact integral_sub gp_integrable gm_integrable
        _ < (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          apply sub_lt_sub_right
          convert gpint
          simp only [EReal.toReal_coe_ennreal]
        _ ‚â§ (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ((‚à´ x : Œ±, ‚Üë(fm x) ‚àÇŒº) - Œ¥) := (sub_le_sub_left gmint _)
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + 2 * Œ¥ := by
          simp_rw [integral_eq_integral_pos_part_sub_integral_neg_part hf]; ring
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ := by congr 1; field_simp [mul_comm]
  case aelt =>
    show ‚àÄ·µê x : Œ± ‚àÇŒº, g x < ‚ä§
    filter_upwards [gp_lt_top] with ?_ hx
    simp only [sub_eq_add_neg, Ne.def, (EReal.add_lt_top _ _).ne, lt_top_iff_ne_top,
      lt_top_iff_ne_top.1 hx, EReal.coe_ennreal_eq_top_iff, not_false_iff, EReal.neg_eq_top_iff,
      EReal.coe_ennreal_ne_bot]
  case lt =>
    show ‚àÄ x, (f x : EReal) < g x
    intro x
    rw [EReal.coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal (f x)]
    refine' EReal.sub_lt_sub_of_lt_of_le _ _ _ _
    ¬∑ simp only [EReal.coe_ennreal_lt_coe_ennreal_iff]; exact fp_lt_gp x
    ¬∑ simp only [ENNReal.coe_le_coe, EReal.coe_ennreal_le_coe_ennreal_iff]
      exact gm_le_fm x
    ¬∑ simp only [EReal.coe_ennreal_ne_bot, Ne.def, not_false_iff]
    ¬∑ simp only [EReal.coe_nnreal_ne_top, Ne.def, not_false_iff]
  case lsc =>
    show LowerSemicontinuous g
    apply LowerSemicontinuous.add'
    ¬∑ exact continuous_coe_ennreal_ereal.comp_lowerSemicontinuous gpcont fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
    ¬∑ apply continuous_neg.comp_upperSemicontinuous_antitone _ fun x y hxy =>
          EReal.neg_le_neg_iff.2 hxy
      dsimp
      apply continuous_coe_ennreal_ereal.comp_upperSemicontinuous _ fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
      exact ENNReal.continuous_coe.comp_upperSemicontinuous gmcont fun x y hxy =>
          ENNReal.coe_le_coe.2 hxy
    ¬∑ intro x
      exact EReal.continuousAt_add (by simp) (by simp)","error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.138587 ‚Üí ?m.138587 ‚Üí Prop
error:  unsolved goals
case h
Œ± : Type u_1
inst‚úù‚Å¥ : TopologicalSpace Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : BorelSpace Œ±
Œº : Measure Œ±
inst‚úù¬π : Œº.WeaklyRegular
inst‚úù : SigmaFinite Œº
f : Œ± ‚Üí ‚Ñù
hf : Integrable f Œº
Œµ : ‚Ñù
Œµpos : 0 < Œµ
Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ / 2, ‚ãØ‚ü©
Œ¥pos : 0 < Œ¥
fp : Œ± ‚Üí ‚Ñù‚â•0 := fun x ‚Ü¶ (f x).toNNReal
int_fp : Integrable (fun x ‚Ü¶ ‚Üë(fp x)) Œº
gp : Œ± ‚Üí ‚Ñù‚â•0‚àû
fp_lt_gp : ‚àÄ (x : Œ±), ‚Üë(fp x) < gp x
gpcont : LowerSemicontinuous gp
gp_lt_top : ‚àÄ·µê (x : Œ±) ‚àÇŒº, gp x < ‚ä§
gp_integrable : Integrable (fun x ‚Ü¶ (gp x).toReal) Œº
gpint : ‚à´ (x : Œ±), (gp x).toReal ‚àÇŒº < ‚à´ (x : Œ±), ‚Üë(fp x) ‚àÇŒº + (fun a ‚Ü¶ ‚Üëa) Œ¥
fm : Œ± ‚Üí ‚Ñù‚â•0 := fun x ‚Ü¶ (-f x).toNNReal
int_fm : Integrable (fun x ‚Ü¶ ‚Üë(fm x)) Œº
gm : Œ± ‚Üí ‚Ñù‚â•0
gm_le_fm : ‚àÄ (x : Œ±), gm x ‚â§ fm x
gmcont : UpperSemicontinuous gm
gm_integrable : Integrable (fun x ‚Ü¶ ‚Üë(gm x)) Œº
gmint : ‚à´ (x : Œ±), ‚Üë(fm x) ‚àÇŒº - (fun a ‚Ü¶ ‚Üëa) Œ¥ ‚â§ ‚à´ (x : Œ±), ‚Üë(gm x) ‚àÇŒº
g : Œ± ‚Üí EReal := fun x ‚Ü¶ ‚Üë(gp x) - ‚Üë‚Üë(gm x)
ae_g : ‚àÄ·µê (x : Œ±) ‚àÇŒº, (g x).toReal = (‚Üë(gp x)).toReal - (‚Üë‚Üë(gm x)).toReal
x‚úù : Œ±
hx : gp x‚úù < ‚ä§
‚ä¢ g x‚úù ‚â† ‚ä§
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.139596 ‚Üí ?m.139596 ‚Üí Prop
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.139631 ‚Üí ?m.139631 ‚Üí Prop
error:  simp made no progress","theorem exists_lt_lowerSemicontinuous_integral_lt [SigmaFinite Œº] (f : Œ± ‚Üí ‚Ñù) (hf : Integrable f Œº)
    {Œµ : ‚Ñù} (Œµpos : 0 < Œµ) :
    ‚àÉ g : Œ± ‚Üí EReal,
      (‚àÄ x, (f x : EReal) < g x) ‚àß
      LowerSemicontinuous g ‚àß
      Integrable (fun x => EReal.toReal (g x)) Œº ‚àß
      (‚àÄ·µê x ‚àÇŒº, g x < ‚ä§) ‚àß (‚à´ x, EReal.toReal (g x) ‚àÇŒº) < (‚à´ x, f x ‚àÇŒº) + Œµ ",":= by
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ / 2, (half_pos Œµpos).le‚ü©
  have Œ¥pos : 0 < Œ¥ := half_pos Œµpos
  let fp : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (f x)
  have int_fp : Integrable (fun x => (fp x : ‚Ñù)) Œº := hf.real_toNNReal
  rcases exists_lt_lowerSemicontinuous_integral_gt_nnreal fp int_fp Œ¥pos with
    ‚ü®gp, fp_lt_gp, gpcont, gp_lt_top, gp_integrable, gpint‚ü©
  let fm : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (-f x)
  have int_fm : Integrable (fun x => (fm x : ‚Ñù)) Œº := hf.neg.real_toNNReal
  rcases exists_upperSemicontinuous_le_integral_le fm int_fm Œ¥pos with
    ‚ü®gm, gm_le_fm, gmcont, gm_integrable, gmint‚ü©
  let g : Œ± ‚Üí EReal := fun x => (gp x : EReal) - gm x
  have ae_g : ‚àÄ·µê x ‚àÇŒº, (g x).toReal = (gp x : EReal).toReal - (gm x : EReal).toReal := by
    filter_upwards [gp_lt_top] with _ hx
    rw [EReal.toReal_sub] <;> simp [hx.ne]
  refine ‚ü®g, ?lt, ?lsc, ?int, ?aelt, ?intlt‚ü©
  case int =>
    show Integrable (fun x => EReal.toReal (g x)) Œº
    rw [integrable_congr ae_g]
    convert gp_integrable.sub gm_integrable
    simp
  case intlt =>
    show (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) < (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ;
    exact
      calc
        (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) = ‚à´ x : Œ±, EReal.toReal (gp x) - EReal.toReal (gm x) ‚àÇŒº :=
          integral_congr_ae ae_g
        _ = (‚à´ x : Œ±, EReal.toReal (gp x) ‚àÇŒº) - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          simp only [EReal.toReal_coe_ennreal, ENNReal.coe_toReal]
          exact integral_sub gp_integrable gm_integrable
        _ < (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          apply sub_lt_sub_right
          convert gpint
          simp only [EReal.toReal_coe_ennreal]
        _ ‚â§ (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ((‚à´ x : Œ±, ‚Üë(fm x) ‚àÇŒº) - Œ¥) := sub_le_sub_left gmint _
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + 2 * Œ¥ := by
          simp_rw [integral_eq_integral_pos_part_sub_integral_neg_part hf]; ring
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ := by congr 1; field_simp [Œ¥, mul_comm]
  case aelt =>
    show ‚àÄ·µê x : Œ± ‚àÇŒº, g x < ‚ä§
    filter_upwards [gp_lt_top] with ?_ hx
    simp only [g, sub_eq_add_neg, Ne, (EReal.add_lt_top _ _).ne, lt_top_iff_ne_top,
      lt_top_iff_ne_top.1 hx, EReal.coe_ennreal_eq_top_iff, not_false_iff, EReal.neg_eq_top_iff,
      EReal.coe_ennreal_ne_bot]
  case lt =>
    show ‚àÄ x, (f x : EReal) < g x
    intro x
    rw [EReal.coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal (f x)]
    refine EReal.sub_lt_sub_of_lt_of_le ?_ ?_ ?_ ?_
    ¬∑ simp only [EReal.coe_ennreal_lt_coe_ennreal_iff]; exact fp_lt_gp x
    ¬∑ simp only [ENNReal.coe_le_coe, EReal.coe_ennreal_le_coe_ennreal_iff]
      exact gm_le_fm x
    ¬∑ simp only [EReal.coe_ennreal_ne_bot, Ne, not_false_iff]
    ¬∑ simp only [EReal.coe_nnreal_ne_top, Ne, not_false_iff]
  case lsc =>
    show LowerSemicontinuous g
    apply LowerSemicontinuous.add'
    ¬∑ exact continuous_coe_ennreal_ereal.comp_lowerSemicontinuous gpcont fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
    ¬∑ apply continuous_neg.comp_upperSemicontinuous_antitone _ fun x y hxy =>
          EReal.neg_le_neg_iff.2 hxy
      dsimp
      apply continuous_coe_ennreal_ereal.comp_upperSemicontinuous _ fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
      exact ENNReal.continuous_coe.comp_upperSemicontinuous gmcont fun x y hxy =>
          ENNReal.coe_le_coe.2 hxy
    ¬∑ intro x
      exact EReal.continuousAt_add (by simp) (by simp)"
Mathlib/Computability/Primrec.lean,Nat.Primrec'.add,add,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  (prec .id ((Primrec.succ.comp right).comp right)).of_eq fun p => by
    simp; induction p.unpair.2 <;> simp [*, add_succ]","error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
error:  unsolved goals
case zero
p : ‚Ñï
‚ä¢ Nat.rec (unpair p).1 (fun y IH ‚Ü¶ IH + 1) 0 = (unpair p).1 + 0

case succ
p n‚úù : ‚Ñï
a‚úù : Nat.rec (unpair p).1 (fun y IH ‚Ü¶ IH + 1) n‚úù = (unpair p).1 + n‚úù
‚ä¢ Nat.rec (unpair p).1 (fun y IH ‚Ü¶ IH + 1) (n‚úù + 1) = (unpair p).1 + (n‚úù + 1)",theorem add : Nat.Primrec (unpaired (¬∑ + ¬∑)) ,":=
  (prec .id ((Primrec.succ.comp right).comp right)).of_eq fun p => by
    simp; induction p.unpair.2 <;> simp [*, Nat.add_assoc]"
Mathlib/NumberTheory/ArithmeticFunction.lean,ArithmeticFunction.sum_eq_iff_sum_smul_moebius_eq_on,sum_eq_iff_sum_smul_moebius_eq_on,8c86ef2b0a8795edffe59cd63522c7b3c716bd02,":= by
  constructor
  ¬∑ intro h
    let G : = fun (n : ‚Ñï) => (‚àë i ‚àà n.divisors, f i)
    intro n hn hnP
    suffices ‚àë d ‚àà n.divisors, Œº (n/d) ‚Ä¢ G d = f n from by
      rw [Nat.sum_divisorsAntidiagonal' (f := fun x y => Œº x ‚Ä¢ g y), ‚Üê this, sum_congr rfl]
      intro d hd
      rw [‚Üê h d (Nat.pos_of_mem_divisors hd) <| hs d n (Nat.dvd_of_mem_divisors hd) hnP]
    rw [‚Üê Nat.sum_divisorsAntidiagonal' (f := fun x y => Œº x ‚Ä¢ G y)]
    apply sum_eq_iff_sum_smul_moebius_eq.mp _ n hn
    intro _ _; rfl
  ¬∑ intro h
    let F : = fun (n : ‚Ñï) => ‚àë x ‚àà n.divisorsAntidiagonal, Œº x.fst ‚Ä¢ g x.snd
    intro n hn hnP
    suffices ‚àë d ‚àà n.divisors, F d = g n from by
      rw [‚Üê this, sum_congr rfl]
      intro d hd
      rw [‚Üê h d (Nat.pos_of_mem_divisors hd) <| hs d n (Nat.dvd_of_mem_divisors hd) hnP]
    apply sum_eq_iff_sum_smul_moebius_eq.mpr _ n hn
    intro _ _; rfl","warning:  zeta does not have a doc string
warning:  Œ∂ does not have a doc string
warning:  sigma does not have a doc string
warning:  œÉ does not have a doc string
warning:  cardFactors does not have a doc string
warning:  Œ© does not have a doc string
warning:  cardDistinctFactors does not have a doc string
warning:  œâ does not have a doc string
warning:  moebius does not have a doc string
warning:  Œº does not have a doc string
error:  unexpected token '='; expected term
error:  unsolved goals
case mp
R : Type u_1
inst‚úù : AddCommGroup R
f g : ‚Ñï ‚Üí R
s : Set ‚Ñï
hs : ‚àÄ (m n : ‚Ñï), m ‚à£ n ‚Üí n ‚àà s ‚Üí m ‚àà s
h : ‚àÄ n > 0, n ‚àà s ‚Üí ‚àë i ‚àà n.divisors, f i = g n
G : sorryAx (Sort ?u.556345) true := nomatch
‚ä¢ ‚àÄ n > 0, n ‚àà s ‚Üí ‚àë x ‚àà n.divisorsAntidiagonal, Œº x.1 ‚Ä¢ g x.2 = f n
error:  unsolved goals
case mpr
R : Type u_1
inst‚úù : AddCommGroup R
f g : ‚Ñï ‚Üí R
s : Set ‚Ñï
hs : ‚àÄ (m n : ‚Ñï), m ‚à£ n ‚Üí n ‚àà s ‚Üí m ‚àà s
‚ä¢ (‚àÄ n > 0, n ‚àà s ‚Üí ‚àë x ‚àà n.divisorsAntidiagonal, Œº x.1 ‚Ä¢ g x.2 = f n) ‚Üí ‚àÄ n > 0, n ‚àà s ‚Üí ‚àë i ‚àà n.divisors, f i = g n","theorem sum_eq_iff_sum_smul_moebius_eq_on [AddCommGroup R] {f g : ‚Ñï ‚Üí R}
    (s : Set ‚Ñï) (hs : ‚àÄ m n, m ‚à£ n ‚Üí n ‚àà s ‚Üí m ‚àà s) :
    (‚àÄ n > 0, n ‚àà s ‚Üí (‚àë i ‚àà n.divisors, f i) = g n) ‚Üî
      ‚àÄ n > 0, n ‚àà s ‚Üí (‚àë x ‚àà n.divisorsAntidiagonal, Œº x.fst ‚Ä¢ g x.snd) = f n ",":= by
  constructor
  ¬∑ intro h
    let G := fun (n:‚Ñï) => (‚àë i ‚àà n.divisors, f i)
    intro n hn hnP
    suffices ‚àë d ‚àà n.divisors, Œº (n/d) ‚Ä¢ G d = f n from by
      rw [Nat.sum_divisorsAntidiagonal' (f := fun x y => Œº x ‚Ä¢ g y), ‚Üê this, sum_congr rfl]
      intro d hd
      rw [‚Üê h d (Nat.pos_of_mem_divisors hd) <| hs d n (Nat.dvd_of_mem_divisors hd) hnP]
    rw [‚Üê Nat.sum_divisorsAntidiagonal' (f := fun x y => Œº x ‚Ä¢ G y)]
    apply sum_eq_iff_sum_smul_moebius_eq.mp _ n hn
    intro _ _; rfl
  ¬∑ intro h
    let F := fun (n:‚Ñï) => ‚àë x ‚àà n.divisorsAntidiagonal, Œº x.fst ‚Ä¢ g x.snd
    intro n hn hnP
    suffices ‚àë d ‚àà n.divisors, F d = g n from by
      rw [‚Üê this, sum_congr rfl]
      intro d hd
      rw [‚Üê h d (Nat.pos_of_mem_divisors hd) <| hs d n (Nat.dvd_of_mem_divisors hd) hnP]
    apply sum_eq_iff_sum_smul_moebius_eq.mpr _ n hn
    intro _ _; rfl"
Mathlib/RingTheory/RootsOfUnity/Basic.lean,IsPrimitiveRoot.card_primitiveRoots,card_primitiveRoots,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  by_cases h0 : k = 0
  ¬∑ simp [h0]
  symm
  refine' Finset.card_congr (fun i _ => Œ∂ ^ i) _ _ _
  ¬∑ simp only [true_and_iff, and_imp, mem_filter, mem_range, mem_univ]
    rintro i - hi
    rw [mem_primitiveRoots (Nat.pos_of_ne_zero h0)]
    exact h.pow_of_coprime i hi.symm
  ¬∑ simp only [true_and_iff, and_imp, mem_filter, mem_range, mem_univ]
    rintro i j hi - hj - H
    exact h.pow_inj hi hj H
  ¬∑ simp only [exists_prop, true_and_iff, mem_filter, mem_range, mem_univ]
    intro Œæ hŒæ
    rw [mem_primitiveRoots (Nat.pos_of_ne_zero h0),
      h.isPrimitiveRoot_iff (Nat.pos_of_ne_zero h0)] at hŒæ
    rcases hŒæ with ‚ü®i, hin, hi, H‚ü©
    exact ‚ü®i, ‚ü®hin, hi.symm‚ü©, H‚ü©","warning:  `Finset.card_congr` has been deprecated, use `Finset.card_bij` instead
error:  application type mismatch
  pow_inj h hi
argument
  hi
has type
  k.Coprime i : Prop
but is expected to have type
  i < k : Prop
error:  unknown identifier 'hj'
error:  unknown identifier 'H'","theorem card_primitiveRoots {Œ∂ : R} {k : ‚Ñï} (h : IsPrimitiveRoot Œ∂ k) :
    (primitiveRoots k R).card = œÜ k ",":= by
  by_cases h0 : k = 0
  ¬∑ simp [h0]
  symm
  refine Finset.card_bij (fun i _ ‚Ü¶ Œ∂ ^ i) ?_ ?_ ?_
  ¬∑ simp only [true_and_iff, and_imp, mem_filter, mem_range, mem_univ]
    rintro i - hi
    rw [mem_primitiveRoots (Nat.pos_of_ne_zero h0)]
    exact h.pow_of_coprime i hi.symm
  ¬∑ simp only [true_and_iff, and_imp, mem_filter, mem_range, mem_univ]
    rintro i hi - j hj - H
    exact h.pow_inj hi hj H
  ¬∑ simp only [exists_prop, true_and_iff, mem_filter, mem_range, mem_univ]
    intro Œæ hŒæ
    rw [mem_primitiveRoots (Nat.pos_of_ne_zero h0),
      h.isPrimitiveRoot_iff (Nat.pos_of_ne_zero h0)] at hŒæ
    rcases hŒæ with ‚ü®i, hin, hi, H‚ü©
    exact ‚ü®i, ‚ü®hin, hi.symm‚ü©, H‚ü©"
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,affineSpan_pair_le_of_mem_of_mem,affineSpan_pair_le_of_mem_of_mem,5068808d2b4c25cf905cf7fee10ded8e447c2346,":= by
  rw [affineSpan_le, Set.insert_subset, Set.singleton_subset_iff]
  exact ‚ü®hp‚ÇÅ, hp‚ÇÇ‚ü©","error:  tactic 'rewrite' failed, equality or iff proof expected
  ?a ‚àà ?m.379528
k : Type u_1
V : Type u_2
P : Type u_3
inst‚úù¬≥ : Ring k
inst‚úù¬≤ : AddCommGroup V
inst‚úù¬π : Module k V
inst‚úù : AffineSpace V P
Œπ : Type u_4
p‚ÇÅ p‚ÇÇ : P
s : AffineSubspace k P
hp‚ÇÅ : p‚ÇÅ ‚àà s
hp‚ÇÇ : p‚ÇÇ ‚àà s
‚ä¢ {p‚ÇÅ, p‚ÇÇ} ‚äÜ ‚Üës
warning:  @AffineSubspace.Parallel does not have a doc string","theorem affineSpan_pair_le_of_mem_of_mem {p‚ÇÅ p‚ÇÇ : P} {s : AffineSubspace k P} (hp‚ÇÅ : p‚ÇÅ ‚àà s)
    (hp‚ÇÇ : p‚ÇÇ ‚àà s) : line[k, p‚ÇÅ, p‚ÇÇ] ‚â§ s ",":= by
  rw [affineSpan_le, Set.insert_subset_iff, Set.singleton_subset_iff]
  exact ‚ü®hp‚ÇÅ, hp‚ÇÇ‚ü©"
Mathlib/Order/ConditionallyCompleteLattice/Basic.lean,WithTop.isGLB_sInf',isGLB_sInf',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  constructor
  ¬∑ show ite _ _ _ ‚àà _
    split_ifs with h
    ¬∑ intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exact le_top
      refine' some_le_some.2 (csInf_le _ ha)
      rcases hs with ‚ü®‚ü®‚ü© | b, hb‚ü©
      ¬∑ exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, ‚Üê top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact some_le_some.1 (hb hc)
  ¬∑ show ite _ _ _ ‚àà _
    split_ifs with h
    ¬∑ intro _ _
      exact le_top
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      ¬∑ refine' some_le_some.2 (le_csInf _ _)
        ¬∑ classical
            contrapose! h
            rintro (‚ü®‚ü© | a) ha
            ¬∑ exact mem_singleton ‚ä§
            ¬∑ exact (not_nonempty_iff_eq_empty.2 h ‚ü®a, ha‚ü©).elim
        ¬∑ intro b hb
          rw [‚Üê some_le_some]
          exact ha hb","error:  function expected at
  h
term has type
  s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.intro.none
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
h : ¬¨(s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s)
a : Œ≤
ha : Option.some a ‚àà s
hb : none ‚àà lowerBounds s
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.none
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
hs : BddBelow s
h : ¬¨(s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s)
ha : none ‚àà lowerBounds s
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.refine'_1
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
hs : BddBelow s
a : Œ≤
ha : Option.some a ‚àà lowerBounds s
h : (fun a ‚Ü¶ ‚Üëa) ‚Åª¬π' s = ‚àÖ
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop","theorem isGLB_sInf' {Œ≤ : Type*} [ConditionallyCompleteLattice Œ≤] {s : Set (WithTop Œ≤)}
    (hs : BddBelow s) : IsGLB s (sInf s) ",":= by
  constructor
  ¬∑ show ite _ _ _ ‚àà _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    ¬∑ intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exact le_top
      refine coe_le_coe.2 (csInf_le ?_ ha)
      rcases hs with ‚ü®‚ü®‚ü© | b, hb‚ü©
      ¬∑ exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, ‚Üê top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact coe_le_coe.1 (hb hc)
  ¬∑ show ite _ _ _ ‚àà _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    ¬∑ intro _ _
      exact le_top
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      ¬∑ refine coe_le_coe.2 (le_csInf ?_ ?_)
        ¬∑ classical
            contrapose! h
            rintro (‚ü®‚ü© | a) ha
            ¬∑ exact mem_singleton ‚ä§
            ¬∑ exact (not_nonempty_iff_eq_empty.2 h ‚ü®a, ha‚ü©).elim
        ¬∑ intro b hb
          rw [‚Üê coe_le_coe]
          exact ha hb"
Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean,CategoryTheory.Limits.colimitLimitToLimitColimit_surjective,colimitLimitToLimitColimit_surjective,41b955aad45c24b4e2c9b0cae45d9ea397306cf5,":= by
  classical
    intro x
    have z := fun j => jointly_surjective'.{v, v} (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply', t, FunctorToTypes.map_comp_apply, Colimit.w_apply', e, ‚Üê
        Limit.w_apply' f, ‚Üê e]
      simp
    simp_rw [colimit_eq_iff.{v, v}] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact k'O
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk.{v, v}
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) :=
            by rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) :=
            by rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) :=
            by rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext'
      intro j
      simp only [id, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff.{v, v}, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","error:  application type mismatch
  jointly_surjective' (limit.œÄ (curry.obj F ‚ãô colim) j x)
argument
  limit.œÄ (curry.obj F ‚ãô colim) j x
has type
  (curry.obj F ‚ãô colim).obj j : Type v
but is expected to have type
  colimit ?m.27488 : Type v
error:  unsolved goals
J : Type u‚ÇÅ
K : Type u‚ÇÇ
inst‚úù‚Å¥ : SmallCategory J
inst‚úù¬≥ : Category.{v‚ÇÇ, u‚ÇÇ} K
inst‚úù¬≤ : Small.{v, u‚ÇÇ} K
inst‚úù¬π : FinCategory J
F : J √ó K ‚•§ Type v
inst‚úù : IsFiltered K
x : limit (curry.obj F ‚ãô colim)
‚ä¢ ‚àÉ a, colimitLimitToLimitColimit F a = x","theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) ",":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ‚Üê Limit.w_apply.{u‚ÇÅ, v, u‚ÇÅ} f, ‚Üê e]
      simp only [Functor.comp_map, Types.Colimit.Œπ_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact k'O
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) := by
            rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) := by
            rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext
      intro j
      simp only [id, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]"
Mathlib/Order/WithBot.lean,WithBot.some_le_some,some_le_some,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  simp [LE.le]","error:  unsolved goals
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
Œ¥ : Type u_4
a b : Œ±
inst‚úù : LE Œ±
‚ä¢ (‚àÄ (a_1 : Œ±), Option.some a = ‚Üëa_1 ‚Üí ‚àÉ b_1, Option.some b = ‚Üëb_1 ‚àß a_1 ‚â§ b_1) ‚Üî a ‚â§ b",theorem some_le_some : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b ,":=
  coe_le_coe"
Mathlib/Data/Set/Basic.lean,Set.disjoint_iff_forall_ne,disjoint_iff_forall_ne,a8f630d813ed24045cb47f3d67db9dfe46660424,":= by
  simp only [Ne.def, disjoint_left, @imp_not_comm _ (_ = _), forall_eq']","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.66800 ‚Üí ?m.66800 ‚Üí Prop","lemma disjoint_iff_forall_ne : Disjoint s t ‚Üî ‚àÄ ‚¶Éa‚¶Ñ, a ‚àà s ‚Üí ‚àÄ ‚¶Éb‚¶Ñ, b ‚àà t ‚Üí a ‚â† b ",":= by
  simp only [Ne, disjoint_left, @imp_not_comm _ (_ = _), forall_eq']"
Mathlib/Data/List/NodupEquivFin.lean,List.sublist_iff_exists_fin_orderEmbedding_get_eq,sublist_iff_exists_fin_orderEmbedding_get_eq,f9c61018b00a768d4a0ce7c39c0dd84152b6827f,":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï} (_ : i < l.length), f i < l'.length :=
      by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine' ‚ü®OrderEmbedding.ofMapLeIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) _, _‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [get?_eq_get i.2, get?_eq_get (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine'
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          _,
        _‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ rw [add_comm]
        exact lt_add_of_lt_of_pos (Fin.is_lt _) (i.zero_le.trans_lt h)
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi
  list.sublist_iff_exists_fin_order_embedding_nth_le_eq
  List.sublist_iff_exists_fin_orderEmbedding_get_eq","error:  unknown tactic
error:  unsolved goals
case mp.intro
Œ± : Type u_1
l l' : List Œ±
f : ‚Ñï ‚Ü™o ‚Ñï
hf : ‚àÄ (ix : ‚Ñï), l.get? ix = l'.get? (f ix)
h : ‚àÄ {i : ‚Ñï}, i < l.length ‚Üí f i < l'.length
‚ä¢ ‚àÄ (ix : Fin l.length), l[‚Üëix] = l'[‚Üë((sorryAx (Fin l.length ‚Ü™o Fin l'.length) true) ix)]
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem sublist_iff_exists_fin_orderEmbedding_get_eq {l l' : List Œ±} :
    l <+ l' ‚Üî
      ‚àÉ f : Fin l.length ‚Ü™o Fin l'.length,
        ‚àÄ ix : Fin l.length, l.get ix = l'.get (f ix) ",":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï}, i < l.length ‚Üí f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) ?_, ?_‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [getElem?_eq_getElem i.2, getElem?_eq_getElem (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          ?_,
        ?_‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ have := (f ‚ü®i, hi‚ü©).is_lt
        omega
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi"
Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean,PrimeSpectrum.vanishingIdeal_irreducibleComponents,vanishingIdeal_irreducibleComponents,77a1d382025ec4a716e07b7aa5643b2094e305c8,":= by
  rw [irreducibleComponents_eq_maximals_closed, minimalPrimes_eq_minimals, ‚Üê minimals_swap,
    ‚Üê PrimeSpectrum.vanishingIdeal_isIrreducibleClosed, image_minimals_of_rel_iff_rel]
  exact fun s t hs _ ‚Ü¶ vanishingIdeal_anti_mono_iff hs.2","error:  unknown constant 'PrimeSpectrum.vanishingIdeal_isIrreducibleClosed'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.154218
R : Type u
S : Type v
inst‚úù : CommSemiring R
‚ä¢ vanishingIdeal '' minimals (Function.swap fun x x_1 ‚Ü¶ x ‚â§ x_1) {s | IsClosed s ‚àß IsIrreducible s} =
    minimals (fun x x_1 ‚Ü¶ x ‚â§ x_1) (setOf Ideal.IsPrime)","lemma vanishingIdeal_irreducibleComponents :
    vanishingIdeal '' (irreducibleComponents <| PrimeSpectrum R) =
    minimalPrimes R ",":= by
  rw [irreducibleComponents_eq_maximals_closed, minimalPrimes_eq_minimals, ‚Üê minimals_swap,
    ‚Üê PrimeSpectrum.vanishingIdeal_isClosed_isIrreducible, image_minimals_of_rel_iff_rel]
  exact fun s t hs _ ‚Ü¶ vanishingIdeal_anti_mono_iff hs.1"
Mathlib/Data/Int/Cast/Basic.lean,Int.cast_subNatNat,cast_subNatNat,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  unfold subNatNat
  cases e : n - m
  ¬∑ simp only [ofNat_eq_coe]
    simp [e, Nat.le_of_sub_eq_zero e]
  ¬∑ rw [cast_negSucc, Nat.add_one, ‚Üê e, Nat.cast_sub <| _root_.le_of_lt <| Nat.lt_of_sub_eq_succ e,
      neg_sub]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  n‚úù + 1
case succ
R : Type u
inst‚úù : AddGroupWithOne R
m n n‚úù : ‚Ñï
e : n - m = n‚úù + 1
‚ä¢ -‚Üën‚úù.succ = ‚Üëm - ‚Üën
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Int.cast_bit0` has been deprecated",theorem cast_subNatNat (m n) : ((Int.subNatNat m n : ‚Ñ§) : R) = m - n ,":= by
  unfold subNatNat
  cases e : n - m
  ¬∑ simp only [ofNat_eq_coe]
    simp [e, Nat.le_of_sub_eq_zero e]
  ¬∑ rw [cast_negSucc, ‚Üê e, Nat.cast_sub <| _root_.le_of_lt <| Nat.lt_of_sub_eq_succ e, neg_sub]"
Mathlib/Computability/TuringMachine.lean,Turing.TM2to1.tr_respects_aux‚ÇÇ,tr_respects_aux‚ÇÇ,3bcc0c6ed1b68b019a2329039651adf26348e80c,":= by
  dsimp only; simp; cases o with simp only [stWrite, stVar, trStAct, TM1.stepAux]
  | push f =>
    have := Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k (some (f v)))
    refine'
      ‚ü®_, fun k' ‚Ü¶ _, by
        erw [Tape.move_right_n_head, List.length, Tape.mk'_nth_nat, this,
          addBottom_modifyNth fun a ‚Ü¶ update a k (some (f v)), Nat.add_one, iterate_succ']
        ¬∑ rfl‚ü©
    refine' ListBlank.ext fun i ‚Ü¶ _
    rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
    by_cases h' : k' = k
    ¬∑ subst k'
      split_ifs with h
        <;> simp only [List.reverse_cons, Function.update_same, ListBlank.nth_mk, List.map]
      ¬∑ rw [List.getI_eq_get, List.get_append_right'] <;>
          simp only [h, List.get_singleton, List.length_map, List.length_reverse, Nat.succ_pos',
            List.length_append, lt_add_iff_pos_right, List.length, le_refl]
      rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk]
      cases' lt_or_gt_of_ne h with h h
      ¬∑ rw [List.getI_append]
        simpa only [List.length_map, List.length_reverse] using h
      ¬∑ rw [gt_iff_lt] at h
        rw [List.getI_eq_default, List.getI_eq_default] <;>
          simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
            List.length_append, List.length_map]
    ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
      rw [Function.update_noteq h']
  | peek f =>
    rw [Function.update_eq_self]
    use L, hL; rw [Tape.move_left_right]; congr
    cases e : S k; ¬∑ rfl
    rw [List.length_cons, iterate_succ', Function.comp, Tape.move_right_left,
      Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_snd, stk_nth_val _ (hL k), e,
      List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length]
    rfl
  | pop f =>
    cases' e : S k with hd tl
    ¬∑ simp only [Tape.mk'_head, ListBlank.head_cons, Tape.move_left_mk', List.length,
        Tape.write_mk', List.head?, iterate_zero_apply, List.tail_nil]
      rw [‚Üê e, Function.update_eq_self]
      exact ‚ü®L, hL, by rw [addBottom_head_fst, cond]‚ü©
    ¬∑ refine'
        ‚ü®_, fun k' ‚Ü¶ _, by
          erw [List.length_cons, Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_succ_fst,
            cond, iterate_succ', Function.comp, Tape.move_right_left, Tape.move_right_n_head,
            Tape.mk'_nth_nat, Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k none),
            addBottom_modifyNth fun a ‚Ü¶ update a k none, addBottom_nth_snd,
            stk_nth_val _ (hL k), e,
            show (List.cons hd tl).reverse.get? tl.length = some hd by
              rw [List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length],
            List.head?, List.tail]‚ü©
      refine' ListBlank.ext fun i ‚Ü¶ _
      rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
      by_cases h' : k' = k
      ¬∑ subst k'
        split_ifs with h <;> simp only [Function.update_same, ListBlank.nth_mk, List.tail]
        ¬∑ rw [List.getI_eq_default]
          ¬∑ rfl
          rw [h, List.length_reverse, List.length_map]
        rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk, e, List.map, List.reverse_cons]
        cases' lt_or_gt_of_ne h with h h
        ¬∑ rw [List.getI_append]
          simpa only [List.length_map, List.length_reverse] using h
        ¬∑ rw [gt_iff_lt] at h
          rw [List.getI_eq_default, List.getI_eq_default] <;>
            simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
              List.length_append, List.length_map]
      ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
        rw [Function.update_noteq h']","warning:  `List.get_append` has been deprecated, use `List.getElem_append` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get_replicate` has been deprecated, use `List.getElem_replicate` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  unused variable `M`
note: this linter can be disabled with `set_option linter.unusedVariables false`
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
error:  unsolved goals
case pos.h‚ÇÇ
K : Type u_1
inst‚úù¬≤ : DecidableEq K
Œì : K ‚Üí Type u_2
Œõ : Type u_3
inst‚úù¬π : Inhabited Œõ
œÉ : Type u_4
inst‚úù : Inhabited œÉ
k : K
q : TM1.Stmt Œì' Œõ' œÉ
v : œÉ
S : (k : K) ‚Üí List (Œì k)
L : ListBlank ((k : K) ‚Üí Option (Œì k))
hL : ‚àÄ (k : K), ListBlank.map (proj k) L = ListBlank.mk (List.map some (S k)).reverse
f : œÉ ‚Üí Œì k
this :
  ‚àÄ (L R : ListBlank Œì') (n : ‚Ñï),
    Tape.write ((R.nth n).1, update (R.nth n).2 k (some (f v))) ((Tape.move Dir.right)^[n] (Tape.mk' L R)) =
      (Tape.move Dir.right)^[n] (Tape.mk' L (ListBlank.modifyNth (fun a ‚Ü¶ (a.1, update a.2 k (some (f v)))) n R))
i : ‚Ñï
h : i = (S k).length
‚ä¢ (S k).length < (S k).length + (0 + 1)
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead","theorem tr_respects_aux‚ÇÇ {k : K} {q : Stmt‚ÇÇ‚ÇÅ} {v : œÉ} {S : ‚àÄ k, List (Œì k)}
    {L : ListBlank (‚àÄ k, Option (Œì k))}
    (hL : ‚àÄ k, L.map (proj k) = ListBlank.mk ((S k).map some).reverse) (o : StAct‚ÇÇ k) :
    let v' := stVar v (S k) o
    let Sk' := stWrite v (S k) o
    let S' := update S k Sk'
    ‚àÉ L' : ListBlank (‚àÄ k, Option (Œì k)),
      (‚àÄ k, L'.map (proj k) = ListBlank.mk ((S' k).map some).reverse) ‚àß
        TM1.stepAux (trStAct q o) v
            ((Tape.move Dir.right)^[(S k).length] (Tape.mk' ‚àÖ (addBottom L))) =
          TM1.stepAux q v' ((Tape.move Dir.right)^[(S' k).length] (Tape.mk' ‚àÖ (addBottom L'))) ",":= by
  dsimp only; simp; cases o with simp only [stWrite, stVar, trStAct, TM1.stepAux]
  | push f =>
    have := Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k (some (f v)))
    refine
      ‚ü®_, fun k' ‚Ü¶ ?_, by
        erw [Tape.move_right_n_head, List.length, Tape.mk'_nth_nat, this,
          addBottom_modifyNth fun a ‚Ü¶ update a k (some (f v)), Nat.add_one, iterate_succ']
        rfl‚ü©
    refine ListBlank.ext fun i ‚Ü¶ ?_
    rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
    by_cases h' : k' = k
    ¬∑ subst k'
      split_ifs with h
        <;> simp only [List.reverse_cons, Function.update_same, ListBlank.nth_mk, List.map]
      ¬∑ rw [List.getI_eq_get, List.get_append_right'] <;>
          simp only [List.length_singleton, h, List.length_reverse, List.length_map, Nat.sub_self,
            Fin.zero_eta, List.get_cons_zero, le_refl, List.length_append, Nat.lt_succ_self]
      rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk]
      cases' lt_or_gt_of_ne h with h h
      ¬∑ rw [List.getI_append]
        simpa only [List.length_map, List.length_reverse] using h
      ¬∑ rw [gt_iff_lt] at h
        rw [List.getI_eq_default, List.getI_eq_default] <;>
          simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
            List.length_append, List.length_map]
    ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
      rw [Function.update_noteq h']
  | peek f =>
    rw [Function.update_eq_self]
    use L, hL; rw [Tape.move_left_right]; congr
    cases e : S k; ¬∑ rfl
    rw [List.length_cons, iterate_succ', Function.comp, Tape.move_right_left,
      Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_snd, stk_nth_val _ (hL k), e,
      List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length]
    rfl
  | pop f =>
    cases' e : S k with hd tl
    ¬∑ simp only [Tape.mk'_head, ListBlank.head_cons, Tape.move_left_mk', List.length,
        Tape.write_mk', List.head?, iterate_zero_apply, List.tail_nil]
      rw [‚Üê e, Function.update_eq_self]
      exact ‚ü®L, hL, by rw [addBottom_head_fst, cond]‚ü©
    ¬∑ refine
        ‚ü®_, fun k' ‚Ü¶ ?_, by
          erw [List.length_cons, Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_succ_fst,
            cond, iterate_succ', Function.comp, Tape.move_right_left, Tape.move_right_n_head,
            Tape.mk'_nth_nat, Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k none),
            addBottom_modifyNth fun a ‚Ü¶ update a k none, addBottom_nth_snd,
            stk_nth_val _ (hL k), e,
            show (List.cons hd tl).reverse.get? tl.length = some hd by
              rw [List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length],
            List.head?, List.tail]‚ü©
      refine ListBlank.ext fun i ‚Ü¶ ?_
      rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
      by_cases h' : k' = k
      ¬∑ subst k'
        split_ifs with h <;> simp only [Function.update_same, ListBlank.nth_mk, List.tail]
        ¬∑ rw [List.getI_eq_default]
          ¬∑ rfl
          rw [h, List.length_reverse, List.length_map]
        rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk, e, List.map, List.reverse_cons]
        cases' lt_or_gt_of_ne h with h h
        ¬∑ rw [List.getI_append]
          simpa only [List.length_map, List.length_reverse] using h
        ¬∑ rw [gt_iff_lt] at h
          rw [List.getI_eq_default, List.getI_eq_default] <;>
            simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
              List.length_append, List.length_map]
      ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
        rw [Function.update_noteq h']"
Mathlib/Topology/UniformSpace/Cauchy.lean,UniformSpace.secondCountable_of_separable,secondCountable_of_separable,14167e48d13e9c2d72cbdff0431a8edba6021c34,":= by
  rcases exists_countable_dense Œ± with ‚ü®s, hsc, hsd‚ü©
  obtain
    ‚ü®t : ‚Ñï ‚Üí Set (Œ± √ó Œ±), hto : ‚àÄ i : ‚Ñï, t i ‚àà (ùì§ Œ±).sets ‚àß IsOpen (t i) ‚àß SymmetricRel (t i),
      h_basis : (ùì§ Œ±).HasAntitoneBasis t‚ü© :=
    (@uniformity_hasBasis_open_symmetric Œ± _).exists_antitone_subbasis
  choose ht_mem hto hts using hto
  refine' ‚ü®‚ü®‚ãÉ x ‚àà s, range fun k => ball x (t k), hsc.bunion·µ¢ fun x _ => countable_range _, _‚ü©‚ü©
  refine' (isTopologicalBasis_of_open_of_nhds _ _).eq_generateFrom
  ¬∑ simp only [mem_union·µ¢‚ÇÇ, mem_range]
    rintro _ ‚ü®x, _, k, rfl‚ü©
    exact isOpen_ball x (hto k)
  ¬∑ intro x V hxV hVo
    simp only [mem_union·µ¢‚ÇÇ, mem_range, exists_prop]
    rcases UniformSpace.mem_nhds_iff.1 (IsOpen.mem_nhds hVo hxV) with ‚ü®U, hU, hUV‚ü©
    rcases comp_symm_of_uniformity hU with ‚ü®U', hU', _, hUU'‚ü©
    rcases h_basis.toHasBasis.mem_iff.1 hU' with ‚ü®k, -, hk‚ü©
    rcases hsd.inter_open_nonempty (ball x <| t k) (isOpen_ball x (hto k))
        ‚ü®x, UniformSpace.mem_ball_self _ (ht_mem k)‚ü© with
      ‚ü®y, hxy, hys‚ü©
    refine' ‚ü®_, ‚ü®y, hys, k, rfl‚ü©, (hts k).subset hxy, fun z hz => _‚ü©
    exact hUV (ball_subset_of_comp_subset (hk hxy) hUU' (hk hz))","error:  invalid field 'bunion·µ¢', the environment does not contain 'Set.Countable.bunion·µ¢'
  hsc
has type
  s.Countable
error:  invalid field 'bunion·µ¢', the environment does not contain 'Countable.bunion·µ¢'
  hsc
has type
  Countable ‚Üës
error:  unknown identifier 'isTopologicalBasis_of_open_of_nhds'
error:  no goals to be solved",theorem secondCountable_of_separable [SeparableSpace Œ±] : SecondCountableTopology Œ± ,":= by
  rcases exists_countable_dense Œ± with ‚ü®s, hsc, hsd‚ü©
  obtain
    ‚ü®t : ‚Ñï ‚Üí Set (Œ± √ó Œ±), hto : ‚àÄ i : ‚Ñï, t i ‚àà (ùì§ Œ±).sets ‚àß IsOpen (t i) ‚àß SymmetricRel (t i),
      h_basis : (ùì§ Œ±).HasAntitoneBasis t‚ü© :=
    (@uniformity_hasBasis_open_symmetric Œ± _).exists_antitone_subbasis
  choose ht_mem hto hts using hto
  refine ‚ü®‚ü®‚ãÉ x ‚àà s, range fun k => ball x (t k), hsc.biUnion fun x _ => countable_range _, ?_‚ü©‚ü©
  refine (isTopologicalBasis_of_isOpen_of_nhds ?_ ?_).eq_generateFrom
  ¬∑ simp only [mem_iUnion‚ÇÇ, mem_range]
    rintro _ ‚ü®x, _, k, rfl‚ü©
    exact isOpen_ball x (hto k)
  ¬∑ intro x V hxV hVo
    simp only [mem_iUnion‚ÇÇ, mem_range, exists_prop]
    rcases UniformSpace.mem_nhds_iff.1 (IsOpen.mem_nhds hVo hxV) with ‚ü®U, hU, hUV‚ü©
    rcases comp_symm_of_uniformity hU with ‚ü®U', hU', _, hUU'‚ü©
    rcases h_basis.toHasBasis.mem_iff.1 hU' with ‚ü®k, -, hk‚ü©
    rcases hsd.inter_open_nonempty (ball x <| t k) (isOpen_ball x (hto k))
        ‚ü®x, UniformSpace.mem_ball_self _ (ht_mem k)‚ü© with
      ‚ü®y, hxy, hys‚ü©
    refine ‚ü®_, ‚ü®y, hys, k, rfl‚ü©, (hts k).subset hxy, fun z hz => ?_‚ü©
    exact hUV (ball_subset_of_comp_subset (hk hxy) hUU' (hk hz))"
Mathlib/MeasureTheory/Integral/CircleTransform.lean,Complex.circleTransformDeriv_bound,circleTransformDeriv_bound,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  obtain ‚ü®r, hr, hrx‚ü© := exists_lt_mem_ball_of_mem_ball hx
  obtain ‚ü®Œµ', hŒµ', H‚ü© := exists_ball_subset_ball hrx
  obtain ‚ü®‚ü®‚ü®a, b‚ü©, ‚ü®ha, hb‚ü©‚ü©, hab‚ü© :=
    abs_circleTransformBoundingFunction_le hr (pos_of_mem_ball hrx).le z
  let V : ‚Ñù ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ := fun Œ∏ w => circleTransformDeriv R z w (fun _ => 1) Œ∏
  have funccomp : ContinuousOn (fun r => abs (f r)) (sphere z R) := by
    have cabs : ContinuousOn abs ‚ä§ := by apply continuous_abs.continuousOn
    apply cabs.comp hf; rw [MapsTo]; tauto
  have sbou :=
    IsCompact.exists_isMaxOn (isCompact_sphere z R) (NormedSpace.sphere_nonempty.2 hR.le) funccomp
  obtain ‚ü®X, HX, HX2‚ü© := sbou
  refine' ‚ü®abs (V b a) * abs (f X), Œµ', hŒµ', Subset.trans H (ball_subset_ball hr.le), _‚ü©
  intro y v hv
  obtain ‚ü®y1, hy1, hfun‚ü© :=
    Periodic.exists_mem_Ico‚ÇÄ (circleTransformDeriv_periodic R z v f) Real.two_pi_pos y
  have hy2 : y1 ‚àà [[0, 2 * œÄ]] := by
    convert Ico_subset_Icc_self hy1 using 1
    simp [uIcc_of_le Real.two_pi_pos.le]
  simp only [IsMaxOn, IsMaxFilter, eventually_principal, mem_sphere_iff_norm, norm_eq_abs] at HX2
  have := mul_le_mul (hab ‚ü®‚ü®v, y1‚ü©, ‚ü®ball_subset_closedBall (H hv), hy2‚ü©‚ü©)
    (HX2 (circleMap z R y1) (circleMap_mem_sphere z hR.le y1)) (Complex.abs.nonneg _)
    (Complex.abs.nonneg _)
  simp_rw [hfun]
  simp only [circleTransformBoundingFunction, circleTransformDeriv, norm_eq_abs,
    Algebra.id.smul_eq_mul, deriv_circleMap, map_mul, abs_circleMap_zero, abs_I, mul_one, ‚Üê
    mul_assoc, mul_inv_rev, inv_I, abs_neg, abs_inv, abs_ofReal, one_mul, abs_two, abs_pow,
    mem_ball, gt_iff_lt, Subtype.coe_mk, SetCoe.forall, mem_prod, mem_closedBall, and_imp,
    Prod.forall, NormedSpace.sphere_nonempty, mem_sphere_iff_norm] at *
  exact this","error:  type mismatch
  this
has type
  abs (-I) * abs (‚ÜëœÄ)‚Åª¬π * abs 2‚Åª¬π * |R| * abs ((circleMap z R y1 - v) ^ 2)‚Åª¬π * abs (f (circleMap z R y1)) ‚â§
    abs (-I) * abs (‚ÜëœÄ)‚Åª¬π * abs 2‚Åª¬π * |R| * abs ((circleMap z R b - a) ^ 2)‚Åª¬π * abs (f X) : Prop
but is expected to have type
  abs (-I) * abs (‚ÜëœÄ)‚Åª¬π * abs 2‚Åª¬π * |R| * abs ((circleMap z R y1 - v) ^ 2)‚Åª¬π * abs (f (circleMap z R y1)) ‚â§
    abs (V b a) * abs (f X) : Prop","theorem circleTransformDeriv_bound {R : ‚Ñù} (hR : 0 < R) {z x : ‚ÑÇ} {f : ‚ÑÇ ‚Üí ‚ÑÇ} (hx : x ‚àà ball z R)
    (hf : ContinuousOn f (sphere z R)) : ‚àÉ B Œµ : ‚Ñù, 0 < Œµ ‚àß
      ball x Œµ ‚äÜ ball z R ‚àß ‚àÄ (t : ‚Ñù), ‚àÄ y ‚àà ball x Œµ, ‚ÄñcircleTransformDeriv R z y f t‚Äñ ‚â§ B ",":= by
  obtain ‚ü®r, hr, hrx‚ü© := exists_lt_mem_ball_of_mem_ball hx
  obtain ‚ü®Œµ', hŒµ', H‚ü© := exists_ball_subset_ball hrx
  obtain ‚ü®‚ü®‚ü®a, b‚ü©, ‚ü®ha, hb‚ü©‚ü©, hab‚ü© :=
    abs_circleTransformBoundingFunction_le hr (pos_of_mem_ball hrx).le z
  let V : ‚Ñù ‚Üí ‚ÑÇ ‚Üí ‚ÑÇ := fun Œ∏ w => circleTransformDeriv R z w (fun _ => 1) Œ∏
  obtain ‚ü®X, -, HX2‚ü© := (isCompact_sphere z R).exists_isMaxOn
    (NormedSpace.sphere_nonempty.2 hR.le) hf.norm
  refine ‚ü®abs (V b a) * abs (f X), Œµ', hŒµ', H.trans (ball_subset_ball hr.le), fun y v hv ‚Ü¶ ?_‚ü©
  obtain ‚ü®y1, hy1, hfun‚ü© :=
    Periodic.exists_mem_Ico‚ÇÄ (circleTransformDeriv_periodic R z v f) Real.two_pi_pos y
  have hy2 : y1 ‚àà [[0, 2 * œÄ]] := Icc_subset_uIcc <| Ico_subset_Icc_self hy1
  simp only [isMaxOn_iff, mem_sphere_iff_norm, norm_eq_abs] at HX2
  have := mul_le_mul (hab ‚ü®‚ü®v, y1‚ü©, ‚ü®ball_subset_closedBall (H hv), hy2‚ü©‚ü©)
    (HX2 (circleMap z R y1) (circleMap_mem_sphere z hR.le y1)) (Complex.abs.nonneg _)
    (Complex.abs.nonneg _)
  rw [hfun]
  simpa [V, circleTransformBoundingFunction, circleTransformDeriv, mul_assoc] using this"
Mathlib/Order/WithBot.lean,WithBot.coe_le_coe,coe_le_coe,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  some_le_some",error:  unknown identifier 'some_le_some',theorem coe_le_coe : (a : WithBot Œ±) ‚â§ b ‚Üî a ‚â§ b ,":= by
  simp [LE.le]"
Mathlib/Geometry/Manifold/IntegralCurve.lean,IsIntegralCurveAt.comp_mul_ne_zero,IsIntegralCurveAt.comp_mul_ne_zero,d9ef486fb98831a09bf2e9a70744861e37dc428e,":= by
  obtain ‚ü®Œµ, hŒµ, h‚ü© := isIntegralCurveAt_iff.mp hŒ≥
  rw [isIntegralCurveAt_iff]
  refine ‚ü®Œµ / |a|, div_pos hŒµ (abs_pos.mpr ha), ?_‚ü©
  convert h.comp_mul a
  ext t
  rw [mem_setOf_eq, Metric.mem_ball, Metric.mem_ball, Real.dist_eq, Real.dist_eq,
    lt_div_iff (abs_pos.mpr ha), ‚Üê abs_mul, sub_mul, div_mul_cancel _ ha]","error:  failed to synthesize
  HDiv (Set ‚Ñù) ‚Ñù ?m.224149
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  div_pos hŒµ
argument
  hŒµ
has type
  Œµ ‚àà ùìù t‚ÇÄ : Prop
but is expected to have type
  0 < ?m.224170 : Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.226810 ‚àà Metric.ball ?m.226809 ?m.226811
case h.e'_13.h
E : Type u_1
inst‚úù‚Å∂ : NormedAddCommGroup E
inst‚úù‚Åµ : NormedSpace ‚Ñù E
inst‚úù‚Å¥ : CompleteSpace E
H : Type u_2
inst‚úù¬≥ : TopologicalSpace H
I : ModelWithCorners ‚Ñù E H
M : Type u_3
inst‚úù¬≤ : TopologicalSpace M
inst‚úù¬π : ChartedSpace H M
inst‚úù : SmoothManifoldWithCorners I M
Œ≥ Œ≥' : ‚Ñù ‚Üí M
v : (x : M) ‚Üí TangentSpace I x
s s' : Set ‚Ñù
t‚ÇÄ : ‚Ñù
hŒ≥ : IsIntegralCurveAt Œ≥ v t‚ÇÄ
a : ‚Ñù
ha : a ‚â† 0
Œµ : Set ‚Ñù
hŒµ : Œµ ‚àà ùìù t‚ÇÄ
h : IsIntegralCurveOn Œ≥ v Œµ
t : ‚Ñù
‚ä¢ t ‚àà sorryAx (Set ‚Ñù) true ‚Üî t * a ‚àà Œµ","lemma IsIntegralCurveAt.comp_mul_ne_zero (hŒ≥ : IsIntegralCurveAt Œ≥ v t‚ÇÄ) {a : ‚Ñù} (ha : a ‚â† 0) :
    IsIntegralCurveAt (Œ≥ ‚àò (¬∑ * a)) (a ‚Ä¢ v) (t‚ÇÄ / a) ",":= by
  rw [isIntegralCurveAt_iff'] at *
  obtain ‚ü®Œµ, hŒµ, h‚ü© := hŒ≥
  refine ‚ü®Œµ / |a|, by positivity, ?_‚ü©
  convert h.comp_mul a
  ext t
  rw [mem_setOf_eq, Metric.mem_ball, Metric.mem_ball, Real.dist_eq, Real.dist_eq,
    lt_div_iff (abs_pos.mpr ha), ‚Üê abs_mul, sub_mul, div_mul_cancel‚ÇÄ _ ha]"
Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean,MeasureTheory.Measure.rnDeriv_withDensity_right,rnDeriv_withDensity_right,6861d9247d1a06a093e444c3a0319e5ec45263c2,":= by
  have : SigmaFinite (ŒΩ.withDensity f) := SigmaFinite.withDensity_of_ne_top hf hf_ne_top
  refine (withDensity_absolutelyContinuous' hf hf_ne_zero hf_ne_top).ae_eq ?_
  refine (Measure.eq_rnDeriv‚ÇÄ (ŒΩ := ŒΩ.withDensity f) ?_ Measure.MutuallySingular.zero_left ?_).symm
  ¬∑ exact (hf.inv.mono_ac (withDensity_absolutelyContinuous _ _)).mul
      (Measure.measurable_rnDeriv _ _).aemeasurable
  ¬∑ ext1 s hs
    conv_lhs => rw [‚Üê Measure.withDensity_rnDeriv_eq _ _ hŒºŒΩ]
    rw [zero_add, withDensity_apply _ hs, withDensity_apply _ hs]
    rw [set_lintegral_withDensity_eq_set_lintegral_mul_non_measurable‚ÇÄ _ _ _ hs]
    ¬∑ simp only [Pi.mul_apply]
      have : (fun a ‚Ü¶ f a * ((f a)‚Åª¬π * Œº.rnDeriv ŒΩ a)) =·µê[ŒΩ] Œº.rnDeriv ŒΩ := by
        filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2
        simp [‚Üê mul_assoc, ENNReal.mul_inv_cancel, hx1, hx2]
      rw [lintegral_congr_ae (ae_restrict_of_ae this)]
    ¬∑ apply ae_restrict_of_ae
      filter_upwards [hf_ne_top] with x hx using hx.lt_top
    ¬∑ exact hf.restrict","error:  application type mismatch
  withDensity_absolutelyContinuous' hf hf_ne_zero hf_ne_top
argument
  hf_ne_top
has type
  ‚àÄ·µê (x : Œ±) ‚àÇŒΩ, f x ‚â† ‚ä§ : Prop
but is expected to have type
  (ŒΩ.withDensity f) ?m.16000 = 0 : Prop
error:  no goals to be solved","lemma rnDeriv_withDensity_right_of_absolutelyContinuous {ŒΩ : Measure Œ±} [SigmaFinite Œº]
    [SigmaFinite ŒΩ] (hŒºŒΩ : Œº ‚â™ ŒΩ) (hf : AEMeasurable f ŒΩ)
    (hf_ne_zero : ‚àÄ·µê x ‚àÇŒΩ, f x ‚â† 0) (hf_ne_top : ‚àÄ·µê x ‚àÇŒΩ, f x ‚â† ‚àû) :
    Œº.rnDeriv (ŒΩ.withDensity f) =·µê[ŒΩ] fun x ‚Ü¶ (f x)‚Åª¬π * Œº.rnDeriv ŒΩ x ",":= by
  have : SigmaFinite (ŒΩ.withDensity f) := SigmaFinite.withDensity_of_ne_top hf hf_ne_top
  refine (withDensity_absolutelyContinuous' hf hf_ne_zero).ae_eq ?_
  refine (Measure.eq_rnDeriv‚ÇÄ (ŒΩ := ŒΩ.withDensity f) ?_ Measure.MutuallySingular.zero_left ?_).symm
  ¬∑ exact (hf.inv.mono_ac (withDensity_absolutelyContinuous _ _)).mul
      (Measure.measurable_rnDeriv _ _).aemeasurable
  ¬∑ ext1 s hs
    conv_lhs => rw [‚Üê Measure.withDensity_rnDeriv_eq _ _ hŒºŒΩ]
    rw [zero_add, withDensity_apply _ hs, withDensity_apply _ hs]
    rw [setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable‚ÇÄ _ _ _ hs]
    ¬∑ simp only [Pi.mul_apply]
      have : (fun a ‚Ü¶ f a * ((f a)‚Åª¬π * Œº.rnDeriv ŒΩ a)) =·µê[ŒΩ] Œº.rnDeriv ŒΩ := by
        filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2
        simp [‚Üê mul_assoc, ENNReal.mul_inv_cancel, hx1, hx2]
      rw [lintegral_congr_ae (ae_restrict_of_ae this)]
    ¬∑ refine ae_restrict_of_ae ?_
      filter_upwards [hf_ne_top] with x hx using hx.lt_top
    ¬∑ exact hf.restrict"
Mathlib/Data/List/OfFn.lean,List.get?_ofFn,get?_ofFn,5068808d2b4c25cf905cf7fee10ded8e447c2346,":=
  if h : i < (ofFn f).length
  then by
    rw [get?_eq_get h, get_ofFn]
    . simp at h; simp [ofFnNthVal, h]
  else by
    rw [ofFnNthVal, dif_neg] <;>
    simpa using h","error:  type mismatch
  h‚úù
has type
  n ‚â§ i : Prop
but is expected to have type
  ofFnNthVal f i = none : Prop
error:  unsolved goals
Œ± : Type u
n : ‚Ñï
f : Fin n ‚Üí Œ±
i : ‚Ñï
h : ¬¨i < (ofFn f).length
‚ä¢ (ofFn f).get? i = none
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_ofFn` has been deprecated, use `List.get_ofFn` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead",theorem get?_ofFn {n} (f : Fin n ‚Üí Œ±) (i) : get? (ofFn f) i = ofFnNthVal f i ,":= by
  simp"
Mathlib/Topology/UniformSpace/Pi.lean,Pi.uniformSpace_comap_restrict,Pi.uniformSpace_comap_restrict,2c616cf6d72eab2cc0cb8be21b40be572f4b56bf,":= by
  simp [‚Üê iInf_subtype'', ‚Üê uniformSpace_comap_precomp' _ ((‚Üë) : S ‚Üí Œπ), Set.restrict]","error:  unsolved goals
Œπ : Type u_1
Œπ' : Type u_2
Œ≤ : Type u_3
Œ± : Œπ ‚Üí Type u
U : (i : Œπ) ‚Üí UniformSpace (Œ± i)
inst‚úù : UniformSpace Œ≤
S : Set Œπ
‚ä¢ UniformSpace.comap S.restrict (uniformSpace fun i ‚Ü¶ Œ± ‚Üëi) =
    UniformSpace.comap (fun g i' ‚Ü¶ g ‚Üëi') (uniformSpace fun i' ‚Ü¶ Œ± ‚Üëi')","lemma Pi.uniformSpace_comap_restrict (S : Set Œπ) :
    UniformSpace.comap (S.restrict) (Pi.uniformSpace (fun i : S ‚Ü¶ Œ± i)) =
    ‚®Ö i ‚àà S, UniformSpace.comap (eval i) (U i) ",":= by
  simp (config := { unfoldPartialApp := true })
    [‚Üê iInf_subtype'', ‚Üê uniformSpace_comap_precomp' _ ((‚Üë) : S ‚Üí Œπ), Set.restrict]"
Mathlib/Algebra/MonoidAlgebra/Degree.lean,AddMonoidAlgebra.le_infDegree_mul,le_infDegree_mul,9288dfb2f7753ca66fd555aa00b7686ee19031ad,":=
  le_inf_support_mul (fun {a b : A} => (AddMonoidHom.map_add D a b).ge) _ _","error:  type mismatch
  Eq.ge (AddMonoidHom.map_add ?m.194621 a b)
has type
  ?m.194621 a + ?m.194621 b ‚â§ ?m.194621 (a + b) : Prop
but is expected to have type
  D a + D b ‚â§ D (a + b) : Prop","theorem le_infDegree_mul (f g : R[A]) :
    f.infDegree D + g.infDegree D ‚â§ (f * g).infDegree D ",":=
  le_inf_support_mul (fun {a b : A} => (map_add D a b).ge) _ _"
Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean,WeierstrassCurve.Jacobian.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,5f623dbbfb1d9c0f7f7df0c222909ea19906d81f,":= by
  have hPx : P x ‚â† 0 := X_ne_zero_of_Z_eq_zero hP hPz
  have hPy : P y ‚â† 0 := Y_ne_zero_of_Z_eq_zero hP hPz
  have hQx : Q x ‚â† 0 := X_ne_zero_of_Z_eq_zero hQ hQz
  have hQy : Q y ‚â† 0 := Y_ne_zero_of_Z_eq_zero hQ hQz
  simp only [nonsingular_of_Z_eq_zero, equation_of_Z_eq_zero, hPz, hQz] at hP hQ
  use (Units.mk0 _ hPy / Units.mk0 _ hPx) * (Units.mk0 _ hQx / Units.mk0 _ hQy)
  simp only [smul_fin3, Units.val_mul, Units.val_div_eq_div_val, Units.val_mk0, mul_pow, hQz,
    mul_zero]
  conv_rhs => rw [‚Üê fin3_def P, hPz]
  congr! 2
  ¬∑ rw [div_pow, hP.left, pow_succ, mul_div_cancel_left‚ÇÄ _ <| pow_ne_zero 2 hPx, div_pow, hQ.left,
      pow_succ _ 2, div_mul_cancel_left‚ÇÄ <| pow_ne_zero 2 hQx, inv_mul_cancel_right‚ÇÄ hQx]
  ¬∑ rw [div_pow, ‚Üê hP.left, pow_succ, mul_div_cancel_left‚ÇÄ _ <| pow_ne_zero 2 hPy, div_pow,
      ‚Üê hQ.left, pow_succ _ 2, div_mul_cancel_left‚ÇÄ <| pow_ne_zero 2 hQy, inv_mul_cancel_right‚ÇÄ hQy]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?a / ?b) ^ ?n
case h
R : Type u
inst‚úù¬π : CommRing R
W' : Jacobian R
F : Type v
inst‚úù : Field F
W : Jacobian F
P Q : Fin 3 ‚Üí F
hPz : P z = 0
hQz : Q z = 0
hPx : P x ‚â† 0
hPy : P y ‚â† 0
hQx : Q x ‚â† 0
hQy : Q y ‚â† 0
hP : P y ^ 2 = P x ^ 3 ‚àß (3 * P x ^ 2 ‚â† 0 ‚à® 2 * P y ‚â† 0 ‚à® W.a‚ÇÅ * P x * P y ‚â† 0)
hQ : Q y ^ 2 = Q x ^ 3 ‚àß (3 * Q x ^ 2 ‚â† 0 ‚à® 2 * Q y ‚â† 0 ‚à® W.a‚ÇÅ * Q x * Q y ‚â† 0)
‚ä¢ (Units.mk0 (P y) hPy / Units.mk0 (P x) hPx * (Units.mk0 (Q x) hQx / Units.mk0 (Q y) hQy)) ‚Ä¢ Q = ![P x, P y, 0]
error:  no goals to be solved","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  have hPx : IsUnit <| P x := isUnit_X_of_Z_eq_zero hP hPz
  have hPy : IsUnit <| P y := isUnit_Y_of_Z_eq_zero hP hPz
  have hQx : IsUnit <| Q x := isUnit_X_of_Z_eq_zero hQ hQz
  have hQy : IsUnit <| Q y := isUnit_Y_of_Z_eq_zero hQ hQz
  simp only [nonsingular_of_Z_eq_zero, equation_of_Z_eq_zero, hPz, hQz] at hP hQ
  use (hPy.unit / hPx.unit) * (hQx.unit / hQy.unit)
  simp only [Units.smul_def, smul_fin3, Units.val_mul, Units.val_div_eq_div_val, IsUnit.unit_spec,
    mul_pow, div_pow, hQz, mul_zero]
  conv_rhs => rw [‚Üê fin3_def P, hPz]
  congr! 2
  ¬∑ rw [hP.left, pow_succ, (hPx.pow 2).mul_div_cancel_left, hQ.left, pow_succ _ 2,
      (hQx.pow 2).div_mul_cancel_left, hQx.inv_mul_cancel_right]
  ¬∑ rw [‚Üê hP.left, pow_succ, (hPy.pow 2).mul_div_cancel_left, ‚Üê hQ.left, pow_succ _ 2,
      (hQy.pow 2).div_mul_cancel_left, hQy.inv_mul_cancel_right]"
Mathlib/Analysis/Normed/Group/ControlledClosure.lean,controlled_closure_of_complete,controlled_closure_of_complete,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  rintro (h : H) (h_in : h ‚àà K.topologicalClosure)
  by_cases hyp_h : h = 0
  ¬∑ rw [hyp_h]
    use 0
    simp
  set b : ‚Ñï ‚Üí ‚Ñù := fun i => (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
  have b_pos : ‚àÄ i, 0 < b i := by
    intro i
    field_simp [b, hC]
    exact
      div_pos (mul_pos hŒµ (norm_pos_iff.mpr hyp_h)) (mul_pos (by norm_num : (0 : ‚Ñù) < 2 ^ i * 2) hC)
  obtain
    ‚ü®v : ‚Ñï ‚Üí H, lim_v : Tendsto (fun n : ‚Ñï => ‚àë k in range (n + 1), v k) atTop (ùìù h), v_in :
      ‚àÄ n, v n ‚àà K, hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0, hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n‚ü© :=
    controlled_sum_of_mem_closure h_in b_pos
  have : ‚àÄ n, ‚àÉ m' : G, f m' = v n ‚àß ‚Äñm'‚Äñ ‚â§ C * ‚Äñv n‚Äñ := fun n : ‚Ñï => hyp (v n) (v_in n)
  choose u hu hnorm_u using this
  set s : ‚Ñï ‚Üí G := fun n => ‚àë k in range (n + 1), u k
  have : CauchySeq s := by
    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one
    rintro n (hn : n ‚â• 1)
    calc
      ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ := hnorm_u n
      _ ‚â§ C * b n := by gcongr; exact (hv _ <| Nat.succ_le_iff.mp hn).le
      _ = (1 / 2) ^ n * (Œµ * ‚Äñh‚Äñ / 2) := by simp [mul_div_cancel' _ hC.ne.symm]
      _ = Œµ * ‚Äñh‚Äñ / 2 * (1 / 2) ^ n := mul_comm _ _
  obtain ‚ü®g : G, hg‚ü© := cauchySeq_tendsto_of_complete this
  refine' ‚ü®g, _, _‚ü©
  ¬∑ 
    have : f ‚àò s = fun n => ‚àë k in range (n + 1), v k := by
      ext n
      simp [s, map_sum, hu]
    rw [‚Üê this] at lim_v
    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v
  ¬∑ 
    suffices ‚àÄ n, ‚Äñs n‚Äñ ‚â§ (C + Œµ) * ‚Äñh‚Äñ from
      le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this
    intro n
    have hnorm‚ÇÄ : ‚Äñu 0‚Äñ ‚â§ C * b 0 + C * ‚Äñh‚Äñ := by
      have :=
        calc
          ‚Äñv 0‚Äñ ‚â§ ‚Äñh‚Äñ + ‚Äñv 0 - h‚Äñ := norm_le_insert' _ _
          _ ‚â§ ‚Äñh‚Äñ + b 0 := by gcongr
      calc
        ‚Äñu 0‚Äñ ‚â§ C * ‚Äñv 0‚Äñ := hnorm_u 0
        _ ‚â§ C * (‚Äñh‚Äñ + b 0) := by gcongr
        _ = C * b 0 + C * ‚Äñh‚Äñ := by rw [add_comm, mul_add]
    have : (‚àë k in range (n + 1), C * b k) ‚â§ Œµ * ‚Äñh‚Äñ :=
      calc
        (‚àë k in range (n + 1), C * b k) = (‚àë k in range (n + 1), (1 / 2 : ‚Ñù) ^ k) * (Œµ * ‚Äñh‚Äñ / 2) :=
          by simp only [mul_div_cancel' _ hC.ne.symm, ‚Üê sum_mul]
        _ ‚â§ 2 * (Œµ * ‚Äñh‚Äñ / 2) := by gcongr; apply sum_geometric_two_le
        _ = Œµ * ‚Äñh‚Äñ := mul_div_cancel' _ two_ne_zero
    calc
      ‚Äñs n‚Äñ ‚â§ ‚àë k in range (n + 1), ‚Äñu k‚Äñ := norm_sum_le _ _
      _ = (‚àë k in range n, ‚Äñu (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := (sum_range_succ' _ _)
      _ ‚â§ (‚àë k in range n, C * ‚Äñv (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := by gcongr; apply hnorm_u
      _ ‚â§ (‚àë k in range n, C * b (k + 1)) + (C * b 0 + C * ‚Äñh‚Äñ) := by
        gcongr with k; exact (hv _ k.succ_pos).le
      _ = (‚àë k in range (n + 1), C * b k) + C * ‚Äñh‚Äñ := by rw [‚Üê add_assoc, sum_range_succ']
      _ ‚â§ (C + Œµ) * ‚Äñh‚Äñ := by
        rw [add_comm, add_mul]
        apply add_le_add_left this","error:  type mismatch
  div_pos (mul_pos hŒµ (norm_pos_iff.mpr hyp_h))
    (mul_pos
      (of_eq_true
        (Eq.trans
          (Mathlib.Algebra.Order.GroupWithZero.Unbundled._auxLemma.5
            (of_eq_true
              (Eq.trans
                (Mathlib.Algebra.Order.Ring.Defs._auxLemma.3
                  (of_eq_true
                    (eq_true
                      (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ‚Ñù Nat.cast_zero)
                        (Mathlib.Meta.NormNum.isNat_ofNat ‚Ñù (Eq.refl 2)) (Eq.refl false))))
                  i)
                (eq_true True.intro))))
          (eq_true
            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ‚Ñù Nat.cast_zero)
              (Mathlib.Meta.NormNum.isNat_ofNat ‚Ñù (Eq.refl 2)) (Eq.refl false)))))
      hC)
has type
  0 < Œµ * ‚Äñh‚Äñ / (2 ^ i * 2 * C) : Prop
but is expected to have type
  ¬¨h = 0 : Prop
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancel‚ÇÄ` instead
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancel‚ÇÄ` instead
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancel‚ÇÄ` instead","theorem controlled_closure_of_complete {f : NormedAddGroupHom G H} {K : AddSubgroup H} {C Œµ : ‚Ñù}
    (hC : 0 < C) (hŒµ : 0 < Œµ) (hyp : f.SurjectiveOnWith K C) :
    f.SurjectiveOnWith K.topologicalClosure (C + Œµ) ",":= by
  rintro (h : H) (h_in : h ‚àà K.topologicalClosure)
  by_cases hyp_h : h = 0
  ¬∑ rw [hyp_h]
    use 0
    simp
  set b : ‚Ñï ‚Üí ‚Ñù := fun i => (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
  have b_pos (i) : 0 < b i := by field_simp [b, hC, hyp_h]
  obtain
    ‚ü®v : ‚Ñï ‚Üí H, lim_v : Tendsto (fun n : ‚Ñï => ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h), v_in :
      ‚àÄ n, v n ‚àà K, hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0, hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n‚ü© :=
    controlled_sum_of_mem_closure h_in b_pos
  have : ‚àÄ n, ‚àÉ m' : G, f m' = v n ‚àß ‚Äñm'‚Äñ ‚â§ C * ‚Äñv n‚Äñ := fun n : ‚Ñï => hyp (v n) (v_in n)
  choose u hu hnorm_u using this
  set s : ‚Ñï ‚Üí G := fun n => ‚àë k ‚àà range (n + 1), u k
  have : CauchySeq s := by
    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one
    ¬∑ rintro n (hn : n ‚â• 1)
      calc
        ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ := hnorm_u n
        _ ‚â§ C * b n := by gcongr; exact (hv _ <| Nat.succ_le_iff.mp hn).le
        _ = (1 / 2) ^ n * (Œµ * ‚Äñh‚Äñ / 2) := by simp [mul_div_cancel‚ÇÄ _ hC.ne.symm]
        _ = Œµ * ‚Äñh‚Äñ / 2 * (1 / 2) ^ n := mul_comm _ _
  obtain ‚ü®g : G, hg‚ü© := cauchySeq_tendsto_of_complete this
  refine ‚ü®g, ?_, ?_‚ü©
  ¬∑ 
    have : f ‚àò s = fun n => ‚àë k ‚àà range (n + 1), v k := by
      ext n
      simp [s, map_sum, hu]
    rw [‚Üê this] at lim_v
    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v
  ¬∑ 
    suffices ‚àÄ n, ‚Äñs n‚Äñ ‚â§ (C + Œµ) * ‚Äñh‚Äñ from
      le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this
    intro n
    have hnorm‚ÇÄ : ‚Äñu 0‚Äñ ‚â§ C * b 0 + C * ‚Äñh‚Äñ := by
      have :=
        calc
          ‚Äñv 0‚Äñ ‚â§ ‚Äñh‚Äñ + ‚Äñv 0 - h‚Äñ := norm_le_insert' _ _
          _ ‚â§ ‚Äñh‚Äñ + b 0 := by gcongr
      calc
        ‚Äñu 0‚Äñ ‚â§ C * ‚Äñv 0‚Äñ := hnorm_u 0
        _ ‚â§ C * (‚Äñh‚Äñ + b 0) := by gcongr
        _ = C * b 0 + C * ‚Äñh‚Äñ := by rw [add_comm, mul_add]
    have : (‚àë k ‚àà range (n + 1), C * b k) ‚â§ Œµ * ‚Äñh‚Äñ :=
      calc (‚àë k ‚àà range (n + 1), C * b k)
        _ = (‚àë k ‚àà range (n + 1), (1 / 2 : ‚Ñù) ^ k) * (Œµ * ‚Äñh‚Äñ / 2) := by
          simp only [mul_div_cancel‚ÇÄ _ hC.ne.symm, ‚Üê sum_mul]
        _ ‚â§ 2 * (Œµ * ‚Äñh‚Äñ / 2) := by gcongr; apply sum_geometric_two_le
        _ = Œµ * ‚Äñh‚Äñ := mul_div_cancel‚ÇÄ _ two_ne_zero
    calc
      ‚Äñs n‚Äñ ‚â§ ‚àë k ‚àà range (n + 1), ‚Äñu k‚Äñ := norm_sum_le _ _
      _ = (‚àë k ‚àà range n, ‚Äñu (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := sum_range_succ' _ _
      _ ‚â§ (‚àë k ‚àà range n, C * ‚Äñv (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := by gcongr; apply hnorm_u
      _ ‚â§ (‚àë k ‚àà range n, C * b (k + 1)) + (C * b 0 + C * ‚Äñh‚Äñ) := by
        gcongr with k; exact (hv _ k.succ_pos).le
      _ = (‚àë k ‚àà range (n + 1), C * b k) + C * ‚Äñh‚Äñ := by rw [‚Üê add_assoc, sum_range_succ']
      _ ‚â§ (C + Œµ) * ‚Äñh‚Äñ := by
        rw [add_comm, add_mul]
        apply add_le_add_left this"
Mathlib/ModelTheory/Skolem.lean,FirstOrder.Language.exists_elementarySubstructure_card_eq,exists_elementarySubstructure_card_eq,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  obtain ‚ü®s', hs'‚ü© := Cardinal.le_mk_iff_exists_set.1 h4
  rw [‚Üê aleph0_le_lift.{_, w}] at h1
  rw [‚Üê hs'] at h1 h2 ‚ä¢
  refine'
    ‚ü®elementarySkolem‚ÇÅReduct (closure (L.sum L.skolem‚ÇÅ) (s ‚à™ Equiv.ulift '' s')),
      (s.subset_union_left _).trans subset_closure, _‚ü©
  have h := mk_image_eq_lift _ s' Equiv.ulift.injective
  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h
  rw [coeSort_elementarySkolem‚ÇÅReduct, ‚Üê h, lift_inj]
  refine'
    le_antisymm (lift_le.1 (lift_card_closure_le.trans _))
      (mk_le_mk_of_subset ((Set.subset_union_right _ _).trans subset_closure))
  rw [max_le_iff, aleph0_le_lift, ‚Üê aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]
  ¬∑ refine' ‚ü®h1, (mk_union_le _ _).trans _, (lift_le.2 card_functions_sum_skolem‚ÇÅ_le).trans _‚ü©
    ¬∑ rw [‚Üê lift_le, lift_add, h, add_comm, add_eq_max h1]
      exact max_le le_rfl h2
    ¬∑ rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, ‚Üê lift_le.{w'},
        lift_lift, lift_lift, ‚Üê aleph0_le_lift, h]
      refine ‚ü®?_, h1‚ü©
      rw [‚Üê lift_lift.{w', w}]
      refine' _root_.trans (lift_le.{w}.2 h3) _
      rw [lift_lift, ‚Üê lift_lift.{w, max u v}, ‚Üê hs', ‚Üê h, lift_lift]
  ¬∑ refine' _root_.trans _ (lift_le.2 (mk_le_mk_of_subset (Set.subset_union_right _ _)))
    rw [aleph0_le_lift, ‚Üê aleph0_le_lift, h]
    exact h1","error:  invalid field 'trans', the environment does not contain 'Membership.mem.trans'
  Set.subset_union_left ?m.26890
has type
  ?m.26889 ‚àà s ‚à™ ?m.26888
error:  invalid field 'trans', the environment does not contain 'Set.Mem.trans'
  Set.subset_union_left ?m.26890
has type
  Set.Mem ?m.26889 (s ‚à™ ?m.26888)
error:  invalid field 'trans', the environment does not contain 'Union.union.trans'
  Set.subset_union_left ?m.26890
has type
  (s ‚à™ ?m.26888) ?m.26889
error:  invalid field 'trans', the environment does not contain 'Set.union.trans'
  Set.subset_union_left ?m.26890
has type
  s.union ?m.26888 ?m.26889
error:  invalid field 'trans', the environment does not contain 'setOf.trans'
  Set.subset_union_left ?m.26890
has type
  {a | a ‚àà s ‚à® a ‚àà ?m.26888} ?m.26889
error:  invalid field 'trans', the environment does not contain 'Or.trans'
  Set.subset_union_left ?m.26890
has type
  ?m.26889 ‚àà s ‚à® ?m.26889 ‚àà ?m.26888
error:  function expected at
  Set.subset_union_right ?m.27688
term has type
  ?m.27687 ‚àà ?m.27685 ‚à™ ?m.27686
error:  function expected at
  Set.subset_union_right ?m.29978
term has type
  ?m.29977 ‚àà ?m.29975 ‚à™ ?m.29976","theorem exists_elementarySubstructure_card_eq (s : Set M) (Œ∫ : Cardinal.{w'}) (h1 : ‚Ñµ‚ÇÄ ‚â§ Œ∫)
    (h2 : Cardinal.lift.{w'} #s ‚â§ Cardinal.lift.{w} Œ∫)
    (h3 : Cardinal.lift.{w'} L.card ‚â§ Cardinal.lift.{max u v} Œ∫)
    (h4 : Cardinal.lift.{w} Œ∫ ‚â§ Cardinal.lift.{w'} #M) :
    ‚àÉ S : L.ElementarySubstructure M, s ‚äÜ S ‚àß Cardinal.lift.{w'} #S = Cardinal.lift.{w} Œ∫ ",":= by
  obtain ‚ü®s', hs'‚ü© := Cardinal.le_mk_iff_exists_set.1 h4
  rw [‚Üê aleph0_le_lift.{_, w}] at h1
  rw [‚Üê hs'] at h1 h2 ‚ä¢
  refine
    ‚ü®elementarySkolem‚ÇÅReduct (closure (L.sum L.skolem‚ÇÅ) (s ‚à™ Equiv.ulift '' s')),
      (s.subset_union_left).trans subset_closure, ?_‚ü©
  have h := mk_image_eq_lift _ s' Equiv.ulift.injective
  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h
  rw [coeSort_elementarySkolem‚ÇÅReduct, ‚Üê h, lift_inj]
  refine
    le_antisymm (lift_le.1 (lift_card_closure_le.trans ?_))
      (mk_le_mk_of_subset ((s.subset_union_right).trans subset_closure))
  rw [max_le_iff, aleph0_le_lift, ‚Üê aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]
  ¬∑ refine ‚ü®h1, (mk_union_le _ _).trans ?_, (lift_le.2 card_functions_sum_skolem‚ÇÅ_le).trans ?_‚ü©
    ¬∑ rw [‚Üê lift_le, lift_add, h, add_comm, add_eq_max h1]
      exact max_le le_rfl h2
    ¬∑ rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, ‚Üê lift_le.{w'},
        lift_lift, lift_lift, ‚Üê aleph0_le_lift, h]
      refine ‚ü®?_, h1‚ü©
      rw [‚Üê lift_lift.{w', w}]
      refine _root_.trans (lift_le.{w}.2 h3) ?_
      rw [lift_lift, ‚Üê lift_lift.{w, max u v}, ‚Üê hs', ‚Üê h, lift_lift]
  ¬∑ refine _root_.trans ?_ (lift_le.2 (mk_le_mk_of_subset Set.subset_union_right))
    rw [aleph0_le_lift, ‚Üê aleph0_le_lift, h]
    exact h1"
Mathlib/Topology/AlexandrovDiscrete.lean,IsOpen.exterior_eq,IsOpen.exterior_eq,13444d800e71a22689e60023576255503756cd93,:=,error:  unexpected token 'lemma'; expected term,lemma IsOpen.exterior_eq (h : IsOpen s) : exterior s = s ,":=
  (exterior_minimal Subset.rfl h).antisymm subset_exterior"
Mathlib/NumberTheory/Rayleigh.lean,Irrational.beattySeq'_pos_eq,Irrational.beattySeq'_pos_eq,02b1069f08408dc7d641b5f65e89f819e399b96c,":= by
  dsimp only [beattySeq, beattySeq']
  congr! 4; rename_i k; rw [and_congr_right_iff]; intro hk; congr!
  rw [sub_eq_iff_eq_add, Int.ceil_eq_iff, Int.cast_add, Int.cast_one, add_sub_cancel]
  refine ‚ü®(Int.floor_le _).lt_of_ne fun h ‚Ü¶ ?_, (Int.lt_floor_add_one _).le‚ü©
  exact (hr.int_mul hk.ne').ne_int ‚åäk * r‚åã h.symm","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + (?b - ?a)
case h.e'_2.h.h.e'_2.h.a.a.h.e'_2
r : ‚Ñù
hr : Irrational r
x‚úù k : ‚Ñ§
hk : k > 0
‚ä¢ ‚Üë‚åä‚Üëk * r‚åã + 1 - 1 < ‚Üëk * r ‚àß ‚Üëk * r ‚â§ ‚Üë‚åä‚Üëk * r‚åã + 1","theorem Irrational.beattySeq'_pos_eq {r : ‚Ñù} (hr : Irrational r) :
    {beattySeq' r k | k > 0} = {beattySeq r k | k > 0} ",":= by
  dsimp only [beattySeq, beattySeq']
  congr! 4; rename_i k; rw [and_congr_right_iff]; intro hk; congr!
  rw [sub_eq_iff_eq_add, Int.ceil_eq_iff, Int.cast_add, Int.cast_one, add_sub_cancel_right]
  refine ‚ü®(Int.floor_le _).lt_of_ne fun h ‚Ü¶ ?_, (Int.lt_floor_add_one _).le‚ü©
  exact (hr.int_mul hk.ne').ne_int ‚åäk * r‚åã h.symm"
Mathlib/Topology/Algebra/Order/Field.lean,tendsto_pow_neg_atTop,tendsto_pow_neg_atTop,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  simpa only [zpow_neg, zpow_ofNat] using (@tendsto_pow_atTop ùïú _ _ hn).inv_tendsto_atTop","error:  type mismatch
  h‚úù
has type
  Tendsto (fun x ‚Ü¶ x ^ n)‚Åª¬π atTop (ùìù 0) : Prop
but is expected to have type
  Tendsto (fun x ‚Ü¶ (x ^ ‚Üën)‚Åª¬π) atTop (ùìù 0) : Prop","theorem tendsto_pow_neg_atTop {n : ‚Ñï} (hn : n ‚â† 0) :
    Tendsto (fun x : ùïú => x ^ (-(n : ‚Ñ§))) atTop (ùìù 0) ",":= by
  simpa only [zpow_neg, zpow_natCast] using (@tendsto_pow_atTop ùïú _ _ hn).inv_tendsto_atTop"
Mathlib/GroupTheory/SpecificGroups/Cyclic.lean,isCyclic_of_prime_card,isCyclic_of_prime_card,1b267f95e5bba4416505a1917839e7487ac60d07,"  exists_generator := by
    obtain ‚ü®g, hg‚ü© : ‚àÉ g : Œ±, g ‚â† 1 := Fintype.exists_ne_of_one_lt_card (h.symm ‚ñ∏ hp.1.one_lt) 1
    have := h ‚ñ∏ orderOf_dvd_card_univ (x := g)
    rw [Nat.dvd_prime hp.1] at this
    exact ‚ü®Group.Generator.of_orderOf_eq_card g <|
      h.symm ‚ñ∏ this.resolve_left (hg <| orderOf_eq_one_iff.mp ¬∑)‚ü©","error:  function expected at
  IsCyclic Œ±
term has type
  Prop
error:  tactic 'cases' failed, nested error:
tactic 'induction' failed, recursor 'Exists.casesOn' can only eliminate into Prop
Œ±‚úù : Type u
a : Œ±‚úù
inst‚úù¬≤ : Group Œ±‚úù
Œ± : Type u
inst‚úù¬π : Group Œ±
inst‚úù : Fintype Œ±
p : ‚Ñï
hp : Fact (Nat.Prime p)
h : Fintype.card Œ± = p
x‚úù : ‚àÉ g, g ‚â† 1
‚ä¢ sorryAx (Sort u_1) true
error:  unknown identifier 'isCyclic_of_prime_card'
error:  unsolved goals
Œ± : Type u
a : Œ±
G : Type u_1
H : Type u_2
p : ‚Ñï
inst‚úù‚Å¥ : Fintype G
inst‚úù¬≥ : Fintype H
inst‚úù¬≤ : Group G
inst‚úù¬π : Group H
inst‚úù : Fact (Nat.Prime p)
hG : Fintype.card G = p
hH : Fintype.card H = p
‚ä¢ G ‚âÉ* H","theorem isCyclic_of_prime_card {Œ± : Type u} [Group Œ±] [Fintype Œ±] {p : ‚Ñï} [hp : Fact p.Prime]
    (h : Fintype.card Œ± = p) : IsCyclic Œ± ",":= by
  obtain ‚ü®g, hg‚ü© : ‚àÉ g, g ‚â† 1 := Fintype.exists_ne_of_one_lt_card (h.symm ‚ñ∏ hp.1.one_lt) 1
  exact ‚ü®g, fun g' ‚Ü¶ mem_zpowers_of_prime_card h hg‚ü©"
Mathlib/Analysis/NormedSpace/Dual.lean,NormedSpace.norm_le_dual_bound,norm_le_dual_bound,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  classical
    by_cases h : x = 0
    ¬∑ simp only [h, hMp, norm_zero]
    ¬∑ obtain ‚ü®f, hf‚ÇÅ, hfx‚ü© : ‚àÉ f : E ‚ÜíL[ùïú] ùïú, ‚Äñf‚Äñ = 1 ‚àß f x = ‚Äñx‚Äñ := exists_dual_vector ùïú x h
      calc
        ‚Äñx‚Äñ = ‚Äñ(‚Äñx‚Äñ : ùïú)‚Äñ := IsROrC.norm_coe_norm.symm
        _ = ‚Äñf x‚Äñ := by rw [hfx]
        _ ‚â§ M * ‚Äñf‚Äñ := (hM f)
        _ = M := by rw [hf‚ÇÅ, mul_one]",error:  unknown identifier 'IsROrC.norm_coe_norm.symm',"theorem norm_le_dual_bound (x : E) {M : ‚Ñù} (hMp : 0 ‚â§ M) (hM : ‚àÄ f : Dual ùïú E, ‚Äñf x‚Äñ ‚â§ M * ‚Äñf‚Äñ) :
    ‚Äñx‚Äñ ‚â§ M ",":= by
  classical
    by_cases h : x = 0
    ¬∑ simp only [h, hMp, norm_zero]
    ¬∑ obtain ‚ü®f, hf‚ÇÅ, hfx‚ü© : ‚àÉ f : E ‚ÜíL[ùïú] ùïú, ‚Äñf‚Äñ = 1 ‚àß f x = ‚Äñx‚Äñ := exists_dual_vector ùïú x h
      calc
        ‚Äñx‚Äñ = ‚Äñ(‚Äñx‚Äñ : ùïú)‚Äñ := RCLike.norm_coe_norm.symm
        _ = ‚Äñf x‚Äñ := by rw [hfx]
        _ ‚â§ M * ‚Äñf‚Äñ := hM f
        _ = M := by rw [hf‚ÇÅ, mul_one]"
Mathlib/Data/QPF/Multivariate/Constructions/Cofix.lean,MvQPF.Cofix.bisim_rel,Cofix.bisim_rel,5fb9beab28702fb284701d494bc9b7c5f52fef53,":= by
  let r' (x y) := x = y ‚à® r x y
  intro x y rxy
  apply Cofix.bisim_aux r'
  ¬∑ intro x
    left
    rfl
  ¬∑ intro x y r'xy
    cases r'xy
    case inl h =>
      rw [h]
    case inr r'xy =>
      have : ‚àÄ x y, r x y ‚Üí r' x y := fun x y h => Or.inr h
      rw [‚Üê Quot.factor_mk_eq _ _ this]
      dsimp
      rw [appendFun_comp_id]
      rw [@comp_map _ _ _ q _ _ _ (appendFun id (Quot.mk r)),
        @comp_map _ _ _ q _ _ _ (appendFun id (Quot.mk r))]
      rw [h _ _ r'xy]
  right; exact rxy",error:  dsimp made no progress,"theorem Cofix.bisim_rel {Œ± : TypeVec n} (r : Cofix F Œ± ‚Üí Cofix F Œ± ‚Üí Prop)
    (h : ‚àÄ x y, r x y ‚Üí
      appendFun id (Quot.mk r) <$$> Cofix.dest x = appendFun id (Quot.mk r) <$$> Cofix.dest y) :
    ‚àÄ x y, r x y ‚Üí x = y ",":= by
  let r' (x y) := x = y ‚à® r x y
  intro x y rxy
  apply Cofix.bisim_aux r'
  ¬∑ intro x
    left
    rfl
  ¬∑ intro x y r'xy
    cases r'xy with
    | inl h =>
      rw [h]
    | inr r'xy =>
      have : ‚àÄ x y, r x y ‚Üí r' x y := fun x y h => Or.inr h
      rw [‚Üê Quot.factor_mk_eq _ _ this]
      dsimp [r']
      rw [appendFun_comp_id]
      rw [@comp_map _ _ q _ _ _ (appendFun id (Quot.mk r)),
        @comp_map _ _ q _ _ _ (appendFun id (Quot.mk r))]
      rw [h _ _ r'xy]
  right; exact rxy"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,ea54eb89c8a123dcfceeb11bd200d459f2f95413,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a
  exact ‚ü®_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b
  exact ‚ü®_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine' ‚ü®g + dg, fun y => _, funext hgf‚ü©
    ¬∑ have hay : a < (g + dg) y := by
        rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
        ¬∑ refine' (lt_add_iff_pos_right _).2 _
          calc
            0 < c - g y := sub_pos.2 hac
            _ = dg y := (dga rfl).symm
        ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      refine' ‚ü®x, hxy.le, _‚ü©
      rcases le_total c (g y) with hc | hc
      ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
      ¬∑ calc
          g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
          _ = b := by rw [hsub, add_sub_cancel'_right]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine' ‚ü®g - dg, fun y => _, funext hgf‚ü©
  ¬∑ have hyb : (g - dg) y < b := by
      rcases (hgb y).eq_or_lt with (rfl | hlt)
      ¬∑ refine' (sub_lt_self_iff _).2 _
        calc
          0 < g y - c := sub_pos.2 hcb
          _ = dg y := (dgb rfl).symm
      ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
    rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
    cases' lt_or_le c (g y) with hc hc
    ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
      ¬∑ refine' ‚ü®x, xu, _, hyxu.le‚ü©
        calc
          f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
      ¬∑ have hay : a < (g - dg) y := by
          calc
            a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
            _ < g y - (b - c) := (sub_lt_sub_right hc _)
            _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
        rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
        exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
    ¬∑ refine' ‚ü®xl y, xu, _, hyxu.le‚ü©
      simp [dg0 (Or.inr hc), hxl]","error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/RingTheory/IntegralRestrict.lean,algebraMap_galRestrictHom_apply,algebraMap_galRestrictHom_apply,fc0107e21675a8298fc7ac3cc6e26f680430b1b5,":= by
  simp [galRestrictHom, Subalgebra.algebraMap_eq]; sorry",error:  no goals to be solved,"lemma algebraMap_galRestrictHom_apply (œÉ : L ‚Üí‚Çê[K] L) (x : B) :
    algebraMap B L (galRestrictHom A K L B œÉ x) = œÉ (algebraMap B L x) ",":= by
  simp [galRestrictHom, Subalgebra.algebraMap_eq]"
Mathlib/Topology/PartialHomeomorph.lean,PartialHomeomorph.isOpen_image_source_inter,isOpen_image_source_inter,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  e.isOpen_image_of_subset_source (e.open_source.inter hs) (inter_subset_left _ _)","error:  function expected at
  inter_subset_left ?m.25435
term has type
  ?m.25434 ‚àà ?m.25432","theorem isOpen_image_source_inter {s : Set X} (hs : IsOpen s) :
    IsOpen (e '' (e.source ‚à© s)) ",":=
  e.isOpen_image_of_subset_source (e.open_source.inter hs) inter_subset_left"
Mathlib/MeasureTheory/Function/Jacobian.lean,ApproximatesLinearOn.norm_fderiv_sub_le,_root_.ApproximatesLinearOn.norm_fderiv_sub_le,4968eba95a704a4a58e8b3735dc3733ee6d46c0d,":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ by
    have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by continuity) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.definition Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := (norm_add_le _ _)
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel_left, sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := (norm_sub_le _ _)
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel_left, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
        mul_le_mul_of_nonneg_left norm_a (mul_nonneg rpos.le (add_nonneg Œ¥.2 Œµpos.le))
  calc
    ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
      congr 1
      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
      abel
    _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := (norm_add_le _ _)
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
      apply add_le_add
      ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
      ¬∑ apply ContinuousLinearMap.le_opNorm
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ :=
      add_le_add le_rfl
        (mul_le_mul_of_nonneg_left (mem_closedBall_iff_norm'.1 az) (norm_nonneg _))","error:  invalid field 'definition', the environment does not contain 'Asymptotics.IsLittleO.definition'
  (hf' x xs).isLittleO
has type
  (fun x' ‚Ü¶ f x' - f x - (f' x) (x' - x)) =o[ùìù[s] x] fun x' ‚Ü¶ x' - x","theorem _root_.ApproximatesLinearOn.norm_fderiv_sub_le {A : E ‚ÜíL[‚Ñù] E} {Œ¥ : ‚Ñù‚â•0}
    (hf : ApproximatesLinearOn f A s Œ¥) (hs : MeasurableSet s) (f' : E ‚Üí E ‚ÜíL[‚Ñù] E)
    (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) : ‚àÄ·µê x ‚àÇŒº.restrict s, ‚Äñf' x - A‚Äñ‚Çä ‚â§ Œ¥ ",":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ by
    have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by fun_prop) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel_left, sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := norm_sub_le _ _
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel_left, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) := by gcongr
  calc
    ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
      congr 1
      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
      abel
    _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
      apply add_le_add
      ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
      ¬∑ apply ContinuousLinearMap.le_opNorm
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ := by
      rw [mem_closedBall_iff_norm'] at az
      gcongr"
Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean,ENNReal.prod_coe_rpow,prod_coe_rpow,25e538f3a737a71314ac143929711e67d0b14d73,":= by
  induction s with
  | empty => simp
  | insert hi ih => simp_rw [prod_insert hi, ih, ‚Üê coe_mul_rpow, coe_mul]",error:  invalid alternative name 'empty',"theorem prod_coe_rpow {Œπ} (s : Finset Œπ) (f : Œπ ‚Üí ‚Ñù‚â•0) (r : ‚Ñù) :
    ‚àè i ‚àà s, (f i : ‚Ñù‚â•0‚àû) ^ r = ((‚àè i ‚àà s, f i : ‚Ñù‚â•0) : ‚Ñù‚â•0‚àû) ^ r ",":= by
  induction s using Finset.induction with
  | empty => simp
  | insert hi ih => simp_rw [prod_insert hi, ih, ‚Üê coe_mul_rpow, coe_mul]"
Mathlib/SetTheory/Cardinal/Divisibility.lean,Cardinal.nat_is_prime_iff,nat_is_prime_iff,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  simp only [Prime, Nat.prime_iff]
  refine and_congr (by simp) (and_congr ?_ ‚ü®fun h b c hbc =>? _, fun h b c hbc =?> _‚ü©)
  ¬∑ simp only [isUnit_iff, Nat.isUnit_iff]
    exact mod_cast Iff.rfl
  ¬∑ exact mod_cast h b c (mod_cast hbc)
  cases' lt_or_le (b * c) ‚Ñµ‚ÇÄ with h' h'
  ¬∑ rcases mul_lt_aleph0_iff.mp h' with (rfl | rfl | ‚ü®hb, hc‚ü©)
    ¬∑ simp
    ¬∑ simp
    lift b to ‚Ñï using hb
    lift c to ‚Ñï using hc
    exact mod_cast h b c (mod_cast hbc)
  rcases aleph0_le_mul_iff.mp h' with ‚ü®hb, hc, h‚Ñµ‚ÇÄ‚ü©
  have hn : (n : Cardinal) ‚â† 0 := by
    intro h
    rw [h, zero_dvd_iff, mul_eq_zero] at hbc
    cases hbc <;> contradiction
  wlog h‚Ñµ‚ÇÄb : ‚Ñµ‚ÇÄ ‚â§ b
  refine (this h c b ?_ ?_ hc hb h‚Ñµ‚ÇÄ.symm hn (h‚Ñµ‚ÇÄ.resolve_left h‚Ñµ‚ÇÄb)).symm <;> try assumption
  ¬∑ rwa [mul_comm] at hbc
  ¬∑ rwa [mul_comm] at h'
  ¬∑ exact Or.inl (dvd_of_le_of_aleph0_le hn ((nat_lt_aleph0 n).le.trans h‚Ñµ‚ÇÄb) h‚Ñµ‚ÇÄb)","error:  unexpected token '='; expected '‚Ü¶', '=>'
error:  unsolved goals
case refine_1
a b : Cardinal.{u}
n m : ‚Ñï
‚ä¢ ¬¨IsUnit ‚Üën ‚Üî ¬¨IsUnit n

case refine_2
a b‚úù : Cardinal.{u}
n m : ‚Ñï
h : ‚àÄ (a b : Cardinal.{u_1}), ‚Üën ‚à£ a * b ‚Üí ‚Üën ‚à£ a ‚à® ‚Üën ‚à£ b
b c : ‚Ñï
hbc : n ‚à£ b * c
‚ä¢ n ‚à£ b ‚à® n ‚à£ c",theorem nat_is_prime_iff : Prime (n : Cardinal) ‚Üî n.Prime ,":= by
  simp only [Prime, Nat.prime_iff]
  refine and_congr (by simp) (and_congr ?_ ‚ü®fun h b c hbc => ?_, fun h b c hbc => ?_‚ü©)
  ¬∑ simp only [isUnit_iff, Nat.isUnit_iff]
    exact mod_cast Iff.rfl
  ¬∑ exact mod_cast h b c (mod_cast hbc)
  cases' lt_or_le (b * c) ‚Ñµ‚ÇÄ with h' h'
  ¬∑ rcases mul_lt_aleph0_iff.mp h' with (rfl | rfl | ‚ü®hb, hc‚ü©)
    ¬∑ simp
    ¬∑ simp
    lift b to ‚Ñï using hb
    lift c to ‚Ñï using hc
    exact mod_cast h b c (mod_cast hbc)
  rcases aleph0_le_mul_iff.mp h' with ‚ü®hb, hc, h‚Ñµ‚ÇÄ‚ü©
  have hn : (n : Cardinal) ‚â† 0 := by
    intro h
    rw [h, zero_dvd_iff, mul_eq_zero] at hbc
    cases hbc <;> contradiction
  wlog h‚Ñµ‚ÇÄb : ‚Ñµ‚ÇÄ ‚â§ b
  apply (this h c b _ _ hc hb h‚Ñµ‚ÇÄ.symm hn (h‚Ñµ‚ÇÄ.resolve_left h‚Ñµ‚ÇÄb)).symm <;> try assumption
  ¬∑ rwa [mul_comm] at hbc
  ¬∑ rwa [mul_comm] at h'
  ¬∑ exact Or.inl (dvd_of_le_of_aleph0_le hn ((nat_lt_aleph0 n).le.trans h‚Ñµ‚ÇÄb) h‚Ñµ‚ÇÄb)"
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.getD_leftInvSeq_mul_wordProd,getD_leftInvSeq_mul_wordProd,c9d416f0791ec06898de80866c80323f32652367,":= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [‚Üê take_append_drop (j + 1) œâ]
  rw [take_succ]
  obtain lt | le := lt_or_le j œâ.length
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_getElem lt]
    simp [wordProd_append, wordProd_cons, mul_assoc]
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_none.mpr le]
    simp","error:  unsolved goals
case inl
B : Type u_1
W : Type u_2
inst‚úù : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
œâ : List B
j : ‚Ñï
lt : j < œâ.length
‚ä¢ cs.simple œâ[j] * ((cs.wordProd (take j œâ))‚Åª¬π * cs.wordProd œâ) = cs.wordProd (drop (j + 1) œâ)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  getElem?_eq_none
has type
  ?m.116290.length ‚â§ ?m.116291 ‚Üí ?m.116290[?m.116291]? = none
error:  unsolved goals
case inr
B : Type u_1
W : Type u_2
inst‚úù : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
œâ : List B
j : ‚Ñï
le : œâ.length ‚â§ j
‚ä¢ cs.wordProd (take j œâ) * (Option.map cs.simple œâ[j]?).getD 1 * (cs.wordProd (take j œâ))‚Åª¬π *
      cs.wordProd (take j œâ ++ (œâ[j]?.toList ++ drop (j + 1) œâ)) =
    cs.wordProd (take j œâ ++ drop (j + 1) œâ)","theorem getD_leftInvSeq_mul_wordProd (œâ : List B) (j : ‚Ñï) :
    ((lis œâ).getD j 1) * œÄ œâ = œÄ (œâ.eraseIdx j) ",":= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [‚Üê take_append_drop (j + 1) œâ]
  rw [take_succ]
  obtain lt | le := lt_or_le j œâ.length
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]
    simp
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_none le]
    simp"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.hasIntegral_GP_pderiv,hasIntegral_GP_pderiv,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine' HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le _ _ _ s hs _ _
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine' .and _ (.and _ _)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) :=
          inter_subset_inter_left _ (closedBall_subset_closedBall hŒ¥.2)
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := (add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ))
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine' this.eventually (ge_mem_nhds _)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine' ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ _‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine' (norm_sub_le _ _).trans (add_le_add _ _)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine' (mul_le_mul_of_nonneg_right _ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
          _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine' (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans _
      refine' (mul_le_mul_of_nonneg_right _ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine' prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => _
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := (dist_le_pi_dist J.upper J.lower (i.succAbove j))
        _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
        _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1 ((Hd x hx).isLittleO.def Œµ'0)
      with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine' ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => _‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine' (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ _) (hJc rfl)).trans _
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg",error:  dsimp made no progress,"theorem hasIntegral_GP_pderiv (f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E)
    (f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E) (s : Set (Fin (n + 1) ‚Üí ‚Ñù))
    (hs : s.Countable) (Hs : ‚àÄ x ‚àà s, ContinuousWithinAt f (Box.Icc I) x)
    (Hd : ‚àÄ x ‚àà (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :
    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume
      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))
          BoxAdditiveMap.volume -
        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))
          BoxAdditiveMap.volume) ",":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le ?_ ?_ _ s hs ?_ ?_
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine .and ?_ (.and ?_ ?_)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) := by gcongr; exact hŒ¥.2
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ)
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine this.eventually (ge_mem_nhds ?_)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ ?_‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp [F]
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine (norm_sub_le _ _).trans (add_le_add ?_ ?_)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine (mul_le_mul_of_nonneg_right ?_ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
          _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans ?_
      refine (mul_le_mul_of_nonneg_right ?_ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => ?_
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := dist_le_pi_dist J.upper J.lower (i.succAbove j)
        _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
        _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1
      ((Hd x hx).isLittleO.def Œµ'0) with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => ?_‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ ?_) (hJc rfl)).trans ?_
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg"
Mathlib/Topology/Separation.lean,IsCompact.finite_compact_cover,IsCompact.finite_compact_cover,ddffab96a653674eaf6ec54e6415f6fa7c2a49f7,":= by
  induction' t with x t hx ih generalizing U s
  ¬∑ refine' ‚ü®fun _ => ‚àÖ, fun _ => isCompact_empty, fun i => empty_subset _, _‚ü©
    simpa only [subset_empty_iff, Finset.not_mem_empty, iUnion_false, iUnion_empty] using hsC
  simp only [Finset.set_biUnion_insert] at hsC
  simp only [Finset.forall_mem_insert] at hU
  have hU' : ‚àÄ i ‚àà t, IsOpen (U i) := fun i hi => hU.2 i hi
  rcases hs.binary_compact_cover hU.1 (isOpen_biUnion hU') hsC with
    ‚ü®K‚ÇÅ, K‚ÇÇ, h1K‚ÇÅ, h1K‚ÇÇ, h2K‚ÇÅ, h2K‚ÇÇ, hK‚ü©
  rcases ih h1K‚ÇÇ U hU' h2K‚ÇÇ with ‚ü®K, h1K, h2K, h3K‚ü©
  refine' ‚ü®update K x K‚ÇÅ, _, _, _‚ü©
  ¬∑ intro i
    rcases eq_or_ne i x with rfl | hi
    ¬∑ simp only [update_same, h1K‚ÇÅ]
    ¬∑ simp only [update_noteq hi, h1K]
  ¬∑ intro i
    rcases eq_or_ne i x with rfl | hi
    ¬∑ simp only [update_same, h2K‚ÇÅ]
    ¬∑ simp only [update_noteq hi, h2K]
  ¬∑ simp only [Finset.set_biUnion_insert_update _ hx, hK, h3K]","error:  type mismatch
  h‚úù
has type
  s ‚äÜ ‚ãÉ i ‚àà { val := x, nodup := t }, U i : Prop
but is expected to have type
  s = ‚àÖ : Prop
error:  no goals to be solved","theorem IsCompact.finite_compact_cover {s : Set X} (hs : IsCompact s) {Œπ : Type*}
    (t : Finset Œπ) (U : Œπ ‚Üí Set X) (hU : ‚àÄ i ‚àà t, IsOpen (U i)) (hsC : s ‚äÜ ‚ãÉ i ‚àà t, U i) :
    ‚àÉ K : Œπ ‚Üí Set X, (‚àÄ i, IsCompact (K i)) ‚àß (‚àÄ i, K i ‚äÜ U i) ‚àß s = ‚ãÉ i ‚àà t, K i ",":= by
  induction' t using Finset.induction with x t hx ih generalizing U s
  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => isCompact_empty, fun i => empty_subset _, ?_‚ü©
    simpa only [subset_empty_iff, Finset.not_mem_empty, iUnion_false, iUnion_empty] using hsC
  simp only [Finset.set_biUnion_insert] at hsC
  simp only [Finset.forall_mem_insert] at hU
  have hU' : ‚àÄ i ‚àà t, IsOpen (U i) := fun i hi => hU.2 i hi
  rcases hs.binary_compact_cover hU.1 (isOpen_biUnion hU') hsC with
    ‚ü®K‚ÇÅ, K‚ÇÇ, h1K‚ÇÅ, h1K‚ÇÇ, h2K‚ÇÅ, h2K‚ÇÇ, hK‚ü©
  rcases ih h1K‚ÇÇ U hU' h2K‚ÇÇ with ‚ü®K, h1K, h2K, h3K‚ü©
  refine ‚ü®update K x K‚ÇÅ, ?_, ?_, ?_‚ü©
  ¬∑ intro i
    rcases eq_or_ne i x with rfl | hi
    ¬∑ simp only [update_same, h1K‚ÇÅ]
    ¬∑ simp only [update_noteq hi, h1K]
  ¬∑ intro i
    rcases eq_or_ne i x with rfl | hi
    ¬∑ simp only [update_same, h2K‚ÇÅ]
    ¬∑ simp only [update_noteq hi, h2K]
  ¬∑ simp only [Finset.set_biUnion_insert_update _ hx, hK, h3K]"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.single_left_inj,single_left_inj,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.single_left_injective (fun _ => h)","warning:  Finsupp does not have a doc string
error:  unknown identifier 'DFinsupp.single_left_injective'",theorem single_left_injective (h : b ‚â† 0) : Function.Injective fun a : Œ± => single a b ,":=
  fun _a _a' H => (((single_eq_single_iff _ _ _ _).mp H).resolve_right fun hb => h hb.1).left"
Mathlib/Combinatorics/Hall/Finite.lean,HallMarriageTheorem.hall_hard_inductive_step_B,hall_hard_inductive_step_B,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  haveI := Classical.decEq Œπ
  rw [Nat.add_one] at hn
  have card_Œπ'_le : Fintype.card s ‚â§ n := by
    apply Nat.le_of_lt_succ
    calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card Œπ := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
  let t' : s ‚Üí Finset Œ± := fun x' => t x'
  rcases ih t' card_Œπ'_le (hall_cond_of_restrict ht) with ‚ü®f', hf', hsf'‚ü©
  set Œπ'' := (s : Set Œπ)·∂ú
  let t'' : Œπ'' ‚Üí Finset Œ± := fun a'' => t a'' \ s.biUnion t
  have card_Œπ''_le : Fintype.card Œπ'' ‚â§ n := by
    simp_rw [‚Üê Nat.lt_succ_iff, ‚Üê hn, ‚Üê Finset.coe_compl, coe_sort_coe]
    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]
  rcases ih t'' card_Œπ''_le (hall_cond_of_compl hus ht) with ‚ü®f'', hf'', hsf''‚ü©
  have f'_mem_biUnion : ‚àÄ (x') (hx' : x' ‚àà s), f' ‚ü®x', hx'‚ü© ‚àà s.biUnion t := by
    intro x' hx'
    rw [mem_biUnion]
    exact ‚ü®x', hx', hsf' _‚ü©
  have f''_not_mem_biUnion : ‚àÄ (x'') (hx'' : ¬¨x'' ‚àà s), ¬¨f'' ‚ü®x'', hx''‚ü© ‚àà s.biUnion t := by
    intro x'' hx''
    have h := hsf'' ‚ü®x'', hx''‚ü©
    rw [mem_sdiff] at h
    exact h.2
  have im_disj :
      ‚àÄ (x' x'' : Œπ) (hx' : x' ‚àà s) (hx'' : ¬¨x'' ‚àà s), f' ‚ü®x', hx'‚ü© ‚â† f'' ‚ü®x'', hx''‚ü© := by
    intro x x' hx' hx'' h
    apply f''_not_mem_biUnion x' hx''
    rw [‚Üê h]
    apply f'_mem_biUnion x
  refine' ‚ü®fun x => if h : x ‚àà s then f' ‚ü®x, h‚ü© else f'' ‚ü®x, h‚ü©, _, _‚ü©
  ¬∑ refine' hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)
  ¬∑ intro x
    simp only [of_eq_true]
    split_ifs with h
    ¬∑ exact hsf' ‚ü®x, h‚ü©
    ¬∑ exact sdiff_subset _ _ (hsf'' ‚ü®x, h‚ü©)","error:  simp made no progress
error:  function expected at
  sdiff_subset ?m.40360
term has type
  ?m.40359 ‚àà ?m.40357","theorem hall_hard_inductive_step_B {n : ‚Ñï} (hn : Fintype.card Œπ = n + 1)
    (ht : ‚àÄ s : Finset Œπ, s.card ‚â§ (s.biUnion t).card)
    (ih :
      ‚àÄ {Œπ' : Type u} [Fintype Œπ'] (t' : Œπ' ‚Üí Finset Œ±),
        Fintype.card Œπ' ‚â§ n ‚Üí
          (‚àÄ s' : Finset Œπ', s'.card ‚â§ (s'.biUnion t').card) ‚Üí
            ‚àÉ f : Œπ' ‚Üí Œ±, Function.Injective f ‚àß ‚àÄ x, f x ‚àà t' x)
    (s : Finset Œπ) (hs : s.Nonempty) (hns : s ‚â† univ) (hus : s.card = (s.biUnion t).card) :
    ‚àÉ f : Œπ ‚Üí Œ±, Function.Injective f ‚àß ‚àÄ x, f x ‚àà t x ",":= by
  haveI := Classical.decEq Œπ
  rw [Nat.add_one] at hn
  have card_Œπ'_le : Fintype.card s ‚â§ n := by
    apply Nat.le_of_lt_succ
    calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card Œπ := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
  let t' : s ‚Üí Finset Œ± := fun x' => t x'
  rcases ih t' card_Œπ'_le (hall_cond_of_restrict ht) with ‚ü®f', hf', hsf'‚ü©
  set Œπ'' := (s : Set Œπ)·∂ú
  let t'' : Œπ'' ‚Üí Finset Œ± := fun a'' => t a'' \ s.biUnion t
  have card_Œπ''_le : Fintype.card Œπ'' ‚â§ n := by
    simp_rw [Œπ'', ‚Üê Nat.lt_succ_iff, ‚Üê hn, ‚Üê Finset.coe_compl, coe_sort_coe]
    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]
  rcases ih t'' card_Œπ''_le (hall_cond_of_compl hus ht) with ‚ü®f'', hf'', hsf''‚ü©
  have f'_mem_biUnion : ‚àÄ (x') (hx' : x' ‚àà s), f' ‚ü®x', hx'‚ü© ‚àà s.biUnion t := by
    intro x' hx'
    rw [mem_biUnion]
    exact ‚ü®x', hx', hsf' _‚ü©
  have f''_not_mem_biUnion : ‚àÄ (x'') (hx'' : ¬¨x'' ‚àà s), ¬¨f'' ‚ü®x'', hx''‚ü© ‚àà s.biUnion t := by
    intro x'' hx''
    have h := hsf'' ‚ü®x'', hx''‚ü©
    rw [mem_sdiff] at h
    exact h.2
  have im_disj :
      ‚àÄ (x' x'' : Œπ) (hx' : x' ‚àà s) (hx'' : ¬¨x'' ‚àà s), f' ‚ü®x', hx'‚ü© ‚â† f'' ‚ü®x'', hx''‚ü© := by
    intro x x' hx' hx'' h
    apply f''_not_mem_biUnion x' hx''
    rw [‚Üê h]
    apply f'_mem_biUnion x
  refine ‚ü®fun x => if h : x ‚àà s then f' ‚ü®x, h‚ü© else f'' ‚ü®x, h‚ü©, ?_, ?_‚ü©
  ¬∑ refine hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)
  ¬∑ intro x
    simp only [of_eq_true]
    split_ifs with h
    ¬∑ exact hsf' ‚ü®x, h‚ü©
    ¬∑ exact sdiff_subset (hsf'' ‚ü®x, h‚ü©)"
Mathlib/NumberTheory/EulerProduct/Basic.lean,EulerProduct.eulerProduct_hasProd,eulerProduct_hasProd,19cfe36a7ab0262701db2043cd019a1861daadc8,":= by
  let F : ‚Ñï ‚Üí R := fun n ‚Ü¶ ‚àë' e, f (n ^ e)
  change HasProd (F ‚àò Subtype.val) _
  sorry","warning:  declaration uses 'sorry'
error:  application type mismatch
  eulerProduct_hasProd hf‚ÇÅ
argument
  hf‚ÇÅ
has type
  f 1 = 1 : Prop
but is expected to have type
  Summable fun x ‚Ü¶ ‚Äñ?m.22815 x‚Äñ : Prop
error:  application type mismatch
  eulerProduct_hasProd_mulIndicator hf‚ÇÅ
argument
  hf‚ÇÅ
has type
  f 1 = 1 : Prop
but is expected to have type
  Summable fun x ‚Ü¶ ‚Äñ?m.26927 x‚Äñ : Prop
error:  unsolved goals
R : Type u_1
inst‚úù¬π : NormedCommRing R
inst‚úù : CompleteSpace R
f : ‚Ñï ‚Üí R
hf‚ÇÅ : f 1 = 1
hmul : ‚àÄ {m n : ‚Ñï}, m.Coprime n ‚Üí f (m * n) = f m * f n
hsum : Summable fun x ‚Ü¶ ‚Äñf x‚Äñ
hf‚ÇÄ : f 0 = 0
‚ä¢ Tendsto (fun n ‚Ü¶ ‚àè p ‚àà n.primesBelow, ‚àë' (e : ‚Ñï), f (p ^ e)) atTop (ùìù (‚àë' (n : ‚Ñï), f n))
error:  application type mismatch
  eulerProduct_hasProd hf‚ÇÅ
argument
  hf‚ÇÅ
has type
  f 1 = 1 : Prop
but is expected to have type
  Summable fun x ‚Ü¶ ‚Äñ?m.30834 x‚Äñ : Prop
error:  application type mismatch
  eulerProduct_hasProd hf.left
argument
  hf.left
has type
  f 1 = 1 : Prop
but is expected to have type
  Summable fun x ‚Ü¶ ‚Äñ?m.33732 x‚Äñ : Prop
error:  application type mismatch
  eulerProduct hf.left
argument
  hf.left
has type
  f 1 = 1 : Prop
but is expected to have type
  Summable fun x ‚Ü¶ ‚Äñ?m.36720 x‚Äñ : Prop
error:  application type mismatch
  eulerProduct_tprod hf.left
argument
  hf.left
has type
  f 1 = 1 : Prop
but is expected to have type
  Summable fun x ‚Ü¶ ‚Äñ?m.39520 x‚Äñ : Prop
error:  application type mismatch
  eulerProduct_hasProd (MonoidWithZeroHom.map_one f)
argument
  MonoidWithZeroHom.map_one f
has type
  f 1 = 1 : Prop
but is expected to have type
  Summable fun x ‚Ü¶ ‚Äñ?m.54131 x‚Äñ : Prop
error:  application type mismatch
  eulerProduct_hasProd_mulIndicator (MonoidWithZeroHom.map_one f)
argument
  MonoidWithZeroHom.map_one f
has type
  f 1 = 1 : Prop
but is expected to have type
  Summable fun x ‚Ü¶ ‚Äñ?m.59495 x‚Äñ : Prop
error:  unsolved goals
F : Type u_1
inst‚úù¬π : NormedField F
inst‚úù : CompleteSpace F
f : ‚Ñï ‚Üí*‚ÇÄ F
hsum : Summable fun x ‚Ü¶ ‚Äñf x‚Äñ
hmul : ‚àÄ {m n : ‚Ñï}, m.Coprime n ‚Üí f (m * n) = f m * f n
‚ä¢ Tendsto (fun n ‚Ü¶ ‚àè p ‚àà n.primesBelow, (1 - f p)‚Åª¬π) atTop (ùìù (‚àë' (n : ‚Ñï), f n))","theorem eulerProduct_hasProd (hsum : Summable (‚Äñf ¬∑‚Äñ)) (hf‚ÇÄ : f 0 = 0) :
    HasProd (fun p : Primes ‚Ü¶ ‚àë' e, f (p ^ e)) (‚àë' n, f n) ",":= by
  let F : ‚Ñï ‚Üí R := fun n ‚Ü¶ ‚àë' e, f (n ^ e)
  change HasProd (F ‚àò Subtype.val) _
  rw [hasProd_subtype_iff_mulIndicator,
    show Set.mulIndicator (fun p : ‚Ñï ‚Ü¶ Irreducible p) =  {p | Nat.Prime p}.mulIndicator from rfl,
    HasProd, Metric.tendsto_atTop]
  intro Œµ hŒµ
  obtain ‚ü®N‚ÇÄ, hN‚ÇÄ‚ü© := norm_tsum_factoredNumbers_sub_tsum_lt hsum.of_norm hf‚ÇÄ hŒµ
  refine ‚ü®range N‚ÇÄ, fun s hs ‚Ü¶ ?_‚ü©
  have : ‚àè p ‚àà s, {p | Nat.Prime p}.mulIndicator F p = ‚àè p ‚àà s.filter Nat.Prime, F p :=
    prod_mulIndicator_eq_prod_filter s (fun _ ‚Ü¶ F) _ id
  rw [this, dist_eq_norm, prod_filter_prime_tsum_eq_tsum_factoredNumbers hf‚ÇÅ hmul hsum,
    norm_sub_rev]
  exact hN‚ÇÄ s fun p hp ‚Ü¶ hs <| mem_range.mpr <| lt_of_mem_primesBelow hp"
Mathlib/Algebra/MonoidAlgebra/Basic.lean,AddMonoidAlgebra.algHom_ext',algHom_ext',848a6055965ceeab03ba2c4d2d0e4e0e9b07c6e6,":=
  algHom_ext <| FunLike.congr_fun h","error:  unknown constant 'FunLike.congr_fun'
warning:  AddMonoidAlgebra does not have a doc string","theorem algHom_ext' ‚¶ÉœÜ‚ÇÅ œÜ‚ÇÇ : MonoidAlgebra k G ‚Üí‚Çê[k] A‚¶Ñ
    (h :
      (œÜ‚ÇÅ : MonoidAlgebra k G ‚Üí* A).comp (of k G) = (œÜ‚ÇÇ : MonoidAlgebra k G ‚Üí* A).comp (of k G)) :
    œÜ‚ÇÅ = œÜ‚ÇÇ ",":=
  algHom_ext <| DFunLike.congr_fun h"
Mathlib/Order/UpperLower/Basic.lean,LowerSet.sdiff_sup_lowerClosure,sdiff_sup_lowerClosure,049f6f9c146026f6debfbf18ad947c4aa57150cb,":= by
  refine' le_antisymm (sup_le sdiff_le_left $ lowerClosure_le.2 hts) fun a ha ‚Ü¶ _
  obtain hat | hat := em (a ‚àà t)
  ¬∑ exact subset_union_right _ _ (subset_lowerClosure hat)
  ¬∑ refine subset_union_left _ _ ‚ü®ha, ?_‚ü©
    rintro ‚ü®b, hb, hba‚ü©
    exact hat $ hst _ ha _ hb hba","error:  function expected at
  subset_union_right ?m.704076
term has type
  ?m.704075 ‚àà ?m.704073 ‚à™ ?m.704074
error:  function expected at
  subset_union_left ?m.704118
term has type
  ?m.704117 ‚àà ?m.704115 ‚à™ ?m.704116
error:  no goals to be solved","lemma sdiff_sup_lowerClosure (hts : t ‚äÜ s) (hst : ‚àÄ b ‚àà s, ‚àÄ c ‚àà t, c ‚â§ b ‚Üí b ‚àà t) :
    s.sdiff t ‚äî lowerClosure t = s ",":= by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ‚Ü¶ ?_
  obtain hat | hat := em (a ‚àà t)
  ¬∑ exact subset_union_right (subset_lowerClosure hat)
  ¬∑ refine subset_union_left ‚ü®ha, ?_‚ü©
    rintro ‚ü®b, hb, hba‚ü©
    exact hat <| hst _ ha _ hb hba"
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow,discr_prime_pow,297417982fafae931b48034c0aab7fe3396185a9,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : Algebra.IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this","error:  unknown constant 'Algebra.IsSeparable'
error:  failed to synthesize
  IsSeparable K L
use `set_option diagnostics true` to get diagnostic information","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ‚Ñï).Prime]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1)) : ‚Ñï) K))
    (hk : p ^ (k + 1) ‚â† 2) : discr K (hŒ∂.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : ‚Ñï).totient / 2) * p ^ ((p : ‚Ñï) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this"
Mathlib/Topology/Algebra/Order/Field.lean,tendsto_pow_neg_atTop,tendsto_pow_neg_atTop,105a48d42f84ef02d78acca07b3565aa1b78ec83,":= by
  simpa only [zpow_neg, zpow_natCast] using (@tendsto_pow_atTop ùïú _ _ _ hn).inv_tendsto_atTop","error:  application type mismatch
  @tendsto_pow_atTop ùïú ?m.32369 ?m.32370 ?m.32371 hn
argument
  hn
has type
  n ‚â† 0 : Prop
but is expected to have type
  Set ùïú : Type u_1","theorem tendsto_pow_neg_atTop {n : ‚Ñï} (hn : n ‚â† 0) :
    Tendsto (fun x : ùïú => x ^ (-(n : ‚Ñ§))) atTop (ùìù 0) ",":= by
  simpa only [zpow_neg, zpow_natCast] using (@tendsto_pow_atTop ùïú _ _ hn).inv_tendsto_atTop"
Mathlib/CategoryTheory/Preadditive/Yoneda/Projective.lean,CategoryTheory.Projective.projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj',projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj',fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  rw [projective_iff_preservesEpimorphisms_coyoneda_obj]
  refine ‚ü®fun h : (preadditiveCoyoneda.obj (op P) ‚ãô
      forget AddCommGroupCat).PreservesEpimorphisms => ?_,? _‚ü©
  ¬∑ exact Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveCoyoneda.obj (op P))
        (forget _)
  ¬∑ intro
    exact (inferInstance : (preadditiveCoyoneda.obj (op P) ‚ãô forget _).PreservesEpimorphisms)","error:  unknown identifier 'AddCommGroupCat'
error:  failed to synthesize
  (preadditiveCoyoneda.obj { unop := P } ‚ãô forget AddCommGrp).PreservesEpimorphisms
use `set_option diagnostics true` to get diagnostic information
error:  no goals to be solved","theorem projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj' (P : C) :
    Projective P ‚Üî (preadditiveCoyoneda.obj (op P)).PreservesEpimorphisms ",":= by
  rw [projective_iff_preservesEpimorphisms_coyoneda_obj]
  refine ‚ü®fun h : (preadditiveCoyoneda.obj (op P) ‚ãô
      forget AddCommGrp).PreservesEpimorphisms => ?_, ?_‚ü©
  ¬∑ exact Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveCoyoneda.obj (op P))
        (forget _)
  ¬∑ intro
    exact (inferInstance : (preadditiveCoyoneda.obj (op P) ‚ãô forget _).PreservesEpimorphisms)"
Mathlib/Data/List/OfFn.lean,List.get?_ofFn,get?_ofFn,66caaeed4dccada03ce195a3f9db1c0009ee8118,":=
  if h : i < (ofFn f).length
  then by
    rw [get?_eq_get h, get_ofFn]
    ¬∑ simp only [length_ofFn] at h; simp [ofFnNthVal, h]
  else by
    rw [ofFnNthVal, dif_neg] <;>
    simpa using h","error:  type mismatch
  h‚úù
has type
  n ‚â§ i : Prop
but is expected to have type
  ofFnNthVal f i = none : Prop
error:  unsolved goals
Œ± : Type u
n : ‚Ñï
f : Fin n ‚Üí Œ±
i : ‚Ñï
h : ¬¨i < (ofFn f).length
‚ä¢ (ofFn f).get? i = none
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_ofFn` has been deprecated, use `List.get_ofFn` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead",theorem get?_ofFn {n} (f : Fin n ‚Üí Œ±) (i) : get? (ofFn f) i = ofFnNthVal f i ,":= by
  simp"
Mathlib/Order/UpperLower/Basic.lean,LowerSet.sdiff_sup_lowerClosure,sdiff_sup_lowerClosure,ec25cca0630aff3805accd410e27691c8e6c4315,":= by
  refine' le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ‚Ü¶ _
  obtain hat | hat := em (a ‚àà t)
  ¬∑ exact subset_union_right _ _ (subset_lowerClosure hat)
  ¬∑ refine subset_union_left _ _ ‚ü®ha, ?_‚ü©
    rintro ‚ü®b, hb, hba‚ü©
    exact hat <| hst _ ha _ hb hba","error:  function expected at
  subset_union_right ?m.704076
term has type
  ?m.704075 ‚àà ?m.704073 ‚à™ ?m.704074
error:  function expected at
  subset_union_left ?m.704118
term has type
  ?m.704117 ‚àà ?m.704115 ‚à™ ?m.704116
error:  no goals to be solved","lemma sdiff_sup_lowerClosure (hts : t ‚äÜ s) (hst : ‚àÄ b ‚àà s, ‚àÄ c ‚àà t, c ‚â§ b ‚Üí b ‚àà t) :
    s.sdiff t ‚äî lowerClosure t = s ",":= by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ‚Ü¶ ?_
  obtain hat | hat := em (a ‚àà t)
  ¬∑ exact subset_union_right (subset_lowerClosure hat)
  ¬∑ refine subset_union_left ‚ü®ha, ?_‚ü©
    rintro ‚ü®b, hb, hba‚ü©
    exact hat <| hst _ ha _ hb hba"
Mathlib/LinearAlgebra/Matrix/IsDiag.lean,Matrix.isDiag_fromBlocks_iff,isDiag_fromBlocks_iff,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  constructor
  ¬∑ intro h
    refine ‚ü®fun i j hij => ?_, ext fun i j =>? _, ext fun i j =?> _, fun i j hij =>? _‚ü©
    ¬∑ exact h (Sum.inl_injective.ne hij)
    ¬∑ exact h Sum.inl_ne_inr
    ¬∑ exact h Sum.inr_ne_inl
    ¬∑ exact h (Sum.inr_injective.ne hij)
  ¬∑ rintro ‚ü®ha, hb, hc, hd‚ü©
    convert IsDiag.fromBlocks ha hd","error:  unexpected token '='; expected '‚Ü¶', '=>'
error:  unsolved goals
case mp.refine_1
Œ± : Type u_1
Œ≤ : Type u_2
R : Type u_3
n : Type u_4
m : Type u_5
inst‚úù : Zero Œ±
A : Matrix m m Œ±
B : Matrix m n Œ±
C : Matrix n m Œ±
D : Matrix n n Œ±
h : (fromBlocks A B C D).IsDiag
i j : m
hij : i ‚â† j
‚ä¢ (fun i j ‚Ü¶ A i j = 0) i j

case mp.refine_2
Œ± : Type u_1
Œ≤ : Type u_2
R : Type u_3
n : Type u_4
m : Type u_5
inst‚úù : Zero Œ±
A : Matrix m m Œ±
B : Matrix m n Œ±
C : Matrix n m Œ±
D : Matrix n n Œ±
h : (fromBlocks A B C D).IsDiag
i : m
j : n
‚ä¢ B i j = 0 i j
error:  unsolved goals
case mpr
Œ± : Type u_1
Œ≤ : Type u_2
R : Type u_3
n : Type u_4
m : Type u_5
inst‚úù : Zero Œ±
A : Matrix m m Œ±
B : Matrix m n Œ±
C : Matrix n m Œ±
D : Matrix n n Œ±
‚ä¢ A.IsDiag ‚àß B = 0 ‚àß C = 0 ‚àß D.IsDiag ‚Üí (fromBlocks A B C D).IsDiag","theorem isDiag_fromBlocks_iff [Zero Œ±] {A : Matrix m m Œ±} {B : Matrix m n Œ±} {C : Matrix n m Œ±}
    {D : Matrix n n Œ±} : (A.fromBlocks B C D).IsDiag ‚Üî A.IsDiag ‚àß B = 0 ‚àß C = 0 ‚àß D.IsDiag ",":= by
  constructor
  ¬∑ intro h
    refine ‚ü®fun i j hij => ?_, ext fun i j => ?_, ext fun i j => ?_, fun i j hij => ?_‚ü©
    ¬∑ exact h (Sum.inl_injective.ne hij)
    ¬∑ exact h Sum.inl_ne_inr
    ¬∑ exact h Sum.inr_ne_inl
    ¬∑ exact h (Sum.inr_injective.ne hij)
  ¬∑ rintro ‚ü®ha, hb, hc, hd‚ü©
    convert IsDiag.fromBlocks ha hd"
Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean,Real.Angle.sin_add_pi_div_two,sin_add_pi_div_two,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction Œ∏
  exact Real.sin_add_pi_div_two _","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Œ∏ : Angle
‚ä¢ (Œ∏ + ‚Üë(œÄ / 2)).sin = Œ∏.cos",theorem sin_add_pi_div_two (Œ∏ : Angle) : sin (Œ∏ + ‚Üë(œÄ / 2)) = cos Œ∏ ,":= by
  induction Œ∏ using Real.Angle.induction_on
  exact Real.sin_add_pi_div_two _"
Mathlib/Algebra/Module/PID.lean,Module.torsion_by_prime_power_decomposition,torsion_by_prime_power_decomposition,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ simp only [Nat.zero_eq] at *
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
    clear IH
    ¬∑ have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine' ‚ü®x, h0, _‚ü©; rw [h1]
        simp only [LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((@lequivProdOfRightSplitExact _ _ _ _ _ _ _ _ _ _ _ _
          ((f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          ((DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one, (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'","error:  simp made no progress
error:  simp made no progress
error:  tactic 'rewrite' failed, motive is not type correct
case h.succ.intro.refine_3.intro.intro.refine_2.refine_2.H.h.h
R : Type u
inst‚úù‚Å∂ : CommRing R
inst‚úù‚Åµ : IsDomain R
inst‚úù‚Å¥ : IsPrincipalIdealRing R
M : Type v
inst‚úù¬≥ : AddCommGroup M
inst‚úù¬≤ : Module R M
p : R
hp : Irreducible p
hM : IsTorsion' M ‚Ü•(Submonoid.powers p)
dec : (x : M) ‚Üí Decidable (x = 0)
d : ‚Ñï
N : Type (max u v)
inst‚úù¬π : AddCommGroup N
inst‚úù : Module R N
hN : IsTorsion' N ‚Ü•(Submonoid.powers p)
s : Fin (d + 1) ‚Üí N
hs : Submodule.span R (Set.range s) = ‚ä§
this‚úù : (x : N) ‚Üí Decidable (x = 0)
j : Fin d.succ
hj : IsTorsionBy R N (p ^ pOrder hN (s j))
s' : Fin d ‚Üí N ‚ß∏ Submodule.span R {s j} := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
k : Fin d ‚Üí ‚Ñï
f : (N ‚ß∏ Submodule.span R {s j}) ‚âÉ‚Çó[R] ‚®Å (i : Fin d), R ‚ß∏ Submodule.span R {p ^ k i}
this :
  ‚àÄ (i : Fin d),
    ‚àÉ x,
      p ^ k i ‚Ä¢ x = 0 ‚àß
        f (Submodule.Quotient.mk x) = (DirectSum.lof R (Fin d) (fun i ‚Ü¶ R ‚ß∏ Submodule.span R {p ^ k i}) i) 1
i : Fin d
‚ä¢ f (Submodule.Quotient.mk ‚ãØ.choose) =
    (DirectSum.lof R (Fin d) (fun i ‚Ü¶ R ‚ß∏ Submodule.span R {p ^ k i}) i)
      ((Ideal.Quotient.mk (Submodule.span R {p ^ k i})) 1)
error:  failed to synthesize
  One (‚®Å (i : Fin d), R ‚ß∏ Submodule.span R {p ^ k i})
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  OneHomClass (R ‚ß∏ Submodule.span R {p ^ k i} ‚Üí‚Çó[R] ‚®Å (i : Fin d), R ‚ß∏ Submodule.span R {p ^ k i})
    (R ‚ß∏ Submodule.span R {p ^ k i}) (‚®Å (i : Fin d), R ‚ß∏ Submodule.span R {p ^ k i})
use `set_option diagnostics true` to get diagnostic information
error:  simp made no progress","theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ‚àÉ (d : ‚Ñï) (k : Fin d ‚Üí ‚Ñï), Nonempty <| N ‚âÉ‚Çó[R] ‚®Å i : Fin d, R ‚ß∏ R ‚àô p ^ (k i : ‚Ñï) ",":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    ¬∑ obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
      clear IH
      have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ‚ü®x, h0, ?_‚ü©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'"
Mathlib/Order/ConditionallyCompleteLattice/Basic.lean,WithTop.isGLB_sInf',isGLB_sInf',a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  constructor
  ¬∑ show ite _ _ _ ‚àà _
    split_ifs with h
    ¬∑ intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exact le_top
      refine coe_le_coe.2 (csInf_le ?_ ha)
      rcases hs with ‚ü®‚ü®‚ü© | b, hb‚ü©
      ¬∑ exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, ‚Üê top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact coe_le_coe.1 (hb hc)
  ¬∑ show ite _ _ _ ‚àà _
    split_ifs with h
    ¬∑ intro _ _
      exact le_top
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      ¬∑ refine coe_le_coe.2 (le_csInf ?_ ?_)
        ¬∑ classical
            contrapose! h
            rintro (‚ü®‚ü© | a) ha
            ¬∑ exact mem_singleton ‚ä§
            ¬∑ exact (not_nonempty_iff_eq_empty.2 h ‚ü®a, ha‚ü©).elim
        ¬∑ intro b hb
          rw [‚Üê coe_le_coe]
          exact ha hb","error:  function expected at
  h
term has type
  s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.intro.none
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
h : ¬¨(s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s)
a : Œ≤
ha : Option.some a ‚àà s
hb : none ‚àà lowerBounds s
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
error:  tactic 'introN' failed, insufficient number of binders
case neg.none
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
hs : BddBelow s
h : ¬¨(s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s)
ha : none ‚àà lowerBounds s
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.refine_1
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
hs : BddBelow s
a : Œ≤
ha : Option.some a ‚àà lowerBounds s
h : (fun a ‚Ü¶ ‚Üëa) ‚Åª¬π' s = ‚àÖ
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s","theorem isGLB_sInf' {Œ≤ : Type*} [ConditionallyCompleteLattice Œ≤] {s : Set (WithTop Œ≤)}
    (hs : BddBelow s) : IsGLB s (sInf s) ",":= by
  constructor
  ¬∑ show ite _ _ _ ‚àà _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    ¬∑ intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exact le_top
      refine coe_le_coe.2 (csInf_le ?_ ha)
      rcases hs with ‚ü®‚ü®‚ü© | b, hb‚ü©
      ¬∑ exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, ‚Üê top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact coe_le_coe.1 (hb hc)
  ¬∑ show ite _ _ _ ‚àà _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    ¬∑ intro _ _
      exact le_top
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      ¬∑ refine coe_le_coe.2 (le_csInf ?_ ?_)
        ¬∑ classical
            contrapose! h
            rintro (‚ü®‚ü© | a) ha
            ¬∑ exact mem_singleton ‚ä§
            ¬∑ exact (not_nonempty_iff_eq_empty.2 h ‚ü®a, ha‚ü©).elim
        ¬∑ intro b hb
          rw [‚Üê coe_le_coe]
          exact ha hb"
Mathlib/GroupTheory/SchurZassenhaus.lean,Subgroup.exists_right_complement'_of_coprime,exists_right_complement'_of_coprime,b999f5fc5a622c176ec2ff740c2226c15d01d750,":=
  instNonempty.elim fun Œ± => ‚ü®stabilizer G Œ±, isComplement'_stabilizer_of_coprime hH‚ü©",error:  unknown identifier 'instNonempty.elim',"theorem exists_right_complement'_of_coprime_aux (hH : Nat.Coprime (Nat.card H) H.index) :
    ‚àÉ K : Subgroup G, IsComplement' H K ",":=
  have ne : Nonempty (QuotientDiff H) := inferInstance
  ne.elim fun Œ± => ‚ü®stabilizer G Œ±, isComplement'_stabilizer_of_coprime hH‚ü©"
Mathlib/Analysis/Normed/Field/Basic.lean,mulRight_bound,mulRight_bound,f0cbe979f38258b1a4b5343919fcfc240dac86d4,":= fun y => by
  rw [mul_comm]
  convert norm_mul_le y x","error:  unsolved goals
case h.e'_3.h.e'_3.h.e
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
Œπ : Type u_4
inst‚úù : NonUnitalSeminormedRing Œ±
x y : Œ±
‚ä¢ ‚áë(AddMonoidHom.mulRight x) = HMul.hMul y

case h.e'_3.h.e'_3.h.e'_1
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
Œπ : Type u_4
inst‚úù : NonUnitalSeminormedRing Œ±
x y : Œ±
‚ä¢ y = x","theorem mulRight_bound (x : Œ±) : ‚àÄ y : Œ±, ‚ÄñAddMonoidHom.mulRight x y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ ",":= fun y => by
  rw [mul_comm]
  exact norm_mul_le y x"
Mathlib/Analysis/Calculus/Taylor.lean,taylor_mean_remainder_lagrange,taylor_mean_remainder_lagrange,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  have gcont : ContinuousOn (fun t : ‚Ñù => (x - t) ^ (n + 1)) (Icc x‚ÇÄ x) := by
    refine' Continuous.continuousOn _
    exact (continuous_const.sub continuous_id').pow _ 
  have xy_ne : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí (x - y) ^ n ‚â† 0 := by
    intro y hy
    refine' pow_ne_zero _ _
    rw [mem_Ioo] at hy
    rw [sub_ne_zero]
    exact hy.2.ne'
  have hg' : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí -(‚Üën + 1) * (x - y) ^ n ‚â† 0 := fun y hy =>
    mul_ne_zero (neg_ne_zero.mpr (Nat.cast_add_one_ne_zero n)) (xy_ne y hy)
  rcases taylor_mean_remainder hx hf hf' gcont (fun y _ => monomial_has_deriv_aux y x _) hg' with
    ‚ü®y, hy, h‚ü©
  use y, hy
  simp only [sub_self, zero_pow, Ne.def, Nat.succ_ne_zero, not_false_iff, zero_sub, mul_neg] at h
  rw [h, neg_div, ‚Üê div_neg, neg_mul, neg_neg]
  field_simp [xy_ne y hy, Nat.factorial]; ring","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.136822 ‚Üí ?m.136822 ‚Üí Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  -?b / ?a
case right
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚Ñù E
f : ‚Ñù ‚Üí ‚Ñù
x x‚ÇÄ : ‚Ñù
n : ‚Ñï
hx : x‚ÇÄ < x
hf : ContDiffOn ‚Ñù (‚Üën) f (Icc x‚ÇÄ x)
hf' : DifferentiableOn ‚Ñù (iteratedDerivWithin n f (Icc x‚ÇÄ x)) (Ioo x‚ÇÄ x)
gcont : ContinuousOn (fun t ‚Ü¶ (x - t) ^ (n + 1)) (Icc x‚ÇÄ x)
xy_ne : ‚àÄ y ‚àà Ioo x‚ÇÄ x, (x - y) ^ n ‚â† 0
hg' : ‚àÄ y ‚àà Ioo x‚ÇÄ x, -(‚Üën + 1) * (x - y) ^ n ‚â† 0
y : ‚Ñù
hy : y ‚àà Ioo x‚ÇÄ x
h :
  f x - taylorWithinEval f n (Icc x‚ÇÄ x) x‚ÇÄ x =
    ((x - y) ^ n / ‚Üën ! * (0 ^ (n + 1) - (x - x‚ÇÄ) ^ (n + 1)) / (-(‚Üën + 1) * (x - y) ^ n)) ‚Ä¢
      iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) y
‚ä¢ ((x - y) ^ n / ‚Üën ! * (0 ^ (n + 1) - (x - x‚ÇÄ) ^ (n + 1)) / (-(‚Üën + 1) * (x - y) ^ n)) ‚Ä¢
      iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) y =
    iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) y * (x - x‚ÇÄ) ^ (n + 1) / ‚Üë(n + 1)!","theorem taylor_mean_remainder_lagrange {f : ‚Ñù ‚Üí ‚Ñù} {x x‚ÇÄ : ‚Ñù} {n : ‚Ñï} (hx : x‚ÇÄ < x)
    (hf : ContDiffOn ‚Ñù n f (Icc x‚ÇÄ x))
    (hf' : DifferentiableOn ‚Ñù (iteratedDerivWithin n f (Icc x‚ÇÄ x)) (Ioo x‚ÇÄ x)) :
    ‚àÉ x' ‚àà Ioo x‚ÇÄ x, f x - taylorWithinEval f n (Icc x‚ÇÄ x) x‚ÇÄ x =
      iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) x' * (x - x‚ÇÄ) ^ (n + 1) / (n + 1)! ",":= by
  have gcont : ContinuousOn (fun t : ‚Ñù => (x - t) ^ (n + 1)) (Icc x‚ÇÄ x) := by fun_prop
  have xy_ne : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí (x - y) ^ n ‚â† 0 := by
    intro y hy
    refine pow_ne_zero _ ?_
    rw [mem_Ioo] at hy
    rw [sub_ne_zero]
    exact hy.2.ne'
  have hg' : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí -(‚Üën + 1) * (x - y) ^ n ‚â† 0 := fun y hy =>
    mul_ne_zero (neg_ne_zero.mpr (Nat.cast_add_one_ne_zero n)) (xy_ne y hy)
  rcases taylor_mean_remainder hx hf hf' gcont (fun y _ => monomial_has_deriv_aux y x _) hg' with
    ‚ü®y, hy, h‚ü©
  use y, hy
  simp only [sub_self, zero_pow, Ne, Nat.succ_ne_zero, not_false_iff, zero_sub, mul_neg] at h
  rw [h, neg_div, ‚Üê div_neg, neg_mul, neg_neg]
  field_simp [xy_ne y hy, Nat.factorial]; ring"
Mathlib/Data/List/Indexes.lean,List.mapIdx_append_one,mapIdx_append_one,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  intros f l e
  unfold mapIdx
  rw [mapIdxGo_append f l [e]]
  simp only [mapIdx.go, Array.size_toArray, mapIdxGo_length, length_nil, add_zero, Array.toList_eq,
    Array.push_data, Array.data_toArray]","error:  unsolved goals
Œ± : Type u
Œ≤ : Type v
f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤
l : List Œ±
e : Œ±
‚ä¢ mapIdx.go f l #[] ++ [f (l.length + 0) e] = mapIdx.go f l #[] ++ [f l.length e]
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem mapIdx_append_one : ‚àÄ (f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤) (l : List Œ±) (e : Œ±),
    mapIdx f (l ++ [e]) = mapIdx f l ++ [f l.length e] ",":= by
  intros f l e
  unfold mapIdx
  rw [mapIdxGo_append f l [e]]
  simp only [mapIdx.go, Array.size_toArray, mapIdxGo_length, length_nil, Nat.add_zero,
    Array.toList_eq, Array.push_data, Array.data_toArray]"
Mathlib/RingTheory/Filtration.lean,Ideal.Filtration.submodule_eq_span_le_iff_stable_ge,submodule_eq_span_le_iff_stable_ge,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [‚Üê submodule_span_single, ‚Üê LE.le.le_iff_eq, Submodule.span_le, Set.iUnion_subset_iff]
  swap; ¬∑ exact Submodule.span_mono (Set.iUnion‚ÇÇ_subset_iUnion _ _)
  constructor
  ¬∑ intro H n hn
    refine' (F.smul_le n).antisymm _
    intro x hx
    obtain ‚ü®l, hl‚ü© := (Finsupp.mem_span_iff_total _ _ _).mp (H _ ‚ü®x, hx, rfl‚ü©)
    replace hl := congr_arg (fun f : ‚Ñï ‚Üí‚ÇÄ M => f (n + 1)) hl
    dsimp only at hl
    erw [Finsupp.single_eq_same] at hl
    rw [‚Üê hl, Finsupp.total_apply, Finsupp.sum_apply]
    apply Submodule.sum_mem _ _
    rintro ‚ü®_, _, ‚ü®n', rfl‚ü©, _, ‚ü®hn', rfl‚ü©, m, hm, rfl‚ü© -
    dsimp only [Subtype.coe_mk]
    rw [Subalgebra.smul_def, smul_single_apply, if_pos (show n' ‚â§ n + 1 by omega)]
    have e : n' ‚â§ n := by omega
    have := F.pow_smul_le_pow_smul (n - n') n' 1
    rw [tsub_add_cancel_of_le e, pow_one, add_comm _ 1, ‚Üê add_tsub_assoc_of_le e, add_comm] at this
    exact this (Submodule.smul_mem_smul ((l _).2 <| n + 1 - n') hm)
  ¬∑ let F' := Submodule.span (reesAlgebra I) (‚ãÉ i ‚â§ n‚ÇÄ, single R i '' (F.N i : Set M))
    intro hF i
    have : ‚àÄ i ‚â§ n‚ÇÄ, single R i '' (F.N i : Set M) ‚äÜ F' := by
      intro i hi
      refine Set.Subset.trans ?_ Submodule.subset_span
      refine @Set.subset_iUnion‚ÇÇ _ _ _ (fun i => fun _ => ‚Üë((single R i) '' ((N F i) : Set M))) i ?_
      exact hi
    induction' i with j hj
    ¬∑ exact this _ (zero_le _)
    by_cases hj' : j.succ ‚â§ n‚ÇÄ
    ¬∑ exact this _ hj'
    simp only [not_le, Nat.lt_succ_iff] at hj'
    rw [Nat.succ_eq_add_one, ‚Üê hF _ hj']
    rintro _ ‚ü®m, hm, rfl‚ü©
    refine' Submodule.smul_induction_on hm (fun r hr m' hm' => _) (fun x y hx hy => _)
    ¬∑ rw [add_comm, ‚Üê monomial_smul_single]
      exact F'.smul_mem
        ‚ü®_, reesAlgebra.monomial_mem.mpr (by rwa [pow_one])‚ü© (hj <| Set.mem_image_of_mem _ hm')
    ¬∑ rw [map_add]
      exact F'.add_mem hx hy","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case neg
R M : Type u
inst‚úù¬≤ : CommRing R
inst‚úù¬π : AddCommGroup M
inst‚úù : Module R M
I : Ideal R
F F'‚úù : I.Filtration M
h : F.Stable
n‚ÇÄ : ‚Ñï
F' : Submodule (‚Ü•(reesAlgebra I)) (PolynomialModule R M) :=
  Submodule.span (‚Ü•(reesAlgebra I)) (‚ãÉ i, ‚ãÉ (_ : i ‚â§ n‚ÇÄ), ‚áë(single R i) '' ‚Üë(F.N i))
hF : ‚àÄ n ‚â• n‚ÇÄ, I ‚Ä¢ F.N n = F.N (n + 1)
this : ‚àÄ i ‚â§ n‚ÇÄ, ‚áë(single R i) '' ‚Üë(F.N i) ‚äÜ ‚ÜëF'
j : ‚Ñï
hj : ‚áë(single R j) '' ‚Üë(F.N j) ‚äÜ ‚Üë(Submodule.span (‚Ü•(reesAlgebra I)) (‚ãÉ i, ‚ãÉ (_ : i ‚â§ n‚ÇÄ), ‚áë(single R i) '' ‚Üë(F.N i)))
hj' : n‚ÇÄ ‚â§ j
‚ä¢ ‚áë(single R (j + 1)) '' ‚Üë(F.N (j + 1)) ‚äÜ
    ‚Üë(Submodule.span (‚Ü•(reesAlgebra I)) (‚ãÉ i, ‚ãÉ (_ : i ‚â§ n‚ÇÄ), ‚áë(single R i) '' ‚Üë(F.N i)))","theorem submodule_eq_span_le_iff_stable_ge (n‚ÇÄ : ‚Ñï) :
    F.submodule = Submodule.span _ (‚ãÉ i ‚â§ n‚ÇÄ, single R i '' (F.N i : Set M)) ‚Üî
      ‚àÄ n ‚â• n‚ÇÄ, I ‚Ä¢ F.N n = F.N (n + 1) ",":= by
  rw [‚Üê submodule_span_single, ‚Üê LE.le.le_iff_eq, Submodule.span_le, Set.iUnion_subset_iff]
  swap; ¬∑ exact Submodule.span_mono (Set.iUnion‚ÇÇ_subset_iUnion _ _)
  constructor
  ¬∑ intro H n hn
    refine (F.smul_le n).antisymm ?_
    intro x hx
    obtain ‚ü®l, hl‚ü© := (Finsupp.mem_span_iff_total _ _ _).mp (H _ ‚ü®x, hx, rfl‚ü©)
    replace hl := congr_arg (fun f : ‚Ñï ‚Üí‚ÇÄ M => f (n + 1)) hl
    dsimp only at hl
    erw [Finsupp.single_eq_same] at hl
    rw [‚Üê hl, Finsupp.total_apply, Finsupp.sum_apply]
    apply Submodule.sum_mem _ _
    rintro ‚ü®_, _, ‚ü®n', rfl‚ü©, _, ‚ü®hn', rfl‚ü©, m, hm, rfl‚ü© -
    dsimp only [Subtype.coe_mk]
    rw [Subalgebra.smul_def, smul_single_apply, if_pos (show n' ‚â§ n + 1 by omega)]
    have e : n' ‚â§ n := by omega
    have := F.pow_smul_le_pow_smul (n - n') n' 1
    rw [tsub_add_cancel_of_le e, pow_one, add_comm _ 1, ‚Üê add_tsub_assoc_of_le e, add_comm] at this
    exact this (Submodule.smul_mem_smul ((l _).2 <| n + 1 - n') hm)
  ¬∑ let F' := Submodule.span (reesAlgebra I) (‚ãÉ i ‚â§ n‚ÇÄ, single R i '' (F.N i : Set M))
    intro hF i
    have : ‚àÄ i ‚â§ n‚ÇÄ, single R i '' (F.N i : Set M) ‚äÜ F' := by
      intro i hi
      refine Set.Subset.trans ?_ Submodule.subset_span
      refine @Set.subset_iUnion‚ÇÇ _ _ _ (fun i => fun _ => ‚Üë((single R i) '' ((N F i) : Set M))) i ?_
      exact hi
    induction' i with j hj
    ¬∑ exact this _ (zero_le _)
    by_cases hj' : j.succ ‚â§ n‚ÇÄ
    ¬∑ exact this _ hj'
    simp only [not_le, Nat.lt_succ_iff] at hj'
    rw [‚Üê hF _ hj']
    rintro _ ‚ü®m, hm, rfl‚ü©
    refine Submodule.smul_induction_on hm (fun r hr m' hm' => ?_) (fun x y hx hy => ?_)
    ¬∑ rw [add_comm, ‚Üê monomial_smul_single]
      exact F'.smul_mem
        ‚ü®_, reesAlgebra.monomial_mem.mpr (by rwa [pow_one])‚ü© (hj <| Set.mem_image_of_mem _ hm')
    ¬∑ rw [map_add]
      exact F'.add_mem hx hy"
Mathlib/Data/Finset/Card.lean,Finset.le_card_sdiff,le_card_sdiff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  calc
    card t - card s ‚â§ card t - card (s ‚à© t) :=
      tsub_le_tsub_left (card_le_card (inter_subset_left s t)) _
    _ = card (t \ (s ‚à© t)) := (card_sdiff (inter_subset_right s t)).symm
    _ ‚â§ card (t \ s) := by rw [sdiff_inter_self_right t s]","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Finset Œ± : Type u_1
but is expected to have type
  ?m.50929 ‚àà ?m.50927 ‚à© ?m.50928 : Prop
error:  failed to synthesize
  OrderedSub ‚Ñï
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  inter_subset_right s
argument
  s
has type
  Finset Œ± : Type u_1
but is expected to have type
  ?m.51558 ‚àà ?m.51556 ‚à© ?m.51557 : Prop",theorem le_card_sdiff (s t : Finset Œ±) : t.card - s.card ‚â§ card (t \ s) ,":=
  calc
    card t - card s ‚â§ card t - card (s ‚à© t) :=
      Nat.sub_le_sub_left (card_le_card inter_subset_left) _
    _ = card (t \ (s ‚à© t)) := (card_sdiff inter_subset_right).symm
    _ ‚â§ card (t \ s) := by rw [sdiff_inter_self_right t s]"
Mathlib/Data/Nat/PartENat.lean,PartENat.lt_coe_succ_iff_le,lt_coe_succ_iff_le,8b24b7412473ebe3dfb3396b9609b7817f5d3868,:=,error:  unexpected token 'theorem'; expected term,lemma lt_coe_succ_iff_le {x : PartENat} {n : ‚Ñï} (hx : x ‚â† ‚ä§) : x < n.succ ‚Üî x ‚â§ n ,":= by
  rw [Nat.succ_eq_add_one n, Nat.cast_add, Nat.cast_one, lt_add_one_iff_lt hx]"
Mathlib/Data/Rat/Cast/Defs.lean,MonoidWithZeroHom.ext_rat',ext_rat',848a6055965ceeab03ba2c4d2d0e4e0e9b07c6e6,":=
  (FunLike.ext f g) fun r => by
    rw [‚Üê r.num_div_den, div_eq_mul_inv, map_mul, map_mul, h, ‚Üê Int.cast_ofNat,
      eq_on_inv‚ÇÄ f g]
    apply h",error:  unknown constant 'FunLike.ext',"theorem ext_rat' (h : ‚àÄ m : ‚Ñ§, f m = g m) : f = g ",":=
  (DFunLike.ext f g) fun r => by
    rw [‚Üê r.num_div_den, div_eq_mul_inv, map_mul, map_mul, h, ‚Üê Int.cast_natCast,
      eq_on_inv‚ÇÄ f g]
    apply h"
Mathlib/Analysis/InnerProductSpace/Basic.lean,OrthogonalFamily.independent,OrthogonalFamily.independent,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  classical!
  apply CompleteLattice.independent_of_dfinsupp_lsum_injective
  refine LinearMap.ker_eq_bot.mp ?_
  rw [Submodule.eq_bot_iff]
  intro v hv
  rw [LinearMap.mem_ker] at hv
  ext i
  suffices ‚ü™(v i : E), v i‚ü´ = 0 by simpa only [inner_self_eq_zero] using this
  calc
    ‚ü™(v i : E), v i‚ü´ = ‚ü™(v i : E), DFinsupp.lsum ‚Ñï (fun i => (V i).subtype) v‚ü´ := by
      simpa only [DFinsupp.sumAddHom_apply, DFinsupp.lsum_apply_apply] using
        (hV.inner_right_dfinsupp v i (v i)).symm
    _ = 0 := by simp only [hv, inner_zero_right]",error:  `classical!` has been removed; use `classical` instead,"theorem OrthogonalFamily.independent {V : Œπ ‚Üí Submodule ùïú E}
    (hV : OrthogonalFamily ùïú (fun i => V i) fun i => (V i).subtype‚Çó·µ¢) :
    CompleteLattice.Independent V ",":= by
  classical
  apply CompleteLattice.independent_of_dfinsupp_lsum_injective
  refine LinearMap.ker_eq_bot.mp ?_
  rw [Submodule.eq_bot_iff]
  intro v hv
  rw [LinearMap.mem_ker] at hv
  ext i
  suffices ‚ü™(v i : E), v i‚ü´ = 0 by simpa only [inner_self_eq_zero] using this
  calc
    ‚ü™(v i : E), v i‚ü´ = ‚ü™(v i : E), DFinsupp.lsum ‚Ñï (fun i => (V i).subtype) v‚ü´ := by
      simpa only [DFinsupp.sumAddHom_apply, DFinsupp.lsum_apply_apply] using
        (hV.inner_right_dfinsupp v i (v i)).symm
    _ = 0 := by simp only [hv, inner_zero_right]"
Mathlib/GroupTheory/OrderOfElement.lean,IsOfFinOrder.mem_powers_iff_mem_zpowers,IsOfFinOrder.mem_powers_iff_mem_zpowers,79472a9a407072ad66f912a2107dee718241ac15,":=
  ‚ü®fun ‚ü®n, hn‚ü© ‚Ü¶ ‚ü®n, by simp_all‚ü©, fun ‚ü®i, hi‚ü© ‚Ü¶ ‚ü®(i % orderOf x).natAbs, by
    dsimp only
    rwa [‚Üê zpow_coe_nat, Int.natAbs_of_nonneg <| Int.emod_nonneg _ <|
      Int.coe_nat_ne_zero_iff_pos.2 <| hx.orderOf_pos, zpow_mod_orderOf]‚ü©‚ü©","warning:  `zpow_coe_nat` has been deprecated, use `zpow_natCast` instead
warning:  `Int.coe_nat_ne_zero_iff_pos` has been deprecated, use `Int.natCast_ne_zero_iff_pos` instead
error:  application type mismatch
  zpow_coe_nat
argument has type
  SubNegMonoid G
but function has type
  ‚àÄ [inst : DivInvMonoid G] (a : G) (n : ‚Ñï), a ^ ‚Üën = a ^ n
error:  (kernel) unknown constant 'IsOfFinAddOrder.mem_multiples_iff_mem_zmultiples'
error:  (kernel) unknown constant 'IsOfFinAddOrder.mem_multiples_iff_mem_zmultiples'
error:  (kernel) unknown constant 'IsOfFinAddOrder.multiples_eq_zmultiples'
error:  (kernel) unknown constant 'finEquivZMultiples'
error:  (kernel) unknown constant 'finEquivZMultiples'
error:  @[to_additive] failed. Type mismatch in additive declaration. For help, see the docstring of `to_additive.attr`, section `Troubleshooting`. Failed to add declaration
mem_multiples_iff_mem_zmultiples:
unknown constant 'IsOfFinAddOrder.mem_multiples_iff_mem_zmultiples'
error:  @[to_additive] failed. Type mismatch in additive declaration. For help, see the docstring of `to_additive.attr`, section `Troubleshooting`. Failed to add declaration
multiples_eq_zmultiples:
unknown constant 'IsOfFinAddOrder.multiples_eq_zmultiples'
error:  @[to_additive] failed. Type mismatch in additive declaration. For help, see the docstring of `to_additive.attr`, section `Troubleshooting`. Failed to add declaration
mem_zmultiples_iff_mem_range_addOrderOf:
unknown constant 'IsOfFinAddOrder.mem_zmultiples_iff_mem_range_addOrderOf'
error:  (kernel) unknown constant 'finEquivZMultiples'
error:  (kernel) unknown constant 'zmultiplesEquivZMultiples'
error:  (kernel) unknown constant 'finEquivZMultiples'
error:  (kernel) unknown constant 'Fintype.card_zmultiples'
error:  (kernel) unknown constant 'Fintype.card_zmultiples'
error:  (kernel) unknown constant 'addOrderOf_dvd_card'
error:  (kernel) unknown constant 'addOrderOf_dvd_natCard'
error:  (kernel) unknown constant 'AddSubgroup.addOrderOf_dvd_natCard'
error:  (kernel) unknown constant 'addOrderOf_dvd_natCard'
error:  (kernel) unknown constant 'card_nsmul_eq_zero''
error:  (kernel) unknown constant 'card_nsmul_eq_zero''
error:  (kernel) unknown constant 'addOrderOf_dvd_card'
error:  (kernel) unknown constant 'addOrderOf_dvd_card'
error:  (kernel) unknown constant 'addOrderOf_dvd_natCard'
error:  (kernel) unknown constant 'addOrderOf_dvd_natCard'
error:  (kernel) unknown constant 'card_nsmul_eq_zero''
error:  (kernel) unknown constant 'nsmulCoprime'
error:  (kernel) unknown constant 'nsmulCoprime'
error:  (kernel) unknown constant 'nsmulCoprime'
error:  (kernel) unknown constant 'addOrderOf_dvd_card'
error:  (kernel) unknown constant 'mem_zmultiples_iff_mem_range_addOrderOf'
error:  (kernel) unknown constant 'card_nsmul_eq_zero'
error:  (kernel) unknown constant 'card_nsmul_eq_zero'
error:  unknown identifier 'card_nsmul_eq_zero'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.429596
G : Type u_1
H : Type u_2
A : Type u_3
Œ± : Type u_4
Œ≤ : Type u_5
R : Type u_6
inst‚úù¬π : AddGroupWithOne R
inst‚úù : Fintype R
‚ä¢ card R ‚Ä¢ 1 = 0","lemma IsOfFinOrder.mem_powers_iff_mem_zpowers (hx : IsOfFinOrder x) :
    y ‚àà powers x ‚Üî y ‚àà zpowers x ",":=
  ‚ü®fun ‚ü®n, hn‚ü© ‚Ü¶ ‚ü®n, by simp_all‚ü©, fun ‚ü®i, hi‚ü© ‚Ü¶ ‚ü®(i % orderOf x).natAbs, by
    dsimp only
    rwa [‚Üê zpow_natCast, Int.natAbs_of_nonneg <| Int.emod_nonneg _ <|
      Int.natCast_ne_zero_iff_pos.2 <| hx.orderOf_pos, zpow_mod_orderOf]‚ü©‚ü©"
Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean,MeasurableSpace.measurableSet_generateFrom_memPartition,measurableSet_generateFrom_memPartition,3bb2cb9fea0fbb1bf6bf2e7773ba73b51952e9e5,":= by
  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®S, hS_subset, hS_eq‚ü© ‚Ü¶ ?_‚ü©
  ¬∑ refine MeasurableSpace.generateFrom_induction
      (p := fun u ‚Ü¶ ‚àÉ S : Finset (Set Œ±), ‚ÜëS ‚äÜ memPartition t n ‚àß u = ‚ãÉ‚ÇÄ ‚ÜëS)
      (C := memPartition t n) ?_ ?_ ?_ ?_ h
    ¬∑ exact fun u hu ‚Ü¶ ‚ü®{u}, by simp [hu], by simp‚ü©
    ¬∑ exact ‚ü®‚àÖ, by simp, by simp‚ü©
    ¬∑ rintro u ‚ü®S, hS_subset, rfl‚ü©
      classical
      refine ‚ü®(memPartition t n).toFinset \ S, ?_, ?_‚ü©
      ¬∑ simp only [Finset.coe_sdiff, coe_toFinset]
        exact diff_subset _ _
      ¬∑ simp only [Finset.coe_sdiff, coe_toFinset]
        refine (IsCompl.eq_compl ‚ü®?_, ?_‚ü©).symm
        ¬∑ rw [disjoint_iff_inter_eq_empty]
          ext x
          simp only [mem_inter_iff, mem_sUnion, mem_diff, Finset.mem_coe, mem_empty_iff_false,
            iff_false, not_and, not_exists, forall_exists_index, and_imp]
          intro u hu huS hxu v hvS
          have huv : u ‚â† v := fun h_eq ‚Ü¶ absurd hvS (h_eq ‚ñ∏ huS)
          have : Disjoint u v := disjoint_memPartition t n hu (hS_subset hvS) huv
          exact fun hxv ‚Ü¶ absurd rfl (this.ne_of_mem hxu hxv)
        ¬∑ rw [codisjoint_iff]
          simp only [sup_eq_union, top_eq_univ]
          rw [‚Üê sUnion_memPartition t n, union_comm, ‚Üê sUnion_union, union_diff_cancel hS_subset]
    ¬∑ intro f h
      choose S hS_subset hS_eq using h
      have : Fintype (‚ãÉ n, (S n : Set (Set Œ±))) := by
        refine (Finite.subset (finite_memPartition t n) ?_).fintype
        simp only [iUnion_subset_iff]
        exact hS_subset
      refine ‚ü®(‚ãÉ n, (S n : Set (Set Œ±))).toFinset, ?_, ?_‚ü©
      ¬∑ simp only [coe_toFinset, iUnion_subset_iff]
        exact hS_subset
      ¬∑ simp only [coe_toFinset, sUnion_iUnion, hS_eq]
  ¬∑ rw [hS_eq, sUnion_eq_biUnion]
    refine MeasurableSet.biUnion ?_ (fun t ht ‚Ü¶ ?_)
    ¬∑ exact S.countable_toSet
    ¬∑ exact measurableSet_generateFrom (hS_subset ht)","error:  function expected at
  diff_subset ?m.43731
term has type
  ?m.43730 ‚àà ?m.43728","lemma measurableSet_generateFrom_memPartition_iff (t : ‚Ñï ‚Üí Set Œ±) (n : ‚Ñï) (s : Set Œ±) :
    MeasurableSet[generateFrom (memPartition t n)] s
      ‚Üî ‚àÉ S : Finset (Set Œ±), ‚ÜëS ‚äÜ memPartition t n ‚àß s = ‚ãÉ‚ÇÄ S ",":= by
  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®S, hS_subset, hS_eq‚ü© ‚Ü¶ ?_‚ü©
  ¬∑ refine MeasurableSpace.generateFrom_induction
      (p := fun u ‚Ü¶ ‚àÉ S : Finset (Set Œ±), ‚ÜëS ‚äÜ memPartition t n ‚àß u = ‚ãÉ‚ÇÄ ‚ÜëS)
      (C := memPartition t n) ?_ ?_ ?_ ?_ h
    ¬∑ exact fun u hu ‚Ü¶ ‚ü®{u}, by simp [hu], by simp‚ü©
    ¬∑ exact ‚ü®‚àÖ, by simp, by simp‚ü©
    ¬∑ rintro u ‚ü®S, hS_subset, rfl‚ü©
      classical
      refine ‚ü®(memPartition t n).toFinset \ S, ?_, ?_‚ü©
      ¬∑ simp only [Finset.coe_sdiff, coe_toFinset]
        exact diff_subset
      ¬∑ simp only [Finset.coe_sdiff, coe_toFinset]
        refine (IsCompl.eq_compl ‚ü®?_, ?_‚ü©).symm
        ¬∑ refine Set.disjoint_sUnion_right.mpr fun u huS => ?_
          refine Set.disjoint_sUnion_left.mpr fun v huV => ?_
          refine disjoint_memPartition t n (mem_of_mem_diff huV) (hS_subset huS) ?_
          exact ne_of_mem_of_not_mem huS (not_mem_of_mem_diff huV) |>.symm
        ¬∑ rw [codisjoint_iff]
          simp only [sup_eq_union, top_eq_univ]
          rw [‚Üê sUnion_memPartition t n, union_comm, ‚Üê sUnion_union, union_diff_cancel hS_subset]
    ¬∑ intro f h
      choose S hS_subset hS_eq using h
      have : Fintype (‚ãÉ n, (S n : Set (Set Œ±))) := by
        refine (Finite.subset (finite_memPartition t n) ?_).fintype
        simp only [iUnion_subset_iff]
        exact hS_subset
      refine ‚ü®(‚ãÉ n, (S n : Set (Set Œ±))).toFinset, ?_, ?_‚ü©
      ¬∑ simp only [coe_toFinset, iUnion_subset_iff]
        exact hS_subset
      ¬∑ simp only [coe_toFinset, sUnion_iUnion, hS_eq]
  ¬∑ rw [hS_eq, sUnion_eq_biUnion]
    refine MeasurableSet.biUnion ?_ (fun t ht ‚Ü¶ ?_)
    ¬∑ exact S.countable_toSet
    ¬∑ exact measurableSet_generateFrom (hS_subset ht)"
Mathlib/Data/QPF/Multivariate/Constructions/Cofix.lean,MvQPF.Cofix.bisim_rel,Cofix.bisim_rel,67ee3b7709353762fdc01cfb00722ee8c27ff6a5,":= by
  let r' (x y) := x = y ‚à® r x y
  intro x y rxy
  apply Cofix.bisim_aux r'
  ¬∑ intro x
    left
    rfl
  ¬∑ intro x y r'xy
    cases r'xy with
    | inl h =>
      rw [h]
    | inr r'xy =>
      have : ‚àÄ x y, r x y ‚Üí r' x y := fun x y h => Or.inr h
      rw [‚Üê Quot.factor_mk_eq _ _ this]
      dsimp [r']
      rw [appendFun_comp_id]
      rw [@comp_map _ _ _ q _ _ _ (appendFun id (Quot.mk r)),
        @comp_map _ _ _ q _ _ _ (appendFun id (Quot.mk r))]
      rw [h _ _ r'xy]
  right; exact rxy","error:  application type mismatch
  @comp_map ?m.13615 ?m.13616 ?m.13617 q
argument
  q
has type
  MvQPF F : Type (u + 1)
but is expected to have type
  TypeVec.{?u.13614} ?m.13615 : Type (?u.13614 + 1)","theorem Cofix.bisim_rel {Œ± : TypeVec n} (r : Cofix F Œ± ‚Üí Cofix F Œ± ‚Üí Prop)
    (h : ‚àÄ x y, r x y ‚Üí
      appendFun id (Quot.mk r) <$$> Cofix.dest x = appendFun id (Quot.mk r) <$$> Cofix.dest y) :
    ‚àÄ x y, r x y ‚Üí x = y ",":= by
  let r' (x y) := x = y ‚à® r x y
  intro x y rxy
  apply Cofix.bisim_aux r'
  ¬∑ intro x
    left
    rfl
  ¬∑ intro x y r'xy
    cases r'xy with
    | inl h =>
      rw [h]
    | inr r'xy =>
      have : ‚àÄ x y, r x y ‚Üí r' x y := fun x y h => Or.inr h
      rw [‚Üê Quot.factor_mk_eq _ _ this]
      dsimp [r']
      rw [appendFun_comp_id]
      rw [@comp_map _ _ q _ _ _ (appendFun id (Quot.mk r)),
        @comp_map _ _ q _ _ _ (appendFun id (Quot.mk r))]
      rw [h _ _ r'xy]
  right; exact rxy"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.partialGamma_add_one,partialGamma_add_one,051aa73462329fa6f7421c7112a573d135b828c1,":= by
  rw [partialGamma, partialGamma, add_sub_cancel]
  have F_der_I : ‚àÄ x : ‚Ñù, x ‚àà Ioo 0 X ‚Üí HasDerivAt (fun x => (-x).exp * x ^ s : ‚Ñù ‚Üí ‚ÑÇ)
      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by
    intro x hx
    have d1 : HasDerivAt (fun y : ‚Ñù => (-y).exp) (-(-x).exp) x := by
      simpa using (hasDerivAt_neg x).exp
    have d2 : HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ s) (s * x ^ (s - 1)) x := by
      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id ‚Üëx) ?_
      simpa only [mul_one] using t.comp_ofReal
      simpa only [id.def, ofReal_re, ofReal_im, Ne.def, eq_self_iff_true, not_true, or_false_iff,
        mul_one] using hx.1
    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2
  have cont := (continuous_ofReal.comp continuous_neg.exp).mul (continuous_ofReal_cpow_const hs)
  have der_ible :=
    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)
  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible
  apply_fun fun x : ‚ÑÇ => -x at int_eval
  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)
      (Gamma_integrand_deriv_integrable_B hs hX),
    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval
  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]
  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : ‚Ñù ‚Üí ‚ÑÇ) =
      (fun x => s * (-x).exp * x ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) := by ext1; ring
  rw [this]
  have t := @integral_const_mul 0 X volume _ _ s fun x : ‚Ñù => (-x).exp * x ^ (s - 1)
  rw [‚Üê t, ofReal_zero, zero_cpow]
  ¬∑ rw [mul_zero, add_zero]; congr 2; ext1; ring
  ¬∑ contrapose! hs; rw [hs, zero_re]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + (?b - ?a)
s : ‚ÑÇ
hs : 0 < s.re
X : ‚Ñù
hX : 0 ‚â§ X
‚ä¢ ‚à´ (x : ‚Ñù) in 0 ..X, ‚Üë(rexp (-x)) * ‚Üëx ^ (s + 1 - 1) =
    (s * ‚à´ (x : ‚Ñù) in 0 ..X, ‚Üë(rexp (-x)) * ‚Üëx ^ (s - 1)) - ‚Üë(rexp (-X)) * ‚ÜëX ^ s","theorem partialGamma_add_one {s : ‚ÑÇ} (hs : 0 < s.re) {X : ‚Ñù} (hX : 0 ‚â§ X) :
    partialGamma (s + 1) X = s * partialGamma s X - (-X).exp * X ^ s ",":= by
  rw [partialGamma, partialGamma, add_sub_cancel_right]
  have F_der_I : ‚àÄ x : ‚Ñù, x ‚àà Ioo 0 X ‚Üí HasDerivAt (fun x => (-x).exp * x ^ s : ‚Ñù ‚Üí ‚ÑÇ)
      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by
    intro x hx
    have d1 : HasDerivAt (fun y : ‚Ñù => (-y).exp) (-(-x).exp) x := by
      simpa using (hasDerivAt_neg x).exp
    have d2 : HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ s) (s * x ^ (s - 1)) x := by
      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id ‚Üëx) ?_
      ¬∑ simpa only [mul_one] using t.comp_ofReal
      ¬∑ exact ofReal_mem_slitPlane.2 hx.1
    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2
  have cont := (continuous_ofReal.comp continuous_neg.rexp).mul (continuous_ofReal_cpow_const hs)
  have der_ible :=
    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)
  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible
  apply_fun fun x : ‚ÑÇ => -x at int_eval
  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)
      (Gamma_integrand_deriv_integrable_B hs hX),
    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval
  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]
  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : ‚Ñù ‚Üí ‚ÑÇ) =
      (fun x => s * (-x).exp * x ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) := by ext1; ring
  rw [this]
  have t := @integral_const_mul 0 X volume _ _ s fun x : ‚Ñù => (-x).exp * x ^ (s - 1)
  rw [‚Üê t, ofReal_zero, zero_cpow]
  ¬∑ rw [mul_zero, add_zero]; congr 2; ext1; ring
  ¬∑ contrapose! hs; rw [hs, zero_re]"
Mathlib/Computability/Primrec.lean,PrimrecPred.or,_root_.PrimrecPred.or,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  (Primrec.or.comp‚ÇÇ hp hq).of_eq fun n => by simp","error:  application type mismatch
  Primrec‚ÇÇ.comp‚ÇÇ Primrec.or hp
argument
  hp
has type
  PrimrecPred p : Prop
but is expected to have type
  Primrec‚ÇÇ ?m.92952 : Prop
error:  simp made no progress","theorem _root_.PrimrecPred.or {p q : Œ± ‚Üí Prop} [DecidablePred p] [DecidablePred q]
    (hp : PrimrecPred p) (hq : PrimrecPred q) : PrimrecPred fun a => p a ‚à® q a ",":=
  (Primrec.or.comp hp hq).of_eq fun n => by simp"
Mathlib/Order/OrderIsoNat.lean,exists_increasing_or_nonincreasing_subseq,exists_increasing_or_nonincreasing_subseq,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  classical
    let bad : Set ‚Ñï := { m | ‚àÄ n, m < n ‚Üí ¬¨r (f m) (f n) }
    by_cases hbad : Infinite bad
    ¬∑ haveI := hbad
      refine ‚ü®Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => ?_‚ü©
      have h := @Set.mem_range_self _ _ ‚Üë(Nat.orderEmbeddingOfSet bad) m
      rw [Nat.orderEmbeddingOfSet_range bad] at h
      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)
    ¬∑ rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad
      obtain ‚ü®m, hm‚ü© : ‚àÉ m, ‚àÄ n, m ‚â§ n ‚Üí ¬¨n ‚àà bad := by
        by_cases he : hbad.toFinset.Nonempty
        ¬∑ refine'
            ‚ü®(hbad.toFinset.max' he).succ, fun n hn nbad =>
              Nat.not_succ_le_self _
                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))‚ü©
        ¬∑ exact ‚ü®0, fun n _ nbad => he ‚ü®n, hbad.mem_toFinset.2 nbad‚ü©‚ü©
      have h : ‚àÄ n : ‚Ñï, ‚àÉ n' : ‚Ñï, n < n' ‚àß r (f (n + m)) (f (n' + m)) := by
        intro n
        have h := hm _ (le_add_of_nonneg_left n.zero_le)
        simp only [bad, exists_prop, not_not, Set.mem_setOf_eq, not_forall] at h
        obtain ‚ü®n', hn1, hn2‚ü© := h
        obtain ‚ü®x, hpos, rfl‚ü© := exists_pos_add_of_lt hn1
        refine ‚ü®n + x, add_lt_add_left hpos n, ?_‚ü©
        rw [add_assoc, add_comm x m, ‚Üê add_assoc]
        exact hn2
      let g' : ‚Ñï ‚Üí ‚Ñï := @Nat.rec (fun _ => ‚Ñï) m fun n gn => Nat.find (h gn)
      exact
        ‚ü®(RelEmbedding.natLT (fun n => g' n + m) fun n =>
              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,
          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2‚ü©","error:  failed to synthesize
  CovariantClass ‚Ñï ‚Ñï (Function.swap fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  exists_pos_add_of_lt hn1
argument
  hn1
has type
  @LT.lt ‚Ñï instLTNat (n + m) n' : Prop
but is expected to have type
  @LT.lt ‚Ñï Preorder.toLT (n + m) n' : Prop","theorem exists_increasing_or_nonincreasing_subseq' (r : Œ± ‚Üí Œ± ‚Üí Prop) (f : ‚Ñï ‚Üí Œ±) :
    ‚àÉ g : ‚Ñï ‚Ü™o ‚Ñï,
      (‚àÄ n : ‚Ñï, r (f (g n)) (f (g (n + 1)))) ‚à® ‚àÄ m n : ‚Ñï, m < n ‚Üí ¬¨r (f (g m)) (f (g n)) ",":= by
  classical
    let bad : Set ‚Ñï := { m | ‚àÄ n, m < n ‚Üí ¬¨r (f m) (f n) }
    by_cases hbad : Infinite bad
    ¬∑ haveI := hbad
      refine ‚ü®Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => ?_‚ü©
      have h := @Set.mem_range_self _ _ ‚Üë(Nat.orderEmbeddingOfSet bad) m
      rw [Nat.orderEmbeddingOfSet_range bad] at h
      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)
    ¬∑ rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad
      obtain ‚ü®m, hm‚ü© : ‚àÉ m, ‚àÄ n, m ‚â§ n ‚Üí ¬¨n ‚àà bad := by
        by_cases he : hbad.toFinset.Nonempty
        ¬∑ refine
            ‚ü®(hbad.toFinset.max' he).succ, fun n hn nbad =>
              Nat.not_succ_le_self _
                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))‚ü©
        ¬∑ exact ‚ü®0, fun n _ nbad => he ‚ü®n, hbad.mem_toFinset.2 nbad‚ü©‚ü©
      have h : ‚àÄ n : ‚Ñï, ‚àÉ n' : ‚Ñï, n < n' ‚àß r (f (n + m)) (f (n' + m)) := by
        intro n
        have h := hm _ (Nat.le_add_left m n)
        simp only [bad, exists_prop, not_not, Set.mem_setOf_eq, not_forall] at h
        obtain ‚ü®n', hn1, hn2‚ü© := h
        refine ‚ü®n + n' - n - m, by omega, ?_‚ü©
        convert hn2
        omega
      let g' : ‚Ñï ‚Üí ‚Ñï := @Nat.rec (fun _ => ‚Ñï) m fun n gn => Nat.find (h gn)
      exact
        ‚ü®(RelEmbedding.natLT (fun n => g' n + m) fun n =>
              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,
          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2‚ü©"
Mathlib/RingTheory/IntegralClosure.lean,Algebra.finite_iff_isIntegral_and_finiteType,Algebra.finite_iff_isIntegral_and_finiteType,bd5d7180d2c8766d32f3a0b566829fe32e3553d3,":=
  ‚ü®fun _ ‚Ü¶ ‚ü®Algebra.IsIntegral.of_finite R, inferInstance‚ü©, fun ‚ü®h, _‚ü© ‚Ü¶ h.finite‚ü©","error:  application type mismatch
  And.intro (IsIntegral.of_finite R)
argument
  IsIntegral.of_finite R
has type
  ‚àÄ (B : Type ?u.178142) [inst : CommRing R] [inst_1 : Ring B] [inst_2 : Algebra R B] [inst_3 : Module.Finite R B],
    Algebra.IsIntegral R B : Prop
but is expected to have type
  Algebra.IsIntegral R A : Prop","theorem Algebra.finite_iff_isIntegral_and_finiteType :
    Module.Finite R A ‚Üî Algebra.IsIntegral R A ‚àß Algebra.FiniteType R A ",":=
  ‚ü®fun _ ‚Ü¶ ‚ü®‚ü®.of_finite R‚ü©, inferInstance‚ü©, fun ‚ü®h, _‚ü© ‚Ü¶ h.finite‚ü©"
Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean,hasDerivAt_ofReal_cpow,hasDerivAt_ofReal_cpow,01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  rw [Ne.def, ‚Üê add_eq_zero_iff_eq_neg, ‚Üê Ne.def] at hr
  rcases lt_or_gt_of_ne hx.symm with (hx | hx)
  ¬∑ 
    apply HasDerivAt.comp_ofReal (e := fun y => (y : ‚ÑÇ) ^ (r + 1) / (r + 1))
    convert HasDerivAt.div_const (ùïú := ‚ÑÇ) ?_ (r + 1) using 1
    ¬∑ exact (mul_div_cancel _ hr).symm
    ¬∑ convert HasDerivAt.cpow_const ?_ ?_ using 1
      ¬∑ rw [add_sub_cancel, mul_comm]; exact (mul_one _).symm
      ¬∑ exact hasDerivAt_id (x : ‚ÑÇ)
      ¬∑ simp [hx]
  ¬∑ 
    have : ‚àÄ·∂† y : ‚Ñù in nhds x,
        (y : ‚ÑÇ) ^ (r + 1) / (r + 1) = (-y : ‚ÑÇ) ^ (r + 1) * exp (œÄ * I * (r + 1)) / (r + 1) := by
      refine' Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => _
      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]
    refine' HasDerivAt.congr_of_eventuallyEq _ this
    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]
    suffices HasDerivAt (fun y : ‚Ñù => (-‚Üëy) ^ (r + 1) * exp (‚ÜëœÄ * I * (r + 1)))
        ((r + 1) * (-‚Üëx) ^ r * exp (‚ÜëœÄ * I * r)) x by
      convert this.div_const (r + 1) using 1
      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel _ hr]
    rw [mul_add ((œÄ : ‚ÑÇ) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : ‚ÑÇ) (-1 : ‚ÑÇ),
      neg_one_mul]
    simp_rw [mul_neg, ‚Üê neg_mul, ‚Üê ofReal_neg]
    suffices HasDerivAt (fun y : ‚Ñù => (‚Üë(-y) : ‚ÑÇ) ^ (r + 1)) (-(r + 1) * ‚Üë(-x) ^ r) x by
      convert this.neg.mul_const _ using 1; ring
    suffices HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) (-x) by
      convert @HasDerivAt.scomp ‚Ñù _ ‚ÑÇ _ _ x ‚Ñù _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1
      rw [real_smul, ofReal_neg 1, ofReal_one]; ring
    suffices HasDerivAt (fun y : ‚ÑÇ => y ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) ‚Üë(-x) by
      exact this.comp_ofReal
    conv in ‚Üë_ ^ _ => rw [(by ring : r = r + 1 - 1)]
    convert HasDerivAt.cpow_const ?_ ?_ using 1
    ¬∑ rw [add_sub_cancel, add_sub_cancel]; exact (mul_one _).symm
    ¬∑ exact hasDerivAt_id ((-x : ‚Ñù) : ‚ÑÇ)
    ¬∑ simp [hx]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.106391 ‚Üí ?m.106391 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.106393
f g : ‚ÑÇ ‚Üí ‚ÑÇ
s : Set ‚ÑÇ
f' g' x‚úù c : ‚ÑÇ
x : ‚Ñù
hx : x ‚â† 0
r : ‚ÑÇ
hr : r ‚â† -1
‚ä¢ HasDerivAt (fun y ‚Ü¶ ‚Üëy ^ (r + 1) / (r + 1)) (‚Üëx ^ r) x","theorem hasDerivAt_ofReal_cpow {x : ‚Ñù} (hx : x ‚â† 0) {r : ‚ÑÇ} (hr : r ‚â† -1) :
    HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ (r + 1) / (r + 1)) (x ^ r) x ",":= by
  rw [Ne, ‚Üê add_eq_zero_iff_eq_neg, ‚Üê Ne] at hr
  rcases lt_or_gt_of_ne hx.symm with (hx | hx)
  ¬∑ 
    apply HasDerivAt.comp_ofReal (e := fun y => (y : ‚ÑÇ) ^ (r + 1) / (r + 1))
    convert HasDerivAt.div_const (ùïú := ‚ÑÇ) ?_ (r + 1) using 1
    ¬∑ exact (mul_div_cancel_right‚ÇÄ _ hr).symm
    ¬∑ convert HasDerivAt.cpow_const ?_ ?_ using 1
      ¬∑ rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm
      ¬∑ exact hasDerivAt_id (x : ‚ÑÇ)
      ¬∑ simp [hx]
  ¬∑ 
    have : ‚àÄ·∂† y : ‚Ñù in ùìù x,
        (y : ‚ÑÇ) ^ (r + 1) / (r + 1) = (-y : ‚ÑÇ) ^ (r + 1) * exp (œÄ * I * (r + 1)) / (r + 1) := by
      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_
      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]
    refine HasDerivAt.congr_of_eventuallyEq ?_ this
    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]
    suffices HasDerivAt (fun y : ‚Ñù => (-‚Üëy) ^ (r + 1) * exp (‚ÜëœÄ * I * (r + 1)))
        ((r + 1) * (-‚Üëx) ^ r * exp (‚ÜëœÄ * I * r)) x by
      convert this.div_const (r + 1) using 1
      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right‚ÇÄ _ hr]
    rw [mul_add ((œÄ : ‚ÑÇ) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : ‚ÑÇ) (-1 : ‚ÑÇ),
      neg_one_mul]
    simp_rw [mul_neg, ‚Üê neg_mul, ‚Üê ofReal_neg]
    suffices HasDerivAt (fun y : ‚Ñù => (‚Üë(-y) : ‚ÑÇ) ^ (r + 1)) (-(r + 1) * ‚Üë(-x) ^ r) x by
      convert this.neg.mul_const _ using 1; ring
    suffices HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) (-x) by
      convert @HasDerivAt.scomp ‚Ñù _ ‚ÑÇ _ _ x ‚Ñù _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1
      rw [real_smul, ofReal_neg 1, ofReal_one]; ring
    suffices HasDerivAt (fun y : ‚ÑÇ => y ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) ‚Üë(-x) by
      exact this.comp_ofReal
    conv in ‚Üë_ ^ _ => rw [(by ring : r = r + 1 - 1)]
    convert HasDerivAt.cpow_const ?_ ?_ using 1
    ¬∑ rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm
    ¬∑ exact hasDerivAt_id ((-x : ‚Ñù) : ‚ÑÇ)
    ¬∑ simp [hx]"
Mathlib/MeasureTheory/Group/Convolution.lean,MeasureTheory.Measure.mconv_comm,mconv_comm,0f75c4a28ad42f2fa1265303fe3992358964fd85,":= by
  unfold mconv
  rw [‚Üê prod_swap, map_map (by fun_prop)]
  ¬∑ simp [Function.comp_def, mul_comm]
  fun_prop","error:  `fun_prop` was unable to prove `Measurable Prod.swap`

Try running with discharger `fun_prop (disch:=aesop)` or with a different discharger tactic like `assumption`, `linarith`, `omega`.
Sometimes it is useful to run `fun_prop (disch:=trace_state; sorry)` which will print all the necessary subgoals for `fun_prop` to succeed.

Potential issues to fix:
  No theorems found for `Prod.swap` in order to prove Measurable fun a ‚Ü¶ a.swap
  Failed to synthesize instance TopologicalSpace (M √ó M) when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace (M √ó M) when applying theorem Continuous.measurable.

For more detailed information use `set_option trace.Meta.Tactic.fun_prop true`","theorem mconv_comm {M : Type*} [CommMonoid M] [MeasurableSpace M] [MeasurableMul‚ÇÇ M] (Œº : Measure M)
    (ŒΩ : Measure M) [SFinite Œº] [SFinite ŒΩ] : Œº ‚àó ŒΩ = ŒΩ ‚àó Œº ",":= by
  unfold mconv
  rw [‚Üê prod_swap, map_map]
  ¬∑ simp [Function.comp_def, mul_comm]
  ¬∑ 
    exact Measurable.mul measurable_fst measurable_snd
  measurability"
Mathlib/Algebra/Group/Subgroup/Finite.lean,Subgroup.pi_mem_of_mulSingle_mem_aux,pi_mem_of_mulSingle_mem_aux,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' I with i I hnmem ih generalizing x
  ¬∑ convert one_mem H
    ext i
    exact h1 i (Finset.not_mem_empty i)
  ¬∑ have : x = Function.update x i 1 * Pi.mulSingle i (x i) := by
      ext j
      by_cases heq : j = i
      ¬∑ subst heq
        simp
      ¬∑ simp [heq]
    rw [this]
    clear this
    apply mul_mem
    ¬∑ apply ih <;> clear ih
      ¬∑ intro j hj
        by_cases heq : j = i
        ¬∑ subst heq
          simp
        ¬∑ simp [heq]
          apply h1 j
          simpa [heq] using hj
      ¬∑ intro j hj
        have : j ‚â† i := by
          rintro rfl
          contradiction
        simp only [ne_eq, this, not_false_eq_true, Function.update_noteq]
        exact h2 _ (Finset.mem_insert_of_mem hj)
    ¬∑ apply h2
      simp","error:  application type mismatch
  h1 i (Finset.not_mem_empty i)
argument
  Finset.not_mem_empty i
has type
  i ‚àâ ‚àÖ : Prop
but is expected to have type
  i ‚àâ { val := i‚úù, nodup := I } : Prop
error:  no goals to be solved","theorem pi_mem_of_mulSingle_mem_aux [DecidableEq Œ∑] (I : Finset Œ∑) {H : Subgroup (‚àÄ i, f i)}
    (x : ‚àÄ i, f i) (h1 : ‚àÄ i, i ‚àâ I ‚Üí x i = 1) (h2 : ‚àÄ i, i ‚àà I ‚Üí Pi.mulSingle i (x i) ‚àà H) :
    x ‚àà H ",":= by
  induction' I using Finset.induction_on with i I hnmem ih generalizing x
  ¬∑ convert one_mem H
    ext i
    exact h1 i (Finset.not_mem_empty i)
  ¬∑ have : x = Function.update x i 1 * Pi.mulSingle i (x i) := by
      ext j
      by_cases heq : j = i
      ¬∑ subst heq
        simp
      ¬∑ simp [heq]
    rw [this]
    clear this
    apply mul_mem
    ¬∑ apply ih <;> clear ih
      ¬∑ intro j hj
        by_cases heq : j = i
        ¬∑ subst heq
          simp
        ¬∑ simp [heq]
          apply h1 j
          simpa [heq] using hj
      ¬∑ intro j hj
        have : j ‚â† i := by
          rintro rfl
          contradiction
        simp only [ne_eq, this, not_false_eq_true, Function.update_noteq]
        exact h2 _ (Finset.mem_insert_of_mem hj)
    ¬∑ apply h2
      simp"
Mathlib/CategoryTheory/Preadditive/Yoneda/Projective.lean,CategoryTheory.Projective.projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj',projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj',bad931b7fc9f31f5ff5b8f408dd19bbe20a9f0e1,":= by
  rw [projective_iff_preservesEpimorphisms_coyoneda_obj]
  refine ‚ü®fun h : (preadditiveCoyoneda.obj (op P) ‚ãô
      forget AddCommGroupCat).PreservesEpimorphisms => ?_, ?_‚ü©
  ¬∑ exact Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveCoyoneda.obj (op P))
        (forget _)
  ¬∑ intro
    exact (inferInstance : (preadditiveCoyoneda.obj (op P) ‚ãô forget _).PreservesEpimorphisms)","error:  unknown identifier 'AddCommGroupCat'
error:  failed to synthesize
  (preadditiveCoyoneda.obj { unop := P } ‚ãô forget AddCommGrp).PreservesEpimorphisms
use `set_option diagnostics true` to get diagnostic information
error:  no goals to be solved","theorem projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj' (P : C) :
    Projective P ‚Üî (preadditiveCoyoneda.obj (op P)).PreservesEpimorphisms ",":= by
  rw [projective_iff_preservesEpimorphisms_coyoneda_obj]
  refine ‚ü®fun h : (preadditiveCoyoneda.obj (op P) ‚ãô
      forget AddCommGrp).PreservesEpimorphisms => ?_, ?_‚ü©
  ¬∑ exact Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveCoyoneda.obj (op P))
        (forget _)
  ¬∑ intro
    exact (inferInstance : (preadditiveCoyoneda.obj (op P) ‚ãô forget _).PreservesEpimorphisms)"
Mathlib/Data/Fin/VecNotation.lean,Matrix.vecAlt1_vecAppend,vecAlt1_vecAppend,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  ext i
  simp_rw [Function.comp, vecAlt1, vecAppend_eq_ite]
  cases n with
  | zero =>
    cases' i with i hi
    simp only [Nat.zero_eq, zero_add, Nat.lt_one_iff] at hi; subst i; rfl
  | succ n =>
    split_ifs with h <;> simp_rw [bit1, bit0] <;> congr
    ¬∑ rw [Fin.val_mk] at h
      rw [Nat.mod_eq_of_lt (Nat.lt_of_succ_lt h)]
      erw [Nat.mod_eq_of_lt h]
    ¬∑ rw [Fin.val_mk, not_lt] at h
      simp only [Fin.ext_iff, Fin.val_add, Fin.val_mk, Nat.mod_add_mod, Fin.val_one,
        Nat.mod_eq_sub_mod h, show 1 % (n + 2) = 1 from Nat.mod_eq_of_lt (by omega)]
      refine (Nat.mod_eq_of_lt ?_).symm
      rw [tsub_lt_iff_left h]
      exact Nat.add_succ_lt_add i.2 i.2","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
error:  tactic 'subst' failed, did not find equation for eliminating 'i'
case h.zero.mk
Œ± : Type u
m o : ‚Ñï
m' : Type u_1
n' : Type u_2
o' : Type u_3
v : Fin (0 + 1) ‚Üí Œ±
i : ‚Ñï
hi : i < 0 + 1
‚ä¢ (if h : ‚Üë‚ü®i, hi‚ü© + ‚Üë‚ü®i, hi‚ü© + 1 < 0 + 1 then v ‚ü®‚Üë‚ü®i, hi‚ü© + ‚Üë‚ü®i, hi‚ü© + 1, ‚ãØ‚ü©
    else v ‚ü®‚Üë‚ü®i, hi‚ü© + ‚Üë‚ü®i, hi‚ü© + 1 - (0 + 1), ‚ãØ‚ü©) =
    v (bit1 ‚ü®i, hi‚ü©)
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  unknown identifier 'tsub_lt_iff_left'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.37629
case neg.e_a.e_val
Œ± : Type u
m o : ‚Ñï
m' : Type u_1
n' : Type u_2
o' : Type u_3
n : ‚Ñï
v : Fin (n + 1 + 1) ‚Üí Œ±
i : Fin (n + 1 + 1)
h : n + 1 + 1 ‚â§ ‚Üëi + ‚Üëi + 1
‚ä¢ ‚Üëi + ‚Üëi + 1 - (n + 1 + 1) < n + 1 + 1
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated",theorem vecAlt1_vecAppend (v : Fin (n + 1) ‚Üí Œ±) : vecAlt1 rfl (vecAppend rfl v v) = v ‚àò bit1 ,":= by
  ext i
  simp_rw [Function.comp, vecAlt1, vecAppend_eq_ite]
  cases n with
  | zero =>
    cases' i with i hi
    simp only [Nat.zero_eq, Nat.zero_add, Nat.lt_one_iff] at hi; subst i; rfl
  | succ n =>
    split_ifs with h <;> simp_rw [bit1, bit0] <;> congr
    ¬∑ simp [Nat.mod_eq_of_lt, h]
    ¬∑ rw [Fin.val_mk, not_lt] at h
      simp only [Fin.ext_iff, Fin.val_add, Fin.val_mk, Nat.mod_add_mod, Fin.val_one,
        Nat.mod_eq_sub_mod h, show 1 % (n + 2) = 1 from Nat.mod_eq_of_lt (by omega)]
      refine (Nat.mod_eq_of_lt ?_).symm
      omega"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.card_compression,card_compression,a4eaf1c4445133f9aeb6ffd22d82bd37dc454769,":= by
  rw [compression, card_disjoint_union (compress_disjoint _ _), image_filter, card_image_of_injOn,
    ‚Üê card_disjoint_union]
  simp_rw [Function.comp]
  rw [filter_union_filter_neg_eq]
  ¬∑ rw [disjoint_iff_inter_eq_empty]
    exact filter_inter_filter_neg_eq _ _ _
  intro a ha b hb hab
  dsimp at hab
  rw [mem_coe, mem_filter, Function.comp_apply] at ha hb
  rw [compress] at ha hab
  split_ifs  at ha hab with has
  ¬∑ rw [compress] at hb hab
    split_ifs  at hb hab with hbs
    ¬∑ exact sup_sdiff_injOn u v has hbs hab
    ¬∑ exact (hb.2 hb.1).elim
  ¬∑ exact (ha.2 ha.1).elim","warning:  @UV.compression does not have a doc string
warning:  `Finset.card_disjoint_union` has been deprecated, use `Finset.card_union_of_disjoint` instead
error:  application type mismatch
  card_disjoint_union (compress_disjoint ?m.54484 ?m.54485)
argument
  compress_disjoint ?m.54484 ?m.54485
has type
  ?m.54483 ‚â§ ‚ä• : Prop
but is expected to have type
  Disjoint ?m.54471 ?m.54472 : Prop
warning:  `Finset.image_filter` has been deprecated, use `Finset.filter_image` instead
warning:  `Finset.card_disjoint_union` has been deprecated, use `Finset.card_union_of_disjoint` instead
error:  simp made no progress",theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card ,":= by
  rw [compression, card_union_of_disjoint compress_disjoint, filter_image,
    card_image_of_injOn compress_injOn, ‚Üê card_union_of_disjoint (disjoint_filter_filter_neg s _ _),
    filter_union_filter_neg_eq]"
Mathlib/Analysis/Convex/SpecificFunctions/Pow.lean,Real.strictConcaveOn_rpow,strictConcaveOn_rpow,693fd79515903b10b1d31f10dccfc49e633cf7ee,":= by
  have hp‚ÇÄ' : 0 < 1 / p := by positivity
  have hp‚ÇÅ' : 1 < 1 / p := by rw [one_lt_div hp‚ÇÄ]; exact hp‚ÇÅ
  let f := NNReal.orderIsoRpow (1 / p) hp‚ÇÄ'
  have h‚ÇÅ : StrictConvexOn ‚Ñù‚â•0 univ f := by
    refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
    exact (strictConvexOn_rpow hp‚ÇÅ').2 (by positivity : 0 ‚â§ x) (by positivity : 0 ‚â§ y)
      (by simp [hxy]) ha hb (by simp; norm_cast)
  have h‚ÇÇ : ‚àÄ x, f.symm x = x ^ p := by simp [NNReal.orderIsoRpow_symm_eq]
  refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
  simp only [‚Üêh‚ÇÇ]
  exact (f.strictConcaveOn_symm h‚ÇÅ).2 (Set.mem_univ x) (Set.mem_univ y) hxy ha hb hab",error:  simp made no progress,"lemma strictConcaveOn_rpow {p : ‚Ñù} (hp‚ÇÄ : 0 < p) (hp‚ÇÅ : p < 1) :
    StrictConcaveOn ‚Ñù‚â•0 univ fun x : ‚Ñù‚â•0 ‚Ü¶ x ^ p ",":= by
  have hp‚ÇÄ' : 0 < 1 / p := div_pos zero_lt_one hp‚ÇÄ
  have hp‚ÇÅ' : 1 < 1 / p := by rw [one_lt_div hp‚ÇÄ]; exact hp‚ÇÅ
  let f := NNReal.orderIsoRpow (1 / p) hp‚ÇÄ'
  have h‚ÇÅ : StrictConvexOn ‚Ñù‚â•0 univ f := by
    refine ‚ü®convex_univ, fun x _ y _ hxy a b ha hb hab => ?_‚ü©
    exact (strictConvexOn_rpow hp‚ÇÅ').2 x.2 y.2 (by simp [hxy]) ha hb (by simp; norm_cast)
  have h‚ÇÇ : ‚àÄ x, f.symm x = x ^ p := by simp [f, NNReal.orderIsoRpow_symm_eq]
  refine ‚ü®convex_univ, fun x mx y my hxy a b ha hb hab => ?_‚ü©
  simp only [‚Üê h‚ÇÇ]
  exact (f.strictConcaveOn_symm h‚ÇÅ).2 mx my hxy ha hb hab"
Mathlib/MeasureTheory/Measure/Haar/Basic.lean,MeasureTheory.Measure.div_mem_nhds_one_of_haar_pos,div_mem_nhds_one_of_haar_pos,1d7e2a559e02dc40ee919af2807dd28c060acf5b,":= by
  obtain ‚ü®K, hKE, hK, K_closed, hKpos‚ü© :
      ‚àÉ (K : Set G), K ‚äÜ E ‚àß IsCompact K ‚àß IsClosed K ‚àß 0 < Œº K := by
    rcases MeasurableSet.exists_lt_isCompact hE hEpos with ‚ü®K, KE, K_comp, K_meas‚ü©
    refine ‚ü®closure K, ?_, K_comp.closure, isClosed_closure, ?_‚ü©
    ¬∑ exact K_comp.closure_subset_measurableSet hE KE
    ¬∑ rwa [K_comp.measure_closure_eq_of_group]
  obtain ‚ü®V, hV1, hV‚ü© : ‚àÉ V ‚àà ùìù (1 : G), ‚àÄ g ‚àà V, Œº (g ‚Ä¢ K \ K) < Œº K :=
    exists_nhds_measure_smul_diff_lt hK K_closed hKpos.ne'
  have hv : ‚àÄ v : G, v ‚àà V ‚Üí ¬¨Disjoint (v ‚Ä¢ K) K := by
    intro v hv hKv
    have Z := hV v hv
    rw [hKv.symm.sdiff_eq_right, measure_smul] at Z
    exact lt_irrefl _ Z
  suffices V ‚äÜ E / E from Filter.mem_of_superset hV1 this
  intro v hvV
  obtain ‚ü®x, hxK, hxvK‚ü© : ‚àÉ x : G, x ‚àà v ‚Ä¢ K ‚àß x ‚àà K := Set.not_disjoint_iff.1 (hv v hvV)
  refine ‚ü®x, hKE hxvK, v‚Åª¬π * x, hKE ?_, ?_‚ü©
  ¬∑ simpa [mem_smul_set_iff_inv_smul_mem] using hxK
  ¬∑ simp only [div_eq_iff_eq_mul, ‚Üê mul_assoc, mul_right_inv, one_mul]","warning:  `IsCompact.measure_closure_eq_of_group` has been deprecated, use `IsCompact.measure_closure` instead
error:  unknown identifier 'exists_nhds_measure_smul_diff_lt'","theorem div_mem_nhds_one_of_haar_pos (Œº : Measure G) [IsHaarMeasure Œº] [LocallyCompactSpace G]
    [InnerRegular Œº] (E : Set G) (hE : MeasurableSet E) (hEpos : 0 < Œº E) :
    E / E ‚àà ùìù (1 : G) ",":= by
  obtain ‚ü®K, hKE, hK, K_closed, hKpos‚ü© :
      ‚àÉ (K : Set G), K ‚äÜ E ‚àß IsCompact K ‚àß IsClosed K ‚àß 0 < Œº K := by
    rcases MeasurableSet.exists_lt_isCompact hE hEpos with ‚ü®K, KE, K_comp, K_meas‚ü©
    refine ‚ü®closure K, ?_, K_comp.closure, isClosed_closure, ?_‚ü©
    ¬∑ exact K_comp.closure_subset_measurableSet hE KE
    ¬∑ rwa [K_comp.measure_closure]
  filter_upwards [eventually_nhds_one_measure_smul_diff_lt hK K_closed hKpos.ne' (Œº := Œº)] with g hg
  have : ¬¨Disjoint (g ‚Ä¢ K) K := fun hd ‚Ü¶ by
    rw [hd.symm.sdiff_eq_right, measure_smul] at hg
    exact hg.false
  rcases Set.not_disjoint_iff.1 this with ‚ü®_, ‚ü®x, hxK, rfl‚ü©, hgxK‚ü©
  simpa using div_mem_div (hKE hgxK) (hKE hxK)"
Mathlib/Analysis/Analytic/IsolatedZeros.lean,AnalyticAt.unique_eventuallyEq_pow_smul_nonzero,unique_eventuallyEq_pow_smul_nonzero,26dcb0a78bda63252389cd8290cafcd2d953c437,":= by
  wlog h_le : n ‚â§ m generalizing m n
  ¬∑ exact ((this hn hm) (not_le.mp h_le).le).symm
  let ‚ü®g, hg_an, _, hg_eq‚ü© := hm
  let ‚ü®j, hj_an, hj_ne, hj_eq‚ü© := hn
  contrapose! hj_ne
  have : ‚àÉ·∂† z in ùìù[‚â†] z‚ÇÄ, j z = (z - z‚ÇÄ) ^ (m - n) ‚Ä¢ g z
  ¬∑ refine (eventually_nhdsWithin_iff.mpr ?_).frequently
    filter_upwards [hg_eq, hj_eq] with z hfz hfz' hz
    rwa [‚Üê Nat.add_sub_cancel' h_le, pow_add, mul_smul, hfz', smul_right_inj] at hfz
    exact pow_ne_zero _ <| sub_ne_zero.mpr hz
  rw [frequently_eq_iff_eventually_eq hj_an] at this
  rw [EventuallyEq.eq_of_nhds this, sub_self, zero_pow, zero_smul]
  ¬∑ apply Nat.sub_ne_zero_of_lt (h_le.lt_of_ne' hj_ne)
  ¬∑ exact (((analyticAt_id ùïú _).sub analyticAt_const).pow _).smul hg_an","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
s : E
p q : FormalMultilinearSeries ùïú ùïú E
f g‚úù : ùïú ‚Üí E
n‚úù : ‚Ñï
z z‚ÇÄ : ùïú
m n : ‚Ñï
hm : ‚àÉ g, AnalyticAt ùïú g z‚ÇÄ ‚àß g z‚ÇÄ ‚â† 0 ‚àß ‚àÄ·∂† (z : ùïú) in ùìù z‚ÇÄ, f z = (z - z‚ÇÄ) ^ m ‚Ä¢ g z
hn : ‚àÉ g, AnalyticAt ùïú g z‚ÇÄ ‚àß g z‚ÇÄ ‚â† 0 ‚àß ‚àÄ·∂† (z : ùïú) in ùìù z‚ÇÄ, f z = (z - z‚ÇÄ) ^ n ‚Ä¢ g z
h_le : n ‚â§ m
g : ùïú ‚Üí E
hg_an : AnalyticAt ùïú g z‚ÇÄ
left‚úù : g z‚ÇÄ ‚â† 0
hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù z‚ÇÄ, f z = (z - z‚ÇÄ) ^ m ‚Ä¢ g z
j : ùïú ‚Üí E
hj_an : AnalyticAt ùïú j z‚ÇÄ
hj_eq : ‚àÄ·∂† (z : ùïú) in ùìù z‚ÇÄ, f z = (z - z‚ÇÄ) ^ n ‚Ä¢ j z
hj_ne : m ‚â† n
this : ‚àÉ·∂† (z : ùïú) in ùìù[‚â†] z‚ÇÄ, j z = (z - z‚ÇÄ) ^ (m - n) ‚Ä¢ g z
‚ä¢ j z‚ÇÄ = 0","lemma unique_eventuallyEq_pow_smul_nonzero {m n : ‚Ñï}
    (hm : ‚àÉ g, AnalyticAt ùïú g z‚ÇÄ ‚àß g z‚ÇÄ ‚â† 0 ‚àß ‚àÄ·∂† z in ùìù z‚ÇÄ, f z = (z - z‚ÇÄ) ^ m ‚Ä¢ g z)
    (hn : ‚àÉ g, AnalyticAt ùïú g z‚ÇÄ ‚àß g z‚ÇÄ ‚â† 0 ‚àß ‚àÄ·∂† z in ùìù z‚ÇÄ, f z = (z - z‚ÇÄ) ^ n ‚Ä¢ g z) :
    m = n ",":= by
  simp_rw [‚Üê zpow_natCast] at hm hn
  exact Int.ofNat_inj.mp <| unique_eventuallyEq_zpow_smul_nonzero
    (let ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := hm; ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ.filter_mono nhdsWithin_le_nhds‚ü©)
    (let ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := hn; ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ.filter_mono nhdsWithin_le_nhds‚ü©)"
Mathlib/Order/JordanHolder.lean,CompositionSeries.ext,ext,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  cases s‚ÇÅ; cases s‚ÇÇ
  dsimp at hl h
  subst hl
  simpa [Function.funext_iff] using h",error:  unknown identifier 'hl',"theorem ext {s‚ÇÅ s‚ÇÇ : CompositionSeries X} (h : ‚àÄ x, x ‚àà s‚ÇÅ ‚Üî x ‚àà s‚ÇÇ) : s‚ÇÅ = s‚ÇÇ ",":=
  toList_injective <|
    List.eq_of_perm_of_sorted
      (by
        classical
        exact List.perm_of_nodup_nodup_toFinset_eq s‚ÇÅ.toList_nodup s‚ÇÇ.toList_nodup
          (Finset.ext <| by simpa only [List.mem_toFinset, RelSeries.mem_toList]))
      s‚ÇÅ.toList_sorted s‚ÇÇ.toList_sorted"
Mathlib/ModelTheory/Skolem.lean,FirstOrder.Language.exists_elementarySubstructure_card_eq,exists_elementarySubstructure_card_eq,65f7857d510e130142dbb111786341d695ac399b,":= by
  obtain ‚ü®s', hs'‚ü© := Cardinal.le_mk_iff_exists_set.1 h4
  rw [‚Üê aleph0_le_lift.{_, w}] at h1
  rw [‚Üê hs'] at h1 h2 ‚ä¢
  refine'
    ‚ü®elementarySkolem‚ÇÅReduct (closure (L.sum L.skolem‚ÇÅ) (s ‚à™ Equiv.ulift '' s')),
      (s.subset_union_left _).trans subset_closure, _‚ü©
  have h := mk_image_eq_lift _ s' Equiv.ulift.injective
  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h
  rw [coeSort_elementarySkolem‚ÇÅReduct, ‚Üê h, lift_inj]
  refine'
    le_antisymm (lift_le.1 (lift_card_closure_le.trans _))
      (mk_le_mk_of_subset ((Set.subset_union_right _ _).trans subset_closure))
  rw [max_le_iff, aleph0_le_lift, ‚Üê aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]
  refine' ‚ü®h1, (mk_union_le _ _).trans _, (lift_le.2 card_functions_sum_skolem‚ÇÅ_le).trans _‚ü©
  ¬∑ rw [‚Üê lift_le, lift_add, h, add_comm, add_eq_max h1]
    exact max_le le_rfl h2
  ¬∑ rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, ‚Üê lift_le.{w'},
      lift_lift, lift_lift, ‚Üê aleph0_le_lift, h]
    refine ‚ü®?_, h1‚ü©
    rw [‚Üê lift_lift.{w', w}]
    refine' _root_.trans (lift_le.{w}.2 h3) _
    rw [lift_lift, ‚Üê lift_lift.{w, max u v}, ‚Üê hs', ‚Üê h, lift_lift]
  ¬∑ refine' _root_.trans _ (lift_le.2 (mk_le_mk_of_subset (Set.subset_union_right _ _)))
    rw [aleph0_le_lift, ‚Üê aleph0_le_lift, h]
    exact h1","error:  invalid field 'trans', the environment does not contain 'Membership.mem.trans'
  Set.subset_union_left ?m.26890
has type
  ?m.26889 ‚àà s ‚à™ ?m.26888
error:  invalid field 'trans', the environment does not contain 'Set.Mem.trans'
  Set.subset_union_left ?m.26890
has type
  Set.Mem ?m.26889 (s ‚à™ ?m.26888)
error:  invalid field 'trans', the environment does not contain 'Union.union.trans'
  Set.subset_union_left ?m.26890
has type
  (s ‚à™ ?m.26888) ?m.26889
error:  invalid field 'trans', the environment does not contain 'Set.union.trans'
  Set.subset_union_left ?m.26890
has type
  s.union ?m.26888 ?m.26889
error:  invalid field 'trans', the environment does not contain 'setOf.trans'
  Set.subset_union_left ?m.26890
has type
  {a | a ‚àà s ‚à® a ‚àà ?m.26888} ?m.26889
error:  invalid field 'trans', the environment does not contain 'Or.trans'
  Set.subset_union_left ?m.26890
has type
  ?m.26889 ‚àà s ‚à® ?m.26889 ‚àà ?m.26888
error:  function expected at
  Set.subset_union_right ?m.27688
term has type
  ?m.27687 ‚àà ?m.27685 ‚à™ ?m.27686
error:  function expected at
  Set.subset_union_right ?m.29978
term has type
  ?m.29977 ‚àà ?m.29975 ‚à™ ?m.29976","theorem exists_elementarySubstructure_card_eq (s : Set M) (Œ∫ : Cardinal.{w'}) (h1 : ‚Ñµ‚ÇÄ ‚â§ Œ∫)
    (h2 : Cardinal.lift.{w'} #s ‚â§ Cardinal.lift.{w} Œ∫)
    (h3 : Cardinal.lift.{w'} L.card ‚â§ Cardinal.lift.{max u v} Œ∫)
    (h4 : Cardinal.lift.{w} Œ∫ ‚â§ Cardinal.lift.{w'} #M) :
    ‚àÉ S : L.ElementarySubstructure M, s ‚äÜ S ‚àß Cardinal.lift.{w'} #S = Cardinal.lift.{w} Œ∫ ",":= by
  obtain ‚ü®s', hs'‚ü© := Cardinal.le_mk_iff_exists_set.1 h4
  rw [‚Üê aleph0_le_lift.{_, w}] at h1
  rw [‚Üê hs'] at h1 h2 ‚ä¢
  refine
    ‚ü®elementarySkolem‚ÇÅReduct (closure (L.sum L.skolem‚ÇÅ) (s ‚à™ Equiv.ulift '' s')),
      (s.subset_union_left).trans subset_closure, ?_‚ü©
  have h := mk_image_eq_lift _ s' Equiv.ulift.injective
  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h
  rw [coeSort_elementarySkolem‚ÇÅReduct, ‚Üê h, lift_inj]
  refine
    le_antisymm (lift_le.1 (lift_card_closure_le.trans ?_))
      (mk_le_mk_of_subset ((s.subset_union_right).trans subset_closure))
  rw [max_le_iff, aleph0_le_lift, ‚Üê aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]
  ¬∑ refine ‚ü®h1, (mk_union_le _ _).trans ?_, (lift_le.2 card_functions_sum_skolem‚ÇÅ_le).trans ?_‚ü©
    ¬∑ rw [‚Üê lift_le, lift_add, h, add_comm, add_eq_max h1]
      exact max_le le_rfl h2
    ¬∑ rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, ‚Üê lift_le.{w'},
        lift_lift, lift_lift, ‚Üê aleph0_le_lift, h]
      refine ‚ü®?_, h1‚ü©
      rw [‚Üê lift_lift.{w', w}]
      refine _root_.trans (lift_le.{w}.2 h3) ?_
      rw [lift_lift, ‚Üê lift_lift.{w, max u v}, ‚Üê hs', ‚Üê h, lift_lift]
  ¬∑ refine _root_.trans ?_ (lift_le.2 (mk_le_mk_of_subset Set.subset_union_right))
    rw [aleph0_le_lift, ‚Üê aleph0_le_lift, h]
    exact h1"
Mathlib/Topology/Sober.lean,quasiSober_of_open_cover,quasiSober_of_open_cover,5192777c94aec06289e492ce206d68fbbe72572c,":= by
  rw [quasiSober_iff]
  intro t h h'
  obtain ‚ü®x, hx‚ü© := h.1
  obtain ‚ü®U, hU, hU'‚ü© : x ‚àà ‚ãÉ‚ÇÄ S := by
    rw [hS'']
    trivial
  haveI : QuasiSober U := hS' ‚ü®U, hU‚ü©
  have H : IsPreirreducible ((‚Üë) ‚Åª¬π' t : Set U) :=
    h.2.preimage (hS ‚ü®U, hU‚ü©).openEmbedding_subtype_val
  replace H : IsIrreducible ((‚Üë) ‚Åª¬π' t : Set U) := ‚ü®‚ü®‚ü®x, hU'‚ü©, by simpa using hx‚ü©, H‚ü©
  use H.genericPoint
  have := continuous_subtype_val.closure_preimage_subset _ H.genericPoint_spec.mem
  rw [h'.closure_eq] at this
  apply le_antisymm
  ¬∑ apply h'.closure_subset_iff.mpr
    simpa using this
  rw [‚Üê image_singleton, ‚Üê closure_image_closure continuous_subtype_val, H.genericPoint_spec.def]
  refine' (subset_closure_inter_of_isPreirreducible_of_isOpen h.2 (hS ‚ü®U, hU‚ü©) ‚ü®x, hx, hU'‚ü©).trans
    (closure_mono _)
  rw [‚Üê Subtype.image_preimage_coe]
  exact Set.image_subset _ subset_closure","error:  typeclass instance problem is stuck, it is often due to metavariables
  TopologicalSpace ?m.16911","theorem quasiSober_of_open_cover (S : Set (Set Œ±)) (hS : ‚àÄ s : S, IsOpen (s : Set Œ±))
    [hS' : ‚àÄ s : S, QuasiSober s] (hS'' : ‚ãÉ‚ÇÄ S = ‚ä§) : QuasiSober Œ± ",":= by
  rw [quasiSober_iff]
  intro t h h'
  obtain ‚ü®x, hx‚ü© := h.1
  obtain ‚ü®U, hU, hU'‚ü© : x ‚àà ‚ãÉ‚ÇÄ S := by
    rw [hS'']
    trivial
  haveI : QuasiSober U := hS' ‚ü®U, hU‚ü©
  have H : IsPreirreducible ((‚Üë) ‚Åª¬π' t : Set U) :=
    h.2.preimage (hS ‚ü®U, hU‚ü©).openEmbedding_subtype_val
  replace H : IsIrreducible ((‚Üë) ‚Åª¬π' t : Set U) := ‚ü®‚ü®‚ü®x, hU'‚ü©, by simpa using hx‚ü©, H‚ü©
  use H.genericPoint
  have := continuous_subtype_val.closure_preimage_subset _ H.genericPoint_spec.mem
  rw [h'.closure_eq] at this
  apply le_antisymm
  ¬∑ apply h'.closure_subset_iff.mpr
    simpa using this
  rw [‚Üê image_singleton, ‚Üê closure_image_closure continuous_subtype_val, H.genericPoint_spec.def]
  refine (subset_closure_inter_of_isPreirreducible_of_isOpen h.2 (hS ‚ü®U, hU‚ü©) ‚ü®x, hx, hU'‚ü©).trans
    (closure_mono ?_)
  rw [inter_comm t, ‚Üê Subtype.image_preimage_coe]
  exact Set.image_subset _ subset_closure"
Mathlib/Data/Finset/Lattice.lean,Finset.sup_le_of_le_directed,sup_le_of_le_directed,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
    induction' t with a r _ ih h
    ¬∑ simpa only [forall_prop_of_true, and_true_iff, forall_prop_of_false, bot_le, not_false_iff,
        sup_empty, forall_true_iff, not_mem_empty]
    ¬∑ intro h
      have incs : (r : Set Œ±) ‚äÜ ‚Üë(insert a r) := by
        rw [Finset.coe_subset]
        apply Finset.subset_insert
      obtain ‚ü®x, ‚ü®hxs, hsx_sup‚ü©‚ü© := ih fun x hx => h x <| incs hx
      obtain ‚ü®y, hys, hay‚ü© := h a (Finset.mem_insert_self a r)
      obtain ‚ü®z, hzs, ‚ü®hxz, hyz‚ü©‚ü© := hdir x hxs y hys
      use z, hzs
      rw [sup_insert, id, sup_le_iff]
      exact ‚ü®le_trans hay hyz, le_trans hsx_sup hxz‚ü©","error:  tactic 'assumption' failed
case mk
F : Type u_1
Œ±‚úù : Type u_2
Œ≤ : Type u_3
Œ≥ : Type u_4
Œπ : Type u_5
Œ∫ : Type u_6
inst‚úù¬≥ : SemilatticeSup Œ±‚úù
inst‚úù¬≤ : OrderBot Œ±‚úù
s‚úù s‚ÇÅ s‚ÇÇ : Finset Œ≤
f g : Œ≤ ‚Üí Œ±‚úù
a‚úù : Œ±‚úù
Œ± : Type u_7
inst‚úù¬π : SemilatticeSup Œ±
inst‚úù : OrderBot Œ±
s : Set Œ±
hs : s.Nonempty
hdir : DirectedOn (fun x x_1 ‚Ü¶ x ‚â§ x_1) s
a : Multiset Œ±
r : a.Nodup
‚ä¢ (‚àÄ x ‚àà { val := a, nodup := r }, ‚àÉ y ‚àà s, x ‚â§ y) ‚Üí ‚àÉ x ‚àà s, { val := a, nodup := r }.sup id ‚â§ x
error:  no goals to be solved","theorem sup_le_of_le_directed {Œ± : Type*} [SemilatticeSup Œ±] [OrderBot Œ±] (s : Set Œ±)
    (hs : s.Nonempty) (hdir : DirectedOn (¬∑ ‚â§ ¬∑) s) (t : Finset Œ±) :
    (‚àÄ x ‚àà t, ‚àÉ y ‚àà s, x ‚â§ y) ‚Üí ‚àÉ x ‚àà s, t.sup id ‚â§ x ",":= by
  classical
    induction' t using Finset.induction_on with a r _ ih h
    ¬∑ simpa only [forall_prop_of_true, and_true_iff, forall_prop_of_false, bot_le, not_false_iff,
        sup_empty, forall_true_iff, not_mem_empty]
    ¬∑ intro h
      have incs : (r : Set Œ±) ‚äÜ ‚Üë(insert a r) := by
        rw [Finset.coe_subset]
        apply Finset.subset_insert
      obtain ‚ü®x, ‚ü®hxs, hsx_sup‚ü©‚ü© := ih fun x hx => h x <| incs hx
      obtain ‚ü®y, hys, hay‚ü© := h a (Finset.mem_insert_self a r)
      obtain ‚ü®z, hzs, ‚ü®hxz, hyz‚ü©‚ü© := hdir x hxs y hys
      use z, hzs
      rw [sup_insert, id, sup_le_iff]
      exact ‚ü®le_trans hay hyz, le_trans hsx_sup hxz‚ü©"
Mathlib/MeasureTheory/Integral/Bochner.lean,MeasureTheory.L1.SimpleFunc.integral_eq_norm_posPart_sub,integral_eq_norm_posPart_sub,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have ae_eq‚ÇÅ : (toSimpleFunc f).posPart =·µê[Œº] (toSimpleFunc (posPart f)).map norm := by
    filter_upwards [posPart_toSimpleFunc f] with _ h
    rw [SimpleFunc.map_apply, h]
    conv_lhs => rw [‚Üê SimpleFunc.posPart_map_norm, SimpleFunc.map_apply]
  have ae_eq‚ÇÇ : (toSimpleFunc f).negPart =·µê[Œº] (toSimpleFunc (negPart f)).map norm := by
    filter_upwards [negPart_toSimpleFunc f] with _ h
    rw [SimpleFunc.map_apply, h]
    conv_lhs => rw [‚Üê SimpleFunc.negPart_map_norm, SimpleFunc.map_apply]
  rw [integral, norm_eq_integral, norm_eq_integral, ‚Üê SimpleFunc.integral_sub]
  ¬∑ show (toSimpleFunc f).integral Œº =
      ((toSimpleFunc (posPart f)).map norm - (toSimpleFunc (negPart f)).map norm).integral Œº
    apply MeasureTheory.SimpleFunc.integral_congr (SimpleFunc.integrable f)
    filter_upwards [ae_eq‚ÇÅ, ae_eq‚ÇÇ] with _ h‚ÇÅ h‚ÇÇ
    show _ = _ - _
    rw [‚Üê h‚ÇÅ, ‚Üê h‚ÇÇ]
    have := (toSimpleFunc f).posPart_sub_negPart
    conv_lhs => rw [‚Üê this]
  ¬∑ exact (SimpleFunc.integrable f).pos_part.congr ae_eq‚ÇÅ
  ¬∑ exact (SimpleFunc.integrable f).neg_part.congr ae_eq‚ÇÇ","error:  unsolved goals
case h
Œ± : Type u_1
E : Type u_2
F : Type u_3
ùïú : Type u_4
inst‚úù¬π‚Å∞ : NormedAddCommGroup E
inst‚úù‚Åπ : NormedAddCommGroup F
m : MeasurableSpace Œ±
Œº : Measure Œ±
inst‚úù‚Å∏ : NormedField ùïú
inst‚úù‚Å∑ : NormedSpace ùïú E
inst‚úù‚Å∂ : NormedSpace ‚Ñù E
inst‚úù‚Åµ : SMulCommClass ‚Ñù ùïú E
F' : Type u_5
inst‚úù‚Å¥ : NormedAddCommGroup F'
inst‚úù¬≥ : NormedSpace ‚Ñù F'
E' : Type u_6
inst‚úù¬≤ : NormedAddCommGroup E'
inst‚úù¬π : NormedSpace ‚Ñù E'
inst‚úù : NormedSpace ùïú E'
f : ‚Ü•(simpleFunc ‚Ñù 1 Œº)
ae_eq‚ÇÅ : ‚Üë(toSimpleFunc f).posPart =·∂†[ae Œº] ‚Üë(SimpleFunc.map norm (toSimpleFunc (posPart f)))
ae_eq‚ÇÇ : ‚Üë(toSimpleFunc f).negPart =·∂†[ae Œº] ‚Üë(SimpleFunc.map norm (toSimpleFunc (negPart f)))
a‚úù : Œ±
h‚ÇÅ : ‚Üë(toSimpleFunc f).posPart a‚úù = ‚Üë(SimpleFunc.map norm (toSimpleFunc (posPart f))) a‚úù
h‚ÇÇ : ‚Üë(toSimpleFunc f).negPart a‚úù = ‚Üë(SimpleFunc.map norm (toSimpleFunc (negPart f))) a‚úù
this : (toSimpleFunc f).posPart - (toSimpleFunc f).negPart = toSimpleFunc f
‚ä¢ ‚Üë((toSimpleFunc f).posPart - (toSimpleFunc f).negPart) a‚úù =
    ‚Üë(toSimpleFunc f).posPart a‚úù - ‚Üë(toSimpleFunc f).negPart a‚úù
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string",theorem integral_eq_norm_posPart_sub (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) : integral f = ‚ÄñposPart f‚Äñ - ‚ÄñnegPart f‚Äñ ,":= by
  have ae_eq‚ÇÅ : (toSimpleFunc f).posPart =·µê[Œº] (toSimpleFunc (posPart f)).map norm := by
    filter_upwards [posPart_toSimpleFunc f] with _ h
    rw [SimpleFunc.map_apply, h]
    conv_lhs => rw [‚Üê SimpleFunc.posPart_map_norm, SimpleFunc.map_apply]
  have ae_eq‚ÇÇ : (toSimpleFunc f).negPart =·µê[Œº] (toSimpleFunc (negPart f)).map norm := by
    filter_upwards [negPart_toSimpleFunc f] with _ h
    rw [SimpleFunc.map_apply, h]
    conv_lhs => rw [‚Üê SimpleFunc.negPart_map_norm, SimpleFunc.map_apply]
  rw [integral, norm_eq_integral, norm_eq_integral, ‚Üê SimpleFunc.integral_sub]
  ¬∑ show (toSimpleFunc f).integral Œº =
      ((toSimpleFunc (posPart f)).map norm - (toSimpleFunc (negPart f)).map norm).integral Œº
    apply MeasureTheory.SimpleFunc.integral_congr (SimpleFunc.integrable f)
    filter_upwards [ae_eq‚ÇÅ, ae_eq‚ÇÇ] with _ h‚ÇÅ h‚ÇÇ
    show _ = _ - _
    rw [‚Üê h‚ÇÅ, ‚Üê h‚ÇÇ]
    have := (toSimpleFunc f).posPart_sub_negPart
    conv_lhs => rw [‚Üê this]
    rfl
  ¬∑ exact (SimpleFunc.integrable f).pos_part.congr ae_eq‚ÇÅ
  ¬∑ exact (SimpleFunc.integrable f).neg_part.congr ae_eq‚ÇÇ"
Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean,Matrix.SpecialLinearGroup.mem_center_iff,mem_center_iff,ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  rcases isEmpty_or_nonempty n with hn | ‚ü®‚ü®i‚ü©‚ü©; ¬∑ exact ‚ü®by aesop, by simp [Subsingleton.elim A 1]‚ü©
  refine ‚ü®fun h ‚Ü¶ ‚ü®A i i, ?_, ?_‚ü©, fun ‚ü®r, _, hr‚ü© ‚Ü¶ mem_center_iff.mpr fun B ‚Ü¶ ?_‚ü©
  ¬∑ have : det ((scalar n) (A i i)) = 1 := (scalar_eq_self_of_mem_center h i).symm ‚ñ∏ A.property
    simpa using this
  ¬∑ exact scalar_eq_self_of_mem_center h i
  ¬∑ suffices ‚Üë‚Çò(B * A) = ‚Üë‚Çò(A * B) from Subtype.val_injective this
    simpa only [coe_mul, ‚Üê hr] using (scalar_commute (n := n) r (Commute.all r) B).symm","warning:  SpecialLinearGroup does not have a doc string
warning:  @transpose does not have a doc string
error:  application type mismatch
  mem_center_iff.mpr fun B ‚Ü¶ ?m.106560 B
argument
  fun B ‚Ü¶ ?m.106560 B
has type
  (B : ?m.106554) ‚Üí ?m.106559 B : Sort (imax ?u.106553 ?u.106556)
but is expected to have type
  ‚àÉ r, r ^ Fintype.card n = 1 ‚àß (scalar n) r = ‚ÜëA : Prop
error:  no goals to be solved
error:  fail to show termination for
  Matrix.SpecialLinearGroup.mem_center_iff
with errors
structural recursion cannot be used:

argument #1 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #2 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #3 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #4 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #5 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #6 cannot be used for structural recursion
  it is unchanged in the recursive calls

well-founded recursion cannot be used, 'Matrix.SpecialLinearGroup.mem_center_iff' does not take any (non-fixed) arguments","theorem mem_center_iff {A : SpecialLinearGroup n R} :
    A ‚àà center (SpecialLinearGroup n R) ‚Üî ‚àÉ (r : R), r ^ (Fintype.card n) = 1 ‚àß scalar n r = A ",":= by
  rcases isEmpty_or_nonempty n with hn | ‚ü®‚ü®i‚ü©‚ü©; ¬∑ exact ‚ü®by aesop, by simp [Subsingleton.elim A 1]‚ü©
  refine ‚ü®fun h ‚Ü¶ ‚ü®A i i, ?_, ?_‚ü©, fun ‚ü®r, _, hr‚ü© ‚Ü¶ Subgroup.mem_center_iff.mpr fun B ‚Ü¶ ?_‚ü©
  ¬∑ have : det ((scalar n) (A i i)) = 1 := (scalar_eq_self_of_mem_center h i).symm ‚ñ∏ A.property
    simpa using this
  ¬∑ exact scalar_eq_self_of_mem_center h i
  ¬∑ suffices ‚Üë‚Çò(B * A) = ‚Üë‚Çò(A * B) from Subtype.val_injective this
    simpa only [coe_mul, ‚Üê hr] using (scalar_commute (n := n) r (Commute.all r) B).symm"
Mathlib/Analysis/Convex/Combination.lean,Set.Finite.convexHull_eq_image,Set.Finite.convexHull_eq_image,2c616cf6d72eab2cc0cb8be21b40be572f4b56bf,":= by
  rw [‚Üê @convexHull_basis_eq_stdSimplex _ _ _ hs.fintype, ‚Üê LinearMap.convexHull_image,
    ‚Üê Set.range_comp]
  simp_rw [Function.comp_def]
  apply congr_arg
  convert Subtype.range_coe.symm
  simp [LinearMap.sum_apply, ite_smul _ (1 : R), Finset.filter_eq,
    @Finset.mem_univ _ hs.fintype _]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.568559 ‚Üí+* ?m.568560) ‚Üí
    (M : Type ?u.568556) ‚Üí
      (M‚ÇÇ : Type ?u.568555) ‚Üí
        [inst : AddCommMonoid M] ‚Üí
          [inst_1 : AddCommMonoid M‚ÇÇ] ‚Üí
            [inst : Module ?m.568559 M] ‚Üí [inst : Module ?m.568560 M‚ÇÇ] ‚Üí Type (max ?u.568556 ?u.568555)
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.568628
R : Type u_1
R' : Type u_2
E : Type u_3
F : Type u_4
Œπ : Type u_5
Œπ' : Type u_6
Œ± : Type u_7
inst‚úù‚Åπ : LinearOrderedField R
inst‚úù‚Å∏ : LinearOrderedField R'
inst‚úù‚Å∑ : AddCommGroup E
inst‚úù‚Å∂ : AddCommGroup F
inst‚úù‚Åµ : LinearOrderedAddCommGroup Œ±
inst‚úù‚Å¥ : Module R E
inst‚úù¬≥ : Module R F
inst‚úù¬≤ : Module R Œ±
inst‚úù¬π : OrderedSMul R Œ±
s‚úù : Set E
i j : Œπ
c : R
t : Finset Œπ
w : Œπ ‚Üí R
z : Œπ ‚Üí E
inst‚úù : Fintype Œπ
f : Œπ ‚Üí R
s : Set E
hs : s.Finite
‚ä¢ (convexHull R) s =
    ‚áë(‚àë x : ‚Üës, (LinearMap.proj x).smulRight ‚Üëx) '' (convexHull R) (range fun i j ‚Ü¶ if i = j then 1 else 0)","theorem Set.Finite.convexHull_eq_image {s : Set E} (hs : s.Finite) : convexHull R s =
    haveI := hs.fintype
    (‚áë(‚àë x : s, (@LinearMap.proj R s _ (fun _ => R) _ _ x).smulRight x.1)) '' stdSimplex R s ",":= by
  letI := hs.fintype
  rw [‚Üê convexHull_basis_eq_stdSimplex, LinearMap.image_convexHull, ‚Üê Set.range_comp]
  apply congr_arg
  simp_rw [Function.comp]
  convert Subtype.range_coe.symm
  simp [LinearMap.sum_apply, ite_smul, Finset.filter_eq, Finset.mem_univ]"
Mathlib/Data/List/Cycle.lean,List.prev_next,prev_next,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain ‚ü®n, hn, rfl‚ü© := nthLe_of_mem hx
  simp only [next_nthLe, prev_nthLe, h, Nat.mod_add_mod]
  cases' l with hd tl
  ¬∑ simp at hx
  ¬∑ have : (n + 1 + length tl) % (length tl + 1) = n := by
      rw [length_cons] at hn
      rw [add_assoc, add_comm 1, Nat.add_mod_right, Nat.mod_eq_of_lt hn]
    simp only [length_cons, Nat.succ_sub_succ_eq_sub, tsub_zero, Nat.succ_eq_add_one, this]","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
error:  unsolved goals
case intro.intro.cons
Œ± : Type u_1
inst‚úù : DecidableEq Œ±
l : List Œ±
x : Œ±
n : ‚Ñï
hd : Œ±
tl : List Œ±
h : (hd :: tl).Nodup
hn : n < (hd :: tl).length
hx : (hd :: tl).nthLe n hn ‚àà hd :: tl
this : (n + 1 + tl.length) % (tl.length + 1) = n
‚ä¢ (hd :: tl).nthLe ((n + 1 + (tl.length - 0)) % (tl.length + 1)) ‚ãØ = (hd :: tl).nthLe n hn
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead","theorem prev_next (l : List Œ±) (h : Nodup l) (x : Œ±) (hx : x ‚àà l) :
    prev l (next l x hx) (next_mem _ _ _) = x ",":= by
  obtain ‚ü®n, hn, rfl‚ü© := nthLe_of_mem hx
  simp only [next_nthLe, prev_nthLe, h, Nat.mod_add_mod]
  cases' l with hd tl
  ¬∑ simp at hx
  ¬∑ have : (n + 1 + length tl) % (length tl + 1) = n := by
      rw [length_cons] at hn
      rw [add_assoc, add_comm 1, Nat.add_mod_right, Nat.mod_eq_of_lt hn]
    simp only [length_cons, Nat.succ_sub_succ_eq_sub, Nat.sub_zero, Nat.succ_eq_add_one, this]"
Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean,mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt,mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt,0f24aee7da46f85fee5cacc716172444ce31e582,":= by
  have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
    hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
  letI := finiteDimensional B
  set P := minpoly R B.gen with hP
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  haveI : NoZeroSMulDivisors R L := NoZeroSMulDivisors.trans R K L
  let _ := P.map (algebraMap R L)
  rw [adjoin_singleton_eq_range_aeval] at hz
  obtain ‚ü®Q‚ÇÅ, hQ‚ü© := hz
  set Q := Q‚ÇÅ %‚Çò P with hQ‚ÇÅ
  replace hQ : aeval B.gen Q = p ‚Ä¢ z
  ¬∑ rw [‚Üê modByMonic_add_div Q‚ÇÅ (minpoly.monic hBint)] at hQ
    simpa using hQ
  by_cases hQzero : Q = 0
  ¬∑ simp only [hQzero, Algebra.smul_def, zero_eq_mul, aeval_zero] at hQ
    cases' hQ with H H‚ÇÅ
    ¬∑ have : Function.Injective (algebraMap R L) := by
        rw [algebraMap_eq R K L]
        exact (algebraMap K L).injective.comp (IsFractionRing.injective R K)
      exfalso
      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)
    ¬∑ rw [H‚ÇÅ]
      exact Subalgebra.zero_mem _
  refine mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => ?_) hQ
  induction' i using Nat.case_strong_induction_on with j hind
  ¬∑ intro _
    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt hp hBint hQ hzint hei
  ¬∑ intro hj
    convert hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd _ hndiv
    exact n
    have H := degree_modByMonic_lt Q‚ÇÅ (minpoly.monic hBint)
    rw [‚Üê hQ‚ÇÅ, ‚Üê hP] at H
    replace H := Nat.lt_iff_add_one_le.1
      (lt_of_lt_of_le
        (lt_of_le_of_lt (Nat.lt_iff_add_one_le.1 (Nat.lt_of_succ_lt_succ (mem_range.1 hj)))
          (lt_succ_self _)) (Nat.lt_iff_add_one_le.1 ((natDegree_lt_natDegree_iff hQzero).2 H)))
    rw [add_assoc] at H
    have Hj : Q.natDegree + 1 = j + 1 + (Q.natDegree - j) := by
      rw [‚Üê add_comm 1, ‚Üê add_comm 1, add_assoc, add_right_inj,
        ‚Üê Nat.add_sub_assoc (Nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm,
        Nat.add_sub_cancel]
    choose! g hg using hind
    replace hg : ‚àÄ k ‚àà range (j + 1), Q.coeff k ‚Ä¢ B.gen ^ k = algebraMap R L p * g k ‚Ä¢ B.gen ^ k
    ¬∑ intro k hk
      rw [hg k (mem_range_succ_iff.1 hk)
        (mem_range_succ_iff.2
          (le_trans (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),
        Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, mul_assoc]
    choose! f hf using
      IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
        (minpoly.monic hBint) hei.isWeaklyEisensteinAt
    have hf‚ÇÅ : ‚àÄ k ‚àà (range (Q.natDegree - j)).erase 0,
        Q.coeff (j + 1 + k) ‚Ä¢ B.gen ^ (j + 1 + k) * B.gen ^ (P.natDegree - (j + 2)) =
        (algebraMap R L) p * Q.coeff (j + 1 + k) ‚Ä¢ f (k + P.natDegree - 1) := by
      intro k hk
      rw [smul_mul_assoc, ‚Üê pow_add, ‚Üê Nat.add_sub_assoc H, ‚Üê add_assoc j 1 1, add_comm (j + 1) 1,
        add_assoc (j + 1), add_comm _ (k + P.natDegree), Nat.add_sub_add_right,
        ‚Üê (hf (k + P.natDegree - 1) _).2, mul_smul_comm]
      rw [(minpoly.monic hBint).natDegree_map, add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact Nat.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    suffices
        p ^ n.succ ‚à£ Q.coeff (succ j) ^ n.succ *
          (minpoly R B.gen).coeff 0 ^ (succ j + (P.natDegree - (j + 2))) by
      convert this
      rw [Nat.succ_eq_add_one, add_assoc, ‚Üê Nat.add_sub_assoc H, ‚Üê add_assoc, add_comm (j + 1),
        Nat.add_sub_add_left, ‚Üê Nat.add_sub_assoc, Nat.add_sub_add_left, hP, ‚Üê
        (minpoly.monic hBint).natDegree_map (algebraMap R K), ‚Üê
        minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, natDegree_minpoly, hn, Nat.sub_one,
        Nat.pred_succ]
      linarith
    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_addLeftEmbedding _ _),
      sum_congr rfl hg, add_comm] at hQ
    replace hQ := congr_arg (fun x => x * B.gen ^ (P.natDegree - (j + 2))) hQ
    simp_rw [sum_map, addLeftEmbedding_apply, add_mul, sum_mul, mul_assoc] at hQ
    rw [‚Üê insert_erase
      (mem_range.2 (tsub_pos_iff_lt.2 <| Nat.lt_of_succ_lt_succ <| mem_range.1 hj)),
      sum_insert (not_mem_erase 0 _), add_zero, sum_congr rfl hf‚ÇÅ, ‚Üê mul_sum, ‚Üê mul_sum, add_assoc,
      ‚Üê mul_add, smul_mul_assoc, ‚Üê pow_add, Algebra.smul_def] at hQ
    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)
    have hintsum : IsIntegral R (z * B.gen ^ (P.natDegree - (j + 2)) -
        (‚àë x : ‚Ñï in (range (Q.natDegree - j)).erase 0,
          Q.coeff (j + 1 + x) ‚Ä¢ f (x + P.natDegree - 1) +
            ‚àë x : ‚Ñï in range (j + 1), g x ‚Ä¢ B.gen ^ x * B.gen ^ (P.natDegree - (j + 2)))) := by
      refine isIntegral_sub (isIntegral_mul hzint (IsIntegral.pow hBint _))
          (isIntegral_add (IsIntegral.sum _ fun k hk => isIntegral_smul _ ?_)
            (IsIntegral.sum _ fun k _ =>
              isIntegral_mul (isIntegral_smul _ (IsIntegral.pow hBint _)) (IsIntegral.pow hBint _)))
      refine adjoin_le_integralClosure hBint (hf _ ?_).1
      rw [(minpoly.monic hBint).natDegree_map (algebraMap R L)]
      rw [add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact _root_.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
    rw [Algebra.smul_def, mul_assoc, ‚Üê mul_sub, _root_.map_mul, algebraMap_apply R K L, map_pow,
      Algebra.norm_algebraMap, _root_.map_mul, algebraMap_apply R K L, Algebra.norm_algebraMap,
      finrank B, ‚Üê hr, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map,
      show (-1 : K) = algebraMap R K (-1) by simp, ‚Üê map_pow, ‚Üê map_pow, ‚Üê _root_.map_mul, ‚Üê
      map_pow, ‚Üê _root_.map_mul, ‚Üê map_pow, ‚Üê _root_.map_mul] at hQ
    have hppdiv : p ^ B.dim ‚à£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _
    rwa [‚Üê IsFractionRing.injective R K hQ, mul_comm, ‚Üê Units.coe_neg_one, mul_pow, ‚Üê
      Units.val_pow_eq_pow_val, ‚Üê Units.val_pow_eq_pow_val, mul_assoc,
      IsUnit.dvd_mul_left _ _ _ ‚ü®_, rfl‚ü©, mul_comm, ‚Üê Nat.succ_eq_add_one, hn] at hppdiv","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case intro.intro
R : Type u
K : Type v
L : Type z
p : R
inst‚úù¬π‚Å∞ : CommRing R
inst‚úù‚Åπ : Field K
inst‚úù‚Å∏ : Field L
inst‚úù‚Å∑ : Algebra K L
inst‚úù‚Å∂ : Algebra R L
inst‚úù‚Åµ : Algebra R K
inst‚úù‚Å¥ : IsScalarTower R K L
inst‚úù¬≥ : IsSeparable K L
inst‚úù¬≤ : IsDomain R
inst‚úù¬π : IsFractionRing R K
inst‚úù : IsIntegrallyClosed R
B : PowerBasis K L
hp : _root_.Prime p
hBint : IsIntegral R B.gen
z : L
hzint : IsIntegral R z
this‚úù : Module.Finite K L := finiteDimensional B
P : R[X] := minpoly R B.gen
hei : P.IsEisensteinAt (Submodule.span R {p})
hndiv : ¬¨p ^ 2 ‚à£ P.coeff 0
hP : P = minpoly R B.gen
n : ‚Ñï
hn : B.dim = n.succ
this : NoZeroSMulDivisors R L
x‚úù : L[X] := Polynomial.map (algebraMap R L) P
Q‚ÇÅ : R[X]
Q : R[X] := Q‚ÇÅ %‚Çò P
hQ‚ÇÅ : Q = Q‚ÇÅ %‚Çò P
hQ : (aeval B.gen) Q = p ‚Ä¢ z
‚ä¢ z ‚àà adjoin R {B.gen}","theorem mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} (hzint : IsIntegral R z)
    (hz : p ‚Ä¢ z ‚àà adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) :
    z ‚àà adjoin R ({B.gen} : Set L) ",":= by
  have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
    hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
  have := B.finite
  set P := minpoly R B.gen with hP
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  haveI : NoZeroSMulDivisors R L := NoZeroSMulDivisors.trans R K L
  let _ := P.map (algebraMap R L)
  rw [adjoin_singleton_eq_range_aeval] at hz
  obtain ‚ü®Q‚ÇÅ, hQ‚ü© := hz
  set Q := Q‚ÇÅ %‚Çò P with hQ‚ÇÅ
  replace hQ : aeval B.gen Q = p ‚Ä¢ z := by
    rw [‚Üê modByMonic_add_div Q‚ÇÅ (minpoly.monic hBint)] at hQ
    simpa using hQ
  by_cases hQzero : Q = 0
  ¬∑ simp only [hQzero, Algebra.smul_def, zero_eq_mul, aeval_zero] at hQ
    cases' hQ with H H‚ÇÅ
    ¬∑ have : Function.Injective (algebraMap R L) := by
        rw [algebraMap_eq R K L]
        exact (algebraMap K L).injective.comp (IsFractionRing.injective R K)
      exfalso
      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)
    ¬∑ rw [H‚ÇÅ]
      exact Subalgebra.zero_mem _
  refine mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => ?_) hQ
  induction' i using Nat.case_strong_induction_on with j hind
  ¬∑ intro _
    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt hp hBint hQ hzint hei
  ¬∑ intro hj
    convert hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd (n := n) _ hndiv
    have H := degree_modByMonic_lt Q‚ÇÅ (minpoly.monic hBint)
    rw [‚Üê hQ‚ÇÅ, ‚Üê hP] at H
    replace H := Nat.lt_iff_add_one_le.1
      (lt_of_lt_of_le
        (lt_of_le_of_lt (Nat.lt_iff_add_one_le.1 (Nat.lt_of_succ_lt_succ (mem_range.1 hj)))
          (lt_succ_self _)) (Nat.lt_iff_add_one_le.1 ((natDegree_lt_natDegree_iff hQzero).2 H)))
    have Hj : Q.natDegree + 1 = j + 1 + (Q.natDegree - j) := by
      rw [‚Üê add_comm 1, ‚Üê add_comm 1, add_assoc, add_right_inj,
        ‚Üê Nat.add_sub_assoc (Nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm,
        Nat.add_sub_cancel]
    choose! g hg using hind
    replace hg : ‚àÄ k ‚àà range (j + 1), Q.coeff k ‚Ä¢ B.gen ^ k =
        algebraMap R L p * g k ‚Ä¢ B.gen ^ k := by
      intro k hk
      rw [hg k (mem_range_succ_iff.1 hk)
        (mem_range_succ_iff.2
          (le_trans (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),
        Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, mul_assoc]
    choose! f hf using
      IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
        (minpoly.monic hBint) hei.isWeaklyEisensteinAt
    have hf‚ÇÅ : ‚àÄ k ‚àà (range (Q.natDegree - j)).erase 0,
        Q.coeff (j + 1 + k) ‚Ä¢ B.gen ^ (j + 1 + k) * B.gen ^ (P.natDegree - (j + 2)) =
        (algebraMap R L) p * Q.coeff (j + 1 + k) ‚Ä¢ f (k + P.natDegree - 1) := by
      intro k hk
      rw [smul_mul_assoc, ‚Üê pow_add, ‚Üê Nat.add_sub_assoc H, add_comm (j + 1) 1,
        add_assoc (j + 1), add_comm _ (k + P.natDegree), Nat.add_sub_add_right,
        ‚Üê (hf (k + P.natDegree - 1) _).2, mul_smul_comm]
      rw [(minpoly.monic hBint).natDegree_map, add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact Nat.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    suffices
        p ^ n.succ ‚à£ Q.coeff (succ j) ^ n.succ *
          (minpoly R B.gen).coeff 0 ^ (succ j + (P.natDegree - (j + 2))) by
      convert this
      rw [Nat.succ_eq_add_one, add_assoc, ‚Üê Nat.add_sub_assoc H, add_comm (j + 1),
        Nat.add_sub_add_left, ‚Üê Nat.add_sub_assoc, Nat.add_sub_add_left, hP, ‚Üê
        (minpoly.monic hBint).natDegree_map (algebraMap R K), ‚Üê
        minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, natDegree_minpoly, hn, Nat.sub_one,
        Nat.pred_succ]
      omega
    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_addLeftEmbedding _ _),
      sum_congr rfl hg, add_comm] at hQ
    replace hQ := congr_arg (fun x => x * B.gen ^ (P.natDegree - (j + 2))) hQ
    simp_rw [sum_map, addLeftEmbedding_apply, add_mul, sum_mul, mul_assoc] at hQ
    rw [‚Üê insert_erase
      (mem_range.2 (tsub_pos_iff_lt.2 <| Nat.lt_of_succ_lt_succ <| mem_range.1 hj)),
      sum_insert (not_mem_erase 0 _), add_zero, sum_congr rfl hf‚ÇÅ, ‚Üê mul_sum, ‚Üê mul_sum, add_assoc,
      ‚Üê mul_add, smul_mul_assoc, ‚Üê pow_add, Algebra.smul_def] at hQ
    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)
    have hintsum : IsIntegral R (z * B.gen ^ (P.natDegree - (j + 2)) -
        (‚àë x ‚àà (range (Q.natDegree - j)).erase 0,
          Q.coeff (j + 1 + x) ‚Ä¢ f (x + P.natDegree - 1) +
            ‚àë x ‚àà range (j + 1), g x ‚Ä¢ B.gen ^ x * B.gen ^ (P.natDegree - (j + 2)))) := by
      refine (hzint.mul (hBint.pow _)).sub
        (.add (.sum _ fun k hk => .smul _ ?_)
          (.sum _ fun k _ => .mul (.smul _ (.pow hBint _)) (hBint.pow _)))
      refine adjoin_le_integralClosure hBint (hf _ ?_).1
      rw [(minpoly.monic hBint).natDegree_map (algebraMap R L)]
      rw [add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact _root_.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
    rw [Algebra.smul_def, mul_assoc, ‚Üê mul_sub, _root_.map_mul, algebraMap_apply R K L, map_pow,
      Algebra.norm_algebraMap, _root_.map_mul, algebraMap_apply R K L, Algebra.norm_algebraMap,
      finrank B, ‚Üê hr, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map,
      show (-1 : K) = algebraMap R K (-1) by simp, ‚Üê map_pow, ‚Üê map_pow, ‚Üê _root_.map_mul, ‚Üê
      map_pow, ‚Üê _root_.map_mul, ‚Üê map_pow, ‚Üê _root_.map_mul] at hQ
    have hppdiv : p ^ B.dim ‚à£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _
    rwa [‚Üê IsFractionRing.injective R K hQ, mul_comm, ‚Üê Units.coe_neg_one, mul_pow, ‚Üê
      Units.val_pow_eq_pow_val, ‚Üê Units.val_pow_eq_pow_val, mul_assoc,
      Units.dvd_mul_left, mul_comm, ‚Üê Nat.succ_eq_add_one, hn] at hppdiv"
Mathlib/RingTheory/Adjoin/PowerBasis.lean,PowerBasis.repr_mul_isIntegral,repr_mul_isIntegral,8dba065d4a693e23ed06348923cd5effc765cb75,":= by
  intro i
  rw [‚Üê B.basis.sum_repr x, ‚Üê B.basis.sum_repr y, Finset.sum_mul_sum, map_sum, Finset.sum_apply']
  refine' IsIntegral.sum _ fun I _ => _
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smul‚Çõ‚Çó,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine (hy _).mul ((hx _).mul ?_)
  simp only [coe_basis, ‚Üê pow_add]
  refine' repr_gen_pow_isIntegral hB hmin _ _","error:  type mismatch
  IsIntegral.mul (hy ?m.62903) (IsIntegral.mul (hx ?m.62946) ?m.62967)
has type
  IsIntegral R ((B.basis.repr y) ?m.62903 * ((B.basis.repr x) ?m.62946 * ?m.62964)) : Prop
but is expected to have type
  IsIntegral R
    ((B.basis.repr (‚àë x_1 : Fin B.dim, (B.basis.repr y) x_1 ‚Ä¢ (B.basis.repr x) I ‚Ä¢ (B.basis I * B.basis x_1))) i) : Prop
error:  application type mismatch
  repr_mul_isIntegral hB
argument
  hB
has type
  IsIntegral R B.gen : Prop
but is expected to have type
  ‚àÄ (i : Fin ?m.77450.dim), IsIntegral ?m.77443 ((?m.77450.basis.repr ?m.77452) i) : Prop
error:  application type mismatch
  repr_pow_isIntegral hB
argument
  hB
has type
  IsIntegral R B.gen : Prop
but is expected to have type
  ‚àÄ (i : Fin ?m.83722.dim), IsIntegral ?m.83715 ((?m.83722.basis.repr ?m.83724) i) : Prop
error:  no goals to be solved","theorem repr_mul_isIntegral [IsDomain S] {x y : A} (hx : ‚àÄ i, IsIntegral R (B.basis.repr x i))
    (hy : ‚àÄ i, IsIntegral R (B.basis.repr y i))
    (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) :
    ‚àÄ i, IsIntegral R (B.basis.repr (x * y) i) ",":= by
  intro i
  rw [‚Üê B.basis.sum_repr x, ‚Üê B.basis.sum_repr y, Finset.sum_mul_sum, ‚Üê Finset.sum_product',
    map_sum, Finset.sum_apply']
  refine IsIntegral.sum _ fun I _ => ?_
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smul‚Çõ‚Çó,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine (hy _).mul ((hx _).mul ?_)
  simp only [coe_basis, ‚Üê pow_add]
  exact repr_gen_pow_isIntegral hB hmin _ _"
Mathlib/Analysis/Calculus/BumpFunction/FiniteDimension.lean,exists_smooth_tsupport_subset,exists_smooth_tsupport_subset,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  obtain ‚ü®d : ‚Ñù, d_pos : 0 < d, hd : Euclidean.closedBall x d ‚äÜ s‚ü© :=
    Euclidean.nhds_basis_closedBall.mem_iff.1 hs
  let c : ContDiffBump (toEuclidean x) :=
    { rIn := d / 2
      rOut := d
      rIn_pos := half_pos d_pos
      rIn_lt_rOut := half_lt_self d_pos }
  let f : E ‚Üí ‚Ñù := c ‚àò toEuclidean
  have f_supp : f.support ‚äÜ Euclidean.ball x d := by
    intro y hy
    have : toEuclidean y ‚àà Function.support c := by
      simpa only [Function.mem_support, Function.comp_apply, Ne.def] using hy
    rwa [c.support_eq] at this
  have f_tsupp : tsupport f ‚äÜ Euclidean.closedBall x d := by
    rw [tsupport, ‚Üê Euclidean.closure_ball _ d_pos.ne']
    exact closure_mono f_supp
  refine' ‚ü®f, f_tsupp.trans hd, _, _, _, _‚ü©
  ¬∑ refine' isCompact_of_isClosed_bounded isClosed_closure _
    have : Bounded (Euclidean.closedBall x d) := Euclidean.isCompact_closedBall.bounded
    apply this.mono _
    refine' (IsClosed.closure_subset_iff Euclidean.isClosed_closedBall).2 _
    exact f_supp.trans Euclidean.ball_subset_closedBall
  ¬∑ apply c.contDiff.comp
    exact ContinuousLinearEquiv.contDiff _
  ¬∑ rintro t ‚ü®y, rfl‚ü©
    exact ‚ü®c.nonneg, c.le_one‚ü©
  ¬∑ apply c.one_of_mem_closedBall
    apply mem_closedBall_self
    exact (half_pos d_pos).le","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.10768 ‚Üí ?m.10768 ‚Üí Prop
error:  unknown identifier 'isCompact_of_isClosed_bounded'
error:  no goals to be solved","theorem exists_smooth_tsupport_subset {s : Set E} {x : E} (hs : s ‚àà ùìù x) :
    ‚àÉ f : E ‚Üí ‚Ñù,
      tsupport f ‚äÜ s ‚àß HasCompactSupport f ‚àß ContDiff ‚Ñù ‚ä§ f ‚àß range f ‚äÜ Icc 0 1 ‚àß f x = 1 ",":= by
  obtain ‚ü®d : ‚Ñù, d_pos : 0 < d, hd : Euclidean.closedBall x d ‚äÜ s‚ü© :=
    Euclidean.nhds_basis_closedBall.mem_iff.1 hs
  let c : ContDiffBump (toEuclidean x) :=
    { rIn := d / 2
      rOut := d
      rIn_pos := half_pos d_pos
      rIn_lt_rOut := half_lt_self d_pos }
  let f : E ‚Üí ‚Ñù := c ‚àò toEuclidean
  have f_supp : f.support ‚äÜ Euclidean.ball x d := by
    intro y hy
    have : toEuclidean y ‚àà Function.support c := by
      simpa only [Function.mem_support, Function.comp_apply, Ne] using hy
    rwa [c.support_eq] at this
  have f_tsupp : tsupport f ‚äÜ Euclidean.closedBall x d := by
    rw [tsupport, ‚Üê Euclidean.closure_ball _ d_pos.ne']
    exact closure_mono f_supp
  refine ‚ü®f, f_tsupp.trans hd, ?_, ?_, ?_, ?_‚ü©
  ¬∑ refine isCompact_of_isClosed_isBounded isClosed_closure ?_
    have : IsBounded (Euclidean.closedBall x d) := Euclidean.isCompact_closedBall.isBounded
    refine this.subset (Euclidean.isClosed_closedBall.closure_subset_iff.2 ?_)
    exact f_supp.trans Euclidean.ball_subset_closedBall
  ¬∑ apply c.contDiff.comp
    exact ContinuousLinearEquiv.contDiff _
  ¬∑ rintro t ‚ü®y, rfl‚ü©
    exact ‚ü®c.nonneg, c.le_one‚ü©
  ¬∑ apply c.one_of_mem_closedBall
    apply mem_closedBall_self
    exact (half_pos d_pos).le"
Mathlib/SetTheory/Cardinal/SchroederBernstein.lean,Function.Embedding.schroeder_bernstein,schroeder_bernstein,6ceb594537e19a62a66597a7b8f405f094f81ebc,":= by
  cases' isEmpty_or_nonempty Œ≤ with hŒ≤ hŒ≤
  ¬∑ have : IsEmpty Œ± := Function.isEmpty f
    exact ‚ü®_, ((Equiv.equivEmpty Œ±).trans (Equiv.equivEmpty Œ≤).symm).bijective‚ü©
  set F : Set Œ± ‚Üío Set Œ± :=
    { toFun := fun s => (g '' (f '' s)·∂ú)·∂ú
      monotone' := fun s t hst =>
        compl_subset_compl.mpr <| image_subset _ <| compl_subset_compl.mpr <| image_subset _ hst }
  set s : Set Œ± := OrderHom.lfp F
  have hs : (g '' (f '' s)·∂ú)·∂ú = s := F.map_lfp
  have hns : g '' (f '' s)·∂ú = s·∂ú := compl_injective (by simp [hs])
  set g' := invFun g
  have g'g : LeftInverse g' g := leftInverse_invFun hg
  have hg'ns : g' '' s·∂ú = (f '' s)·∂ú := by rw [‚Üê hns, g'g.image_image]
  set h : Œ± ‚Üí Œ≤ := s.piecewise f g'
  have : Surjective h := by rw [‚Üê range_iff_surjective, range_piecewise, hg'ns, union_compl_self]
  have : Injective h :=
    by
    refine' (injective_piecewise_iff _).2 ‚ü®hf.injOn _, _, _‚ü©
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®x', _, rfl‚ü© : x ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      obtain ‚ü®y', _, rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _, g'g _] at hxy
      rw [hxy]
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®y', hy', rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _] at hxy
      exact hy' ‚ü®x, hx, hxy‚ü©
  exact ‚ü®h, ‚ÄπInjective h‚Ä∫, ‚ÄπSurjective h‚Ä∫‚ü©","error:  application type mismatch
  And.intro (Injective.injOn hf ?m.1813)
argument
  Injective.injOn hf ?m.1813
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Œ±‚¶Ñ, x‚ÇÇ ‚àà ?m.1811 ‚Üí f ?m.1812 = f x‚ÇÇ ‚Üí ?m.1812 = x‚ÇÇ : Prop
but is expected to have type
  InjOn f s : Prop","theorem schroeder_bernstein {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ±} (hf : Function.Injective f)
    (hg : Function.Injective g) : ‚àÉ h : Œ± ‚Üí Œ≤, Bijective h ",":= by
  cases' isEmpty_or_nonempty Œ≤ with hŒ≤ hŒ≤
  ¬∑ have : IsEmpty Œ± := Function.isEmpty f
    exact ‚ü®_, ((Equiv.equivEmpty Œ±).trans (Equiv.equivEmpty Œ≤).symm).bijective‚ü©
  set F : Set Œ± ‚Üío Set Œ± :=
    { toFun := fun s => (g '' (f '' s)·∂ú)·∂ú
      monotone' := fun s t hst =>
        compl_subset_compl.mpr <| image_subset _ <| compl_subset_compl.mpr <| image_subset _ hst }
  set s : Set Œ± := OrderHom.lfp F
  have hs : (g '' (f '' s)·∂ú)·∂ú = s := F.map_lfp
  have hns : g '' (f '' s)·∂ú = s·∂ú := compl_injective (by simp [hs])
  set g' := invFun g
  have g'g : LeftInverse g' g := leftInverse_invFun hg
  have hg'ns : g' '' s·∂ú = (f '' s)·∂ú := by rw [‚Üê hns, g'g.image_image]
  set h : Œ± ‚Üí Œ≤ := s.piecewise f g'
  have : Surjective h := by rw [‚Üê range_iff_surjective, range_piecewise, hg'ns, union_compl_self]
  have : Injective h := by
    refine (injective_piecewise_iff _).2 ‚ü®hf.injOn, ?_, ?_‚ü©
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®x', _, rfl‚ü© : x ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      obtain ‚ü®y', _, rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _, g'g _] at hxy
      rw [hxy]
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®y', hy', rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _] at hxy
      exact hy' ‚ü®x, hx, hxy‚ü©
  exact ‚ü®h, ‚ÄπInjective h‚Ä∫, ‚ÄπSurjective h‚Ä∫‚ü©"
Mathlib/Data/Nat/Totient.lean,Nat.totient_div_of_dvd,totient_div_of_dvd,40b58304ad9cb6913d2d4e97172b2c306fdb61f2,":= by
  rcases d.eq_zero_or_pos with (rfl | hd0); ¬∑ simp [eq_zero_of_zero_dvd hnd]
  rcases hnd with ‚ü®x, rfl‚ü©
  rw [Nat.mul_div_cancel_left x hd0]
  apply Finset.card_congr fun k _ => d * k
  ¬∑ simp only [mem_filter, mem_range, and_imp, coprime]
    refine' fun a ha1 ha2 => ‚ü®(mul_lt_mul_left hd0).2 ha1, _‚ü©
    rw [gcd_mul_left, ha2, mul_one]
  ¬∑ simp [hd0.ne']
  ¬∑ simp only [mem_filter, mem_range, exists_prop, and_imp]
    refine' fun b hb1 hb2 => _
    have : d ‚à£ b := by
      rw [‚Üê hb2]
      apply gcd_dvd_right
    rcases this with ‚ü®q, rfl‚ü©
    refine' ‚ü®q, ‚ü®‚ü®(mul_lt_mul_left hd0).1 hb1, _‚ü©, rfl‚ü©‚ü©
    rwa [gcd_mul_left, mul_right_eq_self_iff hd0] at hb2","warning:  totient does not have a doc string
warning:  `Finset.card_congr` has been deprecated, use `Finset.card_bij` instead
error:  unknown identifier 'coprime'","theorem totient_div_of_dvd {n d : ‚Ñï} (hnd : d ‚à£ n) :
    œÜ (n / d) = (filter (fun k : ‚Ñï => n.gcd k = d) (range n)).card ",":= by
  rcases d.eq_zero_or_pos with (rfl | hd0); ¬∑ simp [eq_zero_of_zero_dvd hnd]
  rcases hnd with ‚ü®x, rfl‚ü©
  rw [Nat.mul_div_cancel_left x hd0]
  apply Finset.card_bij fun k _ => d * k
  ¬∑ simp only [mem_filter, mem_range, and_imp, Coprime]
    refine fun a ha1 ha2 => ‚ü®(mul_lt_mul_left hd0).2 ha1, ?_‚ü©
    rw [gcd_mul_left, ha2, mul_one]
  ¬∑ simp [hd0.ne']
  ¬∑ simp only [mem_filter, mem_range, exists_prop, and_imp]
    refine fun b hb1 hb2 => ?_
    have : d ‚à£ b := by
      rw [‚Üê hb2]
      apply gcd_dvd_right
    rcases this with ‚ü®q, rfl‚ü©
    refine ‚ü®q, ‚ü®‚ü®(mul_lt_mul_left hd0).1 hb1, ?_‚ü©, rfl‚ü©‚ü©
    rwa [gcd_mul_left, mul_right_eq_self_iff hd0] at hb2"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean,hasDerivAt_ofReal_cpow,hasDerivAt_ofReal_cpow,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  rw [Ne, ‚Üê add_eq_zero_iff_eq_neg, ‚Üê Ne] at hr
  rcases lt_or_gt_of_ne hx.symm with (hx | hx)
  ¬∑ 
    apply HasDerivAt.comp_ofReal (e := fun y => (y : ‚ÑÇ) ^ (r + 1) / (r + 1))
    convert HasDerivAt.div_const (ùïú := ‚ÑÇ) ?_ (r + 1) using 1
    ¬∑ exact (mul_div_cancel_right‚ÇÄ _ hr).symm
    ¬∑ convert HasDerivAt.cpow_const ?_ ?_ using 1
      ¬∑ rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm
      ¬∑ exact hasDerivAt_id (x : ‚ÑÇ)
      ¬∑ simp [hx]
  ¬∑ 
    have : ‚àÄ·∂† y : ‚Ñù in ùìù x,
        (y : ‚ÑÇ) ^ (r + 1) / (r + 1) = (-y : ‚ÑÇ) ^ (r + 1) * exp (œÄ * I * (r + 1)) / (r + 1) := by
      refine' Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => _
      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]
    refine' HasDerivAt.congr_of_eventuallyEq _ this
    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]
    suffices HasDerivAt (fun y : ‚Ñù => (-‚Üëy) ^ (r + 1) * exp (‚ÜëœÄ * I * (r + 1)))
        ((r + 1) * (-‚Üëx) ^ r * exp (‚ÜëœÄ * I * r)) x by
      convert this.div_const (r + 1) using 1
      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right‚ÇÄ _ hr]
    rw [mul_add ((œÄ : ‚ÑÇ) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : ‚ÑÇ) (-1 : ‚ÑÇ),
      neg_one_mul]
    simp_rw [mul_neg, ‚Üê neg_mul, ‚Üê ofReal_neg]
    suffices HasDerivAt (fun y : ‚Ñù => (‚Üë(-y) : ‚ÑÇ) ^ (r + 1)) (-(r + 1) * ‚Üë(-x) ^ r) x by
      convert this.neg.mul_const _ using 1; ring
    suffices HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) (-x) by
      convert @HasDerivAt.scomp ‚Ñù _ ‚ÑÇ _ _ x ‚Ñù _ _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1
      rw [real_smul, ofReal_neg 1, ofReal_one]; ring
    suffices HasDerivAt (fun y : ‚ÑÇ => y ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) ‚Üë(-x) by
      exact this.comp_ofReal
    conv in ‚Üë_ ^ _ => rw [(by ring : r = r + 1 - 1)]
    convert HasDerivAt.cpow_const ?_ ?_ using 1
    ¬∑ rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm
    ¬∑ exact hasDerivAt_id ((-x : ‚Ñù) : ‚ÑÇ)
    ¬∑ simp [hx]","error:  function expected at
  HasDerivAt.scomp x ?m.116908 ?m.116971
term has type
  HasDerivAt (?m.116906 ‚àò ?m.116904) (?m.116905 ‚Ä¢ ?m.116907) x
error:  application type mismatch
  HasDerivAt.scomp x ?m.116908 this
argument
  this
has type
  HasDerivAt (fun y ‚Ü¶ ‚Üëy ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) (-x) : Prop
but is expected to have type
  HasDerivAt ?m.116904 ?m.116905 x : Prop","theorem hasDerivAt_ofReal_cpow {x : ‚Ñù} (hx : x ‚â† 0) {r : ‚ÑÇ} (hr : r ‚â† -1) :
    HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ (r + 1) / (r + 1)) (x ^ r) x ",":= by
  rw [Ne, ‚Üê add_eq_zero_iff_eq_neg, ‚Üê Ne] at hr
  rcases lt_or_gt_of_ne hx.symm with (hx | hx)
  ¬∑ 
    apply HasDerivAt.comp_ofReal (e := fun y => (y : ‚ÑÇ) ^ (r + 1) / (r + 1))
    convert HasDerivAt.div_const (ùïú := ‚ÑÇ) ?_ (r + 1) using 1
    ¬∑ exact (mul_div_cancel_right‚ÇÄ _ hr).symm
    ¬∑ convert HasDerivAt.cpow_const ?_ ?_ using 1
      ¬∑ rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm
      ¬∑ exact hasDerivAt_id (x : ‚ÑÇ)
      ¬∑ simp [hx]
  ¬∑ 
    have : ‚àÄ·∂† y : ‚Ñù in ùìù x,
        (y : ‚ÑÇ) ^ (r + 1) / (r + 1) = (-y : ‚ÑÇ) ^ (r + 1) * exp (œÄ * I * (r + 1)) / (r + 1) := by
      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_
      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]
    refine HasDerivAt.congr_of_eventuallyEq ?_ this
    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]
    suffices HasDerivAt (fun y : ‚Ñù => (-‚Üëy) ^ (r + 1) * exp (‚ÜëœÄ * I * (r + 1)))
        ((r + 1) * (-‚Üëx) ^ r * exp (‚ÜëœÄ * I * r)) x by
      convert this.div_const (r + 1) using 1
      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right‚ÇÄ _ hr]
    rw [mul_add ((œÄ : ‚ÑÇ) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : ‚ÑÇ) (-1 : ‚ÑÇ),
      neg_one_mul]
    simp_rw [mul_neg, ‚Üê neg_mul, ‚Üê ofReal_neg]
    suffices HasDerivAt (fun y : ‚Ñù => (‚Üë(-y) : ‚ÑÇ) ^ (r + 1)) (-(r + 1) * ‚Üë(-x) ^ r) x by
      convert this.neg.mul_const _ using 1; ring
    suffices HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) (-x) by
      convert @HasDerivAt.scomp ‚Ñù _ ‚ÑÇ _ _ x ‚Ñù _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1
      rw [real_smul, ofReal_neg 1, ofReal_one]; ring
    suffices HasDerivAt (fun y : ‚ÑÇ => y ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) ‚Üë(-x) by
      exact this.comp_ofReal
    conv in ‚Üë_ ^ _ => rw [(by ring : r = r + 1 - 1)]
    convert HasDerivAt.cpow_const ?_ ?_ using 1
    ¬∑ rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm
    ¬∑ exact hasDerivAt_id ((-x : ‚Ñù) : ‚ÑÇ)
    ¬∑ simp [hx]"
Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean,CategoryTheory.Pretriangulated.exists_iso_of_arrow_iso,exists_iso_of_arrow_iso,438b05074b62d579d6ae365158053fbb33cfdb16,":= by
  obtain ‚ü®œÜ, ‚ü®hœÜ‚ÇÅ, hœÜ‚ÇÇ‚ü©‚ü© :=
    complete_distinguished_triangle_morphism' T‚ÇÅ T‚ÇÇ hT‚ÇÅ hT‚ÇÇ e.hom.left e.hom.right e.hom.w.symm
  have : IsIso œÜ.hom‚ÇÅ := by rw [hœÜ‚ÇÅ] ; infer_instance
  have : IsIso œÜ.hom‚ÇÇ := by rw [hœÜ‚ÇÇ] ; infer_instance
  have : IsIso œÜ.hom‚ÇÉ := isIso‚ÇÉ_of_isIso‚ÇÅ‚ÇÇ œÜ hT‚ÇÅ hT‚ÇÇ inferInstance inferInstance
  have := Triangle.isIso_of_isIsos œÜ inferInstance inferInstance inferInstance
  exact ‚ü®asIso œÜ, hœÜ‚ÇÅ, hœÜ‚ÇÇ‚ü©","error:  unknown identifier 'complete_distinguished_triangle_morphism''
error:  rcases tactic failed: x‚úù : ?m.221813 is not an inductive datatype","lemma exists_iso_of_arrow_iso (T‚ÇÅ T‚ÇÇ : Triangle C) (hT‚ÇÅ : T‚ÇÅ ‚àà distTriang C)
    (hT‚ÇÇ : T‚ÇÇ ‚àà distTriang C) (e : Arrow.mk T‚ÇÅ.mor‚ÇÅ ‚âÖ Arrow.mk T‚ÇÇ.mor‚ÇÅ) :
    ‚àÉ (e' : T‚ÇÅ ‚âÖ T‚ÇÇ), e'.hom.hom‚ÇÅ = e.hom.left ‚àß e'.hom.hom‚ÇÇ = e.hom.right ",":= by
  let œÜ := completeDistinguishedTriangleMorphism T‚ÇÅ T‚ÇÇ hT‚ÇÅ hT‚ÇÇ e.hom.left e.hom.right e.hom.w.symm
  have : IsIso œÜ.hom‚ÇÅ := by dsimp [œÜ]; infer_instance
  have : IsIso œÜ.hom‚ÇÇ := by dsimp [œÜ]; infer_instance
  have : IsIso œÜ.hom‚ÇÉ := isIso‚ÇÉ_of_isIso‚ÇÅ‚ÇÇ œÜ hT‚ÇÅ hT‚ÇÇ inferInstance inferInstance
  have : IsIso œÜ := by
    apply Triangle.isIso_of_isIsos
    all_goals infer_instance
  exact ‚ü®asIso œÜ, by simp [œÜ], by simp [œÜ]‚ü©"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.partialGamma_add_one,partialGamma_add_one,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  rw [partialGamma, partialGamma, add_sub_cancel]
  have F_der_I : ‚àÄ x : ‚Ñù, x ‚àà Ioo 0 X ‚Üí HasDerivAt (fun x => (-x).exp * x ^ s : ‚Ñù ‚Üí ‚ÑÇ)
      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by
    intro x hx
    have d1 : HasDerivAt (fun y : ‚Ñù => (-y).exp) (-(-x).exp) x := by
      simpa using (hasDerivAt_neg x).exp
    have d2 : HasDerivAt (fun y : ‚Ñù => ‚Üëy ^ s) (s * x ^ (s - 1)) x := by
      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id ‚Üëx) ?_
      simpa only [mul_one] using t.comp_ofReal
      simpa only [id.def, ofReal_re, ofReal_im, Ne.def, eq_self_iff_true, not_true, or_false_iff,
        mul_one] using hx.1
    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2
  have cont := (continuous_ofReal.comp continuous_neg.exp).mul (continuous_ofReal_cpow_const hs)
  have der_ible :=
    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)
  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible
  apply_fun fun x : ‚ÑÇ => -x at int_eval
  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)
      (Gamma_integrand_deriv_integrable_B hs hX),
    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval
  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]
  simp only [sub_left_inj, add_left_inj]
  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : ‚Ñù ‚Üí ‚ÑÇ) =
      (fun x => s * (-x).exp * x ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) := by ext1; ring
  rw [this]
  have t := @integral_const_mul 0 X volume _ _ s fun x : ‚Ñù => (-x).exp * x ^ (s - 1)
  dsimp at t; rw [‚Üê t, ofReal_zero, zero_cpow]
  ¬∑ rw [MulZeroClass.mul_zero, add_zero]; congr 2; ext1; ring
  ¬∑ contrapose! hs; rw [hs, zero_re]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + (?b - ?a)
s : ‚ÑÇ
hs : 0 < s.re
X : ‚Ñù
hX : 0 ‚â§ X
‚ä¢ ‚à´ (x : ‚Ñù) in 0 ..X, ‚Üë(rexp (-x)) * ‚Üëx ^ (s + 1 - 1) =
    (s * ‚à´ (x : ‚Ñù) in 0 ..X, ‚Üë(rexp (-x)) * ‚Üëx ^ (s - 1)) - ‚Üë(rexp (-X)) * ‚ÜëX ^ s","theorem partialGamma_add_one {s : ‚ÑÇ} (hs : 0 < s.re) {X : ‚Ñù} (hX : 0 ‚â§ X) :
    partialGamma (s + 1) X = s * partialGamma s X - (-X).exp * X ^ s ",":= by
  rw [partialGamma, partialGamma, add_sub_cancel_right]
  have F_der_I : ‚àÄ x : ‚Ñù, x ‚àà Ioo 0 X ‚Üí HasDerivAt (fun x => (-x).exp * x ^ s : ‚Ñù ‚Üí ‚ÑÇ)
      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by
    intro x hx
    have d1 : HasDerivAt (fun y : ‚Ñù => (-y).exp) (-(-x).exp) x := by
      simpa using (hasDerivAt_neg x).exp
    have d2 : HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ s) (s * x ^ (s - 1)) x := by
      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id ‚Üëx) ?_
      ¬∑ simpa only [mul_one] using t.comp_ofReal
      ¬∑ exact ofReal_mem_slitPlane.2 hx.1
    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2
  have cont := (continuous_ofReal.comp continuous_neg.rexp).mul (continuous_ofReal_cpow_const hs)
  have der_ible :=
    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)
  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible
  apply_fun fun x : ‚ÑÇ => -x at int_eval
  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)
      (Gamma_integrand_deriv_integrable_B hs hX),
    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval
  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]
  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : ‚Ñù ‚Üí ‚ÑÇ) =
      (fun x => s * (-x).exp * x ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) := by ext1; ring
  rw [this]
  have t := @integral_const_mul 0 X volume _ _ s fun x : ‚Ñù => (-x).exp * x ^ (s - 1)
  rw [‚Üê t, ofReal_zero, zero_cpow]
  ¬∑ rw [mul_zero, add_zero]; congr 2; ext1; ring
  ¬∑ contrapose! hs; rw [hs, zero_re]"
Mathlib/RingTheory/IntegralClosure.lean,Algebra.finite_iff_isIntegral_and_finiteType,Algebra.finite_iff_isIntegral_and_finiteType,a76dc22f3a90e5ab96e9284d30276a87a4324a5d,":=
  ‚ü®fun _ => ‚ü®Algebra.IsIntegral.of_finite, inferInstance‚ü©, fun ‚ü®h, _‚ü© => h.finite‚ü©","error:  application type mismatch
  And.intro IsIntegral.of_finite
argument
  IsIntegral.of_finite
has type
  ‚àÄ (R : Type ?u.178143) (B : Type ?u.178142) [inst : CommRing R] [inst_1 : Ring B] [inst_2 : Algebra R B]
    [inst_3 : Module.Finite R B], Algebra.IsIntegral R B : Prop
but is expected to have type
  Algebra.IsIntegral R A : Prop","theorem Algebra.finite_iff_isIntegral_and_finiteType :
    Module.Finite R A ‚Üî Algebra.IsIntegral R A ‚àß Algebra.FiniteType R A ",":=
  ‚ü®fun _ ‚Ü¶ ‚ü®‚ü®.of_finite R‚ü©, inferInstance‚ü©, fun ‚ü®h, _‚ü© ‚Ü¶ h.finite‚ü©"
Mathlib/Analysis/Calculus/Rademacher.lean,LipschitzWith.ae_differentiableAt,LipschitzWith.ae_differentiableAt,9a069d68af1d7bc2ad676d68e44dc963e5910e7b,":= by
  rw [‚Üê lipschitzOnWith_univ] at h
  simpa [differentiableWithinAt_univ] using h.ae_differentiableWithinAt_of_mem","error:  unknown identifier 'lipschitzOnWith_univ'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.541013
E : Type u_1
inst‚úù‚Å∏ : NormedAddCommGroup E
inst‚úù‚Å∑ : NormedSpace ‚Ñù E
inst‚úù‚Å∂ : FiniteDimensional ‚Ñù E
inst‚úù‚Åµ : MeasurableSpace E
inst‚úù‚Å¥ : BorelSpace E
F : Type u_2
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : NormedSpace ‚Ñù F
C D : ‚Ñù‚â•0
f‚úù g : E ‚Üí ‚Ñù
s : Set E
Œº : Measure E
inst‚úù¬π : Œº.IsAddHaarMeasure
inst‚úù : FiniteDimensional ‚Ñù F
f : E ‚Üí F
h : LipschitzWith C f
‚ä¢ ‚àÄ·µê (x : E) ‚àÇŒº, DifferentiableAt ‚Ñù f x","theorem LipschitzWith.ae_differentiableAt {f : E ‚Üí F} (h : LipschitzWith C f) :
    ‚àÄ·µê x ‚àÇŒº, DifferentiableAt ‚Ñù f x ",":= by
  rw [‚Üê lipschitzOn_univ] at h
  simpa [differentiableWithinAt_univ] using h.ae_differentiableWithinAt_of_mem"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.zipWith_single_single,zipWith_single_single,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.zipWith_single_single (fun _ => f) (fun _ => hf) (i := a) m n","warning:  Finsupp does not have a doc string
error:  unknown identifier 'DFinsupp.zipWith_single_single'","theorem zipWith_single_single (f : M ‚Üí N ‚Üí P) (hf : f 0 0 = 0) (a : Œ±) (m : M) (n : N) :
    zipWith f hf (single a m) (single a n) = single a (f m n) ",":= by
  ext a'
  rw [zipWith_apply]
  obtain rfl | ha' := eq_or_ne a a'
  ¬∑ rw [single_eq_same, single_eq_same, single_eq_same]
  ¬∑ rw [single_eq_of_ne ha', single_eq_of_ne ha', single_eq_of_ne ha', hf]"
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,AffineMap.lineMap_rev_mem_affineSpan_pair,AffineMap.lineMap_rev_mem_affineSpan_pair,a37e82f3616d798c1103557af7187357fc3e9e42,":= by
  aesop","error:  tactic 'aesop' failed, made no progress
Initial goal:
  k : Type u_1
  V : Type u_2
  P : Type u_3
  inst‚úù¬≥ : Ring k
  inst‚úù¬≤ : AddCommGroup V
  inst‚úù¬π : Module k V
  inst‚úù : AffineSpace V P
  Œπ : Type u_4
  r : k
  p‚ÇÅ p‚ÇÇ : P
  ‚ä¢ (lineMap p‚ÇÇ p‚ÇÅ) r ‚àà affineSpan k {p‚ÇÅ, p‚ÇÇ}
warning:  @AffineSubspace.Parallel does not have a doc string","theorem AffineMap.lineMap_rev_mem_affineSpan_pair (r : k) (p‚ÇÅ p‚ÇÇ : P) :
    AffineMap.lineMap p‚ÇÇ p‚ÇÅ r ‚àà line[k, p‚ÇÅ, p‚ÇÇ] ",":=
  AffineMap.lineMap_mem _ (right_mem_affineSpan_pair _ _ _) (left_mem_affineSpan_pair _ _ _)"
Mathlib/RingTheory/IntegralClosure.lean,RingHom.isIntegralElem_leadingCoeff_mul,RingHom.isIntegralElem_leadingCoeff_mul,34df9077caefbe4f9218a88cf325d06c0ca82432,":= by
  by_cases h' : 1 ‚â§ p.natDegree
  ¬∑ use integralNormalization p
    have : p ‚â† 0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use p.monic_integralNormalization this
    rw [integralNormalization_eval‚ÇÇ_leadingCoeff_mul h' f x, h, MulZeroClass.mul_zero]
  ¬∑ by_cases hp : p.map f = 0
    ¬∑ apply_fun fun q => coeff q p.natDegree at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, MulZeroClass.zero_mul]
      exact f.is_integral_zero
    ¬∑ rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', eval‚ÇÇ_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]","error:  unknown identifier 'integralNormalization'
error:  invalid field 'monic_integralNormalization', the environment does not contain 'Polynomial.monic_integralNormalization'
  p
has type
  R[X]
error:  unknown identifier 'integralNormalization_eval‚ÇÇ_leadingCoeff_mul'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.374404
case right
R : Type u_1
A : Type u_2
B : Type u_3
S : Type u_4
inst‚úù‚Åµ : CommRing R
inst‚úù‚Å¥ : CommRing A
inst‚úù¬≥ : Ring B
inst‚úù¬≤ : CommRing S
inst‚úù¬π : Algebra R A
inst‚úù : Algebra R B
f‚úù¬π : R ‚Üí+* S
f‚úù : R ‚Üí+* B
f : R ‚Üí+* S
p : R[X]
x : S
h : eval‚ÇÇ f x p = 0
h' : 1 ‚â§ p.natDegree
this : p ‚â† 0
‚ä¢ eval‚ÇÇ f (f p.leadingCoeff * x) (sorryAx R[X] true) = 0
error:  invalid field 'is_integral_zero', the environment does not contain 'RingHom.is_integral_zero'
  f
has type
  R ‚Üí+* S","theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval‚ÇÇ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) ",":= by
  by_cases h' : 1 ‚â§ p.natDegree
  ¬∑ use normalizeScaleRoots p
    have : p ‚â† 0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_eval‚ÇÇ_leadingCoeff_mul p h' f x, h, mul_zero]
  ¬∑ by_cases hp : p.map f = 0
    ¬∑ apply_fun fun q => coeff q p.natDegree at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, zero_mul]
      exact f.isIntegralElem_zero
    ¬∑ rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', eval‚ÇÇ_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]"
Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean,Orientation.continuousAt_oangle,continuousAt_oangle,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine (Complex.continuousAt_arg_coe_angle ?_).comp? _
  ¬∑ exact o.kahler_ne_zero hx1 hx2
  exact ((continuous_ofReal.comp continuous_inner).add
    ((continuous_ofReal.comp o.areaForm'.continuous‚ÇÇ).mul continuous_const)).continuousAt","error:  invalid field 'comp?', the environment does not contain 'ContinuousAt.comp?'
  continuousAt_arg_coe_angle ?m.9673
has type
  ContinuousAt (Real.Angle.coe ‚àò arg) ?m.9672
error:  invalid field 'comp?', the environment does not contain 'Filter.Tendsto.comp?'
  continuousAt_arg_coe_angle ?m.9673
has type
  Filter.Tendsto (Real.Angle.coe ‚àò arg) (nhds ?m.9672) (nhds ((Real.Angle.coe ‚àò arg) ?m.9672))
error:  invalid field 'comp?', the environment does not contain 'LE.le.comp?'
  continuousAt_arg_coe_angle ?m.9673
has type
  Filter.map (Real.Angle.coe ‚àò arg) (nhds ?m.9672) ‚â§ nhds ((Real.Angle.coe ‚àò arg) ?m.9672)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  continuousAt_arg_coe_angle ?m.9673
has type
  ?m.9674 ‚àà nhds ((Real.Angle.coe ‚àò arg) ?m.9672) ‚Üí ?m.9674 ‚àà Filter.map (Real.Angle.coe ‚àò arg) (nhds ?m.9672)
error:  no goals to be solved","theorem continuousAt_oangle {x : V √ó V} (hx1 : x.1 ‚â† 0) (hx2 : x.2 ‚â† 0) :
    ContinuousAt (fun y : V √ó V => o.oangle y.1 y.2) x ",":= by
  refine (Complex.continuousAt_arg_coe_angle ?_).comp ?_
  ¬∑ exact o.kahler_ne_zero hx1 hx2
  exact ((continuous_ofReal.comp continuous_inner).add
    ((continuous_ofReal.comp o.areaForm'.continuous‚ÇÇ).mul continuous_const)).continuousAt"
Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean,MeasurableSpace.measurableSet_generateFrom_memPartition,measurableSet_generateFrom_memPartition,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®S, hS_subset, hS_eq‚ü© ‚Ü¶ ?_‚ü©
  ¬∑ refine MeasurableSpace.generateFrom_induction
      (p := fun u ‚Ü¶ ‚àÉ S : Finset (Set Œ±), ‚ÜëS ‚äÜ memPartition t n ‚àß u = ‚ãÉ‚ÇÄ ‚ÜëS)
      (C := memPartition t n) ?_ ?_ ?_ ?_ h
    ¬∑ exact fun u hu ‚Ü¶ ‚ü®{u}, by simp [hu], by simp‚ü©
    ¬∑ exact ‚ü®‚àÖ, by simp, by simp‚ü©
    ¬∑ rintro u ‚ü®S, hS_subset, rfl‚ü©
      classical
      refine ‚ü®(memPartition t n).toFinset \ S, ?_, ?_‚ü©
      ¬∑ simp only [Finset.coe_sdiff, coe_toFinset]
        exact diff_subset _ _
      ¬∑ simp only [Finset.coe_sdiff, coe_toFinset]
        refine (IsCompl.eq_compl ‚ü®?_, ?_‚ü©).symm
        ¬∑ refine Set.disjoint_sUnion_right.mpr fun u huS => ?_
          refine Set.disjoint_sUnion_left.mpr fun v huV => ?_
          refine disjoint_memPartition t n (mem_of_mem_diff huV) (hS_subset huS) ?_
          exact ne_of_mem_of_not_mem huS (not_mem_of_mem_diff huV) |>.symm
        ¬∑ rw [codisjoint_iff]
          simp only [sup_eq_union, top_eq_univ]
          rw [‚Üê sUnion_memPartition t n, union_comm, ‚Üê sUnion_union, union_diff_cancel hS_subset]
    ¬∑ intro f h
      choose S hS_subset hS_eq using h
      have : Fintype (‚ãÉ n, (S n : Set (Set Œ±))) := by
        refine (Finite.subset (finite_memPartition t n) ?_).fintype
        simp only [iUnion_subset_iff]
        exact hS_subset
      refine ‚ü®(‚ãÉ n, (S n : Set (Set Œ±))).toFinset, ?_, ?_‚ü©
      ¬∑ simp only [coe_toFinset, iUnion_subset_iff]
        exact hS_subset
      ¬∑ simp only [coe_toFinset, sUnion_iUnion, hS_eq]
  ¬∑ rw [hS_eq, sUnion_eq_biUnion]
    refine MeasurableSet.biUnion ?_ (fun t ht ‚Ü¶ ?_)
    ¬∑ exact S.countable_toSet
    ¬∑ exact measurableSet_generateFrom (hS_subset ht)","error:  function expected at
  diff_subset ?m.43731
term has type
  ?m.43730 ‚àà ?m.43728","lemma measurableSet_generateFrom_memPartition_iff (t : ‚Ñï ‚Üí Set Œ±) (n : ‚Ñï) (s : Set Œ±) :
    MeasurableSet[generateFrom (memPartition t n)] s
      ‚Üî ‚àÉ S : Finset (Set Œ±), ‚ÜëS ‚äÜ memPartition t n ‚àß s = ‚ãÉ‚ÇÄ S ",":= by
  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®S, hS_subset, hS_eq‚ü© ‚Ü¶ ?_‚ü©
  ¬∑ refine MeasurableSpace.generateFrom_induction
      (p := fun u ‚Ü¶ ‚àÉ S : Finset (Set Œ±), ‚ÜëS ‚äÜ memPartition t n ‚àß u = ‚ãÉ‚ÇÄ ‚ÜëS)
      (C := memPartition t n) ?_ ?_ ?_ ?_ h
    ¬∑ exact fun u hu ‚Ü¶ ‚ü®{u}, by simp [hu], by simp‚ü©
    ¬∑ exact ‚ü®‚àÖ, by simp, by simp‚ü©
    ¬∑ rintro u ‚ü®S, hS_subset, rfl‚ü©
      classical
      refine ‚ü®(memPartition t n).toFinset \ S, ?_, ?_‚ü©
      ¬∑ simp only [Finset.coe_sdiff, coe_toFinset]
        exact diff_subset
      ¬∑ simp only [Finset.coe_sdiff, coe_toFinset]
        refine (IsCompl.eq_compl ‚ü®?_, ?_‚ü©).symm
        ¬∑ refine Set.disjoint_sUnion_right.mpr fun u huS => ?_
          refine Set.disjoint_sUnion_left.mpr fun v huV => ?_
          refine disjoint_memPartition t n (mem_of_mem_diff huV) (hS_subset huS) ?_
          exact ne_of_mem_of_not_mem huS (not_mem_of_mem_diff huV) |>.symm
        ¬∑ rw [codisjoint_iff]
          simp only [sup_eq_union, top_eq_univ]
          rw [‚Üê sUnion_memPartition t n, union_comm, ‚Üê sUnion_union, union_diff_cancel hS_subset]
    ¬∑ intro f h
      choose S hS_subset hS_eq using h
      have : Fintype (‚ãÉ n, (S n : Set (Set Œ±))) := by
        refine (Finite.subset (finite_memPartition t n) ?_).fintype
        simp only [iUnion_subset_iff]
        exact hS_subset
      refine ‚ü®(‚ãÉ n, (S n : Set (Set Œ±))).toFinset, ?_, ?_‚ü©
      ¬∑ simp only [coe_toFinset, iUnion_subset_iff]
        exact hS_subset
      ¬∑ simp only [coe_toFinset, sUnion_iUnion, hS_eq]
  ¬∑ rw [hS_eq, sUnion_eq_biUnion]
    refine MeasurableSet.biUnion ?_ (fun t ht ‚Ü¶ ?_)
    ¬∑ exact S.countable_toSet
    ¬∑ exact measurableSet_generateFrom (hS_subset ht)"
Mathlib/NumberTheory/NumberField/CanonicalEmbedding/Basic.lean,NumberField.mixedEmbedding.norm_eq_norm,norm_eq_norm,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  simp_rw [‚Üê prod_eq_abs_norm, mixedEmbedding.norm, mixedEmbedding, RingHom.prod_apply,
    MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, Pi.ringHom_apply, norm_embedding_eq,
    norm_embedding_of_isReal]
  rw [‚Üê Fintype.prod_subtype_mul_prod_subtype (fun w : InfinitePlace K ‚Ü¶ IsReal w)]
  congr 1
  ¬∑ exact Finset.prod_congr rfl (fun w _ ‚Ü¶ by rw [mult, if_pos w.prop, pow_one])
  ¬∑ refine (Fintype.prod_equiv (Equiv.subtypeEquivRight ?_) _ _ (fun w ‚Ü¶ ?_)).symm
    ¬∑ exact fun _ ‚Ü¶ not_isReal_iff_isComplex
    ¬∑ rw [Equiv.subtypeEquivRight_apply_coe, mult, if_neg w.prop]",error:  simp made no progress,"theorem norm_eq_norm (x : K) :
    mixedEmbedding.norm (mixedEmbedding K x) = |Algebra.norm ‚Ñö x| ",":= by
  simp_rw [mixedEmbedding.norm_apply, normAtPlace_apply, prod_eq_abs_norm]"
Mathlib/GroupTheory/SpecificGroups/Cyclic.lean,card_orderOf_eq_totient_aux‚ÇÇ,card_orderOf_eq_totient_aux‚ÇÇ,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  let c := Fintype.card Œ±
  have hc0 : 0 < c := Fintype.card_pos_iff.2 ‚ü®1‚ü©
  apply card_orderOf_eq_totient_aux‚ÇÅ hn hd
  by_contra h0
  simp_rw [not_lt, Nat.le_zero, Finset.card_eq_zero] at h0
  apply lt_irrefl c
  calc
    c = ‚àë m in c.divisors, (univ.filter fun a : Œ± => orderOf a = m).card := by
      simp only [‚Üê filter_dvd_eq_divisors hc0.ne', sum_card_orderOf_eq_card_pow_eq_one hc0.ne']
      apply congr_arg card
      simp [c]
    _ = ‚àë m in c.divisors.erase d, (univ.filter fun a : Œ± => orderOf a = m).card := by
      rw [eq_comm]
      refine' sum_subset (erase_subset _ _) fun m hm‚ÇÅ hm‚ÇÇ => _
      have : m = d := by
        contrapose! hm‚ÇÇ
        exact mem_erase_of_ne_of_mem hm‚ÇÇ hm‚ÇÅ
      simp [this, h0]
    _ ‚â§ ‚àë m in c.divisors.erase d, œÜ m := by
      refine' sum_le_sum fun m hm => _
      have hmc : m ‚à£ c := by
        simp only [mem_erase, mem_divisors] at hm
        tauto
      rcases (filter (fun a : Œ± => orderOf a = m) univ).card.eq_zero_or_pos with (h1 | h1)
      ¬∑ simp [h1]
      ¬∑ simp [card_orderOf_eq_totient_aux‚ÇÅ hn hmc h1]
    _ < ‚àë m in c.divisors, œÜ m :=
      (sum_erase_lt_of_pos (mem_divisors.2 ‚ü®hd, hc0.ne'‚ü©) (totient_pos (pos_of_dvd_of_pos hd hc0)))
    _ = c := sum_totient _","error:  function expected at
  totient_pos
term has type
  0 < œÜ ?m.80669 ‚Üî 0 < ?m.80669","theorem card_orderOf_eq_totient_aux‚ÇÇ {d : ‚Ñï} (hd : d ‚à£ Fintype.card Œ±) :
    (univ.filter fun a : Œ± => orderOf a = d).card = œÜ d ",":= by
  let c := Fintype.card Œ±
  have hc0 : 0 < c := Fintype.card_pos_iff.2 ‚ü®1‚ü©
  apply card_orderOf_eq_totient_aux‚ÇÅ hn hd
  by_contra h0
  simp_rw [not_lt, Nat.le_zero, Finset.card_eq_zero] at h0
  apply lt_irrefl c
  calc
    c = ‚àë m ‚àà c.divisors, (univ.filter fun a : Œ± => orderOf a = m).card := by
      simp only [‚Üê filter_dvd_eq_divisors hc0.ne', sum_card_orderOf_eq_card_pow_eq_one hc0.ne']
      apply congr_arg card
      simp [c]
    _ = ‚àë m ‚àà c.divisors.erase d, (univ.filter fun a : Œ± => orderOf a = m).card := by
      rw [eq_comm]
      refine sum_subset (erase_subset _ _) fun m hm‚ÇÅ hm‚ÇÇ => ?_
      have : m = d := by
        contrapose! hm‚ÇÇ
        exact mem_erase_of_ne_of_mem hm‚ÇÇ hm‚ÇÅ
      simp [this, h0]
    _ ‚â§ ‚àë m ‚àà c.divisors.erase d, œÜ m := by
      refine sum_le_sum fun m hm => ?_
      have hmc : m ‚à£ c := by
        simp only [mem_erase, mem_divisors] at hm
        tauto
      rcases (filter (fun a : Œ± => orderOf a = m) univ).card.eq_zero_or_pos with (h1 | h1)
      ¬∑ simp [h1]
      ¬∑ simp [card_orderOf_eq_totient_aux‚ÇÅ hn hmc h1]
    _ < ‚àë m ‚àà c.divisors, œÜ m :=
      sum_erase_lt_of_pos (mem_divisors.2 ‚ü®hd, hc0.ne'‚ü©) (totient_pos.2 (pos_of_dvd_of_pos hd hc0))
    _ = c := sum_totient _"
Mathlib/FieldTheory/SeparableDegree.lean,minpoly.natSepDegree_eq_one_iff_eq_X_sub_C_pow,natSepDegree_eq_one_iff_eq_X_sub_C_pow,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  haveI := expChar_of_injective_algebraMap (algebraMap F E).injective q
  haveI := expChar_of_injective_algebraMap (NoZeroSMulDivisors.algebraMap_injective E E[X]) q
  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®n, h‚ü© ‚Ü¶ (natSepDegree_eq_one_iff_mem_pow q).2 ?_‚ü©
  ¬∑ obtain ‚ü®n, y, h‚ü© := (natSepDegree_eq_one_iff_eq_X_pow_sub_C q).1 h
    have hx := congr_arg (Polynomial.aeval x) h.symm
    rw [minpoly.aeval, map_sub, map_pow, aeval_X, aeval_C, sub_eq_zero, eq_comm] at hx
    use n
    rw [h, Polynomial.map_sub, Polynomial.map_pow, map_X, map_C, hx, map_pow, ‚Üê sub_pow_expChar_pow]
  apply_fun constantCoeff at h
  simp_rw [map_pow, map_sub, constantCoeff_apply, coeff_map, coeff_X_zero, coeff_C_zero] at h
  rw [zero_sub, neg_pow, ExpChar.neg_one_pow_expChar_pow] at h
  exact ‚ü®n, -(minpoly F x).coeff 0, by rw [map_neg, h]; ring1‚ü©","error:  unknown identifier 'natSepDegree_eq_one_iff_mem_pow'
error:  no goals to be solved","theorem natSepDegree_eq_one_iff_eq_X_sub_C_pow : (minpoly F x).natSepDegree = 1 ‚Üî
    ‚àÉ n : ‚Ñï, (minpoly F x).map (algebraMap F E) = (X - C x) ^ q ^ n ",":= by
  haveI := expChar_of_injective_algebraMap (algebraMap F E).injective q
  haveI := expChar_of_injective_algebraMap (NoZeroSMulDivisors.algebraMap_injective E E[X]) q
  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®n, h‚ü© ‚Ü¶ (natSepDegree_eq_one_iff_pow_mem q).2 ?_‚ü©
  ¬∑ obtain ‚ü®n, y, h‚ü© := (natSepDegree_eq_one_iff_eq_X_pow_sub_C q).1 h
    have hx := congr_arg (Polynomial.aeval x) h.symm
    rw [minpoly.aeval, map_sub, map_pow, aeval_X, aeval_C, sub_eq_zero, eq_comm] at hx
    use n
    rw [h, Polynomial.map_sub, Polynomial.map_pow, map_X, map_C, hx, map_pow, ‚Üê sub_pow_expChar_pow]
  apply_fun constantCoeff at h
  simp_rw [map_pow, map_sub, constantCoeff_apply, coeff_map, coeff_X_zero, coeff_C_zero] at h
  rw [zero_sub, neg_pow, ExpChar.neg_one_pow_expChar_pow] at h
  exact ‚ü®n, -(minpoly F x).coeff 0, by rw [map_neg, h]; ring1‚ü©"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,a380f5a603bf5030bc30e58b1aed19567f67b98d,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120516 ‚Üí ?m.120516
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.124403 ‚Üí ?m.124403
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà id ‚àÖ, closedBall p.1 p.2) ‚â§ Œº s
error:  type mismatch
  mul_le_mul_left' IH (‚ÜëN / (‚ÜëN + 1))
has type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * ((‚ÜëN / (‚ÜëN + 1)) ^ n * Œº s) : Prop
but is expected to have type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ (‚ÜëN / (‚ÜëN + 1)) ^ n * (‚ÜëN / (‚ÜëN + 1) * Œº s) : Prop
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.134258 ‚Üí ?m.134258 ‚Üí Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.134394 ‚Üí ?m.134394 ‚Üí Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/Order/Monotone/Extension.lean,MonotoneOn.exists_monotone_extension,MonotoneOn.exists_monotone_extension,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  classical
    rcases hl with ‚ü®a, ha‚ü©
    have hu' : ‚àÄ x, BddAbove (f '' (Iic x ‚à© s)) := fun x =>
      hu.mono (image_subset _ (inter_subset_right _ _))
    let g : Œ± ‚Üí Œ≤ := fun x => if Disjoint (Iic x) s then a else sSup (f '' (Iic x ‚à© s))
    have hgs : EqOn f g s := by
      intro x hx
      simp only [g]
      have : IsGreatest (Iic x ‚à© s) x := ‚ü®‚ü®right_mem_Iic, hx‚ü©, fun y hy => hy.1‚ü©
      rw [if_neg this.nonempty.not_disjoint,
        ((h.mono <| inter_subset_right _ _).map_isGreatest this).csSup_eq]
    refine ‚ü®g, fun x y hxy => ?_, hgs‚ü©
    by_cases hx : Disjoint (Iic x) s <;> by_cases hy : Disjoint (Iic y) s <;>
      simp only [g, if_pos, if_neg, not_false_iff, *, refl]
    ¬∑ rcases not_disjoint_iff_nonempty_inter.1 hy with ‚ü®z, hz‚ü©
      exact le_csSup_of_le (hu' _) (mem_image_of_mem _ hz) (ha <| mem_image_of_mem _ hz.2)
    ¬∑ exact (hx <| hy.mono_left <| Iic_subset_Iic.2 hxy).elim
    ¬∑ rw [not_disjoint_iff_nonempty_inter] at hx hy
      refine csSup_le_csSup (hu' _) (hx.image _) (image_subset _ ?_)
      exact inter_subset_inter_left _ (Iic_subset_Iic.2 hxy)","error:  function expected at
  inter_subset_right ?m.942
term has type
  ?m.941 ‚àà ?m.940
error:  function expected at
  inter_subset_right ?m.1774
term has type
  ?m.1773 ‚àà ?m.1772","theorem MonotoneOn.exists_monotone_extension (h : MonotoneOn f s) (hl : BddBelow (f '' s))
    (hu : BddAbove (f '' s)) : ‚àÉ g : Œ± ‚Üí Œ≤, Monotone g ‚àß EqOn f g s ",":= by
  classical
    rcases hl with ‚ü®a, ha‚ü©
    have hu' : ‚àÄ x, BddAbove (f '' (Iic x ‚à© s)) := fun x =>
      hu.mono (image_subset _ inter_subset_right)
    let g : Œ± ‚Üí Œ≤ := fun x => if Disjoint (Iic x) s then a else sSup (f '' (Iic x ‚à© s))
    have hgs : EqOn f g s := by
      intro x hx
      simp only [g]
      have : IsGreatest (Iic x ‚à© s) x := ‚ü®‚ü®right_mem_Iic, hx‚ü©, fun y hy => hy.1‚ü©
      rw [if_neg this.nonempty.not_disjoint,
        ((h.mono inter_subset_right).map_isGreatest this).csSup_eq]
    refine ‚ü®g, fun x y hxy => ?_, hgs‚ü©
    by_cases hx : Disjoint (Iic x) s <;> by_cases hy : Disjoint (Iic y) s <;>
      simp only [g, if_pos, if_neg, not_false_iff, *, refl]
    ¬∑ rcases not_disjoint_iff_nonempty_inter.1 hy with ‚ü®z, hz‚ü©
      exact le_csSup_of_le (hu' _) (mem_image_of_mem _ hz) (ha <| mem_image_of_mem _ hz.2)
    ¬∑ exact (hx <| hy.mono_left <| Iic_subset_Iic.2 hxy).elim
    ¬∑ rw [not_disjoint_iff_nonempty_inter] at hx hy
      refine csSup_le_csSup (hu' _) (hx.image _) (image_subset _ ?_)
      exact inter_subset_inter_left _ (Iic_subset_Iic.2 hxy)"
Mathlib/Algebra/Module/Torsion.lean,Ideal.CompleteLattice.Independent.linear_independent',CompleteLattice.Independent.linear_independent',596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine linearIndependent_iff_not_smul_mem_span.mpr fun i r hi => ?_
  replace hv := CompleteLattice.independent_def.mp hv i
  simp only [iSup_subtype', ‚Üê Submodule.span_range_eq_iSup (Œπ := Subtype _), disjoint_iff] at hv
  have : r ‚Ä¢ v i ‚àà ‚ä• := by
    rw [‚Üê hv, Submodule.mem_inf]
    refine ‚ü®Submodule.mem_span_singleton.mpr ‚ü®r, rfl‚ü©, ?_‚ü©
    convert hi
    ext
    simp
  rw [‚Üê Submodule.mem_bot R, ‚Üê h_ne_zero i]
  simpa using this","error:  typeclass instance problem is stuck, it is often due to metavariables
  Membership M ?m.17958","theorem CompleteLattice.Independent.linear_independent' {Œπ R M : Type*} {v : Œπ ‚Üí M} [Ring R]
    [AddCommGroup M] [Module R M] (hv : CompleteLattice.Independent fun i => R ‚àô v i)
    (h_ne_zero : ‚àÄ i, Ideal.torsionOf R M (v i) = ‚ä•) : LinearIndependent R v ",":= by
  refine linearIndependent_iff_not_smul_mem_span.mpr fun i r hi => ?_
  replace hv := CompleteLattice.independent_def.mp hv i
  simp only [iSup_subtype', ‚Üê Submodule.span_range_eq_iSup (Œπ := Subtype _), disjoint_iff] at hv
  have : r ‚Ä¢ v i ‚àà (‚ä• : Submodule R M) := by
    rw [‚Üê hv, Submodule.mem_inf]
    refine ‚ü®Submodule.mem_span_singleton.mpr ‚ü®r, rfl‚ü©, ?_‚ü©
    convert hi
    ext
    simp
  rw [‚Üê Submodule.mem_bot R, ‚Üê h_ne_zero i]
  simpa using this"
Mathlib/Computability/AkraBazzi/AkraBazzi.lean,AkraBazziRecurrence.rpow_p_mul_one_add_smoothingFn_ge,rpow_p_mul_one_add_smoothingFn_ge,399f04bf3c57d43d9f70a32662007a7562003890,":= by
  rw [Filter.eventually_all]
  intro i
  let q : ‚Ñù ‚Üí ‚Ñù := fun x => x ^ (p a b) * (1 + Œµ x)
  have h_diff_q : DifferentiableOn ‚Ñù q (Set.Ioi 1) := by
    refine DifferentiableOn.mul
        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)
        differentiableOn_one_add_smoothingFn
    rw [Set.mem_compl_singleton_iff]
    rw [Set.mem_Ioi] at hz
    exact ne_of_gt <| zero_lt_one.trans hz
  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc
    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + Œµ z) x := by rfl
          _ =·∂†[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + Œµ x)
              + x ^ (p a b) * deriv (fun z => 1 + Œµ z) x := by
                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'
                rw [deriv_mul] <;> aesop
          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by
                refine IsBigO.add ?left ?right
                case left => calc
                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + Œµ x))
                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + Œµ x) := by
                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)
                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=
                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO
                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]
                case right => calc
                  (fun x => x ^ (p a b) * deriv (fun z => 1 + Œµ z) x)
                      =O[atTop] (fun x => x ^ (p a b) * x‚Åª¬π) := by
                        exact IsBigO.mul (isBigO_refl _ _)
                          isLittleO_deriv_one_add_smoothingFn.isBigO
                    _ =·∂†[atTop] fun x => x ^ ((p a b) - 1) := by
                        filter_upwards [eventually_gt_atTop 0] with x hx
                        rw [‚Üê Real.rpow_neg_one, ‚Üê Real.rpow_add hx, ‚Üê sub_eq_add_neg]
  have h_main_norm : (fun (n:‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ)
      ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ := by
    refine IsLittleO.eventuallyLE ?_
    calc
      (fun (n:‚Ñï) => q (r i n) - q (b i * n))
          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by
            exact R.isBigO_apply_r_sub_b q h_diff_q
              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i
        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by
            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)
        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by
            exact IsBigO.mul (IsBigO.nat_cast_atTop h_deriv_q) (isBigO_refl _ _)
        _ =·∂†[atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by
            filter_upwards [eventually_ne_atTop 0] with n hn
            have hn' : (n:‚Ñù) ‚â† 0 := by positivity
            simp [‚Üê mul_div_assoc, ‚Üê Real.rpow_add_one hn']
        _ = fun (n:‚Ñï) => (n:‚Ñù) ^ (p a b) * (1 / (log n) ^ 2)   := by simp_rw [mul_div, mul_one]
        _ =Œò[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) := by
            refine IsTheta.symm ?_
            simp_rw [mul_assoc]
            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)
            have := R.b_pos i; positivity
        _ =Œò[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)
                  <| R.isTheta_smoothingFn_sub_self i
  have h_main : (fun (n:‚Ñï) => q (b i * n) - q (r i n))
      ‚â§·∂†[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
    calc (fun (n:‚Ñï) => q (b i * n) - q (r i n))
           ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ := by
              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _
         _ ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ :=
              h_main_norm
         _ =·∂†[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
              filter_upwards [eventually_gt_atTop ‚åà(b i)‚Åª¬π‚åâ‚Çä, eventually_gt_atTop 1] with n hn hn'
              refine norm_of_nonneg ?_
              have h‚ÇÅ := R.b_pos i
              have h‚ÇÇ : 0 ‚â§ Œµ (b i * n) - Œµ n := by
                refine sub_nonneg_of_le <|
                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le
                case n_gt_one =>
                  show 1 < (n:‚Ñù)
                  rw [Nat.one_lt_cast]
                  exact hn'
                case bn_gt_one =>
                  calc 1 = b i * (b i)‚Åª¬π := by rw [mul_inv_cancel (by positivity)]
                      _ ‚â§ b i * ‚åà(b i)‚Åª¬π‚åâ‚Çä := by gcongr; exact Nat.le_ceil _
                      _ < b i * n := by gcongr; rw [Nat.cast_lt]; exact hn
                case le => calc b i * n ‚â§ 1 * n := by have := R.b_lt_one i; gcongr
                                        _ = n := by rw [one_mul]
              positivity
  filter_upwards [h_main] with n hn
  have h‚ÇÅ : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)
      = (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n) := by
    have := R.b_pos i
    simp only [mul_rpow (by positivity : (0:‚Ñù) ‚â§ b i) (by positivity : (0:‚Ñù) ‚â§ n)]
    ring
  show (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n) ‚â§ q (r i n)
  rw [‚Üê h‚ÇÅ, sub_le_iff_le_add', ‚Üê sub_le_iff_le_add]
  exact hn","warning:  `Asymptotics.IsBigO.nat_cast_atTop` has been deprecated, use `Asymptotics.IsBigO.natCast_atTop` instead
error:  simp made no progress","lemma rpow_p_mul_one_add_smoothingFn_ge :
    ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n)
      ‚â§ (r i n) ^ (p a b) * (1 + Œµ (r i n)) ",":= by
  rw [Filter.eventually_all]
  intro i
  let q : ‚Ñù ‚Üí ‚Ñù := fun x => x ^ (p a b) * (1 + Œµ x)
  have h_diff_q : DifferentiableOn ‚Ñù q (Set.Ioi 1) := by
    refine DifferentiableOn.mul
        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)
        differentiableOn_one_add_smoothingFn
    rw [Set.mem_compl_singleton_iff]
    rw [Set.mem_Ioi] at hz
    exact ne_of_gt <| zero_lt_one.trans hz
  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc
    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + Œµ z) x := by rfl
          _ =·∂†[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + Œµ x)
              + x ^ (p a b) * deriv (fun z => 1 + Œµ z) x := by
                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'
                rw [deriv_mul] <;> aesop
          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by
                refine IsBigO.add ?left ?right
                case left => calc
                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + Œµ x))
                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + Œµ x) := by
                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)
                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=
                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO
                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]
                case right => calc
                  (fun x => x ^ (p a b) * deriv (fun z => 1 + Œµ z) x)
                      =O[atTop] (fun x => x ^ (p a b) * x‚Åª¬π) := by
                        exact IsBigO.mul (isBigO_refl _ _)
                          isLittleO_deriv_one_add_smoothingFn.isBigO
                    _ =·∂†[atTop] fun x => x ^ ((p a b) - 1) := by
                        filter_upwards [eventually_gt_atTop 0] with x hx
                        rw [‚Üê Real.rpow_neg_one, ‚Üê Real.rpow_add hx, ‚Üê sub_eq_add_neg]
  have h_main_norm : (fun (n:‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ)
      ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ := by
    refine IsLittleO.eventuallyLE ?_
    calc
      (fun (n:‚Ñï) => q (r i n) - q (b i * n))
          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by
            exact R.isBigO_apply_r_sub_b q h_diff_q
              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i
        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by
            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)
        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by
            exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)
        _ =·∂†[atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by
            filter_upwards [eventually_ne_atTop 0] with n hn
            have hn' : (n:‚Ñù) ‚â† 0 := by positivity
            simp [‚Üê mul_div_assoc, ‚Üê Real.rpow_add_one hn']
        _ = fun (n:‚Ñï) => (n:‚Ñù) ^ (p a b) * (1 / (log n) ^ 2)   := by simp_rw [mul_div, mul_one]
        _ =Œò[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) := by
            refine IsTheta.symm ?_
            simp_rw [mul_assoc]
            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)
            have := R.b_pos i; positivity
        _ =Œò[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)
                  <| R.isTheta_smoothingFn_sub_self i
  have h_main : (fun (n:‚Ñï) => q (b i * n) - q (r i n))
      ‚â§·∂†[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
    calc (fun (n:‚Ñï) => q (b i * n) - q (r i n))
           ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ := by
              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _
         _ ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ :=
              h_main_norm
         _ =·∂†[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
              filter_upwards [eventually_gt_atTop ‚åà(b i)‚Åª¬π‚åâ‚Çä, eventually_gt_atTop 1] with n hn hn'
              refine norm_of_nonneg ?_
              have h‚ÇÅ := R.b_pos i
              have h‚ÇÇ : 0 ‚â§ Œµ (b i * n) - Œµ n := by
                refine sub_nonneg_of_le <|
                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le
                case n_gt_one =>
                  show 1 < (n:‚Ñù)
                  rw [Nat.one_lt_cast]
                  exact hn'
                case bn_gt_one =>
                  calc 1 = b i * (b i)‚Åª¬π := by rw [mul_inv_cancel (by positivity)]
                      _ ‚â§ b i * ‚åà(b i)‚Åª¬π‚åâ‚Çä := by gcongr; exact Nat.le_ceil _
                      _ < b i * n := by gcongr; rw [Nat.cast_lt]; exact hn
                case le => calc b i * n ‚â§ 1 * n := by have := R.b_lt_one i; gcongr
                                        _ = n := by rw [one_mul]
              positivity
  filter_upwards [h_main] with n hn
  have h‚ÇÅ : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)
      = (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n) := by
    have := R.b_pos i
    simp only [q, mul_rpow (by positivity : (0:‚Ñù) ‚â§ b i) (by positivity : (0:‚Ñù) ‚â§ n)]
    ring
  show (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n) ‚â§ q (r i n)
  rw [‚Üê h‚ÇÅ, sub_le_iff_le_add', ‚Üê sub_le_iff_le_add]
  exact hn"
Mathlib/Combinatorics/SetFamily/CauchyDavenport.lean,Finset.min_le_card_mul,Finset.min_le_card_mul,9f6d33884de569540c527b667d1573e1b97e1347,":= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain ‚ü®rfl, rfl‚ü© := hx
  refine' wellFoundedOn_devosMulRel.induction (P := fun x : Finset Œ± √ó Finset Œ± ‚Ü¶
    min (minOrder Œ±) ‚Üë(card x.1 + card x.2 - 1) ‚â§ card (x.1 * x.2)) ‚ü®hs, ht‚ü© _
  clear! x
  rintro ‚ü®s, t‚ü© ‚ü®hs, ht‚ü© ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  ¬∑ simpa only [‚Üê mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [‚Üê mul_inv_rev, add_comm, card_inv, true_and])
  obtain ‚ü®a, rfl‚ü© | ‚ü®a, ha, b, hb, hab‚ü© := hs.exists_eq_singleton_or_nontrivial
  ¬∑ simp [add_comm]
  obtain ‚ü®g, hg, hgs‚ü© : ‚àÉ g : Œ±, g ‚â† 1 ‚àß (s ‚à© op g ‚Ä¢ s).Nonempty :=
    ‚ü®b‚Åª¬π * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 ‚ü®ha, mem_smul_finset.2 ‚ü®_, hb, by simp‚ü©‚ü©‚ü©
  obtain hsg | hsg := eq_or_ne (op g ‚Ä¢ s) s
  ¬∑ have hS : (zpowers g : Set Œ±) ‚äÜ a‚Åª¬π ‚Ä¢ (s : Set Œ±) := by
      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (¬∑ ‚àà a‚Åª¬π ‚Ä¢ (s : Set Œ±))
        ‚ü®_, ha, inv_mul_self _‚ü© (fun c hc ‚Ü¶ ?_) fun c hc ‚Ü¶ ?_
      ¬∑ rw [‚Üê hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      ¬∑ simp only
        rwa [‚Üê op_smul_eq_mul, op_inv, ‚Üê Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          ‚Üê coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [‚Üê coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s ‚à© op g ‚Ä¢ s).card < s.card := card_lt_card ‚ü®inter_subset_left _ _, fun h ‚Ü¶
    hsg <| eq_of_superset_of_card_ge (h.trans <| inter_subset_right _ _) (card_smul_finset _ _).le‚ü©
  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (g‚Åª¬π ‚Ä¢ t)
  ¬∑ rw [‚Üê card_smul_finset g‚Åª¬π t]
    refine' Or.inr ((add_le_add_right hst _).trans _)
    rw [‚Üê card_union_eq hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  ¬∑ exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h ‚Ü¶ hstg.trans <| h.trans <| add_le_add_right aux1 _
  ¬∑ exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h ‚Ü¶
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _","error:  function expected at
  inter_subset_left ?m.46803
term has type
  ?m.46802 ‚àà ?m.46800
error:  function expected at
  inter_subset_right ?m.46987
term has type
  ?m.46986 ‚àà ?m.46985
warning:  `Finset.card_union_eq` has been deprecated, use `Finset.card_union_of_disjoint` instead","lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder Œ±) ‚Üë(s.card + t.card - 1) ‚â§ (s * t).card ",":= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain ‚ü®rfl, rfl‚ü© := hx
  refine wellFoundedOn_devosMulRel.induction (P := fun x : Finset Œ± √ó Finset Œ± ‚Ü¶
    min (minOrder Œ±) ‚Üë(card x.1 + card x.2 - 1) ‚â§ card (x.1 * x.2)) ‚ü®hs, ht‚ü© ?_
  clear! x
  rintro ‚ü®s, t‚ü© ‚ü®hs, ht‚ü© ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  ¬∑ simpa only [‚Üê mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [‚Üê mul_inv_rev, add_comm, card_inv, true_and])
  obtain ‚ü®a, rfl‚ü© | ‚ü®a, ha, b, hb, hab‚ü© := hs.exists_eq_singleton_or_nontrivial
  ¬∑ simp [add_comm]
  obtain ‚ü®g, hg, hgs‚ü© : ‚àÉ g : Œ±, g ‚â† 1 ‚àß (s ‚à© op g ‚Ä¢ s).Nonempty :=
    ‚ü®b‚Åª¬π * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 ‚ü®ha, mem_smul_finset.2 ‚ü®_, hb, by simp‚ü©‚ü©‚ü©
  obtain hsg | hsg := eq_or_ne (op g ‚Ä¢ s) s
  ¬∑ have hS : (zpowers g : Set Œ±) ‚äÜ a‚Åª¬π ‚Ä¢ (s : Set Œ±) := by
      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (¬∑ ‚àà a‚Åª¬π ‚Ä¢ (s : Set Œ±))
        ‚ü®_, ha, inv_mul_self _‚ü© (fun c hc ‚Ü¶ ?_) fun c hc ‚Ü¶ ?_
      ¬∑ rw [‚Üê hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      ¬∑ simp only
        rwa [‚Üê op_smul_eq_mul, op_inv, ‚Üê Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          ‚Üê coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [‚Üê coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s ‚à© op g ‚Ä¢ s).card < s.card := card_lt_card ‚ü®inter_subset_left, fun h ‚Ü¶
    hsg <| eq_of_superset_of_card_ge (h.trans inter_subset_right) (card_smul_finset _ _).le‚ü©
  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (g‚Åª¬π ‚Ä¢ t)
  ¬∑ rw [‚Üê card_smul_finset g‚Åª¬π t]
    refine Or.inr ((add_le_add_right hst _).trans ?_)
    rw [‚Üê card_union_of_disjoint hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  ¬∑ exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h ‚Ü¶ hstg.trans <| h.trans <| add_le_add_right aux1 _
  ¬∑ exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h ‚Ü¶
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _"
Mathlib/Data/Matroid/Constructions.lean,Matroid.ground_indep_iff_eq_freeOn,ground_indep_iff_eq_freeOn,065587557e6f278858a4849d642d994b856fa980,":= by
  simp",error:  simp made no progress,theorem ground_indep_iff_eq_freeOn : M.Indep M.E ‚Üî M = freeOn M.E ,":= by
  simp [eq_freeOn_iff]"
Mathlib/GroupTheory/Exponent.lean,MonoidHom.exponent_dvd,MonoidHom.exponent_dvd,554c20d1eb6d2f1f6a5b53ccd3a727a93147a4de,":= by
  refine Monoid.exponent_dvd_of_forall_pow_eq_one M‚ÇÇ _ fun m‚ÇÇ ‚Ü¶ ?_
  obtain ‚ü®m‚ÇÅ, rfl‚ü© := hf m‚ÇÇ
  rw [‚Üê map_pow, pow_exponent_eq_one, map_one]","error:  application type mismatch
  exponent_dvd_of_forall_pow_eq_one M‚ÇÇ
argument
  M‚ÇÇ
has type
  Type u_3 : Type (u_3 + 1)
but is expected to have type
  ‚àÄ (g : ?m.92828), g ^ ?m.92830 = 1 : Prop
error:  no goals to be solved","theorem MonoidHom.exponent_dvd {F M‚ÇÅ M‚ÇÇ : Type*} [Monoid M‚ÇÅ] [Monoid M‚ÇÇ]
    [FunLike F M‚ÇÅ M‚ÇÇ] [MonoidHomClass F M‚ÇÅ M‚ÇÇ]
    {f : F} (hf : Function.Surjective f) : exponent M‚ÇÇ ‚à£ exponent M‚ÇÅ ",":= by
  refine Monoid.exponent_dvd_of_forall_pow_eq_one fun m‚ÇÇ ‚Ü¶ ?_
  obtain ‚ü®m‚ÇÅ, rfl‚ü© := hf m‚ÇÇ
  rw [‚Üê map_pow, pow_exponent_eq_one, map_one]"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,1bab9e3823740c27026995d4c01c24399c2a8dfa,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ 
      sorry
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero, Nat.zero_eq,
          Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.123443 ‚Üí ?m.123443
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà id ‚àÖ, closedBall p.1 p.2) ‚â§ Œº s
error:  type mismatch
  mul_le_mul_left' IH (‚ÜëN / (‚ÜëN + 1))
has type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * ((‚ÜëN / (‚ÜëN + 1)) ^ n * Œº s) : Prop
but is expected to have type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ (‚ÜëN / (‚ÜëN + 1)) ^ n * (‚ÜëN / (‚ÜëN + 1) * Œº s) : Prop
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133298 ‚Üí ?m.133298 ‚Üí Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133434 ‚Üí ?m.133434 ‚Üí Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/Data/List/NodupEquivFin.lean,List.sublist_iff_exists_fin_orderEmbedding_get_eq,sublist_iff_exists_fin_orderEmbedding_get_eq,8c7b65ad8326d1219cff9e2e020db7b7d6fcee26,":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï} (_ : i < l.length), f i < l'.length :=
      by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine' ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) _, _‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [get?_eq_get i.2, get?_eq_get (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine'
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          _,
        _‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ rw [add_comm]
        exact lt_add_of_lt_of_pos (Fin.is_lt _) (i.zero_le.trans_lt h)
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi
  list.sublist_iff_exists_fin_order_embedding_nth_le_eq
  List.sublist_iff_exists_fin_orderEmbedding_get_eq","error:  unknown tactic
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem sublist_iff_exists_fin_orderEmbedding_get_eq {l l' : List Œ±} :
    l <+ l' ‚Üî
      ‚àÉ f : Fin l.length ‚Ü™o Fin l'.length,
        ‚àÄ ix : Fin l.length, l.get ix = l'.get (f ix) ",":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï}, i < l.length ‚Üí f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) ?_, ?_‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [getElem?_eq_getElem i.2, getElem?_eq_getElem (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          ?_,
        ?_‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ have := (f ‚ü®i, hi‚ü©).is_lt
        omega
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi"
Mathlib/RingTheory/DedekindDomain/Different.lean,FractionalIdeal.dual_inv,dual_inv,3465d1aaae242475fad59e688648a2285031d19e,":= by
  by_cases hI : I = 0; ¬∑ simp [hI]
  convert mul_right_mono ((dual A K I)‚Åª¬π)
    (mul_left_mono I (inv_le_dual (A := A) (K := K) I)) using 1
  ¬∑ simp only [mul_inv_cancel hI, one_mul]
  ¬∑ simp only [mul_inv_cancel (dual_ne_zero (hI := hI)), mul_assoc, mul_one]","error:  failed to synthesize
  CommRing A
use `set_option diagnostics true` to get diagnostic information
error:  unsolved goals
case h.e'_4
A : Type u_1
K : Type u_2
L : Type u
B : Type u_3
inst‚úù¬π‚Åπ : CommRing A
inst‚úù¬π‚Å∏ : Field K
inst‚úù¬π‚Å∑ : CommRing B
inst‚úù¬π‚Å∂ : Field L
inst‚úù¬π‚Åµ : Algebra A K
inst‚úù¬π‚Å¥ : Algebra B L
inst‚úù¬π¬≥ : Algebra A B
inst‚úù¬π¬≤ : Algebra K L
inst‚úù¬π¬π : Algebra A L
inst‚úù¬π‚Å∞ : IsScalarTower A K L
inst‚úù‚Åπ : IsScalarTower A B L
inst‚úù‚Å∏ : IsDomain A
inst‚úù‚Å∑ : IsDomain B
inst‚úù‚Å∂ : IsFractionRing A K
inst‚úù‚Åµ : IsIntegralClosure B A L
inst‚úù‚Å¥ : IsFractionRing B L
inst‚úù¬≥ : FiniteDimensional K L
inst‚úù¬≤ : IsSeparable K L
inst‚úù¬π : IsIntegrallyClosed A
inst‚úù : IsDedekindDomain B
I J : FractionalIdeal B‚Å∞ L
hI‚úù : I ‚â† 0
hJ : J ‚â† 0
hI : ¬¨I = 0
‚ä¢ I = I * (dual A K I * (dual A K I)‚Åª¬π)","lemma dual_inv_le :
    (dual A K I)‚Åª¬π ‚â§ I ",":= by
  by_cases hI : I = 0; ¬∑ simp [hI]
  convert mul_right_mono ((dual A K I)‚Åª¬π)
    (mul_left_mono I (inv_le_dual A K I)) using 1
  ¬∑ simp only [mul_inv_cancel hI, one_mul]
  ¬∑ simp only [mul_inv_cancel (dual_ne_zero A K (hI := hI)), mul_assoc, mul_one]"
Mathlib/Topology/Separation.lean,IsCompact.finite_compact_cover,IsCompact.finite_compact_cover,25e538f3a737a71314ac143929711e67d0b14d73,":= by
  induction' t with x t hx ih generalizing U s
  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => isCompact_empty, fun i => empty_subset _, ?_‚ü©
    simpa only [subset_empty_iff, Finset.not_mem_empty, iUnion_false, iUnion_empty] using hsC
  simp only [Finset.set_biUnion_insert] at hsC
  simp only [Finset.forall_mem_insert] at hU
  have hU' : ‚àÄ i ‚àà t, IsOpen (U i) := fun i hi => hU.2 i hi
  rcases hs.binary_compact_cover hU.1 (isOpen_biUnion hU') hsC with
    ‚ü®K‚ÇÅ, K‚ÇÇ, h1K‚ÇÅ, h1K‚ÇÇ, h2K‚ÇÅ, h2K‚ÇÇ, hK‚ü©
  rcases ih h1K‚ÇÇ U hU' h2K‚ÇÇ with ‚ü®K, h1K, h2K, h3K‚ü©
  refine ‚ü®update K x K‚ÇÅ, ?_, ?_, ?_‚ü©
  ¬∑ intro i
    rcases eq_or_ne i x with rfl | hi
    ¬∑ simp only [update_same, h1K‚ÇÅ]
    ¬∑ simp only [update_noteq hi, h1K]
  ¬∑ intro i
    rcases eq_or_ne i x with rfl | hi
    ¬∑ simp only [update_same, h2K‚ÇÅ]
    ¬∑ simp only [update_noteq hi, h2K]
  ¬∑ simp only [Finset.set_biUnion_insert_update _ hx, hK, h3K]","error:  type mismatch
  h‚úù
has type
  s ‚äÜ ‚ãÉ i ‚àà { val := x, nodup := t }, U i : Prop
but is expected to have type
  s = ‚àÖ : Prop
error:  no goals to be solved","theorem IsCompact.finite_compact_cover {s : Set X} (hs : IsCompact s) {Œπ : Type*}
    (t : Finset Œπ) (U : Œπ ‚Üí Set X) (hU : ‚àÄ i ‚àà t, IsOpen (U i)) (hsC : s ‚äÜ ‚ãÉ i ‚àà t, U i) :
    ‚àÉ K : Œπ ‚Üí Set X, (‚àÄ i, IsCompact (K i)) ‚àß (‚àÄ i, K i ‚äÜ U i) ‚àß s = ‚ãÉ i ‚àà t, K i ",":= by
  induction' t using Finset.induction with x t hx ih generalizing U s
  ¬∑ refine ‚ü®fun _ => ‚àÖ, fun _ => isCompact_empty, fun i => empty_subset _, ?_‚ü©
    simpa only [subset_empty_iff, Finset.not_mem_empty, iUnion_false, iUnion_empty] using hsC
  simp only [Finset.set_biUnion_insert] at hsC
  simp only [Finset.forall_mem_insert] at hU
  have hU' : ‚àÄ i ‚àà t, IsOpen (U i) := fun i hi => hU.2 i hi
  rcases hs.binary_compact_cover hU.1 (isOpen_biUnion hU') hsC with
    ‚ü®K‚ÇÅ, K‚ÇÇ, h1K‚ÇÅ, h1K‚ÇÇ, h2K‚ÇÅ, h2K‚ÇÇ, hK‚ü©
  rcases ih h1K‚ÇÇ U hU' h2K‚ÇÇ with ‚ü®K, h1K, h2K, h3K‚ü©
  refine ‚ü®update K x K‚ÇÅ, ?_, ?_, ?_‚ü©
  ¬∑ intro i
    rcases eq_or_ne i x with rfl | hi
    ¬∑ simp only [update_same, h1K‚ÇÅ]
    ¬∑ simp only [update_noteq hi, h1K]
  ¬∑ intro i
    rcases eq_or_ne i x with rfl | hi
    ¬∑ simp only [update_same, h2K‚ÇÅ]
    ¬∑ simp only [update_noteq hi, h2K]
  ¬∑ simp only [Finset.set_biUnion_insert_update _ hx, hK, h3K]"
Mathlib/Order/UpperLower/Basic.lean,LowerSet.sdiff_sup_lowerClosure,sdiff_sup_lowerClosure,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ‚Ü¶ ?_
  obtain hat | hat := em (a ‚àà t)
  ¬∑ exact subset_union_right _ _ (subset_lowerClosure hat)
  ¬∑ refine subset_union_left _ _ ‚ü®ha, ?_‚ü©
    rintro ‚ü®b, hb, hba‚ü©
    exact hat <| hst _ ha _ hb hba","error:  function expected at
  subset_union_right ?m.704076
term has type
  ?m.704075 ‚àà ?m.704073 ‚à™ ?m.704074
error:  function expected at
  subset_union_left ?m.704118
term has type
  ?m.704117 ‚àà ?m.704115 ‚à™ ?m.704116
error:  no goals to be solved","lemma sdiff_sup_lowerClosure (hts : t ‚äÜ s) (hst : ‚àÄ b ‚àà s, ‚àÄ c ‚àà t, c ‚â§ b ‚Üí b ‚àà t) :
    s.sdiff t ‚äî lowerClosure t = s ",":= by
  refine le_antisymm (sup_le sdiff_le_left <| lowerClosure_le.2 hts) fun a ha ‚Ü¶ ?_
  obtain hat | hat := em (a ‚àà t)
  ¬∑ exact subset_union_right (subset_lowerClosure hat)
  ¬∑ refine subset_union_left ‚ü®ha, ?_‚ü©
    rintro ‚ü®b, hb, hba‚ü©
    exact hat <| hst _ ha _ hb hba"
Mathlib/CategoryTheory/Limits/Constructions/Pullbacks.lean,CategoryTheory.Limits.hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair,hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair,6ceb594537e19a62a66597a7b8f405f094f81ebc,":=
  let Œπ‚ÇÅ : Y ‚ü∂ Y ‚®ø Z := coprod.inl
  let Œπ‚ÇÇ : Z ‚ü∂ Y ‚®ø Z := coprod.inr
  let c := coequalizer.œÄ (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ)
  HasColimit.mk
    { cocone :=
        PushoutCocone.mk (Œπ‚ÇÅ ‚â´ c) (Œπ‚ÇÇ ‚â´ c) <| by
          rw [‚Üê Category.assoc, ‚Üê Category.assoc, coequalizer.condition]
      isColimit :=
        PushoutCocone.IsColimit.mk _
          (fun s =>
            coequalizer.desc (coprod.desc (s.Œπ.app WalkingSpan.left) (s.Œπ.app WalkingSpan.right)) <|
              by
              rw [Category.assoc, colimit.Œπ_desc, Category.assoc, colimit.Œπ_desc];
                exact PushoutCocone.condition _)
          (by simp) (by simp) fun s m h‚ÇÅ h‚ÇÇ => by
          apply coequalizer.hom_ext
          apply coprod.hom_ext
          ¬∑ simpa using h‚ÇÅ
          ¬∑ simpa using h‚ÇÇ }","error:  unsolved goals
C : Type u
ùíû : Category.{v, u} C
X Y Z : C
f : X ‚ü∂ Y
g : X ‚ü∂ Z
inst‚úù¬π : HasColimit (pair Y Z)
inst‚úù : HasColimit (parallelPair (f ‚â´ coprod.inl) (g ‚â´ coprod.inr))
Œπ‚ÇÅ : Y ‚ü∂ Y ‚®ø Z := coprod.inl
Œπ‚ÇÇ : Z ‚ü∂ Y ‚®ø Z := coprod.inr
c : Y ‚®ø Z ‚ü∂ coequalizer (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ) := coequalizer.œÄ (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ)
‚ä¢ ‚àÄ (s : PushoutCocone f g), Œπ‚ÇÅ ‚â´ c ‚â´ coequalizer.desc (coprod.desc s.inl s.inr) ‚ãØ = s.inl
error:  unsolved goals
C : Type u
ùíû : Category.{v, u} C
X Y Z : C
f : X ‚ü∂ Y
g : X ‚ü∂ Z
inst‚úù¬π : HasColimit (pair Y Z)
inst‚úù : HasColimit (parallelPair (f ‚â´ coprod.inl) (g ‚â´ coprod.inr))
Œπ‚ÇÅ : Y ‚ü∂ Y ‚®ø Z := coprod.inl
Œπ‚ÇÇ : Z ‚ü∂ Y ‚®ø Z := coprod.inr
c : Y ‚®ø Z ‚ü∂ coequalizer (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ) := coequalizer.œÄ (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ)
‚ä¢ ‚àÄ (s : PushoutCocone f g), Œπ‚ÇÇ ‚â´ c ‚â´ coequalizer.desc (coprod.desc s.inl s.inr) ‚ãØ = s.inr","theorem hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair {C : Type u}
    [ùíû : Category.{v} C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasColimit (pair Y Z)]
    [HasColimit (parallelPair (f ‚â´ coprod.inl) (g ‚â´ coprod.inr))] : HasColimit (span f g) ",":=
  let Œπ‚ÇÅ : Y ‚ü∂ Y ‚®ø Z := coprod.inl
  let Œπ‚ÇÇ : Z ‚ü∂ Y ‚®ø Z := coprod.inr
  let c := coequalizer.œÄ (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ)
  HasColimit.mk
    { cocone :=
        PushoutCocone.mk (Œπ‚ÇÅ ‚â´ c) (Œπ‚ÇÇ ‚â´ c) <| by
          rw [‚Üê Category.assoc, ‚Üê Category.assoc, coequalizer.condition]
      isColimit :=
        PushoutCocone.IsColimit.mk _
          (fun s => coequalizer.desc
              (coprod.desc (s.Œπ.app WalkingSpan.left) (s.Œπ.app WalkingSpan.right)) <| by
            rw [Category.assoc, colimit.Œπ_desc, Category.assoc, colimit.Œπ_desc]
            exact PushoutCocone.condition _)
          (by simp [Œπ‚ÇÅ, c]) (by simp [Œπ‚ÇÇ, c]) fun s m h‚ÇÅ h‚ÇÇ => by
          ext
          ¬∑ simpa using h‚ÇÅ
          ¬∑ simpa using h‚ÇÇ }"
Mathlib/CategoryTheory/Sites/Over.lean,CategoryTheory.GrothendieckTopology.over_forget_compatiblePreserving,over_forget_compatiblePreserving,59656d871b75b8384364dfe02f1d82e5419c6d62,"  Compatible {F Z T x hx Y‚ÇÅ Y‚ÇÇ W f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ h} := by
    let W' : Over X := Over.mk (f‚ÇÅ ‚â´ Y‚ÇÅ.hom)
    let g‚ÇÅ' : W' ‚ü∂ Y‚ÇÅ := Over.homMk f‚ÇÅ
    let g‚ÇÇ' : W' ‚ü∂ Y‚ÇÇ := Over.homMk f‚ÇÇ (by simpa using h.symm =‚â´ Z.hom)
    exact hx g‚ÇÅ' g‚ÇÇ' hg‚ÇÅ hg‚ÇÇ (by ext; exact h)",error:  'Compatible' is not a field of structure 'CategoryTheory.CompatiblePreserving',"lemma over_forget_compatiblePreserving (X : C) :
    CompatiblePreserving J (Over.forget X) where
","  compatible {F Z T x hx Y‚ÇÅ Y‚ÇÇ W f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ h} := by
    let W' : Over X := Over.mk (f‚ÇÅ ‚â´ Y‚ÇÅ.hom)
    let g‚ÇÅ' : W' ‚ü∂ Y‚ÇÅ := Over.homMk f‚ÇÅ
    let g‚ÇÇ' : W' ‚ü∂ Y‚ÇÇ := Over.homMk f‚ÇÇ (by simpa using h.symm =‚â´ Z.hom)
    exact hx g‚ÇÅ' g‚ÇÇ' hg‚ÇÅ hg‚ÇÇ (by ext; exact h)"
Mathlib/CategoryTheory/Limits/Constructions/Pullbacks.lean,CategoryTheory.Limits.hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair,hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair,14167e48d13e9c2d72cbdff0431a8edba6021c34,":=
  let Œπ‚ÇÅ : Y ‚ü∂ Y ‚®ø Z := coprod.inl
  let Œπ‚ÇÇ : Z ‚ü∂ Y ‚®ø Z := coprod.inr
  let c := coequalizer.œÄ (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ)
  HasColimit.mk
    { cocone :=
        PushoutCocone.mk (Œπ‚ÇÅ ‚â´ c) (Œπ‚ÇÇ ‚â´ c) <| by
          rw [‚Üê Category.assoc, ‚Üê Category.assoc, coequalizer.condition]
      isColimit :=
        PushoutCocone.IsColimit.mk _
          (fun s => coequalizer.desc
              (coprod.desc (s.Œπ.app WalkingSpan.left) (s.Œπ.app WalkingSpan.right)) <| by
            rw [Category.assoc, colimit.Œπ_desc, Category.assoc, colimit.Œπ_desc]
            exact PushoutCocone.condition _)
          (by simp) (by simp) fun s m h‚ÇÅ h‚ÇÇ => by
          apply coequalizer.hom_ext
          apply coprod.hom_ext
          ¬∑ simpa using h‚ÇÅ
          ¬∑ simpa using h‚ÇÇ }","error:  unsolved goals
C : Type u
ùíû : Category.{v, u} C
X Y Z : C
f : X ‚ü∂ Y
g : X ‚ü∂ Z
inst‚úù¬π : HasColimit (pair Y Z)
inst‚úù : HasColimit (parallelPair (f ‚â´ coprod.inl) (g ‚â´ coprod.inr))
Œπ‚ÇÅ : Y ‚ü∂ Y ‚®ø Z := coprod.inl
Œπ‚ÇÇ : Z ‚ü∂ Y ‚®ø Z := coprod.inr
c : Y ‚®ø Z ‚ü∂ coequalizer (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ) := coequalizer.œÄ (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ)
‚ä¢ ‚àÄ (s : PushoutCocone f g), Œπ‚ÇÅ ‚â´ c ‚â´ coequalizer.desc (coprod.desc s.inl s.inr) ‚ãØ = s.inl
error:  unsolved goals
C : Type u
ùíû : Category.{v, u} C
X Y Z : C
f : X ‚ü∂ Y
g : X ‚ü∂ Z
inst‚úù¬π : HasColimit (pair Y Z)
inst‚úù : HasColimit (parallelPair (f ‚â´ coprod.inl) (g ‚â´ coprod.inr))
Œπ‚ÇÅ : Y ‚ü∂ Y ‚®ø Z := coprod.inl
Œπ‚ÇÇ : Z ‚ü∂ Y ‚®ø Z := coprod.inr
c : Y ‚®ø Z ‚ü∂ coequalizer (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ) := coequalizer.œÄ (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ)
‚ä¢ ‚àÄ (s : PushoutCocone f g), Œπ‚ÇÇ ‚â´ c ‚â´ coequalizer.desc (coprod.desc s.inl s.inr) ‚ãØ = s.inr","theorem hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair {C : Type u}
    [ùíû : Category.{v} C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasColimit (pair Y Z)]
    [HasColimit (parallelPair (f ‚â´ coprod.inl) (g ‚â´ coprod.inr))] : HasColimit (span f g) ",":=
  let Œπ‚ÇÅ : Y ‚ü∂ Y ‚®ø Z := coprod.inl
  let Œπ‚ÇÇ : Z ‚ü∂ Y ‚®ø Z := coprod.inr
  let c := coequalizer.œÄ (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ)
  HasColimit.mk
    { cocone :=
        PushoutCocone.mk (Œπ‚ÇÅ ‚â´ c) (Œπ‚ÇÇ ‚â´ c) <| by
          rw [‚Üê Category.assoc, ‚Üê Category.assoc, coequalizer.condition]
      isColimit :=
        PushoutCocone.IsColimit.mk _
          (fun s => coequalizer.desc
              (coprod.desc (s.Œπ.app WalkingSpan.left) (s.Œπ.app WalkingSpan.right)) <| by
            rw [Category.assoc, colimit.Œπ_desc, Category.assoc, colimit.Œπ_desc]
            exact PushoutCocone.condition _)
          (by simp [Œπ‚ÇÅ, c]) (by simp [Œπ‚ÇÇ, c]) fun s m h‚ÇÅ h‚ÇÇ => by
          ext
          ¬∑ simpa using h‚ÇÅ
          ¬∑ simpa using h‚ÇÇ }"
Mathlib/Algebra/Order/Ring/Pow.lean,one_add_mul_le_pow',one_add_mul_le_pow',2b7553213ceef9ab990abaad26a07b210d09cc6a,"  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 ‚â§ n * (a * a * (2 + a)) + a * a :=
      add_nonneg (mul_nonneg n.cast_nonneg (mul_nonneg Hsq H)) Hsq
    calc
      _ ‚â§ 1 + ‚Üë(n + 2) * a + (n * (a * a * (2 + a)) + a * a) := le_add_of_nonneg_right this
      _ = (1 + a) * (1 + a) * (1 + n * a) := by
          simp only [Nat.cast_add, add_mul, mul_add, one_mul, mul_one, ‚Üê one_add_one_eq_two,
            Nat.cast_one, add_assoc, add_right_inj]
          simp only [‚Üê add_assoc, add_comm _ (‚Üën * a)]
          simp only [add_assoc, (n.cast_commute (_ : Œ±)).left_comm]
          simp only [add_comm, add_left_comm]
      _ ‚â§ (1 + a) * (1 + a) * (1 + a) ^ n :=
        mul_le_mul_of_nonneg_left (one_add_mul_le_pow' Hsq Hsq' H _) Hsq'
      _ = (1 + a) ^ (n + 2) := by simp only [pow_succ, mul_assoc]","error:  unknown identifier 'Œ±'
error:  unsolved goals
R : Type u_1
inst‚úù : OrderedSemiring R
a : R
Hsq : 0 ‚â§ a * a
Hsq' : 0 ‚â§ (1 + a) * (1 + a)
H : 0 ‚â§ 2 + a
n : ‚Ñï
this : 0 ‚â§ ‚Üën * (a * a * (2 + a)) + a * a
‚ä¢ ‚Üën * a + (a + (a + (a * a + (‚Üën * (a * a) + (‚Üën * (a * a) + ‚Üën * (a * a * a))))) + 1) =
    ‚Üën * a + (a + (a + (a * a + (a * (‚Üën * a) + (a * (‚Üën * a) + a * a * (‚Üën * a))))) + 1)
error:  unsolved goals
R : Type u_1
inst‚úù : OrderedSemiring R
a : R
Hsq : 0 ‚â§ a * a
Hsq' : 0 ‚â§ (1 + a) * (1 + a)
H : 0 ‚â§ 2 + a
n : ‚Ñï
this : 0 ‚â§ ‚Üën * (a * a * (2 + a)) + a * a
‚ä¢ (1 + a) * ((1 + a) * (1 + a) ^ n) = (1 + a) ^ n * ((1 + a) * (1 + a))","lemma one_add_mul_le_pow' (Hsq : 0 ‚â§ a * a) (Hsq' : 0 ‚â§ (1 + a) * (1 + a)) (H : 0 ‚â§ 2 + a) :
    ‚àÄ n : ‚Ñï, 1 + n * a ‚â§ (1 + a) ^ n
","  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 ‚â§ n * (a * a * (2 + a)) + a * a :=
      add_nonneg (mul_nonneg n.cast_nonneg (mul_nonneg Hsq H)) Hsq
    calc
      _ ‚â§ 1 + ‚Üë(n + 2) * a + (n * (a * a * (2 + a)) + a * a) := le_add_of_nonneg_right this
      _ = (1 + a) * (1 + a) * (1 + n * a) := by
          simp only [Nat.cast_add, add_mul, mul_add, one_mul, mul_one, ‚Üê one_add_one_eq_two,
            Nat.cast_one, add_assoc, add_right_inj]
          simp only [‚Üê add_assoc, add_comm _ (‚Üën * a)]
          simp only [add_assoc, (n.cast_commute (_ : R)).left_comm]
          simp only [add_comm, add_left_comm]
      _ ‚â§ (1 + a) * (1 + a) * (1 + a) ^ n :=
        mul_le_mul_of_nonneg_left (one_add_mul_le_pow' Hsq Hsq' H _) Hsq'
      _ = (1 + a) ^ (n + 2) := by simp only [pow_succ', mul_assoc]"
Mathlib/Algebra/Ring/Ext.lean,NonAssocRing.toNonUnitalNonAssocring_injective,toNonUnitalNonAssocring_injective,c037f0592e37b88b4421e42e66539b443c8b262e,":= by
  intro _ _ _
  ext <;> congr
  sorry","error:  no goals to be solved
error:  no goals to be solved","theorem toNonUnitalNonAssocring_injective :
    Function.Injective (@toNonUnitalNonAssocRing R) ",":= by
  intro _ _ _
  ext <;> congr"
Mathlib/RingTheory/MvPowerSeries/Inverse.lean,MvPowerSeries.invOfUnit_eq',invOfUnit_eq',456553b604b7224438a4ca1e7546556ca6a53e89,":=
  rfl","error:  type mismatch
  rfl
has type
  œÜ.invOfUnit u = œÜ.invOfUnit u : Prop
but is expected to have type
  œÜ.invOfUnit u = œÜ‚Åª¬π : Prop","theorem invOfUnit_eq' (œÜ : MvPowerSeries œÉ k) (u : Units k) (h : constantCoeff œÉ k œÜ = u) :
    invOfUnit œÜ u = œÜ‚Åª¬π ",":= by
  rw [‚Üê invOfUnit_eq œÜ (h.symm ‚ñ∏ u.ne_zero)]
  apply congrArg (invOfUnit œÜ)
  rw [Units.ext_iff]
  exact h.symm"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,uniformCauchySeqOnFilter_of_fderiv,uniformCauchySeqOnFilter_of_fderiv,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  letI : NormedSpace ‚Ñù E := NormedSpace.restrictScalars ‚Ñù ùïú _
  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero] at hf' ‚ä¢
  suffices
    TendstoUniformlyOnFilter (fun (n : Œπ √ó Œπ) (z : E) => f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) 0
        (l √óÀ¢ l) (ùìù x) ‚àß
      TendstoUniformlyOnFilter (fun (n : Œπ √ó Œπ) (_ : E) => f n.1 x - f n.2 x) 0 (l √óÀ¢ l) (ùìù x) by
    have := this.1.add this.2
    rw [add_zero] at this
    exact this.congr (by simp)
  constructor
  ¬∑ 
    rw [Metric.tendstoUniformlyOnFilter_iff] at hf' ‚ä¢
    intro Œµ hŒµ
    have := (tendsto_swap4_prod.eventually (hf.prod_mk hf)).diag_of_prod_right
    obtain ‚ü®a, b, c, d, e‚ü© := eventually_prod_iff.1 ((hf' Œµ hŒµ).and this)
    obtain ‚ü®R, hR, hR'‚ü© := Metric.nhds_basis_ball.eventually_iff.mp d
    let r := min 1 R
    have hr : 0 < r := by simp [hR]
    have hr' : ‚àÄ ‚¶Éy : E‚¶Ñ, y ‚àà Metric.ball x r ‚Üí c y := fun y hy =>
      hR' (lt_of_lt_of_le (Metric.mem_ball.mp hy) (min_le_right _ _))
    have hxy : ‚àÄ y : E, y ‚àà Metric.ball x r ‚Üí ‚Äñy - x‚Äñ < 1 := by
      intro y hy
      rw [Metric.mem_ball, dist_eq_norm] at hy
      exact lt_of_lt_of_le hy (min_le_left _ _)
    have hxyŒµ : ‚àÄ y : E, y ‚àà Metric.ball x r ‚Üí Œµ * ‚Äñy - x‚Äñ < Œµ := by
      intro y hy
      exact (mul_lt_iff_lt_one_right hŒµ.lt).mpr (hxy y hy)
    refine'
      eventually_prod_iff.mpr
        ‚ü®_, b, fun e : E => Metric.ball x r e,
          eventually_mem_set.mpr (Metric.nhds_basis_ball.mem_of_mem hr), fun {n} hn {y} hy => _‚ü©
    simp only [Pi.zero_apply, dist_zero_left] at e ‚ä¢
    refine' lt_of_le_of_lt _ (hxyŒµ y hy)
    exact
      Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le
        (fun y hy => ((e hn (hr' hy)).2.1.sub (e hn (hr' hy)).2.2).hasFDerivWithinAt)
        (fun y hy => (e hn (hr' hy)).1.le) (convex_ball x r) (Metric.mem_ball_self hr) hy
  ¬∑ 
    refine' Metric.tendstoUniformlyOnFilter_iff.mpr fun Œµ hŒµ => _
    obtain ‚ü®t, ht, ht'‚ü© := (Metric.cauchy_iff.mp hfg).2 Œµ hŒµ
    exact
      eventually_prod_iff.mpr
        ‚ü®fun n : Œπ √ó Œπ => f n.1 x ‚àà t ‚àß f n.2 x ‚àà t,
          eventually_prod_iff.mpr ‚ü®_, ht, _, ht, fun {n} hn {n'} hn' => ‚ü®hn, hn'‚ü©‚ü©,
          fun _ => True,
          by simp,
          fun {n} hn {y} _ => by simpa [norm_sub_rev, dist_eq_norm] using ht' _ hn.1 _ hn.2‚ü©",error:  simp made no progress,"theorem uniformCauchySeqOnFilter_of_fderiv (hf' : UniformCauchySeqOnFilter f' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : Cauchy (map (fun n => f n x) l)) : UniformCauchySeqOnFilter f l (ùìù x) ",":= by
  letI : NormedSpace ‚Ñù E := NormedSpace.restrictScalars ‚Ñù ùïú _
  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero] at hf' ‚ä¢
  suffices
    TendstoUniformlyOnFilter (fun (n : Œπ √ó Œπ) (z : E) => f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) 0
        (l √óÀ¢ l) (ùìù x) ‚àß
      TendstoUniformlyOnFilter (fun (n : Œπ √ó Œπ) (_ : E) => f n.1 x - f n.2 x) 0 (l √óÀ¢ l) (ùìù x) by
    have := this.1.add this.2
    rw [add_zero] at this
    exact this.congr (by simp)
  constructor
  ¬∑ 
    rw [Metric.tendstoUniformlyOnFilter_iff] at hf' ‚ä¢
    intro Œµ hŒµ
    have := (tendsto_swap4_prod.eventually (hf.prod_mk hf)).diag_of_prod_right
    obtain ‚ü®a, b, c, d, e‚ü© := eventually_prod_iff.1 ((hf' Œµ hŒµ).and this)
    obtain ‚ü®R, hR, hR'‚ü© := Metric.nhds_basis_ball.eventually_iff.mp d
    let r := min 1 R
    have hr : 0 < r := by simp [r, hR]
    have hr' : ‚àÄ ‚¶Éy : E‚¶Ñ, y ‚àà Metric.ball x r ‚Üí c y := fun y hy =>
      hR' (lt_of_lt_of_le (Metric.mem_ball.mp hy) (min_le_right _ _))
    have hxy : ‚àÄ y : E, y ‚àà Metric.ball x r ‚Üí ‚Äñy - x‚Äñ < 1 := by
      intro y hy
      rw [Metric.mem_ball, dist_eq_norm] at hy
      exact lt_of_lt_of_le hy (min_le_left _ _)
    have hxyŒµ : ‚àÄ y : E, y ‚àà Metric.ball x r ‚Üí Œµ * ‚Äñy - x‚Äñ < Œµ := by
      intro y hy
      exact (mul_lt_iff_lt_one_right hŒµ.lt).mpr (hxy y hy)
    refine
      eventually_prod_iff.mpr
        ‚ü®_, b, fun e : E => Metric.ball x r e,
          eventually_mem_set.mpr (Metric.nhds_basis_ball.mem_of_mem hr), fun {n} hn {y} hy => ?_‚ü©
    simp only [Pi.zero_apply, dist_zero_left] at e ‚ä¢
    refine lt_of_le_of_lt ?_ (hxyŒµ y hy)
    exact
      Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le
        (fun y hy => ((e hn (hr' hy)).2.1.sub (e hn (hr' hy)).2.2).hasFDerivWithinAt)
        (fun y hy => (e hn (hr' hy)).1.le) (convex_ball x r) (Metric.mem_ball_self hr) hy
  ¬∑ 
    refine Metric.tendstoUniformlyOnFilter_iff.mpr fun Œµ hŒµ => ?_
    obtain ‚ü®t, ht, ht'‚ü© := (Metric.cauchy_iff.mp hfg).2 Œµ hŒµ
    exact
      eventually_prod_iff.mpr
        ‚ü®fun n : Œπ √ó Œπ => f n.1 x ‚àà t ‚àß f n.2 x ‚àà t,
          eventually_prod_iff.mpr ‚ü®_, ht, _, ht, fun {n} hn {n'} hn' => ‚ü®hn, hn'‚ü©‚ü©,
          fun _ => True,
          by simp,
          fun {n} hn {y} _ => by simpa [norm_sub_rev, dist_eq_norm] using ht' _ hn.1 _ hn.2‚ü©"
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow,discr_prime_pow,a76dc22f3a90e5ab96e9284d30276a87a4324a5d,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), succ_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2
      ¬∑ rwa [Ne.def, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]; ¬∑ norm_cast
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact_mod_cast hŒ∂.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact_mod_cast hŒ∂.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by linarith)] at this
      exact absurd (pow_eq_zero h) this","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case e_a.inr
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2‚úù : p = 2 ‚Üí k ‚â† 0
hp2 : ‚Üëp ‚â† 2
‚ä¢ (-1) ^ (‚Üëp ^ k * (‚Üëp - 1) * (‚Üëp ^ k * (‚Üëp - 1) - 1) / 2) = (-1) ^ (‚Üëp ^ k * (‚Üëp - 1) / 2)
error:  unsolved goals
case e_a
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2 : p = 2 ‚Üí k ‚â† 0
‚ä¢ (Algebra.norm K) ((aeval Œ∂) (derivative (cyclotomic (‚Üëp ^ (k + 1)) K))) = ‚Üë‚Üëp ^ (‚Üëp ^ k * ((‚Üëp - 1) * (k + 1) - 1))","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ‚Ñï).Prime]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1)) : ‚Ñï) K))
    (hk : p ^ (k + 1) ‚â† 2) : discr K (hŒ∂.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : ‚Ñï).totient / 2) * p ^ ((p : ‚Ñï) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this"
Mathlib/CategoryTheory/Sites/Coherent/Equivalence.lean,CategoryTheory.Equivalence.preregular,preregular,72110892c7bdc901fc934e958334a55bb9bb634e,":= by
  have : e.inverse.ReflectsEffectiveEpis := sorry
  exact reflects_preregular e.inverse fun X ‚Ü¶ ‚ü®e.functor.obj X, e.unitInv.app _, inferInstance‚ü©",error:  unknown identifier 'reflects_preregular',theorem preregular : Preregular D ,:= e.inverse.reflects_preregular
Mathlib/Topology/Category/Stonean/Basic.lean,Stonean.epi_iff_surjective,epi_iff_surjective,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  refine ‚ü®?_, ConcreteCategory.epi_of_surjective _‚ü©
  dsimp [Function.Surjective]
  intro h y
  by_contra' hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := C·∂ú
  have hUy : U ‚àà nhds y := by
    simp only [Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain ‚ü®V, hV, hyV, hVU‚ü© := isTopologicalBasis_clopen.mem_nhds_iff.mp hUy
  classical
  let g : Y ‚ü∂ mkFinite (ULift (Fin 2)) :=
    ‚ü®(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _‚ü©
  let h : Y ‚ü∂ mkFinite (ULift (Fin 2)) := ‚ü®fun _ => ‚ü®1‚ü©, continuous_const‚ü©
  have H : h = g := by
    rw [‚Üê cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU ¬∑) ?_ 
    simpa only [Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H","error:  unknown tactic
error:  unsolved goals
X Y : Stonean
f : X ‚ü∂ Y
h : Epi f
y : CoeSort.coe Y
‚ä¢ ‚àÉ a, f a = y","lemma epi_iff_surjective {X Y : Stonean} (f : X ‚ü∂ Y) :
    Epi f ‚Üî Function.Surjective f ",":= by
  refine ‚ü®?_, ConcreteCategory.epi_of_surjective _‚ü©
  dsimp [Function.Surjective]
  intro h y
  by_contra! hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := C·∂ú
  have hUy : U ‚àà ùìù y := by
    simp only [C, Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain ‚ü®V, hV, hyV, hVU‚ü© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy
  classical
  let g : Y ‚ü∂ mkFinite (ULift (Fin 2)) :=
    ‚ü®(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _‚ü©
  let h : Y ‚ü∂ mkFinite (ULift (Fin 2)) := ‚ü®fun _ => ‚ü®1‚ü©, continuous_const‚ü©
  have H : h = g := by
    rw [‚Üê cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU ¬∑) ?_ 
    simpa only [U, Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H"
Mathlib/Analysis/SpecialFunctions/Log/ENNReal.lean,ENNReal.log_lt_iff_lt,log_lt_iff_lt,0d64f65aee42c8a3274401ad6c8844a7c87ec76b,":= by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ log_strictMono h‚ü©
  rw [‚Üê exp_log x, ‚Üê exp_log y]
  exact exp_strictMono h","error:  unknown identifier 'exp_log'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.8923
x y : ‚Ñù‚â•0‚àû
h : x.log < y.log
‚ä¢ x < y",theorem log_lt_iff_lt {x y : ‚Ñù‚â•0‚àû} : log x < log y ‚Üî x < y ,:= OrderIso.lt_iff_lt log_orderIso
Mathlib/Data/Set/Basic.lean,Set.sep_or,sep_or,ef3c9bcd07782b044027916a64e925f3e4951707,":=
  inter_union_distrib_left s ‚ü®p‚ü© ‚ü®q‚ü©","error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  Œ± ‚Üí Prop
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  Œ± ‚Üí Prop",theorem sep_or : { x ‚àà s | p x ‚à® q x } = { x ‚àà s | p x } ‚à™ { x ‚àà s | q x } ,":=
  inter_union_distrib_left s p q"
Mathlib/Algebra/BigOperators/Fin.lean,Fin.prod_ofFn,prod_ofFn,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [List.ofFn_eq_map, prod_univ_def]","error:  unknown identifier 'prod_univ_def'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.1167
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù : CommMonoid Œ≤
n : ‚Ñï
f : Fin n ‚Üí Œ≤
‚ä¢ (List.map f (List.finRange n)).prod = ‚àè i : Fin n, f i","theorem prod_ofFn [CommMonoid Œ≤] {n : ‚Ñï} (f : Fin n ‚Üí Œ≤) : (List.ofFn f).prod = ‚àè i, f i ",":= by
  simp [prod_eq_multiset_prod]"
Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean,CategoryTheory.Limits.colimitLimitToLimitColimit_surjective,colimitLimitToLimitColimit_surjective,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  classical
    intro x
    have z := fun j => jointly_surjective'.{v, v} (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply', t, FunctorToTypes.map_comp_apply, Colimit.w_apply', e, ‚Üê
        Limit.w_apply' f, ‚Üê e]
      simp
    simp_rw [colimit_eq_iff.{v, v}] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (by
            rw [Finset.mem_biUnion]
            refine' ‚ü®j, Finset.mem_univ j, _‚ü©
            rw [Finset.mem_biUnion]
            refine' ‚ü®j', Finset.mem_univ j', _‚ü©
            rw [Finset.mem_image]
            refine' ‚ü®f, Finset.mem_univ _, _‚ü©
            rfl))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      exact k'O
      swap
      ¬∑ rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÅ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÇ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®f, Finset.mem_univ _, _‚ü©
        simp only [true_or_iff, eq_self_iff_true, and_self_iff, Finset.mem_insert, heq_iff_eq]
      ¬∑ rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÉ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÑ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®f', Finset.mem_univ _, _‚ü©
        simp only [eq_self_iff_true, or_true_iff, and_self_iff, Finset.mem_insert,
          Finset.mem_singleton, heq_iff_eq]
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk.{v, v}
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) :=
            by rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) :=
            by rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) :=
            by rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext'
      intro j
      simp only [id.def, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff.{v, v}, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine' ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), _‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","error:  application type mismatch
  jointly_surjective' (limit.œÄ (curry.obj F ‚ãô colim) j x)
argument
  limit.œÄ (curry.obj F ‚ãô colim) j x
has type
  (curry.obj F ‚ãô colim).obj j : Type v
but is expected to have type
  colimit ?m.27488 : Type v
error:  unsolved goals
J : Type u‚ÇÅ
K : Type u‚ÇÇ
inst‚úù‚Å¥ : SmallCategory J
inst‚úù¬≥ : Category.{v‚ÇÇ, u‚ÇÇ} K
inst‚úù¬≤ : Small.{v, u‚ÇÇ} K
inst‚úù¬π : FinCategory J
F : J √ó K ‚•§ Type v
inst‚úù : IsFiltered K
x : limit (curry.obj F ‚ãô colim)
‚ä¢ ‚àÉ a, colimitLimitToLimitColimit F a = x","theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) ",":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ‚Üê Limit.w_apply.{u‚ÇÅ, v, u‚ÇÅ} f, ‚Üê e]
      simp only [Functor.comp_map, Types.Colimit.Œπ_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact k'O
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) := by
            rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) := by
            rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext
      intro j
      simp only [id, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]"
Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean,CategoryTheory.Pretriangulated.exists_iso_of_arrow_iso,exists_iso_of_arrow_iso,eb4e7cb40c973c5fbf11d3373bd0829447b7de8a,":= by
  let œÜ := completeDistinguishedTriangleMorphism T‚ÇÅ T‚ÇÇ hT‚ÇÅ hT‚ÇÇ e.hom.left e.hom.right e.hom.w.symm
  have : IsIso œÜ.hom‚ÇÅ := by dsimp; infer_instance
  have : IsIso œÜ.hom‚ÇÇ := by dsimp; infer_instance
  have : IsIso œÜ.hom‚ÇÉ := isIso‚ÇÉ_of_isIso‚ÇÅ‚ÇÇ œÜ hT‚ÇÅ hT‚ÇÇ inferInstance inferInstance
  have : IsIso œÜ := by
    apply Triangle.isIso_of_isIsos
    all_goals infer_instance
  exact ‚ü®asIso œÜ, by simp, by simp‚ü©","error:  failed to synthesize
  IsIso œÜ.hom‚ÇÅ
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  IsIso œÜ.hom‚ÇÇ
use `set_option diagnostics true` to get diagnostic information
error:  unsolved goals
C : Type u
inst‚úù‚Å¥ : Category.{v, u} C
inst‚úù¬≥ : HasZeroObject C
inst‚úù¬≤ : HasShift C ‚Ñ§
inst‚úù¬π : Preadditive C
inst‚úù : ‚àÄ (n : ‚Ñ§), (shiftFunctor C n).Additive
hC : Pretriangulated C
T‚ÇÅ T‚ÇÇ : Triangle C
hT‚ÇÅ : T‚ÇÅ ‚àà distinguishedTriangles
hT‚ÇÇ : T‚ÇÇ ‚àà distinguishedTriangles
e : Arrow.mk T‚ÇÅ.mor‚ÇÅ ‚âÖ Arrow.mk T‚ÇÇ.mor‚ÇÅ
œÜ : T‚ÇÅ ‚ü∂ T‚ÇÇ := completeDistinguishedTriangleMorphism T‚ÇÅ T‚ÇÇ hT‚ÇÅ hT‚ÇÇ e.hom.left e.hom.right ‚ãØ
this‚úù¬≤ : IsIso œÜ.hom‚ÇÅ
this‚úù¬π : IsIso œÜ.hom‚ÇÇ
this‚úù : IsIso œÜ.hom‚ÇÉ
this : IsIso œÜ
‚ä¢ œÜ.hom‚ÇÅ = e.hom.left
error:  unsolved goals
C : Type u
inst‚úù‚Å¥ : Category.{v, u} C
inst‚úù¬≥ : HasZeroObject C
inst‚úù¬≤ : HasShift C ‚Ñ§
inst‚úù¬π : Preadditive C
inst‚úù : ‚àÄ (n : ‚Ñ§), (shiftFunctor C n).Additive
hC : Pretriangulated C
T‚ÇÅ T‚ÇÇ : Triangle C
hT‚ÇÅ : T‚ÇÅ ‚àà distinguishedTriangles
hT‚ÇÇ : T‚ÇÇ ‚àà distinguishedTriangles
e : Arrow.mk T‚ÇÅ.mor‚ÇÅ ‚âÖ Arrow.mk T‚ÇÇ.mor‚ÇÅ
œÜ : T‚ÇÅ ‚ü∂ T‚ÇÇ := completeDistinguishedTriangleMorphism T‚ÇÅ T‚ÇÇ hT‚ÇÅ hT‚ÇÇ e.hom.left e.hom.right ‚ãØ
this‚úù¬≤ : IsIso œÜ.hom‚ÇÅ
this‚úù¬π : IsIso œÜ.hom‚ÇÇ
this‚úù : IsIso œÜ.hom‚ÇÉ
this : IsIso œÜ
‚ä¢ œÜ.hom‚ÇÇ = e.hom.right","lemma exists_iso_of_arrow_iso (T‚ÇÅ T‚ÇÇ : Triangle C) (hT‚ÇÅ : T‚ÇÅ ‚àà distTriang C)
    (hT‚ÇÇ : T‚ÇÇ ‚àà distTriang C) (e : Arrow.mk T‚ÇÅ.mor‚ÇÅ ‚âÖ Arrow.mk T‚ÇÇ.mor‚ÇÅ) :
    ‚àÉ (e' : T‚ÇÅ ‚âÖ T‚ÇÇ), e'.hom.hom‚ÇÅ = e.hom.left ‚àß e'.hom.hom‚ÇÇ = e.hom.right ",":= by
  let œÜ := completeDistinguishedTriangleMorphism T‚ÇÅ T‚ÇÇ hT‚ÇÅ hT‚ÇÇ e.hom.left e.hom.right e.hom.w.symm
  have : IsIso œÜ.hom‚ÇÅ := by dsimp [œÜ]; infer_instance
  have : IsIso œÜ.hom‚ÇÇ := by dsimp [œÜ]; infer_instance
  have : IsIso œÜ.hom‚ÇÉ := isIso‚ÇÉ_of_isIso‚ÇÅ‚ÇÇ œÜ hT‚ÇÅ hT‚ÇÇ inferInstance inferInstance
  have : IsIso œÜ := by
    apply Triangle.isIso_of_isIsos
    all_goals infer_instance
  exact ‚ü®asIso œÜ, by simp [œÜ], by simp [œÜ]‚ü©"
Mathlib/Data/List/NodupEquivFin.lean,List.sublist_iff_exists_fin_orderEmbedding_get_eq,sublist_iff_exists_fin_orderEmbedding_get_eq,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï}, i < l.length ‚Üí f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) ?_,? _‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [get?_eq_get i.2, get?_eq_get (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          ?_,
        ?_‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ have := (f ‚ü®i, hi‚ü©).is_lt
        omega
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi","error:  type mismatch
  h‚úù
has type
  some l[‚Üëi] = l'[f ‚Üëi]? : Prop
but is expected to have type
  l[‚Üëi] = l'[f ‚Üëi] : Prop
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem sublist_iff_exists_fin_orderEmbedding_get_eq {l l' : List Œ±} :
    l <+ l' ‚Üî
      ‚àÉ f : Fin l.length ‚Ü™o Fin l'.length,
        ‚àÄ ix : Fin l.length, l.get ix = l'.get (f ix) ",":= by
  rw [sublist_iff_exists_orderEmbedding_get?_eq]
  constructor
  ¬∑ rintro ‚ü®f, hf‚ü©
    have h : ‚àÄ {i : ‚Ñï}, i < l.length ‚Üí f i < l'.length := by
      intro i hi
      specialize hf i
      rw [get?_eq_get hi, eq_comm, get?_eq_some] at hf
      obtain ‚ü®h, -‚ü© := hf
      exact h
    refine ‚ü®OrderEmbedding.ofMapLEIff (fun ix => ‚ü®f ix, h ix.is_lt‚ü©) ?_, ?_‚ü©
    ¬∑ simp
    ¬∑ intro i
      apply Option.some_injective
      simpa [getElem?_eq_getElem i.2, getElem?_eq_getElem (h i.2)] using hf i
  ¬∑ rintro ‚ü®f, hf‚ü©
    refine
      ‚ü®OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ‚ü®i, hi‚ü© else i + l'.length)
          ?_,
        ?_‚ü©
    ¬∑ intro i j h
      dsimp only
      split_ifs with hi hj hj
      ¬∑ rwa [Fin.val_fin_lt, f.lt_iff_lt]
      ¬∑ have := (f ‚ü®i, hi‚ü©).is_lt
        omega
      ¬∑ exact absurd (h.trans hj) hi
      ¬∑ simpa using h
    ¬∑ intro i
      simp only [OrderEmbedding.coe_ofStrictMono]
      split_ifs with hi
      ¬∑ rw [get?_eq_get hi, get?_eq_get, ‚Üê hf]
      ¬∑ rw [get?_eq_none.mpr, get?_eq_none.mpr]
        ¬∑ simp
        ¬∑ simpa using hi"
Mathlib/LinearAlgebra/FiniteDimensional.lean,LinearMap.surjective_of_injective,surjective_of_injective,50a8866dc2f2f6bf8113aa6829cb3041f9b6ee33,":= by
  have h := rank_eq_of_injective _ hinj
  rw [‚Üê finrank_eq_rank, ‚Üê finrank_eq_rank, natCast_inj] at h
  exact range_eq_top.1 (eq_top_of_finrank_eq h.symm)","error:  unknown identifier 'rank_eq_of_injective'
error:  unsolved goals
K : Type u
V : Type v
inst‚úù‚Åµ : DivisionRing K
inst‚úù‚Å¥ : AddCommGroup V
inst‚úù¬≥ : Module K V
V‚ÇÇ : Type v'
inst‚úù¬≤ : AddCommGroup V‚ÇÇ
inst‚úù¬π : Module K V‚ÇÇ
inst‚úù : FiniteDimensional K V
f : V ‚Üí‚Çó[K] V
hinj : Injective ‚áëf
‚ä¢ Surjective ‚áëf","theorem surjective_of_injective [FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V} (hinj : Injective f) :
    Surjective f ",":= by
  have h := rank_range_of_injective _ hinj
  rw [‚Üê finrank_eq_rank, ‚Üê finrank_eq_rank, natCast_inj] at h
  exact range_eq_top.1 (eq_top_of_finrank_eq h)"
Mathlib/MeasureTheory/Function/SimpleFuncDense.lean,MeasureTheory.SimpleFunc.tendsto_approxOn,tendsto_approxOn,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  haveI : Nonempty s := ‚ü®‚ü®y‚ÇÄ, h‚ÇÄ‚ü©‚ü©
  rw [‚Üê @Subtype.range_coe _ s, ‚Üê image_univ, ‚Üê (denseRange_denseSeq s).closure_eq] at hx
  simp (config := { iota := false }) only [approxOn, coe_comp]
  refine tendsto_nearestPt (closure_minimal ?_ isClosed_closure hx)
  simp (config := { iota := false }) only [Nat.range_casesOn, closure_union, range_comp]
  exact
    Subset.trans (image_closure_subset_closure_image continuous_subtype_val)
      (subset_union_right _ _)","error:  overloaded, errors 
  110:7 overloaded, errors 
    function expected at
      Finset.subset_union_right ?m.27657
    term has type
      ?m.27656 ‚àà ?m.27654 ‚à™ ?m.27655
    
    function expected at
      Set.subset_union_right ?m.27918
    term has type
      ?m.27917 ‚àà ?m.27915 ‚à™ ?m.27916
  
  110:7 overloaded, errors 
    function expected at
      Finset.subset_union_right ?m.28434
    term has type
      ?m.28433 ‚àà ?m.28431 ‚à™ ?m.28432
    
    function expected at
      Set.subset_union_right ?m.28557
    term has type
      ?m.28556 ‚àà ?m.28554 ‚à™ ?m.28555","theorem tendsto_approxOn {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} {y‚ÇÄ : Œ±} (h‚ÇÄ : y‚ÇÄ ‚àà s)
    [SeparableSpace s] {x : Œ≤} (hx : f x ‚àà closure s) :
    Tendsto (fun n => approxOn f hf s y‚ÇÄ h‚ÇÄ n x) atTop (ùìù <| f x) ",":= by
  haveI : Nonempty s := ‚ü®‚ü®y‚ÇÄ, h‚ÇÄ‚ü©‚ü©
  rw [‚Üê @Subtype.range_coe _ s, ‚Üê image_univ, ‚Üê (denseRange_denseSeq s).closure_eq] at hx
  simp (config := { iota := false }) only [approxOn, coe_comp]
  refine tendsto_nearestPt (closure_minimal ?_ isClosed_closure hx)
  simp (config := { iota := false }) only [Nat.range_casesOn, closure_union, range_comp]
  exact
    Subset.trans (image_closure_subset_closure_image continuous_subtype_val)
      subset_union_right"
Mathlib/Order/Monotone/Extension.lean,MonotoneOn.exists_monotone_extension,MonotoneOn.exists_monotone_extension,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  classical
    rcases hl with ‚ü®a, ha‚ü©
    have hu' : ‚àÄ x, BddAbove (f '' (Iic x ‚à© s)) := fun x =>
      hu.mono (image_subset _ (inter_subset_right _ _))
    let g : Œ± ‚Üí Œ≤ := fun x => if Disjoint (Iic x) s then a else sSup (f '' (Iic x ‚à© s))
    have hgs : EqOn f g s := by
      intro x hx
      simp only []
      have : IsGreatest (Iic x ‚à© s) x := ‚ü®‚ü®right_mem_Iic, hx‚ü©, fun y hy => hy.1‚ü©
      rw [if_neg this.nonempty.not_disjoint,
        ((h.mono <| inter_subset_right _ _).map_isGreatest this).csSup_eq]
    refine' ‚ü®g, fun x y hxy => _, hgs‚ü©
    by_cases hx : Disjoint (Iic x) s <;> by_cases hy : Disjoint (Iic y) s <;>
      simp only [if_pos, if_neg, not_false_iff, *, refl]
    ¬∑ rcases not_disjoint_iff_nonempty_inter.1 hy with ‚ü®z, hz‚ü©
      exact le_csSup_of_le (hu' _) (mem_image_of_mem _ hz) (ha <| mem_image_of_mem _ hz.2)
    ¬∑ exact (hx <| hy.mono_left <| Iic_subset_Iic.2 hxy).elim
    ¬∑ rw [not_disjoint_iff_nonempty_inter] at hx hy
      refine' csSup_le_csSup (hu' _) (hx.image _) (image_subset _ _)
      exact inter_subset_inter_left _ (Iic_subset_Iic.2 hxy)","error:  function expected at
  inter_subset_right ?m.942
term has type
  ?m.941 ‚àà ?m.940
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  application type mismatch
  not_disjoint_iff_nonempty_inter.mp hy
argument
  hy
has type
  Disjoint (Iic y) s : Prop
but is expected to have type
  ¬¨Disjoint ?m.3156 ?m.3157 : Prop
error:  type mismatch
  le_csSup_of_le (hu' ?m.3494) (mem_image_of_mem f hz) (ha (mem_image_of_mem f hz.right))
has type
  a ‚â§ sSup (f '' (Iic ?m.3494 ‚à© s)) : Prop
but is expected to have type
  g x ‚â§ g y : Prop
error:  invalid field 'mono_left', the environment does not contain 'Not.mono_left'
  hy
has type
  ¬¨Disjoint (Iic y) s
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hy
has type
  Disjoint (Iic y) s ‚Üí False
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ¬¨Disjoint ?m.3554 ?m.3555
case pos
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬π : LinearOrder Œ±
inst‚úù : ConditionallyCompleteLinearOrder Œ≤
f : Œ± ‚Üí Œ≤
s : Set Œ±
a‚úù b : Œ±
h : MonotoneOn f s
hu : BddAbove (f '' s)
a : Œ≤
ha : a ‚àà lowerBounds (f '' s)
hu' : ‚àÄ (x : Œ±), BddAbove (f '' (Iic x ‚à© s))
g : Œ± ‚Üí Œ≤ := fun x ‚Ü¶ if Disjoint (Iic x) s then a else sSup (f '' (Iic x ‚à© s))
hgs : EqOn f g s
x y : Œ±
hxy : x ‚â§ y
hx : (Iic x ‚à© s).Nonempty
hy : Disjoint (Iic y) s
‚ä¢ g x ‚â§ g y
error:  unsolved goals
case neg
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬π : LinearOrder Œ±
inst‚úù : ConditionallyCompleteLinearOrder Œ≤
f : Œ± ‚Üí Œ≤
s : Set Œ±
a‚úù b : Œ±
h : MonotoneOn f s
hu : BddAbove (f '' s)
a : Œ≤
ha : a ‚àà lowerBounds (f '' s)
hu' : ‚àÄ (x : Œ±), BddAbove (f '' (Iic x ‚à© s))
g : Œ± ‚Üí Œ≤ := fun x ‚Ü¶ if Disjoint (Iic x) s then a else sSup (f '' (Iic x ‚à© s))
hgs : EqOn f g s
x y : Œ±
hxy : x ‚â§ y
hx : ¬¨Disjoint (Iic x) s
hy : ¬¨Disjoint (Iic y) s
‚ä¢ g x ‚â§ g y","theorem MonotoneOn.exists_monotone_extension (h : MonotoneOn f s) (hl : BddBelow (f '' s))
    (hu : BddAbove (f '' s)) : ‚àÉ g : Œ± ‚Üí Œ≤, Monotone g ‚àß EqOn f g s ",":= by
  classical
    rcases hl with ‚ü®a, ha‚ü©
    have hu' : ‚àÄ x, BddAbove (f '' (Iic x ‚à© s)) := fun x =>
      hu.mono (image_subset _ inter_subset_right)
    let g : Œ± ‚Üí Œ≤ := fun x => if Disjoint (Iic x) s then a else sSup (f '' (Iic x ‚à© s))
    have hgs : EqOn f g s := by
      intro x hx
      simp only [g]
      have : IsGreatest (Iic x ‚à© s) x := ‚ü®‚ü®right_mem_Iic, hx‚ü©, fun y hy => hy.1‚ü©
      rw [if_neg this.nonempty.not_disjoint,
        ((h.mono inter_subset_right).map_isGreatest this).csSup_eq]
    refine ‚ü®g, fun x y hxy => ?_, hgs‚ü©
    by_cases hx : Disjoint (Iic x) s <;> by_cases hy : Disjoint (Iic y) s <;>
      simp only [g, if_pos, if_neg, not_false_iff, *, refl]
    ¬∑ rcases not_disjoint_iff_nonempty_inter.1 hy with ‚ü®z, hz‚ü©
      exact le_csSup_of_le (hu' _) (mem_image_of_mem _ hz) (ha <| mem_image_of_mem _ hz.2)
    ¬∑ exact (hx <| hy.mono_left <| Iic_subset_Iic.2 hxy).elim
    ¬∑ rw [not_disjoint_iff_nonempty_inter] at hx hy
      refine csSup_le_csSup (hu' _) (hx.image _) (image_subset _ ?_)
      exact inter_subset_inter_left _ (Iic_subset_Iic.2 hxy)"
Mathlib/Topology/PartitionOfUnity.lean,PartitionOfUnity.exists_pos,exists_pos,3b4737b3b07aa77aaa08420241e83ad9c46eda8a,":= by
  have H := f.sum_eq_one hx
  contrapose! H
  simp_rw [not_exists, not_lt] at H
  simpa only [fun i => (H i).antisymm (f.nonneg i x), finsum_zero] using zero_ne_one",error:  simp made no progress,"theorem exists_pos {x : X} (hx : x ‚àà s) : ‚àÉ i, 0 < f i x ",":= by
  have H := f.sum_eq_one hx
  contrapose! H
  simpa only [fun i => (H i).antisymm (f.nonneg i x), finsum_zero] using zero_ne_one"
Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean,CategoryTheory.Pretriangulated.Triangle.isZero‚ÇÉ_iff_isIso‚ÇÅ,isZero‚ÇÉ_iff_isIso‚ÇÅ,8535b08ef59bcdb8a9d09a473f4b6c583f54aef0,":= by
  refine' Iff.trans _ (Triangle.isZero‚ÇÅ_iff_isIso‚ÇÇ _ (inv_rot_of_dist_triangle _ hT))
  dsimp
  simp only [IsZero.iff_id_eq_zero, ‚Üê Functor.map_id, Functor.map_eq_zero_iff]","error:  unknown identifier 'inv_rot_of_dist_triangle'
error:  unsolved goals
case refine'_1
C : Type u
inst‚úù‚Å¥ : Category.{v, u} C
inst‚úù¬≥ : HasZeroObject C
inst‚úù¬≤ : HasShift C ‚Ñ§
inst‚úù¬π : Preadditive C
inst‚úù : ‚àÄ (n : ‚Ñ§), (CategoryTheory.shiftFunctor C n).Additive
hC : Pretriangulated C
T : Triangle C
hT : T ‚àà distinguishedTriangles
‚ä¢ ùüô T.obj‚ÇÉ = 0 ‚Üî IsZero ?refine'_5.obj‚ÇÅ

case refine'_2
C : Type u
inst‚úù‚Å¥ : Category.{v, u} C
inst‚úù¬≥ : HasZeroObject C
inst‚úù¬≤ : HasShift C ‚Ñ§
inst‚úù¬π : Preadditive C
inst‚úù : ‚àÄ (n : ‚Ñ§), (CategoryTheory.shiftFunctor C n).Additive
hC : Pretriangulated C
T : Triangle C
hT : T ‚àà distinguishedTriangles
‚ä¢ Type u

case refine'_3
C : Type u
inst‚úù‚Å¥ : Category.{v, u} C
inst‚úù¬≥ : HasZeroObject C
inst‚úù¬≤ : HasShift C ‚Ñ§
inst‚úù¬π : Preadditive C
inst‚úù : ‚àÄ (n : ‚Ñ§), (CategoryTheory.shiftFunctor C n).Additive
hC : Pretriangulated C
T : Triangle C
hT : T ‚àà distinguishedTriangles
‚ä¢ Category.{v, u} ?refine'_2

case refine'_4
C : Type u
inst‚úù‚Å¥ : Category.{v, u} C
inst‚úù¬≥ : HasZeroObject C
inst‚úù¬≤ : HasShift C ‚Ñ§
inst‚úù¬π : Preadditive C
inst‚úù : ‚àÄ (n : ‚Ñ§), (CategoryTheory.shiftFunctor C n).Additive
hC : Pretriangulated C
T : Triangle C
hT : T ‚àà distinguishedTriangles
‚ä¢ HasShift ?refine'_2 ‚Ñ§

case refine'_5
C : Type u
inst‚úù‚Å¥ : Category.{v, u} C
inst‚úù¬≥ : HasZeroObject C
inst‚úù¬≤ : HasShift C ‚Ñ§
inst‚úù¬π : Preadditive C
inst‚úù : ‚àÄ (n : ‚Ñ§), (CategoryTheory.shiftFunctor C n).Additive
hC : Pretriangulated C
T : Triangle C
hT : T ‚àà distinguishedTriangles
‚ä¢ Triangle ?refine'_2
error:  function expected at
  isZero‚ÇÉ_iff_isIso‚ÇÅ T
term has type
  IsZero T.obj‚ÇÉ ‚Üî IsIso T.mor‚ÇÅ",lemma isZero‚ÇÉ_iff_isIso‚ÇÅ : IsZero T.obj‚ÇÉ ‚Üî IsIso T.mor‚ÇÅ ,":= by
  refine Iff.trans ?_ (Triangle.isZero‚ÇÅ_iff_isIso‚ÇÇ _ (inv_rot_of_distTriang _ hT))
  dsimp
  simp only [IsZero.iff_id_eq_zero, ‚Üê Functor.map_id, Functor.map_eq_zero_iff]"
Mathlib/Probability/Independence/ZeroOne.lean,ProbabilityTheory.measure_zero_or_one_of_measurableSet_limsup_atTop,measure_zero_or_one_of_measurableSet_limsup_atTop,20100f1475ea197bf6dea643b6ee137219455a51,":=
  measure_eq_zero_or_one_of_indepSetCat_self
    ((indep_limsup_atTop_self h_le h_indep).indepSet_of_measurableSet ht_tail ht_tail)",error:  unknown identifier 'measure_eq_zero_or_one_of_indepSetCat_self',"theorem measure_zero_or_one_of_measurableSet_limsup_atTop (h_le : ‚àÄ n, s n ‚â§ m0)
    (h_indep : iIndep s Œº) {t : Set Œ©} (ht_tail : MeasurableSet[limsup s atTop] t) :
    Œº t = 0 ‚à® Œº t = 1 ",":= by
  simpa only [ae_dirac_eq, Filter.eventually_pure]
    using kernel.measure_zero_or_one_of_measurableSet_limsup_atTop h_le h_indep ht_tail"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.hasIntegral_GP_pderiv,hasIntegral_GP_pderiv,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine' HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le _ _ _ s hs _ _
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine' .and _ (.and _ _)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) :=
          inter_subset_inter_left _ (closedBall_subset_closedBall hŒ¥.2)
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := (add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ))
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine' this.eventually (ge_mem_nhds _)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine' ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ _‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine' (norm_sub_le _ _).trans (add_le_add _ _)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine' (mul_le_mul_of_nonneg_right _ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
          _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine' (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans _
      refine' (mul_le_mul_of_nonneg_right _ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine' prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => _
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := (dist_le_pi_dist J.upper J.lower (i.succAbove j))
        _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
        _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
        _ ‚â§ 1 / 2 + 1 / 2 := (add_le_add hŒ¥12 hŒ¥12)
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1 ((Hd x hx).def Œµ'0) with
      ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine' ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => _‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine' (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ _) (hJc rfl)).trans _
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg","error:  dsimp made no progress
error:  invalid field 'def', the environment does not contain 'HasFDerivWithinAt.def'
  Hd x hx
has type
  HasFDerivWithinAt f (f' x) (Box.Icc I) x
error:  invalid field 'def', the environment does not contain 'HasFDerivAtFilter.def'
  Hd x hx
has type
  HasFDerivAtFilter f (f' x) x (ùìù[Box.Icc I] x)
error:  type mismatch
  HŒ¥ ?m.83042
has type
  ?m.83041 ‚àà ?m.81872 : Prop
but is expected to have type
  ‚Äñf y - ?m.83027 - ?m.82967 (y - x)‚Äñ ‚â§ Œµ' * ‚Äñy - x‚Äñ : Prop
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  E","theorem hasIntegral_GP_pderiv (f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E)
    (f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E) (s : Set (Fin (n + 1) ‚Üí ‚Ñù))
    (hs : s.Countable) (Hs : ‚àÄ x ‚àà s, ContinuousWithinAt f (Box.Icc I) x)
    (Hd : ‚àÄ x ‚àà (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :
    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume
      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))
          BoxAdditiveMap.volume -
        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))
          BoxAdditiveMap.volume) ",":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le ?_ ?_ _ s hs ?_ ?_
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine .and ?_ (.and ?_ ?_)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) := by gcongr; exact hŒ¥.2
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ)
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine this.eventually (ge_mem_nhds ?_)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ ?_‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp [F]
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine (norm_sub_le _ _).trans (add_le_add ?_ ?_)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine (mul_le_mul_of_nonneg_right ?_ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
          _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans ?_
      refine (mul_le_mul_of_nonneg_right ?_ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => ?_
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := dist_le_pi_dist J.upper J.lower (i.succAbove j)
        _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
        _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1
      ((Hd x hx).isLittleO.def Œµ'0) with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => ?_‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ ?_) (hJc rfl)).trans ?_
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg"
Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean,Polynomial.natTrailingDegree_le_trailingDegree,natTrailingDegree_le_trailingDegree,bc769a9f781a01550bc7da7431e6157f3b3d6c81,":=
  ENat.coe_toNat_le_self _","error:  type mismatch
  ENat.coe_toNat_le_self ?m.4446
has type
  ‚Üë?m.4446.toNat ‚â§ ?m.4446 : Prop
but is expected to have type
  ‚Üëp.natTrailingDegree ‚â§ p.trailingDegree : Prop",theorem natTrailingDegree_le_trailingDegree : ‚Üë(natTrailingDegree p) ‚â§ trailingDegree p ,":= by
  by_cases hp : p = 0;
  ¬∑ rw [hp, trailingDegree_zero]
    exact le_top
  rw [trailingDegree_eq_natTrailingDegree hp]"
Mathlib/LinearAlgebra/Dimension/Finite.lean,rank_eq_zero_iff,rank_eq_zero_iff,b09462282225ca03a37b7e6afde435d1ab7552ef,":= by
  nontriviality R
  constructor
  ¬∑ contrapose!
    rintro ‚ü®x, hx‚ü©
    rw [‚Üê Cardinal.one_le_iff_ne_zero]
    have : LinearIndependent R (fun _ : Unit ‚Ü¶ x)
    ¬∑ exact linearIndependent_iff.mpr (fun l hl ‚Ü¶ Finsupp.unique_ext <| not_not.mp fun H ‚Ü¶
        hx _ H ((Finsupp.total_unique _ _ _).symm.trans hl))
    simpa using this.cardinal_lift_le_rank
  ¬∑ intro h
    rw [‚Üê le_zero_iff, Module.rank_def]
    apply ciSup_le'
    intro ‚ü®s, hs‚ü©
    rw [nonpos_iff_eq_zero, Cardinal.mk_eq_zero_iff, ‚Üê not_nonempty_iff]
    rintro ‚ü®i : s‚ü©
    obtain ‚ü®a, ha, ha'‚ü© := h i
    apply ha
    simpa using FunLike.congr_fun (linearIndependent_iff.mp hs (Finsupp.single i a) (by simpa)) i","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case mp.intro
R : Type u
M M‚ÇÅ : Type v
M' : Type v'
Œπ : Type w
inst‚úù‚Å∂ : Ring R
inst‚úù‚Åµ : AddCommGroup M
inst‚úù‚Å¥ : AddCommGroup M'
inst‚úù¬≥ : AddCommGroup M‚ÇÅ
inst‚úù¬≤ : Module R M
inst‚úù¬π : Module R M'
inst‚úù : Module R M‚ÇÅ
a‚úù : Nontrivial R
x : M
hx : ‚àÄ (a : R), a ‚â† 0 ‚Üí a ‚Ä¢ x ‚â† 0
this : LinearIndependent R fun x_1 ‚Ü¶ x
‚ä¢ 1 ‚â§ Module.rank R M
error:  unsolved goals
case mpr
R : Type u
M M‚ÇÅ : Type v
M' : Type v'
Œπ : Type w
inst‚úù‚Å∂ : Ring R
inst‚úù‚Åµ : AddCommGroup M
inst‚úù‚Å¥ : AddCommGroup M'
inst‚úù¬≥ : AddCommGroup M‚ÇÅ
inst‚úù¬≤ : Module R M
inst‚úù¬π : Module R M'
inst‚úù : Module R M‚ÇÅ
a‚úù : Nontrivial R
‚ä¢ (‚àÄ (x : M), ‚àÉ a, a ‚â† 0 ‚àß a ‚Ä¢ x = 0) ‚Üí Module.rank R M = 0","lemma rank_eq_zero_iff :
    Module.rank R M = 0 ‚Üî ‚àÄ x : M, ‚àÉ a : R, a ‚â† 0 ‚àß a ‚Ä¢ x = 0 ",":= by
  nontriviality R
  constructor
  ¬∑ contrapose!
    rintro ‚ü®x, hx‚ü©
    rw [‚Üê Cardinal.one_le_iff_ne_zero]
    have : LinearIndependent R (fun _ : Unit ‚Ü¶ x) :=
      linearIndependent_iff.mpr (fun l hl ‚Ü¶ Finsupp.unique_ext <| not_not.mp fun H ‚Ü¶
        hx _ H ((Finsupp.total_unique _ _ _).symm.trans hl))
    simpa using this.cardinal_lift_le_rank
  ¬∑ intro h
    rw [‚Üê le_zero_iff, Module.rank_def]
    apply ciSup_le'
    intro ‚ü®s, hs‚ü©
    rw [nonpos_iff_eq_zero, Cardinal.mk_eq_zero_iff, ‚Üê not_nonempty_iff]
    rintro ‚ü®i : s‚ü©
    obtain ‚ü®a, ha, ha'‚ü© := h i
    apply ha
    simpa using DFunLike.congr_fun (linearIndependent_iff.mp hs (Finsupp.single i a) (by simpa)) i"
Mathlib/MeasureTheory/Measure/MeasureSpace.lean,MeasureTheory.tsum_measure_preimage_singleton,tsum_measure_preimage_singleton,773a35f7c6fb4a80bd7a461018c89fc559fd98ca,":= by
  rw [‚Üê Set.bunion·µ¢_preimage_singleton, measure_bunion·µ¢ hs (pairwiseDisjoint_fiber f s) hf]","error:  unknown constant 'Set.bunion·µ¢_preimage_singleton'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.29915
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
Œ¥ : Type u_4
Œπ : Type u_5
R : Type u_6
R' : Type u_7
m : MeasurableSpace Œ±
Œº Œº‚ÇÅ Œº‚ÇÇ : Measure Œ±
s‚úù s‚ÇÅ s‚ÇÇ t : Set Œ±
s : Set Œ≤
hs : s.Countable
f : Œ± ‚Üí Œ≤
hf : ‚àÄ y ‚àà s, MeasurableSet (f ‚Åª¬π' {y})
‚ä¢ ‚àë' (b : ‚Üës), Œº (f ‚Åª¬π' {‚Üëb}) = Œº (f ‚Åª¬π' s)
warning:  @Measure.AbsolutelyContinuous does not have a doc string","theorem tsum_measure_preimage_singleton {s : Set Œ≤} (hs : s.Countable) {f : Œ± ‚Üí Œ≤}
    (hf : ‚àÄ y ‚àà s, MeasurableSet (f ‚Åª¬π' {y})) : (‚àë' b : s, Œº (f ‚Åª¬π' {‚Üëb})) = Œº (f ‚Åª¬π' s) ",":= by
  rw [‚Üê Set.biUnion_preimage_singleton, measure_biUnion hs (pairwiseDisjoint_fiber f s) hf]"
Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean,dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt,dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt,88676a0fc6cc37bc23ba9735a55e5ec60dda3449,":= by
  letI := B.finiteDimensional
  let P := minpoly R B.gen
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  have finrank_K_L : FiniteDimensional.finrank K L = B.dim := B.finrank
  have deg_K_P : (minpoly K B.gen).natDegree = B.dim := B.natDegree_minpoly
  have deg_R_P : P.natDegree = B.dim := by
    rw [‚Üê deg_K_P, minpoly.isIntegrallyClosed_eq_field_fractions' K hBint,
      (minpoly.monic hBint).natDegree_map (algebraMap R K)]
  choose! f hf using
    hei.isWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
      (minpoly.monic hBint)
  simp only [(minpoly.monic hBint).natDegree_map, deg_R_P] at hf
  suffices
      p ^ n.succ ‚à£ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n) by
    have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
      hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
    refine @Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd R _ _ _ _ n hp (?_ : _ ‚à£ _)  hndiv
    convert (IsUnit.dvd_mul_right ‚ü®(-1) ^ (n.succ * n), rfl‚ü©).mpr this using 1
    push_cast
    ring_nf
    rw [mul_comm _ 2, pow_mul, neg_one_sq, one_pow, mul_one]
  have aux : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0, B.dim ‚â§ i + n := by
    intro i hi
    simp only [mem_range, mem_erase] at hi
    rw [hn]
    exact le_add_pred_of_pos _ hi.1
  have hintsum :
    IsIntegral R
      (z * B.gen ^ n - ‚àë x : ‚Ñï in (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ f (x + n)) := by
    refine
      isIntegral_sub (isIntegral_mul hzint (IsIntegral.pow hBint _))
        (IsIntegral.sum _ fun i hi => isIntegral_smul _ ?_)
    exact adjoin_le_integralClosure hBint (hf _ (aux i hi)).1
  obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
  use r
  apply IsFractionRing.injective R K
  simp only [_root_.map_mul, _root_.map_pow, _root_.map_neg, _root_.map_one]
  calc
    _ = norm K (Q.coeff 0 ‚Ä¢ B.gen ^ n) := ?_
    _ = norm K (p ‚Ä¢ (z * B.gen ^ n) -
          ‚àë x : ‚Ñï in (range (Q.natDegree + 1)).erase 0, p ‚Ä¢ Q.coeff x ‚Ä¢ f (x + n)) :=
        (congr_arg (norm K) (eq_sub_of_add_eq ?_))
    _ = _ := ?_
  ¬∑ simp only [Algebra.smul_def, algebraMap_apply R K L, Algebra.norm_algebraMap, _root_.map_mul,
      _root_.map_pow, finrank_K_L, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map, ‚Üê hn]
    ring
  swap
  ¬∑ simp_rw [‚Üê smul_sum, ‚Üê smul_sub, Algebra.smul_def p, algebraMap_apply R K L, _root_.map_mul,
      Algebra.norm_algebraMap, finrank_K_L, hr, ‚Üê hn]
  calc
    _ = (Q.coeff 0 ‚Ä¢ ‚Üë1 + ‚àë x : ‚Ñï in (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) *
          B.gen ^ n := ?_
    _ = (Q.coeff 0 ‚Ä¢ B.gen ^ 0 +
        ‚àë x : ‚Ñï in (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) * B.gen ^ n :=
      by rw [_root_.pow_zero]
    _ = aeval B.gen Q * B.gen ^ n := ?_
    _ = _ := by rw [hQ, Algebra.smul_mul_assoc]
  ¬∑ have : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0,
        Q.coeff i ‚Ä¢ (B.gen ^ i * B.gen ^ n) = p ‚Ä¢ Q.coeff i ‚Ä¢ f (i + n) := by
      intro i hi
      rw [‚Üê pow_add, ‚Üê (hf _ (aux i hi)).2, ‚Üê Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]
    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]
  ¬∑ rw [aeval_eq_sum_range,
      Finset.add_sum_erase (range (Q.natDegree + 1)) fun i => Q.coeff i ‚Ä¢ B.gen ^ i]
    simp","warning:  `PowerBasis.finiteDimensional` has been deprecated, use `PowerBasis.finite` instead
error:  unknown identifier 'isIntegral_sub'
error:  no goals to be solved","theorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} {Q : R[X]} (hQ : aeval B.gen Q = p ‚Ä¢ z)
    (hzint : IsIntegral R z) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) : p ‚à£ Q.coeff 0 ",":= by
  letI := B.finite
  let P := minpoly R B.gen
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  have finrank_K_L : FiniteDimensional.finrank K L = B.dim := B.finrank
  have deg_K_P : (minpoly K B.gen).natDegree = B.dim := B.natDegree_minpoly
  have deg_R_P : P.natDegree = B.dim := by
    rw [‚Üê deg_K_P, minpoly.isIntegrallyClosed_eq_field_fractions' K hBint,
      (minpoly.monic hBint).natDegree_map (algebraMap R K)]
  choose! f hf using
    hei.isWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
      (minpoly.monic hBint)
  simp only [(minpoly.monic hBint).natDegree_map, deg_R_P] at hf
  suffices
      p ^ n.succ ‚à£ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n) by
    have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
      hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
    refine @Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd R _ _ _ _ n hp (?_ : _ ‚à£ _) hndiv
    convert (IsUnit.dvd_mul_right ‚ü®(-1) ^ (n.succ * n), rfl‚ü©).mpr this using 1
    push_cast
    ring_nf
    rw [mul_comm _ 2, pow_mul, neg_one_sq, one_pow, mul_one]
  have aux : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0, B.dim ‚â§ i + n := by
    intro i hi
    simp only [mem_range, mem_erase] at hi
    rw [hn]
    exact le_add_pred_of_pos _ hi.1
  have hintsum :
    IsIntegral R
      (z * B.gen ^ n - ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ f (x + n)) := by
    refine (hzint.mul (hBint.pow _)).sub (.sum _ fun i hi => .smul _ ?_)
    exact adjoin_le_integralClosure hBint (hf _ (aux i hi)).1
  obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
  use r
  apply IsFractionRing.injective R K
  simp only [_root_.map_mul, _root_.map_pow, _root_.map_neg, _root_.map_one]
  calc
    _ = norm K (Q.coeff 0 ‚Ä¢ B.gen ^ n) := ?_
    _ = norm K (p ‚Ä¢ (z * B.gen ^ n) -
          ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, p ‚Ä¢ Q.coeff x ‚Ä¢ f (x + n)) :=
        (congr_arg (norm K) (eq_sub_of_add_eq ?_))
    _ = _ := ?_
  ¬∑ simp only [Algebra.smul_def, algebraMap_apply R K L, Algebra.norm_algebraMap, _root_.map_mul,
      _root_.map_pow, finrank_K_L, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map, ‚Üê hn]
    ring
  swap
  ¬∑ simp_rw [‚Üê smul_sum, ‚Üê smul_sub, Algebra.smul_def p, algebraMap_apply R K L, _root_.map_mul,
      Algebra.norm_algebraMap, finrank_K_L, hr, ‚Üê hn]
  calc
    _ = (Q.coeff 0 ‚Ä¢ ‚Üë1 + ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) *
          B.gen ^ n := ?_
    _ = (Q.coeff 0 ‚Ä¢ B.gen ^ 0 +
        ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) * B.gen ^ n := by
      rw [_root_.pow_zero]
    _ = aeval B.gen Q * B.gen ^ n := ?_
    _ = _ := by rw [hQ, Algebra.smul_mul_assoc]
  ¬∑ have : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0,
        Q.coeff i ‚Ä¢ (B.gen ^ i * B.gen ^ n) = p ‚Ä¢ Q.coeff i ‚Ä¢ f (i + n) := by
      intro i hi
      rw [‚Üê pow_add, ‚Üê (hf _ (aux i hi)).2, ‚Üê Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]
    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]
  ¬∑ rw [aeval_eq_sum_range,
      Finset.add_sum_erase (range (Q.natDegree + 1)) fun i => Q.coeff i ‚Ä¢ B.gen ^ i]
    simp"
Mathlib/Geometry/Manifold/Instances/Sphere.lean,mfderiv_coe_sphere_injective,mfderiv_coe_sphere_injective,28f34517ea07a4ecc94b3d55041dd0ca1152a2a8,":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ùïú := ‚Ñù) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices : Injective (fderiv ‚Ñù ((stereoInvFunAux (-v : E) ‚àò (‚Üë)) ‚àò U.symm) 0)
  ¬∑ convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddEquivClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have :
    HasFDerivAt (stereoInvFunAux (-v : E) ‚àò (Subtype.val : (‚Ñù ‚Ä¢ (‚Üë(-v) : E))·óÆ ‚Üí E))
      (‚Ñù ‚Ä¢ (‚Üë(-v) : E))·óÆ.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg FunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective",error:  unexpected token ':'; expected term,"theorem mfderiv_coe_sphere_injective {n : ‚Ñï} [Fact (finrank ‚Ñù E = n + 1)] (v : sphere (0 : E) 1) :
    Injective (mfderiv (ùì° n) ùìò(‚Ñù, E) ((‚Üë) : sphere (0 : E) 1 ‚Üí E) v) ",":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ùïú := ‚Ñù) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices Injective (fderiv ‚Ñù ((stereoInvFunAux (-v : E) ‚àò (‚Üë)) ‚àò U.symm) 0) by
    convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddEquivClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have : HasFDerivAt (stereoInvFunAux (-v : E) ‚àò (Subtype.val : (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ ‚Üí E))
      (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective"
Mathlib/Combinatorics/SetFamily/FourFunctions.lean,Finset.card_le_card_diffs,Finset.card_le_card_diffs,524dc927eaff6bab28332a3ede030d3593f3e7bc,":=
  le_of_pow_le_pow 2 (zero_le _) two_pos $ by simpa [‚Üêsq] using s.le_card_diffs_mul_card_diffs s","warning:  `le_of_pow_le_pow` has been deprecated, use `le_of_pow_le_pow_left` instead
error:  numerals are data in Lean, but the expected type is a proposition
  ?m.408446 ‚â† 0 : Prop",lemma Finset.card_le_card_diffs (s : Finset Œ±) : s.card ‚â§ (s \\ s).card ,":=
  le_of_pow_le_pow_left two_ne_zero (zero_le _) <| by
    simpa [‚Üê sq] using s.le_card_diffs_mul_card_diffs s"
Mathlib/Geometry/Manifold/Instances/Sphere.lean,mfderiv_coe_sphere_injective,mfderiv_coe_sphere_injective,7962047919fd0329ddca78b1a70bd94a7b06f8ca,":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ùïú := ‚Ñù) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices Injective (fderiv ‚Ñù ((stereoInvFunAux (-v : E) ‚àò (‚Üë)) ‚àò U.symm) 0) by
    convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddHomClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have : HasFDerivAt (stereoInvFunAux (-v : E) ‚àò (Subtype.val : (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ ‚Üí E))
      (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective","error:  unknown constant 'AddHomClass.map_eq_zero_iff'
error:  simp made no progress","theorem mfderiv_coe_sphere_injective {n : ‚Ñï} [Fact (finrank ‚Ñù E = n + 1)] (v : sphere (0 : E) 1) :
    Injective (mfderiv (ùì° n) ùìò(‚Ñù, E) ((‚Üë) : sphere (0 : E) 1 ‚Üí E) v) ",":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ùïú := ‚Ñù) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices Injective (fderiv ‚Ñù ((stereoInvFunAux (-v : E) ‚àò (‚Üë)) ‚àò U.symm) 0) by
    convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddEquivClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have : HasFDerivAt (stereoInvFunAux (-v : E) ‚àò (Subtype.val : (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ ‚Üí E))
      (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective"
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow,discr_prime_pow,704efa4d928b79ac7249410b96a25d6fba557a5e,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), succ_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2
      ¬∑ rwa [Ne.def, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]; ¬∑ norm_cast
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, MulZeroClass.zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact_mod_cast hŒ∂.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact_mod_cast hŒ∂.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by linarith)] at this
      exact absurd (pow_eq_zero h) this","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case e_a.inr
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2‚úù : p = 2 ‚Üí k ‚â† 0
hp2 : ‚Üëp ‚â† 2
‚ä¢ (-1) ^ (‚Üëp ^ k * (‚Üëp - 1) * (‚Üëp ^ k * (‚Üëp - 1) - 1) / 2) = (-1) ^ (‚Üëp ^ k * (‚Üëp - 1) / 2)
error:  unsolved goals
case e_a
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2 : p = 2 ‚Üí k ‚â† 0
‚ä¢ (Algebra.norm K) ((aeval Œ∂) (derivative (cyclotomic (‚Üëp ^ (k + 1)) K))) = ‚Üë‚Üëp ^ (‚Üëp ^ k * ((‚Üëp - 1) * (k + 1) - 1))","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ‚Ñï).Prime]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1)) : ‚Ñï) K))
    (hk : p ^ (k + 1) ‚â† 2) : discr K (hŒ∂.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : ‚Ñï).totient / 2) * p ^ ((p : ‚Ñï) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this"
Mathlib/Data/ENat/Lattice.lean,ENat.iInf_coe_ne_top,iInf_coe_ne_top,a2d4b97db742cef33d7ce3404f92ab85330707e5,":= by
  rw [Ne.def, iInf_coe_eq_top, not_isEmpty_iff]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.1318 ‚Üí ?m.1318 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.1320
Œπ : Sort u_1
f : Œπ ‚Üí ‚Ñï
s : Set ‚Ñï
‚ä¢ ‚®Ö i, ‚Üë(f i) ‚â† ‚ä§ ‚Üî Nonempty Œπ","lemma iInf_coe_ne_top : ‚®Ö i, (f i : ‚Ñï‚àû) ‚â† ‚ä§ ‚Üî Nonempty Œπ ",":= by
  rw [Ne, iInf_coe_eq_top, not_isEmpty_iff]"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.join_think,join_think,88f252d9ef6777980e9cb4396094e178f3ed4acb,":= by
  simp [think, join]
  simp [join, Seq1.pure]","error:  unknown constant 'Stream'.Seq1.pure'
error:  simp made no progress",theorem join_think (S : WSeq (WSeq Œ±)) : join (think S) = think (join S) ,":= by
  simp only [join, think]
  dsimp only [(¬∑ <$> ¬∑)]
  simp [join, Seq1.ret]"
Mathlib/MeasureTheory/Measure/Haar/Basic.lean,MeasureTheory.Measure.div_mem_nhds_one_of_haar_pos,div_mem_nhds_one_of_haar_pos,488012d0f5ac537bb8055c310b3f223de3f6802e,":= by
  obtain ‚ü®K, hKE, hK, K_closed, hKpos‚ü© :
      ‚àÉ (K : Set G), K ‚äÜ E ‚àß IsCompact K ‚àß IsClosed K ‚àß 0 < Œº K := by
    rcases MeasurableSet.exists_lt_isCompact hE hEpos with ‚ü®K, KE, K_comp, K_meas‚ü©
    refine ‚ü®closure K, ?_, K_comp.closure, isClosed_closure, ?_‚ü©
    ¬∑ exact IsCompact.closure_subset_of_measurableSet_of_group K_comp hE KE
    ¬∑ rwa [K_comp.measure_closure_eq_of_group]
  obtain ‚ü®V, hV1, hV‚ü© : ‚àÉ V ‚àà ùìù (1 : G), ‚àÄ g ‚àà V, Œº (g ‚Ä¢ K \ K) < Œº K :=
    exists_nhds_measure_smul_diff_lt hK K_closed hKpos.ne'
  have hv : ‚àÄ v : G, v ‚àà V ‚Üí ¬¨Disjoint (v ‚Ä¢ K) K := by
    intro v hv hKv
    have Z := hV v hv
    rw [hKv.symm.sdiff_eq_right, measure_smul] at Z
    exact lt_irrefl _ Z
  suffices V ‚äÜ E / E from Filter.mem_of_superset hV1 this
  intro v hvV
  obtain ‚ü®x, hxK, hxvK‚ü© : ‚àÉ x : G, x ‚àà v ‚Ä¢ K ‚àß x ‚àà K := Set.not_disjoint_iff.1 (hv v hvV)
  refine ‚ü®x, hKE hxvK, v‚Åª¬π * x, hKE ?_, ?_‚ü©
  ¬∑ simpa [mem_smul_set_iff_inv_smul_mem] using hxK
  ¬∑ simp only [div_eq_iff_eq_mul, ‚Üê mul_assoc, mul_right_inv, one_mul]","warning:  `IsCompact.closure_subset_of_measurableSet_of_group` has been deprecated, use `IsCompact.closure_subset_measurableSet` instead
warning:  `IsCompact.measure_closure_eq_of_group` has been deprecated, use `IsCompact.measure_closure` instead
error:  unknown identifier 'exists_nhds_measure_smul_diff_lt'","theorem div_mem_nhds_one_of_haar_pos (Œº : Measure G) [IsHaarMeasure Œº] [LocallyCompactSpace G]
    [InnerRegular Œº] (E : Set G) (hE : MeasurableSet E) (hEpos : 0 < Œº E) :
    E / E ‚àà ùìù (1 : G) ",":= by
  obtain ‚ü®K, hKE, hK, K_closed, hKpos‚ü© :
      ‚àÉ (K : Set G), K ‚äÜ E ‚àß IsCompact K ‚àß IsClosed K ‚àß 0 < Œº K := by
    rcases MeasurableSet.exists_lt_isCompact hE hEpos with ‚ü®K, KE, K_comp, K_meas‚ü©
    refine ‚ü®closure K, ?_, K_comp.closure, isClosed_closure, ?_‚ü©
    ¬∑ exact K_comp.closure_subset_measurableSet hE KE
    ¬∑ rwa [K_comp.measure_closure]
  filter_upwards [eventually_nhds_one_measure_smul_diff_lt hK K_closed hKpos.ne' (Œº := Œº)] with g hg
  have : ¬¨Disjoint (g ‚Ä¢ K) K := fun hd ‚Ü¶ by
    rw [hd.symm.sdiff_eq_right, measure_smul] at hg
    exact hg.false
  rcases Set.not_disjoint_iff.1 this with ‚ü®_, ‚ü®x, hxK, rfl‚ü©, hgxK‚ü©
  simpa using div_mem_div (hKE hgxK) (hKE hxK)"
Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean,MeasureTheory.Measure.eventually_nonempty_inter_smul_of_density_one,eventually_nonempty_inter_smul_of_density_one,0609cd4fa0b9311afb49fcedcecd1590289a458d,":= by
  obtain ‚ü®t', t'_meas, t't, t'pos, t'top‚ü© : ‚àÉ t', MeasurableSet t' ‚àß t' ‚äÜ t ‚àß 0 < Œº t' ‚àß Œº t' < ‚ä§ :=
    exists_subset_measure_lt_top ht h't.bot_lt
  filter_upwards [(tendsto_order.1
          (tendsto_add_haar_inter_smul_one_of_density_one Œº s x h t' t'_meas t'pos.ne' t'top.ne)).1
      0 zero_lt_one]
  intro r hr
  have : Œº (s ‚à© ({x} + r ‚Ä¢ t')) ‚â† 0 := fun h' => by
    simp only [ENNReal.not_lt_zero, ENNReal.zero_div, h'] at hr
  have : (s ‚à© ({x} + r ‚Ä¢ t')).Nonempty := nonempty_of_measure_ne_zero this
  apply this.mono (inter_subset_inter Subset.rfl _)
  exact add_subset_add Subset.rfl (smul_set_mono t't)","error:  unknown identifier 'tendsto_add_haar_inter_smul_one_of_density_one'
error:  simp made no progress","theorem eventually_nonempty_inter_smul_of_density_one (s : Set E) (x : E)
    (h : Tendsto (fun r => Œº (s ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1)) (t : Set E)
    (ht : MeasurableSet t) (h't : Œº t ‚â† 0) :
    ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ t)).Nonempty ",":= by
  obtain ‚ü®t', t'_meas, t't, t'pos, t'top‚ü© : ‚àÉ t', MeasurableSet t' ‚àß t' ‚äÜ t ‚àß 0 < Œº t' ‚àß Œº t' < ‚ä§ :=
    exists_subset_measure_lt_top ht h't.bot_lt
  filter_upwards [(tendsto_order.1
          (tendsto_addHaar_inter_smul_one_of_density_one Œº s x h t' t'_meas t'pos.ne' t'top.ne)).1
      0 zero_lt_one]
  intro r hr
  have : Œº (s ‚à© ({x} + r ‚Ä¢ t')) ‚â† 0 := fun h' => by
    simp only [ENNReal.not_lt_zero, ENNReal.zero_div, h'] at hr
  have : (s ‚à© ({x} + r ‚Ä¢ t')).Nonempty := nonempty_of_measure_ne_zero this
  apply this.mono (inter_subset_inter Subset.rfl _)
  exact add_subset_add Subset.rfl (smul_set_mono t't)"
Mathlib/LinearAlgebra/LinearIndependent.lean,linearIndependent_iUnion_finite,linearIndependent_iUnion_finite,ddffab96a653674eaf6ec54e6415f6fa7c2a49f7,":= by
  classical
  rw [iUnion_eq_iUnion_finset f]
  apply linearIndependent_iUnion_of_directed
  ¬∑ apply directed_of_isDirected_le
    exact fun t‚ÇÅ t‚ÇÇ ht => iUnion_mono fun i => iUnion_subset_iUnion_const fun h => ht h
  intro t
  induction' t with i s his ih
  ¬∑ refine' (linearIndependent_empty R M).mono _
    simp
  ¬∑ rw [Finset.set_biUnion_insert]
    refine' (hl _).union ih _
    rw [span_iUnion‚ÇÇ]
    exact hd i s s.finite_toSet his","error:  unsolved goals
case h.mk
Œπ‚úù : Type u'
Œπ' : Type u_1
R : Type u_2
K : Type u_3
M : Type u_4
M' : Type u_5
M'' : Type u_6
V : Type u
V' : Type u_7
v : Œπ‚úù ‚Üí M
inst‚úù‚Å∂ : Ring R
inst‚úù‚Åµ : AddCommGroup M
inst‚úù‚Å¥ : AddCommGroup M'
inst‚úù¬≥ : AddCommGroup M''
inst‚úù¬≤ : Module R M
inst‚úù¬π : Module R M'
inst‚úù : Module R M''
a b : R
x y : M
Œπ : Type u_8
f : Œπ ‚Üí Set M
hl : ‚àÄ (i : Œπ), LinearIndependent R fun (x : ‚Üë(f i)) ‚Ü¶ ‚Üëx
hd : ‚àÄ (i : Œπ) (t : Set Œπ), t.Finite ‚Üí i ‚àâ t ‚Üí Disjoint (span R (f i)) (‚®Ü i ‚àà t, span R (f i))
i : Multiset Œπ
s : i.Nodup
‚ä¢ ‚àÄ i_1 ‚àà i, f i_1 ‚äÜ ‚àÖ
error:  no goals to be solved","theorem linearIndependent_iUnion_finite_subtype {Œπ : Type*} {f : Œπ ‚Üí Set M}
    (hl : ‚àÄ i, LinearIndependent R (fun x => x : f i ‚Üí M))
    (hd : ‚àÄ i, ‚àÄ t : Set Œπ, t.Finite ‚Üí i ‚àâ t ‚Üí Disjoint (span R (f i)) (‚®Ü i ‚àà t, span R (f i))) :
    LinearIndependent R (fun x => x : (‚ãÉ i, f i) ‚Üí M) ",":= by
  classical
  rw [iUnion_eq_iUnion_finset f]
  apply linearIndependent_iUnion_of_directed
  ¬∑ apply directed_of_isDirected_le
    exact fun t‚ÇÅ t‚ÇÇ ht => iUnion_mono fun i => iUnion_subset_iUnion_const fun h => ht h
  intro t
  induction' t using Finset.induction_on with i s his ih
  ¬∑ refine (linearIndependent_empty R M).mono ?_
    simp
  ¬∑ rw [Finset.set_biUnion_insert]
    refine (hl _).union ih ?_
    rw [span_iUnion‚ÇÇ]
    exact hd i s s.finite_toSet his"
Mathlib/MeasureTheory/Integral/SetIntegral.lean,MeasureTheory.integral_union_eq_left_of_ae_aux,integral_union_eq_left_of_ae_aux,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  let k := f ‚Åª¬π' {0}
  have hk : MeasurableSet k := by borelize E; exact haux.measurable (measurableSet_singleton _)
  have h's : IntegrableOn f s Œº := H.mono (subset_union_left _ _) le_rfl
  have A : ‚àÄ u : Set X, ‚à´ x in u ‚à© k, f x ‚àÇŒº = 0 := fun u =>
    setIntegral_eq_zero_of_forall_eq_zero fun x hx => hx.2
  rw [‚Üê integral_inter_add_diff hk h's, ‚Üê integral_inter_add_diff hk H, A, A, zero_add, zero_add,
    union_diff_distrib, union_comm]
  apply setIntegral_congr_set_ae
  rw [union_ae_eq_right]
  apply measure_mono_null (diff_subset _ _)
  rw [measure_zero_iff_ae_nmem]
  filter_upwards [ae_imp_of_ae_restrict ht_eq] with x hx h'x using h'x.2 (hx h'x.1)","error:  function expected at
  subset_union_left ?m.81487
term has type
  ?m.81486 ‚àà ?m.81484 ‚à™ ?m.81485
error:  function expected at
  diff_subset ?m.83368
term has type
  ?m.83367 ‚àà ?m.83365","theorem integral_union_eq_left_of_ae_aux (ht_eq : ‚àÄ·µê x ‚àÇŒº.restrict t, f x = 0)
    (haux : StronglyMeasurable f) (H : IntegrableOn f (s ‚à™ t) Œº) :
    ‚à´ x in s ‚à™ t, f x ‚àÇŒº = ‚à´ x in s, f x ‚àÇŒº ",":= by
  let k := f ‚Åª¬π' {0}
  have hk : MeasurableSet k := by borelize E; exact haux.measurable (measurableSet_singleton _)
  have h's : IntegrableOn f s Œº := H.mono subset_union_left le_rfl
  have A : ‚àÄ u : Set X, ‚à´ x in u ‚à© k, f x ‚àÇŒº = 0 := fun u =>
    setIntegral_eq_zero_of_forall_eq_zero fun x hx => hx.2
  rw [‚Üê integral_inter_add_diff hk h's, ‚Üê integral_inter_add_diff hk H, A, A, zero_add, zero_add,
    union_diff_distrib, union_comm]
  apply setIntegral_congr_set_ae
  rw [union_ae_eq_right]
  apply measure_mono_null diff_subset
  rw [measure_zero_iff_ae_nmem]
  filter_upwards [ae_imp_of_ae_restrict ht_eq] with x hx h'x using h'x.2 (hx h'x.1)"
Mathlib/Data/Int/ModEq.lean,Int.ModEq.cancel_right_div_gcd,cancel_right_div_gcd,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  letI d := gcd m c
  have hmd := gcd_dvd_left m c
  have hcd := gcd_dvd_right m c
  rw [modEq_iff_dvd] at h ‚ä¢
  refine Int.dvd_of_dvd_mul_right_of_gcd_one (?_ : m / d ‚à£ c / d * (b - a)) ?_
  ¬∑ rw [mul_comm, ‚Üê Int.mul_ediv_assoc (b - a) hcd, sub_mul]
    exact Int.ediv_dvd_ediv hmd h
  ¬∑ rw [gcd_div hmd hcd, natAbs_ofNat, Nat.div_self (gcd_pos_of_ne_zero_left c hm.ne')]","warning:  ModEq does not have a doc string
error:  function expected at
  gcd_dvd_left
term has type
  ‚Üë(?m.14815.gcd ?m.14816) ‚à£ ?m.14815
error:  unsolved goals
m n a b c d‚úù : ‚Ñ§
hm : 0 < m
h : a * c ‚â° b * c [ZMOD m]
d : ‚Ñï := m.gcd c
‚ä¢ a ‚â° b [ZMOD m / ‚Üë(m.gcd c)]","theorem cancel_right_div_gcd (hm : 0 < m) (h : a * c ‚â° b * c [ZMOD m]) :
    a ‚â° b [ZMOD m / gcd m c] ",":= by
  letI d := gcd m c
  rw [modEq_iff_dvd] at h ‚ä¢
  refine Int.dvd_of_dvd_mul_right_of_gcd_one (?_ : m / d ‚à£ c / d * (b - a)) ?_
  ¬∑ rw [mul_comm, ‚Üê Int.mul_ediv_assoc (b - a) gcd_dvd_right, sub_mul]
    exact Int.ediv_dvd_ediv gcd_dvd_left h
  ¬∑ rw [gcd_div gcd_dvd_left gcd_dvd_right, natAbs_ofNat,
      Nat.div_self (gcd_pos_of_ne_zero_left c hm.ne')]"
Mathlib/Computability/Primrec.lean,Nat.Primrec'.add,add,dc0b2fb410ce57ee8ea5b9ce5b357ce030465e7a,":=
  (prec .id ((Primrec.succ.comp right).comp right)).of_eq fun p => by
    simp; induction p.unpair.2 <;> simp [*, ‚Üê Nat.add_assoc']","error:  unknown constant 'Nat.add_assoc''
error:  unknown constant 'Nat.add_assoc''
error:  unsolved goals
case succ
p n‚úù : ‚Ñï
a‚úù : Nat.rec (unpair p).1 (fun y IH ‚Ü¶ IH + 1) n‚úù = (unpair p).1 + n‚úù
‚ä¢ (unpair p).1 + n‚úù + 1 = (unpair p).1 + (n‚úù + 1)",theorem add : Nat.Primrec (unpaired (¬∑ + ¬∑)) ,":=
  (prec .id ((Primrec.succ.comp right).comp right)).of_eq fun p => by
    simp; induction p.unpair.2 <;> simp [*, Nat.add_assoc]"
Mathlib/Order/OrderIsoNat.lean,exists_increasing_or_nonincreasing_subseq,exists_increasing_or_nonincreasing_subseq,ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  classical
    let bad : Set ‚Ñï := { m | ‚àÄ n, m < n ‚Üí ¬¨r (f m) (f n) }
    by_cases hbad : Infinite bad
    ¬∑ haveI := hbad
      refine ‚ü®Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => ?_‚ü©
      have h := @Set.mem_range_self _ _ ‚Üë(Nat.orderEmbeddingOfSet bad) m
      rw [Nat.orderEmbeddingOfSet_range bad] at h
      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)
    ¬∑ rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad
      obtain ‚ü®m, hm‚ü© : ‚àÉ m, ‚àÄ n, m ‚â§ n ‚Üí ¬¨n ‚àà bad := by
        by_cases he : hbad.toFinset.Nonempty
        ¬∑ refine
            ‚ü®(hbad.toFinset.max' he).succ, fun n hn nbad =>
              Nat.not_succ_le_self _
                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))‚ü©
        ¬∑ exact ‚ü®0, fun n _ nbad => he ‚ü®n, hbad.mem_toFinset.2 nbad‚ü©‚ü©
      have h : ‚àÄ n : ‚Ñï, ‚àÉ n' : ‚Ñï, n < n' ‚àß r (f (n + m)) (f (n' + m)) := by
        intro n
        have h := hm _ (le_add_of_nonneg_left n.zero_le)
        simp only [bad, exists_prop, not_not, Set.mem_setOf_eq, not_forall] at h
        obtain ‚ü®n', hn1, hn2‚ü© := h
        obtain ‚ü®x, hpos, rfl‚ü© := exists_pos_add_of_lt hn1
        refine ‚ü®n + x, add_lt_add_left hpos n, ?_‚ü©
        rw [add_assoc, add_comm x m, ‚Üê add_assoc]
        exact hn2
      let g' : ‚Ñï ‚Üí ‚Ñï := @Nat.rec (fun _ => ‚Ñï) m fun n gn => Nat.find (h gn)
      exact
        ‚ü®(RelEmbedding.natLT (fun n => g' n + m) fun n =>
              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,
          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2‚ü©","error:  failed to synthesize
  CovariantClass ‚Ñï ‚Ñï (Function.swap fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  exists_pos_add_of_lt hn1
argument
  hn1
has type
  @LT.lt ‚Ñï instLTNat (n + m) n' : Prop
but is expected to have type
  @LT.lt ‚Ñï Preorder.toLT (n + m) n' : Prop","theorem exists_increasing_or_nonincreasing_subseq' (r : Œ± ‚Üí Œ± ‚Üí Prop) (f : ‚Ñï ‚Üí Œ±) :
    ‚àÉ g : ‚Ñï ‚Ü™o ‚Ñï,
      (‚àÄ n : ‚Ñï, r (f (g n)) (f (g (n + 1)))) ‚à® ‚àÄ m n : ‚Ñï, m < n ‚Üí ¬¨r (f (g m)) (f (g n)) ",":= by
  classical
    let bad : Set ‚Ñï := { m | ‚àÄ n, m < n ‚Üí ¬¨r (f m) (f n) }
    by_cases hbad : Infinite bad
    ¬∑ haveI := hbad
      refine ‚ü®Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => ?_‚ü©
      have h := @Set.mem_range_self _ _ ‚Üë(Nat.orderEmbeddingOfSet bad) m
      rw [Nat.orderEmbeddingOfSet_range bad] at h
      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)
    ¬∑ rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad
      obtain ‚ü®m, hm‚ü© : ‚àÉ m, ‚àÄ n, m ‚â§ n ‚Üí ¬¨n ‚àà bad := by
        by_cases he : hbad.toFinset.Nonempty
        ¬∑ refine
            ‚ü®(hbad.toFinset.max' he).succ, fun n hn nbad =>
              Nat.not_succ_le_self _
                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))‚ü©
        ¬∑ exact ‚ü®0, fun n _ nbad => he ‚ü®n, hbad.mem_toFinset.2 nbad‚ü©‚ü©
      have h : ‚àÄ n : ‚Ñï, ‚àÉ n' : ‚Ñï, n < n' ‚àß r (f (n + m)) (f (n' + m)) := by
        intro n
        have h := hm _ (Nat.le_add_left m n)
        simp only [bad, exists_prop, not_not, Set.mem_setOf_eq, not_forall] at h
        obtain ‚ü®n', hn1, hn2‚ü© := h
        refine ‚ü®n + n' - n - m, by omega, ?_‚ü©
        convert hn2
        omega
      let g' : ‚Ñï ‚Üí ‚Ñï := @Nat.rec (fun _ => ‚Ñï) m fun n gn => Nat.find (h gn)
      exact
        ‚ü®(RelEmbedding.natLT (fun n => g' n + m) fun n =>
              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,
          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2‚ü©"
Mathlib/MeasureTheory/Function/SimpleFuncDenseLp.lean,MeasureTheory.Mem‚Ñíp.induction_dense,Mem‚Ñíp.induction_dense,22e97510854d6906cc856e022d297bf9cf8c9b3a,":= by
  rcases eq_or_ne p 0 with (rfl | hp_pos)
  ¬∑ rcases h0P (0 : E) MeasurableSet.empty (by simp only [measure_empty, WithTop.zero_lt_top])
        hŒµ with ‚ü®g, _, Pg‚ü©
    exact ‚ü®g, by simp only [snorm_exponent_zero, zero_le'], Pg‚ü©
  suffices H :
    ‚àÄ (f' : Œ± ‚Üí‚Çõ E) (Œ¥ : ‚Ñù‚â•0‚àû) (hŒ¥ : Œ¥ ‚â† 0), Mem‚Ñíp f' p Œº ‚Üí ‚àÉ g, snorm (‚áëf' - g) p Œº ‚â§ Œ¥ ‚àß P g
  ¬∑ obtain ‚ü®Œ∑, Œ∑pos, hŒ∑‚ü© := exists_Lp_half E Œº p hŒµ
    rcases hf.exists_simpleFunc_snorm_sub_lt hp_ne_top Œ∑pos.ne' with ‚ü®f', hf', f'_mem‚ü©
    rcases H f' Œ∑ Œ∑pos.ne' f'_mem with ‚ü®g, hg, Pg‚ü©
    refine' ‚ü®g, _, Pg‚ü©
    convert (hŒ∑ _ _ (hf.aestronglyMeasurable.sub f'.aestronglyMeasurable)
          (f'.aestronglyMeasurable.sub (h2P g Pg)) hf'.le hg).le using 2
    simp only [sub_add_sub_cancel]
  apply SimpleFunc.induction
  ¬∑ intro c s hs Œµ Œµpos Hs
    rcases eq_or_ne c 0 with (rfl | hc)
    ¬∑ rcases h0P (0 : E) MeasurableSet.empty (by simp only [measure_empty, WithTop.zero_lt_top])
          Œµpos with ‚ü®g, hg, Pg‚ü©
      rw [‚Üê snorm_neg, neg_sub] at hg
      refine' ‚ü®g, _, Pg‚ü©
      convert hg
      ext x
      simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_zero,
        piecewise_eq_indicator, indicator_zero', Pi.zero_apply, indicator_zero]
    ¬∑ have : Œº s < ‚àû := SimpleFunc.measure_lt_top_of_mem‚Ñíp_indicator hp_pos hp_ne_top hc hs Hs
      rcases h0P c hs this Œµpos with ‚ü®g, hg, Pg‚ü©
      rw [‚Üê snorm_neg, neg_sub] at hg
      exact ‚ü®g, hg, Pg‚ü©
  ¬∑ intro f f' hff' hf hf' Œ¥ Œ¥pos int_ff'
    obtain ‚ü®Œ∑, Œ∑pos, hŒ∑‚ü© := exists_Lp_half E Œº p Œ¥pos
    rw [SimpleFunc.coe_add,
      mem‚Ñíp_add_of_disjoint hff' f.stronglyMeasurable f'.stronglyMeasurable] at int_ff'
    rcases hf Œ∑ Œ∑pos.ne' int_ff'.1 with ‚ü®g, hg, Pg‚ü©
    rcases hf' Œ∑ Œ∑pos.ne' int_ff'.2 with ‚ü®g', hg', Pg'‚ü©
    refine' ‚ü®g + g', _, h1P g g' Pg Pg'‚ü©
    convert (hŒ∑ _ _ (f.aestronglyMeasurable.sub (h2P g Pg))
          (f'.aestronglyMeasurable.sub (h2P g' Pg')) hg hg').le using 2
    rw [SimpleFunc.coe_add]
    abel","error:  unexpected token '¬∑'; expected 'by' or 'from'
error:  unsolved goals
Œ± : Type u_1
Œ≤ : Type u_2
Œπ : Type u_3
E : Type u_4
F : Type u_5
ùïú : Type u_6
inst‚úù¬π : MeasurableSpace Œ±
inst‚úù : NormedAddCommGroup E
f‚úù : Œ± ‚Üí E
Œº : Measure Œ±
P : (Œ± ‚Üí E) ‚Üí Prop
h1P : ‚àÄ (f g : Œ± ‚Üí E), P f ‚Üí P g ‚Üí P (f + g)
h2P : ‚àÄ (f : Œ± ‚Üí E), P f ‚Üí AEStronglyMeasurable f Œº
f : Œ± ‚Üí E
Œµ : ‚Ñù‚â•0‚àû
hŒµ : Œµ ‚â† 0
hp_ne_top : 0 ‚â† ‚ä§
h0P :
  ‚àÄ (c : E) ‚¶És : Set Œ±‚¶Ñ,
    MeasurableSet s ‚Üí Œº s < ‚ä§ ‚Üí ‚àÄ {Œµ : ‚Ñù‚â•0‚àû}, Œµ ‚â† 0 ‚Üí ‚àÉ g, snorm (g - s.indicator fun x ‚Ü¶ c) 0 Œº ‚â§ Œµ ‚àß P g
hf : Mem‚Ñíp f 0 Œº
‚ä¢ 0 < ‚ä§
warning:  @Lp.simpleFunc does not have a doc string","theorem Mem‚Ñíp.induction_dense (hp_ne_top : p ‚â† ‚àû) (P : (Œ± ‚Üí E) ‚Üí Prop)
    (h0P :
      ‚àÄ (c : E) ‚¶És : Set Œ±‚¶Ñ,
        MeasurableSet s ‚Üí
          Œº s < ‚àû ‚Üí
            ‚àÄ {Œµ : ‚Ñù‚â•0‚àû}, Œµ ‚â† 0 ‚Üí ‚àÉ g : Œ± ‚Üí E, snorm (g - s.indicator fun _ => c) p Œº ‚â§ Œµ ‚àß P g)
    (h1P : ‚àÄ f g, P f ‚Üí P g ‚Üí P (f + g)) (h2P : ‚àÄ f, P f ‚Üí AEStronglyMeasurable f Œº) {f : Œ± ‚Üí E}
    (hf : Mem‚Ñíp f p Œº) {Œµ : ‚Ñù‚â•0‚àû} (hŒµ : Œµ ‚â† 0) : ‚àÉ g : Œ± ‚Üí E, snorm (f - g) p Œº ‚â§ Œµ ‚àß P g ",":= by
  rcases eq_or_ne p 0 with (rfl | hp_pos)
  ¬∑ rcases h0P (0 : E) MeasurableSet.empty (by simp only [measure_empty, zero_lt_top])
        hŒµ with ‚ü®g, _, Pg‚ü©
    exact ‚ü®g, by simp only [snorm_exponent_zero, zero_le'], Pg‚ü©
  suffices H : ‚àÄ (f' : Œ± ‚Üí‚Çõ E) (Œ¥ : ‚Ñù‚â•0‚àû) (hŒ¥ : Œ¥ ‚â† 0), Mem‚Ñíp f' p Œº ‚Üí
      ‚àÉ g, snorm (‚áëf' - g) p Œº ‚â§ Œ¥ ‚àß P g by
    obtain ‚ü®Œ∑, Œ∑pos, hŒ∑‚ü© := exists_Lp_half E Œº p hŒµ
    rcases hf.exists_simpleFunc_snorm_sub_lt hp_ne_top Œ∑pos.ne' with ‚ü®f', hf', f'_mem‚ü©
    rcases H f' Œ∑ Œ∑pos.ne' f'_mem with ‚ü®g, hg, Pg‚ü©
    refine ‚ü®g, ?_, Pg‚ü©
    convert (hŒ∑ _ _ (hf.aestronglyMeasurable.sub f'.aestronglyMeasurable)
          (f'.aestronglyMeasurable.sub (h2P g Pg)) hf'.le hg).le using 2
    simp only [sub_add_sub_cancel]
  apply SimpleFunc.induction
  ¬∑ intro c s hs Œµ Œµpos Hs
    rcases eq_or_ne c 0 with (rfl | hc)
    ¬∑ rcases h0P (0 : E) MeasurableSet.empty (by simp only [measure_empty, zero_lt_top])
          Œµpos with ‚ü®g, hg, Pg‚ü©
      rw [‚Üê snorm_neg, neg_sub] at hg
      refine ‚ü®g, ?_, Pg‚ü©
      convert hg
      ext x
      simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_zero,
        piecewise_eq_indicator, indicator_zero', Pi.zero_apply, indicator_zero]
    ¬∑ have : Œº s < ‚àû := SimpleFunc.measure_lt_top_of_mem‚Ñíp_indicator hp_pos hp_ne_top hc hs Hs
      rcases h0P c hs this Œµpos with ‚ü®g, hg, Pg‚ü©
      rw [‚Üê snorm_neg, neg_sub] at hg
      exact ‚ü®g, hg, Pg‚ü©
  ¬∑ intro f f' hff' hf hf' Œ¥ Œ¥pos int_ff'
    obtain ‚ü®Œ∑, Œ∑pos, hŒ∑‚ü© := exists_Lp_half E Œº p Œ¥pos
    rw [SimpleFunc.coe_add,
      mem‚Ñíp_add_of_disjoint hff' f.stronglyMeasurable f'.stronglyMeasurable] at int_ff'
    rcases hf Œ∑ Œ∑pos.ne' int_ff'.1 with ‚ü®g, hg, Pg‚ü©
    rcases hf' Œ∑ Œ∑pos.ne' int_ff'.2 with ‚ü®g', hg', Pg'‚ü©
    refine ‚ü®g + g', ?_, h1P g g' Pg Pg'‚ü©
    convert (hŒ∑ _ _ (f.aestronglyMeasurable.sub (h2P g Pg))
          (f'.aestronglyMeasurable.sub (h2P g' Pg')) hg hg').le using 2
    rw [SimpleFunc.coe_add]
    abel"
Mathlib/NumberTheory/LegendreSymbol/AddCharacter.lean,AddChar.exists_divisor_of_not_isPrimitive,exists_divisor_of_not_isPrimitive,4b2dad8c447ddac1b7fc18db59a31fd177c42fe1,":= by
  simp_rw [IsPrimitive, not_forall, not_ne_iff] at he
  rcases he with ‚ü®b, hb_ne, hb‚ü©
  obtain ‚ü®d, hd, u, hu, rfl‚ü© := b.eq_unit_mul_divisor
  refine ‚ü®d, hd, lt_of_le_of_ne (Nat.le_of_dvd N.pos hd) ?_, ?_‚ü©
  ¬∑ exact fun h ‚Ü¶ by simp only [h, ZMod.natCast_self, mul_zero, ne_eq, not_true_eq_false] at hb_ne
  ¬∑ rw [‚Üê mulShift_unit_eq_one_iff _ hu, ‚Üê hb, mul_comm]
    ext1 y
    rw [mulShift_apply, mulShift_apply, mulShift_apply, mul_assoc]","error:  invalid field 'pos', the environment does not contain 'Nat.pos'
  N
has type
  ‚Ñï","lemma exists_divisor_of_not_isPrimitive (he : ¬¨e.IsPrimitive) :
    ‚àÉ d : ‚Ñï, d ‚à£ N ‚àß d < N ‚àß e.mulShift d = 1 ",":= by
  simp_rw [IsPrimitive, not_forall, not_ne_iff] at he
  rcases he with ‚ü®b, hb_ne, hb‚ü©
  obtain ‚ü®d, hd, u, hu, rfl‚ü© := b.eq_unit_mul_divisor
  refine ‚ü®d, hd, lt_of_le_of_ne (Nat.le_of_dvd (NeZero.pos _) hd) ?_, ?_‚ü©
  ¬∑ exact fun h ‚Ü¶ by simp only [h, ZMod.natCast_self, mul_zero, ne_eq, not_true_eq_false] at hb_ne
  ¬∑ rw [‚Üê mulShift_unit_eq_one_iff _ hu, ‚Üê hb, mul_comm]
    ext1 y
    rw [mulShift_apply, mulShift_apply, mulShift_apply, mul_assoc]"
Mathlib/Combinatorics/SimpleGraph/Coloring.lean,SimpleGraph.chromaticNumber_pos,chromaticNumber_pos,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  rw [hc.chromaticNumber_eq_sInf, Nat.cast_pos]
  apply le_csInf (colorable_set_nonempty_of_colorable hc)
  intro m hm
  by_contra h'
  simp only [not_le] at h'
  obtain ‚ü®i, hi‚ü© := hm.some (Classical.arbitrary V)
  have h‚ÇÅ : i < 0 : = lt_of_lt_of_le hi (Nat.le_of_lt_succ h')
  exact Nat.not_lt_zero _ h‚ÇÅ","error:  unexpected token ':'; expected '|'
error:  unsolved goals
case mk
V : Type u
G : SimpleGraph V
n‚úù : ‚Ñï
Œ± : Type u_1
Œ≤ : Type u_2
C : G.Coloring Œ±
inst‚úù : Nonempty V
n : ‚Ñï
hc : G.Colorable n
m : ‚Ñï
hm : m ‚àà {n | G.Colorable n}
h' : m < Nat.succ 0
i : ‚Ñï
hi : i < m
h‚ÇÅ : i < 0
‚ä¢ False",theorem chromaticNumber_pos [Nonempty V] {n : ‚Ñï} (hc : G.Colorable n) : 0 < G.chromaticNumber ,":= by
  rw [hc.chromaticNumber_eq_sInf, Nat.cast_pos]
  apply le_csInf (colorable_set_nonempty_of_colorable hc)
  intro m hm
  by_contra h'
  simp only [not_le] at h'
  obtain ‚ü®i, hi‚ü© := hm.some (Classical.arbitrary V)
  have h‚ÇÅ: i < 0 := lt_of_lt_of_le hi (Nat.le_of_lt_succ h')
  exact Nat.not_lt_zero _ h‚ÇÅ"
Mathlib/Topology/Compactness/Paracompact.lean,refinement_of_locallyCompact_sigmaCompact_of_nhds_basis,refinement_of_locallyCompact_sigmaCompact_of_nhds_basis,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  classical
    set K' : CompactExhaustion X := CompactExhaustion.choice X
    set K : CompactExhaustion X := K'.shiftr.shiftr
    set Kdiff := fun n ‚Ü¶ K (n + 1) \ interior (K n)
    have hKcov : ‚àÄ x, x ‚àà Kdiff (K'.find x + 1) := fun x ‚Ü¶ by
      simpa only [K'.find_shiftr] using
        diff_subset_diff_right interior_subset (K'.shiftr.mem_diff_shiftr_find x)
    have Kdiffc : ‚àÄ n, IsCompact (Kdiff n ‚à© s) :=
      fun n ‚Ü¶ ((K.isCompact _).diff isOpen_interior).inter_right hs
    have : ‚àÄ (n) (x : ‚Üë(Kdiff (n + 1) ‚à© s)), (K n)·∂ú ‚àà ùìù (x : X) :=
      fun n x ‚Ü¶ (K.isClosed n).compl_mem_nhds fun hx' ‚Ü¶ x.2.1.2 <| K.subset_interior_succ _ hx'
    choose! r hrp hr using fun n (x : ‚Üë(Kdiff (n + 1) ‚à© s)) ‚Ü¶ (hB x x.2.2).mem_iff.1 (this n x)
    have hxr : ‚àÄ (n x) (hx : x ‚àà Kdiff (n + 1) ‚à© s), B x (r n ‚ü®x, hx‚ü©) ‚àà ùìù x := fun n x hx ‚Ü¶
      (hB x hx.2).mem_of_mem (hrp _ ‚ü®x, hx‚ü©)
    choose T hT using fun n ‚Ü¶ (Kdiffc (n + 1)).elim_nhds_subcover' _ (hxr n)
    set T' : ‚àÄ n, Set ‚Üë(Kdiff (n + 1) ‚à© s) := fun n ‚Ü¶ T n
    refine ‚ü®Œ£n, T' n, fun a ‚Ü¶ a.2, fun a ‚Ü¶ r a.1 a.2, ?_,? _?, _‚ü©
    ¬∑ rintro ‚ü®n, x, hx‚ü©
      exact ‚ü®x.2.2, hrp _ _‚ü©
    ¬∑ refine fun x hx ‚Ü¶ mem_iUnion.2 ?_
      rcases mem_iUnion‚ÇÇ.1 (hT _ ‚ü®hKcov x, hx‚ü©) with ‚ü®‚ü®c, hc‚ü©, hcT, hcx‚ü©
      exact ‚ü®‚ü®_, ‚ü®c, hc‚ü©, hcT‚ü©, hcx‚ü©
    ¬∑ intro x
      refine
        ‚ü®interior (K (K'.find x + 3)),
          IsOpen.mem_nhds isOpen_interior (K.subset_interior_succ _ (hKcov x).1), ?_‚ü©
      have : (‚ãÉ k ‚â§ K'.find x + 2, range (Sigma.mk k) : Set (Œ£n, T' n)).Finite :=
        (finite_le_nat _).biUnion fun k _ ‚Ü¶ finite_range _
      apply this.subset
      rintro ‚ü®k, c, hc‚ü©
      simp only [mem_iUnion, mem_setOf_eq, mem_image, Subtype.coe_mk]
      rintro ‚ü®x, hxB : x ‚àà B c (r k c), hxK‚ü©
      refine ‚ü®k, ?_, ‚ü®c, hc‚ü©, rfl‚ü©
      have := (mem_compl_iff _ _).1 (hr k c hxB)
      contrapose! this with hnk
      exact K.subset hnk (interior_subset hxK)","error:  don't know how to synthesize placeholder for argument 'right'
context:
Œπ‚úù : Type u
X : Type v
Y : Type w
inst‚úù‚Å¥ : TopologicalSpace X
inst‚úù¬≥ : TopologicalSpace Y
inst‚úù¬≤ : WeaklyLocallyCompactSpace X
inst‚úù¬π : SigmaCompactSpace X
inst‚úù : T2Space X
Œπ : X ‚Üí Type u
p : (x : X) ‚Üí Œπ x ‚Üí Prop
B : (x : X) ‚Üí Œπ x ‚Üí Set X
s : Set X
hs : IsClosed s
hB : ‚àÄ x ‚àà s, (ùìù x).HasBasis (p x) (B x)
K' : CompactExhaustion X := CompactExhaustion.choice X
K : CompactExhaustion X := K'.shiftr.shiftr
Kdiff : ‚Ñï ‚Üí Set X := fun n ‚Ü¶ K (n + 1) \ interior (K n)
hKcov : ‚àÄ (x : X), x ‚àà Kdiff (K'.find x + 1)
Kdiffc : ‚àÄ (n : ‚Ñï), IsCompact (Kdiff n ‚à© s)
this : ‚àÄ (n : ‚Ñï) (x : ‚Üë(Kdiff (n + 1) ‚à© s)), (K n)·∂ú ‚àà ùìù ‚Üëx
r : (n : ‚Ñï) ‚Üí (x : ‚Üë(Kdiff (n + 1) ‚à© s)) ‚Üí Œπ ‚Üëx
hrp : ‚àÄ (n : ‚Ñï) (x : ‚Üë(Kdiff (n + 1) ‚à© s)), p (‚Üëx) (r n x)
hr : ‚àÄ (n : ‚Ñï) (x : ‚Üë(Kdiff (n + 1) ‚à© s)), B (‚Üëx) (r n x) ‚äÜ (K n)·∂ú
hxr : ‚àÄ (n : ‚Ñï) (x : X) (hx : x ‚àà Kdiff (n + 1) ‚à© s), B x (r n ‚ü®x, hx‚ü©) ‚àà ùìù x
T : (n : ‚Ñï) ‚Üí Finset ‚Üë(Kdiff (n + 1) ‚à© s)
hT : ‚àÄ (n : ‚Ñï), Kdiff (n + 1) ‚à© s ‚äÜ ‚ãÉ x ‚àà T n, B (‚Üëx) (r n ‚ü®‚Üëx, ‚ãØ‚ü©)
T' : (n : ‚Ñï) ‚Üí Set ‚Üë(Kdiff (n + 1) ‚à© s) := fun n ‚Ü¶ ‚Üë(T n)
‚ä¢ LocallyFinite fun a ‚Ü¶ B ((fun a ‚Ü¶ ‚Üë‚Üëa.snd) a) ((fun a ‚Ü¶ r a.fst ‚Üëa.snd) a)
error:  unsolved goals
Œπ‚úù : Type u
X : Type v
Y : Type w
inst‚úù‚Å¥ : TopologicalSpace X
inst‚úù¬≥ : TopologicalSpace Y
inst‚úù¬≤ : WeaklyLocallyCompactSpace X
inst‚úù¬π : SigmaCompactSpace X
inst‚úù : T2Space X
Œπ : X ‚Üí Type u
p : (x : X) ‚Üí Œπ x ‚Üí Prop
B : (x : X) ‚Üí Œπ x ‚Üí Set X
s : Set X
hs : IsClosed s
hB : ‚àÄ x ‚àà s, (ùìù x).HasBasis (p x) (B x)
K' : CompactExhaustion X := CompactExhaustion.choice X
K : CompactExhaustion X := K'.shiftr.shiftr
Kdiff : ‚Ñï ‚Üí Set X := fun n ‚Ü¶ K (n + 1) \ interior (K n)
hKcov : ‚àÄ (x : X), x ‚àà Kdiff (K'.find x + 1)
Kdiffc : ‚àÄ (n : ‚Ñï), IsCompact (Kdiff n ‚à© s)
this : ‚àÄ (n : ‚Ñï) (x : ‚Üë(Kdiff (n + 1) ‚à© s)), (K n)·∂ú ‚àà ùìù ‚Üëx
r : (n : ‚Ñï) ‚Üí (x : ‚Üë(Kdiff (n + 1) ‚à© s)) ‚Üí Œπ ‚Üëx
hrp : ‚àÄ (n : ‚Ñï) (x : ‚Üë(Kdiff (n + 1) ‚à© s)), p (‚Üëx) (r n x)
hr : ‚àÄ (n : ‚Ñï) (x : ‚Üë(Kdiff (n + 1) ‚à© s)), B (‚Üëx) (r n x) ‚äÜ (K n)·∂ú
hxr : ‚àÄ (n : ‚Ñï) (x : X) (hx : x ‚àà Kdiff (n + 1) ‚à© s), B x (r n ‚ü®x, hx‚ü©) ‚àà ùìù x
T : (n : ‚Ñï) ‚Üí Finset ‚Üë(Kdiff (n + 1) ‚à© s)
hT : ‚àÄ (n : ‚Ñï), Kdiff (n + 1) ‚à© s ‚äÜ ‚ãÉ x ‚àà T n, B (‚Üëx) (r n ‚ü®‚Üëx, ‚ãØ‚ü©)
T' : (n : ‚Ñï) ‚Üí Set ‚Üë(Kdiff (n + 1) ‚à© s) := fun n ‚Ü¶ ‚Üë(T n)
‚ä¢ ‚àÉ Œ± c r, (‚àÄ (a : Œ±), c a ‚àà s ‚àß p (c a) (r a)) ‚àß s ‚äÜ ‚ãÉ a, B (c a) (r a) ‚àß LocallyFinite fun a ‚Ü¶ B (c a) (r a)","theorem refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set [WeaklyLocallyCompactSpace X]
    [SigmaCompactSpace X] [T2Space X] {Œπ : X ‚Üí Type u} {p : ‚àÄ x, Œπ x ‚Üí Prop} {B : ‚àÄ x, Œπ x ‚Üí Set X}
    {s : Set X} (hs : IsClosed s) (hB : ‚àÄ x ‚àà s, (ùìù x).HasBasis (p x) (B x)) :
    ‚àÉ (Œ± : Type v) (c : Œ± ‚Üí X) (r : ‚àÄ a, Œπ (c a)),
      (‚àÄ a, c a ‚àà s ‚àß p (c a) (r a)) ‚àß
        (s ‚äÜ ‚ãÉ a, B (c a) (r a)) ‚àß LocallyFinite fun a ‚Ü¶ B (c a) (r a) ",":= by
  classical
    set K' : CompactExhaustion X := CompactExhaustion.choice X
    set K : CompactExhaustion X := K'.shiftr.shiftr
    set Kdiff := fun n ‚Ü¶ K (n + 1) \ interior (K n)
    have hKcov : ‚àÄ x, x ‚àà Kdiff (K'.find x + 1) := fun x ‚Ü¶ by
      simpa only [K'.find_shiftr] using
        diff_subset_diff_right interior_subset (K'.shiftr.mem_diff_shiftr_find x)
    have Kdiffc : ‚àÄ n, IsCompact (Kdiff n ‚à© s) :=
      fun n ‚Ü¶ ((K.isCompact _).diff isOpen_interior).inter_right hs
    have : ‚àÄ (n) (x : ‚Üë(Kdiff (n + 1) ‚à© s)), (K n)·∂ú ‚àà ùìù (x : X) :=
      fun n x ‚Ü¶ (K.isClosed n).compl_mem_nhds fun hx' ‚Ü¶ x.2.1.2 <| K.subset_interior_succ _ hx'
    choose! r hrp hr using fun n (x : ‚Üë(Kdiff (n + 1) ‚à© s)) ‚Ü¶ (hB x x.2.2).mem_iff.1 (this n x)
    have hxr : ‚àÄ (n x) (hx : x ‚àà Kdiff (n + 1) ‚à© s), B x (r n ‚ü®x, hx‚ü©) ‚àà ùìù x := fun n x hx ‚Ü¶
      (hB x hx.2).mem_of_mem (hrp _ ‚ü®x, hx‚ü©)
    choose T hT using fun n ‚Ü¶ (Kdiffc (n + 1)).elim_nhds_subcover' _ (hxr n)
    set T' : ‚àÄ n, Set ‚Üë(Kdiff (n + 1) ‚à© s) := fun n ‚Ü¶ T n
    refine ‚ü®Œ£n, T' n, fun a ‚Ü¶ a.2, fun a ‚Ü¶ r a.1 a.2, ?_, ?_, ?_‚ü©
    ¬∑ rintro ‚ü®n, x, hx‚ü©
      exact ‚ü®x.2.2, hrp _ _‚ü©
    ¬∑ refine fun x hx ‚Ü¶ mem_iUnion.2 ?_
      rcases mem_iUnion‚ÇÇ.1 (hT _ ‚ü®hKcov x, hx‚ü©) with ‚ü®‚ü®c, hc‚ü©, hcT, hcx‚ü©
      exact ‚ü®‚ü®_, ‚ü®c, hc‚ü©, hcT‚ü©, hcx‚ü©
    ¬∑ intro x
      refine
        ‚ü®interior (K (K'.find x + 3)),
          IsOpen.mem_nhds isOpen_interior (K.subset_interior_succ _ (hKcov x).1), ?_‚ü©
      have : (‚ãÉ k ‚â§ K'.find x + 2, range (Sigma.mk k) : Set (Œ£n, T' n)).Finite :=
        (finite_le_nat _).biUnion fun k _ ‚Ü¶ finite_range _
      apply this.subset
      rintro ‚ü®k, c, hc‚ü©
      simp only [mem_iUnion, mem_setOf_eq, mem_image, Subtype.coe_mk]
      rintro ‚ü®x, hxB : x ‚àà B c (r k c), hxK‚ü©
      refine ‚ü®k, ?_, ‚ü®c, hc‚ü©, rfl‚ü©
      have := (mem_compl_iff _ _).1 (hr k c hxB)
      contrapose! this with hnk
      exact K.subset hnk (interior_subset hxK)"
Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean,CategoryTheory.Limits.colimitLimitToLimitColimit_surjective,colimitLimitToLimitColimit_surjective,31d572995d4db174b6fbfa3e3dee4f9027839468,":= by
  classical
    intro x
    have z := fun j => jointly_surjective'.{v, v} (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply'.{v, v}, t, FunctorToTypes.map_comp_apply, Colimit.w_apply'.{v, v}, e,
        ‚Üê Limit.w_apply' f, ‚Üê e]
      simp
    simp_rw [colimit_eq_iff.{v, v}] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (by
            rw [Finset.mem_biUnion]
            refine' ‚ü®j, Finset.mem_univ j, _‚ü©
            rw [Finset.mem_biUnion]
            refine' ‚ü®j', Finset.mem_univ j', _‚ü©
            rw [Finset.mem_image]
            refine' ‚ü®f, Finset.mem_univ _, _‚ü©
            rfl))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      exact k'O
      swap
      ¬∑ rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÅ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÇ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®f, Finset.mem_univ _, _‚ü©
        simp only [true_or_iff, eq_self_iff_true, and_self_iff, Finset.mem_insert, heq_iff_eq]
      ¬∑ rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÉ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÑ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®f', Finset.mem_univ _, _‚ü©
        simp only [eq_self_iff_true, or_true_iff, and_self_iff, Finset.mem_insert,
          Finset.mem_singleton, heq_iff_eq]
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk.{v, v}
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) :=
            by rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) :=
            by rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) :=
            by rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext'
      intro j
      simp only [id.def, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff.{v, v}, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine' ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), _‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","error:  application type mismatch
  jointly_surjective' (limit.œÄ (curry.obj F ‚ãô colim) j x)
argument
  limit.œÄ (curry.obj F ‚ãô colim) j x
has type
  (curry.obj F ‚ãô colim).obj j : Type v
but is expected to have type
  colimit ?m.27488 : Type v
error:  unsolved goals
J : Type u‚ÇÅ
K : Type u‚ÇÇ
inst‚úù‚Å¥ : SmallCategory J
inst‚úù¬≥ : Category.{v‚ÇÇ, u‚ÇÇ} K
inst‚úù¬≤ : Small.{v, u‚ÇÇ} K
inst‚úù¬π : FinCategory J
F : J √ó K ‚•§ Type v
inst‚úù : IsFiltered K
x : limit (curry.obj F ‚ãô colim)
‚ä¢ ‚àÉ a, colimitLimitToLimitColimit F a = x","theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) ",":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ‚Üê Limit.w_apply.{u‚ÇÅ, v, u‚ÇÅ} f, ‚Üê e]
      simp only [Functor.comp_map, Types.Colimit.Œπ_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact k'O
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) := by
            rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) := by
            rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext
      intro j
      simp only [id, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]"
Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean,CategoryTheory.Pretriangulated.exists_iso_of_arrow_iso,exists_iso_of_arrow_iso,afe025caf56711b57f2f34e9ae25ec16a609156d,":= by
  obtain ‚ü®œÜ, ‚ü®hœÜ‚ÇÅ, hœÜ‚ÇÇ‚ü©‚ü© :=
    complete_distinguished_triangle_morphism' T‚ÇÅ T‚ÇÇ hT‚ÇÅ hT‚ÇÇ e.hom.left e.hom.right e.hom.w.symm
  have : IsIso œÜ.hom‚ÇÅ := by rw [hœÜ‚ÇÅ] ; infer_instance
  have : IsIso œÜ.hom‚ÇÇ := by rw [hœÜ‚ÇÇ] ; infer_instance
  have : IsIso œÜ.hom‚ÇÉ := isIso‚ÇÉ_of_isIso‚ÇÅ‚ÇÇ œÜ hT‚ÇÅ hT‚ÇÇ inferInstance inferInstance
  exact ‚ü®asIso œÜ, hœÜ‚ÇÅ, hœÜ‚ÇÇ‚ü©","error:  unknown identifier 'complete_distinguished_triangle_morphism''
error:  rcases tactic failed: x‚úù : ?m.221813 is not an inductive datatype","lemma exists_iso_of_arrow_iso (T‚ÇÅ T‚ÇÇ : Triangle C) (hT‚ÇÅ : T‚ÇÅ ‚àà distTriang C)
    (hT‚ÇÇ : T‚ÇÇ ‚àà distTriang C) (e : Arrow.mk T‚ÇÅ.mor‚ÇÅ ‚âÖ Arrow.mk T‚ÇÇ.mor‚ÇÅ) :
    ‚àÉ (e' : T‚ÇÅ ‚âÖ T‚ÇÇ), e'.hom.hom‚ÇÅ = e.hom.left ‚àß e'.hom.hom‚ÇÇ = e.hom.right ",":= by
  let œÜ := completeDistinguishedTriangleMorphism T‚ÇÅ T‚ÇÇ hT‚ÇÅ hT‚ÇÇ e.hom.left e.hom.right e.hom.w.symm
  have : IsIso œÜ.hom‚ÇÅ := by dsimp [œÜ]; infer_instance
  have : IsIso œÜ.hom‚ÇÇ := by dsimp [œÜ]; infer_instance
  have : IsIso œÜ.hom‚ÇÉ := isIso‚ÇÉ_of_isIso‚ÇÅ‚ÇÇ œÜ hT‚ÇÅ hT‚ÇÇ inferInstance inferInstance
  have : IsIso œÜ := by
    apply Triangle.isIso_of_isIsos
    all_goals infer_instance
  exact ‚ü®asIso œÜ, by simp [œÜ], by simp [œÜ]‚ü©"
Mathlib/Analysis/NormedSpace/lpSpace.lean,lp.tendsto_lp_of_tendsto_pi,tendsto_lp_of_tendsto_pi,b50a8b2e9760b6f582390d3948a953c553480df1,":= by
  rw [Metric.nhds_basis_closedBall.tendsto_right_iff]
  intro Œµ hŒµ
  have hŒµ' : { p : lp E p √ó lp E p | ‚Äñp.1 - p.2‚Äñ < Œµ } ‚àà uniformity (lp E p) :=
    NormedAddCommGroup.uniformity_basis_dist.mem_of_mem hŒµ
  refine' (hF.eventually_eventually hŒµ').mono _
  rintro n (hn : ‚àÄ·∂† l in atTop, ‚Äñ(fun f => F n - f) (F l)‚Äñ < Œµ)
  refine' norm_le_of_tendsto (hn.mono fun k hk => hk.le) _
  rw [tendsto_pi_nhds]
  intro a
  exact (hf.apply a).const_sub (F n a)","warning:  @lp does not have a doc string
warning:  @lp does not have a doc string
error:  application type mismatch
  Tendsto.apply hf
argument
  hf
has type
  Tendsto (id fun i ‚Ü¶ ‚Üë(F i)) atTop (ùìù ‚Üëf) : Prop
but is expected to have type
  Tendsto (id fun i ‚Ü¶ ‚Üë(F i)) atTop (pi ?m.777254) : Prop","theorem tendsto_lp_of_tendsto_pi {F : ‚Ñï ‚Üí lp E p} (hF : CauchySeq F) {f : lp E p}
    (hf : Tendsto (id fun i => F i : ‚Ñï ‚Üí ‚àÄ a, E a) atTop (ùìù f)) : Tendsto F atTop (ùìù f) ",":= by
  rw [Metric.nhds_basis_closedBall.tendsto_right_iff]
  intro Œµ hŒµ
  have hŒµ' : { p : lp E p √ó lp E p | ‚Äñp.1 - p.2‚Äñ < Œµ } ‚àà uniformity (lp E p) :=
    NormedAddCommGroup.uniformity_basis_dist.mem_of_mem hŒµ
  refine (hF.eventually_eventually hŒµ').mono ?_
  rintro n (hn : ‚àÄ·∂† l in atTop, ‚Äñ(fun f => F n - f) (F l)‚Äñ < Œµ)
  refine norm_le_of_tendsto (hn.mono fun k hk => hk.le) ?_
  rw [tendsto_pi_nhds]
  intro a
  exact (hf.apply_nhds a).const_sub (F n a)"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/GroupTheory/CommutingProbability.lean,DihedralGroup.reciprocalFactors_odd,reciprocalFactors_odd,ad88a031b67d9f51d39379f0e5f82a31c1929202,":= by
  have h0 : n ‚â† 0
  ¬∑ rintro rfl
    norm_num at h2
  rw [reciprocalFactors, dif_neg h0, dif_neg h1, if_neg (Nat.odd_iff_not_even.mp h2)]","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
M : Type u_1
inst‚úù¬≥ : Mul M
inst‚úù¬≤ : Finite M
G : Type u_2
inst‚úù¬π : Group G
inst‚úù : Finite G
H : Subgroup G
n : ‚Ñï
h1 : n ‚â† 1
h2 : Odd n
h0 : n ‚â† 0
‚ä¢ reciprocalFactors n = n % 4 * n :: reciprocalFactors (n / 4 + 1)","lemma reciprocalFactors_odd {n : ‚Ñï} (h1 : n ‚â† 1) (h2 : Odd n) :
    reciprocalFactors n = n % 4 * n :: reciprocalFactors (n / 4 + 1) ",":= by
  have h0 : n ‚â† 0 := by
    rintro rfl
    norm_num at h2
  rw [reciprocalFactors, dif_neg h0, dif_neg h1, if_neg (Nat.odd_iff_not_even.mp h2)]"
Mathlib/Analysis/Normed/Group/ControlledClosure.lean,controlled_closure_of_complete,controlled_closure_of_complete,c84d9003027b182d6e34911289aa4dc7700ea050,":= by
  rintro (h : H) (h_in : h ‚àà K.topologicalClosure)
  by_cases hyp_h : h = 0
  ¬∑ rw [hyp_h]
    use 0
    simp
  set b : ‚Ñï ‚Üí ‚Ñù := fun i => (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
  have b_pos : ‚àÄ i, 0 < b i := by
    intro i
    unfold_let b
    field_simp [hC]
    exact
      div_pos (mul_pos hŒµ (norm_pos_iff.mpr hyp_h)) (mul_pos (by norm_num : (0 : ‚Ñù) < 2 ^ i * 2) hC)
  obtain
    ‚ü®v : ‚Ñï ‚Üí H, lim_v : Tendsto (fun n : ‚Ñï => ‚àë k in range (n + 1), v k) atTop (ùìù h), v_in :
      ‚àÄ n, v n ‚àà K, hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0, hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n‚ü© :=
    controlled_sum_of_mem_closure h_in b_pos
  have : ‚àÄ n, ‚àÉ m' : G, f m' = v n ‚àß ‚Äñm'‚Äñ ‚â§ C * ‚Äñv n‚Äñ := fun n : ‚Ñï => hyp (v n) (v_in n)
  choose u hu hnorm_u using this
  set s : ‚Ñï ‚Üí G := fun n => ‚àë k in range (n + 1), u k
  have : CauchySeq s := by
    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one
    rintro n (hn : n ‚â• 1)
    calc
      ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ := hnorm_u n
      _ ‚â§ C * b n := by gcongr; exact (hv _ <| Nat.succ_le_iff.mp hn).le
      _ = (1 / 2) ^ n * (Œµ * ‚Äñh‚Äñ / 2) := by simp [mul_div_cancel' _ hC.ne.symm]
      _ = Œµ * ‚Äñh‚Äñ / 2 * (1 / 2) ^ n := mul_comm _ _
  obtain ‚ü®g : G, hg‚ü© := cauchySeq_tendsto_of_complete this
  refine' ‚ü®g, _, _‚ü©
  ¬∑ 
    have : f ‚àò s = fun n => ‚àë k in range (n + 1), v k := by
      ext n
      simp [map_sum, hu]
    rw [‚Üê this] at lim_v
    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v
  ¬∑ 
    suffices : ‚àÄ n, ‚Äñs n‚Äñ ‚â§ (C + Œµ) * ‚Äñh‚Äñ
    exact le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this
    intro n
    have hnorm‚ÇÄ : ‚Äñu 0‚Äñ ‚â§ C * b 0 + C * ‚Äñh‚Äñ := by
      have :=
        calc
          ‚Äñv 0‚Äñ ‚â§ ‚Äñh‚Äñ + ‚Äñv 0 - h‚Äñ := norm_le_insert' _ _
          _ ‚â§ ‚Äñh‚Äñ + b 0 := by gcongr
      calc
        ‚Äñu 0‚Äñ ‚â§ C * ‚Äñv 0‚Äñ := hnorm_u 0
        _ ‚â§ C * (‚Äñh‚Äñ + b 0) := by gcongr
        _ = C * b 0 + C * ‚Äñh‚Äñ := by rw [add_comm, mul_add]
    have : (‚àë k in range (n + 1), C * b k) ‚â§ Œµ * ‚Äñh‚Äñ :=
      calc
        (‚àë k in range (n + 1), C * b k) = (‚àë k in range (n + 1), (1 / 2 : ‚Ñù) ^ k) * (Œµ * ‚Äñh‚Äñ / 2) :=
          by simp only [mul_div_cancel' _ hC.ne.symm, ‚Üê sum_mul]
        _ ‚â§ 2 * (Œµ * ‚Äñh‚Äñ / 2) := by gcongr; apply sum_geometric_two_le
        _ = Œµ * ‚Äñh‚Äñ := mul_div_cancel' _ two_ne_zero
    calc
      ‚Äñs n‚Äñ ‚â§ ‚àë k in range (n + 1), ‚Äñu k‚Äñ := norm_sum_le _ _
      _ = (‚àë k in range n, ‚Äñu (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := (sum_range_succ' _ _)
      _ ‚â§ (‚àë k in range n, C * ‚Äñv (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := by gcongr; apply hnorm_u
      _ ‚â§ (‚àë k in range n, C * b (k + 1)) + (C * b 0 + C * ‚Äñh‚Äñ) := by
        gcongr with k; exact (hv _ k.succ_pos).le
      _ = (‚àë k in range (n + 1), C * b k) + C * ‚Äñh‚Äñ := by rw [‚Üê add_assoc, sum_range_succ']
      _ ‚â§ (C + Œµ) * ‚Äñh‚Äñ := by
        rw [add_comm, add_mul]
        apply add_le_add_left this","error:  unexpected token ':'; expected term
error:  unsolved goals
case h
G : Type u_1
inst‚úù¬≤ : NormedAddCommGroup G
inst‚úù¬π : CompleteSpace G
H : Type u_2
inst‚úù : NormedAddCommGroup H
f : NormedAddGroupHom G H
K : AddSubgroup H
C Œµ : ‚Ñù
hC : 0 < C
hŒµ : 0 < Œµ
hyp : f.SurjectiveOnWith K C
h : H
h_in : h ‚àà K.topologicalClosure
hyp_h : ¬¨h = 0
b : ‚Ñï ‚Üí ‚Ñù := fun i ‚Ü¶ (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
b_pos : ‚àÄ (i : ‚Ñï), 0 < b i
v : ‚Ñï ‚Üí H
lim_v : Tendsto (fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h)
v_in : ‚àÄ (n : ‚Ñï), v n ‚àà K
hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0
hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n
u : ‚Ñï ‚Üí G
hu : ‚àÄ (n : ‚Ñï), f (u n) = v n
hnorm_u : ‚àÄ (n : ‚Ñï), ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ
s : ‚Ñï ‚Üí G := fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), u k
this : CauchySeq s
g : G
hg : Tendsto s atTop (ùìù g)
n : ‚Ñï
‚ä¢ f (s n) = ‚àë k ‚àà range (n + 1), v k","theorem controlled_closure_of_complete {f : NormedAddGroupHom G H} {K : AddSubgroup H} {C Œµ : ‚Ñù}
    (hC : 0 < C) (hŒµ : 0 < Œµ) (hyp : f.SurjectiveOnWith K C) :
    f.SurjectiveOnWith K.topologicalClosure (C + Œµ) ",":= by
  rintro (h : H) (h_in : h ‚àà K.topologicalClosure)
  by_cases hyp_h : h = 0
  ¬∑ rw [hyp_h]
    use 0
    simp
  set b : ‚Ñï ‚Üí ‚Ñù := fun i => (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
  have b_pos (i) : 0 < b i := by field_simp [b, hC, hyp_h]
  obtain
    ‚ü®v : ‚Ñï ‚Üí H, lim_v : Tendsto (fun n : ‚Ñï => ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h), v_in :
      ‚àÄ n, v n ‚àà K, hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0, hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n‚ü© :=
    controlled_sum_of_mem_closure h_in b_pos
  have : ‚àÄ n, ‚àÉ m' : G, f m' = v n ‚àß ‚Äñm'‚Äñ ‚â§ C * ‚Äñv n‚Äñ := fun n : ‚Ñï => hyp (v n) (v_in n)
  choose u hu hnorm_u using this
  set s : ‚Ñï ‚Üí G := fun n => ‚àë k ‚àà range (n + 1), u k
  have : CauchySeq s := by
    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one
    ¬∑ rintro n (hn : n ‚â• 1)
      calc
        ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ := hnorm_u n
        _ ‚â§ C * b n := by gcongr; exact (hv _ <| Nat.succ_le_iff.mp hn).le
        _ = (1 / 2) ^ n * (Œµ * ‚Äñh‚Äñ / 2) := by simp [mul_div_cancel‚ÇÄ _ hC.ne.symm]
        _ = Œµ * ‚Äñh‚Äñ / 2 * (1 / 2) ^ n := mul_comm _ _
  obtain ‚ü®g : G, hg‚ü© := cauchySeq_tendsto_of_complete this
  refine ‚ü®g, ?_, ?_‚ü©
  ¬∑ 
    have : f ‚àò s = fun n => ‚àë k ‚àà range (n + 1), v k := by
      ext n
      simp [s, map_sum, hu]
    rw [‚Üê this] at lim_v
    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v
  ¬∑ 
    suffices ‚àÄ n, ‚Äñs n‚Äñ ‚â§ (C + Œµ) * ‚Äñh‚Äñ from
      le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this
    intro n
    have hnorm‚ÇÄ : ‚Äñu 0‚Äñ ‚â§ C * b 0 + C * ‚Äñh‚Äñ := by
      have :=
        calc
          ‚Äñv 0‚Äñ ‚â§ ‚Äñh‚Äñ + ‚Äñv 0 - h‚Äñ := norm_le_insert' _ _
          _ ‚â§ ‚Äñh‚Äñ + b 0 := by gcongr
      calc
        ‚Äñu 0‚Äñ ‚â§ C * ‚Äñv 0‚Äñ := hnorm_u 0
        _ ‚â§ C * (‚Äñh‚Äñ + b 0) := by gcongr
        _ = C * b 0 + C * ‚Äñh‚Äñ := by rw [add_comm, mul_add]
    have : (‚àë k ‚àà range (n + 1), C * b k) ‚â§ Œµ * ‚Äñh‚Äñ :=
      calc (‚àë k ‚àà range (n + 1), C * b k)
        _ = (‚àë k ‚àà range (n + 1), (1 / 2 : ‚Ñù) ^ k) * (Œµ * ‚Äñh‚Äñ / 2) := by
          simp only [mul_div_cancel‚ÇÄ _ hC.ne.symm, ‚Üê sum_mul]
        _ ‚â§ 2 * (Œµ * ‚Äñh‚Äñ / 2) := by gcongr; apply sum_geometric_two_le
        _ = Œµ * ‚Äñh‚Äñ := mul_div_cancel‚ÇÄ _ two_ne_zero
    calc
      ‚Äñs n‚Äñ ‚â§ ‚àë k ‚àà range (n + 1), ‚Äñu k‚Äñ := norm_sum_le _ _
      _ = (‚àë k ‚àà range n, ‚Äñu (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := sum_range_succ' _ _
      _ ‚â§ (‚àë k ‚àà range n, C * ‚Äñv (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := by gcongr; apply hnorm_u
      _ ‚â§ (‚àë k ‚àà range n, C * b (k + 1)) + (C * b 0 + C * ‚Äñh‚Äñ) := by
        gcongr with k; exact (hv _ k.succ_pos).le
      _ = (‚àë k ‚àà range (n + 1), C * b k) + C * ‚Äñh‚Äñ := by rw [‚Üê add_assoc, sum_range_succ']
      _ ‚â§ (C + Œµ) * ‚Äñh‚Äñ := by
        rw [add_comm, add_mul]
        apply add_le_add_left this"
Mathlib/Topology/Compactness/Compact.lean,exists_subset_nhds_of_isCompact',exists_subset_nhds_of_isCompact',d5402808be60613076d9d2c9d0a7653fdbebeb3d,":= by
  obtain ‚ü®W, hsubW, W_op, hWU‚ü© := exists_open_set_nhds hU
  suffices : ‚àÉ i, V i ‚äÜ W
  ¬∑ exact this.imp fun i hi => hi.trans hWU
  by_contra! H
  replace H : ‚àÄ i, (V i ‚à© W·∂ú).Nonempty := fun i => Set.inter_compl_nonempty_iff.mpr (H i)
  have : (‚ãÇ i, V i ‚à© W·∂ú).Nonempty := by
    refine'
      IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed _ (fun i j => _) H
        (fun i => (hV_cpct i).inter_right W_op.isClosed_compl) fun i =>
        (hV_closed i).inter W_op.isClosed_compl
    rcases hV i j with ‚ü®k, hki, hkj‚ü©
    refine' ‚ü®k, ‚ü®fun x => _, fun x => _‚ü©‚ü© <;> simp only [and_imp, mem_inter_iff, mem_compl_iff] <;>
      tauto
  have : ¬¨‚ãÇ i : Œπ, V i ‚äÜ W := by simpa [‚Üê iInter_inter, inter_compl_nonempty_iff]
  contradiction",error:  unexpected token ':'; expected term,"theorem exists_subset_nhds_of_isCompact' [Nonempty Œπ] {V : Œπ ‚Üí Set X}
    (hV : Directed (¬∑ ‚äá ¬∑) V) (hV_cpct : ‚àÄ i, IsCompact (V i)) (hV_closed : ‚àÄ i, IsClosed (V i))
    {U : Set X} (hU : ‚àÄ x ‚àà ‚ãÇ i, V i, U ‚àà ùìù x) : ‚àÉ i, V i ‚äÜ U ",":= by
  obtain ‚ü®W, hsubW, W_op, hWU‚ü© := exists_open_set_nhds hU
  suffices ‚àÉ i, V i ‚äÜ W from this.imp fun i hi => hi.trans hWU
  by_contra! H
  replace H : ‚àÄ i, (V i ‚à© W·∂ú).Nonempty := fun i => Set.inter_compl_nonempty_iff.mpr (H i)
  have : (‚ãÇ i, V i ‚à© W·∂ú).Nonempty := by
    refine
      IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed _ (fun i j => ?_) H
        (fun i => (hV_cpct i).inter_right W_op.isClosed_compl) fun i =>
        (hV_closed i).inter W_op.isClosed_compl
    rcases hV i j with ‚ü®k, hki, hkj‚ü©
    refine ‚ü®k, ‚ü®fun x => ?_, fun x => ?_‚ü©‚ü© <;> simp only [and_imp, mem_inter_iff, mem_compl_iff] <;>
      tauto
  have : ¬¨‚ãÇ i : Œπ, V i ‚äÜ W := by simpa [‚Üê iInter_inter, inter_compl_nonempty_iff]
  contradiction"
Mathlib/Geometry/Manifold/Instances/Sphere.lean,mfderiv_coe_sphere_injective,mfderiv_coe_sphere_injective,b011c17e9c6a01496da5c0aebc4ba8e3bb736da2,":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ùïú := ‚Ñù) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices : Injective (fderiv ‚Ñù ((stereoInvFunAux (-v : E) ‚àò (‚Üë)) ‚àò U.symm) 0)
  ¬∑ convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddEquivClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have :
    HasFDerivAt (stereoInvFunAux (-v : E) ‚àò (Subtype.val : (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ ‚Üí E))
      (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective",error:  unexpected token ':'; expected term,"theorem mfderiv_coe_sphere_injective {n : ‚Ñï} [Fact (finrank ‚Ñù E = n + 1)] (v : sphere (0 : E) 1) :
    Injective (mfderiv (ùì° n) ùìò(‚Ñù, E) ((‚Üë) : sphere (0 : E) 1 ‚Üí E) v) ",":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ùïú := ‚Ñù) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices Injective (fderiv ‚Ñù ((stereoInvFunAux (-v : E) ‚àò (‚Üë)) ‚àò U.symm) 0) by
    convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddEquivClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have : HasFDerivAt (stereoInvFunAux (-v : E) ‚àò (Subtype.val : (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ ‚Üí E))
      (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective"
Mathlib/Order/SuccPred/LinearLocallyFinite.lean,toZ_iterate_pred_ge,toZ_iterate_pred_ge,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rcases le_or_lt i0 (pred^[n] i0) with h | h
  ¬∑ have h_eq : pred^[n] i0 = i0 := le_antisymm (pred_iterate_le _ _) h
    rw [h_eq, toZ_of_eq]
    simp only [Right.neg_nonpos_iff, Nat.cast_nonneg]
  ¬∑ rw [toZ_of_lt h, neg_le_neg_iff]
    norm_cast
    exact Nat.find_min' _ rfl","error:  unknown constant 'Nat.cast_nonneg'
error:  simp made no progress
error:  failed to synthesize
  CovariantClass ‚Ñ§ ‚Ñ§ (fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  CovariantClass ‚Ñ§ ‚Ñ§ (Function.swap fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1
use `set_option diagnostics true` to get diagnostic information
error:  unsolved goals
Œπ : Type u_1
inst‚úù¬≥ : LinearOrder Œπ
inst‚úù¬≤ : SuccOrder Œπ
inst‚úù¬π : IsSuccArchimedean Œπ
inst‚úù : PredOrder Œπ
i0 i : Œπ
n : ‚Ñï
h : pred^[n] i0 < i0
‚ä¢ CovariantClass ‚Ñ§ ‚Ñ§ (fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1

Œπ : Type u_1
inst‚úù¬≥ : LinearOrder Œπ
inst‚úù¬≤ : SuccOrder Œπ
inst‚úù¬π : IsSuccArchimedean Œπ
inst‚úù : PredOrder Œπ
i0 i : Œπ
n : ‚Ñï
h : pred^[n] i0 < i0
‚ä¢ CovariantClass ‚Ñ§ ‚Ñ§ (Function.swap fun x x_1 ‚Ü¶ x + x_1) fun x x_1 ‚Ü¶ x ‚â§ x_1",theorem toZ_iterate_pred_ge (n : ‚Ñï) : -(n : ‚Ñ§) ‚â§ toZ i0 (pred^[n] i0) ,":= by
  rcases le_or_lt i0 (pred^[n] i0) with h | h
  ¬∑ have h_eq : pred^[n] i0 = i0 := le_antisymm (pred_iterate_le _ _) h
    rw [h_eq, toZ_of_eq]
    omega
  ¬∑ rw [toZ_of_lt h]
    refine Int.neg_le_neg ?_
    norm_cast
    exact Nat.find_min' _ rfl"
Mathlib/CategoryTheory/Extensive.lean,CategoryTheory.FinitaryPreExtensive.sigma_desc_iso,FinitaryPreExtensive.sigma_desc_iso,4921473a163eff7f3a005863259a8eb06e94bb74,":= by
  suffices IsColimit (Cofan.mk _ ((fun _ ‚Ü¶ pullback.fst) : (a : Œ±) ‚Üí pullback f (œÄ a) ‚ü∂ _)) by
    change IsIso (this.coconePointUniqueUpToIso (getColimitCocone _).2).inv
    infer_instance
  let : IsColimit (Cofan.mk X œÄ)
  ¬∑ refine @IsColimit.ofPointIso (t := Cofan.mk X œÄ) (P := coproductIsCoproduct Z) ?_
    convert hœÄ
    simp [coproductIsCoproduct]
  refine (FinitaryPreExtensive.isUniversal_finiteCoproducts this
    (Cofan.mk _ ((fun _ ‚Ü¶ pullback.fst) : (a : Œ±) ‚Üí pullback f (œÄ a) ‚ü∂ _))
    (Discrete.natTrans fun i ‚Ü¶ pullback.snd) f ?_
    (NatTrans.equifibered_of_discrete _) ?_).some
  ¬∑ ext
    simp [pullback.condition]
  ¬∑ exact fun j ‚Ü¶ IsPullback.of_hasPullback f (œÄ j.as)","error:  unexpected token ':'; expected '_', identifier or term
error:  unsolved goals
J : Type v'
inst‚úù‚Å¥ : Category.{u', v'} J
C : Type u
inst‚úù¬≥ : Category.{v, u} C
D : Type u''
inst‚úù¬≤ : Category.{v'', u''} D
X‚úù Y‚úù : C
inst‚úù¬π : FinitaryPreExtensive C
Œ± : Type
inst‚úù : Finite Œ±
X : C
Z : Œ± ‚Üí C
œÄ : (a : Œ±) ‚Üí Z a ‚ü∂ X
Y : C
f : Y ‚ü∂ X
hœÄ : IsIso (Sigma.desc œÄ)
‚ä¢ IsColimit (Cofan.mk Y fun x ‚Ü¶ pullback.fst)","lemma FinitaryPreExtensive.sigma_desc_iso [FinitaryPreExtensive C] {Œ± : Type} [Finite Œ±] {X : C}
    {Z : Œ± ‚Üí C} (œÄ : (a : Œ±) ‚Üí Z a ‚ü∂ X) {Y : C} (f : Y ‚ü∂ X) (hœÄ : IsIso (Sigma.desc œÄ)) :
    IsIso (Sigma.desc ((fun _ ‚Ü¶ pullback.fst) : (a : Œ±) ‚Üí pullback f (œÄ a) ‚ü∂ _)) ",":= by
  suffices IsColimit (Cofan.mk _ ((fun _ ‚Ü¶ pullback.fst) : (a : Œ±) ‚Üí pullback f (œÄ a) ‚ü∂ _)) by
    change IsIso (this.coconePointUniqueUpToIso (getColimitCocone _).2).inv
    infer_instance
  let this : IsColimit (Cofan.mk X œÄ) := by
    refine @IsColimit.ofPointIso (t := Cofan.mk X œÄ) (P := coproductIsCoproduct Z) ?_
    convert hœÄ
    simp [coproductIsCoproduct]
  refine (FinitaryPreExtensive.isUniversal_finiteCoproducts this
    (Cofan.mk _ ((fun _ ‚Ü¶ pullback.fst) : (a : Œ±) ‚Üí pullback f (œÄ a) ‚ü∂ _))
    (Discrete.natTrans fun i ‚Ü¶ pullback.snd) f ?_
    (NatTrans.equifibered_of_discrete _) ?_).some
  ¬∑ ext
    simp [pullback.condition]
  ¬∑ exact fun j ‚Ü¶ IsPullback.of_hasPullback f (œÄ j.as)"
Mathlib/Probability/Martingale/Convergence.lean,MeasureTheory.Submartingale.ae_tendsto_limitProcess,Submartingale.ae_tendsto_limitProcess,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  classical
  suffices
      ‚àÉ g, StronglyMeasurable[‚®Ü n, ‚Ñ± n] g ‚àß ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù c) then h.choose else 0
  have hle : ‚®Ü n, ‚Ñ± n ‚â§ m0 := sSup_le fun m ‚ü®n, hn‚ü© => hn ‚ñ∏ ‚Ñ±.le _
  have hg' : ‚àÄ·µê œâ ‚àÇŒº.trim hle, Tendsto (fun n => f n œâ) atTop (ùìù (g' œâ)) := by
    filter_upwards [hf.exists_ae_trim_tendsto_of_bdd hbdd] with œâ hœâ
    simp_rw [dif_pos hœâ]
    exact hœâ.choose_spec
  have hg'm : @AEStronglyMeasurable _ _ _ (‚®Ü n, ‚Ñ± n) g' (Œº.trim hle) :=
    (@aemeasurable_of_tendsto_metrizable_ae' _ _ (‚®Ü n, ‚Ñ± n) _ _ _ _ _ _ _
      (fun n => ((hf.stronglyMeasurable n).measurable.mono (le_sSup ‚ü®n, rfl‚ü© : ‚Ñ± n ‚â§ ‚®Ü n, ‚Ñ± n)
        le_rfl).aemeasurable) hg').aestronglyMeasurable
  obtain ‚ü®g, hgm, hae‚ü© := hg'm
  have hg : ‚àÄ·µê œâ ‚àÇŒº.trim hle, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) := by
    filter_upwards [hae, hg'] with œâ hœâ hg'œâ
    exact hœâ ‚ñ∏ hg'œâ
  exact ‚ü®g, hgm, measure_eq_zero_of_trim_eq_zero hle hg‚ü©",error:  simp made no progress,"theorem Submartingale.ae_tendsto_limitProcess [IsFiniteMeasure Œº] (hf : Submartingale f ‚Ñ± Œº)
    (hbdd : ‚àÄ n, snorm (f n) 1 Œº ‚â§ R) :
    ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => f n œâ) atTop (ùìù (‚Ñ±.limitProcess f Œº œâ)) ",":= by
  classical
  suffices
      ‚àÉ g, StronglyMeasurable[‚®Ü n, ‚Ñ± n] g ‚àß ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù c) then h.choose else 0
  have hle : ‚®Ü n, ‚Ñ± n ‚â§ m0 := sSup_le fun m ‚ü®n, hn‚ü© => hn ‚ñ∏ ‚Ñ±.le _
  have hg' : ‚àÄ·µê œâ ‚àÇŒº.trim hle, Tendsto (fun n => f n œâ) atTop (ùìù (g' œâ)) := by
    filter_upwards [hf.exists_ae_trim_tendsto_of_bdd hbdd] with œâ hœâ
    simp_rw [g', dif_pos hœâ]
    exact hœâ.choose_spec
  have hg'm : @AEStronglyMeasurable _ _ _ (‚®Ü n, ‚Ñ± n) g' (Œº.trim hle) :=
    (@aemeasurable_of_tendsto_metrizable_ae' _ _ (‚®Ü n, ‚Ñ± n) _ _ _ _ _ _ _
      (fun n => ((hf.stronglyMeasurable n).measurable.mono (le_sSup ‚ü®n, rfl‚ü© : ‚Ñ± n ‚â§ ‚®Ü n, ‚Ñ± n)
        le_rfl).aemeasurable) hg').aestronglyMeasurable
  obtain ‚ü®g, hgm, hae‚ü© := hg'm
  have hg : ‚àÄ·µê œâ ‚àÇŒº.trim hle, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) := by
    filter_upwards [hae, hg'] with œâ hœâ hg'œâ
    exact hœâ ‚ñ∏ hg'œâ
  exact ‚ü®g, hgm, measure_eq_zero_of_trim_eq_zero hle hg‚ü©"
Mathlib/MeasureTheory/Decomposition/Jordan.lean,MeasureTheory.SignedMeasure.mutuallySingular_ennreal_iff,mutuallySingular_ennreal_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  constructor
  ¬∑ rintro ‚ü®u, hmeas, hu‚ÇÅ, hu‚ÇÇ‚ü©
    obtain ‚ü®i, hi‚ÇÅ, hi‚ÇÇ, hi‚ÇÉ, hpos, hneg‚ü© := s.toJordanDecomposition_spec
    refine ‚ü®u, hmeas, ?_, ?_‚ü©
    ¬∑ rw [totalVariation, Measure.add_apply, hpos, hneg, toMeasureOfZeroLE_apply _ _ _ hmeas,
        toMeasureOfLEZero_apply _ _ _ hmeas]
      simp [hu‚ÇÅ _ (Set.inter_subset_right _ _), ‚Üê NNReal.eq_iff]
    ¬∑ rw [VectorMeasure.ennrealToMeasure_apply hmeas.compl]
      exact hu‚ÇÇ _ (Set.Subset.refl _)
  ¬∑ rintro ‚ü®u, hmeas, hu‚ÇÅ, hu‚ÇÇ‚ü©
    refine
      VectorMeasure.MutuallySingular.mk u hmeas
        (fun t htu _ => null_of_totalVariation_zero _ (measure_mono_null htu hu‚ÇÅ)) fun t htv hmt =>
        ?_
    rw [‚Üê VectorMeasure.ennrealToMeasure_apply hmt]
    exact measure_mono_null htv hu‚ÇÇ","error:  function expected at
  Set.inter_subset_right ?m.97034
term has type
  ?m.97033 ‚àà ?m.97032
error:  unsolved goals
case mp.intro.intro.intro.intro.intro.intro.intro.intro.refine_1
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù : MeasurableSpace Œ±
s : SignedMeasure Œ±
Œº : VectorMeasure Œ± ‚Ñù‚â•0‚àû
u : Set Œ±
hmeas : MeasurableSet u
hu‚ÇÅ : ‚àÄ t ‚äÜ u, ‚Üës t = 0
hu‚ÇÇ : ‚àÄ t ‚äÜ u·∂ú, ‚ÜëŒº t = 0
i : Set Œ±
hi‚ÇÅ : MeasurableSet i
hi‚ÇÇ : VectorMeasure.restrict 0 i ‚â§ VectorMeasure.restrict s i
hi‚ÇÉ : VectorMeasure.restrict s i·∂ú ‚â§ VectorMeasure.restrict 0 i·∂ú
hpos : s.toJordanDecomposition.posPart = s.toMeasureOfZeroLE i hi‚ÇÅ hi‚ÇÇ
hneg : s.toJordanDecomposition.negPart = s.toMeasureOfLEZero i·∂ú ‚ãØ hi‚ÇÉ
‚ä¢ ‚Üës (i ‚à© u) = 0 ‚àß ‚Üës (i·∂ú ‚à© u) = 0","theorem mutuallySingular_ennreal_iff (s : SignedMeasure Œ±) (Œº : VectorMeasure Œ± ‚Ñù‚â•0‚àû) :
    s ‚üÇ·µ• Œº ‚Üî s.totalVariation ‚üÇ‚Çò Œº.ennrealToMeasure ",":= by
  constructor
  ¬∑ rintro ‚ü®u, hmeas, hu‚ÇÅ, hu‚ÇÇ‚ü©
    obtain ‚ü®i, hi‚ÇÅ, hi‚ÇÇ, hi‚ÇÉ, hpos, hneg‚ü© := s.toJordanDecomposition_spec
    refine ‚ü®u, hmeas, ?_, ?_‚ü©
    ¬∑ rw [totalVariation, Measure.add_apply, hpos, hneg, toMeasureOfZeroLE_apply _ _ _ hmeas,
        toMeasureOfLEZero_apply _ _ _ hmeas]
      simp [hu‚ÇÅ _ Set.inter_subset_right, ‚Üê NNReal.eq_iff]
    ¬∑ rw [VectorMeasure.ennrealToMeasure_apply hmeas.compl]
      exact hu‚ÇÇ _ (Set.Subset.refl _)
  ¬∑ rintro ‚ü®u, hmeas, hu‚ÇÅ, hu‚ÇÇ‚ü©
    refine
      VectorMeasure.MutuallySingular.mk u hmeas
        (fun t htu _ => null_of_totalVariation_zero _ (measure_mono_null htu hu‚ÇÅ)) fun t htv hmt =>
        ?_
    rw [‚Üê VectorMeasure.ennrealToMeasure_apply hmt]
    exact measure_mono_null htv hu‚ÇÇ"
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow,discr_prime_pow,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ norm_num; simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne.def, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.69692 ‚Üí ?m.69692 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.69694
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2‚úù : p = 2 ‚Üí k ‚â† 0
hp2 : p ‚â† 2
‚ä¢ ‚Üëp ‚â† 2
warning:  `Polynomial.C_eq_nat_cast` has been deprecated, use `Polynomial.C_eq_natCast` instead
warning:  `Polynomial.C_eq_nat_cast` has been deprecated, use `Polynomial.C_eq_natCast` instead
warning:  `Polynomial.aeval_nat_cast` has been deprecated, use `Polynomial.aeval_natCast` instead
warning:  `IsPrimitiveRoot.pow_sub_one_norm_prime_pow_of_ne_zero` has been deprecated, use `IsPrimitiveRoot.norm_pow_sub_one_eq_prime_pow_of_ne_zero` instead
warning:  `IsPrimitiveRoot.pow_sub_one_norm_prime_ne_two` has been deprecated, use `IsPrimitiveRoot.norm_pow_sub_one_of_prime_ne_two` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.96408 ‚Üí ?m.96408 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.96410
case e_a.refine_1
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2 : p = 2 ‚Üí k ‚â† 0
H :
  (Algebra.norm K) ((aeval Œ∂) (derivative (cyclotomic (‚Üëp ^ (k + 1)) K))) * ‚Üë‚Üëp ^ ‚Üëp ^ k =
    ‚Üë‚Üëp ^ (‚Üëp ^ k * (k.succ * (‚Üëp - 1)).pred) * ‚Üë‚Üëp ^ ‚Üëp ^ k
hnorm : (Algebra.norm K) (Œ∂ ^ ‚Üëp ^ k - 1) = ‚Üë‚Üëp ^ ‚Üëp ^ k
this‚úù : 0 < k.succ * (‚Üëp - 1)
h : ‚Üë‚Üëp ^ ‚Üëp ^ k = 0
this : ‚Üë‚Üëp ^ (k + 1) ‚â† 0
‚ä¢ False","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ‚Ñï).Prime]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1)) : ‚Ñï) K))
    (hk : p ^ (k + 1) ‚â† 2) : discr K (hŒ∂.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : ‚Ñï).totient / 2) * p ^ ((p : ‚Ñï) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this"
Mathlib/Algebra/BigOperators/Group/Multiset.lean,Multiset.sum_nat_mod,sum_nat_mod,c959b2f950b9c44268e36bcedef976356855e6fb,":= by
  induction s <;> simp [Nat.add_mod, *]","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
F : Type u_1
Œπ : Type u_2
Œ± : Type u_3
Œ≤ : Type u_4
Œ≥ : Type u_5
s : Multiset ‚Ñï
n : ‚Ñï
‚ä¢ s.sum % n = (map (fun x ‚Ü¶ x % n) s).sum % n",theorem sum_nat_mod (s : Multiset ‚Ñï) (n : ‚Ñï) : s.sum % n = (s.map (¬∑ % n)).sum % n ,":= by
  induction s using Multiset.induction <;> simp [Nat.add_mod, *]"
Mathlib/Algebra/Homology/QuasiIso.lean,quasiIsoAt_iff_exactAt',quasiIsoAt_iff_exactAt',4773ba7abb162ea632c1ff5810cd5f45a1289422,":= by
  simp only [quasiIsoAt_iff, ShortComplex.quasiIso_iff, HomologicalComplex.exactAt_iff,
    ShortComplex.exact_iff_isZero_homology] at hD ‚ä¢
  constructor
  ¬∑ intro h
    exact IsZero.of_iso hD (@asIso _ _ _ _ _ h)
  ¬∑ intro hC
    exact ‚ü®‚ü®0, IsZero.eq_of_src hC _ _, IsZero.eq_of_tgt hD _ _‚ü©‚ü©",error:  unknown identifier 'hD',"lemma quasiIsoAt_iff_exactAt' (f : K ‚ü∂ L) (i : Œπ) [K.HasHomology i] [L.HasHomology i]
    (hL : L.ExactAt i) :
    QuasiIsoAt f i ‚Üî K.ExactAt i ",":= by
  simp only [quasiIsoAt_iff, ShortComplex.quasiIso_iff, exactAt_iff,
    ShortComplex.exact_iff_isZero_homology] at hL ‚ä¢
  constructor
  ¬∑ intro h
    exact IsZero.of_iso hL (@asIso _ _ _ _ _ h)
  ¬∑ intro hK
    exact ‚ü®‚ü®0, IsZero.eq_of_src hK _ _, IsZero.eq_of_tgt hL _ _‚ü©‚ü©"
Mathlib/Probability/Distributions/Gaussian.lean,ProbabilityTheory.gaussianReal_map_add_const,gaussianReal_map_add_const,1c91c2706a3ccd891c3dcb859d92f31890fa3090,":= by
  by_cases hv : v = 0
  ¬∑ simp only [hv, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.add_const _) _
  let e : ‚Ñù ‚âÉ·µê ‚Ñù := (Homeomorph.addRight y).symm.toMeasurableEquiv
  have he' : ‚àÄ x, HasDerivAt e ((fun _ ‚Ü¶ 1) x) x := fun _ ‚Ü¶ (hasDerivAt_id _).sub_const y
  change (gaussianReal Œº v).map e.symm = gaussianReal (Œº + y) v
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs']
  simp only [abs_neg, abs_one, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, one_mul, ne_eq]
  rw [gaussianReal_apply_eq_integral _ hv s']
  simp [gaussianPDFReal_sub _ y, Homeomorph.addRight, ‚Üê sub_eq_add_neg]",error:  simp made no progress,"lemma gaussianReal_map_add_const (y : ‚Ñù) :
    (gaussianReal Œº v).map (¬∑ + y) = gaussianReal (Œº + y) v ",":= by
  by_cases hv : v = 0
  ¬∑ simp only [hv, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.add_const _) _
  let e : ‚Ñù ‚âÉ·µê ‚Ñù := (Homeomorph.addRight y).symm.toMeasurableEquiv
  have he' : ‚àÄ x, HasDerivAt e ((fun _ ‚Ü¶ 1) x) x := fun _ ‚Ü¶ (hasDerivAt_id _).sub_const y
  change (gaussianReal Œº v).map e.symm = gaussianReal (Œº + y) v
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs']
  simp only [abs_neg, abs_one, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, one_mul, ne_eq]
  rw [gaussianReal_apply_eq_integral _ hv s']
  simp [e, gaussianPDFReal_sub _ y, Homeomorph.addRight, ‚Üê sub_eq_add_neg]"
Mathlib/Analysis/Seminorm.lean,balanced_ball_zero,balanced_ball_zero,0bc9e28b50593c968afd9e45b23586cbdd0008e0,":= by
  rintro a ha x ‚ü®y, hy, hx‚ü©
  rw [mem_ball_zero, ‚Üê hx, map_smul_eq_mul]
  calc
    _ ‚â§ p y := mul_le_of_le_one_left (map_nonneg p _) ha
    _ < r := by rwa [mem_ball_zero] at hy","error:  failed to synthesize
  Preorder E
use `set_option diagnostics true` to get diagnostic information",theorem balanced_ball_zero (r : ‚Ñù) : Balanced ùïú (ball p 0 r) ,":= by
  rintro a ha x ‚ü®y, hy, hx‚ü©
  rw [mem_ball_zero, ‚Üê hx, map_smul_eq_mul]
  calc
    _ ‚â§ p y := mul_le_of_le_one_left (apply_nonneg p _) ha
    _ < r := by rwa [mem_ball_zero] at hy"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero, Nat.zero_eq,
          Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_0_of_lt_1
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120388 ‚Üí ?m.120388
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.123472 ‚Üí ?m.123472
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà u 0, closedBall p.1 p.2) ‚â§ Œº s
error:  type mismatch
  mul_le_mul_left' IH (‚ÜëN / (‚ÜëN + 1))
has type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * ((‚ÜëN / (‚ÜëN + 1)) ^ n * Œº s) : Prop
but is expected to have type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ (‚ÜëN / (‚ÜëN + 1)) ^ n * (‚ÜëN / (‚ÜëN + 1) * Œº s) : Prop
warning:  `ENNReal.tendsto_pow_atTop_nhds_0_of_lt_1` has been deprecated, use `ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one` instead
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133159 ‚Üí ?m.133159 ‚Üí Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133295 ‚Üí ?m.133295 ‚Üí Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.getD_leftInvSeq_mul_wordProd,getD_leftInvSeq_mul_wordProd,5549e23620db2b17d4924bff0c4de45d992f0b8d,":= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [‚Üê take_append_drop (j + 1) œâ]
  rw [take_succ]
  rcases em (j < œâ.length) with hj | nhj
  ¬∑ rw [get?_eq_get hj]
    simp only [wordProd_append, wordProd_cons, mul_assoc]
    simp
  ¬∑ rw [get?_eq_none.mpr (by linarith)]
    simp","error:  unsolved goals
case inl
B : Type u_1
W : Type u_2
inst‚úù : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
œâ : List B
j : ‚Ñï
hj : j < œâ.length
‚ä¢ cs.simple œâ[j] * (cs.wordProd œâ[j]?.toList * cs.wordProd (drop (j + 1) œâ)) = cs.wordProd (drop (j + 1) œâ)
error:  unsolved goals
case inr
B : Type u_1
W : Type u_2
inst‚úù : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
œâ : List B
j : ‚Ñï
nhj : ¬¨j < œâ.length
‚ä¢ cs.wordProd (take j œâ ++ (œâ[j]?.toList ++ drop (j + 1) œâ)) = cs.wordProd (take j œâ ++ drop (j + 1) œâ)","theorem getD_leftInvSeq_mul_wordProd (œâ : List B) (j : ‚Ñï) :
    ((lis œâ).getD j 1) * œÄ œâ = œÄ (œâ.eraseIdx j) ",":= by
  rw [getD_leftInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 4 [‚Üê take_append_drop (j + 1) œâ]
  rw [take_succ]
  obtain lt | le := lt_or_le j œâ.length
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]
    simp
  ¬∑ simp only [get?_eq_getElem?, getElem?_eq_none le]
    simp"
Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean,Path.Homotopy.continuous_transAssocReparamAux,continuous_transAssocReparamAux,2ab2720bf60e325ecde05f72c30fd6346f06a460,":= by
  refine continuous_if_le ?_ ?_ (Continuous.continuousOn? _)
      (continuous_if_le ?_ ?_ (Continuous.continuousOn ?_) (Continuous.continuousOn ?_)? _).continuousOn
      ?_ <;>
    [continuity; continuity; continuity; continuity; continuity; continuity; continuity; skip;
      skip] <;>
    ¬∑ intro x hx
      set_option tactic.skipAssignedInstances false in norm_num [hx]","error:  unexpected token '?'; expected ')', ',' or ':'
error:  unexpected identifier; expected command
warning:  fundamentalGroupoidFunctor does not have a doc string",theorem continuous_transAssocReparamAux : Continuous transAssocReparamAux ,":= by
  refine continuous_if_le ?_ ?_ (Continuous.continuousOn ?_)
    (continuous_if_le ?_ ?_
      (Continuous.continuousOn ?_) (Continuous.continuousOn ?_) ?_).continuousOn
      ?_ <;>
    [continuity; continuity; continuity; continuity; continuity; continuity; continuity; skip;
      skip] <;>
    ¬∑ intro x hx
      norm_num [hx]"
Mathlib/LinearAlgebra/QuadraticForm/Basic.lean,QuadraticForm.map_neg,map_neg,18f1e3ee387a3d040ba88fad8882f979755c163f,":= by
  rw [‚Üê @neg_one_smul R _ _ _ _ x, map_smul, neg_one_mul, neg_neg, one_smul]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  1 ‚Ä¢ ?b
S : Type u_1
T : Type u_2
R : Type u_3
M : Type u_4
N : Type u_5
inst‚úù¬≤ : CommRing R
inst‚úù¬π : AddCommGroup M
inst‚úù : Module R M
Q : QuadraticForm R M
x : M
‚ä¢ 1 * Q x = Q x",theorem map_neg (x : M) : Q (-x) = Q x ,":= by
  rw [‚Üê @neg_one_smul R _ _ _ _ x, map_smul, neg_one_mul, neg_neg, one_mul]"
Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean,GeneralizedContinuedFraction.IntFractPair.succ_nth_stream_eq_some_iff,succ_nth_stream_eq_some_iff,89d7bb3d38da7fac66f85faa3d219547920ff0dc,":= by
  simp [IntFractPair.stream, ite_eq_iff]","error:  unsolved goals
K : Type u_1
inst‚úù¬π : LinearOrderedField K
inst‚úù : FloorRing K
v : K
n : ‚Ñï
ifp_succ_n : IntFractPair K
‚ä¢ ((IntFractPair.stream v n).bind fun ap_n ‚Ü¶ if ap_n.fr = 0 then none else some (IntFractPair.of ap_n.fr‚Åª¬π)) =
      some ifp_succ_n ‚Üî
    ‚àÉ ifp_n, IntFractPair.stream v n = some ifp_n ‚àß ¬¨ifp_n.fr = 0 ‚àß IntFractPair.of ifp_n.fr‚Åª¬π = ifp_succ_n","theorem succ_nth_stream_eq_some_iff {ifp_succ_n : IntFractPair K} :
    IntFractPair.stream v (n + 1) = some ifp_succ_n ‚Üî
      ‚àÉ ifp_n : IntFractPair K,
        IntFractPair.stream v n = some ifp_n ‚àß
          ifp_n.fr ‚â† 0 ‚àß IntFractPair.of ifp_n.fr‚Åª¬π = ifp_succ_n ",":= by
  simp [IntFractPair.stream, ite_eq_iff, Option.bind_eq_some]"
Mathlib/Data/List/OfFn.lean,List.get?_ofFn,get?_ofFn,a380f5a603bf5030bc30e58b1aed19567f67b98d,":=
  if h : i < (ofFn f).length
  then by
    rw [get?_eq_get h, get_ofFn]
    ¬∑ simp at h; simp [ofFnNthVal, h]
  else by
    rw [ofFnNthVal, dif_neg] <;>
    simpa using h","error:  type mismatch
  h‚úù
has type
  n ‚â§ i : Prop
but is expected to have type
  ofFnNthVal f i = none : Prop
error:  unsolved goals
Œ± : Type u
n : ‚Ñï
f : Fin n ‚Üí Œ±
i : ‚Ñï
h : ¬¨i < (ofFn f).length
‚ä¢ (ofFn f).get? i = none
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_ofFn` has been deprecated, use `List.get_ofFn` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead",theorem get?_ofFn {n} (f : Fin n ‚Üí Œ±) (i) : get? (ofFn f) i = ofFnNthVal f i ,":= by
  simp"
Mathlib/Probability/ProbabilityMassFunction/Basic.lean,PMF.toOuterMeasure_apply_eq_of_inter_support_eq,toOuterMeasure_apply_eq_of_inter_support_eq,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  le_antisymm (p.toOuterMeasure_mono (h.symm ‚ñ∏ Set.inter_subset_left t p.support))
    (p.toOuterMeasure_mono (h ‚ñ∏ Set.inter_subset_left s p.support))","error:  application type mismatch
  Set.inter_subset_left t
argument
  t
has type
  Set Œ± : Type u_1
but is expected to have type
  ?m.26578 ‚àà ?m.26576 ‚à© ?m.26577 : Prop
error:  application type mismatch
  Set.inter_subset_left s
argument
  s
has type
  Set Œ± : Type u_1
but is expected to have type
  ?m.26996 ‚àà ?m.26994 ‚à© ?m.26995 : Prop","theorem toOuterMeasure_apply_eq_of_inter_support_eq {s t : Set Œ±}
    (h : s ‚à© p.support = t ‚à© p.support) : p.toOuterMeasure s = p.toOuterMeasure t ",":=
  le_antisymm (p.toOuterMeasure_mono (h.symm ‚ñ∏ Set.inter_subset_left))
    (p.toOuterMeasure_mono (h ‚ñ∏ Set.inter_subset_left))"
Mathlib/Topology/Sober.lean,quasiSober_of_open_cover,quasiSober_of_open_cover,c7bd9bd10c613e1788107ba753e252f069560f87,":= by
  rw [quasiSober_iff]
  intro t h h'
  obtain ‚ü®x, hx‚ü© := h.1
  obtain ‚ü®U, hU, hU'‚ü© : x ‚àà ‚ãÉ‚ÇÄ S := by
    rw [hS'']
    trivial
  haveI : QuasiSober U := hS' ‚ü®U, hU‚ü©
  have H : IsPreirreducible ((‚Üë) ‚Åª¬π' t : Set U) :=
    h.2.preimage (hS ‚ü®U, hU‚ü©).openEmbedding_subtype_val
  replace H : IsIrreducible ((‚Üë) ‚Åª¬π' t : Set U) := ‚ü®‚ü®‚ü®x, hU'‚ü©, by simpa using hx‚ü©, H‚ü©
  use H.genericPoint
  have := continuous_subtype_val.closure_preimage_subset _ H.genericPoint_spec.mem
  rw [h'.closure_eq] at this
  apply le_antisymm
  ¬∑ apply h'.closure_subset_iff.mpr
    simpa using this
  rw [‚Üê image_singleton, ‚Üê closure_image_closure continuous_subtype_val, H.genericPoint_spec.def']
  refine' (subset_closure_inter_of_isPreirreducible_of_isOpen h.2 (hS ‚ü®U, hU‚ü©) ‚ü®x, hx, hU'‚ü©).trans
    (closure_mono _)
  rw [inter_comm t, ‚Üê Subtype.image_preimage_coe]
  exact Set.image_subset _ subset_closure","error:  invalid field 'def'', the environment does not contain 'IsGenericPoint.def''
  IsIrreducible.genericPoint_spec H
has type
  IsGenericPoint H.genericPoint (closure (Subtype.val ‚Åª¬π' t))
error:  invalid field 'def'', the environment does not contain 'Eq.def''
  IsIrreducible.genericPoint_spec H
has type
  closure {H.genericPoint} = closure (Subtype.val ‚Åª¬π' t)
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.16526
case h.a
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬π : TopologicalSpace Œ±
inst‚úù : TopologicalSpace Œ≤
S : Set (Set Œ±)
hS : ‚àÄ (s : ‚ÜëS), IsOpen ‚Üës
hS' : ‚àÄ (s : ‚ÜëS), QuasiSober ‚Üë‚Üës
hS'' : ‚ãÉ‚ÇÄ S = ‚ä§
t : Set Œ±
h : IsIrreducible t
h' : IsClosed t
x : Œ±
hx : x ‚àà t
U : Set Œ±
hU : U ‚àà S
hU' : x ‚àà U
this‚úù : QuasiSober ‚ÜëU
H : IsIrreducible (Subtype.val ‚Åª¬π' t)
this : H.genericPoint ‚àà Subtype.val ‚Åª¬π' t
‚ä¢ t ‚â§ closure (Subtype.val '' closure {H.genericPoint})","theorem quasiSober_of_open_cover (S : Set (Set Œ±)) (hS : ‚àÄ s : S, IsOpen (s : Set Œ±))
    [hS' : ‚àÄ s : S, QuasiSober s] (hS'' : ‚ãÉ‚ÇÄ S = ‚ä§) : QuasiSober Œ± ",":= by
  rw [quasiSober_iff]
  intro t h h'
  obtain ‚ü®x, hx‚ü© := h.1
  obtain ‚ü®U, hU, hU'‚ü© : x ‚àà ‚ãÉ‚ÇÄ S := by
    rw [hS'']
    trivial
  haveI : QuasiSober U := hS' ‚ü®U, hU‚ü©
  have H : IsPreirreducible ((‚Üë) ‚Åª¬π' t : Set U) :=
    h.2.preimage (hS ‚ü®U, hU‚ü©).openEmbedding_subtype_val
  replace H : IsIrreducible ((‚Üë) ‚Åª¬π' t : Set U) := ‚ü®‚ü®‚ü®x, hU'‚ü©, by simpa using hx‚ü©, H‚ü©
  use H.genericPoint
  have := continuous_subtype_val.closure_preimage_subset _ H.genericPoint_spec.mem
  rw [h'.closure_eq] at this
  apply le_antisymm
  ¬∑ apply h'.closure_subset_iff.mpr
    simpa using this
  rw [‚Üê image_singleton, ‚Üê closure_image_closure continuous_subtype_val, H.genericPoint_spec.def]
  refine (subset_closure_inter_of_isPreirreducible_of_isOpen h.2 (hS ‚ü®U, hU‚ü©) ‚ü®x, hx, hU'‚ü©).trans
    (closure_mono ?_)
  rw [inter_comm t, ‚Üê Subtype.image_preimage_coe]
  exact Set.image_subset _ subset_closure"
Mathlib/MeasureTheory/Measure/WithDensityFinite.lean,MeasureTheory.measure_compl_sigmaFiniteSet,measure_compl_sigmaFiniteSet,e2d928188e93fa0596622c7eba77ddc5aab32807,":= by
  rw [‚Üê Measure.iSup_restrict_spanningSets]
  simp only [ENNReal.iSup_eq_zero]
  intro n
  rw [Measure.restrict_apply' (measurable_spanningSets Œº n)]
  refine (measure_eq_zero_or_top_of_subset_compl_sigmaFiniteSet
    ((measurableSet_sigmaFiniteSet _).compl.inter (measurable_spanningSets Œº n))
    (Set.inter_subset_left _ _)).resolve_right (ne_of_lt ?_)
  exact (measure_mono (Set.inter_subset_right _ _)).trans_lt (measure_spanningSets_lt_top _ _)","error:  application type mismatch
  measure_eq_zero_or_top_of_subset_compl_sigmaFiniteSet
    (MeasurableSet.inter (MeasurableSet.compl (measurableSet_sigmaFiniteSet ?m.69205)) (measurable_spanningSets Œº n))
argument
  MeasurableSet.inter (MeasurableSet.compl (measurableSet_sigmaFiniteSet ?m.69205)) (measurable_spanningSets Œº n)
has type
  MeasurableSet (?m.69205.sigmaFiniteSet·∂ú ‚à© spanningSets Œº n) : Prop
but is expected to have type
  ?m.69200 ‚äÜ ?m.69199.sigmaFiniteSet·∂ú : Prop
error:  no goals to be solved",lemma measure_compl_sigmaFiniteSet (Œº : Measure Œ±) [SigmaFinite Œº] : Œº Œº.sigmaFiniteSet·∂ú = 0 ,":=
  densityToFinite_ae_ne_top Œº"
Mathlib/MeasureTheory/Function/SimpleFuncDenseLp.lean,MeasureTheory.Mem‚Ñíp.induction_dense,Mem‚Ñíp.induction_dense,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  rcases eq_or_ne p 0 with (rfl | hp_pos)
  ¬∑ rcases h0P (0 : E) MeasurableSet.empty (by simp only [measure_empty, zero_lt_top])
        hŒµ with ‚ü®g, _, Pg‚ü©
    exact ‚ü®g, by simp only [snorm_exponent_zero, zero_le'], Pg‚ü©
  suffices H :
    ‚àÄ (f' : Œ± ‚Üí‚Çõ E) (Œ¥ : ‚Ñù‚â•0‚àû) (hŒ¥ : Œ¥ ‚â† 0), Mem‚Ñíp f' p Œº ‚Üí ‚àÉ g, snorm (‚áëf' - g) p Œº ‚â§ Œ¥ ‚àß P g
  ¬∑ obtain ‚ü®Œ∑, Œ∑pos, hŒ∑‚ü© := exists_Lp_half E Œº p hŒµ
    rcases hf.exists_simpleFunc_snorm_sub_lt hp_ne_top Œ∑pos.ne' with ‚ü®f', hf', f'_mem‚ü©
    rcases H f' Œ∑ Œ∑pos.ne' f'_mem with ‚ü®g, hg, Pg‚ü©
    refine' ‚ü®g, _, Pg‚ü©
    convert (hŒ∑ _ _ (hf.aestronglyMeasurable.sub f'.aestronglyMeasurable)
          (f'.aestronglyMeasurable.sub (h2P g Pg)) hf'.le hg).le using 2
    simp only [sub_add_sub_cancel]
  apply SimpleFunc.induction
  ¬∑ intro c s hs Œµ Œµpos Hs
    rcases eq_or_ne c 0 with (rfl | hc)
    ¬∑ rcases h0P (0 : E) MeasurableSet.empty (by simp only [measure_empty, zero_lt_top])
          Œµpos with ‚ü®g, hg, Pg‚ü©
      rw [‚Üê snorm_neg, neg_sub] at hg
      refine' ‚ü®g, _, Pg‚ü©
      convert hg
      ext x
      simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_zero,
        piecewise_eq_indicator, indicator_zero', Pi.zero_apply, indicator_zero]
    ¬∑ have : Œº s < ‚àû := SimpleFunc.measure_lt_top_of_mem‚Ñíp_indicator hp_pos hp_ne_top hc hs Hs
      rcases h0P c hs this Œµpos with ‚ü®g, hg, Pg‚ü©
      rw [‚Üê snorm_neg, neg_sub] at hg
      exact ‚ü®g, hg, Pg‚ü©
  ¬∑ intro f f' hff' hf hf' Œ¥ Œ¥pos int_ff'
    obtain ‚ü®Œ∑, Œ∑pos, hŒ∑‚ü© := exists_Lp_half E Œº p Œ¥pos
    rw [SimpleFunc.coe_add,
      mem‚Ñíp_add_of_disjoint hff' f.stronglyMeasurable f'.stronglyMeasurable] at int_ff'
    rcases hf Œ∑ Œ∑pos.ne' int_ff'.1 with ‚ü®g, hg, Pg‚ü©
    rcases hf' Œ∑ Œ∑pos.ne' int_ff'.2 with ‚ü®g', hg', Pg'‚ü©
    refine' ‚ü®g + g', _, h1P g g' Pg Pg'‚ü©
    convert (hŒ∑ _ _ (f.aestronglyMeasurable.sub (h2P g Pg))
          (f'.aestronglyMeasurable.sub (h2P g' Pg')) hg hg').le using 2
    rw [SimpleFunc.coe_add]
    abel","error:  unexpected token '¬∑'; expected 'by' or 'from'
warning:  @Lp.simpleFunc does not have a doc string","theorem Mem‚Ñíp.induction_dense (hp_ne_top : p ‚â† ‚àû) (P : (Œ± ‚Üí E) ‚Üí Prop)
    (h0P :
      ‚àÄ (c : E) ‚¶És : Set Œ±‚¶Ñ,
        MeasurableSet s ‚Üí
          Œº s < ‚àû ‚Üí
            ‚àÄ {Œµ : ‚Ñù‚â•0‚àû}, Œµ ‚â† 0 ‚Üí ‚àÉ g : Œ± ‚Üí E, snorm (g - s.indicator fun _ => c) p Œº ‚â§ Œµ ‚àß P g)
    (h1P : ‚àÄ f g, P f ‚Üí P g ‚Üí P (f + g)) (h2P : ‚àÄ f, P f ‚Üí AEStronglyMeasurable f Œº) {f : Œ± ‚Üí E}
    (hf : Mem‚Ñíp f p Œº) {Œµ : ‚Ñù‚â•0‚àû} (hŒµ : Œµ ‚â† 0) : ‚àÉ g : Œ± ‚Üí E, snorm (f - g) p Œº ‚â§ Œµ ‚àß P g ",":= by
  rcases eq_or_ne p 0 with (rfl | hp_pos)
  ¬∑ rcases h0P (0 : E) MeasurableSet.empty (by simp only [measure_empty, zero_lt_top])
        hŒµ with ‚ü®g, _, Pg‚ü©
    exact ‚ü®g, by simp only [snorm_exponent_zero, zero_le'], Pg‚ü©
  suffices H : ‚àÄ (f' : Œ± ‚Üí‚Çõ E) (Œ¥ : ‚Ñù‚â•0‚àû) (hŒ¥ : Œ¥ ‚â† 0), Mem‚Ñíp f' p Œº ‚Üí
      ‚àÉ g, snorm (‚áëf' - g) p Œº ‚â§ Œ¥ ‚àß P g by
    obtain ‚ü®Œ∑, Œ∑pos, hŒ∑‚ü© := exists_Lp_half E Œº p hŒµ
    rcases hf.exists_simpleFunc_snorm_sub_lt hp_ne_top Œ∑pos.ne' with ‚ü®f', hf', f'_mem‚ü©
    rcases H f' Œ∑ Œ∑pos.ne' f'_mem with ‚ü®g, hg, Pg‚ü©
    refine ‚ü®g, ?_, Pg‚ü©
    convert (hŒ∑ _ _ (hf.aestronglyMeasurable.sub f'.aestronglyMeasurable)
          (f'.aestronglyMeasurable.sub (h2P g Pg)) hf'.le hg).le using 2
    simp only [sub_add_sub_cancel]
  apply SimpleFunc.induction
  ¬∑ intro c s hs Œµ Œµpos Hs
    rcases eq_or_ne c 0 with (rfl | hc)
    ¬∑ rcases h0P (0 : E) MeasurableSet.empty (by simp only [measure_empty, zero_lt_top])
          Œµpos with ‚ü®g, hg, Pg‚ü©
      rw [‚Üê snorm_neg, neg_sub] at hg
      refine ‚ü®g, ?_, Pg‚ü©
      convert hg
      ext x
      simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_zero,
        piecewise_eq_indicator, indicator_zero', Pi.zero_apply, indicator_zero]
    ¬∑ have : Œº s < ‚àû := SimpleFunc.measure_lt_top_of_mem‚Ñíp_indicator hp_pos hp_ne_top hc hs Hs
      rcases h0P c hs this Œµpos with ‚ü®g, hg, Pg‚ü©
      rw [‚Üê snorm_neg, neg_sub] at hg
      exact ‚ü®g, hg, Pg‚ü©
  ¬∑ intro f f' hff' hf hf' Œ¥ Œ¥pos int_ff'
    obtain ‚ü®Œ∑, Œ∑pos, hŒ∑‚ü© := exists_Lp_half E Œº p Œ¥pos
    rw [SimpleFunc.coe_add,
      mem‚Ñíp_add_of_disjoint hff' f.stronglyMeasurable f'.stronglyMeasurable] at int_ff'
    rcases hf Œ∑ Œ∑pos.ne' int_ff'.1 with ‚ü®g, hg, Pg‚ü©
    rcases hf' Œ∑ Œ∑pos.ne' int_ff'.2 with ‚ü®g', hg', Pg'‚ü©
    refine ‚ü®g + g', ?_, h1P g g' Pg Pg'‚ü©
    convert (hŒ∑ _ _ (f.aestronglyMeasurable.sub (h2P g Pg))
          (f'.aestronglyMeasurable.sub (h2P g' Pg')) hg hg').le using 2
    rw [SimpleFunc.coe_add]
    abel"
Mathlib/Geometry/Manifold/Instances/Sphere.lean,mfderiv_coe_sphere_injective,mfderiv_coe_sphere_injective,f191a7207be0307faaba26828726ed6192b89854,":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ùïú := ‚Ñù) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices Injective (fderiv ‚Ñù ((stereoInvFunAux (-v : E) ‚àò (‚Üë)) ‚àò U.symm) 0) by
    convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddEquivClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have : HasFDerivAt (stereoInvFunAux (-v : E) ‚àò ((‚Üë) : (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ ‚Üí E))
      (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚áë‚Üë?e
E : Type u_1
inst‚úù‚Å∏ : NormedAddCommGroup E
inst‚úù‚Å∑ : InnerProductSpace ‚Ñù E
F : Type u_2
inst‚úù‚Å∂ : NormedAddCommGroup F
inst‚úù‚Åµ : NormedSpace ‚Ñù F
H : Type u_3
inst‚úù‚Å¥ : TopologicalSpace H
I : ModelWithCorners ‚Ñù F H
M : Type u_4
inst‚úù¬≥ : TopologicalSpace M
inst‚úù¬≤ : ChartedSpace H M
inst‚úù¬π : SmoothManifoldWithCorners I M
n : ‚Ñï
inst‚úù : Fact (finrank ‚Ñù E = n + 1)
v : ‚Üë(sphere 0 1)
U : ‚Ü•(Submodule.span ‚Ñù {‚Üë(-v)})·óÆ ‚âÉ‚Çó·µ¢[‚Ñù] EuclideanSpace ‚Ñù (Fin n) :=
  (OrthonormalBasis.fromOrthogonalSpanSingleton n ‚ãØ).repr
this‚úù : HasFDerivAt (stereoInvFunAux (-‚Üëv) ‚àò Subtype.val) (Submodule.span ‚Ñù {‚Üë(-v)})·óÆ.subtypeL (U.symm 0)
this :
  ‚áë(fderiv ‚Ñù ((stereoInvFunAux (-‚Üëv) ‚àò Subtype.val) ‚àò ‚áëU.symm) 0) =
    ‚áë((Submodule.span ‚Ñù {‚Üë(-v)})·óÆ.subtypeL.comp ‚ÜëU.symm.toContinuousLinearEquiv)
‚ä¢ Injective (‚áë(Submodule.span ‚Ñù {‚Üë(-v)})·óÆ.subtypeL ‚àò ‚áë‚ÜëU.symm.toContinuousLinearEquiv)","theorem mfderiv_coe_sphere_injective {n : ‚Ñï} [Fact (finrank ‚Ñù E = n + 1)] (v : sphere (0 : E) 1) :
    Injective (mfderiv (ùì° n) ùìò(‚Ñù, E) ((‚Üë) : sphere (0 : E) 1 ‚Üí E) v) ",":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ùïú := ‚Ñù) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices Injective (fderiv ‚Ñù ((stereoInvFunAux (-v : E) ‚àò (‚Üë)) ‚àò U.symm) 0) by
    convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddEquivClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have : HasFDerivAt (stereoInvFunAux (-v : E) ‚àò (Subtype.val : (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ ‚Üí E))
      (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective"
Mathlib/Topology/NhdsSet.lean,IsClosed.nhdsSet_le_sup,IsClosed.nhdsSet_le_sup,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  calc
    ùìùÀ¢ s = ùìùÀ¢ (s ‚à© t ‚à™ s ‚à© t·∂ú) := by rw [Set.inter_union_compl s t]
    _ = ùìùÀ¢ (s ‚à© t) ‚äî ùìùÀ¢ (s ‚à© t·∂ú) := by rw [nhdsSet_union]
    _ ‚â§ ùìùÀ¢ (s ‚à© t) ‚äî ùìùÀ¢ (t·∂ú) := (sup_le_sup_left (monotone_nhdsSet (s.inter_subset_right (t·∂ú))) _)
    _ = ùìùÀ¢ (s ‚à© t) ‚äî ùìü (t·∂ú) := by rw [h.isOpen_compl.nhdsSet_eq]","error:  application type mismatch
  inter_subset_right t·∂ú
argument
  t·∂ú
has type
  Set X : Type u_1
but is expected to have type
  ?m.15899 ‚àà s ‚à© ?m.15898 : Prop",theorem IsClosed.nhdsSet_le_sup (h : IsClosed t) : ùìùÀ¢ s ‚â§ ùìùÀ¢ (s ‚à© t) ‚äî ùìü (t·∂ú) ,":=
  calc
    ùìùÀ¢ s = ùìùÀ¢ (s ‚à© t ‚à™ s ‚à© t·∂ú) := by rw [Set.inter_union_compl s t]
    _ = ùìùÀ¢ (s ‚à© t) ‚äî ùìùÀ¢ (s ‚à© t·∂ú) := by rw [nhdsSet_union]
    _ ‚â§ ùìùÀ¢ (s ‚à© t) ‚äî ùìùÀ¢ (t·∂ú) := sup_le_sup_left (monotone_nhdsSet inter_subset_right) _
    _ = ùìùÀ¢ (s ‚à© t) ‚äî ùìü (t·∂ú) := by rw [h.isOpen_compl.nhdsSet_eq]"
Mathlib/Analysis/Fourier/AddCircle.lean,fourierCoeff_eq_intervalIntegral,fourierCoeff_eq_intervalIntegral,50dac17e96f8a0ddcbd8740f9929f7cf0a85740d,":= by
  have : ‚àÄ x : ‚Ñù, @fourier T (-n) x ‚Ä¢ f x = (fun z : AddCircle T => @fourier T (-n) z ‚Ä¢ f z) x := by
    intro x; rfl
  simp_rw [this]
  rw [fourierCoeff, AddCircle.intervalIntegral_preimage T a (fun z => _ ‚Ä¢ _),
    volume_eq_smul_haarAddCircle, integral_smul_measure, ENNReal.toReal_ofReal hT.out.le,
    ‚Üê smul_assoc, smul_eq_mul, one_div_mul_cancel hT.out.ne', one_smul]","error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information","theorem fourierCoeff_eq_intervalIntegral (f : AddCircle T ‚Üí E) (n : ‚Ñ§) (a : ‚Ñù) :
    fourierCoeff f n = (1 / T) ‚Ä¢ ‚à´ x in a..a + T, @fourier T (-n) x ‚Ä¢ f x ",":= by
  have : ‚àÄ x : ‚Ñù, @fourier T (-n) x ‚Ä¢ f x = (fun z : AddCircle T => @fourier T (-n) z ‚Ä¢ f z) x := by
    intro x; rfl
  simp_rw (config := {singlePass := true}) [this]
  rw [fourierCoeff, AddCircle.intervalIntegral_preimage T a (fun z => _ ‚Ä¢ _),
    volume_eq_smul_haarAddCircle, integral_smul_measure, ENNReal.toReal_ofReal hT.out.le,
    ‚Üê smul_assoc, smul_eq_mul, one_div_mul_cancel hT.out.ne', one_smul]"
Mathlib/Combinatorics/Hall/Finite.lean,HallMarriageTheorem.hall_hard_inductive_step_B,hall_hard_inductive_step_B,28873c4cb83ad061e74703eaac0b51a8ec38d273,":= by
  haveI := Classical.decEq Œπ
  rw [Nat.add_one] at hn
  have card_Œπ'_le : Fintype.card s ‚â§ n := by
    apply Nat.le_of_lt_succ
    calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card Œπ := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
  let t' : s ‚Üí Finset Œ± := fun x' => t x'
  rcases ih t' card_Œπ'_le (hall_cond_of_restrict ht) with ‚ü®f', hf', hsf'‚ü©
  set Œπ'' := (s : Set Œπ)·∂ú
  let t'' : Œπ'' ‚Üí Finset Œ± := fun a'' => t a'' \ s.biUnion t
  have card_Œπ''_le : Fintype.card Œπ'' ‚â§ n := by
    simp_rw [Œπ'', ‚Üê Nat.lt_succ_iff, ‚Üê hn, ‚Üê Finset.coe_compl, coe_sort_coe]
    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]
  rcases ih t'' card_Œπ''_le (hall_cond_of_compl hus ht) with ‚ü®f'', hf'', hsf''‚ü©
  have f'_mem_biUnion : ‚àÄ (x') (hx' : x' ‚àà s), f' ‚ü®x', hx'‚ü© ‚àà s.biUnion t := by
    intro x' hx'
    rw [mem_biUnion]
    exact ‚ü®x', hx', hsf' _‚ü©
  have f''_not_mem_biUnion : ‚àÄ (x'') (hx'' : ¬¨x'' ‚àà s), ¬¨f'' ‚ü®x'', hx''‚ü© ‚àà s.biUnion t := by
    intro x'' hx''
    have h := hsf'' ‚ü®x'', hx''‚ü©
    rw [mem_sdiff] at h
    exact h.2
  have im_disj :
      ‚àÄ (x' x'' : Œπ) (hx' : x' ‚àà s) (hx'' : ¬¨x'' ‚àà s), f' ‚ü®x', hx'‚ü© ‚â† f'' ‚ü®x'', hx''‚ü© := by
    intro x x' hx' hx'' h
    apply f''_not_mem_biUnion x' hx''
    rw [‚Üê h]
    apply f'_mem_biUnion x
  refine ‚ü®fun x => if h : x ‚àà s then f' ‚ü®x, h‚ü© else f'' ‚ü®x, h‚ü©, ?_, ?_‚ü©
  ¬∑ refine hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)
  ¬∑ intro x
    simp only [of_eq_true]
    split_ifs with h
    ¬∑ exact hsf' ‚ü®x, h‚ü©
    ¬∑ exact sdiff_subset _ _ (hsf'' ‚ü®x, h‚ü©)","error:  function expected at
  sdiff_subset ?m.41056
term has type
  ?m.41055 ‚àà ?m.41053","theorem hall_hard_inductive_step_B {n : ‚Ñï} (hn : Fintype.card Œπ = n + 1)
    (ht : ‚àÄ s : Finset Œπ, s.card ‚â§ (s.biUnion t).card)
    (ih :
      ‚àÄ {Œπ' : Type u} [Fintype Œπ'] (t' : Œπ' ‚Üí Finset Œ±),
        Fintype.card Œπ' ‚â§ n ‚Üí
          (‚àÄ s' : Finset Œπ', s'.card ‚â§ (s'.biUnion t').card) ‚Üí
            ‚àÉ f : Œπ' ‚Üí Œ±, Function.Injective f ‚àß ‚àÄ x, f x ‚àà t' x)
    (s : Finset Œπ) (hs : s.Nonempty) (hns : s ‚â† univ) (hus : s.card = (s.biUnion t).card) :
    ‚àÉ f : Œπ ‚Üí Œ±, Function.Injective f ‚àß ‚àÄ x, f x ‚àà t x ",":= by
  haveI := Classical.decEq Œπ
  rw [Nat.add_one] at hn
  have card_Œπ'_le : Fintype.card s ‚â§ n := by
    apply Nat.le_of_lt_succ
    calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card Œπ := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
  let t' : s ‚Üí Finset Œ± := fun x' => t x'
  rcases ih t' card_Œπ'_le (hall_cond_of_restrict ht) with ‚ü®f', hf', hsf'‚ü©
  set Œπ'' := (s : Set Œπ)·∂ú
  let t'' : Œπ'' ‚Üí Finset Œ± := fun a'' => t a'' \ s.biUnion t
  have card_Œπ''_le : Fintype.card Œπ'' ‚â§ n := by
    simp_rw [Œπ'', ‚Üê Nat.lt_succ_iff, ‚Üê hn, ‚Üê Finset.coe_compl, coe_sort_coe]
    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]
  rcases ih t'' card_Œπ''_le (hall_cond_of_compl hus ht) with ‚ü®f'', hf'', hsf''‚ü©
  have f'_mem_biUnion : ‚àÄ (x') (hx' : x' ‚àà s), f' ‚ü®x', hx'‚ü© ‚àà s.biUnion t := by
    intro x' hx'
    rw [mem_biUnion]
    exact ‚ü®x', hx', hsf' _‚ü©
  have f''_not_mem_biUnion : ‚àÄ (x'') (hx'' : ¬¨x'' ‚àà s), ¬¨f'' ‚ü®x'', hx''‚ü© ‚àà s.biUnion t := by
    intro x'' hx''
    have h := hsf'' ‚ü®x'', hx''‚ü©
    rw [mem_sdiff] at h
    exact h.2
  have im_disj :
      ‚àÄ (x' x'' : Œπ) (hx' : x' ‚àà s) (hx'' : ¬¨x'' ‚àà s), f' ‚ü®x', hx'‚ü© ‚â† f'' ‚ü®x'', hx''‚ü© := by
    intro x x' hx' hx'' h
    apply f''_not_mem_biUnion x' hx''
    rw [‚Üê h]
    apply f'_mem_biUnion x
  refine ‚ü®fun x => if h : x ‚àà s then f' ‚ü®x, h‚ü© else f'' ‚ü®x, h‚ü©, ?_, ?_‚ü©
  ¬∑ refine hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)
  ¬∑ intro x
    simp only [of_eq_true]
    split_ifs with h
    ¬∑ exact hsf' ‚ü®x, h‚ü©
    ¬∑ exact sdiff_subset (hsf'' ‚ü®x, h‚ü©)"
Mathlib/Topology/FiberBundle/Basic.lean,FiberBundle.exists_trivialization_Icc_subset,FiberBundle.exists_trivialization_Icc_subset,338b29638884b26649782bacab58b0ffd86541dc,":= by
  obtain ‚ü®ea, hea‚ü© : ‚àÉ ea : Trivialization F (œÄ F E), a ‚àà ea.baseSet :=
    ‚ü®trivializationAt F E a, mem_baseSet_trivializationAt F E a‚ü©
  cases' lt_or_le b a with hab hab
  ¬∑ exact ‚ü®ea, by simp [*]‚ü©
  set s : Set B := { x ‚àà Icc a b | ‚àÉ e : Trivialization F (œÄ F E), Icc a x ‚äÜ e.baseSet }
  have ha : a ‚àà s := ‚ü®left_mem_Icc.2 hab, ea, by simp [hea]‚ü©
  have sne : s.Nonempty := ‚ü®a, ha‚ü©
  have hsb : b ‚àà upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := ‚ü®b, hsb‚ü©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c ‚àà Icc a b := ‚ü®hsc.1 ha, hsc.2 hsb‚ü©
  obtain ‚ü®-, ec : Trivialization F (œÄ F E), hec : Icc a c ‚äÜ ec.baseSet‚ü© : c ‚àà s := by
    cases' hc.1.eq_or_lt with heq hlt
    ¬∑ rwa [‚Üê heq]
    refine ‚ü®hc, ?_‚ü©
    obtain ‚ü®ec, hc‚ü© : ‚àÉ ec : Trivialization F (œÄ F E), c ‚àà ec.baseSet :=
      ‚ü®trivializationAt F E c, mem_baseSet_trivializationAt F E c‚ü©
    obtain ‚ü®c', hc', hc'e‚ü© : ‚àÉ c' ‚àà Ico a c, Ioc c' c ‚äÜ ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain ‚ü®d, ‚ü®hdab, ead, had‚ü©, hd‚ü© : ‚àÉ d ‚àà s, d ‚àà Ioc c' c := hsc.exists_between hc'.2
    refine' ‚ü®ead.piecewiseLe ec d (had ‚ü®hdab.1, le_rfl‚ü©) (hc'e hd), subset_ite.2 _‚ü©
    refine' ‚ü®fun x hx => had ‚ü®hx.1.1, hx.2‚ü©, fun x hx => hc'e ‚ü®hd.1.trans (not_le.1 hx.2), hx.1.2‚ü©‚ü©
  cases' hc.2.eq_or_lt with heq hlt
  ¬∑ exact ‚ü®ec, heq ‚ñ∏ hec‚ü©
  suffices : ‚àÉ d ‚àà Ioc c b, ‚àÉ e : Trivialization F (œÄ F E), Icc a d ‚äÜ e.baseSet
  ¬∑ rcases this with  ‚ü®d, hdcb, hd‚ü© 
    exact ((hsc.1 ‚ü®‚ü®hc.1.trans hdcb.1.le, hdcb.2‚ü©, hd‚ü©).not_lt hdcb.1).elim
  obtain ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, Ico c d ‚äÜ ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec ‚ü®hc.1, le_rfl‚ü©))
  have had : Ico a d ‚äÜ ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  ¬∑ obtain ‚ü®ed, hed‚ü© : ‚àÉ ed : Trivialization F (œÄ F E), d ‚àà ed.baseSet :=
      ‚ü®trivializationAt F E d, mem_baseSet_trivializationAt F E d‚ü©
    refine' ‚ü®d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono (inter_subset_right _ _) (inter_subset_right _ _)), fun x hx => _‚ü©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr ‚ü®hed, hdcb.1‚ü©, Or.inl ‚ü®had ‚ü®hx.1, hxd‚ü©, hxd‚ü©]
  ¬∑ rw [disjoint_left] at he
    push_neg at he
    rcases he with ‚ü®d', hdd' : d' < d, hd'c‚ü©
    exact ‚ü®d', ‚ü®hd'c, hdd'.le.trans hdcb.2‚ü©, ec, (Icc_subset_Ico_right hdd').trans had‚ü©",error:  unexpected token ':'; expected term,"theorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]
    [OrderTopology B] [FiberBundle F E] (a b : B) :
    ‚àÉ e : Trivialization F (œÄ F E), Icc a b ‚äÜ e.baseSet ",":= by
  obtain ‚ü®ea, hea‚ü© : ‚àÉ ea : Trivialization F (œÄ F E), a ‚àà ea.baseSet :=
    ‚ü®trivializationAt F E a, mem_baseSet_trivializationAt F E a‚ü©
  cases' lt_or_le b a with hab hab
  ¬∑ exact ‚ü®ea, by simp [*]‚ü©
  set s : Set B := { x ‚àà Icc a b | ‚àÉ e : Trivialization F (œÄ F E), Icc a x ‚äÜ e.baseSet }
  have ha : a ‚àà s := ‚ü®left_mem_Icc.2 hab, ea, by simp [hea]‚ü©
  have sne : s.Nonempty := ‚ü®a, ha‚ü©
  have hsb : b ‚àà upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := ‚ü®b, hsb‚ü©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c ‚àà Icc a b := ‚ü®hsc.1 ha, hsc.2 hsb‚ü©
  obtain ‚ü®-, ec : Trivialization F (œÄ F E), hec : Icc a c ‚äÜ ec.baseSet‚ü© : c ‚àà s := by
    rcases hc.1.eq_or_lt with heq | hlt
    ¬∑ rwa [‚Üê heq]
    refine ‚ü®hc, ?_‚ü©
    obtain ‚ü®ec, hc‚ü© : ‚àÉ ec : Trivialization F (œÄ F E), c ‚àà ec.baseSet :=
      ‚ü®trivializationAt F E c, mem_baseSet_trivializationAt F E c‚ü©
    obtain ‚ü®c', hc', hc'e‚ü© : ‚àÉ c' ‚àà Ico a c, Ioc c' c ‚äÜ ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain ‚ü®d, ‚ü®hdab, ead, had‚ü©, hd‚ü© : ‚àÉ d ‚àà s, d ‚àà Ioc c' c := hsc.exists_between hc'.2
    refine ‚ü®ead.piecewiseLe ec d (had ‚ü®hdab.1, le_rfl‚ü©) (hc'e hd), subset_ite.2 ?_‚ü©
    exact ‚ü®fun x hx => had ‚ü®hx.1.1, hx.2‚ü©, fun x hx => hc'e ‚ü®hd.1.trans (not_le.1 hx.2), hx.1.2‚ü©‚ü©
  rcases hc.2.eq_or_lt with heq | hlt
  ¬∑ exact ‚ü®ec, heq ‚ñ∏ hec‚ü©
  rsuffices ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, ‚àÉ e : Trivialization F (œÄ F E), Icc a d ‚äÜ e.baseSet
  ¬∑ exact ((hsc.1 ‚ü®‚ü®hc.1.trans hdcb.1.le, hdcb.2‚ü©, hd‚ü©).not_lt hdcb.1).elim
  obtain ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, Ico c d ‚äÜ ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec ‚ü®hc.1, le_rfl‚ü©))
  have had : Ico a d ‚äÜ ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  ¬∑ obtain ‚ü®ed, hed‚ü© : ‚àÉ ed : Trivialization F (œÄ F E), d ‚àà ed.baseSet :=
      ‚ü®trivializationAt F E d, mem_baseSet_trivializationAt F E d‚ü©
    refine ‚ü®d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono inter_subset_right inter_subset_right), fun x hx => ?_‚ü©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr ‚ü®hed, hdcb.1‚ü©, Or.inl ‚ü®had ‚ü®hx.1, hxd‚ü©, hxd‚ü©]
  ¬∑ rw [disjoint_left] at he
    push_neg at he
    rcases he with ‚ü®d', hdd' : d' < d, hd'c‚ü©
    exact ‚ü®d', ‚ü®hd'c, hdd'.le.trans hdcb.2‚ü©, ec, (Icc_subset_Ico_right hdd').trans had‚ü©"
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow,discr_prime_pow,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne.def, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by linarith)] at this
      exact absurd (pow_eq_zero h) this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  2 * ?m.33273 / 2
case e_a.inl.intro
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp : Fact (Nat.Prime ‚Üë2)
k : ‚Ñï
inst‚úù : IsCyclotomicExtension {2 ^ (k.succ + 1)} K L
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(2 ^ (k.succ + 1))
hirr : Irreducible (cyclotomic (‚Üë(2 ^ (k.succ + 1))) K)
hk : 2 ^ (k.succ + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(2 ^ (k.succ + 1))
hp2 : 2 = 2 ‚Üí k.succ ‚â† 0
‚ä¢ (-1) ^ (2 ^ k * (2 * (2 ^ k * 2 - 1)) / 2) = (-1) ^ (2 ^ k * 2 / 2)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.34336 ‚Üí ?m.34336 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.34338
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2‚úù : p = 2 ‚Üí k ‚â† 0
hp2 : p ‚â† 2
‚ä¢ ‚Üëp ‚â† 2
warning:  `Polynomial.C_eq_nat_cast` has been deprecated, use `Polynomial.C_eq_natCast` instead
warning:  `Polynomial.C_eq_nat_cast` has been deprecated, use `Polynomial.C_eq_natCast` instead
warning:  `Polynomial.aeval_nat_cast` has been deprecated, use `Polynomial.aeval_natCast` instead
warning:  `IsPrimitiveRoot.pow_sub_one_norm_prime_pow_of_ne_zero` has been deprecated, use `IsPrimitiveRoot.norm_pow_sub_one_eq_prime_pow_of_ne_zero` instead
warning:  `IsPrimitiveRoot.pow_sub_one_norm_prime_ne_two` has been deprecated, use `IsPrimitiveRoot.norm_pow_sub_one_of_prime_ne_two` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.60645 ‚Üí ?m.60645 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.60647
case e_a.refine_1
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2 : p = 2 ‚Üí k ‚â† 0
H :
  (Algebra.norm K) ((aeval Œ∂) (derivative (cyclotomic (‚Üëp ^ (k + 1)) K))) * ‚Üë‚Üëp ^ ‚Üëp ^ k =
    ‚Üë‚Üëp ^ (‚Üëp ^ k * (k.succ * (‚Üëp - 1)).pred) * ‚Üë‚Üëp ^ ‚Üëp ^ k
hnorm : (Algebra.norm K) (Œ∂ ^ ‚Üëp ^ k - 1) = ‚Üë‚Üëp ^ ‚Üëp ^ k
this‚úù : 0 < k.succ * (‚Üëp - 1)
h : ‚Üë‚Üëp ^ ‚Üëp ^ k = 0
this : ‚Üë‚Üëp ^ (k + 1) ‚â† 0
‚ä¢ False","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ‚Ñï).Prime]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1)) : ‚Ñï) K))
    (hk : p ^ (k + 1) ‚â† 2) : discr K (hŒ∂.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : ‚Ñï).totient / 2) * p ^ ((p : ‚Ñï) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this"
Mathlib/NumberTheory/ModularForms/JacobiTheta/OneVariable.lean,norm_jacobiTheta_sub_one_le,norm_jacobiTheta_sub_one_le,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  suffices ‚Äñ‚àë' n : ‚Ñï, cexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ ‚â§
      rexp (-œÄ * œÑ.im) / (1 - rexp (-œÄ * œÑ.im)) by
    calc
      ‚ÄñjacobiTheta œÑ - 1‚Äñ = ‚Üë2 * ‚Äñ‚àë' n : ‚Ñï, cexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ := by
        rw [sub_eq_iff_eq_add'.mpr (jacobiTheta_eq_tsum_nat hœÑ), norm_mul, Complex.norm_eq_abs,
          Complex.abs_two]
      _ ‚â§ 2 * (rexp (-œÄ * œÑ.im) / (1 - rexp (-œÄ * œÑ.im))) := by gcongr
      _ = 2 / (1 - rexp (-œÄ * œÑ.im)) * rexp (-œÄ * œÑ.im) := by rw [div_mul_comm, mul_comm]
  have : ‚àÄ n : ‚Ñï, ‚Äñcexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ ‚â§ rexp (-œÄ * œÑ.im) ^ (n + 1) := by
    intro n
    simpa only [Int.cast_add, Int.cast_one] using norm_exp_mul_sq_le hœÑ (n + 1)
  have s : HasSum (fun n : ‚Ñï =>
      rexp (-œÄ * œÑ.im) ^ (n + 1)) (rexp (-œÄ * œÑ.im) / (1 - rexp (-œÄ * œÑ.im))) := by
    simp_rw [pow_succ, div_eq_mul_inv, hasSum_mul_left_iff (Real.exp_ne_zero _)]
    exact hasSum_geometric_of_lt_one (exp_pos (-œÄ * œÑ.im)).le
      (exp_lt_one_iff.mpr <| mul_neg_of_neg_of_pos (neg_lt_zero.mpr pi_pos) hœÑ)
  have aux : Summable fun n : ‚Ñï => ‚Äñcexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ :=
    .of_nonneg_of_le (fun n => norm_nonneg _) this s.summable
  exact (norm_tsum_le_tsum_norm aux).trans ((tsum_mono aux s.summable this).trans_eq s.tsum_eq)",error:  simp made no progress,"theorem norm_jacobiTheta_sub_one_le {œÑ : ‚ÑÇ} (hœÑ : 0 < im œÑ) :
    ‚ÄñjacobiTheta œÑ - 1‚Äñ ‚â§ 2 / (1 - rexp (-œÄ * œÑ.im)) * rexp (-œÄ * œÑ.im) ",":= by
  suffices ‚Äñ‚àë' n : ‚Ñï, cexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ ‚â§
      rexp (-œÄ * œÑ.im) / (1 - rexp (-œÄ * œÑ.im)) by
    calc
      ‚ÄñjacobiTheta œÑ - 1‚Äñ = ‚Üë2 * ‚Äñ‚àë' n : ‚Ñï, cexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ := by
        rw [sub_eq_iff_eq_add'.mpr (jacobiTheta_eq_tsum_nat hœÑ), norm_mul, Complex.norm_eq_abs,
          Complex.abs_two]
      _ ‚â§ 2 * (rexp (-œÄ * œÑ.im) / (1 - rexp (-œÄ * œÑ.im))) := by gcongr
      _ = 2 / (1 - rexp (-œÄ * œÑ.im)) * rexp (-œÄ * œÑ.im) := by rw [div_mul_comm, mul_comm]
  have : ‚àÄ n : ‚Ñï, ‚Äñcexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ ‚â§ rexp (-œÄ * œÑ.im) ^ (n + 1) := by
    intro n
    simpa only [Int.cast_add, Int.cast_one] using norm_exp_mul_sq_le hœÑ (n + 1)
  have s : HasSum (fun n : ‚Ñï =>
      rexp (-œÄ * œÑ.im) ^ (n + 1)) (rexp (-œÄ * œÑ.im) / (1 - rexp (-œÄ * œÑ.im))) := by
    simp_rw [pow_succ', div_eq_mul_inv, hasSum_mul_left_iff (Real.exp_ne_zero _)]
    exact hasSum_geometric_of_lt_one (exp_pos (-œÄ * œÑ.im)).le
      (exp_lt_one_iff.mpr <| mul_neg_of_neg_of_pos (neg_lt_zero.mpr pi_pos) hœÑ)
  have aux : Summable fun n : ‚Ñï => ‚Äñcexp (œÄ * I * ((n : ‚ÑÇ) + 1) ^ 2 * œÑ)‚Äñ :=
    .of_nonneg_of_le (fun n => norm_nonneg _) this s.summable
  exact (norm_tsum_le_tsum_norm aux).trans ((tsum_mono aux s.summable this).trans_eq s.tsum_eq)"
Mathlib/Analysis/InnerProductSpace/Orientation.lean,OrthonormalBasis.det_eq_neg_det_of_opposite_orientation,det_eq_neg_det_of_opposite_orientation,b011c17e9c6a01496da5c0aebc4ba8e3bb736da2,":= by
  rw [e.toBasis.det.eq_smul_basis_det f.toBasis]
  simp [e.det_to_matrix_orthonormalBasis_of_opposite_orientation f h,
    neg_one_smul ‚Ñù (M := E [Œõ^Œπ]‚Üí‚Çó[‚Ñù] ‚Ñù)]","error:  unexpected token ']‚Üí‚Çó['; expected ':' or ']'
error:  unsolved goals
E : Type u_1
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : InnerProductSpace ‚Ñù E
Œπ : Type u_2
inst‚úù¬π : Fintype Œπ
inst‚úù : DecidableEq Œπ
ne : Nonempty Œπ
e f : OrthonormalBasis Œπ ‚Ñù E
x : Orientation ‚Ñù E Œπ
h : e.toBasis.orientation ‚â† f.toBasis.orientation
‚ä¢ -1 ‚Ä¢ f.toBasis.det = -f.toBasis.det","theorem det_eq_neg_det_of_opposite_orientation (h : e.toBasis.orientation ‚â† f.toBasis.orientation) :
    e.toBasis.det = -f.toBasis.det ",":= by
  rw [e.toBasis.det.eq_smul_basis_det f.toBasis]
  simp [e.det_to_matrix_orthonormalBasis_of_opposite_orientation f h,
    neg_one_smul ‚Ñù (M := E [‚ãÄ^Œπ]‚Üí‚Çó[‚Ñù] ‚Ñù)]"
Mathlib/Data/ENat/Lattice.lean,ENat.iInf_coe_ne_top,iInf_coe_ne_top,1cf05bbe535635a753ec388621c726f879ea1a28,:=,error:  unexpected token 'lemma'; expected term,"lemma iInf_coe_ne_top : ‚®Ö i, (f i : ‚Ñï‚àû) ‚â† ‚ä§ ‚Üî Nonempty Œπ ",":= by
  rw [Ne, iInf_coe_eq_top, not_isEmpty_iff]"
Mathlib/Data/Multiset/Sections.lean,Multiset.mem_sections,mem_sections,c959b2f950b9c44268e36bcedef976356855e6fb,":= by
  induction s with
  | empty => simp
  | cons _ _ ih => simp [ih, rel_cons_left, eq_comm]","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Œ± : Type u_1
s : Multiset (Multiset Œ±)
‚ä¢ ‚àÄ {a : Multiset Œ±}, a ‚àà s.Sections ‚Üî Rel (fun s a ‚Ü¶ a ‚àà s) s a","theorem mem_sections {s : Multiset (Multiset Œ±)} :
    ‚àÄ {a}, a ‚àà Sections s ‚Üî s.Rel (fun s a => a ‚àà s) a ",":= by
  induction s using Multiset.induction_on with
  | empty => simp
  | cons _ _ ih => simp [ih, rel_cons_left, eq_comm]"
Mathlib/CategoryTheory/Limits/Shapes/CommSq.lean,CategoryTheory.IsPullback.zero_left,zero_left,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  { w := by simp
    isLimit' :=
      ‚ü®{  lift := fun s => 0
          fac := fun s => by
            simpa using
              @PullbackCone.equalizer_ext _ _ _ _ _ _ _ s _ 0 (ùüô _)
                (by simpa using (PullbackCone.condition s).symm) }‚ü© }","error:  type mismatch
  h‚úù
has type
  0 = PullbackCone.snd s ‚Üí ‚àÄ (j : WalkingCospan), 0 = s.œÄ.app j : Prop
but is expected to have type
  ‚àÄ (j : WalkingCospan), 0 = s.œÄ.app j : Prop",theorem zero_left (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) ,":=
  { w := by simp
    isLimit' :=
      ‚ü®{  lift := fun s => 0
          fac := fun s => by
            simpa [eq_iff_true_of_subsingleton] using
              @PullbackCone.equalizer_ext _ _ _ _ _ _ _ s _ 0 (ùüô _)
                (by simpa using (PullbackCone.condition s).symm) }‚ü© }"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.LiftRel.swap_lem,LiftRel.swap_lem,88f252d9ef6777980e9cb4396094e178f3ed4acb,":= by
  refine ‚ü®swap (LiftRel R), h, fun {s t} (h : LiftRel R t s) => ?_‚ü©
  rw [‚Üê LiftRelO.swap, Computation.LiftRel.swap]
  apply liftRel_dest h",error:  unknown identifier 'liftRel_dest',"theorem LiftRel.swap_lem {R : Œ± ‚Üí Œ≤ ‚Üí Prop} {s1 s2} (h : LiftRel R s1 s2) :
    LiftRel (swap R) s2 s1 ",":= by
  refine ‚ü®swap (LiftRel R), h, fun {s t} (h : LiftRel R t s) => ?_‚ü©
  rw [‚Üê LiftRelO.swap, Computation.LiftRel.swap]
  apply liftRel_destruct h"
Mathlib/Data/Rat/Cast/Defs.lean,MonoidWithZeroHom.ext_rat_on_pnat,ext_rat_on_pnat,848a6055965ceeab03ba2c4d2d0e4e0e9b07c6e6,":=
  ext_rat' <|
    FunLike.congr_fun <|
      show
        (f : ‚Ñö ‚Üí*‚ÇÄ M‚ÇÄ).comp (Int.castRingHom ‚Ñö : ‚Ñ§ ‚Üí*‚ÇÄ ‚Ñö) =
          (g : ‚Ñö ‚Üí*‚ÇÄ M‚ÇÄ).comp (Int.castRingHom ‚Ñö : ‚Ñ§ ‚Üí*‚ÇÄ ‚Ñö)
        from ext_int' (by simpa) (by simpa)",error:  unknown constant 'FunLike.congr_fun',"theorem ext_rat_on_pnat (same_on_neg_one : f (-1) = g (-1))
    (same_on_pnat : ‚àÄ n : ‚Ñï, 0 < n ‚Üí f n = g n) : f = g ",":=
  ext_rat' <|
    DFunLike.congr_fun <|
      show
        (f : ‚Ñö ‚Üí*‚ÇÄ M‚ÇÄ).comp (Int.castRingHom ‚Ñö : ‚Ñ§ ‚Üí*‚ÇÄ ‚Ñö) =
          (g : ‚Ñö ‚Üí*‚ÇÄ M‚ÇÄ).comp (Int.castRingHom ‚Ñö : ‚Ñ§ ‚Üí*‚ÇÄ ‚Ñö)
        from ext_int' (by simpa) (by simpa)"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a
  ¬∑ exact ‚ü®_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b
  ¬∑ exact ‚ü®_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine' ‚ü®g + dg, fun y => _, funext hgf‚ü©
    ¬∑ have hay : a < (g + dg) y := by
        rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
        ¬∑ refine' (lt_add_iff_pos_right _).2 _
          calc
            0 < c - g y := sub_pos.2 hac
            _ = dg y := (dga rfl).symm
        ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      refine' ‚ü®x, hxy.le, _‚ü©
      rcases le_total c (g y) with hc | hc
      ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
      ¬∑ calc
          g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
          _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine' ‚ü®g - dg, fun y => _, funext hgf‚ü©
  ¬∑ have hyb : (g - dg) y < b := by
      rcases (hgb y).eq_or_lt with (rfl | hlt)
      ¬∑ refine' (sub_lt_self_iff _).2 _
        calc
          0 < g y - c := sub_pos.2 hcb
          _ = dg y := (dgb rfl).symm
      ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
    rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
    cases' lt_or_le c (g y) with hc hc
    ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
      ¬∑ refine' ‚ü®x, xu, _, hyxu.le‚ü©
        calc
          f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
      ¬∑ have hay : a < (g - dg) y := by
          calc
            a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
            _ < g y - (b - c) := sub_lt_sub_right hc _
            _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
        rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
        exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
    ¬∑ refine' ‚ü®xl y, xu, _, hyxu.le‚ü©
      simp [dg0 (Or.inr hc), hxl]","error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/Order/WellFoundedSet.lean,Set.partiallyWellOrderedOn_union,partiallyWellOrderedOn_union,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":=
  ‚ü®fun h => ‚ü®h.mono <| subset_union_left _ _, h.mono <| subset_union_right _ _‚ü©, fun h =>
    h.1.union h.2‚ü©","error:  function expected at
  subset_union_left ?m.12246
term has type
  ?m.12245 ‚àà ?m.12243 ‚à™ ?m.12244
error:  function expected at
  subset_union_right ?m.12310
term has type
  ?m.12309 ‚àà ?m.12307 ‚à™ ?m.12308","theorem partiallyWellOrderedOn_union :
    (s ‚à™ t).PartiallyWellOrderedOn r ‚Üî s.PartiallyWellOrderedOn r ‚àß t.PartiallyWellOrderedOn r ",":=
  ‚ü®fun h => ‚ü®h.mono subset_union_left, h.mono subset_union_right‚ü©, fun h =>
    h.1.union h.2‚ü©"
Mathlib/Topology/Compactness/Compact.lean,exists_subset_nhds_of_isCompact',exists_subset_nhds_of_isCompact',71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  obtain ‚ü®W, hsubW, W_op, hWU‚ü© := exists_open_set_nhds hU
  suffices : ‚àÉ i, V i ‚äÜ W
  ¬∑ exact this.imp fun i hi => hi.trans hWU
  by_contra' H
  replace H : ‚àÄ i, (V i ‚à© W·∂ú).Nonempty := fun i => Set.inter_compl_nonempty_iff.mpr (H i)
  have : (‚ãÇ i, V i ‚à© W·∂ú).Nonempty := by
    refine'
      IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed _ (fun i j => _) H
        (fun i => (hV_cpct i).inter_right W_op.isClosed_compl) fun i =>
        (hV_closed i).inter W_op.isClosed_compl
    rcases hV i j with ‚ü®k, hki, hkj‚ü©
    refine' ‚ü®k, ‚ü®fun x => _, fun x => _‚ü©‚ü© <;> simp only [and_imp, mem_inter_iff, mem_compl_iff] <;>
      tauto
  have : ¬¨‚ãÇ i : Œπ, V i ‚äÜ W := by simpa [‚Üê iInter_inter, inter_compl_nonempty_iff]
  contradiction",error:  unexpected token ':'; expected term,"theorem exists_subset_nhds_of_isCompact' [Nonempty Œπ] {V : Œπ ‚Üí Set X}
    (hV : Directed (¬∑ ‚äá ¬∑) V) (hV_cpct : ‚àÄ i, IsCompact (V i)) (hV_closed : ‚àÄ i, IsClosed (V i))
    {U : Set X} (hU : ‚àÄ x ‚àà ‚ãÇ i, V i, U ‚àà ùìù x) : ‚àÉ i, V i ‚äÜ U ",":= by
  obtain ‚ü®W, hsubW, W_op, hWU‚ü© := exists_open_set_nhds hU
  suffices ‚àÉ i, V i ‚äÜ W from this.imp fun i hi => hi.trans hWU
  by_contra! H
  replace H : ‚àÄ i, (V i ‚à© W·∂ú).Nonempty := fun i => Set.inter_compl_nonempty_iff.mpr (H i)
  have : (‚ãÇ i, V i ‚à© W·∂ú).Nonempty := by
    refine
      IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed _ (fun i j => ?_) H
        (fun i => (hV_cpct i).inter_right W_op.isClosed_compl) fun i =>
        (hV_closed i).inter W_op.isClosed_compl
    rcases hV i j with ‚ü®k, hki, hkj‚ü©
    refine ‚ü®k, ‚ü®fun x => ?_, fun x => ?_‚ü©‚ü© <;> simp only [and_imp, mem_inter_iff, mem_compl_iff] <;>
      tauto
  have : ¬¨‚ãÇ i : Œπ, V i ‚äÜ W := by simpa [‚Üê iInter_inter, inter_compl_nonempty_iff]
  contradiction"
Mathlib/Topology/Category/Profinite/EffectiveEpi.lean,Profinite.effectiveEpiFamily_tfae,effectiveEpiFamily_tfae,120334db6bd1644200a0101ca523070340f20491,":= by
  tfae_have 2 ‚Üí 1
  ¬∑ intro
    simpa [‚Üê effectiveEpi_desc_iff_effectiveEpiFamily, (effectiveEpi_tfae (Sigma.desc œÄ)).out 0 1]
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 3 ‚Üí 2
  ¬∑ intro e
    rw [epi_iff_surjective]
    intro b
    obtain ‚ü®t, x, h‚ü© := e b
    refine ‚ü®Sigma.Œπ X t x, ?_‚ü©
    change (Sigma.Œπ X t ‚â´ Sigma.desc œÄ) x = _
    simpa using h
  tfae_have 2 ‚Üí 3
  ¬∑ intro e; rw [epi_iff_surjective] at e
    let i : ‚àê X ‚âÖ finiteCoproduct X :=
      (colimit.isColimit _).coconePointUniqueUpToIso (finiteCoproduct.isColimit _)
    intro b
    obtain ‚ü®t, rfl‚ü© := e b
    let q := i.hom t
    refine ‚ü®q.1,q.2,?_‚ü©
    have : t = i.inv (i.hom t) := show t = (i.hom ‚â´ i.inv) t by simp only [i.hom_inv_id]; rfl
    rw [this]
    show _ = (i.inv ‚â´ Sigma.desc œÄ) (i.hom t)
    suffices i.inv ‚â´ Sigma.desc œÄ = finiteCoproduct.desc X œÄ by
      rw [this]; rfl
    rw [Iso.inv_comp_eq]
    apply colimit.hom_ext
    rintro ‚ü®a‚ü©
    simp only [Discrete.functor_obj, colimit.Œπ_desc, Cofan.mk_pt, Cofan.mk_Œπ_app,
      colimit.comp_coconePointUniqueUpToIso_hom_assoc]
    ext; rfl
  tfae_finish","error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case tfae_2_to_3.intro.w.mk.w
Œ± : Type
inst‚úù : Finite Œ±
B : Profinite
X : Œ± ‚Üí Profinite
œÄ : (a : Œ±) ‚Üí X a ‚ü∂ B
tfae_2_to_1 : Epi (Sigma.desc œÄ) ‚Üí EffectiveEpiFamily X œÄ
tfae_1_to_2 : EffectiveEpiFamily X œÄ ‚Üí Epi (Sigma.desc œÄ)
tfae_3_to_2 : (‚àÄ (b : ‚ÜëB.toCompHaus.toTop), ‚àÉ a x, (œÄ a) x = b) ‚Üí Epi (Sigma.desc œÄ)
e : Function.Surjective ‚áë(Sigma.desc œÄ)
i : ‚àê X ‚âÖ finiteCoproduct X :=
  (colimit.isColimit (Discrete.functor X)).coconePointUniqueUpToIso (finiteCoproduct.isColimit X)
t : (forget Profinite).obj (‚àê X)
q : (forget Profinite).obj (finiteCoproduct X) := i.hom t
this : t = i.inv (i.hom t)
a : Œ±
x‚úù : (forget Profinite).obj (X a)
‚ä¢ (œÄ a) x‚úù = (colimit.Œπ (Discrete.functor X) { as := a } ‚â´ i.hom ‚â´ finiteCoproduct.desc X œÄ) x‚úù","theorem effectiveEpiFamily_tfae
    {Œ± : Type} [Finite Œ±] {B : Profinite.{u}}
    (X : Œ± ‚Üí Profinite.{u}) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    TFAE
    [ EffectiveEpiFamily X œÄ
    , Epi (Sigma.desc œÄ)
    , ‚àÄ b : B, ‚àÉ (a : Œ±) (x : X a), œÄ a x = b
    ] ",":= by
  tfae_have 2 ‚Üí 1
  ¬∑ intro
    simpa [‚Üê effectiveEpi_desc_iff_effectiveEpiFamily, (effectiveEpi_tfae (Sigma.desc œÄ)).out 0 1]
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 3 ‚Üî 1
  ¬∑ erw [((CompHaus.effectiveEpiFamily_tfae
      (fun a ‚Ü¶ profiniteToCompHaus.obj (X a)) (fun a ‚Ü¶ profiniteToCompHaus.map (œÄ a))).out 2 0 : )]
    exact ‚ü®fun h ‚Ü¶ profiniteToCompHaus.finite_effectiveEpiFamily_of_map _ _ h,
      fun _ ‚Ü¶ inferInstance‚ü©
  tfae_finish"
Mathlib/RingTheory/Norm.lean,Algebra.norm_eq_one_of_not_exists_basis,norm_eq_one_of_not_exists_basis,02180b5481ba753a8248c0a7c377655a5010dc6b,":= by rw [norm_apply, LinearMap.det]; split_ifs; trivial","error:  unsolved goals
case neg
R : Type u_1
S : Type u_2
T : Type u_3
inst‚úù‚Å∑ : CommRing R
inst‚úù‚Å∂ : Ring S
inst‚úù‚Åµ : Algebra R S
K : Type u_4
L : Type u_5
F : Type u_6
inst‚úù‚Å¥ : Field K
inst‚úù¬≥ : Field L
inst‚úù¬≤ : Field F
inst‚úù¬π : Algebra K L
inst‚úù : Algebra K F
Œπ : Type w
h : ¬¨‚àÉ s, Nonempty (Basis { x // x ‚àà s } R S)
x : S
h‚úù : ¬¨‚àÉ s, Nonempty (Basis { x // x ‚àà s } R S)
‚ä¢ 1 ((lmul R S) x) = 1","theorem norm_eq_one_of_not_exists_basis (h : ¬¨‚àÉ s : Finset S, Nonempty (Basis s R S)) (x : S) :
    norm R x = 1 ",":= by rw [norm_apply, LinearMap.det]; split_ifs <;> trivial"
Mathlib/RingTheory/WittVector/Isocrystal.lean,WittVector.isocrystal_classification,isocrystal_classification,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  haveI : Nontrivial V := FiniteDimensional.nontrivial_of_finrank_eq_succ h_dim
  obtain ‚ü®x, hx‚ü© : ‚àÉ x : V, x ‚â† 0 := exists_ne 0
  have : Œ¶(p, k) x ‚â† 0 := by simpa only [map_zero] using Œ¶(p, k).injective.ne hx
  obtain ‚ü®a, ha, hax‚ü© : ‚àÉ a : K(p, k), a ‚â† 0 ‚àß Œ¶(p, k) x = a ‚Ä¢ x := by
    rw [finrank_eq_one_iff_of_nonzero' x hx] at h_dim
    obtain ‚ü®a, ha‚ü© := h_dim (Œ¶(p, k) x)
    refine' ‚ü®a, _, ha.symm‚ü©
    intro ha'
    apply this
    simp only [‚Üê ha, ha', zero_smul]
  obtain ‚ü®b, hb, m, hmb‚ü© := WittVector.exists_frobenius_solution_fractionRing p ha
  replace hmb : œÜ(p, k) b * a = (p : K(p, k)) ^ m * b := by convert hmb
  use m
  let F‚ÇÄ : StandardOneDimIsocrystal p k m ‚Üí‚Çó[K(p, k)] V := LinearMap.toSpanSingleton K(p, k) V x
  let F : StandardOneDimIsocrystal p k m ‚âÉ‚Çó[K(p, k)] V := by
    refine' LinearEquiv.ofBijective F‚ÇÄ ‚ü®_, _‚ü©
    ¬∑ rw [‚Üê LinearMap.ker_eq_bot]
      exact LinearMap.ker_toSpanSingleton K(p, k) V hx
    ¬∑ rw [‚Üê LinearMap.range_eq_top]
      rw [‚Üê (finrank_eq_one_iff_of_nonzero x hx).mp h_dim]
      rw [LinearMap.span_singleton_eq_range]
  let E := (LinearEquiv.smulOfNeZero K(p, k) _ _ hb).trans F
  refine' ‚ü®‚ü®E, _‚ü©‚ü©
  simp only
  intro c
  rw [LinearEquiv.trans_apply, LinearEquiv.trans_apply, LinearEquiv.smulOfNeZero_apply,
    LinearEquiv.smulOfNeZero_apply, LinearEquiv.map_smul, LinearEquiv.map_smul]
  rw [LinearEquiv.ofBijective_apply, LinearEquiv.ofBijective_apply]
  erw [LinearMap.toSpanSingleton_apply K(p, k) V x c, LinearMap.toSpanSingleton_apply K(p, k) V x]
  simp only [hax, LinearEquiv.ofBijective_apply, LinearMap.toSpanSingleton_apply,
    LinearEquiv.map_smul‚Çõ‚Çó, StandardOneDimIsocrystal.frobenius_apply, Algebra.id.smul_eq_mul]
  simp only [‚Üê mul_smul]
  congr 1
  erw [smul_eq_mul]
  simp only [map_zpow‚ÇÄ, map_natCast]
  linear_combination œÜ(p, k) c * hmb",error:  simp made no progress,"theorem isocrystal_classification (k : Type*) [Field k] [IsAlgClosed k] [CharP k p] (V : Type*)
    [AddCommGroup V] [Isocrystal p k V] (h_dim : finrank K(p, k) V = 1) :
    ‚àÉ m : ‚Ñ§, Nonempty (StandardOneDimIsocrystal p k m ‚âÉ·∂†‚Å±[p, k] V) ",":= by
  haveI : Nontrivial V := FiniteDimensional.nontrivial_of_finrank_eq_succ h_dim
  obtain ‚ü®x, hx‚ü© : ‚àÉ x : V, x ‚â† 0 := exists_ne 0
  have : Œ¶(p, k) x ‚â† 0 := by simpa only [map_zero] using Œ¶(p, k).injective.ne hx
  obtain ‚ü®a, ha, hax‚ü© : ‚àÉ a : K(p, k), a ‚â† 0 ‚àß Œ¶(p, k) x = a ‚Ä¢ x := by
    rw [finrank_eq_one_iff_of_nonzero' x hx] at h_dim
    obtain ‚ü®a, ha‚ü© := h_dim (Œ¶(p, k) x)
    refine ‚ü®a, ?_, ha.symm‚ü©
    intro ha'
    apply this
    simp only [‚Üê ha, ha', zero_smul]
  obtain ‚ü®b, hb, m, hmb‚ü© := WittVector.exists_frobenius_solution_fractionRing p ha
  replace hmb : œÜ(p, k) b * a = (p : K(p, k)) ^ m * b := by convert hmb
  use m
  let F‚ÇÄ : StandardOneDimIsocrystal p k m ‚Üí‚Çó[K(p, k)] V := LinearMap.toSpanSingleton K(p, k) V x
  let F : StandardOneDimIsocrystal p k m ‚âÉ‚Çó[K(p, k)] V := by
    refine LinearEquiv.ofBijective F‚ÇÄ ‚ü®?_, ?_‚ü©
    ¬∑ rw [‚Üê LinearMap.ker_eq_bot]
      exact LinearMap.ker_toSpanSingleton K(p, k) V hx
    ¬∑ rw [‚Üê LinearMap.range_eq_top]
      rw [‚Üê (finrank_eq_one_iff_of_nonzero x hx).mp h_dim]
      rw [LinearMap.span_singleton_eq_range]
  refine ‚ü®‚ü®(LinearEquiv.smulOfNeZero K(p, k) _ _ hb).trans F, fun c ‚Ü¶ ?_‚ü©‚ü©
  rw [LinearEquiv.trans_apply, LinearEquiv.trans_apply, LinearEquiv.smulOfNeZero_apply,
    LinearEquiv.smulOfNeZero_apply, LinearEquiv.map_smul, LinearEquiv.map_smul]
  rw [LinearEquiv.ofBijective_apply, LinearEquiv.ofBijective_apply]
  erw [LinearMap.toSpanSingleton_apply K(p, k) V x c, LinearMap.toSpanSingleton_apply K(p, k) V x]
  simp only [hax, LinearEquiv.ofBijective_apply, LinearMap.toSpanSingleton_apply,
    LinearEquiv.map_smul‚Çõ‚Çó, StandardOneDimIsocrystal.frobenius_apply, Algebra.id.smul_eq_mul]
  simp only [‚Üê mul_smul]
  congr 1
  linear_combination œÜ(p, k) c * hmb"
Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean,IsIntegralClosure.isNoetherian,IsIntegralClosure.isNoetherian,8dba065d4a693e23ed06348923cd5effc765cb75,":= by
  haveI := Classical.decEq L
  obtain ‚ü®s, b, hb_int‚ü© := FiniteDimensional.exists_is_basis_integral A K L
  let b' := (traceForm K L).dualBasis (traceForm_nondegenerate K L) b
  letI := isNoetherian_span_of_finite A (Set.finite_range b')
  let f : C ‚Üí‚Çó[A] Submodule.span A (Set.range b') :=
    (Submodule.ofLe (IsIntegralClosure.range_le_span_dualBasis C b hb_int)).comp
      ((Algebra.linearMap C L).restrictScalars A).rangeRestrict
  refine' isNoetherian_of_ker_bot f _
  rw [LinearMap.ker_comp, Submodule.ker_ofLe, Submodule.comap_bot, LinearMap.ker_codRestrict]
  exact LinearMap.ker_eq_bot_of_injective (IsIntegralClosure.algebraMap_injective C A L)","error:  unknown constant 'Submodule.ofLe'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  LinearMap.ker (?g.comp ?f)
case intro.intro
R : Type u_1
A : Type u_2
K : Type u_3
inst‚úù¬π‚Å∏ : CommRing R
inst‚úù¬π‚Å∑ : CommRing A
inst‚úù¬π‚Å∂ : Field K
inst‚úù¬π‚Åµ : IsDomain A
inst‚úù¬π‚Å¥ : Algebra A K
inst‚úù¬π¬≥ : IsFractionRing A K
L : Type u_4
inst‚úù¬π¬≤ : Field L
C : Type u_5
inst‚úù¬π¬π : CommRing C
inst‚úù¬π‚Å∞ : Algebra K L
inst‚úù‚Åπ : Algebra A L
inst‚úù‚Å∏ : IsScalarTower A K L
inst‚úù‚Å∑ : Algebra C L
inst‚úù‚Å∂ : IsIntegralClosure C A L
inst‚úù‚Åµ : Algebra A C
inst‚úù‚Å¥ : IsScalarTower A C L
inst‚úù¬≥ : FiniteDimensional K L
inst‚úù¬≤ : IsSeparable K L
inst‚úù¬π : IsIntegrallyClosed A
inst‚úù : IsNoetherianRing A
this‚úù : DecidableEq L
s : Finset L
b : Basis { x // x ‚àà s } K L
hb_int : ‚àÄ (x : { x // x ‚àà s }), IsIntegral A (b x)
b' : Basis { x // x ‚àà s } K L := (traceForm K L).dualBasis ‚ãØ b
this : IsNoetherian A ‚Ü•(Submodule.span A (Set.range ‚áëb')) := isNoetherian_span_of_finite A (Set.finite_range ‚áëb')
f : C ‚Üí‚Çó[A] ‚Ü•(Submodule.span A (Set.range ‚áëb')) := sorryAx (C ‚Üí‚Çó[A] ‚Ü•(Submodule.span A (Set.range ‚áëb'))) true
‚ä¢ LinearMap.ker f = ‚ä•","theorem IsIntegralClosure.isNoetherian [IsIntegrallyClosed A] [IsNoetherianRing A] :
    IsNoetherian A C ",":= by
  haveI := Classical.decEq L
  obtain ‚ü®s, b, hb_int‚ü© := FiniteDimensional.exists_is_basis_integral A K L
  let b' := (traceForm K L).dualBasis (traceForm_nondegenerate K L) b
  letI := isNoetherian_span_of_finite A (Set.finite_range b')
  let f : C ‚Üí‚Çó[A] Submodule.span A (Set.range b') :=
    (Submodule.inclusion (IsIntegralClosure.range_le_span_dualBasis C b hb_int)).comp
      ((Algebra.linearMap C L).restrictScalars A).rangeRestrict
  refine isNoetherian_of_ker_bot f ?_
  rw [LinearMap.ker_comp, Submodule.ker_inclusion, Submodule.comap_bot, LinearMap.ker_codRestrict]
  exact LinearMap.ker_eq_bot_of_injective (IsIntegralClosure.algebraMap_injective C A L)"
Mathlib/Algebra/Homology/ShortComplex/Exact.lean,CategoryTheory.ShortComplex.Exact.isIso_f',isIso_f',9072ff84a0d139a344bf9eed4a00c4cd27596c79,:= by,"error:  unexpected token 'lemma'; expected '{' or tactic
error:  unsolved goals
C : Type u_1
D : Type u_2
inst‚úù‚Åµ : Category.{u_3, u_1} C
inst‚úù‚Å¥ : Category.{?u.136410, u_2} D
inst‚úù¬≥ : Preadditive C
inst‚úù¬≤ : Preadditive D
S : ShortComplex C
inst‚úù¬π : Balanced C
hS : S.Exact
h : S.LeftHomologyData
inst‚úù : Mono S.f
‚ä¢ IsIso h.f'
error:  invalid field notation, function 'CategoryTheory.ShortComplex.Exact.isIso_f'' does not have argument with type (CategoryTheory.ShortComplex.Exact ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'CategoryTheory.ShortComplex.Exact.isIso_toCycles' does not have argument with type (CategoryTheory.ShortComplex.Exact ...) that can be used, it must be explicit or implicit with a unique name
error:  unsolved goals
C : Type u_1
D : Type u_2
inst‚úù‚Åµ : Category.{?u.139220, u_1} C
inst‚úù‚Å¥ : Category.{?u.139224, u_2} D
inst‚úù¬≥ : Preadditive C
inst‚úù¬≤ : Preadditive D
S : ShortComplex C
inst‚úù¬π : Balanced C
hS : S.Exact
inst‚úù : Mono S.f
this : S.HasHomology
‚ä¢ IsLimit (KernelFork.ofŒπ S.f ‚ãØ)","lemma isIso_f' (h : S.LeftHomologyData) [Mono S.f] :
    IsIso h.f' ",":= by
  have := hS.epi_f' h
  have := mono_of_mono_fac h.f'_i
  exact isIso_of_mono_of_epi h.f'"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,66c0098b0b62ad14d9c618b402e7673658137a7e,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a
  exact ‚ü®_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b
  exact ‚ü®_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.closed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine' ‚ü®g + dg, fun y => _, funext hgf‚ü©
    ¬∑ have hay : a < (g + dg) y := by
        rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
        ¬∑ refine' (lt_add_iff_pos_right _).2 _
          calc
            0 < c - g y := sub_pos.2 hac
            _ = dg y := (dga rfl).symm
        ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      refine' ‚ü®x, hxy.le, _‚ü©
      rcases le_total c (g y) with hc | hc
      ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
      ¬∑ calc
          g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
          _ = b := by rw [hsub, add_sub_cancel'_right]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.closed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine' ‚ü®g - dg, fun y => _, funext hgf‚ü©
  ¬∑ have hyb : (g - dg) y < b := by
      rcases (hgb y).eq_or_lt with (rfl | hlt)
      ¬∑ refine' (sub_lt_self_iff _).2 _
        calc
          0 < g y - c := sub_pos.2 hcb
          _ = dg y := (dgb rfl).symm
      ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
    rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
    cases' lt_or_le c (g y) with hc hc
    ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
      ¬∑ refine' ‚ü®x, xu, _, hyxu.le‚ü©
        calc
          f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
      ¬∑ have hay : a < (g - dg) y := by
          calc
            a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
            _ < g y - (b - c) := (sub_lt_sub_right hc _)
            _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
        rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
        exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
    ¬∑ refine' ‚ü®xl y, xu, _, hyxu.le‚ü©
      simp [dg0 (Or.inr hc), hxl]","error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  invalid field 'closed_range', the environment does not contain 'ClosedEmbedding.closed_range'
  he
has type
  ClosedEmbedding e
warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
error:  invalid field 'closed_range', the environment does not contain 'ClosedEmbedding.closed_range'
  he
has type
  ClosedEmbedding e","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/Data/Finsupp/Basic.lean,Finsupp.filter_apply_neg,filter_apply_neg,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.filter_apply_neg f h",error:  unknown identifier 'DFinsupp.filter_apply_neg',theorem filter_apply_neg {a : Œ±} (h : ¬¨p a) : f.filter p a = 0 ,:= if_neg h
Mathlib/Algebra/AlgebraicCard.lean,Algebraic.cardinal_mk_lift_le_mul,cardinal_mk_lift_le_mul,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  rw [‚Üê mk_uLift, ‚Üê mk_uLift]
  choose g hg‚ÇÅ hg‚ÇÇ using fun x : { x : A | IsAlgebraic R x } => x.coe_prop
  refine' lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le g fun f => _
  rw [lift_le_aleph0, le_aleph0_iff_set_countable]
  suffices MapsTo (‚Üë) (g ‚Åª¬π' {f}) (f.rootSet A) from
    this.countable_of_injOn (Subtype.coe_injective.injOn _) (f.rootSet_finite A).countable
  rintro x (rfl : g x = f)
  exact mem_rootSet.2 ‚ü®hg‚ÇÅ x, hg‚ÇÇ x‚ü©","error:  application type mismatch
  MapsTo.countable_of_injOn this (Function.Injective.injOn Subtype.coe_injective ?m.5212)
argument
  Function.Injective.injOn Subtype.coe_injective ?m.5212
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Subtype ?m.5188‚¶Ñ, x‚ÇÇ ‚àà ?m.5210 ‚Üí ‚Üë?m.5211 = ‚Üëx‚ÇÇ ‚Üí ?m.5211 = x‚ÇÇ : Prop
but is expected to have type
  InjOn Subtype.val (g ‚Åª¬π' {f}) : Prop","theorem cardinal_mk_lift_le_mul :
    Cardinal.lift.{u} #{ x : A // IsAlgebraic R x } ‚â§ Cardinal.lift.{v} #R[X] * ‚Ñµ‚ÇÄ ",":= by
  rw [‚Üê mk_uLift, ‚Üê mk_uLift]
  choose g hg‚ÇÅ hg‚ÇÇ using fun x : { x : A | IsAlgebraic R x } => x.coe_prop
  refine lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le g fun f => ?_
  rw [lift_le_aleph0, le_aleph0_iff_set_countable]
  suffices MapsTo (‚Üë) (g ‚Åª¬π' {f}) (f.rootSet A) from
    this.countable_of_injOn Subtype.coe_injective.injOn (f.rootSet_finite A).countable
  rintro x (rfl : g x = f)
  exact mem_rootSet.2 ‚ü®hg‚ÇÅ x, hg‚ÇÇ x‚ü©"
Mathlib/Computability/Primrec.lean,Primrec.option_map,option_map,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  (option_bind hf (option_some.comp hg)).of_eq fun x => by cases f x <;> rfl","error:  application type mismatch
  option_bind hf (comp option_some hg)
argument
  comp option_some hg
has type
  Primrec fun a ‚Ü¶ some (g a.1 a.2) : Prop
but is expected to have type
  Primrec‚ÇÇ ?m.84291 : Prop","theorem option_map {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí œÉ} (hf : Primrec f) (hg : Primrec‚ÇÇ g) :
    Primrec fun a => (f a).map (g a) ",":=
  (option_bind hf (option_some.comp‚ÇÇ hg)).of_eq fun x => by cases f x <;> rfl"
Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean,WeierstrassCurve.Jacobian.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp [nonsingular_iff, equation_iff] at hP hQ
  have hPx : P x ‚â† 0 := fun h => by simp [h] at hP; simp [hP] at hP
  have hQx : Q x ‚â† 0 := fun h => by simp [h] at hQ; simp [hQ] at hQ
  have hPy : P y ‚â† 0 := fun h => by simp [h] at hP; exact hPx <| pow_eq_zero hP.left.symm
  have hQy : Q y ‚â† 0 := fun h => by simp [h] at hQ; exact hQx <| pow_eq_zero hQ.left.symm
  use Units.mk0 _ <| mul_ne_zero (div_ne_zero hPy hPx) (div_ne_zero hQx hQy)
  simp? [smul_fin3, mul_pow, div_pow] says
    simp only [Fin.isValue, Units.mk0_mul, smul_fin3, Units.val_mul, Units.val_mk0, mul_pow,
      div_pow, Matrix.cons_val_zero, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two,
      Matrix.tail_cons, mul_zero]
  congr! 2
  ¬∑ field_simp [hP.left, hQ.left]
    ring1
  ¬∑ field_simp [‚Üê hP.left, ‚Üê hQ.left]
    ring1","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ![P x, P y, P z]
R : Type u
inst‚úù¬π : CommRing R
W' : Jacobian R
F : Type v
inst‚úù : Field F
W : Jacobian F
P Q : Fin 3 ‚Üí F
hP : W.Nonsingular P
hQ : W.Nonsingular Q
hPz : P z = 0
hQz : Q z = 0
‚ä¢ P ‚âà Q","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  have hPx : IsUnit <| P x := isUnit_X_of_Z_eq_zero hP hPz
  have hPy : IsUnit <| P y := isUnit_Y_of_Z_eq_zero hP hPz
  have hQx : IsUnit <| Q x := isUnit_X_of_Z_eq_zero hQ hQz
  have hQy : IsUnit <| Q y := isUnit_Y_of_Z_eq_zero hQ hQz
  simp only [nonsingular_of_Z_eq_zero, equation_of_Z_eq_zero, hPz, hQz] at hP hQ
  use (hPy.unit / hPx.unit) * (hQx.unit / hQy.unit)
  simp only [Units.smul_def, smul_fin3, Units.val_mul, Units.val_div_eq_div_val, IsUnit.unit_spec,
    mul_pow, div_pow, hQz, mul_zero]
  conv_rhs => rw [‚Üê fin3_def P, hPz]
  congr! 2
  ¬∑ rw [hP.left, pow_succ, (hPx.pow 2).mul_div_cancel_left, hQ.left, pow_succ _ 2,
      (hQx.pow 2).div_mul_cancel_left, hQx.inv_mul_cancel_right]
  ¬∑ rw [‚Üê hP.left, pow_succ, (hPy.pow 2).mul_div_cancel_left, ‚Üê hQ.left, pow_succ _ 2,
      (hQy.pow 2).div_mul_cancel_left, hQy.inv_mul_cancel_right]"
Mathlib/Data/NNRat/Defs.lean,NNRat.mul_def,mul_def,5f71dc2104c23870830cd3dd0cd165dd6913a60b,":= by
  ext; simp [Rat.mul_def', Rat.mkRat_eq, num_coe, den_coe]","error:  unknown constant 'Rat.mul_def''
error:  unknown constant 'Rat.mkRat_eq'
error:  unsolved goals
case a
p q‚úù : ‚Ñö‚â•0
n‚ÇÅ n‚ÇÇ d‚ÇÅ d‚ÇÇ d : ‚Ñï
q r : ‚Ñö‚â•0
‚ä¢ ‚Üëq * ‚Üër = Rat.divInt (‚Üëq.num * ‚Üër.num) (‚Üëq.den * ‚Üër.den)",lemma mul_def (q r : ‚Ñö‚â•0) : q * r = divNat (q.num * r.num) (q.den * r.den) ,":= by
  ext; simp [Rat.mul_eq_mkRat, Rat.mkRat_eq_divInt, num_coe, den_coe]"
Mathlib/LinearAlgebra/Matrix/Adjugate.lean,Matrix.adjugate_subsingleton,adjugate_subsingleton,a2a634de239759586c8efc8f5eedac6d53981973,":= by
  ext i j
  simp [Subsingleton.elim i j, adjugate_apply, det_eq_elem_of_subsingleton _ i]","error:  unsolved goals
case a
m : Type u
n : Type v
Œ± : Type w
inst‚úù‚Åµ : DecidableEq n
inst‚úù‚Å¥ : Fintype n
inst‚úù¬≥ : DecidableEq m
inst‚úù¬≤ : Fintype m
inst‚úù¬π : CommRing Œ±
inst‚úù : Subsingleton n
A : Matrix n n Œ±
i j : n
‚ä¢ 1 = 1 i j",theorem adjugate_subsingleton [Subsingleton n] (A : Matrix n n Œ±) : adjugate A = 1 ,":= by
  ext i j
  simp [Subsingleton.elim i j, adjugate_apply, det_eq_elem_of_subsingleton _ i, one_apply]"
Mathlib/GroupTheory/Sylow.lean,Sylow.card_normalizer_modEq_card,card_normalizer_modEq_card,1cb1056b5a19f416d3fae3469d51eedb4f5b48cb,":= by
  let this : H.subgroupOf (normalizer H) ‚âÉ H := (subgroupOfEquivOfLe le_normalizer).toEquiv
  rw [card_eq_card_quotient_mul_card_subgroup H,
    card_eq_card_quotient_mul_card_subgroup (H.subgroupOf (normalizer H)), Fintype.card_congr this,
    hH, pow_succ']
  exact (card_quotient_normalizer_modEq_card_quotient hH).mul_right' _","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.card G
G : Type u
Œ± : Type v
Œ≤ : Type w
inst‚úù¬π : Group G
inst‚úù : Fintype G
p n : ‚Ñï
hp : Fact (Nat.Prime p)
H : Subgroup G
hH : Fintype.card ‚Ü•H = p ^ n
this : ‚Ü•(H.subgroupOf H.normalizer) ‚âÉ ‚Ü•H := (subgroupOfEquivOfLe ‚ãØ).toEquiv
‚ä¢ Fintype.card ‚Ü•H.normalizer ‚â° Fintype.card G [MOD p ^ (n + 1)]","theorem card_normalizer_modEq_card [Fintype G] {p : ‚Ñï} {n : ‚Ñï} [hp : Fact p.Prime] {H : Subgroup G}
    (hH : Fintype.card H = p ^ n) : card (normalizer H) ‚â° card G [MOD p ^ (n + 1)] ",":= by
  have : H.subgroupOf (normalizer H) ‚âÉ H := (subgroupOfEquivOfLe le_normalizer).toEquiv
  simp only [‚Üê Nat.card_eq_fintype_card] at hH ‚ä¢
  rw [card_eq_card_quotient_mul_card_subgroup H,
    card_eq_card_quotient_mul_card_subgroup (H.subgroupOf (normalizer H)), Nat.card_congr this,
    hH, pow_succ']
  simp only [Nat.card_eq_fintype_card] at hH ‚ä¢
  exact (card_quotient_normalizer_modEq_card_quotient hH).mul_right' _"
Mathlib/FieldTheory/Finite/Basic.lean,FiniteField.roots_X_pow_card_sub_X,roots_X_pow_card_sub_X,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  classical
    have aux : (X ^ q - X : K[X]) ‚â† 0 := X_pow_card_sub_X_ne_zero K Fintype.one_lt_card
    have : (roots (X ^ q - X : K[X])).toFinset = Finset.univ := by
      rw [eq_univ_iff_forall]
      intro x
      rw [Multiset.mem_toFinset, mem_roots aux, IsRoot.def, eval_sub, eval_pow, eval_X,
        sub_eq_zero, pow_card]
    rw [‚Üê this, Multiset.toFinset_val, eq_comm, Multiset.dedup_eq_self]
    apply nodup_roots
    rw [separable_def]
    convert isCoprime_one_right.neg_right (R := K[X]) using 1
    rw [derivative_sub, derivative_X, derivative_X_pow, CharP.cast_card_eq_zero K, C_0,
      zero_mul, zero_sub]","error:  unknown constant 'CharP.cast_card_eq_zero'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.127015
case h.e'_4
K : Type u_1
R : Type u_2
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Fintype K
p : ‚Ñï
inst‚úù¬π : Fact (Nat.Prime p)
inst‚úù : Algebra (ZMod p) K
aux : X ^ q - X ‚â† 0
this : (X ^ q - X).roots.toFinset = univ
‚ä¢ C ‚Üëq * X ^ (q - 1) - 1 = -1",theorem roots_X_pow_card_sub_X : roots (X ^ q - X : K[X]) = Finset.univ.val ,":= by
  classical
    have aux : (X ^ q - X : K[X]) ‚â† 0 := X_pow_card_sub_X_ne_zero K Fintype.one_lt_card
    have : (roots (X ^ q - X : K[X])).toFinset = Finset.univ := by
      rw [eq_univ_iff_forall]
      intro x
      rw [Multiset.mem_toFinset, mem_roots aux, IsRoot.def, eval_sub, eval_pow, eval_X,
        sub_eq_zero, pow_card]
    rw [‚Üê this, Multiset.toFinset_val, eq_comm, Multiset.dedup_eq_self]
    apply nodup_roots
    rw [separable_def]
    convert isCoprime_one_right.neg_right (R := K[X]) using 1
    rw [derivative_sub, derivative_X, derivative_X_pow, Nat.cast_card_eq_zero K, C_0,
      zero_mul, zero_sub]"
Mathlib/RingTheory/PowerSeries/Basic.lean,PowerSeries.coeff_zero_X_mul,coeff_zero_X_mul,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":= by
  rw [‚Üê (œÜ.commute_X s).eq, coeff_zero_mul_X]","error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.67259
R : Type u_1
inst‚úù : Semiring R
œÜ : R‚ü¶X‚üß
‚ä¢ (coeff R 0) (X * œÜ) = 0
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated",theorem coeff_zero_X_mul (œÜ : R‚ü¶X‚üß) : coeff R 0 (X * œÜ) = 0 ,:= by simp
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow,discr_prime_pow,693fd79515903b10b1d31f10dccfc49e633cf7ee,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), succ_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2
      ¬∑ rwa [Ne.def, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by linarith)] at this
      exact absurd (pow_eq_zero h) this","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case e_a.inr
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2‚úù : p = 2 ‚Üí k ‚â† 0
hp2 : ‚Üëp ‚â† 2
‚ä¢ (-1) ^ (‚Üëp ^ k * (‚Üëp - 1) * (‚Üëp ^ k * (‚Üëp - 1) - 1) / 2) = (-1) ^ (‚Üëp ^ k * (‚Üëp - 1) / 2)
error:  unsolved goals
case e_a
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2 : p = 2 ‚Üí k ‚â† 0
‚ä¢ (Algebra.norm K) ((aeval Œ∂) (derivative (cyclotomic (‚Üëp ^ (k + 1)) K))) = ‚Üë‚Üëp ^ (‚Üëp ^ k * ((‚Üëp - 1) * (k + 1) - 1))","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ‚Ñï).Prime]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1)) : ‚Ñï) K))
    (hk : p ^ (k + 1) ‚â† 2) : discr K (hŒ∂.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : ‚Ñï).totient / 2) * p ^ ((p : ‚Ñï) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this"
Mathlib/RingTheory/IntegralRestrict.lean,Algebra.intNorm_zero,Algebra.intNorm_zero,98740267311a24ae6a2fe792964006babfd6788e,":= by
  haveI : IsIntegralClosure B A (FractionRing B) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (Algebra.IsIntegral.of_finite A B)
  haveI : IsLocalization (algebraMapSubmonoid B A‚Å∞) (FractionRing B) :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
      (isAlgebraic_of_isFractionRing _ _ (Algebra.IsIntegral.of_finite A B))
  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=
    Module.Finite_of_isLocalization A B _ _ A‚Å∞
  apply (IsFractionRing.injective A (FractionRing A))
  simp only [algebraMap_intNorm_fractionRing, map_zero, norm_zero]","error:  function expected at
  IsIntegralClosure.of_isIntegrallyClosed ?m.592945 ?m.592946 ?m.592950
term has type
  IsIntegralClosure ?m.592945 ?m.592946 ?m.592950
error:  function expected at
  IsIntegralClosure.isLocalization ?m.594809 (FractionRing A) ?m.594822 ?m.594824
term has type
  IsLocalization (algebraMapSubmonoid ?m.594824 ?m.594809‚Å∞) ?m.594822",lemma Algebra.intNorm_zero : Algebra.intNorm A B 0 = 0 ,":= by
  haveI : IsIntegralClosure B A (FractionRing B) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  haveI : IsLocalization (algebraMapSubmonoid B A‚Å∞) (FractionRing B) :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=
    Module.Finite_of_isLocalization A B _ _ A‚Å∞
  apply IsFractionRing.injective A (FractionRing A)
  simp only [algebraMap_intNorm_fractionRing, map_zero, norm_zero]"
Mathlib/Algebra/Polynomial/Module/Basic.lean,PolynomialModule.eval_smul,eval_smul,c342c339a777827331257acd880fea6d441a6aa6,":= by
  apply induction_linear q
  ¬∑ rw [smul_zero, map_zero, smul_zero]
  ¬∑ intro f g e‚ÇÅ e‚ÇÇ
    rw [smul_add, map_add, e‚ÇÅ, e‚ÇÇ, map_add, smul_add]
  intro i m
  induction' p with _ _ e‚ÇÅ e‚ÇÇ
  ¬∑ rw [add_smul, map_add, Polynomial.eval_add, e‚ÇÅ, e‚ÇÇ, add_smul]
  ¬∑ rw [monomial_smul_single, eval_single, Polynomial.eval_monomial, eval_single, smul_comm, ‚Üê
      smul_smul, pow_add, mul_smul]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?r + ?s) ‚Ä¢ ?x
case hsingle.ofFinsupp
R : Type u_1
M : Type u_2
inst‚úù¬π¬≤ : CommRing R
inst‚úù¬π¬π : AddCommGroup M
inst‚úù¬π‚Å∞ : Module R M
I : Ideal R
S : Type u_3
inst‚úù‚Åπ : CommSemiring S
inst‚úù‚Å∏ : Algebra S R
inst‚úù‚Å∑ : Module S M
inst‚úù‚Å∂ : IsScalarTower S R M
R' : Type u_4
M' : Type u_5
inst‚úù‚Åµ : CommRing R'
inst‚úù‚Å¥ : AddCommGroup M'
inst‚úù¬≥ : Module R' M'
inst‚úù¬≤ : Algebra R R'
inst‚úù¬π : Module R M'
inst‚úù : IsScalarTower R R' M'
q : PolynomialModule R M
r : R
i : ‚Ñï
m : M
toFinsupp‚úù : AddMonoidAlgebra R ‚Ñï
‚ä¢ (eval r) ({ toFinsupp := toFinsupp‚úù } ‚Ä¢ (single R i) m) =
    Polynomial.eval r { toFinsupp := toFinsupp‚úù } ‚Ä¢ (eval r) ((single R i) m)
error:  no goals to be solved","theorem eval_smul (p : R[X]) (q : PolynomialModule R M) (r : R) :
    eval r (p ‚Ä¢ q) = p.eval r ‚Ä¢ eval r q ",":= by
  apply induction_linear q
  ¬∑ rw [smul_zero, map_zero, smul_zero]
  ¬∑ intro f g e‚ÇÅ e‚ÇÇ
    rw [smul_add, map_add, e‚ÇÅ, e‚ÇÇ, map_add, smul_add]
  intro i m
  induction' p using Polynomial.induction_on' with _ _ e‚ÇÅ e‚ÇÇ
  ¬∑ rw [add_smul, map_add, Polynomial.eval_add, e‚ÇÅ, e‚ÇÇ, add_smul]
  ¬∑ rw [monomial_smul_single, eval_single, Polynomial.eval_monomial, eval_single, smul_comm, ‚Üê
      smul_smul, pow_add, mul_smul]"
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow,discr_prime_pow,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne.def, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  2 * ?m.33273 / 2
case e_a.inl.intro
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp : Fact (Nat.Prime ‚Üë2)
k : ‚Ñï
inst‚úù : IsCyclotomicExtension {2 ^ (k.succ + 1)} K L
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(2 ^ (k.succ + 1))
hirr : Irreducible (cyclotomic (‚Üë(2 ^ (k.succ + 1))) K)
hk : 2 ^ (k.succ + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(2 ^ (k.succ + 1))
hp2 : 2 = 2 ‚Üí k.succ ‚â† 0
‚ä¢ (-1) ^ (2 ^ k * (2 * (2 ^ k * 2 - 1)) / 2) = (-1) ^ (2 ^ k * 2 / 2)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.34336 ‚Üí ?m.34336 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.34338
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2‚úù : p = 2 ‚Üí k ‚â† 0
hp2 : p ‚â† 2
‚ä¢ ‚Üëp ‚â† 2
warning:  `Polynomial.C_eq_nat_cast` has been deprecated, use `Polynomial.C_eq_natCast` instead
warning:  `Polynomial.C_eq_nat_cast` has been deprecated, use `Polynomial.C_eq_natCast` instead
warning:  `Polynomial.aeval_nat_cast` has been deprecated, use `Polynomial.aeval_natCast` instead
warning:  `IsPrimitiveRoot.pow_sub_one_norm_prime_pow_of_ne_zero` has been deprecated, use `IsPrimitiveRoot.norm_pow_sub_one_eq_prime_pow_of_ne_zero` instead
warning:  `IsPrimitiveRoot.pow_sub_one_norm_prime_ne_two` has been deprecated, use `IsPrimitiveRoot.norm_pow_sub_one_of_prime_ne_two` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.60645 ‚Üí ?m.60645 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.60647
case e_a.refine_1
p : ‚Ñï+
k : ‚Ñï
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
inst‚úù : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime ‚Üëp)
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))
hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1))) K)
hk : p ^ (k + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp2 : p = 2 ‚Üí k ‚â† 0
H :
  (Algebra.norm K) ((aeval Œ∂) (derivative (cyclotomic (‚Üëp ^ (k + 1)) K))) * ‚Üë‚Üëp ^ ‚Üëp ^ k =
    ‚Üë‚Üëp ^ (‚Üëp ^ k * (k.succ * (‚Üëp - 1)).pred) * ‚Üë‚Üëp ^ ‚Üëp ^ k
hnorm : (Algebra.norm K) (Œ∂ ^ ‚Üëp ^ k - 1) = ‚Üë‚Üëp ^ ‚Üëp ^ k
this‚úù : 0 < k.succ * (‚Üëp - 1)
h : ‚Üë‚Üëp ^ ‚Üëp ^ k = 0
this : ‚Üë‚Üëp ^ (k + 1) ‚â† 0
‚ä¢ False","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ‚Ñï).Prime]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1)) : ‚Ñï) K))
    (hk : p ^ (k + 1) ‚â† 2) : discr K (hŒ∂.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : ‚Ñï).totient / 2) * p ^ ((p : ‚Ñï) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this"
Mathlib/NumberTheory/LegendreSymbol/AddCharacter.lean,AddChar.exists_divisor_of_not_isPrimitive,exists_divisor_of_not_isPrimitive,cfb67dc2b69e7e3c8df320d6d887e00dd240c448,":= by
  simp_rw [IsPrimitive, not_forall, isNontrivial_iff_ne_trivial, not_ne_iff] at he
  rcases he with ‚ü®b, hb_ne, hb‚ü©
  obtain ‚ü®d, hd, u, hu, rfl‚ü© := b.eq_unit_mul_divisor
  refine ‚ü®d, hd, lt_of_le_of_ne (Nat.le_of_dvd N.pos hd) ?_, ?_‚ü©
  ¬∑ exact fun h ‚Ü¶ by simp only [h, ZMod.natCast_self, mul_zero, ne_eq, not_true_eq_false] at hb_ne
  ¬∑ rw [‚Üê mulShift_unit_eq_one_iff _ hu, ‚Üê hb, mul_comm]
    ext1 y
    rw [mulShift_apply, mulShift_apply, mulShift_apply, mul_assoc]","warning:  `AddChar.isNontrivial_iff_ne_trivial` has been deprecated, use `AddChar.ne_one_iff` instead
error:  simp made no progress","lemma exists_divisor_of_not_isPrimitive (he : ¬¨e.IsPrimitive) :
    ‚àÉ d : ‚Ñï, d ‚à£ N ‚àß d < N ‚àß e.mulShift d = 1 ",":= by
  simp_rw [IsPrimitive, not_forall, not_ne_iff] at he
  rcases he with ‚ü®b, hb_ne, hb‚ü©
  obtain ‚ü®d, hd, u, hu, rfl‚ü© := b.eq_unit_mul_divisor
  refine ‚ü®d, hd, lt_of_le_of_ne (Nat.le_of_dvd (NeZero.pos _) hd) ?_, ?_‚ü©
  ¬∑ exact fun h ‚Ü¶ by simp only [h, ZMod.natCast_self, mul_zero, ne_eq, not_true_eq_false] at hb_ne
  ¬∑ rw [‚Üê mulShift_unit_eq_one_iff _ hu, ‚Üê hb, mul_comm]
    ext1 y
    rw [mulShift_apply, mulShift_apply, mulShift_apply, mul_assoc]"
Mathlib/RingTheory/PowerSeries/Basic.lean,Polynomial.coe_inj,coe_inj,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,"  ext
  simp_rw [‚Üê coeff_coe]
  congr","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
error:  unexpected token 'variable'; expected ':=', 'where' or '|'
error:  function expected at
  Function.Injective Coe.coe
term has type
  Prop
error:  unknown identifier 'coe_injective'",theorem coe_injective : Function.Injective (Coe.coe : R[X] ‚Üí PowerSeries R) ,":= fun x y h => by
  ext
  simp_rw [‚Üê coeff_coe]
  congr"
Mathlib/RingTheory/Localization/NormTrace.lean,Algebra.trace_localization,Algebra.trace_localization,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  cases subsingleton_or_nontrivial R
  ¬∑ haveI : Subsingleton R‚Çò := Module.subsingleton R R‚Çò
    simp
  let b := Module.Free.chooseBasis R S
  letI := Classical.decEq (Module.Free.ChooseBasisIndex R S)
  rw [Algebra.trace_eq_matrix_trace (b.localizationLocalization R‚Çò M S‚Çò),
    Algebra.trace_eq_matrix_trace b, ‚Üê Algebra.map_leftMulMatrix_localization]
  exact (AddMonoidHom.map_trace (algebraMap R R‚Çò).toAddMonoidHom _).symm",error:  simp made no progress,"theorem Algebra.trace_localization [Module.Free R S] [Module.Finite R S] (a : S) :
    Algebra.trace R‚Çò S‚Çò (algebraMap S S‚Çò a) = algebraMap R R‚Çò (Algebra.trace R S a) ",":= by
  cases subsingleton_or_nontrivial R
  ¬∑ haveI : Subsingleton R‚Çò := Module.subsingleton R R‚Çò
    simp [eq_iff_true_of_subsingleton]
  let b := Module.Free.chooseBasis R S
  letI := Classical.decEq (Module.Free.ChooseBasisIndex R S)
  rw [Algebra.trace_eq_matrix_trace (b.localizationLocalization R‚Çò M S‚Çò),
    Algebra.trace_eq_matrix_trace b, ‚Üê Algebra.map_leftMulMatrix_localization]
  exact (AddMonoidHom.map_trace (algebraMap R R‚Çò).toAddMonoidHom _).symm"
Mathlib/GroupTheory/NoncommPiCoprod.lean,Subgroup.eq_one_of_noncommProd_eq_one_of_independent,eq_one_of_noncommProd_eq_one_of_independent,7fa386b9c1d5f5e8344fb34659b062d90996f3f0,":= by
  classical
    revert heq1
    induction' s with i s hnmem ih
    ¬∑ simp
    ¬∑ have hcomm := comm.mono (Finset.coe_subset.2 <| Finset.subset_insert _ _)
      simp only [Finset.forall_mem_insert] at hmem
      have hmem_bsupr : s.noncommProd f hcomm ‚àà ‚®Ü i ‚àà (s : Set Œπ), K i := by
        refine Subgroup.noncommProd_mem _ _ ?_
        intro x hx
        have : K x ‚â§ ‚®Ü i ‚àà (s : Set Œπ), K i := le_iSup‚ÇÇ (f := fun i _ => K i) x hx
        exact this (hmem.2 x hx)
      intro heq1
      rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hnmem] at heq1
      have hnmem' : i ‚àâ (s : Set Œπ) := by simpa
      obtain ‚ü®heq1i : f i = 1, heq1S : s.noncommProd f _ = 1‚ü© :=
        Subgroup.disjoint_iff_mul_eq_one.mp (hind.disjoint_biSup hnmem') hmem.1 hmem_bsupr heq1
      intro i h
      simp only [Finset.mem_insert] at h
      rcases h with (rfl | h)
      ¬∑ exact heq1i
      ¬∑ refine' ih hcomm hmem.2 heq1S _ h","error:  unsolved goals
case mk
G : Type u_1
inst‚úù : Group G
Œπ : Type u_2
f : Œπ ‚Üí G
K : Œπ ‚Üí Subgroup G
hind : CompleteLattice.Independent K
i : Multiset Œπ
s : i.Nodup
comm : (‚Üë{ val := i, nodup := s }).Pairwise fun a b ‚Ü¶ Commute (f a) (f b)
hmem : ‚àÄ x ‚àà { val := i, nodup := s }, f x ‚àà K x
‚ä¢ { val := i, nodup := s }.noncommProd f comm = 1 ‚Üí ‚àÄ i_1 ‚àà i, f i_1 = 1
error:  no goals to be solved","theorem eq_one_of_noncommProd_eq_one_of_independent {Œπ : Type*} (s : Finset Œπ) (f : Œπ ‚Üí G) (comm)
    (K : Œπ ‚Üí Subgroup G) (hind : CompleteLattice.Independent K) (hmem : ‚àÄ x ‚àà s, f x ‚àà K x)
    (heq1 : s.noncommProd f comm = 1) : ‚àÄ i ‚àà s, f i = 1 ",":= by
  classical
    revert heq1
    induction' s using Finset.induction_on with i s hnmem ih
    ¬∑ simp
    ¬∑ have hcomm := comm.mono (Finset.coe_subset.2 <| Finset.subset_insert _ _)
      simp only [Finset.forall_mem_insert] at hmem
      have hmem_bsupr : s.noncommProd f hcomm ‚àà ‚®Ü i ‚àà (s : Set Œπ), K i := by
        refine Subgroup.noncommProd_mem _ _ ?_
        intro x hx
        have : K x ‚â§ ‚®Ü i ‚àà (s : Set Œπ), K i := le_iSup‚ÇÇ (f := fun i _ => K i) x hx
        exact this (hmem.2 x hx)
      intro heq1
      rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hnmem] at heq1
      have hnmem' : i ‚àâ (s : Set Œπ) := by simpa
      obtain ‚ü®heq1i : f i = 1, heq1S : s.noncommProd f _ = 1‚ü© :=
        Subgroup.disjoint_iff_mul_eq_one.mp (hind.disjoint_biSup hnmem') hmem.1 hmem_bsupr heq1
      intro i h
      simp only [Finset.mem_insert] at h
      rcases h with (rfl | h)
      ¬∑ exact heq1i
      ¬∑ refine ih hcomm hmem.2 heq1S _ h"
Mathlib/Order/Monotone/Extension.lean,MonotoneOn.exists_monotone_extension,MonotoneOn.exists_monotone_extension,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  classical
    rcases hl with ‚ü®a, ha‚ü©
    have hu' : ‚àÄ x, BddAbove (f '' (Iic x ‚à© s)) := fun x =>
      hu.mono (image_subset _ (inter_subset_right _ _))
    let g : Œ± ‚Üí Œ≤ := fun x => if Disjoint (Iic x) s then a else sSup (f '' (Iic x ‚à© s))
    have hgs : EqOn f g s := by
      intro x hx
      simp only [g]
      have : IsGreatest (Iic x ‚à© s) x := ‚ü®‚ü®right_mem_Iic, hx‚ü©, fun y hy => hy.1‚ü©
      rw [if_neg this.nonempty.not_disjoint,
        ((h.mono <| inter_subset_right _ _).map_isGreatest this).csSup_eq]
    refine ‚ü®g, fun x y hxy => ?_, hgs‚ü©
    by_cases hx : Disjoint (Iic x) s <;> by_cases hy : Disjoint (Iic y) s <;>
      simp only [g, if_pos, if_neg, not_false_iff, *, refl]
    ¬∑ rcases not_disjoint_iff_nonempty_inter.1 hy with ‚ü®z, hz‚ü©
      exact le_csSup_of_le (hu' _) (mem_image_of_mem _ hz) (ha <| mem_image_of_mem _ hz.2)
    ¬∑ exact (hx <| hy.mono_left <| Iic_subset_Iic.2 hxy).elim
    ¬∑ rw [not_disjoint_iff_nonempty_inter] at hx hy
      refine' csSup_le_csSup (hu' _) (hx.image _) (image_subset _ _)
      exact inter_subset_inter_left _ (Iic_subset_Iic.2 hxy)","error:  function expected at
  inter_subset_right ?m.942
term has type
  ?m.941 ‚àà ?m.940
error:  function expected at
  inter_subset_right ?m.1774
term has type
  ?m.1773 ‚àà ?m.1772","theorem MonotoneOn.exists_monotone_extension (h : MonotoneOn f s) (hl : BddBelow (f '' s))
    (hu : BddAbove (f '' s)) : ‚àÉ g : Œ± ‚Üí Œ≤, Monotone g ‚àß EqOn f g s ",":= by
  classical
    rcases hl with ‚ü®a, ha‚ü©
    have hu' : ‚àÄ x, BddAbove (f '' (Iic x ‚à© s)) := fun x =>
      hu.mono (image_subset _ inter_subset_right)
    let g : Œ± ‚Üí Œ≤ := fun x => if Disjoint (Iic x) s then a else sSup (f '' (Iic x ‚à© s))
    have hgs : EqOn f g s := by
      intro x hx
      simp only [g]
      have : IsGreatest (Iic x ‚à© s) x := ‚ü®‚ü®right_mem_Iic, hx‚ü©, fun y hy => hy.1‚ü©
      rw [if_neg this.nonempty.not_disjoint,
        ((h.mono inter_subset_right).map_isGreatest this).csSup_eq]
    refine ‚ü®g, fun x y hxy => ?_, hgs‚ü©
    by_cases hx : Disjoint (Iic x) s <;> by_cases hy : Disjoint (Iic y) s <;>
      simp only [g, if_pos, if_neg, not_false_iff, *, refl]
    ¬∑ rcases not_disjoint_iff_nonempty_inter.1 hy with ‚ü®z, hz‚ü©
      exact le_csSup_of_le (hu' _) (mem_image_of_mem _ hz) (ha <| mem_image_of_mem _ hz.2)
    ¬∑ exact (hx <| hy.mono_left <| Iic_subset_Iic.2 hxy).elim
    ¬∑ rw [not_disjoint_iff_nonempty_inter] at hx hy
      refine csSup_le_csSup (hu' _) (hx.image _) (image_subset _ ?_)
      exact inter_subset_inter_left _ (Iic_subset_Iic.2 hxy)"
Mathlib/MeasureTheory/Integral/Lebesgue.lean,MeasureTheory.lintegral_le_of_forall_fin_meas_le,lintegral_le_of_forall_fin_meas_le,047f73c34cd3e6bae28166f72847965b1a989c70,":= by
  have : ‚à´‚Åª x in univ, f x ‚àÇŒº = ‚à´‚Åª x, f x ‚àÇŒº := by simp only [Measure.restrict_univ]
  rw [‚Üê this]
  refine' univ_le_of_forall_fin_meas_le hm C hf fun S hS_meas hS_mono => _
  rw [‚Üê lintegral_indicator]
  swap
  ¬∑ exact hm (‚ãÉ n, S n) (@MeasurableSet.iUnion _ _ m _ _ hS_meas)
  have h_integral_indicator : ‚®Ü n, ‚à´‚Åª x in S n, f x ‚àÇŒº = ‚®Ü n, ‚à´‚Åª x, (S n).indicator f x ‚àÇŒº := by
    congr
    ext1 n
    rw [lintegral_indicator _ (hm _ (hS_meas n))]
  rw [h_integral_indicator, ‚Üê lintegral_iSup]
  ¬∑ refine' le_of_eq (lintegral_congr fun x => _)
    simp_rw [indicator_apply]
    by_cases hx_mem : x ‚àà iUnion S
    ¬∑ simp only [hx_mem, if_true]
      obtain ‚ü®n, hxn‚ü© := mem_iUnion.mp hx_mem
      refine' le_antisymm (trans _ (le_iSup _ n)) (iSup_le fun i => _)
      ¬∑ simp only [hxn, le_refl, if_true]
      ¬∑ by_cases hxi : x ‚àà S i <;> simp [hxi]
    ¬∑ simp only [hx_mem, if_false]
      rw [mem_iUnion] at hx_mem
      push_neg at hx_mem
      refine' le_antisymm (zero_le _) (iSup_le fun n => _)
      simp only [hx_mem n, if_false, nonpos_iff_eq_zero]
  ¬∑ exact fun n => hf_meas.indicator (hm _ (hS_meas n))
  ¬∑ intro n‚ÇÅ n‚ÇÇ hn‚ÇÅ‚ÇÇ a
    simp_rw [indicator_apply]
    split_ifs with h h_1
    ¬∑ exact le_rfl
    ¬∑ exact absurd (mem_of_mem_of_subset h (hS_mono hn‚ÇÅ‚ÇÇ)) h_1
    ¬∑ exact zero_le _
    ¬∑ exact le_rfl","warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
warning:  @lintegral does not have a doc string
error:  ambiguous, possible interpretations 
  _root_.trans ?m.453226 (le_iSup (fun n ‚Ü¶ if x ‚àà S n then f x else 0) n) : f x ‚â§ ‚®Ü n, if x ‚àà S n then f x else 0
  
  Trans.trans ?m.453482 (le_iSup (fun n ‚Ü¶ if x ‚àà S n then f x else 0) n) : f x ‚â§ ‚®Ü n, if x ‚àà S n then f x else 0
error:  simp made no progress
error:  no goals to be solved","theorem lintegral_le_of_forall_fin_meas_le_of_measurable {Œº : Measure Œ±} (hm : m ‚â§ m0)
    [SigmaFinite (Œº.trim hm)] (C : ‚Ñù‚â•0‚àû) {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf_meas : Measurable f)
    (hf : ‚àÄ s, MeasurableSet[m] s ‚Üí Œº s ‚â† ‚àû ‚Üí ‚à´‚Åª x in s, f x ‚àÇŒº ‚â§ C) : ‚à´‚Åª x, f x ‚àÇŒº ‚â§ C ",":= by
  have : ‚à´‚Åª x in univ, f x ‚àÇŒº = ‚à´‚Åª x, f x ‚àÇŒº := by simp only [Measure.restrict_univ]
  rw [‚Üê this]
  refine univ_le_of_forall_fin_meas_le hm C hf fun S hS_meas hS_mono => ?_
  rw [‚Üê lintegral_indicator]
  swap
  ¬∑ exact hm (‚ãÉ n, S n) (@MeasurableSet.iUnion _ _ m _ _ hS_meas)
  have h_integral_indicator : ‚®Ü n, ‚à´‚Åª x in S n, f x ‚àÇŒº = ‚®Ü n, ‚à´‚Åª x, (S n).indicator f x ‚àÇŒº := by
    congr
    ext1 n
    rw [lintegral_indicator _ (hm _ (hS_meas n))]
  rw [h_integral_indicator, ‚Üê lintegral_iSup]
  ¬∑ refine le_of_eq (lintegral_congr fun x => ?_)
    simp_rw [indicator_apply]
    by_cases hx_mem : x ‚àà iUnion S
    ¬∑ simp only [hx_mem, if_true]
      obtain ‚ü®n, hxn‚ü© := mem_iUnion.mp hx_mem
      refine le_antisymm (_root_.trans ?_ (le_iSup _ n)) (iSup_le fun i => ?_)
      ¬∑ simp only [hxn, le_refl, if_true]
      ¬∑ by_cases hxi : x ‚àà S i <;> simp [hxi]
    ¬∑ simp only [hx_mem, if_false]
      rw [mem_iUnion] at hx_mem
      push_neg at hx_mem
      refine le_antisymm (zero_le _) (iSup_le fun n => ?_)
      simp only [hx_mem n, if_false, nonpos_iff_eq_zero]
  ¬∑ exact fun n => hf_meas.indicator (hm _ (hS_meas n))
  ¬∑ intro n‚ÇÅ n‚ÇÇ hn‚ÇÅ‚ÇÇ a
    simp_rw [indicator_apply]
    split_ifs with h h_1
    ¬∑ exact le_rfl
    ¬∑ exact absurd (mem_of_mem_of_subset h (hS_mono hn‚ÇÅ‚ÇÇ)) h_1
    ¬∑ exact zero_le _
    ¬∑ exact le_rfl"
Mathlib/Data/Rat/Cast/Defs.lean,MonoidWithZeroHom.ext_rat',ext_rat',00de3ade6a26cc42bd76ef77ae7951d738982567,":=
  (DFunLike.ext f g) fun r => by
    rw [‚Üê r.num_div_den, div_eq_mul_inv, map_mul, map_mul, h, ‚Üê Int.cast_ofNat,
      eq_on_inv‚ÇÄ f g]
    apply h","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  OfNat.ofNat ?n
F : Type u_1
Œπ : Type u_2
Œ± : Type u_3
Œ≤ : Type u_4
inst‚úù¬≥ : FunLike F Œ± Œ≤
M‚ÇÄ : Type u_5
inst‚úù¬≤ : MonoidWithZero M‚ÇÄ
inst‚úù¬π : FunLike F ‚Ñö M‚ÇÄ
inst‚úù : MonoidWithZeroHomClass F ‚Ñö M‚ÇÄ
f g : F
h : ‚àÄ (m : ‚Ñ§), f ‚Üëm = g ‚Üëm
r : ‚Ñö
‚ä¢ g ‚Üër.num * f (‚Üër.den)‚Åª¬π = g ‚Üër.num * g (‚Üër.den)‚Åª¬π","theorem ext_rat' (h : ‚àÄ m : ‚Ñ§, f m = g m) : f = g ",":=
  (DFunLike.ext f g) fun r => by
    rw [‚Üê r.num_div_den, div_eq_mul_inv, map_mul, map_mul, h, ‚Üê Int.cast_natCast,
      eq_on_inv‚ÇÄ f g]
    apply h"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,0ef23fba776dbe5bb848bbfc3337bedef4a59c82,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a
  ¬∑ exact ‚ü®_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b
  ¬∑ exact ‚ü®_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]","error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/Data/Finset/Lattice.lean,Finset.sup'_inf_distrib_left,sup'_inf_distrib_left,dee5d9343d596781e8ec7749927ce52e2d12df27,":= by
  induction hs using Finset.Nonempty.cons_induction with
  | singleton => simp
  | cons _ _ hs ih => simp_rw [sup'_cons hs, inf_sup_left, ih]","error:  application type mismatch
  sup'_cons hs
argument
  hs
has type
  a‚úù¬π ‚àâ s‚úù : Prop
but is expected to have type
  ?m.319164.Nonempty : Prop
error:  simp made no progress","theorem sup'_inf_distrib_left (f : Œπ ‚Üí Œ±) (a : Œ±) :
    a ‚äì s.sup' hs f = s.sup' hs fun i ‚Ü¶ a ‚äì f i ",":= by
  induction hs using Finset.Nonempty.cons_induction with
  | singleton => simp
  | cons _ _ _ hs ih => simp_rw [sup'_cons hs, inf_sup_left, ih]"
Mathlib/Logic/Relator.lean,Relator.rel_iff,rel_iff,b72bb8581e966b6491cee1c5638e18fae2fc11b2,:=,error:  unexpected token 'lemma'; expected term,lemma rel_iff : ((¬∑‚Üî¬∑) ‚áí (¬∑‚Üî¬∑) ‚áí (¬∑‚Üî¬∑)) (¬∑‚Üî¬∑) (¬∑‚Üî¬∑) ,":=
  fun _ _ h‚ÇÅ _ _ h‚ÇÇ => iff_congr h‚ÇÅ h‚ÇÇ"
Mathlib/Topology/Gluing.lean,TopCat.GlueData.image_inter,image_inter,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  ext x
  constructor
  ¬∑ rintro ‚ü®‚ü®x‚ÇÅ, eq‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, eq‚ÇÇ‚ü©‚ü©
    obtain ‚ü®‚ü®‚ü©‚ü© | ‚ü®y, e‚ÇÅ, -‚ü© := (D.Œπ_eq_iff_rel _ _ _ _).mp (eq‚ÇÅ.trans eq‚ÇÇ.symm)
    ¬∑ exact ‚ü®inv (D.f i i) x‚ÇÅ, by
        rw [TopCat.comp_app]
        erw [CategoryTheory.IsIso.inv_hom_id_apply]
        rw [eq‚ÇÅ]‚ü©
    ¬∑ 
      dsimp only at *
      substs eq‚ÇÅ
      exact ‚ü®y, by simp [e‚ÇÅ]‚ü©
  ¬∑ rintro ‚ü®x, hx‚ü©
    exact ‚ü®‚ü®D.f i j x, hx‚ü©, ‚ü®D.f j i (D.t _ _ x), by simp [‚Üê hx]‚ü©‚ü©","error:  unsolved goals
D : GlueData
i j : D.J
x‚úù : ‚ÜëD.glued
x : ‚Üë(D.V (i, j))
hx : (D.f i j ‚â´ D.Œπ i) x = x‚úù
‚ä¢ (D.Œπ j) ((D.f j i) ((D.t i j) x)) = (D.Œπ i) ((D.f i j) x)","theorem image_inter (i j : D.J) :
    Set.range (ùñ£.Œπ i) ‚à© Set.range (ùñ£.Œπ j) = Set.range (D.f i j ‚â´ ùñ£.Œπ _) ",":= by
  ext x
  constructor
  ¬∑ rintro ‚ü®‚ü®x‚ÇÅ, eq‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, eq‚ÇÇ‚ü©‚ü©
    obtain ‚ü®‚ü®‚ü©‚ü© | ‚ü®y, e‚ÇÅ, -‚ü© := (D.Œπ_eq_iff_rel _ _ _ _).mp (eq‚ÇÅ.trans eq‚ÇÇ.symm)
    ¬∑ exact ‚ü®inv (D.f i i) x‚ÇÅ, by
        rw [TopCat.comp_app]
        erw [CategoryTheory.IsIso.inv_hom_id_apply]
        rw [eq‚ÇÅ]‚ü©
    ¬∑ 
      dsimp only at *
      substs eq‚ÇÅ
      exact ‚ü®y, by simp [e‚ÇÅ]‚ü©
  ¬∑ rintro ‚ü®x, hx‚ü©
    refine ‚ü®‚ü®D.f i j x, hx‚ü©, ‚ü®D.f j i (D.t _ _ x), ?_‚ü©‚ü©
    erw [D.glue_condition_apply] 
    exact hx"
Mathlib/Combinatorics/SetFamily/CauchyDavenport.lean,Finset.min_le_card_mul,Finset.min_le_card_mul,75d413be2ff5a21f77a63ca465194c5159bb22d2,":= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain ‚ü®rfl, rfl‚ü© := hx
  refine' wellFoundedOn_devosMulRel.induction (P := fun x : Finset Œ± √ó Finset Œ± ‚Ü¶
    min (minOrder Œ±) ‚Üë(card x.1 + card x.2 - 1) ‚â§ card (x.1 * x.2)) ‚ü®hs, ht‚ü© _
  clear! x
  rintro ‚ü®s, t‚ü© ‚ü®hs, ht‚ü© ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  ¬∑ simpa only [‚Üê mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [‚Üê mul_inv_rev, add_comm, card_inv, true_and])
  obtain ‚ü®a, rfl‚ü© | ‚ü®a, ha, b, hb, hab‚ü© := hs.exists_eq_singleton_or_nontrivial
  ¬∑ simp [add_comm]
  obtain ‚ü®g, hg, hgs‚ü© : ‚àÉ g : Œ±, g ‚â† 1 ‚àß (s ‚à© op g ‚Ä¢ s).Nonempty :=
    ‚ü®b‚Åª¬π * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 ‚ü®ha, mem_smul_finset.2 ‚ü®_, hb, by simp‚ü©‚ü©‚ü©
  obtain hsg | hsg := eq_or_ne (op g ‚Ä¢ s) s
  ¬∑ have hS : (zpowers g : Set Œ±) ‚äÜ a‚Åª¬π ‚Ä¢ (s : Set Œ±) := by
      refine forall_mem_zpowers.2 $ @zpow_induction_right _ _ _ (¬∑ ‚àà a‚Åª¬π ‚Ä¢ (s : Set Œ±))
        ‚ü®_, ha, inv_mul_self _‚ü© (fun c hc ‚Ü¶ ?_) fun c hc ‚Ü¶ ?_
      ¬∑ rw [‚Üê hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      ¬∑ simp only
        rwa [‚Üê op_smul_eq_mul, op_inv, ‚Üê Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          ‚Üê coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [‚Üê coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s ‚à© op g ‚Ä¢ s).card < s.card := card_lt_card ‚ü®inter_subset_left _ _, fun h ‚Ü¶
    hsg <| eq_of_superset_of_card_ge (h.trans <| inter_subset_right _ _) (card_smul_finset _ _).le‚ü©
  replace aux1 := card_mono $ mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono $ mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (g‚Åª¬π ‚Ä¢ t)
  ¬∑ rw [‚Üê card_smul_finset g‚Åª¬π t]
    refine' Or.inr ((add_le_add_right hst _).trans _)
    rw [‚Üê card_union_eq hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  ¬∑ exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h ‚Ü¶ hstg.trans <| h.trans <| add_le_add_right aux1 _
  ¬∑ exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h ‚Ü¶
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _","error:  function expected at
  inter_subset_left ?m.46803
term has type
  ?m.46802 ‚àà ?m.46800
error:  function expected at
  inter_subset_right ?m.46987
term has type
  ?m.46986 ‚àà ?m.46985
warning:  `Finset.card_union_eq` has been deprecated, use `Finset.card_union_of_disjoint` instead","lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder Œ±) ‚Üë(s.card + t.card - 1) ‚â§ (s * t).card ",":= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain ‚ü®rfl, rfl‚ü© := hx
  refine wellFoundedOn_devosMulRel.induction (P := fun x : Finset Œ± √ó Finset Œ± ‚Ü¶
    min (minOrder Œ±) ‚Üë(card x.1 + card x.2 - 1) ‚â§ card (x.1 * x.2)) ‚ü®hs, ht‚ü© ?_
  clear! x
  rintro ‚ü®s, t‚ü© ‚ü®hs, ht‚ü© ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  ¬∑ simpa only [‚Üê mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [‚Üê mul_inv_rev, add_comm, card_inv, true_and])
  obtain ‚ü®a, rfl‚ü© | ‚ü®a, ha, b, hb, hab‚ü© := hs.exists_eq_singleton_or_nontrivial
  ¬∑ simp [add_comm]
  obtain ‚ü®g, hg, hgs‚ü© : ‚àÉ g : Œ±, g ‚â† 1 ‚àß (s ‚à© op g ‚Ä¢ s).Nonempty :=
    ‚ü®b‚Åª¬π * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 ‚ü®ha, mem_smul_finset.2 ‚ü®_, hb, by simp‚ü©‚ü©‚ü©
  obtain hsg | hsg := eq_or_ne (op g ‚Ä¢ s) s
  ¬∑ have hS : (zpowers g : Set Œ±) ‚äÜ a‚Åª¬π ‚Ä¢ (s : Set Œ±) := by
      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (¬∑ ‚àà a‚Åª¬π ‚Ä¢ (s : Set Œ±))
        ‚ü®_, ha, inv_mul_self _‚ü© (fun c hc ‚Ü¶ ?_) fun c hc ‚Ü¶ ?_
      ¬∑ rw [‚Üê hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      ¬∑ simp only
        rwa [‚Üê op_smul_eq_mul, op_inv, ‚Üê Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          ‚Üê coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [‚Üê coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s ‚à© op g ‚Ä¢ s).card < s.card := card_lt_card ‚ü®inter_subset_left, fun h ‚Ü¶
    hsg <| eq_of_superset_of_card_ge (h.trans inter_subset_right) (card_smul_finset _ _).le‚ü©
  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (g‚Åª¬π ‚Ä¢ t)
  ¬∑ rw [‚Üê card_smul_finset g‚Åª¬π t]
    refine Or.inr ((add_le_add_right hst _).trans ?_)
    rw [‚Üê card_union_of_disjoint hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  ¬∑ exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h ‚Ü¶ hstg.trans <| h.trans <| add_le_add_right aux1 _
  ¬∑ exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h ‚Ü¶
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _"
Mathlib/MeasureTheory/Measure/Restrict.lean,MeasureTheory.Measure.restrict_finset_biUnion_congr,restrict_finset_biUnion_congr,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
  induction' s with i s _ hs; ¬∑ simp
  simp only [forall_eq_or_imp, iUnion_iUnion_eq_or_left, Finset.mem_insert]
  rw [restrict_union_congr, ‚Üê hs]","error:  unsolved goals
case mk
R : Type u_1
Œ± : Type u_2
Œ≤ : Type u_3
Œ¥ : Type u_4
Œ≥ : Type u_5
Œπ : Type u_6
m0 : MeasurableSpace Œ±
inst‚úù¬π : MeasurableSpace Œ≤
inst‚úù : MeasurableSpace Œ≥
Œº Œº‚ÇÅ Œº‚ÇÇ Œº‚ÇÉ ŒΩ ŒΩ' ŒΩ‚ÇÅ ŒΩ‚ÇÇ : Measure Œ±
s‚úù s' t‚úù : Set Œ±
t : Œπ ‚Üí Set Œ±
i : Multiset Œπ
s : i.Nodup
‚ä¢ Œº.restrict (‚ãÉ i_1 ‚àà i, t i_1) = ŒΩ.restrict (‚ãÉ i_1 ‚àà i, t i_1) ‚Üî ‚àÄ i_1 ‚àà i, Œº.restrict (t i_1) = ŒΩ.restrict (t i_1)
error:  no goals to be solved","theorem restrict_finset_biUnion_congr {s : Finset Œπ} {t : Œπ ‚Üí Set Œ±} :
    Œº.restrict (‚ãÉ i ‚àà s, t i) = ŒΩ.restrict (‚ãÉ i ‚àà s, t i) ‚Üî
      ‚àÄ i ‚àà s, Œº.restrict (t i) = ŒΩ.restrict (t i) ",":= by
  classical
  induction' s using Finset.induction_on with i s _ hs; ¬∑ simp
  simp only [forall_eq_or_imp, iUnion_iUnion_eq_or_left, Finset.mem_insert]
  rw [restrict_union_congr, ‚Üê hs]"
Mathlib/Computability/AkraBazzi/AkraBazzi.lean,AkraBazziRecurrence.rpow_p_mul_one_add_smoothingFn_ge,rpow_p_mul_one_add_smoothingFn_ge,e3adc4f0695a3d67fb7d7efd6330f16323f31c79,":= by
  rw [Filter.eventually_all]
  intro i
  let q : ‚Ñù ‚Üí ‚Ñù := fun x => x ^ (p a b) * (1 + Œµ x)
  have h_diff_q : DifferentiableOn ‚Ñù q (Set.Ioi 1) := by
    refine DifferentiableOn.mul
        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)
        differentiableOn_one_add_smoothingFn
    rw [Set.mem_compl_singleton_iff]
    exact ne_of_gt <| zero_lt_one.trans hz
  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc
    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + Œµ z) x := by rfl
          _ =·∂†[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + Œµ x)
              + x ^ (p a b) * deriv (fun z => 1 + Œµ z) x := by
                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'
                rw [deriv_mul] <;> aesop
          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by
                refine IsBigO.add ?left ?right
                case left => calc
                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + Œµ x))
                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + Œµ x) := by
                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)
                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=
                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO
                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]
                case right => calc
                  (fun x => x ^ (p a b) * deriv (fun z => 1 + Œµ z) x)
                      =O[atTop] (fun x => x ^ (p a b) * x‚Åª¬π) := by
                        exact IsBigO.mul (isBigO_refl _ _)
                          isLittleO_deriv_one_add_smoothingFn.isBigO
                    _ =·∂†[atTop] fun x => x ^ ((p a b) - 1) := by
                        filter_upwards [eventually_gt_atTop 0] with x hx
                        rw [‚Üê Real.rpow_neg_one, ‚Üê Real.rpow_add hx, ‚Üê sub_eq_add_neg]
  have h_main_norm : (fun (n:‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ)
      ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ := by
    refine IsLittleO.eventuallyLE ?_
    calc
      (fun (n:‚Ñï) => q (r i n) - q (b i * n))
          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by
            exact R.isBigO_apply_r_sub_b q h_diff_q
              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i
        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by
            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)
        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by
            exact IsBigO.mul (IsBigO.nat_cast_atTop h_deriv_q) (isBigO_refl _ _)
        _ =·∂†[atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by
            filter_upwards [eventually_ne_atTop 0] with n hn
            have hn' : (n:‚Ñù) ‚â† 0 := by positivity
            simp [‚Üê mul_div_assoc, ‚Üê Real.rpow_add_one hn']
        _ = fun (n:‚Ñï) => (n:‚Ñù) ^ (p a b) * (1 / (log n) ^ 2)   := by simp_rw [mul_div, mul_one]
        _ =Œò[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) := by
            refine IsTheta.symm ?_
            simp_rw [mul_assoc]
            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)
            have := R.b_pos i; positivity
        _ =Œò[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)
                  <| R.isTheta_smoothingFn_sub_self i
  have h_main : (fun (n:‚Ñï) => q (b i * n) - q (r i n))
      ‚â§·∂†[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
    calc (fun (n:‚Ñï) => q (b i * n) - q (r i n))
           ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ := by
              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _
         _ ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ :=
              h_main_norm
         _ =·∂†[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
              filter_upwards [eventually_gt_atTop ‚åà(b i)‚Åª¬π‚åâ‚Çä, eventually_gt_atTop 1] with n hn hn'
              refine norm_of_nonneg ?_
              have h‚ÇÅ := R.b_pos i
              have h‚ÇÇ : 0 ‚â§ Œµ (b i * n) - Œµ n := by
                refine sub_nonneg_of_le <|
                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le
                case n_gt_one =>
                  show 1 < (n:‚Ñù)
                  rw [Nat.one_lt_cast]
                  exact hn'
                case bn_gt_one =>
                  calc 1 = b i * (b i)‚Åª¬π := by rw [mul_inv_cancel (by positivity)]
                      _ ‚â§ b i * ‚åà(b i)‚Åª¬π‚åâ‚Çä := by gcongr; exact Nat.le_ceil _
                      _ < b i * n := by gcongr; rw [Nat.cast_lt]; exact hn
                case le => calc b i * n ‚â§ 1 * n := by have := R.b_lt_one i; gcongr
                                        _ = n := by rw [one_mul]
              positivity
  filter_upwards [h_main] with n hn
  have h‚ÇÅ : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)
      = (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n) := by
    have := R.b_pos i
    simp only [mul_rpow (by positivity : (0:‚Ñù) ‚â§ b i) (by positivity : (0:‚Ñù) ‚â§ n)]
    ring
  show (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n) ‚â§ q (r i n)
  rw [‚Üê h‚ÇÅ, sub_le_iff_le_add', ‚Üê sub_le_iff_le_add]
  exact hn","warning:  `Asymptotics.IsBigO.nat_cast_atTop` has been deprecated, use `Asymptotics.IsBigO.natCast_atTop` instead
error:  simp made no progress","lemma rpow_p_mul_one_add_smoothingFn_ge :
    ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n)
      ‚â§ (r i n) ^ (p a b) * (1 + Œµ (r i n)) ",":= by
  rw [Filter.eventually_all]
  intro i
  let q : ‚Ñù ‚Üí ‚Ñù := fun x => x ^ (p a b) * (1 + Œµ x)
  have h_diff_q : DifferentiableOn ‚Ñù q (Set.Ioi 1) := by
    refine DifferentiableOn.mul
        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)
        differentiableOn_one_add_smoothingFn
    rw [Set.mem_compl_singleton_iff]
    rw [Set.mem_Ioi] at hz
    exact ne_of_gt <| zero_lt_one.trans hz
  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc
    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + Œµ z) x := by rfl
          _ =·∂†[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + Œµ x)
              + x ^ (p a b) * deriv (fun z => 1 + Œµ z) x := by
                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'
                rw [deriv_mul] <;> aesop
          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by
                refine IsBigO.add ?left ?right
                case left => calc
                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + Œµ x))
                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + Œµ x) := by
                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)
                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=
                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO
                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]
                case right => calc
                  (fun x => x ^ (p a b) * deriv (fun z => 1 + Œµ z) x)
                      =O[atTop] (fun x => x ^ (p a b) * x‚Åª¬π) := by
                        exact IsBigO.mul (isBigO_refl _ _)
                          isLittleO_deriv_one_add_smoothingFn.isBigO
                    _ =·∂†[atTop] fun x => x ^ ((p a b) - 1) := by
                        filter_upwards [eventually_gt_atTop 0] with x hx
                        rw [‚Üê Real.rpow_neg_one, ‚Üê Real.rpow_add hx, ‚Üê sub_eq_add_neg]
  have h_main_norm : (fun (n:‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ)
      ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ := by
    refine IsLittleO.eventuallyLE ?_
    calc
      (fun (n:‚Ñï) => q (r i n) - q (b i * n))
          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by
            exact R.isBigO_apply_r_sub_b q h_diff_q
              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i
        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by
            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)
        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by
            exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)
        _ =·∂†[atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by
            filter_upwards [eventually_ne_atTop 0] with n hn
            have hn' : (n:‚Ñù) ‚â† 0 := by positivity
            simp [‚Üê mul_div_assoc, ‚Üê Real.rpow_add_one hn']
        _ = fun (n:‚Ñï) => (n:‚Ñù) ^ (p a b) * (1 / (log n) ^ 2)   := by simp_rw [mul_div, mul_one]
        _ =Œò[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) := by
            refine IsTheta.symm ?_
            simp_rw [mul_assoc]
            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)
            have := R.b_pos i; positivity
        _ =Œò[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)
                  <| R.isTheta_smoothingFn_sub_self i
  have h_main : (fun (n:‚Ñï) => q (b i * n) - q (r i n))
      ‚â§·∂†[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
    calc (fun (n:‚Ñï) => q (b i * n) - q (r i n))
           ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ := by
              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _
         _ ‚â§·∂†[atTop] fun (n:‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ :=
              h_main_norm
         _ =·∂†[atTop] fun (n:‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by
              filter_upwards [eventually_gt_atTop ‚åà(b i)‚Åª¬π‚åâ‚Çä, eventually_gt_atTop 1] with n hn hn'
              refine norm_of_nonneg ?_
              have h‚ÇÅ := R.b_pos i
              have h‚ÇÇ : 0 ‚â§ Œµ (b i * n) - Œµ n := by
                refine sub_nonneg_of_le <|
                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le
                case n_gt_one =>
                  show 1 < (n:‚Ñù)
                  rw [Nat.one_lt_cast]
                  exact hn'
                case bn_gt_one =>
                  calc 1 = b i * (b i)‚Åª¬π := by rw [mul_inv_cancel (by positivity)]
                      _ ‚â§ b i * ‚åà(b i)‚Åª¬π‚åâ‚Çä := by gcongr; exact Nat.le_ceil _
                      _ < b i * n := by gcongr; rw [Nat.cast_lt]; exact hn
                case le => calc b i * n ‚â§ 1 * n := by have := R.b_lt_one i; gcongr
                                        _ = n := by rw [one_mul]
              positivity
  filter_upwards [h_main] with n hn
  have h‚ÇÅ : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)
      = (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n) := by
    have := R.b_pos i
    simp only [q, mul_rpow (by positivity : (0:‚Ñù) ‚â§ b i) (by positivity : (0:‚Ñù) ‚â§ n)]
    ring
  show (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n) ‚â§ q (r i n)
  rw [‚Üê h‚ÇÅ, sub_le_iff_le_add', ‚Üê sub_le_iff_le_add]
  exact hn"
Mathlib/Geometry/Manifold/Instances/Sphere.lean,mfderiv_coe_sphere_injective,mfderiv_coe_sphere_injective,42efba3d0573971469083f4c678037805b06c5df,":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ùïú := ‚Ñù) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices Injective (fderiv ‚Ñù ((stereoInvFunAux (-v : E) ‚àò (‚Üë)) ‚àò U.symm) 0) by
    convert this using 3 
    apply stereographic'_neg
  have : HasFDerivAt (stereoInvFunAux (-v : E) ‚àò (Subtype.val : (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ ‚Üí E))
      (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ.subtypeL (U.symm 0) := by
    simp only [coe_neg_sphere, map_zero]
    apply hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa only [coe_neg_sphere, Submodule.coe_subtypeL', Submodule.coeSubtype,
    LinearIsometryEquiv.coe_toContinuousLinearEquiv, EquivLike.injective_comp] using
    Subtype.coe_injective",error:  unknown identifier 'stereographic'_neg',"theorem mfderiv_coe_sphere_injective {n : ‚Ñï} [Fact (finrank ‚Ñù E = n + 1)] (v : sphere (0 : E) 1) :
    Injective (mfderiv (ùì° n) ùìò(‚Ñù, E) ((‚Üë) : sphere (0 : E) 1 ‚Üí E) v) ",":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ùïú := ‚Ñù) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices Injective (fderiv ‚Ñù ((stereoInvFunAux (-v : E) ‚àò (‚Üë)) ‚àò U.symm) 0) by
    convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddEquivClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have : HasFDerivAt (stereoInvFunAux (-v : E) ‚àò (Subtype.val : (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ ‚Üí E))
      (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective"
Mathlib/Topology/Perfect.lean,exists_countable_union_perfect_of_isClosed,exists_countable_union_perfect_of_isClosed,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  obtain ‚ü®b, bct, _, bbasis‚ü© := TopologicalSpace.exists_countable_basis Œ±
  let v := { U ‚àà b | (U ‚à© C).Countable }
  let V := ‚ãÉ U ‚àà v, U
  let D := C \ V
  have Vct : (V ‚à© C).Countable := by
    simp only [V, iUnion_inter, mem_sep_iff]
    apply Countable.biUnion
    ¬∑ exact Countable.mono (inter_subset_left _ _) bct
    ¬∑ exact inter_subset_right _ _
  refine ‚ü®V ‚à© C, D, Vct, ‚ü®?_, ?_‚ü©, ?_‚ü©
  ¬∑ refine hclosed.sdiff (isOpen_biUnion fun _ ‚Ü¶ ?_)
    exact fun ‚ü®Ub, _‚ü© ‚Ü¶ IsTopologicalBasis.isOpen bbasis Ub
  ¬∑ rw [preperfect_iff_nhds]
    intro x xD E xE
    have : ¬¨(E ‚à© D).Countable := by
      intro h
      obtain ‚ü®U, hUb, xU, hU‚ü© : ‚àÉ U ‚àà b, x ‚àà U ‚àß U ‚äÜ E :=
        (IsTopologicalBasis.mem_nhds_iff bbasis).mp xE
      have hU_cnt : (U ‚à© C).Countable := by
        apply @Countable.mono _ _ (E ‚à© D ‚à™ V ‚à© C)
        ¬∑ rintro y ‚ü®yU, yC‚ü©
          by_cases h : y ‚àà V
          ¬∑ exact mem_union_right _ (mem_inter h yC)
          ¬∑ exact mem_union_left _ (mem_inter (hU yU) ‚ü®yC, h‚ü©)
        exact Countable.union h Vct
      have : U ‚àà v := ‚ü®hUb, hU_cnt‚ü©
      apply xD.2
      exact mem_biUnion this xU
    by_contra! h
    exact absurd (Countable.mono h (Set.countable_singleton _)) this
  ¬∑ rw [inter_comm, inter_union_diff]","error:  function expected at
  inter_subset_left ?m.6966
term has type
  ?m.6965 ‚àà ?m.6963
error:  function expected at
  inter_subset_right ?m.7008
term has type
  ?m.7007 ‚àà ?m.7006","theorem exists_countable_union_perfect_of_isClosed [SecondCountableTopology Œ±]
    (hclosed : IsClosed C) : ‚àÉ V D : Set Œ±, V.Countable ‚àß Perfect D ‚àß C = V ‚à™ D ",":= by
  obtain ‚ü®b, bct, _, bbasis‚ü© := TopologicalSpace.exists_countable_basis Œ±
  let v := { U ‚àà b | (U ‚à© C).Countable }
  let V := ‚ãÉ U ‚àà v, U
  let D := C \ V
  have Vct : (V ‚à© C).Countable := by
    simp only [V, iUnion_inter, mem_sep_iff]
    apply Countable.biUnion
    ¬∑ exact Countable.mono inter_subset_left bct
    ¬∑ exact inter_subset_right
  refine ‚ü®V ‚à© C, D, Vct, ‚ü®?_, ?_‚ü©, ?_‚ü©
  ¬∑ refine hclosed.sdiff (isOpen_biUnion fun _ ‚Ü¶ ?_)
    exact fun ‚ü®Ub, _‚ü© ‚Ü¶ IsTopologicalBasis.isOpen bbasis Ub
  ¬∑ rw [preperfect_iff_nhds]
    intro x xD E xE
    have : ¬¨(E ‚à© D).Countable := by
      intro h
      obtain ‚ü®U, hUb, xU, hU‚ü© : ‚àÉ U ‚àà b, x ‚àà U ‚àß U ‚äÜ E :=
        (IsTopologicalBasis.mem_nhds_iff bbasis).mp xE
      have hU_cnt : (U ‚à© C).Countable := by
        apply @Countable.mono _ _ (E ‚à© D ‚à™ V ‚à© C)
        ¬∑ rintro y ‚ü®yU, yC‚ü©
          by_cases h : y ‚àà V
          ¬∑ exact mem_union_right _ (mem_inter h yC)
          ¬∑ exact mem_union_left _ (mem_inter (hU yU) ‚ü®yC, h‚ü©)
        exact Countable.union h Vct
      have : U ‚àà v := ‚ü®hUb, hU_cnt‚ü©
      apply xD.2
      exact mem_biUnion this xU
    by_contra! h
    exact absurd (Countable.mono h (Set.countable_singleton _)) this
  ¬∑ rw [inter_comm, inter_union_diff]"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.hausdorffMeasure_pi_real,hausdorffMeasure_pi_real,d14658b4fab8f69219eacfab3f0e2ad2951d7e1c,":= by
  classical
  refine'
    (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)
        (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) _).symm
  simp only [mem_iUnion, mem_singleton_iff]
  intro s hs
  choose a b H using hs
  obtain rfl : s = fun i => Ioo (Œ± := ‚Ñù) (a i) (b i)
  exact funext fun i => (H i).2
  replace H := fun i => (H i).1
  apply le_antisymm _
  ¬∑ have Hle : volume ‚â§ (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) := by
      refine' le_hausdorffMeasure _ _ ‚àû ENNReal.coe_lt_top fun s _ => _
      rw [ENNReal.rpow_nat_cast]
      exact Real.volume_pi_le_diam_pow s
    rw [‚Üê volume_pi_pi fun i => Ioo (a i : ‚Ñù) (b i)]
    exact Measure.le_iff'.1 Hle _
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := fun i => by
    simpa only [sub_nonneg, Rat.cast_le] using (H i).le
  let Œ≥ := fun n : ‚Ñï => ‚àÄ i : Œπ, Fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä
  let t : ‚àÄ n : ‚Ñï, Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f =>
    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)
  have A : Tendsto (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) atTop (ùìù 0) := by
    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]
  have B : ‚àÄ·∂† n in atTop, ‚àÄ i : Œ≥ n, diam (t n i) ‚â§ 1 / n := by
    refine' eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
    intro f
    refine' diam_pi_le_of_le fun b => _
    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel', ENNReal.ofReal_one, ENNReal.ofReal_coe_nat]
  have C : ‚àÄ·∂† n in atTop, (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ i : Œ≥ n, t n i := by
    refine' eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
    have npos : (0 : ‚Ñù) < n := Nat.cast_pos.2 hn
    intro x hx
    simp only [mem_Ioo, mem_univ_pi] at hx
    simp only [mem_iUnion, mem_Ioo, mem_univ_pi]
    let f : Œ≥ n := fun i =>
      ‚ü®‚åä(x i - a i) * n‚åã‚Çä, by
        apply Nat.floor_lt_ceil_of_lt_of_pos
        ¬∑ refine' (mul_lt_mul_right npos).2 _
          simp only [(hx i).right, sub_lt_sub_iff_right]
        ¬∑ refine' mul_pos _ npos
          simpa only [Rat.cast_lt, sub_pos] using H i‚ü©
    refine' ‚ü®f, fun i => ‚ü®_, _‚ü©‚ü©
    ¬∑ calc
        (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + (x i - a i) * n / n := by
          refine' add_le_add le_rfl ((div_le_div_right npos).2 _)
          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
        _ = x i := by field_simp [npos.ne']
    ¬∑ calc
        x i = (a i : ‚Ñù) + (x i - a i) * n / n := by field_simp [npos.ne']
        _ ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n :=
          add_le_add le_rfl ((div_le_div_right npos).2 (Nat.lt_floor_add_one _).le)
  calc
    ŒºH[Fintype.card Œπ] (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚â§
        liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, diam (t n i) ^ ((Fintype.card Œπ) : ‚Ñù)) atTop :=
      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : ‚Ñù) (b i))
        (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) A t B C
    _ ‚â§ liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, (1 / (n : ‚Ñù‚â•0‚àû)) ^ Fintype.card Œπ) atTop := by
      refine' liminf_le_liminf _ _
      ¬∑ filter_upwards [B] with _ hn
        apply Finset.sum_le_sum fun i _ => _
        simp only [ENNReal.rpow_nat_cast]
        intros i _
        exact pow_le_pow_of_le_left' (hn i) _
      ¬∑ isBoundedDefault
    _ = liminf (fun n : ‚Ñï => ‚àè i : Œπ, (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) atTop := by
      simp only [Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
    _ = ‚àè i : Œπ, volume (Ioo (a i : ‚Ñù) (b i)) := by
      simp only [Real.volume_Ioo]
      apply Tendsto.liminf_eq
      refine' ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => _) fun i _ => _
      ¬∑ apply
          Tendsto.congr' _
            ((ENNReal.continuous_ofReal.tendsto _).comp
              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_nat_cast_atTop_atTop))
        apply eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
        intros n hn
        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,
          ENNReal.ofReal_coe_nat]
      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne.def, not_false_iff]","warning:  `ENNReal.rpow_nat_cast` has been deprecated, use `ENNReal.rpow_natCast` instead
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
warning:  `ENNReal.ofReal_coe_nat` has been deprecated, use `ENNReal.ofReal_natCast` instead
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  i ‚àà univ ‚Üí x i ‚àà (fun i ‚Ü¶ Icc (‚Üë(a i) + ‚Üë‚Üë(f i) / ‚Üën) (‚Üë(a i) + (‚Üë‚Üë(f i) + 1) / ‚Üën)) i
error:  no goals to be solved
warning:  `ENNReal.rpow_nat_cast` has been deprecated, use `ENNReal.rpow_natCast` instead
warning:  `pow_le_pow_of_le_left'` has been deprecated, use `pow_le_pow_left'` instead
error:  unsolved goals
Œπ‚úù : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù‚Å∂ : EMetricSpace X
inst‚úù‚Åµ : EMetricSpace Y
inst‚úù‚Å¥ : MeasurableSpace X
inst‚úù¬≥ : BorelSpace X
inst‚úù¬≤ : MeasurableSpace Y
inst‚úù¬π : BorelSpace Y
Œπ : Type u_4
inst‚úù : Fintype Œπ
a b : Œπ ‚Üí ‚Ñö
H : ‚àÄ (i : Œπ), a i < b i
I : ‚àÄ (i : Œπ), 0 ‚â§ ‚Üë(b i) - ‚Üë(a i)
Œ≥ : ‚Ñï ‚Üí Type u_4 := fun n ‚Ü¶ (i : Œπ) ‚Üí Fin ‚åà(‚Üë(b i) - ‚Üë(a i)) * ‚Üën‚åâ‚Çä
t : (n : ‚Ñï) ‚Üí Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f ‚Ü¶ univ.pi fun i ‚Ü¶ Icc (‚Üë(a i) + ‚Üë‚Üë(f i) / ‚Üën) (‚Üë(a i) + (‚Üë‚Üë(f i) + 1) / ‚Üën)
A : Tendsto (fun n ‚Ü¶ 1 / ‚Üën) atTop (ùìù 0)
B : ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ (i : Œ≥ n), diam (t n i) ‚â§ 1 / ‚Üën
C : ‚àÄ·∂† (n : ‚Ñï) in atTop, (univ.pi fun i ‚Ü¶ Ioo ‚Üë(a i) ‚Üë(b i)) ‚äÜ ‚ãÉ i, t n i
‚ä¢ liminf (fun n ‚Ü¶ ‚Üë(Fintype.card (Œ≥ n)) * (‚Üën)‚Åª¬π ^ Fintype.card Œπ) atTop =
    liminf (fun n ‚Ü¶ (‚àè x : Œπ, ‚Üë‚åà(‚Üë(b x) - ‚Üë(a x)) * ‚Üën‚åâ‚Çä) * (‚Üën)‚Åª¬π ^ Fintype.card Œπ) atTop
warning:  `tendsto_nat_cast_atTop_atTop` has been deprecated, use `tendsto_natCast_atTop_atTop` instead
warning:  `ENNReal.ofReal_coe_nat` has been deprecated, use `ENNReal.ofReal_natCast` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.246758 ‚Üí ?m.246758 ‚Üí Prop
error:  simp made no progress","theorem hausdorffMeasure_pi_real {Œπ : Type*} [Fintype Œπ] :
    (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) = volume ",":= by
  classical
  refine (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)
    (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) ?_).symm
  simp only [mem_iUnion, mem_singleton_iff]
  intro s hs
  choose a b H using hs
  obtain rfl : s = fun i => Ioo (Œ± := ‚Ñù) (a i) (b i) := funext fun i => (H i).2
  replace H := fun i => (H i).1
  apply le_antisymm _
  ¬∑ have Hle : volume ‚â§ (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) := by
      refine le_hausdorffMeasure _ _ ‚àû ENNReal.coe_lt_top fun s _ => ?_
      rw [ENNReal.rpow_natCast]
      exact Real.volume_pi_le_diam_pow s
    rw [‚Üê volume_pi_pi fun i => Ioo (a i : ‚Ñù) (b i)]
    exact Measure.le_iff'.1 Hle _
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := fun i => by
    simpa only [sub_nonneg, Rat.cast_le] using (H i).le
  let Œ≥ := fun n : ‚Ñï => ‚àÄ i : Œπ, Fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä
  let t : ‚àÄ n : ‚Ñï, Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f =>
    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)
  have A : Tendsto (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) atTop (ùìù 0) := by
    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]
  have B : ‚àÄ·∂† n in atTop, ‚àÄ i : Œ≥ n, diam (t n i) ‚â§ 1 / n := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => ?_‚ü©
    intro f
    refine diam_pi_le_of_le fun b => ?_
    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel_left, ENNReal.ofReal_one, ENNReal.ofReal_natCast]
  have C : ‚àÄ·∂† n in atTop, (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ i : Œ≥ n, t n i := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => ?_‚ü©
    have npos : (0 : ‚Ñù) < n := Nat.cast_pos.2 hn
    intro x hx
    simp only [mem_Ioo, mem_univ_pi] at hx
    simp only [t, mem_iUnion, mem_Ioo, mem_univ_pi]
    let f : Œ≥ n := fun i =>
      ‚ü®‚åä(x i - a i) * n‚åã‚Çä, by
        apply Nat.floor_lt_ceil_of_lt_of_pos
        ¬∑ refine (mul_lt_mul_right npos).2 ?_
          simp only [(hx i).right, sub_lt_sub_iff_right]
        ¬∑ refine mul_pos ?_ npos
          simpa only [Rat.cast_lt, sub_pos] using H i‚ü©
    refine ‚ü®f, fun i => ‚ü®?_, ?_‚ü©‚ü©
    ¬∑ calc
        (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + (x i - a i) * n / n := by
          gcongr
          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
        _ = x i := by field_simp [npos.ne']
    ¬∑ calc
        x i = (a i : ‚Ñù) + (x i - a i) * n / n := by field_simp [npos.ne']
        _ ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n := by
          gcongr
          exact (Nat.lt_floor_add_one _).le
  calc
    ŒºH[Fintype.card Œπ] (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚â§
        liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, diam (t n i) ^ ((Fintype.card Œπ) : ‚Ñù)) atTop :=
      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : ‚Ñù) (b i))
        (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) A t B C
    _ ‚â§ liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, (1 / (n : ‚Ñù‚â•0‚àû)) ^ Fintype.card Œπ) atTop := by
      refine liminf_le_liminf ?_ ?_
      ¬∑ filter_upwards [B] with _ hn
        apply Finset.sum_le_sum fun i _ => _
        simp only [ENNReal.rpow_natCast]
        intros i _
        exact pow_le_pow_left' (hn i) _
      ¬∑ isBoundedDefault
    _ = liminf (fun n : ‚Ñï => ‚àè i : Œπ, (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) atTop := by
      simp only [Œ≥, Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
    _ = ‚àè i : Œπ, volume (Ioo (a i : ‚Ñù) (b i)) := by
      simp only [Real.volume_Ioo]
      apply Tendsto.liminf_eq
      refine ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => ?_) fun i _ => ?_
      ¬∑ apply
          Tendsto.congr' _
            ((ENNReal.continuous_ofReal.tendsto _).comp
              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_natCast_atTop_atTop))
        apply eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
        intros n hn
        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,
          ENNReal.ofReal_natCast]
      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne, not_false_iff]"
Mathlib/Algebra/ContinuedFractions/Translations.lean,GeneralizedContinuedFraction.exists_s_b_of_part_denom,exists_s_b_of_part_denom,4a1a4df5d2de33446f5d3ea705eb21ecb9ea4f3e,":= by
  simpa [partialDenominators, Seq'.map_get?] using nth_part_denom_eq",error:  unknown identifier 'Seq'.map_get?',"theorem exists_s_b_of_part_denom {b : Œ±}
    (nth_part_denom_eq : g.partialDenominators.get? n = some b) :
    ‚àÉ gp, g.s.get? n = some gp ‚àß gp.b = b ",":= by
  simpa [partialDenominators, Stream'.Seq.map_get?] using nth_part_denom_eq"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.think_append,think_append,938069ac7c83a4980c46ca108d9947ab788c12ee,":=
  Seq'.cons_append _ _ _",error:  unknown identifier 'Seq'.cons_append',theorem think_append (s t : WSeq Œ±) : append (think s) t = think (append s t) ,":=
  Seq.cons_append _ _ _"
Mathlib/RingTheory/IntegralRestrict.lean,Algebra.intNorm_zero,Algebra.intNorm_zero,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  haveI : IsIntegralClosure B A (FractionRing B) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (Algebra.IsIntegral.of_finite A B)
  haveI : IsLocalization (algebraMapSubmonoid B A‚Å∞) (FractionRing B) :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
      (isAlgebraic_of_isFractionRing _ _ (Algebra.IsIntegral.of_finite A B))
  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=
    Module.Finite_of_isLocalization A B _ _ A‚Å∞
  apply IsFractionRing.injective A (FractionRing A)
  simp only [algebraMap_intNorm_fractionRing, map_zero, norm_zero]","error:  function expected at
  IsIntegralClosure.of_isIntegrallyClosed ?m.592945 ?m.592946 ?m.592950
term has type
  IsIntegralClosure ?m.592945 ?m.592946 ?m.592950
error:  function expected at
  IsIntegralClosure.isLocalization ?m.594809 (FractionRing A) ?m.594822 ?m.594824
term has type
  IsLocalization (algebraMapSubmonoid ?m.594824 ?m.594809‚Å∞) ?m.594822",lemma Algebra.intNorm_zero : Algebra.intNorm A B 0 = 0 ,":= by
  haveI : IsIntegralClosure B A (FractionRing B) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  haveI : IsLocalization (algebraMapSubmonoid B A‚Å∞) (FractionRing B) :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  haveI : FiniteDimensional (FractionRing A) (FractionRing B) :=
    Module.Finite_of_isLocalization A B _ _ A‚Å∞
  apply IsFractionRing.injective A (FractionRing A)
  simp only [algebraMap_intNorm_fractionRing, map_zero, norm_zero]"
Mathlib/Data/List/Cycle.lean,List.next_ne_head_ne_getLast,next_ne_head_ne_getLast,5facde50581cefe36eb491a50b05917b86b8b861,":= by
  rw [next, next, nextOr_cons_of_ne _ _ _ _ hy, nextOr_eq_nextOr_of_mem_of_ne]
  ¬∑ rwa [getLast_cons] at hx
  ¬∑ rwa [getLast_cons] at hx
    exact ne_nil_of_mem (by assumption)","error:  unsolved goals
case x_mem
Œ± : Type u_1
inst‚úù : DecidableEq Œ±
l : List Œ±
x : Œ±
h‚úù : x ‚àà l
y : Œ±
h : x ‚àà y :: l
hy : x ‚â† y
hx : x ‚â† (y :: l).getLast ‚ãØ
‚ä¢ l ‚â† []
error:  no goals to be solved
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead","theorem next_ne_head_ne_getLast (h : x ‚àà l) (y : Œ±) (h : x ‚àà y :: l) (hy : x ‚â† y)
    (hx : x ‚â† getLast (y :: l) (cons_ne_nil _ _)) :
    next (y :: l) x h = next l x (by simpa [hy] using h) ",":= by
  rw [next, next, nextOr_cons_of_ne _ _ _ _ hy, nextOr_eq_nextOr_of_mem_of_ne]
  ¬∑ rwa [getLast_cons] at hx
    exact ne_nil_of_mem (by assumption)
  ¬∑ rwa [getLast_cons] at hx"
Mathlib/Topology/Perfect.lean,exists_countable_union_perfect_of_isClosed,exists_countable_union_perfect_of_isClosed,52752d07e2044877cdc88db106f22ffbb1eec3fa,":= by
  obtain ‚ü®b, bct, _, bbasis‚ü© := TopologicalSpace.exists_countable_basis Œ±
  let v := { U ‚àà b | (U ‚à© C).Countable }
  let V := ‚ãÉ U ‚àà v, U
  let D := C \ V
  have Vct : (V ‚à© C).Countable := by
    simp only [V, iUnion_inter, mem_sep_iff]
    apply Countable.biUnion
    ¬∑ exact Countable.mono (inter_subset_left _ _) bct
    ¬∑ exact inter_subset_right _ _
  refine' ‚ü®V ‚à© C, D, Vct, ‚ü®_, _‚ü©, _‚ü©
  ¬∑ refine' hclosed.sdiff (isOpen_biUnion fun _ ‚Ü¶ _)
    exact fun ‚ü®Ub, _‚ü© ‚Ü¶ IsTopologicalBasis.isOpen bbasis Ub
  ¬∑ rw [preperfect_iff_nhds]
    intro x xD E xE
    have : ¬¨(E ‚à© D).Countable := by
      intro h
      obtain ‚ü®U, hUb, xU, hU‚ü© : ‚àÉ U ‚àà b, x ‚àà U ‚àß U ‚äÜ E :=
        (IsTopologicalBasis.mem_nhds_iff bbasis).mp xE
      have hU_cnt : (U ‚à© C).Countable := by
        apply @Countable.mono _ _ (E ‚à© D ‚à™ V ‚à© C)
        ¬∑ rintro y ‚ü®yU, yC‚ü©
          by_cases h : y ‚àà V
          ¬∑ exact mem_union_right _ (mem_inter h yC)
          ¬∑ exact mem_union_left _ (mem_inter (hU yU) ‚ü®yC, h‚ü©)
        exact Countable.union h Vct
      have : U ‚àà v := ‚ü®hUb, hU_cnt‚ü©
      apply xD.2
      exact mem_biUnion this xU
    by_contra! h
    exact absurd (Countable.mono h (Set.countable_singleton _)) this
  ¬∑ rw [inter_comm, inter_union_diff]","error:  function expected at
  inter_subset_left ?m.6966
term has type
  ?m.6965 ‚àà ?m.6963
error:  function expected at
  inter_subset_right ?m.7008
term has type
  ?m.7007 ‚àà ?m.7006","theorem exists_countable_union_perfect_of_isClosed [SecondCountableTopology Œ±]
    (hclosed : IsClosed C) : ‚àÉ V D : Set Œ±, V.Countable ‚àß Perfect D ‚àß C = V ‚à™ D ",":= by
  obtain ‚ü®b, bct, _, bbasis‚ü© := TopologicalSpace.exists_countable_basis Œ±
  let v := { U ‚àà b | (U ‚à© C).Countable }
  let V := ‚ãÉ U ‚àà v, U
  let D := C \ V
  have Vct : (V ‚à© C).Countable := by
    simp only [V, iUnion_inter, mem_sep_iff]
    apply Countable.biUnion
    ¬∑ exact Countable.mono inter_subset_left bct
    ¬∑ exact inter_subset_right
  refine ‚ü®V ‚à© C, D, Vct, ‚ü®?_, ?_‚ü©, ?_‚ü©
  ¬∑ refine hclosed.sdiff (isOpen_biUnion fun _ ‚Ü¶ ?_)
    exact fun ‚ü®Ub, _‚ü© ‚Ü¶ IsTopologicalBasis.isOpen bbasis Ub
  ¬∑ rw [preperfect_iff_nhds]
    intro x xD E xE
    have : ¬¨(E ‚à© D).Countable := by
      intro h
      obtain ‚ü®U, hUb, xU, hU‚ü© : ‚àÉ U ‚àà b, x ‚àà U ‚àß U ‚äÜ E :=
        (IsTopologicalBasis.mem_nhds_iff bbasis).mp xE
      have hU_cnt : (U ‚à© C).Countable := by
        apply @Countable.mono _ _ (E ‚à© D ‚à™ V ‚à© C)
        ¬∑ rintro y ‚ü®yU, yC‚ü©
          by_cases h : y ‚àà V
          ¬∑ exact mem_union_right _ (mem_inter h yC)
          ¬∑ exact mem_union_left _ (mem_inter (hU yU) ‚ü®yC, h‚ü©)
        exact Countable.union h Vct
      have : U ‚àà v := ‚ü®hUb, hU_cnt‚ü©
      apply xD.2
      exact mem_biUnion this xU
    by_contra! h
    exact absurd (Countable.mono h (Set.countable_singleton _)) this
  ¬∑ rw [inter_comm, inter_union_diff]"
Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean,Real.smul_map_diagonal_volume_pi,smul_map_diagonal_volume_pi,fb705518d5c3f45a616388ce3b8f50f170e4fd60,":= by
  refine' (Measure.pi_eq fun s hs => _).symm
  simp only [det_diagonal, Measure.coe_smul, Algebra.id.smul_eq_mul, Pi.smul_apply]
  rw [Measure.map_apply _ (MeasurableSet.univ_pi hs)]
  swap; ¬∑ exact Continuous.measurable (LinearMap.continuous_on_pi _)
  have :
    (Matrix.toLin' (diagonal D) ‚Åª¬π' Set.pi fun i : Œπ => s i) =
      Set.pi fun i : Œπ => (D i * ¬∑) ‚Åª¬π' s i := by
    ext f
    simp only [LinearMap.coe_proj, Algebra.id.smul_eq_mul, LinearMap.smul_apply, mem_univ_pi,
      mem_preimage, LinearMap.pi_apply, diagonal_toLin']
  have B : ‚àÄ i, ofReal (abs (D i)) * volume ((D i * ¬∑) ‚Åª¬π' s i) = volume (s i) := by
    intro i
    have A : D i ‚â† 0 := by
      simp only [det_diagonal, Ne.def] at h
      exact Finset.prod_ne_zero_iff.1 h i (Finset.mem_univ i)
    rw [volume_preimage_mul_left A, ‚Üê mul_assoc, ‚Üê ENNReal.ofReal_mul (abs_nonneg _), ‚Üê abs_mul,
      mul_inv_cancel A, abs_one, ENNReal.ofReal_one, one_mul]
  rw [this, volume_pi_pi, Finset.abs_prod,
    ENNReal.ofReal_prod_of_nonneg fun i _ => abs_nonneg (D i), ‚Üê Finset.prod_mul_distrib]
  simp only [B]","error:  type mismatch
  s i
has type
  Set ‚Ñù : Type
but is expected to have type
  Prop : Type
error:  type mismatch
  (fun x ‚Ü¶ D i * x) ‚Åª¬π' s i
has type
  Set ‚Ñù : Type
but is expected to have type
  Prop : Type
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.134963 ‚Üí ?m.134963 ‚Üí Prop
error:  invalid occurrence of universe level 'u_2' at 'Real.map_matrix_volume_pi_eq_smul_volume_pi', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  smul_map_diagonal_volume_pi.{u_1, u_2} hD
at declaration body
  fun {Œπ : Type u_1} [inst : Fintype Œπ] [inst_1 : DecidableEq Œπ] {M : Matrix Œπ Œπ ‚Ñù} (hM : M.det ‚â† 0) ‚Ü¶
    diagonal_transvection_induction_of_det_ne_zero
      (fun {M : Matrix Œπ Œπ ‚Ñù} ‚Ü¶ Measure.map (‚áë(toLin' M)) volume = ofReal |M.det‚Åª¬π| ‚Ä¢ volume) M hM
      (fun (D : Œπ ‚Üí ‚Ñù) (hD : (Matrix.diagonal D).det ‚â† 0) ‚Ü¶
        Eq.mpr
          (id
            ((fun {Œ± : Type u_1} (a a_1 : Œ±) (e_a : a = a_1) ‚Ü¶
                Eq.rec (motive := fun (a_2 : Œ±) (e_a : a = a_2) ‚Ü¶ ‚àÄ (a_3 a_4 : Œ±), a_3 = a_4 ‚Üí (a = a_3) = (a_2 = a_4))
                  (fun (a_2 a_3 : Œ±) (e_a : a_2 = a_3) ‚Ü¶ e_a ‚ñ∏ Eq.refl (a = a_2)) e_a)
              (Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume) (Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume)
              (Eq.refl (Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume))
              (ofReal |(Matrix.diagonal D).det‚Åª¬π| ‚Ä¢ volume)
              (ofReal |(Matrix.diagonal D).det‚Åª¬π| ‚Ä¢
                ofReal |(Matrix.diagonal D).det| ‚Ä¢ Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume)
              (Eq.trans
                (congrArg (fun (_a : Measure (Œπ ‚Üí ‚Ñù)) ‚Ü¶ ofReal |(Matrix.diagonal D).det‚Åª¬π| ‚Ä¢ _a)
                  (Eq.symm (smul_map_diagonal_volume_pi hD)))
                (Eq.refl
                  (ofReal |(Matrix.diagonal D).det‚Åª¬π| ‚Ä¢
                    ofReal |(Matrix.diagonal D).det| ‚Ä¢ Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume)))))
          (Eq.mpr
            (id
              (congrArg (fun (_a : Measure (Œπ ‚Üí ‚Ñù)) ‚Ü¶ Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume = _a)
                (smul_smul (ofReal |(Matrix.diagonal D).det‚Åª¬π|) (ofReal |(Matrix.diagonal D).det|)
                  (Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume))))
            (Eq.mpr
              (id
                (congrArg
                  (fun (_a : ‚Ñù‚â•0‚àû) ‚Ü¶
                    Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume =
                      _a ‚Ä¢ Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume)
                  (Eq.symm (ENNReal.ofReal_mul (abs_nonneg (Matrix.diagonal D).det‚Åª¬π)))))
              (Eq.mpr
                (id
                  (congrArg
                    (fun (_a : ‚Ñù) ‚Ü¶
                      Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume =
                        ofReal _a ‚Ä¢ Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume)
                    (Eq.symm (abs_mul (Matrix.diagonal D).det‚Åª¬π (Matrix.diagonal D).det))))
                (Eq.mpr
                  (id
                    (congrArg
                      (fun (_a : ‚Ñù) ‚Ü¶
                        Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume =
                          ofReal |_a| ‚Ä¢ Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume)
                      (inv_mul_cancel hD)))
                  (Eq.mpr
                    (id
                      (congrArg
                        (fun (_a : ‚Ñù) ‚Ü¶
                          Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume =
                            ofReal _a ‚Ä¢ Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume)
                        abs_one))
                    (Eq.mpr
                      (id
                        (congrArg
                          (fun (_a : ‚Ñù‚â•0‚àû) ‚Ü¶
                            Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume =
                              _a ‚Ä¢ Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume)
                          ENNReal.ofReal_one))
                      (Eq.mpr
                        (id
                          (congrArg
                            (fun (_a : Measure (Œπ ‚Üí ‚Ñù)) ‚Ü¶ Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume = _a)
                            (one_smul ‚Ñù‚â•0‚àû (Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume))))
                        (Eq.refl (Measure.map (‚áë(toLin' (Matrix.diagonal D))) volume))))))))))
      (fun (t : TransvectionStruct Œπ ‚Ñù) ‚Ü¶
        Eq.mpr
          (id
            (congrArg (fun (x : ‚Ñù) ‚Ü¶ Measure.map (‚áë(toLin' t.toMatrix)) volume = ofReal |x‚Åª¬π| ‚Ä¢ volume)
              (TransvectionStruct.det t)))
          (Eq.mpr
            (id (congrArg (fun (x : ‚Ñù) ‚Ü¶ Measure.map (‚áë(toLin' t.toMatrix)) volume = ofReal |x| ‚Ä¢ volume) inv_one))
            (Eq.mpr
              (id (congrArg (fun (x : ‚Ñù) ‚Ü¶ Measure.map (‚áë(toLin' t.toMatrix)) volume = ofReal x ‚Ä¢ volume) abs_one))
              (Eq.mpr
                (id
                  (congrArg (fun (x : ‚Ñù‚â•0‚àû) ‚Ü¶ Measure.map (‚áë(toLin' t.toMatrix)) volume = x ‚Ä¢ volume)
                    ENNReal.ofReal_one))
                (Eq.mpr (id (congrArg (Eq (Measure.map (‚áë(toLin' t.toMatrix)) volume)) (one_smul ‚Ñù‚â•0‚àû volume)))
                  (of_eq_true
                    (Eq.trans
                      (congrArg (fun (x : Measure (Œπ ‚Üí ‚Ñù)) ‚Ü¶ x = volume)
                        ((fun (x_0 : Type u_1) (x_1 : DecidableEq x_0) (x_2 : Fintype x_0)
                              (x_3 : TransvectionStruct x_0 ‚Ñù) ‚Ü¶
                            (fun (x_0 : Type u_1) (x_1 : DecidableEq x_0) (x_2 : Fintype x_0)
                                  (x_3 : TransvectionStruct x_0 ‚Ñù) ‚Ü¶
                                (volume_preserving_transvectionStruct x_3).map_eq)
                              x_0 x_1 x_2 x_3)
                          Œπ inst_1 inst t))
                      (eq_self volume))))))))
      fun (A B : Matrix Œπ Œπ ‚Ñù) (a : A.det ‚â† 0) (a : B.det ‚â† 0)
        (IHA : Measure.map (‚áë(toLin' A)) volume = ofReal |A.det‚Åª¬π| ‚Ä¢ volume)
        (IHB : Measure.map (‚áë(toLin' B)) volume = ofReal |B.det‚Åª¬π| ‚Ä¢ volume) ‚Ü¶
      Eq.mpr
        (id
          (congrArg (fun (_a : (Œπ ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] Œπ ‚Üí ‚Ñù) ‚Ü¶ Measure.map (‚áë_a) volume = ofReal |(A * B).det‚Åª¬π| ‚Ä¢ volume)
            (toLin'_mul A B)))
        (Eq.mpr
          (id
            (congrArg (fun (_a : ‚Ñù) ‚Ü¶ Measure.map (‚áë(toLin' A ‚àò‚Çó toLin' B)) volume = ofReal |_a‚Åª¬π| ‚Ä¢ volume)
              (det_mul A B)))
          (Eq.mpr
            (id
              (congrArg (fun (_a : (Œπ ‚Üí ‚Ñù) ‚Üí Œπ ‚Üí ‚Ñù) ‚Ü¶ Measure.map _a volume = ofReal |(A.det * B.det)‚Åª¬π| ‚Ä¢ volume)
                (LinearMap.coe_comp (toLin' A) (toLin' B))))
            (Eq.mpr
              (id
                (congrArg (fun (_a : Measure (Œπ ‚Üí ‚Ñù)) ‚Ü¶ _a = ofReal |(A.det * B.det)‚Åª¬π| ‚Ä¢ volume)
                  (Eq.symm
                    (Measure.map_map (Continuous.measurable (LinearMap.continuous_on_pi (toLin' A)))
                      (Continuous.measurable (LinearMap.continuous_on_pi (toLin' B)))))))
              (Eq.mpr
                (id
                  (congrArg
                    (fun (_a : Measure (Œπ ‚Üí ‚Ñù)) ‚Ü¶ Measure.map (‚áë(toLin' A)) _a = ofReal |(A.det * B.det)‚Åª¬π| ‚Ä¢ volume)
                    IHB))
                (Eq.mpr
                  (id
                    (congrArg (fun (_a : Measure (Œπ ‚Üí ‚Ñù)) ‚Ü¶ _a = ofReal |(A.det * B.det)‚Åª¬π| ‚Ä¢ volume)
                      (Measure.map_smul (ofReal |B.det‚Åª¬π|) volume ‚áë(toLin' A))))
                  (Eq.mpr
                    (id
                      (congrArg
                        (fun (_a : Measure (Œπ ‚Üí ‚Ñù)) ‚Ü¶ ofReal |B.det‚Åª¬π| ‚Ä¢ _a = ofReal |(A.det * B.det)‚Åª¬π| ‚Ä¢ volume) IHA))
                    (Eq.mpr
                      (id
                        (congrArg (fun (_a : Measure (Œπ ‚Üí ‚Ñù)) ‚Ü¶ _a = ofReal |(A.det * B.det)‚Åª¬π| ‚Ä¢ volume)
                          (smul_smul (ofReal |B.det‚Åª¬π|) (ofReal |A.det‚Åª¬π|) volume)))
                      (Eq.mpr
                        (id
                          (congrArg (fun (_a : ‚Ñù‚â•0‚àû) ‚Ü¶ _a ‚Ä¢ volume = ofReal |(A.det * B.det)‚Åª¬π| ‚Ä¢ volume)
                            (Eq.symm (ENNReal.ofReal_mul (abs_nonneg B.det‚Åª¬π)))))
                        (Eq.mpr
                          (id
                            (congrArg (fun (_a : ‚Ñù) ‚Ü¶ ofReal _a ‚Ä¢ volume = ofReal |(A.det * B.det)‚Åª¬π| ‚Ä¢ volume)
                              (Eq.symm (abs_mul B.det‚Åª¬π A.det‚Åª¬π))))
                          (Eq.mpr
                            (id
                              (congrArg (fun (_a : ‚Ñù) ‚Ü¶ ofReal |_a| ‚Ä¢ volume = ofReal |(A.det * B.det)‚Åª¬π| ‚Ä¢ volume)
                                (mul_comm B.det‚Åª¬π A.det‚Åª¬π)))
                            (Eq.mpr
                              (id
                                (congrArg (fun (_a : ‚Ñù) ‚Ü¶ ofReal |A.det‚Åª¬π * B.det‚Åª¬π| ‚Ä¢ volume = ofReal |_a| ‚Ä¢ volume)
                                  (mul_inv A.det B.det)))
                              (Eq.refl (ofReal |A.det‚Åª¬π * B.det‚Åª¬π| ‚Ä¢ volume)))))))))))))
error:  unknown identifier 'map_matrix_volume_pi_eq_smul_volume_pi'","theorem smul_map_diagonal_volume_pi [DecidableEq Œπ] {D : Œπ ‚Üí ‚Ñù} (h : det (diagonal D) ‚â† 0) :
    ENNReal.ofReal (abs (det (diagonal D))) ‚Ä¢ Measure.map (toLin' (diagonal D)) volume =
      volume ",":= by
  refine (Measure.pi_eq fun s hs => ?_).symm
  simp only [det_diagonal, Measure.coe_smul, Algebra.id.smul_eq_mul, Pi.smul_apply]
  rw [Measure.map_apply _ (MeasurableSet.univ_pi hs)]
  swap; ¬∑ exact Continuous.measurable (LinearMap.continuous_on_pi _)
  have :
    (Matrix.toLin' (diagonal D) ‚Åª¬π' Set.pi Set.univ fun i : Œπ => s i) =
      Set.pi Set.univ fun i : Œπ => (D i * ¬∑) ‚Åª¬π' s i := by
    ext f
    simp only [LinearMap.coe_proj, Algebra.id.smul_eq_mul, LinearMap.smul_apply, mem_univ_pi,
      mem_preimage, LinearMap.pi_apply, diagonal_toLin']
  have B : ‚àÄ i, ofReal (abs (D i)) * volume ((D i * ¬∑) ‚Åª¬π' s i) = volume (s i) := by
    intro i
    have A : D i ‚â† 0 := by
      simp only [det_diagonal, Ne] at h
      exact Finset.prod_ne_zero_iff.1 h i (Finset.mem_univ i)
    rw [volume_preimage_mul_left A, ‚Üê mul_assoc, ‚Üê ENNReal.ofReal_mul (abs_nonneg _), ‚Üê abs_mul,
      mul_inv_cancel A, abs_one, ENNReal.ofReal_one, one_mul]
  rw [this, volume_pi_pi, Finset.abs_prod,
    ENNReal.ofReal_prod_of_nonneg fun i _ => abs_nonneg (D i), ‚Üê Finset.prod_mul_distrib]
  simp only [B]"
Mathlib/MeasureTheory/Integral/DivergenceTheorem.lean,MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable_aux‚ÇÅ,integral_divergence_of_hasFDerivWithinAt_off_countable_aux‚ÇÅ,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  simp only [‚Üê setIntegral_congr_set_ae (Box.coe_ae_eq_Icc _)]
  have A := (Hi.mono_set Box.coe_subset_Icc).hasBoxIntegral ‚ä• rfl
  have B :=
    hasIntegral_GP_divergence_of_forall_hasDerivWithinAt I f f' (s ‚à© Box.Icc I)
      (hs.mono (inter_subset_left _ _)) (fun x hx => Hc _ hx.2) fun x hx =>
      Hd _ ‚ü®hx.1, fun h => hx.2 ‚ü®h, hx.1‚ü©‚ü©
  rw [continuousOn_pi] at Hc
  refine (A.unique B).trans (sum_congr rfl fun i _ => ?_)
  refine congr_arg‚ÇÇ Sub.sub ?_ ?_
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.right_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.left_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq","error:  overloaded, errors 
  function expected at
    Finset.inter_subset_left ?m.17305
  term has type
    ?m.17304 ‚àà ?m.17302
  
  function expected at
    Set.inter_subset_left ?m.17442
  term has type
    ?m.17441 ‚àà ?m.17439","theorem integral_divergence_of_hasFDerivWithinAt_off_countable_aux‚ÇÅ (I : Box (Fin (n + 1)))
    (f : ‚Ñù‚Åø‚Å∫¬π ‚Üí E‚Åø‚Å∫¬π)
    (f' : ‚Ñù‚Åø‚Å∫¬π ‚Üí ‚Ñù‚Åø‚Å∫¬π ‚ÜíL[‚Ñù] E‚Åø‚Å∫¬π) (s : Set ‚Ñù‚Åø‚Å∫¬π)
    (hs : s.Countable) (Hc : ContinuousOn f (Box.Icc I))
    (Hd : ‚àÄ x ‚àà (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x)
    (Hi : IntegrableOn (fun x => ‚àë i, f' x (e i) i) (Box.Icc I)) :
    (‚à´ x in Box.Icc I, ‚àë i, f' x (e i) i) =
      ‚àë i : Fin (n + 1),
        ((‚à´ x in Box.Icc (I.face i), f (i.insertNth (I.upper i) x) i) -
          ‚à´ x in Box.Icc (I.face i), f (i.insertNth (I.lower i) x) i) ",":= by
  simp only [‚Üê setIntegral_congr_set_ae (Box.coe_ae_eq_Icc _)]
  have A := (Hi.mono_set Box.coe_subset_Icc).hasBoxIntegral ‚ä• rfl
  have B :=
    hasIntegral_GP_divergence_of_forall_hasDerivWithinAt I f f' (s ‚à© Box.Icc I)
      (hs.mono inter_subset_left) (fun x hx => Hc _ hx.2) fun x hx =>
      Hd _ ‚ü®hx.1, fun h => hx.2 ‚ü®h, hx.1‚ü©‚ü©
  rw [continuousOn_pi] at Hc
  refine (A.unique B).trans (sum_congr rfl fun i _ => ?_)
  refine congr_arg‚ÇÇ Sub.sub ?_ ?_
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.right_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.left_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq"
Mathlib/FieldTheory/AbelRuffini.lean,solvableByRad.induction3,induction3,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  let p := minpoly F (Œ± ^ n)
  have hp : p.comp (X ^ n) ‚â† 0 := by
    intro h
    cases' comp_eq_zero_iff.mp h with h' h'
    ¬∑ exact minpoly.ne_zero (isIntegral (Œ± ^ n)) h'
    ¬∑ exact hn (by rw [‚Üê @natDegree_C F, ‚Üê h'.2, natDegree_X_pow])
  apply gal_isSolvable_of_splits
  ¬∑ exact ‚ü®splits_of_splits_of_dvd _ hp (SplittingField.splits (p.comp (X ^ n)))
      (minpoly.dvd F Œ± (by rw [aeval_comp, aeval_X_pow, minpoly.aeval]))‚ü©
  ¬∑ refine gal_isSolvable_tower p (p.comp (X ^ n)) ?_ hŒ±? _
    ¬∑ exact Gal.splits_in_splittingField_of_comp _ _ (by rwa [natDegree_X_pow])
    ¬∑ obtain ‚ü®s, hs‚ü© := (splits_iff_exists_multiset _).1 (SplittingField.splits p)
      rw [map_comp, Polynomial.map_pow, map_X, hs, mul_comp, C_comp]
      apply gal_mul_isSolvable (gal_C_isSolvable _)
      rw [multiset_prod_comp]
      apply gal_prod_isSolvable
      intro q hq
      rw [Multiset.mem_map] at hq
      obtain ‚ü®q, hq, rfl‚ü© := hq
      rw [Multiset.mem_map] at hq
      obtain ‚ü®q, _, rfl‚ü© := hq
      rw [sub_comp, X_comp, C_comp]
      exact gal_X_pow_sub_C_isSolvable n q",error:  unknown identifier 'hŒ±?',theorem induction3 {Œ± : solvableByRad F E} {n : ‚Ñï} (hn : n ‚â† 0) (hŒ± : P (Œ± ^ n)) : P Œ± ,":= by
  let p := minpoly F (Œ± ^ n)
  have hp : p.comp (X ^ n) ‚â† 0 := by
    intro h
    cases' comp_eq_zero_iff.mp h with h' h'
    ¬∑ exact minpoly.ne_zero (isIntegral (Œ± ^ n)) h'
    ¬∑ exact hn (by rw [‚Üê @natDegree_C F, ‚Üê h'.2, natDegree_X_pow])
  apply gal_isSolvable_of_splits
  ¬∑ exact ‚ü®splits_of_splits_of_dvd _ hp (SplittingField.splits (p.comp (X ^ n)))
      (minpoly.dvd F Œ± (by rw [aeval_comp, aeval_X_pow, minpoly.aeval]))‚ü©
  ¬∑ refine gal_isSolvable_tower p (p.comp (X ^ n)) ?_ hŒ± ?_
    ¬∑ exact Gal.splits_in_splittingField_of_comp _ _ (by rwa [natDegree_X_pow])
    ¬∑ obtain ‚ü®s, hs‚ü© := (splits_iff_exists_multiset _).1 (SplittingField.splits p)
      rw [map_comp, Polynomial.map_pow, map_X, hs, mul_comp, C_comp]
      apply gal_mul_isSolvable (gal_C_isSolvable _)
      rw [multiset_prod_comp]
      apply gal_prod_isSolvable
      intro q hq
      rw [Multiset.mem_map] at hq
      obtain ‚ü®q, hq, rfl‚ü© := hq
      rw [Multiset.mem_map] at hq
      obtain ‚ü®q, _, rfl‚ü© := hq
      rw [sub_comp, X_comp, C_comp]
      exact gal_X_pow_sub_C_isSolvable n q"
Mathlib/GroupTheory/SpecificGroups/Cyclic.lean,isCyclic_of_prime_card,isCyclic_of_prime_card,1c443e9a82aa8905ef6ec57fd5b361aff3a498e4,":=
  ‚ü®by
    obtain ‚ü®g, hg‚ü© : ‚àÉ g : Œ±, g ‚â† 1 := Fintype.exists_ne_of_one_lt_card (h.symm ‚ñ∏ hp.1.one_lt) 1
    classical
      have : Fintype.card (Subgroup.zpowers g) ‚à£ p := by
        rw [‚Üê h]
        apply card_subgroup_dvd_card
      rw [Nat.dvd_prime hp.1] at this
      cases' this with that that
      ¬∑ rw [Fintype.card_eq_one_iff] at that
        cases' that with t ht
        suffices g = 1 by contradiction
        have hgt :=
          ht
            ‚ü®g, by
              change g ‚àà Subgroup.zpowers g
              exact Subgroup.mem_zpowers g‚ü©
        rw [‚Üê ht 1] at hgt
        change (‚ü®_, _‚ü© : Subgroup.zpowers g) = ‚ü®_, _‚ü© at hgt
        simpa using hgt
      ¬∑ use g
        intro x
        rw [‚Üê h] at that
        rw [Subgroup.eq_top_of_card_eq _ that]
        exact Subgroup.mem_top _‚ü©","error:  tactic 'apply' failed, failed to unify
  Nat.card ‚Ü•?s ‚à£ Nat.card ?Œ±
with
  Fintype.card ‚Ü•(zpowers g) ‚à£ Fintype.card Œ±
Œ±‚úù : Type u
a : Œ±‚úù
inst‚úù¬≤ : Group Œ±‚úù
Œ± : Type u
inst‚úù¬π : Group Œ±
inst‚úù : Fintype Œ±
p : ‚Ñï
hp : Fact (Nat.Prime p)
h : Fintype.card Œ± = p
g : Œ±
hg : g ‚â† 1
‚ä¢ Fintype.card ‚Ü•(zpowers g) ‚à£ Fintype.card Œ±
error:  application type mismatch
  eq_top_of_card_eq ?m.12360 that
argument
  that
has type
  Fintype.card ‚Ü•(zpowers g) = Fintype.card Œ± : Prop
but is expected to have type
  Nat.card ‚Ü•?m.12360 = Nat.card ?m.12358 : Prop
error:  tactic 'rewrite' failed, pattern is a metavariable
  ?m.12360
from equation
  ?m.12360 = ‚ä§
case h
Œ±‚úù : Type u
a : Œ±‚úù
inst‚úù¬≤ : Group Œ±‚úù
Œ± : Type u
inst‚úù¬π : Group Œ±
inst‚úù : Fintype Œ±
p : ‚Ñï
hp : Fact (Nat.Prime p)
h : Fintype.card Œ± = p
g : Œ±
hg : g ‚â† 1
that : Fintype.card ‚Ü•(zpowers g) = Fintype.card Œ±
x : Œ±
‚ä¢ x ‚àà zpowers g","theorem isCyclic_of_prime_card {Œ± : Type u} [Group Œ±] [Fintype Œ±] {p : ‚Ñï} [hp : Fact p.Prime]
    (h : Fintype.card Œ± = p) : IsCyclic Œ± ",":= by
  obtain ‚ü®g, hg‚ü© : ‚àÉ g, g ‚â† 1 := Fintype.exists_ne_of_one_lt_card (h.symm ‚ñ∏ hp.1.one_lt) 1
  exact ‚ü®g, fun g' ‚Ü¶ mem_zpowers_of_prime_card h hg‚ü©"
Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean,Ideal.homogeneousCore'_mono,Ideal.homogeneousCore'_mono,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":=
  Submodule.homogeneousCore'_mono ùíú",error:  unknown constant 'Submodule.homogeneousCore'_mono',theorem Ideal.homogeneousCore'_mono : Monotone (Ideal.homogeneousCore' ùíú) ,":=
  fun _ _ I_le_J => Ideal.span_mono <| Set.image_subset _ fun _ => @I_le_J _"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.card_compression,card_compression,9e34a191034458a56331f976ff7400a26407c888,":= by
  rw [compression, card_disjoint_union (compress_disjoint _ _), image_filter, card_image_of_injOn,
    ‚Üê card_disjoint_union]
  simp_rw [Function.comp]
  rw [filter_union_filter_neg_eq]
  ¬∑ rw [disjoint_iff_inter_eq_empty]
    exact filter_inter_filter_neg_eq _ _ _
  intro a ha b hb hab
  dsimp at hab
  rw [mem_coe, mem_filter, Function.comp_apply] at ha hb
  rw [compress] at ha hab
  split_ifs at ha hab with has
  ¬∑ rw [compress] at hb hab
    split_ifs at hb hab with hbs
    ¬∑ exact sup_sdiff_injOn u v has hbs hab
    ¬∑ exact (hb.2 hb.1).elim
  ¬∑ exact (ha.2 ha.1).elim","warning:  @UV.compression does not have a doc string
warning:  `Finset.card_disjoint_union` has been deprecated, use `Finset.card_union_of_disjoint` instead
error:  application type mismatch
  card_disjoint_union (compress_disjoint ?m.54484 ?m.54485)
argument
  compress_disjoint ?m.54484 ?m.54485
has type
  ?m.54483 ‚â§ ‚ä• : Prop
but is expected to have type
  Disjoint ?m.54471 ?m.54472 : Prop
warning:  `Finset.image_filter` has been deprecated, use `Finset.filter_image` instead
warning:  `Finset.card_disjoint_union` has been deprecated, use `Finset.card_union_of_disjoint` instead
error:  simp made no progress",theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card ,":= by
  rw [compression, card_union_of_disjoint compress_disjoint, filter_image,
    card_image_of_injOn compress_injOn, ‚Üê card_union_of_disjoint (disjoint_filter_filter_neg s _ _),
    filter_union_filter_neg_eq]"
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.tendsto_Lp_of_tendsto_ae,tendsto_Lp_of_tendsto_ae,b0e957dde04ef7c6990a222e5a6fa5c2179a8fc8,":= by
  rw [ENNReal.tendsto_atTop_zero]
  intro Œµ hŒµ
  by_cases Œµ < ‚àû; swap
  ¬∑ rw [not_lt, top_le_iff] at h
    exact ‚ü®0, fun n _ => by simp [h]‚ü©
  by_cases hŒº : Œº = 0
  ¬∑ exact ‚ü®0, fun n _ => by simp [hŒº]‚ü©
  have hŒµ' : 0 < Œµ.toReal / 3 :=
    div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (by norm_num)
  have hdivp : 0 ‚â§ 1 / p.toReal := by
    refine' one_div_nonneg.2 _
    rw [‚Üê ENNReal.zero_toReal, ENNReal.toReal_le_toReal ENNReal.zero_ne_top hp']
    exact le_trans (zero_le _) hp
  have hpow : 0 < measureUnivNNReal Œº ^ (1 / p.toReal) :=
    Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
  obtain ‚ü®Œ¥‚ÇÅ, hŒ¥‚ÇÅ, hsnorm‚ÇÅ‚ü© := hui hŒµ'
  obtain ‚ü®Œ¥‚ÇÇ, hŒ¥‚ÇÇ, hsnorm‚ÇÇ‚ü© := hg'.snorm_indicator_le Œº hp hp' hŒµ'
  obtain ‚ü®t, htm, ht‚ÇÅ, ht‚ÇÇ‚ü© := tendstoUniformlyOn_of_ae_tendsto' hf hg hfg (lt_min hŒ¥‚ÇÅ hŒ¥‚ÇÇ)
  rw [Metric.tendstoUniformlyOn_iff] at ht‚ÇÇ
  specialize ht‚ÇÇ (Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    (div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (mul_pos (by norm_num) hpow))
  obtain ‚ü®N, hN‚ü© := eventually_atTop.1 ht‚ÇÇ; clear ht‚ÇÇ
  refine' ‚ü®N, fun n hn => _‚ü©
  rw [‚Üê t.indicator_self_add_compl (f n - g)]
  refine' le_trans (snorm_add_le (((hf n).sub hg).indicator htm).aestronglyMeasurable
    (((hf n).sub hg).indicator htm.compl).aestronglyMeasurable hp) _
  rw [sub_eq_add_neg, Set.indicator_add' t, Set.indicator_neg']
  refine' le_trans (add_le_add_right (snorm_add_le ((hf n).indicator htm).aestronglyMeasurable
    (hg.indicator htm).neg.aestronglyMeasurable hp) _) _
  have hnf : snorm (t.indicator (f n)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine' hsnorm‚ÇÅ n t htm (le_trans ht‚ÇÅ _)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÅ.le]
    exact min_le_left _ _
  have hng : snorm (t.indicator g) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine' hsnorm‚ÇÇ t htm (le_trans ht‚ÇÅ _)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÇ.le]
    exact min_le_right _ _
  have hlt : snorm (t·∂ú.indicator (f n - g)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    specialize hN n hn
    have : 0 ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)) := by
      rw [div_mul_eq_div_mul_one_div]
      exact mul_nonneg hŒµ'.le (one_div_nonneg.2 hpow.le)
    have := snorm_sub_le_of_dist_bdd Œº hp' htm.compl this fun x hx =>
      (dist_comm (g x) (f n x) ‚ñ∏ (hN x hx).le :
        dist (f n x) (g x) ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    refine' le_trans this _
    rw [div_mul_eq_div_mul_one_div, ‚Üê ENNReal.ofReal_toReal (measure_lt_top Œº t·∂ú).ne,
      ENNReal.ofReal_rpow_of_nonneg ENNReal.toReal_nonneg hdivp, ‚Üê ENNReal.ofReal_mul, mul_assoc]
    ¬∑ refine' ENNReal.ofReal_le_ofReal (mul_le_of_le_one_right hŒµ'.le _)
      rw [mul_comm, mul_one_div, div_le_one]
      ¬∑ refine' Real.rpow_le_rpow ENNReal.toReal_nonneg
          (ENNReal.toReal_le_of_le_ofReal (measureUnivNNReal_pos hŒº).le _) hdivp
        rw [ENNReal.ofReal_coe_nnreal, coe_measureUnivNNReal]
        exact measure_mono (Set.subset_univ _)
      ¬∑ exact Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
    ¬∑ refine' mul_nonneg hŒµ'.le (one_div_nonneg.2 hpow.le)
  have : ENNReal.ofReal (Œµ.toReal / 3) = Œµ / 3 := by
    rw [ENNReal.ofReal_div_of_pos (show (0 : ‚Ñù) < 3 by norm_num), ENNReal.ofReal_toReal h.ne]
    simp
  rw [this] at hnf hng hlt
  rw [snorm_neg, ‚Üê ENNReal.add_thirds Œµ, ‚Üê sub_eq_add_neg]
  exact add_le_add_three hnf hng hlt","error:  unknown identifier 'h'
error:  unknown identifier 'h.ne'
error:  application type mismatch
  Mem‚Ñíp.snorm_indicator_le Œº
argument
  Œº
has type
  Measure Œ± : Type u_1
but is expected to have type
  1 ‚â§ ?m.123854 : Prop
error:  rcases tactic failed: x‚úù : ?m.125515 is not an inductive datatype","theorem tendsto_Lp_of_tendsto_ae_of_meas [IsFiniteMeasure Œº] (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû)
    {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (hf : ‚àÄ n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g)
    (hg' : Mem‚Ñíp g p Œº) (hui : UnifIntegrable f p Œº)
    (hfg : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (g x))) :
    Tendsto (fun n => snorm (f n - g) p Œº) atTop (ùìù 0) ",":= by
  rw [ENNReal.tendsto_atTop_zero]
  intro Œµ hŒµ
  by_cases h : Œµ < ‚àû; swap
  ¬∑ rw [not_lt, top_le_iff] at h
    exact ‚ü®0, fun n _ => by simp [h]‚ü©
  by_cases hŒº : Œº = 0
  ¬∑ exact ‚ü®0, fun n _ => by simp [hŒº]‚ü©
  have hŒµ' : 0 < Œµ.toReal / 3 :=
    div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (by norm_num)
  have hdivp : 0 ‚â§ 1 / p.toReal := by
    refine one_div_nonneg.2 ?_
    rw [‚Üê ENNReal.zero_toReal, ENNReal.toReal_le_toReal ENNReal.zero_ne_top hp']
    exact le_trans (zero_le _) hp
  have hpow : 0 < measureUnivNNReal Œº ^ (1 / p.toReal) :=
    Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
  obtain ‚ü®Œ¥‚ÇÅ, hŒ¥‚ÇÅ, hsnorm‚ÇÅ‚ü© := hui hŒµ'
  obtain ‚ü®Œ¥‚ÇÇ, hŒ¥‚ÇÇ, hsnorm‚ÇÇ‚ü© := hg'.snorm_indicator_le hp hp' hŒµ'
  obtain ‚ü®t, htm, ht‚ÇÅ, ht‚ÇÇ‚ü© := tendstoUniformlyOn_of_ae_tendsto' hf hg hfg (lt_min hŒ¥‚ÇÅ hŒ¥‚ÇÇ)
  rw [Metric.tendstoUniformlyOn_iff] at ht‚ÇÇ
  specialize ht‚ÇÇ (Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    (div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (mul_pos (by norm_num) hpow))
  obtain ‚ü®N, hN‚ü© := eventually_atTop.1 ht‚ÇÇ; clear ht‚ÇÇ
  refine ‚ü®N, fun n hn => ?_‚ü©
  rw [‚Üê t.indicator_self_add_compl (f n - g)]
  refine le_trans (snorm_add_le (((hf n).sub hg).indicator htm).aestronglyMeasurable
    (((hf n).sub hg).indicator htm.compl).aestronglyMeasurable hp) ?_
  rw [sub_eq_add_neg, Set.indicator_add' t, Set.indicator_neg']
  refine le_trans (add_le_add_right (snorm_add_le ((hf n).indicator htm).aestronglyMeasurable
    (hg.indicator htm).neg.aestronglyMeasurable hp) _) ?_
  have hnf : snorm (t.indicator (f n)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine hsnorm‚ÇÅ n t htm (le_trans ht‚ÇÅ ?_)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÅ.le]
    exact min_le_left _ _
  have hng : snorm (t.indicator g) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine hsnorm‚ÇÇ t htm (le_trans ht‚ÇÅ ?_)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÇ.le]
    exact min_le_right _ _
  have hlt : snorm (t·∂ú.indicator (f n - g)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    specialize hN n hn
    have : 0 ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)) := by positivity
    have := snorm_sub_le_of_dist_bdd Œº hp' htm.compl this fun x hx =>
      (dist_comm (g x) (f n x) ‚ñ∏ (hN x hx).le :
        dist (f n x) (g x) ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    refine le_trans this ?_
    rw [div_mul_eq_div_mul_one_div, ‚Üê ENNReal.ofReal_toReal (measure_lt_top Œº t·∂ú).ne,
      ENNReal.ofReal_rpow_of_nonneg ENNReal.toReal_nonneg hdivp, ‚Üê ENNReal.ofReal_mul, mul_assoc]
    ¬∑ refine ENNReal.ofReal_le_ofReal (mul_le_of_le_one_right hŒµ'.le ?_)
      rw [mul_comm, mul_one_div, div_le_one]
      ¬∑ refine Real.rpow_le_rpow ENNReal.toReal_nonneg
          (ENNReal.toReal_le_of_le_ofReal (measureUnivNNReal_pos hŒº).le ?_) hdivp
        rw [ENNReal.ofReal_coe_nnreal, coe_measureUnivNNReal]
        exact measure_mono (Set.subset_univ _)
      ¬∑ exact Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
    ¬∑ positivity
  have : ENNReal.ofReal (Œµ.toReal / 3) = Œµ / 3 := by
    rw [ENNReal.ofReal_div_of_pos (show (0 : ‚Ñù) < 3 by norm_num), ENNReal.ofReal_toReal h.ne]
    simp
  rw [this] at hnf hng hlt
  rw [snorm_neg, ‚Üê ENNReal.add_thirds Œµ, ‚Üê sub_eq_add_neg]
  exact add_le_add_three hnf hng hlt"
Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean,CategoryTheory.comp_rightAdjointMate,comp_rightAdjointMate,ad0fb7237dfe64692bfd01c1bfd64cdf12e0ccd7,":= by
  rw [rightAdjointMate_comp]
  simp only [rightAdjointMate, comp_whiskerRight]
  simp only [‚Üê Category.assoc]; congr 3; simp only [Category.assoc]
  simp only [‚Üê MonoidalCategory.whiskerLeft_comp]; congr 2
  symm
  calc
    _ = ùüô _ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ ùüô_ C ‚â´ (Y ‚äó Y·òÅ) ‚óÅ Œ∑_ X X·òÅ) ‚äó‚â´ Y ‚óÅ Y·òÅ ‚óÅ f ‚ñ∑ X·òÅ ‚äó‚â´
        Y ‚óÅ Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [tensorHom_def']; coherence
    _ = Œ∑_ X X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ (X ‚äó X·òÅ) ‚â´ (Y ‚äó Y·òÅ) ‚óÅ f ‚ñ∑ X·òÅ) ‚äó‚â´
        Y ‚óÅ Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [‚Üê whisker_exchange]; coherence
    _ = Œ∑_ X X·òÅ ‚äó‚â´ f ‚ñ∑ X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ Y ‚äó‚â´ Y ‚óÅ Œµ_ Y Y·òÅ) ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [‚Üê whisker_exchange]; coherence
    _ = Œ∑_ X X·òÅ ‚â´ f ‚ñ∑ X·òÅ ‚â´ g ‚ñ∑ X·òÅ := by
      rw [evaluation_coevaluation''']; coherence","warning:  @coevaluation does not have a doc string
warning:  @evaluation does not have a doc string
warning:  @leftDual does not have a doc string
warning:  @rightDual does not have a doc string
warning:  @rightAdjointMate does not have a doc string
warning:  @leftAdjointMate does not have a doc string
error:  unknown identifier 'evaluation_coevaluation''''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.342916
C : Type u‚ÇÅ
inst‚úù‚Å¥ : Category.{v‚ÇÅ, u‚ÇÅ} C
inst‚úù¬≥ : MonoidalCategory C
X Y Z : C
inst‚úù¬≤ : HasRightDual X
inst‚úù¬π : HasRightDual Y
inst‚úù : HasRightDual Z
f : X ‚ü∂ Y
g : Y ‚ü∂ Z
‚ä¢ Œ∑_ X X·òÅ ‚äó‚â´ f ‚ñ∑ X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ Y ‚äó‚â´ Y ‚óÅ Œµ_ Y Y·òÅ) ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô (Z ‚äó X·òÅ) = Œ∑_ X X·òÅ ‚â´ f ‚ñ∑ X·òÅ ‚â´ g ‚ñ∑ X·òÅ","theorem comp_rightAdjointMate {X Y Z : C} [HasRightDual X] [HasRightDual Y] [HasRightDual Z]
    {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} : (f ‚â´ g)·òÅ = g·òÅ ‚â´ f·òÅ ",":= by
  rw [rightAdjointMate_comp]
  simp only [rightAdjointMate, comp_whiskerRight]
  simp only [‚Üê Category.assoc]; congr 3; simp only [Category.assoc]
  simp only [‚Üê MonoidalCategory.whiskerLeft_comp]; congr 2
  symm
  calc
    _ = ùüô _ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ ùüô_ C ‚â´ (Y ‚äó Y·òÅ) ‚óÅ Œ∑_ X X·òÅ) ‚äó‚â´ Y ‚óÅ Y·òÅ ‚óÅ f ‚ñ∑ X·òÅ ‚äó‚â´
        Y ‚óÅ Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [tensorHom_def']; coherence
    _ = Œ∑_ X X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ (X ‚äó X·òÅ) ‚â´ (Y ‚äó Y·òÅ) ‚óÅ f ‚ñ∑ X·òÅ) ‚äó‚â´
        Y ‚óÅ Œµ_ Y Y·òÅ ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [‚Üê whisker_exchange]; coherence
    _ = Œ∑_ X X·òÅ ‚äó‚â´ f ‚ñ∑ X·òÅ ‚äó‚â´ (Œ∑_ Y Y·òÅ ‚ñ∑ Y ‚äó‚â´ Y ‚óÅ Œµ_ Y Y·òÅ) ‚ñ∑ X·òÅ ‚äó‚â´ g ‚ñ∑ X·òÅ ‚äó‚â´ ùüô _ := by
      rw [‚Üê whisker_exchange]; coherence
    _ = Œ∑_ X X·òÅ ‚â´ f ‚ñ∑ X·òÅ ‚â´ g ‚ñ∑ X·òÅ := by
      rw [evaluation_coevaluation'']; coherence"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120516 ‚Üí ?m.120516
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.124403 ‚Üí ?m.124403
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà id ‚àÖ, closedBall p.1 p.2) ‚â§ Œº s
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.132197 ‚Üí ?m.132197 ‚Üí Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.132333 ‚Üí ?m.132333 ‚Üí Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/Data/Finset/Fold.lean,Finset.fold_op_rel_iff_or,fold_op_rel_iff_or,c959b2f950b9c44268e36bcedef976356855e6fb,":= by
  classical
    induction' s with a s ha IH
    ¬∑ simp
    rw [Finset.fold_insert ha, hr, IH, ‚Üê or_assoc, @or_comm (r c (f a)), or_assoc]
    apply or_congr Iff.rfl
    constructor
    ¬∑ rintro (h‚ÇÅ | ‚ü®x, hx, h‚ÇÇ‚ü©)
      ¬∑ use a
        simp [h‚ÇÅ]
      ¬∑ refine ‚ü®x, by simp [hx], h‚ÇÇ‚ü©
    ¬∑ rintro ‚ü®x, hx, h‚ü©
      exact (mem_insert.mp hx).imp (fun hx => by rwa [hx] at h) (fun hx => ‚ü®x, hx, h‚ü©)","error:  unsolved goals
case mk
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
op : Œ≤ ‚Üí Œ≤ ‚Üí Œ≤
hc : Std.Commutative op
ha : Std.Associative op
f : Œ± ‚Üí Œ≤
b : Œ≤
s‚úù : Finset Œ±
a‚úù : Œ±
r : Œ≤ ‚Üí Œ≤ ‚Üí Prop
hr : ‚àÄ {x y z : Œ≤}, r x (op y z) ‚Üî r x y ‚à® r x z
c : Œ≤
a : Multiset Œ±
s : a.Nodup
‚ä¢ r c (fold op b f { val := a, nodup := s }) ‚Üî r c b ‚à® ‚àÉ x ‚àà a, r c (f x)
error:  no goals to be solved","theorem fold_op_rel_iff_or {r : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (hr : ‚àÄ {x y z}, r x (op y z) ‚Üî r x y ‚à® r x z)
    {c : Œ≤} : r c (s.fold op b f) ‚Üî r c b ‚à® ‚àÉ x ‚àà s, r c (f x) ",":= by
  classical
    induction' s using Finset.induction_on with a s ha IH
    ¬∑ simp
    rw [Finset.fold_insert ha, hr, IH, ‚Üê or_assoc, @or_comm (r c (f a)), or_assoc]
    apply or_congr Iff.rfl
    constructor
    ¬∑ rintro (h‚ÇÅ | ‚ü®x, hx, h‚ÇÇ‚ü©)
      ¬∑ use a
        simp [h‚ÇÅ]
      ¬∑ refine ‚ü®x, by simp [hx], h‚ÇÇ‚ü©
    ¬∑ rintro ‚ü®x, hx, h‚ü©
      exact (mem_insert.mp hx).imp (fun hx => by rwa [hx] at h) (fun hx => ‚ü®x, hx, h‚ü©)"
Mathlib/Topology/Basic.lean,interior_frontier,interior_frontier,2ea14b79e1f7e6978b1265a8d41f7a305925875c,":= by
  have A : frontier s = s \ interior s := h.frontier_eq
  have B : interior (frontier s) ‚äÜ interior s := by rw [A]; exact interior_mono (diff_subset _ _)
  have C : interior (frontier s) ‚äÜ frontier s := interior_subset
  have : interior (frontier s) ‚äÜ interior s ‚à© (s \ interior s) :=
    subset_inter B (by simpa [A] using C)
  rwa [inter_diff_self, subset_empty_iff] at this","error:  function expected at
  diff_subset ?m.45153
term has type
  ?m.45152 ‚àà ?m.45150",theorem interior_frontier (h : IsClosed s) : interior (frontier s) = ‚àÖ ,":= by
  have A : frontier s = s \ interior s := h.frontier_eq
  have B : interior (frontier s) ‚äÜ interior s := by rw [A]; exact interior_mono diff_subset
  have C : interior (frontier s) ‚äÜ frontier s := interior_subset
  have : interior (frontier s) ‚äÜ interior s ‚à© (s \ interior s) :=
    subset_inter B (by simpa [A] using C)
  rwa [inter_diff_self, subset_empty_iff] at this"
Mathlib/ModelTheory/Skolem.lean,FirstOrder.Language.exists_elementarySubstructure_card_eq,exists_elementarySubstructure_card_eq,047f73c34cd3e6bae28166f72847965b1a989c70,":= by
  obtain ‚ü®s', hs'‚ü© := Cardinal.le_mk_iff_exists_set.1 h4
  rw [‚Üê aleph0_le_lift.{_, w}] at h1
  rw [‚Üê hs'] at h1 h2 ‚ä¢
  refine'
    ‚ü®elementarySkolem‚ÇÅReduct (closure (L.sum L.skolem‚ÇÅ) (s ‚à™ Equiv.ulift '' s')),
      (s.subset_union_left _).trans subset_closure, _‚ü©
  have h := mk_image_eq_lift _ s' Equiv.ulift.injective
  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h
  rw [coeSort_elementarySkolem‚ÇÅReduct, ‚Üê h, lift_inj]
  refine'
    le_antisymm (lift_le.1 (lift_card_closure_le.trans _))
      (mk_le_mk_of_subset ((Set.subset_union_right _ _).trans subset_closure))
  rw [max_le_iff, aleph0_le_lift, ‚Üê aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]
  refine' ‚ü®h1, (mk_union_le _ _).trans _, (lift_le.2 card_functions_sum_skolem‚ÇÅ_le).trans _‚ü©
  ¬∑ rw [‚Üê lift_le, lift_add, h, add_comm, add_eq_max h1]
    exact max_le le_rfl h2
  ¬∑ rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, ‚Üê lift_le.{w'},
      lift_lift, lift_lift, ‚Üê aleph0_le_lift, h]
    refine' ‚ü®_, h1‚ü©
    rw [‚Üê lift_lift.{w', w}]
    refine' trans (lift_le.{w}.2 h3) _
    rw [lift_lift, ‚Üê lift_lift.{w, max u v}, ‚Üê hs', ‚Üê h, lift_lift]
  ¬∑ refine' trans _ (lift_le.2 (mk_le_mk_of_subset (Set.subset_union_right _ _)))
    rw [aleph0_le_lift, ‚Üê aleph0_le_lift, h]
    exact h1","error:  invalid field 'trans', the environment does not contain 'Membership.mem.trans'
  Set.subset_union_left ?m.26890
has type
  ?m.26889 ‚àà s ‚à™ ?m.26888
error:  invalid field 'trans', the environment does not contain 'Set.Mem.trans'
  Set.subset_union_left ?m.26890
has type
  Set.Mem ?m.26889 (s ‚à™ ?m.26888)
error:  invalid field 'trans', the environment does not contain 'Union.union.trans'
  Set.subset_union_left ?m.26890
has type
  (s ‚à™ ?m.26888) ?m.26889
error:  invalid field 'trans', the environment does not contain 'Set.union.trans'
  Set.subset_union_left ?m.26890
has type
  s.union ?m.26888 ?m.26889
error:  invalid field 'trans', the environment does not contain 'setOf.trans'
  Set.subset_union_left ?m.26890
has type
  {a | a ‚àà s ‚à® a ‚àà ?m.26888} ?m.26889
error:  invalid field 'trans', the environment does not contain 'Or.trans'
  Set.subset_union_left ?m.26890
has type
  ?m.26889 ‚àà s ‚à® ?m.26889 ‚àà ?m.26888
error:  function expected at
  Set.subset_union_right ?m.27688
term has type
  ?m.27687 ‚àà ?m.27685 ‚à™ ?m.27686
error:  ambiguous, possible interpretations 
  _root_.trans (lift_le.mpr h3)
    ?m.29723 : lift.{w, max w' u v} (lift.{w', max u v} L.card) ‚â§ lift.{max (max u v) w', w} #‚Üë(‚áëEquiv.ulift '' s')
  
  Trans.trans (lift_le.mpr h3)
    ?m.29890 : lift.{w, max w' u v} (lift.{w', max u v} L.card) ‚â§ lift.{max (max u v) w', w} #‚Üë(‚áëEquiv.ulift '' s')
error:  no goals to be solved
error:  overloaded, errors 
  114:52 function expected at
    Set.subset_union_right ?m.30012
  term has type
    ?m.30011 ‚àà ?m.30009 ‚à™ ?m.30010
  
  114:52 function expected at
    Set.subset_union_right ?m.30131
  term has type
    ?m.30130 ‚àà ?m.30128 ‚à™ ?m.30129
error:  no goals to be solved","theorem exists_elementarySubstructure_card_eq (s : Set M) (Œ∫ : Cardinal.{w'}) (h1 : ‚Ñµ‚ÇÄ ‚â§ Œ∫)
    (h2 : Cardinal.lift.{w'} #s ‚â§ Cardinal.lift.{w} Œ∫)
    (h3 : Cardinal.lift.{w'} L.card ‚â§ Cardinal.lift.{max u v} Œ∫)
    (h4 : Cardinal.lift.{w} Œ∫ ‚â§ Cardinal.lift.{w'} #M) :
    ‚àÉ S : L.ElementarySubstructure M, s ‚äÜ S ‚àß Cardinal.lift.{w'} #S = Cardinal.lift.{w} Œ∫ ",":= by
  obtain ‚ü®s', hs'‚ü© := Cardinal.le_mk_iff_exists_set.1 h4
  rw [‚Üê aleph0_le_lift.{_, w}] at h1
  rw [‚Üê hs'] at h1 h2 ‚ä¢
  refine
    ‚ü®elementarySkolem‚ÇÅReduct (closure (L.sum L.skolem‚ÇÅ) (s ‚à™ Equiv.ulift '' s')),
      (s.subset_union_left).trans subset_closure, ?_‚ü©
  have h := mk_image_eq_lift _ s' Equiv.ulift.injective
  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h
  rw [coeSort_elementarySkolem‚ÇÅReduct, ‚Üê h, lift_inj]
  refine
    le_antisymm (lift_le.1 (lift_card_closure_le.trans ?_))
      (mk_le_mk_of_subset ((s.subset_union_right).trans subset_closure))
  rw [max_le_iff, aleph0_le_lift, ‚Üê aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]
  ¬∑ refine ‚ü®h1, (mk_union_le _ _).trans ?_, (lift_le.2 card_functions_sum_skolem‚ÇÅ_le).trans ?_‚ü©
    ¬∑ rw [‚Üê lift_le, lift_add, h, add_comm, add_eq_max h1]
      exact max_le le_rfl h2
    ¬∑ rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, ‚Üê lift_le.{w'},
        lift_lift, lift_lift, ‚Üê aleph0_le_lift, h]
      refine ‚ü®?_, h1‚ü©
      rw [‚Üê lift_lift.{w', w}]
      refine _root_.trans (lift_le.{w}.2 h3) ?_
      rw [lift_lift, ‚Üê lift_lift.{w, max u v}, ‚Üê hs', ‚Üê h, lift_lift]
  ¬∑ refine _root_.trans ?_ (lift_le.2 (mk_le_mk_of_subset Set.subset_union_right))
    rw [aleph0_le_lift, ‚Üê aleph0_le_lift, h]
    exact h1"
Mathlib/RingTheory/Multiplicity.lean,multiplicity.Finset.prod,Finset.prod,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
    induction' s with a s has ih h
    ¬∑ simp only [Finset.sum_empty, Finset.prod_empty]
      convert one_right hp.not_unit
    ¬∑ simp [has, ‚Üê ih]
      convert multiplicity.mul hp","error:  simp made no progress
error:  no goals to be solved","theorem Finset.prod {Œ≤ : Type*} {p : Œ±} (hp : Prime p) (s : Finset Œ≤) (f : Œ≤ ‚Üí Œ±) :
    multiplicity p (‚àè x ‚àà s, f x) = ‚àë x ‚àà s, multiplicity p (f x) ",":= by
  classical
    induction' s using Finset.induction with a s has ih h
    ¬∑ simp only [Finset.sum_empty, Finset.prod_empty]
      convert one_right hp.not_unit
    ¬∑ simp [has, ‚Üê ih]
      convert multiplicity.mul hp"
Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean,CircleDeg1Lift.tendsto_translationNumber_of_dist_bounded_aux,tendsto_translationNumber_of_dist_bounded_aux,9b5d788d575748c82ffdfc08ef4aaf0a3c6023f0,":= by
  refine f.tendsto_translationNumber_aux.congr_dist (squeeze_zero (fun _ => dist_nonneg) ?_ ?_)
  ¬∑ exact fun n => C / 2 ^ n
  ¬∑ intro n
    have : 0 < (2 ^ n : ‚Ñù) := pow_pos zero_lt_two _
    convert (div_le_div_right this).2 (H (2 ^ n)) using 1
    rw [transnumAuxSeq, Real.dist_eq, ‚Üê sub_div, abs_div, abs_of_pos this, Real.dist_eq]
  ¬∑ exact mul_zero C ‚ñ∏ tendsto_const_nhds.mul <| tendsto_inv_atTop_zero.comp <|
      tendsto_pow_atTop_atTop_of_one_lt one_lt_two","error:  don't know how to synthesize implicit argument 'g'
  @squeeze_zero ‚Ñï (fun x_1 ‚Ü¶ dist (f.transnumAuxSeq x_1) (x (2 ^ x_1) / 2 ^ x_1)) ?m.118405 atTop
    (fun x_1 ‚Ü¶ dist_nonneg) ?m.118451 ?m.118452
context:
f g : CircleDeg1Lift
x : ‚Ñï ‚Üí ‚Ñù
C : ‚Ñù
H : ‚àÄ (n : ‚Ñï), dist ((f ^ n) 0) (x n) ‚â§ C
‚ä¢ ‚Ñï ‚Üí ‚Ñù
error:  unsolved goals
f g : CircleDeg1Lift
x : ‚Ñï ‚Üí ‚Ñù
C : ‚Ñù
H : ‚àÄ (n : ‚Ñï), dist ((f ^ n) 0) (x n) ‚â§ C
‚ä¢ Tendsto (fun n ‚Ü¶ x (2 ^ n) / 2 ^ n) atTop (ùìù (œÑ f))","theorem tendsto_translationNumber_of_dist_bounded_aux (x : ‚Ñï ‚Üí ‚Ñù) (C : ‚Ñù)
    (H : ‚àÄ n : ‚Ñï, dist ((f ^ n) 0) (x n) ‚â§ C) :
    Tendsto (fun n : ‚Ñï => x (2 ^ n) / 2 ^ n) atTop (ùìù <| œÑ f) ",":= by
  apply f.tendsto_translationNumber_aux.congr_dist (squeeze_zero (fun _ => dist_nonneg) _ _)
  ¬∑ exact fun n => C / 2 ^ n
  ¬∑ intro n
    have : 0 < (2 ^ n : ‚Ñù) := pow_pos zero_lt_two _
    convert (div_le_div_right this).2 (H (2 ^ n)) using 1
    rw [transnumAuxSeq, Real.dist_eq, ‚Üê sub_div, abs_div, abs_of_pos this, Real.dist_eq]
  ¬∑ exact mul_zero C ‚ñ∏ tendsto_const_nhds.mul <| tendsto_inv_atTop_zero.comp <|
      tendsto_pow_atTop_atTop_of_one_lt one_lt_two"
Mathlib/GroupTheory/OrderOfElement.lean,IsOfFinOrder.mem_powers_iff_mem_zpowers,IsOfFinOrder.mem_powers_iff_mem_zpowers,4b292e8968c43193b3dbd022dfbc7ddc03b3a7a8,":=
  ‚ü®fun ‚ü®n, hn‚ü© ‚Ü¶ ‚ü®n, by simp_all‚ü©, fun ‚ü®i, hi‚ü© ‚Ü¶ ‚ü®(i % orderOf x).natAbs, by
    dsimp only
    rwa [‚Üê zpow_ofNat, Int.natAbs_of_nonneg <| Int.emod_nonneg _ <| Int.coe_nat_ne_zero_iff_pos.2 <|
      hx.orderOf_pos, zpow_mod_orderOf]‚ü©‚ü©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a ^ OfNat.ofNat ?n
G : Type u_1
H : Type u_2
A : Type u_3
Œ± : Type u_4
Œ≤ : Type u_5
inst‚úù : Group G
x y : G
i‚úù : ‚Ñ§
hx : IsOfFinOrder x
x‚úù : y ‚àà zpowers x
i : ‚Ñ§
hi : (fun x_1 ‚Ü¶ x ^ x_1) i = y
‚ä¢ x ^ (i % ‚Üë(orderOf x)).natAbs = y","lemma IsOfFinOrder.mem_powers_iff_mem_zpowers (hx : IsOfFinOrder x) :
    y ‚àà powers x ‚Üî y ‚àà zpowers x ",":=
  ‚ü®fun ‚ü®n, hn‚ü© ‚Ü¶ ‚ü®n, by simp_all‚ü©, fun ‚ü®i, hi‚ü© ‚Ü¶ ‚ü®(i % orderOf x).natAbs, by
    dsimp only
    rwa [‚Üê zpow_natCast, Int.natAbs_of_nonneg <| Int.emod_nonneg _ <|
      Int.natCast_ne_zero_iff_pos.2 <| hx.orderOf_pos, zpow_mod_orderOf]‚ü©‚ü©"
Mathlib/MeasureTheory/Constructions/Prod/Basic.lean,MeasureTheory.lintegral_prod_of_measurable,lintegral_prod_of_measurable,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  have m := @measurable_prod_mk_left
  refine Measurable.ennreal_induction
    (P := fun f => ‚à´‚Åª z, f z ‚àÇŒº.prod ŒΩ = ‚à´‚Åª x, ‚à´‚Åª y, f (x, y) ‚àÇŒΩ ‚àÇŒº) ?_ ??_ _
  ¬∑ intro c s hs
    conv_rhs =>
      enter [2, x, 2, y]
      rw [‚Üê indicator_comp_right, const_def, const_comp, ‚Üê const_def]
    conv_rhs =>
      enter [2, x]
      rw [lintegral_indicator _ (m (x := x) hs), lintegral_const,
        Measure.restrict_apply MeasurableSet.univ, univ_inter]
    simp [hs, lintegral_const_mul, measurable_measure_prod_mk_left (ŒΩ := ŒΩ) hs, prod_apply]
  ¬∑ rintro f g - hf _ h2f h2g
    simp only [Pi.add_apply]
    conv_lhs => rw [lintegral_add_left hf]
    conv_rhs => enter [2, x]; erw [lintegral_add_left (hf.comp (m (x := x)))]
    simp [lintegral_add_left, Measurable.lintegral_prod_right', hf, h2f, h2g]
  ¬∑ intro f hf h2f h3f
    have kf : ‚àÄ x n, Measurable fun y => f n (x, y) := fun x n => (hf n).comp m
    have k2f : ‚àÄ x, Monotone fun n y => f n (x, y) := fun x i j hij y => h2f hij (x, y)
    have lf : ‚àÄ n, Measurable fun x => ‚à´‚Åª y, f n (x, y) ‚àÇŒΩ := fun n => (hf n).lintegral_prod_right'
    have l2f : Monotone fun n x => ‚à´‚Åª y, f n (x, y) ‚àÇŒΩ := fun i j hij x =>
      lintegral_mono (k2f x hij)
    simp only [lintegral_iSup hf h2f, lintegral_iSup (kf _), k2f, lintegral_iSup lf l2f, h3f]","error:  unexpected token '?'; expected '_' or identifier
error:  unknown identifier 'lintegral_prod_of_measurable'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.195515
Œ± : Type u_1
Œ±' : Type u_2
Œ≤ : Type u_3
Œ≤' : Type u_4
Œ≥ : Type u_5
E : Type u_6
inst‚úù‚Å∂ : MeasurableSpace Œ±
inst‚úù‚Åµ : MeasurableSpace Œ±'
inst‚úù‚Å¥ : MeasurableSpace Œ≤
inst‚úù¬≥ : MeasurableSpace Œ≤'
inst‚úù¬≤ : MeasurableSpace Œ≥
Œº Œº' : Measure Œ±
ŒΩ ŒΩ' : Measure Œ≤
œÑ : Measure Œ≥
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : SFinite ŒΩ
f : Œ± √ó Œ≤ ‚Üí ‚Ñù‚â•0‚àû
hf : AEMeasurable f (Œº.prod ŒΩ)
A : ‚à´‚Åª (z : Œ± √ó Œ≤), f z ‚àÇŒº.prod ŒΩ = ‚à´‚Åª (z : Œ± √ó Œ≤), AEMeasurable.mk f hf z ‚àÇŒº.prod ŒΩ
B : ‚à´‚Åª (x : Œ±), ‚à´‚Åª (y : Œ≤), f (x, y) ‚àÇŒΩ ‚àÇŒº = ‚à´‚Åª (x : Œ±), ‚à´‚Åª (y : Œ≤), AEMeasurable.mk f hf (x, y) ‚àÇŒΩ ‚àÇŒº
‚ä¢ ‚à´‚Åª (z : Œ± √ó Œ≤), AEMeasurable.mk f hf z ‚àÇŒº.prod ŒΩ = ‚à´‚Åª (x : Œ±), ‚à´‚Åª (y : Œ≤), AEMeasurable.mk f hf (x, y) ‚àÇŒΩ ‚àÇŒº","theorem lintegral_prod_of_measurable :
    ‚àÄ (f : Œ± √ó Œ≤ ‚Üí ‚Ñù‚â•0‚àû), Measurable f ‚Üí ‚à´‚Åª z, f z ‚àÇŒº.prod ŒΩ = ‚à´‚Åª x, ‚à´‚Åª y, f (x, y) ‚àÇŒΩ ‚àÇŒº ",":= by
  have m := @measurable_prod_mk_left
  refine Measurable.ennreal_induction
    (P := fun f => ‚à´‚Åª z, f z ‚àÇŒº.prod ŒΩ = ‚à´‚Åª x, ‚à´‚Åª y, f (x, y) ‚àÇŒΩ ‚àÇŒº) ?_ ?_ ?_
  ¬∑ intro c s hs
    conv_rhs =>
      enter [2, x, 2, y]
      rw [‚Üê indicator_comp_right, const_def, const_comp, ‚Üê const_def]
    conv_rhs =>
      enter [2, x]
      rw [lintegral_indicator _ (m (x := x) hs), lintegral_const,
        Measure.restrict_apply MeasurableSet.univ, univ_inter]
    simp [hs, lintegral_const_mul, measurable_measure_prod_mk_left (ŒΩ := ŒΩ) hs, prod_apply]
  ¬∑ rintro f g - hf _ h2f h2g
    simp only [Pi.add_apply]
    conv_lhs => rw [lintegral_add_left hf]
    conv_rhs => enter [2, x]; erw [lintegral_add_left (hf.comp (m (x := x)))]
    simp [lintegral_add_left, Measurable.lintegral_prod_right', hf, h2f, h2g]
  ¬∑ intro f hf h2f h3f
    have kf : ‚àÄ x n, Measurable fun y => f n (x, y) := fun x n => (hf n).comp m
    have k2f : ‚àÄ x, Monotone fun n y => f n (x, y) := fun x i j hij y => h2f hij (x, y)
    have lf : ‚àÄ n, Measurable fun x => ‚à´‚Åª y, f n (x, y) ‚àÇŒΩ := fun n => (hf n).lintegral_prod_right'
    have l2f : Monotone fun n x => ‚à´‚Åª y, f n (x, y) ‚àÇŒΩ := fun i j hij x =>
      lintegral_mono (k2f x hij)
    simp only [lintegral_iSup hf h2f, lintegral_iSup (kf _), k2f, lintegral_iSup lf l2f, h3f]"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.single_add,single_add,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.single_add (Œ≤ := fun _ => M) a b‚ÇÅ b‚ÇÇ","warning:  Finsupp does not have a doc string
error:  unknown identifier 'DFinsupp.single_add'",theorem single_add (a : Œ±) (b‚ÇÅ b‚ÇÇ : M) : single a (b‚ÇÅ + b‚ÇÇ) = single a b‚ÇÅ + single a b‚ÇÇ ,":=
  (zipWith_single_single _ _ _ _ _).symm"
Mathlib/Algebra/AlgebraicCard.lean,Algebraic.cardinal_mk_lift_le_mul,cardinal_mk_lift_le_mul,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [‚Üê mk_uLift, ‚Üê mk_uLift]
  choose g hg‚ÇÅ hg‚ÇÇ using fun x : { x : A | IsAlgebraic R x } => x.coe_prop
  refine lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le g fun f => ?_
  rw [lift_le_aleph0, le_aleph0_iff_set_countable]
  suffices MapsTo (‚Üë) (g ‚Åª¬π' {f}) (f.rootSet A) from
    this.countable_of_injOn (Subtype.coe_injective.injOn _) (f.rootSet_finite A).countable
  rintro x (rfl : g x = f)
  exact mem_rootSet.2 ‚ü®hg‚ÇÅ x, hg‚ÇÇ x‚ü©","error:  application type mismatch
  MapsTo.countable_of_injOn this (Function.Injective.injOn Subtype.coe_injective ?m.5212)
argument
  Function.Injective.injOn Subtype.coe_injective ?m.5212
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Subtype ?m.5188‚¶Ñ, x‚ÇÇ ‚àà ?m.5210 ‚Üí ‚Üë?m.5211 = ‚Üëx‚ÇÇ ‚Üí ?m.5211 = x‚ÇÇ : Prop
but is expected to have type
  InjOn Subtype.val (g ‚Åª¬π' {f}) : Prop","theorem cardinal_mk_lift_le_mul :
    Cardinal.lift.{u} #{ x : A // IsAlgebraic R x } ‚â§ Cardinal.lift.{v} #R[X] * ‚Ñµ‚ÇÄ ",":= by
  rw [‚Üê mk_uLift, ‚Üê mk_uLift]
  choose g hg‚ÇÅ hg‚ÇÇ using fun x : { x : A | IsAlgebraic R x } => x.coe_prop
  refine lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le g fun f => ?_
  rw [lift_le_aleph0, le_aleph0_iff_set_countable]
  suffices MapsTo (‚Üë) (g ‚Åª¬π' {f}) (f.rootSet A) from
    this.countable_of_injOn Subtype.coe_injective.injOn (f.rootSet_finite A).countable
  rintro x (rfl : g x = f)
  exact mem_rootSet.2 ‚ü®hg‚ÇÅ x, hg‚ÇÇ x‚ü©"
Mathlib/Data/Set/NAry.lean,Set.image2_union_inter_subset,image2_union_inter_subset,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [image2_union_left]
  exact
    union_subset_union (image2_subset_left <| inter_subset_left _ _)
      (image2_subset_left <| inter_subset_right _ _)","error:  function expected at
  inter_subset_left ?m.46776
term has type
  ?m.46775 ‚àà ?m.46773
error:  function expected at
  inter_subset_right ?m.46832
term has type
  ?m.46831 ‚àà ?m.46830","theorem image2_union_inter_subset_union :
    image2 f (s ‚à™ s') (t ‚à© t') ‚äÜ image2 f s t ‚à™ image2 f s' t' ",":= by
  rw [image2_union_left]
  exact
    union_subset_union (image2_subset_left inter_subset_left)
      (image2_subset_left inter_subset_right)"
Mathlib/FieldTheory/NormalClosure.lean,IntermediateField.normalClosure_of_normal,normalClosure_of_normal,596865180ecc63dcd1d95809202e31027ac3ae38,:=,error:  unexpected token 'variable'; expected term,lemma normalClosure_of_normal [Normal F K] : normalClosure F K L = K ,":= by
  simp only [normalClosure_def, AlgHom.fieldRange_of_normal, iSup_const]"
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean,Embedding.comp_stronglyMeasurable_iff,_root_.Embedding.comp_stronglyMeasurable_iff,943f6a16d27a44766b2f93ca241caa09fa35467f,":= by
  letI := pseudoMetrizableSpacePseudoMetric Œ≥
  borelize Œ≤ Œ≥
  refine'
    ‚ü®fun H => stronglyMeasurable_iff_measurable_separable.2 ‚ü®_, _‚ü©, fun H =>
      hg.continuous.comp_stronglyMeasurable H‚ü©
  ¬∑ let G : Œ≤ ‚Üí range g := codRestrict g (range g) mem_range_self
    have hG : ClosedEmbedding G :=
      { hg.codRestrict _ _ with
        closed_range := by
          convert isClosed_univ (Œ± := ‚Ü•(range g))
          apply eq_univ_of_forall
          rintro ‚ü®-, ‚ü®x, rfl‚ü©‚ü©
          exact mem_range_self x }
    have : Measurable (G ‚àò f) := Measurable.subtype_mk H.measurable
    exact hG.measurableEmbedding.measurable_comp_iff.1 this
  ¬∑ have : IsSeparable (g ‚Åª¬π' range (g ‚àò f)) := hg.isSeparable_preimage H.isSeparable_range
    convert this
    ext x
    simp [hg.inj.eq_iff]",error:  'closed_range' is not a field of structure 'ClosedEmbedding',"theorem _root_.Embedding.comp_stronglyMeasurable_iff {m : MeasurableSpace Œ±} [TopologicalSpace Œ≤]
    [PseudoMetrizableSpace Œ≤] [TopologicalSpace Œ≥] [PseudoMetrizableSpace Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤}
    (hg : Embedding g) : (StronglyMeasurable fun x => g (f x)) ‚Üî StronglyMeasurable f ",":= by
  letI := pseudoMetrizableSpacePseudoMetric Œ≥
  borelize Œ≤ Œ≥
  refine
    ‚ü®fun H => stronglyMeasurable_iff_measurable_separable.2 ‚ü®?_, ?_‚ü©, fun H =>
      hg.continuous.comp_stronglyMeasurable H‚ü©
  ¬∑ let G : Œ≤ ‚Üí range g := rangeFactorization g
    have hG : ClosedEmbedding G :=
      { hg.codRestrict _ _ with
        isClosed_range := by
          rw [surjective_onto_range.range_eq]
          exact isClosed_univ }
    have : Measurable (G ‚àò f) := Measurable.subtype_mk H.measurable
    exact hG.measurableEmbedding.measurable_comp_iff.1 this
  ¬∑ have : IsSeparable (g ‚Åª¬π' range (g ‚àò f)) := hg.isSeparable_preimage H.isSeparable_range
    rwa [range_comp, hg.inj.preimage_image] at this"
Mathlib/RingTheory/LocalProperties.lean,multiple_mem_span_of_mem_localization_span,multiple_mem_span_of_mem_localization_span,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
  obtain ‚ü®s', hss', hs'‚ü© := Submodule.mem_span_finite_of_mem_span hx
  rsuffices ‚ü®t, ht‚ü© : ‚àÉ t : M, t ‚Ä¢ x ‚àà Submodule.span R (s' : Set N)
  ¬∑ exact ‚ü®t, Submodule.span_mono hss' ht‚ü©
  clear hx hss' s
  induction s' generalizing x
  ¬∑ use 1; simpa using hs'
  rename_i a s _ hs
  simp only [Finset.coe_insert, Finset.image_insert, Finset.coe_image, Subtype.coe_mk,
    Submodule.mem_span_insert] at hs' ‚ä¢
  rcases hs' with ‚ü®y, z, hz, rfl‚ü©
  rcases IsLocalization.surj M y with ‚ü®‚ü®y', s'‚ü©, e‚ü©
  apply congrArg (fun x ‚Ü¶ x ‚Ä¢ a) at e
  simp only [algebraMap_smul] at e
  rcases hs _ hz with ‚ü®t, ht‚ü©
  refine ‚ü®t * s', t * y', _, (Submodule.span R (s : Set N)).smul_mem s' ht, ?_‚ü©
  rw [smul_add, ‚Üê smul_smul, mul_comm, ‚Üê smul_smul, ‚Üê smul_smul, ‚Üê e, mul_comm, ‚Üê Algebra.smul_def]
  simp
  rfl","error:  type mismatch
  h‚úù
has type
  x ‚àà Submodule.span R' ‚Üë{ val := val‚úù, nodup := nodup‚úù } : Prop
but is expected to have type
  x ‚àà Submodule.span R ‚Üë{ val := val‚úù, nodup := nodup‚úù } : Prop
error:  no goals to be solved","theorem multiple_mem_span_of_mem_localization_span
    {N : Type*} [AddCommMonoid N] [Module R N] [Module R' N]
    [IsScalarTower R R' N] [IsLocalization M R'] (s : Set N) (x : N)
    (hx : x ‚àà Submodule.span R' s) : ‚àÉ (t : M), t ‚Ä¢ x ‚àà Submodule.span R s ",":= by
  classical
  obtain ‚ü®s', hss', hs'‚ü© := Submodule.mem_span_finite_of_mem_span hx
  rsuffices ‚ü®t, ht‚ü© : ‚àÉ t : M, t ‚Ä¢ x ‚àà Submodule.span R (s' : Set N)
  ¬∑ exact ‚ü®t, Submodule.span_mono hss' ht‚ü©
  clear hx hss' s
  induction s' using Finset.induction_on generalizing x
  ¬∑ use 1; simpa using hs'
  rename_i a s _ hs
  simp only [Finset.coe_insert, Finset.image_insert, Finset.coe_image, Subtype.coe_mk,
    Submodule.mem_span_insert] at hs' ‚ä¢
  rcases hs' with ‚ü®y, z, hz, rfl‚ü©
  rcases IsLocalization.surj M y with ‚ü®‚ü®y', s'‚ü©, e‚ü©
  apply congrArg (fun x ‚Ü¶ x ‚Ä¢ a) at e
  simp only [algebraMap_smul] at e
  rcases hs _ hz with ‚ü®t, ht‚ü©
  refine ‚ü®t * s', t * y', _, (Submodule.span R (s : Set N)).smul_mem s' ht, ?_‚ü©
  rw [smul_add, ‚Üê smul_smul, mul_comm, ‚Üê smul_smul, ‚Üê smul_smul, ‚Üê e, mul_comm, ‚Üê Algebra.smul_def]
  simp
  rfl"
Mathlib/RingTheory/DedekindDomain/Different.lean,isIntegral_discr_mul_of_mem_traceDual,isIntegral_discr_mul_of_mem_traceDual,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  have hinv : IsUnit (traceMatrix K b).det := by
    simpa [‚Üê discr_def] using discr_isUnit_of_basis _ b
  have H := mulVec_cramer (traceMatrix K b) fun i => trace K L (x * a * b i)
  have : Function.Injective (traceMatrix K b).mulVec
  ¬∑ rwa [mulVec_injective_iff_isUnit, isUnit_iff_isUnit_det]
  rw [‚Üê traceMatrix_of_basis_mulVec, ‚Üê mulVec_smul, this.eq_iff,
    traceMatrix_of_basis_mulVec] at H
  rw [‚Üê b.equivFun.symm_apply_apply (_ * _), b.equivFun_symm_apply]
  apply IsIntegral.sum
  intro i _
  rw [smul_mul_assoc, b.equivFun.map_smul, discr_def, mul_comm, ‚Üê H, Algebra.smul_def]
  refine RingHom.IsIntegralElem.mul _ ?_ (hb _)
  apply IsIntegral.algebraMap
  rw [cramer_apply]
  apply IsIntegral.det
  intros j k
  rw [updateColumn_apply]
  split
  ¬∑ rw [mul_assoc]
    rw [mem_traceDual_iff_isIntegral] at hx
    apply hx
    have ‚ü®y, hy‚ü© := (IsIntegralClosure.isIntegral_iff (A := B)).mp (hb j)
    rw [mul_comm, ‚Üê hy, ‚Üê Algebra.smul_def]
    exact I.smul_mem _ (ha)
  ¬∑ exact isIntegral_trace (RingHom.IsIntegralElem.mul _ (hb j) (hb k))","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
A : Type u_1
K : Type u_2
L : Type u
B : Type u_3
inst‚úù¬≤‚Å∞ : CommRing A
inst‚úù¬π‚Åπ : Field K
inst‚úù¬π‚Å∏ : CommRing B
inst‚úù¬π‚Å∑ : Field L
inst‚úù¬π‚Å∂ : Algebra A K
inst‚úù¬π‚Åµ : Algebra B L
inst‚úù¬π‚Å¥ : Algebra A B
inst‚úù¬π¬≥ : Algebra K L
inst‚úù¬π¬≤ : Algebra A L
inst‚úù¬π¬π : IsScalarTower A K L
inst‚úù¬π‚Å∞ : IsScalarTower A B L
inst‚úù‚Åπ : IsDomain A
inst‚úù‚Å∏ : IsDomain B
inst‚úù‚Å∑ : IsFractionRing A K
inst‚úù‚Å∂ : IsIntegralClosure B A L
inst‚úù‚Åµ : IsFractionRing B L
inst‚úù‚Å¥ : FiniteDimensional K L
inst‚úù¬≥ : IsSeparable K L
inst‚úù¬≤ : IsIntegrallyClosed A
I : Submodule B L
Œπ : Type u_4
inst‚úù¬π : DecidableEq Œπ
inst‚úù : Fintype Œπ
b : Basis Œπ K L
hb : ‚àÄ (i : Œπ), IsIntegral A (b i)
a x : L
ha : a ‚àà I
hx : x ‚àà I·µõ
hinv : IsUnit (traceMatrix K ‚áëb).det
H :
  (traceMatrix K ‚áëb *·µ• (traceMatrix K ‚áëb).cramer fun i ‚Ü¶ (Algebra.trace K L) (x * a * b i)) =
    (traceMatrix K ‚áëb).det ‚Ä¢ fun i ‚Ü¶ (Algebra.trace K L) (x * a * b i)
this : Function.Injective (traceMatrix K ‚áëb).mulVec
‚ä¢ IsIntegral A (discr K ‚áëb ‚Ä¢ a * x)","lemma isIntegral_discr_mul_of_mem_traceDual
    (I : Submodule B L) {Œπ} [DecidableEq Œπ] [Fintype Œπ]
    {b : Basis Œπ K L} (hb : ‚àÄ i, IsIntegral A (b i))
    {a x : L} (ha : a ‚àà I) (hx : x ‚àà I·µõ) :
    IsIntegral A ((discr K b) ‚Ä¢ a * x) ",":= by
  have hinv : IsUnit (traceMatrix K b).det := by
    simpa [‚Üê discr_def] using discr_isUnit_of_basis _ b
  have H := mulVec_cramer (traceMatrix K b) fun i => trace K L (x * a * b i)
  have : Function.Injective (traceMatrix K b).mulVec := by
    rwa [mulVec_injective_iff_isUnit, isUnit_iff_isUnit_det]
  rw [‚Üê traceMatrix_of_basis_mulVec, ‚Üê mulVec_smul, this.eq_iff,
    traceMatrix_of_basis_mulVec] at H
  rw [‚Üê b.equivFun.symm_apply_apply (_ * _), b.equivFun_symm_apply]
  apply IsIntegral.sum
  intro i _
  rw [smul_mul_assoc, b.equivFun.map_smul, discr_def, mul_comm, ‚Üê H, Algebra.smul_def]
  refine RingHom.IsIntegralElem.mul _ ?_ (hb _)
  apply IsIntegral.algebraMap
  rw [cramer_apply]
  apply IsIntegral.det
  intros j k
  rw [updateColumn_apply]
  split
  ¬∑ rw [mul_assoc]
    rw [mem_traceDual_iff_isIntegral] at hx
    apply hx
    have ‚ü®y, hy‚ü© := (IsIntegralClosure.isIntegral_iff (A := B)).mp (hb j)
    rw [mul_comm, ‚Üê hy, ‚Üê Algebra.smul_def]
    exact I.smul_mem _ (ha)
  ¬∑ exact isIntegral_trace (RingHom.IsIntegralElem.mul _ (hb j) (hb k))"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.hausdorffMeasure_pi_real,hausdorffMeasure_pi_real,ced4d3c0af763b9fd00166e49cf999cf46c891cc,":= by
  classical
  refine (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)
    (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) _).symm
  simp only [mem_iUnion, mem_singleton_iff]
  intro s hs
  choose a b H using hs
  obtain rfl : s = fun i => Ioo (Œ± := ‚Ñù) (a i) (b i) := funext fun i => (H i).2
  replace H := fun i => (H i).1
  apply le_antisymm _
  ¬∑ have Hle : volume ‚â§ (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) := by
      refine le_hausdorffMeasure _ _ ‚àû ENNReal.coe_lt_top fun s _ => _
      rw [ENNReal.rpow_natCast]
      exact Real.volume_pi_le_diam_pow s
    rw [‚Üê volume_pi_pi fun i => Ioo (a i : ‚Ñù) (b i)]
    exact Measure.le_iff'.1 Hle _
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := fun i => by
    simpa only [sub_nonneg, Rat.cast_le] using (H i).le
  let Œ≥ := fun n : ‚Ñï => ‚àÄ i : Œπ, Fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä
  let t : ‚àÄ n : ‚Ñï, Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f =>
    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)
  have A : Tendsto (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) atTop (ùìù 0) := by
    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]
  have B : ‚àÄ·∂† n in atTop, ‚àÄ i : Œ≥ n, diam (t n i) ‚â§ 1 / n := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
    intro f
    refine diam_pi_le_of_le fun b => _
    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel_left, ENNReal.ofReal_one, ENNReal.ofReal_natCast]
  have C : ‚àÄ·∂† n in atTop, (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ i : Œ≥ n, t n i := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
    have npos : (0 : ‚Ñù) < n := Nat.cast_pos.2 hn
    intro x hx
    simp only [mem_Ioo, mem_univ_pi] at hx
    simp only [t, mem_iUnion, mem_Ioo, mem_univ_pi]
    let f : Œ≥ n := fun i =>
      ‚ü®‚åä(x i - a i) * n‚åã‚Çä, by
        apply Nat.floor_lt_ceil_of_lt_of_pos
        ¬∑ refine (mul_lt_mul_right npos).2 _
          simp only [(hx i).right, sub_lt_sub_iff_right]
        ¬∑ refine mul_pos _ npos
          simpa only [Rat.cast_lt, sub_pos] using H i‚ü©
    refine ‚ü®f, fun i => ‚ü®_, _‚ü©‚ü©
    ¬∑ calc
        (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + (x i - a i) * n / n := by
          gcongr
          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
        _ = x i := by field_simp [npos.ne']
    ¬∑ calc
        x i = (a i : ‚Ñù) + (x i - a i) * n / n := by field_simp [npos.ne']
        _ ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n := by
          gcongr
          exact (Nat.lt_floor_add_one _).le
  calc
    ŒºH[Fintype.card Œπ] (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚â§
        liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, diam (t n i) ^ ((Fintype.card Œπ) : ‚Ñù)) atTop :=
      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : ‚Ñù) (b i))
        (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) A t B C
    _ ‚â§ liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, (1 / (n : ‚Ñù‚â•0‚àû)) ^ Fintype.card Œπ) atTop := by
      refine liminf_le_liminf _ _
      ¬∑ filter_upwards [B] with _ hn
        apply Finset.sum_le_sum fun i _ => _
        simp only [ENNReal.rpow_natCast]
        intros i _
        exact pow_le_pow_left' (hn i) _
      ¬∑ isBoundedDefault
    _ = liminf (fun n : ‚Ñï => ‚àè i : Œπ, (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) atTop := by
      simp only [Œ≥, Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
    _ = ‚àè i : Œπ, volume (Ioo (a i : ‚Ñù) (b i)) := by
      simp only [Real.volume_Ioo]
      apply Tendsto.liminf_eq
      refine ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => _) fun i _ => _
      ¬∑ apply
          Tendsto.congr' _
            ((ENNReal.continuous_ofReal.tendsto _).comp
              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_natCast_atTop_atTop))
        apply eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
        intros n hn
        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,
          ENNReal.ofReal_natCast]
      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne, not_false_iff]","error:  don't know how to synthesize placeholder for argument 'h‚ÇÅ'
context:
Œπ‚úù : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù‚Å∂ : EMetricSpace X
inst‚úù‚Åµ : EMetricSpace Y
inst‚úù‚Å¥ : MeasurableSpace X
inst‚úù¬≥ : BorelSpace X
inst‚úù¬≤ : MeasurableSpace Y
inst‚úù¬π : BorelSpace Y
Œπ : Type u_4
inst‚úù : Fintype Œπ
‚ä¢ ‚àÄ (s : Œπ ‚Üí Set ‚Ñù),
    (‚àÄ (i : Œπ), s i ‚àà ‚ãÉ a, ‚ãÉ b, ‚ãÉ (_ : a < b), {Ioo ‚Üëa ‚Üëb}) ‚Üí ŒºH[‚Üë(Fintype.card Œπ)] (univ.pi s) = ‚àè i : Œπ, volume (s i)
error:  unsolved goals
Œπ‚úù : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù‚Å∂ : EMetricSpace X
inst‚úù‚Åµ : EMetricSpace Y
inst‚úù‚Å¥ : MeasurableSpace X
inst‚úù¬≥ : BorelSpace X
inst‚úù¬≤ : MeasurableSpace Y
inst‚úù¬π : BorelSpace Y
Œπ : Type u_4
inst‚úù : Fintype Œπ
‚ä¢ ŒºH[‚Üë(Fintype.card Œπ)] = volume","theorem hausdorffMeasure_pi_real {Œπ : Type*} [Fintype Œπ] :
    (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) = volume ",":= by
  classical
  refine (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)
    (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) ?_).symm
  simp only [mem_iUnion, mem_singleton_iff]
  intro s hs
  choose a b H using hs
  obtain rfl : s = fun i => Ioo (Œ± := ‚Ñù) (a i) (b i) := funext fun i => (H i).2
  replace H := fun i => (H i).1
  apply le_antisymm _
  ¬∑ have Hle : volume ‚â§ (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) := by
      refine le_hausdorffMeasure _ _ ‚àû ENNReal.coe_lt_top fun s _ => ?_
      rw [ENNReal.rpow_natCast]
      exact Real.volume_pi_le_diam_pow s
    rw [‚Üê volume_pi_pi fun i => Ioo (a i : ‚Ñù) (b i)]
    exact Measure.le_iff'.1 Hle _
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := fun i => by
    simpa only [sub_nonneg, Rat.cast_le] using (H i).le
  let Œ≥ := fun n : ‚Ñï => ‚àÄ i : Œπ, Fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä
  let t : ‚àÄ n : ‚Ñï, Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f =>
    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)
  have A : Tendsto (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) atTop (ùìù 0) := by
    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]
  have B : ‚àÄ·∂† n in atTop, ‚àÄ i : Œ≥ n, diam (t n i) ‚â§ 1 / n := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => ?_‚ü©
    intro f
    refine diam_pi_le_of_le fun b => ?_
    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel_left, ENNReal.ofReal_one, ENNReal.ofReal_natCast]
  have C : ‚àÄ·∂† n in atTop, (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ i : Œ≥ n, t n i := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => ?_‚ü©
    have npos : (0 : ‚Ñù) < n := Nat.cast_pos.2 hn
    intro x hx
    simp only [mem_Ioo, mem_univ_pi] at hx
    simp only [t, mem_iUnion, mem_Ioo, mem_univ_pi]
    let f : Œ≥ n := fun i =>
      ‚ü®‚åä(x i - a i) * n‚åã‚Çä, by
        apply Nat.floor_lt_ceil_of_lt_of_pos
        ¬∑ refine (mul_lt_mul_right npos).2 ?_
          simp only [(hx i).right, sub_lt_sub_iff_right]
        ¬∑ refine mul_pos ?_ npos
          simpa only [Rat.cast_lt, sub_pos] using H i‚ü©
    refine ‚ü®f, fun i => ‚ü®?_, ?_‚ü©‚ü©
    ¬∑ calc
        (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + (x i - a i) * n / n := by
          gcongr
          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
        _ = x i := by field_simp [npos.ne']
    ¬∑ calc
        x i = (a i : ‚Ñù) + (x i - a i) * n / n := by field_simp [npos.ne']
        _ ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n := by
          gcongr
          exact (Nat.lt_floor_add_one _).le
  calc
    ŒºH[Fintype.card Œπ] (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚â§
        liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, diam (t n i) ^ ((Fintype.card Œπ) : ‚Ñù)) atTop :=
      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : ‚Ñù) (b i))
        (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) A t B C
    _ ‚â§ liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, (1 / (n : ‚Ñù‚â•0‚àû)) ^ Fintype.card Œπ) atTop := by
      refine liminf_le_liminf ?_ ?_
      ¬∑ filter_upwards [B] with _ hn
        apply Finset.sum_le_sum fun i _ => _
        simp only [ENNReal.rpow_natCast]
        intros i _
        exact pow_le_pow_left' (hn i) _
      ¬∑ isBoundedDefault
    _ = liminf (fun n : ‚Ñï => ‚àè i : Œπ, (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) atTop := by
      simp only [Œ≥, Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
    _ = ‚àè i : Œπ, volume (Ioo (a i : ‚Ñù) (b i)) := by
      simp only [Real.volume_Ioo]
      apply Tendsto.liminf_eq
      refine ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => ?_) fun i _ => ?_
      ¬∑ apply
          Tendsto.congr' _
            ((ENNReal.continuous_ofReal.tendsto _).comp
              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_natCast_atTop_atTop))
        apply eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
        intros n hn
        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,
          ENNReal.ofReal_natCast]
      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne, not_false_iff]"
Mathlib/FieldTheory/Normal.lean,AlgHom.normal_bijective,AlgHom.normal_bijective,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  h.isAlgebraic'.bijective_of_isScalarTower' œï","error:  invalid field 'isAlgebraic'', the environment does not contain 'Normal.isAlgebraic''
  h
has type
  Normal F E",theorem AlgHom.normal_bijective [h : Normal F E] (œï : E ‚Üí‚Çê[F] K) : Function.Bijective œï ,":=
  h.toIsAlgebraic.bijective_of_isScalarTower' œï"
Mathlib/Data/List/Indexes.lean,List.indexesValues_eq_filter_enum,indexesValues_eq_filter_enum,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp (config := { unfoldPartialApp := true }) [indexesValues, foldrIdx_eq_foldr_enum, uncurry,
    filter_eq_foldr]","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
error:  unsolved goals
Œ± : Type u
Œ≤ : Type v
p : Œ± ‚Üí Prop
inst‚úù : DecidablePred p
as : List Œ±
‚ä¢ foldr (fun a l ‚Ü¶ if p a.2 then a :: l else l) [] as.enum =
    foldr (fun a out ‚Ü¶ bif decide (p a.2) then a :: out else out) [] as.enum","theorem indexesValues_eq_filter_enum (p : Œ± ‚Üí Prop) [DecidablePred p] (as : List Œ±) :
    indexesValues p as = filter (p ‚àò Prod.snd) (enum as) ",":= by
  simp (config := { unfoldPartialApp := true }) [indexesValues, foldrIdx_eq_foldr_enum, uncurry,
    filter_eq_foldr, cond_eq_if]"
Mathlib/MeasureTheory/Function/LocallyIntegrable.lean,MeasureTheory.locallyIntegrableOn_iff,locallyIntegrableOn_iff,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  refine' ‚ü®fun hf k hk => hf.integrableOn_compact_subset hk, fun hf x hx => _‚ü©
  cases hs with
  | inl hs =>
    exact
      let ‚ü®K, hK, h2K‚ü© := exists_compact_mem_nhds x
      ‚ü®_, inter_mem_nhdsWithin s h2K,
        hf _ (inter_subset_left _ _)
          (hK.of_isClosed_subset (hs.inter hK.isClosed) (inter_subset_right _ _))‚ü©
  | inr hs =>
    obtain ‚ü®K, hK, h2K, h3K‚ü© := exists_compact_subset hs hx
    refine ‚ü®K, ?_, hf K h3K hK‚ü©
    simpa only [IsOpen.nhdsWithin_eq hs hx, interior_eq_nhds'] using h2K","error:  function expected at
  inter_subset_left ?m.10496
term has type
  ?m.10495 ‚àà ?m.10493
error:  function expected at
  inter_subset_right ?m.10593
term has type
  ?m.10592 ‚àà ?m.10591","theorem locallyIntegrableOn_iff [LocallyCompactSpace X] [T2Space X] (hs : IsClosed s ‚à® IsOpen s) :
    LocallyIntegrableOn f s Œº ‚Üî ‚àÄ (k : Set X), k ‚äÜ s ‚Üí (IsCompact k ‚Üí IntegrableOn f k Œº) ",":= by
  refine ‚ü®fun hf k hk => hf.integrableOn_compact_subset hk, fun hf x hx => ?_‚ü©
  cases hs with
  | inl hs =>
    exact
      let ‚ü®K, hK, h2K‚ü© := exists_compact_mem_nhds x
      ‚ü®_, inter_mem_nhdsWithin s h2K,
        hf _ inter_subset_left
          (hK.of_isClosed_subset (hs.inter hK.isClosed) inter_subset_right)‚ü©
  | inr hs =>
    obtain ‚ü®K, hK, h2K, h3K‚ü© := exists_compact_subset hs hx
    refine ‚ü®K, ?_, hf K h3K hK‚ü©
    simpa only [IsOpen.nhdsWithin_eq hs hx, interior_eq_nhds'] using h2K"
Mathlib/Topology/Homotopy/HomotopyGroup.lean,GenLoop.homotopicTo,homotopicTo,0620eae008483cf7a815cce7f68256e53d6d8ac2,":= by
  refine Nonempty.map fun H => ‚ü®‚ü®‚ü®fun t => ‚ü®homotopyTo i H t, ?_‚ü©, ?_‚ü©, ?_, ?_?‚ü©, _‚ü©
  ¬∑ rintro y ‚ü®i, iH‚ü©
    rw [homotopyTo_apply, H.eq_fst, p.2]
    all_goals apply Cube.insertAt_boundary; right; exact ‚ü®i, iH‚ü©
  ¬∑ continuity
  iterate 2 intro; ext; erw [homotopyTo_apply, toLoop_apply]; swap
  ¬∑ apply H.apply_zero
  ¬∑ apply H.apply_one
  intro t y yH
  ext; erw [homotopyTo_apply]
  apply H.eq_fst; use i
  rw [funSplitAt_symm_apply, dif_pos rfl]; exact yH","warning:  GenLoop does not have a doc string
error:  don't know how to synthesize placeholder for argument 'prop''
context:
N : Type u_1
X : Type u_2
inst‚úù¬π : TopologicalSpace X
x : X
inst‚úù : DecidableEq N
i : N
p q : ‚Üë(Œ©^ N X x)
H : (‚Üëp).HomotopyRel (‚Üëq) (Cube.boundary N)
‚ä¢ ‚àÄ (t x_1 : ‚ÜëI),
    x_1 ‚àà {0, 1} ‚Üí
      {
            toFun := fun x_2 ‚Ü¶
              { toFun := fun t ‚Ü¶ ‚ü®(homotopyTo i H) t, ‚ãØ‚ü©, continuous_toFun := ?m.172348, map_zero_left := ?m.172405,
                    map_one_left := ?_? }.toFun
                (t, x_2),
            continuous_toFun := ‚ãØ }
          x_1 =
        (toLoop i p).toContinuousMap x_1
error:  unsolved goals
N : Type u_1
X : Type u_2
inst‚úù¬π : TopologicalSpace X
x : X
inst‚úù : DecidableEq N
i : N
p q : ‚Üë(Œ©^ N X x)
‚ä¢ Homotopic p q ‚Üí Path.Homotopic (toLoop i p) (toLoop i q)","theorem homotopicTo (i : N) {p q : Œ©^ N X x} :
    Homotopic p q ‚Üí (toLoop i p).Homotopic (toLoop i q) ",":= by
  refine Nonempty.map fun H => ‚ü®‚ü®‚ü®fun t => ‚ü®homotopyTo i H t, ?_‚ü©, ?_‚ü©, ?_, ?_‚ü©, ?_‚ü©
  ¬∑ rintro y ‚ü®i, iH‚ü©
    rw [homotopyTo_apply, H.eq_fst, p.2]
    all_goals apply Cube.insertAt_boundary; right; exact ‚ü®i, iH‚ü©
  ¬∑ continuity
  iterate 2 intro; ext; erw [homotopyTo_apply, toLoop_apply]; swap
  ¬∑ apply H.apply_zero
  ¬∑ apply H.apply_one
  intro t y yH
  ext; erw [homotopyTo_apply]
  apply H.eq_fst; use i
  rw [funSplitAt_symm_apply, dif_pos rfl]; exact yH"
Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean,EuclideanGeometry.angle_const_vadd,angle_const_vadd,2094018833793261c76e9c1bd65b8ce67507a994,":=
  (AffineIsometryEquiv.constVadd ‚Ñù P v).toAffineIsometry.angle_map _ _ _","warning:  @angle does not have a doc string
error:  unknown constant 'AffineIsometryEquiv.constVadd'",theorem angle_const_vadd (v : V) (p‚ÇÅ p‚ÇÇ p‚ÇÉ : P) : ‚à† (v +·µ• p‚ÇÅ) (v +·µ• p‚ÇÇ) (v +·µ• p‚ÇÉ) = ‚à† p‚ÇÅ p‚ÇÇ p‚ÇÉ ,":=
  (AffineIsometryEquiv.constVAdd ‚Ñù P v).toAffineIsometry.angle_map _ _ _"
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,affineSpan_eq_bot,affineSpan_eq_bot,6aa938732f4bd703b82127542018850f5874e784,":= by
  rw [‚Üê not_iff_not, ‚Üê Ne.def, ‚Üê Ne.def, ‚Üê nonempty_iff_ne_bot, affineSpan_nonempty,
    nonempty_iff_ne_empty]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.309394 ‚Üí ?m.309394 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.309396
k : Type u_1
V : Type u_2
P : Type u_3
inst‚úù¬≥ : Ring k
inst‚úù¬≤ : AddCommGroup V
inst‚úù¬π : Module k V
inst‚úù : AffineSpace V P
Œπ : Type u_4
s : Set P
‚ä¢ ¬¨affineSpan k s = ‚ä• ‚Üî ¬¨s = ‚àÖ
warning:  @AffineSubspace.Parallel does not have a doc string",theorem affineSpan_eq_bot : affineSpan k s = ‚ä• ‚Üî s = ‚àÖ ,":= by
  rw [‚Üê not_iff_not, ‚Üê Ne, ‚Üê Ne, ‚Üê nonempty_iff_ne_bot, affineSpan_nonempty,
    nonempty_iff_ne_empty]"
Mathlib/Topology/Algebra/Valuation.lean,Valuation.subgroups_basis,subgroups_basis,14c729603a56a1a02f31a1b28b852fe56d29c058,":=
  { inter := by
      rintro Œ≥‚ÇÄ Œ≥‚ÇÅ
      use min Œ≥‚ÇÄ Œ≥‚ÇÅ
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro Œ≥
      cases' exists_square_le Œ≥ with Œ≥‚ÇÄ h
      use Œ≥‚ÇÄ
      rintro - ‚ü®r, s, r_in, s_in, rfl‚ü©
      calc
        (v (r * s) : Œì‚ÇÄ) = v r * v s := Valuation.map_mul _ _ _
        _ < Œ≥‚ÇÄ * Œ≥‚ÇÄ := (mul_lt_mul‚ÇÄ r_in s_in)
        _ ‚â§ Œ≥ := mod_cast h
    leftMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use (1 : Œì‚ÇÄÀ£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (x * y) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt
    rightMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (y * x) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt }","error:  application type mismatch
  v s
argument
  s
has type
  r ‚àà ‚Üë(v.ltAddSubgroup Œ≥‚ÇÄ) : Prop
but is expected to have type
  R : Type u
error:  invalid 'calc' step, failed to synthesize `Trans` instance
  Trans LT.lt Membership.mem ?m.11018
use `set_option diagnostics true` to get diagnostic information",theorem subgroups_basis : RingSubgroupsBasis fun Œ≥ : Œì‚ÇÄÀ£ => (v.ltAddSubgroup Œ≥ : AddSubgroup R) ,":=
  { inter := by
      rintro Œ≥‚ÇÄ Œ≥‚ÇÅ
      use min Œ≥‚ÇÄ Œ≥‚ÇÅ
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro Œ≥
      cases' exists_square_le Œ≥ with Œ≥‚ÇÄ h
      use Œ≥‚ÇÄ
      rintro - ‚ü®r, r_in, s, s_in, rfl‚ü©
      calc
        (v (r * s) : Œì‚ÇÄ) = v r * v s := Valuation.map_mul _ _ _
        _ < Œ≥‚ÇÄ * Œ≥‚ÇÄ := mul_lt_mul‚ÇÄ r_in s_in
        _ ‚â§ Œ≥ := mod_cast h
    leftMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use (1 : Œì‚ÇÄÀ£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (x * y) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt
    rightMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (y * x) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt }"
Mathlib/ModelTheory/Satisfiability.lean,Cardinal.Categorical.isComplete,Categorical.isComplete,b1cd52acffa53bca04a33ddc14a40b2a62ed4308,":=
  ‚ü®hS, fun œÜ => by
    obtain ‚ü®_, _‚ü© := Theory.exists_model_card_eq ‚ü®hS.some, hT hS.some‚ü© Œ∫ h1 h2
    rw [Theory.models_sentence_iff, Theory.models_sentence_iff]
    by_contra' con
    obtain ‚ü®‚ü®MF, hMF‚ü©, MT, hMT‚ü© := con
    rw [Sentence.realize_not, Classical.not_not] at hMT
    refine' hMF _
    haveI := hT MT
    haveI := hT MF
    obtain ‚ü®NT, MNT, hNT‚ü© := exists_elementarilyEquivalent_card_eq L MT Œ∫ h1 h2
    obtain ‚ü®NF, MNF, hNF‚ü© := exists_elementarilyEquivalent_card_eq L MF Œ∫ h1 h2
    obtain ‚ü®TF‚ü© := h (MNT.toModel T) (MNF.toModel T) hNT hNF
    exact
      ((MNT.realize_sentence œÜ).trans
        ((TF.realize_sentence œÜ).trans (MNF.realize_sentence œÜ).symm)).1 hMT‚ü©","warning:  @ModelsBoundedFormula does not have a doc string
error:  unknown tactic
error:  unsolved goals
case intro
L : Language
Œ∫ : Cardinal.{w}
T : L.Theory
h : Œ∫.Categorical T
h1 : ‚Ñµ‚ÇÄ ‚â§ Œ∫
h2 : lift.{w, max u v} L.card ‚â§ lift.{max u v, w} Œ∫
hS : T.IsSatisfiable
hT : ‚àÄ (M : T.ModelType), Infinite ‚ÜëM
œÜ : L.Sentence
w‚úù : T.ModelType
h‚úù : #‚Üëw‚úù = Œ∫
‚ä¢ (‚àÄ (M : T.ModelType), ‚ÜëM ‚ä® œÜ) ‚à® ‚àÄ (M : T.ModelType), ‚ÜëM ‚ä® Formula.not œÜ","theorem Categorical.isComplete (h : Œ∫.Categorical T) (h1 : ‚Ñµ‚ÇÄ ‚â§ Œ∫)
    (h2 : Cardinal.lift.{w} L.card ‚â§ Cardinal.lift.{max u v} Œ∫) (hS : T.IsSatisfiable)
    (hT : ‚àÄ M : Theory.ModelType.{u, v, max u v} T, Infinite M) : T.IsComplete ",":=
  ‚ü®hS, fun œÜ => by
    obtain ‚ü®_, _‚ü© := Theory.exists_model_card_eq ‚ü®hS.some, hT hS.some‚ü© Œ∫ h1 h2
    rw [Theory.models_sentence_iff, Theory.models_sentence_iff]
    by_contra! con
    obtain ‚ü®‚ü®MF, hMF‚ü©, MT, hMT‚ü© := con
    rw [Sentence.realize_not, Classical.not_not] at hMT
    refine hMF ?_
    haveI := hT MT
    haveI := hT MF
    obtain ‚ü®NT, MNT, hNT‚ü© := exists_elementarilyEquivalent_card_eq L MT Œ∫ h1 h2
    obtain ‚ü®NF, MNF, hNF‚ü© := exists_elementarilyEquivalent_card_eq L MF Œ∫ h1 h2
    obtain ‚ü®TF‚ü© := h (MNT.toModel T) (MNF.toModel T) hNT hNF
    exact
      ((MNT.realize_sentence œÜ).trans
        ((TF.realize_sentence œÜ).trans (MNF.realize_sentence œÜ).symm)).1 hMT‚ü©"
Mathlib/SetTheory/Cardinal/SchroederBernstein.lean,Function.Embedding.schroeder_bernstein,schroeder_bernstein,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  cases' isEmpty_or_nonempty Œ≤ with hŒ≤ hŒ≤
  ¬∑ have : IsEmpty Œ± := Function.isEmpty f
    exact ‚ü®_, ((Equiv.equivEmpty Œ±).trans (Equiv.equivEmpty Œ≤).symm).bijective‚ü©
  set F : Set Œ± ‚Üío Set Œ± :=
    { toFun := fun s => (g '' (f '' s)·∂ú)·∂ú
      monotone' := fun s t hst =>
        compl_subset_compl.mpr <| image_subset _ <| compl_subset_compl.mpr <| image_subset _ hst }
  set s : Set Œ± := OrderHom.lfp F
  have hs : (g '' (f '' s)·∂ú)·∂ú = s := F.map_lfp
  have hns : g '' (f '' s)·∂ú = s·∂ú := compl_injective (by simp [hs])
  set g' := invFun g
  have g'g : LeftInverse g' g := leftInverse_invFun hg
  have hg'ns : g' '' s·∂ú = (f '' s)·∂ú := by rw [‚Üê hns, g'g.image_image]
  set h : Œ± ‚Üí Œ≤ := s.piecewise f g'
  have : Surjective h := by rw [‚Üê range_iff_surjective, range_piecewise, hg'ns, union_compl_self]
  have : Injective h := by
    refine' (injective_piecewise_iff _).2 ‚ü®hf.injOn _, _, _‚ü©
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®x', _, rfl‚ü© : x ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      obtain ‚ü®y', _, rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _, g'g _] at hxy
      rw [hxy]
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®y', hy', rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _] at hxy
      exact hy' ‚ü®x, hx, hxy‚ü©
  exact ‚ü®h, ‚ÄπInjective h‚Ä∫, ‚ÄπSurjective h‚Ä∫‚ü©","error:  application type mismatch
  And.intro (Injective.injOn hf ?m.1813)
argument
  Injective.injOn hf ?m.1813
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Œ±‚¶Ñ, x‚ÇÇ ‚àà ?m.1811 ‚Üí f ?m.1812 = f x‚ÇÇ ‚Üí ?m.1812 = x‚ÇÇ : Prop
but is expected to have type
  InjOn f s : Prop","theorem schroeder_bernstein {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ±} (hf : Function.Injective f)
    (hg : Function.Injective g) : ‚àÉ h : Œ± ‚Üí Œ≤, Bijective h ",":= by
  cases' isEmpty_or_nonempty Œ≤ with hŒ≤ hŒ≤
  ¬∑ have : IsEmpty Œ± := Function.isEmpty f
    exact ‚ü®_, ((Equiv.equivEmpty Œ±).trans (Equiv.equivEmpty Œ≤).symm).bijective‚ü©
  set F : Set Œ± ‚Üío Set Œ± :=
    { toFun := fun s => (g '' (f '' s)·∂ú)·∂ú
      monotone' := fun s t hst =>
        compl_subset_compl.mpr <| image_subset _ <| compl_subset_compl.mpr <| image_subset _ hst }
  set s : Set Œ± := OrderHom.lfp F
  have hs : (g '' (f '' s)·∂ú)·∂ú = s := F.map_lfp
  have hns : g '' (f '' s)·∂ú = s·∂ú := compl_injective (by simp [hs])
  set g' := invFun g
  have g'g : LeftInverse g' g := leftInverse_invFun hg
  have hg'ns : g' '' s·∂ú = (f '' s)·∂ú := by rw [‚Üê hns, g'g.image_image]
  set h : Œ± ‚Üí Œ≤ := s.piecewise f g'
  have : Surjective h := by rw [‚Üê range_iff_surjective, range_piecewise, hg'ns, union_compl_self]
  have : Injective h := by
    refine (injective_piecewise_iff _).2 ‚ü®hf.injOn, ?_, ?_‚ü©
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®x', _, rfl‚ü© : x ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      obtain ‚ü®y', _, rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _, g'g _] at hxy
      rw [hxy]
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®y', hy', rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _] at hxy
      exact hy' ‚ü®x, hx, hxy‚ü©
  exact ‚ü®h, ‚ÄπInjective h‚Ä∫, ‚ÄπSurjective h‚Ä∫‚ü©"
Mathlib/Data/Int/Cast/Lemmas.lean,AddMonoidHom.ext_int,ext_int,93812b0faaaed21290db2b79c325e1dbaecd4dce,":=
  have : f.comp (Int.ofNatHom : ‚Ñï ‚Üí+ ‚Ñ§) = g.comp (Int.ofNatHom : ‚Ñï ‚Üí+ ‚Ñ§) := ext_nat' _ _ h1
  have this' : ‚àÄ n : ‚Ñï, f n = g n := ext_iff.1 this
  ext fun n => match n with
  | (n : ‚Ñï) => this' n
  | .negSucc n => eq_on_neg _ _ (this' <| n + 1)",error:  unknown identifier 'ext_iff',theorem ext_int [AddMonoid A] {f g : ‚Ñ§ ‚Üí+ A} (h1 : f 1 = g 1) : f = g ,":=
  have : f.comp (Int.ofNatHom : ‚Ñï ‚Üí+ ‚Ñ§) = g.comp (Int.ofNatHom : ‚Ñï ‚Üí+ ‚Ñ§) := ext_nat' _ _ h1
  have this' : ‚àÄ n : ‚Ñï, f n = g n := DFunLike.ext_iff.1 this
  ext fun n => match n with
  | (n : ‚Ñï) => this' n
  | .negSucc n => eq_on_neg _ _ (this' <| n + 1)"
Mathlib/Geometry/Euclidean/MongePoint.lean,Affine.Triangle.altitude_replace_orthocenter_eq_affineSpan,altitude_replace_orthocenter_eq_affineSpan,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  symm
  rw [‚Üê h‚ÇÇ, t‚ÇÇ.affineSpan_pair_eq_altitude_iff]
  rw [h‚ÇÇ]
  use t‚ÇÅ.independent.injective.ne hi‚ÇÅ‚ÇÇ
  have he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points) := by
    refine ext_of_direction_eq ?_
      ‚ü®t‚ÇÅ.points i‚ÇÉ, mem_affineSpan ‚Ñù ‚ü®j‚ÇÉ, h‚ÇÉ‚ü©, mem_affineSpan ‚Ñù (Set.mem_range_self _)‚ü©
    refine eq_of_le_of_finrank_eq (direction_le (spanPoints_subset_coe_of_subset_coe ?_))? _
    ¬∑ have hu : (Finset.univ : Finset (Fin 3)) = {j‚ÇÅ, j‚ÇÇ, j‚ÇÉ} := by
        clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
        fin_cases j‚ÇÅ <;> fin_cases j‚ÇÇ <;> fin_cases j‚ÇÉ
          <;> simp (config := {decide := true}) at hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ ‚ä¢
      rw [‚Üê Set.image_univ, ‚Üê Finset.coe_univ, hu, Finset.coe_insert, Finset.coe_insert,
        Finset.coe_singleton, Set.image_insert_eq, Set.image_insert_eq, Set.image_singleton, h‚ÇÅ, h‚ÇÇ,
        h‚ÇÉ, Set.insert_subset_iff, Set.insert_subset_iff, Set.singleton_subset_iff]
      exact
        ‚ü®t‚ÇÅ.orthocenter_mem_affineSpan, mem_affineSpan ‚Ñù (Set.mem_range_self _),
          mem_affineSpan ‚Ñù (Set.mem_range_self _)‚ü©
    ¬∑ rw [direction_affineSpan, direction_affineSpan,
        t‚ÇÅ.independent.finrank_vectorSpan (Fintype.card_fin _),
        t‚ÇÇ.independent.finrank_vectorSpan (Fintype.card_fin _)]
  rw [he]
  use mem_affineSpan ‚Ñù (Set.mem_range_self _)
  have hu : Finset.univ.erase j‚ÇÇ = {j‚ÇÅ, j‚ÇÉ} := by
    clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
    fin_cases j‚ÇÅ <;> fin_cases j‚ÇÇ <;> fin_cases j‚ÇÉ
      <;> simp (config := {decide := true}) at hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ ‚ä¢
  rw [hu, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton, h‚ÇÅ, h‚ÇÉ]
  have hle : (t‚ÇÅ.altitude i‚ÇÉ).direction·óÆ ‚â§ line[‚Ñù, t‚ÇÅ.orthocenter, t‚ÇÅ.points i‚ÇÉ].direction·óÆ :=
    Submodule.orthogonal_le (direction_le (affineSpan_orthocenter_point_le_altitude _ _))
  refine hle ((t‚ÇÅ.vectorSpan_isOrtho_altitude_direction i‚ÇÉ) ?_)
  have hui : Finset.univ.erase i‚ÇÉ = {i‚ÇÅ, i‚ÇÇ} := by
    clear hle h‚ÇÇ h‚ÇÉ
    fin_cases i‚ÇÅ <;> fin_cases i‚ÇÇ <;> fin_cases i‚ÇÉ
      <;> simp (config := {decide := true}) at hi‚ÇÅ‚ÇÇ hi‚ÇÅ‚ÇÉ hi‚ÇÇ‚ÇÉ ‚ä¢
  rw [hui, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton]
  exact vsub_mem_vectorSpan ‚Ñù (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_singleton _))","error:  application type mismatch
  direction_le (spanPoints_subset_coe_of_subset_coe ?m.373215)
argument
  spanPoints_subset_coe_of_subset_coe ?m.373215
has type
  spanPoints ?m.373206 ?m.373213 ‚äÜ ‚Üë?m.373214 : Prop
but is expected to have type
  ?m.372575 ‚â§ ?m.372576 : Prop
error:  unsolved goals
case right
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P
i‚ÇÅ i‚ÇÇ i‚ÇÉ j‚ÇÅ j‚ÇÇ j‚ÇÉ : Fin 3
hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ
hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ
hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ
hj‚ÇÅ‚ÇÇ : j‚ÇÅ ‚â† j‚ÇÇ
hj‚ÇÅ‚ÇÉ : j‚ÇÅ ‚â† j‚ÇÉ
hj‚ÇÇ‚ÇÉ : j‚ÇÇ ‚â† j‚ÇÉ
h‚ÇÅ : t‚ÇÇ.points j‚ÇÅ = t‚ÇÅ.orthocenter
h‚ÇÇ : t‚ÇÇ.points j‚ÇÇ = t‚ÇÅ.points i‚ÇÇ
h‚ÇÉ : t‚ÇÇ.points j‚ÇÉ = t‚ÇÅ.points i‚ÇÉ
he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points)
‚ä¢ t‚ÇÅ.points i‚ÇÅ ‚àà affineSpan ‚Ñù (Set.range t‚ÇÇ.points) ‚àß
    t‚ÇÅ.points i‚ÇÅ -·µ• t‚ÇÅ.points i‚ÇÇ ‚àà (affineSpan ‚Ñù (t‚ÇÇ.points '' ‚Üë(univ.erase j‚ÇÇ))).direction·óÆ
error:  unexpected token '?'; expected 'binder_predicate'","theorem altitude_replace_orthocenter_eq_affineSpan {t‚ÇÅ t‚ÇÇ : Triangle ‚Ñù P}
    {i‚ÇÅ i‚ÇÇ i‚ÇÉ j‚ÇÅ j‚ÇÇ j‚ÇÉ : Fin 3} (hi‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ) (hi‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ) (hi‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ) (hj‚ÇÅ‚ÇÇ : j‚ÇÅ ‚â† j‚ÇÇ)
    (hj‚ÇÅ‚ÇÉ : j‚ÇÅ ‚â† j‚ÇÉ) (hj‚ÇÇ‚ÇÉ : j‚ÇÇ ‚â† j‚ÇÉ) (h‚ÇÅ : t‚ÇÇ.points j‚ÇÅ = t‚ÇÅ.orthocenter)
    (h‚ÇÇ : t‚ÇÇ.points j‚ÇÇ = t‚ÇÅ.points i‚ÇÇ) (h‚ÇÉ : t‚ÇÇ.points j‚ÇÉ = t‚ÇÅ.points i‚ÇÉ) :
    t‚ÇÇ.altitude j‚ÇÇ = line[‚Ñù, t‚ÇÅ.points i‚ÇÅ, t‚ÇÅ.points i‚ÇÇ] ",":= by
  symm
  rw [‚Üê h‚ÇÇ, t‚ÇÇ.affineSpan_pair_eq_altitude_iff]
  rw [h‚ÇÇ]
  use t‚ÇÅ.independent.injective.ne hi‚ÇÅ‚ÇÇ
  have he : affineSpan ‚Ñù (Set.range t‚ÇÇ.points) = affineSpan ‚Ñù (Set.range t‚ÇÅ.points) := by
    refine ext_of_direction_eq ?_
      ‚ü®t‚ÇÅ.points i‚ÇÉ, mem_affineSpan ‚Ñù ‚ü®j‚ÇÉ, h‚ÇÉ‚ü©, mem_affineSpan ‚Ñù (Set.mem_range_self _)‚ü©
    refine eq_of_le_of_finrank_eq (direction_le (spanPoints_subset_coe_of_subset_coe ?_)) ?_
    ¬∑ have hu : (Finset.univ : Finset (Fin 3)) = {j‚ÇÅ, j‚ÇÇ, j‚ÇÉ} := by
        clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
        fin_cases j‚ÇÅ <;> fin_cases j‚ÇÇ <;> fin_cases j‚ÇÉ
          <;> simp (config := {decide := true}) at hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ ‚ä¢
      rw [‚Üê Set.image_univ, ‚Üê Finset.coe_univ, hu, Finset.coe_insert, Finset.coe_insert,
        Finset.coe_singleton, Set.image_insert_eq, Set.image_insert_eq, Set.image_singleton, h‚ÇÅ, h‚ÇÇ,
        h‚ÇÉ, Set.insert_subset_iff, Set.insert_subset_iff, Set.singleton_subset_iff]
      exact
        ‚ü®t‚ÇÅ.orthocenter_mem_affineSpan, mem_affineSpan ‚Ñù (Set.mem_range_self _),
          mem_affineSpan ‚Ñù (Set.mem_range_self _)‚ü©
    ¬∑ rw [direction_affineSpan, direction_affineSpan,
        t‚ÇÅ.independent.finrank_vectorSpan (Fintype.card_fin _),
        t‚ÇÇ.independent.finrank_vectorSpan (Fintype.card_fin _)]
  rw [he]
  use mem_affineSpan ‚Ñù (Set.mem_range_self _)
  have hu : Finset.univ.erase j‚ÇÇ = {j‚ÇÅ, j‚ÇÉ} := by
    clear h‚ÇÅ h‚ÇÇ h‚ÇÉ
    fin_cases j‚ÇÅ <;> fin_cases j‚ÇÇ <;> fin_cases j‚ÇÉ
      <;> simp (config := {decide := true}) at hj‚ÇÅ‚ÇÇ hj‚ÇÅ‚ÇÉ hj‚ÇÇ‚ÇÉ ‚ä¢
  rw [hu, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton, h‚ÇÅ, h‚ÇÉ]
  have hle : (t‚ÇÅ.altitude i‚ÇÉ).direction·óÆ ‚â§ line[‚Ñù, t‚ÇÅ.orthocenter, t‚ÇÅ.points i‚ÇÉ].direction·óÆ :=
    Submodule.orthogonal_le (direction_le (affineSpan_orthocenter_point_le_altitude _ _))
  refine hle ((t‚ÇÅ.vectorSpan_isOrtho_altitude_direction i‚ÇÉ) ?_)
  have hui : Finset.univ.erase i‚ÇÉ = {i‚ÇÅ, i‚ÇÇ} := by
    clear hle h‚ÇÇ h‚ÇÉ
    fin_cases i‚ÇÅ <;> fin_cases i‚ÇÇ <;> fin_cases i‚ÇÉ
      <;> simp (config := {decide := true}) at hi‚ÇÅ‚ÇÇ hi‚ÇÅ‚ÇÉ hi‚ÇÇ‚ÇÉ ‚ä¢
  rw [hui, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_singleton]
  exact vsub_mem_vectorSpan ‚Ñù (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_singleton _))"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.hasIntegral_GP_pderiv,hasIntegral_GP_pderiv,8636d2f0d43f26ede7fdda2633d5c6a4971fc185,":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine' HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le _ _ _ s hs _ _
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine' .and _ (.and _ _)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) :=
          inter_subset_inter_left _ (closedBall_subset_closedBall hŒ¥.2)
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := (add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ))
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine' this.eventually (ge_mem_nhds _)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine' ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ _‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine' (norm_sub_le _ _).trans (add_le_add _ _)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine' (mul_le_mul_of_nonneg_right _ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
          _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        (‚àè j, |J.upper j - J.lower j|) ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine' (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans _
      refine' (mul_le_mul_of_nonneg_right _ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine' prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => _
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := (dist_le_pi_dist J.upper J.lower (i.succAbove j))
        _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
        _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
        _ ‚â§ 1 / 2 + 1 / 2 := (add_le_add hŒ¥12 hŒ¥12)
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases(nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1 ((Hd x hx).def Œµ'0) with
      ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine' ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => _‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine' (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ _) (hJc rfl)).trans _
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg","error:  dsimp made no progress
error:  invalid field 'def', the environment does not contain 'HasFDerivWithinAt.def'
  Hd x hx
has type
  HasFDerivWithinAt f (f' x) (Box.Icc I) x
error:  invalid field 'def', the environment does not contain 'HasFDerivAtFilter.def'
  Hd x hx
has type
  HasFDerivAtFilter f (f' x) x (ùìù[Box.Icc I] x)
error:  type mismatch
  HŒ¥ ?m.83042
has type
  ?m.83041 ‚àà ?m.81872 : Prop
but is expected to have type
  ‚Äñf y - ?m.83027 - ?m.82967 (y - x)‚Äñ ‚â§ Œµ' * ‚Äñy - x‚Äñ : Prop
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  E","theorem hasIntegral_GP_pderiv (f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E)
    (f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E) (s : Set (Fin (n + 1) ‚Üí ‚Ñù))
    (hs : s.Countable) (Hs : ‚àÄ x ‚àà s, ContinuousWithinAt f (Box.Icc I) x)
    (Hd : ‚àÄ x ‚àà (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :
    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume
      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))
          BoxAdditiveMap.volume -
        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))
          BoxAdditiveMap.volume) ",":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le ?_ ?_ _ s hs ?_ ?_
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine .and ?_ (.and ?_ ?_)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) := by gcongr; exact hŒ¥.2
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ)
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine this.eventually (ge_mem_nhds ?_)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ ?_‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp [F]
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine (norm_sub_le _ _).trans (add_le_add ?_ ?_)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine (mul_le_mul_of_nonneg_right ?_ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
          _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans ?_
      refine (mul_le_mul_of_nonneg_right ?_ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => ?_
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := dist_le_pi_dist J.upper J.lower (i.succAbove j)
        _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
        _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1
      ((Hd x hx).isLittleO.def Œµ'0) with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => ?_‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ ?_) (hJc rfl)).trans ?_
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg"
Mathlib/ModelTheory/Satisfiability.lean,FirstOrder.Language.Theory.models_iff_not_satisfiable,models_iff_not_satisfiable,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [models_sentence_iff, IsSatisfiable]
  refine'
    ‚ü®fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T ‚à™ {Formula.not œÜ})
          (Set.subset_union_right _ _ (Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel (Set.subset_union_left _ _))),
      fun h M => _‚ü©
  contrapose! h
  rw [‚Üê Sentence.realize_not] at h
  refine'
    ‚ü®{  Carrier := M
        is_model := ‚ü®fun œà hœà => hœà.elim (realize_sentence_of_mem _) fun h' => _‚ü© }‚ü©
  rw [Set.mem_singleton_iff.1 h']
  exact h","warning:  @ModelsBoundedFormula does not have a doc string
error:  function expected at
  Set.subset_union_right ?m.33716
term has type
  ?m.33715 ‚àà ?m.33713 ‚à™ ?m.33714
error:  function expected at
  Set.subset_union_left ?m.33942
term has type
  ?m.33941 ‚àà ?m.33939 ‚à™ ?m.33940",theorem models_iff_not_satisfiable (œÜ : L.Sentence) : T ‚ä®·µá œÜ ‚Üî ¬¨IsSatisfiable (T ‚à™ {œÜ.not}) ,":= by
  rw [models_sentence_iff, IsSatisfiable]
  refine
    ‚ü®fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T ‚à™ {Formula.not œÜ})
          (Set.subset_union_right (Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel Set.subset_union_left)),
      fun h M => ?_‚ü©
  contrapose! h
  rw [‚Üê Sentence.realize_not] at h
  refine
    ‚ü®{  Carrier := M
        is_model := ‚ü®fun œà hœà => hœà.elim (realize_sentence_of_mem _) fun h' => ?_‚ü© }‚ü©
  rw [Set.mem_singleton_iff.1 h']
  exact h"
Mathlib/Algebra/MonoidAlgebra/Basic.lean,AddMonoidAlgebra.nonUnitalAlgHom_ext',nonUnitalAlgHom_ext',848a6055965ceeab03ba2c4d2d0e4e0e9b07c6e6,":=
  nonUnitalAlgHom_ext k <| FunLike.congr_fun h","error:  unknown constant 'FunLike.congr_fun'
warning:  AddMonoidAlgebra does not have a doc string","theorem nonUnitalAlgHom_ext' [DistribMulAction k A] {œÜ‚ÇÅ œÜ‚ÇÇ : MonoidAlgebra k G ‚Üí‚Çô‚Çê[k] A}
    (h : œÜ‚ÇÅ.toMulHom.comp (ofMagma k G) = œÜ‚ÇÇ.toMulHom.comp (ofMagma k G)) : œÜ‚ÇÅ = œÜ‚ÇÇ ",":=
  nonUnitalAlgHom_ext k <| DFunLike.congr_fun h"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.hasIntegral_GP_pderiv,hasIntegral_GP_pderiv,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine' HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le _ _ _ s hs _ _
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine' .and _ (.and _ _)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) :=
          inter_subset_inter_left _ (closedBall_subset_closedBall hŒ¥.2)
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := (add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ))
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine' this.eventually (ge_mem_nhds _)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine' ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ _‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine' (norm_sub_le _ _).trans (add_le_add _ _)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine' (mul_le_mul_of_nonneg_right _ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
          _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine' (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans _
      refine' (mul_le_mul_of_nonneg_right _ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine' prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => _
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := (dist_le_pi_dist J.upper J.lower (i.succAbove j))
        _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
        _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1 ((Hd x hx).def Œµ'0) with
      ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine' ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => _‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine' (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ _) (hJc rfl)).trans _
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg","error:  dsimp made no progress
error:  invalid field 'def', the environment does not contain 'HasFDerivWithinAt.def'
  Hd x hx
has type
  HasFDerivWithinAt f (f' x) (Box.Icc I) x
error:  invalid field 'def', the environment does not contain 'HasFDerivAtFilter.def'
  Hd x hx
has type
  HasFDerivAtFilter f (f' x) x (ùìù[Box.Icc I] x)
error:  type mismatch
  HŒ¥ ?m.83042
has type
  ?m.83041 ‚àà ?m.81872 : Prop
but is expected to have type
  ‚Äñf y - ?m.83027 - ?m.82967 (y - x)‚Äñ ‚â§ Œµ' * ‚Äñy - x‚Äñ : Prop
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  E","theorem hasIntegral_GP_pderiv (f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E)
    (f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E) (s : Set (Fin (n + 1) ‚Üí ‚Ñù))
    (hs : s.Countable) (Hs : ‚àÄ x ‚àà s, ContinuousWithinAt f (Box.Icc I) x)
    (Hd : ‚àÄ x ‚àà (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :
    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume
      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))
          BoxAdditiveMap.volume -
        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))
          BoxAdditiveMap.volume) ",":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le ?_ ?_ _ s hs ?_ ?_
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine .and ?_ (.and ?_ ?_)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) := by gcongr; exact hŒ¥.2
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ)
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine this.eventually (ge_mem_nhds ?_)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ ?_‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp [F]
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine (norm_sub_le _ _).trans (add_le_add ?_ ?_)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine (mul_le_mul_of_nonneg_right ?_ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
          _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans ?_
      refine (mul_le_mul_of_nonneg_right ?_ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => ?_
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := dist_le_pi_dist J.upper J.lower (i.succAbove j)
        _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
        _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1
      ((Hd x hx).isLittleO.def Œµ'0) with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => ?_‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ ?_) (hJc rfl)).trans ?_
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.head_terminates_of_head_tail_terminates,head_terminates_of_head_tail_terminates,88f252d9ef6777980e9cb4396094e178f3ed4acb,":=
  head_terminates_iff.2 <| by
    rcases head_terminates_iff.1 T with ‚ü®‚ü®a, h‚ü©‚ü©
    simp? [tail] at h says simp only [tail, dest_flatten] at h
    rcases exists_of_mem_bind h with ‚ü®s', h1, _‚ü©
    exact
      let ‚ü®t, h3, _‚ü© := Computation.exists_of_mem_map h1
      Computation.terminates_of_mem h3","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  head_terminates_iff
has type
  ‚àÄ (s : WSeq ?m.37473), s.head.Terminates ‚Üî s.destruct.Terminates","theorem head_terminates_of_head_tail_terminates (s : WSeq Œ±) [T : Terminates (head (tail s))] :
    Terminates (head s) ",":=
  (head_terminates_iff _).2 <| by
    rcases (head_terminates_iff _).1 T with ‚ü®‚ü®a, h‚ü©‚ü©
    simp? [tail] at h says simp only [tail, destruct_flatten] at h
    rcases exists_of_mem_bind h with ‚ü®s', h1, _‚ü©
    unfold Functor.map at h1
    exact
      let ‚ü®t, h3, _‚ü© := Computation.exists_of_mem_map h1
      Computation.terminates_of_mem h3"
Mathlib/Data/Finset/Basic.lean,Finset.not_disjoint_iff,not_disjoint_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  disjoint_left.not.trans <| not_forall.trans <| exists_congr fun _ => by rw [not_imp, not_not]","error:  ambiguous, possible interpretations 
  _root_.not_imp : ¬¨(?m.42783 ‚Üí ?m.42784) ‚Üî ?m.42783 ‚àß ¬¨?m.42784
  
  Classical.not_imp : ¬¨(?m.42785 ‚Üí ?m.42786) ‚Üî ?m.42785 ‚àß ¬¨?m.42786
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.42788
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
f : Œ± ‚Üí Œ≤
s t u : Finset Œ±
a b x‚úù : Œ±
‚ä¢ ¬¨(x‚úù ‚àà s ‚Üí x‚úù ‚àâ t) ‚Üî x‚úù ‚àà s ‚àß x‚úù ‚àà t","theorem not_disjoint_iff : ¬¨Disjoint s t ‚Üî ‚àÉ a, a ‚àà s ‚àß a ‚àà t ",":=
  disjoint_left.not.trans <| not_forall.trans <| exists_congr fun _ => by
    rw [Classical.not_imp, not_not]"
Mathlib/Probability/Process/PartitionFiltration.lean,ProbabilityTheory.iSup_partitionFiltration_eq_generateFrom_range,iSup_partitionFiltration_eq_generateFrom_range,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  conv_rhs => rw [‚Üê generateFrom_iUnion_memPartition t, ‚Üê iSup_generateFrom]","error:  unsolved goals
Œ± : Type u_1
m : MeasurableSpace Œ±
t : ‚Ñï ‚Üí Set Œ±
ht : ‚àÄ (n : ‚Ñï), MeasurableSet (t n)
‚ä¢ ‚®Ü n, ‚Üë(partitionFiltration ht) n = ‚®Ü i, generateFrom (memPartition t i)","lemma iSup_partitionFiltration_eq_generateFrom_range (ht : ‚àÄ n, MeasurableSet (t n)) :
    ‚®Ü n, partitionFiltration ht n = generateFrom (Set.range t) ",":= by
  conv_rhs => rw [‚Üê generateFrom_iUnion_memPartition t, ‚Üê iSup_generateFrom]
  rfl"
Mathlib/Data/List/InsertNth.lean,List.length_insertNth_le_succ,length_insertNth_le_succ,df9cfef55a1b8cd650f6575f7f576b85ef124030,":= by
  rcases (Nat.lt_or_ge l.length n).symm with hn | hn
  ¬∑ rw [length_insertNth _ _ hn]
    exact Nat.le_refl _
  ¬∑ rw [insertNth_of_length_lt _ _ _ hn]
    exact Nat.le_of_lt (Nat.lt_succ_self _)","error:  no goals to be solved
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  try 'simp' instead of 'simpa'
note: this linter can be disabled with `set_option linter.unnecessarySimpa false`
warning:  try 'simp at h' instead of 'simpa using h'
note: this linter can be disabled with `set_option linter.unnecessarySimpa false`
warning:  try 'simp at h' instead of 'simpa using h'
note: this linter can be disabled with `set_option linter.unnecessarySimpa false`","theorem length_insertNth_le_succ (l : List Œ±) (x : Œ±) (n : ‚Ñï) :
    (insertNth n x l).length ‚â§ l.length + 1 ",":= by
  rcases le_or_lt n l.length with hn | hn
  ¬∑ rw [length_insertNth _ _ hn]
  ¬∑ rw [insertNth_of_length_lt _ _ _ hn]
    exact (Nat.lt_succ_self _).le"
Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean,coeff_minpolyDiv_sub_pow_mem_span,coeff_minpolyDiv_sub_pow_mem_span,1e6b6c1919bb062a9b0fb6873d11444837c77e88,":= by
  induction i with
  | zero => simp [(minpolyDiv_monic hx).leadingCoeff]
  | succ i IH =>
    rw [coeff_minpolyDiv, add_sub_assoc, pow_succ, ‚Üê sub_mul, Algebra.algebraMap_eq_smul_one]
    apply add_mem
    ¬∑ apply Submodule.smul_mem
      apply Submodule.subset_span
      exact ‚ü®0, Nat.zero_lt_succ _, pow_zero _‚ü©
    ¬∑ rw [Nat.succ_eq_add_one, ‚Üê tsub_tsub, tsub_add_cancel_of_le
        (le_tsub_of_add_le_left (b := 1) hi)]
      apply SetLike.le_def.mp ?_
        (Submodule.mul_mem_mul (IH ((Nat.le_succ _).trans hi))
          (Submodule.mem_span_singleton_self x))
      rw [Submodule.span_mul_span, Set.mul_singleton, Set.image_image]
      apply Submodule.span_mono
      rintro _ ‚ü®j, hj, rfl‚ü©
      rw [Set.mem_Iio] at hj
      exact ‚ü®j + 1, Nat.add_lt_of_lt_sub hj, pow_succ x j‚ü©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ.a
R : Type u_2
K : Type ?u.79175
L : Type ?u.79178
S : Type u_1
inst‚úù‚Åµ : CommRing R
inst‚úù‚Å¥ : Field K
inst‚úù¬≥ : Field L
inst‚úù¬≤ : CommRing S
inst‚úù¬π : Algebra R S
inst‚úù : Algebra K L
x : S
hx : IsIntegral R x
i : ‚Ñï
IH :
  i ‚â§ (minpolyDiv R x).natDegree ‚Üí
    (minpolyDiv R x).coeff ((minpolyDiv R x).natDegree - i) - x ^ i ‚àà
      Submodule.span R ((fun x_1 ‚Ü¶ x ^ x_1) '' Set.Iio i)
hi : i + 1 ‚â§ (minpolyDiv R x).natDegree
‚ä¢ ((minpolyDiv R x).coeff ((minpolyDiv R x).natDegree - (i + 1) + 1) - x ^ i) * x ‚àà
    Submodule.span R ((fun x_1 ‚Ü¶ x ^ x_1) '' Set.Iio (i + 1))","lemma coeff_minpolyDiv_sub_pow_mem_span {i} (hi : i ‚â§ natDegree (minpolyDiv R x)) :
    coeff (minpolyDiv R x) (natDegree (minpolyDiv R x) - i) - x ^ i ‚àà
      Submodule.span R ((x ^ ¬∑) '' Set.Iio i) ",":= by
  induction i with
  | zero => simp [(minpolyDiv_monic hx).leadingCoeff]
  | succ i IH =>
    rw [coeff_minpolyDiv, add_sub_assoc, pow_succ, ‚Üê sub_mul, Algebra.algebraMap_eq_smul_one]
    refine add_mem ?_ ?_
    ¬∑ apply Submodule.smul_mem
      apply Submodule.subset_span
      exact ‚ü®0, Nat.zero_lt_succ _, pow_zero _‚ü©
    ¬∑ rw [‚Üê tsub_tsub, tsub_add_cancel_of_le (le_tsub_of_add_le_left (b := 1) hi)]
      apply SetLike.le_def.mp ?_
        (Submodule.mul_mem_mul (IH ((Nat.le_succ _).trans hi))
          (Submodule.mem_span_singleton_self x))
      rw [Submodule.span_mul_span, Set.mul_singleton, Set.image_image]
      apply Submodule.span_mono
      rintro _ ‚ü®j, hj, rfl‚ü©
      rw [Set.mem_Iio] at hj
      exact ‚ü®j + 1, Nat.add_lt_of_lt_sub hj, pow_succ x j‚ü©"
Mathlib/Computability/Primrec.lean,Nat.Primrec'.prim_iff‚ÇÇ,prim_iff‚ÇÇ,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  prim_iff.trans
    ‚ü®fun h => (h.comp <| Primrec.vector_cons.comp‚ÇÇ .fst <|
      Primrec.vector_cons.comp‚ÇÇ .snd (.const nil)).of_eq fun v => by simp,
    fun h => h.comp‚ÇÇ .vector_head (Primrec.vector_head.comp .vector_tail)‚ü©","error:  application type mismatch
  Primrec‚ÇÇ.comp‚ÇÇ Primrec.vector_cons Primrec.fst
argument
  Primrec.fst
has type
  Primrec Prod.fst : Prop
but is expected to have type
  Primrec‚ÇÇ ?m.303182 : Prop
error:  application type mismatch
  Primrec‚ÇÇ.comp‚ÇÇ Primrec.vector_cons Primrec.snd
argument
  Primrec.snd
has type
  Primrec Prod.snd : Prop
but is expected to have type
  Primrec‚ÇÇ ?m.307253 : Prop
error:  application type mismatch
  Primrec‚ÇÇ.comp‚ÇÇ h Primrec.vector_head
argument
  Primrec.vector_head
has type
  Primrec Vector.head : Prop
but is expected to have type
  Primrec‚ÇÇ ?m.311631 : Prop
error:  unsolved goals
f : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
h : Primrec fun v ‚Ü¶ f v.head v.tail.head
v : ‚Ñï √ó ‚Ñï
‚ä¢ f (?m.311591 h v.1 v.2) (?m.311592 h v.1 v.2) = f v.1 v.2
error:  application type mismatch
  _root_.Primrec.comp Primrec.vector_head Primrec.vector_tail
argument
  Primrec.vector_tail
has type
  Primrec Vector.tail : Prop
but is expected to have type
  Primrec ?m.315455 : Prop",theorem prim_iff‚ÇÇ {f : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï} : (@Primrec' 2 fun v => f v.head v.tail.head) ‚Üî Primrec‚ÇÇ f ,":=
  prim_iff.trans
    ‚ü®fun h => (h.comp <| Primrec.vector_cons.comp .fst <|
      Primrec.vector_cons.comp .snd (.const nil)).of_eq fun v => by simp,
    fun h => h.comp .vector_head (Primrec.vector_head.comp .vector_tail)‚ü©"
Mathlib/Data/Fintype/Option.lean,Fintype.induction_empty_option,induction_empty_option,f805dd1a8f5243708d8b831bb207e63649ac1331,":= by
  obtain ‚ü®p‚ü© :=
    let f_empty := (fun i => by convert h_empty; simp)
    let h_option : ‚àÄ {Œ± : Type u} [Fintype Œ±] [DecidableEq Œ±],
          (‚àÄ (h : Fintype Œ±), P Œ±) ‚Üí ‚àÄ (h : Fintype (Option Œ±)), P (Option Œ±)  := by
      rintro Œ± hŒ± - PŒ± hŒ±'
      convert h_option Œ± (PŒ± _)
      simp
    @truncRecEmptyOption (fun Œ± => ‚àÄ h, @P Œ± h) (@fun Œ± Œ≤ e hŒ± hŒ≤ => @of_equiv Œ± Œ≤ hŒ≤ e (hŒ± _))
      f_empty h_option Œ± _ (Classical.decEq Œ±)
  ¬∑ exact p _","error:  no goals to be solved
error:  no goals to be solved","theorem induction_empty_option {P : ‚àÄ (Œ± : Type u) [Fintype Œ±], Prop}
    (of_equiv : ‚àÄ (Œ± Œ≤) [Fintype Œ≤] (e : Œ± ‚âÉ Œ≤), @P Œ± (@Fintype.ofEquiv Œ± Œ≤ ‚Äπ_‚Ä∫ e.symm) ‚Üí @P Œ≤ ‚Äπ_‚Ä∫)
    (h_empty : P PEmpty) (h_option : ‚àÄ (Œ±) [Fintype Œ±], P Œ± ‚Üí P (Option Œ±)) (Œ± : Type u)
    [h_fintype : Fintype Œ±] : P Œ± ",":= by
  obtain ‚ü®p‚ü© :=
    let f_empty := fun i => by convert h_empty
    let h_option : ‚àÄ {Œ± : Type u} [Fintype Œ±] [DecidableEq Œ±],
          (‚àÄ (h : Fintype Œ±), P Œ±) ‚Üí ‚àÄ (h : Fintype (Option Œ±)), P (Option Œ±)  := by
      rintro Œ± hŒ± - PŒ± hŒ±'
      convert h_option Œ± (PŒ± _)
    @truncRecEmptyOption (fun Œ± => ‚àÄ h, @P Œ± h) (@fun Œ± Œ≤ e hŒ± hŒ≤ => @of_equiv Œ± Œ≤ hŒ≤ e (hŒ± _))
      f_empty h_option Œ± _ (Classical.decEq Œ±)
  exact p _"
Mathlib/NumberTheory/NumberField/CanonicalEmbedding/ConvexBody.lean,NumberField.mixedEmbedding.convexBodySumFun_add_le,convexBodySumFun_add_le,994c2cef3f04490aa959c257e006c8ce6984a9f3,":= by
  simp_rw [convexBodySumFun, ‚Üê Finset.sum_add_distrib, ‚Üê mul_add]
  exact Finset.sum_le_sum
    fun _ _ ‚Ü¶ mul_le_mul_of_nonneg_left (normAtPlace_add_le _ x y) mult_pos.le","error:  application type mismatch
  mul_le_mul_of_nonneg_left (normAtPlace_add_le x‚úù¬π x y) (LT.lt.le mult_pos)
argument
  LT.lt.le mult_pos
has type
  @OfNat.ofNat ‚Ñï 0 (instOfNatNat 0) ‚â§ ?m.187986.mult : Prop
but is expected to have type
  @OfNat.ofNat ‚Ñù 0 Zero.toOfNat0 ‚â§ ‚Üëx‚úù¬π.mult : Prop","theorem convexBodySumFun_add_le (x y : E K) :
    convexBodySumFun (x + y) ‚â§ convexBodySumFun x + convexBodySumFun y ",":= by
  simp_rw [convexBodySumFun, ‚Üê Finset.sum_add_distrib, ‚Üê mul_add]
  exact Finset.sum_le_sum
    fun _ _ ‚Ü¶ mul_le_mul_of_nonneg_left (normAtPlace_add_le _ x y) (Nat.cast_pos.mpr mult_pos).le"
Mathlib/RingTheory/Jacobson.lean,Ideal.Polynomial.isMaximal_comap_C_of_isJacobson,isMaximal_comap_C_of_isJacobson,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [‚Üê @mk_ker _ _ P, RingHom.ker_eq_comap_bot, comap_comap]
  exact isMaximal_comap_of_isIntegral_of_isMaximal' _ (quotient_mk_comp_C_isIntegral_of_jacobson P)
    ‚ä• ((bot_quotient_isMaximal_iff _).mpr hP)","error:  function expected at
  isMaximal_comap_of_isIntegral_of_isMaximal' ((Quotient.mk P).comp C) (quotient_mk_comp_C_isIntegral_of_jacobson P) ‚ä•
term has type
  (comap ((Quotient.mk P).comp C) ‚ä•).IsMaximal",theorem isMaximal_comap_C_of_isJacobson : (P.comap (C : R ‚Üí+* R[X])).IsMaximal ,":= by
  rw [‚Üê @mk_ker _ _ P, RingHom.ker_eq_comap_bot, comap_comap]
  have := (bot_quotient_isMaximal_iff _).mpr hP
  exact isMaximal_comap_of_isIntegral_of_isMaximal' _ (quotient_mk_comp_C_isIntegral_of_jacobson P)
    ‚ä•"
Mathlib/RingTheory/WittVector/Isocrystal.lean,WittVector.isocrystal_classification,isocrystal_classification,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  haveI : Nontrivial V := FiniteDimensional.nontrivial_of_finrank_eq_succ h_dim
  obtain ‚ü®x, hx‚ü© : ‚àÉ x : V, x ‚â† 0 := exists_ne 0
  have : Œ¶(p, k) x ‚â† 0 := by simpa only [map_zero] using Œ¶(p, k).injective.ne hx
  obtain ‚ü®a, ha, hax‚ü© : ‚àÉ a : K(p, k), a ‚â† 0 ‚àß Œ¶(p, k) x = a ‚Ä¢ x := by
    rw [finrank_eq_one_iff_of_nonzero' x hx] at h_dim
    obtain ‚ü®a, ha‚ü© := h_dim (Œ¶(p, k) x)
    refine' ‚ü®a, _, ha.symm‚ü©
    intro ha'
    apply this
    simp only [‚Üê ha, ha', zero_smul]
  obtain ‚ü®b, hb, m, hmb‚ü© := WittVector.exists_frobenius_solution_fractionRing p ha
  replace hmb : œÜ(p, k) b * a = (p : K(p, k)) ^ m * b := by convert hmb
  use m
  let F‚ÇÄ : StandardOneDimIsocrystal p k m ‚Üí‚Çó[K(p, k)] V := LinearMap.toSpanSingleton K(p, k) V x
  let F : StandardOneDimIsocrystal p k m ‚âÉ‚Çó[K(p, k)] V := by
    refine' LinearEquiv.ofBijective F‚ÇÄ ‚ü®_, _‚ü©
    ¬∑ rw [‚Üê LinearMap.ker_eq_bot]
      exact LinearMap.ker_toSpanSingleton K(p, k) V hx
    ¬∑ rw [‚Üê LinearMap.range_eq_top]
      rw [‚Üê (finrank_eq_one_iff_of_nonzero x hx).mp h_dim]
      rw [LinearMap.span_singleton_eq_range]
  let E := (LinearEquiv.smulOfNeZero K(p, k) _ _ hb).trans F
  refine' ‚ü®‚ü®E, _‚ü©‚ü©
  simp only
  intro c
  rw [LinearEquiv.trans_apply, LinearEquiv.trans_apply, LinearEquiv.smulOfNeZero_apply,
    LinearEquiv.smulOfNeZero_apply, LinearEquiv.map_smul, LinearEquiv.map_smul]
  rw [LinearEquiv.ofBijective_apply, LinearEquiv.ofBijective_apply]
  erw [LinearMap.toSpanSingleton_apply K(p, k) V x c, LinearMap.toSpanSingleton_apply K(p, k) V x]
  simp only [hax, LinearEquiv.ofBijective_apply, LinearMap.toSpanSingleton_apply,
    LinearEquiv.map_smul‚Çõ‚Çó, StandardOneDimIsocrystal.frobenius_apply, Algebra.id.smul_eq_mul]
  simp only [‚Üê mul_smul]
  congr 1
  linear_combination œÜ(p, k) c * hmb",error:  simp made no progress,"theorem isocrystal_classification (k : Type*) [Field k] [IsAlgClosed k] [CharP k p] (V : Type*)
    [AddCommGroup V] [Isocrystal p k V] (h_dim : finrank K(p, k) V = 1) :
    ‚àÉ m : ‚Ñ§, Nonempty (StandardOneDimIsocrystal p k m ‚âÉ·∂†‚Å±[p, k] V) ",":= by
  haveI : Nontrivial V := FiniteDimensional.nontrivial_of_finrank_eq_succ h_dim
  obtain ‚ü®x, hx‚ü© : ‚àÉ x : V, x ‚â† 0 := exists_ne 0
  have : Œ¶(p, k) x ‚â† 0 := by simpa only [map_zero] using Œ¶(p, k).injective.ne hx
  obtain ‚ü®a, ha, hax‚ü© : ‚àÉ a : K(p, k), a ‚â† 0 ‚àß Œ¶(p, k) x = a ‚Ä¢ x := by
    rw [finrank_eq_one_iff_of_nonzero' x hx] at h_dim
    obtain ‚ü®a, ha‚ü© := h_dim (Œ¶(p, k) x)
    refine ‚ü®a, ?_, ha.symm‚ü©
    intro ha'
    apply this
    simp only [‚Üê ha, ha', zero_smul]
  obtain ‚ü®b, hb, m, hmb‚ü© := WittVector.exists_frobenius_solution_fractionRing p ha
  replace hmb : œÜ(p, k) b * a = (p : K(p, k)) ^ m * b := by convert hmb
  use m
  let F‚ÇÄ : StandardOneDimIsocrystal p k m ‚Üí‚Çó[K(p, k)] V := LinearMap.toSpanSingleton K(p, k) V x
  let F : StandardOneDimIsocrystal p k m ‚âÉ‚Çó[K(p, k)] V := by
    refine LinearEquiv.ofBijective F‚ÇÄ ‚ü®?_, ?_‚ü©
    ¬∑ rw [‚Üê LinearMap.ker_eq_bot]
      exact LinearMap.ker_toSpanSingleton K(p, k) V hx
    ¬∑ rw [‚Üê LinearMap.range_eq_top]
      rw [‚Üê (finrank_eq_one_iff_of_nonzero x hx).mp h_dim]
      rw [LinearMap.span_singleton_eq_range]
  refine ‚ü®‚ü®(LinearEquiv.smulOfNeZero K(p, k) _ _ hb).trans F, fun c ‚Ü¶ ?_‚ü©‚ü©
  rw [LinearEquiv.trans_apply, LinearEquiv.trans_apply, LinearEquiv.smulOfNeZero_apply,
    LinearEquiv.smulOfNeZero_apply, LinearEquiv.map_smul, LinearEquiv.map_smul]
  rw [LinearEquiv.ofBijective_apply, LinearEquiv.ofBijective_apply]
  erw [LinearMap.toSpanSingleton_apply K(p, k) V x c, LinearMap.toSpanSingleton_apply K(p, k) V x]
  simp only [hax, LinearEquiv.ofBijective_apply, LinearMap.toSpanSingleton_apply,
    LinearEquiv.map_smul‚Çõ‚Çó, StandardOneDimIsocrystal.frobenius_apply, Algebra.id.smul_eq_mul]
  simp only [‚Üê mul_smul]
  congr 1
  linear_combination œÜ(p, k) c * hmb"
Mathlib/RingTheory/IntegralClosure.lean,Algebra.finite_iff_isIntegral_and_finiteType,Algebra.finite_iff_isIntegral_and_finiteType,787f21e24c1b4d0e7a88ac6d76f18bfb080d4d5c,":=
  ‚ü®fun _ ‚Ü¶ ‚ü®.of_finite R, inferInstance‚ü©, fun ‚ü®h, _‚ü© ‚Ü¶ h.finite‚ü©","error:  application type mismatch
  And.intro (IsIntegral.of_finite R)
argument
  IsIntegral.of_finite R
has type
  ‚àÄ (B : Type ?u.178142) [inst : CommRing R] [inst_1 : Ring B] [inst_2 : Algebra R B] [inst_3 : Module.Finite R B],
    Algebra.IsIntegral R B : Prop
but is expected to have type
  Algebra.IsIntegral R A : Prop","theorem Algebra.finite_iff_isIntegral_and_finiteType :
    Module.Finite R A ‚Üî Algebra.IsIntegral R A ‚àß Algebra.FiniteType R A ",":=
  ‚ü®fun _ ‚Ü¶ ‚ü®‚ü®.of_finite R‚ü©, inferInstance‚ü©, fun ‚ü®h, _‚ü© ‚Ü¶ h.finite‚ü©"
Mathlib/Algebra/Order/Ring/Pow.lean,one_add_mul_le_pow',one_add_mul_le_pow',61ddcfa78d90f5773ac5739822ee3721851aa662,"  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 ‚â§ n * (a * a * (2 + a)) + a * a :=
      add_nonneg (mul_nonneg n.cast_nonneg (mul_nonneg Hsq H)) Hsq
    calc
      _ ‚â§ 1 + ‚Üë(n + 2) * a + (n * (a * a * (2 + a)) + a * a) := le_add_of_nonneg_right this
      _ = (1 + a) * (1 + a) * (1 + n * a) := by
          simp only [Nat.cast_add, add_mul, mul_add, one_mul, mul_one, ‚Üê one_add_one_eq_two,
            Nat.cast_one, add_assoc, add_right_inj]
          simp only [‚Üê add_assoc, add_comm _ (‚Üën * a)]
          simp only [add_assoc, (n.cast_commute (_ : R)).left_comm]
          simp only [add_comm, add_left_comm]
      _ ‚â§ (1 + a) * (1 + a) * (1 + a) ^ n :=
        mul_le_mul_of_nonneg_left (one_add_mul_le_pow' Hsq Hsq' H _) Hsq'
      _ = (1 + a) ^ (n + 2) := by simp only [pow_succ, mul_assoc]","error:  unsolved goals
R : Type u_1
inst‚úù : OrderedSemiring R
a : R
Hsq : 0 ‚â§ a * a
Hsq' : 0 ‚â§ (1 + a) * (1 + a)
H : 0 ‚â§ 2 + a
n : ‚Ñï
this : 0 ‚â§ ‚Üën * (a * a * (2 + a)) + a * a
‚ä¢ (1 + a) * ((1 + a) * (1 + a) ^ n) = (1 + a) ^ n * ((1 + a) * (1 + a))","lemma one_add_mul_le_pow' (Hsq : 0 ‚â§ a * a) (Hsq' : 0 ‚â§ (1 + a) * (1 + a)) (H : 0 ‚â§ 2 + a) :
    ‚àÄ n : ‚Ñï, 1 + n * a ‚â§ (1 + a) ^ n
","  | 0 => by simp
  | 1 => by simp
  | n + 2 =>
    have : 0 ‚â§ n * (a * a * (2 + a)) + a * a :=
      add_nonneg (mul_nonneg n.cast_nonneg (mul_nonneg Hsq H)) Hsq
    calc
      _ ‚â§ 1 + ‚Üë(n + 2) * a + (n * (a * a * (2 + a)) + a * a) := le_add_of_nonneg_right this
      _ = (1 + a) * (1 + a) * (1 + n * a) := by
          simp only [Nat.cast_add, add_mul, mul_add, one_mul, mul_one, ‚Üê one_add_one_eq_two,
            Nat.cast_one, add_assoc, add_right_inj]
          simp only [‚Üê add_assoc, add_comm _ (‚Üën * a)]
          simp only [add_assoc, (n.cast_commute (_ : R)).left_comm]
          simp only [add_comm, add_left_comm]
      _ ‚â§ (1 + a) * (1 + a) * (1 + a) ^ n :=
        mul_le_mul_of_nonneg_left (one_add_mul_le_pow' Hsq Hsq' H _) Hsq'
      _ = (1 + a) ^ (n + 2) := by simp only [pow_succ', mul_assoc]"
Mathlib/Data/Real/Irrational.lean,irrational_nrt_of_n_not_dvd_multiplicity,irrational_nrt_of_n_not_dvd_multiplicity,8e31b5ac6bed8ba535a30f3442252684d2f151c1,":= by
  rcases Nat.eq_zero_or_pos n with (rfl | hnpos)
  ¬∑ rw [eq_comm, pow_zero, ‚Üê Int.cast_one, Int.cast_inj] at hxr
    simp [hxr,
      multiplicity.one_right (mt isUnit_iff_dvd_one.1 (mt Int.coe_nat_dvd.1 hp.1.not_dvd_one)),
      Nat.zero_mod] at hv
  refine' irrational_nrt_of_notint_nrt _ _ hxr _ hnpos
  rintro ‚ü®y, rfl‚ü©
  rw [‚Üê Int.cast_pow, Int.cast_inj] at hxr
  subst m
  have : y ‚â† 0 := by
    rintro rfl
    rw [zero_pow hnpos] at hm
    exact hm rfl
  erw [multiplicity.pow' (Nat.prime_iff_prime_int.1 hp.1) (finite_int_iff.2 ‚ü®hp.1.ne_one, this‚ü©),
    Nat.mul_mod_right] at hv
  exact hv rfl","warning:  `Int.coe_nat_dvd` has been deprecated, use `Int.natCast_dvd_natCast` instead
error:  application type mismatch
  zero_pow hnpos
argument
  hnpos
has type
  n > 0 : Prop
but is expected to have type
  ?m.6068 ‚â† 0 : Prop","theorem irrational_nrt_of_n_not_dvd_multiplicity {x : ‚Ñù} (n : ‚Ñï) {m : ‚Ñ§} (hm : m ‚â† 0) (p : ‚Ñï)
    [hp : Fact p.Prime] (hxr : x ^ n = m)
    (hv : (multiplicity (p : ‚Ñ§) m).get (finite_int_iff.2 ‚ü®hp.1.ne_one, hm‚ü©) % n ‚â† 0) :
    Irrational x ",":= by
  rcases Nat.eq_zero_or_pos n with (rfl | hnpos)
  ¬∑ rw [eq_comm, pow_zero, ‚Üê Int.cast_one, Int.cast_inj] at hxr
    simp [hxr, multiplicity.one_right (mt isUnit_iff_dvd_one.1
      (mt Int.natCast_dvd_natCast.1 hp.1.not_dvd_one)), Nat.zero_mod] at hv
  refine irrational_nrt_of_notint_nrt _ _ hxr ?_ hnpos
  rintro ‚ü®y, rfl‚ü©
  rw [‚Üê Int.cast_pow, Int.cast_inj] at hxr
  subst m
  have : y ‚â† 0 := by rintro rfl; rw [zero_pow hnpos.ne'] at hm; exact hm rfl
  erw [multiplicity.pow' (Nat.prime_iff_prime_int.1 hp.1) (finite_int_iff.2 ‚ü®hp.1.ne_one, this‚ü©),
    Nat.mul_mod_right] at hv
  exact hv rfl"
Mathlib/CategoryTheory/FiberedCategory/HomLift.lean,CategoryTheory.IsHomLift.id_lift_eqToHom_codomain,id_lift_eqToHom_codomain,95e75fcfd1c014add03de9b53a54ac3c1396bb20,  fac := by simp [eqToHom_map],"error:  function expected at
  p.IsHomLift (eqToHom hRS) (ùüô b)
term has type
  Prop
error:  simp made no progress","lemma id_lift_eqToHom_codomain {p : ùí≥ ‚•§ ùíÆ} {R S : ùíÆ} (hRS : R = S) {b : ùí≥} (hb : p.obj b = S) :
    p.IsHomLift (eqToHom hRS) (ùüô b) ",":= by
  subst hRS hb; simp"
Mathlib/Topology/Category/TopCat/Opens.lean,TopologicalSpace.Opens.inclusion_top_functor,inclusion_top_functor,25527279cf0fc38a336bb3b3d913a403b5f38ac1,":= by
  refine CategoryTheory.Functor.ext ?_ ?_
  ¬∑ intro U
    ext x
    exact ‚ü®fun ‚ü®‚ü®_, _‚ü©, h, rfl‚ü© => h, fun h => ‚ü®‚ü®x, trivial‚ü©, h, rfl‚ü©‚ü©
  ¬∑ subsingleton","error:  unknown tactic
error:  unsolved goals
case refine_2
X : TopCat
‚ä¢ ‚àÄ (X_1 Y : Opens ‚Üë((toTopCat X).obj ‚ä§)) (f : X_1 ‚ü∂ Y),
    ‚ãØ.functor.map f = eqToHom ‚ãØ ‚â´ (map (inclusionTopIso X).inv).map f ‚â´ eqToHom ‚ãØ","theorem inclusion_top_functor (X : TopCat) :
    (@Opens.openEmbedding X ‚ä§).isOpenMap.functor = map (inclusionTopIso X).inv ",":= by
  refine CategoryTheory.Functor.ext ?_ ?_
  ¬∑ intro U
    ext x
    exact ‚ü®fun ‚ü®‚ü®_, _‚ü©, h, rfl‚ü© => h, fun h => ‚ü®‚ü®x, trivial‚ü©, h, rfl‚ü©‚ü©
  ¬∑ intros U V f
    apply Subsingleton.elim"
Mathlib/Analysis/Analytic/CPolynomial.lean,FormalMultilinearSeries.changeOriginSeriesTerm_bound,changeOriginSeriesTerm_bound,6c2fe6d5f3691b89a4a57aeacfabf7cd7092b732,":= by
  rw [changeOriginSeriesTerm]
  simp only [AddEquivClass.map_eq_zero_iff]
  exact hn _ hkl","error:  type mismatch
  hn (k + l) hkl
has type
  p (k + l) = 0 : Prop
but is expected to have type
  (ContinuousMultilinearMap.curryFinFinset ùïú E F hs ‚ãØ) (p (k + l)) = 0 : Prop","lemma changeOriginSeriesTerm_bound (p : FormalMultilinearSeries ùïú E F) {n : ‚Ñï}
    (hn : ‚àÄ (m : ‚Ñï), n ‚â§ m ‚Üí p m = 0) (k l : ‚Ñï) {s : Finset (Fin (k + l))}
    (hs : s.card = l) (hkl : n ‚â§ k + l) :
    p.changeOriginSeriesTerm k l s hs = 0 ",":= by
  set_option maxSynthPendingDepth 2 in
  rw [changeOriginSeriesTerm, hn _ hkl, map_zero]"
Mathlib/Order/Heyting/Basic.lean,LE.le.disjoint_compl_left,LE.le.disjoint_compl_left,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":=
  disjoint_compl_left.mono_right h","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  disjoint_compl_left
has type
  b ‚â§ a ‚Üí Disjoint a·∂ú b",theorem LE.le.disjoint_compl_left (h : b ‚â§ a) : Disjoint a·∂ú b ,":=
  _root_.disjoint_compl_left.mono_right h"
Mathlib/LinearAlgebra/Matrix/IsDiag.lean,Matrix.isDiag_fromBlocks_iff,isDiag_fromBlocks_iff,8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85,":= by
  constructor
  ¬∑ intro h
    refine ‚ü®fun i j hij => ?_, ext fun i j => ?_, ext fun i j =?> _, fun i j hij => ?_‚ü©
    ¬∑ exact h (Sum.inl_injective.ne hij)
    ¬∑ exact h Sum.inl_ne_inr
    ¬∑ exact h Sum.inr_ne_inl
    ¬∑ exact h (Sum.inr_injective.ne hij)
  ¬∑ rintro ‚ü®ha, hb, hc, hd‚ü©
    convert IsDiag.fromBlocks ha hd","error:  unexpected token '='; expected '‚Ü¶', '=>'
error:  unsolved goals
case mp.refine_1
Œ± : Type u_1
Œ≤ : Type u_2
R : Type u_3
n : Type u_4
m : Type u_5
inst‚úù : Zero Œ±
A : Matrix m m Œ±
B : Matrix m n Œ±
C : Matrix n m Œ±
D : Matrix n n Œ±
h : (fromBlocks A B C D).IsDiag
i j : m
hij : i ‚â† j
‚ä¢ (fun i j ‚Ü¶ A i j = 0) i j

case mp.refine_2
Œ± : Type u_1
Œ≤ : Type u_2
R : Type u_3
n : Type u_4
m : Type u_5
inst‚úù : Zero Œ±
A : Matrix m m Œ±
B : Matrix m n Œ±
C : Matrix n m Œ±
D : Matrix n n Œ±
h : (fromBlocks A B C D).IsDiag
i : m
j : n
‚ä¢ B i j = 0 i j
error:  unsolved goals
case mpr
Œ± : Type u_1
Œ≤ : Type u_2
R : Type u_3
n : Type u_4
m : Type u_5
inst‚úù : Zero Œ±
A : Matrix m m Œ±
B : Matrix m n Œ±
C : Matrix n m Œ±
D : Matrix n n Œ±
‚ä¢ A.IsDiag ‚àß B = 0 ‚àß C = 0 ‚àß D.IsDiag ‚Üí (fromBlocks A B C D).IsDiag","theorem isDiag_fromBlocks_iff [Zero Œ±] {A : Matrix m m Œ±} {B : Matrix m n Œ±} {C : Matrix n m Œ±}
    {D : Matrix n n Œ±} : (A.fromBlocks B C D).IsDiag ‚Üî A.IsDiag ‚àß B = 0 ‚àß C = 0 ‚àß D.IsDiag ",":= by
  constructor
  ¬∑ intro h
    refine ‚ü®fun i j hij => ?_, ext fun i j => ?_, ext fun i j => ?_, fun i j hij => ?_‚ü©
    ¬∑ exact h (Sum.inl_injective.ne hij)
    ¬∑ exact h Sum.inl_ne_inr
    ¬∑ exact h Sum.inr_ne_inl
    ¬∑ exact h (Sum.inr_injective.ne hij)
  ¬∑ rintro ‚ü®ha, hb, hc, hd‚ü©
    convert IsDiag.fromBlocks ha hd"
Mathlib/RingTheory/IntegralClosure.lean,RingHom.isIntegralElem_leadingCoeff_mul,RingHom.isIntegralElem_leadingCoeff_mul,3b4737b3b07aa77aaa08420241e83ad9c46eda8a,":= by
  by_cases h' : 1 ‚â§ p.natDegree
  ¬∑ use normalizeScaleRoots p
    have : p ‚â† 0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_eval‚ÇÇ_leadingCoeff_mul p h' f x, h, MulZeroClass.mul_zero]
  ¬∑ by_cases hp : p.map f = 0
    ¬∑ apply_fun fun q => coeff q p.natDegree  at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, MulZeroClass.zero_mul]
      exact f.is_integral_zero
    ¬∑ rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', eval‚ÇÇ_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]","error:  invalid field 'is_integral_zero', the environment does not contain 'RingHom.is_integral_zero'
  f
has type
  R ‚Üí+* S","theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval‚ÇÇ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) ",":= by
  by_cases h' : 1 ‚â§ p.natDegree
  ¬∑ use normalizeScaleRoots p
    have : p ‚â† 0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_eval‚ÇÇ_leadingCoeff_mul p h' f x, h, mul_zero]
  ¬∑ by_cases hp : p.map f = 0
    ¬∑ apply_fun fun q => coeff q p.natDegree at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, zero_mul]
      exact f.isIntegralElem_zero
    ¬∑ rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', eval‚ÇÇ_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]"
Mathlib/Geometry/Manifold/IntegralCurve.lean,IsIntegralCurveAt.comp_mul_ne_zero,IsIntegralCurveAt.comp_mul_ne_zero,2c4d77d7fd709133772709da9ffb1d698ecbcd0a,":= by
  obtain ‚ü®Œµ, hŒµ, h‚ü© := hŒ≥
  refine ‚ü®Œµ / |a|, div_pos hŒµ (abs_pos.mpr ha), ?_‚ü©
  convert h.comp_mul a
  ext t
  rw [Ioo, Ioo, mem_setOf_eq, mem_setOf_eq, mem_setOf_eq]
  by_cases ha' : 0 < a
  ¬∑ rw [abs_eq_self.mpr (le_of_lt ha'), ‚Üê sub_div, ‚Üê add_div, div_lt_iff ha', lt_div_iff ha']
  ¬∑ rw [abs_eq_neg_self.mpr (not_lt.mp ha'), div_neg, sub_neg_eq_add, ‚Üê sub_eq_add_neg, ‚Üê sub_div,
    ‚Üê add_div, div_lt_iff_of_neg (ha.lt_of_le (not_lt.mp ha')),
    lt_div_iff_of_neg (ha.lt_of_le (not_lt.mp ha')), and_comm]","error:  rcases tactic failed: hŒ≥ : (ùìù t‚ÇÄ).1
  {x | (fun t ‚Ü¶ HasMFDerivAt ùìò(‚Ñù, ‚Ñù) I Œ≥ t (ContinuousLinearMap.smulRight 1 (v (Œ≥ t)))) x} is not an inductive datatype","lemma IsIntegralCurveAt.comp_mul_ne_zero (hŒ≥ : IsIntegralCurveAt Œ≥ v t‚ÇÄ) {a : ‚Ñù} (ha : a ‚â† 0) :
    IsIntegralCurveAt (Œ≥ ‚àò (¬∑ * a)) (a ‚Ä¢ v) (t‚ÇÄ / a) ",":= by
  rw [isIntegralCurveAt_iff'] at *
  obtain ‚ü®Œµ, hŒµ, h‚ü© := hŒ≥
  refine ‚ü®Œµ / |a|, by positivity, ?_‚ü©
  convert h.comp_mul a
  ext t
  rw [mem_setOf_eq, Metric.mem_ball, Metric.mem_ball, Real.dist_eq, Real.dist_eq,
    lt_div_iff (abs_pos.mpr ha), ‚Üê abs_mul, sub_mul, div_mul_cancel‚ÇÄ _ ha]"
Mathlib/Computability/TuringMachine.lean,Turing.TM2to1.tr_respects_aux‚ÇÇ,tr_respects_aux‚ÇÇ,c861dd6cd08bd7df736e7bd108071ed1e6be9ee8,":= by
  dsimp only; simp; cases o with simp only [stWrite, stVar, trStAct, TM1.stepAux]
  | push f =>
    have := Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k (some (f v)))
    refine'
      ‚ü®_, fun k' ‚Ü¶ _, by
        erw [Tape.move_right_n_head, List.length, Tape.mk'_nth_nat, this,
          addBottom_modifyNth fun a ‚Ü¶ update a k (some (f v)), Nat.add_one, iterate_succ']
        rfl‚ü©
    refine ListBlank.ext fun i ‚Ü¶ ?_
    rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
    by_cases h' : k' = k
    ¬∑ subst k'
      split_ifs with h
        <;> simp only [List.reverse_cons, Function.update_same, ListBlank.nth_mk, List.map]
      ¬∑ rw [List.getI_eq_get, List.get_append_right'] <;>
          simp only [h, List.get_singleton, List.length_map, List.length_reverse, Nat.succ_pos',
            List.length_append, lt_add_iff_pos_right, List.length, le_refl]
      rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk]
      cases' lt_or_gt_of_ne h with h h
      ¬∑ rw [List.getI_append]
        simpa only [List.length_map, List.length_reverse] using h
      ¬∑ rw [gt_iff_lt] at h
        rw [List.getI_eq_default, List.getI_eq_default] <;>
          simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
            List.length_append, List.length_map]
    ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
      rw [Function.update_noteq h']
  | peek f =>
    rw [Function.update_eq_self]
    use L, hL; rw [Tape.move_left_right]; congr
    cases e : S k; ¬∑ rfl
    rw [List.length_cons, iterate_succ', Function.comp, Tape.move_right_left,
      Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_snd, stk_nth_val _ (hL k), e,
      List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length]
    rfl
  | pop f =>
    cases' e : S k with hd tl
    ¬∑ simp only [Tape.mk'_head, ListBlank.head_cons, Tape.move_left_mk', List.length,
        Tape.write_mk', List.head?, iterate_zero_apply, List.tail_nil]
      rw [‚Üê e, Function.update_eq_self]
      exact ‚ü®L, hL, by rw [addBottom_head_fst, cond]‚ü©
    ¬∑ refine'
        ‚ü®_, fun k' ‚Ü¶ _, by
          erw [List.length_cons, Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_succ_fst,
            cond, iterate_succ', Function.comp, Tape.move_right_left, Tape.move_right_n_head,
            Tape.mk'_nth_nat, Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k none),
            addBottom_modifyNth fun a ‚Ü¶ update a k none, addBottom_nth_snd,
            stk_nth_val _ (hL k), e,
            show (List.cons hd tl).reverse.get? tl.length = some hd by
              rw [List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length],
            List.head?, List.tail]‚ü©
      refine ListBlank.ext fun i ‚Ü¶ ?_
      rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
      by_cases h' : k' = k
      ¬∑ subst k'
        split_ifs with h <;> simp only [Function.update_same, ListBlank.nth_mk, List.tail]
        ¬∑ rw [List.getI_eq_default]
          ¬∑ rfl
          rw [h, List.length_reverse, List.length_map]
        rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk, e, List.map, List.reverse_cons]
        cases' lt_or_gt_of_ne h with h h
        ¬∑ rw [List.getI_append]
          simpa only [List.length_map, List.length_reverse] using h
        ¬∑ rw [gt_iff_lt] at h
          rw [List.getI_eq_default, List.getI_eq_default] <;>
            simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
              List.length_append, List.length_map]
      ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
        rw [Function.update_noteq h']","warning:  `List.get_append` has been deprecated, use `List.getElem_append` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get_replicate` has been deprecated, use `List.getElem_replicate` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  unused variable `M`
note: this linter can be disabled with `set_option linter.unusedVariables false`
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
error:  unsolved goals
case pos.h‚ÇÇ
K : Type u_1
inst‚úù¬≤ : DecidableEq K
Œì : K ‚Üí Type u_2
Œõ : Type u_3
inst‚úù¬π : Inhabited Œõ
œÉ : Type u_4
inst‚úù : Inhabited œÉ
k : K
q : TM1.Stmt Œì' Œõ' œÉ
v : œÉ
S : (k : K) ‚Üí List (Œì k)
L : ListBlank ((k : K) ‚Üí Option (Œì k))
hL : ‚àÄ (k : K), ListBlank.map (proj k) L = ListBlank.mk (List.map some (S k)).reverse
f : œÉ ‚Üí Œì k
this :
  ‚àÄ (L R : ListBlank Œì') (n : ‚Ñï),
    Tape.write ((R.nth n).1, update (R.nth n).2 k (some (f v))) ((Tape.move Dir.right)^[n] (Tape.mk' L R)) =
      (Tape.move Dir.right)^[n] (Tape.mk' L (ListBlank.modifyNth (fun a ‚Ü¶ (a.1, update a.2 k (some (f v)))) n R))
i : ‚Ñï
h : i = (S k).length
‚ä¢ (S k).length < (S k).length + (0 + 1)
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead","theorem tr_respects_aux‚ÇÇ {k : K} {q : Stmt‚ÇÇ‚ÇÅ} {v : œÉ} {S : ‚àÄ k, List (Œì k)}
    {L : ListBlank (‚àÄ k, Option (Œì k))}
    (hL : ‚àÄ k, L.map (proj k) = ListBlank.mk ((S k).map some).reverse) (o : StAct‚ÇÇ k) :
    let v' := stVar v (S k) o
    let Sk' := stWrite v (S k) o
    let S' := update S k Sk'
    ‚àÉ L' : ListBlank (‚àÄ k, Option (Œì k)),
      (‚àÄ k, L'.map (proj k) = ListBlank.mk ((S' k).map some).reverse) ‚àß
        TM1.stepAux (trStAct q o) v
            ((Tape.move Dir.right)^[(S k).length] (Tape.mk' ‚àÖ (addBottom L))) =
          TM1.stepAux q v' ((Tape.move Dir.right)^[(S' k).length] (Tape.mk' ‚àÖ (addBottom L'))) ",":= by
  dsimp only; simp; cases o with simp only [stWrite, stVar, trStAct, TM1.stepAux]
  | push f =>
    have := Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k (some (f v)))
    refine
      ‚ü®_, fun k' ‚Ü¶ ?_, by
        erw [Tape.move_right_n_head, List.length, Tape.mk'_nth_nat, this,
          addBottom_modifyNth fun a ‚Ü¶ update a k (some (f v)), Nat.add_one, iterate_succ']
        rfl‚ü©
    refine ListBlank.ext fun i ‚Ü¶ ?_
    rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
    by_cases h' : k' = k
    ¬∑ subst k'
      split_ifs with h
        <;> simp only [List.reverse_cons, Function.update_same, ListBlank.nth_mk, List.map]
      ¬∑ rw [List.getI_eq_get, List.get_append_right'] <;>
          simp only [List.length_singleton, h, List.length_reverse, List.length_map, Nat.sub_self,
            Fin.zero_eta, List.get_cons_zero, le_refl, List.length_append, Nat.lt_succ_self]
      rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk]
      cases' lt_or_gt_of_ne h with h h
      ¬∑ rw [List.getI_append]
        simpa only [List.length_map, List.length_reverse] using h
      ¬∑ rw [gt_iff_lt] at h
        rw [List.getI_eq_default, List.getI_eq_default] <;>
          simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
            List.length_append, List.length_map]
    ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
      rw [Function.update_noteq h']
  | peek f =>
    rw [Function.update_eq_self]
    use L, hL; rw [Tape.move_left_right]; congr
    cases e : S k; ¬∑ rfl
    rw [List.length_cons, iterate_succ', Function.comp, Tape.move_right_left,
      Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_snd, stk_nth_val _ (hL k), e,
      List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length]
    rfl
  | pop f =>
    cases' e : S k with hd tl
    ¬∑ simp only [Tape.mk'_head, ListBlank.head_cons, Tape.move_left_mk', List.length,
        Tape.write_mk', List.head?, iterate_zero_apply, List.tail_nil]
      rw [‚Üê e, Function.update_eq_self]
      exact ‚ü®L, hL, by rw [addBottom_head_fst, cond]‚ü©
    ¬∑ refine
        ‚ü®_, fun k' ‚Ü¶ ?_, by
          erw [List.length_cons, Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_succ_fst,
            cond, iterate_succ', Function.comp, Tape.move_right_left, Tape.move_right_n_head,
            Tape.mk'_nth_nat, Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k none),
            addBottom_modifyNth fun a ‚Ü¶ update a k none, addBottom_nth_snd,
            stk_nth_val _ (hL k), e,
            show (List.cons hd tl).reverse.get? tl.length = some hd by
              rw [List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length],
            List.head?, List.tail]‚ü©
      refine ListBlank.ext fun i ‚Ü¶ ?_
      rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
      by_cases h' : k' = k
      ¬∑ subst k'
        split_ifs with h <;> simp only [Function.update_same, ListBlank.nth_mk, List.tail]
        ¬∑ rw [List.getI_eq_default]
          ¬∑ rfl
          rw [h, List.length_reverse, List.length_map]
        rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk, e, List.map, List.reverse_cons]
        cases' lt_or_gt_of_ne h with h h
        ¬∑ rw [List.getI_append]
          simpa only [List.length_map, List.length_reverse] using h
        ¬∑ rw [gt_iff_lt] at h
          rw [List.getI_eq_default, List.getI_eq_default] <;>
            simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
              List.length_append, List.length_map]
      ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
        rw [Function.update_noteq h']"
Mathlib/Data/Seq/Computation.lean,Computation.of_results_think,of_results_think,3c930599229893e1b6a931304cf4efff4a01b172,":= by
  haveI := of_think_terminates h.terminates
  have := results_of_terminates' _ (of_mem_think h.mem)
  exact ‚ü®_, this, Results.len_unique h (results_think this)‚ü©","error:  unknown identifier 'of_mem_think'
error:  unsolved goals
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
s : Computation Œ±
a : Œ±
n : ‚Ñï
h : s.think.Results a n
this : s.Terminates
‚ä¢ ‚àÉ m, s.Results a m ‚àß n = m + 1","theorem of_results_think {s : Computation Œ±} {a n} (h : Results (think s) a n) :
    ‚àÉ m, Results s a m ‚àß n = m + 1 ",":= by
  haveI := of_think_terminates h.terminates
  have := results_of_terminates' _ (of_think_mem h.mem)
  exact ‚ü®_, this, Results.len_unique h (results_think this)‚ü©"
Mathlib/FieldTheory/ChevalleyWarning.lean,char_dvd_card_solutions,char_dvd_card_solutions,2eaabc8998929678aa5be0e0139f3ea37acc7a44,":= by
  have hq : 0 < q - 1 := by rw [‚Üê Fintype.card_units, Fintype.card_pos_iff]; exact ‚ü®1‚ü©
  let S : Finset (œÉ ‚Üí K) := {x | ‚àÄ i ‚àà s, eval x (f i) = 0}
  have hS (x : œÉ ‚Üí K) : x ‚àà S ‚Üî ‚àÄ i ‚àà s, eval x (f i) = 0 := by simp [S]
  let F : MvPolynomial œÉ K := ‚àè i ‚àà s, (1 - f i ^ (q - 1))
  have hF : ‚àÄ x, eval x F = if x ‚àà S then 1 else 0 := by
    intro x
    calc
      eval x F = ‚àè i ‚àà s, eval x (1 - f i ^ (q - 1)) := eval_prod s _ x
      _ = if x ‚àà S then 1 else 0 := ?_
    simp only [(eval x).map_sub, (eval x).map_pow, (eval x).map_one]
    split_ifs with hx
    ¬∑ apply Finset.prod_eq_one
      intro i hi
      rw [hS] at hx
      rw [hx i hi, zero_pow hq.ne', sub_zero]
    ¬∑ obtain ‚ü®i, hi, hx‚ü© : ‚àÉ i ‚àà s, eval x (f i) ‚â† 0 := by
        simpa [hS, not_forall, Classical.not_imp] using hx
      apply Finset.prod_eq_zero hi
      rw [pow_card_sub_one_eq_one (eval x (f i)) hx, sub_self]
  have key : ‚àë x, eval x F = Fintype.card { x : œÉ ‚Üí K // ‚àÄ i ‚àà s, eval x (f i) = 0 } := by
    rw [Fintype.card_of_subtype S hS, card_eq_sum_ones, Nat.cast_sum, Nat.cast_one, ‚Üê
      Fintype.sum_extend_by_zero S, sum_congr rfl fun x _ => hF x]
  show p ‚à£ Fintype.card { x // ‚àÄ i : Œπ, i ‚àà s ‚Üí eval x (f i) = 0 }
  rw [‚Üê CharP.cast_eq_zero_iff K, ‚Üê key]
  show (‚àë x, eval x F) = 0
  apply F.sum_eval_eq_zero
  show F.totalDegree < (q - 1) * Fintype.card œÉ
  calc
    F.totalDegree ‚â§ ‚àë i ‚àà s, (1 - f i ^ (q - 1)).totalDegree := totalDegree_finset_prod s _
    _ ‚â§ ‚àë i ‚àà s, (q - 1) * (f i).totalDegree := sum_le_sum fun i _ => ?_
    _ = (q - 1) * ‚àë i ‚àà s, (f i).totalDegree := (mul_sum ..).symm
    _ < (q - 1) * Fintype.card œÉ := by rwa [mul_lt_mul_left hq]
  show (1 - f i ^ (q - 1)).totalDegree ‚â§ (q - 1) * (f i).totalDegree
  calc
    (1 - f i ^ (q - 1)).totalDegree ‚â§
        max (1 : MvPolynomial œÉ K).totalDegree (f i ^ (q - 1)).totalDegree := totalDegree_sub _ _
    _ ‚â§ (f i ^ (q - 1)).totalDegree := by simp
    _ ‚â§ (q - 1) * (f i).totalDegree := totalDegree_pow _ _","error:  type mismatch
  {x | ‚àÄ i ‚àà s, (eval x) (f i) = 0}
has type
  Set (œÉ ‚Üí K) : Type (max u_2 u_1)
but is expected to have type
  Finset (œÉ ‚Üí K) : Type (max u_1 u_2)
error:  unsolved goals
K : Type u_1
œÉ : Type u_2
Œπ : Type u_3
inst‚úù‚Åµ : Fintype K
inst‚úù‚Å¥ : Field K
inst‚úù¬≥ : Fintype œÉ
inst‚úù¬≤ : DecidableEq œÉ
inst‚úù¬π : DecidableEq K
p : ‚Ñï
inst‚úù : CharP K p
s : Finset Œπ
f : Œπ ‚Üí MvPolynomial œÉ K
h : ‚àë i ‚àà s, (f i).totalDegree < Fintype.card œÉ
hq : 0 < q - 1
S : Finset (œÉ ‚Üí K) := sorryAx (Finset (œÉ ‚Üí K)) true
x : œÉ ‚Üí K
‚ä¢ x ‚àà sorryAx (Finset (œÉ ‚Üí K)) true ‚Üî ‚àÄ i ‚àà s, (eval x) (f i) = 0","theorem char_dvd_card_solutions_of_sum_lt {s : Finset Œπ} {f : Œπ ‚Üí MvPolynomial œÉ K}
    (h : (‚àë i ‚àà s, (f i).totalDegree) < Fintype.card œÉ) :
    p ‚à£ Fintype.card { x : œÉ ‚Üí K // ‚àÄ i ‚àà s, eval x (f i) = 0 } ",":= by
  have hq : 0 < q - 1 := by rw [‚Üê Fintype.card_units, Fintype.card_pos_iff]; exact ‚ü®1‚ü©
  let S : Finset (œÉ ‚Üí K) := { x ‚àà univ | ‚àÄ i ‚àà s, eval x (f i) = 0 }.toFinset
  have hS : ‚àÄ x : œÉ ‚Üí K, x ‚àà S ‚Üî ‚àÄ i : Œπ, i ‚àà s ‚Üí eval x (f i) = 0 := by
    intro x
    simp only [S, Set.toFinset_setOf, mem_univ, true_and, mem_filter]
  let F : MvPolynomial œÉ K := ‚àè i ‚àà s, (1 - f i ^ (q - 1))
  have hF : ‚àÄ x, eval x F = if x ‚àà S then 1 else 0 := by
    intro x
    calc
      eval x F = ‚àè i ‚àà s, eval x (1 - f i ^ (q - 1)) := eval_prod s _ x
      _ = if x ‚àà S then 1 else 0 := ?_
    simp only [(eval x).map_sub, (eval x).map_pow, (eval x).map_one]
    split_ifs with hx
    ¬∑ apply Finset.prod_eq_one
      intro i hi
      rw [hS] at hx
      rw [hx i hi, zero_pow hq.ne', sub_zero]
    ¬∑ obtain ‚ü®i, hi, hx‚ü© : ‚àÉ i ‚àà s, eval x (f i) ‚â† 0 := by
        simpa [hS, not_forall, Classical.not_imp] using hx
      apply Finset.prod_eq_zero hi
      rw [pow_card_sub_one_eq_one (eval x (f i)) hx, sub_self]
  have key : ‚àë x, eval x F = Fintype.card { x : œÉ ‚Üí K // ‚àÄ i ‚àà s, eval x (f i) = 0 } := by
    rw [Fintype.card_of_subtype S hS, card_eq_sum_ones, Nat.cast_sum, Nat.cast_one, ‚Üê
      Fintype.sum_extend_by_zero S, sum_congr rfl fun x _ => hF x]
  show p ‚à£ Fintype.card { x // ‚àÄ i : Œπ, i ‚àà s ‚Üí eval x (f i) = 0 }
  rw [‚Üê CharP.cast_eq_zero_iff K, ‚Üê key]
  show (‚àë x, eval x F) = 0
  apply F.sum_eval_eq_zero
  show F.totalDegree < (q - 1) * Fintype.card œÉ
  calc
    F.totalDegree ‚â§ ‚àë i ‚àà s, (1 - f i ^ (q - 1)).totalDegree := totalDegree_finset_prod s _
    _ ‚â§ ‚àë i ‚àà s, (q - 1) * (f i).totalDegree := sum_le_sum fun i _ => ?_
    _ = (q - 1) * ‚àë i ‚àà s, (f i).totalDegree := (mul_sum ..).symm
    _ < (q - 1) * Fintype.card œÉ := by rwa [mul_lt_mul_left hq]
  show (1 - f i ^ (q - 1)).totalDegree ‚â§ (q - 1) * (f i).totalDegree
  calc
    (1 - f i ^ (q - 1)).totalDegree ‚â§
        max (1 : MvPolynomial œÉ K).totalDegree (f i ^ (q - 1)).totalDegree := totalDegree_sub _ _
    _ ‚â§ (f i ^ (q - 1)).totalDegree := by simp
    _ ‚â§ (q - 1) * (f i).totalDegree := totalDegree_pow _ _"
Mathlib/RingTheory/Polynomial/Pochhammer.lean,ascPochhammer_natDegree,ascPochhammer_natDegree,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' n with n hn
  ¬∑ simp
  ¬∑ have : natDegree (X + (n : S[X])) = 1 := natDegree_X_add_C (n : S)
    rw [ascPochhammer_succ_right,
        natDegree_mul _ (ne_zero_of_natDegree_gt <| this.symm ‚ñ∏ Nat.zero_lt_one), hn, this]
    cases n
    ¬∑ simp
    ¬∑ refine' ne_zero_of_natDegree_gt <| hn.symm ‚ñ∏ Nat.succ_pos _","error:  invalid `‚ñ∏` notation, the equality
  Eq.symm hn
has type 
  n‚úù + 1 = (ascPochhammer S (n‚úù + 1)).natDegree
but neither side of the equality is mentioned in the type
  0 < ?m.29969.succ
error:  unsolved goals
case succ
S : Type u
inst‚úù¬≤ : Semiring S
inst‚úù¬π : NoZeroDivisors S
inst‚úù : Nontrivial S
n‚úù : ‚Ñï
hn : (ascPochhammer S (n‚úù + 1)).natDegree = n‚úù + 1
this : (X + ‚Üë(n‚úù + 1)).natDegree = 1
‚ä¢ ‚Ñï","theorem ascPochhammer_natDegree (n : ‚Ñï) [NoZeroDivisors S] [Nontrivial S] :
    (ascPochhammer S n).natDegree = n ",":= by
  induction' n with n hn
  ¬∑ simp
  ¬∑ have : natDegree (X + (n : S[X])) = 1 := natDegree_X_add_C (n : S)
    rw [ascPochhammer_succ_right,
        natDegree_mul _ (ne_zero_of_natDegree_gt <| this.symm ‚ñ∏ Nat.zero_lt_one), hn, this]
    cases n
    ¬∑ simp
    ¬∑ refine ne_zero_of_natDegree_gt <| hn.symm ‚ñ∏ Nat.add_one_pos _"
Mathlib/Topology/FiberBundle/Basic.lean,FiberBundle.exists_trivialization_Icc_subset,FiberBundle.exists_trivialization_Icc_subset,f7006a73d443b58eaf61494edacfeaae71d812f2,":= by
  obtain ‚ü®ea, hea‚ü© : ‚àÉ ea : Trivialization F (œÄ F E), a ‚àà ea.baseSet :=
    ‚ü®trivializationAt F E a, mem_baseSet_trivializationAt F E a‚ü©
  cases' lt_or_le b a with hab hab
  ¬∑ exact ‚ü®ea, by simp [*]‚ü©
  set s : Set B := { x ‚àà Icc a b | ‚àÉ e : Trivialization F (œÄ F E), Icc a x ‚äÜ e.baseSet }
  have ha : a ‚àà s := ‚ü®left_mem_Icc.2 hab, ea, by simp [hea]‚ü©
  have sne : s.Nonempty := ‚ü®a, ha‚ü©
  have hsb : b ‚àà upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := ‚ü®b, hsb‚ü©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c ‚àà Icc a b := ‚ü®hsc.1 ha, hsc.2 hsb‚ü©
  obtain ‚ü®-, ec : Trivialization F (œÄ F E), hec : Icc a c ‚äÜ ec.baseSet‚ü© : c ‚àà s := by
    cases' hc.1.eq_or_lt with heq hlt
    ¬∑ rwa [‚Üê heq]
    refine ‚ü®hc, ?_‚ü©
    obtain ‚ü®ec, hc‚ü© : ‚àÉ ec : Trivialization F (œÄ F E), c ‚àà ec.baseSet :=
      ‚ü®trivializationAt F E c, mem_baseSet_trivializationAt F E c‚ü©
    obtain ‚ü®c', hc', hc'e‚ü© : ‚àÉ c' ‚àà Ico a c, Ioc c' c ‚äÜ ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain ‚ü®d, ‚ü®hdab, ead, had‚ü©, hd‚ü© : ‚àÉ d ‚àà s, d ‚àà Ioc c' c := hsc.exists_between hc'.2
    refine' ‚ü®ead.piecewiseLe ec d (had ‚ü®hdab.1, le_rfl‚ü©) (hc'e hd), subset_ite.2 _‚ü©
    refine' ‚ü®fun x hx => had ‚ü®hx.1.1, hx.2‚ü©, fun x hx => hc'e ‚ü®hd.1.trans (not_le.1 hx.2), hx.1.2‚ü©‚ü©
  cases' hc.2.eq_or_lt with heq hlt
  ¬∑ exact ‚ü®ec, heq ‚ñ∏ hec‚ü©
  suffices : ‚àÉ d ‚àà Ioc c b, ‚àÉ e : Trivialization F (œÄ F E), Icc a d ‚äÜ e.baseSet
  ¬∑ rcases this with ‚ü®d, hdcb, hd‚ü© 
    exact ((hsc.1 ‚ü®‚ü®hc.1.trans hdcb.1.le, hdcb.2‚ü©, hd‚ü©).not_lt hdcb.1).elim
  obtain ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, Ico c d ‚äÜ ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec ‚ü®hc.1, le_rfl‚ü©))
  have had : Ico a d ‚äÜ ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  ¬∑ obtain ‚ü®ed, hed‚ü© : ‚àÉ ed : Trivialization F (œÄ F E), d ‚àà ed.baseSet :=
      ‚ü®trivializationAt F E d, mem_baseSet_trivializationAt F E d‚ü©
    refine' ‚ü®d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono (inter_subset_right _ _) (inter_subset_right _ _)), fun x hx => _‚ü©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr ‚ü®hed, hdcb.1‚ü©, Or.inl ‚ü®had ‚ü®hx.1, hxd‚ü©, hxd‚ü©]
  ¬∑ rw [disjoint_left] at he
    push_neg at he
    rcases he with ‚ü®d', hdd' : d' < d, hd'c‚ü©
    exact ‚ü®d', ‚ü®hd'c, hdd'.le.trans hdcb.2‚ü©, ec, (Icc_subset_Ico_right hdd').trans had‚ü©",error:  unexpected token ':'; expected term,"theorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]
    [OrderTopology B] [FiberBundle F E] (a b : B) :
    ‚àÉ e : Trivialization F (œÄ F E), Icc a b ‚äÜ e.baseSet ",":= by
  obtain ‚ü®ea, hea‚ü© : ‚àÉ ea : Trivialization F (œÄ F E), a ‚àà ea.baseSet :=
    ‚ü®trivializationAt F E a, mem_baseSet_trivializationAt F E a‚ü©
  cases' lt_or_le b a with hab hab
  ¬∑ exact ‚ü®ea, by simp [*]‚ü©
  set s : Set B := { x ‚àà Icc a b | ‚àÉ e : Trivialization F (œÄ F E), Icc a x ‚äÜ e.baseSet }
  have ha : a ‚àà s := ‚ü®left_mem_Icc.2 hab, ea, by simp [hea]‚ü©
  have sne : s.Nonempty := ‚ü®a, ha‚ü©
  have hsb : b ‚àà upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := ‚ü®b, hsb‚ü©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c ‚àà Icc a b := ‚ü®hsc.1 ha, hsc.2 hsb‚ü©
  obtain ‚ü®-, ec : Trivialization F (œÄ F E), hec : Icc a c ‚äÜ ec.baseSet‚ü© : c ‚àà s := by
    rcases hc.1.eq_or_lt with heq | hlt
    ¬∑ rwa [‚Üê heq]
    refine ‚ü®hc, ?_‚ü©
    obtain ‚ü®ec, hc‚ü© : ‚àÉ ec : Trivialization F (œÄ F E), c ‚àà ec.baseSet :=
      ‚ü®trivializationAt F E c, mem_baseSet_trivializationAt F E c‚ü©
    obtain ‚ü®c', hc', hc'e‚ü© : ‚àÉ c' ‚àà Ico a c, Ioc c' c ‚äÜ ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain ‚ü®d, ‚ü®hdab, ead, had‚ü©, hd‚ü© : ‚àÉ d ‚àà s, d ‚àà Ioc c' c := hsc.exists_between hc'.2
    refine ‚ü®ead.piecewiseLe ec d (had ‚ü®hdab.1, le_rfl‚ü©) (hc'e hd), subset_ite.2 ?_‚ü©
    exact ‚ü®fun x hx => had ‚ü®hx.1.1, hx.2‚ü©, fun x hx => hc'e ‚ü®hd.1.trans (not_le.1 hx.2), hx.1.2‚ü©‚ü©
  rcases hc.2.eq_or_lt with heq | hlt
  ¬∑ exact ‚ü®ec, heq ‚ñ∏ hec‚ü©
  rsuffices ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, ‚àÉ e : Trivialization F (œÄ F E), Icc a d ‚äÜ e.baseSet
  ¬∑ exact ((hsc.1 ‚ü®‚ü®hc.1.trans hdcb.1.le, hdcb.2‚ü©, hd‚ü©).not_lt hdcb.1).elim
  obtain ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, Ico c d ‚äÜ ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec ‚ü®hc.1, le_rfl‚ü©))
  have had : Ico a d ‚äÜ ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  ¬∑ obtain ‚ü®ed, hed‚ü© : ‚àÉ ed : Trivialization F (œÄ F E), d ‚àà ed.baseSet :=
      ‚ü®trivializationAt F E d, mem_baseSet_trivializationAt F E d‚ü©
    refine ‚ü®d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono inter_subset_right inter_subset_right), fun x hx => ?_‚ü©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr ‚ü®hed, hdcb.1‚ü©, Or.inl ‚ü®had ‚ü®hx.1, hxd‚ü©, hxd‚ü©]
  ¬∑ rw [disjoint_left] at he
    push_neg at he
    rcases he with ‚ü®d', hdd' : d' < d, hd'c‚ü©
    exact ‚ü®d', ‚ü®hd'c, hdd'.le.trans hdcb.2‚ü©, ec, (Icc_subset_Ico_right hdd').trans had‚ü©"
Mathlib/NumberTheory/LSeries/Deriv.lean,LSeries_iteratedDeriv,LSeries_iteratedDeriv,8bd4b55183e8c2f473879114c8faa6f2a10f615c,":= by
  induction' m with m ih generalizing s
  ¬∑ simp only [Nat.zero_eq, iteratedDeriv_zero, pow_zero, Function.iterate_zero, id_eq, one_mul]
  ¬∑ have ih' : {s | abscissaOfAbsConv f < re s}.EqOn (iteratedDeriv m (LSeries f))
        ((-1) ^ m * LSeries (logMul^[m] f)) := fun _ hs ‚Ü¶ ih hs
    have := derivWithin_congr ih' (ih h)
    simp_rw [derivWithin_of_isOpen (isOpen_re_gt_EReal _) h] at this
    rw [iteratedDeriv_succ, this]
    simp only [Pi.mul_def, Pi.pow_apply, Pi.neg_apply, Pi.one_apply, deriv_const_mul_field',
      pow_succ', mul_assoc, neg_one_mul, Function.iterate_succ', Function.comp_def,
      LSeries_deriv <| absicssaOfAbsConv_logPowMul.symm ‚ñ∏ h]","error:  unsolved goals
case succ
f : ‚Ñï ‚Üí ‚ÑÇ
m : ‚Ñï
ih : ‚àÄ {s : ‚ÑÇ}, abscissaOfAbsConv f < ‚Üës.re ‚Üí iteratedDeriv m (LSeries f) s = (-1) ^ m * LSeries (logMul^[m] f) s
s : ‚ÑÇ
h : abscissaOfAbsConv f < ‚Üës.re
ih' : Set.EqOn (iteratedDeriv m (LSeries f)) ((-1) ^ m * LSeries (logMul^[m] f)) {s | abscissaOfAbsConv f < ‚Üës.re}
this : deriv (iteratedDeriv m (LSeries f)) s = deriv ((-1) ^ m * LSeries (logMul^[m] f)) s
‚ä¢ (-1) ^ m * -LSeries (logMul (logMul^[m] f)) s = -(-1) ^ m * LSeries (logMul (logMul^[m] f)) s","lemma LSeries_iteratedDeriv {f : ‚Ñï ‚Üí ‚ÑÇ} (m : ‚Ñï) {s : ‚ÑÇ} (h : abscissaOfAbsConv f < s.re) :
    iteratedDeriv m (LSeries f) s = (-1) ^ m * LSeries (logMul^[m] f) s ",":= by
  induction' m with m ih generalizing s
  ¬∑ simp only [Nat.zero_eq, iteratedDeriv_zero, pow_zero, Function.iterate_zero, id_eq, one_mul]
  ¬∑ have ih' : {s | abscissaOfAbsConv f < re s}.EqOn (iteratedDeriv m (LSeries f))
        ((-1) ^ m * LSeries (logMul^[m] f)) := fun _ hs ‚Ü¶ ih hs
    have := derivWithin_congr ih' (ih h)
    simp_rw [derivWithin_of_isOpen (isOpen_re_gt_EReal _) h] at this
    rw [iteratedDeriv_succ, this]
    simp only [Pi.mul_def, Pi.pow_apply, Pi.neg_apply, Pi.one_apply, deriv_const_mul_field',
      pow_succ, mul_assoc, neg_one_mul, Function.iterate_succ', Function.comp_def,
      LSeries_deriv <| absicssaOfAbsConv_logPowMul.symm ‚ñ∏ h]"
Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean,GeneralizedContinuedFraction.IntFractPair.succ_nth_stream_eq_some_iff,succ_nth_stream_eq_some_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  by simp [IntFractPair.stream, ite_eq_iff]","error:  unsolved goals
K : Type u_1
inst‚úù¬π : LinearOrderedField K
inst‚úù : FloorRing K
v : K
n : ‚Ñï
ifp_succ_n : IntFractPair K
‚ä¢ ((IntFractPair.stream v n).bind fun ap_n ‚Ü¶ if ap_n.fr = 0 then none else some (IntFractPair.of ap_n.fr‚Åª¬π)) =
      some ifp_succ_n ‚Üî
    ‚àÉ ifp_n, IntFractPair.stream v n = some ifp_n ‚àß ¬¨ifp_n.fr = 0 ‚àß IntFractPair.of ifp_n.fr‚Åª¬π = ifp_succ_n","theorem succ_nth_stream_eq_some_iff {ifp_succ_n : IntFractPair K} :
    IntFractPair.stream v (n + 1) = some ifp_succ_n ‚Üî
      ‚àÉ ifp_n : IntFractPair K,
        IntFractPair.stream v n = some ifp_n ‚àß
          ifp_n.fr ‚â† 0 ‚àß IntFractPair.of ifp_n.fr‚Åª¬π = ifp_succ_n ",":= by
  simp [IntFractPair.stream, ite_eq_iff, Option.bind_eq_some]"
Mathlib/LinearAlgebra/AffineSpace/Independent.lean,affineIndependent_iff_eq_of_fintype_affineCombination_eq,affineIndependent_iff_eq_of_fintype_affineCombination_eq,9db546a81b334ba30d74fed40766bcdeffb50e5f,":= by
  rw [affineIndependent_iff_indicator_eq_of_affineCombination_eq]
  constructor
  ¬∑ intro h w1 w2 hw1 hw2 hweq
    simpa only [Set.indicator_univ, Finset.coe_univ] using h _ _ w1 w2 hw1 hw2 hweq
  ¬∑ intro h s1 s2 w1 w2 hw1 hw2 hweq
    have hw1' : (‚àë i, (s1 : Set Œπ).indicator w1 i) = 1 := by
      rwa [Set.sum_indicator_subset _ (Finset.subset_univ s1)] at hw1
    have hw2' : (‚àë i, (s2 : Set Œπ).indicator w2 i) = 1 := by
      rwa [Set.sum_indicator_subset _ (Finset.subset_univ s2)] at hw2
    rw [Finset.affineCombination_indicator_subset w1 p (Finset.subset_univ s1),
      Finset.affineCombination_indicator_subset w2 p (Finset.subset_univ s2)] at hweq
    exact h _ _ hw1' hw2' hweq","error:  unknown constant 'Set.sum_indicator_subset'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.61661
k : Type u_1
V : Type u_2
P : Type u_3
inst‚úù‚Å¥ : Ring k
inst‚úù¬≥ : AddCommGroup V
inst‚úù¬≤ : Module k V
inst‚úù¬π : AffineSpace V P
Œπ : Type u_4
inst‚úù : Fintype Œπ
p : Œπ ‚Üí P
h :
  ‚àÄ (w1 w2 : Œπ ‚Üí k),
    ‚àë i : Œπ, w1 i = 1 ‚Üí ‚àë i : Œπ, w2 i = 1 ‚Üí (affineCombination k univ p) w1 = (affineCombination k univ p) w2 ‚Üí w1 = w2
s1 s2 : Finset Œπ
w1 w2 : Œπ ‚Üí k
hw1 : ‚àë i ‚àà s1, w1 i = 1
hw2 : ‚àë i ‚àà s2, w2 i = 1
hweq : (affineCombination k s1 p) w1 = (affineCombination k s2 p) w2
‚ä¢ ‚àë i : Œπ, (‚Üës1).indicator w1 i = 1
error:  unknown constant 'Set.sum_indicator_subset'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.62112
k : Type u_1
V : Type u_2
P : Type u_3
inst‚úù‚Å¥ : Ring k
inst‚úù¬≥ : AddCommGroup V
inst‚úù¬≤ : Module k V
inst‚úù¬π : AffineSpace V P
Œπ : Type u_4
inst‚úù : Fintype Œπ
p : Œπ ‚Üí P
h :
  ‚àÄ (w1 w2 : Œπ ‚Üí k),
    ‚àë i : Œπ, w1 i = 1 ‚Üí ‚àë i : Œπ, w2 i = 1 ‚Üí (affineCombination k univ p) w1 = (affineCombination k univ p) w2 ‚Üí w1 = w2
s1 s2 : Finset Œπ
w1 w2 : Œπ ‚Üí k
hw1 : ‚àë i ‚àà s1, w1 i = 1
hw2 : ‚àë i ‚àà s2, w2 i = 1
hweq : (affineCombination k s1 p) w1 = (affineCombination k s2 p) w2
hw1' : ‚àë i : Œπ, (‚Üës1).indicator w1 i = 1
‚ä¢ ‚àë i : Œπ, (‚Üës2).indicator w2 i = 1","theorem affineIndependent_iff_eq_of_fintype_affineCombination_eq [Fintype Œπ] (p : Œπ ‚Üí P) :
    AffineIndependent k p ‚Üî ‚àÄ w1 w2 : Œπ ‚Üí k, ‚àë i, w1 i = 1 ‚Üí ‚àë i, w2 i = 1 ‚Üí
    Finset.univ.affineCombination k p w1 = Finset.univ.affineCombination k p w2 ‚Üí w1 = w2 ",":= by
  rw [affineIndependent_iff_indicator_eq_of_affineCombination_eq]
  constructor
  ¬∑ intro h w1 w2 hw1 hw2 hweq
    simpa only [Set.indicator_univ, Finset.coe_univ] using h _ _ w1 w2 hw1 hw2 hweq
  ¬∑ intro h s1 s2 w1 w2 hw1 hw2 hweq
    have hw1' : (‚àë i, (s1 : Set Œπ).indicator w1 i) = 1 := by
      rwa [Finset.sum_indicator_subset _ (Finset.subset_univ s1)]
    have hw2' : (‚àë i, (s2 : Set Œπ).indicator w2 i) = 1 := by
      rwa [Finset.sum_indicator_subset _ (Finset.subset_univ s2)]
    rw [Finset.affineCombination_indicator_subset w1 p (Finset.subset_univ s1),
      Finset.affineCombination_indicator_subset w2 p (Finset.subset_univ s2)] at hweq
    exact h _ _ hw1' hw2' hweq"
Mathlib/Data/Nat/Bits.lean,Nat.bodd_succ,bodd_succ,c047c646d66e915f27c3e7f159bef508bfc8dd10,":= by
  simp only [bodd, succ_eq_add_one, one_and_eq_mod_two]
  cases mod_two_eq_zero_or_one n with | _ h => simp [h, add_mod]","error:  simp made no progress
error:  simp made no progress
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated",lemma bodd_succ (n : ‚Ñï) : bodd (succ n) = not (bodd n) ,":= by
  simp only [bodd, boddDiv2]
  let ‚ü®b,m‚ü© := boddDiv2 n
  cases b <;> rfl"
Mathlib/MeasureTheory/Measure/AddContent.lean,MeasureTheory.addContent_union_le,addContent_union_le,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [‚Üê union_diff_self, addContent_union hC hs (hC.diff_mem ht hs)]
  ¬∑ exact add_le_add le_rfl
      (addContent_mono hC.isSetSemiring (hC.diff_mem ht hs) ht (diff_subset _ _))
  ¬∑ rw [Set.disjoint_iff_inter_eq_empty, inter_diff_self]","error:  function expected at
  diff_subset ?m.17879
term has type
  ?m.17878 ‚àà ?m.17876","lemma addContent_union_le (hC : IsSetRing C) (hs : s ‚àà C) (ht : t ‚àà C) :
    m (s ‚à™ t) ‚â§ m s + m t ",":= by
  rw [‚Üê union_diff_self, addContent_union hC hs (hC.diff_mem ht hs)]
  ¬∑ exact add_le_add le_rfl
      (addContent_mono hC.isSetSemiring (hC.diff_mem ht hs) ht diff_subset)
  ¬∑ rw [Set.disjoint_iff_inter_eq_empty, inter_diff_self]"
Mathlib/RingTheory/DedekindDomain/Different.lean,FractionalIdeal.self_mul_dual,self_mul_dual,3465d1aaae242475fad59e688648a2285031d19e,":= by
  rw [mul_comm, dual_mul_self hI]","error:  application type mismatch
  dual_mul_self hI
argument
  hI
has type
  I ‚â† 0 : Prop
but is expected to have type
  Type ?u.431094 : Type (?u.431094 + 1)","lemma self_mul_dual :
    I * dual A K I = dual A K 1 ",":= by
  rw [mul_comm, dual_mul_self A K hI]"
Mathlib/Topology/Algebra/Valuation.lean,Valuation.subgroups_basis,subgroups_basis,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":=
  { inter := by
      rintro Œ≥‚ÇÄ Œ≥‚ÇÅ
      use min Œ≥‚ÇÄ Œ≥‚ÇÅ
      simp [Valuation.ltAddSubgroup]
      tauto
    mul := by
      rintro Œ≥
      cases' exists_square_le Œ≥ with Œ≥‚ÇÄ h
      use Œ≥‚ÇÄ
      rintro - ‚ü®r, s, r_in, s_in, rfl‚ü©
      calc
        (v (r * s) : Œì‚ÇÄ) = v r * v s := Valuation.map_mul _ _ _
        _ < Œ≥‚ÇÄ * Œ≥‚ÇÄ := (mul_lt_mul‚ÇÄ r_in s_in)
        _ ‚â§ Œ≥ := by exact_mod_cast h
    leftMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use (1 : Œì‚ÇÄÀ£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, MulZeroClass.zero_mul]
        exact Units.zero_lt Œ≥
      ¬∑ simp only [image_subset_iff, setOf_subset_setOf, preimage_setOf_eq, Valuation.map_mul]
        use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (x * y) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt
    rightMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, MulZeroClass.mul_zero]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (y * x) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt }","error:  application type mismatch
  v s
argument
  s
has type
  r ‚àà ‚Üë(v.ltAddSubgroup Œ≥‚ÇÄ) : Prop
but is expected to have type
  R : Type u
error:  invalid 'calc' step, failed to synthesize `Trans` instance
  Trans LT.lt Membership.mem ?m.35107
use `set_option diagnostics true` to get diagnostic information
error:  simp made no progress",theorem subgroups_basis : RingSubgroupsBasis fun Œ≥ : Œì‚ÇÄÀ£ => (v.ltAddSubgroup Œ≥ : AddSubgroup R) ,":=
  { inter := by
      rintro Œ≥‚ÇÄ Œ≥‚ÇÅ
      use min Œ≥‚ÇÄ Œ≥‚ÇÅ
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro Œ≥
      cases' exists_square_le Œ≥ with Œ≥‚ÇÄ h
      use Œ≥‚ÇÄ
      rintro - ‚ü®r, r_in, s, s_in, rfl‚ü©
      calc
        (v (r * s) : Œì‚ÇÄ) = v r * v s := Valuation.map_mul _ _ _
        _ < Œ≥‚ÇÄ * Œ≥‚ÇÄ := mul_lt_mul‚ÇÄ r_in s_in
        _ ‚â§ Œ≥ := mod_cast h
    leftMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use (1 : Œì‚ÇÄÀ£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (x * y) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt
    rightMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (y * x) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt }"
Mathlib/MeasureTheory/Integral/IntegrableOn.lean,MeasureTheory.IntegrableOn.restrict,IntegrableOn.restrict,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [IntegrableOn, Measure.restrict_restrict hs]; exact h.mono_set (inter_subset_left _ _)","error:  function expected at
  inter_subset_left ?m.10917
term has type
  ?m.10916 ‚àà ?m.10914","theorem IntegrableOn.restrict (h : IntegrableOn f s Œº) (hs : MeasurableSet s) :
    IntegrableOn f s (Œº.restrict t) ",":= by
  rw [IntegrableOn, Measure.restrict_restrict hs]; exact h.mono_set inter_subset_left"
Mathlib/Algebra/Polynomial/Mirror.lean,Polynomial.mirror_eval_one,mirror_eval_one,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  simp_rw [eval_eq_sum_range, one_pow, mul_one, mirror_natDegree]
  refine Finset.sum_bij_ne_zero ?_ ?_?? _ _ ?_
  ¬∑ exact fun n _ _ => revAt (p.natDegree + p.natTrailingDegree) n
  ¬∑ intro n hn hp
    rw [Finset.mem_range_succ_iff] at *
    rw [revAt_le (hn.trans (Nat.le_add_right _ _))]
    rw [tsub_le_iff_tsub_le, add_comm, add_tsub_cancel_right, ‚Üê mirror_natTrailingDegree]
    exact natTrailingDegree_le_of_ne_zero hp
  ¬∑ exact fun n‚ÇÅ _ _ _ _ _ h => by rw [‚Üê @revAt_invol _ n‚ÇÅ, h, revAt_invol]
  ¬∑ intro n hn hp
    use revAt (p.natDegree + p.natTrailingDegree) n
    refine ‚ü®?_,? _, revAt_invol‚ü©
    ¬∑ rw [Finset.mem_range_succ_iff] at *
      rw [revAt_le (hn.trans (Nat.le_add_right _ _))]
      rw [tsub_le_iff_tsub_le, add_comm, add_tsub_cancel_right]
      exact natTrailingDegree_le_of_ne_zero hp
    ¬∑ change p.mirror.coeff _ ‚â† 0
      rwa [coeff_mirror, revAt_invol]
  ¬∑ exact fun n _ _ => p.coeff_mirror n","error:  don't know how to synthesize placeholder for argument 'i_surj'
context:
R : Type u_1
inst‚úù : Semiring R
p q : R[X]
‚ä¢ ‚àÄ b ‚àà Finset.range (p.natDegree + 1),
    p.coeff b ‚â† 0 ‚Üí ‚àÉ a, ‚àÉ (h‚ÇÅ : a ‚àà Finset.range (p.natDegree + 1)) (h‚ÇÇ : p.mirror.coeff a ‚â† 0), ?m.13231 a h‚ÇÅ h‚ÇÇ = b
error:  don't know how to synthesize placeholder for argument 'i_inj'
context:
R : Type u_1
inst‚úù : Semiring R
p q : R[X]
‚ä¢ ‚àÄ (a‚ÇÅ : ‚Ñï) (h‚ÇÅ‚ÇÅ : a‚ÇÅ ‚àà Finset.range (p.natDegree + 1)) (h‚ÇÅ‚ÇÇ : p.mirror.coeff a‚ÇÅ ‚â† 0) (a‚ÇÇ : ‚Ñï)
    (h‚ÇÇ‚ÇÅ : a‚ÇÇ ‚àà Finset.range (p.natDegree + 1)) (h‚ÇÇ‚ÇÇ : p.mirror.coeff a‚ÇÇ ‚â† 0),
    ?m.13231 a‚ÇÅ h‚ÇÅ‚ÇÅ h‚ÇÅ‚ÇÇ = ?m.13231 a‚ÇÇ h‚ÇÇ‚ÇÅ h‚ÇÇ‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ
error:  unsolved goals
R : Type u_1
inst‚úù : Semiring R
p q : R[X]
‚ä¢ ‚àë x ‚àà Finset.range (p.natDegree + 1), p.mirror.coeff x = ‚àë x ‚àà Finset.range (p.natDegree + 1), p.coeff x",theorem mirror_eval_one : p.mirror.eval 1 = p.eval 1 ,":= by
  simp_rw [eval_eq_sum_range, one_pow, mul_one, mirror_natDegree]
  refine Finset.sum_bij_ne_zero ?_ ?_ ?_ ?_ ?_
  ¬∑ exact fun n _ _ => revAt (p.natDegree + p.natTrailingDegree) n
  ¬∑ intro n hn hp
    rw [Finset.mem_range_succ_iff] at *
    rw [revAt_le (hn.trans (Nat.le_add_right _ _))]
    rw [tsub_le_iff_tsub_le, add_comm, add_tsub_cancel_right, ‚Üê mirror_natTrailingDegree]
    exact natTrailingDegree_le_of_ne_zero hp
  ¬∑ exact fun n‚ÇÅ _ _ _ _ _ h => by rw [‚Üê @revAt_invol _ n‚ÇÅ, h, revAt_invol]
  ¬∑ intro n hn hp
    use revAt (p.natDegree + p.natTrailingDegree) n
    refine ‚ü®?_, ?_, revAt_invol‚ü©
    ¬∑ rw [Finset.mem_range_succ_iff] at *
      rw [revAt_le (hn.trans (Nat.le_add_right _ _))]
      rw [tsub_le_iff_tsub_le, add_comm, add_tsub_cancel_right]
      exact natTrailingDegree_le_of_ne_zero hp
    ¬∑ change p.mirror.coeff _ ‚â† 0
      rwa [coeff_mirror, revAt_invol]
  ¬∑ exact fun n _ _ => p.coeff_mirror n"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.hausdorffMeasure_pi_real,hausdorffMeasure_pi_real,fb705518d5c3f45a616388ce3b8f50f170e4fd60,":= by
  classical
  refine (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)
    (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) ?_).symm
  simp only [mem_iUnion, mem_singleton_iff]
  intro s hs
  choose a b H using hs
  obtain rfl : s = fun i => Ioo (Œ± := ‚Ñù) (a i) (b i) := funext fun i => (H i).2
  replace H := fun i => (H i).1
  apply le_antisymm _
  ¬∑ have Hle : volume ‚â§ (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) := by
      refine' le_hausdorffMeasure _ _ ‚àû ENNReal.coe_lt_top fun s _ => _
      rw [ENNReal.rpow_nat_cast]
      exact Real.volume_pi_le_diam_pow s
    rw [‚Üê volume_pi_pi fun i => Ioo (a i : ‚Ñù) (b i)]
    exact Measure.le_iff'.1 Hle _
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := fun i => by
    simpa only [sub_nonneg, Rat.cast_le] using (H i).le
  let Œ≥ := fun n : ‚Ñï => ‚àÄ i : Œπ, Fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä
  let t : ‚àÄ n : ‚Ñï, Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f =>
    Set.pi fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)
  have A : Tendsto (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) atTop (ùìù 0) := by
    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]
  have B : ‚àÄ·∂† n in atTop, ‚àÄ i : Œ≥ n, diam (t n i) ‚â§ 1 / n := by
    refine' eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
    intro f
    refine' diam_pi_le_of_le fun b => _
    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel', ENNReal.ofReal_one, ENNReal.ofReal_coe_nat]
  have C : ‚àÄ·∂† n in atTop, (Set.pi fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ i : Œ≥ n, t n i := by
    refine' eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
    have npos : (0 : ‚Ñù) < n := Nat.cast_pos.2 hn
    intro x hx
    simp only [mem_Ioo, mem_univ_pi] at hx
    simp only [mem_iUnion, mem_Ioo, mem_univ_pi]
    let f : Œ≥ n := fun i =>
      ‚ü®‚åä(x i - a i) * n‚åã‚Çä, by
        apply Nat.floor_lt_ceil_of_lt_of_pos
        ¬∑ refine' (mul_lt_mul_right npos).2 _
          simp only [(hx i).right, sub_lt_sub_iff_right]
        ¬∑ refine' mul_pos _ npos
          simpa only [Rat.cast_lt, sub_pos] using H i‚ü©
    refine' ‚ü®f, fun i => ‚ü®_, _‚ü©‚ü©
    ¬∑ calc
        (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + (x i - a i) * n / n := by
          refine' add_le_add le_rfl ((div_le_div_right npos).2 _)
          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
        _ = x i := by field_simp [npos.ne']
    ¬∑ calc
        x i = (a i : ‚Ñù) + (x i - a i) * n / n := by field_simp [npos.ne']
        _ ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n :=
          add_le_add le_rfl ((div_le_div_right npos).2 (Nat.lt_floor_add_one _).le)
  calc
    ŒºH[Fintype.card Œπ] (Set.pi fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚â§
        liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, diam (t n i) ^ ((Fintype.card Œπ) : ‚Ñù)) atTop :=
      hausdorffMeasure_le_liminf_sum _ (Set.pi fun i => Ioo (a i : ‚Ñù) (b i))
        (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) A t B C
    _ ‚â§ liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, (1 / (n : ‚Ñù‚â•0‚àû)) ^ Fintype.card Œπ) atTop := by
      refine' liminf_le_liminf _ _
      ¬∑ filter_upwards [B] with _ hn
        apply Finset.sum_le_sum fun i _ => _
        simp only [ENNReal.rpow_nat_cast]
        intros i _
        exact pow_le_pow_left' (hn i) _
      ¬∑ isBoundedDefault
    _ = liminf (fun n : ‚Ñï => ‚àè i : Œπ, (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) atTop := by
      simp only [Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
    _ = ‚àè i : Œπ, volume (Ioo (a i : ‚Ñù) (b i)) := by
      simp only [Real.volume_Ioo]
      apply Tendsto.liminf_eq
      refine' ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => _) fun i _ => _
      ¬∑ apply
          Tendsto.congr' _
            ((ENNReal.continuous_ofReal.tendsto _).comp
              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_nat_cast_atTop_atTop))
        apply eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
        intros n hn
        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,
          ENNReal.ofReal_coe_nat]
      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne.def, not_false_iff]","warning:  `ENNReal.rpow_nat_cast` has been deprecated, use `ENNReal.rpow_natCast` instead
error:  type mismatch
  Icc (a i + ‚Üë‚Üë(f i) / ‚Üën) (a i + (‚Üë‚Üë(f i) + 1) / ‚Üën)
has type
  Set ‚Ñö : Type
but is expected to have type
  Prop : Type
error:  type mismatch
  diam_pi_le_of_le fun b ‚Ü¶ ?m.252730 b
has type
  diam (univ.pi ?m.235296) ‚â§ ?m.235297 : Prop
but is expected to have type
  diam (t n f) ‚â§ 1 / ‚Üën : Prop
error:  type mismatch
  Ioo ‚Üë(a i) ‚Üë(b i)
has type
  Set ‚Ñù : Type
but is expected to have type
  Prop : Type
error:  failed to synthesize
  HasSubset (((i : Œπ) ‚Üí Set (?m.305640 i)) ‚Üí Set ((i : Œπ) ‚Üí ?m.305640 i))
use `set_option diagnostics true` to get diagnostic information
error:  stuck at solving universe constraint
  max ?u.235290 ?u.235291 =?= u_4
while trying to unify
  @diam.{max ?u.235290 ?u.235291} : {Œ± : Type (max ?u.235290 ?u.235291)} ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí Set Œ± ‚Üí ‚Ñù‚â•0‚àû
with
  @diam : {Œ± : Type u_4} ‚Üí [inst : PseudoEMetricSpace Œ±] ‚Üí Set Œ± ‚Üí ‚Ñù‚â•0‚àû","theorem hausdorffMeasure_pi_real {Œπ : Type*} [Fintype Œπ] :
    (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) = volume ",":= by
  classical
  refine (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)
    (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) ?_).symm
  simp only [mem_iUnion, mem_singleton_iff]
  intro s hs
  choose a b H using hs
  obtain rfl : s = fun i => Ioo (Œ± := ‚Ñù) (a i) (b i) := funext fun i => (H i).2
  replace H := fun i => (H i).1
  apply le_antisymm _
  ¬∑ have Hle : volume ‚â§ (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) := by
      refine le_hausdorffMeasure _ _ ‚àû ENNReal.coe_lt_top fun s _ => ?_
      rw [ENNReal.rpow_natCast]
      exact Real.volume_pi_le_diam_pow s
    rw [‚Üê volume_pi_pi fun i => Ioo (a i : ‚Ñù) (b i)]
    exact Measure.le_iff'.1 Hle _
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := fun i => by
    simpa only [sub_nonneg, Rat.cast_le] using (H i).le
  let Œ≥ := fun n : ‚Ñï => ‚àÄ i : Œπ, Fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä
  let t : ‚àÄ n : ‚Ñï, Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f =>
    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)
  have A : Tendsto (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) atTop (ùìù 0) := by
    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]
  have B : ‚àÄ·∂† n in atTop, ‚àÄ i : Œ≥ n, diam (t n i) ‚â§ 1 / n := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => ?_‚ü©
    intro f
    refine diam_pi_le_of_le fun b => ?_
    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel_left, ENNReal.ofReal_one, ENNReal.ofReal_natCast]
  have C : ‚àÄ·∂† n in atTop, (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ i : Œ≥ n, t n i := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => ?_‚ü©
    have npos : (0 : ‚Ñù) < n := Nat.cast_pos.2 hn
    intro x hx
    simp only [mem_Ioo, mem_univ_pi] at hx
    simp only [t, mem_iUnion, mem_Ioo, mem_univ_pi]
    let f : Œ≥ n := fun i =>
      ‚ü®‚åä(x i - a i) * n‚åã‚Çä, by
        apply Nat.floor_lt_ceil_of_lt_of_pos
        ¬∑ refine (mul_lt_mul_right npos).2 ?_
          simp only [(hx i).right, sub_lt_sub_iff_right]
        ¬∑ refine mul_pos ?_ npos
          simpa only [Rat.cast_lt, sub_pos] using H i‚ü©
    refine ‚ü®f, fun i => ‚ü®?_, ?_‚ü©‚ü©
    ¬∑ calc
        (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + (x i - a i) * n / n := by
          gcongr
          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
        _ = x i := by field_simp [npos.ne']
    ¬∑ calc
        x i = (a i : ‚Ñù) + (x i - a i) * n / n := by field_simp [npos.ne']
        _ ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n := by
          gcongr
          exact (Nat.lt_floor_add_one _).le
  calc
    ŒºH[Fintype.card Œπ] (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚â§
        liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, diam (t n i) ^ ((Fintype.card Œπ) : ‚Ñù)) atTop :=
      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : ‚Ñù) (b i))
        (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) A t B C
    _ ‚â§ liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, (1 / (n : ‚Ñù‚â•0‚àû)) ^ Fintype.card Œπ) atTop := by
      refine liminf_le_liminf ?_ ?_
      ¬∑ filter_upwards [B] with _ hn
        apply Finset.sum_le_sum fun i _ => _
        simp only [ENNReal.rpow_natCast]
        intros i _
        exact pow_le_pow_left' (hn i) _
      ¬∑ isBoundedDefault
    _ = liminf (fun n : ‚Ñï => ‚àè i : Œπ, (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) atTop := by
      simp only [Œ≥, Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
    _ = ‚àè i : Œπ, volume (Ioo (a i : ‚Ñù) (b i)) := by
      simp only [Real.volume_Ioo]
      apply Tendsto.liminf_eq
      refine ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => ?_) fun i _ => ?_
      ¬∑ apply
          Tendsto.congr' _
            ((ENNReal.continuous_ofReal.tendsto _).comp
              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_natCast_atTop_atTop))
        apply eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
        intros n hn
        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,
          ENNReal.ofReal_natCast]
      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne, not_false_iff]"
Mathlib/Analysis/Calculus/Taylor.lean,taylor_mean_remainder_lagrange,taylor_mean_remainder_lagrange,7d2c51fa2103976446680baf42aa428cea0e7626,":= by
  have gcont : ContinuousOn (fun t : ‚Ñù => (x - t) ^ (n + 1)) (Icc x‚ÇÄ x) := by
    refine' Continuous.continuousOn _
    exact (continuous_const.sub continuous_id').pow _ 
  have xy_ne : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí (x - y) ^ n ‚â† 0 := by
    intro y hy
    refine' pow_ne_zero _ _
    rw [mem_Ioo] at hy
    rw [sub_ne_zero]
    exact hy.2.ne'
  have hg' : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí -(‚Üën + 1) * (x - y) ^ n ‚â† 0 := fun y hy =>
    mul_ne_zero (neg_ne_zero.mpr (Nat.cast_add_one_ne_zero n)) (xy_ne y hy)
  rcases taylor_mean_remainder hx hf hf' gcont (fun y _ => monomial_has_deriv_aux y x _) hg' with
    ‚ü®y, hy, h‚ü©
  use y, hy
  simp only [sub_self, zero_pow, Ne.def, Nat.succ_ne_zero, not_false_iff, zero_sub, mul_neg] at h
  rw [h, neg_div, ‚Üê div_neg, neg_mul, neg_neg]
  sorry","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.136822 ‚Üí ?m.136822 ‚Üí Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  -?b / ?a
case right
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚Ñù E
f : ‚Ñù ‚Üí ‚Ñù
x x‚ÇÄ : ‚Ñù
n : ‚Ñï
hx : x‚ÇÄ < x
hf : ContDiffOn ‚Ñù (‚Üën) f (Icc x‚ÇÄ x)
hf' : DifferentiableOn ‚Ñù (iteratedDerivWithin n f (Icc x‚ÇÄ x)) (Ioo x‚ÇÄ x)
gcont : ContinuousOn (fun t ‚Ü¶ (x - t) ^ (n + 1)) (Icc x‚ÇÄ x)
xy_ne : ‚àÄ y ‚àà Ioo x‚ÇÄ x, (x - y) ^ n ‚â† 0
hg' : ‚àÄ y ‚àà Ioo x‚ÇÄ x, -(‚Üën + 1) * (x - y) ^ n ‚â† 0
y : ‚Ñù
hy : y ‚àà Ioo x‚ÇÄ x
h :
  f x - taylorWithinEval f n (Icc x‚ÇÄ x) x‚ÇÄ x =
    ((x - y) ^ n / ‚Üën ! * (0 ^ (n + 1) - (x - x‚ÇÄ) ^ (n + 1)) / (-(‚Üën + 1) * (x - y) ^ n)) ‚Ä¢
      iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) y
‚ä¢ ((x - y) ^ n / ‚Üën ! * (0 ^ (n + 1) - (x - x‚ÇÄ) ^ (n + 1)) / (-(‚Üën + 1) * (x - y) ^ n)) ‚Ä¢
      iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) y =
    iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) y * (x - x‚ÇÄ) ^ (n + 1) / ‚Üë(n + 1)!","theorem taylor_mean_remainder_lagrange {f : ‚Ñù ‚Üí ‚Ñù} {x x‚ÇÄ : ‚Ñù} {n : ‚Ñï} (hx : x‚ÇÄ < x)
    (hf : ContDiffOn ‚Ñù n f (Icc x‚ÇÄ x))
    (hf' : DifferentiableOn ‚Ñù (iteratedDerivWithin n f (Icc x‚ÇÄ x)) (Ioo x‚ÇÄ x)) :
    ‚àÉ x' ‚àà Ioo x‚ÇÄ x, f x - taylorWithinEval f n (Icc x‚ÇÄ x) x‚ÇÄ x =
      iteratedDerivWithin (n + 1) f (Icc x‚ÇÄ x) x' * (x - x‚ÇÄ) ^ (n + 1) / (n + 1)! ",":= by
  have gcont : ContinuousOn (fun t : ‚Ñù => (x - t) ^ (n + 1)) (Icc x‚ÇÄ x) := by fun_prop
  have xy_ne : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí (x - y) ^ n ‚â† 0 := by
    intro y hy
    refine pow_ne_zero _ ?_
    rw [mem_Ioo] at hy
    rw [sub_ne_zero]
    exact hy.2.ne'
  have hg' : ‚àÄ y : ‚Ñù, y ‚àà Ioo x‚ÇÄ x ‚Üí -(‚Üën + 1) * (x - y) ^ n ‚â† 0 := fun y hy =>
    mul_ne_zero (neg_ne_zero.mpr (Nat.cast_add_one_ne_zero n)) (xy_ne y hy)
  rcases taylor_mean_remainder hx hf hf' gcont (fun y _ => monomial_has_deriv_aux y x _) hg' with
    ‚ü®y, hy, h‚ü©
  use y, hy
  simp only [sub_self, zero_pow, Ne, Nat.succ_ne_zero, not_false_iff, zero_sub, mul_neg] at h
  rw [h, neg_div, ‚Üê div_neg, neg_mul, neg_neg]
  field_simp [xy_ne y hy, Nat.factorial]; ring"
Mathlib/Analysis/NormedSpace/QuaternionExponential.lean,Quaternion.expSeries_odd_of_imaginary,expSeries_odd_of_imaginary,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  rw [expSeries_apply_eq]
  obtain rfl | hq0 := eq_or_ne q 0
  ¬∑ simp
  have hq2 : q ^ 2 = -normSq q := sq_eq_neg_normSq.mpr hq
  have hqn := norm_ne_zero_iff.mpr hq0
  let k : ‚Ñù := ‚Üë(2 * n + 1)!
  calc
    k‚Åª¬π ‚Ä¢ q ^ (2 * n + 1) = k‚Åª¬π ‚Ä¢ ((-normSq q) ^ n * q) := by rw [pow_succ', pow_mul, hq2]
    _ = k‚Åª¬π ‚Ä¢ ((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n)) ‚Ä¢ q := ?_
    _ = ((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n + 1) / k / ‚Äñq‚Äñ) ‚Ä¢ q := ?_
  ¬∑ congr 1
    rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq, ‚Üê coe_mul_eq_smul]
    norm_cast
  ¬∑ rw [smul_smul]
    congr 1
    simp_rw [pow_succ', mul_div_assoc, div_div_cancel_left' hqn]
    ring","error:  unsolved goals
q : ‚Ñç
hq : q.re = 0
n : ‚Ñï
hq0 : q ‚â† 0
hq2 : q ^ 2 = -‚Üë(normSq q)
hqn : ‚Äñq‚Äñ ‚â† 0
k : ‚Ñù := ‚Üë(2 * n + 1)!
‚ä¢ k‚Åª¬π ‚Ä¢ (q * (-‚Üë(normSq q)) ^ n) = k‚Åª¬π ‚Ä¢ ((-‚Üë(normSq q)) ^ n * q)
error:  simp made no progress","theorem expSeries_odd_of_imaginary {q : Quaternion ‚Ñù} (hq : q.re = 0) (n : ‚Ñï) :
    expSeries ‚Ñù (Quaternion ‚Ñù) (2 * n + 1) (fun _ => q) =
      (((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n + 1) / (2 * n + 1)!) / ‚Äñq‚Äñ) ‚Ä¢ q ",":= by
  rw [expSeries_apply_eq]
  obtain rfl | hq0 := eq_or_ne q 0
  ¬∑ simp
  have hq2 : q ^ 2 = -normSq q := sq_eq_neg_normSq.mpr hq
  have hqn := norm_ne_zero_iff.mpr hq0
  let k : ‚Ñù := ‚Üë(2 * n + 1)!
  calc
    k‚Åª¬π ‚Ä¢ q ^ (2 * n + 1) = k‚Åª¬π ‚Ä¢ ((-normSq q) ^ n * q) := by rw [pow_succ, pow_mul, hq2]
    _ = k‚Åª¬π ‚Ä¢ ((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n)) ‚Ä¢ q := ?_
    _ = ((-1 : ‚Ñù) ^ n * ‚Äñq‚Äñ ^ (2 * n + 1) / k / ‚Äñq‚Äñ) ‚Ä¢ q := ?_
  ¬∑ congr 1
    rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq, ‚Üê coe_mul_eq_smul]
    norm_cast
  ¬∑ rw [smul_smul]
    congr 1
    simp_rw [pow_succ, mul_div_assoc, div_div_cancel_left' hqn]
    ring"
Mathlib/Topology/EMetricSpace/Lipschitz.lean,LipschitzWith.comp_lipschitzOnWith,comp_lipschitzOnWith,9a069d68af1d7bc2ad676d68e44dc963e5910e7b,":=
  lipschitzWith_restrict.1 <| hf.comp hg.to_restrict",error:  unknown identifier 'lipschitzWith_restrict',"theorem comp_lipschitzOnWith {Kf Kg : ‚Ñù‚â•0} {f : Œ≤ ‚Üí Œ≥} {g : Œ± ‚Üí Œ≤} {s : Set Œ±}
    (hf : LipschitzWith Kf f) (hg : LipschitzOnWith Kg g s) : LipschitzOnWith (Kf * Kg) (f ‚àò g) s ",":=
  lipschitzOnWith_iff_restrict.mpr <| hf.comp hg.to_restrict"
Mathlib/MeasureTheory/Integral/PeakFunction.lean,tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux,tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  refine' Metric.tendsto_nhds.2 fun Œµ Œµpos => _
  obtain ‚ü®Œ¥, hŒ¥, Œ¥pos, Œ¥one‚ü© : ‚àÉ Œ¥, (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ < Œµ ‚àß 0 < Œ¥ ‚àß Œ¥ < 1:= by
    have A :
      Tendsto (fun Œ¥ => (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥) (ùìù[>] 0)
        (ùìù ((0 * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * 0)) := by
      apply Tendsto.mono_left _ nhdsWithin_le_nhds
      exact (tendsto_id.mul tendsto_const_nhds).add (tendsto_id.const_mul _)
    rw [zero_mul, zero_add, mul_zero] at A
    have : Ioo (0 : ‚Ñù) 1 ‚àà ùìù[>] 0 := Ioo_mem_nhdsWithin_Ioi ‚ü®le_rfl, zero_lt_one‚ü©
    rcases (((tendsto_order.1 A).2 Œµ Œµpos).and this).exists with ‚ü®Œ¥, hŒ¥, h'Œ¥‚ü©
    exact ‚ü®Œ¥, hŒ¥, h'Œ¥.1, h'Œ¥.2‚ü©
  suffices ‚àÄ·∂† i in l, ‚Äñ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ by
    filter_upwards [this] with i hi
    simp only [dist_zero_right]
    exact hi.trans_lt hŒ¥
  obtain ‚ü®u, u_open, x‚ÇÄu, ut, hu‚ü© :
      ‚àÉ u, IsOpen u ‚àß x‚ÇÄ ‚àà u ‚àß s ‚à© u ‚äÜ t ‚àß ‚àÄ x ‚àà u ‚à© s, g x ‚àà ball 0 Œ¥ := by
    rcases mem_nhdsWithin.1 (Filter.inter_mem h'ts (hcg (ball_mem_nhds _ Œ¥pos)))
      with ‚ü®u, u_open, x‚ÇÄu, hu‚ü©
    refine ‚ü®u, u_open, x‚ÇÄu, ?_, hu.trans (inter_subset_right _ _)‚ü©
    rw [inter_comm]
    exact hu.trans (inter_subset_left _ _)
  filter_upwards [tendstoUniformlyOn_iff.1 (hlœÜ u u_open x‚ÇÄu) Œ¥ Œ¥pos,
    (tendsto_order.1 (tendsto_iff_norm_sub_tendsto_zero.1 hiœÜ)).2 Œ¥ Œ¥pos, hnœÜ,
    integrableOn_peak_smul_of_integrableOn_of_tendsto hs h'ts hlœÜ hiœÜ h'iœÜ hmg hcg]
    with i hi h'i hœÜpos h''i
  have I : IntegrableOn (œÜ i) t Œº := by
    apply Integrable.of_integral_ne_zero (fun h ‚Ü¶ ?_)
    simp [h] at h'i
    linarith
  have B : ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ 2 * Œ¥ :=
    calc
      ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ ‚à´ x in s ‚à© u, ‚ÄñœÜ i x ‚Ä¢ g x‚Äñ ‚àÇŒº :=
        norm_integral_le_integral_norm _
      _ ‚â§ ‚à´ x in s ‚à© u, ‚ÄñœÜ i x‚Äñ * Œ¥ ‚àÇŒº := by
        refine' setIntegral_mono_on _ _ (hs.inter u_open.measurableSet) fun x hx => _
        ¬∑ exact IntegrableOn.mono_set h''i.norm (inter_subset_left _ _)
        ¬∑ exact IntegrableOn.mono_set (I.norm.mul_const _) ut
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
        rw [inter_comm] at hu
        exact (mem_ball_zero_iff.1 (hu x hx)).le
      _ ‚â§ ‚à´ x in t, ‚ÄñœÜ i x‚Äñ * Œ¥ ‚àÇŒº := by
        apply setIntegral_mono_set
        ¬∑ exact I.norm.mul_const _
        ¬∑ exact eventually_of_forall fun x => mul_nonneg (norm_nonneg _) Œ¥pos.le
        ¬∑ exact eventually_of_forall ut
      _ = ‚à´ x in t, œÜ i x * Œ¥ ‚àÇŒº := by
        apply setIntegral_congr ht fun x hx => ?_
        rw [Real.norm_of_nonneg (hœÜpos _ (hts hx))]
      _ = (‚à´ x in t, œÜ i x ‚àÇŒº) * Œ¥ := by rw [integral_mul_right]
      _ ‚â§ 2 * Œ¥ := by gcongr; linarith [(le_abs_self _).trans h'i.le]
  have C : ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº :=
    calc
      ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ ‚à´ x in s \ u, ‚ÄñœÜ i x ‚Ä¢ g x‚Äñ ‚àÇŒº :=
        norm_integral_le_integral_norm _
      _ ‚â§ ‚à´ x in s \ u, Œ¥ * ‚Äñg x‚Äñ ‚àÇŒº := by
        refine' setIntegral_mono_on _ _ (hs.diff u_open.measurableSet) fun x hx => _
        ¬∑ exact IntegrableOn.mono_set h''i.norm (diff_subset _ _)
        ¬∑ exact IntegrableOn.mono_set (hmg.norm.const_mul _) (diff_subset _ _)
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le
      _ ‚â§ Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº := by
        rw [integral_mul_left]
        apply mul_le_mul_of_nonneg_left (setIntegral_mono_set hmg.norm _ _) Œ¥pos.le
        ¬∑ filter_upwards with x using norm_nonneg _
        ¬∑ filter_upwards using diff_subset s u
  calc
    ‚Äñ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ =
      ‚Äñ(‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº) + ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ := by
      conv_lhs => rw [‚Üê diff_union_inter s u]
      rw [integral_union disjoint_sdiff_inter (hs.inter u_open.measurableSet)
          (h''i.mono_set (diff_subset _ _)) (h''i.mono_set (inter_subset_left _ _))]
    _ ‚â§ ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ + ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ := add_le_add C B","error:  function expected at
  inter_subset_right ?m.27078
term has type
  ?m.27077 ‚àà ?m.27076
error:  function expected at
  inter_subset_left ?m.27224
term has type
  ?m.27223 ‚àà ?m.27221
error:  function expected at
  inter_subset_left ?m.35688
term has type
  ?m.35687 ‚àà ?m.35685
error:  function expected at
  diff_subset ?m.54267
term has type
  ?m.54266 ‚àà ?m.54264
error:  function expected at
  diff_subset ?m.54437
term has type
  ?m.54436 ‚àà ?m.54434
error:  application type mismatch
  diff_subset s
argument
  s
has type
  Set Œ± : Type u_1
but is expected to have type
  ?m.55664 ‚àà ?m.55662 \ ?m.55663 : Prop
error:  function expected at
  diff_subset ?m.62903
term has type
  ?m.62902 ‚àà ?m.62900
error:  function expected at
  inter_subset_left ?m.62966
term has type
  ?m.62965 ‚àà ?m.62963","theorem tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux
    (hs : MeasurableSet s) (ht : MeasurableSet t) (hts : t ‚äÜ s) (h'ts : t ‚àà ùìù[s] x‚ÇÄ)
    (hnœÜ : ‚àÄ·∂† i in l, ‚àÄ x ‚àà s, 0 ‚â§ œÜ i x)
    (hlœÜ : ‚àÄ u : Set Œ±, IsOpen u ‚Üí x‚ÇÄ ‚àà u ‚Üí TendstoUniformlyOn œÜ 0 l (s \ u))
    (hiœÜ : Tendsto (fun i ‚Ü¶ ‚à´ x in t, œÜ i x ‚àÇŒº) l (ùìù 1))
    (h'iœÜ : ‚àÄ·∂† i in l, AEStronglyMeasurable (œÜ i) (Œº.restrict s))
    (hmg : IntegrableOn g s Œº) (hcg : Tendsto g (ùìù[s] x‚ÇÄ) (ùìù 0)) :
    Tendsto (fun i : Œπ => ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº) l (ùìù 0) ",":= by
  refine Metric.tendsto_nhds.2 fun Œµ Œµpos => ?_
  obtain ‚ü®Œ¥, hŒ¥, Œ¥pos, Œ¥one‚ü© : ‚àÉ Œ¥, (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ < Œµ ‚àß 0 < Œ¥ ‚àß Œ¥ < 1:= by
    have A :
      Tendsto (fun Œ¥ => (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥) (ùìù[>] 0)
        (ùìù ((0 * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * 0)) := by
      apply Tendsto.mono_left _ nhdsWithin_le_nhds
      exact (tendsto_id.mul tendsto_const_nhds).add (tendsto_id.const_mul _)
    rw [zero_mul, zero_add, mul_zero] at A
    have : Ioo (0 : ‚Ñù) 1 ‚àà ùìù[>] 0 := Ioo_mem_nhdsWithin_Ioi ‚ü®le_rfl, zero_lt_one‚ü©
    rcases (((tendsto_order.1 A).2 Œµ Œµpos).and this).exists with ‚ü®Œ¥, hŒ¥, h'Œ¥‚ü©
    exact ‚ü®Œ¥, hŒ¥, h'Œ¥.1, h'Œ¥.2‚ü©
  suffices ‚àÄ·∂† i in l, ‚Äñ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ by
    filter_upwards [this] with i hi
    simp only [dist_zero_right]
    exact hi.trans_lt hŒ¥
  obtain ‚ü®u, u_open, x‚ÇÄu, ut, hu‚ü© :
      ‚àÉ u, IsOpen u ‚àß x‚ÇÄ ‚àà u ‚àß s ‚à© u ‚äÜ t ‚àß ‚àÄ x ‚àà u ‚à© s, g x ‚àà ball 0 Œ¥ := by
    rcases mem_nhdsWithin.1 (Filter.inter_mem h'ts (hcg (ball_mem_nhds _ Œ¥pos)))
      with ‚ü®u, u_open, x‚ÇÄu, hu‚ü©
    refine ‚ü®u, u_open, x‚ÇÄu, ?_, hu.trans inter_subset_right‚ü©
    rw [inter_comm]
    exact hu.trans inter_subset_left
  filter_upwards [tendstoUniformlyOn_iff.1 (hlœÜ u u_open x‚ÇÄu) Œ¥ Œ¥pos,
    (tendsto_order.1 (tendsto_iff_norm_sub_tendsto_zero.1 hiœÜ)).2 Œ¥ Œ¥pos, hnœÜ,
    integrableOn_peak_smul_of_integrableOn_of_tendsto hs h'ts hlœÜ hiœÜ h'iœÜ hmg hcg]
    with i hi h'i hœÜpos h''i
  have I : IntegrableOn (œÜ i) t Œº := by
    apply Integrable.of_integral_ne_zero (fun h ‚Ü¶ ?_)
    simp [h] at h'i
    linarith
  have B : ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ 2 * Œ¥ :=
    calc
      ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ ‚à´ x in s ‚à© u, ‚ÄñœÜ i x ‚Ä¢ g x‚Äñ ‚àÇŒº :=
        norm_integral_le_integral_norm _
      _ ‚â§ ‚à´ x in s ‚à© u, ‚ÄñœÜ i x‚Äñ * Œ¥ ‚àÇŒº := by
        refine setIntegral_mono_on ?_ ?_ (hs.inter u_open.measurableSet) fun x hx => ?_
        ¬∑ exact IntegrableOn.mono_set h''i.norm inter_subset_left
        ¬∑ exact IntegrableOn.mono_set (I.norm.mul_const _) ut
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
        rw [inter_comm] at hu
        exact (mem_ball_zero_iff.1 (hu x hx)).le
      _ ‚â§ ‚à´ x in t, ‚ÄñœÜ i x‚Äñ * Œ¥ ‚àÇŒº := by
        apply setIntegral_mono_set
        ¬∑ exact I.norm.mul_const _
        ¬∑ exact eventually_of_forall fun x => mul_nonneg (norm_nonneg _) Œ¥pos.le
        ¬∑ exact eventually_of_forall ut
      _ = ‚à´ x in t, œÜ i x * Œ¥ ‚àÇŒº := by
        apply setIntegral_congr ht fun x hx => ?_
        rw [Real.norm_of_nonneg (hœÜpos _ (hts hx))]
      _ = (‚à´ x in t, œÜ i x ‚àÇŒº) * Œ¥ := by rw [integral_mul_right]
      _ ‚â§ 2 * Œ¥ := by gcongr; linarith [(le_abs_self _).trans h'i.le]
  have C : ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº :=
    calc
      ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ ‚à´ x in s \ u, ‚ÄñœÜ i x ‚Ä¢ g x‚Äñ ‚àÇŒº :=
        norm_integral_le_integral_norm _
      _ ‚â§ ‚à´ x in s \ u, Œ¥ * ‚Äñg x‚Äñ ‚àÇŒº := by
        refine setIntegral_mono_on ?_ ?_ (hs.diff u_open.measurableSet) fun x hx => ?_
        ¬∑ exact IntegrableOn.mono_set h''i.norm diff_subset
        ¬∑ exact IntegrableOn.mono_set (hmg.norm.const_mul _) diff_subset
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le
      _ ‚â§ Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº := by
        rw [integral_mul_left]
        apply mul_le_mul_of_nonneg_left (setIntegral_mono_set hmg.norm _ _) Œ¥pos.le
        ¬∑ filter_upwards with x using norm_nonneg _
        ¬∑ filter_upwards using diff_subset (s := s) (t := u)
  calc
    ‚Äñ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ =
      ‚Äñ(‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº) + ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ := by
      conv_lhs => rw [‚Üê diff_union_inter s u]
      rw [integral_union disjoint_sdiff_inter (hs.inter u_open.measurableSet)
          (h''i.mono_set diff_subset) (h''i.mono_set inter_subset_left)]
    _ ‚â§ ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ + ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ := add_le_add C B"
Mathlib/SetTheory/Ordinal/Arithmetic.lean,Ordinal.IsNormal.eq_iff_zero_and_succ,IsNormal.eq_iff_zero_and_succ,25e538f3a737a71314ac143929711e67d0b14d73,":=
  ‚ü®fun h => by simp [h], fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© =>
    funext fun a => by
      induction' a with _ _ _ ho H
      any_goals solve_by_elim
      rw [‚Üê IsNormal.bsup_eq.{u, u} hf ho, ‚Üê IsNormal.bsup_eq.{u, u} hg ho]
      congr
      ext b hb
      exact H b hb‚ü©","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
r : Œ± ‚Üí Œ± ‚Üí Prop
s : Œ≤ ‚Üí Œ≤ ‚Üí Prop
t : Œ≥ ‚Üí Œ≥ ‚Üí Prop
f g : Ordinal.{u} ‚Üí Ordinal.{u}
hf : IsNormal f
hg : IsNormal g
x‚úù : f 0 = g 0 ‚àß ‚àÄ (a : Ordinal.{u}), f a = g a ‚Üí f (succ a) = g (succ a)
h‚ÇÅ : f 0 = g 0
h‚ÇÇ : ‚àÄ (a : Ordinal.{u}), f a = g a ‚Üí f (succ a) = g (succ a)
a : Ordinal.{u}
‚ä¢ f a = g a","theorem IsNormal.eq_iff_zero_and_succ {f g : Ordinal.{u} ‚Üí Ordinal.{u}} (hf : IsNormal f)
    (hg : IsNormal g) : f = g ‚Üî f 0 = g 0 ‚àß ‚àÄ a, f a = g a ‚Üí f (succ a) = g (succ a) ",":=
  ‚ü®fun h => by simp [h], fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© =>
    funext fun a => by
      induction' a using limitRecOn with _ _ _ ho H
      any_goals solve_by_elim
      rw [‚Üê IsNormal.bsup_eq.{u, u} hf ho, ‚Üê IsNormal.bsup_eq.{u, u} hg ho]
      congr
      ext b hb
      exact H b hb‚ü©"
Mathlib/Analysis/Analytic/IsolatedZeros.lean,AnalyticAt.unique_eventuallyEq_pow_smul_nonzero,unique_eventuallyEq_pow_smul_nonzero,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  simp_rw [‚Üê zpow_ofNat] at hm hn
  exact Int.ofNat_inj.mp <| unique_eventuallyEq_zpow_smul_nonzero
    (let ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := hm; ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ.filter_mono nhdsWithin_le_nhds‚ü©)
    (let ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := hn; ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ.filter_mono nhdsWithin_le_nhds‚ü©)",error:  simp made no progress,"lemma unique_eventuallyEq_pow_smul_nonzero {m n : ‚Ñï}
    (hm : ‚àÉ g, AnalyticAt ùïú g z‚ÇÄ ‚àß g z‚ÇÄ ‚â† 0 ‚àß ‚àÄ·∂† z in ùìù z‚ÇÄ, f z = (z - z‚ÇÄ) ^ m ‚Ä¢ g z)
    (hn : ‚àÉ g, AnalyticAt ùïú g z‚ÇÄ ‚àß g z‚ÇÄ ‚â† 0 ‚àß ‚àÄ·∂† z in ùìù z‚ÇÄ, f z = (z - z‚ÇÄ) ^ n ‚Ä¢ g z) :
    m = n ",":= by
  simp_rw [‚Üê zpow_natCast] at hm hn
  exact Int.ofNat_inj.mp <| unique_eventuallyEq_zpow_smul_nonzero
    (let ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := hm; ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ.filter_mono nhdsWithin_le_nhds‚ü©)
    (let ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := hn; ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ.filter_mono nhdsWithin_le_nhds‚ü©)"
Mathlib/RingTheory/Adjoin/PowerBasis.lean,PowerBasis.repr_mul_isIntegral,repr_mul_isIntegral,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  intro i
  rw [‚Üê B.basis.sum_repr x, ‚Üê B.basis.sum_repr y, Finset.sum_mul_sum, LinearEquiv.map_sum,
    Finset.sum_apply']
  refine' IsIntegral.sum _ fun I _ => _
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smul‚Çõ‚Çó,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine' isIntegral_mul (hy _) (isIntegral_mul (hx _) _)
  simp only [coe_basis, ‚Üê pow_add]
  refine' repr_gen_pow_isIntegral hB hmin _ _","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearEquiv
has type
  (œÉ : ?m.58808 ‚Üí+* ?m.58809) ‚Üí
    {œÉ' : ?m.58809 ‚Üí+* ?m.58808} ‚Üí
      [inst : RingHomInvPair œÉ œÉ'] ‚Üí
        [inst : RingHomInvPair œÉ' œÉ] ‚Üí
          (M : Type ?u.58805) ‚Üí
            (M‚ÇÇ : Type ?u.58804) ‚Üí
              [inst : AddCommMonoid M] ‚Üí
                [inst_1 : AddCommMonoid M‚ÇÇ] ‚Üí
                  [inst : Module ?m.58808 M] ‚Üí [inst : Module ?m.58809 M‚ÇÇ] ‚Üí Type (max ?u.58805 ?u.58804)
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.58915
K : Type u_1
S : Type u_2
inst‚úù¬π¬π : Field K
inst‚úù¬π‚Å∞ : CommRing S
inst‚úù‚Åπ : Algebra K S
R : Type u_3
inst‚úù‚Å∏ : CommRing R
inst‚úù‚Å∑ : Algebra R S
inst‚úù‚Å∂ : Algebra R K
inst‚úù‚Åµ : IsScalarTower R K S
A : Type u_4
inst‚úù‚Å¥ : CommRing A
inst‚úù¬≥ : Algebra R A
inst‚úù¬≤ : Algebra S A
inst‚úù¬π : IsScalarTower R S A
B : PowerBasis S A
hB : IsIntegral R B.gen
inst‚úù : IsDomain S
x y : A
hx : ‚àÄ (i : Fin B.dim), IsIntegral R ((B.basis.repr x) i)
hy : ‚àÄ (i : Fin B.dim), IsIntegral R ((B.basis.repr y) i)
hmin : minpoly S B.gen = Polynomial.map (algebraMap R S) (minpoly R B.gen)
i : Fin B.dim
‚ä¢ IsIntegral R
    ((B.basis.repr (‚àë i : Fin B.dim, ‚àë j : Fin B.dim, (B.basis.repr x) i ‚Ä¢ B.basis i * (B.basis.repr y) j ‚Ä¢ B.basis j))
      i)
error:  application type mismatch
  repr_mul_isIntegral hB
argument
  hB
has type
  IsIntegral R B.gen : Prop
but is expected to have type
  ‚àÄ (i : Fin ?m.73478.dim), IsIntegral ?m.73471 ((?m.73478.basis.repr ?m.73480) i) : Prop
error:  application type mismatch
  repr_pow_isIntegral hB
argument
  hB
has type
  IsIntegral R B.gen : Prop
but is expected to have type
  ‚àÄ (i : Fin ?m.79750.dim), IsIntegral ?m.79743 ((?m.79750.basis.repr ?m.79752) i) : Prop
error:  no goals to be solved","theorem repr_mul_isIntegral [IsDomain S] {x y : A} (hx : ‚àÄ i, IsIntegral R (B.basis.repr x i))
    (hy : ‚àÄ i, IsIntegral R (B.basis.repr y i))
    (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) :
    ‚àÄ i, IsIntegral R (B.basis.repr (x * y) i) ",":= by
  intro i
  rw [‚Üê B.basis.sum_repr x, ‚Üê B.basis.sum_repr y, Finset.sum_mul_sum, ‚Üê Finset.sum_product',
    map_sum, Finset.sum_apply']
  refine IsIntegral.sum _ fun I _ => ?_
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smul‚Çõ‚Çó,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine (hy _).mul ((hx _).mul ?_)
  simp only [coe_basis, ‚Üê pow_add]
  exact repr_gen_pow_isIntegral hB hmin _ _"
Mathlib/LinearAlgebra/Matrix/Spectrum.lean,Matrix.IsHermitian.det_eq_prod_eigenvalues,det_eq_prod_eigenvalues,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  apply mul_left_cancel‚ÇÄ (det_ne_zero_of_left_inverse (eigenvectorMatrix_mul_inv hA))
  rw [‚Üê det_mul, spectral_theorem, det_mul, mul_comm, det_diagonal]
  simp_rw [Function.comp_apply]",error:  unknown identifier 'eigenvectorMatrix_mul_inv',"theorem det_eq_prod_eigenvalues : det A = ‚àè i, (hA.eigenvalues i : ùïú) ",":= by
  convert congr_arg det hA.spectral_theorem
  rw [det_mul_right_comm]
  simp"
Mathlib/Topology/Separation.lean,nhds_basis_clopen,nhds_basis_clopen,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":=
  ‚ü®fun U => by
    constructor
    ¬∑ have hx : connectedComponent x = {x} :=
        totallyDisconnectedSpace_iff_connectedComponent_singleton.mp ‚Äπ_‚Ä∫ x
      rw [connectedComponent_eq_iInter_isClopen] at hx
      intro hU
      let N := { s // IsClopen s ‚àß x ‚àà s }
      rsuffices ‚ü®‚ü®s, hs, hs'‚ü©, hs''‚ü© : ‚àÉ s : N, s.val ‚äÜ U
      ¬∑ exact ‚ü®s, ‚ü®hs', hs‚ü©, hs''‚ü©
      haveI : Nonempty N := ‚ü®‚ü®univ, isClopen_univ, mem_univ x‚ü©‚ü©
      have hNcl : ‚àÄ s : N, IsClosed s.val := fun s => s.property.1.1
      have hdir : Directed Superset fun s : N => s.val := by
        rintro ‚ü®s, hs, hxs‚ü© ‚ü®t, ht, hxt‚ü©
        exact ‚ü®‚ü®s ‚à© t, hs.inter ht, ‚ü®hxs, hxt‚ü©‚ü©, inter_subset_left s t, inter_subset_right s t‚ü©
      have h_nhd : ‚àÄ y ‚àà ‚ãÇ s : N, s.val, U ‚àà ùìù y := fun y y_in => by
        erw [hx, mem_singleton_iff] at y_in
        rwa [y_in]
      exact exists_subset_nhds_of_compactSpace hdir hNcl h_nhd
    ¬∑ rintro ‚ü®V, ‚ü®hxV, -, V_op‚ü©, hUV : V ‚äÜ U‚ü©
      rw [mem_nhds_iff]
      exact ‚ü®V, hUV, V_op, hxV‚ü©‚ü©","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set X : Type u_1
but is expected to have type
  ?m.217476 ‚àà ?m.217474 ‚à© ?m.217475 : Prop
error:  application type mismatch
  inter_subset_right s
argument
  s
has type
  Set X : Type u_1
but is expected to have type
  ?m.217792 ‚àà ?m.217790 ‚à© ?m.217791 : Prop",theorem nhds_basis_clopen (x : X) : (ùìù x).HasBasis (fun s : Set X => x ‚àà s ‚àß IsClopen s) id ,":=
  ‚ü®fun U => by
    constructor
    ¬∑ have hx : connectedComponent x = {x} :=
        totallyDisconnectedSpace_iff_connectedComponent_singleton.mp ‚Äπ_‚Ä∫ x
      rw [connectedComponent_eq_iInter_isClopen] at hx
      intro hU
      let N := { s // IsClopen s ‚àß x ‚àà s }
      rsuffices ‚ü®‚ü®s, hs, hs'‚ü©, hs''‚ü© : ‚àÉ s : N, s.val ‚äÜ U
      ¬∑ exact ‚ü®s, ‚ü®hs', hs‚ü©, hs''‚ü©
      haveI : Nonempty N := ‚ü®‚ü®univ, isClopen_univ, mem_univ x‚ü©‚ü©
      have hNcl : ‚àÄ s : N, IsClosed s.val := fun s => s.property.1.1
      have hdir : Directed Superset fun s : N => s.val := by
        rintro ‚ü®s, hs, hxs‚ü© ‚ü®t, ht, hxt‚ü©
        exact ‚ü®‚ü®s ‚à© t, hs.inter ht, ‚ü®hxs, hxt‚ü©‚ü©, inter_subset_left, inter_subset_right‚ü©
      have h_nhd : ‚àÄ y ‚àà ‚ãÇ s : N, s.val, U ‚àà ùìù y := fun y y_in => by
        erw [hx, mem_singleton_iff] at y_in
        rwa [y_in]
      exact exists_subset_nhds_of_compactSpace hdir hNcl h_nhd
    ¬∑ rintro ‚ü®V, ‚ü®hxV, -, V_op‚ü©, hUV : V ‚äÜ U‚ü©
      rw [mem_nhds_iff]
      exact ‚ü®V, hUV, V_op, hxV‚ü©‚ü©"
Mathlib/LinearAlgebra/Orientation.lean,Orientation.eq_or_eq_neg_of_isEmpty,eq_or_eq_neg_of_isEmpty,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' o with x hx
  dsimp [positiveOrientation]
  simp only [ray_eq_iff, sameRay_neg_swap]
  rw [sameRay_or_sameRay_neg_iff_not_linearIndependent]
  intro h
  set f : (M [‚ãÄ^Œπ]‚Üí‚Çó[R] R) ‚âÉ‚Çó[R] R := AlternatingMap.constLinearEquivOfIsEmpty.symm
  have H : LinearIndependent R ![f x, 1] := by
    convert h.map' f.toLinearMap f.ker
    ext i
    fin_cases i <;> simp [f]
  rw [linearIndependent_iff'] at H
  simpa using H Finset.univ ![1, -f x] (by simp [Fin.sum_univ_succ]) 0 (by simp)","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
R : Type u_1
inst‚úù¬≥ : LinearOrderedCommRing R
M : Type u_2
inst‚úù¬≤ : AddCommGroup M
inst‚úù¬π : Module R M
Œπ : Type u_3
inst‚úù : IsEmpty Œπ
o : Orientation R M Œπ
‚ä¢ o = positiveOrientation ‚à® o = -positiveOrientation","theorem eq_or_eq_neg_of_isEmpty [IsEmpty Œπ] (o : Orientation R M Œπ) :
    o = positiveOrientation ‚à® o = -positiveOrientation ",":= by
  induction' o using Module.Ray.ind with x hx
  dsimp [positiveOrientation]
  simp only [ray_eq_iff, sameRay_neg_swap]
  rw [sameRay_or_sameRay_neg_iff_not_linearIndependent]
  intro h
  set f : (M [‚ãÄ^Œπ]‚Üí‚Çó[R] R) ‚âÉ‚Çó[R] R := AlternatingMap.constLinearEquivOfIsEmpty.symm
  have H : LinearIndependent R ![f x, 1] := by
    convert h.map' f.toLinearMap f.ker
    ext i
    fin_cases i <;> simp [f]
  rw [linearIndependent_iff'] at H
  simpa using H Finset.univ ![1, -f x] (by simp [Fin.sum_univ_succ]) 0 (by simp)"
Mathlib/Topology/Category/Stonean/Basic.lean,Stonean.epi_iff_surjective,epi_iff_surjective,5b2e142323b7a721e3ae2adce3b172f93a82f823,":= by
  refine ‚ü®?_, ConcreteCategory.epi_of_surjective _‚ü©
  dsimp [Function.Surjective]
  intro h y
  by_contra! hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := C·∂ú
  have hUy : U ‚àà ùìù y := by
    simp only [Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain ‚ü®V, hV, hyV, hVU‚ü© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy
  classical
  let g : Y ‚ü∂ mkFinite (ULift (Fin 2)) :=
    ‚ü®(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _‚ü©
  let h : Y ‚ü∂ mkFinite (ULift (Fin 2)) := ‚ü®fun _ => ‚ü®1‚ü©, continuous_const‚ü©
  have H : h = g := by
    rw [‚Üê cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU ¬∑) ?_ 
    simpa only [Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H","error:  simp made no progress
error:  type mismatch
  h‚úù
has type
  ‚àÉ a, f a = f x : Prop
but is expected to have type
  f x ‚àâ U : Prop","lemma epi_iff_surjective {X Y : Stonean} (f : X ‚ü∂ Y) :
    Epi f ‚Üî Function.Surjective f ",":= by
  refine ‚ü®?_, ConcreteCategory.epi_of_surjective _‚ü©
  dsimp [Function.Surjective]
  intro h y
  by_contra! hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := C·∂ú
  have hUy : U ‚àà ùìù y := by
    simp only [C, Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain ‚ü®V, hV, hyV, hVU‚ü© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy
  classical
  let g : Y ‚ü∂ mkFinite (ULift (Fin 2)) :=
    ‚ü®(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _‚ü©
  let h : Y ‚ü∂ mkFinite (ULift (Fin 2)) := ‚ü®fun _ => ‚ü®1‚ü©, continuous_const‚ü©
  have H : h = g := by
    rw [‚Üê cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU ¬∑) ?_ 
    simpa only [U, Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H"
Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean,CategoryTheory.Pretriangulated.Triangle.yoneda_exact‚ÇÉ,yoneda_exact‚ÇÉ,8535b08ef59bcdb8a9d09a473f4b6c583f54aef0,":=
  yoneda_exact‚ÇÇ _ (rot_of_dist_triangle _ hT) f hf","error:  unknown identifier 'rot_of_dist_triangle'
error:  application type mismatch
  yoneda_exact‚ÇÉ T hT
argument
  hT
has type
  T ‚àà distinguishedTriangles : Prop
but is expected to have type
  T.obj‚ÇÉ ‚ü∂ ?m.92968 : Type v
error:  rcases tactic failed: x‚úù : ?m.93901 is not an inductive datatype","lemma yoneda_exact‚ÇÉ {X : C} (f : T.obj‚ÇÉ ‚ü∂ X) (hf : T.mor‚ÇÇ ‚â´ f = 0) :
    ‚àÉ (g : T.obj‚ÇÅ‚ü¶(1 : ‚Ñ§)‚üß ‚ü∂ X), f = T.mor‚ÇÉ ‚â´ g ",":=
  yoneda_exact‚ÇÇ _ (rot_of_distTriang _ hT) f hf"
Mathlib/Computability/TuringMachine.lean,Turing.BlankExtends.trans,BlankExtends.trans,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rintro ‚ü®i, rfl‚ü© ‚ü®j, rfl‚ü©
  exact ‚ü®i + j, by simp [List.replicate_add]‚ü©","error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
warning:  `List.get_append` has been deprecated, use `List.getElem_append` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get_replicate` has been deprecated, use `List.getElem_replicate` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  unused variable `M`
note: this linter can be disabled with `set_option linter.unusedVariables false`
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead","theorem BlankExtends.trans {Œì} [Inhabited Œì] {l‚ÇÅ l‚ÇÇ l‚ÇÉ : List Œì} :
    BlankExtends l‚ÇÅ l‚ÇÇ ‚Üí BlankExtends l‚ÇÇ l‚ÇÉ ‚Üí BlankExtends l‚ÇÅ l‚ÇÉ ",":= by
  rintro ‚ü®i, rfl‚ü© ‚ü®j, rfl‚ü©
  exact ‚ü®i + j, by simp‚ü©"
Mathlib/CategoryTheory/Localization/CalculusOfFractions/Fractions.lean,CategoryTheory.Localization.exists_leftFraction‚ÇÉ,exists_leftFraction‚ÇÉ,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  obtain ‚ü®Œ±, hŒ±, hŒ±'‚ü© := exists_leftFraction‚ÇÇ L W f f'
  have ‚ü®Œ≤, hŒ≤‚ü© := exists_leftFraction L W f''
  obtain ‚ü®Œ≥, hŒ≥‚ü© := (RightFraction.mk _ Œ±.hs Œ≤.s).exists_leftFraction
  dsimp at hŒ≥
  let œà : W.LeftFraction‚ÇÉ X Y :=
    { Y' := Œ≥.Y'
      f := Œ±.f ‚â´ Œ≥.f
      f' := Œ±.f' ‚â´ Œ≥.f
      f'' := Œ≤.f ‚â´ Œ≥.s
      s := Œ≤.s ‚â´ Œ≥.s
      hs := W.comp_mem _ _ Œ≤.hs Œ≥.hs }
  have := inverts L W _ Œ≤.hs
  have := inverts L W _ Œ≥.hs
  have : IsIso (L.map (Œ≤.s ‚â´ Œ≥.s)) := by
    rw [L.map_comp]
    infer_instance
  refine ‚ü®œà, ?_, ?_?, _‚ü©
  ¬∑ rw [‚Üê cancel_mono (L.map (Œ≤.s ‚â´ Œ≥.s)), LeftFraction.map_comp_map_s, hŒ±, hŒ≥,
      L.map_comp, LeftFraction.map_comp_map_s_assoc, L.map_comp]
  ¬∑ rw [‚Üê cancel_mono (L.map (Œ≤.s ‚â´ Œ≥.s)), LeftFraction.map_comp_map_s, hŒ±', hŒ≥,
      L.map_comp, LeftFraction.map_comp_map_s_assoc, L.map_comp]
  ¬∑ rw [‚Üê cancel_mono (L.map (Œ≤.s ‚â´ Œ≥.s)), hŒ≤]
    nth_rw 1 [L.map_comp]
    rw [LeftFraction.map_comp_map_s_assoc, LeftFraction.map_comp_map_s, L.map_comp]","error:  don't know how to synthesize placeholder for argument 'right'
context:
C : Type u_1
D : Type u_2
inst‚úù¬≥ : Category.{u_4, u_1} C
inst‚úù¬≤ : Category.{u_3, u_2} D
L : C ‚•§ D
W : MorphismProperty C
inst‚úù¬π : L.IsLocalization W
inst‚úù : W.HasLeftCalculusOfFractions
X Y : C
f f' f'' : L.obj X ‚ü∂ L.obj Y
Œ± : W.LeftFraction‚ÇÇ X Y
hŒ± : f = Œ±.fst.map L ‚ãØ
hŒ±' : f' = Œ±.snd.map L ‚ãØ
Œ≤ : W.LeftFraction X Y
hŒ≤ : f'' = Œ≤.map L ‚ãØ
Œ≥ : W.LeftFraction Œ±.Y' Œ≤.Y'
hŒ≥ : Œ≤.s ‚â´ Œ≥.s = Œ±.s ‚â´ Œ≥.f
œà : W.LeftFraction‚ÇÉ X Y := LeftFraction‚ÇÉ.mk (Œ±.f ‚â´ Œ≥.f) (Œ±.f' ‚â´ Œ≥.f) (Œ≤.f ‚â´ Œ≥.s) (Œ≤.s ‚â´ Œ≥.s) ‚ãØ
this‚úù¬π : IsIso (L.map Œ≤.s)
this‚úù : IsIso (L.map Œ≥.s)
this : IsIso (L.map (Œ≤.s ‚â´ Œ≥.s))
‚ä¢ f'' = œà.thd.map L ‚ãØ
error:  unsolved goals
case intro.intro.intro
C : Type u_1
D : Type u_2
inst‚úù¬≥ : Category.{u_4, u_1} C
inst‚úù¬≤ : Category.{u_3, u_2} D
L : C ‚•§ D
W : MorphismProperty C
inst‚úù¬π : L.IsLocalization W
inst‚úù : W.HasLeftCalculusOfFractions
X Y : C
f f' f'' : L.obj X ‚ü∂ L.obj Y
Œ± : W.LeftFraction‚ÇÇ X Y
hŒ± : f = Œ±.fst.map L ‚ãØ
hŒ±' : f' = Œ±.snd.map L ‚ãØ
Œ≤ : W.LeftFraction X Y
hŒ≤ : f'' = Œ≤.map L ‚ãØ
Œ≥ : W.LeftFraction Œ±.Y' Œ≤.Y'
hŒ≥ : Œ≤.s ‚â´ Œ≥.s = Œ±.s ‚â´ Œ≥.f
œà : W.LeftFraction‚ÇÉ X Y := LeftFraction‚ÇÉ.mk (Œ±.f ‚â´ Œ≥.f) (Œ±.f' ‚â´ Œ≥.f) (Œ≤.f ‚â´ Œ≥.s) (Œ≤.s ‚â´ Œ≥.s) ‚ãØ
this‚úù¬π : IsIso (L.map Œ≤.s)
this‚úù : IsIso (L.map Œ≥.s)
this : IsIso (L.map (Œ≤.s ‚â´ Œ≥.s))
‚ä¢ ‚àÉ œÜ, f = œÜ.fst.map L ‚ãØ ‚àß f' = œÜ.snd.map L ‚ãØ ‚àß f'' = œÜ.thd.map L ‚ãØ","lemma exists_leftFraction‚ÇÉ {X Y : C} (f f' f'' : L.obj X ‚ü∂ L.obj Y) :
    ‚àÉ (œÜ : W.LeftFraction‚ÇÉ X Y), f = œÜ.fst.map L (inverts L W) ‚àß
      f' = œÜ.snd.map L (inverts L W) ‚àß
      f'' = œÜ.thd.map L (inverts L W) ",":= by
  obtain ‚ü®Œ±, hŒ±, hŒ±'‚ü© := exists_leftFraction‚ÇÇ L W f f'
  have ‚ü®Œ≤, hŒ≤‚ü© := exists_leftFraction L W f''
  obtain ‚ü®Œ≥, hŒ≥‚ü© := (RightFraction.mk _ Œ±.hs Œ≤.s).exists_leftFraction
  dsimp at hŒ≥
  let œà : W.LeftFraction‚ÇÉ X Y :=
    { Y' := Œ≥.Y'
      f := Œ±.f ‚â´ Œ≥.f
      f' := Œ±.f' ‚â´ Œ≥.f
      f'' := Œ≤.f ‚â´ Œ≥.s
      s := Œ≤.s ‚â´ Œ≥.s
      hs := W.comp_mem _ _ Œ≤.hs Œ≥.hs }
  have := inverts L W _ Œ≤.hs
  have := inverts L W _ Œ≥.hs
  have : IsIso (L.map (Œ≤.s ‚â´ Œ≥.s)) := by
    rw [L.map_comp]
    infer_instance
  refine ‚ü®œà, ?_, ?_, ?_‚ü©
  ¬∑ rw [‚Üê cancel_mono (L.map (Œ≤.s ‚â´ Œ≥.s)), LeftFraction.map_comp_map_s, hŒ±, hŒ≥,
      L.map_comp, LeftFraction.map_comp_map_s_assoc, L.map_comp]
  ¬∑ rw [‚Üê cancel_mono (L.map (Œ≤.s ‚â´ Œ≥.s)), LeftFraction.map_comp_map_s, hŒ±', hŒ≥,
      L.map_comp, LeftFraction.map_comp_map_s_assoc, L.map_comp]
  ¬∑ rw [‚Üê cancel_mono (L.map (Œ≤.s ‚â´ Œ≥.s)), hŒ≤]
    nth_rw 1 [L.map_comp]
    rw [LeftFraction.map_comp_map_s_assoc, LeftFraction.map_comp_map_s, L.map_comp]"
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.tendsto_Lp_of_tendsto_ae,tendsto_Lp_of_tendsto_ae,494478bf8809a6197efc24a4ee1fc7b02edca0e8,":= by
  rw [ENNReal.tendsto_atTop_zero]
  intro Œµ hŒµ
  by_cases h : Œµ < ‚àû; swap
  ¬∑ rw [not_lt, top_le_iff] at h
    exact ‚ü®0, fun n _ => by simp [h]‚ü©
  by_cases hŒº : Œº = 0
  ¬∑ exact ‚ü®0, fun n _ => by simp [hŒº]‚ü©
  have hŒµ' : 0 < Œµ.toReal / 3 :=
    div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (by norm_num)
  have hdivp : 0 ‚â§ 1 / p.toReal := by
    refine' one_div_nonneg.2 _
    rw [‚Üê ENNReal.zero_toReal, ENNReal.toReal_le_toReal ENNReal.zero_ne_top hp']
    exact le_trans (zero_le _) hp
  have hpow : 0 < measureUnivNNReal Œº ^ (1 / p.toReal) :=
    Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
  obtain ‚ü®Œ¥‚ÇÅ, hŒ¥‚ÇÅ, hsnorm‚ÇÅ‚ü© := hui hŒµ'
  obtain ‚ü®Œ¥‚ÇÇ, hŒ¥‚ÇÇ, hsnorm‚ÇÇ‚ü© := hg'.snorm_indicator_le Œº hp hp' hŒµ'
  obtain ‚ü®t, htm, ht‚ÇÅ, ht‚ÇÇ‚ü© := tendstoUniformlyOn_of_ae_tendsto' hf hg hfg (lt_min hŒ¥‚ÇÅ hŒ¥‚ÇÇ)
  rw [Metric.tendstoUniformlyOn_iff] at ht‚ÇÇ
  specialize ht‚ÇÇ (Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    (div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (mul_pos (by norm_num) hpow))
  obtain ‚ü®N, hN‚ü© := eventually_atTop.1 ht‚ÇÇ; clear ht‚ÇÇ
  refine' ‚ü®N, fun n hn => _‚ü©
  rw [‚Üê t.indicator_self_add_compl (f n - g)]
  refine' le_trans (snorm_add_le (((hf n).sub hg).indicator htm).aestronglyMeasurable
    (((hf n).sub hg).indicator htm.compl).aestronglyMeasurable hp) _
  rw [sub_eq_add_neg, Set.indicator_add' t, Set.indicator_neg']
  refine' le_trans (add_le_add_right (snorm_add_le ((hf n).indicator htm).aestronglyMeasurable
    (hg.indicator htm).neg.aestronglyMeasurable hp) _) _
  have hnf : snorm (t.indicator (f n)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine' hsnorm‚ÇÅ n t htm (le_trans ht‚ÇÅ _)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÅ.le]
    exact min_le_left _ _
  have hng : snorm (t.indicator g) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine' hsnorm‚ÇÇ t htm (le_trans ht‚ÇÅ _)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÇ.le]
    exact min_le_right _ _
  have hlt : snorm (t·∂ú.indicator (f n - g)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    specialize hN n hn
    have : 0 ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)) := by
      rw [div_mul_eq_div_mul_one_div]
      exact mul_nonneg hŒµ'.le (one_div_nonneg.2 hpow.le)
    have := snorm_sub_le_of_dist_bdd Œº hp' htm.compl this fun x hx =>
      (dist_comm (g x) (f n x) ‚ñ∏ (hN x hx).le :
        dist (f n x) (g x) ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    refine' le_trans this _
    rw [div_mul_eq_div_mul_one_div, ‚Üê ENNReal.ofReal_toReal (measure_lt_top Œº t·∂ú).ne,
      ENNReal.ofReal_rpow_of_nonneg ENNReal.toReal_nonneg hdivp, ‚Üê ENNReal.ofReal_mul, mul_assoc]
    ¬∑ refine' ENNReal.ofReal_le_ofReal (mul_le_of_le_one_right hŒµ'.le _)
      rw [mul_comm, mul_one_div, div_le_one]
      ¬∑ refine' Real.rpow_le_rpow ENNReal.toReal_nonneg
          (ENNReal.toReal_le_of_le_ofReal (measureUnivNNReal_pos hŒº).le _) hdivp
        rw [ENNReal.ofReal_coe_nnreal, coe_measureUnivNNReal]
        exact measure_mono (Set.subset_univ _)
      ¬∑ exact Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
    ¬∑ refine' mul_nonneg hŒµ'.le (one_div_nonneg.2 hpow.le)
  have : ENNReal.ofReal (Œµ.toReal / 3) = Œµ / 3 := by
    rw [ENNReal.ofReal_div_of_pos (show (0 : ‚Ñù) < 3 by norm_num), ENNReal.ofReal_toReal h.ne]
    simp
  rw [this] at hnf hng hlt
  rw [snorm_neg, ‚Üê ENNReal.add_thirds Œµ, ‚Üê sub_eq_add_neg]
  exact add_le_add_three hnf hng hlt","error:  application type mismatch
  Mem‚Ñíp.snorm_indicator_le Œº
argument
  Œº
has type
  Measure Œ± : Type u_1
but is expected to have type
  1 ‚â§ ?m.125901 : Prop
error:  rcases tactic failed: x‚úù : ?m.127562 is not an inductive datatype","theorem tendsto_Lp_of_tendsto_ae_of_meas [IsFiniteMeasure Œº] (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû)
    {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (hf : ‚àÄ n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g)
    (hg' : Mem‚Ñíp g p Œº) (hui : UnifIntegrable f p Œº)
    (hfg : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (g x))) :
    Tendsto (fun n => snorm (f n - g) p Œº) atTop (ùìù 0) ",":= by
  rw [ENNReal.tendsto_atTop_zero]
  intro Œµ hŒµ
  by_cases h : Œµ < ‚àû; swap
  ¬∑ rw [not_lt, top_le_iff] at h
    exact ‚ü®0, fun n _ => by simp [h]‚ü©
  by_cases hŒº : Œº = 0
  ¬∑ exact ‚ü®0, fun n _ => by simp [hŒº]‚ü©
  have hŒµ' : 0 < Œµ.toReal / 3 :=
    div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (by norm_num)
  have hdivp : 0 ‚â§ 1 / p.toReal := by
    refine one_div_nonneg.2 ?_
    rw [‚Üê ENNReal.zero_toReal, ENNReal.toReal_le_toReal ENNReal.zero_ne_top hp']
    exact le_trans (zero_le _) hp
  have hpow : 0 < measureUnivNNReal Œº ^ (1 / p.toReal) :=
    Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
  obtain ‚ü®Œ¥‚ÇÅ, hŒ¥‚ÇÅ, hsnorm‚ÇÅ‚ü© := hui hŒµ'
  obtain ‚ü®Œ¥‚ÇÇ, hŒ¥‚ÇÇ, hsnorm‚ÇÇ‚ü© := hg'.snorm_indicator_le hp hp' hŒµ'
  obtain ‚ü®t, htm, ht‚ÇÅ, ht‚ÇÇ‚ü© := tendstoUniformlyOn_of_ae_tendsto' hf hg hfg (lt_min hŒ¥‚ÇÅ hŒ¥‚ÇÇ)
  rw [Metric.tendstoUniformlyOn_iff] at ht‚ÇÇ
  specialize ht‚ÇÇ (Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    (div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (mul_pos (by norm_num) hpow))
  obtain ‚ü®N, hN‚ü© := eventually_atTop.1 ht‚ÇÇ; clear ht‚ÇÇ
  refine ‚ü®N, fun n hn => ?_‚ü©
  rw [‚Üê t.indicator_self_add_compl (f n - g)]
  refine le_trans (snorm_add_le (((hf n).sub hg).indicator htm).aestronglyMeasurable
    (((hf n).sub hg).indicator htm.compl).aestronglyMeasurable hp) ?_
  rw [sub_eq_add_neg, Set.indicator_add' t, Set.indicator_neg']
  refine le_trans (add_le_add_right (snorm_add_le ((hf n).indicator htm).aestronglyMeasurable
    (hg.indicator htm).neg.aestronglyMeasurable hp) _) ?_
  have hnf : snorm (t.indicator (f n)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine hsnorm‚ÇÅ n t htm (le_trans ht‚ÇÅ ?_)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÅ.le]
    exact min_le_left _ _
  have hng : snorm (t.indicator g) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine hsnorm‚ÇÇ t htm (le_trans ht‚ÇÅ ?_)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÇ.le]
    exact min_le_right _ _
  have hlt : snorm (t·∂ú.indicator (f n - g)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    specialize hN n hn
    have : 0 ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)) := by positivity
    have := snorm_sub_le_of_dist_bdd Œº hp' htm.compl this fun x hx =>
      (dist_comm (g x) (f n x) ‚ñ∏ (hN x hx).le :
        dist (f n x) (g x) ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    refine le_trans this ?_
    rw [div_mul_eq_div_mul_one_div, ‚Üê ENNReal.ofReal_toReal (measure_lt_top Œº t·∂ú).ne,
      ENNReal.ofReal_rpow_of_nonneg ENNReal.toReal_nonneg hdivp, ‚Üê ENNReal.ofReal_mul, mul_assoc]
    ¬∑ refine ENNReal.ofReal_le_ofReal (mul_le_of_le_one_right hŒµ'.le ?_)
      rw [mul_comm, mul_one_div, div_le_one]
      ¬∑ refine Real.rpow_le_rpow ENNReal.toReal_nonneg
          (ENNReal.toReal_le_of_le_ofReal (measureUnivNNReal_pos hŒº).le ?_) hdivp
        rw [ENNReal.ofReal_coe_nnreal, coe_measureUnivNNReal]
        exact measure_mono (Set.subset_univ _)
      ¬∑ exact Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
    ¬∑ positivity
  have : ENNReal.ofReal (Œµ.toReal / 3) = Œµ / 3 := by
    rw [ENNReal.ofReal_div_of_pos (show (0 : ‚Ñù) < 3 by norm_num), ENNReal.ofReal_toReal h.ne]
    simp
  rw [this] at hnf hng hlt
  rw [snorm_neg, ‚Üê ENNReal.add_thirds Œµ, ‚Üê sub_eq_add_neg]
  exact add_le_add_three hnf hng hlt"
Mathlib/Geometry/Manifold/Complex.lean,Complex.norm_eventually_eq_of_mdifferentiableAt_of_isLocalMax,Complex.norm_eventually_eq_of_mdifferentiableAt_of_isLocalMax,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  set e := extChartAt I c
  have hI : range I = univ := ModelWithCorners.Boundaryless.range_eq_univ
  have H‚ÇÅ : ùìù[range I] (e c) = ùìù (e c) := by rw [hI, nhdsWithin_univ]
  have H‚ÇÇ : map e.symm (ùìù (e c)) = ùìù c := by
    rw [‚Üê map_extChartAt_symm_nhdsWithin_range I c, H‚ÇÅ]
  rw [‚Üê H‚ÇÇ, eventually_map]
  replace hd : ‚àÄ·∂† y in ùìù (e c), DifferentiableAt ‚ÑÇ (f ‚àò e.symm) y := by
    have : e.target ‚àà ùìù (e c) := H‚ÇÅ ‚ñ∏ extChartAt_target_mem_nhdsWithin I c
    filter_upwards [this, Tendsto.eventually H‚ÇÇ.le hd] with y hyt hy‚ÇÇ
    have hys : e.symm y ‚àà (chartAt H c).source := by
      rw [‚Üê extChartAt_source I c]
      exact (extChartAt I c).map_target hyt
    have hfy : f (e.symm y) ‚àà (chartAt F (0 : F)).source := mem_univ _
    rw [mdifferentiableAt_iff_of_mem_source hys hfy, hI, differentiableWithinAt_univ,
      e.right_inv hyt] at hy‚ÇÇ
    exact hy‚ÇÇ.2
  convert norm_eventually_eq_of_isLocalMax hd _
  ¬∑ exact congr_arg f (extChartAt_to_inv _ _).symm
  ¬∑ simpa only [IsLocalMax, IsMaxFilter, ‚Üê H‚ÇÇ, (¬∑ ‚àò ¬∑), extChartAt_to_inv] using hc","error:  type mismatch
  h‚úù
has type
  ‚àÄ·∂† (x : M) in map (‚Üëe.symm) (ùìù (‚Üëe c)), ‚Äñf x‚Äñ ‚â§ ‚Äñf c‚Äñ : Prop
but is expected to have type
  ‚àÄ·∂† (x : E) in ùìù (‚Üëe c), ‚Äñf (‚Üëe.symm x)‚Äñ ‚â§ ‚Äñf (‚Üëe.symm (‚Üëe c))‚Äñ : Prop","theorem Complex.norm_eventually_eq_of_mdifferentiableAt_of_isLocalMax {f : M ‚Üí F} {c : M}
    (hd : ‚àÄ·∂† z in ùìù c, MDifferentiableAt I ùìò(‚ÑÇ, F) f z) (hc : IsLocalMax (norm ‚àò f) c) :
    ‚àÄ·∂† y in ùìù c, ‚Äñf y‚Äñ = ‚Äñf c‚Äñ ",":= by
  set e := extChartAt I c
  have hI : range I = univ := ModelWithCorners.Boundaryless.range_eq_univ
  have H‚ÇÅ : ùìù[range I] (e c) = ùìù (e c) := by rw [hI, nhdsWithin_univ]
  have H‚ÇÇ : map e.symm (ùìù (e c)) = ùìù c := by
    rw [‚Üê map_extChartAt_symm_nhdsWithin_range I c, H‚ÇÅ]
  rw [‚Üê H‚ÇÇ, eventually_map]
  replace hd : ‚àÄ·∂† y in ùìù (e c), DifferentiableAt ‚ÑÇ (f ‚àò e.symm) y := by
    have : e.target ‚àà ùìù (e c) := H‚ÇÅ ‚ñ∏ extChartAt_target_mem_nhdsWithin I c
    filter_upwards [this, Tendsto.eventually H‚ÇÇ.le hd] with y hyt hy‚ÇÇ
    have hys : e.symm y ‚àà (chartAt H c).source := by
      rw [‚Üê extChartAt_source I c]
      exact (extChartAt I c).map_target hyt
    have hfy : f (e.symm y) ‚àà (chartAt F (0 : F)).source := mem_univ _
    rw [mdifferentiableAt_iff_of_mem_source hys hfy, hI, differentiableWithinAt_univ,
      e.right_inv hyt] at hy‚ÇÇ
    exact hy‚ÇÇ.2
  convert norm_eventually_eq_of_isLocalMax hd _
  ¬∑ exact congr_arg f (extChartAt_to_inv _ _).symm
  ¬∑ simpa only [e, IsLocalMax, IsMaxFilter, ‚Üê H‚ÇÇ, (¬∑ ‚àò ¬∑), extChartAt_to_inv] using hc"
Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean,hasDerivAt_ofReal_cpow,hasDerivAt_ofReal_cpow,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  rw [Ne.def, ‚Üê add_eq_zero_iff_eq_neg, ‚Üê Ne.def] at hr
  rcases lt_or_gt_of_ne hx.symm with (hx | hx)
  ¬∑ 
    apply HasDerivAt.comp_ofReal (e := fun y => (y : ‚ÑÇ) ^ (r + 1) / (r + 1))
    convert HasDerivAt.div_const (ùïú := ‚ÑÇ) ?_ (r + 1) using 1
    ¬∑ exact (mul_div_cancel_right‚ÇÄ _ hr).symm
    ¬∑ convert HasDerivAt.cpow_const ?_ ?_ using 1
      ¬∑ rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm
      ¬∑ exact hasDerivAt_id (x : ‚ÑÇ)
      ¬∑ simp [hx]
  ¬∑ 
    have : ‚àÄ·∂† y : ‚Ñù in ùìù x,
        (y : ‚ÑÇ) ^ (r + 1) / (r + 1) = (-y : ‚ÑÇ) ^ (r + 1) * exp (œÄ * I * (r + 1)) / (r + 1) := by
      refine' Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => _
      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]
    refine' HasDerivAt.congr_of_eventuallyEq _ this
    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]
    suffices HasDerivAt (fun y : ‚Ñù => (-‚Üëy) ^ (r + 1) * exp (‚ÜëœÄ * I * (r + 1)))
        ((r + 1) * (-‚Üëx) ^ r * exp (‚ÜëœÄ * I * r)) x by
      convert this.div_const (r + 1) using 1
      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right‚ÇÄ _ hr]
    rw [mul_add ((œÄ : ‚ÑÇ) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : ‚ÑÇ) (-1 : ‚ÑÇ),
      neg_one_mul]
    simp_rw [mul_neg, ‚Üê neg_mul, ‚Üê ofReal_neg]
    suffices HasDerivAt (fun y : ‚Ñù => (‚Üë(-y) : ‚ÑÇ) ^ (r + 1)) (-(r + 1) * ‚Üë(-x) ^ r) x by
      convert this.neg.mul_const _ using 1; ring
    suffices HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) (-x) by
      convert @HasDerivAt.scomp ‚Ñù _ ‚ÑÇ _ _ x ‚Ñù _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1
      rw [real_smul, ofReal_neg 1, ofReal_one]; ring
    suffices HasDerivAt (fun y : ‚ÑÇ => y ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) ‚Üë(-x) by
      exact this.comp_ofReal
    conv in ‚Üë_ ^ _ => rw [(by ring : r = r + 1 - 1)]
    convert HasDerivAt.cpow_const ?_ ?_ using 1
    ¬∑ rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm
    ¬∑ exact hasDerivAt_id ((-x : ‚Ñù) : ‚ÑÇ)
    ¬∑ simp [hx]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.106391 ‚Üí ?m.106391 ‚Üí Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.106393
f g : ‚ÑÇ ‚Üí ‚ÑÇ
s : Set ‚ÑÇ
f' g' x‚úù c : ‚ÑÇ
x : ‚Ñù
hx : x ‚â† 0
r : ‚ÑÇ
hr : r ‚â† -1
‚ä¢ HasDerivAt (fun y ‚Ü¶ ‚Üëy ^ (r + 1) / (r + 1)) (‚Üëx ^ r) x","theorem hasDerivAt_ofReal_cpow {x : ‚Ñù} (hx : x ‚â† 0) {r : ‚ÑÇ} (hr : r ‚â† -1) :
    HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ (r + 1) / (r + 1)) (x ^ r) x ",":= by
  rw [Ne, ‚Üê add_eq_zero_iff_eq_neg, ‚Üê Ne] at hr
  rcases lt_or_gt_of_ne hx.symm with (hx | hx)
  ¬∑ 
    apply HasDerivAt.comp_ofReal (e := fun y => (y : ‚ÑÇ) ^ (r + 1) / (r + 1))
    convert HasDerivAt.div_const (ùïú := ‚ÑÇ) ?_ (r + 1) using 1
    ¬∑ exact (mul_div_cancel_right‚ÇÄ _ hr).symm
    ¬∑ convert HasDerivAt.cpow_const ?_ ?_ using 1
      ¬∑ rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm
      ¬∑ exact hasDerivAt_id (x : ‚ÑÇ)
      ¬∑ simp [hx]
  ¬∑ 
    have : ‚àÄ·∂† y : ‚Ñù in ùìù x,
        (y : ‚ÑÇ) ^ (r + 1) / (r + 1) = (-y : ‚ÑÇ) ^ (r + 1) * exp (œÄ * I * (r + 1)) / (r + 1) := by
      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_
      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]
    refine HasDerivAt.congr_of_eventuallyEq ?_ this
    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]
    suffices HasDerivAt (fun y : ‚Ñù => (-‚Üëy) ^ (r + 1) * exp (‚ÜëœÄ * I * (r + 1)))
        ((r + 1) * (-‚Üëx) ^ r * exp (‚ÜëœÄ * I * r)) x by
      convert this.div_const (r + 1) using 1
      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right‚ÇÄ _ hr]
    rw [mul_add ((œÄ : ‚ÑÇ) * _), mul_one, exp_add, exp_pi_mul_I, mul_comm (_ : ‚ÑÇ) (-1 : ‚ÑÇ),
      neg_one_mul]
    simp_rw [mul_neg, ‚Üê neg_mul, ‚Üê ofReal_neg]
    suffices HasDerivAt (fun y : ‚Ñù => (‚Üë(-y) : ‚ÑÇ) ^ (r + 1)) (-(r + 1) * ‚Üë(-x) ^ r) x by
      convert this.neg.mul_const _ using 1; ring
    suffices HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) (-x) by
      convert @HasDerivAt.scomp ‚Ñù _ ‚ÑÇ _ _ x ‚Ñù _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1
      rw [real_smul, ofReal_neg 1, ofReal_one]; ring
    suffices HasDerivAt (fun y : ‚ÑÇ => y ^ (r + 1)) ((r + 1) * ‚Üë(-x) ^ r) ‚Üë(-x) by
      exact this.comp_ofReal
    conv in ‚Üë_ ^ _ => rw [(by ring : r = r + 1 - 1)]
    convert HasDerivAt.cpow_const ?_ ?_ using 1
    ¬∑ rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm
    ¬∑ exact hasDerivAt_id ((-x : ‚Ñù) : ‚ÑÇ)
    ¬∑ simp [hx]"
Mathlib/SetTheory/Cardinal/SchroederBernstein.lean,Function.Embedding.schroeder_bernstein,schroeder_bernstein,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  cases' isEmpty_or_nonempty Œ≤ with hŒ≤ hŒ≤
  ¬∑ have : IsEmpty Œ± := Function.isEmpty f
    exact ‚ü®_, ((Equiv.equivEmpty Œ±).trans (Equiv.equivEmpty Œ≤).symm).bijective‚ü©
  set F : Set Œ± ‚Üío Set Œ± :=
    { toFun := fun s => (g '' (f '' s)·∂ú)·∂ú
      monotone' := fun s t hst =>
        compl_subset_compl.mpr <| image_subset _ <| compl_subset_compl.mpr <| image_subset _ hst }
  set s : Set Œ± := OrderHom.lfp F
  have hs : (g '' (f '' s)·∂ú)·∂ú = s := F.map_lfp
  have hns : g '' (f '' s)·∂ú = s·∂ú := compl_injective (by simp [hs])
  set g' := invFun g
  have g'g : LeftInverse g' g := leftInverse_invFun hg
  have hg'ns : g' '' s·∂ú = (f '' s)·∂ú := by rw [‚Üê hns, g'g.image_image]
  set h : Œ± ‚Üí Œ≤ := s.piecewise f g'
  have : Surjective h := by rw [‚Üê range_iff_surjective, range_piecewise, hg'ns, union_compl_self]
  have : Injective h := by
    refine (injective_piecewise_iff _).2 ‚ü®hf.injOn _, ?_, ?_‚ü©
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®x', _, rfl‚ü© : x ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      obtain ‚ü®y', _, rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _, g'g _] at hxy
      rw [hxy]
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®y', hy', rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _] at hxy
      exact hy' ‚ü®x, hx, hxy‚ü©
  exact ‚ü®h, ‚ÄπInjective h‚Ä∫, ‚ÄπSurjective h‚Ä∫‚ü©","error:  application type mismatch
  And.intro (Injective.injOn hf ?m.1813)
argument
  Injective.injOn hf ?m.1813
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Œ±‚¶Ñ, x‚ÇÇ ‚àà ?m.1811 ‚Üí f ?m.1812 = f x‚ÇÇ ‚Üí ?m.1812 = x‚ÇÇ : Prop
but is expected to have type
  InjOn f s : Prop","theorem schroeder_bernstein {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ±} (hf : Function.Injective f)
    (hg : Function.Injective g) : ‚àÉ h : Œ± ‚Üí Œ≤, Bijective h ",":= by
  cases' isEmpty_or_nonempty Œ≤ with hŒ≤ hŒ≤
  ¬∑ have : IsEmpty Œ± := Function.isEmpty f
    exact ‚ü®_, ((Equiv.equivEmpty Œ±).trans (Equiv.equivEmpty Œ≤).symm).bijective‚ü©
  set F : Set Œ± ‚Üío Set Œ± :=
    { toFun := fun s => (g '' (f '' s)·∂ú)·∂ú
      monotone' := fun s t hst =>
        compl_subset_compl.mpr <| image_subset _ <| compl_subset_compl.mpr <| image_subset _ hst }
  set s : Set Œ± := OrderHom.lfp F
  have hs : (g '' (f '' s)·∂ú)·∂ú = s := F.map_lfp
  have hns : g '' (f '' s)·∂ú = s·∂ú := compl_injective (by simp [hs])
  set g' := invFun g
  have g'g : LeftInverse g' g := leftInverse_invFun hg
  have hg'ns : g' '' s·∂ú = (f '' s)·∂ú := by rw [‚Üê hns, g'g.image_image]
  set h : Œ± ‚Üí Œ≤ := s.piecewise f g'
  have : Surjective h := by rw [‚Üê range_iff_surjective, range_piecewise, hg'ns, union_compl_self]
  have : Injective h := by
    refine (injective_piecewise_iff _).2 ‚ü®hf.injOn, ?_, ?_‚ü©
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®x', _, rfl‚ü© : x ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      obtain ‚ü®y', _, rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _, g'g _] at hxy
      rw [hxy]
    ¬∑ intro x hx y hy hxy
      obtain ‚ü®y', hy', rfl‚ü© : y ‚àà g '' (f '' s)·∂ú := by rwa [hns]
      rw [g'g _] at hxy
      exact hy' ‚ü®x, hx, hxy‚ü©
  exact ‚ü®h, ‚ÄπInjective h‚Ä∫, ‚ÄπSurjective h‚Ä∫‚ü©"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,uniformCauchySeqOnFilter_of_fderiv,uniformCauchySeqOnFilter_of_fderiv,1507c181c67dcc2ca8a6c4b34934872edf50bf0f,":= by
  let : NormedSpace ‚Ñù E; exact NormedSpace.restrictScalars ‚Ñù ùïú _
  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero] at hf' ‚ä¢
  suffices
    TendstoUniformlyOnFilter (fun (n : Œπ √ó Œπ) (z : E) => f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) 0
        (l √óÀ¢ l) (ùìù x) ‚àß
      TendstoUniformlyOnFilter (fun (n : Œπ √ó Œπ) (_ : E) => f n.1 x - f n.2 x) 0 (l √óÀ¢ l) (ùìù x) by
    have := this.1.add this.2
    rw [add_zero] at this
    exact this.congr (by simp)
  constructor
  ¬∑ 
    rw [Metric.tendstoUniformlyOnFilter_iff] at hf' ‚ä¢
    intro Œµ hŒµ
    have := (tendsto_swap4_prod.eventually (hf.prod_mk hf)).diag_of_prod_right
    obtain ‚ü®a, b, c, d, e‚ü© := eventually_prod_iff.1 ((hf' Œµ hŒµ).and this)
    obtain ‚ü®R, hR, hR'‚ü© := Metric.nhds_basis_ball.eventually_iff.mp d
    let r := min 1 R
    have hr : 0 < r := by simp [hR]
    have hr' : ‚àÄ ‚¶Éy : E‚¶Ñ, y ‚àà Metric.ball x r ‚Üí c y := fun y hy =>
      hR' (lt_of_lt_of_le (Metric.mem_ball.mp hy) (min_le_right _ _))
    have hxy : ‚àÄ y : E, y ‚àà Metric.ball x r ‚Üí ‚Äñy - x‚Äñ < 1 := by
      intro y hy
      rw [Metric.mem_ball, dist_eq_norm] at hy
      exact lt_of_lt_of_le hy (min_le_left _ _)
    have hxyŒµ : ‚àÄ y : E, y ‚àà Metric.ball x r ‚Üí Œµ * ‚Äñy - x‚Äñ < Œµ := by
      intro y hy
      exact (mul_lt_iff_lt_one_right hŒµ.lt).mpr (hxy y hy)
    refine'
      eventually_prod_iff.mpr
        ‚ü®_, b, fun e : E => Metric.ball x r e,
          eventually_mem_set.mpr (Metric.nhds_basis_ball.mem_of_mem hr), fun {n} hn {y} hy => _‚ü©
    simp only [Pi.zero_apply, dist_zero_left] at e ‚ä¢
    refine' lt_of_le_of_lt _ (hxyŒµ y hy)
    exact
      Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le
        (fun y hy => ((e hn (hr' hy)).2.1.sub (e hn (hr' hy)).2.2).hasFDerivWithinAt)
        (fun y hy => (e hn (hr' hy)).1.le) (convex_ball x r) (Metric.mem_ball_self hr) hy
  ¬∑ 
    refine' Metric.tendstoUniformlyOnFilter_iff.mpr fun Œµ hŒµ => _
    obtain ‚ü®t, ht, ht'‚ü© := (Metric.cauchy_iff.mp hfg).2 Œµ hŒµ
    exact
      eventually_prod_iff.mpr
        ‚ü®fun n : Œπ √ó Œπ => f n.1 x ‚àà t ‚àß f n.2 x ‚àà t,
          eventually_prod_iff.mpr ‚ü®_, ht, _, ht, fun {n} hn {n'} hn' => ‚ü®hn, hn'‚ü©‚ü©,
          fun _ => True,
          by simp,
          fun {n} hn {y} _ => by simpa [norm_sub_rev, dist_eq_norm] using ht' _ hn.1 _ hn.2‚ü©","error:  unexpected token ':'; expected '_', identifier or term
error:  unsolved goals
Œπ : Type u_1
l : Filter Œπ
E : Type u_2
inst‚úù‚Å¥ : NormedAddCommGroup E
ùïú : Type u_3
inst‚úù¬≥ : RCLike ùïú
inst‚úù¬≤ : NormedSpace ùïú E
G : Type u_4
inst‚úù¬π : NormedAddCommGroup G
inst‚úù : NormedSpace ùïú G
f : Œπ ‚Üí E ‚Üí G
g : E ‚Üí G
f' : Œπ ‚Üí E ‚Üí E ‚ÜíL[ùïú] G
g' : E ‚Üí E ‚ÜíL[ùïú] G
x : E
hf' : UniformCauchySeqOnFilter f' l (ùìù x)
hf : ‚àÄ·∂† (n : Œπ √ó E) in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2
hfg : Cauchy (map (fun n ‚Ü¶ f n x) l)
‚ä¢ UniformCauchySeqOnFilter f l (ùìù x)","theorem uniformCauchySeqOnFilter_of_fderiv (hf' : UniformCauchySeqOnFilter f' l (ùìù x))
    (hf : ‚àÄ·∂† n : Œπ √ó E in l √óÀ¢ ùìù x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : Cauchy (map (fun n => f n x) l)) : UniformCauchySeqOnFilter f l (ùìù x) ",":= by
  letI : NormedSpace ‚Ñù E := NormedSpace.restrictScalars ‚Ñù ùïú _
  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero] at hf' ‚ä¢
  suffices
    TendstoUniformlyOnFilter (fun (n : Œπ √ó Œπ) (z : E) => f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) 0
        (l √óÀ¢ l) (ùìù x) ‚àß
      TendstoUniformlyOnFilter (fun (n : Œπ √ó Œπ) (_ : E) => f n.1 x - f n.2 x) 0 (l √óÀ¢ l) (ùìù x) by
    have := this.1.add this.2
    rw [add_zero] at this
    exact this.congr (by simp)
  constructor
  ¬∑ 
    rw [Metric.tendstoUniformlyOnFilter_iff] at hf' ‚ä¢
    intro Œµ hŒµ
    have := (tendsto_swap4_prod.eventually (hf.prod_mk hf)).diag_of_prod_right
    obtain ‚ü®a, b, c, d, e‚ü© := eventually_prod_iff.1 ((hf' Œµ hŒµ).and this)
    obtain ‚ü®R, hR, hR'‚ü© := Metric.nhds_basis_ball.eventually_iff.mp d
    let r := min 1 R
    have hr : 0 < r := by simp [r, hR]
    have hr' : ‚àÄ ‚¶Éy : E‚¶Ñ, y ‚àà Metric.ball x r ‚Üí c y := fun y hy =>
      hR' (lt_of_lt_of_le (Metric.mem_ball.mp hy) (min_le_right _ _))
    have hxy : ‚àÄ y : E, y ‚àà Metric.ball x r ‚Üí ‚Äñy - x‚Äñ < 1 := by
      intro y hy
      rw [Metric.mem_ball, dist_eq_norm] at hy
      exact lt_of_lt_of_le hy (min_le_left _ _)
    have hxyŒµ : ‚àÄ y : E, y ‚àà Metric.ball x r ‚Üí Œµ * ‚Äñy - x‚Äñ < Œµ := by
      intro y hy
      exact (mul_lt_iff_lt_one_right hŒµ.lt).mpr (hxy y hy)
    refine
      eventually_prod_iff.mpr
        ‚ü®_, b, fun e : E => Metric.ball x r e,
          eventually_mem_set.mpr (Metric.nhds_basis_ball.mem_of_mem hr), fun {n} hn {y} hy => ?_‚ü©
    simp only [Pi.zero_apply, dist_zero_left] at e ‚ä¢
    refine lt_of_le_of_lt ?_ (hxyŒµ y hy)
    exact
      Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le
        (fun y hy => ((e hn (hr' hy)).2.1.sub (e hn (hr' hy)).2.2).hasFDerivWithinAt)
        (fun y hy => (e hn (hr' hy)).1.le) (convex_ball x r) (Metric.mem_ball_self hr) hy
  ¬∑ 
    refine Metric.tendstoUniformlyOnFilter_iff.mpr fun Œµ hŒµ => ?_
    obtain ‚ü®t, ht, ht'‚ü© := (Metric.cauchy_iff.mp hfg).2 Œµ hŒµ
    exact
      eventually_prod_iff.mpr
        ‚ü®fun n : Œπ √ó Œπ => f n.1 x ‚àà t ‚àß f n.2 x ‚àà t,
          eventually_prod_iff.mpr ‚ü®_, ht, _, ht, fun {n} hn {n'} hn' => ‚ü®hn, hn'‚ü©‚ü©,
          fun _ => True,
          by simp,
          fun {n} hn {y} _ => by simpa [norm_sub_rev, dist_eq_norm] using ht' _ hn.1 _ hn.2‚ü©"
Mathlib/CategoryTheory/Sites/SheafHom.lean,CategoryTheory.PresheafHom.IsSheafFor.exists_app,exists_app,caa00a446713ac188017c89bf0a19da029f0c735,":= by
  let c : Cone ((Presieve.diagram (Sieve.pullback g S).arrows).op ‚ãô G) :=
    { pt := F.obj (op Y)
      œÄ :=
        { app := fun ‚ü®Z, hZ‚ü© => F.map Z.hom.op ‚â´ (x _ hZ).app (op (Over.mk (ùüô _)))
          naturality := by
            rintro ‚ü®Z‚ÇÅ, hZ‚ÇÅ‚ü© ‚ü®Z‚ÇÇ, hZ‚ÇÇ‚ü© ‚ü®f : Z‚ÇÇ ‚ü∂ Z‚ÇÅ‚ü©
            dsimp
            rw [id_comp, assoc]
            have H := hx f.left (ùüô _) hZ‚ÇÅ hZ‚ÇÇ (by simp)
            simp only [internalHom_obj, unop_op, Functor.id_obj, op_id,
              FunctorToTypes.map_id_apply] at H
            let œÜ : Over.mk f.left ‚ü∂ Over.mk (ùüô Z‚ÇÅ.left) := Over.homMk f.left
            have H' := (x (Z‚ÇÅ.hom ‚â´ g) hZ‚ÇÅ).naturality œÜ.op
            dsimp at H H' ‚ä¢
            erw [‚Üê H, ‚Üê H', internalHom_map_app_op_mk_id, ‚Üê F.map_comp_assoc,
              ‚Üê op_comp, Over.w f] } }
  use (hG g).lift c
  intro Z p hp
  exact ((hG g).fac c ‚ü®Over.mk p, hp‚ü©)","error:  unknown identifier 'internalHom_obj'
error:  unknown identifier 'internalHom_map_app_op_mk_id'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.35450
case op.mk.op.mk.op
C : Type u
inst‚úù¬π : Category.{v, u} C
J : GrothendieckTopology C
A : Type u'
inst‚úù : Category.{v', u'} A
F G : C·µí·µñ ‚•§ A
X : C
S : Sieve X
hG : ‚¶ÉY : C‚¶Ñ ‚Üí (f : Y ‚ü∂ X) ‚Üí IsLimit (G.mapCone (Sieve.pullback f S).arrows.cocone.op)
x : Presieve.FamilyOfElements (presheafHom F G) S.arrows
hx : x.Compatible
Y : C
g : Y ‚ü∂ X
Z‚ÇÅ : Over Y
hZ‚ÇÅ : (Sieve.pullback g S).arrows Z‚ÇÅ.hom
Z‚ÇÇ : Over Y
hZ‚ÇÇ : (Sieve.pullback g S).arrows Z‚ÇÇ.hom
f : Z‚ÇÇ ‚ü∂ Z‚ÇÅ
H : (presheafHom F G).map f.left.op (x (Z‚ÇÅ.hom ‚â´ g) hZ‚ÇÅ) = x (Z‚ÇÇ.hom ‚â´ g) hZ‚ÇÇ
œÜ : Over.mk f.left ‚ü∂ Over.mk (ùüô Z‚ÇÅ.left) := Over.homMk f.left ‚ãØ
H' :
  F.map œÜ.left.op ‚â´ (x (Z‚ÇÅ.hom ‚â´ g) hZ‚ÇÅ).app { unop := Over.mk f.left } =
    (x (Z‚ÇÅ.hom ‚â´ g) hZ‚ÇÅ).app { unop := Over.mk (ùüô Z‚ÇÅ.left) } ‚â´ G.map œÜ.left.op
‚ä¢ F.map Z‚ÇÇ.hom.op ‚â´ ((presheafHom F G).map f.left.op (x (Z‚ÇÅ.hom ‚â´ g) hZ‚ÇÅ)).app { unop := Over.mk (ùüô Z‚ÇÇ.left) } =
    F.map Z‚ÇÅ.hom.op ‚â´ F.map œÜ.left.op ‚â´ (x (Z‚ÇÅ.hom ‚â´ g) hZ‚ÇÅ).app { unop := Over.mk f.left }","lemma exists_app :
    ‚àÉ (œÜ : F.obj (op Y) ‚ü∂ G.obj (op Y)),
      ‚àÄ {Z : C} (p : Z ‚ü∂ Y) (hp : S (p ‚â´ g)), œÜ ‚â´ G.map p.op =
        F.map p.op ‚â´ (x (p ‚â´ g) hp).app ‚ü®Over.mk (ùüô Z)‚ü© ",":= by
  let c : Cone ((Presieve.diagram (Sieve.pullback g S).arrows).op ‚ãô G) :=
    { pt := F.obj (op Y)
      œÄ :=
        { app := fun ‚ü®Z, hZ‚ü© => F.map Z.hom.op ‚â´ (x _ hZ).app (op (Over.mk (ùüô _)))
          naturality := by
            rintro ‚ü®Z‚ÇÅ, hZ‚ÇÅ‚ü© ‚ü®Z‚ÇÇ, hZ‚ÇÇ‚ü© ‚ü®f : Z‚ÇÇ ‚ü∂ Z‚ÇÅ‚ü©
            dsimp
            rw [id_comp, assoc]
            have H := hx f.left (ùüô _) hZ‚ÇÅ hZ‚ÇÇ (by simp)
            simp only [presheafHom_obj, unop_op, Functor.id_obj, op_id,
              FunctorToTypes.map_id_apply] at H
            let œÜ : Over.mk f.left ‚ü∂ Over.mk (ùüô Z‚ÇÅ.left) := Over.homMk f.left
            have H' := (x (Z‚ÇÅ.hom ‚â´ g) hZ‚ÇÅ).naturality œÜ.op
            dsimp at H H' ‚ä¢
            erw [‚Üê H, ‚Üê H', presheafHom_map_app_op_mk_id, ‚Üê F.map_comp_assoc,
              ‚Üê op_comp, Over.w f] } }
  use (hG g).lift c
  intro Z p hp
  exact ((hG g).fac c ‚ü®Over.mk p, hp‚ü©)"
Mathlib/MeasureTheory/Integral/FundThmCalculus.lean,intervalIntegral.sub_le_integral_of_hasDeriv_right_of_le,sub_le_integral_of_hasDeriv_right_of_le,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  refine' le_of_forall_pos_le_add fun Œµ Œµpos => _
  rcases exists_lt_lowerSemicontinuous_integral_lt œÜ œÜint Œµpos with
    ‚ü®G', f_lt_G', G'cont, G'int, G'lt_top, hG'‚ü©
  set s := {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} ‚à© Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, ‚à´ u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [‚Üê uIcc_of_le hab] at G'int hcont ‚ä¢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b ‚äÜ {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain ‚ü®y, g'_lt_y', y_lt_G'‚ü© : ‚àÉ y : ‚Ñù, (g' t : EReal) < y ‚àß (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hœÜg t ht.2)).trans_lt (f_lt_G' t))
    have I1 : ‚àÄ·∂† u in ùìù[>] t, (u - t) * y ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      have B : ‚àÄ·∂† u in ùìù t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with ‚ü®m, M, ‚ü®hm, hM‚ü©, H‚ü©
      have : Ioo t (min M b) ‚àà ùìù[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u ‚äÜ Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = ‚à´ _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ ‚â§ ‚à´ w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, ‚Üê integral_Icc_eq_integral_Ioc]
          apply set_integral_mono_ae_restrict
          ¬∑ simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          ¬∑ exact IntegrableOn.mono_set G'int I
          ¬∑ have C1 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), G' x < ‚àû :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), x ‚àà Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x ‚àà Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t ‚ü®ht.2.1, ht.2.2‚ü©).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [‚Üê smul_eq_mul, sub_smul_slope] at this
    have I3 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : ‚àÄ·∂† u in ùìù[>] t, u ‚àà Ioc t (min v b) := by
      refine' mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 ‚ü®min v b, _, Subset.rfl‚ü©
      simp only [lt_min_iff, mem_Ioi]
      exact ‚ü®t_lt_v, ht.2.2‚ü©
    rcases (I3.and I4).exists with ‚ü®x, hx, h'x‚ü©
    refine' ‚ü®x, _, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x‚ü©
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ ‚â§ (‚à´ w in a..t, (G' w).toReal) + ‚à´ w in t..x, (G' w).toReal := (add_le_add ht.1 hx)
      _ = ‚à´ w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        ¬∑ rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        ¬∑ rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a ‚â§ ‚à´ y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ ‚â§ (‚à´ y in a..b, œÜ y) + Œµ := by
      convert hG'.le <;>
        ¬∑ rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]","error:  simp made no progress
warning:  `MeasureTheory.set_integral_mono_ae_restrict` has been deprecated, use `MeasureTheory.setIntegral_mono_ae_restrict` instead","theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a ‚â§ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (œÜint : IntegrableOn œÜ (Icc a b)) (hœÜg : ‚àÄ x ‚àà Ico a b, g' x ‚â§ œÜ x) :
    g b - g a ‚â§ ‚à´ y in a..b, œÜ y ",":= by
  refine le_of_forall_pos_le_add fun Œµ Œµpos => ?_
  rcases exists_lt_lowerSemicontinuous_integral_lt œÜ œÜint Œµpos with
    ‚ü®G', f_lt_G', G'cont, G'int, G'lt_top, hG'‚ü©
  set s := {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} ‚à© Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, ‚à´ u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [‚Üê uIcc_of_le hab] at G'int hcont ‚ä¢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [s, inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b ‚äÜ {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain ‚ü®y, g'_lt_y', y_lt_G'‚ü© : ‚àÉ y : ‚Ñù, (g' t : EReal) < y ‚àß (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hœÜg t ht.2)).trans_lt (f_lt_G' t))
    have I1 : ‚àÄ·∂† u in ùìù[>] t, (u - t) * y ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      have B : ‚àÄ·∂† u in ùìù t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with ‚ü®m, M, ‚ü®hm, hM‚ü©, H‚ü©
      have : Ioo t (min M b) ‚àà ùìù[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u ‚äÜ Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = ‚à´ _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ ‚â§ ‚à´ w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, ‚Üê integral_Icc_eq_integral_Ioc]
          apply setIntegral_mono_ae_restrict
          ¬∑ simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          ¬∑ exact IntegrableOn.mono_set G'int I
          ¬∑ have C1 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), G' x < ‚àû :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), x ‚àà Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x ‚àà Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t ‚ü®ht.2.1, ht.2.2‚ü©).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [‚Üê smul_eq_mul, sub_smul_slope] at this
    have I3 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : ‚àÄ·∂† u in ùìù[>] t, u ‚àà Ioc t (min v b) := by
      refine mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 ‚ü®min v b, ?_, Subset.rfl‚ü©
      simp only [lt_min_iff, mem_Ioi]
      exact ‚ü®t_lt_v, ht.2.2‚ü©
    rcases (I3.and I4).exists with ‚ü®x, hx, h'x‚ü©
    refine ‚ü®x, ?_, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x‚ü©
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ ‚â§ (‚à´ w in a..t, (G' w).toReal) + ‚à´ w in t..x, (G' w).toReal := add_le_add ht.1 hx
      _ = ‚à´ w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        ¬∑ rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        ¬∑ rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a ‚â§ ‚à´ y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ ‚â§ (‚à´ y in a..b, œÜ y) + Œµ := by
      convert hG'.le <;>
        ¬∑ rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]"
Mathlib/Combinatorics/Hall/Finite.lean,HallMarriageTheorem.hall_hard_inductive_step_B,hall_hard_inductive_step_B,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  haveI := Classical.decEq Œπ
  rw [Nat.add_one] at hn
  have card_Œπ'_le : Fintype.card s ‚â§ n := by
    apply Nat.le_of_lt_succ
    calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card Œπ := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
  let t' : s ‚Üí Finset Œ± := fun x' => t x'
  rcases ih t' card_Œπ'_le (hall_cond_of_restrict ht) with ‚ü®f', hf', hsf'‚ü©
  set Œπ'' := (s : Set Œπ)·∂ú
  let t'' : Œπ'' ‚Üí Finset Œ± := fun a'' => t a'' \ s.biUnion t
  have card_Œπ''_le : Fintype.card Œπ'' ‚â§ n := by
    simp_rw [Œπ'', ‚Üê Nat.lt_succ_iff, ‚Üê hn, ‚Üê Finset.coe_compl, coe_sort_coe]
    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]
  rcases ih t'' card_Œπ''_le (hall_cond_of_compl hus ht) with ‚ü®f'', hf'', hsf''‚ü©
  have f'_mem_biUnion : ‚àÄ (x') (hx' : x' ‚àà s), f' ‚ü®x', hx'‚ü© ‚àà s.biUnion t := by
    intro x' hx'
    rw [mem_biUnion]
    exact ‚ü®x', hx', hsf' _‚ü©
  have f''_not_mem_biUnion : ‚àÄ (x'') (hx'' : ¬¨x'' ‚àà s), ¬¨f'' ‚ü®x'', hx''‚ü© ‚àà s.biUnion t := by
    intro x'' hx''
    have h := hsf'' ‚ü®x'', hx''‚ü©
    rw [mem_sdiff] at h
    exact h.2
  have im_disj :
      ‚àÄ (x' x'' : Œπ) (hx' : x' ‚àà s) (hx'' : ¬¨x'' ‚àà s), f' ‚ü®x', hx'‚ü© ‚â† f'' ‚ü®x'', hx''‚ü© := by
    intro x x' hx' hx'' h
    apply f''_not_mem_biUnion x' hx''
    rw [‚Üê h]
    apply f'_mem_biUnion x
  refine ‚ü®fun x => if h : x ‚àà s then f' ‚ü®x, h‚ü© else f'' ‚ü®x, h‚ü©, ?_, ?_‚ü©
  ¬∑ refine' hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)
  ¬∑ intro x
    simp only [of_eq_true]
    split_ifs with h
    ¬∑ exact hsf' ‚ü®x, h‚ü©
    ¬∑ exact sdiff_subset _ _ (hsf'' ‚ü®x, h‚ü©)","error:  function expected at
  sdiff_subset ?m.41056
term has type
  ?m.41055 ‚àà ?m.41053","theorem hall_hard_inductive_step_B {n : ‚Ñï} (hn : Fintype.card Œπ = n + 1)
    (ht : ‚àÄ s : Finset Œπ, s.card ‚â§ (s.biUnion t).card)
    (ih :
      ‚àÄ {Œπ' : Type u} [Fintype Œπ'] (t' : Œπ' ‚Üí Finset Œ±),
        Fintype.card Œπ' ‚â§ n ‚Üí
          (‚àÄ s' : Finset Œπ', s'.card ‚â§ (s'.biUnion t').card) ‚Üí
            ‚àÉ f : Œπ' ‚Üí Œ±, Function.Injective f ‚àß ‚àÄ x, f x ‚àà t' x)
    (s : Finset Œπ) (hs : s.Nonempty) (hns : s ‚â† univ) (hus : s.card = (s.biUnion t).card) :
    ‚àÉ f : Œπ ‚Üí Œ±, Function.Injective f ‚àß ‚àÄ x, f x ‚àà t x ",":= by
  haveI := Classical.decEq Œπ
  rw [Nat.add_one] at hn
  have card_Œπ'_le : Fintype.card s ‚â§ n := by
    apply Nat.le_of_lt_succ
    calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card Œπ := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
  let t' : s ‚Üí Finset Œ± := fun x' => t x'
  rcases ih t' card_Œπ'_le (hall_cond_of_restrict ht) with ‚ü®f', hf', hsf'‚ü©
  set Œπ'' := (s : Set Œπ)·∂ú
  let t'' : Œπ'' ‚Üí Finset Œ± := fun a'' => t a'' \ s.biUnion t
  have card_Œπ''_le : Fintype.card Œπ'' ‚â§ n := by
    simp_rw [Œπ'', ‚Üê Nat.lt_succ_iff, ‚Üê hn, ‚Üê Finset.coe_compl, coe_sort_coe]
    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]
  rcases ih t'' card_Œπ''_le (hall_cond_of_compl hus ht) with ‚ü®f'', hf'', hsf''‚ü©
  have f'_mem_biUnion : ‚àÄ (x') (hx' : x' ‚àà s), f' ‚ü®x', hx'‚ü© ‚àà s.biUnion t := by
    intro x' hx'
    rw [mem_biUnion]
    exact ‚ü®x', hx', hsf' _‚ü©
  have f''_not_mem_biUnion : ‚àÄ (x'') (hx'' : ¬¨x'' ‚àà s), ¬¨f'' ‚ü®x'', hx''‚ü© ‚àà s.biUnion t := by
    intro x'' hx''
    have h := hsf'' ‚ü®x'', hx''‚ü©
    rw [mem_sdiff] at h
    exact h.2
  have im_disj :
      ‚àÄ (x' x'' : Œπ) (hx' : x' ‚àà s) (hx'' : ¬¨x'' ‚àà s), f' ‚ü®x', hx'‚ü© ‚â† f'' ‚ü®x'', hx''‚ü© := by
    intro x x' hx' hx'' h
    apply f''_not_mem_biUnion x' hx''
    rw [‚Üê h]
    apply f'_mem_biUnion x
  refine ‚ü®fun x => if h : x ‚àà s then f' ‚ü®x, h‚ü© else f'' ‚ü®x, h‚ü©, ?_, ?_‚ü©
  ¬∑ refine hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)
  ¬∑ intro x
    simp only [of_eq_true]
    split_ifs with h
    ¬∑ exact hsf' ‚ü®x, h‚ü©
    ¬∑ exact sdiff_subset (hsf'' ‚ü®x, h‚ü©)"
Mathlib/Analysis/Normed/Group/ControlledClosure.lean,controlled_closure_of_complete,controlled_closure_of_complete,9a5e0ce9f9b714fd5383610a12746cded21f030f,":= by
  rintro (h : H) (h_in : h ‚àà K.topologicalClosure)
  by_cases hyp_h : h = 0
  ¬∑ rw [hyp_h]
    use 0
    simp
  set b : ‚Ñï ‚Üí ‚Ñù := fun i => (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
  have b_pos : ‚àÄ i, 0 < b i := by
    intro i
    field_simp [hC]
    exact
      div_pos (mul_pos hŒµ (norm_pos_iff.mpr hyp_h)) (mul_pos (by norm_num : (0 : ‚Ñù) < 2 ^ i * 2) hC)
  obtain
    ‚ü®v : ‚Ñï ‚Üí H, lim_v : Tendsto (fun n : ‚Ñï => ‚àë k in range (n + 1), v k) atTop (ùìù h), v_in :
      ‚àÄ n, v n ‚àà K, hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0, hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n‚ü© :=
    controlled_sum_of_mem_closure h_in b_pos
  have : ‚àÄ n, ‚àÉ m' : G, f m' = v n ‚àß ‚Äñm'‚Äñ ‚â§ C * ‚Äñv n‚Äñ := fun n : ‚Ñï => hyp (v n) (v_in n)
  choose u hu hnorm_u using this
  set s : ‚Ñï ‚Üí G := fun n => ‚àë k in range (n + 1), u k
  have : CauchySeq s := by
    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one
    rintro n (hn : n ‚â• 1)
    calc
      ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ := hnorm_u n
      _ ‚â§ C * b n := by rel_congr; exact (hv _ <| Nat.succ_le_iff.mp hn).le
      _ = (1 / 2) ^ n * (Œµ * ‚Äñh‚Äñ / 2) := by simp [mul_div_cancel' _ hC.ne.symm]
      _ = Œµ * ‚Äñh‚Äñ / 2 * (1 / 2) ^ n := mul_comm _ _
  obtain ‚ü®g : G, hg‚ü© := cauchySeq_tendsto_of_complete this
  refine' ‚ü®g, _, _‚ü©
  ¬∑ 
    have : f ‚àò s = fun n => ‚àë k in range (n + 1), v k := by
      ext n
      simp [map_sum, hu]
    rw [‚Üê this] at lim_v
    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v
  ¬∑ 
    suffices : ‚àÄ n, ‚Äñs n‚Äñ ‚â§ (C + Œµ) * ‚Äñh‚Äñ
    exact le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this
    intro n
    have hnorm‚ÇÄ : ‚Äñu 0‚Äñ ‚â§ C * b 0 + C * ‚Äñh‚Äñ := by
      have :=
        calc
          ‚Äñv 0‚Äñ ‚â§ ‚Äñh‚Äñ + ‚Äñv 0 - h‚Äñ := norm_le_insert' _ _
          _ ‚â§ ‚Äñh‚Äñ + b 0 := by rel_congr
      calc
        ‚Äñu 0‚Äñ ‚â§ C * ‚Äñv 0‚Äñ := hnorm_u 0
        _ ‚â§ C * (‚Äñh‚Äñ + b 0) := by rel_congr
        _ = C * b 0 + C * ‚Äñh‚Äñ := by rw [add_comm, mul_add]
    have : (‚àë k in range (n + 1), C * b k) ‚â§ Œµ * ‚Äñh‚Äñ :=
      calc
        (‚àë k in range (n + 1), C * b k) = (‚àë k in range (n + 1), (1 / 2 : ‚Ñù) ^ k) * (Œµ * ‚Äñh‚Äñ / 2) :=
          by simp only [mul_div_cancel' _ hC.ne.symm, ‚Üê sum_mul]
        _ ‚â§ 2 * (Œµ * ‚Äñh‚Äñ / 2) := by rel_congr; apply sum_geometric_two_le
        _ = Œµ * ‚Äñh‚Äñ := mul_div_cancel' _ two_ne_zero
    calc
      ‚Äñs n‚Äñ ‚â§ ‚àë k in range (n + 1), ‚Äñu k‚Äñ := norm_sum_le _ _
      _ = (‚àë k in range n, ‚Äñu (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := (sum_range_succ' _ _)
      _ ‚â§ (‚àë k in range n, C * ‚Äñv (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := by rel_congr; apply hnorm_u
      _ ‚â§ (‚àë k in range n, C * b (k + 1)) + (C * b 0 + C * ‚Äñh‚Äñ) := by
        rel_congr; rename_i k _; exact (hv _ k.succ_pos).le
      _ = (‚àë k in range (n + 1), C * b k) + C * ‚Äñh‚Äñ := by rw [‚Üê add_assoc, sum_range_succ']
      _ ‚â§ (C + Œµ) * ‚Äñh‚Äñ := by
        rw [add_comm, add_mul]
        apply add_le_add_left this","error:  unknown tactic
error:  unsolved goals
G : Type u_1
inst‚úù¬≤ : NormedAddCommGroup G
inst‚úù¬π : CompleteSpace G
H : Type u_2
inst‚úù : NormedAddCommGroup H
f : NormedAddGroupHom G H
K : AddSubgroup H
C Œµ : ‚Ñù
hC : 0 < C
hŒµ : 0 < Œµ
hyp : f.SurjectiveOnWith K C
h : H
h_in : h ‚àà K.topologicalClosure
hyp_h : ¬¨h = 0
b : ‚Ñï ‚Üí ‚Ñù := fun i ‚Ü¶ (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
b_pos : ‚àÄ (i : ‚Ñï), 0 < b i
v : ‚Ñï ‚Üí H
lim_v : Tendsto (fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h)
v_in : ‚àÄ (n : ‚Ñï), v n ‚àà K
hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0
hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n
u : ‚Ñï ‚Üí G
hu : ‚àÄ (n : ‚Ñï), f (u n) = v n
hnorm_u : ‚àÄ (n : ‚Ñï), ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ
s : ‚Ñï ‚Üí G := fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), u k
n : ‚Ñï
hn : n ‚â• 1
‚ä¢ C * ‚Äñv n‚Äñ ‚â§ C * b n
error:  unsolved goals
case calc.step
G : Type u_1
inst‚úù¬≤ : NormedAddCommGroup G
inst‚úù¬π : CompleteSpace G
H : Type u_2
inst‚úù : NormedAddCommGroup H
f : NormedAddGroupHom G H
K : AddSubgroup H
C Œµ : ‚Ñù
hC : 0 < C
hŒµ : 0 < Œµ
hyp : f.SurjectiveOnWith K C
h : H
h_in : h ‚àà K.topologicalClosure
hyp_h : ¬¨h = 0
b : ‚Ñï ‚Üí ‚Ñù := fun i ‚Ü¶ (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
b_pos : ‚àÄ (i : ‚Ñï), 0 < b i
v : ‚Ñï ‚Üí H
lim_v : Tendsto (fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h)
v_in : ‚àÄ (n : ‚Ñï), v n ‚àà K
hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0
hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n
u : ‚Ñï ‚Üí G
hu : ‚àÄ (n : ‚Ñï), f (u n) = v n
hnorm_u : ‚àÄ (n : ‚Ñï), ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ
s : ‚Ñï ‚Üí G := fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), u k
n : ‚Ñï
hn : n ‚â• 1
‚ä¢ C * b n ‚â§ ?m.9030 * (1 / 2) ^ n

G : Type u_1
inst‚úù¬≤ : NormedAddCommGroup G
inst‚úù¬π : CompleteSpace G
H : Type u_2
inst‚úù : NormedAddCommGroup H
f : NormedAddGroupHom G H
K : AddSubgroup H
C Œµ : ‚Ñù
hC : 0 < C
hŒµ : 0 < Œµ
hyp : f.SurjectiveOnWith K C
h : H
h_in : h ‚àà K.topologicalClosure
hyp_h : ¬¨h = 0
b : ‚Ñï ‚Üí ‚Ñù := fun i ‚Ü¶ (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
b_pos : ‚àÄ (i : ‚Ñï), 0 < b i
v : ‚Ñï ‚Üí H
lim_v : Tendsto (fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h)
v_in : ‚àÄ (n : ‚Ñï), v n ‚àà K
hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0
hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n
u : ‚Ñï ‚Üí G
hu : ‚àÄ (n : ‚Ñï), f (u n) = v n
hnorm_u : ‚àÄ (n : ‚Ñï), ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ
s : ‚Ñï ‚Üí G := fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), u k
‚ä¢ ‚Ñù
error:  unsolved goals
case neg.intro.intro.intro.intro
G : Type u_1
inst‚úù¬≤ : NormedAddCommGroup G
inst‚úù¬π : CompleteSpace G
H : Type u_2
inst‚úù : NormedAddCommGroup H
f : NormedAddGroupHom G H
K : AddSubgroup H
C Œµ : ‚Ñù
hC : 0 < C
hŒµ : 0 < Œµ
hyp : f.SurjectiveOnWith K C
h : H
h_in : h ‚àà K.topologicalClosure
hyp_h : ¬¨h = 0
b : ‚Ñï ‚Üí ‚Ñù := fun i ‚Ü¶ (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
b_pos : ‚àÄ (i : ‚Ñï), 0 < b i
v : ‚Ñï ‚Üí H
lim_v : Tendsto (fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h)
v_in : ‚àÄ (n : ‚Ñï), v n ‚àà K
hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0
hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n
u : ‚Ñï ‚Üí G
hu : ‚àÄ (n : ‚Ñï), f (u n) = v n
hnorm_u : ‚àÄ (n : ‚Ñï), ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ
s : ‚Ñï ‚Üí G := fun n ‚Ü¶ ‚àë k ‚àà range (n + 1), u k
this : CauchySeq s
‚ä¢ ‚àÉ g, f g = h ‚àß ‚Äñg‚Äñ ‚â§ (C + Œµ) * ‚Äñh‚Äñ","theorem controlled_closure_of_complete {f : NormedAddGroupHom G H} {K : AddSubgroup H} {C Œµ : ‚Ñù}
    (hC : 0 < C) (hŒµ : 0 < Œµ) (hyp : f.SurjectiveOnWith K C) :
    f.SurjectiveOnWith K.topologicalClosure (C + Œµ) ",":= by
  rintro (h : H) (h_in : h ‚àà K.topologicalClosure)
  by_cases hyp_h : h = 0
  ¬∑ rw [hyp_h]
    use 0
    simp
  set b : ‚Ñï ‚Üí ‚Ñù := fun i => (1 / 2) ^ i * (Œµ * ‚Äñh‚Äñ / 2) / C
  have b_pos (i) : 0 < b i := by field_simp [b, hC, hyp_h]
  obtain
    ‚ü®v : ‚Ñï ‚Üí H, lim_v : Tendsto (fun n : ‚Ñï => ‚àë k ‚àà range (n + 1), v k) atTop (ùìù h), v_in :
      ‚àÄ n, v n ‚àà K, hv‚ÇÄ : ‚Äñv 0 - h‚Äñ < b 0, hv : ‚àÄ n > 0, ‚Äñv n‚Äñ < b n‚ü© :=
    controlled_sum_of_mem_closure h_in b_pos
  have : ‚àÄ n, ‚àÉ m' : G, f m' = v n ‚àß ‚Äñm'‚Äñ ‚â§ C * ‚Äñv n‚Äñ := fun n : ‚Ñï => hyp (v n) (v_in n)
  choose u hu hnorm_u using this
  set s : ‚Ñï ‚Üí G := fun n => ‚àë k ‚àà range (n + 1), u k
  have : CauchySeq s := by
    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one
    ¬∑ rintro n (hn : n ‚â• 1)
      calc
        ‚Äñu n‚Äñ ‚â§ C * ‚Äñv n‚Äñ := hnorm_u n
        _ ‚â§ C * b n := by gcongr; exact (hv _ <| Nat.succ_le_iff.mp hn).le
        _ = (1 / 2) ^ n * (Œµ * ‚Äñh‚Äñ / 2) := by simp [mul_div_cancel‚ÇÄ _ hC.ne.symm]
        _ = Œµ * ‚Äñh‚Äñ / 2 * (1 / 2) ^ n := mul_comm _ _
  obtain ‚ü®g : G, hg‚ü© := cauchySeq_tendsto_of_complete this
  refine ‚ü®g, ?_, ?_‚ü©
  ¬∑ 
    have : f ‚àò s = fun n => ‚àë k ‚àà range (n + 1), v k := by
      ext n
      simp [s, map_sum, hu]
    rw [‚Üê this] at lim_v
    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v
  ¬∑ 
    suffices ‚àÄ n, ‚Äñs n‚Äñ ‚â§ (C + Œµ) * ‚Äñh‚Äñ from
      le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this
    intro n
    have hnorm‚ÇÄ : ‚Äñu 0‚Äñ ‚â§ C * b 0 + C * ‚Äñh‚Äñ := by
      have :=
        calc
          ‚Äñv 0‚Äñ ‚â§ ‚Äñh‚Äñ + ‚Äñv 0 - h‚Äñ := norm_le_insert' _ _
          _ ‚â§ ‚Äñh‚Äñ + b 0 := by gcongr
      calc
        ‚Äñu 0‚Äñ ‚â§ C * ‚Äñv 0‚Äñ := hnorm_u 0
        _ ‚â§ C * (‚Äñh‚Äñ + b 0) := by gcongr
        _ = C * b 0 + C * ‚Äñh‚Äñ := by rw [add_comm, mul_add]
    have : (‚àë k ‚àà range (n + 1), C * b k) ‚â§ Œµ * ‚Äñh‚Äñ :=
      calc (‚àë k ‚àà range (n + 1), C * b k)
        _ = (‚àë k ‚àà range (n + 1), (1 / 2 : ‚Ñù) ^ k) * (Œµ * ‚Äñh‚Äñ / 2) := by
          simp only [mul_div_cancel‚ÇÄ _ hC.ne.symm, ‚Üê sum_mul]
        _ ‚â§ 2 * (Œµ * ‚Äñh‚Äñ / 2) := by gcongr; apply sum_geometric_two_le
        _ = Œµ * ‚Äñh‚Äñ := mul_div_cancel‚ÇÄ _ two_ne_zero
    calc
      ‚Äñs n‚Äñ ‚â§ ‚àë k ‚àà range (n + 1), ‚Äñu k‚Äñ := norm_sum_le _ _
      _ = (‚àë k ‚àà range n, ‚Äñu (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := sum_range_succ' _ _
      _ ‚â§ (‚àë k ‚àà range n, C * ‚Äñv (k + 1)‚Äñ) + ‚Äñu 0‚Äñ := by gcongr; apply hnorm_u
      _ ‚â§ (‚àë k ‚àà range n, C * b (k + 1)) + (C * b 0 + C * ‚Äñh‚Äñ) := by
        gcongr with k; exact (hv _ k.succ_pos).le
      _ = (‚àë k ‚àà range (n + 1), C * b k) + C * ‚Äñh‚Äñ := by rw [‚Üê add_assoc, sum_range_succ']
      _ ‚â§ (C + Œµ) * ‚Äñh‚Äñ := by
        rw [add_comm, add_mul]
        apply add_le_add_left this"
Mathlib/Analysis/InnerProductSpace/l2Space.lean,lp.summable_inner,summable_inner,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine .of_norm_bounded (fun i => ‚Äñf i‚Äñ * ‚Äñg i‚Äñ) (lp.summable_mul ?_ f g)? _
  ¬∑ rw [Real.isConjExponent_iff]; norm_num
  intro i
  exact norm_inner_le_norm (ùïú := ùïú) _ _","error:  typeclass instance problem is stuck, it is often due to metavariables
  CompleteSpace ?m.5817
error:  unexpected token '?'; expected 'binder_predicate'","theorem summable_inner (f g : lp G 2) : Summable fun i => ‚ü™f i, g i‚ü´ ",":= by
  refine .of_norm_bounded (fun i => ‚Äñf i‚Äñ * ‚Äñg i‚Äñ) (lp.summable_mul ?_ f g) ?_
  ¬∑ rw [Real.isConjExponent_iff]; norm_num
  intro i
  exact norm_inner_le_norm (ùïú := ùïú) _ _"
Mathlib/Analysis/Complex/RemovableSingularity.lean,Complex.differentiableOn_compl_singleton_and_continuousAt_iff,differentiableOn_compl_singleton_and_continuousAt_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine ‚ü®?_, fun hd => ‚ü®hd.mono (diff_subset _ _), (hd.differentiableAt hs).continuousAt‚ü©‚ü©
  rintro ‚ü®hd, hc‚ü© x hx
  rcases eq_or_ne x c with (rfl | hne)
  ¬∑ refine (analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt
      ?_ hc).differentiableAt.differentiableWithinAt
    refine eventually_nhdsWithin_iff.2 ((eventually_mem_nhds.2 hs).mono fun z hz hzx => ?_)
    exact hd.differentiableAt (inter_mem hz (isOpen_ne.mem_nhds hzx))
  ¬∑ simpa only [DifferentiableWithinAt, HasFDerivWithinAt, hne.nhdsWithin_diff_singleton] using
      hd x ‚ü®hx, hne‚ü©","error:  function expected at
  diff_subset ?m.3430
term has type
  ?m.3429 ‚àà ?m.3427","theorem differentiableOn_compl_singleton_and_continuousAt_iff {f : ‚ÑÇ ‚Üí E} {s : Set ‚ÑÇ} {c : ‚ÑÇ}
    (hs : s ‚àà ùìù c) :
    DifferentiableOn ‚ÑÇ f (s \ {c}) ‚àß ContinuousAt f c ‚Üî DifferentiableOn ‚ÑÇ f s ",":= by
  refine ‚ü®?_, fun hd => ‚ü®hd.mono diff_subset, (hd.differentiableAt hs).continuousAt‚ü©‚ü©
  rintro ‚ü®hd, hc‚ü© x hx
  rcases eq_or_ne x c with (rfl | hne)
  ¬∑ refine (analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt
      ?_ hc).differentiableAt.differentiableWithinAt
    refine eventually_nhdsWithin_iff.2 ((eventually_mem_nhds.2 hs).mono fun z hz hzx => ?_)
    exact hd.differentiableAt (inter_mem hz (isOpen_ne.mem_nhds hzx))
  ¬∑ simpa only [DifferentiableWithinAt, HasFDerivWithinAt, hne.nhdsWithin_diff_singleton] using
      hd x ‚ü®hx, hne‚ü©"
Mathlib/GroupTheory/Sylow.lean,Sylow.card_normalizer_modEq_card,card_normalizer_modEq_card,bb4cd53d3a46e1a0c6139fc0c07b126817cf1b6c,":= by
  have : H.subgroupOf (normalizer H) ‚âÉ H := (subgroupOfEquivOfLe le_normalizer).toEquiv
  rw [card_eq_card_quotient_mul_card_subgroup H,
    card_eq_card_quotient_mul_card_subgroup (H.subgroupOf (normalizer H)), Fintype.card_congr this,
    hH, pow_succ']
  exact (card_quotient_normalizer_modEq_card_quotient hH).mul_right' _","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.card G
G : Type u
Œ± : Type v
Œ≤ : Type w
inst‚úù¬π : Group G
inst‚úù : Fintype G
p n : ‚Ñï
hp : Fact (Nat.Prime p)
H : Subgroup G
hH : Fintype.card ‚Ü•H = p ^ n
this : ‚Ü•(H.subgroupOf H.normalizer) ‚âÉ ‚Ü•H
‚ä¢ Fintype.card ‚Ü•H.normalizer ‚â° Fintype.card G [MOD p ^ (n + 1)]","theorem card_normalizer_modEq_card [Fintype G] {p : ‚Ñï} {n : ‚Ñï} [hp : Fact p.Prime] {H : Subgroup G}
    (hH : Fintype.card H = p ^ n) : card (normalizer H) ‚â° card G [MOD p ^ (n + 1)] ",":= by
  have : H.subgroupOf (normalizer H) ‚âÉ H := (subgroupOfEquivOfLe le_normalizer).toEquiv
  simp only [‚Üê Nat.card_eq_fintype_card] at hH ‚ä¢
  rw [card_eq_card_quotient_mul_card_subgroup H,
    card_eq_card_quotient_mul_card_subgroup (H.subgroupOf (normalizer H)), Nat.card_congr this,
    hH, pow_succ']
  simp only [Nat.card_eq_fintype_card] at hH ‚ä¢
  exact (card_quotient_normalizer_modEq_card_quotient hH).mul_right' _"
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,AffineSubspace.coe_direction_eq_vsub_set_right,coe_direction_eq_vsub_set_right,a37e82f3616d798c1103557af7187357fc3e9e42,":= by
  rw [coe_direction_eq_vsub_set ‚ü®p, hp‚ü©]
  refine' le_antisymm _ _
  ¬∑ rintro v ‚ü®p1, p2, hp1, hp2, rfl‚ü©
    exact ‚ü®p1 -·µ• p2 +·µ• p, by aesop, vadd_vsub _ _‚ü©
  ¬∑ rintro v ‚ü®p2, hp2, rfl‚ü©
    exact ‚ü®p2, p, hp2, hp, rfl‚ü©","error:  application type mismatch
  p1 -·µ• p2
argument
  p2
has type
  p1 ‚àà ‚Üës : Prop
but is expected to have type
  P : Type u_3
warning:  aesop: failed to prove the goal after exhaustive search.
error:  unsolved goals
k : Type u_1
V : Type u_2
P : Type u_3
inst : Ring k
inst_1 : AddCommGroup V
inst_2 : Module k V
inst_3 : AffineSpace V P
s : AffineSubspace k P
p : P
hp : p ‚àà s
p1 hp1 : P
p2 : p1 ‚àà s
hp2 : hp1 ‚àà s
‚ä¢ p1 -·µ• sorryAx P true +·µ• p ‚àà s
error:  application type mismatch
  And.intro p
argument
  p
has type
  P : Type u_3
but is expected to have type
  p2 ‚àà ‚Üës : Prop
error:  application type mismatch
  Exists.intro hp2
argument
  hp2
has type
  p2 ‚àà ‚Üës : Prop
but is expected to have type
  P : Type u_3
warning:  @AffineSubspace.Parallel does not have a doc string","theorem coe_direction_eq_vsub_set_right {s : AffineSubspace k P} {p : P} (hp : p ‚àà s) :
    (s.direction : Set V) = (¬∑ -·µ• p) '' s ",":= by
  rw [coe_direction_eq_vsub_set ‚ü®p, hp‚ü©]
  refine le_antisymm ?_ ?_
  ¬∑ rintro v ‚ü®p1, hp1, p2, hp2, rfl‚ü©
    exact ‚ü®p1 -·µ• p2 +·µ• p, vadd_mem_of_mem_direction (vsub_mem_direction hp1 hp2) hp, vadd_vsub _ _‚ü©
  ¬∑ rintro v ‚ü®p2, hp2, rfl‚ü©
    exact ‚ü®p2, hp2, p, hp, rfl‚ü©"
Mathlib/Analysis/Complex/PhragmenLindelof.lean,PhragmenLindelof.horizontal_strip,horizontal_strip,8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85,":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm
  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb
  wlog hC‚ÇÄ : 0 < C generalizing C
  ¬∑ refine le_of_forall_le_of_dense fun C' hC' => this (fun w hw => ?_) (fun w hw => ?_?) _
    ¬∑ exact (hle_a _ hw).trans hC'.le
    ¬∑ exact (hle_b _ hw).trans hC'.le
    ¬∑ refine ((norm_nonneg (f (a * I))).trans (hle_a _ ?_)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=
    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB
  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with ‚ü®c, hc, B, hO‚ü©
  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)
  have hb' : d * b < œÄ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)
  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))
  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C by
    refine le_of_tendsto (Tendsto.mono_left ?_ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ
  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :
    ‚àÉ Œ¥ : ‚Ñù,
      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by
    refine
      ‚ü®Œµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Œµ‚ÇÄ
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),
        fun w hw => ?_‚ü©
    replace hw : |im (aff w)| ‚â§ d * b := by
      rw [‚Üê Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,
        mul_le_mul_left hd‚ÇÄ]
    simpa only [aff, re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le
  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by
    refine fun w hw => (hŒ¥ <| hw.by_cases ?_ ?_).trans (Real.exp_le_one_iff.2 ?_)
    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]
  obtain ‚ü®R, hzR, hR‚ü© :
    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by
    refine ((eventually_gt_atTop _).and ?_).exists
    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,
      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0) by
      filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him
      calc
        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ ‚â§ C := hR
      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine Real.tendsto_exp_atBot.comp ?_
    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine Tendsto.atBot_add ?_ tendsto_const_nhds
      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id
    refine tendsto_const_nhds.add (tendsto_const_nhds.mul ?_)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable ‚ÑÇ (g Œµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono (inter_subset_right _ _)
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw
    by_cases him : w.im = a - b ‚à® w.im = a + b
    ¬∑ rw [norm_smul, ‚Üê one_mul C]
      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b) := hw.resolve_left fun h ‚Ü¶ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'
      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)
  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]
    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©","error:  don't know how to synthesize placeholder for argument 'hC‚ÇÄ'
context:
E : Type u_1
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚ÑÇ E
a b C : ‚Ñù
f g : ‚ÑÇ ‚Üí E
z : ‚ÑÇ
hfd : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo a b)
hB :
  ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo a b)] fun z ‚Ü¶ expR (B * expR (c * |z.re|))
hle_a : ‚àÄ (z : ‚ÑÇ), z.im = a ‚Üí ‚Äñf z‚Äñ ‚â§ C
hle_b : ‚àÄ (z : ‚ÑÇ), z.im = b ‚Üí ‚Äñf z‚Äñ ‚â§ C
hza : a < z.im
hzb : z.im < b
this : ‚àÄ {C : ‚Ñù}, (‚àÄ (z : ‚ÑÇ), z.im = a ‚Üí ‚Äñf z‚Äñ ‚â§ C) ‚Üí (‚àÄ (z : ‚ÑÇ), z.im = b ‚Üí ‚Äñf z‚Äñ ‚â§ C) ‚Üí 0 < C ‚Üí ‚Äñf z‚Äñ ‚â§ C
hC‚ÇÄ : ¬¨0 < C
C' : ‚Ñù
hC' : C < C'
‚ä¢ 0 < C'
error:  function expected at
  inter_subset_right ?m.85511
term has type
  ?m.85510 ‚àà ?m.85509","theorem horizontal_strip (hfd : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo a b))
    (hB : ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo a b)]
      fun z ‚Ü¶ expR (B * expR (c * |z.re|)))
    (hle_a : ‚àÄ z : ‚ÑÇ, im z = a ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hle_b : ‚àÄ z, im z = b ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hza : a ‚â§ im z)
    (hzb : im z ‚â§ b) : ‚Äñf z‚Äñ ‚â§ C ",":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm
  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb
  wlog hC‚ÇÄ : 0 < C generalizing C
  ¬∑ refine le_of_forall_le_of_dense fun C' hC' => this (fun w hw => ?_) (fun w hw => ?_) ?_
    ¬∑ exact (hle_a _ hw).trans hC'.le
    ¬∑ exact (hle_b _ hw).trans hC'.le
    ¬∑ refine ((norm_nonneg (f (a * I))).trans (hle_a _ ?_)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=
    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB
  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with ‚ü®c, hc, B, hO‚ü©
  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)
  have hb' : d * b < œÄ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)
  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))
  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C by
    refine le_of_tendsto (Tendsto.mono_left ?_ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ
  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :
    ‚àÉ Œ¥ : ‚Ñù,
      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by
    refine
      ‚ü®Œµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Œµ‚ÇÄ
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),
        fun w hw => ?_‚ü©
    replace hw : |im (aff w)| ‚â§ d * b := by
      rw [‚Üê Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,
        mul_le_mul_left hd‚ÇÄ]
    simpa only [aff, re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le
  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by
    refine fun w hw => (hŒ¥ <| hw.by_cases ?_ ?_).trans (Real.exp_le_one_iff.2 ?_)
    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]
  obtain ‚ü®R, hzR, hR‚ü© :
    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by
    refine ((eventually_gt_atTop _).and ?_).exists
    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,
      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0) by
      filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him
      calc
        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ ‚â§ C := hR
      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine Real.tendsto_exp_atBot.comp ?_
    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine Tendsto.atBot_add ?_ tendsto_const_nhds
      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id
    refine tendsto_const_nhds.add (tendsto_const_nhds.mul ?_)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable ‚ÑÇ (g Œµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono inter_subset_right
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw
    by_cases him : w.im = a - b ‚à® w.im = a + b
    ¬∑ rw [norm_smul, ‚Üê one_mul C]
      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b) := hw.resolve_left fun h ‚Ü¶ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'
      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)
  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]
    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©"
Mathlib/SetTheory/Cardinal/Divisibility.lean,Cardinal.nat_is_prime_iff,nat_is_prime_iff,9b5d788d575748c82ffdfc08ef4aaf0a3c6023f0,":= by
  simp only [Prime, Nat.prime_iff]
  refine and_congr (by simp) (and_congr ?_ ‚ü®fun h b c hbc => ?_, fun h b c hbc => ?_‚ü©)
  ¬∑ simp only [isUnit_iff, Nat.isUnit_iff]
    exact mod_cast Iff.rfl
  ¬∑ exact mod_cast h b c (mod_cast hbc)
  cases' lt_or_le (b * c) ‚Ñµ‚ÇÄ with h' h'
  ¬∑ rcases mul_lt_aleph0_iff.mp h' with (rfl | rfl | ‚ü®hb, hc‚ü©)
    ¬∑ simp
    ¬∑ simp
    lift b to ‚Ñï using hb
    lift c to ‚Ñï using hc
    exact mod_cast h b c (mod_cast hbc)
  rcases aleph0_le_mul_iff.mp h' with ‚ü®hb, hc, h‚Ñµ‚ÇÄ‚ü©
  have hn : (n : Cardinal) ‚â† 0 := by
    intro h
    rw [h, zero_dvd_iff, mul_eq_zero] at hbc
    cases hbc <;> contradiction
  wlog h‚Ñµ‚ÇÄb : ‚Ñµ‚ÇÄ ‚â§ b
  refine (this h c b ?_ ?_ hc hb h‚Ñµ‚ÇÄ.symm hn (h‚Ñµ‚ÇÄ.resolve_left h‚Ñµ‚ÇÄb)).symm <;> try assumption
  ¬∑ rwa [mul_comm] at hbc
  ¬∑ rwa [mul_comm] at h'
  ¬∑ exact Or.inl (dvd_of_le_of_aleph0_le hn ((nat_lt_aleph0 n).le.trans h‚Ñµ‚ÇÄb) h‚Ñµ‚ÇÄb)","error:  don't know how to synthesize implicit argument 'm'
  @this ?m.21864 ?m.21865 n ?m.21867 h c b ?m.21881 ?m.21882 hc hb (Or.symm h‚Ñµ‚ÇÄ) hn (Or.resolve_left h‚Ñµ‚ÇÄ h‚Ñµ‚ÇÄb)
context:
a b‚úù : Cardinal.{u}
n m : ‚Ñï
h : ‚àÄ (a b : ‚Ñï), n ‚à£ a * b ‚Üí n ‚à£ a ‚à® n ‚à£ b
b c : Cardinal.{u_1}
hbc : ‚Üën ‚à£ b * c
h' : ‚Ñµ‚ÇÄ ‚â§ b * c
hb : b ‚â† 0
hc : c ‚â† 0
h‚Ñµ‚ÇÄ : ‚Ñµ‚ÇÄ ‚â§ b ‚à® ‚Ñµ‚ÇÄ ‚â§ c
hn : ‚Üën ‚â† 0
this :
  ‚àÄ {a b : Cardinal.{u}} {n : ‚Ñï} {m : ‚Ñï},
    (‚àÄ (a b : ‚Ñï), n ‚à£ a * b ‚Üí n ‚à£ a ‚à® n ‚à£ b) ‚Üí
      ‚àÄ (b c : Cardinal.{u_1}),
        ‚Üën ‚à£ b * c ‚Üí ‚Ñµ‚ÇÄ ‚â§ b * c ‚Üí b ‚â† 0 ‚Üí c ‚â† 0 ‚Üí ‚Ñµ‚ÇÄ ‚â§ b ‚à® ‚Ñµ‚ÇÄ ‚â§ c ‚Üí ‚Üën ‚â† 0 ‚Üí ‚Ñµ‚ÇÄ ‚â§ b ‚Üí ‚Üën ‚à£ b ‚à® ‚Üën ‚à£ c
h‚Ñµ‚ÇÄb : ¬¨‚Ñµ‚ÇÄ ‚â§ b
‚ä¢ ‚Ñï
error:  don't know how to synthesize implicit argument 'b'
  @this ?m.21864 ?m.21865 n ?m.21867 h c b ?m.21881 ?m.21882 hc hb (Or.symm h‚Ñµ‚ÇÄ) hn (Or.resolve_left h‚Ñµ‚ÇÄ h‚Ñµ‚ÇÄb)
context:
a b‚úù : Cardinal.{u}
n m : ‚Ñï
h : ‚àÄ (a b : ‚Ñï), n ‚à£ a * b ‚Üí n ‚à£ a ‚à® n ‚à£ b
b c : Cardinal.{u_1}
hbc : ‚Üën ‚à£ b * c
h' : ‚Ñµ‚ÇÄ ‚â§ b * c
hb : b ‚â† 0
hc : c ‚â† 0
h‚Ñµ‚ÇÄ : ‚Ñµ‚ÇÄ ‚â§ b ‚à® ‚Ñµ‚ÇÄ ‚â§ c
hn : ‚Üën ‚â† 0
this :
  ‚àÄ {a b : Cardinal.{u}} {n : ‚Ñï} {m : ‚Ñï},
    (‚àÄ (a b : ‚Ñï), n ‚à£ a * b ‚Üí n ‚à£ a ‚à® n ‚à£ b) ‚Üí
      ‚àÄ (b c : Cardinal.{u_1}),
        ‚Üën ‚à£ b * c ‚Üí ‚Ñµ‚ÇÄ ‚â§ b * c ‚Üí b ‚â† 0 ‚Üí c ‚â† 0 ‚Üí ‚Ñµ‚ÇÄ ‚â§ b ‚à® ‚Ñµ‚ÇÄ ‚â§ c ‚Üí ‚Üën ‚â† 0 ‚Üí ‚Ñµ‚ÇÄ ‚â§ b ‚Üí ‚Üën ‚à£ b ‚à® ‚Üën ‚à£ c
h‚Ñµ‚ÇÄb : ¬¨‚Ñµ‚ÇÄ ‚â§ b
‚ä¢ Cardinal.{u}
error:  don't know how to synthesize implicit argument 'a'
  @this ?m.21864 ?m.21865 n ?m.21867 h c b ?m.21881 ?m.21882 hc hb (Or.symm h‚Ñµ‚ÇÄ) hn (Or.resolve_left h‚Ñµ‚ÇÄ h‚Ñµ‚ÇÄb)
context:
a b‚úù : Cardinal.{u}
n m : ‚Ñï
h : ‚àÄ (a b : ‚Ñï), n ‚à£ a * b ‚Üí n ‚à£ a ‚à® n ‚à£ b
b c : Cardinal.{u_1}
hbc : ‚Üën ‚à£ b * c
h' : ‚Ñµ‚ÇÄ ‚â§ b * c
hb : b ‚â† 0
hc : c ‚â† 0
h‚Ñµ‚ÇÄ : ‚Ñµ‚ÇÄ ‚â§ b ‚à® ‚Ñµ‚ÇÄ ‚â§ c
hn : ‚Üën ‚â† 0
this :
  ‚àÄ {a b : Cardinal.{u}} {n : ‚Ñï} {m : ‚Ñï},
    (‚àÄ (a b : ‚Ñï), n ‚à£ a * b ‚Üí n ‚à£ a ‚à® n ‚à£ b) ‚Üí
      ‚àÄ (b c : Cardinal.{u_1}),
        ‚Üën ‚à£ b * c ‚Üí ‚Ñµ‚ÇÄ ‚â§ b * c ‚Üí b ‚â† 0 ‚Üí c ‚â† 0 ‚Üí ‚Ñµ‚ÇÄ ‚â§ b ‚à® ‚Ñµ‚ÇÄ ‚â§ c ‚Üí ‚Üën ‚â† 0 ‚Üí ‚Ñµ‚ÇÄ ‚â§ b ‚Üí ‚Üën ‚à£ b ‚à® ‚Üën ‚à£ c
h‚Ñµ‚ÇÄb : ¬¨‚Ñµ‚ÇÄ ‚â§ b
‚ä¢ Cardinal.{u}
error:  unsolved goals
case refine_3.inr.intro.intro.inr
a b‚úù : Cardinal.{u}
n m : ‚Ñï
h : ‚àÄ (a b : ‚Ñï), n ‚à£ a * b ‚Üí n ‚à£ a ‚à® n ‚à£ b
b c : Cardinal.{u_1}
hbc : ‚Üën ‚à£ b * c
h' : ‚Ñµ‚ÇÄ ‚â§ b * c
hb : b ‚â† 0
hc : c ‚â† 0
h‚Ñµ‚ÇÄ : ‚Ñµ‚ÇÄ ‚â§ b ‚à® ‚Ñµ‚ÇÄ ‚â§ c
hn : ‚Üën ‚â† 0
this :
  ‚àÄ {a b : Cardinal.{u}} {n : ‚Ñï} {m : ‚Ñï},
    (‚àÄ (a b : ‚Ñï), n ‚à£ a * b ‚Üí n ‚à£ a ‚à® n ‚à£ b) ‚Üí
      ‚àÄ (b c : Cardinal.{u_1}),
        ‚Üën ‚à£ b * c ‚Üí ‚Ñµ‚ÇÄ ‚â§ b * c ‚Üí b ‚â† 0 ‚Üí c ‚â† 0 ‚Üí ‚Ñµ‚ÇÄ ‚â§ b ‚à® ‚Ñµ‚ÇÄ ‚â§ c ‚Üí ‚Üën ‚â† 0 ‚Üí ‚Ñµ‚ÇÄ ‚â§ b ‚Üí ‚Üën ‚à£ b ‚à® ‚Üën ‚à£ c
h‚Ñµ‚ÇÄb : ¬¨‚Ñµ‚ÇÄ ‚â§ b
‚ä¢ ‚Üën ‚à£ b ‚à® ‚Üën ‚à£ c",theorem nat_is_prime_iff : Prime (n : Cardinal) ‚Üî n.Prime ,":= by
  simp only [Prime, Nat.prime_iff]
  refine and_congr (by simp) (and_congr ?_ ‚ü®fun h b c hbc => ?_, fun h b c hbc => ?_‚ü©)
  ¬∑ simp only [isUnit_iff, Nat.isUnit_iff]
    exact mod_cast Iff.rfl
  ¬∑ exact mod_cast h b c (mod_cast hbc)
  cases' lt_or_le (b * c) ‚Ñµ‚ÇÄ with h' h'
  ¬∑ rcases mul_lt_aleph0_iff.mp h' with (rfl | rfl | ‚ü®hb, hc‚ü©)
    ¬∑ simp
    ¬∑ simp
    lift b to ‚Ñï using hb
    lift c to ‚Ñï using hc
    exact mod_cast h b c (mod_cast hbc)
  rcases aleph0_le_mul_iff.mp h' with ‚ü®hb, hc, h‚Ñµ‚ÇÄ‚ü©
  have hn : (n : Cardinal) ‚â† 0 := by
    intro h
    rw [h, zero_dvd_iff, mul_eq_zero] at hbc
    cases hbc <;> contradiction
  wlog h‚Ñµ‚ÇÄb : ‚Ñµ‚ÇÄ ‚â§ b
  apply (this h c b _ _ hc hb h‚Ñµ‚ÇÄ.symm hn (h‚Ñµ‚ÇÄ.resolve_left h‚Ñµ‚ÇÄb)).symm <;> try assumption
  ¬∑ rwa [mul_comm] at hbc
  ¬∑ rwa [mul_comm] at h'
  ¬∑ exact Or.inl (dvd_of_le_of_aleph0_le hn ((nat_lt_aleph0 n).le.trans h‚Ñµ‚ÇÄb) h‚Ñµ‚ÇÄb)"
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.leftInvSeq_concat,leftInvSeq_concat,b0663dabc91d2626cefc80c8db6537ea3fe88347,":= by
  induction' œâ with j œâ ih
  ¬∑ simp
  ¬∑ dsimp [leftInvSeq]
    rw [ih]
    simp only [concat_eq_append, map_append, map_cons, _root_.map_mul, MulAut.conj_apply,
      simple_inv, map_inv, mul_inv_rev, map_nil, wordProd_cons, cons_append, cons.injEq,
      append_cancel_left_eq, and_true, true_and]
    group
    simp [mul_assoc]","error:  unknown identifier 'simple_inv'
error:  no goals to be solved","theorem leftInvSeq_concat (œâ : List B) (i : B) :
    lis (œâ.concat i) = (lis œâ).concat ((œÄ œâ) * (s i) * (œÄ œâ)‚Åª¬π) ",":= by
  simp [leftInvSeq_eq_reverse_rightInvSeq_reverse, rightInvSeq]"
Mathlib/Data/Seq/Computation.lean,Computation.bind_pure',bind_pure',3c930599229893e1b6a931304cf4efff4a01b172,":= by
  apply eq_of_bisim fun c‚ÇÅ c‚ÇÇ => c‚ÇÅ = c‚ÇÇ ‚à® ‚àÉ s, c‚ÇÅ = bind s pure ‚àß c‚ÇÇ = s
  ¬∑ intro c‚ÇÅ c‚ÇÇ h
    exact
      match c‚ÇÅ, c‚ÇÇ, h with
      | _, c‚ÇÇ, Or.inl (Eq.refl _) => by cases' dest c‚ÇÇ with b cb <;> simp
      | _, _, Or.inr ‚ü®s, rfl, rfl‚ü© => by
        induction' s using recOn' with _ s <;> simp
  ¬∑ exact Or.inr ‚ü®s, rfl, rfl‚ü©","error:  unknown identifier 'dest'
error:  tactic 'induction' failed, major premise type is not an inductive type 
  ?m.30274
Œ± : Type u
Œ≤ : Type v
Œ≥ : Type w
s c‚ÇÅ c‚ÇÇ‚úù : Computation Œ±
h : c‚ÇÅ = c‚ÇÇ‚úù ‚à® ‚àÉ s, c‚ÇÅ = s.bind pure ‚àß c‚ÇÇ‚úù = s
c‚ÇÇ : Computation Œ±
x‚úù : ?m.30274
‚ä¢ BisimO (fun c‚ÇÅ c‚ÇÇ ‚Ü¶ c‚ÇÅ = c‚ÇÇ ‚à® ‚àÉ s, c‚ÇÅ = s.bind pure ‚àß c‚ÇÇ = s) c‚ÇÇ.destruct c‚ÇÇ.destruct
error:  unknown identifier 'recOn''",theorem bind_pure' (s : Computation Œ±) : bind s pure = s ,":= by
  apply eq_of_bisim fun c‚ÇÅ c‚ÇÇ => c‚ÇÅ = c‚ÇÇ ‚à® ‚àÉ s, c‚ÇÅ = bind s pure ‚àß c‚ÇÇ = s
  ¬∑ intro c‚ÇÅ c‚ÇÇ h
    match c‚ÇÅ, c‚ÇÇ, h with
    | _, c‚ÇÇ, Or.inl (Eq.refl _) => cases' destruct c‚ÇÇ with b cb <;> simp
    | _, _, Or.inr ‚ü®s, rfl, rfl‚ü© =>
      apply recOn s <;> intro s <;> simp
  ¬∑ exact Or.inr ‚ü®s, rfl, rfl‚ü©"
Mathlib/FieldTheory/NormalClosure.lean,IntermediateField.le_normalClosure,le_normalClosure,2ac7d87c221020b247729b180bbe2575cceb0700,:=,error:  unexpected token 'lemma'; expected term,lemma le_normalClosure : K ‚â§ normalClosure F K L ,":=
  K.fieldRange_val.symm.trans_le K.val.fieldRange_le_normalClosure"
Mathlib/Analysis/Complex/PhragmenLindelof.lean,PhragmenLindelof.horizontal_strip,horizontal_strip,19ff60fc90e5b1bc6eb222816f5a2f27c483b994,":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm
  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb
  wlog hC‚ÇÄ : 0 < C generalizing C
  ¬∑ refine' le_of_forall_le_of_dense fun C' hC' => this (fun w hw => _) (fun w hw => _) _
    ¬∑ exact (hle_a _ hw).trans hC'.le
    ¬∑ exact (hle_b _ hw).trans hC'.le
    ¬∑ refine' ((norm_nonneg (f (a * I))).trans (hle_a _ _)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=
    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB
  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with ‚ü®c, hc, B, hO‚ü©
  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)
  have hb' : d * b < œÄ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)
  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))
  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C by
    refine le_of_tendsto (Tendsto.mono_left ?_ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ
  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :
    ‚àÉ Œ¥ : ‚Ñù,
      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by
    refine'
      ‚ü®Œµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Œµ‚ÇÄ
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),
        fun w hw => _‚ü©
    replace hw : |im (aff w)| ‚â§ d * b := by
      rw [‚Üê Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,
        mul_le_mul_left hd‚ÇÄ]
    simpa only [aff, re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le
  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by
    refine' fun w hw => (hŒ¥ <| hw.by_cases _ _).trans (Real.exp_le_one_iff.2 _)
    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]
  obtain ‚ü®R, hzR, hR‚ü© :
    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by
    refine' ((eventually_gt_atTop _).and _).exists
    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,
      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0) by
      filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him
      calc
        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ ‚â§ C := hR
      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine Real.tendsto_exp_atBot.comp ?_
    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine Tendsto.atBot_add ?_ tendsto_const_nhds
      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id
    refine tendsto_const_nhds.add (tendsto_const_nhds.mul ?_)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable ‚ÑÇ (g Œµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono (inter_subset_right _ _)
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw
    by_cases him : w.im = a - b ‚à® w.im = a + b
    ¬∑ rw [norm_smul, ‚Üê one_mul C]
      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b) := hw.resolve_left fun h ‚Ü¶ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'
      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)
  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]
    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©","error:  function expected at
  inter_subset_right ?m.85889
term has type
  ?m.85888 ‚àà ?m.85887","theorem horizontal_strip (hfd : DiffContOnCl ‚ÑÇ f (im ‚Åª¬π' Ioo a b))
    (hB : ‚àÉ c < œÄ / (b - a), ‚àÉ B, f =O[comap (_root_.abs ‚àò re) atTop ‚äì ùìü (im ‚Åª¬π' Ioo a b)]
      fun z ‚Ü¶ expR (B * expR (c * |z.re|)))
    (hle_a : ‚àÄ z : ‚ÑÇ, im z = a ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hle_b : ‚àÄ z, im z = b ‚Üí ‚Äñf z‚Äñ ‚â§ C) (hza : a ‚â§ im z)
    (hzb : im z ‚â§ b) : ‚Äñf z‚Äñ ‚â§ C ",":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; ¬∑ exact hle_a _ hza.symm
  cases' hzb with hzb hzb; ¬∑ exact hle_b _ hzb
  wlog hC‚ÇÄ : 0 < C generalizing C
  ¬∑ refine le_of_forall_le_of_dense fun C' hC' => this (fun w hw => ?_) (fun w hw => ?_) ?_
    ¬∑ exact (hle_a _ hw).trans hC'.le
    ¬∑ exact (hle_b _ hw).trans hC'.le
    ¬∑ refine ((norm_nonneg (f (a * I))).trans (hle_a _ ?_)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain ‚ü®a, b, rfl, rfl‚ü© : ‚àÉ a' b', a = a' - b' ‚àß b = a' + b' :=
    ‚ü®(a + b) / 2, (b - a) / 2, by ring, by ring‚ü©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, ‚Üê two_mul, div_mul_eq_div_div] at hB
  have hœÄb : 0 < œÄ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with ‚ü®c, hc, B, hO‚ü©
  obtain ‚ü®d, ‚ü®hcd, hd‚ÇÄ‚ü©, hd‚ü© : ‚àÉ d, (c < d ‚àß 0 < d) ‚àß d < œÄ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hœÄb)
  have hb' : d * b < œÄ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : ‚ÑÇ ‚Üí ‚ÑÇ)
  set g := fun (Œµ : ‚Ñù) (w : ‚ÑÇ) => exp (Œµ * (exp (aff w) + exp (-aff w)))
  suffices ‚àÄ·∂† Œµ : ‚Ñù in ùìù[<] (0 : ‚Ñù), ‚Äñg Œµ z ‚Ä¢ f z‚Äñ ‚â§ C by
    refine le_of_tendsto (Tendsto.mono_left ?_ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ‚ÇÄ; change Œµ < 0 at Œµ‚ÇÄ
  obtain ‚ü®Œ¥, Œ¥‚ÇÄ, hŒ¥‚ü© :
    ‚àÉ Œ¥ : ‚Ñù,
      Œ¥ < 0 ‚àß ‚àÄ ‚¶Éw‚¶Ñ, im w ‚àà Icc (a - b) (a + b) ‚Üí abs (g Œµ w) ‚â§ expR (Œ¥ * expR (d * |re w|)) := by
    refine
      ‚ü®Œµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Œµ‚ÇÄ
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hd‚ÇÄ hb)).symm ‚ñ∏ hb'),
        fun w hw => ?_‚ü©
    replace hw : |im (aff w)| ‚â§ d * b := by
      rw [‚Üê Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hd‚ÇÄ,
        mul_le_mul_left hd‚ÇÄ]
    simpa only [aff, re_ofReal_mul, _root_.abs_mul, abs_of_pos hd‚ÇÄ, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Œµ‚ÇÄ.le hw hb'.le
  have hg‚ÇÅ : ‚àÄ w, im w = a - b ‚à® im w = a + b ‚Üí abs (g Œµ w) ‚â§ 1 := by
    refine fun w hw => (hŒ¥ <| hw.by_cases ?_ ?_).trans (Real.exp_le_one_iff.2 ?_)
    exacts [fun h => h.symm ‚ñ∏ left_mem_Icc.2 hab.le, fun h => h.symm ‚ñ∏ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Œ¥‚ÇÄ.le (Real.exp_pos _).le]
  obtain ‚ü®R, hzR, hR‚ü© :
    ‚àÉ R : ‚Ñù, |z.re| < R ‚àß ‚àÄ w, |re w| = R ‚Üí im w ‚àà Ioo (a - b) (a + b) ‚Üí ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ C := by
    refine ((eventually_gt_atTop _).and ?_).exists
    rcases hO.exists_pos with ‚ü®A, hA‚ÇÄ, hA‚ü©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, ‚Üê abs_lt,
      mem_preimage, (¬∑ ‚àò ¬∑), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ùìù 0) by
      filter_upwards [this.eventually (ge_mem_nhds hC‚ÇÄ), hA] with R hR Hle w hre him
      calc
        ‚Äñg Œµ w ‚Ä¢ f w‚Äñ ‚â§ expR (Œ¥ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ ‚â§ C := hR
      rw [norm_smul, Real.exp_add, ‚Üê hre, Real.exp_add, Real.exp_log hA‚ÇÄ, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hŒ¥ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine Real.tendsto_exp_atBot.comp ?_
    suffices H : Tendsto (fun R => Œ¥ + B * (expR ((d - c) * R))‚Åª¬π) atTop (ùìù (Œ¥ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine Tendsto.atBot_add ?_ tendsto_const_nhds
      simpa only [id, (¬∑ ‚àò ¬∑), add_mul, mul_assoc, ‚Üê div_eq_inv_mul, ‚Üê Real.exp_sub, ‚Üê sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Œ¥‚ÇÄ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hd‚ÇÄ tendsto_id
    refine tendsto_const_nhds.add (tendsto_const_nhds.mul ?_)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hR‚ÇÄ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable ‚ÑÇ (g Œµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl ‚ÑÇ (fun w => g Œµ w ‚Ä¢ f w) (Ioo (-R) R √ó‚ÑÇ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono inter_subset_right
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  ¬∑ rw [frontier_reProdIm, closure_Ioo (neg_lt_self hR‚ÇÄ).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hR‚ÇÄ)] at hw
    by_cases him : w.im = a - b ‚à® w.im = a + b
    ¬∑ rw [norm_smul, ‚Üê one_mul C]
      exact mul_le_mul (hg‚ÇÅ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    ¬∑ replace hw : w ‚àà {-R, R} √ó‚ÑÇ Icc (a - b) (a + b) := hw.resolve_left fun h ‚Ü¶ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [‚Üê or_assoc] at hw'
      exact hR _ ((abs_eq hR‚ÇÄ.le).2 hw.1.symm) (hw'.resolve_left him)
  ¬∑ rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hR‚ÇÄ).ne]
    exact ‚ü®abs_le.1 hzR.le, ‚ü®hza.le, hzb.le‚ü©‚ü©"
Mathlib/Data/List/Join.lean,List.eq_iff_join_eq,eq_iff_join_eq,1ab122267c20bd3edfcd7569e8751657b42d6221,":= by
  refine' ‚ü®fun H => by simp [H], _‚ü©
  rintro ‚ü®join_eq, length_eq‚ü©
  apply ext_get
  ¬∑ have : length (map length L) = length (map length L') := by rw [length_eq]
    simpa using this
  ¬∑ intro n h‚ÇÅ h‚ÇÇ
    rw [‚Üê drop_take_succ_join_eq_get, ‚Üê drop_take_succ_join_eq_get, join_eq, length_eq]","warning:  `List.nthLe` has been deprecated, use `List.get` instead
error:  unknown identifier 'drop_take_succ_join_eq_get'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.8753
case intro.h
Œ± : Type u_1
Œ≤ : Type u_2
L L' : List (List Œ±)
join_eq : L.join = L'.join
length_eq : map length L = map length L'
n : ‚Ñï
h‚ÇÅ : n < L.length
h‚ÇÇ : n < L'.length
‚ä¢ L.get ‚ü®n, h‚ÇÅ‚ü© = L'.get ‚ü®n, h‚ÇÇ‚ü©","theorem eq_iff_join_eq (L L' : List (List Œ±)) :
    L = L' ‚Üî L.join = L'.join ‚àß map length L = map length L' ",":= by
  refine ‚ü®fun H => by simp [H], ?_‚ü©
  rintro ‚ü®join_eq, length_eq‚ü©
  apply ext_getElem
  ¬∑ have : length (map length L) = length (map length L') := by rw [length_eq]
    simpa using this
  ¬∑ intro n h‚ÇÅ h‚ÇÇ
    rw [‚Üê drop_take_succ_join_eq_getElem', ‚Üê drop_take_succ_join_eq_getElem', join_eq, length_eq]"
Mathlib/Data/List/Infix.lean,List.map_reverse_inits,map_reverse_inits,10294a2e3306ccd731ec7cbd6a95830a83a9ff94,":= by
  rw [inits_eq_tails l]
  simp [reverse_involutive.comp_self, reverse_map]","warning:  `List.reverse_map` has been deprecated, use `List.map_reverse` instead
error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead",theorem map_reverse_inits (l : List Œ±) : map reverse l.inits = (reverse <| tails <| reverse l) ,":= by
  rw [inits_eq_tails l]
  simp [reverse_involutive.comp_self, ‚Üê map_reverse]"
Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean,Sbtw.angle‚ÇÅ‚ÇÇ‚ÇÉ_eq_pi,_root_.Sbtw.angle‚ÇÅ‚ÇÇ‚ÇÉ_eq_pi,20f7b16a2188446119159f1899fa98e635e7c11d,":= by
  rw [angle, angle_eq_pi_iff]
  rcases h with ‚ü®‚ü®r, ‚ü®hr0, hr1‚ü©, hp‚ÇÇ‚ü©, hp‚ÇÇp‚ÇÅ, hp‚ÇÇp‚ÇÉ‚ü©
  refine' ‚ü®vsub_ne_zero.2 hp‚ÇÇp‚ÇÅ.symm, -(1 - r) / r, _‚ü©
  have hr0' : r ‚â† 0 := by
    rintro rfl
    rw [‚Üê hp‚ÇÇ] at hp‚ÇÇp‚ÇÅ
    simp at hp‚ÇÇp‚ÇÅ
  have hr1' : r ‚â† 1 := by
    rintro rfl
    rw [‚Üê hp‚ÇÇ] at hp‚ÇÇp‚ÇÉ
    simp at hp‚ÇÇp‚ÇÉ
  replace hr0 := hr0.lt_of_ne hr0'.symm
  replace hr1 := hr1.lt_of_ne hr1'
  refine' ‚ü®div_neg_of_neg_of_pos (Left.neg_neg_iff.2 (sub_pos.2 hr1)) hr0, _‚ü©
  rw [‚Üê hp‚ÇÇ, AffineMap.lineMap_apply, vsub_vadd_eq_vsub_sub, vsub_vadd_eq_vsub_sub, vsub_self,
    zero_sub, smul_neg, smul_smul, div_mul_cancel _ hr0', neg_smul, neg_neg, sub_eq_iff_eq_add, ‚Üê
    add_smul, sub_add_cancel, one_smul]","warning:  @angle does not have a doc string
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.115537 / ?m.115551 * ?m.115551
case intro.intro.intro.intro.intro
V : Type u_1
P : Type u_2
inst‚úù¬≥ : NormedAddCommGroup V
inst‚úù¬≤ : InnerProductSpace ‚Ñù V
inst‚úù¬π : MetricSpace P
inst‚úù : NormedAddTorsor V P
p p‚ÇÄ p‚ÇÅ‚úù p‚ÇÇ‚úù p‚ÇÅ p‚ÇÇ p‚ÇÉ : P
r : ‚Ñù
hp‚ÇÇ : (AffineMap.lineMap p‚ÇÅ p‚ÇÉ) r = p‚ÇÇ
hp‚ÇÇp‚ÇÅ : p‚ÇÇ ‚â† p‚ÇÅ
hp‚ÇÇp‚ÇÉ : p‚ÇÇ ‚â† p‚ÇÉ
hr0' : r ‚â† 0
hr1' : r ‚â† 1
hr0 : 0 < r
hr1 : r < 1
‚ä¢ p‚ÇÉ -·µ• p‚ÇÅ - r ‚Ä¢ (p‚ÇÉ -·µ• p‚ÇÅ) = -((-(1 - r) / r * r) ‚Ä¢ (p‚ÇÉ -·µ• p‚ÇÅ))",theorem _root_.Sbtw.angle‚ÇÅ‚ÇÇ‚ÇÉ_eq_pi {p‚ÇÅ p‚ÇÇ p‚ÇÉ : P} (h : Sbtw ‚Ñù p‚ÇÅ p‚ÇÇ p‚ÇÉ) : ‚à† p‚ÇÅ p‚ÇÇ p‚ÇÉ = œÄ ,":= by
  rw [angle, angle_eq_pi_iff]
  rcases h with ‚ü®‚ü®r, ‚ü®hr0, hr1‚ü©, hp‚ÇÇ‚ü©, hp‚ÇÇp‚ÇÅ, hp‚ÇÇp‚ÇÉ‚ü©
  refine ‚ü®vsub_ne_zero.2 hp‚ÇÇp‚ÇÅ.symm, -(1 - r) / r, ?_‚ü©
  have hr0' : r ‚â† 0 := by
    rintro rfl
    rw [‚Üê hp‚ÇÇ] at hp‚ÇÇp‚ÇÅ
    simp at hp‚ÇÇp‚ÇÅ
  have hr1' : r ‚â† 1 := by
    rintro rfl
    rw [‚Üê hp‚ÇÇ] at hp‚ÇÇp‚ÇÉ
    simp at hp‚ÇÇp‚ÇÉ
  replace hr0 := hr0.lt_of_ne hr0'.symm
  replace hr1 := hr1.lt_of_ne hr1'
  refine ‚ü®div_neg_of_neg_of_pos (Left.neg_neg_iff.2 (sub_pos.2 hr1)) hr0, ?_‚ü©
  rw [‚Üê hp‚ÇÇ, AffineMap.lineMap_apply, vsub_vadd_eq_vsub_sub, vsub_vadd_eq_vsub_sub, vsub_self,
    zero_sub, smul_neg, smul_smul, div_mul_cancel‚ÇÄ _ hr0', neg_smul, neg_neg, sub_eq_iff_eq_add, ‚Üê
    add_smul, sub_add_cancel, one_smul]"
Mathlib/Combinatorics/SimpleGraph/Subgraph.lean,SimpleGraph.Subgraph.le_induce_union,le_induce_union,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  constructor
  ¬∑ simp only [verts_sup, induce_verts, Set.Subset.rfl]
  ¬∑ simp only [sup_adj, induce_Adj, Set.mem_union]
    rintro v w (h | h) <;> simp [h]","error:  unknown identifier 'induce_Adj'
error:  unsolved goals
case right.inl
Œπ : Sort u_1
V : Type u
W : Type v
G : SimpleGraph V
G' G'' : G.Subgraph
s s' : Set V
v w : V
h : (G'.induce s).Adj v w
‚ä¢ (v ‚àà s ‚à® v ‚àà s') ‚àß (w ‚àà s ‚à® w ‚àà s') ‚àß G'.Adj v w

case right.inr
Œπ : Sort u_1
V : Type u
W : Type v
G : SimpleGraph V
G' G'' : G.Subgraph
s s' : Set V
v w : V
h : (G'.induce s').Adj v w
‚ä¢ (v ‚àà s ‚à® v ‚àà s') ‚àß (w ‚àà s ‚à® w ‚àà s') ‚àß G'.Adj v w",lemma le_induce_union : G'.induce s ‚äî G'.induce s' ‚â§ G'.induce (s ‚à™ s') ,":= by
  constructor
  ¬∑ simp only [verts_sup, induce_verts, Set.Subset.rfl]
  ¬∑ simp only [sup_adj, induce_adj, Set.mem_union]
    rintro v w (h | h) <;> simp [h]"
Mathlib/LinearAlgebra/Matrix/Hermitian.lean,Matrix.isHermitian_add_transpose_self,isHermitian_add_transpose_self,1c643aca968064296312bf5328c84d0c50cfe5ae,":=
  IsSelfAdjoint.add_star_self A","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsSelfAdjoint
has type
  ?m.17948 ‚Üí Prop",theorem isHermitian_add_transpose_self (A : Matrix n n Œ±) : (A + A·¥¥).IsHermitian ,":=
  isSelfAdjoint_add_star_self A"
Mathlib/Data/Fin/VecNotation.lean,Matrix.vecAlt1_vecAppend,vecAlt1_vecAppend,2d8928f07c222f171d2f9371935aa5b8359f9d44,":= by
  ext i
  simp_rw [Function.comp, vecAlt1, vecAppend_eq_ite]
  cases n with
  | zero =>
    cases' i with i hi
    simp only [Nat.zero_eq, zero_add, Nat.lt_one_iff] at hi; subst i; rfl
  | succ n =>
    split_ifs with h <;> simp_rw [bit1, bit0] <;> congr
    ¬∑ simp [Nat.mod_eq_of_lt, h]
    ¬∑ rw [Fin.val_mk, not_lt] at h
      simp only [Fin.ext_iff, Fin.val_add, Fin.val_mk, Nat.mod_add_mod, Fin.val_one,
        Nat.mod_eq_sub_mod h, show 1 % (n + 2) = 1 from Nat.mod_eq_of_lt (by omega)]
      refine (Nat.mod_eq_of_lt ?_).symm
      rw [tsub_lt_iff_left h]
      exact Nat.add_succ_lt_add i.2 i.2","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
error:  tactic 'subst' failed, did not find equation for eliminating 'i'
case h.zero.mk
Œ± : Type u
m o : ‚Ñï
m' : Type u_1
n' : Type u_2
o' : Type u_3
v : Fin (0 + 1) ‚Üí Œ±
i : ‚Ñï
hi : i < 0 + 1
‚ä¢ (if h : ‚Üë‚ü®i, hi‚ü© + ‚Üë‚ü®i, hi‚ü© + 1 < 0 + 1 then v ‚ü®‚Üë‚ü®i, hi‚ü© + ‚Üë‚ü®i, hi‚ü© + 1, ‚ãØ‚ü©
    else v ‚ü®‚Üë‚ü®i, hi‚ü© + ‚Üë‚ü®i, hi‚ü© + 1 - (0 + 1), ‚ãØ‚ü©) =
    v (bit1 ‚ü®i, hi‚ü©)
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  unknown identifier 'tsub_lt_iff_left'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.37927
case neg.e_a.e_val
Œ± : Type u
m o : ‚Ñï
m' : Type u_1
n' : Type u_2
o' : Type u_3
n : ‚Ñï
v : Fin (n + 1 + 1) ‚Üí Œ±
i : Fin (n + 1 + 1)
h : n + 1 + 1 ‚â§ ‚Üëi + ‚Üëi + 1
‚ä¢ ‚Üëi + ‚Üëi + 1 - (n + 1 + 1) < n + 1 + 1
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated",theorem vecAlt1_vecAppend (v : Fin (n + 1) ‚Üí Œ±) : vecAlt1 rfl (vecAppend rfl v v) = v ‚àò bit1 ,":= by
  ext i
  simp_rw [Function.comp, vecAlt1, vecAppend_eq_ite]
  cases n with
  | zero =>
    cases' i with i hi
    simp only [Nat.zero_eq, Nat.zero_add, Nat.lt_one_iff] at hi; subst i; rfl
  | succ n =>
    split_ifs with h <;> simp_rw [bit1, bit0] <;> congr
    ¬∑ simp [Nat.mod_eq_of_lt, h]
    ¬∑ rw [Fin.val_mk, not_lt] at h
      simp only [Fin.ext_iff, Fin.val_add, Fin.val_mk, Nat.mod_add_mod, Fin.val_one,
        Nat.mod_eq_sub_mod h, show 1 % (n + 2) = 1 from Nat.mod_eq_of_lt (by omega)]
      refine (Nat.mod_eq_of_lt ?_).symm
      omega"
Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Degree.lean,WeierstrassCurve.natDegree_Œ¶,natDegree_Œ¶,409be1ff4c306030afd38a2641547686c28f2646,":= by
  induction n using Int.negInduction with
  | nat n => exact (W.natDegree_coeff_Œ¶_ofNat n).left
  | neg ih => simp only [Œ¶_neg, Int.natAbs_neg, ih]","error:  invalid argument, variable is not a proposition or let-declaration
error:  unsolved goals
case neg
R : Type u
inst‚úù : CommRing R
W : WeierstrassCurve R
ih : ‚Ñï
a‚úù : (W.Œ¶ ‚Üëih).natDegree ‚â§ (‚Üëih).natAbs ^ 2
‚ä¢ (W.Œ¶ ‚Üëih).natDegree ‚â§ (‚Üëih).natAbs ^ 2",lemma natDegree_Œ¶_le (n : ‚Ñ§) : (W.Œ¶ n).natDegree ‚â§ n.natAbs ^ 2 ,":= by
  induction n using Int.negInduction with
  | nat n => exact (W.natDegree_coeff_Œ¶_ofNat n).left
  | neg => rwa [Œ¶_neg, Int.natAbs_neg]"
Mathlib/MeasureTheory/Function/SimpleFuncDense.lean,MeasureTheory.SimpleFunc.tendsto_approxOn,tendsto_approxOn,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  haveI : Nonempty s := ‚ü®‚ü®y‚ÇÄ, h‚ÇÄ‚ü©‚ü©
  rw [‚Üê @Subtype.range_coe _ s, ‚Üê image_univ, ‚Üê (denseRange_denseSeq s).closure_eq] at hx
  simp (config := { iota := false }) only [approxOn, coe_comp]
  refine' tendsto_nearestPt (closure_minimal _ isClosed_closure hx)
  simp (config := { iota := false }) only [Nat.range_casesOn, closure_union, range_comp]
  exact
    Subset.trans (image_closure_subset_closure_image continuous_subtype_val)
      (subset_union_right _ _)","error:  overloaded, errors 
  110:7 overloaded, errors 
    function expected at
      Finset.subset_union_right ?m.27657
    term has type
      ?m.27656 ‚àà ?m.27654 ‚à™ ?m.27655
    
    function expected at
      Set.subset_union_right ?m.27918
    term has type
      ?m.27917 ‚àà ?m.27915 ‚à™ ?m.27916
  
  110:7 overloaded, errors 
    function expected at
      Finset.subset_union_right ?m.28434
    term has type
      ?m.28433 ‚àà ?m.28431 ‚à™ ?m.28432
    
    function expected at
      Set.subset_union_right ?m.28557
    term has type
      ?m.28556 ‚àà ?m.28554 ‚à™ ?m.28555","theorem tendsto_approxOn {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} {y‚ÇÄ : Œ±} (h‚ÇÄ : y‚ÇÄ ‚àà s)
    [SeparableSpace s] {x : Œ≤} (hx : f x ‚àà closure s) :
    Tendsto (fun n => approxOn f hf s y‚ÇÄ h‚ÇÄ n x) atTop (ùìù <| f x) ",":= by
  haveI : Nonempty s := ‚ü®‚ü®y‚ÇÄ, h‚ÇÄ‚ü©‚ü©
  rw [‚Üê @Subtype.range_coe _ s, ‚Üê image_univ, ‚Üê (denseRange_denseSeq s).closure_eq] at hx
  simp (config := { iota := false }) only [approxOn, coe_comp]
  refine tendsto_nearestPt (closure_minimal ?_ isClosed_closure hx)
  simp (config := { iota := false }) only [Nat.range_casesOn, closure_union, range_comp]
  exact
    Subset.trans (image_closure_subset_closure_image continuous_subtype_val)
      subset_union_right"
Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean,Polynomial.trailingDegree_X_pow,trailingDegree_X_pow,cdc0a3ef94c657b081c8511e7c849dd9c6410512,":= by
  rw [X_pow_eq_monomial, trailingDegree_monomial _ one_ne_zero]","error:  function expected at
  trailingDegree_monomial ?m.52191
term has type
  ((monomial ?m.52189) ?m.52188).trailingDegree = ‚Üë?m.52189
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.52259
R : Type u
S : Type v
a b : R
n‚úù m : ‚Ñï
inst‚úù¬π : Semiring R
inst‚úù : Nontrivial R
p q : R[X]
n : ‚Ñï
‚ä¢ ((monomial n) 1).trailingDegree = ‚Üën","lemma trailingDegree_X_pow (n : ‚Ñï) :
    (X ^ n : R[X]).trailingDegree = n ",":= by
  rw [X_pow_eq_monomial, trailingDegree_monomial one_ne_zero]"
Mathlib/RingTheory/AlgebraicIndependent.lean,AlgHom.algebraicIndependent_iff,AlgHom.algebraicIndependent_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  ‚ü®fun h => h.of_comp f, fun h => h.map (injOn_of_injective hf _)‚ü©","error:  application type mismatch
  AlgebraicIndependent.map h (injOn_of_injective hf ?m.91750)
argument
  injOn_of_injective hf ?m.91750
has type
  ‚àÄ ‚¶Éx‚ÇÇ : A‚¶Ñ, x‚ÇÇ ‚àà ?m.91748 ‚Üí f ?m.91749 = f x‚ÇÇ ‚Üí ?m.91749 = x‚ÇÇ : Prop
but is expected to have type
  InjOn ‚áëf ‚Üë(adjoin R (range x)) : Prop","theorem AlgHom.algebraicIndependent_iff (f : A ‚Üí‚Çê[R] A') (hf : Injective f) :
    AlgebraicIndependent R (f ‚àò x) ‚Üî AlgebraicIndependent R x ",":=
  ‚ü®fun h => h.of_comp f, fun h => h.map hf.injOn‚ü©"
Mathlib/SetTheory/Cardinal/Cofinality.lean,Ordinal.unbounded_of_unbounded_sUnion,unbounded_of_unbounded_sUnion,693fd79515903b10b1d31f10dccfc49e633cf7ee,":= by
  by_contra' h
  simp_rw [not_unbounded_iff] at h
  let f : s ‚Üí Œ± := fun x : s => wo.wf.sup x (h x.1 x.2)
  refine' h‚ÇÇ.not_le (le_trans (csInf_le' ‚ü®range f, fun x => _, rfl‚ü©) mk_range_le)
  rcases h‚ÇÅ x with ‚ü®y, ‚ü®c, hc, hy‚ü©, hxy‚ü©
  exact ‚ü®f ‚ü®c, hc‚ü©, mem_range_self _, fun hxz => hxy (Trans.trans (wo.wf.lt_sup _ hy) hxz)‚ü©","error:  unknown tactic
error:  unsolved goals
Œ± : Type u_1
r‚úù r : Œ± ‚Üí Œ± ‚Üí Prop
wo : IsWellOrder Œ± r
s : Set (Set Œ±)
h‚ÇÅ : Unbounded r (‚ãÉ‚ÇÄ s)
h‚ÇÇ : #‚Üës < StrictOrder.cof r
‚ä¢ ‚àÉ x ‚àà s, Unbounded r x","theorem unbounded_of_unbounded_sUnion (r : Œ± ‚Üí Œ± ‚Üí Prop) [wo : IsWellOrder Œ± r] {s : Set (Set Œ±)}
    (h‚ÇÅ : Unbounded r <| ‚ãÉ‚ÇÄ s) (h‚ÇÇ : #s < StrictOrder.cof r) : ‚àÉ x ‚àà s, Unbounded r x ",":= by
  by_contra! h
  simp_rw [not_unbounded_iff] at h
  let f : s ‚Üí Œ± := fun x : s => wo.wf.sup x (h x.1 x.2)
  refine h‚ÇÇ.not_le (le_trans (csInf_le' ‚ü®range f, fun x => ?_, rfl‚ü©) mk_range_le)
  rcases h‚ÇÅ x with ‚ü®y, ‚ü®c, hc, hy‚ü©, hxy‚ü©
  exact ‚ü®f ‚ü®c, hc‚ü©, mem_range_self _, fun hxz => hxy (Trans.trans (wo.wf.lt_sup _ hy) hxz)‚ü©"
Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean,Complex.natCast_arg,natCast_arg,61ddcfa78d90f5773ac5739822ee3721851aa662,":=
  ofReal_nat_cast n ‚ñ∏ arg_ofReal_of_nonneg n.cast_nonneg",error:  unknown identifier 'ofReal_nat_cast',lemma natCast_arg {n : ‚Ñï} : arg n = 0 ,":=
  ofReal_natCast n ‚ñ∏ arg_ofReal_of_nonneg n.cast_nonneg"
Mathlib/Algebra/CharP/LocalRing.lean,charP_zero_or_prime_power,charP_zero_or_prime_power,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  apply or_iff_not_imp_left.2
  intro q_pos
  let K := LocalRing.ResidueField R
  haveI RM_char := ringChar.charP K
  let r := ringChar K
  let n := q.factorization r
  cases' CharP.char_is_prime_or_zero K r with r_prime r_zero
  ¬∑ let a := q / r ^ n
    have q_eq_a_mul_rn : q = r ^ n * a := by rw [Nat.mul_div_cancel' (Nat.ord_proj_dvd q r)]
    have r_ne_dvd_a := Nat.not_dvd_ord_compl r_prime q_pos
    have rn_dvd_q : r ^ n ‚à£ q := ‚ü®a, q_eq_a_mul_rn‚ü©
    rw [mul_comm] at q_eq_a_mul_rn
    have a_unit : IsUnit (a : R) := by
      by_contra g
      rw [‚Üê mem_nonunits_iff] at g
      rw [‚Üê LocalRing.mem_maximalIdeal] at g
      have a_cast_zero := Ideal.Quotient.eq_zero_iff_mem.2 g
      rw [map_natCast] at a_cast_zero
      have r_dvd_a := (ringChar.spec K a).1 a_cast_zero
      exact absurd r_dvd_a r_ne_dvd_a
    cases' a_unit.exists_left_inv with a_inv h_inv_mul_a
    have rn_cast_zero : ‚Üë(r ^ n) = (0 : R) := by
      rw [‚Üê @mul_one R _ (r ^ n), mul_comm, ‚ÜêClassical.choose_spec a_unit.exists_left_inv,
        mul_assoc, ‚Üê Nat.cast_mul, ‚Üêq_eq_a_mul_rn, CharP.cast_eq_zero R q]
      simp
    have q_eq_rn := Nat.dvd_antisymm ((CharP.cast_eq_zero_iff R q (r ^ n)).mp rn_cast_zero) rn_dvd_q
    have n_pos : n ‚â† 0 := fun n_zero =>
      absurd (by simpa [n_zero] using q_eq_rn) (CharP.char_ne_one R q)
    exact ‚ü®r, ‚ü®n, ‚ü®r_prime.prime, ‚ü®pos_iff_ne_zero.mpr n_pos, q_eq_rn.symm‚ü©‚ü©‚ü©‚ü©
  ¬∑ haveI K_char_p_0 := ringChar.of_eq r_zero
    haveI K_char_zero : CharZero K := CharP.charP_to_charZero K
    haveI R_char_zero := RingHom.charZero (LocalRing.residue R)
    have q_zero := CharP.eq R char_R_q (CharP.ofCharZero R)
    exact absurd q_zero q_pos","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üër ^ n
R : Type u_1
inst‚úù¬π : CommRing R
inst‚úù : LocalRing R
q : ‚Ñï
char_R_q : CharP R q
q_pos : ¬¨q = 0
K : Type u_1 := LocalRing.ResidueField R
RM_char : CharP K (ringChar K)
r : ‚Ñï := ringChar K
n : ‚Ñï := q.factorization r
r_prime : Nat.Prime r
a : ‚Ñï := q / r ^ n
q_eq_a_mul_rn : q = a * r ^ n
r_ne_dvd_a : ¬¨r ‚à£ q / r ^ q.factorization r
rn_dvd_q : r ^ n ‚à£ q
a_unit : IsUnit ‚Üëa
a_inv : R
h_inv_mul_a : a_inv * ‚Üëa = 1
‚ä¢ ‚Üë(r ^ n) = 0","theorem charP_zero_or_prime_power (R : Type*) [CommRing R] [LocalRing R] (q : ‚Ñï)
    [char_R_q : CharP R q] : q = 0 ‚à® IsPrimePow q ",":= by
  apply or_iff_not_imp_left.2
  intro q_pos
  let K := LocalRing.ResidueField R
  haveI RM_char := ringChar.charP K
  let r := ringChar K
  let n := q.factorization r
  cases' CharP.char_is_prime_or_zero K r with r_prime r_zero
  ¬∑ let a := q / r ^ n
    have q_eq_a_mul_rn : q = r ^ n * a := by rw [Nat.mul_div_cancel' (Nat.ord_proj_dvd q r)]
    have r_ne_dvd_a := Nat.not_dvd_ord_compl r_prime q_pos
    have rn_dvd_q : r ^ n ‚à£ q := ‚ü®a, q_eq_a_mul_rn‚ü©
    rw [mul_comm] at q_eq_a_mul_rn
    have a_unit : IsUnit (a : R) := by
      by_contra g
      rw [‚Üê mem_nonunits_iff] at g
      rw [‚Üê LocalRing.mem_maximalIdeal] at g
      have a_cast_zero := Ideal.Quotient.eq_zero_iff_mem.2 g
      rw [map_natCast] at a_cast_zero
      have r_dvd_a := (ringChar.spec K a).1 a_cast_zero
      exact absurd r_dvd_a r_ne_dvd_a
    cases' a_unit.exists_left_inv with a_inv h_inv_mul_a
    have rn_cast_zero : ‚Üë(r ^ n) = (0 : R) := by
      rw [‚Üê @mul_one R _ ‚Üë(r ^ n), mul_comm, ‚Üê Classical.choose_spec a_unit.exists_left_inv,
        mul_assoc, ‚Üê Nat.cast_mul, ‚Üê q_eq_a_mul_rn, CharP.cast_eq_zero R q]
      simp
    have q_eq_rn := Nat.dvd_antisymm ((CharP.cast_eq_zero_iff R q (r ^ n)).mp rn_cast_zero) rn_dvd_q
    have n_pos : n ‚â† 0 := fun n_zero =>
      absurd (by simpa [n_zero] using q_eq_rn) (CharP.char_ne_one R q)
    exact ‚ü®r, ‚ü®n, ‚ü®r_prime.prime, ‚ü®pos_iff_ne_zero.mpr n_pos, q_eq_rn.symm‚ü©‚ü©‚ü©‚ü©
  ¬∑ haveI K_char_p_0 := ringChar.of_eq r_zero
    haveI K_char_zero : CharZero K := CharP.charP_to_charZero K
    haveI R_char_zero := RingHom.charZero (LocalRing.residue R)
    have q_zero := CharP.eq R char_R_q (CharP.ofCharZero R)
    exact absurd q_zero q_pos"
Mathlib/FieldTheory/Finite/Basic.lean,Int.ModEq.pow_card_sub_one_eq_one,Int.ModEq.pow_card_sub_one_eq_one,079113af31d690223d4821fd5f7a58291d2347e7,":= by
  haveI : Fact p.Prime := ‚ü®hp‚ü©
  have : ¬¨(n : ZMod p) = 0 := by
    rw [CharP.int_cast_eq_zero_iff _ p, ‚Üê (Nat.prime_iff_prime_int.mp hp).coprime_iff_not_dvd]
    ¬∑ exact hpn.symm
  simpa [‚Üê ZMod.int_cast_eq_int_cast_iff] using ZMod.pow_card_sub_one_eq_one this","error:  unknown constant 'CharP.int_cast_eq_zero_iff'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.173355
K : Type u_1
R : Type u_2
p : ‚Ñï
hp : Nat.Prime p
n : ‚Ñ§
hpn : IsCoprime n ‚Üëp
this : Fact (Nat.Prime p)
‚ä¢ ¬¨‚Üën = 0
warning:  `ZMod.int_cast_eq_int_cast_iff` has been deprecated, use `ZMod.intCast_eq_intCast_iff` instead","theorem Int.ModEq.pow_card_sub_one_eq_one {p : ‚Ñï} (hp : Nat.Prime p) {n : ‚Ñ§} (hpn : IsCoprime n p) :
    n ^ (p - 1) ‚â° 1 [ZMOD p] ",":= by
  haveI : Fact p.Prime := ‚ü®hp‚ü©
  have : ¬¨(n : ZMod p) = 0 := by
    rw [CharP.intCast_eq_zero_iff _ p, ‚Üê (Nat.prime_iff_prime_int.mp hp).coprime_iff_not_dvd]
    ¬∑ exact hpn.symm
  simpa [‚Üê ZMod.intCast_eq_intCast_iff] using ZMod.pow_card_sub_one_eq_one this"
Mathlib/FieldTheory/NormalClosure.lean,normalClosure.restrictScalars_eq,restrictScalars_eq,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  classical
  have hi : ‚àÄ x : K, IsIntegral F x :=
    fun x ‚Ü¶ (isIntegral_algebraMap_iff (algebraMap K L).injective).mp (h.isIntegral _)
  refine' le_antisymm (iSup_le _) (iSup_le fun x => adjoin_le_iff.mpr fun y hy => _)
  ¬∑ rintro f _ ‚ü®x, rfl‚ü©
    refine' le_iSup (fun x => adjoin F ((minpoly F x).rootSet L)) x
        (subset_adjoin F ((minpoly F x).rootSet L) _)
    rw [mem_rootSet_of_ne (minpoly.ne_zero (hi x)), AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom,
      Polynomial.aeval_algHom_apply, minpoly.aeval, map_zero]
  ¬∑ rw [Polynomial.rootSet, Finset.mem_coe, Multiset.mem_toFinset] at hy
    let g := (algHomAdjoinIntegralEquiv F (hi x)).symm ‚ü®y, hy‚ü©
    refine' le_iSup (fun f : K ‚Üí‚Çê[F] L => f.fieldRange) ((g.liftNormal L).comp (toAlgHom F K L))
        ‚ü®x, (g.liftNormal_commutes L (AdjoinSimple.gen F x)).trans _‚ü©
    rw [Algebra.id.map_eq_id, RingHom.id_apply]
    apply PowerBasis.lift_gen
    change aeval y (minpoly F (AdjoinSimple.gen F x)) = 0
    exact minpoly_gen F x ‚ñ∏ aeval_eq_zero_of_mem_rootSet (Multiset.mem_toFinset.mpr hy)","error:  unknown identifier 'h.isIntegral'
error:  application type mismatch
  le_antisymm (iSup_le ?m.142611)
argument
  iSup_le ?m.142611
has type
  iSup ?m.142609 ‚â§ ?m.142610 : Prop
but is expected to have type
  restrictScalars F (toAlgHom K (‚Ü•(normalClosure F K L)) L).fieldRange ‚â§ normalClosure F K L : Prop
error:  type mismatch
  adjoin_le_iff.mpr fun y hy ‚Ü¶ ?m.143874 y hy
has type
  adjoin ?m.143664 ?m.143812 ‚â§ ?m.143813 : Prop
but is expected to have type
  x.fieldRange ‚â§ restrictScalars F (toAlgHom K (‚Ü•(normalClosure F K L)) L).fieldRange : Prop","lemma restrictScalars_eq :
    (toAlgHom K (normalClosure F K L) L).fieldRange.restrictScalars F = normalClosure F K L ",":=
  SetLike.ext' Subtype.range_val"
Mathlib/Order/JordanHolder.lean,CompositionSeries.toList_sorted,toList_sorted,9e94cfec525a019b90a7957c71fe4af51917c47f,":=
  List.pairwise_iff_get.2 fun i j h => by
    dsimp [RelSeries.toList]
    rw [List.get_ofFn, List.get_ofFn]
    exact s.strictMono h","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (List.ofFn ?f).get ?i
X : Type u
inst‚úù¬π : Lattice X
inst‚úù : JordanHolderLattice X
s : CompositionSeries X
i j : Fin (toList s).length
h : i < j
‚ä¢ (List.ofFn s.toFun)[‚Üëi] < (List.ofFn s.toFun)[‚Üëj]",theorem toList_sorted (s : CompositionSeries X) : s.toList.Sorted (¬∑ < ¬∑) ,":=
  List.pairwise_iff_get.2 fun i j h => by
    dsimp only [RelSeries.toList]
    rw [List.get_ofFn, List.get_ofFn]
    exact s.strictMono h"
Mathlib/Data/Nat/Cast/Basic.lean,nsmul_eq_mul',_root_.nsmul_eq_mul',554c20d1eb6d2f1f6a5b53ccd3a727a93147a4de,":= by
  induction' n with n ih <;> [rw [zero_nsmul, Nat.cast_zero, mul_zero];
    rw [succ_nsmul', ih, Nat.cast_succ, mul_add, mul_one]]","error:  unsolved goals
case succ
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù : NonAssocSemiring Œ±
a : Œ±
n : ‚Ñï
ih : n ‚Ä¢ a = a * ‚Üën
‚ä¢ a + a * ‚Üën = a * ‚Üën + a",lemma _root_.nsmul_eq_mul' (a : Œ±) (n : ‚Ñï) : n ‚Ä¢ a = a * n ,":= by
  induction n with
  | zero => rw [zero_nsmul, Nat.cast_zero, mul_zero]
  | succ n ih => rw [succ_nsmul, ih, Nat.cast_succ, mul_add, mul_one]"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,50f79eaf0f5e360632afea97f3cefd2b1eab4c46,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero, Nat.zero_eq,
          Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120516 ‚Üí ?m.120516
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.124403 ‚Üí ?m.124403
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà id ‚àÖ, closedBall p.1 p.2) ‚â§ Œº s
error:  type mismatch
  mul_le_mul_left' IH (‚ÜëN / (‚ÜëN + 1))
has type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * ((‚ÜëN / (‚ÜëN + 1)) ^ n * Œº s) : Prop
but is expected to have type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ (‚ÜëN / (‚ÜëN + 1)) ^ n * (‚ÜëN / (‚ÜëN + 1) * Œº s) : Prop
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.134258 ‚Üí ?m.134258 ‚Üí Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.134394 ‚Üí ?m.134394 ‚Üí Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/Topology/MetricSpace/HausdorffDistance.lean,Metric.infDist_inter_closedBall_of_mem,infDist_inter_closedBall_of_mem,089ac90928952b8a08be66ede7ff142d0f9ba666,":= by
  replace h : y ‚àà s ‚à© closedBall x (dist y x) := ‚ü®h, mem_closedBall.2 le_rfl‚ü©
  refine le_antisymm ?_ (infDist_le_infDist_of_subset (inter_subset_left _ _) ‚ü®y, h‚ü©)
  refine not_lt.1 fun hlt => ?_
  rcases (infDist_lt_iff ‚ü®y, h.1‚ü©).mp hlt with ‚ü®z, hzs, hz‚ü©
  rcases le_or_lt (dist z x) (dist y x) with hle | hlt
  ¬∑ exact hz.not_le (infDist_le_dist_of_mem ‚ü®hzs, hle‚ü©)
  ¬∑ rw [dist_comm z, dist_comm y] at hlt
    exact (hlt.trans hz).not_le (infDist_le_dist_of_mem h)","error:  function expected at
  inter_subset_left ?m.75705
term has type
  ?m.75704 ‚àà ?m.75702","theorem infDist_inter_closedBall_of_mem (h : y ‚àà s) :
    infDist x (s ‚à© closedBall x (dist y x)) = infDist x s ",":= by
  replace h : y ‚àà s ‚à© closedBall x (dist y x) := ‚ü®h, mem_closedBall.2 le_rfl‚ü©
  refine le_antisymm ?_ (infDist_le_infDist_of_subset inter_subset_left ‚ü®y, h‚ü©)
  refine not_lt.1 fun hlt => ?_
  rcases (infDist_lt_iff ‚ü®y, h.1‚ü©).mp hlt with ‚ü®z, hzs, hz‚ü©
  rcases le_or_lt (dist z x) (dist y x) with hle | hlt
  ¬∑ exact hz.not_le (infDist_le_dist_of_mem ‚ü®hzs, hle‚ü©)
  ¬∑ rw [dist_comm z, dist_comm y] at hlt
    exact (hlt.trans hz).not_le (infDist_le_dist_of_mem h)"
Mathlib/Data/Nat/PartENat.lean,PartENat.le_of_lt_add_one,le_of_lt_add_one,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' y with n
  ¬∑ apply le_top
  rcases ne_top_iff.mp (ne_top_of_lt h) with ‚ü®m, rfl‚ü©
  norm_cast; apply Nat.le_of_lt_succ; norm_cast at h","error:  tactic 'apply' failed, failed to unify
  ?a ‚â§ ‚ä§
with
  x ‚â§ { Dom := n, get := get‚úù }
case mk
x : PartENat
n : Prop
get‚úù : n ‚Üí ‚Ñï
h : x < { Dom := n, get := get‚úù } + 1
‚ä¢ x ‚â§ { Dom := n, get := get‚úù }
error:  no goals to be solved",theorem le_of_lt_add_one {x y : PartENat} (h : x < y + 1) : x ‚â§ y ,":= by
  induction' y using PartENat.casesOn with n
  ¬∑ apply le_top
  rcases ne_top_iff.mp (ne_top_of_lt h) with ‚ü®m, rfl‚ü©
  norm_cast; apply Nat.le_of_lt_succ; norm_cast at h"
Mathlib/Data/List/GetD.lean,List.getD_eq_default,getD_eq_default,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction l generalizing n with
  | nil => exact getD_nil _ _
  | cons head tail ih =>
    cases n
    ¬∑ simp at hn
    ¬∑ exact ih (Nat.le_of_succ_le_succ hn)","error:  function expected at
  getD_nil
term has type
  [].getD ?m.821 ?m.823 = ?m.823
warning:  `List.get_append` has been deprecated, use `List.getElem_append` instead",theorem getD_eq_default {n : ‚Ñï} (hn : l.length ‚â§ n) : l.getD n d = d ,":= by
  induction l generalizing n with
  | nil => exact getD_nil
  | cons head tail ih =>
    cases n
    ¬∑ simp at hn
    ¬∑ exact ih (Nat.le_of_succ_le_succ hn)"
Mathlib/Geometry/Manifold/IntegralCurve.lean,IsIntegralCurveAt.comp_mul_ne_zero,IsIntegralCurveAt.comp_mul_ne_zero,4449fea6cb71b0c9863e5f2aaa338fd940fe3afa,":= by
  rw [isIntegralCurveAt_iff'] at *
  obtain ‚ü®Œµ, hŒµ, h‚ü© := hŒ≥
  refine ‚ü®Œµ / |a|, by positivity, ?_‚ü©
  convert h.comp_mul a
  ext t
  rw [mem_setOf_eq, Metric.mem_ball, Metric.mem_ball, Real.dist_eq, Real.dist_eq,
    lt_div_iff (abs_pos.mpr ha), ‚Üê abs_mul, sub_mul, div_mul_cancel _ ha]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.246709 / ?m.246723 * ?m.246723
case h.e'_13.h
E : Type u_1
inst‚úù‚Å∂ : NormedAddCommGroup E
inst‚úù‚Åµ : NormedSpace ‚Ñù E
inst‚úù‚Å¥ : CompleteSpace E
H : Type u_2
inst‚úù¬≥ : TopologicalSpace H
I : ModelWithCorners ‚Ñù E H
M : Type u_3
inst‚úù¬≤ : TopologicalSpace M
inst‚úù¬π : ChartedSpace H M
inst‚úù : SmoothManifoldWithCorners I M
Œ≥ Œ≥' : ‚Ñù ‚Üí M
v : (x : M) ‚Üí TangentSpace I x
s s' : Set ‚Ñù
t‚ÇÄ a : ‚Ñù
ha : a ‚â† 0
Œµ : ‚Ñù
hŒµ : Œµ > 0
h : IsIntegralCurveOn Œ≥ v (Metric.ball t‚ÇÄ Œµ)
t : ‚Ñù
‚ä¢ |t * a - t‚ÇÄ / a * a| < Œµ ‚Üî |t * a - t‚ÇÄ| < Œµ","lemma IsIntegralCurveAt.comp_mul_ne_zero (hŒ≥ : IsIntegralCurveAt Œ≥ v t‚ÇÄ) {a : ‚Ñù} (ha : a ‚â† 0) :
    IsIntegralCurveAt (Œ≥ ‚àò (¬∑ * a)) (a ‚Ä¢ v) (t‚ÇÄ / a) ",":= by
  rw [isIntegralCurveAt_iff'] at *
  obtain ‚ü®Œµ, hŒµ, h‚ü© := hŒ≥
  refine ‚ü®Œµ / |a|, by positivity, ?_‚ü©
  convert h.comp_mul a
  ext t
  rw [mem_setOf_eq, Metric.mem_ball, Metric.mem_ball, Real.dist_eq, Real.dist_eq,
    lt_div_iff (abs_pos.mpr ha), ‚Üê abs_mul, sub_mul, div_mul_cancel‚ÇÄ _ ha]"
Mathlib/Analysis/InnerProductSpace/Basic.lean,OrthogonalFamily.independent,OrthogonalFamily.independent,442e70a0f01607f243b47e1f187212240d8169d9,":= by
  classical!
  apply CompleteLattice.independent_of_dfinsupp_lsum_injective
  refine LinearMap.ker_eq_bot.mp ?_
  rw [Submodule.eq_bot_iff]
  intro v hv
  rw [LinearMap.mem_ker] at hv
  ext i
  suffices ‚ü™(v i : E), v i‚ü´ = 0 by simpa only [inner_self_eq_zero] using this
  calc
    ‚ü™(v i : E), v i‚ü´ = ‚ü™(v i : E), Dfinsupp.lsum ‚Ñï (fun i => (V i).subtype) v‚ü´ := by
      simpa only [Dfinsupp.sumAddHom_apply, Dfinsupp.lsum_apply_apply] using
        (hV.inner_right_dfinsupp v i (v i)).symm
    _ = 0 := by simp only [hv, inner_zero_right]",error:  `classical!` has been removed; use `classical` instead,"theorem OrthogonalFamily.independent {V : Œπ ‚Üí Submodule ùïú E}
    (hV : OrthogonalFamily ùïú (fun i => V i) fun i => (V i).subtype‚Çó·µ¢) :
    CompleteLattice.Independent V ",":= by
  classical
  apply CompleteLattice.independent_of_dfinsupp_lsum_injective
  refine LinearMap.ker_eq_bot.mp ?_
  rw [Submodule.eq_bot_iff]
  intro v hv
  rw [LinearMap.mem_ker] at hv
  ext i
  suffices ‚ü™(v i : E), v i‚ü´ = 0 by simpa only [inner_self_eq_zero] using this
  calc
    ‚ü™(v i : E), v i‚ü´ = ‚ü™(v i : E), DFinsupp.lsum ‚Ñï (fun i => (V i).subtype) v‚ü´ := by
      simpa only [DFinsupp.sumAddHom_apply, DFinsupp.lsum_apply_apply] using
        (hV.inner_right_dfinsupp v i (v i)).symm
    _ = 0 := by simp only [hv, inner_zero_right]"
Mathlib/MeasureTheory/Integral/PeakFunction.lean,tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux,tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine Metric.tendsto_nhds.2 fun Œµ Œµpos => ?_
  obtain ‚ü®Œ¥, hŒ¥, Œ¥pos, Œ¥one‚ü© : ‚àÉ Œ¥, (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ < Œµ ‚àß 0 < Œ¥ ‚àß Œ¥ < 1:= by
    have A :
      Tendsto (fun Œ¥ => (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥) (ùìù[>] 0)
        (ùìù ((0 * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * 0)) := by
      apply Tendsto.mono_left _ nhdsWithin_le_nhds
      exact (tendsto_id.mul tendsto_const_nhds).add (tendsto_id.const_mul _)
    rw [zero_mul, zero_add, mul_zero] at A
    have : Ioo (0 : ‚Ñù) 1 ‚àà ùìù[>] 0 := Ioo_mem_nhdsWithin_Ioi ‚ü®le_rfl, zero_lt_one‚ü©
    rcases (((tendsto_order.1 A).2 Œµ Œµpos).and this).exists with ‚ü®Œ¥, hŒ¥, h'Œ¥‚ü©
    exact ‚ü®Œ¥, hŒ¥, h'Œ¥.1, h'Œ¥.2‚ü©
  suffices ‚àÄ·∂† i in l, ‚Äñ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ by
    filter_upwards [this] with i hi
    simp only [dist_zero_right]
    exact hi.trans_lt hŒ¥
  obtain ‚ü®u, u_open, x‚ÇÄu, ut, hu‚ü© :
      ‚àÉ u, IsOpen u ‚àß x‚ÇÄ ‚àà u ‚àß s ‚à© u ‚äÜ t ‚àß ‚àÄ x ‚àà u ‚à© s, g x ‚àà ball 0 Œ¥ := by
    rcases mem_nhdsWithin.1 (Filter.inter_mem h'ts (hcg (ball_mem_nhds _ Œ¥pos)))
      with ‚ü®u, u_open, x‚ÇÄu, hu‚ü©
    refine ‚ü®u, u_open, x‚ÇÄu, ?_, hu.trans (inter_subset_right _ _)‚ü©
    rw [inter_comm]
    exact hu.trans (inter_subset_left _ _)
  filter_upwards [tendstoUniformlyOn_iff.1 (hlœÜ u u_open x‚ÇÄu) Œ¥ Œ¥pos,
    (tendsto_order.1 (tendsto_iff_norm_sub_tendsto_zero.1 hiœÜ)).2 Œ¥ Œ¥pos, hnœÜ,
    integrableOn_peak_smul_of_integrableOn_of_tendsto hs h'ts hlœÜ hiœÜ h'iœÜ hmg hcg]
    with i hi h'i hœÜpos h''i
  have I : IntegrableOn (œÜ i) t Œº := by
    apply Integrable.of_integral_ne_zero (fun h ‚Ü¶ ?_)
    simp [h] at h'i
    linarith
  have B : ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ 2 * Œ¥ :=
    calc
      ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ ‚à´ x in s ‚à© u, ‚ÄñœÜ i x ‚Ä¢ g x‚Äñ ‚àÇŒº :=
        norm_integral_le_integral_norm _
      _ ‚â§ ‚à´ x in s ‚à© u, ‚ÄñœÜ i x‚Äñ * Œ¥ ‚àÇŒº := by
        refine setIntegral_mono_on ?_ ?_ (hs.inter u_open.measurableSet) fun x hx => ?_
        ¬∑ exact IntegrableOn.mono_set h''i.norm (inter_subset_left _ _)
        ¬∑ exact IntegrableOn.mono_set (I.norm.mul_const _) ut
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
        rw [inter_comm] at hu
        exact (mem_ball_zero_iff.1 (hu x hx)).le
      _ ‚â§ ‚à´ x in t, ‚ÄñœÜ i x‚Äñ * Œ¥ ‚àÇŒº := by
        apply setIntegral_mono_set
        ¬∑ exact I.norm.mul_const _
        ¬∑ exact eventually_of_forall fun x => mul_nonneg (norm_nonneg _) Œ¥pos.le
        ¬∑ exact eventually_of_forall ut
      _ = ‚à´ x in t, œÜ i x * Œ¥ ‚àÇŒº := by
        apply setIntegral_congr ht fun x hx => ?_
        rw [Real.norm_of_nonneg (hœÜpos _ (hts hx))]
      _ = (‚à´ x in t, œÜ i x ‚àÇŒº) * Œ¥ := by rw [integral_mul_right]
      _ ‚â§ 2 * Œ¥ := by gcongr; linarith [(le_abs_self _).trans h'i.le]
  have C : ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº :=
    calc
      ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ ‚à´ x in s \ u, ‚ÄñœÜ i x ‚Ä¢ g x‚Äñ ‚àÇŒº :=
        norm_integral_le_integral_norm _
      _ ‚â§ ‚à´ x in s \ u, Œ¥ * ‚Äñg x‚Äñ ‚àÇŒº := by
        refine setIntegral_mono_on ?_ ?_ (hs.diff u_open.measurableSet) fun x hx => ?_
        ¬∑ exact IntegrableOn.mono_set h''i.norm (diff_subset _ _)
        ¬∑ exact IntegrableOn.mono_set (hmg.norm.const_mul _) (diff_subset _ _)
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le
      _ ‚â§ Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº := by
        rw [integral_mul_left]
        apply mul_le_mul_of_nonneg_left (setIntegral_mono_set hmg.norm _ _) Œ¥pos.le
        ¬∑ filter_upwards with x using norm_nonneg _
        ¬∑ filter_upwards using diff_subset s u
  calc
    ‚Äñ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ =
      ‚Äñ(‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº) + ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ := by
      conv_lhs => rw [‚Üê diff_union_inter s u]
      rw [integral_union disjoint_sdiff_inter (hs.inter u_open.measurableSet)
          (h''i.mono_set (diff_subset _ _)) (h''i.mono_set (inter_subset_left _ _))]
    _ ‚â§ ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ + ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ := add_le_add C B","error:  function expected at
  inter_subset_right ?m.27078
term has type
  ?m.27077 ‚àà ?m.27076
error:  function expected at
  inter_subset_left ?m.27224
term has type
  ?m.27223 ‚àà ?m.27221
error:  function expected at
  inter_subset_left ?m.35688
term has type
  ?m.35687 ‚àà ?m.35685
error:  function expected at
  diff_subset ?m.54267
term has type
  ?m.54266 ‚àà ?m.54264
error:  function expected at
  diff_subset ?m.54437
term has type
  ?m.54436 ‚àà ?m.54434
error:  application type mismatch
  diff_subset s
argument
  s
has type
  Set Œ± : Type u_1
but is expected to have type
  ?m.55664 ‚àà ?m.55662 \ ?m.55663 : Prop
error:  function expected at
  diff_subset ?m.62903
term has type
  ?m.62902 ‚àà ?m.62900
error:  function expected at
  inter_subset_left ?m.62966
term has type
  ?m.62965 ‚àà ?m.62963","theorem tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux
    (hs : MeasurableSet s) (ht : MeasurableSet t) (hts : t ‚äÜ s) (h'ts : t ‚àà ùìù[s] x‚ÇÄ)
    (hnœÜ : ‚àÄ·∂† i in l, ‚àÄ x ‚àà s, 0 ‚â§ œÜ i x)
    (hlœÜ : ‚àÄ u : Set Œ±, IsOpen u ‚Üí x‚ÇÄ ‚àà u ‚Üí TendstoUniformlyOn œÜ 0 l (s \ u))
    (hiœÜ : Tendsto (fun i ‚Ü¶ ‚à´ x in t, œÜ i x ‚àÇŒº) l (ùìù 1))
    (h'iœÜ : ‚àÄ·∂† i in l, AEStronglyMeasurable (œÜ i) (Œº.restrict s))
    (hmg : IntegrableOn g s Œº) (hcg : Tendsto g (ùìù[s] x‚ÇÄ) (ùìù 0)) :
    Tendsto (fun i : Œπ => ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº) l (ùìù 0) ",":= by
  refine Metric.tendsto_nhds.2 fun Œµ Œµpos => ?_
  obtain ‚ü®Œ¥, hŒ¥, Œ¥pos, Œ¥one‚ü© : ‚àÉ Œ¥, (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ < Œµ ‚àß 0 < Œ¥ ‚àß Œ¥ < 1:= by
    have A :
      Tendsto (fun Œ¥ => (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥) (ùìù[>] 0)
        (ùìù ((0 * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * 0)) := by
      apply Tendsto.mono_left _ nhdsWithin_le_nhds
      exact (tendsto_id.mul tendsto_const_nhds).add (tendsto_id.const_mul _)
    rw [zero_mul, zero_add, mul_zero] at A
    have : Ioo (0 : ‚Ñù) 1 ‚àà ùìù[>] 0 := Ioo_mem_nhdsWithin_Ioi ‚ü®le_rfl, zero_lt_one‚ü©
    rcases (((tendsto_order.1 A).2 Œµ Œµpos).and this).exists with ‚ü®Œ¥, hŒ¥, h'Œ¥‚ü©
    exact ‚ü®Œ¥, hŒ¥, h'Œ¥.1, h'Œ¥.2‚ü©
  suffices ‚àÄ·∂† i in l, ‚Äñ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ by
    filter_upwards [this] with i hi
    simp only [dist_zero_right]
    exact hi.trans_lt hŒ¥
  obtain ‚ü®u, u_open, x‚ÇÄu, ut, hu‚ü© :
      ‚àÉ u, IsOpen u ‚àß x‚ÇÄ ‚àà u ‚àß s ‚à© u ‚äÜ t ‚àß ‚àÄ x ‚àà u ‚à© s, g x ‚àà ball 0 Œ¥ := by
    rcases mem_nhdsWithin.1 (Filter.inter_mem h'ts (hcg (ball_mem_nhds _ Œ¥pos)))
      with ‚ü®u, u_open, x‚ÇÄu, hu‚ü©
    refine ‚ü®u, u_open, x‚ÇÄu, ?_, hu.trans inter_subset_right‚ü©
    rw [inter_comm]
    exact hu.trans inter_subset_left
  filter_upwards [tendstoUniformlyOn_iff.1 (hlœÜ u u_open x‚ÇÄu) Œ¥ Œ¥pos,
    (tendsto_order.1 (tendsto_iff_norm_sub_tendsto_zero.1 hiœÜ)).2 Œ¥ Œ¥pos, hnœÜ,
    integrableOn_peak_smul_of_integrableOn_of_tendsto hs h'ts hlœÜ hiœÜ h'iœÜ hmg hcg]
    with i hi h'i hœÜpos h''i
  have I : IntegrableOn (œÜ i) t Œº := by
    apply Integrable.of_integral_ne_zero (fun h ‚Ü¶ ?_)
    simp [h] at h'i
    linarith
  have B : ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ 2 * Œ¥ :=
    calc
      ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ ‚à´ x in s ‚à© u, ‚ÄñœÜ i x ‚Ä¢ g x‚Äñ ‚àÇŒº :=
        norm_integral_le_integral_norm _
      _ ‚â§ ‚à´ x in s ‚à© u, ‚ÄñœÜ i x‚Äñ * Œ¥ ‚àÇŒº := by
        refine setIntegral_mono_on ?_ ?_ (hs.inter u_open.measurableSet) fun x hx => ?_
        ¬∑ exact IntegrableOn.mono_set h''i.norm inter_subset_left
        ¬∑ exact IntegrableOn.mono_set (I.norm.mul_const _) ut
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)
        rw [inter_comm] at hu
        exact (mem_ball_zero_iff.1 (hu x hx)).le
      _ ‚â§ ‚à´ x in t, ‚ÄñœÜ i x‚Äñ * Œ¥ ‚àÇŒº := by
        apply setIntegral_mono_set
        ¬∑ exact I.norm.mul_const _
        ¬∑ exact eventually_of_forall fun x => mul_nonneg (norm_nonneg _) Œ¥pos.le
        ¬∑ exact eventually_of_forall ut
      _ = ‚à´ x in t, œÜ i x * Œ¥ ‚àÇŒº := by
        apply setIntegral_congr ht fun x hx => ?_
        rw [Real.norm_of_nonneg (hœÜpos _ (hts hx))]
      _ = (‚à´ x in t, œÜ i x ‚àÇŒº) * Œ¥ := by rw [integral_mul_right]
      _ ‚â§ 2 * Œ¥ := by gcongr; linarith [(le_abs_self _).trans h'i.le]
  have C : ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº :=
    calc
      ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ ‚â§ ‚à´ x in s \ u, ‚ÄñœÜ i x ‚Ä¢ g x‚Äñ ‚àÇŒº :=
        norm_integral_le_integral_norm _
      _ ‚â§ ‚à´ x in s \ u, Œ¥ * ‚Äñg x‚Äñ ‚àÇŒº := by
        refine setIntegral_mono_on ?_ ?_ (hs.diff u_open.measurableSet) fun x hx => ?_
        ¬∑ exact IntegrableOn.mono_set h''i.norm diff_subset
        ¬∑ exact IntegrableOn.mono_set (hmg.norm.const_mul _) diff_subset
        rw [norm_smul]
        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)
        simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le
      _ ‚â§ Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº := by
        rw [integral_mul_left]
        apply mul_le_mul_of_nonneg_left (setIntegral_mono_set hmg.norm _ _) Œ¥pos.le
        ¬∑ filter_upwards with x using norm_nonneg _
        ¬∑ filter_upwards using diff_subset (s := s) (t := u)
  calc
    ‚Äñ‚à´ x in s, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ =
      ‚Äñ(‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº) + ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ := by
      conv_lhs => rw [‚Üê diff_union_inter s u]
      rw [integral_union disjoint_sdiff_inter (hs.inter u_open.measurableSet)
          (h''i.mono_set diff_subset) (h''i.mono_set inter_subset_left)]
    _ ‚â§ ‚Äñ‚à´ x in s \ u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ + ‚Äñ‚à´ x in s ‚à© u, œÜ i x ‚Ä¢ g x ‚àÇŒº‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ * ‚à´ x in s, ‚Äñg x‚Äñ ‚àÇŒº) + 2 * Œ¥ := add_le_add C B"
Mathlib/MeasureTheory/Measure/EverywherePos.lean,MeasureTheory.Measure.everywherePosSubset_ae_eq_of_measure_ne_top,everywherePosSubset_ae_eq_of_measure_ne_top,1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493,":= by
  have A : Œº (s \ Œº.everywherePosSubset s) ‚â† ‚àû :=
    ((measure_mono (diff_subset _ _ )).trans_lt h's.lt_top).ne
  simp only [ae_eq_set, diff_eq_empty.mpr (everywherePosSubset_subset Œº s), measure_empty,
    true_and, (hs.diff hs.everywherePosSubset).measure_eq_iSup_isCompact_of_ne_top A,
    ENNReal.iSup_eq_zero]
  intro k hk h'k
  exact measure_eq_zero_of_subset_diff_everywherePosSubset h'k hk","error:  function expected at
  diff_subset ?m.30163
term has type
  ?m.30162 ‚àà ?m.30160","lemma everywherePosSubset_ae_eq_of_measure_ne_top
    [OpensMeasurableSpace Œ±] [InnerRegularCompactLTTop Œº] (hs : MeasurableSet s) (h's : Œº s ‚â† ‚àû) :
    Œº.everywherePosSubset s =·µê[Œº] s ",":= by
  have A : Œº (s \ Œº.everywherePosSubset s) ‚â† ‚àû :=
    ((measure_mono diff_subset).trans_lt h's.lt_top).ne
  simp only [ae_eq_set, diff_eq_empty.mpr (everywherePosSubset_subset Œº s), measure_empty,
    true_and, (hs.diff hs.everywherePosSubset).measure_eq_iSup_isCompact_of_ne_top A,
    ENNReal.iSup_eq_zero]
  intro k hk h'k
  exact measure_eq_zero_of_subset_diff_everywherePosSubset h'k hk"
Mathlib/Geometry/Manifold/ContMDiffMFDeriv.lean,TangentBundle.tangentMap_tangentBundle_pure,tangentMap_tangentBundle_pure,a9e5c97a54df0543783bff424b120a30b61a4aac,":= by
  rcases p with ‚ü®x, v‚ü©
  have N : I.symm ‚Åª¬π' (chartAt H x).target ‚àà ùìù (I ((chartAt H x) x)) := by
    apply IsOpen.mem_nhds
    apply (PartialHomeomorph.open_target _).preimage I.continuous_invFun
    simp only [mfld_simps]
  have A : MDifferentiableAt I I.tangent (fun x => @TotalSpace.mk M E (TangentSpace I) x 0) x :=
    haveI : Smooth I (I.prod ùìò(ùïú, E)) (zeroSection E (TangentSpace I : M ‚Üí Type _)) :=
      Bundle.smooth_zeroSection ùïú (TangentSpace I : M ‚Üí Type _)
    this.mdifferentiableAt
  have B :
    fderivWithin ùïú (fun x' : E => (x', (0 : E))) (Set.range I) (I ((chartAt H x) x)) v = (v, 0)
  ¬∑ rw [fderivWithin_eq_fderiv, DifferentiableAt.fderiv_prod]
    ¬∑ simp
    ¬∑ exact differentiableAt_id'
    ¬∑ exact differentiableAt_const _
    ¬∑ exact ModelWithCorners.unique_diff_at_image I
    ¬∑ exact differentiableAt_id'.prod (differentiableAt_const _)
  simp (config := { unfoldPartialApp := true }) only [Bundle.zeroSection, tangentMap, mfderiv, A,
    if_pos, chartAt, FiberBundle.chartedSpace_chartAt, TangentBundle.trivializationAt_apply,
    tangentBundleCore, Function.comp_def, ContinuousLinearMap.map_zero, mfld_simps]
  rw [‚Üê fderivWithin_inter N] at B
  rw [‚Üê fderivWithin_inter N, ‚Üê B]
  congr 1
  refine' fderivWithin_congr (fun y hy => _) _
  ¬∑ simp only [mfld_simps] at hy
    simp only [hy, Prod.mk.inj_iff, mfld_simps]
  ¬∑ simp only [Prod.mk.inj_iff, mfld_simps]","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case mk
ùïú : Type u_1
inst‚úù¬≤‚Å¥ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬≤¬≥ : NormedAddCommGroup E
inst‚úù¬≤¬≤ : NormedSpace ùïú E
H : Type u_3
inst‚úù¬≤¬π : TopologicalSpace H
I : ModelWithCorners ùïú E H
M : Type u_4
inst‚úù¬≤‚Å∞ : TopologicalSpace M
inst‚úù¬π‚Åπ : ChartedSpace H M
Is : SmoothManifoldWithCorners I M
E' : Type u_5
inst‚úù¬π‚Å∏ : NormedAddCommGroup E'
inst‚úù¬π‚Å∑ : NormedSpace ùïú E'
H' : Type u_6
inst‚úù¬π‚Å∂ : TopologicalSpace H'
I' : ModelWithCorners ùïú E' H'
M' : Type u_7
inst‚úù¬π‚Åµ : TopologicalSpace M'
inst‚úù¬π‚Å¥ : ChartedSpace H' M'
I's : SmoothManifoldWithCorners I' M'
F : Type u_8
inst‚úù¬π¬≥ : NormedAddCommGroup F
inst‚úù¬π¬≤ : NormedSpace ùïú F
G : Type u_9
inst‚úù¬π¬π : TopologicalSpace G
J : ModelWithCorners ùïú F G
N‚úù : Type u_10
inst‚úù¬π‚Å∞ : TopologicalSpace N‚úù
inst‚úù‚Åπ : ChartedSpace G N‚úù
Js : SmoothManifoldWithCorners J N‚úù
F' : Type u_11
inst‚úù‚Å∏ : NormedAddCommGroup F'
inst‚úù‚Å∑ : NormedSpace ùïú F'
G' : Type u_12
inst‚úù‚Å∂ : TopologicalSpace G'
J' : ModelWithCorners ùïú F' G'
N' : Type u_13
inst‚úù‚Åµ : TopologicalSpace N'
inst‚úù‚Å¥ : ChartedSpace G' N'
J's : SmoothManifoldWithCorners J' N'
F‚ÇÅ : Type u_14
inst‚úù¬≥ : NormedAddCommGroup F‚ÇÅ
inst‚úù¬≤ : NormedSpace ùïú F‚ÇÅ
F‚ÇÇ : Type u_15
inst‚úù¬π : NormedAddCommGroup F‚ÇÇ
inst‚úù : NormedSpace ùïú F‚ÇÇ
f f‚ÇÅ : M ‚Üí M'
s s‚ÇÅ t : Set M
x‚úù : M
m n : ‚Ñï‚àû
x : M
v : TangentSpace I x
N : ‚ÜëI.symm ‚Åª¬π' (chartAt H x).target ‚àà ùìù (‚ÜëI (‚Üë(chartAt H x) x))
A : MDifferentiableAt I I.tangent (fun x ‚Ü¶ { proj := x, snd := 0 }) x
B : (fderivWithin ùïú (fun x' ‚Ü¶ (x', 0)) (range ‚ÜëI) (‚ÜëI (‚Üë(chartAt H x) x))) v = (v, 0)
‚ä¢ tangentMap I I.tangent (zeroSection E (TangentSpace I)) { proj := x, snd := v } =
    { proj := { proj := { proj := x, snd := v }.proj, snd := 0 }, snd := ({ proj := x, snd := v }.snd, 0) }","theorem tangentMap_tangentBundle_pure (p : TangentBundle I M) :
    tangentMap I I.tangent (zeroSection E (TangentSpace I)) p = ‚ü®‚ü®p.proj, 0‚ü©, ‚ü®p.2, 0‚ü©‚ü© ",":= by
  rcases p with ‚ü®x, v‚ü©
  have N : I.symm ‚Åª¬π' (chartAt H x).target ‚àà ùìù (I ((chartAt H x) x)) := by
    apply IsOpen.mem_nhds
    ¬∑ apply (PartialHomeomorph.open_target _).preimage I.continuous_invFun
    ¬∑ simp only [mfld_simps]
  have A : MDifferentiableAt I I.tangent (fun x => @TotalSpace.mk M E (TangentSpace I) x 0) x :=
    haveI : Smooth I (I.prod ùìò(ùïú, E)) (zeroSection E (TangentSpace I : M ‚Üí Type _)) :=
      Bundle.smooth_zeroSection ùïú (TangentSpace I : M ‚Üí Type _)
    this.mdifferentiableAt
  have B : fderivWithin ùïú (fun x' : E ‚Ü¶ (x', (0 : E))) (Set.range I) (I ((chartAt H x) x)) v
      = (v, 0) := by
    rw [fderivWithin_eq_fderiv, DifferentiableAt.fderiv_prod]
    ¬∑ simp
    ¬∑ exact differentiableAt_id'
    ¬∑ exact differentiableAt_const _
    ¬∑ exact ModelWithCorners.unique_diff_at_image I
    ¬∑ exact differentiableAt_id'.prod (differentiableAt_const _)
  simp (config := { unfoldPartialApp := true }) only [Bundle.zeroSection, tangentMap, mfderiv, A,
    if_pos, chartAt, FiberBundle.chartedSpace_chartAt, TangentBundle.trivializationAt_apply,
    tangentBundleCore, Function.comp_def, ContinuousLinearMap.map_zero, mfld_simps]
  rw [‚Üê fderivWithin_inter N] at B
  rw [‚Üê fderivWithin_inter N, ‚Üê B]
  congr 1
  refine fderivWithin_congr (fun y hy => ?_) ?_
  ¬∑ simp only [mfld_simps] at hy
    simp only [hy, Prod.mk.inj_iff, mfld_simps]
  ¬∑ simp only [Prod.mk.inj_iff, mfld_simps]"
Mathlib/Data/List/OfFn.lean,List.ofFn_add,ofFn_add,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  induction' n with n IH
  ¬∑ rw [ofFn_zero, append_nil, Fin.castAdd_zero, Fin.castIso_refl]
    rfl
  ¬∑ rw [ofFn_succ', ofFn_succ', IH, append_concat]
    rfl","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_ofFn` has been deprecated, use `List.get_ofFn` instead
warning:  `Fin.castIso_refl` has been deprecated, use `Fin.castOrderIso_refl` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Fin.castOrderIso ‚ãØ
case zero
Œ± : Type u
m : ‚Ñï
f : Fin (m + 0) ‚Üí Œ±
‚ä¢ ofFn f = ofFn fun i ‚Ü¶ f (Fin.cast ‚ãØ i)
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem ofFn_add {m n} (f : Fin (m + n) ‚Üí Œ±) :
    List.ofFn f =
      (List.ofFn fun i => f (Fin.castAdd n i)) ++ List.ofFn fun j => f (Fin.natAdd m j) ",":= by
  induction' n with n IH
  ¬∑ rw [ofFn_zero, append_nil, Fin.castAdd_zero, Fin.cast_refl]
    rfl
  ¬∑ rw [ofFn_succ', ofFn_succ', IH, append_concat]
    rfl"
Mathlib/LinearAlgebra/Basis.lean,Basis.maximal,maximal,5068808d2b4c25cf905cf7fee10ded8e447c2346,":= fun w hi h => by
  apply le_antisymm h
  intro x p
  by_contra q
  have e := b.total_repr x
  let u : Œπ ‚Ü™ w :=
    ‚ü®fun i => ‚ü®b i, h ‚ü®i, rfl‚ü©‚ü©, fun i i' r =>
      b.injective (by simpa only [Subtype.mk_eq_mk] using r)‚ü©
  simp_rw [Finsupp.total_apply] at e
  replace e : ((b.repr x).sum fun (i : Œπ) (a : R) ‚Ü¶ a ‚Ä¢ (u i : M)) =
      ((‚ü®x, p‚ü© : w) : M) := e
  rw [‚Üê Finsupp.sum_embDomain (f := u) (g := fun x r ‚Ü¶ r ‚Ä¢ (x : M)), ‚Üê Finsupp.total_apply] at e
  refine' hi.total_ne_of_not_mem_support _ _ e
  simp only [Finset.mem_map, Finsupp.support_embDomain]
  rintro ‚ü®j, -, W‚ü©
  simp only [Embedding.coeFn_mk, Subtype.mk_eq_mk] at W
  apply q ‚ü®j, W‚ü©",error:  simp made no progress,theorem maximal [Nontrivial R] (b : Basis Œπ R M) : b.linearIndependent.Maximal ,":= fun w hi h => by
  apply le_antisymm h
  intro x p
  by_contra q
  have e := b.total_repr x
  let u : Œπ ‚Ü™ w :=
    ‚ü®fun i => ‚ü®b i, h ‚ü®i, rfl‚ü©‚ü©, fun i i' r =>
      b.injective (by simpa only [Subtype.mk_eq_mk] using r)‚ü©
  simp_rw [Finsupp.total_apply] at e
  change ((b.repr x).sum fun (i : Œπ) (a : R) ‚Ü¶ a ‚Ä¢ (u i : M)) = ((‚ü®x, p‚ü© : w) : M) at e
  rw [‚Üê Finsupp.sum_embDomain (f := u) (g := fun x r ‚Ü¶ r ‚Ä¢ (x : M)), ‚Üê Finsupp.total_apply] at e
  refine hi.total_ne_of_not_mem_support _ ?_ e
  simp only [Finset.mem_map, Finsupp.support_embDomain]
  rintro ‚ü®j, -, W‚ü©
  simp only [u, Embedding.coeFn_mk, Subtype.mk_eq_mk] at W
  apply q ‚ü®j, W‚ü©"
Mathlib/Algebra/Lie/CartanExists.lean,LieAlgebra.engel_isBot_of_isMin,engel_isBot_of_isMin,2d8928f07c222f171d2f9371935aa5b8359f9d44,":= by
  rcases E with ‚ü®_, x, hxU, rfl‚ü©
  rintro ‚ü®_, y, hyU, rfl‚ü©
  set Ex : {engel K x | x ‚àà U} := ‚ü®engel K x, x, hxU, rfl‚ü©
  set Ey : {engel K y | y ‚àà U} := ‚ü®engel K y, y, hyU, rfl‚ü©
  replace hUle : U ‚â§ Ex := hUle
  replace hmin : ‚àÄ E, E ‚â§ Ex ‚Üí Ex ‚â§ E := @hmin
  let E : LieSubmodule K U L :=
  { engel K x with
    lie_mem := by rintro ‚ü®u, hu‚ü© y hy; exact (engel K x).lie_mem (hUle hu) hy }
  obtain rfl|hx‚ÇÄ := eq_or_ne x 0
  ¬∑ simpa [Ex, Ey] using hmin Ey
  let Q := L ‚ß∏ E
  let r := finrank K E
  obtain hr|hr : r = finrank K L ‚à® r < finrank K L := (Submodule.finrank_le _).eq_or_lt
  ¬∑ suffices engel K y ‚â§ engel K x from hmin Ey this
    suffices engel K x = ‚ä§ by simp_rw [this, le_top]
    apply LieSubalgebra.to_submodule_injective
    apply Submodule.eq_top_of_finrank_eq hr
  set x' : U := ‚ü®x, hxU‚ü©
  set y' : U := ‚ü®y, hyU‚ü©
  let u : U := y' - x'
  let œá : Polynomial (K[X]) := lieCharpoly K E x' u
  let œà : Polynomial (K[X]) := lieCharpoly K Q x' u
  suffices œá = X ^ r by
    apply_fun (fun p ‚Ü¶ p.map (evalRingHom 1)) at this
    simp_rw [Polynomial.map_pow, map_X, œá, lieCharpoly_map_eval, one_smul, u, sub_add_cancel,
      r, LinearMap.charpoly_eq_X_pow_iff,
      Subtype.ext_iff, coe_toEndomorphism_pow, ZeroMemClass.coe_zero] at this
    intro z hz
    rw [mem_engel_iff]
    exact this ‚ü®z, hz‚ü©
  suffices ‚àÄ i < r, œá.coeff i = 0 by
    simp_rw [r, ‚Üê lieCharpoly_natDegree K E x' u] at this ‚ä¢
    rw [(lieCharpoly_monic K E x' u).eq_X_pow_iff_natDegree_le_natTrailingDegree]
    exact le_natTrailingDegree (lieCharpoly_monic K E x' u).ne_zero this
  intro i hi
  obtain rfl|hi0 := eq_or_ne i 0
  ¬∑ 
    apply eq_zero_of_forall_eval_zero_of_natDegree_lt_card _ _ ?deg
    case deg =>
      apply lt_of_lt_of_le _ hLK
      rw [Nat.cast_lt]
      apply lt_of_le_of_lt _ hr
      apply lieCharpoly_coeff_natDegree _ _ _ _ 0 r (zero_add r)
    intro Œ±
    rw [‚Üê coe_evalRingHom, ‚Üê coeff_map, lieCharpoly_map_eval,
      ‚Üê constantCoeff_apply, LinearMap.charpoly_constantCoeff_eq_zero_iff]
    let z := Œ± ‚Ä¢ u + x'
    obtain hz‚ÇÄ|hz‚ÇÄ := eq_or_ne z 0
    ¬∑ 
      refine ‚ü®‚ü®x, self_mem_engel K x‚ü©, ?_, ?_‚ü©
      ¬∑ simpa [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero] using hx‚ÇÄ
      ¬∑ dsimp only [z] at hz‚ÇÄ
        simp only [coe_bracket_of_module, hz‚ÇÄ, LieHom.map_zero, LinearMap.zero_apply]
    refine ‚ü®‚ü®z, hUle z.2‚ü©, ?_, ?_‚ü©
    ¬∑ simpa only [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero, Subtype.ext_iff] using hz‚ÇÄ
    ¬∑ show ‚ÅÖz, _‚ÅÜ = (0 : E)
      ext
      exact lie_self z.1
  have hœà : constantCoeff œà ‚â† 0 := by
    intro H
    obtain ‚ü®z, hz0, hxz‚ü© : ‚àÉ z : Q, z ‚â† 0 ‚àß ‚ÅÖx', z‚ÅÜ = 0 := by
      apply_fun (evalRingHom 0) at H
      rw [constantCoeff_apply, ‚Üê coeff_map, lieCharpoly_map_eval,
        ‚Üê constantCoeff_apply, map_zero, LinearMap.charpoly_constantCoeff_eq_zero_iff] at H
      simpa only [coe_bracket_of_module, ne_eq, zero_smul, zero_add, toEndomorphism_apply_apply]
        using H
    apply hz0
    obtain ‚ü®z, rfl‚ü© := LieSubmodule.Quotient.surjective_mk' E z
    have : ‚ÅÖx, z‚ÅÜ ‚àà E := by rwa [‚Üê LieSubmodule.Quotient.mk_eq_zero']
    simp only [coe_bracket_of_module, LieSubmodule.mem_mk_iff', mem_coe_submodule, mem_engel_iff,
      LieSubmodule.Quotient.mk'_apply, LieSubmodule.Quotient.mk_eq_zero', E, Q] at this ‚ä¢
    obtain ‚ü®n, hn‚ü© := this
    use n+1
    rwa [pow_succ]
  obtain ‚ü®s, hs, hsœà‚ü© : ‚àÉ s : Finset K, r ‚â§ s.card ‚àß ‚àÄ Œ± ‚àà s, (constantCoeff œà).eval Œ± ‚â† 0 := by
    classical
    let t := (constantCoeff œà).roots.toFinset
    have ht : t.card ‚â§ finrank K L - r := by
      refine (Multiset.toFinset_card_le _).trans ?_
      refine (card_roots' _).trans ?_
      rw [constantCoeff_apply]
      apply lieCharpoly_coeff_natDegree
      suffices finrank K Q + r = finrank K L by rw [‚Üê this, zero_add, Nat.add_sub_cancel]
      apply Submodule.finrank_quotient_add_finrank
    obtain ‚ü®s, hs‚ü© := exists_finset_le_card K _ hLK
    use s \ t
    refine ‚ü®?_, ?_‚ü©
    ¬∑ refine le_trans ?_ (Finset.le_card_sdiff _ _)
      omega
    ¬∑ intro Œ± hŒ±
      simp only [Finset.mem_sdiff, Multiset.mem_toFinset, mem_roots', IsRoot.def, not_and, t] at hŒ±
      exact hŒ±.2 hœà
  apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero' _ s _ ?hcard
  case hcard =>
    apply lt_of_le_of_lt (lieCharpoly_coeff_natDegree _ _ _ _ i (r - i) _)
    ¬∑ omega
    ¬∑ dsimp only [r] at hi ‚ä¢
      rw [Nat.add_sub_cancel' hi.le]
  intro Œ± hŒ±
  rw [‚Üê coe_evalRingHom, ‚Üê coeff_map, lieCharpoly_map_eval,
    (LinearMap.charpoly_eq_X_pow_iff _).mpr, coeff_X_pow, if_neg hi.ne]
  let v := Œ± ‚Ä¢ u + x'
  suffices engel K (v : L) ‚â§ engel K x by
    replace this : engel K x ‚â§ engel K (v : L) := (hmin ‚ü®_, v, v.2, rfl‚ü© this).ge
    intro z
    simpa only [mem_engel_iff, Subtype.ext_iff, coe_toEndomorphism_pow] using this z.2
  intro z hz
  show z ‚àà E
  rw [‚Üê LieSubmodule.Quotient.mk_eq_zero]
  set z' : Q := LieSubmodule.Quotient.mk' E z
  have hz' : ‚àÉ n : ‚Ñï, (toEndomorphism K U Q v ^ n) z' = 0 := by
    rw [mem_engel_iff] at hz
    obtain ‚ü®n, hn‚ü© := hz
    use n
    apply_fun LieSubmodule.Quotient.mk' E at hn
    rw [LieModuleHom.map_zero] at hn
    rw [‚Üê hn]
    clear hn
    induction n with
    | zero => simp only [Nat.zero_eq, pow_zero, LinearMap.one_apply]
    | succ n ih => rw [pow_succ', pow_succ', LinearMap.mul_apply, ih]; rfl
  classical
  set n := Nat.find hz' with _hn
  have hn : (toEndomorphism K U Q v ^ n) z' = 0 := Nat.find_spec hz'
  obtain hn‚ÇÄ|‚ü®k, hk‚ü© : n = 0 ‚à® ‚àÉ k, n = k + 1 := by cases n <;> simp
  ¬∑ simpa only [hn‚ÇÄ, pow_zero, LinearMap.one_apply] using hn
  specialize hsœà Œ± hŒ±
  rw [‚Üê coe_evalRingHom, constantCoeff_apply, ‚Üê coeff_map, lieCharpoly_map_eval,
    ‚Üê constantCoeff_apply, ne_eq, LinearMap.charpoly_constantCoeff_eq_zero_iff] at hsœà
  contrapose! hsœà
  use (toEndomorphism K U Q v ^ k) z'
  refine ‚ü®?_, ?_‚ü©
  ¬∑ 
    apply Nat.find_min hz'; omega
  ¬∑ rw [‚Üê hn, hk, pow_succ', LinearMap.mul_apply]","error:  unknown identifier 'coe_toEndomorphism_pow'
error:  simp made no progress
error:  unknown identifier 'toEndomorphism_apply_apply'
error:  unknown identifier 'coe_toEndomorphism_pow'
error:  type mismatch
  h‚úù
has type
  ‚àÉ n, ((ad K L) ‚Üëv ^ n) ‚Üëz = 0 : Prop
but is expected to have type
  ‚àÉ n, ‚Üë(((toEnd K ‚Ü•U ‚Ü•(engel K x).toSubmodule) (Œ± ‚Ä¢ u + x') ^ n) z) = ‚Üë0 : Prop
error:  unknown identifier 'toEndomorphism'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  0
case h
K : Type u_1
L : Type u_2
inst‚úù¬≥ : Field K
inst‚úù¬≤ : LieRing L
inst‚úù¬π : LieAlgebra K L
inst‚úù : Module.Finite K L
hLK : ‚Üë(finrank K L) ‚â§ #K
U : LieSubalgebra K L
x : L
hxU : x ‚àà U
y : L
hyU : y ‚àà U
Ex : ‚Üë{x | ‚àÉ x_1 ‚àà U, engel K x_1 = x} := ‚ü®engel K x, ‚ãØ‚ü©
Ey : ‚Üë{x | ‚àÉ y ‚àà U, engel K y = x} := ‚ü®engel K y, ‚ãØ‚ü©
hUle : U ‚â§ ‚ÜëEx
hmin : ‚àÄ E ‚â§ Ex, Ex ‚â§ E
E : LieSubmodule K (‚Ü•U) L :=
  let __src := engel K x;
  { toSubmodule := __src.toSubmodule, lie_mem := ‚ãØ }
hx‚ÇÄ : x ‚â† 0
Q : Type u_2 := L ‚ß∏ E
r : ‚Ñï := finrank K ‚Ü•‚ÜëE
hr : r < finrank K L
x' : ‚Ü•U := ‚ü®x, hxU‚ü©
y' : ‚Ü•U := ‚ü®y, hyU‚ü©
u : ‚Ü•U := y' - x'
œá : K[X][X] := LieAlgebra.engel_isBot_of_isMin.lieCharpoly K (‚Ü•‚ÜëE) x' u
œà : K[X][X] := LieAlgebra.engel_isBot_of_isMin.lieCharpoly K Q x' u
i : ‚Ñï
hi : i < r
hi0 : i ‚â† 0
hœà : constantCoeff œà ‚â† 0
s : Finset K
hs : r ‚â§ s.card
hsœà : ‚àÄ Œ± ‚àà s, eval Œ± (constantCoeff œà) ‚â† 0
Œ± : K
hŒ± : Œ± ‚àà s
v : ‚Ü•U := Œ± ‚Ä¢ u + x'
z : L
z' : Q := (LieSubmodule.Quotient.mk' E) z
n : ‚Ñï
hn : (LieSubmodule.Quotient.mk' E) (((ad K L) ‚Üëv ^ n) z) = 0
‚ä¢ sorryAx ‚Ñï true = 0
error:  unknown identifier 'toEndomorphism'
error:  unknown identifier 'toEndomorphism'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  0
case h.refine_2
K : Type u_1
L : Type u_2
inst‚úù¬≥ : Field K
inst‚úù¬≤ : LieRing L
inst‚úù¬π : LieAlgebra K L
inst‚úù : Module.Finite K L
hLK : ‚Üë(finrank K L) ‚â§ #K
U : LieSubalgebra K L
x : L
hxU : x ‚àà U
y : L
hyU : y ‚àà U
Ex : ‚Üë{x | ‚àÉ x_1 ‚àà U, engel K x_1 = x} := ‚ü®engel K x, ‚ãØ‚ü©
Ey : ‚Üë{x | ‚àÉ y ‚àà U, engel K y = x} := ‚ü®engel K y, ‚ãØ‚ü©
hUle : U ‚â§ ‚ÜëEx
hmin : ‚àÄ E ‚â§ Ex, Ex ‚â§ E
E : LieSubmodule K (‚Ü•U) L :=
  let __src := engel K x;
  { toSubmodule := __src.toSubmodule, lie_mem := ‚ãØ }
hx‚ÇÄ : x ‚â† 0
Q : Type u_2 := L ‚ß∏ E
r : ‚Ñï := finrank K ‚Ü•‚ÜëE
hr : r < finrank K L
x' : ‚Ü•U := ‚ü®x, hxU‚ü©
y' : ‚Ü•U := ‚ü®y, hyU‚ü©
u : ‚Ü•U := y' - x'
œá : K[X][X] := LieAlgebra.engel_isBot_of_isMin.lieCharpoly K (‚Ü•‚ÜëE) x' u
œà : K[X][X] := LieAlgebra.engel_isBot_of_isMin.lieCharpoly K Q x' u
i : ‚Ñï
hi : i < r
hi0 : i ‚â† 0
hœà : constantCoeff œà ‚â† 0
s : Finset K
hs : r ‚â§ s.card
Œ± : K
hŒ± : Œ± ‚àà s
v : ‚Ü•U := Œ± ‚Ä¢ u + x'
z : L
hz : z ‚àà engel K ‚Üëv
z' : Q := (LieSubmodule.Quotient.mk' E) z
hz' : ‚àÉ n, sorryAx ‚Ñï true = 0
n : ‚Ñï := Nat.find hz'
_hn : n = Nat.find hz'
hn : sorryAx ‚Ñï true = 0
k : ‚Ñï
hk : n = k + 1
hsœà : z' ‚â† 0
‚ä¢ ((toEnd K (‚Ü•U) Q) (Œ± ‚Ä¢ u + x')) (sorryAx Q true) = 0","lemma engel_isBot_of_isMin (hLK : finrank K L ‚â§ #K) (U : LieSubalgebra K L)
    (E : {engel K x | x ‚àà U}) (hUle : U ‚â§ E) (hmin : IsMin E) :
    IsBot E ",":= by
  rcases E with ‚ü®_, x, hxU, rfl‚ü©
  rintro ‚ü®_, y, hyU, rfl‚ü©
  set Ex : {engel K x | x ‚àà U} := ‚ü®engel K x, x, hxU, rfl‚ü©
  set Ey : {engel K y | y ‚àà U} := ‚ü®engel K y, y, hyU, rfl‚ü©
  replace hUle : U ‚â§ Ex := hUle
  replace hmin : ‚àÄ E, E ‚â§ Ex ‚Üí Ex ‚â§ E := @hmin
  let E : LieSubmodule K U L :=
  { engel K x with
    lie_mem := by rintro ‚ü®u, hu‚ü© y hy; exact (engel K x).lie_mem (hUle hu) hy }
  obtain rfl|hx‚ÇÄ := eq_or_ne x 0
  ¬∑ simpa [Ex, Ey] using hmin Ey
  let Q := L ‚ß∏ E
  let r := finrank K E
  obtain hr|hr : r = finrank K L ‚à® r < finrank K L := (Submodule.finrank_le _).eq_or_lt
  ¬∑ suffices engel K y ‚â§ engel K x from hmin Ey this
    suffices engel K x = ‚ä§ by simp_rw [this, le_top]
    apply LieSubalgebra.to_submodule_injective
    apply Submodule.eq_top_of_finrank_eq hr
  set x' : U := ‚ü®x, hxU‚ü©
  set y' : U := ‚ü®y, hyU‚ü©
  let u : U := y' - x'
  let œá : Polynomial (K[X]) := lieCharpoly K E x' u
  let œà : Polynomial (K[X]) := lieCharpoly K Q x' u
  suffices œá = X ^ r by
    apply_fun (fun p ‚Ü¶ p.map (evalRingHom 1)) at this
    simp_rw [Polynomial.map_pow, map_X, œá, lieCharpoly_map_eval, one_smul, u, sub_add_cancel,
      r, LinearMap.charpoly_eq_X_pow_iff,
      Subtype.ext_iff, coe_toEnd_pow _ _ _ E, ZeroMemClass.coe_zero] at this
    intro z hz
    rw [mem_engel_iff]
    exact this ‚ü®z, hz‚ü©
  suffices ‚àÄ i < r, œá.coeff i = 0 by
    simp_rw [r, ‚Üê lieCharpoly_natDegree K E x' u] at this ‚ä¢
    rw [(lieCharpoly_monic K E x' u).eq_X_pow_iff_natDegree_le_natTrailingDegree]
    exact le_natTrailingDegree (lieCharpoly_monic K E x' u).ne_zero this
  intro i hi
  obtain rfl|hi0 := eq_or_ne i 0
  ¬∑ 
    apply eq_zero_of_forall_eval_zero_of_natDegree_lt_card _ _ ?deg
    case deg =>
      apply lt_of_lt_of_le _ hLK
      rw [Nat.cast_lt]
      apply lt_of_le_of_lt _ hr
      apply lieCharpoly_coeff_natDegree _ _ _ _ 0 r (zero_add r)
    intro Œ±
    rw [‚Üê coe_evalRingHom, ‚Üê coeff_map, lieCharpoly_map_eval,
      ‚Üê constantCoeff_apply, LinearMap.charpoly_constantCoeff_eq_zero_iff]
    let z := Œ± ‚Ä¢ u + x'
    obtain hz‚ÇÄ|hz‚ÇÄ := eq_or_ne z 0
    ¬∑ 
      refine ‚ü®‚ü®x, self_mem_engel K x‚ü©, ?_, ?_‚ü©
      ¬∑ simpa [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero] using hx‚ÇÄ
      ¬∑ dsimp only [z] at hz‚ÇÄ
        simp only [coe_bracket_of_module, hz‚ÇÄ, LieHom.map_zero, LinearMap.zero_apply]
    refine ‚ü®‚ü®z, hUle z.2‚ü©, ?_, ?_‚ü©
    ¬∑ simpa only [coe_bracket_of_module, ne_eq, Submodule.mk_eq_zero, Subtype.ext_iff] using hz‚ÇÄ
    ¬∑ show ‚ÅÖz, _‚ÅÜ = (0 : E)
      ext
      exact lie_self z.1
  have hœà : constantCoeff œà ‚â† 0 := by
    intro H
    obtain ‚ü®z, hz0, hxz‚ü© : ‚àÉ z : Q, z ‚â† 0 ‚àß ‚ÅÖx', z‚ÅÜ = 0 := by
      apply_fun (evalRingHom 0) at H
      rw [constantCoeff_apply, ‚Üê coeff_map, lieCharpoly_map_eval,
        ‚Üê constantCoeff_apply, map_zero, LinearMap.charpoly_constantCoeff_eq_zero_iff] at H
      simpa only [coe_bracket_of_module, ne_eq, zero_smul, zero_add, toEnd_apply_apply]
        using H
    apply hz0
    obtain ‚ü®z, rfl‚ü© := LieSubmodule.Quotient.surjective_mk' E z
    have : ‚ÅÖx, z‚ÅÜ ‚àà E := by rwa [‚Üê LieSubmodule.Quotient.mk_eq_zero']
    simp only [coe_bracket_of_module, LieSubmodule.mem_mk_iff', mem_coe_submodule, mem_engel_iff,
      LieSubmodule.Quotient.mk'_apply, LieSubmodule.Quotient.mk_eq_zero', E, Q] at this ‚ä¢
    obtain ‚ü®n, hn‚ü© := this
    use n+1
    rwa [pow_succ]
  obtain ‚ü®s, hs, hsœà‚ü© : ‚àÉ s : Finset K, r ‚â§ s.card ‚àß ‚àÄ Œ± ‚àà s, (constantCoeff œà).eval Œ± ‚â† 0 := by
    classical
    let t := (constantCoeff œà).roots.toFinset
    have ht : t.card ‚â§ finrank K L - r := by
      refine (Multiset.toFinset_card_le _).trans ?_
      refine (card_roots' _).trans ?_
      rw [constantCoeff_apply]
      apply lieCharpoly_coeff_natDegree
      suffices finrank K Q + r = finrank K L by rw [‚Üê this, zero_add, Nat.add_sub_cancel]
      apply Submodule.finrank_quotient_add_finrank
    obtain ‚ü®s, hs‚ü© := exists_finset_le_card K _ hLK
    use s \ t
    refine ‚ü®?_, ?_‚ü©
    ¬∑ refine le_trans ?_ (Finset.le_card_sdiff _ _)
      omega
    ¬∑ intro Œ± hŒ±
      simp only [Finset.mem_sdiff, Multiset.mem_toFinset, mem_roots', IsRoot.def, not_and, t] at hŒ±
      exact hŒ±.2 hœà
  apply eq_zero_of_natDegree_lt_card_of_eval_eq_zero' _ s _ ?hcard
  case hcard =>
    apply lt_of_le_of_lt (lieCharpoly_coeff_natDegree _ _ _ _ i (r - i) _)
    ¬∑ omega
    ¬∑ dsimp only [r] at hi ‚ä¢
      rw [Nat.add_sub_cancel' hi.le]
  intro Œ± hŒ±
  rw [‚Üê coe_evalRingHom, ‚Üê coeff_map, lieCharpoly_map_eval,
    (LinearMap.charpoly_eq_X_pow_iff _).mpr, coeff_X_pow, if_neg hi.ne]
  let v := Œ± ‚Ä¢ u + x'
  suffices engel K (v : L) ‚â§ engel K x by
    replace this : engel K x ‚â§ engel K (v : L) := (hmin ‚ü®_, v, v.2, rfl‚ü© this).ge
    intro z
    simpa only [mem_engel_iff, Subtype.ext_iff, coe_toEnd_pow _ _ _ E] using this z.2
  intro z hz
  show z ‚àà E
  rw [‚Üê LieSubmodule.Quotient.mk_eq_zero]
  set z' : Q := LieSubmodule.Quotient.mk' E z
  have hz' : ‚àÉ n : ‚Ñï, (toEnd K U Q v ^ n) z' = 0 := by
    rw [mem_engel_iff] at hz
    obtain ‚ü®n, hn‚ü© := hz
    use n
    apply_fun LieSubmodule.Quotient.mk' E at hn
    rw [LieModuleHom.map_zero] at hn
    rw [‚Üê hn]
    clear hn
    induction n with
    | zero => simp only [Nat.zero_eq, pow_zero, LinearMap.one_apply]
    | succ n ih => rw [pow_succ', pow_succ', LinearMap.mul_apply, ih]; rfl
  classical
  set n := Nat.find hz' with _hn
  have hn : (toEnd K U Q v ^ n) z' = 0 := Nat.find_spec hz'
  obtain hn‚ÇÄ|‚ü®k, hk‚ü© : n = 0 ‚à® ‚àÉ k, n = k + 1 := by cases n <;> simp
  ¬∑ simpa only [hn‚ÇÄ, pow_zero, LinearMap.one_apply] using hn
  specialize hsœà Œ± hŒ±
  rw [‚Üê coe_evalRingHom, constantCoeff_apply, ‚Üê coeff_map, lieCharpoly_map_eval,
    ‚Üê constantCoeff_apply, ne_eq, LinearMap.charpoly_constantCoeff_eq_zero_iff] at hsœà
  contrapose! hsœà
  use (toEnd K U Q v ^ k) z'
  refine ‚ü®?_, ?_‚ü©
  ¬∑ 
    apply Nat.find_min hz'; omega
  ¬∑ rw [‚Üê hn, hk, pow_succ', LinearMap.mul_apply]"
Mathlib/MeasureTheory/Function/Jacobian.lean,ApproximatesLinearOn.norm_fderiv_sub_le,_root_.ApproximatesLinearOn.norm_fderiv_sub_le,442e70a0f01607f243b47e1f187212240d8169d9,":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.op_norm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ
  ¬∑ have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by continuity) 0) nhdsWithin_le_nhds
    simp only [add_zero, MulZeroClass.mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 (IsLittleO.def (hf' x xs) Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset bounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel'_right]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := (norm_add_le _ _)
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel', sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := (norm_sub_le _ _)
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel', norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
        mul_le_mul_of_nonneg_left norm_a (mul_nonneg rpos.le (add_nonneg Œ¥.2 Œµpos.le))
  show ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ;
  exact
    calc
      ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := (norm_add_le _ _)
      _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
        apply add_le_add
        ¬∑ rw [mul_assoc] at I ; exact (mul_le_mul_left rpos).1 I
        ¬∑ apply ContinuousLinearMap.le_op_norm
      _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ :=
        add_le_add le_rfl
          (mul_le_mul_of_nonneg_left (mem_closedBall_iff_norm'.1 az) (norm_nonneg _))",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem _root_.ApproximatesLinearOn.norm_fderiv_sub_le {A : E ‚ÜíL[‚Ñù] E} {Œ¥ : ‚Ñù‚â•0}
    (hf : ApproximatesLinearOn f A s Œ¥) (hs : MeasurableSet s) (f' : E ‚Üí E ‚ÜíL[‚Ñù] E)
    (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) : ‚àÄ·µê x ‚àÇŒº.restrict s, ‚Äñf' x - A‚Äñ‚Çä ‚â§ Œ¥ ",":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ by
    have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by fun_prop) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel_left, sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := norm_sub_le _ _
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel_left, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) := by gcongr
  calc
    ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
      congr 1
      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
      abel
    _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
      apply add_le_add
      ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
      ¬∑ apply ContinuousLinearMap.le_opNorm
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ := by
      rw [mem_closedBall_iff_norm'] at az
      gcongr"
Mathlib/MeasureTheory/Integral/DivergenceTheorem.lean,MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable_aux‚ÇÅ,integral_divergence_of_hasFDerivWithinAt_off_countable_aux‚ÇÅ,3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  simp only [‚Üê setIntegral_congr_set_ae (Box.coe_ae_eq_Icc _)]
  have A := (Hi.mono_set Box.coe_subset_Icc).hasBoxIntegral ‚ä• rfl
  have B :=
    hasIntegral_GP_divergence_of_forall_hasDerivWithinAt I f f' (s ‚à© Box.Icc I)
      (hs.mono (inter_subset_left _ _)) (fun x hx => Hc _ hx.2) fun x hx =>
      Hd _ ‚ü®hx.1, fun h => hx.2 ‚ü®h, hx.1‚ü©‚ü©
  rw [continuousOn_pi] at Hc
  refine' (A.unique B).trans (sum_congr rfl fun i _ => _)
  refine congr_arg‚ÇÇ Sub.sub ?_ ?_
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.right_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.left_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq","error:  overloaded, errors 
  function expected at
    Finset.inter_subset_left ?m.17305
  term has type
    ?m.17304 ‚àà ?m.17302
  
  function expected at
    Set.inter_subset_left ?m.17442
  term has type
    ?m.17441 ‚àà ?m.17439","theorem integral_divergence_of_hasFDerivWithinAt_off_countable_aux‚ÇÅ (I : Box (Fin (n + 1)))
    (f : ‚Ñù‚Åø‚Å∫¬π ‚Üí E‚Åø‚Å∫¬π)
    (f' : ‚Ñù‚Åø‚Å∫¬π ‚Üí ‚Ñù‚Åø‚Å∫¬π ‚ÜíL[‚Ñù] E‚Åø‚Å∫¬π) (s : Set ‚Ñù‚Åø‚Å∫¬π)
    (hs : s.Countable) (Hc : ContinuousOn f (Box.Icc I))
    (Hd : ‚àÄ x ‚àà (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x)
    (Hi : IntegrableOn (fun x => ‚àë i, f' x (e i) i) (Box.Icc I)) :
    (‚à´ x in Box.Icc I, ‚àë i, f' x (e i) i) =
      ‚àë i : Fin (n + 1),
        ((‚à´ x in Box.Icc (I.face i), f (i.insertNth (I.upper i) x) i) -
          ‚à´ x in Box.Icc (I.face i), f (i.insertNth (I.lower i) x) i) ",":= by
  simp only [‚Üê setIntegral_congr_set_ae (Box.coe_ae_eq_Icc _)]
  have A := (Hi.mono_set Box.coe_subset_Icc).hasBoxIntegral ‚ä• rfl
  have B :=
    hasIntegral_GP_divergence_of_forall_hasDerivWithinAt I f f' (s ‚à© Box.Icc I)
      (hs.mono inter_subset_left) (fun x hx => Hc _ hx.2) fun x hx =>
      Hd _ ‚ü®hx.1, fun h => hx.2 ‚ü®h, hx.1‚ü©‚ü©
  rw [continuousOn_pi] at Hc
  refine (A.unique B).trans (sum_congr rfl fun i _ => ?_)
  refine congr_arg‚ÇÇ Sub.sub ?_ ?_
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.right_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq
  ¬∑ have := Box.continuousOn_face_Icc (Hc i) (Set.left_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Œº := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral ‚ä• rfl).integral_eq"
Mathlib/Computability/TMToPartrec.lean,Turing.ToPartrec.stepNormal.is_ret,stepNormal.is_ret,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction c generalizing k v with
  | cons _f fs IHf _IHfs => apply IHf
  | comp f _g _IHf IHg => apply IHg
  | case f g IHf IHg =>
    rw [stepNormal]
    simp only []
    cases v.headI <;> simp only [] <;> [apply IHf; apply IHg]
  | fix f IHf => apply IHf
  | _ => exact ‚ü®_, _, rfl‚ü©",error:  simp made no progress,"theorem stepNormal.is_ret (c k v) : ‚àÉ k' v', stepNormal c k v = Cfg.ret k' v' ",":= by
  induction c generalizing k v with
  | cons _f fs IHf _IHfs => apply IHf
  | comp f _g _IHf IHg => apply IHg
  | case f g IHf IHg =>
    rw [stepNormal]
    simp only []
    cases v.headI <;> [apply IHf; apply IHg]
  | fix f IHf => apply IHf
  | _ => exact ‚ü®_, _, rfl‚ü©"
Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean,coeff_minpolyDiv_sub_pow_mem_span,coeff_minpolyDiv_sub_pow_mem_span,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction i with
  | zero => simp [(minpolyDiv_monic hx).leadingCoeff]
  | succ i IH =>
    rw [coeff_minpolyDiv, add_sub_assoc, pow_succ, ‚Üê sub_mul, Algebra.algebraMap_eq_smul_one]
    refine add_mem ?_ ?_
    ¬∑ apply Submodule.smul_mem
      apply Submodule.subset_span
      exact ‚ü®0, Nat.zero_lt_succ _, pow_zero _‚ü©
    ¬∑ rw [Nat.succ_eq_add_one, ‚Üê tsub_tsub, tsub_add_cancel_of_le
        (le_tsub_of_add_le_left (b := 1) hi)]
      apply SetLike.le_def.mp ?_
        (Submodule.mul_mem_mul (IH ((Nat.le_succ _).trans hi))
          (Submodule.mem_span_singleton_self x))
      rw [Submodule.span_mul_span, Set.mul_singleton, Set.image_image]
      apply Submodule.span_mono
      rintro _ ‚ü®j, hj, rfl‚ü©
      rw [Set.mem_Iio] at hj
      exact ‚ü®j + 1, Nat.add_lt_of_lt_sub hj, pow_succ x j‚ü©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ.refine_2
R : Type u_2
K : Type ?u.79175
L : Type ?u.79178
S : Type u_1
inst‚úù‚Åµ : CommRing R
inst‚úù‚Å¥ : Field K
inst‚úù¬≥ : Field L
inst‚úù¬≤ : CommRing S
inst‚úù¬π : Algebra R S
inst‚úù : Algebra K L
x : S
hx : IsIntegral R x
i : ‚Ñï
IH :
  i ‚â§ (minpolyDiv R x).natDegree ‚Üí
    (minpolyDiv R x).coeff ((minpolyDiv R x).natDegree - i) - x ^ i ‚àà
      Submodule.span R ((fun x_1 ‚Ü¶ x ^ x_1) '' Set.Iio i)
hi : i + 1 ‚â§ (minpolyDiv R x).natDegree
‚ä¢ ((minpolyDiv R x).coeff ((minpolyDiv R x).natDegree - (i + 1) + 1) - x ^ i) * x ‚àà
    Submodule.span R ((fun x_1 ‚Ü¶ x ^ x_1) '' Set.Iio (i + 1))","lemma coeff_minpolyDiv_sub_pow_mem_span {i} (hi : i ‚â§ natDegree (minpolyDiv R x)) :
    coeff (minpolyDiv R x) (natDegree (minpolyDiv R x) - i) - x ^ i ‚àà
      Submodule.span R ((x ^ ¬∑) '' Set.Iio i) ",":= by
  induction i with
  | zero => simp [(minpolyDiv_monic hx).leadingCoeff]
  | succ i IH =>
    rw [coeff_minpolyDiv, add_sub_assoc, pow_succ, ‚Üê sub_mul, Algebra.algebraMap_eq_smul_one]
    refine add_mem ?_ ?_
    ¬∑ apply Submodule.smul_mem
      apply Submodule.subset_span
      exact ‚ü®0, Nat.zero_lt_succ _, pow_zero _‚ü©
    ¬∑ rw [‚Üê tsub_tsub, tsub_add_cancel_of_le (le_tsub_of_add_le_left (b := 1) hi)]
      apply SetLike.le_def.mp ?_
        (Submodule.mul_mem_mul (IH ((Nat.le_succ _).trans hi))
          (Submodule.mem_span_singleton_self x))
      rw [Submodule.span_mul_span, Set.mul_singleton, Set.image_image]
      apply Submodule.span_mono
      rintro _ ‚ü®j, hj, rfl‚ü©
      rw [Set.mem_Iio] at hj
      exact ‚ü®j + 1, Nat.add_lt_of_lt_sub hj, pow_succ x j‚ü©"
Mathlib/Algebra/Homology/ShortComplex/Ab.lean,CategoryTheory.ShortComplex.ShortExact.ab_injective_f,ShortExact.ab_injective_f,bad931b7fc9f31f5ff5b8f408dd19bbe20a9f0e1,":=
  (AddCommGroupCat.mono_iff_injective _).1 hS.mono_f",error:  unknown identifier 'AddCommGroupCat.mono_iff_injective',"lemma ShortExact.ab_injective_f (hS : S.ShortExact) :
    Function.Injective S.f ",":=
  (AddCommGrp.mono_iff_injective _).1 hS.mono_f"
Mathlib/Topology/GDelta.lean,isMeagre_iff_countable_union_isNowhereDense,isMeagre_iff_countable_union_isNowhereDense,4acf29cf15ba1326f189b61f7e886396ab6d97c8,":= by
  rw [IsMeagre, mem_residual_iff, compl_bijective.surjective.image_surjective.exists]
  simp_rw [‚Üê and_assoc, ‚Üê forall_and, ball_image_iff, ‚Üê isClosed_isNowhereDense_iff_compl,
    sInter_image, ‚Üê compl_iUnion‚ÇÇ, compl_subset_compl, ‚Üê sUnion_eq_biUnion, and_assoc]
  refine ‚ü®fun ‚ü®S, hS, hc, hsub‚ü© ‚Ü¶ ‚ü®S, fun s hs ‚Ü¶ (hS s hs).2, ?_, hsub‚ü©, ?_‚ü©
  ¬∑ rw [‚Üê compl_compl_image S]; exact hc.image _
  ¬∑ intro ‚ü®S, hS, hc, hsub‚ü©
    use closure '' S
    rw [ball_image_iff]
    exact ‚ü®fun s hs ‚Ü¶ ‚ü®isClosed_closure, (hS s hs).closure‚ü©,
      (hc.image _).image _, hsub.trans (sUnion_mono_subsets fun s ‚Ü¶ subset_closure)‚ü©","warning:  `Set.ball_image_iff` has been deprecated, use `Set.forall_mem_image` instead
error:  application type mismatch
  hS s
argument
  s
has type
  Set X : Type u_5
but is expected to have type
  ?m.22198 ‚àà S : Prop
warning:  `Set.ball_image_iff` has been deprecated, use `Set.forall_mem_image` instead","lemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :
    IsMeagre s ‚Üî ‚àÉ S : Set (Set X), (‚àÄ t ‚àà S, IsNowhereDense t) ‚àß S.Countable ‚àß s ‚äÜ ‚ãÉ‚ÇÄ S ",":= by
  rw [IsMeagre, mem_residual_iff, compl_bijective.surjective.image_surjective.exists]
  simp_rw [‚Üê and_assoc, ‚Üê forall_and, forall_mem_image, ‚Üê isClosed_isNowhereDense_iff_compl,
    sInter_image, ‚Üê compl_iUnion‚ÇÇ, compl_subset_compl, ‚Üê sUnion_eq_biUnion, and_assoc]
  refine ‚ü®fun ‚ü®S, hS, hc, hsub‚ü© ‚Ü¶ ‚ü®S, fun s hs ‚Ü¶ (hS hs).2, ?_, hsub‚ü©, ?_‚ü©
  ¬∑ rw [‚Üê compl_compl_image S]; exact hc.image _
  ¬∑ intro ‚ü®S, hS, hc, hsub‚ü©
    use closure '' S
    rw [forall_mem_image]
    exact ‚ü®fun s hs ‚Ü¶ ‚ü®isClosed_closure, (hS s hs).closure‚ü©,
      (hc.image _).image _, hsub.trans (sUnion_mono_subsets fun s ‚Ü¶ subset_closure)‚ü©"
Mathlib/Data/Multiset/Sections.lean,Multiset.mem_sections,mem_sections,e201f59f4fb4b1e87b8faa3dc9110a368fa07db5,":= by
  induction s using Multiset.induction_on with
  | empty => simp
  | cons ih => simp [ih, rel_cons_left, eq_comm]","error:  invalid argument, variable is not a proposition or let-declaration
error:  unsolved goals
case cons
Œ± : Type u_1
ih : Multiset Œ±
s‚úù : Multiset (Multiset Œ±)
a‚úù : ‚àÄ {a : Multiset Œ±}, a ‚àà s‚úù.Sections ‚Üî Rel (fun s a ‚Ü¶ a ‚àà s) s‚úù a
‚ä¢ ‚àÄ {a : Multiset Œ±},
    (‚àÉ a_1 ‚àà ih, ‚àÉ a_2 ‚àà s‚úù.Sections, a = a_1 ::‚Çò a_2) ‚Üî ‚àÉ b ‚àà ih, ‚àÉ x, Rel (fun s a ‚Ü¶ a ‚àà s) s‚úù x ‚àß a = b ::‚Çò x","theorem mem_sections {s : Multiset (Multiset Œ±)} :
    ‚àÄ {a}, a ‚àà Sections s ‚Üî s.Rel (fun s a => a ‚àà s) a ",":= by
  induction s using Multiset.induction_on with
  | empty => simp
  | cons _ _ ih => simp [ih, rel_cons_left, eq_comm]"
Mathlib/Algebra/ContinuedFractions/Computation/TerminatesIffRat.lean,GeneralizedContinuedFraction.exists_rat_eq_of_terminates,exists_rat_eq_of_terminates,43912576dd42c7dd56226029dcb5cfac81575096,":= by
  obtain ‚ü®n, v_eq_conv‚ü© : ‚àÉ n, v = (of v).convs n := of_correctness_of_terminates terminates
  obtain ‚ü®q, conv_eq_q‚ü© : ‚àÉ q : ‚Ñö, (of v).convs n = (‚Üëq : K) := exists_rat_eq_nth_conv v n
  have : v = (‚Üëq : K) := Eq.trans v_eq_conv conv_eq_q
  use q, this","error:  invalid field 'convs', the environment does not contain 'GeneralizedContinuedFraction.convs'
  of v
has type
  GeneralizedContinuedFraction K","theorem exists_rat_eq_of_terminates (terminates : (of v).Terminates) : ‚àÉ q : ‚Ñö, v = ‚Üëq ",":= by
  obtain ‚ü®n, v_eq_conv‚ü© : ‚àÉ n, v = (of v).convergents n :=
    of_correctness_of_terminates terminates
  obtain ‚ü®q, conv_eq_q‚ü© : ‚àÉ q : ‚Ñö, (of v).convergents n = (‚Üëq : K) :=
    exists_rat_eq_nth_convergent v n
  have : v = (‚Üëq : K) := Eq.trans v_eq_conv conv_eq_q
  use q, this"
Mathlib/GroupTheory/NoncommPiCoprod.lean,Subgroup.eq_one_of_noncommProd_eq_one_of_independent,eq_one_of_noncommProd_eq_one_of_independent,ddffab96a653674eaf6ec54e6415f6fa7c2a49f7,":= by
  classical
    revert heq1
    induction' s with i s hnmem ih
    ¬∑ simp
    ¬∑ have hcomm := comm.mono (Finset.coe_subset.2 <| Finset.subset_insert _ _)
      simp only [Finset.forall_mem_insert] at hmem
      have hmem_bsupr : s.noncommProd f hcomm ‚àà ‚®Ü i ‚àà (s : Set Œπ), K i := by
        refine' Subgroup.noncommProd_mem _ _ _
        intro x hx
        have : K x ‚â§ ‚®Ü i ‚àà (s : Set Œπ), K i := le_iSup‚ÇÇ (f := fun i _ => K i) x hx
        exact this (hmem.2 x hx)
      intro heq1
      rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hnmem] at heq1
      have hnmem' : i ‚àâ (s : Set Œπ) := by simpa
      obtain ‚ü®heq1i : f i = 1, heq1S : s.noncommProd f _ = 1‚ü© :=
        Subgroup.disjoint_iff_mul_eq_one.mp (hind.disjoint_biSup hnmem') hmem.1 hmem_bsupr heq1
      intro i h
      simp only [Finset.mem_insert] at h
      rcases h with (rfl | h)
      ¬∑ exact heq1i
      ¬∑ refine' ih hcomm hmem.2 heq1S _ h","error:  unsolved goals
case mk
G : Type u_1
inst‚úù : Group G
Œπ : Type u_2
f : Œπ ‚Üí G
K : Œπ ‚Üí Subgroup G
hind : CompleteLattice.Independent K
i : Multiset Œπ
s : i.Nodup
comm : (‚Üë{ val := i, nodup := s }).Pairwise fun a b ‚Ü¶ Commute (f a) (f b)
hmem : ‚àÄ x ‚àà { val := i, nodup := s }, f x ‚àà K x
‚ä¢ { val := i, nodup := s }.noncommProd f comm = 1 ‚Üí ‚àÄ i_1 ‚àà i, f i_1 = 1
error:  no goals to be solved","theorem eq_one_of_noncommProd_eq_one_of_independent {Œπ : Type*} (s : Finset Œπ) (f : Œπ ‚Üí G) (comm)
    (K : Œπ ‚Üí Subgroup G) (hind : CompleteLattice.Independent K) (hmem : ‚àÄ x ‚àà s, f x ‚àà K x)
    (heq1 : s.noncommProd f comm = 1) : ‚àÄ i ‚àà s, f i = 1 ",":= by
  classical
    revert heq1
    induction' s using Finset.induction_on with i s hnmem ih
    ¬∑ simp
    ¬∑ have hcomm := comm.mono (Finset.coe_subset.2 <| Finset.subset_insert _ _)
      simp only [Finset.forall_mem_insert] at hmem
      have hmem_bsupr : s.noncommProd f hcomm ‚àà ‚®Ü i ‚àà (s : Set Œπ), K i := by
        refine Subgroup.noncommProd_mem _ _ ?_
        intro x hx
        have : K x ‚â§ ‚®Ü i ‚àà (s : Set Œπ), K i := le_iSup‚ÇÇ (f := fun i _ => K i) x hx
        exact this (hmem.2 x hx)
      intro heq1
      rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hnmem] at heq1
      have hnmem' : i ‚àâ (s : Set Œπ) := by simpa
      obtain ‚ü®heq1i : f i = 1, heq1S : s.noncommProd f _ = 1‚ü© :=
        Subgroup.disjoint_iff_mul_eq_one.mp (hind.disjoint_biSup hnmem') hmem.1 hmem_bsupr heq1
      intro i h
      simp only [Finset.mem_insert] at h
      rcases h with (rfl | h)
      ¬∑ exact heq1i
      ¬∑ refine ih hcomm hmem.2 heq1S _ h"
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.Mem‚Ñíp.integral_indicator_norm_ge_nonneg_le_of_meas,Mem‚Ñíp.integral_indicator_norm_ge_nonneg_le_of_meas,ff33d25c791a3fac407c782b49018fcb63700d0d,":=
  let ‚ü®M, hM‚ü© := hf.integral_indicator_norm_ge_le Œº hmeas hŒµ
  ‚ü®max M 0, le_max_right _ _, by simpa‚ü©","error:  application type mismatch
  @integral_indicator_norm_ge_le Œ± Œ≤ m Œº inst‚úù f hf Œº
argument
  Œº
has type
  Measure Œ± : Type u_1
but is expected to have type
  StronglyMeasurable f : Prop
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  ?m.33459","theorem Mem‚Ñíp.integral_indicator_norm_ge_nonneg_le_of_meas (hf : Mem‚Ñíp f 1 Œº)
    (hmeas : StronglyMeasurable f) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :
    ‚àÉ M : ‚Ñù, 0 ‚â§ M ‚àß (‚à´‚Åª x, ‚Äñ{ x | M ‚â§ ‚Äñf x‚Äñ‚Çä }.indicator f x‚Äñ‚Çä ‚àÇŒº) ‚â§ ENNReal.ofReal Œµ ",":=
  let ‚ü®M, hM‚ü© := hf.integral_indicator_norm_ge_le hmeas hŒµ
  ‚ü®max M 0, le_max_right _ _, by simpa‚ü©"
Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean,IsIntegralClosure.isNoetherian,IsIntegralClosure.isNoetherian,9cf5b3c82126c67032a6b088145a14487308333e,":= by
  haveI := Classical.decEq L
  obtain ‚ü®s, b, hb_int‚ü© := FiniteDimensional.exists_is_basis_integral A K L
  let b' := (traceForm K L).dualBasis (traceForm_separatingLeft K L) b
  letI := isNoetherian_span_of_finite A (Set.finite_range b')
  let f : C ‚Üí‚Çó[A] Submodule.span A (Set.range b') :=
    (Submodule.inclusion (IsIntegralClosure.range_le_span_dualBasis C b hb_int)).comp
      ((Algebra.linearMap C L).restrictScalars A).rangeRestrict
  refine' isNoetherian_of_ker_bot f _
  rw [LinearMap.ker_comp, Submodule.ker_inclusion, Submodule.comap_bot, LinearMap.ker_codRestrict]
  exact LinearMap.ker_eq_bot_of_injective (IsIntegralClosure.algebraMap_injective C A L)",error:  unknown identifier 'traceForm_separatingLeft',"theorem IsIntegralClosure.isNoetherian [IsIntegrallyClosed A] [IsNoetherianRing A] :
    IsNoetherian A C ",":= by
  haveI := Classical.decEq L
  obtain ‚ü®s, b, hb_int‚ü© := FiniteDimensional.exists_is_basis_integral A K L
  let b' := (traceForm K L).dualBasis (traceForm_nondegenerate K L) b
  letI := isNoetherian_span_of_finite A (Set.finite_range b')
  let f : C ‚Üí‚Çó[A] Submodule.span A (Set.range b') :=
    (Submodule.inclusion (IsIntegralClosure.range_le_span_dualBasis C b hb_int)).comp
      ((Algebra.linearMap C L).restrictScalars A).rangeRestrict
  refine isNoetherian_of_ker_bot f ?_
  rw [LinearMap.ker_comp, Submodule.ker_inclusion, Submodule.comap_bot, LinearMap.ker_codRestrict]
  exact LinearMap.ker_eq_bot_of_injective (IsIntegralClosure.algebraMap_injective C A L)"
Mathlib/ModelTheory/Skolem.lean,FirstOrder.Language.exists_elementarySubstructure_card_eq,exists_elementarySubstructure_card_eq,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  obtain ‚ü®s', hs'‚ü© := Cardinal.le_mk_iff_exists_set.1 h4
  rw [‚Üê aleph0_le_lift.{_, w}] at h1
  rw [‚Üê hs'] at h1 h2 ‚ä¢
  refine
    ‚ü®elementarySkolem‚ÇÅReduct (closure (L.sum L.skolem‚ÇÅ) (s ‚à™ Equiv.ulift '' s')),
      (s.subset_union_left _).trans subset_closure, ?_‚ü©
  have h := mk_image_eq_lift _ s' Equiv.ulift.injective
  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h
  rw [coeSort_elementarySkolem‚ÇÅReduct, ‚Üê h, lift_inj]
  refine
    le_antisymm (lift_le.1 (lift_card_closure_le.trans ?_))
      (mk_le_mk_of_subset ((Set.subset_union_right _ _).trans subset_closure))
  rw [max_le_iff, aleph0_le_lift, ‚Üê aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]
  ¬∑ refine ‚ü®h1, (mk_union_le _ _).trans ?_, (lift_le.2 card_functions_sum_skolem‚ÇÅ_le).trans ?_‚ü©
    ¬∑ rw [‚Üê lift_le, lift_add, h, add_comm, add_eq_max h1]
      exact max_le le_rfl h2
    ¬∑ rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, ‚Üê lift_le.{w'},
        lift_lift, lift_lift, ‚Üê aleph0_le_lift, h]
      refine ‚ü®?_, h1‚ü©
      rw [‚Üê lift_lift.{w', w}]
      refine _root_.trans (lift_le.{w}.2 h3) ?_
      rw [lift_lift, ‚Üê lift_lift.{w, max u v}, ‚Üê hs', ‚Üê h, lift_lift]
  ¬∑ refine _root_.trans ?_ (lift_le.2 (mk_le_mk_of_subset (Set.subset_union_right _ _)))
    rw [aleph0_le_lift, ‚Üê aleph0_le_lift, h]
    exact h1","error:  invalid field 'trans', the environment does not contain 'Membership.mem.trans'
  Set.subset_union_left ?m.26890
has type
  ?m.26889 ‚àà s ‚à™ ?m.26888
error:  invalid field 'trans', the environment does not contain 'Set.Mem.trans'
  Set.subset_union_left ?m.26890
has type
  Set.Mem ?m.26889 (s ‚à™ ?m.26888)
error:  invalid field 'trans', the environment does not contain 'Union.union.trans'
  Set.subset_union_left ?m.26890
has type
  (s ‚à™ ?m.26888) ?m.26889
error:  invalid field 'trans', the environment does not contain 'Set.union.trans'
  Set.subset_union_left ?m.26890
has type
  s.union ?m.26888 ?m.26889
error:  invalid field 'trans', the environment does not contain 'setOf.trans'
  Set.subset_union_left ?m.26890
has type
  {a | a ‚àà s ‚à® a ‚àà ?m.26888} ?m.26889
error:  invalid field 'trans', the environment does not contain 'Or.trans'
  Set.subset_union_left ?m.26890
has type
  ?m.26889 ‚àà s ‚à® ?m.26889 ‚àà ?m.26888
error:  function expected at
  Set.subset_union_right ?m.27688
term has type
  ?m.27687 ‚àà ?m.27685 ‚à™ ?m.27686
error:  function expected at
  Set.subset_union_right ?m.29978
term has type
  ?m.29977 ‚àà ?m.29975 ‚à™ ?m.29976","theorem exists_elementarySubstructure_card_eq (s : Set M) (Œ∫ : Cardinal.{w'}) (h1 : ‚Ñµ‚ÇÄ ‚â§ Œ∫)
    (h2 : Cardinal.lift.{w'} #s ‚â§ Cardinal.lift.{w} Œ∫)
    (h3 : Cardinal.lift.{w'} L.card ‚â§ Cardinal.lift.{max u v} Œ∫)
    (h4 : Cardinal.lift.{w} Œ∫ ‚â§ Cardinal.lift.{w'} #M) :
    ‚àÉ S : L.ElementarySubstructure M, s ‚äÜ S ‚àß Cardinal.lift.{w'} #S = Cardinal.lift.{w} Œ∫ ",":= by
  obtain ‚ü®s', hs'‚ü© := Cardinal.le_mk_iff_exists_set.1 h4
  rw [‚Üê aleph0_le_lift.{_, w}] at h1
  rw [‚Üê hs'] at h1 h2 ‚ä¢
  refine
    ‚ü®elementarySkolem‚ÇÅReduct (closure (L.sum L.skolem‚ÇÅ) (s ‚à™ Equiv.ulift '' s')),
      (s.subset_union_left).trans subset_closure, ?_‚ü©
  have h := mk_image_eq_lift _ s' Equiv.ulift.injective
  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h
  rw [coeSort_elementarySkolem‚ÇÅReduct, ‚Üê h, lift_inj]
  refine
    le_antisymm (lift_le.1 (lift_card_closure_le.trans ?_))
      (mk_le_mk_of_subset ((s.subset_union_right).trans subset_closure))
  rw [max_le_iff, aleph0_le_lift, ‚Üê aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]
  ¬∑ refine ‚ü®h1, (mk_union_le _ _).trans ?_, (lift_le.2 card_functions_sum_skolem‚ÇÅ_le).trans ?_‚ü©
    ¬∑ rw [‚Üê lift_le, lift_add, h, add_comm, add_eq_max h1]
      exact max_le le_rfl h2
    ¬∑ rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, ‚Üê lift_le.{w'},
        lift_lift, lift_lift, ‚Üê aleph0_le_lift, h]
      refine ‚ü®?_, h1‚ü©
      rw [‚Üê lift_lift.{w', w}]
      refine _root_.trans (lift_le.{w}.2 h3) ?_
      rw [lift_lift, ‚Üê lift_lift.{w, max u v}, ‚Üê hs', ‚Üê h, lift_lift]
  ¬∑ refine _root_.trans ?_ (lift_le.2 (mk_le_mk_of_subset Set.subset_union_right))
    rw [aleph0_le_lift, ‚Üê aleph0_le_lift, h]
    exact h1"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.card_compression,card_compression,d3263b231fc2baca52b49308a9c35acca2ade1d0,":= by
  rw [compression, card_disjoint_union (compress_disjoint _ _), image_filter, card_image_of_injOn,
    ‚Üê card_disjoint_union]
  rw [filter_union_filter_neg_eq]
  ¬∑ rw [disjoint_iff_inter_eq_empty]
    exact filter_inter_filter_neg_eq _ _ _
  intro a ha b hb hab
  rw [mem_coe, mem_filter] at ha hb
  rw [compress] at ha hab
  split_ifs at ha hab with has
  ¬∑ rw [compress] at hb hab
    split_ifs at hb hab with hbs
    ¬∑ exact sup_sdiff_injOn u v has hbs hab
    ¬∑ exact (hb.2 hb.1).elim
  ¬∑ exact (ha.2 ha.1).elim","warning:  @UV.compression does not have a doc string
warning:  `Finset.card_disjoint_union` has been deprecated, use `Finset.card_union_of_disjoint` instead
error:  application type mismatch
  card_disjoint_union (compress_disjoint ?m.54484 ?m.54485)
argument
  compress_disjoint ?m.54484 ?m.54485
has type
  ?m.54483 ‚â§ ‚ä• : Prop
but is expected to have type
  Disjoint ?m.54471 ?m.54472 : Prop
warning:  `Finset.image_filter` has been deprecated, use `Finset.filter_image` instead
warning:  `Finset.card_disjoint_union` has been deprecated, use `Finset.card_union_of_disjoint` instead",theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card ,":= by
  rw [compression, card_union_of_disjoint compress_disjoint, filter_image,
    card_image_of_injOn compress_injOn, ‚Üê card_union_of_disjoint (disjoint_filter_filter_neg s _ _),
    filter_union_filter_neg_eq]"
Mathlib/RingTheory/DedekindDomain/Different.lean,FractionalIdeal.dual_eq_zero_iff,dual_eq_zero_iff,3465d1aaae242475fad59e688648a2285031d19e,":= ‚ü®not_imp_not.mp dual_ne_zero, fun e ‚Ü¶ e.symm ‚ñ∏ dual_zero‚ü©","error:  application type mismatch
  not_imp_not.mp dual_ne_zero
argument
  dual_ne_zero
has type
  ‚àÄ (A : Type ?u.327435) (K : Type ?u.327434) {L : Type ?u.327436} {B : Type ?u.327433} [inst : CommRing A]
    [inst_1 : Field K] [inst_2 : CommRing B] [inst_3 : Field L] [inst_4 : Algebra A K] [inst_5 : Algebra B L]
    [inst_6 : Algebra A B] [inst_7 : Algebra K L] [inst_8 : Algebra A L] [inst_9 : IsScalarTower A K L]
    [inst_10 : IsScalarTower A B L] [inst_11 : IsDomain A] [inst_12 : IsDomain B] [inst_13 : IsFractionRing A K]
    [inst_14 : IsIntegralClosure B A L] [inst_15 : IsFractionRing B L] [inst_16 : FiniteDimensional K L]
    [inst_17 : IsSeparable K L] [inst_18 : IsIntegrallyClosed A] {I : FractionalIdeal B‚Å∞ L},
    I ‚â† 0 ‚Üí dual A K I ‚â† 0 : Prop
but is expected to have type
  ¬¨I = 0 ‚Üí ¬¨dual A K I = 0 : Prop
error:  type mismatch
  dual_zero
has type
  ‚àÄ (A : Type ?u.328568) (K : Type ?u.328567) (L : Type ?u.328569) (B : Type ?u.328566) [inst : CommRing A]
    [inst_1 : Field K] [inst_2 : CommRing B] [inst_3 : Field L] [inst_4 : Algebra A K] [inst_5 : Algebra B L]
    [inst_6 : Algebra A B] [inst_7 : Algebra K L] [inst_8 : Algebra A L] [inst_9 : IsScalarTower A K L]
    [inst_10 : IsScalarTower A B L] [inst_11 : IsDomain A] [inst_12 : IsDomain B] [inst_13 : IsFractionRing A K]
    [inst_14 : IsIntegralClosure B A L] [inst_15 : IsFractionRing B L] [inst_16 : FiniteDimensional K L]
    [inst_17 : IsSeparable K L] [inst_18 : IsIntegrallyClosed A], dual A K 0 = 0 : Prop
but is expected to have type
  dual A K 0 = 0 : Prop","lemma dual_eq_zero_iff :
    dual A K I = 0 ‚Üî I = 0 ",":=
  ‚ü®not_imp_not.mp (dual_ne_zero A K), fun e ‚Ü¶ e.symm ‚ñ∏ dual_zero A K L B‚ü©"
Mathlib/Data/Nat/Bits.lean,Nat.bodd_succ,bodd_succ,e22ab90242ae5cde6c534b464851a092255da039,":= by
  simp only [bodd, succ_eq_add_one, one_land_eq_mod_two]
  cases mod_two_eq_zero_or_one n with | _ h => simp [h, add_mod]","error:  unknown identifier 'one_land_eq_mod_two'
error:  simp made no progress
error:  simp made no progress
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated",lemma bodd_succ (n : ‚Ñï) : bodd (succ n) = not (bodd n) ,":= by
  simp only [bodd, boddDiv2]
  let ‚ü®b,m‚ü© := boddDiv2 n
  cases b <;> rfl"
Mathlib/Data/Nat/PartENat.lean,PartENat.toWithTop_le,toWithTop_le,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction y generalizing hy
  ¬∑ simp
  induction x generalizing hx
  ¬∑ simp
  ¬∑ simp ","error:  simp made no progress
error:  no goals to be solved","theorem toWithTop_le {x y : PartENat} [hx : Decidable x.Dom] [hy : Decidable y.Dom] :
    toWithTop x ‚â§ toWithTop y ‚Üî x ‚â§ y ",":= by
  induction y using PartENat.casesOn generalizing hy
  ¬∑ simp
  induction x using PartENat.casesOn generalizing hx
  ¬∑ simp
  ¬∑ simp "
Mathlib/SetTheory/Ordinal/Arithmetic.lean,Ordinal.one_add_omega,one_add_omega,162e9d88f2a813194aaa648791544b64eb14df1d,":= by
  refine' le_antisymm _ (le_add_left _ _)
  rw [omega, ‚Üê lift_one.{_, 0}, ‚Üê lift_add, lift_le, ‚Üê type_unit, ‚Üê type_sum_lex]
  refine' ‚ü®RelEmbedding.collapse (RelEmbedding.ofMonotone _ _)‚ü©
  ¬∑ apply Sum.rec
    ¬∑ exact fun _ => 0
    ¬∑ exact Nat.succ
  ¬∑ intro a b
    cases a <;> cases b <;> intro H <;> cases' H with _ _ H _ _ H <;>
      [exact H.elim; exact Nat.succ_pos _; exact Nat.succ_lt_succ H]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  lift.{?u.63187, ?u.63186} ?a + lift.{?u.63187, ?u.63186} ?b
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
r : Œ± ‚Üí Œ± ‚Üí Prop
s : Œ≤ ‚Üí Œ≤ ‚Üí Prop
t : Œ≥ ‚Üí Œ≥ ‚Üí Prop
‚ä¢ lift.{0, u_4} 1 + lift.{u_4, 0} (type fun x x_1 ‚Ü¶ x < x_1) ‚â§ lift.{u_4, 0} (type fun x x_1 ‚Ü¶ x < x_1)",theorem one_add_omega : 1 + œâ = œâ ,":= by
  refine le_antisymm ?_ (le_add_left _ _)
  rw [omega, ‚Üê lift_one.{0}, ‚Üê lift_add, lift_le, ‚Üê type_unit, ‚Üê type_sum_lex]
  refine ‚ü®RelEmbedding.collapse (RelEmbedding.ofMonotone ?_ ?_)‚ü©
  ¬∑ apply Sum.rec
    ¬∑ exact fun _ => 0
    ¬∑ exact Nat.succ
  ¬∑ intro a b
    cases a <;> cases b <;> intro H <;> cases' H with _ _ H _ _ H <;>
      [exact H.elim; exact Nat.succ_pos _; exact Nat.succ_lt_succ H]"
Mathlib/Algebra/Pointwise/Stabilizer.lean,MulAction.stabilizer_mul_self,stabilizer_mul_self,07756d1c93a4359598a8cb64e0dad5437852db3b,":= by
  ext
  refine ‚ü®?_, fun h ‚Ü¶ ‚ü®_, _, (stabilizer G s).one_mem, h, one_mul _‚ü©‚ü©
  rintro ‚ü®a, b, ha, hb, rfl‚ü©
  rw [‚Üê mem_stabilizer_iff.1 ha]
  exact smul_mem_smul_set hb","error:  application type mismatch
  Exists.intro (Subgroup.one_mem (stabilizer G s))
argument
  Subgroup.one_mem (stabilizer G s)
has type
  1 ‚àà stabilizer G s : Prop
but is expected to have type
  G : Type u_1
error:  unsolved goals
case h
G : Type u_1
H : Type u_2
Œ± : Type u_3
inst‚úù¬≤ : Group G
inst‚úù¬π : Group H
inst‚úù : MulAction G Œ±
a : G
s : Set G
x‚úù : G
‚ä¢ x‚úù ‚àà ‚Üë(stabilizer G s) * s ‚Üî x‚úù ‚àà s",lemma stabilizer_mul_self (s : Set G) : (stabilizer G s : Set G) * s = s ,":= by
  ext
  refine ‚ü®?_, fun h ‚Ü¶ ‚ü®_, (stabilizer G s).one_mem, _, h, one_mul _‚ü©‚ü©
  rintro ‚ü®a, ha, b, hb, rfl‚ü©
  rw [‚Üê mem_stabilizer_iff.1 ha]
  exact smul_mem_smul_set hb"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.hausdorffMeasure_pi_real,hausdorffMeasure_pi_real,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  classical
  refine (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)
    (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) ?_).symm
  simp only [mem_iUnion, mem_singleton_iff]
  intro s hs
  choose a b H using hs
  obtain rfl : s = fun i => Ioo (Œ± := ‚Ñù) (a i) (b i) := funext fun i => (H i).2
  replace H := fun i => (H i).1
  apply le_antisymm _
  ¬∑ have Hle : volume ‚â§ (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) := by
      refine' le_hausdorffMeasure _ _ ‚àû ENNReal.coe_lt_top fun s _ => _
      rw [ENNReal.rpow_nat_cast]
      exact Real.volume_pi_le_diam_pow s
    rw [‚Üê volume_pi_pi fun i => Ioo (a i : ‚Ñù) (b i)]
    exact Measure.le_iff'.1 Hle _
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := fun i => by
    simpa only [sub_nonneg, Rat.cast_le] using (H i).le
  let Œ≥ := fun n : ‚Ñï => ‚àÄ i : Œπ, Fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä
  let t : ‚àÄ n : ‚Ñï, Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f =>
    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)
  have A : Tendsto (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) atTop (ùìù 0) := by
    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]
  have B : ‚àÄ·∂† n in atTop, ‚àÄ i : Œ≥ n, diam (t n i) ‚â§ 1 / n := by
    refine' eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
    intro f
    refine' diam_pi_le_of_le fun b => _
    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel', ENNReal.ofReal_one, ENNReal.ofReal_coe_nat]
  have C : ‚àÄ·∂† n in atTop, (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ i : Œ≥ n, t n i := by
    refine' eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
    have npos : (0 : ‚Ñù) < n := Nat.cast_pos.2 hn
    intro x hx
    simp only [mem_Ioo, mem_univ_pi] at hx
    simp only [t, mem_iUnion, mem_Ioo, mem_univ_pi]
    let f : Œ≥ n := fun i =>
      ‚ü®‚åä(x i - a i) * n‚åã‚Çä, by
        apply Nat.floor_lt_ceil_of_lt_of_pos
        ¬∑ refine' (mul_lt_mul_right npos).2 _
          simp only [(hx i).right, sub_lt_sub_iff_right]
        ¬∑ refine' mul_pos _ npos
          simpa only [Rat.cast_lt, sub_pos] using H i‚ü©
    refine' ‚ü®f, fun i => ‚ü®_, _‚ü©‚ü©
    ¬∑ calc
        (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + (x i - a i) * n / n := by
          refine' add_le_add le_rfl ((div_le_div_right npos).2 _)
          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
        _ = x i := by field_simp [npos.ne']
    ¬∑ calc
        x i = (a i : ‚Ñù) + (x i - a i) * n / n := by field_simp [npos.ne']
        _ ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n :=
          add_le_add le_rfl ((div_le_div_right npos).2 (Nat.lt_floor_add_one _).le)
  calc
    ŒºH[Fintype.card Œπ] (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚â§
        liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, diam (t n i) ^ ((Fintype.card Œπ) : ‚Ñù)) atTop :=
      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : ‚Ñù) (b i))
        (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) A t B C
    _ ‚â§ liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, (1 / (n : ‚Ñù‚â•0‚àû)) ^ Fintype.card Œπ) atTop := by
      refine' liminf_le_liminf _ _
      ¬∑ filter_upwards [B] with _ hn
        apply Finset.sum_le_sum fun i _ => _
        simp only [ENNReal.rpow_nat_cast]
        intros i _
        exact pow_le_pow_left' (hn i) _
      ¬∑ isBoundedDefault
    _ = liminf (fun n : ‚Ñï => ‚àè i : Œπ, (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) atTop := by
      simp only [Œ≥, Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
    _ = ‚àè i : Œπ, volume (Ioo (a i : ‚Ñù) (b i)) := by
      simp only [Real.volume_Ioo]
      apply Tendsto.liminf_eq
      refine' ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => _) fun i _ => _
      ¬∑ apply
          Tendsto.congr' _
            ((ENNReal.continuous_ofReal.tendsto _).comp
              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_nat_cast_atTop_atTop))
        apply eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
        intros n hn
        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,
          ENNReal.ofReal_coe_nat]
      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne.def, not_false_iff]","warning:  `ENNReal.rpow_nat_cast` has been deprecated, use `ENNReal.rpow_natCast` instead
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
warning:  `ENNReal.ofReal_coe_nat` has been deprecated, use `ENNReal.ofReal_natCast` instead
warning:  `ENNReal.rpow_nat_cast` has been deprecated, use `ENNReal.rpow_natCast` instead
warning:  `tendsto_nat_cast_atTop_atTop` has been deprecated, use `tendsto_natCast_atTop_atTop` instead
warning:  `ENNReal.ofReal_coe_nat` has been deprecated, use `ENNReal.ofReal_natCast` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.259530 ‚Üí ?m.259530 ‚Üí Prop
error:  simp made no progress","theorem hausdorffMeasure_pi_real {Œπ : Type*} [Fintype Œπ] :
    (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) = volume ",":= by
  classical
  refine (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)
    (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) ?_).symm
  simp only [mem_iUnion, mem_singleton_iff]
  intro s hs
  choose a b H using hs
  obtain rfl : s = fun i => Ioo (Œ± := ‚Ñù) (a i) (b i) := funext fun i => (H i).2
  replace H := fun i => (H i).1
  apply le_antisymm _
  ¬∑ have Hle : volume ‚â§ (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) := by
      refine le_hausdorffMeasure _ _ ‚àû ENNReal.coe_lt_top fun s _ => ?_
      rw [ENNReal.rpow_natCast]
      exact Real.volume_pi_le_diam_pow s
    rw [‚Üê volume_pi_pi fun i => Ioo (a i : ‚Ñù) (b i)]
    exact Measure.le_iff'.1 Hle _
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := fun i => by
    simpa only [sub_nonneg, Rat.cast_le] using (H i).le
  let Œ≥ := fun n : ‚Ñï => ‚àÄ i : Œπ, Fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä
  let t : ‚àÄ n : ‚Ñï, Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f =>
    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)
  have A : Tendsto (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) atTop (ùìù 0) := by
    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]
  have B : ‚àÄ·∂† n in atTop, ‚àÄ i : Œ≥ n, diam (t n i) ‚â§ 1 / n := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => ?_‚ü©
    intro f
    refine diam_pi_le_of_le fun b => ?_
    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel_left, ENNReal.ofReal_one, ENNReal.ofReal_natCast]
  have C : ‚àÄ·∂† n in atTop, (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ i : Œ≥ n, t n i := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => ?_‚ü©
    have npos : (0 : ‚Ñù) < n := Nat.cast_pos.2 hn
    intro x hx
    simp only [mem_Ioo, mem_univ_pi] at hx
    simp only [t, mem_iUnion, mem_Ioo, mem_univ_pi]
    let f : Œ≥ n := fun i =>
      ‚ü®‚åä(x i - a i) * n‚åã‚Çä, by
        apply Nat.floor_lt_ceil_of_lt_of_pos
        ¬∑ refine (mul_lt_mul_right npos).2 ?_
          simp only [(hx i).right, sub_lt_sub_iff_right]
        ¬∑ refine mul_pos ?_ npos
          simpa only [Rat.cast_lt, sub_pos] using H i‚ü©
    refine ‚ü®f, fun i => ‚ü®?_, ?_‚ü©‚ü©
    ¬∑ calc
        (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + (x i - a i) * n / n := by
          gcongr
          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
        _ = x i := by field_simp [npos.ne']
    ¬∑ calc
        x i = (a i : ‚Ñù) + (x i - a i) * n / n := by field_simp [npos.ne']
        _ ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n := by
          gcongr
          exact (Nat.lt_floor_add_one _).le
  calc
    ŒºH[Fintype.card Œπ] (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚â§
        liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, diam (t n i) ^ ((Fintype.card Œπ) : ‚Ñù)) atTop :=
      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : ‚Ñù) (b i))
        (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) A t B C
    _ ‚â§ liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, (1 / (n : ‚Ñù‚â•0‚àû)) ^ Fintype.card Œπ) atTop := by
      refine liminf_le_liminf ?_ ?_
      ¬∑ filter_upwards [B] with _ hn
        apply Finset.sum_le_sum fun i _ => _
        simp only [ENNReal.rpow_natCast]
        intros i _
        exact pow_le_pow_left' (hn i) _
      ¬∑ isBoundedDefault
    _ = liminf (fun n : ‚Ñï => ‚àè i : Œπ, (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) atTop := by
      simp only [Œ≥, Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
    _ = ‚àè i : Œπ, volume (Ioo (a i : ‚Ñù) (b i)) := by
      simp only [Real.volume_Ioo]
      apply Tendsto.liminf_eq
      refine ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => ?_) fun i _ => ?_
      ¬∑ apply
          Tendsto.congr' _
            ((ENNReal.continuous_ofReal.tendsto _).comp
              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_natCast_atTop_atTop))
        apply eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
        intros n hn
        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,
          ENNReal.ofReal_natCast]
      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne, not_false_iff]"
Mathlib/Algebra/Module/Defs.lean,Convex.combo_eq_smul_sub_add,Convex.combo_eq_smul_sub_add,0ef23fba776dbe5bb848bbfc3337bedef4a59c82,":=
  calc
    a ‚Ä¢ x + b ‚Ä¢ y = b ‚Ä¢ y - b ‚Ä¢ x + (a ‚Ä¢ x + b ‚Ä¢ x) := by abel
    _ = b ‚Ä¢ (y - x) + x := by rw [smul_sub, Convex.combo_self h]","warning:  `bit0` has been deprecated
error:  unknown tactic
error:  unsolved goals
Œ± : Type u_1
R : Type u_2
k : Type u_3
S : Type u_4
M : Type u_5
M‚ÇÇ : Type u_6
M‚ÇÉ : Type u_7
Œπ : Type u_8
inst‚úù¬≤ : Semiring R
inst‚úù¬π : AddCommGroup M
inst‚úù : Module R M
x y : M
a b : R
h : a + b = 1
‚ä¢ a ‚Ä¢ x + b ‚Ä¢ y = b ‚Ä¢ y - b ‚Ä¢ x + (a ‚Ä¢ x + b ‚Ä¢ x)","theorem Convex.combo_eq_smul_sub_add [Module R M] {x y : M} {a b : R} (h : a + b = 1) :
    a ‚Ä¢ x + b ‚Ä¢ y = b ‚Ä¢ (y - x) + x ",":=
  calc
    a ‚Ä¢ x + b ‚Ä¢ y = b ‚Ä¢ y - b ‚Ä¢ x + (a ‚Ä¢ x + b ‚Ä¢ x) := by rw [sub_add_add_cancel, add_comm]
    _ = b ‚Ä¢ (y - x) + x := by rw [smul_sub, Convex.combo_self h]"
Mathlib/Topology/Category/Stonean/Basic.lean,Stonean.epi_iff_surjective,epi_iff_surjective,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  refine ‚ü®?_, ConcreteCategory.epi_of_surjective _‚ü©
  dsimp [Function.Surjective]
  intro h y
  by_contra! hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := C·∂ú
  have hUy : U ‚àà nhds y := by
    simp only [Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain ‚ü®V, hV, hyV, hVU‚ü© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy
  classical
  let g : Y ‚ü∂ mkFinite (ULift (Fin 2)) :=
    ‚ü®(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _‚ü©
  let h : Y ‚ü∂ mkFinite (ULift (Fin 2)) := ‚ü®fun _ => ‚ü®1‚ü©, continuous_const‚ü©
  have H : h = g := by
    rw [‚Üê cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU ¬∑) ?_ 
    simpa only [Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H","error:  simp made no progress
error:  type mismatch
  h‚úù
has type
  ‚àÉ a, f a = f x : Prop
but is expected to have type
  f x ‚àâ U : Prop","lemma epi_iff_surjective {X Y : Stonean} (f : X ‚ü∂ Y) :
    Epi f ‚Üî Function.Surjective f ",":= by
  refine ‚ü®?_, ConcreteCategory.epi_of_surjective _‚ü©
  dsimp [Function.Surjective]
  intro h y
  by_contra! hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := C·∂ú
  have hUy : U ‚àà ùìù y := by
    simp only [C, Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain ‚ü®V, hV, hyV, hVU‚ü© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy
  classical
  let g : Y ‚ü∂ mkFinite (ULift (Fin 2)) :=
    ‚ü®(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _‚ü©
  let h : Y ‚ü∂ mkFinite (ULift (Fin 2)) := ‚ü®fun _ => ‚ü®1‚ü©, continuous_const‚ü©
  have H : h = g := by
    rw [‚Üê cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU ¬∑) ?_ 
    simpa only [U, Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H"
Mathlib/NumberTheory/Padics/PadicVal.lean,Nat.log_ne_padicValNat_succ,Nat.log_ne_padicValNat_succ,0f24aee7da46f85fee5cacc716172444ce31e582,":= by
  rw [Ne, log_eq_iff (by simp [hn])]
  rintro ‚ü®h1, h2‚ü©
  rw [‚Üê lt_add_one_iff, ‚Üê mul_one (2 ^ _)] at h1
  rw [‚Üê add_one_le_iff, pow_succ] at h2
  refine' not_dvd_of_between_consec_multiples h1 (lt_of_le_of_ne' h2 _) pow_padicValNat_dvd
  exact pow_succ_padicValNat_not_dvd n.succ_ne_zero ‚àò dvd_of_eq","error:  unknown identifier 'lt_add_one_iff'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.65770
case intro
p n : ‚Ñï
hn : n ‚â† 0
h1 : 2 ^ padicValNat 2 (n + 1) ‚â§ n
h2 : n < 2 ^ (padicValNat 2 (n + 1) + 1)
‚ä¢ False",lemma Nat.log_ne_padicValNat_succ {n : ‚Ñï} (hn : n ‚â† 0) : log 2 n ‚â† padicValNat 2 (n + 1) ,":= by
  rw [Ne, log_eq_iff (by simp [hn])]
  rintro ‚ü®h1, h2‚ü©
  rw [‚Üê Nat.lt_add_one_iff, ‚Üê mul_one (2 ^ _)] at h1
  rw [‚Üê add_one_le_iff, Nat.pow_succ] at h2
  refine not_dvd_of_between_consec_multiples h1 (lt_of_le_of_ne' h2 ?_) pow_padicValNat_dvd
  exact pow_succ_padicValNat_not_dvd (p := 2) n.succ_ne_zero ‚àò dvd_of_eq"
Mathlib/MeasureTheory/Function/LocallyIntegrable.lean,MeasureTheory.locallyIntegrableOn_iff,locallyIntegrableOn_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine ‚ü®fun hf k hk => hf.integrableOn_compact_subset hk, fun hf x hx => ?_‚ü©
  cases hs with
  | inl hs =>
    exact
      let ‚ü®K, hK, h2K‚ü© := exists_compact_mem_nhds x
      ‚ü®_, inter_mem_nhdsWithin s h2K,
        hf _ (inter_subset_left _ _)
          (hK.of_isClosed_subset (hs.inter hK.isClosed) (inter_subset_right _ _))‚ü©
  | inr hs =>
    obtain ‚ü®K, hK, h2K, h3K‚ü© := exists_compact_subset hs hx
    refine ‚ü®K, ?_, hf K h3K hK‚ü©
    simpa only [IsOpen.nhdsWithin_eq hs hx, interior_eq_nhds'] using h2K","error:  function expected at
  inter_subset_left ?m.10496
term has type
  ?m.10495 ‚àà ?m.10493
error:  function expected at
  inter_subset_right ?m.10593
term has type
  ?m.10592 ‚àà ?m.10591","theorem locallyIntegrableOn_iff [LocallyCompactSpace X] [T2Space X] (hs : IsClosed s ‚à® IsOpen s) :
    LocallyIntegrableOn f s Œº ‚Üî ‚àÄ (k : Set X), k ‚äÜ s ‚Üí (IsCompact k ‚Üí IntegrableOn f k Œº) ",":= by
  refine ‚ü®fun hf k hk => hf.integrableOn_compact_subset hk, fun hf x hx => ?_‚ü©
  cases hs with
  | inl hs =>
    exact
      let ‚ü®K, hK, h2K‚ü© := exists_compact_mem_nhds x
      ‚ü®_, inter_mem_nhdsWithin s h2K,
        hf _ inter_subset_left
          (hK.of_isClosed_subset (hs.inter hK.isClosed) inter_subset_right)‚ü©
  | inr hs =>
    obtain ‚ü®K, hK, h2K, h3K‚ü© := exists_compact_subset hs hx
    refine ‚ü®K, ?_, hf K h3K hK‚ü©
    simpa only [IsOpen.nhdsWithin_eq hs hx, interior_eq_nhds'] using h2K"
Mathlib/GroupTheory/Perm/Cycle/Concrete.lean,Equiv.Perm.toList_pow_apply_eq_rotate,toList_pow_apply_eq_rotate,2fe45d7ee4d337a32784c65e456d0e97bf19c70e,":= by
  apply ext_get
  ¬∑ simp only [length_toList, cycleOf_self_apply_pow, length_rotate]
  ¬∑ intro n hn hn'
    rw [get_toList, Fin.val_mk, get_rotate, get_toList, Fin.val_mk, length_toList,
      pow_mod_card_support_cycleOf_self_apply, pow_add, mul_apply]","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `Equiv.Perm.nthLe_toList` has been deprecated, use `Equiv.Perm.get_toList` instead
warning:  `Equiv.Perm.nthLe_toList` has been deprecated, use `Equiv.Perm.get_toList` instead
warning:  `Equiv.Perm.nthLe_toList` has been deprecated, use `Equiv.Perm.get_toList` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `Equiv.Perm.nthLe_toList` has been deprecated, use `Equiv.Perm.get_toList` instead
warning:  `Equiv.Perm.nthLe_toList` has been deprecated, use `Equiv.Perm.get_toList` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ‚Üë‚ü®?m.62368, ?h‚ü©
case h
Œ± : Type u_1
inst‚úù¬π : Fintype Œ±
inst‚úù : DecidableEq Œ±
p‚úù : Perm Œ±
x‚úù : Œ±
p : Perm Œ±
x : Œ±
k n : ‚Ñï
hn : n < (p.toList ((p ^ k) x)).length
hn' : n < ((p.toList x).rotate k).length
‚ä¢ (p ^ n) ((p ^ k) x) = ((p.toList x).rotate k).get ‚ü®n, hn'‚ü©
warning:  'decide' tactic does nothing
note: this linter can be disabled with `set_option linter.unusedTactic false`","theorem toList_pow_apply_eq_rotate (p : Perm Œ±) (x : Œ±) (k : ‚Ñï) :
    p.toList ((p ^ k) x) = (p.toList x).rotate k ",":= by
  apply ext_nthLe
  ¬∑ simp only [length_toList, cycleOf_self_apply_pow, length_rotate]
  ¬∑ intro n hn hn'
    rw [nthLe_toList, nthLe_rotate, nthLe_toList, length_toList,
      pow_mod_card_support_cycleOf_self_apply, pow_add, mul_apply]"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.integral_cpow_mul_exp_neg_mul_Ioi,integral_cpow_mul_exp_neg_mul_Ioi,c47ebbbece0d449dca95c589513159cdc2bab40d,":= by
  have aux : (1 / r : ‚ÑÇ) ^ a = 1 / r * (1 / r) ^ (a - 1) := by
    nth_rewrite 2 [‚Üê cpow_one (1 / r : ‚ÑÇ)]
    rw [‚Üê cpow_add _ _ (one_div_ne_zero <| ofReal_ne_zero.mpr hr.ne'), add_sub_cancel'_right]
  calc
    _ = ‚à´ (t : ‚Ñù) in Ioi 0, (1 / r) ^ (a - 1) * (r * t) ^ (a - 1) * exp (-(r * t)) := by
      refine MeasureTheory.set_integral_congr measurableSet_Ioi (fun x (hx : 0 < x) ‚Ü¶ ?_)
      rw [mul_cpow_ofReal_nonneg hr.le hx.le, ‚Üê mul_assoc, one_div, ‚Üê ofReal_inv,
        ‚Üê mul_cpow_ofReal_nonneg (inv_pos.mpr hr).le hr.le, ‚Üê ofReal_mul r‚Åª¬π, inv_mul_cancel hr.ne',
        ofReal_one, one_cpow, one_mul]
    _ = |1 / r| * ‚à´ (t : ‚Ñù) in Ioi (r * 0), (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      simp_rw [‚Üê ofReal_mul]
      rw [integral_comp_mul_left_Ioi (fun x ‚Ü¶ _ * x ^ (a - 1) * exp (-x)) _ hr, mul_zero,
        real_smul, ‚Üê one_div]
    _ = 1 / r * ‚à´ (t : ‚Ñù) in Ioi 0, (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      rw [congr_arg Ioi (mul_zero r), _root_.abs_of_nonneg (one_div_pos.mpr hr).le, ofReal_div,
        ofReal_one]
    _ = 1 / r * (1 / r : ‚ÑÇ) ^ (a - 1) * (‚à´ (t : ‚Ñù) in Ioi 0, t ^ (a - 1) * exp (-t)) := by
      simp_rw [‚Üê integral_mul_left, mul_assoc]
    _ = (1 / r) ^ a * Gamma a := by
      rw [aux, Gamma_eq_integral ha]
      congr 2 with x
      rw [ofReal_exp, ofReal_neg, mul_comm]","warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
error:  unsolved goals
a : ‚ÑÇ
r : ‚Ñù
ha : 0 < a.re
hr : 0 < r
aux : (1 / ‚Üër) ^ a = 1 / ‚Üër * (1 / ‚Üër) ^ (a - 1)
‚ä¢ ‚Üë(1 / r) * ‚à´ (x : ‚Ñù) in Ioi 0, (1 / ‚Üër) ^ (a - 1) * ‚Üëx ^ (a - 1) * cexp (-‚Üëx) =
    ‚Üë|1 / r| * ‚à´ (t : ‚Ñù) in Ioi 0, (1 / ‚Üër) ^ (a - 1) * ‚Üët ^ (a - 1) * cexp (-‚Üët)","lemma integral_cpow_mul_exp_neg_mul_Ioi {a : ‚ÑÇ} {r : ‚Ñù} (ha : 0 < a.re) (hr : 0 < r) :
    ‚à´ (t : ‚Ñù) in Ioi 0, t ^ (a - 1) * exp (-(r * t)) = (1 / r) ^ a * Gamma a ",":= by
  have aux : (1 / r : ‚ÑÇ) ^ a = 1 / r * (1 / r) ^ (a - 1) := by
    nth_rewrite 2 [‚Üê cpow_one (1 / r : ‚ÑÇ)]
    rw [‚Üê cpow_add _ _ (one_div_ne_zero <| ofReal_ne_zero.mpr hr.ne'), add_sub_cancel]
  calc
    _ = ‚à´ (t : ‚Ñù) in Ioi 0, (1 / r) ^ (a - 1) * (r * t) ^ (a - 1) * exp (-(r * t)) := by
      refine MeasureTheory.setIntegral_congr measurableSet_Ioi (fun x hx ‚Ü¶ ?_)
      rw [mem_Ioi] at hx
      rw [mul_cpow_ofReal_nonneg hr.le hx.le, ‚Üê mul_assoc, one_div, ‚Üê ofReal_inv,
        ‚Üê mul_cpow_ofReal_nonneg (inv_pos.mpr hr).le hr.le, ‚Üê ofReal_mul r‚Åª¬π, inv_mul_cancel hr.ne',
        ofReal_one, one_cpow, one_mul]
    _ = 1 / r * ‚à´ (t : ‚Ñù) in Ioi 0, (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      simp_rw [‚Üê ofReal_mul]
      rw [integral_comp_mul_left_Ioi (fun x ‚Ü¶ _ * x ^ (a - 1) * exp (-x)) _ hr, mul_zero,
        real_smul, ‚Üê one_div, ofReal_div, ofReal_one]
    _ = 1 / r * (1 / r : ‚ÑÇ) ^ (a - 1) * (‚à´ (t : ‚Ñù) in Ioi 0, t ^ (a - 1) * exp (-t)) := by
      simp_rw [‚Üê integral_mul_left, mul_assoc]
    _ = (1 / r) ^ a * Gamma a := by
      rw [aux, Gamma_eq_integral ha]
      congr 2 with x
      rw [ofReal_exp, ofReal_neg, mul_comm]"
Mathlib/Topology/ProperMap.lean,isProperMap_iff_isClosedMap_and_tendsto_cofinite,isProperMap_iff_isClosedMap_and_tendsto_cofinite,8c47c4038ef15eef85511d722c657967f031d078,":= by
  simp_rw [isProperMap_iff_isClosedMap_and_compact_fibers, Tendsto,
    le_cofinite_iff_compl_singleton_mem, mem_map, preimage_compl]
  refine and_congr_right fun f_cont ‚Ü¶ and_congr_right fun _ ‚Ü¶
    ‚ü®fun H y ‚Ü¶ (H y).compl_mem_cocompact, fun H y ‚Ü¶ ?_‚ü©
  rcases mem_cocompact.mp (H y) with ‚ü®K, hK, hKy‚ü©
  exact isCompact_of_isClosed_subset hK (isClosed_singleton.preimage f_cont)
    (compl_le_compl_iff_le.mp hKy)",error:  unknown identifier 'isCompact_of_isClosed_subset',"lemma isProperMap_iff_isClosedMap_and_tendsto_cofinite [T1Space Y] :
    IsProperMap f ‚Üî Continuous f ‚àß IsClosedMap f ‚àß Tendsto f (cocompact X) cofinite ",":= by
  simp_rw [isProperMap_iff_isClosedMap_and_compact_fibers, Tendsto,
    le_cofinite_iff_compl_singleton_mem, mem_map, preimage_compl]
  refine and_congr_right fun f_cont ‚Ü¶ and_congr_right fun _ ‚Ü¶
    ‚ü®fun H y ‚Ü¶ (H y).compl_mem_cocompact, fun H y ‚Ü¶ ?_‚ü©
  rcases mem_cocompact.mp (H y) with ‚ü®K, hK, hKy‚ü©
  exact hK.of_isClosed_subset (isClosed_singleton.preimage f_cont)
    (compl_le_compl_iff_le.mp hKy)"
Mathlib/Geometry/Manifold/Metrizable.lean,ManifoldWithCorners.metrizableSpace,ManifoldWithCorners.metrizableSpace,9e34a191034458a56331f976ff7400a26407c888,":= by
  haveI := I.locally_compact; haveI := ChartedSpace.locallyCompact H M
  haveI : NormalSpace M := normal_of_paracompact_t2
  haveI := I.secondCountableTopology
  haveI := ChartedSpace.secondCountable_of_sigma_compact H M
  exact metrizableSpace_of_t3_second_countable M","error:  invalid field 'locally_compact', the environment does not contain 'ModelWithCorners.locally_compact'
  I
has type
  ModelWithCorners ‚Ñù E H
error:  unsolved goals
E : Type u_1
inst‚úù‚Å∑ : NormedAddCommGroup E
inst‚úù‚Å∂ : NormedSpace ‚Ñù E
inst‚úù‚Åµ : FiniteDimensional ‚Ñù E
H : Type u_2
inst‚úù‚Å¥ : TopologicalSpace H
I : ModelWithCorners ‚Ñù E H
M : Type u_3
inst‚úù¬≥ : TopologicalSpace M
inst‚úù¬≤ : ChartedSpace H M
inst‚úù¬π : SigmaCompactSpace M
inst‚úù : T2Space M
‚ä¢ MetrizableSpace M","theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    [FiniteDimensional ‚Ñù E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ‚Ñù E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M ",":= by
  haveI := I.locallyCompactSpace; haveI := ChartedSpace.locallyCompactSpace H M
  haveI := I.secondCountableTopology
  haveI := ChartedSpace.secondCountable_of_sigma_compact H M
  exact metrizableSpace_of_t3_second_countable M"
Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean,TopCat.pullback_snd_range,pullback_snd_range,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  ext y
  constructor
  ¬∑ rintro ‚ü®x, rfl‚ü©
    use (pullback.fst : pullback f g ‚ü∂ _) x
    exact ConcreteCategory.congr_hom pullback.condition x
  ¬∑ rintro ‚ü®x, eq‚ü©
    use (TopCat.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®x, y‚ü©, eq‚ü©
    simp","error:  application type mismatch
  ConcreteCategory.congr_hom pullback.condition x
argument
  x
has type
  ‚Üë(pullback f g) : Type u_1
but is expected to have type
  (forget ?m.140582).obj (pullback ?m.140587 ?m.140588) : Type ?u.140572
error:  unsolved goals
case h
J : Type v
inst‚úù : SmallCategory J
X‚úù Y‚úù Z : TopCat
X Y S : TopCat
f : X ‚ü∂ S
g : Y ‚ü∂ S
y : ‚ÜëY
x : ‚ÜëX
eq : f x = g y
‚ä¢ pullback.snd ((pullbackIsoProdSubtype f g).inv ‚ü®(x, y), eq‚ü©) = y","theorem pullback_snd_range {X Y S : TopCat} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) :
    Set.range (pullback.snd : pullback f g ‚ü∂ _) = { y : Y | ‚àÉ x : X, f x = g y } ",":= by
  ext y
  constructor
  ¬∑ rintro ‚ü®(x : (forget TopCat).obj _), rfl‚ü©
    use (pullback.fst : pullback f g ‚ü∂ _) x
    exact ConcreteCategory.congr_hom pullback.condition x
  ¬∑ rintro ‚ü®x, eq‚ü©
    use (TopCat.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®x, y‚ü©, eq‚ü©
    rw [pullbackIsoProdSubtype_inv_snd_apply]"
Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean,PrimeSpectrum.vanishingIdeal_irreducibleComponents,vanishingIdeal_irreducibleComponents,be0091071535c6ef4ffb576dcfd44cbfb47033df,":= by
  rw [irreducibleComponents_eq_maximals_irreducibleClosed, minimalPrimes_eq_minimals,
    ‚Üê minimals_swap, ‚Üê vanishingIdeal_isIrreducibleClosed, image_minimals_of_rel_iff_rel]
  exact fun s t hs _ ‚Ü¶ vanishingIdeal_anti_mono_iff hs.2","error:  unknown identifier 'irreducibleComponents_eq_maximals_irreducibleClosed'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.154068
R : Type u
S : Type v
inst‚úù : CommSemiring R
‚ä¢ vanishingIdeal '' irreducibleComponents (PrimeSpectrum R) = minimalPrimes R","lemma vanishingIdeal_irreducibleComponents :
    vanishingIdeal '' (irreducibleComponents <| PrimeSpectrum R) =
    minimalPrimes R ",":= by
  rw [irreducibleComponents_eq_maximals_closed, minimalPrimes_eq_minimals, ‚Üê minimals_swap,
    ‚Üê PrimeSpectrum.vanishingIdeal_isClosed_isIrreducible, image_minimals_of_rel_iff_rel]
  exact fun s t hs _ ‚Ü¶ vanishingIdeal_anti_mono_iff hs.1"
Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean,IsPrimitiveRoot.minpoly_dvd_cyclotomic,_root_.IsPrimitiveRoot.minpoly_dvd_cyclotomic,4968eba95a704a4a58e8b3735dc3733ee6d46c0d,":= by
  apply minpoly.isIntegrallyClosed_dvd (h.isIntegral hpos)
  simpa [aeval_def, eval‚ÇÇ_eq_eval_map, IsRoot.definition] using h.isRoot_cyclotomic hpos","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsRoot
has type
  ?m.47446[X] ‚Üí ?m.47446 ‚Üí Prop","theorem _root_.IsPrimitiveRoot.minpoly_dvd_cyclotomic {n : ‚Ñï} {K : Type*} [Field K] {Œº : K}
    (h : IsPrimitiveRoot Œº n) (hpos : 0 < n) [CharZero K] : minpoly ‚Ñ§ Œº ‚à£ cyclotomic n ‚Ñ§ ",":= by
  apply minpoly.isIntegrallyClosed_dvd (h.isIntegral hpos)
  simpa [aeval_def, eval‚ÇÇ_eq_eval_map, IsRoot.def] using h.isRoot_cyclotomic hpos"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,961db629df93e5dbd02440deee4c37efcf2faa85,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  type mismatch
  mul_le_mul_left' IH (‚ÜëN / (‚ÜëN + 1))
has type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * ((‚ÜëN / (‚ÜëN + 1)) ^ n * Œº s) : Prop
but is expected to have type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ (‚ÜëN / (‚ÜëN + 1)) ^ n * (‚ÜëN / (‚ÜëN + 1) * Œº s) : Prop
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/LinearAlgebra/LinearPMap.lean,LinearPMap.smul_graph,smul_graph,c438a06cb616a5e483fefc71bcf86a535642c566,":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  ¬∑ rw [mem_graph_iff] at h
    rcases h with ‚ü®y, hy, h‚ü©
    rw [LinearPMap.smul_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id.def,
      LinearMap.smul_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y, hy
  rw [Submodule.mem_map] at h
  rcases h with ‚ü®x', hx', h‚ü©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id.def, LinearMap.smul_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' ‚ä¢
  rcases hx' with ‚ü®y, hy, hx'‚ü©
  use y
  rw [‚Üê h.1, ‚Üê h.2]
  simp [hy, hx']","warning:  LinearPMap does not have a doc string
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.532750 ‚Üí ?m.532750
error:  unsolved goals
case right
R : Type u_1
inst‚úù‚Åπ : Ring R
E : Type u_2
inst‚úù‚Å∏ : AddCommGroup E
inst‚úù‚Å∑ : Module R E
F : Type u_3
inst‚úù‚Å∂ : AddCommGroup F
inst‚úù‚Åµ : Module R F
G : Type u_4
inst‚úù‚Å¥ : AddCommGroup G
inst‚úù¬≥ : Module R G
M : Type u_5
inst‚úù¬≤ : Monoid M
inst‚úù¬π : DistribMulAction M F
inst‚úù : SMulCommClass R M F
y‚úù : M
f : E ‚Üí‚Çó.[R] F
z : M
x_fst : E
x_snd : F
y : ‚Ü•(z ‚Ä¢ f).domain
hy : ‚Üëy = (x_fst, x_snd).1
h : z ‚Ä¢ ‚Üëf y = (x_fst, x_snd).2
‚ä¢ id x_fst = x_fst ‚àß z ‚Ä¢ id (‚Üëf y) = x_snd
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.536551 ‚Üí ?m.536551","theorem smul_graph (f : E ‚Üí‚Çó.[R] F) (z : M) :
    (z ‚Ä¢ f).graph =
      f.graph.map ((LinearMap.id : E ‚Üí‚Çó[R] E).prodMap (z ‚Ä¢ (LinearMap.id : F ‚Üí‚Çó[R] F))) ",":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  ¬∑ rw [mem_graph_iff] at h
    rcases h with ‚ü®y, hy, h‚ü©
    rw [LinearPMap.smul_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id,
      LinearMap.smul_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y, hy
  rw [Submodule.mem_map] at h
  rcases h with ‚ü®x', hx', h‚ü©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id, LinearMap.smul_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' ‚ä¢
  rcases hx' with ‚ü®y, hy, hx'‚ü©
  use y
  rw [‚Üê h.1, ‚Üê h.2]
  simp [hy, hx']"
Mathlib/CategoryTheory/Sites/Over.lean,CategoryTheory.GrothendieckTopology.over_forget_compatiblePreserving,over_forget_compatiblePreserving,9072ff84a0d139a344bf9eed4a00c4cd27596c79,  Compatible {F Z T x hx Y‚ÇÅ Y‚ÇÇ W f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ h} := by,error:  expected '{' or indented tactic sequence,"lemma over_forget_compatiblePreserving (X : C) :
    CompatiblePreserving J (Over.forget X) where
","  compatible {F Z T x hx Y‚ÇÅ Y‚ÇÇ W f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ h} := by
    let W' : Over X := Over.mk (f‚ÇÅ ‚â´ Y‚ÇÅ.hom)
    let g‚ÇÅ' : W' ‚ü∂ Y‚ÇÅ := Over.homMk f‚ÇÅ
    let g‚ÇÇ' : W' ‚ü∂ Y‚ÇÇ := Over.homMk f‚ÇÇ (by simpa using h.symm =‚â´ Z.hom)
    exact hx g‚ÇÅ' g‚ÇÇ' hg‚ÇÅ hg‚ÇÇ (by ext; exact h)"
Mathlib/Analysis/Convex/Slope.lean,strictConvexOn_of_slope_strict_mono_adjacent,strictConvexOn_of_slope_strict_mono_adjacent,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  LinearOrder.strictConvexOn_of_lt hs fun x hx z hz hxz a b ha hb hab => by
    let y := a * x + b * z
    have hxy : x < y := by
      rw [‚Üê one_mul x, ‚Üê hab, add_mul]
      exact add_lt_add_left ((mul_lt_mul_left hb).2 hxz) _
    have hyz : y < z := by
      rw [‚Üê one_mul z, ‚Üê hab, add_mul]
      exact add_lt_add_right ((mul_lt_mul_left ha).2 hxz) _
    have : (f y - f x) * (z - y) < (f z - f y) * (y - x) :=
      (div_lt_div_iff (sub_pos.2 hxy) (sub_pos.2 hyz)).1 (hf hx hz hxy hyz)
    have hxz : 0 < z - x := sub_pos.2 (hxy.trans hyz)
    have ha : (z - y) / (z - x) = a := by
      rw [eq_comm, ‚Üê sub_eq_iff_eq_add'] at hab
      simp_rw [div_eq_iff hxz.ne', ‚Üê hab]
      ring
    have hb : (y - x) / (z - x) = b := by
      rw [eq_comm, ‚Üê sub_eq_iff_eq_add] at hab
      simp_rw [div_eq_iff hxz.ne', ‚Üê hab]
      ring
    rwa [sub_mul, sub_mul, sub_lt_iff_lt_add', ‚Üê add_sub_assoc, lt_sub_iff_add_lt, ‚Üê mul_add,
      sub_add_sub_cancel, ‚Üê lt_div_iff hxz, add_div, mul_div_assoc, mul_div_assoc, mul_comm (f x),
      mul_comm (f z), ha, hb] at this","error:  simp made no progress
error:  simp made no progress","theorem strictConvexOn_of_slope_strict_mono_adjacent (hs : Convex ùïú s)
    (hf :
      ‚àÄ {x y z : ùïú},
        x ‚àà s ‚Üí z ‚àà s ‚Üí x < y ‚Üí y < z ‚Üí (f y - f x) / (y - x) < (f z - f y) / (z - y)) :
    StrictConvexOn ùïú s f ",":=
  LinearOrder.strictConvexOn_of_lt hs fun x hx z hz hxz a b ha hb hab => by
    let y := a * x + b * z
    have hxy : x < y := by
      rw [‚Üê one_mul x, ‚Üê hab, add_mul]
      exact add_lt_add_left ((mul_lt_mul_left hb).2 hxz) _
    have hyz : y < z := by
      rw [‚Üê one_mul z, ‚Üê hab, add_mul]
      exact add_lt_add_right ((mul_lt_mul_left ha).2 hxz) _
    have : (f y - f x) * (z - y) < (f z - f y) * (y - x) :=
      (div_lt_div_iff (sub_pos.2 hxy) (sub_pos.2 hyz)).1 (hf hx hz hxy hyz)
    have hxz : 0 < z - x := sub_pos.2 (hxy.trans hyz)
    have ha : (z - y) / (z - x) = a := by
      rw [eq_comm, ‚Üê sub_eq_iff_eq_add'] at hab
      dsimp [y]
      simp_rw [div_eq_iff hxz.ne', ‚Üê hab]
      ring
    have hb : (y - x) / (z - x) = b := by
      rw [eq_comm, ‚Üê sub_eq_iff_eq_add] at hab
      dsimp [y]
      simp_rw [div_eq_iff hxz.ne', ‚Üê hab]
      ring
    rwa [sub_mul, sub_mul, sub_lt_iff_lt_add', ‚Üê add_sub_assoc, lt_sub_iff_add_lt, ‚Üê mul_add,
      sub_add_sub_cancel, ‚Üê lt_div_iff hxz, add_div, mul_div_assoc, mul_div_assoc, mul_comm (f x),
      mul_comm (f z), ha, hb] at this"
Mathlib/Order/WellFoundedSet.lean,Set.IsWF.min_union,IsWF.min_union,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  refine le_antisymm (le_min (IsWF.min_le_min_of_subset (subset_union_left _ _))
    (IsWF.min_le_min_of_subset (subset_union_right _ _))) ?_
  rw [min_le_iff]
  exact ((mem_union _ _ _).1 ((hs.union ht).min_mem (union_nonempty.2 (.inl hsn)))).imp
    (hs.min_le _) (ht.min_le _)","error:  function expected at
  subset_union_left ?m.45260
term has type
  ?m.45259 ‚àà ?m.45257 ‚à™ ?m.45258
error:  function expected at
  subset_union_right ?m.45348
term has type
  ?m.45347 ‚àà ?m.45345 ‚à™ ?m.45346","theorem IsWF.min_union (hs : s.IsWF) (hsn : s.Nonempty) (ht : t.IsWF) (htn : t.Nonempty) :
    (hs.union ht).min (union_nonempty.2 (Or.intro_left _ hsn)) =
      Min.min (hs.min hsn) (ht.min htn) ",":= by
  refine le_antisymm (le_min (IsWF.min_le_min_of_subset subset_union_left)
    (IsWF.min_le_min_of_subset subset_union_right)) ?_
  rw [min_le_iff]
  exact ((mem_union _ _ _).1 ((hs.union ht).min_mem (union_nonempty.2 (.inl hsn)))).imp
    (hs.min_le _) (ht.min_le _)"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.hausdorffMeasure_pi_real,hausdorffMeasure_pi_real,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  classical
  refine (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)
    (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) ?_).symm
  simp only [mem_iUnion, mem_singleton_iff]
  intro s hs
  choose a b H using hs
  obtain rfl : s = fun i => Ioo (Œ± := ‚Ñù) (a i) (b i) := funext fun i => (H i).2
  replace H := fun i => (H i).1
  apply le_antisymm _
  ¬∑ have Hle : volume ‚â§ (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) := by
      refine' le_hausdorffMeasure _ _ ‚àû ENNReal.coe_lt_top fun s _ => _
      rw [ENNReal.rpow_nat_cast]
      exact Real.volume_pi_le_diam_pow s
    rw [‚Üê volume_pi_pi fun i => Ioo (a i : ‚Ñù) (b i)]
    exact Measure.le_iff'.1 Hle _
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := fun i => by
    simpa only [sub_nonneg, Rat.cast_le] using (H i).le
  let Œ≥ := fun n : ‚Ñï => ‚àÄ i : Œπ, Fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä
  let t : ‚àÄ n : ‚Ñï, Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f =>
    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)
  have A : Tendsto (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) atTop (ùìù 0) := by
    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]
  have B : ‚àÄ·∂† n in atTop, ‚àÄ i : Œ≥ n, diam (t n i) ‚â§ 1 / n := by
    refine' eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
    intro f
    refine' diam_pi_le_of_le fun b => _
    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel_left, ENNReal.ofReal_one, ENNReal.ofReal_coe_nat]
  have C : ‚àÄ·∂† n in atTop, (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ i : Œ≥ n, t n i := by
    refine' eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
    have npos : (0 : ‚Ñù) < n := Nat.cast_pos.2 hn
    intro x hx
    simp only [mem_Ioo, mem_univ_pi] at hx
    simp only [t, mem_iUnion, mem_Ioo, mem_univ_pi]
    let f : Œ≥ n := fun i =>
      ‚ü®‚åä(x i - a i) * n‚åã‚Çä, by
        apply Nat.floor_lt_ceil_of_lt_of_pos
        ¬∑ refine' (mul_lt_mul_right npos).2 _
          simp only [(hx i).right, sub_lt_sub_iff_right]
        ¬∑ refine' mul_pos _ npos
          simpa only [Rat.cast_lt, sub_pos] using H i‚ü©
    refine' ‚ü®f, fun i => ‚ü®_, _‚ü©‚ü©
    ¬∑ calc
        (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + (x i - a i) * n / n := by
          refine' add_le_add le_rfl ((div_le_div_right npos).2 _)
          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
        _ = x i := by field_simp [npos.ne']
    ¬∑ calc
        x i = (a i : ‚Ñù) + (x i - a i) * n / n := by field_simp [npos.ne']
        _ ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n :=
          add_le_add le_rfl ((div_le_div_right npos).2 (Nat.lt_floor_add_one _).le)
  calc
    ŒºH[Fintype.card Œπ] (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚â§
        liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, diam (t n i) ^ ((Fintype.card Œπ) : ‚Ñù)) atTop :=
      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : ‚Ñù) (b i))
        (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) A t B C
    _ ‚â§ liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, (1 / (n : ‚Ñù‚â•0‚àû)) ^ Fintype.card Œπ) atTop := by
      refine' liminf_le_liminf _ _
      ¬∑ filter_upwards [B] with _ hn
        apply Finset.sum_le_sum fun i _ => _
        simp only [ENNReal.rpow_nat_cast]
        intros i _
        exact pow_le_pow_left' (hn i) _
      ¬∑ isBoundedDefault
    _ = liminf (fun n : ‚Ñï => ‚àè i : Œπ, (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) atTop := by
      simp only [Œ≥, Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
    _ = ‚àè i : Œπ, volume (Ioo (a i : ‚Ñù) (b i)) := by
      simp only [Real.volume_Ioo]
      apply Tendsto.liminf_eq
      refine' ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => _) fun i _ => _
      ¬∑ apply
          Tendsto.congr' _
            ((ENNReal.continuous_ofReal.tendsto _).comp
              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_nat_cast_atTop_atTop))
        apply eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
        intros n hn
        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,
          ENNReal.ofReal_coe_nat]
      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne.def, not_false_iff]","warning:  `ENNReal.rpow_nat_cast` has been deprecated, use `ENNReal.rpow_natCast` instead
warning:  `ENNReal.ofReal_coe_nat` has been deprecated, use `ENNReal.ofReal_natCast` instead
warning:  `ENNReal.rpow_nat_cast` has been deprecated, use `ENNReal.rpow_natCast` instead
warning:  `tendsto_nat_cast_atTop_atTop` has been deprecated, use `tendsto_natCast_atTop_atTop` instead
warning:  `ENNReal.ofReal_coe_nat` has been deprecated, use `ENNReal.ofReal_natCast` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.259530 ‚Üí ?m.259530 ‚Üí Prop
error:  simp made no progress","theorem hausdorffMeasure_pi_real {Œπ : Type*} [Fintype Œπ] :
    (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) = volume ",":= by
  classical
  refine (pi_eq_generateFrom (fun _ => Real.borel_eq_generateFrom_Ioo_rat.symm)
    (fun _ => Real.isPiSystem_Ioo_rat) (fun _ => Real.finiteSpanningSetsInIooRat _) ?_).symm
  simp only [mem_iUnion, mem_singleton_iff]
  intro s hs
  choose a b H using hs
  obtain rfl : s = fun i => Ioo (Œ± := ‚Ñù) (a i) (b i) := funext fun i => (H i).2
  replace H := fun i => (H i).1
  apply le_antisymm _
  ¬∑ have Hle : volume ‚â§ (ŒºH[Fintype.card Œπ] : Measure (Œπ ‚Üí ‚Ñù)) := by
      refine le_hausdorffMeasure _ _ ‚àû ENNReal.coe_lt_top fun s _ => ?_
      rw [ENNReal.rpow_natCast]
      exact Real.volume_pi_le_diam_pow s
    rw [‚Üê volume_pi_pi fun i => Ioo (a i : ‚Ñù) (b i)]
    exact Measure.le_iff'.1 Hle _
  have I : ‚àÄ i, 0 ‚â§ (b i : ‚Ñù) - a i := fun i => by
    simpa only [sub_nonneg, Rat.cast_le] using (H i).le
  let Œ≥ := fun n : ‚Ñï => ‚àÄ i : Œπ, Fin ‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä
  let t : ‚àÄ n : ‚Ñï, Œ≥ n ‚Üí Set (Œπ ‚Üí ‚Ñù) := fun n f =>
    Set.pi univ fun i => Icc (a i + f i / n) (a i + (f i + 1) / n)
  have A : Tendsto (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) atTop (ùìù 0) := by
    simp only [one_div, ENNReal.tendsto_inv_nat_nhds_zero]
  have B : ‚àÄ·∂† n in atTop, ‚àÄ i : Œ≥ n, diam (t n i) ‚â§ 1 / n := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => ?_‚ü©
    intro f
    refine diam_pi_le_of_le fun b => ?_
    simp only [Real.ediam_Icc, add_div, ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), le_refl,
      add_sub_add_left_eq_sub, add_sub_cancel_left, ENNReal.ofReal_one, ENNReal.ofReal_natCast]
  have C : ‚àÄ·∂† n in atTop, (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚äÜ ‚ãÉ i : Œ≥ n, t n i := by
    refine eventually_atTop.2 ‚ü®1, fun n hn => ?_‚ü©
    have npos : (0 : ‚Ñù) < n := Nat.cast_pos.2 hn
    intro x hx
    simp only [mem_Ioo, mem_univ_pi] at hx
    simp only [t, mem_iUnion, mem_Ioo, mem_univ_pi]
    let f : Œ≥ n := fun i =>
      ‚ü®‚åä(x i - a i) * n‚åã‚Çä, by
        apply Nat.floor_lt_ceil_of_lt_of_pos
        ¬∑ refine (mul_lt_mul_right npos).2 ?_
          simp only [(hx i).right, sub_lt_sub_iff_right]
        ¬∑ refine mul_pos ?_ npos
          simpa only [Rat.cast_lt, sub_pos] using H i‚ü©
    refine ‚ü®f, fun i => ‚ü®?_, ?_‚ü©‚ü©
    ¬∑ calc
        (a i : ‚Ñù) + ‚åä(x i - a i) * n‚åã‚Çä / n ‚â§ (a i : ‚Ñù) + (x i - a i) * n / n := by
          gcongr
          exact Nat.floor_le (mul_nonneg (sub_nonneg.2 (hx i).1.le) npos.le)
        _ = x i := by field_simp [npos.ne']
    ¬∑ calc
        x i = (a i : ‚Ñù) + (x i - a i) * n / n := by field_simp [npos.ne']
        _ ‚â§ (a i : ‚Ñù) + (‚åä(x i - a i) * n‚åã‚Çä + 1) / n := by
          gcongr
          exact (Nat.lt_floor_add_one _).le
  calc
    ŒºH[Fintype.card Œπ] (Set.pi univ fun i : Œπ => Ioo (a i : ‚Ñù) (b i)) ‚â§
        liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, diam (t n i) ^ ((Fintype.card Œπ) : ‚Ñù)) atTop :=
      hausdorffMeasure_le_liminf_sum _ (Set.pi univ fun i => Ioo (a i : ‚Ñù) (b i))
        (fun n : ‚Ñï => 1 / (n : ‚Ñù‚â•0‚àû)) A t B C
    _ ‚â§ liminf (fun n : ‚Ñï => ‚àë i : Œ≥ n, (1 / (n : ‚Ñù‚â•0‚àû)) ^ Fintype.card Œπ) atTop := by
      refine liminf_le_liminf ?_ ?_
      ¬∑ filter_upwards [B] with _ hn
        apply Finset.sum_le_sum fun i _ => _
        simp only [ENNReal.rpow_natCast]
        intros i _
        exact pow_le_pow_left' (hn i) _
      ¬∑ isBoundedDefault
    _ = liminf (fun n : ‚Ñï => ‚àè i : Œπ, (‚åà((b i : ‚Ñù) - a i) * n‚åâ‚Çä : ‚Ñù‚â•0‚àû) / n) atTop := by
      simp only [Œ≥, Finset.card_univ, Nat.cast_prod, one_mul, Fintype.card_fin, Finset.sum_const,
        nsmul_eq_mul, Fintype.card_pi, div_eq_mul_inv, Finset.prod_mul_distrib, Finset.prod_const]
    _ = ‚àè i : Œπ, volume (Ioo (a i : ‚Ñù) (b i)) := by
      simp only [Real.volume_Ioo]
      apply Tendsto.liminf_eq
      refine ENNReal.tendsto_finset_prod_of_ne_top _ (fun i _ => ?_) fun i _ => ?_
      ¬∑ apply
          Tendsto.congr' _
            ((ENNReal.continuous_ofReal.tendsto _).comp
              ((tendsto_nat_ceil_mul_div_atTop (I i)).comp tendsto_natCast_atTop_atTop))
        apply eventually_atTop.2 ‚ü®1, fun n hn => _‚ü©
        intros n hn
        simp only [ENNReal.ofReal_div_of_pos (Nat.cast_pos.mpr hn), comp_apply,
          ENNReal.ofReal_natCast]
      ¬∑ simp only [ENNReal.ofReal_ne_top, Ne, not_false_iff]"
Mathlib/Topology/Algebra/UniformRing.lean,UniformSpace.Completion.continuous_mul,continuous_mul,54d2d04a76999eff29e8b39b03fa3d5fc19ac0e3,":=
  ContinuousMul.continuous_mul","error:  failed to synthesize
  ContinuousMul (Completion Œ±)
use `set_option diagnostics true` to get diagnostic information",theorem continuous_mul : Continuous fun p : Completion Œ± √ó Completion Œ± => p.1 * p.2 ,":= by
  let m := (AddMonoidHom.mul : Œ± ‚Üí+ Œ± ‚Üí+ Œ±).compr‚ÇÇ toCompl
  have : Continuous fun p : Œ± √ó Œ± => m p.1 p.2 := by
    apply (continuous_coe Œ±).comp _
    simp only [AddMonoidHom.coe_mul, AddMonoidHom.coe_mulLeft]
    exact _root_.continuous_mul
  have di : DenseInducing (toCompl : Œ± ‚Üí Completion Œ±) := denseInducing_coe
  convert di.extend_Z_bilin di this"
Mathlib/Analysis/Calculus/MeanValue.lean,domain_mvt,domain_mvt,fdcecc6431ccffb2e1ba4fe8b297b20ee9baa42b,":= by
  set g : ‚Ñù ‚Üí E := fun t => AffineMap.lineMap x y t
  set I := Icc (0 : ‚Ñù) 1
  have hsub : Ioo (0 : ‚Ñù) 1 ‚äÜ I := Ioo_subset_Icc_self
  have hmaps : MapsTo g I s := hs.mapsTo_lineMap xs ys
  have hfg : ‚àÄ t ‚àà I, HasDerivWithinAt (f ‚àò g) (f' (g t) (y - x)) I t := fun t ht =>
    (hf _ (hmaps ht)).comp_hasDerivWithinAt t AffineMap.hasDerivWithinAt_lineMap hmaps
  have hMVT : ‚àÉ t ‚àà Ioo (0 : ‚Ñù) 1, f' (g t) (y - x) = (f (g 1) - f (g 0)) / (1 - 0) := by
    refine' exists_hasDerivAt_eq_slope (f ‚àò g) _ (by norm_num) _ _
    ¬∑ exact fun t Ht => (hfg t Ht).continuousWithinAt
    ¬∑ exact fun t Ht => (hfg t <| hsub Ht).hasDerivAt (Icc_mem_nhds Ht.1 Ht.2)
  rcases hMVT with ‚ü®t, Ht, hMVT'‚ü©
  rw [segment_eq_image_lineMap, bex_image_iff]
  refine ‚ü®t, hsub Ht, ?_‚ü©
  simpa using hMVT'.symm","warning:  `Set.bex_image_iff` has been deprecated, use `Set.exists_mem_image` instead
error:  type mismatch
  h‚úù
has type
  f (g 1) - f (g 0) = (f' (g t)) y - (f' (g t)) x : Prop
but is expected to have type
  f y - f x = (f' ((AffineMap.lineMap x y) t)) y - (f' ((AffineMap.lineMap x y) t)) x : Prop","theorem domain_mvt {f : E ‚Üí ‚Ñù} {s : Set E} {x y : E} {f' : E ‚Üí E ‚ÜíL[‚Ñù] ‚Ñù}
    (hf : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) (hs : Convex ‚Ñù s) (xs : x ‚àà s) (ys : y ‚àà s) :
    ‚àÉ z ‚àà segment ‚Ñù x y, f y - f x = f' z (y - x) ",":= by
  set g : ‚Ñù ‚Üí E := fun t => AffineMap.lineMap x y t
  set I := Icc (0 : ‚Ñù) 1
  have hsub : Ioo (0 : ‚Ñù) 1 ‚äÜ I := Ioo_subset_Icc_self
  have hmaps : MapsTo g I s := hs.mapsTo_lineMap xs ys
  have hfg : ‚àÄ t ‚àà I, HasDerivWithinAt (f ‚àò g) (f' (g t) (y - x)) I t := fun t ht =>
    (hf _ (hmaps ht)).comp_hasDerivWithinAt t AffineMap.hasDerivWithinAt_lineMap hmaps
  have hMVT : ‚àÉ t ‚àà Ioo (0 : ‚Ñù) 1, f' (g t) (y - x) = (f (g 1) - f (g 0)) / (1 - 0) := by
    refine exists_hasDerivAt_eq_slope (f ‚àò g) _ (by norm_num) ?_ ?_
    ¬∑ exact fun t Ht => (hfg t Ht).continuousWithinAt
    ¬∑ exact fun t Ht => (hfg t <| hsub Ht).hasDerivAt (Icc_mem_nhds Ht.1 Ht.2)
  rcases hMVT with ‚ü®t, Ht, hMVT'‚ü©
  rw [segment_eq_image_lineMap, exists_mem_image]
  refine ‚ü®t, hsub Ht, ?_‚ü©
  simpa [g] using hMVT'.symm"
Mathlib/Probability/Kernel/RadonNikodym.lean,ProbabilityTheory.kernel.withDensity_one_sub_rnDerivAux,withDensity_one_sub_rnDerivAux,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have h_le : Œ∫ ‚â§ Œ∫ + Œ∑ := le_add_of_nonneg_right bot_le
  suffices withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))
      + withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))
      = Œ∫ + Œ∑ by
    ext a s
    have h : (withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))
          + withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))) a s
        = Œ∫ a s + Œ∑ a s := by
      rw [this]
      simp
    simp only [coeFn_add, Pi.add_apply, Measure.add_toOuterMeasure, OuterMeasure.coe_add]
      at h
    rwa [withDensity_rnDerivAux, add_comm, ENNReal.add_right_inj (measure_ne_top _ _)] at h
  have : ‚àÄ b, (Real.toNNReal b : ‚Ñù‚â•0‚àû) = ENNReal.ofReal b := fun _ ‚Ü¶ rfl
  simp_rw [this, ENNReal.ofReal_sub _ (rnDerivAux_nonneg h_le), ENNReal.ofReal_one]
  rw [withDensity_sub_add_cancel]
  ¬∑ rw [withDensity_one']
  ¬∑ exact measurable_const
  ¬∑ exact (measurable_rnDerivAux _ _).ennreal_ofReal
  ¬∑ refine fun a ‚Ü¶ ae_of_all _ (fun x ‚Ü¶ ?_)
    simp only [ENNReal.ofReal_le_one]
    exact density_le_one ((fst_map_id_prod _ measurable_const).trans_le h_le) _ _ _","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.28285 ?m.28287 + ?m.28280 = ?m.28285 ?m.28287 + ?m.28281
case h.h
Œ± : Type u_1
Œ≥ : Type u_2
mŒ± : MeasurableSpace Œ±
mŒ≥ : MeasurableSpace Œ≥
Œ∫‚úù Œ∑‚úù : ‚Ü•(kernel Œ± Œ≥)
hŒ±Œ≥ : MeasurableSpace.CountableOrCountablyGenerated Œ± Œ≥
Œ∫ Œ∑ : ‚Ü•(kernel Œ± Œ≥)
inst‚úù¬π : IsFiniteKernel Œ∫
inst‚úù : IsFiniteKernel Œ∑
h_le : Œ∫ ‚â§ Œ∫ + Œ∑
this :
  ((withDensity (Œ∫ + Œ∑) fun a x ‚Ü¶ ‚Üë(1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x).toNNReal) +
      withDensity (Œ∫ + Œ∑) fun a x ‚Ü¶ ‚Üë(rnDerivAux Œ∫ (Œ∫ + Œ∑) a x).toNNReal) =
    Œ∫ + Œ∑
a : Œ±
s : Set Œ≥
a‚úù : MeasurableSet s
h : (Œ∫ a + (withDensity (Œ∫ + Œ∑) fun a x ‚Ü¶ ‚Üë(1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x).toNNReal) a) s = (Œ∫ a) s + (Œ∑ a) s
‚ä¢ ((withDensity (Œ∫ + Œ∑) fun a x ‚Ü¶ ‚Üë(1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x).toNNReal) a) s = (Œ∑ a) s
error:  failed to synthesize
  MeasurableSpace.CountablyGenerated Œ≥
use `set_option diagnostics true` to get diagnostic information","lemma withDensity_one_sub_rnDerivAux (Œ∫ Œ∑ : kernel Œ± Œ≥) [IsFiniteKernel Œ∫] [IsFiniteKernel Œ∑] :
    withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x)) = Œ∑ ",":= by
  have h_le : Œ∫ ‚â§ Œ∫ + Œ∑ := le_add_of_nonneg_right bot_le
  suffices withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))
      + withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))
      = Œ∫ + Œ∑ by
    ext a s
    have h : (withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (1 - rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))
          + withDensity (Œ∫ + Œ∑) (fun a x ‚Ü¶ Real.toNNReal (rnDerivAux Œ∫ (Œ∫ + Œ∑) a x))) a s
        = Œ∫ a s + Œ∑ a s := by
      rw [this]
      simp
    simp only [coeFn_add, Pi.add_apply, Measure.coe_add] at h
    rwa [withDensity_rnDerivAux, add_comm, ENNReal.add_right_inj (measure_ne_top _ _)] at h
  have : ‚àÄ b, (Real.toNNReal b : ‚Ñù‚â•0‚àû) = ENNReal.ofReal b := fun _ ‚Ü¶ rfl
  simp_rw [this, ENNReal.ofReal_sub _ (rnDerivAux_nonneg h_le), ENNReal.ofReal_one]
  rw [withDensity_sub_add_cancel]
  ¬∑ rw [withDensity_one']
  ¬∑ exact measurable_const
  ¬∑ exact (measurable_rnDerivAux _ _).ennreal_ofReal
  ¬∑ intro a
    filter_upwards [rnDerivAux_le_one h_le] with x hx
    simp only [ENNReal.ofReal_le_one]
    exact hx"
Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean,MvPolynomial.weightedHomogeneousSubmodule_mul,weightedHomogeneousSubmodule_mul,5bfb9ec189190fec527edb96b64e3187a3de6521,":= by
  classical
  rw [Submodule.mul_le]
  intro œÜ hœÜ œà hœà c hc
  rw [coeff_mul] at hc
  obtain ‚ü®‚ü®d, e‚ü©, hde, H‚ü© := Finset.exists_ne_zero_of_sum_ne_zero hc
  have aux : coeff d œÜ ‚â† 0 ‚àß coeff e œà ‚â† 0 := by
    contrapose! H
    by_cases h : coeff d œÜ = 0 <;>
      simp_all only [Ne.def, not_false_iff, zero_mul, mul_zero]
  rw [‚Üê Finsupp.mem_antidiagonal.mp hde, ‚Üê hœÜ aux.1, ‚Üê hœà aux.2, map_add]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.29296 ‚Üí ?m.29296 ‚Üí Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.29928 ‚Üí ?m.29928 ‚Üí Prop
error:  unsolved goals
case neg
R : Type u_1
M : Type u_2
inst‚úù¬π : CommSemiring R
œÉ : Type u_3
inst‚úù : AddCommMonoid M
w : œÉ ‚Üí M
m n : M
œÜ : MvPolynomial œÉ R
hœÜ : œÜ ‚àà weightedHomogeneousSubmodule R w m
œà : MvPolynomial œÉ R
hœà : œà ‚àà weightedHomogeneousSubmodule R w n
c : œÉ ‚Üí‚ÇÄ ‚Ñï
hc : ‚àë x ‚àà antidiagonal c, coeff x.1 œÜ * coeff x.2 œà ‚â† 0
d e : œÉ ‚Üí‚ÇÄ ‚Ñï
hde : (d, e) ‚àà antidiagonal c
H : coeff d œÜ ‚â† 0 ‚Üí coeff e œà = 0
h : ¬¨coeff d œÜ = 0
‚ä¢ coeff d œÜ * coeff e œà = 0
error:  unknown constant 'Finsupp.mem_antidiagonal.mp'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.30084
case intro.mk.intro
R : Type u_1
M : Type u_2
inst‚úù¬π : CommSemiring R
œÉ : Type u_3
inst‚úù : AddCommMonoid M
w : œÉ ‚Üí M
m n : M
œÜ : MvPolynomial œÉ R
hœÜ : œÜ ‚àà weightedHomogeneousSubmodule R w m
œà : MvPolynomial œÉ R
hœà : œà ‚àà weightedHomogeneousSubmodule R w n
c : œÉ ‚Üí‚ÇÄ ‚Ñï
hc : ‚àë x ‚àà antidiagonal c, coeff x.1 œÜ * coeff x.2 œà ‚â† 0
d e : œÉ ‚Üí‚ÇÄ ‚Ñï
hde : (d, e) ‚àà antidiagonal c
H : coeff (d, e).1 œÜ * coeff (d, e).2 œà ‚â† 0
aux : coeff d œÜ ‚â† 0 ‚àß coeff e œà ‚â† 0
‚ä¢ (weightedDegree w) c = m + n","theorem weightedHomogeneousSubmodule_mul (w : œÉ ‚Üí M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ‚â§
      weightedHomogeneousSubmodule R w (m + n) ",":= by
  classical
  rw [Submodule.mul_le]
  intro œÜ hœÜ œà hœà c hc
  rw [coeff_mul] at hc
  obtain ‚ü®‚ü®d, e‚ü©, hde, H‚ü© := Finset.exists_ne_zero_of_sum_ne_zero hc
  have aux : coeff d œÜ ‚â† 0 ‚àß coeff e œà ‚â† 0 := by
    contrapose! H
    by_cases h : coeff d œÜ = 0 <;>
      simp_all only [Ne, not_false_iff, zero_mul, mul_zero]
  rw [‚Üê mem_antidiagonal.mp hde, ‚Üê hœÜ aux.1, ‚Üê hœà aux.2, map_add]"
Mathlib/RingTheory/IntegralClosure.lean,IsIntegralClosure.algebraMap_equiv,algebraMap_equiv,787f21e24c1b4d0e7a88ac6d76f18bfb080d4d5c,":=
  algebraMap_lift A' B (isIntegral_algebra R B) x","error:  application type mismatch
  @algebraMap_lift A' B (isIntegral_algebra R B)
argument
  isIntegral_algebra R B
has type
  Algebra.IsIntegral R ?m.459271 : Prop
but is expected to have type
  Type ?u.459265 : Type (?u.459265 + 1)",theorem algebraMap_equiv (x : A) : algebraMap A' B (equiv R A B A' x) = algebraMap A B x ,":=
  algebraMap_lift A' B (isIntegral := isIntegral_algebra R B) x"
Mathlib/Data/QPF/Univariate/Basic.lean,QPF.Fix.ind_aux,Fix.ind_aux,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have : Fix.mk (abs ‚ü®a, fun x => ‚ü¶f x‚üß‚ü©) = ‚ü¶Wrepr ‚ü®a, f‚ü©‚üß := by
    apply Quot.sound; apply Wequiv.abs'
    rw [PFunctor.W.dest_mk, abs_map, abs_repr, ‚Üê abs_map, PFunctor.map_eq]
    conv =>
      rhs
      simp only [Wrepr, recF_eq, PFunctor.W.dest_mk, abs_repr, Function.comp]
  rw [this]
  apply Quot.sound
  apply Wrepr_equiv","error:  unsolved goals
case a.h
F : Type u ‚Üí Type u
q : QPF F
a : (P F).A
f : (P F).B a ‚Üí (P F).W
‚ä¢ abs ‚ü®a, fixToW ‚àò fun x ‚Ü¶ ‚ü¶f x‚üß‚ü© =
    abs ((P F).map (recF fun x ‚Ü¶ PFunctor.W.mk (repr x)) (PFunctor.W.dest (WType.mk a f)))","theorem Fix.ind_aux (a : q.P.A) (f : q.P.B a ‚Üí q.P.W) :
    Fix.mk (abs ‚ü®a, fun x => ‚ü¶f x‚üß‚ü©) = ‚ü¶‚ü®a, f‚ü©‚üß ",":= by
  have : Fix.mk (abs ‚ü®a, fun x => ‚ü¶f x‚üß‚ü©) = ‚ü¶Wrepr ‚ü®a, f‚ü©‚üß := by
    apply Quot.sound; apply Wequiv.abs'
    rw [PFunctor.W.dest_mk, abs_map, abs_repr, ‚Üê abs_map, PFunctor.map_eq]
    simp only [Wrepr, recF_eq, PFunctor.W.dest_mk, abs_repr, Function.comp]
    rfl
  rw [this]
  apply Quot.sound
  apply Wrepr_equiv"
Mathlib/Data/List/Rotate.lean,List.get?_rotate,get?_rotate,6b876736761577cfe58b37fc8aa8083f81dccc14,":= by
  simp [getElem?_rotate, hml]","error:  unsolved goals
Œ± : Type u
l : List Œ±
n m : ‚Ñï
hml : m < l.length
‚ä¢ some (l.rotate n)[m] = l[(m + n) % l.length]?
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  @IsRotated does not have a doc string","theorem get?_rotate {l : List Œ±} {n m : ‚Ñï} (hml : m < l.length) :
    (l.rotate n).get? m = l.get? ((m + n) % l.length) ",":= by
  simp only [get?_eq_getElem?, length_rotate, hml, getElem?_eq_getElem, getElem_rotate]
  rw [‚Üê getElem?_eq_getElem]"
Mathlib/RingTheory/DedekindDomain/Ideal.lean,exists_multiset_prod_cons_le_and_prod_not_le,exists_multiset_prod_cons_le_and_prod_not_le,f08cd34408673926d8b49db267d81563a31b378d,":= by
  obtain ‚ü®Z‚ÇÄ, hZ‚ÇÄ‚ü© := PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain hNF hI0
  obtain ‚ü®Z, ‚ü®hZI, hprodZ‚ü©, h_eraseZ‚ü© :=
    Multiset.wellFounded_lt.has_min
      (fun Z => (Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß (Z.map PrimeSpectrum.asIdeal).prod ‚â† ‚ä•)
      ‚ü®Z‚ÇÄ, hZ‚ÇÄ‚ü©
  have hZM : Multiset.prod (Z.map PrimeSpectrum.asIdeal) ‚â§ M := le_trans hZI hIM
  have hZ0 : Z ‚â† 0 := by rintro rfl; simp [hM.ne_top] at hZM
  obtain ‚ü®_, hPZ', hPM‚ü© := (hM.isPrime.multiset_prod_le (mt Multiset.map_eq_zero.mp hZ0)).mp hZM
  obtain ‚ü®P, hPZ, rfl‚ü© := Multiset.mem_map.mp hPZ'
  classical
    have := Multiset.map_erase PrimeSpectrum.asIdeal PrimeSpectrum.ext P Z
    obtain ‚ü®hP0, hZP0‚ü© : P.asIdeal ‚â† ‚ä• ‚àß ((Z.erase P).map PrimeSpectrum.asIdeal).prod ‚â† ‚ä• := by
      rwa [Ne.def, ‚Üê Multiset.cons_erase hPZ', Multiset.prod_cons, Ideal.mul_eq_bot, not_or, ‚Üê
        this] at hprodZ
    have hPM' := (IsDedekindDomain.dimensionLeOne _ hP0 P.IsPrime).eq_of_le hM.ne_top hPM
    subst hPM'
    refine ‚ü®Z.erase P, ?_, ?_‚ü©
    ¬∑ convert hZI
      rw [this, Multiset.cons_erase hPZ']
    ¬∑ refine fun h => h_eraseZ (Z.erase P) ‚ü®h, ?_‚ü© (Multiset.erase_lt.mpr hPZ)
      exact hZP0","error:  unknown constant 'Multiset.wellFounded_lt.has_min'
error:  rcases tactic failed: x‚úù : ?m.159565 is not an inductive datatype","theorem exists_multiset_prod_cons_le_and_prod_not_le [IsDedekindDomain A] (hNF : ¬¨IsField A)
    {I M : Ideal A} (hI0 : I ‚â† ‚ä•) (hIM : I ‚â§ M) [hM : M.IsMaximal] :
    ‚àÉ Z : Multiset (PrimeSpectrum A),
      (M ::‚Çò Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß
        ¬¨Multiset.prod (Z.map PrimeSpectrum.asIdeal) ‚â§ I ",":= by
  obtain ‚ü®Z‚ÇÄ, hZ‚ÇÄ‚ü© := PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain hNF hI0
  obtain ‚ü®Z, ‚ü®hZI, hprodZ‚ü©, h_eraseZ‚ü© :=
    wellFounded_lt.has_min
      {Z | (Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß (Z.map PrimeSpectrum.asIdeal).prod ‚â† ‚ä•}
      ‚ü®Z‚ÇÄ, hZ‚ÇÄ.1, hZ‚ÇÄ.2‚ü©
  obtain ‚ü®_, hPZ', hPM‚ü© := hM.isPrime.multiset_prod_le.mp (hZI.trans hIM)
  obtain ‚ü®P, hPZ, rfl‚ü© := Multiset.mem_map.mp hPZ'
  classical
    have := Multiset.map_erase PrimeSpectrum.asIdeal PrimeSpectrum.ext P Z
    obtain ‚ü®hP0, hZP0‚ü© : P.asIdeal ‚â† ‚ä• ‚àß ((Z.erase P).map PrimeSpectrum.asIdeal).prod ‚â† ‚ä• := by
      rwa [Ne, ‚Üê Multiset.cons_erase hPZ', Multiset.prod_cons, Ideal.mul_eq_bot, not_or, ‚Üê
        this] at hprodZ
    have hPM' := (P.isPrime.isMaximal hP0).eq_of_le hM.ne_top hPM
    subst hPM'
    refine ‚ü®Z.erase P, ?_, ?_‚ü©
    ¬∑ convert hZI
      rw [this, Multiset.cons_erase hPZ']
    ¬∑ refine fun h => h_eraseZ (Z.erase P) ‚ü®h, ?_‚ü© (Multiset.erase_lt.mpr hPZ)
      exact hZP0"
Mathlib/MeasureTheory/Function/Jacobian.lean,ApproximatesLinearOn.norm_fderiv_sub_le,_root_.ApproximatesLinearOn.norm_fderiv_sub_le,c7bd9bd10c613e1788107ba753e252f069560f87,":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ by
    have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by continuity) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.definition Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel'_right]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := (norm_add_le _ _)
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel', sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := (norm_sub_le _ _)
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel', norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
        mul_le_mul_of_nonneg_left norm_a (mul_nonneg rpos.le (add_nonneg Œ¥.2 Œµpos.le))
  calc
    ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
      congr 1
      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
      abel
    _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := (norm_add_le _ _)
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
      apply add_le_add
      ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
      ¬∑ apply ContinuousLinearMap.le_opNorm
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ :=
      add_le_add le_rfl
        (mul_le_mul_of_nonneg_left (mem_closedBall_iff_norm'.1 az) (norm_nonneg _))","error:  invalid field 'definition', the environment does not contain 'Asymptotics.IsLittleO.definition'
  (hf' x xs).isLittleO
has type
  (fun x' ‚Ü¶ f x' - f x - (f' x) (x' - x)) =o[ùìù[s] x] fun x' ‚Ü¶ x' - x
warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead","theorem _root_.ApproximatesLinearOn.norm_fderiv_sub_le {A : E ‚ÜíL[‚Ñù] E} {Œ¥ : ‚Ñù‚â•0}
    (hf : ApproximatesLinearOn f A s Œ¥) (hs : MeasurableSet s) (f' : E ‚Üí E ‚ÜíL[‚Ñù] E)
    (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) : ‚àÄ·µê x ‚àÇŒº.restrict s, ‚Äñf' x - A‚Äñ‚Çä ‚â§ Œ¥ ",":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ by
    have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by fun_prop) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel_left, sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := norm_sub_le _ _
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel_left, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) := by gcongr
  calc
    ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
      congr 1
      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
      abel
    _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
      apply add_le_add
      ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
      ¬∑ apply ContinuousLinearMap.le_opNorm
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ := by
      rw [mem_closedBall_iff_norm'] at az
      gcongr"
Mathlib/Combinatorics/SimpleGraph/Triangle/Basic.lean,SimpleGraph.EdgeDisjointTriangles.map,EdgeDisjointTriangles.map,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [EdgeDisjointTriangles, cliqueSet_map (by norm_num : 3 ‚â† 1),
    ((Finset.map_injective f).injOn _).pairwise_image]
  classical
  rintro s hs t ht hst
  dsimp [Function.onFun]
  rw [‚Üê coe_inter, ‚Üê map_inter, coe_map, coe_inter]
  exact (hG hs ht hst).image _","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Function.Injective.injOn (Finset.map_injective f) ?m.2746
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Finset Œ±‚¶Ñ, x‚ÇÇ ‚àà ?m.2744 ‚Üí Finset.map f ?m.2745 = Finset.map f x‚ÇÇ ‚Üí ?m.2745 = x‚ÇÇ
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.2748
Œ± : Type u_1
Œ≤ : Type u_2
ùïú : Type u_3
inst‚úù : LinearOrderedField ùïú
G H : SimpleGraph Œ±
Œµ Œ¥ : ùïú
n : ‚Ñï
s : Finset Œ±
f : Œ± ‚Ü™ Œ≤
hG : G.EdgeDisjointTriangles
‚ä¢ (Finset.map f '' G.cliqueSet 3).Pairwise fun x y ‚Ü¶ (‚Üëx ‚à© ‚Üëy).Subsingleton","lemma EdgeDisjointTriangles.map (f : Œ± ‚Ü™ Œ≤) (hG : G.EdgeDisjointTriangles) :
    (G.map f).EdgeDisjointTriangles ",":= by
  rw [EdgeDisjointTriangles, cliqueSet_map (by norm_num : 3 ‚â† 1),
    (Finset.map_injective f).injOn.pairwise_image]
  classical
  rintro s hs t ht hst
  dsimp [Function.onFun]
  rw [‚Üê coe_inter, ‚Üê map_inter, coe_map, coe_inter]
  exact (hG hs ht hst).image _"
Mathlib/Data/Nat/Size.lean,Nat.size_bit,size_bit,c047c646d66e915f27c3e7f159bef508bfc8dd10,":= by
  rw [size]
  conv =>
    lhs
    rw [binaryRec]
    simp [h]
  rfl","warning:  `bit1` has been deprecated
error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
b : Bool
n : ‚Ñï
h : bit b n ‚â† 0
‚ä¢ binaryRec 0 (fun x x ‚Ü¶ succ) (bit b n).div2 + 1 = (binaryRec 0 (fun x x ‚Ü¶ succ) n).succ
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated",theorem size_bit {b n} (h : bit b n ‚â† 0) : size (bit b n) = succ (size n) ,":= by
  rw [size]
  conv =>
    lhs
    rw [binaryRec]
    simp [h]
  rw [div2_bit]"
Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean,MeasureTheory.Measure.rnDeriv_withDensity_right,rnDeriv_withDensity_right,0a88f90fd4cfa7135d7bd7e34ca7799b79b40573,":= by
  have : SigmaFinite (ŒΩ.withDensity f) := SigmaFinite.withDensity_of_ne_top hf hf_ne_top
  refine (withDensity_absolutelyContinuous' hf hf_ne_zero hf_ne_top).ae_eq ?_
  refine (Measure.eq_rnDeriv‚ÇÄ (ŒΩ := ŒΩ.withDensity f) ?_ Measure.MutuallySingular.zero_left ?_).symm
  ¬∑ exact (hf.inv.mono_ac (withDensity_absolutelyContinuous _ _)).mul
      (Measure.measurable_rnDeriv _ _).aemeasurable
  ¬∑ ext1 s hs
    conv_lhs => rw [‚Üê Measure.withDensity_rnDeriv_eq _ _ hŒºŒΩ]
    rw [zero_add, withDensity_apply _ hs, withDensity_apply _ hs]
    rw [set_lintegral_withDensity_eq_set_lintegral_mul_non_measurable‚ÇÄ _ _ _ hs]
    ¬∑ simp only [Pi.mul_apply]
      have : (fun a ‚Ü¶ f a * ((f a)‚Åª¬π * Œº.rnDeriv ŒΩ a)) =·µê[ŒΩ] Œº.rnDeriv ŒΩ := by
        filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2
        simp [‚Üê mul_assoc, ENNReal.mul_inv_cancel, hx1, hx2]
      rw [lintegral_congr_ae (ae_restrict_of_ae this)]
    ¬∑ refine ae_restrict_of_ae ?_
      filter_upwards [hf_ne_top] with x hx using hx.lt_top
    ¬∑ exact hf.restrict","error:  application type mismatch
  withDensity_absolutelyContinuous' hf hf_ne_zero hf_ne_top
argument
  hf_ne_top
has type
  ‚àÄ·µê (x : Œ±) ‚àÇŒΩ, f x ‚â† ‚ä§ : Prop
but is expected to have type
  (ŒΩ.withDensity f) ?m.16000 = 0 : Prop
error:  no goals to be solved","lemma rnDeriv_withDensity_right_of_absolutelyContinuous {ŒΩ : Measure Œ±} [SigmaFinite Œº]
    [SigmaFinite ŒΩ] (hŒºŒΩ : Œº ‚â™ ŒΩ) (hf : AEMeasurable f ŒΩ)
    (hf_ne_zero : ‚àÄ·µê x ‚àÇŒΩ, f x ‚â† 0) (hf_ne_top : ‚àÄ·µê x ‚àÇŒΩ, f x ‚â† ‚àû) :
    Œº.rnDeriv (ŒΩ.withDensity f) =·µê[ŒΩ] fun x ‚Ü¶ (f x)‚Åª¬π * Œº.rnDeriv ŒΩ x ",":= by
  have : SigmaFinite (ŒΩ.withDensity f) := SigmaFinite.withDensity_of_ne_top hf hf_ne_top
  refine (withDensity_absolutelyContinuous' hf hf_ne_zero).ae_eq ?_
  refine (Measure.eq_rnDeriv‚ÇÄ (ŒΩ := ŒΩ.withDensity f) ?_ Measure.MutuallySingular.zero_left ?_).symm
  ¬∑ exact (hf.inv.mono_ac (withDensity_absolutelyContinuous _ _)).mul
      (Measure.measurable_rnDeriv _ _).aemeasurable
  ¬∑ ext1 s hs
    conv_lhs => rw [‚Üê Measure.withDensity_rnDeriv_eq _ _ hŒºŒΩ]
    rw [zero_add, withDensity_apply _ hs, withDensity_apply _ hs]
    rw [setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable‚ÇÄ _ _ _ hs]
    ¬∑ simp only [Pi.mul_apply]
      have : (fun a ‚Ü¶ f a * ((f a)‚Åª¬π * Œº.rnDeriv ŒΩ a)) =·µê[ŒΩ] Œº.rnDeriv ŒΩ := by
        filter_upwards [hf_ne_zero, hf_ne_top] with x hx1 hx2
        simp [‚Üê mul_assoc, ENNReal.mul_inv_cancel, hx1, hx2]
      rw [lintegral_congr_ae (ae_restrict_of_ae this)]
    ¬∑ refine ae_restrict_of_ae ?_
      filter_upwards [hf_ne_top] with x hx using hx.lt_top
    ¬∑ exact hf.restrict"
Mathlib/Topology/Algebra/Valuation.lean,Valuation.subgroups_basis,subgroups_basis,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  { inter := by
      rintro Œ≥‚ÇÄ Œ≥‚ÇÅ
      use min Œ≥‚ÇÄ Œ≥‚ÇÅ
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro Œ≥
      cases' exists_square_le Œ≥ with Œ≥‚ÇÄ h
      use Œ≥‚ÇÄ
      rintro - ‚ü®r, s, r_in, s_in, rfl‚ü©
      calc
        (v (r * s) : Œì‚ÇÄ) = v r * v s := Valuation.map_mul _ _ _
        _ < Œ≥‚ÇÄ * Œ≥‚ÇÄ := (mul_lt_mul‚ÇÄ r_in s_in)
        _ ‚â§ Œ≥ := by exact_mod_cast h
    leftMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use (1 : Œì‚ÇÄÀ£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (x * y) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt
    rightMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (y * x) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt }","error:  application type mismatch
  v s
argument
  s
has type
  r ‚àà ‚Üë(v.ltAddSubgroup Œ≥‚ÇÄ) : Prop
but is expected to have type
  R : Type u
error:  invalid 'calc' step, failed to synthesize `Trans` instance
  Trans LT.lt Membership.mem ?m.10809
use `set_option diagnostics true` to get diagnostic information",theorem subgroups_basis : RingSubgroupsBasis fun Œ≥ : Œì‚ÇÄÀ£ => (v.ltAddSubgroup Œ≥ : AddSubgroup R) ,":=
  { inter := by
      rintro Œ≥‚ÇÄ Œ≥‚ÇÅ
      use min Œ≥‚ÇÄ Œ≥‚ÇÅ
      simp only [ltAddSubgroup, ge_iff_le, Units.min_val, Units.val_le_val, lt_min_iff,
        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,
        forall_const, and_true]
      tauto
    mul := by
      rintro Œ≥
      cases' exists_square_le Œ≥ with Œ≥‚ÇÄ h
      use Œ≥‚ÇÄ
      rintro - ‚ü®r, r_in, s, s_in, rfl‚ü©
      calc
        (v (r * s) : Œì‚ÇÄ) = v r * v s := Valuation.map_mul _ _ _
        _ < Œ≥‚ÇÄ * Œ≥‚ÇÄ := mul_lt_mul‚ÇÄ r_in s_in
        _ ‚â§ Œ≥ := mod_cast h
    leftMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use (1 : Œì‚ÇÄÀ£)
        rintro y _
        change v (x * y) < _
        rw [Valuation.map_mul, Hx, zero_mul]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (x * y) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx, mul_comm]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt
    rightMul := by
      rintro x Œ≥
      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ‚ü®Œ≥x, Hx‚ü©)
      ¬∑ use 1
        rintro y _
        change v (y * x) < _
        rw [Valuation.map_mul, Hx, mul_zero]
        exact Units.zero_lt Œ≥
      ¬∑ use Œ≥x‚Åª¬π * Œ≥
        rintro y (vy_lt : v y < ‚Üë(Œ≥x‚Åª¬π * Œ≥))
        change (v (y * x) : Œì‚ÇÄ) < Œ≥
        rw [Valuation.map_mul, Hx]
        rw [Units.val_mul, mul_comm] at vy_lt
        simpa using mul_inv_lt_of_lt_mul‚ÇÄ vy_lt }"
Mathlib/MeasureTheory/Function/Jacobian.lean,ApproximatesLinearOn.norm_fderiv_sub_le,_root_.ApproximatesLinearOn.norm_fderiv_sub_le,9e34a191034458a56331f976ff7400a26407c888,":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.op_norm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ
  ¬∑ have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by continuity) 0) nhdsWithin_le_nhds
    simp only [add_zero, MulZeroClass.mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 (IsLittleO.def (hf' x xs) Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset bounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel'_right]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := (norm_add_le _ _)
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel', sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := (norm_sub_le _ _)
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel', norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
        mul_le_mul_of_nonneg_left norm_a (mul_nonneg rpos.le (add_nonneg Œ¥.2 Œµpos.le))
  show ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ;
  exact
    calc
      ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := (norm_add_le _ _)
      _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
        apply add_le_add
        ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
        ¬∑ apply ContinuousLinearMap.le_op_norm
      _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ :=
        add_le_add le_rfl
          (mul_le_mul_of_nonneg_left (mem_closedBall_iff_norm'.1 az) (norm_nonneg _))",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem _root_.ApproximatesLinearOn.norm_fderiv_sub_le {A : E ‚ÜíL[‚Ñù] E} {Œ¥ : ‚Ñù‚â•0}
    (hf : ApproximatesLinearOn f A s Œ¥) (hs : MeasurableSet s) (f' : E ‚Üí E ‚ÜíL[‚Ñù] E)
    (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) : ‚àÄ·µê x ‚àÇŒº.restrict s, ‚Äñf' x - A‚Äñ‚Çä ‚â§ Œ¥ ",":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ by
    have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by fun_prop) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel_left, sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := norm_sub_le _ _
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel_left, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) := by gcongr
  calc
    ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
      congr 1
      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
      abel
    _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
      apply add_le_add
      ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
      ¬∑ apply ContinuousLinearMap.le_opNorm
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ := by
      rw [mem_closedBall_iff_norm'] at az
      gcongr"
Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean,coeff_minpolyDiv_sub_pow_mem_span,coeff_minpolyDiv_sub_pow_mem_span,403f0036f3625bbf32f578e4b9f9f7ff5d5648bd,":= by
  induction i with
  | zero => simp [(minpolyDiv_monic hx).leadingCoeff]
  | succ i IH =>
    rw [coeff_minpolyDiv, add_sub_assoc, pow_succ', ‚Üê sub_mul, Algebra.algebraMap_eq_smul_one]
    refine add_mem ?_ ?_
    ¬∑ apply Submodule.smul_mem
      apply Submodule.subset_span
      exact ‚ü®0, Nat.zero_lt_succ _, pow_zero _‚ü©
    ¬∑ rw [‚Üê tsub_tsub, tsub_add_cancel_of_le (le_tsub_of_add_le_left (b := 1) hi)]
      apply SetLike.le_def.mp ?_
        (Submodule.mul_mem_mul (IH ((Nat.le_succ _).trans hi))
          (Submodule.mem_span_singleton_self x))
      rw [Submodule.span_mul_span, Set.mul_singleton, Set.image_image]
      apply Submodule.span_mono
      rintro _ ‚ü®j, hj, rfl‚ü©
      rw [Set.mem_Iio] at hj
      exact ‚ü®j + 1, Nat.add_lt_of_lt_sub hj, pow_succ' x j‚ü©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * ?c - ?b * ?c
case succ
R : Type u_2
K : Type ?u.79175
L : Type ?u.79178
S : Type u_1
inst‚úù‚Åµ : CommRing R
inst‚úù‚Å¥ : Field K
inst‚úù¬≥ : Field L
inst‚úù¬≤ : CommRing S
inst‚úù¬π : Algebra R S
inst‚úù : Algebra K L
x : S
hx : IsIntegral R x
i : ‚Ñï
IH :
  i ‚â§ (minpolyDiv R x).natDegree ‚Üí
    (minpolyDiv R x).coeff ((minpolyDiv R x).natDegree - i) - x ^ i ‚àà
      Submodule.span R ((fun x_1 ‚Ü¶ x ^ x_1) '' Set.Iio i)
hi : i + 1 ‚â§ (minpolyDiv R x).natDegree
‚ä¢ (algebraMap R S) ((minpoly R x).coeff ((minpolyDiv R x).natDegree - (i + 1) + 1)) +
      ((minpolyDiv R x).coeff ((minpolyDiv R x).natDegree - (i + 1) + 1) * x - x * x ^ i) ‚àà
    Submodule.span R ((fun x_1 ‚Ü¶ x ^ x_1) '' Set.Iio (i + 1))","lemma coeff_minpolyDiv_sub_pow_mem_span {i} (hi : i ‚â§ natDegree (minpolyDiv R x)) :
    coeff (minpolyDiv R x) (natDegree (minpolyDiv R x) - i) - x ^ i ‚àà
      Submodule.span R ((x ^ ¬∑) '' Set.Iio i) ",":= by
  induction i with
  | zero => simp [(minpolyDiv_monic hx).leadingCoeff]
  | succ i IH =>
    rw [coeff_minpolyDiv, add_sub_assoc, pow_succ, ‚Üê sub_mul, Algebra.algebraMap_eq_smul_one]
    refine add_mem ?_ ?_
    ¬∑ apply Submodule.smul_mem
      apply Submodule.subset_span
      exact ‚ü®0, Nat.zero_lt_succ _, pow_zero _‚ü©
    ¬∑ rw [‚Üê tsub_tsub, tsub_add_cancel_of_le (le_tsub_of_add_le_left (b := 1) hi)]
      apply SetLike.le_def.mp ?_
        (Submodule.mul_mem_mul (IH ((Nat.le_succ _).trans hi))
          (Submodule.mem_span_singleton_self x))
      rw [Submodule.span_mul_span, Set.mul_singleton, Set.image_image]
      apply Submodule.span_mono
      rintro _ ‚ü®j, hj, rfl‚ü©
      rw [Set.mem_Iio] at hj
      exact ‚ü®j + 1, Nat.add_lt_of_lt_sub hj, pow_succ x j‚ü©"
Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean,MeasureTheory.Measure.tendsto_addHaar_inter_smul_one_of_density_one_aux,tendsto_addHaar_inter_smul_one_of_density_one_aux,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  have I : ‚àÄ u v, Œº u ‚â† 0 ‚Üí Œº u ‚â† ‚àû ‚Üí MeasurableSet v ‚Üí
    Œº u / Œº u - Œº (v·∂ú ‚à© u) / Œº u = Œº (v ‚à© u) / Œº u := by
    intro u v uzero utop vmeas
    simp_rw [div_eq_mul_inv]
    rw [‚Üê ENNReal.sub_mul]; swap
    ¬∑ simp only [uzero, ENNReal.inv_eq_top, imp_true_iff, Ne, not_false_iff]
    congr 1
    apply
      ENNReal.sub_eq_of_add_eq (ne_top_of_le_ne_top utop (measure_mono (inter_subset_right _ _)))
    rw [inter_comm _ u, inter_comm _ u]
    exact measure_inter_add_diff u vmeas
  have L : Tendsto (fun r => Œº (s·∂ú ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 0) := by
    have A : Tendsto (fun r => Œº (closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1) := by
      apply tendsto_const_nhds.congr' _
      filter_upwards [self_mem_nhdsWithin]
      intro r hr
      rw [div_eq_mul_inv, ENNReal.mul_inv_cancel]
      ¬∑ exact (measure_closedBall_pos Œº _ hr).ne'
      ¬∑ exact measure_closedBall_lt_top.ne
    have B := ENNReal.Tendsto.sub A h (Or.inl ENNReal.one_ne_top)
    simp only [tsub_self] at B
    apply B.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    convert I (closedBall x r) s·∂ú (measure_closedBall_pos Œº _ rpos).ne'
      measure_closedBall_lt_top.ne hs.compl
    rw [compl_compl]
  have L' : Tendsto (fun r : ‚Ñù => Œº (s·∂ú ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 0) :=
    tendsto_addHaar_inter_smul_zero_of_density_zero Œº s·∂ú x L t ht h''t
  have L'' : Tendsto (fun r : ‚Ñù => Œº ({x} + r ‚Ä¢ t) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) := by
    apply tendsto_const_nhds.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    rw [addHaar_singleton_add_smul_div_singleton_add_smul Œº rpos.ne', ENNReal.div_self h't h''t]
  have := ENNReal.Tendsto.sub L'' L' (Or.inl ENNReal.one_ne_top)
  simp only [tsub_zero] at this
  apply this.congr' _
  filter_upwards [self_mem_nhdsWithin]
  rintro r (rpos : 0 < r)
  refine' I ({x} + r ‚Ä¢ t) s _ _ hs
  ¬∑ simp only [h't, abs_of_nonneg rpos.le, pow_pos rpos, addHaar_smul, image_add_left,
      ENNReal.ofReal_eq_zero, not_le, or_false_iff, Ne, measure_preimage_add, abs_pow,
      singleton_add, mul_eq_zero]
  ¬∑ simp [h''t, ENNReal.ofReal_ne_top, addHaar_smul, image_add_left, ENNReal.mul_eq_top,
      Ne, not_false_iff, measure_preimage_add, singleton_add, and_false_iff, false_and_iff,
      or_self_iff]","error:  function expected at
  inter_subset_right ?m.538807
term has type
  ?m.538806 ‚àà ?m.538805","theorem tendsto_addHaar_inter_smul_one_of_density_one_aux (s : Set E) (hs : MeasurableSet s)
    (x : E) (h : Tendsto (fun r => Œº (s ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1))
    (t : Set E) (ht : MeasurableSet t) (h't : Œº t ‚â† 0) (h''t : Œº t ‚â† ‚àû) :
    Tendsto (fun r : ‚Ñù => Œº (s ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) ",":= by
  have I : ‚àÄ u v, Œº u ‚â† 0 ‚Üí Œº u ‚â† ‚àû ‚Üí MeasurableSet v ‚Üí
    Œº u / Œº u - Œº (v·∂ú ‚à© u) / Œº u = Œº (v ‚à© u) / Œº u := by
    intro u v uzero utop vmeas
    simp_rw [div_eq_mul_inv]
    rw [‚Üê ENNReal.sub_mul]; swap
    ¬∑ simp only [uzero, ENNReal.inv_eq_top, imp_true_iff, Ne, not_false_iff]
    congr 1
    apply
      ENNReal.sub_eq_of_add_eq (ne_top_of_le_ne_top utop (measure_mono inter_subset_right))
    rw [inter_comm _ u, inter_comm _ u]
    exact measure_inter_add_diff u vmeas
  have L : Tendsto (fun r => Œº (s·∂ú ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 0) := by
    have A : Tendsto (fun r => Œº (closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù 1) := by
      apply tendsto_const_nhds.congr' _
      filter_upwards [self_mem_nhdsWithin]
      intro r hr
      rw [div_eq_mul_inv, ENNReal.mul_inv_cancel]
      ¬∑ exact (measure_closedBall_pos Œº _ hr).ne'
      ¬∑ exact measure_closedBall_lt_top.ne
    have B := ENNReal.Tendsto.sub A h (Or.inl ENNReal.one_ne_top)
    simp only [tsub_self] at B
    apply B.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    convert I (closedBall x r) s·∂ú (measure_closedBall_pos Œº _ rpos).ne'
      measure_closedBall_lt_top.ne hs.compl
    rw [compl_compl]
  have L' : Tendsto (fun r : ‚Ñù => Œº (s·∂ú ‚à© ({x} + r ‚Ä¢ t)) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 0) :=
    tendsto_addHaar_inter_smul_zero_of_density_zero Œº s·∂ú x L t ht h''t
  have L'' : Tendsto (fun r : ‚Ñù => Œº ({x} + r ‚Ä¢ t) / Œº ({x} + r ‚Ä¢ t)) (ùìù[>] 0) (ùìù 1) := by
    apply tendsto_const_nhds.congr' _
    filter_upwards [self_mem_nhdsWithin]
    rintro r (rpos : 0 < r)
    rw [addHaar_singleton_add_smul_div_singleton_add_smul Œº rpos.ne', ENNReal.div_self h't h''t]
  have := ENNReal.Tendsto.sub L'' L' (Or.inl ENNReal.one_ne_top)
  simp only [tsub_zero] at this
  apply this.congr' _
  filter_upwards [self_mem_nhdsWithin]
  rintro r (rpos : 0 < r)
  refine I ({x} + r ‚Ä¢ t) s ?_ ?_ hs
  ¬∑ simp only [h't, abs_of_nonneg rpos.le, pow_pos rpos, addHaar_smul, image_add_left,
      ENNReal.ofReal_eq_zero, not_le, or_false_iff, Ne, measure_preimage_add, abs_pow,
      singleton_add, mul_eq_zero]
  ¬∑ simp [h''t, ENNReal.ofReal_ne_top, addHaar_smul, image_add_left, ENNReal.mul_eq_top,
      Ne, not_false_iff, measure_preimage_add, singleton_add, and_false_iff, false_and_iff,
      or_self_iff]"
Mathlib/Algebra/Homology/ExactSequence.lean,CategoryTheory.ComposableArrows.exact_iff_Œ¥last,exact_iff_Œ¥last,4ce1bee1aec1b13e15aa7ab6b7f2b65c272ebb54,":= by
  constructor
  ¬∑ intro h
    constructor
    ¬∑ exact Exact.mk (IsComplex.mk (fun i hi => h.toIsComplex.zero i))
        (fun i hi => h.exact i)
    ¬∑ rw [exact‚ÇÇ_iff]; swap
      ¬∑ rw [isComplex‚ÇÇ_iff]
        exact h.toIsComplex.zero n
      exact h.exact n (by linarith)
  ¬∑ rintro ‚ü®h, h'‚ü©
    refine' Exact.mk (IsComplex.mk (fun i hi => _)) (fun i hi => _)
    ¬∑ obtain hi | rfl := LE.le.lt_or_eq (show i ‚â§ n by linarith)
      ¬∑ exact h.toIsComplex.zero i
      ¬∑ exact h'.toIsComplex.zero 0
    ¬∑ obtain hi | rfl := LE.le.lt_or_eq (show i ‚â§ n by linarith)
      ¬∑ exact h.exact i
      ¬∑ exact h'.exact 0","error:  unknown tactic
error:  unsolved goals
C : Type u_1
inst‚úù¬π : Category.{u_2, u_1} C
inst‚úù : HasZeroMorphisms C
n‚úù : ‚Ñï
S‚úù : ComposableArrows C n‚úù
n : ‚Ñï
S : ComposableArrows C (n + 2)
h : S.Exact
‚ä¢ n + 2 ‚â§ n + 2
error:  unsolved goals
case mpr
C : Type u_1
inst‚úù¬π : Category.{u_2, u_1} C
inst‚úù : HasZeroMorphisms C
n‚úù : ‚Ñï
S‚úù : ComposableArrows C n‚úù
n : ‚Ñï
S : ComposableArrows C (n + 2)
‚ä¢ S.Œ¥last.Exact ‚àß (mk‚ÇÇ (S.map' n (n + 1) ‚ãØ ‚ãØ) (S.map' (n + 1) (n + 2) ‚ãØ ‚ãØ)).Exact ‚Üí S.Exact","lemma exact_iff_Œ¥last {n : ‚Ñï} (S : ComposableArrows C (n + 2)) :
    S.Exact ‚Üî S.Œ¥last.Exact ‚àß (mk‚ÇÇ (S.map' n (n + 1)) (S.map' (n + 1) (n + 2))).Exact ",":= by
  constructor
  ¬∑ intro h
    constructor
    ¬∑ exact Exact.mk (IsComplex.mk (fun i hi => h.toIsComplex.zero i))
        (fun i hi => h.exact i)
    ¬∑ rw [exact‚ÇÇ_iff]; swap
      ¬∑ rw [isComplex‚ÇÇ_iff]
        exact h.toIsComplex.zero n
      exact h.exact n (by omega)
  ¬∑ rintro ‚ü®h, h'‚ü©
    refine Exact.mk (IsComplex.mk (fun i hi => ?_)) (fun i hi => ?_)
    ¬∑ simp only [add_le_add_iff_right, ge_iff_le] at hi
      obtain hi | rfl := hi.lt_or_eq
      ¬∑ exact h.toIsComplex.zero i
      ¬∑ exact h'.toIsComplex.zero 0
    ¬∑ simp only [add_le_add_iff_right, ge_iff_le] at hi
      obtain hi | rfl := hi.lt_or_eq
      ¬∑ exact h.exact i
      ¬∑ exact h'.exact 0"
Mathlib/RingTheory/Adjoin/PowerBasis.lean,PowerBasis.repr_mul_isIntegral,repr_mul_isIntegral,a76dc22f3a90e5ab96e9284d30276a87a4324a5d,":= by
  intro i
  rw [‚Üê B.basis.sum_repr x, ‚Üê B.basis.sum_repr y, Finset.sum_mul_sum, map_sum, Finset.sum_apply']
  refine' IsIntegral.sum _ fun I _ => _
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smul‚Çõ‚Çó,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine' IsIntegral.mul (hy _) (IsIntegral.mul (hx _) _)
  simp only [coe_basis, ‚Üê pow_add]
  refine' repr_gen_pow_isIntegral hB hmin _ _","error:  type mismatch
  IsIntegral.mul (hy ?m.63129) (IsIntegral.mul (hx ?m.63330) ?m.63331)
has type
  IsIntegral R ((B.basis.repr y) ?m.63129 * ((B.basis.repr x) ?m.63330 * ?m.63147)) : Prop
but is expected to have type
  IsIntegral R
    ((B.basis.repr (‚àë x_1 : Fin B.dim, (B.basis.repr y) x_1 ‚Ä¢ (B.basis.repr x) I ‚Ä¢ (B.basis I * B.basis x_1))) i) : Prop
error:  application type mismatch
  repr_mul_isIntegral hB
argument
  hB
has type
  IsIntegral R B.gen : Prop
but is expected to have type
  ‚àÄ (i : Fin ?m.77814.dim), IsIntegral ?m.77807 ((?m.77814.basis.repr ?m.77816) i) : Prop
error:  application type mismatch
  repr_pow_isIntegral hB
argument
  hB
has type
  IsIntegral R B.gen : Prop
but is expected to have type
  ‚àÄ (i : Fin ?m.84086.dim), IsIntegral ?m.84079 ((?m.84086.basis.repr ?m.84088) i) : Prop
error:  no goals to be solved","theorem repr_mul_isIntegral [IsDomain S] {x y : A} (hx : ‚àÄ i, IsIntegral R (B.basis.repr x i))
    (hy : ‚àÄ i, IsIntegral R (B.basis.repr y i))
    (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) :
    ‚àÄ i, IsIntegral R (B.basis.repr (x * y) i) ",":= by
  intro i
  rw [‚Üê B.basis.sum_repr x, ‚Üê B.basis.sum_repr y, Finset.sum_mul_sum, ‚Üê Finset.sum_product',
    map_sum, Finset.sum_apply']
  refine IsIntegral.sum _ fun I _ => ?_
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smul‚Çõ‚Çó,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine (hy _).mul ((hx _).mul ?_)
  simp only [coe_basis, ‚Üê pow_add]
  exact repr_gen_pow_isIntegral hB hmin _ _"
Mathlib/MeasureTheory/Integral/FundThmCalculus.lean,intervalIntegral.sub_le_integral_of_hasDeriv_right_of_le,sub_le_integral_of_hasDeriv_right_of_le,9d12b609274b44fc79ae79f9347cf8a3782b6a95,":= by
  refine' le_of_forall_pos_le_add fun Œµ Œµpos => _
  rcases exists_lt_lowerSemicontinuous_integral_lt œÜ œÜint Œµpos with
    ‚ü®G', f_lt_G', G'cont, G'int, G'lt_top, hG'‚ü©
  set s := {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} ‚à© Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, ‚à´ u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [‚Üê uIcc_of_le hab] at G'int hcont ‚ä¢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [s, inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b ‚äÜ {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain ‚ü®y, g'_lt_y', y_lt_G'‚ü© : ‚àÉ y : ‚Ñù, (g' t : EReal) < y ‚àß (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hœÜg t ht.2)).trans_lt (f_lt_G' t))
    have I1 : ‚àÄ·∂† u in ùìù[>] t, (u - t) * y ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      have B : ‚àÄ·∂† u in ùìù t, (y : EReal) < G' u := G'cont.eventually_lt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with ‚ü®m, M, ‚ü®hm, hM‚ü©, H‚ü©
      have : Ioo t (min M b) ‚àà ùìù[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u ‚äÜ Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = ‚à´ _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ ‚â§ ‚à´ w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, ‚Üê integral_Icc_eq_integral_Ioc]
          apply set_integral_mono_ae_restrict
          ¬∑ simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          ¬∑ exact IntegrableOn.mono_set G'int I
          ¬∑ have C1 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), G' x < ‚àû :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), x ‚àà Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x ‚àà Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t ‚ü®ht.2.1, ht.2.2‚ü©).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [‚Üê smul_eq_mul, sub_smul_slope] at this
    have I3 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : ‚àÄ·∂† u in ùìù[>] t, u ‚àà Ioc t (min v b) := by
      refine' mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 ‚ü®min v b, _, Subset.rfl‚ü©
      simp only [lt_min_iff, mem_Ioi]
      exact ‚ü®t_lt_v, ht.2.2‚ü©
    rcases (I3.and I4).exists with ‚ü®x, hx, h'x‚ü©
    refine' ‚ü®x, _, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x‚ü©
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ ‚â§ (‚à´ w in a..t, (G' w).toReal) + ‚à´ w in t..x, (G' w).toReal := (add_le_add ht.1 hx)
      _ = ‚à´ w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        ¬∑ rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        ¬∑ rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a ‚â§ ‚à´ y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ ‚â§ (‚à´ y in a..b, œÜ y) + Œµ := by
      convert hG'.le <;>
        ¬∑ rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]","error:  invalid field 'eventually_lt', the environment does not contain 'LowerSemicontinuous.eventually_lt'
  G'cont
has type
  LowerSemicontinuous G'
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  G'cont
has type
  ‚àÄ (x : ‚Ñù), LowerSemicontinuousAt G' x
warning:  `MeasureTheory.set_integral_mono_ae_restrict` has been deprecated, use `MeasureTheory.setIntegral_mono_ae_restrict` instead","theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a ‚â§ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (œÜint : IntegrableOn œÜ (Icc a b)) (hœÜg : ‚àÄ x ‚àà Ico a b, g' x ‚â§ œÜ x) :
    g b - g a ‚â§ ‚à´ y in a..b, œÜ y ",":= by
  refine le_of_forall_pos_le_add fun Œµ Œµpos => ?_
  rcases exists_lt_lowerSemicontinuous_integral_lt œÜ œÜint Œµpos with
    ‚ü®G', f_lt_G', G'cont, G'int, G'lt_top, hG'‚ü©
  set s := {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} ‚à© Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, ‚à´ u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [‚Üê uIcc_of_le hab] at G'int hcont ‚ä¢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [s, inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b ‚äÜ {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain ‚ü®y, g'_lt_y', y_lt_G'‚ü© : ‚àÉ y : ‚Ñù, (g' t : EReal) < y ‚àß (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hœÜg t ht.2)).trans_lt (f_lt_G' t))
    have I1 : ‚àÄ·∂† u in ùìù[>] t, (u - t) * y ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      have B : ‚àÄ·∂† u in ùìù t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with ‚ü®m, M, ‚ü®hm, hM‚ü©, H‚ü©
      have : Ioo t (min M b) ‚àà ùìù[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u ‚äÜ Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = ‚à´ _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ ‚â§ ‚à´ w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, ‚Üê integral_Icc_eq_integral_Ioc]
          apply setIntegral_mono_ae_restrict
          ¬∑ simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          ¬∑ exact IntegrableOn.mono_set G'int I
          ¬∑ have C1 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), G' x < ‚àû :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), x ‚àà Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x ‚àà Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t ‚ü®ht.2.1, ht.2.2‚ü©).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [‚Üê smul_eq_mul, sub_smul_slope] at this
    have I3 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : ‚àÄ·∂† u in ùìù[>] t, u ‚àà Ioc t (min v b) := by
      refine mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 ‚ü®min v b, ?_, Subset.rfl‚ü©
      simp only [lt_min_iff, mem_Ioi]
      exact ‚ü®t_lt_v, ht.2.2‚ü©
    rcases (I3.and I4).exists with ‚ü®x, hx, h'x‚ü©
    refine ‚ü®x, ?_, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x‚ü©
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ ‚â§ (‚à´ w in a..t, (G' w).toReal) + ‚à´ w in t..x, (G' w).toReal := add_le_add ht.1 hx
      _ = ‚à´ w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        ¬∑ rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        ¬∑ rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a ‚â§ ‚à´ y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ ‚â§ (‚à´ y in a..b, œÜ y) + Œµ := by
      convert hG'.le <;>
        ¬∑ rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]"
Mathlib/RingTheory/Flat/Basic.lean,Module.Flat.of_retract,of_retract,7c70b57520f13e0a034f5fd1c7ac51ceda0c4dc3,":= by
  rw [iff_rTensor_injective] at *
  intro I hI
  have h‚ÇÅ : Function.Injective (lTensor R i)
  ¬∑ apply Function.RightInverse.injective (g := (lTensor R r))
    intro x
    rw [‚Üê LinearMap.comp_apply, ‚Üê lTensor_comp, h]
    simp
  rw [‚Üê Function.Injective.of_comp_iff h‚ÇÅ (rTensor N I.subtype), ‚Üê LinearMap.coe_comp]
  rw [LinearMap.lTensor_comp_rTensor, ‚Üê LinearMap.rTensor_comp_lTensor]
  rw [LinearMap.coe_comp, Function.Injective.of_comp_iff (f hI)]
  apply Function.RightInverse.injective (g := lTensor _ r)
  intro x
  rw [‚Üê LinearMap.comp_apply, ‚Üê lTensor_comp, h]
  simp","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
R : Type u
M : Type v
inst‚úù‚Å¥ : CommRing R
inst‚úù¬≥ : AddCommGroup M
inst‚úù¬≤ : Module R M
N : Type w
inst‚úù¬π : AddCommGroup N
inst‚úù : Module R N
f : ‚àÄ ‚¶ÉI : Ideal R‚¶Ñ, I.FG ‚Üí Function.Injective ‚áë(rTensor M (Submodule.subtype I))
i : N ‚Üí‚Çó[R] M
r : M ‚Üí‚Çó[R] N
h : r ‚àò‚Çó i = LinearMap.id
I : Ideal R
hI : I.FG
h‚ÇÅ : Function.Injective ‚áë(lTensor R i)
‚ä¢ Function.Injective ‚áë(rTensor N (Submodule.subtype I))","lemma of_retract [f : Flat R M] (i : N ‚Üí‚Çó[R] M) (r : M ‚Üí‚Çó[R] N) (h : r.comp i = LinearMap.id) :
    Flat R N ",":= by
  rw [iff_rTensor_injective] at *
  intro I hI
  have h‚ÇÅ : Function.Injective (lTensor R i) := by
    apply Function.RightInverse.injective (g := (lTensor R r))
    intro x
    rw [‚Üê LinearMap.comp_apply, ‚Üê lTensor_comp, h]
    simp
  rw [‚Üê Function.Injective.of_comp_iff h‚ÇÅ (rTensor N I.subtype), ‚Üê LinearMap.coe_comp]
  rw [LinearMap.lTensor_comp_rTensor, ‚Üê LinearMap.rTensor_comp_lTensor]
  rw [LinearMap.coe_comp, Function.Injective.of_comp_iff (f hI)]
  apply Function.RightInverse.injective (g := lTensor _ r)
  intro x
  rw [‚Üê LinearMap.comp_apply, ‚Üê lTensor_comp, h]
  simp"
Mathlib/Geometry/Manifold/ContMDiffMFDeriv.lean,ContMDiffOn.contMDiffOn_tangentMapWithin,ContMDiffOn.contMDiffOn_tangentMapWithin,a9e5c97a54df0543783bff424b120a30b61a4aac,":= by
  have m_le_n : m ‚â§ n := (le_add_right le_rfl).trans hmn
  have one_le_n : 1 ‚â§ n := (le_add_left le_rfl).trans hmn
  have U' : UniqueDiffOn ùïú (range I ‚à© I.symm ‚Åª¬π' s) := fun y hy ‚Ü¶ by
    simpa only [UniqueMDiffOn, UniqueMDiffWithinAt, hy.1, inter_comm, mfld_simps]
      using hs (I.symm y) hy.2
  rw [contMDiffOn_iff]
  refine' ‚ü®hf.continuousOn_tangentMapWithin_aux one_le_n hs, fun p q => _‚ü©
  suffices h :
    ContDiffOn ùïú m
      (((fun p : H' √ó E' => (I' p.fst, p.snd)) ‚àò TotalSpace.toProd H' E') ‚àò
        tangentMapWithin I I' f s ‚àò
          (TotalSpace.toProd H E).symm ‚àò fun p : E √ó E => (I.symm p.fst, p.snd))
      ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ univ)
  ¬∑ 
    convert h using 1
    ¬∑ ext1 ‚ü®x, y‚ü©
      simp only [mfld_simps]; rfl
    ¬∑ simp only [mfld_simps]
      rw [inter_prod, prod_univ, prod_univ]
      rfl
  change
    ContDiffOn ùïú m
      (fun p : E √ó E =>
        ((I' (f (I.symm p.fst)), (mfderivWithin I I' f s (I.symm p.fst) : E ‚Üí E') p.snd) : E' √ó E'))
      ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ univ)
  have hf' := contMDiffOn_iff.1 hf
  have A : ContDiffOn ùïú m (I' ‚àò f ‚àò I.symm) (range I ‚à© I.symm ‚Åª¬π' s) := by
    simpa only [mfld_simps] using (hf'.2 (I.symm 0) (I'.symm 0)).of_le m_le_n
  have B : ContDiffOn ùïú m
      ((I' ‚àò f ‚àò I.symm) ‚àò Prod.fst) ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ (univ : Set E)) :=
    A.comp contDiff_fst.contDiffOn (prod_subset_preimage_fst _ _)
  suffices C :
    ContDiffOn ùïú m
      (fun p : E √ó E => (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) p.1 : _) p.2)
      ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ (univ : Set E))
  ¬∑ refine ContDiffOn.prod B ?_
    refine C.congr fun p hp => ?_
    simp only [mfld_simps] at hp
    simp only [mfderivWithin, hf.mdifferentiableOn one_le_n _ hp.2, hp.1, if_pos, mfld_simps]
    rfl
  have D :
    ContDiffOn ùïú m (fun x => fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) x)
      (range I ‚à© I.symm ‚Åª¬π' s) := by
    have : ContDiffOn ùïú n (I' ‚àò f ‚àò I.symm) (range I ‚à© I.symm ‚Åª¬π' s) := by
      simpa only [mfld_simps] using hf'.2 (I.symm 0) (I'.symm 0)
    simpa only [inter_comm] using this.fderivWithin U' hmn
  refine ContDiffOn.clm_apply ?_ contDiffOn_snd
  exact D.comp contDiff_fst.contDiffOn (prod_subset_preimage_fst _ _)",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem ContMDiffOn.contMDiffOn_tangentMapWithin_aux {f : H ‚Üí H'} {s : Set H}
    (hf : ContMDiffOn I I' n f s) (hmn : m + 1 ‚â§ n) (hs : UniqueMDiffOn I s) :
    ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s)
      (œÄ E (TangentSpace I) ‚Åª¬π' s) ",":= by
  have m_le_n : m ‚â§ n := (le_add_right le_rfl).trans hmn
  have one_le_n : 1 ‚â§ n := (le_add_left le_rfl).trans hmn
  have U' : UniqueDiffOn ùïú (range I ‚à© I.symm ‚Åª¬π' s) := fun y hy ‚Ü¶ by
    simpa only [UniqueMDiffOn, UniqueMDiffWithinAt, hy.1, inter_comm, mfld_simps]
      using hs (I.symm y) hy.2
  rw [contMDiffOn_iff]
  refine ‚ü®hf.continuousOn_tangentMapWithin_aux one_le_n hs, fun p q => ?_‚ü©
  suffices h :
    ContDiffOn ùïú m
      (((fun p : H' √ó E' => (I' p.fst, p.snd)) ‚àò TotalSpace.toProd H' E') ‚àò
        tangentMapWithin I I' f s ‚àò
          (TotalSpace.toProd H E).symm ‚àò fun p : E √ó E => (I.symm p.fst, p.snd))
      ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ univ) by
    convert h using 1
    ¬∑ ext1 ‚ü®x, y‚ü©
      simp only [mfld_simps]; rfl
    ¬∑ simp only [mfld_simps]
      rw [inter_prod, prod_univ, prod_univ]
      rfl
  change
    ContDiffOn ùïú m
      (fun p : E √ó E =>
        ((I' (f (I.symm p.fst)), (mfderivWithin I I' f s (I.symm p.fst) : E ‚Üí E') p.snd) : E' √ó E'))
      ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ univ)
  have hf' := contMDiffOn_iff.1 hf
  have A : ContDiffOn ùïú m (I' ‚àò f ‚àò I.symm) (range I ‚à© I.symm ‚Åª¬π' s) := by
    simpa only [mfld_simps] using (hf'.2 (I.symm 0) (I'.symm 0)).of_le m_le_n
  have B : ContDiffOn ùïú m
      ((I' ‚àò f ‚àò I.symm) ‚àò Prod.fst) ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ (univ : Set E)) :=
    A.comp contDiff_fst.contDiffOn (prod_subset_preimage_fst _ _)
  suffices C :
    ContDiffOn ùïú m
      (fun p : E √ó E => (fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) p.1 : _) p.2)
      ((range I ‚à© I.symm ‚Åª¬π' s) √óÀ¢ (univ : Set E)) by
    refine ContDiffOn.prod B ?_
    refine C.congr fun p hp => ?_
    simp only [mfld_simps] at hp
    simp only [mfderivWithin, hf.mdifferentiableOn one_le_n _ hp.2, hp.1, if_pos, mfld_simps]
    rfl
  have D :
    ContDiffOn ùïú m (fun x => fderivWithin ùïú (I' ‚àò f ‚àò I.symm) (I.symm ‚Åª¬π' s ‚à© range I) x)
      (range I ‚à© I.symm ‚Åª¬π' s) := by
    have : ContDiffOn ùïú n (I' ‚àò f ‚àò I.symm) (range I ‚à© I.symm ‚Åª¬π' s) := by
      simpa only [mfld_simps] using hf'.2 (I.symm 0) (I'.symm 0)
    simpa only [inter_comm] using this.fderivWithin U' hmn
  refine ContDiffOn.clm_apply ?_ contDiffOn_snd
  exact D.comp contDiff_fst.contDiffOn (prod_subset_preimage_fst _ _)"
Mathlib/Topology/UniformSpace/Basic.lean,nhds_le_uniformity,nhds_le_uniformity,bf64083b2a6e2321a0f138d45e91a0516f7133d2,":= by
  intro V V_in
  rcases comp_symm_mem_uniformity_sets V_in with ‚ü®w, w_in, w_symm, w_sub‚ü©
  have : ball x w √óÀ¢ ball x w ‚àà ùìù (x, x)
  ¬∑ rw [nhds_prod_eq]
    exact prod_mem_prod (ball_mem_nhds x w_in) (ball_mem_nhds x w_in)
  apply mem_of_superset this
  rintro ‚ü®u, v‚ü© ‚ü®u_in, v_in‚ü©
  exact w_sub (mem_comp_of_mem_ball w_symm u_in v_in)","warning:  @compRel does not have a doc string
warning:  uniformity does not have a doc string
error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case intro.intro.intro
Œ± : Type ua
Œ≤ : Type ub
Œ≥ : Type uc
Œ¥ : Type ud
Œπ : Sort u_1
inst‚úù : UniformSpace Œ±
x : Œ±
V : Set (Œ± √ó Œ±)
V_in : V ‚àà ùì§ Œ±
w : Set (Œ± √ó Œ±)
w_in : w ‚àà ùì§ Œ±
w_symm : SymmetricRel w
w_sub : w ‚óã w ‚äÜ V
this : ball x w √óÀ¢ ball x w ‚àà ùìù (x, x)
‚ä¢ V ‚àà ùìù (x, x)","theorem nhds_le_uniformity (x : Œ±) : ùìù (x, x) ‚â§ ùì§ Œ± ",":= by
  intro V V_in
  rcases comp_symm_mem_uniformity_sets V_in with ‚ü®w, w_in, w_symm, w_sub‚ü©
  have : ball x w √óÀ¢ ball x w ‚àà ùìù (x, x) := by
    rw [nhds_prod_eq]
    exact prod_mem_prod (ball_mem_nhds x w_in) (ball_mem_nhds x w_in)
  apply mem_of_superset this
  rintro ‚ü®u, v‚ü© ‚ü®u_in, v_in‚ü©
  exact w_sub (mem_comp_of_mem_ball w_symm u_in v_in)"
Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean,PrimeSpectrum.vanishingIdeal_irreducibleComponents,vanishingIdeal_irreducibleComponents,1833c6e43f5f2d80bf844f5bdf73c2f504fbdf8f,":= by
  rw [irreducibleComponents_eq_maximals_closed]
  simp_rw [IsIrreducibleClosed, and_comm]
  rw [minimalPrimes_eq_minimals, ‚Üê minimals_swap,
    ‚Üê PrimeSpectrum.vanishingIdeal_isClosed_isIrreducible, image_minimals_of_rel_iff_rel]
  exact fun s t hs _ ‚Ü¶ vanishingIdeal_anti_mono_iff hs.1","error:  unknown identifier 'IsIrreducibleClosed'
error:  simp made no progress","lemma vanishingIdeal_irreducibleComponents :
    vanishingIdeal '' (irreducibleComponents <| PrimeSpectrum R) =
    minimalPrimes R ",":= by
  rw [irreducibleComponents_eq_maximals_closed, minimalPrimes_eq_minimals, ‚Üê minimals_swap,
    ‚Üê PrimeSpectrum.vanishingIdeal_isClosed_isIrreducible, image_minimals_of_rel_iff_rel]
  exact fun s t hs _ ‚Ü¶ vanishingIdeal_anti_mono_iff hs.1"
Mathlib/Data/Multiset/Sections.lean,Multiset.mem_sections,mem_sections,ddffab96a653674eaf6ec54e6415f6fa7c2a49f7,":= by
  induction s with
  | empty => simp
  | cons ih => simp [ih, rel_cons_left, eq_comm]","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Œ± : Type u_1
s : Multiset (Multiset Œ±)
‚ä¢ ‚àÄ {a : Multiset Œ±}, a ‚àà s.Sections ‚Üî Rel (fun s a ‚Ü¶ a ‚àà s) s a","theorem mem_sections {s : Multiset (Multiset Œ±)} :
    ‚àÄ {a}, a ‚àà Sections s ‚Üî s.Rel (fun s a => a ‚àà s) a ",":= by
  induction s using Multiset.induction_on with
  | empty => simp
  | cons _ _ ih => simp [ih, rel_cons_left, eq_comm]"
Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean,IsIntegralClosure.isDedekindDomain,IsIntegralClosure.isDedekindDomain,db4b2acc70490f6bcea6872fdf1d716949f8c1e7,":=
  have : IsFractionRing C L := IsIntegralClosure.isFractionRing_of_finite_extension A K L C
  have : IsIntegrallyClosed A K := IsDedekindDomain.isIntegrallyClosed A K
  { IsIntegralClosure.isNoetherianRing A K L C,
    Ring.DimensionLEOne.isIntegralClosure A L C,
    (isIntegrallyClosed_fractionRing_iff _ L).mpr fun {x} hx =>
      ‚ü®IsIntegralClosure.mk' C x (isIntegral_trans (IsIntegralClosure.isIntegral_algebra A L) _ hx),
        IsIntegralClosure.algebraMap_mk' _ _ _‚ü© with : IsDedekindDomain C }","error:  function expected at
  IsIntegrallyClosed A
term has type
  Prop
error:  unknown constant 'IsDedekindDomain.isIntegrallyClosed'
error:  unknown identifier 'isIntegrallyClosed_fractionRing_iff'
error:  expected structure
error:  invalid occurrence of universe level 'u_6' at 'integralClosure.isDedekindDomain', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  IsIntegralClosure.isDedekindDomain.{u_2, u_3, u_4, u_4, u_6} A K L ‚Ü•(integralClosure.{u_2, u_4} A L)
at declaration body
  fun (A : Type u_2) (K : Type u_3) [CommRing A] [Field K] [IsDomain A] [Algebra A K] [IsFractionRing A K]
      (L : Type u_4) [Field L] [Algebra K L] [Algebra A L] [IsScalarTower A K L] [FiniteDimensional K L]
      [IsSeparable K L] [IsDedekindDomain A] ‚Ü¶
    IsIntegralClosure.isDedekindDomain A K L ‚Ü•(integralClosure A L)
error:  unknown constant 'integralClosure.isDedekindDomain'",theorem IsIntegralClosure.isDedekindDomain [IsDedekindDomain A] : IsDedekindDomain C ,":=
  have : IsFractionRing C L := IsIntegralClosure.isFractionRing_of_finite_extension A K L C
  have : Algebra.IsIntegral A C := IsIntegralClosure.isIntegral_algebra A L
  { IsIntegralClosure.isNoetherianRing A K L C,
    Ring.DimensionLEOne.isIntegralClosure A L C,
    (isIntegrallyClosed_iff L).mpr fun {x} hx =>
      ‚ü®IsIntegralClosure.mk' C x (isIntegral_trans (R := A) _ hx),
        IsIntegralClosure.algebraMap_mk' _ _ _‚ü© with : IsDedekindDomain C }"
Mathlib/Logic/Lemmas.lean,Prop.forall,Prop.forall,b72bb8581e966b6491cee1c5638e18fae2fc11b2,:=,error:  unexpected token 'lemma'; expected term,"lemma Prop.forall {f : Prop ‚Üí Prop} : (‚àÄ p, f p) ‚Üî f True ‚àß f False ",":=
  ‚ü®fun h ‚Ü¶ ‚ü®h _, h _‚ü©, by rintro ‚ü®h‚ÇÅ, h‚ÇÄ‚ü© p; by_cases hp : p <;> simp only [hp] <;> assumption‚ü©"
Mathlib/Combinatorics/Hall/Finite.lean,HallMarriageTheorem.hall_hard_inductive_step_B,hall_hard_inductive_step_B,1fad85974a73e087cf79e277c849def2b34e2100,":= by
  haveI := Classical.decEq Œπ
  rw [Nat.add_one] at hn
  have card_Œπ'_le : Fintype.card s ‚â§ n := by
    apply Nat.le_of_lt_succ
    calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card Œπ := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
  let t' : s ‚Üí Finset Œ± := fun x' => t x'
  rcases ih t' card_Œπ'_le (hall_cond_of_restrict ht) with ‚ü®f', hf', hsf'‚ü©
  set Œπ'' := (s : Set Œπ)·∂ú
  let t'' : Œπ'' ‚Üí Finset Œ± := fun a'' => t a'' \ s.biUnion t
  have card_Œπ''_le : Fintype.card Œπ'' ‚â§ n := by
    simp_rw [Œπ'', ‚Üê Nat.lt_succ_iff, ‚Üê hn, ‚Üê Finset.coe_compl, coe_sort_coe]
    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]
  rcases ih t'' card_Œπ''_le (hall_cond_of_compl hus ht) with ‚ü®f'', hf'', hsf''‚ü©
  have f'_mem_biUnion : ‚àÄ (x') (hx' : x' ‚àà s), f' ‚ü®x', hx'‚ü© ‚àà s.biUnion t := by
    intro x' hx'
    rw [mem_biUnion]
    exact ‚ü®x', hx', hsf' _‚ü©
  have f''_not_mem_biUnion : ‚àÄ (x'') (hx'' : ¬¨x'' ‚àà s), ¬¨f'' ‚ü®x'', hx''‚ü© ‚àà s.biUnion t := by
    intro x'' hx''
    have h := hsf'' ‚ü®x'', hx''‚ü©
    rw [mem_sdiff] at h
    exact h.2
  have im_disj :
      ‚àÄ (x' x'' : Œπ) (hx' : x' ‚àà s) (hx'' : ¬¨x'' ‚àà s), f' ‚ü®x', hx'‚ü© ‚â† f'' ‚ü®x'', hx''‚ü© := by
    intro x x' hx' hx'' h
    apply f''_not_mem_biUnion x' hx''
    rw [‚Üê h]
    apply f'_mem_biUnion x
  refine' ‚ü®fun x => if h : x ‚àà s then f' ‚ü®x, h‚ü© else f'' ‚ü®x, h‚ü©, _, _‚ü©
  ¬∑ exact hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)
  ¬∑ intro x
    simp only [of_eq_true]
    split_ifs with h
    ¬∑ exact hsf' ‚ü®x, h‚ü©
    ¬∑ exact sdiff_subset _ _ (hsf'' ‚ü®x, h‚ü©)","error:  function expected at
  sdiff_subset ?m.41056
term has type
  ?m.41055 ‚àà ?m.41053","theorem hall_hard_inductive_step_B {n : ‚Ñï} (hn : Fintype.card Œπ = n + 1)
    (ht : ‚àÄ s : Finset Œπ, s.card ‚â§ (s.biUnion t).card)
    (ih :
      ‚àÄ {Œπ' : Type u} [Fintype Œπ'] (t' : Œπ' ‚Üí Finset Œ±),
        Fintype.card Œπ' ‚â§ n ‚Üí
          (‚àÄ s' : Finset Œπ', s'.card ‚â§ (s'.biUnion t').card) ‚Üí
            ‚àÉ f : Œπ' ‚Üí Œ±, Function.Injective f ‚àß ‚àÄ x, f x ‚àà t' x)
    (s : Finset Œπ) (hs : s.Nonempty) (hns : s ‚â† univ) (hus : s.card = (s.biUnion t).card) :
    ‚àÉ f : Œπ ‚Üí Œ±, Function.Injective f ‚àß ‚àÄ x, f x ‚àà t x ",":= by
  haveI := Classical.decEq Œπ
  rw [Nat.add_one] at hn
  have card_Œπ'_le : Fintype.card s ‚â§ n := by
    apply Nat.le_of_lt_succ
    calc
      Fintype.card s = s.card := Fintype.card_coe _
      _ < Fintype.card Œπ := (card_lt_iff_ne_univ _).mpr hns
      _ = n.succ := hn
  let t' : s ‚Üí Finset Œ± := fun x' => t x'
  rcases ih t' card_Œπ'_le (hall_cond_of_restrict ht) with ‚ü®f', hf', hsf'‚ü©
  set Œπ'' := (s : Set Œπ)·∂ú
  let t'' : Œπ'' ‚Üí Finset Œ± := fun a'' => t a'' \ s.biUnion t
  have card_Œπ''_le : Fintype.card Œπ'' ‚â§ n := by
    simp_rw [Œπ'', ‚Üê Nat.lt_succ_iff, ‚Üê hn, ‚Üê Finset.coe_compl, coe_sort_coe]
    rwa [Fintype.card_coe, card_compl_lt_iff_nonempty]
  rcases ih t'' card_Œπ''_le (hall_cond_of_compl hus ht) with ‚ü®f'', hf'', hsf''‚ü©
  have f'_mem_biUnion : ‚àÄ (x') (hx' : x' ‚àà s), f' ‚ü®x', hx'‚ü© ‚àà s.biUnion t := by
    intro x' hx'
    rw [mem_biUnion]
    exact ‚ü®x', hx', hsf' _‚ü©
  have f''_not_mem_biUnion : ‚àÄ (x'') (hx'' : ¬¨x'' ‚àà s), ¬¨f'' ‚ü®x'', hx''‚ü© ‚àà s.biUnion t := by
    intro x'' hx''
    have h := hsf'' ‚ü®x'', hx''‚ü©
    rw [mem_sdiff] at h
    exact h.2
  have im_disj :
      ‚àÄ (x' x'' : Œπ) (hx' : x' ‚àà s) (hx'' : ¬¨x'' ‚àà s), f' ‚ü®x', hx'‚ü© ‚â† f'' ‚ü®x'', hx''‚ü© := by
    intro x x' hx' hx'' h
    apply f''_not_mem_biUnion x' hx''
    rw [‚Üê h]
    apply f'_mem_biUnion x
  refine ‚ü®fun x => if h : x ‚àà s then f' ‚ü®x, h‚ü© else f'' ‚ü®x, h‚ü©, ?_, ?_‚ü©
  ¬∑ refine hf'.dite _ hf'' (@fun x x' => im_disj x x' _ _)
  ¬∑ intro x
    simp only [of_eq_true]
    split_ifs with h
    ¬∑ exact hsf' ‚ü®x, h‚ü©
    ¬∑ exact sdiff_subset (hsf'' ‚ü®x, h‚ü©)"
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow,discr_prime_pow,961db629df93e5dbd02440deee4c37efcf2faa85,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  2 * ?m.33273 / 2
case e_a.inl.intro
K : Type u
L : Type v
Œ∂ : L
inst‚úù¬≥ : Field K
inst‚úù¬≤ : Field L
inst‚úù¬π : Algebra K L
mf : Module.Finite K L
se : IsSeparable K L
coe_two : ‚Üë2 = 2
hp : Fact (Nat.Prime ‚Üë2)
k : ‚Ñï
inst‚úù : IsCyclotomicExtension {2 ^ (k.succ + 1)} K L
hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(2 ^ (k.succ + 1))
hirr : Irreducible (cyclotomic (‚Üë(2 ^ (k.succ + 1))) K)
hk : 2 ^ (k.succ + 1) ‚â† 2
hne : NeZero ‚Üë‚Üë(2 ^ (k.succ + 1))
hp2 : 2 = 2 ‚Üí k.succ ‚â† 0
‚ä¢ (-1) ^ (2 ^ k * (2 * (2 ^ k * 2 - 1)) / 2) = (-1) ^ (2 ^ k * 2 / 2)
warning:  `Polynomial.C_eq_nat_cast` has been deprecated, use `Polynomial.C_eq_natCast` instead
warning:  `Polynomial.C_eq_nat_cast` has been deprecated, use `Polynomial.C_eq_natCast` instead
warning:  `Polynomial.aeval_nat_cast` has been deprecated, use `Polynomial.aeval_natCast` instead
warning:  `IsPrimitiveRoot.pow_sub_one_norm_prime_pow_of_ne_zero` has been deprecated, use `IsPrimitiveRoot.norm_pow_sub_one_eq_prime_pow_of_ne_zero` instead
warning:  `IsPrimitiveRoot.pow_sub_one_norm_prime_ne_two` has been deprecated, use `IsPrimitiveRoot.norm_pow_sub_one_of_prime_ne_two` instead","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ‚Ñï).Prime]
    (hŒ∂ : IsPrimitiveRoot Œ∂ ‚Üë(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (‚Üë(p ^ (k + 1)) : ‚Ñï) K))
    (hk : p ^ (k + 1) ‚â† 2) : discr K (hŒ∂.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : ‚Ñï).totient / 2) * p ^ ((p : ‚Ñï) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hŒ∂.powerBasis_gen _, ‚Üê
    hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : ‚Ñï+) : ‚Ñï) = 2 := rfl
  have hp2 : p = 2 ‚Üí k ‚â† 0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  ¬∑ rcases eq_or_ne p 2 with (rfl | hp2)
    ¬∑ rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ‚ü®k, rfl‚ü©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      ¬∑ simp
      ¬∑ simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    ¬∑ replace hp2 : (p : ‚Ñï) ‚â† 2 := by rwa [Ne, ‚Üê coe_two, PNat.coe_inj]
      have hpo : Odd (p : ‚Ñï) := hp.out.odd_of_ne_two hp2
      obtain ‚ü®a, ha‚ü© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, ‚Üê ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  ¬∑ have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ‚Üê PNat.pow_coe,
      hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Œ∂ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Œ∂ ^ (p : ‚Ñï) ^ k - 1) = (p : K) ^ (p : ‚Ñï) ^ k := by
      by_cases hp : p = 2
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      ¬∑ exact mod_cast hŒ∂.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ‚Üê map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, ‚Üê succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [‚Üê hŒ∂.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hŒ∂.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, ‚Üê pow_mul, ‚Üê mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [‚Üê succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ‚Ñï) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    ¬∑ simp only [H, mul_comm _ (k + 1)]; norm_cast
    ¬∑ 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this"
Mathlib/RingTheory/Ideal/IsPrincipal.lean,Ideal.associatesEquivIsPrincipal_map_zero,associatesEquivIsPrincipal_map_zero,94f8f604abb9aebc9ff83f8d1c77d38a2ab15f5d,":= by
  rw [‚Üê mk_zero, associatesEquivIsPrincipal_apply, Submodule.zero_eq_bot, span_singleton_eq_bot]","error:  unknown identifier 'mk_zero'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.14908
R : Type u_1
inst‚úù¬π : CommRing R
inst‚úù : IsDomain R
‚ä¢ ‚Üë((associatesEquivIsPrincipal R) 0) = 0","theorem associatesEquivIsPrincipal_map_zero :
    (associatesEquivIsPrincipal R 0 : Ideal R) = 0 ",":= by
  rw [‚Üê Associates.mk_zero, ‚Üê Associates.quotient_mk_eq_mk, associatesEquivIsPrincipal_apply,
    Set.singleton_zero, span_zero, zero_eq_bot]"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.ne_iff,ne_iff,fd88ffb8632619a5f956d8e317da257875d2c74c,:= FunLike.ne_iff,"warning:  Finsupp does not have a doc string
error:  type mismatch
  Function.ne_iff
has type
  ?m.3602 ‚â† ?m.3603 ‚Üî ‚àÉ a, ?m.3602 a ‚â† ?m.3603 a : Prop
but is expected to have type
  f ‚â† g ‚Üî ‚àÉ a, f a ‚â† g a : Prop","lemma ne_iff {f g : Œ± ‚Üí‚ÇÄ M} : f ‚â† g ‚Üî ‚àÉ a, f a ‚â† g a ",:= DFunLike.ne_iff
Mathlib/GroupTheory/MonoidLocalization.lean,Localization.mk_mul,mk_mul,f7d2420463796edab0b4f526fd8c96d19b328dd9,":=
  mul_comm b d ‚ñ∏ OreLocalization.oreDiv_mul_oreDiv","error:  type mismatch
  OreLocalization.oreDiv_mul_oreDiv
has type
  ?m.57558 /‚Çí ?m.57560 * (?m.57559 /‚Çí ?m.57561) =
    OreLocalization.oreNum ?m.57558 ?m.57561 * ?m.57559 /‚Çí
      (OreLocalization.oreDenom ?m.57558 ?m.57561 * ?m.57560) : Prop
but is expected to have type
  mk a b * mk c d = mk (a * c) (d * b) : Prop",theorem mk_mul (a c : M) (b d : S) : mk a b * mk c d = mk (a * c) (b * d) ,":=
  show Localization.mul S _ _ = _ by rw [Localization.mul]; rfl"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.OuterMeasure.isometry_comap_mkMetric,isometry_comap_mkMetric,ced4d3c0af763b9fd00166e49cf999cf46c891cc,":= by
  simp only [mkMetric, mkMetric', mkMetric'.pre, inducedOuterMeasure, comap_iSup]
  refine surjective_id.iSup_congr id fun Œµ => surjective_id.iSup_congr id fun hŒµ => _
  rw [comap_boundedBy _ (H.imp _ id)]
  ¬∑ congr with s : 1
    apply extend_congr
    ¬∑ simp [hf.ediam_image]
    ¬∑ intros; simp [hf.injective.subsingleton_image_iff, hf.ediam_image]
  ¬∑ intro h_mono s t hst
    simp only [extend, le_iInf_iff]
    intro ht
    apply le_trans _ (h_mono (diam_mono hst))
    simp only [(diam_mono hst).trans ht, le_refl, ciInf_pos]","error:  don't know how to synthesize placeholder
context:
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬π : EMetricSpace X
inst‚úù : EMetricSpace Y
m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû
f : X ‚Üí Y
hf : Isometry f
H : Monotone m ‚à® Surjective f
Œµ : ‚Ñù‚â•0‚àû
hŒµ : id Œµ > 0
‚ä¢ (comap f) (boundedBy (extend fun s x ‚Ü¶ m (diam s))) = boundedBy (extend fun s x ‚Ü¶ m (diam s))
error:  unsolved goals
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬π : EMetricSpace X
inst‚úù : EMetricSpace Y
m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû
f : X ‚Üí Y
hf : Isometry f
H : Monotone m ‚à® Surjective f
‚ä¢ ‚®Ü i, ‚®Ü (_ : i > 0), (comap f) (boundedBy (extend fun s x ‚Ü¶ m (diam s))) =
    ‚®Ü r, ‚®Ü (_ : r > 0), boundedBy (extend fun s x ‚Ü¶ m (diam s))","theorem isometry_comap_mkMetric (m : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù‚â•0‚àû) {f : X ‚Üí Y} (hf : Isometry f)
    (H : Monotone m ‚à® Surjective f) : comap f (mkMetric m) = mkMetric m ",":= by
  simp only [mkMetric, mkMetric', mkMetric'.pre, inducedOuterMeasure, comap_iSup]
  refine surjective_id.iSup_congr id fun Œµ => surjective_id.iSup_congr id fun hŒµ => ?_
  rw [comap_boundedBy _ (H.imp _ id)]
  ¬∑ congr with s : 1
    apply extend_congr
    ¬∑ simp [hf.ediam_image]
    ¬∑ intros; simp [hf.injective.subsingleton_image_iff, hf.ediam_image]
  ¬∑ intro h_mono s t hst
    simp only [extend, le_iInf_iff]
    intro ht
    apply le_trans _ (h_mono (diam_mono hst))
    simp only [(diam_mono hst).trans ht, le_refl, ciInf_pos]"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,5f92bfec6d6c4ec4639d991dbedc7d9dbbbd4162,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120516 ‚Üí ?m.120516
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.124403 ‚Üí ?m.124403
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà id ‚àÖ, closedBall p.1 p.2) ‚â§ Œº s","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/GroupTheory/GroupAction/FixedPoints.lean,MulAction.fixedBy_subset_fixedBy_zpow,fixedBy_subset_fixedBy_zpow,8d91963661238c0ab55205dc13d946367b9219bd,":= by
  intro a a_in_fixedBy
  rw [mem_fixedBy, zpow_smul_eq_iff_period_dvd,
    period_eq_one_iff_fixedBy.mpr a_in_fixedBy, Nat.cast_one]
  exact one_dvd j","error:  unknown identifier 'period_eq_one_iff_fixedBy.mpr'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.8096
Œ± : Type u_1
G : Type u_2
inst‚úù¬≥ : Group G
inst‚úù¬≤ : MulAction G Œ±
M : Type u_3
inst‚úù¬π : Monoid M
inst‚úù : MulAction M Œ±
g : G
j : ‚Ñ§
a : Œ±
a_in_fixedBy : a ‚àà fixedBy Œ± g
‚ä¢ ‚Üë(period g a) ‚à£ j","theorem fixedBy_subset_fixedBy_zpow (g : G) (j : ‚Ñ§) :
    fixedBy Œ± g ‚äÜ fixedBy Œ± (g ^ j) ",":= by
  intro a a_in_fixedBy
  rw [mem_fixedBy, zpow_smul_eq_iff_minimalPeriod_dvd,
    minimalPeriod_eq_one_iff_fixedBy.mpr a_in_fixedBy, Nat.cast_one]
  exact one_dvd j"
Mathlib/Topology/Separation.lean,minimal_nonempty_open_subsingleton,minimal_nonempty_open_subsingleton,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  clear Y 
  refine' fun x hx y hy => of_not_not fun hxy => _
  rcases exists_isOpen_xor'_mem hxy with ‚ü®U, hUo, hU‚ü©
  wlog h : x ‚àà U ‚àß y ‚àâ U
  ¬∑ exact this hs hmin y hy x hx (Ne.symm hxy) U hUo hU.symm (hU.resolve_left h)
  cases' h with hxU hyU
  have : s ‚à© U = s := hmin (s ‚à© U) (inter_subset_left _ _) ‚ü®x, hx, hxU‚ü© (hs.inter hUo)
  exact hyU (this.symm.subset hy).2","error:  function expected at
  inter_subset_left ?m.38981
term has type
  ?m.38980 ‚àà ?m.38978","theorem minimal_nonempty_open_subsingleton [T0Space X] {s : Set X} (hs : IsOpen s)
    (hmin : ‚àÄ t, t ‚äÜ s ‚Üí t.Nonempty ‚Üí IsOpen t ‚Üí t = s) : s.Subsingleton ",":= by
  clear Y 
  refine fun x hx y hy => of_not_not fun hxy => ?_
  rcases exists_isOpen_xor'_mem hxy with ‚ü®U, hUo, hU‚ü©
  wlog h : x ‚àà U ‚àß y ‚àâ U
  ¬∑ exact this hs hmin y hy x hx (Ne.symm hxy) U hUo hU.symm (hU.resolve_left h)
  cases' h with hxU hyU
  have : s ‚à© U = s := hmin (s ‚à© U) inter_subset_left ‚ü®x, hx, hxU‚ü© (hs.inter hUo)
  exact hyU (this.symm.subset hy).2"
Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean,Path.Homotopy.continuous_transAssocReparamAux,continuous_transAssocReparamAux,4da4e0ebfbf51ecc2e064d04970434177efdead3,":= by
  refine continuous_if_le ?_ ?_ (Continuous.continuousOn? _)
    (continuous_if_le ?_ ?_
      (Continuous.continuousOn ?_) (Continuous.continuousOn ?_) ?_).continuousOn
      ?_ <;>
    [continuity; continuity; continuity; continuity; continuity; continuity; continuity; skip;
      skip] <;>
    ¬∑ intro x hx
      set_option tactic.skipAssignedInstances false in norm_num [hx]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Continuous
has type
  (?m.228799 ‚Üí ?m.228800) ‚Üí Prop
error:  too many tactics
warning:  fundamentalGroupoidFunctor does not have a doc string",theorem continuous_transAssocReparamAux : Continuous transAssocReparamAux ,":= by
  refine continuous_if_le ?_ ?_ (Continuous.continuousOn ?_)
    (continuous_if_le ?_ ?_
      (Continuous.continuousOn ?_) (Continuous.continuousOn ?_) ?_).continuousOn
      ?_ <;>
    [continuity; continuity; continuity; continuity; continuity; continuity; continuity; skip;
      skip] <;>
    ¬∑ intro x hx
      norm_num [hx]"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.not_mem_nil,not_mem_nil,938069ac7c83a4980c46ca108d9947ab788c12ee,":=
  Seq'.not_mem_nil (some a)",error:  unknown identifier 'Seq'.not_mem_nil',theorem not_mem_nil (a : Œ±) : a ‚àâ @nil Œ± ,":=
  Seq.not_mem_nil (some a)"
Mathlib/Data/List/Cycle.lean,List.prev_next,prev_next,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  obtain ‚ü®n, hn, rfl‚ü© := nthLe_of_mem hx
  simp only [next_nthLe, prev_nthLe, h, Nat.mod_add_mod]
  cases' l with hd tl
  ¬∑ simp at hx
  ¬∑ have : (n + 1 + length tl) % (length tl + 1) = n := by
      rw [length_cons, Nat.succ_eq_add_one] at hn
      rw [add_assoc, add_comm 1, Nat.add_mod_right, Nat.mod_eq_of_lt hn]
    simp only [length_cons, Nat.succ_sub_succ_eq_sub, tsub_zero, Nat.succ_eq_add_one, this]","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
Œ± : Type u_1
inst‚úù : DecidableEq Œ±
l : List Œ±
x : Œ±
n : ‚Ñï
hd : Œ±
tl : List Œ±
h : (hd :: tl).Nodup
hn‚úù : n < (hd :: tl).length
hn : n < tl.length + 1
hx : (hd :: tl).nthLe n hn‚úù ‚àà hd :: tl
‚ä¢ (n + 1 + tl.length) % (tl.length + 1) = n
error:  unsolved goals
case intro.intro.cons
Œ± : Type u_1
inst‚úù : DecidableEq Œ±
l : List Œ±
x : Œ±
n : ‚Ñï
hd : Œ±
tl : List Œ±
h : (hd :: tl).Nodup
hn : n < (hd :: tl).length
hx : (hd :: tl).nthLe n hn ‚àà hd :: tl
this : (n + 1 + tl.length) % (tl.length + 1) = n
‚ä¢ (hd :: tl).nthLe ((n + 1 + (tl.length - 0)) % (tl.length + 1)) ‚ãØ = (hd :: tl).nthLe n hn
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead","theorem prev_next (l : List Œ±) (h : Nodup l) (x : Œ±) (hx : x ‚àà l) :
    prev l (next l x hx) (next_mem _ _ _) = x ",":= by
  obtain ‚ü®n, hn, rfl‚ü© := nthLe_of_mem hx
  simp only [next_nthLe, prev_nthLe, h, Nat.mod_add_mod]
  cases' l with hd tl
  ¬∑ simp at hx
  ¬∑ have : (n + 1 + length tl) % (length tl + 1) = n := by
      rw [length_cons] at hn
      rw [add_assoc, add_comm 1, Nat.add_mod_right, Nat.mod_eq_of_lt hn]
    simp only [length_cons, Nat.succ_sub_succ_eq_sub, Nat.sub_zero, Nat.succ_eq_add_one, this]"
Mathlib/MeasureTheory/Constructions/Prod/Basic.lean,measurable_measure_prod_mk_left,measurable_measure_prod_mk_left,bf51f258386f8087f1e18f6afd6b10d7fcd704ae,":= by
  refine' induction_on_inter (C := fun s => Measurable fun x => ŒΩ (Prod.mk x ‚Åª¬π' s))
    generateFrom_prod.symm isPiSystem_prod _ _ _ _ hs
  ¬∑ simp [measurable_zero, const_def]
  ¬∑ rintro _ ‚ü®s, t, hs, _, rfl‚ü©
    simp only [mk_preimage_prod_right_eq_if, measure_if]
    exact measurable_const.indicator hs
  ¬∑ intro t ht h2t
    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top ŒΩ _)]
    exact h2t.const_sub _
  ¬∑ intro f h1f h2f h3f
    simp_rw [preimage_iUnion]
    have : ‚àÄ b, ŒΩ (‚ãÉ i, Prod.mk b ‚Åª¬π' f i) = ‚àë' i, ŒΩ (Prod.mk b ‚Åª¬π' f i) := fun b =>
      measure_iUnion (fun i j hij => Disjoint.preimage _ (h1f hij)) fun i =>
        measurable_prod_mk_left (h2f i)
    simp_rw [this]
    apply Measurable.ennreal_tsum h3f","error:  unsolved goals
case refine'_1
Œ± : Type u_1
Œ±' : Type u_2
Œ≤ : Type u_3
Œ≤' : Type u_4
Œ≥ : Type u_5
E : Type u_6
inst‚úù‚Å∂ : MeasurableSpace Œ±
inst‚úù‚Åµ : MeasurableSpace Œ±'
inst‚úù‚Å¥ : MeasurableSpace Œ≤
inst‚úù¬≥ : MeasurableSpace Œ≤'
inst‚úù¬≤ : MeasurableSpace Œ≥
Œº Œº' : Measure Œ±
ŒΩ ŒΩ' : Measure Œ≤
œÑ : Measure Œ≥
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : IsFiniteMeasure ŒΩ
s : Set (Œ± √ó Œ≤)
hs : MeasurableSet s
‚ä¢ Measurable (const Œ± (ŒΩ ‚àÖ))
error:  application type mismatch
  Measurable.indicator measurable_const hs
argument
  hs
has type
  Set Œ≤ : Type u_3
but is expected to have type
  MeasurableSet s : Prop","theorem measurable_measure_prod_mk_left_finite [IsFiniteMeasure ŒΩ] {s : Set (Œ± √ó Œ≤)}
    (hs : MeasurableSet s) : Measurable fun x => ŒΩ (Prod.mk x ‚Åª¬π' s) ",":= by
  refine induction_on_inter (C := fun s => Measurable fun x => ŒΩ (Prod.mk x ‚Åª¬π' s))
    generateFrom_prod.symm isPiSystem_prod ?_ ?_ ?_ ?_ hs
  ¬∑ simp
  ¬∑ rintro _ ‚ü®s, hs, t, _, rfl‚ü©
    simp only [mk_preimage_prod_right_eq_if, measure_if]
    exact measurable_const.indicator hs
  ¬∑ intro t ht h2t
    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top ŒΩ _)]
    exact h2t.const_sub _
  ¬∑ intro f h1f h2f h3f
    simp_rw [preimage_iUnion]
    have : ‚àÄ b, ŒΩ (‚ãÉ i, Prod.mk b ‚Åª¬π' f i) = ‚àë' i, ŒΩ (Prod.mk b ‚Åª¬π' f i) := fun b =>
      measure_iUnion (fun i j hij => Disjoint.preimage _ (h1f hij)) fun i =>
        measurable_prod_mk_left (h2f i)
    simp_rw [this]
    apply Measurable.ennreal_tsum h3f"
Mathlib/MeasureTheory/Constructions/Prod/Basic.lean,measurable_measure_prod_mk_left,measurable_measure_prod_mk_left,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine' induction_on_inter (C := fun s => Measurable fun x => ŒΩ (Prod.mk x ‚Åª¬π' s))
    generateFrom_prod.symm isPiSystem_prod _ _ _ _ hs
  ¬∑ simp [measurable_zero, const_def]
  ¬∑ rintro _ ‚ü®s, hs, t, _, rfl‚ü©
    simp only [mk_preimage_prod_right_eq_if, measure_if]
    exact measurable_const.indicator hs
  ¬∑ intro t ht h2t
    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top ŒΩ _)]
    exact h2t.const_sub _
  ¬∑ intro f h1f h2f h3f
    simp_rw [preimage_iUnion]
    have : ‚àÄ b, ŒΩ (‚ãÉ i, Prod.mk b ‚Åª¬π' f i) = ‚àë' i, ŒΩ (Prod.mk b ‚Åª¬π' f i) := fun b =>
      measure_iUnion (fun i j hij => Disjoint.preimage _ (h1f hij)) fun i =>
        measurable_prod_mk_left (h2f i)
    simp_rw [this]
    apply Measurable.ennreal_tsum h3f","error:  unsolved goals
case refine'_1
Œ± : Type u_1
Œ±' : Type u_2
Œ≤ : Type u_3
Œ≤' : Type u_4
Œ≥ : Type u_5
E : Type u_6
inst‚úù‚Å∂ : MeasurableSpace Œ±
inst‚úù‚Åµ : MeasurableSpace Œ±'
inst‚úù‚Å¥ : MeasurableSpace Œ≤
inst‚úù¬≥ : MeasurableSpace Œ≤'
inst‚úù¬≤ : MeasurableSpace Œ≥
Œº Œº' : Measure Œ±
ŒΩ ŒΩ' : Measure Œ≤
œÑ : Measure Œ≥
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : IsFiniteMeasure ŒΩ
s : Set (Œ± √ó Œ≤)
hs : MeasurableSet s
‚ä¢ Measurable (const Œ± (ŒΩ ‚àÖ))","theorem measurable_measure_prod_mk_left_finite [IsFiniteMeasure ŒΩ] {s : Set (Œ± √ó Œ≤)}
    (hs : MeasurableSet s) : Measurable fun x => ŒΩ (Prod.mk x ‚Åª¬π' s) ",":= by
  refine induction_on_inter (C := fun s => Measurable fun x => ŒΩ (Prod.mk x ‚Åª¬π' s))
    generateFrom_prod.symm isPiSystem_prod ?_ ?_ ?_ ?_ hs
  ¬∑ simp
  ¬∑ rintro _ ‚ü®s, hs, t, _, rfl‚ü©
    simp only [mk_preimage_prod_right_eq_if, measure_if]
    exact measurable_const.indicator hs
  ¬∑ intro t ht h2t
    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top ŒΩ _)]
    exact h2t.const_sub _
  ¬∑ intro f h1f h2f h3f
    simp_rw [preimage_iUnion]
    have : ‚àÄ b, ŒΩ (‚ãÉ i, Prod.mk b ‚Åª¬π' f i) = ‚àë' i, ŒΩ (Prod.mk b ‚Åª¬π' f i) := fun b =>
      measure_iUnion (fun i j hij => Disjoint.preimage _ (h1f hij)) fun i =>
        measurable_prod_mk_left (h2f i)
    simp_rw [this]
    apply Measurable.ennreal_tsum h3f"
Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean,mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt,mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt,9db546a81b334ba30d74fed40766bcdeffb50e5f,":= by
  have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
    hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
  letI := finiteDimensional B
  set P := minpoly R B.gen with hP
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  haveI : NoZeroSMulDivisors R L := NoZeroSMulDivisors.trans R K L
  let _ := P.map (algebraMap R L)
  rw [adjoin_singleton_eq_range_aeval] at hz
  obtain ‚ü®Q‚ÇÅ, hQ‚ü© := hz
  set Q := Q‚ÇÅ %‚Çò P with hQ‚ÇÅ
  replace hQ : aeval B.gen Q = p ‚Ä¢ z
  ¬∑ rw [‚Üê modByMonic_add_div Q‚ÇÅ (minpoly.monic hBint)] at hQ
    simpa using hQ
  by_cases hQzero : Q = 0
  ¬∑ simp only [hQzero, Algebra.smul_def, zero_eq_mul, aeval_zero] at hQ
    cases' hQ with H H‚ÇÅ
    ¬∑ have : Function.Injective (algebraMap R L) := by
        rw [algebraMap_eq R K L]
        exact (algebraMap K L).injective.comp (IsFractionRing.injective R K)
      exfalso
      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)
    ¬∑ rw [H‚ÇÅ]
      exact Subalgebra.zero_mem _
  refine mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => ?_) hQ
  induction' i using Nat.case_strong_induction_on with j hind
  ¬∑ intro _
    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt hp hBint hQ hzint hei
  ¬∑ intro hj
    convert hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd _ hndiv
    exact n
    have H := degree_modByMonic_lt Q‚ÇÅ (minpoly.monic hBint)
    rw [‚Üê hQ‚ÇÅ, ‚Üê hP] at H
    replace H := Nat.lt_iff_add_one_le.1
      (lt_of_lt_of_le
        (lt_of_le_of_lt (Nat.lt_iff_add_one_le.1 (Nat.lt_of_succ_lt_succ (mem_range.1 hj)))
          (lt_succ_self _)) (Nat.lt_iff_add_one_le.1 ((natDegree_lt_natDegree_iff hQzero).2 H)))
    rw [add_assoc] at H
    have Hj : Q.natDegree + 1 = j + 1 + (Q.natDegree - j) := by
      rw [‚Üê add_comm 1, ‚Üê add_comm 1, add_assoc, add_right_inj,
        ‚Üê Nat.add_sub_assoc (Nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm,
        Nat.add_sub_cancel]
    choose! g hg using hind
    replace hg : ‚àÄ k ‚àà range (j + 1), Q.coeff k ‚Ä¢ B.gen ^ k = algebraMap R L p * g k ‚Ä¢ B.gen ^ k
    ¬∑ intro k hk
      rw [hg k (mem_range_succ_iff.1 hk)
        (mem_range_succ_iff.2
          (le_trans (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),
        Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, mul_assoc]
    choose! f hf using
      IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
        (minpoly.monic hBint) hei.isWeaklyEisensteinAt
    have hf‚ÇÅ : ‚àÄ k ‚àà (range (Q.natDegree - j)).erase 0,
        Q.coeff (j + 1 + k) ‚Ä¢ B.gen ^ (j + 1 + k) * B.gen ^ (P.natDegree - (j + 2)) =
        (algebraMap R L) p * Q.coeff (j + 1 + k) ‚Ä¢ f (k + P.natDegree - 1) := by
      intro k hk
      rw [smul_mul_assoc, ‚Üê pow_add, ‚Üê Nat.add_sub_assoc H, ‚Üê add_assoc j 1 1, add_comm (j + 1) 1,
        add_assoc (j + 1), add_comm _ (k + P.natDegree), Nat.add_sub_add_right,
        ‚Üê (hf (k + P.natDegree - 1) _).2, mul_smul_comm]
      rw [(minpoly.monic hBint).natDegree_map, add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact Nat.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    suffices
        p ^ n.succ ‚à£ Q.coeff (succ j) ^ n.succ *
          (minpoly R B.gen).coeff 0 ^ (succ j + (P.natDegree - (j + 2))) by
      convert this
      rw [Nat.succ_eq_add_one, add_assoc, ‚Üê Nat.add_sub_assoc H, ‚Üê add_assoc, add_comm (j + 1),
        Nat.add_sub_add_left, ‚Üê Nat.add_sub_assoc, Nat.add_sub_add_left, hP, ‚Üê
        (minpoly.monic hBint).natDegree_map (algebraMap R K), ‚Üê
        minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, natDegree_minpoly, hn, Nat.sub_one,
        Nat.pred_succ]
      linarith
    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_addLeftEmbedding _ _),
      sum_congr rfl hg, add_comm] at hQ
    replace hQ := congr_arg (fun x => x * B.gen ^ (P.natDegree - (j + 2))) hQ
    simp_rw [sum_map, addLeftEmbedding_apply, add_mul, sum_mul, mul_assoc] at hQ
    rw [‚Üê insert_erase
      (mem_range.2 (tsub_pos_iff_lt.2 <| Nat.lt_of_succ_lt_succ <| mem_range.1 hj)),
      sum_insert (not_mem_erase 0 _), add_zero, sum_congr rfl hf‚ÇÅ, ‚Üê mul_sum, ‚Üê mul_sum, add_assoc,
      ‚Üê mul_add, smul_mul_assoc, ‚Üê pow_add, Algebra.smul_def] at hQ
    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)
    have hintsum : IsIntegral R (z * B.gen ^ (P.natDegree - (j + 2)) -
        (‚àë x : ‚Ñï in (range (Q.natDegree - j)).erase 0,
          Q.coeff (j + 1 + x) ‚Ä¢ f (x + P.natDegree - 1) +
            ‚àë x : ‚Ñï in range (j + 1), g x ‚Ä¢ B.gen ^ x * B.gen ^ (P.natDegree - (j + 2)))) := by
      refine (hzint.mul (hBint.pow _)).sub
        (.add (.sum _ fun k hk => .smul _ ?_)
          (.sum _ fun k _ => .mul (.smul _ (.pow hBint _)) (hBint.pow _)))
      refine adjoin_le_integralClosure hBint (hf _ ?_).1
      rw [(minpoly.monic hBint).natDegree_map (algebraMap R L)]
      rw [add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact _root_.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
    rw [Algebra.smul_def, mul_assoc, ‚Üê mul_sub, _root_.map_mul, algebraMap_apply R K L, map_pow,
      Algebra.norm_algebraMap, _root_.map_mul, algebraMap_apply R K L, Algebra.norm_algebraMap,
      finrank B, ‚Üê hr, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map,
      show (-1 : K) = algebraMap R K (-1) by simp, ‚Üê map_pow, ‚Üê map_pow, ‚Üê _root_.map_mul, ‚Üê
      map_pow, ‚Üê _root_.map_mul, ‚Üê map_pow, ‚Üê _root_.map_mul] at hQ
    have hppdiv : p ^ B.dim ‚à£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _
    rwa [‚Üê IsFractionRing.injective R K hQ, mul_comm, ‚Üê Units.coe_neg_one, mul_pow, ‚Üê
      Units.val_pow_eq_pow_val, ‚Üê Units.val_pow_eq_pow_val, mul_assoc,
      IsUnit.dvd_mul_left _ _ _ ‚ü®_, rfl‚ü©, mul_comm, ‚Üê Nat.succ_eq_add_one, hn] at hppdiv","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case intro.intro
R : Type u
K : Type v
L : Type z
p : R
inst‚úù¬π‚Å∞ : CommRing R
inst‚úù‚Åπ : Field K
inst‚úù‚Å∏ : Field L
inst‚úù‚Å∑ : Algebra K L
inst‚úù‚Å∂ : Algebra R L
inst‚úù‚Åµ : Algebra R K
inst‚úù‚Å¥ : IsScalarTower R K L
inst‚úù¬≥ : IsSeparable K L
inst‚úù¬≤ : IsDomain R
inst‚úù¬π : IsFractionRing R K
inst‚úù : IsIntegrallyClosed R
B : PowerBasis K L
hp : _root_.Prime p
hBint : IsIntegral R B.gen
z : L
hzint : IsIntegral R z
this‚úù : Module.Finite K L := finiteDimensional B
P : R[X] := minpoly R B.gen
hei : P.IsEisensteinAt (Submodule.span R {p})
hndiv : ¬¨p ^ 2 ‚à£ P.coeff 0
hP : P = minpoly R B.gen
n : ‚Ñï
hn : B.dim = n.succ
this : NoZeroSMulDivisors R L
x‚úù : L[X] := Polynomial.map (algebraMap R L) P
Q‚ÇÅ : R[X]
Q : R[X] := Q‚ÇÅ %‚Çò P
hQ‚ÇÅ : Q = Q‚ÇÅ %‚Çò P
hQ : (aeval B.gen) Q = p ‚Ä¢ z
‚ä¢ z ‚àà adjoin R {B.gen}","theorem mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} (hzint : IsIntegral R z)
    (hz : p ‚Ä¢ z ‚àà adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) :
    z ‚àà adjoin R ({B.gen} : Set L) ",":= by
  have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
    hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
  have := B.finite
  set P := minpoly R B.gen with hP
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  haveI : NoZeroSMulDivisors R L := NoZeroSMulDivisors.trans R K L
  let _ := P.map (algebraMap R L)
  rw [adjoin_singleton_eq_range_aeval] at hz
  obtain ‚ü®Q‚ÇÅ, hQ‚ü© := hz
  set Q := Q‚ÇÅ %‚Çò P with hQ‚ÇÅ
  replace hQ : aeval B.gen Q = p ‚Ä¢ z := by
    rw [‚Üê modByMonic_add_div Q‚ÇÅ (minpoly.monic hBint)] at hQ
    simpa using hQ
  by_cases hQzero : Q = 0
  ¬∑ simp only [hQzero, Algebra.smul_def, zero_eq_mul, aeval_zero] at hQ
    cases' hQ with H H‚ÇÅ
    ¬∑ have : Function.Injective (algebraMap R L) := by
        rw [algebraMap_eq R K L]
        exact (algebraMap K L).injective.comp (IsFractionRing.injective R K)
      exfalso
      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)
    ¬∑ rw [H‚ÇÅ]
      exact Subalgebra.zero_mem _
  refine mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => ?_) hQ
  induction' i using Nat.case_strong_induction_on with j hind
  ¬∑ intro _
    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt hp hBint hQ hzint hei
  ¬∑ intro hj
    convert hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd (n := n) _ hndiv
    have H := degree_modByMonic_lt Q‚ÇÅ (minpoly.monic hBint)
    rw [‚Üê hQ‚ÇÅ, ‚Üê hP] at H
    replace H := Nat.lt_iff_add_one_le.1
      (lt_of_lt_of_le
        (lt_of_le_of_lt (Nat.lt_iff_add_one_le.1 (Nat.lt_of_succ_lt_succ (mem_range.1 hj)))
          (lt_succ_self _)) (Nat.lt_iff_add_one_le.1 ((natDegree_lt_natDegree_iff hQzero).2 H)))
    have Hj : Q.natDegree + 1 = j + 1 + (Q.natDegree - j) := by
      rw [‚Üê add_comm 1, ‚Üê add_comm 1, add_assoc, add_right_inj,
        ‚Üê Nat.add_sub_assoc (Nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm,
        Nat.add_sub_cancel]
    choose! g hg using hind
    replace hg : ‚àÄ k ‚àà range (j + 1), Q.coeff k ‚Ä¢ B.gen ^ k =
        algebraMap R L p * g k ‚Ä¢ B.gen ^ k := by
      intro k hk
      rw [hg k (mem_range_succ_iff.1 hk)
        (mem_range_succ_iff.2
          (le_trans (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),
        Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, mul_assoc]
    choose! f hf using
      IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
        (minpoly.monic hBint) hei.isWeaklyEisensteinAt
    have hf‚ÇÅ : ‚àÄ k ‚àà (range (Q.natDegree - j)).erase 0,
        Q.coeff (j + 1 + k) ‚Ä¢ B.gen ^ (j + 1 + k) * B.gen ^ (P.natDegree - (j + 2)) =
        (algebraMap R L) p * Q.coeff (j + 1 + k) ‚Ä¢ f (k + P.natDegree - 1) := by
      intro k hk
      rw [smul_mul_assoc, ‚Üê pow_add, ‚Üê Nat.add_sub_assoc H, add_comm (j + 1) 1,
        add_assoc (j + 1), add_comm _ (k + P.natDegree), Nat.add_sub_add_right,
        ‚Üê (hf (k + P.natDegree - 1) _).2, mul_smul_comm]
      rw [(minpoly.monic hBint).natDegree_map, add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact Nat.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    suffices
        p ^ n.succ ‚à£ Q.coeff (succ j) ^ n.succ *
          (minpoly R B.gen).coeff 0 ^ (succ j + (P.natDegree - (j + 2))) by
      convert this
      rw [Nat.succ_eq_add_one, add_assoc, ‚Üê Nat.add_sub_assoc H, add_comm (j + 1),
        Nat.add_sub_add_left, ‚Üê Nat.add_sub_assoc, Nat.add_sub_add_left, hP, ‚Üê
        (minpoly.monic hBint).natDegree_map (algebraMap R K), ‚Üê
        minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, natDegree_minpoly, hn, Nat.sub_one,
        Nat.pred_succ]
      omega
    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_addLeftEmbedding _ _),
      sum_congr rfl hg, add_comm] at hQ
    replace hQ := congr_arg (fun x => x * B.gen ^ (P.natDegree - (j + 2))) hQ
    simp_rw [sum_map, addLeftEmbedding_apply, add_mul, sum_mul, mul_assoc] at hQ
    rw [‚Üê insert_erase
      (mem_range.2 (tsub_pos_iff_lt.2 <| Nat.lt_of_succ_lt_succ <| mem_range.1 hj)),
      sum_insert (not_mem_erase 0 _), add_zero, sum_congr rfl hf‚ÇÅ, ‚Üê mul_sum, ‚Üê mul_sum, add_assoc,
      ‚Üê mul_add, smul_mul_assoc, ‚Üê pow_add, Algebra.smul_def] at hQ
    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)
    have hintsum : IsIntegral R (z * B.gen ^ (P.natDegree - (j + 2)) -
        (‚àë x ‚àà (range (Q.natDegree - j)).erase 0,
          Q.coeff (j + 1 + x) ‚Ä¢ f (x + P.natDegree - 1) +
            ‚àë x ‚àà range (j + 1), g x ‚Ä¢ B.gen ^ x * B.gen ^ (P.natDegree - (j + 2)))) := by
      refine (hzint.mul (hBint.pow _)).sub
        (.add (.sum _ fun k hk => .smul _ ?_)
          (.sum _ fun k _ => .mul (.smul _ (.pow hBint _)) (hBint.pow _)))
      refine adjoin_le_integralClosure hBint (hf _ ?_).1
      rw [(minpoly.monic hBint).natDegree_map (algebraMap R L)]
      rw [add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact _root_.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
    rw [Algebra.smul_def, mul_assoc, ‚Üê mul_sub, _root_.map_mul, algebraMap_apply R K L, map_pow,
      Algebra.norm_algebraMap, _root_.map_mul, algebraMap_apply R K L, Algebra.norm_algebraMap,
      finrank B, ‚Üê hr, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map,
      show (-1 : K) = algebraMap R K (-1) by simp, ‚Üê map_pow, ‚Üê map_pow, ‚Üê _root_.map_mul, ‚Üê
      map_pow, ‚Üê _root_.map_mul, ‚Üê map_pow, ‚Üê _root_.map_mul] at hQ
    have hppdiv : p ^ B.dim ‚à£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _
    rwa [‚Üê IsFractionRing.injective R K hQ, mul_comm, ‚Üê Units.coe_neg_one, mul_pow, ‚Üê
      Units.val_pow_eq_pow_val, ‚Üê Units.val_pow_eq_pow_val, mul_assoc,
      Units.dvd_mul_left, mul_comm, ‚Üê Nat.succ_eq_add_one, hn] at hppdiv"
Mathlib/LinearAlgebra/LinearIndependent.lean,linearIndependent_iUnion_finite,linearIndependent_iUnion_finite,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
  rw [iUnion_eq_iUnion_finset f]
  apply linearIndependent_iUnion_of_directed
  ¬∑ apply directed_of_isDirected_le
    exact fun t‚ÇÅ t‚ÇÇ ht => iUnion_mono fun i => iUnion_subset_iUnion_const fun h => ht h
  intro t
  induction' t with i s his ih
  ¬∑ refine (linearIndependent_empty R M).mono ?_
    simp
  ¬∑ rw [Finset.set_biUnion_insert]
    refine (hl _).union ih ?_
    rw [span_iUnion‚ÇÇ]
    exact hd i s s.finite_toSet his","error:  unsolved goals
case h.mk
Œπ‚úù : Type u'
Œπ' : Type u_1
R : Type u_2
K : Type u_3
M : Type u_4
M' : Type u_5
M'' : Type u_6
V : Type u
V' : Type u_7
v : Œπ‚úù ‚Üí M
inst‚úù‚Å∂ : Ring R
inst‚úù‚Åµ : AddCommGroup M
inst‚úù‚Å¥ : AddCommGroup M'
inst‚úù¬≥ : AddCommGroup M''
inst‚úù¬≤ : Module R M
inst‚úù¬π : Module R M'
inst‚úù : Module R M''
a b : R
x y : M
Œπ : Type u_8
f : Œπ ‚Üí Set M
hl : ‚àÄ (i : Œπ), LinearIndependent R fun (x : ‚Üë(f i)) ‚Ü¶ ‚Üëx
hd : ‚àÄ (i : Œπ) (t : Set Œπ), t.Finite ‚Üí i ‚àâ t ‚Üí Disjoint (span R (f i)) (‚®Ü i ‚àà t, span R (f i))
i : Multiset Œπ
s : i.Nodup
‚ä¢ ‚àÄ i_1 ‚àà i, f i_1 ‚äÜ ‚àÖ
error:  no goals to be solved","theorem linearIndependent_iUnion_finite_subtype {Œπ : Type*} {f : Œπ ‚Üí Set M}
    (hl : ‚àÄ i, LinearIndependent R (fun x => x : f i ‚Üí M))
    (hd : ‚àÄ i, ‚àÄ t : Set Œπ, t.Finite ‚Üí i ‚àâ t ‚Üí Disjoint (span R (f i)) (‚®Ü i ‚àà t, span R (f i))) :
    LinearIndependent R (fun x => x : (‚ãÉ i, f i) ‚Üí M) ",":= by
  classical
  rw [iUnion_eq_iUnion_finset f]
  apply linearIndependent_iUnion_of_directed
  ¬∑ apply directed_of_isDirected_le
    exact fun t‚ÇÅ t‚ÇÇ ht => iUnion_mono fun i => iUnion_subset_iUnion_const fun h => ht h
  intro t
  induction' t using Finset.induction_on with i s his ih
  ¬∑ refine (linearIndependent_empty R M).mono ?_
    simp
  ¬∑ rw [Finset.set_biUnion_insert]
    refine (hl _).union ih ?_
    rw [span_iUnion‚ÇÇ]
    exact hd i s s.finite_toSet his"
Mathlib/Order/BooleanGenerators.lean,IsCompactlyGenerated.BooleanGenerators.complementedLattice_of_sSup_eq_top,complementedLattice_of_sSup_eq_top,91cefd36159ba7887974ebf32978e5a613629ba1,":= by
  constructor
  intro a
  obtain ‚ü®T, hT, rfl‚ü© := hS.atomistic a (le_top.trans h.ge)
  use sSup (S \ T)
  constructor
  swap
  ¬∑ rw [codisjoint_iff, ‚Üê sSup_union, Set.union_diff_self, Set.union_eq_right.mpr hT, h]
  intro b hb‚ÇÅ hb‚ÇÇ
  obtain ‚ü®X, hX, rfl‚ü© := hS.atomistic b (le_top.trans h.ge)
  rw [hS.sSup_le_sSup_iff_of_atoms _ _ hX] at hb‚ÇÅ hb‚ÇÇ
  ¬∑ obtain rfl : X = ‚àÖ := by
      have := Set.disjoint_sdiff_right hb‚ÇÅ hb‚ÇÇ
      rwa [‚Üê eq_bot_iff] at this
    simp only [sSup_empty, le_refl]
  ¬∑ exact Set.diff_subset _ _
  ¬∑ exact hT","error:  invalid field 'sSup_le_sSup_iff_of_atoms', the environment does not contain 'IsCompactlyGenerated.BooleanGenerators.sSup_le_sSup_iff_of_atoms'
  hS
has type
  BooleanGenerators S
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.21506
case h.disjoint.intro.intro
Œ± : Type u_1
inst‚úù¬π : CompleteLattice Œ±
inst‚úù : IsCompactlyGenerated Œ±
S : Set Œ±
hS : BooleanGenerators S
h : sSup S = ‚ä§
T : Set Œ±
hT : T ‚äÜ S
X : Set Œ±
hX : X ‚äÜ S
hb‚ÇÅ : sSup X ‚â§ sSup T
hb‚ÇÇ : sSup X ‚â§ sSup (S \ T)
‚ä¢ sSup X ‚â§ ‚ä•",lemma complementedLattice_of_sSup_eq_top (h : sSup S = ‚ä§) : ComplementedLattice Œ± ,":= by
  let _i := hS.distribLattice_of_sSup_eq_top h
  have _i‚ÇÅ := isAtomistic_of_sSup_eq_top hS h
  apply complementedLattice_of_isAtomistic"
Mathlib/CategoryTheory/Limits/Shapes/ConcreteCategory.lean,CategoryTheory.Limits.Concrete.Pi.map_ext,Pi.map_ext,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  apply ConcreteCategory.injective_of_mono_of_preservesPullback (PreservesProduct.iso F f).hom
  apply @Concrete.limit_ext.{w, r, t} D
    _ _ (Discrete J) _ _ _ _ (piComparison F _ x) (piComparison F _ y)
  intro ‚ü®(j : J)‚ü©
  show ((forget D).map (piComparison F f) ‚â´ (forget D).map (limit.œÄ _ _)) x =
    ((forget D).map (piComparison F f) ‚â´ (forget D).map _) y
  rw [‚Üê (forget D).map_comp, piComparison_comp_œÄ]
  exact h j","error:  application type mismatch
  Discrete J
argument
  J
has type
  Type w : Type (w + 1)
but is expected to have type
  Type r : Type (r + 1)","lemma Pi.map_ext (x y : F.obj (‚àè·∂ú f : C))
    (h : ‚àÄ i, F.map (Pi.œÄ f i) x = F.map (Pi.œÄ f i) y) : x = y ",":= by
  apply ConcreteCategory.injective_of_mono_of_preservesPullback (PreservesProduct.iso F f).hom
  apply @Concrete.limit_ext.{w, w, r, t} D
    _ _ (Discrete J) _ _ _ _ (piComparison F _ x) (piComparison F _ y)
  intro ‚ü®(j : J)‚ü©
  show ((forget D).map (piComparison F f) ‚â´ (forget D).map (limit.œÄ _ _)) x =
    ((forget D).map (piComparison F f) ‚â´ (forget D).map _) y
  rw [‚Üê (forget D).map_comp, piComparison_comp_œÄ]
  exact h j"
Mathlib/Probability/Distributions/Gaussian.lean,ProbabilityTheory.gaussianReal_map_add_const,gaussianReal_map_add_const,e6812a236ebd753eb9d9605eafb14df67bdb79b2,":= by
  by_cases hv : v = 0
  ¬∑ simp only [hv, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.add_const _) _
  let e : ‚Ñù ‚âÉ·µê ‚Ñù :=
  { toFun := fun x ‚Ü¶ x - y
    invFun := fun x ‚Ü¶ x + y
    left_inv := fun x ‚Ü¶ by simp
    right_inv := fun x ‚Ü¶ by simp
    measurable_toFun := measurable_id'.add_const _
    measurable_invFun := measurable_id'.add_const _}
  have he' : ‚àÄ x, HasDerivAt e ((fun _ ‚Ü¶ 1) x) x := fun _ ‚Ü¶ (hasDerivAt_id _).sub_const y
  suffices (gaussianReal Œº v).map e.symm = gaussianReal (Œº + y) v by exact this
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs']
  simp only [abs_neg, abs_one, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, one_mul, ne_eq]
  rw [gaussianReal_apply_eq_integral _ hv hs']
  simp_rw [gaussianPdfReal_sub _ y]","error:  application type mismatch
  gaussianReal_apply_eq_integral ?m.254944 hv hs'
argument
  hs'
has type
  MeasurableSet s' : Prop
but is expected to have type
  Set ‚Ñù : Type","lemma gaussianReal_map_add_const (y : ‚Ñù) :
    (gaussianReal Œº v).map (¬∑ + y) = gaussianReal (Œº + y) v ",":= by
  by_cases hv : v = 0
  ¬∑ simp only [hv, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.add_const _) _
  let e : ‚Ñù ‚âÉ·µê ‚Ñù := (Homeomorph.addRight y).symm.toMeasurableEquiv
  have he' : ‚àÄ x, HasDerivAt e ((fun _ ‚Ü¶ 1) x) x := fun _ ‚Ü¶ (hasDerivAt_id _).sub_const y
  change (gaussianReal Œº v).map e.symm = gaussianReal (Œº + y) v
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs']
  simp only [abs_neg, abs_one, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, one_mul, ne_eq]
  rw [gaussianReal_apply_eq_integral _ hv s']
  simp [e, gaussianPDFReal_sub _ y, Homeomorph.addRight, ‚Üê sub_eq_add_neg]"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.integral_cpow_mul_exp_neg_mul_Ioi,integral_cpow_mul_exp_neg_mul_Ioi,84f6d10f9a51f8c6472ec85f7cb1f39056781a29,":= by
  have aux : (1 / r : ‚ÑÇ) ^ a = 1 / r * (1 / r) ^ (a - 1) := by
    nth_rewrite 2 [‚Üê cpow_one (1 / r : ‚ÑÇ)]
    rw [‚Üê cpow_add _ _ (one_div_ne_zero <| ofReal_ne_zero.mpr hr.ne'), add_sub_cancel'_right]
  calc
    _ = ‚à´ (t : ‚Ñù) in Ioi 0, (1 / r) ^ (a - 1) * (r * t) ^ (a - 1) * exp (-(r * t)) := by
      refine MeasureTheory.set_integral_congr measurableSet_Ioi (fun x hx ‚Ü¶ ?_)
      rw [mem_Ioi] at hx
      rw [mul_cpow_ofReal_nonneg hr.le hx.le, ‚Üê mul_assoc, one_div, ‚Üê ofReal_inv,
        ‚Üê mul_cpow_ofReal_nonneg (inv_pos.mpr hr).le hr.le, ‚Üê ofReal_mul r‚Åª¬π, inv_mul_cancel hr.ne',
        ofReal_one, one_cpow, one_mul]
    _ = |1 / r| * ‚à´ (t : ‚Ñù) in Ioi (r * 0), (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      simp_rw [‚Üê ofReal_mul]
      rw [integral_comp_mul_left_Ioi (fun x ‚Ü¶ _ * x ^ (a - 1) * exp (-x)) _ hr, mul_zero,
        real_smul, ‚Üê one_div]
    _ = 1 / r * ‚à´ (t : ‚Ñù) in Ioi 0, (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      rw [congr_arg Ioi (mul_zero r), _root_.abs_of_nonneg (one_div_pos.mpr hr).le, ofReal_div,
        ofReal_one]
    _ = 1 / r * (1 / r : ‚ÑÇ) ^ (a - 1) * (‚à´ (t : ‚Ñù) in Ioi 0, t ^ (a - 1) * exp (-t)) := by
      simp_rw [‚Üê integral_mul_left, mul_assoc]
    _ = (1 / r) ^ a * Gamma a := by
      rw [aux, Gamma_eq_integral ha]
      congr 2 with x
      rw [ofReal_exp, ofReal_neg, mul_comm]","warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
error:  unsolved goals
a : ‚ÑÇ
r : ‚Ñù
ha : 0 < a.re
hr : 0 < r
aux : (1 / ‚Üër) ^ a = 1 / ‚Üër * (1 / ‚Üër) ^ (a - 1)
‚ä¢ ‚Üë(1 / r) * ‚à´ (x : ‚Ñù) in Ioi 0, (1 / ‚Üër) ^ (a - 1) * ‚Üëx ^ (a - 1) * cexp (-‚Üëx) =
    ‚Üë|1 / r| * ‚à´ (t : ‚Ñù) in Ioi 0, (1 / ‚Üër) ^ (a - 1) * ‚Üët ^ (a - 1) * cexp (-‚Üët)","lemma integral_cpow_mul_exp_neg_mul_Ioi {a : ‚ÑÇ} {r : ‚Ñù} (ha : 0 < a.re) (hr : 0 < r) :
    ‚à´ (t : ‚Ñù) in Ioi 0, t ^ (a - 1) * exp (-(r * t)) = (1 / r) ^ a * Gamma a ",":= by
  have aux : (1 / r : ‚ÑÇ) ^ a = 1 / r * (1 / r) ^ (a - 1) := by
    nth_rewrite 2 [‚Üê cpow_one (1 / r : ‚ÑÇ)]
    rw [‚Üê cpow_add _ _ (one_div_ne_zero <| ofReal_ne_zero.mpr hr.ne'), add_sub_cancel]
  calc
    _ = ‚à´ (t : ‚Ñù) in Ioi 0, (1 / r) ^ (a - 1) * (r * t) ^ (a - 1) * exp (-(r * t)) := by
      refine MeasureTheory.setIntegral_congr measurableSet_Ioi (fun x hx ‚Ü¶ ?_)
      rw [mem_Ioi] at hx
      rw [mul_cpow_ofReal_nonneg hr.le hx.le, ‚Üê mul_assoc, one_div, ‚Üê ofReal_inv,
        ‚Üê mul_cpow_ofReal_nonneg (inv_pos.mpr hr).le hr.le, ‚Üê ofReal_mul r‚Åª¬π, inv_mul_cancel hr.ne',
        ofReal_one, one_cpow, one_mul]
    _ = 1 / r * ‚à´ (t : ‚Ñù) in Ioi 0, (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by
      simp_rw [‚Üê ofReal_mul]
      rw [integral_comp_mul_left_Ioi (fun x ‚Ü¶ _ * x ^ (a - 1) * exp (-x)) _ hr, mul_zero,
        real_smul, ‚Üê one_div, ofReal_div, ofReal_one]
    _ = 1 / r * (1 / r : ‚ÑÇ) ^ (a - 1) * (‚à´ (t : ‚Ñù) in Ioi 0, t ^ (a - 1) * exp (-t)) := by
      simp_rw [‚Üê integral_mul_left, mul_assoc]
    _ = (1 / r) ^ a * Gamma a := by
      rw [aux, Gamma_eq_integral ha]
      congr 2 with x
      rw [ofReal_exp, ofReal_neg, mul_comm]"
Mathlib/Combinatorics/Additive/PluenneckeRuzsa.lean,Finset.card_div_mul_le_card_div_mul_card_mul,card_div_mul_le_card_div_mul_card_mul,b6f850672eb8da55d1b220b37667f05296845b90,":= by
  rw [‚Üê div_inv_eq_mul, div_eq_mul_inv]
  exact ruzsa_triangle_inequality_mul_div_div _ _ _",error:  unknown identifier 'ruzsa_triangle_inequality_mul_div_div',"theorem card_div_mul_le_card_div_mul_card_mul (A B C : Finset Œ±) :
    (A / C).card * B.card ‚â§ (A / B).card * (B * C).card ",":= by
  rw [‚Üê div_inv_eq_mul, div_eq_mul_inv]
  exact card_mul_mul_le_card_div_mul_card_div _ _ _"
Mathlib/RingTheory/IntegralClosure.lean,normalizeScaleRoots_coeff_mul_leadingCoeff_pow,normalizeScaleRoots_coeff_mul_leadingCoeff_pow,787f21e24c1b4d0e7a88ac6d76f18bfb080d4d5c,":= by
  simp only [normalizeScaleRoots, finset_sum_coeff, coeff_monomial, Finset.sum_ite_eq', one_mul,
    zero_mul, mem_support_iff, ite_mul, Ne.def, ite_not]
  split_ifs with h‚ÇÅ h‚ÇÇ
  ¬∑ simp [h‚ÇÅ]
  ¬∑ rw [h‚ÇÇ, leadingCoeff, ‚Üê pow_succ, tsub_add_cancel_of_le hp]
  ¬∑ rw [mul_assoc, ‚Üê pow_add, tsub_add_cancel_of_le]
    apply Nat.le_sub_one_of_lt
    rw [lt_iff_le_and_ne]
    exact ‚ü®le_natDegree_of_ne_zero h‚ÇÅ, h‚ÇÇ‚ü©","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.316691 ‚Üí ?m.316691 ‚Üí Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a ^ ?n * ?a
case pos
R : Type u_1
A : Type u_2
B : Type u_3
S : Type u_4
inst‚úù‚Åµ : CommRing R
inst‚úù‚Å¥ : CommRing A
inst‚úù¬≥ : Ring B
inst‚úù¬≤ : CommRing S
inst‚úù¬π : Algebra R A
inst‚úù : Algebra R B
f‚úù¬π : R ‚Üí+* S
f‚úù : R ‚Üí+* B
f : R ‚Üí+* S
p : R[X]
x : S
i : ‚Ñï
hp : 1 ‚â§ p.natDegree
h‚ÇÅ : ¬¨p.coeff i = 0
h‚ÇÇ : i = p.natDegree
‚ä¢ p.coeff p.natDegree ^ p.natDegree = p.coeff p.natDegree * p.coeff p.natDegree ^ (p.natDegree - 1)","theorem normalizeScaleRoots_coeff_mul_leadingCoeff_pow (i : ‚Ñï) (hp : 1 ‚â§ natDegree p) :
    (normalizeScaleRoots p).coeff i * p.leadingCoeff ^ i =
      p.coeff i * p.leadingCoeff ^ (p.natDegree - 1) ",":= by
  simp only [normalizeScaleRoots, finset_sum_coeff, coeff_monomial, Finset.sum_ite_eq', one_mul,
    zero_mul, mem_support_iff, ite_mul, Ne, ite_not]
  split_ifs with h‚ÇÅ h‚ÇÇ
  ¬∑ simp [h‚ÇÅ]
  ¬∑ rw [h‚ÇÇ, leadingCoeff, ‚Üê pow_succ', tsub_add_cancel_of_le hp]
  ¬∑ rw [mul_assoc, ‚Üê pow_add, tsub_add_cancel_of_le]
    apply Nat.le_sub_one_of_lt
    rw [lt_iff_le_and_ne]
    exact ‚ü®le_natDegree_of_ne_zero h‚ÇÅ, h‚ÇÇ‚ü©"
Mathlib/MeasureTheory/Constructions/Polish.lean,MeasureTheory.measurablySeparable_range_of_disjoint,measurablySeparable_range_of_disjoint,62d1e98c9775031911b945f049f84047fafbe5e1,":= by
  by_contra hfg
  have I : ‚àÄ n x y, ¬¨MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) ‚Üí
      ‚àÉ x' y', x' ‚àà cylinder x n ‚àß y' ‚àà cylinder y n ‚àß
      ¬¨MeasurablySeparable (f '' cylinder x' (n + 1)) (g '' cylinder y' (n + 1)) := by
    intro n x y
    contrapose!
    intro H
    rw [‚Üê iUnion_cylinder_update x n, ‚Üê iUnion_cylinder_update y n, image_iUnion, image_iUnion]
    refine' MeasurablySeparable.iUnion fun i j => _
    exact H _ _ (update_mem_cylinder _ _ _) (update_mem_cylinder _ _ _)
  let A :=
    { p : ‚Ñï √ó (‚Ñï ‚Üí ‚Ñï) √ó (‚Ñï ‚Üí ‚Ñï) //
      ¬¨MeasurablySeparable (f '' cylinder p.2.1 p.1) (g '' cylinder p.2.2 p.1) }
  have : ‚àÄ p : A, ‚àÉ q : A,
      q.1.1 = p.1.1 + 1 ‚àß q.1.2.1 ‚àà cylinder p.1.2.1 p.1.1 ‚àß q.1.2.2 ‚àà cylinder p.1.2.2 p.1.1 := by
    rintro ‚ü®‚ü®n, x, y‚ü©, hp‚ü©
    rcases I n x y hp with ‚ü®x', y', hx', hy', h'‚ü©
    exact ‚ü®‚ü®‚ü®n + 1, x', y'‚ü©, h'‚ü©, rfl, hx', hy'‚ü©
  choose F hFn hFx hFy using this
  let p0 : A := ‚ü®‚ü®0, fun _ => 0, fun _ => 0‚ü©, by simp [hfg]‚ü©
  let p : ‚Ñï ‚Üí A := fun n => F^[n] p0
  have prec : ‚àÄ n, p (n + 1) = F (p n) := fun n => by simp only [iterate_succ', Function.comp]
  have pn_fst : ‚àÄ n, (p n).1.1 = n := by
    intro n
    induction' n with n IH
    ¬∑ rfl
    ¬∑ simp only [prec, hFn, IH]
  have Ix : ‚àÄ m n, m + 1 ‚â§ n ‚Üí (p n).1.2.1 m = (p (m + 1)).1.2.1 m := by
    intro m
    apply Nat.le_induction
    ¬∑ rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.fst m = (p n).val.snd.fst m := by
      apply hFx (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  have Iy : ‚àÄ m n, m + 1 ‚â§ n ‚Üí (p n).1.2.2 m = (p (m + 1)).1.2.2 m := by
    intro m
    apply Nat.le_induction
    ¬∑ rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.snd m = (p n).val.snd.snd m := by
      apply hFy (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  set x : ‚Ñï ‚Üí ‚Ñï := fun n => (p (n + 1)).1.2.1 n with hx
  set y : ‚Ñï ‚Üí ‚Ñï := fun n => (p (n + 1)).1.2.2 n with hy
  have M : ‚àÄ n, ¬¨MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    intro n
    convert (p n).2 using 3
    ¬∑ rw [pn_fst, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hx]
      exact (Ix i n hi).symm
    ¬∑ rw [pn_fst, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hy]
      exact (Iy i n hi).symm
  obtain ‚ü®u, v, u_open, v_open, xu, yv, huv‚ü© :
    ‚àÉ u v : Set Œ±, IsOpen u ‚àß IsOpen v ‚àß f x ‚àà u ‚àß g y ‚àà v ‚àß Disjoint u v := by
    apply t2_separation
    exact disjoint_iff_forall_ne.1 h (mem_range_self _) (mem_range_self _)
  letI : MetricSpace (‚Ñï ‚Üí ‚Ñï) := metricSpaceNatNat
  obtain ‚ü®Œµx, Œµxpos, hŒµx‚ü© : ‚àÉ (Œµx : ‚Ñù), Œµx > 0 ‚àß Metric.ball x Œµx ‚äÜ f ‚Åª¬π' u := by
    apply Metric.mem_nhds_iff.1
    exact hf.continuousAt.preimage_mem_nhds (u_open.mem_nhds xu)
  obtain ‚ü®Œµy, Œµypos, hŒµy‚ü© : ‚àÉ (Œµy : ‚Ñù), Œµy > 0 ‚àß Metric.ball y Œµy ‚äÜ g ‚Åª¬π' v := by
    apply Metric.mem_nhds_iff.1
    exact hg.continuousAt.preimage_mem_nhds (v_open.mem_nhds yv)
  obtain ‚ü®n, hn‚ü© : ‚àÉ n : ‚Ñï, (1 / 2 : ‚Ñù) ^ n < min Œµx Œµy :=
    exists_pow_lt_of_lt_one (lt_min Œµxpos Œµypos) (by norm_num)
  have B : MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    refine' ‚ü®u, _, _, u_open.measurableSet‚ü©
    ¬∑ rw [image_subset_iff]
      apply Subset.trans _ hŒµx
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_left _ _))
    ¬∑ refine' Disjoint.mono_left _ huv.symm
      change g '' cylinder y n ‚äÜ v
      rw [image_subset_iff]
      apply Subset.trans _ hŒµy
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_right _ _))
  exact M n B",error:  simp made no progress,"theorem measurablySeparable_range_of_disjoint [T2Space Œ±] [MeasurableSpace Œ±]
    [OpensMeasurableSpace Œ±] {f g : (‚Ñï ‚Üí ‚Ñï) ‚Üí Œ±} (hf : Continuous f) (hg : Continuous g)
    (h : Disjoint (range f) (range g)) : MeasurablySeparable (range f) (range g) ",":= by
  by_contra hfg
  have I : ‚àÄ n x y, ¬¨MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) ‚Üí
      ‚àÉ x' y', x' ‚àà cylinder x n ‚àß y' ‚àà cylinder y n ‚àß
      ¬¨MeasurablySeparable (f '' cylinder x' (n + 1)) (g '' cylinder y' (n + 1)) := by
    intro n x y
    contrapose!
    intro H
    rw [‚Üê iUnion_cylinder_update x n, ‚Üê iUnion_cylinder_update y n, image_iUnion, image_iUnion]
    refine MeasurablySeparable.iUnion fun i j => ?_
    exact H _ _ (update_mem_cylinder _ _ _) (update_mem_cylinder _ _ _)
  let A :=
    { p : ‚Ñï √ó (‚Ñï ‚Üí ‚Ñï) √ó (‚Ñï ‚Üí ‚Ñï) //
      ¬¨MeasurablySeparable (f '' cylinder p.2.1 p.1) (g '' cylinder p.2.2 p.1) }
  have : ‚àÄ p : A, ‚àÉ q : A,
      q.1.1 = p.1.1 + 1 ‚àß q.1.2.1 ‚àà cylinder p.1.2.1 p.1.1 ‚àß q.1.2.2 ‚àà cylinder p.1.2.2 p.1.1 := by
    rintro ‚ü®‚ü®n, x, y‚ü©, hp‚ü©
    rcases I n x y hp with ‚ü®x', y', hx', hy', h'‚ü©
    exact ‚ü®‚ü®‚ü®n + 1, x', y'‚ü©, h'‚ü©, rfl, hx', hy'‚ü©
  choose F hFn hFx hFy using this
  let p0 : A := ‚ü®‚ü®0, fun _ => 0, fun _ => 0‚ü©, by simp [hfg]‚ü©
  let p : ‚Ñï ‚Üí A := fun n => F^[n] p0
  have prec : ‚àÄ n, p (n + 1) = F (p n) := fun n => by simp only [p, iterate_succ', Function.comp]
  have pn_fst : ‚àÄ n, (p n).1.1 = n := by
    intro n
    induction' n with n IH
    ¬∑ rfl
    ¬∑ simp only [prec, hFn, IH]
  have Ix : ‚àÄ m n, m + 1 ‚â§ n ‚Üí (p n).1.2.1 m = (p (m + 1)).1.2.1 m := by
    intro m
    apply Nat.le_induction
    ¬∑ rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.fst m = (p n).val.snd.fst m := by
      apply hFx (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  have Iy : ‚àÄ m n, m + 1 ‚â§ n ‚Üí (p n).1.2.2 m = (p (m + 1)).1.2.2 m := by
    intro m
    apply Nat.le_induction
    ¬∑ rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.snd m = (p n).val.snd.snd m := by
      apply hFy (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  set x : ‚Ñï ‚Üí ‚Ñï := fun n => (p (n + 1)).1.2.1 n with hx
  set y : ‚Ñï ‚Üí ‚Ñï := fun n => (p (n + 1)).1.2.2 n with hy
  have M : ‚àÄ n, ¬¨MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    intro n
    convert (p n).2 using 3
    ¬∑ rw [pn_fst, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hx]
      exact (Ix i n hi).symm
    ¬∑ rw [pn_fst, ‚Üê mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hy]
      exact (Iy i n hi).symm
  obtain ‚ü®u, v, u_open, v_open, xu, yv, huv‚ü© :
      ‚àÉ u v : Set Œ±, IsOpen u ‚àß IsOpen v ‚àß f x ‚àà u ‚àß g y ‚àà v ‚àß Disjoint u v := by
    apply t2_separation
    exact disjoint_iff_forall_ne.1 h (mem_range_self _) (mem_range_self _)
  letI : MetricSpace (‚Ñï ‚Üí ‚Ñï) := metricSpaceNatNat
  obtain ‚ü®Œµx, Œµxpos, hŒµx‚ü© : ‚àÉ (Œµx : ‚Ñù), Œµx > 0 ‚àß Metric.ball x Œµx ‚äÜ f ‚Åª¬π' u := by
    apply Metric.mem_nhds_iff.1
    exact hf.continuousAt.preimage_mem_nhds (u_open.mem_nhds xu)
  obtain ‚ü®Œµy, Œµypos, hŒµy‚ü© : ‚àÉ (Œµy : ‚Ñù), Œµy > 0 ‚àß Metric.ball y Œµy ‚äÜ g ‚Åª¬π' v := by
    apply Metric.mem_nhds_iff.1
    exact hg.continuousAt.preimage_mem_nhds (v_open.mem_nhds yv)
  obtain ‚ü®n, hn‚ü© : ‚àÉ n : ‚Ñï, (1 / 2 : ‚Ñù) ^ n < min Œµx Œµy :=
    exists_pow_lt_of_lt_one (lt_min Œµxpos Œµypos) (by norm_num)
  have B : MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    refine ‚ü®u, ?_, ?_, u_open.measurableSet‚ü©
    ¬∑ rw [image_subset_iff]
      apply Subset.trans _ hŒµx
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_left _ _))
    ¬∑ refine Disjoint.mono_left ?_ huv.symm
      change g '' cylinder y n ‚äÜ v
      rw [image_subset_iff]
      apply Subset.trans _ hŒµy
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_right _ _))
  exact M n B"
Mathlib/Order/ConditionallyCompleteLattice/Basic.lean,WithTop.isGLB_sInf',isGLB_sInf',596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  constructor
  ¬∑ show ite _ _ _ ‚àà _
    split_ifs with h
    ¬∑ intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exact le_top
      refine some_le_some.2 (csInf_le ?_ ha)
      rcases hs with ‚ü®‚ü®‚ü© | b, hb‚ü©
      ¬∑ exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, ‚Üê top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact some_le_some.1 (hb hc)
  ¬∑ show ite _ _ _ ‚àà _
    split_ifs with h
    ¬∑ intro _ _
      exact le_top
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      ¬∑ refine some_le_some.2 (le_csInf ?_ ?_)
        ¬∑ classical
            contrapose! h
            rintro (‚ü®‚ü© | a) ha
            ¬∑ exact mem_singleton ‚ä§
            ¬∑ exact (not_nonempty_iff_eq_empty.2 h ‚ü®a, ha‚ü©).elim
        ¬∑ intro b hb
          rw [‚Üê some_le_some]
          exact ha hb","error:  function expected at
  h
term has type
  s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.intro.none
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
h : ¬¨(s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s)
a : Œ≤
ha : Option.some a ‚àà s
hb : none ‚àà lowerBounds s
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.none
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
hs : BddBelow s
h : ¬¨(s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s)
ha : none ‚àà lowerBounds s
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.refine_1
Œ± : Type u_1
Œ≤‚úù : Type u_2
Œ≥ : Type u_3
Œπ : Sort u_4
inst‚úù¬π : ConditionallyCompleteLinearOrderBot Œ±
Œ≤ : Type u_5
inst‚úù : ConditionallyCompleteLattice Œ≤
s : Set (WithTop Œ≤)
hs : BddBelow s
a : Œ≤
ha : Option.some a ‚àà lowerBounds s
h : (fun a ‚Ü¶ ‚Üëa) ‚Åª¬π' s = ‚àÖ
‚ä¢ s ‚äÜ {‚ä§} ‚à® ¬¨BddBelow s
warning:  Don't mix Option and WithTop","theorem isGLB_sInf' {Œ≤ : Type*} [ConditionallyCompleteLattice Œ≤] {s : Set (WithTop Œ≤)}
    (hs : BddBelow s) : IsGLB s (sInf s) ",":= by
  constructor
  ¬∑ show ite _ _ _ ‚àà _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    ¬∑ intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exact le_top
      refine coe_le_coe.2 (csInf_le ?_ ha)
      rcases hs with ‚ü®‚ü®‚ü© | b, hb‚ü©
      ¬∑ exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, ‚Üê top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact coe_le_coe.1 (hb hc)
  ¬∑ show ite _ _ _ ‚àà _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    ¬∑ intro _ _
      exact le_top
    ¬∑ rintro (‚ü®‚ü© | a) ha
      ¬∑ exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      ¬∑ refine coe_le_coe.2 (le_csInf ?_ ?_)
        ¬∑ classical
            contrapose! h
            rintro (‚ü®‚ü© | a) ha
            ¬∑ exact mem_singleton ‚ä§
            ¬∑ exact (not_nonempty_iff_eq_empty.2 h ‚ü®a, ha‚ü©).elim
        ¬∑ intro b hb
          rw [‚Üê coe_le_coe]
          exact ha hb"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.Measure.hausdorffMeasure_zero_or_top,hausdorffMeasure_zero_or_top,ced4d3c0af763b9fd00166e49cf999cf46c891cc,":= by
  by_contra! H
  suffices ‚àÄ c : ‚Ñù‚â•0, c ‚â† 0 ‚Üí ŒºH[d‚ÇÇ] s ‚â§ c * ŒºH[d‚ÇÅ] s by
    rcases ENNReal.exists_nnreal_pos_mul_lt H.2 H.1 with ‚ü®c, hc0, hc‚ü©
    exact hc.not_le (this c (pos_iff_ne_zero.1 hc0))
  intro c hc
  refine le_iff'.1 (mkMetric_mono_smul ENNReal.coe_ne_top (mod_cast hc) _) s
  have : 0 < ((c : ‚Ñù‚â•0‚àû) ^ (d‚ÇÇ - d‚ÇÅ)‚Åª¬π) := by
    rw [ENNReal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, Ne, ENNReal.coe_eq_zero,
      NNReal.rpow_eq_zero_iff]
    exact mt And.left hc
  filter_upwards [Ico_mem_nhdsWithin_Ici ‚ü®le_rfl, this‚ü©]
  rintro r ‚ü®hr‚ÇÄ, hrc‚ü©
  lift r to ‚Ñù‚â•0 using ne_top_of_lt hrc
  rw [Pi.smul_apply, smul_eq_mul,
    ‚Üê ENNReal.div_le_iff_le_mul (Or.inr ENNReal.coe_ne_top) (Or.inr <| mt ENNReal.coe_eq_zero.1 hc)]
  rcases eq_or_ne r 0 with (rfl | hr‚ÇÄ)
  ¬∑ rcases lt_or_le 0 d‚ÇÇ with (h‚ÇÇ | h‚ÇÇ)
    ¬∑ simp only [h‚ÇÇ, ENNReal.zero_rpow_of_pos, zero_le, ENNReal.zero_div, ENNReal.coe_zero]
    ¬∑ simp only [h.trans_le h‚ÇÇ, ENNReal.div_top, zero_le, ENNReal.zero_rpow_of_neg,
        ENNReal.coe_zero]
  ¬∑ have : (r : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using hr‚ÇÄ
    rw [‚Üê ENNReal.rpow_sub _ _ this ENNReal.coe_ne_top]
    refine (ENNReal.rpow_lt_rpow hrc (sub_pos.2 h)).le.trans _
    rw [‚Üê ENNReal.rpow_mul, inv_mul_cancel (sub_pos.2 h).ne', ENNReal.rpow_one]","error:  don't know how to synthesize placeholder for argument 'hle'
context:
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬≥ : EMetricSpace X
inst‚úù¬≤ : EMetricSpace Y
inst‚úù¬π : MeasurableSpace X
inst‚úù : BorelSpace X
d‚ÇÅ d‚ÇÇ : ‚Ñù
h : d‚ÇÅ < d‚ÇÇ
s : Set X
H : ŒºH[d‚ÇÇ] s ‚â† 0 ‚àß ŒºH[d‚ÇÅ] s ‚â† ‚ä§
c : ‚Ñù‚â•0
hc : c ‚â† 0
‚ä¢ (fun r ‚Ü¶ r ^ d‚ÇÇ) ‚â§·∂†[ùìù[‚â•] 0] ‚Üëc ‚Ä¢ fun r ‚Ü¶ r ^ d‚ÇÅ
error:  unsolved goals
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬≥ : EMetricSpace X
inst‚úù¬≤ : EMetricSpace Y
inst‚úù¬π : MeasurableSpace X
inst‚úù : BorelSpace X
d‚ÇÅ d‚ÇÇ : ‚Ñù
h : d‚ÇÅ < d‚ÇÇ
s : Set X
H : ŒºH[d‚ÇÇ] s ‚â† 0 ‚àß ŒºH[d‚ÇÅ] s ‚â† ‚ä§
c : ‚Ñù‚â•0
hc : c ‚â† 0
‚ä¢ ŒºH[d‚ÇÇ] s ‚â§ ‚Üëc * ŒºH[d‚ÇÅ] s","theorem hausdorffMeasure_zero_or_top {d‚ÇÅ d‚ÇÇ : ‚Ñù} (h : d‚ÇÅ < d‚ÇÇ) (s : Set X) :
    ŒºH[d‚ÇÇ] s = 0 ‚à® ŒºH[d‚ÇÅ] s = ‚àû ",":= by
  by_contra! H
  suffices ‚àÄ c : ‚Ñù‚â•0, c ‚â† 0 ‚Üí ŒºH[d‚ÇÇ] s ‚â§ c * ŒºH[d‚ÇÅ] s by
    rcases ENNReal.exists_nnreal_pos_mul_lt H.2 H.1 with ‚ü®c, hc0, hc‚ü©
    exact hc.not_le (this c (pos_iff_ne_zero.1 hc0))
  intro c hc
  refine le_iff'.1 (mkMetric_mono_smul ENNReal.coe_ne_top (mod_cast hc) ?_) s
  have : 0 < ((c : ‚Ñù‚â•0‚àû) ^ (d‚ÇÇ - d‚ÇÅ)‚Åª¬π) := by
    rw [ENNReal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, Ne, ENNReal.coe_eq_zero,
      NNReal.rpow_eq_zero_iff]
    exact mt And.left hc
  filter_upwards [Ico_mem_nhdsWithin_Ici ‚ü®le_rfl, this‚ü©]
  rintro r ‚ü®hr‚ÇÄ, hrc‚ü©
  lift r to ‚Ñù‚â•0 using ne_top_of_lt hrc
  rw [Pi.smul_apply, smul_eq_mul,
    ‚Üê ENNReal.div_le_iff_le_mul (Or.inr ENNReal.coe_ne_top) (Or.inr <| mt ENNReal.coe_eq_zero.1 hc)]
  rcases eq_or_ne r 0 with (rfl | hr‚ÇÄ)
  ¬∑ rcases lt_or_le 0 d‚ÇÇ with (h‚ÇÇ | h‚ÇÇ)
    ¬∑ simp only [h‚ÇÇ, ENNReal.zero_rpow_of_pos, zero_le, ENNReal.zero_div, ENNReal.coe_zero]
    ¬∑ simp only [h.trans_le h‚ÇÇ, ENNReal.div_top, zero_le, ENNReal.zero_rpow_of_neg,
        ENNReal.coe_zero]
  ¬∑ have : (r : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using hr‚ÇÄ
    rw [‚Üê ENNReal.rpow_sub _ _ this ENNReal.coe_ne_top]
    refine (ENNReal.rpow_lt_rpow hrc (sub_pos.2 h)).le.trans ?_
    rw [‚Üê ENNReal.rpow_mul, inv_mul_cancel (sub_pos.2 h).ne', ENNReal.rpow_one]"
Mathlib/Data/Part.lean,Part.mem_toOption,mem_toOption,8d36235876dea0b8843e7cdecc85da3004503a83,":= by
  unfold toOption
  by_cases h : o.Dom <;> simp only [h, ‚ÜìreduceDite, Option.mem_def, Option.some.injEq, false_iff]
  ¬∑ exact ‚ü®fun h => ‚ü®_, h‚ü©, fun ‚ü®_, h‚ü© => h‚ü©
  ¬∑ exact mt Exists.fst h","error:  unknown identifier 'reduceDite'
error:  unknown identifier 'reduceDite'
error:  application type mismatch
  Exists.intro ?m.7256 h
argument
  h
has type
  (if h : True then Option.some (o.get ‚ãØ) else Option.none) = Option.some a : Prop
but is expected to have type
  o.get ?m.7256 = a : Prop
error:  type mismatch
  h
has type
  o.get w‚úù = a : Prop
but is expected to have type
  (if h : True then Option.some (o.get ‚ãØ) else Option.none) = Option.some a : Prop
error:  type mismatch
  mt Exists.fst h
has type
  ¬¨Exists ?m.7658 : Prop
but is expected to have type
  (if h_1 : False then Option.some (o.get ‚ãØ) else Option.none) = Option.some a ‚Üî a ‚àà o : Prop",theorem mem_toOption {o : Part Œ±} [Decidable o.Dom] {a : Œ±} : a ‚àà toOption o ‚Üî a ‚àà o ,":= by
  unfold toOption
  by_cases h : o.Dom <;> simp [h]
  ¬∑ exact ‚ü®fun h => ‚ü®_, h‚ü©, fun ‚ü®_, h‚ü© => h‚ü©
  ¬∑ exact mt Exists.fst h"
Mathlib/Analysis/Convex/Combination.lean,Set.Finite.convexHull_eq_image,Set.Finite.convexHull_eq_image,67a30f55cabb8ddd087043d4900eb7947be27d10,":= by
  letI := hs.fintype
  rw [‚Üê convexHull_basis_eq_stdSimplex, ‚Üê LinearMap.convexHull_image, ‚Üê Set.range_comp]
  apply congr_arg
  simp_rw [Function.comp]
  convert Subtype.range_coe.symm
  simp [LinearMap.sum_apply, ite_smul _ _ (1 : R), Finset.filter_eq, Finset.mem_univ]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.568565 ‚Üí+* ?m.568566) ‚Üí
    (M : Type ?u.568562) ‚Üí
      (M‚ÇÇ : Type ?u.568561) ‚Üí
        [inst : AddCommMonoid M] ‚Üí
          [inst_1 : AddCommMonoid M‚ÇÇ] ‚Üí
            [inst : Module ?m.568565 M] ‚Üí [inst : Module ?m.568566 M‚ÇÇ] ‚Üí Type (max ?u.568562 ?u.568561)
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.568634
R : Type u_1
R' : Type u_2
E : Type u_3
F : Type u_4
Œπ : Type u_5
Œπ' : Type u_6
Œ± : Type u_7
inst‚úù‚Åπ : LinearOrderedField R
inst‚úù‚Å∏ : LinearOrderedField R'
inst‚úù‚Å∑ : AddCommGroup E
inst‚úù‚Å∂ : AddCommGroup F
inst‚úù‚Åµ : LinearOrderedAddCommGroup Œ±
inst‚úù‚Å¥ : Module R E
inst‚úù¬≥ : Module R F
inst‚úù¬≤ : Module R Œ±
inst‚úù¬π : OrderedSMul R Œ±
s‚úù : Set E
i j : Œπ
c : R
t : Finset Œπ
w : Œπ ‚Üí R
z : Œπ ‚Üí E
inst‚úù : Fintype Œπ
f : Œπ ‚Üí R
s : Set E
hs : s.Finite
this : Fintype ‚Üës := hs.fintype
‚ä¢ (convexHull R) s =
    ‚áë(‚àë x : ‚Üës, (LinearMap.proj x).smulRight ‚Üëx) '' (convexHull R) (range fun i j ‚Ü¶ if i = j then 1 else 0)","theorem Set.Finite.convexHull_eq_image {s : Set E} (hs : s.Finite) : convexHull R s =
    haveI := hs.fintype
    (‚áë(‚àë x : s, (@LinearMap.proj R s _ (fun _ => R) _ _ x).smulRight x.1)) '' stdSimplex R s ",":= by
  letI := hs.fintype
  rw [‚Üê convexHull_basis_eq_stdSimplex, LinearMap.image_convexHull, ‚Üê Set.range_comp]
  apply congr_arg
  simp_rw [Function.comp]
  convert Subtype.range_coe.symm
  simp [LinearMap.sum_apply, ite_smul, Finset.filter_eq, Finset.mem_univ]"
Mathlib/RingTheory/IntegralClosure.lean,RingHom.isIntegralElem_leadingCoeff_mul,RingHom.isIntegralElem_leadingCoeff_mul,a76dc22f3a90e5ab96e9284d30276a87a4324a5d,":= by
  by_cases h' : 1 ‚â§ p.natDegree
  ¬∑ use normalizeScaleRoots p
    have : p ‚â† 0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_eval‚ÇÇ_leadingCoeff_mul p h' f x, h, mul_zero]
  ¬∑ by_cases hp : p.map f = 0
    ¬∑ apply_fun fun q => coeff q p.natDegree at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, zero_mul]
      exact f.is_integral_zero
    ¬∑ rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', eval‚ÇÇ_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]","error:  invalid field 'is_integral_zero', the environment does not contain 'RingHom.is_integral_zero'
  f
has type
  R ‚Üí+* S","theorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval‚ÇÇ f x = 0) :
    f.IsIntegralElem (f p.leadingCoeff * x) ",":= by
  by_cases h' : 1 ‚â§ p.natDegree
  ¬∑ use normalizeScaleRoots p
    have : p ‚â† 0 := fun h'' => by
      rw [h'', natDegree_zero] at h'
      exact Nat.not_succ_le_zero 0 h'
    use normalizeScaleRoots_monic p this
    rw [normalizeScaleRoots_eval‚ÇÇ_leadingCoeff_mul p h' f x, h, mul_zero]
  ¬∑ by_cases hp : p.map f = 0
    ¬∑ apply_fun fun q => coeff q p.natDegree at hp
      rw [coeff_map, coeff_zero, coeff_natDegree] at hp
      rw [hp, zero_mul]
      exact f.isIntegralElem_zero
    ¬∑ rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'
      rw [eq_C_of_natDegree_eq_zero h', eval‚ÇÇ_C] at h
      suffices p.map f = 0 by exact (hp this).elim
      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]"
Mathlib/Data/Finset/Fold.lean,Finset.fold_ite',fold_ite',c959b2f950b9c44268e36bcedef976356855e6fb,":= by
  classical
    induction' s with x s hx IH
    ¬∑ simp [hb]
    ¬∑ simp only [Finset.fold_insert hx]
      split_ifs with h
      ¬∑ have : x ‚àâ Finset.filter p s := by simp [hx]
        simp [Finset.filter_insert, h, Finset.fold_insert this, ha.assoc, IH]
      ¬∑ have : x ‚àâ Finset.filter (fun i => ¬¨ p i) s := by simp [hx]
        simp [Finset.filter_insert, h, Finset.fold_insert this, IH, ‚Üê ha.assoc, hc.comm]","error:  simp made no progress
error:  no goals to be solved","theorem fold_ite' {g : Œ± ‚Üí Œ≤} (hb : op b b = b) (p : Œ± ‚Üí Prop) [DecidablePred p] :
    Finset.fold op b (fun i => ite (p i) (f i) (g i)) s =
      op (Finset.fold op b f (s.filter p)) (Finset.fold op b g (s.filter fun i => ¬¨p i)) ",":= by
  classical
    induction' s using Finset.induction_on with x s hx IH
    ¬∑ simp [hb]
    ¬∑ simp only [Finset.fold_insert hx]
      split_ifs with h
      ¬∑ have : x ‚àâ Finset.filter p s := by simp [hx]
        simp [Finset.filter_insert, h, Finset.fold_insert this, ha.assoc, IH]
      ¬∑ have : x ‚àâ Finset.filter (fun i => ¬¨ p i) s := by simp [hx]
        simp [Finset.filter_insert, h, Finset.fold_insert this, IH, ‚Üê ha.assoc, hc.comm]"
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.Œ¥_comp_œÉ_succ,Œ¥_comp_œÉ_succ,7472132820a806816d92180a5476e45b47a8d68b,":=
  Hom.ext _ _ (OrderHom.ext _ _ (Fin.predAbove_comp_succAbove_succ))",error:  unknown constant 'Fin.predAbove_comp_succAbove_succ',theorem Œ¥_comp_œÉ_succ {n} {i : Fin (n + 1)} : Œ¥ i.succ ‚â´ œÉ i = ùüô ([n] : SimplexCategory) ,":= by
  ext j
  rcases i with ‚ü®i, _‚ü©
  rcases j with ‚ü®j, _‚ü©
  dsimp [Œ¥, œÉ, Fin.succAbove, Fin.predAbove]
  split_ifs <;> simp <;> simp at * <;> omega"
Mathlib/Topology/FiberBundle/Basic.lean,FiberBundle.exists_trivialization_Icc_subset,FiberBundle.exists_trivialization_Icc_subset,6bb383b09ebd407aabadf1dde2aef5017ac69b0f,":= by
  obtain ‚ü®ea, hea‚ü© : ‚àÉ ea : Trivialization F (œÄ F E), a ‚àà ea.baseSet :=
    ‚ü®trivializationAt F E a, mem_baseSet_trivializationAt F E a‚ü©
  cases' lt_or_le b a with hab hab
  ¬∑ exact ‚ü®ea, by simp [*]‚ü©
  set s : Set B := { x ‚àà Icc a b | ‚àÉ e : Trivialization F (œÄ F E), Icc a x ‚äÜ e.baseSet }
  have ha : a ‚àà s := ‚ü®left_mem_Icc.2 hab, ea, by simp [hea]‚ü©
  have sne : s.Nonempty := ‚ü®a, ha‚ü©
  have hsb : b ‚àà upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := ‚ü®b, hsb‚ü©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c ‚àà Icc a b := ‚ü®hsc.1 ha, hsc.2 hsb‚ü©
  obtain ‚ü®-, ec : Trivialization F (œÄ F E), hec : Icc a c ‚äÜ ec.baseSet‚ü© : c ‚àà s := by
    cases' hc.1.eq_or_lt with heq hlt
    ¬∑ rwa [‚Üê heq]
    refine ‚ü®hc, ?_‚ü©
    obtain ‚ü®ec, hc‚ü© : ‚àÉ ec : Trivialization F (œÄ F E), c ‚àà ec.baseSet :=
      ‚ü®trivializationAt F E c, mem_baseSet_trivializationAt F E c‚ü©
    obtain ‚ü®c', hc', hc'e‚ü© : ‚àÉ c' ‚àà Ico a c, Ioc c' c ‚äÜ ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain ‚ü®d, ‚ü®hdab, ead, had‚ü©, hd‚ü© : ‚àÉ d ‚àà s, d ‚àà Ioc c' c := hsc.exists_between hc'.2
    refine' ‚ü®ead.piecewiseLe ec d (had ‚ü®hdab.1, le_rfl‚ü©) (hc'e hd), subset_ite.2 _‚ü©
    refine' ‚ü®fun x hx => had ‚ü®hx.1.1, hx.2‚ü©, fun x hx => hc'e ‚ü®hd.1.trans (not_le.1 hx.2), hx.1.2‚ü©‚ü©
  cases' hc.2.eq_or_lt with heq hlt
  ¬∑ exact ‚ü®ec, heq ‚ñ∏ hec‚ü©
  rsuffices ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, ‚àÉ e : Trivialization F (œÄ F E), Icc a d ‚äÜ e.baseSet
  ¬∑ exact ((hsc.1 ‚ü®‚ü®hc.1.trans hdcb.1.le, hdcb.2‚ü©, hd‚ü©).not_lt hdcb.1).elim
  obtain ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, Ico c d ‚äÜ ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec ‚ü®hc.1, le_rfl‚ü©))
  have had : Ico a d ‚äÜ ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  ¬∑ obtain ‚ü®ed, hed‚ü© : ‚àÉ ed : Trivialization F (œÄ F E), d ‚àà ed.baseSet :=
      ‚ü®trivializationAt F E d, mem_baseSet_trivializationAt F E d‚ü©
    refine' ‚ü®d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono (inter_subset_right _ _) (inter_subset_right _ _)), fun x hx => _‚ü©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr ‚ü®hed, hdcb.1‚ü©, Or.inl ‚ü®had ‚ü®hx.1, hxd‚ü©, hxd‚ü©]
  ¬∑ rw [disjoint_left] at he
    push_neg at he
    rcases he with ‚ü®d', hdd' : d' < d, hd'c‚ü©
    exact ‚ü®d', ‚ü®hd'c, hdd'.le.trans hdcb.2‚ü©, ec, (Icc_subset_Ico_right hdd').trans had‚ü©","error:  function expected at
  inter_subset_right ?m.16177
term has type
  ?m.16176 ‚àà ?m.16175
error:  function expected at
  inter_subset_right ?m.16219
term has type
  ?m.16218 ‚àà ?m.16217","theorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]
    [OrderTopology B] [FiberBundle F E] (a b : B) :
    ‚àÉ e : Trivialization F (œÄ F E), Icc a b ‚äÜ e.baseSet ",":= by
  obtain ‚ü®ea, hea‚ü© : ‚àÉ ea : Trivialization F (œÄ F E), a ‚àà ea.baseSet :=
    ‚ü®trivializationAt F E a, mem_baseSet_trivializationAt F E a‚ü©
  cases' lt_or_le b a with hab hab
  ¬∑ exact ‚ü®ea, by simp [*]‚ü©
  set s : Set B := { x ‚àà Icc a b | ‚àÉ e : Trivialization F (œÄ F E), Icc a x ‚äÜ e.baseSet }
  have ha : a ‚àà s := ‚ü®left_mem_Icc.2 hab, ea, by simp [hea]‚ü©
  have sne : s.Nonempty := ‚ü®a, ha‚ü©
  have hsb : b ‚àà upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := ‚ü®b, hsb‚ü©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c ‚àà Icc a b := ‚ü®hsc.1 ha, hsc.2 hsb‚ü©
  obtain ‚ü®-, ec : Trivialization F (œÄ F E), hec : Icc a c ‚äÜ ec.baseSet‚ü© : c ‚àà s := by
    rcases hc.1.eq_or_lt with heq | hlt
    ¬∑ rwa [‚Üê heq]
    refine ‚ü®hc, ?_‚ü©
    obtain ‚ü®ec, hc‚ü© : ‚àÉ ec : Trivialization F (œÄ F E), c ‚àà ec.baseSet :=
      ‚ü®trivializationAt F E c, mem_baseSet_trivializationAt F E c‚ü©
    obtain ‚ü®c', hc', hc'e‚ü© : ‚àÉ c' ‚àà Ico a c, Ioc c' c ‚äÜ ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain ‚ü®d, ‚ü®hdab, ead, had‚ü©, hd‚ü© : ‚àÉ d ‚àà s, d ‚àà Ioc c' c := hsc.exists_between hc'.2
    refine ‚ü®ead.piecewiseLe ec d (had ‚ü®hdab.1, le_rfl‚ü©) (hc'e hd), subset_ite.2 ?_‚ü©
    exact ‚ü®fun x hx => had ‚ü®hx.1.1, hx.2‚ü©, fun x hx => hc'e ‚ü®hd.1.trans (not_le.1 hx.2), hx.1.2‚ü©‚ü©
  rcases hc.2.eq_or_lt with heq | hlt
  ¬∑ exact ‚ü®ec, heq ‚ñ∏ hec‚ü©
  rsuffices ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, ‚àÉ e : Trivialization F (œÄ F E), Icc a d ‚äÜ e.baseSet
  ¬∑ exact ((hsc.1 ‚ü®‚ü®hc.1.trans hdcb.1.le, hdcb.2‚ü©, hd‚ü©).not_lt hdcb.1).elim
  obtain ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, Ico c d ‚äÜ ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec ‚ü®hc.1, le_rfl‚ü©))
  have had : Ico a d ‚äÜ ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  ¬∑ obtain ‚ü®ed, hed‚ü© : ‚àÉ ed : Trivialization F (œÄ F E), d ‚àà ed.baseSet :=
      ‚ü®trivializationAt F E d, mem_baseSet_trivializationAt F E d‚ü©
    refine ‚ü®d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono inter_subset_right inter_subset_right), fun x hx => ?_‚ü©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr ‚ü®hed, hdcb.1‚ü©, Or.inl ‚ü®had ‚ü®hx.1, hxd‚ü©, hxd‚ü©]
  ¬∑ rw [disjoint_left] at he
    push_neg at he
    rcases he with ‚ü®d', hdd' : d' < d, hd'c‚ü©
    exact ‚ü®d', ‚ü®hd'c, hdd'.le.trans hdcb.2‚ü©, ec, (Icc_subset_Ico_right hdd').trans had‚ü©"
Mathlib/CategoryTheory/Limits/Indization/IndObject.lean,CategoryTheory.Limits.isIndObject_of_isFiltered_of_finallySmall,isIndObject_of_isFiltered_of_finallySmall,476128e573a29c623a24754b867f995938432b84,":= by
  have h‚ÇÅ : (factoring (fromFinalModel (CostructuredArrow yoneda A)) ‚ãô
      inclusion (fromFinalModel (CostructuredArrow yoneda A))).Final := Functor.final_of_natIso
    (factoringCompInclusion (fromFinalModel <| CostructuredArrow yoneda A)).symm
  have h‚ÇÇ : Functor.Final (inclusion (fromFinalModel (CostructuredArrow yoneda A))) :=
    Functor.final_of_comp_full_faithful' (factoring _) (inclusion _)
  let c := (Presheaf.tautologicalCocone A).whisker
    (inclusion (fromFinalModel (CostructuredArrow yoneda A)))
  let hc : IsColimit c := (Functor.Final.isColimitWhiskerEquiv _ _).symm
    (Presheaf.isColimitTautologicalCocone A)
  have hq : Nonempty (FinalModel (CostructuredArrow yoneda A)) := Nonempty.map
    (Functor.Final.lift (fromFinalModel (CostructuredArrow yoneda A))) IsFiltered.nonempty
  exact ‚ü®_, inclusion (fromFinalModel _) ‚ãô CostructuredArrow.proj yoneda A, c.Œπ, hc‚ü©","error:  unknown identifier 'Presheaf.tautologicalCocone'
error:  unsolved goals
C : Type u
inst‚úù¬≤ : Category.{v, u} C
A : C·µí·µñ ‚•§ Type v
inst‚úù¬π : IsFiltered (CostructuredArrow yoneda A)
inst‚úù : FinallySmall (CostructuredArrow yoneda A)
h‚ÇÅ :
  (factoring (fromFinalModel (CostructuredArrow yoneda A)) ‚ãô
      inclusion (fromFinalModel (CostructuredArrow yoneda A))).Final
h‚ÇÇ : (inclusion (fromFinalModel (CostructuredArrow yoneda A))).Final
‚ä¢ IsIndObject A","theorem isIndObject_of_isFiltered_of_finallySmall (A : C·µí·µñ ‚•§ Type v)
    [IsFiltered (CostructuredArrow yoneda A)] [FinallySmall.{v} (CostructuredArrow yoneda A)] :
    IsIndObject A ",":= by
  have h‚ÇÅ : (factoring (fromFinalModel (CostructuredArrow yoneda A)) ‚ãô
      inclusion (fromFinalModel (CostructuredArrow yoneda A))).Final := Functor.final_of_natIso
    (factoringCompInclusion (fromFinalModel <| CostructuredArrow yoneda A)).symm
  have h‚ÇÇ : Functor.Final (inclusion (fromFinalModel (CostructuredArrow yoneda A))) :=
    Functor.final_of_comp_full_faithful' (factoring _) (inclusion _)
  let c := (tautologicalCocone A).whisker (inclusion (fromFinalModel (CostructuredArrow yoneda A)))
  let hc : IsColimit c := (Functor.Final.isColimitWhiskerEquiv _ _).symm
    (isColimitTautologicalCocone A)
  have hq : Nonempty (FinalModel (CostructuredArrow yoneda A)) := Nonempty.map
    (Functor.Final.lift (fromFinalModel (CostructuredArrow yoneda A))) IsFiltered.nonempty
  exact ‚ü®_, inclusion (fromFinalModel _) ‚ãô CostructuredArrow.proj yoneda A, c.Œπ, hc‚ü©"
Mathlib/Analysis/Analytic/IsolatedZeros.lean,AnalyticAt.unique_eventuallyEq_pow_smul_nonzero,unique_eventuallyEq_pow_smul_nonzero,8e31b5ac6bed8ba535a30f3442252684d2f151c1,":= by
  wlog h_le : n ‚â§ m generalizing m n
  ¬∑ exact ((this hn hm) (not_le.mp h_le).le).symm
  let ‚ü®g, hg_an, _, hg_eq‚ü© := hm
  let ‚ü®j, hj_an, hj_ne, hj_eq‚ü© := hn
  contrapose! hj_ne
  have : ‚àÉ·∂† z in ùìù[‚â†] z‚ÇÄ, j z = (z - z‚ÇÄ) ^ (m - n) ‚Ä¢ g z
  ¬∑ refine (eventually_nhdsWithin_iff.mpr ?_).frequently
    filter_upwards [hg_eq, hj_eq] with z hfz hfz' hz
    rwa [‚Üê Nat.add_sub_cancel' h_le, pow_add, mul_smul, hfz', smul_right_inj] at hfz
    exact pow_ne_zero _ <| sub_ne_zero.mpr hz
  rw [frequently_eq_iff_eventually_eq hj_an] at this
  rw [EventuallyEq.eq_of_nhds this, sub_self, zero_pow, zero_smul]
  ¬∑ apply Nat.zero_lt_sub_of_lt (Nat.lt_of_le_of_ne h_le hj_ne.symm)
  ¬∑ exact (((analyticAt_id ùïú _).sub analyticAt_const).pow _).smul hg_an","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
ùïú : Type u_1
inst‚úù¬≤ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ùïú E
s : E
p q : FormalMultilinearSeries ùïú ùïú E
f g‚úù : ùïú ‚Üí E
n‚úù : ‚Ñï
z z‚ÇÄ : ùïú
m n : ‚Ñï
hm : ‚àÉ g, AnalyticAt ùïú g z‚ÇÄ ‚àß g z‚ÇÄ ‚â† 0 ‚àß ‚àÄ·∂† (z : ùïú) in ùìù z‚ÇÄ, f z = (z - z‚ÇÄ) ^ m ‚Ä¢ g z
hn : ‚àÉ g, AnalyticAt ùïú g z‚ÇÄ ‚àß g z‚ÇÄ ‚â† 0 ‚àß ‚àÄ·∂† (z : ùïú) in ùìù z‚ÇÄ, f z = (z - z‚ÇÄ) ^ n ‚Ä¢ g z
h_le : n ‚â§ m
g : ùïú ‚Üí E
hg_an : AnalyticAt ùïú g z‚ÇÄ
left‚úù : g z‚ÇÄ ‚â† 0
hg_eq : ‚àÄ·∂† (z : ùïú) in ùìù z‚ÇÄ, f z = (z - z‚ÇÄ) ^ m ‚Ä¢ g z
j : ùïú ‚Üí E
hj_an : AnalyticAt ùïú j z‚ÇÄ
hj_eq : ‚àÄ·∂† (z : ùïú) in ùìù z‚ÇÄ, f z = (z - z‚ÇÄ) ^ n ‚Ä¢ j z
hj_ne : m ‚â† n
this : ‚àÉ·∂† (z : ùïú) in ùìù[‚â†] z‚ÇÄ, j z = (z - z‚ÇÄ) ^ (m - n) ‚Ä¢ g z
‚ä¢ j z‚ÇÄ = 0","lemma unique_eventuallyEq_pow_smul_nonzero {m n : ‚Ñï}
    (hm : ‚àÉ g, AnalyticAt ùïú g z‚ÇÄ ‚àß g z‚ÇÄ ‚â† 0 ‚àß ‚àÄ·∂† z in ùìù z‚ÇÄ, f z = (z - z‚ÇÄ) ^ m ‚Ä¢ g z)
    (hn : ‚àÉ g, AnalyticAt ùïú g z‚ÇÄ ‚àß g z‚ÇÄ ‚â† 0 ‚àß ‚àÄ·∂† z in ùìù z‚ÇÄ, f z = (z - z‚ÇÄ) ^ n ‚Ä¢ g z) :
    m = n ",":= by
  simp_rw [‚Üê zpow_natCast] at hm hn
  exact Int.ofNat_inj.mp <| unique_eventuallyEq_zpow_smul_nonzero
    (let ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := hm; ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ.filter_mono nhdsWithin_le_nhds‚ü©)
    (let ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := hn; ‚ü®g, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ.filter_mono nhdsWithin_le_nhds‚ü©)"
Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean,GeneralizedContinuedFraction.convergents'_of_int,convergents'_of_int,67bb925387960887a3b36a6aab219b9c613883f7,":= by
  induction' n with n
  ¬∑ simp only [zeroth_convergent'_eq_h, of_h_eq_floor, floor_intCast, Nat.zero_eq]
  ¬∑ rw [convergents', of_h_eq_floor, floor_intCast, add_right_eq_self]
    exact convergents'Aux_succ_none ((of_s_of_int K a).symm ‚ñ∏ Seq'.get?_nil 0) _",error:  unknown identifier 'Seq'.get?_nil',theorem convergents'_of_int (a : ‚Ñ§) : (of (a : K)).convergents' n = a ,":= by
  induction' n with n
  ¬∑ simp only [zeroth_convergent'_eq_h, of_h_eq_floor, floor_intCast, Nat.zero_eq]
  ¬∑ rw [convergents', of_h_eq_floor, floor_intCast, add_right_eq_self]
    exact convergents'Aux_succ_none ((of_s_of_int K a).symm ‚ñ∏ Stream'.Seq.get?_nil 0) _"
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,AffineSubspace.parallel_iff_direction_eq_and_eq_bot_iff_eq_bot,parallel_iff_direction_eq_and_eq_bot_iff_eq_bot,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  refine ‚ü®fun h => ‚ü®h.direction_eq, ?_, ?_‚ü©, fun h =?> _‚ü©
  ¬∑ rintro rfl
    exact bot_parallel_iff_eq_bot.1 h
  ¬∑ rintro rfl
    exact parallel_bot_iff_eq_bot.1 h
  ¬∑ rcases h with ‚ü®hd, hb‚ü©
    by_cases hs‚ÇÅ : s‚ÇÅ = ‚ä•
    ¬∑ rw [hs‚ÇÅ, bot_parallel_iff_eq_bot]
      exact hb.1 hs‚ÇÅ
    ¬∑ have hs‚ÇÇ : s‚ÇÇ ‚â† ‚ä• := hb.not.1 hs‚ÇÅ
      rcases (nonempty_iff_ne_bot s‚ÇÅ).2 hs‚ÇÅ with ‚ü®p‚ÇÅ, hp‚ÇÅ‚ü©
      rcases (nonempty_iff_ne_bot s‚ÇÇ).2 hs‚ÇÇ with ‚ü®p‚ÇÇ, hp‚ÇÇ‚ü©
      refine ‚ü®p‚ÇÇ -·µ• p‚ÇÅ, (eq_iff_direction_eq_of_mem hp‚ÇÇ ?_).2? _‚ü©
      ¬∑ rw [mem_map]
        refine ‚ü®p‚ÇÅ, hp‚ÇÅ, ?_‚ü©
        simp
      ¬∑ simpa using hd.symm","warning:  @AffineSubspace.Parallel does not have a doc string
error:  unexpected token '='; expected '‚Ü¶', '=>'
error:  unsolved goals
case refine_1
k : Type u_1
V : Type u_2
P : Type u_3
inst‚úù¬≥ : Ring k
inst‚úù¬≤ : AddCommGroup V
inst‚úù¬π : Module k V
inst‚úù : AffineSpace V P
s‚ÇÅ s‚ÇÇ : AffineSubspace k P
h : s‚ÇÅ ‚à• s‚ÇÇ
‚ä¢ s‚ÇÅ = ‚ä• ‚Üí s‚ÇÇ = ‚ä•

case refine_2
k : Type u_1
V : Type u_2
P : Type u_3
inst‚úù¬≥ : Ring k
inst‚úù¬≤ : AddCommGroup V
inst‚úù¬π : Module k V
inst‚úù : AffineSpace V P
s‚ÇÅ s‚ÇÇ : AffineSubspace k P
h : s‚ÇÅ ‚à• s‚ÇÇ
‚ä¢ s‚ÇÇ = ‚ä• ‚Üí s‚ÇÅ = ‚ä•","theorem parallel_iff_direction_eq_and_eq_bot_iff_eq_bot {s‚ÇÅ s‚ÇÇ : AffineSubspace k P} :
    s‚ÇÅ ‚à• s‚ÇÇ ‚Üî s‚ÇÅ.direction = s‚ÇÇ.direction ‚àß (s‚ÇÅ = ‚ä• ‚Üî s‚ÇÇ = ‚ä•) ",":= by
  refine ‚ü®fun h => ‚ü®h.direction_eq, ?_, ?_‚ü©, fun h => ?_‚ü©
  ¬∑ rintro rfl
    exact bot_parallel_iff_eq_bot.1 h
  ¬∑ rintro rfl
    exact parallel_bot_iff_eq_bot.1 h
  ¬∑ rcases h with ‚ü®hd, hb‚ü©
    by_cases hs‚ÇÅ : s‚ÇÅ = ‚ä•
    ¬∑ rw [hs‚ÇÅ, bot_parallel_iff_eq_bot]
      exact hb.1 hs‚ÇÅ
    ¬∑ have hs‚ÇÇ : s‚ÇÇ ‚â† ‚ä• := hb.not.1 hs‚ÇÅ
      rcases (nonempty_iff_ne_bot s‚ÇÅ).2 hs‚ÇÅ with ‚ü®p‚ÇÅ, hp‚ÇÅ‚ü©
      rcases (nonempty_iff_ne_bot s‚ÇÇ).2 hs‚ÇÇ with ‚ü®p‚ÇÇ, hp‚ÇÇ‚ü©
      refine ‚ü®p‚ÇÇ -·µ• p‚ÇÅ, (eq_iff_direction_eq_of_mem hp‚ÇÇ ?_).2 ?_‚ü©
      ¬∑ rw [mem_map]
        refine ‚ü®p‚ÇÅ, hp‚ÇÅ, ?_‚ü©
        simp
      ¬∑ simpa using hd.symm"
Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean,MeasureTheory.exists_lt_lowerSemicontinuous_integral_lt,exists_lt_lowerSemicontinuous_integral_lt,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ / 2, (half_pos Œµpos).le‚ü©
  have Œ¥pos : 0 < Œ¥ := half_pos Œµpos
  let fp : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (f x)
  have int_fp : Integrable (fun x => (fp x : ‚Ñù)) Œº := hf.real_toNNReal
  rcases exists_lt_lowerSemicontinuous_integral_gt_nnreal fp int_fp Œ¥pos with
    ‚ü®gp, fp_lt_gp, gpcont, gp_lt_top, gp_integrable, gpint‚ü©
  let fm : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (-f x)
  have int_fm : Integrable (fun x => (fm x : ‚Ñù)) Œº := hf.neg.real_toNNReal
  rcases exists_upperSemicontinuous_le_integral_le fm int_fm Œ¥pos with
    ‚ü®gm, gm_le_fm, gmcont, gm_integrable, gmint‚ü©
  let g : Œ± ‚Üí EReal := fun x => (gp x : EReal) - gm x
  have ae_g : ‚àÄ·µê x ‚àÇŒº, (g x).toReal = (gp x : EReal).toReal - (gm x : EReal).toReal := by
    filter_upwards [gp_lt_top] with _ hx
    rw [EReal.toReal_sub] <;> simp [hx.ne]
  refine' ‚ü®g, ?lt, ?lsc, ?int, ?aelt, ?intlt‚ü©
  case int =>
    show Integrable (fun x => EReal.toReal (g x)) Œº
    rw [integrable_congr ae_g]
    convert gp_integrable.sub gm_integrable
    simp
  case intlt =>
    show (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) < (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ;
    exact
      calc
        (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) = ‚à´ x : Œ±, EReal.toReal (gp x) - EReal.toReal (gm x) ‚àÇŒº :=
          integral_congr_ae ae_g
        _ = (‚à´ x : Œ±, EReal.toReal (gp x) ‚àÇŒº) - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          simp only [EReal.toReal_coe_ennreal, ENNReal.coe_toReal]
          exact integral_sub gp_integrable gm_integrable
        _ < (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          apply sub_lt_sub_right
          convert gpint
          simp only [EReal.toReal_coe_ennreal]
        _ ‚â§ (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ((‚à´ x : Œ±, ‚Üë(fm x) ‚àÇŒº) - Œ¥) := sub_le_sub_left gmint _
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + 2 * Œ¥ := by
          simp_rw [integral_eq_integral_pos_part_sub_integral_neg_part hf]; ring
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ := by congr 1; field_simp [Œ¥, mul_comm]
  case aelt =>
    show ‚àÄ·µê x : Œ± ‚àÇŒº, g x < ‚ä§
    filter_upwards [gp_lt_top] with ?_ hx
    simp only [g, sub_eq_add_neg, Ne, (EReal.add_lt_top _ _).ne, lt_top_iff_ne_top,
      lt_top_iff_ne_top.1 hx, EReal.coe_ennreal_eq_top_iff, not_false_iff, EReal.neg_eq_top_iff,
      EReal.coe_ennreal_ne_bot]
  case lt =>
    show ‚àÄ x, (f x : EReal) < g x
    intro x
    rw [EReal.coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal (f x)]
    refine EReal.sub_lt_sub_of_lt_of_le ?_ ??_ _? _
    ¬∑ simp only [EReal.coe_ennreal_lt_coe_ennreal_iff]; exact fp_lt_gp x
    ¬∑ simp only [ENNReal.coe_le_coe, EReal.coe_ennreal_le_coe_ennreal_iff]
      exact gm_le_fm x
    ¬∑ simp only [EReal.coe_ennreal_ne_bot, Ne, not_false_iff]
    ¬∑ simp only [EReal.coe_nnreal_ne_top, Ne, not_false_iff]
  case lsc =>
    show LowerSemicontinuous g
    apply LowerSemicontinuous.add'
    ¬∑ exact continuous_coe_ennreal_ereal.comp_lowerSemicontinuous gpcont fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
    ¬∑ apply continuous_neg.comp_upperSemicontinuous_antitone _ fun x y hxy =>
          EReal.neg_le_neg_iff.2 hxy
      dsimp
      apply continuous_coe_ennreal_ereal.comp_upperSemicontinuous _ fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
      exact ENNReal.continuous_coe.comp_upperSemicontinuous gmcont fun x y hxy =>
          ENNReal.coe_le_coe.2 hxy
    ¬∑ intro x
      exact EReal.continuousAt_add (by simp) (by simp)","error:  unexpected token '?'; expected '_' or identifier
error:  unsolved goals
case lsc
Œ± : Type u_1
inst‚úù‚Å¥ : TopologicalSpace Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : BorelSpace Œ±
Œº : Measure Œ±
inst‚úù¬π : Œº.WeaklyRegular
inst‚úù : SigmaFinite Œº
f : Œ± ‚Üí ‚Ñù
hf : Integrable f Œº
Œµ : ‚Ñù
Œµpos : 0 < Œµ
Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ / 2, ‚ãØ‚ü©
Œ¥pos : 0 < Œ¥
fp : Œ± ‚Üí ‚Ñù‚â•0 := fun x ‚Ü¶ (f x).toNNReal
int_fp : Integrable (fun x ‚Ü¶ ‚Üë(fp x)) Œº
gp : Œ± ‚Üí ‚Ñù‚â•0‚àû
fp_lt_gp : ‚àÄ (x : Œ±), ‚Üë(fp x) < gp x
gpcont : LowerSemicontinuous gp
gp_lt_top : ‚àÄ·µê (x : Œ±) ‚àÇŒº, gp x < ‚ä§
gp_integrable : Integrable (fun x ‚Ü¶ (gp x).toReal) Œº
gpint : ‚à´ (x : Œ±), (gp x).toReal ‚àÇŒº < ‚à´ (x : Œ±), ‚Üë(fp x) ‚àÇŒº + (fun a ‚Ü¶ ‚Üëa) Œ¥
fm : Œ± ‚Üí ‚Ñù‚â•0 := fun x ‚Ü¶ (-f x).toNNReal
int_fm : Integrable (fun x ‚Ü¶ ‚Üë(fm x)) Œº
gm : Œ± ‚Üí ‚Ñù‚â•0
gm_le_fm : ‚àÄ (x : Œ±), gm x ‚â§ fm x
gmcont : UpperSemicontinuous gm
gm_integrable : Integrable (fun x ‚Ü¶ ‚Üë(gm x)) Œº
gmint : ‚à´ (x : Œ±), ‚Üë(fm x) ‚àÇŒº - (fun a ‚Ü¶ ‚Üëa) Œ¥ ‚â§ ‚à´ (x : Œ±), ‚Üë(gm x) ‚àÇŒº
g : Œ± ‚Üí EReal := fun x ‚Ü¶ ‚Üë(gp x) - ‚Üë‚Üë(gm x)
ae_g : ‚àÄ·µê (x : Œ±) ‚àÇŒº, (g x).toReal = (‚Üë(gp x)).toReal - (‚Üë‚Üë(gm x)).toReal
‚ä¢ LowerSemicontinuous g","theorem exists_lt_lowerSemicontinuous_integral_lt [SigmaFinite Œº] (f : Œ± ‚Üí ‚Ñù) (hf : Integrable f Œº)
    {Œµ : ‚Ñù} (Œµpos : 0 < Œµ) :
    ‚àÉ g : Œ± ‚Üí EReal,
      (‚àÄ x, (f x : EReal) < g x) ‚àß
      LowerSemicontinuous g ‚àß
      Integrable (fun x => EReal.toReal (g x)) Œº ‚àß
      (‚àÄ·µê x ‚àÇŒº, g x < ‚ä§) ‚àß (‚à´ x, EReal.toReal (g x) ‚àÇŒº) < (‚à´ x, f x ‚àÇŒº) + Œµ ",":= by
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ / 2, (half_pos Œµpos).le‚ü©
  have Œ¥pos : 0 < Œ¥ := half_pos Œµpos
  let fp : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (f x)
  have int_fp : Integrable (fun x => (fp x : ‚Ñù)) Œº := hf.real_toNNReal
  rcases exists_lt_lowerSemicontinuous_integral_gt_nnreal fp int_fp Œ¥pos with
    ‚ü®gp, fp_lt_gp, gpcont, gp_lt_top, gp_integrable, gpint‚ü©
  let fm : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (-f x)
  have int_fm : Integrable (fun x => (fm x : ‚Ñù)) Œº := hf.neg.real_toNNReal
  rcases exists_upperSemicontinuous_le_integral_le fm int_fm Œ¥pos with
    ‚ü®gm, gm_le_fm, gmcont, gm_integrable, gmint‚ü©
  let g : Œ± ‚Üí EReal := fun x => (gp x : EReal) - gm x
  have ae_g : ‚àÄ·µê x ‚àÇŒº, (g x).toReal = (gp x : EReal).toReal - (gm x : EReal).toReal := by
    filter_upwards [gp_lt_top] with _ hx
    rw [EReal.toReal_sub] <;> simp [hx.ne]
  refine ‚ü®g, ?lt, ?lsc, ?int, ?aelt, ?intlt‚ü©
  case int =>
    show Integrable (fun x => EReal.toReal (g x)) Œº
    rw [integrable_congr ae_g]
    convert gp_integrable.sub gm_integrable
    simp
  case intlt =>
    show (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) < (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ;
    exact
      calc
        (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) = ‚à´ x : Œ±, EReal.toReal (gp x) - EReal.toReal (gm x) ‚àÇŒº :=
          integral_congr_ae ae_g
        _ = (‚à´ x : Œ±, EReal.toReal (gp x) ‚àÇŒº) - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          simp only [EReal.toReal_coe_ennreal, ENNReal.coe_toReal]
          exact integral_sub gp_integrable gm_integrable
        _ < (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          apply sub_lt_sub_right
          convert gpint
          simp only [EReal.toReal_coe_ennreal]
        _ ‚â§ (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ((‚à´ x : Œ±, ‚Üë(fm x) ‚àÇŒº) - Œ¥) := sub_le_sub_left gmint _
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + 2 * Œ¥ := by
          simp_rw [integral_eq_integral_pos_part_sub_integral_neg_part hf]; ring
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ := by congr 1; field_simp [Œ¥, mul_comm]
  case aelt =>
    show ‚àÄ·µê x : Œ± ‚àÇŒº, g x < ‚ä§
    filter_upwards [gp_lt_top] with ?_ hx
    simp only [g, sub_eq_add_neg, Ne, (EReal.add_lt_top _ _).ne, lt_top_iff_ne_top,
      lt_top_iff_ne_top.1 hx, EReal.coe_ennreal_eq_top_iff, not_false_iff, EReal.neg_eq_top_iff,
      EReal.coe_ennreal_ne_bot]
  case lt =>
    show ‚àÄ x, (f x : EReal) < g x
    intro x
    rw [EReal.coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal (f x)]
    refine EReal.sub_lt_sub_of_lt_of_le ?_ ?_ ?_ ?_
    ¬∑ simp only [EReal.coe_ennreal_lt_coe_ennreal_iff]; exact fp_lt_gp x
    ¬∑ simp only [ENNReal.coe_le_coe, EReal.coe_ennreal_le_coe_ennreal_iff]
      exact gm_le_fm x
    ¬∑ simp only [EReal.coe_ennreal_ne_bot, Ne, not_false_iff]
    ¬∑ simp only [EReal.coe_nnreal_ne_top, Ne, not_false_iff]
  case lsc =>
    show LowerSemicontinuous g
    apply LowerSemicontinuous.add'
    ¬∑ exact continuous_coe_ennreal_ereal.comp_lowerSemicontinuous gpcont fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
    ¬∑ apply continuous_neg.comp_upperSemicontinuous_antitone _ fun x y hxy =>
          EReal.neg_le_neg_iff.2 hxy
      dsimp
      apply continuous_coe_ennreal_ereal.comp_upperSemicontinuous _ fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
      exact ENNReal.continuous_coe.comp_upperSemicontinuous gmcont fun x y hxy =>
          ENNReal.coe_le_coe.2 hxy
    ¬∑ intro x
      exact EReal.continuousAt_add (by simp) (by simp)"
Mathlib/CategoryTheory/Limits/Constructions/Pullbacks.lean,CategoryTheory.Limits.hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair,hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  let Œπ‚ÇÅ : Y ‚ü∂ Y ‚®ø Z := coprod.inl
  let Œπ‚ÇÇ : Z ‚ü∂ Y ‚®ø Z := coprod.inr
  let c := coequalizer.œÄ (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ)
  HasColimit.mk
    { cocone :=
        PushoutCocone.mk (Œπ‚ÇÅ ‚â´ c) (Œπ‚ÇÇ ‚â´ c) <| by
          rw [‚Üê Category.assoc, ‚Üê Category.assoc, coequalizer.condition]
      isColimit :=
        PushoutCocone.IsColimit.mk _
          (fun s => coequalizer.desc
              (coprod.desc (s.Œπ.app WalkingSpan.left) (s.Œπ.app WalkingSpan.right)) <| by
            rw [Category.assoc, colimit.Œπ_desc, Category.assoc, colimit.Œπ_desc]
            exact PushoutCocone.condition _)
          (by simp) (by simp) fun s m h‚ÇÅ h‚ÇÇ => by
          ext
          ¬∑ simpa using h‚ÇÅ
          ¬∑ simpa using h‚ÇÇ }","error:  unsolved goals
C : Type u
ùíû : Category.{v, u} C
X Y Z : C
f : X ‚ü∂ Y
g : X ‚ü∂ Z
inst‚úù¬π : HasColimit (pair Y Z)
inst‚úù : HasColimit (parallelPair (f ‚â´ coprod.inl) (g ‚â´ coprod.inr))
Œπ‚ÇÅ : Y ‚ü∂ Y ‚®ø Z := coprod.inl
Œπ‚ÇÇ : Z ‚ü∂ Y ‚®ø Z := coprod.inr
c : Y ‚®ø Z ‚ü∂ coequalizer (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ) := coequalizer.œÄ (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ)
‚ä¢ ‚àÄ (s : PushoutCocone f g), Œπ‚ÇÅ ‚â´ c ‚â´ coequalizer.desc (coprod.desc s.inl s.inr) ‚ãØ = s.inl
error:  unsolved goals
C : Type u
ùíû : Category.{v, u} C
X Y Z : C
f : X ‚ü∂ Y
g : X ‚ü∂ Z
inst‚úù¬π : HasColimit (pair Y Z)
inst‚úù : HasColimit (parallelPair (f ‚â´ coprod.inl) (g ‚â´ coprod.inr))
Œπ‚ÇÅ : Y ‚ü∂ Y ‚®ø Z := coprod.inl
Œπ‚ÇÇ : Z ‚ü∂ Y ‚®ø Z := coprod.inr
c : Y ‚®ø Z ‚ü∂ coequalizer (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ) := coequalizer.œÄ (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ)
‚ä¢ ‚àÄ (s : PushoutCocone f g), Œπ‚ÇÇ ‚â´ c ‚â´ coequalizer.desc (coprod.desc s.inl s.inr) ‚ãØ = s.inr","theorem hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair {C : Type u}
    [ùíû : Category.{v} C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasColimit (pair Y Z)]
    [HasColimit (parallelPair (f ‚â´ coprod.inl) (g ‚â´ coprod.inr))] : HasColimit (span f g) ",":=
  let Œπ‚ÇÅ : Y ‚ü∂ Y ‚®ø Z := coprod.inl
  let Œπ‚ÇÇ : Z ‚ü∂ Y ‚®ø Z := coprod.inr
  let c := coequalizer.œÄ (f ‚â´ Œπ‚ÇÅ) (g ‚â´ Œπ‚ÇÇ)
  HasColimit.mk
    { cocone :=
        PushoutCocone.mk (Œπ‚ÇÅ ‚â´ c) (Œπ‚ÇÇ ‚â´ c) <| by
          rw [‚Üê Category.assoc, ‚Üê Category.assoc, coequalizer.condition]
      isColimit :=
        PushoutCocone.IsColimit.mk _
          (fun s => coequalizer.desc
              (coprod.desc (s.Œπ.app WalkingSpan.left) (s.Œπ.app WalkingSpan.right)) <| by
            rw [Category.assoc, colimit.Œπ_desc, Category.assoc, colimit.Œπ_desc]
            exact PushoutCocone.condition _)
          (by simp [Œπ‚ÇÅ, c]) (by simp [Œπ‚ÇÇ, c]) fun s m h‚ÇÅ h‚ÇÇ => by
          ext
          ¬∑ simpa using h‚ÇÅ
          ¬∑ simpa using h‚ÇÇ }"
Mathlib/NumberTheory/Multiplicity.lean,Int.two_pow_sub_pow,Int.two_pow_sub_pow,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have hx_odd : Odd x := by rwa [Int.odd_iff_not_even, even_iff_two_dvd]
  have hxy_even : Even (x - y) := even_iff_two_dvd.mpr (dvd_trans (by decide) hxy)
  have hy_odd : Odd y := by simpa using hx_odd.sub_even hxy_even
  cases' n with n
  ¬∑ simp only [pow_zero, sub_self, multiplicity.zero, Int.ofNat_zero, Nat.zero_eq, add_top]
  have h : (multiplicity 2 n.succ).Dom := multiplicity.finite_nat_iff.mpr ‚ü®by norm_num, n.succ_pos‚ü©
  rcases multiplicity.eq_coe_iff.mp (PartENat.natCast_get h).symm with ‚ü®‚ü®k, hk‚ü©, hpn‚ü©
  rw [hk, pow_mul, pow_mul, multiplicity.pow_sub_pow_of_prime,
    Int.two_pow_two_pow_sub_pow_two_pow _ hxy hx, ‚Üê hk, PartENat.natCast_get]
  ¬∑ norm_cast
  ¬∑ exact Int.prime_two
  ¬∑ simpa only [even_iff_two_dvd] using hx_odd.pow.sub_odd hy_odd.pow
  ¬∑ simpa only [even_iff_two_dvd, Int.odd_iff_not_even] using hx_odd.pow
  erw [Int.natCast_dvd_natCast]
  contrapose! hpn
  rw [pow_succ]
  conv_rhs => rw [hk]
  exact mul_dvd_mul_left _ hpn","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  n.succ
case succ.intro.intro
R : Type u_1
n‚úù : ‚Ñï
x y : ‚Ñ§
hxy : 4 ‚à£ x - y
hx : ¬¨2 ‚à£ x
hx_odd : Odd x
hxy_even : Even (x - y)
hy_odd : Odd y
n : ‚Ñï
h : (multiplicity 2 n.succ).Dom
hpn : ¬¨2 ^ ((multiplicity 2 n.succ).get h + 1) ‚à£ n.succ
k : ‚Ñï
hk : n.succ = 2 ^ (multiplicity 2 n.succ).get h * k
‚ä¢ multiplicity 2 (x ^ (n + 1) - y ^ (n + 1)) = multiplicity 2 (x - y) + multiplicity 2 ‚Üë(n + 1)","theorem Int.two_pow_sub_pow' {x y : ‚Ñ§} (n : ‚Ñï) (hxy : 4 ‚à£ x - y) (hx : ¬¨2 ‚à£ x) :
    multiplicity 2 (x ^ n - y ^ n) = multiplicity 2 (x - y) + multiplicity (2 : ‚Ñ§) n ",":= by
  have hx_odd : Odd x := by rwa [Int.odd_iff_not_even, even_iff_two_dvd]
  have hxy_even : Even (x - y) := even_iff_two_dvd.mpr (dvd_trans (by decide) hxy)
  have hy_odd : Odd y := by simpa using hx_odd.sub_even hxy_even
  cases' n with n
  ¬∑ simp only [pow_zero, sub_self, multiplicity.zero, Int.ofNat_zero, Nat.zero_eq, add_top]
  have h : (multiplicity 2 n.succ).Dom := multiplicity.finite_nat_iff.mpr ‚ü®by norm_num, n.succ_pos‚ü©
  simp only [Nat.succ_eq_add_one] at h
  rcases multiplicity.eq_coe_iff.mp (PartENat.natCast_get h).symm with ‚ü®‚ü®k, hk‚ü©, hpn‚ü©
  rw [hk, pow_mul, pow_mul, multiplicity.pow_sub_pow_of_prime,
    Int.two_pow_two_pow_sub_pow_two_pow _ hxy hx, ‚Üê hk, PartENat.natCast_get]
  ¬∑ norm_cast
  ¬∑ exact Int.prime_two
  ¬∑ simpa only [even_iff_two_dvd] using hx_odd.pow.sub_odd hy_odd.pow
  ¬∑ simpa only [even_iff_two_dvd, Int.odd_iff_not_even] using hx_odd.pow
  erw [Int.natCast_dvd_natCast]
  contrapose! hpn
  rw [pow_succ]
  conv_rhs => rw [hk]
  exact mul_dvd_mul_left _ hpn"
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,AffineMap.lineMap_rev_mem_affineSpan_pair,AffineMap.lineMap_rev_mem_affineSpan_pair,f27ef6dc0fb66aa1c033b41bb16e840c0a1527a5,":= by
  set_like","error:  unknown tactic
error:  unsolved goals
k : Type u_1
V : Type u_2
P : Type u_3
inst‚úù¬≥ : Ring k
inst‚úù¬≤ : AddCommGroup V
inst‚úù¬π : Module k V
inst‚úù : AffineSpace V P
Œπ : Type u_4
r : k
p‚ÇÅ p‚ÇÇ : P
‚ä¢ (lineMap p‚ÇÇ p‚ÇÅ) r ‚àà affineSpan k {p‚ÇÅ, p‚ÇÇ}
warning:  @AffineSubspace.Parallel does not have a doc string","theorem AffineMap.lineMap_rev_mem_affineSpan_pair (r : k) (p‚ÇÅ p‚ÇÇ : P) :
    AffineMap.lineMap p‚ÇÇ p‚ÇÅ r ‚àà line[k, p‚ÇÅ, p‚ÇÇ] ",":=
  AffineMap.lineMap_mem _ (right_mem_affineSpan_pair _ _ _) (left_mem_affineSpan_pair _ _ _)"
Mathlib/GroupTheory/SpecificGroups/Dihedral.lean,DihedralGroup.orderOf_sr,orderOf_sr,81ba544bf02abe18dd2aecc651188fac71cf454e,":= by
  apply orderOf_eq_prime
  ¬∑ rw [sq, sr_mul_self]
  ¬∑ 
    revert n
    simp_rw [one_def, ne_eq, forall_const]","error:  unsolved goals
case hg1
‚ä¢ ¬¨False",theorem orderOf_sr (i : ZMod n) : orderOf (sr i) = 2 ,":= by
  apply orderOf_eq_prime
  ¬∑ rw [sq, sr_mul_self]
  ¬∑ 
    revert n
    simp_rw [one_def, ne_eq, forall_const, not_false_eq_true]"
Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean,WeierstrassCurve.Jacobian.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,fa6f23d89711db1c90fb4daa7fe13fa411505542,":= by
  rw [fin3_def P, hPz] at hP ‚ä¢
  rw [fin3_def Q, hQz] at hQ ‚ä¢
  simp [nonsingular_iff, equation_iff] at hP hQ
  have hPx : P x ‚â† 0 := fun h => by simp [h] at hP; simp [hP] at hP
  have hQx : Q x ‚â† 0 := fun h => by simp [h] at hQ; simp [hQ] at hQ
  have hPy : P y ‚â† 0 := fun h => by simp [h] at hP; exact hPx <| pow_eq_zero hP.left.symm
  have hQy : Q y ‚â† 0 := fun h => by simp [h] at hQ; exact hQx <| pow_eq_zero hQ.left.symm
  use Units.mk0 _ <| mul_ne_zero (div_ne_zero hPy hPx) (div_ne_zero hQx hQy)
  simp [smul_fin3, mul_pow, div_pow]
  congr! 2
  ¬∑ field_simp [hP.left, hQ.left]
    ring1
  ¬∑ field_simp [‚Üê hP.left, ‚Üê hQ.left]
    ring1","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ![P x, P y, P z]
R : Type u
inst‚úù¬π : CommRing R
W' : Jacobian R
F : Type v
inst‚úù : Field F
W : Jacobian F
P Q : Fin 3 ‚Üí F
hP : W.Nonsingular P
hQ : W.Nonsingular Q
hPz : P z = 0
hQz : Q z = 0
‚ä¢ P ‚âà Q","lemma equiv_of_Z_eq_zero {P Q : Fin 3 ‚Üí F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P ‚âà Q ",":= by
  have hPx : IsUnit <| P x := isUnit_X_of_Z_eq_zero hP hPz
  have hPy : IsUnit <| P y := isUnit_Y_of_Z_eq_zero hP hPz
  have hQx : IsUnit <| Q x := isUnit_X_of_Z_eq_zero hQ hQz
  have hQy : IsUnit <| Q y := isUnit_Y_of_Z_eq_zero hQ hQz
  simp only [nonsingular_of_Z_eq_zero, equation_of_Z_eq_zero, hPz, hQz] at hP hQ
  use (hPy.unit / hPx.unit) * (hQx.unit / hQy.unit)
  simp only [Units.smul_def, smul_fin3, Units.val_mul, Units.val_div_eq_div_val, IsUnit.unit_spec,
    mul_pow, div_pow, hQz, mul_zero]
  conv_rhs => rw [‚Üê fin3_def P, hPz]
  congr! 2
  ¬∑ rw [hP.left, pow_succ, (hPx.pow 2).mul_div_cancel_left, hQ.left, pow_succ _ 2,
      (hQx.pow 2).div_mul_cancel_left, hQx.inv_mul_cancel_right]
  ¬∑ rw [‚Üê hP.left, pow_succ, (hPy.pow 2).mul_div_cancel_left, ‚Üê hQ.left, pow_succ _ 2,
      (hQy.pow 2).div_mul_cancel_left, hQy.inv_mul_cancel_right]"
Mathlib/NumberTheory/Multiplicity.lean,Int.two_pow_sub_pow',Int.two_pow_sub_pow',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have hx_odd : Odd x := by rwa [Int.odd_iff_not_even, even_iff_two_dvd]
  have hxy_even : Even (x - y) := even_iff_two_dvd.mpr (dvd_trans (by decide) hxy)
  have hy_odd : Odd y := by simpa using hx_odd.sub_even hxy_even
  cases' n with n
  ¬∑ simp only [pow_zero, sub_self, multiplicity.zero, Int.ofNat_zero, Nat.zero_eq, add_top]
  have h : (multiplicity 2 n.succ).Dom := multiplicity.finite_nat_iff.mpr ‚ü®by norm_num, n.succ_pos‚ü©
  rcases multiplicity.eq_coe_iff.mp (PartENat.natCast_get h).symm with ‚ü®‚ü®k, hk‚ü©, hpn‚ü©
  rw [hk, pow_mul, pow_mul, multiplicity.pow_sub_pow_of_prime,
    Int.two_pow_two_pow_sub_pow_two_pow _ hxy hx, ‚Üê hk, PartENat.natCast_get]
  ¬∑ norm_cast
  ¬∑ exact Int.prime_two
  ¬∑ simpa only [even_iff_two_dvd] using hx_odd.pow.sub_odd hy_odd.pow
  ¬∑ simpa only [even_iff_two_dvd, Int.odd_iff_not_even] using hx_odd.pow
  erw [Int.natCast_dvd_natCast]
  contrapose! hpn
  rw [pow_succ]
  conv_rhs => rw [hk]
  exact mul_dvd_mul_left _ hpn","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  n.succ
case succ.intro.intro
R : Type u_1
n‚úù : ‚Ñï
x y : ‚Ñ§
hxy : 4 ‚à£ x - y
hx : ¬¨2 ‚à£ x
hx_odd : Odd x
hxy_even : Even (x - y)
hy_odd : Odd y
n : ‚Ñï
h : (multiplicity 2 n.succ).Dom
hpn : ¬¨2 ^ ((multiplicity 2 n.succ).get h + 1) ‚à£ n.succ
k : ‚Ñï
hk : n.succ = 2 ^ (multiplicity 2 n.succ).get h * k
‚ä¢ multiplicity 2 (x ^ (n + 1) - y ^ (n + 1)) = multiplicity 2 (x - y) + multiplicity 2 ‚Üë(n + 1)","theorem Int.two_pow_sub_pow' {x y : ‚Ñ§} (n : ‚Ñï) (hxy : 4 ‚à£ x - y) (hx : ¬¨2 ‚à£ x) :
    multiplicity 2 (x ^ n - y ^ n) = multiplicity 2 (x - y) + multiplicity (2 : ‚Ñ§) n ",":= by
  have hx_odd : Odd x := by rwa [Int.odd_iff_not_even, even_iff_two_dvd]
  have hxy_even : Even (x - y) := even_iff_two_dvd.mpr (dvd_trans (by decide) hxy)
  have hy_odd : Odd y := by simpa using hx_odd.sub_even hxy_even
  cases' n with n
  ¬∑ simp only [pow_zero, sub_self, multiplicity.zero, Int.ofNat_zero, Nat.zero_eq, add_top]
  have h : (multiplicity 2 n.succ).Dom := multiplicity.finite_nat_iff.mpr ‚ü®by norm_num, n.succ_pos‚ü©
  simp only [Nat.succ_eq_add_one] at h
  rcases multiplicity.eq_coe_iff.mp (PartENat.natCast_get h).symm with ‚ü®‚ü®k, hk‚ü©, hpn‚ü©
  rw [hk, pow_mul, pow_mul, multiplicity.pow_sub_pow_of_prime,
    Int.two_pow_two_pow_sub_pow_two_pow _ hxy hx, ‚Üê hk, PartENat.natCast_get]
  ¬∑ norm_cast
  ¬∑ exact Int.prime_two
  ¬∑ simpa only [even_iff_two_dvd] using hx_odd.pow.sub_odd hy_odd.pow
  ¬∑ simpa only [even_iff_two_dvd, Int.odd_iff_not_even] using hx_odd.pow
  erw [Int.natCast_dvd_natCast]
  contrapose! hpn
  rw [pow_succ]
  conv_rhs => rw [hk]
  exact mul_dvd_mul_left _ hpn"
Mathlib/Computability/TuringMachine.lean,Turing.TM2to1.tr_respects_aux‚ÇÇ,tr_respects_aux‚ÇÇ,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  dsimp only; simp; cases o with simp only [stWrite, stVar, trStAct, TM1.stepAux]
  | push f =>
    have := Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k (some (f v)))
    refine'
      ‚ü®_, fun k' ‚Ü¶ _, by
        erw [Tape.move_right_n_head, List.length, Tape.mk'_nth_nat, this,
          addBottom_modifyNth fun a ‚Ü¶ update a k (some (f v)), Nat.add_one, iterate_succ']
        rfl‚ü©
    refine' ListBlank.ext fun i ‚Ü¶ _
    rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
    by_cases h' : k' = k
    ¬∑ subst k'
      split_ifs with h
        <;> simp only [List.reverse_cons, Function.update_same, ListBlank.nth_mk, List.map]
      ¬∑ rw [List.getI_eq_get, List.get_append_right'] <;>
          simp only [h, List.get_singleton, List.length_map, List.length_reverse, Nat.succ_pos',
            List.length_append, lt_add_iff_pos_right, List.length, le_refl]
      rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk]
      cases' lt_or_gt_of_ne h with h h
      ¬∑ rw [List.getI_append]
        simpa only [List.length_map, List.length_reverse] using h
      ¬∑ rw [gt_iff_lt] at h
        rw [List.getI_eq_default, List.getI_eq_default] <;>
          simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
            List.length_append, List.length_map]
    ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
      rw [Function.update_noteq h']
  | peek f =>
    rw [Function.update_eq_self]
    use L, hL; rw [Tape.move_left_right]; congr
    cases e : S k; ¬∑ rfl
    rw [List.length_cons, iterate_succ', Function.comp, Tape.move_right_left,
      Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_snd, stk_nth_val _ (hL k), e,
      List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length]
    rfl
  | pop f =>
    cases' e : S k with hd tl
    ¬∑ simp only [Tape.mk'_head, ListBlank.head_cons, Tape.move_left_mk', List.length,
        Tape.write_mk', List.head?, iterate_zero_apply, List.tail_nil]
      rw [‚Üê e, Function.update_eq_self]
      exact ‚ü®L, hL, by rw [addBottom_head_fst, cond]‚ü©
    ¬∑ refine'
        ‚ü®_, fun k' ‚Ü¶ _, by
          erw [List.length_cons, Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_succ_fst,
            cond, iterate_succ', Function.comp, Tape.move_right_left, Tape.move_right_n_head,
            Tape.mk'_nth_nat, Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k none),
            addBottom_modifyNth fun a ‚Ü¶ update a k none, addBottom_nth_snd,
            stk_nth_val _ (hL k), e,
            show (List.cons hd tl).reverse.get? tl.length = some hd by
              rw [List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length],
            List.head?, List.tail]‚ü©
      refine' ListBlank.ext fun i ‚Ü¶ _
      rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
      by_cases h' : k' = k
      ¬∑ subst k'
        split_ifs with h <;> simp only [Function.update_same, ListBlank.nth_mk, List.tail]
        ¬∑ rw [List.getI_eq_default]
          ¬∑ rfl
          rw [h, List.length_reverse, List.length_map]
        rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk, e, List.map, List.reverse_cons]
        cases' lt_or_gt_of_ne h with h h
        ¬∑ rw [List.getI_append]
          simpa only [List.length_map, List.length_reverse] using h
        ¬∑ rw [gt_iff_lt] at h
          rw [List.getI_eq_default, List.getI_eq_default] <;>
            simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
              List.length_append, List.length_map]
      ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
        rw [Function.update_noteq h']","warning:  `List.get_append` has been deprecated, use `List.getElem_append` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get_replicate` has been deprecated, use `List.getElem_replicate` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  unused variable `M`
note: this linter can be disabled with `set_option linter.unusedVariables false`
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
error:  unsolved goals
case pos.h‚ÇÇ
K : Type u_1
inst‚úù¬≤ : DecidableEq K
Œì : K ‚Üí Type u_2
Œõ : Type u_3
inst‚úù¬π : Inhabited Œõ
œÉ : Type u_4
inst‚úù : Inhabited œÉ
k : K
q : TM1.Stmt Œì' Œõ' œÉ
v : œÉ
S : (k : K) ‚Üí List (Œì k)
L : ListBlank ((k : K) ‚Üí Option (Œì k))
hL : ‚àÄ (k : K), ListBlank.map (proj k) L = ListBlank.mk (List.map some (S k)).reverse
f : œÉ ‚Üí Œì k
this :
  ‚àÄ (L R : ListBlank Œì') (n : ‚Ñï),
    Tape.write ((R.nth n).1, update (R.nth n).2 k (some (f v))) ((Tape.move Dir.right)^[n] (Tape.mk' L R)) =
      (Tape.move Dir.right)^[n] (Tape.mk' L (ListBlank.modifyNth (fun a ‚Ü¶ (a.1, update a.2 k (some (f v)))) n R))
i : ‚Ñï
h : i = (S k).length
‚ä¢ (S k).length < (S k).length + (0 + 1)
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead","theorem tr_respects_aux‚ÇÇ {k : K} {q : Stmt‚ÇÇ‚ÇÅ} {v : œÉ} {S : ‚àÄ k, List (Œì k)}
    {L : ListBlank (‚àÄ k, Option (Œì k))}
    (hL : ‚àÄ k, L.map (proj k) = ListBlank.mk ((S k).map some).reverse) (o : StAct‚ÇÇ k) :
    let v' := stVar v (S k) o
    let Sk' := stWrite v (S k) o
    let S' := update S k Sk'
    ‚àÉ L' : ListBlank (‚àÄ k, Option (Œì k)),
      (‚àÄ k, L'.map (proj k) = ListBlank.mk ((S' k).map some).reverse) ‚àß
        TM1.stepAux (trStAct q o) v
            ((Tape.move Dir.right)^[(S k).length] (Tape.mk' ‚àÖ (addBottom L))) =
          TM1.stepAux q v' ((Tape.move Dir.right)^[(S' k).length] (Tape.mk' ‚àÖ (addBottom L'))) ",":= by
  dsimp only; simp; cases o with simp only [stWrite, stVar, trStAct, TM1.stepAux]
  | push f =>
    have := Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k (some (f v)))
    refine
      ‚ü®_, fun k' ‚Ü¶ ?_, by
        erw [Tape.move_right_n_head, List.length, Tape.mk'_nth_nat, this,
          addBottom_modifyNth fun a ‚Ü¶ update a k (some (f v)), Nat.add_one, iterate_succ']
        rfl‚ü©
    refine ListBlank.ext fun i ‚Ü¶ ?_
    rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
    by_cases h' : k' = k
    ¬∑ subst k'
      split_ifs with h
        <;> simp only [List.reverse_cons, Function.update_same, ListBlank.nth_mk, List.map]
      ¬∑ rw [List.getI_eq_get, List.get_append_right'] <;>
          simp only [List.length_singleton, h, List.length_reverse, List.length_map, Nat.sub_self,
            Fin.zero_eta, List.get_cons_zero, le_refl, List.length_append, Nat.lt_succ_self]
      rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk]
      cases' lt_or_gt_of_ne h with h h
      ¬∑ rw [List.getI_append]
        simpa only [List.length_map, List.length_reverse] using h
      ¬∑ rw [gt_iff_lt] at h
        rw [List.getI_eq_default, List.getI_eq_default] <;>
          simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
            List.length_append, List.length_map]
    ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
      rw [Function.update_noteq h']
  | peek f =>
    rw [Function.update_eq_self]
    use L, hL; rw [Tape.move_left_right]; congr
    cases e : S k; ¬∑ rfl
    rw [List.length_cons, iterate_succ', Function.comp, Tape.move_right_left,
      Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_snd, stk_nth_val _ (hL k), e,
      List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length]
    rfl
  | pop f =>
    cases' e : S k with hd tl
    ¬∑ simp only [Tape.mk'_head, ListBlank.head_cons, Tape.move_left_mk', List.length,
        Tape.write_mk', List.head?, iterate_zero_apply, List.tail_nil]
      rw [‚Üê e, Function.update_eq_self]
      exact ‚ü®L, hL, by rw [addBottom_head_fst, cond]‚ü©
    ¬∑ refine
        ‚ü®_, fun k' ‚Ü¶ ?_, by
          erw [List.length_cons, Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_succ_fst,
            cond, iterate_succ', Function.comp, Tape.move_right_left, Tape.move_right_n_head,
            Tape.mk'_nth_nat, Tape.write_move_right_n fun a : Œì' ‚Ü¶ (a.1, update a.2 k none),
            addBottom_modifyNth fun a ‚Ü¶ update a k none, addBottom_nth_snd,
            stk_nth_val _ (hL k), e,
            show (List.cons hd tl).reverse.get? tl.length = some hd by
              rw [List.reverse_cons, ‚Üê List.length_reverse, List.get?_concat_length],
            List.head?, List.tail]‚ü©
      refine ListBlank.ext fun i ‚Ü¶ ?_
      rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
      by_cases h' : k' = k
      ¬∑ subst k'
        split_ifs with h <;> simp only [Function.update_same, ListBlank.nth_mk, List.tail]
        ¬∑ rw [List.getI_eq_default]
          ¬∑ rfl
          rw [h, List.length_reverse, List.length_map]
        rw [‚Üê proj_map_nth, hL, ListBlank.nth_mk, e, List.map, List.reverse_cons]
        cases' lt_or_gt_of_ne h with h h
        ¬∑ rw [List.getI_append]
          simpa only [List.length_map, List.length_reverse] using h
        ¬∑ rw [gt_iff_lt] at h
          rw [List.getI_eq_default, List.getI_eq_default] <;>
            simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
              List.length_append, List.length_map]
      ¬∑ split_ifs <;> rw [Function.update_noteq h', ‚Üê proj_map_nth, hL]
        rw [Function.update_noteq h']"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/AlgebraicGeometry/GammaSpecAdjunction.lean,AlgebraicGeometry.LocallyRingedSpace.toŒìSpecMapBasicOpen_eq,toŒìSpecMapBasicOpen_eq,cc927b7a2c044a18b803345ec4455b6c0b09ced0,":=
  Opens.ext (X.to_Œì_Spec_preim_basicOpen_eq r)","error:  invalid field 'to_Œì_Spec_preim_basicOpen_eq', the environment does not contain 'AlgebraicGeometry.LocallyRingedSpace.to_Œì_Spec_preim_basicOpen_eq'
  X
has type
  LocallyRingedSpace",theorem toŒìSpecMapBasicOpen_eq : X.toŒìSpecMapBasicOpen r = X.toRingedSpace.basicOpen r ,":=
  Opens.ext (X.toŒìSpec_preim_basicOpen_eq r)"
Mathlib/Analysis/Complex/RealDeriv.lean,HasDerivAt.real_of_complex,HasDerivAt.real_of_complex,01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  have A : HasFDerivAt ((‚Üë) : ‚Ñù ‚Üí ‚ÑÇ) ofRealClm z := ofRealClm.hasFDerivAt
  have B :
    HasFDerivAt e ((ContinuousLinearMap.smulRight 1 e' : ‚ÑÇ ‚ÜíL[‚ÑÇ] ‚ÑÇ).restrictScalars ‚Ñù)
      (ofRealClm z) :=
    h.hasFDerivAt.restrictScalars ‚Ñù
  have C : HasFDerivAt re reClm (e (ofRealClm z)) := reClm.hasFDerivAt
  convert (C.comp z (B.comp z A)).hasDerivAt
  rw [ContinuousLinearMap.comp_apply, ContinuousLinearMap.comp_apply]
  simp","error:  unknown identifier 'ofRealClm'
error:  unknown identifier 'ofRealClm.hasFDerivAt'
error:  unsolved goals
e : ‚ÑÇ ‚Üí ‚ÑÇ
e' : ‚ÑÇ
z : ‚Ñù
h : HasDerivAt e e' ‚Üëz
‚ä¢ HasDerivAt (fun x ‚Ü¶ (e ‚Üëx).re) e'.re z","theorem HasDerivAt.real_of_complex (h : HasDerivAt e e' z) :
    HasDerivAt (fun x : ‚Ñù => (e x).re) e'.re z ",":= by
  have A : HasFDerivAt ((‚Üë) : ‚Ñù ‚Üí ‚ÑÇ) ofRealCLM z := ofRealCLM.hasFDerivAt
  have B :
    HasFDerivAt e ((ContinuousLinearMap.smulRight 1 e' : ‚ÑÇ ‚ÜíL[‚ÑÇ] ‚ÑÇ).restrictScalars ‚Ñù)
      (ofRealCLM z) :=
    h.hasFDerivAt.restrictScalars ‚Ñù
  have C : HasFDerivAt re reCLM (e (ofRealCLM z)) := reCLM.hasFDerivAt
  convert (C.comp z (B.comp z A)).hasDerivAt
  rw [ContinuousLinearMap.comp_apply, ContinuousLinearMap.comp_apply]
  simp"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a
  exact ‚ü®_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b
  exact ‚ü®_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.closed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x
    ¬∑ intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine' ‚ü®g + dg, fun y => _, funext hgf‚ü©
    ¬∑ have hay : a < (g + dg) y := by
        rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
        ¬∑ refine' (lt_add_iff_pos_right _).2 _
          calc
            0 < c - g y := sub_pos.2 hac
            _ = dg y := (dga rfl).symm
        ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      refine' ‚ü®x, hxy.le, _‚ü©
      cases' le_total c (g y) with hc hc
      ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
      ¬∑ calc
          g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
          _ = b := by rw [hsub, add_sub_cancel'_right]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.closed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x
  ¬∑ intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine' ‚ü®g - dg, fun y => _, funext hgf‚ü©
  ¬∑ have hyb : (g - dg) y < b := by
      rcases (hgb y).eq_or_lt with (rfl | hlt)
      ¬∑ refine' (sub_lt_self_iff _).2 _
        calc
          0 < g y - c := sub_pos.2 hcb
          _ = dg y := (dgb rfl).symm
      ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
    rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
    cases' lt_or_le c (g y) with hc hc
    ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
      ¬∑ refine' ‚ü®x, xu, _, hyxu.le‚ü©
        calc
          f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
      ¬∑ have hay : a < (g - dg) y := by
          calc
            a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
            _ < g y - (b - c) := (sub_lt_sub_right hc _)
            _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
        rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
        exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
    ¬∑ refine' ‚ü®xl y, xu, _, hyxu.le‚ü©
      simp [dg0 (Or.inr hc), hxl]","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case intro.intro.inr.intro.intro.intro
X : Type u_1
Y : Type u_2
inst‚úù¬≥ : TopologicalSpace X
inst‚úù¬≤ : TopologicalSpace Y
inst‚úù¬π : NormalSpace Y
inst‚úù : Nonempty X
f : X ‚Üí·µá ‚Ñù
e : X ‚Üí Y
he : ClosedEmbedding e
inhabited_h : Inhabited X
a : ‚Ñù
ha : IsGLB (range ‚áëf) a
b : ‚Ñù
hb : IsLUB (range ‚áëf) b
hmem : ‚àÄ (x : X), f x ‚àà Icc a b
hle : a ‚â§ b
hlt : a < b
c : ‚Ñù := (a + b) / 2
hac : a < c
hcb : c < b
hsub : c - a = b - c
g : Y ‚Üí·µá ‚Ñù
hg_mem : ‚àÄ (y : Y), g y ‚àà Icc a b
ha' : ¬¨‚àÉ x, f x = a
hd : Disjoint (range e ‚à™ ‚áëg ‚Åª¬π' Ici c) (‚áëg ‚Åª¬π' {a})
dg : Y ‚Üí·µá ‚Ñù
dg0 : EqOn (‚áëdg) (Function.const Y 0) (range e ‚à™ ‚áëg ‚Åª¬π' Ici c)
dga : EqOn (‚áëdg) (Function.const Y (c - a)) (‚áëg ‚Åª¬π' {a})
dgmem : ‚àÄ (x : Y), dg x ‚àà Icc 0 (c - a)
hgf : ‚àÄ (x : X), (g + dg) (e x) = f x
‚ä¢ ‚àÉ g, (‚àÄ (y : Y), ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß ‚áëg ‚àò e = ‚áëf
error:  unsolved goals
case intro.intro.inr.intro.intro
X : Type u_1
Y : Type u_2
inst‚úù¬≥ : TopologicalSpace X
inst‚úù¬≤ : TopologicalSpace Y
inst‚úù¬π : NormalSpace Y
inst‚úù : Nonempty X
f : X ‚Üí·µá ‚Ñù
e : X ‚Üí Y
he : ClosedEmbedding e
inhabited_h : Inhabited X
a : ‚Ñù
ha : IsGLB (range ‚áëf) a
b : ‚Ñù
hb : IsLUB (range ‚áëf) b
hmem : ‚àÄ (x : X), f x ‚àà Icc a b
hle : a ‚â§ b
hlt : a < b
c : ‚Ñù := (a + b) / 2
hac : a < c
hcb : c < b
hsub : c - a = b - c
g : Y ‚Üí·µá ‚Ñù
hg_mem : ‚àÄ (y : Y), ‚àÉ x, g y ‚àà Icc (f x) b
hgf : ‚áëg ‚àò e = ‚áëf
‚ä¢ ‚àÉ g, (‚àÄ (y : Y), ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß ‚áëg ‚àò e = ‚áëf","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/MeasureTheory/Measure/Haar/Basic.lean,MeasureTheory.Measure.div_mem_nhds_one_of_haar_pos,div_mem_nhds_one_of_haar_pos,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  obtain ‚ü®K, hKE, hK, K_closed, hKpos‚ü© :
      ‚àÉ (K : Set G), K ‚äÜ E ‚àß IsCompact K ‚àß IsClosed K ‚àß 0 < Œº K := by
    rcases MeasurableSet.exists_lt_isCompact hE hEpos with ‚ü®K, KE, K_comp, K_meas‚ü©
    refine ‚ü®closure K, ?_, K_comp.closure, isClosed_closure, ?_‚ü©
    ¬∑ exact IsCompact.closure_subset_of_measurableSet_of_group K_comp hE KE
    ¬∑ rwa [K_comp.measure_closure_eq_of_group]
  obtain ‚ü®U, hUK, hU, hŒºUK‚ü© : ‚àÉ (U : Set G), K ‚äÜ U ‚àß IsOpen U ‚àß Œº U < Œº K + Œº K :=
    hK.exists_isOpen_lt_add hKpos.ne'
  obtain ‚ü®V, hV1, hVKU‚ü© : ‚àÉ V ‚àà ùìù (1 : G), V * K ‚äÜ U :=
    compact_open_separated_mul_left hK hU hUK
  have hv : ‚àÄ v : G, v ‚àà V ‚Üí ¬¨Disjoint ({v} * K) K := by
    intro v hv hKv
    have hKvsub : {v} * K ‚à™ K ‚äÜ U := by
      apply Set.union_subset _ hUK
      apply _root_.subset_trans _ hVKU
      apply Set.mul_subset_mul _ (Set.Subset.refl K)
      simp only [Set.singleton_subset_iff, hv]
    replace hKvsub := @measure_mono _ _ Œº _ _ hKvsub
    have hcontr := lt_of_le_of_lt hKvsub hŒºUK
    rw [measure_union hKv K_closed.measurableSet] at hcontr
    have hKtranslate : Œº ({v} * K) = Œº K := by
      simp only [singleton_mul, image_mul_left, measure_preimage_mul]
    rw [hKtranslate, lt_self_iff_false] at hcontr
    assumption
  suffices V ‚äÜ E / E from Filter.mem_of_superset hV1 this
  intro v hvV
  obtain ‚ü®x, hxK, hxvK‚ü© : ‚àÉ x : G, x ‚àà {v} * K ‚àß x ‚àà K := Set.not_disjoint_iff.1 (hv v hvV)
  refine ‚ü®x, hKE hxvK, v‚Åª¬π * x, hKE ?_, ?_‚ü©
  ¬∑ simpa only [singleton_mul, image_mul_left, mem_preimage] using hxK
  ¬∑ simp only [div_eq_iff_eq_mul, ‚Üê mul_assoc, mul_right_inv, one_mul]","warning:  `IsCompact.closure_subset_of_measurableSet_of_group` has been deprecated, use `IsCompact.closure_subset_measurableSet` instead
warning:  `IsCompact.measure_closure_eq_of_group` has been deprecated, use `IsCompact.measure_closure` instead
error:  application type mismatch
  @measure_mono ?m.115970 ?m.115971 Œº
argument
  Œº
has type
  Measure G : Type u_1
but is expected to have type
  FunLike ?m.115971 (Set ?m.115970) ‚Ñù‚â•0‚àû : Type (max (max ?u.115968 ?u.115969) 0)","theorem div_mem_nhds_one_of_haar_pos (Œº : Measure G) [IsHaarMeasure Œº] [LocallyCompactSpace G]
    [InnerRegular Œº] (E : Set G) (hE : MeasurableSet E) (hEpos : 0 < Œº E) :
    E / E ‚àà ùìù (1 : G) ",":= by
  obtain ‚ü®K, hKE, hK, K_closed, hKpos‚ü© :
      ‚àÉ (K : Set G), K ‚äÜ E ‚àß IsCompact K ‚àß IsClosed K ‚àß 0 < Œº K := by
    rcases MeasurableSet.exists_lt_isCompact hE hEpos with ‚ü®K, KE, K_comp, K_meas‚ü©
    refine ‚ü®closure K, ?_, K_comp.closure, isClosed_closure, ?_‚ü©
    ¬∑ exact K_comp.closure_subset_measurableSet hE KE
    ¬∑ rwa [K_comp.measure_closure]
  filter_upwards [eventually_nhds_one_measure_smul_diff_lt hK K_closed hKpos.ne' (Œº := Œº)] with g hg
  have : ¬¨Disjoint (g ‚Ä¢ K) K := fun hd ‚Ü¶ by
    rw [hd.symm.sdiff_eq_right, measure_smul] at hg
    exact hg.false
  rcases Set.not_disjoint_iff.1 this with ‚ü®_, ‚ü®x, hxK, rfl‚ü©, hgxK‚ü©
  simpa using div_mem_div (hKE hgxK) (hKE hxK)"
Mathlib/Analysis/Normed/Field/Basic.lean,nnnorm_pow_le,nnnorm_pow_le,61ddcfa78d90f5773ac5739822ee3721851aa662,"  | 1, _ => by simp only [pow_one, le_rfl]
  | n + 2, _ => by
    simpa only [pow_succ _ (n + 1)] using
      le_trans (nnnorm_mul_le _ _) (mul_le_mul_left' (nnnorm_pow_le' a n.succ_pos) _)","error:  type mismatch
  h‚úù
has type
  ‚Äña ^ (n + 1) * a ^ n.succ‚Äñ‚Çä ‚â§ ‚Äña ^ (n + 1)‚Äñ‚Çä * ‚Äña‚Äñ‚Çä ^ n.succ : Prop
but is expected to have type
  ‚Äña ^ (n + 1) * a‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä ^ (n + 1) * ‚Äña‚Äñ‚Çä : Prop","theorem nnnorm_pow_le' (a : Œ±) : ‚àÄ {n : ‚Ñï}, 0 < n ‚Üí ‚Äña ^ n‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä ^ n
","  | 1, _ => by simp only [pow_one, le_rfl]
  | n + 2, _ => by
    simpa only [pow_succ' _ (n + 1)] using
      le_trans (nnnorm_mul_le _ _) (mul_le_mul_left' (nnnorm_pow_le' a n.succ_pos) _)"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,b0906f1a9f950f5731cad2defb88e9843a7e3fc9,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean,Complex.differentiable_one_div_Gamma,differentiable_one_div_Gamma,01d739c14a27d96463129c57bbb1982309f33ea6,":= fun s ‚Ü¶ by
  rcases exists_nat_gt (-s.re) with ‚ü®n, hs‚ü©
  induction n generalizing s with
  | zero =>
    rw [Nat.cast_zero, neg_lt_zero] at hs
    suffices : ‚àÄ m : ‚Ñï, s ‚â† -‚Üëm; exact (differentiableAt_Gamma _ this).inv (Gamma_ne_zero this)
    rintro m rfl
    apply hs.not_le
    simp
  | succ n ihn =>
    rw [funext one_div_Gamma_eq_self_mul_one_div_Gamma_add_one]
    specialize ihn (s + 1) (by rwa [add_re, one_re, neg_add', sub_lt_iff_lt_add, ‚Üê Nat.cast_succ])
    exact differentiableAt_id.mul (ihn.comp s <| differentiableAt_id.add_const _)",error:  unexpected token ':'; expected term,theorem differentiable_one_div_Gamma : Differentiable ‚ÑÇ fun s : ‚ÑÇ => (Gamma s)‚Åª¬π ,":= fun s ‚Ü¶ by
  rcases exists_nat_gt (-s.re) with ‚ü®n, hs‚ü©
  induction n generalizing s with
  | zero =>
    rw [Nat.cast_zero, neg_lt_zero] at hs
    suffices ‚àÄ m : ‚Ñï, s ‚â† -‚Üëm from (differentiableAt_Gamma _ this).inv (Gamma_ne_zero this)
    rintro m rfl
    apply hs.not_le
    simp
  | succ n ihn =>
    rw [funext one_div_Gamma_eq_self_mul_one_div_Gamma_add_one]
    specialize ihn (s + 1) (by rwa [add_re, one_re, neg_add', sub_lt_iff_lt_add, ‚Üê Nat.cast_succ])
    exact differentiableAt_id.mul (ihn.comp s <| differentiableAt_id.add_const _)"
Mathlib/Analysis/Convex/Combination.lean,Set.Finite.convexHull_eq_image,Set.Finite.convexHull_eq_image,9f6d33884de569540c527b667d1573e1b97e1347,":= by
  rw [‚Üê @convexHull_basis_eq_stdSimplex _ _ _ hs.fintype, ‚Üê LinearMap.convexHull_image,
    ‚Üê Set.range_comp]
  simp_rw [Function.comp]
  apply congr_arg
  convert Subtype.range_coe.symm
  simp [LinearMap.sum_apply, ite_smul _ (1 : R), Finset.filter_eq,
    @Finset.mem_univ _ hs.fintype _]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.568559 ‚Üí+* ?m.568560) ‚Üí
    (M : Type ?u.568556) ‚Üí
      (M‚ÇÇ : Type ?u.568555) ‚Üí
        [inst : AddCommMonoid M] ‚Üí
          [inst_1 : AddCommMonoid M‚ÇÇ] ‚Üí
            [inst : Module ?m.568559 M] ‚Üí [inst : Module ?m.568560 M‚ÇÇ] ‚Üí Type (max ?u.568556 ?u.568555)
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.568628
R : Type u_1
R' : Type u_2
E : Type u_3
F : Type u_4
Œπ : Type u_5
Œπ' : Type u_6
Œ± : Type u_7
inst‚úù‚Åπ : LinearOrderedField R
inst‚úù‚Å∏ : LinearOrderedField R'
inst‚úù‚Å∑ : AddCommGroup E
inst‚úù‚Å∂ : AddCommGroup F
inst‚úù‚Åµ : LinearOrderedAddCommGroup Œ±
inst‚úù‚Å¥ : Module R E
inst‚úù¬≥ : Module R F
inst‚úù¬≤ : Module R Œ±
inst‚úù¬π : OrderedSMul R Œ±
s‚úù : Set E
i j : Œπ
c : R
t : Finset Œπ
w : Œπ ‚Üí R
z : Œπ ‚Üí E
inst‚úù : Fintype Œπ
f : Œπ ‚Üí R
s : Set E
hs : s.Finite
‚ä¢ (convexHull R) s =
    ‚áë(‚àë x : ‚Üës, (LinearMap.proj x).smulRight ‚Üëx) '' (convexHull R) (range fun i j ‚Ü¶ if i = j then 1 else 0)","theorem Set.Finite.convexHull_eq_image {s : Set E} (hs : s.Finite) : convexHull R s =
    haveI := hs.fintype
    (‚áë(‚àë x : s, (@LinearMap.proj R s _ (fun _ => R) _ _ x).smulRight x.1)) '' stdSimplex R s ",":= by
  letI := hs.fintype
  rw [‚Üê convexHull_basis_eq_stdSimplex, LinearMap.image_convexHull, ‚Üê Set.range_comp]
  apply congr_arg
  simp_rw [Function.comp]
  convert Subtype.range_coe.symm
  simp [LinearMap.sum_apply, ite_smul, Finset.filter_eq, Finset.mem_univ]"
Mathlib/Algebra/Group/Semiconj/Units.lean,SemiconjBy.units_zpow_right,units_zpow_right,c2d2bf7e3c17a8505a5d9206327d2cd9b9b50229,"  | (n : ‚Ñï) => by simp only [zpow_coe_nat, Units.val_pow_eq_pow_val, h, pow_right]
  | -[n+1] => by simp only [zpow_negSucc, Units.val_pow_eq_pow_val, units_inv_right, h, pow_right]","warning:  `zpow_coe_nat` has been deprecated, use `zpow_natCast` instead
error:  application type mismatch
  zpow_coe_nat
argument has type
  SubNegMonoid (AddUnits M)
but function has type
  ‚àÄ [inst : DivInvMonoid (AddUnits M)] (a : AddUnits M) (n : ‚Ñï), a ^ ‚Üën = a ^ n","lemma units_zpow_right {a : M} {x y : MÀ£} (h : SemiconjBy a x y) :
    ‚àÄ m : ‚Ñ§, SemiconjBy a ‚Üë(x ^ m) ‚Üë(y ^ m)
","  | (n : ‚Ñï) => by simp only [zpow_natCast, Units.val_pow_eq_pow_val, h, pow_right]
  | -[n+1] => by simp only [zpow_negSucc, Units.val_pow_eq_pow_val, units_inv_right, h, pow_right]"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.ae_tendsto_lintegral_nnnorm_sub_div,ae_tendsto_lintegral_nnnorm_sub_div,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  let A := MeasureTheory.Measure.finiteSpanningSetsInOpen' Œº
  rcases h'f.isSeparable_range with ‚ü®t, t_count, ht‚ü©
  have main :
    ‚àÄ·µê x ‚àÇŒº,
      ‚àÄ·µâ (n : ‚Ñï) (c ‚àà t),
        Tendsto (fun a => (‚à´‚Åª y in a, ‚Äñf y - (A.set n).indicator (fun _ => c) y‚Äñ‚Çä ‚àÇŒº) / Œº a)
          (v.filterAt x) (ùìù ‚Äñf x - (A.set n).indicator (fun _ => c) x‚Äñ‚Çä) := by
    simp_rw [ae_all_iff, ae_ball_iff t_count]
    intro n c _
    apply ae_tendsto_lintegral_div'
    ¬∑ refine' (h'f.sub _).ennnorm
      exact stronglyMeasurable_const.indicator (IsOpen.measurableSet (A.set_mem n))
    ¬∑ apply ne_of_lt
      calc
        (‚à´‚Åª y, ‚Üë‚Äñf y - (A.set n).indicator (fun _ : Œ± => c) y‚Äñ‚Çä ‚àÇŒº) ‚â§
            ‚à´‚Åª y, ‚Äñf y‚Äñ‚Çä + ‚Äñ(A.set n).indicator (fun _ : Œ± => c) y‚Äñ‚Çä ‚àÇŒº := by
          apply lintegral_mono
          intro x
          dsimp
          rw [‚Üê ENNReal.coe_add]
          exact ENNReal.coe_le_coe.2 (nnnorm_sub_le _ _)
        _ = (‚à´‚Åª y, ‚Äñf y‚Äñ‚Çä ‚àÇŒº) + ‚à´‚Åª y, ‚Äñ(A.set n).indicator (fun _ : Œ± => c) y‚Äñ‚Çä ‚àÇŒº :=
          (lintegral_add_left h'f.ennnorm _)
        _ < ‚àû + ‚àû :=
          haveI I : Integrable ((A.set n).indicator fun _ : Œ± => c) Œº := by
            simp only [integrable_indicator_iff (IsOpen.measurableSet (A.set_mem n)),
              integrableOn_const, A.finite n, or_true_iff]
          ENNReal.add_lt_add hf.2 I.2
  filter_upwards [main, v.ae_eventually_measure_pos] with x hx h'x
  have M :
    ‚àÄ c ‚àà t, Tendsto (fun a => (‚à´‚Åª y in a, ‚Äñf y - c‚Äñ‚Çä ‚àÇŒº) / Œº a)
      (v.filterAt x) (ùìù ‚Äñf x - c‚Äñ‚Çä) := by
    intro c hc
    obtain ‚ü®n, xn‚ü© : ‚àÉ n, x ‚àà A.set n := by simpa [‚Üê A.spanning] using mem_univ x
    specialize hx n c hc
    simp only [xn, indicator_of_mem] at hx
    apply hx.congr' _
    filter_upwards [v.eventually_filterAt_subset_of_nhds (IsOpen.mem_nhds (A.set_mem n) xn),
      v.eventually_filterAt_measurableSet x] with a ha h'a
    congr 1
    apply set_lintegral_congr_fun h'a
    filter_upwards with y hy using (by simp only [ha hy, indicator_of_mem])
  apply ENNReal.tendsto_nhds_zero.2 fun Œµ Œµpos => ?_
  obtain ‚ü®c, ct, xc‚ü© : ‚àÉ c ‚àà t, (‚Äñf x - c‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < Œµ / 2 := by
    simp_rw [‚Üê edist_eq_coe_nnnorm_sub]
    have : f x ‚àà closure t := ht (mem_range_self _)
    exact EMetric.mem_closure_iff.1 this (Œµ / 2) (ENNReal.half_pos (ne_of_gt Œµpos))
  filter_upwards [(tendsto_order.1 (M c ct)).2 (Œµ / 2) xc, h'x, v.eventually_measure_lt_top x] with
    a ha h'a h''a
  apply ENNReal.div_le_of_le_mul
  calc
    (‚à´‚Åª y in a, ‚Äñf y - f x‚Äñ‚Çä ‚àÇŒº) ‚â§ ‚à´‚Åª y in a, ‚Äñf y - c‚Äñ‚Çä + ‚Äñf x - c‚Äñ‚Çä ‚àÇŒº := by
      apply lintegral_mono fun x => ?_
      simpa only [‚Üê edist_eq_coe_nnnorm_sub] using edist_triangle_right _ _ _
    _ = (‚à´‚Åª y in a, ‚Äñf y - c‚Äñ‚Çä ‚àÇŒº) + ‚à´‚Åª _ in a, ‚Äñf x - c‚Äñ‚Çä ‚àÇŒº :=
      (lintegral_add_right _ measurable_const)
    _ ‚â§ Œµ / 2 * Œº a + Œµ / 2 * Œº a := by
      gcongr
      ¬∑ rw [ENNReal.div_lt_iff (Or.inl h'a.ne') (Or.inl h''a.ne)] at ha
        exact ha.le
      ¬∑ simp only [lintegral_const, Measure.restrict_apply, MeasurableSet.univ, univ_inter]
        gcongr
    _ = Œµ * Œº a := by rw [‚Üê add_mul, ENNReal.add_halves]","error:  simp made no progress
warning:  `MeasureTheory.set_lintegral_congr_fun` has been deprecated, use `MeasureTheory.setLIntegral_congr_fun` instead","theorem ae_tendsto_lintegral_nnnorm_sub_div'_of_integrable {f : Œ± ‚Üí E} (hf : Integrable f Œº)
    (h'f : StronglyMeasurable f) :
    ‚àÄ·µê x ‚àÇŒº, Tendsto (fun a => (‚à´‚Åª y in a, ‚Äñf y - f x‚Äñ‚Çä ‚àÇŒº) / Œº a) (v.filterAt x) (ùìù 0) ",":= by
  let A := MeasureTheory.Measure.finiteSpanningSetsInOpen' Œº
  rcases h'f.isSeparable_range with ‚ü®t, t_count, ht‚ü©
  have main :
    ‚àÄ·µê x ‚àÇŒº,
      ‚àÄ·µâ (n : ‚Ñï) (c ‚àà t),
        Tendsto (fun a => (‚à´‚Åª y in a, ‚Äñf y - (A.set n).indicator (fun _ => c) y‚Äñ‚Çä ‚àÇŒº) / Œº a)
          (v.filterAt x) (ùìù ‚Äñf x - (A.set n).indicator (fun _ => c) x‚Äñ‚Çä) := by
    simp_rw [ae_all_iff]
    intro x; rw [ae_ball_iff t_count]; revert x
    intro n c _
    apply ae_tendsto_lintegral_div'
    ¬∑ refine (h'f.sub ?_).ennnorm
      exact stronglyMeasurable_const.indicator (IsOpen.measurableSet (A.set_mem n))
    ¬∑ apply ne_of_lt
      calc
        (‚à´‚Åª y, ‚Üë‚Äñf y - (A.set n).indicator (fun _ : Œ± => c) y‚Äñ‚Çä ‚àÇŒº) ‚â§
            ‚à´‚Åª y, ‚Äñf y‚Äñ‚Çä + ‚Äñ(A.set n).indicator (fun _ : Œ± => c) y‚Äñ‚Çä ‚àÇŒº := by
          apply lintegral_mono
          intro x
          dsimp
          rw [‚Üê ENNReal.coe_add]
          exact ENNReal.coe_le_coe.2 (nnnorm_sub_le _ _)
        _ = (‚à´‚Åª y, ‚Äñf y‚Äñ‚Çä ‚àÇŒº) + ‚à´‚Åª y, ‚Äñ(A.set n).indicator (fun _ : Œ± => c) y‚Äñ‚Çä ‚àÇŒº :=
          (lintegral_add_left h'f.ennnorm _)
        _ < ‚àû + ‚àû :=
          haveI I : Integrable ((A.set n).indicator fun _ : Œ± => c) Œº := by
            simp only [integrable_indicator_iff (IsOpen.measurableSet (A.set_mem n)),
              integrableOn_const, A.finite n, or_true_iff]
          ENNReal.add_lt_add hf.2 I.2
  filter_upwards [main, v.ae_eventually_measure_pos] with x hx h'x
  have M :
    ‚àÄ c ‚àà t, Tendsto (fun a => (‚à´‚Åª y in a, ‚Äñf y - c‚Äñ‚Çä ‚àÇŒº) / Œº a)
      (v.filterAt x) (ùìù ‚Äñf x - c‚Äñ‚Çä) := by
    intro c hc
    obtain ‚ü®n, xn‚ü© : ‚àÉ n, x ‚àà A.set n := by simpa [‚Üê A.spanning] using mem_univ x
    specialize hx n c hc
    simp only [xn, indicator_of_mem] at hx
    apply hx.congr' _
    filter_upwards [v.eventually_filterAt_subset_of_nhds (IsOpen.mem_nhds (A.set_mem n) xn),
      v.eventually_filterAt_measurableSet x] with a ha h'a
    congr 1
    apply setLIntegral_congr_fun h'a
    filter_upwards with y hy using (by simp only [ha hy, indicator_of_mem])
  apply ENNReal.tendsto_nhds_zero.2 fun Œµ Œµpos => ?_
  obtain ‚ü®c, ct, xc‚ü© : ‚àÉ c ‚àà t, (‚Äñf x - c‚Äñ‚Çä : ‚Ñù‚â•0‚àû) < Œµ / 2 := by
    simp_rw [‚Üê edist_eq_coe_nnnorm_sub]
    have : f x ‚àà closure t := ht (mem_range_self _)
    exact EMetric.mem_closure_iff.1 this (Œµ / 2) (ENNReal.half_pos (ne_of_gt Œµpos))
  filter_upwards [(tendsto_order.1 (M c ct)).2 (Œµ / 2) xc, h'x, v.eventually_measure_lt_top x] with
    a ha h'a h''a
  apply ENNReal.div_le_of_le_mul
  calc
    (‚à´‚Åª y in a, ‚Äñf y - f x‚Äñ‚Çä ‚àÇŒº) ‚â§ ‚à´‚Åª y in a, ‚Äñf y - c‚Äñ‚Çä + ‚Äñf x - c‚Äñ‚Çä ‚àÇŒº := by
      apply lintegral_mono fun x => ?_
      simpa only [‚Üê edist_eq_coe_nnnorm_sub] using edist_triangle_right _ _ _
    _ = (‚à´‚Åª y in a, ‚Äñf y - c‚Äñ‚Çä ‚àÇŒº) + ‚à´‚Åª _ in a, ‚Äñf x - c‚Äñ‚Çä ‚àÇŒº :=
      (lintegral_add_right _ measurable_const)
    _ ‚â§ Œµ / 2 * Œº a + Œµ / 2 * Œº a := by
      gcongr
      ¬∑ rw [ENNReal.div_lt_iff (Or.inl h'a.ne') (Or.inl h''a.ne)] at ha
        exact ha.le
      ¬∑ simp only [lintegral_const, Measure.restrict_apply, MeasurableSet.univ, univ_inter]
        gcongr
    _ = Œµ * Œº a := by rw [‚Üê add_mul, ENNReal.add_halves]"
Mathlib/MeasureTheory/Measure/Restrict.lean,MeasureTheory.Measure.restrict_iUnion_apply,restrict_iUnion_apply,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  simp only [restrict_apply, ht, inter_iUnion]
  exact
    measure_iUnion‚ÇÄ (hd.mono fun i j h => h.mono (inter_subset_right _ _) (inter_subset_right _ _))
      fun i => ht.nullMeasurableSet.inter (hm i)","error:  function expected at
  inter_subset_right ?m.47812
term has type
  ?m.47811 ‚àà ?m.47810
error:  function expected at
  inter_subset_right ?m.47854
term has type
  ?m.47853 ‚àà ?m.47852","theorem restrict_iUnion_apply_ae [Countable Œπ] {s : Œπ ‚Üí Set Œ±} (hd : Pairwise (AEDisjoint Œº on s))
    (hm : ‚àÄ i, NullMeasurableSet (s i) Œº) {t : Set Œ±} (ht : MeasurableSet t) :
    Œº.restrict (‚ãÉ i, s i) t = ‚àë' i, Œº.restrict (s i) t ",":= by
  simp only [restrict_apply, ht, inter_iUnion]
  exact
    measure_iUnion‚ÇÄ (hd.mono fun i j h => h.mono inter_subset_right inter_subset_right)
      fun i => ht.nullMeasurableSet.inter (hm i)"
Mathlib/ModelTheory/Satisfiability.lean,FirstOrder.Language.Theory.models_iff_not_satisfiable,models_iff_not_satisfiable,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rw [models_sentence_iff, IsSatisfiable]
  refine
    ‚ü®fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T ‚à™ {Formula.not œÜ})
          (Set.subset_union_right _ _ (Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel (Set.subset_union_left _ _))),
      fun h M => ?_‚ü©
  contrapose! h
  rw [‚Üê Sentence.realize_not] at h
  refine'
    ‚ü®{  Carrier := M
        is_model := ‚ü®fun œà hœà => hœà.elim (realize_sentence_of_mem _) fun h' => _‚ü© }‚ü©
  rw [Set.mem_singleton_iff.1 h']
  exact h","warning:  @ModelsBoundedFormula does not have a doc string
error:  function expected at
  Set.subset_union_right ?m.33716
term has type
  ?m.33715 ‚àà ?m.33713 ‚à™ ?m.33714
error:  function expected at
  Set.subset_union_left ?m.33942
term has type
  ?m.33941 ‚àà ?m.33939 ‚à™ ?m.33940",theorem models_iff_not_satisfiable (œÜ : L.Sentence) : T ‚ä®·µá œÜ ‚Üî ¬¨IsSatisfiable (T ‚à™ {œÜ.not}) ,":= by
  rw [models_sentence_iff, IsSatisfiable]
  refine
    ‚ü®fun h1 h2 =>
      (Sentence.realize_not _).1
        (realize_sentence_of_mem (T ‚à™ {Formula.not œÜ})
          (Set.subset_union_right (Set.mem_singleton _)))
        (h1 (h2.some.subtheoryModel Set.subset_union_left)),
      fun h M => ?_‚ü©
  contrapose! h
  rw [‚Üê Sentence.realize_not] at h
  refine
    ‚ü®{  Carrier := M
        is_model := ‚ü®fun œà hœà => hœà.elim (realize_sentence_of_mem _) fun h' => ?_‚ü© }‚ü©
  rw [Set.mem_singleton_iff.1 h']
  exact h"
Mathlib/LinearAlgebra/TensorProduct/Vanishing.lean,TensorProduct.vanishesTrivially_of_sum_tmul_eq_zero,vanishesTrivially_of_sum_tmul_eq_zero,3580d586803b82ba362015ef69c1be472f5fac6f,":= by
  apply VanishesTrivially.universe_shift
  set G : (Œπ ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] M := Finsupp.total Œπ M R m with hG
  have G_basis_eq (i : Œπ) : G (Finsupp.single i 1) = m i := by simp [hG, toModule_lof]
  have G_surjective : Surjective G := by
    apply LinearMap.range_eq_top.mp
    apply top_le_iff.mp
    rw [‚Üê hm]
    apply Submodule.span_le.mpr
    rintro _ ‚ü®i, rfl‚ü©
    use Finsupp.single i 1, G_basis_eq i
  set en : (Œπ ‚Üí‚ÇÄ R) ‚äó[R] N := ‚àë i, Finsupp.single i 1 ‚äó‚Çú n i with hen
  have en_mem_ker : en ‚àà ker (rTensor N G) := by simp [hen, G_basis_eq, hmn]
  have exact_ker_subtype : Exact (ker G).subtype G := G.exact_subtype_ker_map
  have exact_rTensor_ker_subtype : Exact (rTensor N (ker G).subtype) (rTensor N G) :=
    rTensor_exact (M := ‚Ü•(ker G)) N exact_ker_subtype G_surjective
  have en_mem_range : en ‚àà range (rTensor N (ker G).subtype) :=
    exact_rTensor_ker_subtype.linearMap_ker_eq ‚ñ∏ en_mem_ker
  obtain ‚ü®kn, hkn‚ü© := en_mem_range
  obtain ‚ü®ma, rfl : kn = ‚àë kj ‚àà ma, kj.1 ‚äó‚Çú[R] kj.2‚ü© := exists_finset kn
  use ‚Üë‚Üëma, FinsetCoe.fintype ma
  use fun i ‚ü®‚ü®kj, _‚ü©, _‚ü© ‚Ü¶ (kj : Œπ ‚Üí‚ÇÄ R) i
  use fun ‚ü®‚ü®_, yj‚ü©, _‚ü© ‚Ü¶ yj
  constructor
  ¬∑ intro i
    apply_fun finsuppScalarLeft R N Œπ at hkn
    apply_fun (¬∑ i) at hkn
    symm at hkn
    simp only [map_sum, finsuppScalarLeft_apply_tmul, zero_smul, Finsupp.single_zero,
      Finsupp.sum_single_index, one_smul, Finsupp.finset_sum_apply, Finsupp.single_apply,
      Finset.sum_ite_eq', Finset.mem_univ, ‚ÜìreduceIte, rTensor_tmul, coeSubtype, Finsupp.sum_apply,
      Finsupp.sum_ite_eq', Finsupp.mem_support_iff, ne_eq, ite_not, en] at hkn
    simp only [Finset.univ_eq_attach, Finset.sum_attach ma (fun x ‚Ü¶ (x.1 : Œπ ‚Üí‚ÇÄ R) i ‚Ä¢ x.2)]
    convert hkn using 2 with x _
    split
    ¬∑ next h'x => rw [h'x, zero_smul]
    ¬∑ rfl
  ¬∑ rintro ‚ü®‚ü®‚ü®k, hk‚ü©, _‚ü©, _‚ü©
    simpa only [hG, Finsupp.total_apply, zero_smul, implies_true, Finsupp.sum_fintype] using
      mem_ker.mp hk",error:  unknown constant 'TensorProduct.VanishesTrivially.universe_shift',"theorem vanishesTrivially_of_sum_tmul_eq_zero (hm : Submodule.span R (Set.range m) = ‚ä§)
    (hmn : ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N)) : VanishesTrivially R m n ",":= by
  set G : (Œπ ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] M := Finsupp.total Œπ M R m with hG
  have G_basis_eq (i : Œπ) : G (Finsupp.single i 1) = m i := by simp [hG, toModule_lof]
  have G_surjective : Surjective G := by
    apply LinearMap.range_eq_top.mp
    apply top_le_iff.mp
    rw [‚Üê hm]
    apply Submodule.span_le.mpr
    rintro _ ‚ü®i, rfl‚ü©
    use Finsupp.single i 1, G_basis_eq i
  set en : (Œπ ‚Üí‚ÇÄ R) ‚äó[R] N := ‚àë i, Finsupp.single i 1 ‚äó‚Çú n i with hen
  have en_mem_ker : en ‚àà ker (rTensor N G) := by simp [hen, G_basis_eq, hmn]
  have exact_ker_subtype : Exact (ker G).subtype G := G.exact_subtype_ker_map
  have exact_rTensor_ker_subtype : Exact (rTensor N (ker G).subtype) (rTensor N G) :=
    rTensor_exact (M := ‚Ü•(ker G)) N exact_ker_subtype G_surjective
  have en_mem_range : en ‚àà range (rTensor N (ker G).subtype) :=
    exact_rTensor_ker_subtype.linearMap_ker_eq ‚ñ∏ en_mem_ker
  obtain ‚ü®kn, hkn‚ü© := en_mem_range
  obtain ‚ü®ma, rfl : kn = ‚àë kj ‚àà ma, kj.1 ‚äó‚Çú[R] kj.2‚ü© := exists_finset kn
  use ‚Üë‚Üëma, FinsetCoe.fintype ma
  use fun i ‚ü®‚ü®kj, _‚ü©, _‚ü© ‚Ü¶ (kj : Œπ ‚Üí‚ÇÄ R) i
  use fun ‚ü®‚ü®_, yj‚ü©, _‚ü© ‚Ü¶ yj
  constructor
  ¬∑ intro i
    apply_fun finsuppScalarLeft R N Œπ at hkn
    apply_fun (¬∑ i) at hkn
    symm at hkn
    simp only [map_sum, finsuppScalarLeft_apply_tmul, zero_smul, Finsupp.single_zero,
      Finsupp.sum_single_index, one_smul, Finsupp.finset_sum_apply, Finsupp.single_apply,
      Finset.sum_ite_eq', Finset.mem_univ, ‚ÜìreduceIte, rTensor_tmul, coeSubtype, Finsupp.sum_apply,
      Finsupp.sum_ite_eq', Finsupp.mem_support_iff, ne_eq, ite_not, en] at hkn
    simp only [Finset.univ_eq_attach, Finset.sum_attach ma (fun x ‚Ü¶ (x.1 : Œπ ‚Üí‚ÇÄ R) i ‚Ä¢ x.2)]
    convert hkn using 2 with x _
    split
    ¬∑ next h'x => rw [h'x, zero_smul]
    ¬∑ rfl
  ¬∑ rintro ‚ü®‚ü®‚ü®k, hk‚ü©, _‚ü©, _‚ü©
    simpa only [hG, Finsupp.total_apply, zero_smul, implies_true, Finsupp.sum_fintype] using
      mem_ker.mp hk"
Mathlib/NumberTheory/Cyclotomic/Basic.lean,IsCyclotomicExtension.splitting_field_cyclotomic,splitting_field_cyclotomic,6d1b77e97159c51b0084f053ab93299f39b3a009,":=
  { splits' := splits_cyclotomic K L (mem_singleton n)
    adjoin_rootSet' := by
      rw [‚Üê ((iff_adjoin_eq_top {n} K L).1 inferInstance).2]
      letI := Classical.decEq L
      obtain ‚ü®Œ∂ : L, hŒ∂‚ü© := IsCyclotomicExtension.exists_prim_root K (mem_singleton n)
      exact adjoin_roots_cyclotomic_eq_adjoin_nth_roots hŒ∂ }","error:  typeclass instance problem is stuck, it is often due to metavariables
  IsCyclotomicExtension {n} K ?m.183753",theorem splitting_field_cyclotomic : IsSplittingField K L (cyclotomic n K) ,":=
  { splits' := splits_cyclotomic K L (mem_singleton n)
    adjoin_rootSet' := by
      rw [‚Üê ((iff_adjoin_eq_top {n} K L).1 inferInstance).2]
      letI := Classical.decEq L
      obtain ‚ü®Œ∂ : L, hŒ∂‚ü© := IsCyclotomicExtension.exists_prim_root K (B := L) (mem_singleton n)
      exact adjoin_roots_cyclotomic_eq_adjoin_nth_roots hŒ∂ }"
Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean,Real.smul_map_diagonal_volume_pi,smul_map_diagonal_volume_pi,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  refine' (Measure.pi_eq fun s hs => _).symm
  simp only [det_diagonal, Measure.coe_smul, Algebra.id.smul_eq_mul, Pi.smul_apply]
  rw [Measure.map_apply _ (MeasurableSet.univ_pi hs)]
  swap; ¬∑ exact Continuous.measurable (LinearMap.continuous_on_pi _)
  have :
    (Matrix.toLin' (diagonal D) ‚Åª¬π' Set.pi Set.univ fun i : Œπ => s i) =
      Set.pi Set.univ fun i : Œπ => (D i * ¬∑) ‚Åª¬π' s i := by
    ext f
    simp only [LinearMap.coe_proj, Algebra.id.smul_eq_mul, LinearMap.smul_apply, mem_univ_pi,
      mem_preimage, LinearMap.pi_apply, diagonal_toLin']
  have B : ‚àÄ i, ofReal (abs (D i)) * volume ((D i * ¬∑) ‚Åª¬π' s i) = volume (s i) := by
    intro i
    have A : D i ‚â† 0 := by
      simp only [det_diagonal, Ne.def] at h
      exact Finset.prod_ne_zero_iff.1 h i (Finset.mem_univ i)
    rw [volume_preimage_mul_left A, ‚Üê mul_assoc, ‚Üê ENNReal.ofReal_mul (abs_nonneg _), ‚Üê abs_mul,
      mul_inv_cancel A, abs_one, ENNReal.ofReal_one, one_mul]
  rw [this, volume_pi_pi, Finset.abs_prod,
    ENNReal.ofReal_prod_of_nonneg fun i _ => abs_nonneg (D i), ‚Üê Finset.prod_mul_distrib]
  simp only [B]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.131298 ‚Üí ?m.131298 ‚Üí Prop","theorem smul_map_diagonal_volume_pi [DecidableEq Œπ] {D : Œπ ‚Üí ‚Ñù} (h : det (diagonal D) ‚â† 0) :
    ENNReal.ofReal (abs (det (diagonal D))) ‚Ä¢ Measure.map (toLin' (diagonal D)) volume =
      volume ",":= by
  refine (Measure.pi_eq fun s hs => ?_).symm
  simp only [det_diagonal, Measure.coe_smul, Algebra.id.smul_eq_mul, Pi.smul_apply]
  rw [Measure.map_apply _ (MeasurableSet.univ_pi hs)]
  swap; ¬∑ exact Continuous.measurable (LinearMap.continuous_on_pi _)
  have :
    (Matrix.toLin' (diagonal D) ‚Åª¬π' Set.pi Set.univ fun i : Œπ => s i) =
      Set.pi Set.univ fun i : Œπ => (D i * ¬∑) ‚Åª¬π' s i := by
    ext f
    simp only [LinearMap.coe_proj, Algebra.id.smul_eq_mul, LinearMap.smul_apply, mem_univ_pi,
      mem_preimage, LinearMap.pi_apply, diagonal_toLin']
  have B : ‚àÄ i, ofReal (abs (D i)) * volume ((D i * ¬∑) ‚Åª¬π' s i) = volume (s i) := by
    intro i
    have A : D i ‚â† 0 := by
      simp only [det_diagonal, Ne] at h
      exact Finset.prod_ne_zero_iff.1 h i (Finset.mem_univ i)
    rw [volume_preimage_mul_left A, ‚Üê mul_assoc, ‚Üê ENNReal.ofReal_mul (abs_nonneg _), ‚Üê abs_mul,
      mul_inv_cancel A, abs_one, ENNReal.ofReal_one, one_mul]
  rw [this, volume_pi_pi, Finset.abs_prod,
    ENNReal.ofReal_prod_of_nonneg fun i _ => abs_nonneg (D i), ‚Üê Finset.prod_mul_distrib]
  simp only [B]"
Mathlib/Data/Nat/Fib/Zeckendorf.lean,Nat.isZeckendorfRep_zeckendorf,isZeckendorfRep_zeckendorf,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,"  | 0 => Chain.nil
  | n + 1 => by
    rw [zeckendorf_succ, IsZeckendorfRep, List.cons_append]
    have := zeckendorf_aux n.succ_pos
    refine (isZeckendorfRep_zeckendorf _).cons' (fun a ha ‚Ü¶ ?_)
    obtain h | h := eq_zero_or_pos (n + 1 - fib (greatestFib (n + 1)))
    ¬∑ simp only [h, zeckendorf_zero, nil_append, head?_cons, Option.mem_some_iff] at ha
      subst ha
      exact le_greatestFib.2 le_add_self
    rw [zeckendorf_of_pos h, cons_append, head?_cons, Option.mem_some_iff] at ha
    subst a
    exact add_le_of_le_tsub_right_of_le (le_greatestFib.2 le_add_self)
      (greatestFib_sub_fib_greatestFib_le_greatestFib n.succ_ne_zero)","error:  type mismatch
  Chain.nil
has type
  Chain ?m.19482 ?m.19483 [] : Prop
but is expected to have type
  (zeckendorf 0).IsZeckendorfRep : Prop","lemma isZeckendorfRep_zeckendorf : ‚àÄ n, (zeckendorf n).IsZeckendorfRep
","  | 0 => by simp only [zeckendorf_zero, IsZeckendorfRep_nil]
  | n + 1 => by
    rw [zeckendorf_succ, IsZeckendorfRep, List.cons_append]
    refine (isZeckendorfRep_zeckendorf _).cons' (fun a ha ‚Ü¶ ?_)
    obtain h | h := eq_zero_or_pos (n + 1 - fib (greatestFib (n + 1)))
    ¬∑ simp only [h, zeckendorf_zero, nil_append, head?_cons, Option.mem_some_iff] at ha
      subst ha
      exact le_greatestFib.2 le_add_self
    rw [zeckendorf_of_pos h, cons_append, head?_cons, Option.mem_some_iff] at ha
    subst a
    exact add_le_of_le_tsub_right_of_le (le_greatestFib.2 le_add_self)
      (greatestFib_sub_fib_greatestFib_le_greatestFib n.succ_ne_zero)"
Mathlib/Analysis/SpecialFunctions/Pow/Real.lean,Complex.cpow_ofReal,cpow_ofReal,494478bf8809a6197efc24a4ee1fc7b02edca0e8,":= by
  rcases eq_or_ne x 0 with rfl | hx
  ¬∑ simp [ofReal_cpow le_rfl]
  ¬∑ rw [cpow_def_of_ne_zero hx, exp_eq_exp_re_mul_sin_add_cos, mul_comm (log x)]
    norm_cast
    rw [ofReal_mul_re, ofReal_mul_im, log_re, log_im, mul_comm y, mul_comm y, Real.exp_mul,
      Real.exp_log]
    rwa [abs.pos_iff]","error:  unknown identifier 'ofReal_mul_re'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.48283
case inr
x : ‚ÑÇ
y : ‚Ñù
hx : x ‚â† 0
‚ä¢ ‚Üë(rexp (‚Üëy * log x).re) * (‚Üë(Real.cos (‚Üëy * log x).im) + ‚Üë(Real.sin (‚Üëy * log x).im) * I) =
    ‚Üë(abs x ^ y) * (‚Üë(Real.cos (x.arg * y)) + ‚Üë(Real.sin (x.arg * y)) * I)","lemma cpow_ofReal (x : ‚ÑÇ) (y : ‚Ñù) :
    x ^ (y : ‚ÑÇ) = ‚Üë(abs x ^ y) * (Real.cos (arg x * y) + Real.sin (arg x * y) * I) ",":= by
  rcases eq_or_ne x 0 with rfl | hx
  ¬∑ simp [ofReal_cpow le_rfl]
  ¬∑ rw [cpow_def_of_ne_zero hx, exp_eq_exp_re_mul_sin_add_cos, mul_comm (log x)]
    norm_cast
    rw [re_ofReal_mul, im_ofReal_mul, log_re, log_im, mul_comm y, mul_comm y, Real.exp_mul,
      Real.exp_log]
    rwa [abs.pos_iff]"
Mathlib/Data/Matrix/PEquiv.lean,PEquiv.toMatrix_swap,toMatrix_swap,166d0bf5448fdaad518cf95891af45e08a3e9c35,":= by
  ext
  dsimp [toMatrix, single, Equiv.swap_apply_def, Equiv.toPEquiv, one_apply]
  rw [one_apply]
  split_ifs <;> simp_all","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  1 ?m.53380 ?m.53381
case a
k : Type u_1
l : Type u_2
m : Type u_3
n : Type u_4
Œ± : Type v
inst‚úù¬π : DecidableEq n
inst‚úù : Ring Œ±
i j i‚úù j‚úù : n
‚ä¢ (if j‚úù ‚àà some (if i‚úù = i then j else if i‚úù = j then i else i‚úù) then 1 else 0) =
    ((((if i‚úù = j‚úù then 1 else 0) - if j‚úù ‚àà if i‚úù = i then some i else none then 1 else 0) -
          if j‚úù ‚àà if i‚úù = j then some j else none then 1 else 0) +
        if j‚úù ‚àà if i‚úù = i then some j else none then 1 else 0) +
      if j‚úù ‚àà if i‚úù = j then some i else none then 1 else 0","theorem toMatrix_swap [DecidableEq n] [Ring Œ±] (i j : n) :
    (Equiv.swap i j).toPEquiv.toMatrix =
      (1 : Matrix n n Œ±) - (single i i).toMatrix - (single j j).toMatrix + (single i j).toMatrix +
        (single j i).toMatrix ",":= by
  ext
  dsimp [toMatrix, single, Equiv.swap_apply_def, Equiv.toPEquiv, one_apply]
  split_ifs <;> simp_all"
Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean,MeasureTheory.exists_lt_lowerSemicontinuous_integral_lt,exists_lt_lowerSemicontinuous_integral_lt,2ab2720bf60e325ecde05f72c30fd6346f06a460,":= by
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ / 2, (half_pos Œµpos).le‚ü©
  have Œ¥pos : 0 < Œ¥ := half_pos Œµpos
  let fp : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (f x)
  have int_fp : Integrable (fun x => (fp x : ‚Ñù)) Œº := hf.real_toNNReal
  rcases exists_lt_lowerSemicontinuous_integral_gt_nnreal fp int_fp Œ¥pos with
    ‚ü®gp, fp_lt_gp, gpcont, gp_lt_top, gp_integrable, gpint‚ü©
  let fm : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (-f x)
  have int_fm : Integrable (fun x => (fm x : ‚Ñù)) Œº := hf.neg.real_toNNReal
  rcases exists_upperSemicontinuous_le_integral_le fm int_fm Œ¥pos with
    ‚ü®gm, gm_le_fm, gmcont, gm_integrable, gmint‚ü©
  let g : Œ± ‚Üí EReal := fun x => (gp x : EReal) - gm x
  have ae_g : ‚àÄ·µê x ‚àÇŒº, (g x).toReal = (gp x : EReal).toReal - (gm x : EReal).toReal := by
    filter_upwards [gp_lt_top] with _ hx
    rw [EReal.toReal_sub] <;> simp [hx.ne]
  refine' ‚ü®g, ?lt, ?lsc, ?int, ?aelt, ?intlt‚ü©
  case int =>
    show Integrable (fun x => EReal.toReal (g x)) Œº
    rw [integrable_congr ae_g]
    convert gp_integrable.sub gm_integrable
    simp
  case intlt =>
    show (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) < (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ;
    exact
      calc
        (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) = ‚à´ x : Œ±, EReal.toReal (gp x) - EReal.toReal (gm x) ‚àÇŒº :=
          integral_congr_ae ae_g
        _ = (‚à´ x : Œ±, EReal.toReal (gp x) ‚àÇŒº) - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          simp only [EReal.toReal_coe_ennreal, ENNReal.coe_toReal]
          exact integral_sub gp_integrable gm_integrable
        _ < (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          apply sub_lt_sub_right
          convert gpint
          simp only [EReal.toReal_coe_ennreal]
        _ ‚â§ (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ((‚à´ x : Œ±, ‚Üë(fm x) ‚àÇŒº) - Œ¥) := sub_le_sub_left gmint _
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + 2 * Œ¥ := by
          simp_rw [integral_eq_integral_pos_part_sub_integral_neg_part hf]; ring
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ := by congr 1; field_simp [Œ¥, mul_comm]
  case aelt =>
    show ‚àÄ·µê x : Œ± ‚àÇŒº, g x < ‚ä§
    filter_upwards [gp_lt_top] with ?_ hx
    simp only [g, sub_eq_add_neg, Ne, (EReal.add_lt_top _ _).ne, lt_top_iff_ne_top,
      lt_top_iff_ne_top.1 hx, EReal.coe_ennreal_eq_top_iff, not_false_iff, EReal.neg_eq_top_iff,
      EReal.coe_ennreal_ne_bot]
  case lt =>
    show ‚àÄ x, (f x : EReal) < g x
    intro x
    rw [EReal.coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal (f x)]
    refine EReal.sub_lt_sub_of_lt_of_le ?_ ?_ ?_? _
    ¬∑ simp only [EReal.coe_ennreal_lt_coe_ennreal_iff]; exact fp_lt_gp x
    ¬∑ simp only [ENNReal.coe_le_coe, EReal.coe_ennreal_le_coe_ennreal_iff]
      exact gm_le_fm x
    ¬∑ simp only [EReal.coe_ennreal_ne_bot, Ne, not_false_iff]
    ¬∑ simp only [EReal.coe_nnreal_ne_top, Ne, not_false_iff]
  case lsc =>
    show LowerSemicontinuous g
    apply LowerSemicontinuous.add'
    ¬∑ exact continuous_coe_ennreal_ereal.comp_lowerSemicontinuous gpcont fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
    ¬∑ apply continuous_neg.comp_upperSemicontinuous_antitone _ fun x y hxy =>
          EReal.neg_le_neg_iff.2 hxy
      dsimp
      apply continuous_coe_ennreal_ereal.comp_upperSemicontinuous _ fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
      exact ENNReal.continuous_coe.comp_upperSemicontinuous gmcont fun x y hxy =>
          ENNReal.coe_le_coe.2 hxy
    ¬∑ intro x
      exact EReal.continuousAt_add (by simp) (by simp)","error:  don't know how to synthesize placeholder for argument 'ht'
context:
Œ± : Type u_1
inst‚úù‚Å¥ : TopologicalSpace Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : BorelSpace Œ±
Œº : Measure Œ±
inst‚úù¬π : Œº.WeaklyRegular
inst‚úù : SigmaFinite Œº
f : Œ± ‚Üí ‚Ñù
hf : Integrable f Œº
Œµ : ‚Ñù
Œµpos : 0 < Œµ
Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ / 2, ‚ãØ‚ü©
Œ¥pos : 0 < Œ¥
fp : Œ± ‚Üí ‚Ñù‚â•0 := fun x ‚Ü¶ (f x).toNNReal
int_fp : Integrable (fun x ‚Ü¶ ‚Üë(fp x)) Œº
gp : Œ± ‚Üí ‚Ñù‚â•0‚àû
fp_lt_gp : ‚àÄ (x : Œ±), ‚Üë(fp x) < gp x
gpcont : LowerSemicontinuous gp
gp_lt_top : ‚àÄ·µê (x : Œ±) ‚àÇŒº, gp x < ‚ä§
gp_integrable : Integrable (fun x ‚Ü¶ (gp x).toReal) Œº
gpint : ‚à´ (x : Œ±), (gp x).toReal ‚àÇŒº < ‚à´ (x : Œ±), ‚Üë(fp x) ‚àÇŒº + (fun a ‚Ü¶ ‚Üëa) Œ¥
fm : Œ± ‚Üí ‚Ñù‚â•0 := fun x ‚Ü¶ (-f x).toNNReal
int_fm : Integrable (fun x ‚Ü¶ ‚Üë(fm x)) Œº
gm : Œ± ‚Üí ‚Ñù‚â•0
gm_le_fm : ‚àÄ (x : Œ±), gm x ‚â§ fm x
gmcont : UpperSemicontinuous gm
gm_integrable : Integrable (fun x ‚Ü¶ ‚Üë(gm x)) Œº
gmint : ‚à´ (x : Œ±), ‚Üë(fm x) ‚àÇŒº - (fun a ‚Ü¶ ‚Üëa) Œ¥ ‚â§ ‚à´ (x : Œ±), ‚Üë(gm x) ‚àÇŒº
g : Œ± ‚Üí EReal := fun x ‚Ü¶ ‚Üë(gp x) - ‚Üë‚Üë(gm x)
ae_g : ‚àÄ·µê (x : Œ±) ‚àÇŒº, (g x).toReal = (‚Üë(gp x)).toReal - (‚Üë‚Üë(gm x)).toReal
x : Œ±
‚ä¢ ‚Üë‚Üë(-f x).toNNReal ‚â† ‚ä§","theorem exists_lt_lowerSemicontinuous_integral_lt [SigmaFinite Œº] (f : Œ± ‚Üí ‚Ñù) (hf : Integrable f Œº)
    {Œµ : ‚Ñù} (Œµpos : 0 < Œµ) :
    ‚àÉ g : Œ± ‚Üí EReal,
      (‚àÄ x, (f x : EReal) < g x) ‚àß
      LowerSemicontinuous g ‚àß
      Integrable (fun x => EReal.toReal (g x)) Œº ‚àß
      (‚àÄ·µê x ‚àÇŒº, g x < ‚ä§) ‚àß (‚à´ x, EReal.toReal (g x) ‚àÇŒº) < (‚à´ x, f x ‚àÇŒº) + Œµ ",":= by
  let Œ¥ : ‚Ñù‚â•0 := ‚ü®Œµ / 2, (half_pos Œµpos).le‚ü©
  have Œ¥pos : 0 < Œ¥ := half_pos Œµpos
  let fp : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (f x)
  have int_fp : Integrable (fun x => (fp x : ‚Ñù)) Œº := hf.real_toNNReal
  rcases exists_lt_lowerSemicontinuous_integral_gt_nnreal fp int_fp Œ¥pos with
    ‚ü®gp, fp_lt_gp, gpcont, gp_lt_top, gp_integrable, gpint‚ü©
  let fm : Œ± ‚Üí ‚Ñù‚â•0 := fun x => Real.toNNReal (-f x)
  have int_fm : Integrable (fun x => (fm x : ‚Ñù)) Œº := hf.neg.real_toNNReal
  rcases exists_upperSemicontinuous_le_integral_le fm int_fm Œ¥pos with
    ‚ü®gm, gm_le_fm, gmcont, gm_integrable, gmint‚ü©
  let g : Œ± ‚Üí EReal := fun x => (gp x : EReal) - gm x
  have ae_g : ‚àÄ·µê x ‚àÇŒº, (g x).toReal = (gp x : EReal).toReal - (gm x : EReal).toReal := by
    filter_upwards [gp_lt_top] with _ hx
    rw [EReal.toReal_sub] <;> simp [hx.ne]
  refine ‚ü®g, ?lt, ?lsc, ?int, ?aelt, ?intlt‚ü©
  case int =>
    show Integrable (fun x => EReal.toReal (g x)) Œº
    rw [integrable_congr ae_g]
    convert gp_integrable.sub gm_integrable
    simp
  case intlt =>
    show (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) < (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ;
    exact
      calc
        (‚à´ x : Œ±, (g x).toReal ‚àÇŒº) = ‚à´ x : Œ±, EReal.toReal (gp x) - EReal.toReal (gm x) ‚àÇŒº :=
          integral_congr_ae ae_g
        _ = (‚à´ x : Œ±, EReal.toReal (gp x) ‚àÇŒº) - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          simp only [EReal.toReal_coe_ennreal, ENNReal.coe_toReal]
          exact integral_sub gp_integrable gm_integrable
        _ < (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ‚à´ x : Œ±, ‚Üë(gm x) ‚àÇŒº := by
          apply sub_lt_sub_right
          convert gpint
          simp only [EReal.toReal_coe_ennreal]
        _ ‚â§ (‚à´ x : Œ±, ‚Üë(fp x) ‚àÇŒº) + ‚ÜëŒ¥ - ((‚à´ x : Œ±, ‚Üë(fm x) ‚àÇŒº) - Œ¥) := sub_le_sub_left gmint _
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + 2 * Œ¥ := by
          simp_rw [integral_eq_integral_pos_part_sub_integral_neg_part hf]; ring
        _ = (‚à´ x : Œ±, f x ‚àÇŒº) + Œµ := by congr 1; field_simp [Œ¥, mul_comm]
  case aelt =>
    show ‚àÄ·µê x : Œ± ‚àÇŒº, g x < ‚ä§
    filter_upwards [gp_lt_top] with ?_ hx
    simp only [g, sub_eq_add_neg, Ne, (EReal.add_lt_top _ _).ne, lt_top_iff_ne_top,
      lt_top_iff_ne_top.1 hx, EReal.coe_ennreal_eq_top_iff, not_false_iff, EReal.neg_eq_top_iff,
      EReal.coe_ennreal_ne_bot]
  case lt =>
    show ‚àÄ x, (f x : EReal) < g x
    intro x
    rw [EReal.coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal (f x)]
    refine EReal.sub_lt_sub_of_lt_of_le ?_ ?_ ?_ ?_
    ¬∑ simp only [EReal.coe_ennreal_lt_coe_ennreal_iff]; exact fp_lt_gp x
    ¬∑ simp only [ENNReal.coe_le_coe, EReal.coe_ennreal_le_coe_ennreal_iff]
      exact gm_le_fm x
    ¬∑ simp only [EReal.coe_ennreal_ne_bot, Ne, not_false_iff]
    ¬∑ simp only [EReal.coe_nnreal_ne_top, Ne, not_false_iff]
  case lsc =>
    show LowerSemicontinuous g
    apply LowerSemicontinuous.add'
    ¬∑ exact continuous_coe_ennreal_ereal.comp_lowerSemicontinuous gpcont fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
    ¬∑ apply continuous_neg.comp_upperSemicontinuous_antitone _ fun x y hxy =>
          EReal.neg_le_neg_iff.2 hxy
      dsimp
      apply continuous_coe_ennreal_ereal.comp_upperSemicontinuous _ fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
      exact ENNReal.continuous_coe.comp_upperSemicontinuous gmcont fun x y hxy =>
          ENNReal.coe_le_coe.2 hxy
    ¬∑ intro x
      exact EReal.continuousAt_add (by simp) (by simp)"
Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean,CategoryTheory.Limits.colimitLimitToLimitColimit_surjective,colimitLimitToLimitColimit_surjective,d1eb6264448286c8ff0dd2875db90fd9724a3cbf,":= by
  classical
    intro x
    have z := fun j => jointly_surjective'.{v, v} (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply', t, FunctorToTypes.map_comp_apply, Colimit.w_apply', e, ‚Üê
        Limit.w_apply' f, ‚Üê e]
      simp
    simp_rw [colimit_eq_iff.{v, v}] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (by
            rw [Finset.mem_biUnion]
            refine' ‚ü®j, Finset.mem_univ j, _‚ü©
            rw [Finset.mem_biUnion]
            refine' ‚ü®j', Finset.mem_univ j', _‚ü©
            rw [Finset.mem_image]
            refine' ‚ü®f, Finset.mem_univ _, _‚ü©
            rfl))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£'(X Y : K)(_ : X ‚àà O)(_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      exact k'O
      swap
      ¬∑ rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÅ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÇ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®f, Finset.mem_univ _, _‚ü©
        simp only [true_or_iff, eq_self_iff_true, and_self_iff, Finset.mem_insert, heq_iff_eq]
      ¬∑ rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÉ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®j‚ÇÑ, Finset.mem_univ _, _‚ü©
        rw [Finset.mem_biUnion]
        refine' ‚ü®f', Finset.mem_univ _, _‚ü©
        simp only [eq_self_iff_true, or_true_iff, and_self_iff, Finset.mem_insert,
          Finset.mem_singleton, heq_iff_eq]
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk.{v, v}
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) :=
            by rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) :=
            by rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) :=
            by rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext'
      intro j
      simp only [id.def, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff.{v, v}, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine' ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), _‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","error:  application type mismatch
  jointly_surjective' (limit.œÄ (curry.obj F ‚ãô colim) j x)
argument
  limit.œÄ (curry.obj F ‚ãô colim) j x
has type
  (curry.obj F ‚ãô colim).obj j : Type v
but is expected to have type
  colimit ?m.27488 : Type v
error:  unsolved goals
J : Type u‚ÇÅ
K : Type u‚ÇÇ
inst‚úù‚Å¥ : SmallCategory J
inst‚úù¬≥ : Category.{v‚ÇÇ, u‚ÇÇ} K
inst‚úù¬≤ : Small.{v, u‚ÇÇ} K
inst‚úù¬π : FinCategory J
F : J √ó K ‚•§ Type v
inst‚úù : IsFiltered K
x : limit (curry.obj F ‚ãô colim)
‚ä¢ ‚àÉ a, colimitLimitToLimitColimit F a = x","theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) ",":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.œÄ (curry.obj F ‚ãô Limits.colim) j x)
    let k : J ‚Üí K := fun j => (z j).choose
    let y : ‚àÄ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : ‚àÄ j,
        colimit.Œπ ((curry.obj F).obj j) (k j) (y j) = limit.œÄ (curry.obj F ‚ãô Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) ‚àÖ
    have g : ‚àÄ j, k j ‚ü∂ k' := fun j => IsFiltered.toSup (Finset.univ.image k) ‚àÖ (by simp)
    clear_value k'
    have w :
      ‚àÄ {j j' : J} (f : j ‚ü∂ j'),
        colimit.Œπ ((curry.obj F).obj j') k' (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          colimit.Œπ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ùüô (k j)) : (j, k j) ‚ü∂ (j', k j)) ‚â´ (ùüô j', g j) : (j, k j) ‚ü∂ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        ‚Üê Limit.w_apply.{u‚ÇÅ, v, u‚ÇÅ} f, ‚Üê e]
      simp only [Functor.comp_map, Types.Colimit.Œπ_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : ‚àÄ {j j'} (_ : j ‚ü∂ j'), K := fun f => (w f).choose
    let gf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f => (w f).choose_spec.choose
    let hf : ‚àÄ {j j'} (f : j ‚ü∂ j'), k' ‚ü∂ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      ‚àÄ {j j'} (f : j ‚ü∂ j'),
        F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j') =
          F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ùüô j', g j') : (j', k j') ‚ü∂ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) ‚ü∂ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [‚Üê FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) ‚à™ {k'}
    have kfO : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚àà O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr ‚ü®j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr ‚ü®j', Finset.mem_univ j',
              Finset.mem_image.mpr ‚ü®f, Finset.mem_univ _, rfl‚ü©‚ü©‚ü©))
    have k'O : k' ‚àà O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Œ£' (X Y : K) (_ : X ‚àà O) (_ : Y ‚àà O), X ‚ü∂ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j ‚ü∂ j' =>
            {‚ü®k', kf f, k'O, kfO f, gf f‚ü©, ‚ü®k', kf f, k'O, kfO f, hf f‚ü©}
    obtain ‚ü®k'', i', s'‚ü© := IsFiltered.sup_exists O H
    let i : ‚àÄ {j j'} (f : j ‚ü∂ j'), kf f ‚ü∂ k'' := fun {j} {j'} f => i' (kfO f)
    have s : ‚àÄ {j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f' : j‚ÇÉ ‚ü∂ j‚ÇÑ), gf f ‚â´ i f = hf f' ‚â´ i f' := by
      intros j‚ÇÅ j‚ÇÇ j‚ÇÉ j‚ÇÑ f f'
      rw [s', s']
      ¬∑ exact k'O
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÉ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÑ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivial‚ü©‚ü©‚ü©
      ¬∑ exact Finset.mem_biUnion.mpr ‚ü®j‚ÇÅ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr ‚ü®j‚ÇÇ, Finset.mem_univ _,
            Finset.mem_biUnion.mpr ‚ü®f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivial‚ü©‚ü©‚ü©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    ¬∑ 
      apply colimit.Œπ (curry.obj (swap K J ‚ãô F) ‚ãô Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      ¬∑
        exact fun j => F.map (‚ü®ùüô j, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)‚ü© : (j, k j) ‚ü∂ (j, k'')) (y j)
      ¬∑ 
        dsimp
        intro j j' f
        simp only [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j)) : (j, k j) ‚ü∂ (j', k'')) (y j) =
              F.map ((f, g j ‚â´ hf f ‚â´ i f) : (j, k j) ‚ü∂ (j', k'')) (y j) := by
            rw [s (ùüô j) f]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((f, g j ‚â´ hf f) : (j, k j) ‚ü∂ (j', kf f)) (y j)) := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ùüô j', i f) : (j', kf f) ‚ü∂ (j', k''))
                (F.map ((ùüô j', g j' ‚â´ gf f) : (j', k j') ‚ü∂ (j', kf f)) (y j')) := by
            rw [‚Üê wf f]
          _ = F.map ((ùüô j', g j' ‚â´ gf f ‚â´ i f) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [‚Üê FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ùüô j', g j' ‚â´ gf (ùüô j') ‚â´ i (ùüô j')) : (j', k j') ‚ü∂ (j', k'')) (y j') := by
            rw [s f (ùüô j'), ‚Üê s (ùüô j') (ùüô j')]
    ¬∑ 
      apply limit_ext
      intro j
      simp only [id, ‚Üê e, Limits.Œπ_colimitLimitToLimitColimit_œÄ_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.œÄ_mk]
      refine ‚ü®k'', ùüô k'', g j ‚â´ gf (ùüô j) ‚â´ i (ùüô j), ?_‚ü©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.partialGamma_add_one,partialGamma_add_one,916c75c1d9f2fcdcd11d5d5b32f69afcc94bb9c4,":= by
  rw [partialGamma, partialGamma, add_sub_cancel]
  have F_der_I : ‚àÄ x : ‚Ñù, x ‚àà Ioo 0 X ‚Üí HasDerivAt (fun x => (-x).exp * x ^ s : ‚Ñù ‚Üí ‚ÑÇ)
      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by
    intro x hx
    have d1 : HasDerivAt (fun y : ‚Ñù => (-y).exp) (-(-x).exp) x := by
      simpa using (hasDerivAt_neg x).exp
    have d2 : HasDerivAt (fun y : ‚Ñù => ‚Üëy ^ s) (s * x ^ (s - 1)) x := by
      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id ‚Üëx) ?_
      simpa only [mul_one] using t.comp_ofReal
      simpa only [id.def, ofReal_re, ofReal_im, Ne.def, eq_self_iff_true, not_true, or_false_iff,
        mul_one] using hx.1
    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2
  have cont := (continuous_ofReal.comp continuous_neg.exp).mul (continuous_ofReal_cpow_const hs)
  have der_ible :=
    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)
  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible
  apply_fun fun x : ‚ÑÇ => -x at int_eval
  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)
      (Gamma_integrand_deriv_integrable_B hs hX),
    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval
  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]
  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : ‚Ñù ‚Üí ‚ÑÇ) =
      (fun x => s * (-x).exp * x ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) := by ext1; ring
  rw [this]
  have t := @integral_const_mul 0 X volume _ _ s fun x : ‚Ñù => (-x).exp * x ^ (s - 1)
  rw [‚Üê t, ofReal_zero, zero_cpow]
  ¬∑ rw [MulZeroClass.mul_zero, add_zero]; congr 2; ext1; ring
  ¬∑ contrapose! hs; rw [hs, zero_re]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + (?b - ?a)
s : ‚ÑÇ
hs : 0 < s.re
X : ‚Ñù
hX : 0 ‚â§ X
‚ä¢ ‚à´ (x : ‚Ñù) in 0 ..X, ‚Üë(rexp (-x)) * ‚Üëx ^ (s + 1 - 1) =
    (s * ‚à´ (x : ‚Ñù) in 0 ..X, ‚Üë(rexp (-x)) * ‚Üëx ^ (s - 1)) - ‚Üë(rexp (-X)) * ‚ÜëX ^ s","theorem partialGamma_add_one {s : ‚ÑÇ} (hs : 0 < s.re) {X : ‚Ñù} (hX : 0 ‚â§ X) :
    partialGamma (s + 1) X = s * partialGamma s X - (-X).exp * X ^ s ",":= by
  rw [partialGamma, partialGamma, add_sub_cancel_right]
  have F_der_I : ‚àÄ x : ‚Ñù, x ‚àà Ioo 0 X ‚Üí HasDerivAt (fun x => (-x).exp * x ^ s : ‚Ñù ‚Üí ‚ÑÇ)
      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by
    intro x hx
    have d1 : HasDerivAt (fun y : ‚Ñù => (-y).exp) (-(-x).exp) x := by
      simpa using (hasDerivAt_neg x).exp
    have d2 : HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ s) (s * x ^ (s - 1)) x := by
      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id ‚Üëx) ?_
      ¬∑ simpa only [mul_one] using t.comp_ofReal
      ¬∑ exact ofReal_mem_slitPlane.2 hx.1
    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2
  have cont := (continuous_ofReal.comp continuous_neg.rexp).mul (continuous_ofReal_cpow_const hs)
  have der_ible :=
    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)
  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible
  apply_fun fun x : ‚ÑÇ => -x at int_eval
  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)
      (Gamma_integrand_deriv_integrable_B hs hX),
    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval
  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]
  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : ‚Ñù ‚Üí ‚ÑÇ) =
      (fun x => s * (-x).exp * x ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) := by ext1; ring
  rw [this]
  have t := @integral_const_mul 0 X volume _ _ s fun x : ‚Ñù => (-x).exp * x ^ (s - 1)
  rw [‚Üê t, ofReal_zero, zero_cpow]
  ¬∑ rw [mul_zero, add_zero]; congr 2; ext1; ring
  ¬∑ contrapose! hs; rw [hs, zero_re]"
Mathlib/Geometry/Manifold/Metrizable.lean,ManifoldWithCorners.metrizableSpace,ManifoldWithCorners.metrizableSpace,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  haveI := I.locallyCompactSpace; haveI := ChartedSpace.locallyCompactSpace H M
  haveI : NormalSpace M := normal_of_paracompact_t2
  haveI := I.secondCountableTopology
  haveI := ChartedSpace.secondCountable_of_sigma_compact H M
  exact metrizableSpace_of_t3_second_countable M",error:  unknown identifier 'normal_of_paracompact_t2',"theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    [FiniteDimensional ‚Ñù E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ‚Ñù E H)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :
    MetrizableSpace M ",":= by
  haveI := I.locallyCompactSpace; haveI := ChartedSpace.locallyCompactSpace H M
  haveI := I.secondCountableTopology
  haveI := ChartedSpace.secondCountable_of_sigma_compact H M
  exact metrizableSpace_of_t3_second_countable M"
Mathlib/Analysis/Convex/Slope.lean,StrictConvexOn.slope_strict_mono_adjacent,StrictConvexOn.slope_strict_mono_adjacent,9e34a191034458a56331f976ff7400a26407c888,":= by
  have hxz := hxy.trans hyz
  have hxz' := hxz.ne
  rw [‚Üê sub_pos] at hxy hxz hyz
  suffices f y / (y - x) + f y / (z - y) < f x / (y - x) + f z / (z - y) by
    ring_nf at this ‚ä¢
    linarith
  set a := (z - y) / (z - x)
  set b := (y - x) / (z - x)
  have hy : a ‚Ä¢ x + b ‚Ä¢ z = y := by
    field_simp
    rw [div_eq_iff] <;> [ring; linarith]
  have key :=
    hf.2 hx hz hxz' (div_pos hyz hxz) (div_pos hxy hxz)
      (show a + b = 1 by
        field_simp
        rw [div_eq_iff] <;> [ring; linarith])
  rw [hy] at key
  replace key := mul_lt_mul_of_pos_left key hxz
  field_simp [hxy.ne', hyz.ne', hxz.ne', mul_comm (z - x) _] at key ‚ä¢
  rw [div_lt_div_right]
  ¬∑ linarith
  ¬∑ nlinarith","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.48812 / ?m.48813 = ?m.48814
ùïú : Type u_1
inst‚úù : LinearOrderedField ùïú
s : Set ùïú
f : ùïú ‚Üí ùïú
hf : StrictConvexOn ùïú s f
x y z : ùïú
hx : x ‚àà s
hz : z ‚àà s
hxy : 0 < y - x
hyz : 0 < z - y
hxz : 0 < z - x
hxz' : x ‚â† z
a : ùïú := (z - y) / (z - x)
b : ùïú := (y - x) / (z - x)
‚ä¢ a * x + b * z = y
error:  simp made no progress","theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn ùïú s f) {x y z : ùïú}
    (hx : x ‚àà s) (hz : z ‚àà s) (hxy : x < y) (hyz : y < z) :
    (f y - f x) / (y - x) < (f z - f y) / (z - y) ",":= by
  have hxz := hxy.trans hyz
  have hxz' := hxz.ne
  rw [‚Üê sub_pos] at hxy hxz hyz
  suffices f y / (y - x) + f y / (z - y) < f x / (y - x) + f z / (z - y) by
    ring_nf at this ‚ä¢
    linarith
  set a := (z - y) / (z - x)
  set b := (y - x) / (z - x)
  have hy : a ‚Ä¢ x + b ‚Ä¢ z = y := by field_simp [a, b]; ring
  have key :=
    hf.2 hx hz hxz' (div_pos hyz hxz) (div_pos hxy hxz)
      (show a + b = 1 by field_simp [a, b])
  rw [hy] at key
  replace key := mul_lt_mul_of_pos_left key hxz
  field_simp [mul_comm (z - x) _] at key ‚ä¢
  rw [div_lt_div_right]
  ¬∑ linarith
  ¬∑ nlinarith"
Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean,mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt,mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt,d664a4757e1d5d6999ae3ca588b989e1039faee2,":= by
  have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
    hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
  letI := finiteDimensional B
  set P := minpoly R B.gen with hP
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  haveI : NoZeroSMulDivisors R L := NoZeroSMulDivisors.trans R K L
  let _ := P.map (algebraMap R L)
  rw [adjoin_singleton_eq_range_aeval] at hz
  obtain ‚ü®Q‚ÇÅ, hQ‚ü© := hz
  set Q := Q‚ÇÅ %‚Çò P with hQ‚ÇÅ
  replace hQ : aeval B.gen Q = p ‚Ä¢ z
  ¬∑ rw [‚Üê modByMonic_add_div Q‚ÇÅ (minpoly.monic hBint)] at hQ
    simpa using hQ
  by_cases hQzero : Q = 0
  ¬∑ simp only [hQzero, Algebra.smul_def, zero_eq_mul, aeval_zero] at hQ
    cases' hQ with H H‚ÇÅ
    ¬∑ have : Function.Injective (algebraMap R L) := by
        rw [algebraMap_eq R K L]
        exact (algebraMap K L).injective.comp (IsFractionRing.injective R K)
      exfalso
      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)
    ¬∑ rw [H‚ÇÅ]
      exact Subalgebra.zero_mem _
  refine mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => ?_) hQ
  induction' i using Nat.case_strong_induction_on with j hind
  ¬∑ intro _
    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt hp hBint hQ hzint hei
  ¬∑ intro hj
    convert hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd _ hndiv
    exact n
    have H := degree_modByMonic_lt Q‚ÇÅ (minpoly.monic hBint)
    rw [‚Üê hQ‚ÇÅ, ‚Üê hP] at H
    replace H := Nat.lt_iff_add_one_le.1
      (lt_of_lt_of_le
        (lt_of_le_of_lt (Nat.lt_iff_add_one_le.1 (Nat.lt_of_succ_lt_succ (mem_range.1 hj)))
          (lt_succ_self _)) (Nat.lt_iff_add_one_le.1 ((natDegree_lt_natDegree_iff hQzero).2 H)))
    rw [add_assoc] at H
    have Hj : Q.natDegree + 1 = j + 1 + (Q.natDegree - j) := by
      rw [‚Üê add_comm 1, ‚Üê add_comm 1, add_assoc, add_right_inj,
        ‚Üê Nat.add_sub_assoc (Nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm,
        Nat.add_sub_cancel]
    choose! g hg using hind
    replace hg : ‚àÄ k ‚àà range (j + 1), Q.coeff k ‚Ä¢ B.gen ^ k = algebraMap R L p * g k ‚Ä¢ B.gen ^ k
    ¬∑ intro k hk
      rw [hg k (mem_range_succ_iff.1 hk)
        (mem_range_succ_iff.2
          (le_trans (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),
        Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, mul_assoc]
    choose! f hf using
      IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
        (minpoly.monic hBint) hei.isWeaklyEisensteinAt
    have hf‚ÇÅ : ‚àÄ k ‚àà (range (Q.natDegree - j)).erase 0,
        Q.coeff (j + 1 + k) ‚Ä¢ B.gen ^ (j + 1 + k) * B.gen ^ (P.natDegree - (j + 2)) =
        (algebraMap R L) p * Q.coeff (j + 1 + k) ‚Ä¢ f (k + P.natDegree - 1) := by
      intro k hk
      rw [smul_mul_assoc, ‚Üê pow_add, ‚Üê Nat.add_sub_assoc H, ‚Üê add_assoc j 1 1, add_comm (j + 1) 1,
        add_assoc (j + 1), add_comm _ (k + P.natDegree), Nat.add_sub_add_right,
        ‚Üê (hf (k + P.natDegree - 1) _).2, mul_smul_comm]
      rw [(minpoly.monic hBint).natDegree_map, add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact Nat.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    suffices
        p ^ n.succ ‚à£ Q.coeff (succ j) ^ n.succ *
          (minpoly R B.gen).coeff 0 ^ (succ j + (P.natDegree - (j + 2))) by
      convert this
      rw [Nat.succ_eq_add_one, add_assoc, ‚Üê Nat.add_sub_assoc H, ‚Üê add_assoc, add_comm (j + 1),
        Nat.add_sub_add_left, ‚Üê Nat.add_sub_assoc, Nat.add_sub_add_left, hP, ‚Üê
        (minpoly.monic hBint).natDegree_map (algebraMap R K), ‚Üê
        minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, natDegree_minpoly, hn, Nat.sub_one,
        Nat.pred_succ]
      linarith
    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_addLeftEmbedding _ _),
      sum_congr rfl hg, add_comm] at hQ
    replace hQ := congr_arg (fun x => x * B.gen ^ (P.natDegree - (j + 2))) hQ
    simp_rw [sum_map, addLeftEmbedding_apply, add_mul, sum_mul, mul_assoc] at hQ
    rw [‚Üê insert_erase
      (mem_range.2 (tsub_pos_iff_lt.2 <| Nat.lt_of_succ_lt_succ <| mem_range.1 hj)),
      sum_insert (not_mem_erase 0 _), add_zero, sum_congr rfl hf‚ÇÅ, ‚Üê mul_sum, ‚Üê mul_sum, add_assoc,
      ‚Üê mul_add, smul_mul_assoc, ‚Üê pow_add, Algebra.smul_def] at hQ
    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)
    have hintsum : IsIntegral R (z * B.gen ^ (P.natDegree - (j + 2)) -
        (‚àë x : ‚Ñï in (range (Q.natDegree - j)).erase 0,
          Q.coeff (j + 1 + x) ‚Ä¢ f (x + P.natDegree - 1) +
            ‚àë x : ‚Ñï in range (j + 1), g x ‚Ä¢ B.gen ^ x * B.gen ^ (P.natDegree - (j + 2)))) := by
      refine (hzint.mul (hBint.pow _)).sub
        (.add (.sum _ fun k hk => .smul _ ?_)
          (.sum _ fun k _ => .mul (.smul _ (.pow hBint _)) (hBint.pow _)))
      refine adjoin_le_integralClosure hBint (hf _ ?_).1
      rw [(minpoly.monic hBint).natDegree_map (algebraMap R L)]
      rw [add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact _root_.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
    rw [Algebra.smul_def, mul_assoc, ‚Üê mul_sub, _root_.map_mul, algebraMap_apply R K L, map_pow,
      Algebra.norm_algebraMap, _root_.map_mul, algebraMap_apply R K L, Algebra.norm_algebraMap,
      finrank B, ‚Üê hr, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map,
      show (-1 : K) = algebraMap R K (-1) by simp, ‚Üê map_pow, ‚Üê map_pow, ‚Üê _root_.map_mul, ‚Üê
      map_pow, ‚Üê _root_.map_mul, ‚Üê map_pow, ‚Üê _root_.map_mul] at hQ
    have hppdiv : p ^ B.dim ‚à£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _
    rwa [‚Üê IsFractionRing.injective R K hQ, mul_comm, ‚Üê Units.coe_neg_one, mul_pow, ‚Üê
      Units.val_pow_eq_pow_val, ‚Üê Units.val_pow_eq_pow_val, mul_assoc,
      Units.dvd_mul_left, mul_comm, ‚Üê Nat.succ_eq_add_one, hn] at hppdiv","error:  unexpected token '¬∑'; expected '|'
error:  unsolved goals
case intro.intro
R : Type u
K : Type v
L : Type z
p : R
inst‚úù¬π‚Å∞ : CommRing R
inst‚úù‚Åπ : Field K
inst‚úù‚Å∏ : Field L
inst‚úù‚Å∑ : Algebra K L
inst‚úù‚Å∂ : Algebra R L
inst‚úù‚Åµ : Algebra R K
inst‚úù‚Å¥ : IsScalarTower R K L
inst‚úù¬≥ : IsSeparable K L
inst‚úù¬≤ : IsDomain R
inst‚úù¬π : IsFractionRing R K
inst‚úù : IsIntegrallyClosed R
B : PowerBasis K L
hp : _root_.Prime p
hBint : IsIntegral R B.gen
z : L
hzint : IsIntegral R z
this‚úù : Module.Finite K L := finiteDimensional B
P : R[X] := minpoly R B.gen
hei : P.IsEisensteinAt (Submodule.span R {p})
hndiv : ¬¨p ^ 2 ‚à£ P.coeff 0
hP : P = minpoly R B.gen
n : ‚Ñï
hn : B.dim = n.succ
this : NoZeroSMulDivisors R L
x‚úù : L[X] := Polynomial.map (algebraMap R L) P
Q‚ÇÅ : R[X]
Q : R[X] := Q‚ÇÅ %‚Çò P
hQ‚ÇÅ : Q = Q‚ÇÅ %‚Çò P
hQ : (aeval B.gen) Q = p ‚Ä¢ z
‚ä¢ z ‚àà adjoin R {B.gen}","theorem mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} (hzint : IsIntegral R z)
    (hz : p ‚Ä¢ z ‚àà adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) :
    z ‚àà adjoin R ({B.gen} : Set L) ",":= by
  have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>
    hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)
  have := B.finite
  set P := minpoly R B.gen with hP
  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  haveI : NoZeroSMulDivisors R L := NoZeroSMulDivisors.trans R K L
  let _ := P.map (algebraMap R L)
  rw [adjoin_singleton_eq_range_aeval] at hz
  obtain ‚ü®Q‚ÇÅ, hQ‚ü© := hz
  set Q := Q‚ÇÅ %‚Çò P with hQ‚ÇÅ
  replace hQ : aeval B.gen Q = p ‚Ä¢ z := by
    rw [‚Üê modByMonic_add_div Q‚ÇÅ (minpoly.monic hBint)] at hQ
    simpa using hQ
  by_cases hQzero : Q = 0
  ¬∑ simp only [hQzero, Algebra.smul_def, zero_eq_mul, aeval_zero] at hQ
    cases' hQ with H H‚ÇÅ
    ¬∑ have : Function.Injective (algebraMap R L) := by
        rw [algebraMap_eq R K L]
        exact (algebraMap K L).injective.comp (IsFractionRing.injective R K)
      exfalso
      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)
    ¬∑ rw [H‚ÇÅ]
      exact Subalgebra.zero_mem _
  refine mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => ?_) hQ
  induction' i using Nat.case_strong_induction_on with j hind
  ¬∑ intro _
    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt hp hBint hQ hzint hei
  ¬∑ intro hj
    convert hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd (n := n) _ hndiv
    have H := degree_modByMonic_lt Q‚ÇÅ (minpoly.monic hBint)
    rw [‚Üê hQ‚ÇÅ, ‚Üê hP] at H
    replace H := Nat.lt_iff_add_one_le.1
      (lt_of_lt_of_le
        (lt_of_le_of_lt (Nat.lt_iff_add_one_le.1 (Nat.lt_of_succ_lt_succ (mem_range.1 hj)))
          (lt_succ_self _)) (Nat.lt_iff_add_one_le.1 ((natDegree_lt_natDegree_iff hQzero).2 H)))
    have Hj : Q.natDegree + 1 = j + 1 + (Q.natDegree - j) := by
      rw [‚Üê add_comm 1, ‚Üê add_comm 1, add_assoc, add_right_inj,
        ‚Üê Nat.add_sub_assoc (Nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm,
        Nat.add_sub_cancel]
    choose! g hg using hind
    replace hg : ‚àÄ k ‚àà range (j + 1), Q.coeff k ‚Ä¢ B.gen ^ k =
        algebraMap R L p * g k ‚Ä¢ B.gen ^ k := by
      intro k hk
      rw [hg k (mem_range_succ_iff.1 hk)
        (mem_range_succ_iff.2
          (le_trans (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),
        Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, mul_assoc]
    choose! f hf using
      IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)
        (minpoly.monic hBint) hei.isWeaklyEisensteinAt
    have hf‚ÇÅ : ‚àÄ k ‚àà (range (Q.natDegree - j)).erase 0,
        Q.coeff (j + 1 + k) ‚Ä¢ B.gen ^ (j + 1 + k) * B.gen ^ (P.natDegree - (j + 2)) =
        (algebraMap R L) p * Q.coeff (j + 1 + k) ‚Ä¢ f (k + P.natDegree - 1) := by
      intro k hk
      rw [smul_mul_assoc, ‚Üê pow_add, ‚Üê Nat.add_sub_assoc H, add_comm (j + 1) 1,
        add_assoc (j + 1), add_comm _ (k + P.natDegree), Nat.add_sub_add_right,
        ‚Üê (hf (k + P.natDegree - 1) _).2, mul_smul_comm]
      rw [(minpoly.monic hBint).natDegree_map, add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact Nat.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    suffices
        p ^ n.succ ‚à£ Q.coeff (succ j) ^ n.succ *
          (minpoly R B.gen).coeff 0 ^ (succ j + (P.natDegree - (j + 2))) by
      convert this
      rw [Nat.succ_eq_add_one, add_assoc, ‚Üê Nat.add_sub_assoc H, add_comm (j + 1),
        Nat.add_sub_add_left, ‚Üê Nat.add_sub_assoc, Nat.add_sub_add_left, hP, ‚Üê
        (minpoly.monic hBint).natDegree_map (algebraMap R K), ‚Üê
        minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, natDegree_minpoly, hn, Nat.sub_one,
        Nat.pred_succ]
      omega
    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_addLeftEmbedding _ _),
      sum_congr rfl hg, add_comm] at hQ
    replace hQ := congr_arg (fun x => x * B.gen ^ (P.natDegree - (j + 2))) hQ
    simp_rw [sum_map, addLeftEmbedding_apply, add_mul, sum_mul, mul_assoc] at hQ
    rw [‚Üê insert_erase
      (mem_range.2 (tsub_pos_iff_lt.2 <| Nat.lt_of_succ_lt_succ <| mem_range.1 hj)),
      sum_insert (not_mem_erase 0 _), add_zero, sum_congr rfl hf‚ÇÅ, ‚Üê mul_sum, ‚Üê mul_sum, add_assoc,
      ‚Üê mul_add, smul_mul_assoc, ‚Üê pow_add, Algebra.smul_def] at hQ
    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)
    have hintsum : IsIntegral R (z * B.gen ^ (P.natDegree - (j + 2)) -
        (‚àë x ‚àà (range (Q.natDegree - j)).erase 0,
          Q.coeff (j + 1 + x) ‚Ä¢ f (x + P.natDegree - 1) +
            ‚àë x ‚àà range (j + 1), g x ‚Ä¢ B.gen ^ x * B.gen ^ (P.natDegree - (j + 2)))) := by
      refine (hzint.mul (hBint.pow _)).sub
        (.add (.sum _ fun k hk => .smul _ ?_)
          (.sum _ fun k _ => .mul (.smul _ (.pow hBint _)) (hBint.pow _)))
      refine adjoin_le_integralClosure hBint (hf _ ?_).1
      rw [(minpoly.monic hBint).natDegree_map (algebraMap R L)]
      rw [add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]
      ¬∑ exact _root_.zero_le _
      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_
        rw [h] at hk
        simp at hk
    obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)
    rw [Algebra.smul_def, mul_assoc, ‚Üê mul_sub, _root_.map_mul, algebraMap_apply R K L, map_pow,
      Algebra.norm_algebraMap, _root_.map_mul, algebraMap_apply R K L, Algebra.norm_algebraMap,
      finrank B, ‚Üê hr, PowerBasis.norm_gen_eq_coeff_zero_minpoly,
      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map,
      show (-1 : K) = algebraMap R K (-1) by simp, ‚Üê map_pow, ‚Üê map_pow, ‚Üê _root_.map_mul, ‚Üê
      map_pow, ‚Üê _root_.map_mul, ‚Üê map_pow, ‚Üê _root_.map_mul] at hQ
    have hppdiv : p ^ B.dim ‚à£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _
    rwa [‚Üê IsFractionRing.injective R K hQ, mul_comm, ‚Üê Units.coe_neg_one, mul_pow, ‚Üê
      Units.val_pow_eq_pow_val, ‚Üê Units.val_pow_eq_pow_val, mul_assoc,
      Units.dvd_mul_left, mul_comm, ‚Üê Nat.succ_eq_add_one, hn] at hppdiv"
Mathlib/RingTheory/RootsOfUnity/Basic.lean,IsPrimitiveRoot.card_primitiveRoots,card_primitiveRoots,0ef23fba776dbe5bb848bbfc3337bedef4a59c82,":= by
  by_cases h0 : k = 0
  ¬∑ simp [h0]
  symm
  refine Finset.card_congr (fun i _ => Œ∂ ^ i) ?_ ?_ ?_
  ¬∑ simp only [true_and_iff, and_imp, mem_filter, mem_range, mem_univ]
    rintro i - hi
    rw [mem_primitiveRoots (Nat.pos_of_ne_zero h0)]
    exact h.pow_of_coprime i hi.symm
  ¬∑ simp only [true_and_iff, and_imp, mem_filter, mem_range, mem_univ]
    rintro i j hi - hj - H
    exact h.pow_inj hi hj H
  ¬∑ simp only [exists_prop, true_and_iff, mem_filter, mem_range, mem_univ]
    intro Œæ hŒæ
    rw [mem_primitiveRoots (Nat.pos_of_ne_zero h0),
      h.isPrimitiveRoot_iff (Nat.pos_of_ne_zero h0)] at hŒæ
    rcases hŒæ with ‚ü®i, hin, hi, H‚ü©
    exact ‚ü®i, ‚ü®hin, hi.symm‚ü©, H‚ü©","warning:  `Finset.card_congr` has been deprecated, use `Finset.card_bij` instead
error:  application type mismatch
  pow_inj h hi
argument
  hi
has type
  k.Coprime i : Prop
but is expected to have type
  i < k : Prop
error:  unknown identifier 'hj'
error:  unknown identifier 'H'","theorem card_primitiveRoots {Œ∂ : R} {k : ‚Ñï} (h : IsPrimitiveRoot Œ∂ k) :
    (primitiveRoots k R).card = œÜ k ",":= by
  by_cases h0 : k = 0
  ¬∑ simp [h0]
  symm
  refine Finset.card_bij (fun i _ ‚Ü¶ Œ∂ ^ i) ?_ ?_ ?_
  ¬∑ simp only [true_and_iff, and_imp, mem_filter, mem_range, mem_univ]
    rintro i - hi
    rw [mem_primitiveRoots (Nat.pos_of_ne_zero h0)]
    exact h.pow_of_coprime i hi.symm
  ¬∑ simp only [true_and_iff, and_imp, mem_filter, mem_range, mem_univ]
    rintro i hi - j hj - H
    exact h.pow_inj hi hj H
  ¬∑ simp only [exists_prop, true_and_iff, mem_filter, mem_range, mem_univ]
    intro Œæ hŒæ
    rw [mem_primitiveRoots (Nat.pos_of_ne_zero h0),
      h.isPrimitiveRoot_iff (Nat.pos_of_ne_zero h0)] at hŒæ
    rcases hŒæ with ‚ü®i, hin, hi, H‚ü©
    exact ‚ü®i, ‚ü®hin, hi.symm‚ü©, H‚ü©"
Mathlib/Data/Nat/Factorial/Basic.lean,Nat.succ_ascFactorial,succ_ascFactorial,dc0b2fb410ce57ee8ea5b9ce5b357ce030465e7a,"  | 0 => by rw [Nat.add_zero, ascFactorial_zero, ascFactorial_zero]
  | k + 1 => by rw [ascFactorial, Nat.mul_left_comm, succ_ascFactorial n k, ascFactorial, succ_add,
    Nat.add_assoc']","error:  unknown constant 'Nat.add_assoc''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.10558
n k : ‚Ñï
‚ä¢ (n + k).succ * ((n + k) * n.ascFactorial k) = (n + (k + 1)) * ((n + k) * n.ascFactorial k)","theorem succ_ascFactorial (n : ‚Ñï) :
    ‚àÄ k, n * n.succ.ascFactorial k = (n + k) * n.ascFactorial k
","  | 0 => by rw [Nat.add_zero, ascFactorial_zero, ascFactorial_zero]
  | k + 1 => by rw [ascFactorial, Nat.mul_left_comm, succ_ascFactorial n k, ascFactorial, succ_add,
    ‚Üê Nat.add_assoc]"
Mathlib/Probability/Martingale/Convergence.lean,MeasureTheory.Submartingale.ae_tendsto_limitProcess,Submartingale.ae_tendsto_limitProcess,be55166c883a8ce6c537d5f0d2dd43baed489981,":= by
  classical
  suffices
      ‚àÉ g, StronglyMeasurable[‚®Ü n, ‚Ñ± n] g ‚àß ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù c) then h.choose else 0
  have hle : (‚®Ü n, ‚Ñ± n) ‚â§ m0 := sSup_le fun m ‚ü®n, hn‚ü© => hn ‚ñ∏ ‚Ñ±.le _
  have hg' : ‚àÄ·µê œâ ‚àÇŒº.trim hle, Tendsto (fun n => f n œâ) atTop (ùìù (g' œâ)) := by
    filter_upwards [hf.exists_ae_trim_tendsto_of_bdd hbdd] with œâ hœâ
    simp_rw [dif_pos hœâ]
    exact hœâ.choose_spec
  have hg'm : @AEStronglyMeasurable _ _ _ (‚®Ü n, ‚Ñ± n) g' (Œº.trim hle) :=
    (@aemeasurable_of_tendsto_metrizable_ae' _ _ (‚®Ü n, ‚Ñ± n) _ _ _ _ _ _ _
      (fun n => ((hf.stronglyMeasurable n).measurable.mono (le_sSup ‚ü®n, rfl‚ü© : ‚Ñ± n ‚â§ ‚®Ü n, ‚Ñ± n)
        le_rfl).aemeasurable) hg').aestronglyMeasurable
  obtain ‚ü®g, hgm, hae‚ü© := hg'm
  have hg : ‚àÄ·µê œâ ‚àÇŒº.trim hle, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) := by
    filter_upwards [hae, hg'] with œâ hœâ hg'œâ
    exact hœâ ‚ñ∏ hg'œâ
  exact ‚ü®g, hgm, measure_eq_zero_of_trim_eq_zero hle hg‚ü©",error:  simp made no progress,"theorem Submartingale.ae_tendsto_limitProcess [IsFiniteMeasure Œº] (hf : Submartingale f ‚Ñ± Œº)
    (hbdd : ‚àÄ n, snorm (f n) 1 Œº ‚â§ R) :
    ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => f n œâ) atTop (ùìù (‚Ñ±.limitProcess f Œº œâ)) ",":= by
  classical
  suffices
      ‚àÉ g, StronglyMeasurable[‚®Ü n, ‚Ñ± n] g ‚àß ‚àÄ·µê œâ ‚àÇŒº, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) by
    rw [limitProcess, dif_pos this]
    exact (Classical.choose_spec this).2
  set g' : Œ© ‚Üí ‚Ñù := fun œâ => if h : ‚àÉ c, Tendsto (fun n => f n œâ) atTop (ùìù c) then h.choose else 0
  have hle : ‚®Ü n, ‚Ñ± n ‚â§ m0 := sSup_le fun m ‚ü®n, hn‚ü© => hn ‚ñ∏ ‚Ñ±.le _
  have hg' : ‚àÄ·µê œâ ‚àÇŒº.trim hle, Tendsto (fun n => f n œâ) atTop (ùìù (g' œâ)) := by
    filter_upwards [hf.exists_ae_trim_tendsto_of_bdd hbdd] with œâ hœâ
    simp_rw [g', dif_pos hœâ]
    exact hœâ.choose_spec
  have hg'm : @AEStronglyMeasurable _ _ _ (‚®Ü n, ‚Ñ± n) g' (Œº.trim hle) :=
    (@aemeasurable_of_tendsto_metrizable_ae' _ _ (‚®Ü n, ‚Ñ± n) _ _ _ _ _ _ _
      (fun n => ((hf.stronglyMeasurable n).measurable.mono (le_sSup ‚ü®n, rfl‚ü© : ‚Ñ± n ‚â§ ‚®Ü n, ‚Ñ± n)
        le_rfl).aemeasurable) hg').aestronglyMeasurable
  obtain ‚ü®g, hgm, hae‚ü© := hg'm
  have hg : ‚àÄ·µê œâ ‚àÇŒº.trim hle, Tendsto (fun n => f n œâ) atTop (ùìù (g œâ)) := by
    filter_upwards [hae, hg'] with œâ hœâ hg'œâ
    exact hœâ ‚ñ∏ hg'œâ
  exact ‚ü®g, hgm, measure_eq_zero_of_trim_eq_zero hle hg‚ü©"
Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean,CategoryTheory.Equalizer.Sieve.SecondObj.ext,SecondObj.ext,f76dc92a63457a8b36463cee1fe33a048c0ba0ce,":= by
  apply Limits.Types.limit_ext
  rintro ‚ü®i‚ü©
  exact h i","error:  application type mismatch
  h i
argument
  i
has type
  (Y : C) √ó (Z : C) √ó (_ : Z ‚ü∂ Y) √ó { f' // S.arrows f' } : Type (max u v u)
but is expected to have type
  C : Type u","lemma SecondObj.ext (z‚ÇÅ z‚ÇÇ : SecondObj P S) (h : ‚àÄ (Y Z : C) (g : Z ‚ü∂ Y) (f : Y ‚ü∂ X)
    (hf : S.arrows f), (Pi.œÄ _ ‚ü®Y, Z, g, f, hf‚ü© : SecondObj P S ‚ü∂ _) z‚ÇÅ =
      (Pi.œÄ _ ‚ü®Y, Z, g, f, hf‚ü© : SecondObj P S ‚ü∂ _) z‚ÇÇ) : z‚ÇÅ = z‚ÇÇ ",":= by
  apply Limits.Types.limit_ext
  rintro ‚ü®‚ü®Y, Z, g, f, hf‚ü©‚ü©
  apply h"
Mathlib/MeasureTheory/Integral/FundThmCalculus.lean,intervalIntegral.sub_le_integral_of_hasDeriv_right_of_le,sub_le_integral_of_hasDeriv_right_of_le,49ee3b274b8d6dca510739494eb2ff0d0e484e8f,":= by
  refine' le_of_forall_pos_le_add fun Œµ Œµpos => _
  rcases exists_lt_lowerSemicontinuous_integral_lt œÜ œÜint Œµpos with
    ‚ü®G', f_lt_G', G'cont, G'int, G'lt_top, hG'‚ü©
  set s := {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} ‚à© Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, ‚à´ u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [‚Üê uIcc_of_le hab] at G'int hcont ‚ä¢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b ‚äÜ {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain ‚ü®y, g'_lt_y', y_lt_G'‚ü© : ‚àÉ y : ‚Ñù, (g' t : EReal) < y ‚àß (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hœÜg t ht.2)).trans_lt (f_lt_G' t))
    have I1 : ‚àÄ·∂† u in ùìù[>] t, (u - t) * y ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      have B : ‚àÄ·∂† u in ùìù t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with ‚ü®m, M, ‚ü®hm, hM‚ü©, H‚ü©
      have : Ioo t (min M b) ‚àà ùìù[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u ‚äÜ Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = ‚à´ _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ ‚â§ ‚à´ w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, ‚Üê integral_Icc_eq_integral_Ioc]
          apply set_integral_mono_ae_restrict
          ¬∑ simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          ¬∑ exact IntegrableOn.mono_set G'int I
          ¬∑ have C1 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), G' x < ‚àû :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), x ‚àà Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x ‚àà Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t ‚ü®ht.2.1, ht.2.2‚ü©).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [‚Üê smul_eq_mul, sub_smul_slope] at this
    have I3 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : ‚àÄ·∂† u in ùìù[>] t, u ‚àà Ioc t (min v b) := by
      refine' mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 ‚ü®min v b, _, Subset.rfl‚ü©
      simp only [lt_min_iff, mem_Ioi]
      exact ‚ü®t_lt_v, ht.2.2‚ü©
    rcases (I3.and I4).exists with ‚ü®x, hx, h'x‚ü©
    refine' ‚ü®x, _, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x‚ü©
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ ‚â§ (‚à´ w in a..t, (G' w).toReal) + ‚à´ w in t..x, (G' w).toReal := (add_le_add ht.1 hx)
      _ = ‚à´ w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        ¬∑ rw [intervalIntegrable_iff_integrable_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        ¬∑ rw [intervalIntegrable_iff_integrable_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a ‚â§ ‚à´ y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ ‚â§ (‚à´ y in a..b, œÜ y) + Œµ := by
      convert hG'.le <;>
        ¬∑ rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]","error:  simp made no progress
warning:  `MeasureTheory.set_integral_mono_ae_restrict` has been deprecated, use `MeasureTheory.setIntegral_mono_ae_restrict` instead
error:  unknown identifier 'intervalIntegrable_iff_integrable_Ioc_of_le'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.311191
case hab
Œπ : Type u_1
ùïú : Type u_2
E : Type u_3
F : Type u_4
A : Type u_5
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚Ñù E
f : ‚Ñù ‚Üí E
g' g œÜ : ‚Ñù ‚Üí ‚Ñù
a b : ‚Ñù
hab : a ‚â§ b
hcont : ContinuousOn g (Icc a b)
hderiv : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x
œÜint : IntegrableOn œÜ (Icc a b) volume
hœÜg : ‚àÄ x ‚àà Ico a b, g' x ‚â§ œÜ x
Œµ : ‚Ñù
Œµpos : 0 < Œµ
G' : ‚Ñù ‚Üí EReal
f_lt_G' : ‚àÄ (x : ‚Ñù), ‚Üë(œÜ x) < G' x
G'cont : LowerSemicontinuous G'
G'int : Integrable (fun x ‚Ü¶ (G' x).toReal) (volume.restrict (Icc a b))
G'lt_top : ‚àÄ·µê (x : ‚Ñù) ‚àÇvolume.restrict (Icc a b), G' x < ‚ä§
hG' : ‚à´ (x : ‚Ñù) in Icc a b, (G' x).toReal ‚àÇvolume < ‚à´ (x : ‚Ñù) in Icc a b, œÜ x ‚àÇvolume + Œµ
s : Set ‚Ñù := {t | g t - g a ‚â§ ‚à´ (u : ‚Ñù) in a..t, (G' u).toReal} ‚à© Icc a b
s_closed : IsClosed s
t : ‚Ñù
ht : t ‚àà {t | g t - g a ‚â§ ‚à´ (u : ‚Ñù) in a..t, (G' u).toReal} ‚à© Ico a b
v : ‚Ñù
t_lt_v : v ‚àà Ioi t
y : ‚Ñù
g'_lt_y' : ‚Üë(g' t) < ‚Üëy
y_lt_G' : ‚Üëy < G' t
I1 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, (u - t) * y ‚â§ ‚à´ (w : ‚Ñù) in t..u, (G' w).toReal
I2 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, g u - g t ‚â§ (u - t) * y
I3 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, g u - g t ‚â§ ‚à´ (w : ‚Ñù) in t..u, (G' w).toReal
I4 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, u ‚àà Ioc t (min v b)
x : ‚Ñù
hx : g x - g t ‚â§ ‚à´ (w : ‚Ñù) in t..x, (G' w).toReal
h'x : x ‚àà Ioc t (min v b)
‚ä¢ IntervalIntegrable (fun x ‚Ü¶ (G' x).toReal) volume a t
error:  unknown identifier 'intervalIntegrable_iff_integrable_Ioc_of_le'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.311193
case hbc
Œπ : Type u_1
ùïú : Type u_2
E : Type u_3
F : Type u_4
A : Type u_5
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚Ñù E
f : ‚Ñù ‚Üí E
g' g œÜ : ‚Ñù ‚Üí ‚Ñù
a b : ‚Ñù
hab : a ‚â§ b
hcont : ContinuousOn g (Icc a b)
hderiv : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x
œÜint : IntegrableOn œÜ (Icc a b) volume
hœÜg : ‚àÄ x ‚àà Ico a b, g' x ‚â§ œÜ x
Œµ : ‚Ñù
Œµpos : 0 < Œµ
G' : ‚Ñù ‚Üí EReal
f_lt_G' : ‚àÄ (x : ‚Ñù), ‚Üë(œÜ x) < G' x
G'cont : LowerSemicontinuous G'
G'int : Integrable (fun x ‚Ü¶ (G' x).toReal) (volume.restrict (Icc a b))
G'lt_top : ‚àÄ·µê (x : ‚Ñù) ‚àÇvolume.restrict (Icc a b), G' x < ‚ä§
hG' : ‚à´ (x : ‚Ñù) in Icc a b, (G' x).toReal ‚àÇvolume < ‚à´ (x : ‚Ñù) in Icc a b, œÜ x ‚àÇvolume + Œµ
s : Set ‚Ñù := {t | g t - g a ‚â§ ‚à´ (u : ‚Ñù) in a..t, (G' u).toReal} ‚à© Icc a b
s_closed : IsClosed s
t : ‚Ñù
ht : t ‚àà {t | g t - g a ‚â§ ‚à´ (u : ‚Ñù) in a..t, (G' u).toReal} ‚à© Ico a b
v : ‚Ñù
t_lt_v : v ‚àà Ioi t
y : ‚Ñù
g'_lt_y' : ‚Üë(g' t) < ‚Üëy
y_lt_G' : ‚Üëy < G' t
I1 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, (u - t) * y ‚â§ ‚à´ (w : ‚Ñù) in t..u, (G' w).toReal
I2 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, g u - g t ‚â§ (u - t) * y
I3 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, g u - g t ‚â§ ‚à´ (w : ‚Ñù) in t..u, (G' w).toReal
I4 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, u ‚àà Ioc t (min v b)
x : ‚Ñù
hx : g x - g t ‚â§ ‚à´ (w : ‚Ñù) in t..x, (G' w).toReal
h'x : x ‚àà Ioc t (min v b)
‚ä¢ IntervalIntegrable (fun x ‚Ü¶ (G' x).toReal) volume t x","theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a ‚â§ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (œÜint : IntegrableOn œÜ (Icc a b)) (hœÜg : ‚àÄ x ‚àà Ico a b, g' x ‚â§ œÜ x) :
    g b - g a ‚â§ ‚à´ y in a..b, œÜ y ",":= by
  refine le_of_forall_pos_le_add fun Œµ Œµpos => ?_
  rcases exists_lt_lowerSemicontinuous_integral_lt œÜ œÜint Œµpos with
    ‚ü®G', f_lt_G', G'cont, G'int, G'lt_top, hG'‚ü©
  set s := {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} ‚à© Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, ‚à´ u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [‚Üê uIcc_of_le hab] at G'int hcont ‚ä¢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [s, inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b ‚äÜ {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain ‚ü®y, g'_lt_y', y_lt_G'‚ü© : ‚àÉ y : ‚Ñù, (g' t : EReal) < y ‚àß (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hœÜg t ht.2)).trans_lt (f_lt_G' t))
    have I1 : ‚àÄ·∂† u in ùìù[>] t, (u - t) * y ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      have B : ‚àÄ·∂† u in ùìù t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with ‚ü®m, M, ‚ü®hm, hM‚ü©, H‚ü©
      have : Ioo t (min M b) ‚àà ùìù[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u ‚äÜ Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = ‚à´ _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ ‚â§ ‚à´ w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, ‚Üê integral_Icc_eq_integral_Ioc]
          apply setIntegral_mono_ae_restrict
          ¬∑ simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          ¬∑ exact IntegrableOn.mono_set G'int I
          ¬∑ have C1 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), G' x < ‚àû :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), x ‚àà Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x ‚àà Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t ‚ü®ht.2.1, ht.2.2‚ü©).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [‚Üê smul_eq_mul, sub_smul_slope] at this
    have I3 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : ‚àÄ·∂† u in ùìù[>] t, u ‚àà Ioc t (min v b) := by
      refine mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 ‚ü®min v b, ?_, Subset.rfl‚ü©
      simp only [lt_min_iff, mem_Ioi]
      exact ‚ü®t_lt_v, ht.2.2‚ü©
    rcases (I3.and I4).exists with ‚ü®x, hx, h'x‚ü©
    refine ‚ü®x, ?_, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x‚ü©
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ ‚â§ (‚à´ w in a..t, (G' w).toReal) + ‚à´ w in t..x, (G' w).toReal := add_le_add ht.1 hx
      _ = ‚à´ w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        ¬∑ rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        ¬∑ rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a ‚â§ ‚à´ y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ ‚â§ (‚à´ y in a..b, œÜ y) + Œµ := by
      convert hG'.le <;>
        ¬∑ rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]"
Mathlib/Computability/TMToPartrec.lean,Turing.PartrecToTM2.codeSupp'_self,codeSupp'_self,67ee3b7709353762fdc01cfb00722ee8c27ff6a5,":= by
  cases c <;> first |rfl|exact Finset.subset_union_left _ _","error:  function expected at
  Finset.subset_union_left ?m.330295
term has type
  ?m.330294 ‚àà ?m.330292 ‚à™ ?m.330293
error:  function expected at
  Finset.subset_union_left ?m.330860
term has type
  ?m.330859 ‚àà ?m.330857 ‚à™ ?m.330858
error:  function expected at
  Finset.subset_union_left ?m.331825
term has type
  ?m.331824 ‚àà ?m.331822 ‚à™ ?m.331823
error:  function expected at
  Finset.subset_union_left ?m.332389
term has type
  ?m.332388 ‚àà ?m.332386 ‚à™ ?m.332387",theorem codeSupp'_self (c k) : trStmts‚ÇÅ (trNormal c k) ‚äÜ codeSupp' c k ,":= by
  cases c <;> first | rfl | exact Finset.union_subset_left (fun _ a ‚Ü¶ a)"
Mathlib/Analysis/Calculus/TangentCone.lean,mem_tangentCone_of_openSegment_subset,mem_tangentCone_of_openSegment_subset,ce64ef0d23c361a1b9665a31c320629abe7579db,":= by
  let c := fun n : ‚Ñï => (2 : ‚Ñù) ^ (n + 1)
  let d := fun n : ‚Ñï => (c n)‚Åª¬π ‚Ä¢ (y - x)
  refine' ‚ü®c, d, Filter.univ_mem' fun n => h _, _, _‚ü©
  show x + d n ‚àà openSegment ‚Ñù x y
  ¬∑ rw [openSegment_eq_image]
    refine' ‚ü®(c n)‚Åª¬π, ‚ü®_, _‚ü©, _‚ü©
    ¬∑ rw [inv_pos]
      apply pow_pos
      norm_num
    ¬∑ apply inv_lt_one
      apply one_lt_pow _ (Nat.succ_ne_zero _)
      norm_num
    ¬∑ simp only [sub_smul, smul_sub, one_smul]
      abel
  show Filter.Tendsto (fun n : ‚Ñï => ‚Äñc n‚Äñ) Filter.atTop Filter.atTop
  ¬∑ have : (fun n : ‚Ñï => ‚Äñc n‚Äñ) = c := by
      ext n
      exact abs_of_nonneg (pow_nonneg (by norm_num) _)
    rw [this]
    exact (tendsto_pow_atTop_atTop_of_one_lt (by norm_num)).comp (tendsto_add_atTop_nat 1)
  show Filter.Tendsto (fun n : ‚Ñï => c n ‚Ä¢ d n) Filter.atTop (ùìù (y - x))
  ¬∑ have : (fun n : ‚Ñï => c n ‚Ä¢ d n) = fun _ => y - x := by
      ext n
      simp only [smul_smul]
      rw [mul_inv_cancel, one_smul]
      exact pow_ne_zero _ (by norm_num)
    rw [this]
    apply tendsto_const_nhds","info:  Try this: abel_nf
error:  unsolved goals
case refine'_1.refine'_3
ùïú : Type u_1
inst‚úù‚Å∂ : NontriviallyNormedField ùïú
E : Type u_2
inst‚úù‚Åµ : NormedAddCommGroup E
inst‚úù‚Å¥ : NormedSpace ùïú E
F : Type u_3
inst‚úù¬≥ : NormedAddCommGroup F
inst‚úù¬≤ : NormedSpace ùïú F
G : Type u_4
inst‚úù¬π : NormedAddCommGroup G
inst‚úù : NormedSpace ‚Ñù G
x‚úù y‚úù : E
s‚úù t : Set E
s : Set G
x y : G
h : openSegment ‚Ñù x y ‚äÜ s
c : ‚Ñï ‚Üí ‚Ñù := fun n ‚Ü¶ 2 ^ (n + 1)
d : ‚Ñï ‚Üí G := fun n ‚Ü¶ (c n)‚Åª¬π ‚Ä¢ (y - x)
n : ‚Ñï
‚ä¢ x + (-1 ‚Ä¢ (c n)‚Åª¬π ‚Ä¢ x + (c n)‚Åª¬π ‚Ä¢ y) = x + d n
error:  simp made no progress","theorem mem_tangentCone_of_openSegment_subset {s : Set G} {x y : G} (h : openSegment ‚Ñù x y ‚äÜ s) :
    y - x ‚àà tangentConeAt ‚Ñù s x ",":= by
  refine mem_tangentConeAt_of_pow_smul one_half_pos.ne' (by norm_num) ?_
  refine (eventually_ne_atTop 0).mono fun n hn ‚Ü¶ (h ?_)
  rw [openSegment_eq_image]
  refine ‚ü®(1 / 2) ^ n, ‚ü®?_, ?_‚ü©, ?_‚ü©
  ¬∑ exact pow_pos one_half_pos _
  ¬∑ exact pow_lt_one one_half_pos.le one_half_lt_one hn
  ¬∑ simp only [sub_smul, one_smul, smul_sub]; abel"
Mathlib/Algebra/Order/Module/Defs.lean,inv_smul_le_iff_of_neg,inv_smul_le_iff_of_neg,299792d941f0a59647d1864dd577af60b4b0228f,":= by
  rw [‚Üê smul_le_smul_iff_of_neg h, smul_inv_smul‚ÇÄ h.ne]","error:  unknown identifier 'smul_le_smul_iff_of_neg'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.432650
Œ± : Type u_1
Œ≤ : Type u_2
a‚úù a‚ÇÅ a‚ÇÇ : Œ±
b b‚ÇÅ‚úù b‚ÇÇ‚úù : Œ≤
inst‚úù¬≥ : LinearOrderedField Œ±
inst‚úù¬≤ : OrderedAddCommGroup Œ≤
inst‚úù¬π : Module Œ± Œ≤
a : Œ±
b‚ÇÅ b‚ÇÇ : Œ≤
inst‚úù : PosSMulMono Œ± Œ≤
h : a < 0
‚ä¢ a‚Åª¬π ‚Ä¢ b‚ÇÅ ‚â§ b‚ÇÇ ‚Üî a ‚Ä¢ b‚ÇÇ ‚â§ b‚ÇÅ",lemma inv_smul_le_iff_of_neg (h : a < 0) : a‚Åª¬π ‚Ä¢ b‚ÇÅ ‚â§ b‚ÇÇ ‚Üî a ‚Ä¢ b‚ÇÇ ‚â§ b‚ÇÅ ,":= by
  rw [‚Üê smul_le_smul_iff_of_neg_left h, smul_inv_smul‚ÇÄ h.ne]"
Mathlib/CategoryTheory/Sites/Over.lean,CategoryTheory.GrothendieckTopology.over_map_compatiblePreserving,over_map_compatiblePreserving,9072ff84a0d139a344bf9eed4a00c4cd27596c79,"  Compatible {F Z T x hx Y‚ÇÅ Y‚ÇÇ W f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ h} := by
    let W' : Over X := Over.mk (f‚ÇÅ.left ‚â´ Y‚ÇÅ.hom)
    let g‚ÇÅ' : W' ‚ü∂ Y‚ÇÅ := Over.homMk f‚ÇÅ.left
    let g‚ÇÇ' : W' ‚ü∂ Y‚ÇÇ := Over.homMk f‚ÇÇ.left
      (by simpa using (Over.forget _).congr_map h.symm =‚â´ Z.hom)
    let e : (Over.map f).obj W' ‚âÖ W := Over.isoMk (Iso.refl _)
      (by simpa using (Over.w f‚ÇÅ).symm)
    convert congr_arg (F.val.map e.inv.op)
      (hx g‚ÇÅ' g‚ÇÇ' hg‚ÇÅ hg‚ÇÇ (by ext; exact (Over.forget _).congr_map h)) using 1
    all_goals
      dsimp
      rw [‚Üê FunctorToTypes.map_comp_apply]
      apply congr_fun
      congr 1
      rw [‚Üê op_comp]
      congr 1
      ext
      simp",error:  'Compatible' is not a field of structure 'CategoryTheory.CompatiblePreserving',"lemma over_map_compatiblePreserving {X Y : C} (f : X ‚ü∂ Y) :
    CompatiblePreserving (J.over Y) (Over.map f) where
","  compatible {F Z T x hx Y‚ÇÅ Y‚ÇÇ W f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ h} := by
    let W' : Over X := Over.mk (f‚ÇÅ.left ‚â´ Y‚ÇÅ.hom)
    let g‚ÇÅ' : W' ‚ü∂ Y‚ÇÅ := Over.homMk f‚ÇÅ.left
    let g‚ÇÇ' : W' ‚ü∂ Y‚ÇÇ := Over.homMk f‚ÇÇ.left
      (by simpa using (Over.forget _).congr_map h.symm =‚â´ Z.hom)
    let e : (Over.map f).obj W' ‚âÖ W := Over.isoMk (Iso.refl _)
      (by simpa [W'] using (Over.w f‚ÇÅ).symm)
    convert congr_arg (F.val.map e.inv.op)
      (hx g‚ÇÅ' g‚ÇÇ' hg‚ÇÅ hg‚ÇÇ (by ext; exact (Over.forget _).congr_map h)) using 1
    all_goals
      dsimp [e, W', g‚ÇÅ', g‚ÇÇ']
      rw [‚Üê FunctorToTypes.map_comp_apply]
      apply congr_fun
      congr 1
      rw [‚Üê op_comp]
      congr 1
      ext
      simp"
Mathlib/Data/Nat/Factorization/Basic.lean,Nat.factorization_one,factorization_one,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,:= by decide,"error:  tactic 'decide' failed for proposition
  factorization 1 = 0
since its 'Decidable' instance reduced to
  Decidable.rec (fun h ‚Ü¶ (fun hp ‚Ü¶ isFalse ‚ãØ) h) (fun h ‚Ü¶ (fun hp ‚Ü¶ isTrue ‚ãØ) h) instDecidableAnd
rather than to the 'isTrue' constructor.",theorem factorization_one : factorization 1 = 0 ,:= by ext; simp [factorization]
Mathlib/ModelTheory/Skolem.lean,FirstOrder.Language.exists_elementarySubstructure_card_eq,exists_elementarySubstructure_card_eq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain ‚ü®s', hs'‚ü© := Cardinal.le_mk_iff_exists_set.1 h4
  rw [‚Üê aleph0_le_lift.{_, w}] at h1
  rw [‚Üê hs'] at h1 h2 ‚ä¢
  refine'
    ‚ü®elementarySkolem‚ÇÅReduct (closure (L.sum L.skolem‚ÇÅ) (s ‚à™ Equiv.ulift '' s')),
      (s.subset_union_left _).trans subset_closure, _‚ü©
  have h := mk_image_eq_lift _ s' Equiv.ulift.injective
  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h
  rw [coeSort_elementarySkolem‚ÇÅReduct, ‚Üê h, lift_inj]
  refine'
    le_antisymm (lift_le.1 (lift_card_closure_le.trans _))
      (mk_le_mk_of_subset ((Set.subset_union_right _ _).trans subset_closure))
  rw [max_le_iff, aleph0_le_lift, ‚Üê aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]
  refine' ‚ü®h1, (mk_union_le _ _).trans _, (lift_le.2 card_functions_sum_skolem‚ÇÅ_le).trans _‚ü©
  ¬∑ rw [‚Üê lift_le, lift_add, h, add_comm, add_eq_max h1]
    exact max_le le_rfl h2
  ¬∑ rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, ‚Üê lift_le.{w'},
      lift_lift, lift_lift, ‚Üê aleph0_le_lift, h]
    refine' ‚ü®_, h1‚ü©
    rw [‚Üê lift_lift.{w', w}]
    refine' _root_.trans (lift_le.{w}.2 h3) _
    rw [lift_lift, ‚Üê lift_lift.{w, max u v}, ‚Üê hs', ‚Üê h, lift_lift]
  ¬∑ refine' _root_.trans _ (lift_le.2 (mk_le_mk_of_subset (Set.subset_union_right _ _)))
    rw [aleph0_le_lift, ‚Üê aleph0_le_lift, h]
    exact h1","error:  invalid field 'trans', the environment does not contain 'Membership.mem.trans'
  Set.subset_union_left ?m.26890
has type
  ?m.26889 ‚àà s ‚à™ ?m.26888
error:  invalid field 'trans', the environment does not contain 'Set.Mem.trans'
  Set.subset_union_left ?m.26890
has type
  Set.Mem ?m.26889 (s ‚à™ ?m.26888)
error:  invalid field 'trans', the environment does not contain 'Union.union.trans'
  Set.subset_union_left ?m.26890
has type
  (s ‚à™ ?m.26888) ?m.26889
error:  invalid field 'trans', the environment does not contain 'Set.union.trans'
  Set.subset_union_left ?m.26890
has type
  s.union ?m.26888 ?m.26889
error:  invalid field 'trans', the environment does not contain 'setOf.trans'
  Set.subset_union_left ?m.26890
has type
  {a | a ‚àà s ‚à® a ‚àà ?m.26888} ?m.26889
error:  invalid field 'trans', the environment does not contain 'Or.trans'
  Set.subset_union_left ?m.26890
has type
  ?m.26889 ‚àà s ‚à® ?m.26889 ‚àà ?m.26888
error:  function expected at
  Set.subset_union_right ?m.27688
term has type
  ?m.27687 ‚àà ?m.27685 ‚à™ ?m.27686
error:  function expected at
  Set.subset_union_right ?m.29978
term has type
  ?m.29977 ‚àà ?m.29975 ‚à™ ?m.29976","theorem exists_elementarySubstructure_card_eq (s : Set M) (Œ∫ : Cardinal.{w'}) (h1 : ‚Ñµ‚ÇÄ ‚â§ Œ∫)
    (h2 : Cardinal.lift.{w'} #s ‚â§ Cardinal.lift.{w} Œ∫)
    (h3 : Cardinal.lift.{w'} L.card ‚â§ Cardinal.lift.{max u v} Œ∫)
    (h4 : Cardinal.lift.{w} Œ∫ ‚â§ Cardinal.lift.{w'} #M) :
    ‚àÉ S : L.ElementarySubstructure M, s ‚äÜ S ‚àß Cardinal.lift.{w'} #S = Cardinal.lift.{w} Œ∫ ",":= by
  obtain ‚ü®s', hs'‚ü© := Cardinal.le_mk_iff_exists_set.1 h4
  rw [‚Üê aleph0_le_lift.{_, w}] at h1
  rw [‚Üê hs'] at h1 h2 ‚ä¢
  refine
    ‚ü®elementarySkolem‚ÇÅReduct (closure (L.sum L.skolem‚ÇÅ) (s ‚à™ Equiv.ulift '' s')),
      (s.subset_union_left).trans subset_closure, ?_‚ü©
  have h := mk_image_eq_lift _ s' Equiv.ulift.injective
  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h
  rw [coeSort_elementarySkolem‚ÇÅReduct, ‚Üê h, lift_inj]
  refine
    le_antisymm (lift_le.1 (lift_card_closure_le.trans ?_))
      (mk_le_mk_of_subset ((s.subset_union_right).trans subset_closure))
  rw [max_le_iff, aleph0_le_lift, ‚Üê aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]
  ¬∑ refine ‚ü®h1, (mk_union_le _ _).trans ?_, (lift_le.2 card_functions_sum_skolem‚ÇÅ_le).trans ?_‚ü©
    ¬∑ rw [‚Üê lift_le, lift_add, h, add_comm, add_eq_max h1]
      exact max_le le_rfl h2
    ¬∑ rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, ‚Üê lift_le.{w'},
        lift_lift, lift_lift, ‚Üê aleph0_le_lift, h]
      refine ‚ü®?_, h1‚ü©
      rw [‚Üê lift_lift.{w', w}]
      refine _root_.trans (lift_le.{w}.2 h3) ?_
      rw [lift_lift, ‚Üê lift_lift.{w, max u v}, ‚Üê hs', ‚Üê h, lift_lift]
  ¬∑ refine _root_.trans ?_ (lift_le.2 (mk_le_mk_of_subset Set.subset_union_right))
    rw [aleph0_le_lift, ‚Üê aleph0_le_lift, h]
    exact h1"
Mathlib/Topology/CompactOpen.lean,ContinuousMap.tendsto_nhds_compactOpen,tendsto_nhds_compactOpen,60a00d0d9787466842c2343d950dd31a7483238a,":= by
  simp_rw [compactOpen_eq_mapsTo, tendsto_nhds_generateFrom_iff, forall_image2_iff]; rfl","error:  unknown identifier 'compactOpen_eq_mapsTo'
error:  simp made no progress
warning:  `ContinuousMap.curry'` has been deprecated, use `ContinuousMap.curry` instead","lemma tendsto_nhds_compactOpen {l : Filter Œ±} {f : Œ± ‚Üí C(Y, Z)} {g : C(Y, Z)} :
    Tendsto f l (ùìù g) ‚Üî
      ‚àÄ K, IsCompact K ‚Üí ‚àÄ U, IsOpen U ‚Üí MapsTo g K U ‚Üí ‚àÄ·∂† a in l, MapsTo (f a) K U ",":= by
  simp [nhds_compactOpen]"
Mathlib/Geometry/Euclidean/Angle/Sphere.lean,Affine.Triangle.dist_div_sin_oangle_eq_two_mul_circumradius,dist_div_sin_oangle_eq_two_mul_circumradius,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  Sphere.dist_div_sin_oangle_eq_two_mul_radius (t.mem_circumsphere _) (t.mem_circumsphere _)
    (t.mem_circumsphere _) (t.Independent.injective.ne h‚ÇÅ‚ÇÇ) (t.Independent.injective.ne h‚ÇÅ‚ÇÉ)
    (t.Independent.injective.ne h‚ÇÇ‚ÇÉ)","error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Triangle ‚Ñù P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Simplex ‚Ñù P 2
error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Triangle ‚Ñù P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Simplex ‚Ñù P 2
error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Triangle ‚Ñù P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Simplex ‚Ñù P 2","theorem dist_div_sin_oangle_eq_two_mul_circumradius (t : Triangle ‚Ñù P) {i‚ÇÅ i‚ÇÇ i‚ÇÉ : Fin 3}
    (h‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ) (h‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ) (h‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ) : dist (t.points i‚ÇÅ) (t.points i‚ÇÉ) /
      |Real.Angle.sin (‚à° (t.points i‚ÇÅ) (t.points i‚ÇÇ) (t.points i‚ÇÉ))| = 2 * t.circumradius ",":=
  Sphere.dist_div_sin_oangle_eq_two_mul_radius (t.mem_circumsphere _) (t.mem_circumsphere _)
    (t.mem_circumsphere _) (t.independent.injective.ne h‚ÇÅ‚ÇÇ) (t.independent.injective.ne h‚ÇÅ‚ÇÉ)
    (t.independent.injective.ne h‚ÇÇ‚ÇÉ)"
Mathlib/AlgebraicGeometry/Morphisms/ClosedImmersion.lean,AlgebraicGeometry.IsClosedImmersion.spec_of_surjective,spec_of_surjective,522709fb663293411481bc3e307de4801942d55a,"  base_closed := PrimeSpectrum.closedEmbedding_comap_of_surjective _ _ h
  surj_on_stalks x := by
    dsimp
    erw [‚Üê localRingHom_comp_stalkIso, CommRingCat.coe_comp, CommRingCat.coe_comp]
    apply Function.Surjective.comp (Function.Surjective.comp _ _) _
    ¬∑ exact (ConcreteCategory.bijective_of_isIso (StructureSheaf.stalkIso S x).inv).2
    ¬∑ exact surjective_localRingHom_of_surjective f h x.asIdeal
    ¬∑ let g := (StructureSheaf.stalkIso ((CommRingCat.of R))
        ((PrimeSpectrum.comap (CommRingCat.ofHom f)) x)).hom
      exact (ConcreteCategory.bijective_of_isIso g).2",error:  dsimp made no progress,"theorem spec_of_surjective {R S : CommRingCat} (f : R ‚ü∂ S) (h : Function.Surjective f) :
    IsClosedImmersion (Spec.map f) where
","  base_closed := PrimeSpectrum.closedEmbedding_comap_of_surjective _ _ h
  surj_on_stalks x := by
    erw [‚Üê localRingHom_comp_stalkIso, CommRingCat.coe_comp, CommRingCat.coe_comp]
    apply Function.Surjective.comp (Function.Surjective.comp _ _) _
    ¬∑ exact (ConcreteCategory.bijective_of_isIso (StructureSheaf.stalkIso S x).inv).2
    ¬∑ exact surjective_localRingHom_of_surjective f h x.asIdeal
    ¬∑ let g := (StructureSheaf.stalkIso ((CommRingCat.of R))
        ((PrimeSpectrum.comap (CommRingCat.ofHom f)) x)).hom
      exact (ConcreteCategory.bijective_of_isIso g).2"
Mathlib/Topology/Algebra/Module/FiniteDimension.lean,Submodule.closed_of_finiteDimensional,Submodule.closed_of_finiteDimensional,33f56a6d891ee4aa4b4f689219ac43593803d757,":=
  letI := TopologicalAddGroup.toUniformSpace E
  haveI : UniformAddGroup E := comm_topologicalAddGroup_is_uniform
  haveI := separated_iff_t2.2 ‚ÄπT2Space E‚Ä∫
  s.complete_of_finiteDimensional.isClosed",error:  unknown identifier 'separated_iff_t2',"theorem Submodule.closed_of_finiteDimensional (s : Submodule ùïú E) [FiniteDimensional ùïú s] :
    IsClosed (s : Set E) ",":=
  letI := TopologicalAddGroup.toUniformSpace E
  haveI : UniformAddGroup E := comm_topologicalAddGroup_is_uniform
  s.complete_of_finiteDimensional.isClosed"
Mathlib/Analysis/Fourier/AddCircle.lean,fourier_add_half_inv_index,fourier_add_half_inv_index,01f5513fdd086f366aba4744806e9bf17676ce61,":= by
  rw [fourier_apply, zsmul_add, ‚Üê QuotientAddGroup.mk_zsmul, toCircle_add, coe_mul_unitSphere]
  have : (@toCircle T (n ‚Ä¢ (T / 2 / n) : ‚Ñù) : ‚ÑÇ) = -1 := by
    rw [zsmul_eq_mul, toCircle, Function.Periodic.lift_coe, expMapCircle_apply]
    replace hT := Complex.ofReal_ne_zero.mpr hT.ne'
    convert Complex.exp_pi_mul_I using 3
    field_simp; ring
  rw [this]; simp","info:  Try this: ring_nf
error:  unsolved goals
case h.e'_2.h.e'_1.h.e'_5
T : ‚Ñù
n : ‚Ñ§
hn : n ‚â† 0
x : AddCircle T
hT : ‚ÜëT ‚â† 0
‚ä¢ ‚ÜëœÄ * ‚Üën * ‚ÜëT * (‚Üën)‚Åª¬π * (‚ÜëT)‚Åª¬π = ‚ÜëœÄ","theorem fourier_add_half_inv_index {n : ‚Ñ§} (hn : n ‚â† 0) (hT : 0 < T) (x : AddCircle T) :
    @fourier T n (x + ‚Üë(T / 2 / n)) = -fourier n x ",":= by
  rw [fourier_apply, zsmul_add, ‚Üê QuotientAddGroup.mk_zsmul, toCircle_add, coe_mul_unitSphere]
  have : (n : ‚ÑÇ) ‚â† 0 := by simpa using hn
  have : (@toCircle T (n ‚Ä¢ (T / 2 / n) : ‚Ñù) : ‚ÑÇ) = -1 := by
    rw [zsmul_eq_mul, toCircle, Function.Periodic.lift_coe, expMapCircle_apply]
    replace hT := Complex.ofReal_ne_zero.mpr hT.ne'
    convert Complex.exp_pi_mul_I using 3
    field_simp; ring
  rw [this]; simp"
Mathlib/MeasureTheory/Function/Jacobian.lean,ApproximatesLinearOn.norm_fderiv_sub_le,_root_.ApproximatesLinearOn.norm_fderiv_sub_le,ac197cdca670f410b4e313b0a220dab452142dff,":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.op_norm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ
  ¬∑ have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by continuity) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 (IsLittleO.def (hf' x xs) Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel'_right]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := (norm_add_le _ _)
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel', sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := (norm_sub_le _ _)
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel', norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
        mul_le_mul_of_nonneg_left norm_a (mul_nonneg rpos.le (add_nonneg Œ¥.2 Œµpos.le))
  show ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ;
  exact
    calc
      ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := (norm_add_le _ _)
      _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
        apply add_le_add
        ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
        ¬∑ apply ContinuousLinearMap.le_op_norm
      _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ :=
        add_le_add le_rfl
          (mul_le_mul_of_nonneg_left (mem_closedBall_iff_norm'.1 az) (norm_nonneg _))",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem _root_.ApproximatesLinearOn.norm_fderiv_sub_le {A : E ‚ÜíL[‚Ñù] E} {Œ¥ : ‚Ñù‚â•0}
    (hf : ApproximatesLinearOn f A s Œ¥) (hs : MeasurableSet s) (f' : E ‚Üí E ‚ÜíL[‚Ñù] E)
    (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) : ‚àÄ·µê x ‚àÇŒº.restrict s, ‚Äñf' x - A‚Äñ‚Çä ‚â§ Œ¥ ",":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ by
    have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by fun_prop) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel_left, sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := norm_sub_le _ _
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel_left, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) := by gcongr
  calc
    ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
      congr 1
      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
      abel
    _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
      apply add_le_add
      ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
      ¬∑ apply ContinuousLinearMap.le_opNorm
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ := by
      rw [mem_closedBall_iff_norm'] at az
      gcongr"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.partialGamma_add_one,partialGamma_add_one,8eee072d70c12314075443642860b2be6c1b3660,":= by
  rw [partialGamma, partialGamma, add_sub_cancel]
  have F_der_I : ‚àÄ x : ‚Ñù, x ‚àà Ioo 0 X ‚Üí HasDerivAt (fun x => (-x).exp * x ^ s : ‚Ñù ‚Üí ‚ÑÇ)
      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by
    intro x hx
    have d1 : HasDerivAt (fun y : ‚Ñù => (-y).exp) (-(-x).exp) x := by
      simpa using (hasDerivAt_neg x).exp
    have d2 : HasDerivAt (fun y : ‚Ñù => ‚Üëy ^ s) (s * x ^ (s - 1)) x := by
      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id ‚Üëx) ?_
      simpa only [mul_one] using t.comp_ofReal
      simpa only [id.def, ofReal_re, ofReal_im, Ne.def, eq_self_iff_true, not_true, or_false_iff,
        mul_one] using hx.1
    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2
  have cont := (continuous_ofReal.comp continuous_neg.exp).mul (continuous_ofReal_cpow_const hs)
  have der_ible :=
    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)
  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible
  apply_fun fun x : ‚ÑÇ => -x at int_eval
  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)
      (Gamma_integrand_deriv_integrable_B hs hX),
    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval
  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]
  simp only [sub_left_inj, add_left_inj]
  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : ‚Ñù ‚Üí ‚ÑÇ) =
      (fun x => s * (-x).exp * x ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) := by ext1; ring
  rw [this]
  have t := @integral_const_mul 0 X volume _ _ s fun x : ‚Ñù => (-x).exp * x ^ (s - 1)
  dsimp at t ; rw [‚Üê t, ofReal_zero, zero_cpow]
  ¬∑ rw [MulZeroClass.mul_zero, add_zero]; congr 2; ext1; ring
  ¬∑ contrapose! hs; rw [hs, zero_re]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + (?b - ?a)
s : ‚ÑÇ
hs : 0 < s.re
X : ‚Ñù
hX : 0 ‚â§ X
‚ä¢ ‚à´ (x : ‚Ñù) in 0 ..X, ‚Üë(rexp (-x)) * ‚Üëx ^ (s + 1 - 1) =
    (s * ‚à´ (x : ‚Ñù) in 0 ..X, ‚Üë(rexp (-x)) * ‚Üëx ^ (s - 1)) - ‚Üë(rexp (-X)) * ‚ÜëX ^ s","theorem partialGamma_add_one {s : ‚ÑÇ} (hs : 0 < s.re) {X : ‚Ñù} (hX : 0 ‚â§ X) :
    partialGamma (s + 1) X = s * partialGamma s X - (-X).exp * X ^ s ",":= by
  rw [partialGamma, partialGamma, add_sub_cancel_right]
  have F_der_I : ‚àÄ x : ‚Ñù, x ‚àà Ioo 0 X ‚Üí HasDerivAt (fun x => (-x).exp * x ^ s : ‚Ñù ‚Üí ‚ÑÇ)
      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by
    intro x hx
    have d1 : HasDerivAt (fun y : ‚Ñù => (-y).exp) (-(-x).exp) x := by
      simpa using (hasDerivAt_neg x).exp
    have d2 : HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ s) (s * x ^ (s - 1)) x := by
      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id ‚Üëx) ?_
      ¬∑ simpa only [mul_one] using t.comp_ofReal
      ¬∑ exact ofReal_mem_slitPlane.2 hx.1
    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2
  have cont := (continuous_ofReal.comp continuous_neg.rexp).mul (continuous_ofReal_cpow_const hs)
  have der_ible :=
    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)
  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible
  apply_fun fun x : ‚ÑÇ => -x at int_eval
  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)
      (Gamma_integrand_deriv_integrable_B hs hX),
    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval
  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]
  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : ‚Ñù ‚Üí ‚ÑÇ) =
      (fun x => s * (-x).exp * x ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) := by ext1; ring
  rw [this]
  have t := @integral_const_mul 0 X volume _ _ s fun x : ‚Ñù => (-x).exp * x ^ (s - 1)
  rw [‚Üê t, ofReal_zero, zero_cpow]
  ¬∑ rw [mul_zero, add_zero]; congr 2; ext1; ring
  ¬∑ contrapose! hs; rw [hs, zero_re]"
Mathlib/MeasureTheory/Measure/AddContent.lean,MeasureTheory.addContent_union,addContent_union,26c29dc27c999d53a30ed03b6e655c799e1675d8,":= by
  by_cases hs_empty : s = ‚àÖ
  ¬∑ simp only [hs_empty, Set.empty_union, addContent_empty, zero_add]
  classical
  have h := addContent_sUnion (m := m) (I := {s, t}) ?_ ?_ ?_
  rotate_left
  ¬∑ simp only [coe_pair, Set.insert_subset_iff, hs, ht, Set.singleton_subset_iff, and_self_iff]
  ¬∑ simp only [coe_pair, Set.pairwiseDisjoint_insert, pairwiseDisjoint_singleton,
      mem_singleton_iff, Ne.def, id.def, forall_eq, true_and_iff]
    exact fun _ ‚Ü¶ h_dis
  ¬∑ simp only [coe_pair, sUnion_insert, sUnion_singleton]
    exact hst
  convert h
  ¬∑ simp only [coe_pair, sUnion_insert, sUnion_singleton]
  ¬∑ rw [sum_insert, sum_singleton]
    simp only [Finset.mem_singleton]
    refine fun hs_eq_t ‚Ü¶ hs_empty ?_
    rw [‚Üê hs_eq_t] at h_dis
    exact Disjoint.eq_bot_of_self h_dis","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.6002 ‚Üí ?m.6002 ‚Üí Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.6006 ‚Üí ?m.6006","lemma addContent_union' (hs : s ‚àà C) (ht : t ‚àà C) (hst : s ‚à™ t ‚àà C) (h_dis : Disjoint s t) :
    m (s ‚à™ t) = m s + m t ",":= by
  by_cases hs_empty : s = ‚àÖ
  ¬∑ simp only [hs_empty, Set.empty_union, addContent_empty, zero_add]
  classical
  have h := addContent_sUnion (m := m) (I := {s, t}) ?_ ?_ ?_
  rotate_left
  ¬∑ simp only [coe_pair, Set.insert_subset_iff, hs, ht, Set.singleton_subset_iff, and_self_iff]
  ¬∑ simp only [coe_pair, Set.pairwiseDisjoint_insert, pairwiseDisjoint_singleton,
      mem_singleton_iff, Ne, id, forall_eq, true_and_iff]
    exact fun _ => h_dis
  ¬∑ simp only [coe_pair, sUnion_insert, sUnion_singleton]
    exact hst
  convert h
  ¬∑ simp only [coe_pair, sUnion_insert, sUnion_singleton]
  ¬∑ rw [sum_insert, sum_singleton]
    simp only [Finset.mem_singleton]
    refine fun hs_eq_t => hs_empty ?_
    rw [‚Üê hs_eq_t] at h_dis
    exact Disjoint.eq_bot_of_self h_dis"
Mathlib/RingTheory/ChainOfDivisors.lean,DivisorChain.eq_pow_second_of_chain_of_has_chain,eq_pow_second_of_chain_of_has_chain,1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493,":= by
  classical
    obtain ‚ü®i, hi'‚ü© := element_of_chain_eq_pow_second_of_chain hn h‚ÇÅ (@fun r => h‚ÇÇ) (dvd_refl q) hq
    convert hi'
    refine (Nat.lt_succ_iff.1 i.prop).antisymm' (Nat.le_of_succ_le_succ ?_)
    calc
      n + 1 = (Finset.univ : Finset (Fin (n + 1))).card := (Finset.card_fin _).symm
      _ = (Finset.univ.image c).card := (Finset.card_image_iff.mpr (h‚ÇÅ.injective.injOn _)).symm
      _ ‚â§ (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card :=
        (Finset.card_le_card ?_)
      _ ‚â§ (Finset.univ : Finset (Fin (i + 1))).card := Finset.card_image_le
      _ = i + 1 := Finset.card_fin _
    intro r hr
    obtain ‚ü®j, -, rfl‚ü© := Finset.mem_image.1 hr
    have := h‚ÇÇ.2 ‚ü®j, rfl‚ü©
    rw [hi'] at this
    have h := (dvd_prime_pow (show Prime (c 1) from ?_) i).1 this
    ¬∑ rcases h with ‚ü®u, hu, hu'‚ü©
      refine Finset.mem_image.mpr ‚ü®u, Finset.mem_univ _, ?_‚ü©
      rw [associated_iff_eq] at hu'
      rw [Fin.val_cast_of_lt (Nat.lt_succ_of_le hu), hu']
    ¬∑ rw [‚Üê irreducible_iff_prime]
      exact second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq","error:  application type mismatch
  Finset.card_image_iff.mpr (Function.Injective.injOn (StrictMono.injective h‚ÇÅ) ?m.37447)
argument
  Function.Injective.injOn (StrictMono.injective h‚ÇÅ) ?m.37447
has type
  ‚àÄ ‚¶Éx‚ÇÇ : Fin (n + 1)‚¶Ñ, x‚ÇÇ ‚àà ?m.37445 ‚Üí c ?m.37446 = c x‚ÇÇ ‚Üí ?m.37446 = x‚ÇÇ : Prop
but is expected to have type
  Set.InjOn ?m.37126 ‚Üë?m.37125 : Prop","theorem eq_pow_second_of_chain_of_has_chain {q : Associates M} {n : ‚Ñï} (hn : n ‚â† 0)
    {c : Fin (n + 1) ‚Üí Associates M} (h‚ÇÅ : StrictMono c)
    (h‚ÇÇ : ‚àÄ {r : Associates M}, r ‚â§ q ‚Üî ‚àÉ i, r = c i) (hq : q ‚â† 0) : q = c 1 ^ n ",":= by
  classical
    obtain ‚ü®i, hi'‚ü© := element_of_chain_eq_pow_second_of_chain hn h‚ÇÅ (@fun r => h‚ÇÇ) (dvd_refl q) hq
    convert hi'
    refine (Nat.lt_succ_iff.1 i.prop).antisymm' (Nat.le_of_succ_le_succ ?_)
    calc
      n + 1 = (Finset.univ : Finset (Fin (n + 1))).card := (Finset.card_fin _).symm
      _ = (Finset.univ.image c).card := (Finset.card_image_iff.mpr h‚ÇÅ.injective.injOn).symm
      _ ‚â§ (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : ‚Ñï)).card :=
        (Finset.card_le_card ?_)
      _ ‚â§ (Finset.univ : Finset (Fin (i + 1))).card := Finset.card_image_le
      _ = i + 1 := Finset.card_fin _
    intro r hr
    obtain ‚ü®j, -, rfl‚ü© := Finset.mem_image.1 hr
    have := h‚ÇÇ.2 ‚ü®j, rfl‚ü©
    rw [hi'] at this
    have h := (dvd_prime_pow (show Prime (c 1) from ?_) i).1 this
    ¬∑ rcases h with ‚ü®u, hu, hu'‚ü©
      refine Finset.mem_image.mpr ‚ü®u, Finset.mem_univ _, ?_‚ü©
      rw [associated_iff_eq] at hu'
      rw [Fin.val_cast_of_lt (Nat.lt_succ_of_le hu), hu']
    ¬∑ rw [‚Üê irreducible_iff_prime]
      exact second_of_chain_is_irreducible hn h‚ÇÅ (@h‚ÇÇ) hq"
Mathlib/Combinatorics/Enumerative/Composition.lean,List.get_splitWrtCompositionAux,get_splitWrtCompositionAux,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' ns with n ns IH generalizing l i
  ¬∑ cases hi
  cases' i with i
  ¬∑ rw [Nat.add_zero, List.take_zero, sum_nil]
    simpa using get_mk_zero hi
  ¬∑ simp only [splitWrtCompositionAux._eq_2, get_cons_succ, IH, take,
        sum_cons, Nat.add_eq, add_zero, splitAt_eq_take_drop, drop_take, drop_drop]
    rw [Nat.succ_eq_add_one, add_comm (sum _) n, Nat.add_sub_add_left]","warning:  try 'simp' instead of 'simpa'
note: this linter can be disabled with `set_option linter.unnecessarySimpa false`
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  splitWrtCompositionAux
has type
  List ?m.63363 ‚Üí List ‚Ñï ‚Üí List (List ?m.63363)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case cons.succ
n‚úù : ‚Ñï
Œ± : Type u_1
n : ‚Ñï
ns : List ‚Ñï
IH :
  ‚àÄ (l : List Œ±) {i : ‚Ñï} (hi : i < (l.splitWrtCompositionAux ns).length),
    (l.splitWrtCompositionAux ns).get ‚ü®i, hi‚ü© = drop (take i ns).sum (take (take (i + 1) ns).sum l)
l : List Œ±
i : ‚Ñï
hi : i + 1 < (l.splitWrtCompositionAux (n :: ns)).length
‚ä¢ (l.splitWrtCompositionAux (n :: ns)).get ‚ü®i + 1, hi‚ü© =
    take (n + (take (i + 1) ns).sum - (n + (take i ns).sum)) (drop (n + (take i ns).sum) l)","theorem get_splitWrtCompositionAux (l : List Œ±) (ns : List ‚Ñï) {i : ‚Ñï} (hi) :
    (l.splitWrtCompositionAux ns).get ‚ü®i, hi‚ü©  =
      (l.take (ns.take (i + 1)).sum).drop (ns.take i).sum ",":= by
  simp [getElem_splitWrtCompositionAux]"
Mathlib/CategoryTheory/Limits/Indization/IndObject.lean,CategoryTheory.Limits.isIndObject_of_isFiltered_of_finallySmall,isIndObject_of_isFiltered_of_finallySmall,b00a3805fab44f4e1c5c20f20210228921360a80,":= by
  have h‚ÇÅ : (factoring (fromFinalModel (CostructuredArrow yoneda A)) ‚ãô
      inclusion (fromFinalModel (CostructuredArrow yoneda A))).Final := Functor.final_of_natIso
    (factoringCompInclusion (fromFinalModel <| CostructuredArrow yoneda A)).symm
  have h‚ÇÇ : Functor.Final (inclusion (fromFinalModel (CostructuredArrow yoneda A))) :=
    Functor.final_of_comp_full_faithful' (factoring _) (inclusion _)
  let c := (Presheaf.tautologicalCocone A).whisker (inclusion (fromFinalModel (CostructuredArrow yoneda A)))
  let hc : IsColimit c := (Functor.Final.isColimitWhiskerEquiv _ _).symm
    (Presheaf.isColimitTautologicalCocone A)
  have hq : Nonempty (FinalModel (CostructuredArrow yoneda A)) := Nonempty.map
    (Functor.Final.lift (fromFinalModel (CostructuredArrow yoneda A))) IsFiltered.nonempty
  exact ‚ü®_, inclusion (fromFinalModel _) ‚ãô CostructuredArrow.proj yoneda A, c.Œπ, hc‚ü©","error:  unknown identifier 'Presheaf.tautologicalCocone'
error:  unsolved goals
C : Type u
inst‚úù¬≤ : Category.{v, u} C
A : C·µí·µñ ‚•§ Type v
inst‚úù¬π : IsFiltered (CostructuredArrow yoneda A)
inst‚úù : FinallySmall (CostructuredArrow yoneda A)
h‚ÇÅ :
  (factoring (fromFinalModel (CostructuredArrow yoneda A)) ‚ãô
      inclusion (fromFinalModel (CostructuredArrow yoneda A))).Final
h‚ÇÇ : (inclusion (fromFinalModel (CostructuredArrow yoneda A))).Final
‚ä¢ IsIndObject A","theorem isIndObject_of_isFiltered_of_finallySmall (A : C·µí·µñ ‚•§ Type v)
    [IsFiltered (CostructuredArrow yoneda A)] [FinallySmall.{v} (CostructuredArrow yoneda A)] :
    IsIndObject A ",":= by
  have h‚ÇÅ : (factoring (fromFinalModel (CostructuredArrow yoneda A)) ‚ãô
      inclusion (fromFinalModel (CostructuredArrow yoneda A))).Final := Functor.final_of_natIso
    (factoringCompInclusion (fromFinalModel <| CostructuredArrow yoneda A)).symm
  have h‚ÇÇ : Functor.Final (inclusion (fromFinalModel (CostructuredArrow yoneda A))) :=
    Functor.final_of_comp_full_faithful' (factoring _) (inclusion _)
  let c := (tautologicalCocone A).whisker (inclusion (fromFinalModel (CostructuredArrow yoneda A)))
  let hc : IsColimit c := (Functor.Final.isColimitWhiskerEquiv _ _).symm
    (isColimitTautologicalCocone A)
  have hq : Nonempty (FinalModel (CostructuredArrow yoneda A)) := Nonempty.map
    (Functor.Final.lift (fromFinalModel (CostructuredArrow yoneda A))) IsFiltered.nonempty
  exact ‚ü®_, inclusion (fromFinalModel _) ‚ãô CostructuredArrow.proj yoneda A, c.Œπ, hc‚ü©"
Mathlib/Data/Rat/Lemmas.lean,Rat.inv_natCast_den_of_pos,inv_natCast_den_of_pos,0ef23fba776dbe5bb848bbfc3337bedef4a59c82,":= by
  rw [‚Üê Int.ofNat_inj, ‚Üê Int.cast_natCast a, inv_intCast_den_of_pos]
  rwa [Nat.cast_pos]","error:  unknown constant 'Nat.cast_pos'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.33629
a : ‚Ñï
ha0 : 0 < a
‚ä¢ 0 < ‚Üëa",theorem inv_natCast_den_of_pos {a : ‚Ñï} (ha0 : 0 < a) : (a : ‚Ñö)‚Åª¬π.den = a ,":= by
  rw [‚Üê Int.ofNat_inj, ‚Üê Int.cast_natCast a, inv_intCast_den_of_pos]
  rwa [Int.natCast_pos]"
Mathlib/Topology/FiberBundle/Basic.lean,FiberBundle.exists_trivialization_Icc_subset,FiberBundle.exists_trivialization_Icc_subset,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain ‚ü®ea, hea‚ü© : ‚àÉ ea : Trivialization F (œÄ F E), a ‚àà ea.baseSet :=
    ‚ü®trivializationAt F E a, mem_baseSet_trivializationAt F E a‚ü©
  cases' lt_or_le b a with hab hab
  ¬∑ exact ‚ü®ea, by simp [*]‚ü©
  set s : Set B := { x ‚àà Icc a b | ‚àÉ e : Trivialization F (œÄ F E), Icc a x ‚äÜ e.baseSet }
  have ha : a ‚àà s := ‚ü®left_mem_Icc.2 hab, ea, by simp [hea]‚ü©
  have sne : s.Nonempty := ‚ü®a, ha‚ü©
  have hsb : b ‚àà upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := ‚ü®b, hsb‚ü©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c ‚àà Icc a b := ‚ü®hsc.1 ha, hsc.2 hsb‚ü©
  obtain ‚ü®-, ec : Trivialization F (œÄ F E), hec : Icc a c ‚äÜ ec.baseSet‚ü© : c ‚àà s := by
    rcases hc.1.eq_or_lt with heq | hlt
    ¬∑ rwa [‚Üê heq]
    refine ‚ü®hc, ?_‚ü©
    obtain ‚ü®ec, hc‚ü© : ‚àÉ ec : Trivialization F (œÄ F E), c ‚àà ec.baseSet :=
      ‚ü®trivializationAt F E c, mem_baseSet_trivializationAt F E c‚ü©
    obtain ‚ü®c', hc', hc'e‚ü© : ‚àÉ c' ‚àà Ico a c, Ioc c' c ‚äÜ ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain ‚ü®d, ‚ü®hdab, ead, had‚ü©, hd‚ü© : ‚àÉ d ‚àà s, d ‚àà Ioc c' c := hsc.exists_between hc'.2
    refine' ‚ü®ead.piecewiseLe ec d (had ‚ü®hdab.1, le_rfl‚ü©) (hc'e hd), subset_ite.2 _‚ü©
    exact ‚ü®fun x hx => had ‚ü®hx.1.1, hx.2‚ü©, fun x hx => hc'e ‚ü®hd.1.trans (not_le.1 hx.2), hx.1.2‚ü©‚ü©
  rcases hc.2.eq_or_lt with heq | hlt
  ¬∑ exact ‚ü®ec, heq ‚ñ∏ hec‚ü©
  rsuffices ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, ‚àÉ e : Trivialization F (œÄ F E), Icc a d ‚äÜ e.baseSet
  ¬∑ exact ((hsc.1 ‚ü®‚ü®hc.1.trans hdcb.1.le, hdcb.2‚ü©, hd‚ü©).not_lt hdcb.1).elim
  obtain ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, Ico c d ‚äÜ ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec ‚ü®hc.1, le_rfl‚ü©))
  have had : Ico a d ‚äÜ ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  ¬∑ obtain ‚ü®ed, hed‚ü© : ‚àÉ ed : Trivialization F (œÄ F E), d ‚àà ed.baseSet :=
      ‚ü®trivializationAt F E d, mem_baseSet_trivializationAt F E d‚ü©
    refine' ‚ü®d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono (inter_subset_right _ _) (inter_subset_right _ _)), fun x hx => _‚ü©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr ‚ü®hed, hdcb.1‚ü©, Or.inl ‚ü®had ‚ü®hx.1, hxd‚ü©, hxd‚ü©]
  ¬∑ rw [disjoint_left] at he
    push_neg at he
    rcases he with ‚ü®d', hdd' : d' < d, hd'c‚ü©
    exact ‚ü®d', ‚ü®hd'c, hdd'.le.trans hdcb.2‚ü©, ec, (Icc_subset_Ico_right hdd').trans had‚ü©","error:  function expected at
  inter_subset_right ?m.16125
term has type
  ?m.16124 ‚àà ?m.16123
error:  function expected at
  inter_subset_right ?m.16167
term has type
  ?m.16166 ‚àà ?m.16165","theorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]
    [OrderTopology B] [FiberBundle F E] (a b : B) :
    ‚àÉ e : Trivialization F (œÄ F E), Icc a b ‚äÜ e.baseSet ",":= by
  obtain ‚ü®ea, hea‚ü© : ‚àÉ ea : Trivialization F (œÄ F E), a ‚àà ea.baseSet :=
    ‚ü®trivializationAt F E a, mem_baseSet_trivializationAt F E a‚ü©
  cases' lt_or_le b a with hab hab
  ¬∑ exact ‚ü®ea, by simp [*]‚ü©
  set s : Set B := { x ‚àà Icc a b | ‚àÉ e : Trivialization F (œÄ F E), Icc a x ‚äÜ e.baseSet }
  have ha : a ‚àà s := ‚ü®left_mem_Icc.2 hab, ea, by simp [hea]‚ü©
  have sne : s.Nonempty := ‚ü®a, ha‚ü©
  have hsb : b ‚àà upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := ‚ü®b, hsb‚ü©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c ‚àà Icc a b := ‚ü®hsc.1 ha, hsc.2 hsb‚ü©
  obtain ‚ü®-, ec : Trivialization F (œÄ F E), hec : Icc a c ‚äÜ ec.baseSet‚ü© : c ‚àà s := by
    rcases hc.1.eq_or_lt with heq | hlt
    ¬∑ rwa [‚Üê heq]
    refine ‚ü®hc, ?_‚ü©
    obtain ‚ü®ec, hc‚ü© : ‚àÉ ec : Trivialization F (œÄ F E), c ‚àà ec.baseSet :=
      ‚ü®trivializationAt F E c, mem_baseSet_trivializationAt F E c‚ü©
    obtain ‚ü®c', hc', hc'e‚ü© : ‚àÉ c' ‚àà Ico a c, Ioc c' c ‚äÜ ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain ‚ü®d, ‚ü®hdab, ead, had‚ü©, hd‚ü© : ‚àÉ d ‚àà s, d ‚àà Ioc c' c := hsc.exists_between hc'.2
    refine ‚ü®ead.piecewiseLe ec d (had ‚ü®hdab.1, le_rfl‚ü©) (hc'e hd), subset_ite.2 ?_‚ü©
    exact ‚ü®fun x hx => had ‚ü®hx.1.1, hx.2‚ü©, fun x hx => hc'e ‚ü®hd.1.trans (not_le.1 hx.2), hx.1.2‚ü©‚ü©
  rcases hc.2.eq_or_lt with heq | hlt
  ¬∑ exact ‚ü®ec, heq ‚ñ∏ hec‚ü©
  rsuffices ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, ‚àÉ e : Trivialization F (œÄ F E), Icc a d ‚äÜ e.baseSet
  ¬∑ exact ((hsc.1 ‚ü®‚ü®hc.1.trans hdcb.1.le, hdcb.2‚ü©, hd‚ü©).not_lt hdcb.1).elim
  obtain ‚ü®d, hdcb, hd‚ü© : ‚àÉ d ‚àà Ioc c b, Ico c d ‚äÜ ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec ‚ü®hc.1, le_rfl‚ü©))
  have had : Ico a d ‚äÜ ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  ¬∑ obtain ‚ü®ed, hed‚ü© : ‚àÉ ed : Trivialization F (œÄ F E), d ‚àà ed.baseSet :=
      ‚ü®trivializationAt F E d, mem_baseSet_trivializationAt F E d‚ü©
    refine ‚ü®d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono inter_subset_right inter_subset_right), fun x hx => ?_‚ü©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr ‚ü®hed, hdcb.1‚ü©, Or.inl ‚ü®had ‚ü®hx.1, hxd‚ü©, hxd‚ü©]
  ¬∑ rw [disjoint_left] at he
    push_neg at he
    rcases he with ‚ü®d', hdd' : d' < d, hd'c‚ü©
    exact ‚ü®d', ‚ü®hd'c, hdd'.le.trans hdcb.2‚ü©, ec, (Icc_subset_Ico_right hdd').trans had‚ü©"
Mathlib/GroupTheory/Sylow.lean,Sylow.card_normalizer_modEq_card,card_normalizer_modEq_card,a2d4b97db742cef33d7ce3404f92ab85330707e5,":= by
  have : H.subgroupOf (normalizer H) ‚âÉ H := (subgroupOfEquivOfLe le_normalizer).toEquiv
  rw [card_eq_card_quotient_mul_card_subgroup H,
    card_eq_card_quotient_mul_card_subgroup (H.subgroupOf (normalizer H)), Fintype.card_congr this,
    hH, pow_succ]
  exact (card_quotient_normalizer_modEq_card_quotient hH).mul_right' _","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.card G
G : Type u
Œ± : Type v
Œ≤ : Type w
inst‚úù¬π : Group G
inst‚úù : Fintype G
p n : ‚Ñï
hp : Fact (Nat.Prime p)
H : Subgroup G
hH : Fintype.card ‚Ü•H = p ^ n
this : ‚Ü•(H.subgroupOf H.normalizer) ‚âÉ ‚Ü•H
‚ä¢ Fintype.card ‚Ü•H.normalizer ‚â° Fintype.card G [MOD p ^ (n + 1)]","theorem card_normalizer_modEq_card [Fintype G] {p : ‚Ñï} {n : ‚Ñï} [hp : Fact p.Prime] {H : Subgroup G}
    (hH : Fintype.card H = p ^ n) : card (normalizer H) ‚â° card G [MOD p ^ (n + 1)] ",":= by
  have : H.subgroupOf (normalizer H) ‚âÉ H := (subgroupOfEquivOfLe le_normalizer).toEquiv
  simp only [‚Üê Nat.card_eq_fintype_card] at hH ‚ä¢
  rw [card_eq_card_quotient_mul_card_subgroup H,
    card_eq_card_quotient_mul_card_subgroup (H.subgroupOf (normalizer H)), Nat.card_congr this,
    hH, pow_succ']
  simp only [Nat.card_eq_fintype_card] at hH ‚ä¢
  exact (card_quotient_normalizer_modEq_card_quotient hH).mul_right' _"
Mathlib/Topology/ExtendFrom.lean,continuousOn_extendFrom,continuousOn_extendFrom,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  set œÜ := extendFrom A f
  intro x x_in
  suffices ‚àÄ V' ‚àà ùìù (œÜ x), IsClosed V' ‚Üí œÜ ‚Åª¬π' V' ‚àà ùìù[B] x by
    simpa [ContinuousWithinAt, (closed_nhds_basis (œÜ x)).tendsto_right_iff]
  intro V' V'_in V'_closed
  obtain ‚ü®V, V_in, V_op, hV‚ü© : ‚àÉ V ‚àà ùìù x, IsOpen V ‚àß V ‚à© A ‚äÜ f ‚Åª¬π' V' := by
    have := tendsto_extendFrom (hf x x_in)
    rcases (nhdsWithin_basis_open x A).tendsto_left_iff.mp this V' V'_in with ‚ü®V, ‚ü®hxV, V_op‚ü©, hV‚ü©
    exact ‚ü®V, IsOpen.mem_nhds V_op hxV, V_op, hV‚ü©
  suffices : ‚àÄ y ‚àà V ‚à© B, œÜ y ‚àà V'
  exact mem_of_superset (inter_mem_inf V_in <| mem_principal_self B) this
  rintro y ‚ü®hyV, hyB‚ü©
  haveI := mem_closure_iff_nhdsWithin_neBot.mp (hB hyB)
  have limy : Tendsto f (ùìù[A] y) (ùìù <| œÜ y) := tendsto_extendFrom (hf y hyB)
  have hVy : V ‚àà ùìù y := IsOpen.mem_nhds V_op hyV
  have : V ‚à© A ‚àà ùìù[A] y := by simpa only [inter_comm] using inter_mem_nhdsWithin A hVy
  exact V'_closed.mem_of_tendsto limy (mem_of_superset this hV)",error:  unexpected token ':'; expected term,"theorem continuousOn_extendFrom [RegularSpace Y] {f : X ‚Üí Y} {A B : Set X} (hB : B ‚äÜ closure A)
    (hf : ‚àÄ x ‚àà B, ‚àÉ y, Tendsto f (ùìù[A] x) (ùìù y)) : ContinuousOn (extendFrom A f) B ",":= by
  set œÜ := extendFrom A f
  intro x x_in
  suffices ‚àÄ V' ‚àà ùìù (œÜ x), IsClosed V' ‚Üí œÜ ‚Åª¬π' V' ‚àà ùìù[B] x by
    simpa [ContinuousWithinAt, (closed_nhds_basis (œÜ x)).tendsto_right_iff]
  intro V' V'_in V'_closed
  obtain ‚ü®V, V_in, V_op, hV‚ü© : ‚àÉ V ‚àà ùìù x, IsOpen V ‚àß V ‚à© A ‚äÜ f ‚Åª¬π' V' := by
    have := tendsto_extendFrom (hf x x_in)
    rcases (nhdsWithin_basis_open x A).tendsto_left_iff.mp this V' V'_in with ‚ü®V, ‚ü®hxV, V_op‚ü©, hV‚ü©
    exact ‚ü®V, IsOpen.mem_nhds V_op hxV, V_op, hV‚ü©
  suffices ‚àÄ y ‚àà V ‚à© B, œÜ y ‚àà V' from
    mem_of_superset (inter_mem_inf V_in <| mem_principal_self B) this
  rintro y ‚ü®hyV, hyB‚ü©
  haveI := mem_closure_iff_nhdsWithin_neBot.mp (hB hyB)
  have limy : Tendsto f (ùìù[A] y) (ùìù <| œÜ y) := tendsto_extendFrom (hf y hyB)
  have hVy : V ‚àà ùìù y := IsOpen.mem_nhds V_op hyV
  have : V ‚à© A ‚àà ùìù[A] y := by simpa only [inter_comm] using inter_mem_nhdsWithin A hVy
  exact V'_closed.mem_of_tendsto limy (mem_of_superset this hV)"
Mathlib/Combinatorics/SimpleGraph/Basic.lean,SimpleGraph.adj_iff_exists_edge,adj_iff_exists_edge,2c7acf21b13bf7a6ef2ed22140a70e1226429170,":= by
  refine' ‚ü®fun _ => ‚ü®G.ne_of_adj ‚Äπ_‚Ä∫, ‚ü¶(v, w)‚üß, by simpa‚ü©, _‚ü©
  rintro ‚ü®hne, e, he, hv‚ü©
  rw [Sym2.mem_and_mem_iff hne] at hv
  subst e
  rwa [mem_edgeSet] at he","error:  application type mismatch
  Exists.intro ‚ü¶(v, w)‚üß
argument
  ‚ü¶(v, w)‚üß
has type
  Quotient ?m.45031 : Type u
but is expected to have type
  Sym2 V : Type u
error:  tactic 'assumption' failed
Œπ : Sort u_1
V : Type u
G : SimpleGraph V
a b c u v‚úù w‚úù : V
e : Sym2 V
G‚ÇÅ G‚ÇÇ : SimpleGraph V
v w : V
x‚úù : G.Adj v w
‚ä¢ sorryAx (Sym2 V) true ‚àà G.edgeSet ‚àß v ‚àà sorryAx (Sym2 V) true ‚àß w ‚àà sorryAx (Sym2 V) true","theorem adj_iff_exists_edge {v w : V} : G.Adj v w ‚Üî v ‚â† w ‚àß ‚àÉ e ‚àà G.edgeSet, v ‚àà e ‚àß w ‚àà e ",":= by
  refine ‚ü®fun _ => ‚ü®G.ne_of_adj ‚Äπ_‚Ä∫, s(v, w), by simpa‚ü©, ?_‚ü©
  rintro ‚ü®hne, e, he, hv‚ü©
  rw [Sym2.mem_and_mem_iff hne] at hv
  subst e
  rwa [mem_edgeSet] at he"
Mathlib/Topology/Algebra/Group/Basic.lean,local_isCompact_isClosed_nhds_of_group,local_isCompact_isClosed_nhds_of_group,db373a75816d420c2441e31b5146e7d6b22d6eac,":= by
  obtain ‚ü®L, Lint, LU, Lcomp‚ü© : ‚àÉ (L : Set G), L ‚àà ùìù (1 : G) ‚àß L ‚äÜ U ‚àß IsCompact L :=
    local_compact_nhds hU
  obtain ‚ü®V, Vnhds, hV‚ü© : ‚àÉ V ‚àà ùìù (1 : G), ‚àÄ v ‚àà V, ‚àÄ w ‚àà V, v * w ‚àà L := by
    have : (fun p : G √ó G => p.1 * p.2) ‚Åª¬π' L ‚àà ùìù ((1, 1) : G √ó G) := by
      refine' continuousAt_fst.mul continuousAt_snd _
      simpa only [mul_one] using Lint
    simpa only [div_eq_mul_inv, nhds_prod_eq, mem_prod_self_iff, prod_subset_iff, mem_preimage]
      using this
  have VL : closure V ‚äÜ L :=
    calc
      closure V = {(1 : G)} * closure V := by simp only [singleton_mul, one_mul, image_id']
      _ ‚äÜ interior V * closure V :=
        mul_subset_mul_right
          (by simpa only [singleton_subset_iff] using mem_interior_iff_mem_nhds.2 Vnhds)
      _ = interior V * V := isOpen_interior.mul_closure _
      _ ‚äÜ V * V := mul_subset_mul_right interior_subset
      _ ‚äÜ L := by
        rintro x ‚ü®y, z, yv, zv, rfl‚ü©
        exact hV _ yv _ zv

  exact
    ‚ü®closure V, isCompact_of_isClosed_subset Lcomp isClosed_closure VL, isClosed_closure,
      VL.trans LU, interior_mono subset_closure (mem_interior_iff_mem_nhds.2 Vnhds)‚ü©","error:  application type mismatch
  hV ?m.397869 yv
argument
  yv
has type
  G : Type w
but is expected to have type
  ?m.397869 ‚àà V : Prop
error:  unknown identifier 'isCompact_of_isClosed_subset'","theorem local_isCompact_isClosed_nhds_of_group [LocallyCompactSpace G] {U : Set G}
    (hU : U ‚àà ùìù (1 : G)) :
    ‚àÉ K : Set G, IsCompact K ‚àß IsClosed K ‚àß K ‚äÜ U ‚àß (1 : G) ‚àà interior K ",":=
  let ‚ü®K, ‚ü®hK‚ÇÅ, hKco, hKcl‚ü©, hKU‚ü© := (isCompact_isClosed_basis_nhds (1 : G)).mem_iff.1 hU
  ‚ü®K, hKco, hKcl, hKU, mem_interior_iff_mem_nhds.2 hK‚ÇÅ‚ü©"
Mathlib/LinearAlgebra/BilinearForm/DualLattice.lean,LinearMap.BilinForm.dualSubmoduleParing_spec,dualSubmoduleParing_spec,31c261277bc3e8a52b74d248691ef6b40c75b452,":=
  LinearMap.BilinForm.dualSubmoduleParing_spec (BilinForm.toLin B) x y","warning:  `LinearMap.BilinForm.toLin` has been deprecated
error:  application type mismatch
  dualSubmoduleParing_spec (toLin B)
argument
  toLin B
has type
  M ‚Üí‚Çó[S] M ‚Üí‚Çó[S] S : Type (max u_2 u_3 u_2)
but is expected to have type
  ‚Ü•(B.dualSubmodule ?m.48341) : Type u_2","lemma dualSubmoduleParing_spec {N : Submodule R M} (x : B.dualSubmodule N) (y : N) :
    algebraMap R S (B.dualSubmoduleParing x y) = B x y ",":=
  (x.prop y y.prop).choose_spec"
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,AffineSubspace.coe_direction_eq_vsub_set_right,coe_direction_eq_vsub_set_right,983cf2223ba675764dd6602c425ff6d20a683993,":= by
  rw [coe_direction_eq_vsub_set ‚ü®p, hp‚ü©]
  refine' le_antisymm _ _
  ¬∑ rintro v ‚ü®p1, p2, hp1, hp2, rfl‚ü©
    exact ‚ü®p1 -·µ• p2 +·µ• p, vadd_mem_of_mem_direction (vsub_mem_direction hp1 hp2) hp, vadd_vsub _ _‚ü©
  ¬∑ rintro v ‚ü®p2, hp2, rfl‚ü©
    exact ‚ü®p2, p, hp2, hp, rfl‚ü©","error:  application type mismatch
  p1 -·µ• p2
argument
  p2
has type
  p1 ‚àà ‚Üës : Prop
but is expected to have type
  P : Type u_3
error:  application type mismatch
  vsub_mem_direction hp1
argument
  hp1
has type
  P : Type u_3
but is expected to have type
  ?m.72122 ‚àà ?m.72121 : Prop
error:  application type mismatch
  And.intro p
argument
  p
has type
  P : Type u_3
but is expected to have type
  p2 ‚àà ‚Üës : Prop
error:  application type mismatch
  Exists.intro hp2
argument
  hp2
has type
  p2 ‚àà ‚Üës : Prop
but is expected to have type
  P : Type u_3
warning:  @AffineSubspace.Parallel does not have a doc string","theorem coe_direction_eq_vsub_set_right {s : AffineSubspace k P} {p : P} (hp : p ‚àà s) :
    (s.direction : Set V) = (¬∑ -·µ• p) '' s ",":= by
  rw [coe_direction_eq_vsub_set ‚ü®p, hp‚ü©]
  refine le_antisymm ?_ ?_
  ¬∑ rintro v ‚ü®p1, hp1, p2, hp2, rfl‚ü©
    exact ‚ü®p1 -·µ• p2 +·µ• p, vadd_mem_of_mem_direction (vsub_mem_direction hp1 hp2) hp, vadd_vsub _ _‚ü©
  ¬∑ rintro v ‚ü®p2, hp2, rfl‚ü©
    exact ‚ü®p2, hp2, p, hp, rfl‚ü©"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.Measure.hausdorffMeasure_zero_or_top,hausdorffMeasure_zero_or_top,b0e957dde04ef7c6990a222e5a6fa5c2179a8fc8,":= by
  by_contra' H
  suffices ‚àÄ c : ‚Ñù‚â•0, c ‚â† 0 ‚Üí ŒºH[d‚ÇÇ] s ‚â§ c * ŒºH[d‚ÇÅ] s by
    rcases ENNReal.exists_nnreal_pos_mul_lt H.2 H.1 with ‚ü®c, hc0, hc‚ü©
    exact hc.not_le (this c (pos_iff_ne_zero.1 hc0))
  intro c hc
  refine' le_iff'.1 (mkMetric_mono_smul ENNReal.coe_ne_top (by exact_mod_cast hc) _) s
  have : 0 < ((c : ‚Ñù‚â•0‚àû) ^ (d‚ÇÇ - d‚ÇÅ)‚Åª¬π) := by
    rw [ENNReal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, Ne.def, ENNReal.coe_eq_zero,
      NNReal.rpow_eq_zero_iff]
    exact mt And.left hc
  filter_upwards [Ico_mem_nhdsWithin_Ici ‚ü®le_rfl, this‚ü©]
  rintro r ‚ü®hr‚ÇÄ, hrc‚ü©
  lift r to ‚Ñù‚â•0 using ne_top_of_lt hrc
  rw [Pi.smul_apply, smul_eq_mul,
    ‚Üê ENNReal.div_le_iff_le_mul (Or.inr ENNReal.coe_ne_top) (Or.inr <| mt ENNReal.coe_eq_zero.1 hc)]
  rcases eq_or_ne r 0 with (rfl | hr‚ÇÄ)
  ¬∑ rcases lt_or_le 0 d‚ÇÇ with (h‚ÇÇ | h‚ÇÇ)
    ¬∑ simp only [h‚ÇÇ, ENNReal.zero_rpow_of_pos, zero_le, ENNReal.zero_div, ENNReal.coe_zero]
    ¬∑ simp only [h.trans_le h‚ÇÇ, ENNReal.div_top, zero_le, ENNReal.zero_rpow_of_neg,
        ENNReal.coe_zero]
  ¬∑ have : (r : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne.def] using hr‚ÇÄ
    rw [‚Üê ENNReal.rpow_sub _ _ this ENNReal.coe_ne_top]
    refine' (ENNReal.rpow_lt_rpow hrc (sub_pos.2 h)).le.trans _
    rw [‚Üê ENNReal.rpow_mul, inv_mul_cancel (sub_pos.2 h).ne', ENNReal.rpow_one]","error:  unknown tactic
error:  unsolved goals
Œπ : Type u_1
X : Type u_2
Y : Type u_3
inst‚úù¬≥ : EMetricSpace X
inst‚úù¬≤ : EMetricSpace Y
inst‚úù¬π : MeasurableSpace X
inst‚úù : BorelSpace X
d‚ÇÅ d‚ÇÇ : ‚Ñù
h : d‚ÇÅ < d‚ÇÇ
s : Set X
‚ä¢ ŒºH[d‚ÇÇ] s = 0 ‚à® ŒºH[d‚ÇÅ] s = ‚ä§","theorem hausdorffMeasure_zero_or_top {d‚ÇÅ d‚ÇÇ : ‚Ñù} (h : d‚ÇÅ < d‚ÇÇ) (s : Set X) :
    ŒºH[d‚ÇÇ] s = 0 ‚à® ŒºH[d‚ÇÅ] s = ‚àû ",":= by
  by_contra! H
  suffices ‚àÄ c : ‚Ñù‚â•0, c ‚â† 0 ‚Üí ŒºH[d‚ÇÇ] s ‚â§ c * ŒºH[d‚ÇÅ] s by
    rcases ENNReal.exists_nnreal_pos_mul_lt H.2 H.1 with ‚ü®c, hc0, hc‚ü©
    exact hc.not_le (this c (pos_iff_ne_zero.1 hc0))
  intro c hc
  refine le_iff'.1 (mkMetric_mono_smul ENNReal.coe_ne_top (mod_cast hc) ?_) s
  have : 0 < ((c : ‚Ñù‚â•0‚àû) ^ (d‚ÇÇ - d‚ÇÅ)‚Åª¬π) := by
    rw [ENNReal.coe_rpow_of_ne_zero hc, pos_iff_ne_zero, Ne, ENNReal.coe_eq_zero,
      NNReal.rpow_eq_zero_iff]
    exact mt And.left hc
  filter_upwards [Ico_mem_nhdsWithin_Ici ‚ü®le_rfl, this‚ü©]
  rintro r ‚ü®hr‚ÇÄ, hrc‚ü©
  lift r to ‚Ñù‚â•0 using ne_top_of_lt hrc
  rw [Pi.smul_apply, smul_eq_mul,
    ‚Üê ENNReal.div_le_iff_le_mul (Or.inr ENNReal.coe_ne_top) (Or.inr <| mt ENNReal.coe_eq_zero.1 hc)]
  rcases eq_or_ne r 0 with (rfl | hr‚ÇÄ)
  ¬∑ rcases lt_or_le 0 d‚ÇÇ with (h‚ÇÇ | h‚ÇÇ)
    ¬∑ simp only [h‚ÇÇ, ENNReal.zero_rpow_of_pos, zero_le, ENNReal.zero_div, ENNReal.coe_zero]
    ¬∑ simp only [h.trans_le h‚ÇÇ, ENNReal.div_top, zero_le, ENNReal.zero_rpow_of_neg,
        ENNReal.coe_zero]
  ¬∑ have : (r : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa only [ENNReal.coe_eq_zero, Ne] using hr‚ÇÄ
    rw [‚Üê ENNReal.rpow_sub _ _ this ENNReal.coe_ne_top]
    refine (ENNReal.rpow_lt_rpow hrc (sub_pos.2 h)).le.trans ?_
    rw [‚Üê ENNReal.rpow_mul, inv_mul_cancel (sub_pos.2 h).ne', ENNReal.rpow_one]"
Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean,MvPolynomial.weightedHomogeneousSubmodule_mul,weightedHomogeneousSubmodule_mul,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  rw [Submodule.mul_le]
  intro œÜ hœÜ œà hœà c hc
  rw [coeff_mul] at hc
  obtain ‚ü®‚ü®d, e‚ü©, hde, H‚ü© := Finset.exists_ne_zero_of_sum_ne_zero hc
  have aux : coeff d œÜ ‚â† 0 ‚àß coeff e œà ‚â† 0 := by
    contrapose! H
    by_cases h : coeff d œÜ = 0 <;>
      simp_all only [Ne.def, not_false_iff, MulZeroClass.zero_mul, MulZeroClass.mul_zero]
  rw [‚Üê Finsupp.mem_antidiagonal.mp hde, ‚Üê hœÜ aux.1, ‚Üê hœà aux.2, map_add]","error:  failed to synthesize
  DecidableEq œÉ
use `set_option diagnostics true` to get diagnostic information
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.29194 ‚Üí ?m.29194 ‚Üí Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.29869 ‚Üí ?m.29869 ‚Üí Prop
error:  unsolved goals
case neg
R : Type u_1
M : Type u_2
inst‚úù¬π : CommSemiring R
œÉ : Type u_3
inst‚úù : AddCommMonoid M
w : œÉ ‚Üí M
m n : M
œÜ : MvPolynomial œÉ R
hœÜ : œÜ ‚àà weightedHomogeneousSubmodule R w m
œà : MvPolynomial œÉ R
hœà : œà ‚àà weightedHomogeneousSubmodule R w n
c : œÉ ‚Üí‚ÇÄ ‚Ñï
hc‚úù : coeff c (œÜ * œà) ‚â† 0
hc : ‚àë x ‚àà antidiagonal c, coeff x.1 œÜ * coeff x.2 œà ‚â† 0
d e : œÉ ‚Üí‚ÇÄ ‚Ñï
hde : (d, e) ‚àà antidiagonal c
H : coeff d œÜ ‚â† 0 ‚Üí coeff e œà = 0
h : ¬¨coeff d œÜ = 0
‚ä¢ coeff d œÜ * coeff e œà = 0
error:  unknown constant 'Finsupp.mem_antidiagonal.mp'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.30020
case intro.mk.intro
R : Type u_1
M : Type u_2
inst‚úù¬π : CommSemiring R
œÉ : Type u_3
inst‚úù : AddCommMonoid M
w : œÉ ‚Üí M
m n : M
œÜ : MvPolynomial œÉ R
hœÜ : œÜ ‚àà weightedHomogeneousSubmodule R w m
œà : MvPolynomial œÉ R
hœà : œà ‚àà weightedHomogeneousSubmodule R w n
c : œÉ ‚Üí‚ÇÄ ‚Ñï
hc‚úù : coeff c (œÜ * œà) ‚â† 0
hc : ‚àë x ‚àà antidiagonal c, coeff x.1 œÜ * coeff x.2 œà ‚â† 0
d e : œÉ ‚Üí‚ÇÄ ‚Ñï
hde : (d, e) ‚àà antidiagonal c
H : coeff (d, e).1 œÜ * coeff (d, e).2 œà ‚â† 0
aux : coeff d œÜ ‚â† 0 ‚àß coeff e œà ‚â† 0
‚ä¢ (weightedDegree w) c = m + n","theorem weightedHomogeneousSubmodule_mul (w : œÉ ‚Üí M) (m n : M) :
    weightedHomogeneousSubmodule R w m * weightedHomogeneousSubmodule R w n ‚â§
      weightedHomogeneousSubmodule R w (m + n) ",":= by
  classical
  rw [Submodule.mul_le]
  intro œÜ hœÜ œà hœà c hc
  rw [coeff_mul] at hc
  obtain ‚ü®‚ü®d, e‚ü©, hde, H‚ü© := Finset.exists_ne_zero_of_sum_ne_zero hc
  have aux : coeff d œÜ ‚â† 0 ‚àß coeff e œà ‚â† 0 := by
    contrapose! H
    by_cases h : coeff d œÜ = 0 <;>
      simp_all only [Ne, not_false_iff, zero_mul, mul_zero]
  rw [‚Üê mem_antidiagonal.mp hde, ‚Üê hœÜ aux.1, ‚Üê hœà aux.2, map_add]"
Mathlib/LinearAlgebra/Matrix/Spectrum.lean,Matrix.IsHermitian.det_eq_prod_eigenvalues,det_eq_prod_eigenvalues,aaf4ca2007ab15f02495731d0805034c9199aeea,":= by
  apply mul_left_cancel‚ÇÄ <| det_ne_zero_of_left_inverse <|
    unitary.coe_mul_star_self hA.eigenvectorUnitary
  rw [unitary.coe_star, ‚Üê det_mul, spectral_theorem, det_mul, mul_comm, det_diagonal]
  simp_rw [Function.comp_apply]","error:  tactic 'rewrite' failed, pattern is a metavariable
  ?m.92295
from equation
  ?m.92295 = ‚Üë?hA.eigenvectorUnitary * diagonal (RCLike.ofReal ‚àò ?hA.eigenvalues) * star ‚Üë?hA.eigenvectorUnitary
ùïú : Type u_1
inst‚úù¬≤ : RCLike ùïú
n : Type u_2
inst‚úù¬π : Fintype n
A : Matrix n n ùïú
inst‚úù : DecidableEq n
hA : A.IsHermitian
‚ä¢ (star ‚ÜëhA.eigenvectorUnitary * A).det = (star ‚ÜëhA.eigenvectorUnitary).det * ‚àè i : n, ‚Üë(hA.eigenvalues i)","theorem det_eq_prod_eigenvalues : det A = ‚àè i, (hA.eigenvalues i : ùïú) ",":= by
  convert congr_arg det hA.spectral_theorem
  rw [det_mul_right_comm]
  simp"
Mathlib/Topology/Category/Stonean/Basic.lean,CompHaus.Gleason,Gleason,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  constructor
  ¬∑ intro h
    show ExtremallyDisconnected X.toStonean
    infer_instance
  ¬∑ intro h
    let X' : Stonean := ‚ü®X‚ü©
    show Projective X'.compHaus
    apply Stonean.instProjectiveCompHausCategoryCompHaus",error:  unknown constant 'Stonean.instProjectiveCompHausCategoryCompHaus',"lemma Gleason (X : CompHaus.{u}) :
    Projective X ‚Üî ExtremallyDisconnected X ",":= by
  constructor
  ¬∑ intro h
    show ExtremallyDisconnected X.toStonean
    infer_instance
  ¬∑ intro h
    let X' : Stonean := ‚ü®X‚ü©
    show Projective X'.compHaus
    apply Stonean.instProjectiveCompHausCompHaus"
Mathlib/Analysis/InnerProductSpace/Basic.lean,Orthonormal.comp,Orthonormal.comp,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  classical!
  rw [orthonormal_iff_ite] at hv ‚ä¢
  intro i j
  convert hv (f i) (f j) using 1
  simp [hf.eq_iff]",error:  `classical!` has been removed; use `classical` instead,"theorem Orthonormal.comp {Œπ' : Type*} {v : Œπ ‚Üí E} (hv : Orthonormal ùïú v) (f : Œπ' ‚Üí Œπ)
    (hf : Function.Injective f) : Orthonormal ùïú (v ‚àò f) ",":= by
  classical
  rw [orthonormal_iff_ite] at hv ‚ä¢
  intro i j
  convert hv (f i) (f j) using 1
  simp [hf.eq_iff]"
Mathlib/MeasureTheory/Integral/Gamma.lean,Complex.integral_rpow_mul_exp_neg_rpow,Complex.integral_rpow_mul_exp_neg_rpow,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  calc
    _ = ‚à´ x in Ioi (0 : ‚Ñù) √óÀ¢ Ioo (-œÄ) œÄ, x.1 * (|x.1| ^ q * rexp (-|x.1| ^ p)) : = by
      rw [‚Üê Complex.integral_comp_polarCoord_symm, polarCoord_target]
      simp_rw [Complex.norm_eq_abs, Complex.polardCoord_symm_abs, smul_eq_mul]
    _ = (‚à´ x in Ioi (0 : ‚Ñù), x * |x| ^ q * rexp (-|x| ^ p)) * ‚à´ _ in Ioo (-œÄ) œÄ, 1 : = by
      rw [‚Üê setIntegral_prod_mul, volume_eq_prod]
      simp_rw [mul_one]
      congr! 2; ring
    _ = 2 * œÄ * ‚à´ x in Ioi (0 : ‚Ñù), x * |x| ^ q * rexp (-|x| ^ p) : = by
      simp_rw [integral_const, Measure.restrict_apply MeasurableSet.univ, Set.univ_inter,
        volume_Ioo, sub_neg_eq_add, ‚Üê two_mul, ENNReal.toReal_ofReal (by positivity : 0 ‚â§ 2 * œÄ),
        smul_eq_mul, mul_one, mul_comm]
    _ = 2 * œÄ * ‚à´ x in Ioi (0 : ‚Ñù), x ^ (q + 1) * rexp (-x ^ p) : = by
      congr 1
      refine setIntegral_congr measurableSet_Ioi (fun x hx => ?_)
      rw [abs_eq_self.mpr (le_of_lt (by exact hx)), rpow_add hx, rpow_one]
      ring
    _ = (2 * Real.pi / p) * Real.Gamma ((q + 2) / p) := by
      rw [_root_.integral_rpow_mul_exp_neg_rpow (by linarith) (by linarith), add_assoc,
        one_add_one_eq_two]
      ring","error:  invalid 'calc' step, failed to synthesize `Trans` instance
  Trans Eq Eq ?m.38557
use `set_option diagnostics true` to get diagnostic information
error:  unexpected token ':'; expected command","theorem Complex.integral_rpow_mul_exp_neg_rpow {p q : ‚Ñù} (hp : 1 ‚â§ p) (hq : - 2 < q) :
    ‚à´ x : ‚ÑÇ, ‚Äñx‚Äñ ^ q * rexp (- ‚Äñx‚Äñ ^ p) = (2 * œÄ / p) * Real.Gamma ((q + 2) / p) ",":= by
  calc
    _ = ‚à´ x in Ioi (0:‚Ñù) √óÀ¢ Ioo (-œÄ) œÄ, x.1 * (|x.1| ^ q * rexp (-|x.1| ^ p)) := by
      rw [‚Üê Complex.integral_comp_polarCoord_symm, polarCoord_target]
      simp_rw [Complex.norm_eq_abs, Complex.polardCoord_symm_abs, smul_eq_mul]
    _ = (‚à´ x in Ioi (0:‚Ñù), x * |x| ^ q * rexp (-|x| ^ p)) * ‚à´ _ in Ioo (-œÄ) œÄ, 1 := by
      rw [‚Üê setIntegral_prod_mul, volume_eq_prod]
      simp_rw [mul_one]
      congr! 2; ring
    _ = 2 * œÄ * ‚à´ x in Ioi (0:‚Ñù), x * |x| ^ q * rexp (-|x| ^ p) := by
      simp_rw [integral_const, Measure.restrict_apply MeasurableSet.univ, Set.univ_inter,
        volume_Ioo, sub_neg_eq_add, ‚Üê two_mul, ENNReal.toReal_ofReal (by positivity : 0 ‚â§ 2 * œÄ),
        smul_eq_mul, mul_one, mul_comm]
    _ = 2 * œÄ * ‚à´ x in Ioi (0:‚Ñù), x ^ (q + 1) * rexp (-x ^ p) := by
      congr 1
      refine setIntegral_congr measurableSet_Ioi (fun x hx => ?_)
      rw [abs_eq_self.mpr (le_of_lt (by exact hx)), rpow_add hx, rpow_one]
      ring
    _ = (2 * Real.pi / p) * Real.Gamma ((q + 2) / p) := by
      rw [_root_.integral_rpow_mul_exp_neg_rpow (by linarith) (by linarith), add_assoc,
        one_add_one_eq_two]
      ring"
Mathlib/SetTheory/Ordinal/Principal.lean,Ordinal.principal_add_iff_zero_or_omega_opow,principal_add_iff_zero_or_omega_opow,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  rcases eq_or_ne o 0 with (rfl | ho)
  ¬∑ simp only [principal_zero, Or.inl]
  ¬∑ rw [principal_add_iff_add_left_eq_self]
    simp only [ho, false_or_iff]
    refine'
      ‚ü®fun H => ‚ü®_, ((lt_or_eq_of_le (opow_log_le_self _ ho)).resolve_left fun h => _).symm‚ü©,
        fun ‚ü®b, e‚ü© => e.symm ‚ñ∏ fun a => add_omega_opow‚ü©
    have := H _ h
    have := lt_opow_succ_log_self one_lt_omega o
    rw [opow_succ, lt_mul_of_limit omega_isLimit] at this
    rcases this with ‚ü®a, ao, h'‚ü©
    rcases lt_omega.1 ao with ‚ü®n, rfl‚ü©
    clear ao
    revert h'
    apply not_lt_of_le
    suffices e : (omega^log omega o) * ‚Üën + o = o
    ¬∑ simpa only [e] using le_add_right ((omega^log omega o) * ‚Üën) o
    induction' n with n IH
    ¬∑ simp [Nat.cast_zero, mul_zero, zero_add]
    simp only [Nat.cast_succ, mul_add_one, add_assoc, this, IH]",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem principal_add_iff_zero_or_omega_opow {o : Ordinal} :
    Principal (¬∑ + ¬∑) o ‚Üî o = 0 ‚à® ‚àÉ a : Ordinal, o = (omega^a) ",":= by
  rcases eq_or_ne o 0 with (rfl | ho)
  ¬∑ simp only [principal_zero, Or.inl]
  ¬∑ rw [principal_add_iff_add_left_eq_self]
    simp only [ho, false_or_iff]
    refine
      ‚ü®fun H => ‚ü®_, ((lt_or_eq_of_le (opow_log_le_self _ ho)).resolve_left fun h => ?_).symm‚ü©,
        fun ‚ü®b, e‚ü© => e.symm ‚ñ∏ fun a => add_omega_opow‚ü©
    have := H _ h
    have := lt_opow_succ_log_self one_lt_omega o
    rw [opow_succ, lt_mul_of_limit omega_isLimit] at this
    rcases this with ‚ü®a, ao, h'‚ü©
    rcases lt_omega.1 ao with ‚ü®n, rfl‚ü©
    clear ao
    revert h'
    apply not_lt_of_le
    suffices e : (omega^log omega o) * ‚Üën + o = o by
      simpa only [e] using le_add_right ((omega^log omega o) * ‚Üën) o
    induction' n with n IH
    ¬∑ simp [Nat.cast_zero, mul_zero, zero_add]
    simp only [Nat.cast_succ, mul_add_one, add_assoc, this, IH]"
Mathlib/RingTheory/PrincipalIdealDomain.lean,IsPrincipalIdealRing.of_prime,IsPrincipalIdealRing.of_prime,4da4e0ebfbf51ecc2e064d04970434177efdead3,":= by
  rw [‚Üê nonPrincipals_eq_empty_iff, Set.eq_empty_iff_forall_not_mem]
  intro J hJ
  obtain ‚ü®I, Ibad, -, Imax‚ü© := zorn_nonempty_partialOrder‚ÇÄ (nonPrincipals R) nonPrincipals_zorn _ hJ
  have Imax' : ‚àÄ {J}, I < J ‚Üí J.IsPrincipal := by
    intro J hJ
    by_contra He
    exact hJ.ne (Imax _ ((nonPrincipals_def R).2 He) hJ.le).symm
  by_cases hI1 : I = ‚ä§
  ¬∑ subst hI1
    exact Ibad top_isPrincipal
  refine Ibad (H I ‚ü®hI1, fun {x y} hxy => or_iff_not_imp_right.mpr fun hy => ?_‚ü©)
  obtain ‚ü®a, ha‚ü© : (I ‚äî span {y}).IsPrincipal :=
    Imax' (left_lt_sup.mpr (mt I.span_singleton_le_iff_mem.mp hy))
  suffices He : ¬¨(I.colon (span {y})).IsPrincipal by
    rw [‚Üê Imax _ ((nonPrincipals_def R).2 He) fun a ha =>
        Ideal.mem_colon_singleton.2 (mul_mem_right _ _ ha)]
    exact Ideal.mem_colon_singleton.2 hxy
  rintro ‚ü®b, hb‚ü©
  refine (nonPrincipals_def _).1 Ibad ‚ü®a * b, ?_‚ü©
  refine
    le_antisymm (Œ± := Ideal R) (fun i hi => ?_) <|
      (span_singleton_mul_span_singleton a b).ge.trans? _
  ¬∑ have hisup : i ‚àà I ‚äî span {y} := Ideal.mem_sup_left hi
    have : y ‚àà I ‚äî span {y} := Ideal.mem_sup_right (Ideal.mem_span_singleton_self y)
    erw [ha, mem_span_singleton'] at hisup this
    obtain ‚ü®v, rfl‚ü© := this
    obtain ‚ü®u, rfl‚ü© := hisup
    have hucolon : u ‚àà I.colon (span {v * a}) := by
      rw [Ideal.mem_colon_singleton, mul_comm v, ‚Üê mul_assoc]
      exact mul_mem_right _ _ hi
    erw [hb, mem_span_singleton'] at hucolon
    obtain ‚ü®z, rfl‚ü© := hucolon
    exact mem_span_singleton'.2 ‚ü®z, by ring‚ü©
  ¬∑ rw [‚Üê Ideal.submodule_span_eq, ‚Üê ha, Ideal.sup_mul, sup_le_iff,
      span_singleton_mul_span_singleton, mul_comm y, Ideal.span_singleton_le_iff_mem]
    exact ‚ü®mul_le_right, Ideal.mem_colon_singleton.1 <| hb.symm ‚ñ∏ Ideal.mem_span_singleton_self b‚ü©","error:  invalid field 'trans?', the environment does not contain 'LE.le.trans?'
  Eq.ge (span_singleton_mul_span_singleton a b)
has type
  Ideal.span {a * b} ‚â§ Ideal.span {a} * Ideal.span {b}
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Eq.ge (span_singleton_mul_span_singleton a b)
has type
  ?m.139941 ‚àà Ideal.span {a * b} ‚Üí ?m.139941 ‚àà Ideal.span {a} * Ideal.span {b}
error:  no goals to be solved","theorem IsPrincipalIdealRing.of_prime (H : ‚àÄ P : Ideal R, P.IsPrime ‚Üí P.IsPrincipal) :
    IsPrincipalIdealRing R ",":= by
  rw [‚Üê nonPrincipals_eq_empty_iff, Set.eq_empty_iff_forall_not_mem]
  intro J hJ
  obtain ‚ü®I, Ibad, -, Imax‚ü© := zorn_nonempty_partialOrder‚ÇÄ (nonPrincipals R) nonPrincipals_zorn _ hJ
  have Imax' : ‚àÄ {J}, I < J ‚Üí J.IsPrincipal := by
    intro J hJ
    by_contra He
    exact hJ.ne (Imax _ ((nonPrincipals_def R).2 He) hJ.le).symm
  by_cases hI1 : I = ‚ä§
  ¬∑ subst hI1
    exact Ibad top_isPrincipal
  refine Ibad (H I ‚ü®hI1, fun {x y} hxy => or_iff_not_imp_right.mpr fun hy => ?_‚ü©)
  obtain ‚ü®a, ha‚ü© : (I ‚äî span {y}).IsPrincipal :=
    Imax' (left_lt_sup.mpr (mt I.span_singleton_le_iff_mem.mp hy))
  suffices He : ¬¨(I.colon (span {y})).IsPrincipal by
    rw [‚Üê Imax _ ((nonPrincipals_def R).2 He) fun a ha =>
        Ideal.mem_colon_singleton.2 (mul_mem_right _ _ ha)]
    exact Ideal.mem_colon_singleton.2 hxy
  rintro ‚ü®b, hb‚ü©
  refine (nonPrincipals_def _).1 Ibad ‚ü®a * b, ?_‚ü©
  refine
    le_antisymm (Œ± := Ideal R) (fun i hi => ?_) <|
      (span_singleton_mul_span_singleton a b).ge.trans ?_
  ¬∑ have hisup : i ‚àà I ‚äî span {y} := Ideal.mem_sup_left hi
    have : y ‚àà I ‚äî span {y} := Ideal.mem_sup_right (Ideal.mem_span_singleton_self y)
    erw [ha, mem_span_singleton'] at hisup this
    obtain ‚ü®v, rfl‚ü© := this
    obtain ‚ü®u, rfl‚ü© := hisup
    have hucolon : u ‚àà I.colon (span {v * a}) := by
      rw [Ideal.mem_colon_singleton, mul_comm v, ‚Üê mul_assoc]
      exact mul_mem_right _ _ hi
    erw [hb, mem_span_singleton'] at hucolon
    obtain ‚ü®z, rfl‚ü© := hucolon
    exact mem_span_singleton'.2 ‚ü®z, by ring‚ü©
  ¬∑ rw [‚Üê Ideal.submodule_span_eq, ‚Üê ha, Ideal.sup_mul, sup_le_iff,
      span_singleton_mul_span_singleton, mul_comm y, Ideal.span_singleton_le_iff_mem]
    exact ‚ü®mul_le_right, Ideal.mem_colon_singleton.1 <| hb.symm ‚ñ∏ Ideal.mem_span_singleton_self b‚ü©"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.partialGamma_add_one,partialGamma_add_one,63aaa8cc21050b7a5cb193c6764569918728723b,":= by
  rw [partialGamma, partialGamma, add_sub_cancel]
  have F_der_I : ‚àÄ x : ‚Ñù, x ‚àà Ioo 0 X ‚Üí HasDerivAt (fun x => (-x).exp * x ^ s : ‚Ñù ‚Üí ‚ÑÇ)
      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by
    intro x hx
    have d1 : HasDerivAt (fun y : ‚Ñù => (-y).exp) (-(-x).exp) x := by
      simpa using (hasDerivAt_neg x).exp
    have d2 : HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ s) (s * x ^ (s - 1)) x := by
      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id ‚Üëx) ?_
      ¬∑ simpa only [mul_one] using t.comp_ofReal
      ¬∑ exact ofReal_mem_slitPlane.2 hx.1
    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2
  have cont := (continuous_ofReal.comp continuous_neg.exp).mul (continuous_ofReal_cpow_const hs)
  have der_ible :=
    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)
  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible
  apply_fun fun x : ‚ÑÇ => -x at int_eval
  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)
      (Gamma_integrand_deriv_integrable_B hs hX),
    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval
  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]
  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : ‚Ñù ‚Üí ‚ÑÇ) =
      (fun x => s * (-x).exp * x ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) := by ext1; ring
  rw [this]
  have t := @integral_const_mul 0 X volume _ _ s fun x : ‚Ñù => (-x).exp * x ^ (s - 1)
  rw [‚Üê t, ofReal_zero, zero_cpow]
  ¬∑ rw [mul_zero, add_zero]; congr 2; ext1; ring
  ¬∑ contrapose! hs; rw [hs, zero_re]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + (?b - ?a)
s : ‚ÑÇ
hs : 0 < s.re
X : ‚Ñù
hX : 0 ‚â§ X
‚ä¢ ‚à´ (x : ‚Ñù) in 0 ..X, ‚Üë(rexp (-x)) * ‚Üëx ^ (s + 1 - 1) =
    (s * ‚à´ (x : ‚Ñù) in 0 ..X, ‚Üë(rexp (-x)) * ‚Üëx ^ (s - 1)) - ‚Üë(rexp (-X)) * ‚ÜëX ^ s","theorem partialGamma_add_one {s : ‚ÑÇ} (hs : 0 < s.re) {X : ‚Ñù} (hX : 0 ‚â§ X) :
    partialGamma (s + 1) X = s * partialGamma s X - (-X).exp * X ^ s ",":= by
  rw [partialGamma, partialGamma, add_sub_cancel_right]
  have F_der_I : ‚àÄ x : ‚Ñù, x ‚àà Ioo 0 X ‚Üí HasDerivAt (fun x => (-x).exp * x ^ s : ‚Ñù ‚Üí ‚ÑÇ)
      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by
    intro x hx
    have d1 : HasDerivAt (fun y : ‚Ñù => (-y).exp) (-(-x).exp) x := by
      simpa using (hasDerivAt_neg x).exp
    have d2 : HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ s) (s * x ^ (s - 1)) x := by
      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id ‚Üëx) ?_
      ¬∑ simpa only [mul_one] using t.comp_ofReal
      ¬∑ exact ofReal_mem_slitPlane.2 hx.1
    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2
  have cont := (continuous_ofReal.comp continuous_neg.rexp).mul (continuous_ofReal_cpow_const hs)
  have der_ible :=
    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)
  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible
  apply_fun fun x : ‚ÑÇ => -x at int_eval
  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)
      (Gamma_integrand_deriv_integrable_B hs hX),
    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval
  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]
  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : ‚Ñù ‚Üí ‚ÑÇ) =
      (fun x => s * (-x).exp * x ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) := by ext1; ring
  rw [this]
  have t := @integral_const_mul 0 X volume _ _ s fun x : ‚Ñù => (-x).exp * x ^ (s - 1)
  rw [‚Üê t, ofReal_zero, zero_cpow]
  ¬∑ rw [mul_zero, add_zero]; congr 2; ext1; ring
  ¬∑ contrapose! hs; rw [hs, zero_re]"
Mathlib/Analysis/Convex/Slope.lean,StrictConvexOn.slope_strict_mono_adjacent,StrictConvexOn.slope_strict_mono_adjacent,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  have hxz := hxy.trans hyz
  have hxz' := hxz.ne
  rw [‚Üê sub_pos] at hxy hxz hyz
  suffices f y / (y - x) + f y / (z - y) < f x / (y - x) + f z / (z - y) by
    ring_nf at this ‚ä¢
    linarith
  set a := (z - y) / (z - x)
  set b := (y - x) / (z - x)
  have hy : a ‚Ä¢ x + b ‚Ä¢ z = y := by field_simp; ring
  have key :=
    hf.2 hx hz hxz' (div_pos hyz hxz) (div_pos hxy hxz)
      (show a + b = 1 by field_simp)
  rw [hy] at key
  replace key := mul_lt_mul_of_pos_left key hxz
  field_simp [mul_comm (z - x) _] at key ‚ä¢
  rw [div_lt_div_right]
  ¬∑ linarith
  ¬∑ nlinarith","info:  Try this: ring_nf
error:  unsolved goals
ùïú : Type u_1
inst‚úù : LinearOrderedField ùïú
s : Set ùïú
f : ùïú ‚Üí ùïú
hf : StrictConvexOn ùïú s f
x y z : ùïú
hx : x ‚àà s
hz : z ‚àà s
hxy : 0 < y - x
hyz : 0 < z - y
hxz : 0 < z - x
hxz' : x ‚â† z
a : ùïú := (z - y) / (z - x)
b : ùïú := (y - x) / (z - x)
‚ä¢ z * y * (z - x)‚Åª¬π - y * x * (z - x)‚Åª¬π = y
error:  simp made no progress","theorem StrictConvexOn.slope_strict_mono_adjacent (hf : StrictConvexOn ùïú s f) {x y z : ùïú}
    (hx : x ‚àà s) (hz : z ‚àà s) (hxy : x < y) (hyz : y < z) :
    (f y - f x) / (y - x) < (f z - f y) / (z - y) ",":= by
  have hxz := hxy.trans hyz
  have hxz' := hxz.ne
  rw [‚Üê sub_pos] at hxy hxz hyz
  suffices f y / (y - x) + f y / (z - y) < f x / (y - x) + f z / (z - y) by
    ring_nf at this ‚ä¢
    linarith
  set a := (z - y) / (z - x)
  set b := (y - x) / (z - x)
  have hy : a ‚Ä¢ x + b ‚Ä¢ z = y := by field_simp [a, b]; ring
  have key :=
    hf.2 hx hz hxz' (div_pos hyz hxz) (div_pos hxy hxz)
      (show a + b = 1 by field_simp [a, b])
  rw [hy] at key
  replace key := mul_lt_mul_of_pos_left key hxz
  field_simp [mul_comm (z - x) _] at key ‚ä¢
  rw [div_lt_div_right]
  ¬∑ linarith
  ¬∑ nlinarith"
Mathlib/Data/Nat/Factorial/Basic.lean,Nat.pow_succ_le_ascFactorial,pow_succ_le_ascFactorial,df9cfef55a1b8cd650f6575f7f576b85ef124030,"  | 0 => by rw [ascFactorial_zero, Nat.pow_zero]; exact Nat.le_refl _
  | k + 1 => by
    rw [Nat.pow_succ, Nat.mul_comm, ascFactorial_succ, ‚Üê succ_ascFactorial]
    exact Nat.mul_le_mul (Nat.le_refl n)
      (Nat.le_trans (Nat.pow_le_pow_left (le_succ n) k) (pow_succ_le_ascFactorial n.succ k))",error:  no goals to be solved,"theorem pow_succ_le_ascFactorial (n : ‚Ñï) : ‚àÄ k : ‚Ñï, n ^ k ‚â§ n.ascFactorial k
","  | 0 => by rw [ascFactorial_zero, Nat.pow_zero]
  | k + 1 => by
    rw [Nat.pow_succ, Nat.mul_comm, ascFactorial_succ, ‚Üê succ_ascFactorial]
    exact Nat.mul_le_mul (Nat.le_refl n)
      (Nat.le_trans (Nat.pow_le_pow_left (le_succ n) k) (pow_succ_le_ascFactorial n.succ k))"
Mathlib/MeasureTheory/Integral/Marginal.lean,MeasureTheory.lmarginal_update_of_not_mem,lmarginal_update_of_not_mem,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction s generalizing x with
  | empty => simp
  | @insert i' s hi' ih =>
    rw [lmarginal_insert _ hf hi', lmarginal_insert _ (hf.comp measurable_update_left) hi']
    have hii' : i ‚â† i' := mt (by rintro rfl; exact mem_insert_self i s) hi
    simp_rw [update_comm hii', ih (mt Finset.mem_insert_of_mem hi)]","warning:  @lmarginal does not have a doc string
warning:  @lmarginal does not have a doc string
error:  invalid alternative name 'empty'","theorem lmarginal_update_of_not_mem {i : Œ¥}
    {f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) (hi : i ‚àâ s) (x : ‚àÄ i, œÄ i) (y : œÄ i) :
    (‚à´‚ãØ‚à´‚Åª_s, f ‚àÇŒº) (Function.update x i y) = (‚à´‚ãØ‚à´‚Åª_s, f ‚àò (Function.update ¬∑ i y) ‚àÇŒº) x ",":= by
  induction s using Finset.induction generalizing x with
  | empty => simp
  | @insert i' s hi' ih =>
    rw [lmarginal_insert _ hf hi', lmarginal_insert _ (hf.comp measurable_update_left) hi']
    have hii' : i ‚â† i' := mt (by rintro rfl; exact mem_insert_self i s) hi
    simp_rw [update_comm hii', ih (mt Finset.mem_insert_of_mem hi)]"
Mathlib/RingTheory/DedekindDomain/Ideal.lean,exists_multiset_prod_cons_le_and_prod_not_le,exists_multiset_prod_cons_le_and_prod_not_le,c3ab0e431ee2be2cbb5176e1e0c1ef11b3cd98cc,":= by
  obtain ‚ü®Z‚ÇÄ, hZ‚ÇÄ‚ü© := PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain hNF hI0
  obtain ‚ü®Z, ‚ü®hZI, hprodZ‚ü©, h_eraseZ‚ü© :=
    Multiset.wellFounded_lt.has_min
      (fun Z => (Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß (Z.map PrimeSpectrum.asIdeal).prod ‚â† ‚ä•)
      ‚ü®Z‚ÇÄ, hZ‚ÇÄ‚ü©
  have hZM : Multiset.prod (Z.map PrimeSpectrum.asIdeal) ‚â§ M := le_trans hZI hIM
  have hZ0 : Z ‚â† 0 := by rintro rfl; simp [hM.ne_top] at hZM
  obtain ‚ü®_, hPZ', hPM‚ü© := (hM.isPrime.multiset_prod_le (mt Multiset.map_eq_zero.mp hZ0)).mp hZM
  obtain ‚ü®P, hPZ, rfl‚ü© := Multiset.mem_map.mp hPZ'
  classical
    have := Multiset.map_erase PrimeSpectrum.asIdeal PrimeSpectrum.ext P Z
    obtain ‚ü®hP0, hZP0‚ü© : P.asIdeal ‚â† ‚ä• ‚àß ((Z.erase P).map PrimeSpectrum.asIdeal).prod ‚â† ‚ä• := by
      rwa [Ne.def, ‚Üê Multiset.cons_erase hPZ', Multiset.prod_cons, Ideal.mul_eq_bot, not_or, ‚Üê
        this] at hprodZ
    have hPM' := (P.IsPrime.isMaximal hP0).eq_of_le hM.ne_top hPM
    subst hPM'
    refine ‚ü®Z.erase P, ?_, ?_‚ü©
    ¬∑ convert hZI
      rw [this, Multiset.cons_erase hPZ']
    ¬∑ refine fun h => h_eraseZ (Z.erase P) ‚ü®h, ?_‚ü© (Multiset.erase_lt.mpr hPZ)
      exact hZP0","error:  unknown constant 'Multiset.wellFounded_lt.has_min'
error:  rcases tactic failed: x‚úù : ?m.159565 is not an inductive datatype","theorem exists_multiset_prod_cons_le_and_prod_not_le [IsDedekindDomain A] (hNF : ¬¨IsField A)
    {I M : Ideal A} (hI0 : I ‚â† ‚ä•) (hIM : I ‚â§ M) [hM : M.IsMaximal] :
    ‚àÉ Z : Multiset (PrimeSpectrum A),
      (M ::‚Çò Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß
        ¬¨Multiset.prod (Z.map PrimeSpectrum.asIdeal) ‚â§ I ",":= by
  obtain ‚ü®Z‚ÇÄ, hZ‚ÇÄ‚ü© := PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain hNF hI0
  obtain ‚ü®Z, ‚ü®hZI, hprodZ‚ü©, h_eraseZ‚ü© :=
    wellFounded_lt.has_min
      {Z | (Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß (Z.map PrimeSpectrum.asIdeal).prod ‚â† ‚ä•}
      ‚ü®Z‚ÇÄ, hZ‚ÇÄ.1, hZ‚ÇÄ.2‚ü©
  obtain ‚ü®_, hPZ', hPM‚ü© := hM.isPrime.multiset_prod_le.mp (hZI.trans hIM)
  obtain ‚ü®P, hPZ, rfl‚ü© := Multiset.mem_map.mp hPZ'
  classical
    have := Multiset.map_erase PrimeSpectrum.asIdeal PrimeSpectrum.ext P Z
    obtain ‚ü®hP0, hZP0‚ü© : P.asIdeal ‚â† ‚ä• ‚àß ((Z.erase P).map PrimeSpectrum.asIdeal).prod ‚â† ‚ä• := by
      rwa [Ne, ‚Üê Multiset.cons_erase hPZ', Multiset.prod_cons, Ideal.mul_eq_bot, not_or, ‚Üê
        this] at hprodZ
    have hPM' := (P.isPrime.isMaximal hP0).eq_of_le hM.ne_top hPM
    subst hPM'
    refine ‚ü®Z.erase P, ?_, ?_‚ü©
    ¬∑ convert hZI
      rw [this, Multiset.cons_erase hPZ']
    ¬∑ refine fun h => h_eraseZ (Z.erase P) ‚ü®h, ?_‚ü© (Multiset.erase_lt.mpr hPZ)
      exact hZP0"
Mathlib/NumberTheory/Padics/PadicVal.lean,padicValRat.padicValRat_le_padicValRat_iff,padicValRat_le_padicValRat_iff,e8ad950d2a458423931793f5cda18b99a90223d6,":= by
  have hf1 : Finite (p : ‚Ñ§) (n‚ÇÅ * d‚ÇÇ) := finite_int_prime_iff.2 (mul_ne_zero hn‚ÇÅ hd‚ÇÇ)
  have hf2 : Finite (p : ‚Ñ§) (n‚ÇÇ * d‚ÇÅ) := finite_int_prime_iff.2 (mul_ne_zero hn‚ÇÇ hd‚ÇÅ)
  conv =>
    lhs
    rw [padicValRat.defn p (Rat.divInt_ne_zero_of_ne_zero hn‚ÇÅ hd‚ÇÅ) rfl,
      padicValRat.defn p (Rat.divInt_ne_zero_of_ne_zero hn‚ÇÇ hd‚ÇÇ) rfl, sub_le_iff_le_add', ‚Üê
      add_sub_assoc, _root_.le_sub_iff_add_le]
    norm_cast
    rw [‚Üê multiplicity.mul' (Nat.prime_iff_prime_int.1 hp.1) hf1, add_comm, ‚Üê
      multiplicity.mul' (Nat.prime_iff_prime_int.1 hp.1) hf2, PartENat.get_le_get,
      multiplicity_le_multiplicity_iff]
  exact Iff.rfl",error:  no goals to be solved,"theorem padicValRat_le_padicValRat_iff {n‚ÇÅ n‚ÇÇ d‚ÇÅ d‚ÇÇ : ‚Ñ§} (hn‚ÇÅ : n‚ÇÅ ‚â† 0) (hn‚ÇÇ : n‚ÇÇ ‚â† 0)
    (hd‚ÇÅ : d‚ÇÅ ‚â† 0) (hd‚ÇÇ : d‚ÇÇ ‚â† 0) :
    padicValRat p (n‚ÇÅ /. d‚ÇÅ) ‚â§ padicValRat p (n‚ÇÇ /. d‚ÇÇ) ‚Üî
      ‚àÄ n : ‚Ñï, (p : ‚Ñ§) ^ n ‚à£ n‚ÇÅ * d‚ÇÇ ‚Üí (p : ‚Ñ§) ^ n ‚à£ n‚ÇÇ * d‚ÇÅ ",":= by
  have hf1 : Finite (p : ‚Ñ§) (n‚ÇÅ * d‚ÇÇ) := finite_int_prime_iff.2 (mul_ne_zero hn‚ÇÅ hd‚ÇÇ)
  have hf2 : Finite (p : ‚Ñ§) (n‚ÇÇ * d‚ÇÅ) := finite_int_prime_iff.2 (mul_ne_zero hn‚ÇÇ hd‚ÇÅ)
  conv =>
    lhs
    rw [padicValRat.defn p (Rat.divInt_ne_zero_of_ne_zero hn‚ÇÅ hd‚ÇÅ) rfl,
      padicValRat.defn p (Rat.divInt_ne_zero_of_ne_zero hn‚ÇÇ hd‚ÇÇ) rfl, sub_le_iff_le_add', ‚Üê
      add_sub_assoc, _root_.le_sub_iff_add_le]
    norm_cast
    rw [‚Üê multiplicity.mul' (Nat.prime_iff_prime_int.1 hp.1) hf1, add_comm, ‚Üê
      multiplicity.mul' (Nat.prime_iff_prime_int.1 hp.1) hf2, PartENat.get_le_get,
      multiplicity_le_multiplicity_iff]"
Mathlib/Analysis/MellinTransform.lean,mellin_hasDerivAt_of_isBigO_rpow,mellin_hasDerivAt_of_isBigO_rpow,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  set F : ‚ÑÇ ‚Üí ‚Ñù ‚Üí E := fun (z : ‚ÑÇ) (t : ‚Ñù) => (t : ‚ÑÇ) ^ (z - 1) ‚Ä¢ f t
  set F' : ‚ÑÇ ‚Üí ‚Ñù ‚Üí E := fun (z : ‚ÑÇ) (t : ‚Ñù) => ((t : ‚ÑÇ) ^ (z - 1) * log t) ‚Ä¢ f t
  obtain ‚ü®v, hv0, hv1, hv2‚ü© : ‚àÉ v : ‚Ñù, 0 < v ‚àß v < s.re - b ‚àß v < a - s.re := by
    obtain ‚ü®w, hw1, hw2‚ü© := exists_between (sub_pos.mpr hs_top)
    obtain ‚ü®w', hw1', hw2'‚ü© := exists_between (sub_pos.mpr hs_bot)
    exact
      ‚ü®min w w', lt_min hw1 hw1', (min_le_right _ _).trans_lt hw2', (min_le_left _ _).trans_lt hw2‚ü©
  let bound : ‚Ñù ‚Üí ‚Ñù := fun t : ‚Ñù => (t ^ (s.re + v - 1) + t ^ (s.re - v - 1)) * |log t| * ‚Äñf t‚Äñ
  have h1 : ‚àÄ·∂† z : ‚ÑÇ in ùìù s, AEStronglyMeasurable (F z) (volume.restrict <| Ioi 0) := by
    refine eventually_of_forall fun z => AEStronglyMeasurable.smul ?_ hfc.aestronglyMeasurable
    refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
    refine ContinuousAt.continuousOn fun t ht => ?_
    exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
  have h2 : IntegrableOn (F s) (Ioi (0 : ‚Ñù)) := by
    exact mellinConvergent_of_isBigO_rpow hfc hf_top hs_top hf_bot hs_bot
  have h3 : AEStronglyMeasurable (F' s) (volume.restrict <| Ioi 0) := by
    apply LocallyIntegrableOn.aestronglyMeasurable
    refine hfc.continuousOn_smul isOpen_Ioi ((ContinuousAt.continuousOn fun t ht => ?_).mul ?_)
    ¬∑ exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
    ¬∑ refine continuous_ofReal.comp_continuousOn ?_
      exact continuousOn_log.mono (subset_compl_singleton_iff.mpr not_mem_Ioi_self)
  have h4 : ‚àÄ·µê t : ‚Ñù ‚àÇvolume.restrict (Ioi 0),
      ‚àÄ z : ‚ÑÇ, z ‚àà Metric.ball s v ‚Üí ‚ÄñF' z t‚Äñ ‚â§ bound t := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht z hz => ?_
    simp_rw [F', bound, norm_smul, norm_mul, Complex.norm_eq_abs (log _), Complex.abs_ofReal,
      mul_assoc]
    gcongr
    rw [Complex.norm_eq_abs, abs_cpow_eq_rpow_re_of_pos ht]
    rcases le_or_lt 1 t with h | h
    ¬∑ refine le_add_of_le_of_nonneg (rpow_le_rpow_of_exponent_le h ?_)
        (rpow_nonneg (zero_le_one.trans h) _)
      rw [sub_re, one_re, sub_le_sub_iff_right]
      rw [mem_ball_iff_norm, Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add'] at hz'
    ¬∑ refine
        le_add_of_nonneg_of_le (rpow_pos_of_pos ht _).le (rpow_le_rpow_of_exponent_ge ht h.le ?_)
      rw [sub_re, one_re, sub_le_iff_le_add, sub_add_cancel]
      rw [mem_ball_iff_norm', Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add, ‚Üê sub_le_iff_le_add'] at hz'
  have h5 : IntegrableOn bound (Ioi 0) := by
    simp_rw [bound, add_mul, mul_assoc]
    suffices ‚àÄ {j : ‚Ñù}, b < j ‚Üí j < a ‚Üí
        IntegrableOn (fun t : ‚Ñù => t ^ (j - 1) * (|log t| * ‚Äñf t‚Äñ)) (Ioi 0) volume by
      refine Integrable.add (this ?_ ?_) (this? _ ?_)
      all_goals linarith
    ¬∑ intro j hj hj'
      obtain ‚ü®w, hw1, hw2‚ü© := exists_between hj
      obtain ‚ü®w', hw1', hw2'‚ü© := exists_between hj'
      refine mellin_convergent_of_isBigO_scalar ?_ ?_ hw1?' _ hw2
      ¬∑ simp_rw [mul_comm]
        refine hfc.norm.mul_continuousOn ?_ isOpen_Ioi
        refine Continuous.comp_continuousOn _root_.continuous_abs (continuousOn_log.mono ?_)
        exact subset_compl_singleton_iff.mpr not_mem_Ioi_self
      ¬∑ refine (isBigO_rpow_top_log_smul hw2' hf_top).norm_left.congr_left fun t ‚Ü¶ ?_
        simp only [norm_smul, Real.norm_eq_abs]
      ¬∑ refine (isBigO_rpow_zero_log_smul hw1 hf_bot).norm_left.congr_left fun t ‚Ü¶ ?_
        simp only [norm_smul, Real.norm_eq_abs]
  have h6 : ‚àÄ·µê t : ‚Ñù ‚àÇvolume.restrict (Ioi 0),
      ‚àÄ y : ‚ÑÇ, y ‚àà Metric.ball s v ‚Üí HasDerivAt (fun z : ‚ÑÇ => F z t) (F' y t) y := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht y _ => ?_
    have ht' : (t : ‚ÑÇ) ‚â† 0 := ofReal_ne_zero.mpr (ne_of_gt ht)
    have u1 : HasDerivAt (fun z : ‚ÑÇ => (t : ‚ÑÇ) ^ (z - 1)) (t ^ (y - 1) * log t) y := by
      convert ((hasDerivAt_id' y).sub_const 1).const_cpow (Or.inl ht') using 1
      rw [ofReal_log (le_of_lt ht)]
      ring
    exact u1.smul_const (f t)
  have main := hasDerivAt_integral_of_dominated_loc_of_deriv_le hv0 h1 h2 h3 h4 h5 h6
  simpa only [F', mul_smul] using main","error:  unknown identifier 'this?'
error:  unknown identifier 'hw1?''","theorem mellin_hasDerivAt_of_isBigO_rpow [NormedSpace ‚ÑÇ E] {a b : ‚Ñù}
    {f : ‚Ñù ‚Üí E} {s : ‚ÑÇ} (hfc : LocallyIntegrableOn f (Ioi 0)) (hf_top : f =O[atTop] (¬∑ ^ (-a)))
    (hs_top : s.re < a) (hf_bot : f =O[ùìù[>] 0] (¬∑ ^ (-b))) (hs_bot : b < s.re) :
    MellinConvergent (fun t => log t ‚Ä¢ f t) s ‚àß
      HasDerivAt (mellin f) (mellin (fun t => log t ‚Ä¢ f t) s) s ",":= by
  set F : ‚ÑÇ ‚Üí ‚Ñù ‚Üí E := fun (z : ‚ÑÇ) (t : ‚Ñù) => (t : ‚ÑÇ) ^ (z - 1) ‚Ä¢ f t
  set F' : ‚ÑÇ ‚Üí ‚Ñù ‚Üí E := fun (z : ‚ÑÇ) (t : ‚Ñù) => ((t : ‚ÑÇ) ^ (z - 1) * log t) ‚Ä¢ f t
  obtain ‚ü®v, hv0, hv1, hv2‚ü© : ‚àÉ v : ‚Ñù, 0 < v ‚àß v < s.re - b ‚àß v < a - s.re := by
    obtain ‚ü®w, hw1, hw2‚ü© := exists_between (sub_pos.mpr hs_top)
    obtain ‚ü®w', hw1', hw2'‚ü© := exists_between (sub_pos.mpr hs_bot)
    exact
      ‚ü®min w w', lt_min hw1 hw1', (min_le_right _ _).trans_lt hw2', (min_le_left _ _).trans_lt hw2‚ü©
  let bound : ‚Ñù ‚Üí ‚Ñù := fun t : ‚Ñù => (t ^ (s.re + v - 1) + t ^ (s.re - v - 1)) * |log t| * ‚Äñf t‚Äñ
  have h1 : ‚àÄ·∂† z : ‚ÑÇ in ùìù s, AEStronglyMeasurable (F z) (volume.restrict <| Ioi 0) := by
    refine eventually_of_forall fun z => AEStronglyMeasurable.smul ?_ hfc.aestronglyMeasurable
    refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
    refine ContinuousAt.continuousOn fun t ht => ?_
    exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
  have h2 : IntegrableOn (F s) (Ioi (0 : ‚Ñù)) := by
    exact mellinConvergent_of_isBigO_rpow hfc hf_top hs_top hf_bot hs_bot
  have h3 : AEStronglyMeasurable (F' s) (volume.restrict <| Ioi 0) := by
    apply LocallyIntegrableOn.aestronglyMeasurable
    refine hfc.continuousOn_smul isOpen_Ioi ((ContinuousAt.continuousOn fun t ht => ?_).mul ?_)
    ¬∑ exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
    ¬∑ refine continuous_ofReal.comp_continuousOn ?_
      exact continuousOn_log.mono (subset_compl_singleton_iff.mpr not_mem_Ioi_self)
  have h4 : ‚àÄ·µê t : ‚Ñù ‚àÇvolume.restrict (Ioi 0),
      ‚àÄ z : ‚ÑÇ, z ‚àà Metric.ball s v ‚Üí ‚ÄñF' z t‚Äñ ‚â§ bound t := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht z hz => ?_
    simp_rw [F', bound, norm_smul, norm_mul, Complex.norm_eq_abs (log _), Complex.abs_ofReal,
      mul_assoc]
    gcongr
    rw [Complex.norm_eq_abs, abs_cpow_eq_rpow_re_of_pos ht]
    rcases le_or_lt 1 t with h | h
    ¬∑ refine le_add_of_le_of_nonneg (rpow_le_rpow_of_exponent_le h ?_)
        (rpow_nonneg (zero_le_one.trans h) _)
      rw [sub_re, one_re, sub_le_sub_iff_right]
      rw [mem_ball_iff_norm, Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add'] at hz'
    ¬∑ refine
        le_add_of_nonneg_of_le (rpow_pos_of_pos ht _).le (rpow_le_rpow_of_exponent_ge ht h.le ?_)
      rw [sub_re, one_re, sub_le_iff_le_add, sub_add_cancel]
      rw [mem_ball_iff_norm', Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add, ‚Üê sub_le_iff_le_add'] at hz'
  have h5 : IntegrableOn bound (Ioi 0) := by
    simp_rw [bound, add_mul, mul_assoc]
    suffices ‚àÄ {j : ‚Ñù}, b < j ‚Üí j < a ‚Üí
        IntegrableOn (fun t : ‚Ñù => t ^ (j - 1) * (|log t| * ‚Äñf t‚Äñ)) (Ioi 0) volume by
      refine Integrable.add (this ?_ ?_) (this ?_ ?_)
      all_goals linarith
    ¬∑ intro j hj hj'
      obtain ‚ü®w, hw1, hw2‚ü© := exists_between hj
      obtain ‚ü®w', hw1', hw2'‚ü© := exists_between hj'
      refine mellin_convergent_of_isBigO_scalar ?_ ?_ hw1' ?_ hw2
      ¬∑ simp_rw [mul_comm]
        refine hfc.norm.mul_continuousOn ?_ isOpen_Ioi
        refine Continuous.comp_continuousOn _root_.continuous_abs (continuousOn_log.mono ?_)
        exact subset_compl_singleton_iff.mpr not_mem_Ioi_self
      ¬∑ refine (isBigO_rpow_top_log_smul hw2' hf_top).norm_left.congr_left fun t ‚Ü¶ ?_
        simp only [norm_smul, Real.norm_eq_abs]
      ¬∑ refine (isBigO_rpow_zero_log_smul hw1 hf_bot).norm_left.congr_left fun t ‚Ü¶ ?_
        simp only [norm_smul, Real.norm_eq_abs]
  have h6 : ‚àÄ·µê t : ‚Ñù ‚àÇvolume.restrict (Ioi 0),
      ‚àÄ y : ‚ÑÇ, y ‚àà Metric.ball s v ‚Üí HasDerivAt (fun z : ‚ÑÇ => F z t) (F' y t) y := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht y _ => ?_
    have ht' : (t : ‚ÑÇ) ‚â† 0 := ofReal_ne_zero.mpr (ne_of_gt ht)
    have u1 : HasDerivAt (fun z : ‚ÑÇ => (t : ‚ÑÇ) ^ (z - 1)) (t ^ (y - 1) * log t) y := by
      convert ((hasDerivAt_id' y).sub_const 1).const_cpow (Or.inl ht') using 1
      rw [ofReal_log (le_of_lt ht)]
      ring
    exact u1.smul_const (f t)
  have main := hasDerivAt_integral_of_dominated_loc_of_deriv_le hv0 h1 h2 h3 h4 h5 h6
  simpa only [F', mul_smul] using main"
Mathlib/RingTheory/FinitePresentation.lean,RingHom.FinitePresentation.comp_surjective,comp_surjective,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":=
  letI := f.toSMul
  letI := f.toAlgebra
  letI := (g.comp f).toSMul
  letI := (g.comp f).toAlgebra
  letI : Algebra.FinitePresentation A B := hf
  Algebra.FinitePresentation.of_surjective
    (f :=
      { g with
        toFun := g
        commutes' := fun _ => rfl })
    hg hker","error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  f
has type
  A ‚Üí+* B
error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  g.comp f
has type
  A ‚Üí+* C","theorem comp_surjective {f : A ‚Üí+* B} {g : B ‚Üí+* C} (hf : f.FinitePresentation) (hg : Surjective g)
    (hker : g.ker.FG) : (g.comp f).FinitePresentation ",":=
  letI := f.toAlgebra
  letI := (g.comp f).toAlgebra
  letI : Algebra.FinitePresentation A B := hf
  Algebra.FinitePresentation.of_surjective
    (f :=
      { g with
        toFun := g
        commutes' := fun _ => rfl })
    hg hker"
Mathlib/LinearAlgebra/LinearPMap.lean,LinearPMap.smul_graph,smul_graph,59c36da5834220170716566e80c451914feb876f,":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  ¬∑ rw [mem_graph_iff] at h
    rcases h with ‚ü®y, hy, h‚ü©
    rw [LinearPMap.smul_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id.def,
      LinearMap.smul_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y
    simp [hy, h]
  rw [Submodule.mem_map] at h
  rcases h with ‚ü®x', hx', h‚ü©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id.def, LinearMap.smul_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx'‚ä¢
  rcases hx' with ‚ü®y, hy, hx'‚ü©
  use y
  rw [‚Üê h.1, ‚Üê h.2]
  simp [hy, hx']","warning:  LinearPMap does not have a doc string
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.532750 ‚Üí ?m.532750
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.536657 ‚Üí ?m.536657","theorem smul_graph (f : E ‚Üí‚Çó.[R] F) (z : M) :
    (z ‚Ä¢ f).graph =
      f.graph.map ((LinearMap.id : E ‚Üí‚Çó[R] E).prodMap (z ‚Ä¢ (LinearMap.id : F ‚Üí‚Çó[R] F))) ",":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  ¬∑ rw [mem_graph_iff] at h
    rcases h with ‚ü®y, hy, h‚ü©
    rw [LinearPMap.smul_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id,
      LinearMap.smul_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y, hy
  rw [Submodule.mem_map] at h
  rcases h with ‚ü®x', hx', h‚ü©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id, LinearMap.smul_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' ‚ä¢
  rcases hx' with ‚ü®y, hy, hx'‚ü©
  use y
  rw [‚Üê h.1, ‚Üê h.2]
  simp [hy, hx']"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a
  exact ‚ü®_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b
  exact ‚ü®_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine' ‚ü®g + dg, fun y => _, funext hgf‚ü©
    ¬∑ have hay : a < (g + dg) y := by
        rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
        ¬∑ refine' (lt_add_iff_pos_right _).2 _
          calc
            0 < c - g y := sub_pos.2 hac
            _ = dg y := (dga rfl).symm
        ¬∑ exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      refine ‚ü®x, hxy.le, ?_‚ü©
      rcases le_total c (g y) with hc | hc
      ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
      ¬∑ calc
          g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
          _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine' disjoint_union_left.2 ‚ü®_, Disjoint.preimage _ _‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine' ‚ü®g - dg, fun y => _, funext hgf‚ü©
  ¬∑ have hyb : (g - dg) y < b := by
      rcases (hgb y).eq_or_lt with (rfl | hlt)
      ¬∑ refine' (sub_lt_self_iff _).2 _
        calc
          0 < g y - c := sub_pos.2 hcb
          _ = dg y := (dgb rfl).symm
      ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
    rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
    cases' lt_or_le c (g y) with hc hc
    ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
      ¬∑ refine' ‚ü®x, xu, _, hyxu.le‚ü©
        calc
          f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
      ¬∑ have hay : a < (g - dg) y := by
          calc
            a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
            _ < g y - (b - c) := sub_lt_sub_right hc _
            _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
        rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
        exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
    ¬∑ refine' ‚ü®xl y, xu, _, hyxu.le‚ü©
      simp [dg0 (Or.inr hc), hxl]","error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X ‚Üí·µá ‚Ñù)
    {e : X ‚Üí Y} (he : ClosedEmbedding e) :
    ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x‚ÇÅ x‚ÇÇ, g y ‚àà Icc (f x‚ÇÅ) (f x‚ÇÇ)) ‚àß g ‚àò e = f ",":= by
  inhabit X
  obtain ‚ü®a, ha‚ü© : ‚àÉ a, IsGLB (range f) a := ‚ü®_, isGLB_ciInf f.isBounded_range.bddBelow‚ü©
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, IsLUB (range f) b := ‚ü®_, isLUB_ciSup f.isBounded_range.bddAbove‚ü©
  have hmem : ‚àÄ x, f x ‚àà Icc a b := fun x => ‚ü®ha.1 ‚ü®x, rfl‚ü©, hb.1 ‚ü®x, rfl‚ü©‚ü©
  have hle : a ‚â§ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  ¬∑ have : ‚àÄ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain ‚ü®g, hg_mem, hgf‚ü© : ‚àÉ g : Y ‚Üí·µá ‚Ñù, (‚àÄ y, ‚àÉ x, g y ‚àà Icc (f x) b) ‚àß g ‚àò e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with ‚ü®g, hg_mem, hgf‚ü©
    rcases em (‚àÉ x, f x = a) with (‚ü®x, rfl‚ü© | ha')
    ¬∑ exact ‚ü®g, fun y => ‚ü®x, hg_mem _‚ü©, hgf‚ü©
    have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Ici c) (g ‚Åª¬π' {a}) := by
      refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
      ¬∑ rw [Set.disjoint_left]
        rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = a)
        exact ha' ‚ü®x, (congr_fun hgf x).symm‚ü©
      ¬∑ exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      ‚ü®dg, dg0, dga, dgmem‚ü©
    replace hgf : ‚àÄ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
    refine ‚ü®g + dg, fun y => ?_, funext hgf‚ü©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      ¬∑ refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      ¬∑ exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
    refine ‚ü®x, hxy.le, ?_‚ü©
    rcases le_total c (g y) with hc | hc
    ¬∑ simp [dg0 (Or.inr hc), (hg_mem y).2]
    ¬∑ calc
        g y + dg y ‚â§ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (‚àÉ x, f x = b) with (‚ü®x, rfl‚ü© | hb')
  ¬∑ exact ‚ü®g, fun y => ‚ü®xl y, x, hxl y, hgb y‚ü©, hgf‚ü©
  have hd : Disjoint (range e ‚à™ g ‚Åª¬π' Iic c) (g ‚Åª¬π' {b}) := by
    refine disjoint_union_left.2 ‚ü®?_, Disjoint.preimage _ ?_‚ü©
    ¬∑ rw [Set.disjoint_left]
      rintro _ ‚ü®x, rfl‚ü© (rfl : g (e x) = b)
      exact hb' ‚ü®x, (congr_fun hgf x).symm‚ü©
    ¬∑ exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    ‚ü®dg, dg0, dgb, dgmem‚ü©
  replace hgf : ‚àÄ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), ‚Üê hgf]
  refine ‚ü®g - dg, fun y => ?_, funext hgf‚ü©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    ¬∑ refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    ¬∑ exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with ‚ü®_, ‚ü®xu, rfl‚ü©, hyxu, _‚ü©
  cases' lt_or_le c (g y) with hc hc
  ¬∑ rcases em (a ‚àà range f) with (‚ü®x, rfl‚ü© | _)
    ¬∑ refine ‚ü®x, xu, ?_, hyxu.le‚ü©
      calc
        f x = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
        _ ‚â§ g y - dg y := sub_le_sub hc.le (dgmem _).2
    ¬∑ have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [‚Üê hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ ‚â§ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with ‚ü®_, ‚ü®x, rfl‚ü©, _, hxy‚ü©
      exact ‚ü®x, xu, hxy.le, hyxu.le‚ü©
  ¬∑ refine ‚ü®xl y, xu, ?_, hyxu.le‚ü©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/GroupTheory/SpecificGroups/Cyclic.lean,isCyclic_of_card_pow_eq_one_le,isCyclic_of_card_pow_eq_one_le,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  have : (univ.filter fun a : Œ± => orderOf a = Fintype.card Œ±).Nonempty :=
    card_pos.1 <| by
      rw [card_orderOf_eq_totient_aux‚ÇÇ hn dvd_rfl];
        exact totient_pos (Fintype.card_pos_iff.2 ‚ü®1‚ü©)
  let ‚ü®x, hx‚ü© := this
  isCyclic_of_orderOf_eq_card x (Finset.mem_filter.1 hx).2","error:  function expected at
  totient_pos
term has type
  0 < œÜ ?m.90864 ‚Üî 0 < ?m.90864",theorem isCyclic_of_card_pow_eq_one_le : IsCyclic Œ± ,":=
  have : (univ.filter fun a : Œ± => orderOf a = Fintype.card Œ±).Nonempty :=
    card_pos.1 <| by
      rw [card_orderOf_eq_totient_aux‚ÇÇ hn dvd_rfl, totient_pos]
      apply Fintype.card_pos
  let ‚ü®x, hx‚ü© := this
  isCyclic_of_orderOf_eq_card x (Finset.mem_filter.1 hx).2"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.card_compression,card_compression,5ea60ae0ce479298732e0863bb5b578716c83e1f,":= by
  rw [compression, card_disjoint_union (compress_disjoint _ _), image_filter, card_image_of_injOn,
    ‚Üê card_disjoint_union]
  simp_rw [Function.comp]
  rw [filter_union_filter_neg_eq]
  ¬∑ rw [disjoint_iff_inter_eq_empty]
    exact filter_inter_filter_neg_eq _ _ _
  intro a ha b hb hab
  rw [mem_coe, mem_filter, Function.comp_apply] at ha hb
  rw [compress] at ha hab
  split_ifs at ha hab with has
  ¬∑ rw [compress] at hb hab
    split_ifs at hb hab with hbs
    ¬∑ exact sup_sdiff_injOn u v has hbs hab
    ¬∑ exact (hb.2 hb.1).elim
  ¬∑ exact (ha.2 ha.1).elim","warning:  @UV.compression does not have a doc string
warning:  `Finset.card_disjoint_union` has been deprecated, use `Finset.card_union_of_disjoint` instead
error:  application type mismatch
  card_disjoint_union (compress_disjoint ?m.54484 ?m.54485)
argument
  compress_disjoint ?m.54484 ?m.54485
has type
  ?m.54483 ‚â§ ‚ä• : Prop
but is expected to have type
  Disjoint ?m.54471 ?m.54472 : Prop
warning:  `Finset.image_filter` has been deprecated, use `Finset.filter_image` instead
warning:  `Finset.card_disjoint_union` has been deprecated, use `Finset.card_union_of_disjoint` instead
error:  simp made no progress",theorem card_compression (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card ,":= by
  rw [compression, card_union_of_disjoint compress_disjoint, filter_image,
    card_image_of_injOn compress_injOn, ‚Üê card_union_of_disjoint (disjoint_filter_filter_neg s _ _),
    filter_union_filter_neg_eq]"
Mathlib/Topology/NoetherianSpace.lean,TopologicalSpace.NoetherianSpace.exists_finite_set_isClosed_irreducible,NoetherianSpace.exists_finite_set_isClosed_irreducible,a415df24c51b406da69ab57361635401beec47d5,":= by
  lift s to Closeds Œ± using hs
  rcases NoetherianSpace.exists_finite_set_closeds_irreducible s with ‚ü®S, hSf, hS, rfl‚ü©
  refine ‚ü®(‚Üë) '' S, hSf.image _, Set.ball_image_iff.2 fun S _ => S.2, Set.ball_image_iff.2 hS, ?_‚ü©
  lift S to Finset (Closeds Œ±) using hSf
  simp [‚Üê Finset.sup_id_eq_sup‚Çõ, Closeds.coe_finset_sup]","warning:  `Set.ball_image_iff` has been deprecated, use `Set.forall_mem_image` instead
warning:  `Set.ball_image_iff` has been deprecated, use `Set.forall_mem_image` instead
error:  unknown constant 'Finset.sup_id_eq_sup‚Çõ'
error:  unsolved goals
case intro.intro.intro.intro.intro
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬≤ : TopologicalSpace Œ±
inst‚úù¬π : TopologicalSpace Œ≤
inst‚úù : NoetherianSpace Œ±
S : Finset (Closeds Œ±)
hS : ‚àÄ t ‚àà ‚ÜëS, IsIrreducible ‚Üët
‚ä¢ ‚ãÉ i ‚àà S, closure ‚Üëi = ‚ãÉ x ‚àà S, ‚Üëx","theorem NoetherianSpace.exists_finite_set_isClosed_irreducible [NoetherianSpace Œ±]
    {s : Set Œ±} (hs : IsClosed s) : ‚àÉ S : Set (Set Œ±), S.Finite ‚àß
      (‚àÄ t ‚àà S, IsClosed t) ‚àß (‚àÄ t ‚àà S, IsIrreducible t) ‚àß s = ‚ãÉ‚ÇÄ S ",":= by
  lift s to Closeds Œ± using hs
  rcases NoetherianSpace.exists_finite_set_closeds_irreducible s with ‚ü®S, hSf, hS, rfl‚ü©
  refine ‚ü®(‚Üë) '' S, hSf.image _, Set.forall_mem_image.2 fun S _ ‚Ü¶ S.2, Set.forall_mem_image.2 hS,
    ?_‚ü©
  lift S to Finset (Closeds Œ±) using hSf
  simp [‚Üê Finset.sup_id_eq_sSup, Closeds.coe_finset_sup]"
Mathlib/Geometry/Manifold/Instances/Sphere.lean,mfderiv_coe_sphere_injective,mfderiv_coe_sphere_injective,fc32fb1ee620bd1caec81914893aac3174a010c9,":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ùïú := ‚Ñù) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices : Injective (fderiv ‚Ñù ((stereoInvFunAux (-v : E) ‚àò (‚Üë)) ‚àò U.symm) 0)
  ¬∑ convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddEquivClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have :
    HasFDerivAt (stereoInvFunAux (-v : E) ‚àò (Subtype.val : (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ ‚Üí E))
      (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg FunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective",error:  unexpected token ':'; expected term,"theorem mfderiv_coe_sphere_injective {n : ‚Ñï} [Fact (finrank ‚Ñù E = n + 1)] (v : sphere (0 : E) 1) :
    Injective (mfderiv (ùì° n) ùìò(‚Ñù, E) ((‚Üë) : sphere (0 : E) 1 ‚Üí E) v) ",":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ùïú := ‚Ñù) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices Injective (fderiv ‚Ñù ((stereoInvFunAux (-v : E) ‚àò (‚Üë)) ‚àò U.symm) 0) by
    convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddEquivClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have : HasFDerivAt (stereoInvFunAux (-v : E) ‚àò (Subtype.val : (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ ‚Üí E))
      (‚Ñù ‚àô (‚Üë(-v) : E))·óÆ.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective"
Mathlib/LinearAlgebra/Basis.lean,Basis.maximal,maximal,ad243405451d6a694e2b1f0a33e88f2674d66a12,":= fun w hi h => by
  apply le_antisymm h
  intro x p
  by_contra q
  have e := b.total_repr x
  let u : Œπ ‚Ü™ w :=
    ‚ü®fun i => ‚ü®b i, h ‚ü®i, rfl‚ü©‚ü©, fun i i' r =>
      b.injective (by simpa only [Subtype.mk_eq_mk] using r)‚ü©
  simp_rw [Finsupp.total_apply] at e
  change ((b.repr x).sum fun (i : Œπ) (a : R) ‚Ü¶ a ‚Ä¢ (u i : M)) = ((‚ü®x, p‚ü© : w) : M) at e
  rw [‚Üê Finsupp.sum_embDomain (f := u) (g := fun x r ‚Ü¶ r ‚Ä¢ (x : M)), ‚Üê Finsupp.total_apply] at e
  refine' hi.total_ne_of_not_mem_support _ _ e
  simp only [Finset.mem_map, Finsupp.support_embDomain]
  rintro ‚ü®j, -, W‚ü©
  simp only [Embedding.coeFn_mk, Subtype.mk_eq_mk] at W
  apply q ‚ü®j, W‚ü©",error:  simp made no progress,theorem maximal [Nontrivial R] (b : Basis Œπ R M) : b.linearIndependent.Maximal ,":= fun w hi h => by
  apply le_antisymm h
  intro x p
  by_contra q
  have e := b.total_repr x
  let u : Œπ ‚Ü™ w :=
    ‚ü®fun i => ‚ü®b i, h ‚ü®i, rfl‚ü©‚ü©, fun i i' r =>
      b.injective (by simpa only [Subtype.mk_eq_mk] using r)‚ü©
  simp_rw [Finsupp.total_apply] at e
  change ((b.repr x).sum fun (i : Œπ) (a : R) ‚Ü¶ a ‚Ä¢ (u i : M)) = ((‚ü®x, p‚ü© : w) : M) at e
  rw [‚Üê Finsupp.sum_embDomain (f := u) (g := fun x r ‚Ü¶ r ‚Ä¢ (x : M)), ‚Üê Finsupp.total_apply] at e
  refine hi.total_ne_of_not_mem_support _ ?_ e
  simp only [Finset.mem_map, Finsupp.support_embDomain]
  rintro ‚ü®j, -, W‚ü©
  simp only [u, Embedding.coeFn_mk, Subtype.mk_eq_mk] at W
  apply q ‚ü®j, W‚ü©"
Mathlib/MeasureTheory/Integral/FundThmCalculus.lean,intervalIntegral.sub_le_integral_of_hasDeriv_right_of_le,sub_le_integral_of_hasDeriv_right_of_le,193761250a9869327056b499a7f49d676ed5e3a9,":= by
  refine' le_of_forall_pos_le_add fun Œµ Œµpos => _
  rcases exists_lt_lowerSemicontinuous_integral_lt œÜ œÜint Œµpos with
    ‚ü®G', f_lt_G', G'cont, G'int, G'lt_top, hG'‚ü©
  set s := {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} ‚à© Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, ‚à´ u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [‚Üê uIcc_of_le hab] at G'int hcont ‚ä¢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [inter_comm]
    exact this.preimage_closed_of_closed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b ‚äÜ {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain ‚ü®y, g'_lt_y', y_lt_G'‚ü© : ‚àÉ y : ‚Ñù, (g' t : EReal) < y ‚àß (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hœÜg t ht.2)).trans_lt (f_lt_G' t))
    have I1 : ‚àÄ·∂† u in ùìù[>] t, (u - t) * y ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      have B : ‚àÄ·∂† u in ùìù t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with ‚ü®m, M, ‚ü®hm, hM‚ü©, H‚ü©
      have : Ioo t (min M b) ‚àà ùìù[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u ‚äÜ Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = ‚à´ _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ ‚â§ ‚à´ w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, ‚Üê integral_Icc_eq_integral_Ioc]
          apply set_integral_mono_ae_restrict
          ¬∑ simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          ¬∑ exact IntegrableOn.mono_set G'int I
          ¬∑ have C1 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), G' x < ‚àû :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), x ‚àà Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x ‚àà Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t ‚ü®ht.2.1, ht.2.2‚ü©).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [‚Üê smul_eq_mul, sub_smul_slope] at this
    have I3 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : ‚àÄ·∂† u in ùìù[>] t, u ‚àà Ioc t (min v b) := by
      refine' mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 ‚ü®min v b, _, Subset.rfl‚ü©
      simp only [lt_min_iff, mem_Ioi]
      exact ‚ü®t_lt_v, ht.2.2‚ü©
    rcases(I3.and I4).exists with ‚ü®x, hx, h'x‚ü©
    refine' ‚ü®x, _, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x‚ü©
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ ‚â§ (‚à´ w in a..t, (G' w).toReal) + ‚à´ w in t..x, (G' w).toReal := (add_le_add ht.1 hx)
      _ = ‚à´ w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        ¬∑ rw [intervalIntegrable_iff_integrable_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        ¬∑ rw [intervalIntegrable_iff_integrable_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a ‚â§ ‚à´ y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ ‚â§ (‚à´ y in a..b, œÜ y) + Œµ := by
      convert hG'.le <;>
        ¬∑ rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]","error:  simp made no progress
warning:  `MeasureTheory.set_integral_mono_ae_restrict` has been deprecated, use `MeasureTheory.setIntegral_mono_ae_restrict` instead
error:  unknown identifier 'intervalIntegrable_iff_integrable_Ioc_of_le'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.311191
case hab
Œπ : Type u_1
ùïú : Type u_2
E : Type u_3
F : Type u_4
A : Type u_5
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚Ñù E
f : ‚Ñù ‚Üí E
g' g œÜ : ‚Ñù ‚Üí ‚Ñù
a b : ‚Ñù
hab : a ‚â§ b
hcont : ContinuousOn g (Icc a b)
hderiv : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x
œÜint : IntegrableOn œÜ (Icc a b) volume
hœÜg : ‚àÄ x ‚àà Ico a b, g' x ‚â§ œÜ x
Œµ : ‚Ñù
Œµpos : 0 < Œµ
G' : ‚Ñù ‚Üí EReal
f_lt_G' : ‚àÄ (x : ‚Ñù), ‚Üë(œÜ x) < G' x
G'cont : LowerSemicontinuous G'
G'int : Integrable (fun x ‚Ü¶ (G' x).toReal) (volume.restrict (Icc a b))
G'lt_top : ‚àÄ·µê (x : ‚Ñù) ‚àÇvolume.restrict (Icc a b), G' x < ‚ä§
hG' : ‚à´ (x : ‚Ñù) in Icc a b, (G' x).toReal ‚àÇvolume < ‚à´ (x : ‚Ñù) in Icc a b, œÜ x ‚àÇvolume + Œµ
s : Set ‚Ñù := {t | g t - g a ‚â§ ‚à´ (u : ‚Ñù) in a..t, (G' u).toReal} ‚à© Icc a b
s_closed : IsClosed s
t : ‚Ñù
ht : t ‚àà {t | g t - g a ‚â§ ‚à´ (u : ‚Ñù) in a..t, (G' u).toReal} ‚à© Ico a b
v : ‚Ñù
t_lt_v : v ‚àà Ioi t
y : ‚Ñù
g'_lt_y' : ‚Üë(g' t) < ‚Üëy
y_lt_G' : ‚Üëy < G' t
I1 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, (u - t) * y ‚â§ ‚à´ (w : ‚Ñù) in t..u, (G' w).toReal
I2 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, g u - g t ‚â§ (u - t) * y
I3 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, g u - g t ‚â§ ‚à´ (w : ‚Ñù) in t..u, (G' w).toReal
I4 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, u ‚àà Ioc t (min v b)
x : ‚Ñù
hx : g x - g t ‚â§ ‚à´ (w : ‚Ñù) in t..x, (G' w).toReal
h'x : x ‚àà Ioc t (min v b)
‚ä¢ IntervalIntegrable (fun x ‚Ü¶ (G' x).toReal) volume a t
error:  unknown identifier 'intervalIntegrable_iff_integrable_Ioc_of_le'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.311193
case hbc
Œπ : Type u_1
ùïú : Type u_2
E : Type u_3
F : Type u_4
A : Type u_5
inst‚úù¬π : NormedAddCommGroup E
inst‚úù : NormedSpace ‚Ñù E
f : ‚Ñù ‚Üí E
g' g œÜ : ‚Ñù ‚Üí ‚Ñù
a b : ‚Ñù
hab : a ‚â§ b
hcont : ContinuousOn g (Icc a b)
hderiv : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x
œÜint : IntegrableOn œÜ (Icc a b) volume
hœÜg : ‚àÄ x ‚àà Ico a b, g' x ‚â§ œÜ x
Œµ : ‚Ñù
Œµpos : 0 < Œµ
G' : ‚Ñù ‚Üí EReal
f_lt_G' : ‚àÄ (x : ‚Ñù), ‚Üë(œÜ x) < G' x
G'cont : LowerSemicontinuous G'
G'int : Integrable (fun x ‚Ü¶ (G' x).toReal) (volume.restrict (Icc a b))
G'lt_top : ‚àÄ·µê (x : ‚Ñù) ‚àÇvolume.restrict (Icc a b), G' x < ‚ä§
hG' : ‚à´ (x : ‚Ñù) in Icc a b, (G' x).toReal ‚àÇvolume < ‚à´ (x : ‚Ñù) in Icc a b, œÜ x ‚àÇvolume + Œµ
s : Set ‚Ñù := {t | g t - g a ‚â§ ‚à´ (u : ‚Ñù) in a..t, (G' u).toReal} ‚à© Icc a b
s_closed : IsClosed s
t : ‚Ñù
ht : t ‚àà {t | g t - g a ‚â§ ‚à´ (u : ‚Ñù) in a..t, (G' u).toReal} ‚à© Ico a b
v : ‚Ñù
t_lt_v : v ‚àà Ioi t
y : ‚Ñù
g'_lt_y' : ‚Üë(g' t) < ‚Üëy
y_lt_G' : ‚Üëy < G' t
I1 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, (u - t) * y ‚â§ ‚à´ (w : ‚Ñù) in t..u, (G' w).toReal
I2 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, g u - g t ‚â§ (u - t) * y
I3 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, g u - g t ‚â§ ‚à´ (w : ‚Ñù) in t..u, (G' w).toReal
I4 : ‚àÄ·∂† (u : ‚Ñù) in ùìù[>] t, u ‚àà Ioc t (min v b)
x : ‚Ñù
hx : g x - g t ‚â§ ‚à´ (w : ‚Ñù) in t..x, (G' w).toReal
h'x : x ‚àà Ioc t (min v b)
‚ä¢ IntervalIntegrable (fun x ‚Ü¶ (G' x).toReal) volume t x","theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a ‚â§ b)
    (hcont : ContinuousOn g (Icc a b)) (hderiv : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)
    (œÜint : IntegrableOn œÜ (Icc a b)) (hœÜg : ‚àÄ x ‚àà Ico a b, g' x ‚â§ œÜ x) :
    g b - g a ‚â§ ‚à´ y in a..b, œÜ y ",":= by
  refine le_of_forall_pos_le_add fun Œµ Œµpos => ?_
  rcases exists_lt_lowerSemicontinuous_integral_lt œÜ œÜint Œµpos with
    ‚ü®G', f_lt_G', G'cont, G'int, G'lt_top, hG'‚ü©
  set s := {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} ‚à© Icc a b
  have s_closed : IsClosed s := by
    have : ContinuousOn (fun t => (g t - g a, ‚à´ u in a..t, (G' u).toReal)) (Icc a b) := by
      rw [‚Üê uIcc_of_le hab] at G'int hcont ‚ä¢
      exact (hcont.sub continuousOn_const).prod (continuousOn_primitive_interval G'int)
    simp only [s, inter_comm]
    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'
  have main : Icc a b ‚äÜ {t | g t - g a ‚â§ ‚à´ u in a..t, (G' u).toReal} := by
    refine s_closed.Icc_subset_of_forall_exists_gt
      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_
    obtain ‚ü®y, g'_lt_y', y_lt_G'‚ü© : ‚àÉ y : ‚Ñù, (g' t : EReal) < y ‚àß (y : EReal) < G' t :=
      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (hœÜg t ht.2)).trans_lt (f_lt_G' t))
    have I1 : ‚àÄ·∂† u in ùìù[>] t, (u - t) * y ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      have B : ‚àÄ·∂† u in ùìù t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'
      rcases mem_nhds_iff_exists_Ioo_subset.1 B with ‚ü®m, M, ‚ü®hm, hM‚ü©, H‚ü©
      have : Ioo t (min M b) ‚àà ùìù[>] t := Ioo_mem_nhdsWithin_Ioi' (lt_min hM ht.right.right)
      filter_upwards [this] with u hu
      have I : Icc t u ‚äÜ Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))
      calc
        (u - t) * y = ‚à´ _ in Icc t u, y := by
          simp only [hu.left.le, MeasureTheory.integral_const, Algebra.id.smul_eq_mul, sub_nonneg,
            MeasurableSet.univ, Real.volume_Icc, Measure.restrict_apply, univ_inter,
            ENNReal.toReal_ofReal]
        _ ‚â§ ‚à´ w in t..u, (G' w).toReal := by
          rw [intervalIntegral.integral_of_le hu.1.le, ‚Üê integral_Icc_eq_integral_Ioc]
          apply setIntegral_mono_ae_restrict
          ¬∑ simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true_iff]
          ¬∑ exact IntegrableOn.mono_set G'int I
          ¬∑ have C1 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), G' x < ‚àû :=
              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top
            have C2 : ‚àÄ·µê x : ‚Ñù ‚àÇvolume.restrict (Icc t u), x ‚àà Icc t u :=
              ae_restrict_mem measurableSet_Icc
            filter_upwards [C1, C2] with x G'x hx
            apply EReal.coe_le_coe_iff.1
            have : x ‚àà Ioo m M := by
              simp only [hm.trans_le hx.left,
                (hx.right.trans_lt hu.right).trans_le (min_le_left M b), mem_Ioo, and_self_iff]
            refine (H this).out.le.trans_eq ?_
            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm
    have I2 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ (u - t) * y := by
      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'
      filter_upwards [(hderiv t ‚ü®ht.2.1, ht.2.2‚ü©).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,
        self_mem_nhdsWithin] with u hu t_lt_u
      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le
      rwa [‚Üê smul_eq_mul, sub_smul_slope] at this
    have I3 : ‚àÄ·∂† u in ùìù[>] t, g u - g t ‚â§ ‚à´ w in t..u, (G' w).toReal := by
      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1
    have I4 : ‚àÄ·∂† u in ùìù[>] t, u ‚àà Ioc t (min v b) := by
      refine mem_nhdsWithin_Ioi_iff_exists_Ioc_subset.2 ‚ü®min v b, ?_, Subset.rfl‚ü©
      simp only [lt_min_iff, mem_Ioi]
      exact ‚ü®t_lt_v, ht.2.2‚ü©
    rcases (I3.and I4).exists with ‚ü®x, hx, h'x‚ü©
    refine ‚ü®x, ?_, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x‚ü©
    calc
      g x - g a = g t - g a + (g x - g t) := by abel
      _ ‚â§ (‚à´ w in a..t, (G' w).toReal) + ‚à´ w in t..x, (G' w).toReal := add_le_add ht.1 hx
      _ = ‚à´ w in a..x, (G' w).toReal := by
        apply integral_add_adjacent_intervals
        ¬∑ rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]
          exact IntegrableOn.mono_set G'int
            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))
        ¬∑ rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]
          apply IntegrableOn.mono_set G'int
          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))
  calc
    g b - g a ‚â§ ‚à´ y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)
    _ ‚â§ (‚à´ y in a..b, œÜ y) + Œµ := by
      convert hG'.le <;>
        ¬∑ rw [intervalIntegral.integral_of_le hab]
          simp only [integral_Icc_eq_integral_Ioc', Real.volume_singleton]"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.join_nil,join_nil,938069ac7c83a4980c46ca108d9947ab788c12ee,":=
  Seq'.join_nil",error:  unknown identifier 'Seq'.join_nil',theorem join_nil : join nil = (nil : WSeq Œ±) ,":=
  Seq.join_nil"
Mathlib/MeasureTheory/Function/Jacobian.lean,ApproximatesLinearOn.norm_fderiv_sub_le,_root_.ApproximatesLinearOn.norm_fderiv_sub_le,60e2ebb714fa61b2422f9c1cd4cff5fd09169c21,":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ
  ¬∑ have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by continuity) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel'_right]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := (norm_add_le _ _)
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel', sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := (norm_sub_le _ _)
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel', norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
        mul_le_mul_of_nonneg_left norm_a (mul_nonneg rpos.le (add_nonneg Œ¥.2 Œµpos.le))
  calc
    ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
      congr 1
      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
      abel
    _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := (norm_add_le _ _)
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
      apply add_le_add
      ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
      ¬∑ apply ContinuousLinearMap.le_opNorm
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ :=
      add_le_add le_rfl
        (mul_le_mul_of_nonneg_left (mem_closedBall_iff_norm'.1 az) (norm_nonneg _))",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem _root_.ApproximatesLinearOn.norm_fderiv_sub_le {A : E ‚ÜíL[‚Ñù] E} {Œ¥ : ‚Ñù‚â•0}
    (hf : ApproximatesLinearOn f A s Œ¥) (hs : MeasurableSet s) (f' : E ‚Üí E ‚ÜíL[‚Ñù] E)
    (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) : ‚àÄ·µê x ‚àÇŒº.restrict s, ‚Äñf' x - A‚Äñ‚Çä ‚â§ Œ¥ ",":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ by
    have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by fun_prop) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel_left, sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := norm_sub_le _ _
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel_left, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) := by gcongr
  calc
    ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
      congr 1
      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
      abel
    _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
      apply add_le_add
      ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
      ¬∑ apply ContinuousLinearMap.le_opNorm
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ := by
      rw [mem_closedBall_iff_norm'] at az
      gcongr"
Mathlib/Analysis/Calculus/MeanValue.lean,eq_of_derivWithin_eq,eq_of_derivWithin_eq,9e34a191034458a56331f976ff7400a26407c888,":= by
  have A : ‚àÄ y ‚àà Ico a b, HasDerivWithinAt f (derivWithin f (Icc a b) y) (Ici y) y := fun y hy =>
    (fdiff y (mem_Icc_of_Ico hy)).hasDerivWithinAt.nhdsWithin (Icc_mem_nhdsWithin_Ici hy)
  have B : ‚àÄ y ‚àà Ico a b, HasDerivWithinAt g (derivWithin g (Icc a b) y) (Ici y) y := fun y hy =>
    (gdiff y (mem_Icc_of_Ico hy)).hasDerivWithinAt.nhdsWithin (Icc_mem_nhdsWithin_Ici hy)
  exact
    eq_of_has_deriv_right_eq A (fun y hy => (hderiv hy).symm ‚ñ∏ B y hy) fdiff.continuousOn
      gdiff.continuousOn hi","error:  invalid field 'nhdsWithin', the environment does not contain 'HasDerivWithinAt.nhdsWithin'
  DifferentiableWithinAt.hasDerivWithinAt (fdiff y (mem_Icc_of_Ico hy))
has type
  HasDerivWithinAt f (derivWithin f (Icc a b) y) (Icc a b) y
error:  invalid field 'nhdsWithin', the environment does not contain 'HasDerivAtFilter.nhdsWithin'
  DifferentiableWithinAt.hasDerivWithinAt (fdiff y (mem_Icc_of_Ico hy))
has type
  HasDerivAtFilter f (derivWithin f (Icc a b) y) y (ùìù[Icc a b] y)
error:  invalid field 'nhdsWithin', the environment does not contain 'HasFDerivAtFilter.nhdsWithin'
  DifferentiableWithinAt.hasDerivWithinAt (fdiff y (mem_Icc_of_Ico hy))
has type
  HasFDerivAtFilter f (smulRight 1 (derivWithin f (Icc a b) y)) y (ùìù[Icc a b] y)
error:  invalid field 'nhdsWithin', the environment does not contain 'HasDerivWithinAt.nhdsWithin'
  DifferentiableWithinAt.hasDerivWithinAt (gdiff y (mem_Icc_of_Ico hy))
has type
  HasDerivWithinAt g (derivWithin g (Icc a b) y) (Icc a b) y
error:  invalid field 'nhdsWithin', the environment does not contain 'HasDerivAtFilter.nhdsWithin'
  DifferentiableWithinAt.hasDerivWithinAt (gdiff y (mem_Icc_of_Ico hy))
has type
  HasDerivAtFilter g (derivWithin g (Icc a b) y) y (ùìù[Icc a b] y)
error:  invalid field 'nhdsWithin', the environment does not contain 'HasFDerivAtFilter.nhdsWithin'
  DifferentiableWithinAt.hasDerivWithinAt (gdiff y (mem_Icc_of_Ico hy))
has type
  HasFDerivAtFilter g (smulRight 1 (derivWithin g (Icc a b) y)) y (ùìù[Icc a b] y)","theorem eq_of_derivWithin_eq (fdiff : DifferentiableOn ‚Ñù f (Icc a b))
    (gdiff : DifferentiableOn ‚Ñù g (Icc a b))
    (hderiv : EqOn (derivWithin f (Icc a b)) (derivWithin g (Icc a b)) (Ico a b)) (hi : f a = g a) :
    ‚àÄ y ‚àà Icc a b, f y = g y ",":= by
  have A : ‚àÄ y ‚àà Ico a b, HasDerivWithinAt f (derivWithin f (Icc a b) y) (Ici y) y := fun y hy =>
    (fdiff y (mem_Icc_of_Ico hy)).hasDerivWithinAt.mono_of_mem (Icc_mem_nhdsWithin_Ici hy)
  have B : ‚àÄ y ‚àà Ico a b, HasDerivWithinAt g (derivWithin g (Icc a b) y) (Ici y) y := fun y hy =>
    (gdiff y (mem_Icc_of_Ico hy)).hasDerivWithinAt.mono_of_mem (Icc_mem_nhdsWithin_Ici hy)
  exact
    eq_of_has_deriv_right_eq A (fun y hy => (hderiv hy).symm ‚ñ∏ B y hy) fdiff.continuousOn
      gdiff.continuousOn hi"
Mathlib/Data/QPF/Multivariate/Constructions/Cofix.lean,MvQPF.Cofix.bisim_rel,Cofix.bisim_rel,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  let r' (x y) := x = y ‚à® r x y
  intro x y rxy
  apply Cofix.bisim_aux r'
  ¬∑ intro x
    left
    rfl
  ¬∑ intro x y r'xy
    cases r'xy with
    | inl h =>
      rw [h]
    | inr r'xy =>
      have : ‚àÄ x y, r x y ‚Üí r' x y := fun x y h => Or.inr h
      rw [‚Üê Quot.factor_mk_eq _ _ this]
      dsimp
      rw [appendFun_comp_id]
      rw [@comp_map _ _ _ q _ _ _ (appendFun id (Quot.mk r)),
        @comp_map _ _ _ q _ _ _ (appendFun id (Quot.mk r))]
      rw [h _ _ r'xy]
  right; exact rxy",error:  dsimp made no progress,"theorem Cofix.bisim_rel {Œ± : TypeVec n} (r : Cofix F Œ± ‚Üí Cofix F Œ± ‚Üí Prop)
    (h : ‚àÄ x y, r x y ‚Üí
      appendFun id (Quot.mk r) <$$> Cofix.dest x = appendFun id (Quot.mk r) <$$> Cofix.dest y) :
    ‚àÄ x y, r x y ‚Üí x = y ",":= by
  let r' (x y) := x = y ‚à® r x y
  intro x y rxy
  apply Cofix.bisim_aux r'
  ¬∑ intro x
    left
    rfl
  ¬∑ intro x y r'xy
    cases r'xy with
    | inl h =>
      rw [h]
    | inr r'xy =>
      have : ‚àÄ x y, r x y ‚Üí r' x y := fun x y h => Or.inr h
      rw [‚Üê Quot.factor_mk_eq _ _ this]
      dsimp [r']
      rw [appendFun_comp_id]
      rw [@comp_map _ _ q _ _ _ (appendFun id (Quot.mk r)),
        @comp_map _ _ q _ _ _ (appendFun id (Quot.mk r))]
      rw [h _ _ r'xy]
  right; exact rxy"
Mathlib/Algebra/Module/PID.lean,Module.torsion_by_prime_power_decomposition,torsion_by_prime_power_decomposition,554c20d1eb6d2f1f6a5b53ccd3a727a93147a4de,":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ simp only [Nat.zero_eq] at *
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
    clear IH
    ¬∑ have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine' ‚ü®x, h0, _‚ü©; rw [h1]
        simp only [LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'","error:  simp made no progress
error:  simp made no progress
error:  simp made no progress","theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))
    [h' : Module.Finite R N] :
    ‚àÉ (d : ‚Ñï) (k : Fin d ‚Üí ‚Ñï), Nonempty <| N ‚âÉ‚Çó[R] ‚®Å i : Fin d, R ‚ß∏ R ‚àô p ^ (k i : ‚Ñï) ",":= by
  obtain ‚ü®d, s, hs‚ü© := @Module.Finite.exists_fin _ _ _ _ _ h'; use d; clear h'
  induction' d with d IH generalizing N
  ¬∑ 
    use finZeroElim
    rw [Set.range_eq_empty, Submodule.span_empty] at hs
    haveI : Unique N :=
      ‚ü®‚ü®0‚ü©, fun x => by dsimp; rw [‚Üê Submodule.mem_bot R, hs]; exact Submodule.mem_top‚ü©
    haveI : IsEmpty (Fin Nat.zero) := inferInstanceAs (IsEmpty (Fin 0))
    exact ‚ü®0‚ü©
  ¬∑ have : ‚àÄ x : N, Decidable (x = 0) := fun _ => by classical infer_instance
    obtain ‚ü®j, hj‚ü© := exists_isTorsionBy hN d.succ d.succ_ne_zero s hs
    let s' : Fin d ‚Üí N ‚ß∏ R ‚àô s j := Submodule.Quotient.mk ‚àò s ‚àò j.succAbove
    have := IH ?_ s' ?_
    ¬∑ obtain ‚ü®k, ‚ü®f‚ü©‚ü© := this
      clear IH
      have : ‚àÄ i : Fin d,
          ‚àÉ x : N, p ^ k i ‚Ä¢ x = 0 ‚àß f (Submodule.Quotient.mk x) = DirectSum.lof R _ _ i 1 := by
        intro i
        let fi := f.symm.toLinearMap.comp (DirectSum.lof _ _ _ i)
        obtain ‚ü®x, h0, h1‚ü© := exists_smul_eq_zero_and_mk_eq hp hN hj fi; refine ‚ü®x, h0, ?_‚ü©; rw [h1]
        simp only [fi, LinearMap.coe_comp, f.symm.coe_toLinearMap, f.apply_symm_apply,
          Function.comp_apply]
      refine ‚ü®?_, ‚ü®?_‚ü©‚ü©
      ¬∑ exact fun a => (fun i => (Option.rec (pOrder hN (s j)) k i : ‚Ñï)) (finSuccEquiv d a)
      ¬∑ refine (((lequivProdOfRightSplitExact
          (g := (f.trans ULift.moduleEquiv.{u, u, v}.symm).toLinearMap.comp <| mkQ _)
          (f := (DirectSum.toModule _ _ _ fun i => (liftQSpanSingleton (p ^ k i)
              (LinearMap.toSpanSingleton _ _ _) (this i).choose_spec.left : R ‚ß∏ _ ‚Üí‚Çó[R] _)).comp
            ULift.moduleEquiv.toLinearMap) (R ‚àô s j).injective_subtype ?_ ?_).symm.trans
          (((quotTorsionOfEquivSpanSingleton R N (s j)).symm.trans
          (quotEquivOfEq (torsionOf R N (s j)) _
          (Ideal.torsionOf_eq_span_pow_pOrder hp hN (s j)))).prod
          (ULift.moduleEquiv))).trans
          (@DirectSum.lequivProdDirectSum R _ _ _
          (fun i => R ‚ß∏ R ‚àô p ^ @Option.rec _ (fun _ => ‚Ñï) (pOrder hN <| s j) k i) _ _).symm).trans
          (DirectSum.lequivCongrLeft R (finSuccEquiv d).symm)
        ¬∑ rw [range_subtype, LinearEquiv.ker_comp, ker_mkQ]
        ¬∑ rw [‚Üê f.comp_coe, LinearMap.comp_assoc, LinearMap.comp_assoc,
            LinearEquiv.toLinearMap_symm_comp_eq, LinearMap.comp_id, ‚Üê LinearMap.comp_assoc,
            ‚Üê LinearMap.comp_assoc]
          suffices (f.toLinearMap.comp (R ‚àô s j).mkQ).comp _ = LinearMap.id by
            rw [this, LinearMap.id_comp]
          ext i : 3
          simp only [LinearMap.coe_comp, Function.comp_apply, mkQ_apply]
          rw [LinearEquiv.coe_toLinearMap, LinearMap.id_apply, DirectSum.toModule_lof,
            liftQSpanSingleton_apply, LinearMap.toSpanSingleton_one, Ideal.Quotient.mk_eq_mk,
            map_one (Ideal.Quotient.mk _), (this i).choose_spec.right]
    ¬∑ exact (mk_surjective _).forall.mpr fun x =>
        ‚ü®(@hN x).choose, by rw [‚Üê Quotient.mk_smul, (@hN x).choose_spec, Quotient.mk_zero]‚ü©
    ¬∑ have hs' := congr_arg (Submodule.map <| mkQ <| R ‚àô s j) hs
      rw [Submodule.map_span, Submodule.map_top, range_mkQ] at hs'; simp only [mkQ_apply] at hs'
      simp only [s']; rw [‚Üê Function.comp.assoc, Set.range_comp (_ ‚àò s), Fin.range_succAbove]
      rw [‚Üê Set.range_comp, ‚Üê Set.insert_image_compl_eq_range _ j, Function.comp_apply,
        (Quotient.mk_eq_zero _).mpr (Submodule.mem_span_singleton_self _), span_insert_zero] at hs'
      exact hs'"
Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean,CategoryTheory.MorphismProperty.RightFraction.map_s_comp_map,map_s_comp_map,9072ff84a0d139a344bf9eed4a00c4cd27596c79,":= by
  have := hL _ œÜ.hs","error:  unsolved goals
C : Type u_1
D : Type u_2
inst‚úù¬π : Category.{u_3, u_1} C
inst‚úù : Category.{u_4, u_2} D
W : MorphismProperty C
X Y : C
œÜ : W.RightFraction X Y
L : C ‚•§ D
hL : W.IsInvertedBy L
this : IsIso (L.map œÜ.s)
‚ä¢ L.map œÜ.s ‚â´ œÜ.map L hL = L.map œÜ.f","lemma map_s_comp_map (œÜ : W.RightFraction X Y) (L : C ‚•§ D) (hL : W.IsInvertedBy L) :
    L.map œÜ.s ‚â´ œÜ.map L hL = L.map œÜ.f ",":= by
  letI := hL _ œÜ.hs
  simp [map]"
Mathlib/Data/Num/Lemmas.lean,Num.ofNat'_succ,ofNat'_succ,0c824fb54f74f0c66db893166b73e377be2feb6f,":=
  @(Nat.binaryRec (by simp [zero_add]) fun b n ih => by
    cases b
    ¬∑ erw [ofNat'_bit true n, ofNat'_bit]
      simp only [‚Üê bit1_of_bit1, ‚Üê bit0_of_bit0, cond, _root_.bit1]
    ¬∑ erw [show n.bit true + 1 = (n + 1).bit false by
        simpa [Nat.bit, _root_.bit1, _root_.bit0] using Nat.add_right_comm n n 1,
        ofNat'_bit, ofNat'_bit, ih]
      simp only [cond, add_one, bit1_succ])","warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  type mismatch
  h‚úù
has type
  n + 1 = 1 + n : Prop
but is expected to have type
  n + 2 = 1 + (n + 1) : Prop
warning:  `castNum` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated","theorem ofNat'_succ : ‚àÄ {n}, ofNat' (n + 1) = ofNat' n + 1 ",":=
  @(Nat.binaryRec (by simp [zero_add]) fun b n ih => by
    cases b
    ¬∑ erw [ofNat'_bit true n, ofNat'_bit]
      simp only [‚Üê bit1_of_bit1, ‚Üê bit0_of_bit0, cond, _root_.bit1]
    ¬∑ erw [show n.bit true + 1 = (n + 1).bit false by
        simpa [Nat.bit, _root_.bit1, _root_.bit0] using Nat.add_left_comm n 1 1,
        ofNat'_bit, ofNat'_bit, ih]
      simp only [cond, add_one, bit1_succ])"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine' ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, _‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, ‚ü®_, _, _‚ü©, _‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero, Nat.zero_eq,
          Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 ‚àà ?m.116759 ‚à™ ?m.116760
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120388 ‚Üí ?m.120388
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.123472 ‚Üí ?m.123472
error:  unsolved goals
case zero
Œ± : Type u_1
inst‚úù‚Åµ : MetricSpace Œ±
Œ≤ : Type u
inst‚úù‚Å¥ : SecondCountableTopology Œ±
inst‚úù¬≥ : MeasurableSpace Œ±
inst‚úù¬≤ : OpensMeasurableSpace Œ±
inst‚úù¬π : HasBesicovitchCovering Œ±
Œº : Measure Œ±
inst‚úù : IsFiniteMeasure Œº
f : Œ± ‚Üí Set ‚Ñù
s : Set Œ±
hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty
N : ‚Ñï
œÑ : ‚Ñù
hœÑ : 1 < œÑ
hN : IsEmpty (SatelliteConfig Œ± N œÑ)
P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop :=
  fun t ‚Ü¶ ((‚Üët).PairwiseDisjoint fun p ‚Ü¶ closedBall p.1 p.2) ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß ‚àÄ p ‚àà t, p.2 ‚àà f p.1
F : Finset (Œ± √ó ‚Ñù) ‚Üí Finset (Œ± √ó ‚Ñù)
hF :
  ‚àÄ (t : Finset (Œ± √ó ‚Ñù)),
    P t ‚Üí
      t ‚äÜ F t ‚àß P (F t) ‚àß Œº (s \ ‚ãÉ p ‚àà F t, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà t, closedBall p.1 p.2)
u : ‚Ñï ‚Üí Finset (Œ± √ó ‚Ñù) := fun n ‚Ü¶ F^[n] ‚àÖ
u_succ : ‚àÄ (n : ‚Ñï), u n.succ = F (u n)
Pu : ‚àÄ (n : ‚Ñï), P (u n)
A : ‚àÄ (n : ‚Ñï), Œº (s \ ‚ãÉ p ‚àà ‚ãÉ n, ‚Üë(u n), closedBall p.1 p.2) ‚â§ Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2)
‚ä¢ Œº (s \ ‚ãÉ p ‚àà u 0, closedBall p.1 p.2) ‚â§ Œº s
error:  type mismatch
  mul_le_mul_left' IH (‚ÜëN / (‚ÜëN + 1))
has type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ ‚ÜëN / (‚ÜëN + 1) * ((‚ÜëN / (‚ÜëN + 1)) ^ n * Œº s) : Prop
but is expected to have type
  ‚ÜëN / (‚ÜëN + 1) * Œº (s \ ‚ãÉ p ‚àà u n, closedBall p.1 p.2) ‚â§ (‚ÜëN / (‚ÜëN + 1)) ^ n * (‚ÜëN / (‚ÜëN + 1) * Œº s) : Prop
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133159 ‚Üí ?m.133159 ‚Üí Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133295 ‚Üí ?m.133295 ‚Üí Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Œº : Measure Œ±)
    [IsFiniteMeasure Œº] (f : Œ± ‚Üí Set ‚Ñù) (s : Set Œ±)
    (hf : ‚àÄ x ‚àà s, ‚àÄ Œ¥ > 0, (f x ‚à© Ioo 0 Œ¥).Nonempty) :
    ‚àÉ t : Set (Œ± √ó ‚Ñù), t.Countable ‚àß (‚àÄ p ‚àà t, p.1 ‚àà s) ‚àß (‚àÄ p ‚àà t, p.2 ‚àà f p.1) ‚àß
      Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) = 0 ‚àß
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Œ± := Œ±) with ‚ü®N, œÑ, hœÑ, hN‚ü©
  let P : Finset (Œ± √ó ‚Ñù) ‚Üí Prop := fun t =>
    ((t : Set (Œ± √ó ‚Ñù)).PairwiseDisjoint fun p => closedBall p.1 p.2) ‚àß
      (‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.1 ‚àà s) ‚àß ‚àÄ p : Œ± √ó ‚Ñù, p ‚àà t ‚Üí p.2 ‚àà f p.1
  have :
      ‚àÄ t : Finset (Œ± √ó ‚Ñù), P t ‚Üí ‚àÉ u : Finset (Œ± √ó ‚Ñù), t ‚äÜ u ‚àß P u ‚àß
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u), closedBall p.1 p.2) ‚â§
          N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2) := by
    intro t ht
    set B := ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : ‚àÄ x ‚àà s', ‚àÉ r ‚àà f x ‚à© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x ‚àà s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      ¬∑ rcases hf x xs 1 zero_lt_one with ‚ü®r, hr, h'r‚ü©
        exact ‚ü®r, ‚ü®hr, h'r‚ü©, by simp only [hB, empty_disjoint]‚ü©
      ¬∑ let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with ‚ü®r, hr, h'r‚ü©
        refine ‚ü®r, ‚ü®hr, ‚ü®h'r.1, h'r.2.trans_le (min_le_right _ _)‚ü©‚ü©, ?_‚ü©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain ‚ü®v, vs', hŒºv, hv‚ü© :
      ‚àÉ v : Finset Œ±,
        ‚Üëv ‚äÜ s' ‚àß
          Œº (s' \ ‚ãÉ x ‚àà v, closedBall x (r x)) ‚â§ N / (N + 1) * Œº s' ‚àß
            (v : Set Œ±).PairwiseDisjoint fun x : Œ± => closedBall x (r x) :=
      haveI rI : ‚àÄ x ‚àà s', r x ‚àà Ioo (0 : ‚Ñù) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Œº hœÑ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine ‚ü®t ‚à™ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ‚ü®?_, ?_, ?_‚ü©, ?_‚ü©
    ¬∑ simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with ‚ü®p', p'v, rfl‚ü©
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      ¬∑ intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with ‚ü®q', q'v, rfl‚ü©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, ‚Üê Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Œ± √ó ‚Ñù => closedBall x.1 x.2) hp
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.1 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    ¬∑ intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      ¬∑ exact ht.2.2 p h'p
      ¬∑ rcases Finset.mem_image.1 h'p with ‚ü®p', p'v, rfl‚ü©
        exact (hr p' (vs' p'v)).1.1
    ¬∑ convert hŒºv using 2
      rw [Finset.set_biUnion_union, ‚Üê diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] ‚àÖ
  have u_succ : ‚àÄ n : ‚Ñï, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : ‚àÄ n, P (u n) := by
    intro n
    induction' n with n IH
    ¬∑ simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall‚ÇÇ_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    ¬∑ rw [u_succ]
      exact (hF (u n) IH).2.1
  refine ‚ü®‚ãÉ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_‚ü©
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  ¬∑ intro p hp
    rcases mem_iUnion.1 hp with ‚ü®n, hn‚ü©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  ¬∑ have A :
      ‚àÄ n,
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà ‚ãÉ n : ‚Ñï, (u n : Set (Œ± √ó ‚Ñù))), closedBall p.fst p.snd) ‚â§
          Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Œº (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Œ± √ó ‚Ñù))) n)
    have B :
        ‚àÄ n, Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) ‚â§
          (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n * Œº s := by
      intro n
      induction' n with n IH
      ¬∑ simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n.succ), closedBall p.fst p.snd) ‚â§
            N / (N + 1) * Œº (s \ ‚ãÉ (p : Œ± √ó ‚Ñù) (_ : p ‚àà u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ ‚â§ (N / (N + 1) : ‚Ñù‚â•0‚àû) ^ n.succ * Œº s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : ‚Ñï => ((N : ‚Ñù‚â•0‚àû) / (N + 1)) ^ n * Œº s) atTop (ùìù (0 * Œº s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Œº s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      ¬∑ conv_lhs => rw [‚Üê add_zero (N : ‚Ñù‚â•0‚àû)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      ¬∑ simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      ¬∑ simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  ¬∑ refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [‚Üê Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/CategoryTheory/Sites/Coherent/Equivalence.lean,CategoryTheory.Equivalence.preregular,preregular,09a7ef77a5b5c96dc87a39e16d844c0b39b1fca3,":=
  reflects_preregular e.inverse fun X ‚Ü¶ ‚ü®e.functor.obj X, e.unitInv.app _, inferInstance‚ü©","error:  unknown identifier 'reflects_preregular'
error:  invalid field notation, function 'CategoryTheory.Equivalence.preregular' does not have argument with type (CategoryTheory.Equivalence ...) that can be used, it must be explicit or implicit with a unique name
error:  function expected at
  preregular
term has type
  Preregular ?m.12078
error:  failed to synthesize
  Preregular D
use `set_option diagnostics true` to get diagnostic information
error:  invalid field notation, function 'CategoryTheory.Equivalence.preregular' does not have argument with type (CategoryTheory.Equivalence ...) that can be used, it must be explicit or implicit with a unique name
error:  failed to synthesize
  Preregular D
use `set_option diagnostics true` to get diagnostic information
error:  invalid field notation, function 'CategoryTheory.Equivalence.preregular' does not have argument with type (CategoryTheory.Equivalence ...) that can be used, it must be explicit or implicit with a unique name
error:  failed to synthesize
  Preregular D
use `set_option diagnostics true` to get diagnostic information
error:  typeclass instance problem is stuck, it is often due to metavariables
  Category.{u_4, u_4} ?m.22495",theorem preregular : Preregular D ,:= e.inverse.reflects_preregular
Mathlib/Analysis/InnerProductSpace/Basic.lean,Orthonormal.sum_inner_products_le,Orthonormal.sum_inner_products_le,868e1449d619ac98cf19e96339acab3ba4f241aa,":= by
  have h‚ÇÇ :
    (‚àë i ‚àà s, ‚àë j ‚àà s, ‚ü™v i, x‚ü´ * ‚ü™x, v j‚ü´ * ‚ü™v j, v i‚ü´) = (‚àë k ‚àà s, ‚ü™v k, x‚ü´ * ‚ü™x, v k‚ü´ : ùïú) := by
    classical exact hv.inner_left_right_finset
  have h‚ÇÉ : ‚àÄ z : ùïú, re (z * conj z) = ‚Äñz‚Äñ ^ 2 := by
    intro z
    simp only [mul_conj, normSq_eq_def']
    norm_cast
  suffices hbf : ‚Äñx - ‚àë i ‚àà s, ‚ü™v i, x‚ü´ ‚Ä¢ v i‚Äñ ^ 2 = ‚Äñx‚Äñ ^ 2 - ‚àë i ‚àà s, ‚Äñ‚ü™v i, x‚ü´‚Äñ ^ 2 by
    rw [‚Üê sub_nonneg, ‚Üê hbf]
    simp only [norm_nonneg, pow_nonneg]
  rw [@norm_sub_sq ùïú, sub_add]
  simp only [@PreInnerProductSpace.norm_sq_eq_inner ùïú, _root_.inner_sum, _root_.sum_inner]
  simp only [inner_smul_right, two_mul, inner_smul_left, inner_conj_symm, ‚Üê mul_assoc, h‚ÇÇ,
    add_sub_cancel_right, sub_right_inj]
  simp only [map_sum, ‚Üê inner_conj_symm x, ‚Üê h‚ÇÉ]","error:  unknown identifier 'PreInnerProductSpace.norm_sq_eq_inner'
error:  unsolved goals
ùïú : Type u_1
E : Type u_2
F : Type u_3
inst‚úù‚Å¥ : _root_.RCLike ùïú
inst‚úù¬≥ : NormedAddCommGroup E
inst‚úù¬≤ : InnerProductSpace ùïú E
inst‚úù¬π : NormedAddCommGroup F
inst‚úù : InnerProductSpace ‚Ñù F
Œπ : Type u_4
x : E
v : Œπ ‚Üí E
s : Finset Œπ
hv : Orthonormal ùïú v
h‚ÇÇ : ‚àë i ‚àà s, ‚àë j ‚àà s, ‚ü™v i, x‚ü´_ùïú * ‚ü™x, v j‚ü´_ùïú * ‚ü™v j, v i‚ü´_ùïú = ‚àë k ‚àà s, ‚ü™v k, x‚ü´_ùïú * ‚ü™x, v k‚ü´_ùïú
h‚ÇÉ : ‚àÄ (z : ùïú), re (z * (starRingEnd ùïú) z) = ‚Äñz‚Äñ ^ 2
‚ä¢ ‚àë x_1 ‚àà s, re (‚ü™v x_1, x‚ü´_ùïú * (starRingEnd ùïú) ‚ü™v x_1, x‚ü´_ùïú) +
        ‚àë x_1 ‚àà s, re (‚ü™v x_1, x‚ü´_ùïú * (starRingEnd ùïú) ‚ü™v x_1, x‚ü´_ùïú) -
      ‚Äñ‚àë i ‚àà s, ‚ü™v i, x‚ü´_ùïú ‚Ä¢ v i‚Äñ ^ 2 =
    ‚àë x_1 ‚àà s, re (‚ü™v x_1, x‚ü´_ùïú * (starRingEnd ùïú) ‚ü™v x_1, x‚ü´_ùïú)","theorem Orthonormal.sum_inner_products_le {s : Finset Œπ} (hv : Orthonormal ùïú v) :
    ‚àë i ‚àà s, ‚Äñ‚ü™v i, x‚ü´‚Äñ ^ 2 ‚â§ ‚Äñx‚Äñ ^ 2 ",":= by
  have h‚ÇÇ :
    (‚àë i ‚àà s, ‚àë j ‚àà s, ‚ü™v i, x‚ü´ * ‚ü™x, v j‚ü´ * ‚ü™v j, v i‚ü´) = (‚àë k ‚àà s, ‚ü™v k, x‚ü´ * ‚ü™x, v k‚ü´ : ùïú) := by
    classical exact hv.inner_left_right_finset
  have h‚ÇÉ : ‚àÄ z : ùïú, re (z * conj z) = ‚Äñz‚Äñ ^ 2 := by
    intro z
    simp only [mul_conj, normSq_eq_def']
    norm_cast
  suffices hbf : ‚Äñx - ‚àë i ‚àà s, ‚ü™v i, x‚ü´ ‚Ä¢ v i‚Äñ ^ 2 = ‚Äñx‚Äñ ^ 2 - ‚àë i ‚àà s, ‚Äñ‚ü™v i, x‚ü´‚Äñ ^ 2 by
    rw [‚Üê sub_nonneg, ‚Üê hbf]
    simp only [norm_nonneg, pow_nonneg]
  rw [@norm_sub_sq ùïú, sub_add]
  simp only [@InnerProductSpace.norm_sq_eq_inner ùïú, _root_.inner_sum, _root_.sum_inner]
  simp only [inner_smul_right, two_mul, inner_smul_left, inner_conj_symm, ‚Üê mul_assoc, h‚ÇÇ,
    add_sub_cancel_right, sub_right_inj]
  simp only [map_sum, ‚Üê inner_conj_symm x, ‚Üê h‚ÇÉ]"
Mathlib/Data/Real/Sqrt.lean,Real.sqrt_le_sqrt_iff,sqrt_le_sqrt_iff,57f68575c03ebf22f387c64f95a2043b5f70d1df,":= by
  rw [sqrt_def, sqrt_def, NNReal.coe_le_coe, NNReal.sqrt_le_sqrt, toNNReal_le_toNNReal_iff hy]","warning:  sqrt does not have a doc string
error:  unknown identifier 'sqrt_def'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.34789
x y : ‚Ñù
hy : 0 ‚â§ y
‚ä¢ ‚àöx ‚â§ ‚àöy ‚Üî x ‚â§ y",theorem sqrt_le_sqrt_iff (hy : 0 ‚â§ y) : ‚àöx ‚â§ ‚àöy ‚Üî x ‚â§ y ,":= by
  rw [Real.sqrt, Real.sqrt, NNReal.coe_le_coe, NNReal.sqrt_le_sqrt, toNNReal_le_toNNReal_iff hy]"
Mathlib/Topology/Category/Profinite/EffectiveEpi.lean,Profinite.effectiveEpiFamily_tfae,effectiveEpiFamily_tfae,29131019c389552288b33fba786258718f26dc2f,":= by
  tfae_have 2 ‚Üí 1
  ¬∑ intro
    simpa [‚Üê effectiveEpi_desc_iff_effectiveEpiFamily, (effectiveEpi_tfae (Sigma.desc œÄ)).out 0 1]
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 3 ‚Üí 2
  ¬∑ intro e
    rw [epi_iff_surjective]
    intro b
    obtain ‚ü®t, x, h‚ü© := e b
    refine ‚ü®Sigma.Œπ X t x, ?_‚ü©
    change (Sigma.Œπ X t ‚â´ Sigma.desc œÄ) x = _
    simpa using h
  tfae_have 2 ‚Üí 3
  ¬∑ intro e; rw [epi_iff_surjective] at e
    let i : ‚àê X ‚âÖ finiteCoproduct X (inferInstance : TotallyDisconnectedSpace (Œ£ (a : Œ±), X a)) :=
      (colimit.isColimit _).coconePointUniqueUpToIso (finiteCoproduct.isColimit _ _)
    intro b
    obtain ‚ü®t, rfl‚ü© := e b
    let q := i.hom t
    refine ‚ü®q.1,q.2,?_‚ü©
    have : t = i.inv (i.hom t) := show t = (i.hom ‚â´ i.inv) t by simp only [i.hom_inv_id]; rfl
    rw [this]
    show _ = (i.inv ‚â´ Sigma.desc œÄ) (i.hom t)
    suffices i.inv ‚â´ Sigma.desc œÄ = finiteCoproduct.desc X _ œÄ by
      rw [this]; rfl
    rw [Iso.inv_comp_eq]
    apply colimit.hom_ext
    rintro ‚ü®a‚ü©
    simp only [i, Discrete.functor_obj, colimit.Œπ_desc, Cofan.mk_pt, Cofan.mk_Œπ_app,
      colimit.comp_coconePointUniqueUpToIso_hom_assoc]
    ext; rfl
  tfae_finish","error:  function expected at
  finiteCoproduct X
term has type
  Profinite
error:  function expected at
  finiteCoproduct.isColimit ?m.15198
term has type
  IsColimit (finiteCoproduct.cofan ?m.15198)
error:  application type mismatch
  (finiteCoproduct.desc X ?m.18176) œÄ
argument
  œÄ
has type
  (a : Œ±) ‚Üí X a ‚ü∂ B : Type u
but is expected to have type
  (forget Profinite).obj (finiteCoproduct X) : Type u
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?Œ±.inv ‚â´ ?f = ?g
case tfae_2_to_3.intro
Œ± : Type
inst‚úù : Finite Œ±
B : Profinite
X : Œ± ‚Üí Profinite
œÄ : (a : Œ±) ‚Üí X a ‚ü∂ B
tfae_2_to_1 : Epi (Sigma.desc œÄ) ‚Üí EffectiveEpiFamily X œÄ
tfae_1_to_2 : EffectiveEpiFamily X œÄ ‚Üí Epi (Sigma.desc œÄ)
tfae_3_to_2 : (‚àÄ (b : ‚ÜëB.toCompHaus.toTop), ‚àÉ a x, (œÄ a) x = b) ‚Üí Epi (Sigma.desc œÄ)
e : Function.Surjective ‚áë(Sigma.desc œÄ)
i : ‚àê X ‚âÖ sorryAx Profinite true := sorryAx (‚àê X ‚âÖ sorryAx Profinite true) true
t : (forget Profinite).obj (‚àê X)
q : (forget Profinite).obj (sorryAx Profinite true) := i.hom t
this : t = i.inv (i.hom t)
‚ä¢ sorryAx (Sort ?u.17901) true","theorem effectiveEpiFamily_tfae
    {Œ± : Type} [Finite Œ±] {B : Profinite.{u}}
    (X : Œ± ‚Üí Profinite.{u}) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    TFAE
    [ EffectiveEpiFamily X œÄ
    , Epi (Sigma.desc œÄ)
    , ‚àÄ b : B, ‚àÉ (a : Œ±) (x : X a), œÄ a x = b
    ] ",":= by
  tfae_have 2 ‚Üí 1
  ¬∑ intro
    simpa [‚Üê effectiveEpi_desc_iff_effectiveEpiFamily, (effectiveEpi_tfae (Sigma.desc œÄ)).out 0 1]
  tfae_have 1 ‚Üí 2
  ¬∑ intro; infer_instance
  tfae_have 3 ‚Üî 1
  ¬∑ erw [((CompHaus.effectiveEpiFamily_tfae
      (fun a ‚Ü¶ profiniteToCompHaus.obj (X a)) (fun a ‚Ü¶ profiniteToCompHaus.map (œÄ a))).out 2 0 : )]
    exact ‚ü®fun h ‚Ü¶ profiniteToCompHaus.finite_effectiveEpiFamily_of_map _ _ h,
      fun _ ‚Ü¶ inferInstance‚ü©
  tfae_finish"
Mathlib/Order/Heyting/Basic.lean,himp_himp,himp_himp,f168625e615d9c67ebf22f3c975967f66d443364,":=
  eq_of_forall_le_iff fun d => by simp_rw [le_himp_iff, inf_assoc]; rfl",error:  no goals to be solved,theorem himp_himp (a b c : Œ±) : a ‚á® b ‚á® c = a ‚äì b ‚á® c ,":=
  eq_of_forall_le_iff fun d => by simp_rw [le_himp_iff, inf_assoc]"
Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean,jacobiSym.mul_right',mul_right',070b09db52c6f063dd905c04b291f74460734aab,":= by
  rw [jacobiSym, ((perm_factors_mul hb‚ÇÅ hb‚ÇÇ).pmap _).prod_eq, List.pmap_append, List.prod_append]
  exacts [rfl, fun p hp => (List.mem_append.mp hp).elim prime_of_mem_factors prime_of_mem_factors]","warning:  jacobiSym does not have a doc string
error:  type mismatch
  rfl
has type
  (List.pmap (fun p pp ‚Ü¶ legendreSym p a) b‚ÇÅ.factors ‚ãØ).prod *
      (List.pmap (fun p pp ‚Ü¶ legendreSym p a) b‚ÇÇ.factors ‚ãØ).prod =
    (List.pmap (fun p pp ‚Ü¶ legendreSym p a) b‚ÇÅ.factors ‚ãØ).prod *
      (List.pmap (fun p pp ‚Ü¶ legendreSym p a) b‚ÇÇ.factors ‚ãØ).prod : Prop
but is expected to have type
  (List.pmap (fun p pp ‚Ü¶ legendreSym p a) b‚ÇÅ.factors ‚ãØ).prod *
      (List.pmap (fun p pp ‚Ü¶ legendreSym p a) b‚ÇÇ.factors ‚ãØ).prod =
    J(a | b‚ÇÅ) * J(a | b‚ÇÇ) : Prop","theorem mul_right' (a : ‚Ñ§) {b‚ÇÅ b‚ÇÇ : ‚Ñï} (hb‚ÇÅ : b‚ÇÅ ‚â† 0) (hb‚ÇÇ : b‚ÇÇ ‚â† 0) :
    J(a | b‚ÇÅ * b‚ÇÇ) = J(a | b‚ÇÅ) * J(a | b‚ÇÇ) ",":= by
  rw [jacobiSym, ((perm_factors_mul hb‚ÇÅ hb‚ÇÇ).pmap _).prod_eq, List.pmap_append, List.prod_append]
  case h => exact fun p hp => (List.mem_append.mp hp).elim prime_of_mem_factors prime_of_mem_factors
  case _ => rfl"
Mathlib/Order/Bounded.lean,Set.bounded_le_inter_le,bounded_le_inter_le,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine' ‚ü®_, Bounded.mono (Set.inter_subset_left s _)‚ü©
  rw [‚Üê @bounded_le_inter_lt _ s _ a]
  exact Bounded.mono fun x ‚ü®hx, hx'‚ü© => ‚ü®hx, le_of_lt hx'‚ü©","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set Œ± : Type u_1
but is expected to have type
  ?m.20507 ‚àà ?m.20505 ‚à© ?m.20506 : Prop","theorem bounded_le_inter_le [LinearOrder Œ±] (a : Œ±) :
    Bounded (¬∑ ‚â§ ¬∑) (s ‚à© { b | a ‚â§ b }) ‚Üî Bounded (¬∑ ‚â§ ¬∑) s ",":= by
  refine ‚ü®?_, Bounded.mono Set.inter_subset_left‚ü©
  rw [‚Üê @bounded_le_inter_lt _ s _ a]
  exact Bounded.mono fun x ‚ü®hx, hx'‚ü© => ‚ü®hx, le_of_lt hx'‚ü©"
Mathlib/Data/Finsupp/Basic.lean,Finsupp.mem_frange,mem_frange,67e80fd089fe45abea632652c43b78eba72d60e3,":= by
  cases' f with f s
  induction' s using Trunc.induction_on with s
  simp [frange, Trunc.lift_mk]
  constructor
  case mp  => rintro ‚ü®a, ‚ü®_, ha‚ü©, rfl‚ü©; exact ‚ü®ha, a, rfl‚ü©
  case mpr => rintro ‚ü®ha, a, rfl‚ü©; exact ‚ü®a, ‚ü®(s.prop a).resolve_right ha, ha‚ü©, rfl‚ü©","error:  target
  s
has type
  Œ± ‚Üí M : Type (max u_5 u_1)
but is expected to have type
  Trunc ?m.239428 : Sort ?u.239422","theorem mem_frange {f : Œ± ‚Üí‚ÇÄ M} {y : M} : y ‚àà f.frange ‚Üî y ‚â† 0 ‚àß ‚àÉ x, f x = y ",":= by
  rw [frange, @Finset.mem_image _ _ (Classical.decEq _) _ f.support]
  exact ‚ü®fun ‚ü®x, hx1, hx2‚ü© => ‚ü®hx2 ‚ñ∏ mem_support_iff.1 hx1, x, hx2‚ü©, fun ‚ü®hy, x, hx‚ü© =>
    ‚ü®x, mem_support_iff.2 (hx.symm ‚ñ∏ hy), hx‚ü©‚ü©"
Mathlib/MeasureTheory/Measure/Haar/Quotient.lean,MeasureTheory.QuotientMeasureEqMeasurePreimage.smulInvariantMeasure_quotient,MeasureTheory.QuotientMeasureEqMeasurePreimage.smulInvariantMeasure_quotient,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,"  measure_preimage_smul g A hA := by
    have meas_œÄ : Measurable œÄ := continuous_quotient_mk'.measurable
    obtain ‚ü®ùìï, hùìï‚ü© := hasFun.ExistsIsFundamentalDomain
    have hùìï_translate_fundom : IsFundamentalDomain Œì.op (g ‚Ä¢ ùìï) ŒΩ :=
      hùìï.smul_of_comm g
    rw [hùìï.projection_respects_measure_apply (Œº := Œº)
      (meas_œÄ (measurableSet_preimage (measurable_const_smul g) hA)),
      hùìï_translate_fundom.projection_respects_measure_apply (Œº := Œº) hA]
    change ŒΩ ((œÄ ‚Åª¬π' _) ‚à© _) = ŒΩ ((œÄ ‚Åª¬π' _) ‚à© _)
    set œÄ_preA := œÄ ‚Åª¬π' A
    have : œÄ ‚Åª¬π' ((fun x : G ‚ß∏ Œì => g ‚Ä¢ x) ‚Åª¬π' A) = (g * ¬∑) ‚Åª¬π' œÄ_preA := by ext1; simp [œÄ_preA]
    rw [this]
    have : ŒΩ ((g * ¬∑) ‚Åª¬π' œÄ_preA ‚à© ùìï) = ŒΩ (œÄ_preA ‚à© (g‚Åª¬π * ¬∑) ‚Åª¬π' ùìï) := by
      trans ŒΩ ((g * ¬∑) ‚Åª¬π' (œÄ_preA ‚à© (g‚Åª¬π * ¬∑) ‚Åª¬π' ùìï))
      ¬∑ rw [preimage_inter]
        congr 2
        simp [Set.preimage]
      rw [measure_preimage_mul]
    rw [this, ‚Üê preimage_smul_inv]; rfl","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Œº ((fun x ‚Ü¶ g ‚Ä¢ x) ‚Åª¬π' A)
case intro
G : Type u_1
inst‚úù¬π‚Å∞ : Group G
inst‚úù‚Åπ : MeasurableSpace G
inst‚úù‚Å∏ : TopologicalSpace G
inst‚úù‚Å∑ : TopologicalGroup G
inst‚úù‚Å∂ : BorelSpace G
inst‚úù‚Åµ : PolishSpace G
ŒΩ : Measure G
Œì : Subgroup G
inst‚úù‚Å¥ : Countable ‚Ü•Œì
inst‚úù¬≥ : T2Space (G ‚ß∏ Œì)
inst‚úù¬≤ : SecondCountableTopology (G ‚ß∏ Œì)
Œº : Measure (G ‚ß∏ Œì)
inst‚úù¬π : QuotientMeasureEqMeasurePreimage ŒΩ Œº
inst‚úù : ŒΩ.IsMulLeftInvariant
hasFun : HasFundamentalDomain (‚Ü•Œì.op) G ŒΩ
g : G
A : Set (G ‚ß∏ Œì)
hA : MeasurableSet A
meas_œÄ : Measurable QuotientGroup.mk
ùìï : Set G
hùìï : IsFundamentalDomain (‚Ü•Œì.op) ùìï ŒΩ
hùìï_translate_fundom : IsFundamentalDomain (‚Ü•Œì.op) (g ‚Ä¢ ùìï) ŒΩ
‚ä¢ Œº ((fun x ‚Ü¶ g ‚Ä¢ x) ‚Åª¬π' A) = Œº A","lemma MeasureTheory.QuotientMeasureEqMeasurePreimage.smulInvariantMeasure_quotient
    [IsMulLeftInvariant ŒΩ] [hasFun : HasFundamentalDomain Œì.op G ŒΩ] :
    SMulInvariantMeasure G (G ‚ß∏ Œì) Œº where
","  measure_preimage_smul g A hA := by
    have meas_œÄ : Measurable œÄ := continuous_quotient_mk'.measurable
    obtain ‚ü®ùìï, hùìï‚ü© := hasFun.ExistsIsFundamentalDomain
    have hùìï_translate_fundom : IsFundamentalDomain Œì.op (g ‚Ä¢ ùìï) ŒΩ := hùìï.smul_of_comm g
    erw [hùìï.projection_respects_measure_apply (Œº := Œº)
      (meas_œÄ (measurableSet_preimage (measurable_const_smul g) hA)),
      hùìï_translate_fundom.projection_respects_measure_apply (Œº := Œº) hA]
    change ŒΩ ((œÄ ‚Åª¬π' _) ‚à© _) = ŒΩ ((œÄ ‚Åª¬π' _) ‚à© _)
    set œÄ_preA := œÄ ‚Åª¬π' A
    have : œÄ ‚Åª¬π' ((fun x : G ‚ß∏ Œì => g ‚Ä¢ x) ‚Åª¬π' A) = (g * ¬∑) ‚Åª¬π' œÄ_preA := by ext1; simp [œÄ_preA]
    rw [this]
    have : ŒΩ ((g * ¬∑) ‚Åª¬π' œÄ_preA ‚à© ùìï) = ŒΩ (œÄ_preA ‚à© (g‚Åª¬π * ¬∑) ‚Åª¬π' ùìï) := by
      trans ŒΩ ((g * ¬∑) ‚Åª¬π' (œÄ_preA ‚à© (g‚Åª¬π * ¬∑) ‚Åª¬π' ùìï))
      ¬∑ rw [preimage_inter]
        congr 2
        simp [Set.preimage]
      rw [measure_preimage_mul]
    rw [this, ‚Üê preimage_smul_inv]; rfl"
Mathlib/Analysis/BoxIntegral/DivergenceTheorem.lean,BoxIntegral.hasIntegral_GP_pderiv,hasIntegral_GP_pderiv,132658dad5b44b1f4aee2f646a8e244692c96863,":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine' HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le _ _ _ s hs _ _
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine' .and _ (.and _ _)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) :=
          inter_subset_inter_left _ (closedBall_subset_closedBall hŒ¥.2)
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := (add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ))
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine' this.eventually (ge_mem_nhds _)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine' ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ _‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp [F]
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine' (norm_sub_le _ _).trans (add_le_add _ _)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine' (mul_le_mul_of_nonneg_right _ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
          _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine' (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans _
      refine' (mul_le_mul_of_nonneg_right _ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine' prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => _
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := (dist_le_pi_dist J.upper J.lower (i.succAbove j))
        _ ‚â§ dist J.upper x + dist J.lower x := (dist_triangle_right _ _ _)
        _ ‚â§ Œ¥ + Œ¥ := (add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc))
        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1 ((Hd x hx).isLittleO.definition Œµ'0)
      with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine' ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => _‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine' (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ _) (hJc rfl)).trans _
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg","error:  invalid field 'definition', the environment does not contain 'Asymptotics.IsLittleO.definition'
  (Hd x hx).isLittleO
has type
  (fun x' ‚Ü¶ f x' - f x - (f' x) (x' - x)) =o[ùìù[Box.Icc I] x] fun x' ‚Ü¶ x' - x
error:  type mismatch
  HŒ¥ ?m.101432
has type
  ?m.101431 ‚àà ?m.99938 : Prop
but is expected to have type
  ‚Äñf y - ?m.101421 - ?m.101184 (y - x)‚Äñ ‚â§ Œµ' * ‚Äñy - x‚Äñ : Prop
error:  invalid constructor ‚ü®...‚ü©, expected type must be an inductive type 
  E","theorem hasIntegral_GP_pderiv (f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E)
    (f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E) (s : Set (Fin (n + 1) ‚Üí ‚Ñù))
    (hs : s.Countable) (Hs : ‚àÄ x ‚àà s, ContinuousWithinAt f (Box.Icc I) x)
    (Hd : ‚àÄ x ‚àà (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :
    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume
      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))
          BoxAdditiveMap.volume -
        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))
          BoxAdditiveMap.volume) ",":= by
  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by
    by_cases hxs : x ‚àà s
    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]
  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>
    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume
  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>
    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive
  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl
  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)
  refine HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le ?_ ?_ _ s hs ?_ ?_
  ¬∑
    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top
  ¬∑ exact fun J => ENNReal.toReal_nonneg
  ¬∑ intro c x hx Œµ Œµ0
    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß
        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),
              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by
      refine .and ?_ (.and ?_ ?_)
      ¬∑ exact Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, one_half_pos‚ü©
      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1
            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©
        filter_upwards [Ioc_mem_nhdsWithin_Ioi ‚ü®le_rfl, Œ¥‚ÇÅ0‚ü©] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ
        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) := by gcongr; exact hŒ¥.2
        rw [‚Üê dist_eq_norm]
        calc
          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _
          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ)
          _ = Œµ / 2 := add_halves _
      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)
            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _
        refine this.eventually (ge_mem_nhds ?_)
        simpa using half_pos Œµ0
    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©
    refine ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ ?_‚ü©
    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)
    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)
    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),
        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))
          BoxAdditiveMap.volume := fun x hx =>
      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)
        volume
    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)
    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),
        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>
      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'
    simp only [dist_eq_norm]; dsimp [F]
    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]
    refine (norm_sub_le _ _).trans (add_le_add ?_ ?_)
    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]
      refine (mul_le_mul_of_nonneg_right ?_ <| norm_nonneg _).trans hŒ¥
      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶
        calc
          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _
          _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
          _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
          _ = 2 * Œ¥ := (two_mul Œ¥).symm
      calc
        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=
          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j
        _ = (2 * Œ¥) ^ (n + 1) := by simp
    ¬∑ refine (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _
        (Hmaps _ Hl hy)) volume).trans ?_
      refine (mul_le_mul_of_nonneg_right ?_ (half_pos Œµ0).le).trans_eq (one_mul _)
      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]
      refine prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => ?_
      calc
        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§
            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=
          le_abs_self _
        _ ‚â§ dist J.upper J.lower := dist_le_pi_dist J.upper J.lower (i.succAbove j)
        _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _
        _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)
        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr
        _ = 1 := add_halves 1
  ¬∑ intro c x hx Œµ Œµ0
    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©
    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1
      ((Hd x hx).isLittleO.def Œµ'0) with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©
    refine ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => ?_‚ü©
    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]
    refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le _
      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ ?_) (hJc rfl)).trans ?_
    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©
    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]
      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg"
Mathlib/Data/Nat/ModEq.lean,Nat.ModEq.eq_of_lt_of_lt,eq_of_lt_of_lt,27d257fca86730535c755957eeacad78dfe0e921,:=,"warning:  ModEq does not have a doc string
error:  unexpected token 'lemma'; expected term",lemma eq_of_lt_of_lt (h : a ‚â° b [MOD m]) (ha : a < m) (hb : b < m) : a = b ,":=
  h.eq_of_abs_lt <| abs_sub_lt_iff.2
    ‚ü®(sub_le_self _ <| Int.natCast_nonneg _).trans_lt <| Int.ofNat_lt.2 hb,
    (sub_le_self _ <| Int.natCast_nonneg _).trans_lt <| Int.ofNat_lt.2 ha‚ü©"
Mathlib/Analysis/NormedSpace/HahnBanach/Extension.lean,Submodule.ClosedComplemented.of_finiteDimensional,Submodule.ClosedComplemented.of_finiteDimensional,7088139429bcf36357f4c44f3beff1a1374a13e1,":=
  let ‚ü®g, hg‚ü© := (ContinuousLinearMap.id ùïú p).exist_extension_of_finiteDimensional_range
  ‚ü®g, FunLike.congr_fun hg.symm‚ü©",error:  unknown constant 'FunLike.congr_fun',"lemma Submodule.ClosedComplemented.of_finiteDimensional (p : Submodule ùïú F)
    [FiniteDimensional ùïú p] : p.ClosedComplemented ",":=
  let ‚ü®g, hg‚ü© := (ContinuousLinearMap.id ùïú p).exist_extension_of_finiteDimensional_range
  ‚ü®g, DFunLike.congr_fun hg.symm‚ü©"
Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean,symm_trans_mem_contDiffGroupoid,symm_trans_mem_contDiffGroupoid,b492f764dc62b80a0be745055df26ce5b018a24a,":=
  haveI : e.symm.trans e ‚âà PartialHomeomorph.ofSet e.target e.open_target :=
    PartialHomeomorph.symm_trans_self _
  StructureGroupoid.eq_on_source _ (ofSet_mem_contDiffGroupoid n I e.open_target) this","warning:  modelWithCornersSelf does not have a doc string
error:  unknown constant 'StructureGroupoid.eq_on_source'","theorem symm_trans_mem_contDiffGroupoid (e : PartialHomeomorph M H) :
    e.symm.trans e ‚àà contDiffGroupoid n I ",":=
  haveI : e.symm.trans e ‚âà PartialHomeomorph.ofSet e.target e.open_target :=
    PartialHomeomorph.symm_trans_self _
  StructureGroupoid.mem_of_eqOnSource _ (ofSet_mem_contDiffGroupoid n I e.open_target) this"
Mathlib/FieldTheory/IsAlgClosed/Spectrum.lean,spectrum.subset_polynomial_aeval,subset_polynomial_aeval,18b64d3b01560f3af84d7ae915a9f4830f705b5d,":= by
  rintro _ ‚ü®k, hk, rfl‚ü©
  let q := C (eval k p) - p
  have hroot : IsRoot q k := by simp only [eval_C, eval_sub, sub_self, IsRoot.def]
  rw [‚Üê mul_div_eq_iff_isRoot, ‚Üê neg_mul_neg, neg_sub] at hroot
  have aeval_q_eq : ‚Üë‚Çê (eval k p) - aeval a p = aeval a q := by
    simp only [aeval_C, AlgHom.map_sub, sub_left_inj]
  rw [mem_iff, aeval_q_eq, ‚Üê hroot, aeval_mul]
  have hcomm := (Commute.all (C k - X) (-(q / (X - C k)))).map (aeval a : ùïú[X] ‚Üí‚Çê[ùïú] A)
  apply mt fun h => (hcomm.isUnit_mul_iff.mp h).1
  simpa only [aeval_X, aeval_C, AlgHom.map_sub] using hk","error:  unsolved goals
ùïú : Type u
A : Type v
inst‚úù¬≤ : Field ùïú
inst‚úù¬π : Ring A
inst‚úù : Algebra ùïú A
a : A
p : ùïú[X]
k : ùïú
hk : k ‚àà œÉ a
q : ùïú[X] := C (eval k p) - p
‚ä¢ eval k q = 0
error:  simp made no progress",theorem subset_polynomial_aeval (a : A) (p : ùïú[X]) : (eval ¬∑ p) '' œÉ a ‚äÜ œÉ (aeval a p) ,":= by
  rintro _ ‚ü®k, hk, rfl‚ü©
  let q := C (eval k p) - p
  have hroot : IsRoot q k := by simp only [q, eval_C, eval_sub, sub_self, IsRoot.def]
  rw [‚Üê mul_div_eq_iff_isRoot, ‚Üê neg_mul_neg, neg_sub] at hroot
  have aeval_q_eq : ‚Üë‚Çê (eval k p) - aeval a p = aeval a q := by
    simp only [q, aeval_C, AlgHom.map_sub, sub_left_inj]
  rw [mem_iff, aeval_q_eq, ‚Üê hroot, aeval_mul]
  have hcomm := (Commute.all (C k - X) (-(q / (X - C k)))).map (aeval a : ùïú[X] ‚Üí‚Çê[ùïú] A)
  apply mt fun h => (hcomm.isUnit_mul_iff.mp h).1
  simpa only [aeval_X, aeval_C, AlgHom.map_sub] using hk"
Mathlib/Data/List/Zip.lean,List.get?_zip_with_eq_some,get?_zip_with_eq_some,561da585a69fbbdde80bd939bbe9557293b5250e,":= by
  induction l‚ÇÅ generalizing l‚ÇÇ i
  ¬∑ simp [zipWith]
  ¬∑ cases l‚ÇÇ <;> simp only [zipWith, get?, exists_false, and_false_iff, false_and_iff]
    cases i <;> simp [*]","error:  unsolved goals
case cons.cons.succ
Œ± : Type u
Œ≤ : Type u_1
Œ≥ : Type u_2
Œ¥ : Type u_3
Œµ : Type u_4
f : Œ± ‚Üí Œ≤ ‚Üí Œ≥
z : Œ≥
head‚úù¬π : Œ±
tail‚úù¬π : List Œ±
tail_ih‚úù :
  ‚àÄ (l‚ÇÇ : List Œ≤) (i : ‚Ñï),
    (zipWith f tail‚úù¬π l‚ÇÇ).get? i = some z ‚Üî ‚àÉ x y, tail‚úù¬π.get? i = some x ‚àß l‚ÇÇ.get? i = some y ‚àß f x y = z
head‚úù : Œ≤
tail‚úù : List Œ≤
n‚úù : ‚Ñï
‚ä¢ (zipWith f tail‚úù¬π tail‚úù)[n‚úù]? = some z ‚Üî ‚àÉ x, tail‚úù¬π[n‚úù]? = some x ‚àß ‚àÉ x_1, tail‚úù[n‚úù]? = some x_1 ‚àß f x x_1 = z
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_zipWith` has been deprecated, use `List.getElem_zipWith` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_zipWith` has been deprecated, use `List.get_zipWith` instead","theorem get?_zip_with_eq_some (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (l‚ÇÅ : List Œ±) (l‚ÇÇ : List Œ≤) (z : Œ≥) (i : ‚Ñï) :
    (zipWith f l‚ÇÅ l‚ÇÇ).get? i = some z ‚Üî
      ‚àÉ x y, l‚ÇÅ.get? i = some x ‚àß l‚ÇÇ.get? i = some y ‚àß f x y = z ",":= by
  simp [getElem?_zip_with_eq_some]"
Mathlib/RingTheory/DedekindDomain/Ideal.lean,exists_multiset_prod_cons_le_and_prod_not_le,exists_multiset_prod_cons_le_and_prod_not_le,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  obtain ‚ü®Z‚ÇÄ, hZ‚ÇÄ‚ü© := PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain hNF hI0
  obtain ‚ü®Z, ‚ü®hZI, hprodZ‚ü©, h_eraseZ‚ü© :=
    Multiset.wellFounded_lt.has_min
      (fun Z => (Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß (Z.map PrimeSpectrum.asIdeal).prod ‚â† ‚ä•)
      ‚ü®Z‚ÇÄ, hZ‚ÇÄ‚ü©
  have hZM : Multiset.prod (Z.map PrimeSpectrum.asIdeal) ‚â§ M := le_trans hZI hIM
  have hZ0 : Z ‚â† 0 := by rintro rfl; simp [hM.ne_top] at hZM
  obtain ‚ü®_, hPZ', hPM‚ü© := (hM.isPrime.multiset_prod_le (mt Multiset.map_eq_zero.mp hZ0)).mp hZM
  obtain ‚ü®P, hPZ, rfl‚ü© := Multiset.mem_map.mp hPZ'
  classical
    have := Multiset.map_erase PrimeSpectrum.asIdeal PrimeSpectrum.ext P Z
    obtain ‚ü®hP0, hZP0‚ü© : P.asIdeal ‚â† ‚ä• ‚àß ((Z.erase P).map PrimeSpectrum.asIdeal).prod ‚â† ‚ä• := by
      rwa [Ne.def, ‚Üê Multiset.cons_erase hPZ', Multiset.prod_cons, Ideal.mul_eq_bot, not_or, ‚Üê
        this] at hprodZ
    have hPM' := (IsDedekindDomain.dimensionLEOne _ hP0 P.IsPrime).eq_of_le hM.ne_top hPM
    subst hPM'
    refine ‚ü®Z.erase P, ?_, ?_‚ü©
    ¬∑ convert hZI
      rw [this, Multiset.cons_erase hPZ']
    ¬∑ refine fun h => h_eraseZ (Z.erase P) ‚ü®h, ?_‚ü© (Multiset.erase_lt.mpr hPZ)
      exact hZP0","error:  unknown constant 'Multiset.wellFounded_lt.has_min'
error:  rcases tactic failed: x‚úù : ?m.159565 is not an inductive datatype","theorem exists_multiset_prod_cons_le_and_prod_not_le [IsDedekindDomain A] (hNF : ¬¨IsField A)
    {I M : Ideal A} (hI0 : I ‚â† ‚ä•) (hIM : I ‚â§ M) [hM : M.IsMaximal] :
    ‚àÉ Z : Multiset (PrimeSpectrum A),
      (M ::‚Çò Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß
        ¬¨Multiset.prod (Z.map PrimeSpectrum.asIdeal) ‚â§ I ",":= by
  obtain ‚ü®Z‚ÇÄ, hZ‚ÇÄ‚ü© := PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain hNF hI0
  obtain ‚ü®Z, ‚ü®hZI, hprodZ‚ü©, h_eraseZ‚ü© :=
    wellFounded_lt.has_min
      {Z | (Z.map PrimeSpectrum.asIdeal).prod ‚â§ I ‚àß (Z.map PrimeSpectrum.asIdeal).prod ‚â† ‚ä•}
      ‚ü®Z‚ÇÄ, hZ‚ÇÄ.1, hZ‚ÇÄ.2‚ü©
  obtain ‚ü®_, hPZ', hPM‚ü© := hM.isPrime.multiset_prod_le.mp (hZI.trans hIM)
  obtain ‚ü®P, hPZ, rfl‚ü© := Multiset.mem_map.mp hPZ'
  classical
    have := Multiset.map_erase PrimeSpectrum.asIdeal PrimeSpectrum.ext P Z
    obtain ‚ü®hP0, hZP0‚ü© : P.asIdeal ‚â† ‚ä• ‚àß ((Z.erase P).map PrimeSpectrum.asIdeal).prod ‚â† ‚ä• := by
      rwa [Ne, ‚Üê Multiset.cons_erase hPZ', Multiset.prod_cons, Ideal.mul_eq_bot, not_or, ‚Üê
        this] at hprodZ
    have hPM' := (P.isPrime.isMaximal hP0).eq_of_le hM.ne_top hPM
    subst hPM'
    refine ‚ü®Z.erase P, ?_, ?_‚ü©
    ¬∑ convert hZI
      rw [this, Multiset.cons_erase hPZ']
    ¬∑ refine fun h => h_eraseZ (Z.erase P) ‚ü®h, ?_‚ü© (Multiset.erase_lt.mpr hPZ)
      exact hZP0"
Mathlib/RingTheory/Ideal/Cotangent.lean,LocalRing.finrank_cotangentSpace_le_one_iff,finrank_cotangentSpace_le_one_iff,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  rw [Module.finrank_le_one_iff_top_isPrincipal, IsPrincipal_iff,
    (maximalIdeal R).toCotangent_surjective.exists, IsPrincipal_iff]
  simp_rw [‚Üê Set.image_singleton, eq_comm (a := ‚ä§), CotangentSpace.span_image_eq_top_iff,
    ‚Üê (map_injective_of_injective (injective_subtype _)).eq_iff, map_span, Set.image_singleton,
    Submodule.map_top, range_subtype, eq_comm (a := maximalIdeal R)]
  exact ‚ü®fun ‚ü®x, h‚ü© ‚Ü¶ ‚ü®_, h‚ü©, fun ‚ü®x, h‚ü© ‚Ü¶ ‚ü®‚ü®x, h ‚ñ∏ subset_span (Set.mem_singleton x)‚ü©, h‚ü©‚ü©","error:  unknown identifier 'IsPrincipal_iff'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.207623
R : Type u_1
inst‚úù¬≤ : CommRing R
inst‚úù¬π : LocalRing R
inst‚úù : IsNoetherianRing R
‚ä¢ ‚ä§.IsPrincipal ‚Üî IsPrincipal (maximalIdeal R)","theorem finrank_cotangentSpace_le_one_iff [IsNoetherianRing R] :
    finrank (ResidueField R) (CotangentSpace R) ‚â§ 1 ‚Üî (maximalIdeal R).IsPrincipal ",":= by
  rw [Module.finrank_le_one_iff_top_isPrincipal, isPrincipal_iff,
    (maximalIdeal R).toCotangent_surjective.exists, isPrincipal_iff]
  simp_rw [‚Üê Set.image_singleton, eq_comm (a := ‚ä§), CotangentSpace.span_image_eq_top_iff,
    ‚Üê (map_injective_of_injective (injective_subtype _)).eq_iff, map_span, Set.image_singleton,
    Submodule.map_top, range_subtype, eq_comm (a := maximalIdeal R)]
  exact ‚ü®fun ‚ü®x, h‚ü© ‚Ü¶ ‚ü®_, h‚ü©, fun ‚ü®x, h‚ü© ‚Ü¶ ‚ü®‚ü®x, h ‚ñ∏ subset_span (Set.mem_singleton x)‚ü©, h‚ü©‚ü©"
Mathlib/Algebra/Order/CauSeq/Basic.lean,IsCauSeq.bounded,bounded,52246a5198338f057a074cd3bf958a5e8b44c5f3,":= by
  obtain ‚ü®i, h‚ü© := hf _ zero_lt_one
  set R : ‚Ñï ‚Üí Œ± := @Nat.rec (fun _ => Œ±) (abv (f 0)) fun i c => max c (abv (f i.succ)) with hR
  have : ‚àÄ i, ‚àÄ j ‚â§ i, abv (f j) ‚â§ R i := by
    refine' Nat.rec (by simp [hR]) _
    rintro i hi j (rfl | hj)
    ¬∑ simp
    ¬∑ exact (hi j hj).trans (le_max_left _ _)
  refine ‚ü®R i + 1, fun j ‚Ü¶ ?_‚ü©
  obtain hji | hij := le_total j i
  ¬∑ exact (this i _ hji).trans_lt (lt_add_one _)
  ¬∑ simpa using (abv_add abv _ _).trans_lt $ add_lt_add_of_le_of_lt (this i _ le_rfl) (h _ hij)","error:  unsolved goals
case refl
Œ± : Type u_1
Œ≤ : Type u_2
inst‚úù¬≤ : LinearOrderedField Œ±
inst‚úù¬π : Ring Œ≤
abv : Œ≤ ‚Üí Œ±
inst‚úù : IsAbsoluteValue abv
f g : ‚Ñï ‚Üí Œ≤
hf : IsCauSeq abv f
i‚úù : ‚Ñï
h : ‚àÄ j ‚â• i‚úù, abv (f j - f i‚úù) < 1
R : ‚Ñï ‚Üí Œ± := Nat.rec (abv (f 0)) fun i c ‚Ü¶ max c (abv (f i.succ))
hR : R = Nat.rec (abv (f 0)) fun i c ‚Ü¶ max c (abv (f i.succ))
i : ‚Ñï
hi : ‚àÄ j ‚â§ i, abv (f j) ‚â§ R i
‚ä¢ abv (f (i + 1)) ‚â§ R (i + 1)","lemma bounded (hf : IsCauSeq abv f) : ‚àÉ r, ‚àÄ i, abv (f i) < r ",":= by
  obtain ‚ü®i, h‚ü© := hf _ zero_lt_one
  set R : ‚Ñï ‚Üí Œ± := @Nat.rec (fun _ => Œ±) (abv (f 0)) fun i c => max c (abv (f i.succ)) with hR
  have : ‚àÄ i, ‚àÄ j ‚â§ i, abv (f j) ‚â§ R i := by
    refine Nat.rec (by simp [hR]) ?_
    rintro i hi j (rfl | hj)
    ¬∑ simp [R]
    ¬∑ exact (hi j hj).trans (le_max_left _ _)
  refine ‚ü®R i + 1, fun j ‚Ü¶ ?_‚ü©
  obtain hji | hij := le_total j i
  ¬∑ exact (this i _ hji).trans_lt (lt_add_one _)
  ¬∑ simpa using (abv_add abv _ _).trans_lt $ add_lt_add_of_le_of_lt (this i _ le_rfl) (h _ hij)"
Mathlib/LinearAlgebra/Matrix/Spectrum.lean,Matrix.IsHermitian.det_eq_prod_eigenvalues,det_eq_prod_eigenvalues,5250ed6b5cbd9c34a91206fe413e98dfc25abd1d,":= by
  convert congr_arg det hA.spectral_theorem2
  rw [det_mul_right_comm]
  simp","error:  invalid field 'spectral_theorem2', the environment does not contain 'Matrix.IsHermitian.spectral_theorem2'
  hA
has type
  A.IsHermitian
error:  invalid field 'spectral_theorem2', the environment does not contain 'Eq.spectral_theorem2'
  hA
has type
  A·¥¥ = A
error:  unsolved goals
case h.e'_3
ùïú : Type u_1
inst‚úù¬≤ : RCLike ùïú
n : Type u_2
inst‚úù¬π : Fintype n
A : Matrix n n ùïú
inst‚úù : DecidableEq n
hA : A.IsHermitian
‚ä¢ ‚àè i : n, ‚Üë(hA.eigenvalues i) = ?h.e'_3.M.det * ?h.e'_3.P.det * ?h.e'_3.N.det

case h.e'_3.M
ùïú : Type u_1
inst‚úù¬≤ : RCLike ùïú
n : Type u_2
inst‚úù¬π : Fintype n
A : Matrix n n ùïú
inst‚úù : DecidableEq n
hA : A.IsHermitian
‚ä¢ Matrix n n ùïú

case h.e'_3.N
ùïú : Type u_1
inst‚úù¬≤ : RCLike ùïú
n : Type u_2
inst‚úù¬π : Fintype n
A : Matrix n n ùïú
inst‚úù : DecidableEq n
hA : A.IsHermitian
‚ä¢ Matrix n n ùïú

case h.e'_3.P
ùïú : Type u_1
inst‚úù¬≤ : RCLike ùïú
n : Type u_2
inst‚úù¬π : Fintype n
A : Matrix n n ùïú
inst‚úù : DecidableEq n
hA : A.IsHermitian
‚ä¢ Matrix n n ùïú","theorem det_eq_prod_eigenvalues : det A = ‚àè i, (hA.eigenvalues i : ùïú) ",":= by
  convert congr_arg det hA.spectral_theorem
  rw [det_mul_right_comm]
  simp"
Mathlib/Algebra/Ring/Basic.lean,NoZeroDivisors.to_isDomain,NoZeroDivisors.to_isDomain,0c7d6fa5bb16b4a1ca9eaa97c01bce48bcac90d5,:=,error:  unexpected token 'instance'; expected term,"lemma NoZeroDivisors.to_isDomain [Ring Œ±] [h : Nontrivial Œ±] [NoZeroDivisors Œ±] :
    IsDomain Œ± ",":=
  { NoZeroDivisors.to_isCancelMulZero Œ±, h with .. }"
Mathlib/Topology/Perfect.lean,exists_countable_union_perfect_of_isClosed,exists_countable_union_perfect_of_isClosed,1dc887740d2df22ab91917858f6dc84546892421,":= by
  obtain ‚ü®b, bct, _, bbasis‚ü© := TopologicalSpace.exists_countable_basis Œ±
  let v := { U ‚àà b | (U ‚à© C).Countable }
  let V := ‚ãÉ U ‚àà v, U
  let D := C \ V
  have Vct : (V ‚à© C).Countable := by
    simp only [iUnion_inter, mem_sep_iff]
    apply Countable.biUnion
    ¬∑ exact Countable.mono (inter_subset_left _ _) bct
    ¬∑ exact inter_subset_right _ _
  refine' ‚ü®V ‚à© C, D, Vct, ‚ü®_, _‚ü©, _‚ü©
  ¬∑ refine' hclosed.sdiff (isOpen_biUnion fun _ ‚Ü¶ _)
    exact fun ‚ü®Ub, _‚ü© ‚Ü¶ IsTopologicalBasis.isOpen bbasis Ub
  ¬∑ rw [preperfect_iff_nhds]
    intro x xD E xE
    have : ¬¨(E ‚à© D).Countable := by
      intro h
      obtain ‚ü®U, hUb, xU, hU‚ü© : ‚àÉ U ‚àà b, x ‚àà U ‚àß U ‚äÜ E :=
        (IsTopologicalBasis.mem_nhds_iff bbasis).mp xE
      have hU_cnt : (U ‚à© C).Countable := by
        apply @Countable.mono _ _ (E ‚à© D ‚à™ V ‚à© C)
        ¬∑ rintro y ‚ü®yU, yC‚ü©
          by_cases h : y ‚àà V
          ¬∑ exact mem_union_right _ (mem_inter h yC)
          ¬∑ exact mem_union_left _ (mem_inter (hU yU) ‚ü®yC, h‚ü©)
        exact Countable.union h Vct
      have : U ‚àà v := ‚ü®hUb, hU_cnt‚ü©
      apply xD.2
      exact mem_biUnion this xU
    by_contra! h
    exact absurd (Countable.mono h (Set.countable_singleton _)) this
  ¬∑ rw [inter_comm, inter_union_diff]",error:  simp made no progress,"theorem exists_countable_union_perfect_of_isClosed [SecondCountableTopology Œ±]
    (hclosed : IsClosed C) : ‚àÉ V D : Set Œ±, V.Countable ‚àß Perfect D ‚àß C = V ‚à™ D ",":= by
  obtain ‚ü®b, bct, _, bbasis‚ü© := TopologicalSpace.exists_countable_basis Œ±
  let v := { U ‚àà b | (U ‚à© C).Countable }
  let V := ‚ãÉ U ‚àà v, U
  let D := C \ V
  have Vct : (V ‚à© C).Countable := by
    simp only [V, iUnion_inter, mem_sep_iff]
    apply Countable.biUnion
    ¬∑ exact Countable.mono inter_subset_left bct
    ¬∑ exact inter_subset_right
  refine ‚ü®V ‚à© C, D, Vct, ‚ü®?_, ?_‚ü©, ?_‚ü©
  ¬∑ refine hclosed.sdiff (isOpen_biUnion fun _ ‚Ü¶ ?_)
    exact fun ‚ü®Ub, _‚ü© ‚Ü¶ IsTopologicalBasis.isOpen bbasis Ub
  ¬∑ rw [preperfect_iff_nhds]
    intro x xD E xE
    have : ¬¨(E ‚à© D).Countable := by
      intro h
      obtain ‚ü®U, hUb, xU, hU‚ü© : ‚àÉ U ‚àà b, x ‚àà U ‚àß U ‚äÜ E :=
        (IsTopologicalBasis.mem_nhds_iff bbasis).mp xE
      have hU_cnt : (U ‚à© C).Countable := by
        apply @Countable.mono _ _ (E ‚à© D ‚à™ V ‚à© C)
        ¬∑ rintro y ‚ü®yU, yC‚ü©
          by_cases h : y ‚àà V
          ¬∑ exact mem_union_right _ (mem_inter h yC)
          ¬∑ exact mem_union_left _ (mem_inter (hU yU) ‚ü®yC, h‚ü©)
        exact Countable.union h Vct
      have : U ‚àà v := ‚ü®hUb, hU_cnt‚ü©
      apply xD.2
      exact mem_biUnion this xU
    by_contra! h
    exact absurd (Countable.mono h (Set.countable_singleton _)) this
  ¬∑ rw [inter_comm, inter_union_diff]"
Mathlib/RingTheory/FinitePresentation.lean,RingHom.FinitePresentation.of_finiteType,of_finiteType,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  refine' ‚ü®fun h => _, Algebra.FiniteType.of_finitePresentation‚ü©
  obtain ‚ü®n, f, hf‚ü© := Algebra.FiniteType.iff_quotient_mvPolynomial''.1 h
  refine' ‚ü®n, f, hf, _‚ü©
  have hnoet : IsNoetherianRing (MvPolynomial (Fin n) R) := by infer_instance
  rw [isNoetherianRing_iff] at hnoet
  letI : Module (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R) := Semiring.toModule
  have := hnoet.noetherian (RingHom.ker f.toRingHom)
  convert this","error:  failed to synthesize
  FinitePresentation ?m.5343 ?m.5344
use `set_option diagnostics true` to get diagnostic information",theorem of_finiteType [IsNoetherianRing R] : FiniteType R A ‚Üî FinitePresentation R A ,":= by
  refine ‚ü®fun h => ?_, fun hfp => Algebra.FiniteType.of_finitePresentation‚ü©
  obtain ‚ü®n, f, hf‚ü© := Algebra.FiniteType.iff_quotient_mvPolynomial''.1 h
  refine ‚ü®n, f, hf, ?_‚ü©
  have hnoet : IsNoetherianRing (MvPolynomial (Fin n) R) := by infer_instance
  rw [isNoetherianRing_iff] at hnoet
  letI : Module (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R) := Semiring.toModule
  have := hnoet.noetherian (RingHom.ker f.toRingHom)
  convert this"
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.tendsto_Lp_of_tendsto_ae,tendsto_Lp_of_tendsto_ae,2a87032320c8a6441a601ba5b37374ff532cf9b9,":= by
  rw [ENNReal.tendsto_atTop_zero]
  intro Œµ hŒµ
  by_cases Œµ < ‚àû; swap
  ¬∑ rw [not_lt, top_le_iff] at h
    exact ‚ü®0, fun n _ => by simp [h]‚ü©
  by_cases hŒº : Œº = 0
  ¬∑ exact ‚ü®0, fun n _ => by simp [hŒº]‚ü©
  have hŒµ' : 0 < Œµ.toReal / 3 :=
    div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (by norm_num)
  have hdivp : 0 ‚â§ 1 / p.toReal := by
    refine' one_div_nonneg.2 _
    rw [‚Üê ENNReal.zero_toReal, ENNReal.toReal_le_toReal ENNReal.zero_ne_top hp']
    exact le_trans (zero_le _) hp
  have hpow : 0 < measureUnivNNReal Œº ^ (1 / p.toReal) :=
    Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
  obtain ‚ü®Œ¥‚ÇÅ, hŒ¥‚ÇÅ, hsnorm‚ÇÅ‚ü© := hui hŒµ'
  obtain ‚ü®Œ¥‚ÇÇ, hŒ¥‚ÇÇ, hsnorm‚ÇÇ‚ü© := hg'.snorm_indicator_le Œº hp hp' hŒµ'
  obtain ‚ü®t, htm, ht‚ÇÅ, ht‚ÇÇ‚ü© := tendstoUniformlyOn_of_ae_tendsto' hf hg hfg (lt_min hŒ¥‚ÇÅ hŒ¥‚ÇÇ)
  rw [Metric.tendstoUniformlyOn_iff] at ht‚ÇÇ
  specialize ht‚ÇÇ (Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    (div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (mul_pos (by norm_num) hpow))
  obtain ‚ü®N, hN‚ü© := eventually_atTop.1 ht‚ÇÇ; clear ht‚ÇÇ
  refine' ‚ü®N, fun n hn => _‚ü©
  rw [‚Üê t.indicator_self_add_compl (f n - g)]
  refine' le_trans (snorm_add_le (((hf n).sub hg).indicator htm).aestronglyMeasurable
    (((hf n).sub hg).indicator htm.compl).aestronglyMeasurable hp) _
  rw [sub_eq_add_neg, Set.indicator_add' t, Set.indicator_neg']
  refine' le_trans (add_le_add_right (snorm_add_le ((hf n).indicator htm).aestronglyMeasurable
    (hg.indicator htm).neg.aestronglyMeasurable hp) _) _
  have hnf : snorm (t.indicator (f n)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine' hsnorm‚ÇÅ n t htm (le_trans ht‚ÇÅ _)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÅ.le]
    exact min_le_left _ _
  have hng : snorm (t.indicator g) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine' hsnorm‚ÇÇ t htm (le_trans ht‚ÇÅ _)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÇ.le]
    exact min_le_right _ _
  have hlt : snorm (t·∂ú.indicator (f n - g)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    specialize hN n hn
    have : 0 ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)) := by
      rw [div_mul_eq_div_mul_one_div]
      exact mul_nonneg hŒµ'.le (one_div_nonneg.2 hpow.le)
    have := snorm_sub_le_of_dist_bdd Œº hp' htm.compl this fun x hx =>
      (dist_comm (g x) (f n x) ‚ñ∏ (hN x hx).le :
        dist (f n x) (g x) ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    refine' le_trans this _
    rw [div_mul_eq_div_mul_one_div, ‚Üê ENNReal.ofReal_toReal (measure_lt_top Œº (t·∂ú)).ne,
      ENNReal.ofReal_rpow_of_nonneg ENNReal.toReal_nonneg hdivp, ‚Üê ENNReal.ofReal_mul, mul_assoc]
    ¬∑ refine' ENNReal.ofReal_le_ofReal (mul_le_of_le_one_right hŒµ'.le _)
      rw [mul_comm, mul_one_div, div_le_one]
      ¬∑ refine' Real.rpow_le_rpow ENNReal.toReal_nonneg
          (ENNReal.toReal_le_of_le_ofReal (measureUnivNNReal_pos hŒº).le _) hdivp
        rw [ENNReal.ofReal_coe_nnreal, coe_measureUnivNNReal]
        exact measure_mono (Set.subset_univ _)
      ¬∑ exact Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
    ¬∑ refine' mul_nonneg hŒµ'.le (one_div_nonneg.2 hpow.le)
  have : ENNReal.ofReal (Œµ.toReal / 3) = Œµ / 3 := by
    rw [ENNReal.ofReal_div_of_pos (show (0 : ‚Ñù) < 3 by norm_num), ENNReal.ofReal_toReal h.ne]
    simp
  rw [this] at hnf hng hlt
  rw [snorm_neg, ‚Üê ENNReal.add_thirds Œµ, ‚Üê sub_eq_add_neg]
  exact add_le_add_three hnf hng hlt","error:  unknown identifier 'h'
error:  unknown identifier 'h.ne'
error:  application type mismatch
  Mem‚Ñíp.snorm_indicator_le Œº
argument
  Œº
has type
  Measure Œ± : Type u_1
but is expected to have type
  1 ‚â§ ?m.123854 : Prop
error:  rcases tactic failed: x‚úù : ?m.125515 is not an inductive datatype","theorem tendsto_Lp_of_tendsto_ae_of_meas [IsFiniteMeasure Œº] (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû)
    {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (hf : ‚àÄ n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g)
    (hg' : Mem‚Ñíp g p Œº) (hui : UnifIntegrable f p Œº)
    (hfg : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (g x))) :
    Tendsto (fun n => snorm (f n - g) p Œº) atTop (ùìù 0) ",":= by
  rw [ENNReal.tendsto_atTop_zero]
  intro Œµ hŒµ
  by_cases h : Œµ < ‚àû; swap
  ¬∑ rw [not_lt, top_le_iff] at h
    exact ‚ü®0, fun n _ => by simp [h]‚ü©
  by_cases hŒº : Œº = 0
  ¬∑ exact ‚ü®0, fun n _ => by simp [hŒº]‚ü©
  have hŒµ' : 0 < Œµ.toReal / 3 :=
    div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (by norm_num)
  have hdivp : 0 ‚â§ 1 / p.toReal := by
    refine one_div_nonneg.2 ?_
    rw [‚Üê ENNReal.zero_toReal, ENNReal.toReal_le_toReal ENNReal.zero_ne_top hp']
    exact le_trans (zero_le _) hp
  have hpow : 0 < measureUnivNNReal Œº ^ (1 / p.toReal) :=
    Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
  obtain ‚ü®Œ¥‚ÇÅ, hŒ¥‚ÇÅ, hsnorm‚ÇÅ‚ü© := hui hŒµ'
  obtain ‚ü®Œ¥‚ÇÇ, hŒ¥‚ÇÇ, hsnorm‚ÇÇ‚ü© := hg'.snorm_indicator_le hp hp' hŒµ'
  obtain ‚ü®t, htm, ht‚ÇÅ, ht‚ÇÇ‚ü© := tendstoUniformlyOn_of_ae_tendsto' hf hg hfg (lt_min hŒ¥‚ÇÅ hŒ¥‚ÇÇ)
  rw [Metric.tendstoUniformlyOn_iff] at ht‚ÇÇ
  specialize ht‚ÇÇ (Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    (div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (mul_pos (by norm_num) hpow))
  obtain ‚ü®N, hN‚ü© := eventually_atTop.1 ht‚ÇÇ; clear ht‚ÇÇ
  refine ‚ü®N, fun n hn => ?_‚ü©
  rw [‚Üê t.indicator_self_add_compl (f n - g)]
  refine le_trans (snorm_add_le (((hf n).sub hg).indicator htm).aestronglyMeasurable
    (((hf n).sub hg).indicator htm.compl).aestronglyMeasurable hp) ?_
  rw [sub_eq_add_neg, Set.indicator_add' t, Set.indicator_neg']
  refine le_trans (add_le_add_right (snorm_add_le ((hf n).indicator htm).aestronglyMeasurable
    (hg.indicator htm).neg.aestronglyMeasurable hp) _) ?_
  have hnf : snorm (t.indicator (f n)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine hsnorm‚ÇÅ n t htm (le_trans ht‚ÇÅ ?_)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÅ.le]
    exact min_le_left _ _
  have hng : snorm (t.indicator g) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    refine hsnorm‚ÇÇ t htm (le_trans ht‚ÇÅ ?_)
    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÇ.le]
    exact min_le_right _ _
  have hlt : snorm (t·∂ú.indicator (f n - g)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by
    specialize hN n hn
    have : 0 ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)) := by positivity
    have := snorm_sub_le_of_dist_bdd Œº hp' htm.compl this fun x hx =>
      (dist_comm (g x) (f n x) ‚ñ∏ (hN x hx).le :
        dist (f n x) (g x) ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))
    refine le_trans this ?_
    rw [div_mul_eq_div_mul_one_div, ‚Üê ENNReal.ofReal_toReal (measure_lt_top Œº t·∂ú).ne,
      ENNReal.ofReal_rpow_of_nonneg ENNReal.toReal_nonneg hdivp, ‚Üê ENNReal.ofReal_mul, mul_assoc]
    ¬∑ refine ENNReal.ofReal_le_ofReal (mul_le_of_le_one_right hŒµ'.le ?_)
      rw [mul_comm, mul_one_div, div_le_one]
      ¬∑ refine Real.rpow_le_rpow ENNReal.toReal_nonneg
          (ENNReal.toReal_le_of_le_ofReal (measureUnivNNReal_pos hŒº).le ?_) hdivp
        rw [ENNReal.ofReal_coe_nnreal, coe_measureUnivNNReal]
        exact measure_mono (Set.subset_univ _)
      ¬∑ exact Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _
    ¬∑ positivity
  have : ENNReal.ofReal (Œµ.toReal / 3) = Œµ / 3 := by
    rw [ENNReal.ofReal_div_of_pos (show (0 : ‚Ñù) < 3 by norm_num), ENNReal.ofReal_toReal h.ne]
    simp
  rw [this] at hnf hng hlt
  rw [snorm_neg, ‚Üê ENNReal.add_thirds Œµ, ‚Üê sub_eq_add_neg]
  exact add_le_add_three hnf hng hlt"
Mathlib/MeasureTheory/Function/L1Space.lean,MeasureTheory.integrable_finset_sum,integrable_finset_sum,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction s <;> simp [*]","error:  unsolved goals
case mk
Œ± : Type u_1
Œ≤ : Type u_2
Œ≥ : Type u_3
Œ¥ : Type u_4
m‚úù : MeasurableSpace Œ±
Œº‚úù ŒΩ : Measure Œ±
inst‚úù¬≤ : MeasurableSpace Œ¥
inst‚úù¬π : NormedAddCommGroup Œ≤
inst‚úù : NormedAddCommGroup Œ≥
Œπ : Type u_5
m : MeasurableSpace Œ±
f : Œ± ‚Üí Œ≤
Œº : Œπ ‚Üí Measure Œ±
val‚úù : Multiset Œπ
nodup‚úù : val‚úù.Nodup
‚ä¢ Integrable f (Multiset.map (fun i ‚Ü¶ Œº i) val‚úù).sum ‚Üî ‚àÄ i ‚àà val‚úù, Integrable f (Œº i)","theorem integrable_finset_sum_measure {Œπ} {m : MeasurableSpace Œ±} {f : Œ± ‚Üí Œ≤} {Œº : Œπ ‚Üí Measure Œ±}
    {s : Finset Œπ} : Integrable f (‚àë i ‚àà s, Œº i) ‚Üî ‚àÄ i ‚àà s, Integrable f (Œº i) ",":= by
  induction s using Finset.induction_on <;> simp [*]"
Mathlib/AlgebraicGeometry/EllipticCurve/Weierstrass.lean,EllipticCurve.variableChange_j,variableChange_j,3399e7d92a1792fd30f4f6e0f21c3f0b5ee901f6,":= by
  rw [j, coe_inv_variableChange_Œî']
  have hu : (C.u * ‚ÜëC.u‚Åª¬π : R) ^ 12 = 1 := by rw [C.u.mul_inv, one_pow]
  linear_combination (norm := (rw [variableChange_toWeierstrassCurve,
    WeierstrassCurve.variableChange_c‚ÇÑ, j]; ring1)) E.j * hu","error:  ring failed, ring expressions not equal
R : Type u
inst‚úù : CommRing R
E : EllipticCurve R
C : WeierstrassCurve.VariableChange R
hu : (‚ÜëC.u * ‚ÜëC.u‚Åª¬π) ^ 12 = 1
‚ä¢ ‚Üë(C.u ^ 12 * E.Œî'‚Åª¬π) * ‚ÜëC.u‚Åª¬π ^ 12 * E.c‚ÇÑ ^ 3 - ‚ÜëC.u‚Åª¬π ^ 12 * E.c‚ÇÑ ^ 3 * ‚ÜëE.Œî'‚Åª¬π * ‚ÜëC.u ^ 12 = 0",lemma variableChange_j : (E.variableChange C).j = E.j ,":= by
  rw [j, coe_inv_variableChange_Œî', Units.val_mul, Units.val_pow_eq_pow_val,
    variableChange_toWeierstrassCurve, WeierstrassCurve.variableChange_c‚ÇÑ]
  have hu : (C.u * C.u‚Åª¬π : R) ^ 12 = 1 := by rw [C.u.mul_inv, one_pow]
  linear_combination (norm := (rw [j]; ring1)) E.j * hu"
Mathlib/MeasureTheory/Function/Jacobian.lean,ApproximatesLinearOn.norm_fderiv_sub_le,_root_.ApproximatesLinearOn.norm_fderiv_sub_le,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.op_norm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ
  ¬∑ have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by continuity) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 (IsLittleO.def (hf' x xs) Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset bounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel'_right]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := (norm_add_le _ _)
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel', sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := (norm_sub_le _ _)
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel', norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
        mul_le_mul_of_nonneg_left norm_a (mul_nonneg rpos.le (add_nonneg Œ¥.2 Œµpos.le))
  show ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ;
  exact
    calc
      ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
        congr 1
        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
        abel
      _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := (norm_add_le _ _)
      _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
        apply add_le_add
        ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
        ¬∑ apply ContinuousLinearMap.le_op_norm
      _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ :=
        add_le_add le_rfl
          (mul_le_mul_of_nonneg_left (mem_closedBall_iff_norm'.1 az) (norm_nonneg _))",error:  unexpected token '¬∑'; expected 'by' or 'from',"theorem _root_.ApproximatesLinearOn.norm_fderiv_sub_le {A : E ‚ÜíL[‚Ñù] E} {Œ¥ : ‚Ñù‚â•0}
    (hf : ApproximatesLinearOn f A s Œ¥) (hs : MeasurableSet s) (f' : E ‚Üí E ‚ÜíL[‚Ñù] E)
    (hf' : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) : ‚àÄ·µê x ‚àÇŒº.restrict s, ‚Äñf' x - A‚Äñ‚Çä ‚â§ Œ¥ ",":= by
  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Œº s, ae_restrict_mem hs]
  intro x hx xs
  apply ContinuousLinearMap.opNorm_le_bound _ Œ¥.2 fun z => ?_
  suffices H : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚Äñ(f' x - A) z‚Äñ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ by
    have :
      Tendsto (fun Œµ : ‚Ñù => ((Œ¥ : ‚Ñù) + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ) (ùìù[>] 0)
        (ùìù ((Œ¥ + 0) * (‚Äñz‚Äñ + 0) + ‚Äñf' x - A‚Äñ * 0)) :=
      Tendsto.mono_left (Continuous.tendsto (by fun_prop) 0) nhdsWithin_le_nhds
    simp only [add_zero, mul_zero] at this
    apply le_of_tendsto_of_tendsto tendsto_const_nhds this
    filter_upwards [self_mem_nhdsWithin]
    exact H
  intro Œµ Œµpos
  have B‚ÇÅ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty :=
    eventually_nonempty_inter_smul_of_density_one Œº s x hx _ measurableSet_closedBall
      (measure_closedBall_pos Œº z Œµpos).ne'
  obtain ‚ü®œÅ, œÅpos, hœÅ‚ü© :
    ‚àÉ œÅ > 0, ball x œÅ ‚à© s ‚äÜ {y : E | ‚Äñf y - f x - (f' x) (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ} :=
    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Œµpos)
  have B‚ÇÇ : ‚àÄ·∂† r in ùìù[>] (0 : ‚Ñù), {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ := by
    apply nhdsWithin_le_nhds
    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x œÅpos)
  obtain ‚ü®r, ‚ü®y, ‚ü®ys, hy‚ü©‚ü©, rœÅ, rpos‚ü© :
    ‚àÉ r : ‚Ñù,
      (s ‚à© ({x} + r ‚Ä¢ closedBall z Œµ)).Nonempty ‚àß {x} + r ‚Ä¢ closedBall z Œµ ‚äÜ ball x œÅ ‚àß 0 < r :=
    (B‚ÇÅ.and (B‚ÇÇ.and self_mem_nhdsWithin)).exists
  obtain ‚ü®a, az, ya‚ü© : ‚àÉ a, a ‚àà closedBall z Œµ ‚àß y = x + r ‚Ä¢ a := by
    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy
    rcases hy with ‚ü®a, az, ha‚ü©
    exact ‚ü®a, az, by simp only [ha, add_neg_cancel_left]‚ü©
  have norm_a : ‚Äña‚Äñ ‚â§ ‚Äñz‚Äñ + Œµ :=
    calc
      ‚Äña‚Äñ = ‚Äñz + (a - z)‚Äñ := by simp only [add_sub_cancel]
      _ ‚â§ ‚Äñz‚Äñ + ‚Äña - z‚Äñ := norm_add_le _ _
      _ ‚â§ ‚Äñz‚Äñ + Œµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _
  have I : r * ‚Äñ(f' x - A) a‚Äñ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) :=
    calc
      r * ‚Äñ(f' x - A) a‚Äñ = ‚Äñ(f' x - A) (r ‚Ä¢ a)‚Äñ := by
        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
      _ = ‚Äñf y - f x - A (y - x) - (f y - f x - (f' x) (y - x))‚Äñ := by
        congr 1
        simp only [ya, add_sub_cancel_left, sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',
          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]
      _ ‚â§ ‚Äñf y - f x - A (y - x)‚Äñ + ‚Äñf y - f x - (f' x) (y - x)‚Äñ := norm_sub_le _ _
      _ ‚â§ Œ¥ * ‚Äñy - x‚Äñ + Œµ * ‚Äñy - x‚Äñ := (add_le_add (hf _ ys _ xs) (hœÅ ‚ü®rœÅ hy, ys‚ü©))
      _ = r * (Œ¥ + Œµ) * ‚Äña‚Äñ := by
        simp only [ya, add_sub_cancel_left, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]
        ring
      _ ‚â§ r * (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) := by gcongr
  calc
    ‚Äñ(f' x - A) z‚Äñ = ‚Äñ(f' x - A) a + (f' x - A) (z - a)‚Äñ := by
      congr 1
      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]
      abel
    _ ‚â§ ‚Äñ(f' x - A) a‚Äñ + ‚Äñ(f' x - A) (z - a)‚Äñ := norm_add_le _ _
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * ‚Äñz - a‚Äñ := by
      apply add_le_add
      ¬∑ rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I
      ¬∑ apply ContinuousLinearMap.le_opNorm
    _ ‚â§ (Œ¥ + Œµ) * (‚Äñz‚Äñ + Œµ) + ‚Äñf' x - A‚Äñ * Œµ := by
      rw [mem_closedBall_iff_norm'] at az
      gcongr"
Mathlib/GroupTheory/OrderOfElement.lean,orderOf_pos,orderOf_pos,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  minimalPeriod_pos_of_mem_periodicPts h",error:  unknown identifier 'h',theorem orderOf_pos_iff : 0 < orderOf x ‚Üî IsOfFinOrder x ,":= by
  rw [iff_not_comm.mp orderOf_eq_zero_iff, pos_iff_ne_zero]"
